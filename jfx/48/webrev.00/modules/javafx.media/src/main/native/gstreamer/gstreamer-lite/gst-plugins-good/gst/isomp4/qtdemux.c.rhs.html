<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/isomp4/qtdemux.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 /* GStreamer
    2  * Copyright (C) &lt;1999&gt; Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
    3  * Copyright (C) &lt;2003&gt; David A. Schleef &lt;ds@schleef.org&gt;
    4  * Copyright (C) &lt;2006&gt; Wim Taymans &lt;wim@fluendo.com&gt;
    5  * Copyright (C) &lt;2007&gt; Julien Moutte &lt;julien@fluendo.com&gt;
    6  * Copyright (C) &lt;2009&gt; Tim-Philipp MÃ¼ller &lt;tim centricular net&gt;
    7  * Copyright (C) &lt;2009&gt; STEricsson &lt;benjamin.gaignard@stericsson.com&gt;
    8  * Copyright (C) &lt;2013&gt; Sreerenj Balachandran &lt;sreerenj.balachandran@intel.com&gt;
    9  * Copyright (C) &lt;2013&gt; Intel Corporation
   10  * Copyright (C) &lt;2014&gt; Centricular Ltd
   11  * Copyright (C) &lt;2015&gt; YouView TV Ltd.
   12  * Copyright (C) &lt;2016&gt; British Broadcasting Corporation
   13  *
   14  * This library is free software; you can redistribute it and/or
   15  * modify it under the terms of the GNU Library General Public
   16  * License as published by the Free Software Foundation; either
   17  * version 2 of the License, or (at your option) any later version.
   18  *
   19  * This library is distributed in the hope that it will be useful,
   20  * but WITHOUT ANY WARRANTY; without even the implied warranty of
   21  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   22  * Library General Public License for more details.
   23  *
   24  * You should have received a copy of the GNU Library General Public
   25  * License along with this library; if not, write to the
   26  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
   27  * Boston, MA 02110-1301, USA.
   28  */
   29 
   30 /**
   31  * SECTION:element-qtdemux
   32  *
   33  * Demuxes a .mov file into raw or compressed audio and/or video streams.
   34  *
   35  * This element supports both push and pull-based scheduling, depending on the
   36  * capabilities of the upstream elements.
   37  *
   38  * &lt;refsect2&gt;
   39  * &lt;title&gt;Example launch line&lt;/title&gt;
   40  * |[
   41  * gst-launch-1.0 filesrc location=test.mov ! qtdemux name=demux  demux.audio_0 ! queue ! decodebin ! audioconvert ! audioresample ! autoaudiosink   demux.video_0 ! queue ! decodebin ! videoconvert ! videoscale ! autovideosink
   42  * ]| Play (parse and decode) a .mov file and try to output it to
   43  * an automatically detected soundcard and videosink. If the MOV file contains
   44  * compressed audio or video data, this will only work if you have the
   45  * right decoder elements/plugins installed.
   46  * &lt;/refsect2&gt;
   47  */
   48 
   49 #ifdef HAVE_CONFIG_H
   50 #include &quot;config.h&quot;
   51 #endif
   52 
   53 #include &quot;gst/gst-i18n-plugin.h&quot;
   54 
   55 #include &lt;glib/gprintf.h&gt;
   56 #include &lt;gst/tag/tag.h&gt;
   57 #include &lt;gst/audio/audio.h&gt;
   58 #include &lt;gst/video/video.h&gt;
   59 #include &lt;gst/riff/riff.h&gt;
   60 #include &lt;gst/pbutils/pbutils.h&gt;
   61 
   62 #include &quot;qtatomparser.h&quot;
   63 #include &quot;qtdemux_types.h&quot;
   64 #include &quot;qtdemux_dump.h&quot;
   65 #include &quot;fourcc.h&quot;
   66 #include &quot;descriptors.h&quot;
   67 #include &quot;qtdemux_lang.h&quot;
   68 #include &quot;qtdemux.h&quot;
   69 #include &quot;qtpalette.h&quot;
   70 
   71 #include &lt;stdio.h&gt;
   72 #include &lt;stdlib.h&gt;
   73 #include &lt;string.h&gt;
   74 
   75 #include &lt;math.h&gt;
   76 #include &lt;gst/math-compat.h&gt;
   77 
   78 #ifdef HAVE_ZLIB
   79 # include &lt;zlib.h&gt;
   80 #endif
   81 
   82 /* max. size considered &#39;sane&#39; for non-mdat atoms */
   83 #define QTDEMUX_MAX_ATOM_SIZE (25*1024*1024)
   84 
   85 /* if the sample index is larger than this, something is likely wrong */
   86 #ifdef GSTREAMER_LITE
   87 // relaxing the limitation since some long files has more than 50Mb sample index
   88 #define QTDEMUX_MAX_SAMPLE_INDEX_SIZE (500*1024*1024)
   89 #else
   90 #define QTDEMUX_MAX_SAMPLE_INDEX_SIZE (200*1024*1024)
   91 #endif // GSTREAMER_LITE
   92 
   93 /* For converting qt creation times to unix epoch times */
   94 #define QTDEMUX_SECONDS_PER_DAY (60 * 60 * 24)
   95 #define QTDEMUX_LEAP_YEARS_FROM_1904_TO_1970 17
   96 #define QTDEMUX_SECONDS_FROM_1904_TO_1970 (((1970 - 1904) * (guint64) 365 + \
   97     QTDEMUX_LEAP_YEARS_FROM_1904_TO_1970) * QTDEMUX_SECONDS_PER_DAY)
   98 
   99 #define QTDEMUX_TREE_NODE_FOURCC(n) (QT_FOURCC(((guint8 *) (n)-&gt;data) + 4))
  100 
<a name="1" id="anc1"></a><span class="line-modified">  101 #define STREAM_IS_EOS(s) ((s)-&gt;time_position == GST_CLOCK_TIME_NONE)</span>
  102 
  103 #define ABSDIFF(x, y) ( (x) &gt; (y) ? ((x) - (y)) : ((y) - (x)) )
  104 
<a name="2" id="anc2"></a><span class="line-added">  105 #define QTDEMUX_STREAM(s) ((QtDemuxStream *)(s))</span>
<span class="line-added">  106 #define QTDEMUX_N_STREAMS(demux) ((demux)-&gt;active_streams-&gt;len)</span>
<span class="line-added">  107 #define QTDEMUX_NTH_STREAM(demux,idx) \</span>
<span class="line-added">  108    QTDEMUX_STREAM(g_ptr_array_index((demux)-&gt;active_streams,idx))</span>
<span class="line-added">  109 #define QTDEMUX_NTH_OLD_STREAM(demux,idx) \</span>
<span class="line-added">  110    QTDEMUX_STREAM(g_ptr_array_index((demux)-&gt;old_streams,idx))</span>
<span class="line-added">  111 </span>
  112 GST_DEBUG_CATEGORY (qtdemux_debug);
  113 #define GST_CAT_DEFAULT qtdemux_debug
  114 
  115 typedef struct _QtDemuxSegment QtDemuxSegment;
  116 typedef struct _QtDemuxSample QtDemuxSample;
  117 
  118 typedef struct _QtDemuxCencSampleSetInfo QtDemuxCencSampleSetInfo;
  119 
  120 struct _QtDemuxSample
  121 {
  122   guint32 size;
  123   gint32 pts_offset;            /* Add this value to timestamp to get the pts */
  124   guint64 offset;
  125   guint64 timestamp;            /* DTS In mov time */
  126   guint32 duration;             /* In mov time */
  127   gboolean keyframe;            /* TRUE when this packet is a keyframe */
  128 };
  129 
  130 /* Macros for converting to/from timescale */
  131 #define QTSTREAMTIME_TO_GSTTIME(stream, value) (gst_util_uint64_scale((value), GST_SECOND, (stream)-&gt;timescale))
  132 #define GSTTIME_TO_QTSTREAMTIME(stream, value) (gst_util_uint64_scale((value), (stream)-&gt;timescale, GST_SECOND))
  133 
  134 #define QTTIME_TO_GSTTIME(qtdemux, value) (gst_util_uint64_scale((value), GST_SECOND, (qtdemux)-&gt;timescale))
  135 #define GSTTIME_TO_QTTIME(qtdemux, value) (gst_util_uint64_scale((value), (qtdemux)-&gt;timescale, GST_SECOND))
  136 
  137 /* timestamp is the DTS */
  138 #define QTSAMPLE_DTS(stream,sample) (QTSTREAMTIME_TO_GSTTIME((stream), (sample)-&gt;timestamp))
  139 /* timestamp + offset + cslg_shift is the outgoing PTS */
  140 #define QTSAMPLE_PTS(stream,sample) (QTSTREAMTIME_TO_GSTTIME((stream), (sample)-&gt;timestamp + (stream)-&gt;cslg_shift + (sample)-&gt;pts_offset))
  141 /* timestamp + offset is the PTS used for internal seek calcuations */
  142 #define QTSAMPLE_PTS_NO_CSLG(stream,sample) (QTSTREAMTIME_TO_GSTTIME((stream), (sample)-&gt;timestamp + (sample)-&gt;pts_offset))
  143 /* timestamp + duration - dts is the duration */
  144 #define QTSAMPLE_DUR_DTS(stream, sample, dts) (QTSTREAMTIME_TO_GSTTIME ((stream), (sample)-&gt;timestamp + (sample)-&gt;duration) - (dts))
  145 
  146 #define QTSAMPLE_KEYFRAME(stream,sample) ((stream)-&gt;all_keyframe || (sample)-&gt;keyframe)
  147 
<a name="3" id="anc3"></a><span class="line-added">  148 #define QTDEMUX_EXPOSE_GET_LOCK(demux) (&amp;((demux)-&gt;expose_lock))</span>
<span class="line-added">  149 #define QTDEMUX_EXPOSE_LOCK(demux) G_STMT_START { \</span>
<span class="line-added">  150     GST_TRACE(&quot;Locking from thread %p&quot;, g_thread_self()); \</span>
<span class="line-added">  151     g_mutex_lock (QTDEMUX_EXPOSE_GET_LOCK (demux)); \</span>
<span class="line-added">  152     GST_TRACE(&quot;Locked from thread %p&quot;, g_thread_self()); \</span>
<span class="line-added">  153  } G_STMT_END</span>
<span class="line-added">  154 </span>
<span class="line-added">  155 #define QTDEMUX_EXPOSE_UNLOCK(demux) G_STMT_START { \</span>
<span class="line-added">  156     GST_TRACE(&quot;Unlocking from thread %p&quot;, g_thread_self()); \</span>
<span class="line-added">  157     g_mutex_unlock (QTDEMUX_EXPOSE_GET_LOCK (demux)); \</span>
<span class="line-added">  158  } G_STMT_END</span>
<span class="line-added">  159 </span>
  160 /*
  161  * Quicktime has tracks and segments. A track is a continuous piece of
  162  * multimedia content. The track is not always played from start to finish but
  163  * instead, pieces of the track are &#39;cut out&#39; and played in sequence. This is
  164  * what the segments do.
  165  *
  166  * Inside the track we have keyframes (K) and delta frames. The track has its
  167  * own timing, which starts from 0 and extends to end. The position in the track
  168  * is called the media_time.
  169  *
  170  * The segments now describe the pieces that should be played from this track
  171  * and are basically tuples of media_time/duration/rate entries. We can have
  172  * multiple segments and they are all played after one another. An example:
  173  *
  174  * segment 1: media_time: 1 second, duration: 1 second, rate 1
  175  * segment 2: media_time: 3 second, duration: 2 second, rate 2
  176  *
  177  * To correctly play back this track, one must play: 1 second of media starting
  178  * from media_time 1 followed by 2 seconds of media starting from media_time 3
  179  * at a rate of 2.
  180  *
  181  * Each of the segments will be played at a specific time, the first segment at
  182  * time 0, the second one after the duration of the first one, etc.. Note that
  183  * the time in resulting playback is not identical to the media_time of the
  184  * track anymore.
  185  *
  186  * Visually, assuming the track has 4 second of media_time:
  187  *
  188  *                (a)                   (b)          (c)              (d)
  189  *         .-----------------------------------------------------------.
  190  * track:  | K.....K.........K........K.......K.......K...........K... |
  191  *         &#39;-----------------------------------------------------------&#39;
  192  *         0              1              2              3              4
  193  *           .------------^              ^   .----------^              ^
  194  *          /              .-------------&#39;  /       .------------------&#39;
  195  *         /              /          .-----&#39;       /
  196  *         .--------------.         .--------------.
  197  *         | segment 1    |         | segment 2    |
  198  *         &#39;--------------&#39;         &#39;--------------&#39;
  199  *
  200  * The challenge here is to cut out the right pieces of the track for each of
  201  * the playback segments. This fortunately can easily be done with the SEGMENT
  202  * events of GStreamer.
  203  *
  204  * For playback of segment 1, we need to provide the decoder with the keyframe
  205  * (a), in the above figure, but we must instruct it only to output the decoded
  206  * data between second 1 and 2. We do this with a SEGMENT event for 1 to 2, time
  207  * position set to the time of the segment: 0.
  208  *
  209  * We then proceed to push data from keyframe (a) to frame (b). The decoder
  210  * decodes but clips all before media_time 1.
  211  *
  212  * After finishing a segment, we push out a new SEGMENT event with the clipping
  213  * boundaries of the new data.
  214  *
  215  * This is a good usecase for the GStreamer accumulated SEGMENT events.
  216  */
  217 
  218 struct _QtDemuxSegment
  219 {
  220   /* global time and duration, all gst time */
  221   GstClockTime time;
  222   GstClockTime stop_time;
  223   GstClockTime duration;
  224   /* media time of trak, all gst time */
  225   GstClockTime media_start;
  226   GstClockTime media_stop;
  227   gdouble rate;
  228   /* Media start time in trak timescale units */
  229   guint32 trak_media_start;
  230 };
  231 
  232 #define QTSEGMENT_IS_EMPTY(s) ((s)-&gt;media_start == GST_CLOCK_TIME_NONE)
  233 
  234 /* Used with fragmented MP4 files (mfra atom) */
  235 typedef struct
  236 {
  237   GstClockTime ts;
  238   guint64 moof_offset;
  239 } QtDemuxRandomAccessEntry;
  240 
  241 typedef struct _QtDemuxStreamStsdEntry
  242 {
  243   GstCaps *caps;
  244   guint32 fourcc;
  245   gboolean sparse;
  246 
  247   /* video info */
  248   gint width;
  249   gint height;
  250   gint par_w;
  251   gint par_h;
  252   /* Numerator/denominator framerate */
  253   gint fps_n;
  254   gint fps_d;
  255   GstVideoColorimetry colorimetry;
  256   guint16 bits_per_sample;
  257   guint16 color_table_id;
  258   GstMemory *rgb8_palette;
  259   guint interlace_mode;
  260   guint field_order;
  261 
  262   /* audio info */
  263   gdouble rate;
  264   gint n_channels;
  265   guint samples_per_packet;
  266   guint samples_per_frame;
  267   guint bytes_per_packet;
  268   guint bytes_per_sample;
  269   guint bytes_per_frame;
  270   guint compression;
  271 
  272   /* if we use chunks or samples */
  273   gboolean sampled;
  274   guint padding;
  275 
  276 } QtDemuxStreamStsdEntry;
  277 
  278 #define CUR_STREAM(s) (&amp;((s)-&gt;stsd_entries[(s)-&gt;cur_stsd_entry_index]))
  279 
  280 struct _QtDemuxStream
  281 {
  282   GstPad *pad;
  283 
<a name="4" id="anc4"></a><span class="line-added">  284   GstQTDemux *demux;</span>
<span class="line-added">  285   gchar *stream_id;</span>
<span class="line-added">  286 </span>
  287   QtDemuxStreamStsdEntry *stsd_entries;
  288   guint stsd_entries_length;
  289   guint cur_stsd_entry_index;
  290 
  291   /* stream type */
  292   guint32 subtype;
  293 
  294   gboolean new_caps;            /* If TRUE, caps need to be generated (by
  295                                  * calling _configure_stream()) This happens
  296                                  * for MSS and fragmented streams */
  297 
  298   gboolean new_stream;          /* signals that a stream_start is required */
  299   gboolean on_keyframe;         /* if this stream last pushed buffer was a
  300                                  * keyframe. This is important to identify
  301                                  * where to stop pushing buffers after a
  302                                  * segment stop time */
  303 
  304   /* if the stream has a redirect URI in its headers, we store it here */
  305   gchar *redirect_uri;
  306 
  307   /* track id */
  308   guint track_id;
  309 #ifdef GSTREAMER_LITE
  310   gboolean track_enabled;
  311 #endif // GSTREAMER_LITE
  312 
  313   /* duration/scale */
  314   guint64 duration;             /* in timescale units */
  315   guint32 timescale;
  316 
  317   /* language */
  318   gchar lang_id[4];             /* ISO 639-2T language code */
  319 
  320   /* our samples */
  321   guint32 n_samples;
  322   QtDemuxSample *samples;
  323   gboolean all_keyframe;        /* TRUE when all samples are keyframes (no stss) */
<a name="5" id="anc5"></a>

  324   guint32 n_samples_moof;       /* sample count in a moof */
  325   guint64 duration_moof;        /* duration in timescale of a moof, used for figure out
  326                                  * the framerate of fragmented format stream */
  327   guint64 duration_last_moof;
  328 
  329   guint32 offset_in_sample;     /* Offset in the current sample, used for
  330                                  * streams which have got exceedingly big
  331                                  * sample size (such as 24s of raw audio).
  332                                  * Only used when max_buffer_size is non-NULL */
  333   guint32 max_buffer_size;      /* Maximum allowed size for output buffers.
  334                                  * Currently only set for raw audio streams*/
  335 
  336   /* video info */
  337   /* aspect ratio */
  338   gint display_width;
  339   gint display_height;
  340 
  341   /* allocation */
  342   gboolean use_allocator;
  343   GstAllocator *allocator;
  344   GstAllocationParams params;
  345 
  346   gsize alignment;
  347 
  348   /* when a discontinuity is pending */
  349   gboolean discont;
  350 
  351   /* list of buffers to push first */
  352   GSList *buffers;
  353 
  354   /* if we need to clip this buffer. This is only needed for uncompressed
  355    * data */
  356   gboolean need_clip;
  357 
  358   /* buffer needs some custom processing, e.g. subtitles */
  359   gboolean need_process;
<a name="6" id="anc6"></a><span class="line-added">  360   /* buffer needs potentially be split, e.g. CEA608 subtitles */</span>
<span class="line-added">  361   gboolean need_split;</span>
  362 
  363   /* current position */
  364   guint32 segment_index;
  365   guint32 sample_index;
  366   GstClockTime time_position;   /* in gst time */
  367   guint64 accumulated_base;
  368 
  369   /* the Gst segment we are processing out, used for clipping */
  370   GstSegment segment;
  371 
  372   /* quicktime segments */
  373   guint32 n_segments;
  374   QtDemuxSegment *segments;
  375   gboolean dummy_segment;
  376   guint32 from_sample;
  377   guint32 to_sample;
  378 
  379   gboolean sent_eos;
  380   GstTagList *stream_tags;
  381   gboolean send_global_tags;
  382 
  383   GstEvent *pending_event;
  384 
  385   GstByteReader stco;
  386   GstByteReader stsz;
  387   GstByteReader stsc;
  388   GstByteReader stts;
  389   GstByteReader stss;
  390   GstByteReader stps;
  391   GstByteReader ctts;
  392 
  393   gboolean chunks_are_samples;  /* TRUE means treat chunks as samples */
  394   gint64 stbl_index;
  395   /* stco */
  396   guint co_size;
  397   GstByteReader co_chunk;
  398   guint32 first_chunk;
  399   guint32 current_chunk;
  400   guint32 last_chunk;
  401   guint32 samples_per_chunk;
  402   guint32 stsd_sample_description_id;
  403   guint32 stco_sample_index;
  404   /* stsz */
  405   guint32 sample_size;          /* 0 means variable sizes are stored in stsz */
  406   /* stsc */
  407   guint32 stsc_index;
  408   guint32 n_samples_per_chunk;
  409   guint32 stsc_chunk_index;
  410   guint32 stsc_sample_index;
  411   guint64 chunk_offset;
  412   /* stts */
  413   guint32 stts_index;
  414   guint32 stts_samples;
  415   guint32 n_sample_times;
  416   guint32 stts_sample_index;
  417   guint64 stts_time;
  418   guint32 stts_duration;
  419   /* stss */
  420   gboolean stss_present;
  421   guint32 n_sample_syncs;
  422   guint32 stss_index;
  423   /* stps */
  424   gboolean stps_present;
  425   guint32 n_sample_partial_syncs;
  426   guint32 stps_index;
  427   QtDemuxRandomAccessEntry *ra_entries;
  428   guint n_ra_entries;
  429 
  430   const QtDemuxRandomAccessEntry *pending_seek;
  431 
  432   /* ctts */
  433   gboolean ctts_present;
  434   guint32 n_composition_times;
  435   guint32 ctts_index;
  436   guint32 ctts_sample_index;
  437   guint32 ctts_count;
  438   gint32 ctts_soffset;
  439 
  440   /* cslg */
  441   guint32 cslg_shift;
  442 
  443   /* fragmented */
  444   gboolean parsed_trex;
  445   guint32 def_sample_description_index; /* index is 1-based */
  446   guint32 def_sample_duration;
  447   guint32 def_sample_size;
  448   guint32 def_sample_flags;
  449 
  450   gboolean disabled;
  451 
  452   /* stereoscopic video streams */
  453   GstVideoMultiviewMode multiview_mode;
  454   GstVideoMultiviewFlags multiview_flags;
  455 
  456   /* protected streams */
  457   gboolean protected;
  458   guint32 protection_scheme_type;
  459   guint32 protection_scheme_version;
  460   gpointer protection_scheme_info;      /* specific to the protection scheme */
  461   GQueue protection_scheme_event_queue;
<a name="7" id="anc7"></a><span class="line-added">  462 </span>
<span class="line-added">  463   gint ref_count;               /* atomic */</span>
  464 };
  465 
  466 /* Contains properties and cryptographic info for a set of samples from a
  467  * track protected using Common Encryption (cenc) */
  468 struct _QtDemuxCencSampleSetInfo
  469 {
  470   GstStructure *default_properties;
  471 
  472   /* @crypto_info holds one GstStructure per sample */
  473   GPtrArray *crypto_info;
  474 };
  475 
  476 static const gchar *
  477 qt_demux_state_string (enum QtDemuxState state)
  478 {
  479   switch (state) {
  480     case QTDEMUX_STATE_INITIAL:
  481       return &quot;&lt;INITIAL&gt;&quot;;
  482     case QTDEMUX_STATE_HEADER:
  483       return &quot;&lt;HEADER&gt;&quot;;
  484     case QTDEMUX_STATE_MOVIE:
  485       return &quot;&lt;MOVIE&gt;&quot;;
  486     case QTDEMUX_STATE_BUFFER_MDAT:
  487       return &quot;&lt;BUFFER_MDAT&gt;&quot;;
  488     default:
  489       return &quot;&lt;UNKNOWN&gt;&quot;;
  490   }
  491 }
  492 
  493 static GNode *qtdemux_tree_get_child_by_type (GNode * node, guint32 fourcc);
  494 static GNode *qtdemux_tree_get_child_by_type_full (GNode * node,
  495     guint32 fourcc, GstByteReader * parser);
  496 static GNode *qtdemux_tree_get_sibling_by_type (GNode * node, guint32 fourcc);
  497 static GNode *qtdemux_tree_get_sibling_by_type_full (GNode * node,
  498     guint32 fourcc, GstByteReader * parser);
  499 
  500 static GstFlowReturn qtdemux_add_fragmented_samples (GstQTDemux * qtdemux);
  501 
<a name="8" id="anc8"></a><span class="line-added">  502 static void gst_qtdemux_check_send_pending_segment (GstQTDemux * demux);</span>
<span class="line-added">  503 </span>
  504 static GstStaticPadTemplate gst_qtdemux_sink_template =
  505     GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,
  506     GST_PAD_SINK,
  507     GST_PAD_ALWAYS,
  508     GST_STATIC_CAPS (&quot;video/quicktime; video/mj2; audio/x-m4a; &quot;
  509         &quot;application/x-3gp&quot;)
  510     );
  511 
  512 static GstStaticPadTemplate gst_qtdemux_videosrc_template =
  513 GST_STATIC_PAD_TEMPLATE (&quot;video_%u&quot;,
  514     GST_PAD_SRC,
  515     GST_PAD_SOMETIMES,
  516     GST_STATIC_CAPS_ANY);
  517 
  518 static GstStaticPadTemplate gst_qtdemux_audiosrc_template =
  519 GST_STATIC_PAD_TEMPLATE (&quot;audio_%u&quot;,
  520     GST_PAD_SRC,
  521     GST_PAD_SOMETIMES,
  522     GST_STATIC_CAPS_ANY);
  523 
  524 static GstStaticPadTemplate gst_qtdemux_subsrc_template =
  525 GST_STATIC_PAD_TEMPLATE (&quot;subtitle_%u&quot;,
  526     GST_PAD_SRC,
  527     GST_PAD_SOMETIMES,
  528     GST_STATIC_CAPS_ANY);
  529 
  530 #define gst_qtdemux_parent_class parent_class
  531 G_DEFINE_TYPE (GstQTDemux, gst_qtdemux, GST_TYPE_ELEMENT);
  532 
  533 static void gst_qtdemux_dispose (GObject * object);
  534 
  535 static guint32
  536 gst_qtdemux_find_index_linear (GstQTDemux * qtdemux, QtDemuxStream * str,
  537     GstClockTime media_time);
  538 static guint32
  539 gst_qtdemux_find_index_for_given_media_offset_linear (GstQTDemux * qtdemux,
  540     QtDemuxStream * str, gint64 media_offset);
  541 
  542 #if 0
  543 static void gst_qtdemux_set_index (GstElement * element, GstIndex * index);
  544 static GstIndex *gst_qtdemux_get_index (GstElement * element);
  545 #endif
  546 static GstStateChangeReturn gst_qtdemux_change_state (GstElement * element,
  547     GstStateChange transition);
<a name="9" id="anc9"></a><span class="line-added">  548 static void gst_qtdemux_set_context (GstElement * element,</span>
<span class="line-added">  549     GstContext * context);</span>
  550 static gboolean qtdemux_sink_activate (GstPad * sinkpad, GstObject * parent);
  551 static gboolean qtdemux_sink_activate_mode (GstPad * sinkpad,
  552     GstObject * parent, GstPadMode mode, gboolean active);
  553 
  554 static void gst_qtdemux_loop (GstPad * pad);
  555 static GstFlowReturn gst_qtdemux_chain (GstPad * sinkpad, GstObject * parent,
  556     GstBuffer * inbuf);
  557 static gboolean gst_qtdemux_handle_sink_event (GstPad * pad, GstObject * parent,
  558     GstEvent * event);
<a name="10" id="anc10"></a><span class="line-added">  559 static gboolean gst_qtdemux_handle_sink_query (GstPad * pad, GstObject * parent,</span>
<span class="line-added">  560     GstQuery * query);</span>
  561 static gboolean gst_qtdemux_setcaps (GstQTDemux * qtdemux, GstCaps * caps);
  562 static gboolean gst_qtdemux_configure_stream (GstQTDemux * qtdemux,
  563     QtDemuxStream * stream);
  564 static void gst_qtdemux_stream_check_and_change_stsd_index (GstQTDemux * demux,
  565     QtDemuxStream * stream);
  566 static GstFlowReturn gst_qtdemux_process_adapter (GstQTDemux * demux,
  567     gboolean force);
  568 
<a name="11" id="anc11"></a><span class="line-added">  569 static void gst_qtdemux_check_seekability (GstQTDemux * demux);</span>
<span class="line-added">  570 </span>
  571 static gboolean qtdemux_parse_moov (GstQTDemux * qtdemux,
  572     const guint8 * buffer, guint length);
  573 static gboolean qtdemux_parse_node (GstQTDemux * qtdemux, GNode * node,
  574     const guint8 * buffer, guint length);
  575 static gboolean qtdemux_parse_tree (GstQTDemux * qtdemux);
  576 static void qtdemux_parse_udta (GstQTDemux * qtdemux, GstTagList * taglist,
  577     GNode * udta);
  578 
  579 #ifdef GSTREAMER_LITE
  580 static gboolean gst_qtdemux_handle_esds (GstQTDemux * qtdemux,
  581     QtDemuxStream * stream, QtDemuxStreamStsdEntry * entry, GNode * esds,
  582     GstTagList * list);
  583 #else
  584 static void gst_qtdemux_handle_esds (GstQTDemux * qtdemux,
  585     QtDemuxStream * stream, QtDemuxStreamStsdEntry * entry, GNode * esds,
  586     GstTagList * list);
  587 #endif // GSTREAMER_LITE
  588 static GstCaps *qtdemux_video_caps (GstQTDemux * qtdemux,
  589     QtDemuxStream * stream, QtDemuxStreamStsdEntry * entry, guint32 fourcc,
  590     const guint8 * stsd_entry_data, gchar ** codec_name);
  591 static GstCaps *qtdemux_audio_caps (GstQTDemux * qtdemux,
  592     QtDemuxStream * stream, QtDemuxStreamStsdEntry * entry, guint32 fourcc,
  593     const guint8 * data, int len, gchar ** codec_name);
  594 static GstCaps *qtdemux_sub_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
  595     QtDemuxStreamStsdEntry * entry, guint32 fourcc, const guint8 * data,
  596     gchar ** codec_name);
  597 static GstCaps *qtdemux_generic_caps (GstQTDemux * qtdemux,
  598     QtDemuxStream * stream, QtDemuxStreamStsdEntry * entry, guint32 fourcc,
  599     const guint8 * stsd_entry_data, gchar ** codec_name);
  600 
  601 static gboolean qtdemux_parse_samples (GstQTDemux * qtdemux,
  602     QtDemuxStream * stream, guint32 n);
  603 static GstFlowReturn qtdemux_expose_streams (GstQTDemux * qtdemux);
<a name="12" id="anc12"></a><span class="line-modified">  604 static QtDemuxStream *gst_qtdemux_stream_ref (QtDemuxStream * stream);</span>
<span class="line-modified">  605 static void gst_qtdemux_stream_unref (QtDemuxStream * stream);</span>
<span class="line-modified">  606 static void gst_qtdemux_stream_clear (QtDemuxStream * stream);</span>


  607 static GstFlowReturn qtdemux_prepare_streams (GstQTDemux * qtdemux);
<a name="13" id="anc13"></a><span class="line-modified">  608 static void qtdemux_do_allocation (QtDemuxStream * stream,</span>
<span class="line-modified">  609     GstQTDemux * qtdemux);</span>
  610 static gboolean gst_qtdemux_activate_segment (GstQTDemux * qtdemux,
  611     QtDemuxStream * stream, guint32 seg_idx, GstClockTime offset);
  612 static gboolean gst_qtdemux_stream_update_segment (GstQTDemux * qtdemux,
  613     QtDemuxStream * stream, gint seg_idx, GstClockTime offset,
  614     GstClockTime * _start, GstClockTime * _stop);
  615 static void gst_qtdemux_send_gap_for_segment (GstQTDemux * demux,
  616     QtDemuxStream * stream, gint segment_index, GstClockTime pos);
  617 
  618 static gboolean qtdemux_pull_mfro_mfra (GstQTDemux * qtdemux);
  619 static void check_update_duration (GstQTDemux * qtdemux, GstClockTime duration);
  620 
  621 static gchar *qtdemux_uuid_bytes_to_string (gconstpointer uuid_bytes);
  622 
  623 static GstStructure *qtdemux_get_cenc_sample_properties (GstQTDemux * qtdemux,
  624     QtDemuxStream * stream, guint sample_index);
  625 static void gst_qtdemux_append_protection_system_id (GstQTDemux * qtdemux,
  626     const gchar * id);
  627 static void qtdemux_gst_structure_free (GstStructure * gststructure);
<a name="14" id="anc14"></a><span class="line-added">  628 static void gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard);</span>
  629 
  630 static void
  631 gst_qtdemux_class_init (GstQTDemuxClass * klass)
  632 {
  633   GObjectClass *gobject_class;
  634   GstElementClass *gstelement_class;
  635 
  636   gobject_class = (GObjectClass *) klass;
  637   gstelement_class = (GstElementClass *) klass;
  638 
  639   parent_class = g_type_class_peek_parent (klass);
  640 
  641   gobject_class-&gt;dispose = gst_qtdemux_dispose;
  642 
  643   gstelement_class-&gt;change_state = GST_DEBUG_FUNCPTR (gst_qtdemux_change_state);
  644 #if 0
  645   gstelement_class-&gt;set_index = GST_DEBUG_FUNCPTR (gst_qtdemux_set_index);
  646   gstelement_class-&gt;get_index = GST_DEBUG_FUNCPTR (gst_qtdemux_get_index);
  647 #endif
<a name="15" id="anc15"></a><span class="line-added">  648   gstelement_class-&gt;set_context = GST_DEBUG_FUNCPTR (gst_qtdemux_set_context);</span>
  649 
  650   gst_tag_register_musicbrainz_tags ();
  651 
  652   gst_element_class_add_static_pad_template (gstelement_class,
  653       &amp;gst_qtdemux_sink_template);
  654   gst_element_class_add_static_pad_template (gstelement_class,
  655       &amp;gst_qtdemux_videosrc_template);
  656   gst_element_class_add_static_pad_template (gstelement_class,
  657       &amp;gst_qtdemux_audiosrc_template);
  658   gst_element_class_add_static_pad_template (gstelement_class,
  659       &amp;gst_qtdemux_subsrc_template);
  660   gst_element_class_set_static_metadata (gstelement_class, &quot;QuickTime demuxer&quot;,
  661       &quot;Codec/Demuxer&quot;,
  662       &quot;Demultiplex a QuickTime file into audio and video streams&quot;,
  663       &quot;David Schleef &lt;ds@schleef.org&gt;, Wim Taymans &lt;wim@fluendo.com&gt;&quot;);
  664 
  665   GST_DEBUG_CATEGORY_INIT (qtdemux_debug, &quot;qtdemux&quot;, 0, &quot;qtdemux plugin&quot;);
  666   gst_riff_init ();
  667 }
  668 
  669 static void
  670 gst_qtdemux_init (GstQTDemux * qtdemux)
  671 {
  672   qtdemux-&gt;sinkpad =
  673       gst_pad_new_from_static_template (&amp;gst_qtdemux_sink_template, &quot;sink&quot;);
  674   gst_pad_set_activate_function (qtdemux-&gt;sinkpad, qtdemux_sink_activate);
  675   gst_pad_set_activatemode_function (qtdemux-&gt;sinkpad,
  676       qtdemux_sink_activate_mode);
  677   gst_pad_set_chain_function (qtdemux-&gt;sinkpad, gst_qtdemux_chain);
  678   gst_pad_set_event_function (qtdemux-&gt;sinkpad, gst_qtdemux_handle_sink_event);
<a name="16" id="anc16"></a><span class="line-added">  679   gst_pad_set_query_function (qtdemux-&gt;sinkpad, gst_qtdemux_handle_sink_query);</span>
  680   gst_element_add_pad (GST_ELEMENT_CAST (qtdemux), qtdemux-&gt;sinkpad);
  681 
<a name="17" id="anc17"></a>




  682   qtdemux-&gt;adapter = gst_adapter_new ();
<a name="18" id="anc18"></a>



















  683   g_queue_init (&amp;qtdemux-&gt;protection_event_queue);
<a name="19" id="anc19"></a>


  684   qtdemux-&gt;flowcombiner = gst_flow_combiner_new ();
<a name="20" id="anc20"></a><span class="line-added">  685   g_mutex_init (&amp;qtdemux-&gt;expose_lock);</span>
<span class="line-added">  686 </span>
<span class="line-added">  687   qtdemux-&gt;active_streams = g_ptr_array_new_with_free_func</span>
<span class="line-added">  688       ((GDestroyNotify) gst_qtdemux_stream_unref);</span>
<span class="line-added">  689   qtdemux-&gt;old_streams = g_ptr_array_new_with_free_func</span>
<span class="line-added">  690       ((GDestroyNotify) gst_qtdemux_stream_unref);</span>
  691 
  692   GST_OBJECT_FLAG_SET (qtdemux, GST_ELEMENT_FLAG_INDEXABLE);
<a name="21" id="anc21"></a><span class="line-added">  693 </span>
<span class="line-added">  694   gst_qtdemux_reset (qtdemux, TRUE);</span>
  695 }
  696 
  697 static void
  698 gst_qtdemux_dispose (GObject * object)
  699 {
  700   GstQTDemux *qtdemux = GST_QTDEMUX (object);
  701 
  702   if (qtdemux-&gt;adapter) {
  703     g_object_unref (G_OBJECT (qtdemux-&gt;adapter));
  704     qtdemux-&gt;adapter = NULL;
  705   }
  706   gst_tag_list_unref (qtdemux-&gt;tag_list);
  707   gst_flow_combiner_free (qtdemux-&gt;flowcombiner);
  708   g_queue_foreach (&amp;qtdemux-&gt;protection_event_queue, (GFunc) gst_event_unref,
  709       NULL);
  710   g_queue_clear (&amp;qtdemux-&gt;protection_event_queue);
  711 
  712   g_free (qtdemux-&gt;cenc_aux_info_sizes);
  713   qtdemux-&gt;cenc_aux_info_sizes = NULL;
<a name="22" id="anc22"></a><span class="line-added">  714   g_mutex_clear (&amp;qtdemux-&gt;expose_lock);</span>
<span class="line-added">  715 </span>
<span class="line-added">  716   g_ptr_array_free (qtdemux-&gt;active_streams, TRUE);</span>
<span class="line-added">  717   g_ptr_array_free (qtdemux-&gt;old_streams, TRUE);</span>
  718 
  719   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
  720 }
  721 
  722 static void
  723 gst_qtdemux_post_no_playable_stream_error (GstQTDemux * qtdemux)
  724 {
  725   if (qtdemux-&gt;posted_redirect) {
  726     GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
  727         (_(&quot;This file contains no playable streams.&quot;)),
  728         (&quot;no known streams found, a redirect message has been posted&quot;));
  729   } else {
  730     GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
  731         (_(&quot;This file contains no playable streams.&quot;)),
  732         (&quot;no known streams found&quot;));
  733   }
  734 }
  735 
  736 static GstBuffer *
  737 _gst_buffer_new_wrapped (gpointer mem, gsize size, GFreeFunc free_func)
  738 {
  739   return gst_buffer_new_wrapped_full (free_func ? 0 : GST_MEMORY_FLAG_READONLY,
  740       mem, size, 0, size, mem, free_func);
  741 }
  742 
  743 static GstFlowReturn
  744 gst_qtdemux_pull_atom (GstQTDemux * qtdemux, guint64 offset, guint64 size,
  745     GstBuffer ** buf)
  746 {
  747   GstFlowReturn flow;
  748   GstMapInfo map;
  749   gsize bsize;
  750 
  751   if (G_UNLIKELY (size == 0)) {
  752     GstFlowReturn ret;
  753     GstBuffer *tmp = NULL;
  754 
  755     ret = gst_qtdemux_pull_atom (qtdemux, offset, sizeof (guint32), &amp;tmp);
  756     if (ret != GST_FLOW_OK)
  757       return ret;
  758 
  759     gst_buffer_map (tmp, &amp;map, GST_MAP_READ);
  760     size = QT_UINT32 (map.data);
  761     GST_DEBUG_OBJECT (qtdemux, &quot;size 0x%08&quot; G_GINT64_MODIFIER &quot;x&quot;, size);
  762 
  763     gst_buffer_unmap (tmp, &amp;map);
  764     gst_buffer_unref (tmp);
  765   }
  766 
  767   /* Sanity check: catch bogus sizes (fuzzed/broken files) */
  768   if (G_UNLIKELY (size &gt; QTDEMUX_MAX_ATOM_SIZE)) {
  769     if (qtdemux-&gt;state != QTDEMUX_STATE_MOVIE &amp;&amp; qtdemux-&gt;got_moov) {
  770       /* we&#39;re pulling header but already got most interesting bits,
  771        * so never mind the rest (e.g. tags) (that much) */
  772       GST_WARNING_OBJECT (qtdemux, &quot;atom has bogus size %&quot; G_GUINT64_FORMAT,
  773           size);
  774       return GST_FLOW_EOS;
  775     } else {
  776       GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
  777           (_(&quot;This file is invalid and cannot be played.&quot;)),
  778           (&quot;atom has bogus size %&quot; G_GUINT64_FORMAT, size));
  779       return GST_FLOW_ERROR;
  780     }
  781   }
  782 
  783   flow = gst_pad_pull_range (qtdemux-&gt;sinkpad, offset, size, buf);
  784 
  785   if (G_UNLIKELY (flow != GST_FLOW_OK))
  786     return flow;
  787 
  788   bsize = gst_buffer_get_size (*buf);
  789   /* Catch short reads - we don&#39;t want any partial atoms */
  790   if (G_UNLIKELY (bsize &lt; size)) {
  791     GST_WARNING_OBJECT (qtdemux,
  792         &quot;short read: %&quot; G_GSIZE_FORMAT &quot; &lt; %&quot; G_GUINT64_FORMAT, bsize, size);
  793     gst_buffer_unref (*buf);
  794     *buf = NULL;
  795     return GST_FLOW_EOS;
  796   }
  797 
  798   return flow;
  799 }
  800 
  801 #if 1
  802 static gboolean
  803 gst_qtdemux_src_convert (GstQTDemux * qtdemux, GstPad * pad,
  804     GstFormat src_format, gint64 src_value, GstFormat dest_format,
  805     gint64 * dest_value)
  806 {
  807   gboolean res = TRUE;
  808   QtDemuxStream *stream = gst_pad_get_element_private (pad);
  809   gint32 index;
  810 
  811   if (stream-&gt;subtype != FOURCC_vide) {
  812     res = FALSE;
  813     goto done;
  814   }
  815 
  816   switch (src_format) {
  817     case GST_FORMAT_TIME:
  818       switch (dest_format) {
  819         case GST_FORMAT_BYTES:{
  820           index = gst_qtdemux_find_index_linear (qtdemux, stream, src_value);
  821           if (-1 == index) {
  822             res = FALSE;
  823             goto done;
  824           }
  825 
  826           *dest_value = stream-&gt;samples[index].offset;
  827 
  828           GST_DEBUG_OBJECT (qtdemux, &quot;Format Conversion Time-&gt;Offset :%&quot;
  829               GST_TIME_FORMAT &quot;-&gt;%&quot; G_GUINT64_FORMAT,
  830               GST_TIME_ARGS (src_value), *dest_value);
  831           break;
  832         }
  833         default:
  834           res = FALSE;
  835           break;
  836       }
  837       break;
  838     case GST_FORMAT_BYTES:
  839       switch (dest_format) {
  840         case GST_FORMAT_TIME:{
  841           index =
  842               gst_qtdemux_find_index_for_given_media_offset_linear (qtdemux,
  843               stream, src_value);
  844 
  845           if (-1 == index) {
  846             res = FALSE;
  847             goto done;
  848           }
  849 
  850           *dest_value =
  851               QTSTREAMTIME_TO_GSTTIME (stream,
  852               stream-&gt;samples[index].timestamp);
  853           GST_DEBUG_OBJECT (qtdemux,
  854               &quot;Format Conversion Offset-&gt;Time :%&quot; G_GUINT64_FORMAT &quot;-&gt;%&quot;
  855               GST_TIME_FORMAT, src_value, GST_TIME_ARGS (*dest_value));
  856           break;
  857         }
  858         default:
  859           res = FALSE;
  860           break;
  861       }
  862       break;
  863     default:
  864       res = FALSE;
  865       break;
  866   }
  867 
  868 done:
  869   return res;
  870 }
  871 #endif
  872 
  873 static gboolean
  874 gst_qtdemux_get_duration (GstQTDemux * qtdemux, GstClockTime * duration)
  875 {
  876   gboolean res = FALSE;
  877 
  878   *duration = GST_CLOCK_TIME_NONE;
  879 
  880   if (qtdemux-&gt;duration != 0 &amp;&amp;
  881       qtdemux-&gt;duration != G_MAXINT64 &amp;&amp; qtdemux-&gt;timescale != 0) {
  882     *duration = QTTIME_TO_GSTTIME (qtdemux, qtdemux-&gt;duration);
  883     res = TRUE;
  884   } else {
  885     *duration = GST_CLOCK_TIME_NONE;
<a name="23" id="anc23"></a><span class="line-modified">  886   }</span>
  887 
  888   return res;
  889 }
  890 
  891 static gboolean
  892 gst_qtdemux_handle_src_query (GstPad * pad, GstObject * parent,
  893     GstQuery * query)
  894 {
  895   gboolean res = FALSE;
  896   GstQTDemux *qtdemux = GST_QTDEMUX (parent);
  897 
  898   GST_LOG_OBJECT (pad, &quot;%s query&quot;, GST_QUERY_TYPE_NAME (query));
  899 
  900   switch (GST_QUERY_TYPE (query)) {
  901     case GST_QUERY_POSITION:{
  902       GstFormat fmt;
  903 
  904       gst_query_parse_position (query, &amp;fmt, NULL);
  905       if (fmt == GST_FORMAT_TIME
  906           &amp;&amp; GST_CLOCK_TIME_IS_VALID (qtdemux-&gt;segment.position)) {
  907         gst_query_set_position (query, GST_FORMAT_TIME,
  908             qtdemux-&gt;segment.position);
  909         res = TRUE;
  910       }
  911     }
  912       break;
  913     case GST_QUERY_DURATION:{
  914       GstFormat fmt;
  915 
  916       gst_query_parse_duration (query, &amp;fmt, NULL);
  917       if (fmt == GST_FORMAT_TIME) {
  918         /* First try to query upstream */
  919         res = gst_pad_query_default (pad, parent, query);
  920         if (!res) {
  921           GstClockTime duration;
  922           if (gst_qtdemux_get_duration (qtdemux, &amp;duration) &amp;&amp; duration &gt; 0) {
<a name="24" id="anc24"></a><span class="line-modified">  923             gst_query_set_duration (query, GST_FORMAT_TIME, duration);</span>
<span class="line-modified">  924             res = TRUE;</span>
<span class="line-added">  925           }</span>
  926         }
  927       }
<a name="25" id="anc25"></a>
  928       break;
  929     }
  930     case GST_QUERY_CONVERT:{
  931       GstFormat src_fmt, dest_fmt;
  932       gint64 src_value, dest_value = 0;
  933 
  934       gst_query_parse_convert (query, &amp;src_fmt, &amp;src_value, &amp;dest_fmt, NULL);
  935 
  936       res = gst_qtdemux_src_convert (qtdemux, pad,
  937           src_fmt, src_value, dest_fmt, &amp;dest_value);
  938       if (res)
  939         gst_query_set_convert (query, src_fmt, src_value, dest_fmt, dest_value);
  940 
  941       break;
  942     }
  943     case GST_QUERY_FORMATS:
  944       gst_query_set_formats (query, 2, GST_FORMAT_TIME, GST_FORMAT_BYTES);
  945       res = TRUE;
  946       break;
  947     case GST_QUERY_SEEKING:{
  948       GstFormat fmt;
  949       gboolean seekable;
  950 
  951       /* try upstream first */
  952       res = gst_pad_query_default (pad, parent, query);
  953 
  954       if (!res) {
<a name="26" id="anc26"></a><span class="line-modified">  955         gst_query_parse_seeking (query, &amp;fmt, NULL, NULL, NULL);</span>
<span class="line-modified">  956         if (fmt == GST_FORMAT_TIME) {</span>
  957           GstClockTime duration;
  958 
<a name="27" id="anc27"></a><span class="line-modified">  959           gst_qtdemux_get_duration (qtdemux, &amp;duration);</span>
<span class="line-modified">  960           seekable = TRUE;</span>
<span class="line-modified">  961           if (!qtdemux-&gt;pullbased) {</span>
<span class="line-modified">  962             GstQuery *q;</span>
<span class="line-modified">  963 </span>
<span class="line-modified">  964             /* we might be able with help from upstream */</span>
<span class="line-modified">  965             seekable = FALSE;</span>
<span class="line-modified">  966             q = gst_query_new_seeking (GST_FORMAT_BYTES);</span>
<span class="line-modified">  967             if (gst_pad_peer_query (qtdemux-&gt;sinkpad, q)) {</span>
<span class="line-modified">  968               gst_query_parse_seeking (q, &amp;fmt, &amp;seekable, NULL, NULL);</span>
<span class="line-modified">  969               GST_LOG_OBJECT (qtdemux, &quot;upstream BYTE seekable %d&quot;, seekable);</span>
<span class="line-added">  970             }</span>
<span class="line-added">  971             gst_query_unref (q);</span>
  972           }
<a name="28" id="anc28"></a><span class="line-modified">  973           gst_query_set_seeking (query, GST_FORMAT_TIME, seekable, 0, duration);</span>
<span class="line-added">  974           res = TRUE;</span>
  975         }
<a name="29" id="anc29"></a>


  976       }
  977       break;
  978     }
  979     case GST_QUERY_SEGMENT:
  980     {
  981       GstFormat format;
  982       gint64 start, stop;
  983 
  984       format = qtdemux-&gt;segment.format;
  985 
  986       start =
  987           gst_segment_to_stream_time (&amp;qtdemux-&gt;segment, format,
  988           qtdemux-&gt;segment.start);
  989       if ((stop = qtdemux-&gt;segment.stop) == -1)
  990         stop = qtdemux-&gt;segment.duration;
  991       else
  992         stop = gst_segment_to_stream_time (&amp;qtdemux-&gt;segment, format, stop);
  993 
  994       gst_query_set_segment (query, qtdemux-&gt;segment.rate, format, start, stop);
  995       res = TRUE;
  996       break;
  997     }
  998     default:
  999       res = gst_pad_query_default (pad, parent, query);
 1000       break;
 1001   }
 1002 
 1003 #ifdef GSTREAMER_LITE
 1004   if (!res)
 1005       res = gst_pad_query_default (pad, parent, query);
 1006 #endif
 1007 
 1008   return res;
 1009 }
 1010 
 1011 static void
 1012 gst_qtdemux_push_tags (GstQTDemux * qtdemux, QtDemuxStream * stream)
 1013 {
 1014   if (G_LIKELY (stream-&gt;pad)) {
 1015     GST_DEBUG_OBJECT (qtdemux, &quot;Checking pad %s:%s for tags&quot;,
 1016         GST_DEBUG_PAD_NAME (stream-&gt;pad));
 1017 
 1018     if (!gst_tag_list_is_empty (stream-&gt;stream_tags)) {
 1019       GST_DEBUG_OBJECT (qtdemux, &quot;Sending tags %&quot; GST_PTR_FORMAT,
 1020           stream-&gt;stream_tags);
 1021       gst_pad_push_event (stream-&gt;pad,
 1022           gst_event_new_tag (gst_tag_list_ref (stream-&gt;stream_tags)));
 1023     }
 1024 
 1025     if (G_UNLIKELY (stream-&gt;send_global_tags)) {
 1026       GST_DEBUG_OBJECT (qtdemux, &quot;Sending global tags %&quot; GST_PTR_FORMAT,
 1027           qtdemux-&gt;tag_list);
 1028       gst_pad_push_event (stream-&gt;pad,
 1029           gst_event_new_tag (gst_tag_list_ref (qtdemux-&gt;tag_list)));
 1030       stream-&gt;send_global_tags = FALSE;
 1031     }
 1032   }
 1033 }
 1034 
 1035 /* push event on all source pads; takes ownership of the event */
 1036 static void
 1037 gst_qtdemux_push_event (GstQTDemux * qtdemux, GstEvent * event)
 1038 {
<a name="30" id="anc30"></a>
 1039   gboolean has_valid_stream = FALSE;
 1040   GstEventType etype = GST_EVENT_TYPE (event);
<a name="31" id="anc31"></a><span class="line-added"> 1041   guint i;</span>
 1042 
 1043   GST_DEBUG_OBJECT (qtdemux, &quot;pushing %s event on all source pads&quot;,
 1044       GST_EVENT_TYPE_NAME (event));
 1045 
<a name="32" id="anc32"></a><span class="line-modified"> 1046   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
 1047     GstPad *pad;
<a name="33" id="anc33"></a><span class="line-modified"> 1048     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-modified"> 1049     GST_DEBUG_OBJECT (qtdemux, &quot;pushing on track-id %u&quot;, stream-&gt;track_id);</span>
 1050 
 1051     if ((pad = stream-&gt;pad)) {
 1052       has_valid_stream = TRUE;
 1053 
 1054       if (etype == GST_EVENT_EOS) {
 1055         /* let&#39;s not send twice */
 1056         if (stream-&gt;sent_eos)
 1057           continue;
 1058         stream-&gt;sent_eos = TRUE;
 1059       }
 1060 
 1061       gst_pad_push_event (pad, gst_event_ref (event));
 1062     }
 1063   }
 1064 
 1065   gst_event_unref (event);
 1066 
 1067   /* if it is EOS and there are no pads, post an error */
 1068   if (!has_valid_stream &amp;&amp; etype == GST_EVENT_EOS) {
 1069     gst_qtdemux_post_no_playable_stream_error (qtdemux);
 1070   }
 1071 }
 1072 
<a name="34" id="anc34"></a>









 1073 typedef struct
 1074 {
 1075   guint64 media_time;
 1076 } FindData;
 1077 
 1078 static gint
 1079 find_func (QtDemuxSample * s1, gint64 * media_time, gpointer user_data)
 1080 {
<a name="35" id="anc35"></a><span class="line-modified"> 1081   if ((gint64) s1-&gt;timestamp &gt; *media_time)</span>
 1082     return 1;
<a name="36" id="anc36"></a><span class="line-modified"> 1083   if ((gint64) s1-&gt;timestamp == *media_time)</span>
 1084     return 0;
 1085 
 1086   return -1;
 1087 }
 1088 
 1089 /* find the index of the sample that includes the data for @media_time using a
 1090  * binary search.  Only to be called in optimized cases of linear search below.
 1091  *
<a name="37" id="anc37"></a><span class="line-modified"> 1092  * Returns the index of the sample with the corresponding *DTS*.</span>
 1093  */
 1094 static guint32
 1095 gst_qtdemux_find_index (GstQTDemux * qtdemux, QtDemuxStream * str,
 1096     guint64 media_time)
 1097 {
 1098   QtDemuxSample *result;
 1099   guint32 index;
 1100 
 1101   /* convert media_time to mov format */
 1102   media_time =
 1103       gst_util_uint64_scale_ceil (media_time, str-&gt;timescale, GST_SECOND);
 1104 
 1105   result = gst_util_array_binary_search (str-&gt;samples, str-&gt;stbl_index + 1,
 1106       sizeof (QtDemuxSample), (GCompareDataFunc) find_func,
 1107       GST_SEARCH_MODE_BEFORE, &amp;media_time, NULL);
 1108 
 1109   if (G_LIKELY (result))
 1110     index = result - str-&gt;samples;
 1111   else
 1112     index = 0;
 1113 
 1114   return index;
 1115 }
 1116 
 1117 
 1118 
 1119 /* find the index of the sample that includes the data for @media_offset using a
 1120  * linear search
 1121  *
 1122  * Returns the index of the sample.
 1123  */
 1124 static guint32
 1125 gst_qtdemux_find_index_for_given_media_offset_linear (GstQTDemux * qtdemux,
 1126     QtDemuxStream * str, gint64 media_offset)
 1127 {
 1128   QtDemuxSample *result = str-&gt;samples;
 1129   guint32 index = 0;
 1130 
 1131   if (result == NULL || str-&gt;n_samples == 0)
 1132     return -1;
 1133 
 1134   if (media_offset == result-&gt;offset)
 1135     return index;
 1136 
 1137   result++;
 1138   while (index &lt; str-&gt;n_samples - 1) {
 1139     if (!qtdemux_parse_samples (qtdemux, str, index + 1))
 1140       goto parse_failed;
 1141 
 1142     if (media_offset &lt; result-&gt;offset)
 1143       break;
 1144 
 1145     index++;
 1146     result++;
 1147   }
 1148   return index;
 1149 
 1150   /* ERRORS */
 1151 parse_failed:
 1152   {
 1153     GST_LOG_OBJECT (qtdemux, &quot;Parsing of index %u failed!&quot;, index + 1);
 1154     return -1;
 1155   }
 1156 }
 1157 
 1158 /* find the index of the sample that includes the data for @media_time using a
 1159  * linear search, and keeping in mind that not all samples may have been parsed
 1160  * yet.  If possible, it will delegate to binary search.
 1161  *
 1162  * Returns the index of the sample.
 1163  */
 1164 static guint32
 1165 gst_qtdemux_find_index_linear (GstQTDemux * qtdemux, QtDemuxStream * str,
 1166     GstClockTime media_time)
 1167 {
 1168   guint32 index = 0;
 1169   guint64 mov_time;
 1170   QtDemuxSample *sample;
 1171 
 1172   /* convert media_time to mov format */
 1173   mov_time =
 1174       gst_util_uint64_scale_ceil (media_time, str-&gt;timescale, GST_SECOND);
 1175 
 1176   sample = str-&gt;samples;
 1177   if (mov_time == sample-&gt;timestamp + sample-&gt;pts_offset)
 1178     return index;
 1179 
 1180   /* use faster search if requested time in already parsed range */
 1181   sample = str-&gt;samples + str-&gt;stbl_index;
<a name="38" id="anc38"></a><span class="line-modified"> 1182   if (str-&gt;stbl_index &gt;= 0 &amp;&amp; mov_time &lt;= sample-&gt;timestamp) {</span>
<span class="line-modified"> 1183     index = gst_qtdemux_find_index (qtdemux, str, media_time);</span>
<span class="line-modified"> 1184     sample = str-&gt;samples + index;</span>
<span class="line-added"> 1185   } else {</span>
<span class="line-added"> 1186     while (index &lt; str-&gt;n_samples - 1) {</span>
<span class="line-added"> 1187       if (!qtdemux_parse_samples (qtdemux, str, index + 1))</span>
<span class="line-added"> 1188         goto parse_failed;</span>
 1189 
<a name="39" id="anc39"></a><span class="line-modified"> 1190       sample = str-&gt;samples + index + 1;</span>
<span class="line-modified"> 1191       if (mov_time &lt; sample-&gt;timestamp) {</span>
<span class="line-modified"> 1192         sample = str-&gt;samples + index;</span>
<span class="line-added"> 1193         break;</span>
<span class="line-added"> 1194       }</span>
 1195 
<a name="40" id="anc40"></a><span class="line-modified"> 1196       index++;</span>
<span class="line-modified"> 1197     }</span>
<span class="line-modified"> 1198   }</span>
 1199 
<a name="41" id="anc41"></a><span class="line-modified"> 1200   /* sample-&gt;timestamp is now &lt;= media_time, need to find the corresponding</span>
<span class="line-added"> 1201    * PTS now by looking backwards */</span>
<span class="line-added"> 1202   while (index &gt; 0 &amp;&amp; sample-&gt;timestamp + sample-&gt;pts_offset &gt; mov_time) {</span>
<span class="line-added"> 1203     index--;</span>
<span class="line-added"> 1204     sample = str-&gt;samples + index;</span>
 1205   }
<a name="42" id="anc42"></a><span class="line-added"> 1206 </span>
 1207   return index;
 1208 
 1209   /* ERRORS */
 1210 parse_failed:
 1211   {
 1212     GST_LOG_OBJECT (qtdemux, &quot;Parsing of index %u failed!&quot;, index + 1);
 1213     return -1;
 1214   }
 1215 }
 1216 
 1217 /* find the index of the keyframe needed to decode the sample at @index
 1218  * of stream @str, or of a subsequent keyframe (depending on @next)
 1219  *
 1220  * Returns the index of the keyframe.
 1221  */
 1222 static guint32
 1223 gst_qtdemux_find_keyframe (GstQTDemux * qtdemux, QtDemuxStream * str,
 1224     guint32 index, gboolean next)
 1225 {
 1226   guint32 new_index = index;
 1227 
 1228   if (index &gt;= str-&gt;n_samples) {
 1229     new_index = str-&gt;n_samples;
 1230     goto beach;
 1231   }
 1232 
 1233   /* all keyframes, return index */
 1234   if (str-&gt;all_keyframe) {
 1235     new_index = index;
 1236     goto beach;
 1237   }
 1238 
 1239   /* else search until we have a keyframe */
 1240   while (new_index &lt; str-&gt;n_samples) {
 1241     if (next &amp;&amp; !qtdemux_parse_samples (qtdemux, str, new_index))
 1242       goto parse_failed;
 1243 
 1244     if (str-&gt;samples[new_index].keyframe)
 1245       break;
 1246 
 1247     if (new_index == 0)
 1248       break;
 1249 
 1250     if (next)
 1251       new_index++;
 1252     else
<a name="43" id="anc43"></a><span class="line-modified"> 1253       new_index--;</span>
 1254   }
 1255 
 1256   if (new_index == str-&gt;n_samples) {
 1257     GST_DEBUG_OBJECT (qtdemux, &quot;no next keyframe&quot;);
 1258     new_index = -1;
 1259   }
 1260 
 1261 beach:
 1262   GST_DEBUG_OBJECT (qtdemux, &quot;searching for keyframe index %s index %u &quot;
 1263       &quot;gave %u&quot;, next ? &quot;after&quot; : &quot;before&quot;, index, new_index);
 1264 
 1265   return new_index;
 1266 
 1267   /* ERRORS */
 1268 parse_failed:
 1269   {
 1270     GST_LOG_OBJECT (qtdemux, &quot;Parsing of index %u failed!&quot;, new_index);
 1271     return -1;
<a name="44" id="anc44"></a><span class="line-modified"> 1272   }</span>
 1273 }
 1274 
 1275 /* find the segment for @time_position for @stream
 1276  *
 1277  * Returns the index of the segment containing @time_position.
 1278  * Returns the last segment and sets the @eos variable to TRUE
 1279  * if the time is beyond the end. @eos may be NULL
 1280  */
 1281 static guint32
 1282 gst_qtdemux_find_segment (GstQTDemux * qtdemux, QtDemuxStream * stream,
 1283     GstClockTime time_position)
 1284 {
 1285   gint i;
 1286   guint32 seg_idx;
 1287 
 1288   GST_LOG_OBJECT (stream-&gt;pad, &quot;finding segment for %&quot; GST_TIME_FORMAT,
 1289       GST_TIME_ARGS (time_position));
 1290 
 1291   seg_idx = -1;
 1292   for (i = 0; i &lt; stream-&gt;n_segments; i++) {
 1293     QtDemuxSegment *segment = &amp;stream-&gt;segments[i];
 1294 
 1295     GST_LOG_OBJECT (stream-&gt;pad,
 1296         &quot;looking at segment %&quot; GST_TIME_FORMAT &quot;-%&quot; GST_TIME_FORMAT,
 1297         GST_TIME_ARGS (segment-&gt;time), GST_TIME_ARGS (segment-&gt;stop_time));
 1298 
 1299     /* For the last segment we include stop_time in the last segment */
 1300     if (i &lt; stream-&gt;n_segments - 1) {
 1301       if (segment-&gt;time &lt;= time_position &amp;&amp; time_position &lt; segment-&gt;stop_time) {
 1302         GST_LOG_OBJECT (stream-&gt;pad, &quot;segment %d matches&quot;, i);
 1303         seg_idx = i;
 1304         break;
 1305       }
 1306     } else {
 1307       /* Last segment always matches */
<a name="45" id="anc45"></a><span class="line-modified"> 1308       seg_idx = i;</span>
<span class="line-modified"> 1309       break;</span>

 1310     }
<a name="46" id="anc46"></a><span class="line-added"> 1311   }</span>
 1312   return seg_idx;
 1313 }
 1314 
 1315 /* move the stream @str to the sample position @index.
 1316  *
 1317  * Updates @str-&gt;sample_index and marks discontinuity if needed.
 1318  */
 1319 static void
 1320 gst_qtdemux_move_stream (GstQTDemux * qtdemux, QtDemuxStream * str,
 1321     guint32 index)
 1322 {
 1323   /* no change needed */
 1324   if (index == str-&gt;sample_index)
 1325     return;
 1326 
 1327   GST_DEBUG_OBJECT (qtdemux, &quot;moving to sample %u of %u&quot;, index,
 1328       str-&gt;n_samples);
 1329 
 1330   /* position changed, we have a discont */
 1331   str-&gt;sample_index = index;
 1332   str-&gt;offset_in_sample = 0;
 1333   /* Each time we move in the stream we store the position where we are
 1334    * starting from */
 1335   str-&gt;from_sample = index;
 1336   str-&gt;discont = TRUE;
 1337 }
 1338 
 1339 static void
 1340 gst_qtdemux_adjust_seek (GstQTDemux * qtdemux, gint64 desired_time,
 1341     gboolean use_sparse, gboolean next, gint64 * key_time, gint64 * key_offset)
 1342 {
 1343   guint64 min_offset;
 1344   gint64 min_byte_offset = -1;
<a name="47" id="anc47"></a><span class="line-modified"> 1345   guint i;</span>
 1346 
 1347   min_offset = desired_time;
 1348 
 1349   /* for each stream, find the index of the sample in the segment
 1350    * and move back to the previous keyframe. */
<a name="48" id="anc48"></a><span class="line-modified"> 1351   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
 1352     QtDemuxStream *str;
 1353     guint32 index, kindex;
 1354     guint32 seg_idx;
 1355     GstClockTime media_start;
 1356     GstClockTime media_time;
 1357     GstClockTime seg_time;
 1358     QtDemuxSegment *seg;
 1359     gboolean empty_segment = FALSE;
 1360 
<a name="49" id="anc49"></a><span class="line-modified"> 1361     str = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 1362 
 1363     if (CUR_STREAM (str)-&gt;sparse &amp;&amp; !use_sparse)
 1364       continue;
 1365 
 1366     seg_idx = gst_qtdemux_find_segment (qtdemux, str, desired_time);
 1367     GST_DEBUG_OBJECT (qtdemux, &quot;align segment %d&quot;, seg_idx);
 1368 
 1369     /* get segment and time in the segment */
 1370     seg = &amp;str-&gt;segments[seg_idx];
 1371     seg_time = (desired_time - seg-&gt;time) * seg-&gt;rate;
 1372 
 1373     while (QTSEGMENT_IS_EMPTY (seg)) {
 1374       seg_time = 0;
 1375       empty_segment = TRUE;
 1376       GST_DEBUG_OBJECT (str-&gt;pad, &quot;Segment %d is empty, moving to next one&quot;,
 1377           seg_idx);
 1378       seg_idx++;
 1379       if (seg_idx == str-&gt;n_segments)
 1380         break;
 1381       seg = &amp;str-&gt;segments[seg_idx];
 1382     }
 1383 
 1384     if (seg_idx == str-&gt;n_segments) {
 1385       /* FIXME track shouldn&#39;t have the last segment as empty, but if it
 1386        * happens we better handle it */
 1387       continue;
 1388     }
 1389 
 1390     /* get the media time in the segment */
 1391     media_start = seg-&gt;media_start + seg_time;
 1392 
 1393     /* get the index of the sample with media time */
 1394     index = gst_qtdemux_find_index_linear (qtdemux, str, media_start);
 1395     GST_DEBUG_OBJECT (qtdemux, &quot;sample for %&quot; GST_TIME_FORMAT &quot; at %u&quot;
 1396         &quot; at offset %&quot; G_GUINT64_FORMAT &quot; (empty segment: %d)&quot;,
 1397         GST_TIME_ARGS (media_start), index, str-&gt;samples[index].offset,
 1398         empty_segment);
 1399 
 1400     /* shift to next frame if we are looking for next keyframe */
 1401     if (next &amp;&amp; QTSAMPLE_PTS_NO_CSLG (str, &amp;str-&gt;samples[index]) &lt; media_start
 1402         &amp;&amp; index &lt; str-&gt;stbl_index)
 1403       index++;
 1404 
 1405     if (!empty_segment) {
<a name="50" id="anc50"></a><span class="line-modified"> 1406       /* find previous keyframe */</span>
 1407       kindex = gst_qtdemux_find_keyframe (qtdemux, str, index, next);
 1408 
 1409       /* we will settle for one before if none found after */
 1410       if (next &amp;&amp; kindex == -1)
 1411         kindex = gst_qtdemux_find_keyframe (qtdemux, str, index, FALSE);
 1412 
<a name="51" id="anc51"></a><span class="line-modified"> 1413       /* if the keyframe is at a different position, we need to update the</span>
<span class="line-modified"> 1414        * requested seek time */</span>
<span class="line-modified"> 1415       if (index != kindex) {</span>
<span class="line-modified"> 1416         index = kindex;</span>
 1417 
<a name="52" id="anc52"></a><span class="line-modified"> 1418         /* get timestamp of keyframe */</span>
 1419         media_time = QTSAMPLE_PTS_NO_CSLG (str, &amp;str-&gt;samples[kindex]);
 1420         GST_DEBUG_OBJECT (qtdemux,
 1421             &quot;keyframe at %u with time %&quot; GST_TIME_FORMAT &quot; at offset %&quot;
 1422             G_GUINT64_FORMAT, kindex, GST_TIME_ARGS (media_time),
 1423             str-&gt;samples[kindex].offset);
 1424 
<a name="53" id="anc53"></a><span class="line-modified"> 1425         /* keyframes in the segment get a chance to change the</span>
<span class="line-modified"> 1426          * desired_offset. keyframes out of the segment are</span>
<span class="line-modified"> 1427          * ignored. */</span>
<span class="line-modified"> 1428         if (media_time &gt;= seg-&gt;media_start) {</span>
 1429           GstClockTime seg_time;
 1430 
<a name="54" id="anc54"></a><span class="line-modified"> 1431           /* this keyframe is inside the segment, convert back to</span>
<span class="line-modified"> 1432            * segment time */</span>
<span class="line-modified"> 1433           seg_time = (media_time - seg-&gt;media_start) + seg-&gt;time;</span>
 1434           if ((!next &amp;&amp; (seg_time &lt; min_offset)) ||
 1435               (next &amp;&amp; (seg_time &gt; min_offset)))
<a name="55" id="anc55"></a><span class="line-modified"> 1436             min_offset = seg_time;</span>
<span class="line-added"> 1437         }</span>
 1438       }
 1439     }
<a name="56" id="anc56"></a>
 1440 
 1441     if (min_byte_offset &lt; 0 || str-&gt;samples[index].offset &lt; min_byte_offset)
 1442       min_byte_offset = str-&gt;samples[index].offset;
 1443   }
 1444 
 1445   if (key_time)
 1446     *key_time = min_offset;
 1447   if (key_offset)
 1448     *key_offset = min_byte_offset;
 1449 }
 1450 
 1451 static gboolean
 1452 gst_qtdemux_convert_seek (GstPad * pad, GstFormat * format,
 1453     GstSeekType cur_type, gint64 * cur, GstSeekType stop_type, gint64 * stop)
 1454 {
 1455   gboolean res;
 1456 
 1457   g_return_val_if_fail (format != NULL, FALSE);
 1458   g_return_val_if_fail (cur != NULL, FALSE);
 1459   g_return_val_if_fail (stop != NULL, FALSE);
 1460 
 1461   if (*format == GST_FORMAT_TIME)
 1462     return TRUE;
 1463 
 1464   res = TRUE;
 1465   if (cur_type != GST_SEEK_TYPE_NONE)
 1466     res = gst_pad_query_convert (pad, *format, *cur, GST_FORMAT_TIME, cur);
 1467   if (res &amp;&amp; stop_type != GST_SEEK_TYPE_NONE)
 1468     res = gst_pad_query_convert (pad, *format, *stop, GST_FORMAT_TIME, stop);
 1469 
 1470   if (res)
 1471     *format = GST_FORMAT_TIME;
 1472 
 1473   return res;
 1474 }
 1475 
 1476 /* perform seek in push based mode:
 1477    find BYTE position to move to based on time and delegate to upstream
 1478 */
 1479 static gboolean
 1480 gst_qtdemux_do_push_seek (GstQTDemux * qtdemux, GstPad * pad, GstEvent * event)
 1481 {
 1482   gdouble rate;
 1483   GstFormat format;
 1484   GstSeekFlags flags;
 1485   GstSeekType cur_type, stop_type;
 1486   gint64 cur, stop, key_cur;
 1487   gboolean res;
 1488   gint64 byte_cur;
 1489   gint64 original_stop;
 1490   guint32 seqnum;
 1491 #ifdef GSTREAMER_LITE
 1492   GstEvent * new_event = NULL;
 1493 #endif // GSTREAMER_LITE
 1494 
 1495   GST_DEBUG_OBJECT (qtdemux, &quot;doing push-based seek&quot;);
 1496 
 1497   gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags,
 1498       &amp;cur_type, &amp;cur, &amp;stop_type, &amp;stop);
 1499   seqnum = gst_event_get_seqnum (event);
 1500 
 1501   /* only forward streaming and seeking is possible */
 1502   if (rate &lt;= 0)
 1503     goto unsupported_seek;
 1504 
 1505   /* convert to TIME if needed and possible */
 1506   if (!gst_qtdemux_convert_seek (pad, &amp;format, cur_type, &amp;cur,
 1507           stop_type, &amp;stop))
 1508     goto no_format;
 1509 
 1510   /* Upstream seek in bytes will have undefined stop, but qtdemux stores
 1511    * the original stop position to use when upstream pushes the new segment
 1512    * for this seek */
 1513   original_stop = stop;
 1514   stop = -1;
 1515 
 1516   /* find reasonable corresponding BYTE position,
 1517    * also try to mind about keyframes, since we can not go back a bit for them
 1518    * later on */
 1519   /* determining @next here based on SNAP_BEFORE/SNAP_AFTER should
 1520    * mostly just work, but let&#39;s not yet boldly go there  ... */
 1521   gst_qtdemux_adjust_seek (qtdemux, cur, FALSE, FALSE, &amp;key_cur, &amp;byte_cur);
 1522 
 1523   if (byte_cur == -1)
 1524     goto abort_seek;
 1525 
 1526   GST_DEBUG_OBJECT (qtdemux, &quot;Pushing BYTE seek rate %g, &quot;
 1527       &quot;start %&quot; G_GINT64_FORMAT &quot;, stop %&quot; G_GINT64_FORMAT, rate, byte_cur,
 1528       stop);
 1529 
<a name="57" id="anc57"></a><span class="line-modified"> 1530   GST_OBJECT_LOCK (qtdemux);</span>
<span class="line-modified"> 1531   qtdemux-&gt;seek_offset = byte_cur;</span>
 1532   if (!(flags &amp; GST_SEEK_FLAG_KEY_UNIT)) {
 1533     qtdemux-&gt;push_seek_start = cur;
 1534   } else {
 1535     qtdemux-&gt;push_seek_start = key_cur;
 1536   }
 1537 
 1538   if (stop_type == GST_SEEK_TYPE_NONE) {
 1539     qtdemux-&gt;push_seek_stop = qtdemux-&gt;segment.stop;
 1540   } else {
 1541     qtdemux-&gt;push_seek_stop = original_stop;
 1542   }
 1543   GST_OBJECT_UNLOCK (qtdemux);
 1544 
<a name="58" id="anc58"></a><span class="line-added"> 1545   qtdemux-&gt;segment_seqnum = seqnum;</span>
 1546   /* BYTE seek event */
 1547 #ifdef GSTREAMER_LITE
 1548   new_event = gst_event_new_seek(rate, GST_FORMAT_BYTES, flags, cur_type, byte_cur,
 1549       stop_type, stop);
 1550   gst_event_set_seqnum(new_event, seqnum);
 1551   res = gst_pad_push_event(qtdemux-&gt;sinkpad, new_event);
 1552   if (res) {
 1553     gst_event_unref(event);
 1554   }
 1555 #else // GSTREAMER_LITE
 1556   event = gst_event_new_seek (rate, GST_FORMAT_BYTES, flags, cur_type, byte_cur,
 1557       stop_type, stop);
 1558   gst_event_set_seqnum (event, seqnum);
 1559   res = gst_pad_push_event (qtdemux-&gt;sinkpad, event);
 1560 #endif // GSTREAMER_LITE
 1561 
 1562   return res;
 1563 
 1564   /* ERRORS */
 1565 abort_seek:
 1566   {
 1567     GST_DEBUG_OBJECT (qtdemux, &quot;could not determine byte position to seek to, &quot;
 1568         &quot;seek aborted.&quot;);
 1569     return FALSE;
 1570   }
 1571 unsupported_seek:
 1572   {
 1573     GST_DEBUG_OBJECT (qtdemux, &quot;unsupported seek, seek aborted.&quot;);
 1574     return FALSE;
 1575   }
 1576 no_format:
 1577   {
 1578     GST_DEBUG_OBJECT (qtdemux, &quot;unsupported format given, seek aborted.&quot;);
 1579     return FALSE;
 1580   }
 1581 }
 1582 
 1583 /* perform the seek.
 1584  *
 1585  * We set all segment_indexes in the streams to unknown and
 1586  * adjust the time_position to the desired position. this is enough
 1587  * to trigger a segment switch in the streaming thread to start
 1588  * streaming from the desired position.
 1589  *
 1590  * Keyframe seeking is a little more complicated when dealing with
 1591  * segments. Ideally we want to move to the previous keyframe in
 1592  * the segment but there might not be a keyframe in the segment. In
 1593  * fact, none of the segments could contain a keyframe. We take a
 1594  * practical approach: seek to the previous keyframe in the segment,
 1595  * if there is none, seek to the beginning of the segment.
 1596  *
 1597  * Called with STREAM_LOCK
 1598  */
 1599 static gboolean
 1600 gst_qtdemux_perform_seek (GstQTDemux * qtdemux, GstSegment * segment,
 1601     guint32 seqnum, GstSeekFlags flags)
 1602 {
 1603   gint64 desired_offset;
<a name="59" id="anc59"></a><span class="line-modified"> 1604   guint i;</span>
 1605 
 1606   desired_offset = segment-&gt;position;
 1607 
 1608   GST_DEBUG_OBJECT (qtdemux, &quot;seeking to %&quot; GST_TIME_FORMAT,
 1609       GST_TIME_ARGS (desired_offset));
 1610 
 1611   /* may not have enough fragmented info to do this adjustment,
 1612    * and we can&#39;t scan (and probably should not) at this time with
 1613    * possibly flushing upstream */
 1614   if ((flags &amp; GST_SEEK_FLAG_KEY_UNIT) &amp;&amp; !qtdemux-&gt;fragmented) {
 1615     gint64 min_offset;
 1616     gboolean next, before, after;
 1617 
 1618     before = ! !(flags &amp; GST_SEEK_FLAG_SNAP_BEFORE);
 1619     after = ! !(flags &amp; GST_SEEK_FLAG_SNAP_AFTER);
 1620     next = after &amp;&amp; !before;
 1621     if (segment-&gt;rate &lt; 0)
 1622       next = !next;
 1623 
 1624     gst_qtdemux_adjust_seek (qtdemux, desired_offset, TRUE, next, &amp;min_offset,
 1625         NULL);
 1626     GST_DEBUG_OBJECT (qtdemux, &quot;keyframe seek, align to %&quot;
 1627         GST_TIME_FORMAT, GST_TIME_ARGS (min_offset));
 1628     desired_offset = min_offset;
 1629   }
 1630 
 1631   /* and set all streams to the final position */
 1632   gst_flow_combiner_reset (qtdemux-&gt;flowcombiner);
 1633   qtdemux-&gt;segment_seqnum = seqnum;
<a name="60" id="anc60"></a><span class="line-modified"> 1634   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified"> 1635     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 1636 
 1637     stream-&gt;time_position = desired_offset;
 1638     stream-&gt;accumulated_base = 0;
 1639     stream-&gt;sample_index = -1;
 1640     stream-&gt;offset_in_sample = 0;
 1641     stream-&gt;segment_index = -1;
 1642     stream-&gt;sent_eos = FALSE;
 1643 
 1644     if (segment-&gt;flags &amp; GST_SEEK_FLAG_FLUSH)
 1645       gst_segment_init (&amp;stream-&gt;segment, GST_FORMAT_TIME);
 1646   }
 1647   segment-&gt;position = desired_offset;
 1648   segment-&gt;time = desired_offset;
 1649   if (segment-&gt;rate &gt;= 0) {
 1650     segment-&gt;start = desired_offset;
 1651 
<a name="61" id="anc61"></a><span class="line-modified"> 1652     /* we stop at the end */</span>
<span class="line-modified"> 1653     if (segment-&gt;stop == -1)</span>
<span class="line-modified"> 1654       segment-&gt;stop = segment-&gt;duration;</span>
 1655   } else {
 1656     segment-&gt;stop = desired_offset;
 1657   }
 1658 
 1659   if (qtdemux-&gt;fragmented)
 1660     qtdemux-&gt;fragmented_seek_pending = TRUE;
 1661 
 1662   return TRUE;
 1663 }
 1664 
 1665 /* do a seek in pull based mode */
 1666 static gboolean
 1667 gst_qtdemux_do_seek (GstQTDemux * qtdemux, GstPad * pad, GstEvent * event)
 1668 {
 1669   gdouble rate;
 1670   GstFormat format;
 1671   GstSeekFlags flags;
 1672   GstSeekType cur_type, stop_type;
 1673   gint64 cur, stop;
 1674   gboolean flush;
 1675   gboolean update;
 1676   GstSegment seeksegment;
 1677   guint32 seqnum = GST_SEQNUM_INVALID;
 1678   GstEvent *flush_event;
 1679   gboolean ret;
 1680 
 1681   if (event) {
 1682     GST_DEBUG_OBJECT (qtdemux, &quot;doing seek with event&quot;);
 1683 
 1684     gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags,
 1685         &amp;cur_type, &amp;cur, &amp;stop_type, &amp;stop);
 1686     seqnum = gst_event_get_seqnum (event);
 1687 
 1688     /* we have to have a format as the segment format. Try to convert
 1689      * if not. */
 1690     if (!gst_qtdemux_convert_seek (pad, &amp;format, cur_type, &amp;cur,
 1691             stop_type, &amp;stop))
 1692       goto no_format;
 1693 
 1694     GST_DEBUG_OBJECT (qtdemux, &quot;seek format %s&quot;, gst_format_get_name (format));
 1695   } else {
 1696     GST_DEBUG_OBJECT (qtdemux, &quot;doing seek without event&quot;);
 1697     flags = 0;
 1698   }
 1699 
 1700   flush = flags &amp; GST_SEEK_FLAG_FLUSH;
 1701 
 1702   /* stop streaming, either by flushing or by pausing the task */
 1703   if (flush) {
 1704     flush_event = gst_event_new_flush_start ();
 1705     if (seqnum != GST_SEQNUM_INVALID)
 1706       gst_event_set_seqnum (flush_event, seqnum);
 1707     /* unlock upstream pull_range */
 1708     gst_pad_push_event (qtdemux-&gt;sinkpad, gst_event_ref (flush_event));
 1709     /* make sure out loop function exits */
 1710     gst_qtdemux_push_event (qtdemux, flush_event);
 1711   } else {
 1712     /* non flushing seek, pause the task */
 1713     gst_pad_pause_task (qtdemux-&gt;sinkpad);
 1714   }
 1715 
 1716   /* wait for streaming to finish */
 1717   GST_PAD_STREAM_LOCK (qtdemux-&gt;sinkpad);
 1718 
 1719   /* copy segment, we need this because we still need the old
 1720    * segment when we close the current segment. */
 1721   memcpy (&amp;seeksegment, &amp;qtdemux-&gt;segment, sizeof (GstSegment));
 1722 
 1723   if (event) {
 1724     /* configure the segment with the seek variables */
 1725     GST_DEBUG_OBJECT (qtdemux, &quot;configuring seek&quot;);
 1726     if (!gst_segment_do_seek (&amp;seeksegment, rate, format, flags,
 1727             cur_type, cur, stop_type, stop, &amp;update)) {
 1728       ret = FALSE;
 1729       GST_ERROR_OBJECT (qtdemux, &quot;inconsistent seek values, doing nothing&quot;);
 1730     } else {
 1731       /* now do the seek */
 1732       ret = gst_qtdemux_perform_seek (qtdemux, &amp;seeksegment, seqnum, flags);
<a name="62" id="anc62"></a><span class="line-modified"> 1733     }</span>
 1734   } else {
 1735     /* now do the seek */
 1736     ret = gst_qtdemux_perform_seek (qtdemux, &amp;seeksegment, seqnum, flags);
 1737   }
 1738 
 1739   /* prepare for streaming again */
 1740   if (flush) {
 1741     flush_event = gst_event_new_flush_stop (TRUE);
 1742     if (seqnum != GST_SEQNUM_INVALID)
 1743       gst_event_set_seqnum (flush_event, seqnum);
 1744 
 1745     gst_pad_push_event (qtdemux-&gt;sinkpad, gst_event_ref (flush_event));
 1746     gst_qtdemux_push_event (qtdemux, flush_event);
<a name="63" id="anc63"></a><span class="line-modified"> 1747   }</span>
 1748 
 1749   /* commit the new segment */
 1750   memcpy (&amp;qtdemux-&gt;segment, &amp;seeksegment, sizeof (GstSegment));
 1751 
 1752   if (qtdemux-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
 1753     GstMessage *msg = gst_message_new_segment_start (GST_OBJECT_CAST (qtdemux),
 1754         qtdemux-&gt;segment.format, qtdemux-&gt;segment.position);
 1755     if (seqnum != GST_SEQNUM_INVALID)
 1756       gst_message_set_seqnum (msg, seqnum);
 1757     gst_element_post_message (GST_ELEMENT_CAST (qtdemux), msg);
 1758   }
 1759 
 1760   /* restart streaming, NEWSEGMENT will be sent from the streaming thread. */
 1761   gst_pad_start_task (qtdemux-&gt;sinkpad, (GstTaskFunction) gst_qtdemux_loop,
 1762       qtdemux-&gt;sinkpad, NULL);
 1763 
 1764   GST_PAD_STREAM_UNLOCK (qtdemux-&gt;sinkpad);
 1765 
 1766   return ret;
 1767 
 1768   /* ERRORS */
 1769 no_format:
 1770   {
 1771     GST_DEBUG_OBJECT (qtdemux, &quot;unsupported format given, seek aborted.&quot;);
 1772     return FALSE;
 1773   }
 1774 }
 1775 
 1776 static gboolean
 1777 qtdemux_ensure_index (GstQTDemux * qtdemux)
 1778 {
 1779   guint i;
 1780 
 1781   GST_DEBUG_OBJECT (qtdemux, &quot;collecting all metadata for all streams&quot;);
 1782 
 1783   /* Build complete index */
<a name="64" id="anc64"></a><span class="line-modified"> 1784   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified"> 1785     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 1786 
<a name="65" id="anc65"></a><span class="line-modified"> 1787     if (!qtdemux_parse_samples (qtdemux, stream, stream-&gt;n_samples - 1)) {</span>
<span class="line-modified"> 1788       GST_LOG_OBJECT (qtdemux,</span>
<span class="line-added"> 1789           &quot;Building complete index of track-id %u for seeking failed!&quot;,</span>
<span class="line-added"> 1790           stream-&gt;track_id);</span>
<span class="line-added"> 1791       return FALSE;</span>
<span class="line-added"> 1792     }</span>
 1793   }
<a name="66" id="anc66"></a>
 1794 
<a name="67" id="anc67"></a><span class="line-modified"> 1795   return TRUE;</span>






 1796 }
 1797 
 1798 static gboolean
 1799 gst_qtdemux_handle_src_event (GstPad * pad, GstObject * parent,
 1800     GstEvent * event)
 1801 {
 1802   gboolean res = TRUE;
 1803   GstQTDemux *qtdemux = GST_QTDEMUX (parent);
 1804 
 1805   switch (GST_EVENT_TYPE (event)) {
 1806     case GST_EVENT_SEEK:
 1807     {
 1808 #ifndef GST_DISABLE_GST_DEBUG
 1809       GstClockTime ts = gst_util_get_timestamp ();
 1810 #endif
 1811       guint32 seqnum = gst_event_get_seqnum (event);
 1812 
<a name="68" id="anc68"></a><span class="line-added"> 1813       qtdemux-&gt;received_seek = TRUE;</span>
<span class="line-added"> 1814 </span>
 1815       if (seqnum == qtdemux-&gt;segment_seqnum) {
 1816         GST_LOG_OBJECT (pad,
 1817             &quot;Drop duplicated SEEK event seqnum %&quot; G_GUINT32_FORMAT, seqnum);
 1818         gst_event_unref (event);
 1819         return TRUE;
 1820       }
 1821 
 1822       if (qtdemux-&gt;upstream_format_is_time &amp;&amp; qtdemux-&gt;fragmented) {
 1823         /* seek should be handled by upstream, we might need to re-download fragments */
 1824         GST_DEBUG_OBJECT (qtdemux,
 1825             &quot;let upstream handle seek for fragmented playback&quot;);
 1826         goto upstream;
 1827       }
 1828 
 1829       /* Build complete index for seeking;
 1830        * if not a fragmented file at least */
 1831       if (!qtdemux-&gt;fragmented)
 1832         if (!qtdemux_ensure_index (qtdemux))
 1833           goto index_failed;
 1834 #ifndef GST_DISABLE_GST_DEBUG
 1835       ts = gst_util_get_timestamp () - ts;
 1836       GST_INFO_OBJECT (qtdemux,
 1837           &quot;Time taken to parse index %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (ts));
 1838 #endif
 1839     }
 1840       if (qtdemux-&gt;pullbased) {
 1841         res = gst_qtdemux_do_seek (qtdemux, pad, event);
 1842       } else if (gst_pad_push_event (qtdemux-&gt;sinkpad, gst_event_ref (event))) {
 1843         GST_DEBUG_OBJECT (qtdemux, &quot;Upstream successfully seeked&quot;);
 1844         res = TRUE;
<a name="69" id="anc69"></a><span class="line-modified"> 1845       } else if (qtdemux-&gt;state == QTDEMUX_STATE_MOVIE</span>
<span class="line-added"> 1846           &amp;&amp; QTDEMUX_N_STREAMS (qtdemux)</span>
 1847           &amp;&amp; !qtdemux-&gt;fragmented) {
 1848         res = gst_qtdemux_do_push_seek (qtdemux, pad, event);
 1849       } else {
 1850         GST_DEBUG_OBJECT (qtdemux,
 1851             &quot;ignoring seek in push mode in current state&quot;);
 1852         res = FALSE;
 1853       }
 1854       gst_event_unref (event);
 1855       break;
 1856     default:
 1857     upstream:
 1858       res = gst_pad_event_default (pad, parent, event);
 1859       break;
 1860   }
 1861 
 1862 done:
 1863   return res;
 1864 
 1865   /* ERRORS */
 1866 index_failed:
 1867   {
 1868     GST_ERROR_OBJECT (qtdemux, &quot;Index failed&quot;);
 1869     gst_event_unref (event);
 1870     res = FALSE;
 1871     goto done;
 1872   }
 1873 }
 1874 
 1875 /* Find, for each track, the first sample in coding order that has a file offset &gt;= @byte_pos.
 1876  *
 1877  * If @fw is false, the coding order is explored backwards.
 1878  *
 1879  * If @set is true, each stream will be moved to its matched sample, or EOS if no matching
 1880  * sample is found for that track.
 1881  *
 1882  * The stream and sample index of the sample with the minimum offset in the direction explored
 1883  * (see @fw) is returned in the output parameters @_stream and @_index respectively.
 1884  *
 1885  * @_time is set to the QTSAMPLE_PTS of the matched sample with the minimum QTSAMPLE_PTS in the
 1886  * direction explored, which may not always match the QTSAMPLE_PTS of the sample returned in
 1887  * @_stream and @_index. */
 1888 static void
 1889 gst_qtdemux_find_sample (GstQTDemux * qtdemux, gint64 byte_pos, gboolean fw,
 1890     gboolean set, QtDemuxStream ** _stream, gint * _index, gint64 * _time)
 1891 {
<a name="70" id="anc70"></a><span class="line-modified"> 1892   gint i, index;</span>
 1893   gint64 time, min_time;
 1894   QtDemuxStream *stream;
<a name="71" id="anc71"></a><span class="line-added"> 1895   gint iter;</span>
 1896 
 1897   min_time = -1;
 1898   stream = NULL;
 1899   index = -1;
 1900 
<a name="72" id="anc72"></a><span class="line-modified"> 1901   for (iter = 0; iter &lt; QTDEMUX_N_STREAMS (qtdemux); iter++) {</span>
 1902     QtDemuxStream *str;
 1903     gint inc;
 1904     gboolean set_sample;
 1905 
<a name="73" id="anc73"></a><span class="line-modified"> 1906     str = QTDEMUX_NTH_STREAM (qtdemux, iter);</span>
 1907     set_sample = !set;
 1908 
 1909     if (fw) {
 1910       i = 0;
 1911       inc = 1;
 1912     } else {
 1913       i = str-&gt;n_samples - 1;
 1914       inc = -1;
 1915     }
 1916 
 1917     for (; (i &gt;= 0) &amp;&amp; (i &lt; str-&gt;n_samples); i += inc) {
 1918       if (str-&gt;samples[i].size == 0)
 1919         continue;
 1920 
 1921       if (fw &amp;&amp; (str-&gt;samples[i].offset &lt; byte_pos))
 1922         continue;
 1923 
 1924       if (!fw &amp;&amp; (str-&gt;samples[i].offset + str-&gt;samples[i].size &gt; byte_pos))
 1925         continue;
 1926 
<a name="74" id="anc74"></a><span class="line-modified"> 1927       /* move stream to first available sample */</span>
<span class="line-modified"> 1928       if (set) {</span>
<span class="line-modified"> 1929         gst_qtdemux_move_stream (qtdemux, str, i);</span>
<span class="line-modified"> 1930         set_sample = TRUE;</span>
<span class="line-modified"> 1931       }</span>
 1932 
 1933       /* avoid index from sparse streams since they might be far away */
 1934       if (!CUR_STREAM (str)-&gt;sparse) {
 1935         /* determine min/max time */
 1936         time = QTSAMPLE_PTS (str, &amp;str-&gt;samples[i]);
 1937         if (min_time == -1 || (!fw &amp;&amp; time &gt; min_time) ||
 1938             (fw &amp;&amp; time &lt; min_time)) {
 1939           min_time = time;
 1940         }
 1941 
 1942         /* determine stream with leading sample, to get its position */
 1943         if (!stream ||
 1944             (fw &amp;&amp; (str-&gt;samples[i].offset &lt; stream-&gt;samples[index].offset)) ||
 1945             (!fw &amp;&amp; (str-&gt;samples[i].offset &gt; stream-&gt;samples[index].offset))) {
 1946           stream = str;
 1947           index = i;
 1948         }
 1949       }
<a name="75" id="anc75"></a><span class="line-modified"> 1950       break;</span>
<span class="line-modified"> 1951     }</span>
 1952 
 1953     /* no sample for this stream, mark eos */
 1954     if (!set_sample)
 1955       gst_qtdemux_move_stream (qtdemux, str, str-&gt;n_samples);
 1956   }
 1957 
 1958   if (_time)
 1959     *_time = min_time;
 1960   if (_stream)
 1961     *_stream = stream;
 1962   if (_index)
 1963     *_index = index;
 1964 }
 1965 
<a name="76" id="anc76"></a><span class="line-added"> 1966 /* Copied from mpegtsbase code */</span>
<span class="line-added"> 1967 /* FIXME: replace this function when we add new util function for stream-id creation */</span>
<span class="line-added"> 1968 static gchar *</span>
<span class="line-added"> 1969 _get_upstream_id (GstQTDemux * demux)</span>
<span class="line-added"> 1970 {</span>
<span class="line-added"> 1971   gchar *upstream_id = gst_pad_get_stream_id (demux-&gt;sinkpad);</span>
<span class="line-added"> 1972 </span>
<span class="line-added"> 1973   if (!upstream_id) {</span>
<span class="line-added"> 1974     /* Try to create one from the upstream URI, else use a randome number */</span>
<span class="line-added"> 1975     GstQuery *query;</span>
<span class="line-added"> 1976     gchar *uri = NULL;</span>
<span class="line-added"> 1977 </span>
<span class="line-added"> 1978     /* Try to generate one from the URI query and</span>
<span class="line-added"> 1979      * if it fails take a random number instead */</span>
<span class="line-added"> 1980     query = gst_query_new_uri ();</span>
<span class="line-added"> 1981     if (gst_element_query (GST_ELEMENT_CAST (demux), query)) {</span>
<span class="line-added"> 1982       gst_query_parse_uri (query, &amp;uri);</span>
<span class="line-added"> 1983     }</span>
<span class="line-added"> 1984 </span>
<span class="line-added"> 1985     if (uri) {</span>
<span class="line-added"> 1986       GChecksum *cs;</span>
<span class="line-added"> 1987 </span>
<span class="line-added"> 1988       /* And then generate an SHA256 sum of the URI */</span>
<span class="line-added"> 1989       cs = g_checksum_new (G_CHECKSUM_SHA256);</span>
<span class="line-added"> 1990       g_checksum_update (cs, (const guchar *) uri, strlen (uri));</span>
<span class="line-added"> 1991       g_free (uri);</span>
<span class="line-added"> 1992       upstream_id = g_strdup (g_checksum_get_string (cs));</span>
<span class="line-added"> 1993       g_checksum_free (cs);</span>
<span class="line-added"> 1994     } else {</span>
<span class="line-added"> 1995       /* Just get some random number if the URI query fails */</span>
<span class="line-added"> 1996       GST_FIXME_OBJECT (demux, &quot;Creating random stream-id, consider &quot;</span>
<span class="line-added"> 1997           &quot;implementing a deterministic way of creating a stream-id&quot;);</span>
<span class="line-added"> 1998       upstream_id =</span>
<span class="line-added"> 1999           g_strdup_printf (&quot;%08x%08x%08x%08x&quot;, g_random_int (), g_random_int (),</span>
<span class="line-added"> 2000           g_random_int (), g_random_int ());</span>
<span class="line-added"> 2001     }</span>
<span class="line-added"> 2002 </span>
<span class="line-added"> 2003     gst_query_unref (query);</span>
<span class="line-added"> 2004   }</span>
<span class="line-added"> 2005   return upstream_id;</span>
<span class="line-added"> 2006 }</span>
<span class="line-added"> 2007 </span>
 2008 static QtDemuxStream *
<a name="77" id="anc77"></a><span class="line-modified"> 2009 _create_stream (GstQTDemux * demux, guint32 track_id)</span>
 2010 {
 2011   QtDemuxStream *stream;
<a name="78" id="anc78"></a><span class="line-added"> 2012   gchar *upstream_id;</span>
 2013 
 2014   stream = g_new0 (QtDemuxStream, 1);
<a name="79" id="anc79"></a><span class="line-added"> 2015   stream-&gt;demux = demux;</span>
<span class="line-added"> 2016   stream-&gt;track_id = track_id;</span>
<span class="line-added"> 2017   upstream_id = _get_upstream_id (demux);</span>
<span class="line-added"> 2018   stream-&gt;stream_id = g_strdup_printf (&quot;%s/%03u&quot;, upstream_id, track_id);</span>
<span class="line-added"> 2019   g_free (upstream_id);</span>
 2020   /* new streams always need a discont */
 2021   stream-&gt;discont = TRUE;
 2022   /* we enable clipping for raw audio/video streams */
 2023   stream-&gt;need_clip = FALSE;
 2024   stream-&gt;need_process = FALSE;
 2025   stream-&gt;segment_index = -1;
 2026   stream-&gt;time_position = 0;
 2027   stream-&gt;sample_index = -1;
 2028   stream-&gt;offset_in_sample = 0;
 2029   stream-&gt;new_stream = TRUE;
 2030   stream-&gt;multiview_mode = GST_VIDEO_MULTIVIEW_MODE_NONE;
 2031   stream-&gt;multiview_flags = GST_VIDEO_MULTIVIEW_FLAGS_NONE;
 2032   stream-&gt;protected = FALSE;
 2033   stream-&gt;protection_scheme_type = 0;
 2034   stream-&gt;protection_scheme_version = 0;
 2035   stream-&gt;protection_scheme_info = NULL;
 2036   stream-&gt;n_samples_moof = 0;
 2037   stream-&gt;duration_moof = 0;
 2038   stream-&gt;duration_last_moof = 0;
 2039   stream-&gt;alignment = 1;
 2040   stream-&gt;stream_tags = gst_tag_list_new_empty ();
 2041   gst_tag_list_set_scope (stream-&gt;stream_tags, GST_TAG_SCOPE_STREAM);
 2042   g_queue_init (&amp;stream-&gt;protection_scheme_event_queue);
<a name="80" id="anc80"></a><span class="line-added"> 2043   stream-&gt;ref_count = 1;</span>
<span class="line-added"> 2044   /* consistent default for push based mode */</span>
<span class="line-added"> 2045   gst_segment_init (&amp;stream-&gt;segment, GST_FORMAT_TIME);</span>
 2046   return stream;
 2047 }
 2048 
 2049 static gboolean
 2050 gst_qtdemux_setcaps (GstQTDemux * demux, GstCaps * caps)
 2051 {
 2052   GstStructure *structure;
 2053   const gchar *variant;
 2054   const GstCaps *mediacaps = NULL;
 2055 
 2056   GST_DEBUG_OBJECT (demux, &quot;Sink set caps: %&quot; GST_PTR_FORMAT, caps);
 2057 
 2058   structure = gst_caps_get_structure (caps, 0);
 2059   variant = gst_structure_get_string (structure, &quot;variant&quot;);
 2060 
 2061   if (variant &amp;&amp; strcmp (variant, &quot;mss-fragmented&quot;) == 0) {
 2062     QtDemuxStream *stream;
 2063     const GValue *value;
 2064 
 2065     demux-&gt;fragmented = TRUE;
 2066     demux-&gt;mss_mode = TRUE;
 2067 
<a name="81" id="anc81"></a><span class="line-modified"> 2068     if (QTDEMUX_N_STREAMS (demux) &gt; 1) {</span>
 2069       /* can&#39;t do this, we can only renegotiate for another mss format */
 2070       return FALSE;
 2071     }
 2072 
 2073     value = gst_structure_get_value (structure, &quot;media-caps&quot;);
 2074     /* create stream */
 2075     if (value) {
 2076       const GValue *timescale_v;
 2077 
 2078       /* TODO update when stream changes during playback */
 2079 
<a name="82" id="anc82"></a><span class="line-modified"> 2080       if (QTDEMUX_N_STREAMS (demux) == 0) {</span>
<span class="line-modified"> 2081         stream = _create_stream (demux, 1);</span>
<span class="line-modified"> 2082         g_ptr_array_add (demux-&gt;active_streams, stream);</span>

 2083         /* mss has no stsd/stsd entry, use id 0 as default */
 2084         stream-&gt;stsd_entries_length = 1;
 2085         stream-&gt;stsd_sample_description_id = stream-&gt;cur_stsd_entry_index = 0;
 2086         stream-&gt;stsd_entries = g_new0 (QtDemuxStreamStsdEntry, 1);
 2087       } else {
<a name="83" id="anc83"></a><span class="line-modified"> 2088         stream = QTDEMUX_NTH_STREAM (demux, 0);</span>
 2089       }
 2090 
 2091       timescale_v = gst_structure_get_value (structure, &quot;timescale&quot;);
 2092       if (timescale_v) {
 2093         stream-&gt;timescale = g_value_get_uint64 (timescale_v);
 2094       } else {
 2095         /* default mss timescale */
 2096         stream-&gt;timescale = 10000000;
 2097       }
 2098       demux-&gt;timescale = stream-&gt;timescale;
 2099 
 2100       mediacaps = gst_value_get_caps (value);
 2101       if (!CUR_STREAM (stream)-&gt;caps
 2102           || !gst_caps_is_equal_fixed (mediacaps, CUR_STREAM (stream)-&gt;caps)) {
 2103         GST_DEBUG_OBJECT (demux, &quot;We have a new caps %&quot; GST_PTR_FORMAT,
 2104             mediacaps);
 2105         stream-&gt;new_caps = TRUE;
 2106       }
 2107       gst_caps_replace (&amp;CUR_STREAM (stream)-&gt;caps, (GstCaps *) mediacaps);
 2108       structure = gst_caps_get_structure (mediacaps, 0);
 2109       if (g_str_has_prefix (gst_structure_get_name (structure), &quot;video&quot;)) {
 2110         stream-&gt;subtype = FOURCC_vide;
 2111 
 2112         gst_structure_get_int (structure, &quot;width&quot;, &amp;CUR_STREAM (stream)-&gt;width);
 2113         gst_structure_get_int (structure, &quot;height&quot;,
 2114             &amp;CUR_STREAM (stream)-&gt;height);
 2115         gst_structure_get_fraction (structure, &quot;framerate&quot;,
 2116             &amp;CUR_STREAM (stream)-&gt;fps_n, &amp;CUR_STREAM (stream)-&gt;fps_d);
 2117       } else if (g_str_has_prefix (gst_structure_get_name (structure), &quot;audio&quot;)) {
 2118         gint rate = 0;
 2119         stream-&gt;subtype = FOURCC_soun;
 2120         gst_structure_get_int (structure, &quot;channels&quot;,
 2121             &amp;CUR_STREAM (stream)-&gt;n_channels);
 2122         gst_structure_get_int (structure, &quot;rate&quot;, &amp;rate);
 2123         CUR_STREAM (stream)-&gt;rate = rate;
 2124       }
 2125     }
 2126     gst_caps_replace (&amp;demux-&gt;media_caps, (GstCaps *) mediacaps);
 2127   } else {
 2128     demux-&gt;mss_mode = FALSE;
 2129   }
 2130 
 2131   return TRUE;
 2132 }
 2133 
 2134 static void
 2135 gst_qtdemux_reset (GstQTDemux * qtdemux, gboolean hard)
 2136 {
<a name="84" id="anc84"></a><span class="line-modified"> 2137   gint i;</span>
 2138 
 2139   GST_DEBUG_OBJECT (qtdemux, &quot;Resetting demux&quot;);
 2140   gst_pad_stop_task (qtdemux-&gt;sinkpad);
 2141 
 2142   if (hard || qtdemux-&gt;upstream_format_is_time) {
 2143     qtdemux-&gt;state = QTDEMUX_STATE_INITIAL;
 2144     qtdemux-&gt;neededbytes = 16;
 2145     qtdemux-&gt;todrop = 0;
 2146     qtdemux-&gt;pullbased = FALSE;
 2147     qtdemux-&gt;posted_redirect = FALSE;
 2148     qtdemux-&gt;first_mdat = -1;
 2149     qtdemux-&gt;header_size = 0;
 2150     qtdemux-&gt;mdatoffset = -1;
 2151     qtdemux-&gt;restoredata_offset = -1;
 2152     if (qtdemux-&gt;mdatbuffer)
 2153       gst_buffer_unref (qtdemux-&gt;mdatbuffer);
 2154     if (qtdemux-&gt;restoredata_buffer)
 2155       gst_buffer_unref (qtdemux-&gt;restoredata_buffer);
 2156     qtdemux-&gt;mdatbuffer = NULL;
 2157     qtdemux-&gt;restoredata_buffer = NULL;
 2158     qtdemux-&gt;mdatleft = 0;
 2159     qtdemux-&gt;mdatsize = 0;
 2160     if (qtdemux-&gt;comp_brands)
 2161       gst_buffer_unref (qtdemux-&gt;comp_brands);
 2162     qtdemux-&gt;comp_brands = NULL;
 2163     qtdemux-&gt;last_moov_offset = -1;
 2164     if (qtdemux-&gt;moov_node_compressed) {
 2165       g_node_destroy (qtdemux-&gt;moov_node_compressed);
<a name="85" id="anc85"></a><span class="line-modified"> 2166       if (qtdemux-&gt;moov_node)</span>
 2167         g_free (qtdemux-&gt;moov_node-&gt;data);
 2168     }
 2169     qtdemux-&gt;moov_node_compressed = NULL;
 2170     if (qtdemux-&gt;moov_node)
 2171       g_node_destroy (qtdemux-&gt;moov_node);
 2172     qtdemux-&gt;moov_node = NULL;
 2173     if (qtdemux-&gt;tag_list)
 2174       gst_mini_object_unref (GST_MINI_OBJECT_CAST (qtdemux-&gt;tag_list));
 2175     qtdemux-&gt;tag_list = gst_tag_list_new_empty ();
 2176     gst_tag_list_set_scope (qtdemux-&gt;tag_list, GST_TAG_SCOPE_GLOBAL);
 2177 #if 0
 2178     if (qtdemux-&gt;element_index)
 2179       gst_object_unref (qtdemux-&gt;element_index);
 2180     qtdemux-&gt;element_index = NULL;
 2181 #endif
 2182     qtdemux-&gt;major_brand = 0;
<a name="86" id="anc86"></a>


 2183     qtdemux-&gt;upstream_format_is_time = FALSE;
 2184     qtdemux-&gt;upstream_seekable = FALSE;
 2185     qtdemux-&gt;upstream_size = 0;
 2186 
 2187     qtdemux-&gt;fragment_start = -1;
 2188     qtdemux-&gt;fragment_start_offset = -1;
 2189     qtdemux-&gt;duration = 0;
 2190     qtdemux-&gt;moof_offset = 0;
 2191     qtdemux-&gt;chapters_track_id = 0;
 2192     qtdemux-&gt;have_group_id = FALSE;
 2193     qtdemux-&gt;group_id = G_MAXUINT;
 2194 
 2195     g_queue_foreach (&amp;qtdemux-&gt;protection_event_queue, (GFunc) gst_event_unref,
 2196         NULL);
 2197     g_queue_clear (&amp;qtdemux-&gt;protection_event_queue);
<a name="87" id="anc87"></a><span class="line-added"> 2198 </span>
<span class="line-added"> 2199     qtdemux-&gt;received_seek = FALSE;</span>
<span class="line-added"> 2200     qtdemux-&gt;first_moof_already_parsed = FALSE;</span>
 2201   }
 2202   qtdemux-&gt;offset = 0;
 2203   gst_adapter_clear (qtdemux-&gt;adapter);
 2204   gst_segment_init (&amp;qtdemux-&gt;segment, GST_FORMAT_TIME);
<a name="88" id="anc88"></a><span class="line-modified"> 2205   qtdemux-&gt;need_segment = TRUE;</span>
 2206 
 2207   if (hard) {
<a name="89" id="anc89"></a><span class="line-modified"> 2208     qtdemux-&gt;segment_seqnum = GST_SEQNUM_INVALID;</span>
<span class="line-modified"> 2209     g_ptr_array_set_size (qtdemux-&gt;active_streams, 0);</span>
<span class="line-modified"> 2210     g_ptr_array_set_size (qtdemux-&gt;old_streams, 0);</span>


 2211     qtdemux-&gt;n_video_streams = 0;
 2212     qtdemux-&gt;n_audio_streams = 0;
 2213     qtdemux-&gt;n_sub_streams = 0;
 2214     qtdemux-&gt;exposed = FALSE;
 2215     qtdemux-&gt;fragmented = FALSE;
 2216     qtdemux-&gt;mss_mode = FALSE;
 2217     gst_caps_replace (&amp;qtdemux-&gt;media_caps, NULL);
 2218     qtdemux-&gt;timescale = 0;
 2219     qtdemux-&gt;got_moov = FALSE;
<a name="90" id="anc90"></a><span class="line-added"> 2220     qtdemux-&gt;cenc_aux_info_offset = 0;</span>
<span class="line-added"> 2221     qtdemux-&gt;cenc_aux_info_sizes = NULL;</span>
<span class="line-added"> 2222     qtdemux-&gt;cenc_aux_sample_count = 0;</span>
 2223     if (qtdemux-&gt;protection_system_ids) {
 2224       g_ptr_array_free (qtdemux-&gt;protection_system_ids, TRUE);
 2225       qtdemux-&gt;protection_system_ids = NULL;
 2226     }
<a name="91" id="anc91"></a><span class="line-added"> 2227     qtdemux-&gt;streams_aware = GST_OBJECT_PARENT (qtdemux)</span>
<span class="line-added"> 2228         &amp;&amp; GST_OBJECT_FLAG_IS_SET (GST_OBJECT_PARENT (qtdemux),</span>
<span class="line-added"> 2229         GST_BIN_FLAG_STREAMS_AWARE);</span>
<span class="line-added"> 2230 </span>
<span class="line-added"> 2231     if (qtdemux-&gt;preferred_protection_system_id) {</span>
<span class="line-added"> 2232       g_free (qtdemux-&gt;preferred_protection_system_id);</span>
<span class="line-added"> 2233       qtdemux-&gt;preferred_protection_system_id = NULL;</span>
<span class="line-added"> 2234     }</span>
 2235   } else if (qtdemux-&gt;mss_mode) {
 2236     gst_flow_combiner_reset (qtdemux-&gt;flowcombiner);
<a name="92" id="anc92"></a><span class="line-modified"> 2237     g_ptr_array_foreach (qtdemux-&gt;active_streams,</span>
<span class="line-modified"> 2238         (GFunc) gst_qtdemux_stream_clear, NULL);</span>
 2239   } else {
 2240     gst_flow_combiner_reset (qtdemux-&gt;flowcombiner);
<a name="93" id="anc93"></a><span class="line-modified"> 2241     for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified"> 2242       QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-modified"> 2243       stream-&gt;sent_eos = FALSE;</span>
<span class="line-modified"> 2244       stream-&gt;time_position = 0;</span>
<span class="line-added"> 2245       stream-&gt;accumulated_base = 0;</span>
 2246     }
<a name="94" id="anc94"></a>




 2247   }
 2248 }
<a name="95" id="anc95"></a>
 2249 
 2250 
 2251 /* Maps the @segment to the qt edts internal segments and pushes
 2252  * the correspnding segment event.
 2253  *
 2254  * If it ends up being at a empty segment, a gap will be pushed and the next
 2255  * edts segment will be activated in sequence.
 2256  *
 2257  * To be used in push-mode only */
 2258 static void
 2259 gst_qtdemux_map_and_push_segments (GstQTDemux * qtdemux, GstSegment * segment)
 2260 {
<a name="96" id="anc96"></a><span class="line-modified"> 2261   gint i, iter;</span>
 2262 
<a name="97" id="anc97"></a><span class="line-modified"> 2263   for (iter = 0; iter &lt; QTDEMUX_N_STREAMS (qtdemux); iter++) {</span>
<span class="line-modified"> 2264     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, iter);</span>
 2265 
 2266     stream-&gt;time_position = segment-&gt;start;
 2267 
 2268     /* in push mode we should be guaranteed that we will have empty segments
 2269      * at the beginning and then one segment after, other scenarios are not
 2270      * supported and are discarded when parsing the edts */
 2271     for (i = 0; i &lt; stream-&gt;n_segments; i++) {
 2272       if (stream-&gt;segments[i].stop_time &gt; segment-&gt;start) {
<a name="98" id="anc98"></a><span class="line-added"> 2273         /* push the empty segment and move to the next one */</span>
 2274         gst_qtdemux_activate_segment (qtdemux, stream, i,
 2275             stream-&gt;time_position);
 2276         if (QTSEGMENT_IS_EMPTY (&amp;stream-&gt;segments[i])) {
<a name="99" id="anc99"></a>
 2277           gst_qtdemux_send_gap_for_segment (qtdemux, stream, i,
 2278               stream-&gt;time_position);
<a name="100" id="anc100"></a><span class="line-added"> 2279 </span>
<span class="line-added"> 2280           /* accumulate previous segments */</span>
<span class="line-added"> 2281           if (GST_CLOCK_TIME_IS_VALID (stream-&gt;segment.stop))</span>
<span class="line-added"> 2282             stream-&gt;accumulated_base +=</span>
<span class="line-added"> 2283                 (stream-&gt;segment.stop -</span>
<span class="line-added"> 2284                 stream-&gt;segment.start) / ABS (stream-&gt;segment.rate);</span>
 2285           continue;
 2286         }
 2287 
 2288         g_assert (i == stream-&gt;n_segments - 1);
 2289       }
 2290     }
 2291   }
 2292 }
 2293 
<a name="101" id="anc101"></a><span class="line-added"> 2294 static void</span>
<span class="line-added"> 2295 gst_qtdemux_stream_concat (GstQTDemux * qtdemux, GPtrArray * dest,</span>
<span class="line-added"> 2296     GPtrArray * src)</span>
<span class="line-added"> 2297 {</span>
<span class="line-added"> 2298   guint i;</span>
<span class="line-added"> 2299   guint len;</span>
<span class="line-added"> 2300 </span>
<span class="line-added"> 2301   len = src-&gt;len;</span>
<span class="line-added"> 2302 </span>
<span class="line-added"> 2303   if (len == 0)</span>
<span class="line-added"> 2304     return;</span>
<span class="line-added"> 2305 </span>
<span class="line-added"> 2306   for (i = 0; i &lt; len; i++) {</span>
<span class="line-added"> 2307     QtDemuxStream *stream = g_ptr_array_index (src, i);</span>
<span class="line-added"> 2308 </span>
<span class="line-added"> 2309 #ifndef GST_DISABLE_GST_DEBUG</span>
<span class="line-added"> 2310     GST_DEBUG_OBJECT (qtdemux, &quot;Move stream %p (stream-id %s) to %p&quot;,</span>
<span class="line-added"> 2311         stream, GST_STR_NULL (stream-&gt;stream_id), dest);</span>
<span class="line-added"> 2312 #endif</span>
<span class="line-added"> 2313     g_ptr_array_add (dest, gst_qtdemux_stream_ref (stream));</span>
<span class="line-added"> 2314   }</span>
<span class="line-added"> 2315 </span>
<span class="line-added"> 2316   g_ptr_array_set_size (src, 0);</span>
<span class="line-added"> 2317 }</span>
<span class="line-added"> 2318 </span>
 2319 static gboolean
 2320 gst_qtdemux_handle_sink_event (GstPad * sinkpad, GstObject * parent,
 2321     GstEvent * event)
 2322 {
 2323   GstQTDemux *demux = GST_QTDEMUX (parent);
 2324   gboolean res = TRUE;
 2325 
 2326   GST_LOG_OBJECT (demux, &quot;handling %s event&quot;, GST_EVENT_TYPE_NAME (event));
 2327 
 2328   switch (GST_EVENT_TYPE (event)) {
 2329     case GST_EVENT_SEGMENT:
 2330     {
 2331       gint64 offset = 0;
 2332       QtDemuxStream *stream;
 2333       gint idx;
 2334       GstSegment segment;
 2335 
 2336       /* some debug output */
 2337       gst_event_copy_segment (event, &amp;segment);
 2338       GST_DEBUG_OBJECT (demux, &quot;received newsegment %&quot; GST_SEGMENT_FORMAT,
 2339           &amp;segment);
 2340 
<a name="102" id="anc102"></a>


 2341       if (segment.format == GST_FORMAT_TIME) {
<a name="103" id="anc103"></a>

 2342         demux-&gt;upstream_format_is_time = TRUE;
<a name="104" id="anc104"></a><span class="line-added"> 2343         demux-&gt;segment_seqnum = gst_event_get_seqnum (event);</span>
 2344       } else {
 2345         GST_DEBUG_OBJECT (demux, &quot;Not storing upstream newsegment, &quot;
 2346             &quot;not in time format&quot;);
 2347 
<a name="105" id="anc105"></a><span class="line-modified"> 2348         /* chain will send initial newsegment after pads have been added */</span>
<span class="line-modified"> 2349         if (demux-&gt;state != QTDEMUX_STATE_MOVIE || !QTDEMUX_N_STREAMS (demux)) {</span>
<span class="line-modified"> 2350           GST_DEBUG_OBJECT (demux, &quot;still starting, eating event&quot;);</span>
<span class="line-modified"> 2351           goto exit;</span>
<span class="line-modified"> 2352         }</span>
 2353       }
 2354 
 2355       /* check if this matches a time seek we received previously
 2356        * FIXME for backwards compatibility reasons we use the
 2357        * seek_offset here to compare. In the future we might want to
 2358        * change this to use the seqnum as it uniquely should identify
 2359        * the segment that corresponds to the seek. */
 2360       GST_DEBUG_OBJECT (demux, &quot;Stored seek offset: %&quot; G_GINT64_FORMAT
 2361           &quot;, received segment offset %&quot; G_GINT64_FORMAT,
 2362           demux-&gt;seek_offset, segment.start);
 2363       if (segment.format == GST_FORMAT_BYTES
 2364           &amp;&amp; demux-&gt;seek_offset == segment.start) {
 2365         GST_OBJECT_LOCK (demux);
 2366         offset = segment.start;
 2367 
 2368         segment.format = GST_FORMAT_TIME;
 2369         segment.start = demux-&gt;push_seek_start;
 2370         segment.stop = demux-&gt;push_seek_stop;
 2371         GST_DEBUG_OBJECT (demux, &quot;Replaced segment with stored seek &quot;
 2372             &quot;segment %&quot; GST_TIME_FORMAT &quot; - %&quot; GST_TIME_FORMAT,
 2373             GST_TIME_ARGS (segment.start), GST_TIME_ARGS (segment.stop));
<a name="106" id="anc106"></a><span class="line-modified"> 2374         GST_OBJECT_UNLOCK (demux);</span>
 2375       }
 2376 
 2377       /* we only expect a BYTE segment, e.g. following a seek */
 2378       if (segment.format == GST_FORMAT_BYTES) {
 2379         if (GST_CLOCK_TIME_IS_VALID (segment.start)) {
 2380           offset = segment.start;
 2381 
 2382           gst_qtdemux_find_sample (demux, segment.start, TRUE, FALSE, NULL,
 2383               NULL, (gint64 *) &amp; segment.start);
 2384           if ((gint64) segment.start &lt; 0)
 2385             segment.start = 0;
<a name="107" id="anc107"></a><span class="line-modified"> 2386         }</span>
 2387         if (GST_CLOCK_TIME_IS_VALID (segment.stop)) {
 2388           gst_qtdemux_find_sample (demux, segment.stop, FALSE, FALSE, NULL,
 2389               NULL, (gint64 *) &amp; segment.stop);
 2390           /* keyframe seeking should already arrange for start &gt;= stop,
 2391            * but make sure in other rare cases */
 2392           segment.stop = MAX (segment.stop, segment.start);
 2393         }
 2394       } else if (segment.format == GST_FORMAT_TIME) {
 2395         /* push all data on the adapter before starting this
 2396          * new segment */
 2397         gst_qtdemux_process_adapter (demux, TRUE);
 2398       } else {
 2399         GST_DEBUG_OBJECT (demux, &quot;unsupported segment format, ignoring&quot;);
 2400         goto exit;
 2401       }
 2402 
 2403       /* We shouldn&#39;t modify upstream driven TIME FORMAT segment */
 2404       if (!demux-&gt;upstream_format_is_time) {
<a name="108" id="anc108"></a><span class="line-modified"> 2405         /* accept upstream&#39;s notion of segment and distribute along */</span>
<span class="line-modified"> 2406         segment.format = GST_FORMAT_TIME;</span>
<span class="line-modified"> 2407         segment.position = segment.time = segment.start;</span>
<span class="line-modified"> 2408         segment.duration = demux-&gt;segment.duration;</span>
<span class="line-modified"> 2409         segment.base = gst_segment_to_running_time (&amp;demux-&gt;segment,</span>
<span class="line-modified"> 2410             GST_FORMAT_TIME, demux-&gt;segment.position);</span>
 2411       }
 2412 
 2413       gst_segment_copy_into (&amp;segment, &amp;demux-&gt;segment);
 2414       GST_DEBUG_OBJECT (demux, &quot;Pushing newseg %&quot; GST_SEGMENT_FORMAT, &amp;segment);
 2415 
 2416       /* map segment to internal qt segments and push on each stream */
<a name="109" id="anc109"></a><span class="line-modified"> 2417       if (QTDEMUX_N_STREAMS (demux)) {</span>
<span class="line-modified"> 2418         demux-&gt;need_segment = TRUE;</span>
<span class="line-modified"> 2419         gst_qtdemux_check_send_pending_segment (demux);</span>








 2420       }
 2421 
 2422       /* clear leftover in current segment, if any */
 2423       gst_adapter_clear (demux-&gt;adapter);
 2424 
 2425       /* set up streaming thread */
 2426       demux-&gt;offset = offset;
 2427       if (demux-&gt;upstream_format_is_time) {
 2428         GST_DEBUG_OBJECT (demux, &quot;Upstream is driving in time format, &quot;
 2429             &quot;set values to restart reading from a new atom&quot;);
 2430         demux-&gt;neededbytes = 16;
 2431         demux-&gt;todrop = 0;
 2432       } else {
 2433         gst_qtdemux_find_sample (demux, offset, TRUE, TRUE, &amp;stream, &amp;idx,
 2434             NULL);
<a name="110" id="anc110"></a><span class="line-modified"> 2435         if (stream) {</span>
<span class="line-modified"> 2436           demux-&gt;todrop = stream-&gt;samples[idx].offset - offset;</span>
<span class="line-modified"> 2437           demux-&gt;neededbytes = demux-&gt;todrop + stream-&gt;samples[idx].size;</span>
<span class="line-modified"> 2438         } else {</span>
<span class="line-modified"> 2439           /* set up for EOS */</span>
<span class="line-modified"> 2440           demux-&gt;neededbytes = -1;</span>
<span class="line-modified"> 2441           demux-&gt;todrop = 0;</span>
<span class="line-modified"> 2442         }</span>
 2443       }
 2444     exit:
 2445       gst_event_unref (event);
 2446       res = TRUE;
 2447       goto drop;
 2448     }
 2449     case GST_EVENT_FLUSH_START:
 2450     {
 2451       if (gst_event_get_seqnum (event) == demux-&gt;offset_seek_seqnum) {
 2452         gst_event_unref (event);
 2453         goto drop;
 2454       }
<a name="111" id="anc111"></a><span class="line-modified"> 2455       QTDEMUX_EXPOSE_LOCK (demux);</span>
<span class="line-added"> 2456       res = gst_pad_event_default (demux-&gt;sinkpad, parent, event);</span>
<span class="line-added"> 2457       QTDEMUX_EXPOSE_UNLOCK (demux);</span>
<span class="line-added"> 2458       goto drop;</span>
 2459     }
 2460     case GST_EVENT_FLUSH_STOP:
 2461     {
 2462       guint64 dur;
 2463 
 2464       dur = demux-&gt;segment.duration;
 2465       gst_qtdemux_reset (demux, FALSE);
 2466       demux-&gt;segment.duration = dur;
 2467 
 2468       if (gst_event_get_seqnum (event) == demux-&gt;offset_seek_seqnum) {
 2469         gst_event_unref (event);
 2470         goto drop;
 2471       }
 2472       break;
 2473     }
 2474     case GST_EVENT_EOS:
 2475       /* If we are in push mode, and get an EOS before we&#39;ve seen any streams,
 2476        * then error out - we have nowhere to send the EOS */
 2477       if (!demux-&gt;pullbased) {
 2478         gint i;
 2479         gboolean has_valid_stream = FALSE;
<a name="112" id="anc112"></a><span class="line-modified"> 2480         for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified"> 2481           if (QTDEMUX_NTH_STREAM (demux, i)-&gt;pad != NULL) {</span>
 2482             has_valid_stream = TRUE;
 2483             break;
 2484           }
 2485         }
 2486         if (!has_valid_stream)
 2487           gst_qtdemux_post_no_playable_stream_error (demux);
 2488         else {
 2489           GST_DEBUG_OBJECT (demux, &quot;Data still available after EOS: %u&quot;,
 2490               (guint) gst_adapter_available (demux-&gt;adapter));
 2491           if (gst_qtdemux_process_adapter (demux, TRUE) != GST_FLOW_OK) {
 2492             res = FALSE;
<a name="113" id="anc113"></a><span class="line-modified"> 2493           }</span>
 2494         }
 2495       }
 2496       break;
 2497     case GST_EVENT_CAPS:{
 2498       GstCaps *caps = NULL;
 2499 
 2500       gst_event_parse_caps (event, &amp;caps);
 2501       gst_qtdemux_setcaps (demux, caps);
 2502       res = TRUE;
 2503       gst_event_unref (event);
 2504       goto drop;
 2505     }
 2506     case GST_EVENT_PROTECTION:
 2507     {
 2508       const gchar *system_id = NULL;
 2509 
 2510       gst_event_parse_protection (event, &amp;system_id, NULL, NULL);
 2511       GST_DEBUG_OBJECT (demux, &quot;Received protection event for system ID %s&quot;,
 2512           system_id);
 2513       gst_qtdemux_append_protection_system_id (demux, system_id);
 2514       /* save the event for later, for source pads that have not been created */
 2515       g_queue_push_tail (&amp;demux-&gt;protection_event_queue, gst_event_ref (event));
 2516       /* send it to all pads that already exist */
 2517       gst_qtdemux_push_event (demux, event);
 2518       res = TRUE;
 2519       goto drop;
 2520     }
<a name="114" id="anc114"></a><span class="line-added"> 2521     case GST_EVENT_STREAM_START:</span>
<span class="line-added"> 2522     {</span>
<span class="line-added"> 2523       res = TRUE;</span>
<span class="line-added"> 2524       gst_event_unref (event);</span>
<span class="line-added"> 2525 </span>
<span class="line-added"> 2526       /* Drain all the buffers */</span>
<span class="line-added"> 2527       gst_qtdemux_process_adapter (demux, TRUE);</span>
<span class="line-added"> 2528       gst_qtdemux_reset (demux, FALSE);</span>
<span class="line-added"> 2529       /* We expect new moov box after new stream-start event */</span>
<span class="line-added"> 2530       if (demux-&gt;exposed) {</span>
<span class="line-added"> 2531         gst_qtdemux_stream_concat (demux,</span>
<span class="line-added"> 2532             demux-&gt;old_streams, demux-&gt;active_streams);</span>
<span class="line-added"> 2533       }</span>
<span class="line-added"> 2534 </span>
<span class="line-added"> 2535       goto drop;</span>
<span class="line-added"> 2536     }</span>
 2537     default:
 2538       break;
 2539   }
 2540 
 2541   res = gst_pad_event_default (demux-&gt;sinkpad, parent, event) &amp; res;
 2542 
 2543 drop:
 2544   return res;
 2545 }
 2546 
<a name="115" id="anc115"></a><span class="line-added"> 2547 static gboolean</span>
<span class="line-added"> 2548 gst_qtdemux_handle_sink_query (GstPad * pad, GstObject * parent,</span>
<span class="line-added"> 2549     GstQuery * query)</span>
<span class="line-added"> 2550 {</span>
<span class="line-added"> 2551   GstQTDemux *demux = GST_QTDEMUX (parent);</span>
<span class="line-added"> 2552   gboolean res = FALSE;</span>
<span class="line-added"> 2553 </span>
<span class="line-added"> 2554   switch (GST_QUERY_TYPE (query)) {</span>
<span class="line-added"> 2555     case GST_QUERY_BITRATE:</span>
<span class="line-added"> 2556     {</span>
<span class="line-added"> 2557       GstClockTime duration;</span>
<span class="line-added"> 2558 </span>
<span class="line-added"> 2559       /* populate demux-&gt;upstream_size if not done yet */</span>
<span class="line-added"> 2560       gst_qtdemux_check_seekability (demux);</span>
<span class="line-added"> 2561 </span>
<span class="line-added"> 2562       if (demux-&gt;upstream_size != -1</span>
<span class="line-added"> 2563           &amp;&amp; gst_qtdemux_get_duration (demux, &amp;duration)) {</span>
<span class="line-added"> 2564         guint bitrate =</span>
<span class="line-added"> 2565             gst_util_uint64_scale (8 * demux-&gt;upstream_size, GST_SECOND,</span>
<span class="line-added"> 2566             duration);</span>
<span class="line-added"> 2567 </span>
<span class="line-added"> 2568         GST_LOG_OBJECT (demux, &quot;bitrate query byte length: %&quot; G_GUINT64_FORMAT</span>
<span class="line-added"> 2569             &quot; duration %&quot; GST_TIME_FORMAT &quot; resulting a bitrate of %u&quot;,</span>
<span class="line-added"> 2570             demux-&gt;upstream_size, GST_TIME_ARGS (duration), bitrate);</span>
<span class="line-added"> 2571 </span>
<span class="line-added"> 2572         /* TODO: better results based on ranges/index tables */</span>
<span class="line-added"> 2573         gst_query_set_bitrate (query, bitrate);</span>
<span class="line-added"> 2574         res = TRUE;</span>
<span class="line-added"> 2575       }</span>
<span class="line-added"> 2576       break;</span>
<span class="line-added"> 2577     }</span>
<span class="line-added"> 2578     default:</span>
<span class="line-added"> 2579       res = gst_pad_query_default (pad, (GstObject *) demux, query);</span>
<span class="line-added"> 2580       break;</span>
<span class="line-added"> 2581   }</span>
<span class="line-added"> 2582 </span>
<span class="line-added"> 2583   return res;</span>
<span class="line-added"> 2584 }</span>
<span class="line-added"> 2585 </span>
<span class="line-added"> 2586 </span>
 2587 #if 0
 2588 static void
 2589 gst_qtdemux_set_index (GstElement * element, GstIndex * index)
 2590 {
 2591   GstQTDemux *demux = GST_QTDEMUX (element);
 2592 
 2593   GST_OBJECT_LOCK (demux);
 2594   if (demux-&gt;element_index)
 2595     gst_object_unref (demux-&gt;element_index);
 2596   if (index) {
 2597     demux-&gt;element_index = gst_object_ref (index);
 2598   } else {
 2599     demux-&gt;element_index = NULL;
 2600   }
 2601   GST_OBJECT_UNLOCK (demux);
 2602   /* object lock might be taken again */
 2603   if (index)
 2604     gst_index_get_writer_id (index, GST_OBJECT (element), &amp;demux-&gt;index_id);
 2605   GST_DEBUG_OBJECT (demux, &quot;Set index %&quot; GST_PTR_FORMAT &quot;for writer id %d&quot;,
 2606       demux-&gt;element_index, demux-&gt;index_id);
 2607 }
 2608 
 2609 static GstIndex *
 2610 gst_qtdemux_get_index (GstElement * element)
 2611 {
 2612   GstIndex *result = NULL;
 2613   GstQTDemux *demux = GST_QTDEMUX (element);
 2614 
 2615   GST_OBJECT_LOCK (demux);
 2616   if (demux-&gt;element_index)
 2617     result = gst_object_ref (demux-&gt;element_index);
 2618   GST_OBJECT_UNLOCK (demux);
 2619 
 2620   GST_DEBUG_OBJECT (demux, &quot;Returning index %&quot; GST_PTR_FORMAT, result);
 2621 
 2622   return result;
 2623 }
 2624 #endif
 2625 
 2626 static void
 2627 gst_qtdemux_stbl_free (QtDemuxStream * stream)
 2628 {
 2629   g_free ((gpointer) stream-&gt;stco.data);
 2630   stream-&gt;stco.data = NULL;
 2631   g_free ((gpointer) stream-&gt;stsz.data);
 2632   stream-&gt;stsz.data = NULL;
 2633   g_free ((gpointer) stream-&gt;stsc.data);
 2634   stream-&gt;stsc.data = NULL;
 2635   g_free ((gpointer) stream-&gt;stts.data);
 2636   stream-&gt;stts.data = NULL;
 2637   g_free ((gpointer) stream-&gt;stss.data);
 2638   stream-&gt;stss.data = NULL;
 2639   g_free ((gpointer) stream-&gt;stps.data);
 2640   stream-&gt;stps.data = NULL;
 2641   g_free ((gpointer) stream-&gt;ctts.data);
 2642   stream-&gt;ctts.data = NULL;
 2643 }
 2644 
 2645 static void
<a name="116" id="anc116"></a><span class="line-modified"> 2646 gst_qtdemux_stream_flush_segments_data (QtDemuxStream * stream)</span>

 2647 {
 2648   g_free (stream-&gt;segments);
 2649   stream-&gt;segments = NULL;
 2650   stream-&gt;segment_index = -1;
 2651   stream-&gt;accumulated_base = 0;
 2652 }
 2653 
 2654 static void
<a name="117" id="anc117"></a><span class="line-modified"> 2655 gst_qtdemux_stream_flush_samples_data (QtDemuxStream * stream)</span>

 2656 {
 2657   g_free (stream-&gt;samples);
 2658   stream-&gt;samples = NULL;
 2659   gst_qtdemux_stbl_free (stream);
 2660 
 2661   /* fragments */
 2662   g_free (stream-&gt;ra_entries);
 2663   stream-&gt;ra_entries = NULL;
 2664   stream-&gt;n_ra_entries = 0;
 2665 
 2666   stream-&gt;sample_index = -1;
 2667   stream-&gt;stbl_index = -1;
 2668   stream-&gt;n_samples = 0;
 2669   stream-&gt;time_position = 0;
 2670 
 2671   stream-&gt;n_samples_moof = 0;
 2672   stream-&gt;duration_moof = 0;
 2673   stream-&gt;duration_last_moof = 0;
 2674 }
 2675 
 2676 static void
<a name="118" id="anc118"></a><span class="line-modified"> 2677 gst_qtdemux_stream_clear (QtDemuxStream * stream)</span>
 2678 {
 2679   gint i;
 2680   if (stream-&gt;allocator)
 2681     gst_object_unref (stream-&gt;allocator);
 2682   while (stream-&gt;buffers) {
 2683     gst_buffer_unref (GST_BUFFER_CAST (stream-&gt;buffers-&gt;data));
 2684     stream-&gt;buffers = g_slist_delete_link (stream-&gt;buffers, stream-&gt;buffers);
 2685   }
 2686   for (i = 0; i &lt; stream-&gt;stsd_entries_length; i++) {
 2687     QtDemuxStreamStsdEntry *entry = &amp;stream-&gt;stsd_entries[i];
 2688     if (entry-&gt;rgb8_palette) {
 2689       gst_memory_unref (entry-&gt;rgb8_palette);
 2690       entry-&gt;rgb8_palette = NULL;
<a name="119" id="anc119"></a><span class="line-modified"> 2691     }</span>
 2692     entry-&gt;sparse = FALSE;
 2693   }
 2694 
<a name="120" id="anc120"></a><span class="line-modified"> 2695   if (stream-&gt;stream_tags)</span>
<span class="line-added"> 2696     gst_tag_list_unref (stream-&gt;stream_tags);</span>
<span class="line-added"> 2697 </span>
 2698   stream-&gt;stream_tags = gst_tag_list_new_empty ();
 2699   gst_tag_list_set_scope (stream-&gt;stream_tags, GST_TAG_SCOPE_STREAM);
 2700   g_free (stream-&gt;redirect_uri);
 2701   stream-&gt;redirect_uri = NULL;
 2702   stream-&gt;sent_eos = FALSE;
 2703   stream-&gt;protected = FALSE;
 2704   if (stream-&gt;protection_scheme_info) {
 2705     if (stream-&gt;protection_scheme_type == FOURCC_cenc) {
 2706       QtDemuxCencSampleSetInfo *info =
 2707           (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;
 2708       if (info-&gt;default_properties)
 2709         gst_structure_free (info-&gt;default_properties);
 2710       if (info-&gt;crypto_info)
 2711         g_ptr_array_free (info-&gt;crypto_info, TRUE);
<a name="121" id="anc121"></a><span class="line-modified"> 2712     }</span>
 2713     g_free (stream-&gt;protection_scheme_info);
 2714     stream-&gt;protection_scheme_info = NULL;
 2715   }
 2716   stream-&gt;protection_scheme_type = 0;
 2717   stream-&gt;protection_scheme_version = 0;
 2718   g_queue_foreach (&amp;stream-&gt;protection_scheme_event_queue,
 2719       (GFunc) gst_event_unref, NULL);
 2720   g_queue_clear (&amp;stream-&gt;protection_scheme_event_queue);
<a name="122" id="anc122"></a><span class="line-modified"> 2721   gst_qtdemux_stream_flush_segments_data (stream);</span>
<span class="line-modified"> 2722   gst_qtdemux_stream_flush_samples_data (stream);</span>
 2723 }
 2724 
 2725 static void
<a name="123" id="anc123"></a><span class="line-modified"> 2726 gst_qtdemux_stream_reset (QtDemuxStream * stream)</span>
 2727 {
 2728   gint i;
<a name="124" id="anc124"></a><span class="line-modified"> 2729   gst_qtdemux_stream_clear (stream);</span>
 2730   for (i = 0; i &lt; stream-&gt;stsd_entries_length; i++) {
 2731     QtDemuxStreamStsdEntry *entry = &amp;stream-&gt;stsd_entries[i];
 2732     if (entry-&gt;caps) {
 2733       gst_caps_unref (entry-&gt;caps);
 2734       entry-&gt;caps = NULL;
 2735     }
 2736   }
 2737   g_free (stream-&gt;stsd_entries);
 2738   stream-&gt;stsd_entries = NULL;
 2739   stream-&gt;stsd_entries_length = 0;
 2740 }
 2741 
<a name="125" id="anc125"></a><span class="line-modified"> 2742 static QtDemuxStream *</span>
<span class="line-modified"> 2743 gst_qtdemux_stream_ref (QtDemuxStream * stream)</span>

 2744 {
<a name="126" id="anc126"></a><span class="line-modified"> 2745   g_atomic_int_add (&amp;stream-&gt;ref_count, 1);</span>
<span class="line-modified"> 2746 </span>
<span class="line-modified"> 2747   return stream;</span>




 2748 }
 2749 
 2750 static void
<a name="127" id="anc127"></a><span class="line-modified"> 2751 gst_qtdemux_stream_unref (QtDemuxStream * stream)</span>
 2752 {
<a name="128" id="anc128"></a><span class="line-modified"> 2753   if (g_atomic_int_dec_and_test (&amp;stream-&gt;ref_count)) {</span>
<span class="line-modified"> 2754     gst_qtdemux_stream_reset (stream);</span>
<span class="line-modified"> 2755     gst_tag_list_unref (stream-&gt;stream_tags);</span>
<span class="line-modified"> 2756     if (stream-&gt;pad) {</span>
<span class="line-modified"> 2757       GstQTDemux *demux = stream-&gt;demux;</span>
<span class="line-modified"> 2758       gst_element_remove_pad (GST_ELEMENT_CAST (demux), stream-&gt;pad);</span>
<span class="line-added"> 2759       gst_flow_combiner_remove_pad (demux-&gt;flowcombiner, stream-&gt;pad);</span>
<span class="line-added"> 2760     }</span>
<span class="line-added"> 2761     g_free (stream-&gt;stream_id);</span>
<span class="line-added"> 2762     g_free (stream);</span>
<span class="line-added"> 2763   }</span>
 2764 }
 2765 
 2766 static GstStateChangeReturn
 2767 gst_qtdemux_change_state (GstElement * element, GstStateChange transition)
 2768 {
 2769   GstQTDemux *qtdemux = GST_QTDEMUX (element);
 2770   GstStateChangeReturn result = GST_STATE_CHANGE_FAILURE;
 2771 
 2772   switch (transition) {
<a name="129" id="anc129"></a><span class="line-modified"> 2773     case GST_STATE_CHANGE_READY_TO_PAUSED:</span>
<span class="line-added"> 2774       gst_qtdemux_reset (qtdemux, TRUE);</span>
 2775       break;
 2776     default:
 2777       break;
 2778   }
 2779 
 2780   result = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
 2781 
 2782   switch (transition) {
 2783     case GST_STATE_CHANGE_PAUSED_TO_READY:{
 2784       gst_qtdemux_reset (qtdemux, TRUE);
 2785       break;
 2786     }
 2787     default:
 2788       break;
 2789   }
 2790 
 2791   return result;
 2792 }
 2793 
<a name="130" id="anc130"></a><span class="line-added"> 2794 static void</span>
<span class="line-added"> 2795 gst_qtdemux_set_context (GstElement * element, GstContext * context)</span>
<span class="line-added"> 2796 {</span>
<span class="line-added"> 2797   GstQTDemux *qtdemux = GST_QTDEMUX (element);</span>
<span class="line-added"> 2798 </span>
<span class="line-added"> 2799   g_return_if_fail (GST_IS_CONTEXT (context));</span>
<span class="line-added"> 2800 </span>
<span class="line-added"> 2801   if (gst_context_has_context_type (context,</span>
<span class="line-added"> 2802           &quot;drm-preferred-decryption-system-id&quot;)) {</span>
<span class="line-added"> 2803     const GstStructure *s;</span>
<span class="line-added"> 2804 </span>
<span class="line-added"> 2805     s = gst_context_get_structure (context);</span>
<span class="line-added"> 2806     g_free (qtdemux-&gt;preferred_protection_system_id);</span>
<span class="line-added"> 2807     qtdemux-&gt;preferred_protection_system_id =</span>
<span class="line-added"> 2808         g_strdup (gst_structure_get_string (s, &quot;decryption-system-id&quot;));</span>
<span class="line-added"> 2809     GST_DEBUG_OBJECT (element, &quot;set preferred decryption system to %s&quot;,</span>
<span class="line-added"> 2810         qtdemux-&gt;preferred_protection_system_id);</span>
<span class="line-added"> 2811   }</span>
<span class="line-added"> 2812 </span>
<span class="line-added"> 2813   GST_ELEMENT_CLASS (parent_class)-&gt;set_context (element, context);</span>
<span class="line-added"> 2814 }</span>
<span class="line-added"> 2815 </span>
 2816 static void
 2817 qtdemux_parse_ftyp (GstQTDemux * qtdemux, const guint8 * buffer, gint length)
 2818 {
 2819   /* counts as header data */
 2820   qtdemux-&gt;header_size += length;
 2821 
 2822   /* only consider at least a sufficiently complete ftyp atom */
 2823   if (length &gt;= 20) {
 2824     GstBuffer *buf;
 2825 
 2826     qtdemux-&gt;major_brand = QT_FOURCC (buffer + 8);
 2827     GST_DEBUG_OBJECT (qtdemux, &quot;major brand: %&quot; GST_FOURCC_FORMAT,
 2828         GST_FOURCC_ARGS (qtdemux-&gt;major_brand));
 2829     if (qtdemux-&gt;comp_brands)
 2830       gst_buffer_unref (qtdemux-&gt;comp_brands);
 2831     buf = qtdemux-&gt;comp_brands = gst_buffer_new_and_alloc (length - 16);
 2832     gst_buffer_fill (buf, 0, buffer + 16, length - 16);
 2833   }
 2834 }
 2835 
 2836 static void
 2837 qtdemux_handle_xmp_taglist (GstQTDemux * qtdemux, GstTagList * taglist,
 2838     GstTagList * xmptaglist)
 2839 {
 2840   /* Strip out bogus fields */
 2841   if (xmptaglist) {
 2842     if (gst_tag_list_get_scope (taglist) == GST_TAG_SCOPE_GLOBAL) {
 2843       gst_tag_list_remove_tag (xmptaglist, GST_TAG_VIDEO_CODEC);
 2844       gst_tag_list_remove_tag (xmptaglist, GST_TAG_AUDIO_CODEC);
 2845     } else {
 2846       gst_tag_list_remove_tag (xmptaglist, GST_TAG_CONTAINER_FORMAT);
 2847     }
 2848 
 2849     GST_DEBUG_OBJECT (qtdemux, &quot;Found XMP tags %&quot; GST_PTR_FORMAT, xmptaglist);
 2850 
<a name="131" id="anc131"></a><span class="line-modified"> 2851     /* prioritize native tags using _KEEP mode */</span>
 2852     gst_tag_list_insert (taglist, xmptaglist, GST_TAG_MERGE_KEEP);
 2853     gst_tag_list_unref (xmptaglist);
 2854   }
 2855 }
 2856 
<a name="132" id="anc132"></a><span class="line-added"> 2857 static void</span>
<span class="line-added"> 2858 qtdemux_update_default_sample_encryption_settings (GstQTDemux * qtdemux,</span>
<span class="line-added"> 2859     QtDemuxCencSampleSetInfo * info, guint32 is_encrypted, guint8 iv_size,</span>
<span class="line-added"> 2860     const guint8 * kid)</span>
<span class="line-added"> 2861 {</span>
<span class="line-added"> 2862   GstBuffer *kid_buf = gst_buffer_new_allocate (NULL, 16, NULL);</span>
<span class="line-added"> 2863   gst_buffer_fill (kid_buf, 0, kid, 16);</span>
<span class="line-added"> 2864   if (info-&gt;default_properties)</span>
<span class="line-added"> 2865     gst_structure_free (info-&gt;default_properties);</span>
<span class="line-added"> 2866   info-&gt;default_properties =</span>
<span class="line-added"> 2867       gst_structure_new (&quot;application/x-cenc&quot;,</span>
<span class="line-added"> 2868       &quot;iv_size&quot;, G_TYPE_UINT, iv_size,</span>
<span class="line-added"> 2869       &quot;encrypted&quot;, G_TYPE_BOOLEAN, (is_encrypted == 1),</span>
<span class="line-added"> 2870       &quot;kid&quot;, GST_TYPE_BUFFER, kid_buf, NULL);</span>
<span class="line-added"> 2871   GST_DEBUG_OBJECT (qtdemux, &quot;default sample properties: &quot;</span>
<span class="line-added"> 2872       &quot;is_encrypted=%u, iv_size=%u&quot;, is_encrypted, iv_size);</span>
<span class="line-added"> 2873   gst_buffer_unref (kid_buf);</span>
<span class="line-added"> 2874 }</span>
<span class="line-added"> 2875 </span>
<span class="line-added"> 2876 static gboolean</span>
<span class="line-added"> 2877 qtdemux_update_default_piff_encryption_settings (GstQTDemux * qtdemux,</span>
<span class="line-added"> 2878     QtDemuxCencSampleSetInfo * info, GstByteReader * br)</span>
<span class="line-added"> 2879 {</span>
<span class="line-added"> 2880   guint32 algorithm_id = 0;</span>
<span class="line-added"> 2881   const guint8 *kid;</span>
<span class="line-added"> 2882   gboolean is_encrypted = TRUE;</span>
<span class="line-added"> 2883   guint8 iv_size = 8;</span>
<span class="line-added"> 2884 </span>
<span class="line-added"> 2885   if (!gst_byte_reader_get_uint24_le (br, &amp;algorithm_id)) {</span>
<span class="line-added"> 2886     GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s algorithm ID field&quot;);</span>
<span class="line-added"> 2887     return FALSE;</span>
<span class="line-added"> 2888   }</span>
<span class="line-added"> 2889 </span>
<span class="line-added"> 2890   algorithm_id &gt;&gt;= 8;</span>
<span class="line-added"> 2891   if (algorithm_id == 0) {</span>
<span class="line-added"> 2892     is_encrypted = FALSE;</span>
<span class="line-added"> 2893   } else if (algorithm_id == 1) {</span>
<span class="line-added"> 2894     GST_DEBUG_OBJECT (qtdemux, &quot;AES 128-bits CTR encrypted stream&quot;);</span>
<span class="line-added"> 2895   } else if (algorithm_id == 2) {</span>
<span class="line-added"> 2896     GST_DEBUG_OBJECT (qtdemux, &quot;AES 128-bits CBC encrypted stream&quot;);</span>
<span class="line-added"> 2897   }</span>
<span class="line-added"> 2898 </span>
<span class="line-added"> 2899   if (!gst_byte_reader_get_uint8 (br, &amp;iv_size))</span>
<span class="line-added"> 2900     return FALSE;</span>
<span class="line-added"> 2901 </span>
<span class="line-added"> 2902   if (!gst_byte_reader_get_data (br, 16, &amp;kid))</span>
<span class="line-added"> 2903     return FALSE;</span>
<span class="line-added"> 2904 </span>
<span class="line-added"> 2905   qtdemux_update_default_sample_encryption_settings (qtdemux, info,</span>
<span class="line-added"> 2906       is_encrypted, iv_size, kid);</span>
<span class="line-added"> 2907   gst_structure_set (info-&gt;default_properties, &quot;piff_algorithm_id&quot;,</span>
<span class="line-added"> 2908       G_TYPE_UINT, algorithm_id, NULL);</span>
<span class="line-added"> 2909   return TRUE;</span>
<span class="line-added"> 2910 }</span>
<span class="line-added"> 2911 </span>
<span class="line-added"> 2912 </span>
 2913 static void
 2914 qtdemux_parse_piff (GstQTDemux * qtdemux, const guint8 * buffer, gint length,
 2915     guint offset)
 2916 {
 2917   GstByteReader br;
 2918   guint8 version;
 2919   guint32 flags = 0;
 2920   guint i;
<a name="133" id="anc133"></a><span class="line-modified"> 2921   guint iv_size = 8;</span>
 2922   QtDemuxStream *stream;
 2923   GstStructure *structure;
 2924   QtDemuxCencSampleSetInfo *ss_info = NULL;
 2925   const gchar *system_id;
 2926   gboolean uses_sub_sample_encryption = FALSE;
 2927   guint32 sample_count;
 2928 
<a name="134" id="anc134"></a><span class="line-modified"> 2929   if (QTDEMUX_N_STREAMS (qtdemux) == 0)</span>
 2930     return;
 2931 
<a name="135" id="anc135"></a><span class="line-modified"> 2932   stream = QTDEMUX_NTH_STREAM (qtdemux, 0);</span>
 2933 
 2934   structure = gst_caps_get_structure (CUR_STREAM (stream)-&gt;caps, 0);
 2935   if (!gst_structure_has_name (structure, &quot;application/x-cenc&quot;)) {
 2936     GST_WARNING_OBJECT (qtdemux,
 2937         &quot;Attempting PIFF box parsing on an unencrypted stream.&quot;);
 2938     return;
 2939   }
 2940 
 2941   gst_structure_get (structure, GST_PROTECTION_SYSTEM_ID_CAPS_FIELD,
 2942       G_TYPE_STRING, &amp;system_id, NULL);
 2943   gst_qtdemux_append_protection_system_id (qtdemux, system_id);
 2944 
 2945   stream-&gt;protected = TRUE;
 2946   stream-&gt;protection_scheme_type = FOURCC_cenc;
 2947 
 2948   if (!stream-&gt;protection_scheme_info)
 2949     stream-&gt;protection_scheme_info = g_new0 (QtDemuxCencSampleSetInfo, 1);
 2950 
 2951   ss_info = (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;
<a name="136" id="anc136"></a><span class="line-added"> 2952   if (!ss_info-&gt;default_properties) {</span>
<span class="line-added"> 2953     ss_info-&gt;default_properties =</span>
<span class="line-added"> 2954         gst_structure_new (&quot;application/x-cenc&quot;,</span>
<span class="line-added"> 2955         &quot;iv_size&quot;, G_TYPE_UINT, iv_size, &quot;encrypted&quot;, G_TYPE_BOOLEAN, TRUE,</span>
<span class="line-added"> 2956         NULL);</span>
 2957 
<a name="137" id="anc137"></a><span class="line-modified"> 2958   }</span>





 2959 
 2960   if (ss_info-&gt;crypto_info) {
 2961     GST_LOG_OBJECT (qtdemux, &quot;unreffing existing crypto_info&quot;);
 2962     g_ptr_array_free (ss_info-&gt;crypto_info, TRUE);
 2963     ss_info-&gt;crypto_info = NULL;
 2964   }
 2965 
 2966   /* skip UUID */
 2967   gst_byte_reader_init (&amp;br, buffer + offset + 16, length - offset - 16);
 2968 
 2969   if (!gst_byte_reader_get_uint8 (&amp;br, &amp;version)) {
 2970     GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s version field&quot;);
 2971     return;
 2972   }
 2973 
 2974   if (!gst_byte_reader_get_uint24_be (&amp;br, &amp;flags)) {
 2975     GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s flags field&quot;);
 2976     return;
 2977   }
 2978 
 2979   if ((flags &amp; 0x000001)) {
<a name="138" id="anc138"></a><span class="line-modified"> 2980     if (!qtdemux_update_default_piff_encryption_settings (qtdemux, ss_info,</span>
<span class="line-modified"> 2981             &amp;br))</span>























 2982       return;
<a name="139" id="anc139"></a>












 2983   } else if ((flags &amp; 0x000002)) {
 2984     uses_sub_sample_encryption = TRUE;
 2985   }
 2986 
<a name="140" id="anc140"></a><span class="line-added"> 2987   if (!gst_structure_get_uint (ss_info-&gt;default_properties, &quot;iv_size&quot;,</span>
<span class="line-added"> 2988           &amp;iv_size)) {</span>
<span class="line-added"> 2989     GST_ERROR_OBJECT (qtdemux, &quot;Error getting encryption IV size field&quot;);</span>
<span class="line-added"> 2990     return;</span>
<span class="line-added"> 2991   }</span>
<span class="line-added"> 2992 </span>
 2993   if (!gst_byte_reader_get_uint32_be (&amp;br, &amp;sample_count)) {
 2994     GST_ERROR_OBJECT (qtdemux, &quot;Error getting box&#39;s sample count field&quot;);
 2995     return;
 2996   }
 2997 
 2998   ss_info-&gt;crypto_info =
 2999       g_ptr_array_new_full (sample_count,
 3000       (GDestroyNotify) qtdemux_gst_structure_free);
 3001 
 3002   for (i = 0; i &lt; sample_count; ++i) {
 3003     GstStructure *properties;
 3004     guint8 *data;
 3005     GstBuffer *buf;
 3006 
 3007     properties = qtdemux_get_cenc_sample_properties (qtdemux, stream, i);
 3008     if (properties == NULL) {
 3009       GST_ERROR_OBJECT (qtdemux, &quot;failed to get properties for sample %u&quot;, i);
 3010       qtdemux-&gt;cenc_aux_sample_count = i;
 3011       return;
 3012     }
 3013 
 3014     if (!gst_byte_reader_dup_data (&amp;br, iv_size, &amp;data)) {
 3015       GST_ERROR_OBJECT (qtdemux, &quot;IV data not present for sample %u&quot;, i);
 3016       gst_structure_free (properties);
 3017       qtdemux-&gt;cenc_aux_sample_count = i;
 3018       return;
 3019     }
 3020     buf = gst_buffer_new_wrapped (data, iv_size);
 3021     gst_structure_set (properties, &quot;iv&quot;, GST_TYPE_BUFFER, buf, NULL);
 3022     gst_buffer_unref (buf);
 3023 
 3024     if (uses_sub_sample_encryption) {
 3025       guint16 n_subsamples;
<a name="141" id="anc141"></a><span class="line-added"> 3026       const GValue *kid_buf_value;</span>
 3027 
 3028       if (!gst_byte_reader_get_uint16_be (&amp;br, &amp;n_subsamples)
 3029           || n_subsamples == 0) {
 3030         GST_ERROR_OBJECT (qtdemux,
 3031             &quot;failed to get subsample count for sample %u&quot;, i);
 3032         gst_structure_free (properties);
 3033         qtdemux-&gt;cenc_aux_sample_count = i;
 3034         return;
 3035       }
 3036       GST_LOG_OBJECT (qtdemux, &quot;subsample count: %u&quot;, n_subsamples);
 3037       if (!gst_byte_reader_dup_data (&amp;br, n_subsamples * 6, &amp;data)) {
 3038         GST_ERROR_OBJECT (qtdemux, &quot;failed to get subsample data for sample %u&quot;,
 3039             i);
 3040         gst_structure_free (properties);
 3041         qtdemux-&gt;cenc_aux_sample_count = i;
 3042         return;
 3043       }
 3044       buf = gst_buffer_new_wrapped (data, n_subsamples * 6);
<a name="142" id="anc142"></a><span class="line-added"> 3045 </span>
<span class="line-added"> 3046       kid_buf_value =</span>
<span class="line-added"> 3047           gst_structure_get_value (ss_info-&gt;default_properties, &quot;kid&quot;);</span>
<span class="line-added"> 3048 </span>
 3049       gst_structure_set (properties,
 3050           &quot;subsample_count&quot;, G_TYPE_UINT, n_subsamples,
 3051           &quot;subsamples&quot;, GST_TYPE_BUFFER, buf, NULL);
<a name="143" id="anc143"></a><span class="line-added"> 3052       gst_structure_set_value (properties, &quot;kid&quot;, kid_buf_value);</span>
 3053       gst_buffer_unref (buf);
 3054     } else {
 3055       gst_structure_set (properties, &quot;subsample_count&quot;, G_TYPE_UINT, 0, NULL);
 3056     }
 3057 
 3058     g_ptr_array_add (ss_info-&gt;crypto_info, properties);
 3059   }
 3060 
 3061   qtdemux-&gt;cenc_aux_sample_count = sample_count;
 3062 }
 3063 
 3064 static void
 3065 qtdemux_parse_uuid (GstQTDemux * qtdemux, const guint8 * buffer, gint length)
 3066 {
 3067   static const guint8 xmp_uuid[] = { 0xBE, 0x7A, 0xCF, 0xCB,
 3068     0x97, 0xA9, 0x42, 0xE8,
 3069     0x9C, 0x71, 0x99, 0x94,
 3070     0x91, 0xE3, 0xAF, 0xAC
 3071   };
 3072   static const guint8 playready_uuid[] = {
 3073     0xd0, 0x8a, 0x4f, 0x18, 0x10, 0xf3, 0x4a, 0x82,
 3074     0xb6, 0xc8, 0x32, 0xd8, 0xab, 0xa1, 0x83, 0xd3
 3075   };
 3076 
 3077   static const guint8 piff_sample_encryption_uuid[] = {
 3078     0xa2, 0x39, 0x4f, 0x52, 0x5a, 0x9b, 0x4f, 0x14,
 3079     0xa2, 0x44, 0x6c, 0x42, 0x7c, 0x64, 0x8d, 0xf4
 3080   };
 3081 
 3082   guint offset;
 3083 
 3084   /* counts as header data */
 3085   qtdemux-&gt;header_size += length;
 3086 
 3087   offset = (QT_UINT32 (buffer) == 0) ? 16 : 8;
 3088 
 3089   if (length &lt;= offset + 16) {
 3090     GST_DEBUG_OBJECT (qtdemux, &quot;uuid atom is too short, skipping&quot;);
 3091     return;
 3092   }
 3093 
 3094 #ifndef GSTREAMER_LITE
 3095   if (memcmp (buffer + offset, xmp_uuid, 16) == 0) {
 3096     GstBuffer *buf;
 3097     GstTagList *taglist;
 3098 
 3099     buf = _gst_buffer_new_wrapped ((guint8 *) buffer + offset + 16,
 3100         length - offset - 16, NULL);
 3101     taglist = gst_tag_list_from_xmp_buffer (buf);
 3102     gst_buffer_unref (buf);
 3103 
 3104     /* make sure we have a usable taglist */
 3105     qtdemux-&gt;tag_list = gst_tag_list_make_writable (qtdemux-&gt;tag_list);
 3106 
 3107     qtdemux_handle_xmp_taglist (qtdemux, qtdemux-&gt;tag_list, taglist);
 3108 
 3109   } else if (memcmp (buffer + offset, playready_uuid, 16) == 0) {
 3110     int len;
 3111     const gunichar2 *s_utf16;
 3112     char *contents;
 3113 
 3114     len = GST_READ_UINT16_LE (buffer + offset + 0x30);
 3115     s_utf16 = (const gunichar2 *) (buffer + offset + 0x32);
 3116     contents = g_utf16_to_utf8 (s_utf16, len / 2, NULL, NULL, NULL);
 3117     GST_ERROR_OBJECT (qtdemux, &quot;contents: %s&quot;, contents);
 3118 
 3119     g_free (contents);
 3120 
 3121     GST_ELEMENT_ERROR (qtdemux, STREAM, DECRYPT,
 3122         (_(&quot;Cannot play stream because it is encrypted with PlayReady DRM.&quot;)),
 3123         (NULL));
 3124   } else if (memcmp (buffer + offset, piff_sample_encryption_uuid, 16) == 0) {
 3125     qtdemux_parse_piff (qtdemux, buffer, length, offset);
 3126   } else {
 3127     GST_DEBUG_OBJECT (qtdemux, &quot;Ignoring unknown uuid: %08x-%08x-%08x-%08x&quot;,
 3128         GST_READ_UINT32_LE (buffer + offset),
 3129         GST_READ_UINT32_LE (buffer + offset + 4),
 3130         GST_READ_UINT32_LE (buffer + offset + 8),
 3131         GST_READ_UINT32_LE (buffer + offset + 12));
 3132   }
 3133 #endif // GSTREAMER_LITE
 3134 }
 3135 
 3136 static void
 3137 qtdemux_parse_sidx (GstQTDemux * qtdemux, const guint8 * buffer, gint length)
 3138 {
 3139   GstSidxParser sidx_parser;
 3140   GstIsoffParserResult res;
 3141   guint consumed;
 3142 
 3143   gst_isoff_qt_sidx_parser_init (&amp;sidx_parser);
 3144 
 3145   res =
 3146       gst_isoff_qt_sidx_parser_add_data (&amp;sidx_parser, buffer, length,
 3147       &amp;consumed);
 3148   GST_DEBUG_OBJECT (qtdemux, &quot;sidx parse result: %d&quot;, res);
 3149   if (res == GST_ISOFF_QT_PARSER_DONE) {
 3150     check_update_duration (qtdemux, sidx_parser.cumulative_pts);
 3151   }
 3152   gst_isoff_qt_sidx_parser_clear (&amp;sidx_parser);
 3153 }
 3154 
 3155 /* caller verifies at least 8 bytes in buf */
 3156 static void
 3157 extract_initial_length_and_fourcc (const guint8 * data, guint size,
 3158     guint64 * plength, guint32 * pfourcc)
 3159 {
 3160   guint64 length;
 3161   guint32 fourcc;
 3162 
 3163   length = QT_UINT32 (data);
 3164   GST_DEBUG (&quot;length 0x%08&quot; G_GINT64_MODIFIER &quot;x&quot;, length);
 3165   fourcc = QT_FOURCC (data + 4);
 3166   GST_DEBUG (&quot;atom type %&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));
 3167 
 3168   if (length == 0) {
 3169     length = G_MAXUINT64;
 3170   } else if (length == 1 &amp;&amp; size &gt;= 16) {
 3171     /* this means we have an extended size, which is the 64 bit value of
 3172      * the next 8 bytes */
 3173     length = QT_UINT64 (data + 8);
 3174     GST_DEBUG (&quot;length 0x%08&quot; G_GINT64_MODIFIER &quot;x&quot;, length);
 3175   }
 3176 
 3177   if (plength)
 3178     *plength = length;
 3179   if (pfourcc)
 3180     *pfourcc = fourcc;
 3181 }
 3182 
 3183 static gboolean
 3184 qtdemux_parse_mehd (GstQTDemux * qtdemux, GstByteReader * br)
 3185 {
 3186   guint32 version = 0;
 3187   GstClockTime duration = 0;
 3188 
 3189   if (!gst_byte_reader_get_uint32_be (br, &amp;version))
 3190     goto failed;
 3191 
 3192   version &gt;&gt;= 24;
 3193   if (version == 1) {
 3194     if (!gst_byte_reader_get_uint64_be (br, &amp;duration))
 3195       goto failed;
 3196   } else {
 3197     guint32 dur = 0;
 3198 
 3199     if (!gst_byte_reader_get_uint32_be (br, &amp;dur))
 3200       goto failed;
 3201     duration = dur;
 3202   }
 3203 
 3204   GST_INFO_OBJECT (qtdemux, &quot;mehd duration: %&quot; G_GUINT64_FORMAT, duration);
 3205   qtdemux-&gt;duration = duration;
 3206 
 3207   return TRUE;
 3208 
 3209 failed:
 3210   {
 3211     GST_DEBUG_OBJECT (qtdemux, &quot;parsing mehd failed&quot;);
 3212     return FALSE;
 3213   }
 3214 }
 3215 
 3216 static gboolean
 3217 qtdemux_parse_trex (GstQTDemux * qtdemux, QtDemuxStream * stream,
 3218     guint32 * ds_duration, guint32 * ds_size, guint32 * ds_flags)
 3219 {
 3220   if (!stream-&gt;parsed_trex &amp;&amp; qtdemux-&gt;moov_node) {
 3221     GNode *mvex, *trex;
 3222     GstByteReader trex_data;
 3223 
 3224     mvex = qtdemux_tree_get_child_by_type (qtdemux-&gt;moov_node, FOURCC_mvex);
 3225     if (mvex) {
 3226       trex = qtdemux_tree_get_child_by_type_full (mvex, FOURCC_trex,
 3227           &amp;trex_data);
 3228       while (trex) {
 3229         guint32 id = 0, sdi = 0, dur = 0, size = 0, flags = 0;
 3230 
 3231         /* skip version/flags */
 3232         if (!gst_byte_reader_skip (&amp;trex_data, 4))
 3233           goto next;
 3234         if (!gst_byte_reader_get_uint32_be (&amp;trex_data, &amp;id))
 3235           goto next;
 3236         if (id != stream-&gt;track_id)
 3237           goto next;
 3238         if (!gst_byte_reader_get_uint32_be (&amp;trex_data, &amp;sdi))
 3239           goto next;
 3240         if (!gst_byte_reader_get_uint32_be (&amp;trex_data, &amp;dur))
 3241           goto next;
 3242         if (!gst_byte_reader_get_uint32_be (&amp;trex_data, &amp;size))
 3243           goto next;
 3244         if (!gst_byte_reader_get_uint32_be (&amp;trex_data, &amp;flags))
 3245           goto next;
 3246 
 3247         GST_DEBUG_OBJECT (qtdemux, &quot;fragment defaults for stream %d; &quot;
 3248             &quot;duration %d,  size %d, flags 0x%x&quot;, stream-&gt;track_id,
 3249             dur, size, flags);
 3250 
 3251         stream-&gt;parsed_trex = TRUE;
 3252         stream-&gt;def_sample_description_index = sdi;
 3253         stream-&gt;def_sample_duration = dur;
 3254         stream-&gt;def_sample_size = size;
 3255         stream-&gt;def_sample_flags = flags;
 3256 
 3257       next:
 3258         /* iterate all siblings */
 3259         trex = qtdemux_tree_get_sibling_by_type_full (trex, FOURCC_trex,
 3260             &amp;trex_data);
 3261       }
 3262     }
 3263   }
 3264 
 3265   *ds_duration = stream-&gt;def_sample_duration;
 3266   *ds_size = stream-&gt;def_sample_size;
 3267   *ds_flags = stream-&gt;def_sample_flags;
 3268 
 3269   /* even then, above values are better than random ... */
 3270   if (G_UNLIKELY (!stream-&gt;parsed_trex)) {
 3271     GST_WARNING_OBJECT (qtdemux,
 3272         &quot;failed to find fragment defaults for stream %d&quot;, stream-&gt;track_id);
 3273     return FALSE;
 3274   }
 3275 
 3276   return TRUE;
 3277 }
 3278 
 3279 /* This method should be called whenever a more accurate duration might
 3280  * have been found. It will update all relevant variables if/where needed
 3281  */
 3282 static void
 3283 check_update_duration (GstQTDemux * qtdemux, GstClockTime duration)
 3284 {
 3285   guint i;
 3286   guint64 movdur;
 3287   GstClockTime prevdur;
 3288 
 3289   movdur = GSTTIME_TO_QTTIME (qtdemux, duration);
 3290 
 3291   if (movdur &gt; qtdemux-&gt;duration) {
 3292     prevdur = QTTIME_TO_GSTTIME (qtdemux, qtdemux-&gt;duration);
 3293     GST_DEBUG_OBJECT (qtdemux,
 3294         &quot;Updating total duration to %&quot; GST_TIME_FORMAT &quot; was %&quot; GST_TIME_FORMAT,
 3295         GST_TIME_ARGS (duration), GST_TIME_ARGS (prevdur));
 3296     qtdemux-&gt;duration = movdur;
 3297     GST_DEBUG_OBJECT (qtdemux,
 3298         &quot;qtdemux-&gt;segment.duration: %&quot; GST_TIME_FORMAT &quot; .stop: %&quot;
 3299         GST_TIME_FORMAT, GST_TIME_ARGS (qtdemux-&gt;segment.duration),
 3300         GST_TIME_ARGS (qtdemux-&gt;segment.stop));
 3301     if (qtdemux-&gt;segment.duration == prevdur) {
 3302       /* If the current segment has duration/stop identical to previous duration
 3303        * update them also (because they were set at that point in time with
 3304        * the wrong duration */
 3305       /* We convert the value *from* the timescale version to avoid rounding errors */
 3306       GstClockTime fixeddur = QTTIME_TO_GSTTIME (qtdemux, movdur);
 3307       GST_DEBUG_OBJECT (qtdemux, &quot;Updated segment.duration and segment.stop&quot;);
 3308       qtdemux-&gt;segment.duration = fixeddur;
 3309       qtdemux-&gt;segment.stop = fixeddur;
 3310     }
 3311   }
<a name="144" id="anc144"></a>



























 3312 
<a name="145" id="anc145"></a><span class="line-modified"> 3313   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified"> 3314     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added"> 3315 </span>
<span class="line-added"> 3316     movdur = GSTTIME_TO_QTSTREAMTIME (stream, duration);</span>
<span class="line-added"> 3317     if (movdur &gt; stream-&gt;duration) {</span>
<span class="line-added"> 3318       GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-added"> 3319           &quot;Updating stream #%d duration to %&quot; GST_TIME_FORMAT, i,</span>
<span class="line-added"> 3320           GST_TIME_ARGS (duration));</span>
<span class="line-added"> 3321       stream-&gt;duration = movdur;</span>
<span class="line-added"> 3322       /* internal duration tracking state has been updated above, so */</span>
<span class="line-added"> 3323       /* preserve an open-ended dummy segment rather than repeatedly updating</span>
<span class="line-added"> 3324        * it and spamming downstream accordingly with segment events */</span>
<span class="line-added"> 3325       if (stream-&gt;dummy_segment &amp;&amp;</span>
<span class="line-added"> 3326           GST_CLOCK_TIME_IS_VALID (stream-&gt;segments[0].duration)) {</span>
<span class="line-added"> 3327         /* Update all dummy values to new duration */</span>
<span class="line-added"> 3328         stream-&gt;segments[0].stop_time = duration;</span>
<span class="line-added"> 3329         stream-&gt;segments[0].duration = duration;</span>
<span class="line-added"> 3330         stream-&gt;segments[0].media_stop = duration;</span>
<span class="line-added"> 3331 </span>
<span class="line-added"> 3332         /* let downstream know we possibly have a new stop time */</span>
<span class="line-added"> 3333         if (stream-&gt;segment_index != -1) {</span>
<span class="line-added"> 3334           GstClockTime pos;</span>
<span class="line-added"> 3335 </span>
<span class="line-added"> 3336           if (qtdemux-&gt;segment.rate &gt;= 0) {</span>
<span class="line-added"> 3337             pos = stream-&gt;segment.start;</span>
<span class="line-added"> 3338           } else {</span>
<span class="line-added"> 3339             pos = stream-&gt;segment.stop;</span>
 3340           }
<a name="146" id="anc146"></a><span class="line-added"> 3341 </span>
<span class="line-added"> 3342           gst_qtdemux_stream_update_segment (qtdemux, stream,</span>
<span class="line-added"> 3343               stream-&gt;segment_index, pos, NULL, NULL);</span>
 3344         }
 3345       }
 3346     }
 3347   }
 3348 }
 3349 
 3350 static gboolean
 3351 qtdemux_parse_trun (GstQTDemux * qtdemux, GstByteReader * trun,
 3352     QtDemuxStream * stream, guint32 d_sample_duration, guint32 d_sample_size,
 3353     guint32 d_sample_flags, gint64 moof_offset, gint64 moof_length,
 3354     gint64 * base_offset, gint64 * running_offset, gint64 decode_ts,
 3355     gboolean has_tfdt)
 3356 {
 3357   GstClockTime gst_ts = GST_CLOCK_TIME_NONE;
 3358   guint64 timestamp;
 3359   gint32 data_offset = 0;
 3360   guint32 flags = 0, first_flags = 0, samples_count = 0;
 3361   gint i;
 3362   guint8 *data;
 3363   guint entry_size, dur_offset, size_offset, flags_offset = 0, ct_offset = 0;
 3364   QtDemuxSample *sample;
 3365   gboolean ismv = FALSE;
 3366   gint64 initial_offset;
 3367 
<a name="147" id="anc147"></a><span class="line-modified"> 3368   GST_LOG_OBJECT (qtdemux, &quot;parsing trun track-id %d; &quot;</span>
 3369       &quot;default dur %d, size %d, flags 0x%x, base offset %&quot; G_GINT64_FORMAT &quot;, &quot;
 3370       &quot;decode ts %&quot; G_GINT64_FORMAT, stream-&gt;track_id, d_sample_duration,
 3371       d_sample_size, d_sample_flags, *base_offset, decode_ts);
 3372 
 3373   if (stream-&gt;pending_seek &amp;&amp; moof_offset &lt; stream-&gt;pending_seek-&gt;moof_offset) {
 3374     GST_INFO_OBJECT (stream-&gt;pad, &quot;skipping trun before seek target fragment&quot;);
 3375     return TRUE;
 3376   }
 3377 
 3378   /* presence of stss or not can&#39;t really tell us much,
 3379    * and flags and so on tend to be marginally reliable in these files */
 3380   if (stream-&gt;subtype == FOURCC_soun) {
 3381     GST_DEBUG_OBJECT (qtdemux,
 3382         &quot;sound track in fragmented file; marking all keyframes&quot;);
 3383     stream-&gt;all_keyframe = TRUE;
 3384   }
 3385 
 3386   if (!gst_byte_reader_skip (trun, 1) ||
 3387       !gst_byte_reader_get_uint24_be (trun, &amp;flags))
 3388     goto fail;
 3389 
 3390   if (!gst_byte_reader_get_uint32_be (trun, &amp;samples_count))
 3391     goto fail;
 3392 
 3393   if (flags &amp; TR_DATA_OFFSET) {
 3394     /* note this is really signed */
 3395     if (!gst_byte_reader_get_int32_be (trun, &amp;data_offset))
 3396       goto fail;
 3397     GST_LOG_OBJECT (qtdemux, &quot;trun data offset %d&quot;, data_offset);
 3398     /* default base offset = first byte of moof */
 3399     if (*base_offset == -1) {
 3400       GST_LOG_OBJECT (qtdemux, &quot;base_offset at moof&quot;);
 3401       *base_offset = moof_offset;
 3402     }
 3403     *running_offset = *base_offset + data_offset;
 3404   } else {
 3405     /* if no offset at all, that would mean data starts at moof start,
 3406      * which is a bit wrong and is ismv crappy way, so compensate
 3407      * assuming data is in mdat following moof */
 3408     if (*base_offset == -1) {
 3409       *base_offset = moof_offset + moof_length + 8;
 3410       GST_LOG_OBJECT (qtdemux, &quot;base_offset assumed in mdat after moof&quot;);
 3411       ismv = TRUE;
 3412     }
 3413     if (*running_offset == -1)
 3414       *running_offset = *base_offset;
 3415   }
 3416 
 3417   GST_LOG_OBJECT (qtdemux, &quot;running offset now %&quot; G_GINT64_FORMAT,
 3418       *running_offset);
 3419   GST_LOG_OBJECT (qtdemux, &quot;trun offset %d, flags 0x%x, entries %d&quot;,
 3420       data_offset, flags, samples_count);
 3421 
 3422   if (flags &amp; TR_FIRST_SAMPLE_FLAGS) {
 3423     if (G_UNLIKELY (flags &amp; TR_SAMPLE_FLAGS)) {
 3424       GST_DEBUG_OBJECT (qtdemux,
 3425           &quot;invalid flags; SAMPLE and FIRST_SAMPLE present, discarding latter&quot;);
 3426       flags ^= TR_FIRST_SAMPLE_FLAGS;
 3427     } else {
 3428       if (!gst_byte_reader_get_uint32_be (trun, &amp;first_flags))
 3429         goto fail;
 3430       GST_LOG_OBJECT (qtdemux, &quot;first flags: 0x%x&quot;, first_flags);
 3431     }
 3432   }
 3433 
 3434   /* FIXME ? spec says other bits should also be checked to determine
 3435    * entry size (and prefix size for that matter) */
 3436   entry_size = 0;
 3437   dur_offset = size_offset = 0;
 3438   if (flags &amp; TR_SAMPLE_DURATION) {
 3439     GST_LOG_OBJECT (qtdemux, &quot;entry duration present&quot;);
 3440     dur_offset = entry_size;
 3441     entry_size += 4;
 3442   }
 3443   if (flags &amp; TR_SAMPLE_SIZE) {
 3444     GST_LOG_OBJECT (qtdemux, &quot;entry size present&quot;);
 3445     size_offset = entry_size;
 3446     entry_size += 4;
 3447   }
 3448   if (flags &amp; TR_SAMPLE_FLAGS) {
 3449     GST_LOG_OBJECT (qtdemux, &quot;entry flags present&quot;);
 3450     flags_offset = entry_size;
 3451     entry_size += 4;
 3452   }
 3453   if (flags &amp; TR_COMPOSITION_TIME_OFFSETS) {
 3454     GST_LOG_OBJECT (qtdemux, &quot;entry ct offset present&quot;);
 3455     ct_offset = entry_size;
 3456     entry_size += 4;
 3457   }
 3458 
 3459   if (!qt_atom_parser_has_chunks (trun, samples_count, entry_size))
 3460     goto fail;
 3461   data = (guint8 *) gst_byte_reader_peek_data_unchecked (trun);
 3462 
 3463   if (stream-&gt;n_samples + samples_count &gt;=
 3464       QTDEMUX_MAX_SAMPLE_INDEX_SIZE / sizeof (QtDemuxSample))
 3465     goto index_too_big;
 3466 
 3467   GST_DEBUG_OBJECT (qtdemux, &quot;allocating n_samples %u * %u (%.2f MB)&quot;,
 3468       stream-&gt;n_samples + samples_count, (guint) sizeof (QtDemuxSample),
 3469       (stream-&gt;n_samples + samples_count) *
 3470       sizeof (QtDemuxSample) / (1024.0 * 1024.0));
 3471 
 3472   /* create a new array of samples if it&#39;s the first sample parsed */
 3473   if (stream-&gt;n_samples == 0) {
 3474     g_assert (stream-&gt;samples == NULL);
 3475     stream-&gt;samples = g_try_new0 (QtDemuxSample, samples_count);
<a name="148" id="anc148"></a><span class="line-modified"> 3476     /* or try to reallocate it with space enough to insert the new samples */</span>
 3477   } else
 3478     stream-&gt;samples = g_try_renew (QtDemuxSample, stream-&gt;samples,
 3479         stream-&gt;n_samples + samples_count);
 3480   if (stream-&gt;samples == NULL)
 3481     goto out_of_memory;
 3482 
 3483   if (qtdemux-&gt;fragment_start != -1) {
 3484     timestamp = GSTTIME_TO_QTSTREAMTIME (stream, qtdemux-&gt;fragment_start);
 3485     qtdemux-&gt;fragment_start = -1;
 3486   } else {
 3487     if (stream-&gt;n_samples == 0) {
 3488       if (decode_ts &gt; 0) {
 3489         timestamp = decode_ts;
 3490       } else if (stream-&gt;pending_seek != NULL) {
 3491         /* if we don&#39;t have a timestamp from a tfdt box, we&#39;ll use the one
 3492          * from the mfra seek table */
 3493         GST_INFO_OBJECT (stream-&gt;pad, &quot;pending seek ts = %&quot; GST_TIME_FORMAT,
 3494             GST_TIME_ARGS (stream-&gt;pending_seek-&gt;ts));
 3495 
 3496         /* FIXME: this is not fully correct, the timestamp refers to the random
 3497          * access sample refered to in the tfra entry, which may not necessarily
 3498          * be the first sample in the tfrag/trun (but hopefully/usually is) */
 3499         timestamp = GSTTIME_TO_QTSTREAMTIME (stream, stream-&gt;pending_seek-&gt;ts);
 3500       } else {
<a name="149" id="anc149"></a><span class="line-modified"> 3501         timestamp = 0;</span>
 3502       }
 3503 
 3504       gst_ts = QTSTREAMTIME_TO_GSTTIME (stream, timestamp);
 3505       GST_INFO_OBJECT (stream-&gt;pad, &quot;first sample ts %&quot; GST_TIME_FORMAT,
 3506           GST_TIME_ARGS (gst_ts));
<a name="150" id="anc150"></a><span class="line-modified"> 3507     } else {</span>
<span class="line-modified"> 3508       /* subsequent fragments extend stream */</span>
<span class="line-modified"> 3509       timestamp =</span>
<span class="line-modified"> 3510           stream-&gt;samples[stream-&gt;n_samples - 1].timestamp +</span>
<span class="line-modified"> 3511           stream-&gt;samples[stream-&gt;n_samples - 1].duration;</span>
 3512 
 3513       /* If this is a GST_FORMAT_BYTES stream and there&#39;s a significant
 3514        * difference (1 sec.) between decode_ts and timestamp, prefer the
 3515        * former */
 3516       if (has_tfdt &amp;&amp; !qtdemux-&gt;upstream_format_is_time
 3517           &amp;&amp; ABSDIFF (decode_ts, timestamp) &gt;
 3518           MAX (stream-&gt;duration_last_moof / 2,
 3519               GSTTIME_TO_QTSTREAMTIME (stream, GST_SECOND))) {
 3520         GST_INFO_OBJECT (qtdemux,
 3521             &quot;decode_ts (%&quot; GST_TIME_FORMAT &quot;) and timestamp (%&quot; GST_TIME_FORMAT
 3522             &quot;) are significantly different (more than %&quot; GST_TIME_FORMAT
 3523             &quot;), using decode_ts&quot;,
 3524             GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream, decode_ts)),
 3525             GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream, timestamp)),
 3526             GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream,
 3527                     MAX (stream-&gt;duration_last_moof / 2,
 3528                         GSTTIME_TO_QTSTREAMTIME (stream, GST_SECOND)))));
 3529         timestamp = decode_ts;
<a name="151" id="anc151"></a><span class="line-modified"> 3530       }</span>
 3531 
 3532       gst_ts = QTSTREAMTIME_TO_GSTTIME (stream, timestamp);
 3533       GST_INFO_OBJECT (qtdemux, &quot;first sample ts %&quot; GST_TIME_FORMAT
 3534           &quot; (extends previous samples)&quot;, GST_TIME_ARGS (gst_ts));
<a name="152" id="anc152"></a><span class="line-modified"> 3535     }</span>
 3536   }
 3537 
 3538   initial_offset = *running_offset;
 3539 
 3540   sample = stream-&gt;samples + stream-&gt;n_samples;
 3541   for (i = 0; i &lt; samples_count; i++) {
 3542     guint32 dur, size, sflags, ct;
 3543 
 3544     /* first read sample data */
 3545     if (flags &amp; TR_SAMPLE_DURATION) {
 3546       dur = QT_UINT32 (data + dur_offset);
 3547     } else {
 3548       dur = d_sample_duration;
 3549     }
 3550     if (flags &amp; TR_SAMPLE_SIZE) {
 3551       size = QT_UINT32 (data + size_offset);
 3552     } else {
 3553       size = d_sample_size;
 3554     }
 3555     if (flags &amp; TR_FIRST_SAMPLE_FLAGS) {
 3556       if (i == 0) {
 3557         sflags = first_flags;
 3558       } else {
 3559         sflags = d_sample_flags;
 3560       }
 3561     } else if (flags &amp; TR_SAMPLE_FLAGS) {
 3562       sflags = QT_UINT32 (data + flags_offset);
 3563     } else {
 3564       sflags = d_sample_flags;
 3565     }
 3566     if (flags &amp; TR_COMPOSITION_TIME_OFFSETS) {
 3567       ct = QT_UINT32 (data + ct_offset);
 3568     } else {
 3569       ct = 0;
 3570     }
 3571     data += entry_size;
 3572 
 3573     /* fill the sample information */
 3574     sample-&gt;offset = *running_offset;
 3575     sample-&gt;pts_offset = ct;
 3576     sample-&gt;size = size;
 3577     sample-&gt;timestamp = timestamp;
 3578     sample-&gt;duration = dur;
 3579     /* sample-is-difference-sample */
 3580     /* ismv seems to use 0x40 for keyframe, 0xc0 for non-keyframe,
 3581      * now idea how it relates to bitfield other than massive LE/BE confusion */
 3582     sample-&gt;keyframe = ismv ? ((sflags &amp; 0xff) == 0x40) : !(sflags &amp; 0x10000);
 3583     *running_offset += size;
 3584     timestamp += dur;
 3585     stream-&gt;duration_moof += dur;
 3586     sample++;
 3587   }
 3588 
 3589   /* Update total duration if needed */
 3590   check_update_duration (qtdemux, QTSTREAMTIME_TO_GSTTIME (stream, timestamp));
 3591 
 3592   /* Pre-emptively figure out size of mdat based on trun information.
 3593    * If the [mdat] atom is effectivelly read, it will be replaced by the actual
 3594    * size, else we will still be able to use this when dealing with gap&#39;ed
 3595    * input */
 3596   qtdemux-&gt;mdatleft = *running_offset - initial_offset;
 3597   qtdemux-&gt;mdatoffset = initial_offset;
 3598   qtdemux-&gt;mdatsize = qtdemux-&gt;mdatleft;
 3599 
 3600   stream-&gt;n_samples += samples_count;
 3601   stream-&gt;n_samples_moof += samples_count;
 3602 
 3603   if (stream-&gt;pending_seek != NULL)
 3604     stream-&gt;pending_seek = NULL;
 3605 
 3606   return TRUE;
 3607 
 3608 fail:
 3609   {
 3610     GST_WARNING_OBJECT (qtdemux, &quot;failed to parse trun&quot;);
 3611     return FALSE;
 3612   }
 3613 out_of_memory:
 3614   {
 3615     GST_WARNING_OBJECT (qtdemux, &quot;failed to allocate %d samples&quot;,
 3616         stream-&gt;n_samples);
 3617     return FALSE;
 3618   }
 3619 index_too_big:
 3620   {
 3621     GST_WARNING_OBJECT (qtdemux, &quot;not allocating index of %d samples, would &quot;
 3622         &quot;be larger than %uMB (broken file?)&quot;, stream-&gt;n_samples,
 3623         QTDEMUX_MAX_SAMPLE_INDEX_SIZE &gt;&gt; 20);
 3624     return FALSE;
 3625   }
 3626 }
 3627 
 3628 /* find stream with @id */
 3629 static inline QtDemuxStream *
 3630 qtdemux_find_stream (GstQTDemux * qtdemux, guint32 id)
 3631 {
 3632   QtDemuxStream *stream;
 3633   gint i;
 3634 
 3635   /* check */
 3636   if (G_UNLIKELY (!id)) {
 3637     GST_DEBUG_OBJECT (qtdemux, &quot;invalid track id 0&quot;);
 3638     return NULL;
 3639   }
 3640 
<a name="153" id="anc153"></a><span class="line-modified"> 3641   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified"> 3642     stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>








 3643     if (stream-&gt;track_id == id)
 3644       return stream;
 3645   }
 3646   if (qtdemux-&gt;mss_mode) {
 3647     /* mss should have only 1 stream anyway */
<a name="154" id="anc154"></a><span class="line-modified"> 3648     return QTDEMUX_NTH_STREAM (qtdemux, 0);</span>
 3649   }
 3650 
 3651   return NULL;
 3652 }
 3653 
 3654 static gboolean
 3655 qtdemux_parse_mfhd (GstQTDemux * qtdemux, GstByteReader * mfhd,
 3656     guint32 * fragment_number)
 3657 {
 3658   if (!gst_byte_reader_skip (mfhd, 4))
 3659     goto fail;
 3660   if (!gst_byte_reader_get_uint32_be (mfhd, fragment_number))
 3661     goto fail;
 3662   return TRUE;
 3663 fail:
 3664   {
 3665     GST_WARNING_OBJECT (qtdemux, &quot;Failed to parse mfhd atom&quot;);
 3666     return FALSE;
 3667   }
 3668 }
 3669 
 3670 static gboolean
 3671 qtdemux_parse_tfhd (GstQTDemux * qtdemux, GstByteReader * tfhd,
 3672     QtDemuxStream ** stream, guint32 * default_sample_duration,
 3673     guint32 * default_sample_size, guint32 * default_sample_flags,
 3674     gint64 * base_offset)
 3675 {
 3676   guint32 flags = 0;
 3677   guint32 track_id = 0;
 3678 
 3679   if (!gst_byte_reader_skip (tfhd, 1) ||
 3680       !gst_byte_reader_get_uint24_be (tfhd, &amp;flags))
 3681     goto invalid_track;
 3682 
 3683   if (!gst_byte_reader_get_uint32_be (tfhd, &amp;track_id))
 3684     goto invalid_track;
 3685 
 3686   *stream = qtdemux_find_stream (qtdemux, track_id);
 3687   if (G_UNLIKELY (!*stream))
 3688     goto unknown_stream;
 3689 
 3690   if (flags &amp; TF_DEFAULT_BASE_IS_MOOF)
 3691     *base_offset = qtdemux-&gt;moof_offset;
 3692 
 3693   if (flags &amp; TF_BASE_DATA_OFFSET)
 3694     if (!gst_byte_reader_get_uint64_be (tfhd, (guint64 *) base_offset))
 3695       goto invalid_track;
 3696 
 3697   /* obtain stream defaults */
 3698   qtdemux_parse_trex (qtdemux, *stream,
 3699       default_sample_duration, default_sample_size, default_sample_flags);
 3700 
 3701   (*stream)-&gt;stsd_sample_description_id =
 3702       (*stream)-&gt;def_sample_description_index - 1;
 3703 
 3704   if (flags &amp; TF_SAMPLE_DESCRIPTION_INDEX) {
 3705     guint32 sample_description_index;
 3706     if (!gst_byte_reader_get_uint32_be (tfhd, &amp;sample_description_index))
 3707       goto invalid_track;
 3708     (*stream)-&gt;stsd_sample_description_id = sample_description_index - 1;
 3709   }
 3710 
 3711   if (qtdemux-&gt;mss_mode) {
 3712     /* mss has no stsd entry */
 3713     (*stream)-&gt;stsd_sample_description_id = 0;
 3714   }
 3715 
 3716   if (flags &amp; TF_DEFAULT_SAMPLE_DURATION)
 3717     if (!gst_byte_reader_get_uint32_be (tfhd, default_sample_duration))
 3718       goto invalid_track;
 3719 
 3720   if (flags &amp; TF_DEFAULT_SAMPLE_SIZE)
 3721     if (!gst_byte_reader_get_uint32_be (tfhd, default_sample_size))
 3722       goto invalid_track;
 3723 
 3724   if (flags &amp; TF_DEFAULT_SAMPLE_FLAGS)
 3725     if (!gst_byte_reader_get_uint32_be (tfhd, default_sample_flags))
 3726       goto invalid_track;
 3727 
 3728   return TRUE;
 3729 
 3730 invalid_track:
 3731   {
 3732     GST_WARNING_OBJECT (qtdemux, &quot;invalid track fragment header&quot;);
 3733     return FALSE;
 3734   }
 3735 unknown_stream:
 3736   {
 3737     GST_DEBUG_OBJECT (qtdemux, &quot;unknown stream in tfhd&quot;);
 3738     return TRUE;
 3739   }
 3740 }
 3741 
 3742 static gboolean
 3743 qtdemux_parse_tfdt (GstQTDemux * qtdemux, GstByteReader * br,
 3744     guint64 * decode_time)
 3745 {
 3746   guint32 version = 0;
 3747 
 3748   if (!gst_byte_reader_get_uint32_be (br, &amp;version))
 3749     return FALSE;
 3750 
 3751   version &gt;&gt;= 24;
 3752   if (version == 1) {
 3753     if (!gst_byte_reader_get_uint64_be (br, decode_time))
 3754       goto failed;
 3755   } else {
 3756     guint32 dec_time = 0;
 3757     if (!gst_byte_reader_get_uint32_be (br, &amp;dec_time))
 3758       goto failed;
 3759     *decode_time = dec_time;
 3760   }
 3761 
 3762   GST_INFO_OBJECT (qtdemux, &quot;Track fragment decode time: %&quot; G_GUINT64_FORMAT,
 3763       *decode_time);
 3764 
 3765   return TRUE;
 3766 
 3767 failed:
 3768   {
 3769     GST_DEBUG_OBJECT (qtdemux, &quot;parsing tfdt failed&quot;);
 3770     return FALSE;
 3771   }
 3772 }
 3773 
 3774 /* Returns a pointer to a GstStructure containing the properties of
 3775  * the stream sample identified by @sample_index. The caller must unref
 3776  * the returned object after use. Returns NULL if unsuccessful. */
 3777 static GstStructure *
 3778 qtdemux_get_cenc_sample_properties (GstQTDemux * qtdemux,
 3779     QtDemuxStream * stream, guint sample_index)
 3780 {
 3781   QtDemuxCencSampleSetInfo *info = NULL;
 3782 
 3783   g_return_val_if_fail (stream != NULL, NULL);
 3784   g_return_val_if_fail (stream-&gt;protected, NULL);
 3785   g_return_val_if_fail (stream-&gt;protection_scheme_info != NULL, NULL);
 3786 
 3787   info = (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;
 3788 
 3789   /* Currently, cenc properties for groups of samples are not supported, so
 3790    * simply return a copy of the default sample properties */
 3791   return gst_structure_copy (info-&gt;default_properties);
 3792 }
 3793 
 3794 /* Parses the sizes of sample auxiliary information contained within a stream,
 3795  * as given in a saiz box. Returns array of sample_count guint8 size values,
 3796  * or NULL on failure */
 3797 static guint8 *
 3798 qtdemux_parse_saiz (GstQTDemux * qtdemux, QtDemuxStream * stream,
 3799     GstByteReader * br, guint32 * sample_count)
 3800 {
 3801   guint32 flags = 0;
 3802   guint8 *info_sizes;
 3803   guint8 default_info_size;
 3804 
 3805   g_return_val_if_fail (qtdemux != NULL, NULL);
 3806   g_return_val_if_fail (stream != NULL, NULL);
 3807   g_return_val_if_fail (br != NULL, NULL);
 3808   g_return_val_if_fail (sample_count != NULL, NULL);
 3809 
 3810   if (!gst_byte_reader_get_uint32_be (br, &amp;flags))
 3811     return NULL;
 3812 
 3813   if (flags &amp; 0x1) {
 3814     /* aux_info_type and aux_info_type_parameter are ignored */
 3815     if (!gst_byte_reader_skip (br, 8))
 3816       return NULL;
 3817   }
 3818 
 3819   if (!gst_byte_reader_get_uint8 (br, &amp;default_info_size))
 3820     return NULL;
 3821   GST_DEBUG_OBJECT (qtdemux, &quot;default_info_size: %u&quot;, default_info_size);
 3822 
 3823   if (!gst_byte_reader_get_uint32_be (br, sample_count))
 3824     return NULL;
 3825   GST_DEBUG_OBJECT (qtdemux, &quot;sample_count: %u&quot;, *sample_count);
 3826 
 3827 
 3828   if (default_info_size == 0) {
 3829     if (!gst_byte_reader_dup_data (br, *sample_count, &amp;info_sizes)) {
 3830       return NULL;
 3831     }
 3832   } else {
 3833     info_sizes = g_new (guint8, *sample_count);
 3834     memset (info_sizes, default_info_size, *sample_count);
 3835   }
 3836 
 3837   return info_sizes;
 3838 }
 3839 
 3840 /* Parses the offset of sample auxiliary information contained within a stream,
 3841  * as given in a saio box. Returns TRUE if successful; FALSE otherwise. */
 3842 static gboolean
 3843 qtdemux_parse_saio (GstQTDemux * qtdemux, QtDemuxStream * stream,
 3844     GstByteReader * br, guint32 * info_type, guint32 * info_type_parameter,
 3845     guint64 * offset)
 3846 {
 3847   guint8 version = 0;
 3848   guint32 flags = 0;
 3849   guint32 aux_info_type = 0;
 3850   guint32 aux_info_type_parameter = 0;
 3851   guint32 entry_count;
 3852   guint32 off_32;
 3853   guint64 off_64;
 3854   const guint8 *aux_info_type_data = NULL;
 3855 
 3856   g_return_val_if_fail (qtdemux != NULL, FALSE);
 3857   g_return_val_if_fail (stream != NULL, FALSE);
 3858   g_return_val_if_fail (br != NULL, FALSE);
 3859   g_return_val_if_fail (offset != NULL, FALSE);
 3860 
 3861   if (!gst_byte_reader_get_uint8 (br, &amp;version))
 3862     return FALSE;
 3863 
 3864   if (!gst_byte_reader_get_uint24_be (br, &amp;flags))
 3865     return FALSE;
 3866 
 3867   if (flags &amp; 0x1) {
 3868 
 3869     if (!gst_byte_reader_get_data (br, 4, &amp;aux_info_type_data))
 3870       return FALSE;
 3871     aux_info_type = QT_FOURCC (aux_info_type_data);
 3872 
 3873     if (!gst_byte_reader_get_uint32_be (br, &amp;aux_info_type_parameter))
 3874       return FALSE;
 3875   } else if (stream-&gt;protected) {
 3876     aux_info_type = stream-&gt;protection_scheme_type;
 3877   } else {
 3878     aux_info_type = CUR_STREAM (stream)-&gt;fourcc;
 3879   }
 3880 
 3881   if (info_type)
 3882     *info_type = aux_info_type;
 3883   if (info_type_parameter)
 3884     *info_type_parameter = aux_info_type_parameter;
 3885 
 3886   GST_DEBUG_OBJECT (qtdemux, &quot;aux_info_type: &#39;%&quot; GST_FOURCC_FORMAT &quot;&#39;, &quot;
 3887       &quot;aux_info_type_parameter:  %#06x&quot;,
 3888       GST_FOURCC_ARGS (aux_info_type), aux_info_type_parameter);
 3889 
 3890   if (!gst_byte_reader_get_uint32_be (br, &amp;entry_count))
 3891     return FALSE;
 3892 
 3893   if (entry_count != 1) {
 3894     GST_ERROR_OBJECT (qtdemux, &quot;multiple offsets are not supported&quot;);
 3895     return FALSE;
 3896   }
 3897 
 3898   if (version == 0) {
 3899     if (!gst_byte_reader_get_uint32_be (br, &amp;off_32))
 3900       return FALSE;
 3901     *offset = (guint64) off_32;
 3902   } else {
 3903     if (!gst_byte_reader_get_uint64_be (br, &amp;off_64))
 3904       return FALSE;
 3905     *offset = off_64;
 3906   }
 3907 
 3908   GST_DEBUG_OBJECT (qtdemux, &quot;offset: %&quot; G_GUINT64_FORMAT, *offset);
 3909   return TRUE;
 3910 }
 3911 
 3912 static void
 3913 qtdemux_gst_structure_free (GstStructure * gststructure)
 3914 {
 3915   if (gststructure) {
 3916     gst_structure_free (gststructure);
 3917   }
 3918 }
 3919 
 3920 /* Parses auxiliary information relating to samples protected using Common
 3921  * Encryption (cenc); the format of this information is defined in
 3922  * ISO/IEC 23001-7. Returns TRUE if successful; FALSE otherwise. */
 3923 static gboolean
 3924 qtdemux_parse_cenc_aux_info (GstQTDemux * qtdemux, QtDemuxStream * stream,
 3925     GstByteReader * br, guint8 * info_sizes, guint32 sample_count)
 3926 {
 3927   QtDemuxCencSampleSetInfo *ss_info = NULL;
 3928   guint8 size;
 3929   gint i;
 3930   GPtrArray *old_crypto_info = NULL;
 3931   guint old_entries = 0;
 3932 
 3933   g_return_val_if_fail (qtdemux != NULL, FALSE);
 3934   g_return_val_if_fail (stream != NULL, FALSE);
 3935   g_return_val_if_fail (br != NULL, FALSE);
 3936   g_return_val_if_fail (stream-&gt;protected, FALSE);
 3937   g_return_val_if_fail (stream-&gt;protection_scheme_info != NULL, FALSE);
 3938 
 3939   ss_info = (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;
 3940 
 3941   if (ss_info-&gt;crypto_info) {
 3942     old_crypto_info = ss_info-&gt;crypto_info;
 3943     /* Count number of non-null entries remaining at the tail end */
 3944     for (i = old_crypto_info-&gt;len - 1; i &gt;= 0; i--) {
 3945       if (g_ptr_array_index (old_crypto_info, i) == NULL)
 3946         break;
 3947       old_entries++;
 3948     }
 3949   }
 3950 
 3951   ss_info-&gt;crypto_info =
 3952       g_ptr_array_new_full (sample_count + old_entries,
 3953       (GDestroyNotify) qtdemux_gst_structure_free);
 3954 
 3955   /* We preserve old entries because we parse the next moof in advance
 3956    * of consuming all samples from the previous moof, and otherwise
 3957    * we&#39;d discard the corresponding crypto info for the samples
 3958    * from the previous fragment. */
 3959   if (old_entries) {
 3960     GST_DEBUG_OBJECT (qtdemux, &quot;Preserving %d old crypto info entries&quot;,
 3961         old_entries);
 3962     for (i = old_crypto_info-&gt;len - old_entries; i &lt; old_crypto_info-&gt;len; i++) {
 3963       g_ptr_array_add (ss_info-&gt;crypto_info, g_ptr_array_index (old_crypto_info,
 3964               i));
 3965       g_ptr_array_index (old_crypto_info, i) = NULL;
 3966     }
 3967   }
 3968 
 3969   if (old_crypto_info) {
 3970     /* Everything now belongs to the new array */
 3971     g_ptr_array_free (old_crypto_info, TRUE);
 3972   }
 3973 
 3974   for (i = 0; i &lt; sample_count; ++i) {
 3975     GstStructure *properties;
 3976     guint16 n_subsamples = 0;
 3977     guint8 *data;
 3978     guint iv_size;
 3979     GstBuffer *buf;
 3980 
 3981     properties = qtdemux_get_cenc_sample_properties (qtdemux, stream, i);
 3982     if (properties == NULL) {
 3983       GST_ERROR_OBJECT (qtdemux, &quot;failed to get properties for sample %u&quot;, i);
 3984       return FALSE;
 3985     }
 3986     if (!gst_structure_get_uint (properties, &quot;iv_size&quot;, &amp;iv_size)) {
 3987       GST_ERROR_OBJECT (qtdemux, &quot;failed to get iv_size for sample %u&quot;, i);
 3988       gst_structure_free (properties);
 3989       return FALSE;
 3990     }
 3991     if (!gst_byte_reader_dup_data (br, iv_size, &amp;data)) {
 3992       GST_ERROR_OBJECT (qtdemux, &quot;failed to get IV for sample %u&quot;, i);
 3993       gst_structure_free (properties);
 3994       return FALSE;
 3995     }
 3996     buf = gst_buffer_new_wrapped (data, iv_size);
 3997     gst_structure_set (properties, &quot;iv&quot;, GST_TYPE_BUFFER, buf, NULL);
 3998     gst_buffer_unref (buf);
 3999     size = info_sizes[i];
 4000     if (size &gt; iv_size) {
 4001       if (!gst_byte_reader_get_uint16_be (br, &amp;n_subsamples)
 4002           || !(n_subsamples &gt; 0)) {
 4003         gst_structure_free (properties);
 4004         GST_ERROR_OBJECT (qtdemux,
 4005             &quot;failed to get subsample count for sample %u&quot;, i);
 4006         return FALSE;
 4007       }
 4008       GST_LOG_OBJECT (qtdemux, &quot;subsample count: %u&quot;, n_subsamples);
 4009       if (!gst_byte_reader_dup_data (br, n_subsamples * 6, &amp;data)) {
 4010         GST_ERROR_OBJECT (qtdemux, &quot;failed to get subsample data for sample %u&quot;,
 4011             i);
 4012         gst_structure_free (properties);
 4013         return FALSE;
 4014       }
 4015       buf = gst_buffer_new_wrapped (data, n_subsamples * 6);
 4016       if (!buf) {
 4017         gst_structure_free (properties);
 4018         return FALSE;
 4019       }
 4020       gst_structure_set (properties,
 4021           &quot;subsample_count&quot;, G_TYPE_UINT, n_subsamples,
 4022           &quot;subsamples&quot;, GST_TYPE_BUFFER, buf, NULL);
 4023       gst_buffer_unref (buf);
 4024     } else {
 4025       gst_structure_set (properties, &quot;subsample_count&quot;, G_TYPE_UINT, 0, NULL);
 4026     }
 4027     g_ptr_array_add (ss_info-&gt;crypto_info, properties);
 4028   }
 4029   return TRUE;
 4030 }
 4031 
 4032 /* Converts a UUID in raw byte form to a string representation, as defined in
 4033  * RFC 4122. The caller takes ownership of the returned string and is
 4034  * responsible for freeing it after use. */
 4035 static gchar *
 4036 qtdemux_uuid_bytes_to_string (gconstpointer uuid_bytes)
 4037 {
 4038   const guint8 *uuid = (const guint8 *) uuid_bytes;
 4039 
 4040   return g_strdup_printf (&quot;%02x%02x%02x%02x-%02x%02x-%02x%02x-&quot;
 4041       &quot;%02x%02x-%02x%02x%02x%02x%02x%02x&quot;,
 4042       uuid[0], uuid[1], uuid[2], uuid[3],
 4043       uuid[4], uuid[5], uuid[6], uuid[7],
 4044       uuid[8], uuid[9], uuid[10], uuid[11],
 4045       uuid[12], uuid[13], uuid[14], uuid[15]);
 4046 }
 4047 
 4048 /* Parses a Protection System Specific Header box (pssh), as defined in the
 4049  * Common Encryption (cenc) standard (ISO/IEC 23001-7), which contains
 4050  * information needed by a specific content protection system in order to
 4051  * decrypt cenc-protected tracks. Returns TRUE if successful; FALSE
 4052  * otherwise. */
 4053 static gboolean
 4054 qtdemux_parse_pssh (GstQTDemux * qtdemux, GNode * node)
 4055 {
 4056   gchar *sysid_string;
 4057   guint32 pssh_size = QT_UINT32 (node-&gt;data);
 4058   GstBuffer *pssh = NULL;
 4059   GstEvent *event = NULL;
 4060   guint32 parent_box_type;
 4061   gint i;
 4062 
 4063   if (G_UNLIKELY (pssh_size &lt; 32U)) {
 4064     GST_ERROR_OBJECT (qtdemux, &quot;invalid box size&quot;);
 4065     return FALSE;
 4066   }
 4067 
 4068   sysid_string =
 4069       qtdemux_uuid_bytes_to_string ((const guint8 *) node-&gt;data + 12);
 4070 
 4071   gst_qtdemux_append_protection_system_id (qtdemux, sysid_string);
 4072 
 4073   pssh = gst_buffer_new_wrapped (g_memdup (node-&gt;data, pssh_size), pssh_size);
 4074   GST_LOG_OBJECT (qtdemux, &quot;cenc pssh size: %&quot; G_GSIZE_FORMAT,
 4075       gst_buffer_get_size (pssh));
 4076 
 4077   parent_box_type = QT_FOURCC ((const guint8 *) node-&gt;parent-&gt;data + 4);
 4078 
 4079   /* Push an event containing the pssh box onto the queues of all streams. */
 4080   event = gst_event_new_protection (sysid_string, pssh,
 4081       (parent_box_type == FOURCC_moov) ? &quot;isobmff/moov&quot; : &quot;isobmff/moof&quot;);
<a name="155" id="anc155"></a><span class="line-modified"> 4082   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified"> 4083     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added"> 4084     GST_TRACE_OBJECT (qtdemux,</span>
<span class="line-added"> 4085         &quot;adding protection event for stream %s and system %s&quot;,</span>
<span class="line-added"> 4086         stream-&gt;stream_id, sysid_string);</span>
<span class="line-added"> 4087     g_queue_push_tail (&amp;stream-&gt;protection_scheme_event_queue,</span>
 4088         gst_event_ref (event));
 4089   }
 4090   g_free (sysid_string);
 4091   gst_event_unref (event);
 4092   gst_buffer_unref (pssh);
 4093   return TRUE;
 4094 }
 4095 
 4096 static gboolean
 4097 qtdemux_parse_moof (GstQTDemux * qtdemux, const guint8 * buffer, guint length,
 4098     guint64 moof_offset, QtDemuxStream * stream)
 4099 {
 4100   GNode *moof_node, *traf_node, *tfhd_node, *trun_node, *tfdt_node, *mfhd_node;
 4101   GNode *uuid_node;
 4102   GstByteReader mfhd_data, trun_data, tfhd_data, tfdt_data;
 4103   GNode *saiz_node, *saio_node, *pssh_node;
 4104   GstByteReader saiz_data, saio_data;
 4105   guint32 ds_size = 0, ds_duration = 0, ds_flags = 0;
 4106   gint64 base_offset, running_offset;
 4107   guint32 frag_num;
<a name="156" id="anc156"></a><span class="line-added"> 4108   GstClockTime min_dts = GST_CLOCK_TIME_NONE;</span>
 4109 
 4110   /* NOTE @stream ignored */
 4111 
 4112   moof_node = g_node_new ((guint8 *) buffer);
 4113   qtdemux_parse_node (qtdemux, moof_node, buffer, length);
 4114   qtdemux_node_dump (qtdemux, moof_node);
 4115 
 4116   /* Get fragment number from mfhd and check it&#39;s valid */
 4117   mfhd_node =
 4118       qtdemux_tree_get_child_by_type_full (moof_node, FOURCC_mfhd, &amp;mfhd_data);
 4119   if (mfhd_node == NULL)
 4120     goto missing_mfhd;
 4121   if (!qtdemux_parse_mfhd (qtdemux, &amp;mfhd_data, &amp;frag_num))
 4122     goto fail;
 4123   GST_DEBUG_OBJECT (qtdemux, &quot;Fragment #%d&quot;, frag_num);
 4124 
 4125   /* unknown base_offset to start with */
 4126   base_offset = running_offset = -1;
 4127   traf_node = qtdemux_tree_get_child_by_type (moof_node, FOURCC_traf);
 4128   while (traf_node) {
 4129     guint64 decode_time = 0;
 4130 
 4131     /* Fragment Header node */
 4132     tfhd_node =
 4133         qtdemux_tree_get_child_by_type_full (traf_node, FOURCC_tfhd,
 4134         &amp;tfhd_data);
 4135     if (!tfhd_node)
 4136       goto missing_tfhd;
 4137     if (!qtdemux_parse_tfhd (qtdemux, &amp;tfhd_data, &amp;stream, &amp;ds_duration,
 4138             &amp;ds_size, &amp;ds_flags, &amp;base_offset))
 4139       goto missing_tfhd;
 4140 
 4141     /* The following code assumes at most a single set of sample auxiliary
 4142      * data in the fragment (consisting of a saiz box and a corresponding saio
 4143      * box); in theory, however, there could be multiple sets of sample
 4144      * auxiliary data in a fragment. */
 4145     saiz_node =
 4146         qtdemux_tree_get_child_by_type_full (traf_node, FOURCC_saiz,
 4147         &amp;saiz_data);
 4148     if (saiz_node) {
 4149       guint32 info_type = 0;
 4150       guint64 offset = 0;
 4151       guint32 info_type_parameter = 0;
 4152 
 4153       g_free (qtdemux-&gt;cenc_aux_info_sizes);
 4154 
 4155       qtdemux-&gt;cenc_aux_info_sizes =
 4156           qtdemux_parse_saiz (qtdemux, stream, &amp;saiz_data,
 4157           &amp;qtdemux-&gt;cenc_aux_sample_count);
 4158       if (qtdemux-&gt;cenc_aux_info_sizes == NULL) {
 4159         GST_ERROR_OBJECT (qtdemux, &quot;failed to parse saiz box&quot;);
 4160         goto fail;
 4161       }
 4162       saio_node =
 4163           qtdemux_tree_get_child_by_type_full (traf_node, FOURCC_saio,
 4164           &amp;saio_data);
 4165       if (!saio_node) {
 4166         GST_ERROR_OBJECT (qtdemux, &quot;saiz box without a corresponding saio box&quot;);
 4167         g_free (qtdemux-&gt;cenc_aux_info_sizes);
 4168         qtdemux-&gt;cenc_aux_info_sizes = NULL;
 4169         goto fail;
 4170       }
 4171 
 4172       if (G_UNLIKELY (!qtdemux_parse_saio (qtdemux, stream, &amp;saio_data,
 4173                   &amp;info_type, &amp;info_type_parameter, &amp;offset))) {
 4174         GST_ERROR_OBJECT (qtdemux, &quot;failed to parse saio box&quot;);
 4175         g_free (qtdemux-&gt;cenc_aux_info_sizes);
 4176         qtdemux-&gt;cenc_aux_info_sizes = NULL;
 4177         goto fail;
 4178       }
 4179       if (base_offset &gt; -1 &amp;&amp; base_offset &gt; qtdemux-&gt;moof_offset)
 4180         offset += (guint64) (base_offset - qtdemux-&gt;moof_offset);
 4181       if (info_type == FOURCC_cenc &amp;&amp; info_type_parameter == 0U) {
 4182         GstByteReader br;
 4183         if (offset &gt; length) {
 4184           GST_DEBUG_OBJECT (qtdemux, &quot;cenc auxiliary info stored out of moof&quot;);
 4185           qtdemux-&gt;cenc_aux_info_offset = offset;
 4186         } else {
 4187           gst_byte_reader_init (&amp;br, buffer + offset, length - offset);
 4188           if (!qtdemux_parse_cenc_aux_info (qtdemux, stream, &amp;br,
 4189                   qtdemux-&gt;cenc_aux_info_sizes,
 4190                   qtdemux-&gt;cenc_aux_sample_count)) {
 4191             GST_ERROR_OBJECT (qtdemux, &quot;failed to parse cenc auxiliary info&quot;);
 4192             g_free (qtdemux-&gt;cenc_aux_info_sizes);
 4193             qtdemux-&gt;cenc_aux_info_sizes = NULL;
 4194             goto fail;
 4195           }
 4196         }
 4197       }
 4198     }
 4199 
 4200     tfdt_node =
 4201         qtdemux_tree_get_child_by_type_full (traf_node, FOURCC_tfdt,
 4202         &amp;tfdt_data);
 4203     if (tfdt_node) {
 4204       /* We&#39;ll use decode_time to interpolate timestamps
 4205        * in case the input timestamps are missing */
 4206       qtdemux_parse_tfdt (qtdemux, &amp;tfdt_data, &amp;decode_time);
 4207 
 4208       GST_DEBUG_OBJECT (qtdemux, &quot;decode time %&quot; G_GINT64_FORMAT
 4209           &quot; (%&quot; GST_TIME_FORMAT &quot;)&quot;, decode_time,
 4210           GST_TIME_ARGS (stream ? QTSTREAMTIME_TO_GSTTIME (stream,
 4211                   decode_time) : GST_CLOCK_TIME_NONE));
 4212 
 4213       /* Discard the fragment buffer timestamp info to avoid using it.
 4214        * Rely on tfdt instead as it is more accurate than the timestamp
 4215        * that is fetched from a manifest/playlist and is usually
 4216        * less accurate. */
 4217       qtdemux-&gt;fragment_start = -1;
 4218     }
 4219 
 4220     if (G_UNLIKELY (!stream)) {
 4221       /* we lost track of offset, we&#39;ll need to regain it,
 4222        * but can delay complaining until later or avoid doing so altogether */
 4223       base_offset = -2;
 4224       goto next;
 4225     }
 4226     if (G_UNLIKELY (base_offset &lt; -1))
 4227       goto lost_offset;
 4228 
<a name="157" id="anc157"></a><span class="line-modified"> 4229     min_dts = MIN (min_dts, QTSTREAMTIME_TO_GSTTIME (stream, decode_time));</span>
<span class="line-modified"> 4230 </span>
<span class="line-added"> 4231     if (!qtdemux-&gt;pullbased) {</span>
<span class="line-added"> 4232       /* Sample tables can grow enough to be problematic if the system memory</span>
<span class="line-added"> 4233        * is very low (e.g. embedded devices) and the videos very long</span>
<span class="line-added"> 4234        * (~8 MiB/hour for 25-30 fps video + typical AAC audio frames).</span>
<span class="line-added"> 4235        * Fortunately, we can easily discard them for each new fragment when</span>
<span class="line-added"> 4236        * we know qtdemux will not receive seeks outside of the current fragment.</span>
<span class="line-added"> 4237        * adaptivedemux honors this assumption.</span>
<span class="line-added"> 4238        * This optimization is also useful for applications that use qtdemux as</span>
<span class="line-added"> 4239        * a push-based simple demuxer, like Media Source Extensions. */</span>
<span class="line-added"> 4240       gst_qtdemux_stream_flush_samples_data (stream);</span>
<span class="line-added"> 4241     }</span>
 4242 
 4243     /* initialise moof sample data */
 4244     stream-&gt;n_samples_moof = 0;
 4245     stream-&gt;duration_last_moof = stream-&gt;duration_moof;
 4246     stream-&gt;duration_moof = 0;
 4247 
 4248     /* Track Run node */
 4249     trun_node =
 4250         qtdemux_tree_get_child_by_type_full (traf_node, FOURCC_trun,
 4251         &amp;trun_data);
 4252     while (trun_node) {
 4253       qtdemux_parse_trun (qtdemux, &amp;trun_data, stream,
 4254           ds_duration, ds_size, ds_flags, moof_offset, length, &amp;base_offset,
 4255           &amp;running_offset, decode_time, (tfdt_node != NULL));
 4256       /* iterate all siblings */
 4257       trun_node = qtdemux_tree_get_sibling_by_type_full (trun_node, FOURCC_trun,
 4258           &amp;trun_data);
 4259     }
 4260 
 4261     uuid_node = qtdemux_tree_get_child_by_type (traf_node, FOURCC_uuid);
 4262     if (uuid_node) {
 4263       guint8 *uuid_buffer = (guint8 *) uuid_node-&gt;data;
 4264       guint32 box_length = QT_UINT32 (uuid_buffer);
 4265 
 4266       qtdemux_parse_uuid (qtdemux, uuid_buffer, box_length);
 4267     }
 4268 
 4269     /* if no new base_offset provided for next traf,
 4270      * base is end of current traf */
 4271     base_offset = running_offset;
 4272     running_offset = -1;
 4273 
 4274     if (stream-&gt;n_samples_moof &amp;&amp; stream-&gt;duration_moof)
 4275       stream-&gt;new_caps = TRUE;
 4276 
 4277   next:
 4278     /* iterate all siblings */
 4279     traf_node = qtdemux_tree_get_sibling_by_type (traf_node, FOURCC_traf);
 4280   }
 4281 
 4282   /* parse any protection system info */
 4283   pssh_node = qtdemux_tree_get_child_by_type (moof_node, FOURCC_pssh);
 4284   while (pssh_node) {
 4285     GST_LOG_OBJECT (qtdemux, &quot;Parsing pssh box.&quot;);
 4286     qtdemux_parse_pssh (qtdemux, pssh_node);
 4287     pssh_node = qtdemux_tree_get_sibling_by_type (pssh_node, FOURCC_pssh);
 4288   }
 4289 
<a name="158" id="anc158"></a><span class="line-added"> 4290   if (!qtdemux-&gt;upstream_format_is_time &amp;&amp; !qtdemux-&gt;first_moof_already_parsed</span>
<span class="line-added"> 4291       &amp;&amp; !qtdemux-&gt;received_seek &amp;&amp; GST_CLOCK_TIME_IS_VALID (min_dts)</span>
<span class="line-added"> 4292       &amp;&amp; min_dts != 0) {</span>
<span class="line-added"> 4293     /* Unless the user has explictly requested another seek, perform an</span>
<span class="line-added"> 4294      * internal seek to the time specified in the tfdt.</span>
<span class="line-added"> 4295      *</span>
<span class="line-added"> 4296      * This way if the user opens a file where the first tfdt is 1 hour</span>
<span class="line-added"> 4297      * into the presentation, they will not have to wait 1 hour for run</span>
<span class="line-added"> 4298      * time to catch up and actual playback to start. */</span>
<span class="line-added"> 4299     gint i;</span>
<span class="line-added"> 4300 </span>
<span class="line-added"> 4301     GST_DEBUG_OBJECT (qtdemux, &quot;First fragment has a non-zero tfdt, &quot;</span>
<span class="line-added"> 4302         &quot;performing an internal seek to %&quot; GST_TIME_FORMAT,</span>
<span class="line-added"> 4303         GST_TIME_ARGS (min_dts));</span>
<span class="line-added"> 4304 </span>
<span class="line-added"> 4305     qtdemux-&gt;segment.start = min_dts;</span>
<span class="line-added"> 4306     qtdemux-&gt;segment.time = qtdemux-&gt;segment.position = min_dts;</span>
<span class="line-added"> 4307 </span>
<span class="line-added"> 4308     for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-added"> 4309       QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added"> 4310       stream-&gt;time_position = min_dts;</span>
<span class="line-added"> 4311     }</span>
<span class="line-added"> 4312 </span>
<span class="line-added"> 4313     /* Before this code was run a segment was already sent when the moov was</span>
<span class="line-added"> 4314      * parsed... which is OK -- some apps (mostly tests) expect a segment to</span>
<span class="line-added"> 4315      * be emitted after a moov, and we can emit a second segment anyway for</span>
<span class="line-added"> 4316      * special cases like this. */</span>
<span class="line-added"> 4317     qtdemux-&gt;need_segment = TRUE;</span>
<span class="line-added"> 4318   }</span>
<span class="line-added"> 4319 </span>
<span class="line-added"> 4320   qtdemux-&gt;first_moof_already_parsed = TRUE;</span>
<span class="line-added"> 4321 </span>
 4322   g_node_destroy (moof_node);
 4323   return TRUE;
 4324 
 4325 missing_tfhd:
 4326   {
 4327     GST_DEBUG_OBJECT (qtdemux, &quot;missing tfhd box&quot;);
 4328     goto fail;
 4329   }
 4330 missing_mfhd:
 4331   {
 4332     GST_DEBUG_OBJECT (qtdemux, &quot;Missing mfhd box&quot;);
 4333     goto fail;
 4334   }
 4335 lost_offset:
 4336   {
 4337     GST_DEBUG_OBJECT (qtdemux, &quot;lost offset&quot;);
 4338     goto fail;
 4339   }
 4340 fail:
 4341   {
 4342     g_node_destroy (moof_node);
 4343     GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
 4344         (_(&quot;This file is corrupt and cannot be played.&quot;)), (NULL));
 4345     return FALSE;
 4346   }
 4347 }
 4348 
 4349 #if 0
 4350 /* might be used if some day we actually use mfra &amp; co
 4351  * for random access to fragments,
 4352  * but that will require quite some modifications and much less relying
 4353  * on a sample array */
 4354 #endif
 4355 
 4356 static gboolean
 4357 qtdemux_parse_tfra (GstQTDemux * qtdemux, GNode * tfra_node)
 4358 {
 4359   QtDemuxStream *stream;
 4360   guint32 ver_flags, track_id, len, num_entries, i;
 4361   guint value_size, traf_size, trun_size, sample_size;
 4362   guint64 time = 0, moof_offset = 0;
 4363 #if 0
 4364   GstBuffer *buf = NULL;
 4365   GstFlowReturn ret;
 4366 #endif
 4367   GstByteReader tfra;
 4368 
 4369   gst_byte_reader_init (&amp;tfra, tfra_node-&gt;data, QT_UINT32 (tfra_node-&gt;data));
 4370 
 4371   if (!gst_byte_reader_skip (&amp;tfra, 8))
 4372     return FALSE;
 4373 
 4374   if (!gst_byte_reader_get_uint32_be (&amp;tfra, &amp;ver_flags))
 4375     return FALSE;
 4376 
 4377   if (!gst_byte_reader_get_uint32_be (&amp;tfra, &amp;track_id)
 4378       || !gst_byte_reader_get_uint32_be (&amp;tfra, &amp;len)
 4379       || !gst_byte_reader_get_uint32_be (&amp;tfra, &amp;num_entries))
 4380     return FALSE;
 4381 
 4382   GST_DEBUG_OBJECT (qtdemux, &quot;parsing tfra box for track id %u&quot;, track_id);
 4383 
 4384   stream = qtdemux_find_stream (qtdemux, track_id);
 4385   if (stream == NULL)
 4386     goto unknown_trackid;
 4387 
 4388   value_size = ((ver_flags &gt;&gt; 24) == 1) ? sizeof (guint64) : sizeof (guint32);
 4389   sample_size = (len &amp; 3) + 1;
 4390   trun_size = ((len &amp; 12) &gt;&gt; 2) + 1;
 4391   traf_size = ((len &amp; 48) &gt;&gt; 4) + 1;
 4392 
 4393   GST_DEBUG_OBJECT (qtdemux, &quot;%u entries, sizes: value %u, traf %u, trun %u, &quot;
 4394       &quot;sample %u&quot;, num_entries, value_size, traf_size, trun_size, sample_size);
 4395 
 4396   if (num_entries == 0)
 4397     goto no_samples;
 4398 
 4399   if (!qt_atom_parser_has_chunks (&amp;tfra, num_entries,
 4400           value_size + value_size + traf_size + trun_size + sample_size))
 4401     goto corrupt_file;
 4402 
 4403   g_free (stream-&gt;ra_entries);
 4404   stream-&gt;ra_entries = g_new (QtDemuxRandomAccessEntry, num_entries);
 4405   stream-&gt;n_ra_entries = num_entries;
 4406 
 4407   for (i = 0; i &lt; num_entries; i++) {
 4408     qt_atom_parser_get_offset (&amp;tfra, value_size, &amp;time);
 4409     qt_atom_parser_get_offset (&amp;tfra, value_size, &amp;moof_offset);
 4410     qt_atom_parser_get_uint_with_size_unchecked (&amp;tfra, traf_size);
 4411     qt_atom_parser_get_uint_with_size_unchecked (&amp;tfra, trun_size);
 4412     qt_atom_parser_get_uint_with_size_unchecked (&amp;tfra, sample_size);
 4413 
 4414     time = QTSTREAMTIME_TO_GSTTIME (stream, time);
 4415 
 4416     GST_LOG_OBJECT (qtdemux, &quot;fragment time: %&quot; GST_TIME_FORMAT &quot;, &quot;
 4417         &quot; moof_offset: %&quot; G_GUINT64_FORMAT, GST_TIME_ARGS (time), moof_offset);
 4418 
 4419     stream-&gt;ra_entries[i].ts = time;
 4420     stream-&gt;ra_entries[i].moof_offset = moof_offset;
 4421 
 4422     /* don&#39;t want to go through the entire file and read all moofs at startup */
 4423 #if 0
 4424     ret = gst_qtdemux_pull_atom (qtdemux, moof_offset, 0, &amp;buf);
 4425     if (ret != GST_FLOW_OK)
 4426       goto corrupt_file;
 4427     qtdemux_parse_moof (qtdemux, GST_BUFFER_DATA (buf), GST_BUFFER_SIZE (buf),
 4428         moof_offset, stream);
 4429     gst_buffer_unref (buf);
 4430 #endif
 4431   }
 4432 
 4433   check_update_duration (qtdemux, time);
 4434 
 4435   return TRUE;
 4436 
 4437 /* ERRORS */
 4438 unknown_trackid:
 4439   {
 4440     GST_WARNING_OBJECT (qtdemux, &quot;Couldn&#39;t find stream for track %u&quot;, track_id);
 4441     return FALSE;
 4442   }
 4443 corrupt_file:
 4444   {
 4445     GST_WARNING_OBJECT (qtdemux, &quot;broken traf box, ignoring&quot;);
 4446     return FALSE;
 4447   }
 4448 no_samples:
 4449   {
 4450     GST_WARNING_OBJECT (qtdemux, &quot;stream has no samples&quot;);
 4451     return FALSE;
 4452   }
 4453 }
 4454 
 4455 static gboolean
 4456 qtdemux_pull_mfro_mfra (GstQTDemux * qtdemux)
 4457 {
 4458   GstMapInfo mfro_map = GST_MAP_INFO_INIT;
 4459   GstMapInfo mfra_map = GST_MAP_INFO_INIT;
 4460   GstBuffer *mfro = NULL, *mfra = NULL;
 4461   GstFlowReturn flow;
 4462   gboolean ret = FALSE;
 4463   GNode *mfra_node, *tfra_node;
 4464   guint64 mfra_offset = 0;
 4465   guint32 fourcc, mfra_size;
 4466   gint64 len;
 4467 
 4468   /* query upstream size in bytes */
 4469   if (!gst_pad_peer_query_duration (qtdemux-&gt;sinkpad, GST_FORMAT_BYTES, &amp;len))
 4470     goto size_query_failed;
 4471 
 4472   /* mfro box should be at the very end of the file */
 4473   flow = gst_qtdemux_pull_atom (qtdemux, len - 16, 16, &amp;mfro);
 4474   if (flow != GST_FLOW_OK)
 4475     goto exit;
 4476 
 4477   gst_buffer_map (mfro, &amp;mfro_map, GST_MAP_READ);
 4478 
 4479   fourcc = QT_FOURCC (mfro_map.data + 4);
 4480   if (fourcc != FOURCC_mfro)
 4481     goto exit;
 4482 
 4483   GST_INFO_OBJECT (qtdemux, &quot;Found mfro box&quot;);
 4484   if (mfro_map.size &lt; 16)
 4485     goto invalid_mfro_size;
 4486 
 4487   mfra_size = QT_UINT32 (mfro_map.data + 12);
 4488   if (mfra_size &gt;= len)
 4489     goto invalid_mfra_size;
 4490 
 4491   mfra_offset = len - mfra_size;
 4492 
 4493   GST_INFO_OBJECT (qtdemux, &quot;mfra offset: %&quot; G_GUINT64_FORMAT &quot;, size %u&quot;,
 4494       mfra_offset, mfra_size);
 4495 
 4496   /* now get and parse mfra box */
 4497   flow = gst_qtdemux_pull_atom (qtdemux, mfra_offset, mfra_size, &amp;mfra);
 4498   if (flow != GST_FLOW_OK)
 4499     goto broken_file;
 4500 
 4501   gst_buffer_map (mfra, &amp;mfra_map, GST_MAP_READ);
 4502 
 4503   mfra_node = g_node_new ((guint8 *) mfra_map.data);
 4504   qtdemux_parse_node (qtdemux, mfra_node, mfra_map.data, mfra_map.size);
 4505 
 4506   tfra_node = qtdemux_tree_get_child_by_type (mfra_node, FOURCC_tfra);
 4507 
 4508   while (tfra_node) {
 4509     qtdemux_parse_tfra (qtdemux, tfra_node);
 4510     /* iterate all siblings */
 4511     tfra_node = qtdemux_tree_get_sibling_by_type (tfra_node, FOURCC_tfra);
 4512   }
 4513   g_node_destroy (mfra_node);
 4514 
 4515   GST_INFO_OBJECT (qtdemux, &quot;parsed movie fragment random access box (mfra)&quot;);
 4516   ret = TRUE;
 4517 
 4518 exit:
 4519 
 4520   if (mfro) {
 4521     if (mfro_map.memory != NULL)
 4522       gst_buffer_unmap (mfro, &amp;mfro_map);
 4523     gst_buffer_unref (mfro);
 4524   }
 4525   if (mfra) {
 4526     if (mfra_map.memory != NULL)
 4527       gst_buffer_unmap (mfra, &amp;mfra_map);
 4528     gst_buffer_unref (mfra);
<a name="159" id="anc159"></a><span class="line-modified"> 4529   }</span>
 4530   return ret;
 4531 
 4532 /* ERRORS */
 4533 size_query_failed:
<a name="160" id="anc160"></a><span class="line-modified"> 4534   {</span>
 4535     GST_WARNING_OBJECT (qtdemux, &quot;could not query upstream size&quot;);
 4536     goto exit;
 4537   }
 4538 invalid_mfro_size:
 4539   {
 4540     GST_WARNING_OBJECT (qtdemux, &quot;mfro size is too small&quot;);
 4541     goto exit;
 4542   }
 4543 invalid_mfra_size:
 4544   {
 4545     GST_WARNING_OBJECT (qtdemux, &quot;mfra_size in mfro box is invalid&quot;);
 4546     goto exit;
 4547   }
 4548 broken_file:
 4549   {
 4550     GST_WARNING_OBJECT (qtdemux, &quot;bogus mfra offset or size, broken file&quot;);
<a name="161" id="anc161"></a><span class="line-modified"> 4551     goto exit;</span>

 4552   }
<a name="162" id="anc162"></a><span class="line-added"> 4553 }</span>
 4554 
 4555 static guint64
 4556 add_offset (guint64 offset, guint64 advance)
 4557 {
 4558   /* Avoid 64-bit overflow by clamping */
 4559   if (offset &gt; G_MAXUINT64 - advance)
 4560     return G_MAXUINT64;
 4561   return offset + advance;
<a name="163" id="anc163"></a><span class="line-modified"> 4562 }</span>
 4563 
 4564 static GstFlowReturn
 4565 gst_qtdemux_loop_state_header (GstQTDemux * qtdemux)
 4566 {
 4567   guint64 length = 0;
 4568   guint32 fourcc = 0;
 4569   GstBuffer *buf = NULL;
 4570   GstFlowReturn ret = GST_FLOW_OK;
 4571   guint64 cur_offset = qtdemux-&gt;offset;
 4572   GstMapInfo map;
 4573 
 4574   ret = gst_pad_pull_range (qtdemux-&gt;sinkpad, cur_offset, 16, &amp;buf);
 4575   if (G_UNLIKELY (ret != GST_FLOW_OK))
 4576     goto beach;
 4577   gst_buffer_map (buf, &amp;map, GST_MAP_READ);
 4578   if (G_LIKELY (map.size &gt;= 8))
 4579     extract_initial_length_and_fourcc (map.data, map.size, &amp;length, &amp;fourcc);
 4580   gst_buffer_unmap (buf, &amp;map);
 4581   gst_buffer_unref (buf);
 4582 
 4583   /* maybe we already got most we needed, so only consider this eof */
 4584   if (G_UNLIKELY (length == 0)) {
 4585     GST_ELEMENT_WARNING (qtdemux, STREAM, DEMUX,
 4586         (_(&quot;Invalid atom size.&quot;)),
 4587         (&quot;Header atom &#39;%&quot; GST_FOURCC_FORMAT &quot;&#39; has empty length&quot;,
 4588             GST_FOURCC_ARGS (fourcc)));
 4589     ret = GST_FLOW_EOS;
 4590     goto beach;
 4591   }
 4592 
 4593   switch (fourcc) {
 4594     case FOURCC_moof:
 4595       /* record for later parsing when needed */
 4596       if (!qtdemux-&gt;moof_offset) {
 4597         qtdemux-&gt;moof_offset = qtdemux-&gt;offset;
 4598       }
 4599       if (qtdemux_pull_mfro_mfra (qtdemux)) {
 4600         /* FIXME */
 4601       } else {
 4602         qtdemux-&gt;offset += length;      /* skip moof and keep going */
 4603       }
 4604       if (qtdemux-&gt;got_moov) {
 4605         GST_INFO_OBJECT (qtdemux, &quot;moof header, got moov, done with headers&quot;);
 4606         ret = GST_FLOW_EOS;
 4607         goto beach;
 4608       }
 4609       break;
 4610     case FOURCC_mdat:
 4611     case FOURCC_free:
 4612     case FOURCC_skip:
 4613     case FOURCC_wide:
 4614     case FOURCC_PICT:
 4615     case FOURCC_pnot:
 4616     {
 4617       GST_LOG_OBJECT (qtdemux,
 4618           &quot;skipping atom &#39;%&quot; GST_FOURCC_FORMAT &quot;&#39; at %&quot; G_GUINT64_FORMAT,
 4619           GST_FOURCC_ARGS (fourcc), cur_offset);
 4620       qtdemux-&gt;offset = add_offset (qtdemux-&gt;offset, length);
 4621       break;
 4622     }
 4623     case FOURCC_moov:
 4624     {
 4625       GstBuffer *moov = NULL;
 4626 
 4627       if (qtdemux-&gt;got_moov) {
 4628         GST_DEBUG_OBJECT (qtdemux, &quot;Skipping moov atom as we have one already&quot;);
 4629         qtdemux-&gt;offset = add_offset (qtdemux-&gt;offset, length);
 4630         goto beach;
 4631       }
 4632 
 4633       ret = gst_pad_pull_range (qtdemux-&gt;sinkpad, cur_offset, length, &amp;moov);
 4634       if (ret != GST_FLOW_OK)
 4635         goto beach;
 4636       gst_buffer_map (moov, &amp;map, GST_MAP_READ);
 4637 
 4638       if (length != map.size) {
 4639         /* Some files have a &#39;moov&#39; atom at the end of the file which contains
 4640          * a terminal &#39;free&#39; atom where the body of the atom is missing.
 4641          * Check for, and permit, this special case.
 4642          */
 4643         if (map.size &gt;= 8) {
 4644           guint8 *final_data = map.data + (map.size - 8);
 4645           guint32 final_length = QT_UINT32 (final_data);
 4646           guint32 final_fourcc = QT_FOURCC (final_data + 4);
 4647 
 4648           if (final_fourcc == FOURCC_free
 4649               &amp;&amp; map.size + final_length - 8 == length) {
 4650             /* Ok, we&#39;ve found that special case. Allocate a new buffer with
 4651              * that free atom actually present. */
 4652             GstBuffer *newmoov = gst_buffer_new_and_alloc (length);
 4653             gst_buffer_fill (newmoov, 0, map.data, map.size);
 4654             gst_buffer_memset (newmoov, map.size, 0, final_length - 8);
 4655             gst_buffer_unmap (moov, &amp;map);
 4656             gst_buffer_unref (moov);
 4657             moov = newmoov;
 4658             gst_buffer_map (moov, &amp;map, GST_MAP_READ);
 4659           }
 4660         }
 4661       }
 4662 
 4663       if (length != map.size) {
 4664         GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
 4665             (_(&quot;This file is incomplete and cannot be played.&quot;)),
 4666             (&quot;We got less than expected (received %&quot; G_GSIZE_FORMAT
 4667                 &quot;, wanted %u, offset %&quot; G_GUINT64_FORMAT &quot;)&quot;, map.size,
 4668                 (guint) length, cur_offset));
 4669         gst_buffer_unmap (moov, &amp;map);
 4670         gst_buffer_unref (moov);
 4671         ret = GST_FLOW_ERROR;
 4672         goto beach;
 4673       }
 4674       qtdemux-&gt;offset += length;
 4675 
 4676       qtdemux_parse_moov (qtdemux, map.data, length);
 4677       qtdemux_node_dump (qtdemux, qtdemux-&gt;moov_node);
 4678 
 4679 #ifdef GSTREAMER_LITE
 4680       if (!qtdemux_parse_tree (qtdemux)) {
 4681         ret = GST_FLOW_ERROR;
 4682         break;
 4683       }
 4684 #else
 4685       qtdemux_parse_tree (qtdemux);
 4686 #endif //GSTREAMER_LITE
 4687 
 4688       if (qtdemux-&gt;moov_node_compressed) {
 4689         g_node_destroy (qtdemux-&gt;moov_node_compressed);
 4690         g_free (qtdemux-&gt;moov_node-&gt;data);
 4691       }
 4692       qtdemux-&gt;moov_node_compressed = NULL;
 4693       g_node_destroy (qtdemux-&gt;moov_node);
 4694       qtdemux-&gt;moov_node = NULL;
 4695       gst_buffer_unmap (moov, &amp;map);
 4696       gst_buffer_unref (moov);
 4697       qtdemux-&gt;got_moov = TRUE;
 4698 
 4699       break;
 4700     }
 4701     case FOURCC_ftyp:
 4702     {
 4703       GstBuffer *ftyp = NULL;
 4704 
 4705       /* extract major brand; might come in handy for ISO vs QT issues */
 4706       ret = gst_qtdemux_pull_atom (qtdemux, cur_offset, length, &amp;ftyp);
 4707       if (ret != GST_FLOW_OK)
 4708         goto beach;
 4709       qtdemux-&gt;offset += length;
 4710       gst_buffer_map (ftyp, &amp;map, GST_MAP_READ);
 4711       qtdemux_parse_ftyp (qtdemux, map.data, map.size);
 4712       gst_buffer_unmap (ftyp, &amp;map);
 4713       gst_buffer_unref (ftyp);
 4714       break;
 4715     }
 4716     case FOURCC_uuid:
 4717     {
 4718       GstBuffer *uuid = NULL;
 4719 
 4720       /* uuid are extension atoms */
 4721       ret = gst_qtdemux_pull_atom (qtdemux, cur_offset, length, &amp;uuid);
 4722       if (ret != GST_FLOW_OK)
 4723         goto beach;
 4724       qtdemux-&gt;offset += length;
 4725       gst_buffer_map (uuid, &amp;map, GST_MAP_READ);
 4726       qtdemux_parse_uuid (qtdemux, map.data, map.size);
 4727       gst_buffer_unmap (uuid, &amp;map);
 4728       gst_buffer_unref (uuid);
 4729       break;
 4730     }
 4731     case FOURCC_sidx:
 4732     {
 4733       GstBuffer *sidx = NULL;
 4734       ret = gst_qtdemux_pull_atom (qtdemux, cur_offset, length, &amp;sidx);
 4735       if (ret != GST_FLOW_OK)
 4736         goto beach;
 4737       qtdemux-&gt;offset += length;
 4738       gst_buffer_map (sidx, &amp;map, GST_MAP_READ);
 4739       qtdemux_parse_sidx (qtdemux, map.data, map.size);
 4740       gst_buffer_unmap (sidx, &amp;map);
 4741       gst_buffer_unref (sidx);
 4742       break;
 4743     }
 4744     default:
 4745     {
 4746       GstBuffer *unknown = NULL;
 4747 
 4748       GST_LOG_OBJECT (qtdemux,
 4749           &quot;unknown %08x &#39;%&quot; GST_FOURCC_FORMAT &quot;&#39; of size %&quot; G_GUINT64_FORMAT
 4750           &quot; at %&quot; G_GUINT64_FORMAT, fourcc, GST_FOURCC_ARGS (fourcc), length,
 4751           cur_offset);
 4752       ret = gst_qtdemux_pull_atom (qtdemux, cur_offset, length, &amp;unknown);
 4753       if (ret != GST_FLOW_OK)
 4754         goto beach;
 4755       gst_buffer_map (unknown, &amp;map, GST_MAP_READ);
 4756       GST_MEMDUMP (&quot;Unknown tag&quot;, map.data, map.size);
 4757       gst_buffer_unmap (unknown, &amp;map);
 4758       gst_buffer_unref (unknown);
 4759       qtdemux-&gt;offset += length;
 4760       break;
 4761     }
 4762   }
 4763 
 4764 beach:
 4765   if (ret == GST_FLOW_EOS &amp;&amp; (qtdemux-&gt;got_moov || qtdemux-&gt;media_caps)) {
 4766     /* digested all data, show what we have */
 4767     qtdemux_prepare_streams (qtdemux);
<a name="164" id="anc164"></a><span class="line-added"> 4768     QTDEMUX_EXPOSE_LOCK (qtdemux);</span>
 4769     ret = qtdemux_expose_streams (qtdemux);
<a name="165" id="anc165"></a><span class="line-added"> 4770     QTDEMUX_EXPOSE_UNLOCK (qtdemux);</span>
 4771 
 4772     qtdemux-&gt;state = QTDEMUX_STATE_MOVIE;
 4773     GST_DEBUG_OBJECT (qtdemux, &quot;switching state to STATE_MOVIE (%d)&quot;,
 4774         qtdemux-&gt;state);
 4775     return ret;
 4776   }
 4777   return ret;
 4778 }
 4779 
 4780 /* Seeks to the previous keyframe of the indexed stream and
 4781  * aligns other streams with respect to the keyframe timestamp
 4782  * of indexed stream. Only called in case of Reverse Playback
 4783  */
 4784 static GstFlowReturn
 4785 gst_qtdemux_seek_to_previous_keyframe (GstQTDemux * qtdemux)
 4786 {
<a name="166" id="anc166"></a>
 4787   guint32 seg_idx = 0, k_index = 0;
 4788   guint32 ref_seg_idx, ref_k_index;
 4789   GstClockTime k_pos = 0, last_stop = 0;
 4790   QtDemuxSegment *seg = NULL;
 4791   QtDemuxStream *ref_str = NULL;
 4792   guint64 seg_media_start_mov;  /* segment media start time in mov format */
 4793   guint64 target_ts;
<a name="167" id="anc167"></a><span class="line-added"> 4794   gint i;</span>
 4795 
 4796   /* Now we choose an arbitrary stream, get the previous keyframe timestamp
 4797    * and finally align all the other streams on that timestamp with their
 4798    * respective keyframes */
<a name="168" id="anc168"></a><span class="line-modified"> 4799   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified"> 4800     QtDemuxStream *str = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 4801 
 4802     /* No candidate yet, take the first stream */
 4803     if (!ref_str) {
 4804       ref_str = str;
 4805       continue;
 4806     }
 4807 
 4808     /* So that stream has a segment, we prefer video streams */
 4809     if (str-&gt;subtype == FOURCC_vide) {
 4810       ref_str = str;
 4811       break;
 4812     }
 4813   }
 4814 
 4815   if (G_UNLIKELY (!ref_str)) {
 4816     GST_DEBUG_OBJECT (qtdemux, &quot;couldn&#39;t find any stream&quot;);
 4817     goto eos;
 4818   }
 4819 
 4820   if (G_UNLIKELY (!ref_str-&gt;from_sample)) {
 4821     GST_DEBUG_OBJECT (qtdemux, &quot;reached the beginning of the file&quot;);
 4822     goto eos;
 4823   }
 4824 
 4825   /* So that stream has been playing from from_sample to to_sample. We will
 4826    * get the timestamp of the previous sample and search for a keyframe before
 4827    * that. For audio streams we do an arbitrary jump in the past (10 samples) */
 4828   if (ref_str-&gt;subtype == FOURCC_vide) {
 4829     k_index = gst_qtdemux_find_keyframe (qtdemux, ref_str,
 4830         ref_str-&gt;from_sample - 1, FALSE);
 4831   } else {
 4832     if (ref_str-&gt;from_sample &gt;= 10)
 4833       k_index = ref_str-&gt;from_sample - 10;
 4834     else
 4835       k_index = 0;
 4836   }
 4837 
 4838   target_ts =
 4839       ref_str-&gt;samples[k_index].timestamp +
 4840       ref_str-&gt;samples[k_index].pts_offset;
 4841 
 4842   /* get current segment for that stream */
 4843   seg = &amp;ref_str-&gt;segments[ref_str-&gt;segment_index];
 4844   /* Use segment start in original timescale for comparisons */
 4845   seg_media_start_mov = seg-&gt;trak_media_start;
 4846 
 4847   GST_LOG_OBJECT (qtdemux, &quot;keyframe index %u ts %&quot; G_GUINT64_FORMAT
<a name="169" id="anc169"></a><span class="line-modified"> 4848       &quot; seg start %&quot; G_GUINT64_FORMAT &quot; %&quot; GST_TIME_FORMAT,</span>
 4849       k_index, target_ts, seg_media_start_mov,
 4850       GST_TIME_ARGS (seg-&gt;media_start));
 4851 
 4852   /* Crawl back through segments to find the one containing this I frame */
 4853   while (target_ts &lt; seg_media_start_mov) {
 4854     GST_DEBUG_OBJECT (qtdemux,
 4855         &quot;keyframe position (sample %u) is out of segment %u &quot; &quot; target %&quot;
 4856         G_GUINT64_FORMAT &quot; seg start %&quot; G_GUINT64_FORMAT, k_index,
 4857         ref_str-&gt;segment_index, target_ts, seg_media_start_mov);
 4858 
 4859     if (G_UNLIKELY (!ref_str-&gt;segment_index)) {
 4860       /* Reached first segment, let&#39;s consider it&#39;s EOS */
 4861       goto eos;
 4862     }
 4863     ref_str-&gt;segment_index--;
 4864     seg = &amp;ref_str-&gt;segments[ref_str-&gt;segment_index];
 4865     /* Use segment start in original timescale for comparisons */
 4866     seg_media_start_mov = seg-&gt;trak_media_start;
 4867   }
 4868   /* Calculate time position of the keyframe and where we should stop */
 4869   k_pos =
 4870       QTSTREAMTIME_TO_GSTTIME (ref_str,
 4871       target_ts - seg-&gt;trak_media_start) + seg-&gt;time;
 4872   last_stop =
 4873       QTSTREAMTIME_TO_GSTTIME (ref_str,
 4874       ref_str-&gt;samples[ref_str-&gt;from_sample].timestamp -
 4875       seg-&gt;trak_media_start) + seg-&gt;time;
 4876 
 4877   GST_DEBUG_OBJECT (qtdemux, &quot;preferred stream played from sample %u, &quot;
 4878       &quot;now going to sample %u (pts %&quot; GST_TIME_FORMAT &quot;)&quot;, ref_str-&gt;from_sample,
 4879       k_index, GST_TIME_ARGS (k_pos));
 4880 
 4881   /* Set last_stop with the keyframe timestamp we pushed of that stream */
 4882   qtdemux-&gt;segment.position = last_stop;
 4883   GST_DEBUG_OBJECT (qtdemux, &quot;last_stop now is %&quot; GST_TIME_FORMAT,
 4884       GST_TIME_ARGS (last_stop));
 4885 
 4886   if (G_UNLIKELY (last_stop &lt; qtdemux-&gt;segment.start)) {
 4887     GST_DEBUG_OBJECT (qtdemux, &quot;reached the beginning of segment&quot;);
 4888     goto eos;
 4889   }
 4890 
 4891   ref_seg_idx = ref_str-&gt;segment_index;
 4892   ref_k_index = k_index;
 4893 
 4894   /* Align them all on this */
<a name="170" id="anc170"></a><span class="line-modified"> 4895   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
 4896     guint32 index = 0;
 4897     GstClockTime seg_time = 0;
<a name="171" id="anc171"></a><span class="line-modified"> 4898     QtDemuxStream *str = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 4899 
 4900     /* aligning reference stream again might lead to backing up to yet another
 4901      * keyframe (due to timestamp rounding issues),
 4902      * potentially putting more load on downstream; so let&#39;s try to avoid */
 4903     if (str == ref_str) {
 4904       seg_idx = ref_seg_idx;
 4905       seg = &amp;str-&gt;segments[seg_idx];
 4906       k_index = ref_k_index;
<a name="172" id="anc172"></a><span class="line-modified"> 4907       GST_DEBUG_OBJECT (qtdemux, &quot;reference track-id %u segment %d, &quot;</span>
<span class="line-modified"> 4908           &quot;sample at index %d&quot;, str-&gt;track_id, ref_str-&gt;segment_index, k_index);</span>
 4909     } else {
 4910       seg_idx = gst_qtdemux_find_segment (qtdemux, str, k_pos);
 4911       GST_DEBUG_OBJECT (qtdemux,
<a name="173" id="anc173"></a><span class="line-modified"> 4912           &quot;track-id %u align segment %d for keyframe pos %&quot; GST_TIME_FORMAT,</span>
<span class="line-modified"> 4913           str-&gt;track_id, seg_idx, GST_TIME_ARGS (k_pos));</span>
 4914 
 4915       /* get segment and time in the segment */
 4916       seg = &amp;str-&gt;segments[seg_idx];
 4917       seg_time = k_pos - seg-&gt;time;
 4918 
 4919       /* get the media time in the segment.
 4920        * No adjustment for empty &quot;filler&quot; segments */
 4921       if (seg-&gt;media_start != GST_CLOCK_TIME_NONE)
 4922         seg_time += seg-&gt;media_start;
 4923 
 4924       /* get the index of the sample with media time */
 4925       index = gst_qtdemux_find_index_linear (qtdemux, str, seg_time);
 4926       GST_DEBUG_OBJECT (qtdemux,
<a name="174" id="anc174"></a><span class="line-modified"> 4927           &quot;track-id %u sample for %&quot; GST_TIME_FORMAT &quot; at %u&quot;, str-&gt;track_id,</span>
 4928           GST_TIME_ARGS (seg_time), index);
 4929 
 4930       /* find previous keyframe */
 4931       k_index = gst_qtdemux_find_keyframe (qtdemux, str, index, FALSE);
 4932     }
 4933 
 4934     /* Remember until where we want to go */
 4935     str-&gt;to_sample = str-&gt;from_sample - 1;
 4936     /* Define our time position */
 4937     target_ts =
 4938         str-&gt;samples[k_index].timestamp + str-&gt;samples[k_index].pts_offset;
 4939     str-&gt;time_position = QTSTREAMTIME_TO_GSTTIME (str, target_ts) + seg-&gt;time;
 4940     if (seg-&gt;media_start != GST_CLOCK_TIME_NONE)
 4941       str-&gt;time_position -= seg-&gt;media_start;
 4942 
 4943     /* Now seek back in time */
 4944     gst_qtdemux_move_stream (qtdemux, str, k_index);
<a name="175" id="anc175"></a><span class="line-modified"> 4945     GST_DEBUG_OBJECT (qtdemux, &quot;track-id %u keyframe at %u, time position %&quot;</span>
<span class="line-modified"> 4946         GST_TIME_FORMAT &quot; playing from sample %u to %u&quot;, str-&gt;track_id, k_index,</span>
 4947         GST_TIME_ARGS (str-&gt;time_position), str-&gt;from_sample, str-&gt;to_sample);
 4948   }
 4949 
 4950   return GST_FLOW_OK;
 4951 
 4952 eos:
 4953   return GST_FLOW_EOS;
 4954 }
 4955 
 4956 /*
 4957  * Gets the current qt segment start, stop and position for the
 4958  * given time offset. This is used in update_segment()
 4959  */
 4960 static void
 4961 gst_qtdemux_stream_segment_get_boundaries (GstQTDemux * qtdemux,
 4962     QtDemuxStream * stream, GstClockTime offset,
 4963     GstClockTime * _start, GstClockTime * _stop, GstClockTime * _time)
 4964 {
 4965   GstClockTime seg_time;
 4966   GstClockTime start, stop, time;
 4967   QtDemuxSegment *segment;
 4968 
 4969   segment = &amp;stream-&gt;segments[stream-&gt;segment_index];
 4970 
 4971   /* get time in this segment */
 4972   seg_time = (offset - segment-&gt;time) * segment-&gt;rate;
 4973 
 4974   GST_LOG_OBJECT (stream-&gt;pad, &quot;seg_time %&quot; GST_TIME_FORMAT,
 4975       GST_TIME_ARGS (seg_time));
 4976 
 4977   if (G_UNLIKELY (seg_time &gt; segment-&gt;duration)) {
 4978     GST_LOG_OBJECT (stream-&gt;pad,
 4979         &quot;seg_time &gt; segment-&gt;duration %&quot; GST_TIME_FORMAT,
 4980         GST_TIME_ARGS (segment-&gt;duration));
 4981     seg_time = segment-&gt;duration;
 4982   }
 4983 
 4984   /* qtdemux-&gt;segment.stop is in outside-time-realm, whereas
 4985    * segment-&gt;media_stop is in track-time-realm.
 4986    *
 4987    * In order to compare the two, we need to bring segment.stop
 4988    * into the track-time-realm
 4989    *
 4990    * FIXME - does this comment still hold? Don&#39;t see any conversion here */
 4991 
 4992   stop = qtdemux-&gt;segment.stop;
 4993   if (stop == GST_CLOCK_TIME_NONE)
 4994     stop = qtdemux-&gt;segment.duration;
 4995   if (stop == GST_CLOCK_TIME_NONE)
 4996     stop = segment-&gt;media_stop;
 4997   else
 4998     stop =
 4999         MIN (segment-&gt;media_stop, stop - segment-&gt;time + segment-&gt;media_start);
 5000 
 5001   if (G_UNLIKELY (QTSEGMENT_IS_EMPTY (segment))) {
 5002     start = segment-&gt;time + seg_time;
 5003     time = offset;
 5004     stop = start - seg_time + segment-&gt;duration;
 5005   } else if (qtdemux-&gt;segment.rate &gt;= 0) {
 5006     start = MIN (segment-&gt;media_start + seg_time, stop);
 5007     time = offset;
 5008   } else {
 5009     if (segment-&gt;media_start &gt;= qtdemux-&gt;segment.start) {
 5010       time = segment-&gt;time;
 5011     } else {
 5012       time = segment-&gt;time + (qtdemux-&gt;segment.start - segment-&gt;media_start);
 5013     }
 5014 
 5015     start = MAX (segment-&gt;media_start, qtdemux-&gt;segment.start);
 5016     stop = MIN (segment-&gt;media_start + seg_time, stop);
 5017   }
 5018 
 5019   *_start = start;
 5020   *_stop = stop;
 5021   *_time = time;
 5022 }
 5023 
 5024 /*
 5025  * Updates the qt segment used for the stream and pushes a new segment event
 5026  * downstream on this stream&#39;s pad.
 5027  */
 5028 static gboolean
 5029 gst_qtdemux_stream_update_segment (GstQTDemux * qtdemux, QtDemuxStream * stream,
 5030     gint seg_idx, GstClockTime offset, GstClockTime * _start,
 5031     GstClockTime * _stop)
 5032 {
 5033   QtDemuxSegment *segment;
 5034   GstClockTime start = 0, stop = GST_CLOCK_TIME_NONE, time = 0;
 5035   gdouble rate;
 5036   GstEvent *event;
 5037 
 5038   /* update the current segment */
 5039   stream-&gt;segment_index = seg_idx;
 5040 
 5041   /* get the segment */
 5042   segment = &amp;stream-&gt;segments[seg_idx];
 5043 
 5044   if (G_UNLIKELY (offset &lt; segment-&gt;time)) {
 5045     GST_WARNING_OBJECT (stream-&gt;pad, &quot;offset &lt; segment-&gt;time %&quot; GST_TIME_FORMAT,
 5046         GST_TIME_ARGS (segment-&gt;time));
 5047     return FALSE;
 5048   }
 5049 
 5050   /* segment lies beyond total indicated duration */
 5051   if (G_UNLIKELY (qtdemux-&gt;segment.duration != GST_CLOCK_TIME_NONE &amp;&amp;
 5052           segment-&gt;time &gt; qtdemux-&gt;segment.duration)) {
 5053     GST_WARNING_OBJECT (stream-&gt;pad, &quot;file duration %&quot; GST_TIME_FORMAT
 5054         &quot; &lt; segment-&gt;time %&quot; GST_TIME_FORMAT,
 5055         GST_TIME_ARGS (qtdemux-&gt;segment.duration),
 5056         GST_TIME_ARGS (segment-&gt;time));
 5057     return FALSE;
 5058   }
 5059 
 5060   gst_qtdemux_stream_segment_get_boundaries (qtdemux, stream, offset,
 5061       &amp;start, &amp;stop, &amp;time);
 5062 
 5063   GST_DEBUG_OBJECT (stream-&gt;pad, &quot;new segment %d from %&quot; GST_TIME_FORMAT
 5064       &quot; to %&quot; GST_TIME_FORMAT &quot;, time %&quot; GST_TIME_FORMAT, seg_idx,
 5065       GST_TIME_ARGS (start), GST_TIME_ARGS (stop), GST_TIME_ARGS (time));
 5066 
 5067   /* combine global rate with that of the segment */
 5068   rate = segment-&gt;rate * qtdemux-&gt;segment.rate;
 5069 
 5070   /* Copy flags from main segment */
 5071   stream-&gt;segment.flags = qtdemux-&gt;segment.flags;
 5072 
 5073   /* update the segment values used for clipping */
 5074   stream-&gt;segment.offset = qtdemux-&gt;segment.offset;
 5075   stream-&gt;segment.base = qtdemux-&gt;segment.base + stream-&gt;accumulated_base;
 5076   stream-&gt;segment.applied_rate = qtdemux-&gt;segment.applied_rate;
 5077   stream-&gt;segment.rate = rate;
 5078   stream-&gt;segment.start = start + QTSTREAMTIME_TO_GSTTIME (stream,
 5079       stream-&gt;cslg_shift);
 5080   stream-&gt;segment.stop = stop + QTSTREAMTIME_TO_GSTTIME (stream,
 5081       stream-&gt;cslg_shift);
 5082   stream-&gt;segment.time = time;
 5083   stream-&gt;segment.position = stream-&gt;segment.start;
 5084 
 5085   GST_DEBUG_OBJECT (stream-&gt;pad, &quot;New segment: %&quot; GST_SEGMENT_FORMAT,
 5086       &amp;stream-&gt;segment);
 5087 
 5088   /* now prepare and send the segment */
 5089   if (stream-&gt;pad) {
 5090     event = gst_event_new_segment (&amp;stream-&gt;segment);
 5091     if (qtdemux-&gt;segment_seqnum != GST_SEQNUM_INVALID) {
 5092       gst_event_set_seqnum (event, qtdemux-&gt;segment_seqnum);
 5093     }
 5094     gst_pad_push_event (stream-&gt;pad, event);
 5095     /* assume we can send more data now */
 5096     GST_PAD_LAST_FLOW_RETURN (stream-&gt;pad) = GST_FLOW_OK;
 5097     /* clear to send tags on this pad now */
 5098     gst_qtdemux_push_tags (qtdemux, stream);
 5099   }
 5100 
 5101   if (_start)
 5102     *_start = start;
 5103   if (_stop)
 5104     *_stop = stop;
 5105 
 5106   return TRUE;
 5107 }
 5108 
 5109 /* activate the given segment number @seg_idx of @stream at time @offset.
 5110  * @offset is an absolute global position over all the segments.
 5111  *
 5112  * This will push out a NEWSEGMENT event with the right values and
 5113  * position the stream index to the first decodable sample before
 5114  * @offset.
 5115  */
 5116 static gboolean
 5117 gst_qtdemux_activate_segment (GstQTDemux * qtdemux, QtDemuxStream * stream,
 5118     guint32 seg_idx, GstClockTime offset)
 5119 {
 5120   QtDemuxSegment *segment;
 5121   guint32 index, kf_index;
 5122   GstClockTime start = 0, stop = GST_CLOCK_TIME_NONE;
 5123 
 5124   GST_LOG_OBJECT (stream-&gt;pad, &quot;activate segment %d, offset %&quot; GST_TIME_FORMAT,
 5125       seg_idx, GST_TIME_ARGS (offset));
 5126 
 5127   if (!gst_qtdemux_stream_update_segment (qtdemux, stream, seg_idx, offset,
 5128           &amp;start, &amp;stop))
 5129     return FALSE;
 5130 
 5131   segment = &amp;stream-&gt;segments[stream-&gt;segment_index];
 5132 
 5133   /* in the fragmented case, we pick a fragment that starts before our
 5134    * desired position and rely on downstream to wait for a keyframe
 5135    * (FIXME: doesn&#39;t seem to work so well with ismv and wmv, as no parser; the
 5136    * tfra entries tells us which trun/sample the key unit is in, but we don&#39;t
 5137    * make use of this additional information at the moment) */
 5138   if (qtdemux-&gt;fragmented &amp;&amp; !qtdemux-&gt;fragmented_seek_pending) {
 5139     stream-&gt;to_sample = G_MAXUINT32;
 5140     return TRUE;
 5141   } else {
 5142     /* well, it will be taken care of below */
 5143     qtdemux-&gt;fragmented_seek_pending = FALSE;
 5144     /* FIXME ideally the do_fragmented_seek can be done right here,
 5145      * rather than at loop level
 5146      * (which might even allow handling edit lists in a fragmented file) */
 5147   }
 5148 
 5149   /* We don&#39;t need to look for a sample in push-based */
 5150   if (!qtdemux-&gt;pullbased)
 5151     return TRUE;
 5152 
 5153   /* and move to the keyframe before the indicated media time of the
 5154    * segment */
 5155   if (G_LIKELY (!QTSEGMENT_IS_EMPTY (segment))) {
<a name="176" id="anc176"></a><span class="line-modified"> 5156     if (qtdemux-&gt;segment.rate &gt;= 0) {</span>
<span class="line-modified"> 5157       index = gst_qtdemux_find_index_linear (qtdemux, stream, start);</span>
<span class="line-modified"> 5158       stream-&gt;to_sample = G_MAXUINT32;</span>
 5159       GST_DEBUG_OBJECT (stream-&gt;pad,
 5160           &quot;moving data pointer to %&quot; GST_TIME_FORMAT &quot;, index: %u, pts %&quot;
 5161           GST_TIME_FORMAT, GST_TIME_ARGS (start), index,
 5162           GST_TIME_ARGS (QTSAMPLE_PTS (stream, &amp;stream-&gt;samples[index])));
<a name="177" id="anc177"></a><span class="line-modified"> 5163     } else {</span>
<span class="line-modified"> 5164       index = gst_qtdemux_find_index_linear (qtdemux, stream, stop);</span>
<span class="line-modified"> 5165       stream-&gt;to_sample = index;</span>
 5166       GST_DEBUG_OBJECT (stream-&gt;pad,
 5167           &quot;moving data pointer to %&quot; GST_TIME_FORMAT &quot;, index: %u, pts %&quot;
 5168           GST_TIME_FORMAT, GST_TIME_ARGS (stop), index,
 5169           GST_TIME_ARGS (QTSAMPLE_PTS (stream, &amp;stream-&gt;samples[index])));
<a name="178" id="anc178"></a><span class="line-modified"> 5170     }</span>
 5171   } else {
 5172     GST_DEBUG_OBJECT (stream-&gt;pad, &quot;No need to look for keyframe, &quot;
 5173         &quot;this is an empty segment&quot;);
 5174     return TRUE;
 5175   }
 5176 
 5177   /* gst_qtdemux_parse_sample () called from gst_qtdemux_find_index_linear ()
 5178    * encountered an error and printed a message so we return appropriately */
 5179   if (index == -1)
 5180     return FALSE;
 5181 
 5182   /* we&#39;re at the right spot */
 5183   if (index == stream-&gt;sample_index) {
 5184     GST_DEBUG_OBJECT (stream-&gt;pad, &quot;we are at the right index&quot;);
 5185     return TRUE;
 5186   }
 5187 
 5188   /* find keyframe of the target index */
 5189   kf_index = gst_qtdemux_find_keyframe (qtdemux, stream, index, FALSE);
 5190 
 5191 /* *INDENT-OFF* */
 5192 /* indent does stupid stuff with stream-&gt;samples[].timestamp */
 5193 
 5194   /* if we move forwards, we don&#39;t have to go back to the previous
 5195    * keyframe since we already sent that. We can also just jump to
 5196    * the keyframe right before the target index if there is one. */
 5197   if (index &gt; stream-&gt;sample_index) {
 5198     /* moving forwards check if we move past a keyframe */
 5199     if (kf_index &gt; stream-&gt;sample_index) {
 5200       GST_DEBUG_OBJECT (stream-&gt;pad,
 5201            &quot;moving forwards to keyframe at %u (pts %&quot; GST_TIME_FORMAT &quot; dts %&quot;GST_TIME_FORMAT&quot; )&quot;, kf_index,
 5202            GST_TIME_ARGS (QTSAMPLE_PTS(stream, &amp;stream-&gt;samples[kf_index])),
 5203            GST_TIME_ARGS (QTSAMPLE_DTS(stream, &amp;stream-&gt;samples[kf_index])));
 5204       gst_qtdemux_move_stream (qtdemux, stream, kf_index);
 5205     } else {
 5206       GST_DEBUG_OBJECT (stream-&gt;pad,
 5207           &quot;moving forwards, keyframe at %u (pts %&quot; GST_TIME_FORMAT &quot; dts %&quot;GST_TIME_FORMAT&quot; ) already sent&quot;, kf_index,
 5208           GST_TIME_ARGS (QTSAMPLE_PTS (stream, &amp;stream-&gt;samples[kf_index])),
 5209           GST_TIME_ARGS (QTSAMPLE_DTS (stream, &amp;stream-&gt;samples[kf_index])));
 5210     }
 5211   } else {
 5212     GST_DEBUG_OBJECT (stream-&gt;pad,
 5213         &quot;moving backwards to keyframe at %u (pts %&quot; GST_TIME_FORMAT &quot; dts %&quot;GST_TIME_FORMAT&quot; )&quot;, kf_index,
 5214         GST_TIME_ARGS (QTSAMPLE_PTS(stream, &amp;stream-&gt;samples[kf_index])),
 5215         GST_TIME_ARGS (QTSAMPLE_DTS(stream, &amp;stream-&gt;samples[kf_index])));
 5216     gst_qtdemux_move_stream (qtdemux, stream, kf_index);
 5217   }
 5218 
 5219 /* *INDENT-ON* */
 5220 
 5221   return TRUE;
 5222 }
 5223 
 5224 /* prepare to get the current sample of @stream, getting essential values.
 5225  *
 5226  * This function will also prepare and send the segment when needed.
 5227  *
 5228  * Return FALSE if the stream is EOS.
 5229  *
 5230  * PULL-BASED
 5231  */
 5232 static gboolean
 5233 gst_qtdemux_prepare_current_sample (GstQTDemux * qtdemux,
 5234     QtDemuxStream * stream, gboolean * empty, guint64 * offset, guint * size,
 5235     GstClockTime * dts, GstClockTime * pts, GstClockTime * duration,
 5236     gboolean * keyframe)
 5237 {
 5238   QtDemuxSample *sample;
 5239   GstClockTime time_position;
 5240   guint32 seg_idx;
 5241 
 5242   g_return_val_if_fail (stream != NULL, FALSE);
 5243 
 5244   time_position = stream-&gt;time_position;
 5245   if (G_UNLIKELY (time_position == GST_CLOCK_TIME_NONE))
 5246     goto eos;
 5247 
 5248   seg_idx = stream-&gt;segment_index;
 5249   if (G_UNLIKELY (seg_idx == -1)) {
 5250     /* find segment corresponding to time_position if we are looking
 5251      * for a segment. */
 5252     seg_idx = gst_qtdemux_find_segment (qtdemux, stream, time_position);
 5253   }
 5254 
 5255   /* different segment, activate it, sample_index will be set. */
 5256   if (G_UNLIKELY (stream-&gt;segment_index != seg_idx))
 5257     gst_qtdemux_activate_segment (qtdemux, stream, seg_idx, time_position);
 5258 
<a name="179" id="anc179"></a><span class="line-modified"> 5259   if (G_UNLIKELY (QTSEGMENT_IS_EMPTY (&amp;stream-&gt;</span>
<span class="line-modified"> 5260               segments[stream-&gt;segment_index]))) {</span>
 5261     QtDemuxSegment *seg = &amp;stream-&gt;segments[stream-&gt;segment_index];
 5262 
 5263     GST_LOG_OBJECT (qtdemux, &quot;Empty segment activated,&quot;
 5264         &quot; prepare empty sample&quot;);
 5265 
 5266     *empty = TRUE;
 5267     *pts = *dts = time_position;
 5268     *duration = seg-&gt;duration - (time_position - seg-&gt;time);
 5269 
 5270     return TRUE;
 5271   }
 5272 
 5273   *empty = FALSE;
 5274 
 5275   if (stream-&gt;sample_index == -1)
 5276     stream-&gt;sample_index = 0;
 5277 
 5278   GST_LOG_OBJECT (qtdemux, &quot;segment active, index = %u of %u&quot;,
 5279       stream-&gt;sample_index, stream-&gt;n_samples);
 5280 
 5281   if (G_UNLIKELY (stream-&gt;sample_index &gt;= stream-&gt;n_samples)) {
 5282     if (!qtdemux-&gt;fragmented)
<a name="180" id="anc180"></a><span class="line-modified"> 5283       goto eos;</span>
 5284 
 5285     GST_INFO_OBJECT (qtdemux, &quot;out of samples, trying to add more&quot;);
 5286     do {
 5287       GstFlowReturn flow;
 5288 
 5289       GST_OBJECT_LOCK (qtdemux);
 5290       flow = qtdemux_add_fragmented_samples (qtdemux);
 5291       GST_OBJECT_UNLOCK (qtdemux);
 5292 
 5293       if (flow != GST_FLOW_OK)
 5294         goto eos;
 5295     }
 5296     while (stream-&gt;sample_index &gt;= stream-&gt;n_samples);
 5297   }
 5298 
 5299   if (!qtdemux_parse_samples (qtdemux, stream, stream-&gt;sample_index)) {
 5300     GST_LOG_OBJECT (qtdemux, &quot;Parsing of index %u failed!&quot;,
 5301         stream-&gt;sample_index);
 5302     return FALSE;
 5303   }
 5304 
 5305   /* now get the info for the sample we&#39;re at */
 5306   sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
 5307 
 5308   *dts = QTSAMPLE_DTS (stream, sample);
 5309   *pts = QTSAMPLE_PTS (stream, sample);
 5310   *offset = sample-&gt;offset;
 5311   *size = sample-&gt;size;
 5312   *duration = QTSAMPLE_DUR_DTS (stream, sample, *dts);
 5313   *keyframe = QTSAMPLE_KEYFRAME (stream, sample);
 5314 
 5315   return TRUE;
 5316 
 5317   /* special cases */
 5318 eos:
 5319   {
 5320     stream-&gt;time_position = GST_CLOCK_TIME_NONE;
 5321     return FALSE;
 5322   }
 5323 }
 5324 
 5325 /* move to the next sample in @stream.
 5326  *
 5327  * Moves to the next segment when needed.
 5328  */
 5329 static void
 5330 gst_qtdemux_advance_sample (GstQTDemux * qtdemux, QtDemuxStream * stream)
 5331 {
 5332   QtDemuxSample *sample;
 5333   QtDemuxSegment *segment;
 5334 
 5335   /* get current segment */
 5336   segment = &amp;stream-&gt;segments[stream-&gt;segment_index];
 5337 
 5338   if (G_UNLIKELY (QTSEGMENT_IS_EMPTY (segment))) {
 5339     GST_DEBUG_OBJECT (qtdemux, &quot;Empty segment, no samples to advance&quot;);
 5340     goto next_segment;
 5341   }
 5342 
 5343   if (G_UNLIKELY (stream-&gt;sample_index &gt;= stream-&gt;to_sample)) {
 5344     /* Mark the stream as EOS */
 5345     GST_DEBUG_OBJECT (qtdemux,
 5346         &quot;reached max allowed sample %u, mark EOS&quot;, stream-&gt;to_sample);
 5347     stream-&gt;time_position = GST_CLOCK_TIME_NONE;
 5348     return;
 5349   }
 5350 
 5351   /* move to next sample */
 5352   stream-&gt;sample_index++;
 5353   stream-&gt;offset_in_sample = 0;
 5354 
 5355   /* reached the last sample, we need the next segment */
 5356   if (G_UNLIKELY (stream-&gt;sample_index &gt;= stream-&gt;n_samples))
 5357     goto next_segment;
 5358 
 5359   if (!qtdemux_parse_samples (qtdemux, stream, stream-&gt;sample_index)) {
 5360     GST_LOG_OBJECT (qtdemux, &quot;Parsing of index %u failed!&quot;,
 5361         stream-&gt;sample_index);
 5362     return;
 5363   }
 5364 
 5365   /* get next sample */
 5366   sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
 5367 
 5368   /* see if we are past the segment */
 5369   if (G_UNLIKELY (QTSAMPLE_DTS (stream, sample) &gt;= segment-&gt;media_stop))
 5370     goto next_segment;
 5371 
 5372   if (QTSAMPLE_DTS (stream, sample) &gt;= segment-&gt;media_start) {
 5373     /* inside the segment, update time_position, looks very familiar to
 5374      * GStreamer segments, doesn&#39;t it? */
 5375     stream-&gt;time_position =
 5376         QTSAMPLE_DTS (stream, sample) - segment-&gt;media_start + segment-&gt;time;
 5377   } else {
 5378     /* not yet in segment, time does not yet increment. This means
 5379      * that we are still prerolling keyframes to the decoder so it can
 5380      * decode the first sample of the segment. */
 5381     stream-&gt;time_position = segment-&gt;time;
 5382   }
 5383   return;
 5384 
 5385   /* move to the next segment */
 5386 next_segment:
 5387   {
 5388     GST_DEBUG_OBJECT (qtdemux, &quot;segment %d ended &quot;, stream-&gt;segment_index);
 5389 
 5390     if (stream-&gt;segment_index == stream-&gt;n_segments - 1) {
 5391       /* are we at the end of the last segment, we&#39;re EOS */
 5392       stream-&gt;time_position = GST_CLOCK_TIME_NONE;
 5393     } else {
 5394       /* else we&#39;re only at the end of the current segment */
 5395       stream-&gt;time_position = segment-&gt;stop_time;
 5396     }
 5397     /* make sure we select a new segment */
 5398 
 5399     /* accumulate previous segments */
 5400     if (GST_CLOCK_TIME_IS_VALID (stream-&gt;segment.stop))
 5401       stream-&gt;accumulated_base +=
 5402           (stream-&gt;segment.stop -
 5403           stream-&gt;segment.start) / ABS (stream-&gt;segment.rate);
 5404 
 5405     stream-&gt;segment_index = -1;
 5406   }
 5407 }
 5408 
 5409 static void
 5410 gst_qtdemux_sync_streams (GstQTDemux * demux)
 5411 {
 5412   gint i;
 5413 
<a name="181" id="anc181"></a><span class="line-modified"> 5414   if (QTDEMUX_N_STREAMS (demux) &lt;= 1)</span>
 5415     return;
 5416 
<a name="182" id="anc182"></a><span class="line-modified"> 5417   for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
 5418     QtDemuxStream *stream;
 5419     GstClockTime end_time;
 5420 
<a name="183" id="anc183"></a><span class="line-modified"> 5421     stream = QTDEMUX_NTH_STREAM (demux, i);</span>
 5422 
 5423     if (!stream-&gt;pad)
 5424       continue;
 5425 
 5426     /* TODO advance time on subtitle streams here, if any some day */
 5427 
 5428     /* some clips/trailers may have unbalanced streams at the end,
 5429      * so send EOS on shorter stream to prevent stalling others */
 5430 
 5431     /* do not mess with EOS if SEGMENT seeking */
 5432     if (demux-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT)
 5433       continue;
 5434 
 5435     if (demux-&gt;pullbased) {
 5436       /* loop mode is sample time based */
 5437       if (!STREAM_IS_EOS (stream))
 5438         continue;
 5439     } else {
 5440       /* push mode is byte position based */
 5441       if (stream-&gt;n_samples &amp;&amp;
 5442           stream-&gt;samples[stream-&gt;n_samples - 1].offset &gt;= demux-&gt;offset)
 5443         continue;
 5444     }
 5445 
 5446     if (stream-&gt;sent_eos)
 5447       continue;
 5448 
 5449     /* only act if some gap */
 5450     end_time = stream-&gt;segments[stream-&gt;n_segments - 1].stop_time;
 5451     GST_LOG_OBJECT (demux, &quot;current position: %&quot; GST_TIME_FORMAT
 5452         &quot;, stream end: %&quot; GST_TIME_FORMAT,
 5453         GST_TIME_ARGS (demux-&gt;segment.position), GST_TIME_ARGS (end_time));
 5454     if (GST_CLOCK_TIME_IS_VALID (end_time)
 5455         &amp;&amp; (end_time + 2 * GST_SECOND &lt; demux-&gt;segment.position)) {
 5456       GstEvent *event;
 5457 
 5458       GST_DEBUG_OBJECT (demux, &quot;sending EOS for stream %s&quot;,
 5459           GST_PAD_NAME (stream-&gt;pad));
 5460       stream-&gt;sent_eos = TRUE;
 5461       event = gst_event_new_eos ();
 5462       if (demux-&gt;segment_seqnum != GST_SEQNUM_INVALID)
 5463         gst_event_set_seqnum (event, demux-&gt;segment_seqnum);
 5464       gst_pad_push_event (stream-&gt;pad, event);
 5465     }
 5466   }
 5467 }
 5468 
 5469 /* EOS and NOT_LINKED need to be combined. This means that we return:
 5470  *
 5471  *  GST_FLOW_NOT_LINKED: when all pads NOT_LINKED.
 5472  *  GST_FLOW_EOS: when all pads EOS or NOT_LINKED.
 5473  */
 5474 static GstFlowReturn
 5475 gst_qtdemux_combine_flows (GstQTDemux * demux, QtDemuxStream * stream,
 5476     GstFlowReturn ret)
 5477 {
 5478   GST_LOG_OBJECT (demux, &quot;flow return: %s&quot;, gst_flow_get_name (ret));
 5479 
 5480   if (stream-&gt;pad)
 5481     ret = gst_flow_combiner_update_pad_flow (demux-&gt;flowcombiner, stream-&gt;pad,
 5482         ret);
 5483   else
<a name="184" id="anc184"></a><span class="line-modified"> 5484     ret = gst_flow_combiner_update_flow (demux-&gt;flowcombiner, ret);</span>
 5485 
 5486   GST_LOG_OBJECT (demux, &quot;combined flow return: %s&quot;, gst_flow_get_name (ret));
 5487   return ret;
 5488 }
 5489 
 5490 /* the input buffer metadata must be writable. Returns NULL when the buffer is
 5491  * completely clipped
 5492  *
 5493  * Should be used only with raw buffers */
 5494 static GstBuffer *
 5495 gst_qtdemux_clip_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,
 5496     GstBuffer * buf)
 5497 {
 5498   guint64 start, stop, cstart, cstop, diff;
 5499   GstClockTime pts, duration;
 5500   gsize size, osize;
 5501   gint num_rate, denom_rate;
 5502   gint frame_size;
 5503   gboolean clip_data;
 5504   guint offset;
 5505 
 5506   osize = size = gst_buffer_get_size (buf);
 5507   offset = 0;
 5508 
 5509   /* depending on the type, setup the clip parameters */
 5510   if (stream-&gt;subtype == FOURCC_soun) {
 5511     frame_size = CUR_STREAM (stream)-&gt;bytes_per_frame;
 5512     num_rate = GST_SECOND;
 5513     denom_rate = (gint) CUR_STREAM (stream)-&gt;rate;
 5514     clip_data = TRUE;
 5515   } else if (stream-&gt;subtype == FOURCC_vide) {
 5516     frame_size = size;
 5517     num_rate = CUR_STREAM (stream)-&gt;fps_n;
 5518     denom_rate = CUR_STREAM (stream)-&gt;fps_d;
 5519     clip_data = FALSE;
 5520   } else
 5521     goto wrong_type;
 5522 
 5523   if (frame_size &lt;= 0)
 5524     goto bad_frame_size;
 5525 
 5526   /* we can only clip if we have a valid pts */
 5527   pts = GST_BUFFER_PTS (buf);
 5528   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (pts)))
 5529     goto no_pts;
 5530 
<a name="185" id="anc185"></a><span class="line-modified"> 5531   duration = GST_BUFFER_DURATION (buf);</span>
 5532 
 5533   if (G_UNLIKELY (!GST_CLOCK_TIME_IS_VALID (duration))) {
 5534     duration =
 5535         gst_util_uint64_scale_int (size / frame_size, num_rate, denom_rate);
 5536   }
 5537 
 5538   start = pts;
 5539   stop = start + duration;
 5540 
 5541   if (G_UNLIKELY (!gst_segment_clip (&amp;stream-&gt;segment,
 5542               GST_FORMAT_TIME, start, stop, &amp;cstart, &amp;cstop)))
 5543     goto clipped;
 5544 
 5545   /* see if some clipping happened */
 5546   diff = cstart - start;
 5547   if (diff &gt; 0) {
 5548     pts += diff;
 5549     duration -= diff;
 5550 
 5551     if (clip_data) {
 5552       /* bring clipped time to samples and to bytes */
 5553       diff = gst_util_uint64_scale_int (diff, denom_rate, num_rate);
 5554       diff *= frame_size;
 5555 
 5556       GST_DEBUG_OBJECT (qtdemux,
 5557           &quot;clipping start to %&quot; GST_TIME_FORMAT &quot; %&quot;
 5558           G_GUINT64_FORMAT &quot; bytes&quot;, GST_TIME_ARGS (cstart), diff);
 5559 
 5560       offset = diff;
 5561       size -= diff;
 5562     }
 5563   }
 5564   diff = stop - cstop;
 5565   if (diff &gt; 0) {
 5566     duration -= diff;
 5567 
 5568     if (clip_data) {
 5569       /* bring clipped time to samples and then to bytes */
 5570       diff = gst_util_uint64_scale_int (diff, denom_rate, num_rate);
 5571       diff *= frame_size;
 5572       GST_DEBUG_OBJECT (qtdemux,
 5573           &quot;clipping stop to %&quot; GST_TIME_FORMAT &quot; %&quot; G_GUINT64_FORMAT
 5574           &quot; bytes&quot;, GST_TIME_ARGS (cstop), diff);
 5575       size -= diff;
 5576     }
 5577   }
 5578 
 5579   if (offset != 0 || size != osize)
 5580     gst_buffer_resize (buf, offset, size);
 5581 
 5582   GST_BUFFER_DTS (buf) = GST_CLOCK_TIME_NONE;
 5583   GST_BUFFER_PTS (buf) = pts;
 5584   GST_BUFFER_DURATION (buf) = duration;
 5585 
 5586   return buf;
 5587 
 5588   /* dropped buffer */
 5589 wrong_type:
 5590   {
 5591     GST_DEBUG_OBJECT (qtdemux, &quot;unknown stream type&quot;);
 5592     return buf;
 5593   }
 5594 bad_frame_size:
 5595   {
 5596     GST_DEBUG_OBJECT (qtdemux, &quot;bad frame size&quot;);
 5597     return buf;
 5598   }
 5599 no_pts:
 5600   {
 5601     GST_DEBUG_OBJECT (qtdemux, &quot;no pts on buffer&quot;);
 5602     return buf;
 5603   }
 5604 clipped:
 5605   {
 5606     GST_DEBUG_OBJECT (qtdemux, &quot;clipped buffer&quot;);
 5607     gst_buffer_unref (buf);
 5608     return NULL;
 5609   }
 5610 }
 5611 
 5612 static GstBuffer *
 5613 gst_qtdemux_align_buffer (GstQTDemux * demux,
 5614     GstBuffer * buffer, gsize alignment)
 5615 {
 5616   GstMapInfo map;
 5617 
 5618   gst_buffer_map (buffer, &amp;map, GST_MAP_READ);
 5619 
 5620   if (map.size &lt; sizeof (guintptr)) {
 5621     gst_buffer_unmap (buffer, &amp;map);
 5622     return buffer;
 5623   }
 5624 
 5625   if (((guintptr) map.data) &amp; (alignment - 1)) {
 5626     GstBuffer *new_buffer;
 5627     GstAllocationParams params = { 0, alignment - 1, 0, 0, };
 5628 
 5629     new_buffer = gst_buffer_new_allocate (NULL,
 5630         gst_buffer_get_size (buffer), &amp;params);
 5631 
 5632     /* Copy data &quot;by hand&quot;, so ensure alignment is kept: */
 5633     gst_buffer_fill (new_buffer, 0, map.data, map.size);
 5634 
 5635     gst_buffer_copy_into (new_buffer, buffer, GST_BUFFER_COPY_METADATA, 0, -1);
 5636     GST_DEBUG_OBJECT (demux,
 5637         &quot;We want output aligned on %&quot; G_GSIZE_FORMAT &quot;, reallocated&quot;,
 5638         alignment);
 5639 
 5640     gst_buffer_unmap (buffer, &amp;map);
 5641     gst_buffer_unref (buffer);
 5642 
 5643     return new_buffer;
 5644   }
 5645 
 5646   gst_buffer_unmap (buffer, &amp;map);
 5647   return buffer;
 5648 }
 5649 
<a name="186" id="anc186"></a><span class="line-added"> 5650 static guint8 *</span>
<span class="line-added"> 5651 convert_to_s334_1a (const guint8 * ccpair, guint8 ccpair_size, guint field,</span>
<span class="line-added"> 5652     gsize * res)</span>
<span class="line-added"> 5653 {</span>
<span class="line-added"> 5654   guint8 *storage;</span>
<span class="line-added"> 5655   gsize i;</span>
<span class="line-added"> 5656 </span>
<span class="line-added"> 5657   /* We are converting from pairs to triplets */</span>
<span class="line-added"> 5658   *res = ccpair_size / 2 * 3;</span>
<span class="line-added"> 5659   storage = g_malloc (*res);</span>
<span class="line-added"> 5660   for (i = 0; i * 2 &lt; ccpair_size; i += 1) {</span>
<span class="line-added"> 5661     /* FIXME: Use line offset 0 as we simply can&#39;t know here */</span>
<span class="line-added"> 5662     if (field == 1)</span>
<span class="line-added"> 5663       storage[i * 3] = 0x80 | 0x00;</span>
<span class="line-added"> 5664     else</span>
<span class="line-added"> 5665       storage[i * 3] = 0x00 | 0x00;</span>
<span class="line-added"> 5666     storage[i * 3 + 1] = ccpair[i * 2];</span>
<span class="line-added"> 5667     storage[i * 3 + 2] = ccpair[i * 2 + 1];</span>
<span class="line-added"> 5668   }</span>
<span class="line-added"> 5669 </span>
<span class="line-added"> 5670   return storage;</span>
<span class="line-added"> 5671 }</span>
<span class="line-added"> 5672 </span>
<span class="line-added"> 5673 static guint8 *</span>
<span class="line-added"> 5674 extract_cc_from_data (QtDemuxStream * stream, const guint8 * data, gsize size,</span>
<span class="line-added"> 5675     gsize * cclen)</span>
<span class="line-added"> 5676 {</span>
<span class="line-added"> 5677   guint8 *res = NULL;</span>
<span class="line-added"> 5678   guint32 atom_length, fourcc;</span>
<span class="line-added"> 5679   QtDemuxStreamStsdEntry *stsd_entry;</span>
<span class="line-added"> 5680 </span>
<span class="line-added"> 5681   GST_MEMDUMP (&quot;caption atom&quot;, data, size);</span>
<span class="line-added"> 5682 </span>
<span class="line-added"> 5683   /* There might be multiple atoms */</span>
<span class="line-added"> 5684 </span>
<span class="line-added"> 5685   *cclen = 0;</span>
<span class="line-added"> 5686   if (size &lt; 8)</span>
<span class="line-added"> 5687     goto invalid_cdat;</span>
<span class="line-added"> 5688   atom_length = QT_UINT32 (data);</span>
<span class="line-added"> 5689   fourcc = QT_FOURCC (data + 4);</span>
<span class="line-added"> 5690   if (G_UNLIKELY (atom_length &gt; size || atom_length == 8))</span>
<span class="line-added"> 5691     goto invalid_cdat;</span>
<span class="line-added"> 5692 </span>
<span class="line-added"> 5693   GST_DEBUG_OBJECT (stream-&gt;pad, &quot;here&quot;);</span>
<span class="line-added"> 5694 </span>
<span class="line-added"> 5695   /* Check if we have somethig compatible */</span>
<span class="line-added"> 5696   stsd_entry = CUR_STREAM (stream);</span>
<span class="line-added"> 5697   switch (stsd_entry-&gt;fourcc) {</span>
<span class="line-added"> 5698     case FOURCC_c608:{</span>
<span class="line-added"> 5699       guint8 *cdat = NULL, *cdt2 = NULL;</span>
<span class="line-added"> 5700       gsize cdat_size = 0, cdt2_size = 0;</span>
<span class="line-added"> 5701       /* Should be cdat or cdt2 */</span>
<span class="line-added"> 5702       if (fourcc != FOURCC_cdat &amp;&amp; fourcc != FOURCC_cdt2) {</span>
<span class="line-added"> 5703         GST_WARNING_OBJECT (stream-&gt;pad,</span>
<span class="line-added"> 5704             &quot;Unknown data atom (%&quot; GST_FOURCC_FORMAT &quot;) for CEA608&quot;,</span>
<span class="line-added"> 5705             GST_FOURCC_ARGS (fourcc));</span>
<span class="line-added"> 5706         goto invalid_cdat;</span>
<span class="line-added"> 5707       }</span>
<span class="line-added"> 5708 </span>
<span class="line-added"> 5709       /* Convert to S334-1 Annex A byte triplet */</span>
<span class="line-added"> 5710       if (fourcc == FOURCC_cdat)</span>
<span class="line-added"> 5711         cdat = convert_to_s334_1a (data + 8, atom_length - 8, 1, &amp;cdat_size);</span>
<span class="line-added"> 5712       else</span>
<span class="line-added"> 5713         cdt2 = convert_to_s334_1a (data + 8, atom_length - 8, 2, &amp;cdt2_size);</span>
<span class="line-added"> 5714       GST_DEBUG_OBJECT (stream-&gt;pad, &quot;size:%&quot; G_GSIZE_FORMAT &quot; atom_length:%u&quot;,</span>
<span class="line-added"> 5715           size, atom_length);</span>
<span class="line-added"> 5716 </span>
<span class="line-added"> 5717       /* Check for another atom ? */</span>
<span class="line-added"> 5718       if (size &gt; atom_length + 8) {</span>
<span class="line-added"> 5719         guint32 new_atom_length = QT_UINT32 (data + atom_length);</span>
<span class="line-added"> 5720         if (size &gt;= atom_length + new_atom_length) {</span>
<span class="line-added"> 5721           fourcc = QT_FOURCC (data + atom_length + 4);</span>
<span class="line-added"> 5722           if (fourcc == FOURCC_cdat) {</span>
<span class="line-added"> 5723             if (cdat == NULL)</span>
<span class="line-added"> 5724               cdat =</span>
<span class="line-added"> 5725                   convert_to_s334_1a (data + atom_length + 8,</span>
<span class="line-added"> 5726                   new_atom_length - 8, 1, &amp;cdat_size);</span>
<span class="line-added"> 5727             else</span>
<span class="line-added"> 5728               GST_WARNING_OBJECT (stream-&gt;pad,</span>
<span class="line-added"> 5729                   &quot;Got multiple [cdat] atoms in a c608 sample. This is unsupported for now. Please file a bug&quot;);</span>
<span class="line-added"> 5730           } else {</span>
<span class="line-added"> 5731             if (cdt2 == NULL)</span>
<span class="line-added"> 5732               cdt2 =</span>
<span class="line-added"> 5733                   convert_to_s334_1a (data + atom_length + 8,</span>
<span class="line-added"> 5734                   new_atom_length - 8, 2, &amp;cdt2_size);</span>
<span class="line-added"> 5735             else</span>
<span class="line-added"> 5736               GST_WARNING_OBJECT (stream-&gt;pad,</span>
<span class="line-added"> 5737                   &quot;Got multiple [cdt2] atoms in a c608 sample. This is unsupported for now. Please file a bug&quot;);</span>
<span class="line-added"> 5738           }</span>
<span class="line-added"> 5739         }</span>
<span class="line-added"> 5740       }</span>
<span class="line-added"> 5741 </span>
<span class="line-added"> 5742       *cclen = cdat_size + cdt2_size;</span>
<span class="line-added"> 5743       res = g_malloc (*cclen);</span>
<span class="line-added"> 5744       if (cdat_size)</span>
<span class="line-added"> 5745         memcpy (res, cdat, cdat_size);</span>
<span class="line-added"> 5746       if (cdt2_size)</span>
<span class="line-added"> 5747         memcpy (res + cdat_size, cdt2, cdt2_size);</span>
<span class="line-added"> 5748       g_free (cdat);</span>
<span class="line-added"> 5749       g_free (cdt2);</span>
<span class="line-added"> 5750     }</span>
<span class="line-added"> 5751       break;</span>
<span class="line-added"> 5752     case FOURCC_c708:</span>
<span class="line-added"> 5753       if (fourcc != FOURCC_ccdp) {</span>
<span class="line-added"> 5754         GST_WARNING_OBJECT (stream-&gt;pad,</span>
<span class="line-added"> 5755             &quot;Unknown data atom (%&quot; GST_FOURCC_FORMAT &quot;) for CEA708&quot;,</span>
<span class="line-added"> 5756             GST_FOURCC_ARGS (fourcc));</span>
<span class="line-added"> 5757         goto invalid_cdat;</span>
<span class="line-added"> 5758       }</span>
<span class="line-added"> 5759       *cclen = atom_length - 8;</span>
<span class="line-added"> 5760       res = g_memdup (data + 8, *cclen);</span>
<span class="line-added"> 5761       break;</span>
<span class="line-added"> 5762     default:</span>
<span class="line-added"> 5763       /* Keep this here in case other closed caption formats are added */</span>
<span class="line-added"> 5764       g_assert_not_reached ();</span>
<span class="line-added"> 5765       break;</span>
<span class="line-added"> 5766   }</span>
<span class="line-added"> 5767 </span>
<span class="line-added"> 5768   GST_MEMDUMP (&quot;Output&quot;, res, *cclen);</span>
<span class="line-added"> 5769   return res;</span>
<span class="line-added"> 5770 </span>
<span class="line-added"> 5771   /* Errors */</span>
<span class="line-added"> 5772 invalid_cdat:</span>
<span class="line-added"> 5773   GST_WARNING (&quot;[cdat] atom is too small or invalid&quot;);</span>
<span class="line-added"> 5774   return NULL;</span>
<span class="line-added"> 5775 }</span>
<span class="line-added"> 5776 </span>
 5777 /* the input buffer metadata must be writable,
 5778  * but time/duration etc not yet set and need not be preserved */
 5779 static GstBuffer *
 5780 gst_qtdemux_process_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,
 5781     GstBuffer * buf)
 5782 {
 5783   GstMapInfo map;
 5784   guint nsize = 0;
 5785   gchar *str;
 5786 
 5787   /* not many cases for now */
 5788   if (G_UNLIKELY (CUR_STREAM (stream)-&gt;fourcc == FOURCC_mp4s)) {
 5789     /* send a one time dvd clut event */
 5790     if (stream-&gt;pending_event &amp;&amp; stream-&gt;pad)
 5791       gst_pad_push_event (stream-&gt;pad, stream-&gt;pending_event);
 5792     stream-&gt;pending_event = NULL;
 5793   }
 5794 
 5795   if (G_UNLIKELY (stream-&gt;subtype != FOURCC_text
 5796           &amp;&amp; stream-&gt;subtype != FOURCC_sbtl &amp;&amp;
<a name="187" id="anc187"></a><span class="line-modified"> 5797           stream-&gt;subtype != FOURCC_subp &amp;&amp; stream-&gt;subtype != FOURCC_clcp)) {</span>
 5798     return buf;
 5799   }
 5800 
 5801   gst_buffer_map (buf, &amp;map, GST_MAP_READ);
 5802 
 5803   /* empty buffer is sent to terminate previous subtitle */
 5804   if (map.size &lt;= 2) {
 5805     gst_buffer_unmap (buf, &amp;map);
 5806     gst_buffer_unref (buf);
 5807     return NULL;
 5808   }
 5809   if (stream-&gt;subtype == FOURCC_subp) {
 5810     /* That&#39;s all the processing needed for subpictures */
 5811     gst_buffer_unmap (buf, &amp;map);
 5812     return buf;
 5813   }
 5814 
<a name="188" id="anc188"></a><span class="line-added"> 5815   if (stream-&gt;subtype == FOURCC_clcp) {</span>
<span class="line-added"> 5816     guint8 *cc;</span>
<span class="line-added"> 5817     gsize cclen = 0;</span>
<span class="line-added"> 5818     /* For closed caption, we need to extract the information from the</span>
<span class="line-added"> 5819      * [cdat],[cdt2] or [ccdp] atom */</span>
<span class="line-added"> 5820     cc = extract_cc_from_data (stream, map.data, map.size, &amp;cclen);</span>
<span class="line-added"> 5821     gst_buffer_unmap (buf, &amp;map);</span>
<span class="line-added"> 5822     gst_buffer_unref (buf);</span>
<span class="line-added"> 5823     if (cc) {</span>
<span class="line-added"> 5824       buf = _gst_buffer_new_wrapped (cc, cclen, g_free);</span>
<span class="line-added"> 5825     } else {</span>
<span class="line-added"> 5826       /* Conversion failed or there&#39;s nothing */</span>
<span class="line-added"> 5827       buf = NULL;</span>
<span class="line-added"> 5828     }</span>
<span class="line-added"> 5829     return buf;</span>
<span class="line-added"> 5830   }</span>
<span class="line-added"> 5831 </span>
 5832   nsize = GST_READ_UINT16_BE (map.data);
 5833   nsize = MIN (nsize, map.size - 2);
 5834 
 5835   GST_LOG_OBJECT (qtdemux, &quot;3GPP timed text subtitle: %d/%&quot; G_GSIZE_FORMAT &quot;&quot;,
 5836       nsize, map.size);
 5837 
 5838   /* takes care of UTF-8 validation or UTF-16 recognition,
 5839    * no other encoding expected */
 5840   str = gst_tag_freeform_string_to_utf8 ((gchar *) map.data + 2, nsize, NULL);
 5841   gst_buffer_unmap (buf, &amp;map);
 5842   if (str) {
 5843     gst_buffer_unref (buf);
 5844     buf = _gst_buffer_new_wrapped (str, strlen (str), g_free);
 5845   } else {
 5846     /* this should not really happen unless the subtitle is corrupted */
 5847     gst_buffer_unref (buf);
 5848     buf = NULL;
 5849   }
 5850 
 5851   /* FIXME ? convert optional subsequent style info to markup */
 5852 
 5853   return buf;
 5854 }
 5855 
<a name="189" id="anc189"></a><span class="line-added"> 5856 static GstFlowReturn</span>
<span class="line-added"> 5857 gst_qtdemux_push_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,</span>
<span class="line-added"> 5858     GstBuffer * buf)</span>
<span class="line-added"> 5859 {</span>
<span class="line-added"> 5860   GstFlowReturn ret = GST_FLOW_OK;</span>
<span class="line-added"> 5861   GstClockTime pts, duration;</span>
<span class="line-added"> 5862 </span>
<span class="line-added"> 5863   if (stream-&gt;need_clip)</span>
<span class="line-added"> 5864     buf = gst_qtdemux_clip_buffer (qtdemux, stream, buf);</span>
<span class="line-added"> 5865 </span>
<span class="line-added"> 5866   if (G_UNLIKELY (buf == NULL))</span>
<span class="line-added"> 5867     goto exit;</span>
<span class="line-added"> 5868 </span>
<span class="line-added"> 5869   if (G_UNLIKELY (stream-&gt;discont)) {</span>
<span class="line-added"> 5870     GST_LOG_OBJECT (qtdemux, &quot;marking discont buffer&quot;);</span>
<span class="line-added"> 5871     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);</span>
<span class="line-added"> 5872     stream-&gt;discont = FALSE;</span>
<span class="line-added"> 5873   } else {</span>
<span class="line-added"> 5874     GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DISCONT);</span>
<span class="line-added"> 5875   }</span>
<span class="line-added"> 5876 </span>
<span class="line-added"> 5877   GST_LOG_OBJECT (qtdemux,</span>
<span class="line-added"> 5878       &quot;Pushing buffer with dts %&quot; GST_TIME_FORMAT &quot;, pts %&quot; GST_TIME_FORMAT</span>
<span class="line-added"> 5879       &quot;, duration %&quot; GST_TIME_FORMAT &quot; on pad %s&quot;,</span>
<span class="line-added"> 5880       GST_TIME_ARGS (GST_BUFFER_DTS (buf)),</span>
<span class="line-added"> 5881       GST_TIME_ARGS (GST_BUFFER_PTS (buf)),</span>
<span class="line-added"> 5882       GST_TIME_ARGS (GST_BUFFER_DURATION (buf)), GST_PAD_NAME (stream-&gt;pad));</span>
<span class="line-added"> 5883 </span>
<span class="line-added"> 5884   if (stream-&gt;protected &amp;&amp; stream-&gt;protection_scheme_type == FOURCC_cenc) {</span>
<span class="line-added"> 5885     GstStructure *crypto_info;</span>
<span class="line-added"> 5886     QtDemuxCencSampleSetInfo *info =</span>
<span class="line-added"> 5887         (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;</span>
<span class="line-added"> 5888     gint index;</span>
<span class="line-added"> 5889     GstEvent *event;</span>
<span class="line-added"> 5890 </span>
<span class="line-added"> 5891     while ((event = g_queue_pop_head (&amp;stream-&gt;protection_scheme_event_queue))) {</span>
<span class="line-added"> 5892       GST_TRACE_OBJECT (stream-&gt;pad, &quot;pushing protection event: %&quot;</span>
<span class="line-added"> 5893           GST_PTR_FORMAT, event);</span>
<span class="line-added"> 5894       gst_pad_push_event (stream-&gt;pad, event);</span>
<span class="line-added"> 5895     }</span>
<span class="line-added"> 5896 </span>
<span class="line-added"> 5897     if (info-&gt;crypto_info == NULL) {</span>
<span class="line-added"> 5898       GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-added"> 5899           &quot;cenc metadata hasn&#39;t been parsed yet, pushing buffer as if it wasn&#39;t encrypted&quot;);</span>
<span class="line-added"> 5900     } else {</span>
<span class="line-added"> 5901       /* The end of the crypto_info array matches our n_samples position,</span>
<span class="line-added"> 5902        * so count backward from there */</span>
<span class="line-added"> 5903       index = stream-&gt;sample_index - stream-&gt;n_samples + info-&gt;crypto_info-&gt;len;</span>
<span class="line-added"> 5904       if (G_LIKELY (index &gt;= 0 &amp;&amp; index &lt; info-&gt;crypto_info-&gt;len)) {</span>
<span class="line-added"> 5905         /* steal structure from array */</span>
<span class="line-added"> 5906         crypto_info = g_ptr_array_index (info-&gt;crypto_info, index);</span>
<span class="line-added"> 5907         g_ptr_array_index (info-&gt;crypto_info, index) = NULL;</span>
<span class="line-added"> 5908         GST_LOG_OBJECT (qtdemux, &quot;attaching cenc metadata [%u/%u]&quot;, index,</span>
<span class="line-added"> 5909             info-&gt;crypto_info-&gt;len);</span>
<span class="line-added"> 5910         if (!crypto_info || !gst_buffer_add_protection_meta (buf, crypto_info))</span>
<span class="line-added"> 5911           GST_ERROR_OBJECT (qtdemux,</span>
<span class="line-added"> 5912               &quot;failed to attach cenc metadata to buffer&quot;);</span>
<span class="line-added"> 5913       } else {</span>
<span class="line-added"> 5914         GST_INFO_OBJECT (qtdemux, &quot;No crypto info with index %d and sample %d&quot;,</span>
<span class="line-added"> 5915             index, stream-&gt;sample_index);</span>
<span class="line-added"> 5916       }</span>
<span class="line-added"> 5917     }</span>
<span class="line-added"> 5918   }</span>
<span class="line-added"> 5919 </span>
<span class="line-added"> 5920   if (stream-&gt;alignment &gt; 1)</span>
<span class="line-added"> 5921     buf = gst_qtdemux_align_buffer (qtdemux, buf, stream-&gt;alignment);</span>
<span class="line-added"> 5922 </span>
<span class="line-added"> 5923   pts = GST_BUFFER_PTS (buf);</span>
<span class="line-added"> 5924   duration = GST_BUFFER_DURATION (buf);</span>
<span class="line-added"> 5925 </span>
<span class="line-added"> 5926   ret = gst_pad_push (stream-&gt;pad, buf);</span>
<span class="line-added"> 5927 </span>
<span class="line-added"> 5928   if (GST_CLOCK_TIME_IS_VALID (pts) &amp;&amp; GST_CLOCK_TIME_IS_VALID (duration)) {</span>
<span class="line-added"> 5929     /* mark position in stream, we&#39;ll need this to know when to send GAP event */</span>
<span class="line-added"> 5930     stream-&gt;segment.position = pts + duration;</span>
<span class="line-added"> 5931   }</span>
<span class="line-added"> 5932 </span>
<span class="line-added"> 5933 exit:</span>
<span class="line-added"> 5934 </span>
<span class="line-added"> 5935   return ret;</span>
<span class="line-added"> 5936 }</span>
<span class="line-added"> 5937 </span>
<span class="line-added"> 5938 static GstFlowReturn</span>
<span class="line-added"> 5939 gst_qtdemux_split_and_push_buffer (GstQTDemux * qtdemux, QtDemuxStream * stream,</span>
<span class="line-added"> 5940     GstBuffer * buf)</span>
<span class="line-added"> 5941 {</span>
<span class="line-added"> 5942   GstFlowReturn ret = GST_FLOW_OK;</span>
<span class="line-added"> 5943 </span>
<span class="line-added"> 5944   if (stream-&gt;subtype == FOURCC_clcp</span>
<span class="line-added"> 5945       &amp;&amp; CUR_STREAM (stream)-&gt;fourcc == FOURCC_c608 &amp;&amp; stream-&gt;need_split) {</span>
<span class="line-added"> 5946     GstMapInfo map;</span>
<span class="line-added"> 5947     guint n_output_buffers, n_field1 = 0, n_field2 = 0;</span>
<span class="line-added"> 5948     guint n_triplets, i;</span>
<span class="line-added"> 5949     guint field1_off = 0, field2_off = 0;</span>
<span class="line-added"> 5950 </span>
<span class="line-added"> 5951     /* We have to split CEA608 buffers so that each outgoing buffer contains</span>
<span class="line-added"> 5952      * one byte pair per field according to the framerate of the video track.</span>
<span class="line-added"> 5953      *</span>
<span class="line-added"> 5954      * If there is only a single byte pair per field we don&#39;t have to do</span>
<span class="line-added"> 5955      * anything</span>
<span class="line-added"> 5956      */</span>
<span class="line-added"> 5957 </span>
<span class="line-added"> 5958     gst_buffer_map (buf, &amp;map, GST_MAP_READ);</span>
<span class="line-added"> 5959 </span>
<span class="line-added"> 5960     n_triplets = map.size / 3;</span>
<span class="line-added"> 5961     for (i = 0; i &lt; n_triplets; i++) {</span>
<span class="line-added"> 5962       if (map.data[3 * i] &amp; 0x80)</span>
<span class="line-added"> 5963         n_field1++;</span>
<span class="line-added"> 5964       else</span>
<span class="line-added"> 5965         n_field2++;</span>
<span class="line-added"> 5966     }</span>
<span class="line-added"> 5967 </span>
<span class="line-added"> 5968     g_assert (n_field1 || n_field2);</span>
<span class="line-added"> 5969 </span>
<span class="line-added"> 5970     /* If there&#39;s more than 1 frame we have to split, otherwise we can just</span>
<span class="line-added"> 5971      * pass through */</span>
<span class="line-added"> 5972     if (n_field1 &gt; 1 || n_field2 &gt; 1) {</span>
<span class="line-added"> 5973       n_output_buffers =</span>
<span class="line-added"> 5974           gst_util_uint64_scale (GST_BUFFER_DURATION (buf),</span>
<span class="line-added"> 5975           CUR_STREAM (stream)-&gt;fps_n, GST_SECOND * CUR_STREAM (stream)-&gt;fps_d);</span>
<span class="line-added"> 5976 </span>
<span class="line-added"> 5977       for (i = 0; i &lt; n_output_buffers; i++) {</span>
<span class="line-added"> 5978         GstBuffer *outbuf =</span>
<span class="line-added"> 5979             gst_buffer_new_and_alloc ((n_field1 ? 3 : 0) + (n_field2 ? 3 : 0));</span>
<span class="line-added"> 5980         GstMapInfo outmap;</span>
<span class="line-added"> 5981         guint8 *outptr;</span>
<span class="line-added"> 5982 </span>
<span class="line-added"> 5983         gst_buffer_map (outbuf, &amp;outmap, GST_MAP_WRITE);</span>
<span class="line-added"> 5984         outptr = outmap.data;</span>
<span class="line-added"> 5985 </span>
<span class="line-added"> 5986         if (n_field1) {</span>
<span class="line-added"> 5987           gboolean found = FALSE;</span>
<span class="line-added"> 5988 </span>
<span class="line-added"> 5989           while (map.data + field1_off &lt; map.data + map.size) {</span>
<span class="line-added"> 5990             if (map.data[field1_off] &amp; 0x80) {</span>
<span class="line-added"> 5991               memcpy (outptr, &amp;map.data[field1_off], 3);</span>
<span class="line-added"> 5992               field1_off += 3;</span>
<span class="line-added"> 5993               found = TRUE;</span>
<span class="line-added"> 5994               break;</span>
<span class="line-added"> 5995             }</span>
<span class="line-added"> 5996             field1_off += 3;</span>
<span class="line-added"> 5997           }</span>
<span class="line-added"> 5998 </span>
<span class="line-added"> 5999           if (!found) {</span>
<span class="line-added"> 6000             const guint8 empty[] = { 0x80, 0x80, 0x80 };</span>
<span class="line-added"> 6001 </span>
<span class="line-added"> 6002             memcpy (outptr, empty, 3);</span>
<span class="line-added"> 6003           }</span>
<span class="line-added"> 6004 </span>
<span class="line-added"> 6005           outptr += 3;</span>
<span class="line-added"> 6006         }</span>
<span class="line-added"> 6007 </span>
<span class="line-added"> 6008         if (n_field2) {</span>
<span class="line-added"> 6009           gboolean found = FALSE;</span>
<span class="line-added"> 6010 </span>
<span class="line-added"> 6011           while (map.data + field2_off &lt; map.data + map.size) {</span>
<span class="line-added"> 6012             if ((map.data[field2_off] &amp; 0x80) == 0) {</span>
<span class="line-added"> 6013               memcpy (outptr, &amp;map.data[field2_off], 3);</span>
<span class="line-added"> 6014               field2_off += 3;</span>
<span class="line-added"> 6015               found = TRUE;</span>
<span class="line-added"> 6016               break;</span>
<span class="line-added"> 6017             }</span>
<span class="line-added"> 6018             field2_off += 3;</span>
<span class="line-added"> 6019           }</span>
<span class="line-added"> 6020 </span>
<span class="line-added"> 6021           if (!found) {</span>
<span class="line-added"> 6022             const guint8 empty[] = { 0x00, 0x80, 0x80 };</span>
<span class="line-added"> 6023 </span>
<span class="line-added"> 6024             memcpy (outptr, empty, 3);</span>
<span class="line-added"> 6025           }</span>
<span class="line-added"> 6026 </span>
<span class="line-added"> 6027           outptr += 3;</span>
<span class="line-added"> 6028         }</span>
<span class="line-added"> 6029 </span>
<span class="line-added"> 6030         gst_buffer_unmap (outbuf, &amp;outmap);</span>
<span class="line-added"> 6031 </span>
<span class="line-added"> 6032         GST_BUFFER_PTS (outbuf) =</span>
<span class="line-added"> 6033             GST_BUFFER_PTS (buf) + gst_util_uint64_scale (i,</span>
<span class="line-added"> 6034             GST_SECOND * CUR_STREAM (stream)-&gt;fps_d,</span>
<span class="line-added"> 6035             CUR_STREAM (stream)-&gt;fps_n);</span>
<span class="line-added"> 6036         GST_BUFFER_DURATION (outbuf) =</span>
<span class="line-added"> 6037             gst_util_uint64_scale (GST_SECOND, CUR_STREAM (stream)-&gt;fps_d,</span>
<span class="line-added"> 6038             CUR_STREAM (stream)-&gt;fps_n);</span>
<span class="line-added"> 6039         GST_BUFFER_OFFSET (outbuf) = -1;</span>
<span class="line-added"> 6040         GST_BUFFER_OFFSET_END (outbuf) = -1;</span>
<span class="line-added"> 6041 </span>
<span class="line-added"> 6042         ret = gst_qtdemux_push_buffer (qtdemux, stream, outbuf);</span>
<span class="line-added"> 6043 </span>
<span class="line-added"> 6044         if (ret != GST_FLOW_OK &amp;&amp; ret != GST_FLOW_NOT_LINKED)</span>
<span class="line-added"> 6045           break;</span>
<span class="line-added"> 6046       }</span>
<span class="line-added"> 6047       gst_buffer_unmap (buf, &amp;map);</span>
<span class="line-added"> 6048       gst_buffer_unref (buf);</span>
<span class="line-added"> 6049     } else {</span>
<span class="line-added"> 6050       gst_buffer_unmap (buf, &amp;map);</span>
<span class="line-added"> 6051       ret = gst_qtdemux_push_buffer (qtdemux, stream, buf);</span>
<span class="line-added"> 6052     }</span>
<span class="line-added"> 6053   } else {</span>
<span class="line-added"> 6054     ret = gst_qtdemux_push_buffer (qtdemux, stream, buf);</span>
<span class="line-added"> 6055   }</span>
<span class="line-added"> 6056 </span>
<span class="line-added"> 6057   return ret;</span>
<span class="line-added"> 6058 }</span>
<span class="line-added"> 6059 </span>
 6060 /* Sets a buffer&#39;s attributes properly and pushes it downstream.
 6061  * Also checks for additional actions and custom processing that may
 6062  * need to be done first.
 6063  */
 6064 static GstFlowReturn
 6065 gst_qtdemux_decorate_and_push_buffer (GstQTDemux * qtdemux,
 6066     QtDemuxStream * stream, GstBuffer * buf,
 6067     GstClockTime dts, GstClockTime pts, GstClockTime duration,
 6068     gboolean keyframe, GstClockTime position, guint64 byte_position)
 6069 {
 6070   GstFlowReturn ret = GST_FLOW_OK;
 6071 
 6072   /* offset the timestamps according to the edit list */
 6073 
 6074   if (G_UNLIKELY (CUR_STREAM (stream)-&gt;fourcc == FOURCC_rtsp)) {
 6075     gchar *url;
 6076     GstMapInfo map;
 6077 
 6078     gst_buffer_map (buf, &amp;map, GST_MAP_READ);
 6079     url = g_strndup ((gchar *) map.data, map.size);
 6080     gst_buffer_unmap (buf, &amp;map);
 6081     if (url != NULL &amp;&amp; strlen (url) != 0) {
 6082       /* we have RTSP redirect now */
 6083       gst_element_post_message (GST_ELEMENT_CAST (qtdemux),
 6084           gst_message_new_element (GST_OBJECT_CAST (qtdemux),
 6085               gst_structure_new (&quot;redirect&quot;,
 6086                   &quot;new-location&quot;, G_TYPE_STRING, url, NULL)));
 6087       qtdemux-&gt;posted_redirect = TRUE;
 6088     } else {
 6089       GST_WARNING_OBJECT (qtdemux, &quot;Redirect URI of stream is empty, not &quot;
 6090           &quot;posting&quot;);
 6091     }
 6092     g_free (url);
 6093   }
 6094 
 6095   /* position reporting */
 6096   if (qtdemux-&gt;segment.rate &gt;= 0) {
 6097     qtdemux-&gt;segment.position = position;
 6098     gst_qtdemux_sync_streams (qtdemux);
 6099   }
 6100 
 6101   if (G_UNLIKELY (!stream-&gt;pad)) {
 6102     GST_DEBUG_OBJECT (qtdemux, &quot;No output pad for stream, ignoring&quot;);
 6103     gst_buffer_unref (buf);
 6104     goto exit;
 6105   }
 6106 
 6107   /* send out pending buffers */
 6108   while (stream-&gt;buffers) {
 6109     GstBuffer *buffer = (GstBuffer *) stream-&gt;buffers-&gt;data;
 6110 
 6111     if (G_UNLIKELY (stream-&gt;discont)) {
 6112       GST_LOG_OBJECT (qtdemux, &quot;marking discont buffer&quot;);
 6113       GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);
 6114       stream-&gt;discont = FALSE;
 6115     } else {
 6116       GST_BUFFER_FLAG_UNSET (buf, GST_BUFFER_FLAG_DISCONT);
 6117     }
 6118 
 6119     if (stream-&gt;alignment &gt; 1)
 6120       buffer = gst_qtdemux_align_buffer (qtdemux, buffer, stream-&gt;alignment);
 6121     gst_pad_push (stream-&gt;pad, buffer);
 6122 
 6123     stream-&gt;buffers = g_slist_delete_link (stream-&gt;buffers, stream-&gt;buffers);
 6124   }
 6125 
 6126   /* we&#39;re going to modify the metadata */
 6127   buf = gst_buffer_make_writable (buf);
 6128 
 6129   if (G_UNLIKELY (stream-&gt;need_process))
 6130     buf = gst_qtdemux_process_buffer (qtdemux, stream, buf);
 6131 
 6132   if (!buf) {
 6133     goto exit;
 6134   }
 6135 
 6136   GST_BUFFER_DTS (buf) = dts;
 6137   GST_BUFFER_PTS (buf) = pts;
 6138   GST_BUFFER_DURATION (buf) = duration;
 6139   GST_BUFFER_OFFSET (buf) = -1;
 6140   GST_BUFFER_OFFSET_END (buf) = -1;
 6141 
<a name="190" id="anc190"></a><span class="line-added"> 6142   if (!keyframe) {</span>
<span class="line-added"> 6143     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DELTA_UNIT);</span>
<span class="line-added"> 6144     stream-&gt;on_keyframe = FALSE;</span>
<span class="line-added"> 6145   } else {</span>
<span class="line-added"> 6146     stream-&gt;on_keyframe = TRUE;</span>
<span class="line-added"> 6147   }</span>
<span class="line-added"> 6148 </span>
 6149   if (G_UNLIKELY (CUR_STREAM (stream)-&gt;rgb8_palette))
 6150     gst_buffer_append_memory (buf,
 6151         gst_memory_ref (CUR_STREAM (stream)-&gt;rgb8_palette));
 6152 
 6153   if (G_UNLIKELY (CUR_STREAM (stream)-&gt;padding)) {
 6154     gst_buffer_resize (buf, CUR_STREAM (stream)-&gt;padding, -1);
 6155   }
 6156 #if 0
 6157   if (G_UNLIKELY (qtdemux-&gt;element_index)) {
 6158     GstClockTime stream_time;
 6159 
 6160     stream_time =
 6161         gst_segment_to_stream_time (&amp;stream-&gt;segment, GST_FORMAT_TIME,
 6162         timestamp);
 6163     if (GST_CLOCK_TIME_IS_VALID (stream_time)) {
 6164       GST_LOG_OBJECT (qtdemux,
 6165           &quot;adding association %&quot; GST_TIME_FORMAT &quot;-&gt; %&quot;
 6166           G_GUINT64_FORMAT, GST_TIME_ARGS (stream_time), byte_position);
 6167       gst_index_add_association (qtdemux-&gt;element_index,
 6168           qtdemux-&gt;index_id,
 6169           keyframe ? GST_ASSOCIATION_FLAG_KEY_UNIT :
 6170           GST_ASSOCIATION_FLAG_DELTA_UNIT, GST_FORMAT_TIME, stream_time,
 6171           GST_FORMAT_BYTES, byte_position, NULL);
 6172     }
 6173   }
 6174 #endif
 6175 
<a name="191" id="anc191"></a><span class="line-modified"> 6176   ret = gst_qtdemux_split_and_push_buffer (qtdemux, stream, buf);</span>






































































 6177 
 6178 exit:
 6179   return ret;
 6180 }
 6181 
 6182 static const QtDemuxRandomAccessEntry *
 6183 gst_qtdemux_stream_seek_fragment (GstQTDemux * qtdemux, QtDemuxStream * stream,
 6184     GstClockTime pos, gboolean after)
 6185 {
 6186   QtDemuxRandomAccessEntry *entries = stream-&gt;ra_entries;
 6187   guint n_entries = stream-&gt;n_ra_entries;
 6188   guint i;
 6189 
 6190   /* we assume the table is sorted */
 6191   for (i = 0; i &lt; n_entries; ++i) {
 6192     if (entries[i].ts &gt; pos)
 6193       break;
 6194   }
 6195 
 6196   /* FIXME: maybe save first moof_offset somewhere instead, but for now it&#39;s
 6197    * probably okay to assume that the index lists the very first fragment */
 6198   if (i == 0)
 6199     return &amp;entries[0];
 6200 
 6201   if (after)
 6202     return &amp;entries[i];
 6203   else
 6204     return &amp;entries[i - 1];
 6205 }
 6206 
 6207 static gboolean
 6208 gst_qtdemux_do_fragmented_seek (GstQTDemux * qtdemux)
 6209 {
 6210   const QtDemuxRandomAccessEntry *best_entry = NULL;
<a name="192" id="anc192"></a><span class="line-modified"> 6211   gint i;</span>
 6212 
 6213   GST_OBJECT_LOCK (qtdemux);
 6214 
<a name="193" id="anc193"></a><span class="line-modified"> 6215   g_assert (QTDEMUX_N_STREAMS (qtdemux) &gt; 0);</span>
 6216 
 6217   /* first see if we can determine where to go to using mfra,
 6218    * before we start clearing things */
<a name="194" id="anc194"></a><span class="line-modified"> 6219   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
 6220     const QtDemuxRandomAccessEntry *entry;
 6221     QtDemuxStream *stream;
 6222     gboolean is_audio_or_video;
 6223 
<a name="195" id="anc195"></a><span class="line-modified"> 6224     stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 6225 
 6226     if (stream-&gt;ra_entries == NULL)
 6227       continue;
 6228 
 6229     if (stream-&gt;subtype == FOURCC_vide || stream-&gt;subtype == FOURCC_soun)
 6230       is_audio_or_video = TRUE;
 6231     else
 6232       is_audio_or_video = FALSE;
 6233 
 6234     entry =
 6235         gst_qtdemux_stream_seek_fragment (qtdemux, stream,
 6236         stream-&gt;time_position, !is_audio_or_video);
 6237 
 6238     GST_INFO_OBJECT (stream-&gt;pad, &quot;%&quot; GST_TIME_FORMAT &quot; at offset &quot;
 6239         &quot;%&quot; G_GUINT64_FORMAT, GST_TIME_ARGS (entry-&gt;ts), entry-&gt;moof_offset);
 6240 
 6241     stream-&gt;pending_seek = entry;
 6242 
 6243     /* decide position to jump to just based on audio/video tracks, not subs */
 6244     if (!is_audio_or_video)
 6245       continue;
 6246 
 6247     if (best_entry == NULL || entry-&gt;moof_offset &lt; best_entry-&gt;moof_offset)
 6248       best_entry = entry;
 6249   }
 6250 
 6251   /* no luck, will handle seek otherwise */
 6252   if (best_entry == NULL) {
 6253     GST_OBJECT_UNLOCK (qtdemux);
 6254     return FALSE;
 6255   }
 6256 
 6257   /* ok, now we can prepare for processing as of located moof */
<a name="196" id="anc196"></a><span class="line-modified"> 6258   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
 6259     QtDemuxStream *stream;
 6260 
<a name="197" id="anc197"></a><span class="line-modified"> 6261     stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 6262 
 6263     g_free (stream-&gt;samples);
 6264     stream-&gt;samples = NULL;
 6265     stream-&gt;n_samples = 0;
 6266     stream-&gt;stbl_index = -1;    /* no samples have yet been parsed */
 6267     stream-&gt;sample_index = -1;
 6268 
 6269     if (stream-&gt;protection_scheme_info) {
 6270       /* Clear out any old cenc crypto info entries as we&#39;ll move to a new moof */
 6271       if (stream-&gt;protection_scheme_type == FOURCC_cenc) {
 6272         QtDemuxCencSampleSetInfo *info =
 6273             (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;
 6274         if (info-&gt;crypto_info) {
 6275           g_ptr_array_free (info-&gt;crypto_info, TRUE);
 6276           info-&gt;crypto_info = NULL;
 6277         }
 6278       }
 6279     }
 6280   }
 6281 
 6282   GST_INFO_OBJECT (qtdemux, &quot;seek to %&quot; GST_TIME_FORMAT &quot;, best fragment &quot;
 6283       &quot;moof offset: %&quot; G_GUINT64_FORMAT &quot;, ts %&quot; GST_TIME_FORMAT,
<a name="198" id="anc198"></a><span class="line-modified"> 6284       GST_TIME_ARGS (QTDEMUX_NTH_STREAM (qtdemux, 0)-&gt;time_position),</span>
 6285       best_entry-&gt;moof_offset, GST_TIME_ARGS (best_entry-&gt;ts));
 6286 
 6287   qtdemux-&gt;moof_offset = best_entry-&gt;moof_offset;
 6288 
 6289   qtdemux_add_fragmented_samples (qtdemux);
 6290 
 6291   GST_OBJECT_UNLOCK (qtdemux);
 6292   return TRUE;
 6293 }
 6294 
 6295 static GstFlowReturn
 6296 gst_qtdemux_loop_state_movie (GstQTDemux * qtdemux)
 6297 {
 6298   GstFlowReturn ret = GST_FLOW_OK;
 6299   GstBuffer *buf = NULL;
<a name="199" id="anc199"></a><span class="line-modified"> 6300   QtDemuxStream *stream, *target_stream = NULL;</span>
 6301   GstClockTime min_time;
 6302   guint64 offset = 0;
 6303   GstClockTime dts = GST_CLOCK_TIME_NONE;
 6304   GstClockTime pts = GST_CLOCK_TIME_NONE;
 6305   GstClockTime duration = 0;
 6306   gboolean keyframe = FALSE;
 6307   guint sample_size = 0;
 6308   gboolean empty = 0;
 6309   guint size;
<a name="200" id="anc200"></a>
 6310   gint i;
 6311 
<a name="201" id="anc201"></a>

 6312   if (qtdemux-&gt;fragmented_seek_pending) {
 6313     GST_INFO_OBJECT (qtdemux, &quot;pending fragmented seek&quot;);
 6314     if (gst_qtdemux_do_fragmented_seek (qtdemux)) {
 6315       GST_INFO_OBJECT (qtdemux, &quot;fragmented seek done!&quot;);
 6316       qtdemux-&gt;fragmented_seek_pending = FALSE;
 6317     } else {
 6318       GST_INFO_OBJECT (qtdemux, &quot;fragmented seek still pending&quot;);
 6319     }
 6320   }
 6321 
 6322   /* Figure out the next stream sample to output, min_time is expressed in
 6323    * global time and runs over the edit list segments. */
 6324   min_time = G_MAXUINT64;
<a name="202" id="anc202"></a><span class="line-modified"> 6325   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>

 6326     GstClockTime position;
 6327 
<a name="203" id="anc203"></a><span class="line-modified"> 6328     stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 6329     position = stream-&gt;time_position;
 6330 
 6331     /* position of -1 is EOS */
 6332     if (position != GST_CLOCK_TIME_NONE &amp;&amp; position &lt; min_time) {
 6333       min_time = position;
<a name="204" id="anc204"></a><span class="line-modified"> 6334       target_stream = stream;</span>
 6335     }
 6336   }
 6337   /* all are EOS */
<a name="205" id="anc205"></a><span class="line-modified"> 6338   if (G_UNLIKELY (target_stream == NULL)) {</span>
 6339     GST_DEBUG_OBJECT (qtdemux, &quot;all streams are EOS&quot;);
 6340     goto eos;
 6341   }
 6342 
 6343   /* check for segment end */
 6344   if (G_UNLIKELY (qtdemux-&gt;segment.stop != -1
 6345           &amp;&amp; ((qtdemux-&gt;segment.rate &gt;= 0 &amp;&amp; qtdemux-&gt;segment.stop &lt;= min_time)
 6346               || (qtdemux-&gt;segment.rate &lt; 0
 6347                   &amp;&amp; qtdemux-&gt;segment.start &gt; min_time))
<a name="206" id="anc206"></a><span class="line-modified"> 6348           &amp;&amp; target_stream-&gt;on_keyframe)) {</span>
 6349     GST_DEBUG_OBJECT (qtdemux, &quot;we reached the end of our segment.&quot;);
<a name="207" id="anc207"></a><span class="line-modified"> 6350     target_stream-&gt;time_position = GST_CLOCK_TIME_NONE;</span>
 6351     goto eos_stream;
 6352   }
 6353 
 6354   /* gap events for subtitle streams */
<a name="208" id="anc208"></a><span class="line-modified"> 6355   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified"> 6356     stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
 6357     if (stream-&gt;pad &amp;&amp; (stream-&gt;subtype == FOURCC_subp
 6358             || stream-&gt;subtype == FOURCC_text
 6359             || stream-&gt;subtype == FOURCC_sbtl)) {
 6360       /* send one second gap events until the stream catches up */
 6361       /* gaps can only be sent after segment is activated (segment.stop is no longer -1) */
 6362       while (GST_CLOCK_TIME_IS_VALID (stream-&gt;segment.stop) &amp;&amp;
 6363           GST_CLOCK_TIME_IS_VALID (stream-&gt;segment.position) &amp;&amp;
 6364           stream-&gt;segment.position + GST_SECOND &lt; min_time) {
 6365         GstEvent *gap =
 6366             gst_event_new_gap (stream-&gt;segment.position, GST_SECOND);
 6367         gst_pad_push_event (stream-&gt;pad, gap);
 6368         stream-&gt;segment.position += GST_SECOND;
 6369       }
 6370     }
 6371   }
 6372 
<a name="209" id="anc209"></a><span class="line-modified"> 6373   stream = target_stream;</span>
 6374   /* fetch info for the current sample of this stream */
 6375   if (G_UNLIKELY (!gst_qtdemux_prepare_current_sample (qtdemux, stream, &amp;empty,
 6376               &amp;offset, &amp;sample_size, &amp;dts, &amp;pts, &amp;duration, &amp;keyframe)))
 6377     goto eos_stream;
 6378 
 6379   gst_qtdemux_stream_check_and_change_stsd_index (qtdemux, stream);
 6380   if (stream-&gt;new_caps) {
 6381     gst_qtdemux_configure_stream (qtdemux, stream);
<a name="210" id="anc210"></a><span class="line-modified"> 6382     qtdemux_do_allocation (stream, qtdemux);</span>
 6383   }
 6384 
 6385   /* If we&#39;re doing a keyframe-only trickmode, only push keyframes on video streams */
<a name="211" id="anc211"></a><span class="line-modified"> 6386   if (G_UNLIKELY (qtdemux-&gt;segment.</span>
<span class="line-modified"> 6387           flags &amp; GST_SEGMENT_FLAG_TRICKMODE_KEY_UNITS)) {</span>
 6388     if (stream-&gt;subtype == FOURCC_vide &amp;&amp; !keyframe) {
<a name="212" id="anc212"></a><span class="line-modified"> 6389       GST_LOG_OBJECT (qtdemux, &quot;Skipping non-keyframe on track-id %u&quot;,</span>
<span class="line-added"> 6390           stream-&gt;track_id);</span>
 6391       goto next;
 6392     }
 6393   }
 6394 
 6395   GST_DEBUG_OBJECT (qtdemux,
<a name="213" id="anc213"></a><span class="line-modified"> 6396       &quot;pushing from track-id %u, empty %d offset %&quot; G_GUINT64_FORMAT</span>
 6397       &quot;, size %d, dts=%&quot; GST_TIME_FORMAT &quot;, pts=%&quot; GST_TIME_FORMAT
<a name="214" id="anc214"></a><span class="line-modified"> 6398       &quot;, duration %&quot; GST_TIME_FORMAT, stream-&gt;track_id, empty, offset,</span>
<span class="line-modified"> 6399       sample_size, GST_TIME_ARGS (dts), GST_TIME_ARGS (pts),</span>
<span class="line-added"> 6400       GST_TIME_ARGS (duration));</span>
 6401 
 6402   if (G_UNLIKELY (empty)) {
 6403     /* empty segment, push a gap if there&#39;s a second or more
 6404      * difference and move to the next one */
 6405     if ((pts + duration - stream-&gt;segment.position) &gt;= GST_SECOND)
<a name="215" id="anc215"></a><span class="line-modified"> 6406       gst_pad_push_event (stream-&gt;pad, gst_event_new_gap (pts, duration));</span>
 6407     stream-&gt;segment.position = pts + duration;
 6408     goto next;
 6409   }
 6410 
 6411   /* hmm, empty sample, skip and move to next sample */
 6412   if (G_UNLIKELY (sample_size &lt;= 0))
 6413     goto next;
 6414 
 6415   /* last pushed sample was out of boundary, goto next sample */
 6416   if (G_UNLIKELY (GST_PAD_LAST_FLOW_RETURN (stream-&gt;pad) == GST_FLOW_EOS))
 6417     goto next;
 6418 
 6419   if (stream-&gt;max_buffer_size == 0 || sample_size &lt;= stream-&gt;max_buffer_size) {
 6420     size = sample_size;
 6421   } else {
 6422     GST_DEBUG_OBJECT (qtdemux,
 6423         &quot;size %d larger than stream max_buffer_size %d, trimming&quot;,
 6424         sample_size, stream-&gt;max_buffer_size);
 6425     size =
 6426         MIN (sample_size - stream-&gt;offset_in_sample, stream-&gt;max_buffer_size);
 6427   }
 6428 
 6429   if (qtdemux-&gt;cenc_aux_info_offset &gt; 0) {
 6430     GstMapInfo map;
 6431     GstByteReader br;
 6432     GstBuffer *aux_info = NULL;
 6433 
 6434     /* pull the data stored before the sample */
 6435     ret =
 6436         gst_qtdemux_pull_atom (qtdemux, qtdemux-&gt;offset,
 6437         offset + stream-&gt;offset_in_sample - qtdemux-&gt;offset, &amp;aux_info);
 6438     if (G_UNLIKELY (ret != GST_FLOW_OK))
 6439       goto beach;
 6440     gst_buffer_map (aux_info, &amp;map, GST_MAP_READ);
 6441     GST_DEBUG_OBJECT (qtdemux, &quot;parsing cenc auxiliary info&quot;);
 6442     gst_byte_reader_init (&amp;br, map.data + 8, map.size);
 6443     if (!qtdemux_parse_cenc_aux_info (qtdemux, stream, &amp;br,
 6444             qtdemux-&gt;cenc_aux_info_sizes, qtdemux-&gt;cenc_aux_sample_count)) {
 6445       GST_ERROR_OBJECT (qtdemux, &quot;failed to parse cenc auxiliary info&quot;);
 6446       gst_buffer_unmap (aux_info, &amp;map);
 6447       gst_buffer_unref (aux_info);
 6448       ret = GST_FLOW_ERROR;
 6449       goto beach;
 6450     }
 6451     gst_buffer_unmap (aux_info, &amp;map);
 6452     gst_buffer_unref (aux_info);
 6453   }
 6454 
 6455   GST_LOG_OBJECT (qtdemux, &quot;reading %d bytes @ %&quot; G_GUINT64_FORMAT, size,
 6456       offset);
 6457 
 6458   if (stream-&gt;use_allocator) {
 6459     /* if we have a per-stream allocator, use it */
 6460     buf = gst_buffer_new_allocate (stream-&gt;allocator, size, &amp;stream-&gt;params);
 6461   }
 6462 
 6463   ret = gst_qtdemux_pull_atom (qtdemux, offset + stream-&gt;offset_in_sample,
 6464       size, &amp;buf);
 6465   if (G_UNLIKELY (ret != GST_FLOW_OK))
 6466     goto beach;
 6467 
 6468   if (size != sample_size) {
 6469     pts += gst_util_uint64_scale_int (GST_SECOND,
 6470         stream-&gt;offset_in_sample / CUR_STREAM (stream)-&gt;bytes_per_frame,
 6471         stream-&gt;timescale);
 6472     dts +=
 6473         gst_util_uint64_scale_int (GST_SECOND,
 6474         stream-&gt;offset_in_sample / CUR_STREAM (stream)-&gt;bytes_per_frame,
 6475         stream-&gt;timescale);
 6476     duration =
 6477         gst_util_uint64_scale_int (GST_SECOND,
 6478         size / CUR_STREAM (stream)-&gt;bytes_per_frame, stream-&gt;timescale);
 6479   }
 6480 
 6481   ret = gst_qtdemux_decorate_and_push_buffer (qtdemux, stream, buf,
 6482       dts, pts, duration, keyframe, min_time, offset);
 6483 
 6484   if (size != sample_size) {
 6485     QtDemuxSample *sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
 6486     QtDemuxSegment *segment = &amp;stream-&gt;segments[stream-&gt;segment_index];
 6487 
 6488     GstClockTime time_position = QTSTREAMTIME_TO_GSTTIME (stream,
 6489         sample-&gt;timestamp +
 6490         stream-&gt;offset_in_sample / CUR_STREAM (stream)-&gt;bytes_per_frame);
 6491     if (time_position &gt;= segment-&gt;media_start) {
 6492       /* inside the segment, update time_position, looks very familiar to
 6493        * GStreamer segments, doesn&#39;t it? */
 6494       stream-&gt;time_position = (time_position - segment-&gt;media_start) +
 6495           segment-&gt;time;
 6496     } else {
 6497       /* not yet in segment, time does not yet increment. This means
 6498        * that we are still prerolling keyframes to the decoder so it can
 6499        * decode the first sample of the segment. */
 6500       stream-&gt;time_position = segment-&gt;time;
 6501     }
 6502   }
 6503 
 6504   /* combine flows */
 6505   ret = gst_qtdemux_combine_flows (qtdemux, stream, ret);
 6506   /* ignore unlinked, we will not push on the pad anymore and we will EOS when
 6507    * we have no more data for the pad to push */
 6508   if (ret == GST_FLOW_EOS)
 6509     ret = GST_FLOW_OK;
 6510 
 6511   stream-&gt;offset_in_sample += size;
 6512   if (stream-&gt;offset_in_sample &gt;= sample_size) {
 6513     gst_qtdemux_advance_sample (qtdemux, stream);
 6514   }
 6515   goto beach;
 6516 
 6517 next:
 6518   gst_qtdemux_advance_sample (qtdemux, stream);
 6519 
 6520 beach:
 6521   return ret;
 6522 
 6523   /* special cases */
 6524 eos:
 6525   {
 6526     GST_DEBUG_OBJECT (qtdemux, &quot;No samples left for any streams - EOS&quot;);
 6527     ret = GST_FLOW_EOS;
 6528     goto beach;
 6529   }
 6530 eos_stream:
 6531   {
 6532     GST_DEBUG_OBJECT (qtdemux, &quot;No samples left for stream&quot;);
 6533     /* EOS will be raised if all are EOS */
 6534     ret = GST_FLOW_OK;
 6535     goto beach;
 6536   }
 6537 }
 6538 
 6539 static void
 6540 gst_qtdemux_loop (GstPad * pad)
 6541 {
 6542   GstQTDemux *qtdemux;
 6543   guint64 cur_offset;
 6544   GstFlowReturn ret;
 6545 
 6546   qtdemux = GST_QTDEMUX (gst_pad_get_parent (pad));
 6547 
 6548   cur_offset = qtdemux-&gt;offset;
 6549   GST_LOG_OBJECT (qtdemux, &quot;loop at position %&quot; G_GUINT64_FORMAT &quot;, state %s&quot;,
 6550       cur_offset, qt_demux_state_string (qtdemux-&gt;state));
 6551 
 6552   switch (qtdemux-&gt;state) {
 6553     case QTDEMUX_STATE_INITIAL:
 6554     case QTDEMUX_STATE_HEADER:
 6555       ret = gst_qtdemux_loop_state_header (qtdemux);
 6556       break;
 6557     case QTDEMUX_STATE_MOVIE:
 6558       ret = gst_qtdemux_loop_state_movie (qtdemux);
 6559       if (qtdemux-&gt;segment.rate &lt; 0 &amp;&amp; ret == GST_FLOW_EOS) {
 6560         ret = gst_qtdemux_seek_to_previous_keyframe (qtdemux);
 6561       }
 6562       break;
 6563     default:
 6564       /* ouch */
 6565       goto invalid_state;
 6566   }
 6567 
 6568   /* if something went wrong, pause */
 6569   if (ret != GST_FLOW_OK)
 6570     goto pause;
 6571 
 6572 done:
 6573   gst_object_unref (qtdemux);
 6574   return;
 6575 
 6576   /* ERRORS */
 6577 invalid_state:
 6578   {
 6579     GST_ELEMENT_ERROR (qtdemux, STREAM, FAILED,
 6580         (NULL), (&quot;streaming stopped, invalid state&quot;));
 6581     gst_pad_pause_task (pad);
 6582     gst_qtdemux_push_event (qtdemux, gst_event_new_eos ());
 6583     goto done;
 6584   }
 6585 pause:
 6586   {
 6587     const gchar *reason = gst_flow_get_name (ret);
 6588 
 6589     GST_LOG_OBJECT (qtdemux, &quot;pausing task, reason %s&quot;, reason);
 6590 
 6591     gst_pad_pause_task (pad);
 6592 
 6593     /* fatal errors need special actions */
 6594     /* check EOS */
 6595     if (ret == GST_FLOW_EOS) {
<a name="216" id="anc216"></a><span class="line-modified"> 6596       if (QTDEMUX_N_STREAMS (qtdemux) == 0) {</span>
 6597         /* we have no streams, post an error */
 6598         gst_qtdemux_post_no_playable_stream_error (qtdemux);
 6599       }
 6600       if (qtdemux-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
 6601         gint64 stop;
 6602 
 6603         if ((stop = qtdemux-&gt;segment.stop) == -1)
 6604           stop = qtdemux-&gt;segment.duration;
 6605 
 6606         if (qtdemux-&gt;segment.rate &gt;= 0) {
 6607           GstMessage *message;
 6608           GstEvent *event;
 6609 
 6610           GST_LOG_OBJECT (qtdemux, &quot;Sending segment done, at end of segment&quot;);
 6611           message = gst_message_new_segment_done (GST_OBJECT_CAST (qtdemux),
 6612               GST_FORMAT_TIME, stop);
 6613           event = gst_event_new_segment_done (GST_FORMAT_TIME, stop);
 6614           if (qtdemux-&gt;segment_seqnum != GST_SEQNUM_INVALID) {
 6615             gst_message_set_seqnum (message, qtdemux-&gt;segment_seqnum);
 6616             gst_event_set_seqnum (event, qtdemux-&gt;segment_seqnum);
 6617           }
 6618           gst_element_post_message (GST_ELEMENT_CAST (qtdemux), message);
 6619           gst_qtdemux_push_event (qtdemux, event);
 6620         } else {
 6621           GstMessage *message;
 6622           GstEvent *event;
 6623 
 6624           /*  For Reverse Playback */
 6625           GST_LOG_OBJECT (qtdemux, &quot;Sending segment done, at start of segment&quot;);
 6626           message = gst_message_new_segment_done (GST_OBJECT_CAST (qtdemux),
 6627               GST_FORMAT_TIME, qtdemux-&gt;segment.start);
 6628           event = gst_event_new_segment_done (GST_FORMAT_TIME,
 6629               qtdemux-&gt;segment.start);
 6630           if (qtdemux-&gt;segment_seqnum != GST_SEQNUM_INVALID) {
 6631             gst_message_set_seqnum (message, qtdemux-&gt;segment_seqnum);
 6632             gst_event_set_seqnum (event, qtdemux-&gt;segment_seqnum);
<a name="217" id="anc217"></a><span class="line-modified"> 6633           }</span>
 6634           gst_element_post_message (GST_ELEMENT_CAST (qtdemux), message);
 6635           gst_qtdemux_push_event (qtdemux, event);
 6636         }
 6637       } else {
 6638         GstEvent *event;
 6639 
 6640         GST_LOG_OBJECT (qtdemux, &quot;Sending EOS at end of segment&quot;);
 6641         event = gst_event_new_eos ();
 6642         if (qtdemux-&gt;segment_seqnum != GST_SEQNUM_INVALID)
 6643           gst_event_set_seqnum (event, qtdemux-&gt;segment_seqnum);
 6644         gst_qtdemux_push_event (qtdemux, event);
 6645       }
 6646     } else if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS) {
 6647       GST_ELEMENT_FLOW_ERROR (qtdemux, ret);
 6648       gst_qtdemux_push_event (qtdemux, gst_event_new_eos ());
 6649     }
 6650     goto done;
 6651   }
 6652 }
 6653 
 6654 /*
 6655  * has_next_entry
 6656  *
 6657  * Returns if there are samples to be played.
 6658  */
 6659 static gboolean
 6660 has_next_entry (GstQTDemux * demux)
 6661 {
 6662   QtDemuxStream *stream;
<a name="218" id="anc218"></a><span class="line-modified"> 6663   gint i;</span>
 6664 
 6665   GST_DEBUG_OBJECT (demux, &quot;Checking if there are samples not played yet&quot;);
 6666 
<a name="219" id="anc219"></a><span class="line-modified"> 6667   for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified"> 6668     stream = QTDEMUX_NTH_STREAM (demux, i);</span>
 6669 
 6670     if (stream-&gt;sample_index == -1) {
 6671       stream-&gt;sample_index = 0;
 6672       stream-&gt;offset_in_sample = 0;
 6673     }
 6674 
 6675     if (stream-&gt;sample_index &gt;= stream-&gt;n_samples) {
<a name="220" id="anc220"></a><span class="line-modified"> 6676       GST_LOG_OBJECT (demux, &quot;track-id %u samples exhausted&quot;, stream-&gt;track_id);</span>
 6677       continue;
 6678     }
 6679     GST_DEBUG_OBJECT (demux, &quot;Found a sample&quot;);
 6680     return TRUE;
 6681   }
 6682 
 6683   GST_DEBUG_OBJECT (demux, &quot;There wasn&#39;t any next sample&quot;);
 6684   return FALSE;
 6685 }
 6686 
 6687 /*
 6688  * next_entry_size
 6689  *
 6690  * Returns the size of the first entry at the current offset.
 6691  * If -1, there are none (which means EOS or empty file).
 6692  */
 6693 static guint64
 6694 next_entry_size (GstQTDemux * demux)
 6695 {
<a name="221" id="anc221"></a><span class="line-modified"> 6696   QtDemuxStream *stream, *target_stream = NULL;</span>


 6697   guint64 smalloffs = (guint64) - 1;
 6698   QtDemuxSample *sample;
<a name="222" id="anc222"></a><span class="line-added"> 6699   gint i;</span>
 6700 
 6701   GST_LOG_OBJECT (demux, &quot;Finding entry at offset %&quot; G_GUINT64_FORMAT,
 6702       demux-&gt;offset);
 6703 
<a name="223" id="anc223"></a><span class="line-modified"> 6704   for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified"> 6705     stream = QTDEMUX_NTH_STREAM (demux, i);</span>
 6706 
 6707     if (stream-&gt;sample_index == -1) {
 6708       stream-&gt;sample_index = 0;
 6709       stream-&gt;offset_in_sample = 0;
 6710     }
 6711 
 6712     if (stream-&gt;sample_index &gt;= stream-&gt;n_samples) {
<a name="224" id="anc224"></a><span class="line-modified"> 6713       GST_LOG_OBJECT (demux, &quot;track-id %u samples exhausted&quot;, stream-&gt;track_id);</span>
 6714       continue;
 6715     }
 6716 
 6717     if (!qtdemux_parse_samples (demux, stream, stream-&gt;sample_index)) {
 6718       GST_LOG_OBJECT (demux, &quot;Parsing of index %u from stbl atom failed!&quot;,
 6719           stream-&gt;sample_index);
 6720       return -1;
 6721     }
 6722 
 6723     sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
 6724 
 6725     GST_LOG_OBJECT (demux,
<a name="225" id="anc225"></a><span class="line-modified"> 6726         &quot;Checking track-id %u (sample_index:%d / offset:%&quot; G_GUINT64_FORMAT</span>
<span class="line-modified"> 6727         &quot; / size:%&quot; G_GUINT32_FORMAT &quot;)&quot;, stream-&gt;track_id,</span>
<span class="line-modified"> 6728         stream-&gt;sample_index, sample-&gt;offset, sample-&gt;size);</span>
 6729 
 6730     if (((smalloffs == -1)
 6731             || (sample-&gt;offset &lt; smalloffs)) &amp;&amp; (sample-&gt;size)) {
<a name="226" id="anc226"></a>
 6732       smalloffs = sample-&gt;offset;
<a name="227" id="anc227"></a><span class="line-added"> 6733       target_stream = stream;</span>
 6734     }
 6735   }
 6736 
<a name="228" id="anc228"></a><span class="line-modified"> 6737   if (!target_stream)</span>




 6738     return -1;
 6739 
<a name="229" id="anc229"></a><span class="line-modified"> 6740   GST_LOG_OBJECT (demux,</span>
<span class="line-added"> 6741       &quot;track-id %u offset %&quot; G_GUINT64_FORMAT &quot; demux-&gt;offset :%&quot;</span>
<span class="line-added"> 6742       G_GUINT64_FORMAT, target_stream-&gt;track_id, smalloffs, demux-&gt;offset);</span>
<span class="line-added"> 6743 </span>
<span class="line-added"> 6744   stream = target_stream;</span>
 6745   sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
 6746 
 6747   if (sample-&gt;offset &gt;= demux-&gt;offset) {
 6748     demux-&gt;todrop = sample-&gt;offset - demux-&gt;offset;
 6749     return sample-&gt;size + demux-&gt;todrop;
 6750   }
 6751 
 6752   GST_DEBUG_OBJECT (demux,
 6753       &quot;There wasn&#39;t any entry at offset %&quot; G_GUINT64_FORMAT, demux-&gt;offset);
 6754   return -1;
 6755 }
 6756 
 6757 static void
 6758 gst_qtdemux_post_progress (GstQTDemux * demux, gint num, gint denom)
 6759 {
 6760   gint perc = (gint) ((gdouble) num * 100.0 / (gdouble) denom);
 6761 
 6762   gst_element_post_message (GST_ELEMENT_CAST (demux),
 6763       gst_message_new_element (GST_OBJECT_CAST (demux),
 6764           gst_structure_new (&quot;progress&quot;, &quot;percent&quot;, G_TYPE_INT, perc, NULL)));
 6765 }
 6766 
 6767 static gboolean
 6768 qtdemux_seek_offset (GstQTDemux * demux, guint64 offset)
 6769 {
 6770   GstEvent *event;
 6771   gboolean res = 0;
 6772 
 6773   GST_DEBUG_OBJECT (demux, &quot;Seeking to %&quot; G_GUINT64_FORMAT, offset);
 6774 
 6775   event =
 6776       gst_event_new_seek (1.0, GST_FORMAT_BYTES,
 6777       GST_SEEK_FLAG_FLUSH | GST_SEEK_FLAG_ACCURATE, GST_SEEK_TYPE_SET, offset,
 6778       GST_SEEK_TYPE_NONE, -1);
 6779 
 6780   /* store seqnum to drop flush events, they don&#39;t need to reach downstream */
 6781   demux-&gt;offset_seek_seqnum = gst_event_get_seqnum (event);
 6782   res = gst_pad_push_event (demux-&gt;sinkpad, event);
 6783   demux-&gt;offset_seek_seqnum = GST_SEQNUM_INVALID;
 6784 
 6785   return res;
 6786 }
 6787 
 6788 /* check for seekable upstream, above and beyond a mere query */
 6789 static void
 6790 gst_qtdemux_check_seekability (GstQTDemux * demux)
 6791 {
 6792   GstQuery *query;
 6793   gboolean seekable = FALSE;
 6794   gint64 start = -1, stop = -1;
 6795 
 6796   if (demux-&gt;upstream_size)
 6797     return;
 6798 
 6799   if (demux-&gt;upstream_format_is_time)
 6800     return;
 6801 
 6802   query = gst_query_new_seeking (GST_FORMAT_BYTES);
 6803   if (!gst_pad_peer_query (demux-&gt;sinkpad, query)) {
 6804     GST_DEBUG_OBJECT (demux, &quot;seeking query failed&quot;);
 6805     goto done;
 6806   }
 6807 
 6808   gst_query_parse_seeking (query, NULL, &amp;seekable, &amp;start, &amp;stop);
 6809 
 6810   /* try harder to query upstream size if we didn&#39;t get it the first time */
 6811   if (seekable &amp;&amp; stop == -1) {
 6812     GST_DEBUG_OBJECT (demux, &quot;doing duration query to fix up unset stop&quot;);
 6813     gst_pad_peer_query_duration (demux-&gt;sinkpad, GST_FORMAT_BYTES, &amp;stop);
 6814   }
 6815 
 6816   /* if upstream doesn&#39;t know the size, it&#39;s likely that it&#39;s not seekable in
 6817    * practice even if it technically may be seekable */
 6818   if (seekable &amp;&amp; (start != 0 || stop &lt;= start)) {
 6819     GST_DEBUG_OBJECT (demux, &quot;seekable but unknown start/stop -&gt; disable&quot;);
 6820     seekable = FALSE;
 6821   }
 6822 
 6823 done:
 6824   gst_query_unref (query);
 6825 
 6826   GST_DEBUG_OBJECT (demux, &quot;seekable: %d (%&quot; G_GUINT64_FORMAT &quot; - %&quot;
 6827       G_GUINT64_FORMAT &quot;)&quot;, seekable, start, stop);
 6828   demux-&gt;upstream_seekable = seekable;
 6829   demux-&gt;upstream_size = seekable ? stop : -1;
 6830 }
 6831 
 6832 static void
 6833 gst_qtdemux_drop_data (GstQTDemux * demux, gint bytes)
 6834 {
 6835   g_return_if_fail (bytes &lt;= demux-&gt;todrop);
 6836 
 6837   GST_LOG_OBJECT (demux, &quot;Dropping %d bytes&quot;, bytes);
 6838   gst_adapter_flush (demux-&gt;adapter, bytes);
 6839   demux-&gt;neededbytes -= bytes;
 6840   demux-&gt;offset += bytes;
 6841   demux-&gt;todrop -= bytes;
 6842 }
 6843 
<a name="230" id="anc230"></a><span class="line-added"> 6844 /* PUSH-MODE only: Send a segment, if not done already. */</span>
 6845 static void
 6846 gst_qtdemux_check_send_pending_segment (GstQTDemux * demux)
 6847 {
<a name="231" id="anc231"></a><span class="line-modified"> 6848   if (G_UNLIKELY (demux-&gt;need_segment)) {</span>
 6849     gint i;
 6850 
<a name="232" id="anc232"></a><span class="line-modified"> 6851     if (!demux-&gt;upstream_format_is_time) {</span>
<span class="line-added"> 6852       gst_qtdemux_map_and_push_segments (demux, &amp;demux-&gt;segment);</span>
<span class="line-added"> 6853     } else {</span>
<span class="line-added"> 6854       GstEvent *segment_event;</span>
<span class="line-added"> 6855       segment_event = gst_event_new_segment (&amp;demux-&gt;segment);</span>
<span class="line-added"> 6856       if (demux-&gt;segment_seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added"> 6857         gst_event_set_seqnum (segment_event, demux-&gt;segment_seqnum);</span>
<span class="line-added"> 6858       gst_qtdemux_push_event (demux, segment_event);</span>
<span class="line-added"> 6859     }</span>
<span class="line-added"> 6860 </span>
<span class="line-added"> 6861     demux-&gt;need_segment = FALSE;</span>
<span class="line-added"> 6862 </span>
 6863     /* clear to send tags on all streams */
<a name="233" id="anc233"></a><span class="line-modified"> 6864     for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified"> 6865       QtDemuxStream *stream = QTDEMUX_NTH_STREAM (demux, i);</span>

 6866       gst_qtdemux_push_tags (demux, stream);
 6867       if (CUR_STREAM (stream)-&gt;sparse) {
 6868         GST_INFO_OBJECT (demux, &quot;Sending gap event on stream %d&quot;, i);
 6869         gst_pad_push_event (stream-&gt;pad,
 6870             gst_event_new_gap (stream-&gt;segment.position, GST_CLOCK_TIME_NONE));
 6871       }
 6872     }
 6873   }
 6874 }
 6875 
<a name="234" id="anc234"></a><span class="line-added"> 6876 /* Used for push mode only. */</span>
 6877 static void
 6878 gst_qtdemux_send_gap_for_segment (GstQTDemux * demux,
 6879     QtDemuxStream * stream, gint segment_index, GstClockTime pos)
 6880 {
 6881   GstClockTime ts, dur;
<a name="235" id="anc235"></a>
 6882 
 6883   ts = pos;
 6884   dur =
 6885       stream-&gt;segments[segment_index].duration - (pos -
 6886       stream-&gt;segments[segment_index].time);
<a name="236" id="anc236"></a>
 6887   stream-&gt;time_position += dur;
 6888 
<a name="237" id="anc237"></a><span class="line-modified"> 6889   /* Only gaps with a duration of at least one second are propagated.</span>
<span class="line-modified"> 6890    * Same workaround as in pull mode.</span>
<span class="line-modified"> 6891    * (See 2e45926a96ec5298c6ef29bf912e5e6a06dc3e0e) */</span>
<span class="line-modified"> 6892   if (dur &gt;= GST_SECOND) {</span>
<span class="line-modified"> 6893     GstEvent *gap;</span>
<span class="line-modified"> 6894     gap = gst_event_new_gap (ts, dur);</span>









 6895 
<a name="238" id="anc238"></a><span class="line-modified"> 6896     GST_DEBUG_OBJECT (stream-&gt;pad, &quot;Pushing gap for empty &quot;</span>
<span class="line-modified"> 6897         &quot;segment: %&quot; GST_PTR_FORMAT, gap);</span>
<span class="line-modified"> 6898     gst_pad_push_event (stream-&gt;pad, gap);</span>







 6899   }
 6900 }
 6901 
 6902 static GstFlowReturn
 6903 gst_qtdemux_chain (GstPad * sinkpad, GstObject * parent, GstBuffer * inbuf)
 6904 {
 6905   GstQTDemux *demux;
 6906 
 6907   demux = GST_QTDEMUX (parent);
 6908 
 6909   GST_DEBUG_OBJECT (demux,
 6910       &quot;Received buffer pts:%&quot; GST_TIME_FORMAT &quot; dts:%&quot; GST_TIME_FORMAT
 6911       &quot; offset:%&quot; G_GUINT64_FORMAT &quot; size:%&quot; G_GSIZE_FORMAT &quot; demux offset:%&quot;
 6912       G_GUINT64_FORMAT, GST_TIME_ARGS (GST_BUFFER_PTS (inbuf)),
 6913       GST_TIME_ARGS (GST_BUFFER_DTS (inbuf)), GST_BUFFER_OFFSET (inbuf),
 6914       gst_buffer_get_size (inbuf), demux-&gt;offset);
 6915 
 6916   if (GST_BUFFER_FLAG_IS_SET (inbuf, GST_BUFFER_FLAG_DISCONT)) {
 6917     gboolean is_gap_input = FALSE;
 6918     gint i;
 6919 
 6920     GST_DEBUG_OBJECT (demux, &quot;Got DISCONT, marking all streams as DISCONT&quot;);
 6921 
<a name="239" id="anc239"></a><span class="line-modified"> 6922     for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified"> 6923       QTDEMUX_NTH_STREAM (demux, i)-&gt;discont = TRUE;</span>
 6924     }
 6925 
 6926     /* Check if we can land back on our feet in the case where upstream is
 6927      * handling the seeking/pushing of samples with gaps in between (like
 6928      * in the case of trick-mode DASH for example) */
 6929     if (demux-&gt;upstream_format_is_time
 6930         &amp;&amp; GST_BUFFER_OFFSET (inbuf) != GST_BUFFER_OFFSET_NONE) {
<a name="240" id="anc240"></a><span class="line-modified"> 6931       for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>

 6932         guint32 res;
<a name="241" id="anc241"></a><span class="line-added"> 6933         QtDemuxStream *stream = QTDEMUX_NTH_STREAM (demux, i);</span>
 6934         GST_LOG_OBJECT (demux,
<a name="242" id="anc242"></a><span class="line-modified"> 6935             &quot;track-id #%u , checking if offset %&quot; G_GUINT64_FORMAT</span>
<span class="line-modified"> 6936             &quot; is a sample start&quot;, stream-&gt;track_id, GST_BUFFER_OFFSET (inbuf));</span>
 6937         res =
 6938             gst_qtdemux_find_index_for_given_media_offset_linear (demux,
<a name="243" id="anc243"></a><span class="line-modified"> 6939             stream, GST_BUFFER_OFFSET (inbuf));</span>
 6940         if (res != -1) {
<a name="244" id="anc244"></a><span class="line-modified"> 6941           QtDemuxSample *sample = &amp;stream-&gt;samples[res];</span>
 6942           GST_LOG_OBJECT (demux,
<a name="245" id="anc245"></a><span class="line-modified"> 6943               &quot;Checking if sample %d from track-id %u is valid (offset:%&quot;</span>
<span class="line-modified"> 6944               G_GUINT64_FORMAT &quot; size:%&quot; G_GUINT32_FORMAT &quot;)&quot;, res,</span>
<span class="line-modified"> 6945               stream-&gt;track_id, sample-&gt;offset, sample-&gt;size);</span>
 6946           if (sample-&gt;offset == GST_BUFFER_OFFSET (inbuf)) {
 6947             GST_LOG_OBJECT (demux,
 6948                 &quot;new buffer corresponds to a valid sample : %&quot; G_GUINT32_FORMAT,
 6949                 res);
 6950             is_gap_input = TRUE;
 6951             /* We can go back to standard playback mode */
 6952             demux-&gt;state = QTDEMUX_STATE_MOVIE;
 6953             /* Remember which sample this stream is at */
<a name="246" id="anc246"></a><span class="line-modified"> 6954             stream-&gt;sample_index = res;</span>
 6955             /* Finally update all push-based values to the expected values */
<a name="247" id="anc247"></a><span class="line-modified"> 6956             demux-&gt;neededbytes = stream-&gt;samples[res].size;</span>
 6957             demux-&gt;offset = GST_BUFFER_OFFSET (inbuf);
 6958             demux-&gt;mdatleft =
 6959                 demux-&gt;mdatsize - demux-&gt;offset + demux-&gt;mdatoffset;
 6960             demux-&gt;todrop = 0;
 6961           }
 6962         }
 6963       }
 6964       if (!is_gap_input) {
 6965         GST_DEBUG_OBJECT (demux, &quot;Resetting, actual DISCONT&quot;);
 6966         /* Reset state if it&#39;s a real discont */
 6967         demux-&gt;neededbytes = 16;
 6968         demux-&gt;state = QTDEMUX_STATE_INITIAL;
 6969         demux-&gt;offset = GST_BUFFER_OFFSET (inbuf);
 6970         gst_adapter_clear (demux-&gt;adapter);
 6971       }
 6972     }
 6973     /* Reverse fragmented playback, need to flush all we have before
 6974      * consuming a new fragment.
 6975      * The samples array have the timestamps calculated by accumulating the
 6976      * durations but this won&#39;t work for reverse playback of fragments as
 6977      * the timestamps of a subsequent fragment should be smaller than the
 6978      * previously received one. */
 6979     if (!is_gap_input &amp;&amp; demux-&gt;fragmented &amp;&amp; demux-&gt;segment.rate &lt; 0) {
 6980       gst_qtdemux_process_adapter (demux, TRUE);
<a name="248" id="anc248"></a><span class="line-modified"> 6981       g_ptr_array_foreach (demux-&gt;active_streams,</span>
<span class="line-modified"> 6982           (GFunc) gst_qtdemux_stream_flush_samples_data, NULL);</span>
 6983     }
 6984   }
 6985 
 6986   gst_adapter_push (demux-&gt;adapter, inbuf);
 6987 
 6988   GST_DEBUG_OBJECT (demux,
 6989       &quot;pushing in inbuf %p, neededbytes:%u, available:%&quot; G_GSIZE_FORMAT, inbuf,
 6990       demux-&gt;neededbytes, gst_adapter_available (demux-&gt;adapter));
 6991 
 6992   return gst_qtdemux_process_adapter (demux, FALSE);
 6993 }
 6994 
 6995 static GstFlowReturn
 6996 gst_qtdemux_process_adapter (GstQTDemux * demux, gboolean force)
 6997 {
 6998   GstFlowReturn ret = GST_FLOW_OK;
 6999 
 7000   /* we never really mean to buffer that much */
 7001   if (demux-&gt;neededbytes == -1) {
 7002     goto eos;
 7003   }
 7004 
 7005   while (((gst_adapter_available (demux-&gt;adapter)) &gt;= demux-&gt;neededbytes) &amp;&amp;
 7006       (ret == GST_FLOW_OK || (ret == GST_FLOW_NOT_LINKED &amp;&amp; force))) {
 7007 
 7008 #ifndef GST_DISABLE_GST_DEBUG
 7009     {
 7010       guint64 discont_offset, distance_from_discont;
 7011 
 7012       discont_offset = gst_adapter_offset_at_discont (demux-&gt;adapter);
 7013       distance_from_discont =
 7014           gst_adapter_distance_from_discont (demux-&gt;adapter);
 7015 
<a name="249" id="anc249"></a><span class="line-modified"> 7016       GST_DEBUG_OBJECT (demux,</span>
 7017           &quot;state:%s , demux-&gt;neededbytes:%d, demux-&gt;offset:%&quot; G_GUINT64_FORMAT
 7018           &quot; adapter offset :%&quot; G_GUINT64_FORMAT &quot; (+ %&quot; G_GUINT64_FORMAT
 7019           &quot; bytes)&quot;, qt_demux_state_string (demux-&gt;state), demux-&gt;neededbytes,
 7020           demux-&gt;offset, discont_offset, distance_from_discont);
 7021     }
 7022 #endif
 7023 
 7024     switch (demux-&gt;state) {
 7025       case QTDEMUX_STATE_INITIAL:{
 7026         const guint8 *data;
 7027         guint32 fourcc;
 7028         guint64 size;
 7029 
 7030         gst_qtdemux_check_seekability (demux);
 7031 
 7032         data = gst_adapter_map (demux-&gt;adapter, demux-&gt;neededbytes);
 7033 
 7034         /* get fourcc/length, set neededbytes */
 7035         extract_initial_length_and_fourcc ((guint8 *) data, demux-&gt;neededbytes,
 7036             &amp;size, &amp;fourcc);
 7037         gst_adapter_unmap (demux-&gt;adapter);
 7038         data = NULL;
 7039         GST_DEBUG_OBJECT (demux, &quot;Peeking found [%&quot; GST_FOURCC_FORMAT &quot;] &quot;
 7040             &quot;size: %&quot; G_GUINT64_FORMAT, GST_FOURCC_ARGS (fourcc), size);
 7041         if (size == 0) {
 7042           GST_ELEMENT_ERROR (demux, STREAM, DEMUX,
 7043               (_(&quot;This file is invalid and cannot be played.&quot;)),
 7044               (&quot;initial atom &#39;%&quot; GST_FOURCC_FORMAT &quot;&#39; has empty length&quot;,
 7045                   GST_FOURCC_ARGS (fourcc)));
 7046           ret = GST_FLOW_ERROR;
 7047           break;
 7048         }
 7049         if (fourcc == FOURCC_mdat) {
 7050           gint next_entry = next_entry_size (demux);
<a name="250" id="anc250"></a><span class="line-modified"> 7051           if (QTDEMUX_N_STREAMS (demux) &gt; 0 &amp;&amp; (next_entry != -1</span>
<span class="line-added"> 7052                   || !demux-&gt;fragmented)) {</span>
 7053             /* we have the headers, start playback */
 7054             demux-&gt;state = QTDEMUX_STATE_MOVIE;
 7055             demux-&gt;neededbytes = next_entry;
 7056             demux-&gt;mdatleft = size;
 7057             demux-&gt;mdatsize = demux-&gt;mdatleft;
 7058           } else {
 7059             /* no headers yet, try to get them */
 7060             guint bs;
 7061             gboolean res;
 7062             guint64 old, target;
 7063 
 7064           buffer_data:
 7065             old = demux-&gt;offset;
 7066             target = old + size;
 7067 
 7068             /* try to jump over the atom with a seek */
 7069             /* only bother if it seems worth doing so,
 7070              * and avoids possible upstream/server problems */
 7071             if (demux-&gt;upstream_seekable &amp;&amp;
 7072                 demux-&gt;upstream_size &gt; 4 * (1 &lt;&lt; 20)) {
<a name="251" id="anc251"></a><span class="line-modified"> 7073               res = qtdemux_seek_offset (demux, target);</span>
 7074             } else {
 7075               GST_DEBUG_OBJECT (demux, &quot;skipping seek&quot;);
 7076               res = FALSE;
 7077             }
 7078 
 7079             if (res) {
 7080               GST_DEBUG_OBJECT (demux, &quot;seek success&quot;);
 7081               /* remember the offset fo the first mdat so we can seek back to it
 7082                * after we have the headers */
 7083               if (fourcc == FOURCC_mdat &amp;&amp; demux-&gt;first_mdat == -1) {
 7084                 demux-&gt;first_mdat = old;
 7085                 GST_DEBUG_OBJECT (demux, &quot;first mdat at %&quot; G_GUINT64_FORMAT,
 7086                     demux-&gt;first_mdat);
 7087               }
 7088               /* seek worked, continue reading */
 7089               demux-&gt;offset = target;
 7090               demux-&gt;neededbytes = 16;
 7091               demux-&gt;state = QTDEMUX_STATE_INITIAL;
 7092             } else {
 7093               /* seek failed, need to buffer */
 7094               demux-&gt;offset = old;
 7095               GST_DEBUG_OBJECT (demux, &quot;seek failed/skipped&quot;);
 7096               /* there may be multiple mdat (or alike) buffers */
 7097               /* sanity check */
 7098               if (demux-&gt;mdatbuffer)
 7099                 bs = gst_buffer_get_size (demux-&gt;mdatbuffer);
 7100               else
 7101                 bs = 0;
 7102               if (size + bs &gt; 10 * (1 &lt;&lt; 20))
 7103                 goto no_moov;
 7104               demux-&gt;state = QTDEMUX_STATE_BUFFER_MDAT;
 7105               demux-&gt;neededbytes = size;
 7106               if (!demux-&gt;mdatbuffer)
 7107                 demux-&gt;mdatoffset = demux-&gt;offset;
 7108             }
 7109           }
 7110         } else if (G_UNLIKELY (size &gt; QTDEMUX_MAX_ATOM_SIZE)) {
 7111           GST_ELEMENT_ERROR (demux, STREAM, DEMUX,
 7112               (_(&quot;This file is invalid and cannot be played.&quot;)),
 7113               (&quot;atom %&quot; GST_FOURCC_FORMAT &quot; has bogus size %&quot; G_GUINT64_FORMAT,
 7114                   GST_FOURCC_ARGS (fourcc), size));
 7115           ret = GST_FLOW_ERROR;
 7116           break;
 7117         } else {
 7118           /* this means we already started buffering and still no moov header,
 7119            * let&#39;s continue buffering everything till we get moov */
 7120           if (demux-&gt;mdatbuffer &amp;&amp; !(fourcc == FOURCC_moov
 7121                   || fourcc == FOURCC_moof))
 7122             goto buffer_data;
 7123           demux-&gt;neededbytes = size;
 7124           demux-&gt;state = QTDEMUX_STATE_HEADER;
 7125         }
 7126         break;
 7127       }
 7128       case QTDEMUX_STATE_HEADER:{
 7129         const guint8 *data;
 7130         guint32 fourcc;
 7131 
 7132         GST_DEBUG_OBJECT (demux, &quot;In header&quot;);
 7133 
 7134         data = gst_adapter_map (demux-&gt;adapter, demux-&gt;neededbytes);
 7135 
 7136         /* parse the header */
 7137         extract_initial_length_and_fourcc (data, demux-&gt;neededbytes, NULL,
 7138             &amp;fourcc);
 7139         if (fourcc == FOURCC_moov) {
<a name="252" id="anc252"></a>

 7140           /* in usual fragmented setup we could try to scan for more
 7141            * and end up at the the moov (after mdat) again */
<a name="253" id="anc253"></a><span class="line-modified"> 7142           if (demux-&gt;got_moov &amp;&amp; QTDEMUX_N_STREAMS (demux) &gt; 0 &amp;&amp;</span>
 7143               (!demux-&gt;fragmented
 7144                   || demux-&gt;last_moov_offset == demux-&gt;offset)) {
 7145             GST_DEBUG_OBJECT (demux,
 7146                 &quot;Skipping moov atom as we have (this) one already&quot;);
 7147           } else {
<a name="254" id="anc254"></a><span class="line-modified"> 7148             GST_DEBUG_OBJECT (demux, &quot;Parsing [moov]&quot;);</span>
 7149 
 7150             if (demux-&gt;got_moov &amp;&amp; demux-&gt;fragmented) {
 7151               GST_DEBUG_OBJECT (demux,
 7152                   &quot;Got a second moov, clean up data from old one&quot;);
 7153               if (demux-&gt;moov_node_compressed) {
 7154                 g_node_destroy (demux-&gt;moov_node_compressed);
<a name="255" id="anc255"></a><span class="line-modified"> 7155                 if (demux-&gt;moov_node)</span>
 7156                   g_free (demux-&gt;moov_node-&gt;data);
 7157               }
 7158               demux-&gt;moov_node_compressed = NULL;
 7159               if (demux-&gt;moov_node)
 7160                 g_node_destroy (demux-&gt;moov_node);
 7161               demux-&gt;moov_node = NULL;
<a name="256" id="anc256"></a>








 7162             }
 7163 
 7164             demux-&gt;last_moov_offset = demux-&gt;offset;
 7165 
<a name="257" id="anc257"></a><span class="line-modified"> 7166             /* Update streams with new moov */</span>
<span class="line-modified"> 7167             gst_qtdemux_stream_concat (demux,</span>
<span class="line-added"> 7168                 demux-&gt;old_streams, demux-&gt;active_streams);</span>
<span class="line-added"> 7169 </span>
<span class="line-added"> 7170             qtdemux_parse_moov (demux, data, demux-&gt;neededbytes);</span>
<span class="line-added"> 7171             qtdemux_node_dump (demux, demux-&gt;moov_node);</span>
 7172 #ifdef GSTREAMER_LITE
 7173           if (!qtdemux_parse_tree (demux))
 7174           {
 7175               g_node_destroy (demux-&gt;moov_node);
 7176               demux-&gt;moov_node = NULL;
 7177               ret = GST_FLOW_ERROR;
 7178               goto done;
 7179           }
 7180 #else
<a name="258" id="anc258"></a><span class="line-modified"> 7181             qtdemux_parse_tree (demux);</span>
 7182 #endif //GSTREAMER_LITE
<a name="259" id="anc259"></a><span class="line-modified"> 7183             qtdemux_prepare_streams (demux);</span>
<span class="line-modified"> 7184             QTDEMUX_EXPOSE_LOCK (demux);</span>
 7185             qtdemux_expose_streams (demux);
<a name="260" id="anc260"></a><span class="line-modified"> 7186             QTDEMUX_EXPOSE_UNLOCK (demux);</span>







 7187 
 7188             demux-&gt;got_moov = TRUE;
<a name="261" id="anc261"></a>
 7189 
<a name="262" id="anc262"></a><span class="line-modified"> 7190             gst_qtdemux_check_send_pending_segment (demux);</span>






 7191 
 7192             if (demux-&gt;moov_node_compressed) {
 7193               g_node_destroy (demux-&gt;moov_node_compressed);
 7194               g_free (demux-&gt;moov_node-&gt;data);
 7195             }
 7196             demux-&gt;moov_node_compressed = NULL;
<a name="263" id="anc263"></a><span class="line-modified"> 7197             g_node_destroy (demux-&gt;moov_node);</span>
<span class="line-modified"> 7198             demux-&gt;moov_node = NULL;</span>
<span class="line-modified"> 7199             GST_DEBUG_OBJECT (demux, &quot;Finished parsing the header&quot;);</span>
 7200           }
 7201         } else if (fourcc == FOURCC_moof) {
 7202           if ((demux-&gt;got_moov || demux-&gt;media_caps) &amp;&amp; demux-&gt;fragmented) {
 7203             guint64 dist = 0;
 7204             GstClockTime prev_pts;
 7205             guint64 prev_offset;
 7206             guint64 adapter_discont_offset, adapter_discont_dist;
 7207 
 7208             GST_DEBUG_OBJECT (demux, &quot;Parsing [moof]&quot;);
 7209 
 7210             /*
 7211              * The timestamp of the moof buffer is relevant as some scenarios
 7212              * won&#39;t have the initial timestamp in the atoms. Whenever a new
 7213              * buffer has started, we get that buffer&#39;s PTS and use it as a base
 7214              * timestamp for the trun entries.
 7215              *
 7216              * To keep track of the current buffer timestamp and starting point
 7217              * we use gst_adapter_prev_pts that gives us the PTS and the distance
 7218              * from the beggining of the buffer, with the distance and demux-&gt;offset
 7219              * we know if it is still the same buffer or not.
 7220              */
 7221             prev_pts = gst_adapter_prev_pts (demux-&gt;adapter, &amp;dist);
 7222             prev_offset = demux-&gt;offset - dist;
 7223             if (demux-&gt;fragment_start_offset == -1
 7224                 || prev_offset &gt; demux-&gt;fragment_start_offset) {
 7225               demux-&gt;fragment_start_offset = prev_offset;
 7226               demux-&gt;fragment_start = prev_pts;
 7227               GST_DEBUG_OBJECT (demux,
 7228                   &quot;New fragment start found at: %&quot; G_GUINT64_FORMAT &quot; : %&quot;
 7229                   GST_TIME_FORMAT, demux-&gt;fragment_start_offset,
 7230                   GST_TIME_ARGS (demux-&gt;fragment_start));
 7231             }
 7232 
 7233             /* We can&#39;t use prev_offset() here because this would require
 7234              * upstream to set consistent and correct offsets on all buffers
 7235              * since the discont. Nothing ever did that in the past and we
 7236              * would break backwards compatibility here then.
 7237              * Instead take the offset we had at the last discont and count
 7238              * the bytes from there. This works with old code as there would
 7239              * be no discont between moov and moof, and also works with
 7240              * adaptivedemux which correctly sets offset and will set the
 7241              * DISCONT flag accordingly when needed.
 7242              *
 7243              * We also only do this for upstream TIME segments as otherwise
 7244              * there are potential backwards compatibility problems with
 7245              * seeking in PUSH mode and upstream providing inconsistent
 7246              * timestamps. */
 7247             adapter_discont_offset =
 7248                 gst_adapter_offset_at_discont (demux-&gt;adapter);
 7249             adapter_discont_dist =
 7250                 gst_adapter_distance_from_discont (demux-&gt;adapter);
 7251 
 7252             GST_DEBUG_OBJECT (demux,
 7253                 &quot;demux offset %&quot; G_GUINT64_FORMAT &quot; adapter offset %&quot;
 7254                 G_GUINT64_FORMAT &quot; (+ %&quot; G_GUINT64_FORMAT &quot; bytes)&quot;,
 7255                 demux-&gt;offset, adapter_discont_offset, adapter_discont_dist);
 7256 
 7257             if (demux-&gt;upstream_format_is_time) {
 7258               demux-&gt;moof_offset = adapter_discont_offset;
 7259               if (demux-&gt;moof_offset != GST_BUFFER_OFFSET_NONE)
 7260                 demux-&gt;moof_offset += adapter_discont_dist;
 7261               if (demux-&gt;moof_offset == GST_BUFFER_OFFSET_NONE)
 7262                 demux-&gt;moof_offset = demux-&gt;offset;
 7263             } else {
 7264               demux-&gt;moof_offset = demux-&gt;offset;
 7265             }
 7266 
 7267             if (!qtdemux_parse_moof (demux, data, demux-&gt;neededbytes,
 7268                     demux-&gt;moof_offset, NULL)) {
 7269               gst_adapter_unmap (demux-&gt;adapter);
 7270               ret = GST_FLOW_ERROR;
 7271               goto done;
 7272             }
<a name="264" id="anc264"></a><span class="line-added"> 7273 </span>
 7274             /* in MSS we need to expose the pads after the first moof as we won&#39;t get a moov */
 7275             if (demux-&gt;mss_mode &amp;&amp; !demux-&gt;exposed) {
<a name="265" id="anc265"></a><span class="line-modified"> 7276               QTDEMUX_EXPOSE_LOCK (demux);</span>







 7277               qtdemux_expose_streams (demux);
<a name="266" id="anc266"></a><span class="line-added"> 7278               QTDEMUX_EXPOSE_UNLOCK (demux);</span>
 7279             }
<a name="267" id="anc267"></a><span class="line-added"> 7280 </span>
<span class="line-added"> 7281             gst_qtdemux_check_send_pending_segment (demux);</span>
 7282           } else {
 7283             GST_DEBUG_OBJECT (demux, &quot;Discarding [moof]&quot;);
 7284           }
 7285         } else if (fourcc == FOURCC_ftyp) {
 7286           GST_DEBUG_OBJECT (demux, &quot;Parsing [ftyp]&quot;);
 7287           qtdemux_parse_ftyp (demux, data, demux-&gt;neededbytes);
 7288         } else if (fourcc == FOURCC_uuid) {
 7289           GST_DEBUG_OBJECT (demux, &quot;Parsing [uuid]&quot;);
 7290           qtdemux_parse_uuid (demux, data, demux-&gt;neededbytes);
 7291         } else if (fourcc == FOURCC_sidx) {
 7292           GST_DEBUG_OBJECT (demux, &quot;Parsing [sidx]&quot;);
 7293           qtdemux_parse_sidx (demux, data, demux-&gt;neededbytes);
 7294         } else {
 7295           switch (fourcc) {
 7296             case FOURCC_styp:
 7297               /* [styp] is like a [ftyp], but in fragment header. We ignore it for now
 7298                * FALLTHROUGH */
 7299             case FOURCC_skip:
 7300             case FOURCC_free:
 7301               /* [free] and [skip] are padding atoms */
 7302               GST_DEBUG_OBJECT (demux,
 7303                   &quot;Skipping fourcc while parsing header : %&quot; GST_FOURCC_FORMAT,
 7304                   GST_FOURCC_ARGS (fourcc));
 7305               break;
 7306             default:
<a name="268" id="anc268"></a><span class="line-modified"> 7307               GST_WARNING_OBJECT (demux,</span>
<span class="line-modified"> 7308                   &quot;Unknown fourcc while parsing header : %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified"> 7309                   GST_FOURCC_ARGS (fourcc));</span>
<span class="line-modified"> 7310               /* Let&#39;s jump that one and go back to initial state */</span>
 7311               break;
<a name="269" id="anc269"></a><span class="line-modified"> 7312           }</span>
 7313         }
 7314         gst_adapter_unmap (demux-&gt;adapter);
 7315         data = NULL;
 7316 
<a name="270" id="anc270"></a><span class="line-modified"> 7317         if (demux-&gt;mdatbuffer &amp;&amp; QTDEMUX_N_STREAMS (demux)) {</span>
 7318           gsize remaining_data_size = 0;
 7319 
 7320           /* the mdat was before the header */
 7321           GST_DEBUG_OBJECT (demux, &quot;We have n_streams:%d and mdatbuffer:%p&quot;,
<a name="271" id="anc271"></a><span class="line-modified"> 7322               QTDEMUX_N_STREAMS (demux), demux-&gt;mdatbuffer);</span>
 7323           /* restore our adapter/offset view of things with upstream;
 7324            * put preceding buffered data ahead of current moov data.
 7325            * This should also handle evil mdat, moov, mdat cases and alike */
 7326           gst_adapter_flush (demux-&gt;adapter, demux-&gt;neededbytes);
 7327 
 7328           /* Store any remaining data after the mdat for later usage */
 7329           remaining_data_size = gst_adapter_available (demux-&gt;adapter);
 7330           if (remaining_data_size &gt; 0) {
 7331             g_assert (demux-&gt;restoredata_buffer == NULL);
 7332             demux-&gt;restoredata_buffer =
 7333                 gst_adapter_take_buffer (demux-&gt;adapter, remaining_data_size);
 7334             demux-&gt;restoredata_offset = demux-&gt;offset + demux-&gt;neededbytes;
 7335             GST_DEBUG_OBJECT (demux,
 7336                 &quot;Stored %&quot; G_GSIZE_FORMAT &quot; post mdat bytes at offset %&quot;
 7337                 G_GUINT64_FORMAT, remaining_data_size,
 7338                 demux-&gt;restoredata_offset);
 7339           }
 7340 
 7341           gst_adapter_push (demux-&gt;adapter, demux-&gt;mdatbuffer);
 7342           demux-&gt;mdatbuffer = NULL;
 7343           demux-&gt;offset = demux-&gt;mdatoffset;
 7344           demux-&gt;neededbytes = next_entry_size (demux);
 7345           demux-&gt;state = QTDEMUX_STATE_MOVIE;
 7346           demux-&gt;mdatleft = gst_adapter_available (demux-&gt;adapter);
 7347           demux-&gt;mdatsize = demux-&gt;mdatleft;
 7348         } else {
 7349           GST_DEBUG_OBJECT (demux, &quot;Carrying on normally&quot;);
 7350           gst_adapter_flush (demux-&gt;adapter, demux-&gt;neededbytes);
 7351 
 7352           /* only go back to the mdat if there are samples to play */
 7353           if (demux-&gt;got_moov &amp;&amp; demux-&gt;first_mdat != -1
 7354               &amp;&amp; has_next_entry (demux)) {
 7355             gboolean res;
 7356 
 7357             /* we need to seek back */
 7358             res = qtdemux_seek_offset (demux, demux-&gt;first_mdat);
 7359             if (res) {
 7360               demux-&gt;offset = demux-&gt;first_mdat;
 7361             } else {
 7362               GST_DEBUG_OBJECT (demux, &quot;Seek back failed&quot;);
 7363             }
 7364           } else {
 7365             demux-&gt;offset += demux-&gt;neededbytes;
 7366           }
 7367           demux-&gt;neededbytes = 16;
 7368           demux-&gt;state = QTDEMUX_STATE_INITIAL;
 7369         }
 7370 
 7371         break;
 7372       }
 7373       case QTDEMUX_STATE_BUFFER_MDAT:{
 7374         GstBuffer *buf;
 7375         guint8 fourcc[4];
 7376 
 7377         GST_DEBUG_OBJECT (demux, &quot;Got our buffer at offset %&quot; G_GUINT64_FORMAT,
 7378             demux-&gt;offset);
 7379         buf = gst_adapter_take_buffer (demux-&gt;adapter, demux-&gt;neededbytes);
 7380         gst_buffer_extract (buf, 0, fourcc, 4);
 7381         GST_DEBUG_OBJECT (demux, &quot;mdatbuffer starts with %&quot; GST_FOURCC_FORMAT,
 7382             GST_FOURCC_ARGS (QT_FOURCC (fourcc)));
 7383         if (demux-&gt;mdatbuffer)
 7384           demux-&gt;mdatbuffer = gst_buffer_append (demux-&gt;mdatbuffer, buf);
 7385         else
 7386           demux-&gt;mdatbuffer = buf;
 7387         demux-&gt;offset += demux-&gt;neededbytes;
 7388         demux-&gt;neededbytes = 16;
 7389         demux-&gt;state = QTDEMUX_STATE_INITIAL;
 7390         gst_qtdemux_post_progress (demux, 1, 1);
 7391 
 7392         break;
 7393       }
 7394       case QTDEMUX_STATE_MOVIE:{
 7395         QtDemuxStream *stream = NULL;
 7396         QtDemuxSample *sample;
<a name="272" id="anc272"></a>
 7397         GstClockTime dts, pts, duration;
 7398         gboolean keyframe;
<a name="273" id="anc273"></a><span class="line-added"> 7399         gint i;</span>
 7400 
 7401         GST_DEBUG_OBJECT (demux,
 7402             &quot;BEGIN // in MOVIE for offset %&quot; G_GUINT64_FORMAT, demux-&gt;offset);
 7403 
 7404         if (demux-&gt;fragmented) {
 7405           GST_DEBUG_OBJECT (demux, &quot;mdat remaining %&quot; G_GUINT64_FORMAT,
 7406               demux-&gt;mdatleft);
 7407           if (G_LIKELY (demux-&gt;todrop &lt; demux-&gt;mdatleft)) {
 7408             /* if needed data starts within this atom,
 7409              * then it should not exceed this atom */
 7410             if (G_UNLIKELY (demux-&gt;neededbytes &gt; demux-&gt;mdatleft)) {
 7411               GST_ELEMENT_ERROR (demux, STREAM, DEMUX,
 7412                   (_(&quot;This file is invalid and cannot be played.&quot;)),
 7413                   (&quot;sample data crosses atom boundary&quot;));
 7414               ret = GST_FLOW_ERROR;
 7415               break;
 7416             }
 7417             demux-&gt;mdatleft -= demux-&gt;neededbytes;
 7418           } else {
 7419             GST_DEBUG_OBJECT (demux, &quot;data atom emptied; resuming atom scan&quot;);
 7420             /* so we are dropping more than left in this atom */
 7421             gst_qtdemux_drop_data (demux, demux-&gt;mdatleft);
 7422             demux-&gt;mdatleft = 0;
 7423 
 7424             /* need to resume atom parsing so we do not miss any other pieces */
 7425             demux-&gt;state = QTDEMUX_STATE_INITIAL;
 7426             demux-&gt;neededbytes = 16;
 7427 
 7428             /* check if there was any stored post mdat data from previous buffers */
 7429             if (demux-&gt;restoredata_buffer) {
 7430               g_assert (gst_adapter_available (demux-&gt;adapter) == 0);
 7431 
 7432               gst_adapter_push (demux-&gt;adapter, demux-&gt;restoredata_buffer);
 7433               demux-&gt;restoredata_buffer = NULL;
 7434               demux-&gt;offset = demux-&gt;restoredata_offset;
 7435             }
 7436 
 7437             break;
 7438           }
 7439         }
 7440 
 7441         if (demux-&gt;todrop) {
 7442           if (demux-&gt;cenc_aux_info_offset &gt; 0) {
 7443             GstByteReader br;
 7444             const guint8 *data;
 7445 
 7446             GST_DEBUG_OBJECT (demux, &quot;parsing cenc auxiliary info&quot;);
 7447             data = gst_adapter_map (demux-&gt;adapter, demux-&gt;todrop);
 7448             gst_byte_reader_init (&amp;br, data + 8, demux-&gt;todrop);
<a name="274" id="anc274"></a><span class="line-modified"> 7449             if (!qtdemux_parse_cenc_aux_info (demux,</span>
<span class="line-added"> 7450                     QTDEMUX_NTH_STREAM (demux, 0), &amp;br,</span>
 7451                     demux-&gt;cenc_aux_info_sizes, demux-&gt;cenc_aux_sample_count)) {
 7452               GST_ERROR_OBJECT (demux, &quot;failed to parse cenc auxiliary info&quot;);
 7453               ret = GST_FLOW_ERROR;
 7454               gst_adapter_unmap (demux-&gt;adapter);
 7455               g_free (demux-&gt;cenc_aux_info_sizes);
 7456               demux-&gt;cenc_aux_info_sizes = NULL;
 7457               goto done;
<a name="275" id="anc275"></a><span class="line-modified"> 7458             }</span>
 7459             demux-&gt;cenc_aux_info_offset = 0;
 7460             g_free (demux-&gt;cenc_aux_info_sizes);
 7461             demux-&gt;cenc_aux_info_sizes = NULL;
 7462             gst_adapter_unmap (demux-&gt;adapter);
 7463           }
 7464           gst_qtdemux_drop_data (demux, demux-&gt;todrop);
 7465         }
 7466 
 7467         /* first buffer? */
 7468         /* initial newsegment sent here after having added pads,
 7469          * possible others in sink_event */
 7470         gst_qtdemux_check_send_pending_segment (demux);
 7471 
 7472         /* Figure out which stream this packet belongs to */
<a name="276" id="anc276"></a><span class="line-modified"> 7473         for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified"> 7474           stream = QTDEMUX_NTH_STREAM (demux, i);</span>
<span class="line-modified"> 7475           if (stream-&gt;sample_index &gt;= stream-&gt;n_samples) {</span>
<span class="line-added"> 7476             /* reset to be checked below G_UNLIKELY (stream == NULL) */</span>
<span class="line-added"> 7477             stream = NULL;</span>
 7478             continue;
<a name="277" id="anc277"></a><span class="line-added"> 7479           }</span>
 7480           GST_LOG_OBJECT (demux,
<a name="278" id="anc278"></a><span class="line-modified"> 7481               &quot;Checking track-id %u (sample_index:%d / offset:%&quot;</span>
<span class="line-modified"> 7482               G_GUINT64_FORMAT &quot; / size:%d)&quot;, stream-&gt;track_id,</span>
<span class="line-added"> 7483               stream-&gt;sample_index,</span>
 7484               stream-&gt;samples[stream-&gt;sample_index].offset,
 7485               stream-&gt;samples[stream-&gt;sample_index].size);
 7486 
 7487           if (stream-&gt;samples[stream-&gt;sample_index].offset == demux-&gt;offset)
 7488             break;
 7489         }
 7490 
<a name="279" id="anc279"></a><span class="line-modified"> 7491         if (G_UNLIKELY (stream == NULL))</span>
 7492           goto unknown_stream;
 7493 
 7494         gst_qtdemux_stream_check_and_change_stsd_index (demux, stream);
 7495 
 7496         if (stream-&gt;new_caps) {
 7497           gst_qtdemux_configure_stream (demux, stream);
 7498         }
 7499 
 7500         /* Put data in a buffer, set timestamps, caps, ... */
 7501         sample = &amp;stream-&gt;samples[stream-&gt;sample_index];
 7502 
 7503         if (G_LIKELY (!(STREAM_IS_EOS (stream)))) {
<a name="280" id="anc280"></a><span class="line-modified"> 7504           GST_DEBUG_OBJECT (demux, &quot;stream : %&quot; GST_FOURCC_FORMAT,</span>
 7505               GST_FOURCC_ARGS (CUR_STREAM (stream)-&gt;fourcc));
 7506 
 7507           dts = QTSAMPLE_DTS (stream, sample);
 7508           pts = QTSAMPLE_PTS (stream, sample);
 7509           duration = QTSAMPLE_DUR_DTS (stream, sample, dts);
<a name="281" id="anc281"></a><span class="line-modified"> 7510           keyframe = QTSAMPLE_KEYFRAME (stream, sample);</span>
 7511 
 7512           /* check for segment end */
 7513           if (G_UNLIKELY (demux-&gt;segment.stop != -1
<a name="282" id="anc282"></a><span class="line-modified"> 7514                   &amp;&amp; demux-&gt;segment.stop &lt;= pts &amp;&amp; stream-&gt;on_keyframe)</span>
<span class="line-added"> 7515               &amp;&amp; !(demux-&gt;upstream_format_is_time &amp;&amp; demux-&gt;segment.rate &lt; 0)) {</span>
 7516             GST_DEBUG_OBJECT (demux, &quot;we reached the end of our segment.&quot;);
 7517             stream-&gt;time_position = GST_CLOCK_TIME_NONE;        /* this means EOS */
 7518 
 7519             /* skip this data, stream is EOS */
 7520             gst_adapter_flush (demux-&gt;adapter, demux-&gt;neededbytes);
 7521             demux-&gt;offset += demux-&gt;neededbytes;
 7522 
 7523             /* check if all streams are eos */
 7524             ret = GST_FLOW_EOS;
<a name="283" id="anc283"></a><span class="line-modified"> 7525             for (i = 0; i &lt; QTDEMUX_N_STREAMS (demux); i++) {</span>
<span class="line-modified"> 7526               if (!STREAM_IS_EOS (QTDEMUX_NTH_STREAM (demux, i))) {</span>
 7527                 ret = GST_FLOW_OK;
 7528                 break;
 7529               }
 7530             }
 7531           } else {
 7532             GstBuffer *outbuf;
 7533 
 7534             outbuf =
 7535                 gst_adapter_take_buffer (demux-&gt;adapter, demux-&gt;neededbytes);
 7536 
 7537             /* FIXME: should either be an assert or a plain check */
 7538             g_return_val_if_fail (outbuf != NULL, GST_FLOW_ERROR);
 7539 
<a name="284" id="anc284"></a><span class="line-modified"> 7540             ret = gst_qtdemux_decorate_and_push_buffer (demux, stream, outbuf,</span>
 7541                 dts, pts, duration, keyframe, dts, demux-&gt;offset);
 7542           }
 7543 
<a name="285" id="anc285"></a><span class="line-modified"> 7544           /* combine flows */</span>
 7545           ret = gst_qtdemux_combine_flows (demux, stream, ret);
 7546         } else {
 7547           /* skip this data, stream is EOS */
 7548           gst_adapter_flush (demux-&gt;adapter, demux-&gt;neededbytes);
 7549         }
 7550 
 7551         stream-&gt;sample_index++;
 7552         stream-&gt;offset_in_sample = 0;
 7553 
 7554         /* update current offset and figure out size of next buffer */
 7555         GST_LOG_OBJECT (demux, &quot;increasing offset %&quot; G_GUINT64_FORMAT &quot; by %u&quot;,
 7556             demux-&gt;offset, demux-&gt;neededbytes);
 7557         demux-&gt;offset += demux-&gt;neededbytes;
 7558         GST_LOG_OBJECT (demux, &quot;offset is now %&quot; G_GUINT64_FORMAT,
 7559             demux-&gt;offset);
 7560 
 7561 
 7562         if (ret == GST_FLOW_EOS) {
 7563           GST_DEBUG_OBJECT (demux, &quot;All streams are EOS, signal upstream&quot;);
 7564           demux-&gt;neededbytes = -1;
 7565           goto eos;
 7566         }
 7567 
 7568         if ((demux-&gt;neededbytes = next_entry_size (demux)) == -1) {
 7569           if (demux-&gt;fragmented) {
 7570             GST_DEBUG_OBJECT (demux, &quot;(temporarily) out of fragmented samples&quot;);
 7571             /* there may be more to follow, only finish this atom */
 7572             demux-&gt;todrop = demux-&gt;mdatleft;
 7573             demux-&gt;neededbytes = demux-&gt;todrop;
 7574             break;
 7575           }
 7576           goto eos;
 7577         }
 7578         if (ret != GST_FLOW_OK &amp;&amp; ret != GST_FLOW_NOT_LINKED) {
 7579           goto non_ok_unlinked_flow;
 7580         }
 7581         break;
 7582       }
 7583       default:
 7584         goto invalid_state;
 7585     }
 7586   }
 7587 
 7588   /* when buffering movie data, at least show user something is happening */
 7589   if (ret == GST_FLOW_OK &amp;&amp; demux-&gt;state == QTDEMUX_STATE_BUFFER_MDAT &amp;&amp;
 7590       gst_adapter_available (demux-&gt;adapter) &lt;= demux-&gt;neededbytes) {
 7591     gst_qtdemux_post_progress (demux, gst_adapter_available (demux-&gt;adapter),
 7592         demux-&gt;neededbytes);
 7593   }
 7594 done:
 7595 
 7596   return ret;
 7597 
 7598   /* ERRORS */
 7599 non_ok_unlinked_flow:
 7600   {
 7601     GST_DEBUG_OBJECT (demux, &quot;Stopping, combined return flow %s&quot;,
 7602         gst_flow_get_name (ret));
 7603     return ret;
 7604   }
 7605 unknown_stream:
 7606   {
 7607     GST_ELEMENT_ERROR (demux, STREAM, FAILED, (NULL), (&quot;unknown stream found&quot;));
 7608     ret = GST_FLOW_ERROR;
 7609     goto done;
 7610   }
 7611 eos:
 7612   {
 7613     GST_DEBUG_OBJECT (demux, &quot;no next entry, EOS&quot;);
 7614     ret = GST_FLOW_EOS;
 7615     goto done;
 7616   }
 7617 invalid_state:
 7618   {
 7619     GST_ELEMENT_ERROR (demux, STREAM, FAILED,
 7620         (NULL), (&quot;qtdemuxer invalid state %d&quot;, demux-&gt;state));
 7621     ret = GST_FLOW_ERROR;
 7622     goto done;
 7623   }
 7624 no_moov:
 7625   {
 7626     GST_ELEMENT_ERROR (demux, STREAM, FAILED,
 7627         (NULL), (&quot;no &#39;moov&#39; atom within the first 10 MB&quot;));
 7628     ret = GST_FLOW_ERROR;
 7629     goto done;
 7630   }
 7631 }
 7632 
 7633 static gboolean
 7634 qtdemux_sink_activate (GstPad * sinkpad, GstObject * parent)
 7635 {
 7636   GstQuery *query;
 7637   gboolean pull_mode;
 7638 
 7639   query = gst_query_new_scheduling ();
 7640 
 7641   if (!gst_pad_peer_query (sinkpad, query)) {
 7642     gst_query_unref (query);
 7643     goto activate_push;
 7644   }
 7645 
 7646   pull_mode = gst_query_has_scheduling_mode_with_flags (query,
 7647       GST_PAD_MODE_PULL, GST_SCHEDULING_FLAG_SEEKABLE);
 7648   gst_query_unref (query);
 7649 
 7650   if (!pull_mode)
 7651     goto activate_push;
 7652 
 7653   GST_DEBUG_OBJECT (sinkpad, &quot;activating pull&quot;);
 7654   return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PULL, TRUE);
 7655 
 7656 activate_push:
 7657   {
 7658     GST_DEBUG_OBJECT (sinkpad, &quot;activating push&quot;);
 7659     return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PUSH, TRUE);
 7660   }
 7661 }
 7662 
 7663 static gboolean
 7664 qtdemux_sink_activate_mode (GstPad * sinkpad, GstObject * parent,
 7665     GstPadMode mode, gboolean active)
 7666 {
 7667   gboolean res;
 7668   GstQTDemux *demux = GST_QTDEMUX (parent);
 7669 
 7670   switch (mode) {
 7671     case GST_PAD_MODE_PUSH:
<a name="286" id="anc286"></a><span class="line-modified"> 7672       demux-&gt;pullbased = FALSE;</span>
 7673       res = TRUE;
 7674       break;
 7675     case GST_PAD_MODE_PULL:
 7676       if (active) {
 7677         demux-&gt;pullbased = TRUE;
 7678         res = gst_pad_start_task (sinkpad, (GstTaskFunction) gst_qtdemux_loop,
 7679             sinkpad, NULL);
 7680       } else {
 7681         res = gst_pad_stop_task (sinkpad);
 7682       }
 7683       break;
 7684     default:
 7685       res = FALSE;
 7686       break;
 7687   }
 7688   return res;
 7689 }
 7690 
 7691 #ifdef HAVE_ZLIB
 7692 static void *
 7693 qtdemux_inflate (void *z_buffer, guint z_length, guint * length)
 7694 {
 7695   guint8 *buffer;
 7696   z_stream z;
 7697   int ret;
 7698 
 7699   memset (&amp;z, 0, sizeof (z));
 7700   z.zalloc = NULL;
 7701   z.zfree = NULL;
 7702   z.opaque = NULL;
 7703 
 7704   if ((ret = inflateInit (&amp;z)) != Z_OK) {
 7705     GST_ERROR (&quot;inflateInit() returned %d&quot;, ret);
 7706     return NULL;
 7707   }
 7708 
 7709   z.next_in = z_buffer;
 7710   z.avail_in = z_length;
 7711 
 7712   buffer = (guint8 *) g_malloc (*length);
 7713   z.avail_out = *length;
 7714   z.next_out = (Bytef *) buffer;
 7715   do {
 7716     ret = inflate (&amp;z, Z_NO_FLUSH);
 7717     if (ret == Z_STREAM_END) {
 7718       break;
 7719     } else if (ret != Z_OK) {
 7720       GST_WARNING (&quot;inflate() returned %d&quot;, ret);
 7721       break;
<a name="287" id="anc287"></a><span class="line-modified"> 7722     }</span>
 7723 
 7724     *length += 4096;
 7725     buffer = (guint8 *) g_realloc (buffer, *length);
 7726     z.next_out = (Bytef *) (buffer + z.total_out);
 7727     z.avail_out += 4096;
 7728   } while (z.avail_in &gt; 0);
 7729 
 7730   if (ret != Z_STREAM_END) {
 7731     g_free (buffer);
 7732     buffer = NULL;
 7733     *length = 0;
 7734   } else {
 7735     *length = z.total_out;
 7736   }
 7737 
 7738   inflateEnd (&amp;z);
 7739 
 7740   return buffer;
 7741 }
 7742 #endif /* HAVE_ZLIB */
 7743 
 7744 static gboolean
 7745 qtdemux_parse_moov (GstQTDemux * qtdemux, const guint8 * buffer, guint length)
 7746 {
 7747   GNode *cmov;
 7748 
 7749   qtdemux-&gt;moov_node = g_node_new ((guint8 *) buffer);
 7750 
 7751   /* counts as header data */
 7752   qtdemux-&gt;header_size += length;
 7753 
 7754   GST_DEBUG_OBJECT (qtdemux, &quot;parsing &#39;moov&#39; atom&quot;);
 7755   qtdemux_parse_node (qtdemux, qtdemux-&gt;moov_node, buffer, length);
 7756 
 7757   cmov = qtdemux_tree_get_child_by_type (qtdemux-&gt;moov_node, FOURCC_cmov);
 7758   if (cmov) {
 7759     guint32 method;
 7760     GNode *dcom;
 7761     GNode *cmvd;
 7762     guint32 dcom_len;
 7763 
 7764     dcom = qtdemux_tree_get_child_by_type (cmov, FOURCC_dcom);
 7765     cmvd = qtdemux_tree_get_child_by_type (cmov, FOURCC_cmvd);
 7766     if (dcom == NULL || cmvd == NULL)
 7767       goto invalid_compression;
 7768 
 7769     dcom_len = QT_UINT32 (dcom-&gt;data);
 7770     if (dcom_len &lt; 12)
 7771       goto invalid_compression;
 7772 
 7773     method = QT_FOURCC ((guint8 *) dcom-&gt;data + 8);
 7774     switch (method) {
 7775 #ifdef HAVE_ZLIB
 7776       case FOURCC_zlib:{
 7777         guint uncompressed_length;
 7778         guint compressed_length;
 7779         guint8 *buf;
 7780         guint32 cmvd_len;
 7781 
 7782         cmvd_len = QT_UINT32 ((guint8 *) cmvd-&gt;data);
 7783         if (cmvd_len &lt; 12)
 7784           goto invalid_compression;
 7785 
 7786         uncompressed_length = QT_UINT32 ((guint8 *) cmvd-&gt;data + 8);
 7787         compressed_length = cmvd_len - 12;
 7788         GST_LOG (&quot;length = %u&quot;, uncompressed_length);
 7789 
 7790         buf =
 7791             (guint8 *) qtdemux_inflate ((guint8 *) cmvd-&gt;data + 12,
 7792             compressed_length, &amp;uncompressed_length);
 7793 
 7794         if (buf) {
<a name="288" id="anc288"></a><span class="line-modified"> 7795           qtdemux-&gt;moov_node_compressed = qtdemux-&gt;moov_node;</span>
<span class="line-modified"> 7796           qtdemux-&gt;moov_node = g_node_new (buf);</span>
 7797 
<a name="289" id="anc289"></a><span class="line-modified"> 7798           qtdemux_parse_node (qtdemux, qtdemux-&gt;moov_node, buf,</span>
<span class="line-modified"> 7799               uncompressed_length);</span>
 7800         }
 7801         break;
 7802       }
 7803 #endif /* HAVE_ZLIB */
 7804       default:
 7805         GST_WARNING_OBJECT (qtdemux, &quot;unknown or unhandled header compression &quot;
 7806             &quot;type %&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (method));
 7807         break;
 7808     }
 7809   }
 7810   return TRUE;
 7811 
 7812   /* ERRORS */
 7813 invalid_compression:
 7814   {
 7815     GST_ERROR_OBJECT (qtdemux, &quot;invalid compressed header&quot;);
 7816     return FALSE;
 7817   }
 7818 }
 7819 
 7820 static gboolean
 7821 qtdemux_parse_container (GstQTDemux * qtdemux, GNode * node, const guint8 * buf,
 7822     const guint8 * end)
 7823 {
 7824   while (G_UNLIKELY (buf &lt; end)) {
 7825     GNode *child;
 7826     guint32 len;
 7827 
 7828     if (G_UNLIKELY (buf + 4 &gt; end)) {
 7829       GST_LOG_OBJECT (qtdemux, &quot;buffer overrun&quot;);
 7830       break;
 7831     }
 7832     len = QT_UINT32 (buf);
 7833     if (G_UNLIKELY (len == 0)) {
 7834       GST_LOG_OBJECT (qtdemux, &quot;empty container&quot;);
 7835       break;
 7836     }
 7837     if (G_UNLIKELY (len &lt; 8)) {
 7838       GST_WARNING_OBJECT (qtdemux, &quot;length too short (%d &lt; 8)&quot;, len);
 7839       break;
 7840     }
 7841     if (G_UNLIKELY (len &gt; (end - buf))) {
 7842       GST_WARNING_OBJECT (qtdemux, &quot;length too long (%d &gt; %d)&quot;, len,
 7843           (gint) (end - buf));
 7844       break;
 7845     }
 7846 
 7847     child = g_node_new ((guint8 *) buf);
 7848     g_node_append (node, child);
 7849     GST_LOG_OBJECT (qtdemux, &quot;adding new node of len %d&quot;, len);
 7850     qtdemux_parse_node (qtdemux, child, buf, len);
 7851 
 7852     buf += len;
 7853   }
 7854   return TRUE;
 7855 }
 7856 
 7857 static gboolean
 7858 qtdemux_parse_theora_extension (GstQTDemux * qtdemux, QtDemuxStream * stream,
 7859     GNode * xdxt)
 7860 {
 7861   int len = QT_UINT32 (xdxt-&gt;data);
 7862   guint8 *buf = xdxt-&gt;data;
 7863   guint8 *end = buf + len;
 7864   GstBuffer *buffer;
 7865 
 7866   /* skip size and type */
 7867   buf += 8;
 7868   end -= 8;
 7869 
 7870   while (buf &lt; end) {
 7871     gint size;
 7872     guint32 type;
 7873 
 7874     size = QT_UINT32 (buf);
 7875     type = QT_FOURCC (buf + 4);
 7876 
 7877     GST_LOG_OBJECT (qtdemux, &quot;%p %p&quot;, buf, end);
 7878 
 7879     if (buf + size &gt; end || size &lt;= 0)
 7880       break;
 7881 
 7882     buf += 8;
 7883     size -= 8;
 7884 
 7885     GST_WARNING_OBJECT (qtdemux, &quot;have cookie %&quot; GST_FOURCC_FORMAT,
 7886         GST_FOURCC_ARGS (type));
 7887 
 7888     switch (type) {
 7889       case FOURCC_tCtH:
 7890         buffer = gst_buffer_new_and_alloc (size);
 7891         gst_buffer_fill (buffer, 0, buf, size);
 7892         stream-&gt;buffers = g_slist_append (stream-&gt;buffers, buffer);
 7893         GST_LOG_OBJECT (qtdemux, &quot;parsing theora header&quot;);
 7894         break;
 7895       case FOURCC_tCt_:
 7896         buffer = gst_buffer_new_and_alloc (size);
 7897         gst_buffer_fill (buffer, 0, buf, size);
 7898         stream-&gt;buffers = g_slist_append (stream-&gt;buffers, buffer);
 7899         GST_LOG_OBJECT (qtdemux, &quot;parsing theora comment&quot;);
 7900         break;
 7901       case FOURCC_tCtC:
 7902         buffer = gst_buffer_new_and_alloc (size);
 7903         gst_buffer_fill (buffer, 0, buf, size);
 7904         stream-&gt;buffers = g_slist_append (stream-&gt;buffers, buffer);
 7905         GST_LOG_OBJECT (qtdemux, &quot;parsing theora codebook&quot;);
 7906         break;
 7907       default:
 7908         GST_WARNING_OBJECT (qtdemux,
 7909             &quot;unknown theora cookie %&quot; GST_FOURCC_FORMAT,
 7910             GST_FOURCC_ARGS (type));
 7911         break;
 7912     }
 7913     buf += size;
 7914   }
 7915   return TRUE;
 7916 }
 7917 
 7918 static gboolean
 7919 qtdemux_parse_node (GstQTDemux * qtdemux, GNode * node, const guint8 * buffer,
 7920     guint length)
 7921 {
 7922   guint32 fourcc = 0;
 7923   guint32 node_length = 0;
 7924   const QtNodeType *type;
 7925   const guint8 *end;
 7926 
 7927   GST_LOG_OBJECT (qtdemux, &quot;qtdemux_parse buffer %p length %u&quot;, buffer, length);
 7928 
 7929   if (G_UNLIKELY (length &lt; 8))
 7930     goto not_enough_data;
 7931 
 7932   node_length = QT_UINT32 (buffer);
 7933   fourcc = QT_FOURCC (buffer + 4);
 7934 
 7935   /* ignore empty nodes */
 7936   if (G_UNLIKELY (fourcc == 0 || node_length == 8))
 7937     return TRUE;
 7938 
 7939   type = qtdemux_type_get (fourcc);
 7940 
 7941   end = buffer + length;
 7942 
 7943   GST_LOG_OBJECT (qtdemux,
 7944       &quot;parsing &#39;%&quot; GST_FOURCC_FORMAT &quot;&#39;, length=%u, name &#39;%s&#39;&quot;,
 7945       GST_FOURCC_ARGS (fourcc), node_length, type-&gt;name);
 7946 
 7947   if (node_length &gt; length)
 7948     goto broken_atom_size;
 7949 
 7950   if (type-&gt;flags &amp; QT_FLAG_CONTAINER) {
 7951     qtdemux_parse_container (qtdemux, node, buffer + 8, end);
 7952   } else {
 7953     switch (fourcc) {
 7954       case FOURCC_stsd:
 7955       {
 7956         if (node_length &lt; 20) {
 7957           GST_LOG_OBJECT (qtdemux, &quot;skipping small stsd box&quot;);
 7958           break;
 7959         }
 7960         GST_DEBUG_OBJECT (qtdemux,
 7961             &quot;parsing stsd (sample table, sample description) atom&quot;);
 7962         /* Skip over 8 byte atom hdr + 1 byte version, 3 bytes flags, 4 byte num_entries */
 7963         qtdemux_parse_container (qtdemux, node, buffer + 16, end);
 7964         break;
 7965       }
 7966       case FOURCC_mp4a:
 7967       case FOURCC_alac:
 7968       case FOURCC_fLaC:
 7969       {
 7970         guint32 version;
 7971         guint32 offset;
 7972         guint min_size;
 7973 
 7974         /* also read alac (or whatever) in stead of mp4a in the following,
 7975          * since a similar layout is used in other cases as well */
 7976         if (fourcc == FOURCC_mp4a)
 7977           min_size = 20;
 7978         else if (fourcc == FOURCC_fLaC)
 7979           min_size = 86;
 7980         else
 7981           min_size = 40;
 7982 
 7983         /* There are two things we might encounter here: a true mp4a atom, and
 7984            an mp4a entry in an stsd atom. The latter is what we&#39;re interested
 7985            in, and it looks like an atom, but isn&#39;t really one. The true mp4a
 7986            atom is short, so we detect it based on length here. */
 7987         if (length &lt; min_size) {
 7988           GST_LOG_OBJECT (qtdemux, &quot;skipping small %&quot; GST_FOURCC_FORMAT &quot; box&quot;,
 7989               GST_FOURCC_ARGS (fourcc));
 7990           break;
 7991         }
 7992 
 7993         /* &#39;version&#39; here is the sound sample description version. Types 0 and
 7994            1 are documented in the QTFF reference, but type 2 is not: it&#39;s
 7995            described in Apple header files instead (struct SoundDescriptionV2
 7996            in Movies.h) */
 7997         version = QT_UINT16 (buffer + 16);
 7998 
 7999         GST_DEBUG_OBJECT (qtdemux, &quot;%&quot; GST_FOURCC_FORMAT &quot; version 0x%08x&quot;,
 8000             GST_FOURCC_ARGS (fourcc), version);
 8001 
 8002         /* parse any esds descriptors */
 8003         switch (version) {
 8004           case 0:
 8005             offset = 0x24;
 8006             break;
 8007           case 1:
 8008             offset = 0x34;
 8009             break;
 8010           case 2:
 8011             offset = 0x48;
 8012             break;
 8013           default:
 8014             GST_WARNING_OBJECT (qtdemux,
 8015                 &quot;unhandled %&quot; GST_FOURCC_FORMAT &quot; version 0x%08x&quot;,
 8016                 GST_FOURCC_ARGS (fourcc), version);
 8017             offset = 0;
 8018             break;
 8019         }
 8020         if (offset)
 8021           qtdemux_parse_container (qtdemux, node, buffer + offset, end);
 8022         break;
 8023       }
 8024       case FOURCC_mp4v:
 8025       case FOURCC_MP4V:
 8026       case FOURCC_fmp4:
 8027       case FOURCC_FMP4:
 8028       case FOURCC_apcs:
 8029       case FOURCC_apch:
 8030       case FOURCC_apcn:
 8031       case FOURCC_apco:
 8032       case FOURCC_ap4h:
 8033       case FOURCC_xvid:
 8034       case FOURCC_XVID:
 8035       case FOURCC_H264:
 8036       case FOURCC_avc1:
 8037       case FOURCC_avc3:
 8038       case FOURCC_H265:
 8039       case FOURCC_hvc1:
 8040       case FOURCC_hev1:
 8041       case FOURCC_mjp2:
 8042       case FOURCC_encv:
 8043       {
 8044         guint32 version;
 8045         guint32 str_len;
 8046 
 8047         /* codec_data is contained inside these atoms, which all have
 8048          * the same format. */
 8049         /* video sample description size is 86 bytes without extension.
 8050          * node_length have to be bigger than 86 bytes because video sample
 8051          * description can include extenstions such as esds, fiel, glbl, etc. */
 8052         if (node_length &lt; 86) {
 8053           GST_WARNING_OBJECT (qtdemux, &quot;%&quot; GST_FOURCC_FORMAT
 8054               &quot; sample description length too short (%u &lt; 86)&quot;,
 8055               GST_FOURCC_ARGS (fourcc), node_length);
 8056           break;
 8057         }
 8058 
 8059         GST_DEBUG_OBJECT (qtdemux, &quot;parsing in %&quot; GST_FOURCC_FORMAT,
 8060             GST_FOURCC_ARGS (fourcc));
 8061 
 8062         /* version (2 bytes) : this is set to 0, unless a compressor has changed
 8063          *              its data format.
 8064          * revision level (2 bytes) : must be set to 0. */
 8065         version = QT_UINT32 (buffer + 16);
 8066         GST_DEBUG_OBJECT (qtdemux, &quot;version %08x&quot;, version);
 8067 
 8068         /* compressor name : PASCAL string and informative purposes
 8069          * first byte : the number of bytes to be displayed.
 8070          *              it has to be less than 32 because it is reserved
 8071          *              space of 32 bytes total including itself. */
 8072         str_len = QT_UINT8 (buffer + 50);
 8073         if (str_len &lt; 32)
 8074           GST_DEBUG_OBJECT (qtdemux, &quot;compressorname = %.*s&quot;, str_len,
 8075               (char *) buffer + 51);
 8076         else
 8077           GST_WARNING_OBJECT (qtdemux,
 8078               &quot;compressorname length too big (%u &gt; 31)&quot;, str_len);
 8079 
 8080         GST_MEMDUMP_OBJECT (qtdemux, &quot;video sample description&quot;, buffer,
 8081             end - buffer);
 8082         qtdemux_parse_container (qtdemux, node, buffer + 86, end);
 8083         break;
 8084       }
 8085       case FOURCC_meta:
 8086       {
 8087         GST_DEBUG_OBJECT (qtdemux, &quot;parsing meta atom&quot;);
 8088 
 8089         /* You are reading this correctly. QTFF specifies that the
 8090          * metadata atom is a short atom, whereas ISO BMFF specifies
 8091          * it&#39;s a full atom. But since so many people are doing things
 8092          * differently, we actually peek into the atom to see which
 8093          * variant it is */
 8094         if (length &lt; 16) {
 8095           GST_LOG_OBJECT (qtdemux, &quot;skipping small %&quot; GST_FOURCC_FORMAT &quot; box&quot;,
 8096               GST_FOURCC_ARGS (fourcc));
 8097           break;
 8098         }
 8099         if (QT_FOURCC (buffer + 12) == FOURCC_hdlr) {
 8100           /* Variant 1: What QTFF specifies. &#39;meta&#39; is a short header which
 8101            * starts with a &#39;hdlr&#39; atom */
 8102           qtdemux_parse_container (qtdemux, node, buffer + 8, end);
 8103         } else if (QT_UINT32 (buffer + 8) == 0x00000000) {
 8104           /* Variant 2: What ISO BMFF specifies. &#39;meta&#39; is a _full_ atom
 8105            * with version/flags both set to zero */
<a name="290" id="anc290"></a><span class="line-modified"> 8106           qtdemux_parse_container (qtdemux, node, buffer + 12, end);</span>
 8107         } else
 8108           GST_WARNING_OBJECT (qtdemux, &quot;Unknown &#39;meta&#39; atom format&quot;);
 8109         break;
 8110       }
 8111       case FOURCC_mp4s:
 8112       {
 8113         GST_MEMDUMP_OBJECT (qtdemux, &quot;mp4s&quot;, buffer, end - buffer);
 8114         /* Skip 8 byte header, plus 8 byte version + flags + entry_count */
 8115         qtdemux_parse_container (qtdemux, node, buffer + 16, end);
 8116         break;
 8117       }
 8118       case FOURCC_XiTh:
 8119       {
 8120         guint32 version;
 8121         guint32 offset;
 8122 
 8123         if (length &lt; 16) {
 8124           GST_LOG_OBJECT (qtdemux, &quot;skipping small %&quot; GST_FOURCC_FORMAT &quot; box&quot;,
 8125               GST_FOURCC_ARGS (fourcc));
 8126           break;
 8127         }
 8128 
 8129         version = QT_UINT32 (buffer + 12);
 8130         GST_DEBUG_OBJECT (qtdemux, &quot;parsing XiTh atom version 0x%08x&quot;, version);
 8131 
 8132         switch (version) {
 8133           case 0x00000001:
 8134             offset = 0x62;
 8135             break;
 8136           default:
 8137             GST_DEBUG_OBJECT (qtdemux, &quot;unknown version 0x%08x&quot;, version);
 8138             offset = 0;
 8139             break;
 8140         }
 8141         if (offset) {
 8142           if (length &lt; offset) {
 8143             GST_WARNING_OBJECT (qtdemux,
 8144                 &quot;skipping too small %&quot; GST_FOURCC_FORMAT &quot; box&quot;,
 8145                 GST_FOURCC_ARGS (fourcc));
 8146             break;
 8147           }
 8148           qtdemux_parse_container (qtdemux, node, buffer + offset, end);
 8149         }
 8150         break;
 8151       }
 8152       case FOURCC_in24:
 8153       {
 8154         qtdemux_parse_container (qtdemux, node, buffer + 0x34, end);
 8155         break;
 8156       }
 8157       case FOURCC_uuid:
 8158       {
 8159         qtdemux_parse_uuid (qtdemux, buffer, end - buffer);
 8160         break;
 8161       }
 8162       case FOURCC_enca:
 8163       {
 8164         qtdemux_parse_container (qtdemux, node, buffer + 36, end);
 8165         break;
 8166       }
 8167       default:
 8168         if (!strcmp (type-&gt;name, &quot;unknown&quot;))
 8169           GST_MEMDUMP (&quot;Unknown tag&quot;, buffer + 4, end - buffer - 4);
 8170         break;
 8171     }
 8172   }
 8173   GST_LOG_OBJECT (qtdemux, &quot;parsed &#39;%&quot; GST_FOURCC_FORMAT &quot;&#39;&quot;,
 8174       GST_FOURCC_ARGS (fourcc));
 8175   return TRUE;
 8176 
 8177 /* ERRORS */
 8178 not_enough_data:
 8179   {
 8180     GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
 8181         (_(&quot;This file is corrupt and cannot be played.&quot;)),
 8182         (&quot;Not enough data for an atom header, got only %u bytes&quot;, length));
 8183     return FALSE;
 8184   }
 8185 broken_atom_size:
 8186   {
 8187     GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
 8188         (_(&quot;This file is corrupt and cannot be played.&quot;)),
 8189         (&quot;Atom &#39;%&quot; GST_FOURCC_FORMAT &quot;&#39; has size of %u bytes, but we have only &quot;
 8190             &quot;%u bytes available.&quot;, GST_FOURCC_ARGS (fourcc), node_length,
 8191             length));
 8192     return FALSE;
 8193   }
 8194 }
 8195 
 8196 static GNode *
 8197 qtdemux_tree_get_child_by_type (GNode * node, guint32 fourcc)
 8198 {
 8199   GNode *child;
 8200   guint8 *buffer;
 8201   guint32 child_fourcc;
 8202 
 8203   for (child = g_node_first_child (node); child;
 8204       child = g_node_next_sibling (child)) {
 8205     buffer = (guint8 *) child-&gt;data;
 8206 
 8207     child_fourcc = QT_FOURCC (buffer + 4);
 8208 
 8209     if (G_UNLIKELY (child_fourcc == fourcc)) {
 8210       return child;
 8211     }
 8212   }
 8213   return NULL;
 8214 }
 8215 
 8216 static GNode *
 8217 qtdemux_tree_get_child_by_type_full (GNode * node, guint32 fourcc,
 8218     GstByteReader * parser)
 8219 {
 8220   GNode *child;
 8221   guint8 *buffer;
 8222   guint32 child_fourcc, child_len;
 8223 
 8224   for (child = g_node_first_child (node); child;
 8225       child = g_node_next_sibling (child)) {
 8226     buffer = (guint8 *) child-&gt;data;
 8227 
 8228     child_len = QT_UINT32 (buffer);
 8229     child_fourcc = QT_FOURCC (buffer + 4);
 8230 
 8231     if (G_UNLIKELY (child_fourcc == fourcc)) {
 8232       if (G_UNLIKELY (child_len &lt; (4 + 4)))
 8233         return NULL;
 8234       /* FIXME: must verify if atom length &lt; parent atom length */
 8235       gst_byte_reader_init (parser, buffer + (4 + 4), child_len - (4 + 4));
 8236       return child;
 8237     }
 8238   }
 8239   return NULL;
 8240 }
 8241 
 8242 static GNode *
 8243 qtdemux_tree_get_child_by_index (GNode * node, guint index)
 8244 {
 8245   return g_node_nth_child (node, index);
 8246 }
 8247 
 8248 static GNode *
 8249 qtdemux_tree_get_sibling_by_type_full (GNode * node, guint32 fourcc,
 8250     GstByteReader * parser)
 8251 {
 8252   GNode *child;
 8253   guint8 *buffer;
 8254   guint32 child_fourcc, child_len;
 8255 
 8256   for (child = g_node_next_sibling (node); child;
 8257       child = g_node_next_sibling (child)) {
 8258     buffer = (guint8 *) child-&gt;data;
 8259 
 8260     child_fourcc = QT_FOURCC (buffer + 4);
 8261 
 8262     if (child_fourcc == fourcc) {
 8263       if (parser) {
 8264         child_len = QT_UINT32 (buffer);
 8265         if (G_UNLIKELY (child_len &lt; (4 + 4)))
 8266           return NULL;
 8267         /* FIXME: must verify if atom length &lt; parent atom length */
 8268         gst_byte_reader_init (parser, buffer + (4 + 4), child_len - (4 + 4));
 8269       }
 8270       return child;
 8271     }
 8272   }
 8273   return NULL;
 8274 }
 8275 
 8276 static GNode *
 8277 qtdemux_tree_get_sibling_by_type (GNode * node, guint32 fourcc)
 8278 {
 8279   return qtdemux_tree_get_sibling_by_type_full (node, fourcc, NULL);
 8280 }
 8281 
 8282 static void
<a name="291" id="anc291"></a><span class="line-modified"> 8283 qtdemux_do_allocation (QtDemuxStream * stream, GstQTDemux * qtdemux)</span>
 8284 {
 8285 /* FIXME: This can only reliably work if demuxers have a
 8286  * separate streaming thread per srcpad. This should be
 8287  * done in a demuxer base class, which integrates parts
 8288  * of multiqueue
 8289  *
 8290  * https://bugzilla.gnome.org/show_bug.cgi?id=701856
 8291  */
 8292 #if 0
 8293   GstQuery *query;
 8294 
 8295   query = gst_query_new_allocation (stream-&gt;caps, FALSE);
 8296 
 8297   if (!gst_pad_peer_query (stream-&gt;pad, query)) {
 8298     /* not a problem, just debug a little */
 8299     GST_DEBUG_OBJECT (qtdemux, &quot;peer ALLOCATION query failed&quot;);
 8300   }
 8301 
 8302   if (stream-&gt;allocator)
 8303     gst_object_unref (stream-&gt;allocator);
 8304 
 8305   if (gst_query_get_n_allocation_params (query) &gt; 0) {
 8306     /* try the allocator */
 8307     gst_query_parse_nth_allocation_param (query, 0, &amp;stream-&gt;allocator,
 8308         &amp;stream-&gt;params);
 8309     stream-&gt;use_allocator = TRUE;
 8310   } else {
 8311     stream-&gt;allocator = NULL;
 8312     gst_allocation_params_init (&amp;stream-&gt;params);
 8313     stream-&gt;use_allocator = FALSE;
 8314   }
 8315   gst_query_unref (query);
 8316 #endif
 8317 }
 8318 
<a name="292" id="anc292"></a><span class="line-added"> 8319 static gboolean</span>
<span class="line-added"> 8320 pad_query (const GValue * item, GValue * value, gpointer user_data)</span>
<span class="line-added"> 8321 {</span>
<span class="line-added"> 8322   GstPad *pad = g_value_get_object (item);</span>
<span class="line-added"> 8323   GstQuery *query = user_data;</span>
<span class="line-added"> 8324   gboolean res;</span>
<span class="line-added"> 8325 </span>
<span class="line-added"> 8326   res = gst_pad_peer_query (pad, query);</span>
<span class="line-added"> 8327 </span>
<span class="line-added"> 8328   if (res) {</span>
<span class="line-added"> 8329     g_value_set_boolean (value, TRUE);</span>
<span class="line-added"> 8330     return FALSE;</span>
<span class="line-added"> 8331   }</span>
<span class="line-added"> 8332 </span>
<span class="line-added"> 8333   GST_INFO_OBJECT (pad, &quot;pad peer query failed&quot;);</span>
<span class="line-added"> 8334   return TRUE;</span>
<span class="line-added"> 8335 }</span>
<span class="line-added"> 8336 </span>
<span class="line-added"> 8337 static gboolean</span>
<span class="line-added"> 8338 gst_qtdemux_run_query (GstElement * element, GstQuery * query,</span>
<span class="line-added"> 8339     GstPadDirection direction)</span>
<span class="line-added"> 8340 {</span>
<span class="line-added"> 8341   GstIterator *it;</span>
<span class="line-added"> 8342   GstIteratorFoldFunction func = pad_query;</span>
<span class="line-added"> 8343   GValue res = { 0, };</span>
<span class="line-added"> 8344 </span>
<span class="line-added"> 8345   g_value_init (&amp;res, G_TYPE_BOOLEAN);</span>
<span class="line-added"> 8346   g_value_set_boolean (&amp;res, FALSE);</span>
<span class="line-added"> 8347 </span>
<span class="line-added"> 8348   /* Ask neighbor */</span>
<span class="line-added"> 8349   if (direction == GST_PAD_SRC)</span>
<span class="line-added"> 8350     it = gst_element_iterate_src_pads (element);</span>
<span class="line-added"> 8351   else</span>
<span class="line-added"> 8352     it = gst_element_iterate_sink_pads (element);</span>
<span class="line-added"> 8353 </span>
<span class="line-added"> 8354   while (gst_iterator_fold (it, func, &amp;res, query) == GST_ITERATOR_RESYNC)</span>
<span class="line-added"> 8355     gst_iterator_resync (it);</span>
<span class="line-added"> 8356 </span>
<span class="line-added"> 8357   gst_iterator_free (it);</span>
<span class="line-added"> 8358 </span>
<span class="line-added"> 8359   return g_value_get_boolean (&amp;res);</span>
<span class="line-added"> 8360 }</span>
<span class="line-added"> 8361 </span>
<span class="line-added"> 8362 static void</span>
<span class="line-added"> 8363 gst_qtdemux_request_protection_context (GstQTDemux * qtdemux,</span>
<span class="line-added"> 8364     QtDemuxStream * stream)</span>
<span class="line-added"> 8365 {</span>
<span class="line-added"> 8366   GstQuery *query;</span>
<span class="line-added"> 8367   GstContext *ctxt;</span>
<span class="line-added"> 8368   GstElement *element = GST_ELEMENT (qtdemux);</span>
<span class="line-added"> 8369   GstStructure *st;</span>
<span class="line-added"> 8370   gchar **filtered_sys_ids;</span>
<span class="line-added"> 8371   GValue event_list = G_VALUE_INIT;</span>
<span class="line-added"> 8372   GList *walk;</span>
<span class="line-added"> 8373 </span>
<span class="line-added"> 8374   /* 1. Check if we already have the context. */</span>
<span class="line-added"> 8375   if (qtdemux-&gt;preferred_protection_system_id != NULL) {</span>
<span class="line-added"> 8376     GST_LOG_OBJECT (element,</span>
<span class="line-added"> 8377         &quot;already have the protection context, no need to request it again&quot;);</span>
<span class="line-added"> 8378     return;</span>
<span class="line-added"> 8379   }</span>
<span class="line-added"> 8380 </span>
<span class="line-added"> 8381   g_ptr_array_add (qtdemux-&gt;protection_system_ids, NULL);</span>
<span class="line-added"> 8382   filtered_sys_ids = gst_protection_filter_systems_by_available_decryptors (</span>
<span class="line-added"> 8383       (const gchar **) qtdemux-&gt;protection_system_ids-&gt;pdata);</span>
<span class="line-added"> 8384 </span>
<span class="line-added"> 8385   g_ptr_array_remove_index (qtdemux-&gt;protection_system_ids,</span>
<span class="line-added"> 8386       qtdemux-&gt;protection_system_ids-&gt;len - 1);</span>
<span class="line-added"> 8387   GST_TRACE_OBJECT (qtdemux, &quot;detected %u protection systems, we have &quot;</span>
<span class="line-added"> 8388       &quot;decryptors for %u of them, running context request&quot;,</span>
<span class="line-added"> 8389       qtdemux-&gt;protection_system_ids-&gt;len,</span>
<span class="line-added"> 8390       filtered_sys_ids ? g_strv_length (filtered_sys_ids) : 0);</span>
<span class="line-added"> 8391 </span>
<span class="line-added"> 8392 </span>
<span class="line-added"> 8393   if (stream-&gt;protection_scheme_event_queue.length) {</span>
<span class="line-added"> 8394     GST_TRACE_OBJECT (qtdemux, &quot;using stream event queue, length %u&quot;,</span>
<span class="line-added"> 8395         stream-&gt;protection_scheme_event_queue.length);</span>
<span class="line-added"> 8396     walk = stream-&gt;protection_scheme_event_queue.tail;</span>
<span class="line-added"> 8397   } else {</span>
<span class="line-added"> 8398     GST_TRACE_OBJECT (qtdemux, &quot;using demuxer event queue, length %u&quot;,</span>
<span class="line-added"> 8399         qtdemux-&gt;protection_event_queue.length);</span>
<span class="line-added"> 8400     walk = qtdemux-&gt;protection_event_queue.tail;</span>
<span class="line-added"> 8401   }</span>
<span class="line-added"> 8402 </span>
<span class="line-added"> 8403   g_value_init (&amp;event_list, GST_TYPE_LIST);</span>
<span class="line-added"> 8404   for (; walk; walk = g_list_previous (walk)) {</span>
<span class="line-added"> 8405     GValue *event_value = g_new0 (GValue, 1);</span>
<span class="line-added"> 8406     g_value_init (event_value, GST_TYPE_EVENT);</span>
<span class="line-added"> 8407     g_value_set_boxed (event_value, walk-&gt;data);</span>
<span class="line-added"> 8408     gst_value_list_append_and_take_value (&amp;event_list, event_value);</span>
<span class="line-added"> 8409   }</span>
<span class="line-added"> 8410 </span>
<span class="line-added"> 8411   /*  2a) Query downstream with GST_QUERY_CONTEXT for the context and</span>
<span class="line-added"> 8412    *      check if downstream already has a context of the specific type</span>
<span class="line-added"> 8413    *  2b) Query upstream as above.</span>
<span class="line-added"> 8414    */</span>
<span class="line-added"> 8415   query = gst_query_new_context (&quot;drm-preferred-decryption-system-id&quot;);</span>
<span class="line-added"> 8416   st = gst_query_writable_structure (query);</span>
<span class="line-added"> 8417   gst_structure_set (st, &quot;track-id&quot;, G_TYPE_UINT, stream-&gt;track_id,</span>
<span class="line-added"> 8418       &quot;available-stream-encryption-systems&quot;, G_TYPE_STRV, filtered_sys_ids,</span>
<span class="line-added"> 8419       NULL);</span>
<span class="line-added"> 8420   gst_structure_set_value (st, &quot;stream-encryption-events&quot;, &amp;event_list);</span>
<span class="line-added"> 8421   if (gst_qtdemux_run_query (element, query, GST_PAD_SRC)) {</span>
<span class="line-added"> 8422     gst_query_parse_context (query, &amp;ctxt);</span>
<span class="line-added"> 8423     GST_INFO_OBJECT (element, &quot;found context (%p) in downstream query&quot;, ctxt);</span>
<span class="line-added"> 8424     gst_element_set_context (element, ctxt);</span>
<span class="line-added"> 8425   } else if (gst_qtdemux_run_query (element, query, GST_PAD_SINK)) {</span>
<span class="line-added"> 8426     gst_query_parse_context (query, &amp;ctxt);</span>
<span class="line-added"> 8427     GST_INFO_OBJECT (element, &quot;found context (%p) in upstream query&quot;, ctxt);</span>
<span class="line-added"> 8428     gst_element_set_context (element, ctxt);</span>
<span class="line-added"> 8429   } else {</span>
<span class="line-added"> 8430     /* 3) Post a GST_MESSAGE_NEED_CONTEXT message on the bus with</span>
<span class="line-added"> 8431      *    the required context type and afterwards check if a</span>
<span class="line-added"> 8432      *    usable context was set now as in 1). The message could</span>
<span class="line-added"> 8433      *    be handled by the parent bins of the element and the</span>
<span class="line-added"> 8434      *    application.</span>
<span class="line-added"> 8435      */</span>
<span class="line-added"> 8436     GstMessage *msg;</span>
<span class="line-added"> 8437 </span>
<span class="line-added"> 8438     GST_INFO_OBJECT (element, &quot;posting need context message&quot;);</span>
<span class="line-added"> 8439     msg = gst_message_new_need_context (GST_OBJECT_CAST (element),</span>
<span class="line-added"> 8440         &quot;drm-preferred-decryption-system-id&quot;);</span>
<span class="line-added"> 8441     st = (GstStructure *) gst_message_get_structure (msg);</span>
<span class="line-added"> 8442     gst_structure_set (st, &quot;track-id&quot;, G_TYPE_UINT, stream-&gt;track_id,</span>
<span class="line-added"> 8443         &quot;available-stream-encryption-systems&quot;, G_TYPE_STRV, filtered_sys_ids,</span>
<span class="line-added"> 8444         NULL);</span>
<span class="line-added"> 8445 </span>
<span class="line-added"> 8446     gst_structure_set_value (st, &quot;stream-encryption-events&quot;, &amp;event_list);</span>
<span class="line-added"> 8447     gst_element_post_message (element, msg);</span>
<span class="line-added"> 8448   }</span>
<span class="line-added"> 8449 </span>
<span class="line-added"> 8450   g_strfreev (filtered_sys_ids);</span>
<span class="line-added"> 8451   g_value_unset (&amp;event_list);</span>
<span class="line-added"> 8452   gst_query_unref (query);</span>
<span class="line-added"> 8453 }</span>
<span class="line-added"> 8454 </span>
 8455 static gboolean
 8456 gst_qtdemux_configure_protected_caps (GstQTDemux * qtdemux,
 8457     QtDemuxStream * stream)
 8458 {
 8459   GstStructure *s;
<a name="293" id="anc293"></a><span class="line-modified"> 8460   const gchar *selected_system = NULL;</span>
 8461 
 8462   g_return_val_if_fail (qtdemux != NULL, FALSE);
 8463   g_return_val_if_fail (stream != NULL, FALSE);
 8464   g_return_val_if_fail (gst_caps_get_size (CUR_STREAM (stream)-&gt;caps) == 1,
 8465       FALSE);
 8466 
 8467   if (stream-&gt;protection_scheme_type != FOURCC_cenc) {
<a name="294" id="anc294"></a><span class="line-modified"> 8468     GST_ERROR_OBJECT (qtdemux,</span>
<span class="line-added"> 8469         &quot;unsupported protection scheme: %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-added"> 8470         GST_FOURCC_ARGS (stream-&gt;protection_scheme_type));</span>
 8471     return FALSE;
 8472   }
 8473   if (qtdemux-&gt;protection_system_ids == NULL) {
 8474     GST_ERROR_OBJECT (qtdemux, &quot;stream is protected using cenc, but no &quot;
 8475         &quot;cenc protection system information has been found&quot;);
 8476     return FALSE;
 8477   }
<a name="295" id="anc295"></a><span class="line-modified"> 8478 </span>
<span class="line-modified"> 8479   gst_qtdemux_request_protection_context (qtdemux, stream);</span>
<span class="line-modified"> 8480   if (qtdemux-&gt;preferred_protection_system_id != NULL) {</span>
<span class="line-modified"> 8481     const gchar *preferred_system_array[] =</span>
<span class="line-modified"> 8482         { qtdemux-&gt;preferred_protection_system_id, NULL };</span>
<span class="line-added"> 8483 </span>
<span class="line-added"> 8484     selected_system = gst_protection_select_system (preferred_system_array);</span>
<span class="line-added"> 8485 </span>
<span class="line-added"> 8486     if (selected_system) {</span>
<span class="line-added"> 8487       GST_TRACE_OBJECT (qtdemux, &quot;selected preferred system %s&quot;,</span>
<span class="line-added"> 8488           qtdemux-&gt;preferred_protection_system_id);</span>
<span class="line-added"> 8489     } else {</span>
<span class="line-added"> 8490       GST_WARNING_OBJECT (qtdemux, &quot;could not select preferred system %s &quot;</span>
<span class="line-added"> 8491           &quot;because there is no available decryptor&quot;,</span>
<span class="line-added"> 8492           qtdemux-&gt;preferred_protection_system_id);</span>
<span class="line-added"> 8493     }</span>
<span class="line-added"> 8494   }</span>
<span class="line-added"> 8495 </span>
<span class="line-added"> 8496   if (!selected_system) {</span>
<span class="line-added"> 8497     g_ptr_array_add (qtdemux-&gt;protection_system_ids, NULL);</span>
<span class="line-added"> 8498     selected_system = gst_protection_select_system ((const gchar **)</span>
<span class="line-added"> 8499         qtdemux-&gt;protection_system_ids-&gt;pdata);</span>
<span class="line-added"> 8500     g_ptr_array_remove_index (qtdemux-&gt;protection_system_ids,</span>
<span class="line-added"> 8501         qtdemux-&gt;protection_system_ids-&gt;len - 1);</span>
<span class="line-added"> 8502   }</span>
<span class="line-added"> 8503 </span>
 8504   if (!selected_system) {
 8505     GST_ERROR_OBJECT (qtdemux, &quot;stream is protected, but no &quot;
 8506         &quot;suitable decryptor element has been found&quot;);
 8507     return FALSE;
 8508   }
 8509 
<a name="296" id="anc296"></a><span class="line-added"> 8510   GST_DEBUG_OBJECT (qtdemux, &quot;selected protection system is %s&quot;,</span>
<span class="line-added"> 8511       selected_system);</span>
<span class="line-added"> 8512 </span>
 8513   s = gst_caps_get_structure (CUR_STREAM (stream)-&gt;caps, 0);
 8514   if (!gst_structure_has_name (s, &quot;application/x-cenc&quot;)) {
 8515     gst_structure_set (s,
 8516         &quot;original-media-type&quot;, G_TYPE_STRING, gst_structure_get_name (s),
 8517         GST_PROTECTION_SYSTEM_ID_CAPS_FIELD, G_TYPE_STRING, selected_system,
 8518         NULL);
 8519     gst_structure_set_name (s, &quot;application/x-cenc&quot;);
 8520   }
 8521   return TRUE;
 8522 }
 8523 
 8524 static gboolean
<a name="297" id="anc297"></a><span class="line-modified"> 8525 gst_qtdemux_guess_framerate (GstQTDemux * qtdemux, QtDemuxStream * stream)</span>
 8526 {
<a name="298" id="anc298"></a><span class="line-modified"> 8527   /* fps is calculated base on the duration of the average framerate since</span>
<span class="line-modified"> 8528    * qt does not have a fixed framerate. */</span>
<span class="line-modified"> 8529   gboolean fps_available = TRUE;</span>
<span class="line-modified"> 8530   guint32 first_duration = 0;</span>
<span class="line-modified"> 8531 </span>
<span class="line-modified"> 8532   if (stream-&gt;n_samples &gt; 0)</span>
<span class="line-modified"> 8533     first_duration = stream-&gt;samples[0].duration;</span>
<span class="line-modified"> 8534 </span>
<span class="line-modified"> 8535   if ((stream-&gt;n_samples == 1 &amp;&amp; first_duration == 0)</span>
<span class="line-added"> 8536       || (qtdemux-&gt;fragmented &amp;&amp; stream-&gt;n_samples_moof == 1)) {</span>
<span class="line-added"> 8537     /* still frame */</span>
<span class="line-added"> 8538     CUR_STREAM (stream)-&gt;fps_n = 0;</span>
<span class="line-added"> 8539     CUR_STREAM (stream)-&gt;fps_d = 1;</span>
<span class="line-added"> 8540   } else {</span>
<span class="line-added"> 8541     if (stream-&gt;duration == 0 || stream-&gt;n_samples &lt; 2) {</span>
<span class="line-added"> 8542       CUR_STREAM (stream)-&gt;fps_n = stream-&gt;timescale;</span>
 8543       CUR_STREAM (stream)-&gt;fps_d = 1;
<a name="299" id="anc299"></a><span class="line-added"> 8544       fps_available = FALSE;</span>
 8545     } else {
<a name="300" id="anc300"></a><span class="line-modified"> 8546       GstClockTime avg_duration;</span>
<span class="line-modified"> 8547       guint64 duration;</span>
<span class="line-modified"> 8548       guint32 n_samples;</span>
<span class="line-modified"> 8549 </span>
<span class="line-added"> 8550       /* duration and n_samples can be updated for fragmented format</span>
<span class="line-added"> 8551        * so, framerate of fragmented format is calculated using data in a moof */</span>
<span class="line-added"> 8552       if (qtdemux-&gt;fragmented &amp;&amp; stream-&gt;n_samples_moof &gt; 0</span>
<span class="line-added"> 8553           &amp;&amp; stream-&gt;duration_moof &gt; 0) {</span>
<span class="line-added"> 8554         n_samples = stream-&gt;n_samples_moof;</span>
<span class="line-added"> 8555         duration = stream-&gt;duration_moof;</span>
 8556       } else {
<a name="301" id="anc301"></a><span class="line-modified"> 8557         n_samples = stream-&gt;n_samples;</span>
<span class="line-modified"> 8558         duration = stream-&gt;duration;</span>
<span class="line-modified"> 8559       }</span>











 8560 
<a name="302" id="anc302"></a><span class="line-modified"> 8561       /* Calculate a framerate, ignoring the first sample which is sometimes truncated */</span>
<span class="line-modified"> 8562       /* stream-&gt;duration is guint64, timescale, n_samples are guint32 */</span>
<span class="line-modified"> 8563       avg_duration =</span>
<span class="line-modified"> 8564           gst_util_uint64_scale_round (duration -</span>
<span class="line-modified"> 8565           first_duration, GST_SECOND,</span>
<span class="line-modified"> 8566           (guint64) (stream-&gt;timescale) * (n_samples - 1));</span>
 8567 
<a name="303" id="anc303"></a><span class="line-modified"> 8568       GST_LOG_OBJECT (qtdemux,</span>
<span class="line-modified"> 8569           &quot;Calculating avg sample duration based on stream (or moof) duration %&quot;</span>
<span class="line-modified"> 8570           G_GUINT64_FORMAT</span>
<span class="line-modified"> 8571           &quot; minus first sample %u, leaving %d samples gives %&quot;</span>
<span class="line-modified"> 8572           GST_TIME_FORMAT, duration, first_duration,</span>
<span class="line-modified"> 8573           n_samples - 1, GST_TIME_ARGS (avg_duration));</span>
 8574 
<a name="304" id="anc304"></a><span class="line-modified"> 8575       fps_available =</span>
<span class="line-modified"> 8576           gst_video_guess_framerate (avg_duration,</span>
<span class="line-added"> 8577           &amp;CUR_STREAM (stream)-&gt;fps_n, &amp;CUR_STREAM (stream)-&gt;fps_d);</span>
 8578 
<a name="305" id="anc305"></a><span class="line-modified"> 8579       GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-modified"> 8580           &quot;Calculating framerate, timescale %u gave fps_n %d fps_d %d&quot;,</span>
<span class="line-modified"> 8581           stream-&gt;timescale, CUR_STREAM (stream)-&gt;fps_n,</span>
<span class="line-modified"> 8582           CUR_STREAM (stream)-&gt;fps_d);</span>

 8583     }
<a name="306" id="anc306"></a><span class="line-added"> 8584   }</span>
<span class="line-added"> 8585 </span>
<span class="line-added"> 8586   return fps_available;</span>
<span class="line-added"> 8587 }</span>
<span class="line-added"> 8588 </span>
<span class="line-added"> 8589 static gboolean</span>
<span class="line-added"> 8590 gst_qtdemux_configure_stream (GstQTDemux * qtdemux, QtDemuxStream * stream)</span>
<span class="line-added"> 8591 {</span>
<span class="line-added"> 8592   if (stream-&gt;subtype == FOURCC_vide) {</span>
<span class="line-added"> 8593     gboolean fps_available = gst_qtdemux_guess_framerate (qtdemux, stream);</span>
 8594 
 8595     if (CUR_STREAM (stream)-&gt;caps) {
 8596       CUR_STREAM (stream)-&gt;caps =
 8597           gst_caps_make_writable (CUR_STREAM (stream)-&gt;caps);
 8598 
<a name="307" id="anc307"></a><span class="line-modified"> 8599       if (CUR_STREAM (stream)-&gt;width &amp;&amp; CUR_STREAM (stream)-&gt;height)</span>
<span class="line-modified"> 8600         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,</span>
<span class="line-modified"> 8601             &quot;width&quot;, G_TYPE_INT, CUR_STREAM (stream)-&gt;width,</span>
<span class="line-added"> 8602             &quot;height&quot;, G_TYPE_INT, CUR_STREAM (stream)-&gt;height, NULL);</span>
 8603 
 8604       /* set framerate if calculated framerate is reliable */
 8605       if (fps_available) {
 8606         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,
 8607             &quot;framerate&quot;, GST_TYPE_FRACTION, CUR_STREAM (stream)-&gt;fps_n,
 8608             CUR_STREAM (stream)-&gt;fps_d, NULL);
 8609       }
 8610 
 8611       /* calculate pixel-aspect-ratio using display width and height */
 8612       GST_DEBUG_OBJECT (qtdemux,
 8613           &quot;video size %dx%d, target display size %dx%d&quot;,
 8614           CUR_STREAM (stream)-&gt;width, CUR_STREAM (stream)-&gt;height,
 8615           stream-&gt;display_width, stream-&gt;display_height);
 8616       /* qt file might have pasp atom */
 8617       if (CUR_STREAM (stream)-&gt;par_w &gt; 0 &amp;&amp; CUR_STREAM (stream)-&gt;par_h &gt; 0) {
 8618         GST_DEBUG_OBJECT (qtdemux, &quot;par %d:%d&quot;, CUR_STREAM (stream)-&gt;par_w,
 8619             CUR_STREAM (stream)-&gt;par_h);
 8620         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;pixel-aspect-ratio&quot;,
 8621             GST_TYPE_FRACTION, CUR_STREAM (stream)-&gt;par_w,
 8622             CUR_STREAM (stream)-&gt;par_h, NULL);
 8623       } else if (stream-&gt;display_width &gt; 0 &amp;&amp; stream-&gt;display_height &gt; 0
 8624           &amp;&amp; CUR_STREAM (stream)-&gt;width &gt; 0
 8625           &amp;&amp; CUR_STREAM (stream)-&gt;height &gt; 0) {
 8626         gint n, d;
 8627 
 8628         /* calculate the pixel aspect ratio using the display and pixel w/h */
 8629         n = stream-&gt;display_width * CUR_STREAM (stream)-&gt;height;
 8630         d = stream-&gt;display_height * CUR_STREAM (stream)-&gt;width;
 8631         if (n == d)
 8632           n = d = 1;
 8633         GST_DEBUG_OBJECT (qtdemux, &quot;setting PAR to %d/%d&quot;, n, d);
 8634         CUR_STREAM (stream)-&gt;par_w = n;
 8635         CUR_STREAM (stream)-&gt;par_h = d;
 8636         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;pixel-aspect-ratio&quot;,
 8637             GST_TYPE_FRACTION, CUR_STREAM (stream)-&gt;par_w,
 8638             CUR_STREAM (stream)-&gt;par_h, NULL);
 8639       }
 8640 
 8641       if (CUR_STREAM (stream)-&gt;interlace_mode &gt; 0) {
 8642         if (CUR_STREAM (stream)-&gt;interlace_mode == 1) {
 8643           gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;interlace-mode&quot;,
 8644               G_TYPE_STRING, &quot;progressive&quot;, NULL);
 8645         } else if (CUR_STREAM (stream)-&gt;interlace_mode == 2) {
 8646           gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;interlace-mode&quot;,
 8647               G_TYPE_STRING, &quot;interleaved&quot;, NULL);
 8648           if (CUR_STREAM (stream)-&gt;field_order == 9) {
 8649             gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;field-order&quot;,
 8650                 G_TYPE_STRING, &quot;top-field-first&quot;, NULL);
 8651           } else if (CUR_STREAM (stream)-&gt;field_order == 14) {
 8652             gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;field-order&quot;,
 8653                 G_TYPE_STRING, &quot;bottom-field-first&quot;, NULL);
<a name="308" id="anc308"></a><span class="line-modified"> 8654           }</span>
<span class="line-modified"> 8655         }</span>
 8656       }
 8657 
 8658       /* Create incomplete colorimetry here if needed */
 8659       if (CUR_STREAM (stream)-&gt;colorimetry.range ||
 8660           CUR_STREAM (stream)-&gt;colorimetry.matrix ||
 8661           CUR_STREAM (stream)-&gt;colorimetry.transfer
 8662           || CUR_STREAM (stream)-&gt;colorimetry.primaries) {
 8663         gchar *colorimetry =
 8664             gst_video_colorimetry_to_string (&amp;CUR_STREAM (stream)-&gt;colorimetry);
 8665         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;colorimetry&quot;,
 8666             G_TYPE_STRING, colorimetry, NULL);
 8667         g_free (colorimetry);
 8668       }
 8669 
 8670       if (stream-&gt;multiview_mode != GST_VIDEO_MULTIVIEW_MODE_NONE) {
 8671         guint par_w = 1, par_h = 1;
 8672 
 8673         if (CUR_STREAM (stream)-&gt;par_w &gt; 0 &amp;&amp; CUR_STREAM (stream)-&gt;par_h &gt; 0) {
 8674           par_w = CUR_STREAM (stream)-&gt;par_w;
 8675           par_h = CUR_STREAM (stream)-&gt;par_h;
 8676         }
 8677 
 8678         if (gst_video_multiview_guess_half_aspect (stream-&gt;multiview_mode,
 8679                 CUR_STREAM (stream)-&gt;width, CUR_STREAM (stream)-&gt;height, par_w,
 8680                 par_h)) {
 8681           stream-&gt;multiview_flags |= GST_VIDEO_MULTIVIEW_FLAGS_HALF_ASPECT;
 8682         }
 8683 
 8684         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,
 8685             &quot;multiview-mode&quot;, G_TYPE_STRING,
 8686             gst_video_multiview_mode_to_caps_string (stream-&gt;multiview_mode),
 8687             &quot;multiview-flags&quot;, GST_TYPE_VIDEO_MULTIVIEW_FLAGSET,
 8688             stream-&gt;multiview_flags, GST_FLAG_SET_MASK_EXACT, NULL);
 8689       }
 8690     }
 8691   }
 8692 
 8693   else if (stream-&gt;subtype == FOURCC_soun) {
 8694     if (CUR_STREAM (stream)-&gt;caps) {
 8695       CUR_STREAM (stream)-&gt;caps =
 8696           gst_caps_make_writable (CUR_STREAM (stream)-&gt;caps);
 8697       if (CUR_STREAM (stream)-&gt;rate &gt; 0)
 8698         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,
 8699             &quot;rate&quot;, G_TYPE_INT, (int) CUR_STREAM (stream)-&gt;rate, NULL);
 8700       if (CUR_STREAM (stream)-&gt;n_channels &gt; 0)
 8701         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,
 8702             &quot;channels&quot;, G_TYPE_INT, CUR_STREAM (stream)-&gt;n_channels, NULL);
 8703       if (CUR_STREAM (stream)-&gt;n_channels &gt; 2) {
 8704         /* FIXME: Need to parse the &#39;chan&#39; atom to get channel layouts
 8705          * correctly; this is just the minimum we can do - assume
 8706          * we don&#39;t actually have any channel positions. */
 8707         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,
 8708             &quot;channel-mask&quot;, GST_TYPE_BITMASK, G_GUINT64_CONSTANT (0), NULL);
 8709       }
 8710     }
 8711   }
 8712 
<a name="309" id="anc309"></a><span class="line-added"> 8713   else if (stream-&gt;subtype == FOURCC_clcp &amp;&amp; CUR_STREAM (stream)-&gt;caps) {</span>
<span class="line-added"> 8714     const GstStructure *s;</span>
<span class="line-added"> 8715     QtDemuxStream *fps_stream = NULL;</span>
<span class="line-added"> 8716     gboolean fps_available = FALSE;</span>
<span class="line-added"> 8717 </span>
<span class="line-added"> 8718     /* CEA608 closed caption tracks are a bit special in that each sample</span>
<span class="line-added"> 8719      * can contain CCs for multiple frames, and CCs can be omitted and have to</span>
<span class="line-added"> 8720      * be inferred from the duration of the sample then.</span>
<span class="line-added"> 8721      *</span>
<span class="line-added"> 8722      * As such we take the framerate from the (first) video track here for</span>
<span class="line-added"> 8723      * CEA608 as there must be one CC byte pair for every video frame</span>
<span class="line-added"> 8724      * according to the spec.</span>
<span class="line-added"> 8725      *</span>
<span class="line-added"> 8726      * For CEA708 all is fine and there is one sample per frame.</span>
<span class="line-added"> 8727      */</span>
<span class="line-added"> 8728 </span>
<span class="line-added"> 8729     s = gst_caps_get_structure (CUR_STREAM (stream)-&gt;caps, 0);</span>
<span class="line-added"> 8730     if (gst_structure_has_name (s, &quot;closedcaption/x-cea-608&quot;)) {</span>
<span class="line-added"> 8731       gint i;</span>
<span class="line-added"> 8732 </span>
<span class="line-added"> 8733       for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-added"> 8734         QtDemuxStream *tmp = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added"> 8735 </span>
<span class="line-added"> 8736         if (tmp-&gt;subtype == FOURCC_vide) {</span>
<span class="line-added"> 8737           fps_stream = tmp;</span>
<span class="line-added"> 8738           break;</span>
<span class="line-added"> 8739         }</span>
<span class="line-added"> 8740       }</span>
<span class="line-added"> 8741 </span>
<span class="line-added"> 8742       if (fps_stream) {</span>
<span class="line-added"> 8743         fps_available = gst_qtdemux_guess_framerate (qtdemux, fps_stream);</span>
<span class="line-added"> 8744         CUR_STREAM (stream)-&gt;fps_n = CUR_STREAM (fps_stream)-&gt;fps_n;</span>
<span class="line-added"> 8745         CUR_STREAM (stream)-&gt;fps_d = CUR_STREAM (fps_stream)-&gt;fps_d;</span>
<span class="line-added"> 8746       }</span>
<span class="line-added"> 8747     } else {</span>
<span class="line-added"> 8748       fps_available = gst_qtdemux_guess_framerate (qtdemux, stream);</span>
<span class="line-added"> 8749       fps_stream = stream;</span>
<span class="line-added"> 8750     }</span>
<span class="line-added"> 8751 </span>
<span class="line-added"> 8752     CUR_STREAM (stream)-&gt;caps =</span>
<span class="line-added"> 8753         gst_caps_make_writable (CUR_STREAM (stream)-&gt;caps);</span>
<span class="line-added"> 8754 </span>
<span class="line-added"> 8755     /* set framerate if calculated framerate is reliable */</span>
<span class="line-added"> 8756     if (fps_available) {</span>
<span class="line-added"> 8757       gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,</span>
<span class="line-added"> 8758           &quot;framerate&quot;, GST_TYPE_FRACTION, CUR_STREAM (stream)-&gt;fps_n,</span>
<span class="line-added"> 8759           CUR_STREAM (stream)-&gt;fps_d, NULL);</span>
<span class="line-added"> 8760     }</span>
<span class="line-added"> 8761   }</span>
<span class="line-added"> 8762 </span>
 8763   if (stream-&gt;pad) {
 8764     GstCaps *prev_caps = NULL;
 8765 
 8766     GST_PAD_ELEMENT_PRIVATE (stream-&gt;pad) = stream;
 8767     gst_pad_set_event_function (stream-&gt;pad, gst_qtdemux_handle_src_event);
 8768     gst_pad_set_query_function (stream-&gt;pad, gst_qtdemux_handle_src_query);
 8769     gst_pad_set_active (stream-&gt;pad, TRUE);
 8770 
 8771     gst_pad_use_fixed_caps (stream-&gt;pad);
 8772 
 8773     if (stream-&gt;protected) {
 8774       if (!gst_qtdemux_configure_protected_caps (qtdemux, stream)) {
 8775         GST_ERROR_OBJECT (qtdemux,
 8776             &quot;Failed to configure protected stream caps.&quot;);
 8777         return FALSE;
 8778       }
 8779     }
 8780 
 8781     GST_DEBUG_OBJECT (qtdemux, &quot;setting caps %&quot; GST_PTR_FORMAT,
 8782         CUR_STREAM (stream)-&gt;caps);
 8783     if (stream-&gt;new_stream) {
<a name="310" id="anc310"></a>
 8784       GstEvent *event;
 8785       GstStreamFlags stream_flags = GST_STREAM_FLAG_NONE;
 8786 
 8787       event =
 8788           gst_pad_get_sticky_event (qtdemux-&gt;sinkpad, GST_EVENT_STREAM_START,
 8789           0);
 8790       if (event) {
 8791         gst_event_parse_stream_flags (event, &amp;stream_flags);
 8792         if (gst_event_parse_group_id (event, &amp;qtdemux-&gt;group_id))
 8793           qtdemux-&gt;have_group_id = TRUE;
<a name="311" id="anc311"></a><span class="line-modified"> 8794         else</span>
 8795           qtdemux-&gt;have_group_id = FALSE;
 8796         gst_event_unref (event);
 8797       } else if (!qtdemux-&gt;have_group_id) {
 8798         qtdemux-&gt;have_group_id = TRUE;
 8799         qtdemux-&gt;group_id = gst_util_group_id_next ();
 8800       }
 8801 
 8802       stream-&gt;new_stream = FALSE;
<a name="312" id="anc312"></a><span class="line-modified"> 8803       event = gst_event_new_stream_start (stream-&gt;stream_id);</span>



 8804       if (qtdemux-&gt;have_group_id)
 8805         gst_event_set_group_id (event, qtdemux-&gt;group_id);
 8806       if (stream-&gt;disabled)
 8807         stream_flags |= GST_STREAM_FLAG_UNSELECT;
 8808       if (CUR_STREAM (stream)-&gt;sparse) {
 8809         stream_flags |= GST_STREAM_FLAG_SPARSE;
 8810       } else {
 8811         stream_flags &amp;= ~GST_STREAM_FLAG_SPARSE;
 8812       }
 8813       gst_event_set_stream_flags (event, stream_flags);
 8814       gst_pad_push_event (stream-&gt;pad, event);
<a name="313" id="anc313"></a>
 8815     }
 8816 
 8817     prev_caps = gst_pad_get_current_caps (stream-&gt;pad);
 8818 
 8819     if (CUR_STREAM (stream)-&gt;caps) {
 8820       if (!prev_caps
 8821           || !gst_caps_is_equal_fixed (prev_caps, CUR_STREAM (stream)-&gt;caps)) {
 8822         GST_DEBUG_OBJECT (qtdemux, &quot;setting caps %&quot; GST_PTR_FORMAT,
 8823             CUR_STREAM (stream)-&gt;caps);
 8824         gst_pad_set_caps (stream-&gt;pad, CUR_STREAM (stream)-&gt;caps);
 8825       } else {
 8826         GST_DEBUG_OBJECT (qtdemux, &quot;ignore duplicated caps&quot;);
 8827       }
 8828     } else {
 8829       GST_WARNING_OBJECT (qtdemux, &quot;stream without caps&quot;);
 8830     }
 8831 
 8832     if (prev_caps)
 8833       gst_caps_unref (prev_caps);
 8834     stream-&gt;new_caps = FALSE;
 8835   }
 8836   return TRUE;
 8837 }
 8838 
 8839 static void
 8840 gst_qtdemux_stream_check_and_change_stsd_index (GstQTDemux * demux,
 8841     QtDemuxStream * stream)
 8842 {
 8843   if (stream-&gt;cur_stsd_entry_index == stream-&gt;stsd_sample_description_id)
 8844     return;
 8845 
 8846   GST_DEBUG_OBJECT (stream-&gt;pad, &quot;Changing stsd index from &#39;%u&#39; to &#39;%u&#39;&quot;,
 8847       stream-&gt;cur_stsd_entry_index, stream-&gt;stsd_sample_description_id);
 8848   if (G_UNLIKELY (stream-&gt;stsd_sample_description_id &gt;=
 8849           stream-&gt;stsd_entries_length)) {
 8850     GST_ELEMENT_ERROR (demux, STREAM, DEMUX,
 8851         (_(&quot;This file is invalid and cannot be played.&quot;)),
 8852         (&quot;New sample description id is out of bounds (%d &gt;= %d)&quot;,
 8853             stream-&gt;stsd_sample_description_id, stream-&gt;stsd_entries_length));
 8854   } else {
 8855     stream-&gt;cur_stsd_entry_index = stream-&gt;stsd_sample_description_id;
 8856     stream-&gt;new_caps = TRUE;
 8857   }
 8858 }
 8859 
 8860 static gboolean
 8861 gst_qtdemux_add_stream (GstQTDemux * qtdemux,
 8862     QtDemuxStream * stream, GstTagList * list)
 8863 {
 8864   gboolean ret = TRUE;
<a name="314" id="anc314"></a>

 8865 
 8866   if (stream-&gt;subtype == FOURCC_vide) {
 8867     gchar *name = g_strdup_printf (&quot;video_%u&quot;, qtdemux-&gt;n_video_streams);
 8868 
 8869     stream-&gt;pad =
 8870         gst_pad_new_from_static_template (&amp;gst_qtdemux_videosrc_template, name);
 8871     g_free (name);
 8872 
 8873     if (!gst_qtdemux_configure_stream (qtdemux, stream)) {
 8874       gst_object_unref (stream-&gt;pad);
 8875       stream-&gt;pad = NULL;
 8876       ret = FALSE;
 8877       goto done;
 8878     }
 8879 
 8880     qtdemux-&gt;n_video_streams++;
 8881   } else if (stream-&gt;subtype == FOURCC_soun) {
 8882     gchar *name = g_strdup_printf (&quot;audio_%u&quot;, qtdemux-&gt;n_audio_streams);
 8883 
 8884     stream-&gt;pad =
 8885         gst_pad_new_from_static_template (&amp;gst_qtdemux_audiosrc_template, name);
 8886     g_free (name);
 8887     if (!gst_qtdemux_configure_stream (qtdemux, stream)) {
 8888       gst_object_unref (stream-&gt;pad);
 8889       stream-&gt;pad = NULL;
 8890       ret = FALSE;
 8891       goto done;
 8892     }
 8893     qtdemux-&gt;n_audio_streams++;
 8894   } else if (stream-&gt;subtype == FOURCC_strm) {
 8895     GST_DEBUG_OBJECT (qtdemux, &quot;stream type, not creating pad&quot;);
 8896   } else if (stream-&gt;subtype == FOURCC_subp || stream-&gt;subtype == FOURCC_text
<a name="315" id="anc315"></a><span class="line-modified"> 8897       || stream-&gt;subtype == FOURCC_sbtl || stream-&gt;subtype == FOURCC_subt</span>
<span class="line-added"> 8898       || stream-&gt;subtype == FOURCC_clcp) {</span>
 8899     gchar *name = g_strdup_printf (&quot;subtitle_%u&quot;, qtdemux-&gt;n_sub_streams);
 8900 
 8901     stream-&gt;pad =
 8902         gst_pad_new_from_static_template (&amp;gst_qtdemux_subsrc_template, name);
 8903     g_free (name);
 8904     if (!gst_qtdemux_configure_stream (qtdemux, stream)) {
 8905       gst_object_unref (stream-&gt;pad);
 8906       stream-&gt;pad = NULL;
 8907       ret = FALSE;
 8908       goto done;
 8909     }
 8910     qtdemux-&gt;n_sub_streams++;
 8911   } else if (CUR_STREAM (stream)-&gt;caps) {
 8912     gchar *name = g_strdup_printf (&quot;video_%u&quot;, qtdemux-&gt;n_video_streams);
 8913 
 8914     stream-&gt;pad =
 8915         gst_pad_new_from_static_template (&amp;gst_qtdemux_videosrc_template, name);
 8916     g_free (name);
 8917     if (!gst_qtdemux_configure_stream (qtdemux, stream)) {
 8918       gst_object_unref (stream-&gt;pad);
 8919       stream-&gt;pad = NULL;
 8920       ret = FALSE;
 8921       goto done;
 8922     }
 8923     qtdemux-&gt;n_video_streams++;
 8924   } else {
 8925     GST_DEBUG_OBJECT (qtdemux, &quot;unknown stream type&quot;);
 8926     goto done;
 8927   }
 8928 
 8929   if (stream-&gt;pad) {
 8930     GList *l;
 8931 #ifdef GSTREAMER_LITE
 8932     // Add track_id and track_enabled so we can find this pad later on by track ID
 8933     if (CUR_STREAM (stream)-&gt;caps) {
 8934       gst_caps_set_simple(CUR_STREAM (stream)-&gt;caps,
 8935           &quot;track_id&quot;, G_TYPE_INT, stream-&gt;track_id,
 8936           &quot;track_enabled&quot;, G_TYPE_BOOLEAN, stream-&gt;track_enabled,
 8937           NULL);
 8938       GST_DEBUG_OBJECT (qtdemux, &quot;setting caps %&quot; GST_PTR_FORMAT, stream-&gt;caps);
 8939     }
 8940 #endif // GSTREAMER_LITE
 8941 
 8942     GST_DEBUG_OBJECT (qtdemux, &quot;adding pad %s %p to qtdemux %p&quot;,
 8943         GST_OBJECT_NAME (stream-&gt;pad), stream-&gt;pad, qtdemux);
 8944     gst_element_add_pad (GST_ELEMENT_CAST (qtdemux), stream-&gt;pad);
 8945     gst_flow_combiner_add_pad (qtdemux-&gt;flowcombiner, stream-&gt;pad);
 8946 
 8947     if (stream-&gt;stream_tags)
 8948       gst_tag_list_unref (stream-&gt;stream_tags);
 8949     stream-&gt;stream_tags = list;
 8950     list = NULL;
 8951     /* global tags go on each pad anyway */
 8952     stream-&gt;send_global_tags = TRUE;
 8953     /* send upstream GST_EVENT_PROTECTION events that were received before
 8954        this source pad was created */
 8955     for (l = qtdemux-&gt;protection_event_queue.head; l != NULL; l = l-&gt;next)
 8956       gst_pad_push_event (stream-&gt;pad, gst_event_ref (l-&gt;data));
 8957   }
 8958 done:
 8959   if (list)
 8960     gst_tag_list_unref (list);
 8961   return ret;
 8962 }
 8963 
 8964 /* find next atom with @fourcc starting at @offset */
 8965 static GstFlowReturn
 8966 qtdemux_find_atom (GstQTDemux * qtdemux, guint64 * offset,
 8967     guint64 * length, guint32 fourcc)
 8968 {
 8969   GstFlowReturn ret;
 8970   guint32 lfourcc;
 8971   GstBuffer *buf;
 8972 
 8973   GST_LOG_OBJECT (qtdemux, &quot;finding fourcc %&quot; GST_FOURCC_FORMAT &quot; at offset %&quot;
 8974       G_GUINT64_FORMAT, GST_FOURCC_ARGS (fourcc), *offset);
 8975 
 8976   while (TRUE) {
 8977     GstMapInfo map;
 8978 
 8979     buf = NULL;
 8980     ret = gst_pad_pull_range (qtdemux-&gt;sinkpad, *offset, 16, &amp;buf);
 8981     if (G_UNLIKELY (ret != GST_FLOW_OK))
 8982       goto locate_failed;
 8983     if (G_UNLIKELY (gst_buffer_get_size (buf) != 16)) {
 8984       /* likely EOF */
 8985       ret = GST_FLOW_EOS;
 8986       gst_buffer_unref (buf);
 8987       goto locate_failed;
 8988     }
 8989     gst_buffer_map (buf, &amp;map, GST_MAP_READ);
 8990     extract_initial_length_and_fourcc (map.data, 16, length, &amp;lfourcc);
 8991     gst_buffer_unmap (buf, &amp;map);
 8992     gst_buffer_unref (buf);
 8993 
 8994     if (G_UNLIKELY (*length == 0)) {
 8995       GST_DEBUG_OBJECT (qtdemux, &quot;invalid length 0&quot;);
 8996       ret = GST_FLOW_ERROR;
 8997       goto locate_failed;
 8998     }
 8999 
 9000     if (lfourcc == fourcc) {
 9001       GST_DEBUG_OBJECT (qtdemux, &quot;found fourcc at offset %&quot; G_GUINT64_FORMAT,
 9002           *offset);
 9003       break;
 9004     } else {
 9005       GST_LOG_OBJECT (qtdemux,
 9006           &quot;skipping atom &#39;%&quot; GST_FOURCC_FORMAT &quot;&#39; at %&quot; G_GUINT64_FORMAT,
 9007           GST_FOURCC_ARGS (fourcc), *offset);
 9008       *offset += *length;
 9009     }
 9010   }
 9011 
 9012   return GST_FLOW_OK;
 9013 
 9014 locate_failed:
 9015   {
 9016     /* might simply have had last one */
 9017     GST_DEBUG_OBJECT (qtdemux, &quot;fourcc not found&quot;);
 9018     return ret;
 9019   }
 9020 }
 9021 
 9022 /* should only do something in pull mode */
 9023 /* call with OBJECT lock */
 9024 static GstFlowReturn
 9025 qtdemux_add_fragmented_samples (GstQTDemux * qtdemux)
 9026 {
 9027   guint64 length, offset;
 9028   GstBuffer *buf = NULL;
 9029   GstFlowReturn ret = GST_FLOW_OK;
 9030   GstFlowReturn res = GST_FLOW_OK;
 9031   GstMapInfo map;
 9032 
 9033   offset = qtdemux-&gt;moof_offset;
 9034   GST_DEBUG_OBJECT (qtdemux, &quot;next moof at offset %&quot; G_GUINT64_FORMAT, offset);
 9035 
 9036   if (!offset) {
 9037     GST_DEBUG_OBJECT (qtdemux, &quot;no next moof&quot;);
 9038     return GST_FLOW_EOS;
 9039   }
 9040 
 9041   /* best not do pull etc with lock held */
 9042   GST_OBJECT_UNLOCK (qtdemux);
 9043 
 9044   ret = qtdemux_find_atom (qtdemux, &amp;offset, &amp;length, FOURCC_moof);
 9045   if (ret != GST_FLOW_OK)
 9046     goto flow_failed;
 9047 
 9048   ret = gst_qtdemux_pull_atom (qtdemux, offset, length, &amp;buf);
 9049   if (G_UNLIKELY (ret != GST_FLOW_OK))
 9050     goto flow_failed;
 9051   gst_buffer_map (buf, &amp;map, GST_MAP_READ);
 9052   if (!qtdemux_parse_moof (qtdemux, map.data, map.size, offset, NULL)) {
 9053     gst_buffer_unmap (buf, &amp;map);
 9054     gst_buffer_unref (buf);
 9055     buf = NULL;
 9056     goto parse_failed;
 9057   }
 9058 
 9059   gst_buffer_unmap (buf, &amp;map);
 9060   gst_buffer_unref (buf);
 9061   buf = NULL;
 9062 
 9063   offset += length;
 9064   /* look for next moof */
 9065   ret = qtdemux_find_atom (qtdemux, &amp;offset, &amp;length, FOURCC_moof);
 9066   if (G_UNLIKELY (ret != GST_FLOW_OK))
 9067     goto flow_failed;
 9068 
 9069 exit:
 9070   GST_OBJECT_LOCK (qtdemux);
 9071 
 9072   qtdemux-&gt;moof_offset = offset;
 9073 
 9074   return res;
 9075 
 9076 parse_failed:
 9077   {
 9078     GST_DEBUG_OBJECT (qtdemux, &quot;failed to parse moof&quot;);
 9079     offset = 0;
 9080     res = GST_FLOW_ERROR;
 9081     goto exit;
 9082   }
 9083 flow_failed:
 9084   {
 9085     /* maybe upstream temporarily flushing */
 9086     if (ret != GST_FLOW_FLUSHING) {
 9087       GST_DEBUG_OBJECT (qtdemux, &quot;no next moof&quot;);
 9088       offset = 0;
 9089     } else {
 9090       GST_DEBUG_OBJECT (qtdemux, &quot;upstream WRONG_STATE&quot;);
 9091       /* resume at current position next time */
 9092     }
 9093     res = ret;
 9094     goto exit;
 9095   }
 9096 }
 9097 
 9098 /* initialise bytereaders for stbl sub-atoms */
 9099 static gboolean
 9100 qtdemux_stbl_init (GstQTDemux * qtdemux, QtDemuxStream * stream, GNode * stbl)
 9101 {
 9102   stream-&gt;stbl_index = -1;      /* no samples have yet been parsed */
 9103   stream-&gt;sample_index = -1;
 9104 
 9105   /* time-to-sample atom */
 9106   if (!qtdemux_tree_get_child_by_type_full (stbl, FOURCC_stts, &amp;stream-&gt;stts))
 9107     goto corrupt_file;
 9108 
 9109   /* copy atom data into a new buffer for later use */
 9110   stream-&gt;stts.data = g_memdup (stream-&gt;stts.data, stream-&gt;stts.size);
 9111 
 9112   /* skip version + flags */
 9113   if (!gst_byte_reader_skip (&amp;stream-&gt;stts, 1 + 3) ||
 9114       !gst_byte_reader_get_uint32_be (&amp;stream-&gt;stts, &amp;stream-&gt;n_sample_times))
 9115     goto corrupt_file;
 9116   GST_LOG_OBJECT (qtdemux, &quot;%u timestamp blocks&quot;, stream-&gt;n_sample_times);
 9117 
 9118   /* make sure there&#39;s enough data */
 9119   if (!qt_atom_parser_has_chunks (&amp;stream-&gt;stts, stream-&gt;n_sample_times, 8)) {
 9120     stream-&gt;n_sample_times = gst_byte_reader_get_remaining (&amp;stream-&gt;stts) / 8;
 9121     GST_LOG_OBJECT (qtdemux, &quot;overriding to %u timestamp blocks&quot;,
 9122         stream-&gt;n_sample_times);
 9123     if (!stream-&gt;n_sample_times)
<a name="316" id="anc316"></a><span class="line-modified"> 9124       goto corrupt_file;</span>
 9125   }
 9126 
 9127   /* sync sample atom */
 9128   stream-&gt;stps_present = FALSE;
 9129   if ((stream-&gt;stss_present =
 9130           ! !qtdemux_tree_get_child_by_type_full (stbl, FOURCC_stss,
 9131               &amp;stream-&gt;stss) ? TRUE : FALSE) == TRUE) {
 9132     /* copy atom data into a new buffer for later use */
 9133     stream-&gt;stss.data = g_memdup (stream-&gt;stss.data, stream-&gt;stss.size);
 9134 
 9135     /* skip version + flags */
 9136     if (!gst_byte_reader_skip (&amp;stream-&gt;stss, 1 + 3) ||
 9137         !gst_byte_reader_get_uint32_be (&amp;stream-&gt;stss, &amp;stream-&gt;n_sample_syncs))
 9138       goto corrupt_file;
 9139 
 9140     if (stream-&gt;n_sample_syncs) {
 9141       /* make sure there&#39;s enough data */
 9142       if (!qt_atom_parser_has_chunks (&amp;stream-&gt;stss, stream-&gt;n_sample_syncs, 4))
 9143         goto corrupt_file;
 9144     }
 9145 
 9146     /* partial sync sample atom */
 9147     if ((stream-&gt;stps_present =
 9148             ! !qtdemux_tree_get_child_by_type_full (stbl, FOURCC_stps,
 9149                 &amp;stream-&gt;stps) ? TRUE : FALSE) == TRUE) {
 9150       /* copy atom data into a new buffer for later use */
 9151       stream-&gt;stps.data = g_memdup (stream-&gt;stps.data, stream-&gt;stps.size);
 9152 
 9153       /* skip version + flags */
 9154       if (!gst_byte_reader_skip (&amp;stream-&gt;stps, 1 + 3) ||
 9155           !gst_byte_reader_get_uint32_be (&amp;stream-&gt;stps,
 9156               &amp;stream-&gt;n_sample_partial_syncs))
 9157         goto corrupt_file;
 9158 
 9159       /* if there are no entries, the stss table contains the real
 9160        * sync samples */
 9161       if (stream-&gt;n_sample_partial_syncs) {
 9162         /* make sure there&#39;s enough data */
 9163         if (!qt_atom_parser_has_chunks (&amp;stream-&gt;stps,
 9164                 stream-&gt;n_sample_partial_syncs, 4))
 9165           goto corrupt_file;
 9166       }
 9167     }
 9168   }
 9169 
 9170   /* sample size */
 9171   if (!qtdemux_tree_get_child_by_type_full (stbl, FOURCC_stsz, &amp;stream-&gt;stsz))
 9172     goto no_samples;
 9173 
 9174   /* copy atom data into a new buffer for later use */
 9175   stream-&gt;stsz.data = g_memdup (stream-&gt;stsz.data, stream-&gt;stsz.size);
 9176 
 9177   /* skip version + flags */
 9178   if (!gst_byte_reader_skip (&amp;stream-&gt;stsz, 1 + 3) ||
 9179       !gst_byte_reader_get_uint32_be (&amp;stream-&gt;stsz, &amp;stream-&gt;sample_size))
 9180     goto corrupt_file;
 9181 
 9182   if (!gst_byte_reader_get_uint32_be (&amp;stream-&gt;stsz, &amp;stream-&gt;n_samples))
 9183     goto corrupt_file;
 9184 
 9185   if (!stream-&gt;n_samples)
 9186     goto no_samples;
 9187 
 9188   /* sample-to-chunk atom */
 9189   if (!qtdemux_tree_get_child_by_type_full (stbl, FOURCC_stsc, &amp;stream-&gt;stsc))
 9190     goto corrupt_file;
 9191 
 9192   /* copy atom data into a new buffer for later use */
 9193   stream-&gt;stsc.data = g_memdup (stream-&gt;stsc.data, stream-&gt;stsc.size);
 9194 
 9195   /* skip version + flags */
 9196   if (!gst_byte_reader_skip (&amp;stream-&gt;stsc, 1 + 3) ||
 9197       !gst_byte_reader_get_uint32_be (&amp;stream-&gt;stsc,
 9198           &amp;stream-&gt;n_samples_per_chunk))
 9199     goto corrupt_file;
 9200 
 9201   GST_DEBUG_OBJECT (qtdemux, &quot;n_samples_per_chunk %u&quot;,
 9202       stream-&gt;n_samples_per_chunk);
 9203 
 9204   /* make sure there&#39;s enough data */
 9205   if (!qt_atom_parser_has_chunks (&amp;stream-&gt;stsc, stream-&gt;n_samples_per_chunk,
 9206           12))
 9207     goto corrupt_file;
 9208 
 9209 
 9210   /* chunk offset */
 9211   if (qtdemux_tree_get_child_by_type_full (stbl, FOURCC_stco, &amp;stream-&gt;stco))
 9212     stream-&gt;co_size = sizeof (guint32);
 9213   else if (qtdemux_tree_get_child_by_type_full (stbl, FOURCC_co64,
 9214           &amp;stream-&gt;stco))
 9215     stream-&gt;co_size = sizeof (guint64);
 9216   else
 9217     goto corrupt_file;
 9218 
 9219   /* copy atom data into a new buffer for later use */
 9220   stream-&gt;stco.data = g_memdup (stream-&gt;stco.data, stream-&gt;stco.size);
 9221 
 9222   /* skip version + flags */
 9223   if (!gst_byte_reader_skip (&amp;stream-&gt;stco, 1 + 3))
 9224     goto corrupt_file;
 9225 
 9226   /* chunks_are_samples == TRUE means treat chunks as samples */
 9227   stream-&gt;chunks_are_samples = stream-&gt;sample_size
 9228       &amp;&amp; !CUR_STREAM (stream)-&gt;sampled;
 9229   if (stream-&gt;chunks_are_samples) {
 9230     /* treat chunks as samples */
 9231     if (!gst_byte_reader_get_uint32_be (&amp;stream-&gt;stco, &amp;stream-&gt;n_samples))
 9232       goto corrupt_file;
 9233   } else {
 9234     /* skip number of entries */
 9235     if (!gst_byte_reader_skip (&amp;stream-&gt;stco, 4))
 9236       goto corrupt_file;
 9237 
 9238     /* make sure there are enough data in the stsz atom */
 9239     if (!stream-&gt;sample_size) {
 9240       /* different sizes for each sample */
 9241       if (!qt_atom_parser_has_chunks (&amp;stream-&gt;stsz, stream-&gt;n_samples, 4))
 9242         goto corrupt_file;
 9243     }
 9244   }
 9245 
 9246   GST_DEBUG_OBJECT (qtdemux, &quot;allocating n_samples %u * %u (%.2f MB)&quot;,
 9247       stream-&gt;n_samples, (guint) sizeof (QtDemuxSample),
 9248       stream-&gt;n_samples * sizeof (QtDemuxSample) / (1024.0 * 1024.0));
 9249 
 9250   if (stream-&gt;n_samples &gt;=
 9251       QTDEMUX_MAX_SAMPLE_INDEX_SIZE / sizeof (QtDemuxSample)) {
 9252     GST_WARNING_OBJECT (qtdemux, &quot;not allocating index of %d samples, would &quot;
 9253         &quot;be larger than %uMB (broken file?)&quot;, stream-&gt;n_samples,
 9254         QTDEMUX_MAX_SAMPLE_INDEX_SIZE &gt;&gt; 20);
 9255     return FALSE;
 9256   }
 9257 
 9258   g_assert (stream-&gt;samples == NULL);
 9259   stream-&gt;samples = g_try_new0 (QtDemuxSample, stream-&gt;n_samples);
 9260   if (!stream-&gt;samples) {
 9261     GST_WARNING_OBJECT (qtdemux, &quot;failed to allocate %d samples&quot;,
 9262         stream-&gt;n_samples);
 9263     return FALSE;
 9264   }
 9265 
 9266   /* composition time-to-sample */
 9267   if ((stream-&gt;ctts_present =
 9268           ! !qtdemux_tree_get_child_by_type_full (stbl, FOURCC_ctts,
 9269               &amp;stream-&gt;ctts) ? TRUE : FALSE) == TRUE) {
 9270     GstByteReader cslg = GST_BYTE_READER_INIT (NULL, 0);
 9271 
 9272     /* copy atom data into a new buffer for later use */
 9273     stream-&gt;ctts.data = g_memdup (stream-&gt;ctts.data, stream-&gt;ctts.size);
 9274 
 9275     /* skip version + flags */
 9276     if (!gst_byte_reader_skip (&amp;stream-&gt;ctts, 1 + 3)
 9277         || !gst_byte_reader_get_uint32_be (&amp;stream-&gt;ctts,
 9278             &amp;stream-&gt;n_composition_times))
 9279       goto corrupt_file;
 9280 
 9281     /* make sure there&#39;s enough data */
 9282     if (!qt_atom_parser_has_chunks (&amp;stream-&gt;ctts, stream-&gt;n_composition_times,
 9283             4 + 4))
 9284       goto corrupt_file;
 9285 
 9286     /* This is optional, if missing we iterate the ctts */
 9287     if (qtdemux_tree_get_child_by_type_full (stbl, FOURCC_cslg, &amp;cslg)) {
 9288       if (!gst_byte_reader_skip (&amp;cslg, 1 + 3)
 9289           || !gst_byte_reader_get_uint32_be (&amp;cslg, &amp;stream-&gt;cslg_shift)) {
 9290         g_free ((gpointer) cslg.data);
 9291         goto corrupt_file;
<a name="317" id="anc317"></a><span class="line-modified"> 9292       }</span>
 9293     } else {
 9294       gint32 cslg_least = 0;
 9295       guint num_entries, pos;
 9296       gint i;
 9297 
 9298       pos = gst_byte_reader_get_pos (&amp;stream-&gt;ctts);
 9299       num_entries = stream-&gt;n_composition_times;
 9300 
 9301       stream-&gt;cslg_shift = 0;
 9302 
 9303       for (i = 0; i &lt; num_entries; i++) {
 9304         gint32 offset;
 9305 
 9306         gst_byte_reader_skip_unchecked (&amp;stream-&gt;ctts, 4);
 9307         offset = gst_byte_reader_get_int32_be_unchecked (&amp;stream-&gt;ctts);
<a name="318" id="anc318"></a><span class="line-added"> 9308         /* HACK: if sample_offset is larger than 2 * duration, ignore the box.</span>
<span class="line-added"> 9309          * slightly inaccurate PTS could be more usable than corrupted one */</span>
<span class="line-added"> 9310         if (G_UNLIKELY ((ABS (offset) / 2) &gt; stream-&gt;duration)) {</span>
<span class="line-added"> 9311           GST_WARNING_OBJECT (qtdemux,</span>
<span class="line-added"> 9312               &quot;Ignore corrupted ctts, sample_offset %&quot; G_GINT32_FORMAT</span>
<span class="line-added"> 9313               &quot; larger than duration %&quot; G_GUINT64_FORMAT,</span>
<span class="line-added"> 9314               offset, stream-&gt;duration);</span>
<span class="line-added"> 9315 </span>
<span class="line-added"> 9316           stream-&gt;cslg_shift = 0;</span>
<span class="line-added"> 9317           stream-&gt;ctts_present = FALSE;</span>
<span class="line-added"> 9318           return TRUE;</span>
<span class="line-added"> 9319         }</span>
 9320 
 9321         if (offset &lt; cslg_least)
 9322           cslg_least = offset;
 9323       }
 9324 
 9325       if (cslg_least &lt; 0)
 9326         stream-&gt;cslg_shift = ABS (cslg_least);
 9327       else
 9328         stream-&gt;cslg_shift = 0;
 9329 
 9330       /* reset the reader so we can generate sample table */
 9331       gst_byte_reader_set_pos (&amp;stream-&gt;ctts, pos);
 9332     }
 9333   } else {
 9334     /* Ensure the cslg_shift value is consistent so we can use it
 9335      * unconditionnally to produce TS and Segment */
 9336     stream-&gt;cslg_shift = 0;
 9337   }
 9338 
 9339   return TRUE;
 9340 
 9341 corrupt_file:
 9342   {
 9343     GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
 9344         (_(&quot;This file is corrupt and cannot be played.&quot;)), (NULL));
 9345     return FALSE;
 9346   }
 9347 no_samples:
 9348   {
 9349     gst_qtdemux_stbl_free (stream);
 9350     if (!qtdemux-&gt;fragmented) {
 9351       /* not quite good */
 9352       GST_WARNING_OBJECT (qtdemux, &quot;stream has no samples&quot;);
 9353       return FALSE;
 9354     } else {
 9355       /* may pick up samples elsewhere */
 9356       return TRUE;
 9357     }
 9358   }
 9359 }
 9360 
 9361 /* collect samples from the next sample to be parsed up to sample @n for @stream
 9362  * by reading the info from @stbl
 9363  *
 9364  * This code can be executed from both the streaming thread and the seeking
 9365  * thread so it takes the object lock to protect itself
 9366  */
 9367 static gboolean
 9368 qtdemux_parse_samples (GstQTDemux * qtdemux, QtDemuxStream * stream, guint32 n)
 9369 {
 9370   gint i, j, k;
 9371   QtDemuxSample *samples, *first, *cur, *last;
 9372   guint32 n_samples_per_chunk;
 9373   guint32 n_samples;
 9374 
 9375   GST_LOG_OBJECT (qtdemux, &quot;parsing samples for stream fourcc %&quot;
 9376       GST_FOURCC_FORMAT &quot;, pad %s&quot;,
 9377       GST_FOURCC_ARGS (CUR_STREAM (stream)-&gt;fourcc),
 9378       stream-&gt;pad ? GST_PAD_NAME (stream-&gt;pad) : &quot;(NULL)&quot;);
 9379 
 9380   n_samples = stream-&gt;n_samples;
 9381 
 9382   if (n &gt;= n_samples)
 9383     goto out_of_samples;
 9384 
 9385   GST_OBJECT_LOCK (qtdemux);
 9386   if (n &lt;= stream-&gt;stbl_index)
 9387     goto already_parsed;
 9388 
 9389   GST_DEBUG_OBJECT (qtdemux, &quot;parsing up to sample %u&quot;, n);
 9390 
 9391   if (!stream-&gt;stsz.data) {
 9392     /* so we already parsed and passed all the moov samples;
 9393      * onto fragmented ones */
 9394     g_assert (qtdemux-&gt;fragmented);
 9395     goto done;
 9396   }
 9397 
 9398   /* pointer to the sample table */
 9399   samples = stream-&gt;samples;
 9400 
 9401   /* starts from -1, moves to the next sample index to parse */
 9402   stream-&gt;stbl_index++;
 9403 
 9404   /* keep track of the first and last sample to fill */
 9405   first = &amp;samples[stream-&gt;stbl_index];
 9406   last = &amp;samples[n];
 9407 
 9408   if (!stream-&gt;chunks_are_samples) {
 9409     /* set the sample sizes */
 9410     if (stream-&gt;sample_size == 0) {
 9411       /* different sizes for each sample */
 9412       for (cur = first; cur &lt;= last; cur++) {
 9413         cur-&gt;size = gst_byte_reader_get_uint32_be_unchecked (&amp;stream-&gt;stsz);
 9414         GST_LOG_OBJECT (qtdemux, &quot;sample %d has size %u&quot;,
 9415             (guint) (cur - samples), cur-&gt;size);
 9416       }
 9417     } else {
 9418       /* samples have the same size */
 9419       GST_LOG_OBJECT (qtdemux, &quot;all samples have size %u&quot;, stream-&gt;sample_size);
 9420       for (cur = first; cur &lt;= last; cur++)
 9421         cur-&gt;size = stream-&gt;sample_size;
 9422     }
 9423   }
 9424 
 9425   n_samples_per_chunk = stream-&gt;n_samples_per_chunk;
 9426   cur = first;
 9427 
 9428   for (i = stream-&gt;stsc_index; i &lt; n_samples_per_chunk; i++) {
 9429     guint32 last_chunk;
 9430 
 9431     if (stream-&gt;stsc_chunk_index &gt;= stream-&gt;last_chunk
 9432         || stream-&gt;stsc_chunk_index &lt; stream-&gt;first_chunk) {
 9433       stream-&gt;first_chunk =
 9434           gst_byte_reader_get_uint32_be_unchecked (&amp;stream-&gt;stsc);
 9435       stream-&gt;samples_per_chunk =
 9436           gst_byte_reader_get_uint32_be_unchecked (&amp;stream-&gt;stsc);
 9437       /* starts from 1 */
 9438       stream-&gt;stsd_sample_description_id =
 9439           gst_byte_reader_get_uint32_be_unchecked (&amp;stream-&gt;stsc) - 1;
 9440 
 9441       /* chunk numbers are counted from 1 it seems */
 9442       if (G_UNLIKELY (stream-&gt;first_chunk == 0))
 9443         goto corrupt_file;
 9444 
 9445       --stream-&gt;first_chunk;
 9446 
 9447       /* the last chunk of each entry is calculated by taking the first chunk
 9448        * of the next entry; except if there is no next, where we fake it with
 9449        * INT_MAX */
 9450       if (G_UNLIKELY (i == (stream-&gt;n_samples_per_chunk - 1))) {
 9451         stream-&gt;last_chunk = G_MAXUINT32;
 9452       } else {
 9453         stream-&gt;last_chunk =
 9454             gst_byte_reader_peek_uint32_be_unchecked (&amp;stream-&gt;stsc);
 9455         if (G_UNLIKELY (stream-&gt;last_chunk == 0))
 9456           goto corrupt_file;
 9457 
 9458         --stream-&gt;last_chunk;
 9459       }
 9460 
 9461       GST_LOG_OBJECT (qtdemux,
 9462           &quot;entry %d has first_chunk %d, last_chunk %d, samples_per_chunk %d&quot;
 9463           &quot;sample desc ID: %d&quot;, i, stream-&gt;first_chunk, stream-&gt;last_chunk,
 9464           stream-&gt;samples_per_chunk, stream-&gt;stsd_sample_description_id);
 9465 
 9466       if (G_UNLIKELY (stream-&gt;last_chunk &lt; stream-&gt;first_chunk))
 9467         goto corrupt_file;
 9468 
 9469       if (stream-&gt;last_chunk != G_MAXUINT32) {
 9470         if (!qt_atom_parser_peek_sub (&amp;stream-&gt;stco,
 9471                 stream-&gt;first_chunk * stream-&gt;co_size,
 9472                 (stream-&gt;last_chunk - stream-&gt;first_chunk) * stream-&gt;co_size,
 9473                 &amp;stream-&gt;co_chunk))
 9474           goto corrupt_file;
 9475 
 9476       } else {
 9477         stream-&gt;co_chunk = stream-&gt;stco;
 9478         if (!gst_byte_reader_skip (&amp;stream-&gt;co_chunk,
 9479                 stream-&gt;first_chunk * stream-&gt;co_size))
 9480           goto corrupt_file;
 9481       }
 9482 
 9483       stream-&gt;stsc_chunk_index = stream-&gt;first_chunk;
 9484     }
 9485 
 9486     last_chunk = stream-&gt;last_chunk;
 9487 
 9488     if (stream-&gt;chunks_are_samples) {
 9489       cur = &amp;samples[stream-&gt;stsc_chunk_index];
 9490 
 9491       for (j = stream-&gt;stsc_chunk_index; j &lt; last_chunk; j++) {
 9492         if (j &gt; n) {
 9493           /* save state */
 9494           stream-&gt;stsc_chunk_index = j;
 9495           goto done;
 9496         }
 9497 
 9498         cur-&gt;offset =
 9499             qt_atom_parser_get_offset_unchecked (&amp;stream-&gt;co_chunk,
 9500             stream-&gt;co_size);
 9501 
 9502         GST_LOG_OBJECT (qtdemux, &quot;Created entry %d with offset &quot;
 9503             &quot;%&quot; G_GUINT64_FORMAT, j, cur-&gt;offset);
 9504 
 9505         if (CUR_STREAM (stream)-&gt;samples_per_frame &gt; 0 &amp;&amp;
 9506             CUR_STREAM (stream)-&gt;bytes_per_frame &gt; 0) {
 9507           cur-&gt;size =
 9508               (stream-&gt;samples_per_chunk * CUR_STREAM (stream)-&gt;n_channels) /
 9509               CUR_STREAM (stream)-&gt;samples_per_frame *
 9510               CUR_STREAM (stream)-&gt;bytes_per_frame;
 9511         } else {
 9512           cur-&gt;size = stream-&gt;samples_per_chunk;
 9513         }
 9514 
 9515         GST_DEBUG_OBJECT (qtdemux,
 9516             &quot;keyframe sample %d: timestamp %&quot; GST_TIME_FORMAT &quot;, size %u&quot;,
 9517             j, GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream,
 9518                     stream-&gt;stco_sample_index)), cur-&gt;size);
 9519 
 9520         cur-&gt;timestamp = stream-&gt;stco_sample_index;
 9521         cur-&gt;duration = stream-&gt;samples_per_chunk;
 9522         cur-&gt;keyframe = TRUE;
 9523         cur++;
 9524 
 9525         stream-&gt;stco_sample_index += stream-&gt;samples_per_chunk;
 9526       }
 9527       stream-&gt;stsc_chunk_index = j;
 9528     } else {
 9529       for (j = stream-&gt;stsc_chunk_index; j &lt; last_chunk; j++) {
 9530         guint32 samples_per_chunk;
 9531         guint64 chunk_offset;
 9532 
 9533         if (!stream-&gt;stsc_sample_index
 9534             &amp;&amp; !qt_atom_parser_get_offset (&amp;stream-&gt;co_chunk, stream-&gt;co_size,
 9535                 &amp;stream-&gt;chunk_offset))
 9536           goto corrupt_file;
 9537 
 9538         samples_per_chunk = stream-&gt;samples_per_chunk;
 9539         chunk_offset = stream-&gt;chunk_offset;
 9540 
 9541         for (k = stream-&gt;stsc_sample_index; k &lt; samples_per_chunk; k++) {
 9542           GST_LOG_OBJECT (qtdemux, &quot;creating entry %d with offset %&quot;
 9543               G_GUINT64_FORMAT &quot; and size %d&quot;,
 9544               (guint) (cur - samples), chunk_offset, cur-&gt;size);
 9545 
 9546           cur-&gt;offset = chunk_offset;
 9547           chunk_offset += cur-&gt;size;
 9548           cur++;
 9549 
 9550           if (G_UNLIKELY (cur &gt; last)) {
 9551             /* save state */
 9552             stream-&gt;stsc_sample_index = k + 1;
 9553             stream-&gt;chunk_offset = chunk_offset;
 9554             stream-&gt;stsc_chunk_index = j;
 9555             goto done2;
<a name="319" id="anc319"></a><span class="line-modified"> 9556           }</span>
 9557         }
 9558         stream-&gt;stsc_sample_index = 0;
 9559       }
 9560       stream-&gt;stsc_chunk_index = j;
 9561     }
 9562     stream-&gt;stsc_index++;
 9563   }
 9564 
 9565   if (stream-&gt;chunks_are_samples)
 9566     goto ctts;
 9567 done2:
 9568   {
 9569     guint32 n_sample_times;
 9570 
 9571     n_sample_times = stream-&gt;n_sample_times;
 9572     cur = first;
 9573 
 9574     for (i = stream-&gt;stts_index; i &lt; n_sample_times; i++) {
 9575       guint32 stts_samples;
 9576       gint32 stts_duration;
 9577       gint64 stts_time;
 9578 
 9579       if (stream-&gt;stts_sample_index &gt;= stream-&gt;stts_samples
 9580           || !stream-&gt;stts_sample_index) {
 9581 
 9582         stream-&gt;stts_samples =
 9583             gst_byte_reader_get_uint32_be_unchecked (&amp;stream-&gt;stts);
 9584         stream-&gt;stts_duration =
 9585             gst_byte_reader_get_uint32_be_unchecked (&amp;stream-&gt;stts);
 9586 
 9587         GST_LOG_OBJECT (qtdemux, &quot;block %d, %u timestamps, duration %u&quot;,
 9588             i, stream-&gt;stts_samples, stream-&gt;stts_duration);
 9589 
 9590         stream-&gt;stts_sample_index = 0;
 9591       }
 9592 
 9593       stts_samples = stream-&gt;stts_samples;
 9594       stts_duration = stream-&gt;stts_duration;
 9595       stts_time = stream-&gt;stts_time;
 9596 
 9597       for (j = stream-&gt;stts_sample_index; j &lt; stts_samples; j++) {
 9598         GST_DEBUG_OBJECT (qtdemux,
 9599             &quot;sample %d: index %d, timestamp %&quot; GST_TIME_FORMAT,
 9600             (guint) (cur - samples), j,
 9601             GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream, stts_time)));
 9602 
 9603         cur-&gt;timestamp = stts_time;
 9604         cur-&gt;duration = stts_duration;
 9605 
 9606         /* avoid 32-bit wrap-around,
 9607          * but still mind possible &#39;negative&#39; duration */
 9608         stts_time += (gint64) stts_duration;
 9609         cur++;
 9610 
 9611         if (G_UNLIKELY (cur &gt; last)) {
 9612           /* save values */
 9613           stream-&gt;stts_time = stts_time;
 9614           stream-&gt;stts_sample_index = j + 1;
 9615           if (stream-&gt;stts_sample_index &gt;= stream-&gt;stts_samples)
 9616             stream-&gt;stts_index++;
 9617           goto done3;
 9618         }
 9619       }
 9620       stream-&gt;stts_sample_index = 0;
 9621       stream-&gt;stts_time = stts_time;
 9622       stream-&gt;stts_index++;
 9623     }
 9624     /* fill up empty timestamps with the last timestamp, this can happen when
 9625      * the last samples do not decode and so we don&#39;t have timestamps for them.
 9626      * We however look at the last timestamp to estimate the track length so we
 9627      * need something in here. */
 9628     for (; cur &lt; last; cur++) {
 9629       GST_DEBUG_OBJECT (qtdemux,
 9630           &quot;fill sample %d: timestamp %&quot; GST_TIME_FORMAT,
 9631           (guint) (cur - samples),
 9632           GST_TIME_ARGS (QTSTREAMTIME_TO_GSTTIME (stream, stream-&gt;stts_time)));
 9633       cur-&gt;timestamp = stream-&gt;stts_time;
 9634       cur-&gt;duration = -1;
 9635     }
 9636   }
 9637 done3:
 9638   {
 9639     /* sample sync, can be NULL */
 9640     if (stream-&gt;stss_present == TRUE) {
 9641       guint32 n_sample_syncs;
 9642 
 9643       n_sample_syncs = stream-&gt;n_sample_syncs;
 9644 
 9645       if (!n_sample_syncs) {
 9646         GST_DEBUG_OBJECT (qtdemux, &quot;all samples are keyframes&quot;);
 9647         stream-&gt;all_keyframe = TRUE;
 9648       } else {
 9649         for (i = stream-&gt;stss_index; i &lt; n_sample_syncs; i++) {
 9650           /* note that the first sample is index 1, not 0 */
 9651           guint32 index;
 9652 
 9653           index = gst_byte_reader_get_uint32_be_unchecked (&amp;stream-&gt;stss);
 9654 
 9655           if (G_LIKELY (index &gt; 0 &amp;&amp; index &lt;= n_samples)) {
 9656             index -= 1;
 9657             samples[index].keyframe = TRUE;
 9658             GST_DEBUG_OBJECT (qtdemux, &quot;samples at %u is keyframe&quot;, index);
 9659             /* and exit if we have enough samples */
 9660             if (G_UNLIKELY (index &gt;= n)) {
 9661               i++;
 9662               break;
 9663             }
 9664           }
 9665         }
 9666         /* save state */
 9667         stream-&gt;stss_index = i;
 9668       }
 9669 
 9670       /* stps marks partial sync frames like open GOP I-Frames */
 9671       if (stream-&gt;stps_present == TRUE) {
 9672         guint32 n_sample_partial_syncs;
 9673 
 9674         n_sample_partial_syncs = stream-&gt;n_sample_partial_syncs;
 9675 
 9676         /* if there are no entries, the stss table contains the real
 9677          * sync samples */
 9678         if (n_sample_partial_syncs) {
 9679           for (i = stream-&gt;stps_index; i &lt; n_sample_partial_syncs; i++) {
 9680             /* note that the first sample is index 1, not 0 */
 9681             guint32 index;
 9682 
 9683             index = gst_byte_reader_get_uint32_be_unchecked (&amp;stream-&gt;stps);
 9684 
 9685             if (G_LIKELY (index &gt; 0 &amp;&amp; index &lt;= n_samples)) {
 9686               index -= 1;
 9687               samples[index].keyframe = TRUE;
 9688               GST_DEBUG_OBJECT (qtdemux, &quot;samples at %u is keyframe&quot;, index);
 9689               /* and exit if we have enough samples */
 9690               if (G_UNLIKELY (index &gt;= n)) {
 9691                 i++;
 9692                 break;
 9693               }
 9694             }
 9695           }
 9696           /* save state */
 9697           stream-&gt;stps_index = i;
 9698         }
 9699       }
 9700     } else {
 9701       /* no stss, all samples are keyframes */
 9702       stream-&gt;all_keyframe = TRUE;
 9703       GST_DEBUG_OBJECT (qtdemux, &quot;setting all keyframes&quot;);
 9704     }
 9705   }
 9706 
 9707 ctts:
 9708   /* composition time to sample */
 9709   if (stream-&gt;ctts_present == TRUE) {
 9710     guint32 n_composition_times;
 9711     guint32 ctts_count;
 9712     gint32 ctts_soffset;
 9713 
 9714     /* Fill in the pts_offsets */
 9715     cur = first;
 9716     n_composition_times = stream-&gt;n_composition_times;
 9717 
 9718     for (i = stream-&gt;ctts_index; i &lt; n_composition_times; i++) {
 9719       if (stream-&gt;ctts_sample_index &gt;= stream-&gt;ctts_count
 9720           || !stream-&gt;ctts_sample_index) {
 9721         stream-&gt;ctts_count =
 9722             gst_byte_reader_get_uint32_be_unchecked (&amp;stream-&gt;ctts);
 9723         stream-&gt;ctts_soffset =
 9724             gst_byte_reader_get_int32_be_unchecked (&amp;stream-&gt;ctts);
 9725         stream-&gt;ctts_sample_index = 0;
 9726       }
 9727 
 9728       ctts_count = stream-&gt;ctts_count;
 9729       ctts_soffset = stream-&gt;ctts_soffset;
 9730 
 9731       for (j = stream-&gt;ctts_sample_index; j &lt; ctts_count; j++) {
 9732         cur-&gt;pts_offset = ctts_soffset;
 9733         cur++;
 9734 
 9735         if (G_UNLIKELY (cur &gt; last)) {
 9736           /* save state */
 9737           stream-&gt;ctts_sample_index = j + 1;
 9738           goto done;
 9739         }
 9740       }
 9741       stream-&gt;ctts_sample_index = 0;
 9742       stream-&gt;ctts_index++;
 9743     }
 9744   }
 9745 done:
 9746   stream-&gt;stbl_index = n;
 9747   /* if index has been completely parsed, free data that is no-longer needed */
 9748   if (n + 1 == stream-&gt;n_samples) {
 9749     gst_qtdemux_stbl_free (stream);
 9750     GST_DEBUG_OBJECT (qtdemux, &quot;parsed all available samples;&quot;);
 9751     if (qtdemux-&gt;pullbased) {
 9752       GST_DEBUG_OBJECT (qtdemux, &quot;checking for more samples&quot;);
<a name="320" id="anc320"></a><span class="line-modified"> 9753       while (n + 1 == stream-&gt;n_samples)</span>
<span class="line-modified"> 9754         if (qtdemux_add_fragmented_samples (qtdemux) != GST_FLOW_OK)</span>
<span class="line-modified"> 9755           break;</span>
<span class="line-modified"> 9756     }</span>
 9757   }
 9758   GST_OBJECT_UNLOCK (qtdemux);
 9759 
 9760   return TRUE;
 9761 
 9762   /* SUCCESS */
 9763 already_parsed:
 9764   {
 9765     GST_LOG_OBJECT (qtdemux,
 9766         &quot;Tried to parse up to sample %u but this sample has already been parsed&quot;,
 9767         n);
 9768     /* if fragmented, there may be more */
 9769     if (qtdemux-&gt;fragmented &amp;&amp; n == stream-&gt;stbl_index)
 9770       goto done;
 9771     GST_OBJECT_UNLOCK (qtdemux);
 9772     return TRUE;
 9773   }
 9774   /* ERRORS */
 9775 out_of_samples:
 9776   {
 9777     GST_LOG_OBJECT (qtdemux,
 9778         &quot;Tried to parse up to sample %u but there are only %u samples&quot;, n + 1,
 9779         stream-&gt;n_samples);
 9780     GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
 9781         (_(&quot;This file is corrupt and cannot be played.&quot;)), (NULL));
 9782     return FALSE;
 9783   }
 9784 corrupt_file:
 9785   {
 9786     GST_OBJECT_UNLOCK (qtdemux);
 9787     GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
 9788         (_(&quot;This file is corrupt and cannot be played.&quot;)), (NULL));
 9789     return FALSE;
 9790   }
 9791 }
 9792 
 9793 /* collect all segment info for @stream.
 9794  */
 9795 static gboolean
 9796 qtdemux_parse_segments (GstQTDemux * qtdemux, QtDemuxStream * stream,
 9797     GNode * trak)
 9798 {
 9799   GNode *edts;
 9800   /* accept edts if they contain gaps at start and there is only
 9801    * one media segment */
 9802   gboolean allow_pushbased_edts = TRUE;
 9803   gint media_segments_count = 0;
 9804 
 9805   /* parse and prepare segment info from the edit list */
 9806   GST_DEBUG_OBJECT (qtdemux, &quot;looking for edit list container&quot;);
 9807   stream-&gt;n_segments = 0;
 9808   stream-&gt;segments = NULL;
 9809   if ((edts = qtdemux_tree_get_child_by_type (trak, FOURCC_edts))) {
 9810     GNode *elst;
 9811     gint n_segments;
<a name="321" id="anc321"></a><span class="line-modified"> 9812     gint segment_number, entry_size;</span>
 9813     guint64 time;
 9814     GstClockTime stime;
 9815     const guint8 *buffer;
 9816     guint8 version;
 9817     guint32 size;
 9818 
 9819     GST_DEBUG_OBJECT (qtdemux, &quot;looking for edit list&quot;);
 9820     if (!(elst = qtdemux_tree_get_child_by_type (edts, FOURCC_elst)))
 9821       goto done;
 9822 
 9823     buffer = elst-&gt;data;
 9824 
 9825     size = QT_UINT32 (buffer);
 9826     /* version, flags, n_segments */
 9827     if (size &lt; 16) {
 9828       GST_WARNING_OBJECT (qtdemux, &quot;Invalid edit list&quot;);
 9829       goto done;
 9830     }
 9831     version = QT_UINT8 (buffer + 8);
 9832     entry_size = (version == 1) ? 20 : 12;
 9833 
 9834     n_segments = QT_UINT32 (buffer + 12);
 9835 
 9836     if (n_segments &gt; 100000 || size &lt; 16 + n_segments * entry_size) {
 9837       GST_WARNING_OBJECT (qtdemux, &quot;Invalid edit list&quot;);
 9838       goto done;
 9839     }
 9840 
 9841     /* we might allocate a bit too much, at least allocate 1 segment */
 9842     stream-&gt;segments = g_new (QtDemuxSegment, MAX (n_segments, 1));
 9843 
 9844     /* segments always start from 0 */
 9845     time = 0;
 9846     stime = 0;
<a name="322" id="anc322"></a>
 9847     buffer += 16;
<a name="323" id="anc323"></a><span class="line-modified"> 9848     for (segment_number = 0; segment_number &lt; n_segments; segment_number++) {</span>
 9849       guint64 duration;
 9850       guint64 media_time;
<a name="324" id="anc324"></a><span class="line-modified"> 9851       gboolean empty_edit = FALSE;</span>
 9852       QtDemuxSegment *segment;
 9853       guint32 rate_int;
 9854       GstClockTime media_start = GST_CLOCK_TIME_NONE;
 9855 
<a name="325" id="anc325"></a><span class="line-modified"> 9856       if (version == 1) {</span>
 9857         media_time = QT_UINT64 (buffer + 8);
 9858         duration = QT_UINT64 (buffer);
 9859         if (media_time == G_MAXUINT64)
<a name="326" id="anc326"></a><span class="line-modified"> 9860           empty_edit = TRUE;</span>
 9861       } else {
 9862         media_time = QT_UINT32 (buffer + 4);
 9863         duration = QT_UINT32 (buffer);
 9864         if (media_time == G_MAXUINT32)
<a name="327" id="anc327"></a><span class="line-modified"> 9865           empty_edit = TRUE;</span>
 9866       }
 9867 
<a name="328" id="anc328"></a><span class="line-modified"> 9868       if (!empty_edit)</span>
 9869         media_start = QTSTREAMTIME_TO_GSTTIME (stream, media_time);
 9870 
<a name="329" id="anc329"></a><span class="line-modified"> 9871       segment = &amp;stream-&gt;segments[segment_number];</span>
 9872 
 9873       /* time and duration expressed in global timescale */
 9874       segment-&gt;time = stime;
<a name="330" id="anc330"></a><span class="line-modified"> 9875       if (duration != 0 || empty_edit) {</span>
<span class="line-modified"> 9876         /* edge case: empty edits with duration=zero are treated here.</span>
<span class="line-modified"> 9877          * (files should not have these anyway). */</span>
<span class="line-added"> 9878 </span>
<span class="line-added"> 9879         /* add non scaled values so we don&#39;t cause roundoff errors */</span>
<span class="line-added"> 9880         time += duration;</span>
 9881         stime = QTTIME_TO_GSTTIME (qtdemux, time);
 9882         segment-&gt;duration = stime - segment-&gt;time;
 9883       } else {
 9884         /* zero duration does not imply media_start == media_stop
<a name="331" id="anc331"></a><span class="line-modified"> 9885          * but, only specify media_start. The edit ends with the track. */</span>
<span class="line-modified"> 9886         stime = segment-&gt;duration = GST_CLOCK_TIME_NONE;</span>
<span class="line-modified"> 9887         /* Don&#39;t allow more edits after this one. */</span>
<span class="line-modified"> 9888         n_segments = segment_number + 1;</span>




 9889       }
 9890       segment-&gt;stop_time = stime;
 9891 
 9892       segment-&gt;trak_media_start = media_time;
 9893       /* media_time expressed in stream timescale */
<a name="332" id="anc332"></a><span class="line-modified"> 9894       if (!empty_edit) {</span>
 9895         segment-&gt;media_start = media_start;
<a name="333" id="anc333"></a><span class="line-modified"> 9896         segment-&gt;media_stop = GST_CLOCK_TIME_IS_VALID (segment-&gt;duration)</span>
<span class="line-added"> 9897             ? segment-&gt;media_start + segment-&gt;duration : GST_CLOCK_TIME_NONE;</span>
 9898         media_segments_count++;
 9899       } else {
 9900         segment-&gt;media_start = GST_CLOCK_TIME_NONE;
 9901         segment-&gt;media_stop = GST_CLOCK_TIME_NONE;
 9902       }
 9903       rate_int = QT_UINT32 (buffer + ((version == 1) ? 16 : 8));
 9904 
 9905       if (rate_int &lt;= 1) {
 9906         /* 0 is not allowed, some programs write 1 instead of the floating point
 9907          * value */
 9908         GST_WARNING_OBJECT (qtdemux, &quot;found suspicious rate %&quot; G_GUINT32_FORMAT,
 9909             rate_int);
 9910         segment-&gt;rate = 1;
 9911       } else {
 9912         segment-&gt;rate = rate_int / 65536.0;
 9913       }
 9914 
 9915       GST_DEBUG_OBJECT (qtdemux, &quot;created segment %d time %&quot; GST_TIME_FORMAT
 9916           &quot;, duration %&quot; GST_TIME_FORMAT &quot;, media_start %&quot; GST_TIME_FORMAT
 9917           &quot; (%&quot; G_GUINT64_FORMAT &quot;) , media_stop %&quot; GST_TIME_FORMAT
 9918           &quot; stop_time %&quot; GST_TIME_FORMAT &quot; rate %g, (%d) timescale %u&quot;,
<a name="334" id="anc334"></a><span class="line-modified"> 9919           segment_number, GST_TIME_ARGS (segment-&gt;time),</span>
 9920           GST_TIME_ARGS (segment-&gt;duration),
 9921           GST_TIME_ARGS (segment-&gt;media_start), media_time,
 9922           GST_TIME_ARGS (segment-&gt;media_stop),
 9923           GST_TIME_ARGS (segment-&gt;stop_time), segment-&gt;rate, rate_int,
 9924           stream-&gt;timescale);
<a name="335" id="anc335"></a><span class="line-modified"> 9925       if (segment-&gt;stop_time &gt; qtdemux-&gt;segment.stop &amp;&amp;</span>
<span class="line-added"> 9926           !qtdemux-&gt;upstream_format_is_time) {</span>
 9927         GST_WARNING_OBJECT (qtdemux, &quot;Segment %d &quot;
 9928             &quot; extends to %&quot; GST_TIME_FORMAT
<a name="336" id="anc336"></a><span class="line-modified"> 9929             &quot; past the end of the declared movie duration %&quot; GST_TIME_FORMAT</span>
<span class="line-modified"> 9930             &quot; movie segment will be extended&quot;, segment_number,</span>
<span class="line-added"> 9931             GST_TIME_ARGS (segment-&gt;stop_time),</span>
 9932             GST_TIME_ARGS (qtdemux-&gt;segment.stop));
<a name="337" id="anc337"></a><span class="line-modified"> 9933         qtdemux-&gt;segment.stop = qtdemux-&gt;segment.duration = segment-&gt;stop_time;</span>
<span class="line-modified"> 9934       }</span>
 9935 
 9936       buffer += entry_size;
 9937     }
<a name="338" id="anc338"></a><span class="line-modified"> 9938     GST_DEBUG_OBJECT (qtdemux, &quot;found %d segments&quot;, n_segments);</span>
<span class="line-modified"> 9939     stream-&gt;n_segments = n_segments;</span>
 9940     if (media_segments_count != 1)
 9941       allow_pushbased_edts = FALSE;
 9942   }
 9943 done:
 9944 
 9945   /* push based does not handle segments, so act accordingly here,
 9946    * and warn if applicable */
 9947   if (!qtdemux-&gt;pullbased &amp;&amp; !allow_pushbased_edts) {
 9948     GST_WARNING_OBJECT (qtdemux, &quot;streaming; discarding edit list segments&quot;);
 9949     /* remove and use default one below, we stream like it anyway */
 9950     g_free (stream-&gt;segments);
 9951     stream-&gt;segments = NULL;
 9952     stream-&gt;n_segments = 0;
 9953   }
 9954 
 9955   /* no segments, create one to play the complete trak */
 9956   if (stream-&gt;n_segments == 0) {
 9957     GstClockTime stream_duration =
 9958         QTSTREAMTIME_TO_GSTTIME (stream, stream-&gt;duration);
 9959 
 9960     if (stream-&gt;segments == NULL)
 9961       stream-&gt;segments = g_new (QtDemuxSegment, 1);
 9962 
 9963     /* represent unknown our way */
 9964     if (stream_duration == 0)
 9965       stream_duration = GST_CLOCK_TIME_NONE;
 9966 
 9967     stream-&gt;segments[0].time = 0;
 9968     stream-&gt;segments[0].stop_time = stream_duration;
 9969     stream-&gt;segments[0].duration = stream_duration;
 9970     stream-&gt;segments[0].media_start = 0;
 9971     stream-&gt;segments[0].media_stop = stream_duration;
 9972     stream-&gt;segments[0].rate = 1.0;
 9973     stream-&gt;segments[0].trak_media_start = 0;
 9974 
 9975     GST_DEBUG_OBJECT (qtdemux, &quot;created dummy segment %&quot; GST_TIME_FORMAT,
 9976         GST_TIME_ARGS (stream_duration));
 9977     stream-&gt;n_segments = 1;
 9978     stream-&gt;dummy_segment = TRUE;
 9979   }
 9980   GST_DEBUG_OBJECT (qtdemux, &quot;using %d segments&quot;, stream-&gt;n_segments);
 9981 
 9982   return TRUE;
 9983 }
 9984 
 9985 /*
 9986  * Parses the stsd atom of a svq3 trak looking for
 9987  * the SMI and gama atoms.
 9988  */
 9989 static void
 9990 qtdemux_parse_svq3_stsd_data (GstQTDemux * qtdemux,
 9991     const guint8 * stsd_entry_data, const guint8 ** gamma, GstBuffer ** seqh)
 9992 {
 9993   const guint8 *_gamma = NULL;
 9994   GstBuffer *_seqh = NULL;
 9995   const guint8 *stsd_data = stsd_entry_data;
 9996   guint32 length = QT_UINT32 (stsd_data);
 9997   guint16 version;
 9998 
 9999   if (length &lt; 32) {
10000     GST_WARNING_OBJECT (qtdemux, &quot;stsd too short&quot;);
10001     goto end;
10002   }
10003 
10004   stsd_data += 16;
10005   length -= 16;
10006   version = QT_UINT16 (stsd_data);
10007   if (version == 3) {
10008     if (length &gt;= 70) {
10009       length -= 70;
10010       stsd_data += 70;
10011       while (length &gt; 8) {
10012         guint32 fourcc, size;
10013         const guint8 *data;
10014         size = QT_UINT32 (stsd_data);
10015         fourcc = QT_FOURCC (stsd_data + 4);
10016         data = stsd_data + 8;
10017 
10018         if (size == 0) {
10019           GST_WARNING_OBJECT (qtdemux, &quot;Atom of size 0 found, aborting &quot;
10020               &quot;svq3 atom parsing&quot;);
10021           goto end;
10022         }
10023 
10024         switch (fourcc) {
10025           case FOURCC_gama:{
10026             if (size == 12) {
10027               _gamma = data;
10028             } else {
10029               GST_WARNING_OBJECT (qtdemux, &quot;Unexpected size %&quot; G_GUINT32_FORMAT
10030                   &quot; for gama atom, expected 12&quot;, size);
10031             }
10032             break;
10033           }
10034           case FOURCC_SMI_:{
10035             if (size &gt; 16 &amp;&amp; QT_FOURCC (data) == FOURCC_SEQH) {
10036               guint32 seqh_size;
10037               if (_seqh != NULL) {
10038                 GST_WARNING_OBJECT (qtdemux, &quot;Unexpected second SEQH SMI atom &quot;
10039                     &quot; found, ignoring&quot;);
10040               } else {
10041                 seqh_size = QT_UINT32 (data + 4);
10042                 if (seqh_size &gt; 0) {
10043                   _seqh = gst_buffer_new_and_alloc (seqh_size);
10044                   gst_buffer_fill (_seqh, 0, data + 8, seqh_size);
10045                 }
10046               }
10047             }
10048             break;
10049           }
10050           default:{
10051             GST_WARNING_OBJECT (qtdemux, &quot;Unhandled atom %&quot; GST_FOURCC_FORMAT
10052                 &quot; in SVQ3 entry in stsd atom&quot;, GST_FOURCC_ARGS (fourcc));
10053           }
10054         }
10055 
10056         if (size &lt;= length) {
10057           length -= size;
10058           stsd_data += size;
10059         }
10060       }
10061     } else {
10062       GST_WARNING_OBJECT (qtdemux, &quot;SVQ3 entry too short in stsd atom&quot;);
10063     }
10064   } else {
10065     GST_WARNING_OBJECT (qtdemux, &quot;Unexpected version for SVQ3 entry %&quot;
10066         G_GUINT16_FORMAT, version);
10067     goto end;
10068   }
10069 
10070 end:
10071   if (gamma) {
10072     *gamma = _gamma;
10073   }
10074   if (seqh) {
10075     *seqh = _seqh;
10076   } else if (_seqh) {
10077     gst_buffer_unref (_seqh);
10078   }
10079 }
10080 
10081 static gchar *
10082 qtdemux_get_rtsp_uri_from_hndl (GstQTDemux * qtdemux, GNode * minf)
10083 {
10084   GNode *dinf;
10085   GstByteReader dref;
10086   gchar *uri = NULL;
10087 
10088   /*
10089    * Get &#39;dinf&#39;, to get its child &#39;dref&#39;, that might contain a &#39;hndl&#39;
10090    * atom that might contain a &#39;data&#39; atom with the rtsp uri.
10091    * This case was reported in bug #597497, some info about
10092    * the hndl atom can be found in TN1195
10093    */
10094   dinf = qtdemux_tree_get_child_by_type (minf, FOURCC_dinf);
10095   GST_DEBUG_OBJECT (qtdemux, &quot;Trying to obtain rtsp URI for stream trak&quot;);
10096 
10097   if (dinf) {
10098     guint32 dref_num_entries = 0;
10099     if (qtdemux_tree_get_child_by_type_full (dinf, FOURCC_dref, &amp;dref) &amp;&amp;
10100         gst_byte_reader_skip (&amp;dref, 4) &amp;&amp;
10101         gst_byte_reader_get_uint32_be (&amp;dref, &amp;dref_num_entries)) {
10102       gint i;
10103 
10104       /* search dref entries for hndl atom */
10105       for (i = 0; i &lt; dref_num_entries; i++) {
10106         guint32 size = 0, type;
10107         guint8 string_len = 0;
10108         if (gst_byte_reader_get_uint32_be (&amp;dref, &amp;size) &amp;&amp;
10109             qt_atom_parser_get_fourcc (&amp;dref, &amp;type)) {
10110           if (type == FOURCC_hndl) {
10111             GST_DEBUG_OBJECT (qtdemux, &quot;Found hndl atom&quot;);
10112 
10113             /* skip data reference handle bytes and the
10114              * following pascal string and some extra 4
10115              * bytes I have no idea what are */
10116             if (!gst_byte_reader_skip (&amp;dref, 4) ||
10117                 !gst_byte_reader_get_uint8 (&amp;dref, &amp;string_len) ||
10118                 !gst_byte_reader_skip (&amp;dref, string_len + 4)) {
10119               GST_WARNING_OBJECT (qtdemux, &quot;Failed to parse hndl atom&quot;);
10120               break;
10121             }
10122 
10123             /* iterate over the atoms to find the data atom */
10124             while (gst_byte_reader_get_remaining (&amp;dref) &gt;= 8) {
10125               guint32 atom_size;
10126               guint32 atom_type;
10127 
10128               if (gst_byte_reader_get_uint32_be (&amp;dref, &amp;atom_size) &amp;&amp;
10129                   qt_atom_parser_get_fourcc (&amp;dref, &amp;atom_type)) {
10130                 if (atom_type == FOURCC_data) {
10131                   const guint8 *uri_aux = NULL;
10132 
10133                   /* found the data atom that might contain the rtsp uri */
10134                   GST_DEBUG_OBJECT (qtdemux, &quot;Found data atom inside &quot;
10135                       &quot;hndl atom, interpreting it as an URI&quot;);
10136                   if (gst_byte_reader_peek_data (&amp;dref, atom_size - 8,
10137                           &amp;uri_aux)) {
10138                     if (g_strstr_len ((gchar *) uri_aux, 7, &quot;rtsp://&quot;) != NULL)
10139                       uri = g_strndup ((gchar *) uri_aux, atom_size - 8);
10140                     else
10141                       GST_WARNING_OBJECT (qtdemux, &quot;Data atom in hndl atom &quot;
10142                           &quot;didn&#39;t contain a rtsp address&quot;);
10143                   } else {
10144                     GST_WARNING_OBJECT (qtdemux, &quot;Failed to get the data &quot;
10145                         &quot;atom contents&quot;);
10146                   }
10147                   break;
10148                 }
10149                 /* skipping to the next entry */
10150                 if (!gst_byte_reader_skip (&amp;dref, atom_size - 8))
10151                   break;
10152               } else {
10153                 GST_WARNING_OBJECT (qtdemux, &quot;Failed to parse hndl child &quot;
10154                     &quot;atom header&quot;);
10155                 break;
10156               }
10157             }
10158             break;
10159           }
10160           /* skip to the next entry */
10161           if (!gst_byte_reader_skip (&amp;dref, size - 8))
10162             break;
10163         } else {
10164           GST_WARNING_OBJECT (qtdemux, &quot;Error parsing dref atom&quot;);
10165         }
10166       }
10167       GST_DEBUG_OBJECT (qtdemux, &quot;Finished parsing dref atom&quot;);
10168     }
10169   }
10170   return uri;
10171 }
10172 
10173 #define AMR_NB_ALL_MODES        0x81ff
10174 #define AMR_WB_ALL_MODES        0x83ff
10175 static guint
10176 qtdemux_parse_amr_bitrate (GstBuffer * buf, gboolean wb)
10177 {
10178   /* The &#39;damr&#39; atom is of the form:
10179    *
10180    * | vendor | decoder_ver | mode_set | mode_change_period | frames/sample |
10181    *    32 b       8 b          16 b           8 b                 8 b
10182    *
10183    * The highest set bit of the first 7 (AMR-NB) or 8 (AMR-WB) bits of mode_set
10184    * represents the highest mode used in the stream (and thus the maximum
10185    * bitrate), with a couple of special cases as seen below.
10186    */
10187 
10188   /* Map of frame type ID -&gt; bitrate */
10189   static const guint nb_bitrates[] = {
10190     4750, 5150, 5900, 6700, 7400, 7950, 10200, 12200
10191   };
10192   static const guint wb_bitrates[] = {
10193     6600, 8850, 12650, 14250, 15850, 18250, 19850, 23050, 23850
10194   };
10195   GstMapInfo map;
10196   gsize max_mode;
10197   guint16 mode_set;
10198 
10199   gst_buffer_map (buf, &amp;map, GST_MAP_READ);
10200 
10201   if (map.size != 0x11) {
10202     GST_DEBUG (&quot;Atom should have size 0x11, not %&quot; G_GSIZE_FORMAT, map.size);
10203     goto bad_data;
10204   }
10205 
10206   if (QT_FOURCC (map.data + 4) != FOURCC_damr) {
10207     GST_DEBUG (&quot;Unknown atom in %&quot; GST_FOURCC_FORMAT,
10208         GST_FOURCC_ARGS (QT_UINT32 (map.data + 4)));
10209     goto bad_data;
10210   }
10211 
10212   mode_set = QT_UINT16 (map.data + 13);
10213 
10214   if (mode_set == (wb ? AMR_WB_ALL_MODES : AMR_NB_ALL_MODES))
10215     max_mode = 7 + (wb ? 1 : 0);
10216   else
10217     /* AMR-NB modes fo from 0-7, and AMR-WB modes go from 0-8 */
10218     max_mode = g_bit_nth_msf ((gulong) mode_set &amp; (wb ? 0x1ff : 0xff), -1);
10219 
10220   if (max_mode == -1) {
10221     GST_DEBUG (&quot;No mode indication was found (mode set) = %x&quot;,
10222         (guint) mode_set);
10223     goto bad_data;
10224   }
10225 
10226   gst_buffer_unmap (buf, &amp;map);
10227   return wb ? wb_bitrates[max_mode] : nb_bitrates[max_mode];
10228 
10229 bad_data:
10230   gst_buffer_unmap (buf, &amp;map);
10231   return 0;
10232 }
10233 
10234 static gboolean
10235 qtdemux_parse_transformation_matrix (GstQTDemux * qtdemux,
10236     GstByteReader * reader, guint32 * matrix, const gchar * atom)
10237 {
10238   /*
10239    * 9 values of 32 bits (fixed point 16.16, except 2 5 and 8 that are 2.30)
10240    * [0 1 2]
10241    * [3 4 5]
10242    * [6 7 8]
10243    */
10244 
10245   if (gst_byte_reader_get_remaining (reader) &lt; 36)
10246     return FALSE;
10247 
10248   matrix[0] = gst_byte_reader_get_uint32_be_unchecked (reader);
10249   matrix[1] = gst_byte_reader_get_uint32_be_unchecked (reader);
10250   matrix[2] = gst_byte_reader_get_uint32_be_unchecked (reader);
10251   matrix[3] = gst_byte_reader_get_uint32_be_unchecked (reader);
10252   matrix[4] = gst_byte_reader_get_uint32_be_unchecked (reader);
10253   matrix[5] = gst_byte_reader_get_uint32_be_unchecked (reader);
10254   matrix[6] = gst_byte_reader_get_uint32_be_unchecked (reader);
10255   matrix[7] = gst_byte_reader_get_uint32_be_unchecked (reader);
10256   matrix[8] = gst_byte_reader_get_uint32_be_unchecked (reader);
10257 
10258   GST_DEBUG_OBJECT (qtdemux, &quot;Transformation matrix from atom %s&quot;, atom);
10259   GST_DEBUG_OBJECT (qtdemux, &quot;%u.%u %u.%u %u.%u&quot;, matrix[0] &gt;&gt; 16,
10260       matrix[0] &amp; 0xFFFF, matrix[1] &gt;&gt; 16, matrix[1] &amp; 0xFF, matrix[2] &gt;&gt; 16,
10261       matrix[2] &amp; 0xFF);
10262   GST_DEBUG_OBJECT (qtdemux, &quot;%u.%u %u.%u %u.%u&quot;, matrix[3] &gt;&gt; 16,
10263       matrix[3] &amp; 0xFFFF, matrix[4] &gt;&gt; 16, matrix[4] &amp; 0xFF, matrix[5] &gt;&gt; 16,
10264       matrix[5] &amp; 0xFF);
10265   GST_DEBUG_OBJECT (qtdemux, &quot;%u.%u %u.%u %u.%u&quot;, matrix[6] &gt;&gt; 16,
10266       matrix[6] &amp; 0xFFFF, matrix[7] &gt;&gt; 16, matrix[7] &amp; 0xFF, matrix[8] &gt;&gt; 16,
10267       matrix[8] &amp; 0xFF);
10268 
10269   return TRUE;
10270 }
10271 
10272 static void
10273 qtdemux_inspect_transformation_matrix (GstQTDemux * qtdemux,
10274     QtDemuxStream * stream, guint32 * matrix, GstTagList ** taglist)
10275 {
10276 
10277 /* [a b c]
10278  * [d e f]
10279  * [g h i]
10280  *
10281  * This macro will only compare value abdegh, it expects cfi to have already
10282  * been checked
10283  */
10284 #define QTCHECK_MATRIX(m,a,b,d,e) ((m)[0] == (a &lt;&lt; 16) &amp;&amp; (m)[1] == (b &lt;&lt; 16) &amp;&amp; \
10285                                    (m)[3] == (d &lt;&lt; 16) &amp;&amp; (m)[4] == (e &lt;&lt; 16))
10286 
10287   /* only handle the cases where the last column has standard values */
10288   if (matrix[2] == 0 &amp;&amp; matrix[5] == 0 &amp;&amp; matrix[8] == 1 &lt;&lt; 30) {
10289     const gchar *rotation_tag = NULL;
10290 
10291     /* no rotation needed */
10292     if (QTCHECK_MATRIX (matrix, 1, 0, 0, 1)) {
10293       /* NOP */
10294     } else if (QTCHECK_MATRIX (matrix, 0, 1, G_MAXUINT16, 0)) {
10295       rotation_tag = &quot;rotate-90&quot;;
10296     } else if (QTCHECK_MATRIX (matrix, G_MAXUINT16, 0, 0, G_MAXUINT16)) {
10297       rotation_tag = &quot;rotate-180&quot;;
10298     } else if (QTCHECK_MATRIX (matrix, 0, G_MAXUINT16, 1, 0)) {
10299       rotation_tag = &quot;rotate-270&quot;;
10300     } else {
10301       GST_FIXME_OBJECT (qtdemux, &quot;Unhandled transformation matrix values&quot;);
10302     }
10303 
10304     GST_DEBUG_OBJECT (qtdemux, &quot;Transformation matrix rotation %s&quot;,
10305         rotation_tag);
10306     if (rotation_tag != NULL) {
10307       if (*taglist == NULL)
10308         *taglist = gst_tag_list_new_empty ();
10309       gst_tag_list_add (*taglist, GST_TAG_MERGE_REPLACE,
10310           GST_TAG_IMAGE_ORIENTATION, rotation_tag, NULL);
10311     }
10312   } else {
10313     GST_FIXME_OBJECT (qtdemux, &quot;Unhandled transformation matrix values&quot;);
10314   }
10315 }
10316 
10317 /* Parses the boxes defined in ISO/IEC 14496-12 that enable support for
10318  * protected streams (sinf, frma, schm and schi); if the protection scheme is
10319  * Common Encryption (cenc), the function will also parse the tenc box (defined
10320  * in ISO/IEC 23001-7). @container points to the node that contains these boxes
10321  * (typically an enc[v|a|t|s] sample entry); the function will set
10322  * @original_fmt to the fourcc of the original unencrypted stream format.
10323  * Returns TRUE if successful; FALSE otherwise. */
10324 static gboolean
10325 qtdemux_parse_protection_scheme_info (GstQTDemux * qtdemux,
10326     QtDemuxStream * stream, GNode * container, guint32 * original_fmt)
10327 {
10328   GNode *sinf;
10329   GNode *frma;
10330   GNode *schm;
10331   GNode *schi;
<a name="339" id="anc339"></a><span class="line-added">10332   QtDemuxCencSampleSetInfo *info;</span>
<span class="line-added">10333   GNode *tenc;</span>
<span class="line-added">10334   const guint8 *tenc_data;</span>
10335 
10336   g_return_val_if_fail (qtdemux != NULL, FALSE);
10337   g_return_val_if_fail (stream != NULL, FALSE);
10338   g_return_val_if_fail (container != NULL, FALSE);
10339   g_return_val_if_fail (original_fmt != NULL, FALSE);
10340 
10341   sinf = qtdemux_tree_get_child_by_type (container, FOURCC_sinf);
10342   if (G_UNLIKELY (!sinf)) {
10343     if (stream-&gt;protection_scheme_type == FOURCC_cenc) {
10344       GST_ERROR_OBJECT (qtdemux, &quot;sinf box does not contain schi box, which is &quot;
10345           &quot;mandatory for Common Encryption&quot;);
10346       return FALSE;
10347     }
10348     return TRUE;
10349   }
10350 
10351   frma = qtdemux_tree_get_child_by_type (sinf, FOURCC_frma);
10352   if (G_UNLIKELY (!frma)) {
10353     GST_ERROR_OBJECT (qtdemux, &quot;sinf box does not contain mandatory frma box&quot;);
10354     return FALSE;
10355   }
10356 
10357   *original_fmt = QT_FOURCC ((const guint8 *) frma-&gt;data + 8);
10358   GST_DEBUG_OBJECT (qtdemux, &quot;original stream format: &#39;%&quot; GST_FOURCC_FORMAT &quot;&#39;&quot;,
10359       GST_FOURCC_ARGS (*original_fmt));
10360 
10361   schm = qtdemux_tree_get_child_by_type (sinf, FOURCC_schm);
10362   if (!schm) {
10363     GST_DEBUG_OBJECT (qtdemux, &quot;sinf box does not contain schm box&quot;);
10364     return FALSE;
10365   }
10366   stream-&gt;protection_scheme_type = QT_FOURCC ((const guint8 *) schm-&gt;data + 12);
10367   stream-&gt;protection_scheme_version =
10368       QT_UINT32 ((const guint8 *) schm-&gt;data + 16);
10369 
10370   GST_DEBUG_OBJECT (qtdemux,
10371       &quot;protection_scheme_type: %&quot; GST_FOURCC_FORMAT &quot;, &quot;
10372       &quot;protection_scheme_version: %#010x&quot;,
10373       GST_FOURCC_ARGS (stream-&gt;protection_scheme_type),
10374       stream-&gt;protection_scheme_version);
10375 
10376   schi = qtdemux_tree_get_child_by_type (sinf, FOURCC_schi);
10377   if (!schi) {
10378     GST_DEBUG_OBJECT (qtdemux, &quot;sinf box does not contain schi box&quot;);
10379     return FALSE;
10380   }
<a name="340" id="anc340"></a><span class="line-added">10381   if (stream-&gt;protection_scheme_type != FOURCC_cenc &amp;&amp;</span>
<span class="line-added">10382       stream-&gt;protection_scheme_type != FOURCC_piff) {</span>
<span class="line-added">10383     GST_ERROR_OBJECT (qtdemux,</span>
<span class="line-added">10384         &quot;Invalid protection_scheme_type: %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-added">10385         GST_FOURCC_ARGS (stream-&gt;protection_scheme_type));</span>
<span class="line-added">10386     return FALSE;</span>
<span class="line-added">10387   }</span>
<span class="line-added">10388 </span>
<span class="line-added">10389   if (G_UNLIKELY (!stream-&gt;protection_scheme_info))</span>
<span class="line-added">10390     stream-&gt;protection_scheme_info =</span>
<span class="line-added">10391         g_malloc0 (sizeof (QtDemuxCencSampleSetInfo));</span>
<span class="line-added">10392 </span>
<span class="line-added">10393   info = (QtDemuxCencSampleSetInfo *) stream-&gt;protection_scheme_info;</span>
<span class="line-added">10394 </span>
10395   if (stream-&gt;protection_scheme_type == FOURCC_cenc) {
<a name="341" id="anc341"></a><span class="line-modified">10396     guint32 is_encrypted;</span>



10397     guint8 iv_size;
10398     const guint8 *default_kid;
<a name="342" id="anc342"></a>






10399 
10400     tenc = qtdemux_tree_get_child_by_type (schi, FOURCC_tenc);
10401     if (!tenc) {
10402       GST_ERROR_OBJECT (qtdemux, &quot;schi box does not contain tenc box, &quot;
10403           &quot;which is mandatory for Common Encryption&quot;);
10404       return FALSE;
10405     }
10406     tenc_data = (const guint8 *) tenc-&gt;data + 12;
<a name="343" id="anc343"></a><span class="line-modified">10407     is_encrypted = QT_UINT24 (tenc_data);</span>
10408     iv_size = QT_UINT8 (tenc_data + 3);
10409     default_kid = (tenc_data + 4);
<a name="344" id="anc344"></a><span class="line-modified">10410     qtdemux_update_default_sample_encryption_settings (qtdemux, info,</span>
<span class="line-modified">10411         is_encrypted, iv_size, default_kid);</span>
<span class="line-modified">10412   } else if (stream-&gt;protection_scheme_type == FOURCC_piff) {</span>
<span class="line-modified">10413     GstByteReader br;</span>
<span class="line-modified">10414     static const guint8 piff_track_encryption_uuid[] = {</span>
<span class="line-modified">10415       0x89, 0x74, 0xdb, 0xce, 0x7b, 0xe7, 0x4c, 0x51,</span>
<span class="line-modified">10416       0x84, 0xf9, 0x71, 0x48, 0xf9, 0x88, 0x25, 0x54</span>
<span class="line-modified">10417     };</span>
<span class="line-modified">10418 </span>
<span class="line-modified">10419     tenc = qtdemux_tree_get_child_by_type (schi, FOURCC_uuid);</span>
<span class="line-modified">10420     if (!tenc) {</span>
<span class="line-modified">10421       GST_ERROR_OBJECT (qtdemux, &quot;schi box does not contain tenc box, &quot;</span>
<span class="line-added">10422           &quot;which is mandatory for Common Encryption&quot;);</span>
<span class="line-added">10423       return FALSE;</span>
<span class="line-added">10424     }</span>
<span class="line-added">10425 </span>
<span class="line-added">10426     tenc_data = (const guint8 *) tenc-&gt;data + 8;</span>
<span class="line-added">10427     if (memcmp (tenc_data, piff_track_encryption_uuid, 16) != 0) {</span>
<span class="line-added">10428       gchar *box_uuid = qtdemux_uuid_bytes_to_string (tenc_data);</span>
<span class="line-added">10429       GST_ERROR_OBJECT (qtdemux,</span>
<span class="line-added">10430           &quot;Unsupported track encryption box with uuid: %s&quot;, box_uuid);</span>
<span class="line-added">10431       g_free (box_uuid);</span>
<span class="line-added">10432       return FALSE;</span>
<span class="line-added">10433     }</span>
<span class="line-added">10434     tenc_data = (const guint8 *) tenc-&gt;data + 16 + 12;</span>
<span class="line-added">10435     gst_byte_reader_init (&amp;br, tenc_data, 20);</span>
<span class="line-added">10436     if (!qtdemux_update_default_piff_encryption_settings (qtdemux, info, &amp;br)) {</span>
<span class="line-added">10437       GST_ERROR_OBJECT (qtdemux, &quot;PIFF track box parsing error&quot;);</span>
<span class="line-added">10438       return FALSE;</span>
<span class="line-added">10439     }</span>
<span class="line-added">10440     stream-&gt;protection_scheme_type = FOURCC_cenc;</span>
10441   }
<a name="345" id="anc345"></a><span class="line-added">10442 </span>
10443   return TRUE;
10444 }
10445 
<a name="346" id="anc346"></a><span class="line-added">10446 static gint</span>
<span class="line-added">10447 qtdemux_track_id_compare_func (QtDemuxStream ** stream1,</span>
<span class="line-added">10448     QtDemuxStream ** stream2)</span>
<span class="line-added">10449 {</span>
<span class="line-added">10450   return (gint) (*stream1)-&gt;track_id - (gint) (*stream2)-&gt;track_id;</span>
<span class="line-added">10451 }</span>
<span class="line-added">10452 </span>
10453 /* parse the traks.
10454  * With each track we associate a new QtDemuxStream that contains all the info
10455  * about the trak.
10456  * traks that do not decode to something (like strm traks) will not have a pad.
10457  */
10458 static gboolean
10459 qtdemux_parse_trak (GstQTDemux * qtdemux, GNode * trak)
10460 {
10461   GstByteReader tkhd;
10462   int offset;
10463   GNode *mdia;
10464   GNode *mdhd;
10465   GNode *hdlr;
10466   GNode *minf;
10467   GNode *stbl;
10468   GNode *stsd;
10469   GNode *mp4a;
10470   GNode *mp4v;
10471   GNode *esds;
10472   GNode *tref;
10473   GNode *udta;
10474   GNode *svmi;
10475 
10476   QtDemuxStream *stream = NULL;
<a name="347" id="anc347"></a>
10477   const guint8 *stsd_data;
10478   const guint8 *stsd_entry_data;
10479   guint remaining_stsd_len;
10480   guint stsd_entry_count;
10481   guint stsd_index;
10482   guint16 lang_code;            /* quicktime lang code or packed iso code */
10483   guint32 version;
10484   guint32 tkhd_flags = 0;
10485   guint8 tkhd_version = 0;
10486   guint32 w = 0, h = 0;
10487   guint value_size, stsd_len, len;
10488   guint32 track_id;
10489   guint32 dummy;
10490 
10491   GST_DEBUG_OBJECT (qtdemux, &quot;parse_trak&quot;);
10492 
10493   if (!qtdemux_tree_get_child_by_type_full (trak, FOURCC_tkhd, &amp;tkhd)
10494       || !gst_byte_reader_get_uint8 (&amp;tkhd, &amp;tkhd_version)
10495       || !gst_byte_reader_get_uint24_be (&amp;tkhd, &amp;tkhd_flags))
10496     goto corrupt_file;
10497 
10498   /* pick between 64 or 32 bits */
10499   value_size = tkhd_version == 1 ? 8 : 4;
10500   if (!gst_byte_reader_skip (&amp;tkhd, value_size * 2) ||
10501       !gst_byte_reader_get_uint32_be (&amp;tkhd, &amp;track_id))
10502     goto corrupt_file;
10503 
<a name="348" id="anc348"></a><span class="line-modified">10504   /* Check if current moov has duplicated track_id */</span>
<span class="line-modified">10505   if (qtdemux_find_stream (qtdemux, track_id))</span>
<span class="line-modified">10506     goto existing_stream;</span>
<span class="line-modified">10507 </span>
<span class="line-modified">10508   stream = _create_stream (qtdemux, track_id);</span>
<span class="line-modified">10509   stream-&gt;stream_tags = gst_tag_list_make_writable (stream-&gt;stream_tags);</span>






10510 
<a name="349" id="anc349"></a>


10511   /* need defaults for fragments */
10512   qtdemux_parse_trex (qtdemux, stream, &amp;dummy, &amp;dummy, &amp;dummy);
10513 
10514   if ((tkhd_flags &amp; 1) == 0)
10515     stream-&gt;disabled = TRUE;
10516 
10517 #ifdef GSTREAMER_LITE
10518   // set track_enabled based on bit 0 of flags
10519   stream-&gt;track_enabled = (gboolean)(tkhd_flags &amp; 0x000001);
10520 #endif // GSTREAMER_LITE
10521 
10522   GST_LOG_OBJECT (qtdemux, &quot;track[tkhd] version/flags/id: 0x%02x/%06x/%u&quot;,
10523       tkhd_version, tkhd_flags, stream-&gt;track_id);
10524 
10525   if (!(mdia = qtdemux_tree_get_child_by_type (trak, FOURCC_mdia)))
10526     goto corrupt_file;
10527 
10528   if (!(mdhd = qtdemux_tree_get_child_by_type (mdia, FOURCC_mdhd))) {
10529     /* be nice for some crooked mjp2 files that use mhdr for mdhd */
10530     if (qtdemux-&gt;major_brand != FOURCC_mjp2 ||
10531         !(mdhd = qtdemux_tree_get_child_by_type (mdia, FOURCC_mhdr)))
10532       goto corrupt_file;
10533   }
10534 
10535   len = QT_UINT32 ((guint8 *) mdhd-&gt;data);
10536   version = QT_UINT32 ((guint8 *) mdhd-&gt;data + 8);
10537   GST_LOG_OBJECT (qtdemux, &quot;track version/flags: %08x&quot;, version);
10538   if (version == 0x01000000) {
<a name="350" id="anc350"></a><span class="line-modified">10539     if (len &lt; 42)</span>
10540       goto corrupt_file;
10541     stream-&gt;timescale = QT_UINT32 ((guint8 *) mdhd-&gt;data + 28);
10542     stream-&gt;duration = QT_UINT64 ((guint8 *) mdhd-&gt;data + 32);
<a name="351" id="anc351"></a><span class="line-modified">10543     lang_code = QT_UINT16 ((guint8 *) mdhd-&gt;data + 40);</span>
10544   } else {
10545     if (len &lt; 30)
10546       goto corrupt_file;
10547     stream-&gt;timescale = QT_UINT32 ((guint8 *) mdhd-&gt;data + 20);
10548     stream-&gt;duration = QT_UINT32 ((guint8 *) mdhd-&gt;data + 24);
10549     lang_code = QT_UINT16 ((guint8 *) mdhd-&gt;data + 28);
10550   }
10551 
10552   if (lang_code &lt; 0x400) {
10553     qtdemux_lang_map_qt_code_to_iso (stream-&gt;lang_id, lang_code);
10554   } else if (lang_code == 0x7fff) {
10555     stream-&gt;lang_id[0] = 0;     /* unspecified */
10556   } else {
10557     stream-&gt;lang_id[0] = 0x60 + ((lang_code &gt;&gt; 10) &amp; 0x1F);
10558     stream-&gt;lang_id[1] = 0x60 + ((lang_code &gt;&gt; 5) &amp; 0x1F);
10559     stream-&gt;lang_id[2] = 0x60 + (lang_code &amp; 0x1F);
10560     stream-&gt;lang_id[3] = 0;
10561   }
10562 
10563   GST_LOG_OBJECT (qtdemux, &quot;track timescale: %&quot; G_GUINT32_FORMAT,
10564       stream-&gt;timescale);
10565   GST_LOG_OBJECT (qtdemux, &quot;track duration: %&quot; G_GUINT64_FORMAT,
10566       stream-&gt;duration);
10567   GST_LOG_OBJECT (qtdemux, &quot;track language code/id: 0x%04x/%s&quot;,
10568       lang_code, stream-&gt;lang_id);
10569 
10570   if (G_UNLIKELY (stream-&gt;timescale == 0 || qtdemux-&gt;timescale == 0))
10571     goto corrupt_file;
10572 
10573   if ((tref = qtdemux_tree_get_child_by_type (trak, FOURCC_tref))) {
10574     /* chapters track reference */
10575     GNode *chap = qtdemux_tree_get_child_by_type (tref, FOURCC_chap);
10576     if (chap) {
10577       gsize length = GST_READ_UINT32_BE (chap-&gt;data);
10578       if (qtdemux-&gt;chapters_track_id)
10579         GST_FIXME_OBJECT (qtdemux, &quot;Multiple CHAP tracks&quot;);
10580 
10581       if (length &gt;= 12) {
10582         qtdemux-&gt;chapters_track_id =
10583             GST_READ_UINT32_BE ((gint8 *) chap-&gt;data + 8);
10584       }
10585     }
10586   }
10587 
10588   /* fragmented files may have bogus duration in moov */
10589   if (!qtdemux-&gt;fragmented &amp;&amp;
10590       qtdemux-&gt;duration != G_MAXINT64 &amp;&amp; stream-&gt;duration != G_MAXINT32) {
10591     guint64 tdur1, tdur2;
10592 
10593     /* don&#39;t overflow */
10594     tdur1 = stream-&gt;timescale * (guint64) qtdemux-&gt;duration;
10595     tdur2 = qtdemux-&gt;timescale * (guint64) stream-&gt;duration;
10596 
10597     /* HACK:
10598      * some of those trailers, nowadays, have prologue images that are
10599      * themselves video tracks as well. I haven&#39;t really found a way to
10600      * identify those yet, except for just looking at their duration. */
10601     if (tdur1 != 0 &amp;&amp; (tdur2 * 10 / tdur1) &lt; 2) {
10602       GST_WARNING_OBJECT (qtdemux,
10603           &quot;Track shorter than 20%% (%&quot; G_GUINT64_FORMAT &quot;/%&quot; G_GUINT32_FORMAT
10604           &quot; vs. %&quot; G_GUINT64_FORMAT &quot;/%&quot; G_GUINT32_FORMAT &quot;) of the stream &quot;
10605           &quot;found, assuming preview image or something; skipping track&quot;,
10606           stream-&gt;duration, stream-&gt;timescale, qtdemux-&gt;duration,
10607           qtdemux-&gt;timescale);
<a name="352" id="anc352"></a><span class="line-modified">10608       gst_qtdemux_stream_unref (stream);</span>

10609       return TRUE;
10610     }
10611   }
10612 
10613   if (!(hdlr = qtdemux_tree_get_child_by_type (mdia, FOURCC_hdlr)))
10614     goto corrupt_file;
10615 
10616   GST_LOG_OBJECT (qtdemux, &quot;track type: %&quot; GST_FOURCC_FORMAT,
10617       GST_FOURCC_ARGS (QT_FOURCC ((guint8 *) hdlr-&gt;data + 12)));
10618 
10619   len = QT_UINT32 ((guint8 *) hdlr-&gt;data);
10620   if (len &gt;= 20)
10621     stream-&gt;subtype = QT_FOURCC ((guint8 *) hdlr-&gt;data + 16);
10622   GST_LOG_OBJECT (qtdemux, &quot;track subtype: %&quot; GST_FOURCC_FORMAT,
10623       GST_FOURCC_ARGS (stream-&gt;subtype));
10624 
10625   if (!(minf = qtdemux_tree_get_child_by_type (mdia, FOURCC_minf)))
10626     goto corrupt_file;
10627 
10628   if (!(stbl = qtdemux_tree_get_child_by_type (minf, FOURCC_stbl)))
10629     goto corrupt_file;
10630 
10631   /*parse svmi header if existing */
10632   svmi = qtdemux_tree_get_child_by_type (stbl, FOURCC_svmi);
10633   if (svmi) {
10634     len = QT_UINT32 ((guint8 *) svmi-&gt;data);
10635     version = QT_UINT32 ((guint8 *) svmi-&gt;data + 8);
10636     if (!version) {
10637       GstVideoMultiviewMode mode = GST_VIDEO_MULTIVIEW_MODE_NONE;
10638       GstVideoMultiviewFlags flags = GST_VIDEO_MULTIVIEW_FLAGS_NONE;
10639       guint8 frame_type, frame_layout;
10640 
10641       /* MPEG-A stereo video */
10642       if (qtdemux-&gt;major_brand == FOURCC_ss02)
10643         flags |= GST_VIDEO_MULTIVIEW_FLAGS_MIXED_MONO;
10644 
10645       frame_type = QT_UINT8 ((guint8 *) svmi-&gt;data + 12);
10646       frame_layout = QT_UINT8 ((guint8 *) svmi-&gt;data + 13) &amp; 0x01;
10647       switch (frame_type) {
10648         case 0:
10649           mode = GST_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE;
10650           break;
10651         case 1:
10652           mode = GST_VIDEO_MULTIVIEW_MODE_ROW_INTERLEAVED;
10653           break;
10654         case 2:
10655           mode = GST_VIDEO_MULTIVIEW_MODE_FRAME_BY_FRAME;
10656           break;
10657         case 3:
10658           /* mode 3 is primary/secondary view sequence, ie
10659            * left/right views in separate tracks. See section 7.2
10660            * of ISO/IEC 23000-11:2009 */
10661           GST_FIXME_OBJECT (qtdemux,
10662               &quot;Implement stereo video in separate streams&quot;);
10663       }
10664 
10665       if ((frame_layout &amp; 0x1) == 0)
10666         flags |= GST_VIDEO_MULTIVIEW_FLAGS_RIGHT_VIEW_FIRST;
10667 
10668       GST_LOG_OBJECT (qtdemux,
10669           &quot;StereoVideo: composition type: %u, is_left_first: %u&quot;,
10670           frame_type, frame_layout);
10671       stream-&gt;multiview_mode = mode;
10672       stream-&gt;multiview_flags = flags;
10673     }
10674   }
10675 
10676   /* parse rest of tkhd */
10677   if (stream-&gt;subtype == FOURCC_vide) {
10678     guint32 matrix[9];
10679 
10680     /* version 1 uses some 64-bit ints */
10681     if (!gst_byte_reader_skip (&amp;tkhd, 20 + value_size))
10682       goto corrupt_file;
10683 
10684     if (!qtdemux_parse_transformation_matrix (qtdemux, &amp;tkhd, matrix, &quot;tkhd&quot;))
10685       goto corrupt_file;
10686 
10687     if (!gst_byte_reader_get_uint32_be (&amp;tkhd, &amp;w)
10688         || !gst_byte_reader_get_uint32_be (&amp;tkhd, &amp;h))
10689       goto corrupt_file;
10690 
10691     qtdemux_inspect_transformation_matrix (qtdemux, stream, matrix,
10692         &amp;stream-&gt;stream_tags);
10693   }
10694 
10695   /* parse stsd */
10696   if (!(stsd = qtdemux_tree_get_child_by_type (stbl, FOURCC_stsd)))
10697     goto corrupt_file;
10698   stsd_data = (const guint8 *) stsd-&gt;data;
10699 
10700   /* stsd should at least have one entry */
10701   stsd_len = QT_UINT32 (stsd_data);
10702   if (stsd_len &lt; 24) {
10703     /* .. but skip stream with empty stsd produced by some Vivotek cameras */
10704     if (stream-&gt;subtype == FOURCC_vivo) {
<a name="353" id="anc353"></a><span class="line-modified">10705       gst_qtdemux_stream_unref (stream);</span>

10706       return TRUE;
10707     } else {
<a name="354" id="anc354"></a><span class="line-modified">10708       goto corrupt_file;</span>
10709     }
10710   }
10711 
10712   stream-&gt;stsd_entries_length = stsd_entry_count = QT_UINT32 (stsd_data + 12);
10713   stream-&gt;stsd_entries = g_new0 (QtDemuxStreamStsdEntry, stsd_entry_count);
10714 #ifdef GSTREAMER_LITE
10715   // Even if we check stsd header length (stsd_len) to make sure we have at least
10716   // one entry, we still might have actual entry count set to 0. g_new0() will
10717   // return NULL if fail or count is 0.
10718   if (stream-&gt;stsd_entries == NULL) {
10719     goto corrupt_file;
10720   }
10721 #endif // GSTREAMER_LITE
10722   GST_LOG_OBJECT (qtdemux, &quot;stsd len:           %d&quot;, stsd_len);
10723   GST_LOG_OBJECT (qtdemux, &quot;stsd entry count:   %u&quot;, stsd_entry_count);
10724 
10725   stsd_entry_data = stsd_data + 16;
10726   remaining_stsd_len = stsd_len - 16;
10727   for (stsd_index = 0; stsd_index &lt; stsd_entry_count; stsd_index++) {
10728     guint32 fourcc;
10729     gchar *codec = NULL;
10730     QtDemuxStreamStsdEntry *entry = &amp;stream-&gt;stsd_entries[stsd_index];
10731 
<a name="355" id="anc355"></a><span class="line-modified">10732     /* and that entry should fit within stsd */</span>
10733     len = QT_UINT32 (stsd_entry_data);
10734     if (len &gt; remaining_stsd_len)
<a name="356" id="anc356"></a><span class="line-modified">10735       goto corrupt_file;</span>
10736 
10737     entry-&gt;fourcc = fourcc = QT_FOURCC (stsd_entry_data + 4);
<a name="357" id="anc357"></a><span class="line-modified">10738     GST_LOG_OBJECT (qtdemux, &quot;stsd type:          %&quot; GST_FOURCC_FORMAT,</span>
10739         GST_FOURCC_ARGS (entry-&gt;fourcc));
<a name="358" id="anc358"></a><span class="line-modified">10740     GST_LOG_OBJECT (qtdemux, &quot;stsd type len:      %d&quot;, len);</span>
10741 
10742     if ((fourcc == FOURCC_drms) || (fourcc == FOURCC_drmi))
<a name="359" id="anc359"></a><span class="line-modified">10743       goto error_encrypted;</span>
10744 
10745     if (fourcc == FOURCC_encv || fourcc == FOURCC_enca) {
10746       /* FIXME this looks wrong, there might be multiple children
10747        * with the same type */
10748       GNode *enc = qtdemux_tree_get_child_by_type (stsd, fourcc);
10749       stream-&gt;protected = TRUE;
10750       if (!qtdemux_parse_protection_scheme_info (qtdemux, stream, enc, &amp;fourcc))
10751         GST_ERROR_OBJECT (qtdemux, &quot;Failed to parse protection scheme info&quot;);
10752     }
10753 
<a name="360" id="anc360"></a><span class="line-modified">10754     if (stream-&gt;subtype == FOURCC_vide) {</span>
10755       GNode *colr;
10756       GNode *fiel;
10757       GNode *pasp;
<a name="361" id="anc361"></a><span class="line-modified">10758       gboolean gray;</span>
<span class="line-modified">10759       gint depth, palette_size, palette_count;</span>
<span class="line-modified">10760       guint32 *palette_data = NULL;</span>
10761 
10762       entry-&gt;sampled = TRUE;
10763 
<a name="362" id="anc362"></a><span class="line-modified">10764       stream-&gt;display_width = w &gt;&gt; 16;</span>
<span class="line-modified">10765       stream-&gt;display_height = h &gt;&gt; 16;</span>
10766 
<a name="363" id="anc363"></a><span class="line-modified">10767       offset = 16;</span>
10768       if (len &lt; 86)             /* TODO verify */
<a name="364" id="anc364"></a><span class="line-modified">10769         goto corrupt_file;</span>
10770 
10771       entry-&gt;width = QT_UINT16 (stsd_entry_data + offset + 16);
10772       entry-&gt;height = QT_UINT16 (stsd_entry_data + offset + 18);
10773       entry-&gt;fps_n = 0;         /* this is filled in later */
10774       entry-&gt;fps_d = 0;         /* this is filled in later */
10775       entry-&gt;bits_per_sample = QT_UINT16 (stsd_entry_data + offset + 66);
10776       entry-&gt;color_table_id = QT_UINT16 (stsd_entry_data + offset + 68);
10777 
10778       /* if color_table_id is 0, ctab atom must follow; however some files
10779        * produced by TMPEGEnc have color_table_id = 0 and no ctab atom, so
10780        * if color table is not present we&#39;ll correct the value */
10781       if (entry-&gt;color_table_id == 0 &amp;&amp;
10782           (len &lt; 90
10783               || QT_FOURCC (stsd_entry_data + offset + 70) != FOURCC_ctab)) {
10784         entry-&gt;color_table_id = -1;
10785       }
10786 
<a name="365" id="anc365"></a><span class="line-modified">10787       GST_LOG_OBJECT (qtdemux, &quot;width %d, height %d, bps %d, color table id %d&quot;,</span>
10788           entry-&gt;width, entry-&gt;height, entry-&gt;bits_per_sample,
10789           entry-&gt;color_table_id);
10790 
10791       depth = entry-&gt;bits_per_sample;
10792 
<a name="366" id="anc366"></a><span class="line-modified">10793       /* more than 32 bits means grayscale */</span>
<span class="line-modified">10794       gray = (depth &gt; 32);</span>
<span class="line-modified">10795       /* low 32 bits specify the depth  */</span>
<span class="line-modified">10796       depth &amp;= 0x1F;</span>
10797 
<a name="367" id="anc367"></a><span class="line-modified">10798       /* different number of palette entries is determined by depth. */</span>
<span class="line-modified">10799       palette_count = 0;</span>
<span class="line-modified">10800       if ((depth == 1) || (depth == 2) || (depth == 4) || (depth == 8))</span>
<span class="line-modified">10801         palette_count = (1 &lt;&lt; depth);</span>
<span class="line-modified">10802       palette_size = palette_count * 4;</span>
10803 
10804       if (entry-&gt;color_table_id) {
<a name="368" id="anc368"></a><span class="line-modified">10805         switch (palette_count) {</span>
<span class="line-modified">10806           case 0:</span>
<span class="line-modified">10807             break;</span>
<span class="line-modified">10808           case 2:</span>
<span class="line-modified">10809             palette_data = g_memdup (ff_qt_default_palette_2, palette_size);</span>
<span class="line-modified">10810             break;</span>
<span class="line-modified">10811           case 4:</span>
<span class="line-modified">10812             palette_data = g_memdup (ff_qt_default_palette_4, palette_size);</span>
<span class="line-modified">10813             break;</span>
<span class="line-modified">10814           case 16:</span>
<span class="line-modified">10815             if (gray)</span>
10816               palette_data =
10817                   g_memdup (ff_qt_grayscale_palette_16, palette_size);
<a name="369" id="anc369"></a><span class="line-modified">10818             else</span>
<span class="line-modified">10819               palette_data = g_memdup (ff_qt_default_palette_16, palette_size);</span>
<span class="line-modified">10820             break;</span>
<span class="line-modified">10821           case 256:</span>
<span class="line-modified">10822             if (gray)</span>
10823               palette_data =
10824                   g_memdup (ff_qt_grayscale_palette_256, palette_size);
<a name="370" id="anc370"></a><span class="line-modified">10825             else</span>
<span class="line-modified">10826               palette_data = g_memdup (ff_qt_default_palette_256, palette_size);</span>
<span class="line-modified">10827             break;</span>
<span class="line-modified">10828           default:</span>
<span class="line-modified">10829             GST_ELEMENT_WARNING (qtdemux, STREAM, DEMUX,</span>
<span class="line-modified">10830                 (_(&quot;The video in this file might not play correctly.&quot;)),</span>
<span class="line-modified">10831                 (&quot;unsupported palette depth %d&quot;, depth));</span>
<span class="line-modified">10832             break;</span>
<span class="line-modified">10833         }</span>
<span class="line-modified">10834       } else {</span>
<span class="line-modified">10835         gint i, j, start, end;</span>
10836 
<a name="371" id="anc371"></a><span class="line-modified">10837         if (len &lt; 94)</span>
<span class="line-modified">10838           goto corrupt_file;</span>
10839 
<a name="372" id="anc372"></a><span class="line-modified">10840         /* read table */</span>
10841         start = QT_UINT32 (stsd_entry_data + offset + 70);
10842         palette_count = QT_UINT16 (stsd_entry_data + offset + 74);
10843         end = QT_UINT16 (stsd_entry_data + offset + 76);
10844 
<a name="373" id="anc373"></a><span class="line-modified">10845         GST_LOG_OBJECT (qtdemux, &quot;start %d, end %d, palette_count %d&quot;,</span>
<span class="line-modified">10846             start, end, palette_count);</span>
10847 
<a name="374" id="anc374"></a><span class="line-modified">10848         if (end &gt; 255)</span>
<span class="line-modified">10849           end = 255;</span>
<span class="line-modified">10850         if (start &gt; end)</span>
<span class="line-modified">10851           start = end;</span>
10852 
<a name="375" id="anc375"></a><span class="line-modified">10853         if (len &lt; 94 + (end - start) * 8)</span>
<span class="line-modified">10854           goto corrupt_file;</span>
10855 
<a name="376" id="anc376"></a><span class="line-modified">10856         /* palette is always the same size */</span>
<span class="line-modified">10857         palette_data = g_malloc0 (256 * 4);</span>
<span class="line-modified">10858         palette_size = 256 * 4;</span>
10859 
<a name="377" id="anc377"></a><span class="line-modified">10860         for (j = 0, i = start; i &lt;= end; j++, i++) {</span>
<span class="line-modified">10861           guint32 a, r, g, b;</span>
10862 
10863           a = QT_UINT16 (stsd_entry_data + offset + 78 + (j * 8));
10864           r = QT_UINT16 (stsd_entry_data + offset + 80 + (j * 8));
10865           g = QT_UINT16 (stsd_entry_data + offset + 82 + (j * 8));
10866           b = QT_UINT16 (stsd_entry_data + offset + 84 + (j * 8));
10867 
<a name="378" id="anc378"></a><span class="line-modified">10868           palette_data[i] = ((a &amp; 0xff00) &lt;&lt; 16) | ((r &amp; 0xff00) &lt;&lt; 8) |</span>
<span class="line-modified">10869               (g &amp; 0xff00) | (b &gt;&gt; 8);</span>
<span class="line-added">10870         }</span>
10871       }
<a name="379" id="anc379"></a>
10872 
10873       if (entry-&gt;caps)
10874         gst_caps_unref (entry-&gt;caps);
10875 
10876       entry-&gt;caps =
10877           qtdemux_video_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,
10878           &amp;codec);
10879       if (G_UNLIKELY (!entry-&gt;caps)) {
<a name="380" id="anc380"></a><span class="line-modified">10880         g_free (palette_data);</span>
<span class="line-modified">10881         goto unknown_stream;</span>
<span class="line-modified">10882       }</span>
10883 
<a name="381" id="anc381"></a><span class="line-modified">10884       if (codec) {</span>
10885         gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<a name="382" id="anc382"></a><span class="line-modified">10886             GST_TAG_VIDEO_CODEC, codec, NULL);</span>
<span class="line-modified">10887         g_free (codec);</span>
<span class="line-modified">10888         codec = NULL;</span>
<span class="line-modified">10889       }</span>
10890 
<a name="383" id="anc383"></a><span class="line-modified">10891       if (palette_data) {</span>
<span class="line-modified">10892         GstStructure *s;</span>
10893 
10894         if (entry-&gt;rgb8_palette)
10895           gst_memory_unref (entry-&gt;rgb8_palette);
10896         entry-&gt;rgb8_palette = gst_memory_new_wrapped (GST_MEMORY_FLAG_READONLY,
<a name="384" id="anc384"></a><span class="line-modified">10897             palette_data, palette_size, 0, palette_size, palette_data, g_free);</span>
10898 
10899         s = gst_caps_get_structure (entry-&gt;caps, 0);
10900 
<a name="385" id="anc385"></a><span class="line-modified">10901         /* non-raw video has a palette_data property. raw video has the palette as</span>
<span class="line-modified">10902          * an extra plane that we append to the output buffers before we push</span>
<span class="line-modified">10903          * them*/</span>
<span class="line-modified">10904         if (!gst_structure_has_name (s, &quot;video/x-raw&quot;)) {</span>
<span class="line-modified">10905           GstBuffer *palette;</span>
10906 
<a name="386" id="anc386"></a><span class="line-modified">10907           palette = gst_buffer_new ();</span>
10908           gst_buffer_append_memory (palette, entry-&gt;rgb8_palette);
10909           entry-&gt;rgb8_palette = NULL;
10910 
10911           gst_caps_set_simple (entry-&gt;caps, &quot;palette_data&quot;,
<a name="387" id="anc387"></a><span class="line-modified">10912               GST_TYPE_BUFFER, palette, NULL);</span>
<span class="line-modified">10913           gst_buffer_unref (palette);</span>
<span class="line-added">10914         }</span>
<span class="line-added">10915       } else if (palette_count != 0) {</span>
<span class="line-added">10916         GST_ELEMENT_WARNING (qtdemux, STREAM, NOT_IMPLEMENTED,</span>
<span class="line-added">10917             (NULL), (&quot;Unsupported palette depth %d&quot;, depth));</span>
10918       }
<a name="388" id="anc388"></a>



10919 
<a name="389" id="anc389"></a><span class="line-modified">10920       GST_LOG_OBJECT (qtdemux, &quot;frame count:   %u&quot;,</span>
10921           QT_UINT16 (stsd_entry_data + offset + 32));
10922 
<a name="390" id="anc390"></a><span class="line-modified">10923       esds = NULL;</span>
<span class="line-modified">10924       pasp = NULL;</span>
10925       colr = NULL;
10926       fiel = NULL;
<a name="391" id="anc391"></a><span class="line-modified">10927       /* pick &#39;the&#39; stsd child */</span>
10928       mp4v = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<a name="392" id="anc392"></a><span class="line-modified">10929       // We should skip parsing the stsd for non-protected streams if</span>
<span class="line-modified">10930       // the entry doesn&#39;t match the fourcc, since they don&#39;t change</span>
<span class="line-added">10931       // format. However, for protected streams we can have partial</span>
<span class="line-added">10932       // encryption, where parts of the stream are encrypted and parts</span>
<span class="line-added">10933       // not. For both parts of such streams, we should ensure the</span>
<span class="line-added">10934       // esds overrides are parsed for both from the stsd.</span>
<span class="line-added">10935       if (QTDEMUX_TREE_NODE_FOURCC (mp4v) != fourcc) {</span>
<span class="line-added">10936         if (stream-&gt;protected &amp;&amp; QTDEMUX_TREE_NODE_FOURCC (mp4v) != FOURCC_encv)</span>
10937           mp4v = NULL;
<a name="393" id="anc393"></a><span class="line-modified">10938         else if (!stream-&gt;protected)</span>


10939           mp4v = NULL;
<a name="394" id="anc394"></a>
10940       }
10941 
<a name="395" id="anc395"></a><span class="line-modified">10942       if (mp4v) {</span>
<span class="line-modified">10943         esds = qtdemux_tree_get_child_by_type (mp4v, FOURCC_esds);</span>
<span class="line-modified">10944         pasp = qtdemux_tree_get_child_by_type (mp4v, FOURCC_pasp);</span>
10945         colr = qtdemux_tree_get_child_by_type (mp4v, FOURCC_colr);
10946         fiel = qtdemux_tree_get_child_by_type (mp4v, FOURCC_fiel);
<a name="396" id="anc396"></a><span class="line-modified">10947       }</span>
10948 
<a name="397" id="anc397"></a><span class="line-modified">10949       if (pasp) {</span>
<span class="line-modified">10950         const guint8 *pasp_data = (const guint8 *) pasp-&gt;data;</span>
10951         gint len = QT_UINT32 (pasp_data);
10952 
10953         if (len == 16) {
10954           CUR_STREAM (stream)-&gt;par_w = QT_UINT32 (pasp_data + 8);
10955           CUR_STREAM (stream)-&gt;par_h = QT_UINT32 (pasp_data + 12);
<a name="398" id="anc398"></a><span class="line-modified">10956         } else {</span>
10957           CUR_STREAM (stream)-&gt;par_w = 0;
10958           CUR_STREAM (stream)-&gt;par_h = 0;
<a name="399" id="anc399"></a><span class="line-modified">10959         }</span>
10960       } else {
10961         CUR_STREAM (stream)-&gt;par_w = 0;
10962         CUR_STREAM (stream)-&gt;par_h = 0;
10963       }
10964 
10965       if (fiel) {
10966         const guint8 *fiel_data = (const guint8 *) fiel-&gt;data;
10967         gint len = QT_UINT32 (fiel_data);
10968 
10969         if (len == 10) {
10970           CUR_STREAM (stream)-&gt;interlace_mode = GST_READ_UINT8 (fiel_data + 8);
10971           CUR_STREAM (stream)-&gt;field_order = GST_READ_UINT8 (fiel_data + 9);
10972         }
10973       }
10974 
10975       if (colr) {
10976         const guint8 *colr_data = (const guint8 *) colr-&gt;data;
10977         gint len = QT_UINT32 (colr_data);
10978 
10979         if (len == 19 || len == 18) {
10980           guint32 color_type = GST_READ_UINT32_LE (colr_data + 8);
10981 
10982           if (color_type == FOURCC_nclx || color_type == FOURCC_nclc) {
10983             guint16 primaries = GST_READ_UINT16_BE (colr_data + 12);
10984             guint16 transfer_function = GST_READ_UINT16_BE (colr_data + 14);
10985             guint16 matrix = GST_READ_UINT16_BE (colr_data + 16);
10986             gboolean full_range = len == 19 ? colr_data[17] &gt;&gt; 7 : FALSE;
10987 
10988             switch (primaries) {
10989               case 1:
10990                 CUR_STREAM (stream)-&gt;colorimetry.primaries =
10991                     GST_VIDEO_COLOR_PRIMARIES_BT709;
10992                 break;
10993               case 5:
10994                 CUR_STREAM (stream)-&gt;colorimetry.primaries =
10995                     GST_VIDEO_COLOR_PRIMARIES_BT470BG;
10996                 break;
10997               case 6:
10998                 CUR_STREAM (stream)-&gt;colorimetry.primaries =
10999                     GST_VIDEO_COLOR_PRIMARIES_SMPTE170M;
11000                 break;
11001               case 9:
11002                 CUR_STREAM (stream)-&gt;colorimetry.primaries =
11003                     GST_VIDEO_COLOR_PRIMARIES_BT2020;
11004                 break;
11005               default:
11006                 break;
11007             }
11008 
11009             switch (transfer_function) {
11010               case 1:
11011                 CUR_STREAM (stream)-&gt;colorimetry.transfer =
11012                     GST_VIDEO_TRANSFER_BT709;
11013                 break;
11014               case 7:
11015                 CUR_STREAM (stream)-&gt;colorimetry.transfer =
11016                     GST_VIDEO_TRANSFER_SMPTE240M;
11017                 break;
11018               default:
11019                 break;
11020             }
11021 
11022             switch (matrix) {
11023               case 1:
11024                 CUR_STREAM (stream)-&gt;colorimetry.matrix =
11025                     GST_VIDEO_COLOR_MATRIX_BT709;
11026                 break;
11027               case 6:
11028                 CUR_STREAM (stream)-&gt;colorimetry.matrix =
11029                     GST_VIDEO_COLOR_MATRIX_BT601;
11030                 break;
11031               case 7:
11032                 CUR_STREAM (stream)-&gt;colorimetry.matrix =
11033                     GST_VIDEO_COLOR_MATRIX_SMPTE240M;
11034                 break;
11035               case 9:
11036                 CUR_STREAM (stream)-&gt;colorimetry.matrix =
11037                     GST_VIDEO_COLOR_MATRIX_BT2020;
11038                 break;
11039               default:
11040                 break;
11041             }
11042 
11043             CUR_STREAM (stream)-&gt;colorimetry.range =
11044                 full_range ? GST_VIDEO_COLOR_RANGE_0_255 :
11045                 GST_VIDEO_COLOR_RANGE_16_235;
11046           } else {
11047             GST_DEBUG_OBJECT (qtdemux, &quot;Unsupported color type&quot;);
11048           }
11049         } else {
11050           GST_WARNING_OBJECT (qtdemux, &quot;Invalid colr atom size&quot;);
11051         }
11052       }
11053 
<a name="400" id="anc400"></a><span class="line-modified">11054       if (esds) {</span>
11055 #ifdef GSTREAMER_LITE
11056         if (!gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
11057                                       stream-&gt;stream_tags))
11058             goto corrupt_file;
11059 #else
11060         gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
11061             stream-&gt;stream_tags);
11062 #endif // GSTREAMER_LITE
<a name="401" id="anc401"></a><span class="line-modified">11063       } else {</span>
<span class="line-modified">11064         switch (fourcc) {</span>
<span class="line-modified">11065           case FOURCC_H264:</span>
<span class="line-modified">11066           case FOURCC_avc1:</span>
<span class="line-modified">11067           case FOURCC_avc3:</span>
<span class="line-modified">11068           {</span>
11069             gint len = QT_UINT32 (stsd_entry_data) - 0x56;
11070             const guint8 *avc_data = stsd_entry_data + 0x56;
11071 
<a name="402" id="anc402"></a><span class="line-modified">11072             /* find avcC */</span>
<span class="line-modified">11073             while (len &gt;= 0x8) {</span>
<span class="line-modified">11074               gint size;</span>
11075 
<a name="403" id="anc403"></a><span class="line-modified">11076               if (QT_UINT32 (avc_data) &lt;= len)</span>
<span class="line-modified">11077                 size = QT_UINT32 (avc_data) - 0x8;</span>
<span class="line-modified">11078               else</span>
<span class="line-modified">11079                 size = len - 0x8;</span>
11080 
<a name="404" id="anc404"></a><span class="line-modified">11081               if (size &lt; 1)</span>
<span class="line-modified">11082                 /* No real data, so break out */</span>
<span class="line-modified">11083                 break;</span>
11084 
<a name="405" id="anc405"></a><span class="line-modified">11085               switch (QT_FOURCC (avc_data + 0x4)) {</span>
<span class="line-modified">11086                 case FOURCC_avcC:</span>
<span class="line-modified">11087                 {</span>
<span class="line-modified">11088                   /* parse, if found */</span>
<span class="line-modified">11089                   GstBuffer *buf;</span>
11090 
<a name="406" id="anc406"></a><span class="line-modified">11091                   GST_DEBUG_OBJECT (qtdemux, &quot;found avcC codec_data in stsd&quot;);</span>
11092 
<a name="407" id="anc407"></a><span class="line-modified">11093                   /* First 4 bytes are the length of the atom, the next 4 bytes</span>
<span class="line-modified">11094                    * are the fourcc, the next 1 byte is the version, and the</span>
<span class="line-modified">11095                    * subsequent bytes are profile_tier_level structure like data. */</span>
11096                   gst_codec_utils_h264_caps_set_level_and_profile (entry-&gt;caps,
<a name="408" id="anc408"></a><span class="line-modified">11097                       avc_data + 8 + 1, size - 1);</span>
<span class="line-modified">11098                   buf = gst_buffer_new_and_alloc (size);</span>
<span class="line-modified">11099                   gst_buffer_fill (buf, 0, avc_data + 0x8, size);</span>
11100                   gst_caps_set_simple (entry-&gt;caps,
<a name="409" id="anc409"></a><span class="line-modified">11101                       &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">11102                   gst_buffer_unref (buf);</span>
11103 
<a name="410" id="anc410"></a><span class="line-modified">11104                   break;</span>
<span class="line-modified">11105                 }</span>
<span class="line-modified">11106                 case FOURCC_strf:</span>
<span class="line-modified">11107                 {</span>
<span class="line-modified">11108                   GstBuffer *buf;</span>
11109 
<a name="411" id="anc411"></a><span class="line-modified">11110                   GST_DEBUG_OBJECT (qtdemux, &quot;found strf codec_data in stsd&quot;);</span>
11111 
<a name="412" id="anc412"></a><span class="line-modified">11112                   /* First 4 bytes are the length of the atom, the next 4 bytes</span>
<span class="line-modified">11113                    * are the fourcc, next 40 bytes are BITMAPINFOHEADER,</span>
<span class="line-modified">11114                    * next 1 byte is the version, and the</span>
<span class="line-modified">11115                    * subsequent bytes are sequence parameter set like data. */</span>
11116 
11117                   size -= 40;   /* we&#39;ll be skipping BITMAPINFOHEADER */
<a name="413" id="anc413"></a><span class="line-modified">11118                   if (size &gt; 1) {</span>
11119                     gst_codec_utils_h264_caps_set_level_and_profile
11120                         (entry-&gt;caps, avc_data + 8 + 40 + 1, size - 1);
11121 
<a name="414" id="anc414"></a><span class="line-modified">11122                     buf = gst_buffer_new_and_alloc (size);</span>
<span class="line-modified">11123                     gst_buffer_fill (buf, 0, avc_data + 8 + 40, size);</span>
11124                     gst_caps_set_simple (entry-&gt;caps,
<a name="415" id="anc415"></a><span class="line-modified">11125                         &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">11126                     gst_buffer_unref (buf);</span>
<span class="line-added">11127                   }</span>
<span class="line-added">11128                   break;</span>
11129                 }
<a name="416" id="anc416"></a><span class="line-modified">11130                 case FOURCC_btrt:</span>
<span class="line-modified">11131                 {</span>
<span class="line-modified">11132                   guint avg_bitrate, max_bitrate;</span>


11133 
<a name="417" id="anc417"></a><span class="line-modified">11134                   /* bufferSizeDB, maxBitrate and avgBitrate - 4 bytes each */</span>
<span class="line-modified">11135                   if (size &lt; 12)</span>
<span class="line-modified">11136                     break;</span>
11137 
<a name="418" id="anc418"></a><span class="line-modified">11138                   max_bitrate = QT_UINT32 (avc_data + 0xc);</span>
<span class="line-modified">11139                   avg_bitrate = QT_UINT32 (avc_data + 0x10);</span>
11140 
<a name="419" id="anc419"></a><span class="line-modified">11141                   if (!max_bitrate &amp;&amp; !avg_bitrate)</span>
<span class="line-modified">11142                     break;</span>
11143 
<a name="420" id="anc420"></a><span class="line-modified">11144                   /* Some muxers seem to swap the average and maximum bitrates</span>
<span class="line-modified">11145                    * (I&#39;m looking at you, YouTube), so we swap for sanity. */</span>
<span class="line-modified">11146                   if (max_bitrate &gt; 0 &amp;&amp; max_bitrate &lt; avg_bitrate) {</span>
<span class="line-modified">11147                     guint temp = avg_bitrate;</span>
11148 
<a name="421" id="anc421"></a><span class="line-modified">11149                     avg_bitrate = max_bitrate;</span>
<span class="line-modified">11150                     max_bitrate = temp;</span>
<span class="line-modified">11151                   }</span>
11152 
<a name="422" id="anc422"></a><span class="line-modified">11153                   if (max_bitrate &gt; 0 &amp;&amp; max_bitrate &lt; G_MAXUINT32) {</span>
11154                     gst_tag_list_add (stream-&gt;stream_tags,
11155                         GST_TAG_MERGE_REPLACE, GST_TAG_MAXIMUM_BITRATE,
11156                         max_bitrate, NULL);
<a name="423" id="anc423"></a><span class="line-modified">11157                   }</span>
<span class="line-modified">11158                   if (avg_bitrate &gt; 0 &amp;&amp; avg_bitrate &lt; G_MAXUINT32) {</span>
11159                     gst_tag_list_add (stream-&gt;stream_tags,
11160                         GST_TAG_MERGE_REPLACE, GST_TAG_BITRATE, avg_bitrate,
11161                         NULL);
<a name="424" id="anc424"></a><span class="line-added">11162                   }</span>
<span class="line-added">11163 </span>
<span class="line-added">11164                   break;</span>
11165                 }
11166 
<a name="425" id="anc425"></a><span class="line-modified">11167                 default:</span>
<span class="line-added">11168                   break;</span>
11169               }
11170 
<a name="426" id="anc426"></a><span class="line-modified">11171               len -= size + 8;</span>
<span class="line-modified">11172               avc_data += size + 8;</span>
11173             }
11174 
<a name="427" id="anc427"></a><span class="line-modified">11175             break;</span>

11176           }
<a name="428" id="anc428"></a><span class="line-modified">11177           case FOURCC_H265:</span>
<span class="line-modified">11178           case FOURCC_hvc1:</span>
<span class="line-modified">11179           case FOURCC_hev1:</span>
<span class="line-modified">11180           {</span>



11181             gint len = QT_UINT32 (stsd_entry_data) - 0x56;
11182             const guint8 *hevc_data = stsd_entry_data + 0x56;
11183 
<a name="429" id="anc429"></a><span class="line-modified">11184             /* find hevc */</span>
<span class="line-modified">11185             while (len &gt;= 0x8) {</span>
<span class="line-modified">11186               gint size;</span>
11187 
<a name="430" id="anc430"></a><span class="line-modified">11188               if (QT_UINT32 (hevc_data) &lt;= len)</span>
<span class="line-modified">11189                 size = QT_UINT32 (hevc_data) - 0x8;</span>
<span class="line-modified">11190               else</span>
<span class="line-modified">11191                 size = len - 0x8;</span>
11192 
<a name="431" id="anc431"></a><span class="line-modified">11193               if (size &lt; 1)</span>
<span class="line-modified">11194                 /* No real data, so break out */</span>
<span class="line-modified">11195                 break;</span>
11196 
<a name="432" id="anc432"></a><span class="line-modified">11197               switch (QT_FOURCC (hevc_data + 0x4)) {</span>
<span class="line-modified">11198                 case FOURCC_hvcC:</span>
<span class="line-modified">11199                 {</span>
<span class="line-modified">11200                   /* parse, if found */</span>
<span class="line-modified">11201                   GstBuffer *buf;</span>
11202 
11203                   GST_DEBUG_OBJECT (qtdemux, &quot;found hvcC codec_data in stsd&quot;);
11204 
<a name="433" id="anc433"></a><span class="line-modified">11205                   /* First 4 bytes are the length of the atom, the next 4 bytes</span>
<span class="line-modified">11206                    * are the fourcc, the next 1 byte is the version, and the</span>
<span class="line-modified">11207                    * subsequent bytes are sequence parameter set like data. */</span>
<span class="line-modified">11208                   gst_codec_utils_h265_caps_set_level_tier_and_profile</span>
11209                       (entry-&gt;caps, hevc_data + 8 + 1, size - 1);
11210 
<a name="434" id="anc434"></a><span class="line-modified">11211                   buf = gst_buffer_new_and_alloc (size);</span>
<span class="line-modified">11212                   gst_buffer_fill (buf, 0, hevc_data + 0x8, size);</span>
11213                   gst_caps_set_simple (entry-&gt;caps,
<a name="435" id="anc435"></a><span class="line-modified">11214                       &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">11215                   gst_buffer_unref (buf);</span>
<span class="line-modified">11216                   break;</span>
<span class="line-added">11217                 }</span>
<span class="line-added">11218                 default:</span>
<span class="line-added">11219                   break;</span>
11220               }
<a name="436" id="anc436"></a><span class="line-modified">11221               len -= size + 8;</span>
<span class="line-modified">11222               hevc_data += size + 8;</span>
11223             }
<a name="437" id="anc437"></a><span class="line-modified">11224             break;</span>

11225           }
<a name="438" id="anc438"></a><span class="line-modified">11226           case FOURCC_mp4v:</span>
<span class="line-modified">11227           case FOURCC_MP4V:</span>
<span class="line-modified">11228           case FOURCC_fmp4:</span>
<span class="line-modified">11229           case FOURCC_FMP4:</span>


11230           case FOURCC_xvid:
11231           case FOURCC_XVID:
<a name="439" id="anc439"></a><span class="line-modified">11232           {</span>
<span class="line-modified">11233             GNode *glbl;</span>
11234 
<a name="440" id="anc440"></a><span class="line-modified">11235             GST_DEBUG_OBJECT (qtdemux, &quot;found %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">11236                 GST_FOURCC_ARGS (fourcc));</span>
11237 
<a name="441" id="anc441"></a><span class="line-modified">11238             /* codec data might be in glbl extension atom */</span>
<span class="line-modified">11239             glbl = mp4v ?</span>
<span class="line-modified">11240                 qtdemux_tree_get_child_by_type (mp4v, FOURCC_glbl) : NULL;</span>
<span class="line-modified">11241             if (glbl) {</span>
<span class="line-modified">11242               guint8 *data;</span>
<span class="line-modified">11243               GstBuffer *buf;</span>
<span class="line-modified">11244               gint len;</span>
<span class="line-modified">11245 </span>
<span class="line-modified">11246               GST_DEBUG_OBJECT (qtdemux, &quot;found glbl data in stsd&quot;);</span>
<span class="line-modified">11247               data = glbl-&gt;data;</span>
<span class="line-modified">11248               len = QT_UINT32 (data);</span>
<span class="line-modified">11249               if (len &gt; 0x8) {</span>
<span class="line-modified">11250                 len -= 0x8;</span>
<span class="line-modified">11251                 buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">11252                 gst_buffer_fill (buf, 0, data + 8, len);</span>
11253                 gst_caps_set_simple (entry-&gt;caps,
<a name="442" id="anc442"></a><span class="line-modified">11254                     &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">11255                 gst_buffer_unref (buf);</span>
<span class="line-added">11256               }</span>
11257             }
<a name="443" id="anc443"></a><span class="line-added">11258             break;</span>
11259           }
<a name="444" id="anc444"></a><span class="line-modified">11260           case FOURCC_mjp2:</span>
<span class="line-modified">11261           {</span>
<span class="line-modified">11262             /* see annex I of the jpeg2000 spec */</span>
<span class="line-modified">11263             GNode *jp2h, *ihdr, *colr, *mjp2, *field, *prefix, *cmap, *cdef;</span>
<span class="line-modified">11264             const guint8 *data;</span>
<span class="line-modified">11265             const gchar *colorspace = NULL;</span>
<span class="line-modified">11266             gint ncomp = 0;</span>
<span class="line-modified">11267             guint32 ncomp_map = 0;</span>
<span class="line-modified">11268             gint32 *comp_map = NULL;</span>
<span class="line-modified">11269             guint32 nchan_def = 0;</span>
<span class="line-modified">11270             gint32 *chan_def = NULL;</span>
<span class="line-modified">11271 </span>
<span class="line-modified">11272             GST_DEBUG_OBJECT (qtdemux, &quot;found mjp2&quot;);</span>
<span class="line-modified">11273             /* some required atoms */</span>


11274             mjp2 = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<a name="445" id="anc445"></a><span class="line-modified">11275             if (!mjp2)</span>
<span class="line-modified">11276               break;</span>
<span class="line-modified">11277             jp2h = qtdemux_tree_get_child_by_type (mjp2, FOURCC_jp2h);</span>
<span class="line-modified">11278             if (!jp2h)</span>
<span class="line-modified">11279               break;</span>
11280 
<a name="446" id="anc446"></a><span class="line-modified">11281             /* number of components; redundant with info in codestream, but useful</span>
<span class="line-modified">11282                to a muxer */</span>
<span class="line-modified">11283             ihdr = qtdemux_tree_get_child_by_type (jp2h, FOURCC_ihdr);</span>
<span class="line-modified">11284             if (!ihdr || QT_UINT32 (ihdr-&gt;data) != 22)</span>
<span class="line-modified">11285               break;</span>
<span class="line-modified">11286             ncomp = QT_UINT16 (((guint8 *) ihdr-&gt;data) + 16);</span>
11287 
<a name="447" id="anc447"></a><span class="line-modified">11288             colr = qtdemux_tree_get_child_by_type (jp2h, FOURCC_colr);</span>
<span class="line-modified">11289             if (!colr)</span>
<span class="line-modified">11290               break;</span>
<span class="line-modified">11291             GST_DEBUG_OBJECT (qtdemux, &quot;found colr&quot;);</span>
<span class="line-modified">11292             /* extract colour space info */</span>
<span class="line-modified">11293             if (QT_UINT8 ((guint8 *) colr-&gt;data + 8) == 1) {</span>
<span class="line-modified">11294               switch (QT_UINT32 ((guint8 *) colr-&gt;data + 11)) {</span>
<span class="line-modified">11295                 case 16:</span>
<span class="line-modified">11296                   colorspace = &quot;sRGB&quot;;</span>
<span class="line-modified">11297                   break;</span>
<span class="line-modified">11298                 case 17:</span>
<span class="line-modified">11299                   colorspace = &quot;GRAY&quot;;</span>
<span class="line-modified">11300                   break;</span>
<span class="line-modified">11301                 case 18:</span>
<span class="line-modified">11302                   colorspace = &quot;sYUV&quot;;</span>
<span class="line-modified">11303                   break;</span>
<span class="line-modified">11304                 default:</span>
<span class="line-modified">11305                   colorspace = NULL;</span>
<span class="line-modified">11306                   break;</span>
<span class="line-added">11307               }</span>
11308             }
<a name="448" id="anc448"></a><span class="line-modified">11309             if (!colorspace)</span>
<span class="line-modified">11310               /* colr is required, and only values 16, 17, and 18 are specified,</span>
<span class="line-modified">11311                  so error if we have no colorspace */</span>
<span class="line-modified">11312               break;</span>

11313 
<a name="449" id="anc449"></a><span class="line-modified">11314             /* extract component mapping */</span>
<span class="line-modified">11315             cmap = qtdemux_tree_get_child_by_type (jp2h, FOURCC_cmap);</span>
<span class="line-modified">11316             if (cmap) {</span>
<span class="line-modified">11317               guint32 cmap_len = 0;</span>
<span class="line-modified">11318               int i;</span>
<span class="line-modified">11319               cmap_len = QT_UINT32 (cmap-&gt;data);</span>
<span class="line-modified">11320               if (cmap_len &gt;= 8) {</span>
<span class="line-modified">11321                 /* normal box, subtract off header */</span>
<span class="line-modified">11322                 cmap_len -= 8;</span>
<span class="line-modified">11323                 /* cmap: { u16 cmp; u8 mtyp; u8 pcol; }* */</span>
<span class="line-modified">11324                 if (cmap_len % 4 == 0) {</span>
<span class="line-modified">11325                   ncomp_map = (cmap_len / 4);</span>
<span class="line-modified">11326                   comp_map = g_new0 (gint32, ncomp_map);</span>
<span class="line-modified">11327                   for (i = 0; i &lt; ncomp_map; i++) {</span>
<span class="line-modified">11328                     guint16 cmp;</span>
<span class="line-modified">11329                     guint8 mtyp, pcol;</span>
<span class="line-modified">11330                     cmp = QT_UINT16 (((guint8 *) cmap-&gt;data) + 8 + i * 4);</span>
<span class="line-modified">11331                     mtyp = QT_UINT8 (((guint8 *) cmap-&gt;data) + 8 + i * 4 + 2);</span>
<span class="line-modified">11332                     pcol = QT_UINT8 (((guint8 *) cmap-&gt;data) + 8 + i * 4 + 3);</span>
<span class="line-modified">11333                     comp_map[i] = (mtyp &lt;&lt; 24) | (pcol &lt;&lt; 16) | cmp;</span>
<span class="line-added">11334                   }</span>
11335                 }
11336               }
11337             }
<a name="450" id="anc450"></a><span class="line-modified">11338             /* extract channel definitions */</span>
<span class="line-modified">11339             cdef = qtdemux_tree_get_child_by_type (jp2h, FOURCC_cdef);</span>
<span class="line-modified">11340             if (cdef) {</span>
<span class="line-modified">11341               guint32 cdef_len = 0;</span>
<span class="line-modified">11342               int i;</span>
<span class="line-modified">11343               cdef_len = QT_UINT32 (cdef-&gt;data);</span>
<span class="line-modified">11344               if (cdef_len &gt;= 10) {</span>
<span class="line-modified">11345                 /* normal box, subtract off header and len */</span>
<span class="line-modified">11346                 cdef_len -= 10;</span>
<span class="line-modified">11347                 /* cdef: u16 n; { u16 cn; u16 typ; u16 asoc; }* */</span>
<span class="line-modified">11348                 if (cdef_len % 6 == 0) {</span>
<span class="line-modified">11349                   nchan_def = (cdef_len / 6);</span>
<span class="line-modified">11350                   chan_def = g_new0 (gint32, nchan_def);</span>
<span class="line-modified">11351                   for (i = 0; i &lt; nchan_def; i++)</span>
<span class="line-modified">11352                     chan_def[i] = -1;</span>
<span class="line-modified">11353                   for (i = 0; i &lt; nchan_def; i++) {</span>
<span class="line-modified">11354                     guint16 cn, typ, asoc;</span>
<span class="line-modified">11355                     cn = QT_UINT16 (((guint8 *) cdef-&gt;data) + 10 + i * 6);</span>
<span class="line-modified">11356                     typ = QT_UINT16 (((guint8 *) cdef-&gt;data) + 10 + i * 6 + 2);</span>
<span class="line-modified">11357                     asoc = QT_UINT16 (((guint8 *) cdef-&gt;data) + 10 + i * 6 + 4);</span>
<span class="line-modified">11358                     if (cn &lt; nchan_def) {</span>
<span class="line-modified">11359                       switch (typ) {</span>
<span class="line-modified">11360                         case 0:</span>
<span class="line-modified">11361                           chan_def[cn] = asoc;</span>
<span class="line-modified">11362                           break;</span>
<span class="line-modified">11363                         case 1:</span>

11364                           chan_def[cn] = 0;     /* alpha */
<a name="451" id="anc451"></a><span class="line-modified">11365                           break;</span>
<span class="line-modified">11366                         default:</span>
<span class="line-modified">11367                           chan_def[cn] = -typ;</span>
<span class="line-added">11368                       }</span>
11369                     }
11370                   }
11371                 }
11372               }
11373             }
<a name="452" id="anc452"></a>
11374 
11375             gst_caps_set_simple (entry-&gt;caps,
<a name="453" id="anc453"></a><span class="line-modified">11376                 &quot;num-components&quot;, G_TYPE_INT, ncomp, NULL);</span>
11377             gst_caps_set_simple (entry-&gt;caps,
<a name="454" id="anc454"></a><span class="line-modified">11378                 &quot;colorspace&quot;, G_TYPE_STRING, colorspace, NULL);</span>
<span class="line-modified">11379 </span>
<span class="line-modified">11380             if (comp_map) {</span>
<span class="line-modified">11381               GValue arr = { 0, };</span>
<span class="line-modified">11382               GValue elt = { 0, };</span>
<span class="line-modified">11383               int i;</span>
<span class="line-modified">11384               g_value_init (&amp;arr, GST_TYPE_ARRAY);</span>
<span class="line-modified">11385               g_value_init (&amp;elt, G_TYPE_INT);</span>
<span class="line-modified">11386               for (i = 0; i &lt; ncomp_map; i++) {</span>
<span class="line-modified">11387                 g_value_set_int (&amp;elt, comp_map[i]);</span>
<span class="line-modified">11388                 gst_value_array_append_value (&amp;arr, &amp;elt);</span>
<span class="line-modified">11389               }</span>
11390               gst_structure_set_value (gst_caps_get_structure (entry-&gt;caps, 0),
<a name="455" id="anc455"></a><span class="line-modified">11391                   &quot;component-map&quot;, &amp;arr);</span>
<span class="line-modified">11392               g_value_unset (&amp;elt);</span>
<span class="line-modified">11393               g_value_unset (&amp;arr);</span>
<span class="line-modified">11394               g_free (comp_map);</span>











11395             }
<a name="456" id="anc456"></a><span class="line-added">11396 </span>
<span class="line-added">11397             if (chan_def) {</span>
<span class="line-added">11398               GValue arr = { 0, };</span>
<span class="line-added">11399               GValue elt = { 0, };</span>
<span class="line-added">11400               int i;</span>
<span class="line-added">11401               g_value_init (&amp;arr, GST_TYPE_ARRAY);</span>
<span class="line-added">11402               g_value_init (&amp;elt, G_TYPE_INT);</span>
<span class="line-added">11403               for (i = 0; i &lt; nchan_def; i++) {</span>
<span class="line-added">11404                 g_value_set_int (&amp;elt, chan_def[i]);</span>
<span class="line-added">11405                 gst_value_array_append_value (&amp;arr, &amp;elt);</span>
<span class="line-added">11406               }</span>
11407               gst_structure_set_value (gst_caps_get_structure (entry-&gt;caps, 0),
<a name="457" id="anc457"></a><span class="line-modified">11408                   &quot;channel-definitions&quot;, &amp;arr);</span>
<span class="line-modified">11409               g_value_unset (&amp;elt);</span>
<span class="line-modified">11410               g_value_unset (&amp;arr);</span>
<span class="line-modified">11411               g_free (chan_def);</span>
<span class="line-modified">11412             }</span>
11413 
<a name="458" id="anc458"></a><span class="line-modified">11414             /* some optional atoms */</span>
<span class="line-modified">11415             field = qtdemux_tree_get_child_by_type (mjp2, FOURCC_fiel);</span>
<span class="line-modified">11416             prefix = qtdemux_tree_get_child_by_type (mjp2, FOURCC_jp2x);</span>
11417 
<a name="459" id="anc459"></a><span class="line-modified">11418             /* indicate possible fields in caps */</span>
<span class="line-modified">11419             if (field) {</span>
<span class="line-modified">11420               data = (guint8 *) field-&gt;data + 8;</span>
<span class="line-modified">11421               if (*data != 1)</span>
11422                 gst_caps_set_simple (entry-&gt;caps, &quot;fields&quot;, G_TYPE_INT,
<a name="460" id="anc460"></a><span class="line-modified">11423                     (gint) * data, NULL);</span>
<span class="line-modified">11424             }</span>
<span class="line-modified">11425             /* add codec_data if provided */</span>
<span class="line-modified">11426             if (prefix) {</span>
<span class="line-modified">11427               GstBuffer *buf;</span>
<span class="line-modified">11428               gint len;</span>
<span class="line-modified">11429 </span>
<span class="line-modified">11430               GST_DEBUG_OBJECT (qtdemux, &quot;found prefix data in stsd&quot;);</span>
<span class="line-modified">11431               data = prefix-&gt;data;</span>
<span class="line-modified">11432               len = QT_UINT32 (data);</span>
<span class="line-modified">11433               if (len &gt; 0x8) {</span>
<span class="line-modified">11434                 len -= 0x8;</span>
<span class="line-modified">11435                 buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">11436                 gst_buffer_fill (buf, 0, data + 8, len);</span>
11437                 gst_caps_set_simple (entry-&gt;caps,
<a name="461" id="anc461"></a><span class="line-modified">11438                     &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">11439                 gst_buffer_unref (buf);</span>
<span class="line-added">11440               }</span>
11441             }
<a name="462" id="anc462"></a><span class="line-added">11442             break;</span>
11443           }
<a name="463" id="anc463"></a><span class="line-modified">11444           case FOURCC_SVQ3:</span>
<span class="line-modified">11445           case FOURCC_VP31:</span>
<span class="line-modified">11446           {</span>
<span class="line-modified">11447             GstBuffer *buf;</span>
<span class="line-modified">11448             GstBuffer *seqh = NULL;</span>


11449             const guint8 *gamma_data = NULL;
11450             gint len = QT_UINT32 (stsd_data);   /* FIXME review - why put the whole stsd in codec data? */
11451 
11452             qtdemux_parse_svq3_stsd_data (qtdemux, stsd_entry_data, &amp;gamma_data,
11453                 &amp;seqh);
<a name="464" id="anc464"></a><span class="line-modified">11454             if (gamma_data) {</span>
11455               gst_caps_set_simple (entry-&gt;caps, &quot;applied-gamma&quot;, G_TYPE_DOUBLE,
<a name="465" id="anc465"></a><span class="line-modified">11456                   QT_FP32 (gamma_data), NULL);</span>
<span class="line-modified">11457             }</span>
<span class="line-modified">11458             if (seqh) {</span>
<span class="line-modified">11459               /* sorry for the bad name, but we don&#39;t know what this is, other</span>
<span class="line-modified">11460                * than its own fourcc */</span>
11461               gst_caps_set_simple (entry-&gt;caps, &quot;seqh&quot;, GST_TYPE_BUFFER, seqh,
<a name="466" id="anc466"></a><span class="line-modified">11462                   NULL);</span>
11463               gst_buffer_unref (seqh);
<a name="467" id="anc467"></a><span class="line-modified">11464             }</span>
11465 
<a name="468" id="anc468"></a><span class="line-modified">11466             GST_DEBUG_OBJECT (qtdemux, &quot;found codec_data in stsd&quot;);</span>
<span class="line-modified">11467             buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">11468             gst_buffer_fill (buf, 0, stsd_data, len);</span>
11469             gst_caps_set_simple (entry-&gt;caps,
<a name="469" id="anc469"></a><span class="line-modified">11470                 &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">11471             gst_buffer_unref (buf);</span>
<span class="line-modified">11472             break;</span>
<span class="line-modified">11473           }</span>
11474           case FOURCC_jpeg:
11475           {
11476             /* https://developer.apple.com/standards/qtff-2001.pdf,
11477              * page 92, &quot;Video Sample Description&quot;, under table 3.1 */
11478             GstByteReader br;
11479 
11480             const gint compressor_offset =
11481                 16 + 4 + 4 * 3 + 2 * 2 + 2 * 4 + 4 + 2;
11482             const gint min_size = compressor_offset + 32 + 2 + 2;
11483             GNode *jpeg;
11484             guint32 len;
11485             guint16 color_table_id = 0;
11486             gboolean ok;
11487 
11488             GST_DEBUG_OBJECT (qtdemux, &quot;found jpeg&quot;);
11489 
11490             /* recover information on interlaced/progressive */
11491             jpeg = qtdemux_tree_get_child_by_type (stsd, FOURCC_jpeg);
11492             if (!jpeg)
11493               break;
11494 
11495             len = QT_UINT32 (jpeg-&gt;data);
11496             GST_DEBUG_OBJECT (qtdemux, &quot;Found jpeg: len %u, need %d&quot;, len,
11497                 min_size);
11498             if (len &gt;= min_size) {
11499               gst_byte_reader_init (&amp;br, jpeg-&gt;data, len);
11500 
11501               gst_byte_reader_skip (&amp;br, compressor_offset + 32 + 2);
11502               gst_byte_reader_get_uint16_le (&amp;br, &amp;color_table_id);
11503               if (color_table_id != 0) {
11504                 /* the spec says there can be concatenated chunks in the data, and we want
11505                  * to find one called field. Walk through them. */
11506                 gint offset = min_size;
11507                 while (offset + 8 &lt; len) {
11508                   guint32 size = 0, tag;
11509                   ok = gst_byte_reader_get_uint32_le (&amp;br, &amp;size);
11510                   ok &amp;= gst_byte_reader_get_uint32_le (&amp;br, &amp;tag);
11511                   if (!ok || size &lt; 8) {
11512                     GST_WARNING_OBJECT (qtdemux,
11513                         &quot;Failed to walk optional chunk list&quot;);
11514                     break;
11515                   }
11516                   GST_DEBUG_OBJECT (qtdemux,
11517                       &quot;Found optional %4.4s chunk, size %u&quot;,
11518                       (const char *) &amp;tag, size);
11519                   if (tag == FOURCC_fiel) {
11520                     guint8 n_fields = 0, ordering = 0;
11521                     gst_byte_reader_get_uint8 (&amp;br, &amp;n_fields);
11522                     gst_byte_reader_get_uint8 (&amp;br, &amp;ordering);
11523                     if (n_fields == 1 || n_fields == 2) {
11524                       GST_DEBUG_OBJECT (qtdemux,
11525                           &quot;Found fiel tag with %u fields, ordering %u&quot;,
11526                           n_fields, ordering);
11527                       if (n_fields == 2)
11528                         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps,
11529                             &quot;interlace-mode&quot;, G_TYPE_STRING, &quot;interleaved&quot;,
11530                             NULL);
11531                     } else {
11532                       GST_WARNING_OBJECT (qtdemux,
11533                           &quot;Found fiel tag with invalid fields (%u)&quot;, n_fields);
11534                     }
11535                   }
11536                   offset += size;
11537                 }
11538               } else {
11539                 GST_DEBUG_OBJECT (qtdemux,
11540                     &quot;Color table ID is 0, not trying to get interlacedness&quot;);
11541               }
11542             } else {
11543               GST_WARNING_OBJECT (qtdemux,
11544                   &quot;Length of jpeg chunk is too small, not trying to get interlacedness&quot;);
11545             }
11546 
11547             break;
11548           }
<a name="470" id="anc470"></a><span class="line-modified">11549           case FOURCC_rle_:</span>
<span class="line-modified">11550           case FOURCC_WRLE:</span>
<span class="line-modified">11551           {</span>
11552             gst_caps_set_simple (entry-&gt;caps,
11553                 &quot;depth&quot;, G_TYPE_INT, QT_UINT16 (stsd_entry_data + offset + 66),
11554                 NULL);
<a name="471" id="anc471"></a><span class="line-modified">11555             break;</span>
<span class="line-modified">11556           }</span>
<span class="line-modified">11557           case FOURCC_XiTh:</span>
<span class="line-modified">11558           {</span>
<span class="line-modified">11559             GNode *xith, *xdxt;</span>
11560 
<a name="472" id="anc472"></a><span class="line-modified">11561             GST_DEBUG_OBJECT (qtdemux, &quot;found XiTh&quot;);</span>
11562             xith = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<a name="473" id="anc473"></a><span class="line-modified">11563             if (!xith)</span>
<span class="line-modified">11564               break;</span>
11565 
<a name="474" id="anc474"></a><span class="line-modified">11566             xdxt = qtdemux_tree_get_child_by_type (xith, FOURCC_XdxT);</span>
<span class="line-modified">11567             if (!xdxt)</span>
<span class="line-modified">11568               break;</span>
11569 
<a name="475" id="anc475"></a><span class="line-modified">11570             GST_DEBUG_OBJECT (qtdemux, &quot;found XdxT node&quot;);</span>
<span class="line-modified">11571             /* collect the headers and store them in a stream list so that we can</span>
<span class="line-modified">11572              * send them out first */</span>
<span class="line-modified">11573             qtdemux_parse_theora_extension (qtdemux, stream, xdxt);</span>
<span class="line-modified">11574             break;</span>
<span class="line-modified">11575           }</span>
<span class="line-modified">11576           case FOURCC_ovc1:</span>
<span class="line-modified">11577           {</span>
<span class="line-modified">11578             GNode *ovc1;</span>
<span class="line-modified">11579             guint8 *ovc1_data;</span>
<span class="line-modified">11580             guint ovc1_len;</span>
<span class="line-modified">11581             GstBuffer *buf;</span>
11582 
<a name="476" id="anc476"></a><span class="line-modified">11583             GST_DEBUG_OBJECT (qtdemux, &quot;parse ovc1 header&quot;);</span>
11584             ovc1 = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<a name="477" id="anc477"></a><span class="line-modified">11585             if (!ovc1)</span>
<span class="line-modified">11586               break;</span>
<span class="line-modified">11587             ovc1_data = ovc1-&gt;data;</span>
<span class="line-modified">11588             ovc1_len = QT_UINT32 (ovc1_data);</span>
<span class="line-modified">11589             if (ovc1_len &lt;= 198) {</span>
<span class="line-modified">11590               GST_WARNING_OBJECT (qtdemux, &quot;Too small ovc1 header, skipping&quot;);</span>
<span class="line-added">11591               break;</span>
<span class="line-added">11592             }</span>
<span class="line-added">11593             buf = gst_buffer_new_and_alloc (ovc1_len - 198);</span>
<span class="line-added">11594             gst_buffer_fill (buf, 0, ovc1_data + 198, ovc1_len - 198);</span>
<span class="line-added">11595             gst_caps_set_simple (entry-&gt;caps,</span>
<span class="line-added">11596                 &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-added">11597             gst_buffer_unref (buf);</span>
11598             break;
11599           }
<a name="478" id="anc478"></a>






11600           case FOURCC_vc_1:
11601           {
11602             gint len = QT_UINT32 (stsd_entry_data) - 0x56;
11603             const guint8 *vc1_data = stsd_entry_data + 0x56;
11604 
11605             /* find dvc1 */
11606             while (len &gt;= 8) {
11607               gint size;
11608 
11609               if (QT_UINT32 (vc1_data) &lt;= len)
11610                 size = QT_UINT32 (vc1_data) - 8;
11611               else
11612                 size = len - 8;
11613 
11614               if (size &lt; 1)
11615                 /* No real data, so break out */
11616                 break;
11617 
11618               switch (QT_FOURCC (vc1_data + 0x4)) {
11619                 case GST_MAKE_FOURCC (&#39;d&#39;, &#39;v&#39;, &#39;c&#39;, &#39;1&#39;):
11620                 {
11621                   GstBuffer *buf;
11622 
11623                   GST_DEBUG_OBJECT (qtdemux, &quot;found dvc1 codec_data in stsd&quot;);
11624                   buf = gst_buffer_new_and_alloc (size);
11625                   gst_buffer_fill (buf, 0, vc1_data + 8, size);
11626                   gst_caps_set_simple (entry-&gt;caps,
11627                       &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);
11628                   gst_buffer_unref (buf);
11629                   break;
11630                 }
<a name="479" id="anc479"></a><span class="line-modified">11631                 default:</span>
<span class="line-modified">11632                   break;</span>
<span class="line-modified">11633               }</span>
11634               len -= size + 8;
11635               vc1_data += size + 8;
<a name="480" id="anc480"></a><span class="line-modified">11636             }</span>
<span class="line-added">11637             break;</span>
<span class="line-added">11638           }</span>
<span class="line-added">11639           case FOURCC_av01:</span>
<span class="line-added">11640           {</span>
<span class="line-added">11641             gint len = QT_UINT32 (stsd_entry_data) - 0x56;</span>
<span class="line-added">11642             const guint8 *av1_data = stsd_entry_data + 0x56;</span>
<span class="line-added">11643 </span>
<span class="line-added">11644             /* find av1C */</span>
<span class="line-added">11645             while (len &gt;= 0x8) {</span>
<span class="line-added">11646               gint size;</span>
<span class="line-added">11647 </span>
<span class="line-added">11648               if (QT_UINT32 (av1_data) &lt;= len)</span>
<span class="line-added">11649                 size = QT_UINT32 (av1_data) - 0x8;</span>
<span class="line-added">11650               else</span>
<span class="line-added">11651                 size = len - 0x8;</span>
<span class="line-added">11652 </span>
<span class="line-added">11653               if (size &lt; 1)</span>
<span class="line-added">11654                 /* No real data, so break out */</span>
<span class="line-added">11655                 break;</span>
<span class="line-added">11656 </span>
<span class="line-added">11657               switch (QT_FOURCC (av1_data + 0x4)) {</span>
<span class="line-added">11658                 case FOURCC_av1C:</span>
<span class="line-added">11659                 {</span>
<span class="line-added">11660                   /* parse, if found */</span>
<span class="line-added">11661                   GstBuffer *buf;</span>
<span class="line-added">11662                   guint8 pres_delay_field;</span>
<span class="line-added">11663 </span>
<span class="line-added">11664                   GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-added">11665                       &quot;found av1C codec_data in stsd of size %d&quot;, size);</span>
<span class="line-added">11666 </span>
<span class="line-added">11667                   /* not enough data, just ignore and hope for the best */</span>
<span class="line-added">11668                   if (size &lt; 5)</span>
<span class="line-added">11669                     break;</span>
<span class="line-added">11670 </span>
<span class="line-added">11671                   /* Content is:</span>
<span class="line-added">11672                    * 4 bytes: atom length</span>
<span class="line-added">11673                    * 4 bytes: fourcc</span>
<span class="line-added">11674                    * 1 byte: version</span>
<span class="line-added">11675                    * 3 bytes: flags</span>
<span class="line-added">11676                    * 3 bits: reserved</span>
<span class="line-added">11677                    * 1 bits:  initial_presentation_delay_present</span>
<span class="line-added">11678                    * 4 bits: initial_presentation_delay (if present else reserved</span>
<span class="line-added">11679                    * rest: OBUs.</span>
<span class="line-added">11680                    */</span>
<span class="line-added">11681 </span>
<span class="line-added">11682                   if (av1_data[9] != 0) {</span>
<span class="line-added">11683                     GST_WARNING (&quot;Unknown version %d of av1C box&quot;, av1_data[9]);</span>
<span class="line-added">11684                     break;</span>
<span class="line-added">11685                   }</span>
<span class="line-added">11686 </span>
<span class="line-added">11687                   /* We skip initial_presentation_delay* for now */</span>
<span class="line-added">11688                   pres_delay_field = *(av1_data + 12);</span>
<span class="line-added">11689                   if (pres_delay_field &amp; (1 &lt;&lt; 5)) {</span>
<span class="line-added">11690                     gst_caps_set_simple (entry-&gt;caps,</span>
<span class="line-added">11691                         &quot;presentation-delay&quot;, G_TYPE_INT,</span>
<span class="line-added">11692                         (gint) (pres_delay_field &amp; 0x0F) + 1, NULL);</span>
<span class="line-added">11693                   }</span>
<span class="line-added">11694                   if (size &gt; 5) {</span>
<span class="line-added">11695                     buf = gst_buffer_new_and_alloc (size - 5);</span>
<span class="line-added">11696                     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_HEADER);</span>
<span class="line-added">11697                     gst_buffer_fill (buf, 0, av1_data + 13, size - 5);</span>
<span class="line-added">11698                     gst_caps_set_simple (entry-&gt;caps,</span>
<span class="line-added">11699                         &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-added">11700                     gst_buffer_unref (buf);</span>
<span class="line-added">11701                   }</span>
<span class="line-added">11702                   break;</span>
<span class="line-added">11703                 }</span>
<span class="line-added">11704                 default:</span>
<span class="line-added">11705                   break;</span>
<span class="line-added">11706               }</span>
<span class="line-added">11707 </span>
<span class="line-added">11708               len -= size + 8;</span>
<span class="line-added">11709               av1_data += size + 8;</span>
<span class="line-added">11710             }</span>
<span class="line-added">11711 </span>
11712             break;
11713           }
11714           default:
11715             break;
11716         }
11717       }
11718 
<a name="481" id="anc481"></a><span class="line-modified">11719       GST_INFO_OBJECT (qtdemux,</span>
<span class="line-modified">11720           &quot;type %&quot; GST_FOURCC_FORMAT &quot; caps %&quot; GST_PTR_FORMAT,</span>
11721           GST_FOURCC_ARGS (fourcc), entry-&gt;caps);
11722 
<a name="482" id="anc482"></a><span class="line-modified">11723     } else if (stream-&gt;subtype == FOURCC_soun) {</span>
11724       GNode *wave;
<a name="483" id="anc483"></a><span class="line-modified">11725       int version, samplesize;</span>
<span class="line-modified">11726       guint16 compression_id;</span>
<span class="line-modified">11727       gboolean amrwb = FALSE;</span>
11728 
11729       offset = 16;
<a name="484" id="anc484"></a><span class="line-modified">11730       /* sample description entry (16) + sound sample description v0 (20) */</span>
<span class="line-modified">11731       if (len &lt; 36)</span>
<span class="line-modified">11732         goto corrupt_file;</span>
11733 
11734       version = QT_UINT32 (stsd_entry_data + offset);
11735       entry-&gt;n_channels = QT_UINT16 (stsd_entry_data + offset + 8);
11736       samplesize = QT_UINT16 (stsd_entry_data + offset + 10);
11737       compression_id = QT_UINT16 (stsd_entry_data + offset + 12);
11738       entry-&gt;rate = QT_FP32 (stsd_entry_data + offset + 16);
11739 
<a name="485" id="anc485"></a><span class="line-modified">11740       GST_LOG_OBJECT (qtdemux, &quot;version/rev:      %08x&quot;, version);</span>
<span class="line-modified">11741       GST_LOG_OBJECT (qtdemux, &quot;vendor:           %08x&quot;,</span>
11742           QT_UINT32 (stsd_entry_data + offset + 4));
11743       GST_LOG_OBJECT (qtdemux, &quot;n_channels:       %d&quot;, entry-&gt;n_channels);
<a name="486" id="anc486"></a><span class="line-modified">11744       GST_LOG_OBJECT (qtdemux, &quot;sample_size:      %d&quot;, samplesize);</span>
<span class="line-modified">11745       GST_LOG_OBJECT (qtdemux, &quot;compression_id:   %d&quot;, compression_id);</span>
<span class="line-modified">11746       GST_LOG_OBJECT (qtdemux, &quot;packet size:      %d&quot;,</span>
11747           QT_UINT16 (stsd_entry_data + offset + 14));
11748       GST_LOG_OBJECT (qtdemux, &quot;sample rate:      %g&quot;, entry-&gt;rate);
11749 
<a name="487" id="anc487"></a><span class="line-modified">11750       if (compression_id == 0xfffe)</span>
11751         entry-&gt;sampled = TRUE;
11752 
<a name="488" id="anc488"></a><span class="line-modified">11753       /* first assume uncompressed audio */</span>
11754       entry-&gt;bytes_per_sample = samplesize / 8;
11755       entry-&gt;samples_per_frame = entry-&gt;n_channels;
11756       entry-&gt;bytes_per_frame = entry-&gt;n_channels * entry-&gt;bytes_per_sample;
11757       entry-&gt;samples_per_packet = entry-&gt;samples_per_frame;
11758       entry-&gt;bytes_per_packet = entry-&gt;bytes_per_sample;
11759 
11760       offset = 36;
<a name="489" id="anc489"></a><span class="line-modified">11761       switch (fourcc) {</span>
<span class="line-modified">11762           /* Yes, these have to be hard-coded */</span>
<span class="line-modified">11763         case FOURCC_MAC6:</span>
<span class="line-modified">11764         {</span>
11765           entry-&gt;samples_per_packet = 6;
11766           entry-&gt;bytes_per_packet = 1;
11767           entry-&gt;bytes_per_frame = 1 * entry-&gt;n_channels;
11768           entry-&gt;bytes_per_sample = 1;
11769           entry-&gt;samples_per_frame = 6 * entry-&gt;n_channels;
<a name="490" id="anc490"></a><span class="line-modified">11770           break;</span>
<span class="line-modified">11771         }</span>
<span class="line-modified">11772         case FOURCC_MAC3:</span>
<span class="line-modified">11773         {</span>
11774           entry-&gt;samples_per_packet = 3;
11775           entry-&gt;bytes_per_packet = 1;
11776           entry-&gt;bytes_per_frame = 1 * entry-&gt;n_channels;
11777           entry-&gt;bytes_per_sample = 1;
11778           entry-&gt;samples_per_frame = 3 * entry-&gt;n_channels;
<a name="491" id="anc491"></a><span class="line-modified">11779           break;</span>
<span class="line-modified">11780         }</span>
<span class="line-modified">11781         case FOURCC_ima4:</span>
<span class="line-modified">11782         {</span>
11783           entry-&gt;samples_per_packet = 64;
11784           entry-&gt;bytes_per_packet = 34;
11785           entry-&gt;bytes_per_frame = 34 * entry-&gt;n_channels;
11786           entry-&gt;bytes_per_sample = 2;
11787           entry-&gt;samples_per_frame = 64 * entry-&gt;n_channels;
<a name="492" id="anc492"></a><span class="line-modified">11788           break;</span>
<span class="line-modified">11789         }</span>
<span class="line-modified">11790         case FOURCC_ulaw:</span>
<span class="line-modified">11791         case FOURCC_alaw:</span>
<span class="line-modified">11792         {</span>
11793           entry-&gt;samples_per_packet = 1;
11794           entry-&gt;bytes_per_packet = 1;
11795           entry-&gt;bytes_per_frame = 1 * entry-&gt;n_channels;
11796           entry-&gt;bytes_per_sample = 1;
11797           entry-&gt;samples_per_frame = 1 * entry-&gt;n_channels;
<a name="493" id="anc493"></a><span class="line-modified">11798           break;</span>
<span class="line-modified">11799         }</span>
<span class="line-modified">11800         case FOURCC_agsm:</span>
<span class="line-modified">11801         {</span>
11802           entry-&gt;samples_per_packet = 160;
11803           entry-&gt;bytes_per_packet = 33;
11804           entry-&gt;bytes_per_frame = 33 * entry-&gt;n_channels;
11805           entry-&gt;bytes_per_sample = 2;
11806           entry-&gt;samples_per_frame = 160 * entry-&gt;n_channels;
<a name="494" id="anc494"></a><span class="line-modified">11807           break;</span>
<span class="line-added">11808         }</span>
<span class="line-added">11809         default:</span>
<span class="line-added">11810           break;</span>
11811       }
<a name="495" id="anc495"></a>


11812 
<a name="496" id="anc496"></a><span class="line-modified">11813       if (version == 0x00010000) {</span>
<span class="line-modified">11814         /* sample description entry (16) + sound sample description v1 (20+16) */</span>
<span class="line-modified">11815         if (len &lt; 52)</span>
<span class="line-modified">11816           goto corrupt_file;</span>
11817 
<a name="497" id="anc497"></a><span class="line-modified">11818         switch (fourcc) {</span>
<span class="line-modified">11819           case FOURCC_twos:</span>
<span class="line-modified">11820           case FOURCC_sowt:</span>
<span class="line-modified">11821           case FOURCC_raw_:</span>
11822           case FOURCC_lpcm:
<a name="498" id="anc498"></a><span class="line-modified">11823             break;</span>
<span class="line-modified">11824           default:</span>
<span class="line-modified">11825           {</span>
<span class="line-modified">11826             /* only parse extra decoding config for non-pcm audio */</span>
11827             entry-&gt;samples_per_packet = QT_UINT32 (stsd_entry_data + offset);
11828             entry-&gt;bytes_per_packet = QT_UINT32 (stsd_entry_data + offset + 4);
11829             entry-&gt;bytes_per_frame = QT_UINT32 (stsd_entry_data + offset + 8);
11830             entry-&gt;bytes_per_sample = QT_UINT32 (stsd_entry_data + offset + 12);
11831 
<a name="499" id="anc499"></a><span class="line-modified">11832             GST_LOG_OBJECT (qtdemux, &quot;samples/packet:   %d&quot;,</span>
11833                 entry-&gt;samples_per_packet);
<a name="500" id="anc500"></a><span class="line-modified">11834             GST_LOG_OBJECT (qtdemux, &quot;bytes/packet:     %d&quot;,</span>
11835                 entry-&gt;bytes_per_packet);
<a name="501" id="anc501"></a><span class="line-modified">11836             GST_LOG_OBJECT (qtdemux, &quot;bytes/frame:      %d&quot;,</span>
11837                 entry-&gt;bytes_per_frame);
<a name="502" id="anc502"></a><span class="line-modified">11838             GST_LOG_OBJECT (qtdemux, &quot;bytes/sample:     %d&quot;,</span>
11839                 entry-&gt;bytes_per_sample);
11840 
11841             if (!entry-&gt;sampled &amp;&amp; entry-&gt;bytes_per_packet) {
11842               entry-&gt;samples_per_frame = (entry-&gt;bytes_per_frame /
11843                   entry-&gt;bytes_per_packet) * entry-&gt;samples_per_packet;
<a name="503" id="anc503"></a><span class="line-modified">11844               GST_LOG_OBJECT (qtdemux, &quot;samples/frame:    %d&quot;,</span>
11845                   entry-&gt;samples_per_frame);
<a name="504" id="anc504"></a><span class="line-added">11846             }</span>
<span class="line-added">11847             break;</span>
11848           }
<a name="505" id="anc505"></a>
11849         }
<a name="506" id="anc506"></a><span class="line-modified">11850       } else if (version == 0x00020000) {</span>
<span class="line-modified">11851         union</span>
<span class="line-modified">11852         {</span>
<span class="line-modified">11853           gdouble fp;</span>
<span class="line-modified">11854           guint64 val;</span>
<span class="line-modified">11855         } qtfp;</span>

11856 
<a name="507" id="anc507"></a><span class="line-modified">11857         /* sample description entry (16) + sound sample description v2 (56) */</span>
<span class="line-modified">11858         if (len &lt; 72)</span>
<span class="line-modified">11859           goto corrupt_file;</span>
11860 
11861         qtfp.val = QT_UINT64 (stsd_entry_data + offset + 4);
11862         entry-&gt;rate = qtfp.fp;
11863         entry-&gt;n_channels = QT_UINT32 (stsd_entry_data + offset + 12);
11864 
<a name="508" id="anc508"></a><span class="line-modified">11865         GST_LOG_OBJECT (qtdemux, &quot;Sound sample description Version 2&quot;);</span>
11866         GST_LOG_OBJECT (qtdemux, &quot;sample rate:        %g&quot;, entry-&gt;rate);
11867         GST_LOG_OBJECT (qtdemux, &quot;n_channels:         %d&quot;, entry-&gt;n_channels);
<a name="509" id="anc509"></a><span class="line-modified">11868         GST_LOG_OBJECT (qtdemux, &quot;bits/channel:       %d&quot;,</span>
11869             QT_UINT32 (stsd_entry_data + offset + 20));
<a name="510" id="anc510"></a><span class="line-modified">11870         GST_LOG_OBJECT (qtdemux, &quot;format flags:       %X&quot;,</span>
11871             QT_UINT32 (stsd_entry_data + offset + 24));
<a name="511" id="anc511"></a><span class="line-modified">11872         GST_LOG_OBJECT (qtdemux, &quot;bytes/packet:       %d&quot;,</span>
11873             QT_UINT32 (stsd_entry_data + offset + 28));
<a name="512" id="anc512"></a><span class="line-modified">11874         GST_LOG_OBJECT (qtdemux, &quot;LPCM frames/packet: %d&quot;,</span>
11875             QT_UINT32 (stsd_entry_data + offset + 32));
<a name="513" id="anc513"></a><span class="line-modified">11876       } else if (version != 0x00000) {</span>
11877         GST_WARNING_OBJECT (qtdemux, &quot;unknown audio STSD version %08x&quot;,
11878             version);
<a name="514" id="anc514"></a><span class="line-modified">11879       }</span>
11880 
11881       if (entry-&gt;caps)
11882         gst_caps_unref (entry-&gt;caps);
11883 
11884       entry-&gt;caps = qtdemux_audio_caps (qtdemux, stream, entry, fourcc,
11885           stsd_entry_data + 32, len - 16, &amp;codec);
11886 
<a name="515" id="anc515"></a><span class="line-modified">11887       switch (fourcc) {</span>
<span class="line-modified">11888         case FOURCC_in24:</span>
<span class="line-modified">11889         {</span>
<span class="line-modified">11890           GNode *enda;</span>
<span class="line-modified">11891           GNode *in24;</span>
11892 
<a name="516" id="anc516"></a><span class="line-modified">11893           in24 = qtdemux_tree_get_child_by_type (stsd, FOURCC_in24);</span>
11894 
<a name="517" id="anc517"></a><span class="line-modified">11895           enda = qtdemux_tree_get_child_by_type (in24, FOURCC_enda);</span>
<span class="line-modified">11896           if (!enda) {</span>
<span class="line-modified">11897             wave = qtdemux_tree_get_child_by_type (in24, FOURCC_wave);</span>
<span class="line-modified">11898             if (wave)</span>
<span class="line-modified">11899               enda = qtdemux_tree_get_child_by_type (wave, FOURCC_enda);</span>
<span class="line-modified">11900           }</span>
<span class="line-modified">11901           if (enda) {</span>
<span class="line-modified">11902             int enda_value = QT_UINT16 ((guint8 *) enda-&gt;data + 8);</span>
11903             gst_caps_set_simple (entry-&gt;caps,
11904                 &quot;format&quot;, G_TYPE_STRING, (enda_value) ? &quot;S24LE&quot; : &quot;S24BE&quot;,
11905                 NULL);
<a name="518" id="anc518"></a><span class="line-added">11906           }</span>
<span class="line-added">11907           break;</span>
11908         }
<a name="519" id="anc519"></a><span class="line-modified">11909         case FOURCC_owma:</span>












11910         {
<a name="520" id="anc520"></a><span class="line-modified">11911           const guint8 *owma_data;</span>
<span class="line-modified">11912           const gchar *codec_name = NULL;</span>
<span class="line-modified">11913           guint owma_len;</span>
<span class="line-modified">11914           GstBuffer *buf;</span>
<span class="line-modified">11915           gint version = 1;</span>
<span class="line-modified">11916           /* from http://msdn.microsoft.com/en-us/library/dd757720(VS.85).aspx */</span>
<span class="line-modified">11917           /* FIXME this should also be gst_riff_strf_auds,</span>
<span class="line-modified">11918            * but the latter one is actually missing bits-per-sample :( */</span>
<span class="line-modified">11919           typedef struct</span>
<span class="line-modified">11920           {</span>
<span class="line-modified">11921             gint16 wFormatTag;</span>
<span class="line-added">11922             gint16 nChannels;</span>
<span class="line-added">11923             gint32 nSamplesPerSec;</span>
<span class="line-added">11924             gint32 nAvgBytesPerSec;</span>
<span class="line-added">11925             gint16 nBlockAlign;</span>
<span class="line-added">11926             gint16 wBitsPerSample;</span>
<span class="line-added">11927             gint16 cbSize;</span>
<span class="line-added">11928           } WAVEFORMATEX;</span>
<span class="line-added">11929           WAVEFORMATEX *wfex;</span>
<span class="line-added">11930 </span>
<span class="line-added">11931           GST_DEBUG_OBJECT (qtdemux, &quot;parse owma&quot;);</span>
11932           owma_data = stsd_entry_data;
<a name="521" id="anc521"></a><span class="line-modified">11933           owma_len = QT_UINT32 (owma_data);</span>
<span class="line-modified">11934           if (owma_len &lt;= 54) {</span>
<span class="line-modified">11935             GST_WARNING_OBJECT (qtdemux, &quot;Too small owma header, skipping&quot;);</span>
<span class="line-modified">11936             break;</span>
<span class="line-modified">11937           }</span>
<span class="line-modified">11938           wfex = (WAVEFORMATEX *) (owma_data + 36);</span>
<span class="line-modified">11939           buf = gst_buffer_new_and_alloc (owma_len - 54);</span>
<span class="line-modified">11940           gst_buffer_fill (buf, 0, owma_data + 54, owma_len - 54);</span>
<span class="line-modified">11941           if (wfex-&gt;wFormatTag == 0x0161) {</span>
<span class="line-modified">11942             codec_name = &quot;Windows Media Audio&quot;;</span>
<span class="line-modified">11943             version = 2;</span>
<span class="line-modified">11944           } else if (wfex-&gt;wFormatTag == 0x0162) {</span>
<span class="line-modified">11945             codec_name = &quot;Windows Media Audio 9 Pro&quot;;</span>
<span class="line-modified">11946             version = 3;</span>
<span class="line-modified">11947           } else if (wfex-&gt;wFormatTag == 0x0163) {</span>
<span class="line-modified">11948             codec_name = &quot;Windows Media Audio 9 Lossless&quot;;</span>
<span class="line-modified">11949             /* is that correct? gstffmpegcodecmap.c is missing it, but</span>
<span class="line-modified">11950              * fluendo codec seems to support it */</span>
<span class="line-modified">11951             version = 4;</span>
<span class="line-modified">11952           }</span>
11953 
11954           gst_caps_set_simple (entry-&gt;caps,
<a name="522" id="anc522"></a><span class="line-modified">11955               &quot;codec_data&quot;, GST_TYPE_BUFFER, buf,</span>
<span class="line-modified">11956               &quot;wmaversion&quot;, G_TYPE_INT, version,</span>
11957               &quot;block_align&quot;, G_TYPE_INT,
11958               GST_READ_UINT16_LE (&amp;wfex-&gt;nBlockAlign), &quot;bitrate&quot;, G_TYPE_INT,
11959               GST_READ_UINT32_LE (&amp;wfex-&gt;nAvgBytesPerSec), &quot;width&quot;, G_TYPE_INT,
11960               GST_READ_UINT16_LE (&amp;wfex-&gt;wBitsPerSample), &quot;depth&quot;, G_TYPE_INT,
11961               GST_READ_UINT16_LE (&amp;wfex-&gt;wBitsPerSample), NULL);
<a name="523" id="anc523"></a><span class="line-modified">11962           gst_buffer_unref (buf);</span>
11963 
<a name="524" id="anc524"></a><span class="line-modified">11964           if (codec_name) {</span>
<span class="line-modified">11965             g_free (codec);</span>
<span class="line-modified">11966             codec = g_strdup (codec_name);</span>
<span class="line-added">11967           }</span>
<span class="line-added">11968           break;</span>
11969         }
<a name="525" id="anc525"></a>

11970         case FOURCC_wma_:
11971         {
11972           gint len = QT_UINT32 (stsd_entry_data) - offset;
11973           const guint8 *wfex_data = stsd_entry_data + offset;
11974           const gchar *codec_name = NULL;
11975           gint version = 1;
11976           /* from http://msdn.microsoft.com/en-us/library/dd757720(VS.85).aspx */
11977           /* FIXME this should also be gst_riff_strf_auds,
11978            * but the latter one is actually missing bits-per-sample :( */
11979           typedef struct
11980           {
11981             gint16 wFormatTag;
11982             gint16 nChannels;
11983             gint32 nSamplesPerSec;
11984             gint32 nAvgBytesPerSec;
11985             gint16 nBlockAlign;
11986             gint16 wBitsPerSample;
11987             gint16 cbSize;
11988           } WAVEFORMATEX;
11989           WAVEFORMATEX wfex;
11990 
11991           /* FIXME: unify with similar wavformatex parsing code above */
11992           GST_DEBUG_OBJECT (qtdemux, &quot;parse wma, looking for wfex&quot;);
11993 
11994           /* find wfex */
11995           while (len &gt;= 8) {
11996             gint size;
11997 
11998             if (QT_UINT32 (wfex_data) &lt;= len)
11999               size = QT_UINT32 (wfex_data) - 8;
12000             else
12001               size = len - 8;
12002 
12003             if (size &lt; 1)
12004               /* No real data, so break out */
12005               break;
12006 
12007             switch (QT_FOURCC (wfex_data + 4)) {
12008               case GST_MAKE_FOURCC (&#39;w&#39;, &#39;f&#39;, &#39;e&#39;, &#39;x&#39;):
12009               {
12010                 GST_DEBUG_OBJECT (qtdemux, &quot;found wfex in stsd&quot;);
12011 
12012                 if (size &lt; 8 + 18)
12013                   break;
12014 
12015                 wfex.wFormatTag = GST_READ_UINT16_LE (wfex_data + 8 + 0);
12016                 wfex.nChannels = GST_READ_UINT16_LE (wfex_data + 8 + 2);
12017                 wfex.nSamplesPerSec = GST_READ_UINT32_LE (wfex_data + 8 + 4);
12018                 wfex.nAvgBytesPerSec = GST_READ_UINT32_LE (wfex_data + 8 + 8);
12019                 wfex.nBlockAlign = GST_READ_UINT16_LE (wfex_data + 8 + 12);
12020                 wfex.wBitsPerSample = GST_READ_UINT16_LE (wfex_data + 8 + 14);
12021                 wfex.cbSize = GST_READ_UINT16_LE (wfex_data + 8 + 16);
12022 
12023                 GST_LOG_OBJECT (qtdemux, &quot;Found wfex box in stsd:&quot;);
12024                 GST_LOG_OBJECT (qtdemux, &quot;FormatTag = 0x%04x, Channels = %u, &quot;
12025                     &quot;SamplesPerSec = %u, AvgBytesPerSec = %u, BlockAlign = %u, &quot;
12026                     &quot;BitsPerSample = %u, Size = %u&quot;, wfex.wFormatTag,
12027                     wfex.nChannels, wfex.nSamplesPerSec, wfex.nAvgBytesPerSec,
12028                     wfex.nBlockAlign, wfex.wBitsPerSample, wfex.cbSize);
12029 
12030                 if (wfex.wFormatTag == 0x0161) {
12031                   codec_name = &quot;Windows Media Audio&quot;;
12032                   version = 2;
12033                 } else if (wfex.wFormatTag == 0x0162) {
12034                   codec_name = &quot;Windows Media Audio 9 Pro&quot;;
12035                   version = 3;
12036                 } else if (wfex.wFormatTag == 0x0163) {
12037                   codec_name = &quot;Windows Media Audio 9 Lossless&quot;;
12038                   /* is that correct? gstffmpegcodecmap.c is missing it, but
12039                    * fluendo codec seems to support it */
12040                   version = 4;
12041                 }
12042 
12043                 gst_caps_set_simple (entry-&gt;caps,
12044                     &quot;wmaversion&quot;, G_TYPE_INT, version,
12045                     &quot;block_align&quot;, G_TYPE_INT, wfex.nBlockAlign,
12046                     &quot;bitrate&quot;, G_TYPE_INT, wfex.nAvgBytesPerSec,
12047                     &quot;width&quot;, G_TYPE_INT, wfex.wBitsPerSample,
12048                     &quot;depth&quot;, G_TYPE_INT, wfex.wBitsPerSample, NULL);
12049 
12050                 if (size &gt; wfex.cbSize) {
12051                   GstBuffer *buf;
12052 
12053                   buf = gst_buffer_new_and_alloc (size - wfex.cbSize);
12054                   gst_buffer_fill (buf, 0, wfex_data + 8 + wfex.cbSize,
12055                       size - wfex.cbSize);
12056                   gst_caps_set_simple (entry-&gt;caps,
12057                       &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);
12058                   gst_buffer_unref (buf);
12059                 } else {
12060                   GST_WARNING_OBJECT (qtdemux, &quot;no codec data&quot;);
12061                 }
12062 
12063                 if (codec_name) {
12064                   g_free (codec);
12065                   codec = g_strdup (codec_name);
12066                 }
12067                 break;
12068               }
<a name="526" id="anc526"></a><span class="line-modified">12069               default:</span>
<span class="line-modified">12070                 break;</span>
<span class="line-modified">12071             }</span>
12072             len -= size + 8;
12073             wfex_data += size + 8;
12074           }
12075           break;
12076         }
12077 #ifndef GSTREAMER_LITE
12078         case FOURCC_opus:
12079         {
12080           const guint8 *opus_data;
12081           guint8 *channel_mapping = NULL;
12082           guint32 rate;
12083           guint8 channels;
12084           guint8 channel_mapping_family;
12085           guint8 stream_count;
12086           guint8 coupled_count;
12087           guint8 i;
12088 
12089           opus_data = stsd_entry_data;
12090 
12091           channels = GST_READ_UINT8 (opus_data + 45);
12092           rate = GST_READ_UINT32_LE (opus_data + 48);
12093           channel_mapping_family = GST_READ_UINT8 (opus_data + 54);
12094           stream_count = GST_READ_UINT8 (opus_data + 55);
12095           coupled_count = GST_READ_UINT8 (opus_data + 56);
12096 
12097           if (channels &gt; 0) {
12098             channel_mapping = g_malloc (channels * sizeof (guint8));
12099             for (i = 0; i &lt; channels; i++)
12100               channel_mapping[i] = GST_READ_UINT8 (opus_data + i + 57);
12101           }
12102 
12103           entry-&gt;caps = gst_codec_utils_opus_create_caps (rate, channels,
12104               channel_mapping_family, stream_count, coupled_count,
12105               channel_mapping);
12106           break;
12107         }
12108 #endif // GSTREAMER_LITE
12109         default:
12110           break;
12111       }
12112 
<a name="527" id="anc527"></a><span class="line-modified">12113       if (codec) {</span>
<span class="line-modified">12114         GstStructure *s;</span>
<span class="line-modified">12115         gint bitrate = 0;</span>
12116 
12117         gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<a name="528" id="anc528"></a><span class="line-modified">12118             GST_TAG_AUDIO_CODEC, codec, NULL);</span>
<span class="line-modified">12119         g_free (codec);</span>
<span class="line-modified">12120         codec = NULL;</span>
12121 
<a name="529" id="anc529"></a><span class="line-modified">12122         /* some bitrate info may have ended up in caps */</span>
12123         s = gst_caps_get_structure (entry-&gt;caps, 0);
<a name="530" id="anc530"></a><span class="line-modified">12124         gst_structure_get_int (s, &quot;bitrate&quot;, &amp;bitrate);</span>
<span class="line-modified">12125         if (bitrate &gt; 0)</span>
12126           gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
12127               GST_TAG_BITRATE, bitrate, NULL);
<a name="531" id="anc531"></a><span class="line-modified">12128       }</span>
12129 
12130       mp4a = qtdemux_tree_get_child_by_index (stsd, stsd_index);
<a name="532" id="anc532"></a><span class="line-modified">12131       if (QTDEMUX_TREE_NODE_FOURCC (mp4a) != fourcc) {</span>
<span class="line-modified">12132         if (stream-&gt;protected &amp;&amp; QTDEMUX_TREE_NODE_FOURCC (mp4a) != FOURCC_enca)</span>






12133           mp4a = NULL;
<a name="533" id="anc533"></a><span class="line-modified">12134         else if (!stream-&gt;protected)</span>


12135           mp4a = NULL;
<a name="534" id="anc534"></a>
12136       }
12137 
<a name="535" id="anc535"></a><span class="line-modified">12138       wave = NULL;</span>
<span class="line-modified">12139       esds = NULL;</span>
<span class="line-modified">12140       if (mp4a) {</span>
<span class="line-modified">12141         wave = qtdemux_tree_get_child_by_type (mp4a, FOURCC_wave);</span>
<span class="line-modified">12142         if (wave)</span>
<span class="line-modified">12143           esds = qtdemux_tree_get_child_by_type (wave, FOURCC_esds);</span>
<span class="line-modified">12144         if (!esds)</span>
<span class="line-modified">12145           esds = qtdemux_tree_get_child_by_type (mp4a, FOURCC_esds);</span>
<span class="line-modified">12146       }</span>
12147 
12148 
<a name="536" id="anc536"></a><span class="line-modified">12149       /* If the fourcc&#39;s bottom 16 bits gives &#39;sm&#39;, then the top</span>
<span class="line-modified">12150          16 bits is a byte-swapped wave-style codec identifier,</span>
<span class="line-modified">12151          and we can find a WAVE header internally to a &#39;wave&#39; atom here.</span>
<span class="line-modified">12152          This can more clearly be thought of as &#39;ms&#39; as the top 16 bits, and a</span>
<span class="line-modified">12153          codec id as the bottom 16 bits - but byte-swapped to store in QT (which</span>
<span class="line-modified">12154          is big-endian).</span>
<span class="line-modified">12155        */</span>
<span class="line-modified">12156       if ((fourcc &amp; 0xffff) == ((&#39;s&#39; &lt;&lt; 8) | &#39;m&#39;)) {</span>
<span class="line-modified">12157         if (len &lt; offset + 20) {</span>
<span class="line-modified">12158           GST_WARNING_OBJECT (qtdemux, &quot;No wave atom in MS-style audio&quot;);</span>
<span class="line-modified">12159         } else {</span>
12160           guint32 datalen = QT_UINT32 (stsd_entry_data + offset + 16);
12161           const guint8 *data = stsd_entry_data + offset + 16;
<a name="537" id="anc537"></a><span class="line-modified">12162           GNode *wavenode;</span>
<span class="line-modified">12163           GNode *waveheadernode;</span>
12164 
<a name="538" id="anc538"></a><span class="line-modified">12165           wavenode = g_node_new ((guint8 *) data);</span>
<span class="line-modified">12166           if (qtdemux_parse_node (qtdemux, wavenode, data, datalen)) {</span>
<span class="line-modified">12167             const guint8 *waveheader;</span>
<span class="line-modified">12168             guint32 headerlen;</span>
12169 
<a name="539" id="anc539"></a><span class="line-modified">12170             waveheadernode = qtdemux_tree_get_child_by_type (wavenode, fourcc);</span>
<span class="line-modified">12171             if (waveheadernode) {</span>
<span class="line-modified">12172               waveheader = (const guint8 *) waveheadernode-&gt;data;</span>
<span class="line-modified">12173               headerlen = QT_UINT32 (waveheader);</span>
12174 
<a name="540" id="anc540"></a><span class="line-modified">12175               if (headerlen &gt; 8) {</span>
<span class="line-modified">12176                 gst_riff_strf_auds *header = NULL;</span>
<span class="line-modified">12177                 GstBuffer *headerbuf;</span>
<span class="line-modified">12178                 GstBuffer *extra;</span>
12179 
<a name="541" id="anc541"></a><span class="line-modified">12180                 waveheader += 8;</span>
<span class="line-modified">12181                 headerlen -= 8;</span>
12182 
<a name="542" id="anc542"></a><span class="line-modified">12183                 headerbuf = gst_buffer_new_and_alloc (headerlen);</span>
<span class="line-modified">12184                 gst_buffer_fill (headerbuf, 0, waveheader, headerlen);</span>
12185 
<a name="543" id="anc543"></a><span class="line-modified">12186                 if (gst_riff_parse_strf_auds (GST_ELEMENT_CAST (qtdemux),</span>
<span class="line-modified">12187                         headerbuf, &amp;header, &amp;extra)) {</span>
12188                   gst_caps_unref (entry-&gt;caps);
<a name="544" id="anc544"></a><span class="line-modified">12189                   /* FIXME: Need to do something with the channel reorder map */</span>
12190                   entry-&gt;caps =
12191                       gst_riff_create_audio_caps (header-&gt;format, NULL, header,
12192                       extra, NULL, NULL, NULL);
12193 
<a name="545" id="anc545"></a><span class="line-modified">12194                   if (extra)</span>
<span class="line-modified">12195                     gst_buffer_unref (extra);</span>
<span class="line-modified">12196                   g_free (header);</span>
<span class="line-added">12197                 }</span>
12198               }
<a name="546" id="anc546"></a><span class="line-modified">12199             } else</span>
<span class="line-modified">12200               GST_DEBUG (&quot;Didn&#39;t find waveheadernode for this codec&quot;);</span>
<span class="line-modified">12201           }</span>
<span class="line-added">12202           g_node_destroy (wavenode);</span>
12203         }
<a name="547" id="anc547"></a><span class="line-modified">12204       } else if (esds) {</span>


12205 #ifdef GSTREAMER_LITE
12206         if (!gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
12207                                       stream-&gt;stream_tags))
12208             goto corrupt_file;
12209 #else
12210         gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
12211             stream-&gt;stream_tags);
12212 #endif // GSTREAMER_LITE
<a name="548" id="anc548"></a><span class="line-modified">12213       } else {</span>
<span class="line-modified">12214         switch (fourcc) {</span>
12215 #if 0
<a name="549" id="anc549"></a><span class="line-modified">12216             /* FIXME: what is in the chunk? */</span>
<span class="line-modified">12217           case FOURCC_QDMC:</span>
<span class="line-modified">12218           {</span>
<span class="line-modified">12219             gint len = QT_UINT32 (stsd_data);</span>
12220 
<a name="550" id="anc550"></a><span class="line-modified">12221             /* seems to be always = 116 = 0x74 */</span>
<span class="line-modified">12222             break;</span>
<span class="line-modified">12223           }</span>
12224 #endif
<a name="551" id="anc551"></a><span class="line-modified">12225           case FOURCC_QDM2:</span>
<span class="line-modified">12226           {</span>
12227             gint len = QT_UINT32 (stsd_entry_data);
12228 
12229             if (len &gt; 0x3C) {
12230               GstBuffer *buf = gst_buffer_new_and_alloc (len - 0x3C);
12231 
12232               gst_buffer_fill (buf, 0, stsd_entry_data + 0x3C, len - 0x3C);
12233               gst_caps_set_simple (entry-&gt;caps,
<a name="552" id="anc552"></a><span class="line-modified">12234                   &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">12235               gst_buffer_unref (buf);</span>
<span class="line-modified">12236             }</span>
12237             gst_caps_set_simple (entry-&gt;caps,
<a name="553" id="anc553"></a><span class="line-modified">12238                 &quot;samplesize&quot;, G_TYPE_INT, samplesize, NULL);</span>
<span class="line-modified">12239             break;</span>















12240           }
<a name="554" id="anc554"></a><span class="line-modified">12241           case FOURCC_alac:</span>
<span class="line-modified">12242           {</span>
<span class="line-modified">12243             GNode *alac, *wave = NULL;</span>
<span class="line-modified">12244 </span>
<span class="line-added">12245             /* apparently, m4a has this atom appended directly in the stsd entry,</span>
<span class="line-added">12246              * while mov has it in a wave atom */</span>
<span class="line-added">12247             alac = qtdemux_tree_get_child_by_type (stsd, FOURCC_alac);</span>
<span class="line-added">12248             if (alac) {</span>
<span class="line-added">12249               /* alac now refers to stsd entry atom */</span>
<span class="line-added">12250               wave = qtdemux_tree_get_child_by_type (alac, FOURCC_wave);</span>
<span class="line-added">12251               if (wave)</span>
<span class="line-added">12252                 alac = qtdemux_tree_get_child_by_type (wave, FOURCC_alac);</span>
<span class="line-added">12253               else</span>
<span class="line-added">12254                 alac = qtdemux_tree_get_child_by_type (alac, FOURCC_alac);</span>
<span class="line-added">12255             }</span>
<span class="line-added">12256             if (alac) {</span>
<span class="line-added">12257               const guint8 *alac_data = alac-&gt;data;</span>
<span class="line-added">12258               gint len = QT_UINT32 (alac-&gt;data);</span>
<span class="line-added">12259               GstBuffer *buf;</span>
12260 
<a name="555" id="anc555"></a><span class="line-modified">12261               if (len &lt; 36) {</span>
<span class="line-modified">12262                 GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-modified">12263                     &quot;discarding alac atom with unexpected len %d&quot;, len);</span>
<span class="line-modified">12264               } else {</span>
<span class="line-modified">12265                 /* codec-data contains alac atom size and prefix,</span>
<span class="line-modified">12266                  * ffmpeg likes it that way, not quite gst-ish though ...*/</span>
<span class="line-modified">12267                 buf = gst_buffer_new_and_alloc (len);</span>
<span class="line-modified">12268                 gst_buffer_fill (buf, 0, alac-&gt;data, len);</span>
12269                 gst_caps_set_simple (entry-&gt;caps,
<a name="556" id="anc556"></a><span class="line-modified">12270                     &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">12271                 gst_buffer_unref (buf);</span>
12272 
12273                 entry-&gt;bytes_per_frame = QT_UINT32 (alac_data + 12);
12274                 entry-&gt;n_channels = QT_UINT8 (alac_data + 21);
12275                 entry-&gt;rate = QT_UINT32 (alac_data + 32);
<a name="557" id="anc557"></a><span class="line-added">12276               }</span>
12277             }
<a name="558" id="anc558"></a>
12278             gst_caps_set_simple (entry-&gt;caps,
<a name="559" id="anc559"></a><span class="line-modified">12279                 &quot;samplesize&quot;, G_TYPE_INT, samplesize, NULL);</span>
<span class="line-modified">12280             break;</span>
<span class="line-modified">12281           }</span>
12282           case FOURCC_fLaC:
12283           {
12284             /* The codingname of the sample entry is &#39;fLaC&#39; */
12285             GNode *flac = qtdemux_tree_get_child_by_type (stsd, FOURCC_fLaC);
12286 
12287             if (flac) {
12288               /* The &#39;dfLa&#39; box is added to the sample entry to convey
12289                  initializing information for the decoder. */
12290               const GNode *dfla =
12291                   qtdemux_tree_get_child_by_type (flac, FOURCC_dfLa);
12292 
12293               if (dfla) {
12294                 const guint32 len = QT_UINT32 (dfla-&gt;data);
12295 
12296                 /* Must contain at least dfLa box header (12),
12297                  * METADATA_BLOCK_HEADER (4), METADATA_BLOCK_STREAMINFO (34) */
12298                 if (len &lt; 50) {
12299                   GST_DEBUG_OBJECT (qtdemux,
12300                       &quot;discarding dfla atom with unexpected len %d&quot;, len);
12301                 } else {
12302                   /* skip dfLa header to get the METADATA_BLOCKs */
12303                   const guint8 *metadata_blocks = (guint8 *) dfla-&gt;data + 12;
12304                   const guint32 metadata_blocks_len = len - 12;
12305 
12306                   gchar *stream_marker = g_strdup (&quot;fLaC&quot;);
12307                   GstBuffer *block = gst_buffer_new_wrapped (stream_marker,
12308                       strlen (stream_marker));
12309 
12310                   guint32 index = 0;
12311                   guint32 remainder = 0;
12312                   guint32 block_size = 0;
12313                   gboolean is_last = FALSE;
12314 
12315                   GValue array = G_VALUE_INIT;
12316                   GValue value = G_VALUE_INIT;
12317 
12318                   g_value_init (&amp;array, GST_TYPE_ARRAY);
12319                   g_value_init (&amp;value, GST_TYPE_BUFFER);
12320 
12321                   gst_value_set_buffer (&amp;value, block);
12322                   gst_value_array_append_value (&amp;array, &amp;value);
12323                   g_value_reset (&amp;value);
12324 
12325                   gst_buffer_unref (block);
12326 
12327                   /* check there&#39;s at least one METADATA_BLOCK_HEADER&#39;s worth
12328                    * of data, and we haven&#39;t already finished parsing */
12329                   while (!is_last &amp;&amp; ((index + 3) &lt; metadata_blocks_len)) {
12330                     remainder = metadata_blocks_len - index;
12331 
12332                     /* add the METADATA_BLOCK_HEADER size to the signalled size */
12333                     block_size = 4 +
12334                         (metadata_blocks[index + 1] &lt;&lt; 16) +
12335                         (metadata_blocks[index + 2] &lt;&lt; 8) +
12336                         metadata_blocks[index + 3];
12337 
12338                     /* be careful not to read off end of box */
12339                     if (block_size &gt; remainder) {
12340                       break;
12341                     }
12342 
12343                     is_last = metadata_blocks[index] &gt;&gt; 7;
12344 
12345                     block = gst_buffer_new_and_alloc (block_size);
12346 
12347                     gst_buffer_fill (block, 0, &amp;metadata_blocks[index],
12348                         block_size);
12349 
12350                     gst_value_set_buffer (&amp;value, block);
12351                     gst_value_array_append_value (&amp;array, &amp;value);
12352                     g_value_reset (&amp;value);
12353 
12354                     gst_buffer_unref (block);
12355 
12356                     index += block_size;
12357                   }
12358 
12359                   /* only append the metadata if we successfully read all of it */
12360                   if (is_last) {
12361                     gst_structure_set_value (gst_caps_get_structure (CUR_STREAM
12362                             (stream)-&gt;caps, 0), &quot;streamheader&quot;, &amp;array);
12363                   } else {
12364                     GST_WARNING_OBJECT (qtdemux,
12365                         &quot;discarding all METADATA_BLOCKs due to invalid &quot;
12366                         &quot;block_size %d at idx %d, rem %d&quot;, block_size, index,
12367                         remainder);
12368                   }
12369 
12370                   g_value_unset (&amp;value);
12371                   g_value_unset (&amp;array);
12372 
12373                   /* The sample rate obtained from the stsd may not be accurate
12374                    * since it cannot represent rates greater than 65535Hz, so
12375                    * override that value with the sample rate from the
12376                    * METADATA_BLOCK_STREAMINFO block */
12377                   CUR_STREAM (stream)-&gt;rate =
12378                       (QT_UINT32 (metadata_blocks + 14) &gt;&gt; 12) &amp; 0xFFFFF;
12379                 }
12380               }
12381             }
12382             break;
12383           }
<a name="560" id="anc560"></a><span class="line-modified">12384           case FOURCC_sawb:</span>
<span class="line-modified">12385             /* Fallthrough! */</span>
<span class="line-modified">12386             amrwb = TRUE;</span>
<span class="line-modified">12387           case FOURCC_samr:</span>
<span class="line-modified">12388           {</span>
12389             gint len = QT_UINT32 (stsd_entry_data);
12390 
12391             if (len &gt; 0x24) {
12392               GstBuffer *buf = gst_buffer_new_and_alloc (len - 0x24);
<a name="561" id="anc561"></a><span class="line-modified">12393               guint bitrate;</span>
12394 
12395               gst_buffer_fill (buf, 0, stsd_entry_data + 0x24, len - 0x24);
12396 
<a name="562" id="anc562"></a><span class="line-modified">12397               /* If we have enough data, let&#39;s try to get the &#39;damr&#39; atom. See</span>
<span class="line-modified">12398                * the 3GPP container spec (26.244) for more details. */</span>
<span class="line-modified">12399               if ((len - 0x34) &gt; 8 &amp;&amp;</span>
<span class="line-modified">12400                   (bitrate = qtdemux_parse_amr_bitrate (buf, amrwb))) {</span>
12401                 gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<a name="563" id="anc563"></a><span class="line-modified">12402                     GST_TAG_MAXIMUM_BITRATE, bitrate, NULL);</span>
<span class="line-modified">12403               }</span>
12404 
12405               gst_caps_set_simple (entry-&gt;caps,
<a name="564" id="anc564"></a><span class="line-modified">12406                   &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);</span>
<span class="line-modified">12407               gst_buffer_unref (buf);</span>
<span class="line-added">12408             }</span>
<span class="line-added">12409             break;</span>
12410           }
<a name="565" id="anc565"></a>

12411           case FOURCC_mp4a:
12412           {
12413             /* mp4a atom withtout ESDS; Attempt to build codec data from atom */
12414             gint len = QT_UINT32 (stsd_entry_data);
12415 
12416             if (len &gt;= 34) {
12417               guint16 sound_version = QT_UINT16 (stsd_entry_data + 16);
12418 
12419               if (sound_version == 1) {
12420                 guint16 channels = QT_UINT16 (stsd_entry_data + 24);
12421                 guint32 time_scale = QT_UINT32 (stsd_entry_data + 30);
12422                 guint8 codec_data[2];
12423                 GstBuffer *buf;
12424                 gint profile = 2;       /* FIXME: Can this be determined somehow? There doesn&#39;t seem to be anything in mp4a atom that specifis compression */
12425 
12426                 gint sample_rate_index =
12427                     gst_codec_utils_aac_get_index_from_sample_rate (time_scale);
12428 
12429                 /* build AAC codec data */
12430                 codec_data[0] = profile &lt;&lt; 3;
12431                 codec_data[0] |= ((sample_rate_index &gt;&gt; 1) &amp; 0x7);
12432                 codec_data[1] = (sample_rate_index &amp; 0x01) &lt;&lt; 7;
12433                 codec_data[1] |= (channels &amp; 0xF) &lt;&lt; 3;
12434 
12435                 buf = gst_buffer_new_and_alloc (2);
12436                 gst_buffer_fill (buf, 0, codec_data, 2);
12437                 gst_caps_set_simple (entry-&gt;caps,
12438                     &quot;codec_data&quot;, GST_TYPE_BUFFER, buf, NULL);
12439                 gst_buffer_unref (buf);
12440               }
12441             }
12442             break;
12443           }
12444           case FOURCC_lpcm:
12445             /* Fully handled elsewhere */
12446             break;
<a name="566" id="anc566"></a><span class="line-modified">12447           default:</span>
<span class="line-modified">12448             GST_INFO_OBJECT (qtdemux,</span>
<span class="line-modified">12449                 &quot;unhandled type %&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));</span>
<span class="line-modified">12450             break;</span>
<span class="line-added">12451         }</span>
12452       }
<a name="567" id="anc567"></a><span class="line-modified">12453       GST_INFO_OBJECT (qtdemux,</span>
<span class="line-modified">12454           &quot;type %&quot; GST_FOURCC_FORMAT &quot; caps %&quot; GST_PTR_FORMAT,</span>

12455           GST_FOURCC_ARGS (fourcc), entry-&gt;caps);
12456 
<a name="568" id="anc568"></a><span class="line-modified">12457     } else if (stream-&gt;subtype == FOURCC_strm) {</span>
<span class="line-modified">12458       if (fourcc == FOURCC_rtsp) {</span>
<span class="line-modified">12459         stream-&gt;redirect_uri = qtdemux_get_rtsp_uri_from_hndl (qtdemux, minf);</span>
<span class="line-modified">12460       } else {</span>
<span class="line-modified">12461         GST_INFO_OBJECT (qtdemux, &quot;unhandled stream type %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">12462             GST_FOURCC_ARGS (fourcc));</span>
<span class="line-modified">12463         goto unknown_stream;</span>
<span class="line-modified">12464       }</span>
12465       entry-&gt;sampled = TRUE;
<a name="569" id="anc569"></a><span class="line-modified">12466     } else if (stream-&gt;subtype == FOURCC_subp || stream-&gt;subtype == FOURCC_text</span>
<span class="line-modified">12467         || stream-&gt;subtype == FOURCC_sbtl || stream-&gt;subtype == FOURCC_subt</span>
<span class="line-added">12468         || stream-&gt;subtype == FOURCC_clcp) {</span>
12469 
12470       entry-&gt;sampled = TRUE;
12471       entry-&gt;sparse = TRUE;
12472 
12473       entry-&gt;caps =
12474           qtdemux_sub_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,
12475           &amp;codec);
<a name="570" id="anc570"></a><span class="line-modified">12476       if (codec) {</span>
12477         gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<a name="571" id="anc571"></a><span class="line-modified">12478             GST_TAG_SUBTITLE_CODEC, codec, NULL);</span>
<span class="line-modified">12479         g_free (codec);</span>
<span class="line-modified">12480         codec = NULL;</span>
<span class="line-modified">12481       }</span>
12482 
<a name="572" id="anc572"></a><span class="line-modified">12483       /* hunt for sort-of codec data */</span>
<span class="line-modified">12484       switch (fourcc) {</span>
<span class="line-modified">12485         case FOURCC_mp4s:</span>
<span class="line-modified">12486         {</span>
<span class="line-modified">12487           GNode *mp4s = NULL;</span>
<span class="line-modified">12488           GNode *esds = NULL;</span>
<span class="line-modified">12489 </span>
<span class="line-modified">12490           /* look for palette in a stsd-&gt;mp4s-&gt;esds sub-atom */</span>
<span class="line-modified">12491           mp4s = qtdemux_tree_get_child_by_type (stsd, FOURCC_mp4s);</span>
<span class="line-modified">12492           if (mp4s)</span>
<span class="line-modified">12493             esds = qtdemux_tree_get_child_by_type (mp4s, FOURCC_esds);</span>
<span class="line-modified">12494           if (esds == NULL) {</span>
<span class="line-modified">12495             /* Invalid STSD */</span>
<span class="line-modified">12496             GST_LOG_OBJECT (qtdemux, &quot;Skipping invalid stsd: no esds child&quot;);</span>
<span class="line-modified">12497             break;</span>
12498           }
12499 
12500           gst_qtdemux_handle_esds (qtdemux, stream, entry, esds,
12501               stream-&gt;stream_tags);
<a name="573" id="anc573"></a><span class="line-modified">12502           break;</span>
<span class="line-added">12503         }</span>
<span class="line-added">12504         default:</span>
<span class="line-added">12505           GST_INFO_OBJECT (qtdemux,</span>
<span class="line-added">12506               &quot;unhandled type %&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));</span>
<span class="line-added">12507           break;</span>
12508       }
<a name="574" id="anc574"></a><span class="line-modified">12509       GST_INFO_OBJECT (qtdemux,</span>
<span class="line-modified">12510           &quot;type %&quot; GST_FOURCC_FORMAT &quot; caps %&quot; GST_PTR_FORMAT,</span>





12511           GST_FOURCC_ARGS (fourcc), entry-&gt;caps);
<a name="575" id="anc575"></a><span class="line-modified">12512     } else {</span>
<span class="line-modified">12513       /* everything in 1 sample */</span>
12514       entry-&gt;sampled = TRUE;
12515 
12516       entry-&gt;caps =
12517           qtdemux_generic_caps (qtdemux, stream, entry, fourcc, stsd_entry_data,
12518           &amp;codec);
12519 
12520       if (entry-&gt;caps == NULL)
<a name="576" id="anc576"></a><span class="line-modified">12521         goto unknown_stream;</span>
12522 
<a name="577" id="anc577"></a><span class="line-modified">12523       if (codec) {</span>
12524         gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
<a name="578" id="anc578"></a><span class="line-modified">12525             GST_TAG_SUBTITLE_CODEC, codec, NULL);</span>
<span class="line-modified">12526         g_free (codec);</span>
<span class="line-modified">12527         codec = NULL;</span>
<span class="line-modified">12528       }</span>
<span class="line-modified">12529     }</span>
12530 
<a name="579" id="anc579"></a><span class="line-modified">12531     /* promote to sampled format */</span>
12532     if (entry-&gt;fourcc == FOURCC_samr) {
<a name="580" id="anc580"></a><span class="line-modified">12533       /* force mono 8000 Hz for AMR */</span>
12534       entry-&gt;sampled = TRUE;
12535       entry-&gt;n_channels = 1;
12536       entry-&gt;rate = 8000;
12537     } else if (entry-&gt;fourcc == FOURCC_sawb) {
<a name="581" id="anc581"></a><span class="line-modified">12538       /* force mono 16000 Hz for AMR-WB */</span>
12539       entry-&gt;sampled = TRUE;
12540       entry-&gt;n_channels = 1;
12541       entry-&gt;rate = 16000;
12542     } else if (entry-&gt;fourcc == FOURCC_mp4a) {
12543       entry-&gt;sampled = TRUE;
<a name="582" id="anc582"></a><span class="line-modified">12544     }</span>
12545 
12546 
12547     stsd_entry_data += len;
12548     remaining_stsd_len -= len;
12549 
12550   }
12551 
12552   /* collect sample information */
12553   if (!qtdemux_stbl_init (qtdemux, stream, stbl))
12554     goto samples_failed;
12555 
12556   if (qtdemux-&gt;fragmented) {
12557     guint64 offset;
12558 
12559     /* need all moov samples as basis; probably not many if any at all */
12560     /* prevent moof parsing taking of at this time */
12561     offset = qtdemux-&gt;moof_offset;
12562     qtdemux-&gt;moof_offset = 0;
12563     if (stream-&gt;n_samples &amp;&amp;
12564         !qtdemux_parse_samples (qtdemux, stream, stream-&gt;n_samples - 1)) {
12565       qtdemux-&gt;moof_offset = offset;
12566       goto samples_failed;
12567     }
12568     qtdemux-&gt;moof_offset = 0;
12569     /* movie duration more reliable in this case (e.g. mehd) */
12570     if (qtdemux-&gt;segment.duration &amp;&amp;
12571         GST_CLOCK_TIME_IS_VALID (qtdemux-&gt;segment.duration))
12572       stream-&gt;duration =
12573           GSTTIME_TO_QTSTREAMTIME (stream, qtdemux-&gt;segment.duration);
12574   }
12575 
12576   /* configure segments */
12577   if (!qtdemux_parse_segments (qtdemux, stream, trak))
12578     goto segments_failed;
12579 
12580   /* add some language tag, if useful */
12581   if (stream-&gt;lang_id[0] != &#39;\0&#39; &amp;&amp; strcmp (stream-&gt;lang_id, &quot;unk&quot;) &amp;&amp;
12582       strcmp (stream-&gt;lang_id, &quot;und&quot;)) {
12583     const gchar *lang_code;
12584 
12585     /* convert ISO 639-2 code to ISO 639-1 */
12586     lang_code = gst_tag_get_language_code (stream-&gt;lang_id);
12587     gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
12588         GST_TAG_LANGUAGE_CODE, (lang_code) ? lang_code : stream-&gt;lang_id, NULL);
12589   }
12590 
12591   /* Check for UDTA tags */
12592   if ((udta = qtdemux_tree_get_child_by_type (trak, FOURCC_udta))) {
12593     qtdemux_parse_udta (qtdemux, stream-&gt;stream_tags, udta);
12594   }
12595 
<a name="583" id="anc583"></a><span class="line-modified">12596   /* Insert and sort new stream in track-id order.</span>
<span class="line-modified">12597    * This will help in comparing old/new streams during stream update check */</span>
<span class="line-modified">12598   g_ptr_array_add (qtdemux-&gt;active_streams, stream);</span>
<span class="line-modified">12599   g_ptr_array_sort (qtdemux-&gt;active_streams,</span>
<span class="line-modified">12600       (GCompareFunc) qtdemux_track_id_compare_func);</span>
<span class="line-modified">12601   GST_DEBUG_OBJECT (qtdemux, &quot;n_streams is now %d&quot;,</span>
<span class="line-modified">12602       QTDEMUX_N_STREAMS (qtdemux));</span>


12603 
12604   return TRUE;
12605 
12606 /* ERRORS */
<a name="584" id="anc584"></a>






12607 corrupt_file:
12608   {
12609     GST_ELEMENT_ERROR (qtdemux, STREAM, DEMUX,
12610         (_(&quot;This file is corrupt and cannot be played.&quot;)), (NULL));
<a name="585" id="anc585"></a><span class="line-modified">12611     if (stream)</span>
<span class="line-modified">12612       gst_qtdemux_stream_unref (stream);</span>
12613     return FALSE;
12614   }
12615 error_encrypted:
12616   {
12617     GST_ELEMENT_ERROR (qtdemux, STREAM, DECRYPT, (NULL), (NULL));
<a name="586" id="anc586"></a><span class="line-modified">12618     gst_qtdemux_stream_unref (stream);</span>

12619     return FALSE;
12620   }
12621 samples_failed:
12622 segments_failed:
12623   {
12624     /* we posted an error already */
12625     /* free stbl sub-atoms */
12626     gst_qtdemux_stbl_free (stream);
<a name="587" id="anc587"></a><span class="line-modified">12627     gst_qtdemux_stream_unref (stream);</span>

12628     return FALSE;
12629   }
12630 existing_stream:
12631   {
12632     GST_INFO_OBJECT (qtdemux, &quot;stream with track id %i already exists&quot;,
12633         track_id);
<a name="588" id="anc588"></a>

12634     return TRUE;
12635   }
12636 unknown_stream:
12637   {
12638     GST_INFO_OBJECT (qtdemux, &quot;unknown subtype %&quot; GST_FOURCC_FORMAT,
12639         GST_FOURCC_ARGS (stream-&gt;subtype));
<a name="589" id="anc589"></a><span class="line-modified">12640     gst_qtdemux_stream_unref (stream);</span>








12641     return TRUE;
12642   }
12643 }
12644 
12645 /* If we can estimate the overall bitrate, and don&#39;t have information about the
12646  * stream bitrate for exactly one stream, this guesses the stream bitrate as
12647  * the overall bitrate minus the sum of the bitrates of all other streams. This
12648  * should be useful for the common case where we have one audio and one video
12649  * stream and can estimate the bitrate of one, but not the other. */
12650 static void
12651 gst_qtdemux_guess_bitrate (GstQTDemux * qtdemux)
12652 {
12653   QtDemuxStream *stream = NULL;
12654   gint64 size, sys_bitrate, sum_bitrate = 0;
12655   GstClockTime duration;
<a name="590" id="anc590"></a>
12656   guint bitrate;
<a name="591" id="anc591"></a><span class="line-added">12657   gint i;</span>
12658 
12659   if (qtdemux-&gt;fragmented)
12660     return;
12661 
12662   GST_DEBUG_OBJECT (qtdemux, &quot;Looking for streams with unknown bitrate&quot;);
12663 
12664   if (!gst_pad_peer_query_duration (qtdemux-&gt;sinkpad, GST_FORMAT_BYTES, &amp;size)
12665       || size &lt;= 0) {
12666     GST_DEBUG_OBJECT (qtdemux,
12667         &quot;Size in bytes of the stream not known - bailing&quot;);
12668     return;
12669   }
12670 
12671   /* Subtract the header size */
12672   GST_DEBUG_OBJECT (qtdemux, &quot;Total size %&quot; G_GINT64_FORMAT &quot;, header size %u&quot;,
12673       size, qtdemux-&gt;header_size);
12674 
12675   if (size &lt; qtdemux-&gt;header_size)
12676     return;
12677 
12678   size = size - qtdemux-&gt;header_size;
12679 
12680   if (!gst_qtdemux_get_duration (qtdemux, &amp;duration)) {
12681     GST_DEBUG_OBJECT (qtdemux, &quot;Stream duration not known - bailing&quot;);
12682     return;
12683   }
12684 
<a name="592" id="anc592"></a><span class="line-modified">12685   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified">12686     QtDemuxStream *str = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added">12687     switch (str-&gt;subtype) {</span>
12688       case FOURCC_soun:
12689       case FOURCC_vide:
12690         GST_DEBUG_OBJECT (qtdemux, &quot;checking bitrate for %&quot; GST_PTR_FORMAT,
<a name="593" id="anc593"></a><span class="line-modified">12691             CUR_STREAM (str)-&gt;caps);</span>
12692         /* retrieve bitrate, prefer avg then max */
12693         bitrate = 0;
<a name="594" id="anc594"></a><span class="line-modified">12694         if (str-&gt;stream_tags) {</span>
<span class="line-modified">12695           if (gst_tag_list_get_uint (str-&gt;stream_tags,</span>
12696                   GST_TAG_MAXIMUM_BITRATE, &amp;bitrate))
<a name="595" id="anc595"></a><span class="line-modified">12697             GST_DEBUG_OBJECT (qtdemux, &quot;max-bitrate: %u&quot;, bitrate);</span>
<span class="line-modified">12698           if (gst_tag_list_get_uint (str-&gt;stream_tags,</span>
12699                   GST_TAG_NOMINAL_BITRATE, &amp;bitrate))
<a name="596" id="anc596"></a><span class="line-modified">12700             GST_DEBUG_OBJECT (qtdemux, &quot;nominal-bitrate: %u&quot;, bitrate);</span>
<span class="line-modified">12701           if (gst_tag_list_get_uint (str-&gt;stream_tags,</span>
12702                   GST_TAG_BITRATE, &amp;bitrate))
<a name="597" id="anc597"></a><span class="line-modified">12703             GST_DEBUG_OBJECT (qtdemux, &quot;bitrate: %u&quot;, bitrate);</span>
12704         }
12705         if (bitrate)
12706           sum_bitrate += bitrate;
12707         else {
12708           if (stream) {
12709             GST_DEBUG_OBJECT (qtdemux,
12710                 &quot;&gt;1 stream with unknown bitrate - bailing&quot;);
12711             return;
12712           } else
<a name="598" id="anc598"></a><span class="line-modified">12713             stream = str;</span>
12714         }
12715 
12716       default:
12717         /* For other subtypes, we assume no significant impact on bitrate */
12718         break;
12719     }
12720   }
12721 
12722   if (!stream) {
12723     GST_DEBUG_OBJECT (qtdemux, &quot;All stream bitrates are known&quot;);
12724     return;
12725   }
12726 
12727   sys_bitrate = gst_util_uint64_scale (size, GST_SECOND * 8, duration);
12728 
12729   if (sys_bitrate &lt; sum_bitrate) {
12730     /* This can happen, since sum_bitrate might be derived from maximum
12731      * bitrates and not average bitrates */
12732     GST_DEBUG_OBJECT (qtdemux,
12733         &quot;System bitrate less than sum bitrate - bailing&quot;);
12734     return;
12735   }
12736 
12737   bitrate = sys_bitrate - sum_bitrate;
12738   GST_DEBUG_OBJECT (qtdemux, &quot;System bitrate = %&quot; G_GINT64_FORMAT
12739       &quot;, Stream bitrate = %u&quot;, sys_bitrate, bitrate);
12740 
12741   if (!stream-&gt;stream_tags)
12742     stream-&gt;stream_tags = gst_tag_list_new_empty ();
12743   else
12744     stream-&gt;stream_tags = gst_tag_list_make_writable (stream-&gt;stream_tags);
12745 
12746   gst_tag_list_add (stream-&gt;stream_tags, GST_TAG_MERGE_REPLACE,
12747       GST_TAG_BITRATE, bitrate, NULL);
12748 }
12749 
12750 static GstFlowReturn
12751 qtdemux_prepare_streams (GstQTDemux * qtdemux)
12752 {
<a name="599" id="anc599"></a>
12753   GstFlowReturn ret = GST_FLOW_OK;
<a name="600" id="anc600"></a><span class="line-added">12754   gint i;</span>
12755 
12756   GST_DEBUG_OBJECT (qtdemux, &quot;prepare streams&quot;);
12757 
<a name="601" id="anc601"></a><span class="line-modified">12758   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified">12759     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
12760     guint32 sample_num = 0;
12761 
<a name="602" id="anc602"></a><span class="line-modified">12762     GST_DEBUG_OBJECT (qtdemux, &quot;track-id %u, fourcc %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">12763         stream-&gt;track_id, GST_FOURCC_ARGS (CUR_STREAM (stream)-&gt;fourcc));</span>
12764 
12765     if (qtdemux-&gt;fragmented) {
12766       /* need all moov samples first */
12767       GST_OBJECT_LOCK (qtdemux);
12768       while (stream-&gt;n_samples == 0)
12769         if ((ret = qtdemux_add_fragmented_samples (qtdemux)) != GST_FLOW_OK)
12770           break;
12771       GST_OBJECT_UNLOCK (qtdemux);
12772     } else {
12773       /* discard any stray moof */
12774       qtdemux-&gt;moof_offset = 0;
12775     }
12776 
12777     /* prepare braking */
12778     if (ret != GST_FLOW_ERROR)
12779       ret = GST_FLOW_OK;
12780 
12781     /* in pull mode, we should have parsed some sample info by now;
12782      * and quite some code will not handle no samples.
12783      * in push mode, we&#39;ll just have to deal with it */
12784     if (G_UNLIKELY (qtdemux-&gt;pullbased &amp;&amp; !stream-&gt;n_samples)) {
12785       GST_DEBUG_OBJECT (qtdemux, &quot;no samples for stream; discarding&quot;);
<a name="603" id="anc603"></a><span class="line-modified">12786       g_ptr_array_remove_index (qtdemux-&gt;active_streams, i);</span>
<span class="line-added">12787       i--;</span>
<span class="line-added">12788       continue;</span>
<span class="line-added">12789     } else if (stream-&gt;track_id == qtdemux-&gt;chapters_track_id &amp;&amp;</span>
<span class="line-added">12790         (stream-&gt;subtype == FOURCC_text || stream-&gt;subtype == FOURCC_sbtl)) {</span>
<span class="line-added">12791       /* TODO - parse chapters track and expose it as GstToc; For now just ignore it</span>
<span class="line-added">12792          so that it doesn&#39;t look like a subtitle track */</span>
<span class="line-added">12793       g_ptr_array_remove_index (qtdemux-&gt;active_streams, i);</span>
12794       i--;
12795       continue;
12796     }
12797 
12798     /* parse the initial sample for use in setting the frame rate cap */
12799     while (sample_num == 0 &amp;&amp; sample_num &lt; stream-&gt;n_samples) {
12800       if (!qtdemux_parse_samples (qtdemux, stream, sample_num))
12801         break;
12802       ++sample_num;
12803     }
<a name="604" id="anc604"></a><span class="line-modified">12804   }</span>





12805 
12806   return ret;
12807 }
12808 
<a name="605" id="anc605"></a><span class="line-added">12809 static gboolean</span>
<span class="line-added">12810 _stream_equal_func (const QtDemuxStream * stream, const gchar * stream_id)</span>
<span class="line-added">12811 {</span>
<span class="line-added">12812   return g_strcmp0 (stream-&gt;stream_id, stream_id) == 0;</span>
<span class="line-added">12813 }</span>
<span class="line-added">12814 </span>
<span class="line-added">12815 static gboolean</span>
<span class="line-added">12816 qtdemux_is_streams_update (GstQTDemux * qtdemux)</span>
<span class="line-added">12817 {</span>
<span class="line-added">12818   gint i;</span>
<span class="line-added">12819 </span>
<span class="line-added">12820   /* Different length, updated */</span>
<span class="line-added">12821   if (QTDEMUX_N_STREAMS (qtdemux) != qtdemux-&gt;old_streams-&gt;len)</span>
<span class="line-added">12822     return TRUE;</span>
<span class="line-added">12823 </span>
<span class="line-added">12824   /* streams in list are sorted in track-id order */</span>
<span class="line-added">12825   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-added">12826     /* Different stream-id, updated */</span>
<span class="line-added">12827     if (g_strcmp0 (QTDEMUX_NTH_STREAM (qtdemux, i)-&gt;stream_id,</span>
<span class="line-added">12828             QTDEMUX_NTH_OLD_STREAM (qtdemux, i)-&gt;stream_id))</span>
<span class="line-added">12829       return TRUE;</span>
<span class="line-added">12830   }</span>
<span class="line-added">12831 </span>
<span class="line-added">12832   return FALSE;</span>
<span class="line-added">12833 }</span>
<span class="line-added">12834 </span>
<span class="line-added">12835 static gboolean</span>
<span class="line-added">12836 qtdemux_reuse_and_configure_stream (GstQTDemux * qtdemux,</span>
<span class="line-added">12837     QtDemuxStream * oldstream, QtDemuxStream * newstream)</span>
<span class="line-added">12838 {</span>
<span class="line-added">12839   /* Connect old stream&#39;s srcpad to new stream */</span>
<span class="line-added">12840   newstream-&gt;pad = oldstream-&gt;pad;</span>
<span class="line-added">12841   oldstream-&gt;pad = NULL;</span>
<span class="line-added">12842 </span>
<span class="line-added">12843   /* unset new_stream to prevent stream-start event */</span>
<span class="line-added">12844   newstream-&gt;new_stream = FALSE;</span>
<span class="line-added">12845 </span>
<span class="line-added">12846   return gst_qtdemux_configure_stream (qtdemux, newstream);</span>
<span class="line-added">12847 }</span>
<span class="line-added">12848 </span>
<span class="line-added">12849 /* g_ptr_array_find_with_equal_func is available since 2.54,</span>
<span class="line-added">12850  * replacement until we can depend unconditionally on the real one in GLib */</span>
<span class="line-added">12851 #if !GLIB_CHECK_VERSION(2,54,0)</span>
<span class="line-added">12852 #define g_ptr_array_find_with_equal_func qtdemux_ptr_array_find_with_equal_func</span>
<span class="line-added">12853 static gboolean</span>
<span class="line-added">12854 qtdemux_ptr_array_find_with_equal_func (GPtrArray * haystack,</span>
<span class="line-added">12855     gconstpointer needle, GEqualFunc equal_func, guint * index_)</span>
<span class="line-added">12856 {</span>
<span class="line-added">12857   guint i;</span>
<span class="line-added">12858 </span>
<span class="line-added">12859   g_return_val_if_fail (haystack != NULL, FALSE);</span>
<span class="line-added">12860 </span>
<span class="line-added">12861   if (equal_func == NULL)</span>
<span class="line-added">12862     equal_func = g_direct_equal;</span>
<span class="line-added">12863 </span>
<span class="line-added">12864   for (i = 0; i &lt; haystack-&gt;len; i++) {</span>
<span class="line-added">12865     if (equal_func (g_ptr_array_index (haystack, i), needle)) {</span>
<span class="line-added">12866       if (index_ != NULL)</span>
<span class="line-added">12867         *index_ = i;</span>
<span class="line-added">12868       return TRUE;</span>
<span class="line-added">12869     }</span>
<span class="line-added">12870   }</span>
<span class="line-added">12871 </span>
<span class="line-added">12872   return FALSE;</span>
<span class="line-added">12873 }</span>
<span class="line-added">12874 #endif</span>
<span class="line-added">12875 </span>
<span class="line-added">12876 static gboolean</span>
<span class="line-added">12877 qtdemux_update_streams (GstQTDemux * qtdemux)</span>
<span class="line-added">12878 {</span>
<span class="line-added">12879   gint i;</span>
<span class="line-added">12880   g_assert (qtdemux-&gt;streams_aware);</span>
<span class="line-added">12881 </span>
<span class="line-added">12882   /* At below, figure out which stream in active_streams has identical stream-id</span>
<span class="line-added">12883    * with that of in old_streams. If there is matching stream-id,</span>
<span class="line-added">12884    * corresponding newstream will not be exposed again,</span>
<span class="line-added">12885    * but demux will reuse srcpad of matched old stream</span>
<span class="line-added">12886    *</span>
<span class="line-added">12887    * active_streams : newly created streams from the latest moov</span>
<span class="line-added">12888    * old_streams : existing streams (belong to previous moov)</span>
<span class="line-added">12889    */</span>
<span class="line-added">12890 </span>
<span class="line-added">12891   for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-added">12892     QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added">12893     QtDemuxStream *oldstream = NULL;</span>
<span class="line-added">12894     guint target;</span>
<span class="line-added">12895 </span>
<span class="line-added">12896     GST_DEBUG_OBJECT (qtdemux, &quot;track-id %u, fourcc %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-added">12897         stream-&gt;track_id, GST_FOURCC_ARGS (CUR_STREAM (stream)-&gt;fourcc));</span>
<span class="line-added">12898 </span>
<span class="line-added">12899     if (g_ptr_array_find_with_equal_func (qtdemux-&gt;old_streams,</span>
<span class="line-added">12900             stream-&gt;stream_id, (GEqualFunc) _stream_equal_func, &amp;target)) {</span>
<span class="line-added">12901       oldstream = QTDEMUX_NTH_OLD_STREAM (qtdemux, target);</span>
<span class="line-added">12902 </span>
<span class="line-added">12903       /* null pad stream cannot be reused */</span>
<span class="line-added">12904       if (oldstream-&gt;pad == NULL)</span>
<span class="line-added">12905         oldstream = NULL;</span>
<span class="line-added">12906     }</span>
<span class="line-added">12907 </span>
<span class="line-added">12908     if (oldstream) {</span>
<span class="line-added">12909       GST_DEBUG_OBJECT (qtdemux, &quot;Reuse track-id %d&quot;, oldstream-&gt;track_id);</span>
<span class="line-added">12910 </span>
<span class="line-added">12911       if (!qtdemux_reuse_and_configure_stream (qtdemux, oldstream, stream))</span>
<span class="line-added">12912         return FALSE;</span>
<span class="line-added">12913 </span>
<span class="line-added">12914       /* we don&#39;t need to preserve order of old streams */</span>
<span class="line-added">12915       g_ptr_array_remove_fast (qtdemux-&gt;old_streams, oldstream);</span>
<span class="line-added">12916     } else {</span>
<span class="line-added">12917       GstTagList *list;</span>
<span class="line-added">12918 </span>
<span class="line-added">12919       /* now we have all info and can expose */</span>
<span class="line-added">12920       list = stream-&gt;stream_tags;</span>
<span class="line-added">12921       stream-&gt;stream_tags = NULL;</span>
<span class="line-added">12922       if (!gst_qtdemux_add_stream (qtdemux, stream, list))</span>
<span class="line-added">12923         return FALSE;</span>
<span class="line-added">12924     }</span>
<span class="line-added">12925   }</span>
<span class="line-added">12926 </span>
<span class="line-added">12927   return TRUE;</span>
<span class="line-added">12928 }</span>
<span class="line-added">12929 </span>
<span class="line-added">12930 /* Must be called with expose lock */</span>
12931 static GstFlowReturn
12932 qtdemux_expose_streams (GstQTDemux * qtdemux)
12933 {
12934   gint i;
<a name="606" id="anc606"></a>

12935 
12936   GST_DEBUG_OBJECT (qtdemux, &quot;exposing streams&quot;);
12937 
<a name="607" id="anc607"></a><span class="line-modified">12938   if (!qtdemux_is_streams_update (qtdemux)) {</span>
<span class="line-modified">12939     GST_DEBUG_OBJECT (qtdemux, &quot;Reuse all streams&quot;);</span>
<span class="line-modified">12940     for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-modified">12941       QtDemuxStream *new_stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added">12942       QtDemuxStream *old_stream = QTDEMUX_NTH_OLD_STREAM (qtdemux, i);</span>
<span class="line-added">12943       if (!qtdemux_reuse_and_configure_stream (qtdemux, old_stream, new_stream))</span>
<span class="line-added">12944         return GST_FLOW_ERROR;</span>
<span class="line-added">12945     }</span>
12946 
<a name="608" id="anc608"></a><span class="line-modified">12947     g_ptr_array_set_size (qtdemux-&gt;old_streams, 0);</span>
<span class="line-modified">12948     qtdemux-&gt;need_segment = TRUE;</span>
12949 
<a name="609" id="anc609"></a><span class="line-modified">12950     return GST_FLOW_OK;</span>
<span class="line-modified">12951   }</span>






12952 
<a name="610" id="anc610"></a><span class="line-modified">12953   if (qtdemux-&gt;streams_aware) {</span>
<span class="line-modified">12954     if (!qtdemux_update_streams (qtdemux))</span>




12955       return GST_FLOW_ERROR;
<a name="611" id="anc611"></a><span class="line-added">12956   } else {</span>
<span class="line-added">12957     for (i = 0; i &lt; QTDEMUX_N_STREAMS (qtdemux); i++) {</span>
<span class="line-added">12958       QtDemuxStream *stream = QTDEMUX_NTH_STREAM (qtdemux, i);</span>
<span class="line-added">12959       GstTagList *list;</span>
<span class="line-added">12960 </span>
<span class="line-added">12961       /* now we have all info and can expose */</span>
<span class="line-added">12962       list = stream-&gt;stream_tags;</span>
<span class="line-added">12963       stream-&gt;stream_tags = NULL;</span>
<span class="line-added">12964       if (!gst_qtdemux_add_stream (qtdemux, stream, list))</span>
<span class="line-added">12965         return GST_FLOW_ERROR;</span>
<span class="line-added">12966 </span>
<span class="line-added">12967     }</span>
12968   }
12969 
12970   gst_qtdemux_guess_bitrate (qtdemux);
12971 
12972   gst_element_no_more_pads (GST_ELEMENT_CAST (qtdemux));
12973 
<a name="612" id="anc612"></a><span class="line-modified">12974   /* If we have still old_streams, it&#39;s no more used stream */</span>
<span class="line-modified">12975   for (i = 0; i &lt; qtdemux-&gt;old_streams-&gt;len; i++) {</span>
<span class="line-modified">12976     QtDemuxStream *stream = QTDEMUX_NTH_OLD_STREAM (qtdemux, i);</span>
12977 
<a name="613" id="anc613"></a><span class="line-modified">12978     if (stream-&gt;pad) {</span>
<span class="line-modified">12979       GstEvent *event;</span>
<span class="line-modified">12980 </span>
<span class="line-added">12981       event = gst_event_new_eos ();</span>
<span class="line-added">12982       if (qtdemux-&gt;segment_seqnum)</span>
<span class="line-added">12983         gst_event_set_seqnum (event, qtdemux-&gt;segment_seqnum);</span>
12984 
<a name="614" id="anc614"></a><span class="line-modified">12985       gst_pad_push_event (stream-&gt;pad, event);</span>
<span class="line-modified">12986     }</span>



12987   }
12988 
<a name="615" id="anc615"></a><span class="line-added">12989   g_ptr_array_set_size (qtdemux-&gt;old_streams, 0);</span>
<span class="line-added">12990 </span>
12991   /* check if we should post a redirect in case there is a single trak
12992    * and it is a redirecting trak */
<a name="616" id="anc616"></a><span class="line-modified">12993   if (QTDEMUX_N_STREAMS (qtdemux) == 1 &amp;&amp;</span>
<span class="line-added">12994       QTDEMUX_NTH_STREAM (qtdemux, 0)-&gt;redirect_uri != NULL) {</span>
12995     GstMessage *m;
12996 
12997     GST_INFO_OBJECT (qtdemux, &quot;Issuing a redirect due to a single track with &quot;
12998         &quot;an external content&quot;);
12999     m = gst_message_new_element (GST_OBJECT_CAST (qtdemux),
13000         gst_structure_new (&quot;redirect&quot;,
<a name="617" id="anc617"></a><span class="line-modified">13001             &quot;new-location&quot;, G_TYPE_STRING,</span>
<span class="line-modified">13002             QTDEMUX_NTH_STREAM (qtdemux, 0)-&gt;redirect_uri, NULL));</span>
13003     gst_element_post_message (GST_ELEMENT_CAST (qtdemux), m);
13004     qtdemux-&gt;posted_redirect = TRUE;
13005   }
13006 
<a name="618" id="anc618"></a><span class="line-modified">13007   g_ptr_array_foreach (qtdemux-&gt;active_streams,</span>
<span class="line-modified">13008       (GFunc) qtdemux_do_allocation, qtdemux);</span>
13009 
<a name="619" id="anc619"></a><span class="line-modified">13010   qtdemux-&gt;need_segment = TRUE;</span>

13011 
13012   qtdemux-&gt;exposed = TRUE;
13013   return GST_FLOW_OK;
13014 }
13015 
13016 /* check if major or compatible brand is 3GP */
13017 static inline gboolean
13018 qtdemux_is_brand_3gp (GstQTDemux * qtdemux, gboolean major)
13019 {
13020   if (major) {
13021     return ((qtdemux-&gt;major_brand &amp; GST_MAKE_FOURCC (255, 255, 0, 0)) ==
13022         FOURCC_3g__);
13023   } else if (qtdemux-&gt;comp_brands != NULL) {
13024     GstMapInfo map;
13025     guint8 *data;
13026     gsize size;
13027     gboolean res = FALSE;
13028 
13029     gst_buffer_map (qtdemux-&gt;comp_brands, &amp;map, GST_MAP_READ);
13030     data = map.data;
13031     size = map.size;
13032     while (size &gt;= 4) {
13033       res = res || ((QT_FOURCC (data) &amp; GST_MAKE_FOURCC (255, 255, 0, 0)) ==
13034           FOURCC_3g__);
13035       data += 4;
13036       size -= 4;
13037     }
13038     gst_buffer_unmap (qtdemux-&gt;comp_brands, &amp;map);
13039     return res;
13040   } else {
13041     return FALSE;
13042   }
13043 }
13044 
13045 /* check if tag is a spec&#39;ed 3GP tag keyword storing a string */
13046 static inline gboolean
13047 qtdemux_is_string_tag_3gp (GstQTDemux * qtdemux, guint32 fourcc)
13048 {
13049   return fourcc == FOURCC_cprt || fourcc == FOURCC_gnre || fourcc == FOURCC_titl
13050       || fourcc == FOURCC_dscp || fourcc == FOURCC_perf || fourcc == FOURCC_auth
13051       || fourcc == FOURCC_albm;
13052 }
13053 
13054 static void
13055 qtdemux_tag_add_location (GstQTDemux * qtdemux, GstTagList * taglist,
13056     const char *tag, const char *dummy, GNode * node)
13057 {
13058   const gchar *env_vars[] = { &quot;GST_QT_TAG_ENCODING&quot;, &quot;GST_TAG_ENCODING&quot;, NULL };
13059   int offset;
13060   char *name;
13061   gchar *data;
13062   gdouble longitude, latitude, altitude;
13063   gint len;
13064 
13065   len = QT_UINT32 (node-&gt;data);
13066   if (len &lt;= 14)
13067     goto short_read;
13068 
13069   data = node-&gt;data;
13070   offset = 14;
13071 
13072   /* TODO: language code skipped */
13073 
13074   name = gst_tag_freeform_string_to_utf8 (data + offset, -1, env_vars);
13075 
13076   if (!name) {
13077     /* do not alarm in trivial case, but bail out otherwise */
13078     if (*(data + offset) != 0) {
13079       GST_DEBUG_OBJECT (qtdemux, &quot;failed to convert %s tag to UTF-8, &quot;
13080           &quot;giving up&quot;, tag);
13081     }
13082   } else {
13083     gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE,
13084         GST_TAG_GEO_LOCATION_NAME, name, NULL);
13085     offset += strlen (name);
13086     g_free (name);
13087   }
13088 
13089   if (len &lt; offset + 2 + 4 + 4 + 4)
13090     goto short_read;
13091 
13092   /* +1 +1 = skip null-terminator and location role byte */
13093   offset += 1 + 1;
13094   /* table in spec says unsigned, semantics say negative has meaning ... */
13095   longitude = QT_SFP32 (data + offset);
13096 
13097   offset += 4;
13098   latitude = QT_SFP32 (data + offset);
13099 
13100   offset += 4;
13101   altitude = QT_SFP32 (data + offset);
13102 
13103   /* one invalid means all are invalid */
13104   if (longitude &gt;= -180.0 &amp;&amp; longitude &lt;= 180.0 &amp;&amp;
13105       latitude &gt;= -90.0 &amp;&amp; latitude &lt;= 90.0) {
13106     gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE,
13107         GST_TAG_GEO_LOCATION_LATITUDE, latitude,
13108         GST_TAG_GEO_LOCATION_LONGITUDE, longitude,
13109         GST_TAG_GEO_LOCATION_ELEVATION, altitude, NULL);
13110   }
13111 
13112   /* TODO: no GST_TAG_, so astronomical body and additional notes skipped */
13113 
13114   return;
13115 
13116   /* ERRORS */
13117 short_read:
13118   {
13119     GST_DEBUG_OBJECT (qtdemux, &quot;short read parsing 3GP location&quot;);
13120     return;
13121   }
13122 }
13123 
13124 
13125 static void
13126 qtdemux_tag_add_year (GstQTDemux * qtdemux, GstTagList * taglist,
13127     const char *tag, const char *dummy, GNode * node)
13128 {
13129   guint16 y;
13130   GDate *date;
13131   gint len;
13132 
13133   len = QT_UINT32 (node-&gt;data);
13134   if (len &lt; 14)
13135     return;
13136 
13137   y = QT_UINT16 ((guint8 *) node-&gt;data + 12);
13138   if (y == 0) {
13139     GST_DEBUG_OBJECT (qtdemux, &quot;year: %u is not a valid year&quot;, y);
13140     return;
13141   }
13142   GST_DEBUG_OBJECT (qtdemux, &quot;year: %u&quot;, y);
13143 
13144   date = g_date_new_dmy (1, 1, y);
13145   gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, date, NULL);
13146   g_date_free (date);
13147 }
13148 
13149 static void
13150 qtdemux_tag_add_classification (GstQTDemux * qtdemux, GstTagList * taglist,
13151     const char *tag, const char *dummy, GNode * node)
13152 {
13153   int offset;
13154   char *tag_str = NULL;
13155   guint8 *entity;
13156   guint16 table;
13157   gint len;
13158 
13159   len = QT_UINT32 (node-&gt;data);
13160   if (len &lt;= 20)
13161     goto short_read;
13162 
13163   offset = 12;
13164   entity = (guint8 *) node-&gt;data + offset;
13165   if (entity[0] == 0 || entity[1] == 0 || entity[2] == 0 || entity[3] == 0) {
13166     GST_DEBUG_OBJECT (qtdemux,
13167         &quot;classification info: %c%c%c%c invalid classification entity&quot;,
13168         entity[0], entity[1], entity[2], entity[3]);
13169     return;
13170   }
13171 
13172   offset += 4;
13173   table = QT_UINT16 ((guint8 *) node-&gt;data + offset);
13174 
13175   /* Language code skipped */
13176 
13177   offset += 4;
13178 
13179   /* Tag format: &quot;XXXX://Y[YYYY]/classification info string&quot;
13180    * XXXX: classification entity, fixed length 4 chars.
13181    * Y[YYYY]: classification table, max 5 chars.
13182    */
13183   tag_str = g_strdup_printf (&quot;----://%u/%s&quot;,
13184       table, (char *) node-&gt;data + offset);
13185 
13186   /* memcpy To be sure we&#39;re preserving byte order */
13187   memcpy (tag_str, entity, 4);
13188   GST_DEBUG_OBJECT (qtdemux, &quot;classification info: %s&quot;, tag_str);
13189 
13190   gst_tag_list_add (taglist, GST_TAG_MERGE_APPEND, tag, tag_str, NULL);
13191 
13192   g_free (tag_str);
13193 
13194   return;
13195 
13196   /* ERRORS */
13197 short_read:
13198   {
13199     GST_DEBUG_OBJECT (qtdemux, &quot;short read parsing 3GP classification&quot;);
13200     return;
13201   }
13202 }
13203 
13204 static gboolean
13205 qtdemux_tag_add_str_full (GstQTDemux * qtdemux, GstTagList * taglist,
13206     const char *tag, const char *dummy, GNode * node)
13207 {
13208   const gchar *env_vars[] = { &quot;GST_QT_TAG_ENCODING&quot;, &quot;GST_TAG_ENCODING&quot;, NULL };
13209   GNode *data;
13210   char *s;
13211   int len;
13212   guint32 type;
13213   int offset;
13214   gboolean ret = TRUE;
13215   const gchar *charset = NULL;
13216 
13217   data = qtdemux_tree_get_child_by_type (node, FOURCC_data);
13218   if (data) {
13219     len = QT_UINT32 (data-&gt;data);
13220     type = QT_UINT32 ((guint8 *) data-&gt;data + 8);
13221     if (type == 0x00000001 &amp;&amp; len &gt; 16) {
13222       s = gst_tag_freeform_string_to_utf8 ((char *) data-&gt;data + 16, len - 16,
13223           env_vars);
13224       if (s) {
13225         GST_DEBUG_OBJECT (qtdemux, &quot;adding tag %s&quot;, GST_STR_NULL (s));
13226         gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, s, NULL);
13227         g_free (s);
13228       } else {
13229         GST_DEBUG_OBJECT (qtdemux, &quot;failed to convert %s tag to UTF-8&quot;, tag);
13230       }
13231     }
13232   } else {
13233     len = QT_UINT32 (node-&gt;data);
13234     type = QT_UINT32 ((guint8 *) node-&gt;data + 4);
13235     if ((type &gt;&gt; 24) == 0xa9 &amp;&amp; len &gt; 8 + 4) {
13236       gint str_len;
13237       gint lang_code;
13238 
13239       /* Type starts with the (C) symbol, so the next data is a list
13240        * of (string size(16), language code(16), string) */
13241 
13242       str_len = QT_UINT16 ((guint8 *) node-&gt;data + 8);
13243       lang_code = QT_UINT16 ((guint8 *) node-&gt;data + 10);
13244 
13245       /* the string + fourcc + size + 2 16bit fields,
13246        * means that there are more tags in this atom */
13247       if (len &gt; str_len + 8 + 4) {
13248         /* TODO how to represent the same tag in different languages? */
13249         GST_WARNING_OBJECT (qtdemux, &quot;Ignoring metadata entry with multiple &quot;
13250             &quot;text alternatives, reading only first one&quot;);
13251       }
13252 
13253       offset = 12;
13254       len = MIN (len, str_len + 8 + 4); /* remove trailing strings that we don&#39;t use */
13255       GST_DEBUG_OBJECT (qtdemux, &quot;found international text tag&quot;);
13256 
13257       if (lang_code &lt; 0x800) {  /* MAC encoded string */
13258         charset = &quot;mac&quot;;
13259       }
13260     } else if (len &gt; 14 &amp;&amp; qtdemux_is_string_tag_3gp (qtdemux,
13261             QT_FOURCC ((guint8 *) node-&gt;data + 4))) {
13262       guint32 type = QT_UINT32 ((guint8 *) node-&gt;data + 8);
13263 
13264       /* we go for 3GP style encoding if major brands claims so,
13265        * or if no hope for data be ok UTF-8, and compatible 3GP brand present */
13266       if (qtdemux_is_brand_3gp (qtdemux, TRUE) ||
13267           (qtdemux_is_brand_3gp (qtdemux, FALSE) &amp;&amp;
13268               ((type &amp; 0x00FFFFFF) == 0x0) &amp;&amp; (type &gt;&gt; 24 &lt;= 0xF))) {
13269         offset = 14;
13270         /* 16-bit Language code is ignored here as well */
13271         GST_DEBUG_OBJECT (qtdemux, &quot;found 3gpp text tag&quot;);
13272       } else {
13273         goto normal;
13274       }
13275     } else {
13276     normal:
13277       offset = 8;
13278       GST_DEBUG_OBJECT (qtdemux, &quot;found normal text tag&quot;);
13279       ret = FALSE;              /* may have to fallback */
13280     }
13281     if (charset) {
13282       GError *err = NULL;
13283 
13284       s = g_convert ((gchar *) node-&gt;data + offset, len - offset, &quot;utf8&quot;,
13285           charset, NULL, NULL, &amp;err);
13286       if (err) {
13287         GST_DEBUG_OBJECT (qtdemux, &quot;Failed to convert string from charset %s:&quot;
13288             &quot; %s(%d): %s&quot;, charset, g_quark_to_string (err-&gt;domain), err-&gt;code,
13289             err-&gt;message);
13290         g_error_free (err);
13291       }
13292     } else {
<a name="620" id="anc620"></a><span class="line-modified">13293       s = gst_tag_freeform_string_to_utf8 ((char *) node-&gt;data + offset,</span>
<span class="line-modified">13294           len - offset, env_vars);</span>
13295     }
13296     if (s) {
13297       GST_DEBUG_OBJECT (qtdemux, &quot;adding tag %s&quot;, GST_STR_NULL (s));
13298       gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, s, NULL);
13299       g_free (s);
13300       ret = TRUE;
13301     } else {
13302       GST_DEBUG_OBJECT (qtdemux, &quot;failed to convert %s tag to UTF-8&quot;, tag);
13303     }
13304   }
13305   return ret;
13306 }
13307 
13308 static void
13309 qtdemux_tag_add_str (GstQTDemux * qtdemux, GstTagList * taglist,
13310     const char *tag, const char *dummy, GNode * node)
13311 {
13312   qtdemux_tag_add_str_full (qtdemux, taglist, tag, dummy, node);
13313 }
13314 
13315 static void
13316 qtdemux_tag_add_keywords (GstQTDemux * qtdemux, GstTagList * taglist,
13317     const char *tag, const char *dummy, GNode * node)
13318 {
13319   const gchar *env_vars[] = { &quot;GST_QT_TAG_ENCODING&quot;, &quot;GST_TAG_ENCODING&quot;, NULL };
13320   guint8 *data;
13321   char *s, *t, *k = NULL;
13322   int len;
13323   int offset;
13324   int count;
13325 
13326   /* first try normal string tag if major brand not 3GP */
13327   if (!qtdemux_is_brand_3gp (qtdemux, TRUE)) {
13328     if (!qtdemux_tag_add_str_full (qtdemux, taglist, tag, dummy, node)) {
13329       /* hm, that did not work, maybe 3gpp storage in non-3gpp major brand;
13330        * let&#39;s try it 3gpp way after minor safety check */
13331       data = node-&gt;data;
13332       if (QT_UINT32 (data) &lt; 15 || !qtdemux_is_brand_3gp (qtdemux, FALSE))
13333         return;
13334     } else
13335       return;
13336   }
13337 
13338   GST_DEBUG_OBJECT (qtdemux, &quot;found 3gpp keyword tag&quot;);
13339 
13340   data = node-&gt;data;
13341 
13342   len = QT_UINT32 (data);
13343   if (len &lt; 15)
13344     goto short_read;
13345 
13346   count = QT_UINT8 (data + 14);
13347   offset = 15;
13348   for (; count; count--) {
13349     gint slen;
13350 
13351     if (offset + 1 &gt; len)
13352       goto short_read;
13353     slen = QT_UINT8 (data + offset);
13354     offset += 1;
13355     if (offset + slen &gt; len)
13356       goto short_read;
13357     s = gst_tag_freeform_string_to_utf8 ((char *) node-&gt;data + offset,
13358         slen, env_vars);
13359     if (s) {
13360       GST_DEBUG_OBJECT (qtdemux, &quot;adding keyword %s&quot;, GST_STR_NULL (s));
13361       if (k) {
13362         t = g_strjoin (&quot;,&quot;, k, s, NULL);
13363         g_free (s);
13364         g_free (k);
13365         k = t;
13366       } else {
13367         k = s;
13368       }
13369     } else {
13370       GST_DEBUG_OBJECT (qtdemux, &quot;failed to convert keyword to UTF-8&quot;);
13371     }
13372     offset += slen;
13373   }
13374 
13375 done:
13376   if (k) {
13377     GST_DEBUG_OBJECT (qtdemux, &quot;adding tag %s&quot;, GST_STR_NULL (k));
13378     gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, k, NULL);
13379   }
13380   g_free (k);
13381 
13382   return;
13383 
13384   /* ERRORS */
13385 short_read:
13386   {
13387     GST_DEBUG_OBJECT (qtdemux, &quot;short read parsing 3GP keywords&quot;);
13388     goto done;
13389   }
13390 }
13391 
13392 static void
13393 qtdemux_tag_add_num (GstQTDemux * qtdemux, GstTagList * taglist,
13394     const char *tag1, const char *tag2, GNode * node)
13395 {
13396   GNode *data;
13397   int len;
13398   int type;
13399   int n1, n2;
13400 
13401   data = qtdemux_tree_get_child_by_type (node, FOURCC_data);
13402   if (data) {
13403     len = QT_UINT32 (data-&gt;data);
13404     type = QT_UINT32 ((guint8 *) data-&gt;data + 8);
13405     if (type == 0x00000000 &amp;&amp; len &gt;= 22) {
13406       n1 = QT_UINT16 ((guint8 *) data-&gt;data + 18);
13407       n2 = QT_UINT16 ((guint8 *) data-&gt;data + 20);
13408       if (n1 &gt; 0) {
13409         GST_DEBUG_OBJECT (qtdemux, &quot;adding tag %s=%d&quot;, tag1, n1);
13410         gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag1, n1, NULL);
13411       }
13412       if (n2 &gt; 0) {
13413         GST_DEBUG_OBJECT (qtdemux, &quot;adding tag %s=%d&quot;, tag2, n2);
13414         gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag2, n2, NULL);
13415       }
13416     }
13417   }
13418 }
13419 
13420 static void
13421 qtdemux_tag_add_tmpo (GstQTDemux * qtdemux, GstTagList * taglist,
13422     const char *tag1, const char *dummy, GNode * node)
13423 {
13424   GNode *data;
13425   int len;
13426   int type;
13427   int n1;
13428 
13429   data = qtdemux_tree_get_child_by_type (node, FOURCC_data);
13430   if (data) {
13431     len = QT_UINT32 (data-&gt;data);
13432     type = QT_UINT32 ((guint8 *) data-&gt;data + 8);
13433     GST_DEBUG_OBJECT (qtdemux, &quot;have tempo tag, type=%d,len=%d&quot;, type, len);
13434     /* some files wrongly have a type 0x0f=15, but it should be 0x15 */
13435     if ((type == 0x00000015 || type == 0x0000000f) &amp;&amp; len &gt;= 18) {
13436       n1 = QT_UINT16 ((guint8 *) data-&gt;data + 16);
13437       if (n1) {
13438         /* do not add bpm=0 */
13439         GST_DEBUG_OBJECT (qtdemux, &quot;adding tag %d&quot;, n1);
13440         gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag1, (gdouble) n1,
13441             NULL);
13442       }
13443     }
13444   }
13445 }
13446 
13447 static void
13448 qtdemux_tag_add_uint32 (GstQTDemux * qtdemux, GstTagList * taglist,
13449     const char *tag1, const char *dummy, GNode * node)
13450 {
13451   GNode *data;
13452   int len;
13453   int type;
13454   guint32 num;
13455 
13456   data = qtdemux_tree_get_child_by_type (node, FOURCC_data);
13457   if (data) {
13458     len = QT_UINT32 (data-&gt;data);
13459     type = QT_UINT32 ((guint8 *) data-&gt;data + 8);
13460     GST_DEBUG_OBJECT (qtdemux, &quot;have %s tag, type=%d,len=%d&quot;, tag1, type, len);
13461     /* some files wrongly have a type 0x0f=15, but it should be 0x15 */
13462     if ((type == 0x00000015 || type == 0x0000000f) &amp;&amp; len &gt;= 20) {
13463       num = QT_UINT32 ((guint8 *) data-&gt;data + 16);
13464       if (num) {
13465         /* do not add num=0 */
13466         GST_DEBUG_OBJECT (qtdemux, &quot;adding tag %d&quot;, num);
13467         gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag1, num, NULL);
13468       }
13469     }
13470   }
13471 }
13472 
13473 static void
13474 qtdemux_tag_add_covr (GstQTDemux * qtdemux, GstTagList * taglist,
13475     const char *tag1, const char *dummy, GNode * node)
13476 {
13477   GNode *data;
13478   int len;
13479   int type;
13480   GstSample *sample;
13481 
13482   data = qtdemux_tree_get_child_by_type (node, FOURCC_data);
13483   if (data) {
13484     len = QT_UINT32 (data-&gt;data);
13485     type = QT_UINT32 ((guint8 *) data-&gt;data + 8);
13486     GST_DEBUG_OBJECT (qtdemux, &quot;have covr tag, type=%d,len=%d&quot;, type, len);
13487     if ((type == 0x0000000d || type == 0x0000000e) &amp;&amp; len &gt; 16) {
13488       GstTagImageType image_type;
13489 
13490       if (gst_tag_list_get_tag_size (taglist, GST_TAG_IMAGE) == 0)
13491         image_type = GST_TAG_IMAGE_TYPE_FRONT_COVER;
13492       else
13493         image_type = GST_TAG_IMAGE_TYPE_NONE;
13494 
13495       if ((sample =
13496               gst_tag_image_data_to_image_sample ((guint8 *) data-&gt;data + 16,
13497                   len - 16, image_type))) {
13498         GST_DEBUG_OBJECT (qtdemux, &quot;adding tag size %d&quot;, len - 16);
13499         gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag1, sample, NULL);
13500         gst_sample_unref (sample);
13501       }
13502     }
13503   }
13504 }
13505 
13506 static void
13507 qtdemux_tag_add_date (GstQTDemux * qtdemux, GstTagList * taglist,
13508     const char *tag, const char *dummy, GNode * node)
13509 {
13510   GNode *data;
<a name="621" id="anc621"></a><span class="line-added">13511   GstDateTime *datetime = NULL;</span>
13512   char *s;
13513   int len;
13514   int type;
13515 
13516   data = qtdemux_tree_get_child_by_type (node, FOURCC_data);
13517   if (data) {
13518     len = QT_UINT32 (data-&gt;data);
13519     type = QT_UINT32 ((guint8 *) data-&gt;data + 8);
13520     if (type == 0x00000001 &amp;&amp; len &gt; 16) {
13521       guint y, m = 1, d = 1;
13522       gint ret;
13523 
13524       s = g_strndup ((char *) data-&gt;data + 16, len - 16);
13525       GST_DEBUG_OBJECT (qtdemux, &quot;adding date &#39;%s&#39;&quot;, s);
<a name="622" id="anc622"></a><span class="line-added">13526       datetime = gst_date_time_new_from_iso8601_string (s);</span>
<span class="line-added">13527       if (datetime != NULL) {</span>
<span class="line-added">13528         gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, GST_TAG_DATE_TIME,</span>
<span class="line-added">13529             datetime, NULL);</span>
<span class="line-added">13530         gst_date_time_unref (datetime);</span>
<span class="line-added">13531       }</span>
<span class="line-added">13532 </span>
13533       ret = sscanf (s, &quot;%u-%u-%u&quot;, &amp;y, &amp;m, &amp;d);
13534       if (ret &gt;= 1 &amp;&amp; y &gt; 1500 &amp;&amp; y &lt; 3000) {
13535         GDate *date;
13536 
13537         date = g_date_new_dmy (d, m, y);
13538         gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, date, NULL);
13539         g_date_free (date);
13540       } else {
13541         GST_DEBUG_OBJECT (qtdemux, &quot;could not parse date string &#39;%s&#39;&quot;, s);
13542       }
13543       g_free (s);
13544     }
13545   }
13546 }
13547 
13548 static void
13549 qtdemux_tag_add_gnre (GstQTDemux * qtdemux, GstTagList * taglist,
13550     const char *tag, const char *dummy, GNode * node)
13551 {
13552   GNode *data;
13553 
13554   data = qtdemux_tree_get_child_by_type (node, FOURCC_data);
13555 
13556   /* re-route to normal string tag if major brand says so
13557    * or no data atom and compatible brand suggests so */
13558   if (qtdemux_is_brand_3gp (qtdemux, TRUE) ||
13559       (qtdemux_is_brand_3gp (qtdemux, FALSE) &amp;&amp; !data)) {
13560     qtdemux_tag_add_str (qtdemux, taglist, tag, dummy, node);
13561     return;
13562   }
13563 
13564   if (data) {
13565     guint len, type, n;
13566 
13567     len = QT_UINT32 (data-&gt;data);
13568     type = QT_UINT32 ((guint8 *) data-&gt;data + 8);
13569     if (type == 0x00000000 &amp;&amp; len &gt;= 18) {
13570       n = QT_UINT16 ((guint8 *) data-&gt;data + 16);
13571       if (n &gt; 0) {
13572         const gchar *genre;
13573 
13574         genre = gst_tag_id3_genre_get (n - 1);
13575         if (genre != NULL) {
13576           GST_DEBUG_OBJECT (qtdemux, &quot;adding %d [%s]&quot;, n, genre);
13577           gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, genre, NULL);
13578         }
13579       }
13580     }
13581   }
13582 }
13583 
13584 static void
13585 qtdemux_add_double_tag_from_str (GstQTDemux * demux, GstTagList * taglist,
13586     const gchar * tag, guint8 * data, guint32 datasize)
13587 {
13588   gdouble value;
13589   gchar *datacopy;
13590 
13591   /* make a copy to have \0 at the end */
13592   datacopy = g_strndup ((gchar *) data, datasize);
13593 
13594   /* convert the str to double */
13595   if (sscanf (datacopy, &quot;%lf&quot;, &amp;value) == 1) {
13596     GST_DEBUG_OBJECT (demux, &quot;adding tag: %s [%s]&quot;, tag, datacopy);
13597     gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, tag, value, NULL);
13598   } else {
13599     GST_WARNING_OBJECT (demux, &quot;Failed to parse double from string: %s&quot;,
13600         datacopy);
13601   }
13602   g_free (datacopy);
13603 }
13604 
13605 
13606 static void
13607 qtdemux_tag_add_revdns (GstQTDemux * demux, GstTagList * taglist,
13608     const char *tag, const char *tag_bis, GNode * node)
13609 {
13610   GNode *mean;
13611   GNode *name;
13612   GNode *data;
13613   guint32 meansize;
13614   guint32 namesize;
13615   guint32 datatype;
13616   guint32 datasize;
13617   const gchar *meanstr;
13618   const gchar *namestr;
13619 
13620   /* checking the whole ---- atom size for consistency */
13621   if (QT_UINT32 (node-&gt;data) &lt;= 4 + 12 + 12 + 16) {
13622     GST_WARNING_OBJECT (demux, &quot;Tag ---- atom is too small, ignoring&quot;);
13623     return;
13624   }
13625 
13626   mean = qtdemux_tree_get_child_by_type (node, FOURCC_mean);
13627   if (!mean) {
13628     GST_WARNING_OBJECT (demux, &quot;No &#39;mean&#39; atom found&quot;);
13629     return;
13630   }
13631 
13632   meansize = QT_UINT32 (mean-&gt;data);
13633   if (meansize &lt;= 12) {
13634     GST_WARNING_OBJECT (demux, &quot;Small mean atom, ignoring the whole tag&quot;);
13635     return;
13636   }
13637   meanstr = ((gchar *) mean-&gt;data) + 12;
13638   meansize -= 12;
13639 
13640   name = qtdemux_tree_get_child_by_type (node, FOURCC_name);
13641   if (!name) {
13642     GST_WARNING_OBJECT (demux, &quot;&#39;name&#39; atom not found, ignoring tag&quot;);
13643     return;
13644   }
13645 
13646   namesize = QT_UINT32 (name-&gt;data);
13647   if (namesize &lt;= 12) {
13648     GST_WARNING_OBJECT (demux, &quot;&#39;name&#39; atom is too small, ignoring tag&quot;);
13649     return;
13650   }
13651   namestr = ((gchar *) name-&gt;data) + 12;
13652   namesize -= 12;
13653 
13654   /*
13655    * Data atom is:
13656    * uint32 - size
13657    * uint32 - name
13658    * uint8  - version
13659    * uint24 - data type
13660    * uint32 - all 0
13661    * rest   - the data
13662    */
13663   data = qtdemux_tree_get_child_by_type (node, FOURCC_data);
13664   if (!data) {
13665     GST_WARNING_OBJECT (demux, &quot;No data atom in this tag&quot;);
13666     return;
13667   }
13668   datasize = QT_UINT32 (data-&gt;data);
13669   if (datasize &lt;= 16) {
13670     GST_WARNING_OBJECT (demux, &quot;Data atom too small&quot;);
13671     return;
13672   }
13673   datatype = QT_UINT32 (((gchar *) data-&gt;data) + 8) &amp; 0xFFFFFF;
13674 
13675   if ((strncmp (meanstr, &quot;com.apple.iTunes&quot;, meansize) == 0) ||
13676       (strncmp (meanstr, &quot;org.hydrogenaudio.replaygain&quot;, meansize) == 0)) {
13677     static const struct
13678     {
13679       const gchar name[28];
13680       const gchar tag[28];
13681     } tags[] = {
13682       {
13683       &quot;replaygain_track_gain&quot;, GST_TAG_TRACK_GAIN}, {
13684       &quot;replaygain_track_peak&quot;, GST_TAG_TRACK_PEAK}, {
13685       &quot;replaygain_album_gain&quot;, GST_TAG_ALBUM_GAIN}, {
13686       &quot;replaygain_album_peak&quot;, GST_TAG_ALBUM_PEAK}, {
13687       &quot;MusicBrainz Track Id&quot;, GST_TAG_MUSICBRAINZ_TRACKID}, {
13688       &quot;MusicBrainz Artist Id&quot;, GST_TAG_MUSICBRAINZ_ARTISTID}, {
13689       &quot;MusicBrainz Album Id&quot;, GST_TAG_MUSICBRAINZ_ALBUMID}, {
13690       &quot;MusicBrainz Album Artist Id&quot;, GST_TAG_MUSICBRAINZ_ALBUMARTISTID}
13691     };
13692     int i;
13693 
13694     for (i = 0; i &lt; G_N_ELEMENTS (tags); ++i) {
13695       if (!g_ascii_strncasecmp (tags[i].name, namestr, namesize)) {
13696         switch (gst_tag_get_type (tags[i].tag)) {
13697           case G_TYPE_DOUBLE:
13698             qtdemux_add_double_tag_from_str (demux, taglist, tags[i].tag,
13699                 ((guint8 *) data-&gt;data) + 16, datasize - 16);
13700             break;
13701           case G_TYPE_STRING:
13702             qtdemux_tag_add_str (demux, taglist, tags[i].tag, NULL, node);
13703             break;
13704           default:
13705             /* not reached */
13706             break;
13707         }
13708         break;
13709       }
13710     }
13711     if (i == G_N_ELEMENTS (tags))
13712       goto unknown_tag;
13713   } else {
13714     goto unknown_tag;
13715   }
13716 
13717   return;
13718 
13719 /* errors */
13720 unknown_tag:
13721 #ifndef GST_DISABLE_GST_DEBUG
13722   {
13723     gchar *namestr_dbg;
13724     gchar *meanstr_dbg;
13725 
13726     meanstr_dbg = g_strndup (meanstr, meansize);
13727     namestr_dbg = g_strndup (namestr, namesize);
13728 
13729     GST_WARNING_OBJECT (demux, &quot;This tag %s:%s type:%u is not mapped, &quot;
13730         &quot;file a bug at bugzilla.gnome.org&quot;, meanstr_dbg, namestr_dbg, datatype);
13731 
13732     g_free (namestr_dbg);
13733     g_free (meanstr_dbg);
13734   }
13735 #endif
<a name="623" id="anc623"></a><span class="line-modified">13736   return;</span>
13737 }
13738 
13739 static void
13740 qtdemux_tag_add_id32 (GstQTDemux * demux, GstTagList * taglist, const char *tag,
13741     const char *tag_bis, GNode * node)
13742 {
13743   guint8 *data;
13744   GstBuffer *buf;
13745   guint len;
13746   GstTagList *id32_taglist = NULL;
13747 
13748   GST_LOG_OBJECT (demux, &quot;parsing ID32&quot;);
13749 
13750   data = node-&gt;data;
13751   len = GST_READ_UINT32_BE (data);
13752 
13753   /* need at least full box and language tag */
13754   if (len &lt; 12 + 2)
13755     return;
13756 
13757   buf = gst_buffer_new_allocate (NULL, len - 14, NULL);
13758   gst_buffer_fill (buf, 0, data + 14, len - 14);
13759 
13760   id32_taglist = gst_tag_list_from_id3v2_tag (buf);
13761   if (id32_taglist) {
13762     GST_LOG_OBJECT (demux, &quot;parsing ok&quot;);
13763     gst_tag_list_insert (taglist, id32_taglist, GST_TAG_MERGE_KEEP);
13764     gst_tag_list_unref (id32_taglist);
13765   } else {
13766     GST_LOG_OBJECT (demux, &quot;parsing failed&quot;);
13767   }
13768 
13769   gst_buffer_unref (buf);
13770 }
13771 
13772 typedef void (*GstQTDemuxAddTagFunc) (GstQTDemux * demux, GstTagList * taglist,
13773     const char *tag, const char *tag_bis, GNode * node);
13774 
13775 /* unmapped tags
13776 FOURCC_pcst -&gt; if media is a podcast -&gt; bool
13777 FOURCC_cpil -&gt; if media is part of a compilation -&gt; bool
13778 FOURCC_pgap -&gt; if media is part of a gapless context -&gt; bool
13779 FOURCC_tven -&gt; the tv episode id e.g. S01E23 -&gt; str
13780 */
13781 
13782 static const struct
13783 {
13784   guint32 fourcc;
13785   const gchar *gst_tag;
13786   const gchar *gst_tag_bis;
13787   const GstQTDemuxAddTagFunc func;
13788 } add_funcs[] = {
13789   {
13790   FOURCC__nam, GST_TAG_TITLE, NULL, qtdemux_tag_add_str}, {
13791   FOURCC_titl, GST_TAG_TITLE, NULL, qtdemux_tag_add_str}, {
13792   FOURCC__grp, GST_TAG_GROUPING, NULL, qtdemux_tag_add_str}, {
13793   FOURCC__wrt, GST_TAG_COMPOSER, NULL, qtdemux_tag_add_str}, {
13794   FOURCC__ART, GST_TAG_ARTIST, NULL, qtdemux_tag_add_str}, {
13795   FOURCC_aART, GST_TAG_ALBUM_ARTIST, NULL, qtdemux_tag_add_str}, {
13796   FOURCC_perf, GST_TAG_ARTIST, NULL, qtdemux_tag_add_str}, {
13797   FOURCC_auth, GST_TAG_COMPOSER, NULL, qtdemux_tag_add_str}, {
13798   FOURCC__alb, GST_TAG_ALBUM, NULL, qtdemux_tag_add_str}, {
13799   FOURCC_albm, GST_TAG_ALBUM, NULL, qtdemux_tag_add_str}, {
13800   FOURCC_cprt, GST_TAG_COPYRIGHT, NULL, qtdemux_tag_add_str}, {
13801   FOURCC__cpy, GST_TAG_COPYRIGHT, NULL, qtdemux_tag_add_str}, {
13802   FOURCC__cmt, GST_TAG_COMMENT, NULL, qtdemux_tag_add_str}, {
13803   FOURCC__des, GST_TAG_DESCRIPTION, NULL, qtdemux_tag_add_str}, {
13804   FOURCC_desc, GST_TAG_DESCRIPTION, NULL, qtdemux_tag_add_str}, {
13805   FOURCC_dscp, GST_TAG_DESCRIPTION, NULL, qtdemux_tag_add_str}, {
13806   FOURCC__lyr, GST_TAG_LYRICS, NULL, qtdemux_tag_add_str}, {
13807   FOURCC__day, GST_TAG_DATE, NULL, qtdemux_tag_add_date}, {
13808   FOURCC_yrrc, GST_TAG_DATE, NULL, qtdemux_tag_add_year}, {
13809   FOURCC__too, GST_TAG_ENCODER, NULL, qtdemux_tag_add_str}, {
13810   FOURCC__inf, GST_TAG_COMMENT, NULL, qtdemux_tag_add_str}, {
13811   FOURCC_trkn, GST_TAG_TRACK_NUMBER, GST_TAG_TRACK_COUNT, qtdemux_tag_add_num}, {
13812   FOURCC_disk, GST_TAG_ALBUM_VOLUME_NUMBER, GST_TAG_ALBUM_VOLUME_COUNT,
13813         qtdemux_tag_add_num}, {
13814   FOURCC_disc, GST_TAG_ALBUM_VOLUME_NUMBER, GST_TAG_ALBUM_VOLUME_COUNT,
13815         qtdemux_tag_add_num}, {
13816   FOURCC__gen, GST_TAG_GENRE, NULL, qtdemux_tag_add_str}, {
13817   FOURCC_gnre, GST_TAG_GENRE, NULL, qtdemux_tag_add_gnre}, {
13818   FOURCC_tmpo, GST_TAG_BEATS_PER_MINUTE, NULL, qtdemux_tag_add_tmpo}, {
13819   FOURCC_covr, GST_TAG_IMAGE, NULL, qtdemux_tag_add_covr}, {
13820   FOURCC_sonm, GST_TAG_TITLE_SORTNAME, NULL, qtdemux_tag_add_str}, {
13821   FOURCC_soal, GST_TAG_ALBUM_SORTNAME, NULL, qtdemux_tag_add_str}, {
13822   FOURCC_soar, GST_TAG_ARTIST_SORTNAME, NULL, qtdemux_tag_add_str}, {
13823   FOURCC_soaa, GST_TAG_ALBUM_ARTIST_SORTNAME, NULL, qtdemux_tag_add_str}, {
13824   FOURCC_soco, GST_TAG_COMPOSER_SORTNAME, NULL, qtdemux_tag_add_str}, {
13825   FOURCC_sosn, GST_TAG_SHOW_SORTNAME, NULL, qtdemux_tag_add_str}, {
13826   FOURCC_tvsh, GST_TAG_SHOW_NAME, NULL, qtdemux_tag_add_str}, {
13827   FOURCC_tvsn, GST_TAG_SHOW_SEASON_NUMBER, NULL, qtdemux_tag_add_uint32}, {
13828   FOURCC_tves, GST_TAG_SHOW_EPISODE_NUMBER, NULL, qtdemux_tag_add_uint32}, {
13829   FOURCC_kywd, GST_TAG_KEYWORDS, NULL, qtdemux_tag_add_keywords}, {
13830   FOURCC_keyw, GST_TAG_KEYWORDS, NULL, qtdemux_tag_add_str}, {
13831   FOURCC__enc, GST_TAG_ENCODER, NULL, qtdemux_tag_add_str}, {
13832   FOURCC_loci, GST_TAG_GEO_LOCATION_NAME, NULL, qtdemux_tag_add_location}, {
13833   FOURCC_clsf, GST_QT_DEMUX_CLASSIFICATION_TAG, NULL,
13834         qtdemux_tag_add_classification}, {
13835   FOURCC__mak, GST_TAG_DEVICE_MANUFACTURER, NULL, qtdemux_tag_add_str}, {
13836   FOURCC__mod, GST_TAG_DEVICE_MODEL, NULL, qtdemux_tag_add_str}, {
13837   FOURCC__swr, GST_TAG_APPLICATION_NAME, NULL, qtdemux_tag_add_str}, {
13838 
13839     /* This is a special case, some tags are stored in this
13840      * &#39;reverse dns naming&#39;, according to:
13841      * http://atomicparsley.sourceforge.net/mpeg-4files.html and
13842      * bug #614471
13843      */
13844   FOURCC_____, &quot;&quot;, NULL, qtdemux_tag_add_revdns}, {
13845     /* see http://www.mp4ra.org/specs.html for ID32 in meta box */
13846   FOURCC_ID32, &quot;&quot;, NULL, qtdemux_tag_add_id32}
13847 };
13848 
13849 struct _GstQtDemuxTagList
13850 {
13851   GstQTDemux *demux;
13852   GstTagList *taglist;
13853 };
13854 typedef struct _GstQtDemuxTagList GstQtDemuxTagList;
13855 
13856 static void
13857 qtdemux_tag_add_blob (GNode * node, GstQtDemuxTagList * qtdemuxtaglist)
13858 {
13859   gint len;
13860   guint8 *data;
13861   GstBuffer *buf;
13862   gchar *media_type;
13863   const gchar *style;
13864   GstSample *sample;
13865   GstStructure *s;
13866   guint i;
13867   guint8 ndata[4];
13868   GstQTDemux *demux = qtdemuxtaglist-&gt;demux;
13869   GstTagList *taglist = qtdemuxtaglist-&gt;taglist;
13870 
13871   data = node-&gt;data;
13872   len = QT_UINT32 (data);
13873   buf = gst_buffer_new_and_alloc (len);
13874   gst_buffer_fill (buf, 0, data, len);
13875 
13876   /* heuristic to determine style of tag */
13877   if (QT_FOURCC (data + 4) == FOURCC_____ ||
13878       (len &gt; 8 + 12 &amp;&amp; QT_FOURCC (data + 12) == FOURCC_data))
13879     style = &quot;itunes&quot;;
13880   else if (demux-&gt;major_brand == FOURCC_qt__)
13881     style = &quot;quicktime&quot;;
13882   /* fall back to assuming iso/3gp tag style */
13883   else
13884     style = &quot;iso&quot;;
13885 
13886   /* santize the name for the caps. */
13887   for (i = 0; i &lt; 4; i++) {
13888     guint8 d = data[4 + i];
13889     if (g_ascii_isalnum (d))
13890       ndata[i] = g_ascii_tolower (d);
13891     else
13892       ndata[i] = &#39;_&#39;;
13893   }
13894 
13895   media_type = g_strdup_printf (&quot;application/x-gst-qt-%c%c%c%c-tag&quot;,
13896       ndata[0], ndata[1], ndata[2], ndata[3]);
13897   GST_DEBUG_OBJECT (demux, &quot;media type %s&quot;, media_type);
13898 
13899   s = gst_structure_new (media_type, &quot;style&quot;, G_TYPE_STRING, style, NULL);
13900   sample = gst_sample_new (buf, NULL, NULL, s);
13901   gst_buffer_unref (buf);
13902   g_free (media_type);
13903 
13904   GST_DEBUG_OBJECT (demux, &quot;adding private tag; size %d, info %&quot; GST_PTR_FORMAT,
13905       len, s);
13906 
13907   gst_tag_list_add (taglist, GST_TAG_MERGE_APPEND,
13908       GST_QT_DEMUX_PRIVATE_TAG, sample, NULL);
13909 
13910   gst_sample_unref (sample);
13911 }
13912 
13913 static void
13914 qtdemux_parse_udta (GstQTDemux * qtdemux, GstTagList * taglist, GNode * udta)
13915 {
13916   GNode *meta;
13917   GNode *ilst;
13918   GNode *xmp_;
13919   GNode *node;
13920   gint i;
13921   GstQtDemuxTagList demuxtaglist;
13922 
13923   demuxtaglist.demux = qtdemux;
13924   demuxtaglist.taglist = taglist;
13925 
13926   meta = qtdemux_tree_get_child_by_type (udta, FOURCC_meta);
13927   if (meta != NULL) {
13928     ilst = qtdemux_tree_get_child_by_type (meta, FOURCC_ilst);
13929     if (ilst == NULL) {
13930       GST_LOG_OBJECT (qtdemux, &quot;no ilst&quot;);
13931       return;
13932     }
13933   } else {
13934     ilst = udta;
13935     GST_LOG_OBJECT (qtdemux, &quot;no meta so using udta itself&quot;);
13936   }
13937 
13938   i = 0;
13939   while (i &lt; G_N_ELEMENTS (add_funcs)) {
13940     node = qtdemux_tree_get_child_by_type (ilst, add_funcs[i].fourcc);
13941     if (node) {
13942       gint len;
13943 
13944       len = QT_UINT32 (node-&gt;data);
13945       if (len &lt; 12) {
13946         GST_DEBUG_OBJECT (qtdemux, &quot;too small tag atom %&quot; GST_FOURCC_FORMAT,
13947             GST_FOURCC_ARGS (add_funcs[i].fourcc));
13948       } else {
13949         add_funcs[i].func (qtdemux, taglist, add_funcs[i].gst_tag,
13950             add_funcs[i].gst_tag_bis, node);
13951       }
13952       g_node_destroy (node);
13953     } else {
13954       i++;
13955     }
13956   }
13957 
13958   /* parsed nodes have been removed, pass along remainder as blob */
13959   g_node_children_foreach (ilst, G_TRAVERSE_ALL,
13960       (GNodeForeachFunc) qtdemux_tag_add_blob, &amp;demuxtaglist);
13961 
13962 #ifndef GSTREAMER_LITE
13963   /* parse up XMP_ node if existing */
13964   xmp_ = qtdemux_tree_get_child_by_type (udta, FOURCC_XMP_);
13965   if (xmp_ != NULL) {
13966     GstBuffer *buf;
13967     GstTagList *xmptaglist;
13968 
13969     buf = _gst_buffer_new_wrapped (((guint8 *) xmp_-&gt;data) + 8,
13970         QT_UINT32 ((guint8 *) xmp_-&gt;data) - 8, NULL);
13971     xmptaglist = gst_tag_list_from_xmp_buffer (buf);
13972     gst_buffer_unref (buf);
13973 
13974     qtdemux_handle_xmp_taglist (qtdemux, taglist, xmptaglist);
13975   } else {
13976     GST_DEBUG_OBJECT (qtdemux, &quot;No XMP_ node found&quot;);
13977   }
13978 #endif // GSTREAMER_LITE
13979 }
13980 
13981 typedef struct
13982 {
13983   GstStructure *structure;      /* helper for sort function */
13984   gchar *location;
13985   guint min_req_bitrate;
13986   guint min_req_qt_version;
13987 } GstQtReference;
13988 
13989 static gint
13990 qtdemux_redirects_sort_func (gconstpointer a, gconstpointer b)
13991 {
13992   GstQtReference *ref_a = (GstQtReference *) a;
13993   GstQtReference *ref_b = (GstQtReference *) b;
13994 
13995   if (ref_b-&gt;min_req_qt_version != ref_a-&gt;min_req_qt_version)
13996     return ref_b-&gt;min_req_qt_version - ref_a-&gt;min_req_qt_version;
13997 
13998   /* known bitrates go before unknown; higher bitrates go first */
13999   return ref_b-&gt;min_req_bitrate - ref_a-&gt;min_req_bitrate;
14000 }
14001 
14002 /* sort the redirects and post a message for the application.
14003  */
14004 static void
14005 qtdemux_process_redirects (GstQTDemux * qtdemux, GList * references)
14006 {
14007   GstQtReference *best;
14008   GstStructure *s;
14009   GstMessage *msg;
14010   GValue list_val = { 0, };
14011   GList *l;
14012 
14013   g_assert (references != NULL);
14014 
14015   references = g_list_sort (references, qtdemux_redirects_sort_func);
14016 
14017   best = (GstQtReference *) references-&gt;data;
14018 
14019   g_value_init (&amp;list_val, GST_TYPE_LIST);
14020 
14021   for (l = references; l != NULL; l = l-&gt;next) {
14022     GstQtReference *ref = (GstQtReference *) l-&gt;data;
14023     GValue struct_val = { 0, };
14024 
14025     ref-&gt;structure = gst_structure_new (&quot;redirect&quot;,
14026         &quot;new-location&quot;, G_TYPE_STRING, ref-&gt;location, NULL);
14027 
14028     if (ref-&gt;min_req_bitrate &gt; 0) {
14029       gst_structure_set (ref-&gt;structure, &quot;minimum-bitrate&quot;, G_TYPE_INT,
14030           ref-&gt;min_req_bitrate, NULL);
14031     }
14032 
14033     g_value_init (&amp;struct_val, GST_TYPE_STRUCTURE);
14034     g_value_set_boxed (&amp;struct_val, ref-&gt;structure);
14035     gst_value_list_append_value (&amp;list_val, &amp;struct_val);
14036     g_value_unset (&amp;struct_val);
14037     /* don&#39;t free anything here yet, since we need best-&gt;structure below */
14038   }
14039 
14040   g_assert (best != NULL);
14041   s = gst_structure_copy (best-&gt;structure);
14042 
14043   if (g_list_length (references) &gt; 1) {
14044     gst_structure_set_value (s, &quot;locations&quot;, &amp;list_val);
14045   }
14046 
14047   g_value_unset (&amp;list_val);
14048 
14049   for (l = references; l != NULL; l = l-&gt;next) {
14050     GstQtReference *ref = (GstQtReference *) l-&gt;data;
14051 
14052     gst_structure_free (ref-&gt;structure);
14053     g_free (ref-&gt;location);
14054     g_free (ref);
14055   }
14056   g_list_free (references);
14057 
14058   GST_INFO_OBJECT (qtdemux, &quot;posting redirect message: %&quot; GST_PTR_FORMAT, s);
14059   msg = gst_message_new_element (GST_OBJECT_CAST (qtdemux), s);
14060   gst_element_post_message (GST_ELEMENT_CAST (qtdemux), msg);
14061   qtdemux-&gt;posted_redirect = TRUE;
14062 }
14063 
14064 /* look for redirect nodes, collect all redirect information and
14065  * process it.
14066  */
14067 static gboolean
14068 qtdemux_parse_redirects (GstQTDemux * qtdemux)
14069 {
14070   GNode *rmra, *rmda, *rdrf;
14071 
14072   rmra = qtdemux_tree_get_child_by_type (qtdemux-&gt;moov_node, FOURCC_rmra);
14073   if (rmra) {
14074     GList *redirects = NULL;
14075 
14076     rmda = qtdemux_tree_get_child_by_type (rmra, FOURCC_rmda);
14077     while (rmda) {
14078       GstQtReference ref = { NULL, NULL, 0, 0 };
14079       GNode *rmdr, *rmvc;
14080 
14081       if ((rmdr = qtdemux_tree_get_child_by_type (rmda, FOURCC_rmdr))) {
14082         ref.min_req_bitrate = QT_UINT32 ((guint8 *) rmdr-&gt;data + 12);
14083         GST_LOG_OBJECT (qtdemux, &quot;data rate atom, required bitrate = %u&quot;,
14084             ref.min_req_bitrate);
14085       }
14086 
14087       if ((rmvc = qtdemux_tree_get_child_by_type (rmda, FOURCC_rmvc))) {
14088         guint32 package = QT_FOURCC ((guint8 *) rmvc-&gt;data + 12);
14089         guint version = QT_UINT32 ((guint8 *) rmvc-&gt;data + 16);
14090 
14091 #ifndef GST_DISABLE_GST_DEBUG
14092         guint bitmask = QT_UINT32 ((guint8 *) rmvc-&gt;data + 20);
14093 #endif
14094         guint check_type = QT_UINT16 ((guint8 *) rmvc-&gt;data + 24);
14095 
14096         GST_LOG_OBJECT (qtdemux,
14097             &quot;version check atom [%&quot; GST_FOURCC_FORMAT &quot;], version=0x%08x&quot;
14098             &quot;, mask=%08x, check_type=%u&quot;, GST_FOURCC_ARGS (package), version,
14099             bitmask, check_type);
14100         if (package == FOURCC_qtim &amp;&amp; check_type == 0) {
14101           ref.min_req_qt_version = version;
14102         }
14103       }
14104 
14105       rdrf = qtdemux_tree_get_child_by_type (rmda, FOURCC_rdrf);
14106       if (rdrf) {
14107         guint32 ref_type;
14108         guint8 *ref_data;
14109         guint ref_len;
14110 
14111         ref_len = QT_UINT32 ((guint8 *) rdrf-&gt;data);
14112         if (ref_len &gt; 20) {
<a name="624" id="anc624"></a><span class="line-modified">14113           ref_type = QT_FOURCC ((guint8 *) rdrf-&gt;data + 12);</span>
<span class="line-modified">14114           ref_data = (guint8 *) rdrf-&gt;data + 20;</span>
<span class="line-modified">14115           if (ref_type == FOURCC_alis) {</span>
<span class="line-modified">14116             guint record_len, record_version, fn_len;</span>
14117 
14118             if (ref_len &gt; 70) {
<a name="625" id="anc625"></a><span class="line-modified">14119               /* MacOSX alias record, google for alias-layout.txt */</span>
<span class="line-modified">14120               record_len = QT_UINT16 (ref_data + 4);</span>
<span class="line-modified">14121               record_version = QT_UINT16 (ref_data + 4 + 2);</span>
<span class="line-modified">14122               fn_len = QT_UINT8 (ref_data + 50);</span>
<span class="line-modified">14123               if (record_len &gt; 50 &amp;&amp; record_version == 2 &amp;&amp; fn_len &gt; 0) {</span>
<span class="line-modified">14124                 ref.location = g_strndup ((gchar *) ref_data + 51, fn_len);</span>
<span class="line-modified">14125               }</span>
14126             } else {
14127               GST_WARNING_OBJECT (qtdemux, &quot;Invalid rdrf/alis size (%u &lt; 70)&quot;,
14128                   ref_len);
14129             }
<a name="626" id="anc626"></a><span class="line-modified">14130           } else if (ref_type == FOURCC_url_) {</span>
14131             ref.location = g_strndup ((gchar *) ref_data, ref_len - 8);
<a name="627" id="anc627"></a><span class="line-modified">14132           } else {</span>
<span class="line-modified">14133             GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-modified">14134                 &quot;unknown rdrf reference type %&quot; GST_FOURCC_FORMAT,</span>
<span class="line-modified">14135                 GST_FOURCC_ARGS (ref_type));</span>
<span class="line-modified">14136           }</span>
<span class="line-modified">14137           if (ref.location != NULL) {</span>
<span class="line-modified">14138             GST_INFO_OBJECT (qtdemux, &quot;New location: %s&quot;, ref.location);</span>
14139             redirects =
14140                 g_list_prepend (redirects, g_memdup (&amp;ref, sizeof (ref)));
<a name="628" id="anc628"></a><span class="line-modified">14141           } else {</span>
<span class="line-modified">14142             GST_WARNING_OBJECT (qtdemux,</span>
<span class="line-modified">14143                 &quot;Failed to extract redirect location from rdrf atom&quot;);</span>
<span class="line-modified">14144           }</span>
14145         } else {
14146           GST_WARNING_OBJECT (qtdemux, &quot;Invalid rdrf size (%u &lt; 20)&quot;, ref_len);
<a name="629" id="anc629"></a><span class="line-modified">14147         }</span>
14148       }
14149 
14150       /* look for others */
14151       rmda = qtdemux_tree_get_sibling_by_type (rmda, FOURCC_rmda);
14152     }
14153 
14154     if (redirects != NULL) {
14155       qtdemux_process_redirects (qtdemux, redirects);
14156     }
14157   }
14158   return TRUE;
14159 }
14160 
14161 static GstTagList *
14162 qtdemux_add_container_format (GstQTDemux * qtdemux, GstTagList * tags)
14163 {
14164   const gchar *fmt;
14165 
14166   if (tags == NULL) {
14167     tags = gst_tag_list_new_empty ();
14168     gst_tag_list_set_scope (tags, GST_TAG_SCOPE_GLOBAL);
14169   }
14170 
14171   if (qtdemux-&gt;major_brand == FOURCC_mjp2)
14172     fmt = &quot;Motion JPEG 2000&quot;;
14173   else if ((qtdemux-&gt;major_brand &amp; 0xffff) == FOURCC_3g__)
14174     fmt = &quot;3GP&quot;;
14175   else if (qtdemux-&gt;major_brand == FOURCC_qt__)
14176     fmt = &quot;Quicktime&quot;;
14177   else if (qtdemux-&gt;fragmented)
14178     fmt = &quot;ISO fMP4&quot;;
14179   else
14180     fmt = &quot;ISO MP4/M4A&quot;;
14181 
14182   GST_LOG_OBJECT (qtdemux, &quot;mapped %&quot; GST_FOURCC_FORMAT &quot; to &#39;%s&#39;&quot;,
14183       GST_FOURCC_ARGS (qtdemux-&gt;major_brand), fmt);
14184 
14185   gst_tag_list_add (tags, GST_TAG_MERGE_REPLACE, GST_TAG_CONTAINER_FORMAT,
14186       fmt, NULL);
14187 
14188   return tags;
14189 }
14190 
14191 /* we have read the complete moov node now.
14192  * This function parses all of the relevant info, creates the traks and
14193  * prepares all data structures for playback
14194  */
14195 static gboolean
14196 qtdemux_parse_tree (GstQTDemux * qtdemux)
14197 {
14198   GNode *mvhd;
14199   GNode *trak;
14200   GNode *udta;
14201   GNode *mvex;
<a name="630" id="anc630"></a>
14202   GNode *pssh;
14203   guint64 creation_time;
14204   GstDateTime *datetime = NULL;
14205   gint version;
14206 
14207   /* make sure we have a usable taglist */
<a name="631" id="anc631"></a><span class="line-modified">14208   qtdemux-&gt;tag_list = gst_tag_list_make_writable (qtdemux-&gt;tag_list);</span>
14209 
14210   mvhd = qtdemux_tree_get_child_by_type (qtdemux-&gt;moov_node, FOURCC_mvhd);
14211   if (mvhd == NULL) {
14212     GST_LOG_OBJECT (qtdemux, &quot;No mvhd node found, looking for redirects.&quot;);
14213     return qtdemux_parse_redirects (qtdemux);
14214   }
14215 
14216   version = QT_UINT8 ((guint8 *) mvhd-&gt;data + 8);
14217   if (version == 1) {
14218     creation_time = QT_UINT64 ((guint8 *) mvhd-&gt;data + 12);
14219     qtdemux-&gt;timescale = QT_UINT32 ((guint8 *) mvhd-&gt;data + 28);
14220     qtdemux-&gt;duration = QT_UINT64 ((guint8 *) mvhd-&gt;data + 32);
14221   } else if (version == 0) {
14222     creation_time = QT_UINT32 ((guint8 *) mvhd-&gt;data + 12);
14223     qtdemux-&gt;timescale = QT_UINT32 ((guint8 *) mvhd-&gt;data + 20);
14224     qtdemux-&gt;duration = QT_UINT32 ((guint8 *) mvhd-&gt;data + 24);
14225   } else {
14226     GST_WARNING_OBJECT (qtdemux, &quot;Unhandled mvhd version %d&quot;, version);
14227     return FALSE;
14228   }
14229 
14230   /* Moving qt creation time (secs since 1904) to unix time */
14231   if (creation_time != 0) {
14232     /* Try to use epoch first as it should be faster and more commonly found */
14233     if (creation_time &gt;= QTDEMUX_SECONDS_FROM_1904_TO_1970) {
14234       GTimeVal now;
14235 
14236       creation_time -= QTDEMUX_SECONDS_FROM_1904_TO_1970;
14237       /* some data cleansing sanity */
14238       g_get_current_time (&amp;now);
14239       if (now.tv_sec + 24 * 3600 &lt; creation_time) {
14240         GST_DEBUG_OBJECT (qtdemux, &quot;discarding bogus future creation time&quot;);
<a name="632" id="anc632"></a><span class="line-modified">14241       } else {</span>
14242         datetime = gst_date_time_new_from_unix_epoch_utc (creation_time);
<a name="633" id="anc633"></a><span class="line-modified">14243       }</span>
14244     } else {
14245       GDateTime *base_dt = g_date_time_new_utc (1904, 1, 1, 0, 0, 0);
14246       GDateTime *dt, *dt_local;
14247 
14248       dt = g_date_time_add_seconds (base_dt, creation_time);
14249       dt_local = g_date_time_to_local (dt);
14250       datetime = gst_date_time_new_from_g_date_time (dt_local);
14251 
14252       g_date_time_unref (base_dt);
14253       g_date_time_unref (dt);
<a name="634" id="anc634"></a><span class="line-modified">14254     }</span>
14255   }
14256   if (datetime) {
14257     /* Use KEEP as explicit tags should have a higher priority than mvhd tag */
14258     gst_tag_list_add (qtdemux-&gt;tag_list, GST_TAG_MERGE_KEEP, GST_TAG_DATE_TIME,
14259         datetime, NULL);
14260     gst_date_time_unref (datetime);
14261   }
14262 
14263   GST_INFO_OBJECT (qtdemux, &quot;timescale: %u&quot;, qtdemux-&gt;timescale);
14264   GST_INFO_OBJECT (qtdemux, &quot;duration: %&quot; G_GUINT64_FORMAT, qtdemux-&gt;duration);
14265 
14266   /* check for fragmented file and get some (default) data */
14267   mvex = qtdemux_tree_get_child_by_type (qtdemux-&gt;moov_node, FOURCC_mvex);
14268   if (mvex) {
14269     GNode *mehd;
14270     GstByteReader mehd_data;
14271 
14272     /* let track parsing or anyone know weird stuff might happen ... */
14273     qtdemux-&gt;fragmented = TRUE;
14274 
14275     /* compensate for total duration */
14276     mehd = qtdemux_tree_get_child_by_type_full (mvex, FOURCC_mehd, &amp;mehd_data);
14277     if (mehd)
14278       qtdemux_parse_mehd (qtdemux, &amp;mehd_data);
14279   }
14280 
<a name="635" id="anc635"></a><span class="line-modified">14281   /* Update the movie segment duration, unless it was directly given to us</span>
<span class="line-modified">14282    * by upstream. Otherwise let it as is, as we don&#39;t want to mangle the</span>
<span class="line-modified">14283    * duration provided by upstream that may come e.g. from a MPD file. */</span>
<span class="line-added">14284   if (!qtdemux-&gt;upstream_format_is_time) {</span>
<span class="line-added">14285     GstClockTime duration;</span>
<span class="line-added">14286     /* set duration in the segment info */</span>
<span class="line-added">14287     gst_qtdemux_get_duration (qtdemux, &amp;duration);</span>
14288     qtdemux-&gt;segment.duration = duration;
14289     /* also do not exceed duration; stop is set that way post seek anyway,
14290      * and segment activation falls back to duration,
14291      * whereas loop only checks stop, so let&#39;s align this here as well */
14292     qtdemux-&gt;segment.stop = duration;
14293   }
14294 
14295   /* parse all traks */
14296   trak = qtdemux_tree_get_child_by_type (qtdemux-&gt;moov_node, FOURCC_trak);
14297   while (trak) {
14298 #ifdef GSTREAMER_LITE
14299       if (!qtdemux_parse_trak (qtdemux, trak))
14300         return FALSE;
14301 #else
14302     qtdemux_parse_trak (qtdemux, trak);
14303 #endif // GSTREAMER_LITE
14304     /* iterate all siblings */
14305     trak = qtdemux_tree_get_sibling_by_type (trak, FOURCC_trak);
14306   }
14307 
14308   qtdemux-&gt;tag_list = gst_tag_list_make_writable (qtdemux-&gt;tag_list);
14309 
14310   /* find tags */
14311   udta = qtdemux_tree_get_child_by_type (qtdemux-&gt;moov_node, FOURCC_udta);
14312   if (udta) {
14313     qtdemux_parse_udta (qtdemux, qtdemux-&gt;tag_list, udta);
14314   } else {
14315     GST_LOG_OBJECT (qtdemux, &quot;No udta node found.&quot;);
14316   }
14317 
14318   /* maybe also some tags in meta box */
14319   udta = qtdemux_tree_get_child_by_type (qtdemux-&gt;moov_node, FOURCC_meta);
14320   if (udta) {
14321     GST_DEBUG_OBJECT (qtdemux, &quot;Parsing meta box for tags.&quot;);
14322     qtdemux_parse_udta (qtdemux, qtdemux-&gt;tag_list, udta);
14323   } else {
14324     GST_LOG_OBJECT (qtdemux, &quot;No meta node found.&quot;);
14325   }
14326 
14327   /* parse any protection system info */
14328   pssh = qtdemux_tree_get_child_by_type (qtdemux-&gt;moov_node, FOURCC_pssh);
14329   while (pssh) {
14330     GST_LOG_OBJECT (qtdemux, &quot;Parsing pssh box.&quot;);
14331     qtdemux_parse_pssh (qtdemux, pssh);
14332     pssh = qtdemux_tree_get_sibling_by_type (pssh, FOURCC_pssh);
14333   }
14334 
14335   qtdemux-&gt;tag_list = qtdemux_add_container_format (qtdemux, qtdemux-&gt;tag_list);
14336 
14337   return TRUE;
14338 }
14339 
14340 /* taken from ffmpeg */
14341 static int
14342 read_descr_size (guint8 * ptr, guint8 * end, guint8 ** end_out)
14343 {
14344   int count = 4;
14345   int len = 0;
14346 
14347   while (count--) {
14348     int c;
14349 
14350     if (ptr &gt;= end)
14351       return -1;
14352 
14353     c = *ptr++;
14354     len = (len &lt;&lt; 7) | (c &amp; 0x7f);
14355     if (!(c &amp; 0x80))
14356       break;
14357   }
14358   *end_out = ptr;
14359   return len;
14360 }
14361 
<a name="636" id="anc636"></a><span class="line-added">14362 static GList *</span>
<span class="line-added">14363 parse_xiph_stream_headers (GstQTDemux * qtdemux, gpointer codec_data,</span>
<span class="line-added">14364     gsize codec_data_size)</span>
<span class="line-added">14365 {</span>
<span class="line-added">14366   GList *list = NULL;</span>
<span class="line-added">14367   guint8 *p = codec_data;</span>
<span class="line-added">14368   gint i, offset, num_packets;</span>
<span class="line-added">14369   guint *length, last;</span>
<span class="line-added">14370 </span>
<span class="line-added">14371   GST_MEMDUMP_OBJECT (qtdemux, &quot;xiph codec data&quot;, codec_data, codec_data_size);</span>
<span class="line-added">14372 </span>
<span class="line-added">14373   if (codec_data == NULL || codec_data_size == 0)</span>
<span class="line-added">14374     goto error;</span>
<span class="line-added">14375 </span>
<span class="line-added">14376   /* start of the stream and vorbis audio or theora video, need to</span>
<span class="line-added">14377    * send the codec_priv data as first three packets */</span>
<span class="line-added">14378   num_packets = p[0] + 1;</span>
<span class="line-added">14379   GST_DEBUG_OBJECT (qtdemux,</span>
<span class="line-added">14380       &quot;%u stream headers, total length=%&quot; G_GSIZE_FORMAT &quot; bytes&quot;,</span>
<span class="line-added">14381       (guint) num_packets, codec_data_size);</span>
<span class="line-added">14382 </span>
<span class="line-added">14383   /* Let&#39;s put some limits, Don&#39;t think there even is a xiph codec</span>
<span class="line-added">14384    * with more than 3-4 headers */</span>
<span class="line-added">14385   if (G_UNLIKELY (num_packets &gt; 16)) {</span>
<span class="line-added">14386     GST_WARNING_OBJECT (qtdemux,</span>
<span class="line-added">14387         &quot;Unlikely number of xiph headers, most likely not valid&quot;);</span>
<span class="line-added">14388     goto error;</span>
<span class="line-added">14389   }</span>
<span class="line-added">14390 </span>
<span class="line-added">14391   length = g_alloca (num_packets * sizeof (guint));</span>
<span class="line-added">14392   last = 0;</span>
<span class="line-added">14393   offset = 1;</span>
<span class="line-added">14394 </span>
<span class="line-added">14395   /* first packets, read length values */</span>
<span class="line-added">14396   for (i = 0; i &lt; num_packets - 1; i++) {</span>
<span class="line-added">14397     length[i] = 0;</span>
<span class="line-added">14398     while (offset &lt; codec_data_size) {</span>
<span class="line-added">14399       length[i] += p[offset];</span>
<span class="line-added">14400       if (p[offset++] != 0xff)</span>
<span class="line-added">14401         break;</span>
<span class="line-added">14402     }</span>
<span class="line-added">14403     last += length[i];</span>
<span class="line-added">14404   }</span>
<span class="line-added">14405   if (offset + last &gt; codec_data_size)</span>
<span class="line-added">14406     goto error;</span>
<span class="line-added">14407 </span>
<span class="line-added">14408   /* last packet is the remaining size */</span>
<span class="line-added">14409   length[i] = codec_data_size - offset - last;</span>
<span class="line-added">14410 </span>
<span class="line-added">14411   for (i = 0; i &lt; num_packets; i++) {</span>
<span class="line-added">14412     GstBuffer *hdr;</span>
<span class="line-added">14413 </span>
<span class="line-added">14414     GST_DEBUG_OBJECT (qtdemux, &quot;buffer %d: %u bytes&quot;, i, (guint) length[i]);</span>
<span class="line-added">14415 </span>
<span class="line-added">14416     if (offset + length[i] &gt; codec_data_size)</span>
<span class="line-added">14417       goto error;</span>
<span class="line-added">14418 </span>
<span class="line-added">14419     hdr = gst_buffer_new_wrapped (g_memdup (p + offset, length[i]), length[i]);</span>
<span class="line-added">14420     list = g_list_append (list, hdr);</span>
<span class="line-added">14421 </span>
<span class="line-added">14422     offset += length[i];</span>
<span class="line-added">14423   }</span>
<span class="line-added">14424 </span>
<span class="line-added">14425   return list;</span>
<span class="line-added">14426 </span>
<span class="line-added">14427   /* ERRORS */</span>
<span class="line-added">14428 error:</span>
<span class="line-added">14429   {</span>
<span class="line-added">14430     if (list != NULL)</span>
<span class="line-added">14431       g_list_free_full (list, (GDestroyNotify) gst_buffer_unref);</span>
<span class="line-added">14432     return NULL;</span>
<span class="line-added">14433   }</span>
<span class="line-added">14434 </span>
<span class="line-added">14435 }</span>
<span class="line-added">14436 </span>
14437 /* this can change the codec originally present in @list */
14438 #ifdef GSTREAMER_LITE
14439 static gboolean
14440 #else
14441 static void
14442 #endif // GSTREAMER_LITE
14443 gst_qtdemux_handle_esds (GstQTDemux * qtdemux, QtDemuxStream * stream,
14444     QtDemuxStreamStsdEntry * entry, GNode * esds, GstTagList * list)
14445 {
14446   int len = QT_UINT32 (esds-&gt;data);
14447   guint8 *ptr = esds-&gt;data;
14448   guint8 *end = ptr + len;
14449   int tag;
14450   guint8 *data_ptr = NULL;
14451   int data_len = 0;
14452   guint8 object_type_id = 0;
<a name="637" id="anc637"></a><span class="line-added">14453   guint8 stream_type = 0;</span>
14454   const char *codec_name = NULL;
14455   GstCaps *caps = NULL;
14456 
14457   GST_MEMDUMP_OBJECT (qtdemux, &quot;esds&quot;, ptr, len);
14458   ptr += 8;
14459   GST_DEBUG_OBJECT (qtdemux, &quot;version/flags = %08x&quot;, QT_UINT32 (ptr));
14460   ptr += 4;
14461   while (ptr + 1 &lt; end) {
14462     tag = QT_UINT8 (ptr);
14463     GST_DEBUG_OBJECT (qtdemux, &quot;tag = %02x&quot;, tag);
14464     ptr++;
14465     len = read_descr_size (ptr, end, &amp;ptr);
14466     GST_DEBUG_OBJECT (qtdemux, &quot;len = %d&quot;, len);
14467 
14468     /* Check the stated amount of data is available for reading */
14469     if (len &lt; 0 || ptr + len &gt; end)
14470       break;
14471 
14472     switch (tag) {
14473       case ES_DESCRIPTOR_TAG:
<a name="638" id="anc638"></a><span class="line-modified">14474         GST_DEBUG_OBJECT (qtdemux, &quot;ID 0x%04x&quot;, QT_UINT16 (ptr));</span>
<span class="line-modified">14475         GST_DEBUG_OBJECT (qtdemux, &quot;priority 0x%04x&quot;, QT_UINT8 (ptr + 2));</span>
14476         ptr += 3;
14477         break;
14478       case DECODER_CONFIG_DESC_TAG:{
14479         guint max_bitrate, avg_bitrate;
14480 
14481         object_type_id = QT_UINT8 (ptr);
<a name="639" id="anc639"></a><span class="line-added">14482         stream_type = QT_UINT8 (ptr + 1) &gt;&gt; 2;</span>
14483         max_bitrate = QT_UINT32 (ptr + 5);
14484         avg_bitrate = QT_UINT32 (ptr + 9);
14485         GST_DEBUG_OBJECT (qtdemux, &quot;object_type_id %02x&quot;, object_type_id);
<a name="640" id="anc640"></a><span class="line-modified">14486         GST_DEBUG_OBJECT (qtdemux, &quot;stream_type %02x&quot;, stream_type);</span>
14487         GST_DEBUG_OBJECT (qtdemux, &quot;buffer_size_db %02x&quot;, QT_UINT24 (ptr + 2));
14488         GST_DEBUG_OBJECT (qtdemux, &quot;max bitrate %u&quot;, max_bitrate);
14489         GST_DEBUG_OBJECT (qtdemux, &quot;avg bitrate %u&quot;, avg_bitrate);
14490         if (max_bitrate &gt; 0 &amp;&amp; max_bitrate &lt; G_MAXUINT32) {
14491           gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
14492               GST_TAG_MAXIMUM_BITRATE, max_bitrate, NULL);
14493         }
14494         if (avg_bitrate &gt; 0 &amp;&amp; avg_bitrate &lt; G_MAXUINT32) {
14495           gst_tag_list_add (list, GST_TAG_MERGE_REPLACE, GST_TAG_BITRATE,
14496               avg_bitrate, NULL);
14497         }
14498         ptr += 13;
14499         break;
14500       }
14501       case DECODER_SPECIFIC_INFO_TAG:
14502         GST_MEMDUMP_OBJECT (qtdemux, &quot;data&quot;, ptr, len);
14503 #ifdef GSTREAMER_LITE
14504         if (end - len &lt; ptr)
14505             return FALSE;
14506 #endif // GSTREAMER_LITE
14507         if (object_type_id == 0xe0 &amp;&amp; len == 0x40) {
14508           guint8 *data;
14509           GstStructure *s;
14510           guint32 clut[16];
14511           gint i;
14512 
14513           GST_DEBUG_OBJECT (qtdemux,
14514               &quot;Have VOBSUB palette. Creating palette event&quot;);
14515           /* move to decConfigDescr data and read palette */
14516           data = ptr;
14517           for (i = 0; i &lt; 16; i++) {
14518             clut[i] = QT_UINT32 (data);
14519             data += 4;
14520           }
14521 
14522           s = gst_structure_new (&quot;application/x-gst-dvd&quot;, &quot;event&quot;,
14523               G_TYPE_STRING, &quot;dvd-spu-clut-change&quot;,
14524               &quot;clut00&quot;, G_TYPE_INT, clut[0], &quot;clut01&quot;, G_TYPE_INT, clut[1],
14525               &quot;clut02&quot;, G_TYPE_INT, clut[2], &quot;clut03&quot;, G_TYPE_INT, clut[3],
14526               &quot;clut04&quot;, G_TYPE_INT, clut[4], &quot;clut05&quot;, G_TYPE_INT, clut[5],
14527               &quot;clut06&quot;, G_TYPE_INT, clut[6], &quot;clut07&quot;, G_TYPE_INT, clut[7],
14528               &quot;clut08&quot;, G_TYPE_INT, clut[8], &quot;clut09&quot;, G_TYPE_INT, clut[9],
14529               &quot;clut10&quot;, G_TYPE_INT, clut[10], &quot;clut11&quot;, G_TYPE_INT, clut[11],
14530               &quot;clut12&quot;, G_TYPE_INT, clut[12], &quot;clut13&quot;, G_TYPE_INT, clut[13],
14531               &quot;clut14&quot;, G_TYPE_INT, clut[14], &quot;clut15&quot;, G_TYPE_INT, clut[15],
14532               NULL);
14533 
14534           /* store event and trigger custom processing */
14535           stream-&gt;pending_event =
14536               gst_event_new_custom (GST_EVENT_CUSTOM_DOWNSTREAM, s);
14537         } else {
14538           /* Generic codec_data handler puts it on the caps */
14539           data_ptr = ptr;
14540           data_len = len;
14541         }
14542 
14543         ptr += len;
14544         break;
14545       case SL_CONFIG_DESC_TAG:
14546         GST_DEBUG_OBJECT (qtdemux, &quot;data %02x&quot;, QT_UINT8 (ptr));
14547         ptr += 1;
14548         break;
14549       default:
14550         GST_DEBUG_OBJECT (qtdemux, &quot;Unknown/unhandled descriptor tag %02x&quot;,
14551             tag);
14552         GST_MEMDUMP_OBJECT (qtdemux, &quot;descriptor data&quot;, ptr, len);
14553         ptr += len;
14554         break;
14555     }
14556   }
14557 
14558   /* object_type_id in the esds atom in mp4a and mp4v tells us which codec is
14559    * in use, and should also be used to override some other parameters for some
14560    * codecs. */
14561   switch (object_type_id) {
14562     case 0x20:                 /* MPEG-4 */
14563       /* 4 bytes for the visual_object_sequence_start_code and 1 byte for the
14564        * profile_and_level_indication */
14565       if (data_ptr != NULL &amp;&amp; data_len &gt;= 5 &amp;&amp;
14566           GST_READ_UINT32_BE (data_ptr) == 0x000001b0) {
14567         gst_codec_utils_mpeg4video_caps_set_level_and_profile (entry-&gt;caps,
14568             data_ptr + 4, data_len - 4);
14569       }
14570       break;                    /* Nothing special needed here */
14571     case 0x21:                 /* H.264 */
14572       codec_name = &quot;H.264 / AVC&quot;;
14573       caps = gst_caps_new_simple (&quot;video/x-h264&quot;,
14574           &quot;stream-format&quot;, G_TYPE_STRING, &quot;avc&quot;,
14575           &quot;alignment&quot;, G_TYPE_STRING, &quot;au&quot;, NULL);
14576       break;
14577     case 0x40:                 /* AAC (any) */
14578     case 0x66:                 /* AAC Main */
14579     case 0x67:                 /* AAC LC */
14580     case 0x68:                 /* AAC SSR */
14581       /* Override channels and rate based on the codec_data, as it&#39;s often
14582        * wrong. */
14583       /* Only do so for basic setup without HE-AAC extension */
14584       if (data_ptr &amp;&amp; data_len == 2) {
14585         guint channels, rate;
14586 
14587         channels = gst_codec_utils_aac_get_channels (data_ptr, data_len);
14588         if (channels &gt; 0)
14589           entry-&gt;n_channels = channels;
14590 
14591         rate = gst_codec_utils_aac_get_sample_rate (data_ptr, data_len);
14592         if (rate &gt; 0)
14593           entry-&gt;rate = rate;
14594       }
14595 
14596       /* Set level and profile if possible */
14597       if (data_ptr != NULL &amp;&amp; data_len &gt;= 2) {
14598         gst_codec_utils_aac_caps_set_level_and_profile (entry-&gt;caps,
14599             data_ptr, data_len);
14600       } else {
14601         const gchar *profile_str = NULL;
14602         GstBuffer *buffer;
14603         GstMapInfo map;
14604         guint8 *codec_data;
14605         gint rate_idx, profile;
14606 
14607         /* No codec_data, let&#39;s invent something.
14608          * FIXME: This is wrong for SBR! */
14609 
14610         GST_WARNING_OBJECT (qtdemux, &quot;No codec_data for AAC available&quot;);
14611 
14612         buffer = gst_buffer_new_and_alloc (2);
14613         gst_buffer_map (buffer, &amp;map, GST_MAP_WRITE);
14614         codec_data = map.data;
14615 
14616         rate_idx =
14617             gst_codec_utils_aac_get_index_from_sample_rate (CUR_STREAM
14618             (stream)-&gt;rate);
14619 
14620         switch (object_type_id) {
14621           case 0x66:
14622             profile_str = &quot;main&quot;;
14623             profile = 0;
14624             break;
14625           case 0x67:
14626             profile_str = &quot;lc&quot;;
14627             profile = 1;
14628             break;
14629           case 0x68:
14630             profile_str = &quot;ssr&quot;;
14631             profile = 2;
14632             break;
14633           default:
14634             profile = 3;
14635             break;
<a name="641" id="anc641"></a><span class="line-modified">14636         }</span>
14637 
14638         codec_data[0] = ((profile + 1) &lt;&lt; 3) | ((rate_idx &amp; 0xE) &gt;&gt; 1);
14639         codec_data[1] =
14640             ((rate_idx &amp; 0x1) &lt;&lt; 7) | (CUR_STREAM (stream)-&gt;n_channels &lt;&lt; 3);
14641 
14642         gst_buffer_unmap (buffer, &amp;map);
14643         gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;codec_data&quot;,
14644             GST_TYPE_BUFFER, buffer, NULL);
14645         gst_buffer_unref (buffer);
14646 
14647         if (profile_str) {
14648           gst_caps_set_simple (CUR_STREAM (stream)-&gt;caps, &quot;profile&quot;,
14649               G_TYPE_STRING, profile_str, NULL);
14650         }
14651       }
14652       break;
14653     case 0x60:                 /* MPEG-2, various profiles */
14654     case 0x61:
14655     case 0x62:
14656     case 0x63:
14657     case 0x64:
14658     case 0x65:
14659       codec_name = &quot;MPEG-2 video&quot;;
14660       caps = gst_caps_new_simple (&quot;video/mpeg&quot;,
14661           &quot;mpegversion&quot;, G_TYPE_INT, 2,
14662           &quot;systemstream&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
14663       break;
14664     case 0x69:                 /* MPEG-2 BC audio */
14665     case 0x6B:                 /* MPEG-1 audio */
14666       caps = gst_caps_new_simple (&quot;audio/mpeg&quot;,
14667           &quot;mpegversion&quot;, G_TYPE_INT, 1, NULL);
14668       codec_name = &quot;MPEG-1 audio&quot;;
14669       break;
14670     case 0x6A:                 /* MPEG-1 */
14671       codec_name = &quot;MPEG-1 video&quot;;
14672       caps = gst_caps_new_simple (&quot;video/mpeg&quot;,
14673           &quot;mpegversion&quot;, G_TYPE_INT, 1,
14674           &quot;systemstream&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
14675       break;
14676     case 0x6C:                 /* MJPEG */
14677       caps =
14678           gst_caps_new_simple (&quot;image/jpeg&quot;, &quot;parsed&quot;, G_TYPE_BOOLEAN, TRUE,
14679           NULL);
14680       codec_name = &quot;Motion-JPEG&quot;;
14681       break;
14682     case 0x6D:                 /* PNG */
14683       caps =
14684           gst_caps_new_simple (&quot;image/png&quot;, &quot;parsed&quot;, G_TYPE_BOOLEAN, TRUE,
14685           NULL);
14686       codec_name = &quot;PNG still images&quot;;
14687       break;
14688     case 0x6E:                 /* JPEG2000 */
14689       codec_name = &quot;JPEG-2000&quot;;
14690       caps = gst_caps_new_simple (&quot;image/x-j2c&quot;, &quot;fields&quot;, G_TYPE_INT, 1, NULL);
14691       break;
14692     case 0xA4:                 /* Dirac */
14693       codec_name = &quot;Dirac&quot;;
14694       caps = gst_caps_new_empty_simple (&quot;video/x-dirac&quot;);
14695       break;
14696     case 0xA5:                 /* AC3 */
14697       codec_name = &quot;AC-3 audio&quot;;
14698       caps = gst_caps_new_simple (&quot;audio/x-ac3&quot;,
14699           &quot;framed&quot;, G_TYPE_BOOLEAN, TRUE, NULL);
14700       break;
14701     case 0xA9:                 /* AC3 */
14702       codec_name = &quot;DTS audio&quot;;
14703       caps = gst_caps_new_simple (&quot;audio/x-dts&quot;,
14704           &quot;framed&quot;, G_TYPE_BOOLEAN, TRUE, NULL);
14705       break;
<a name="642" id="anc642"></a><span class="line-added">14706     case 0xDD:</span>
<span class="line-added">14707       if (stream_type == 0x05 &amp;&amp; data_ptr) {</span>
<span class="line-added">14708         GList *headers =</span>
<span class="line-added">14709             parse_xiph_stream_headers (qtdemux, data_ptr, data_len);</span>
<span class="line-added">14710         if (headers) {</span>
<span class="line-added">14711           GList *tmp;</span>
<span class="line-added">14712           GValue arr_val = G_VALUE_INIT;</span>
<span class="line-added">14713           GValue buf_val = G_VALUE_INIT;</span>
<span class="line-added">14714           GstStructure *s;</span>
<span class="line-added">14715 </span>
<span class="line-added">14716           /* Let&#39;s assume it&#39;s vorbis if it&#39;s an audio stream of type 0xdd and we have codec data that extracts properly */</span>
<span class="line-added">14717           codec_name = &quot;Vorbis&quot;;</span>
<span class="line-added">14718           caps = gst_caps_new_empty_simple (&quot;audio/x-vorbis&quot;);</span>
<span class="line-added">14719           g_value_init (&amp;arr_val, GST_TYPE_ARRAY);</span>
<span class="line-added">14720           g_value_init (&amp;buf_val, GST_TYPE_BUFFER);</span>
<span class="line-added">14721           for (tmp = headers; tmp; tmp = tmp-&gt;next) {</span>
<span class="line-added">14722             g_value_set_boxed (&amp;buf_val, (GstBuffer *) tmp-&gt;data);</span>
<span class="line-added">14723             gst_value_array_append_value (&amp;arr_val, &amp;buf_val);</span>
<span class="line-added">14724           }</span>
<span class="line-added">14725           s = gst_caps_get_structure (caps, 0);</span>
<span class="line-added">14726           gst_structure_take_value (s, &quot;streamheader&quot;, &amp;arr_val);</span>
<span class="line-added">14727           g_value_unset (&amp;buf_val);</span>
<span class="line-added">14728           g_list_free (headers);</span>
<span class="line-added">14729 </span>
<span class="line-added">14730           data_ptr = NULL;</span>
<span class="line-added">14731           data_len = 0;</span>
<span class="line-added">14732         }</span>
<span class="line-added">14733       }</span>
<span class="line-added">14734       break;</span>
14735     case 0xE1:                 /* QCELP */
14736       /* QCELP, the codec_data is a riff tag (little endian) with
14737        * more info (http://ftp.3gpp2.org/TSGC/Working/2003/2003-05-SanDiego/TSG-C-2003-05-San%20Diego/WG1/SWG12/C12-20030512-006%20=%20C12-20030217-015_Draft_Baseline%20Text%20of%20FFMS_R2.doc). */
14738       caps = gst_caps_new_empty_simple (&quot;audio/qcelp&quot;);
14739       codec_name = &quot;QCELP&quot;;
14740       break;
14741     default:
14742       break;
14743   }
14744 
14745   /* If we have a replacement caps, then change our caps for this stream */
14746   if (caps) {
14747     gst_caps_unref (entry-&gt;caps);
14748     entry-&gt;caps = caps;
14749   }
14750 
14751   if (codec_name &amp;&amp; list)
14752     gst_tag_list_add (list, GST_TAG_MERGE_REPLACE,
14753         GST_TAG_AUDIO_CODEC, codec_name, NULL);
14754 
14755   /* Add the codec_data attribute to caps, if we have it */
14756   if (data_ptr) {
14757     GstBuffer *buffer;
14758 
14759     buffer = gst_buffer_new_and_alloc (data_len);
14760     gst_buffer_fill (buffer, 0, data_ptr, data_len);
14761 
14762     GST_DEBUG_OBJECT (qtdemux, &quot;setting codec_data from esds&quot;);
14763     GST_MEMDUMP_OBJECT (qtdemux, &quot;codec_data from esds&quot;, data_ptr, data_len);
14764 
14765     gst_caps_set_simple (entry-&gt;caps, &quot;codec_data&quot;, GST_TYPE_BUFFER,
14766         buffer, NULL);
14767     gst_buffer_unref (buffer);
14768 
14769 #if defined(GSTREAMER_LITE) &amp;&amp; defined(OSX)
14770       switch (object_type_id) {
14771           case 0x40:                 /* AAC (any) */
14772           case 0x66:                 /* AAC Main */
14773           case 0x67:                 /* AAC LC */
14774           case 0x68:                 /* AAC SSR */
14775           {
14776               GstMapInfo info;
14777               int esds_len = QT_UINT32 (esds-&gt;data);
14778               GstBuffer* esds_buffer = gst_buffer_new_allocate (NULL, esds_len, NULL);
14779               if (esds_buffer)
14780               {
14781                   if (gst_buffer_map(esds_buffer, &amp;info, GST_MAP_WRITE))
14782                   {
14783                       memcpy (info.data, esds-&gt;data, esds_len);
14784                       gst_buffer_unmap(esds_buffer, &amp;info);
14785 
14786                       GST_DEBUG_OBJECT (qtdemux, &quot;setting esds_data from esds&quot;);
14787                       GST_MEMDUMP_OBJECT (qtdemux, &quot;esds_data from esds&quot;, esds-&gt;data, esds_len);
14788 
14789                       gst_caps_set_simple (entry-&gt;caps, &quot;esds_data&quot;, GST_TYPE_BUFFER,
14790                                    esds_buffer, NULL);
14791                   }
14792 
14793                   gst_buffer_unref (esds_buffer);
<a name="643" id="anc643"></a><span class="line-modified">14794                }</span>
14795           }
14796               break;
14797           default:
14798               break;
14799       }
<a name="644" id="anc644"></a><span class="line-modified">14800 #endif // GSTREAMER_LITE</span>
14801 
14802   }
14803 
14804 #ifdef GSTREAMER_LITE
14805     return TRUE;
14806 #endif
14807 }
14808 
14809 static inline GstCaps *
14810 _get_unknown_codec_name (const gchar * type, guint32 fourcc)
14811 {
14812   GstCaps *caps;
14813   guint i;
14814   char *s, fourstr[5];
14815 
14816   g_snprintf (fourstr, 5, &quot;%&quot; GST_FOURCC_FORMAT, GST_FOURCC_ARGS (fourcc));
14817   for (i = 0; i &lt; 4; i++) {
14818     if (!g_ascii_isalnum (fourstr[i]))
14819       fourstr[i] = &#39;_&#39;;
14820   }
14821   s = g_strdup_printf (&quot;%s/x-gst-fourcc-%s&quot;, type, g_strstrip (fourstr));
14822   caps = gst_caps_new_empty_simple (s);
14823   g_free (s);
14824   return caps;
14825 }
14826 
14827 #define _codec(name) \
14828   do { \
14829     if (codec_name) { \
14830       *codec_name = g_strdup (name); \
14831     } \
14832   } while (0)
14833 
14834 static GstCaps *
14835 qtdemux_video_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
14836     QtDemuxStreamStsdEntry * entry, guint32 fourcc,
14837     const guint8 * stsd_entry_data, gchar ** codec_name)
14838 {
14839   GstCaps *caps = NULL;
14840   GstVideoFormat format = GST_VIDEO_FORMAT_UNKNOWN;
14841 
14842   switch (fourcc) {
14843     case FOURCC_png:
14844       _codec (&quot;PNG still images&quot;);
14845       caps = gst_caps_new_empty_simple (&quot;image/png&quot;);
14846       break;
14847     case FOURCC_jpeg:
14848       _codec (&quot;JPEG still images&quot;);
14849       caps =
14850           gst_caps_new_simple (&quot;image/jpeg&quot;, &quot;parsed&quot;, G_TYPE_BOOLEAN, TRUE,
14851           NULL);
14852       break;
14853     case GST_MAKE_FOURCC (&#39;m&#39;, &#39;j&#39;, &#39;p&#39;, &#39;a&#39;):
14854     case GST_MAKE_FOURCC (&#39;A&#39;, &#39;V&#39;, &#39;D&#39;, &#39;J&#39;):
14855     case GST_MAKE_FOURCC (&#39;M&#39;, &#39;J&#39;, &#39;P&#39;, &#39;G&#39;):
14856     case GST_MAKE_FOURCC (&#39;d&#39;, &#39;m&#39;, &#39;b&#39;, &#39;1&#39;):
14857       _codec (&quot;Motion-JPEG&quot;);
14858       caps =
14859           gst_caps_new_simple (&quot;image/jpeg&quot;, &quot;parsed&quot;, G_TYPE_BOOLEAN, TRUE,
14860           NULL);
14861       break;
14862     case GST_MAKE_FOURCC (&#39;m&#39;, &#39;j&#39;, &#39;p&#39;, &#39;b&#39;):
14863       _codec (&quot;Motion-JPEG format B&quot;);
14864       caps = gst_caps_new_empty_simple (&quot;video/x-mjpeg-b&quot;);
14865       break;
14866     case FOURCC_mjp2:
14867       _codec (&quot;JPEG-2000&quot;);
14868       /* override to what it should be according to spec, avoid palette_data */
14869       entry-&gt;bits_per_sample = 24;
14870       caps = gst_caps_new_simple (&quot;image/x-j2c&quot;, &quot;fields&quot;, G_TYPE_INT, 1, NULL);
14871       break;
14872     case FOURCC_SVQ3:
14873       _codec (&quot;Sorensen video v.3&quot;);
14874       caps = gst_caps_new_simple (&quot;video/x-svq&quot;,
14875           &quot;svqversion&quot;, G_TYPE_INT, 3, NULL);
14876       break;
14877     case GST_MAKE_FOURCC (&#39;s&#39;, &#39;v&#39;, &#39;q&#39;, &#39;i&#39;):
14878     case GST_MAKE_FOURCC (&#39;S&#39;, &#39;V&#39;, &#39;Q&#39;, &#39;1&#39;):
14879       _codec (&quot;Sorensen video v.1&quot;);
14880       caps = gst_caps_new_simple (&quot;video/x-svq&quot;,
14881           &quot;svqversion&quot;, G_TYPE_INT, 1, NULL);
14882       break;
14883     case GST_MAKE_FOURCC (&#39;W&#39;, &#39;R&#39;, &#39;A&#39;, &#39;W&#39;):
14884       caps = gst_caps_new_empty_simple (&quot;video/x-raw&quot;);
14885       gst_caps_set_simple (caps, &quot;format&quot;, G_TYPE_STRING, &quot;RGB8P&quot;, NULL);
14886       _codec (&quot;Windows Raw RGB&quot;);
14887       stream-&gt;alignment = 32;
14888       break;
14889     case FOURCC_raw_:
14890     {
14891       guint16 bps;
14892 
14893       bps = QT_UINT16 (stsd_entry_data + 82);
14894       switch (bps) {
14895         case 15:
14896           format = GST_VIDEO_FORMAT_RGB15;
14897           break;
14898         case 16:
14899           format = GST_VIDEO_FORMAT_RGB16;
14900           break;
14901         case 24:
14902           format = GST_VIDEO_FORMAT_RGB;
14903           break;
14904         case 32:
14905           format = GST_VIDEO_FORMAT_ARGB;
14906           break;
14907         default:
14908           /* unknown */
14909           break;
14910       }
14911       break;
14912     }
14913     case GST_MAKE_FOURCC (&#39;y&#39;, &#39;v&#39;, &#39;1&#39;, &#39;2&#39;):
14914       format = GST_VIDEO_FORMAT_I420;
14915       break;
14916     case GST_MAKE_FOURCC (&#39;y&#39;, &#39;u&#39;, &#39;v&#39;, &#39;2&#39;):
14917     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;u&#39;, &#39;v&#39;, &#39;2&#39;):
14918       format = GST_VIDEO_FORMAT_I420;
14919       break;
14920     case FOURCC_2vuy:
14921     case GST_MAKE_FOURCC (&#39;2&#39;, &#39;V&#39;, &#39;u&#39;, &#39;y&#39;):
14922       format = GST_VIDEO_FORMAT_UYVY;
14923       break;
14924     case GST_MAKE_FOURCC (&#39;v&#39;, &#39;3&#39;, &#39;0&#39;, &#39;8&#39;):
14925       format = GST_VIDEO_FORMAT_v308;
14926       break;
14927     case GST_MAKE_FOURCC (&#39;v&#39;, &#39;2&#39;, &#39;1&#39;, &#39;6&#39;):
14928       format = GST_VIDEO_FORMAT_v216;
14929       break;
14930     case FOURCC_v210:
14931       format = GST_VIDEO_FORMAT_v210;
14932       break;
14933     case GST_MAKE_FOURCC (&#39;r&#39;, &#39;2&#39;, &#39;1&#39;, &#39;0&#39;):
14934       format = GST_VIDEO_FORMAT_r210;
14935       break;
14936       /* Packed YUV 4:4:4 10 bit in 32 bits, complex
14937          case GST_MAKE_FOURCC (&#39;v&#39;, &#39;4&#39;, &#39;1&#39;, &#39;0&#39;):
14938          format = GST_VIDEO_FORMAT_v410;
14939          break;
14940        */
14941       /* Packed YUV 4:4:4:4 8 bit in 32 bits
14942        * but different order than AYUV
14943        case GST_MAKE_FOURCC (&#39;v&#39;, &#39;4&#39;, &#39;0&#39;, &#39;8&#39;):
14944        format = GST_VIDEO_FORMAT_v408;
14945        break;
14946        */
14947     case GST_MAKE_FOURCC (&#39;m&#39;, &#39;p&#39;, &#39;e&#39;, &#39;g&#39;):
14948     case GST_MAKE_FOURCC (&#39;m&#39;, &#39;p&#39;, &#39;g&#39;, &#39;1&#39;):
14949       _codec (&quot;MPEG-1 video&quot;);
14950       caps = gst_caps_new_simple (&quot;video/mpeg&quot;, &quot;mpegversion&quot;, G_TYPE_INT, 1,
14951           &quot;systemstream&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
14952       break;
14953     case GST_MAKE_FOURCC (&#39;h&#39;, &#39;d&#39;, &#39;v&#39;, &#39;1&#39;): /* HDV 720p30 */
14954     case GST_MAKE_FOURCC (&#39;h&#39;, &#39;d&#39;, &#39;v&#39;, &#39;2&#39;): /* HDV 1080i60 */
14955     case GST_MAKE_FOURCC (&#39;h&#39;, &#39;d&#39;, &#39;v&#39;, &#39;3&#39;): /* HDV 1080i50 */
14956     case GST_MAKE_FOURCC (&#39;h&#39;, &#39;d&#39;, &#39;v&#39;, &#39;4&#39;): /* HDV 720p24 */
14957     case GST_MAKE_FOURCC (&#39;h&#39;, &#39;d&#39;, &#39;v&#39;, &#39;5&#39;): /* HDV 720p25 */
14958     case GST_MAKE_FOURCC (&#39;h&#39;, &#39;d&#39;, &#39;v&#39;, &#39;6&#39;): /* HDV 1080p24 */
14959     case GST_MAKE_FOURCC (&#39;h&#39;, &#39;d&#39;, &#39;v&#39;, &#39;7&#39;): /* HDV 1080p25 */
14960     case GST_MAKE_FOURCC (&#39;h&#39;, &#39;d&#39;, &#39;v&#39;, &#39;8&#39;): /* HDV 1080p30 */
14961     case GST_MAKE_FOURCC (&#39;h&#39;, &#39;d&#39;, &#39;v&#39;, &#39;9&#39;): /* HDV 720p60 */
14962     case GST_MAKE_FOURCC (&#39;h&#39;, &#39;d&#39;, &#39;v&#39;, &#39;a&#39;): /* HDV 720p50 */
14963     case GST_MAKE_FOURCC (&#39;m&#39;, &#39;x&#39;, &#39;5&#39;, &#39;n&#39;): /* MPEG2 IMX NTSC 525/60 50mb/s produced by FCP */
14964     case GST_MAKE_FOURCC (&#39;m&#39;, &#39;x&#39;, &#39;5&#39;, &#39;p&#39;): /* MPEG2 IMX PAL 625/60 50mb/s produced by FCP */
14965     case GST_MAKE_FOURCC (&#39;m&#39;, &#39;x&#39;, &#39;4&#39;, &#39;n&#39;): /* MPEG2 IMX NTSC 525/60 40mb/s produced by FCP */
14966     case GST_MAKE_FOURCC (&#39;m&#39;, &#39;x&#39;, &#39;4&#39;, &#39;p&#39;): /* MPEG2 IMX PAL 625/60 40mb/s produced by FCP */
14967     case GST_MAKE_FOURCC (&#39;m&#39;, &#39;x&#39;, &#39;3&#39;, &#39;n&#39;): /* MPEG2 IMX NTSC 525/60 30mb/s produced by FCP */
14968     case GST_MAKE_FOURCC (&#39;m&#39;, &#39;x&#39;, &#39;3&#39;, &#39;p&#39;): /* MPEG2 IMX PAL 625/50 30mb/s produced by FCP */
14969     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;v&#39;, &#39;1&#39;): /* XDCAM HD 720p30 35Mb/s */
14970     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;v&#39;, &#39;2&#39;): /* XDCAM HD 1080i60 35Mb/s */
14971     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;v&#39;, &#39;3&#39;): /* XDCAM HD 1080i50 35Mb/s */
14972     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;v&#39;, &#39;4&#39;): /* XDCAM HD 720p24 35Mb/s */
14973     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;v&#39;, &#39;5&#39;): /* XDCAM HD 720p25 35Mb/s */
14974     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;v&#39;, &#39;6&#39;): /* XDCAM HD 1080p24 35Mb/s */
14975     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;v&#39;, &#39;7&#39;): /* XDCAM HD 1080p25 35Mb/s */
14976     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;v&#39;, &#39;8&#39;): /* XDCAM HD 1080p30 35Mb/s */
14977     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;v&#39;, &#39;9&#39;): /* XDCAM HD 720p60 35Mb/s */
14978     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;v&#39;, &#39;a&#39;): /* XDCAM HD 720p50 35Mb/s */
14979     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;v&#39;, &#39;b&#39;): /* XDCAM EX 1080i60 50Mb/s CBR */
14980     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;v&#39;, &#39;c&#39;): /* XDCAM EX 1080i50 50Mb/s CBR */
14981     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;v&#39;, &#39;d&#39;): /* XDCAM HD 1080p24 50Mb/s CBR */
14982     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;v&#39;, &#39;e&#39;): /* XDCAM HD 1080p25 50Mb/s CBR */
14983     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;v&#39;, &#39;f&#39;): /* XDCAM HD 1080p30 50Mb/s CBR */
14984     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;5&#39;, &#39;1&#39;): /* XDCAM HD422 720p30 50Mb/s CBR */
14985     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;5&#39;, &#39;4&#39;): /* XDCAM HD422 720p24 50Mb/s CBR */
14986     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;5&#39;, &#39;5&#39;): /* XDCAM HD422 720p25 50Mb/s CBR */
14987     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;5&#39;, &#39;9&#39;): /* XDCAM HD422 720p60 50Mb/s CBR */
14988     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;5&#39;, &#39;a&#39;): /* XDCAM HD422 720p50 50Mb/s CBR */
14989     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;5&#39;, &#39;b&#39;): /* XDCAM HD422 1080i50 50Mb/s CBR */
14990     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;5&#39;, &#39;c&#39;): /* XDCAM HD422 1080i50 50Mb/s CBR */
14991     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;5&#39;, &#39;d&#39;): /* XDCAM HD422 1080p24 50Mb/s CBR */
14992     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;5&#39;, &#39;e&#39;): /* XDCAM HD422 1080p25 50Mb/s CBR */
14993     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;5&#39;, &#39;f&#39;): /* XDCAM HD422 1080p30 50Mb/s CBR */
14994     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;h&#39;, &#39;d&#39;): /* XDCAM HD 540p */
14995     case GST_MAKE_FOURCC (&#39;x&#39;, &#39;d&#39;, &#39;h&#39;, &#39;2&#39;): /* XDCAM HD422 540p */
14996     case GST_MAKE_FOURCC (&#39;A&#39;, &#39;V&#39;, &#39;m&#39;, &#39;p&#39;): /* AVID IMX PAL */
14997     case GST_MAKE_FOURCC (&#39;m&#39;, &#39;p&#39;, &#39;g&#39;, &#39;2&#39;): /* AVID IMX PAL */
14998     case GST_MAKE_FOURCC (&#39;m&#39;, &#39;p&#39;, &#39;2&#39;, &#39;v&#39;): /* AVID IMX PAL */
14999     case GST_MAKE_FOURCC (&#39;m&#39;, &#39;2&#39;, &#39;v&#39;, &#39;1&#39;):
15000       _codec (&quot;MPEG-2 video&quot;);
15001       caps = gst_caps_new_simple (&quot;video/mpeg&quot;, &quot;mpegversion&quot;, G_TYPE_INT, 2,
15002           &quot;systemstream&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
15003       break;
15004     case GST_MAKE_FOURCC (&#39;g&#39;, &#39;i&#39;, &#39;f&#39;, &#39; &#39;):
15005       _codec (&quot;GIF still images&quot;);
15006       caps = gst_caps_new_empty_simple (&quot;image/gif&quot;);
15007       break;
15008     case FOURCC_h263:
15009     case GST_MAKE_FOURCC (&#39;H&#39;, &#39;2&#39;, &#39;6&#39;, &#39;3&#39;):
15010     case FOURCC_s263:
15011     case GST_MAKE_FOURCC (&#39;U&#39;, &#39;2&#39;, &#39;6&#39;, &#39;3&#39;):
15012       _codec (&quot;H.263&quot;);
15013       /* ffmpeg uses the height/width props, don&#39;t know why */
15014       caps = gst_caps_new_simple (&quot;video/x-h263&quot;,
15015           &quot;variant&quot;, G_TYPE_STRING, &quot;itu&quot;, NULL);
15016       break;
15017     case FOURCC_mp4v:
15018     case FOURCC_MP4V:
15019       _codec (&quot;MPEG-4 video&quot;);
15020       caps = gst_caps_new_simple (&quot;video/mpeg&quot;, &quot;mpegversion&quot;, G_TYPE_INT, 4,
15021           &quot;systemstream&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
15022       break;
15023     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;i&#39;, &#39;v&#39;, &#39;d&#39;):
15024     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;I&#39;, &#39;V&#39;, &#39;D&#39;):
15025       _codec (&quot;Microsoft MPEG-4 4.3&quot;);  /* FIXME? */
15026       caps = gst_caps_new_simple (&quot;video/x-msmpeg&quot;,
15027           &quot;msmpegversion&quot;, G_TYPE_INT, 43, NULL);
15028       break;
15029     case GST_MAKE_FOURCC (&#39;D&#39;, &#39;I&#39;, &#39;V&#39;, &#39;3&#39;):
15030       _codec (&quot;DivX 3&quot;);
15031       caps = gst_caps_new_simple (&quot;video/x-divx&quot;,
15032           &quot;divxversion&quot;, G_TYPE_INT, 3, NULL);
15033       break;
15034     case GST_MAKE_FOURCC (&#39;D&#39;, &#39;I&#39;, &#39;V&#39;, &#39;X&#39;):
15035     case GST_MAKE_FOURCC (&#39;d&#39;, &#39;i&#39;, &#39;v&#39;, &#39;x&#39;):
15036       _codec (&quot;DivX 4&quot;);
15037       caps = gst_caps_new_simple (&quot;video/x-divx&quot;,
15038           &quot;divxversion&quot;, G_TYPE_INT, 4, NULL);
15039       break;
15040     case GST_MAKE_FOURCC (&#39;D&#39;, &#39;X&#39;, &#39;5&#39;, &#39;0&#39;):
15041       _codec (&quot;DivX 5&quot;);
15042       caps = gst_caps_new_simple (&quot;video/x-divx&quot;,
15043           &quot;divxversion&quot;, G_TYPE_INT, 5, NULL);
15044       break;
15045 
15046     case GST_MAKE_FOURCC (&#39;F&#39;, &#39;F&#39;, &#39;V&#39;, &#39;1&#39;):
15047       _codec (&quot;FFV1&quot;);
15048       caps = gst_caps_new_simple (&quot;video/x-ffv&quot;,
15049           &quot;ffvversion&quot;, G_TYPE_INT, 1, NULL);
15050       break;
15051 
15052     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;I&#39;, &#39;V&#39;, &#39;1&#39;):
15053     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;I&#39;, &#39;V&#39;, &#39;2&#39;):
15054     case FOURCC_XVID:
15055     case FOURCC_xvid:
15056     case FOURCC_FMP4:
15057     case FOURCC_fmp4:
15058     case GST_MAKE_FOURCC (&#39;U&#39;, &#39;M&#39;, &#39;P&#39;, &#39;4&#39;):
15059       caps = gst_caps_new_simple (&quot;video/mpeg&quot;, &quot;mpegversion&quot;, G_TYPE_INT, 4,
15060           &quot;systemstream&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
15061       _codec (&quot;MPEG-4&quot;);
15062       break;
15063 
15064     case GST_MAKE_FOURCC (&#39;c&#39;, &#39;v&#39;, &#39;i&#39;, &#39;d&#39;):
15065       _codec (&quot;Cinepak&quot;);
15066       caps = gst_caps_new_empty_simple (&quot;video/x-cinepak&quot;);
15067       break;
15068     case GST_MAKE_FOURCC (&#39;q&#39;, &#39;d&#39;, &#39;r&#39;, &#39;w&#39;):
15069       _codec (&quot;Apple QuickDraw&quot;);
15070       caps = gst_caps_new_empty_simple (&quot;video/x-qdrw&quot;);
15071       break;
15072     case GST_MAKE_FOURCC (&#39;r&#39;, &#39;p&#39;, &#39;z&#39;, &#39;a&#39;):
15073       _codec (&quot;Apple video&quot;);
15074       caps = gst_caps_new_empty_simple (&quot;video/x-apple-video&quot;);
15075       break;
15076     case FOURCC_H264:
15077     case FOURCC_avc1:
15078       _codec (&quot;H.264 / AVC&quot;);
15079       caps = gst_caps_new_simple (&quot;video/x-h264&quot;,
15080           &quot;stream-format&quot;, G_TYPE_STRING, &quot;avc&quot;,
15081           &quot;alignment&quot;, G_TYPE_STRING, &quot;au&quot;, NULL);
15082       break;
15083     case FOURCC_avc3:
15084       _codec (&quot;H.264 / AVC&quot;);
15085       caps = gst_caps_new_simple (&quot;video/x-h264&quot;,
15086           &quot;stream-format&quot;, G_TYPE_STRING, &quot;avc3&quot;,
15087           &quot;alignment&quot;, G_TYPE_STRING, &quot;au&quot;, NULL);
15088       break;
15089     case FOURCC_H265:
15090     case FOURCC_hvc1:
15091       _codec (&quot;H.265 / HEVC&quot;);
15092       caps = gst_caps_new_simple (&quot;video/x-h265&quot;,
15093           &quot;stream-format&quot;, G_TYPE_STRING, &quot;hvc1&quot;,
15094           &quot;alignment&quot;, G_TYPE_STRING, &quot;au&quot;, NULL);
15095       break;
15096     case FOURCC_hev1:
15097       _codec (&quot;H.265 / HEVC&quot;);
15098       caps = gst_caps_new_simple (&quot;video/x-h265&quot;,
15099           &quot;stream-format&quot;, G_TYPE_STRING, &quot;hev1&quot;,
15100           &quot;alignment&quot;, G_TYPE_STRING, &quot;au&quot;, NULL);
15101       break;
15102     case FOURCC_rle_:
15103       _codec (&quot;Run-length encoding&quot;);
15104       caps = gst_caps_new_simple (&quot;video/x-rle&quot;,
15105           &quot;layout&quot;, G_TYPE_STRING, &quot;quicktime&quot;, NULL);
15106       break;
15107     case FOURCC_WRLE:
15108       _codec (&quot;Run-length encoding&quot;);
15109       caps = gst_caps_new_simple (&quot;video/x-rle&quot;,
15110           &quot;layout&quot;, G_TYPE_STRING, &quot;microsoft&quot;, NULL);
15111       break;
15112     case GST_MAKE_FOURCC (&#39;I&#39;, &#39;V&#39;, &#39;3&#39;, &#39;2&#39;):
15113     case GST_MAKE_FOURCC (&#39;i&#39;, &#39;v&#39;, &#39;3&#39;, &#39;2&#39;):
15114       _codec (&quot;Indeo Video 3&quot;);
15115       caps = gst_caps_new_simple (&quot;video/x-indeo&quot;,
15116           &quot;indeoversion&quot;, G_TYPE_INT, 3, NULL);
15117       break;
15118     case GST_MAKE_FOURCC (&#39;I&#39;, &#39;V&#39;, &#39;4&#39;, &#39;1&#39;):
15119     case GST_MAKE_FOURCC (&#39;i&#39;, &#39;v&#39;, &#39;4&#39;, &#39;1&#39;):
15120       _codec (&quot;Intel Video 4&quot;);
15121       caps = gst_caps_new_simple (&quot;video/x-indeo&quot;,
15122           &quot;indeoversion&quot;, G_TYPE_INT, 4, NULL);
15123       break;
15124     case FOURCC_dvcp:
15125     case FOURCC_dvc_:
15126     case GST_MAKE_FOURCC (&#39;d&#39;, &#39;v&#39;, &#39;s&#39;, &#39;d&#39;):
15127     case GST_MAKE_FOURCC (&#39;D&#39;, &#39;V&#39;, &#39;S&#39;, &#39;D&#39;):
15128     case GST_MAKE_FOURCC (&#39;d&#39;, &#39;v&#39;, &#39;c&#39;, &#39;s&#39;):
15129     case GST_MAKE_FOURCC (&#39;D&#39;, &#39;V&#39;, &#39;C&#39;, &#39;S&#39;):
15130     case GST_MAKE_FOURCC (&#39;d&#39;, &#39;v&#39;, &#39;2&#39;, &#39;5&#39;):
15131     case GST_MAKE_FOURCC (&#39;d&#39;, &#39;v&#39;, &#39;p&#39;, &#39;p&#39;):
15132       _codec (&quot;DV Video&quot;);
15133       caps = gst_caps_new_simple (&quot;video/x-dv&quot;, &quot;dvversion&quot;, G_TYPE_INT, 25,
15134           &quot;systemstream&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
15135       break;
15136     case FOURCC_dv5n:          /* DVCPRO50 NTSC */
15137     case FOURCC_dv5p:          /* DVCPRO50 PAL */
15138       _codec (&quot;DVCPro50 Video&quot;);
15139       caps = gst_caps_new_simple (&quot;video/x-dv&quot;, &quot;dvversion&quot;, G_TYPE_INT, 50,
15140           &quot;systemstream&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
15141       break;
15142     case GST_MAKE_FOURCC (&#39;d&#39;, &#39;v&#39;, &#39;h&#39;, &#39;5&#39;): /* DVCPRO HD 50i produced by FCP */
15143     case GST_MAKE_FOURCC (&#39;d&#39;, &#39;v&#39;, &#39;h&#39;, &#39;6&#39;): /* DVCPRO HD 60i produced by FCP */
15144       _codec (&quot;DVCProHD Video&quot;);
15145       caps = gst_caps_new_simple (&quot;video/x-dv&quot;, &quot;dvversion&quot;, G_TYPE_INT, 100,
15146           &quot;systemstream&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
15147       break;
15148     case GST_MAKE_FOURCC (&#39;s&#39;, &#39;m&#39;, &#39;c&#39;, &#39; &#39;):
15149       _codec (&quot;Apple Graphics (SMC)&quot;);
15150       caps = gst_caps_new_empty_simple (&quot;video/x-smc&quot;);
15151       break;
15152     case GST_MAKE_FOURCC (&#39;V&#39;, &#39;P&#39;, &#39;3&#39;, &#39;1&#39;):
15153       _codec (&quot;VP3&quot;);
15154       caps = gst_caps_new_empty_simple (&quot;video/x-vp3&quot;);
15155       break;
15156     case GST_MAKE_FOURCC (&#39;V&#39;, &#39;P&#39;, &#39;6&#39;, &#39;F&#39;):
15157       _codec (&quot;VP6 Flash&quot;);
15158       caps = gst_caps_new_empty_simple (&quot;video/x-vp6-flash&quot;);
15159       break;
15160     case FOURCC_XiTh:
15161       _codec (&quot;Theora&quot;);
15162       caps = gst_caps_new_empty_simple (&quot;video/x-theora&quot;);
15163       /* theora uses one byte of padding in the data stream because it does not
15164        * allow 0 sized packets while theora does */
15165       entry-&gt;padding = 1;
15166       break;
15167     case FOURCC_drac:
15168       _codec (&quot;Dirac&quot;);
15169       caps = gst_caps_new_empty_simple (&quot;video/x-dirac&quot;);
15170       break;
15171     case GST_MAKE_FOURCC (&#39;t&#39;, &#39;i&#39;, &#39;f&#39;, &#39;f&#39;):
15172       _codec (&quot;TIFF still images&quot;);
15173       caps = gst_caps_new_empty_simple (&quot;image/tiff&quot;);
15174       break;
15175     case GST_MAKE_FOURCC (&#39;i&#39;, &#39;c&#39;, &#39;o&#39;, &#39;d&#39;):
15176       _codec (&quot;Apple Intermediate Codec&quot;);
15177       caps = gst_caps_from_string (&quot;video/x-apple-intermediate-codec&quot;);
15178       break;
15179     case GST_MAKE_FOURCC (&#39;A&#39;, &#39;V&#39;, &#39;d&#39;, &#39;n&#39;):
15180       _codec (&quot;AVID DNxHD&quot;);
15181       caps = gst_caps_from_string (&quot;video/x-dnxhd&quot;);
15182       break;
15183     case FOURCC_VP80:
15184     case FOURCC_vp08:
15185       _codec (&quot;On2 VP8&quot;);
15186       caps = gst_caps_from_string (&quot;video/x-vp8&quot;);
15187       break;
15188     case FOURCC_vp09:
15189       _codec (&quot;Google VP9&quot;);
15190       caps = gst_caps_from_string (&quot;video/x-vp9&quot;);
15191       break;
15192     case FOURCC_apcs:
15193       _codec (&quot;Apple ProRes LT&quot;);
15194       caps =
15195           gst_caps_new_simple (&quot;video/x-prores&quot;, &quot;variant&quot;, G_TYPE_STRING, &quot;lt&quot;,
15196           NULL);
15197       break;
15198     case FOURCC_apch:
15199       _codec (&quot;Apple ProRes HQ&quot;);
15200       caps =
15201           gst_caps_new_simple (&quot;video/x-prores&quot;, &quot;variant&quot;, G_TYPE_STRING, &quot;hq&quot;,
15202           NULL);
15203       break;
15204     case FOURCC_apcn:
15205       _codec (&quot;Apple ProRes&quot;);
15206       caps =
15207           gst_caps_new_simple (&quot;video/x-prores&quot;, &quot;variant&quot;, G_TYPE_STRING,
15208           &quot;standard&quot;, NULL);
15209       break;
15210     case FOURCC_apco:
15211       _codec (&quot;Apple ProRes Proxy&quot;);
15212       caps =
15213           gst_caps_new_simple (&quot;video/x-prores&quot;, &quot;variant&quot;, G_TYPE_STRING,
15214           &quot;proxy&quot;, NULL);
15215       break;
15216     case FOURCC_ap4h:
15217       _codec (&quot;Apple ProRes 4444&quot;);
15218       caps =
15219           gst_caps_new_simple (&quot;video/x-prores&quot;, &quot;variant&quot;, G_TYPE_STRING,
15220           &quot;4444&quot;, NULL);
15221       break;
15222     case FOURCC_ap4x:
15223       _codec (&quot;Apple ProRes 4444 XQ&quot;);
15224       caps =
15225           gst_caps_new_simple (&quot;video/x-prores&quot;, &quot;variant&quot;, G_TYPE_STRING,
15226           &quot;4444xq&quot;, NULL);
15227       break;
15228     case FOURCC_cfhd:
15229       _codec (&quot;GoPro CineForm&quot;);
15230       caps = gst_caps_from_string (&quot;video/x-cineform&quot;);
15231       break;
15232     case FOURCC_vc_1:
15233     case FOURCC_ovc1:
15234       _codec (&quot;VC-1&quot;);
15235       caps = gst_caps_new_simple (&quot;video/x-wmv&quot;,
15236           &quot;wmvversion&quot;, G_TYPE_INT, 3, &quot;format&quot;, G_TYPE_STRING, &quot;WVC1&quot;, NULL);
15237       break;
<a name="645" id="anc645"></a><span class="line-added">15238     case FOURCC_av01:</span>
<span class="line-added">15239       _codec (&quot;AV1&quot;);</span>
<span class="line-added">15240       caps = gst_caps_new_empty_simple (&quot;video/x-av1&quot;);</span>
<span class="line-added">15241       break;</span>
15242     case GST_MAKE_FOURCC (&#39;k&#39;, &#39;p&#39;, &#39;c&#39;, &#39;d&#39;):
15243     default:
15244     {
15245       caps = _get_unknown_codec_name (&quot;video&quot;, fourcc);
15246       break;
15247     }
15248   }
15249 
15250   if (format != GST_VIDEO_FORMAT_UNKNOWN) {
15251     GstVideoInfo info;
15252 
15253     gst_video_info_init (&amp;info);
15254     gst_video_info_set_format (&amp;info, format, entry-&gt;width, entry-&gt;height);
15255 
15256     caps = gst_video_info_to_caps (&amp;info);
15257     *codec_name = gst_pb_utils_get_codec_description (caps);
15258 
<a name="646" id="anc646"></a><span class="line-modified">15259     /* enable clipping for raw video streams */</span>
15260     stream-&gt;need_clip = TRUE;
15261     stream-&gt;alignment = 32;
15262   }
15263 
15264   return caps;
15265 }
15266 
15267 static guint
15268 round_up_pow2 (guint n)
15269 {
15270   n = n - 1;
15271   n = n | (n &gt;&gt; 1);
15272   n = n | (n &gt;&gt; 2);
15273   n = n | (n &gt;&gt; 4);
15274   n = n | (n &gt;&gt; 8);
15275   n = n | (n &gt;&gt; 16);
15276   return n + 1;
15277 }
15278 
15279 static GstCaps *
15280 qtdemux_audio_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
15281     QtDemuxStreamStsdEntry * entry, guint32 fourcc, const guint8 * data,
15282     int len, gchar ** codec_name)
15283 {
15284   GstCaps *caps;
15285   const GstStructure *s;
15286   const gchar *name;
15287   gint endian = 0;
15288   GstAudioFormat format = 0;
15289   gint depth;
15290 
15291   GST_DEBUG_OBJECT (qtdemux, &quot;resolve fourcc 0x%08x&quot;, GUINT32_TO_BE (fourcc));
15292 
15293   depth = entry-&gt;bytes_per_packet * 8;
15294 
15295   switch (fourcc) {
15296     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;O&#39;, &#39;N&#39;, &#39;E&#39;):
15297     case FOURCC_raw_:
15298       /* 8-bit audio is unsigned */
15299       if (depth == 8)
15300         format = GST_AUDIO_FORMAT_U8;
15301       /* otherwise it&#39;s signed and big-endian just like &#39;twos&#39; */
15302     case FOURCC_twos:
15303       endian = G_BIG_ENDIAN;
15304       /* fall-through */
15305     case FOURCC_sowt:
15306     {
15307       gchar *str;
15308 
15309       if (!endian)
15310         endian = G_LITTLE_ENDIAN;
15311 
15312       if (!format)
<a name="647" id="anc647"></a><span class="line-modified">15313         format = gst_audio_format_build_integer (TRUE, endian, depth, depth);</span>
15314 
15315       str = g_strdup_printf (&quot;Raw %d-bit PCM audio&quot;, depth);
15316       _codec (str);
15317       g_free (str);
15318 
15319       caps = gst_caps_new_simple (&quot;audio/x-raw&quot;,
15320           &quot;format&quot;, G_TYPE_STRING, gst_audio_format_to_string (format),
15321           &quot;layout&quot;, G_TYPE_STRING, &quot;interleaved&quot;, NULL);
15322       stream-&gt;alignment = GST_ROUND_UP_8 (depth);
15323       stream-&gt;alignment = round_up_pow2 (stream-&gt;alignment);
15324       break;
15325     }
15326     case GST_MAKE_FOURCC (&#39;f&#39;, &#39;l&#39;, &#39;6&#39;, &#39;4&#39;):
15327       _codec (&quot;Raw 64-bit floating-point audio&quot;);
15328       caps = gst_caps_new_simple (&quot;audio/x-raw&quot;,
15329           &quot;format&quot;, G_TYPE_STRING, &quot;F64BE&quot;,
15330           &quot;layout&quot;, G_TYPE_STRING, &quot;interleaved&quot;, NULL);
15331       stream-&gt;alignment = 8;
15332       break;
15333     case GST_MAKE_FOURCC (&#39;f&#39;, &#39;l&#39;, &#39;3&#39;, &#39;2&#39;):
15334       _codec (&quot;Raw 32-bit floating-point audio&quot;);
15335       caps = gst_caps_new_simple (&quot;audio/x-raw&quot;,
15336           &quot;format&quot;, G_TYPE_STRING, &quot;F32BE&quot;,
15337           &quot;layout&quot;, G_TYPE_STRING, &quot;interleaved&quot;, NULL);
15338       stream-&gt;alignment = 4;
15339       break;
15340     case FOURCC_in24:
15341       _codec (&quot;Raw 24-bit PCM audio&quot;);
15342       /* we assume BIG ENDIAN, an enda box will tell us to change this to little
15343        * endian later */
15344       caps = gst_caps_new_simple (&quot;audio/x-raw&quot;,
15345           &quot;format&quot;, G_TYPE_STRING, &quot;S24BE&quot;,
15346           &quot;layout&quot;, G_TYPE_STRING, &quot;interleaved&quot;, NULL);
15347       stream-&gt;alignment = 4;
15348       break;
15349     case GST_MAKE_FOURCC (&#39;i&#39;, &#39;n&#39;, &#39;3&#39;, &#39;2&#39;):
15350       _codec (&quot;Raw 32-bit PCM audio&quot;);
15351       caps = gst_caps_new_simple (&quot;audio/x-raw&quot;,
15352           &quot;format&quot;, G_TYPE_STRING, &quot;S32BE&quot;,
15353           &quot;layout&quot;, G_TYPE_STRING, &quot;interleaved&quot;, NULL);
15354       stream-&gt;alignment = 4;
15355       break;
15356     case GST_MAKE_FOURCC (&#39;s&#39;, &#39;1&#39;, &#39;6&#39;, &#39;l&#39;):
15357       _codec (&quot;Raw 16-bit PCM audio&quot;);
15358       caps = gst_caps_new_simple (&quot;audio/x-raw&quot;,
15359           &quot;format&quot;, G_TYPE_STRING, &quot;S16LE&quot;,
15360           &quot;layout&quot;, G_TYPE_STRING, &quot;interleaved&quot;, NULL);
15361       stream-&gt;alignment = 2;
15362       break;
15363     case FOURCC_ulaw:
15364       _codec (&quot;Mu-law audio&quot;);
15365       caps = gst_caps_new_empty_simple (&quot;audio/x-mulaw&quot;);
15366       break;
15367     case FOURCC_alaw:
15368       _codec (&quot;A-law audio&quot;);
15369       caps = gst_caps_new_empty_simple (&quot;audio/x-alaw&quot;);
15370       break;
15371     case 0x0200736d:
15372     case 0x6d730002:
15373       _codec (&quot;Microsoft ADPCM&quot;);
15374       /* Microsoft ADPCM-ACM code 2 */
15375       caps = gst_caps_new_simple (&quot;audio/x-adpcm&quot;,
15376           &quot;layout&quot;, G_TYPE_STRING, &quot;microsoft&quot;, NULL);
15377       break;
15378     case 0x1100736d:
15379     case 0x6d730011:
15380       _codec (&quot;DVI/IMA ADPCM&quot;);
15381       caps = gst_caps_new_simple (&quot;audio/x-adpcm&quot;,
15382           &quot;layout&quot;, G_TYPE_STRING, &quot;dvi&quot;, NULL);
15383       break;
15384     case 0x1700736d:
15385     case 0x6d730017:
15386       _codec (&quot;DVI/Intel IMA ADPCM&quot;);
15387       /* FIXME DVI/Intel IMA ADPCM/ACM code 17 */
15388       caps = gst_caps_new_simple (&quot;audio/x-adpcm&quot;,
15389           &quot;layout&quot;, G_TYPE_STRING, &quot;quicktime&quot;, NULL);
15390       break;
15391     case 0x5500736d:
15392     case 0x6d730055:
15393       /* MPEG layer 3, CBR only (pre QT4.1) */
15394     case FOURCC__mp3:
15395       _codec (&quot;MPEG-1 layer 3&quot;);
15396       /* MPEG layer 3, CBR &amp; VBR (QT4.1 and later) */
15397       caps = gst_caps_new_simple (&quot;audio/mpeg&quot;, &quot;layer&quot;, G_TYPE_INT, 3,
15398           &quot;mpegversion&quot;, G_TYPE_INT, 1, NULL);
15399       break;
15400     case GST_MAKE_FOURCC (&#39;.&#39;, &#39;m&#39;, &#39;p&#39;, &#39;2&#39;):
15401       _codec (&quot;MPEG-1 layer 2&quot;);
15402       /* MPEG layer 2 */
15403       caps = gst_caps_new_simple (&quot;audio/mpeg&quot;, &quot;layer&quot;, G_TYPE_INT, 2,
15404           &quot;mpegversion&quot;, G_TYPE_INT, 1, NULL);
15405       break;
15406     case 0x20736d:
15407     case GST_MAKE_FOURCC (&#39;e&#39;, &#39;c&#39;, &#39;-&#39;, &#39;3&#39;):
15408       _codec (&quot;EAC-3 audio&quot;);
15409       caps = gst_caps_new_simple (&quot;audio/x-eac3&quot;,
15410           &quot;framed&quot;, G_TYPE_BOOLEAN, TRUE, NULL);
15411       entry-&gt;sampled = TRUE;
15412       break;
15413     case GST_MAKE_FOURCC (&#39;s&#39;, &#39;a&#39;, &#39;c&#39;, &#39;3&#39;): // Nero Recode
15414     case FOURCC_ac_3:
15415       _codec (&quot;AC-3 audio&quot;);
15416       caps = gst_caps_new_simple (&quot;audio/x-ac3&quot;,
15417           &quot;framed&quot;, G_TYPE_BOOLEAN, TRUE, NULL);
15418       entry-&gt;sampled = TRUE;
15419       break;
15420     case GST_MAKE_FOURCC (&#39;d&#39;, &#39;t&#39;, &#39;s&#39;, &#39;c&#39;):
15421     case GST_MAKE_FOURCC (&#39;D&#39;, &#39;T&#39;, &#39;S&#39;, &#39; &#39;):
15422       _codec (&quot;DTS audio&quot;);
15423       caps = gst_caps_new_simple (&quot;audio/x-dts&quot;,
15424           &quot;framed&quot;, G_TYPE_BOOLEAN, TRUE, NULL);
15425       entry-&gt;sampled = TRUE;
15426       break;
15427     case GST_MAKE_FOURCC (&#39;d&#39;, &#39;t&#39;, &#39;s&#39;, &#39;h&#39;): // DTS-HD
15428     case GST_MAKE_FOURCC (&#39;d&#39;, &#39;t&#39;, &#39;s&#39;, &#39;l&#39;): // DTS-HD Lossless
15429       _codec (&quot;DTS-HD audio&quot;);
15430       caps = gst_caps_new_simple (&quot;audio/x-dts&quot;,
15431           &quot;framed&quot;, G_TYPE_BOOLEAN, TRUE, NULL);
15432       entry-&gt;sampled = TRUE;
15433       break;
15434     case FOURCC_MAC3:
15435       _codec (&quot;MACE-3&quot;);
15436       caps = gst_caps_new_simple (&quot;audio/x-mace&quot;,
15437           &quot;maceversion&quot;, G_TYPE_INT, 3, NULL);
15438       break;
15439     case FOURCC_MAC6:
15440       _codec (&quot;MACE-6&quot;);
15441       caps = gst_caps_new_simple (&quot;audio/x-mace&quot;,
15442           &quot;maceversion&quot;, G_TYPE_INT, 6, NULL);
15443       break;
15444     case GST_MAKE_FOURCC (&#39;O&#39;, &#39;g&#39;, &#39;g&#39;, &#39;V&#39;):
15445       /* ogg/vorbis */
15446       caps = gst_caps_new_empty_simple (&quot;application/ogg&quot;);
15447       break;
15448     case GST_MAKE_FOURCC (&#39;d&#39;, &#39;v&#39;, &#39;c&#39;, &#39;a&#39;):
15449       _codec (&quot;DV audio&quot;);
15450       caps = gst_caps_new_empty_simple (&quot;audio/x-dv&quot;);
15451       break;
15452     case FOURCC_mp4a:
15453       _codec (&quot;MPEG-4 AAC audio&quot;);
15454       caps = gst_caps_new_simple (&quot;audio/mpeg&quot;,
15455           &quot;mpegversion&quot;, G_TYPE_INT, 4, &quot;framed&quot;, G_TYPE_BOOLEAN, TRUE,
15456           &quot;stream-format&quot;, G_TYPE_STRING, &quot;raw&quot;, NULL);
15457       break;
15458     case GST_MAKE_FOURCC (&#39;Q&#39;, &#39;D&#39;, &#39;M&#39;, &#39;C&#39;):
15459       _codec (&quot;QDesign Music&quot;);
15460       caps = gst_caps_new_empty_simple (&quot;audio/x-qdm&quot;);
15461       break;
15462     case FOURCC_QDM2:
15463       _codec (&quot;QDesign Music v.2&quot;);
15464       /* FIXME: QDesign music version 2 (no constant) */
15465       if (FALSE &amp;&amp; data) {
15466         caps = gst_caps_new_simple (&quot;audio/x-qdm2&quot;,
15467             &quot;framesize&quot;, G_TYPE_INT, QT_UINT32 (data + 52),
15468             &quot;bitrate&quot;, G_TYPE_INT, QT_UINT32 (data + 40),
15469             &quot;blocksize&quot;, G_TYPE_INT, QT_UINT32 (data + 44), NULL);
15470       } else {
15471         caps = gst_caps_new_empty_simple (&quot;audio/x-qdm2&quot;);
15472       }
15473       break;
15474     case FOURCC_agsm:
15475       _codec (&quot;GSM audio&quot;);
15476       caps = gst_caps_new_empty_simple (&quot;audio/x-gsm&quot;);
15477       break;
15478     case FOURCC_samr:
15479       _codec (&quot;AMR audio&quot;);
15480       caps = gst_caps_new_empty_simple (&quot;audio/AMR&quot;);
15481       break;
15482     case FOURCC_sawb:
15483       _codec (&quot;AMR-WB audio&quot;);
15484       caps = gst_caps_new_empty_simple (&quot;audio/AMR-WB&quot;);
15485       break;
15486     case FOURCC_ima4:
15487       _codec (&quot;Quicktime IMA ADPCM&quot;);
15488       caps = gst_caps_new_simple (&quot;audio/x-adpcm&quot;,
15489           &quot;layout&quot;, G_TYPE_STRING, &quot;quicktime&quot;, NULL);
15490       break;
15491     case FOURCC_alac:
15492       _codec (&quot;Apple lossless audio&quot;);
15493       caps = gst_caps_new_empty_simple (&quot;audio/x-alac&quot;);
15494       break;
15495     case FOURCC_fLaC:
15496       _codec (&quot;Free Lossless Audio Codec&quot;);
15497       caps = gst_caps_new_simple (&quot;audio/x-flac&quot;,
15498           &quot;framed&quot;, G_TYPE_BOOLEAN, TRUE, NULL);
15499       break;
15500     case GST_MAKE_FOURCC (&#39;Q&#39;, &#39;c&#39;, &#39;l&#39;, &#39;p&#39;):
15501       _codec (&quot;QualComm PureVoice&quot;);
15502       caps = gst_caps_from_string (&quot;audio/qcelp&quot;);
15503       break;
15504     case FOURCC_wma_:
15505     case FOURCC_owma:
15506       _codec (&quot;WMA&quot;);
15507       caps = gst_caps_new_empty_simple (&quot;audio/x-wma&quot;);
15508       break;
15509     case FOURCC_opus:
15510       _codec (&quot;Opus&quot;);
15511       caps = gst_caps_new_empty_simple (&quot;audio/x-opus&quot;);
15512       break;
15513     case FOURCC_lpcm:
15514     {
15515       guint32 flags = 0;
15516       guint32 depth = 0;
15517       guint32 width = 0;
15518       GstAudioFormat format;
15519       enum
15520       {
15521         FLAG_IS_FLOAT = 0x1,
15522         FLAG_IS_BIG_ENDIAN = 0x2,
15523         FLAG_IS_SIGNED = 0x4,
15524         FLAG_IS_PACKED = 0x8,
15525         FLAG_IS_ALIGNED_HIGH = 0x10,
15526         FLAG_IS_NON_INTERLEAVED = 0x20
15527       };
15528       _codec (&quot;Raw LPCM audio&quot;);
15529 
15530       if (data &amp;&amp; len &gt;= 36) {
15531         depth = QT_UINT32 (data + 24);
15532         flags = QT_UINT32 (data + 28);
15533         width = QT_UINT32 (data + 32) * 8 / entry-&gt;n_channels;
15534       }
15535       if ((flags &amp; FLAG_IS_FLOAT) == 0) {
15536         if (depth == 0)
15537           depth = 16;
15538         if (width == 0)
15539           width = 16;
15540         if ((flags &amp; FLAG_IS_ALIGNED_HIGH))
15541           depth = width;
15542 
15543         format = gst_audio_format_build_integer ((flags &amp; FLAG_IS_SIGNED) ?
15544             TRUE : FALSE, (flags &amp; FLAG_IS_BIG_ENDIAN) ?
15545             G_BIG_ENDIAN : G_LITTLE_ENDIAN, width, depth);
15546         caps = gst_caps_new_simple (&quot;audio/x-raw&quot;,
15547             &quot;format&quot;, G_TYPE_STRING,
15548             format !=
15549             GST_AUDIO_FORMAT_UNKNOWN ? gst_audio_format_to_string (format) :
15550             &quot;UNKNOWN&quot;, &quot;layout&quot;, G_TYPE_STRING,
15551             (flags &amp; FLAG_IS_NON_INTERLEAVED) ? &quot;non-interleaved&quot; :
15552             &quot;interleaved&quot;, NULL);
15553         stream-&gt;alignment = GST_ROUND_UP_8 (depth);
15554         stream-&gt;alignment = round_up_pow2 (stream-&gt;alignment);
15555       } else {
15556         if (width == 0)
15557           width = 32;
15558         if (width == 64) {
15559           if (flags &amp; FLAG_IS_BIG_ENDIAN)
15560             format = GST_AUDIO_FORMAT_F64BE;
15561           else
15562             format = GST_AUDIO_FORMAT_F64LE;
15563         } else {
15564           if (flags &amp; FLAG_IS_BIG_ENDIAN)
15565             format = GST_AUDIO_FORMAT_F32BE;
15566           else
15567             format = GST_AUDIO_FORMAT_F32LE;
15568         }
15569         caps = gst_caps_new_simple (&quot;audio/x-raw&quot;,
15570             &quot;format&quot;, G_TYPE_STRING, gst_audio_format_to_string (format),
15571             &quot;layout&quot;, G_TYPE_STRING, (flags &amp; FLAG_IS_NON_INTERLEAVED) ?
15572             &quot;non-interleaved&quot; : &quot;interleaved&quot;, NULL);
15573         stream-&gt;alignment = width / 8;
15574       }
15575       break;
15576     }
15577     case GST_MAKE_FOURCC (&#39;q&#39;, &#39;t&#39;, &#39;v&#39;, &#39;r&#39;):
15578       /* ? */
15579     default:
15580     {
15581       caps = _get_unknown_codec_name (&quot;audio&quot;, fourcc);
15582       break;
15583     }
15584   }
15585 
15586   if (caps) {
15587     GstCaps *templ_caps =
15588         gst_static_pad_template_get_caps (&amp;gst_qtdemux_audiosrc_template);
15589     GstCaps *intersection = gst_caps_intersect (caps, templ_caps);
15590     gst_caps_unref (caps);
15591     gst_caps_unref (templ_caps);
15592     caps = intersection;
15593   }
15594 
15595   /* enable clipping for raw audio streams */
15596   s = gst_caps_get_structure (caps, 0);
15597   name = gst_structure_get_name (s);
15598   if (g_str_has_prefix (name, &quot;audio/x-raw&quot;)) {
15599     stream-&gt;need_clip = TRUE;
15600     stream-&gt;max_buffer_size = 4096 * entry-&gt;bytes_per_frame;
15601     GST_DEBUG (&quot;setting max buffer size to %d&quot;, stream-&gt;max_buffer_size);
15602   }
15603   return caps;
15604 }
15605 
15606 static GstCaps *
15607 qtdemux_sub_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
15608     QtDemuxStreamStsdEntry * entry, guint32 fourcc,
15609     const guint8 * stsd_entry_data, gchar ** codec_name)
15610 {
15611   GstCaps *caps;
15612 
15613   GST_DEBUG_OBJECT (qtdemux, &quot;resolve fourcc 0x%08x&quot;, GUINT32_TO_BE (fourcc));
15614 
15615   switch (fourcc) {
15616     case FOURCC_mp4s:
15617       _codec (&quot;DVD subtitle&quot;);
15618       caps = gst_caps_new_empty_simple (&quot;subpicture/x-dvd&quot;);
15619       stream-&gt;need_process = TRUE;
15620       break;
15621     case FOURCC_text:
15622       _codec (&quot;Quicktime timed text&quot;);
15623       goto text;
15624     case FOURCC_tx3g:
15625       _codec (&quot;3GPP timed text&quot;);
15626     text:
15627       caps = gst_caps_new_simple (&quot;text/x-raw&quot;, &quot;format&quot;, G_TYPE_STRING,
15628           &quot;utf8&quot;, NULL);
15629       /* actual text piece needs to be extracted */
15630       stream-&gt;need_process = TRUE;
15631       break;
15632     case FOURCC_stpp:
15633       _codec (&quot;XML subtitles&quot;);
15634       caps = gst_caps_new_empty_simple (&quot;application/ttml+xml&quot;);
15635       break;
<a name="648" id="anc648"></a><span class="line-added">15636     case FOURCC_c608:</span>
<span class="line-added">15637       _codec (&quot;CEA 608 Closed Caption&quot;);</span>
<span class="line-added">15638       caps =</span>
<span class="line-added">15639           gst_caps_new_simple (&quot;closedcaption/x-cea-608&quot;, &quot;format&quot;,</span>
<span class="line-added">15640           G_TYPE_STRING, &quot;s334-1a&quot;, NULL);</span>
<span class="line-added">15641       stream-&gt;need_process = TRUE;</span>
<span class="line-added">15642       stream-&gt;need_split = TRUE;</span>
<span class="line-added">15643       break;</span>
<span class="line-added">15644     case FOURCC_c708:</span>
<span class="line-added">15645       _codec (&quot;CEA 708 Closed Caption&quot;);</span>
<span class="line-added">15646       caps =</span>
<span class="line-added">15647           gst_caps_new_simple (&quot;closedcaption/x-cea-708&quot;, &quot;format&quot;,</span>
<span class="line-added">15648           G_TYPE_STRING, &quot;cdp&quot;, NULL);</span>
<span class="line-added">15649       stream-&gt;need_process = TRUE;</span>
<span class="line-added">15650       break;</span>
<span class="line-added">15651 </span>
15652     default:
15653     {
15654       caps = _get_unknown_codec_name (&quot;text&quot;, fourcc);
15655       break;
15656     }
15657   }
15658   return caps;
15659 }
15660 
15661 static GstCaps *
15662 qtdemux_generic_caps (GstQTDemux * qtdemux, QtDemuxStream * stream,
15663     QtDemuxStreamStsdEntry * entry, guint32 fourcc,
15664     const guint8 * stsd_entry_data, gchar ** codec_name)
15665 {
15666   GstCaps *caps;
15667 
15668   switch (fourcc) {
15669     case FOURCC_m1v:
15670       _codec (&quot;MPEG 1 video&quot;);
15671       caps = gst_caps_new_simple (&quot;video/mpeg&quot;, &quot;mpegversion&quot;, G_TYPE_INT, 1,
15672           &quot;systemstream&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
15673       break;
15674     default:
15675       caps = NULL;
15676       break;
15677   }
15678   return caps;
15679 }
15680 
15681 static void
15682 gst_qtdemux_append_protection_system_id (GstQTDemux * qtdemux,
15683     const gchar * system_id)
15684 {
15685   gint i;
15686 
15687   if (!qtdemux-&gt;protection_system_ids)
15688     qtdemux-&gt;protection_system_ids =
15689         g_ptr_array_new_with_free_func ((GDestroyNotify) g_free);
15690   /* Check whether we already have an entry for this system ID. */
15691   for (i = 0; i &lt; qtdemux-&gt;protection_system_ids-&gt;len; ++i) {
15692     const gchar *id = g_ptr_array_index (qtdemux-&gt;protection_system_ids, i);
15693     if (g_ascii_strcasecmp (system_id, id) == 0) {
15694       return;
15695     }
15696   }
15697   GST_DEBUG_OBJECT (qtdemux, &quot;Adding cenc protection system ID %s&quot;, system_id);
15698   g_ptr_array_add (qtdemux-&gt;protection_system_ids, g_ascii_strdown (system_id,
15699           -1));
15700 }
<a name="649" id="anc649"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="649" type="hidden" />
</body>
</html>