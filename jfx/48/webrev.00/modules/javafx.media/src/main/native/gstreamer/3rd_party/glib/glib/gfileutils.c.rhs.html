<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gfileutils.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* gfileutils.c - File utility functions
   2  *
   3  *  Copyright 2000 Red Hat, Inc.
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public License
  16  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  */
  18 
  19 #include &quot;config.h&quot;
  20 #include &quot;glibconfig.h&quot;
  21 
  22 #include &lt;sys/stat.h&gt;
  23 #include &lt;stdio.h&gt;
  24 #include &lt;stdlib.h&gt;
  25 #include &lt;stdarg.h&gt;
  26 #include &lt;string.h&gt;
  27 #include &lt;errno.h&gt;
  28 #include &lt;sys/types.h&gt;
  29 #include &lt;sys/stat.h&gt;
  30 #include &lt;fcntl.h&gt;
  31 #include &lt;stdlib.h&gt;
  32 
  33 #ifdef G_OS_UNIX
  34 #include &lt;unistd.h&gt;
  35 #endif
  36 #ifdef G_OS_WIN32
  37 #include &lt;windows.h&gt;
  38 #include &lt;io.h&gt;
  39 #endif /* G_OS_WIN32 */
  40 
  41 #ifndef S_ISLNK
  42 #define S_ISLNK(x) 0
  43 #endif
  44 
  45 #ifndef O_BINARY
  46 #define O_BINARY 0
  47 #endif
  48 
  49 #include &quot;gfileutils.h&quot;
  50 
  51 #include &quot;gstdio.h&quot;
  52 #include &quot;gstdioprivate.h&quot;
  53 #include &quot;glibintl.h&quot;
  54 
  55 #ifdef HAVE_LINUX_MAGIC_H /* for btrfs check */
  56 #include &lt;linux/magic.h&gt;
  57 #include &lt;sys/vfs.h&gt;
  58 #endif
  59 
  60 
  61 /**
  62  * SECTION:fileutils
  63  * @title: File Utilities
  64  * @short_description: various file-related functions
  65  *
  66  * Do not use these APIs unless you are porting a POSIX application to Windows.
<a name="1" id="anc1"></a><span class="line-modified">  67  * A more high-level file access API is provided as GIO - see the documentation</span>
  68  * for #GFile.
  69  *
  70  * There is a group of functions which wrap the common POSIX functions
  71  * dealing with filenames (g_open(), g_rename(), g_mkdir(), g_stat(),
  72  * g_unlink(), g_remove(), g_fopen(), g_freopen()). The point of these
  73  * wrappers is to make it possible to handle file names with any Unicode
  74  * characters in them on Windows without having to use ifdefs and the
  75  * wide character API in the application code.
  76  *
  77  * On some Unix systems, these APIs may be defined as identical to their POSIX
  78  * counterparts. For this reason, you must check for and include the necessary
  79  * header files (such as `fcntl.h`) before using functions like g_creat(). You
  80  * must also define the relevant feature test macros.
  81  *
  82  * The pathname argument should be in the GLib file name encoding.
  83  * On POSIX this is the actual on-disk encoding which might correspond
  84  * to the locale settings of the process (or the `G_FILENAME_ENCODING`
  85  * environment variable), or not.
  86  *
  87  * On Windows the GLib file name encoding is UTF-8. Note that the
  88  * Microsoft C library does not use UTF-8, but has separate APIs for
  89  * current system code page and wide characters (UTF-16). The GLib
  90  * wrappers call the wide character API if present (on modern Windows
  91  * systems), otherwise convert to/from the system code page.
  92  *
  93  * Another group of functions allows to open and read directories
  94  * in the GLib file name encoding. These are g_dir_open(),
  95  * g_dir_read_name(), g_dir_rewind(), g_dir_close().
  96  */
  97 
  98 /**
  99  * GFileError:
 100  * @G_FILE_ERROR_EXIST: Operation not permitted; only the owner of
 101  *     the file (or other resource) or processes with special privileges
 102  *     can perform the operation.
 103  * @G_FILE_ERROR_ISDIR: File is a directory; you cannot open a directory
 104  *     for writing, or create or remove hard links to it.
 105  * @G_FILE_ERROR_ACCES: Permission denied; the file permissions do not
 106  *     allow the attempted operation.
 107  * @G_FILE_ERROR_NAMETOOLONG: Filename too long.
 108  * @G_FILE_ERROR_NOENT: No such file or directory. This is a &quot;file
 109  *     doesn&#39;t exist&quot; error for ordinary files that are referenced in
 110  *     contexts where they are expected to already exist.
 111  * @G_FILE_ERROR_NOTDIR: A file that isn&#39;t a directory was specified when
 112  *     a directory is required.
 113  * @G_FILE_ERROR_NXIO: No such device or address. The system tried to
 114  *     use the device represented by a file you specified, and it
 115  *     couldn&#39;t find the device. This can mean that the device file was
 116  *     installed incorrectly, or that the physical device is missing or
 117  *     not correctly attached to the computer.
 118  * @G_FILE_ERROR_NODEV: The underlying file system of the specified file
 119  *     does not support memory mapping.
 120  * @G_FILE_ERROR_ROFS: The directory containing the new link can&#39;t be
 121  *     modified because it&#39;s on a read-only file system.
 122  * @G_FILE_ERROR_TXTBSY: Text file busy.
 123  * @G_FILE_ERROR_FAULT: You passed in a pointer to bad memory.
 124  *     (GLib won&#39;t reliably return this, don&#39;t pass in pointers to bad
 125  *     memory.)
 126  * @G_FILE_ERROR_LOOP: Too many levels of symbolic links were encountered
 127  *     in looking up a file name. This often indicates a cycle of symbolic
 128  *     links.
 129  * @G_FILE_ERROR_NOSPC: No space left on device; write operation on a
 130  *     file failed because the disk is full.
 131  * @G_FILE_ERROR_NOMEM: No memory available. The system cannot allocate
 132  *     more virtual memory because its capacity is full.
 133  * @G_FILE_ERROR_MFILE: The current process has too many files open and
 134  *     can&#39;t open any more. Duplicate descriptors do count toward this
 135  *     limit.
 136  * @G_FILE_ERROR_NFILE: There are too many distinct file openings in the
 137  *     entire system.
 138  * @G_FILE_ERROR_BADF: Bad file descriptor; for example, I/O on a
 139  *     descriptor that has been closed or reading from a descriptor open
 140  *     only for writing (or vice versa).
 141  * @G_FILE_ERROR_INVAL: Invalid argument. This is used to indicate
 142  *     various kinds of problems with passing the wrong argument to a
 143  *     library function.
 144  * @G_FILE_ERROR_PIPE: Broken pipe; there is no process reading from the
 145  *     other end of a pipe. Every library function that returns this
 146  *     error code also generates a &#39;SIGPIPE&#39; signal; this signal
 147  *     terminates the program if not handled or blocked. Thus, your
 148  *     program will never actually see this code unless it has handled
 149  *     or blocked &#39;SIGPIPE&#39;.
 150  * @G_FILE_ERROR_AGAIN: Resource temporarily unavailable; the call might
 151  *     work if you try again later.
 152  * @G_FILE_ERROR_INTR: Interrupted function call; an asynchronous signal
 153  *     occurred and prevented completion of the call. When this
 154  *     happens, you should try the call again.
 155  * @G_FILE_ERROR_IO: Input/output error; usually used for physical read
 156  *    or write errors. i.e. the disk or other physical device hardware
 157  *    is returning errors.
 158  * @G_FILE_ERROR_PERM: Operation not permitted; only the owner of the
 159  *    file (or other resource) or processes with special privileges can
 160  *    perform the operation.
 161  * @G_FILE_ERROR_NOSYS: Function not implemented; this indicates that
 162  *    the system is missing some functionality.
 163  * @G_FILE_ERROR_FAILED: Does not correspond to a UNIX error code; this
 164  *    is the standard &quot;failed for unspecified reason&quot; error code present
 165  *    in all #GError error code enumerations. Returned if no specific
 166  *    code applies.
 167  *
 168  * Values corresponding to @errno codes returned from file operations
 169  * on UNIX. Unlike @errno codes, GFileError values are available on
 170  * all systems, even Windows. The exact meaning of each code depends
 171  * on what sort of file operation you were performing; the UNIX
 172  * documentation gives more details. The following error code descriptions
 173  * come from the GNU C Library manual, and are under the copyright
 174  * of that manual.
 175  *
 176  * It&#39;s not very portable to make detailed assumptions about exactly
 177  * which errors will be returned from a given operation. Some errors
 178  * don&#39;t occur on some systems, etc., sometimes there are subtle
 179  * differences in when a system will report a given error, etc.
 180  */
 181 
 182 /**
 183  * G_FILE_ERROR:
 184  *
 185  * Error domain for file operations. Errors in this domain will
 186  * be from the #GFileError enumeration. See #GError for information
 187  * on error domains.
 188  */
 189 
 190 /**
 191  * GFileTest:
 192  * @G_FILE_TEST_IS_REGULAR: %TRUE if the file is a regular file
 193  *     (not a directory). Note that this test will also return %TRUE
 194  *     if the tested file is a symlink to a regular file.
 195  * @G_FILE_TEST_IS_SYMLINK: %TRUE if the file is a symlink.
 196  * @G_FILE_TEST_IS_DIR: %TRUE if the file is a directory.
 197  * @G_FILE_TEST_IS_EXECUTABLE: %TRUE if the file is executable.
 198  * @G_FILE_TEST_EXISTS: %TRUE if the file exists. It may or may not
 199  *     be a regular file.
 200  *
 201  * A test to perform on a file using g_file_test().
 202  */
 203 
 204 /**
 205  * g_mkdir_with_parents:
 206  * @pathname: (type filename): a pathname in the GLib file name encoding
 207  * @mode: permissions to use for newly created directories
 208  *
 209  * Create a directory if it doesn&#39;t already exist. Create intermediate
 210  * parent directories as needed, too.
 211  *
 212  * Returns: 0 if the directory already exists, or was successfully
 213  * created. Returns -1 if an error occurred, with errno set.
 214  *
 215  * Since: 2.8
 216  */
 217 int
 218 g_mkdir_with_parents (const gchar *pathname,
<a name="2" id="anc2"></a><span class="line-modified"> 219           int          mode)</span>
 220 {
 221   gchar *fn, *p;
 222 
 223   if (pathname == NULL || *pathname == &#39;\0&#39;)
 224     {
 225       errno = EINVAL;
 226       return -1;
 227     }
 228 
<a name="3" id="anc3"></a><span class="line-added"> 229   /* try to create the full path first */</span>
<span class="line-added"> 230   if (g_mkdir (pathname, mode) == 0)</span>
<span class="line-added"> 231     return 0;</span>
<span class="line-added"> 232   else if (errno == EEXIST)</span>
<span class="line-added"> 233     {</span>
<span class="line-added"> 234       if (!g_file_test (pathname, G_FILE_TEST_IS_DIR))</span>
<span class="line-added"> 235         {</span>
<span class="line-added"> 236           errno = ENOTDIR;</span>
<span class="line-added"> 237           return -1;</span>
<span class="line-added"> 238         }</span>
<span class="line-added"> 239       return 0;</span>
<span class="line-added"> 240     }</span>
<span class="line-added"> 241 </span>
<span class="line-added"> 242   /* walk the full path and try creating each element */</span>
 243   fn = g_strdup (pathname);
 244 
 245   if (g_path_is_absolute (fn))
 246     p = (gchar *) g_path_skip_root (fn);
 247   else
 248     p = fn;
 249 
 250   do
 251     {
 252       while (*p &amp;&amp; !G_IS_DIR_SEPARATOR (*p))
<a name="4" id="anc4"></a><span class="line-modified"> 253   p++;</span>
 254 
 255       if (!*p)
<a name="5" id="anc5"></a><span class="line-modified"> 256   p = NULL;</span>
 257       else
<a name="6" id="anc6"></a><span class="line-modified"> 258   *p = &#39;\0&#39;;</span>
 259 
 260       if (!g_file_test (fn, G_FILE_TEST_EXISTS))
<a name="7" id="anc7"></a><span class="line-modified"> 261   {</span>
<span class="line-modified"> 262     if (g_mkdir (fn, mode) == -1 &amp;&amp; errno != EEXIST)</span>
<span class="line-modified"> 263       {</span>
<span class="line-modified"> 264         int errno_save = errno;</span>
<span class="line-modified"> 265         if (errno != ENOENT || !p)</span>
<span class="line-modified"> 266                 {</span>
<span class="line-modified"> 267             g_free (fn);</span>
<span class="line-modified"> 268             errno = errno_save;</span>
<span class="line-added"> 269             return -1;</span>
 270     }
<a name="8" id="anc8"></a><span class="line-added"> 271       }</span>
<span class="line-added"> 272   }</span>
 273       else if (!g_file_test (fn, G_FILE_TEST_IS_DIR))
<a name="9" id="anc9"></a><span class="line-modified"> 274   {</span>
<span class="line-modified"> 275     g_free (fn);</span>
<span class="line-modified"> 276     errno = ENOTDIR;</span>
<span class="line-modified"> 277     return -1;</span>
<span class="line-modified"> 278   }</span>
 279       if (p)
<a name="10" id="anc10"></a><span class="line-modified"> 280   {</span>
<span class="line-modified"> 281     *p++ = G_DIR_SEPARATOR;</span>
<span class="line-modified"> 282     while (*p &amp;&amp; G_IS_DIR_SEPARATOR (*p))</span>
<span class="line-modified"> 283       p++;</span>
<span class="line-modified"> 284   }</span>
 285     }
 286   while (p);
 287 
 288   g_free (fn);
 289 
 290   return 0;
 291 }
 292 
 293 /**
 294  * g_file_test:
 295  * @filename: (type filename): a filename to test in the
 296  *     GLib file name encoding
 297  * @test: bitfield of #GFileTest flags
 298  *
 299  * Returns %TRUE if any of the tests in the bitfield @test are
 300  * %TRUE. For example, `(G_FILE_TEST_EXISTS | G_FILE_TEST_IS_DIR)`
 301  * will return %TRUE if the file exists; the check whether it&#39;s a
 302  * directory doesn&#39;t matter since the existence test is %TRUE. With
 303  * the current set of available tests, there&#39;s no point passing in
 304  * more than one test at a time.
 305  *
 306  * Apart from %G_FILE_TEST_IS_SYMLINK all tests follow symbolic links,
 307  * so for a symbolic link to a regular file g_file_test() will return
 308  * %TRUE for both %G_FILE_TEST_IS_SYMLINK and %G_FILE_TEST_IS_REGULAR.
 309  *
 310  * Note, that for a dangling symbolic link g_file_test() will return
 311  * %TRUE for %G_FILE_TEST_IS_SYMLINK and %FALSE for all other flags.
 312  *
 313  * You should never use g_file_test() to test whether it is safe
 314  * to perform an operation, because there is always the possibility
 315  * of the condition changing before you actually perform the operation.
 316  * For example, you might think you could use %G_FILE_TEST_IS_SYMLINK
 317  * to know whether it is safe to write to a file without being
 318  * tricked into writing into a different location. It doesn&#39;t work!
 319  * |[&lt;!-- language=&quot;C&quot; --&gt;
 320  *  // DON&#39;T DO THIS
 321  *  if (!g_file_test (filename, G_FILE_TEST_IS_SYMLINK))
 322  *    {
 323  *      fd = g_open (filename, O_WRONLY);
 324  *      // write to fd
 325  *    }
 326  * ]|
 327  *
 328  * Another thing to note is that %G_FILE_TEST_EXISTS and
 329  * %G_FILE_TEST_IS_EXECUTABLE are implemented using the access()
 330  * system call. This usually doesn&#39;t matter, but if your program
 331  * is setuid or setgid it means that these tests will give you
 332  * the answer for the real user ID and group ID, rather than the
 333  * effective user ID and group ID.
 334  *
 335  * On Windows, there are no symlinks, so testing for
 336  * %G_FILE_TEST_IS_SYMLINK will always return %FALSE. Testing for
 337  * %G_FILE_TEST_IS_EXECUTABLE will just check that the file exists and
 338  * its name indicates that it is executable, checking for well-known
 339  * extensions and those listed in the `PATHEXT` environment variable.
 340  *
 341  * Returns: whether a test was %TRUE
 342  **/
 343 gboolean
 344 g_file_test (const gchar *filename,
 345              GFileTest    test)
 346 {
 347 #ifdef G_OS_WIN32
 348   int attributes;
 349   wchar_t *wfilename;
 350 #endif
 351 
 352   g_return_val_if_fail (filename != NULL, FALSE);
 353 
 354 #ifdef G_OS_WIN32
 355 /* stuff missing in std vc6 api */
 356 #  ifndef INVALID_FILE_ATTRIBUTES
 357 #    define INVALID_FILE_ATTRIBUTES -1
 358 #  endif
 359 #  ifndef FILE_ATTRIBUTE_DEVICE
 360 #    define FILE_ATTRIBUTE_DEVICE 64
 361 #  endif
 362   wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 363 
 364   if (wfilename == NULL)
 365     return FALSE;
 366 
 367   attributes = GetFileAttributesW (wfilename);
 368 
 369   g_free (wfilename);
 370 
 371   if (attributes == INVALID_FILE_ATTRIBUTES)
 372     return FALSE;
 373 
 374   if (test &amp; G_FILE_TEST_EXISTS)
 375     return TRUE;
 376 
 377   if (test &amp; G_FILE_TEST_IS_REGULAR)
 378     {
 379       if ((attributes &amp; (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_DEVICE)) == 0)
<a name="11" id="anc11"></a><span class="line-modified"> 380   return TRUE;</span>
 381     }
 382 
 383   if (test &amp; G_FILE_TEST_IS_DIR)
 384     {
 385       if ((attributes &amp; FILE_ATTRIBUTE_DIRECTORY) != 0)
<a name="12" id="anc12"></a><span class="line-modified"> 386   return TRUE;</span>
 387     }
 388 
 389   /* &quot;while&quot; so that we can exit this &quot;loop&quot; with a simple &quot;break&quot; */
 390   while (test &amp; G_FILE_TEST_IS_EXECUTABLE)
 391     {
 392       const gchar *lastdot = strrchr (filename, &#39;.&#39;);
 393       const gchar *pathext = NULL, *p;
 394       int extlen;
 395 
 396       if (lastdot == NULL)
 397         break;
 398 
 399       if (_stricmp (lastdot, &quot;.exe&quot;) == 0 ||
<a name="13" id="anc13"></a><span class="line-modified"> 400     _stricmp (lastdot, &quot;.cmd&quot;) == 0 ||</span>
<span class="line-modified"> 401     _stricmp (lastdot, &quot;.bat&quot;) == 0 ||</span>
<span class="line-modified"> 402     _stricmp (lastdot, &quot;.com&quot;) == 0)</span>
<span class="line-modified"> 403   return TRUE;</span>
 404 
 405       /* Check if it is one of the types listed in %PATHEXT% */
 406 
 407       pathext = g_getenv (&quot;PATHEXT&quot;);
 408       if (pathext == NULL)
 409         break;
 410 
 411       pathext = g_utf8_casefold (pathext, -1);
 412 
 413       lastdot = g_utf8_casefold (lastdot, -1);
 414       extlen = strlen (lastdot);
 415 
 416       p = pathext;
 417       while (TRUE)
<a name="14" id="anc14"></a><span class="line-modified"> 418   {</span>
<span class="line-modified"> 419     const gchar *q = strchr (p, &#39;;&#39;);</span>
<span class="line-modified"> 420     if (q == NULL)</span>
<span class="line-modified"> 421       q = p + strlen (p);</span>
<span class="line-modified"> 422     if (extlen == q - p &amp;&amp;</span>
<span class="line-modified"> 423         memcmp (lastdot, p, extlen) == 0)</span>
<span class="line-modified"> 424       {</span>
<span class="line-modified"> 425         g_free ((gchar *) pathext);</span>
<span class="line-modified"> 426         g_free ((gchar *) lastdot);</span>
<span class="line-modified"> 427         return TRUE;</span>
<span class="line-modified"> 428       }</span>
<span class="line-modified"> 429     if (*q)</span>
<span class="line-modified"> 430       p = q + 1;</span>
<span class="line-modified"> 431     else</span>
<span class="line-modified"> 432       break;</span>
<span class="line-modified"> 433   }</span>
 434 
 435       g_free ((gchar *) pathext);
 436       g_free ((gchar *) lastdot);
 437       break;
 438     }
 439 
 440   return FALSE;
 441 #else
 442   if ((test &amp; G_FILE_TEST_EXISTS) &amp;&amp; (access (filename, F_OK) == 0))
 443     return TRUE;
 444 
 445   if ((test &amp; G_FILE_TEST_IS_EXECUTABLE) &amp;&amp; (access (filename, X_OK) == 0))
 446     {
 447       if (getuid () != 0)
<a name="15" id="anc15"></a><span class="line-modified"> 448   return TRUE;</span>
 449 
 450       /* For root, on some POSIX systems, access (filename, X_OK)
 451        * will succeed even if no executable bits are set on the
 452        * file. We fall through to a stat test to avoid that.
 453        */
 454     }
 455   else
 456     test &amp;= ~G_FILE_TEST_IS_EXECUTABLE;
 457 
 458   if (test &amp; G_FILE_TEST_IS_SYMLINK)
 459     {
 460       struct stat s;
 461 
 462       if ((lstat (filename, &amp;s) == 0) &amp;&amp; S_ISLNK (s.st_mode))
 463         return TRUE;
 464     }
 465 
 466   if (test &amp; (G_FILE_TEST_IS_REGULAR |
<a name="16" id="anc16"></a><span class="line-modified"> 467         G_FILE_TEST_IS_DIR |</span>
<span class="line-modified"> 468         G_FILE_TEST_IS_EXECUTABLE))</span>
 469     {
 470       struct stat s;
 471 
 472       if (stat (filename, &amp;s) == 0)
<a name="17" id="anc17"></a><span class="line-modified"> 473   {</span>
<span class="line-modified"> 474     if ((test &amp; G_FILE_TEST_IS_REGULAR) &amp;&amp; S_ISREG (s.st_mode))</span>
<span class="line-modified"> 475       return TRUE;</span>
 476 
<a name="18" id="anc18"></a><span class="line-modified"> 477     if ((test &amp; G_FILE_TEST_IS_DIR) &amp;&amp; S_ISDIR (s.st_mode))</span>
<span class="line-modified"> 478       return TRUE;</span>
 479 
<a name="19" id="anc19"></a><span class="line-modified"> 480     /* The extra test for root when access (file, X_OK) succeeds.</span>
<span class="line-modified"> 481      */</span>
<span class="line-modified"> 482     if ((test &amp; G_FILE_TEST_IS_EXECUTABLE) &amp;&amp;</span>
<span class="line-modified"> 483         ((s.st_mode &amp; S_IXOTH) ||</span>
<span class="line-modified"> 484          (s.st_mode &amp; S_IXUSR) ||</span>
<span class="line-modified"> 485          (s.st_mode &amp; S_IXGRP)))</span>
<span class="line-modified"> 486       return TRUE;</span>
<span class="line-modified"> 487   }</span>
 488     }
 489 
 490   return FALSE;
 491 #endif
 492 }
 493 
 494 G_DEFINE_QUARK (g-file-error-quark, g_file_error)
 495 
 496 /**
 497  * g_file_error_from_errno:
 498  * @err_no: an &quot;errno&quot; value
 499  *
 500  * Gets a #GFileError constant based on the passed-in @err_no.
 501  * For example, if you pass in `EEXIST` this function returns
 502  * #G_FILE_ERROR_EXIST. Unlike `errno` values, you can portably
 503  * assume that all #GFileError values will exist.
 504  *
 505  * Normally a #GFileError value goes into a #GError returned
 506  * from a function that manipulates files. So you would use
 507  * g_file_error_from_errno() when constructing a #GError.
 508  *
 509  * Returns: #GFileError corresponding to the given @errno
 510  **/
 511 GFileError
 512 g_file_error_from_errno (gint err_no)
 513 {
 514   switch (err_no)
 515     {
 516 #ifdef EEXIST
 517     case EEXIST:
 518       return G_FILE_ERROR_EXIST;
 519 #endif
 520 
 521 #ifdef EISDIR
 522     case EISDIR:
 523       return G_FILE_ERROR_ISDIR;
 524 #endif
 525 
 526 #ifdef EACCES
 527     case EACCES:
 528       return G_FILE_ERROR_ACCES;
 529 #endif
 530 
 531 #ifdef ENAMETOOLONG
 532     case ENAMETOOLONG:
 533       return G_FILE_ERROR_NAMETOOLONG;
 534 #endif
 535 
 536 #ifdef ENOENT
 537     case ENOENT:
 538       return G_FILE_ERROR_NOENT;
 539 #endif
 540 
 541 #ifdef ENOTDIR
 542     case ENOTDIR:
 543       return G_FILE_ERROR_NOTDIR;
 544 #endif
 545 
 546 #ifdef ENXIO
 547     case ENXIO:
 548       return G_FILE_ERROR_NXIO;
 549 #endif
 550 
 551 #ifdef ENODEV
 552     case ENODEV:
 553       return G_FILE_ERROR_NODEV;
 554 #endif
 555 
 556 #ifdef EROFS
 557     case EROFS:
 558       return G_FILE_ERROR_ROFS;
 559 #endif
 560 
 561 #ifdef ETXTBSY
 562     case ETXTBSY:
 563       return G_FILE_ERROR_TXTBSY;
 564 #endif
 565 
 566 #ifdef EFAULT
 567     case EFAULT:
 568       return G_FILE_ERROR_FAULT;
 569 #endif
 570 
 571 #ifdef ELOOP
 572     case ELOOP:
 573       return G_FILE_ERROR_LOOP;
 574 #endif
 575 
 576 #ifdef ENOSPC
 577     case ENOSPC:
 578       return G_FILE_ERROR_NOSPC;
 579 #endif
 580 
 581 #ifdef ENOMEM
 582     case ENOMEM:
 583       return G_FILE_ERROR_NOMEM;
 584 #endif
 585 
 586 #ifdef EMFILE
 587     case EMFILE:
 588       return G_FILE_ERROR_MFILE;
 589 #endif
 590 
 591 #ifdef ENFILE
 592     case ENFILE:
 593       return G_FILE_ERROR_NFILE;
 594 #endif
 595 
 596 #ifdef EBADF
 597     case EBADF:
 598       return G_FILE_ERROR_BADF;
 599 #endif
 600 
 601 #ifdef EINVAL
 602     case EINVAL:
 603       return G_FILE_ERROR_INVAL;
 604 #endif
 605 
 606 #ifdef EPIPE
 607     case EPIPE:
 608       return G_FILE_ERROR_PIPE;
 609 #endif
 610 
 611 #ifdef EAGAIN
 612     case EAGAIN:
 613       return G_FILE_ERROR_AGAIN;
 614 #endif
 615 
 616 #ifdef EINTR
 617     case EINTR:
 618       return G_FILE_ERROR_INTR;
 619 #endif
 620 
 621 #ifdef EIO
 622     case EIO:
 623       return G_FILE_ERROR_IO;
 624 #endif
 625 
 626 #ifdef EPERM
 627     case EPERM:
 628       return G_FILE_ERROR_PERM;
 629 #endif
 630 
 631 #ifdef ENOSYS
 632     case ENOSYS:
 633       return G_FILE_ERROR_NOSYS;
 634 #endif
 635 
 636     default:
 637       return G_FILE_ERROR_FAILED;
 638     }
 639 }
 640 
 641 static char *
 642 format_error_message (const gchar  *filename,
 643                       const gchar  *format_string,
 644                       int           saved_errno) G_GNUC_FORMAT(2);
 645 
 646 #ifdef GSTREAMER_LITE
 647 #ifndef G_OS_WIN32
 648 #pragma GCC diagnostic push
 649 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
 650 #endif // G_OS_WIN32
 651 #else // GSTREAMER_LITE
 652 #pragma GCC diagnostic push
 653 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
 654 #endif // GSTREAMER_LITE
 655 
 656 static char *
 657 format_error_message (const gchar  *filename,
 658                       const gchar  *format_string,
 659                       int           saved_errno)
 660 {
 661   gchar *display_name;
 662   gchar *msg;
 663 
 664   display_name = g_filename_display_name (filename);
 665   msg = g_strdup_printf (format_string, display_name, g_strerror (saved_errno));
 666   g_free (display_name);
 667 
 668   return msg;
 669 }
 670 
 671 #ifdef GSTREAMER_LITE
 672 #ifndef G_OS_WIN32
 673 #pragma GCC diagnostic pop
 674 #endif // G_OS_WIN32
 675 #else // GSTREAMER_LITE
 676 #pragma GCC diagnostic pop
 677 #endif // GSTREAMER_LITE
 678 
 679 /* format string must have two &#39;%s&#39;:
 680  *
 681  *   - the place for the filename
 682  *   - the place for the strerror
 683  */
 684 static void
 685 set_file_error (GError      **error,
 686                 const gchar  *filename,
 687                 const gchar  *format_string,
 688                 int           saved_errno)
 689 {
 690   char *msg = format_error_message (filename, format_string, saved_errno);
 691 
 692   g_set_error_literal (error, G_FILE_ERROR, g_file_error_from_errno (saved_errno),
 693                        msg);
 694   g_free (msg);
 695 }
 696 
 697 static gboolean
 698 get_contents_stdio (const gchar  *filename,
 699                     FILE         *f,
 700                     gchar       **contents,
 701                     gsize        *length,
 702                     GError      **error)
 703 {
 704   gchar buf[4096];
 705   gsize bytes;  /* always &lt;= sizeof(buf) */
 706   gchar *str = NULL;
 707   gsize total_bytes = 0;
 708   gsize total_allocated = 0;
 709   gchar *tmp;
 710   gchar *display_filename;
 711 
 712   g_assert (f != NULL);
 713 
 714   while (!feof (f))
 715     {
 716       gint save_errno;
 717 
 718       bytes = fread (buf, 1, sizeof (buf), f);
 719       save_errno = errno;
 720 
 721       if (total_bytes &gt; G_MAXSIZE - bytes)
 722           goto file_too_large;
 723 
 724       /* Possibility of overflow eliminated above. */
 725       while (total_bytes + bytes &gt;= total_allocated)
 726         {
 727           if (str)
 728             {
 729               if (total_allocated &gt; G_MAXSIZE / 2)
 730                   goto file_too_large;
 731               total_allocated *= 2;
 732             }
 733           else
 734             {
 735               total_allocated = MIN (bytes + 1, sizeof (buf));
 736             }
 737 
 738           tmp = g_try_realloc (str, total_allocated);
 739 
 740           if (tmp == NULL)
 741             {
 742               display_filename = g_filename_display_name (filename);
 743               g_set_error (error,
 744                            G_FILE_ERROR,
 745                            G_FILE_ERROR_NOMEM,
 746                            g_dngettext (GETTEXT_PACKAGE, &quot;Could not allocate %lu byte to read file &#39;%s&#39;&quot;, &quot;Could not allocate %lu bytes to read file &#39;%s&#39;&quot;, (gulong)total_allocated),
 747                            (gulong) total_allocated,
<a name="20" id="anc20"></a><span class="line-modified"> 748          display_filename);</span>
 749               g_free (display_filename);
 750 
 751               goto error;
 752             }
 753 
<a name="21" id="anc21"></a><span class="line-modified"> 754     str = tmp;</span>
 755         }
 756 
 757       if (ferror (f))
 758         {
 759           display_filename = g_filename_display_name (filename);
 760           g_set_error (error,
 761                        G_FILE_ERROR,
 762                        g_file_error_from_errno (save_errno),
 763                        _(&quot;Error reading file &#39;%s&#39;: %s&quot;),
 764                        display_filename,
<a name="22" id="anc22"></a><span class="line-modified"> 765            g_strerror (save_errno));</span>
 766           g_free (display_filename);
 767 
 768           goto error;
 769         }
 770 
 771       g_assert (str != NULL);
 772       memcpy (str + total_bytes, buf, bytes);
 773 
 774       total_bytes += bytes;
 775     }
 776 
 777   fclose (f);
 778 
 779   if (total_allocated == 0)
 780     {
 781       str = g_new (gchar, 1);
 782       total_bytes = 0;
 783     }
 784 
 785   str[total_bytes] = &#39;\0&#39;;
 786 
 787   if (length)
 788     *length = total_bytes;
 789 
 790   *contents = str;
 791 
 792   return TRUE;
 793 
 794  file_too_large:
 795   display_filename = g_filename_display_name (filename);
 796   g_set_error (error,
 797                G_FILE_ERROR,
 798                G_FILE_ERROR_FAILED,
 799                _(&quot;File &#39;%s&#39; is too large&quot;),
 800                display_filename);
 801   g_free (display_filename);
 802 
 803  error:
 804 
 805   g_free (str);
 806   fclose (f);
 807 
 808   return FALSE;
 809 }
 810 
 811 #ifndef G_OS_WIN32
 812 
 813 static gboolean
 814 get_contents_regfile (const gchar  *filename,
 815                       struct stat  *stat_buf,
 816                       gint          fd,
 817                       gchar       **contents,
 818                       gsize        *length,
 819                       GError      **error)
 820 {
 821   gchar *buf;
 822   gsize bytes_read;
 823   gsize size;
 824   gsize alloc_size;
 825   gchar *display_filename;
 826 
 827   size = stat_buf-&gt;st_size;
 828 
 829   alloc_size = size + 1;
 830   buf = g_try_malloc (alloc_size);
 831 
 832   if (buf == NULL)
 833     {
 834       display_filename = g_filename_display_name (filename);
 835       g_set_error (error,
 836                    G_FILE_ERROR,
 837                    G_FILE_ERROR_NOMEM,
 838                            g_dngettext (GETTEXT_PACKAGE, &quot;Could not allocate %lu byte to read file &#39;%s&#39;&quot;, &quot;Could not allocate %lu bytes to read file &#39;%s&#39;&quot;, (gulong)alloc_size),
 839                    (gulong) alloc_size,
<a name="23" id="anc23"></a><span class="line-modified"> 840        display_filename);</span>
 841       g_free (display_filename);
 842       goto error;
 843     }
 844 
 845   bytes_read = 0;
 846   while (bytes_read &lt; size)
 847     {
 848       gssize rc;
 849 
 850       rc = read (fd, buf + bytes_read, size - bytes_read);
 851 
 852       if (rc &lt; 0)
 853         {
 854           if (errno != EINTR)
 855             {
<a name="24" id="anc24"></a><span class="line-modified"> 856         int save_errno = errno;</span>
 857 
 858               g_free (buf);
 859               display_filename = g_filename_display_name (filename);
 860               g_set_error (error,
 861                            G_FILE_ERROR,
 862                            g_file_error_from_errno (save_errno),
 863                            _(&quot;Failed to read from file &#39;%s&#39;: %s&quot;),
 864                            display_filename,
<a name="25" id="anc25"></a><span class="line-modified"> 865          g_strerror (save_errno));</span>
 866               g_free (display_filename);
<a name="26" id="anc26"></a><span class="line-modified"> 867         goto error;</span>
 868             }
 869         }
 870       else if (rc == 0)
 871         break;
 872       else
 873         bytes_read += rc;
 874     }
 875 
 876   buf[bytes_read] = &#39;\0&#39;;
 877 
 878   if (length)
 879     *length = bytes_read;
 880 
 881   *contents = buf;
 882 
 883   close (fd);
 884 
 885   return TRUE;
 886 
 887  error:
 888 
 889   close (fd);
 890 
 891   return FALSE;
 892 }
 893 
 894 static gboolean
 895 get_contents_posix (const gchar  *filename,
 896                     gchar       **contents,
 897                     gsize        *length,
 898                     GError      **error)
 899 {
 900   struct stat stat_buf;
 901   gint fd;
 902 
 903   /* O_BINARY useful on Cygwin */
 904   fd = open (filename, O_RDONLY|O_BINARY);
 905 
 906   if (fd &lt; 0)
 907     {
 908       int saved_errno = errno;
 909       set_file_error (error,
 910                       filename,
 911                       _(&quot;Failed to open file &#39;%s&#39;: %s&quot;),
 912                       saved_errno);
 913 
 914       return FALSE;
 915     }
 916 
 917   /* I don&#39;t think this will ever fail, aside from ENOMEM, but. */
 918   if (fstat (fd, &amp;stat_buf) &lt; 0)
 919     {
 920       int saved_errno = errno;
 921       set_file_error (error,
 922                       filename,
 923                       _(&quot;Failed to get attributes of file &#39;%s&#39;: fstat() failed: %s&quot;),
 924                       saved_errno);
 925       close (fd);
 926 
 927       return FALSE;
 928     }
 929 
 930   if (stat_buf.st_size &gt; 0 &amp;&amp; S_ISREG (stat_buf.st_mode))
 931     {
 932       gboolean retval = get_contents_regfile (filename,
<a name="27" id="anc27"></a><span class="line-modified"> 933                 &amp;stat_buf,</span>
<span class="line-modified"> 934                 fd,</span>
<span class="line-modified"> 935                 contents,</span>
<span class="line-modified"> 936                 length,</span>
<span class="line-modified"> 937                 error);</span>
 938 
 939       return retval;
 940     }
 941   else
 942     {
 943       FILE *f;
 944       gboolean retval;
 945 
 946       f = fdopen (fd, &quot;r&quot;);
 947 
 948       if (f == NULL)
 949         {
 950           int saved_errno = errno;
 951           set_file_error (error,
 952                           filename,
 953                           _(&quot;Failed to open file &#39;%s&#39;: fdopen() failed: %s&quot;),
 954                           saved_errno);
 955 
 956           return FALSE;
 957         }
 958 
 959       retval = get_contents_stdio (filename, f, contents, length, error);
 960 
 961       return retval;
 962     }
 963 }
 964 
 965 #else  /* G_OS_WIN32 */
 966 
 967 static gboolean
 968 get_contents_win32 (const gchar  *filename,
<a name="28" id="anc28"></a><span class="line-modified"> 969         gchar       **contents,</span>
<span class="line-modified"> 970         gsize        *length,</span>
<span class="line-modified"> 971         GError      **error)</span>
 972 {
 973   FILE *f;
 974   gboolean retval;
 975 
 976   f = g_fopen (filename, &quot;rb&quot;);
 977 
 978   if (f == NULL)
 979     {
 980       int saved_errno = errno;
 981       set_file_error (error,
 982                       filename,
 983                       _(&quot;Failed to open file &#39;%s&#39;: %s&quot;),
 984                       saved_errno);
 985 
 986       return FALSE;
 987     }
 988 
 989   retval = get_contents_stdio (filename, f, contents, length, error);
 990 
 991   return retval;
 992 }
 993 
 994 #endif
 995 
 996 /**
 997  * g_file_get_contents:
 998  * @filename: (type filename): name of a file to read contents from, in the GLib file name encoding
 999  * @contents: (out) (array length=length) (element-type guint8): location to store an allocated string, use g_free() to free
1000  *     the returned string
1001  * @length: (nullable): location to store length in bytes of the contents, or %NULL
1002  * @error: return location for a #GError, or %NULL
1003  *
1004  * Reads an entire file into allocated memory, with good error
1005  * checking.
1006  *
1007  * If the call was successful, it returns %TRUE and sets @contents to the file
1008  * contents and @length to the length of the file contents in bytes. The string
1009  * stored in @contents will be nul-terminated, so for text files you can pass
1010  * %NULL for the @length argument. If the call was not successful, it returns
1011  * %FALSE and sets @error. The error domain is #G_FILE_ERROR. Possible error
1012  * codes are those in the #GFileError enumeration. In the error case,
1013  * @contents is set to %NULL and @length is set to zero.
1014  *
1015  * Returns: %TRUE on success, %FALSE if an error occurred
1016  **/
1017 gboolean
1018 g_file_get_contents (const gchar  *filename,
1019                      gchar       **contents,
1020                      gsize        *length,
1021                      GError      **error)
1022 {
1023   g_return_val_if_fail (filename != NULL, FALSE);
1024   g_return_val_if_fail (contents != NULL, FALSE);
1025 
1026   *contents = NULL;
1027   if (length)
1028     *length = 0;
1029 
1030 #ifdef G_OS_WIN32
1031   return get_contents_win32 (filename, contents, length, error);
1032 #else
1033   return get_contents_posix (filename, contents, length, error);
1034 #endif
1035 }
1036 
1037 static gboolean
1038 rename_file (const char  *old_name,
<a name="29" id="anc29"></a><span class="line-modified">1039        const char  *new_name,</span>
<span class="line-modified">1040        GError     **err)</span>
1041 {
1042   errno = 0;
1043   if (g_rename (old_name, new_name) == -1)
1044     {
1045       int save_errno = errno;
1046       gchar *display_old_name = g_filename_display_name (old_name);
1047       gchar *display_new_name = g_filename_display_name (new_name);
1048 
1049       g_set_error (err,
<a name="30" id="anc30"></a><span class="line-modified">1050        G_FILE_ERROR,</span>
<span class="line-modified">1051        g_file_error_from_errno (save_errno),</span>
<span class="line-modified">1052        _(&quot;Failed to rename file &#39;%s&#39; to &#39;%s&#39;: g_rename() failed: %s&quot;),</span>
<span class="line-modified">1053        display_old_name,</span>
<span class="line-modified">1054        display_new_name,</span>
<span class="line-modified">1055        g_strerror (save_errno));</span>
1056 
1057       g_free (display_old_name);
1058       g_free (display_new_name);
1059 
1060       return FALSE;
1061     }
1062 
1063   return TRUE;
1064 }
1065 
1066 static gchar *
1067 write_to_temp_file (const gchar  *contents,
<a name="31" id="anc31"></a><span class="line-modified">1068         gssize        length,</span>
<span class="line-modified">1069         const gchar  *dest_file,</span>
<span class="line-modified">1070         GError      **err)</span>
1071 {
1072   gchar *tmp_name;
1073   gchar *retval;
1074   gint fd;
1075 
1076   retval = NULL;
1077 
1078   tmp_name = g_strdup_printf (&quot;%s.XXXXXX&quot;, dest_file);
1079 
1080   errno = 0;
1081   fd = g_mkstemp_full (tmp_name, O_RDWR | O_BINARY, 0666);
1082 
1083   if (fd == -1)
1084     {
1085       int saved_errno = errno;
1086       set_file_error (err,
1087                       tmp_name, _(&quot;Failed to create file &#39;%s&#39;: %s&quot;),
1088                       saved_errno);
1089       goto out;
1090     }
1091 
1092 #ifdef HAVE_FALLOCATE
1093   if (length &gt; 0)
1094     {
1095       /* We do this on a &#39;best effort&#39; basis... It may not be supported
1096        * on the underlying filesystem.
1097        */
1098       (void) fallocate (fd, 0, 0, length);
1099     }
1100 #endif
1101   while (length &gt; 0)
1102     {
1103       gssize s;
1104 
1105       s = write (fd, contents, length);
1106 
1107       if (s &lt; 0)
1108         {
1109           int saved_errno = errno;
1110           if (saved_errno == EINTR)
1111             continue;
1112 
1113           set_file_error (err,
1114                           tmp_name, _(&quot;Failed to write file &#39;%s&#39;: write() failed: %s&quot;),
1115                           saved_errno);
1116           close (fd);
1117           g_unlink (tmp_name);
1118 
1119           goto out;
1120         }
1121 
1122       g_assert (s &lt;= length);
1123 
1124       contents += s;
1125       length -= s;
1126     }
1127 
1128 #ifdef BTRFS_SUPER_MAGIC
1129   {
1130     struct statfs buf;
1131 
1132     /* On Linux, on btrfs, skip the fsync since rename-over-existing is
1133      * guaranteed to be atomic and this is the only case in which we
1134      * would fsync() anyway.
1135      */
1136 
1137     if (fstatfs (fd, &amp;buf) == 0 &amp;&amp; buf.f_type == BTRFS_SUPER_MAGIC)
1138       goto no_fsync;
1139   }
1140 #endif
1141 
1142 #ifdef HAVE_FSYNC
1143   {
1144     struct stat statbuf;
1145 
1146     errno = 0;
1147     /* If the final destination exists and is &gt; 0 bytes, we want to sync the
1148      * newly written file to ensure the data is on disk when we rename over
1149      * the destination. Otherwise if we get a system crash we can lose both
1150      * the new and the old file on some filesystems. (I.E. those that don&#39;t
1151      * guarantee the data is written to the disk before the metadata.)
1152      */
1153     if (g_lstat (dest_file, &amp;statbuf) == 0 &amp;&amp; statbuf.st_size &gt; 0 &amp;&amp; fsync (fd) != 0)
1154       {
1155         int saved_errno = errno;
1156         set_file_error (err,
1157                         tmp_name, _(&quot;Failed to write file &#39;%s&#39;: fsync() failed: %s&quot;),
1158                         saved_errno);
1159         close (fd);
1160         g_unlink (tmp_name);
1161 
1162         goto out;
1163       }
1164   }
1165 #endif
1166 
1167 #ifdef BTRFS_SUPER_MAGIC
1168  no_fsync:
1169 #endif
1170 
1171   errno = 0;
1172   if (!g_close (fd, err))
1173     {
1174       g_unlink (tmp_name);
1175 
1176       goto out;
1177     }
1178 
1179   retval = g_strdup (tmp_name);
1180 
1181  out:
1182   g_free (tmp_name);
1183 
1184   return retval;
1185 }
1186 
1187 /**
1188  * g_file_set_contents:
1189  * @filename: (type filename): name of a file to write @contents to, in the GLib file name
1190  *   encoding
1191  * @contents: (array length=length) (element-type guint8): string to write to the file
1192  * @length: length of @contents, or -1 if @contents is a nul-terminated string
1193  * @error: return location for a #GError, or %NULL
1194  *
1195  * Writes all of @contents to a file named @filename, with good error checking.
1196  * If a file called @filename already exists it will be overwritten.
1197  *
1198  * This write is atomic in the sense that it is first written to a temporary
1199  * file which is then renamed to the final name. Notes:
1200  *
1201  * - On UNIX, if @filename already exists hard links to @filename will break.
1202  *   Also since the file is recreated, existing permissions, access control
1203  *   lists, metadata etc. may be lost. If @filename is a symbolic link,
1204  *   the link itself will be replaced, not the linked file.
1205  *
1206  * - On UNIX, if @filename already exists and is non-empty, and if the system
1207  *   supports it (via a journalling filesystem or equivalent), the fsync()
1208  *   call (or equivalent) will be used to ensure atomic replacement: @filename
1209  *   will contain either its old contents or @contents, even in the face of
1210  *   system power loss, the disk being unsafely removed, etc.
1211  *
1212  * - On UNIX, if @filename does not already exist or is empty, there is a
1213  *   possibility that system power loss etc. after calling this function will
1214  *   leave @filename empty or full of NUL bytes, depending on the underlying
1215  *   filesystem.
1216  *
1217  * - On Windows renaming a file will not remove an existing file with the
1218  *   new name, so on Windows there is a race condition between the existing
1219  *   file being removed and the temporary file being renamed.
1220  *
1221  * - On Windows there is no way to remove a file that is open to some
1222  *   process, or mapped into memory. Thus, this function will fail if
1223  *   @filename already exists and is open.
1224  *
1225  * If the call was successful, it returns %TRUE. If the call was not successful,
1226  * it returns %FALSE and sets @error. The error domain is #G_FILE_ERROR.
1227  * Possible error codes are those in the #GFileError enumeration.
1228  *
1229  * Note that the name for the temporary file is constructed by appending up
1230  * to 7 characters to @filename.
1231  *
1232  * Returns: %TRUE on success, %FALSE if an error occurred
1233  *
1234  * Since: 2.8
1235  */
1236 gboolean
1237 g_file_set_contents (const gchar  *filename,
<a name="32" id="anc32"></a><span class="line-modified">1238          const gchar  *contents,</span>
<span class="line-modified">1239          gssize    length,</span>
<span class="line-modified">1240          GError  **error)</span>
1241 {
1242   gchar *tmp_filename;
1243   gboolean retval;
1244   GError *rename_error = NULL;
1245 
1246   g_return_val_if_fail (filename != NULL, FALSE);
1247   g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
1248   g_return_val_if_fail (contents != NULL || length == 0, FALSE);
1249   g_return_val_if_fail (length &gt;= -1, FALSE);
1250 
1251   if (length == -1)
1252     length = strlen (contents);
1253 
1254   tmp_filename = write_to_temp_file (contents, length, filename, error);
1255 
1256   if (!tmp_filename)
1257     {
1258       retval = FALSE;
1259       goto out;
1260     }
1261 
1262   if (!rename_file (tmp_filename, filename, &amp;rename_error))
1263     {
1264 #ifndef G_OS_WIN32
1265 
1266       g_unlink (tmp_filename);
1267       g_propagate_error (error, rename_error);
1268       retval = FALSE;
1269       goto out;
1270 
1271 #else /* G_OS_WIN32 */
1272 
1273       /* Renaming failed, but on Windows this may just mean
1274        * the file already exists. So if the target file
1275        * exists, try deleting it and do the rename again.
1276        */
1277       if (!g_file_test (filename, G_FILE_TEST_EXISTS))
<a name="33" id="anc33"></a><span class="line-modified">1278   {</span>
<span class="line-modified">1279     g_unlink (tmp_filename);</span>
<span class="line-modified">1280     g_propagate_error (error, rename_error);</span>
<span class="line-modified">1281     retval = FALSE;</span>
<span class="line-modified">1282     goto out;</span>
<span class="line-modified">1283   }</span>
1284 
1285       g_error_free (rename_error);
1286 
1287       if (g_unlink (filename) == -1)
<a name="34" id="anc34"></a><span class="line-modified">1288   {</span>
1289           int saved_errno = errno;
1290           set_file_error (error,
1291                           filename,
<a name="35" id="anc35"></a><span class="line-modified">1292               _(&quot;Existing file &#39;%s&#39; could not be removed: g_unlink() failed: %s&quot;),</span>
1293                           saved_errno);
<a name="36" id="anc36"></a><span class="line-modified">1294     g_unlink (tmp_filename);</span>
<span class="line-modified">1295     retval = FALSE;</span>
<span class="line-modified">1296     goto out;</span>
<span class="line-modified">1297   }</span>
1298 
1299       if (!rename_file (tmp_filename, filename, error))
<a name="37" id="anc37"></a><span class="line-modified">1300   {</span>
<span class="line-modified">1301     g_unlink (tmp_filename);</span>
<span class="line-modified">1302     retval = FALSE;</span>
<span class="line-modified">1303     goto out;</span>
<span class="line-modified">1304   }</span>
1305 
1306 #endif
1307     }
1308 
1309   retval = TRUE;
1310 
1311  out:
1312   g_free (tmp_filename);
1313   return retval;
1314 }
1315 
1316 /*
1317  * get_tmp_file based on the mkstemp implementation from the GNU C library.
1318  * Copyright (C) 1991,92,93,94,95,96,97,98,99 Free Software Foundation, Inc.
1319  */
1320 typedef gint (*GTmpFileCallback) (const gchar *, gint, gint);
1321 
1322 static gint
1323 get_tmp_file (gchar            *tmpl,
1324               GTmpFileCallback  f,
1325               int               flags,
1326               int               mode)
1327 {
1328   char *XXXXXX;
1329   int count, fd;
1330   static const char letters[] =
1331     &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;;
1332   static const int NLETTERS = sizeof (letters) - 1;
1333   glong value;
<a name="38" id="anc38"></a><span class="line-modified">1334   gint64 now_us;</span>
1335   static int counter = 0;
1336 
1337   g_return_val_if_fail (tmpl != NULL, -1);
1338 
1339   /* find the last occurrence of &quot;XXXXXX&quot; */
1340   XXXXXX = g_strrstr (tmpl, &quot;XXXXXX&quot;);
1341 
1342   if (!XXXXXX || strncmp (XXXXXX, &quot;XXXXXX&quot;, 6))
1343     {
1344       errno = EINVAL;
1345       return -1;
1346     }
1347 
1348   /* Get some more or less random data.  */
<a name="39" id="anc39"></a><span class="line-modified">1349   now_us = g_get_real_time ();</span>
<span class="line-modified">1350   value = ((now_us % G_USEC_PER_SEC) ^ (now_us / G_USEC_PER_SEC)) + counter++;</span>
1351 
1352   for (count = 0; count &lt; 100; value += 7777, ++count)
1353     {
1354       glong v = value;
1355 
1356       /* Fill in the random bits.  */
1357       XXXXXX[0] = letters[v % NLETTERS];
1358       v /= NLETTERS;
1359       XXXXXX[1] = letters[v % NLETTERS];
1360       v /= NLETTERS;
1361       XXXXXX[2] = letters[v % NLETTERS];
1362       v /= NLETTERS;
1363       XXXXXX[3] = letters[v % NLETTERS];
1364       v /= NLETTERS;
1365       XXXXXX[4] = letters[v % NLETTERS];
1366       v /= NLETTERS;
1367       XXXXXX[5] = letters[v % NLETTERS];
1368 
1369       fd = f (tmpl, flags, mode);
1370 
1371       if (fd &gt;= 0)
1372         return fd;
1373       else if (errno != EEXIST)
1374         /* Any other error will apply also to other names we might
1375          *  try, and there are 2^32 or so of them, so give up now.
1376          */
1377         return -1;
1378     }
1379 
1380   /* We got out of the loop because we ran out of combinations to try.  */
1381   errno = EEXIST;
1382   return -1;
1383 }
1384 
1385 /* Some GTmpFileCallback implementations.
1386  *
1387  * Note: we cannot use open() or g_open() directly because even though
1388  * they appear compatible, they may be vararg functions and calling
1389  * varargs functions through a non-varargs type is undefined.
1390  */
1391 static gint
1392 wrap_g_mkdir (const gchar *filename,
1393               int          flags G_GNUC_UNUSED,
1394               int          mode)
1395 {
1396   /* tmpl is in UTF-8 on Windows, thus use g_mkdir() */
1397   return g_mkdir (filename, mode);
1398 }
1399 
1400 static gint
1401 wrap_g_open (const gchar *filename,
1402                 int          flags,
1403                 int          mode)
1404 {
1405   return g_open (filename, flags, mode);
1406 }
1407 
1408 /**
1409  * g_mkdtemp_full: (skip)
1410  * @tmpl: (type filename): template directory name
1411  * @mode: permissions to create the temporary directory with
1412  *
1413  * Creates a temporary directory. See the mkdtemp() documentation
1414  * on most UNIX-like systems.
1415  *
1416  * The parameter is a string that should follow the rules for
1417  * mkdtemp() templates, i.e. contain the string &quot;XXXXXX&quot;.
1418  * g_mkdtemp_full() is slightly more flexible than mkdtemp() in that the
1419  * sequence does not have to occur at the very end of the template
1420  * and you can pass a @mode. The X string will be modified to form
1421  * the name of a directory that didn&#39;t exist. The string should be
1422  * in the GLib file name encoding. Most importantly, on Windows it
1423  * should be in UTF-8.
1424  *
1425  * If you are going to be creating a temporary directory inside the
1426  * directory returned by g_get_tmp_dir(), you might want to use
1427  * g_dir_make_tmp() instead.
1428  *
1429  * Returns: (nullable) (type filename): A pointer to @tmpl, which has been
1430  *     modified to hold the directory name. In case of errors, %NULL is
1431  *     returned, and %errno will be set.
1432  *
1433  * Since: 2.30
1434  */
1435 gchar *
1436 g_mkdtemp_full (gchar *tmpl,
1437                 gint   mode)
1438 {
1439   if (get_tmp_file (tmpl, wrap_g_mkdir, 0, mode) == -1)
1440     return NULL;
1441   else
1442     return tmpl;
1443 }
1444 
1445 /**
1446  * g_mkdtemp: (skip)
1447  * @tmpl: (type filename): template directory name
1448  *
1449  * Creates a temporary directory. See the mkdtemp() documentation
1450  * on most UNIX-like systems.
1451  *
1452  * The parameter is a string that should follow the rules for
1453  * mkdtemp() templates, i.e. contain the string &quot;XXXXXX&quot;.
1454  * g_mkdtemp() is slightly more flexible than mkdtemp() in that the
1455  * sequence does not have to occur at the very end of the template.
1456  * The X string will be modified to form the name of a directory that
1457  * didn&#39;t exist.
1458  * The string should be in the GLib file name encoding. Most importantly,
1459  * on Windows it should be in UTF-8.
1460  *
1461  * If you are going to be creating a temporary directory inside the
1462  * directory returned by g_get_tmp_dir(), you might want to use
1463  * g_dir_make_tmp() instead.
1464  *
1465  * Returns: (nullable) (type filename): A pointer to @tmpl, which has been
1466  *     modified to hold the directory name.  In case of errors, %NULL is
1467  *     returned and %errno will be set.
1468  *
1469  * Since: 2.30
1470  */
1471 gchar *
1472 g_mkdtemp (gchar *tmpl)
1473 {
1474   return g_mkdtemp_full (tmpl, 0700);
1475 }
1476 
1477 /**
1478  * g_mkstemp_full: (skip)
1479  * @tmpl: (type filename): template filename
1480  * @flags: flags to pass to an open() call in addition to O_EXCL
1481  *     and O_CREAT, which are passed automatically
1482  * @mode: permissions to create the temporary file with
1483  *
1484  * Opens a temporary file. See the mkstemp() documentation
1485  * on most UNIX-like systems.
1486  *
1487  * The parameter is a string that should follow the rules for
1488  * mkstemp() templates, i.e. contain the string &quot;XXXXXX&quot;.
1489  * g_mkstemp_full() is slightly more flexible than mkstemp()
1490  * in that the sequence does not have to occur at the very end of the
1491  * template and you can pass a @mode and additional @flags. The X
1492  * string will be modified to form the name of a file that didn&#39;t exist.
1493  * The string should be in the GLib file name encoding. Most importantly,
1494  * on Windows it should be in UTF-8.
1495  *
1496  * Returns: A file handle (as from open()) to the file
1497  *     opened for reading and writing. The file handle should be
1498  *     closed with close(). In case of errors, -1 is returned
1499  *     and %errno will be set.
1500  *
1501  * Since: 2.22
1502  */
1503 gint
1504 g_mkstemp_full (gchar *tmpl,
1505                 gint   flags,
1506                 gint   mode)
1507 {
1508   /* tmpl is in UTF-8 on Windows, thus use g_open() */
1509   return get_tmp_file (tmpl, wrap_g_open,
1510                        flags | O_CREAT | O_EXCL, mode);
1511 }
1512 
1513 /**
1514  * g_mkstemp: (skip)
1515  * @tmpl: (type filename): template filename
1516  *
1517  * Opens a temporary file. See the mkstemp() documentation
1518  * on most UNIX-like systems.
1519  *
1520  * The parameter is a string that should follow the rules for
1521  * mkstemp() templates, i.e. contain the string &quot;XXXXXX&quot;.
1522  * g_mkstemp() is slightly more flexible than mkstemp() in that the
1523  * sequence does not have to occur at the very end of the template.
1524  * The X string will be modified to form the name of a file that
1525  * didn&#39;t exist. The string should be in the GLib file name encoding.
1526  * Most importantly, on Windows it should be in UTF-8.
1527  *
1528  * Returns: A file handle (as from open()) to the file
1529  *     opened for reading and writing. The file is opened in binary
1530  *     mode on platforms where there is a difference. The file handle
1531  *     should be closed with close(). In case of errors, -1 is
1532  *     returned and %errno will be set.
1533  */
1534 gint
1535 g_mkstemp (gchar *tmpl)
1536 {
1537   return g_mkstemp_full (tmpl, O_RDWR | O_BINARY, 0600);
1538 }
1539 
1540 static gint
1541 g_get_tmp_name (const gchar      *tmpl,
1542                 gchar           **name_used,
1543                 GTmpFileCallback  f,
1544                 gint              flags,
1545                 gint              mode,
1546                 GError          **error)
1547 {
1548   int retval;
1549   const char *tmpdir;
1550   const char *sep;
1551   char *fulltemplate;
1552   const char *slash;
1553 
1554   if (tmpl == NULL)
1555     tmpl = &quot;.XXXXXX&quot;;
1556 
1557   if ((slash = strchr (tmpl, G_DIR_SEPARATOR)) != NULL
1558 #ifdef G_OS_WIN32
1559       || (strchr (tmpl, &#39;/&#39;) != NULL &amp;&amp; (slash = &quot;/&quot;))
1560 #endif
1561       )
1562     {
1563       gchar *display_tmpl = g_filename_display_name (tmpl);
1564       char c[2];
1565       c[0] = *slash;
1566       c[1] = &#39;\0&#39;;
1567 
1568       g_set_error (error,
1569                    G_FILE_ERROR,
1570                    G_FILE_ERROR_FAILED,
1571                    _(&quot;Template &#39;%s&#39; invalid, should not contain a &#39;%s&#39;&quot;),
1572                    display_tmpl, c);
1573       g_free (display_tmpl);
1574 
1575       return -1;
1576     }
1577 
1578   if (strstr (tmpl, &quot;XXXXXX&quot;) == NULL)
1579     {
1580       gchar *display_tmpl = g_filename_display_name (tmpl);
1581       g_set_error (error,
1582                    G_FILE_ERROR,
1583                    G_FILE_ERROR_FAILED,
1584                    _(&quot;Template &#39;%s&#39; doesn&#39;t contain XXXXXX&quot;),
1585                    display_tmpl);
1586       g_free (display_tmpl);
1587       return -1;
1588     }
1589 
1590   tmpdir = g_get_tmp_dir ();
1591 
1592   if (G_IS_DIR_SEPARATOR (tmpdir [strlen (tmpdir) - 1]))
1593     sep = &quot;&quot;;
1594   else
1595     sep = G_DIR_SEPARATOR_S;
1596 
1597   fulltemplate = g_strconcat (tmpdir, sep, tmpl, NULL);
1598 
1599   retval = get_tmp_file (fulltemplate, f, flags, mode);
1600   if (retval == -1)
1601     {
1602       int saved_errno = errno;
1603       set_file_error (error,
1604                       fulltemplate,
1605                       _(&quot;Failed to create file &#39;%s&#39;: %s&quot;),
1606                       saved_errno);
1607       g_free (fulltemplate);
1608       return -1;
1609     }
1610 
1611   *name_used = fulltemplate;
1612 
1613   return retval;
1614 }
1615 
1616 /**
1617  * g_file_open_tmp:
1618  * @tmpl: (type filename) (nullable): Template for file name, as in
1619  *     g_mkstemp(), basename only, or %NULL for a default template
1620  * @name_used: (out) (type filename): location to store actual name used,
1621  *     or %NULL
1622  * @error: return location for a #GError
1623  *
1624  * Opens a file for writing in the preferred directory for temporary
1625  * files (as returned by g_get_tmp_dir()).
1626  *
1627  * @tmpl should be a string in the GLib file name encoding containing
1628  * a sequence of six &#39;X&#39; characters, as the parameter to g_mkstemp().
1629  * However, unlike these functions, the template should only be a
1630  * basename, no directory components are allowed. If template is
1631  * %NULL, a default template is used.
1632  *
1633  * Note that in contrast to g_mkstemp() (and mkstemp()) @tmpl is not
1634  * modified, and might thus be a read-only literal string.
1635  *
1636  * Upon success, and if @name_used is non-%NULL, the actual name used
1637  * is returned in @name_used. This string should be freed with g_free()
1638  * when not needed any longer. The returned name is in the GLib file
1639  * name encoding.
1640  *
1641  * Returns: A file handle (as from open()) to the file opened for
1642  *     reading and writing. The file is opened in binary mode on platforms
1643  *     where there is a difference. The file handle should be closed with
1644  *     close(). In case of errors, -1 is returned and @error will be set.
1645  */
1646 gint
1647 g_file_open_tmp (const gchar  *tmpl,
1648                  gchar       **name_used,
1649                  GError      **error)
1650 {
1651   gchar *fulltemplate;
1652   gint result;
1653 
1654   g_return_val_if_fail (error == NULL || *error == NULL, -1);
1655 
1656   result = g_get_tmp_name (tmpl, &amp;fulltemplate,
1657                            wrap_g_open,
1658                            O_CREAT | O_EXCL | O_RDWR | O_BINARY,
1659                            0600,
1660                            error);
1661   if (result != -1)
1662     {
1663       if (name_used)
1664         *name_used = fulltemplate;
1665       else
1666         g_free (fulltemplate);
1667     }
1668 
1669   return result;
1670 }
1671 
1672 /**
1673  * g_dir_make_tmp:
1674  * @tmpl: (type filename) (nullable): Template for directory name,
1675  *     as in g_mkdtemp(), basename only, or %NULL for a default template
1676  * @error: return location for a #GError
1677  *
1678  * Creates a subdirectory in the preferred directory for temporary
1679  * files (as returned by g_get_tmp_dir()).
1680  *
1681  * @tmpl should be a string in the GLib file name encoding containing
1682  * a sequence of six &#39;X&#39; characters, as the parameter to g_mkstemp().
1683  * However, unlike these functions, the template should only be a
1684  * basename, no directory components are allowed. If template is
1685  * %NULL, a default template is used.
1686  *
1687  * Note that in contrast to g_mkdtemp() (and mkdtemp()) @tmpl is not
1688  * modified, and might thus be a read-only literal string.
1689  *
1690  * Returns: (type filename): The actual name used. This string
1691  *     should be freed with g_free() when not needed any longer and is
1692  *     is in the GLib file name encoding. In case of errors, %NULL is
1693  *     returned and @error will be set.
1694  *
1695  * Since: 2.30
1696  */
1697 gchar *
1698 g_dir_make_tmp (const gchar  *tmpl,
1699                 GError      **error)
1700 {
1701   gchar *fulltemplate;
1702 
1703   g_return_val_if_fail (error == NULL || *error == NULL, NULL);
1704 
1705   if (g_get_tmp_name (tmpl, &amp;fulltemplate, wrap_g_mkdir, 0, 0700, error) == -1)
1706     return NULL;
1707   else
1708     return fulltemplate;
1709 }
1710 
1711 static gchar *
1712 g_build_path_va (const gchar  *separator,
<a name="40" id="anc40"></a><span class="line-modified">1713      const gchar  *first_element,</span>
<span class="line-modified">1714      va_list      *args,</span>
<span class="line-modified">1715      gchar       **str_array)</span>
1716 {
1717   GString *result;
1718   gint separator_len = strlen (separator);
1719   gboolean is_first = TRUE;
1720   gboolean have_leading = FALSE;
1721   const gchar *single_element = NULL;
1722   const gchar *next_element;
1723   const gchar *last_trailing = NULL;
1724   gint i = 0;
1725 
1726   result = g_string_new (NULL);
1727 
1728   if (str_array)
1729     next_element = str_array[i++];
1730   else
1731     next_element = first_element;
1732 
1733   while (TRUE)
1734     {
1735       const gchar *element;
1736       const gchar *start;
1737       const gchar *end;
1738 
1739       if (next_element)
<a name="41" id="anc41"></a><span class="line-modified">1740   {</span>
<span class="line-modified">1741     element = next_element;</span>
<span class="line-modified">1742     if (str_array)</span>
<span class="line-modified">1743       next_element = str_array[i++];</span>
<span class="line-modified">1744     else</span>
<span class="line-modified">1745       next_element = va_arg (*args, gchar *);</span>
<span class="line-modified">1746   }</span>
1747       else
<a name="42" id="anc42"></a><span class="line-modified">1748   break;</span>
1749 
1750       /* Ignore empty elements */
1751       if (!*element)
<a name="43" id="anc43"></a><span class="line-modified">1752   continue;</span>
1753 
1754       start = element;
1755 
1756       if (separator_len)
<a name="44" id="anc44"></a><span class="line-modified">1757   {</span>
<span class="line-modified">1758     while (strncmp (start, separator, separator_len) == 0)</span>
<span class="line-modified">1759       start += separator_len;</span>
1760         }
1761 
1762       end = start + strlen (start);
1763 
1764       if (separator_len)
<a name="45" id="anc45"></a><span class="line-modified">1765   {</span>
<span class="line-modified">1766     while (end &gt;= start + separator_len &amp;&amp;</span>
<span class="line-modified">1767      strncmp (end - separator_len, separator, separator_len) == 0)</span>
<span class="line-modified">1768       end -= separator_len;</span>
1769 
<a name="46" id="anc46"></a><span class="line-modified">1770     last_trailing = end;</span>
<span class="line-modified">1771     while (last_trailing &gt;= element + separator_len &amp;&amp;</span>
<span class="line-modified">1772      strncmp (last_trailing - separator_len, separator, separator_len) == 0)</span>
<span class="line-modified">1773       last_trailing -= separator_len;</span>
1774 
<a name="47" id="anc47"></a><span class="line-modified">1775     if (!have_leading)</span>
<span class="line-modified">1776       {</span>
<span class="line-modified">1777         /* If the leading and trailing separator strings are in the</span>
<span class="line-modified">1778          * same element and overlap, the result is exactly that element</span>
<span class="line-modified">1779          */</span>
<span class="line-modified">1780         if (last_trailing &lt;= start)</span>
<span class="line-modified">1781     single_element = element;</span>
<span class="line-modified">1782 </span>
<span class="line-modified">1783         g_string_append_len (result, element, start - element);</span>
<span class="line-modified">1784         have_leading = TRUE;</span>
<span class="line-modified">1785       }</span>
<span class="line-modified">1786     else</span>
<span class="line-modified">1787       single_element = NULL;</span>
<span class="line-modified">1788   }</span>
1789 
1790       if (end == start)
<a name="48" id="anc48"></a><span class="line-modified">1791   continue;</span>
1792 
1793       if (!is_first)
<a name="49" id="anc49"></a><span class="line-modified">1794   g_string_append (result, separator);</span>
1795 
1796       g_string_append_len (result, start, end - start);
1797       is_first = FALSE;
1798     }
1799 
1800   if (single_element)
1801     {
1802       g_string_free (result, TRUE);
1803       return g_strdup (single_element);
1804     }
1805   else
1806     {
1807       if (last_trailing)
<a name="50" id="anc50"></a><span class="line-modified">1808   g_string_append (result, last_trailing);</span>
1809 
1810       return g_string_free (result, FALSE);
1811     }
1812 }
1813 
1814 /**
1815  * g_build_pathv:
1816  * @separator: a string used to separator the elements of the path.
1817  * @args: (array zero-terminated=1) (element-type filename): %NULL-terminated
1818  *     array of strings containing the path elements.
1819  *
1820  * Behaves exactly like g_build_path(), but takes the path elements
1821  * as a string array, instead of varargs. This function is mainly
1822  * meant for language bindings.
1823  *
1824  * Returns: (type filename): a newly-allocated string that must be freed
1825  *     with g_free().
1826  *
1827  * Since: 2.8
1828  */
1829 gchar *
1830 g_build_pathv (const gchar  *separator,
<a name="51" id="anc51"></a><span class="line-modified">1831          gchar       **args)</span>
1832 {
1833   if (!args)
1834     return NULL;
1835 
1836   return g_build_path_va (separator, NULL, NULL, args);
1837 }
1838 
1839 
1840 /**
1841  * g_build_path:
1842  * @separator: (type filename): a string used to separator the elements of the path.
1843  * @first_element: (type filename): the first element in the path
1844  * @...: remaining elements in path, terminated by %NULL
1845  *
1846  * Creates a path from a series of elements using @separator as the
1847  * separator between elements. At the boundary between two elements,
1848  * any trailing occurrences of separator in the first element, or
1849  * leading occurrences of separator in the second element are removed
1850  * and exactly one copy of the separator is inserted.
1851  *
1852  * Empty elements are ignored.
1853  *
1854  * The number of leading copies of the separator on the result is
1855  * the same as the number of leading copies of the separator on
1856  * the first non-empty element.
1857  *
1858  * The number of trailing copies of the separator on the result is
1859  * the same as the number of trailing copies of the separator on
1860  * the last non-empty element. (Determination of the number of
1861  * trailing copies is done without stripping leading copies, so
1862  * if the separator is `ABA`, then `ABABA` has 1 trailing copy.)
1863  *
1864  * However, if there is only a single non-empty element, and there
1865  * are no characters in that element not part of the leading or
1866  * trailing separators, then the result is exactly the original value
1867  * of that element.
1868  *
1869  * Other than for determination of the number of leading and trailing
1870  * copies of the separator, elements consisting only of copies
1871  * of the separator are ignored.
1872  *
1873  * Returns: (type filename): a newly-allocated string that must be freed with
1874  *     g_free().
1875  **/
1876 gchar *
1877 g_build_path (const gchar *separator,
<a name="52" id="anc52"></a><span class="line-modified">1878         const gchar *first_element,</span>
<span class="line-modified">1879         ...)</span>
1880 {
1881   gchar *str;
1882   va_list args;
1883 
1884   g_return_val_if_fail (separator != NULL, NULL);
1885 
1886   va_start (args, first_element);
1887   str = g_build_path_va (separator, first_element, &amp;args, NULL);
1888   va_end (args);
1889 
1890   return str;
1891 }
1892 
1893 #ifdef G_OS_WIN32
1894 
1895 static gchar *
1896 g_build_pathname_va (const gchar  *first_element,
<a name="53" id="anc53"></a><span class="line-modified">1897          va_list      *args,</span>
<span class="line-modified">1898          gchar       **str_array)</span>
1899 {
1900   /* Code copied from g_build_pathv(), and modified to use two
1901    * alternative single-character separators.
1902    */
1903   GString *result;
1904   gboolean is_first = TRUE;
1905   gboolean have_leading = FALSE;
1906   const gchar *single_element = NULL;
1907   const gchar *next_element;
1908   const gchar *last_trailing = NULL;
1909   gchar current_separator = &#39;\\&#39;;
1910   gint i = 0;
1911 
1912   result = g_string_new (NULL);
1913 
1914   if (str_array)
1915     next_element = str_array[i++];
1916   else
1917     next_element = first_element;
1918 
1919   while (TRUE)
1920     {
1921       const gchar *element;
1922       const gchar *start;
1923       const gchar *end;
1924 
1925       if (next_element)
<a name="54" id="anc54"></a><span class="line-modified">1926   {</span>
<span class="line-modified">1927     element = next_element;</span>
<span class="line-modified">1928     if (str_array)</span>
<span class="line-modified">1929       next_element = str_array[i++];</span>
<span class="line-modified">1930     else</span>
<span class="line-modified">1931       next_element = va_arg (*args, gchar *);</span>
<span class="line-modified">1932   }</span>
1933       else
<a name="55" id="anc55"></a><span class="line-modified">1934   break;</span>
1935 
1936       /* Ignore empty elements */
1937       if (!*element)
<a name="56" id="anc56"></a><span class="line-modified">1938   continue;</span>
1939 
1940       start = element;
1941 
1942       if (TRUE)
<a name="57" id="anc57"></a><span class="line-modified">1943   {</span>
<span class="line-modified">1944     while (start &amp;&amp;</span>
<span class="line-modified">1945      (*start == &#39;\\&#39; || *start == &#39;/&#39;))</span>
<span class="line-modified">1946       {</span>
<span class="line-modified">1947         current_separator = *start;</span>
<span class="line-modified">1948         start++;</span>
<span class="line-modified">1949       }</span>
<span class="line-modified">1950   }</span>
1951 
1952       end = start + strlen (start);
1953 
1954       if (TRUE)
<a name="58" id="anc58"></a><span class="line-modified">1955   {</span>
<span class="line-modified">1956     while (end &gt;= start + 1 &amp;&amp;</span>
<span class="line-modified">1957      (end[-1] == &#39;\\&#39; || end[-1] == &#39;/&#39;))</span>
<span class="line-modified">1958       {</span>
<span class="line-modified">1959         current_separator = end[-1];</span>
<span class="line-modified">1960         end--;</span>
<span class="line-modified">1961       }</span>
1962 
<a name="59" id="anc59"></a><span class="line-modified">1963     last_trailing = end;</span>
<span class="line-modified">1964     while (last_trailing &gt;= element + 1 &amp;&amp;</span>
<span class="line-modified">1965      (last_trailing[-1] == &#39;\\&#39; || last_trailing[-1] == &#39;/&#39;))</span>
<span class="line-modified">1966       last_trailing--;</span>
1967 
<a name="60" id="anc60"></a><span class="line-modified">1968     if (!have_leading)</span>
<span class="line-modified">1969       {</span>
<span class="line-modified">1970         /* If the leading and trailing separator strings are in the</span>
<span class="line-modified">1971          * same element and overlap, the result is exactly that element</span>
<span class="line-modified">1972          */</span>
<span class="line-modified">1973         if (last_trailing &lt;= start)</span>
<span class="line-modified">1974     single_element = element;</span>
<span class="line-modified">1975 </span>
<span class="line-modified">1976         g_string_append_len (result, element, start - element);</span>
<span class="line-modified">1977         have_leading = TRUE;</span>
<span class="line-modified">1978       }</span>
<span class="line-modified">1979     else</span>
<span class="line-modified">1980       single_element = NULL;</span>
<span class="line-modified">1981   }</span>
1982 
1983       if (end == start)
<a name="61" id="anc61"></a><span class="line-modified">1984   continue;</span>
1985 
1986       if (!is_first)
<a name="62" id="anc62"></a><span class="line-modified">1987   g_string_append_len (result, &amp;current_separator, 1);</span>
1988 
1989       g_string_append_len (result, start, end - start);
1990       is_first = FALSE;
1991     }
1992 
1993   if (single_element)
1994     {
1995       g_string_free (result, TRUE);
1996       return g_strdup (single_element);
1997     }
1998   else
1999     {
2000       if (last_trailing)
<a name="63" id="anc63"></a><span class="line-modified">2001   g_string_append (result, last_trailing);</span>
2002 
2003       return g_string_free (result, FALSE);
2004     }
2005 }
2006 
2007 #endif
2008 
2009 static gchar *
2010 g_build_filename_va (const gchar  *first_argument,
2011                      va_list      *args,
2012                      gchar       **str_array)
2013 {
2014   gchar *str;
2015 
2016 #ifndef G_OS_WIN32
2017   str = g_build_path_va (G_DIR_SEPARATOR_S, first_argument, args, str_array);
2018 #else
2019   str = g_build_pathname_va (first_argument, args, str_array);
2020 #endif
2021 
2022   return str;
2023 }
2024 
2025 /**
2026  * g_build_filename_valist:
2027  * @first_element: (type filename): the first element in the path
2028  * @args: va_list of remaining elements in path
2029  *
2030  * Behaves exactly like g_build_filename(), but takes the path elements
2031  * as a va_list. This function is mainly meant for language bindings.
2032  *
2033  * Returns: (type filename): a newly-allocated string that must be freed
2034  *     with g_free().
2035  *
2036  * Since: 2.56
2037  */
2038 gchar *
2039 g_build_filename_valist (const gchar  *first_element,
2040                          va_list      *args)
2041 {
2042   g_return_val_if_fail (first_element != NULL, NULL);
2043 
2044   return g_build_filename_va (first_element, args, NULL);
2045 }
2046 
2047 /**
2048  * g_build_filenamev:
2049  * @args: (array zero-terminated=1) (element-type filename): %NULL-terminated
2050  *     array of strings containing the path elements.
2051  *
2052  * Behaves exactly like g_build_filename(), but takes the path elements
2053  * as a string array, instead of varargs. This function is mainly
2054  * meant for language bindings.
2055  *
2056  * Returns: (type filename): a newly-allocated string that must be freed
2057  *     with g_free().
2058  *
2059  * Since: 2.8
2060  */
2061 gchar *
2062 g_build_filenamev (gchar **args)
2063 {
2064   return g_build_filename_va (NULL, NULL, args);
2065 }
2066 
2067 /**
2068  * g_build_filename:
2069  * @first_element: (type filename): the first element in the path
2070  * @...: remaining elements in path, terminated by %NULL
2071  *
2072  * Creates a filename from a series of elements using the correct
2073  * separator for filenames.
2074  *
2075  * On Unix, this function behaves identically to `g_build_path
2076  * (G_DIR_SEPARATOR_S, first_element, ....)`.
2077  *
2078  * On Windows, it takes into account that either the backslash
2079  * (`\` or slash (`/`) can be used as separator in filenames, but
2080  * otherwise behaves as on UNIX. When file pathname separators need
2081  * to be inserted, the one that last previously occurred in the
2082  * parameters (reading from left to right) is used.
2083  *
2084  * No attempt is made to force the resulting filename to be an absolute
2085  * path. If the first element is a relative path, the result will
2086  * be a relative path.
2087  *
2088  * Returns: (type filename): a newly-allocated string that must be freed with
2089  *     g_free().
2090  **/
2091 gchar *
2092 g_build_filename (const gchar *first_element,
<a name="64" id="anc64"></a><span class="line-modified">2093       ...)</span>
2094 {
2095   gchar *str;
2096   va_list args;
2097 
2098   va_start (args, first_element);
2099   str = g_build_filename_va (first_element, &amp;args, NULL);
2100   va_end (args);
2101 
2102   return str;
2103 }
2104 
2105 /**
2106  * g_file_read_link:
2107  * @filename: (type filename): the symbolic link
2108  * @error: return location for a #GError
2109  *
2110  * Reads the contents of the symbolic link @filename like the POSIX
2111  * readlink() function.  The returned string is in the encoding used
2112  * for filenames. Use g_filename_to_utf8() to convert it to UTF-8.
2113  *
2114  * Returns: (type filename): A newly-allocated string with the contents of
2115  *     the symbolic link, or %NULL if an error occurred.
2116  *
2117  * Since: 2.4
2118  */
2119 gchar *
2120 g_file_read_link (const gchar  *filename,
<a name="65" id="anc65"></a><span class="line-modified">2121             GError      **error)</span>
2122 {
<a name="66" id="anc66"></a><span class="line-modified">2123 #if defined (HAVE_READLINK)</span>
2124   gchar *buffer;
2125   size_t size;
2126   gssize read_size;
2127 
2128   g_return_val_if_fail (filename != NULL, NULL);
2129   g_return_val_if_fail (error == NULL || *error == NULL, NULL);
2130 
2131   size = 256;
2132   buffer = g_malloc (size);
2133 
2134   while (TRUE)
2135     {
<a name="67" id="anc67"></a>
2136       read_size = readlink (filename, buffer, size);
<a name="68" id="anc68"></a>


2137       if (read_size &lt; 0)
2138         {
2139           int saved_errno = errno;
2140           set_file_error (error,
2141                           filename,
2142                           _(&quot;Failed to read the symbolic link &#39;%s&#39;: %s&quot;),
2143                           saved_errno);
2144           g_free (buffer);
2145           return NULL;
2146         }
2147 
2148       if ((size_t) read_size &lt; size)
2149         {
2150           buffer[read_size] = 0;
2151           return buffer;
2152         }
2153 
2154       size *= 2;
2155       buffer = g_realloc (buffer, size);
2156     }
<a name="69" id="anc69"></a><span class="line-added">2157 #elif defined (G_OS_WIN32)</span>
<span class="line-added">2158   gchar *buffer;</span>
<span class="line-added">2159   gssize read_size;</span>
<span class="line-added">2160 </span>
<span class="line-added">2161   g_return_val_if_fail (filename != NULL, NULL);</span>
<span class="line-added">2162   g_return_val_if_fail (error == NULL || *error == NULL, NULL);</span>
<span class="line-added">2163 </span>
<span class="line-added">2164   read_size = g_win32_readlink_utf8 (filename, NULL, 0, &amp;buffer, TRUE);</span>
<span class="line-added">2165   if (read_size &lt; 0)</span>
<span class="line-added">2166     {</span>
<span class="line-added">2167       int saved_errno = errno;</span>
<span class="line-added">2168       set_file_error (error,</span>
<span class="line-added">2169                       filename,</span>
<span class="line-added">2170                       _(&quot;Failed to read the symbolic link &#39;%s&#39;: %s&quot;),</span>
<span class="line-added">2171                       saved_errno);</span>
<span class="line-added">2172       return NULL;</span>
<span class="line-added">2173     }</span>
<span class="line-added">2174   else if (read_size == 0)</span>
<span class="line-added">2175     return strdup (&quot;&quot;);</span>
<span class="line-added">2176   else</span>
<span class="line-added">2177     return buffer;</span>
2178 #else
2179   g_return_val_if_fail (filename != NULL, NULL);
2180   g_return_val_if_fail (error == NULL || *error == NULL, NULL);
2181 
2182   g_set_error_literal (error,
2183                        G_FILE_ERROR,
2184                        G_FILE_ERROR_INVAL,
2185                        _(&quot;Symbolic links not supported&quot;));
2186 
2187   return NULL;
2188 #endif
2189 }
2190 
2191 /**
2192  * g_path_is_absolute:
2193  * @file_name: (type filename): a file name
2194  *
2195  * Returns %TRUE if the given @file_name is an absolute file name.
2196  * Note that this is a somewhat vague concept on Windows.
2197  *
2198  * On POSIX systems, an absolute file name is well-defined. It always
2199  * starts from the single root directory. For example &quot;/usr/local&quot;.
2200  *
2201  * On Windows, the concepts of current drive and drive-specific
2202  * current directory introduce vagueness. This function interprets as
2203  * an absolute file name one that either begins with a directory
2204  * separator such as &quot;\Users\tml&quot; or begins with the root on a drive,
2205  * for example &quot;C:\Windows&quot;. The first case also includes UNC paths
2206  * such as &quot;\\\\myserver\docs\foo&quot;. In all cases, either slashes or
2207  * backslashes are accepted.
2208  *
2209  * Note that a file name relative to the current drive root does not
2210  * truly specify a file uniquely over time and across processes, as
2211  * the current drive is a per-process value and can be changed.
2212  *
2213  * File names relative the current directory on some specific drive,
2214  * such as &quot;D:foo/bar&quot;, are not interpreted as absolute by this
2215  * function, but they obviously are not relative to the normal current
2216  * directory as returned by getcwd() or g_get_current_dir()
2217  * either. Such paths should be avoided, or need to be handled using
2218  * Windows-specific code.
2219  *
2220  * Returns: %TRUE if @file_name is absolute
2221  */
2222 gboolean
2223 g_path_is_absolute (const gchar *file_name)
2224 {
2225   g_return_val_if_fail (file_name != NULL, FALSE);
2226 
2227   if (G_IS_DIR_SEPARATOR (file_name[0]))
2228     return TRUE;
2229 
2230 #ifdef G_OS_WIN32
2231   /* Recognize drive letter on native Windows */
2232   if (g_ascii_isalpha (file_name[0]) &amp;&amp;
2233       file_name[1] == &#39;:&#39; &amp;&amp; G_IS_DIR_SEPARATOR (file_name[2]))
2234     return TRUE;
2235 #endif
2236 
2237   return FALSE;
2238 }
2239 
2240 /**
2241  * g_path_skip_root:
2242  * @file_name: (type filename): a file name
2243  *
2244  * Returns a pointer into @file_name after the root component,
2245  * i.e. after the &quot;/&quot; in UNIX or &quot;C:\&quot; under Windows. If @file_name
2246  * is not an absolute path it returns %NULL.
2247  *
2248  * Returns: (type filename) (nullable): a pointer into @file_name after the
2249  *     root component
2250  */
2251 const gchar *
2252 g_path_skip_root (const gchar *file_name)
2253 {
2254   g_return_val_if_fail (file_name != NULL, NULL);
2255 
2256 #ifdef G_PLATFORM_WIN32
2257   /* Skip \\server\share or //server/share */
2258   if (G_IS_DIR_SEPARATOR (file_name[0]) &amp;&amp;
2259       G_IS_DIR_SEPARATOR (file_name[1]) &amp;&amp;
2260       file_name[2] &amp;&amp;
2261       !G_IS_DIR_SEPARATOR (file_name[2]))
2262     {
2263       gchar *p;
2264       p = strchr (file_name + 2, G_DIR_SEPARATOR);
2265 
2266 #ifdef G_OS_WIN32
2267       {
2268         gchar *q;
2269 
2270         q = strchr (file_name + 2, &#39;/&#39;);
2271         if (p == NULL || (q != NULL &amp;&amp; q &lt; p))
2272         p = q;
2273       }
2274 #endif
2275 
2276       if (p &amp;&amp; p &gt; file_name + 2 &amp;&amp; p[1])
2277         {
2278           file_name = p + 1;
2279 
2280           while (file_name[0] &amp;&amp; !G_IS_DIR_SEPARATOR (file_name[0]))
2281             file_name++;
2282 
2283           /* Possibly skip a backslash after the share name */
2284           if (G_IS_DIR_SEPARATOR (file_name[0]))
2285             file_name++;
2286 
2287           return (gchar *)file_name;
2288         }
2289     }
2290 #endif
2291 
2292   /* Skip initial slashes */
2293   if (G_IS_DIR_SEPARATOR (file_name[0]))
2294     {
2295       while (G_IS_DIR_SEPARATOR (file_name[0]))
2296         file_name++;
2297       return (gchar *)file_name;
2298     }
2299 
2300 #ifdef G_OS_WIN32
2301   /* Skip X:\ */
2302   if (g_ascii_isalpha (file_name[0]) &amp;&amp;
2303       file_name[1] == &#39;:&#39; &amp;&amp;
2304       G_IS_DIR_SEPARATOR (file_name[2]))
2305     return (gchar *)file_name + 3;
2306 #endif
2307 
2308   return NULL;
2309 }
2310 
2311 /**
2312  * g_basename:
2313  * @file_name: (type filename): the name of the file
2314  *
2315  * Gets the name of the file without any leading directory
2316  * components. It returns a pointer into the given file name
2317  * string.
2318  *
2319  * Returns: (type filename): the name of the file without any leading
2320  *     directory components
2321  *
2322  * Deprecated:2.2: Use g_path_get_basename() instead, but notice
2323  *     that g_path_get_basename() allocates new memory for the
2324  *     returned string, unlike this function which returns a pointer
2325  *     into the argument.
2326  */
2327 const gchar *
2328 g_basename (const gchar *file_name)
2329 {
2330   gchar *base;
2331 
2332   g_return_val_if_fail (file_name != NULL, NULL);
2333 
2334   base = strrchr (file_name, G_DIR_SEPARATOR);
2335 
2336 #ifdef G_OS_WIN32
2337   {
2338     gchar *q;
2339     q = strrchr (file_name, &#39;/&#39;);
2340     if (base == NULL || (q != NULL &amp;&amp; q &gt; base))
2341       base = q;
2342   }
2343 #endif
2344 
2345   if (base)
2346     return base + 1;
2347 
2348 #ifdef G_OS_WIN32
2349   if (g_ascii_isalpha (file_name[0]) &amp;&amp; file_name[1] == &#39;:&#39;)
2350     return (gchar*) file_name + 2;
2351 #endif
2352 
2353   return (gchar*) file_name;
2354 }
2355 
2356 /**
2357  * g_path_get_basename:
2358  * @file_name: (type filename): the name of the file
2359  *
2360  * Gets the last component of the filename.
2361  *
2362  * If @file_name ends with a directory separator it gets the component
2363  * before the last slash. If @file_name consists only of directory
2364  * separators (and on Windows, possibly a drive letter), a single
2365  * separator is returned. If @file_name is empty, it gets &quot;.&quot;.
2366  *
2367  * Returns: (type filename): a newly allocated string containing the last
2368  *    component of the filename
2369  */
2370 gchar *
2371 g_path_get_basename (const gchar *file_name)
2372 {
2373   gssize base;
2374   gssize last_nonslash;
2375   gsize len;
2376   gchar *retval;
2377 
2378   g_return_val_if_fail (file_name != NULL, NULL);
2379 
2380   if (file_name[0] == &#39;\0&#39;)
2381     return g_strdup (&quot;.&quot;);
2382 
2383   last_nonslash = strlen (file_name) - 1;
2384 
2385   while (last_nonslash &gt;= 0 &amp;&amp; G_IS_DIR_SEPARATOR (file_name [last_nonslash]))
2386     last_nonslash--;
2387 
2388   if (last_nonslash == -1)
2389     /* string only containing slashes */
2390     return g_strdup (G_DIR_SEPARATOR_S);
2391 
2392 #ifdef G_OS_WIN32
2393   if (last_nonslash == 1 &amp;&amp;
2394       g_ascii_isalpha (file_name[0]) &amp;&amp;
2395       file_name[1] == &#39;:&#39;)
2396     /* string only containing slashes and a drive */
2397     return g_strdup (G_DIR_SEPARATOR_S);
2398 #endif
2399   base = last_nonslash;
2400 
2401   while (base &gt;=0 &amp;&amp; !G_IS_DIR_SEPARATOR (file_name [base]))
2402     base--;
2403 
2404 #ifdef G_OS_WIN32
2405   if (base == -1 &amp;&amp;
2406       g_ascii_isalpha (file_name[0]) &amp;&amp;
2407       file_name[1] == &#39;:&#39;)
2408     base = 1;
2409 #endif /* G_OS_WIN32 */
2410 
2411   len = last_nonslash - base;
2412   retval = g_malloc (len + 1);
2413   memcpy (retval, file_name + base + 1, len);
2414   retval [len] = &#39;\0&#39;;
2415 
2416   return retval;
2417 }
2418 
2419 /**
2420  * g_dirname:
2421  * @file_name: (type filename): the name of the file
2422  *
2423  * Gets the directory components of a file name.
2424  *
2425  * If the file name has no directory components &quot;.&quot; is returned.
2426  * The returned string should be freed when no longer needed.
2427  *
2428  * Returns: (type filename): the directory components of the file
2429  *
2430  * Deprecated: use g_path_get_dirname() instead
2431  */
2432 
2433 /**
2434  * g_path_get_dirname:
2435  * @file_name: (type filename): the name of the file
2436  *
<a name="70" id="anc70"></a><span class="line-modified">2437  * Gets the directory components of a file name. For example, the directory</span>
<span class="line-added">2438  * component of `/usr/bin/test` is `/usr/bin`. The directory component of `/`</span>
<span class="line-added">2439  * is `/`.</span>
2440  *
2441  * If the file name has no directory components &quot;.&quot; is returned.
2442  * The returned string should be freed when no longer needed.
2443  *
2444  * Returns: (type filename): the directory components of the file
2445  */
2446 gchar *
2447 g_path_get_dirname (const gchar *file_name)
2448 {
2449   gchar *base;
2450   gsize len;
2451 
2452   g_return_val_if_fail (file_name != NULL, NULL);
2453 
2454   base = strrchr (file_name, G_DIR_SEPARATOR);
2455 
2456 #ifdef G_OS_WIN32
2457   {
2458     gchar *q;
2459     q = strrchr (file_name, &#39;/&#39;);
2460     if (base == NULL || (q != NULL &amp;&amp; q &gt; base))
2461       base = q;
2462   }
2463 #endif
2464 
2465   if (!base)
2466     {
2467 #ifdef G_OS_WIN32
2468       if (g_ascii_isalpha (file_name[0]) &amp;&amp; file_name[1] == &#39;:&#39;)
2469         {
2470           gchar drive_colon_dot[4];
2471 
2472           drive_colon_dot[0] = file_name[0];
2473           drive_colon_dot[1] = &#39;:&#39;;
2474           drive_colon_dot[2] = &#39;.&#39;;
2475           drive_colon_dot[3] = &#39;\0&#39;;
2476 
2477           return g_strdup (drive_colon_dot);
2478         }
2479 #endif
2480     return g_strdup (&quot;.&quot;);
2481     }
2482 
2483   while (base &gt; file_name &amp;&amp; G_IS_DIR_SEPARATOR (*base))
2484     base--;
2485 
2486 #ifdef G_OS_WIN32
2487   /* base points to the char before the last slash.
2488    *
2489    * In case file_name is the root of a drive (X:\) or a child of the
2490    * root of a drive (X:\foo), include the slash.
2491    *
2492    * In case file_name is the root share of an UNC path
2493    * (\\server\share), add a slash, returning \\server\share\ .
2494    *
2495    * In case file_name is a direct child of a share in an UNC path
2496    * (\\server\share\foo), include the slash after the share name,
2497    * returning \\server\share\ .
2498    */
2499   if (base == file_name + 1 &amp;&amp;
2500       g_ascii_isalpha (file_name[0]) &amp;&amp;
2501       file_name[1] == &#39;:&#39;)
2502     base++;
2503   else if (G_IS_DIR_SEPARATOR (file_name[0]) &amp;&amp;
2504            G_IS_DIR_SEPARATOR (file_name[1]) &amp;&amp;
2505            file_name[2] &amp;&amp;
2506            !G_IS_DIR_SEPARATOR (file_name[2]) &amp;&amp;
2507            base &gt;= file_name + 2)
2508     {
2509       const gchar *p = file_name + 2;
2510       while (*p &amp;&amp; !G_IS_DIR_SEPARATOR (*p))
2511         p++;
2512       if (p == base + 1)
2513         {
2514           len = (guint) strlen (file_name) + 1;
2515           base = g_new (gchar, len + 1);
2516           strcpy (base, file_name);
2517           base[len-1] = G_DIR_SEPARATOR;
2518           base[len] = 0;
2519           return base;
2520         }
2521       if (G_IS_DIR_SEPARATOR (*p))
2522         {
2523           p++;
2524           while (*p &amp;&amp; !G_IS_DIR_SEPARATOR (*p))
2525             p++;
2526           if (p == base + 1)
2527             base++;
2528         }
2529     }
2530 #endif
2531 
2532   len = (guint) 1 + base - file_name;
2533   base = g_new (gchar, len + 1);
2534   memmove (base, file_name, len);
2535   base[len] = 0;
2536 
2537   return base;
2538 }
2539 
2540 /**
2541  * g_canonicalize_filename:
2542  * @filename: (type filename): the name of the file
2543  * @relative_to: (type filename) (nullable): the relative directory, or %NULL
2544  * to use the current working directory
2545  *
2546  * Gets the canonical file name from @filename. All triple slashes are turned into
2547  * single slashes, and all `..` and `.`s resolved against @relative_to.
2548  *
2549  * Symlinks are not followed, and the returned path is guaranteed to be absolute.
2550  *
2551  * If @filename is an absolute path, @relative_to is ignored. Otherwise,
2552  * @relative_to will be prepended to @filename to make it absolute. @relative_to
2553  * must be an absolute path, or %NULL. If @relative_to is %NULL, it&#39;ll fallback
2554  * to g_get_current_dir().
2555  *
2556  * This function never fails, and will canonicalize file paths even if they don&#39;t
2557  * exist.
2558  *
2559  * No file system I/O is done.
2560  *
2561  * Returns: (type filename) (transfer full): a newly allocated string with the
2562  * canonical file path
2563  * Since: 2.58
2564  */
2565 gchar *
2566 g_canonicalize_filename (const gchar *filename,
2567                          const gchar *relative_to)
2568 {
2569   gchar *canon, *start, *p, *q;
2570   guint i;
2571 
2572   g_return_val_if_fail (relative_to == NULL || g_path_is_absolute (relative_to), NULL);
2573 
2574   if (!g_path_is_absolute (filename))
2575     {
2576       gchar *cwd_allocated = NULL;
2577       const gchar  *cwd;
2578 
2579       if (relative_to != NULL)
2580         cwd = relative_to;
2581       else
2582         cwd = cwd_allocated = g_get_current_dir ();
2583 
2584       canon = g_build_filename (cwd, filename, NULL);
2585       g_free (cwd_allocated);
2586     }
2587   else
2588     {
2589       canon = g_strdup (filename);
2590     }
2591 
2592   start = (char *)g_path_skip_root (canon);
2593 
2594   if (start == NULL)
2595     {
2596       /* This shouldn&#39;t really happen, as g_get_current_dir() should
2597          return an absolute pathname, but bug 573843 shows this is
2598          not always happening */
2599       g_free (canon);
2600       return g_build_filename (G_DIR_SEPARATOR_S, filename, NULL);
2601     }
2602 
2603   /* POSIX allows double slashes at the start to
2604    * mean something special (as does windows too).
2605    * So, &quot;//&quot; != &quot;/&quot;, but more than two slashes
2606    * is treated as &quot;/&quot;.
2607    */
2608   i = 0;
2609   for (p = start - 1;
2610        (p &gt;= canon) &amp;&amp;
2611          G_IS_DIR_SEPARATOR (*p);
2612        p--)
2613     i++;
2614   if (i &gt; 2)
2615     {
2616       i -= 1;
2617       start -= i;
2618       memmove (start, start+i, strlen (start+i) + 1);
2619     }
2620 
2621   /* Make sure we&#39;re using the canonical dir separator */
2622   p++;
2623   while (p &lt; start &amp;&amp; G_IS_DIR_SEPARATOR (*p))
2624     *p++ = G_DIR_SEPARATOR;
2625 
2626   p = start;
2627   while (*p != 0)
2628     {
2629       if (p[0] == &#39;.&#39; &amp;&amp; (p[1] == 0 || G_IS_DIR_SEPARATOR (p[1])))
2630         {
2631           memmove (p, p+1, strlen (p+1)+1);
2632         }
2633       else if (p[0] == &#39;.&#39; &amp;&amp; p[1] == &#39;.&#39; &amp;&amp; (p[2] == 0 || G_IS_DIR_SEPARATOR (p[2])))
2634         {
2635           q = p + 2;
2636           /* Skip previous separator */
2637           p = p - 2;
2638           if (p &lt; start)
2639             p = start;
2640           while (p &gt; start &amp;&amp; !G_IS_DIR_SEPARATOR (*p))
2641             p--;
2642           if (G_IS_DIR_SEPARATOR (*p))
2643             *p++ = G_DIR_SEPARATOR;
2644           memmove (p, q, strlen (q)+1);
2645         }
2646       else
2647         {
2648           /* Skip until next separator */
2649           while (*p != 0 &amp;&amp; !G_IS_DIR_SEPARATOR (*p))
2650             p++;
2651 
2652           if (*p != 0)
2653             {
2654               /* Canonicalize one separator */
2655               *p++ = G_DIR_SEPARATOR;
2656             }
2657         }
2658 
2659       /* Remove additional separators */
2660       q = p;
2661       while (*q &amp;&amp; G_IS_DIR_SEPARATOR (*q))
2662         q++;
2663 
2664       if (p != q)
2665         memmove (p, q, strlen (q) + 1);
2666     }
2667 
2668   /* Remove trailing slashes */
2669   if (p &gt; start &amp;&amp; G_IS_DIR_SEPARATOR (*(p-1)))
2670     *(p-1) = 0;
2671 
2672   return canon;
2673 }
2674 
2675 #if defined(MAXPATHLEN)
2676 #define G_PATH_LENGTH MAXPATHLEN
2677 #elif defined(PATH_MAX)
2678 #define G_PATH_LENGTH PATH_MAX
2679 #elif defined(_PC_PATH_MAX)
2680 #define G_PATH_LENGTH sysconf(_PC_PATH_MAX)
2681 #else
2682 #define G_PATH_LENGTH 2048
2683 #endif
2684 
2685 /**
2686  * g_get_current_dir:
2687  *
2688  * Gets the current directory.
2689  *
2690  * The returned string should be freed when no longer needed.
2691  * The encoding of the returned string is system defined.
2692  * On Windows, it is always UTF-8.
2693  *
2694  * Since GLib 2.40, this function will return the value of the &quot;PWD&quot;
2695  * environment variable if it is set and it happens to be the same as
2696  * the current directory.  This can make a difference in the case that
2697  * the current directory is the target of a symbolic link.
2698  *
2699  * Returns: (type filename): the current directory
2700  */
2701 gchar *
2702 g_get_current_dir (void)
2703 {
2704 #ifdef G_OS_WIN32
2705 
2706   gchar *dir = NULL;
2707   wchar_t dummy[2], *wdir;
2708   int len;
2709 
2710   len = GetCurrentDirectoryW (2, dummy);
2711   wdir = g_new (wchar_t, len);
2712 
2713   if (GetCurrentDirectoryW (len, wdir) == len - 1)
2714     dir = g_utf16_to_utf8 (wdir, -1, NULL, NULL, NULL);
2715 
2716   g_free (wdir);
2717 
2718   if (dir == NULL)
2719     dir = g_strdup (&quot;\\&quot;);
2720 
2721   return dir;
2722 
2723 #else
2724   const gchar *pwd;
2725   gchar *buffer = NULL;
2726   gchar *dir = NULL;
2727   static gulong max_len = 0;
2728   struct stat pwdbuf, dotbuf;
2729 
2730   pwd = g_getenv (&quot;PWD&quot;);
2731   if (pwd != NULL &amp;&amp;
2732       g_stat (&quot;.&quot;, &amp;dotbuf) == 0 &amp;&amp; g_stat (pwd, &amp;pwdbuf) == 0 &amp;&amp;
2733       dotbuf.st_dev == pwdbuf.st_dev &amp;&amp; dotbuf.st_ino == pwdbuf.st_ino)
2734     return g_strdup (pwd);
2735 
2736   if (max_len == 0)
2737     max_len = (G_PATH_LENGTH == -1) ? 2048 : G_PATH_LENGTH;
2738 
2739   while (max_len &lt; G_MAXULONG / 2)
2740     {
2741       g_free (buffer);
2742       buffer = g_new (gchar, max_len + 1);
2743       *buffer = 0;
2744       dir = getcwd (buffer, max_len);
2745 
2746       if (dir || errno != ERANGE)
2747         break;
2748 
2749       max_len *= 2;
2750     }
2751 
2752   if (!dir || !*buffer)
2753     {
2754       /* hm, should we g_error() out here?
2755        * this can happen if e.g. &quot;./&quot; has mode \0000
2756        */
2757       buffer[0] = G_DIR_SEPARATOR;
2758       buffer[1] = 0;
2759     }
2760 
2761   dir = g_strdup (buffer);
2762   g_free (buffer);
2763 
2764   return dir;
2765 
2766 #endif /* !G_OS_WIN32 */
2767 }
2768 
2769 #ifndef GSTREAMER_LITE
2770 #ifdef G_OS_WIN32
2771 
2772 /* Binary compatibility versions. Not for newly compiled code. */
2773 
2774 _GLIB_EXTERN gboolean g_file_test_utf8         (const gchar  *filename,
2775                                                 GFileTest     test);
2776 _GLIB_EXTERN gboolean g_file_get_contents_utf8 (const gchar  *filename,
2777                                                 gchar       **contents,
2778                                                 gsize        *length,
2779                                                 GError      **error);
2780 _GLIB_EXTERN gint     g_mkstemp_utf8           (gchar        *tmpl);
2781 _GLIB_EXTERN gint     g_file_open_tmp_utf8     (const gchar  *tmpl,
2782                                                 gchar       **name_used,
2783                                                 GError      **error);
2784 _GLIB_EXTERN gchar   *g_get_current_dir_utf8   (void);
2785 
2786 
2787 gboolean
2788 g_file_test_utf8 (const gchar *filename,
<a name="71" id="anc71"></a><span class="line-modified">2789                   GFileTest    test)</span>
2790 {
2791   return g_file_test (filename, test);
2792 }
2793 
2794 gboolean
2795 g_file_get_contents_utf8 (const gchar  *filename,
<a name="72" id="anc72"></a><span class="line-modified">2796                           gchar       **contents,</span>
<span class="line-modified">2797                           gsize        *length,</span>
<span class="line-modified">2798                           GError      **error)</span>
2799 {
2800   return g_file_get_contents (filename, contents, length, error);
2801 }
2802 
2803 gint
2804 g_mkstemp_utf8 (gchar *tmpl)
2805 {
2806   return g_mkstemp (tmpl);
2807 }
2808 
2809 gint
2810 g_file_open_tmp_utf8 (const gchar  *tmpl,
<a name="73" id="anc73"></a><span class="line-modified">2811                       gchar       **name_used,</span>
<span class="line-modified">2812                       GError      **error)</span>
2813 {
2814   return g_file_open_tmp (tmpl, name_used, error);
2815 }
2816 
2817 gchar *
2818 g_get_current_dir_utf8 (void)
2819 {
2820   return g_get_current_dir ();
2821 }
2822 
2823 #endif
2824 #endif // GSTREAMER_LITE
<a name="74" id="anc74"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="74" type="hidden" />
</body>
</html>