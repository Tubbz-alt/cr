<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gmarshal.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GObject - GLib Type, Object, Parameter and Signal Library
   2  *
   3  * This library is free software; you can redistribute it and/or
   4  * modify it under the terms of the GNU Lesser General Public
   5  * License as published by the Free Software Foundation; either
   6  * version 2.1 of the License, or (at your option) any later version.
   7  *
   8  * This library is distributed in the hope that it will be useful,
   9  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  11  * Lesser General Public License for more details.
  12  *
  13  * You should have received a copy of the GNU Lesser General
  14  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  15  */
  16 
  17 #include &quot;config.h&quot;
  18 
  19 #include &quot;gobject.h&quot;
  20 #include &quot;genums.h&quot;
  21 #include &quot;gboxed.h&quot;
  22 #include &quot;gvaluetypes.h&quot;
  23 
  24 
  25 #ifdef G_ENABLE_DEBUG
  26 #define g_marshal_value_peek_boolean(v)  g_value_get_boolean (v)
  27 #define g_marshal_value_peek_char(v)     g_value_get_schar (v)
  28 #define g_marshal_value_peek_uchar(v)    g_value_get_uchar (v)
  29 #define g_marshal_value_peek_int(v)      g_value_get_int (v)
  30 #define g_marshal_value_peek_uint(v)     g_value_get_uint (v)
  31 #define g_marshal_value_peek_long(v)     g_value_get_long (v)
  32 #define g_marshal_value_peek_ulong(v)    g_value_get_ulong (v)
  33 #define g_marshal_value_peek_int64(v)    g_value_get_int64 (v)
  34 #define g_marshal_value_peek_uint64(v)   g_value_get_uint64 (v)
  35 #define g_marshal_value_peek_enum(v)     g_value_get_enum (v)
  36 #define g_marshal_value_peek_flags(v)    g_value_get_flags (v)
  37 #define g_marshal_value_peek_float(v)    g_value_get_float (v)
  38 #define g_marshal_value_peek_double(v)   g_value_get_double (v)
  39 #define g_marshal_value_peek_string(v)   (char*) g_value_get_string (v)
  40 #define g_marshal_value_peek_param(v)    g_value_get_param (v)
  41 #define g_marshal_value_peek_boxed(v)    g_value_get_boxed (v)
  42 #define g_marshal_value_peek_pointer(v)  g_value_get_pointer (v)
  43 #define g_marshal_value_peek_object(v)   g_value_get_object (v)
  44 #define g_marshal_value_peek_variant(v)  g_value_get_variant (v)
  45 #else /* !G_ENABLE_DEBUG */
  46 /* WARNING: This code accesses GValues directly, which is UNSUPPORTED API.
  47  *          Do not access GValues directly in your code. Instead, use the
  48  *          g_value_get_*() functions
  49  */
  50 #define g_marshal_value_peek_boolean(v)  (v)-&gt;data[0].v_int
  51 #define g_marshal_value_peek_char(v)     (v)-&gt;data[0].v_int
  52 #define g_marshal_value_peek_uchar(v)    (v)-&gt;data[0].v_uint
  53 #define g_marshal_value_peek_int(v)      (v)-&gt;data[0].v_int
  54 #define g_marshal_value_peek_uint(v)     (v)-&gt;data[0].v_uint
  55 #define g_marshal_value_peek_long(v)     (v)-&gt;data[0].v_long
  56 #define g_marshal_value_peek_ulong(v)    (v)-&gt;data[0].v_ulong
  57 #define g_marshal_value_peek_int64(v)    (v)-&gt;data[0].v_int64
  58 #define g_marshal_value_peek_uint64(v)   (v)-&gt;data[0].v_uint64
  59 #define g_marshal_value_peek_enum(v)     (v)-&gt;data[0].v_long
  60 #define g_marshal_value_peek_flags(v)    (v)-&gt;data[0].v_ulong
  61 #define g_marshal_value_peek_float(v)    (v)-&gt;data[0].v_float
  62 #define g_marshal_value_peek_double(v)   (v)-&gt;data[0].v_double
  63 #define g_marshal_value_peek_string(v)   (v)-&gt;data[0].v_pointer
  64 #define g_marshal_value_peek_param(v)    (v)-&gt;data[0].v_pointer
  65 #define g_marshal_value_peek_boxed(v)    (v)-&gt;data[0].v_pointer
  66 #define g_marshal_value_peek_pointer(v)  (v)-&gt;data[0].v_pointer
  67 #define g_marshal_value_peek_object(v)   (v)-&gt;data[0].v_pointer
  68 #define g_marshal_value_peek_variant(v)  (v)-&gt;data[0].v_pointer
  69 #endif /* !G_ENABLE_DEBUG */
  70 
  71 
  72 /**
  73  * g_cclosure_marshal_VOID__VOID:
  74  * @closure: A #GClosure.
  75  * @return_value: A #GValue to store the return value. May be %NULL
  76  *   if the callback of closure doesn&#39;t return a value.
  77  * @n_param_values: The length of the @param_values array.
  78  * @param_values: An array of #GValues holding the arguments
  79  *   on which to invoke the callback of closure.
  80  * @invocation_hint: The invocation hint given as the last argument to
  81  *   g_closure_invoke().
  82  * @marshal_data: Additional data specified when registering the
  83  *   marshaller, see g_closure_set_marshal() and
  84  *   g_closure_set_meta_marshal()
  85  *
  86  * A #GClosureMarshal function for use with signals with no arguments.
  87  */
  88 /* VOID:VOID */
  89 void
  90 g_cclosure_marshal_VOID__VOID (GClosure     *closure,
  91                                GValue       *return_value G_GNUC_UNUSED,
  92                                guint         n_param_values,
  93                                const GValue *param_values,
  94                                gpointer      invocation_hint G_GNUC_UNUSED,
  95                                gpointer      marshal_data)
  96 {
  97   typedef void (*GMarshalFunc_VOID__VOID) (gpointer     data1,
  98                                            gpointer     data2);
  99   GMarshalFunc_VOID__VOID callback;
 100   GCClosure *cc = (GCClosure*) closure;
 101   gpointer data1, data2;
 102 
 103   g_return_if_fail (n_param_values == 1);
 104 
 105   if (G_CCLOSURE_SWAP_DATA (closure))
 106     {
 107       data1 = closure-&gt;data;
 108       data2 = g_value_peek_pointer (param_values + 0);
 109     }
 110   else
 111     {
 112       data1 = g_value_peek_pointer (param_values + 0);
 113       data2 = closure-&gt;data;
 114     }
 115   callback = (GMarshalFunc_VOID__VOID) (marshal_data ? marshal_data : cc-&gt;callback);
 116 
 117   callback (data1,
 118             data2);
 119 }
 120 
 121 /**
 122  * g_cclosure_marshal_VOID__VOIDv:
 123  * @closure: the #GClosure to which the marshaller belongs
 124  * @return_value: (nullable): a #GValue to store the return
 125  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 126  *  value.
 127  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 128  * @args: va_list of arguments to be passed to the closure.
 129  * @marshal_data: (nullable): additional data specified when
 130  *  registering the marshaller, see g_closure_set_marshal() and
 131  *  g_closure_set_meta_marshal()
 132  * @n_params: the length of the @param_types array
 133  * @param_types: (array length=n_params): the #GType of each argument from
 134  *  @args.
 135  *
 136  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__VOID().
 137  */
 138 void
 139 g_cclosure_marshal_VOID__VOIDv (GClosure     *closure,
 140                                 GValue       *return_value,
 141                                 gpointer      instance,
 142                                 va_list       args,
 143                                 gpointer      marshal_data,
 144                                 int           n_params,
 145                                 GType        *param_types)
 146 {
 147   typedef void (*GMarshalFunc_VOID__VOID) (gpointer     instance,
 148                                            gpointer     data);
 149   GCClosure *cc = (GCClosure*) closure;
 150   gpointer data1, data2;
 151   GMarshalFunc_VOID__VOID callback;
 152 
 153   if (G_CCLOSURE_SWAP_DATA (closure))
 154     {
 155       data1 = closure-&gt;data;
 156       data2 = instance;
 157     }
 158   else
 159     {
 160       data1 = instance;
 161       data2 = closure-&gt;data;
 162     }
 163   callback = (GMarshalFunc_VOID__VOID) (marshal_data ? marshal_data : cc-&gt;callback);
 164 
 165   callback (data1,
 166             data2);
 167 }
 168 
 169 /**
 170  * g_cclosure_marshal_VOID__BOOLEAN:
 171  * @closure: A #GClosure.
 172  * @return_value: A #GValue to store the return value. May be %NULL
 173  *   if the callback of closure doesn&#39;t return a value.
 174  * @n_param_values: The length of the @param_values array.
 175  * @param_values: An array of #GValues holding the arguments
 176  *   on which to invoke the callback of closure.
 177  * @invocation_hint: The invocation hint given as the last argument to
 178  *   g_closure_invoke().
 179  * @marshal_data: Additional data specified when registering the
 180  *   marshaller, see g_closure_set_marshal() and
 181  *   g_closure_set_meta_marshal()
 182  *
 183  * A #GClosureMarshal function for use with signals with a single
 184  * boolean argument.
 185  */
 186 /* VOID:BOOLEAN */
 187 void
 188 g_cclosure_marshal_VOID__BOOLEAN (GClosure     *closure,
 189                                   GValue       *return_value G_GNUC_UNUSED,
 190                                   guint         n_param_values,
 191                                   const GValue *param_values,
 192                                   gpointer      invocation_hint G_GNUC_UNUSED,
 193                                   gpointer      marshal_data)
 194 {
 195   typedef void (*GMarshalFunc_VOID__BOOLEAN) (gpointer     data1,
 196                                               gboolean     arg_1,
 197                                               gpointer     data2);
 198   GMarshalFunc_VOID__BOOLEAN callback;
 199   GCClosure *cc = (GCClosure*) closure;
 200   gpointer data1, data2;
 201 
 202   g_return_if_fail (n_param_values == 2);
 203 
 204   if (G_CCLOSURE_SWAP_DATA (closure))
 205     {
 206       data1 = closure-&gt;data;
 207       data2 = g_value_peek_pointer (param_values + 0);
 208     }
 209   else
 210     {
 211       data1 = g_value_peek_pointer (param_values + 0);
 212       data2 = closure-&gt;data;
 213     }
 214   callback = (GMarshalFunc_VOID__BOOLEAN) (marshal_data ? marshal_data : cc-&gt;callback);
 215 
 216   callback (data1,
 217             g_marshal_value_peek_boolean (param_values + 1),
 218             data2);
 219 }
 220 
 221 /**
 222  * g_cclosure_marshal_VOID__BOOLEANv:
 223  * @closure: the #GClosure to which the marshaller belongs
 224  * @return_value: (nullable): a #GValue to store the return
 225  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 226  *  value.
 227  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 228  * @args: va_list of arguments to be passed to the closure.
 229  * @marshal_data: (nullable): additional data specified when
 230  *  registering the marshaller, see g_closure_set_marshal() and
 231  *  g_closure_set_meta_marshal()
 232  * @n_params: the length of the @param_types array
 233  * @param_types: (array length=n_params): the #GType of each argument from
 234  *  @args.
 235  *
 236  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__BOOLEAN().
 237  */
 238 void
 239 g_cclosure_marshal_VOID__BOOLEANv (GClosure     *closure,
 240                                    GValue       *return_value,
 241                                    gpointer      instance,
 242                                    va_list       args,
 243                                    gpointer      marshal_data,
 244                                    int           n_params,
 245                                    GType        *param_types)
 246 {
 247   typedef void (*GMarshalFunc_VOID__BOOLEAN) (gpointer     instance,
 248                                               gboolean     arg_0,
 249                                               gpointer     data);
 250   GCClosure *cc = (GCClosure*) closure;
 251   gpointer data1, data2;
 252   GMarshalFunc_VOID__BOOLEAN callback;
 253   gboolean arg0;
 254   va_list args_copy;
 255 
 256   G_VA_COPY (args_copy, args);
 257   arg0 = (gboolean) va_arg (args_copy, gboolean);
 258   va_end (args_copy);
 259 
 260   if (G_CCLOSURE_SWAP_DATA (closure))
 261     {
 262       data1 = closure-&gt;data;
 263       data2 = instance;
 264     }
 265   else
 266     {
 267       data1 = instance;
 268       data2 = closure-&gt;data;
 269     }
 270   callback = (GMarshalFunc_VOID__BOOLEAN) (marshal_data ? marshal_data : cc-&gt;callback);
 271 
 272   callback (data1,
 273             arg0,
 274             data2);
 275 }
 276 
 277 /**
 278  * g_cclosure_marshal_VOID__CHAR:
 279  * @closure: A #GClosure.
 280  * @return_value: A #GValue to store the return value. May be %NULL
 281  *   if the callback of closure doesn&#39;t return a value.
 282  * @n_param_values: The length of the @param_values array.
 283  * @param_values: An array of #GValues holding the arguments
 284  *   on which to invoke the callback of closure.
 285  * @invocation_hint: The invocation hint given as the last argument to
 286  *   g_closure_invoke().
 287  * @marshal_data: Additional data specified when registering the
 288  *   marshaller, see g_closure_set_marshal() and
 289  *   g_closure_set_meta_marshal()
 290  *
 291  * A #GClosureMarshal function for use with signals with a single
 292  * character argument.
 293  */
 294 /* VOID:CHAR */
 295 void
 296 g_cclosure_marshal_VOID__CHAR (GClosure     *closure,
 297                                GValue       *return_value G_GNUC_UNUSED,
 298                                guint         n_param_values,
 299                                const GValue *param_values,
 300                                gpointer      invocation_hint G_GNUC_UNUSED,
 301                                gpointer      marshal_data)
 302 {
 303   typedef void (*GMarshalFunc_VOID__CHAR) (gpointer     data1,
 304                                            gchar        arg_1,
 305                                            gpointer     data2);
 306   GMarshalFunc_VOID__CHAR callback;
 307   GCClosure *cc = (GCClosure*) closure;
 308   gpointer data1, data2;
 309 
 310   g_return_if_fail (n_param_values == 2);
 311 
 312   if (G_CCLOSURE_SWAP_DATA (closure))
 313     {
 314       data1 = closure-&gt;data;
 315       data2 = g_value_peek_pointer (param_values + 0);
 316     }
 317   else
 318     {
 319       data1 = g_value_peek_pointer (param_values + 0);
 320       data2 = closure-&gt;data;
 321     }
 322   callback = (GMarshalFunc_VOID__CHAR) (marshal_data ? marshal_data : cc-&gt;callback);
 323 
 324   callback (data1,
 325             g_marshal_value_peek_char (param_values + 1),
 326             data2);
 327 }
 328 
 329 /**
 330  * g_cclosure_marshal_VOID__CHARv:
 331  * @closure: the #GClosure to which the marshaller belongs
 332  * @return_value: (nullable): a #GValue to store the return
 333  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 334  *  value.
 335  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 336  * @args: va_list of arguments to be passed to the closure.
 337  * @marshal_data: (nullable): additional data specified when
 338  *  registering the marshaller, see g_closure_set_marshal() and
 339  *  g_closure_set_meta_marshal()
 340  * @n_params: the length of the @param_types array
 341  * @param_types: (array length=n_params): the #GType of each argument from
 342  *  @args.
 343  *
 344  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__CHAR().
 345  */
 346 void
 347 g_cclosure_marshal_VOID__CHARv (GClosure     *closure,
 348                                 GValue       *return_value,
 349                                 gpointer      instance,
 350                                 va_list       args,
 351                                 gpointer      marshal_data,
 352                                 int           n_params,
 353                                 GType        *param_types)
 354 {
 355   typedef void (*GMarshalFunc_VOID__CHAR) (gpointer     instance,
 356                                            gchar        arg_0,
 357                                            gpointer     data);
 358   GCClosure *cc = (GCClosure*) closure;
 359   gpointer data1, data2;
 360   GMarshalFunc_VOID__CHAR callback;
 361   gchar arg0;
 362   va_list args_copy;
 363 
 364   G_VA_COPY (args_copy, args);
 365   arg0 = (gchar) va_arg (args_copy, gint);
 366   va_end (args_copy);
 367 
 368   if (G_CCLOSURE_SWAP_DATA (closure))
 369     {
 370       data1 = closure-&gt;data;
 371       data2 = instance;
 372     }
 373   else
 374     {
 375       data1 = instance;
 376       data2 = closure-&gt;data;
 377     }
 378   callback = (GMarshalFunc_VOID__CHAR) (marshal_data ? marshal_data : cc-&gt;callback);
 379 
 380   callback (data1,
 381             arg0,
 382             data2);
 383 }
 384 
 385 /**
 386  * g_cclosure_marshal_VOID__UCHAR:
 387  * @closure: A #GClosure.
 388  * @return_value: A #GValue to store the return value. May be %NULL
 389  *   if the callback of closure doesn&#39;t return a value.
 390  * @n_param_values: The length of the @param_values array.
 391  * @param_values: An array of #GValues holding the arguments
 392  *   on which to invoke the callback of closure.
 393  * @invocation_hint: The invocation hint given as the last argument to
 394  *   g_closure_invoke().
 395  * @marshal_data: Additional data specified when registering the
 396  *   marshaller, see g_closure_set_marshal() and
 397  *   g_closure_set_meta_marshal()
 398  *
 399  * A #GClosureMarshal function for use with signals with a single
 400  * unsigned character argument.
 401  */
 402 /* VOID:UCHAR */
 403 void
 404 g_cclosure_marshal_VOID__UCHAR (GClosure     *closure,
 405                                 GValue       *return_value G_GNUC_UNUSED,
 406                                 guint         n_param_values,
 407                                 const GValue *param_values,
 408                                 gpointer      invocation_hint G_GNUC_UNUSED,
 409                                 gpointer      marshal_data)
 410 {
 411   typedef void (*GMarshalFunc_VOID__UCHAR) (gpointer     data1,
 412                                             guchar       arg_1,
 413                                             gpointer     data2);
 414   GMarshalFunc_VOID__UCHAR callback;
 415   GCClosure *cc = (GCClosure*) closure;
 416   gpointer data1, data2;
 417 
 418   g_return_if_fail (n_param_values == 2);
 419 
 420   if (G_CCLOSURE_SWAP_DATA (closure))
 421     {
 422       data1 = closure-&gt;data;
 423       data2 = g_value_peek_pointer (param_values + 0);
 424     }
 425   else
 426     {
 427       data1 = g_value_peek_pointer (param_values + 0);
 428       data2 = closure-&gt;data;
 429     }
 430   callback = (GMarshalFunc_VOID__UCHAR) (marshal_data ? marshal_data : cc-&gt;callback);
 431 
 432   callback (data1,
 433             g_marshal_value_peek_uchar (param_values + 1),
 434             data2);
 435 }
 436 
 437 /**
 438  * g_cclosure_marshal_VOID__UCHARv:
 439  * @closure: the #GClosure to which the marshaller belongs
 440  * @return_value: (nullable): a #GValue to store the return
 441  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 442  *  value.
 443  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 444  * @args: va_list of arguments to be passed to the closure.
 445  * @marshal_data: (nullable): additional data specified when
 446  *  registering the marshaller, see g_closure_set_marshal() and
 447  *  g_closure_set_meta_marshal()
 448  * @n_params: the length of the @param_types array
 449  * @param_types: (array length=n_params): the #GType of each argument from
 450  *  @args.
 451  *
 452  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UCHAR().
 453  */
 454 void
 455 g_cclosure_marshal_VOID__UCHARv (GClosure     *closure,
 456                                  GValue       *return_value,
 457                                  gpointer      instance,
 458                                  va_list       args,
 459                                  gpointer      marshal_data,
 460                                  int           n_params,
 461                                  GType        *param_types)
 462 {
 463   typedef void (*GMarshalFunc_VOID__UCHAR) (gpointer     instance,
 464                                             guchar       arg_0,
 465                                             gpointer     data);
 466   GCClosure *cc = (GCClosure*) closure;
 467   gpointer data1, data2;
 468   GMarshalFunc_VOID__UCHAR callback;
 469   guchar arg0;
 470   va_list args_copy;
 471 
 472   G_VA_COPY (args_copy, args);
 473   arg0 = (guchar) va_arg (args_copy, guint);
 474   va_end (args_copy);
 475 
 476   if (G_CCLOSURE_SWAP_DATA (closure))
 477     {
 478       data1 = closure-&gt;data;
 479       data2 = instance;
 480     }
 481   else
 482     {
 483       data1 = instance;
 484       data2 = closure-&gt;data;
 485     }
 486   callback = (GMarshalFunc_VOID__UCHAR) (marshal_data ? marshal_data : cc-&gt;callback);
 487 
 488   callback (data1,
 489             arg0,
 490             data2);
 491 }
 492 
 493 /**
 494  * g_cclosure_marshal_VOID__INT:
 495  * @closure: A #GClosure.
 496  * @return_value: A #GValue to store the return value. May be %NULL
 497  *   if the callback of closure doesn&#39;t return a value.
 498  * @n_param_values: The length of the @param_values array.
 499  * @param_values: An array of #GValues holding the arguments
 500  *   on which to invoke the callback of closure.
 501  * @invocation_hint: The invocation hint given as the last argument to
 502  *   g_closure_invoke().
 503  * @marshal_data: Additional data specified when registering the
 504  *   marshaller, see g_closure_set_marshal() and
 505  *   g_closure_set_meta_marshal()
 506  *
 507  * A #GClosureMarshal function for use with signals with a single
 508  * integer argument.
 509  */
 510 /* VOID:INT */
 511 void
 512 g_cclosure_marshal_VOID__INT (GClosure     *closure,
 513                               GValue       *return_value G_GNUC_UNUSED,
 514                               guint         n_param_values,
 515                               const GValue *param_values,
 516                               gpointer      invocation_hint G_GNUC_UNUSED,
 517                               gpointer      marshal_data)
 518 {
 519   typedef void (*GMarshalFunc_VOID__INT) (gpointer     data1,
 520                                           gint         arg_1,
 521                                           gpointer     data2);
 522   GMarshalFunc_VOID__INT callback;
 523   GCClosure *cc = (GCClosure*) closure;
 524   gpointer data1, data2;
 525 
 526   g_return_if_fail (n_param_values == 2);
 527 
 528   if (G_CCLOSURE_SWAP_DATA (closure))
 529     {
 530       data1 = closure-&gt;data;
 531       data2 = g_value_peek_pointer (param_values + 0);
 532     }
 533   else
 534     {
 535       data1 = g_value_peek_pointer (param_values + 0);
 536       data2 = closure-&gt;data;
 537     }
 538   callback = (GMarshalFunc_VOID__INT) (marshal_data ? marshal_data : cc-&gt;callback);
 539 
 540   callback (data1,
 541             g_marshal_value_peek_int (param_values + 1),
 542             data2);
 543 }
 544 
 545 /**
 546  * g_cclosure_marshal_VOID__INTv:
 547  * @closure: the #GClosure to which the marshaller belongs
 548  * @return_value: (nullable): a #GValue to store the return
 549  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 550  *  value.
 551  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 552  * @args: va_list of arguments to be passed to the closure.
 553  * @marshal_data: (nullable): additional data specified when
 554  *  registering the marshaller, see g_closure_set_marshal() and
 555  *  g_closure_set_meta_marshal()
 556  * @n_params: the length of the @param_types array
 557  * @param_types: (array length=n_params): the #GType of each argument from
 558  *  @args.
 559  *
 560  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__INT().
 561  */
 562 void
 563 g_cclosure_marshal_VOID__INTv (GClosure     *closure,
 564                                GValue       *return_value,
 565                                gpointer      instance,
 566                                va_list       args,
 567                                gpointer      marshal_data,
 568                                int           n_params,
 569                                GType        *param_types)
 570 {
 571   typedef void (*GMarshalFunc_VOID__INT) (gpointer     instance,
 572                                           gint         arg_0,
 573                                           gpointer     data);
 574   GCClosure *cc = (GCClosure*) closure;
 575   gpointer data1, data2;
 576   GMarshalFunc_VOID__INT callback;
 577   gint arg0;
 578   va_list args_copy;
 579 
 580  G_VA_COPY (args_copy, args);
 581   arg0 = (gint) va_arg (args_copy, gint);
 582   va_end (args_copy);
 583 
 584   if (G_CCLOSURE_SWAP_DATA (closure))
 585     {
 586       data1 = closure-&gt;data;
 587       data2 = instance;
 588     }
 589   else
 590     {
 591       data1 = instance;
 592       data2 = closure-&gt;data;
 593     }
 594   callback = (GMarshalFunc_VOID__INT) (marshal_data ? marshal_data : cc-&gt;callback);
 595 
 596   callback (data1,
 597             arg0,
 598             data2);
 599 }
 600 
 601 /**
 602  * g_cclosure_marshal_VOID__UINT:
 603  * @closure: A #GClosure.
 604  * @return_value: A #GValue to store the return value. May be %NULL
 605  *   if the callback of closure doesn&#39;t return a value.
 606  * @n_param_values: The length of the @param_values array.
 607  * @param_values: An array of #GValues holding the arguments
 608  *   on which to invoke the callback of closure.
 609  * @invocation_hint: The invocation hint given as the last argument to
 610  *   g_closure_invoke().
 611  * @marshal_data: Additional data specified when registering the
 612  *   marshaller, see g_closure_set_marshal() and
 613  *   g_closure_set_meta_marshal()
 614  *
 615  * A #GClosureMarshal function for use with signals with with a single
 616  * unsigned integer argument.
 617  */
 618 /* VOID:UINT */
 619 void
 620 g_cclosure_marshal_VOID__UINT (GClosure     *closure,
 621                                GValue       *return_value G_GNUC_UNUSED,
 622                                guint         n_param_values,
 623                                const GValue *param_values,
 624                                gpointer      invocation_hint G_GNUC_UNUSED,
 625                                gpointer      marshal_data)
 626 {
 627   typedef void (*GMarshalFunc_VOID__UINT) (gpointer     data1,
 628                                            guint        arg_1,
 629                                            gpointer     data2);
 630   GMarshalFunc_VOID__UINT callback;
 631   GCClosure *cc = (GCClosure*) closure;
 632   gpointer data1, data2;
 633 
 634   g_return_if_fail (n_param_values == 2);
 635 
 636   if (G_CCLOSURE_SWAP_DATA (closure))
 637     {
 638       data1 = closure-&gt;data;
 639       data2 = g_value_peek_pointer (param_values + 0);
 640     }
 641   else
 642     {
 643       data1 = g_value_peek_pointer (param_values + 0);
 644       data2 = closure-&gt;data;
 645     }
 646   callback = (GMarshalFunc_VOID__UINT) (marshal_data ? marshal_data : cc-&gt;callback);
 647 
 648   callback (data1,
 649             g_marshal_value_peek_uint (param_values + 1),
 650             data2);
 651 }
 652 
 653 /**
 654  * g_cclosure_marshal_VOID__UINTv:
 655  * @closure: the #GClosure to which the marshaller belongs
 656  * @return_value: (nullable): a #GValue to store the return
 657  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 658  *  value.
 659  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 660  * @args: va_list of arguments to be passed to the closure.
 661  * @marshal_data: (nullable): additional data specified when
 662  *  registering the marshaller, see g_closure_set_marshal() and
 663  *  g_closure_set_meta_marshal()
 664  * @n_params: the length of the @param_types array
 665  * @param_types: (array length=n_params): the #GType of each argument from
 666  *  @args.
 667  *
 668  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UINT().
 669  */
 670 void
 671 g_cclosure_marshal_VOID__UINTv (GClosure     *closure,
 672                                 GValue       *return_value,
 673                                 gpointer      instance,
 674                                 va_list       args,
 675                                 gpointer      marshal_data,
 676                                 int           n_params,
 677                                 GType        *param_types)
 678 {
 679   typedef void (*GMarshalFunc_VOID__UINT) (gpointer     instance,
 680                                            guint        arg_0,
 681                                            gpointer     data);
 682   GCClosure *cc = (GCClosure*) closure;
 683   gpointer data1, data2;
 684   GMarshalFunc_VOID__UINT callback;
 685   guint arg0;
 686   va_list args_copy;
 687 
 688   G_VA_COPY (args_copy, args);
 689   arg0 = (guint) va_arg (args_copy, guint);
 690   va_end (args_copy);
 691 
 692   if (G_CCLOSURE_SWAP_DATA (closure))
 693     {
 694       data1 = closure-&gt;data;
 695       data2 = instance;
 696     }
 697   else
 698     {
 699       data1 = instance;
 700       data2 = closure-&gt;data;
 701     }
 702   callback = (GMarshalFunc_VOID__UINT) (marshal_data ? marshal_data : cc-&gt;callback);
 703 
 704   callback (data1,
 705             arg0,
 706             data2);
 707 }
 708 
 709 /**
 710  * g_cclosure_marshal_VOID__LONG:
 711  * @closure: A #GClosure.
 712  * @return_value: A #GValue to store the return value. May be %NULL
 713  *   if the callback of closure doesn&#39;t return a value.
 714  * @n_param_values: The length of the @param_values array.
 715  * @param_values: An array of #GValues holding the arguments
 716  *   on which to invoke the callback of closure.
 717  * @invocation_hint: The invocation hint given as the last argument to
 718  *   g_closure_invoke().
 719  * @marshal_data: Additional data specified when registering the
 720  *   marshaller, see g_closure_set_marshal() and
 721  *   g_closure_set_meta_marshal()
 722  *
 723  * A #GClosureMarshal function for use with signals with with a single
 724  * long integer argument.
 725  */
 726 /* VOID:LONG */
 727 void
 728 g_cclosure_marshal_VOID__LONG (GClosure     *closure,
 729                                GValue       *return_value G_GNUC_UNUSED,
 730                                guint         n_param_values,
 731                                const GValue *param_values,
 732                                gpointer      invocation_hint G_GNUC_UNUSED,
 733                                gpointer      marshal_data)
 734 {
 735   typedef void (*GMarshalFunc_VOID__LONG) (gpointer     data1,
 736                                            glong        arg_1,
 737                                            gpointer     data2);
 738   GMarshalFunc_VOID__LONG callback;
 739   GCClosure *cc = (GCClosure*) closure;
 740   gpointer data1, data2;
 741 
 742   g_return_if_fail (n_param_values == 2);
 743 
 744   if (G_CCLOSURE_SWAP_DATA (closure))
 745     {
 746       data1 = closure-&gt;data;
 747       data2 = g_value_peek_pointer (param_values + 0);
 748     }
 749   else
 750     {
 751       data1 = g_value_peek_pointer (param_values + 0);
 752       data2 = closure-&gt;data;
 753     }
 754   callback = (GMarshalFunc_VOID__LONG) (marshal_data ? marshal_data : cc-&gt;callback);
 755 
 756   callback (data1,
 757             g_marshal_value_peek_long (param_values + 1),
 758             data2);
 759 }
 760 
 761 /**
 762  * g_cclosure_marshal_VOID__LONGv:
 763  * @closure: the #GClosure to which the marshaller belongs
 764  * @return_value: (nullable): a #GValue to store the return
 765  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 766  *  value.
 767  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 768  * @args: va_list of arguments to be passed to the closure.
 769  * @marshal_data: (nullable): additional data specified when
 770  *  registering the marshaller, see g_closure_set_marshal() and
 771  *  g_closure_set_meta_marshal()
 772  * @n_params: the length of the @param_types array
 773  * @param_types: (array length=n_params): the #GType of each argument from
 774  *  @args.
 775  *
 776  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__LONG().
 777  */
 778 void
 779 g_cclosure_marshal_VOID__LONGv (GClosure     *closure,
 780                                 GValue       *return_value,
 781                                 gpointer      instance,
 782                                 va_list       args,
 783                                 gpointer      marshal_data,
 784                                 int           n_params,
 785                                 GType        *param_types)
 786 {
 787   typedef void (*GMarshalFunc_VOID__LONG) (gpointer     instance,
 788                                            glong        arg_0,
 789                                            gpointer     data);
 790   GCClosure *cc = (GCClosure*) closure;
 791   gpointer data1, data2;
 792   GMarshalFunc_VOID__LONG callback;
 793   glong arg0;
 794   va_list args_copy;
 795 
 796   G_VA_COPY (args_copy, args);
 797   arg0 = (glong) va_arg (args_copy, glong);
 798   va_end (args_copy);
 799 
 800   if (G_CCLOSURE_SWAP_DATA (closure))
 801     {
 802       data1 = closure-&gt;data;
 803       data2 = instance;
 804     }
 805   else
 806     {
 807       data1 = instance;
 808       data2 = closure-&gt;data;
 809     }
 810   callback = (GMarshalFunc_VOID__LONG) (marshal_data ? marshal_data : cc-&gt;callback);
 811 
 812   callback (data1,
 813             arg0,
 814             data2);
 815 }
 816 
 817 /**
 818  * g_cclosure_marshal_VOID__ULONG:
 819  * @closure: A #GClosure.
 820  * @return_value: A #GValue to store the return value. May be %NULL
 821  *   if the callback of closure doesn&#39;t return a value.
 822  * @n_param_values: The length of the @param_values array.
 823  * @param_values: An array of #GValues holding the arguments
 824  *   on which to invoke the callback of closure.
 825  * @invocation_hint: The invocation hint given as the last argument to
 826  *   g_closure_invoke().
 827  * @marshal_data: Additional data specified when registering the
 828  *   marshaller, see g_closure_set_marshal() and
 829  *   g_closure_set_meta_marshal()
 830  *
 831  * A #GClosureMarshal function for use with signals with a single
 832  * unsigned long integer argument.
 833  */
 834 /* VOID:ULONG */
 835 void
 836 g_cclosure_marshal_VOID__ULONG (GClosure     *closure,
 837                                 GValue       *return_value G_GNUC_UNUSED,
 838                                 guint         n_param_values,
 839                                 const GValue *param_values,
 840                                 gpointer      invocation_hint G_GNUC_UNUSED,
 841                                 gpointer      marshal_data)
 842 {
 843   typedef void (*GMarshalFunc_VOID__ULONG) (gpointer     data1,
 844                                             gulong       arg_1,
 845                                             gpointer     data2);
 846   GMarshalFunc_VOID__ULONG callback;
 847   GCClosure *cc = (GCClosure*) closure;
 848   gpointer data1, data2;
 849 
 850   g_return_if_fail (n_param_values == 2);
 851 
 852   if (G_CCLOSURE_SWAP_DATA (closure))
 853     {
 854       data1 = closure-&gt;data;
 855       data2 = g_value_peek_pointer (param_values + 0);
 856     }
 857   else
 858     {
 859       data1 = g_value_peek_pointer (param_values + 0);
 860       data2 = closure-&gt;data;
 861     }
 862   callback = (GMarshalFunc_VOID__ULONG) (marshal_data ? marshal_data : cc-&gt;callback);
 863 
 864   callback (data1,
 865             g_marshal_value_peek_ulong (param_values + 1),
 866             data2);
 867 }
 868 
 869 /**
 870  * g_cclosure_marshal_VOID__ULONGv:
 871  * @closure: the #GClosure to which the marshaller belongs
 872  * @return_value: (nullable): a #GValue to store the return
 873  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 874  *  value.
 875  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 876  * @args: va_list of arguments to be passed to the closure.
 877  * @marshal_data: (nullable): additional data specified when
 878  *  registering the marshaller, see g_closure_set_marshal() and
 879  *  g_closure_set_meta_marshal()
 880  * @n_params: the length of the @param_types array
 881  * @param_types: (array length=n_params): the #GType of each argument from
 882  *  @args.
 883  *
 884  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__ULONG().
 885  */
 886 void
 887 g_cclosure_marshal_VOID__ULONGv (GClosure     *closure,
 888                                  GValue       *return_value,
 889                                  gpointer      instance,
 890                                  va_list       args,
 891                                  gpointer      marshal_data,
 892                                  int           n_params,
 893                                  GType        *param_types)
 894 {
 895   typedef void (*GMarshalFunc_VOID__ULONG) (gpointer     instance,
 896                                             gulong       arg_0,
 897                                             gpointer     data);
 898   GCClosure *cc = (GCClosure*) closure;
 899   gpointer data1, data2;
 900   GMarshalFunc_VOID__ULONG callback;
 901   gulong arg0;
 902   va_list args_copy;
 903 
 904   G_VA_COPY (args_copy, args);
 905   arg0 = (gulong) va_arg (args_copy, gulong);
 906   va_end (args_copy);
 907 
 908   if (G_CCLOSURE_SWAP_DATA (closure))
 909     {
 910       data1 = closure-&gt;data;
 911       data2 = instance;
 912     }
 913   else
 914     {
 915       data1 = instance;
 916       data2 = closure-&gt;data;
 917     }
 918   callback = (GMarshalFunc_VOID__ULONG) (marshal_data ? marshal_data : cc-&gt;callback);
 919 
 920   callback (data1,
 921             arg0,
 922             data2);
 923 }
 924 
 925 /**
 926  * g_cclosure_marshal_VOID__ENUM:
 927  * @closure: A #GClosure.
 928  * @return_value: A #GValue to store the return value. May be %NULL
 929  *   if the callback of closure doesn&#39;t return a value.
 930  * @n_param_values: The length of the @param_values array.
 931  * @param_values: An array of #GValues holding the arguments
 932  *   on which to invoke the callback of closure.
 933  * @invocation_hint: The invocation hint given as the last argument to
 934  *   g_closure_invoke().
 935  * @marshal_data: Additional data specified when registering the
 936  *   marshaller, see g_closure_set_marshal() and
 937  *   g_closure_set_meta_marshal()
 938  *
 939  * A #GClosureMarshal function for use with signals with a single
 940  * argument with an enumerated type.
 941  */
 942 /* VOID:ENUM */
 943 void
 944 g_cclosure_marshal_VOID__ENUM (GClosure     *closure,
 945                                GValue       *return_value G_GNUC_UNUSED,
 946                                guint         n_param_values,
 947                                const GValue *param_values,
 948                                gpointer      invocation_hint G_GNUC_UNUSED,
 949                                gpointer      marshal_data)
 950 {
 951   typedef void (*GMarshalFunc_VOID__ENUM) (gpointer     data1,
 952                                            gint         arg_1,
 953                                            gpointer     data2);
 954   GMarshalFunc_VOID__ENUM callback;
 955   GCClosure *cc = (GCClosure*) closure;
 956   gpointer data1, data2;
 957 
 958   g_return_if_fail (n_param_values == 2);
 959 
 960   if (G_CCLOSURE_SWAP_DATA (closure))
 961     {
 962       data1 = closure-&gt;data;
 963       data2 = g_value_peek_pointer (param_values + 0);
 964     }
 965   else
 966     {
 967       data1 = g_value_peek_pointer (param_values + 0);
 968       data2 = closure-&gt;data;
 969     }
 970   callback = (GMarshalFunc_VOID__ENUM) (marshal_data ? marshal_data : cc-&gt;callback);
 971 
 972   callback (data1,
 973             g_marshal_value_peek_enum (param_values + 1),
 974             data2);
 975 }
 976 
 977 /**
 978  * g_cclosure_marshal_VOID__ENUMv:
 979  * @closure: the #GClosure to which the marshaller belongs
 980  * @return_value: (nullable): a #GValue to store the return
 981  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 982  *  value.
 983  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 984  * @args: va_list of arguments to be passed to the closure.
 985  * @marshal_data: (nullable): additional data specified when
 986  *  registering the marshaller, see g_closure_set_marshal() and
 987  *  g_closure_set_meta_marshal()
 988  * @n_params: the length of the @param_types array
 989  * @param_types: (array length=n_params): the #GType of each argument from
 990  *  @args.
 991  *
 992  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__ENUM().
 993  */
 994 void
 995 g_cclosure_marshal_VOID__ENUMv (GClosure     *closure,
 996                                 GValue       *return_value,
 997                                 gpointer      instance,
 998                                 va_list       args,
 999                                 gpointer      marshal_data,
1000                                 int           n_params,
1001                                 GType        *param_types)
1002 {
1003   typedef void (*GMarshalFunc_VOID__ENUM) (gpointer     instance,
1004                                            gint         arg_0,
1005                                            gpointer     data);
1006   GCClosure *cc = (GCClosure*) closure;
1007   gpointer data1, data2;
1008   GMarshalFunc_VOID__ENUM callback;
1009   gint arg0;
1010   va_list args_copy;
1011 
1012   G_VA_COPY (args_copy, args);
1013   arg0 = (gint) va_arg (args_copy, gint);
1014   va_end (args_copy);
1015 
1016   if (G_CCLOSURE_SWAP_DATA (closure))
1017     {
1018       data1 = closure-&gt;data;
1019       data2 = instance;
1020     }
1021   else
1022     {
1023       data1 = instance;
1024       data2 = closure-&gt;data;
1025     }
1026   callback = (GMarshalFunc_VOID__ENUM) (marshal_data ? marshal_data : cc-&gt;callback);
1027 
1028   callback (data1,
1029             arg0,
1030             data2);
1031 }
1032 
1033 /**
1034  * g_cclosure_marshal_VOID__FLAGS:
1035  * @closure: A #GClosure.
1036  * @return_value: A #GValue to store the return value. May be %NULL
1037  *   if the callback of closure doesn&#39;t return a value.
1038  * @n_param_values: The length of the @param_values array.
1039  * @param_values: An array of #GValues holding the arguments
1040  *   on which to invoke the callback of closure.
1041  * @invocation_hint: The invocation hint given as the last argument to
1042  *   g_closure_invoke().
1043  * @marshal_data: Additional data specified when registering the
1044  *   marshaller, see g_closure_set_marshal() and
1045  *   g_closure_set_meta_marshal()
1046  *
1047  * A #GClosureMarshal function for use with signals with a single
1048  * argument with a flags types.
1049  */
1050 /* VOID:FLAGS */
1051 void
1052 g_cclosure_marshal_VOID__FLAGS (GClosure     *closure,
1053                                 GValue       *return_value G_GNUC_UNUSED,
1054                                 guint         n_param_values,
1055                                 const GValue *param_values,
1056                                 gpointer      invocation_hint G_GNUC_UNUSED,
1057                                 gpointer      marshal_data)
1058 {
1059   typedef void (*GMarshalFunc_VOID__FLAGS) (gpointer     data1,
1060                                             guint        arg_1,
1061                                             gpointer     data2);
1062   GMarshalFunc_VOID__FLAGS callback;
1063   GCClosure *cc = (GCClosure*) closure;
1064   gpointer data1, data2;
1065 
1066   g_return_if_fail (n_param_values == 2);
1067 
1068   if (G_CCLOSURE_SWAP_DATA (closure))
1069     {
1070       data1 = closure-&gt;data;
1071       data2 = g_value_peek_pointer (param_values + 0);
1072     }
1073   else
1074     {
1075       data1 = g_value_peek_pointer (param_values + 0);
1076       data2 = closure-&gt;data;
1077     }
1078   callback = (GMarshalFunc_VOID__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
1079 
1080   callback (data1,
1081             g_marshal_value_peek_flags (param_values + 1),
1082             data2);
1083 }
1084 
1085 /**
1086  * g_cclosure_marshal_VOID__FLAGSv:
1087  * @closure: the #GClosure to which the marshaller belongs
1088  * @return_value: (nullable): a #GValue to store the return
1089  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
1090  *  value.
1091  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
1092  * @args: va_list of arguments to be passed to the closure.
1093  * @marshal_data: (nullable): additional data specified when
1094  *  registering the marshaller, see g_closure_set_marshal() and
1095  *  g_closure_set_meta_marshal()
1096  * @n_params: the length of the @param_types array
1097  * @param_types: (array length=n_params): the #GType of each argument from
1098  *  @args.
1099  *
1100  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__FLAGS().
1101  */
1102 void
1103 g_cclosure_marshal_VOID__FLAGSv (GClosure     *closure,
1104                                  GValue       *return_value,
1105                                  gpointer      instance,
1106                                  va_list       args,
1107                                  gpointer      marshal_data,
1108                                  int           n_params,
1109                                  GType        *param_types)
1110 {
1111   typedef void (*GMarshalFunc_VOID__FLAGS) (gpointer     instance,
1112                                             guint        arg_0,
1113                                             gpointer     data);
1114   GCClosure *cc = (GCClosure*) closure;
1115   gpointer data1, data2;
1116   GMarshalFunc_VOID__FLAGS callback;
1117   guint arg0;
1118   va_list args_copy;
1119 
1120   G_VA_COPY (args_copy, args);
1121   arg0 = (guint) va_arg (args_copy, guint);
1122   va_end (args_copy);
1123 
1124   if (G_CCLOSURE_SWAP_DATA (closure))
1125     {
1126       data1 = closure-&gt;data;
1127       data2 = instance;
1128     }
1129   else
1130     {
1131       data1 = instance;
1132       data2 = closure-&gt;data;
1133     }
1134   callback = (GMarshalFunc_VOID__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
1135 
1136   callback (data1,
1137             arg0,
1138             data2);
1139 }
1140 
1141 /**
1142  * g_cclosure_marshal_VOID__FLOAT:
1143  * @closure: A #GClosure.
1144  * @return_value: A #GValue to store the return value. May be %NULL
1145  *   if the callback of closure doesn&#39;t return a value.
1146  * @n_param_values: The length of the @param_values array.
1147  * @param_values: An array of #GValues holding the arguments
1148  *   on which to invoke the callback of closure.
1149  * @invocation_hint: The invocation hint given as the last argument to
1150  *   g_closure_invoke().
1151  * @marshal_data: Additional data specified when registering the
1152  *   marshaller, see g_closure_set_marshal() and
1153  *   g_closure_set_meta_marshal()
1154  *
1155  * A #GClosureMarshal function for use with signals with one
1156  * single-precision floating point argument.
1157  */
1158 /* VOID:FLOAT */
1159 void
1160 g_cclosure_marshal_VOID__FLOAT (GClosure     *closure,
1161                                 GValue       *return_value G_GNUC_UNUSED,
1162                                 guint         n_param_values,
1163                                 const GValue *param_values,
1164                                 gpointer      invocation_hint G_GNUC_UNUSED,
1165                                 gpointer      marshal_data)
1166 {
1167   typedef void (*GMarshalFunc_VOID__FLOAT) (gpointer     data1,
1168                                             gfloat       arg_1,
1169                                             gpointer     data2);
1170   GMarshalFunc_VOID__FLOAT callback;
1171   GCClosure *cc = (GCClosure*) closure;
1172   gpointer data1, data2;
1173 
1174   g_return_if_fail (n_param_values == 2);
1175 
1176   if (G_CCLOSURE_SWAP_DATA (closure))
1177     {
1178       data1 = closure-&gt;data;
1179       data2 = g_value_peek_pointer (param_values + 0);
1180     }
1181   else
1182     {
1183       data1 = g_value_peek_pointer (param_values + 0);
1184       data2 = closure-&gt;data;
1185     }
1186   callback = (GMarshalFunc_VOID__FLOAT) (marshal_data ? marshal_data : cc-&gt;callback);
1187 
1188   callback (data1,
1189             g_marshal_value_peek_float (param_values + 1),
1190             data2);
1191 }
1192 
1193 /**
1194  * g_cclosure_marshal_VOID__FLOATv:
1195  * @closure: the #GClosure to which the marshaller belongs
1196  * @return_value: (nullable): a #GValue to store the return
1197  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
1198  *  value.
1199  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
1200  * @args: va_list of arguments to be passed to the closure.
1201  * @marshal_data: (nullable): additional data specified when
1202  *  registering the marshaller, see g_closure_set_marshal() and
1203  *  g_closure_set_meta_marshal()
1204  * @n_params: the length of the @param_types array
1205  * @param_types: (array length=n_params): the #GType of each argument from
1206  *  @args.
1207  *
1208  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__FLOAT().
1209  */
1210 void
1211 g_cclosure_marshal_VOID__FLOATv (GClosure     *closure,
1212                                  GValue       *return_value,
1213                                  gpointer      instance,
1214                                  va_list       args,
1215                                  gpointer      marshal_data,
1216                                  int           n_params,
1217                                  GType        *param_types)
1218 {
1219   typedef void (*GMarshalFunc_VOID__FLOAT) (gpointer     instance,
1220                                             gfloat       arg_0,
1221                                             gpointer     data);
1222   GCClosure *cc = (GCClosure*) closure;
1223   gpointer data1, data2;
1224   GMarshalFunc_VOID__FLOAT callback;
1225   gfloat arg0;
1226   va_list args_copy;
1227 
1228   G_VA_COPY (args_copy, args);
1229   arg0 = (gfloat) va_arg (args_copy, gdouble);
1230   va_end (args_copy);
1231 
1232   if (G_CCLOSURE_SWAP_DATA (closure))
1233     {
1234       data1 = closure-&gt;data;
1235       data2 = instance;
1236     }
1237   else
1238     {
1239       data1 = instance;
1240       data2 = closure-&gt;data;
1241     }
1242   callback = (GMarshalFunc_VOID__FLOAT) (marshal_data ? marshal_data : cc-&gt;callback);
1243 
1244   callback (data1,
1245             arg0,
1246             data2);
1247 }
1248 
1249 /**
1250  * g_cclosure_marshal_VOID__DOUBLE:
1251  * @closure: A #GClosure.
1252  * @return_value: A #GValue to store the return value. May be %NULL
1253  *   if the callback of closure doesn&#39;t return a value.
1254  * @n_param_values: The length of the @param_values array.
1255  * @param_values: An array of #GValues holding the arguments
1256  *   on which to invoke the callback of closure.
1257  * @invocation_hint: The invocation hint given as the last argument to
1258  *   g_closure_invoke().
1259  * @marshal_data: Additional data specified when registering the
1260  *   marshaller, see g_closure_set_marshal() and
1261  *   g_closure_set_meta_marshal()
1262  *
1263  * A #GClosureMarshal function for use with signals with one
1264  * double-precision floating point argument.
1265  */
1266 /* VOID:DOUBLE */
1267 void
1268 g_cclosure_marshal_VOID__DOUBLE (GClosure     *closure,
1269                                  GValue       *return_value G_GNUC_UNUSED,
1270                                  guint         n_param_values,
1271                                  const GValue *param_values,
1272                                  gpointer      invocation_hint G_GNUC_UNUSED,
1273                                  gpointer      marshal_data)
1274 {
1275   typedef void (*GMarshalFunc_VOID__DOUBLE) (gpointer     data1,
1276                                              gdouble      arg_1,
1277                                              gpointer     data2);
1278   GMarshalFunc_VOID__DOUBLE callback;
1279   GCClosure *cc = (GCClosure*) closure;
1280   gpointer data1, data2;
1281 
1282   g_return_if_fail (n_param_values == 2);
1283 
1284   if (G_CCLOSURE_SWAP_DATA (closure))
1285     {
1286       data1 = closure-&gt;data;
1287       data2 = g_value_peek_pointer (param_values + 0);
1288     }
1289   else
1290     {
1291       data1 = g_value_peek_pointer (param_values + 0);
1292       data2 = closure-&gt;data;
1293     }
1294   callback = (GMarshalFunc_VOID__DOUBLE) (marshal_data ? marshal_data : cc-&gt;callback);
1295 
1296   callback (data1,
1297             g_marshal_value_peek_double (param_values + 1),
1298             data2);
1299 }
1300 
1301 /**
1302  * g_cclosure_marshal_VOID__DOUBLEv:
1303  * @closure: the #GClosure to which the marshaller belongs
1304  * @return_value: (nullable): a #GValue to store the return
1305  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
1306  *  value.
1307  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
1308  * @args: va_list of arguments to be passed to the closure.
1309  * @marshal_data: (nullable): additional data specified when
1310  *  registering the marshaller, see g_closure_set_marshal() and
1311  *  g_closure_set_meta_marshal()
1312  * @n_params: the length of the @param_types array
1313  * @param_types: (array length=n_params): the #GType of each argument from
1314  *  @args.
1315  *
1316  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__DOUBLE().
1317  */
1318 void
1319 g_cclosure_marshal_VOID__DOUBLEv (GClosure     *closure,
1320                                   GValue       *return_value,
1321                                   gpointer      instance,
1322                                   va_list       args,
1323                                   gpointer      marshal_data,
1324                                   int           n_params,
1325                                   GType        *param_types)
1326 {
1327   typedef void (*GMarshalFunc_VOID__DOUBLE) (gpointer     instance,
1328                                              gdouble      arg_0,
1329                                              gpointer     data);
1330   GCClosure *cc = (GCClosure*) closure;
1331   gpointer data1, data2;
1332   GMarshalFunc_VOID__DOUBLE callback;
1333   gdouble arg0;
1334   va_list args_copy;
1335 
1336   G_VA_COPY (args_copy, args);
1337   arg0 = (gdouble) va_arg (args_copy, gdouble);
1338   va_end (args_copy);
1339 
1340   if (G_CCLOSURE_SWAP_DATA (closure))
1341     {
1342       data1 = closure-&gt;data;
1343       data2 = instance;
1344     }
1345   else
1346     {
1347       data1 = instance;
1348       data2 = closure-&gt;data;
1349     }
1350   callback = (GMarshalFunc_VOID__DOUBLE) (marshal_data ? marshal_data : cc-&gt;callback);
1351 
1352   callback (data1,
1353             arg0,
1354             data2);
1355 }
1356 
1357 /**
1358  * g_cclosure_marshal_VOID__STRING:
1359  * @closure: A #GClosure.
1360  * @return_value: A #GValue to store the return value. May be %NULL
1361  *   if the callback of closure doesn&#39;t return a value.
1362  * @n_param_values: The length of the @param_values array.
1363  * @param_values: An array of #GValues holding the arguments
1364  *   on which to invoke the callback of closure.
1365  * @invocation_hint: The invocation hint given as the last argument to
1366  *   g_closure_invoke().
1367  * @marshal_data: Additional data specified when registering the
1368  *   marshaller, see g_closure_set_marshal() and
1369  *   g_closure_set_meta_marshal()
1370  *
1371  * A #GClosureMarshal function for use with signals with a single string
1372  * argument.
1373  */
1374 /* VOID:STRING */
1375 void
1376 g_cclosure_marshal_VOID__STRING (GClosure     *closure,
1377                                  GValue       *return_value G_GNUC_UNUSED,
1378                                  guint         n_param_values,
1379                                  const GValue *param_values,
1380                                  gpointer      invocation_hint G_GNUC_UNUSED,
1381                                  gpointer      marshal_data)
1382 {
1383   typedef void (*GMarshalFunc_VOID__STRING) (gpointer     data1,
1384                                              gpointer     arg_1,
1385                                              gpointer     data2);
1386   GMarshalFunc_VOID__STRING callback;
1387   GCClosure *cc = (GCClosure*) closure;
1388   gpointer data1, data2;
1389 
1390   g_return_if_fail (n_param_values == 2);
1391 
1392   if (G_CCLOSURE_SWAP_DATA (closure))
1393     {
1394       data1 = closure-&gt;data;
1395       data2 = g_value_peek_pointer (param_values + 0);
1396     }
1397   else
1398     {
1399       data1 = g_value_peek_pointer (param_values + 0);
1400       data2 = closure-&gt;data;
1401     }
1402   callback = (GMarshalFunc_VOID__STRING) (marshal_data ? marshal_data : cc-&gt;callback);
1403 
1404   callback (data1,
1405             g_marshal_value_peek_string (param_values + 1),
1406             data2);
1407 }
1408 
1409 /**
1410  * g_cclosure_marshal_VOID__STRINGv:
1411  * @closure: the #GClosure to which the marshaller belongs
1412  * @return_value: (nullable): a #GValue to store the return
1413  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
1414  *  value.
1415  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
1416  * @args: va_list of arguments to be passed to the closure.
1417  * @marshal_data: (nullable): additional data specified when
1418  *  registering the marshaller, see g_closure_set_marshal() and
1419  *  g_closure_set_meta_marshal()
1420  * @n_params: the length of the @param_types array
1421  * @param_types: (array length=n_params): the #GType of each argument from
1422  *  @args.
1423  *
1424  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__STRING().
1425  */
1426 void
1427 g_cclosure_marshal_VOID__STRINGv (GClosure     *closure,
1428                                   GValue       *return_value,
1429                                   gpointer      instance,
1430                                   va_list       args,
1431                                   gpointer      marshal_data,
1432                                   int           n_params,
1433                                   GType        *param_types)
1434 {
1435   typedef void (*GMarshalFunc_VOID__STRING) (gpointer     instance,
1436                                              gpointer     arg_0,
1437                                              gpointer     data);
1438   GCClosure *cc = (GCClosure*) closure;
1439   gpointer data1, data2;
1440   GMarshalFunc_VOID__STRING callback;
1441   gpointer arg0;
1442   va_list args_copy;
1443 
1444   G_VA_COPY (args_copy, args);
1445   arg0 = (gpointer) va_arg (args_copy, gpointer);
1446   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1447     arg0 = g_strdup (arg0);
1448   va_end (args_copy);
1449 
1450   if (G_CCLOSURE_SWAP_DATA (closure))
1451     {
1452       data1 = closure-&gt;data;
1453       data2 = instance;
1454     }
1455   else
1456     {
1457       data1 = instance;
1458       data2 = closure-&gt;data;
1459     }
1460   callback = (GMarshalFunc_VOID__STRING) (marshal_data ? marshal_data : cc-&gt;callback);
1461 
1462   callback (data1,
1463             arg0,
1464             data2);
1465   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1466     g_free (arg0);
1467 }
1468 
1469 /**
1470  * g_cclosure_marshal_VOID__PARAM:
1471  * @closure: A #GClosure.
1472  * @return_value: A #GValue to store the return value. May be %NULL
1473  *   if the callback of closure doesn&#39;t return a value.
1474  * @n_param_values: The length of the @param_values array.
1475  * @param_values: An array of #GValues holding the arguments
1476  *   on which to invoke the callback of closure.
1477  * @invocation_hint: The invocation hint given as the last argument to
1478  *   g_closure_invoke().
1479  * @marshal_data: Additional data specified when registering the
1480  *   marshaller, see g_closure_set_marshal() and
1481  *   g_closure_set_meta_marshal()
1482  *
1483  * A #GClosureMarshal function for use with signals with a single
1484  * argument of type #GParamSpec.
1485  */
1486 /* VOID:PARAM */
1487 void
1488 g_cclosure_marshal_VOID__PARAM (GClosure     *closure,
1489                                 GValue       *return_value G_GNUC_UNUSED,
1490                                 guint         n_param_values,
1491                                 const GValue *param_values,
1492                                 gpointer      invocation_hint G_GNUC_UNUSED,
1493                                 gpointer      marshal_data)
1494 {
1495   typedef void (*GMarshalFunc_VOID__PARAM) (gpointer     data1,
1496                                             gpointer     arg_1,
1497                                             gpointer     data2);
1498   GMarshalFunc_VOID__PARAM callback;
1499   GCClosure *cc = (GCClosure*) closure;
1500   gpointer data1, data2;
1501 
1502   g_return_if_fail (n_param_values == 2);
1503 
1504   if (G_CCLOSURE_SWAP_DATA (closure))
1505     {
1506       data1 = closure-&gt;data;
1507       data2 = g_value_peek_pointer (param_values + 0);
1508     }
1509   else
1510     {
1511       data1 = g_value_peek_pointer (param_values + 0);
1512       data2 = closure-&gt;data;
1513     }
1514   callback = (GMarshalFunc_VOID__PARAM) (marshal_data ? marshal_data : cc-&gt;callback);
1515 
1516   callback (data1,
1517             g_marshal_value_peek_param (param_values + 1),
1518             data2);
1519 }
1520 
1521 /**
1522  * g_cclosure_marshal_VOID__PARAMv:
1523  * @closure: the #GClosure to which the marshaller belongs
1524  * @return_value: (nullable): a #GValue to store the return
1525  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
1526  *  value.
1527  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
1528  * @args: va_list of arguments to be passed to the closure.
1529  * @marshal_data: (nullable): additional data specified when
1530  *  registering the marshaller, see g_closure_set_marshal() and
1531  *  g_closure_set_meta_marshal()
1532  * @n_params: the length of the @param_types array
1533  * @param_types: (array length=n_params): the #GType of each argument from
1534  *  @args.
1535  *
1536  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__PARAM().
1537  */
1538 void
1539 g_cclosure_marshal_VOID__PARAMv (GClosure     *closure,
1540                                  GValue       *return_value,
1541                                  gpointer      instance,
1542                                  va_list       args,
1543                                  gpointer      marshal_data,
1544                                  int           n_params,
1545                                  GType        *param_types)
1546 {
1547   typedef void (*GMarshalFunc_VOID__PARAM) (gpointer     instance,
1548                                             gpointer     arg_0,
1549                                             gpointer     data);
1550   GCClosure *cc = (GCClosure*) closure;
1551   gpointer data1, data2;
1552   GMarshalFunc_VOID__PARAM callback;
1553   gpointer arg0;
1554   va_list args_copy;
1555 
1556   G_VA_COPY (args_copy, args);
1557   arg0 = (gpointer) va_arg (args_copy, gpointer);
1558   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1559     arg0 = g_param_spec_ref (arg0);
1560   va_end (args_copy);
1561 
1562   if (G_CCLOSURE_SWAP_DATA (closure))
1563     {
1564       data1 = closure-&gt;data;
1565       data2 = instance;
1566     }
1567   else
1568     {
1569       data1 = instance;
1570       data2 = closure-&gt;data;
1571     }
1572   callback = (GMarshalFunc_VOID__PARAM) (marshal_data ? marshal_data : cc-&gt;callback);
1573 
1574   callback (data1,
1575             arg0,
1576             data2);
1577   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1578     g_param_spec_unref (arg0);
1579 }
1580 
1581 /**
1582  * g_cclosure_marshal_VOID__BOXED:
1583  * @closure: A #GClosure.
1584  * @return_value: A #GValue to store the return value. May be %NULL
1585  *   if the callback of closure doesn&#39;t return a value.
1586  * @n_param_values: The length of the @param_values array.
1587  * @param_values: An array of #GValues holding the arguments
1588  *   on which to invoke the callback of closure.
1589  * @invocation_hint: The invocation hint given as the last argument to
1590  *   g_closure_invoke().
1591  * @marshal_data: Additional data specified when registering the
1592  *   marshaller, see g_closure_set_marshal() and
1593  *   g_closure_set_meta_marshal()
1594  *
1595  * A #GClosureMarshal function for use with signals with a single
1596  * argument which is any boxed pointer type.
1597  */
1598 /* VOID:BOXED */
1599 void
1600 g_cclosure_marshal_VOID__BOXED (GClosure     *closure,
1601                                 GValue       *return_value G_GNUC_UNUSED,
1602                                 guint         n_param_values,
1603                                 const GValue *param_values,
1604                                 gpointer      invocation_hint G_GNUC_UNUSED,
1605                                 gpointer      marshal_data)
1606 {
1607   typedef void (*GMarshalFunc_VOID__BOXED) (gpointer     data1,
1608                                             gpointer     arg_1,
1609                                             gpointer     data2);
1610   GMarshalFunc_VOID__BOXED callback;
1611   GCClosure *cc = (GCClosure*) closure;
1612   gpointer data1, data2;
1613 
1614   g_return_if_fail (n_param_values == 2);
1615 
1616   if (G_CCLOSURE_SWAP_DATA (closure))
1617     {
1618       data1 = closure-&gt;data;
1619       data2 = g_value_peek_pointer (param_values + 0);
1620     }
1621   else
1622     {
1623       data1 = g_value_peek_pointer (param_values + 0);
1624       data2 = closure-&gt;data;
1625     }
1626   callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
1627 
1628   callback (data1,
1629             g_marshal_value_peek_boxed (param_values + 1),
1630             data2);
1631 }
1632 
1633 /**
1634  * g_cclosure_marshal_VOID__BOXEDv:
1635  * @closure: the #GClosure to which the marshaller belongs
1636  * @return_value: (nullable): a #GValue to store the return
1637  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
1638  *  value.
1639  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
1640  * @args: va_list of arguments to be passed to the closure.
1641  * @marshal_data: (nullable): additional data specified when
1642  *  registering the marshaller, see g_closure_set_marshal() and
1643  *  g_closure_set_meta_marshal()
1644  * @n_params: the length of the @param_types array
1645  * @param_types: (array length=n_params): the #GType of each argument from
1646  *  @args.
1647  *
1648  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__BOXED().
1649  */
1650 void
1651 g_cclosure_marshal_VOID__BOXEDv (GClosure     *closure,
1652                                  GValue       *return_value,
1653                                  gpointer      instance,
1654                                  va_list       args,
1655                                  gpointer      marshal_data,
1656                                  int           n_params,
1657                                  GType        *param_types)
1658 {
1659   typedef void (*GMarshalFunc_VOID__BOXED) (gpointer     instance,
1660                                             gpointer     arg_0,
1661                                             gpointer     data);
1662   GCClosure *cc = (GCClosure*) closure;
1663   gpointer data1, data2;
1664   GMarshalFunc_VOID__BOXED callback;
1665   gpointer arg0;
1666   va_list args_copy;
1667 
1668   G_VA_COPY (args_copy, args);
1669   arg0 = (gpointer) va_arg (args_copy, gpointer);
1670   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1671     arg0 = g_boxed_copy (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
1672   va_end (args_copy);
1673 
1674   if (G_CCLOSURE_SWAP_DATA (closure))
1675     {
1676       data1 = closure-&gt;data;
1677       data2 = instance;
1678     }
1679   else
1680     {
1681       data1 = instance;
1682       data2 = closure-&gt;data;
1683     }
1684   callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
1685 
1686   callback (data1,
1687             arg0,
1688             data2);
1689   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1690     g_boxed_free (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
1691 }
1692 
1693 /**
1694  * g_cclosure_marshal_VOID__POINTER:
1695  * @closure: A #GClosure.
1696  * @return_value: A #GValue to store the return value. May be %NULL
1697  *   if the callback of closure doesn&#39;t return a value.
1698  * @n_param_values: The length of the @param_values array.
1699  * @param_values: An array of #GValues holding the arguments
1700  *   on which to invoke the callback of closure.
1701  * @invocation_hint: The invocation hint given as the last argument to
1702  *   g_closure_invoke().
1703  * @marshal_data: Additional data specified when registering the
1704  *   marshaller, see g_closure_set_marshal() and
1705  *   g_closure_set_meta_marshal()
1706  *
1707  * A #GClosureMarshal function for use with signals with a single raw
1708  * pointer argument type.
1709  *
1710  * If it is possible, it is better to use one of the more specific
1711  * functions such as g_cclosure_marshal_VOID__OBJECT() or
1712  * g_cclosure_marshal_VOID__OBJECT().
1713  */
1714 /* VOID:POINTER */
1715 void
1716 g_cclosure_marshal_VOID__POINTER (GClosure     *closure,
1717                                   GValue       *return_value G_GNUC_UNUSED,
1718                                   guint         n_param_values,
1719                                   const GValue *param_values,
1720                                   gpointer      invocation_hint G_GNUC_UNUSED,
1721                                   gpointer      marshal_data)
1722 {
1723   typedef void (*GMarshalFunc_VOID__POINTER) (gpointer     data1,
1724                                               gpointer     arg_1,
1725                                               gpointer     data2);
1726   GMarshalFunc_VOID__POINTER callback;
1727   GCClosure *cc = (GCClosure*) closure;
1728   gpointer data1, data2;
1729 
1730   g_return_if_fail (n_param_values == 2);
1731 
1732   if (G_CCLOSURE_SWAP_DATA (closure))
1733     {
1734       data1 = closure-&gt;data;
1735       data2 = g_value_peek_pointer (param_values + 0);
1736     }
1737   else
1738     {
1739       data1 = g_value_peek_pointer (param_values + 0);
1740       data2 = closure-&gt;data;
1741     }
1742   callback = (GMarshalFunc_VOID__POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
1743 
1744   callback (data1,
1745             g_marshal_value_peek_pointer (param_values + 1),
1746             data2);
1747 }
1748 
1749 /**
1750  * g_cclosure_marshal_VOID__POINTERv:
1751  * @closure: the #GClosure to which the marshaller belongs
1752  * @return_value: (nullable): a #GValue to store the return
1753  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
1754  *  value.
1755  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
1756  * @args: va_list of arguments to be passed to the closure.
1757  * @marshal_data: (nullable): additional data specified when
1758  *  registering the marshaller, see g_closure_set_marshal() and
1759  *  g_closure_set_meta_marshal()
1760  * @n_params: the length of the @param_types array
1761  * @param_types: (array length=n_params): the #GType of each argument from
1762  *  @args.
1763  *
1764  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__POINTER().
1765  */
1766 void
1767 g_cclosure_marshal_VOID__POINTERv (GClosure     *closure,
1768                                    GValue       *return_value,
1769                                    gpointer      instance,
1770                                    va_list       args,
1771                                    gpointer      marshal_data,
1772                                    int           n_params,
1773                                    GType        *param_types)
1774 {
1775   typedef void (*GMarshalFunc_VOID__POINTER) (gpointer     instance,
1776                                               gpointer     arg_0,
1777                                               gpointer     data);
1778   GCClosure *cc = (GCClosure*) closure;
1779   gpointer data1, data2;
1780   GMarshalFunc_VOID__POINTER callback;
1781   gpointer arg0;
1782   va_list args_copy;
1783 
1784   G_VA_COPY (args_copy, args);
1785   arg0 = (gpointer) va_arg (args_copy, gpointer);
1786   va_end (args_copy);
1787 
1788   if (G_CCLOSURE_SWAP_DATA (closure))
1789     {
1790       data1 = closure-&gt;data;
1791       data2 = instance;
1792     }
1793   else
1794     {
1795       data1 = instance;
1796       data2 = closure-&gt;data;
1797     }
1798   callback = (GMarshalFunc_VOID__POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
1799 
1800   callback (data1,
1801             arg0,
1802             data2);
1803 }
1804 
1805 /**
1806  * g_cclosure_marshal_VOID__OBJECT:
1807  * @closure: A #GClosure.
1808  * @return_value: A #GValue to store the return value. May be %NULL
1809  *   if the callback of closure doesn&#39;t return a value.
1810  * @n_param_values: The length of the @param_values array.
1811  * @param_values: An array of #GValues holding the arguments
1812  *   on which to invoke the callback of closure.
1813  * @invocation_hint: The invocation hint given as the last argument to
1814  *   g_closure_invoke().
1815  * @marshal_data: Additional data specified when registering the
1816  *   marshaller, see g_closure_set_marshal() and
1817  *   g_closure_set_meta_marshal()
1818  *
1819  * A #GClosureMarshal function for use with signals with a single
1820  * #GObject argument.
1821  */
1822 /* VOID:OBJECT */
1823 void
1824 g_cclosure_marshal_VOID__OBJECT (GClosure     *closure,
1825                                  GValue       *return_value G_GNUC_UNUSED,
1826                                  guint         n_param_values,
1827                                  const GValue *param_values,
1828                                  gpointer      invocation_hint G_GNUC_UNUSED,
1829                                  gpointer      marshal_data)
1830 {
1831   typedef void (*GMarshalFunc_VOID__OBJECT) (gpointer     data1,
1832                                              gpointer     arg_1,
1833                                              gpointer     data2);
1834   GMarshalFunc_VOID__OBJECT callback;
1835   GCClosure *cc = (GCClosure*) closure;
1836   gpointer data1, data2;
1837 
1838   g_return_if_fail (n_param_values == 2);
1839 
1840   if (G_CCLOSURE_SWAP_DATA (closure))
1841     {
1842       data1 = closure-&gt;data;
1843       data2 = g_value_peek_pointer (param_values + 0);
1844     }
1845   else
1846     {
1847       data1 = g_value_peek_pointer (param_values + 0);
1848       data2 = closure-&gt;data;
1849     }
1850   callback = (GMarshalFunc_VOID__OBJECT) (marshal_data ? marshal_data : cc-&gt;callback);
1851 
1852   callback (data1,
1853             g_marshal_value_peek_object (param_values + 1),
1854             data2);
1855 }
1856 
1857 /**
1858  * g_cclosure_marshal_VOID__OBJECTv:
1859  * @closure: the #GClosure to which the marshaller belongs
1860  * @return_value: (nullable): a #GValue to store the return
1861  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
1862  *  value.
1863  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
1864  * @args: va_list of arguments to be passed to the closure.
1865  * @marshal_data: (nullable): additional data specified when
1866  *  registering the marshaller, see g_closure_set_marshal() and
1867  *  g_closure_set_meta_marshal()
1868  * @n_params: the length of the @param_types array
1869  * @param_types: (array length=n_params): the #GType of each argument from
1870  *  @args.
1871  *
1872  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__OBJECT().
1873  */
1874 void
1875 g_cclosure_marshal_VOID__OBJECTv (GClosure     *closure,
1876                                   GValue       *return_value,
1877                                   gpointer      instance,
1878                                   va_list       args,
1879                                   gpointer      marshal_data,
1880                                   int           n_params,
1881                                   GType        *param_types)
1882 {
1883   typedef void (*GMarshalFunc_VOID__OBJECT) (gpointer     instance,
1884                                              gpointer     arg_0,
1885                                              gpointer     data);
1886   GCClosure *cc = (GCClosure*) closure;
1887   gpointer data1, data2;
1888   GMarshalFunc_VOID__OBJECT callback;
1889   gpointer arg0;
1890   va_list args_copy;
1891 
1892   G_VA_COPY (args_copy, args);
1893   arg0 = (gpointer) va_arg (args_copy, gpointer);
1894   if (arg0 != NULL)
1895     arg0 = g_object_ref (arg0);
1896   va_end (args_copy);
1897 
1898   if (G_CCLOSURE_SWAP_DATA (closure))
1899     {
1900       data1 = closure-&gt;data;
1901       data2 = instance;
1902     }
1903   else
1904     {
1905       data1 = instance;
1906       data2 = closure-&gt;data;
1907     }
1908   callback = (GMarshalFunc_VOID__OBJECT) (marshal_data ? marshal_data : cc-&gt;callback);
1909 
1910   callback (data1,
1911             arg0,
1912             data2);
1913   if (arg0 != NULL)
1914     g_object_unref (arg0);
1915 }
1916 
1917 /**
1918  * g_cclosure_marshal_VOID__VARIANT:
1919  * @closure: A #GClosure.
1920  * @return_value: A #GValue to store the return value. May be %NULL
1921  *   if the callback of closure doesn&#39;t return a value.
1922  * @n_param_values: The length of the @param_values array.
1923  * @param_values: An array of #GValues holding the arguments
1924  *   on which to invoke the callback of closure.
1925  * @invocation_hint: The invocation hint given as the last argument to
1926  *   g_closure_invoke().
1927  * @marshal_data: Additional data specified when registering the
1928  *   marshaller, see g_closure_set_marshal() and
1929  *   g_closure_set_meta_marshal()
1930  *
1931  * A #GClosureMarshal function for use with signals with a single
1932  * #GVariant argument.
1933  */
1934 /* VOID:VARIANT */
1935 void
1936 g_cclosure_marshal_VOID__VARIANT (GClosure     *closure,
1937                                   GValue       *return_value G_GNUC_UNUSED,
1938                                   guint         n_param_values,
1939                                   const GValue *param_values,
1940                                   gpointer      invocation_hint G_GNUC_UNUSED,
1941                                   gpointer      marshal_data)
1942 {
1943   typedef void (*GMarshalFunc_VOID__VARIANT) (gpointer     data1,
1944                                               gpointer     arg_1,
1945                                               gpointer     data2);
1946   GMarshalFunc_VOID__VARIANT callback;
1947   GCClosure *cc = (GCClosure*) closure;
1948   gpointer data1, data2;
1949 
1950   g_return_if_fail (n_param_values == 2);
1951 
1952   if (G_CCLOSURE_SWAP_DATA (closure))
1953     {
1954       data1 = closure-&gt;data;
1955       data2 = g_value_peek_pointer (param_values + 0);
1956     }
1957   else
1958     {
1959       data1 = g_value_peek_pointer (param_values + 0);
1960       data2 = closure-&gt;data;
1961     }
1962   callback = (GMarshalFunc_VOID__VARIANT) (marshal_data ? marshal_data : cc-&gt;callback);
1963 
1964   callback (data1,
1965             g_marshal_value_peek_variant (param_values + 1),
1966             data2);
1967 }
1968 
1969 /**
1970  * g_cclosure_marshal_VOID__VARIANTv:
1971  * @closure: the #GClosure to which the marshaller belongs
1972  * @return_value: (nullable): a #GValue to store the return
1973  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
1974  *  value.
1975  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
1976  * @args: va_list of arguments to be passed to the closure.
1977  * @marshal_data: (nullable): additional data specified when
1978  *  registering the marshaller, see g_closure_set_marshal() and
1979  *  g_closure_set_meta_marshal()
1980  * @n_params: the length of the @param_types array
1981  * @param_types: (array length=n_params): the #GType of each argument from
1982  *  @args.
1983  *
1984  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__VARIANT().
1985  */
1986 void
1987 g_cclosure_marshal_VOID__VARIANTv (GClosure     *closure,
1988                                    GValue       *return_value,
1989                                    gpointer      instance,
1990                                    va_list       args,
1991                                    gpointer      marshal_data,
1992                                    int           n_params,
1993                                    GType        *param_types)
1994 {
1995   typedef void (*GMarshalFunc_VOID__VARIANT) (gpointer     instance,
1996                                               gpointer     arg_0,
1997                                               gpointer     data);
1998   GCClosure *cc = (GCClosure*) closure;
1999   gpointer data1, data2;
2000   GMarshalFunc_VOID__VARIANT callback;
2001   gpointer arg0;
2002   va_list args_copy;
2003 
2004   G_VA_COPY (args_copy, args);
2005   arg0 = (gpointer) va_arg (args_copy, gpointer);
2006   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2007     arg0 = g_variant_ref_sink (arg0);
2008   va_end (args_copy);
2009 
2010   if (G_CCLOSURE_SWAP_DATA (closure))
2011     {
2012       data1 = closure-&gt;data;
2013       data2 = instance;
2014     }
2015   else
2016     {
2017       data1 = instance;
2018       data2 = closure-&gt;data;
2019     }
2020   callback = (GMarshalFunc_VOID__VARIANT) (marshal_data ? marshal_data : cc-&gt;callback);
2021 
2022   callback (data1,
2023             arg0,
2024             data2);
2025   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2026     g_variant_unref (arg0);
2027 }
2028 
2029 /**
2030  * g_cclosure_marshal_VOID__UINT_POINTER:
2031  * @closure: A #GClosure.
2032  * @return_value: A #GValue to store the return value. May be %NULL
2033  *   if the callback of closure doesn&#39;t return a value.
2034  * @n_param_values: The length of the @param_values array.
2035  * @param_values: An array of #GValues holding the arguments
2036  *   on which to invoke the callback of closure.
2037  * @invocation_hint: The invocation hint given as the last argument to
2038  *   g_closure_invoke().
2039  * @marshal_data: Additional data specified when registering the
2040  *   marshaller, see g_closure_set_marshal() and
2041  *   g_closure_set_meta_marshal()
2042  *
2043  * A #GClosureMarshal function for use with signals with an unsigned int
2044  * and a pointer as arguments.
2045  */
2046 /* VOID:UINT,POINTER */
2047 void
2048 g_cclosure_marshal_VOID__UINT_POINTER (GClosure     *closure,
2049                                        GValue       *return_value G_GNUC_UNUSED,
2050                                        guint         n_param_values,
2051                                        const GValue *param_values,
2052                                        gpointer      invocation_hint G_GNUC_UNUSED,
2053                                        gpointer      marshal_data)
2054 {
2055   typedef void (*GMarshalFunc_VOID__UINT_POINTER) (gpointer     data1,
2056                                                    guint        arg_1,
2057                                                    gpointer     arg_2,
2058                                                    gpointer     data2);
2059   GMarshalFunc_VOID__UINT_POINTER callback;
2060   GCClosure *cc = (GCClosure*) closure;
2061   gpointer data1, data2;
2062 
2063   g_return_if_fail (n_param_values == 3);
2064 
2065   if (G_CCLOSURE_SWAP_DATA (closure))
2066     {
2067       data1 = closure-&gt;data;
2068       data2 = g_value_peek_pointer (param_values + 0);
2069     }
2070   else
2071     {
2072       data1 = g_value_peek_pointer (param_values + 0);
2073       data2 = closure-&gt;data;
2074     }
2075   callback = (GMarshalFunc_VOID__UINT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2076 
2077   callback (data1,
2078             g_marshal_value_peek_uint (param_values + 1),
2079             g_marshal_value_peek_pointer (param_values + 2),
2080             data2);
2081 }
2082 
2083 /**
2084  * g_cclosure_marshal_VOID__UINT_POINTERv:
2085  * @closure: the #GClosure to which the marshaller belongs
2086  * @return_value: (nullable): a #GValue to store the return
2087  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
2088  *  value.
2089  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
2090  * @args: va_list of arguments to be passed to the closure.
2091  * @marshal_data: (nullable): additional data specified when
2092  *  registering the marshaller, see g_closure_set_marshal() and
2093  *  g_closure_set_meta_marshal()
2094  * @n_params: the length of the @param_types array
2095  * @param_types: (array length=n_params): the #GType of each argument from
2096  *  @args.
2097  *
2098  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UINT_POINTER().
2099  */
2100 void
2101 g_cclosure_marshal_VOID__UINT_POINTERv (GClosure     *closure,
2102                                         GValue       *return_value,
2103                                         gpointer      instance,
2104                                         va_list       args,
2105                                         gpointer      marshal_data,
2106                                         int           n_params,
2107                                         GType        *param_types)
2108 {
2109   typedef void (*GMarshalFunc_VOID__UINT_POINTER) (gpointer     instance,
2110                                                    guint        arg_0,
2111                                                    gpointer     arg_1,
2112                                                    gpointer     data);
2113   GCClosure *cc = (GCClosure*) closure;
2114   gpointer data1, data2;
2115   GMarshalFunc_VOID__UINT_POINTER callback;
2116   guint arg0;
2117   gpointer arg1;
2118   va_list args_copy;
2119 
2120   G_VA_COPY (args_copy, args);
2121   arg0 = (guint) va_arg (args_copy, guint);
2122   arg1 = (gpointer) va_arg (args_copy, gpointer);
2123   va_end (args_copy);
2124 
2125   if (G_CCLOSURE_SWAP_DATA (closure))
2126     {
2127       data1 = closure-&gt;data;
2128       data2 = instance;
2129     }
2130   else
2131     {
2132       data1 = instance;
2133       data2 = closure-&gt;data;
2134     }
2135   callback = (GMarshalFunc_VOID__UINT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2136 
2137   callback (data1,
2138             arg0,
2139             arg1,
2140             data2);
2141 }
2142 
2143 /**
2144  * g_cclosure_marshal_BOOLEAN__FLAGS:
2145  * @closure: A #GClosure.
2146  * @return_value: A #GValue to store the return value. May be %NULL
2147  *   if the callback of closure doesn&#39;t return a value.
2148  * @n_param_values: The length of the @param_values array.
2149  * @param_values: An array of #GValues holding the arguments
2150  *   on which to invoke the callback of closure.
2151  * @invocation_hint: The invocation hint given as the last argument to
2152  *   g_closure_invoke().
2153  * @marshal_data: Additional data specified when registering the
2154  *   marshaller, see g_closure_set_marshal() and
2155  *   g_closure_set_meta_marshal()
2156  *
2157  * A #GClosureMarshal function for use with signals with handlers that
2158  * take a flags type as an argument and return a boolean.  If you have
2159  * such a signal, you will probably also need to use an accumulator,
2160  * such as g_signal_accumulator_true_handled().
2161  */
2162 /* BOOL:FLAGS */
2163 void
2164 g_cclosure_marshal_BOOLEAN__FLAGS (GClosure     *closure,
2165                                    GValue       *return_value G_GNUC_UNUSED,
2166                                    guint         n_param_values,
2167                                    const GValue *param_values,
2168                                    gpointer      invocation_hint G_GNUC_UNUSED,
2169                                    gpointer      marshal_data)
2170 {
2171   typedef gboolean (*GMarshalFunc_BOOLEAN__FLAGS) (gpointer     data1,
2172                                                    guint        arg_1,
2173                                                    gpointer     data2);
2174   GMarshalFunc_BOOLEAN__FLAGS callback;
2175   GCClosure *cc = (GCClosure*) closure;
2176   gpointer data1, data2;
2177   gboolean v_return;
2178 
2179   g_return_if_fail (return_value != NULL);
2180   g_return_if_fail (n_param_values == 2);
2181 
2182   if (G_CCLOSURE_SWAP_DATA (closure))
2183     {
2184       data1 = closure-&gt;data;
2185       data2 = g_value_peek_pointer (param_values + 0);
2186     }
2187   else
2188     {
2189       data1 = g_value_peek_pointer (param_values + 0);
2190       data2 = closure-&gt;data;
2191     }
2192   callback = (GMarshalFunc_BOOLEAN__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
2193 
2194   v_return = callback (data1,
2195                        g_marshal_value_peek_flags (param_values + 1),
2196                        data2);
2197 
2198   g_value_set_boolean (return_value, v_return);
2199 }
2200 
2201 /**
2202  * g_cclosure_marshal_BOOLEAN__FLAGSv:
2203  * @closure: the #GClosure to which the marshaller belongs
2204  * @return_value: (nullable): a #GValue to store the return
2205  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
2206  *  value.
2207  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
2208  * @args: va_list of arguments to be passed to the closure.
2209  * @marshal_data: (nullable): additional data specified when
2210  *  registering the marshaller, see g_closure_set_marshal() and
2211  *  g_closure_set_meta_marshal()
2212  * @n_params: the length of the @param_types array
2213  * @param_types: (array length=n_params): the #GType of each argument from
2214  *  @args.
2215  *
2216  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_BOOLEAN__FLAGS().
2217  */
2218 void
2219 g_cclosure_marshal_BOOLEAN__FLAGSv (GClosure     *closure,
2220                                     GValue       *return_value,
2221                                     gpointer      instance,
2222                                     va_list       args,
2223                                     gpointer      marshal_data,
2224                                     int           n_params,
2225                                     GType        *param_types)
2226 {
2227   typedef gboolean (*GMarshalFunc_BOOLEAN__FLAGS) (gpointer     instance,
2228                                                    guint        arg_0,
2229                                                    gpointer     data);
2230   GCClosure *cc = (GCClosure*) closure;
2231   gpointer data1, data2;
2232   GMarshalFunc_BOOLEAN__FLAGS callback;
2233   guint arg0;
2234   va_list args_copy;
2235   gboolean v_return;
2236 
2237   g_return_if_fail (return_value != NULL);
2238 
2239   G_VA_COPY (args_copy, args);
2240   arg0 = (guint) va_arg (args_copy, guint);
2241   va_end (args_copy);
2242 
2243   if (G_CCLOSURE_SWAP_DATA (closure))
2244     {
2245       data1 = closure-&gt;data;
2246       data2 = instance;
2247     }
2248   else
2249     {
2250       data1 = instance;
2251       data2 = closure-&gt;data;
2252     }
2253   callback = (GMarshalFunc_BOOLEAN__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
2254 
2255   v_return = callback (data1,
2256                        arg0,
2257                        data2);
2258 
2259   g_value_set_boolean (return_value, v_return);
2260 }
2261 
2262 /**
2263  * g_cclosure_marshal_STRING__OBJECT_POINTER:
2264  * @closure: A #GClosure.
2265  * @return_value: A #GValue to store the return value. May be %NULL
2266  *   if the callback of closure doesn&#39;t return a value.
2267  * @n_param_values: The length of the @param_values array.
2268  * @param_values: An array of #GValues holding the arguments
2269  *   on which to invoke the callback of closure.
2270  * @invocation_hint: The invocation hint given as the last argument to
2271  *   g_closure_invoke().
2272  * @marshal_data: Additional data specified when registering the
2273  *   marshaller, see g_closure_set_marshal() and
2274  *   g_closure_set_meta_marshal()
2275  *
2276  * A #GClosureMarshal function for use with signals with handlers that
2277  * take a #GObject and a pointer and produce a string.  It is highly
2278  * unlikely that your signal handler fits this description.
2279  */
2280 /* STRING:OBJECT,POINTER */
2281 void
2282 g_cclosure_marshal_STRING__OBJECT_POINTER (GClosure     *closure,
2283                                            GValue       *return_value G_GNUC_UNUSED,
2284                                            guint         n_param_values,
2285                                            const GValue *param_values,
2286                                            gpointer      invocation_hint G_GNUC_UNUSED,
2287                                            gpointer      marshal_data)
2288 {
2289   typedef gchar* (*GMarshalFunc_STRING__OBJECT_POINTER) (gpointer     data1,
2290                                                          gpointer     arg_1,
2291                                                          gpointer     arg_2,
2292                                                          gpointer     data2);
2293   GMarshalFunc_STRING__OBJECT_POINTER callback;
2294   GCClosure *cc = (GCClosure*) closure;
2295   gpointer data1, data2;
2296   gchar* v_return;
2297 
2298   g_return_if_fail (return_value != NULL);
2299   g_return_if_fail (n_param_values == 3);
2300 
2301   if (G_CCLOSURE_SWAP_DATA (closure))
2302     {
2303       data1 = closure-&gt;data;
2304       data2 = g_value_peek_pointer (param_values + 0);
2305     }
2306   else
2307     {
2308       data1 = g_value_peek_pointer (param_values + 0);
2309       data2 = closure-&gt;data;
2310     }
2311   callback = (GMarshalFunc_STRING__OBJECT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2312 
2313   v_return = callback (data1,
2314                        g_marshal_value_peek_object (param_values + 1),
2315                        g_marshal_value_peek_pointer (param_values + 2),
2316                        data2);
2317 
2318   g_value_take_string (return_value, v_return);
2319 }
2320 
2321 /**
2322  * g_cclosure_marshal_STRING__OBJECT_POINTERv:
2323  * @closure: the #GClosure to which the marshaller belongs
2324  * @return_value: (nullable): a #GValue to store the return
2325  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
2326  *  value.
2327  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
2328  * @args: va_list of arguments to be passed to the closure.
2329  * @marshal_data: (nullable): additional data specified when
2330  *  registering the marshaller, see g_closure_set_marshal() and
2331  *  g_closure_set_meta_marshal()
2332  * @n_params: the length of the @param_types array
2333  * @param_types: (array length=n_params): the #GType of each argument from
2334  *  @args.
2335  *
2336  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_STRING__OBJECT_POINTER().
2337  */
2338 void
2339 g_cclosure_marshal_STRING__OBJECT_POINTERv (GClosure     *closure,
2340                                             GValue       *return_value,
2341                                             gpointer      instance,
2342                                             va_list       args,
2343                                             gpointer      marshal_data,
2344                                             int           n_params,
2345                                             GType        *param_types)
2346 {
2347   typedef gchar* (*GMarshalFunc_STRING__OBJECT_POINTER) (gpointer     instance,
2348                                                          gpointer     arg_0,
2349                                                          gpointer     arg_1,
2350                                                          gpointer     data);
2351   GCClosure *cc = (GCClosure*) closure;
2352   gpointer data1, data2;
2353   GMarshalFunc_STRING__OBJECT_POINTER callback;
2354   gpointer arg0;
2355   gpointer arg1;
2356   va_list args_copy;
2357   gchar* v_return;
2358 
2359   g_return_if_fail (return_value != NULL);
2360 
2361   G_VA_COPY (args_copy, args);
2362   arg0 = (gpointer) va_arg (args_copy, gpointer);
2363   if (arg0 != NULL)
2364     arg0 = g_object_ref (arg0);
2365   arg1 = (gpointer) va_arg (args_copy, gpointer);
2366   va_end (args_copy);
2367 
2368   if (G_CCLOSURE_SWAP_DATA (closure))
2369     {
2370       data1 = closure-&gt;data;
2371       data2 = instance;
2372     }
2373   else
2374     {
2375       data1 = instance;
2376       data2 = closure-&gt;data;
2377     }
2378   callback = (GMarshalFunc_STRING__OBJECT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2379 
2380   v_return = callback (data1,
2381                        arg0,
2382                        arg1,
2383                        data2);
2384   if (arg0 != NULL)
2385     g_object_unref (arg0);
2386 
2387   g_value_take_string (return_value, v_return);
2388 }
2389 
2390 /**
2391  * g_cclosure_marshal_BOOLEAN__BOXED_BOXED:
2392  * @closure: A #GClosure.
2393  * @return_value: A #GValue to store the return value. May be %NULL
2394  *   if the callback of closure doesn&#39;t return a value.
2395  * @n_param_values: The length of the @param_values array.
2396  * @param_values: An array of #GValues holding the arguments
2397  *   on which to invoke the callback of closure.
2398  * @invocation_hint: The invocation hint given as the last argument to
2399  *   g_closure_invoke().
2400  * @marshal_data: Additional data specified when registering the
2401  *   marshaller, see g_closure_set_marshal() and
2402  *   g_closure_set_meta_marshal()
2403  *
2404  * A #GClosureMarshal function for use with signals with handlers that
2405  * take two boxed pointers as arguments and return a boolean.  If you
2406  * have such a signal, you will probably also need to use an
2407  * accumulator, such as g_signal_accumulator_true_handled().
2408  */
2409 /* BOOL:BOXED,BOXED */
2410 void
2411 g_cclosure_marshal_BOOLEAN__BOXED_BOXED (GClosure     *closure,
2412                                          GValue       *return_value G_GNUC_UNUSED,
2413                                          guint         n_param_values,
2414                                          const GValue *param_values,
2415                                          gpointer      invocation_hint G_GNUC_UNUSED,
2416                                          gpointer      marshal_data)
2417 {
2418   typedef gboolean (*GMarshalFunc_BOOLEAN__BOXED_BOXED) (gpointer     data1,
2419                                                          gpointer     arg_1,
2420                                                          gpointer     arg_2,
2421                                                          gpointer     data2);
2422   GMarshalFunc_BOOLEAN__BOXED_BOXED callback;
2423   GCClosure *cc = (GCClosure*) closure;
2424   gpointer data1, data2;
2425   gboolean v_return;
2426 
2427   g_return_if_fail (return_value != NULL);
2428   g_return_if_fail (n_param_values == 3);
2429 
2430   if (G_CCLOSURE_SWAP_DATA (closure))
2431     {
2432       data1 = closure-&gt;data;
2433       data2 = g_value_peek_pointer (param_values + 0);
2434     }
2435   else
2436     {
2437       data1 = g_value_peek_pointer (param_values + 0);
2438       data2 = closure-&gt;data;
2439     }
2440   callback = (GMarshalFunc_BOOLEAN__BOXED_BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
2441 
2442   v_return = callback (data1,
2443                        g_marshal_value_peek_boxed (param_values + 1),
2444                        g_marshal_value_peek_boxed (param_values + 2),
2445                        data2);
2446 
2447   g_value_set_boolean (return_value, v_return);
2448 }
2449 
2450 /**
2451  * g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv:
2452  * @closure: the #GClosure to which the marshaller belongs
2453  * @return_value: (nullable): a #GValue to store the return
2454  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
2455  *  value.
2456  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
2457  * @args: va_list of arguments to be passed to the closure.
2458  * @marshal_data: (nullable): additional data specified when
2459  *  registering the marshaller, see g_closure_set_marshal() and
2460  *  g_closure_set_meta_marshal()
2461  * @n_params: the length of the @param_types array
2462  * @param_types: (array length=n_params): the #GType of each argument from
2463  *  @args.
2464  *
2465  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_BOOLEAN__BOXED_BOXED().
2466  */
2467 void
2468 g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv (GClosure     *closure,
2469                                           GValue       *return_value,
2470                                           gpointer      instance,
2471                                           va_list       args,
2472                                           gpointer      marshal_data,
2473                                           int           n_params,
2474                                           GType        *param_types)
2475 {
2476   typedef gboolean (*GMarshalFunc_BOOLEAN__BOXED_BOXED) (gpointer     instance,
2477                                                          gpointer     arg_0,
2478                                                          gpointer     arg_1,
2479                                                          gpointer     data);
2480   GCClosure *cc = (GCClosure*) closure;
2481   gpointer data1, data2;
2482   GMarshalFunc_BOOLEAN__BOXED_BOXED callback;
2483   gpointer arg0;
2484   gpointer arg1;
2485   va_list args_copy;
2486   gboolean v_return;
2487 
2488   g_return_if_fail (return_value != NULL);
2489 
2490   G_VA_COPY (args_copy, args);
2491   arg0 = (gpointer) va_arg (args_copy, gpointer);
2492   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2493     arg0 = g_boxed_copy (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
2494   arg1 = (gpointer) va_arg (args_copy, gpointer);
2495   if ((param_types[1] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg1 != NULL)
2496     arg1 = g_boxed_copy (param_types[1] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
2497   va_end (args_copy);
2498 
2499   if (G_CCLOSURE_SWAP_DATA (closure))
2500     {
2501       data1 = closure-&gt;data;
2502       data2 = instance;
2503     }
2504   else
2505     {
2506       data1 = instance;
2507       data2 = closure-&gt;data;
2508     }
2509   callback = (GMarshalFunc_BOOLEAN__BOXED_BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
2510 
2511   v_return = callback (data1,
2512                        arg0,
2513                        arg1,
2514                        data2);
2515   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2516     g_boxed_free (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
2517   if ((param_types[1] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg1 != NULL)
2518     g_boxed_free (param_types[1] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
2519 
2520   g_value_set_boolean (return_value, v_return);
2521 }
    </pre>
  </body>
</html>