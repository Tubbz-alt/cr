diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gobject.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gobject.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gobject.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gobject.c
@@ -51,10 +51,17 @@
  * For the high-level concepts behind GObject, read [Instantiable classed types:
  * Objects][gtype-instantiable-classed].
  *
  * ## Floating references # {#floating-ref}
  *
+ * **Note**: Floating references are a C convenience API and should not be
+ * used in modern GObject code. Language bindings in particular find the
+ * concept highly problematic, as floating references are not identifiable
+ * through annotations, and neither are deviations from the floating reference
+ * behavior, like types that inherit from #GInitiallyUnowned and still return
+ * a full reference from g_object_new().
+ *
  * GInitiallyUnowned is derived from GObject. The only difference between
  * the two is that the initial reference of a GInitiallyUnowned is flagged
  * as a "floating" reference. This means that it is not specifically
  * claimed to be "owned" by any code portion. The main motivation for
  * providing floating references is C convenience. In particular, it
@@ -81,11 +88,27 @@
  * to g_object_ref() and returns a new reference.
  *
  * Since floating references are useful almost exclusively for C convenience,
  * language bindings that provide automated reference and memory ownership
  * maintenance (such as smart pointers or garbage collection) should not
- * expose floating references in their API.
+ * expose floating references in their API. The best practice for handling
+ * types that have initially floating references is to immediately sink those
+ * references after g_object_new() returns, by checking if the #GType
+ * inherits from #GInitiallyUnowned. For instance:
+ *
+ * |[<!-- language="C" -->
+ * GObject *res = g_object_new_with_properties (gtype,
+ *                                              n_props,
+ *                                              prop_names,
+ *                                              prop_values);
+ *
+ * // or: if (g_type_is_a (gtype, G_TYPE_INITIALLY_UNOWNED))
+ * if (G_IS_INITIALLY_UNOWNED (res))
+ *   g_object_ref_sink (res);
+ *
+ * return res;
+ * ]|
  *
  * Some object implementations may need to save an objects floating state
  * across certain code portions (an example is #GtkMenu), to achieve this,
  * the following sequence can be used:
  *
@@ -105,11 +128,11 @@
  * ]|
  */
 
 
 /* --- macros --- */
-#define PARAM_SPEC_PARAM_ID(pspec)      ((pspec)->param_id)
+#define PARAM_SPEC_PARAM_ID(pspec)    ((pspec)->param_id)
 #define PARAM_SPEC_SET_PARAM_ID(pspec, id)  ((pspec)->param_id = (id))
 
 #define OBJECT_HAS_TOGGLE_REF_FLAG 0x1
 #define OBJECT_HAS_TOGGLE_REF(object) \
     ((g_datalist_get_flags (&(object)->qdata) & OBJECT_HAS_TOGGLE_REF_FLAG) != 0)
@@ -139,52 +162,52 @@
   PROP_NONE
 };
 
 
 /* --- prototypes --- */
-static void g_object_base_class_init        (GObjectClass   *class);
-static void g_object_base_class_finalize        (GObjectClass   *class);
-static void g_object_do_class_init          (GObjectClass   *class);
-static void g_object_init               (GObject    *object,
-                             GObjectClass   *class);
-static GObject* g_object_constructor            (GType                  type,
-                             guint                  n_construct_properties,
-                             GObjectConstructParam *construct_params);
+static void g_object_base_class_init    (GObjectClass *class);
+static void g_object_base_class_finalize    (GObjectClass *class);
+static void g_object_do_class_init      (GObjectClass *class);
+static void g_object_init       (GObject  *object,
+               GObjectClass *class);
+static GObject* g_object_constructor      (GType                  type,
+               guint                  n_construct_properties,
+               GObjectConstructParam *construct_params);
 static void     g_object_constructed                    (GObject        *object);
-static void g_object_real_dispose           (GObject    *object);
-static void g_object_finalize           (GObject    *object);
-static void g_object_do_set_property        (GObject        *object,
-                             guint           property_id,
-                             const GValue   *value,
-                             GParamSpec     *pspec);
-static void g_object_do_get_property        (GObject        *object,
-                             guint           property_id,
-                             GValue         *value,
-                             GParamSpec     *pspec);
-static void g_value_object_init         (GValue     *value);
-static void g_value_object_free_value       (GValue     *value);
-static void g_value_object_copy_value       (const GValue   *src_value,
-                             GValue     *dest_value);
-static void g_value_object_transform_value      (const GValue   *src_value,
-                             GValue     *dest_value);
+static void g_object_real_dispose     (GObject  *object);
+static void g_object_finalize     (GObject  *object);
+static void g_object_do_set_property    (GObject        *object,
+               guint           property_id,
+               const GValue   *value,
+               GParamSpec     *pspec);
+static void g_object_do_get_property    (GObject        *object,
+               guint           property_id,
+               GValue         *value,
+               GParamSpec     *pspec);
+static void g_value_object_init     (GValue   *value);
+static void g_value_object_free_value   (GValue   *value);
+static void g_value_object_copy_value   (const GValue *src_value,
+               GValue   *dest_value);
+static void g_value_object_transform_value    (const GValue *src_value,
+               GValue   *dest_value);
 static gpointer g_value_object_peek_pointer             (const GValue   *value);
-static gchar*   g_value_object_collect_value        (GValue     *value,
-                             guint           n_collect_values,
-                             GTypeCValue    *collect_values,
-                             guint           collect_flags);
-static gchar*   g_value_object_lcopy_value      (const GValue   *value,
-                             guint           n_collect_values,
-                             GTypeCValue    *collect_values,
-                             guint           collect_flags);
-static void g_object_dispatch_properties_changed    (GObject    *object,
-                             guint       n_pspecs,
-                             GParamSpec    **pspecs);
+static gchar* g_value_object_collect_value    (GValue   *value,
+               guint           n_collect_values,
+               GTypeCValue    *collect_values,
+               guint           collect_flags);
+static gchar* g_value_object_lcopy_value    (const GValue *value,
+               guint           n_collect_values,
+               GTypeCValue    *collect_values,
+               guint           collect_flags);
+static void g_object_dispatch_properties_changed  (GObject  *object,
+               guint     n_pspecs,
+               GParamSpec    **pspecs);
 static guint               object_floating_flag_handler (GObject        *object,
                                                          gint            job);
 
 static void object_interface_check_properties           (gpointer        check_data,
-                             gpointer        g_iface);
+               gpointer        g_iface);
 
 /* --- typedefs --- */
 typedef struct _GObjectNotifyQueue            GObjectNotifyQueue;
 
 struct _GObjectNotifyQueue
@@ -196,20 +219,20 @@
 
 /* --- variables --- */
 G_LOCK_DEFINE_STATIC (closure_array_mutex);
 G_LOCK_DEFINE_STATIC (weak_refs_mutex);
 G_LOCK_DEFINE_STATIC (toggle_refs_mutex);
-static GQuark               quark_closure_array = 0;
-static GQuark               quark_weak_refs = 0;
-static GQuark               quark_toggle_refs = 0;
+static GQuark             quark_closure_array = 0;
+static GQuark             quark_weak_refs = 0;
+static GQuark             quark_toggle_refs = 0;
 static GQuark               quark_notify_queue;
 static GQuark               quark_in_construction;
 static GParamSpecPool      *pspec_pool = NULL;
-static gulong               gobject_signals[LAST_SIGNAL] = { 0, };
+static gulong             gobject_signals[LAST_SIGNAL] = { 0, };
 static guint (*floating_flag_handler) (GObject*, gint) = object_floating_flag_handler;
 /* qdata pointing to GSList<GWeakRef *>, protected by weak_locations_lock */
-static GQuark               quark_weak_locations = 0;
+static GQuark             quark_weak_locations = 0;
 static GRWLock              weak_locations_lock;
 
 G_LOCK_DEFINE_STATIC(notify_lock);
 
 /* --- functions --- */
@@ -261,11 +284,10 @@
 {
   GParamSpec *pspecs_mem[16], **pspecs, **free_me = NULL;
   GSList *slist;
   guint n_pspecs = 0;
 
-  g_return_if_fail (nqueue->freeze_count > 0);
   g_return_if_fail (g_atomic_int_get(&object->ref_count) > 0);
 
   G_LOCK(notify_lock);
 
   /* Just make sure we never get into some nasty race condition */
@@ -315,24 +337,24 @@
   G_UNLOCK(notify_lock);
 }
 
 #ifdef  G_ENABLE_DEBUG
 G_LOCK_DEFINE_STATIC     (debug_objects);
-static guint         debug_objects_count = 0;
-static GHashTable   *debug_objects_ht = NULL;
+static guint     debug_objects_count = 0;
+static GHashTable *debug_objects_ht = NULL;
 
 static void
 debug_objects_foreach (gpointer key,
-               gpointer value,
-               gpointer user_data)
+           gpointer value,
+           gpointer user_data)
 {
   GObject *object = value;
 
   g_message ("[%p] stale %s\tref_count=%u",
-         object,
-         G_OBJECT_TYPE_NAME (object),
-         object->ref_count);
+       object,
+       G_OBJECT_TYPE_NAME (object),
+       object->ref_count);
 }
 
 #ifdef G_HAS_CONSTRUCTORS
 #ifdef G_DEFINE_DESTRUCTOR_NEEDS_PRAGMA
 #pragma G_DEFINE_DESTRUCTOR_PRAGMA_ARGS(debug_objects_atexit)
@@ -363,28 +385,28 @@
   GTypeInfo info = {
     sizeof (GObjectClass),
     (GBaseInitFunc) g_object_base_class_init,
     (GBaseFinalizeFunc) g_object_base_class_finalize,
     (GClassInitFunc) g_object_do_class_init,
-    NULL    /* class_destroy */,
-    NULL    /* class_data */,
+    NULL  /* class_destroy */,
+    NULL  /* class_data */,
     sizeof (GObject),
-    0       /* n_preallocs */,
+    0   /* n_preallocs */,
     (GInstanceInitFunc) g_object_init,
-    NULL,   /* value_table */
+    NULL, /* value_table */
   };
   static const GTypeValueTable value_table = {
-    g_value_object_init,      /* value_init */
+    g_value_object_init,    /* value_init */
     g_value_object_free_value,    /* value_free */
     g_value_object_copy_value,    /* value_copy */
     g_value_object_peek_pointer,  /* value_peek_pointer */
-    "p",              /* collect_format */
+    "p",        /* collect_format */
     g_value_object_collect_value, /* collect_value */
-    "p",              /* lcopy_format */
+    "p",        /* lcopy_format */
     g_value_object_lcopy_value,   /* lcopy_value */
   };
-  GType type;
+  GType type G_GNUC_UNUSED  /* when compiling with G_DISABLE_ASSERT */;
 
   g_return_if_fail (initialized == FALSE);
   initialized = TRUE;
 
   /* G_TYPE_OBJECT
@@ -501,34 +523,34 @@
    * [canonical parameter names][canonical-parameter-names] as
    * detail strings for the notify signal.
    */
   gobject_signals[NOTIFY] =
     g_signal_new (g_intern_static_string ("notify"),
-          G_TYPE_FROM_CLASS (class),
-          G_SIGNAL_RUN_FIRST | G_SIGNAL_NO_RECURSE | G_SIGNAL_DETAILED | G_SIGNAL_NO_HOOKS | G_SIGNAL_ACTION,
-          G_STRUCT_OFFSET (GObjectClass, notify),
-          NULL, NULL,
-          g_cclosure_marshal_VOID__PARAM,
-          G_TYPE_NONE,
-          1, G_TYPE_PARAM);
+      G_TYPE_FROM_CLASS (class),
+      G_SIGNAL_RUN_FIRST | G_SIGNAL_NO_RECURSE | G_SIGNAL_DETAILED | G_SIGNAL_NO_HOOKS | G_SIGNAL_ACTION,
+      G_STRUCT_OFFSET (GObjectClass, notify),
+      NULL, NULL,
+      NULL,
+      G_TYPE_NONE,
+      1, G_TYPE_PARAM);
 
   /* Install a check function that we'll use to verify that classes that
    * implement an interface implement all properties for that interface
    */
   g_type_add_interface_check (NULL, object_interface_check_properties);
 }
 
 static inline gboolean
 install_property_internal (GType       g_type,
-               guint       property_id,
-               GParamSpec *pspec)
+         guint       property_id,
+         GParamSpec *pspec)
 {
   if (g_param_spec_pool_lookup (pspec_pool, pspec->name, g_type, FALSE))
     {
       g_warning ("When installing property: type '%s' already has a property named '%s'",
-         g_type_name (g_type),
-         pspec->name);
+     g_type_name (g_type),
+     pspec->name);
       return FALSE;
     }
 
   g_param_spec_ref_sink (pspec);
   PARAM_SPEC_SET_PARAM_ID (pspec, property_id);
@@ -538,11 +560,11 @@
 
 static gboolean
 validate_pspec_to_install (GParamSpec *pspec)
 {
   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), FALSE);
-  g_return_val_if_fail (PARAM_SPEC_PARAM_ID (pspec) == 0, FALSE);   /* paranoid */
+  g_return_val_if_fail (PARAM_SPEC_PARAM_ID (pspec) == 0, FALSE); /* paranoid */
 
   g_return_val_if_fail (pspec->flags & (G_PARAM_READABLE | G_PARAM_WRITABLE), FALSE);
 
   if (pspec->flags & G_PARAM_CONSTRUCT)
     g_return_val_if_fail ((pspec->flags & G_PARAM_CONSTRUCT_ONLY) == 0, FALSE);
@@ -604,12 +626,12 @@
  * by installing a property with the same name. This can be useful at times,
  * e.g. to change the range of allowed values or the default value.
  */
 void
 g_object_class_install_property (GObjectClass *class,
-                 guint         property_id,
-                                 GParamSpec   *pspec)
+         guint         property_id,
+         GParamSpec   *pspec)
 {
   GType oclass_type, parent_type;
 
   g_return_if_fail (G_IS_OBJECT_CLASS (class));
   g_return_if_fail (property_id > 0);
@@ -759,11 +781,11 @@
  *
  * Since: 2.4
  */
 void
 g_object_interface_install_property (gpointer      g_iface,
-                     GParamSpec   *pspec)
+             GParamSpec   *pspec)
 {
   GTypeInterface *iface_class = g_iface;
 
   g_return_if_fail (G_TYPE_IS_INTERFACE (iface_class->g_type));
   g_return_if_fail (!G_IS_PARAM_SPEC_OVERRIDE (pspec)); /* paranoid */
@@ -784,39 +806,39 @@
  * Returns: (transfer none): the #GParamSpec for the property, or
  *          %NULL if the class doesn't have a property of that name
  */
 GParamSpec*
 g_object_class_find_property (GObjectClass *class,
-                  const gchar  *property_name)
+            const gchar  *property_name)
 {
   GParamSpec *pspec;
   GParamSpec *redirect;
 
   g_return_val_if_fail (G_IS_OBJECT_CLASS (class), NULL);
   g_return_val_if_fail (property_name != NULL, NULL);
 
   pspec = g_param_spec_pool_lookup (pspec_pool,
-                    property_name,
-                    G_OBJECT_CLASS_TYPE (class),
-                    TRUE);
+            property_name,
+            G_OBJECT_CLASS_TYPE (class),
+            TRUE);
   if (pspec)
     {
       redirect = g_param_spec_get_redirect_target (pspec);
       if (redirect)
-    return redirect;
+  return redirect;
       else
-    return pspec;
+  return pspec;
     }
   else
     return NULL;
 }
 
 /**
  * g_object_interface_find_property:
  * @g_iface: (type GObject.TypeInterface): any interface vtable for the
  *  interface, or the default vtable for the interface
- * @property_name: name of a property to lookup.
+ * @property_name: name of a property to look up.
  *
  * Find the #GParamSpec with the given name for an
  * interface. Generally, the interface vtable passed in as @g_iface
  * will be the default vtable from g_type_default_interface_ref(), or,
  * if you know the interface has already been loaded,
@@ -828,21 +850,21 @@
  *          interface with the name @property_name, or %NULL if no
  *          such property exists.
  */
 GParamSpec*
 g_object_interface_find_property (gpointer      g_iface,
-                  const gchar  *property_name)
+          const gchar  *property_name)
 {
   GTypeInterface *iface_class = g_iface;
 
   g_return_val_if_fail (G_TYPE_IS_INTERFACE (iface_class->g_type), NULL);
   g_return_val_if_fail (property_name != NULL, NULL);
 
   return g_param_spec_pool_lookup (pspec_pool,
-                   property_name,
-                   iface_class->g_type,
-                   FALSE);
+           property_name,
+           iface_class->g_type,
+           FALSE);
 }
 
 /**
  * g_object_class_override_property:
  * @oclass: a #GObjectClass
@@ -869,12 +891,12 @@
  *
  * Since: 2.4
  */
 void
 g_object_class_override_property (GObjectClass *oclass,
-                  guint         property_id,
-                  const gchar  *name)
+          guint         property_id,
+          const gchar  *name)
 {
   GParamSpec *overridden = NULL;
   GParamSpec *new;
   GType parent_type;
 
@@ -885,36 +907,36 @@
   /* Find the overridden property; first check parent types
    */
   parent_type = g_type_parent (G_OBJECT_CLASS_TYPE (oclass));
   if (parent_type != G_TYPE_NONE)
     overridden = g_param_spec_pool_lookup (pspec_pool,
-                       name,
-                       parent_type,
-                       TRUE);
+             name,
+             parent_type,
+             TRUE);
   if (!overridden)
     {
       GType *ifaces;
       guint n_ifaces;
 
       /* Now check interfaces
        */
       ifaces = g_type_interfaces (G_OBJECT_CLASS_TYPE (oclass), &n_ifaces);
       while (n_ifaces-- && !overridden)
-    {
-      overridden = g_param_spec_pool_lookup (pspec_pool,
-                         name,
-                         ifaces[n_ifaces],
-                         FALSE);
-    }
+  {
+    overridden = g_param_spec_pool_lookup (pspec_pool,
+             name,
+             ifaces[n_ifaces],
+             FALSE);
+  }
 
       g_free (ifaces);
     }
 
   if (!overridden)
     {
       g_warning ("%s: Can't find property to override for '%s::%s'",
-         G_STRFUNC, G_OBJECT_CLASS_NAME (oclass), name);
+     G_STRFUNC, G_OBJECT_CLASS_NAME (oclass), name);
       return;
     }
 
   new = g_param_spec_override (name, overridden);
   g_object_class_install_property (oclass, property_id, new);
@@ -930,20 +952,20 @@
  * Returns: (array length=n_properties) (transfer container): an array of
  *          #GParamSpec* which should be freed after use
  */
 GParamSpec** /* free result */
 g_object_class_list_properties (GObjectClass *class,
-                guint        *n_properties_p)
+        guint        *n_properties_p)
 {
   GParamSpec **pspecs;
   guint n;
 
   g_return_val_if_fail (G_IS_OBJECT_CLASS (class), NULL);
 
   pspecs = g_param_spec_pool_list (pspec_pool,
-                   G_OBJECT_CLASS_TYPE (class),
-                   &n);
+           G_OBJECT_CLASS_TYPE (class),
+           &n);
   if (n_properties_p)
     *n_properties_p = n;
 
   return pspecs;
 }
@@ -967,21 +989,21 @@
  *          array should be freed with g_free() when you are done with
  *          it.
  */
 GParamSpec**
 g_object_interface_list_properties (gpointer      g_iface,
-                    guint        *n_properties_p)
+            guint        *n_properties_p)
 {
   GTypeInterface *iface_class = g_iface;
   GParamSpec **pspecs;
   guint n;
 
   g_return_val_if_fail (G_TYPE_IS_INTERFACE (iface_class->g_type), NULL);
 
   pspecs = g_param_spec_pool_list (pspec_pool,
-                   iface_class->g_type,
-                   &n);
+           iface_class->g_type,
+           &n);
   if (n_properties_p)
     *n_properties_p = n;
 
   return pspecs;
 }
@@ -991,12 +1013,12 @@
 {
   return g_datalist_id_get_data (&object->qdata, quark_in_construction) != NULL;
 }
 
 static void
-g_object_init (GObject      *object,
-           GObjectClass *class)
+g_object_init (GObject    *object,
+         GObjectClass *class)
 {
   object->ref_count = 1;
   object->qdata = NULL;
 
   if (CLASS_HAS_PROPS (class))
@@ -1020,13 +1042,13 @@
     });
 }
 
 static void
 g_object_do_set_property (GObject      *object,
-              guint         property_id,
-              const GValue *value,
-              GParamSpec   *pspec)
+        guint         property_id,
+        const GValue *value,
+        GParamSpec   *pspec)
 {
   switch (property_id)
     {
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
@@ -1034,13 +1056,13 @@
     }
 }
 
 static void
 g_object_do_get_property (GObject     *object,
-              guint        property_id,
-              GValue      *value,
-              GParamSpec  *pspec)
+        guint        property_id,
+        GValue      *value,
+        GParamSpec  *pspec)
 {
   switch (property_id)
     {
     default:
       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
@@ -1077,12 +1099,12 @@
     });
 }
 
 static void
 g_object_dispatch_properties_changed (GObject     *object,
-                      guint        n_pspecs,
-                      GParamSpec **pspecs)
+              guint        n_pspecs,
+              GParamSpec **pspecs)
 {
   guint i;
 
   for (i = 0; i < n_pspecs; i++)
     g_signal_emit (object, gobject_signals[NOTIFY], g_param_spec_get_name_quark (pspecs[i]), pspecs[i]);
@@ -1099,11 +1121,11 @@
  */
 void
 g_object_run_dispose (GObject *object)
 {
   g_return_if_fail (G_IS_OBJECT (object));
-  g_return_if_fail (object->ref_count > 0);
+  g_return_if_fail (g_atomic_int_get (&object->ref_count) > 0);
 
   g_object_ref (object);
   TRACE (GOBJECT_OBJECT_DISPOSE(object,G_TYPE_FROM_INSTANCE(object), 0));
   G_OBJECT_GET_CLASS (object)->dispose (object);
   TRACE (GOBJECT_OBJECT_DISPOSE_END(object,G_TYPE_FROM_INSTANCE(object), 0));
@@ -1155,11 +1177,11 @@
   return pspec;
 }
 
 static inline void
 g_object_notify_by_spec_internal (GObject    *object,
-                  GParamSpec *pspec)
+          GParamSpec *pspec)
 {
   GParamSpec *notify_pspec;
 
   notify_pspec = get_notify_pspec (pspec);
 
@@ -1199,11 +1221,11 @@
  * and will be emitted (in reverse order) when g_object_thaw_notify() is
  * called.
  */
 void
 g_object_notify (GObject     *object,
-         const gchar *property_name)
+     const gchar *property_name)
 {
   GParamSpec *pspec;
 
   g_return_if_fail (G_IS_OBJECT (object));
   g_return_if_fail (property_name != NULL);
@@ -1214,19 +1236,19 @@
   /* We don't need to get the redirect target
    * (by, e.g. calling g_object_class_find_property())
    * because g_object_notify_queue_add() does that
    */
   pspec = g_param_spec_pool_lookup (pspec_pool,
-                    property_name,
-                    G_OBJECT_TYPE (object),
-                    TRUE);
+            property_name,
+            G_OBJECT_TYPE (object),
+            TRUE);
 
   if (!pspec)
     g_warning ("%s: object class '%s' has no property named '%s'",
-           G_STRFUNC,
-           G_OBJECT_TYPE_NAME (object),
-           property_name);
+         G_STRFUNC,
+         G_OBJECT_TYPE_NAME (object),
+         property_name);
   else
     g_object_notify_by_spec_internal (object, pspec);
   g_object_unref (object);
 }
 
@@ -1276,11 +1298,11 @@
  *
  * Since: 2.26
  */
 void
 g_object_notify_by_pspec (GObject    *object,
-              GParamSpec *pspec)
+        GParamSpec *pspec)
 {
 
   g_return_if_fail (G_IS_OBJECT (object));
   g_return_if_fail (G_IS_PARAM_SPEC (pspec));
 
@@ -1377,12 +1399,12 @@
                g_type_name (pspec->owner_type), pspec->name);
 }
 
 static inline void
 object_get_property (GObject     *object,
-             GParamSpec  *pspec,
-             GValue      *value)
+         GParamSpec  *pspec,
+         GValue      *value)
 {
   GObjectClass *class = g_type_class_peek (pspec->owner_type);
   guint param_id = PARAM_SPEC_PARAM_ID (pspec);
   GParamSpec *redirect;
 
@@ -1402,13 +1424,13 @@
   class->get_property (object, param_id, value, pspec);
 }
 
 static inline void
 object_set_property (GObject             *object,
-             GParamSpec          *pspec,
-             const GValue        *value,
-             GObjectNotifyQueue  *nqueue)
+         GParamSpec          *pspec,
+         const GValue        *value,
+         GObjectNotifyQueue  *nqueue)
 {
   GValue tmp_value = G_VALUE_INIT;
   GObjectClass *class = g_type_class_peek (pspec->owner_type);
   guint param_id = PARAM_SPEC_PARAM_ID (pspec);
   GParamSpec *redirect;
@@ -1426,22 +1448,22 @@
 
   /* provide a copy to work from, convert (if necessary) and validate */
   g_value_init (&tmp_value, pspec->value_type);
   if (!g_value_transform (value, &tmp_value))
     g_warning ("unable to set property '%s' of type '%s' from value of type '%s'",
-           pspec->name,
-           g_type_name (pspec->value_type),
-           G_VALUE_TYPE_NAME (value));
+         pspec->name,
+         g_type_name (pspec->value_type),
+         G_VALUE_TYPE_NAME (value));
   else if (g_param_value_validate (pspec, &tmp_value) && !(pspec->flags & G_PARAM_LAX_VALIDATION))
     {
       gchar *contents = g_strdup_value_contents (value);
 
       g_warning ("value \"%s\" of type '%s' is invalid or out of range for property '%s' of type '%s'",
-         contents,
-         G_VALUE_TYPE_NAME (value),
-         pspec->name,
-         g_type_name (pspec->value_type));
+     contents,
+     G_VALUE_TYPE_NAME (value),
+     pspec->name,
+     g_type_name (pspec->value_type));
       g_free (contents);
     }
   else
     {
       class->set_property (object, param_id, &tmp_value, pspec);
@@ -1459,11 +1481,11 @@
   g_value_unset (&tmp_value);
 }
 
 static void
 object_interface_check_properties (gpointer check_data,
-                   gpointer g_iface)
+           gpointer g_iface)
 {
   GTypeInterface *iface_class = g_iface;
   GObjectClass *class;
   GType iface_type = iface_class->g_type;
   GParamSpec **pspecs;
@@ -1480,24 +1502,24 @@
   pspecs = g_param_spec_pool_list (pspec_pool, iface_type, &n);
 
   while (n--)
     {
       GParamSpec *class_pspec = g_param_spec_pool_lookup (pspec_pool,
-                              pspecs[n]->name,
-                              G_OBJECT_CLASS_TYPE (class),
-                              TRUE);
+                pspecs[n]->name,
+                G_OBJECT_CLASS_TYPE (class),
+                TRUE);
 
       if (!class_pspec)
-    {
-      g_critical ("Object class %s doesn't implement property "
-              "'%s' from interface '%s'",
-              g_type_name (G_OBJECT_CLASS_TYPE (class)),
-              pspecs[n]->name,
-              g_type_name (iface_type));
-
-      continue;
-    }
+  {
+    g_critical ("Object class %s doesn't implement property "
+          "'%s' from interface '%s'",
+          g_type_name (G_OBJECT_CLASS_TYPE (class)),
+          pspecs[n]->name,
+          g_type_name (iface_type));
+
+    continue;
+  }
 
       /* We do a number of checks on the properties of an interface to
        * make sure that all classes implementing the interface are
        * overriding the properties in a sane way.
        *
@@ -1632,12 +1654,12 @@
  * Returns: (transfer full) (type GObject.Object): a new instance of
  *   @object_type
  */
 gpointer
 g_object_new (GType    object_type,
-              const gchar *first_property_name,
-              ...)
+        const gchar *first_property_name,
+        ...)
 {
   GObject *object;
   va_list var_args;
 
   /* short circuit for calls supplying no properties */
@@ -1705,11 +1727,11 @@
             consider_issuing_property_deprecation_warning (pspec);
             value = params[j].value;
             break;
           }
 
-      if (j == n_params)
+      if (value == NULL)
         {
           value = &cvalues[cvals_used++];
           g_value_init (value, pspec->value_type);
           g_param_value_set_default (pspec, value);
         }
@@ -1831,11 +1853,11 @@
                 consider_issuing_property_deprecation_warning (pspec);
                 value = params[j].value;
                 break;
               }
 
-          if (j == n_params)
+          if (value == NULL)
             value = g_param_spec_get_default_value (pspec);
 
           object_set_property (object, pspec, value, nqueue);
         }
     }
@@ -1993,10 +2015,11 @@
  * @object_type
  *
  * Deprecated: 2.54: Use g_object_new_with_properties() instead.
  * deprecated. See #GParameter for more information.
  */
+G_GNUC_BEGIN_IGNORE_DEPRECATIONS
 gpointer
 g_object_newv (GType       object_type,
                guint       n_parameters,
                GParameter *parameters)
 {
@@ -2044,10 +2067,11 @@
   if (unref_class)
     g_type_class_unref (unref_class);
 
   return object;
 }
+G_GNUC_END_IGNORE_DEPRECATIONS
 
 /**
  * g_object_new_valist: (skip)
  * @object_type: the type id of the #GObject subtype to instantiate
  * @first_property_name: the name of the first property
@@ -2143,12 +2167,12 @@
   return object;
 }
 
 static GObject*
 g_object_constructor (GType                  type,
-              guint                  n_construct_properties,
-              GObjectConstructParam *construct_params)
+          guint                  n_construct_properties,
+          GObjectConstructParam *construct_params)
 {
   GObject *object;
 
   /* create object */
   object = (GObject*) g_type_create_instance (type);
@@ -2158,17 +2182,17 @@
     {
       GObjectNotifyQueue *nqueue = g_object_notify_queue_freeze (object, FALSE);
 
       /* set construct properties */
       while (n_construct_properties--)
-    {
-      GValue *value = construct_params->value;
-      GParamSpec *pspec = construct_params->pspec;
+  {
+    GValue *value = construct_params->value;
+    GParamSpec *pspec = construct_params->pspec;
 
-      construct_params++;
-      object_set_property (object, pspec, value, nqueue);
-    }
+    construct_params++;
+    object_set_property (object, pspec, value, nqueue);
+  }
       g_object_notify_queue_thaw (object, nqueue);
       /* the notification queue is still frozen from g_object_init(), so
        * we don't need to handle it here, g_object_newv() takes
        * care of that
        */
@@ -2265,13 +2289,13 @@
  *  name/value pairs, followed by %NULL
  *
  * Sets properties on an object.
  */
 void
-g_object_set_valist (GObject     *object,
-                     const gchar *first_property_name,
-             va_list      var_args)
+g_object_set_valist (GObject   *object,
+         const gchar *first_property_name,
+         va_list    var_args)
 {
   GObjectNotifyQueue *nqueue;
   const gchar *name;
 
   g_return_if_fail (G_IS_OBJECT (object));
@@ -2285,26 +2309,26 @@
       GValue value = G_VALUE_INIT;
       GParamSpec *pspec;
       gchar *error = NULL;
 
       pspec = g_param_spec_pool_lookup (pspec_pool,
-                    name,
-                    G_OBJECT_TYPE (object),
-                    TRUE);
+          name,
+          G_OBJECT_TYPE (object),
+          TRUE);
 
       if (!g_object_set_is_valid_property (object, pspec, name))
         break;
 
       G_VALUE_COLLECT_INIT (&value, pspec->value_type, var_args,
-                0, &error);
+          0, &error);
       if (error)
-    {
-      g_warning ("%s: %s", G_STRFUNC, error);
-      g_free (error);
+  {
+    g_warning ("%s: %s", G_STRFUNC, error);
+    g_free (error);
           g_value_unset (&value);
-      break;
-    }
+    break;
+  }
 
       consider_issuing_property_deprecation_warning (pspec);
       object_set_property (object, pspec, &value, nqueue);
       g_value_unset (&value);
 
@@ -2368,13 +2392,13 @@
 
   obj_type = G_OBJECT_TYPE (object);
   for (i = 0; i < n_properties; i++)
     {
       pspec = g_param_spec_pool_lookup (pspec_pool,
-                        names[i],
-                        obj_type,
-                        TRUE);
+                names[i],
+                obj_type,
+                TRUE);
       if (!g_object_get_is_valid_property (object, pspec, names[i]))
         break;
 
       memset (&values[i], 0, sizeof (GValue));
       g_value_init (&values[i], pspec->value_type);
@@ -2397,13 +2421,13 @@
  * the type, for instance by calling g_free() or g_object_unref().
  *
  * See g_object_get().
  */
 void
-g_object_get_valist (GObject     *object,
-                     const gchar *first_property_name,
-             va_list      var_args)
+g_object_get_valist (GObject   *object,
+         const gchar *first_property_name,
+         va_list    var_args)
 {
   const gchar *name;
 
   g_return_if_fail (G_IS_OBJECT (object));
 
@@ -2416,29 +2440,29 @@
       GValue value = G_VALUE_INIT;
       GParamSpec *pspec;
       gchar *error;
 
       pspec = g_param_spec_pool_lookup (pspec_pool,
-                    name,
-                    G_OBJECT_TYPE (object),
-                    TRUE);
+          name,
+          G_OBJECT_TYPE (object),
+          TRUE);
 
       if (!g_object_get_is_valid_property (object, pspec, name))
         break;
 
       g_value_init (&value, pspec->value_type);
 
       object_get_property (object, pspec, &value);
 
       G_VALUE_LCOPY (&value, var_args, 0, &error);
       if (error)
-    {
-      g_warning ("%s: %s", G_STRFUNC, error);
-      g_free (error);
-      g_value_unset (&value);
-      break;
-    }
+  {
+    g_warning ("%s: %s", G_STRFUNC, error);
+    g_free (error);
+    g_value_unset (&value);
+    break;
+  }
 
       g_value_unset (&value);
 
       name = va_arg (var_args, gchar*);
     }
@@ -2459,12 +2483,12 @@
  * reverse order) after all properties have been set. See
  * g_object_freeze_notify().
  */
 void
 g_object_set (gpointer     _object,
-          const gchar *first_property_name,
-          ...)
+        const gchar *first_property_name,
+        ...)
 {
   GObject *object = _object;
   va_list var_args;
 
   g_return_if_fail (G_IS_OBJECT (object));
@@ -2506,12 +2530,12 @@
  *  g_object_unref (objval);
  *  ]|
  */
 void
 g_object_get (gpointer     _object,
-          const gchar *first_property_name,
-          ...)
+        const gchar *first_property_name,
+        ...)
 {
   GObject *object = _object;
   va_list var_args;
 
   g_return_if_fail (G_IS_OBJECT (object));
@@ -2529,81 +2553,93 @@
  *
  * Sets a property on an object.
  */
 void
 g_object_set_property (GObject      *object,
-                       const gchar  *property_name,
-                       const GValue *value)
+           const gchar  *property_name,
+           const GValue *value)
 {
   g_object_setv (object, 1, &property_name, value);
 }
 
 /**
  * g_object_get_property:
  * @object: a #GObject
  * @property_name: the name of the property to get
  * @value: return location for the property value
  *
- * Gets a property of an object. @value must have been initialized to the
- * expected type of the property (or a type to which the expected type can be
- * transformed) using g_value_init().
+ * Gets a property of an object.
+ *
+ * The @value can be:
+ *
+ *  - an empty #GValue initialized by %G_VALUE_INIT, which will be
+ *    automatically initialized with the expected type of the property
+ *    (since GLib 2.60)
+ *  - a #GValue initialized with the expected type of the property
+ *  - a #GValue initialized with a type to which the expected type
+ *    of the property can be transformed
  *
  * In general, a copy is made of the property contents and the caller is
  * responsible for freeing the memory by calling g_value_unset().
  *
  * Note that g_object_get_property() is really intended for language
  * bindings, g_object_get() is much more convenient for C programming.
  */
 void
 g_object_get_property (GObject     *object,
-                       const gchar *property_name,
-               GValue      *value)
+           const gchar *property_name,
+           GValue    *value)
 {
   GParamSpec *pspec;
 
   g_return_if_fail (G_IS_OBJECT (object));
   g_return_if_fail (property_name != NULL);
-  g_return_if_fail (G_IS_VALUE (value));
+  g_return_if_fail (value != NULL);
 
   g_object_ref (object);
 
   pspec = g_param_spec_pool_lookup (pspec_pool,
-                    property_name,
-                    G_OBJECT_TYPE (object),
-                    TRUE);
+            property_name,
+            G_OBJECT_TYPE (object),
+            TRUE);
 
   if (g_object_get_is_valid_property (object, pspec, property_name))
     {
       GValue *prop_value, tmp_value = G_VALUE_INIT;
 
-      /* auto-conversion of the callers value type
-       */
-      if (G_VALUE_TYPE (value) == pspec->value_type)
-    {
-      g_value_reset (value);
-      prop_value = value;
-    }
+      if (G_VALUE_TYPE (value) == G_TYPE_INVALID)
+        {
+          /* zero-initialized value */
+          g_value_init (value, pspec->value_type);
+          prop_value = value;
+        }
+      else if (G_VALUE_TYPE (value) == pspec->value_type)
+        {
+          /* auto-conversion of the callers value type */
+          g_value_reset (value);
+          prop_value = value;
+        }
       else if (!g_value_type_transformable (pspec->value_type, G_VALUE_TYPE (value)))
-    {
-      g_warning ("%s: can't retrieve property '%s' of type '%s' as value of type '%s'",
-             G_STRFUNC, pspec->name,
-             g_type_name (pspec->value_type),
-             G_VALUE_TYPE_NAME (value));
-      g_object_unref (object);
-      return;
-    }
+        {
+          g_warning ("%s: can't retrieve property '%s' of type '%s' as value of type '%s'",
+                     G_STRFUNC, pspec->name,
+                     g_type_name (pspec->value_type),
+                     G_VALUE_TYPE_NAME (value));
+          g_object_unref (object);
+          return;
+        }
       else
-    {
-      g_value_init (&tmp_value, pspec->value_type);
-      prop_value = &tmp_value;
-    }
+        {
+          g_value_init (&tmp_value, pspec->value_type);
+          prop_value = &tmp_value;
+        }
       object_get_property (object, pspec, prop_value);
       if (prop_value != value)
-    {
-      g_value_transform (prop_value, value);
-      g_value_unset (&tmp_value);
-    }
+        {
+          g_value_transform (prop_value, value);
+          g_value_unset (&tmp_value);
+        }
     }
 
   g_object_unref (object);
 }
 
@@ -2617,36 +2653,36 @@
  *
  * A convenience function to connect multiple signals at once.
  *
  * The signal specs expected by this function have the form
  * "modifier::signal_name", where modifier can be one of the following:
- * * - signal: equivalent to g_signal_connect_data (..., NULL, 0)
+ * - signal: equivalent to g_signal_connect_data (..., NULL, 0)
  * - object-signal, object_signal: equivalent to g_signal_connect_object (..., 0)
  * - swapped-signal, swapped_signal: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED)
  * - swapped_object_signal, swapped-object-signal: equivalent to g_signal_connect_object (..., G_CONNECT_SWAPPED)
  * - signal_after, signal-after: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_AFTER)
  * - object_signal_after, object-signal-after: equivalent to g_signal_connect_object (..., G_CONNECT_AFTER)
  * - swapped_signal_after, swapped-signal-after: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED | G_CONNECT_AFTER)
  * - swapped_object_signal_after, swapped-object-signal-after: equivalent to g_signal_connect_object (..., G_CONNECT_SWAPPED | G_CONNECT_AFTER)
  *
  * |[<!-- language="C" -->
  *   menu->toplevel = g_object_connect (g_object_new (GTK_TYPE_WINDOW,
- *                         "type", GTK_WINDOW_POPUP,
- *                         "child", menu,
- *                         NULL),
- *                   "signal::event", gtk_menu_window_event, menu,
- *                   "signal::size_request", gtk_menu_window_size_request, menu,
- *                   "signal::destroy", gtk_widget_destroyed, &menu->toplevel,
- *                   NULL);
+ *               "type", GTK_WINDOW_POPUP,
+ *               "child", menu,
+ *               NULL),
+ *             "signal::event", gtk_menu_window_event, menu,
+ *             "signal::size_request", gtk_menu_window_size_request, menu,
+ *             "signal::destroy", gtk_widget_destroyed, &menu->toplevel,
+ *             NULL);
  * ]|
  *
  * Returns: (transfer none) (type GObject.Object): @object
  */
 gpointer
 g_object_connect (gpointer     _object,
-          const gchar *signal_spec,
-          ...)
+      const gchar *signal_spec,
+      ...)
 {
   GObject *object = _object;
   va_list var_args;
 
   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
@@ -2657,53 +2693,53 @@
     {
       GCallback callback = va_arg (var_args, GCallback);
       gpointer data = va_arg (var_args, gpointer);
 
       if (strncmp (signal_spec, "signal::", 8) == 0)
-    g_signal_connect_data (object, signal_spec + 8,
-                   callback, data, NULL,
-                   0);
+  g_signal_connect_data (object, signal_spec + 8,
+             callback, data, NULL,
+             0);
       else if (strncmp (signal_spec, "object_signal::", 15) == 0 ||
                strncmp (signal_spec, "object-signal::", 15) == 0)
-    g_signal_connect_object (object, signal_spec + 15,
-                 callback, data,
-                 0);
+  g_signal_connect_object (object, signal_spec + 15,
+         callback, data,
+         0);
       else if (strncmp (signal_spec, "swapped_signal::", 16) == 0 ||
                strncmp (signal_spec, "swapped-signal::", 16) == 0)
-    g_signal_connect_data (object, signal_spec + 16,
-                   callback, data, NULL,
-                   G_CONNECT_SWAPPED);
+  g_signal_connect_data (object, signal_spec + 16,
+             callback, data, NULL,
+             G_CONNECT_SWAPPED);
       else if (strncmp (signal_spec, "swapped_object_signal::", 23) == 0 ||
                strncmp (signal_spec, "swapped-object-signal::", 23) == 0)
-    g_signal_connect_object (object, signal_spec + 23,
-                 callback, data,
-                 G_CONNECT_SWAPPED);
+  g_signal_connect_object (object, signal_spec + 23,
+         callback, data,
+         G_CONNECT_SWAPPED);
       else if (strncmp (signal_spec, "signal_after::", 14) == 0 ||
                strncmp (signal_spec, "signal-after::", 14) == 0)
-    g_signal_connect_data (object, signal_spec + 14,
-                   callback, data, NULL,
-                   G_CONNECT_AFTER);
+  g_signal_connect_data (object, signal_spec + 14,
+             callback, data, NULL,
+             G_CONNECT_AFTER);
       else if (strncmp (signal_spec, "object_signal_after::", 21) == 0 ||
                strncmp (signal_spec, "object-signal-after::", 21) == 0)
-    g_signal_connect_object (object, signal_spec + 21,
-                 callback, data,
-                 G_CONNECT_AFTER);
+  g_signal_connect_object (object, signal_spec + 21,
+         callback, data,
+         G_CONNECT_AFTER);
       else if (strncmp (signal_spec, "swapped_signal_after::", 22) == 0 ||
                strncmp (signal_spec, "swapped-signal-after::", 22) == 0)
-    g_signal_connect_data (object, signal_spec + 22,
-                   callback, data, NULL,
-                   G_CONNECT_SWAPPED | G_CONNECT_AFTER);
+  g_signal_connect_data (object, signal_spec + 22,
+             callback, data, NULL,
+             G_CONNECT_SWAPPED | G_CONNECT_AFTER);
       else if (strncmp (signal_spec, "swapped_object_signal_after::", 29) == 0 ||
                strncmp (signal_spec, "swapped-object-signal-after::", 29) == 0)
-    g_signal_connect_object (object, signal_spec + 29,
-                 callback, data,
-                 G_CONNECT_SWAPPED | G_CONNECT_AFTER);
+  g_signal_connect_object (object, signal_spec + 29,
+         callback, data,
+         G_CONNECT_SWAPPED | G_CONNECT_AFTER);
       else
-    {
-      g_warning ("%s: invalid signal spec \"%s\"", G_STRFUNC, signal_spec);
-      break;
-    }
+  {
+    g_warning ("%s: invalid signal spec \"%s\"", G_STRFUNC, signal_spec);
+    break;
+  }
       signal_spec = va_arg (var_args, gchar*);
     }
   va_end (var_args);
 
   return object;
@@ -2724,12 +2760,12 @@
  * callback and data, or "any_signal::signal_name", which only
  * disconnects the signal named "signal_name".
  */
 void
 g_object_disconnect (gpointer     _object,
-             const gchar *signal_spec,
-             ...)
+         const gchar *signal_spec,
+         ...)
 {
   GObject *object = _object;
   va_list var_args;
 
   g_return_if_fail (G_IS_OBJECT (object));
@@ -2742,33 +2778,33 @@
       gpointer data = va_arg (var_args, gpointer);
       guint sid = 0, detail = 0, mask = 0;
 
       if (strncmp (signal_spec, "any_signal::", 12) == 0 ||
           strncmp (signal_spec, "any-signal::", 12) == 0)
-    {
-      signal_spec += 12;
-      mask = G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA;
-    }
+  {
+    signal_spec += 12;
+    mask = G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA;
+  }
       else if (strcmp (signal_spec, "any_signal") == 0 ||
                strcmp (signal_spec, "any-signal") == 0)
-    {
-      signal_spec += 10;
-      mask = G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA;
-    }
+  {
+    signal_spec += 10;
+    mask = G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA;
+  }
       else
-    {
-      g_warning ("%s: invalid signal spec \"%s\"", G_STRFUNC, signal_spec);
-      break;
-    }
+  {
+    g_warning ("%s: invalid signal spec \"%s\"", G_STRFUNC, signal_spec);
+    break;
+  }
 
       if ((mask & G_SIGNAL_MATCH_ID) &&
-      !g_signal_parse_name (signal_spec, G_OBJECT_TYPE (object), &sid, &detail, FALSE))
-    g_warning ("%s: invalid signal name \"%s\"", G_STRFUNC, signal_spec);
+    !g_signal_parse_name (signal_spec, G_OBJECT_TYPE (object), &sid, &detail, FALSE))
+  g_warning ("%s: invalid signal name \"%s\"", G_STRFUNC, signal_spec);
       else if (!g_signal_handlers_disconnect_matched (object, mask | (detail ? G_SIGNAL_MATCH_DETAIL : 0),
-                              sid, detail,
-                              NULL, (gpointer)callback, data))
-    g_warning ("%s: signal handler %p(%p) is not connected", G_STRFUNC, callback, data);
+                  sid, detail,
+                  NULL, (gpointer)callback, data))
+  g_warning ("%s: signal handler %p(%p) is not connected", G_STRFUNC, callback, data);
       signal_spec = va_arg (var_args, gchar*);
     }
   va_end (var_args);
 }
 
@@ -2809,19 +2845,19 @@
  * object's last g_object_unref() might happen in another thread.
  * Use #GWeakRef if thread-safety is required.
  */
 void
 g_object_weak_ref (GObject    *object,
-           GWeakNotify notify,
-           gpointer    data)
+       GWeakNotify notify,
+       gpointer    data)
 {
   WeakRefStack *wstack;
   guint i;
 
   g_return_if_fail (G_IS_OBJECT (object));
   g_return_if_fail (notify != NULL);
-  g_return_if_fail (object->ref_count >= 1);
+  g_return_if_fail (g_atomic_int_get (&object->ref_count) >= 1);
 
   G_LOCK (weak_refs_mutex);
   wstack = g_datalist_id_remove_no_notify (&object->qdata, quark_weak_refs);
   if (wstack)
     {
@@ -2849,12 +2885,12 @@
  *
  * Removes a weak reference callback to an object.
  */
 void
 g_object_weak_unref (GObject    *object,
-             GWeakNotify notify,
-             gpointer    data)
+         GWeakNotify notify,
+         gpointer    data)
 {
   WeakRefStack *wstack;
   gboolean found_one = FALSE;
 
   g_return_if_fail (G_IS_OBJECT (object));
@@ -2865,20 +2901,20 @@
   if (wstack)
     {
       guint i;
 
       for (i = 0; i < wstack->n_weak_refs; i++)
-    if (wstack->weak_refs[i].notify == notify &&
-        wstack->weak_refs[i].data == data)
-      {
-        found_one = TRUE;
-        wstack->n_weak_refs -= 1;
-        if (i != wstack->n_weak_refs)
-          wstack->weak_refs[i] = wstack->weak_refs[wstack->n_weak_refs];
+  if (wstack->weak_refs[i].notify == notify &&
+      wstack->weak_refs[i].data == data)
+    {
+      found_one = TRUE;
+      wstack->n_weak_refs -= 1;
+      if (i != wstack->n_weak_refs)
+        wstack->weak_refs[i] = wstack->weak_refs[wstack->n_weak_refs];
 
-        break;
-      }
+      break;
+    }
     }
   G_UNLOCK (weak_refs_mutex);
   if (!found_one)
     g_warning ("%s: couldn't find weak ref %p(%p)", G_STRFUNC, notify, data);
 }
@@ -2999,11 +3035,11 @@
 (g_object_ref_sink) (gpointer _object)
 {
   GObject *object = _object;
   gboolean was_floating;
   g_return_val_if_fail (G_IS_OBJECT (object), object);
-  g_return_val_if_fail (object->ref_count >= 1, object);
+  g_return_val_if_fail (g_atomic_int_get (&object->ref_count) >= 1, object);
   g_object_ref (object);
   was_floating = floating_flag_handler (object, -1);
   if (was_floating)
     g_object_unref (object);
   return object;
@@ -3022,11 +3058,11 @@
  */
 void
 g_object_force_floating (GObject *object)
 {
   g_return_if_fail (G_IS_OBJECT (object));
-  g_return_if_fail (object->ref_count >= 1);
+  g_return_if_fail (g_atomic_int_get (&object->ref_count) >= 1);
 
   floating_flag_handler (object, +1);
 }
 
 typedef struct {
@@ -3038,11 +3074,11 @@
   } toggle_refs[1];  /* flexible array */
 } ToggleRefStack;
 
 static void
 toggle_refs_notify (GObject *object,
-            gboolean is_last_ref)
+        gboolean is_last_ref)
 {
   ToggleRefStack tstack, *tstackptr;
 
   G_LOCK (toggle_refs_mutex);
   tstackptr = g_datalist_id_get_data (&object->qdata, quark_toggle_refs);
@@ -3095,19 +3131,19 @@
  *
  * Since: 2.8
  */
 void
 g_object_add_toggle_ref (GObject       *object,
-             GToggleNotify  notify,
-             gpointer       data)
+       GToggleNotify  notify,
+       gpointer       data)
 {
   ToggleRefStack *tstack;
   guint i;
 
   g_return_if_fail (G_IS_OBJECT (object));
   g_return_if_fail (notify != NULL);
-  g_return_if_fail (object->ref_count >= 1);
+  g_return_if_fail (g_atomic_int_get (&object->ref_count) >= 1);
 
   g_object_ref (object);
 
   G_LOCK (toggle_refs_mutex);
   tstack = g_datalist_id_remove_no_notify (&object->qdata, quark_toggle_refs);
@@ -3131,11 +3167,11 @@
     g_datalist_set_flags (&object->qdata, OBJECT_HAS_TOGGLE_REF_FLAG);
 
   tstack->toggle_refs[i].notify = notify;
   tstack->toggle_refs[i].data = data;
   g_datalist_id_set_data_full (&object->qdata, quark_toggle_refs, tstack,
-                   (GDestroyNotify)g_free);
+             (GDestroyNotify)g_free);
   G_UNLOCK (toggle_refs_mutex);
 }
 
 /**
  * g_object_remove_toggle_ref: (skip)
@@ -3150,12 +3186,12 @@
  *
  * Since: 2.8
  */
 void
 g_object_remove_toggle_ref (GObject       *object,
-                GToggleNotify  notify,
-                gpointer       data)
+          GToggleNotify  notify,
+          gpointer       data)
 {
   ToggleRefStack *tstack;
   gboolean found_one = FALSE;
 
   g_return_if_fail (G_IS_OBJECT (object));
@@ -3166,23 +3202,23 @@
   if (tstack)
     {
       guint i;
 
       for (i = 0; i < tstack->n_toggle_refs; i++)
-    if (tstack->toggle_refs[i].notify == notify &&
-        tstack->toggle_refs[i].data == data)
-      {
-        found_one = TRUE;
-        tstack->n_toggle_refs -= 1;
-        if (i != tstack->n_toggle_refs)
-          tstack->toggle_refs[i] = tstack->toggle_refs[tstack->n_toggle_refs];
+  if (tstack->toggle_refs[i].notify == notify &&
+      tstack->toggle_refs[i].data == data)
+    {
+      found_one = TRUE;
+      tstack->n_toggle_refs -= 1;
+      if (i != tstack->n_toggle_refs)
+        tstack->toggle_refs[i] = tstack->toggle_refs[tstack->n_toggle_refs];
 
-        if (tstack->n_toggle_refs == 0)
-          g_datalist_unset_flags (&object->qdata, OBJECT_HAS_TOGGLE_REF_FLAG);
+      if (tstack->n_toggle_refs == 0)
+        g_datalist_unset_flags (&object->qdata, OBJECT_HAS_TOGGLE_REF_FLAG);
 
-        break;
-      }
+      break;
+    }
     }
   G_UNLOCK (toggle_refs_mutex);
 
   if (found_one)
     g_object_unref (object);
@@ -3208,13 +3244,13 @@
 {
   GObject *object = _object;
   gint old_val;
 
   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
-  g_return_val_if_fail (object->ref_count > 0, NULL);
 
   old_val = g_atomic_int_add (&object->ref_count, 1);
+  g_return_val_if_fail (old_val > 0, NULL);
 
   if (old_val == 1 && OBJECT_HAS_TOGGLE_REF (object))
     toggle_refs_notify (object, FALSE);
 
   TRACE (GOBJECT_OBJECT_REF(object,G_TYPE_FROM_INSTANCE(object),old_val));
@@ -3239,28 +3275,27 @@
 {
   GObject *object = _object;
   gint old_ref;
 
   g_return_if_fail (G_IS_OBJECT (object));
-  g_return_if_fail (object->ref_count > 0);
 
   /* here we want to atomically do: if (ref_count>1) { ref_count--; return; } */
  retry_atomic_decrement1:
   old_ref = g_atomic_int_get (&object->ref_count);
   if (old_ref > 1)
     {
       /* valid if last 2 refs are owned by this call to unref and the toggle_ref */
       gboolean has_toggle_ref = OBJECT_HAS_TOGGLE_REF (object);
 
       if (!g_atomic_int_compare_and_exchange ((int *)&object->ref_count, old_ref, old_ref - 1))
-    goto retry_atomic_decrement1;
+  goto retry_atomic_decrement1;
 
       TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));
 
       /* if we went from 2->1 we need to notify toggle refs if any */
       if (old_ref == 2 && has_toggle_ref) /* The last ref being held in this case is owned by the toggle_ref */
-    toggle_refs_notify (object, TRUE);
+  toggle_refs_notify (object, TRUE);
     }
   else
     {
       GSList **weak_locations;
 
@@ -3316,48 +3351,55 @@
         {
           /* valid if last 2 refs are owned by this call to unref and the toggle_ref */
           gboolean has_toggle_ref = OBJECT_HAS_TOGGLE_REF (object);
 
           if (!g_atomic_int_compare_and_exchange ((int *)&object->ref_count, old_ref, old_ref - 1))
-        goto retry_atomic_decrement2;
+      goto retry_atomic_decrement2;
 
-      TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));
+    TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));
 
           /* if we went from 2->1 we need to notify toggle refs if any */
           if (old_ref == 2 && has_toggle_ref) /* The last ref being held in this case is owned by the toggle_ref */
-        toggle_refs_notify (object, TRUE);
+      toggle_refs_notify (object, TRUE);
 
-      return;
-    }
+    return;
+  }
 
       /* we are still in the process of taking away the last ref */
       g_datalist_id_set_data (&object->qdata, quark_closure_array, NULL);
       g_signal_handlers_destroy (object);
       g_datalist_id_set_data (&object->qdata, quark_weak_refs, NULL);
 
       /* decrement the last reference */
       old_ref = g_atomic_int_add (&object->ref_count, -1);
+      g_return_if_fail (old_ref > 0);
 
       TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));
 
       /* may have been re-referenced meanwhile */
       if (G_LIKELY (old_ref == 1))
-    {
-      TRACE (GOBJECT_OBJECT_FINALIZE(object,G_TYPE_FROM_INSTANCE(object)));
+  {
+    TRACE (GOBJECT_OBJECT_FINALIZE(object,G_TYPE_FROM_INSTANCE(object)));
           G_OBJECT_GET_CLASS (object)->finalize (object);
 
-      TRACE (GOBJECT_OBJECT_FINALIZE_END(object,G_TYPE_FROM_INSTANCE(object)));
+    TRACE (GOBJECT_OBJECT_FINALIZE_END(object,G_TYPE_FROM_INSTANCE(object)));
 
           GOBJECT_IF_DEBUG (OBJECTS,
-        {
-          /* catch objects not chaining finalize handlers */
-          G_LOCK (debug_objects);
-          g_assert (!g_hash_table_contains (debug_objects_ht, object));
-          G_UNLOCK (debug_objects);
-        });
+      {
+              gboolean was_present;
+
+              /* catch objects not chaining finalize handlers */
+              G_LOCK (debug_objects);
+              was_present = g_hash_table_remove (debug_objects_ht, object);
+              G_UNLOCK (debug_objects);
+
+              if (was_present)
+                g_critical ("Object %p of type %s not finalized correctly.",
+                            object, G_OBJECT_TYPE_NAME (object));
+      });
           g_type_free_instance ((GTypeInstance*) object);
-    }
+  }
     }
 }
 
 /**
  * g_clear_object: (skip)
@@ -3393,11 +3435,11 @@
  *
  * Returns: (transfer none) (nullable): The user data pointer set, or %NULL
  */
 gpointer
 g_object_get_qdata (GObject *object,
-            GQuark   quark)
+        GQuark   quark)
 {
   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
 
   return quark ? g_datalist_id_get_data (&object->qdata, quark) : NULL;
 }
@@ -3417,12 +3459,12 @@
  * the old pointer set, using #NULL as pointer essentially
  * removes the data stored.
  */
 void
 g_object_set_qdata (GObject *object,
-            GQuark   quark,
-            gpointer data)
+        GQuark   quark,
+        gpointer data)
 {
   g_return_if_fail (G_IS_OBJECT (object));
   g_return_if_fail (quark > 0);
 
   g_datalist_id_set_data (&object->qdata, quark, data);
@@ -3527,19 +3569,19 @@
  * the data is being overwritten by a call to g_object_set_qdata()
  * with the same @quark.
  */
 void
 g_object_set_qdata_full (GObject       *object,
-             GQuark     quark,
-             gpointer   data,
-                         GDestroyNotify destroy)
+       GQuark   quark,
+       gpointer data,
+       GDestroyNotify destroy)
 {
   g_return_if_fail (G_IS_OBJECT (object));
   g_return_if_fail (quark > 0);
 
   g_datalist_id_set_data_full (&object->qdata, quark, data,
-                   data ? destroy : (GDestroyNotify) NULL);
+             data ? destroy : (GDestroyNotify) NULL);
 }
 
 /**
  * g_object_steal_qdata:
  * @object: The GObject to get a stored user data pointer from
@@ -3583,11 +3625,11 @@
  *
  * Returns: (transfer full) (nullable): The user data pointer set, or %NULL
  */
 gpointer
 g_object_steal_qdata (GObject *object,
-              GQuark   quark)
+          GQuark   quark)
 {
   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
   g_return_val_if_fail (quark > 0, NULL);
 
   return g_datalist_id_remove_no_notify (&object->qdata, quark);
@@ -3622,10 +3664,15 @@
  * Each object carries around a table of associations from
  * strings to pointers.  This function lets you set an association.
  *
  * If the object already had an association with that name,
  * the old association will be destroyed.
+ *
+ * Internally, the @key is converted to a #GQuark using g_quark_from_string().
+ * This means a copy of @key is kept permanently (even after @object has been
+ * finalized) - so it is recommended to only use a small, bounded set of values
+ * for @key in your program, to avoid the #GQuark storage growing unbounded.
  */
 void
 g_object_set_data (GObject     *object,
                    const gchar *key,
                    gpointer     data)
@@ -3700,10 +3747,13 @@
  * the registered destroy notify for it (passed out in @old_destroy).
  * It's up to the caller to free this as needed, which may
  * or may not include using @old_destroy as sometimes replacement
  * should not destroy the object in the normal way.
  *
+ * See g_object_set_data() for guidance on using a small, bounded set of values
+ * for @key.
+ *
  * Returns: %TRUE if the existing value for @key was replaced
  *  by @newval, %FALSE otherwise.
  *
  * Since: 2.34
  */
@@ -3745,11 +3795,11 @@
 {
   g_return_if_fail (G_IS_OBJECT (object));
   g_return_if_fail (key != NULL);
 
   g_datalist_id_set_data_full (&object->qdata, g_quark_from_string (key), data,
-                   data ? destroy : (GDestroyNotify) NULL);
+             data ? destroy : (GDestroyNotify) NULL);
 }
 
 /**
  * g_object_steal_data:
  * @object: #GObject containing the associations
@@ -3788,21 +3838,21 @@
     g_object_unref (value->data[0].v_pointer);
 }
 
 static void
 g_value_object_copy_value (const GValue *src_value,
-               GValue   *dest_value)
+         GValue *dest_value)
 {
   if (src_value->data[0].v_pointer)
     dest_value->data[0].v_pointer = g_object_ref (src_value->data[0].v_pointer);
   else
     dest_value->data[0].v_pointer = NULL;
 }
 
 static void
 g_value_object_transform_value (const GValue *src_value,
-                GValue       *dest_value)
+        GValue       *dest_value)
 {
   if (src_value->data[0].v_pointer && g_type_is_a (G_OBJECT_TYPE (src_value->data[0].v_pointer), G_VALUE_TYPE (dest_value)))
     dest_value->data[0].v_pointer = g_object_ref (src_value->data[0].v_pointer);
   else
     dest_value->data[0].v_pointer = NULL;
@@ -3813,31 +3863,31 @@
 {
   return value->data[0].v_pointer;
 }
 
 static gchar*
-g_value_object_collect_value (GValue      *value,
-                              guint        n_collect_values,
-                              GTypeCValue *collect_values,
-                              guint        collect_flags)
+g_value_object_collect_value (GValue    *value,
+            guint        n_collect_values,
+            GTypeCValue *collect_values,
+            guint        collect_flags)
 {
   if (collect_values[0].v_pointer)
     {
       GObject *object = collect_values[0].v_pointer;
 
       if (object->g_type_instance.g_class == NULL)
-    return g_strconcat ("invalid unclassed object pointer for value type '",
-                G_VALUE_TYPE_NAME (value),
-                "'",
-                NULL);
+  return g_strconcat ("invalid unclassed object pointer for value type '",
+          G_VALUE_TYPE_NAME (value),
+          "'",
+          NULL);
       else if (!g_value_type_compatible (G_OBJECT_TYPE (object), G_VALUE_TYPE (value)))
-    return g_strconcat ("invalid object type '",
-                G_OBJECT_TYPE_NAME (object),
-                "' for value type '",
-                G_VALUE_TYPE_NAME (value),
-                "'",
-                NULL);
+  return g_strconcat ("invalid object type '",
+          G_OBJECT_TYPE_NAME (object),
+          "' for value type '",
+          G_VALUE_TYPE_NAME (value),
+          "'",
+          NULL);
       /* never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types */
       value->data[0].v_pointer = g_object_ref (object);
     }
   else
     value->data[0].v_pointer = NULL;
@@ -3845,13 +3895,13 @@
   return NULL;
 }
 
 static gchar*
 g_value_object_lcopy_value (const GValue *value,
-                guint        n_collect_values,
-                GTypeCValue *collect_values,
-                guint        collect_flags)
+          guint        n_collect_values,
+          GTypeCValue *collect_values,
+          guint        collect_flags)
 {
   GObject **object_p = collect_values[0].v_pointer;
 
   if (!object_p)
     return g_strdup_printf ("value location for '%s' passed as NULL", G_VALUE_TYPE_NAME (value));
@@ -3883,11 +3933,11 @@
  * own, or one it has taken) to ensure that the object won't be destroyed while
  * the #GValue still exists).
  */
 void
 g_value_set_object (GValue   *value,
-            gpointer  v_object)
+        gpointer  v_object)
 {
   GObject *old;
 
   g_return_if_fail (G_VALUE_HOLDS_OBJECT (value));
 
@@ -3917,33 +3967,33 @@
  *
  * Deprecated: 2.4: Use g_value_take_object() instead.
  */
 void
 g_value_set_object_take_ownership (GValue  *value,
-                   gpointer v_object)
+           gpointer v_object)
 {
   g_value_take_object (value, v_object);
 }
 
 /**
  * g_value_take_object: (skip)
  * @value: a valid #GValue of %G_TYPE_OBJECT derived type
  * @v_object: (nullable): object value to be set
  *
  * Sets the contents of a %G_TYPE_OBJECT derived #GValue to @v_object
- * and takes over the ownership of the callers reference to @v_object;
+ * and takes over the ownership of the caller's reference to @v_object;
  * the caller doesn't have to unref it any more (i.e. the reference
  * count of the object is not increased).
  *
  * If you want the #GValue to hold its own reference to @v_object, use
  * g_value_set_object() instead.
  *
  * Since: 2.4
  */
 void
 g_value_take_object (GValue  *value,
-             gpointer v_object)
+         gpointer v_object)
 {
   g_return_if_fail (G_VALUE_HOLDS_OBJECT (value));
 
   if (value->data[0].v_pointer)
     {
@@ -4015,14 +4065,14 @@
  *
  * Returns: the handler id.
  */
 gulong
 g_signal_connect_object (gpointer      instance,
-             const gchar  *detailed_signal,
-             GCallback     c_handler,
-             gpointer      gobject,
-             GConnectFlags connect_flags)
+       const gchar  *detailed_signal,
+       GCallback     c_handler,
+       gpointer      gobject,
+       GConnectFlags connect_flags)
 {
   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
   g_return_val_if_fail (detailed_signal != NULL, 0);
   g_return_val_if_fail (c_handler != NULL, 0);
 
@@ -4064,26 +4114,26 @@
  * }
  */
 
 static void
 object_remove_closure (gpointer  data,
-               GClosure *closure)
+           GClosure *closure)
 {
   GObject *object = data;
   CArray *carray;
   guint i;
 
   G_LOCK (closure_array_mutex);
   carray = g_object_get_qdata (object, quark_closure_array);
   for (i = 0; i < carray->n_closures; i++)
     if (carray->closures[i] == closure)
       {
-    carray->n_closures--;
-    if (i < carray->n_closures)
-      carray->closures[i] = carray->closures[carray->n_closures];
-    G_UNLOCK (closure_array_mutex);
-    return;
+  carray->n_closures--;
+  if (i < carray->n_closures)
+    carray->closures[i] = carray->closures[carray->n_closures];
+  G_UNLOCK (closure_array_mutex);
+  return;
       }
   G_UNLOCK (closure_array_mutex);
   g_assert_not_reached ();
 }
 
@@ -4107,12 +4157,12 @@
   g_free (carray);
 }
 
 /**
  * g_object_watch_closure:
- * @object: GObject restricting lifetime of @closure
- * @closure: GClosure to watch
+ * @object: #GObject restricting lifetime of @closure
+ * @closure: #GClosure to watch
  *
  * This function essentially limits the life time of the @closure to
  * the life time of the object. That is, when the object is finalized,
  * the @closure is invalidated by calling g_closure_invalidate() on
  * it, in order to prevent invocations of the closure with a finalized
@@ -4122,25 +4172,25 @@
  * @closure.  Usually, this function will be called on closures that
  * use this @object as closure data.
  */
 void
 g_object_watch_closure (GObject  *object,
-            GClosure *closure)
+      GClosure *closure)
 {
   CArray *carray;
   guint i;
 
   g_return_if_fail (G_IS_OBJECT (object));
   g_return_if_fail (closure != NULL);
   g_return_if_fail (closure->is_invalid == FALSE);
   g_return_if_fail (closure->in_marshal == FALSE);
-  g_return_if_fail (object->ref_count > 0); /* this doesn't work on finalizing objects */
+  g_return_if_fail (g_atomic_int_get (&object->ref_count) > 0); /* this doesn't work on finalizing objects */
 
   g_closure_add_invalidate_notifier (closure, object, object_remove_closure);
   g_closure_add_marshal_guards (closure,
-                object, (GClosureNotify) g_object_ref,
-                object, (GClosureNotify) g_object_unref);
+        object, (GClosureNotify) g_object_ref,
+        object, (GClosureNotify) g_object_unref);
   G_LOCK (closure_array_mutex);
   carray = g_datalist_id_remove_no_notify (&object->qdata, quark_closure_array);
   if (!carray)
     {
       carray = g_renew (CArray, NULL, 1);
@@ -4172,16 +4222,16 @@
  *
  * Returns: (transfer full): a newly allocated #GClosure
  */
 GClosure*
 g_closure_new_object (guint    sizeof_closure,
-              GObject *object)
+          GObject *object)
 {
   GClosure *closure;
 
   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
-  g_return_val_if_fail (object->ref_count > 0, NULL);     /* this doesn't work on finalizing objects */
+  g_return_val_if_fail (g_atomic_int_get (&object->ref_count) > 0, NULL);     /* this doesn't work on finalizing objects */
 
   closure = g_closure_new_simple (sizeof_closure, object);
   g_object_watch_closure (object, closure);
 
   return closure;
@@ -4200,16 +4250,16 @@
  *
  * Returns: a new #GCClosure
  */
 GClosure*
 g_cclosure_new_object (GCallback callback_func,
-               GObject  *object)
+           GObject  *object)
 {
   GClosure *closure;
 
   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
-  g_return_val_if_fail (object->ref_count > 0, NULL);     /* this doesn't work on finalizing objects */
+  g_return_val_if_fail (g_atomic_int_get (&object->ref_count) > 0, NULL);     /* this doesn't work on finalizing objects */
   g_return_val_if_fail (callback_func != NULL, NULL);
 
   closure = g_cclosure_new (callback_func, object, NULL);
   g_object_watch_closure (object, closure);
 
@@ -4229,16 +4279,16 @@
  *
  * Returns: a new #GCClosure
  */
 GClosure*
 g_cclosure_new_object_swap (GCallback callback_func,
-                GObject  *object)
+          GObject  *object)
 {
   GClosure *closure;
 
   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
-  g_return_val_if_fail (object->ref_count > 0, NULL);     /* this doesn't work on finalizing objects */
+  g_return_val_if_fail (g_atomic_int_get (&object->ref_count) > 0, NULL);     /* this doesn't work on finalizing objects */
   g_return_val_if_fail (callback_func != NULL, NULL);
 
   closure = g_cclosure_new_swap (callback_func, object, NULL);
   g_object_watch_closure (object, closure);
 
