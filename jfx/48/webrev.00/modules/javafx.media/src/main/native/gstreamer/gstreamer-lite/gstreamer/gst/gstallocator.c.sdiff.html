<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstallocator.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gst_private.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstallocator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstallocator.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 31  *
 32  * New allocators can be registered with gst_allocator_register().
 33  * Allocators are identified by name and can be retrieved with
 34  * gst_allocator_find(). gst_allocator_set_default() can be used to change the
 35  * default allocator.
 36  *
 37  * New memory can be created with gst_memory_new_wrapped() that wraps the memory
 38  * allocated elsewhere.
 39  */
 40 
 41 #ifdef HAVE_CONFIG_H
 42 #include &quot;config.h&quot;
 43 #endif
 44 
 45 #include &quot;gst_private.h&quot;
 46 #include &quot;gstmemory.h&quot;
 47 
 48 GST_DEBUG_CATEGORY_STATIC (gst_allocator_debug);
 49 #define GST_CAT_DEFAULT gst_allocator_debug
 50 
<span class="line-removed"> 51 #define GST_ALLOCATOR_GET_PRIVATE(obj)  \</span>
<span class="line-removed"> 52      (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_ALLOCATOR, GstAllocatorPrivate))</span>
<span class="line-removed"> 53 </span>
 54 struct _GstAllocatorPrivate
 55 {
 56   gpointer dummy;
 57 };
 58 
 59 #ifdef GSTREAMER_LITE
 60 // In GStLite we require to have memory aligned to 16 bytes for RAW video.
 61 // For now lets have all memory 16 bytes aligned.
 62 gsize gst_memory_alignment = 15;
 63 #else // GSTREAMER_LITE
 64 #if defined(MEMORY_ALIGNMENT_MALLOC)
 65 gsize gst_memory_alignment = 7;
 66 #elif defined(MEMORY_ALIGNMENT_PAGESIZE)
 67 /* we fill this in in the _init method */
 68 gsize gst_memory_alignment = 0;
 69 #elif defined(MEMORY_ALIGNMENT)
 70 gsize gst_memory_alignment = MEMORY_ALIGNMENT - 1;
 71 #else
 72 #error &quot;No memory alignment configured&quot;
 73 gsize gst_memory_alignment = 0;
 74 #endif
 75 #endif // GSTREAMER_LITE
 76 
 77 /* the default allocator */
 78 static GstAllocator *_default_allocator;
 79 
 80 static GstAllocator *_sysmem_allocator;
 81 
 82 /* registered allocators */
 83 static GRWLock lock;
 84 static GHashTable *allocators;
 85 
<span class="line-modified"> 86 G_DEFINE_ABSTRACT_TYPE (GstAllocator, gst_allocator, GST_TYPE_OBJECT);</span>

 87 
 88 static void
 89 gst_allocator_class_init (GstAllocatorClass * klass)
 90 {
<span class="line-removed"> 91   g_type_class_add_private (klass, sizeof (GstAllocatorPrivate));</span>
<span class="line-removed"> 92 </span>
 93   GST_DEBUG_CATEGORY_INIT (gst_allocator_debug, &quot;allocator&quot;, 0,
 94       &quot;allocator debug&quot;);
 95 }
 96 
 97 static GstMemory *
 98 _fallback_mem_copy (GstMemory * mem, gssize offset, gssize size)
 99 {
100   GstMemory *copy;
101   GstMapInfo sinfo, dinfo;
102   GstAllocationParams params = { 0, mem-&gt;align, 0, 0, };
103   GstAllocator *allocator;
104 
105   if (!gst_memory_map (mem, &amp;sinfo, GST_MAP_READ))
106     return NULL;
107 
108   if (size == -1)
109     size = sinfo.size &gt; offset ? sinfo.size - offset : 0;
110 
111   /* use the same allocator as the memory we copy  */
112   allocator = mem-&gt;allocator;
</pre>
<hr />
<pre>
122   }
123 
124   GST_CAT_DEBUG (GST_CAT_PERFORMANCE,
125       &quot;memcpy %&quot; G_GSSIZE_FORMAT &quot; memory %p -&gt; %p&quot;, size, mem, copy);
126   memcpy (dinfo.data, sinfo.data + offset, size);
127   gst_memory_unmap (copy, &amp;dinfo);
128   gst_memory_unmap (mem, &amp;sinfo);
129 
130   return copy;
131 }
132 
133 static gboolean
134 _fallback_mem_is_span (GstMemory * mem1, GstMemory * mem2, gsize * offset)
135 {
136   return FALSE;
137 }
138 
139 static void
140 gst_allocator_init (GstAllocator * allocator)
141 {
<span class="line-modified">142   allocator-&gt;priv = GST_ALLOCATOR_GET_PRIVATE (allocator);</span>
143 
144   allocator-&gt;mem_copy = _fallback_mem_copy;
145   allocator-&gt;mem_is_span = _fallback_mem_is_span;
146 }
147 
148 G_DEFINE_BOXED_TYPE (GstAllocationParams, gst_allocation_params,
149     (GBoxedCopyFunc) gst_allocation_params_copy,
150     (GBoxedFreeFunc) gst_allocation_params_free);
151 
152 /**
153  * gst_allocation_params_init:
154  * @params: a #GstAllocationParams
155  *
156  * Initialize @params to its default values
157  */
158 void
159 gst_allocation_params_init (GstAllocationParams * params)
160 {
161   g_return_if_fail (params != NULL);
162 
</pre>
<hr />
<pre>
534   gsize slice_size;
535 
536   if (dmem-&gt;notify)
537     dmem-&gt;notify (dmem-&gt;user_data);
538 
539   slice_size = dmem-&gt;slice_size;
540 
541 #ifdef USE_POISONING
542   /* just poison the structs, not all the data */
543   memset (mem, 0xff, sizeof (GstMemorySystem));
544 #endif
545 
546   g_slice_free1 (slice_size, mem);
547 }
548 
549 static void
550 gst_allocator_sysmem_finalize (GObject * obj)
551 {
552   /* Don&#39;t raise warnings if we are shutting down */
553   if (_default_allocator)
<span class="line-modified">554   g_warning (&quot;The default memory allocator was freed!&quot;);</span>
555 
556   ((GObjectClass *) gst_allocator_sysmem_parent_class)-&gt;finalize (obj);
557 }
558 
559 static void
560 gst_allocator_sysmem_class_init (GstAllocatorSysmemClass * klass)
561 {
562   GObjectClass *gobject_class;
563   GstAllocatorClass *allocator_class;
564 
565   gobject_class = (GObjectClass *) klass;
566   allocator_class = (GstAllocatorClass *) klass;
567 
568   gobject_class-&gt;finalize = gst_allocator_sysmem_finalize;
569 
570   allocator_class-&gt;alloc = default_alloc;
571   allocator_class-&gt;free = default_free;
572 }
573 
574 static void
</pre>
</td>
<td>
<hr />
<pre>
 31  *
 32  * New allocators can be registered with gst_allocator_register().
 33  * Allocators are identified by name and can be retrieved with
 34  * gst_allocator_find(). gst_allocator_set_default() can be used to change the
 35  * default allocator.
 36  *
 37  * New memory can be created with gst_memory_new_wrapped() that wraps the memory
 38  * allocated elsewhere.
 39  */
 40 
 41 #ifdef HAVE_CONFIG_H
 42 #include &quot;config.h&quot;
 43 #endif
 44 
 45 #include &quot;gst_private.h&quot;
 46 #include &quot;gstmemory.h&quot;
 47 
 48 GST_DEBUG_CATEGORY_STATIC (gst_allocator_debug);
 49 #define GST_CAT_DEFAULT gst_allocator_debug
 50 



 51 struct _GstAllocatorPrivate
 52 {
 53   gpointer dummy;
 54 };
 55 
 56 #ifdef GSTREAMER_LITE
 57 // In GStLite we require to have memory aligned to 16 bytes for RAW video.
 58 // For now lets have all memory 16 bytes aligned.
 59 gsize gst_memory_alignment = 15;
 60 #else // GSTREAMER_LITE
 61 #if defined(MEMORY_ALIGNMENT_MALLOC)
 62 gsize gst_memory_alignment = 7;
 63 #elif defined(MEMORY_ALIGNMENT_PAGESIZE)
 64 /* we fill this in in the _init method */
 65 gsize gst_memory_alignment = 0;
 66 #elif defined(MEMORY_ALIGNMENT)
 67 gsize gst_memory_alignment = MEMORY_ALIGNMENT - 1;
 68 #else
 69 #error &quot;No memory alignment configured&quot;
 70 gsize gst_memory_alignment = 0;
 71 #endif
 72 #endif // GSTREAMER_LITE
 73 
 74 /* the default allocator */
 75 static GstAllocator *_default_allocator;
 76 
 77 static GstAllocator *_sysmem_allocator;
 78 
 79 /* registered allocators */
 80 static GRWLock lock;
 81 static GHashTable *allocators;
 82 
<span class="line-modified"> 83 G_DEFINE_ABSTRACT_TYPE_WITH_PRIVATE (GstAllocator, gst_allocator,</span>
<span class="line-added"> 84     GST_TYPE_OBJECT);</span>
 85 
 86 static void
 87 gst_allocator_class_init (GstAllocatorClass * klass)
 88 {


 89   GST_DEBUG_CATEGORY_INIT (gst_allocator_debug, &quot;allocator&quot;, 0,
 90       &quot;allocator debug&quot;);
 91 }
 92 
 93 static GstMemory *
 94 _fallback_mem_copy (GstMemory * mem, gssize offset, gssize size)
 95 {
 96   GstMemory *copy;
 97   GstMapInfo sinfo, dinfo;
 98   GstAllocationParams params = { 0, mem-&gt;align, 0, 0, };
 99   GstAllocator *allocator;
100 
101   if (!gst_memory_map (mem, &amp;sinfo, GST_MAP_READ))
102     return NULL;
103 
104   if (size == -1)
105     size = sinfo.size &gt; offset ? sinfo.size - offset : 0;
106 
107   /* use the same allocator as the memory we copy  */
108   allocator = mem-&gt;allocator;
</pre>
<hr />
<pre>
118   }
119 
120   GST_CAT_DEBUG (GST_CAT_PERFORMANCE,
121       &quot;memcpy %&quot; G_GSSIZE_FORMAT &quot; memory %p -&gt; %p&quot;, size, mem, copy);
122   memcpy (dinfo.data, sinfo.data + offset, size);
123   gst_memory_unmap (copy, &amp;dinfo);
124   gst_memory_unmap (mem, &amp;sinfo);
125 
126   return copy;
127 }
128 
129 static gboolean
130 _fallback_mem_is_span (GstMemory * mem1, GstMemory * mem2, gsize * offset)
131 {
132   return FALSE;
133 }
134 
135 static void
136 gst_allocator_init (GstAllocator * allocator)
137 {
<span class="line-modified">138   allocator-&gt;priv = gst_allocator_get_instance_private (allocator);</span>
139 
140   allocator-&gt;mem_copy = _fallback_mem_copy;
141   allocator-&gt;mem_is_span = _fallback_mem_is_span;
142 }
143 
144 G_DEFINE_BOXED_TYPE (GstAllocationParams, gst_allocation_params,
145     (GBoxedCopyFunc) gst_allocation_params_copy,
146     (GBoxedFreeFunc) gst_allocation_params_free);
147 
148 /**
149  * gst_allocation_params_init:
150  * @params: a #GstAllocationParams
151  *
152  * Initialize @params to its default values
153  */
154 void
155 gst_allocation_params_init (GstAllocationParams * params)
156 {
157   g_return_if_fail (params != NULL);
158 
</pre>
<hr />
<pre>
530   gsize slice_size;
531 
532   if (dmem-&gt;notify)
533     dmem-&gt;notify (dmem-&gt;user_data);
534 
535   slice_size = dmem-&gt;slice_size;
536 
537 #ifdef USE_POISONING
538   /* just poison the structs, not all the data */
539   memset (mem, 0xff, sizeof (GstMemorySystem));
540 #endif
541 
542   g_slice_free1 (slice_size, mem);
543 }
544 
545 static void
546 gst_allocator_sysmem_finalize (GObject * obj)
547 {
548   /* Don&#39;t raise warnings if we are shutting down */
549   if (_default_allocator)
<span class="line-modified">550     g_warning (&quot;The default memory allocator was freed!&quot;);</span>
551 
552   ((GObjectClass *) gst_allocator_sysmem_parent_class)-&gt;finalize (obj);
553 }
554 
555 static void
556 gst_allocator_sysmem_class_init (GstAllocatorSysmemClass * klass)
557 {
558   GObjectClass *gobject_class;
559   GstAllocatorClass *allocator_class;
560 
561   gobject_class = (GObjectClass *) klass;
562   allocator_class = (GstAllocatorClass *) klass;
563 
564   gobject_class-&gt;finalize = gst_allocator_sysmem_finalize;
565 
566   allocator_class-&gt;alloc = default_alloc;
567   allocator_class-&gt;free = default_free;
568 }
569 
570 static void
</pre>
</td>
</tr>
</table>
<center><a href="gst_private.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstallocator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>