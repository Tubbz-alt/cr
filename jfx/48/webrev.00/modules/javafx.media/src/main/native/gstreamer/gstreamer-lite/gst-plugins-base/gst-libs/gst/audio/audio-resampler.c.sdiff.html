<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/audio-resampler.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="audio-quantize.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="audio.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/audio-resampler.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 894     } else {                                                            \
 895       type *ip = (type *) in[0] + c;                                    \
 896       for (i = 0; i &lt; in_frames; i++, ip += channels)                   \
 897         s[i] = *ip;                                                     \
 898     }                                                                   \
 899   }                                                                     \
 900 }
 901 
 902 MAKE_DEINTERLEAVE_FUNC (gint16);
 903 MAKE_DEINTERLEAVE_FUNC (gint32);
 904 MAKE_DEINTERLEAVE_FUNC (gfloat);
 905 MAKE_DEINTERLEAVE_FUNC (gdouble);
 906 
 907 static DeinterleaveFunc deinterleave_funcs[] = {
 908   deinterleave_gint16,
 909   deinterleave_gint32,
 910   deinterleave_gfloat,
 911   deinterleave_gdouble
 912 };
 913 
















 914 static void
 915 calculate_kaiser_params (GstAudioResampler * resampler)
 916 {
 917   gdouble A, B, dw, tr_bw, Fc;
 918   gint n;
 919   const KaiserQualityMap *q = &amp;kaiser_qualities[DEFAULT_QUALITY];
 920 
 921   /* default cutoff */
 922   Fc = q-&gt;cutoff;
 923   if (resampler-&gt;out_rate &lt; resampler-&gt;in_rate)
 924     Fc *= q-&gt;downsample_cutoff_factor;
 925 
 926   Fc = GET_OPT_CUTOFF (resampler-&gt;options, Fc);
 927   A = GET_OPT_STOP_ATTENUATION (resampler-&gt;options, q-&gt;stopband_attenuation);
 928   tr_bw =
 929       GET_OPT_TRANSITION_BANDWIDTH (resampler-&gt;options,
 930       q-&gt;transition_bandwidth);
 931 
 932   GST_LOG (&quot;Fc %f, A %f, tr_bw %f&quot;, Fc, A, tr_bw);
 933 
</pre>
<hr />
<pre>
1301         cutoff *= map-&gt;downsample_cutoff_factor;
1302 
1303       gst_structure_set (options,
1304           GST_AUDIO_RESAMPLER_OPT_CUTOFF, G_TYPE_DOUBLE, cutoff,
1305           GST_AUDIO_RESAMPLER_OPT_STOP_ATTENUATION, G_TYPE_DOUBLE,
1306           map-&gt;stopband_attenuation,
1307           GST_AUDIO_RESAMPLER_OPT_TRANSITION_BANDWIDTH, G_TYPE_DOUBLE,
1308           map-&gt;transition_bandwidth, NULL);
1309       break;
1310     }
1311   }
1312   gst_structure_set (options,
1313       GST_AUDIO_RESAMPLER_OPT_FILTER_OVERSAMPLE, G_TYPE_INT,
1314       oversample_qualities[quality], NULL);
1315 }
1316 
1317 /**
1318  * gst_audio_resampler_new:
1319  * @method: a #GstAudioResamplerMethod
1320  * @flags: #GstAudioResamplerFlags


1321  * @in_rate: input rate
1322  * @out_rate: output rate
1323  * @options: extra options
1324  *
1325  * Make a new resampler.
1326  *
<span class="line-modified">1327  * Returns: (skip) (transfer full): %TRUE on success</span>

1328  */
1329 GstAudioResampler *
1330 gst_audio_resampler_new (GstAudioResamplerMethod method,
1331     GstAudioResamplerFlags flags,
1332     GstAudioFormat format, gint channels,
1333     gint in_rate, gint out_rate, GstStructure * options)
1334 {
<span class="line-modified">1335   gboolean non_interleaved;</span>
1336   GstAudioResampler *resampler;
1337   const GstAudioFormatInfo *info;
1338   GstStructure *def_options = NULL;
1339 
1340   g_return_val_if_fail (method &gt;= GST_AUDIO_RESAMPLER_METHOD_NEAREST
1341       &amp;&amp; method &lt;= GST_AUDIO_RESAMPLER_METHOD_KAISER, NULL);
1342   g_return_val_if_fail (format == GST_AUDIO_FORMAT_S16 ||
1343       format == GST_AUDIO_FORMAT_S32 || format == GST_AUDIO_FORMAT_F32 ||
1344       format == GST_AUDIO_FORMAT_F64, NULL);
1345   g_return_val_if_fail (channels &gt; 0, NULL);
1346   g_return_val_if_fail (in_rate &gt; 0, NULL);
1347   g_return_val_if_fail (out_rate &gt; 0, NULL);
1348 
1349   audio_resampler_init ();
1350 
1351   resampler = g_slice_new0 (GstAudioResampler);
1352   resampler-&gt;method = method;
1353   resampler-&gt;flags = flags;
1354   resampler-&gt;format = format;
1355   resampler-&gt;channels = channels;
</pre>
<hr />
<pre>
1359       resampler-&gt;format_index = 0;
1360       break;
1361     case GST_AUDIO_FORMAT_S32:
1362       resampler-&gt;format_index = 1;
1363       break;
1364     case GST_AUDIO_FORMAT_F32:
1365       resampler-&gt;format_index = 2;
1366       break;
1367     case GST_AUDIO_FORMAT_F64:
1368       resampler-&gt;format_index = 3;
1369       break;
1370     default:
1371       g_assert_not_reached ();
1372       break;
1373   }
1374 
1375   info = gst_audio_format_get_info (format);
1376   resampler-&gt;bps = GST_AUDIO_FORMAT_INFO_WIDTH (info) / 8;
1377   resampler-&gt;sbuf = g_malloc0 (sizeof (gpointer) * channels);
1378 
<span class="line-modified">1379   non_interleaved =</span>


1380       (resampler-&gt;flags &amp; GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_OUT);
1381 
1382   /* we resample each channel separately */
1383   resampler-&gt;blocks = resampler-&gt;channels;
1384   resampler-&gt;inc = 1;
<span class="line-modified">1385   resampler-&gt;ostride = non_interleaved ? 1 : resampler-&gt;channels;</span>
<span class="line-modified">1386   resampler-&gt;deinterleave = deinterleave_funcs[resampler-&gt;format_index];</span>

1387   resampler-&gt;convert_taps = convert_taps_funcs[resampler-&gt;format_index];
1388 
1389   GST_DEBUG (&quot;method %d, bps %d, channels %d&quot;, method, resampler-&gt;bps,
1390       resampler-&gt;channels);
1391 
1392   if (options == NULL) {
1393     options = def_options =
1394         gst_structure_new_empty (&quot;GstAudioResampler.options&quot;);
1395     gst_audio_resampler_options_set_quality (DEFAULT_RESAMPLER_METHOD,
1396         GST_AUDIO_RESAMPLER_QUALITY_DEFAULT, in_rate, out_rate, options);
1397   }
1398 
1399   gst_audio_resampler_update (resampler, in_rate, out_rate, options);
1400   gst_audio_resampler_reset (resampler);
1401 
1402   if (def_options)
1403     gst_structure_free (def_options);
1404 
1405   return resampler;
1406 }
</pre>
</td>
<td>
<hr />
<pre>
 894     } else {                                                            \
 895       type *ip = (type *) in[0] + c;                                    \
 896       for (i = 0; i &lt; in_frames; i++, ip += channels)                   \
 897         s[i] = *ip;                                                     \
 898     }                                                                   \
 899   }                                                                     \
 900 }
 901 
 902 MAKE_DEINTERLEAVE_FUNC (gint16);
 903 MAKE_DEINTERLEAVE_FUNC (gint32);
 904 MAKE_DEINTERLEAVE_FUNC (gfloat);
 905 MAKE_DEINTERLEAVE_FUNC (gdouble);
 906 
 907 static DeinterleaveFunc deinterleave_funcs[] = {
 908   deinterleave_gint16,
 909   deinterleave_gint32,
 910   deinterleave_gfloat,
 911   deinterleave_gdouble
 912 };
 913 
<span class="line-added"> 914 static void</span>
<span class="line-added"> 915 copy_func (GstAudioResampler * resampler, gpointer sbuf[],</span>
<span class="line-added"> 916     gpointer in[], gsize in_frames)</span>
<span class="line-added"> 917 {</span>
<span class="line-added"> 918   gint c, channels = resampler-&gt;channels;</span>
<span class="line-added"> 919   gsize samples_avail = resampler-&gt;samples_avail;</span>
<span class="line-added"> 920   for (c = 0; c &lt; channels; c++) {</span>
<span class="line-added"> 921     guint8 *s = ((guint8 *) sbuf[c]) + (samples_avail * resampler-&gt;bps);</span>
<span class="line-added"> 922     if (G_UNLIKELY (in == NULL)) {</span>
<span class="line-added"> 923       memset (s, 0, in_frames * resampler-&gt;bps);</span>
<span class="line-added"> 924     } else {</span>
<span class="line-added"> 925       memcpy (s, in[c], in_frames * resampler-&gt;bps);</span>
<span class="line-added"> 926     }</span>
<span class="line-added"> 927   }</span>
<span class="line-added"> 928 }</span>
<span class="line-added"> 929 </span>
 930 static void
 931 calculate_kaiser_params (GstAudioResampler * resampler)
 932 {
 933   gdouble A, B, dw, tr_bw, Fc;
 934   gint n;
 935   const KaiserQualityMap *q = &amp;kaiser_qualities[DEFAULT_QUALITY];
 936 
 937   /* default cutoff */
 938   Fc = q-&gt;cutoff;
 939   if (resampler-&gt;out_rate &lt; resampler-&gt;in_rate)
 940     Fc *= q-&gt;downsample_cutoff_factor;
 941 
 942   Fc = GET_OPT_CUTOFF (resampler-&gt;options, Fc);
 943   A = GET_OPT_STOP_ATTENUATION (resampler-&gt;options, q-&gt;stopband_attenuation);
 944   tr_bw =
 945       GET_OPT_TRANSITION_BANDWIDTH (resampler-&gt;options,
 946       q-&gt;transition_bandwidth);
 947 
 948   GST_LOG (&quot;Fc %f, A %f, tr_bw %f&quot;, Fc, A, tr_bw);
 949 
</pre>
<hr />
<pre>
1317         cutoff *= map-&gt;downsample_cutoff_factor;
1318 
1319       gst_structure_set (options,
1320           GST_AUDIO_RESAMPLER_OPT_CUTOFF, G_TYPE_DOUBLE, cutoff,
1321           GST_AUDIO_RESAMPLER_OPT_STOP_ATTENUATION, G_TYPE_DOUBLE,
1322           map-&gt;stopband_attenuation,
1323           GST_AUDIO_RESAMPLER_OPT_TRANSITION_BANDWIDTH, G_TYPE_DOUBLE,
1324           map-&gt;transition_bandwidth, NULL);
1325       break;
1326     }
1327   }
1328   gst_structure_set (options,
1329       GST_AUDIO_RESAMPLER_OPT_FILTER_OVERSAMPLE, G_TYPE_INT,
1330       oversample_qualities[quality], NULL);
1331 }
1332 
1333 /**
1334  * gst_audio_resampler_new:
1335  * @method: a #GstAudioResamplerMethod
1336  * @flags: #GstAudioResamplerFlags
<span class="line-added">1337  * @format: the #GstAudioFormat</span>
<span class="line-added">1338  * @channels: the number of channels</span>
1339  * @in_rate: input rate
1340  * @out_rate: output rate
1341  * @options: extra options
1342  *
1343  * Make a new resampler.
1344  *
<span class="line-modified">1345  * Returns: (skip) (transfer full): The new #GstAudioResampler, or</span>
<span class="line-added">1346  * %NULL on failure.</span>
1347  */
1348 GstAudioResampler *
1349 gst_audio_resampler_new (GstAudioResamplerMethod method,
1350     GstAudioResamplerFlags flags,
1351     GstAudioFormat format, gint channels,
1352     gint in_rate, gint out_rate, GstStructure * options)
1353 {
<span class="line-modified">1354   gboolean non_interleaved_in, non_interleaved_out;</span>
1355   GstAudioResampler *resampler;
1356   const GstAudioFormatInfo *info;
1357   GstStructure *def_options = NULL;
1358 
1359   g_return_val_if_fail (method &gt;= GST_AUDIO_RESAMPLER_METHOD_NEAREST
1360       &amp;&amp; method &lt;= GST_AUDIO_RESAMPLER_METHOD_KAISER, NULL);
1361   g_return_val_if_fail (format == GST_AUDIO_FORMAT_S16 ||
1362       format == GST_AUDIO_FORMAT_S32 || format == GST_AUDIO_FORMAT_F32 ||
1363       format == GST_AUDIO_FORMAT_F64, NULL);
1364   g_return_val_if_fail (channels &gt; 0, NULL);
1365   g_return_val_if_fail (in_rate &gt; 0, NULL);
1366   g_return_val_if_fail (out_rate &gt; 0, NULL);
1367 
1368   audio_resampler_init ();
1369 
1370   resampler = g_slice_new0 (GstAudioResampler);
1371   resampler-&gt;method = method;
1372   resampler-&gt;flags = flags;
1373   resampler-&gt;format = format;
1374   resampler-&gt;channels = channels;
</pre>
<hr />
<pre>
1378       resampler-&gt;format_index = 0;
1379       break;
1380     case GST_AUDIO_FORMAT_S32:
1381       resampler-&gt;format_index = 1;
1382       break;
1383     case GST_AUDIO_FORMAT_F32:
1384       resampler-&gt;format_index = 2;
1385       break;
1386     case GST_AUDIO_FORMAT_F64:
1387       resampler-&gt;format_index = 3;
1388       break;
1389     default:
1390       g_assert_not_reached ();
1391       break;
1392   }
1393 
1394   info = gst_audio_format_get_info (format);
1395   resampler-&gt;bps = GST_AUDIO_FORMAT_INFO_WIDTH (info) / 8;
1396   resampler-&gt;sbuf = g_malloc0 (sizeof (gpointer) * channels);
1397 
<span class="line-modified">1398   non_interleaved_in =</span>
<span class="line-added">1399       (resampler-&gt;flags &amp; GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_IN);</span>
<span class="line-added">1400   non_interleaved_out =</span>
1401       (resampler-&gt;flags &amp; GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_OUT);
1402 
1403   /* we resample each channel separately */
1404   resampler-&gt;blocks = resampler-&gt;channels;
1405   resampler-&gt;inc = 1;
<span class="line-modified">1406   resampler-&gt;ostride = non_interleaved_out ? 1 : resampler-&gt;channels;</span>
<span class="line-modified">1407   resampler-&gt;deinterleave = non_interleaved_in ?</span>
<span class="line-added">1408       copy_func : deinterleave_funcs[resampler-&gt;format_index];</span>
1409   resampler-&gt;convert_taps = convert_taps_funcs[resampler-&gt;format_index];
1410 
1411   GST_DEBUG (&quot;method %d, bps %d, channels %d&quot;, method, resampler-&gt;bps,
1412       resampler-&gt;channels);
1413 
1414   if (options == NULL) {
1415     options = def_options =
1416         gst_structure_new_empty (&quot;GstAudioResampler.options&quot;);
1417     gst_audio_resampler_options_set_quality (DEFAULT_RESAMPLER_METHOD,
1418         GST_AUDIO_RESAMPLER_QUALITY_DEFAULT, in_rate, out_rate, options);
1419   }
1420 
1421   gst_audio_resampler_update (resampler, in_rate, out_rate, options);
1422   gst_audio_resampler_reset (resampler);
1423 
1424   if (def_options)
1425     gst_structure_free (def_options);
1426 
1427   return resampler;
1428 }
</pre>
</td>
</tr>
</table>
<center><a href="audio-quantize.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="audio.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>