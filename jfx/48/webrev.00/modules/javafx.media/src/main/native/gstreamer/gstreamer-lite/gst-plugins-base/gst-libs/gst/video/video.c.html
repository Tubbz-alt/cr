<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/video.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /* GStreamer
  2  * Copyright (C) &lt;1999&gt; Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
  3  * Library       &lt;2002&gt; Ronald Bultje &lt;rbultje@ronald.bitfreak.net&gt;
  4  * Copyright (C) 2007 David A. Schleef &lt;ds@schleef.org&gt;
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public
 17  * License along with this library; if not, write to the
 18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #ifdef HAVE_CONFIG_H
 23 #  include &quot;config.h&quot;
 24 #endif
 25 
 26 #include &lt;string.h&gt;
 27 #include &lt;stdio.h&gt;
 28 
 29 #include &quot;video.h&quot;
 30 #include &quot;gstvideometa.h&quot;
 31 
 32 #ifdef GSTREAMER_LITE
 33 #ifndef WIN32
 34 #undef GSTREAMER_LITE
 35 #endif // WIN32
 36 #endif // GSTREAMER_LITE
 37 
 38 #ifndef GSTREAMER_LITE
 39 /**
 40  * SECTION:gstvideo
 41  * @title: GstVideo
 42  * @short_description: Support library for video operations
 43  *
 44  * This library contains some helper functions and includes the
 45  * videosink and videofilter base classes.
 46  */
 47 
 48 /**
 49  * gst_video_calculate_display_ratio:
 50  * @dar_n: (out): Numerator of the calculated display_ratio
 51  * @dar_d: (out): Denominator of the calculated display_ratio
 52  * @video_width: Width of the video frame in pixels
 53  * @video_height: Height of the video frame in pixels
 54  * @video_par_n: Numerator of the pixel aspect ratio of the input video.
 55  * @video_par_d: Denominator of the pixel aspect ratio of the input video.
 56  * @display_par_n: Numerator of the pixel aspect ratio of the display device
 57  * @display_par_d: Denominator of the pixel aspect ratio of the display device
 58  *
 59  * Given the Pixel Aspect Ratio and size of an input video frame, and the
 60  * pixel aspect ratio of the intended display device, calculates the actual
 61  * display ratio the video will be rendered with.
 62  *
 63  * Returns: A boolean indicating success and a calculated Display Ratio in the
 64  * dar_n and dar_d parameters.
 65  * The return value is FALSE in the case of integer overflow or other error.
 66  */
 67 gboolean
 68 gst_video_calculate_display_ratio (guint * dar_n, guint * dar_d,
 69     guint video_width, guint video_height,
 70     guint video_par_n, guint video_par_d,
 71     guint display_par_n, guint display_par_d)
 72 {
 73   gint num, den;
 74   gint tmp_n, tmp_d;
 75 
 76   g_return_val_if_fail (dar_n != NULL, FALSE);
 77   g_return_val_if_fail (dar_d != NULL, FALSE);
 78 
 79   /* Calculate (video_width * video_par_n * display_par_d) /
 80    * (video_height * video_par_d * display_par_n) */
 81   if (!gst_util_fraction_multiply (video_width, video_height, video_par_n,
 82           video_par_d, &amp;tmp_n, &amp;tmp_d))
 83     goto error_overflow;
 84 
 85   if (!gst_util_fraction_multiply (tmp_n, tmp_d, display_par_d, display_par_n,
 86           &amp;num, &amp;den))
 87     goto error_overflow;
 88 
 89   g_return_val_if_fail (num &gt; 0, FALSE);
 90   g_return_val_if_fail (den &gt; 0, FALSE);
 91 
 92   *dar_n = num;
 93   *dar_d = den;
 94 
 95   return TRUE;
 96 
 97   /* ERRORS */
 98 error_overflow:
 99   {
100     GST_WARNING (&quot;overflow in multiply&quot;);
101     return FALSE;
102   }
103 }
104 #endif // GSTREAMER_LITE
105 
106 /**
107  * gst_video_guess_framerate:
108  * @duration: Nominal duration of one frame
109  * @dest_n: (out) (allow-none): Numerator of the calculated framerate
110  * @dest_d: (out) (allow-none): Denominator of the calculated framerate
111  *
112  * Given the nominal duration of one video frame,
113  * this function will check some standard framerates for
114  * a close match (within 0.1%) and return one if possible,
115  *
116  * It will calculate an arbitrary framerate if no close
117  * match was found, and return %FALSE.
118  *
119  * It returns %FALSE if a duration of 0 is passed.
120  *
121  * Returns: %TRUE if a close &quot;standard&quot; framerate was
122  * recognised, and %FALSE otherwise.
123  *
124  * Since: 1.6
125  */
126 gboolean
127 gst_video_guess_framerate (GstClockTime duration, gint * dest_n, gint * dest_d)
128 {
129   const int common_den[] = { 1, 2, 3, 4, 1001 };
130   int best_n, best_d, gcd;
131   guint64 best_error = G_MAXUINT64;
132   guint64 a;
133   int i;
134 
135   if (G_UNLIKELY (duration == 0))
136     return FALSE;
137 
138   /* Use a limited precision conversion by default for more sensible results,
139    * unless the frame duration is absurdly small (high speed cameras?) */
140   if (duration &gt; 100000) {
141     best_n = GST_SECOND / 10000;
142     best_d = duration / 10000;
143   } else {
144     best_n = GST_SECOND;
145     best_d = duration;
146   }
147 
148   for (i = 0; i &lt; G_N_ELEMENTS (common_den); i++) {
149     gint d = common_den[i];
150     gint n = gst_util_uint64_scale_round (d, GST_SECOND, duration);
151 
152     /* For NTSC framerates, round to the nearest 1000 fps */
153     if (d == 1001) {
154       n += 500;
155       n -= (n % 1000);
156     }
157 
158     if (n &gt; 0) {
159       /* See what duration the given framerate should be */
160       a = gst_util_uint64_scale_int (GST_SECOND, d, n);
161       /* Compute absolute error */
162       a = (a &lt; duration) ? (duration - a) : (a - duration);
163       if (a &lt; 2) {
164         /* Really precise - take this option */
165         if (dest_n)
166           *dest_n = n;
167         if (dest_d)
168           *dest_d = d;
169         return TRUE;
170       }
171       /* If within 0.1%, remember this denominator */
172       if (a * 1000 &lt; duration &amp;&amp; a &lt; best_error) {
173         best_error = a;
174         best_n = n;
175         best_d = d;
176       }
177     }
178   }
179 
180   /* set results */
181   gcd = gst_util_greatest_common_divisor (best_n, best_d);
182   if (gcd) {
183     best_n /= gcd;
184     best_d /= gcd;
185   }
186   if (dest_n)
187     *dest_n = best_n;
188   if (dest_d)
189     *dest_d = best_d;
190 
191   return (best_error != G_MAXUINT64);
192 }
193 
194 #ifndef GSTREAMER_LITE
195 /**
196  * gst_video_alignment_reset:
197  * @align: a #GstVideoAlignment
198  *
199  * Set @align to its default values with no padding and no alignment.
200  */
201 void
202 gst_video_alignment_reset (GstVideoAlignment * align)
203 {
204   gint i;
205 
206   g_return_if_fail (align != NULL);
207 
208   align-&gt;padding_top = 0;
209   align-&gt;padding_bottom = 0;
210   align-&gt;padding_left = 0;
211   align-&gt;padding_right = 0;
212   for (i = 0; i &lt; GST_VIDEO_MAX_PLANES; i++)
213     align-&gt;stride_align[i] = 0;
214 }
215 #endif // GSTREAMER_LITE
    </pre>
  </body>
</html>