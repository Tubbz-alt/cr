<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst/audioconvert/gstaudioconvert.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 2003 Benjamin Otte &lt;in7y118@public.uni-hamburg.de&gt;
   3  * Copyright (C) 2005 Thomas Vander Stichele &lt;thomas at apestaart dot org&gt;
   4  * Copyright (C) 2011 Wim Taymans &lt;wim.taymans at gmail dot com&gt;
   5  *
   6  * gstaudioconvert.c: Convert audio to different audio formats automatically
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public
  19  * License along with this library; if not, write to the
  20  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 /**
  25  * SECTION:element-audioconvert
  26  * @title: audioconvert
  27  *
  28  * Audioconvert converts raw audio buffers between various possible formats.
  29  * It supports integer to float conversion, width/depth conversion,
  30  * signedness and endianness conversion and channel transformations
  31  * (ie. upmixing and downmixing), as well as dithering and noise-shaping.
  32  *
  33  * ## Example launch line
  34  * |[
  35  * gst-launch-1.0 -v -m audiotestsrc ! audioconvert ! audio/x-raw,format=S8,channels=2 ! level ! fakesink silent=TRUE
  36  * ]|
  37  *  This pipeline converts audio to 8-bit.  The level element shows that
  38  * the output levels still match the one for a sine wave.
  39  * |[
  40  * gst-launch-1.0 -v -m uridecodebin uri=file:///path/to/audio.flac ! audioconvert ! vorbisenc ! oggmux ! filesink location=audio.ogg
  41  * ]|
  42  *  The vorbis encoder takes float audio data instead of the integer data
  43  * output by most other audio elements. This pipeline decodes a FLAC audio file
  44  * (or any other audio file for which decoders are installed) and re-encodes
  45  * it into an Ogg/Vorbis audio file.
  46  *
  47  * A mix matrix can be passed to audioconvert, that will govern the
  48  * remapping of input to output channels.
  49  * ## Example matrix generation code
  50  * To generate the matrix using code:
  51  *
  52  * |[
  53  * GValue v = G_VALUE_INIT;
  54  * GValue v2 = G_VALUE_INIT;
  55  * GValue v3 = G_VALUE_INIT;
  56  *
  57  * g_value_init (&amp;v2, GST_TYPE_ARRAY);
  58  * g_value_init (&amp;v3, G_TYPE_FLOAT);
  59  * g_value_set_float (&amp;v3, 1);
  60  * gst_value_array_append_value (&amp;v2, &amp;v3);
  61  * g_value_unset (&amp;v3);
  62  * [ Repeat for as many float as your input channels - unset and reinit v3 ]
  63  * g_value_init (&amp;v, GST_TYPE_ARRAY);
  64  * gst_value_array_append_value (&amp;v, &amp;v2);
  65  * g_value_unset (&amp;v2);
  66  * [ Repeat for as many v2&#39;s as your output channels - unset and reinit v2]
  67  * g_object_set_property (G_OBJECT (audioconvert), &quot;mix-matrix&quot;, &amp;v);
  68  * g_value_unset (&amp;v);
  69  * ]|
  70  *
  71  * ## Example launch line
  72  * |[
  73  * gst-launch-1.0 audiotestsrc ! audio/x-raw, channels=4 ! audioconvert mix-matrix=&quot;&lt;&lt;(float)1.0, (float)0.0, (float)0.0, (float)0.0&gt;, &lt;(float)0.0, (float)1.0, (float)0.0, (float)0.0&gt;&gt;&quot; ! audio/x-raw,channels=2 ! autoaudiosink
  74  * ]|
  75  *
  76  * &gt; If an empty mix matrix is specified, a (potentially truncated)
  77  * &gt; identity matrix will be generated.
  78  *
  79  * ## Example empty matrix generation code
  80  * |[
  81  * GValue v = G_VALUE_INIT;
  82  *
  83  * g_value_init (&amp;v, GST_TYPE_ARRAY);
  84  * g_object_set_property (G_OBJECT (audioconvert), &quot;mix-matrix&quot;, &amp;v);
  85  * g_value_unset (&amp;v);
  86  * ]|
  87  *
  88  * ## Example empty matrix launch line
  89  * |[
  90  * gst-launch-1.0 -v audiotestsrc ! audio/x-raw,channels=8 ! audioconvert mix-matrix=&quot;&lt;&gt;&quot; ! audio/x-raw,channels=16,channel-mask=\(bitmask\)0x0000000000000000 ! fakesink
  91  * ]|
  92  */
  93 
  94 /*
  95  * design decisions:
  96  * - audioconvert converts buffers in a set of supported caps. If it supports
  97  *   a caps, it supports conversion from these caps to any other caps it
  98  *   supports. (example: if it does A=&gt;B and A=&gt;C, it also does B=&gt;C)
  99  * - audioconvert does not save state between buffers. Every incoming buffer is
 100  *   converted and the converted buffer is pushed out.
 101  * conclusion:
 102  * audioconvert is not supposed to be a one-element-does-anything solution for
 103  * audio conversions.
 104  */
 105 
 106 #ifdef HAVE_CONFIG_H
 107 #include &quot;config.h&quot;
 108 #endif
 109 
 110 #include &lt;string.h&gt;
 111 
 112 #include &quot;gstaudioconvert.h&quot;
 113 #include &quot;plugin.h&quot;
 114 
 115 GST_DEBUG_CATEGORY (audio_convert_debug);
 116 GST_DEBUG_CATEGORY_STATIC (GST_CAT_PERFORMANCE);
 117 #define GST_CAT_DEFAULT (audio_convert_debug)
 118 
 119 /*** DEFINITIONS **************************************************************/
 120 
 121 /* type functions */
 122 static void gst_audio_convert_dispose (GObject * obj);
 123 
 124 /* gstreamer functions */
 125 static gboolean gst_audio_convert_get_unit_size (GstBaseTransform * base,
 126     GstCaps * caps, gsize * size);
 127 static GstCaps *gst_audio_convert_transform_caps (GstBaseTransform * base,
 128     GstPadDirection direction, GstCaps * caps, GstCaps * filter);
 129 static GstCaps *gst_audio_convert_fixate_caps (GstBaseTransform * base,
 130     GstPadDirection direction, GstCaps * caps, GstCaps * othercaps);
 131 static gboolean gst_audio_convert_set_caps (GstBaseTransform * base,
 132     GstCaps * incaps, GstCaps * outcaps);
 133 static GstFlowReturn gst_audio_convert_transform (GstBaseTransform * base,
 134     GstBuffer * inbuf, GstBuffer * outbuf);
 135 static GstFlowReturn gst_audio_convert_transform_ip (GstBaseTransform * base,
 136     GstBuffer * buf);
 137 static gboolean gst_audio_convert_transform_meta (GstBaseTransform * trans,
 138     GstBuffer * outbuf, GstMeta * meta, GstBuffer * inbuf);
 139 static GstFlowReturn gst_audio_convert_submit_input_buffer (GstBaseTransform *
 140     base, gboolean is_discont, GstBuffer * input);
 141 static GstFlowReturn gst_audio_convert_prepare_output_buffer (GstBaseTransform *
 142     base, GstBuffer * inbuf, GstBuffer ** outbuf);
 143 static void gst_audio_convert_set_property (GObject * object, guint prop_id,
 144     const GValue * value, GParamSpec * pspec);
 145 static void gst_audio_convert_get_property (GObject * object, guint prop_id,
 146     GValue * value, GParamSpec * pspec);
 147 
 148 /* AudioConvert signals and args */
 149 enum
 150 {
 151   /* FILL ME */
 152   LAST_SIGNAL
 153 };
 154 
 155 enum
 156 {
 157   PROP_0,
 158   PROP_DITHERING,
 159   PROP_NOISE_SHAPING,
 160   PROP_MIX_MATRIX,
 161 };
 162 
 163 #define DEBUG_INIT \
 164   GST_DEBUG_CATEGORY_INIT (audio_convert_debug, &quot;audioconvert&quot;, 0, &quot;audio conversion element&quot;); \
 165   GST_DEBUG_CATEGORY_GET (GST_CAT_PERFORMANCE, &quot;GST_PERFORMANCE&quot;);
 166 #define gst_audio_convert_parent_class parent_class
 167 G_DEFINE_TYPE_WITH_CODE (GstAudioConvert, gst_audio_convert,
 168     GST_TYPE_BASE_TRANSFORM, DEBUG_INIT);
 169 
 170 /*** GSTREAMER PROTOTYPES *****************************************************/
 171 
 172 #define STATIC_CAPS \
 173 GST_STATIC_CAPS (GST_AUDIO_CAPS_MAKE (GST_AUDIO_FORMATS_ALL) \
 174     &quot;, layout = (string) { interleaved, non-interleaved }&quot;)
 175 
 176 static GstStaticPadTemplate gst_audio_convert_src_template =
 177 GST_STATIC_PAD_TEMPLATE (&quot;src&quot;,
 178     GST_PAD_SRC,
 179     GST_PAD_ALWAYS,
 180     STATIC_CAPS);
 181 
 182 static GstStaticPadTemplate gst_audio_convert_sink_template =
 183 GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,
 184     GST_PAD_SINK,
 185     GST_PAD_ALWAYS,
 186     STATIC_CAPS);
 187 
 188 
 189 /*** TYPE FUNCTIONS ***********************************************************/
 190 static void
 191 gst_audio_convert_class_init (GstAudioConvertClass * klass)
 192 {
 193   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 194   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
 195   GstBaseTransformClass *basetransform_class = GST_BASE_TRANSFORM_CLASS (klass);
 196 
 197   gobject_class-&gt;dispose = gst_audio_convert_dispose;
 198   gobject_class-&gt;set_property = gst_audio_convert_set_property;
 199   gobject_class-&gt;get_property = gst_audio_convert_get_property;
 200 
 201   g_object_class_install_property (gobject_class, PROP_DITHERING,
 202       g_param_spec_enum (&quot;dithering&quot;, &quot;Dithering&quot;,
 203           &quot;Selects between different dithering methods.&quot;,
 204           GST_TYPE_AUDIO_DITHER_METHOD, GST_AUDIO_DITHER_TPDF,
 205           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 206 
 207   g_object_class_install_property (gobject_class, PROP_NOISE_SHAPING,
 208       g_param_spec_enum (&quot;noise-shaping&quot;, &quot;Noise shaping&quot;,
 209           &quot;Selects between different noise shaping methods.&quot;,
 210           GST_TYPE_AUDIO_NOISE_SHAPING_METHOD, GST_AUDIO_NOISE_SHAPING_NONE,
 211           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 212 
 213   g_object_class_install_property (gobject_class, PROP_MIX_MATRIX,
 214       gst_param_spec_array (&quot;mix-matrix&quot;,
 215           &quot;Input/output channel matrix&quot;,
 216           &quot;Transformation matrix for input/output channels&quot;,
 217           gst_param_spec_array (&quot;matrix-rows&quot;, &quot;rows&quot;, &quot;rows&quot;,
 218               g_param_spec_float (&quot;matrix-cols&quot;, &quot;cols&quot;, &quot;cols&quot;,
 219                   -1, 1, 0,
 220                   G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS),
 221               G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS),
 222           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 223 
 224   gst_element_class_add_static_pad_template (element_class,
 225       &amp;gst_audio_convert_src_template);
 226   gst_element_class_add_static_pad_template (element_class,
 227       &amp;gst_audio_convert_sink_template);
 228   gst_element_class_set_static_metadata (element_class, &quot;Audio converter&quot;,
 229       &quot;Filter/Converter/Audio&quot;, &quot;Convert audio to different formats&quot;,
 230       &quot;Benjamin Otte &lt;otte@gnome.org&gt;&quot;);
 231 
 232   basetransform_class-&gt;get_unit_size =
 233       GST_DEBUG_FUNCPTR (gst_audio_convert_get_unit_size);
 234   basetransform_class-&gt;transform_caps =
 235       GST_DEBUG_FUNCPTR (gst_audio_convert_transform_caps);
 236   basetransform_class-&gt;fixate_caps =
 237       GST_DEBUG_FUNCPTR (gst_audio_convert_fixate_caps);
 238   basetransform_class-&gt;set_caps =
 239       GST_DEBUG_FUNCPTR (gst_audio_convert_set_caps);
 240   basetransform_class-&gt;transform =
 241       GST_DEBUG_FUNCPTR (gst_audio_convert_transform);
 242   basetransform_class-&gt;transform_ip =
 243       GST_DEBUG_FUNCPTR (gst_audio_convert_transform_ip);
 244   basetransform_class-&gt;transform_meta =
 245       GST_DEBUG_FUNCPTR (gst_audio_convert_transform_meta);
 246   basetransform_class-&gt;submit_input_buffer =
 247       GST_DEBUG_FUNCPTR (gst_audio_convert_submit_input_buffer);
 248   basetransform_class-&gt;prepare_output_buffer =
 249       GST_DEBUG_FUNCPTR (gst_audio_convert_prepare_output_buffer);
 250 
 251   basetransform_class-&gt;transform_ip_on_passthrough = FALSE;
 252 }
 253 
 254 static void
 255 gst_audio_convert_init (GstAudioConvert * this)
 256 {
 257   this-&gt;dither = GST_AUDIO_DITHER_TPDF;
 258   this-&gt;ns = GST_AUDIO_NOISE_SHAPING_NONE;
 259   g_value_init (&amp;this-&gt;mix_matrix, GST_TYPE_ARRAY);
 260 
 261   gst_base_transform_set_gap_aware (GST_BASE_TRANSFORM (this), TRUE);
 262 }
 263 
 264 static void
 265 gst_audio_convert_dispose (GObject * obj)
 266 {
 267   GstAudioConvert *this = GST_AUDIO_CONVERT (obj);
 268 
 269   if (this-&gt;convert) {
 270     gst_audio_converter_free (this-&gt;convert);
 271     this-&gt;convert = NULL;
 272   }
 273 
 274   g_value_unset (&amp;this-&gt;mix_matrix);
 275 
 276   G_OBJECT_CLASS (parent_class)-&gt;dispose (obj);
 277 }
 278 
 279 /*** GSTREAMER FUNCTIONS ******************************************************/
 280 
 281 /* BaseTransform vmethods */
 282 static gboolean
 283 gst_audio_convert_get_unit_size (GstBaseTransform * base, GstCaps * caps,
 284     gsize * size)
 285 {
 286   GstAudioInfo info;
 287 
 288   g_assert (size);
 289 
 290   if (!gst_audio_info_from_caps (&amp;info, caps))
 291     goto parse_error;
 292 
 293   *size = info.bpf;
 294   GST_INFO_OBJECT (base, &quot;unit_size = %&quot; G_GSIZE_FORMAT, *size);
 295 
 296   return TRUE;
 297 
 298 parse_error:
 299   {
 300     GST_INFO_OBJECT (base, &quot;failed to parse caps to get unit_size&quot;);
 301     return FALSE;
 302   }
 303 }
 304 
 305 static gboolean
 306 remove_format_from_structure (GstCapsFeatures * features,
 307     GstStructure * structure, gpointer user_data G_GNUC_UNUSED)
 308 {
 309   gst_structure_remove_field (structure, &quot;format&quot;);
 310   return TRUE;
 311 }
 312 
 313 static gboolean
 314 remove_layout_from_structure (GstCapsFeatures * features,
 315     GstStructure * structure, gpointer user_data G_GNUC_UNUSED)
 316 {
 317   gst_structure_remove_field (structure, &quot;layout&quot;);
 318   return TRUE;
 319 }
 320 
 321 static gboolean
 322 remove_channels_from_structure (GstCapsFeatures * features, GstStructure * s,
 323     gpointer user_data)
 324 {
 325   guint64 mask;
 326   gint channels;
 327   GstAudioConvert *this = GST_AUDIO_CONVERT (user_data);
 328 
 329   /* Only remove the channels and channel-mask for non-NONE layouts,
 330    * or if a mix matrix was manually specified */
 331   if (this-&gt;mix_matrix_was_set ||
 332       !gst_structure_get (s, &quot;channel-mask&quot;, GST_TYPE_BITMASK, &amp;mask, NULL) ||
 333       (mask != 0 || (gst_structure_get_int (s, &quot;channels&quot;, &amp;channels)
 334               &amp;&amp; channels == 1))) {
 335     gst_structure_remove_fields (s, &quot;channel-mask&quot;, &quot;channels&quot;, NULL);
 336   }
 337 
 338   return TRUE;
 339 }
 340 
 341 static gboolean
 342 add_other_channels_to_structure (GstCapsFeatures * features, GstStructure * s,
 343     gpointer user_data)
 344 {
 345   gint other_channels = GPOINTER_TO_INT (user_data);
 346 
 347   gst_structure_set (s, &quot;channels&quot;, G_TYPE_INT, other_channels, NULL);
 348 
 349   return TRUE;
 350 }
 351 
 352 /* The caps can be transformed into any other caps with format info removed.
 353  * However, we should prefer passthrough, so if passthrough is possible,
 354  * put it first in the list. */
 355 static GstCaps *
 356 gst_audio_convert_transform_caps (GstBaseTransform * btrans,
 357     GstPadDirection direction, GstCaps * caps, GstCaps * filter)
 358 {
 359   GstCaps *tmp, *tmp2;
 360   GstCaps *result;
 361   GstAudioConvert *this = GST_AUDIO_CONVERT (btrans);
 362 
 363   tmp = gst_caps_copy (caps);
 364 
 365   gst_caps_map_in_place (tmp, remove_format_from_structure, NULL);
 366   gst_caps_map_in_place (tmp, remove_layout_from_structure, NULL);
 367   gst_caps_map_in_place (tmp, remove_channels_from_structure, btrans);
 368 
 369   /* We can infer the required input / output channels based on the
 370    * matrix dimensions */
 371   if (gst_value_array_get_size (&amp;this-&gt;mix_matrix)) {
 372     gint other_channels;
 373 
 374     if (direction == GST_PAD_SRC) {
 375       const GValue *first_row =
 376           gst_value_array_get_value (&amp;this-&gt;mix_matrix, 0);
 377       other_channels = gst_value_array_get_size (first_row);
 378     } else {
 379       other_channels = gst_value_array_get_size (&amp;this-&gt;mix_matrix);
 380     }
 381 
 382     gst_caps_map_in_place (tmp, add_other_channels_to_structure,
 383         GINT_TO_POINTER (other_channels));
 384   }
 385 
 386   if (filter) {
 387     tmp2 = gst_caps_intersect_full (filter, tmp, GST_CAPS_INTERSECT_FIRST);
 388     gst_caps_unref (tmp);
 389     tmp = tmp2;
 390   }
 391 
 392   result = tmp;
 393 
 394   GST_DEBUG_OBJECT (btrans, &quot;transformed %&quot; GST_PTR_FORMAT &quot; into %&quot;
 395       GST_PTR_FORMAT, caps, result);
 396 
 397   return result;
 398 }
 399 
 400 /* Count the number of bits set
 401  * Optimized for the common case, assuming that the number of channels
 402  * (i.e. bits set) is small
 403  */
 404 static gint
 405 n_bits_set (guint64 x)
 406 {
 407   gint c;
 408 
 409   for (c = 0; x; c++)
 410     x &amp;= x - 1;
 411 
 412   return c;
 413 }
 414 
 415 /* Reduce the mask to the n_chans lowest set bits
 416  *
 417  * The algorithm clears the n_chans lowest set bits and subtracts the
 418  * result from the original mask to get the desired mask.
 419  * It is optimized for the common case where n_chans is a small
 420  * number. In the worst case, however, it stops after 64 iterations.
 421  */
 422 static guint64
 423 find_suitable_mask (guint64 mask, gint n_chans)
 424 {
 425   guint64 x = mask;
 426 
 427   for (; x &amp;&amp; n_chans; n_chans--)
 428     x &amp;= x - 1;
 429 
 430   g_assert (x || n_chans == 0);
 431   /* assertion fails if mask contained less bits than n_chans
 432    * or n_chans was &lt; 0 */
 433 
 434   return mask - x;
 435 }
 436 
 437 static void
 438 gst_audio_convert_fixate_format (GstBaseTransform * base, GstStructure * ins,
 439     GstStructure * outs)
 440 {
 441   const gchar *in_format;
 442   const GValue *format;
 443   const GstAudioFormatInfo *in_info, *out_info = NULL;
 444   GstAudioFormatFlags in_flags, out_flags = 0;
 445   gint in_depth, out_depth = -1;
 446   gint i, len;
 447 
 448   in_format = gst_structure_get_string (ins, &quot;format&quot;);
 449   if (!in_format)
 450     return;
 451 
 452   format = gst_structure_get_value (outs, &quot;format&quot;);
 453   /* should not happen */
 454   if (format == NULL)
 455     return;
 456 
 457   /* nothing to fixate? */
 458   if (!GST_VALUE_HOLDS_LIST (format))
 459     return;
 460 
 461   in_info =
 462       gst_audio_format_get_info (gst_audio_format_from_string (in_format));
 463   if (!in_info)
 464     return;
 465 
 466   in_flags = GST_AUDIO_FORMAT_INFO_FLAGS (in_info);
 467   in_flags &amp;= ~(GST_AUDIO_FORMAT_FLAG_UNPACK);
 468   in_flags &amp;= ~(GST_AUDIO_FORMAT_FLAG_SIGNED);
 469 
 470   in_depth = GST_AUDIO_FORMAT_INFO_DEPTH (in_info);
 471 
 472   len = gst_value_list_get_size (format);
 473   for (i = 0; i &lt; len; i++) {
 474     const GstAudioFormatInfo *t_info;
 475     GstAudioFormatFlags t_flags;
 476     gboolean t_flags_better;
 477     const GValue *val;
 478     const gchar *fname;
 479     gint t_depth;
 480 
 481     val = gst_value_list_get_value (format, i);
 482     if (!G_VALUE_HOLDS_STRING (val))
 483       continue;
 484 
 485     fname = g_value_get_string (val);
 486     t_info = gst_audio_format_get_info (gst_audio_format_from_string (fname));
 487     if (!t_info)
 488       continue;
 489 
 490     /* accept input format immediately */
 491     if (strcmp (fname, in_format) == 0) {
 492       out_info = t_info;
 493       break;
 494     }
 495 
 496     t_flags = GST_AUDIO_FORMAT_INFO_FLAGS (t_info);
 497     t_flags &amp;= ~(GST_AUDIO_FORMAT_FLAG_UNPACK);
 498     t_flags &amp;= ~(GST_AUDIO_FORMAT_FLAG_SIGNED);
 499 
 500     t_depth = GST_AUDIO_FORMAT_INFO_DEPTH (t_info);
 501 
 502     /* Any output format is better than no output format at all */
 503     if (!out_info) {
 504       out_info = t_info;
 505       out_depth = t_depth;
 506       out_flags = t_flags;
 507       continue;
 508     }
 509 
 510     t_flags_better = (t_flags == in_flags &amp;&amp; out_flags != in_flags);
 511 
 512     if (t_depth == in_depth &amp;&amp; (out_depth != in_depth || t_flags_better)) {
 513       /* Prefer to use the first format that has the same depth with the same
 514        * flags, and if none with the same flags exist use the first other one
 515        * that has the same depth */
 516       out_info = t_info;
 517       out_depth = t_depth;
 518       out_flags = t_flags;
 519     } else if (t_depth &gt;= in_depth &amp;&amp; (in_depth &gt; out_depth
 520             || (out_depth &gt;= in_depth &amp;&amp; t_flags_better))) {
 521       /* Otherwise use the first format that has a higher depth with the same flags,
 522        * if none with the same flags exist use the first other one that has a higher
 523        * depth */
 524       out_info = t_info;
 525       out_depth = t_depth;
 526       out_flags = t_flags;
 527     } else if ((t_depth &gt; out_depth &amp;&amp; out_depth &lt; in_depth)
 528         || (t_flags_better &amp;&amp; out_depth == t_depth)) {
 529       /* Else get at least the one with the highest depth, ideally with the same flags */
 530       out_info = t_info;
 531       out_depth = t_depth;
 532       out_flags = t_flags;
 533     }
 534 
 535   }
 536 
 537   if (out_info)
 538     gst_structure_set (outs, &quot;format&quot;, G_TYPE_STRING,
 539         GST_AUDIO_FORMAT_INFO_NAME (out_info), NULL);
 540 }
 541 
 542 static void
 543 gst_audio_convert_fixate_channels (GstBaseTransform * base, GstStructure * ins,
 544     GstStructure * outs)
 545 {
 546   gint in_chans, out_chans;
 547   guint64 in_mask = 0, out_mask = 0;
 548   gboolean has_in_mask = FALSE, has_out_mask = FALSE;
 549 
 550   if (!gst_structure_get_int (ins, &quot;channels&quot;, &amp;in_chans))
 551     return;                     /* this shouldn&#39;t really happen, should it? */
 552 
 553   if (!gst_structure_has_field (outs, &quot;channels&quot;)) {
 554     /* we could try to get the implied number of channels from the layout,
 555      * but that seems overdoing it for a somewhat exotic corner case */
 556     gst_structure_remove_field (outs, &quot;channel-mask&quot;);
 557     return;
 558   }
 559 
 560   /* ok, let&#39;s fixate the channels if they are not fixated yet */
 561   gst_structure_fixate_field_nearest_int (outs, &quot;channels&quot;, in_chans);
 562 
 563   if (!gst_structure_get_int (outs, &quot;channels&quot;, &amp;out_chans)) {
 564     /* shouldn&#39;t really happen ... */
 565     gst_structure_remove_field (outs, &quot;channel-mask&quot;);
 566     return;
 567   }
 568 
 569   /* get the channel layout of the output if any */
 570   has_out_mask = gst_structure_has_field (outs, &quot;channel-mask&quot;);
 571   if (has_out_mask) {
 572     gst_structure_get (outs, &quot;channel-mask&quot;, GST_TYPE_BITMASK, &amp;out_mask, NULL);
 573   } else {
 574     /* channels == 1 =&gt; MONO */
 575     if (out_chans == 2) {
 576       out_mask =
 577           GST_AUDIO_CHANNEL_POSITION_MASK (FRONT_LEFT) |
 578           GST_AUDIO_CHANNEL_POSITION_MASK (FRONT_RIGHT);
 579       has_out_mask = TRUE;
 580       gst_structure_set (outs, &quot;channel-mask&quot;, GST_TYPE_BITMASK, out_mask,
 581           NULL);
 582     }
 583   }
 584 
 585   /* get the channel layout of the input if any */
 586   has_in_mask = gst_structure_has_field (ins, &quot;channel-mask&quot;);
 587   if (has_in_mask) {
 588     gst_structure_get (ins, &quot;channel-mask&quot;, GST_TYPE_BITMASK, &amp;in_mask, NULL);
 589   } else {
 590     /* channels == 1 =&gt; MONO */
 591     if (in_chans == 2) {
 592       in_mask =
 593           GST_AUDIO_CHANNEL_POSITION_MASK (FRONT_LEFT) |
 594           GST_AUDIO_CHANNEL_POSITION_MASK (FRONT_RIGHT);
 595       has_in_mask = TRUE;
 596     } else if (in_chans &gt; 2)
 597       g_warning (&quot;%s: Upstream caps contain no channel mask&quot;,
 598           GST_ELEMENT_NAME (base));
 599   }
 600 
 601   if (!has_out_mask &amp;&amp; out_chans == 1 &amp;&amp; (in_chans != out_chans
 602           || !has_in_mask))
 603     return;                     /* nothing to do, default layout will be assumed */
 604 
 605   if (in_chans == out_chans &amp;&amp; (has_in_mask || in_chans == 1)) {
 606     /* same number of channels and no output layout: just use input layout */
 607     if (!has_out_mask) {
 608       /* in_chans == 1 handled above already */
 609       gst_structure_set (outs, &quot;channel-mask&quot;, GST_TYPE_BITMASK, in_mask, NULL);
 610       return;
 611     }
 612 
 613     /* If both masks are the same we&#39;re done, this includes the NONE layout case */
 614     if (in_mask == out_mask)
 615       return;
 616 
 617     /* if output layout is fixed already and looks sane, we&#39;re done */
 618     if (n_bits_set (out_mask) == out_chans)
 619       return;
 620 
 621     if (n_bits_set (out_mask) &lt; in_chans) {
 622       /* Not much we can do here, this shouldn&#39;t just happen */
 623       g_warning (&quot;%s: Invalid downstream channel-mask with too few bits set&quot;,
 624           GST_ELEMENT_NAME (base));
 625     } else {
 626       guint64 intersection;
 627 
 628       /* if the output layout is not fixed, check if the output layout contains
 629        * the input layout */
 630       intersection = in_mask &amp; out_mask;
 631       if (n_bits_set (intersection) &gt;= in_chans) {
 632         gst_structure_set (outs, &quot;channel-mask&quot;, GST_TYPE_BITMASK, in_mask,
 633             NULL);
 634         return;
 635       }
 636 
 637       /* output layout is not fixed and does not contain the input layout, so
 638        * just pick the first possibility */
 639       intersection = find_suitable_mask (out_mask, out_chans);
 640       if (intersection) {
 641         gst_structure_set (outs, &quot;channel-mask&quot;, GST_TYPE_BITMASK, intersection,
 642             NULL);
 643         return;
 644       }
 645     }
 646 
 647     /* ... else fall back to default layout (NB: out_layout is NULL here) */
 648     GST_WARNING_OBJECT (base, &quot;unexpected output channel layout&quot;);
 649   } else {
 650     guint64 intersection;
 651 
 652     /* number of input channels != number of output channels:
 653      * if this value contains a list of channel layouts (or even worse: a list
 654      * with another list), just pick the first value and repeat until we find a
 655      * channel position array or something else that&#39;s not a list; we assume
 656      * the input if half-way sane and don&#39;t try to fall back on other list items
 657      * if the first one is something unexpected or non-channel-pos-array-y */
 658     if (n_bits_set (out_mask) &gt;= out_chans) {
 659       intersection = find_suitable_mask (out_mask, out_chans);
 660       gst_structure_set (outs, &quot;channel-mask&quot;, GST_TYPE_BITMASK, intersection,
 661           NULL);
 662       return;
 663     }
 664 
 665     /* what now?! Just ignore what we&#39;re given and use default positions */
 666     GST_WARNING_OBJECT (base, &quot;invalid or unexpected channel-positions&quot;);
 667   }
 668 
 669   /* missing or invalid output layout and we can&#39;t use the input layout for
 670    * one reason or another, so just pick a default layout (we could be smarter
 671    * and try to add/remove channels from the input layout, or pick a default
 672    * layout based on LFE-presence in input layout, but let&#39;s save that for
 673    * another day). For mono, no mask is required and the fallback mask is 0 */
 674   if (out_chans &gt; 1
 675       &amp;&amp; (out_mask = gst_audio_channel_get_fallback_mask (out_chans))) {
 676     GST_DEBUG_OBJECT (base, &quot;using default channel layout as fallback&quot;);
 677     gst_structure_set (outs, &quot;channel-mask&quot;, GST_TYPE_BITMASK, out_mask, NULL);
 678   } else if (out_chans &gt; 1) {
 679     GST_ERROR_OBJECT (base, &quot;Have no default layout for %d channels&quot;,
 680         out_chans);
 681   }
 682 }
 683 
 684 /* try to keep as many of the structure members the same by fixating the
 685  * possible ranges; this way we convert the least amount of things as possible
 686  */
 687 static GstCaps *
 688 gst_audio_convert_fixate_caps (GstBaseTransform * base,
 689     GstPadDirection direction, GstCaps * caps, GstCaps * othercaps)
 690 {
 691   GstStructure *ins, *outs;
 692   GstCaps *result;
 693 
 694   GST_DEBUG_OBJECT (base, &quot;trying to fixate othercaps %&quot; GST_PTR_FORMAT
 695       &quot; based on caps %&quot; GST_PTR_FORMAT, othercaps, caps);
 696 
 697   result = gst_caps_intersect (othercaps, caps);
 698   if (gst_caps_is_empty (result)) {
 699     GstCaps *removed = gst_caps_copy (caps);
 700 
 701     if (result)
 702       gst_caps_unref (result);
 703     gst_caps_map_in_place (removed, remove_format_from_structure, NULL);
 704     gst_caps_map_in_place (removed, remove_layout_from_structure, NULL);
 705     result = gst_caps_intersect (othercaps, removed);
 706     gst_caps_unref (removed);
 707     if (gst_caps_is_empty (result)) {
 708       if (result)
 709         gst_caps_unref (result);
 710       result = othercaps;
 711     } else {
 712       gst_caps_unref (othercaps);
 713     }
 714   } else {
 715     gst_caps_unref (othercaps);
 716   }
 717 
 718   GST_DEBUG_OBJECT (base, &quot;now fixating %&quot; GST_PTR_FORMAT, result);
 719 
 720   /* fixate remaining fields */
 721   result = gst_caps_make_writable (result);
 722 
 723   ins = gst_caps_get_structure (caps, 0);
 724   outs = gst_caps_get_structure (result, 0);
 725 
 726   gst_audio_convert_fixate_channels (base, ins, outs);
 727   gst_audio_convert_fixate_format (base, ins, outs);
 728 
 729   /* fixate remaining */
 730   result = gst_caps_fixate (result);
 731 
 732   GST_DEBUG_OBJECT (base, &quot;fixated othercaps to %&quot; GST_PTR_FORMAT, result);
 733 
 734   return result;
 735 }
 736 
 737 static gboolean
 738 gst_audio_convert_set_caps (GstBaseTransform * base, GstCaps * incaps,
 739     GstCaps * outcaps)
 740 {
 741   GstAudioConvert *this = GST_AUDIO_CONVERT (base);
 742   GstAudioInfo in_info;
 743   GstAudioInfo out_info;
 744   gboolean in_place;
 745   GstStructure *config;
 746 
 747   GST_DEBUG_OBJECT (base, &quot;incaps %&quot; GST_PTR_FORMAT &quot;, outcaps %&quot;
 748       GST_PTR_FORMAT, incaps, outcaps);
 749 
 750   if (this-&gt;convert) {
 751     gst_audio_converter_free (this-&gt;convert);
 752     this-&gt;convert = NULL;
 753   }
 754 
 755   if (!gst_audio_info_from_caps (&amp;in_info, incaps))
 756     goto invalid_in;
 757   if (!gst_audio_info_from_caps (&amp;out_info, outcaps))
 758     goto invalid_out;
 759 
 760   config = gst_structure_new (&quot;GstAudioConverterConfig&quot;,
 761       GST_AUDIO_CONVERTER_OPT_DITHER_METHOD, GST_TYPE_AUDIO_DITHER_METHOD,
 762       this-&gt;dither,
 763       GST_AUDIO_CONVERTER_OPT_NOISE_SHAPING_METHOD,
 764       GST_TYPE_AUDIO_NOISE_SHAPING_METHOD, this-&gt;ns, NULL);
 765 
 766   if (this-&gt;mix_matrix_was_set)
 767     gst_structure_set_value (config, GST_AUDIO_CONVERTER_OPT_MIX_MATRIX,
 768         &amp;this-&gt;mix_matrix);
 769 
 770   this-&gt;convert = gst_audio_converter_new (0, &amp;in_info, &amp;out_info, config);
 771 
 772   if (this-&gt;convert == NULL)
 773     goto no_converter;
 774 
 775   in_place = gst_audio_converter_supports_inplace (this-&gt;convert);
 776   gst_base_transform_set_in_place (base, in_place);
 777 
 778   gst_base_transform_set_passthrough (base,
 779       gst_audio_converter_is_passthrough (this-&gt;convert));
 780 
 781   this-&gt;in_info = in_info;
 782   this-&gt;out_info = out_info;
 783 
 784   return TRUE;
 785 
 786   /* ERRORS */
 787 invalid_in:
 788   {
 789     GST_ERROR_OBJECT (base, &quot;invalid input caps&quot;);
 790     return FALSE;
 791   }
 792 invalid_out:
 793   {
 794     GST_ERROR_OBJECT (base, &quot;invalid output caps&quot;);
 795     return FALSE;
 796   }
 797 no_converter:
 798   {
 799     GST_ERROR_OBJECT (base, &quot;could not make converter&quot;);
 800     return FALSE;
 801   }
 802 }
 803 
 804 /* if called through gst_audio_convert_transform_ip() inbuf == outbuf */
 805 static GstFlowReturn
 806 gst_audio_convert_transform (GstBaseTransform * base, GstBuffer * inbuf,
 807     GstBuffer * outbuf)
 808 {
 809   GstFlowReturn ret;
 810   GstAudioConvert *this = GST_AUDIO_CONVERT (base);
 811   GstAudioBuffer srcabuf, dstabuf;
 812   gboolean inbuf_writable;
 813   GstAudioConverterFlags flags;
 814 
 815   /* https://bugzilla.gnome.org/show_bug.cgi?id=396835 */
 816   if (gst_buffer_get_size (inbuf) == 0)
 817     return GST_FLOW_OK;
 818 
 819   if (inbuf != outbuf) {
 820     inbuf_writable = gst_buffer_is_writable (inbuf)
 821         &amp;&amp; gst_buffer_n_memory (inbuf) == 1
 822         &amp;&amp; gst_memory_is_writable (gst_buffer_peek_memory (inbuf, 0));
 823 
 824     if (!gst_audio_buffer_map (&amp;srcabuf, &amp;this-&gt;in_info, inbuf,
 825             inbuf_writable ? GST_MAP_READWRITE : GST_MAP_READ))
 826       goto inmap_error;
 827   } else {
 828     inbuf_writable = TRUE;
 829   }
 830 
 831   if (!gst_audio_buffer_map (&amp;dstabuf, &amp;this-&gt;out_info, outbuf, GST_MAP_WRITE))
 832     goto outmap_error;
 833 
 834   /* and convert the samples */
 835   flags = 0;
 836   if (inbuf_writable)
 837     flags |= GST_AUDIO_CONVERTER_FLAG_IN_WRITABLE;
 838 
 839   if (!GST_BUFFER_FLAG_IS_SET (inbuf, GST_BUFFER_FLAG_GAP)) {
 840     if (!gst_audio_converter_samples (this-&gt;convert, flags,
 841             inbuf != outbuf ? srcabuf.planes : dstabuf.planes,
 842             dstabuf.n_samples, dstabuf.planes, dstabuf.n_samples))
 843       goto convert_error;
 844   } else {
 845     /* Create silence buffer */
 846     gint i;
 847     for (i = 0; i &lt; dstabuf.n_planes; i++) {
 848       gst_audio_format_fill_silence (this-&gt;out_info.finfo, dstabuf.planes[i],
 849           GST_AUDIO_BUFFER_PLANE_SIZE (&amp;dstabuf));
 850     }
 851   }
 852   ret = GST_FLOW_OK;
 853 
 854 done:
 855   gst_audio_buffer_unmap (&amp;dstabuf);
 856   if (inbuf != outbuf)
 857     gst_audio_buffer_unmap (&amp;srcabuf);
 858 
 859   return ret;
 860 
 861   /* ERRORS */
 862 convert_error:
 863   {
 864     GST_ELEMENT_ERROR (this, STREAM, FORMAT,
 865         (NULL), (&quot;error while converting&quot;));
 866     ret = GST_FLOW_ERROR;
 867     goto done;
 868   }
 869 inmap_error:
 870   {
 871     GST_ELEMENT_ERROR (this, STREAM, FORMAT,
 872         (NULL), (&quot;failed to map input buffer&quot;));
 873     return GST_FLOW_ERROR;
 874   }
 875 outmap_error:
 876   {
 877     GST_ELEMENT_ERROR (this, STREAM, FORMAT,
 878         (NULL), (&quot;failed to map output buffer&quot;));
 879     if (inbuf != outbuf)
 880       gst_audio_buffer_unmap (&amp;srcabuf);
 881     return GST_FLOW_ERROR;
 882   }
 883 }
 884 
 885 static GstFlowReturn
 886 gst_audio_convert_transform_ip (GstBaseTransform * base, GstBuffer * buf)
 887 {
 888   return gst_audio_convert_transform (base, buf, buf);
 889 }
 890 
 891 static gboolean
 892 gst_audio_convert_transform_meta (GstBaseTransform * trans, GstBuffer * outbuf,
 893     GstMeta * meta, GstBuffer * inbuf)
 894 {
 895   const GstMetaInfo *info = meta-&gt;info;
 896   const gchar *const *tags;
 897 
 898   tags = gst_meta_api_type_get_tags (info-&gt;api);
 899 
 900   if (!tags || (g_strv_length ((gchar **) tags) == 1
 901           &amp;&amp; gst_meta_api_type_has_tag (info-&gt;api,
 902               g_quark_from_string (GST_META_TAG_AUDIO_STR))))
 903     return TRUE;
 904 
 905   return FALSE;
 906 }
 907 
 908 static GstFlowReturn
 909 gst_audio_convert_submit_input_buffer (GstBaseTransform * base,
 910     gboolean is_discont, GstBuffer * input)
 911 {
 912   GstAudioConvert *this = GST_AUDIO_CONVERT (base);
 913 
 914   if (base-&gt;segment.format == GST_FORMAT_TIME) {
 915     input =
 916         gst_audio_buffer_clip (input, &amp;base-&gt;segment, this-&gt;in_info.rate,
 917         this-&gt;in_info.bpf);
 918 
 919     if (!input)
 920       return GST_FLOW_OK;
 921   }
 922 
 923   return GST_BASE_TRANSFORM_CLASS (parent_class)-&gt;submit_input_buffer (base,
 924       is_discont, input);
 925 }
 926 
 927 static GstFlowReturn
 928 gst_audio_convert_prepare_output_buffer (GstBaseTransform * base,
 929     GstBuffer * inbuf, GstBuffer ** outbuf)
 930 {
 931   GstAudioConvert *this = GST_AUDIO_CONVERT (base);
 932   GstAudioMeta *meta;
 933   GstFlowReturn ret;
 934 
 935   ret = GST_BASE_TRANSFORM_CLASS (parent_class)-&gt;prepare_output_buffer (base,
 936       inbuf, outbuf);
 937 
 938   if (ret != GST_FLOW_OK)
 939     return ret;
 940 
 941   meta = gst_buffer_get_audio_meta (inbuf);
 942 
 943   if (inbuf != *outbuf) {
 944     gsize samples = meta ?
 945         meta-&gt;samples : (gst_buffer_get_size (inbuf) / this-&gt;in_info.bpf);
 946 
 947     /* ensure that the output buffer is not bigger than what we need */
 948     gst_buffer_resize (*outbuf, 0, samples * this-&gt;out_info.bpf);
 949 
 950     /* add the audio meta on the output buffer if it&#39;s planar */
 951     if (this-&gt;out_info.layout == GST_AUDIO_LAYOUT_NON_INTERLEAVED) {
 952       gst_buffer_add_audio_meta (*outbuf, &amp;this-&gt;out_info, samples, NULL);
 953     }
 954   } else {
 955     /* if the input buffer came with a GstAudioMeta,
 956      * update it to reflect the properties of the output format */
 957     if (meta)
 958       meta-&gt;info = this-&gt;out_info;
 959   }
 960 
 961   return ret;
 962 }
 963 
 964 static void
 965 gst_audio_convert_set_property (GObject * object, guint prop_id,
 966     const GValue * value, GParamSpec * pspec)
 967 {
 968   GstAudioConvert *this = GST_AUDIO_CONVERT (object);
 969 
 970   switch (prop_id) {
 971     case PROP_DITHERING:
 972       this-&gt;dither = g_value_get_enum (value);
 973       break;
 974     case PROP_NOISE_SHAPING:
 975       this-&gt;ns = g_value_get_enum (value);
 976       break;
 977     case PROP_MIX_MATRIX:
 978       if (!gst_value_array_get_size (value)) {
 979         g_value_copy (value, &amp;this-&gt;mix_matrix);
 980         this-&gt;mix_matrix_was_set = TRUE;
 981       } else {
 982         const GValue *first_row = gst_value_array_get_value (value, 0);
 983 
 984         if (gst_value_array_get_size (first_row)) {
 985           if (gst_value_array_get_size (&amp;this-&gt;mix_matrix))
 986             g_value_unset (&amp;this-&gt;mix_matrix);
 987 
 988           g_value_copy (value, &amp;this-&gt;mix_matrix);
 989           this-&gt;mix_matrix_was_set = TRUE;
 990         } else {
 991           g_warning (&quot;Empty mix matrix&#39;s first row&quot;);
 992         }
 993       }
 994       break;
 995     default:
 996       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 997       break;
 998   }
 999 }
1000 
1001 static void
1002 gst_audio_convert_get_property (GObject * object, guint prop_id,
1003     GValue * value, GParamSpec * pspec)
1004 {
1005   GstAudioConvert *this = GST_AUDIO_CONVERT (object);
1006 
1007   switch (prop_id) {
1008     case PROP_DITHERING:
1009       g_value_set_enum (value, this-&gt;dither);
1010       break;
1011     case PROP_NOISE_SHAPING:
1012       g_value_set_enum (value, this-&gt;ns);
1013       break;
1014     case PROP_MIX_MATRIX:
1015       if (this-&gt;mix_matrix_was_set)
1016         g_value_copy (&amp;this-&gt;mix_matrix, value);
1017       break;
1018     default:
1019       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
1020       break;
1021   }
1022 }
    </pre>
  </body>
</html>