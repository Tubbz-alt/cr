<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gfileutils.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gerror.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gfileutils.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gfileutils.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 62,11 ***</span>
   * SECTION:fileutils
   * @title: File Utilities
   * @short_description: various file-related functions
   *
   * Do not use these APIs unless you are porting a POSIX application to Windows.
<span class="line-modified">!  * A more high-level file access API is provided as GIO see the documentation</span>
   * for #GFile.
   *
   * There is a group of functions which wrap the common POSIX functions
   * dealing with filenames (g_open(), g_rename(), g_mkdir(), g_stat(),
   * g_unlink(), g_remove(), g_fopen(), g_freopen()). The point of these
<span class="line-new-header">--- 62,11 ---</span>
   * SECTION:fileutils
   * @title: File Utilities
   * @short_description: various file-related functions
   *
   * Do not use these APIs unless you are porting a POSIX application to Windows.
<span class="line-modified">!  * A more high-level file access API is provided as GIO - see the documentation</span>
   * for #GFile.
   *
   * There is a group of functions which wrap the common POSIX functions
   * dealing with filenames (g_open(), g_rename(), g_mkdir(), g_stat(),
   * g_unlink(), g_remove(), g_fopen(), g_freopen()). The point of these
</pre>
<hr />
<pre>
<span class="line-old-header">*** 214,59 ***</span>
   *
   * Since: 2.8
   */
  int
  g_mkdir_with_parents (const gchar *pathname,
<span class="line-modified">!               int          mode)</span>
  {
    gchar *fn, *p;
  
    if (pathname == NULL || *pathname == &#39;\0&#39;)
      {
        errno = EINVAL;
        return -1;
      }
  
    fn = g_strdup (pathname);
  
    if (g_path_is_absolute (fn))
      p = (gchar *) g_path_skip_root (fn);
    else
      p = fn;
  
    do
      {
        while (*p &amp;&amp; !G_IS_DIR_SEPARATOR (*p))
<span class="line-modified">!     p++;</span>
  
        if (!*p)
<span class="line-modified">!     p = NULL;</span>
        else
<span class="line-modified">!     *p = &#39;\0&#39;;</span>
  
        if (!g_file_test (fn, G_FILE_TEST_EXISTS))
<span class="line-modified">!     {</span>
<span class="line-modified">!       if (g_mkdir (fn, mode) == -1 &amp;&amp; errno != EEXIST)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           int errno_save = errno;</span>
<span class="line-modified">!           g_free (fn);</span>
<span class="line-modified">!           errno = errno_save;</span>
<span class="line-modified">!           return -1;</span>
<span class="line-modified">!         }</span>
      }
        else if (!g_file_test (fn, G_FILE_TEST_IS_DIR))
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_free (fn);</span>
<span class="line-modified">!       errno = ENOTDIR;</span>
<span class="line-modified">!       return -1;</span>
<span class="line-modified">!     }</span>
        if (p)
<span class="line-modified">!     {</span>
<span class="line-modified">!       *p++ = G_DIR_SEPARATOR;</span>
<span class="line-modified">!       while (*p &amp;&amp; G_IS_DIR_SEPARATOR (*p))</span>
<span class="line-modified">!         p++;</span>
<span class="line-modified">!     }</span>
      }
    while (p);
  
    g_free (fn);
  
<span class="line-new-header">--- 214,76 ---</span>
   *
   * Since: 2.8
   */
  int
  g_mkdir_with_parents (const gchar *pathname,
<span class="line-modified">!           int          mode)</span>
  {
    gchar *fn, *p;
  
    if (pathname == NULL || *pathname == &#39;\0&#39;)
      {
        errno = EINVAL;
        return -1;
      }
  
<span class="line-added">+   /* try to create the full path first */</span>
<span class="line-added">+   if (g_mkdir (pathname, mode) == 0)</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+   else if (errno == EEXIST)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       if (!g_file_test (pathname, G_FILE_TEST_IS_DIR))</span>
<span class="line-added">+         {</span>
<span class="line-added">+           errno = ENOTDIR;</span>
<span class="line-added">+           return -1;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       return 0;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* walk the full path and try creating each element */</span>
    fn = g_strdup (pathname);
  
    if (g_path_is_absolute (fn))
      p = (gchar *) g_path_skip_root (fn);
    else
      p = fn;
  
    do
      {
        while (*p &amp;&amp; !G_IS_DIR_SEPARATOR (*p))
<span class="line-modified">!   p++;</span>
  
        if (!*p)
<span class="line-modified">!   p = NULL;</span>
        else
<span class="line-modified">!   *p = &#39;\0&#39;;</span>
  
        if (!g_file_test (fn, G_FILE_TEST_EXISTS))
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (g_mkdir (fn, mode) == -1 &amp;&amp; errno != EEXIST)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         int errno_save = errno;</span>
<span class="line-modified">!         if (errno != ENOENT || !p)</span>
<span class="line-modified">!                 {</span>
<span class="line-modified">!             g_free (fn);</span>
<span class="line-modified">!             errno = errno_save;</span>
<span class="line-added">+             return -1;</span>
      }
<span class="line-added">+       }</span>
<span class="line-added">+   }</span>
        else if (!g_file_test (fn, G_FILE_TEST_IS_DIR))
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_free (fn);</span>
<span class="line-modified">!     errno = ENOTDIR;</span>
<span class="line-modified">!     return -1;</span>
<span class="line-modified">!   }</span>
        if (p)
<span class="line-modified">!   {</span>
<span class="line-modified">!     *p++ = G_DIR_SEPARATOR;</span>
<span class="line-modified">!     while (*p &amp;&amp; G_IS_DIR_SEPARATOR (*p))</span>
<span class="line-modified">!       p++;</span>
<span class="line-modified">!   }</span>
      }
    while (p);
  
    g_free (fn);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 358,17 ***</span>
      return TRUE;
  
    if (test &amp; G_FILE_TEST_IS_REGULAR)
      {
        if ((attributes &amp; (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_DEVICE)) == 0)
<span class="line-modified">!     return TRUE;</span>
      }
  
    if (test &amp; G_FILE_TEST_IS_DIR)
      {
        if ((attributes &amp; FILE_ATTRIBUTE_DIRECTORY) != 0)
<span class="line-modified">!     return TRUE;</span>
      }
  
    /* &quot;while&quot; so that we can exit this &quot;loop&quot; with a simple &quot;break&quot; */
    while (test &amp; G_FILE_TEST_IS_EXECUTABLE)
      {
<span class="line-new-header">--- 375,17 ---</span>
      return TRUE;
  
    if (test &amp; G_FILE_TEST_IS_REGULAR)
      {
        if ((attributes &amp; (FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_DEVICE)) == 0)
<span class="line-modified">!   return TRUE;</span>
      }
  
    if (test &amp; G_FILE_TEST_IS_DIR)
      {
        if ((attributes &amp; FILE_ATTRIBUTE_DIRECTORY) != 0)
<span class="line-modified">!   return TRUE;</span>
      }
  
    /* &quot;while&quot; so that we can exit this &quot;loop&quot; with a simple &quot;break&quot; */
    while (test &amp; G_FILE_TEST_IS_EXECUTABLE)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 378,14 ***</span>
  
        if (lastdot == NULL)
          break;
  
        if (_stricmp (lastdot, &quot;.exe&quot;) == 0 ||
<span class="line-modified">!       _stricmp (lastdot, &quot;.cmd&quot;) == 0 ||</span>
<span class="line-modified">!       _stricmp (lastdot, &quot;.bat&quot;) == 0 ||</span>
<span class="line-modified">!       _stricmp (lastdot, &quot;.com&quot;) == 0)</span>
<span class="line-modified">!     return TRUE;</span>
  
        /* Check if it is one of the types listed in %PATHEXT% */
  
        pathext = g_getenv (&quot;PATHEXT&quot;);
        if (pathext == NULL)
<span class="line-new-header">--- 395,14 ---</span>
  
        if (lastdot == NULL)
          break;
  
        if (_stricmp (lastdot, &quot;.exe&quot;) == 0 ||
<span class="line-modified">!     _stricmp (lastdot, &quot;.cmd&quot;) == 0 ||</span>
<span class="line-modified">!     _stricmp (lastdot, &quot;.bat&quot;) == 0 ||</span>
<span class="line-modified">!     _stricmp (lastdot, &quot;.com&quot;) == 0)</span>
<span class="line-modified">!   return TRUE;</span>
  
        /* Check if it is one of the types listed in %PATHEXT% */
  
        pathext = g_getenv (&quot;PATHEXT&quot;);
        if (pathext == NULL)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 396,26 ***</span>
        lastdot = g_utf8_casefold (lastdot, -1);
        extlen = strlen (lastdot);
  
        p = pathext;
        while (TRUE)
<span class="line-modified">!     {</span>
<span class="line-modified">!       const gchar *q = strchr (p, &#39;;&#39;);</span>
<span class="line-modified">!       if (q == NULL)</span>
<span class="line-modified">!         q = p + strlen (p);</span>
<span class="line-modified">!       if (extlen == q - p &amp;&amp;</span>
<span class="line-modified">!           memcmp (lastdot, p, extlen) == 0)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           g_free ((gchar *) pathext);</span>
<span class="line-modified">!           g_free ((gchar *) lastdot);</span>
<span class="line-modified">!           return TRUE;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       if (*q)</span>
<span class="line-modified">!         p = q + 1;</span>
<span class="line-modified">!       else</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     }</span>
  
        g_free ((gchar *) pathext);
        g_free ((gchar *) lastdot);
        break;
      }
<span class="line-new-header">--- 413,26 ---</span>
        lastdot = g_utf8_casefold (lastdot, -1);
        extlen = strlen (lastdot);
  
        p = pathext;
        while (TRUE)
<span class="line-modified">!   {</span>
<span class="line-modified">!     const gchar *q = strchr (p, &#39;;&#39;);</span>
<span class="line-modified">!     if (q == NULL)</span>
<span class="line-modified">!       q = p + strlen (p);</span>
<span class="line-modified">!     if (extlen == q - p &amp;&amp;</span>
<span class="line-modified">!         memcmp (lastdot, p, extlen) == 0)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         g_free ((gchar *) pathext);</span>
<span class="line-modified">!         g_free ((gchar *) lastdot);</span>
<span class="line-modified">!         return TRUE;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     if (*q)</span>
<span class="line-modified">!       p = q + 1;</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!   }</span>
  
        g_free ((gchar *) pathext);
        g_free ((gchar *) lastdot);
        break;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 426,11 ***</span>
      return TRUE;
  
    if ((test &amp; G_FILE_TEST_IS_EXECUTABLE) &amp;&amp; (access (filename, X_OK) == 0))
      {
        if (getuid () != 0)
<span class="line-modified">!     return TRUE;</span>
  
        /* For root, on some POSIX systems, access (filename, X_OK)
         * will succeed even if no executable bits are set on the
         * file. We fall through to a stat test to avoid that.
         */
<span class="line-new-header">--- 443,11 ---</span>
      return TRUE;
  
    if ((test &amp; G_FILE_TEST_IS_EXECUTABLE) &amp;&amp; (access (filename, X_OK) == 0))
      {
        if (getuid () != 0)
<span class="line-modified">!   return TRUE;</span>
  
        /* For root, on some POSIX systems, access (filename, X_OK)
         * will succeed even if no executable bits are set on the
         * file. We fall through to a stat test to avoid that.
         */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 445,31 ***</span>
        if ((lstat (filename, &amp;s) == 0) &amp;&amp; S_ISLNK (s.st_mode))
          return TRUE;
      }
  
    if (test &amp; (G_FILE_TEST_IS_REGULAR |
<span class="line-modified">!           G_FILE_TEST_IS_DIR |</span>
<span class="line-modified">!           G_FILE_TEST_IS_EXECUTABLE))</span>
      {
        struct stat s;
  
        if (stat (filename, &amp;s) == 0)
<span class="line-modified">!     {</span>
<span class="line-modified">!       if ((test &amp; G_FILE_TEST_IS_REGULAR) &amp;&amp; S_ISREG (s.st_mode))</span>
<span class="line-modified">!         return TRUE;</span>
  
<span class="line-modified">!       if ((test &amp; G_FILE_TEST_IS_DIR) &amp;&amp; S_ISDIR (s.st_mode))</span>
<span class="line-modified">!         return TRUE;</span>
  
<span class="line-modified">!       /* The extra test for root when access (file, X_OK) succeeds.</span>
<span class="line-modified">!        */</span>
<span class="line-modified">!       if ((test &amp; G_FILE_TEST_IS_EXECUTABLE) &amp;&amp;</span>
<span class="line-modified">!           ((s.st_mode &amp; S_IXOTH) ||</span>
<span class="line-modified">!            (s.st_mode &amp; S_IXUSR) ||</span>
<span class="line-modified">!            (s.st_mode &amp; S_IXGRP)))</span>
<span class="line-modified">!         return TRUE;</span>
<span class="line-modified">!     }</span>
      }
  
    return FALSE;
  #endif
  }
<span class="line-new-header">--- 462,31 ---</span>
        if ((lstat (filename, &amp;s) == 0) &amp;&amp; S_ISLNK (s.st_mode))
          return TRUE;
      }
  
    if (test &amp; (G_FILE_TEST_IS_REGULAR |
<span class="line-modified">!         G_FILE_TEST_IS_DIR |</span>
<span class="line-modified">!         G_FILE_TEST_IS_EXECUTABLE))</span>
      {
        struct stat s;
  
        if (stat (filename, &amp;s) == 0)
<span class="line-modified">!   {</span>
<span class="line-modified">!     if ((test &amp; G_FILE_TEST_IS_REGULAR) &amp;&amp; S_ISREG (s.st_mode))</span>
<span class="line-modified">!       return TRUE;</span>
  
<span class="line-modified">!     if ((test &amp; G_FILE_TEST_IS_DIR) &amp;&amp; S_ISDIR (s.st_mode))</span>
<span class="line-modified">!       return TRUE;</span>
  
<span class="line-modified">!     /* The extra test for root when access (file, X_OK) succeeds.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     if ((test &amp; G_FILE_TEST_IS_EXECUTABLE) &amp;&amp;</span>
<span class="line-modified">!         ((s.st_mode &amp; S_IXOTH) ||</span>
<span class="line-modified">!          (s.st_mode &amp; S_IXUSR) ||</span>
<span class="line-modified">!          (s.st_mode &amp; S_IXGRP)))</span>
<span class="line-modified">!       return TRUE;</span>
<span class="line-modified">!   }</span>
      }
  
    return FALSE;
  #endif
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 726,28 ***</span>
                g_set_error (error,
                             G_FILE_ERROR,
                             G_FILE_ERROR_NOMEM,
                             g_dngettext (GETTEXT_PACKAGE, &quot;Could not allocate %lu byte to read file &#39;%s&#39;&quot;, &quot;Could not allocate %lu bytes to read file &#39;%s&#39;&quot;, (gulong)total_allocated),
                             (gulong) total_allocated,
<span class="line-modified">!                display_filename);</span>
                g_free (display_filename);
  
                goto error;
              }
  
<span class="line-modified">!       str = tmp;</span>
          }
  
        if (ferror (f))
          {
            display_filename = g_filename_display_name (filename);
            g_set_error (error,
                         G_FILE_ERROR,
                         g_file_error_from_errno (save_errno),
                         _(&quot;Error reading file &#39;%s&#39;: %s&quot;),
                         display_filename,
<span class="line-modified">!                g_strerror (save_errno));</span>
            g_free (display_filename);
  
            goto error;
          }
  
<span class="line-new-header">--- 743,28 ---</span>
                g_set_error (error,
                             G_FILE_ERROR,
                             G_FILE_ERROR_NOMEM,
                             g_dngettext (GETTEXT_PACKAGE, &quot;Could not allocate %lu byte to read file &#39;%s&#39;&quot;, &quot;Could not allocate %lu bytes to read file &#39;%s&#39;&quot;, (gulong)total_allocated),
                             (gulong) total_allocated,
<span class="line-modified">!          display_filename);</span>
                g_free (display_filename);
  
                goto error;
              }
  
<span class="line-modified">!     str = tmp;</span>
          }
  
        if (ferror (f))
          {
            display_filename = g_filename_display_name (filename);
            g_set_error (error,
                         G_FILE_ERROR,
                         g_file_error_from_errno (save_errno),
                         _(&quot;Error reading file &#39;%s&#39;: %s&quot;),
                         display_filename,
<span class="line-modified">!            g_strerror (save_errno));</span>
            g_free (display_filename);
  
            goto error;
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 818,11 ***</span>
        g_set_error (error,
                     G_FILE_ERROR,
                     G_FILE_ERROR_NOMEM,
                             g_dngettext (GETTEXT_PACKAGE, &quot;Could not allocate %lu byte to read file &#39;%s&#39;&quot;, &quot;Could not allocate %lu bytes to read file &#39;%s&#39;&quot;, (gulong)alloc_size),
                     (gulong) alloc_size,
<span class="line-modified">!            display_filename);</span>
        g_free (display_filename);
        goto error;
      }
  
    bytes_read = 0;
<span class="line-new-header">--- 835,11 ---</span>
        g_set_error (error,
                     G_FILE_ERROR,
                     G_FILE_ERROR_NOMEM,
                             g_dngettext (GETTEXT_PACKAGE, &quot;Could not allocate %lu byte to read file &#39;%s&#39;&quot;, &quot;Could not allocate %lu bytes to read file &#39;%s&#39;&quot;, (gulong)alloc_size),
                     (gulong) alloc_size,
<span class="line-modified">!        display_filename);</span>
        g_free (display_filename);
        goto error;
      }
  
    bytes_read = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 834,22 ***</span>
  
        if (rc &lt; 0)
          {
            if (errno != EINTR)
              {
<span class="line-modified">!           int save_errno = errno;</span>
  
                g_free (buf);
                display_filename = g_filename_display_name (filename);
                g_set_error (error,
                             G_FILE_ERROR,
                             g_file_error_from_errno (save_errno),
                             _(&quot;Failed to read from file &#39;%s&#39;: %s&quot;),
                             display_filename,
<span class="line-modified">!                g_strerror (save_errno));</span>
                g_free (display_filename);
<span class="line-modified">!           goto error;</span>
              }
          }
        else if (rc == 0)
          break;
        else
<span class="line-new-header">--- 851,22 ---</span>
  
        if (rc &lt; 0)
          {
            if (errno != EINTR)
              {
<span class="line-modified">!         int save_errno = errno;</span>
  
                g_free (buf);
                display_filename = g_filename_display_name (filename);
                g_set_error (error,
                             G_FILE_ERROR,
                             g_file_error_from_errno (save_errno),
                             _(&quot;Failed to read from file &#39;%s&#39;: %s&quot;),
                             display_filename,
<span class="line-modified">!          g_strerror (save_errno));</span>
                g_free (display_filename);
<span class="line-modified">!         goto error;</span>
              }
          }
        else if (rc == 0)
          break;
        else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 911,15 ***</span>
      }
  
    if (stat_buf.st_size &gt; 0 &amp;&amp; S_ISREG (stat_buf.st_mode))
      {
        gboolean retval = get_contents_regfile (filename,
<span class="line-modified">!                           &amp;stat_buf,</span>
<span class="line-modified">!                           fd,</span>
<span class="line-modified">!                           contents,</span>
<span class="line-modified">!                           length,</span>
<span class="line-modified">!                           error);</span>
  
        return retval;
      }
    else
      {
<span class="line-new-header">--- 928,15 ---</span>
      }
  
    if (stat_buf.st_size &gt; 0 &amp;&amp; S_ISREG (stat_buf.st_mode))
      {
        gboolean retval = get_contents_regfile (filename,
<span class="line-modified">!                 &amp;stat_buf,</span>
<span class="line-modified">!                 fd,</span>
<span class="line-modified">!                 contents,</span>
<span class="line-modified">!                 length,</span>
<span class="line-modified">!                 error);</span>
  
        return retval;
      }
    else
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 947,13 ***</span>
  
  #else  /* G_OS_WIN32 */
  
  static gboolean
  get_contents_win32 (const gchar  *filename,
<span class="line-modified">!             gchar       **contents,</span>
<span class="line-modified">!             gsize        *length,</span>
<span class="line-modified">!             GError      **error)</span>
  {
    FILE *f;
    gboolean retval;
  
    f = g_fopen (filename, &quot;rb&quot;);
<span class="line-new-header">--- 964,13 ---</span>
  
  #else  /* G_OS_WIN32 */
  
  static gboolean
  get_contents_win32 (const gchar  *filename,
<span class="line-modified">!         gchar       **contents,</span>
<span class="line-modified">!         gsize        *length,</span>
<span class="line-modified">!         GError      **error)</span>
  {
    FILE *f;
    gboolean retval;
  
    f = g_fopen (filename, &quot;rb&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1017,27 ***</span>
  #endif
  }
  
  static gboolean
  rename_file (const char  *old_name,
<span class="line-modified">!          const char  *new_name,</span>
<span class="line-modified">!          GError     **err)</span>
  {
    errno = 0;
    if (g_rename (old_name, new_name) == -1)
      {
        int save_errno = errno;
        gchar *display_old_name = g_filename_display_name (old_name);
        gchar *display_new_name = g_filename_display_name (new_name);
  
        g_set_error (err,
<span class="line-modified">!            G_FILE_ERROR,</span>
<span class="line-modified">!            g_file_error_from_errno (save_errno),</span>
<span class="line-modified">!            _(&quot;Failed to rename file &#39;%s&#39; to &#39;%s&#39;: g_rename() failed: %s&quot;),</span>
<span class="line-modified">!            display_old_name,</span>
<span class="line-modified">!            display_new_name,</span>
<span class="line-modified">!            g_strerror (save_errno));</span>
  
        g_free (display_old_name);
        g_free (display_new_name);
  
        return FALSE;
<span class="line-new-header">--- 1034,27 ---</span>
  #endif
  }
  
  static gboolean
  rename_file (const char  *old_name,
<span class="line-modified">!        const char  *new_name,</span>
<span class="line-modified">!        GError     **err)</span>
  {
    errno = 0;
    if (g_rename (old_name, new_name) == -1)
      {
        int save_errno = errno;
        gchar *display_old_name = g_filename_display_name (old_name);
        gchar *display_new_name = g_filename_display_name (new_name);
  
        g_set_error (err,
<span class="line-modified">!        G_FILE_ERROR,</span>
<span class="line-modified">!        g_file_error_from_errno (save_errno),</span>
<span class="line-modified">!        _(&quot;Failed to rename file &#39;%s&#39; to &#39;%s&#39;: g_rename() failed: %s&quot;),</span>
<span class="line-modified">!        display_old_name,</span>
<span class="line-modified">!        display_new_name,</span>
<span class="line-modified">!        g_strerror (save_errno));</span>
  
        g_free (display_old_name);
        g_free (display_new_name);
  
        return FALSE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1046,13 ***</span>
    return TRUE;
  }
  
  static gchar *
  write_to_temp_file (const gchar  *contents,
<span class="line-modified">!             gssize        length,</span>
<span class="line-modified">!             const gchar  *dest_file,</span>
<span class="line-modified">!             GError      **err)</span>
  {
    gchar *tmp_name;
    gchar *retval;
    gint fd;
  
<span class="line-new-header">--- 1063,13 ---</span>
    return TRUE;
  }
  
  static gchar *
  write_to_temp_file (const gchar  *contents,
<span class="line-modified">!         gssize        length,</span>
<span class="line-modified">!         const gchar  *dest_file,</span>
<span class="line-modified">!         GError      **err)</span>
  {
    gchar *tmp_name;
    gchar *retval;
    gint fd;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1216,13 ***</span>
   *
   * Since: 2.8
   */
  gboolean
  g_file_set_contents (const gchar  *filename,
<span class="line-modified">!                      const gchar  *contents,</span>
<span class="line-modified">!              gssize    length,</span>
<span class="line-modified">!              GError  **error)</span>
  {
    gchar *tmp_filename;
    gboolean retval;
    GError *rename_error = NULL;
  
<span class="line-new-header">--- 1233,13 ---</span>
   *
   * Since: 2.8
   */
  gboolean
  g_file_set_contents (const gchar  *filename,
<span class="line-modified">!          const gchar  *contents,</span>
<span class="line-modified">!          gssize    length,</span>
<span class="line-modified">!          GError  **error)</span>
  {
    gchar *tmp_filename;
    gboolean retval;
    GError *rename_error = NULL;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1256,37 ***</span>
        /* Renaming failed, but on Windows this may just mean
         * the file already exists. So if the target file
         * exists, try deleting it and do the rename again.
         */
        if (!g_file_test (filename, G_FILE_TEST_EXISTS))
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_unlink (tmp_filename);</span>
<span class="line-modified">!       g_propagate_error (error, rename_error);</span>
<span class="line-modified">!       retval = FALSE;</span>
<span class="line-modified">!       goto out;</span>
<span class="line-modified">!     }</span>
  
        g_error_free (rename_error);
  
        if (g_unlink (filename) == -1)
<span class="line-modified">!     {</span>
            int saved_errno = errno;
            set_file_error (error,
                            filename,
<span class="line-modified">!                   _(&quot;Existing file &#39;%s&#39; could not be removed: g_unlink() failed: %s&quot;),</span>
                            saved_errno);
<span class="line-modified">!       g_unlink (tmp_filename);</span>
<span class="line-modified">!       retval = FALSE;</span>
<span class="line-modified">!       goto out;</span>
<span class="line-modified">!     }</span>
  
        if (!rename_file (tmp_filename, filename, error))
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_unlink (tmp_filename);</span>
<span class="line-modified">!       retval = FALSE;</span>
<span class="line-modified">!       goto out;</span>
<span class="line-modified">!     }</span>
  
  #endif
      }
  
    retval = TRUE;
<span class="line-new-header">--- 1273,37 ---</span>
        /* Renaming failed, but on Windows this may just mean
         * the file already exists. So if the target file
         * exists, try deleting it and do the rename again.
         */
        if (!g_file_test (filename, G_FILE_TEST_EXISTS))
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_unlink (tmp_filename);</span>
<span class="line-modified">!     g_propagate_error (error, rename_error);</span>
<span class="line-modified">!     retval = FALSE;</span>
<span class="line-modified">!     goto out;</span>
<span class="line-modified">!   }</span>
  
        g_error_free (rename_error);
  
        if (g_unlink (filename) == -1)
<span class="line-modified">!   {</span>
            int saved_errno = errno;
            set_file_error (error,
                            filename,
<span class="line-modified">!               _(&quot;Existing file &#39;%s&#39; could not be removed: g_unlink() failed: %s&quot;),</span>
                            saved_errno);
<span class="line-modified">!     g_unlink (tmp_filename);</span>
<span class="line-modified">!     retval = FALSE;</span>
<span class="line-modified">!     goto out;</span>
<span class="line-modified">!   }</span>
  
        if (!rename_file (tmp_filename, filename, error))
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_unlink (tmp_filename);</span>
<span class="line-modified">!     retval = FALSE;</span>
<span class="line-modified">!     goto out;</span>
<span class="line-modified">!   }</span>
  
  #endif
      }
  
    retval = TRUE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1312,11 ***</span>
    int count, fd;
    static const char letters[] =
      &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;;
    static const int NLETTERS = sizeof (letters) - 1;
    glong value;
<span class="line-modified">!   GTimeVal tv;</span>
    static int counter = 0;
  
    g_return_val_if_fail (tmpl != NULL, -1);
  
    /* find the last occurrence of &quot;XXXXXX&quot; */
<span class="line-new-header">--- 1329,11 ---</span>
    int count, fd;
    static const char letters[] =
      &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;;
    static const int NLETTERS = sizeof (letters) - 1;
    glong value;
<span class="line-modified">!   gint64 now_us;</span>
    static int counter = 0;
  
    g_return_val_if_fail (tmpl != NULL, -1);
  
    /* find the last occurrence of &quot;XXXXXX&quot; */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1327,12 ***</span>
        errno = EINVAL;
        return -1;
      }
  
    /* Get some more or less random data.  */
<span class="line-modified">!   g_get_current_time (&amp;tv);</span>
<span class="line-modified">!   value = (tv.tv_usec ^ tv.tv_sec) + counter++;</span>
  
    for (count = 0; count &lt; 100; value += 7777, ++count)
      {
        glong v = value;
  
<span class="line-new-header">--- 1344,12 ---</span>
        errno = EINVAL;
        return -1;
      }
  
    /* Get some more or less random data.  */
<span class="line-modified">!   now_us = g_get_real_time ();</span>
<span class="line-modified">!   value = ((now_us % G_USEC_PER_SEC) ^ (now_us / G_USEC_PER_SEC)) + counter++;</span>
  
    for (count = 0; count &lt; 100; value += 7777, ++count)
      {
        glong v = value;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1691,13 ***</span>
      return fulltemplate;
  }
  
  static gchar *
  g_build_path_va (const gchar  *separator,
<span class="line-modified">!          const gchar  *first_element,</span>
<span class="line-modified">!          va_list      *args,</span>
<span class="line-modified">!          gchar       **str_array)</span>
  {
    GString *result;
    gint separator_len = strlen (separator);
    gboolean is_first = TRUE;
    gboolean have_leading = FALSE;
<span class="line-new-header">--- 1708,13 ---</span>
      return fulltemplate;
  }
  
  static gchar *
  g_build_path_va (const gchar  *separator,
<span class="line-modified">!      const gchar  *first_element,</span>
<span class="line-modified">!      va_list      *args,</span>
<span class="line-modified">!      gchar       **str_array)</span>
  {
    GString *result;
    gint separator_len = strlen (separator);
    gboolean is_first = TRUE;
    gboolean have_leading = FALSE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1718,65 ***</span>
        const gchar *element;
        const gchar *start;
        const gchar *end;
  
        if (next_element)
<span class="line-modified">!     {</span>
<span class="line-modified">!       element = next_element;</span>
<span class="line-modified">!       if (str_array)</span>
<span class="line-modified">!         next_element = str_array[i++];</span>
<span class="line-modified">!       else</span>
<span class="line-modified">!         next_element = va_arg (*args, gchar *);</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     break;</span>
  
        /* Ignore empty elements */
        if (!*element)
<span class="line-modified">!     continue;</span>
  
        start = element;
  
        if (separator_len)
<span class="line-modified">!     {</span>
<span class="line-modified">!       while (strncmp (start, separator, separator_len) == 0)</span>
<span class="line-modified">!         start += separator_len;</span>
          }
  
        end = start + strlen (start);
  
        if (separator_len)
<span class="line-modified">!     {</span>
<span class="line-modified">!       while (end &gt;= start + separator_len &amp;&amp;</span>
<span class="line-modified">!          strncmp (end - separator_len, separator, separator_len) == 0)</span>
<span class="line-modified">!         end -= separator_len;</span>
  
<span class="line-modified">!       last_trailing = end;</span>
<span class="line-modified">!       while (last_trailing &gt;= element + separator_len &amp;&amp;</span>
<span class="line-modified">!          strncmp (last_trailing - separator_len, separator, separator_len) == 0)</span>
<span class="line-modified">!         last_trailing -= separator_len;</span>
  
<span class="line-modified">!       if (!have_leading)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           /* If the leading and trailing separator strings are in the</span>
<span class="line-modified">!            * same element and overlap, the result is exactly that element</span>
<span class="line-modified">!            */</span>
<span class="line-modified">!           if (last_trailing &lt;= start)</span>
<span class="line-modified">!         single_element = element;</span>
<span class="line-modified">! </span>
<span class="line-modified">!           g_string_append_len (result, element, start - element);</span>
<span class="line-modified">!           have_leading = TRUE;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       else</span>
<span class="line-modified">!         single_element = NULL;</span>
<span class="line-modified">!     }</span>
  
        if (end == start)
<span class="line-modified">!     continue;</span>
  
        if (!is_first)
<span class="line-modified">!     g_string_append (result, separator);</span>
  
        g_string_append_len (result, start, end - start);
        is_first = FALSE;
      }
  
<span class="line-new-header">--- 1735,65 ---</span>
        const gchar *element;
        const gchar *start;
        const gchar *end;
  
        if (next_element)
<span class="line-modified">!   {</span>
<span class="line-modified">!     element = next_element;</span>
<span class="line-modified">!     if (str_array)</span>
<span class="line-modified">!       next_element = str_array[i++];</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       next_element = va_arg (*args, gchar *);</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   break;</span>
  
        /* Ignore empty elements */
        if (!*element)
<span class="line-modified">!   continue;</span>
  
        start = element;
  
        if (separator_len)
<span class="line-modified">!   {</span>
<span class="line-modified">!     while (strncmp (start, separator, separator_len) == 0)</span>
<span class="line-modified">!       start += separator_len;</span>
          }
  
        end = start + strlen (start);
  
        if (separator_len)
<span class="line-modified">!   {</span>
<span class="line-modified">!     while (end &gt;= start + separator_len &amp;&amp;</span>
<span class="line-modified">!      strncmp (end - separator_len, separator, separator_len) == 0)</span>
<span class="line-modified">!       end -= separator_len;</span>
  
<span class="line-modified">!     last_trailing = end;</span>
<span class="line-modified">!     while (last_trailing &gt;= element + separator_len &amp;&amp;</span>
<span class="line-modified">!      strncmp (last_trailing - separator_len, separator, separator_len) == 0)</span>
<span class="line-modified">!       last_trailing -= separator_len;</span>
  
<span class="line-modified">!     if (!have_leading)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         /* If the leading and trailing separator strings are in the</span>
<span class="line-modified">!          * same element and overlap, the result is exactly that element</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         if (last_trailing &lt;= start)</span>
<span class="line-modified">!     single_element = element;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         g_string_append_len (result, element, start - element);</span>
<span class="line-modified">!         have_leading = TRUE;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       single_element = NULL;</span>
<span class="line-modified">!   }</span>
  
        if (end == start)
<span class="line-modified">!   continue;</span>
  
        if (!is_first)
<span class="line-modified">!   g_string_append (result, separator);</span>
  
        g_string_append_len (result, start, end - start);
        is_first = FALSE;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1786,11 ***</span>
        return g_strdup (single_element);
      }
    else
      {
        if (last_trailing)
<span class="line-modified">!     g_string_append (result, last_trailing);</span>
  
        return g_string_free (result, FALSE);
      }
  }
  
<span class="line-new-header">--- 1803,11 ---</span>
        return g_strdup (single_element);
      }
    else
      {
        if (last_trailing)
<span class="line-modified">!   g_string_append (result, last_trailing);</span>
  
        return g_string_free (result, FALSE);
      }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1809,11 ***</span>
   *
   * Since: 2.8
   */
  gchar *
  g_build_pathv (const gchar  *separator,
<span class="line-modified">!            gchar       **args)</span>
  {
    if (!args)
      return NULL;
  
    return g_build_path_va (separator, NULL, NULL, args);
<span class="line-new-header">--- 1826,11 ---</span>
   *
   * Since: 2.8
   */
  gchar *
  g_build_pathv (const gchar  *separator,
<span class="line-modified">!          gchar       **args)</span>
  {
    if (!args)
      return NULL;
  
    return g_build_path_va (separator, NULL, NULL, args);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1856,12 ***</span>
   * Returns: (type filename): a newly-allocated string that must be freed with
   *     g_free().
   **/
  gchar *
  g_build_path (const gchar *separator,
<span class="line-modified">!           const gchar *first_element,</span>
<span class="line-modified">!           ...)</span>
  {
    gchar *str;
    va_list args;
  
    g_return_val_if_fail (separator != NULL, NULL);
<span class="line-new-header">--- 1873,12 ---</span>
   * Returns: (type filename): a newly-allocated string that must be freed with
   *     g_free().
   **/
  gchar *
  g_build_path (const gchar *separator,
<span class="line-modified">!         const gchar *first_element,</span>
<span class="line-modified">!         ...)</span>
  {
    gchar *str;
    va_list args;
  
    g_return_val_if_fail (separator != NULL, NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1875,12 ***</span>
  
  #ifdef G_OS_WIN32
  
  static gchar *
  g_build_pathname_va (const gchar  *first_element,
<span class="line-modified">!              va_list      *args,</span>
<span class="line-modified">!              gchar       **str_array)</span>
  {
    /* Code copied from g_build_pathv(), and modified to use two
     * alternative single-character separators.
     */
    GString *result;
<span class="line-new-header">--- 1892,12 ---</span>
  
  #ifdef G_OS_WIN32
  
  static gchar *
  g_build_pathname_va (const gchar  *first_element,
<span class="line-modified">!          va_list      *args,</span>
<span class="line-modified">!          gchar       **str_array)</span>
  {
    /* Code copied from g_build_pathv(), and modified to use two
     * alternative single-character separators.
     */
    GString *result;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1904,72 ***</span>
        const gchar *element;
        const gchar *start;
        const gchar *end;
  
        if (next_element)
<span class="line-modified">!     {</span>
<span class="line-modified">!       element = next_element;</span>
<span class="line-modified">!       if (str_array)</span>
<span class="line-modified">!         next_element = str_array[i++];</span>
<span class="line-modified">!       else</span>
<span class="line-modified">!         next_element = va_arg (*args, gchar *);</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     break;</span>
  
        /* Ignore empty elements */
        if (!*element)
<span class="line-modified">!     continue;</span>
  
        start = element;
  
        if (TRUE)
<span class="line-modified">!     {</span>
<span class="line-modified">!       while (start &amp;&amp;</span>
<span class="line-modified">!          (*start == &#39;\\&#39; || *start == &#39;/&#39;))</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           current_separator = *start;</span>
<span class="line-modified">!           start++;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
  
        end = start + strlen (start);
  
        if (TRUE)
<span class="line-modified">!     {</span>
<span class="line-modified">!       while (end &gt;= start + 1 &amp;&amp;</span>
<span class="line-modified">!          (end[-1] == &#39;\\&#39; || end[-1] == &#39;/&#39;))</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           current_separator = end[-1];</span>
<span class="line-modified">!           end--;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!       last_trailing = end;</span>
<span class="line-modified">!       while (last_trailing &gt;= element + 1 &amp;&amp;</span>
<span class="line-modified">!          (last_trailing[-1] == &#39;\\&#39; || last_trailing[-1] == &#39;/&#39;))</span>
<span class="line-modified">!         last_trailing--;</span>
  
<span class="line-modified">!       if (!have_leading)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           /* If the leading and trailing separator strings are in the</span>
<span class="line-modified">!            * same element and overlap, the result is exactly that element</span>
<span class="line-modified">!            */</span>
<span class="line-modified">!           if (last_trailing &lt;= start)</span>
<span class="line-modified">!         single_element = element;</span>
<span class="line-modified">! </span>
<span class="line-modified">!           g_string_append_len (result, element, start - element);</span>
<span class="line-modified">!           have_leading = TRUE;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       else</span>
<span class="line-modified">!         single_element = NULL;</span>
<span class="line-modified">!     }</span>
  
        if (end == start)
<span class="line-modified">!     continue;</span>
  
        if (!is_first)
<span class="line-modified">!     g_string_append_len (result, &amp;current_separator, 1);</span>
  
        g_string_append_len (result, start, end - start);
        is_first = FALSE;
      }
  
<span class="line-new-header">--- 1921,72 ---</span>
        const gchar *element;
        const gchar *start;
        const gchar *end;
  
        if (next_element)
<span class="line-modified">!   {</span>
<span class="line-modified">!     element = next_element;</span>
<span class="line-modified">!     if (str_array)</span>
<span class="line-modified">!       next_element = str_array[i++];</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       next_element = va_arg (*args, gchar *);</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   break;</span>
  
        /* Ignore empty elements */
        if (!*element)
<span class="line-modified">!   continue;</span>
  
        start = element;
  
        if (TRUE)
<span class="line-modified">!   {</span>
<span class="line-modified">!     while (start &amp;&amp;</span>
<span class="line-modified">!      (*start == &#39;\\&#39; || *start == &#39;/&#39;))</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         current_separator = *start;</span>
<span class="line-modified">!         start++;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!   }</span>
  
        end = start + strlen (start);
  
        if (TRUE)
<span class="line-modified">!   {</span>
<span class="line-modified">!     while (end &gt;= start + 1 &amp;&amp;</span>
<span class="line-modified">!      (end[-1] == &#39;\\&#39; || end[-1] == &#39;/&#39;))</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         current_separator = end[-1];</span>
<span class="line-modified">!         end--;</span>
<span class="line-modified">!       }</span>
  
<span class="line-modified">!     last_trailing = end;</span>
<span class="line-modified">!     while (last_trailing &gt;= element + 1 &amp;&amp;</span>
<span class="line-modified">!      (last_trailing[-1] == &#39;\\&#39; || last_trailing[-1] == &#39;/&#39;))</span>
<span class="line-modified">!       last_trailing--;</span>
  
<span class="line-modified">!     if (!have_leading)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         /* If the leading and trailing separator strings are in the</span>
<span class="line-modified">!          * same element and overlap, the result is exactly that element</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         if (last_trailing &lt;= start)</span>
<span class="line-modified">!     single_element = element;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         g_string_append_len (result, element, start - element);</span>
<span class="line-modified">!         have_leading = TRUE;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       single_element = NULL;</span>
<span class="line-modified">!   }</span>
  
        if (end == start)
<span class="line-modified">!   continue;</span>
  
        if (!is_first)
<span class="line-modified">!   g_string_append_len (result, &amp;current_separator, 1);</span>
  
        g_string_append_len (result, start, end - start);
        is_first = FALSE;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1979,11 ***</span>
        return g_strdup (single_element);
      }
    else
      {
        if (last_trailing)
<span class="line-modified">!     g_string_append (result, last_trailing);</span>
  
        return g_string_free (result, FALSE);
      }
  }
  
<span class="line-new-header">--- 1996,11 ---</span>
        return g_strdup (single_element);
      }
    else
      {
        if (last_trailing)
<span class="line-modified">!   g_string_append (result, last_trailing);</span>
  
        return g_string_free (result, FALSE);
      }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2071,11 ***</span>
   * Returns: (type filename): a newly-allocated string that must be freed with
   *     g_free().
   **/
  gchar *
  g_build_filename (const gchar *first_element,
<span class="line-modified">!           ...)</span>
  {
    gchar *str;
    va_list args;
  
    va_start (args, first_element);
<span class="line-new-header">--- 2088,11 ---</span>
   * Returns: (type filename): a newly-allocated string that must be freed with
   *     g_free().
   **/
  gchar *
  g_build_filename (const gchar *first_element,
<span class="line-modified">!       ...)</span>
  {
    gchar *str;
    va_list args;
  
    va_start (args, first_element);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2099,13 ***</span>
   *
   * Since: 2.4
   */
  gchar *
  g_file_read_link (const gchar  *filename,
<span class="line-modified">!               GError      **error)</span>
  {
<span class="line-modified">! #if defined (HAVE_READLINK) || defined (G_OS_WIN32)</span>
    gchar *buffer;
    size_t size;
    gssize read_size;
  
    g_return_val_if_fail (filename != NULL, NULL);
<span class="line-new-header">--- 2116,13 ---</span>
   *
   * Since: 2.4
   */
  gchar *
  g_file_read_link (const gchar  *filename,
<span class="line-modified">!             GError      **error)</span>
  {
<span class="line-modified">! #if defined (HAVE_READLINK)</span>
    gchar *buffer;
    size_t size;
    gssize read_size;
  
    g_return_val_if_fail (filename != NULL, NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2114,15 ***</span>
    size = 256;
    buffer = g_malloc (size);
  
    while (TRUE)
      {
<span class="line-removed">- #ifndef G_OS_WIN32</span>
        read_size = readlink (filename, buffer, size);
<span class="line-removed">- #else</span>
<span class="line-removed">-       read_size = g_win32_readlink_utf8 (filename, buffer, size);</span>
<span class="line-removed">- #endif</span>
        if (read_size &lt; 0)
          {
            int saved_errno = errno;
            set_file_error (error,
                            filename,
<span class="line-new-header">--- 2131,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2139,10 ***</span>
<span class="line-new-header">--- 2152,31 ---</span>
          }
  
        size *= 2;
        buffer = g_realloc (buffer, size);
      }
<span class="line-added">+ #elif defined (G_OS_WIN32)</span>
<span class="line-added">+   gchar *buffer;</span>
<span class="line-added">+   gssize read_size;</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_return_val_if_fail (filename != NULL, NULL);</span>
<span class="line-added">+   g_return_val_if_fail (error == NULL || *error == NULL, NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   read_size = g_win32_readlink_utf8 (filename, NULL, 0, &amp;buffer, TRUE);</span>
<span class="line-added">+   if (read_size &lt; 0)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       int saved_errno = errno;</span>
<span class="line-added">+       set_file_error (error,</span>
<span class="line-added">+                       filename,</span>
<span class="line-added">+                       _(&quot;Failed to read the symbolic link &#39;%s&#39;: %s&quot;),</span>
<span class="line-added">+                       saved_errno);</span>
<span class="line-added">+       return NULL;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   else if (read_size == 0)</span>
<span class="line-added">+     return strdup (&quot;&quot;);</span>
<span class="line-added">+   else</span>
<span class="line-added">+     return buffer;</span>
  #else
    g_return_val_if_fail (filename != NULL, NULL);
    g_return_val_if_fail (error == NULL || *error == NULL, NULL);
  
    g_set_error_literal (error,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2398,11 ***</span>
  
  /**
   * g_path_get_dirname:
   * @file_name: (type filename): the name of the file
   *
<span class="line-modified">!  * Gets the directory components of a file name.</span>
   *
   * If the file name has no directory components &quot;.&quot; is returned.
   * The returned string should be freed when no longer needed.
   *
   * Returns: (type filename): the directory components of the file
<span class="line-new-header">--- 2432,13 ---</span>
  
  /**
   * g_path_get_dirname:
   * @file_name: (type filename): the name of the file
   *
<span class="line-modified">!  * Gets the directory components of a file name. For example, the directory</span>
<span class="line-added">+  * component of `/usr/bin/test` is `/usr/bin`. The directory component of `/`</span>
<span class="line-added">+  * is `/`.</span>
   *
   * If the file name has no directory components &quot;.&quot; is returned.
   * The returned string should be freed when no longer needed.
   *
   * Returns: (type filename): the directory components of the file
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2748,20 ***</span>
  _GLIB_EXTERN gchar   *g_get_current_dir_utf8   (void);
  
  
  gboolean
  g_file_test_utf8 (const gchar *filename,
<span class="line-modified">!              GFileTest    test)</span>
  {
    return g_file_test (filename, test);
  }
  
  gboolean
  g_file_get_contents_utf8 (const gchar  *filename,
<span class="line-modified">!                      gchar       **contents,</span>
<span class="line-modified">!                      gsize        *length,</span>
<span class="line-modified">!                      GError      **error)</span>
  {
    return g_file_get_contents (filename, contents, length, error);
  }
  
  gint
<span class="line-new-header">--- 2784,20 ---</span>
  _GLIB_EXTERN gchar   *g_get_current_dir_utf8   (void);
  
  
  gboolean
  g_file_test_utf8 (const gchar *filename,
<span class="line-modified">!                   GFileTest    test)</span>
  {
    return g_file_test (filename, test);
  }
  
  gboolean
  g_file_get_contents_utf8 (const gchar  *filename,
<span class="line-modified">!                           gchar       **contents,</span>
<span class="line-modified">!                           gsize        *length,</span>
<span class="line-modified">!                           GError      **error)</span>
  {
    return g_file_get_contents (filename, contents, length, error);
  }
  
  gint
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2770,12 ***</span>
    return g_mkstemp (tmpl);
  }
  
  gint
  g_file_open_tmp_utf8 (const gchar  *tmpl,
<span class="line-modified">!          gchar       **name_used,</span>
<span class="line-modified">!          GError      **error)</span>
  {
    return g_file_open_tmp (tmpl, name_used, error);
  }
  
  gchar *
<span class="line-new-header">--- 2806,12 ---</span>
    return g_mkstemp (tmpl);
  }
  
  gint
  g_file_open_tmp_utf8 (const gchar  *tmpl,
<span class="line-modified">!                       gchar       **name_used,</span>
<span class="line-modified">!                       GError      **error)</span>
  {
    return g_file_open_tmp (tmpl, name_used, error);
  }
  
  gchar *
</pre>
<center><a href="gerror.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gfileutils.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>