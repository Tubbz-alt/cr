<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstevent.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wim.taymans@chello.be&gt;
   4  *                    2005 Wim Taymans &lt;wim@fluendo.com&gt;
   5  *
   6  * gstevent.c: GstEvent subsystem
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public
  19  * License along with this library; if not, write to the
  20  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 /**
  25  * SECTION:gstevent
  26  * @title: GstEvent
  27  * @short_description: Structure describing events that are passed up and down
  28  *                     a pipeline
  29  * @see_also: #GstPad, #GstElement
  30  *
  31  * The event class provides factory methods to construct events for sending
  32  * and functions to query (parse) received events.
  33  *
  34  * Events are usually created with gst_event_new_*() which takes event-type
  35  * specific parameters as arguments.
  36  * To send an event application will usually use gst_element_send_event() and
  37  * elements will use gst_pad_send_event() or gst_pad_push_event().
  38  * The event should be unreffed with gst_event_unref() if it has not been sent.
  39  *
  40  * Events that have been received can be parsed with their respective
  41  * gst_event_parse_*() functions. It is valid to pass %NULL for unwanted details.
  42  *
  43  * Events are passed between elements in parallel to the data stream. Some events
  44  * are serialized with buffers, others are not. Some events only travel downstream,
  45  * others only upstream. Some events can travel both upstream and downstream.
  46  *
  47  * The events are used to signal special conditions in the datastream such as
  48  * EOS (end of stream) or the start of a new stream-segment.
  49  * Events are also used to flush the pipeline of any pending data.
  50  *
  51  * Most of the event API is used inside plugins. Applications usually only
  52  * construct and use seek events.
  53  * To do that gst_event_new_seek() is used to create a seek event. It takes
  54  * the needed parameters to specify seeking time and mode.
  55  * |[&lt;!-- language=&quot;C&quot; --&gt;
  56  *   GstEvent *event;
  57  *   gboolean result;
  58  *   ...
  59  *   // construct a seek event to play the media from second 2 to 5, flush
  60  *   // the pipeline to decrease latency.
  61  *   event = gst_event_new_seek (1.0,
  62  *      GST_FORMAT_TIME,
  63  *      GST_SEEK_FLAG_FLUSH,
  64  *      GST_SEEK_TYPE_SET, 2 * GST_SECOND,
  65  *      GST_SEEK_TYPE_SET, 5 * GST_SECOND);
  66  *   ...
  67  *   result = gst_element_send_event (pipeline, event);
  68  *   if (!result)
  69  *     g_warning (&quot;seek failed&quot;);
  70  *   ...
  71  * ]|
  72  */
  73 
  74 
  75 #include &quot;gst_private.h&quot;
  76 #include &lt;string.h&gt;             /* memcpy */
  77 
  78 #include &quot;gstinfo.h&quot;
  79 #include &quot;gstevent.h&quot;
  80 #include &quot;gstenumtypes.h&quot;
  81 #include &quot;gstutils.h&quot;
  82 #include &quot;gstquark.h&quot;
  83 #include &quot;gstvalue.h&quot;
  84 
  85 GType _gst_event_type = 0;
  86 
  87 typedef struct
  88 {
  89   GstEvent event;
  90 
  91   GstStructure *structure;
  92   gint64 running_time_offset;
  93 } GstEventImpl;
  94 
  95 #define GST_EVENT_STRUCTURE(e)  (((GstEventImpl *)(e))-&gt;structure)
  96 
  97 typedef struct
  98 {
  99   const gint type;
 100   const gchar *name;
 101   GQuark quark;
 102 } GstEventQuarks;
 103 
 104 static GstEventQuarks event_quarks[] = {
 105   {GST_EVENT_UNKNOWN, &quot;unknown&quot;, 0},
 106   {GST_EVENT_FLUSH_START, &quot;flush-start&quot;, 0},
 107   {GST_EVENT_FLUSH_STOP, &quot;flush-stop&quot;, 0},
 108   {GST_EVENT_SELECT_STREAMS, &quot;select-streams&quot;, 0},
 109   {GST_EVENT_STREAM_START, &quot;stream-start&quot;, 0},
 110   {GST_EVENT_STREAM_COLLECTION, &quot;stream-collection&quot;, 0},
 111   {GST_EVENT_CAPS, &quot;caps&quot;, 0},
 112   {GST_EVENT_SEGMENT, &quot;segment&quot;, 0},
 113   {GST_EVENT_TAG, &quot;tag&quot;, 0},
 114   {GST_EVENT_TOC, &quot;toc&quot;, 0},
 115   {GST_EVENT_PROTECTION, &quot;protection&quot;, 0},
 116   {GST_EVENT_BUFFERSIZE, &quot;buffersize&quot;, 0},
 117   {GST_EVENT_SINK_MESSAGE, &quot;sink-message&quot;, 0},
 118   {GST_EVENT_EOS, &quot;eos&quot;, 0},
 119   {GST_EVENT_SEGMENT_DONE, &quot;segment-done&quot;, 0},
 120   {GST_EVENT_GAP, &quot;gap&quot;, 0},
 121   {GST_EVENT_QOS, &quot;qos&quot;, 0},
 122   {GST_EVENT_SEEK, &quot;seek&quot;, 0},
 123   {GST_EVENT_NAVIGATION, &quot;navigation&quot;, 0},
 124   {GST_EVENT_LATENCY, &quot;latency&quot;, 0},
 125   {GST_EVENT_STEP, &quot;step&quot;, 0},
 126   {GST_EVENT_RECONFIGURE, &quot;reconfigure&quot;, 0},
 127   {GST_EVENT_TOC_SELECT, &quot;toc-select&quot;, 0},
 128   {GST_EVENT_CUSTOM_UPSTREAM, &quot;custom-upstream&quot;, 0},
 129   {GST_EVENT_CUSTOM_DOWNSTREAM, &quot;custom-downstream&quot;, 0},
 130   {GST_EVENT_CUSTOM_DOWNSTREAM_OOB, &quot;custom-downstream-oob&quot;, 0},
 131   {GST_EVENT_CUSTOM_DOWNSTREAM_STICKY, &quot;custom-downstream-sticky&quot;, 0},
 132   {GST_EVENT_CUSTOM_BOTH, &quot;custom-both&quot;, 0},
 133   {GST_EVENT_CUSTOM_BOTH_OOB, &quot;custom-both-oob&quot;, 0},
 134   {GST_EVENT_STREAM_GROUP_DONE, &quot;stream-group-done&quot;, 0},
 135 
 136   {0, NULL, 0}
 137 };
 138 
 139 GST_DEFINE_MINI_OBJECT_TYPE (GstEvent, gst_event);
 140 
 141 void
 142 _priv_gst_event_initialize (void)
 143 {
 144   gint i;
 145 
 146   _gst_event_type = gst_event_get_type ();
 147 
 148   g_type_class_ref (gst_seek_flags_get_type ());
 149   g_type_class_ref (gst_seek_type_get_type ());
 150 
 151   for (i = 0; event_quarks[i].name; i++) {
 152     event_quarks[i].quark = g_quark_from_static_string (event_quarks[i].name);
 153   }
 154 }
 155 
 156 /**
 157  * gst_event_type_get_name:
 158  * @type: the event type
 159  *
 160  * Get a printable name for the given event type. Do not modify or free.
 161  *
 162  * Returns: a reference to the static name of the event.
 163  */
 164 const gchar *
 165 gst_event_type_get_name (GstEventType type)
 166 {
 167   gint i;
 168 
 169   for (i = 0; event_quarks[i].name; i++) {
 170     if (type == event_quarks[i].type)
 171       return event_quarks[i].name;
 172   }
 173   return &quot;unknown&quot;;
 174 }
 175 
 176 /**
 177  * gst_event_type_to_quark:
 178  * @type: the event type
 179  *
 180  * Get the unique quark for the given event type.
 181  *
 182  * Returns: the quark associated with the event type
 183  */
 184 GQuark
 185 gst_event_type_to_quark (GstEventType type)
 186 {
 187   gint i;
 188 
 189   for (i = 0; event_quarks[i].name; i++) {
 190     if (type == event_quarks[i].type)
 191       return event_quarks[i].quark;
 192   }
 193   return 0;
 194 }
 195 
 196 /**
 197  * gst_event_type_get_flags:
 198  * @type: a #GstEventType
 199  *
 200  * Gets the #GstEventTypeFlags associated with @type.
 201  *
 202  * Returns: a #GstEventTypeFlags.
 203  */
 204 GstEventTypeFlags
 205 gst_event_type_get_flags (GstEventType type)
 206 {
 207   GstEventTypeFlags ret;
 208 
 209   ret = type &amp; ((1 &lt;&lt; GST_EVENT_NUM_SHIFT) - 1);
 210 
 211   return ret;
 212 }
 213 
 214 static void
 215 _gst_event_free (GstEvent * event)
 216 {
 217   GstStructure *s;
 218 
 219   g_return_if_fail (event != NULL);
 220   g_return_if_fail (GST_IS_EVENT (event));
 221 
 222   GST_CAT_LOG (GST_CAT_EVENT, &quot;freeing event %p type %s&quot;, event,
 223       GST_EVENT_TYPE_NAME (event));
 224 
 225   s = GST_EVENT_STRUCTURE (event);
 226 
 227   if (s) {
 228     gst_structure_set_parent_refcount (s, NULL);
 229     gst_structure_free (s);
 230   }
<a name="1" id="anc1"></a><span class="line-added"> 231 #ifdef USE_POISONING</span>
<span class="line-added"> 232   memset (event, 0xff, sizeof (GstEventImpl));</span>
<span class="line-added"> 233 #endif</span>
 234 
 235   g_slice_free1 (sizeof (GstEventImpl), event);
 236 }
 237 
 238 static void gst_event_init (GstEventImpl * event, GstEventType type);
 239 
 240 static GstEvent *
 241 _gst_event_copy (GstEvent * event)
 242 {
 243   GstEventImpl *copy;
 244   GstStructure *s;
 245 
 246   copy = g_slice_new0 (GstEventImpl);
 247 
 248   gst_event_init (copy, GST_EVENT_TYPE (event));
 249 
 250   GST_EVENT_TIMESTAMP (copy) = GST_EVENT_TIMESTAMP (event);
 251   GST_EVENT_SEQNUM (copy) = GST_EVENT_SEQNUM (event);
 252 
 253   s = GST_EVENT_STRUCTURE (event);
 254   if (s) {
 255     GST_EVENT_STRUCTURE (copy) = gst_structure_copy (s);
 256     gst_structure_set_parent_refcount (GST_EVENT_STRUCTURE (copy),
 257         &amp;copy-&gt;event.mini_object.refcount);
 258   } else {
 259     GST_EVENT_STRUCTURE (copy) = NULL;
 260   }
 261 
 262   ((GstEventImpl *) copy)-&gt;running_time_offset =
 263       ((GstEventImpl *) event)-&gt;running_time_offset;
 264 
 265   return GST_EVENT_CAST (copy);
 266 }
 267 
 268 static void
 269 gst_event_init (GstEventImpl * event, GstEventType type)
 270 {
 271   gst_mini_object_init (GST_MINI_OBJECT_CAST (event), 0, _gst_event_type,
 272       (GstMiniObjectCopyFunction) _gst_event_copy, NULL,
 273       (GstMiniObjectFreeFunction) _gst_event_free);
 274 
 275   GST_EVENT_TYPE (event) = type;
 276   GST_EVENT_TIMESTAMP (event) = GST_CLOCK_TIME_NONE;
 277   GST_EVENT_SEQNUM (event) = gst_util_seqnum_next ();
 278   event-&gt;running_time_offset = 0;
 279 }
 280 
 281 
 282 /**
 283  * gst_event_new_custom:
 284  * @type: The type of the new event
 285  * @structure: (transfer full): the structure for the event. The event will
 286  *     take ownership of the structure.
 287  *
 288  * Create a new custom-typed event. This can be used for anything not
 289  * handled by other event-specific functions to pass an event to another
 290  * element.
 291  *
 292  * Make sure to allocate an event type with the #GST_EVENT_MAKE_TYPE macro,
 293  * assigning a free number and filling in the correct direction and
 294  * serialization flags.
 295  *
 296  * New custom events can also be created by subclassing the event type if
 297  * needed.
 298  *
 299  * Returns: (transfer full) (nullable): the new custom event.
 300  */
 301 GstEvent *
 302 gst_event_new_custom (GstEventType type, GstStructure * structure)
 303 {
 304   GstEventImpl *event;
 305 
 306   event = g_slice_new0 (GstEventImpl);
 307 
 308   GST_CAT_DEBUG (GST_CAT_EVENT, &quot;creating new event %p %s %d&quot;, event,
 309       gst_event_type_get_name (type), type);
 310 
 311   if (structure) {
 312     /* structure must not have a parent */
 313     if (!gst_structure_set_parent_refcount (structure,
 314             &amp;event-&gt;event.mini_object.refcount))
 315       goto had_parent;
 316 
 317   }
 318   gst_event_init (event, type);
 319 
 320   GST_EVENT_STRUCTURE (event) = structure;
 321 
 322   return GST_EVENT_CAST (event);
 323 
 324   /* ERRORS */
 325 had_parent:
 326   {
 327     g_slice_free1 (sizeof (GstEventImpl), event);
 328     g_warning (&quot;structure is already owned by another object&quot;);
 329     return NULL;
 330   }
 331 }
 332 
 333 /**
 334  * gst_event_get_structure:
 335  * @event: The #GstEvent.
 336  *
 337  * Access the structure of the event.
 338  *
 339  * Returns: (transfer none) (nullable): The structure of the event. The
 340  * structure is still owned by the event, which means that you should not free
 341  * it and that the pointer becomes invalid when you free the event.
 342  *
 343  * MT safe.
 344  */
 345 const GstStructure *
 346 gst_event_get_structure (GstEvent * event)
 347 {
 348   g_return_val_if_fail (GST_IS_EVENT (event), NULL);
 349 
 350   return GST_EVENT_STRUCTURE (event);
 351 }
 352 
 353 /**
 354  * gst_event_writable_structure:
 355  * @event: The #GstEvent.
 356  *
 357  * Get a writable version of the structure.
 358  *
 359  * Returns: (transfer none): The structure of the event. The structure
 360  * is still owned by the event, which means that you should not free
 361  * it and that the pointer becomes invalid when you free the event.
 362  * This function checks if @event is writable and will never return
 363  * %NULL.
 364  *
 365  * MT safe.
 366  */
 367 GstStructure *
 368 gst_event_writable_structure (GstEvent * event)
 369 {
 370   GstStructure *structure;
 371 
 372   g_return_val_if_fail (GST_IS_EVENT (event), NULL);
 373   g_return_val_if_fail (gst_event_is_writable (event), NULL);
 374 
 375   structure = GST_EVENT_STRUCTURE (event);
 376 
 377   if (structure == NULL) {
 378     structure =
 379         gst_structure_new_id_empty (gst_event_type_to_quark (GST_EVENT_TYPE
 380             (event)));
 381     gst_structure_set_parent_refcount (structure, &amp;event-&gt;mini_object.refcount);
 382     GST_EVENT_STRUCTURE (event) = structure;
 383   }
 384   return structure;
 385 }
 386 
 387 /**
 388  * gst_event_has_name:
 389  * @event: The #GstEvent.
 390  * @name: name to check
 391  *
 392  * Checks if @event has the given @name. This function is usually used to
 393  * check the name of a custom event.
 394  *
 395  * Returns: %TRUE if @name matches the name of the event structure.
 396  */
 397 gboolean
 398 gst_event_has_name (GstEvent * event, const gchar * name)
 399 {
 400   g_return_val_if_fail (GST_IS_EVENT (event), FALSE);
 401 
 402   if (GST_EVENT_STRUCTURE (event) == NULL)
 403     return FALSE;
 404 
 405   return gst_structure_has_name (GST_EVENT_STRUCTURE (event), name);
 406 }
 407 
 408 /**
 409  * gst_event_get_seqnum:
 410  * @event: A #GstEvent.
 411  *
 412  * Retrieve the sequence number of a event.
 413  *
 414  * Events have ever-incrementing sequence numbers, which may also be set
 415  * explicitly via gst_event_set_seqnum(). Sequence numbers are typically used to
 416  * indicate that a event corresponds to some other set of events or messages,
 417  * for example an EOS event corresponding to a SEEK event. It is considered good
 418  * practice to make this correspondence when possible, though it is not
 419  * required.
 420  *
 421  * Note that events and messages share the same sequence number incrementor;
 422  * two events or messages will never have the same sequence number unless
 423  * that correspondence was made explicitly.
 424  *
 425  * Returns: The event&#39;s sequence number.
 426  *
 427  * MT safe.
 428  */
 429 guint32
 430 gst_event_get_seqnum (GstEvent * event)
 431 {
 432   g_return_val_if_fail (GST_IS_EVENT (event), -1);
 433 
 434   return GST_EVENT_SEQNUM (event);
 435 }
 436 
 437 /**
 438  * gst_event_set_seqnum:
 439  * @event: A #GstEvent.
 440  * @seqnum: A sequence number.
 441  *
 442  * Set the sequence number of a event.
 443  *
 444  * This function might be called by the creator of a event to indicate that the
 445  * event relates to other events or messages. See gst_event_get_seqnum() for
 446  * more information.
 447  *
 448  * MT safe.
 449  */
 450 void
 451 gst_event_set_seqnum (GstEvent * event, guint32 seqnum)
 452 {
 453   g_return_if_fail (GST_IS_EVENT (event));
<a name="2" id="anc2"></a><span class="line-added"> 454   g_return_if_fail (seqnum != GST_SEQNUM_INVALID);</span>
<span class="line-added"> 455   g_return_if_fail (gst_event_is_writable (event));</span>
 456 
 457   GST_EVENT_SEQNUM (event) = seqnum;
 458 }
 459 
 460 /**
 461  * gst_event_get_running_time_offset:
 462  * @event: A #GstEvent.
 463  *
 464  * Retrieve the accumulated running time offset of the event.
 465  *
 466  * Events passing through #GstPads that have a running time
 467  * offset set via gst_pad_set_offset() will get their offset
 468  * adjusted according to the pad&#39;s offset.
 469  *
 470  * If the event contains any information that related to the
 471  * running time, this information will need to be updated
 472  * before usage with this offset.
 473  *
 474  * Returns: The event&#39;s running time offset
 475  *
 476  * MT safe.
 477  *
 478  * Since: 1.4
 479  */
 480 gint64
 481 gst_event_get_running_time_offset (GstEvent * event)
 482 {
 483   g_return_val_if_fail (GST_IS_EVENT (event), 0);
 484 
 485   return ((GstEventImpl *) event)-&gt;running_time_offset;
 486 }
 487 
 488 /**
 489  * gst_event_set_running_time_offset:
 490  * @event: A #GstEvent.
 491  * @offset: A the new running time offset
 492  *
 493  * Set the running time offset of a event. See
 494  * gst_event_get_running_time_offset() for more information.
 495  *
 496  * MT safe.
 497  *
 498  * Since: 1.4
 499  */
 500 void
 501 gst_event_set_running_time_offset (GstEvent * event, gint64 offset)
 502 {
 503   g_return_if_fail (GST_IS_EVENT (event));
<a name="3" id="anc3"></a><span class="line-added"> 504   g_return_if_fail (gst_event_is_writable (event));</span>
 505 
 506   ((GstEventImpl *) event)-&gt;running_time_offset = offset;
 507 }
 508 
 509 /**
 510  * gst_event_new_flush_start:
 511  *
 512  * Allocate a new flush start event. The flush start event can be sent
 513  * upstream and downstream and travels out-of-bounds with the dataflow.
 514  *
 515  * It marks pads as being flushing and will make them return
 516  * #GST_FLOW_FLUSHING when used for data flow with gst_pad_push(),
 517  * gst_pad_chain(), gst_pad_get_range() and gst_pad_pull_range().
 518  * Any event (except a #GST_EVENT_FLUSH_STOP) received
 519  * on a flushing pad will return %FALSE immediately.
 520  *
 521  * Elements should unlock any blocking functions and exit their streaming
 522  * functions as fast as possible when this event is received.
 523  *
 524  * This event is typically generated after a seek to flush out all queued data
 525  * in the pipeline so that the new media is played as soon as possible.
 526  *
 527  * Returns: (transfer full): a new flush start event.
 528  */
 529 GstEvent *
 530 gst_event_new_flush_start (void)
 531 {
 532   return gst_event_new_custom (GST_EVENT_FLUSH_START, NULL);
 533 }
 534 
 535 /**
 536  * gst_event_new_flush_stop:
 537  * @reset_time: if time should be reset
 538  *
 539  * Allocate a new flush stop event. The flush stop event can be sent
 540  * upstream and downstream and travels serialized with the dataflow.
 541  * It is typically sent after sending a FLUSH_START event to make the
 542  * pads accept data again.
 543  *
 544  * Elements can process this event synchronized with the dataflow since
 545  * the preceding FLUSH_START event stopped the dataflow.
 546  *
 547  * This event is typically generated to complete a seek and to resume
 548  * dataflow.
 549  *
 550  * Returns: (transfer full): a new flush stop event.
 551  */
 552 GstEvent *
 553 gst_event_new_flush_stop (gboolean reset_time)
 554 {
 555   GstEvent *event;
 556 
 557   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating flush stop %d&quot;, reset_time);
 558 
 559   event = gst_event_new_custom (GST_EVENT_FLUSH_STOP,
 560       gst_structure_new_id (GST_QUARK (EVENT_FLUSH_STOP),
 561           GST_QUARK (RESET_TIME), G_TYPE_BOOLEAN, reset_time, NULL));
 562 
 563   return event;
 564 }
 565 
 566 /**
 567  * gst_event_parse_flush_stop:
 568  * @event: The event to parse
 569  * @reset_time: (out): if time should be reset
 570  *
 571  * Parse the FLUSH_STOP event and retrieve the @reset_time member.
 572  */
 573 void
 574 gst_event_parse_flush_stop (GstEvent * event, gboolean * reset_time)
 575 {
 576   GstStructure *structure;
 577 
 578   g_return_if_fail (GST_IS_EVENT (event));
 579   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_FLUSH_STOP);
 580 
 581   structure = GST_EVENT_STRUCTURE (event);
 582   if (G_LIKELY (reset_time))
 583     *reset_time =
 584         g_value_get_boolean (gst_structure_id_get_value (structure,
 585             GST_QUARK (RESET_TIME)));
 586 }
 587 
 588 /**
 589  * gst_event_new_select_streams:
 590  * @streams: (element-type utf8) (transfer none): the list of streams to
 591  * activate
 592  *
 593  * Allocate a new select-streams event.
 594  *
 595  * The select-streams event requests the specified @streams to be activated.
 596  *
 597  * The list of @streams corresponds to the &quot;Stream ID&quot; of each stream to be
 598  * activated. Those ID can be obtained via the #GstStream objects present
 599  * in #GST_EVENT_STREAM_START, #GST_EVENT_STREAM_COLLECTION or
 600  * #GST_MESSAGE_STREAM_COLLECTION.
 601  *
 602  * Note: The list of @streams can not be empty.
 603  *
 604  * Returns: (transfer full): a new select-streams event or %NULL in case of
 605  * an error (like an empty streams list).
 606  *
 607  * Since: 1.10
 608  */
 609 GstEvent *
 610 gst_event_new_select_streams (GList * streams)
 611 {
 612   GstEvent *event;
 613   GValue val = G_VALUE_INIT;
 614   GstStructure *struc;
 615   GList *tmpl;
 616 
 617   g_return_val_if_fail (streams != NULL, NULL);
 618 
 619   GST_CAT_INFO (GST_CAT_EVENT, &quot;Creating new select-streams event&quot;);
 620   struc = gst_structure_new_id_empty (GST_QUARK (EVENT_SELECT_STREAMS));
 621   g_value_init (&amp;val, GST_TYPE_LIST);
 622   /* Fill struc with streams */
 623   for (tmpl = streams; tmpl; tmpl = tmpl-&gt;next) {
 624     GValue strval = G_VALUE_INIT;
 625     const gchar *str = (const gchar *) tmpl-&gt;data;
 626     g_value_init (&amp;strval, G_TYPE_STRING);
 627     g_value_set_string (&amp;strval, str);
 628     gst_value_list_append_and_take_value (&amp;val, &amp;strval);
 629   }
 630   gst_structure_id_take_value (struc, GST_QUARK (STREAMS), &amp;val);
 631   event = gst_event_new_custom (GST_EVENT_SELECT_STREAMS, struc);
 632 
 633   return event;
 634 }
 635 
 636 /**
 637  * gst_event_parse_select_streams:
 638  * @event: The event to parse
 639  * @streams: (out) (element-type utf8) (transfer full): the streams
 640  *
 641  * Parse the SELECT_STREAMS event and retrieve the contained streams.
 642  *
 643  * Since: 1.10
 644  */
 645 void
 646 gst_event_parse_select_streams (GstEvent * event, GList ** streams)
 647 {
 648   GstStructure *structure;
 649   GList *res = NULL;
 650 
 651   g_return_if_fail (GST_IS_EVENT (event));
 652   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_SELECT_STREAMS);
 653 
 654   structure = GST_EVENT_STRUCTURE (event);
 655   if (G_LIKELY (streams)) {
 656     const GValue *vlist =
 657         gst_structure_id_get_value (structure, GST_QUARK (STREAMS));
 658     guint i, sz = gst_value_list_get_size (vlist);
 659     for (i = 0; i &lt; sz; i++) {
 660       const GValue *strv = gst_value_list_get_value (vlist, i);
 661       res = g_list_append (res, g_value_dup_string (strv));
 662     }
 663     *streams = res;
 664   }
 665 }
 666 
 667 
 668 /**
 669  * gst_event_new_stream_group_done:
 670  * @group_id: the group id of the stream group which is ending
 671  *
 672  * Create a new Stream Group Done event. The stream-group-done event can
 673  * only travel downstream synchronized with the buffer flow. Elements
 674  * that receive the event on a pad should handle it mostly like EOS,
 675  * and emit any data or pending buffers that would depend on more data
 676  * arriving and unblock, since there won&#39;t be any more data.
 677  *
 678  * This event is followed by EOS at some point in the future, and is
 679  * generally used when switching pads - to unblock downstream so that
 680  * new pads can be exposed before sending EOS on the existing pads.
 681  *
 682  * Returns: (transfer full): the new stream-group-done event.
 683  *
 684  * Since: 1.10
 685  */
 686 GstEvent *
 687 gst_event_new_stream_group_done (guint group_id)
 688 {
 689   GstStructure *s;
 690 
 691   s = gst_structure_new_id (GST_QUARK (EVENT_STREAM_GROUP_DONE),
 692       GST_QUARK (GROUP_ID), G_TYPE_UINT, group_id, NULL);
 693 
 694   return gst_event_new_custom (GST_EVENT_STREAM_GROUP_DONE, s);
 695 }
 696 
 697 /**
 698  * gst_event_parse_stream_group_done:
 699  * @event: a stream-group-done event.
 700  * @group_id: (out): address of variable to store the group id into
 701  *
 702  * Parse a stream-group-done @event and store the result in the given
 703  * @group_id location.
 704  *
 705  * Since: 1.10
 706  */
 707 void
 708 gst_event_parse_stream_group_done (GstEvent * event, guint * group_id)
 709 {
 710   g_return_if_fail (event != NULL);
 711   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_GROUP_DONE);
 712 
 713   if (group_id) {
 714     gst_structure_id_get (GST_EVENT_STRUCTURE (event),
 715         GST_QUARK (GROUP_ID), G_TYPE_UINT, group_id, NULL);
 716   }
 717 }
 718 
 719 /**
 720  * gst_event_new_eos:
 721  *
 722  * Create a new EOS event. The eos event can only travel downstream
 723  * synchronized with the buffer flow. Elements that receive the EOS
 724  * event on a pad can return #GST_FLOW_EOS as a #GstFlowReturn
 725  * when data after the EOS event arrives.
 726  *
 727  * The EOS event will travel down to the sink elements in the pipeline
 728  * which will then post the #GST_MESSAGE_EOS on the bus after they have
 729  * finished playing any buffered data.
 730  *
 731  * When all sinks have posted an EOS message, an EOS message is
 732  * forwarded to the application.
 733  *
 734  * The EOS event itself will not cause any state transitions of the pipeline.
 735  *
 736  * Returns: (transfer full): the new EOS event.
 737  */
 738 GstEvent *
 739 gst_event_new_eos (void)
 740 {
 741   return gst_event_new_custom (GST_EVENT_EOS, NULL);
 742 }
 743 
 744 /**
 745  * gst_event_new_gap:
 746  * @timestamp: the start time (pts) of the gap
 747  * @duration: the duration of the gap
 748  *
 749  * Create a new GAP event. A gap event can be thought of as conceptually
 750  * equivalent to a buffer to signal that there is no data for a certain
 751  * amount of time. This is useful to signal a gap to downstream elements
 752  * which may wait for data, such as muxers or mixers or overlays, especially
 753  * for sparse streams such as subtitle streams.
 754  *
 755  * Returns: (transfer full): the new GAP event.
 756  */
 757 GstEvent *
 758 gst_event_new_gap (GstClockTime timestamp, GstClockTime duration)
 759 {
 760   GstEvent *event;
 761 
 762   g_return_val_if_fail (GST_CLOCK_TIME_IS_VALID (timestamp), NULL);
 763 
 764   GST_CAT_TRACE (GST_CAT_EVENT, &quot;creating gap %&quot; GST_TIME_FORMAT &quot; - &quot;
 765       &quot;%&quot; GST_TIME_FORMAT &quot; (duration: %&quot; GST_TIME_FORMAT &quot;)&quot;,
 766       GST_TIME_ARGS (timestamp), GST_TIME_ARGS (timestamp + duration),
 767       GST_TIME_ARGS (duration));
 768 
 769   event = gst_event_new_custom (GST_EVENT_GAP,
 770       gst_structure_new_id (GST_QUARK (EVENT_GAP),
 771           GST_QUARK (TIMESTAMP), GST_TYPE_CLOCK_TIME, timestamp,
 772           GST_QUARK (DURATION), GST_TYPE_CLOCK_TIME, duration, NULL));
 773 
 774   return event;
 775 }
 776 
 777 /**
 778  * gst_event_parse_gap:
 779  * @event: a #GstEvent of type #GST_EVENT_GAP
 780  * @timestamp: (out) (allow-none): location where to store the
 781  *     start time (pts) of the gap, or %NULL
 782  * @duration: (out) (allow-none): location where to store the duration of
 783  *     the gap, or %NULL
 784  *
 785  * Extract timestamp and duration from a new GAP event.
 786  */
 787 void
 788 gst_event_parse_gap (GstEvent * event, GstClockTime * timestamp,
 789     GstClockTime * duration)
 790 {
 791   GstStructure *structure;
 792 
 793   g_return_if_fail (GST_IS_EVENT (event));
 794   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_GAP);
 795 
 796   structure = GST_EVENT_STRUCTURE (event);
 797   gst_structure_id_get (structure,
 798       GST_QUARK (TIMESTAMP), GST_TYPE_CLOCK_TIME, timestamp,
 799       GST_QUARK (DURATION), GST_TYPE_CLOCK_TIME, duration, NULL);
 800 }
 801 
 802 /**
 803  * gst_event_new_caps:
 804  * @caps: (transfer none): a #GstCaps
 805  *
 806  * Create a new CAPS event for @caps. The caps event can only travel downstream
 807  * synchronized with the buffer flow and contains the format of the buffers
 808  * that will follow after the event.
 809  *
 810  * Returns: (transfer full) (nullable): the new CAPS event.
 811  */
 812 GstEvent *
 813 gst_event_new_caps (GstCaps * caps)
 814 {
 815   GstEvent *event;
 816 
 817   g_return_val_if_fail (caps != NULL, NULL);
 818   g_return_val_if_fail (gst_caps_is_fixed (caps), NULL);
 819 
 820   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating caps event %&quot; GST_PTR_FORMAT, caps);
 821 
 822   event = gst_event_new_custom (GST_EVENT_CAPS,
 823       gst_structure_new_id (GST_QUARK (EVENT_CAPS),
 824           GST_QUARK (CAPS), GST_TYPE_CAPS, caps, NULL));
 825 
 826   return event;
 827 }
 828 
 829 /**
 830  * gst_event_parse_caps:
 831  * @event: The event to parse
 832  * @caps: (out) (transfer none): A pointer to the caps
 833  *
 834  * Get the caps from @event. The caps remains valid as long as @event remains
 835  * valid.
 836  */
 837 void
 838 gst_event_parse_caps (GstEvent * event, GstCaps ** caps)
 839 {
 840   GstStructure *structure;
 841 
 842   g_return_if_fail (GST_IS_EVENT (event));
 843   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_CAPS);
 844 
 845   structure = GST_EVENT_STRUCTURE (event);
 846   if (G_LIKELY (caps))
 847     *caps =
 848         g_value_get_boxed (gst_structure_id_get_value (structure,
 849             GST_QUARK (CAPS)));
 850 }
 851 
 852 /**
 853  * gst_event_new_segment:
 854  * @segment: (transfer none): a #GstSegment
 855  *
 856  * Create a new SEGMENT event for @segment. The segment event can only travel
 857  * downstream synchronized with the buffer flow and contains timing information
 858  * and playback properties for the buffers that will follow.
 859  *
 860  * The segment event marks the range of buffers to be processed. All
 861  * data not within the segment range is not to be processed. This can be
 862  * used intelligently by plugins to apply more efficient methods of skipping
 863  * unneeded data. The valid range is expressed with the @start and @stop
 864  * values.
 865  *
 866  * The time value of the segment is used in conjunction with the start
 867  * value to convert the buffer timestamps into the stream time. This is
 868  * usually done in sinks to report the current stream_time.
 869  * @time represents the stream_time of a buffer carrying a timestamp of
 870  * @start. @time cannot be -1.
 871  *
 872  * @start cannot be -1, @stop can be -1. If there
 873  * is a valid @stop given, it must be greater or equal the @start, including
 874  * when the indicated playback @rate is &lt; 0.
 875  *
 876  * The @applied_rate value provides information about any rate adjustment that
 877  * has already been made to the timestamps and content on the buffers of the
 878  * stream. (@rate * @applied_rate) should always equal the rate that has been
 879  * requested for playback. For example, if an element has an input segment
 880  * with intended playback @rate of 2.0 and applied_rate of 1.0, it can adjust
 881  * incoming timestamps and buffer content by half and output a segment event
 882  * with @rate of 1.0 and @applied_rate of 2.0
 883  *
 884  * After a segment event, the buffer stream time is calculated with:
 885  *
 886  *   time + (TIMESTAMP(buf) - start) * ABS (rate * applied_rate)
 887  *
 888  * Returns: (transfer full) (nullable): the new SEGMENT event.
 889  */
 890 GstEvent *
 891 gst_event_new_segment (const GstSegment * segment)
 892 {
 893   GstEvent *event;
 894 
 895   g_return_val_if_fail (segment != NULL, NULL);
 896   g_return_val_if_fail (segment-&gt;rate != 0.0, NULL);
 897   g_return_val_if_fail (segment-&gt;applied_rate != 0.0, NULL);
 898   g_return_val_if_fail (segment-&gt;format != GST_FORMAT_UNDEFINED, NULL);
 899 
 900   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating segment event %&quot; GST_SEGMENT_FORMAT,
 901       segment);
 902 
 903   event = gst_event_new_custom (GST_EVENT_SEGMENT,
 904       gst_structure_new_id (GST_QUARK (EVENT_SEGMENT),
 905           GST_QUARK (SEGMENT), GST_TYPE_SEGMENT, segment, NULL));
 906 
 907   return event;
 908 }
 909 
 910 /**
 911  * gst_event_parse_segment:
 912  * @event: The event to parse
 913  * @segment: (out) (transfer none): a pointer to a #GstSegment
 914  *
 915  * Parses a segment @event and stores the result in the given @segment location.
 916  * @segment remains valid only until the @event is freed. Don&#39;t modify the segment
 917  * and make a copy if you want to modify it or store it for later use.
 918  */
 919 void
 920 gst_event_parse_segment (GstEvent * event, const GstSegment ** segment)
 921 {
 922   GstStructure *structure;
 923 
 924   g_return_if_fail (GST_IS_EVENT (event));
 925   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_SEGMENT);
 926 
 927   if (segment) {
 928     structure = GST_EVENT_STRUCTURE (event);
 929     *segment = g_value_get_boxed (gst_structure_id_get_value (structure,
 930             GST_QUARK (SEGMENT)));
 931   }
 932 }
 933 
 934 /**
 935  * gst_event_copy_segment:
 936  * @event: The event to parse
 937  * @segment: a pointer to a #GstSegment
 938  *
 939  * Parses a segment @event and copies the #GstSegment into the location
 940  * given by @segment.
 941  */
 942 void
 943 gst_event_copy_segment (GstEvent * event, GstSegment * segment)
 944 {
 945   const GstSegment *src;
 946 
 947   g_return_if_fail (GST_IS_EVENT (event));
 948   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_SEGMENT);
 949 
 950   if (segment) {
 951     gst_event_parse_segment (event, &amp;src);
 952     gst_segment_copy_into (src, segment);
 953   }
 954 }
 955 
 956 /**
 957  * gst_event_new_tag:
 958  * @taglist: (transfer full): metadata list. The event will take ownership
 959  *     of the taglist.
 960  *
 961  * Generates a metadata tag event from the given @taglist.
 962  *
 963  * The scope of the taglist specifies if the taglist applies to the
 964  * complete medium or only to this specific stream. As the tag event
 965  * is a sticky event, elements should merge tags received from
 966  * upstream with a given scope with their own tags with the same
 967  * scope and create a new tag event from it.
 968  *
 969  * Returns: (transfer full): a new #GstEvent
 970  */
 971 GstEvent *
 972 gst_event_new_tag (GstTagList * taglist)
 973 {
 974   GstStructure *s;
 975   GValue val = G_VALUE_INIT;
 976   const gchar *names[] = { &quot;GstTagList-stream&quot;, &quot;GstTagList-global&quot; };
 977 
 978   g_return_val_if_fail (taglist != NULL, NULL);
 979 
 980   s = gst_structure_new_empty (names[gst_tag_list_get_scope (taglist)]);
 981   g_value_init (&amp;val, GST_TYPE_TAG_LIST);
 982   g_value_take_boxed (&amp;val, taglist);
 983   gst_structure_id_take_value (s, GST_QUARK (TAGLIST), &amp;val);
 984   return gst_event_new_custom (GST_EVENT_TAG, s);
 985 }
 986 
 987 /**
 988  * gst_event_parse_tag:
 989  * @event: a tag event
 990  * @taglist: (out) (transfer none): pointer to metadata list
 991  *
 992  * Parses a tag @event and stores the results in the given @taglist location.
 993  * No reference to the taglist will be returned, it remains valid only until
 994  * the @event is freed. Don&#39;t modify or free the taglist, make a copy if you
 995  * want to modify it or store it for later use.
 996  */
 997 void
 998 gst_event_parse_tag (GstEvent * event, GstTagList ** taglist)
 999 {
1000   const GValue *val;
1001 
1002   g_return_if_fail (GST_IS_EVENT (event));
1003   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_TAG);
1004 
1005   val = gst_structure_id_get_value (GST_EVENT_STRUCTURE (event),
1006       GST_QUARK (TAGLIST));
1007 
1008   if (taglist)
1009     *taglist = (GstTagList *) g_value_get_boxed (val);
1010 }
1011 
1012 /* buffersize event */
1013 /**
1014  * gst_event_new_buffer_size:
1015  * @format: buffer format
1016  * @minsize: minimum buffer size
1017  * @maxsize: maximum buffer size
1018  * @async: thread behavior
1019  *
1020  * Create a new buffersize event. The event is sent downstream and notifies
1021  * elements that they should provide a buffer of the specified dimensions.
1022  *
1023  * When the @async flag is set, a thread boundary is preferred.
1024  *
1025  * Returns: (transfer full): a new #GstEvent
1026  */
1027 GstEvent *
1028 gst_event_new_buffer_size (GstFormat format, gint64 minsize,
1029     gint64 maxsize, gboolean async)
1030 {
1031   GstEvent *event;
1032   GstStructure *structure;
1033 
1034   GST_CAT_INFO (GST_CAT_EVENT,
1035       &quot;creating buffersize format %s, minsize %&quot; G_GINT64_FORMAT
1036       &quot;, maxsize %&quot; G_GINT64_FORMAT &quot;, async %d&quot;, gst_format_get_name (format),
1037       minsize, maxsize, async);
1038 
1039   structure = gst_structure_new_id (GST_QUARK (EVENT_BUFFER_SIZE),
1040       GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,
1041       GST_QUARK (MINSIZE), G_TYPE_INT64, minsize,
1042       GST_QUARK (MAXSIZE), G_TYPE_INT64, maxsize,
1043       GST_QUARK (ASYNC), G_TYPE_BOOLEAN, async, NULL);
1044   event = gst_event_new_custom (GST_EVENT_BUFFERSIZE, structure);
1045 
1046   return event;
1047 }
1048 
1049 /**
1050  * gst_event_parse_buffer_size:
1051  * @event: The event to query
1052  * @format: (out): A pointer to store the format in
1053  * @minsize: (out): A pointer to store the minsize in
1054  * @maxsize: (out): A pointer to store the maxsize in
1055  * @async: (out): A pointer to store the async-flag in
1056  *
1057  * Get the format, minsize, maxsize and async-flag in the buffersize event.
1058  */
1059 void
1060 gst_event_parse_buffer_size (GstEvent * event, GstFormat * format,
1061     gint64 * minsize, gint64 * maxsize, gboolean * async)
1062 {
1063   const GstStructure *structure;
1064 
1065   g_return_if_fail (GST_IS_EVENT (event));
1066   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_BUFFERSIZE);
1067 
1068   structure = GST_EVENT_STRUCTURE (event);
1069   if (format)
1070     *format = (GstFormat)
1071         g_value_get_enum (gst_structure_id_get_value (structure,
1072             GST_QUARK (FORMAT)));
1073   if (minsize)
1074     *minsize =
1075         g_value_get_int64 (gst_structure_id_get_value (structure,
1076             GST_QUARK (MINSIZE)));
1077   if (maxsize)
1078     *maxsize =
1079         g_value_get_int64 (gst_structure_id_get_value (structure,
1080             GST_QUARK (MAXSIZE)));
1081   if (async)
1082     *async =
1083         g_value_get_boolean (gst_structure_id_get_value (structure,
1084             GST_QUARK (ASYNC)));
1085 }
1086 
1087 /**
1088  * gst_event_new_qos:
1089  * @type: the QoS type
1090  * @proportion: the proportion of the qos message
1091  * @diff: The time difference of the last Clock sync
1092  * @timestamp: The timestamp of the buffer
1093  *
1094  * Allocate a new qos event with the given values.
1095  * The QOS event is generated in an element that wants an upstream
1096  * element to either reduce or increase its rate because of
1097  * high/low CPU load or other resource usage such as network performance or
1098  * throttling. Typically sinks generate these events for each buffer
1099  * they receive.
1100  *
1101  * @type indicates the reason for the QoS event. #GST_QOS_TYPE_OVERFLOW is
1102  * used when a buffer arrived in time or when the sink cannot keep up with
1103  * the upstream datarate. #GST_QOS_TYPE_UNDERFLOW is when the sink is not
1104  * receiving buffers fast enough and thus has to drop late buffers.
1105  * #GST_QOS_TYPE_THROTTLE is used when the datarate is artificially limited
1106  * by the application, for example to reduce power consumption.
1107  *
1108  * @proportion indicates the real-time performance of the streaming in the
1109  * element that generated the QoS event (usually the sink). The value is
1110  * generally computed based on more long term statistics about the streams
1111  * timestamps compared to the clock.
1112  * A value &lt; 1.0 indicates that the upstream element is producing data faster
1113  * than real-time. A value &gt; 1.0 indicates that the upstream element is not
1114  * producing data fast enough. 1.0 is the ideal @proportion value. The
1115  * proportion value can safely be used to lower or increase the quality of
1116  * the element.
1117  *
1118  * @diff is the difference against the clock in running time of the last
1119  * buffer that caused the element to generate the QOS event. A negative value
1120  * means that the buffer with @timestamp arrived in time. A positive value
1121  * indicates how late the buffer with @timestamp was. When throttling is
1122  * enabled, @diff will be set to the requested throttling interval.
1123  *
1124  * @timestamp is the timestamp of the last buffer that cause the element
1125  * to generate the QOS event. It is expressed in running time and thus an ever
1126  * increasing value.
1127  *
1128  * The upstream element can use the @diff and @timestamp values to decide
1129  * whether to process more buffers. For positive @diff, all buffers with
1130  * timestamp &lt;= @timestamp + @diff will certainly arrive late in the sink
1131  * as well. A (negative) @diff value so that @timestamp + @diff would yield a
1132  * result smaller than 0 is not allowed.
1133  *
1134  * The application can use general event probes to intercept the QoS
1135  * event and implement custom application specific QoS handling.
1136  *
1137  * Returns: (transfer full) (nullable): a new QOS event.
1138  */
1139 GstEvent *
1140 gst_event_new_qos (GstQOSType type, gdouble proportion,
1141     GstClockTimeDiff diff, GstClockTime timestamp)
1142 {
1143   GstEvent *event;
1144   GstStructure *structure;
1145 
1146   /* diff must be positive or timestamp + diff must be positive */
1147   g_return_val_if_fail (diff &gt;= 0 || -diff &lt;= timestamp, NULL);
1148 
1149   GST_CAT_LOG (GST_CAT_EVENT,
1150       &quot;creating qos type %d, proportion %lf, diff %&quot; G_GINT64_FORMAT
1151       &quot;, timestamp %&quot; GST_TIME_FORMAT, type, proportion,
1152       diff, GST_TIME_ARGS (timestamp));
1153 
1154   structure = gst_structure_new_id (GST_QUARK (EVENT_QOS),
1155       GST_QUARK (TYPE), GST_TYPE_QOS_TYPE, type,
1156       GST_QUARK (PROPORTION), G_TYPE_DOUBLE, proportion,
1157       GST_QUARK (DIFF), G_TYPE_INT64, diff,
1158       GST_QUARK (TIMESTAMP), G_TYPE_UINT64, timestamp, NULL);
1159   event = gst_event_new_custom (GST_EVENT_QOS, structure);
1160 
1161   return event;
1162 }
1163 
1164 /**
1165  * gst_event_parse_qos:
1166  * @event: The event to query
1167  * @type: (out): A pointer to store the QoS type in
1168  * @proportion: (out): A pointer to store the proportion in
1169  * @diff: (out): A pointer to store the diff in
1170  * @timestamp: (out): A pointer to store the timestamp in
1171  *
1172  * Get the type, proportion, diff and timestamp in the qos event. See
1173  * gst_event_new_qos() for more information about the different QoS values.
1174  *
1175  * @timestamp will be adjusted for any pad offsets of pads it was passing through.
1176  */
1177 void
1178 gst_event_parse_qos (GstEvent * event, GstQOSType * type,
1179     gdouble * proportion, GstClockTimeDiff * diff, GstClockTime * timestamp)
1180 {
1181   const GstStructure *structure;
1182 
1183   g_return_if_fail (GST_IS_EVENT (event));
1184   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_QOS);
1185 
1186   structure = GST_EVENT_STRUCTURE (event);
1187   if (type)
1188     *type = (GstQOSType)
1189         g_value_get_enum (gst_structure_id_get_value (structure,
1190             GST_QUARK (TYPE)));
1191   if (proportion)
1192     *proportion =
1193         g_value_get_double (gst_structure_id_get_value (structure,
1194             GST_QUARK (PROPORTION)));
1195   if (diff)
1196     *diff =
1197         g_value_get_int64 (gst_structure_id_get_value (structure,
1198             GST_QUARK (DIFF)));
1199   if (timestamp) {
1200     gint64 offset = gst_event_get_running_time_offset (event);
1201     GstClockTimeDiff diff_ =
1202         g_value_get_int64 (gst_structure_id_get_value (structure,
1203             GST_QUARK (DIFF)));
1204 
1205     *timestamp =
1206         g_value_get_uint64 (gst_structure_id_get_value (structure,
1207             GST_QUARK (TIMESTAMP)));
1208     /* Catch underflows */
1209     if (*timestamp &gt; -offset)
1210       *timestamp += offset;
1211     else
1212       *timestamp = 0;
1213 
1214     /* Make sure that timestamp + diff is always &gt;= 0. Because
1215      * of the running time offset this might not be true */
1216     if (diff_ &lt; 0 &amp;&amp; *timestamp &lt; -diff_)
1217       *timestamp = (GstClockTime) - diff_;
1218   }
1219 }
1220 
1221 /**
1222  * gst_event_new_seek:
1223  * @rate: The new playback rate
1224  * @format: The format of the seek values
1225  * @flags: The optional seek flags
1226  * @start_type: The type and flags for the new start position
1227  * @start: The value of the new start position
1228  * @stop_type: The type and flags for the new stop position
1229  * @stop: The value of the new stop position
1230  *
1231  * Allocate a new seek event with the given parameters.
1232  *
1233  * The seek event configures playback of the pipeline between @start to @stop
1234  * at the speed given in @rate, also called a playback segment.
1235  * The @start and @stop values are expressed in @format.
1236  *
1237  * A @rate of 1.0 means normal playback rate, 2.0 means double speed.
1238  * Negatives values means backwards playback. A value of 0.0 for the
1239  * rate is not allowed and should be accomplished instead by PAUSING the
1240  * pipeline.
1241  *
1242  * A pipeline has a default playback segment configured with a start
1243  * position of 0, a stop position of -1 and a rate of 1.0. The currently
1244  * configured playback segment can be queried with #GST_QUERY_SEGMENT.
1245  *
1246  * @start_type and @stop_type specify how to adjust the currently configured
1247  * start and stop fields in playback segment. Adjustments can be made relative
1248  * or absolute to the last configured values. A type of #GST_SEEK_TYPE_NONE
1249  * means that the position should not be updated.
1250  *
1251  * When the rate is positive and @start has been updated, playback will start
1252  * from the newly configured start position.
1253  *
1254  * For negative rates, playback will start from the newly configured stop
1255  * position (if any). If the stop position is updated, it must be different from
1256  * -1 (#GST_CLOCK_TIME_NONE) for negative rates.
1257  *
1258  * It is not possible to seek relative to the current playback position, to do
1259  * this, PAUSE the pipeline, query the current playback position with
1260  * #GST_QUERY_POSITION and update the playback segment current position with a
1261  * #GST_SEEK_TYPE_SET to the desired position.
1262  *
1263  * Returns: (transfer full) (nullable): a new seek event.
1264  */
1265 GstEvent *
1266 gst_event_new_seek (gdouble rate, GstFormat format, GstSeekFlags flags,
1267     GstSeekType start_type, gint64 start, GstSeekType stop_type, gint64 stop)
1268 {
1269   GstEvent *event;
1270   GstStructure *structure;
1271 
1272   g_return_val_if_fail (rate != 0.0, NULL);
1273 
<a name="4" id="anc4"></a><span class="line-added">1274   /* SNAP flags only make sense in combination with the KEYUNIT flag. Warn</span>
<span class="line-added">1275    * and unset the SNAP flags if they&#39;re set without the KEYUNIT flag */</span>
<span class="line-added">1276   if (!(flags &amp; GST_SEEK_FLAG_KEY_UNIT) &amp;&amp;</span>
<span class="line-added">1277       (flags &amp; (GST_SEEK_FLAG_SNAP_BEFORE | GST_SEEK_FLAG_SNAP_AFTER |</span>
<span class="line-added">1278               GST_SEEK_FLAG_SNAP_NEAREST))) {</span>
<span class="line-added">1279     g_warning (&quot;SNAP seeks only work in combination with the KEY_UNIT &quot;</span>
<span class="line-added">1280         &quot;flag, ignoring SNAP flags&quot;);</span>
<span class="line-added">1281     flags &amp;=</span>
<span class="line-added">1282         ~(GST_SEEK_FLAG_SNAP_BEFORE | GST_SEEK_FLAG_SNAP_AFTER |</span>
<span class="line-added">1283         GST_SEEK_FLAG_SNAP_NEAREST);</span>
<span class="line-added">1284   }</span>
<span class="line-added">1285 </span>
1286   if (format == GST_FORMAT_TIME) {
1287     GST_CAT_INFO (GST_CAT_EVENT,
1288         &quot;creating seek rate %lf, format TIME, flags %d, &quot;
1289         &quot;start_type %d, start %&quot; GST_TIME_FORMAT &quot;, &quot;
1290         &quot;stop_type %d, stop %&quot; GST_TIME_FORMAT,
1291         rate, flags, start_type, GST_TIME_ARGS (start),
1292         stop_type, GST_TIME_ARGS (stop));
1293   } else {
1294     GST_CAT_INFO (GST_CAT_EVENT,
1295         &quot;creating seek rate %lf, format %s, flags %d, &quot;
1296         &quot;start_type %d, start %&quot; G_GINT64_FORMAT &quot;, &quot;
1297         &quot;stop_type %d, stop %&quot; G_GINT64_FORMAT,
1298         rate, gst_format_get_name (format), flags, start_type, start, stop_type,
1299         stop);
1300   }
1301 
1302   structure = gst_structure_new_id (GST_QUARK (EVENT_SEEK),
1303       GST_QUARK (RATE), G_TYPE_DOUBLE, rate,
1304       GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,
1305       GST_QUARK (FLAGS), GST_TYPE_SEEK_FLAGS, flags,
1306       GST_QUARK (CUR_TYPE), GST_TYPE_SEEK_TYPE, start_type,
1307       GST_QUARK (CUR), G_TYPE_INT64, start,
1308       GST_QUARK (STOP_TYPE), GST_TYPE_SEEK_TYPE, stop_type,
<a name="5" id="anc5"></a><span class="line-modified">1309       GST_QUARK (STOP), G_TYPE_INT64, stop,</span>
<span class="line-added">1310       GST_QUARK (TRICKMODE_INTERVAL), GST_TYPE_CLOCK_TIME, (GstClockTime) 0,</span>
<span class="line-added">1311       NULL);</span>
1312   event = gst_event_new_custom (GST_EVENT_SEEK, structure);
1313 
1314   return event;
1315 }
1316 
1317 /**
1318  * gst_event_parse_seek:
1319  * @event: a seek event
1320  * @rate: (out): result location for the rate
1321  * @format: (out): result location for the stream format
1322  * @flags:  (out): result location for the #GstSeekFlags
1323  * @start_type: (out): result location for the #GstSeekType of the start position
1324  * @start: (out): result location for the start position expressed in @format
1325  * @stop_type:  (out): result location for the #GstSeekType of the stop position
1326  * @stop: (out): result location for the stop position expressed in @format
1327  *
1328  * Parses a seek @event and stores the results in the given result locations.
1329  */
1330 void
1331 gst_event_parse_seek (GstEvent * event, gdouble * rate,
1332     GstFormat * format, GstSeekFlags * flags, GstSeekType * start_type,
1333     gint64 * start, GstSeekType * stop_type, gint64 * stop)
1334 {
1335   const GstStructure *structure;
1336 
1337   g_return_if_fail (GST_IS_EVENT (event));
1338   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_SEEK);
1339 
1340   structure = GST_EVENT_STRUCTURE (event);
1341   if (rate)
1342     *rate =
1343         g_value_get_double (gst_structure_id_get_value (structure,
1344             GST_QUARK (RATE)));
1345   if (format)
1346     *format = (GstFormat)
1347         g_value_get_enum (gst_structure_id_get_value (structure,
1348             GST_QUARK (FORMAT)));
1349   if (flags)
1350     *flags = (GstSeekFlags)
1351         g_value_get_flags (gst_structure_id_get_value (structure,
1352             GST_QUARK (FLAGS)));
1353   if (start_type)
1354     *start_type = (GstSeekType)
1355         g_value_get_enum (gst_structure_id_get_value (structure,
1356             GST_QUARK (CUR_TYPE)));
1357   if (start)
1358     *start =
1359         g_value_get_int64 (gst_structure_id_get_value (structure,
1360             GST_QUARK (CUR)));
1361   if (stop_type)
1362     *stop_type = (GstSeekType)
1363         g_value_get_enum (gst_structure_id_get_value (structure,
1364             GST_QUARK (STOP_TYPE)));
1365   if (stop)
1366     *stop =
1367         g_value_get_int64 (gst_structure_id_get_value (structure,
1368             GST_QUARK (STOP)));
1369 }
1370 
<a name="6" id="anc6"></a><span class="line-added">1371 /**</span>
<span class="line-added">1372  * gst_event_set_seek_trickmode_interval:</span>
<span class="line-added">1373  *</span>
<span class="line-added">1374  * Sets a trickmode interval on a (writable) seek event. Elements</span>
<span class="line-added">1375  * that support TRICKMODE_KEY_UNITS seeks SHOULD use this as the minimal</span>
<span class="line-added">1376  * interval between each frame they may output.</span>
<span class="line-added">1377  *</span>
<span class="line-added">1378  * Since: 1.16</span>
<span class="line-added">1379  */</span>
<span class="line-added">1380 void</span>
<span class="line-added">1381 gst_event_set_seek_trickmode_interval (GstEvent * event, GstClockTime interval)</span>
<span class="line-added">1382 {</span>
<span class="line-added">1383   g_return_if_fail (event != NULL);</span>
<span class="line-added">1384   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_SEEK);</span>
<span class="line-added">1385   g_return_if_fail (gst_event_is_writable (event));</span>
<span class="line-added">1386   g_return_if_fail (GST_CLOCK_TIME_IS_VALID (interval));</span>
<span class="line-added">1387 </span>
<span class="line-added">1388   gst_structure_id_set (GST_EVENT_STRUCTURE (event),</span>
<span class="line-added">1389       GST_QUARK (TRICKMODE_INTERVAL), GST_TYPE_CLOCK_TIME, interval, NULL);</span>
<span class="line-added">1390 }</span>
<span class="line-added">1391 </span>
<span class="line-added">1392 /**</span>
<span class="line-added">1393  * gst_event_parse_seek_trickmode_interval:</span>
<span class="line-added">1394  * @interval: (out)</span>
<span class="line-added">1395  *</span>
<span class="line-added">1396  * Retrieve the trickmode interval that may have been set on a</span>
<span class="line-added">1397  * seek event with gst_event_set_seek_trickmode_interval().</span>
<span class="line-added">1398  *</span>
<span class="line-added">1399  * Since: 1.16</span>
<span class="line-added">1400  */</span>
<span class="line-added">1401 void</span>
<span class="line-added">1402 gst_event_parse_seek_trickmode_interval (GstEvent * event,</span>
<span class="line-added">1403     GstClockTime * interval)</span>
<span class="line-added">1404 {</span>
<span class="line-added">1405   g_return_if_fail (event != NULL);</span>
<span class="line-added">1406   g_return_if_fail (interval != NULL);</span>
<span class="line-added">1407   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_SEEK);</span>
<span class="line-added">1408 </span>
<span class="line-added">1409   gst_structure_id_get (GST_EVENT_STRUCTURE (event),</span>
<span class="line-added">1410       GST_QUARK (TRICKMODE_INTERVAL), GST_TYPE_CLOCK_TIME, interval, NULL);</span>
<span class="line-added">1411 }</span>
<span class="line-added">1412 </span>
1413 /**
1414  * gst_event_new_navigation:
1415  * @structure: (transfer full): description of the event. The event will take
1416  *     ownership of the structure.
1417  *
1418  * Create a new navigation event from the given description.
1419  *
1420  * Returns: (transfer full): a new #GstEvent
1421  */
1422 GstEvent *
1423 gst_event_new_navigation (GstStructure * structure)
1424 {
1425   g_return_val_if_fail (structure != NULL, NULL);
1426 
1427   return gst_event_new_custom (GST_EVENT_NAVIGATION, structure);
1428 }
1429 
1430 /**
1431  * gst_event_new_latency:
1432  * @latency: the new latency value
1433  *
1434  * Create a new latency event. The event is sent upstream from the sinks and
1435  * notifies elements that they should add an additional @latency to the
1436  * running time before synchronising against the clock.
1437  *
1438  * The latency is mostly used in live sinks and is always expressed in
1439  * the time format.
1440  *
1441  * Returns: (transfer full): a new #GstEvent
1442  */
1443 GstEvent *
1444 gst_event_new_latency (GstClockTime latency)
1445 {
1446   GstEvent *event;
1447   GstStructure *structure;
1448 
1449   GST_CAT_INFO (GST_CAT_EVENT,
1450       &quot;creating latency event %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (latency));
1451 
1452   structure = gst_structure_new_id (GST_QUARK (EVENT_LATENCY),
1453       GST_QUARK (LATENCY), G_TYPE_UINT64, latency, NULL);
1454   event = gst_event_new_custom (GST_EVENT_LATENCY, structure);
1455 
1456   return event;
1457 }
1458 
1459 /**
1460  * gst_event_parse_latency:
1461  * @event: The event to query
1462  * @latency: (out): A pointer to store the latency in.
1463  *
1464  * Get the latency in the latency event.
1465  */
1466 void
1467 gst_event_parse_latency (GstEvent * event, GstClockTime * latency)
1468 {
1469   g_return_if_fail (GST_IS_EVENT (event));
1470   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_LATENCY);
1471 
1472   if (latency)
1473     *latency =
1474         g_value_get_uint64 (gst_structure_id_get_value (GST_EVENT_STRUCTURE
1475             (event), GST_QUARK (LATENCY)));
1476 }
1477 
1478 /**
1479  * gst_event_new_step:
1480  * @format: the format of @amount
1481  * @amount: the amount of data to step
1482  * @rate: the step rate
1483  * @flush: flushing steps
1484  * @intermediate: intermediate steps
1485  *
1486  * Create a new step event. The purpose of the step event is to instruct a sink
1487  * to skip @amount (expressed in @format) of media. It can be used to implement
1488  * stepping through the video frame by frame or for doing fast trick modes.
1489  *
1490  * A rate of &lt;= 0.0 is not allowed. Pause the pipeline, for the effect of rate
1491  * = 0.0 or first reverse the direction of playback using a seek event to get
1492  * the same effect as rate &lt; 0.0.
1493  *
1494  * The @flush flag will clear any pending data in the pipeline before starting
1495  * the step operation.
1496  *
1497  * The @intermediate flag instructs the pipeline that this step operation is
1498  * part of a larger step operation.
1499  *
1500  * Returns: (transfer full) (nullable): a new #GstEvent
1501  */
1502 GstEvent *
1503 gst_event_new_step (GstFormat format, guint64 amount, gdouble rate,
1504     gboolean flush, gboolean intermediate)
1505 {
1506   GstEvent *event;
1507   GstStructure *structure;
1508 
1509   g_return_val_if_fail (rate &gt; 0.0, NULL);
1510 
1511   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating step event&quot;);
1512 
1513   structure = gst_structure_new_id (GST_QUARK (EVENT_STEP),
1514       GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,
1515       GST_QUARK (AMOUNT), G_TYPE_UINT64, amount,
1516       GST_QUARK (RATE), G_TYPE_DOUBLE, rate,
1517       GST_QUARK (FLUSH), G_TYPE_BOOLEAN, flush,
1518       GST_QUARK (INTERMEDIATE), G_TYPE_BOOLEAN, intermediate, NULL);
1519   event = gst_event_new_custom (GST_EVENT_STEP, structure);
1520 
1521   return event;
1522 }
1523 
1524 /**
1525  * gst_event_parse_step:
1526  * @event: The event to query
1527  * @format: (out) (allow-none): a pointer to store the format in
1528  * @amount: (out) (allow-none): a pointer to store the amount in
1529  * @rate: (out) (allow-none): a pointer to store the rate in
1530  * @flush: (out) (allow-none): a pointer to store the flush boolean in
1531  * @intermediate: (out) (allow-none): a pointer to store the intermediate
1532  *     boolean in
1533  *
1534  * Parse the step event.
1535  */
1536 void
1537 gst_event_parse_step (GstEvent * event, GstFormat * format, guint64 * amount,
1538     gdouble * rate, gboolean * flush, gboolean * intermediate)
1539 {
1540   const GstStructure *structure;
1541 
1542   g_return_if_fail (GST_IS_EVENT (event));
1543   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STEP);
1544 
1545   structure = GST_EVENT_STRUCTURE (event);
1546   if (format)
1547     *format =
1548         (GstFormat) g_value_get_enum (gst_structure_id_get_value (structure,
1549             GST_QUARK (FORMAT)));
1550   if (amount)
1551     *amount = g_value_get_uint64 (gst_structure_id_get_value (structure,
1552             GST_QUARK (AMOUNT)));
1553   if (rate)
1554     *rate = g_value_get_double (gst_structure_id_get_value (structure,
1555             GST_QUARK (RATE)));
1556   if (flush)
1557     *flush = g_value_get_boolean (gst_structure_id_get_value (structure,
1558             GST_QUARK (FLUSH)));
1559   if (intermediate)
1560     *intermediate = g_value_get_boolean (gst_structure_id_get_value (structure,
1561             GST_QUARK (INTERMEDIATE)));
1562 }
1563 
1564 /**
1565  * gst_event_new_reconfigure:
1566 
1567  * Create a new reconfigure event. The purpose of the reconfigure event is
1568  * to travel upstream and make elements renegotiate their caps or reconfigure
1569  * their buffer pools. This is useful when changing properties on elements
1570  * or changing the topology of the pipeline.
1571  *
1572  * Returns: (transfer full): a new #GstEvent
1573  */
1574 GstEvent *
1575 gst_event_new_reconfigure (void)
1576 {
1577   GstEvent *event;
1578 
1579   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating reconfigure event&quot;);
1580 
1581   event = gst_event_new_custom (GST_EVENT_RECONFIGURE, NULL);
1582 
1583   return event;
1584 }
1585 
1586 /**
1587  * gst_event_new_sink_message:
1588  * @name: a name for the event
1589  * @msg: (transfer none): the #GstMessage to be posted
1590  *
1591  * Create a new sink-message event. The purpose of the sink-message event is
1592  * to instruct a sink to post the message contained in the event synchronized
1593  * with the stream.
1594  *
1595  * @name is used to store multiple sticky events on one pad.
1596  *
1597  * Returns: (transfer full): a new #GstEvent
1598  */
1599 /* FIXME 2.0: take ownership of msg for consistency? */
1600 GstEvent *
1601 gst_event_new_sink_message (const gchar * name, GstMessage * msg)
1602 {
1603   GstEvent *event;
1604   GstStructure *structure;
1605 
1606   g_return_val_if_fail (msg != NULL, NULL);
1607 
1608   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating sink-message event&quot;);
1609 
1610   structure = gst_structure_new_id (g_quark_from_string (name),
1611       GST_QUARK (MESSAGE), GST_TYPE_MESSAGE, msg, NULL);
1612   event = gst_event_new_custom (GST_EVENT_SINK_MESSAGE, structure);
1613 
1614   return event;
1615 }
1616 
1617 /**
1618  * gst_event_parse_sink_message:
1619  * @event: The event to query
1620  * @msg: (out) (transfer full): a pointer to store the #GstMessage in.
1621  *
1622  * Parse the sink-message event. Unref @msg after usage.
1623  */
1624 void
1625 gst_event_parse_sink_message (GstEvent * event, GstMessage ** msg)
1626 {
1627   const GstStructure *structure;
1628 
1629   g_return_if_fail (GST_IS_EVENT (event));
1630   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_SINK_MESSAGE);
1631 
1632   structure = GST_EVENT_STRUCTURE (event);
1633   if (msg)
1634     *msg =
1635         GST_MESSAGE (g_value_dup_boxed (gst_structure_id_get_value
1636             (structure, GST_QUARK (MESSAGE))));
1637 }
1638 
1639 /**
1640  * gst_event_new_stream_start:
1641  * @stream_id: Identifier for this stream
1642  *
1643  * Create a new STREAM_START event. The stream start event can only
1644  * travel downstream synchronized with the buffer flow. It is expected
1645  * to be the first event that is sent for a new stream.
1646  *
1647  * Source elements, demuxers and other elements that create new streams
1648  * are supposed to send this event as the first event of a new stream. It
1649  * should not be sent after a flushing seek or in similar situations
1650  * and is used to mark the beginning of a new logical stream. Elements
1651  * combining multiple streams must ensure that this event is only forwarded
1652  * downstream once and not for every single input stream.
1653  *
1654  * The @stream_id should be a unique string that consists of the upstream
1655  * stream-id, / as separator and a unique stream-id for this specific
1656  * stream. A new stream-id should only be created for a stream if the upstream
1657  * stream is split into (potentially) multiple new streams, e.g. in a demuxer,
1658  * but not for every single element in the pipeline.
1659  * gst_pad_create_stream_id() or gst_pad_create_stream_id_printf() can be
1660  * used to create a stream-id.  There are no particular semantics for the
1661  * stream-id, though it should be deterministic (to support stream matching)
1662  * and it might be used to order streams (besides any information conveyed by
1663  * stream flags).
1664  *
1665  * Returns: (transfer full): the new STREAM_START event.
1666  */
1667 GstEvent *
1668 gst_event_new_stream_start (const gchar * stream_id)
1669 {
1670   GstStructure *s;
1671 
1672   g_return_val_if_fail (stream_id != NULL, NULL);
1673 
1674   s = gst_structure_new_id (GST_QUARK (EVENT_STREAM_START),
1675       GST_QUARK (STREAM_ID), G_TYPE_STRING, stream_id,
1676       GST_QUARK (FLAGS), GST_TYPE_STREAM_FLAGS, GST_STREAM_FLAG_NONE, NULL);
1677 
1678   return gst_event_new_custom (GST_EVENT_STREAM_START, s);
1679 }
1680 
1681 /**
1682  * gst_event_parse_stream_start:
1683  * @event: a stream-start event.
1684  * @stream_id: (out) (transfer none): pointer to store the stream-id
1685  *
1686  * Parse a stream-id @event and store the result in the given @stream_id
1687  * location. The string stored in @stream_id must not be modified and will
1688  * remain valid only until @event gets freed. Make a copy if you want to
1689  * modify it or store it for later use.
1690  */
1691 void
1692 gst_event_parse_stream_start (GstEvent * event, const gchar ** stream_id)
1693 {
1694   const GstStructure *structure;
1695   const GValue *val;
1696 
1697   g_return_if_fail (event != NULL);
1698   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START);
1699 
1700   structure = gst_event_get_structure (event);
1701   val = gst_structure_id_get_value (structure, GST_QUARK (STREAM_ID));
1702 
1703   if (stream_id)
1704     *stream_id = g_value_get_string (val);
1705 }
1706 
1707 /**
1708  * gst_event_set_stream:
1709  * @event: a stream-start event
1710  * @stream: (transfer none): the stream object to set
1711  *
1712  * Set the @stream on the stream-start @event
1713  *
1714  * Since: 1.10
1715  */
1716 void
1717 gst_event_set_stream (GstEvent * event, GstStream * stream)
1718 {
1719   g_return_if_fail (event != NULL);
1720   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START);
1721   g_return_if_fail (gst_event_is_writable (event));
1722 
1723   gst_structure_id_set (GST_EVENT_STRUCTURE (event),
1724       GST_QUARK (STREAM), GST_TYPE_STREAM, stream, NULL);
1725 }
1726 
1727 /**
1728  * gst_event_parse_stream:
1729  * @event: a stream-start event
<a name="7" id="anc7"></a><span class="line-modified">1730  * @stream: (out) (transfer full): address of variable to store the stream</span>
1731  *
1732  * Parse a stream-start @event and extract the #GstStream from it.
1733  *
1734  * Since: 1.10
1735  */
1736 void
1737 gst_event_parse_stream (GstEvent * event, GstStream ** stream)
1738 {
1739   g_return_if_fail (event != NULL);
1740   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START);
1741 
1742   if (stream) {
1743     gst_structure_id_get (GST_EVENT_STRUCTURE (event),
1744         GST_QUARK (STREAM), GST_TYPE_STREAM, stream, NULL);
1745   }
1746 
1747 }
1748 
1749 /**
1750  * gst_event_set_stream_flags:
1751  * @event: a stream-start event
1752  * @flags: the stream flags to set
1753  *
1754  * Since: 1.2
1755  */
1756 void
1757 gst_event_set_stream_flags (GstEvent * event, GstStreamFlags flags)
1758 {
1759   g_return_if_fail (event != NULL);
1760   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START);
1761   g_return_if_fail (gst_event_is_writable (event));
1762 
1763   gst_structure_id_set (GST_EVENT_STRUCTURE (event),
1764       GST_QUARK (FLAGS), GST_TYPE_STREAM_FLAGS, flags, NULL);
1765 }
1766 
1767 /**
1768  * gst_event_parse_stream_flags:
1769  * @event: a stream-start event
1770  * @flags: (out): address of variable where to store the stream flags
1771  *
1772  * Since: 1.2
1773  */
1774 void
1775 gst_event_parse_stream_flags (GstEvent * event, GstStreamFlags * flags)
1776 {
1777   g_return_if_fail (event != NULL);
1778   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START);
1779 
1780   if (flags) {
1781     gst_structure_id_get (GST_EVENT_STRUCTURE (event),
1782         GST_QUARK (FLAGS), GST_TYPE_STREAM_FLAGS, flags, NULL);
1783   }
1784 }
1785 
1786 /**
1787  * gst_event_set_group_id:
1788  * @event: a stream-start event
1789  * @group_id: the group id to set
1790  *
1791  * All streams that have the same group id are supposed to be played
1792  * together, i.e. all streams inside a container file should have the
1793  * same group id but different stream ids. The group id should change
1794  * each time the stream is started, resulting in different group ids
1795  * each time a file is played for example.
1796  *
1797  * Use gst_util_group_id_next() to get a new group id.
1798  *
1799  * Since: 1.2
1800  */
1801 void
1802 gst_event_set_group_id (GstEvent * event, guint group_id)
1803 {
1804   g_return_if_fail (event != NULL);
1805   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START);
1806   g_return_if_fail (gst_event_is_writable (event));
1807 
1808   gst_structure_id_set (GST_EVENT_STRUCTURE (event),
1809       GST_QUARK (GROUP_ID), G_TYPE_UINT, group_id, NULL);
1810 }
1811 
1812 /**
1813  * gst_event_parse_group_id:
1814  * @event: a stream-start event
1815  * @group_id: (out): address of variable where to store the group id
1816  *
1817  * Returns: %TRUE if a group id was set on the event and could be parsed,
1818  *   %FALSE otherwise.
1819  *
1820  * Since: 1.2
1821  */
1822 gboolean
1823 gst_event_parse_group_id (GstEvent * event, guint * group_id)
1824 {
1825   g_return_val_if_fail (event != NULL, FALSE);
1826   g_return_val_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START,
1827       FALSE);
1828 
1829   if (group_id) {
1830     return gst_structure_id_get (GST_EVENT_STRUCTURE (event),
1831         GST_QUARK (GROUP_ID), G_TYPE_UINT, group_id, NULL);
1832   }
1833 
1834   return TRUE;
1835 }
1836 
1837 /**
1838  * gst_event_new_stream_collection:
1839  * @collection: Active collection for this data flow
1840  *
1841  * Create a new STREAM_COLLECTION event. The stream collection event can only
1842  * travel downstream synchronized with the buffer flow.
1843  *
1844  * Source elements, demuxers and other elements that manage collections
1845  * of streams and post #GstStreamCollection messages on the bus also send
1846  * this event downstream on each pad involved in the collection, so that
1847  * activation of a new collection can be tracked through the downstream
1848  * data flow.
1849  *
1850  * Returns: (transfer full): the new STREAM_COLLECTION event.
1851  *
1852  * Since: 1.10
1853  */
1854 GstEvent *
1855 gst_event_new_stream_collection (GstStreamCollection * collection)
1856 {
1857   GstStructure *s;
1858 
1859   g_return_val_if_fail (collection != NULL, NULL);
1860   g_return_val_if_fail (GST_IS_STREAM_COLLECTION (collection), NULL);
1861 
1862   s = gst_structure_new_id (GST_QUARK (EVENT_STREAM_COLLECTION),
1863       GST_QUARK (COLLECTION), GST_TYPE_STREAM_COLLECTION, collection, NULL);
1864 
1865   return gst_event_new_custom (GST_EVENT_STREAM_COLLECTION, s);
1866 }
1867 
1868 /**
1869  * gst_event_parse_stream_collection:
1870  * @event: a stream-collection event
1871  * @collection: (out): pointer to store the collection
1872  *
1873  * Retrieve new #GstStreamCollection from STREAM_COLLECTION event @event.
1874  *
1875  * Since: 1.10
1876  */
1877 void
1878 gst_event_parse_stream_collection (GstEvent * event,
1879     GstStreamCollection ** collection)
1880 {
1881   const GstStructure *structure;
1882 
1883   g_return_if_fail (event != NULL);
1884   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_COLLECTION);
1885 
1886   structure = gst_event_get_structure (event);
1887 
1888   if (collection) {
1889     gst_structure_id_get (structure,
1890         GST_QUARK (COLLECTION), GST_TYPE_STREAM_COLLECTION, collection, NULL);
1891   }
1892 }
1893 
1894 /**
1895  * gst_event_new_toc:
1896  * @toc: (transfer none): #GstToc structure.
1897  * @updated: whether @toc was updated or not.
1898  *
1899  * Generate a TOC event from the given @toc. The purpose of the TOC event is to
1900  * inform elements that some kind of the TOC was found.
1901  *
1902  * Returns: (transfer full): a new #GstEvent.
1903  */
1904 GstEvent *
1905 gst_event_new_toc (GstToc * toc, gboolean updated)
1906 {
1907   GstStructure *toc_struct;
1908   GQuark id;
1909 
1910   g_return_val_if_fail (toc != NULL, NULL);
1911 
1912   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating toc event&quot;);
1913 
1914   /* need different structure names so sticky_multi event stuff on pads
1915    * works, i.e. both TOC events are kept around */
1916   if (gst_toc_get_scope (toc) == GST_TOC_SCOPE_GLOBAL)
1917     id = GST_QUARK (EVENT_TOC_GLOBAL);
1918   else
1919     id = GST_QUARK (EVENT_TOC_CURRENT);
1920 
1921   toc_struct = gst_structure_new_id (id,
1922       GST_QUARK (TOC), GST_TYPE_TOC, toc,
1923       GST_QUARK (UPDATED), G_TYPE_BOOLEAN, updated, NULL);
1924 
1925   return gst_event_new_custom (GST_EVENT_TOC, toc_struct);
1926 }
1927 
1928 /**
1929  * gst_event_parse_toc:
1930  * @event: a TOC event.
1931  * @toc: (out) (transfer full): pointer to #GstToc structure.
1932  * @updated: (out): pointer to store TOC updated flag.
1933  *
1934  * Parse a TOC @event and store the results in the given @toc and @updated locations.
1935  */
1936 void
1937 gst_event_parse_toc (GstEvent * event, GstToc ** toc, gboolean * updated)
1938 {
1939   const GstStructure *structure;
1940 
1941   g_return_if_fail (event != NULL);
1942   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_TOC);
1943   g_return_if_fail (toc != NULL);
1944 
1945   structure = gst_event_get_structure (event);
1946 
1947   gst_structure_id_get (structure,
1948       GST_QUARK (TOC), GST_TYPE_TOC, toc,
1949       GST_QUARK (UPDATED), G_TYPE_BOOLEAN, updated, NULL);
1950 }
1951 
1952 /**
1953  * gst_event_new_toc_select:
1954  * @uid: UID in the TOC to start playback from.
1955  *
1956  * Generate a TOC select event with the given @uid. The purpose of the
1957  * TOC select event is to start playback based on the TOC&#39;s entry with the
1958  * given @uid.
1959  *
1960  * Returns: a new #GstEvent.
1961  */
1962 GstEvent *
1963 gst_event_new_toc_select (const gchar * uid)
1964 {
1965   GstStructure *structure;
1966 
1967   g_return_val_if_fail (uid != NULL, NULL);
1968 
1969   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating toc select event for UID: %s&quot;, uid);
1970 
1971   structure = gst_structure_new_id (GST_QUARK (EVENT_TOC_SELECT),
1972       GST_QUARK (UID), G_TYPE_STRING, uid, NULL);
1973 
1974   return gst_event_new_custom (GST_EVENT_TOC_SELECT, structure);
1975 }
1976 
1977 /**
1978  * gst_event_parse_toc_select:
1979  * @event: a TOC select event.
1980  * @uid: (out) (transfer full) (allow-none): storage for the selection UID.
1981  *
1982  * Parse a TOC select @event and store the results in the given @uid location.
1983  */
1984 void
1985 gst_event_parse_toc_select (GstEvent * event, gchar ** uid)
1986 {
1987   const GstStructure *structure;
1988   const GValue *val;
1989 
1990   g_return_if_fail (event != NULL);
1991   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_TOC_SELECT);
1992 
1993   structure = gst_event_get_structure (event);
1994   val = gst_structure_id_get_value (structure, GST_QUARK (UID));
1995 
1996   if (uid != NULL)
1997     *uid = g_strdup (g_value_get_string (val));
1998 
1999 }
2000 
2001 /**
2002  * gst_event_new_protection:
2003  * @system_id: (transfer none): a string holding a UUID that uniquely
2004  * identifies a protection system.
2005  * @data: (transfer none): a #GstBuffer holding protection system specific
2006  * information. The reference count of the buffer will be incremented by one.
2007  * @origin: a string indicating where the protection
2008  * information carried in the event was extracted from. The allowed values
2009  * of this string will depend upon the protection scheme.
2010  *
2011  * Creates a new event containing information specific to a particular
2012  * protection system (uniquely identified by @system_id), by which that
2013  * protection system can acquire key(s) to decrypt a protected stream.
2014  *
2015  * In order for a decryption element to decrypt media
2016  * protected using a specific system, it first needs all the
2017  * protection system specific information necessary to acquire the decryption
2018  * key(s) for that stream. The functions defined here enable this information
2019  * to be passed in events from elements that extract it
2020  * (e.g., ISOBMFF demuxers, MPEG DASH demuxers) to protection decrypter
2021  * elements that use it.
2022  *
2023  * Events containing protection system specific information are created using
2024  * #gst_event_new_protection, and they can be parsed by downstream elements
2025  * using #gst_event_parse_protection.
2026  *
2027  * In Common Encryption, protection system specific information may be located
2028  * within ISOBMFF files, both in movie (moov) boxes and movie fragment (moof)
2029  * boxes; it may also be contained in ContentProtection elements within MPEG
2030  * DASH MPDs. The events created by #gst_event_new_protection contain data
2031  * identifying from which of these locations the encapsulated protection system
2032  * specific information originated. This origin information is required as
2033  * some protection systems use different encodings depending upon where the
2034  * information originates.
2035  *
2036  * The events returned by gst_event_new_protection() are implemented
2037  * in such a way as to ensure that the most recently-pushed protection info
2038  * event of a particular @origin and @system_id will
2039  * be stuck to the output pad of the sending element.
2040  *
2041  * Returns: a #GST_EVENT_PROTECTION event, if successful; %NULL
2042  * if unsuccessful.
2043  *
2044  * Since: 1.6
2045  */
2046 GstEvent *
2047 gst_event_new_protection (const gchar * system_id,
2048     GstBuffer * data, const gchar * origin)
2049 {
2050   gchar *event_name;
2051   GstEvent *event;
2052   GstStructure *s;
2053 
2054   g_return_val_if_fail (system_id != NULL, NULL);
2055   g_return_val_if_fail (data != NULL, NULL);
2056 
2057   event_name =
2058       g_strconcat (&quot;GstProtectionEvent&quot;, origin ? &quot;-&quot; : &quot;&quot;,
2059       origin ? origin : &quot;&quot;, &quot;-&quot;, system_id, NULL);
2060 
2061   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating protection event %s&quot;, event_name);
2062 
2063   s = gst_structure_new (event_name, &quot;data&quot;, GST_TYPE_BUFFER, data,
2064       &quot;system_id&quot;, G_TYPE_STRING, system_id, NULL);
2065   if (origin)
2066     gst_structure_set (s, &quot;origin&quot;, G_TYPE_STRING, origin, NULL);
2067   event = gst_event_new_custom (GST_EVENT_PROTECTION, s);
2068 
2069   g_free (event_name);
2070   return event;
2071 }
2072 
2073 /**
2074  * gst_event_parse_protection:
2075  * @event: a #GST_EVENT_PROTECTION event.
2076  * @system_id: (out) (allow-none) (transfer none): pointer to store the UUID
2077  * string uniquely identifying a content protection system.
2078  * @data: (out) (allow-none) (transfer none): pointer to store a #GstBuffer
2079  * holding protection system specific information.
2080  * @origin: (out) (allow-none) (transfer none): pointer to store a value that
2081  * indicates where the protection information carried by @event was extracted
2082  * from.
2083  *
2084  * Parses an event containing protection system specific information and stores
2085  * the results in @system_id, @data and @origin. The data stored in @system_id,
2086  * @origin and @data are valid until @event is released.
2087  *
2088  * Since: 1.6
2089  */
2090 void
2091 gst_event_parse_protection (GstEvent * event, const gchar ** system_id,
2092     GstBuffer ** data, const gchar ** origin)
2093 {
2094   const GstStructure *s;
2095 
2096   g_return_if_fail (event != NULL);
2097   g_return_if_fail (GST_IS_EVENT (event));
2098   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_PROTECTION);
2099 
2100   s = gst_event_get_structure (event);
2101 
2102   if (origin)
2103     *origin = gst_structure_get_string (s, &quot;origin&quot;);
2104 
2105   if (system_id)
2106     *system_id = gst_structure_get_string (s, &quot;system_id&quot;);
2107 
2108   if (data) {
2109     const GValue *value = gst_structure_get_value (s, &quot;data&quot;);
2110     *data = gst_value_get_buffer (value);
2111   }
2112 }
2113 
2114 /**
2115  * gst_event_new_segment_done:
2116  * @format: The format of the position being done
2117  * @position: The position of the segment being done
2118  *
2119  * Create a new segment-done event. This event is sent by elements that
2120  * finish playback of a segment as a result of a segment seek.
2121  *
2122  * Returns: (transfer full): a new #GstEvent
2123  */
2124 GstEvent *
2125 gst_event_new_segment_done (GstFormat format, gint64 position)
2126 {
2127   GstEvent *event;
2128   GstStructure *structure;
2129 
2130   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating segment-done event&quot;);
2131 
2132   structure = gst_structure_new_id (GST_QUARK (EVENT_SEGMENT_DONE),
2133       GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,
2134       GST_QUARK (POSITION), G_TYPE_INT64, position, NULL);
2135 
2136   event = gst_event_new_custom (GST_EVENT_SEGMENT_DONE, structure);
2137 
2138   return event;
2139 }
2140 
2141 /**
2142  * gst_event_parse_segment_done:
2143  * @event: A valid #GstEvent of type GST_EVENT_SEGMENT_DONE.
2144  * @format: (out) (allow-none): Result location for the format, or %NULL
2145  * @position: (out) (allow-none): Result location for the position, or %NULL
2146  *
2147  * Extracts the position and format from the segment done message.
2148  *
2149  */
2150 void
2151 gst_event_parse_segment_done (GstEvent * event, GstFormat * format,
2152     gint64 * position)
2153 {
2154   const GstStructure *structure;
2155   const GValue *val;
2156 
2157   g_return_if_fail (event != NULL);
2158   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_SEGMENT_DONE);
2159 
2160   structure = gst_event_get_structure (event);
2161 
2162   val = gst_structure_id_get_value (structure, GST_QUARK (FORMAT));
2163   if (format != NULL)
2164     *format = g_value_get_enum (val);
2165 
2166   val = gst_structure_id_get_value (structure, GST_QUARK (POSITION));
2167   if (position != NULL)
2168     *position = g_value_get_int64 (val);
2169 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>