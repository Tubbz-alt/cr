<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/pbutils/descriptions.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="codec-utils.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstaudiovisualizer.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/pbutils/descriptions.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 174   {&quot;audio/x-tta&quot;, N_(&quot;Lossless True Audio (TTA)&quot;), FLAG_AUDIO, &quot;tta&quot;},
 175   {&quot;audio/x-ttafile&quot;, N_(&quot;Lossless True Audio (TTA)&quot;), FLAG_AUDIO, &quot;tta&quot;},
 176   {&quot;audio/x-vnd.sony.atrac3&quot;, &quot;Sony ATRAC3&quot;, FLAG_AUDIO, &quot;&quot;},
 177   {&quot;audio/x-vorbis&quot;, &quot;Vorbis&quot;, FLAG_AUDIO, &quot;&quot;},
 178   {&quot;audio/x-voc&quot;, &quot;SoundBlaster VOC&quot;, FLAG_AUDIO, &quot;&quot;},
 179   {&quot;audio/x-w64&quot;, &quot;Sonic Foundry Wave64&quot;, AUDIO_CONTAINER, &quot;w64&quot;},
 180   {&quot;audio/x-wav&quot;, &quot;WAV&quot;, AUDIO_CONTAINER, &quot;wav&quot;},
 181   {&quot;audio/x-wavpack&quot;, &quot;Wavpack&quot;, FLAG_AUDIO, &quot;wp&quot;},
 182   {&quot;audio/x-wavpack-correction&quot;, &quot;Wavpack&quot;, 0, &quot;wpc&quot;},
 183   {&quot;audio/x-wms&quot;, N_(&quot;Windows Media Speech&quot;), FLAG_AUDIO, &quot;&quot;},
 184   {&quot;audio/x-voxware&quot;, &quot;Voxware&quot;, FLAG_AUDIO, &quot;&quot;},
 185   {&quot;audio/x-xi&quot;, &quot;Fasttracker 2 Extended Instrument&quot;, FLAG_AUDIO, &quot;xi&quot;},
 186 
 187 
 188   /* video formats with static descriptions */
 189   {&quot;video/sp5x&quot;, &quot;Sunplus JPEG 5.x&quot;, FLAG_VIDEO, &quot;&quot;},
 190   {&quot;video/vivo&quot;, &quot;Vivo&quot;, FLAG_VIDEO, &quot;&quot;},
 191   {&quot;video/x-4xm&quot;, &quot;4X Technologies Video&quot;, FLAG_VIDEO, &quot;&quot;},
 192   {&quot;video/x-apple-video&quot;, &quot;Apple video&quot;, FLAG_VIDEO, &quot;&quot;},
 193   {&quot;video/x-aasc&quot;, &quot;Autodesk Animator&quot;, FLAG_VIDEO, &quot;&quot;},

 194   {&quot;video/x-camtasia&quot;, &quot;TechSmith Camtasia&quot;, FLAG_VIDEO, &quot;&quot;},
 195   {&quot;video/x-cavs&quot;, &quot;Chinese AVS (CAVS)&quot;, FLAG_VIDEO, &quot;&quot;},
 196   {&quot;video/x-cdxa&quot;, &quot;RIFF/CDXA (VCD)&quot;, AV_CONTAINER, &quot;&quot;},
 197   {&quot;video/x-cinepak&quot;, &quot;Cinepak Video&quot;, FLAG_VIDEO, &quot;&quot;},
 198   {&quot;video/x-cirrus-logic-accupak&quot;, &quot;Cirrus Logipak AccuPak&quot;, FLAG_VIDEO, &quot;&quot;},
 199   {&quot;video/x-compressed-yuv&quot;, N_(&quot;CYUV Lossless&quot;), FLAG_VIDEO, &quot;&quot;},
 200   {&quot;video/x-dnxhd&quot;, &quot;Digital Nonlinear Extensible High Definition (DNxHD)&quot;,
 201       FLAG_VIDEO, &quot;&quot;},
 202   {&quot;subpicture/x-dvd&quot;, &quot;DVD subpicture&quot;, FLAG_VIDEO, &quot;&quot;},
 203   {&quot;video/x-ffv&quot;, N_(&quot;FFMpeg v1&quot;), FLAG_VIDEO, &quot;&quot;},
 204   {&quot;video/x-flash-screen&quot;, &quot;Flash Screen Video&quot;, FLAG_VIDEO, &quot;&quot;},
 205   {&quot;video/x-flash-video&quot;, &quot;Sorenson Spark Video&quot;, FLAG_VIDEO, &quot;&quot;},
 206   {&quot;video/x-h261&quot;, &quot;H.261&quot;, FLAG_VIDEO, &quot;&quot;},
 207   {&quot;video/x-huffyuv&quot;, &quot;Huffyuv&quot;, FLAG_VIDEO, &quot;&quot;},
 208   {&quot;video/x-intel-h263&quot;, &quot;Intel H.263&quot;, FLAG_VIDEO, &quot;&quot;},
 209   {&quot;video/x-jpeg&quot;, &quot;Motion JPEG&quot;, FLAG_VIDEO, &quot;&quot;},
 210   /* { &quot;video/x-jpeg-b&quot;, &quot;&quot;, 0 }, does this actually exist? */
 211   {&quot;video/x-loco&quot;, &quot;LOCO Lossless&quot;, FLAG_VIDEO, &quot;&quot;},
 212   {&quot;video/x-mimic&quot;, &quot;MIMIC&quot;, FLAG_VIDEO, &quot;&quot;},
 213   {&quot;video/x-mjpeg&quot;, &quot;Motion-JPEG&quot;, FLAG_VIDEO, &quot;&quot;},
</pre>
<hr />
<pre>
 267   {&quot;image/x-quicktime&quot;, &quot;QuickTime Image Format (QTIF)&quot;,
 268       FLAG_IMAGE | FLAG_CONTAINER, &quot;.mov&quot;},
 269   {&quot;image/x-sun-raster&quot;, &quot;Sun Raster Format (RAS)&quot;, FLAG_IMAGE, &quot;&quot;},
 270   {&quot;image/x-tga&quot;, &quot;TGA&quot;, FLAG_IMAGE, &quot;tga&quot;},
 271   {&quot;image/vnd.wap.wbmp&quot;, &quot;Wireless Bitmap&quot;, FLAG_IMAGE, &quot;wbmp&quot;},
 272 
 273   /* subtitle formats with static descriptions */
 274   {&quot;text/x-raw&quot;, N_(&quot;Timed Text&quot;), FLAG_SUB, &quot;&quot;},
 275   {&quot;application/x-ssa&quot;, &quot;SubStation Alpha&quot;, FLAG_SUB, &quot;&quot;},
 276   {&quot;application/x-ass&quot;, &quot;Advanced SubStation Alpha&quot;, FLAG_SUB, &quot;&quot;},
 277   /* FIXME: add variant field to typefinder? */
 278   {&quot;application/x-subtitle&quot;, N_(&quot;Subtitle&quot;), FLAG_SUB, &quot;&quot;},
 279   {&quot;application/x-subtitle-mpl2&quot;, N_(&quot;MPL2 subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 280   {&quot;application/x-subtitle-dks&quot;, N_(&quot;DKS subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 281   {&quot;application/x-subtitle-qttext&quot;, N_(&quot;QTtext subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 282   {&quot;application/x-subtitle-sami&quot;, N_(&quot;Sami subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 283   {&quot;application/x-subtitle-tmplayer&quot;, N_(&quot;TMPlayer subtitle format&quot;), FLAG_SUB,
 284       &quot;&quot;},
 285   {&quot;application/x-teletext&quot;, &quot;Teletext&quot;, 0, &quot;&quot;},
 286   {&quot;application/x-kate&quot;, &quot;Kate&quot;, 0, &quot;&quot;},


 287   {&quot;subtitle/x-kate&quot;, N_(&quot;Kate subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 288   {&quot;application/x-subtitle-vtt&quot;, N_(&quot;WebVTT subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 289   {&quot;subpicture/x-dvb&quot;, &quot;DVB subtitles&quot;, FLAG_SUB, &quot;&quot;},
 290   {&quot;subpicture/x-pgs&quot;, &quot;PGS subtitles&quot;, FLAG_SUB, &quot;&quot;},
 291   {&quot;subpicture/x-xsub&quot;, &quot;XSUB subtitles&quot;, FLAG_SUB, &quot;&quot;},
 292 
 293   /* non-audio/video/container formats */
 294   {&quot;hdv/aux-v&quot;, &quot;HDV AUX-V&quot;, 0, &quot;&quot;},
 295   {&quot;hdv/aux-a&quot;, &quot;HDV AUX-A&quot;, 0, &quot;&quot;},
 296 
 297   /* formats with dynamic descriptions */
 298   {&quot;audio/mpeg&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 299   {&quot;audio/x-adpcm&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 300   {&quot;audio/x-mace&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 301   {&quot;audio/x-pn-realaudio&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 302   {&quot;audio/x-raw&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 303   {&quot;audio/x-wma&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 304   {&quot;video/mpeg&quot;, NULL, AVS_CONTAINER | FLAG_SYSTEMSTREAM, &quot;mpg&quot;},
 305   {&quot;video/mpeg&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 306   {&quot;video/x-asus&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
</pre>
<hr />
<pre>
 485 
 486     if (GST_VIDEO_FORMAT_INFO_IS_GRAY (finfo)) {
 487       ret = g_strdup (_(&quot;Uncompressed gray&quot;));
 488     } else if (GST_VIDEO_FORMAT_INFO_IS_YUV (finfo)) {
 489       const gchar *subs;
 490       gint w_sub, h_sub, n_semi;
 491 
 492       w_sub = GST_VIDEO_FORMAT_INFO_W_SUB (finfo, 1);
 493       h_sub = GST_VIDEO_FORMAT_INFO_H_SUB (finfo, 1);
 494 
 495       if (w_sub == 1 &amp;&amp; h_sub == 1) {
 496         subs = &quot;4:4:4&quot;;
 497       } else if (w_sub == 2 &amp;&amp; h_sub == 1) {
 498         subs = &quot;4:2:2&quot;;
 499       } else if (w_sub == 2 &amp;&amp; h_sub == 2) {
 500         subs = &quot;4:2:0&quot;;
 501       } else if (w_sub == 4 &amp;&amp; h_sub == 1) {
 502         subs = &quot;4:1:1&quot;;
 503       } else {
 504         subs = &quot;&quot;;
<span class="line-modified"> 505     }</span>
 506 
 507       n_semi = GST_VIDEO_FORMAT_INFO_HAS_ALPHA (finfo) ? 3 : 2;
 508 
 509       if (GST_VIDEO_FORMAT_INFO_N_PLANES (finfo) == 1) {
 510         ret = g_strdup_printf (_(&quot;Uncompressed packed YUV %s&quot;), subs);
 511       } else if (GST_VIDEO_FORMAT_INFO_N_PLANES (finfo) == n_semi) {
 512         ret = g_strdup_printf (_(&quot;Uncompressed semi-planar YUV %s&quot;), subs);
<span class="line-modified"> 513     } else {</span>
 514         ret = g_strdup_printf (_(&quot;Uncompressed planar YUV %s&quot;), subs);
<span class="line-modified"> 515     }</span>
 516     } else if (GST_VIDEO_FORMAT_INFO_IS_RGB (finfo)) {
 517       gboolean alpha, palette;
 518       gint bits;
 519 
 520       alpha = GST_VIDEO_FORMAT_INFO_HAS_ALPHA (finfo);
 521       palette = GST_VIDEO_FORMAT_INFO_HAS_PALETTE (finfo);
 522       bits = GST_VIDEO_FORMAT_INFO_BITS (finfo);
 523 
 524       if (palette) {
 525         ret = g_strdup_printf (_(&quot;Uncompressed palettized %d-bit %s&quot;),
 526             bits, alpha ? &quot;RGBA&quot; : &quot;RGB&quot;);
 527       } else {
 528         ret = g_strdup_printf (_(&quot;Uncompressed %d-bit %s&quot;),
 529             bits, alpha ? &quot;RGBA&quot; : &quot;RGB&quot;);
 530       }
 531     } else {
 532       ret = g_strdup (_(&quot;Uncompressed video&quot;));
 533     }
 534     return ret;
 535   } else if (strcmp (info-&gt;type, &quot;video/x-h263&quot;) == 0) {
</pre>
<hr />
<pre>
 560     const gchar *profile;
 561 
 562     variant = gst_structure_get_string (s, &quot;variant&quot;);
 563     if (variant == NULL)
 564       ret = &quot;H.264&quot;;
 565     else if (strcmp (variant, &quot;itu&quot;) == 0)
 566       ret = &quot;ITU H.264&quot;;
 567     else if (strcmp (variant, &quot;videosoft&quot;) == 0)
 568       ret = &quot;Videosoft H.264&quot;;
 569     else if (strcmp (variant, &quot;lead&quot;) == 0)
 570       ret = &quot;Lead H.264&quot;;
 571     else {
 572       GST_WARNING (&quot;Unknown H264 variant &#39;%s&#39;&quot;, variant);
 573       ret = &quot;H.264&quot;;
 574     }
 575     /* profile */
 576     profile = gst_structure_get_string (s, &quot;profile&quot;);
 577     if (profile != NULL)
 578       profile = pbutils_desc_get_h264_profile_name_from_nick (profile);
 579     if (profile == NULL)
<span class="line-modified"> 580     return g_strdup (ret);</span>
 581     return g_strdup_printf (&quot;%s (%s Profile)&quot;, ret, profile);
 582   } else if (strcmp (info-&gt;type, &quot;video/x-h265&quot;) == 0) {
 583     const gchar *profile = gst_structure_get_string (s, &quot;profile&quot;);
 584 
 585     if (profile != NULL)
 586       profile = pbutils_desc_get_h265_profile_name_from_nick (profile);
 587     if (profile != NULL)
 588       return g_strdup_printf (&quot;H.265 (%s Profile)&quot;, profile);
 589 
 590     return g_strdup (&quot;H.265&quot;);
 591   } else if (strcmp (info-&gt;type, &quot;video/x-dirac&quot;) == 0) {
 592     const gchar *profile = gst_structure_get_string (s, &quot;profile&quot;);
 593     if (profile == NULL)
 594       return g_strdup (&quot;Dirac&quot;);
 595     if (strcmp (profile, &quot;vc2-low-delay&quot;) == 0)
 596       return g_strdup_printf (&quot;Dirac (%s)&quot;, &quot;VC-2 Low Delay Profile&quot;);
 597     else if (strcmp (profile, &quot;vc2-simple&quot;) == 0)
 598       return g_strdup_printf (&quot;Dirac (%s)&quot;, &quot;VC-2 Simple Profile&quot;);
 599     else if (strcmp (profile, &quot;vc2-main&quot;) == 0)
 600       return g_strdup_printf (&quot;Dirac (%s)&quot;, &quot;VC-2 Main Profile&quot;);
</pre>
<hr />
<pre>
 821           &quot;%&quot; GST_PTR_FORMAT, caps);
 822       sysstream = FALSE;
 823     }
 824 
 825     if (gst_structure_get_int (s, &quot;mpegversion&quot;, &amp;ver) &amp;&amp; ver &gt; 0 &amp;&amp; ver &lt;= 4) {
 826       if (sysstream) {
 827         return g_strdup_printf (&quot;MPEG-%d System Stream&quot;, ver);
 828       } else {
 829         const gchar *profile = gst_structure_get_string (s, &quot;profile&quot;);
 830         if (profile != NULL) {
 831           if (ver == 4)
 832             profile = pbutils_desc_get_mpeg4v_profile_name_from_nick (profile);
 833           else if (ver == 2)
 834             profile = pbutils_desc_get_mpeg2v_profile_name_from_nick (profile);
 835           else
 836             profile = NULL;
 837         }
 838         if (profile != NULL)
 839           return g_strdup_printf (&quot;MPEG-%d Video (%s Profile)&quot;, ver, profile);
 840         else
<span class="line-modified"> 841         return g_strdup_printf (&quot;MPEG-%d Video&quot;, ver);</span>
 842       }
 843     }
 844     GST_WARNING (&quot;Missing mpegversion field in mpeg video caps &quot;
 845         &quot;%&quot; GST_PTR_FORMAT, caps);
 846     return g_strdup (&quot;MPEG Video&quot;);
 847   } else if (strcmp (info-&gt;type, &quot;audio/x-raw&quot;) == 0) {
 848     gint depth = 0;
 849     gboolean is_float;
 850     const gchar *str;
 851     GstAudioFormat format = GST_AUDIO_FORMAT_UNKNOWN;
 852     const GstAudioFormatInfo *finfo;
 853 
 854     str = gst_structure_get_string (s, &quot;format&quot;);
 855     if (str)
 856       format = gst_audio_format_from_string (str);
 857     if (format == GST_AUDIO_FORMAT_UNKNOWN)
 858       return g_strdup (_(&quot;Uncompressed audio&quot;));
 859 
 860     finfo = gst_audio_format_get_info (format);
 861     depth = GST_AUDIO_FORMAT_INFO_DEPTH (finfo);
 862     is_float = GST_AUDIO_FORMAT_INFO_IS_FLOAT (finfo);
 863 
 864     return g_strdup_printf (_(&quot;Raw %d-bit %s audio&quot;), depth,
 865         is_float ? &quot;floating-point&quot; : &quot;PCM&quot;);
 866   } else if (strcmp (info-&gt;type, &quot;video/x-tscc&quot;) == 0) {
 867     gint version;
 868     gst_structure_get_int (s, &quot;tsccversion&quot;, &amp;version);
 869     switch (version) {
 870       case 1:
 871         return g_strdup (&quot;TechSmith Screen Capture 1&quot;);
 872       case 2:
 873         return g_strdup (&quot;TechSmith Screen Capture 2&quot;);
 874       default:
 875         break;
<span class="line-modified"> 876   }</span>
 877     GST_WARNING (&quot;Unexpected version in %&quot; GST_PTR_FORMAT, caps);
 878     return g_strdup (&quot;TechSmith Screen Capture&quot;);
 879   }
 880   return NULL;
 881 }
 882 
 883 /* returns format info structure, will return NULL for dynamic media types! */
 884 static const FormatInfo *
 885 find_format_info (const GstCaps * caps)
 886 {
 887   const GstStructure *s;
 888   const gchar *media_type;
 889   guint i;
 890 
 891   s = gst_caps_get_structure (caps, 0);
 892   media_type = gst_structure_get_name (s);
 893 
 894   for (i = 0; i &lt; G_N_ELEMENTS (formats); ++i) {
 895     if (strcmp (media_type, formats[i].type) == 0) {
 896       gboolean is_sys = FALSE;
</pre>
</td>
<td>
<hr />
<pre>
 174   {&quot;audio/x-tta&quot;, N_(&quot;Lossless True Audio (TTA)&quot;), FLAG_AUDIO, &quot;tta&quot;},
 175   {&quot;audio/x-ttafile&quot;, N_(&quot;Lossless True Audio (TTA)&quot;), FLAG_AUDIO, &quot;tta&quot;},
 176   {&quot;audio/x-vnd.sony.atrac3&quot;, &quot;Sony ATRAC3&quot;, FLAG_AUDIO, &quot;&quot;},
 177   {&quot;audio/x-vorbis&quot;, &quot;Vorbis&quot;, FLAG_AUDIO, &quot;&quot;},
 178   {&quot;audio/x-voc&quot;, &quot;SoundBlaster VOC&quot;, FLAG_AUDIO, &quot;&quot;},
 179   {&quot;audio/x-w64&quot;, &quot;Sonic Foundry Wave64&quot;, AUDIO_CONTAINER, &quot;w64&quot;},
 180   {&quot;audio/x-wav&quot;, &quot;WAV&quot;, AUDIO_CONTAINER, &quot;wav&quot;},
 181   {&quot;audio/x-wavpack&quot;, &quot;Wavpack&quot;, FLAG_AUDIO, &quot;wp&quot;},
 182   {&quot;audio/x-wavpack-correction&quot;, &quot;Wavpack&quot;, 0, &quot;wpc&quot;},
 183   {&quot;audio/x-wms&quot;, N_(&quot;Windows Media Speech&quot;), FLAG_AUDIO, &quot;&quot;},
 184   {&quot;audio/x-voxware&quot;, &quot;Voxware&quot;, FLAG_AUDIO, &quot;&quot;},
 185   {&quot;audio/x-xi&quot;, &quot;Fasttracker 2 Extended Instrument&quot;, FLAG_AUDIO, &quot;xi&quot;},
 186 
 187 
 188   /* video formats with static descriptions */
 189   {&quot;video/sp5x&quot;, &quot;Sunplus JPEG 5.x&quot;, FLAG_VIDEO, &quot;&quot;},
 190   {&quot;video/vivo&quot;, &quot;Vivo&quot;, FLAG_VIDEO, &quot;&quot;},
 191   {&quot;video/x-4xm&quot;, &quot;4X Technologies Video&quot;, FLAG_VIDEO, &quot;&quot;},
 192   {&quot;video/x-apple-video&quot;, &quot;Apple video&quot;, FLAG_VIDEO, &quot;&quot;},
 193   {&quot;video/x-aasc&quot;, &quot;Autodesk Animator&quot;, FLAG_VIDEO, &quot;&quot;},
<span class="line-added"> 194   {&quot;video/x-av1&quot;, &quot;AV1&quot;, FLAG_VIDEO, &quot;&quot;},</span>
 195   {&quot;video/x-camtasia&quot;, &quot;TechSmith Camtasia&quot;, FLAG_VIDEO, &quot;&quot;},
 196   {&quot;video/x-cavs&quot;, &quot;Chinese AVS (CAVS)&quot;, FLAG_VIDEO, &quot;&quot;},
 197   {&quot;video/x-cdxa&quot;, &quot;RIFF/CDXA (VCD)&quot;, AV_CONTAINER, &quot;&quot;},
 198   {&quot;video/x-cinepak&quot;, &quot;Cinepak Video&quot;, FLAG_VIDEO, &quot;&quot;},
 199   {&quot;video/x-cirrus-logic-accupak&quot;, &quot;Cirrus Logipak AccuPak&quot;, FLAG_VIDEO, &quot;&quot;},
 200   {&quot;video/x-compressed-yuv&quot;, N_(&quot;CYUV Lossless&quot;), FLAG_VIDEO, &quot;&quot;},
 201   {&quot;video/x-dnxhd&quot;, &quot;Digital Nonlinear Extensible High Definition (DNxHD)&quot;,
 202       FLAG_VIDEO, &quot;&quot;},
 203   {&quot;subpicture/x-dvd&quot;, &quot;DVD subpicture&quot;, FLAG_VIDEO, &quot;&quot;},
 204   {&quot;video/x-ffv&quot;, N_(&quot;FFMpeg v1&quot;), FLAG_VIDEO, &quot;&quot;},
 205   {&quot;video/x-flash-screen&quot;, &quot;Flash Screen Video&quot;, FLAG_VIDEO, &quot;&quot;},
 206   {&quot;video/x-flash-video&quot;, &quot;Sorenson Spark Video&quot;, FLAG_VIDEO, &quot;&quot;},
 207   {&quot;video/x-h261&quot;, &quot;H.261&quot;, FLAG_VIDEO, &quot;&quot;},
 208   {&quot;video/x-huffyuv&quot;, &quot;Huffyuv&quot;, FLAG_VIDEO, &quot;&quot;},
 209   {&quot;video/x-intel-h263&quot;, &quot;Intel H.263&quot;, FLAG_VIDEO, &quot;&quot;},
 210   {&quot;video/x-jpeg&quot;, &quot;Motion JPEG&quot;, FLAG_VIDEO, &quot;&quot;},
 211   /* { &quot;video/x-jpeg-b&quot;, &quot;&quot;, 0 }, does this actually exist? */
 212   {&quot;video/x-loco&quot;, &quot;LOCO Lossless&quot;, FLAG_VIDEO, &quot;&quot;},
 213   {&quot;video/x-mimic&quot;, &quot;MIMIC&quot;, FLAG_VIDEO, &quot;&quot;},
 214   {&quot;video/x-mjpeg&quot;, &quot;Motion-JPEG&quot;, FLAG_VIDEO, &quot;&quot;},
</pre>
<hr />
<pre>
 268   {&quot;image/x-quicktime&quot;, &quot;QuickTime Image Format (QTIF)&quot;,
 269       FLAG_IMAGE | FLAG_CONTAINER, &quot;.mov&quot;},
 270   {&quot;image/x-sun-raster&quot;, &quot;Sun Raster Format (RAS)&quot;, FLAG_IMAGE, &quot;&quot;},
 271   {&quot;image/x-tga&quot;, &quot;TGA&quot;, FLAG_IMAGE, &quot;tga&quot;},
 272   {&quot;image/vnd.wap.wbmp&quot;, &quot;Wireless Bitmap&quot;, FLAG_IMAGE, &quot;wbmp&quot;},
 273 
 274   /* subtitle formats with static descriptions */
 275   {&quot;text/x-raw&quot;, N_(&quot;Timed Text&quot;), FLAG_SUB, &quot;&quot;},
 276   {&quot;application/x-ssa&quot;, &quot;SubStation Alpha&quot;, FLAG_SUB, &quot;&quot;},
 277   {&quot;application/x-ass&quot;, &quot;Advanced SubStation Alpha&quot;, FLAG_SUB, &quot;&quot;},
 278   /* FIXME: add variant field to typefinder? */
 279   {&quot;application/x-subtitle&quot;, N_(&quot;Subtitle&quot;), FLAG_SUB, &quot;&quot;},
 280   {&quot;application/x-subtitle-mpl2&quot;, N_(&quot;MPL2 subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 281   {&quot;application/x-subtitle-dks&quot;, N_(&quot;DKS subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 282   {&quot;application/x-subtitle-qttext&quot;, N_(&quot;QTtext subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 283   {&quot;application/x-subtitle-sami&quot;, N_(&quot;Sami subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 284   {&quot;application/x-subtitle-tmplayer&quot;, N_(&quot;TMPlayer subtitle format&quot;), FLAG_SUB,
 285       &quot;&quot;},
 286   {&quot;application/x-teletext&quot;, &quot;Teletext&quot;, 0, &quot;&quot;},
 287   {&quot;application/x-kate&quot;, &quot;Kate&quot;, 0, &quot;&quot;},
<span class="line-added"> 288   {&quot;closedcaption/x-cea-608&quot;, N_(&quot;CEA 608 Closed Caption&quot;), FLAG_SUB, &quot;&quot;},</span>
<span class="line-added"> 289   {&quot;closedcaption/x-cea-708&quot;, N_(&quot;CEA 708 Closed Caption&quot;), FLAG_SUB, &quot;&quot;},</span>
 290   {&quot;subtitle/x-kate&quot;, N_(&quot;Kate subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 291   {&quot;application/x-subtitle-vtt&quot;, N_(&quot;WebVTT subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 292   {&quot;subpicture/x-dvb&quot;, &quot;DVB subtitles&quot;, FLAG_SUB, &quot;&quot;},
 293   {&quot;subpicture/x-pgs&quot;, &quot;PGS subtitles&quot;, FLAG_SUB, &quot;&quot;},
 294   {&quot;subpicture/x-xsub&quot;, &quot;XSUB subtitles&quot;, FLAG_SUB, &quot;&quot;},
 295 
 296   /* non-audio/video/container formats */
 297   {&quot;hdv/aux-v&quot;, &quot;HDV AUX-V&quot;, 0, &quot;&quot;},
 298   {&quot;hdv/aux-a&quot;, &quot;HDV AUX-A&quot;, 0, &quot;&quot;},
 299 
 300   /* formats with dynamic descriptions */
 301   {&quot;audio/mpeg&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 302   {&quot;audio/x-adpcm&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 303   {&quot;audio/x-mace&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 304   {&quot;audio/x-pn-realaudio&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 305   {&quot;audio/x-raw&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 306   {&quot;audio/x-wma&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 307   {&quot;video/mpeg&quot;, NULL, AVS_CONTAINER | FLAG_SYSTEMSTREAM, &quot;mpg&quot;},
 308   {&quot;video/mpeg&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 309   {&quot;video/x-asus&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
</pre>
<hr />
<pre>
 488 
 489     if (GST_VIDEO_FORMAT_INFO_IS_GRAY (finfo)) {
 490       ret = g_strdup (_(&quot;Uncompressed gray&quot;));
 491     } else if (GST_VIDEO_FORMAT_INFO_IS_YUV (finfo)) {
 492       const gchar *subs;
 493       gint w_sub, h_sub, n_semi;
 494 
 495       w_sub = GST_VIDEO_FORMAT_INFO_W_SUB (finfo, 1);
 496       h_sub = GST_VIDEO_FORMAT_INFO_H_SUB (finfo, 1);
 497 
 498       if (w_sub == 1 &amp;&amp; h_sub == 1) {
 499         subs = &quot;4:4:4&quot;;
 500       } else if (w_sub == 2 &amp;&amp; h_sub == 1) {
 501         subs = &quot;4:2:2&quot;;
 502       } else if (w_sub == 2 &amp;&amp; h_sub == 2) {
 503         subs = &quot;4:2:0&quot;;
 504       } else if (w_sub == 4 &amp;&amp; h_sub == 1) {
 505         subs = &quot;4:1:1&quot;;
 506       } else {
 507         subs = &quot;&quot;;
<span class="line-modified"> 508       }</span>
 509 
 510       n_semi = GST_VIDEO_FORMAT_INFO_HAS_ALPHA (finfo) ? 3 : 2;
 511 
 512       if (GST_VIDEO_FORMAT_INFO_N_PLANES (finfo) == 1) {
 513         ret = g_strdup_printf (_(&quot;Uncompressed packed YUV %s&quot;), subs);
 514       } else if (GST_VIDEO_FORMAT_INFO_N_PLANES (finfo) == n_semi) {
 515         ret = g_strdup_printf (_(&quot;Uncompressed semi-planar YUV %s&quot;), subs);
<span class="line-modified"> 516       } else {</span>
 517         ret = g_strdup_printf (_(&quot;Uncompressed planar YUV %s&quot;), subs);
<span class="line-modified"> 518       }</span>
 519     } else if (GST_VIDEO_FORMAT_INFO_IS_RGB (finfo)) {
 520       gboolean alpha, palette;
 521       gint bits;
 522 
 523       alpha = GST_VIDEO_FORMAT_INFO_HAS_ALPHA (finfo);
 524       palette = GST_VIDEO_FORMAT_INFO_HAS_PALETTE (finfo);
 525       bits = GST_VIDEO_FORMAT_INFO_BITS (finfo);
 526 
 527       if (palette) {
 528         ret = g_strdup_printf (_(&quot;Uncompressed palettized %d-bit %s&quot;),
 529             bits, alpha ? &quot;RGBA&quot; : &quot;RGB&quot;);
 530       } else {
 531         ret = g_strdup_printf (_(&quot;Uncompressed %d-bit %s&quot;),
 532             bits, alpha ? &quot;RGBA&quot; : &quot;RGB&quot;);
 533       }
 534     } else {
 535       ret = g_strdup (_(&quot;Uncompressed video&quot;));
 536     }
 537     return ret;
 538   } else if (strcmp (info-&gt;type, &quot;video/x-h263&quot;) == 0) {
</pre>
<hr />
<pre>
 563     const gchar *profile;
 564 
 565     variant = gst_structure_get_string (s, &quot;variant&quot;);
 566     if (variant == NULL)
 567       ret = &quot;H.264&quot;;
 568     else if (strcmp (variant, &quot;itu&quot;) == 0)
 569       ret = &quot;ITU H.264&quot;;
 570     else if (strcmp (variant, &quot;videosoft&quot;) == 0)
 571       ret = &quot;Videosoft H.264&quot;;
 572     else if (strcmp (variant, &quot;lead&quot;) == 0)
 573       ret = &quot;Lead H.264&quot;;
 574     else {
 575       GST_WARNING (&quot;Unknown H264 variant &#39;%s&#39;&quot;, variant);
 576       ret = &quot;H.264&quot;;
 577     }
 578     /* profile */
 579     profile = gst_structure_get_string (s, &quot;profile&quot;);
 580     if (profile != NULL)
 581       profile = pbutils_desc_get_h264_profile_name_from_nick (profile);
 582     if (profile == NULL)
<span class="line-modified"> 583       return g_strdup (ret);</span>
 584     return g_strdup_printf (&quot;%s (%s Profile)&quot;, ret, profile);
 585   } else if (strcmp (info-&gt;type, &quot;video/x-h265&quot;) == 0) {
 586     const gchar *profile = gst_structure_get_string (s, &quot;profile&quot;);
 587 
 588     if (profile != NULL)
 589       profile = pbutils_desc_get_h265_profile_name_from_nick (profile);
 590     if (profile != NULL)
 591       return g_strdup_printf (&quot;H.265 (%s Profile)&quot;, profile);
 592 
 593     return g_strdup (&quot;H.265&quot;);
 594   } else if (strcmp (info-&gt;type, &quot;video/x-dirac&quot;) == 0) {
 595     const gchar *profile = gst_structure_get_string (s, &quot;profile&quot;);
 596     if (profile == NULL)
 597       return g_strdup (&quot;Dirac&quot;);
 598     if (strcmp (profile, &quot;vc2-low-delay&quot;) == 0)
 599       return g_strdup_printf (&quot;Dirac (%s)&quot;, &quot;VC-2 Low Delay Profile&quot;);
 600     else if (strcmp (profile, &quot;vc2-simple&quot;) == 0)
 601       return g_strdup_printf (&quot;Dirac (%s)&quot;, &quot;VC-2 Simple Profile&quot;);
 602     else if (strcmp (profile, &quot;vc2-main&quot;) == 0)
 603       return g_strdup_printf (&quot;Dirac (%s)&quot;, &quot;VC-2 Main Profile&quot;);
</pre>
<hr />
<pre>
 824           &quot;%&quot; GST_PTR_FORMAT, caps);
 825       sysstream = FALSE;
 826     }
 827 
 828     if (gst_structure_get_int (s, &quot;mpegversion&quot;, &amp;ver) &amp;&amp; ver &gt; 0 &amp;&amp; ver &lt;= 4) {
 829       if (sysstream) {
 830         return g_strdup_printf (&quot;MPEG-%d System Stream&quot;, ver);
 831       } else {
 832         const gchar *profile = gst_structure_get_string (s, &quot;profile&quot;);
 833         if (profile != NULL) {
 834           if (ver == 4)
 835             profile = pbutils_desc_get_mpeg4v_profile_name_from_nick (profile);
 836           else if (ver == 2)
 837             profile = pbutils_desc_get_mpeg2v_profile_name_from_nick (profile);
 838           else
 839             profile = NULL;
 840         }
 841         if (profile != NULL)
 842           return g_strdup_printf (&quot;MPEG-%d Video (%s Profile)&quot;, ver, profile);
 843         else
<span class="line-modified"> 844           return g_strdup_printf (&quot;MPEG-%d Video&quot;, ver);</span>
 845       }
 846     }
 847     GST_WARNING (&quot;Missing mpegversion field in mpeg video caps &quot;
 848         &quot;%&quot; GST_PTR_FORMAT, caps);
 849     return g_strdup (&quot;MPEG Video&quot;);
 850   } else if (strcmp (info-&gt;type, &quot;audio/x-raw&quot;) == 0) {
 851     gint depth = 0;
 852     gboolean is_float;
 853     const gchar *str;
 854     GstAudioFormat format = GST_AUDIO_FORMAT_UNKNOWN;
 855     const GstAudioFormatInfo *finfo;
 856 
 857     str = gst_structure_get_string (s, &quot;format&quot;);
 858     if (str)
 859       format = gst_audio_format_from_string (str);
 860     if (format == GST_AUDIO_FORMAT_UNKNOWN)
 861       return g_strdup (_(&quot;Uncompressed audio&quot;));
 862 
 863     finfo = gst_audio_format_get_info (format);
 864     depth = GST_AUDIO_FORMAT_INFO_DEPTH (finfo);
 865     is_float = GST_AUDIO_FORMAT_INFO_IS_FLOAT (finfo);
 866 
 867     return g_strdup_printf (_(&quot;Raw %d-bit %s audio&quot;), depth,
 868         is_float ? &quot;floating-point&quot; : &quot;PCM&quot;);
 869   } else if (strcmp (info-&gt;type, &quot;video/x-tscc&quot;) == 0) {
 870     gint version;
 871     gst_structure_get_int (s, &quot;tsccversion&quot;, &amp;version);
 872     switch (version) {
 873       case 1:
 874         return g_strdup (&quot;TechSmith Screen Capture 1&quot;);
 875       case 2:
 876         return g_strdup (&quot;TechSmith Screen Capture 2&quot;);
 877       default:
 878         break;
<span class="line-modified"> 879     }</span>
 880     GST_WARNING (&quot;Unexpected version in %&quot; GST_PTR_FORMAT, caps);
 881     return g_strdup (&quot;TechSmith Screen Capture&quot;);
 882   }
 883   return NULL;
 884 }
 885 
 886 /* returns format info structure, will return NULL for dynamic media types! */
 887 static const FormatInfo *
 888 find_format_info (const GstCaps * caps)
 889 {
 890   const GstStructure *s;
 891   const gchar *media_type;
 892   guint i;
 893 
 894   s = gst_caps_get_structure (caps, 0);
 895   media_type = gst_structure_get_name (s);
 896 
 897   for (i = 0; i &lt; G_N_ELEMENTS (formats); ++i) {
 898     if (strcmp (media_type, formats[i].type) == 0) {
 899       gboolean is_sys = FALSE;
</pre>
</td>
</tr>
</table>
<center><a href="codec-utils.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstaudiovisualizer.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>