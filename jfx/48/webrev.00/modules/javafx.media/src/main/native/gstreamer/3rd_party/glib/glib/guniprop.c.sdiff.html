<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/guniprop.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gunidecomp.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gurifuncs.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/guniprop.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  20 #include &quot;config.h&quot;
  21 
  22 #include &lt;stdlib.h&gt;
  23 #include &lt;stddef.h&gt;
  24 #include &lt;string.h&gt;
  25 #include &lt;locale.h&gt;
  26 
  27 #include &quot;gmem.h&quot;
  28 #include &quot;gstring.h&quot;
  29 #include &quot;gtestutils.h&quot;
  30 #include &quot;gtypes.h&quot;
  31 #include &quot;gunicode.h&quot;
  32 #include &quot;gunichartables.h&quot;
  33 #include &quot;gmirroringtable.h&quot;
  34 #include &quot;gscripttable.h&quot;
  35 #include &quot;gunicodeprivate.h&quot;
  36 #ifdef G_OS_WIN32
  37 #include &quot;gwin32.h&quot;
  38 #endif
  39 







  40 #define ATTR_TABLE(Page) (((Page) &lt;= G_UNICODE_LAST_PAGE_PART1) \
  41                           ? attr_table_part1[Page] \
  42                           : attr_table_part2[(Page) - 0xe00])
  43 
  44 #define ATTTABLE(Page, Char) \
  45   ((ATTR_TABLE(Page) == G_UNICODE_MAX_TABLE_INDEX) ? 0 : (attr_data[ATTR_TABLE(Page)][Char]))
  46 
  47 #define TTYPE_PART1(Page, Char) \
  48   ((type_table_part1[Page] &gt;= G_UNICODE_MAX_TABLE_INDEX) \
  49    ? (type_table_part1[Page] - G_UNICODE_MAX_TABLE_INDEX) \
  50    : (type_data[type_table_part1[Page]][Char]))
  51 
  52 #define TTYPE_PART2(Page, Char) \
  53   ((type_table_part2[Page] &gt;= G_UNICODE_MAX_TABLE_INDEX) \
  54    ? (type_table_part2[Page] - G_UNICODE_MAX_TABLE_INDEX) \
  55    : (type_data[type_table_part2[Page]][Char]))
  56 
  57 #define TYPE(Char) \
  58   (((Char) &lt;= G_UNICODE_LAST_CHAR_PART1) \
  59    ? TTYPE_PART1 ((Char) &gt;&gt; 8, (Char) &amp; 0xff) \
  60    : (((Char) &gt;= 0xe0000 &amp;&amp; (Char) &lt;= G_UNICODE_LAST_CHAR) \
  61       ? TTYPE_PART2 (((Char) - 0xe0000) &gt;&gt; 8, (Char) &amp; 0xff) \
  62       : G_UNICODE_UNASSIGNED))
  63 
  64 
  65 #define IS(Type, Class) (((guint)1 &lt;&lt; (Type)) &amp; (Class))
  66 #define OR(Type, Rest)  (((guint)1 &lt;&lt; (Type)) | (Rest))
  67 
  68 
  69 
<span class="line-modified">  70 #define ISALPHA(Type)   IS ((Type),             \</span>
<span class="line-modified">  71                 OR (G_UNICODE_LOWERCASE_LETTER, \</span>
<span class="line-modified">  72                 OR (G_UNICODE_UPPERCASE_LETTER, \</span>
<span class="line-modified">  73                 OR (G_UNICODE_TITLECASE_LETTER, \</span>
<span class="line-modified">  74                 OR (G_UNICODE_MODIFIER_LETTER,  \</span>
<span class="line-modified">  75                 OR (G_UNICODE_OTHER_LETTER,     0))))))</span>
  76 
<span class="line-modified">  77 #define ISALDIGIT(Type) IS ((Type),             \</span>
<span class="line-modified">  78                 OR (G_UNICODE_DECIMAL_NUMBER,   \</span>
<span class="line-modified">  79                 OR (G_UNICODE_LETTER_NUMBER,    \</span>
<span class="line-modified">  80                 OR (G_UNICODE_OTHER_NUMBER,     \</span>
<span class="line-modified">  81                 OR (G_UNICODE_LOWERCASE_LETTER, \</span>
<span class="line-modified">  82                 OR (G_UNICODE_UPPERCASE_LETTER, \</span>
<span class="line-modified">  83                 OR (G_UNICODE_TITLECASE_LETTER, \</span>
<span class="line-modified">  84                 OR (G_UNICODE_MODIFIER_LETTER,  \</span>
<span class="line-modified">  85                 OR (G_UNICODE_OTHER_LETTER,     0)))))))))</span>
  86 
<span class="line-modified">  87 #define ISMARK(Type)    IS ((Type),             \</span>
<span class="line-modified">  88                 OR (G_UNICODE_NON_SPACING_MARK, \</span>
<span class="line-modified">  89                 OR (G_UNICODE_SPACING_MARK, \</span>
<span class="line-modified">  90                 OR (G_UNICODE_ENCLOSING_MARK,   0))))</span>
  91 
<span class="line-modified">  92 #define ISZEROWIDTHTYPE(Type)   IS ((Type),         \</span>
<span class="line-modified">  93                 OR (G_UNICODE_NON_SPACING_MARK, \</span>
<span class="line-modified">  94                 OR (G_UNICODE_ENCLOSING_MARK,   \</span>
<span class="line-modified">  95                 OR (G_UNICODE_FORMAT,       0))))</span>
  96 
  97 /**
  98  * g_unichar_isalnum:
  99  * @c: a Unicode character
 100  *
 101  * Determines whether a character is alphanumeric.
 102  * Given some UTF-8 text, obtain a character value
 103  * with g_utf8_get_char().
 104  *
 105  * Returns: %TRUE if @c is an alphanumeric character
 106  **/
 107 gboolean
 108 g_unichar_isalnum (gunichar c)
 109 {
 110   return ISALDIGIT (TYPE (c)) ? TRUE : FALSE;
 111 }
 112 
 113 /**
 114  * g_unichar_isalpha:
 115  * @c: a Unicode character
</pre>
<hr />
<pre>
 159   return TYPE (c) == G_UNICODE_DECIMAL_NUMBER;
 160 }
 161 
 162 
 163 /**
 164  * g_unichar_isgraph:
 165  * @c: a Unicode character
 166  *
 167  * Determines whether a character is printable and not a space
 168  * (returns %FALSE for control characters, format characters, and
 169  * spaces). g_unichar_isprint() is similar, but returns %TRUE for
 170  * spaces. Given some UTF-8 text, obtain a character value with
 171  * g_utf8_get_char().
 172  *
 173  * Returns: %TRUE if @c is printable unless it&#39;s a space
 174  **/
 175 gboolean
 176 g_unichar_isgraph (gunichar c)
 177 {
 178   return !IS (TYPE(c),
<span class="line-modified"> 179           OR (G_UNICODE_CONTROL,</span>
<span class="line-modified"> 180           OR (G_UNICODE_FORMAT,</span>
<span class="line-modified"> 181           OR (G_UNICODE_UNASSIGNED,</span>
<span class="line-modified"> 182           OR (G_UNICODE_SURROGATE,</span>
<span class="line-modified"> 183           OR (G_UNICODE_SPACE_SEPARATOR,</span>
<span class="line-modified"> 184          0))))));</span>
 185 }
 186 
 187 /**
 188  * g_unichar_islower:
 189  * @c: a Unicode character
 190  *
 191  * Determines whether a character is a lowercase letter.
 192  * Given some UTF-8 text, obtain a character value with
 193  * g_utf8_get_char().
 194  *
 195  * Returns: %TRUE if @c is a lowercase letter
 196  **/
 197 gboolean
 198 g_unichar_islower (gunichar c)
 199 {
 200   return TYPE (c) == G_UNICODE_LOWERCASE_LETTER;
 201 }
 202 
 203 
 204 /**
 205  * g_unichar_isprint:
 206  * @c: a Unicode character
 207  *
 208  * Determines whether a character is printable.
 209  * Unlike g_unichar_isgraph(), returns %TRUE for spaces.
 210  * Given some UTF-8 text, obtain a character value with
 211  * g_utf8_get_char().
 212  *
 213  * Returns: %TRUE if @c is printable
 214  **/
 215 gboolean
 216 g_unichar_isprint (gunichar c)
 217 {
 218   return !IS (TYPE(c),
<span class="line-modified"> 219           OR (G_UNICODE_CONTROL,</span>
<span class="line-modified"> 220           OR (G_UNICODE_FORMAT,</span>
<span class="line-modified"> 221           OR (G_UNICODE_UNASSIGNED,</span>
<span class="line-modified"> 222           OR (G_UNICODE_SURROGATE,</span>
<span class="line-modified"> 223          0)))));</span>
 224 }
 225 
 226 /**
 227  * g_unichar_ispunct:
 228  * @c: a Unicode character
 229  *
 230  * Determines whether a character is punctuation or a symbol.
 231  * Given some UTF-8 text, obtain a character value with
 232  * g_utf8_get_char().
 233  *
 234  * Returns: %TRUE if @c is a punctuation or symbol character
 235  **/
 236 gboolean
 237 g_unichar_ispunct (gunichar c)
 238 {
 239   return IS (TYPE(c),
<span class="line-modified"> 240          OR (G_UNICODE_CONNECT_PUNCTUATION,</span>
<span class="line-modified"> 241          OR (G_UNICODE_DASH_PUNCTUATION,</span>
<span class="line-modified"> 242          OR (G_UNICODE_CLOSE_PUNCTUATION,</span>
<span class="line-modified"> 243          OR (G_UNICODE_FINAL_PUNCTUATION,</span>
<span class="line-modified"> 244          OR (G_UNICODE_INITIAL_PUNCTUATION,</span>
<span class="line-modified"> 245          OR (G_UNICODE_OTHER_PUNCTUATION,</span>
<span class="line-modified"> 246          OR (G_UNICODE_OPEN_PUNCTUATION,</span>
<span class="line-modified"> 247          OR (G_UNICODE_CURRENCY_SYMBOL,</span>
<span class="line-modified"> 248          OR (G_UNICODE_MODIFIER_SYMBOL,</span>
<span class="line-modified"> 249          OR (G_UNICODE_MATH_SYMBOL,</span>
<span class="line-modified"> 250          OR (G_UNICODE_OTHER_SYMBOL,</span>
<span class="line-modified"> 251         0)))))))))))) ? TRUE : FALSE;</span>
 252 }
 253 
 254 /**
 255  * g_unichar_isspace:
 256  * @c: a Unicode character
 257  *
 258  * Determines whether a character is a space, tab, or line separator
 259  * (newline, carriage return, etc.).  Given some UTF-8 text, obtain a
 260  * character value with g_utf8_get_char().
 261  *
 262  * (Note: don&#39;t use this to do word breaking; you have to use
 263  * Pango or equivalent to get word breaking right, the algorithm
 264  * is fairly complex.)
 265  *
 266  * Returns: %TRUE if @c is a space character
 267  **/
 268 gboolean
 269 g_unichar_isspace (gunichar c)
 270 {
 271   switch (c)
 272     {
 273       /* special-case these since Unicode thinks they are not spaces */
 274     case &#39;\t&#39;:
 275     case &#39;\n&#39;:
 276     case &#39;\r&#39;:
 277     case &#39;\f&#39;:
 278       return TRUE;
 279       break;
 280 
 281     default:
 282       {
<span class="line-modified"> 283     return IS (TYPE(c),</span>
<span class="line-modified"> 284                OR (G_UNICODE_SPACE_SEPARATOR,</span>
<span class="line-modified"> 285                OR (G_UNICODE_LINE_SEPARATOR,</span>
 286                    OR (G_UNICODE_PARAGRAPH_SEPARATOR,
<span class="line-modified"> 287           0)))) ? TRUE : FALSE;</span>
 288       }
 289       break;
 290     }
 291 }
 292 
 293 /**
 294  * g_unichar_ismark:
 295  * @c: a Unicode character
 296  *
 297  * Determines whether a character is a mark (non-spacing mark,
 298  * combining mark, or enclosing mark in Unicode speak).
 299  * Given some UTF-8 text, obtain a character value
 300  * with g_utf8_get_char().
 301  *
 302  * Note: in most cases where isalpha characters are allowed,
 303  * ismark characters should be allowed to as they are essential
 304  * for writing most European languages as well as many non-Latin
 305  * scripts.
 306  *
 307  * Returns: %TRUE if @c is a mark character
</pre>
<hr />
<pre>
 345 g_unichar_istitle (gunichar c)
 346 {
 347   unsigned int i;
 348   for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)
 349     if (title_table[i][0] == c)
 350       return TRUE;
 351   return FALSE;
 352 }
 353 
 354 /**
 355  * g_unichar_isxdigit:
 356  * @c: a Unicode character.
 357  *
 358  * Determines if a character is a hexidecimal digit.
 359  *
 360  * Returns: %TRUE if the character is a hexadecimal digit
 361  **/
 362 gboolean
 363 g_unichar_isxdigit (gunichar c)
 364 {
<span class="line-modified"> 365   return ((c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;)</span>
<span class="line-modified"> 366       || (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;)</span>
<span class="line-modified"> 367       || (TYPE (c) == G_UNICODE_DECIMAL_NUMBER));</span>


 368 }
 369 
 370 /**
 371  * g_unichar_isdefined:
 372  * @c: a Unicode character
 373  *
 374  * Determines if a given character is assigned in the Unicode
 375  * standard.
 376  *
 377  * Returns: %TRUE if the character has an assigned value
 378  **/
 379 gboolean
 380 g_unichar_isdefined (gunichar c)
 381 {
 382   return !IS (TYPE(c),
<span class="line-modified"> 383           OR (G_UNICODE_UNASSIGNED,</span>
<span class="line-modified"> 384           OR (G_UNICODE_SURROGATE,</span>
<span class="line-modified"> 385          0)));</span>
 386 }
 387 
 388 /**
 389  * g_unichar_iszerowidth:
 390  * @c: a Unicode character
 391  *
 392  * Determines if a given character typically takes zero width when rendered.
 393  * The return value is %TRUE for all non-spacing and enclosing marks
 394  * (e.g., combining accents), format characters, zero-width
 395  * space, but not U+00AD SOFT HYPHEN.
 396  *
 397  * A typical use of this function is with one of g_unichar_iswide() or
 398  * g_unichar_iswide_cjk() to determine the number of cells a string occupies
 399  * when displayed on a grid display (terminals).  However, note that not all
 400  * terminals support zero-width rendering of zero-width marks.
 401  *
 402  * Returns: %TRUE if the character has zero width
 403  *
 404  * Since: 2.14
 405  **/
 406 gboolean
 407 g_unichar_iszerowidth (gunichar c)
 408 {
 409   if (G_UNLIKELY (c == 0x00AD))
 410     return FALSE;
 411 
 412   if (G_UNLIKELY (ISZEROWIDTHTYPE (TYPE (c))))
 413     return TRUE;
 414 
 415   if (G_UNLIKELY ((c &gt;= 0x1160 &amp;&amp; c &lt; 0x1200) ||
<span class="line-modified"> 416           c == 0x200B))</span>
 417     return TRUE;
 418 
 419   return FALSE;
 420 }
 421 
 422 static int
 423 interval_compare (const void *key, const void *elt)
 424 {
 425   gunichar c = GPOINTER_TO_UINT (key);
 426   struct Interval *interval = (struct Interval *)elt;
 427 
 428   if (c &lt; interval-&gt;start)
 429     return -1;
 430   if (c &gt; interval-&gt;end)
 431     return +1;
 432 
 433   return 0;
 434 }
 435 
 436 #define G_WIDTH_TABLE_MIDPOINT (G_N_ELEMENTS (g_unicode_width_table_wide) / 2)
 437 
 438 static inline gboolean
 439 g_unichar_iswide_bsearch (gunichar ch)
 440 {
 441   int lower = 0;
 442   int upper = G_N_ELEMENTS (g_unicode_width_table_wide) - 1;
 443   static int saved_mid = G_WIDTH_TABLE_MIDPOINT;
 444   int mid = saved_mid;
 445 
 446   do
 447     {
 448       if (ch &lt; g_unicode_width_table_wide[mid].start)
<span class="line-modified"> 449     upper = mid - 1;</span>
 450       else if (ch &gt; g_unicode_width_table_wide[mid].end)
<span class="line-modified"> 451     lower = mid + 1;</span>
 452       else
<span class="line-modified"> 453     return TRUE;</span>
 454 
 455       mid = (lower + upper) / 2;
 456     }
 457   while (lower &lt;= upper);
 458 
 459   return FALSE;
 460 }
 461 
 462 /**
 463  * g_unichar_iswide:
 464  * @c: a Unicode character
 465  *
 466  * Determines if a character is typically rendered in a double-width
 467  * cell.
 468  *
 469  * Returns: %TRUE if the character is wide
 470  **/
 471 gboolean
 472 g_unichar_iswide (gunichar c)
 473 {
 474   if (c &lt; g_unicode_width_table_wide[0].start)
<span class="line-modified"> 475   return FALSE;</span>
 476   else
 477     return g_unichar_iswide_bsearch (c);
 478 }
 479 
 480 
 481 /**
 482  * g_unichar_iswide_cjk:
 483  * @c: a Unicode character
 484  *
 485  * Determines if a character is typically rendered in a double-width
 486  * cell under legacy East Asian locales.  If a character is wide according to
 487  * g_unichar_iswide(), then it is also reported wide with this function, but
 488  * the converse is not necessarily true. See the
 489  * [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)
 490  * for details.
 491  *
 492  * If a character passes the g_unichar_iswide() test then it will also pass
 493  * this test, but not the other way around.  Note that some characters may
 494  * pass both this test and g_unichar_iszerowidth().
 495  *
 496  * Returns: %TRUE if the character is wide in legacy East Asian locales
 497  *
 498  * Since: 2.12
 499  */
 500 gboolean
 501 g_unichar_iswide_cjk (gunichar c)
 502 {
 503   if (g_unichar_iswide (c))
 504     return TRUE;
 505 
 506   /* bsearch() is declared attribute(nonnull(1)) so we can&#39;t validly search
 507    * for a NULL key */
 508   if (c == 0)
 509     return FALSE;
 510 
 511   if (bsearch (GUINT_TO_POINTER (c),
 512                g_unicode_width_table_ambiguous,
 513                G_N_ELEMENTS (g_unicode_width_table_ambiguous),
 514                sizeof g_unicode_width_table_ambiguous[0],
<span class="line-modified"> 515            interval_compare))</span>
 516     return TRUE;
 517 
 518   return FALSE;
 519 }
 520 
 521 
 522 /**
 523  * g_unichar_toupper:
 524  * @c: a Unicode character
 525  *
 526  * Converts a character to uppercase.
 527  *
 528  * Returns: the result of converting @c to uppercase.
<span class="line-modified"> 529  *               If @c is not an lowercase or titlecase character,</span>
 530  *               or has no upper case equivalent @c is returned unchanged.
 531  **/
 532 gunichar
 533 g_unichar_toupper (gunichar c)
 534 {
 535   int t = TYPE (c);
 536   if (t == G_UNICODE_LOWERCASE_LETTER)
 537     {
 538       gunichar val = ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);
 539       if (val &gt;= 0x1000000)
<span class="line-modified"> 540     {</span>
<span class="line-modified"> 541       const gchar *p = special_case_table + val - 0x1000000;</span>
 542           val = g_utf8_get_char (p);
<span class="line-modified"> 543     }</span>
 544       /* Some lowercase letters, e.g., U+000AA, FEMININE ORDINAL INDICATOR,
 545        * do not have an uppercase equivalent, in which case val will be
 546        * zero.
 547        */
 548       return val ? val : c;
 549     }
 550   else if (t == G_UNICODE_TITLECASE_LETTER)
 551     {
 552       unsigned int i;
 553       for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)
<span class="line-modified"> 554     {</span>
<span class="line-modified"> 555       if (title_table[i][0] == c)</span>
<span class="line-modified"> 556         return title_table[i][1] ? title_table[i][1] : c;</span>
<span class="line-modified"> 557     }</span>
 558     }
 559   return c;
 560 }
 561 
 562 /**
 563  * g_unichar_tolower:
 564  * @c: a Unicode character.
 565  *
 566  * Converts a character to lower case.
 567  *
 568  * Returns: the result of converting @c to lower case.
 569  *               If @c is not an upperlower or titlecase character,
 570  *               or has no lowercase equivalent @c is returned unchanged.
 571  **/
 572 gunichar
 573 g_unichar_tolower (gunichar c)
 574 {
 575   int t = TYPE (c);
 576   if (t == G_UNICODE_UPPERCASE_LETTER)
 577     {
 578       gunichar val = ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);
 579       if (val &gt;= 0x1000000)
<span class="line-modified"> 580     {</span>
<span class="line-modified"> 581       const gchar *p = special_case_table + val - 0x1000000;</span>
<span class="line-modified"> 582       return g_utf8_get_char (p);</span>
<span class="line-modified"> 583     }</span>
 584       else
<span class="line-modified"> 585     {</span>
<span class="line-modified"> 586       /* Not all uppercase letters are guaranteed to have a lowercase</span>
<span class="line-modified"> 587        * equivalent.  If this is the case, val will be zero. */</span>
<span class="line-modified"> 588       return val ? val : c;</span>
<span class="line-modified"> 589     }</span>
 590     }
 591   else if (t == G_UNICODE_TITLECASE_LETTER)
 592     {
 593       unsigned int i;
 594       for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)
<span class="line-modified"> 595     {</span>
<span class="line-modified"> 596       if (title_table[i][0] == c)</span>
<span class="line-modified"> 597         return title_table[i][2];</span>
<span class="line-modified"> 598     }</span>
 599     }
 600   return c;
 601 }
 602 
 603 /**
 604  * g_unichar_totitle:
 605  * @c: a Unicode character
 606  *
 607  * Converts a character to the titlecase.
 608  *
 609  * Returns: the result of converting @c to titlecase.
 610  *               If @c is not an uppercase or lowercase character,
 611  *               @c is returned unchanged.
 612  **/
 613 gunichar
 614 g_unichar_totitle (gunichar c)
 615 {
 616   unsigned int i;






 617   for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)
 618     {
 619       if (title_table[i][0] == c || title_table[i][1] == c
<span class="line-modified"> 620       || title_table[i][2] == c)</span>
<span class="line-modified"> 621     return title_table[i][0];</span>
 622     }
 623 
 624   if (TYPE (c) == G_UNICODE_LOWERCASE_LETTER)
 625     return g_unichar_toupper (c);
 626 
 627   return c;
 628 }
 629 
 630 /**
 631  * g_unichar_digit_value:
 632  * @c: a Unicode character
 633  *
 634  * Determines the numeric value of a character as a decimal
 635  * digit.
 636  *
 637  * Returns: If @c is a decimal digit (according to
 638  * g_unichar_isdigit()), its numeric value. Otherwise, -1.
 639  **/
 640 int
 641 g_unichar_digit_value (gunichar c)
</pre>
<hr />
<pre>
 645   return -1;
 646 }
 647 
 648 /**
 649  * g_unichar_xdigit_value:
 650  * @c: a Unicode character
 651  *
 652  * Determines the numeric value of a character as a hexidecimal
 653  * digit.
 654  *
 655  * Returns: If @c is a hex digit (according to
 656  * g_unichar_isxdigit()), its numeric value. Otherwise, -1.
 657  **/
 658 int
 659 g_unichar_xdigit_value (gunichar c)
 660 {
 661   if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;)
 662     return c - &#39;A&#39; + 10;
 663   if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;)
 664     return c - &#39;a&#39; + 10;




 665   if (TYPE (c) == G_UNICODE_DECIMAL_NUMBER)
 666     return ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);
 667   return -1;
 668 }
 669 
 670 /**
 671  * g_unichar_type:
 672  * @c: a Unicode character
 673  *
 674  * Classifies a Unicode character by type.
 675  *
 676  * Returns: the type of the character.
 677  **/
 678 GUnicodeType
 679 g_unichar_type (gunichar c)
 680 {
 681   return TYPE (c);
 682 }
 683 
 684 /*
</pre>
<hr />
<pre>
 695 get_locale_type (void)
 696 {
 697 #ifdef G_OS_WIN32
 698   char *tem = g_win32_getlocale ();
 699   char locale[2];
 700 
 701   locale[0] = tem[0];
 702   locale[1] = tem[1];
 703   g_free (tem);
 704 #else
 705   const char *locale = setlocale (LC_CTYPE, NULL);
 706 
 707   if (locale == NULL)
 708     return LOCALE_NORMAL;
 709 #endif
 710 
 711   switch (locale[0])
 712     {
 713    case &#39;a&#39;:
 714       if (locale[1] == &#39;z&#39;)
<span class="line-modified"> 715     return LOCALE_TURKIC;</span>
 716       break;
 717     case &#39;l&#39;:
 718       if (locale[1] == &#39;t&#39;)
<span class="line-modified"> 719     return LOCALE_LITHUANIAN;</span>
 720       break;
 721     case &#39;t&#39;:
 722       if (locale[1] == &#39;r&#39;)
<span class="line-modified"> 723     return LOCALE_TURKIC;</span>
 724       break;
 725     }
 726 
 727   return LOCALE_NORMAL;
 728 }
 729 
 730 static gint
 731 output_marks (const char **p_inout,
<span class="line-modified"> 732           char        *out_buffer,</span>
<span class="line-modified"> 733           gboolean     remove_dot)</span>
 734 {
 735   const char *p = *p_inout;
 736   gint len = 0;
 737 
 738   while (*p)
 739     {
 740       gunichar c = g_utf8_get_char (p);
 741 
 742       if (ISMARK (TYPE (c)))
<span class="line-modified"> 743     {</span>
<span class="line-modified"> 744       if (!remove_dot || c != 0x307 /* COMBINING DOT ABOVE */)</span>
<span class="line-modified"> 745         len += g_unichar_to_utf8 (c, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-modified"> 746       p = g_utf8_next_char (p);</span>
<span class="line-modified"> 747     }</span>
 748       else
<span class="line-modified"> 749     break;</span>
 750     }
 751 
 752   *p_inout = p;
 753   return len;
 754 }
 755 
 756 static gint
 757 output_special_case (gchar *out_buffer,
<span class="line-modified"> 758              int    offset,</span>
<span class="line-modified"> 759              int    type,</span>
<span class="line-modified"> 760              int    which)</span>
 761 {
 762   const gchar *p = special_case_table + offset;
 763   gint len;
 764 
 765   if (type != G_UNICODE_TITLECASE_LETTER)
 766     p = g_utf8_next_char (p);
 767 
 768   if (which == 1)
 769     p += strlen (p) + 1;
 770 
 771   len = strlen (p);
 772   if (out_buffer)
 773     memcpy (out_buffer, p, len);
 774 
 775   return len;
 776 }
 777 
 778 static gsize
 779 real_toupper (const gchar *str,
<span class="line-modified"> 780           gssize       max_len,</span>
<span class="line-modified"> 781           gchar       *out_buffer,</span>
<span class="line-modified"> 782           LocaleType   locale_type)</span>
 783 {
 784   const gchar *p = str;
 785   const char *last = NULL;
 786   gsize len = 0;
 787   gboolean last_was_i = FALSE;
 788 
 789   while ((max_len &lt; 0 || p &lt; str + max_len) &amp;&amp; *p)
 790     {
 791       gunichar c = g_utf8_get_char (p);
 792       int t = TYPE (c);
 793       gunichar val;
 794 
 795       last = p;
 796       p = g_utf8_next_char (p);
 797 
 798       if (locale_type == LOCALE_LITHUANIAN)






 799     {
<span class="line-modified"> 800       if (c == &#39;i&#39;)</span>
<span class="line-modified"> 801         last_was_i = TRUE;</span>
<span class="line-modified"> 802       else</span>
<span class="line-modified"> 803         {</span>
<span class="line-modified"> 804           if (last_was_i)</span>
<span class="line-modified"> 805         {</span>
<span class="line-removed"> 806           /* Nasty, need to remove any dot above. Though</span>
<span class="line-removed"> 807            * I think only E WITH DOT ABOVE occurs in practice</span>
<span class="line-removed"> 808            * which could simplify this considerably.</span>
<span class="line-removed"> 809            */</span>
<span class="line-removed"> 810           gsize decomp_len, i;</span>
<span class="line-removed"> 811           gunichar decomp[G_UNICHAR_MAX_DECOMPOSITION_LENGTH];</span>
<span class="line-removed"> 812 </span>
<span class="line-removed"> 813           decomp_len = g_unichar_fully_decompose (c, FALSE, decomp, G_N_ELEMENTS (decomp));</span>
<span class="line-removed"> 814           for (i=0; i &lt; decomp_len; i++)</span>
<span class="line-removed"> 815             {</span>
<span class="line-removed"> 816               if (decomp[i] != 0x307 /* COMBINING DOT ABOVE */)</span>
<span class="line-removed"> 817             len += g_unichar_to_utf8 (g_unichar_toupper (decomp[i]), out_buffer ? out_buffer + len : NULL);</span>
<span class="line-removed"> 818             }</span>
<span class="line-removed"> 819 </span>
<span class="line-removed"> 820           len += output_marks (&amp;p, out_buffer ? out_buffer + len : NULL, TRUE);</span>
 821 
<span class="line-modified"> 822           continue;</span>




 823         }
 824 
<span class="line-modified"> 825           if (!ISMARK (t))</span>
<span class="line-modified"> 826         last_was_i = FALSE;</span>
<span class="line-modified"> 827         }</span>
 828     }
 829 





 830       if (locale_type == LOCALE_TURKIC &amp;&amp; c == &#39;i&#39;)
<span class="line-modified"> 831     {</span>
<span class="line-modified"> 832       /* i =&gt; LATIN CAPITAL LETTER I WITH DOT ABOVE */</span>
<span class="line-modified"> 833       len += g_unichar_to_utf8 (0x130, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-modified"> 834     }</span>
 835       else if (c == 0x0345) /* COMBINING GREEK YPOGEGRAMMENI */
<span class="line-modified"> 836     {</span>
<span class="line-modified"> 837       /* Nasty, need to move it after other combining marks .. this would go away if</span>
<span class="line-modified"> 838        * we normalized first.</span>
<span class="line-modified"> 839        */</span>
<span class="line-modified"> 840       len += output_marks (&amp;p, out_buffer ? out_buffer + len : NULL, FALSE);</span>
<span class="line-modified"> 841 </span>
<span class="line-modified"> 842       /* And output as GREEK CAPITAL LETTER IOTA */</span>
<span class="line-modified"> 843       len += g_unichar_to_utf8 (0x399, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-modified"> 844     }</span>
 845       else if (IS (t,
<span class="line-modified"> 846            OR (G_UNICODE_LOWERCASE_LETTER,</span>
<span class="line-modified"> 847            OR (G_UNICODE_TITLECASE_LETTER,</span>
<span class="line-modified"> 848           0))))</span>
<span class="line-modified"> 849     {</span>
<span class="line-modified"> 850       val = ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);</span>
 851 
<span class="line-modified"> 852       if (val &gt;= 0x1000000)</span>
<span class="line-modified"> 853         {</span>
<span class="line-modified"> 854           len += output_special_case (out_buffer ? out_buffer + len : NULL, val - 0x1000000, t,</span>
<span class="line-modified"> 855                       t == G_UNICODE_LOWERCASE_LETTER ? 0 : 1);</span>
<span class="line-modified"> 856         }</span>
<span class="line-modified"> 857       else</span>
<span class="line-modified"> 858         {</span>
<span class="line-modified"> 859           if (t == G_UNICODE_TITLECASE_LETTER)</span>



 860         {
<span class="line-modified"> 861           unsigned int i;</span>
<span class="line-modified"> 862           for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)</span>
<span class="line-modified"> 863             {</span>
<span class="line-modified"> 864               if (title_table[i][0] == c)</span>
<span class="line-modified"> 865             {</span>
<span class="line-removed"> 866               val = title_table[i][1];</span>
<span class="line-removed"> 867               break;</span>
<span class="line-removed"> 868             }</span>
<span class="line-removed"> 869             }</span>
<span class="line-removed"> 870         }</span>
<span class="line-removed"> 871 </span>
<span class="line-removed"> 872           /* Some lowercase letters, e.g., U+000AA, FEMININE ORDINAL INDICATOR,</span>
<span class="line-removed"> 873            * do not have an uppercase equivalent, in which case val will be</span>
<span class="line-removed"> 874            * zero. */</span>
<span class="line-removed"> 875           len += g_unichar_to_utf8 (val ? val : c, out_buffer ? out_buffer + len : NULL);</span>
 876         }
 877     }







 878       else
<span class="line-modified"> 879     {</span>
<span class="line-modified"> 880       gsize char_len = g_utf8_skip[*(guchar *)last];</span>
 881 
<span class="line-modified"> 882       if (out_buffer)</span>
<span class="line-modified"> 883         memcpy (out_buffer + len, last, char_len);</span>
 884 
<span class="line-modified"> 885       len += char_len;</span>
<span class="line-modified"> 886     }</span>
 887 
 888     }
 889 
 890   return len;
 891 }
 892 
 893 /**
 894  * g_utf8_strup:
 895  * @str: a UTF-8 encoded string
 896  * @len: length of @str, in bytes, or -1 if @str is nul-terminated.
 897  *
 898  * Converts all Unicode characters in the string that have a case
 899  * to uppercase. The exact manner that this is done depends
 900  * on the current locale, and may result in the number of
 901  * characters in the string increasing. (For instance, the
 902  * German ess-zet will be changed to SS.)
 903  *
 904  * Returns: a newly allocated string, with all characters
 905  *    converted to uppercase.
 906  **/
 907 gchar *
 908 g_utf8_strup (const gchar *str,
<span class="line-modified"> 909           gssize       len)</span>
 910 {
 911   gsize result_len;
 912   LocaleType locale_type;
 913   gchar *result;
 914 
 915   g_return_val_if_fail (str != NULL, NULL);
 916 
 917   locale_type = get_locale_type ();
 918 
 919   /*
 920    * We use a two pass approach to keep memory management simple
 921    */
 922   result_len = real_toupper (str, len, NULL, locale_type);
 923 #ifdef GSTREAMER_LITE
 924   if (result_len == 0)
 925     return NULL;
 926 #endif // GSTREAMER_LITE
 927   result = g_malloc (result_len + 1);
 928 #ifdef GSTREAMER_LITE
 929   if (result == NULL)
</pre>
<hr />
<pre>
 947 {
 948   const gchar *p = str;
 949   gint combining_class;
 950 
 951   while (*p)
 952     {
 953       combining_class = g_unichar_combining_class (g_utf8_get_char (p));
 954       if (combining_class == 230)
 955         return TRUE;
 956       else if (combining_class == 0)
 957         break;
 958 
 959       p = g_utf8_next_char (p);
 960     }
 961 
 962   return FALSE;
 963 }
 964 
 965 static gsize
 966 real_tolower (const gchar *str,
<span class="line-modified"> 967           gssize       max_len,</span>
<span class="line-modified"> 968           gchar       *out_buffer,</span>
<span class="line-modified"> 969           LocaleType   locale_type)</span>
 970 {
 971   const gchar *p = str;
 972   const char *last = NULL;
 973   gsize len = 0;
 974 
 975   while ((max_len &lt; 0 || p &lt; str + max_len) &amp;&amp; *p)
 976     {
 977       gunichar c = g_utf8_get_char (p);
 978       int t = TYPE (c);
 979       gunichar val;
 980 
 981       last = p;
 982       p = g_utf8_next_char (p);
 983 
<span class="line-modified"> 984       if (locale_type == LOCALE_TURKIC &amp;&amp; c == &#39;I&#39;)</span>
<span class="line-modified"> 985     {</span>

 986           if (g_utf8_get_char (p) == 0x0307)
 987             {
 988               /* I + COMBINING DOT ABOVE =&gt; i (U+0069) */
 989               len += g_unichar_to_utf8 (0x0069, out_buffer ? out_buffer + len : NULL);
 990               p = g_utf8_next_char (p);
 991             }
 992           else
 993             {
 994               /* I =&gt; LATIN SMALL LETTER DOTLESS I */
 995               len += g_unichar_to_utf8 (0x131, out_buffer ? out_buffer + len : NULL);
 996             }
 997         }
 998       /* Introduce an explicit dot above when lowercasing capital I&#39;s and J&#39;s
 999        * whenever there are more accents above. [SpecialCasing.txt] */
1000       else if (locale_type == LOCALE_LITHUANIAN &amp;&amp;
1001                (c == 0x00cc || c == 0x00cd || c == 0x0128))
1002         {
1003           len += g_unichar_to_utf8 (0x0069, out_buffer ? out_buffer + len : NULL);
1004           len += g_unichar_to_utf8 (0x0307, out_buffer ? out_buffer + len : NULL);
1005 
1006           switch (c)
1007             {
1008             case 0x00cc:
1009               len += g_unichar_to_utf8 (0x0300, out_buffer ? out_buffer + len : NULL);
1010               break;
1011             case 0x00cd:
1012               len += g_unichar_to_utf8 (0x0301, out_buffer ? out_buffer + len : NULL);
1013               break;
1014             case 0x0128:
1015               len += g_unichar_to_utf8 (0x0303, out_buffer ? out_buffer + len : NULL);
1016               break;
1017             }
1018         }
1019       else if (locale_type == LOCALE_LITHUANIAN &amp;&amp;
<span class="line-modified">1020                (c == &#39;I&#39; || c == &#39;J&#39; || c == 0x012e) &amp;&amp;</span>

1021                has_more_above (p))
1022         {
1023           len += g_unichar_to_utf8 (g_unichar_tolower (c), out_buffer ? out_buffer + len : NULL);
1024           len += g_unichar_to_utf8 (0x0307, out_buffer ? out_buffer + len : NULL);
1025         }
1026       else if (c == 0x03A3) /* GREEK CAPITAL LETTER SIGMA */
<span class="line-modified">1027     {</span>
<span class="line-modified">1028       if ((max_len &lt; 0 || p &lt; str + max_len) &amp;&amp; *p)</span>
<span class="line-modified">1029         {</span>
<span class="line-modified">1030           gunichar next_c = g_utf8_get_char (p);</span>
<span class="line-modified">1031           int next_type = TYPE(next_c);</span>
<span class="line-modified">1032 </span>
<span class="line-modified">1033           /* SIGMA mapps differently depending on whether it is</span>
<span class="line-modified">1034            * final or not. The following simplified test would</span>
<span class="line-modified">1035            * fail in the case of combining marks following the</span>
<span class="line-modified">1036            * sigma, but I don&#39;t think that occurs in real text.</span>
<span class="line-modified">1037            * The test here matches that in ICU.</span>
<span class="line-modified">1038            */</span>
<span class="line-modified">1039           if (ISALPHA (next_type)) /* Lu,Ll,Lt,Lm,Lo */</span>
<span class="line-modified">1040         val = 0x3c3;    /* GREEK SMALL SIGMA */</span>
<span class="line-modified">1041           else</span>
<span class="line-modified">1042         val = 0x3c2;    /* GREEK SMALL FINAL SIGMA */</span>
<span class="line-modified">1043         }</span>
<span class="line-modified">1044       else</span>
<span class="line-modified">1045         val = 0x3c2;    /* GREEK SMALL FINAL SIGMA */</span>
1046 
<span class="line-modified">1047       len += g_unichar_to_utf8 (val, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-modified">1048     }</span>
1049       else if (IS (t,
<span class="line-modified">1050            OR (G_UNICODE_UPPERCASE_LETTER,</span>
<span class="line-modified">1051            OR (G_UNICODE_TITLECASE_LETTER,</span>
<span class="line-modified">1052           0))))</span>
<span class="line-modified">1053     {</span>
<span class="line-modified">1054       val = ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);</span>
1055 
<span class="line-modified">1056       if (val &gt;= 0x1000000)</span>
<span class="line-modified">1057         {</span>
<span class="line-modified">1058           len += output_special_case (out_buffer ? out_buffer + len : NULL, val - 0x1000000, t, 0);</span>
<span class="line-modified">1059         }</span>
<span class="line-modified">1060       else</span>
<span class="line-modified">1061         {</span>
<span class="line-modified">1062           if (t == G_UNICODE_TITLECASE_LETTER)</span>



1063         {
<span class="line-modified">1064           unsigned int i;</span>
<span class="line-modified">1065           for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)</span>
<span class="line-modified">1066             {</span>
<span class="line-modified">1067               if (title_table[i][0] == c)</span>
<span class="line-modified">1068             {</span>
<span class="line-removed">1069               val = title_table[i][2];</span>
<span class="line-removed">1070               break;</span>
<span class="line-removed">1071             }</span>
<span class="line-removed">1072             }</span>
<span class="line-removed">1073         }</span>
<span class="line-removed">1074 </span>
<span class="line-removed">1075           /* Not all uppercase letters are guaranteed to have a lowercase</span>
<span class="line-removed">1076            * equivalent.  If this is the case, val will be zero. */</span>
<span class="line-removed">1077           len += g_unichar_to_utf8 (val ? val : c, out_buffer ? out_buffer + len : NULL);</span>
1078         }
1079     }






1080       else
<span class="line-modified">1081     {</span>
<span class="line-modified">1082       gsize char_len = g_utf8_skip[*(guchar *)last];</span>
1083 
<span class="line-modified">1084       if (out_buffer)</span>
<span class="line-modified">1085         memcpy (out_buffer + len, last, char_len);</span>
1086 
<span class="line-modified">1087       len += char_len;</span>
<span class="line-modified">1088     }</span>
1089 
1090     }
1091 
1092   return len;
1093 }
1094 
1095 /**
1096  * g_utf8_strdown:
1097  * @str: a UTF-8 encoded string
1098  * @len: length of @str, in bytes, or -1 if @str is nul-terminated.
1099  *
1100  * Converts all Unicode characters in the string that have a case
1101  * to lowercase. The exact manner that this is done depends
1102  * on the current locale, and may result in the number of
1103  * characters in the string changing.
1104  *
1105  * Returns: a newly allocated string, with all characters
1106  *    converted to lowercase.
1107  **/
1108 gchar *
1109 g_utf8_strdown (const gchar *str,
<span class="line-modified">1110         gssize       len)</span>
1111 {
1112   gsize result_len;
1113   LocaleType locale_type;
1114   gchar *result;
1115 
1116   g_return_val_if_fail (str != NULL, NULL);
1117 
1118   locale_type = get_locale_type ();
1119 
1120   /*
1121    * We use a two pass approach to keep memory management simple
1122    */
1123   result_len = real_tolower (str, len, NULL, locale_type);
1124   result = g_malloc (result_len + 1);
1125 #ifdef GSTREAMER_LITE
1126   if (result == NULL)
1127       return NULL;
1128 #endif // GSTREAMER_LITE
1129   real_tolower (str, len, result, locale_type);
1130   result[result_len] = &#39;\0&#39;;
</pre>
<hr />
<pre>
1137  * @str: a UTF-8 encoded string
1138  * @len: length of @str, in bytes, or -1 if @str is nul-terminated.
1139  *
1140  * Converts a string into a form that is independent of case. The
1141  * result will not correspond to any particular case, but can be
1142  * compared for equality or ordered with the results of calling
1143  * g_utf8_casefold() on other strings.
1144  *
1145  * Note that calling g_utf8_casefold() followed by g_utf8_collate() is
1146  * only an approximation to the correct linguistic case insensitive
1147  * ordering, though it is a fairly good one. Getting this exactly
1148  * right would require a more sophisticated collation function that
1149  * takes case sensitivity into account. GLib does not currently
1150  * provide such a function.
1151  *
1152  * Returns: a newly allocated string, that is a
1153  *   case independent form of @str.
1154  **/
1155 gchar *
1156 g_utf8_casefold (const gchar *str,
<span class="line-modified">1157          gssize       len)</span>
1158 {
1159   GString *result;
1160   const char *p;
1161 
1162   g_return_val_if_fail (str != NULL, NULL);
1163 
1164   result = g_string_new (NULL);
1165   p = str;
1166   while ((len &lt; 0 || p &lt; str + len) &amp;&amp; *p)
1167     {
1168       gunichar ch = g_utf8_get_char (p);
1169 
1170       int start = 0;
1171       int end = G_N_ELEMENTS (casefold_table);
1172 
1173       if (ch &gt;= casefold_table[start].ch &amp;&amp;
1174           ch &lt;= casefold_table[end - 1].ch)





1175     {
<span class="line-modified">1176       while (TRUE)</span>
<span class="line-modified">1177         {</span>
<span class="line-removed">1178           int half = (start + end) / 2;</span>
<span class="line-removed">1179           if (ch == casefold_table[half].ch)</span>
<span class="line-removed">1180         {</span>
<span class="line-removed">1181           g_string_append (result, casefold_table[half].data);</span>
<span class="line-removed">1182           goto next;</span>
<span class="line-removed">1183         }</span>
<span class="line-removed">1184           else if (half == start)</span>
<span class="line-removed">1185         break;</span>
<span class="line-removed">1186           else if (ch &gt; casefold_table[half].ch)</span>
<span class="line-removed">1187         start = half;</span>
<span class="line-removed">1188           else</span>
<span class="line-removed">1189         end = half;</span>
<span class="line-removed">1190         }</span>
1191     }








1192 
1193       g_string_append_unichar (result, g_unichar_tolower (ch));
1194 
1195     next:
1196       p = g_utf8_next_char (p);
1197     }
1198 
1199   return g_string_free (result, FALSE);
1200 }
1201 
1202 /**
1203  * g_unichar_get_mirror_char:
1204  * @ch: a Unicode character
1205  * @mirrored_ch: location to store the mirrored character
1206  *
1207  * In Unicode, some characters are &quot;mirrored&quot;. This means that their
1208  * images are mirrored horizontally in text that is laid out from right
1209  * to left. For instance, &quot;(&quot; would become its mirror image, &quot;)&quot;, in
1210  * right-to-left text.
1211  *
</pre>
<hr />
<pre>
1232     *mirrored_ch = mirrored;
1233 
1234   return found;
1235 
1236 }
1237 
1238 #define G_SCRIPT_TABLE_MIDPOINT (G_N_ELEMENTS (g_script_table) / 2)
1239 
1240 static inline GUnicodeScript
1241 g_unichar_get_script_bsearch (gunichar ch)
1242 {
1243   int lower = 0;
1244   int upper = G_N_ELEMENTS (g_script_table) - 1;
1245   static int saved_mid = G_SCRIPT_TABLE_MIDPOINT;
1246   int mid = saved_mid;
1247 
1248 
1249   do
1250     {
1251       if (ch &lt; g_script_table[mid].start)
<span class="line-modified">1252     upper = mid - 1;</span>
1253       else if (ch &gt;= g_script_table[mid].start + g_script_table[mid].chars)
<span class="line-modified">1254     lower = mid + 1;</span>
1255       else
<span class="line-modified">1256     return g_script_table[saved_mid = mid].script;</span>
1257 
1258       mid = (lower + upper) / 2;
1259     }
1260   while (lower &lt;= upper);
1261 
1262   return G_UNICODE_SCRIPT_UNKNOWN;
1263 }
1264 
1265 /**
1266  * g_unichar_get_script:
1267  * @ch: a Unicode character
1268  *
1269  * Looks up the #GUnicodeScript for a particular character (as defined
1270  * by Unicode Standard Annex \#24). No check is made for @ch being a
1271  * valid Unicode character; if you pass in invalid character, the
1272  * result is undefined.
1273  *
1274  * This function is equivalent to pango_script_for_unichar() and the
1275  * two are interchangeable.
1276  *
</pre>
<hr />
<pre>
1404 
1405   /* Unicode-6.1 additions */
1406     PACK (&#39;C&#39;,&#39;a&#39;,&#39;k&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_CHAKMA */
1407     PACK (&#39;M&#39;,&#39;e&#39;,&#39;r&#39;,&#39;c&#39;), /* G_UNICODE_SCRIPT_MEROITIC_CURSIVE */
1408     PACK (&#39;M&#39;,&#39;e&#39;,&#39;r&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS */
1409     PACK (&#39;P&#39;,&#39;l&#39;,&#39;r&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_MIAO */
1410     PACK (&#39;S&#39;,&#39;h&#39;,&#39;r&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_SHARADA */
1411     PACK (&#39;S&#39;,&#39;o&#39;,&#39;r&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_SORA_SOMPENG */
1412     PACK (&#39;T&#39;,&#39;a&#39;,&#39;k&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_TAKRI */
1413 
1414   /* Unicode 7.0 additions */
1415     PACK (&#39;B&#39;,&#39;a&#39;,&#39;s&#39;,&#39;s&#39;), /* G_UNICODE_SCRIPT_BASSA_VAH */
1416     PACK (&#39;A&#39;,&#39;g&#39;,&#39;h&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN */
1417     PACK (&#39;D&#39;,&#39;u&#39;,&#39;p&#39;,&#39;l&#39;), /* G_UNICODE_SCRIPT_DUPLOYAN */
1418     PACK (&#39;E&#39;,&#39;l&#39;,&#39;b&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_ELBASAN */
1419     PACK (&#39;G&#39;,&#39;r&#39;,&#39;a&#39;,&#39;n&#39;), /* G_UNICODE_SCRIPT_GRANTHA */
1420     PACK (&#39;K&#39;,&#39;h&#39;,&#39;o&#39;,&#39;j&#39;), /* G_UNICODE_SCRIPT_KHOJKI*/
1421     PACK (&#39;S&#39;,&#39;i&#39;,&#39;n&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_KHUDAWADI */
1422     PACK (&#39;L&#39;,&#39;i&#39;,&#39;n&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_LINEAR_A */
1423     PACK (&#39;M&#39;,&#39;a&#39;,&#39;h&#39;,&#39;j&#39;), /* G_UNICODE_SCRIPT_MAHAJANI */
<span class="line-modified">1424     PACK (&#39;M&#39;,&#39;a&#39;,&#39;n&#39;,&#39;u&#39;), /* G_UNICODE_SCRIPT_MANICHAEAN */</span>
1425     PACK (&#39;M&#39;,&#39;e&#39;,&#39;n&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_MENDE_KIKAKUI */
1426     PACK (&#39;M&#39;,&#39;o&#39;,&#39;d&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_MODI */
1427     PACK (&#39;M&#39;,&#39;r&#39;,&#39;o&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_MRO */
1428     PACK (&#39;N&#39;,&#39;b&#39;,&#39;a&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_NABATAEAN */
1429     PACK (&#39;N&#39;,&#39;a&#39;,&#39;r&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN */
1430     PACK (&#39;P&#39;,&#39;e&#39;,&#39;r&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_OLD_PERMIC */
1431     PACK (&#39;H&#39;,&#39;m&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_PAHAWH_HMONG */
1432     PACK (&#39;P&#39;,&#39;a&#39;,&#39;l&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_PALMYRENE */
1433     PACK (&#39;P&#39;,&#39;a&#39;,&#39;u&#39;,&#39;c&#39;), /* G_UNICODE_SCRIPT_PAU_CIN_HAU */
1434     PACK (&#39;P&#39;,&#39;h&#39;,&#39;l&#39;,&#39;p&#39;), /* G_UNICODE_SCRIPT_PSALTER_PAHLAVI */
1435     PACK (&#39;S&#39;,&#39;i&#39;,&#39;d&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_SIDDHAM */
1436     PACK (&#39;T&#39;,&#39;i&#39;,&#39;r&#39;,&#39;h&#39;), /* G_UNICODE_SCRIPT_TIRHUTA */
1437     PACK (&#39;W&#39;,&#39;a&#39;,&#39;r&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_WARANG_CITI */
1438 
1439   /* Unicode 8.0 additions */
1440     PACK (&#39;A&#39;,&#39;h&#39;,&#39;o&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_AHOM */
1441     PACK (&#39;H&#39;,&#39;l&#39;,&#39;u&#39;,&#39;w&#39;), /* G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS */
1442     PACK (&#39;H&#39;,&#39;a&#39;,&#39;t&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_HATRAN */
1443     PACK (&#39;M&#39;,&#39;u&#39;,&#39;l&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_MULTANI */
1444     PACK (&#39;H&#39;,&#39;u&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_OLD_HUNGARIAN */
</pre>
<hr />
<pre>
1449     PACK (&#39;B&#39;,&#39;h&#39;,&#39;k&#39;,&#39;s&#39;), /* G_UNICODE_SCRIPT_BHAIKSUKI */
1450     PACK (&#39;M&#39;,&#39;a&#39;,&#39;r&#39;,&#39;c&#39;), /* G_UNICODE_SCRIPT_MARCHEN */
1451     PACK (&#39;N&#39;,&#39;e&#39;,&#39;w&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_NEWA */
1452     PACK (&#39;O&#39;,&#39;s&#39;,&#39;g&#39;,&#39;e&#39;), /* G_UNICODE_SCRIPT_OSAGE */
1453     PACK (&#39;T&#39;,&#39;a&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_TANGUT */
1454 
1455   /* Unicode 10.0 additions */
1456     PACK (&#39;G&#39;,&#39;o&#39;,&#39;n&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_MASARAM_GONDI */
1457     PACK (&#39;N&#39;,&#39;s&#39;,&#39;h&#39;,&#39;u&#39;), /* G_UNICODE_SCRIPT_NUSHU */
1458     PACK (&#39;S&#39;,&#39;o&#39;,&#39;y&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_SOYOMBO */
1459     PACK (&#39;Z&#39;,&#39;a&#39;,&#39;n&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_ZANABAZAR_SQUARE */
1460 
1461   /* Unicode 11.0 additions */
1462     PACK (&#39;D&#39;,&#39;o&#39;,&#39;g&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_DOGRA */
1463     PACK (&#39;G&#39;,&#39;o&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_GUNJALA_GONDI */
1464     PACK (&#39;R&#39;,&#39;o&#39;,&#39;h&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_HANIFI_ROHINGYA */
1465     PACK (&#39;M&#39;,&#39;a&#39;,&#39;k&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_MAKASAR */
1466     PACK (&#39;M&#39;,&#39;e&#39;,&#39;d&#39;,&#39;f&#39;), /* G_UNICODE_SCRIPT_MEDEFAIDRIN */
1467     PACK (&#39;S&#39;,&#39;o&#39;,&#39;g&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_OLD_SOGDIAN */
1468     PACK (&#39;S&#39;,&#39;o&#39;,&#39;g&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_SOGDIAN */






1469 #undef PACK
1470 };
1471 
1472 /**
1473  * g_unicode_script_to_iso15924:
1474  * @script: a Unicode script
1475  *
1476  * Looks up the ISO 15924 code for @script.  ISO 15924 assigns four-letter
1477  * codes to scripts.  For example, the code for Arabic is &#39;Arab&#39;.  The
1478  * four letter codes are encoded as a @guint32 by this function in a
1479  * big-endian fashion.  That is, the code returned for Arabic is
1480  * 0x41726162 (0x41 is ASCII code for &#39;A&#39;, 0x72 is ASCII code for &#39;r&#39;, etc).
1481  *
1482  * See
1483  * [Codes for the representation of names of scripts](http://unicode.org/iso15924/codelists.html)
1484  * for details.
1485  *
1486  * Returns: the ISO 15924 code for @script, encoded as an integer,
1487  *   of zero if @script is %G_UNICODE_SCRIPT_INVALID_CODE or
1488  *   ISO 15924 code &#39;Zzzz&#39; (script code for UNKNOWN) if @script is not understood.
</pre>
</td>
<td>
<hr />
<pre>
  20 #include &quot;config.h&quot;
  21 
  22 #include &lt;stdlib.h&gt;
  23 #include &lt;stddef.h&gt;
  24 #include &lt;string.h&gt;
  25 #include &lt;locale.h&gt;
  26 
  27 #include &quot;gmem.h&quot;
  28 #include &quot;gstring.h&quot;
  29 #include &quot;gtestutils.h&quot;
  30 #include &quot;gtypes.h&quot;
  31 #include &quot;gunicode.h&quot;
  32 #include &quot;gunichartables.h&quot;
  33 #include &quot;gmirroringtable.h&quot;
  34 #include &quot;gscripttable.h&quot;
  35 #include &quot;gunicodeprivate.h&quot;
  36 #ifdef G_OS_WIN32
  37 #include &quot;gwin32.h&quot;
  38 #endif
  39 
<span class="line-added">  40 #define G_UNICHAR_FULLWIDTH_A 0xff21</span>
<span class="line-added">  41 #define G_UNICHAR_FULLWIDTH_I 0xff29</span>
<span class="line-added">  42 #define G_UNICHAR_FULLWIDTH_J 0xff2a</span>
<span class="line-added">  43 #define G_UNICHAR_FULLWIDTH_F 0xff26</span>
<span class="line-added">  44 #define G_UNICHAR_FULLWIDTH_a 0xff41</span>
<span class="line-added">  45 #define G_UNICHAR_FULLWIDTH_f 0xff46</span>
<span class="line-added">  46 </span>
  47 #define ATTR_TABLE(Page) (((Page) &lt;= G_UNICODE_LAST_PAGE_PART1) \
  48                           ? attr_table_part1[Page] \
  49                           : attr_table_part2[(Page) - 0xe00])
  50 
  51 #define ATTTABLE(Page, Char) \
  52   ((ATTR_TABLE(Page) == G_UNICODE_MAX_TABLE_INDEX) ? 0 : (attr_data[ATTR_TABLE(Page)][Char]))
  53 
  54 #define TTYPE_PART1(Page, Char) \
  55   ((type_table_part1[Page] &gt;= G_UNICODE_MAX_TABLE_INDEX) \
  56    ? (type_table_part1[Page] - G_UNICODE_MAX_TABLE_INDEX) \
  57    : (type_data[type_table_part1[Page]][Char]))
  58 
  59 #define TTYPE_PART2(Page, Char) \
  60   ((type_table_part2[Page] &gt;= G_UNICODE_MAX_TABLE_INDEX) \
  61    ? (type_table_part2[Page] - G_UNICODE_MAX_TABLE_INDEX) \
  62    : (type_data[type_table_part2[Page]][Char]))
  63 
  64 #define TYPE(Char) \
  65   (((Char) &lt;= G_UNICODE_LAST_CHAR_PART1) \
  66    ? TTYPE_PART1 ((Char) &gt;&gt; 8, (Char) &amp; 0xff) \
  67    : (((Char) &gt;= 0xe0000 &amp;&amp; (Char) &lt;= G_UNICODE_LAST_CHAR) \
  68       ? TTYPE_PART2 (((Char) - 0xe0000) &gt;&gt; 8, (Char) &amp; 0xff) \
  69       : G_UNICODE_UNASSIGNED))
  70 
  71 
  72 #define IS(Type, Class) (((guint)1 &lt;&lt; (Type)) &amp; (Class))
  73 #define OR(Type, Rest)  (((guint)1 &lt;&lt; (Type)) | (Rest))
  74 
  75 
  76 
<span class="line-modified">  77 #define ISALPHA(Type) IS ((Type),       \</span>
<span class="line-modified">  78           OR (G_UNICODE_LOWERCASE_LETTER, \</span>
<span class="line-modified">  79           OR (G_UNICODE_UPPERCASE_LETTER, \</span>
<span class="line-modified">  80           OR (G_UNICODE_TITLECASE_LETTER, \</span>
<span class="line-modified">  81           OR (G_UNICODE_MODIFIER_LETTER,  \</span>
<span class="line-modified">  82           OR (G_UNICODE_OTHER_LETTER,   0))))))</span>
  83 
<span class="line-modified">  84 #define ISALDIGIT(Type) IS ((Type),       \</span>
<span class="line-modified">  85           OR (G_UNICODE_DECIMAL_NUMBER, \</span>
<span class="line-modified">  86           OR (G_UNICODE_LETTER_NUMBER,  \</span>
<span class="line-modified">  87           OR (G_UNICODE_OTHER_NUMBER,   \</span>
<span class="line-modified">  88           OR (G_UNICODE_LOWERCASE_LETTER, \</span>
<span class="line-modified">  89           OR (G_UNICODE_UPPERCASE_LETTER, \</span>
<span class="line-modified">  90           OR (G_UNICODE_TITLECASE_LETTER, \</span>
<span class="line-modified">  91           OR (G_UNICODE_MODIFIER_LETTER,  \</span>
<span class="line-modified">  92           OR (G_UNICODE_OTHER_LETTER,   0)))))))))</span>
  93 
<span class="line-modified">  94 #define ISMARK(Type)  IS ((Type),       \</span>
<span class="line-modified">  95           OR (G_UNICODE_NON_SPACING_MARK, \</span>
<span class="line-modified">  96           OR (G_UNICODE_SPACING_MARK, \</span>
<span class="line-modified">  97           OR (G_UNICODE_ENCLOSING_MARK, 0))))</span>
  98 
<span class="line-modified">  99 #define ISZEROWIDTHTYPE(Type) IS ((Type),     \</span>
<span class="line-modified"> 100           OR (G_UNICODE_NON_SPACING_MARK, \</span>
<span class="line-modified"> 101           OR (G_UNICODE_ENCLOSING_MARK, \</span>
<span class="line-modified"> 102           OR (G_UNICODE_FORMAT,   0))))</span>
 103 
 104 /**
 105  * g_unichar_isalnum:
 106  * @c: a Unicode character
 107  *
 108  * Determines whether a character is alphanumeric.
 109  * Given some UTF-8 text, obtain a character value
 110  * with g_utf8_get_char().
 111  *
 112  * Returns: %TRUE if @c is an alphanumeric character
 113  **/
 114 gboolean
 115 g_unichar_isalnum (gunichar c)
 116 {
 117   return ISALDIGIT (TYPE (c)) ? TRUE : FALSE;
 118 }
 119 
 120 /**
 121  * g_unichar_isalpha:
 122  * @c: a Unicode character
</pre>
<hr />
<pre>
 166   return TYPE (c) == G_UNICODE_DECIMAL_NUMBER;
 167 }
 168 
 169 
 170 /**
 171  * g_unichar_isgraph:
 172  * @c: a Unicode character
 173  *
 174  * Determines whether a character is printable and not a space
 175  * (returns %FALSE for control characters, format characters, and
 176  * spaces). g_unichar_isprint() is similar, but returns %TRUE for
 177  * spaces. Given some UTF-8 text, obtain a character value with
 178  * g_utf8_get_char().
 179  *
 180  * Returns: %TRUE if @c is printable unless it&#39;s a space
 181  **/
 182 gboolean
 183 g_unichar_isgraph (gunichar c)
 184 {
 185   return !IS (TYPE(c),
<span class="line-modified"> 186         OR (G_UNICODE_CONTROL,</span>
<span class="line-modified"> 187         OR (G_UNICODE_FORMAT,</span>
<span class="line-modified"> 188         OR (G_UNICODE_UNASSIGNED,</span>
<span class="line-modified"> 189         OR (G_UNICODE_SURROGATE,</span>
<span class="line-modified"> 190         OR (G_UNICODE_SPACE_SEPARATOR,</span>
<span class="line-modified"> 191        0))))));</span>
 192 }
 193 
 194 /**
 195  * g_unichar_islower:
 196  * @c: a Unicode character
 197  *
 198  * Determines whether a character is a lowercase letter.
 199  * Given some UTF-8 text, obtain a character value with
 200  * g_utf8_get_char().
 201  *
 202  * Returns: %TRUE if @c is a lowercase letter
 203  **/
 204 gboolean
 205 g_unichar_islower (gunichar c)
 206 {
 207   return TYPE (c) == G_UNICODE_LOWERCASE_LETTER;
 208 }
 209 
 210 
 211 /**
 212  * g_unichar_isprint:
 213  * @c: a Unicode character
 214  *
 215  * Determines whether a character is printable.
 216  * Unlike g_unichar_isgraph(), returns %TRUE for spaces.
 217  * Given some UTF-8 text, obtain a character value with
 218  * g_utf8_get_char().
 219  *
 220  * Returns: %TRUE if @c is printable
 221  **/
 222 gboolean
 223 g_unichar_isprint (gunichar c)
 224 {
 225   return !IS (TYPE(c),
<span class="line-modified"> 226         OR (G_UNICODE_CONTROL,</span>
<span class="line-modified"> 227         OR (G_UNICODE_FORMAT,</span>
<span class="line-modified"> 228         OR (G_UNICODE_UNASSIGNED,</span>
<span class="line-modified"> 229         OR (G_UNICODE_SURROGATE,</span>
<span class="line-modified"> 230        0)))));</span>
 231 }
 232 
 233 /**
 234  * g_unichar_ispunct:
 235  * @c: a Unicode character
 236  *
 237  * Determines whether a character is punctuation or a symbol.
 238  * Given some UTF-8 text, obtain a character value with
 239  * g_utf8_get_char().
 240  *
 241  * Returns: %TRUE if @c is a punctuation or symbol character
 242  **/
 243 gboolean
 244 g_unichar_ispunct (gunichar c)
 245 {
 246   return IS (TYPE(c),
<span class="line-modified"> 247        OR (G_UNICODE_CONNECT_PUNCTUATION,</span>
<span class="line-modified"> 248        OR (G_UNICODE_DASH_PUNCTUATION,</span>
<span class="line-modified"> 249        OR (G_UNICODE_CLOSE_PUNCTUATION,</span>
<span class="line-modified"> 250        OR (G_UNICODE_FINAL_PUNCTUATION,</span>
<span class="line-modified"> 251        OR (G_UNICODE_INITIAL_PUNCTUATION,</span>
<span class="line-modified"> 252        OR (G_UNICODE_OTHER_PUNCTUATION,</span>
<span class="line-modified"> 253        OR (G_UNICODE_OPEN_PUNCTUATION,</span>
<span class="line-modified"> 254        OR (G_UNICODE_CURRENCY_SYMBOL,</span>
<span class="line-modified"> 255        OR (G_UNICODE_MODIFIER_SYMBOL,</span>
<span class="line-modified"> 256        OR (G_UNICODE_MATH_SYMBOL,</span>
<span class="line-modified"> 257        OR (G_UNICODE_OTHER_SYMBOL,</span>
<span class="line-modified"> 258       0)))))))))))) ? TRUE : FALSE;</span>
 259 }
 260 
 261 /**
 262  * g_unichar_isspace:
 263  * @c: a Unicode character
 264  *
 265  * Determines whether a character is a space, tab, or line separator
 266  * (newline, carriage return, etc.).  Given some UTF-8 text, obtain a
 267  * character value with g_utf8_get_char().
 268  *
 269  * (Note: don&#39;t use this to do word breaking; you have to use
 270  * Pango or equivalent to get word breaking right, the algorithm
 271  * is fairly complex.)
 272  *
 273  * Returns: %TRUE if @c is a space character
 274  **/
 275 gboolean
 276 g_unichar_isspace (gunichar c)
 277 {
 278   switch (c)
 279     {
 280       /* special-case these since Unicode thinks they are not spaces */
 281     case &#39;\t&#39;:
 282     case &#39;\n&#39;:
 283     case &#39;\r&#39;:
 284     case &#39;\f&#39;:
 285       return TRUE;
 286       break;
 287 
 288     default:
 289       {
<span class="line-modified"> 290   return IS (TYPE(c),</span>
<span class="line-modified"> 291              OR (G_UNICODE_SPACE_SEPARATOR,</span>
<span class="line-modified"> 292              OR (G_UNICODE_LINE_SEPARATOR,</span>
 293                    OR (G_UNICODE_PARAGRAPH_SEPARATOR,
<span class="line-modified"> 294       0)))) ? TRUE : FALSE;</span>
 295       }
 296       break;
 297     }
 298 }
 299 
 300 /**
 301  * g_unichar_ismark:
 302  * @c: a Unicode character
 303  *
 304  * Determines whether a character is a mark (non-spacing mark,
 305  * combining mark, or enclosing mark in Unicode speak).
 306  * Given some UTF-8 text, obtain a character value
 307  * with g_utf8_get_char().
 308  *
 309  * Note: in most cases where isalpha characters are allowed,
 310  * ismark characters should be allowed to as they are essential
 311  * for writing most European languages as well as many non-Latin
 312  * scripts.
 313  *
 314  * Returns: %TRUE if @c is a mark character
</pre>
<hr />
<pre>
 352 g_unichar_istitle (gunichar c)
 353 {
 354   unsigned int i;
 355   for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)
 356     if (title_table[i][0] == c)
 357       return TRUE;
 358   return FALSE;
 359 }
 360 
 361 /**
 362  * g_unichar_isxdigit:
 363  * @c: a Unicode character.
 364  *
 365  * Determines if a character is a hexidecimal digit.
 366  *
 367  * Returns: %TRUE if the character is a hexadecimal digit
 368  **/
 369 gboolean
 370 g_unichar_isxdigit (gunichar c)
 371 {
<span class="line-modified"> 372   return ((c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;) ||</span>
<span class="line-modified"> 373           (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;) ||</span>
<span class="line-modified"> 374           (c &gt;= G_UNICHAR_FULLWIDTH_a &amp;&amp; c &lt;= G_UNICHAR_FULLWIDTH_f) ||</span>
<span class="line-added"> 375           (c &gt;= G_UNICHAR_FULLWIDTH_A &amp;&amp; c &lt;= G_UNICHAR_FULLWIDTH_F) ||</span>
<span class="line-added"> 376           (TYPE (c) == G_UNICODE_DECIMAL_NUMBER));</span>
 377 }
 378 
 379 /**
 380  * g_unichar_isdefined:
 381  * @c: a Unicode character
 382  *
 383  * Determines if a given character is assigned in the Unicode
 384  * standard.
 385  *
 386  * Returns: %TRUE if the character has an assigned value
 387  **/
 388 gboolean
 389 g_unichar_isdefined (gunichar c)
 390 {
 391   return !IS (TYPE(c),
<span class="line-modified"> 392         OR (G_UNICODE_UNASSIGNED,</span>
<span class="line-modified"> 393         OR (G_UNICODE_SURROGATE,</span>
<span class="line-modified"> 394        0)));</span>
 395 }
 396 
 397 /**
 398  * g_unichar_iszerowidth:
 399  * @c: a Unicode character
 400  *
 401  * Determines if a given character typically takes zero width when rendered.
 402  * The return value is %TRUE for all non-spacing and enclosing marks
 403  * (e.g., combining accents), format characters, zero-width
 404  * space, but not U+00AD SOFT HYPHEN.
 405  *
 406  * A typical use of this function is with one of g_unichar_iswide() or
 407  * g_unichar_iswide_cjk() to determine the number of cells a string occupies
 408  * when displayed on a grid display (terminals).  However, note that not all
 409  * terminals support zero-width rendering of zero-width marks.
 410  *
 411  * Returns: %TRUE if the character has zero width
 412  *
 413  * Since: 2.14
 414  **/
 415 gboolean
 416 g_unichar_iszerowidth (gunichar c)
 417 {
 418   if (G_UNLIKELY (c == 0x00AD))
 419     return FALSE;
 420 
 421   if (G_UNLIKELY (ISZEROWIDTHTYPE (TYPE (c))))
 422     return TRUE;
 423 
 424   if (G_UNLIKELY ((c &gt;= 0x1160 &amp;&amp; c &lt; 0x1200) ||
<span class="line-modified"> 425       c == 0x200B))</span>
 426     return TRUE;
 427 
 428   return FALSE;
 429 }
 430 
 431 static int
 432 interval_compare (const void *key, const void *elt)
 433 {
 434   gunichar c = GPOINTER_TO_UINT (key);
 435   struct Interval *interval = (struct Interval *)elt;
 436 
 437   if (c &lt; interval-&gt;start)
 438     return -1;
 439   if (c &gt; interval-&gt;end)
 440     return +1;
 441 
 442   return 0;
 443 }
 444 
 445 #define G_WIDTH_TABLE_MIDPOINT (G_N_ELEMENTS (g_unicode_width_table_wide) / 2)
 446 
 447 static inline gboolean
 448 g_unichar_iswide_bsearch (gunichar ch)
 449 {
 450   int lower = 0;
 451   int upper = G_N_ELEMENTS (g_unicode_width_table_wide) - 1;
 452   static int saved_mid = G_WIDTH_TABLE_MIDPOINT;
 453   int mid = saved_mid;
 454 
 455   do
 456     {
 457       if (ch &lt; g_unicode_width_table_wide[mid].start)
<span class="line-modified"> 458   upper = mid - 1;</span>
 459       else if (ch &gt; g_unicode_width_table_wide[mid].end)
<span class="line-modified"> 460   lower = mid + 1;</span>
 461       else
<span class="line-modified"> 462   return TRUE;</span>
 463 
 464       mid = (lower + upper) / 2;
 465     }
 466   while (lower &lt;= upper);
 467 
 468   return FALSE;
 469 }
 470 
 471 /**
 472  * g_unichar_iswide:
 473  * @c: a Unicode character
 474  *
 475  * Determines if a character is typically rendered in a double-width
 476  * cell.
 477  *
 478  * Returns: %TRUE if the character is wide
 479  **/
 480 gboolean
 481 g_unichar_iswide (gunichar c)
 482 {
 483   if (c &lt; g_unicode_width_table_wide[0].start)
<span class="line-modified"> 484     return FALSE;</span>
 485   else
 486     return g_unichar_iswide_bsearch (c);
 487 }
 488 
 489 
 490 /**
 491  * g_unichar_iswide_cjk:
 492  * @c: a Unicode character
 493  *
 494  * Determines if a character is typically rendered in a double-width
 495  * cell under legacy East Asian locales.  If a character is wide according to
 496  * g_unichar_iswide(), then it is also reported wide with this function, but
 497  * the converse is not necessarily true. See the
 498  * [Unicode Standard Annex #11](http://www.unicode.org/reports/tr11/)
 499  * for details.
 500  *
 501  * If a character passes the g_unichar_iswide() test then it will also pass
 502  * this test, but not the other way around.  Note that some characters may
 503  * pass both this test and g_unichar_iszerowidth().
 504  *
 505  * Returns: %TRUE if the character is wide in legacy East Asian locales
 506  *
 507  * Since: 2.12
 508  */
 509 gboolean
 510 g_unichar_iswide_cjk (gunichar c)
 511 {
 512   if (g_unichar_iswide (c))
 513     return TRUE;
 514 
 515   /* bsearch() is declared attribute(nonnull(1)) so we can&#39;t validly search
 516    * for a NULL key */
 517   if (c == 0)
 518     return FALSE;
 519 
 520   if (bsearch (GUINT_TO_POINTER (c),
 521                g_unicode_width_table_ambiguous,
 522                G_N_ELEMENTS (g_unicode_width_table_ambiguous),
 523                sizeof g_unicode_width_table_ambiguous[0],
<span class="line-modified"> 524          interval_compare))</span>
 525     return TRUE;
 526 
 527   return FALSE;
 528 }
 529 
 530 
 531 /**
 532  * g_unichar_toupper:
 533  * @c: a Unicode character
 534  *
 535  * Converts a character to uppercase.
 536  *
 537  * Returns: the result of converting @c to uppercase.
<span class="line-modified"> 538  *               If @c is not a lowercase or titlecase character,</span>
 539  *               or has no upper case equivalent @c is returned unchanged.
 540  **/
 541 gunichar
 542 g_unichar_toupper (gunichar c)
 543 {
 544   int t = TYPE (c);
 545   if (t == G_UNICODE_LOWERCASE_LETTER)
 546     {
 547       gunichar val = ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);
 548       if (val &gt;= 0x1000000)
<span class="line-modified"> 549   {</span>
<span class="line-modified"> 550     const gchar *p = special_case_table + val - 0x1000000;</span>
 551           val = g_utf8_get_char (p);
<span class="line-modified"> 552   }</span>
 553       /* Some lowercase letters, e.g., U+000AA, FEMININE ORDINAL INDICATOR,
 554        * do not have an uppercase equivalent, in which case val will be
 555        * zero.
 556        */
 557       return val ? val : c;
 558     }
 559   else if (t == G_UNICODE_TITLECASE_LETTER)
 560     {
 561       unsigned int i;
 562       for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)
<span class="line-modified"> 563   {</span>
<span class="line-modified"> 564     if (title_table[i][0] == c)</span>
<span class="line-modified"> 565       return title_table[i][1] ? title_table[i][1] : c;</span>
<span class="line-modified"> 566   }</span>
 567     }
 568   return c;
 569 }
 570 
 571 /**
 572  * g_unichar_tolower:
 573  * @c: a Unicode character.
 574  *
 575  * Converts a character to lower case.
 576  *
 577  * Returns: the result of converting @c to lower case.
 578  *               If @c is not an upperlower or titlecase character,
 579  *               or has no lowercase equivalent @c is returned unchanged.
 580  **/
 581 gunichar
 582 g_unichar_tolower (gunichar c)
 583 {
 584   int t = TYPE (c);
 585   if (t == G_UNICODE_UPPERCASE_LETTER)
 586     {
 587       gunichar val = ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);
 588       if (val &gt;= 0x1000000)
<span class="line-modified"> 589   {</span>
<span class="line-modified"> 590     const gchar *p = special_case_table + val - 0x1000000;</span>
<span class="line-modified"> 591     return g_utf8_get_char (p);</span>
<span class="line-modified"> 592   }</span>
 593       else
<span class="line-modified"> 594   {</span>
<span class="line-modified"> 595     /* Not all uppercase letters are guaranteed to have a lowercase</span>
<span class="line-modified"> 596      * equivalent.  If this is the case, val will be zero. */</span>
<span class="line-modified"> 597     return val ? val : c;</span>
<span class="line-modified"> 598   }</span>
 599     }
 600   else if (t == G_UNICODE_TITLECASE_LETTER)
 601     {
 602       unsigned int i;
 603       for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)
<span class="line-modified"> 604   {</span>
<span class="line-modified"> 605     if (title_table[i][0] == c)</span>
<span class="line-modified"> 606       return title_table[i][2];</span>
<span class="line-modified"> 607   }</span>
 608     }
 609   return c;
 610 }
 611 
 612 /**
 613  * g_unichar_totitle:
 614  * @c: a Unicode character
 615  *
 616  * Converts a character to the titlecase.
 617  *
 618  * Returns: the result of converting @c to titlecase.
 619  *               If @c is not an uppercase or lowercase character,
 620  *               @c is returned unchanged.
 621  **/
 622 gunichar
 623 g_unichar_totitle (gunichar c)
 624 {
 625   unsigned int i;
<span class="line-added"> 626 </span>
<span class="line-added"> 627   /* We handle U+0000 explicitely because some elements in</span>
<span class="line-added"> 628    * title_table[i][1] may be null. */</span>
<span class="line-added"> 629   if (c == 0)</span>
<span class="line-added"> 630     return c;</span>
<span class="line-added"> 631 </span>
 632   for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)
 633     {
 634       if (title_table[i][0] == c || title_table[i][1] == c
<span class="line-modified"> 635     || title_table[i][2] == c)</span>
<span class="line-modified"> 636   return title_table[i][0];</span>
 637     }
 638 
 639   if (TYPE (c) == G_UNICODE_LOWERCASE_LETTER)
 640     return g_unichar_toupper (c);
 641 
 642   return c;
 643 }
 644 
 645 /**
 646  * g_unichar_digit_value:
 647  * @c: a Unicode character
 648  *
 649  * Determines the numeric value of a character as a decimal
 650  * digit.
 651  *
 652  * Returns: If @c is a decimal digit (according to
 653  * g_unichar_isdigit()), its numeric value. Otherwise, -1.
 654  **/
 655 int
 656 g_unichar_digit_value (gunichar c)
</pre>
<hr />
<pre>
 660   return -1;
 661 }
 662 
 663 /**
 664  * g_unichar_xdigit_value:
 665  * @c: a Unicode character
 666  *
 667  * Determines the numeric value of a character as a hexidecimal
 668  * digit.
 669  *
 670  * Returns: If @c is a hex digit (according to
 671  * g_unichar_isxdigit()), its numeric value. Otherwise, -1.
 672  **/
 673 int
 674 g_unichar_xdigit_value (gunichar c)
 675 {
 676   if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39;)
 677     return c - &#39;A&#39; + 10;
 678   if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39;)
 679     return c - &#39;a&#39; + 10;
<span class="line-added"> 680   if (c &gt;= G_UNICHAR_FULLWIDTH_A &amp;&amp; c &lt;= G_UNICHAR_FULLWIDTH_F)</span>
<span class="line-added"> 681     return c - G_UNICHAR_FULLWIDTH_A + 10;</span>
<span class="line-added"> 682   if (c &gt;= G_UNICHAR_FULLWIDTH_a &amp;&amp; c &lt;= G_UNICHAR_FULLWIDTH_f)</span>
<span class="line-added"> 683     return c - G_UNICHAR_FULLWIDTH_a + 10;</span>
 684   if (TYPE (c) == G_UNICODE_DECIMAL_NUMBER)
 685     return ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);
 686   return -1;
 687 }
 688 
 689 /**
 690  * g_unichar_type:
 691  * @c: a Unicode character
 692  *
 693  * Classifies a Unicode character by type.
 694  *
 695  * Returns: the type of the character.
 696  **/
 697 GUnicodeType
 698 g_unichar_type (gunichar c)
 699 {
 700   return TYPE (c);
 701 }
 702 
 703 /*
</pre>
<hr />
<pre>
 714 get_locale_type (void)
 715 {
 716 #ifdef G_OS_WIN32
 717   char *tem = g_win32_getlocale ();
 718   char locale[2];
 719 
 720   locale[0] = tem[0];
 721   locale[1] = tem[1];
 722   g_free (tem);
 723 #else
 724   const char *locale = setlocale (LC_CTYPE, NULL);
 725 
 726   if (locale == NULL)
 727     return LOCALE_NORMAL;
 728 #endif
 729 
 730   switch (locale[0])
 731     {
 732    case &#39;a&#39;:
 733       if (locale[1] == &#39;z&#39;)
<span class="line-modified"> 734   return LOCALE_TURKIC;</span>
 735       break;
 736     case &#39;l&#39;:
 737       if (locale[1] == &#39;t&#39;)
<span class="line-modified"> 738   return LOCALE_LITHUANIAN;</span>
 739       break;
 740     case &#39;t&#39;:
 741       if (locale[1] == &#39;r&#39;)
<span class="line-modified"> 742   return LOCALE_TURKIC;</span>
 743       break;
 744     }
 745 
 746   return LOCALE_NORMAL;
 747 }
 748 
 749 static gint
 750 output_marks (const char **p_inout,
<span class="line-modified"> 751         char        *out_buffer,</span>
<span class="line-modified"> 752         gboolean     remove_dot)</span>
 753 {
 754   const char *p = *p_inout;
 755   gint len = 0;
 756 
 757   while (*p)
 758     {
 759       gunichar c = g_utf8_get_char (p);
 760 
 761       if (ISMARK (TYPE (c)))
<span class="line-modified"> 762   {</span>
<span class="line-modified"> 763     if (!remove_dot || c != 0x307 /* COMBINING DOT ABOVE */)</span>
<span class="line-modified"> 764       len += g_unichar_to_utf8 (c, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-modified"> 765     p = g_utf8_next_char (p);</span>
<span class="line-modified"> 766   }</span>
 767       else
<span class="line-modified"> 768   break;</span>
 769     }
 770 
 771   *p_inout = p;
 772   return len;
 773 }
 774 
 775 static gint
 776 output_special_case (gchar *out_buffer,
<span class="line-modified"> 777          int    offset,</span>
<span class="line-modified"> 778          int    type,</span>
<span class="line-modified"> 779          int    which)</span>
 780 {
 781   const gchar *p = special_case_table + offset;
 782   gint len;
 783 
 784   if (type != G_UNICODE_TITLECASE_LETTER)
 785     p = g_utf8_next_char (p);
 786 
 787   if (which == 1)
 788     p += strlen (p) + 1;
 789 
 790   len = strlen (p);
 791   if (out_buffer)
 792     memcpy (out_buffer, p, len);
 793 
 794   return len;
 795 }
 796 
 797 static gsize
 798 real_toupper (const gchar *str,
<span class="line-modified"> 799         gssize       max_len,</span>
<span class="line-modified"> 800         gchar       *out_buffer,</span>
<span class="line-modified"> 801         LocaleType   locale_type)</span>
 802 {
 803   const gchar *p = str;
 804   const char *last = NULL;
 805   gsize len = 0;
 806   gboolean last_was_i = FALSE;
 807 
 808   while ((max_len &lt; 0 || p &lt; str + max_len) &amp;&amp; *p)
 809     {
 810       gunichar c = g_utf8_get_char (p);
 811       int t = TYPE (c);
 812       gunichar val;
 813 
 814       last = p;
 815       p = g_utf8_next_char (p);
 816 
 817       if (locale_type == LOCALE_LITHUANIAN)
<span class="line-added"> 818   {</span>
<span class="line-added"> 819     if (c == &#39;i&#39;)</span>
<span class="line-added"> 820       last_was_i = TRUE;</span>
<span class="line-added"> 821     else</span>
<span class="line-added"> 822       {</span>
<span class="line-added"> 823         if (last_was_i)</span>
 824     {
<span class="line-modified"> 825       /* Nasty, need to remove any dot above. Though</span>
<span class="line-modified"> 826        * I think only E WITH DOT ABOVE occurs in practice</span>
<span class="line-modified"> 827        * which could simplify this considerably.</span>
<span class="line-modified"> 828        */</span>
<span class="line-modified"> 829       gsize decomp_len, i;</span>
<span class="line-modified"> 830       gunichar decomp[G_UNICHAR_MAX_DECOMPOSITION_LENGTH];</span>















 831 
<span class="line-modified"> 832       decomp_len = g_unichar_fully_decompose (c, FALSE, decomp, G_N_ELEMENTS (decomp));</span>
<span class="line-added"> 833       for (i=0; i &lt; decomp_len; i++)</span>
<span class="line-added"> 834         {</span>
<span class="line-added"> 835           if (decomp[i] != 0x307 /* COMBINING DOT ABOVE */)</span>
<span class="line-added"> 836       len += g_unichar_to_utf8 (g_unichar_toupper (decomp[i]), out_buffer ? out_buffer + len : NULL);</span>
 837         }
 838 
<span class="line-modified"> 839       len += output_marks (&amp;p, out_buffer ? out_buffer + len : NULL, TRUE);</span>
<span class="line-modified"> 840 </span>
<span class="line-modified"> 841       continue;</span>
 842     }
 843 
<span class="line-added"> 844         if (!ISMARK (t))</span>
<span class="line-added"> 845     last_was_i = FALSE;</span>
<span class="line-added"> 846       }</span>
<span class="line-added"> 847   }</span>
<span class="line-added"> 848 </span>
 849       if (locale_type == LOCALE_TURKIC &amp;&amp; c == &#39;i&#39;)
<span class="line-modified"> 850   {</span>
<span class="line-modified"> 851     /* i =&gt; LATIN CAPITAL LETTER I WITH DOT ABOVE */</span>
<span class="line-modified"> 852     len += g_unichar_to_utf8 (0x130, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-modified"> 853   }</span>
 854       else if (c == 0x0345) /* COMBINING GREEK YPOGEGRAMMENI */
<span class="line-modified"> 855   {</span>
<span class="line-modified"> 856     /* Nasty, need to move it after other combining marks .. this would go away if</span>
<span class="line-modified"> 857      * we normalized first.</span>
<span class="line-modified"> 858      */</span>
<span class="line-modified"> 859     len += output_marks (&amp;p, out_buffer ? out_buffer + len : NULL, FALSE);</span>
<span class="line-modified"> 860 </span>
<span class="line-modified"> 861     /* And output as GREEK CAPITAL LETTER IOTA */</span>
<span class="line-modified"> 862     len += g_unichar_to_utf8 (0x399, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-modified"> 863   }</span>
 864       else if (IS (t,
<span class="line-modified"> 865        OR (G_UNICODE_LOWERCASE_LETTER,</span>
<span class="line-modified"> 866        OR (G_UNICODE_TITLECASE_LETTER,</span>
<span class="line-modified"> 867       0))))</span>
<span class="line-modified"> 868   {</span>
<span class="line-modified"> 869     val = ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);</span>
 870 
<span class="line-modified"> 871     if (val &gt;= 0x1000000)</span>
<span class="line-modified"> 872       {</span>
<span class="line-modified"> 873         len += output_special_case (out_buffer ? out_buffer + len : NULL, val - 0x1000000, t,</span>
<span class="line-modified"> 874             t == G_UNICODE_LOWERCASE_LETTER ? 0 : 1);</span>
<span class="line-modified"> 875       }</span>
<span class="line-modified"> 876     else</span>
<span class="line-modified"> 877       {</span>
<span class="line-modified"> 878         if (t == G_UNICODE_TITLECASE_LETTER)</span>
<span class="line-added"> 879     {</span>
<span class="line-added"> 880       unsigned int i;</span>
<span class="line-added"> 881       for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)</span>
 882         {
<span class="line-modified"> 883           if (title_table[i][0] == c)</span>
<span class="line-modified"> 884       {</span>
<span class="line-modified"> 885         val = title_table[i][1];</span>
<span class="line-modified"> 886         break;</span>
<span class="line-modified"> 887       }</span>










 888         }
 889     }
<span class="line-added"> 890 </span>
<span class="line-added"> 891         /* Some lowercase letters, e.g., U+000AA, FEMININE ORDINAL INDICATOR,</span>
<span class="line-added"> 892          * do not have an uppercase equivalent, in which case val will be</span>
<span class="line-added"> 893          * zero. */</span>
<span class="line-added"> 894         len += g_unichar_to_utf8 (val ? val : c, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-added"> 895       }</span>
<span class="line-added"> 896   }</span>
 897       else
<span class="line-modified"> 898   {</span>
<span class="line-modified"> 899     gsize char_len = g_utf8_skip[*(guchar *)last];</span>
 900 
<span class="line-modified"> 901     if (out_buffer)</span>
<span class="line-modified"> 902       memcpy (out_buffer + len, last, char_len);</span>
 903 
<span class="line-modified"> 904     len += char_len;</span>
<span class="line-modified"> 905   }</span>
 906 
 907     }
 908 
 909   return len;
 910 }
 911 
 912 /**
 913  * g_utf8_strup:
 914  * @str: a UTF-8 encoded string
 915  * @len: length of @str, in bytes, or -1 if @str is nul-terminated.
 916  *
 917  * Converts all Unicode characters in the string that have a case
 918  * to uppercase. The exact manner that this is done depends
 919  * on the current locale, and may result in the number of
 920  * characters in the string increasing. (For instance, the
 921  * German ess-zet will be changed to SS.)
 922  *
 923  * Returns: a newly allocated string, with all characters
 924  *    converted to uppercase.
 925  **/
 926 gchar *
 927 g_utf8_strup (const gchar *str,
<span class="line-modified"> 928         gssize       len)</span>
 929 {
 930   gsize result_len;
 931   LocaleType locale_type;
 932   gchar *result;
 933 
 934   g_return_val_if_fail (str != NULL, NULL);
 935 
 936   locale_type = get_locale_type ();
 937 
 938   /*
 939    * We use a two pass approach to keep memory management simple
 940    */
 941   result_len = real_toupper (str, len, NULL, locale_type);
 942 #ifdef GSTREAMER_LITE
 943   if (result_len == 0)
 944     return NULL;
 945 #endif // GSTREAMER_LITE
 946   result = g_malloc (result_len + 1);
 947 #ifdef GSTREAMER_LITE
 948   if (result == NULL)
</pre>
<hr />
<pre>
 966 {
 967   const gchar *p = str;
 968   gint combining_class;
 969 
 970   while (*p)
 971     {
 972       combining_class = g_unichar_combining_class (g_utf8_get_char (p));
 973       if (combining_class == 230)
 974         return TRUE;
 975       else if (combining_class == 0)
 976         break;
 977 
 978       p = g_utf8_next_char (p);
 979     }
 980 
 981   return FALSE;
 982 }
 983 
 984 static gsize
 985 real_tolower (const gchar *str,
<span class="line-modified"> 986         gssize       max_len,</span>
<span class="line-modified"> 987         gchar       *out_buffer,</span>
<span class="line-modified"> 988         LocaleType   locale_type)</span>
 989 {
 990   const gchar *p = str;
 991   const char *last = NULL;
 992   gsize len = 0;
 993 
 994   while ((max_len &lt; 0 || p &lt; str + max_len) &amp;&amp; *p)
 995     {
 996       gunichar c = g_utf8_get_char (p);
 997       int t = TYPE (c);
 998       gunichar val;
 999 
1000       last = p;
1001       p = g_utf8_next_char (p);
1002 
<span class="line-modified">1003       if (locale_type == LOCALE_TURKIC &amp;&amp; (c == &#39;I&#39; ||</span>
<span class="line-modified">1004                                            c == G_UNICHAR_FULLWIDTH_I))</span>
<span class="line-added">1005   {</span>
1006           if (g_utf8_get_char (p) == 0x0307)
1007             {
1008               /* I + COMBINING DOT ABOVE =&gt; i (U+0069) */
1009               len += g_unichar_to_utf8 (0x0069, out_buffer ? out_buffer + len : NULL);
1010               p = g_utf8_next_char (p);
1011             }
1012           else
1013             {
1014               /* I =&gt; LATIN SMALL LETTER DOTLESS I */
1015               len += g_unichar_to_utf8 (0x131, out_buffer ? out_buffer + len : NULL);
1016             }
1017         }
1018       /* Introduce an explicit dot above when lowercasing capital I&#39;s and J&#39;s
1019        * whenever there are more accents above. [SpecialCasing.txt] */
1020       else if (locale_type == LOCALE_LITHUANIAN &amp;&amp;
1021                (c == 0x00cc || c == 0x00cd || c == 0x0128))
1022         {
1023           len += g_unichar_to_utf8 (0x0069, out_buffer ? out_buffer + len : NULL);
1024           len += g_unichar_to_utf8 (0x0307, out_buffer ? out_buffer + len : NULL);
1025 
1026           switch (c)
1027             {
1028             case 0x00cc:
1029               len += g_unichar_to_utf8 (0x0300, out_buffer ? out_buffer + len : NULL);
1030               break;
1031             case 0x00cd:
1032               len += g_unichar_to_utf8 (0x0301, out_buffer ? out_buffer + len : NULL);
1033               break;
1034             case 0x0128:
1035               len += g_unichar_to_utf8 (0x0303, out_buffer ? out_buffer + len : NULL);
1036               break;
1037             }
1038         }
1039       else if (locale_type == LOCALE_LITHUANIAN &amp;&amp;
<span class="line-modified">1040                (c == &#39;I&#39; || c == G_UNICHAR_FULLWIDTH_I ||</span>
<span class="line-added">1041                 c == &#39;J&#39; || c == G_UNICHAR_FULLWIDTH_J || c == 0x012e) &amp;&amp;</span>
1042                has_more_above (p))
1043         {
1044           len += g_unichar_to_utf8 (g_unichar_tolower (c), out_buffer ? out_buffer + len : NULL);
1045           len += g_unichar_to_utf8 (0x0307, out_buffer ? out_buffer + len : NULL);
1046         }
1047       else if (c == 0x03A3) /* GREEK CAPITAL LETTER SIGMA */
<span class="line-modified">1048   {</span>
<span class="line-modified">1049     if ((max_len &lt; 0 || p &lt; str + max_len) &amp;&amp; *p)</span>
<span class="line-modified">1050       {</span>
<span class="line-modified">1051         gunichar next_c = g_utf8_get_char (p);</span>
<span class="line-modified">1052         int next_type = TYPE(next_c);</span>
<span class="line-modified">1053 </span>
<span class="line-modified">1054         /* SIGMA mapps differently depending on whether it is</span>
<span class="line-modified">1055          * final or not. The following simplified test would</span>
<span class="line-modified">1056          * fail in the case of combining marks following the</span>
<span class="line-modified">1057          * sigma, but I don&#39;t think that occurs in real text.</span>
<span class="line-modified">1058          * The test here matches that in ICU.</span>
<span class="line-modified">1059          */</span>
<span class="line-modified">1060         if (ISALPHA (next_type)) /* Lu,Ll,Lt,Lm,Lo */</span>
<span class="line-modified">1061     val = 0x3c3;  /* GREEK SMALL SIGMA */</span>
<span class="line-modified">1062         else</span>
<span class="line-modified">1063     val = 0x3c2;  /* GREEK SMALL FINAL SIGMA */</span>
<span class="line-modified">1064       }</span>
<span class="line-modified">1065     else</span>
<span class="line-modified">1066       val = 0x3c2;  /* GREEK SMALL FINAL SIGMA */</span>
1067 
<span class="line-modified">1068     len += g_unichar_to_utf8 (val, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-modified">1069   }</span>
1070       else if (IS (t,
<span class="line-modified">1071        OR (G_UNICODE_UPPERCASE_LETTER,</span>
<span class="line-modified">1072        OR (G_UNICODE_TITLECASE_LETTER,</span>
<span class="line-modified">1073       0))))</span>
<span class="line-modified">1074   {</span>
<span class="line-modified">1075     val = ATTTABLE (c &gt;&gt; 8, c &amp; 0xff);</span>
1076 
<span class="line-modified">1077     if (val &gt;= 0x1000000)</span>
<span class="line-modified">1078       {</span>
<span class="line-modified">1079         len += output_special_case (out_buffer ? out_buffer + len : NULL, val - 0x1000000, t, 0);</span>
<span class="line-modified">1080       }</span>
<span class="line-modified">1081     else</span>
<span class="line-modified">1082       {</span>
<span class="line-modified">1083         if (t == G_UNICODE_TITLECASE_LETTER)</span>
<span class="line-added">1084     {</span>
<span class="line-added">1085       unsigned int i;</span>
<span class="line-added">1086       for (i = 0; i &lt; G_N_ELEMENTS (title_table); ++i)</span>
1087         {
<span class="line-modified">1088           if (title_table[i][0] == c)</span>
<span class="line-modified">1089       {</span>
<span class="line-modified">1090         val = title_table[i][2];</span>
<span class="line-modified">1091         break;</span>
<span class="line-modified">1092       }</span>









1093         }
1094     }
<span class="line-added">1095 </span>
<span class="line-added">1096         /* Not all uppercase letters are guaranteed to have a lowercase</span>
<span class="line-added">1097          * equivalent.  If this is the case, val will be zero. */</span>
<span class="line-added">1098         len += g_unichar_to_utf8 (val ? val : c, out_buffer ? out_buffer + len : NULL);</span>
<span class="line-added">1099       }</span>
<span class="line-added">1100   }</span>
1101       else
<span class="line-modified">1102   {</span>
<span class="line-modified">1103     gsize char_len = g_utf8_skip[*(guchar *)last];</span>
1104 
<span class="line-modified">1105     if (out_buffer)</span>
<span class="line-modified">1106       memcpy (out_buffer + len, last, char_len);</span>
1107 
<span class="line-modified">1108     len += char_len;</span>
<span class="line-modified">1109   }</span>
1110 
1111     }
1112 
1113   return len;
1114 }
1115 
1116 /**
1117  * g_utf8_strdown:
1118  * @str: a UTF-8 encoded string
1119  * @len: length of @str, in bytes, or -1 if @str is nul-terminated.
1120  *
1121  * Converts all Unicode characters in the string that have a case
1122  * to lowercase. The exact manner that this is done depends
1123  * on the current locale, and may result in the number of
1124  * characters in the string changing.
1125  *
1126  * Returns: a newly allocated string, with all characters
1127  *    converted to lowercase.
1128  **/
1129 gchar *
1130 g_utf8_strdown (const gchar *str,
<span class="line-modified">1131     gssize       len)</span>
1132 {
1133   gsize result_len;
1134   LocaleType locale_type;
1135   gchar *result;
1136 
1137   g_return_val_if_fail (str != NULL, NULL);
1138 
1139   locale_type = get_locale_type ();
1140 
1141   /*
1142    * We use a two pass approach to keep memory management simple
1143    */
1144   result_len = real_tolower (str, len, NULL, locale_type);
1145   result = g_malloc (result_len + 1);
1146 #ifdef GSTREAMER_LITE
1147   if (result == NULL)
1148       return NULL;
1149 #endif // GSTREAMER_LITE
1150   real_tolower (str, len, result, locale_type);
1151   result[result_len] = &#39;\0&#39;;
</pre>
<hr />
<pre>
1158  * @str: a UTF-8 encoded string
1159  * @len: length of @str, in bytes, or -1 if @str is nul-terminated.
1160  *
1161  * Converts a string into a form that is independent of case. The
1162  * result will not correspond to any particular case, but can be
1163  * compared for equality or ordered with the results of calling
1164  * g_utf8_casefold() on other strings.
1165  *
1166  * Note that calling g_utf8_casefold() followed by g_utf8_collate() is
1167  * only an approximation to the correct linguistic case insensitive
1168  * ordering, though it is a fairly good one. Getting this exactly
1169  * right would require a more sophisticated collation function that
1170  * takes case sensitivity into account. GLib does not currently
1171  * provide such a function.
1172  *
1173  * Returns: a newly allocated string, that is a
1174  *   case independent form of @str.
1175  **/
1176 gchar *
1177 g_utf8_casefold (const gchar *str,
<span class="line-modified">1178      gssize       len)</span>
1179 {
1180   GString *result;
1181   const char *p;
1182 
1183   g_return_val_if_fail (str != NULL, NULL);
1184 
1185   result = g_string_new (NULL);
1186   p = str;
1187   while ((len &lt; 0 || p &lt; str + len) &amp;&amp; *p)
1188     {
1189       gunichar ch = g_utf8_get_char (p);
1190 
1191       int start = 0;
1192       int end = G_N_ELEMENTS (casefold_table);
1193 
1194       if (ch &gt;= casefold_table[start].ch &amp;&amp;
1195           ch &lt;= casefold_table[end - 1].ch)
<span class="line-added">1196   {</span>
<span class="line-added">1197     while (TRUE)</span>
<span class="line-added">1198       {</span>
<span class="line-added">1199         int half = (start + end) / 2;</span>
<span class="line-added">1200         if (ch == casefold_table[half].ch)</span>
1201     {
<span class="line-modified">1202       g_string_append (result, casefold_table[half].data);</span>
<span class="line-modified">1203       goto next;</span>













1204     }
<span class="line-added">1205         else if (half == start)</span>
<span class="line-added">1206     break;</span>
<span class="line-added">1207         else if (ch &gt; casefold_table[half].ch)</span>
<span class="line-added">1208     start = half;</span>
<span class="line-added">1209         else</span>
<span class="line-added">1210     end = half;</span>
<span class="line-added">1211       }</span>
<span class="line-added">1212   }</span>
1213 
1214       g_string_append_unichar (result, g_unichar_tolower (ch));
1215 
1216     next:
1217       p = g_utf8_next_char (p);
1218     }
1219 
1220   return g_string_free (result, FALSE);
1221 }
1222 
1223 /**
1224  * g_unichar_get_mirror_char:
1225  * @ch: a Unicode character
1226  * @mirrored_ch: location to store the mirrored character
1227  *
1228  * In Unicode, some characters are &quot;mirrored&quot;. This means that their
1229  * images are mirrored horizontally in text that is laid out from right
1230  * to left. For instance, &quot;(&quot; would become its mirror image, &quot;)&quot;, in
1231  * right-to-left text.
1232  *
</pre>
<hr />
<pre>
1253     *mirrored_ch = mirrored;
1254 
1255   return found;
1256 
1257 }
1258 
1259 #define G_SCRIPT_TABLE_MIDPOINT (G_N_ELEMENTS (g_script_table) / 2)
1260 
1261 static inline GUnicodeScript
1262 g_unichar_get_script_bsearch (gunichar ch)
1263 {
1264   int lower = 0;
1265   int upper = G_N_ELEMENTS (g_script_table) - 1;
1266   static int saved_mid = G_SCRIPT_TABLE_MIDPOINT;
1267   int mid = saved_mid;
1268 
1269 
1270   do
1271     {
1272       if (ch &lt; g_script_table[mid].start)
<span class="line-modified">1273   upper = mid - 1;</span>
1274       else if (ch &gt;= g_script_table[mid].start + g_script_table[mid].chars)
<span class="line-modified">1275   lower = mid + 1;</span>
1276       else
<span class="line-modified">1277   return g_script_table[saved_mid = mid].script;</span>
1278 
1279       mid = (lower + upper) / 2;
1280     }
1281   while (lower &lt;= upper);
1282 
1283   return G_UNICODE_SCRIPT_UNKNOWN;
1284 }
1285 
1286 /**
1287  * g_unichar_get_script:
1288  * @ch: a Unicode character
1289  *
1290  * Looks up the #GUnicodeScript for a particular character (as defined
1291  * by Unicode Standard Annex \#24). No check is made for @ch being a
1292  * valid Unicode character; if you pass in invalid character, the
1293  * result is undefined.
1294  *
1295  * This function is equivalent to pango_script_for_unichar() and the
1296  * two are interchangeable.
1297  *
</pre>
<hr />
<pre>
1425 
1426   /* Unicode-6.1 additions */
1427     PACK (&#39;C&#39;,&#39;a&#39;,&#39;k&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_CHAKMA */
1428     PACK (&#39;M&#39;,&#39;e&#39;,&#39;r&#39;,&#39;c&#39;), /* G_UNICODE_SCRIPT_MEROITIC_CURSIVE */
1429     PACK (&#39;M&#39;,&#39;e&#39;,&#39;r&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS */
1430     PACK (&#39;P&#39;,&#39;l&#39;,&#39;r&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_MIAO */
1431     PACK (&#39;S&#39;,&#39;h&#39;,&#39;r&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_SHARADA */
1432     PACK (&#39;S&#39;,&#39;o&#39;,&#39;r&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_SORA_SOMPENG */
1433     PACK (&#39;T&#39;,&#39;a&#39;,&#39;k&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_TAKRI */
1434 
1435   /* Unicode 7.0 additions */
1436     PACK (&#39;B&#39;,&#39;a&#39;,&#39;s&#39;,&#39;s&#39;), /* G_UNICODE_SCRIPT_BASSA_VAH */
1437     PACK (&#39;A&#39;,&#39;g&#39;,&#39;h&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN */
1438     PACK (&#39;D&#39;,&#39;u&#39;,&#39;p&#39;,&#39;l&#39;), /* G_UNICODE_SCRIPT_DUPLOYAN */
1439     PACK (&#39;E&#39;,&#39;l&#39;,&#39;b&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_ELBASAN */
1440     PACK (&#39;G&#39;,&#39;r&#39;,&#39;a&#39;,&#39;n&#39;), /* G_UNICODE_SCRIPT_GRANTHA */
1441     PACK (&#39;K&#39;,&#39;h&#39;,&#39;o&#39;,&#39;j&#39;), /* G_UNICODE_SCRIPT_KHOJKI*/
1442     PACK (&#39;S&#39;,&#39;i&#39;,&#39;n&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_KHUDAWADI */
1443     PACK (&#39;L&#39;,&#39;i&#39;,&#39;n&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_LINEAR_A */
1444     PACK (&#39;M&#39;,&#39;a&#39;,&#39;h&#39;,&#39;j&#39;), /* G_UNICODE_SCRIPT_MAHAJANI */
<span class="line-modified">1445     PACK (&#39;M&#39;,&#39;a&#39;,&#39;n&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_MANICHAEAN */</span>
1446     PACK (&#39;M&#39;,&#39;e&#39;,&#39;n&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_MENDE_KIKAKUI */
1447     PACK (&#39;M&#39;,&#39;o&#39;,&#39;d&#39;,&#39;i&#39;), /* G_UNICODE_SCRIPT_MODI */
1448     PACK (&#39;M&#39;,&#39;r&#39;,&#39;o&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_MRO */
1449     PACK (&#39;N&#39;,&#39;b&#39;,&#39;a&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_NABATAEAN */
1450     PACK (&#39;N&#39;,&#39;a&#39;,&#39;r&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN */
1451     PACK (&#39;P&#39;,&#39;e&#39;,&#39;r&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_OLD_PERMIC */
1452     PACK (&#39;H&#39;,&#39;m&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_PAHAWH_HMONG */
1453     PACK (&#39;P&#39;,&#39;a&#39;,&#39;l&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_PALMYRENE */
1454     PACK (&#39;P&#39;,&#39;a&#39;,&#39;u&#39;,&#39;c&#39;), /* G_UNICODE_SCRIPT_PAU_CIN_HAU */
1455     PACK (&#39;P&#39;,&#39;h&#39;,&#39;l&#39;,&#39;p&#39;), /* G_UNICODE_SCRIPT_PSALTER_PAHLAVI */
1456     PACK (&#39;S&#39;,&#39;i&#39;,&#39;d&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_SIDDHAM */
1457     PACK (&#39;T&#39;,&#39;i&#39;,&#39;r&#39;,&#39;h&#39;), /* G_UNICODE_SCRIPT_TIRHUTA */
1458     PACK (&#39;W&#39;,&#39;a&#39;,&#39;r&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_WARANG_CITI */
1459 
1460   /* Unicode 8.0 additions */
1461     PACK (&#39;A&#39;,&#39;h&#39;,&#39;o&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_AHOM */
1462     PACK (&#39;H&#39;,&#39;l&#39;,&#39;u&#39;,&#39;w&#39;), /* G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS */
1463     PACK (&#39;H&#39;,&#39;a&#39;,&#39;t&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_HATRAN */
1464     PACK (&#39;M&#39;,&#39;u&#39;,&#39;l&#39;,&#39;t&#39;), /* G_UNICODE_SCRIPT_MULTANI */
1465     PACK (&#39;H&#39;,&#39;u&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_OLD_HUNGARIAN */
</pre>
<hr />
<pre>
1470     PACK (&#39;B&#39;,&#39;h&#39;,&#39;k&#39;,&#39;s&#39;), /* G_UNICODE_SCRIPT_BHAIKSUKI */
1471     PACK (&#39;M&#39;,&#39;a&#39;,&#39;r&#39;,&#39;c&#39;), /* G_UNICODE_SCRIPT_MARCHEN */
1472     PACK (&#39;N&#39;,&#39;e&#39;,&#39;w&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_NEWA */
1473     PACK (&#39;O&#39;,&#39;s&#39;,&#39;g&#39;,&#39;e&#39;), /* G_UNICODE_SCRIPT_OSAGE */
1474     PACK (&#39;T&#39;,&#39;a&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_TANGUT */
1475 
1476   /* Unicode 10.0 additions */
1477     PACK (&#39;G&#39;,&#39;o&#39;,&#39;n&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_MASARAM_GONDI */
1478     PACK (&#39;N&#39;,&#39;s&#39;,&#39;h&#39;,&#39;u&#39;), /* G_UNICODE_SCRIPT_NUSHU */
1479     PACK (&#39;S&#39;,&#39;o&#39;,&#39;y&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_SOYOMBO */
1480     PACK (&#39;Z&#39;,&#39;a&#39;,&#39;n&#39;,&#39;b&#39;), /* G_UNICODE_SCRIPT_ZANABAZAR_SQUARE */
1481 
1482   /* Unicode 11.0 additions */
1483     PACK (&#39;D&#39;,&#39;o&#39;,&#39;g&#39;,&#39;r&#39;), /* G_UNICODE_SCRIPT_DOGRA */
1484     PACK (&#39;G&#39;,&#39;o&#39;,&#39;n&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_GUNJALA_GONDI */
1485     PACK (&#39;R&#39;,&#39;o&#39;,&#39;h&#39;,&#39;g&#39;), /* G_UNICODE_SCRIPT_HANIFI_ROHINGYA */
1486     PACK (&#39;M&#39;,&#39;a&#39;,&#39;k&#39;,&#39;a&#39;), /* G_UNICODE_SCRIPT_MAKASAR */
1487     PACK (&#39;M&#39;,&#39;e&#39;,&#39;d&#39;,&#39;f&#39;), /* G_UNICODE_SCRIPT_MEDEFAIDRIN */
1488     PACK (&#39;S&#39;,&#39;o&#39;,&#39;g&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_OLD_SOGDIAN */
1489     PACK (&#39;S&#39;,&#39;o&#39;,&#39;g&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_SOGDIAN */
<span class="line-added">1490 </span>
<span class="line-added">1491   /* Unicode 12.0 additions */</span>
<span class="line-added">1492     PACK (&#39;E&#39;,&#39;l&#39;,&#39;y&#39;,&#39;m&#39;), /* G_UNICODE_SCRIPT_ELYMAIC */</span>
<span class="line-added">1493     PACK (&#39;N&#39;,&#39;a&#39;,&#39;n&#39;,&#39;d&#39;), /* G_UNICODE_SCRIPT_NANDINAGARI */</span>
<span class="line-added">1494     PACK (&#39;H&#39;,&#39;m&#39;,&#39;n&#39;,&#39;p&#39;), /* G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG */</span>
<span class="line-added">1495     PACK (&#39;W&#39;,&#39;c&#39;,&#39;h&#39;,&#39;o&#39;), /* G_UNICODE_SCRIPT_WANCHO */</span>
1496 #undef PACK
1497 };
1498 
1499 /**
1500  * g_unicode_script_to_iso15924:
1501  * @script: a Unicode script
1502  *
1503  * Looks up the ISO 15924 code for @script.  ISO 15924 assigns four-letter
1504  * codes to scripts.  For example, the code for Arabic is &#39;Arab&#39;.  The
1505  * four letter codes are encoded as a @guint32 by this function in a
1506  * big-endian fashion.  That is, the code returned for Arabic is
1507  * 0x41726162 (0x41 is ASCII code for &#39;A&#39;, 0x72 is ASCII code for &#39;r&#39;, etc).
1508  *
1509  * See
1510  * [Codes for the representation of names of scripts](http://unicode.org/iso15924/codelists.html)
1511  * for details.
1512  *
1513  * Returns: the ISO 15924 code for @script, encoded as an integer,
1514  *   of zero if @script is %G_UNICODE_SCRIPT_INVALID_CODE or
1515  *   ISO 15924 code &#39;Zzzz&#39; (script code for UNKNOWN) if @script is not understood.
</pre>
</td>
</tr>
</table>
<center><a href="gunidecomp.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gurifuncs.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>