<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gpoll.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gpattern.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gpoll.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gpoll.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 70,10 ***</span>
<span class="line-new-header">--- 70,11 ---</span>
  #include &lt;errno.h&gt;
  
  #ifdef G_OS_WIN32
  #define STRICT
  #include &lt;windows.h&gt;
<span class="line-added">+ #include &lt;process.h&gt;</span>
  #endif /* G_OS_WIN32 */
  
  #include &quot;gpoll.h&quot;
  
  #ifdef G_OS_WIN32
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,26 ***</span>
   *
   * Since: 2.20
   **/
  gint
  g_poll (GPollFD *fds,
<span class="line-modified">!     guint    nfds,</span>
<span class="line-modified">!     gint     timeout)</span>
  {
    return poll ((struct pollfd *)fds, nfds, timeout);
  }
  
<span class="line-modified">! #else   /* !HAVE_POLL */</span>
  
  #ifdef G_OS_WIN32
  
  static int
  poll_rest (GPollFD *msg_fd,
             HANDLE  *handles,
             GPollFD *handle_to_fd[],
             gint     nhandles,
<span class="line-modified">!            gint     timeout)</span>
  {
    DWORD ready;
    GPollFD *f;
    int recursed_result;
  
<span class="line-new-header">--- 117,27 ---</span>
   *
   * Since: 2.20
   **/
  gint
  g_poll (GPollFD *fds,
<span class="line-modified">!   guint    nfds,</span>
<span class="line-modified">!   gint     timeout)</span>
  {
    return poll ((struct pollfd *)fds, nfds, timeout);
  }
  
<span class="line-modified">! #else /* !HAVE_POLL */</span>
  
  #ifdef G_OS_WIN32
  
  static int
  poll_rest (GPollFD *msg_fd,
<span class="line-added">+            GPollFD *stop_fd,</span>
             HANDLE  *handles,
             GPollFD *handle_to_fd[],
             gint     nhandles,
<span class="line-modified">!            gint     timeout_ms)</span>
  {
    DWORD ready;
    GPollFD *f;
    int recursed_result;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,183 ***</span>
      {
        /* Wait for either messages or handles
         * -&gt; Use MsgWaitForMultipleObjectsEx
         */
        if (_g_main_poll_debug)
<span class="line-modified">!     g_print (&quot;  MsgWaitForMultipleObjectsEx(%d, %d)\n&quot;, nhandles, timeout);</span>
  
<span class="line-modified">!       ready = MsgWaitForMultipleObjectsEx (nhandles, handles, timeout,</span>
<span class="line-modified">!                        QS_ALLINPUT, MWMO_ALERTABLE);</span>
  
        if (ready == WAIT_FAILED)
<span class="line-modified">!     {</span>
<span class="line-modified">!       gchar *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-modified">!       g_warning (&quot;MsgWaitForMultipleObjectsEx failed: %s&quot;, emsg);</span>
<span class="line-modified">!       g_free (emsg);</span>
<span class="line-modified">!     }</span>
      }
    else if (nhandles == 0)
      {
        /* No handles to wait for, just the timeout */
<span class="line-modified">!       if (timeout == INFINITE)</span>
<span class="line-modified">!     ready = WAIT_FAILED;</span>
        else
<span class="line-modified">!     {</span>
            /* Wait for the current process to die, more efficient than SleepEx(). */
<span class="line-modified">!           WaitForSingleObjectEx (GetCurrentProcess (), timeout, TRUE);</span>
<span class="line-modified">!       ready = WAIT_TIMEOUT;</span>
<span class="line-modified">!     }</span>
      }
    else
      {
        /* Wait for just handles
         * -&gt; Use WaitForMultipleObjectsEx
         */
        if (_g_main_poll_debug)
<span class="line-modified">!     g_print (&quot;  WaitForMultipleObjectsEx(%d, %d)\n&quot;, nhandles, timeout);</span>
  
<span class="line-modified">!       ready = WaitForMultipleObjectsEx (nhandles, handles, FALSE, timeout, TRUE);</span>
        if (ready == WAIT_FAILED)
<span class="line-modified">!     {</span>
<span class="line-modified">!       gchar *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-modified">!       g_warning (&quot;WaitForMultipleObjectsEx failed: %s&quot;, emsg);</span>
<span class="line-modified">!       g_free (emsg);</span>
<span class="line-modified">!     }</span>
      }
  
    if (_g_main_poll_debug)
      g_print (&quot;  wait returns %ld%s\n&quot;,
<span class="line-modified">!          ready,</span>
<span class="line-modified">!          (ready == WAIT_FAILED ? &quot; (WAIT_FAILED)&quot; :</span>
<span class="line-modified">!           (ready == WAIT_TIMEOUT ? &quot; (WAIT_TIMEOUT)&quot; :</span>
<span class="line-modified">!            (msg_fd != NULL &amp;&amp; ready == WAIT_OBJECT_0 + nhandles ? &quot; (msg)&quot; : &quot;&quot;))));</span>
  
    if (ready == WAIT_FAILED)
      return -1;
    else if (ready == WAIT_TIMEOUT ||
<span class="line-modified">!        ready == WAIT_IO_COMPLETION)</span>
      return 0;
    else if (msg_fd != NULL &amp;&amp; ready == WAIT_OBJECT_0 + nhandles)
      {
        msg_fd-&gt;revents |= G_IO_IN;
  
        /* If we have a timeout, or no handles to poll, be satisfied
         * with just noticing we have messages waiting.
         */
<span class="line-modified">!       if (timeout != 0 || nhandles == 0)</span>
<span class="line-modified">!     return 1;</span>
  
        /* If no timeout and handles to poll, recurse to poll them,
         * too.
         */
<span class="line-modified">!       recursed_result = poll_rest (NULL, handles, handle_to_fd, nhandles, 0);</span>
        return (recursed_result == -1) ? -1 : 1 + recursed_result;
      }
    else if (ready &gt;= WAIT_OBJECT_0 &amp;&amp; ready &lt; WAIT_OBJECT_0 + nhandles)
      {
        f = handle_to_fd[ready - WAIT_OBJECT_0];
<span class="line-modified">!           f-&gt;revents = f-&gt;events;</span>
<span class="line-modified">!           if (_g_main_poll_debug)</span>
          g_print (&quot;  got event %p\n&quot;, (HANDLE) f-&gt;fd);
  
        /* If no timeout and polling several handles, recurse to poll
         * the rest of them.
         */
<span class="line-modified">!       if (timeout == 0 &amp;&amp; nhandles &gt; 1)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       /* Poll the handles with index &gt; ready */</span>
<span class="line-modified">!           HANDLE  *shorter_handles;</span>
            GPollFD **shorter_handle_to_fd;
<span class="line-modified">!           gint     shorter_nhandles;</span>
  
            shorter_handles = &amp;handles[ready - WAIT_OBJECT_0 + 1];
            shorter_handle_to_fd = &amp;handle_to_fd[ready - WAIT_OBJECT_0 + 1];
            shorter_nhandles = nhandles - (ready - WAIT_OBJECT_0 + 1);
  
<span class="line-modified">!       recursed_result = poll_rest (NULL, shorter_handles, shorter_handle_to_fd, shorter_nhandles, 0);</span>
<span class="line-modified">!       return (recursed_result == -1) ? -1 : 1 + recursed_result;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!       return 1;</span>
      }
  
    return 0;
  }
  
<span class="line-modified">! gint</span>
<span class="line-removed">- g_poll (GPollFD *fds,</span>
<span class="line-removed">-     guint    nfds,</span>
<span class="line-removed">-     gint     timeout)</span>
  {
    HANDLE handles[MAXIMUM_WAIT_OBJECTS];
    GPollFD *handle_to_fd[MAXIMUM_WAIT_OBJECTS];
<span class="line-modified">!   GPollFD *msg_fd = NULL;</span>
<span class="line-modified">!   GPollFD *f;</span>
<span class="line-modified">!   gint nhandles = 0;</span>
    int retval;
  
<span class="line-removed">-   if (_g_main_poll_debug)</span>
<span class="line-removed">-     g_print (&quot;g_poll: waiting for&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   for (f = fds; f &lt; &amp;fds[nfds]; ++f)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-     if (f-&gt;fd == G_WIN32_MSG_HANDLE &amp;&amp; (f-&gt;events &amp; G_IO_IN))</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-           if (_g_main_poll_debug &amp;&amp; msg_fd == NULL)</span>
<span class="line-removed">-       g_print (&quot; MSG&quot;);</span>
<span class="line-removed">-           msg_fd = f;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     else if (f-&gt;fd &gt; 0)</span>
<span class="line-removed">-       {</span>
<span class="line-removed">-         if (nhandles == MAXIMUM_WAIT_OBJECTS)</span>
<span class="line-removed">-           {</span>
<span class="line-removed">-             g_warning (&quot;Too many handles to wait for!&quot;);</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-           {</span>
<span class="line-removed">-         if (_g_main_poll_debug)</span>
<span class="line-removed">-           g_print (&quot; %p&quot;, (HANDLE) f-&gt;fd);</span>
<span class="line-removed">-               handle_to_fd[nhandles] = f;</span>
<span class="line-removed">-         handles[nhandles++] = (HANDLE) f-&gt;fd;</span>
<span class="line-removed">-           }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       f-&gt;revents = 0;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (_g_main_poll_debug)</span>
<span class="line-removed">-     g_print (&quot;\n&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (timeout == -1)</span>
<span class="line-removed">-     timeout = INFINITE;</span>
<span class="line-removed">- </span>
    /* Polling for several things? */
<span class="line-modified">!   if (nhandles &gt; 1 || (nhandles &gt; 0 &amp;&amp; msg_fd != NULL))</span>
      {
        /* First check if one or several of them are immediately
         * available
         */
<span class="line-modified">!       retval = poll_rest (msg_fd, handles, handle_to_fd, nhandles, 0);</span>
  
        /* If not, and we have a significant timeout, poll again with
         * timeout then. Note that this will return indication for only
         * one event, or only for messages.
         */
<span class="line-modified">!       if (retval == 0 &amp;&amp; (timeout == INFINITE || timeout &gt; 0))</span>
<span class="line-modified">!     retval = poll_rest (msg_fd, handles, handle_to_fd, nhandles, timeout);</span>
      }
    else
      {
        /* Just polling for one thing, so no need to check first if
         * available immediately
         */
<span class="line-modified">!       retval = poll_rest (msg_fd, handles, handle_to_fd, nhandles, timeout);</span>
      }
  
    if (retval == -1)
      for (f = fds; f &lt; &amp;fds[nfds]; ++f)
        f-&gt;revents = 0;
  
    return retval;
  }
  
  #else  /* !G_OS_WIN32 */
  
<span class="line-new-header">--- 145,349 ---</span>
      {
        /* Wait for either messages or handles
         * -&gt; Use MsgWaitForMultipleObjectsEx
         */
        if (_g_main_poll_debug)
<span class="line-modified">!   g_print (&quot;  MsgWaitForMultipleObjectsEx(%d, %d)\n&quot;, nhandles, timeout_ms);</span>
  
<span class="line-modified">!       ready = MsgWaitForMultipleObjectsEx (nhandles, handles, timeout_ms,</span>
<span class="line-modified">!              QS_ALLINPUT, MWMO_ALERTABLE);</span>
  
        if (ready == WAIT_FAILED)
<span class="line-modified">!   {</span>
<span class="line-modified">!     gchar *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-modified">!     g_warning (&quot;MsgWaitForMultipleObjectsEx failed: %s&quot;, emsg);</span>
<span class="line-modified">!     g_free (emsg);</span>
<span class="line-modified">!   }</span>
      }
    else if (nhandles == 0)
      {
        /* No handles to wait for, just the timeout */
<span class="line-modified">!       if (timeout_ms == INFINITE)</span>
<span class="line-modified">!   ready = WAIT_FAILED;</span>
        else
<span class="line-modified">!         {</span>
            /* Wait for the current process to die, more efficient than SleepEx(). */
<span class="line-modified">!           WaitForSingleObjectEx (GetCurrentProcess (), timeout_ms, TRUE);</span>
<span class="line-modified">!           ready = WAIT_TIMEOUT;</span>
<span class="line-modified">!         }</span>
      }
    else
      {
        /* Wait for just handles
         * -&gt; Use WaitForMultipleObjectsEx
         */
        if (_g_main_poll_debug)
<span class="line-modified">!   g_print (&quot;  WaitForMultipleObjectsEx(%d, %d)\n&quot;, nhandles, timeout_ms);</span>
  
<span class="line-modified">!       ready = WaitForMultipleObjectsEx (nhandles, handles, FALSE, timeout_ms, TRUE);</span>
        if (ready == WAIT_FAILED)
<span class="line-modified">!   {</span>
<span class="line-modified">!     gchar *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-modified">!     g_warning (&quot;WaitForMultipleObjectsEx failed: %s&quot;, emsg);</span>
<span class="line-modified">!     g_free (emsg);</span>
<span class="line-modified">!   }</span>
      }
  
    if (_g_main_poll_debug)
      g_print (&quot;  wait returns %ld%s\n&quot;,
<span class="line-modified">!        ready,</span>
<span class="line-modified">!        (ready == WAIT_FAILED ? &quot; (WAIT_FAILED)&quot; :</span>
<span class="line-modified">!         (ready == WAIT_TIMEOUT ? &quot; (WAIT_TIMEOUT)&quot; :</span>
<span class="line-modified">!          (msg_fd != NULL &amp;&amp; ready == WAIT_OBJECT_0 + nhandles ? &quot; (msg)&quot; : &quot;&quot;))));</span>
  
    if (ready == WAIT_FAILED)
      return -1;
    else if (ready == WAIT_TIMEOUT ||
<span class="line-modified">!      ready == WAIT_IO_COMPLETION)</span>
      return 0;
    else if (msg_fd != NULL &amp;&amp; ready == WAIT_OBJECT_0 + nhandles)
      {
        msg_fd-&gt;revents |= G_IO_IN;
  
        /* If we have a timeout, or no handles to poll, be satisfied
         * with just noticing we have messages waiting.
         */
<span class="line-modified">!       if (timeout_ms != 0 || nhandles == 0)</span>
<span class="line-modified">!   return 1;</span>
  
        /* If no timeout and handles to poll, recurse to poll them,
         * too.
         */
<span class="line-modified">!       recursed_result = poll_rest (NULL, stop_fd, handles, handle_to_fd, nhandles, 0);</span>
        return (recursed_result == -1) ? -1 : 1 + recursed_result;
      }
    else if (ready &gt;= WAIT_OBJECT_0 &amp;&amp; ready &lt; WAIT_OBJECT_0 + nhandles)
      {
<span class="line-added">+       int retval;</span>
<span class="line-added">+ </span>
        f = handle_to_fd[ready - WAIT_OBJECT_0];
<span class="line-modified">!       f-&gt;revents = f-&gt;events;</span>
<span class="line-modified">!       if (_g_main_poll_debug)</span>
          g_print (&quot;  got event %p\n&quot;, (HANDLE) f-&gt;fd);
  
<span class="line-added">+       /* Do not count the stop_fd */</span>
<span class="line-added">+       retval = (f != stop_fd) ? 1 : 0;</span>
<span class="line-added">+ </span>
        /* If no timeout and polling several handles, recurse to poll
         * the rest of them.
         */
<span class="line-modified">!       if (timeout_ms == 0 &amp;&amp; nhandles &gt; 1)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           /* Poll the handles with index &gt; ready */</span>
<span class="line-modified">!           HANDLE *shorter_handles;</span>
            GPollFD **shorter_handle_to_fd;
<span class="line-modified">!           gint shorter_nhandles;</span>
  
            shorter_handles = &amp;handles[ready - WAIT_OBJECT_0 + 1];
            shorter_handle_to_fd = &amp;handle_to_fd[ready - WAIT_OBJECT_0 + 1];
            shorter_nhandles = nhandles - (ready - WAIT_OBJECT_0 + 1);
  
<span class="line-modified">!           recursed_result = poll_rest (NULL, stop_fd, shorter_handles, shorter_handle_to_fd, shorter_nhandles, 0);</span>
<span class="line-modified">!           return (recursed_result == -1) ? -1 : retval + recursed_result;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       return retval;</span>
      }
  
    return 0;
  }
  
<span class="line-modified">! typedef struct</span>
  {
    HANDLE handles[MAXIMUM_WAIT_OBJECTS];
    GPollFD *handle_to_fd[MAXIMUM_WAIT_OBJECTS];
<span class="line-modified">!   GPollFD *msg_fd;</span>
<span class="line-modified">!   GPollFD *stop_fd;</span>
<span class="line-modified">!   gint nhandles;</span>
<span class="line-added">+   gint timeout_ms;</span>
<span class="line-added">+ } GWin32PollThreadData;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static gint</span>
<span class="line-added">+ poll_single_thread (GWin32PollThreadData *data)</span>
<span class="line-added">+ {</span>
    int retval;
  
    /* Polling for several things? */
<span class="line-modified">!   if (data-&gt;nhandles &gt; 1 || (data-&gt;nhandles &gt; 0 &amp;&amp; data-&gt;msg_fd != NULL))</span>
      {
        /* First check if one or several of them are immediately
         * available
         */
<span class="line-modified">!       retval = poll_rest (data-&gt;msg_fd, data-&gt;stop_fd, data-&gt;handles, data-&gt;handle_to_fd, data-&gt;nhandles, 0);</span>
  
        /* If not, and we have a significant timeout, poll again with
         * timeout then. Note that this will return indication for only
         * one event, or only for messages.
         */
<span class="line-modified">!       if (retval == 0 &amp;&amp; (data-&gt;timeout_ms == INFINITE || data-&gt;timeout_ms &gt; 0))</span>
<span class="line-modified">!         retval = poll_rest (data-&gt;msg_fd, data-&gt;stop_fd, data-&gt;handles, data-&gt;handle_to_fd, data-&gt;nhandles, data-&gt;timeout_ms);</span>
      }
    else
      {
        /* Just polling for one thing, so no need to check first if
         * available immediately
         */
<span class="line-modified">!       retval = poll_rest (data-&gt;msg_fd, data-&gt;stop_fd, data-&gt;handles, data-&gt;handle_to_fd, data-&gt;nhandles, data-&gt;timeout_ms);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return retval;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void</span>
<span class="line-added">+ fill_poll_thread_data (GPollFD              *fds,</span>
<span class="line-added">+                        guint                 nfds,</span>
<span class="line-added">+                        gint                  timeout_ms,</span>
<span class="line-added">+                        GPollFD              *stop_fd,</span>
<span class="line-added">+                        GWin32PollThreadData *data)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   GPollFD *f;</span>
<span class="line-added">+ </span>
<span class="line-added">+   data-&gt;timeout_ms = timeout_ms;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (stop_fd != NULL)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       if (_g_main_poll_debug)</span>
<span class="line-added">+         g_print (&quot; Stop FD: %p&quot;, (HANDLE) stop_fd-&gt;fd);</span>
<span class="line-added">+ </span>
<span class="line-added">+       g_assert (data-&gt;nhandles &lt; MAXIMUM_WAIT_OBJECTS);</span>
<span class="line-added">+ </span>
<span class="line-added">+       data-&gt;stop_fd = stop_fd;</span>
<span class="line-added">+       data-&gt;handle_to_fd[data-&gt;nhandles] = stop_fd;</span>
<span class="line-added">+       data-&gt;handles[data-&gt;nhandles++] = (HANDLE) stop_fd-&gt;fd;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   for (f = fds; f &lt; &amp;fds[nfds]; ++f)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       if ((data-&gt;nhandles == MAXIMUM_WAIT_OBJECTS) ||</span>
<span class="line-added">+           (data-&gt;msg_fd != NULL &amp;&amp; (data-&gt;nhandles == MAXIMUM_WAIT_OBJECTS - 1)))</span>
<span class="line-added">+         {</span>
<span class="line-added">+           g_warning (&quot;Too many handles to wait for!&quot;);</span>
<span class="line-added">+           break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (f-&gt;fd == G_WIN32_MSG_HANDLE &amp;&amp; (f-&gt;events &amp; G_IO_IN))</span>
<span class="line-added">+         {</span>
<span class="line-added">+           if (_g_main_poll_debug &amp;&amp; data-&gt;msg_fd == NULL)</span>
<span class="line-added">+             g_print (&quot; MSG&quot;);</span>
<span class="line-added">+           data-&gt;msg_fd = f;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       else if (f-&gt;fd &gt; 0)</span>
<span class="line-added">+         {</span>
<span class="line-added">+           if (_g_main_poll_debug)</span>
<span class="line-added">+             g_print (&quot; %p&quot;, (HANDLE) f-&gt;fd);</span>
<span class="line-added">+           data-&gt;handle_to_fd[data-&gt;nhandles] = f;</span>
<span class="line-added">+           data-&gt;handles[data-&gt;nhandles++] = (HANDLE) f-&gt;fd;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+       f-&gt;revents = 0;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static guint __stdcall</span>
<span class="line-added">+ poll_thread_run (gpointer user_data)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   GWin32PollThreadData *data = user_data;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Docs say that it is safer to call _endthreadex by our own:</span>
<span class="line-added">+    * https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/endthread-endthreadex</span>
<span class="line-added">+    */</span>
<span class="line-added">+   _endthreadex (poll_single_thread (data));</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_assert_not_reached ();</span>
<span class="line-added">+ </span>
<span class="line-added">+   return 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* One slot for a possible msg object or the stop event */</span>
<span class="line-added">+ #define MAXIMUM_WAIT_OBJECTS_PER_THREAD (MAXIMUM_WAIT_OBJECTS - 1)</span>
<span class="line-added">+ </span>
<span class="line-added">+ gint</span>
<span class="line-added">+ g_poll (GPollFD *fds,</span>
<span class="line-added">+   guint    nfds,</span>
<span class="line-added">+   gint     timeout)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   guint nthreads, threads_remain;</span>
<span class="line-added">+   HANDLE thread_handles[MAXIMUM_WAIT_OBJECTS];</span>
<span class="line-added">+   GWin32PollThreadData *threads_data;</span>
<span class="line-added">+   GPollFD stop_event = { 0, };</span>
<span class="line-added">+   GPollFD *f;</span>
<span class="line-added">+   guint i, fds_idx = 0;</span>
<span class="line-added">+   DWORD ready;</span>
<span class="line-added">+   DWORD thread_retval;</span>
<span class="line-added">+   int retval;</span>
<span class="line-added">+   GPollFD *msg_fd = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (timeout == -1)</span>
<span class="line-added">+     timeout = INFINITE;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Simple case without extra threads */</span>
<span class="line-added">+   if (nfds &lt;= MAXIMUM_WAIT_OBJECTS)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       GWin32PollThreadData data = { 0, };</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (_g_main_poll_debug)</span>
<span class="line-added">+         g_print (&quot;g_poll: waiting for&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+       fill_poll_thread_data (fds, nfds, timeout, NULL, &amp;data);</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (_g_main_poll_debug)</span>
<span class="line-added">+         g_print (&quot;\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+       retval = poll_single_thread (&amp;data);</span>
<span class="line-added">+       if (retval == -1)</span>
<span class="line-added">+         for (f = fds; f &lt; &amp;fds[nfds]; ++f)</span>
<span class="line-added">+           f-&gt;revents = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+       return retval;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (_g_main_poll_debug)</span>
<span class="line-added">+     g_print (&quot;g_poll: polling with threads\n&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+   nthreads = nfds / MAXIMUM_WAIT_OBJECTS_PER_THREAD;</span>
<span class="line-added">+   threads_remain = nfds % MAXIMUM_WAIT_OBJECTS_PER_THREAD;</span>
<span class="line-added">+   if (threads_remain &gt; 0)</span>
<span class="line-added">+     nthreads++;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (nthreads &gt; MAXIMUM_WAIT_OBJECTS_PER_THREAD)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       g_warning (&quot;Too many handles to wait for in threads!&quot;);</span>
<span class="line-added">+       nthreads = MAXIMUM_WAIT_OBJECTS_PER_THREAD;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if GLIB_SIZEOF_VOID_P == 8</span>
<span class="line-added">+   stop_event.fd = (gint64)CreateEventW (NULL, TRUE, FALSE, NULL);</span>
<span class="line-added">+ #else</span>
<span class="line-added">+   stop_event.fd = (gint)CreateEventW (NULL, TRUE, FALSE, NULL);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+   stop_event.events = G_IO_IN;</span>
<span class="line-added">+ </span>
<span class="line-added">+   threads_data = g_new0 (GWin32PollThreadData, nthreads);</span>
<span class="line-added">+   for (i = 0; i &lt; nthreads; i++)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       guint thread_fds;</span>
<span class="line-added">+       guint ignore;</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (i == (nthreads - 1) &amp;&amp; threads_remain &gt; 0)</span>
<span class="line-added">+         thread_fds = threads_remain;</span>
<span class="line-added">+       else</span>
<span class="line-added">+         thread_fds = MAXIMUM_WAIT_OBJECTS_PER_THREAD;</span>
<span class="line-added">+ </span>
<span class="line-added">+       fill_poll_thread_data (fds + fds_idx, thread_fds, timeout, &amp;stop_event, &amp;threads_data[i]);</span>
<span class="line-added">+       fds_idx += thread_fds;</span>
<span class="line-added">+ </span>
<span class="line-added">+       /* We must poll for messages from the same thread, so poll it along with the threads */</span>
<span class="line-added">+       if (threads_data[i].msg_fd != NULL)</span>
<span class="line-added">+         {</span>
<span class="line-added">+           msg_fd = threads_data[i].msg_fd;</span>
<span class="line-added">+           threads_data[i].msg_fd = NULL;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+       thread_handles[i] = (HANDLE) _beginthreadex (NULL, 0, poll_thread_run, &amp;threads_data[i], 0, &amp;ignore);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Wait for at least one thread to return */</span>
<span class="line-added">+   if (msg_fd != NULL)</span>
<span class="line-added">+     ready = MsgWaitForMultipleObjectsEx (nthreads, thread_handles, timeout,</span>
<span class="line-added">+                                          QS_ALLINPUT, MWMO_ALERTABLE);</span>
<span class="line-added">+   else</span>
<span class="line-added">+     ready = WaitForMultipleObjects (nthreads, thread_handles, timeout &gt; 0, timeout);</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Signal the stop in case any of the threads did not stop yet */</span>
<span class="line-added">+   if (!SetEvent ((HANDLE)stop_event.fd))</span>
<span class="line-added">+     {</span>
<span class="line-added">+       gchar *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-added">+       g_warning (&quot;gpoll: failed to signal the stop event: %s&quot;, emsg);</span>
<span class="line-added">+       g_free (emsg);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Wait for the rest of the threads to finish */</span>
<span class="line-added">+   WaitForMultipleObjects (nthreads, thread_handles, TRUE, INFINITE);</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* The return value of all the threads give us all the fds that changed state */</span>
<span class="line-added">+   retval = 0;</span>
<span class="line-added">+   if (msg_fd != NULL &amp;&amp; ready == WAIT_OBJECT_0 + nthreads)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       msg_fd-&gt;revents |= G_IO_IN;</span>
<span class="line-added">+       retval = 1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   for (i = 0; i &lt; nthreads; i++)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       if (GetExitCodeThread (thread_handles[i], &amp;thread_retval))</span>
<span class="line-added">+         retval = retval == -1 ? -1 : thread_retval == -1 ? -1 : retval + thread_retval;</span>
<span class="line-added">+ </span>
<span class="line-added">+       CloseHandle (thread_handles[i]);</span>
      }
  
    if (retval == -1)
      for (f = fds; f &lt; &amp;fds[nfds]; ++f)
        f-&gt;revents = 0;
  
<span class="line-added">+   g_free (threads_data);</span>
<span class="line-added">+   CloseHandle ((HANDLE)stop_event.fd);</span>
<span class="line-added">+ </span>
    return retval;
  }
  
  #else  /* !G_OS_WIN32 */
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 333,12 ***</span>
  #include &lt;sys/select.h&gt;
  #endif /* HAVE_SYS_SELECT_H */
  
  gint
  g_poll (GPollFD *fds,
<span class="line-modified">!     guint    nfds,</span>
<span class="line-modified">!     gint     timeout)</span>
  {
    struct timeval tv;
    fd_set rset, wset, xset;
    GPollFD *f;
    int ready;
<span class="line-new-header">--- 501,12 ---</span>
  #include &lt;sys/select.h&gt;
  #endif /* HAVE_SYS_SELECT_H */
  
  gint
  g_poll (GPollFD *fds,
<span class="line-modified">!   guint    nfds,</span>
<span class="line-modified">!   gint     timeout)</span>
  {
    struct timeval tv;
    fd_set rset, wset, xset;
    GPollFD *f;
    int ready;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 349,38 ***</span>
    FD_ZERO (&amp;xset);
  
    for (f = fds; f &lt; &amp;fds[nfds]; ++f)
      if (f-&gt;fd &gt;= 0)
        {
<span class="line-modified">!     if (f-&gt;events &amp; G_IO_IN)</span>
<span class="line-modified">!       FD_SET (f-&gt;fd, &amp;rset);</span>
<span class="line-modified">!     if (f-&gt;events &amp; G_IO_OUT)</span>
<span class="line-modified">!       FD_SET (f-&gt;fd, &amp;wset);</span>
<span class="line-modified">!     if (f-&gt;events &amp; G_IO_PRI)</span>
<span class="line-modified">!       FD_SET (f-&gt;fd, &amp;xset);</span>
<span class="line-modified">!     if (f-&gt;fd &gt; maxfd &amp;&amp; (f-&gt;events &amp; (G_IO_IN|G_IO_OUT|G_IO_PRI)))</span>
<span class="line-modified">!       maxfd = f-&gt;fd;</span>
        }
  
    tv.tv_sec = timeout / 1000;
    tv.tv_usec = (timeout % 1000) * 1000;
  
    ready = select (maxfd + 1, &amp;rset, &amp;wset, &amp;xset,
<span class="line-modified">!           timeout == -1 ? NULL : &amp;tv);</span>
    if (ready &gt; 0)
      for (f = fds; f &lt; &amp;fds[nfds]; ++f)
        {
<span class="line-modified">!     f-&gt;revents = 0;</span>
<span class="line-modified">!     if (f-&gt;fd &gt;= 0)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         if (FD_ISSET (f-&gt;fd, &amp;rset))</span>
<span class="line-modified">!           f-&gt;revents |= G_IO_IN;</span>
<span class="line-modified">!         if (FD_ISSET (f-&gt;fd, &amp;wset))</span>
<span class="line-modified">!           f-&gt;revents |= G_IO_OUT;</span>
<span class="line-modified">!         if (FD_ISSET (f-&gt;fd, &amp;xset))</span>
<span class="line-modified">!           f-&gt;revents |= G_IO_PRI;</span>
<span class="line-modified">!       }</span>
        }
  
    return ready;
  }
  
<span class="line-new-header">--- 517,38 ---</span>
    FD_ZERO (&amp;xset);
  
    for (f = fds; f &lt; &amp;fds[nfds]; ++f)
      if (f-&gt;fd &gt;= 0)
        {
<span class="line-modified">!   if (f-&gt;events &amp; G_IO_IN)</span>
<span class="line-modified">!     FD_SET (f-&gt;fd, &amp;rset);</span>
<span class="line-modified">!   if (f-&gt;events &amp; G_IO_OUT)</span>
<span class="line-modified">!     FD_SET (f-&gt;fd, &amp;wset);</span>
<span class="line-modified">!   if (f-&gt;events &amp; G_IO_PRI)</span>
<span class="line-modified">!     FD_SET (f-&gt;fd, &amp;xset);</span>
<span class="line-modified">!   if (f-&gt;fd &gt; maxfd &amp;&amp; (f-&gt;events &amp; (G_IO_IN|G_IO_OUT|G_IO_PRI)))</span>
<span class="line-modified">!     maxfd = f-&gt;fd;</span>
        }
  
    tv.tv_sec = timeout / 1000;
    tv.tv_usec = (timeout % 1000) * 1000;
  
    ready = select (maxfd + 1, &amp;rset, &amp;wset, &amp;xset,
<span class="line-modified">!       timeout == -1 ? NULL : &amp;tv);</span>
    if (ready &gt; 0)
      for (f = fds; f &lt; &amp;fds[nfds]; ++f)
        {
<span class="line-modified">!   f-&gt;revents = 0;</span>
<span class="line-modified">!   if (f-&gt;fd &gt;= 0)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       if (FD_ISSET (f-&gt;fd, &amp;rset))</span>
<span class="line-modified">!         f-&gt;revents |= G_IO_IN;</span>
<span class="line-modified">!       if (FD_ISSET (f-&gt;fd, &amp;wset))</span>
<span class="line-modified">!         f-&gt;revents |= G_IO_OUT;</span>
<span class="line-modified">!       if (FD_ISSET (f-&gt;fd, &amp;xset))</span>
<span class="line-modified">!         f-&gt;revents |= G_IO_PRI;</span>
<span class="line-modified">!     }</span>
        }
  
    return ready;
  }
  
</pre>
<center><a href="gpattern.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gpoll.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>