<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstminiobject.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstmeta.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstminiobject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstminiobject.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  20  */
  21 /**
  22  * SECTION:gstminiobject
  23  * @title: GstMiniObject
  24  * @short_description: Lightweight base class for the GStreamer object hierarchy
  25  *
  26  * #GstMiniObject is a simple structure that can be used to implement refcounted
  27  * types.
  28  *
  29  * Subclasses will include #GstMiniObject as the first member in their structure
  30  * and then call gst_mini_object_init() to initialize the #GstMiniObject fields.
  31  *
  32  * gst_mini_object_ref() and gst_mini_object_unref() increment and decrement the
  33  * refcount respectively. When the refcount of a mini-object reaches 0, the
  34  * dispose function is called first and when this returns %TRUE, the free
  35  * function of the miniobject is called.
  36  *
  37  * A copy can be made with gst_mini_object_copy().
  38  *
  39  * gst_mini_object_is_writable() will return %TRUE when the refcount of the
<span class="line-modified">  40  * object is exactly 1, meaning the current caller has the only reference to the</span>
<span class="line-modified">  41  * object. gst_mini_object_make_writable() will return a writable version of the</span>
<span class="line-modified">  42  * object, which might be a new copy when the refcount was not 1.</span>

  43  *
  44  * Opaque data can be associated with a #GstMiniObject with
  45  * gst_mini_object_set_qdata() and gst_mini_object_get_qdata(). The data is
  46  * meant to be specific to the particular object and is not automatically copied
  47  * with gst_mini_object_copy() or similar methods.
  48  *
  49  * A weak reference can be added and remove with gst_mini_object_weak_ref()
  50  * and gst_mini_object_weak_unref() respectively.
  51  */
  52 #ifdef HAVE_CONFIG_H
  53 #include &quot;config.h&quot;
  54 #endif
  55 
  56 #include &quot;gst/gst_private.h&quot;
  57 #include &quot;gst/gstminiobject.h&quot;
  58 #include &quot;gst/gstinfo.h&quot;
  59 #include &lt;gobject/gvaluecollector.h&gt;
  60 
  61 /* Mutex used for weak referencing */
  62 G_LOCK_DEFINE_STATIC (qdata_mutex);
  63 static GQuark weak_ref_quark;
  64 
  65 #define SHARE_ONE (1 &lt;&lt; 16)
  66 #define SHARE_TWO (2 &lt;&lt; 16)
  67 #define SHARE_MASK (~(SHARE_ONE - 1))
  68 #define IS_SHARED(state) (state &gt;= SHARE_TWO)
  69 #define LOCK_ONE (GST_LOCK_FLAG_LAST)
  70 #define FLAG_MASK (GST_LOCK_FLAG_LAST - 1)
  71 #define LOCK_MASK ((SHARE_ONE - 1) - FLAG_MASK)
  72 #define LOCK_FLAG_MASK (SHARE_ONE - 1)
  73 





























  74 typedef struct
  75 {
  76   GQuark quark;
  77   GstMiniObjectNotify notify;
  78   gpointer data;
  79   GDestroyNotify destroy;
  80 } GstQData;
  81 
<span class="line-modified">  82 #define QDATA(o,i)          ((GstQData *)(o)-&gt;qdata)[(i)]</span>











  83 #define QDATA_QUARK(o,i)    (QDATA(o,i).quark)
  84 #define QDATA_NOTIFY(o,i)   (QDATA(o,i).notify)
  85 #define QDATA_DATA(o,i)     (QDATA(o,i).data)
  86 #define QDATA_DESTROY(o,i)  (QDATA(o,i).destroy)
  87 
  88 void
  89 _priv_gst_mini_object_initialize (void)
  90 {
  91   weak_ref_quark = g_quark_from_static_string (&quot;GstMiniObjectWeakRefQuark&quot;);
  92 }
  93 
  94 /**
  95  * gst_mini_object_init: (skip)
  96  * @mini_object: a #GstMiniObject
  97  * @flags: initial #GstMiniObjectFlags
  98  * @type: the #GType of the mini-object to create
  99  * @copy_func: (allow-none): the copy function, or %NULL
 100  * @dispose_func: (allow-none): the dispose function, or %NULL
 101  * @free_func: (allow-none): the free function or %NULL
 102  *
 103  * Initializes a mini-object with the desired type and copy/dispose/free
 104  * functions.
 105  */
 106 void
 107 gst_mini_object_init (GstMiniObject * mini_object, guint flags, GType type,
 108     GstMiniObjectCopyFunction copy_func,
 109     GstMiniObjectDisposeFunction dispose_func,
 110     GstMiniObjectFreeFunction free_func)
 111 {
 112   mini_object-&gt;type = type;
 113   mini_object-&gt;refcount = 1;
 114   mini_object-&gt;lockstate = 0;
 115   mini_object-&gt;flags = flags;
 116 
 117   mini_object-&gt;copy = copy_func;
 118   mini_object-&gt;dispose = dispose_func;
 119   mini_object-&gt;free = free_func;
 120 
<span class="line-modified"> 121   mini_object-&gt;n_qdata = 0;</span>
<span class="line-modified"> 122   mini_object-&gt;qdata = NULL;</span>

 123 
 124   GST_TRACER_MINI_OBJECT_CREATED (mini_object);
 125 }
 126 
 127 /**
 128  * gst_mini_object_copy: (skip)
 129  * @mini_object: the mini-object to copy
 130  *
 131  * Creates a copy of the mini-object.
 132  *
 133  * MT safe
 134  *
 135  * Returns: (transfer full) (nullable): the new mini-object if copying is
 136  * possible, %NULL otherwise.
 137  */
 138 GstMiniObject *
 139 gst_mini_object_copy (const GstMiniObject * mini_object)
 140 {
 141   GstMiniObject *copy;
 142 
</pre>
<hr />
<pre>
 167   g_return_val_if_fail (object != NULL, FALSE);
 168   g_return_val_if_fail (GST_MINI_OBJECT_IS_LOCKABLE (object), FALSE);
 169 
 170   if (G_UNLIKELY (object-&gt;flags &amp; GST_MINI_OBJECT_FLAG_LOCK_READONLY &amp;&amp;
 171           flags &amp; GST_LOCK_FLAG_WRITE))
 172     return FALSE;
 173 
 174   do {
 175     access_mode = flags &amp; FLAG_MASK;
 176     newstate = state = g_atomic_int_get (&amp;object-&gt;lockstate);
 177 
 178     GST_CAT_TRACE (GST_CAT_LOCKING, &quot;lock %p: state %08x, access_mode %d&quot;,
 179         object, state, access_mode);
 180 
 181     if (access_mode &amp; GST_LOCK_FLAG_EXCLUSIVE) {
 182       /* shared ref */
 183       newstate += SHARE_ONE;
 184       access_mode &amp;= ~GST_LOCK_FLAG_EXCLUSIVE;
 185     }
 186 
<span class="line-modified"> 187       /* shared counter &gt; 1 and write access is not allowed */</span>
 188     if (((state &amp; GST_LOCK_FLAG_WRITE) != 0
 189             || (access_mode &amp; GST_LOCK_FLAG_WRITE) != 0)
 190         &amp;&amp; IS_SHARED (newstate))
<span class="line-modified"> 191         goto lock_failed;</span>
 192 
 193     if (access_mode) {
 194       if ((state &amp; LOCK_FLAG_MASK) == 0) {
 195         /* nothing mapped, set access_mode */
 196         newstate |= access_mode;
 197       } else {
 198         /* access_mode must match */
 199         if ((state &amp; access_mode) != access_mode)
 200           goto lock_failed;
 201       }
 202       /* increase refcount */
 203       newstate += LOCK_ONE;
 204     }
 205   } while (!g_atomic_int_compare_and_exchange (&amp;object-&gt;lockstate, state,
 206           newstate));
 207 
 208   return TRUE;
 209 
 210 lock_failed:
 211   {
</pre>
<hr />
<pre>
 240 
 241     if (access_mode &amp; GST_LOCK_FLAG_EXCLUSIVE) {
 242       /* shared counter */
 243       g_return_if_fail (state &gt;= SHARE_ONE);
 244       newstate -= SHARE_ONE;
 245       access_mode &amp;= ~GST_LOCK_FLAG_EXCLUSIVE;
 246     }
 247 
 248     if (access_mode) {
 249       g_return_if_fail ((state &amp; access_mode) == access_mode);
 250       /* decrease the refcount */
 251       newstate -= LOCK_ONE;
 252       /* last refcount, unset access_mode */
 253       if ((newstate &amp; LOCK_FLAG_MASK) == access_mode)
 254         newstate &amp;= ~LOCK_FLAG_MASK;
 255     }
 256   } while (!g_atomic_int_compare_and_exchange (&amp;object-&gt;lockstate, state,
 257           newstate));
 258 }
 259 


























 260 /**
 261  * gst_mini_object_is_writable:
 262  * @mini_object: the mini-object to check
 263  *
 264  * If @mini_object has the LOCKABLE flag set, check if the current EXCLUSIVE
 265  * lock on @object is the only one, this means that changes to the object will
 266  * not be visible to any other object.
 267  *
 268  * If the LOCKABLE flag is not set, check if the refcount of @mini_object is
 269  * exactly 1, meaning that no other reference exists to the object and that the
 270  * object is therefore writable.
 271  *
 272  * Modification of a mini-object should only be done after verifying that it
 273  * is writable.
 274  *
 275  * Returns: %TRUE if the object is writable.
 276  */
 277 gboolean
 278 gst_mini_object_is_writable (const GstMiniObject * mini_object)
 279 {
 280   gboolean result;

 281 
 282   g_return_val_if_fail (mini_object != NULL, FALSE);
 283 


 284   if (GST_MINI_OBJECT_IS_LOCKABLE (mini_object)) {
 285     result = !IS_SHARED (g_atomic_int_get (&amp;mini_object-&gt;lockstate));
 286   } else {
 287     result = (GST_MINI_OBJECT_REFCOUNT_VALUE (mini_object) == 1);
 288   }








































 289   return result;
 290 }
 291 
 292 /**
 293  * gst_mini_object_make_writable: (skip)
 294  * @mini_object: (transfer full): the mini-object to make writable
 295  *
 296  * Checks if a mini-object is writable.  If not, a writable copy is made and
 297  * returned.  This gives away the reference to the original mini object,
 298  * and returns a reference to the new object.
 299  *
 300  * MT safe
 301  *
 302  * Returns: (transfer full): a mini-object (possibly the same pointer) that
 303  *     is writable.
 304  */
 305 GstMiniObject *
 306 gst_mini_object_make_writable (GstMiniObject * mini_object)
 307 {
 308   GstMiniObject *ret;
</pre>
<hr />
<pre>
 326  * @mini_object: the mini-object
 327  *
 328  * Increase the reference count of the mini-object.
 329  *
 330  * Note that the refcount affects the writability
 331  * of @mini-object, see gst_mini_object_is_writable(). It is
 332  * important to note that keeping additional references to
 333  * GstMiniObject instances can potentially increase the number
 334  * of memcpy operations in a pipeline, especially if the miniobject
 335  * is a #GstBuffer.
 336  *
 337  * Returns: (transfer full): the mini-object.
 338  */
 339 GstMiniObject *
 340 gst_mini_object_ref (GstMiniObject * mini_object)
 341 {
 342   gint old_refcount, new_refcount;
 343 
 344   g_return_val_if_fail (mini_object != NULL, NULL);
 345   /* we can&#39;t assert that the refcount &gt; 0 since the _free functions
<span class="line-modified"> 346    * increments the refcount from 0 to 1 again to allow resurecting</span>
 347    * the object
 348    g_return_val_if_fail (mini_object-&gt;refcount &gt; 0, NULL);
 349    */
 350 
 351   old_refcount = g_atomic_int_add (&amp;mini_object-&gt;refcount, 1);
 352   new_refcount = old_refcount + 1;
 353 
 354   GST_CAT_TRACE (GST_CAT_REFCOUNTING, &quot;%p ref %d-&gt;%d&quot;, mini_object,
 355       old_refcount, new_refcount);
 356 
 357   GST_TRACER_MINI_OBJECT_REFFED (mini_object, new_refcount);
 358 
 359   return mini_object;
 360 }
 361 

 362 static gint
 363 find_notify (GstMiniObject * object, GQuark quark, gboolean match_notify,
 364     GstMiniObjectNotify notify, gpointer data)
 365 {
 366   guint i;


 367 
<span class="line-modified"> 368   for (i = 0; i &lt; object-&gt;n_qdata; i++) {</span>
<span class="line-modified"> 369     if (QDATA_QUARK (object, i) == quark) {</span>





 370       /* check if we need to match the callback too */
<span class="line-modified"> 371       if (!match_notify || (QDATA_NOTIFY (object, i) == notify &amp;&amp;</span>
<span class="line-modified"> 372               QDATA_DATA (object, i) == data))</span>
 373         return i;
 374     }
 375   }
 376   return -1;
 377 }
 378 
 379 static void
 380 remove_notify (GstMiniObject * object, gint index)
 381 {






 382   /* remove item */
<span class="line-modified"> 383   if (--object-&gt;n_qdata == 0) {</span>

 384     /* we don&#39;t shrink but free when everything is gone */
<span class="line-modified"> 385     g_free (object-&gt;qdata);</span>
<span class="line-modified"> 386     object-&gt;qdata = NULL;</span>
<span class="line-modified"> 387   } else if (index != object-&gt;n_qdata)</span>
<span class="line-modified"> 388     QDATA (object, index) = QDATA (object, object-&gt;n_qdata);</span>










































 389 }
 390 
 391 static void
 392 set_notify (GstMiniObject * object, gint index, GQuark quark,
 393     GstMiniObjectNotify notify, gpointer data, GDestroyNotify destroy)
 394 {





 395   if (index == -1) {
 396     /* add item */
<span class="line-modified"> 397     index = object-&gt;n_qdata++;</span>
<span class="line-modified"> 398     object-&gt;qdata =</span>
<span class="line-modified"> 399         g_realloc (object-&gt;qdata, sizeof (GstQData) * object-&gt;n_qdata);</span>







 400   }
<span class="line-modified"> 401   QDATA_QUARK (object, index) = quark;</span>
<span class="line-modified"> 402   QDATA_NOTIFY (object, index) = notify;</span>
<span class="line-modified"> 403   QDATA_DATA (object, index) = data;</span>
<span class="line-modified"> 404   QDATA_DESTROY (object, index) = destroy;</span>

 405 }
 406 
 407 static void
<span class="line-modified"> 408 call_finalize_notify (GstMiniObject * obj)</span>
 409 {
 410   guint i;













 411 
<span class="line-modified"> 412   for (i = 0; i &lt; obj-&gt;n_qdata; i++) {</span>
<span class="line-removed"> 413     if (QDATA_QUARK (obj, i) == weak_ref_quark)</span>
<span class="line-removed"> 414       QDATA_NOTIFY (obj, i) (QDATA_DATA (obj, i), obj);</span>
<span class="line-removed"> 415     if (QDATA_DESTROY (obj, i))</span>
<span class="line-removed"> 416       QDATA_DESTROY (obj, i) (QDATA_DATA (obj, i));</span>
 417   }

















 418 }
 419 
 420 /**
 421  * gst_mini_object_unref: (skip)
 422  * @mini_object: the mini-object
 423  *
 424  * Decreases the reference count of the mini-object, possibly freeing
 425  * the mini-object.
 426  */
 427 void
 428 gst_mini_object_unref (GstMiniObject * mini_object)
 429 {
 430   gint old_refcount, new_refcount;
 431 
 432   g_return_if_fail (mini_object != NULL);
 433   g_return_if_fail (GST_MINI_OBJECT_REFCOUNT_VALUE (mini_object) &gt; 0);
 434 
 435   old_refcount = g_atomic_int_add (&amp;mini_object-&gt;refcount, -1);
 436   new_refcount = old_refcount - 1;
 437 
</pre>
<hr />
<pre>
 440   GST_CAT_TRACE (GST_CAT_REFCOUNTING, &quot;%p unref %d-&gt;%d&quot;,
 441       mini_object, old_refcount, new_refcount);
 442 
 443   GST_TRACER_MINI_OBJECT_UNREFFED (mini_object, new_refcount);
 444 
 445   if (new_refcount == 0) {
 446     gboolean do_free;
 447 
 448     if (mini_object-&gt;dispose)
 449       do_free = mini_object-&gt;dispose (mini_object);
 450     else
 451       do_free = TRUE;
 452 
 453     /* if the subclass recycled the object (and returned FALSE) we don&#39;t
 454      * want to free the instance anymore */
 455     if (G_LIKELY (do_free)) {
 456       /* there should be no outstanding locks */
 457       g_return_if_fail ((g_atomic_int_get (&amp;mini_object-&gt;lockstate) &amp; LOCK_MASK)
 458           &lt; 4);
 459 
<span class="line-modified"> 460       if (mini_object-&gt;n_qdata) {</span>
<span class="line-modified"> 461         call_finalize_notify (mini_object);</span>
<span class="line-removed"> 462         g_free (mini_object-&gt;qdata);</span>
<span class="line-removed"> 463       }</span>
 464       GST_TRACER_MINI_OBJECT_DESTROYED (mini_object);
 465       if (mini_object-&gt;free)
 466         mini_object-&gt;free (mini_object);
 467     }
 468   }
 469 }
 470 
























 471 /**
 472  * gst_mini_object_replace:
 473  * @olddata: (inout) (transfer full) (nullable): pointer to a pointer to a
 474  *     mini-object to be replaced
 475  * @newdata: (allow-none): pointer to new mini-object
 476  *
 477  * Atomically modifies a pointer to point to a new mini-object.
 478  * The reference count of @olddata is decreased and the reference count of
 479  * @newdata is increased.
 480  *
 481  * Either @newdata and the value pointed to by @olddata may be %NULL.
 482  *
 483  * Returns: %TRUE if @newdata was different from @olddata
 484  */
 485 gboolean
 486 gst_mini_object_replace (GstMiniObject ** olddata, GstMiniObject * newdata)
 487 {
 488   GstMiniObject *olddata_val;
 489 
 490   g_return_val_if_fail (olddata != NULL, FALSE);
</pre>
<hr />
<pre>
 653  * the old pointer set, using %NULL as pointer essentially
 654  * removes the data stored.
 655  *
 656  * @destroy may be specified which is called with @data as argument
 657  * when the @object is disposed, or the data is being overwritten by
 658  * a call to gst_mini_object_set_qdata() with the same @quark.
 659  */
 660 void
 661 gst_mini_object_set_qdata (GstMiniObject * object, GQuark quark,
 662     gpointer data, GDestroyNotify destroy)
 663 {
 664   gint i;
 665   gpointer old_data = NULL;
 666   GDestroyNotify old_notify = NULL;
 667 
 668   g_return_if_fail (object != NULL);
 669   g_return_if_fail (quark &gt; 0);
 670 
 671   G_LOCK (qdata_mutex);
 672   if ((i = find_notify (object, quark, FALSE, NULL, NULL)) != -1) {

 673 
<span class="line-modified"> 674     old_data = QDATA_DATA (object, i);</span>
<span class="line-modified"> 675     old_notify = QDATA_DESTROY (object, i);</span>
 676 
 677     if (data == NULL)
 678       remove_notify (object, i);
 679   }
 680   if (data != NULL)
 681     set_notify (object, i, quark, NULL, data, destroy);
 682   G_UNLOCK (qdata_mutex);
 683 
 684   if (old_notify)
 685     old_notify (old_data);
 686 }
 687 
 688 /**
 689  * gst_mini_object_get_qdata:
 690  * @object: The GstMiniObject to get a stored user data pointer from
 691  * @quark: A #GQuark, naming the user data pointer
 692  *
 693  * This function gets back user data pointers stored via
 694  * gst_mini_object_set_qdata().
 695  *
 696  * Returns: (transfer none) (nullable): The user data pointer set, or
 697  * %NULL
 698  */
 699 gpointer
 700 gst_mini_object_get_qdata (GstMiniObject * object, GQuark quark)
 701 {
 702   guint i;
 703   gpointer result;
 704 
 705   g_return_val_if_fail (object != NULL, NULL);
 706   g_return_val_if_fail (quark &gt; 0, NULL);
 707 
 708   G_LOCK (qdata_mutex);
<span class="line-modified"> 709   if ((i = find_notify (object, quark, FALSE, NULL, NULL)) != -1)</span>
<span class="line-modified"> 710     result = QDATA_DATA (object, i);</span>
<span class="line-modified"> 711   else</span>

 712     result = NULL;

 713   G_UNLOCK (qdata_mutex);
 714 
 715   return result;
 716 }
 717 
 718 /**
 719  * gst_mini_object_steal_qdata:
 720  * @object: The GstMiniObject to get a stored user data pointer from
 721  * @quark: A #GQuark, naming the user data pointer
 722  *
 723  * This function gets back user data pointers stored via gst_mini_object_set_qdata()
 724  * and removes the data from @object without invoking its destroy() function (if
 725  * any was set).
 726  *
 727  * Returns: (transfer full) (nullable): The user data pointer set, or
 728  * %NULL
 729  */
 730 gpointer
 731 gst_mini_object_steal_qdata (GstMiniObject * object, GQuark quark)
 732 {
 733   guint i;
 734   gpointer result;
 735 
 736   g_return_val_if_fail (object != NULL, NULL);
 737   g_return_val_if_fail (quark &gt; 0, NULL);
 738 
 739   G_LOCK (qdata_mutex);
 740   if ((i = find_notify (object, quark, FALSE, NULL, NULL)) != -1) {
<span class="line-modified"> 741     result = QDATA_DATA (object, i);</span>

 742     remove_notify (object, i);
 743   } else {
 744     result = NULL;
 745   }
 746   G_UNLOCK (qdata_mutex);
 747 
 748   return result;
 749 }




































































































































</pre>
</td>
<td>
<hr />
<pre>
  20  */
  21 /**
  22  * SECTION:gstminiobject
  23  * @title: GstMiniObject
  24  * @short_description: Lightweight base class for the GStreamer object hierarchy
  25  *
  26  * #GstMiniObject is a simple structure that can be used to implement refcounted
  27  * types.
  28  *
  29  * Subclasses will include #GstMiniObject as the first member in their structure
  30  * and then call gst_mini_object_init() to initialize the #GstMiniObject fields.
  31  *
  32  * gst_mini_object_ref() and gst_mini_object_unref() increment and decrement the
  33  * refcount respectively. When the refcount of a mini-object reaches 0, the
  34  * dispose function is called first and when this returns %TRUE, the free
  35  * function of the miniobject is called.
  36  *
  37  * A copy can be made with gst_mini_object_copy().
  38  *
  39  * gst_mini_object_is_writable() will return %TRUE when the refcount of the
<span class="line-modified">  40  * object is exactly 1 and there is no parent or a single parent exists and is</span>
<span class="line-modified">  41  * writable itself, meaning the current caller has the only reference to the</span>
<span class="line-modified">  42  * object. gst_mini_object_make_writable() will return a writable version of</span>
<span class="line-added">  43  * the object, which might be a new copy when the refcount was not 1.</span>
  44  *
  45  * Opaque data can be associated with a #GstMiniObject with
  46  * gst_mini_object_set_qdata() and gst_mini_object_get_qdata(). The data is
  47  * meant to be specific to the particular object and is not automatically copied
  48  * with gst_mini_object_copy() or similar methods.
  49  *
  50  * A weak reference can be added and remove with gst_mini_object_weak_ref()
  51  * and gst_mini_object_weak_unref() respectively.
  52  */
  53 #ifdef HAVE_CONFIG_H
  54 #include &quot;config.h&quot;
  55 #endif
  56 
  57 #include &quot;gst/gst_private.h&quot;
  58 #include &quot;gst/gstminiobject.h&quot;
  59 #include &quot;gst/gstinfo.h&quot;
  60 #include &lt;gobject/gvaluecollector.h&gt;
  61 
  62 /* Mutex used for weak referencing */
  63 G_LOCK_DEFINE_STATIC (qdata_mutex);
  64 static GQuark weak_ref_quark;
  65 
  66 #define SHARE_ONE (1 &lt;&lt; 16)
  67 #define SHARE_TWO (2 &lt;&lt; 16)
  68 #define SHARE_MASK (~(SHARE_ONE - 1))
  69 #define IS_SHARED(state) (state &gt;= SHARE_TWO)
  70 #define LOCK_ONE (GST_LOCK_FLAG_LAST)
  71 #define FLAG_MASK (GST_LOCK_FLAG_LAST - 1)
  72 #define LOCK_MASK ((SHARE_ONE - 1) - FLAG_MASK)
  73 #define LOCK_FLAG_MASK (SHARE_ONE - 1)
  74 
<span class="line-added">  75 /* For backwards compatibility reasons we use the</span>
<span class="line-added">  76  * guint and gpointer in the GstMiniObject struct in</span>
<span class="line-added">  77  * a rather complicated way to store the parent(s) and qdata.</span>
<span class="line-added">  78  * Originally the were just the number of qdatas and the qdata.</span>
<span class="line-added">  79  *</span>
<span class="line-added">  80  * The guint is used as an atomic state integer with the following</span>
<span class="line-added">  81  * states:</span>
<span class="line-added">  82  * - Locked: 0, basically a spinlock</span>
<span class="line-added">  83  * - No parent, no qdata: 1 (pointer is NULL)</span>
<span class="line-added">  84  * - One parent: 2 (pointer contains the parent)</span>
<span class="line-added">  85  * - Multiple parents or qdata: 3 (pointer contains a PrivData struct)</span>
<span class="line-added">  86  *</span>
<span class="line-added">  87  * Unless we&#39;re in state 3, we always have to move to Locking state</span>
<span class="line-added">  88  * atomically and release that again later to the target state whenever</span>
<span class="line-added">  89  * accessing the pointer. When we&#39;re in state 3, we will never move to lower</span>
<span class="line-added">  90  * states again</span>
<span class="line-added">  91  *</span>
<span class="line-added">  92  * FIXME 2.0: We should store this directly inside the struct, possibly</span>
<span class="line-added">  93  * keeping space directly allocated for a couple of parents</span>
<span class="line-added">  94  */</span>
<span class="line-added">  95 </span>
<span class="line-added">  96 enum</span>
<span class="line-added">  97 {</span>
<span class="line-added">  98   PRIV_DATA_STATE_LOCKED = 0,</span>
<span class="line-added">  99   PRIV_DATA_STATE_NO_PARENT = 1,</span>
<span class="line-added"> 100   PRIV_DATA_STATE_ONE_PARENT = 2,</span>
<span class="line-added"> 101   PRIV_DATA_STATE_PARENTS_OR_QDATA = 3,</span>
<span class="line-added"> 102 };</span>
<span class="line-added"> 103 </span>
 104 typedef struct
 105 {
 106   GQuark quark;
 107   GstMiniObjectNotify notify;
 108   gpointer data;
 109   GDestroyNotify destroy;
 110 } GstQData;
 111 
<span class="line-modified"> 112 typedef struct</span>
<span class="line-added"> 113 {</span>
<span class="line-added"> 114   /* Atomic spinlock: 1 if locked, 0 otherwise */</span>
<span class="line-added"> 115   gint parent_lock;</span>
<span class="line-added"> 116   guint n_parents, n_parents_len;</span>
<span class="line-added"> 117   GstMiniObject **parents;</span>
<span class="line-added"> 118 </span>
<span class="line-added"> 119   guint n_qdata, n_qdata_len;</span>
<span class="line-added"> 120   GstQData *qdata;</span>
<span class="line-added"> 121 } PrivData;</span>
<span class="line-added"> 122 </span>
<span class="line-added"> 123 #define QDATA(q,i)          (q-&gt;qdata)[(i)]</span>
 124 #define QDATA_QUARK(o,i)    (QDATA(o,i).quark)
 125 #define QDATA_NOTIFY(o,i)   (QDATA(o,i).notify)
 126 #define QDATA_DATA(o,i)     (QDATA(o,i).data)
 127 #define QDATA_DESTROY(o,i)  (QDATA(o,i).destroy)
 128 
 129 void
 130 _priv_gst_mini_object_initialize (void)
 131 {
 132   weak_ref_quark = g_quark_from_static_string (&quot;GstMiniObjectWeakRefQuark&quot;);
 133 }
 134 
 135 /**
 136  * gst_mini_object_init: (skip)
 137  * @mini_object: a #GstMiniObject
 138  * @flags: initial #GstMiniObjectFlags
 139  * @type: the #GType of the mini-object to create
 140  * @copy_func: (allow-none): the copy function, or %NULL
 141  * @dispose_func: (allow-none): the dispose function, or %NULL
 142  * @free_func: (allow-none): the free function or %NULL
 143  *
 144  * Initializes a mini-object with the desired type and copy/dispose/free
 145  * functions.
 146  */
 147 void
 148 gst_mini_object_init (GstMiniObject * mini_object, guint flags, GType type,
 149     GstMiniObjectCopyFunction copy_func,
 150     GstMiniObjectDisposeFunction dispose_func,
 151     GstMiniObjectFreeFunction free_func)
 152 {
 153   mini_object-&gt;type = type;
 154   mini_object-&gt;refcount = 1;
 155   mini_object-&gt;lockstate = 0;
 156   mini_object-&gt;flags = flags;
 157 
 158   mini_object-&gt;copy = copy_func;
 159   mini_object-&gt;dispose = dispose_func;
 160   mini_object-&gt;free = free_func;
 161 
<span class="line-modified"> 162   g_atomic_int_set ((gint *) &amp; mini_object-&gt;priv_uint,</span>
<span class="line-modified"> 163       PRIV_DATA_STATE_NO_PARENT);</span>
<span class="line-added"> 164   mini_object-&gt;priv_pointer = NULL;</span>
 165 
 166   GST_TRACER_MINI_OBJECT_CREATED (mini_object);
 167 }
 168 
 169 /**
 170  * gst_mini_object_copy: (skip)
 171  * @mini_object: the mini-object to copy
 172  *
 173  * Creates a copy of the mini-object.
 174  *
 175  * MT safe
 176  *
 177  * Returns: (transfer full) (nullable): the new mini-object if copying is
 178  * possible, %NULL otherwise.
 179  */
 180 GstMiniObject *
 181 gst_mini_object_copy (const GstMiniObject * mini_object)
 182 {
 183   GstMiniObject *copy;
 184 
</pre>
<hr />
<pre>
 209   g_return_val_if_fail (object != NULL, FALSE);
 210   g_return_val_if_fail (GST_MINI_OBJECT_IS_LOCKABLE (object), FALSE);
 211 
 212   if (G_UNLIKELY (object-&gt;flags &amp; GST_MINI_OBJECT_FLAG_LOCK_READONLY &amp;&amp;
 213           flags &amp; GST_LOCK_FLAG_WRITE))
 214     return FALSE;
 215 
 216   do {
 217     access_mode = flags &amp; FLAG_MASK;
 218     newstate = state = g_atomic_int_get (&amp;object-&gt;lockstate);
 219 
 220     GST_CAT_TRACE (GST_CAT_LOCKING, &quot;lock %p: state %08x, access_mode %d&quot;,
 221         object, state, access_mode);
 222 
 223     if (access_mode &amp; GST_LOCK_FLAG_EXCLUSIVE) {
 224       /* shared ref */
 225       newstate += SHARE_ONE;
 226       access_mode &amp;= ~GST_LOCK_FLAG_EXCLUSIVE;
 227     }
 228 
<span class="line-modified"> 229     /* shared counter &gt; 1 and write access is not allowed */</span>
 230     if (((state &amp; GST_LOCK_FLAG_WRITE) != 0
 231             || (access_mode &amp; GST_LOCK_FLAG_WRITE) != 0)
 232         &amp;&amp; IS_SHARED (newstate))
<span class="line-modified"> 233       goto lock_failed;</span>
 234 
 235     if (access_mode) {
 236       if ((state &amp; LOCK_FLAG_MASK) == 0) {
 237         /* nothing mapped, set access_mode */
 238         newstate |= access_mode;
 239       } else {
 240         /* access_mode must match */
 241         if ((state &amp; access_mode) != access_mode)
 242           goto lock_failed;
 243       }
 244       /* increase refcount */
 245       newstate += LOCK_ONE;
 246     }
 247   } while (!g_atomic_int_compare_and_exchange (&amp;object-&gt;lockstate, state,
 248           newstate));
 249 
 250   return TRUE;
 251 
 252 lock_failed:
 253   {
</pre>
<hr />
<pre>
 282 
 283     if (access_mode &amp; GST_LOCK_FLAG_EXCLUSIVE) {
 284       /* shared counter */
 285       g_return_if_fail (state &gt;= SHARE_ONE);
 286       newstate -= SHARE_ONE;
 287       access_mode &amp;= ~GST_LOCK_FLAG_EXCLUSIVE;
 288     }
 289 
 290     if (access_mode) {
 291       g_return_if_fail ((state &amp; access_mode) == access_mode);
 292       /* decrease the refcount */
 293       newstate -= LOCK_ONE;
 294       /* last refcount, unset access_mode */
 295       if ((newstate &amp; LOCK_FLAG_MASK) == access_mode)
 296         newstate &amp;= ~LOCK_FLAG_MASK;
 297     }
 298   } while (!g_atomic_int_compare_and_exchange (&amp;object-&gt;lockstate, state,
 299           newstate));
 300 }
 301 
<span class="line-added"> 302 /* Locks the priv pointer and sets the priv uint to PRIV_DATA_STATE_LOCKED,</span>
<span class="line-added"> 303  * unless the full struct was already stored in the priv pointer.</span>
<span class="line-added"> 304  *</span>
<span class="line-added"> 305  * Returns the previous state of the priv uint</span>
<span class="line-added"> 306  */</span>
<span class="line-added"> 307 static guint</span>
<span class="line-added"> 308 lock_priv_pointer (GstMiniObject * object)</span>
<span class="line-added"> 309 {</span>
<span class="line-added"> 310   gint priv_state = g_atomic_int_get ((gint *) &amp; object-&gt;priv_uint);</span>
<span class="line-added"> 311 </span>
<span class="line-added"> 312   if (priv_state != PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added"> 313     /* As long as the struct was not allocated yet and either someone else</span>
<span class="line-added"> 314      * locked it or our priv_state is out of date, try to lock it */</span>
<span class="line-added"> 315     while (priv_state != PRIV_DATA_STATE_PARENTS_OR_QDATA &amp;&amp;</span>
<span class="line-added"> 316         (priv_state == PRIV_DATA_STATE_LOCKED ||</span>
<span class="line-added"> 317             !g_atomic_int_compare_and_exchange ((gint *) &amp; object-&gt;priv_uint,</span>
<span class="line-added"> 318                 priv_state, PRIV_DATA_STATE_LOCKED)))</span>
<span class="line-added"> 319       priv_state = g_atomic_int_get ((gint *) &amp; object-&gt;priv_uint);</span>
<span class="line-added"> 320 </span>
<span class="line-added"> 321     /* Note that if we got the full struct, we did not store</span>
<span class="line-added"> 322      * PRIV_DATA_STATE_LOCKED and did not actually lock the priv pointer */</span>
<span class="line-added"> 323   }</span>
<span class="line-added"> 324 </span>
<span class="line-added"> 325   return priv_state;</span>
<span class="line-added"> 326 }</span>
<span class="line-added"> 327 </span>
 328 /**
 329  * gst_mini_object_is_writable:
 330  * @mini_object: the mini-object to check
 331  *
 332  * If @mini_object has the LOCKABLE flag set, check if the current EXCLUSIVE
 333  * lock on @object is the only one, this means that changes to the object will
 334  * not be visible to any other object.
 335  *
 336  * If the LOCKABLE flag is not set, check if the refcount of @mini_object is
 337  * exactly 1, meaning that no other reference exists to the object and that the
 338  * object is therefore writable.
 339  *
 340  * Modification of a mini-object should only be done after verifying that it
 341  * is writable.
 342  *
 343  * Returns: %TRUE if the object is writable.
 344  */
 345 gboolean
 346 gst_mini_object_is_writable (const GstMiniObject * mini_object)
 347 {
 348   gboolean result;
<span class="line-added"> 349   gint priv_state;</span>
 350 
 351   g_return_val_if_fail (mini_object != NULL, FALSE);
 352 
<span class="line-added"> 353   /* Let&#39;s first check our own writability. If this already fails there&#39;s</span>
<span class="line-added"> 354    * no point in checking anything else */</span>
 355   if (GST_MINI_OBJECT_IS_LOCKABLE (mini_object)) {
 356     result = !IS_SHARED (g_atomic_int_get (&amp;mini_object-&gt;lockstate));
 357   } else {
 358     result = (GST_MINI_OBJECT_REFCOUNT_VALUE (mini_object) == 1);
 359   }
<span class="line-added"> 360   if (!result)</span>
<span class="line-added"> 361     return result;</span>
<span class="line-added"> 362 </span>
<span class="line-added"> 363   /* We are writable ourselves, but are there parents and are they all</span>
<span class="line-added"> 364    * writable too? */</span>
<span class="line-added"> 365   priv_state = lock_priv_pointer (GST_MINI_OBJECT_CAST (mini_object));</span>
<span class="line-added"> 366 </span>
<span class="line-added"> 367   /* Now we either have to check the full struct and all the</span>
<span class="line-added"> 368    * parents in there, or if there is exactly one parent we</span>
<span class="line-added"> 369    * can check that one */</span>
<span class="line-added"> 370   if (priv_state == PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added"> 371     PrivData *priv_data = mini_object-&gt;priv_pointer;</span>
<span class="line-added"> 372 </span>
<span class="line-added"> 373     /* Lock parents */</span>
<span class="line-added"> 374     while (!g_atomic_int_compare_and_exchange (&amp;priv_data-&gt;parent_lock, 0, 1));</span>
<span class="line-added"> 375 </span>
<span class="line-added"> 376     /* If we have one parent, we&#39;re only writable if that parent is writable.</span>
<span class="line-added"> 377      * Otherwise if we have multiple parents we are not writable, and if</span>
<span class="line-added"> 378      * we have no parent, we are writable */</span>
<span class="line-added"> 379     if (priv_data-&gt;n_parents == 1)</span>
<span class="line-added"> 380       result = gst_mini_object_is_writable (priv_data-&gt;parents[0]);</span>
<span class="line-added"> 381     else if (priv_data-&gt;n_parents == 0)</span>
<span class="line-added"> 382       result = TRUE;</span>
<span class="line-added"> 383     else</span>
<span class="line-added"> 384       result = FALSE;</span>
<span class="line-added"> 385 </span>
<span class="line-added"> 386     /* Unlock again */</span>
<span class="line-added"> 387     g_atomic_int_set (&amp;priv_data-&gt;parent_lock, 0);</span>
<span class="line-added"> 388   } else {</span>
<span class="line-added"> 389     if (priv_state == PRIV_DATA_STATE_ONE_PARENT) {</span>
<span class="line-added"> 390       result = gst_mini_object_is_writable (mini_object-&gt;priv_pointer);</span>
<span class="line-added"> 391     } else {</span>
<span class="line-added"> 392       g_assert (priv_state == PRIV_DATA_STATE_NO_PARENT);</span>
<span class="line-added"> 393       result = TRUE;</span>
<span class="line-added"> 394     }</span>
<span class="line-added"> 395 </span>
<span class="line-added"> 396     /* Unlock again */</span>
<span class="line-added"> 397     g_atomic_int_set ((gint *) &amp; mini_object-&gt;priv_uint, priv_state);</span>
<span class="line-added"> 398   }</span>
<span class="line-added"> 399 </span>
 400   return result;
 401 }
 402 
 403 /**
 404  * gst_mini_object_make_writable: (skip)
 405  * @mini_object: (transfer full): the mini-object to make writable
 406  *
 407  * Checks if a mini-object is writable.  If not, a writable copy is made and
 408  * returned.  This gives away the reference to the original mini object,
 409  * and returns a reference to the new object.
 410  *
 411  * MT safe
 412  *
 413  * Returns: (transfer full): a mini-object (possibly the same pointer) that
 414  *     is writable.
 415  */
 416 GstMiniObject *
 417 gst_mini_object_make_writable (GstMiniObject * mini_object)
 418 {
 419   GstMiniObject *ret;
</pre>
<hr />
<pre>
 437  * @mini_object: the mini-object
 438  *
 439  * Increase the reference count of the mini-object.
 440  *
 441  * Note that the refcount affects the writability
 442  * of @mini-object, see gst_mini_object_is_writable(). It is
 443  * important to note that keeping additional references to
 444  * GstMiniObject instances can potentially increase the number
 445  * of memcpy operations in a pipeline, especially if the miniobject
 446  * is a #GstBuffer.
 447  *
 448  * Returns: (transfer full): the mini-object.
 449  */
 450 GstMiniObject *
 451 gst_mini_object_ref (GstMiniObject * mini_object)
 452 {
 453   gint old_refcount, new_refcount;
 454 
 455   g_return_val_if_fail (mini_object != NULL, NULL);
 456   /* we can&#39;t assert that the refcount &gt; 0 since the _free functions
<span class="line-modified"> 457    * increments the refcount from 0 to 1 again to allow resurrecting</span>
 458    * the object
 459    g_return_val_if_fail (mini_object-&gt;refcount &gt; 0, NULL);
 460    */
 461 
 462   old_refcount = g_atomic_int_add (&amp;mini_object-&gt;refcount, 1);
 463   new_refcount = old_refcount + 1;
 464 
 465   GST_CAT_TRACE (GST_CAT_REFCOUNTING, &quot;%p ref %d-&gt;%d&quot;, mini_object,
 466       old_refcount, new_refcount);
 467 
 468   GST_TRACER_MINI_OBJECT_REFFED (mini_object, new_refcount);
 469 
 470   return mini_object;
 471 }
 472 
<span class="line-added"> 473 /* Called with global qdata lock */</span>
 474 static gint
 475 find_notify (GstMiniObject * object, GQuark quark, gboolean match_notify,
 476     GstMiniObjectNotify notify, gpointer data)
 477 {
 478   guint i;
<span class="line-added"> 479   gint priv_state = g_atomic_int_get ((gint *) &amp; object-&gt;priv_uint);</span>
<span class="line-added"> 480   PrivData *priv_data;</span>
 481 
<span class="line-modified"> 482   if (priv_state != PRIV_DATA_STATE_PARENTS_OR_QDATA)</span>
<span class="line-modified"> 483     return -1;</span>
<span class="line-added"> 484 </span>
<span class="line-added"> 485   priv_data = object-&gt;priv_pointer;</span>
<span class="line-added"> 486 </span>
<span class="line-added"> 487   for (i = 0; i &lt; priv_data-&gt;n_qdata; i++) {</span>
<span class="line-added"> 488     if (QDATA_QUARK (priv_data, i) == quark) {</span>
 489       /* check if we need to match the callback too */
<span class="line-modified"> 490       if (!match_notify || (QDATA_NOTIFY (priv_data, i) == notify &amp;&amp;</span>
<span class="line-modified"> 491               QDATA_DATA (priv_data, i) == data))</span>
 492         return i;
 493     }
 494   }
 495   return -1;
 496 }
 497 
 498 static void
 499 remove_notify (GstMiniObject * object, gint index)
 500 {
<span class="line-added"> 501   gint priv_state = g_atomic_int_get ((gint *) &amp; object-&gt;priv_uint);</span>
<span class="line-added"> 502   PrivData *priv_data;</span>
<span class="line-added"> 503 </span>
<span class="line-added"> 504   g_assert (priv_state == PRIV_DATA_STATE_PARENTS_OR_QDATA);</span>
<span class="line-added"> 505   priv_data = object-&gt;priv_pointer;</span>
<span class="line-added"> 506 </span>
 507   /* remove item */
<span class="line-modified"> 508   priv_data-&gt;n_qdata--;</span>
<span class="line-added"> 509   if (priv_data-&gt;n_qdata == 0) {</span>
 510     /* we don&#39;t shrink but free when everything is gone */
<span class="line-modified"> 511     g_free (priv_data-&gt;qdata);</span>
<span class="line-modified"> 512     priv_data-&gt;qdata = NULL;</span>
<span class="line-modified"> 513     priv_data-&gt;n_qdata_len = 0;</span>
<span class="line-modified"> 514   } else if (index != priv_data-&gt;n_qdata) {</span>
<span class="line-added"> 515     QDATA (priv_data, index) = QDATA (priv_data, priv_data-&gt;n_qdata);</span>
<span class="line-added"> 516   }</span>
<span class="line-added"> 517 }</span>
<span class="line-added"> 518 </span>
<span class="line-added"> 519 /* Make sure we allocate the PrivData of this object if not happened yet */</span>
<span class="line-added"> 520 static void</span>
<span class="line-added"> 521 ensure_priv_data (GstMiniObject * object)</span>
<span class="line-added"> 522 {</span>
<span class="line-added"> 523   gint priv_state;</span>
<span class="line-added"> 524   PrivData *priv_data;</span>
<span class="line-added"> 525   GstMiniObject *parent = NULL;</span>
<span class="line-added"> 526 </span>
<span class="line-added"> 527   GST_CAT_DEBUG (GST_CAT_PERFORMANCE,</span>
<span class="line-added"> 528       &quot;allocating private data %s miniobject %p&quot;,</span>
<span class="line-added"> 529       g_type_name (GST_MINI_OBJECT_TYPE (object)), object);</span>
<span class="line-added"> 530 </span>
<span class="line-added"> 531   priv_state = lock_priv_pointer (object);</span>
<span class="line-added"> 532   if (priv_state == PRIV_DATA_STATE_PARENTS_OR_QDATA)</span>
<span class="line-added"> 533     return;</span>
<span class="line-added"> 534 </span>
<span class="line-added"> 535   /* Now we&#39;re either locked, or someone has already allocated the struct</span>
<span class="line-added"> 536    * before us and we can just go ahead</span>
<span class="line-added"> 537    *</span>
<span class="line-added"> 538    * Note: if someone else allocated it in the meantime, we don&#39;t have to</span>
<span class="line-added"> 539    * unlock as we didn&#39;t lock! */</span>
<span class="line-added"> 540   if (priv_state != PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added"> 541     if (priv_state == PRIV_DATA_STATE_ONE_PARENT)</span>
<span class="line-added"> 542       parent = object-&gt;priv_pointer;</span>
<span class="line-added"> 543 </span>
<span class="line-added"> 544     object-&gt;priv_pointer = priv_data = g_new0 (PrivData, 1);</span>
<span class="line-added"> 545 </span>
<span class="line-added"> 546     if (parent) {</span>
<span class="line-added"> 547       priv_data-&gt;parents = g_new (GstMiniObject *, 16);</span>
<span class="line-added"> 548       priv_data-&gt;n_parents_len = 16;</span>
<span class="line-added"> 549       priv_data-&gt;n_parents = 1;</span>
<span class="line-added"> 550       priv_data-&gt;parents[0] = parent;</span>
<span class="line-added"> 551     }</span>
<span class="line-added"> 552 </span>
<span class="line-added"> 553     /* Unlock */</span>
<span class="line-added"> 554     g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint,</span>
<span class="line-added"> 555         PRIV_DATA_STATE_PARENTS_OR_QDATA);</span>
<span class="line-added"> 556   }</span>
 557 }
 558 
 559 static void
 560 set_notify (GstMiniObject * object, gint index, GQuark quark,
 561     GstMiniObjectNotify notify, gpointer data, GDestroyNotify destroy)
 562 {
<span class="line-added"> 563   PrivData *priv_data;</span>
<span class="line-added"> 564 </span>
<span class="line-added"> 565   ensure_priv_data (object);</span>
<span class="line-added"> 566   priv_data = object-&gt;priv_pointer;</span>
<span class="line-added"> 567 </span>
 568   if (index == -1) {
 569     /* add item */
<span class="line-modified"> 570     index = priv_data-&gt;n_qdata++;</span>
<span class="line-modified"> 571     if (index &gt;= priv_data-&gt;n_qdata_len) {</span>
<span class="line-modified"> 572       priv_data-&gt;n_qdata_len *= 2;</span>
<span class="line-added"> 573       if (priv_data-&gt;n_qdata_len == 0)</span>
<span class="line-added"> 574         priv_data-&gt;n_qdata_len = 16;</span>
<span class="line-added"> 575 </span>
<span class="line-added"> 576       priv_data-&gt;qdata =</span>
<span class="line-added"> 577           g_realloc (priv_data-&gt;qdata,</span>
<span class="line-added"> 578           sizeof (GstQData) * priv_data-&gt;n_qdata_len);</span>
<span class="line-added"> 579     }</span>
 580   }
<span class="line-modified"> 581 </span>
<span class="line-modified"> 582   QDATA_QUARK (priv_data, index) = quark;</span>
<span class="line-modified"> 583   QDATA_NOTIFY (priv_data, index) = notify;</span>
<span class="line-modified"> 584   QDATA_DATA (priv_data, index) = data;</span>
<span class="line-added"> 585   QDATA_DESTROY (priv_data, index) = destroy;</span>
 586 }
 587 
 588 static void
<span class="line-modified"> 589 free_priv_data (GstMiniObject * obj)</span>
 590 {
 591   guint i;
<span class="line-added"> 592   gint priv_state = g_atomic_int_get ((gint *) &amp; obj-&gt;priv_uint);</span>
<span class="line-added"> 593   PrivData *priv_data;</span>
<span class="line-added"> 594 </span>
<span class="line-added"> 595   if (priv_state != PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added"> 596     if (priv_state == PRIV_DATA_STATE_LOCKED) {</span>
<span class="line-added"> 597       g_warning</span>
<span class="line-added"> 598           (&quot;%s: object finalizing but has locked private data (object:%p)&quot;,</span>
<span class="line-added"> 599           G_STRFUNC, obj);</span>
<span class="line-added"> 600     } else if (priv_state == PRIV_DATA_STATE_ONE_PARENT) {</span>
<span class="line-added"> 601       g_warning</span>
<span class="line-added"> 602           (&quot;%s: object finalizing but still has parent (object:%p, parent:%p)&quot;,</span>
<span class="line-added"> 603           G_STRFUNC, obj, obj-&gt;priv_pointer);</span>
<span class="line-added"> 604     }</span>
 605 
<span class="line-modified"> 606     return;</span>




 607   }
<span class="line-added"> 608 </span>
<span class="line-added"> 609   priv_data = obj-&gt;priv_pointer;</span>
<span class="line-added"> 610 </span>
<span class="line-added"> 611   for (i = 0; i &lt; priv_data-&gt;n_qdata; i++) {</span>
<span class="line-added"> 612     if (QDATA_QUARK (priv_data, i) == weak_ref_quark)</span>
<span class="line-added"> 613       QDATA_NOTIFY (priv_data, i) (QDATA_DATA (priv_data, i), obj);</span>
<span class="line-added"> 614     if (QDATA_DESTROY (priv_data, i))</span>
<span class="line-added"> 615       QDATA_DESTROY (priv_data, i) (QDATA_DATA (priv_data, i));</span>
<span class="line-added"> 616   }</span>
<span class="line-added"> 617   g_free (priv_data-&gt;qdata);</span>
<span class="line-added"> 618 </span>
<span class="line-added"> 619   if (priv_data-&gt;n_parents)</span>
<span class="line-added"> 620     g_warning (&quot;%s: object finalizing but still has %d parents (object:%p)&quot;,</span>
<span class="line-added"> 621         G_STRFUNC, priv_data-&gt;n_parents, obj);</span>
<span class="line-added"> 622   g_free (priv_data-&gt;parents);</span>
<span class="line-added"> 623 </span>
<span class="line-added"> 624   g_free (priv_data);</span>
 625 }
 626 
 627 /**
 628  * gst_mini_object_unref: (skip)
 629  * @mini_object: the mini-object
 630  *
 631  * Decreases the reference count of the mini-object, possibly freeing
 632  * the mini-object.
 633  */
 634 void
 635 gst_mini_object_unref (GstMiniObject * mini_object)
 636 {
 637   gint old_refcount, new_refcount;
 638 
 639   g_return_if_fail (mini_object != NULL);
 640   g_return_if_fail (GST_MINI_OBJECT_REFCOUNT_VALUE (mini_object) &gt; 0);
 641 
 642   old_refcount = g_atomic_int_add (&amp;mini_object-&gt;refcount, -1);
 643   new_refcount = old_refcount - 1;
 644 
</pre>
<hr />
<pre>
 647   GST_CAT_TRACE (GST_CAT_REFCOUNTING, &quot;%p unref %d-&gt;%d&quot;,
 648       mini_object, old_refcount, new_refcount);
 649 
 650   GST_TRACER_MINI_OBJECT_UNREFFED (mini_object, new_refcount);
 651 
 652   if (new_refcount == 0) {
 653     gboolean do_free;
 654 
 655     if (mini_object-&gt;dispose)
 656       do_free = mini_object-&gt;dispose (mini_object);
 657     else
 658       do_free = TRUE;
 659 
 660     /* if the subclass recycled the object (and returned FALSE) we don&#39;t
 661      * want to free the instance anymore */
 662     if (G_LIKELY (do_free)) {
 663       /* there should be no outstanding locks */
 664       g_return_if_fail ((g_atomic_int_get (&amp;mini_object-&gt;lockstate) &amp; LOCK_MASK)
 665           &lt; 4);
 666 
<span class="line-modified"> 667       free_priv_data (mini_object);</span>
<span class="line-modified"> 668 </span>


 669       GST_TRACER_MINI_OBJECT_DESTROYED (mini_object);
 670       if (mini_object-&gt;free)
 671         mini_object-&gt;free (mini_object);
 672     }
 673   }
 674 }
 675 
<span class="line-added"> 676 /**</span>
<span class="line-added"> 677  * gst_clear_mini_object: (skip)</span>
<span class="line-added"> 678  * @object_ptr: a pointer to a #GstMiniObject reference</span>
<span class="line-added"> 679  *</span>
<span class="line-added"> 680  * Clears a reference to a #GstMiniObject.</span>
<span class="line-added"> 681  *</span>
<span class="line-added"> 682  * @object_ptr must not be %NULL.</span>
<span class="line-added"> 683  *</span>
<span class="line-added"> 684  * If the reference is %NULL then this function does nothing.</span>
<span class="line-added"> 685  * Otherwise, the reference count of the object is decreased using</span>
<span class="line-added"> 686  * gst_mini_object_unref() and the pointer is set to %NULL.</span>
<span class="line-added"> 687  *</span>
<span class="line-added"> 688  * A macro is also included that allows this function to be used without</span>
<span class="line-added"> 689  * pointer casts.</span>
<span class="line-added"> 690  *</span>
<span class="line-added"> 691  * Since: 1.16</span>
<span class="line-added"> 692  **/</span>
<span class="line-added"> 693 #undef gst_clear_mini_object</span>
<span class="line-added"> 694 void</span>
<span class="line-added"> 695 gst_clear_mini_object (GstMiniObject ** object_ptr)</span>
<span class="line-added"> 696 {</span>
<span class="line-added"> 697   g_clear_pointer (object_ptr, gst_mini_object_unref);</span>
<span class="line-added"> 698 }</span>
<span class="line-added"> 699 </span>
 700 /**
 701  * gst_mini_object_replace:
 702  * @olddata: (inout) (transfer full) (nullable): pointer to a pointer to a
 703  *     mini-object to be replaced
 704  * @newdata: (allow-none): pointer to new mini-object
 705  *
 706  * Atomically modifies a pointer to point to a new mini-object.
 707  * The reference count of @olddata is decreased and the reference count of
 708  * @newdata is increased.
 709  *
 710  * Either @newdata and the value pointed to by @olddata may be %NULL.
 711  *
 712  * Returns: %TRUE if @newdata was different from @olddata
 713  */
 714 gboolean
 715 gst_mini_object_replace (GstMiniObject ** olddata, GstMiniObject * newdata)
 716 {
 717   GstMiniObject *olddata_val;
 718 
 719   g_return_val_if_fail (olddata != NULL, FALSE);
</pre>
<hr />
<pre>
 882  * the old pointer set, using %NULL as pointer essentially
 883  * removes the data stored.
 884  *
 885  * @destroy may be specified which is called with @data as argument
 886  * when the @object is disposed, or the data is being overwritten by
 887  * a call to gst_mini_object_set_qdata() with the same @quark.
 888  */
 889 void
 890 gst_mini_object_set_qdata (GstMiniObject * object, GQuark quark,
 891     gpointer data, GDestroyNotify destroy)
 892 {
 893   gint i;
 894   gpointer old_data = NULL;
 895   GDestroyNotify old_notify = NULL;
 896 
 897   g_return_if_fail (object != NULL);
 898   g_return_if_fail (quark &gt; 0);
 899 
 900   G_LOCK (qdata_mutex);
 901   if ((i = find_notify (object, quark, FALSE, NULL, NULL)) != -1) {
<span class="line-added"> 902     PrivData *priv_data = object-&gt;priv_pointer;</span>
 903 
<span class="line-modified"> 904     old_data = QDATA_DATA (priv_data, i);</span>
<span class="line-modified"> 905     old_notify = QDATA_DESTROY (priv_data, i);</span>
 906 
 907     if (data == NULL)
 908       remove_notify (object, i);
 909   }
 910   if (data != NULL)
 911     set_notify (object, i, quark, NULL, data, destroy);
 912   G_UNLOCK (qdata_mutex);
 913 
 914   if (old_notify)
 915     old_notify (old_data);
 916 }
 917 
 918 /**
 919  * gst_mini_object_get_qdata:
 920  * @object: The GstMiniObject to get a stored user data pointer from
 921  * @quark: A #GQuark, naming the user data pointer
 922  *
 923  * This function gets back user data pointers stored via
 924  * gst_mini_object_set_qdata().
 925  *
 926  * Returns: (transfer none) (nullable): The user data pointer set, or
 927  * %NULL
 928  */
 929 gpointer
 930 gst_mini_object_get_qdata (GstMiniObject * object, GQuark quark)
 931 {
 932   guint i;
 933   gpointer result;
 934 
 935   g_return_val_if_fail (object != NULL, NULL);
 936   g_return_val_if_fail (quark &gt; 0, NULL);
 937 
 938   G_LOCK (qdata_mutex);
<span class="line-modified"> 939   if ((i = find_notify (object, quark, FALSE, NULL, NULL)) != -1) {</span>
<span class="line-modified"> 940     PrivData *priv_data = object-&gt;priv_pointer;</span>
<span class="line-modified"> 941     result = QDATA_DATA (priv_data, i);</span>
<span class="line-added"> 942   } else {</span>
 943     result = NULL;
<span class="line-added"> 944   }</span>
 945   G_UNLOCK (qdata_mutex);
 946 
 947   return result;
 948 }
 949 
 950 /**
 951  * gst_mini_object_steal_qdata:
 952  * @object: The GstMiniObject to get a stored user data pointer from
 953  * @quark: A #GQuark, naming the user data pointer
 954  *
 955  * This function gets back user data pointers stored via gst_mini_object_set_qdata()
 956  * and removes the data from @object without invoking its destroy() function (if
 957  * any was set).
 958  *
 959  * Returns: (transfer full) (nullable): The user data pointer set, or
 960  * %NULL
 961  */
 962 gpointer
 963 gst_mini_object_steal_qdata (GstMiniObject * object, GQuark quark)
 964 {
 965   guint i;
 966   gpointer result;
 967 
 968   g_return_val_if_fail (object != NULL, NULL);
 969   g_return_val_if_fail (quark &gt; 0, NULL);
 970 
 971   G_LOCK (qdata_mutex);
 972   if ((i = find_notify (object, quark, FALSE, NULL, NULL)) != -1) {
<span class="line-modified"> 973     PrivData *priv_data = object-&gt;priv_pointer;</span>
<span class="line-added"> 974     result = QDATA_DATA (priv_data, i);</span>
 975     remove_notify (object, i);
 976   } else {
 977     result = NULL;
 978   }
 979   G_UNLOCK (qdata_mutex);
 980 
 981   return result;
 982 }
<span class="line-added"> 983 </span>
<span class="line-added"> 984 /**</span>
<span class="line-added"> 985  * gst_mini_object_add_parent:</span>
<span class="line-added"> 986  * @object: a #GstMiniObject</span>
<span class="line-added"> 987  * @parent: a parent #GstMiniObject</span>
<span class="line-added"> 988  *</span>
<span class="line-added"> 989  * This adds @parent as a parent for @object. Having one ore more parents affects the</span>
<span class="line-added"> 990  * writability of @object: if a @parent is not writable, @object is also not</span>
<span class="line-added"> 991  * writable, regardless of its refcount. @object is only writable if all</span>
<span class="line-added"> 992  * the parents are writable and its own refcount is exactly 1.</span>
<span class="line-added"> 993  *</span>
<span class="line-added"> 994  * Note: This function does not take ownership of @parent and also does not</span>
<span class="line-added"> 995  * take an additional reference. It is the responsibility of the caller to</span>
<span class="line-added"> 996  * remove the parent again at a later time.</span>
<span class="line-added"> 997  *</span>
<span class="line-added"> 998  * Since: 1.16</span>
<span class="line-added"> 999  */</span>
<span class="line-added">1000 void</span>
<span class="line-added">1001 gst_mini_object_add_parent (GstMiniObject * object, GstMiniObject * parent)</span>
<span class="line-added">1002 {</span>
<span class="line-added">1003   gint priv_state;</span>
<span class="line-added">1004 </span>
<span class="line-added">1005   g_return_if_fail (object != NULL);</span>
<span class="line-added">1006 </span>
<span class="line-added">1007   GST_CAT_TRACE (GST_CAT_REFCOUNTING, &quot;adding parent %p to object %p&quot;, parent,</span>
<span class="line-added">1008       object);</span>
<span class="line-added">1009 </span>
<span class="line-added">1010   priv_state = lock_priv_pointer (object);</span>
<span class="line-added">1011   /* If we already had one parent, we need to allocate the full struct now */</span>
<span class="line-added">1012   if (priv_state == PRIV_DATA_STATE_ONE_PARENT) {</span>
<span class="line-added">1013     /* Unlock again */</span>
<span class="line-added">1014     g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint, priv_state);</span>
<span class="line-added">1015 </span>
<span class="line-added">1016     ensure_priv_data (object);</span>
<span class="line-added">1017     priv_state = PRIV_DATA_STATE_PARENTS_OR_QDATA;</span>
<span class="line-added">1018   }</span>
<span class="line-added">1019 </span>
<span class="line-added">1020   /* Now we either have to add the new parent to the full struct, or add</span>
<span class="line-added">1021    * our one and only parent to the pointer field */</span>
<span class="line-added">1022   if (priv_state == PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added">1023     PrivData *priv_data = object-&gt;priv_pointer;</span>
<span class="line-added">1024 </span>
<span class="line-added">1025     /* Lock parents */</span>
<span class="line-added">1026     while (!g_atomic_int_compare_and_exchange (&amp;priv_data-&gt;parent_lock, 0, 1));</span>
<span class="line-added">1027 </span>
<span class="line-added">1028     if (priv_data-&gt;n_parents &gt;= priv_data-&gt;n_parents_len) {</span>
<span class="line-added">1029       priv_data-&gt;n_parents_len *= 2;</span>
<span class="line-added">1030       if (priv_data-&gt;n_parents_len == 0)</span>
<span class="line-added">1031         priv_data-&gt;n_parents_len = 16;</span>
<span class="line-added">1032 </span>
<span class="line-added">1033       priv_data-&gt;parents =</span>
<span class="line-added">1034           g_realloc (priv_data-&gt;parents,</span>
<span class="line-added">1035           priv_data-&gt;n_parents_len * sizeof (GstMiniObject *));</span>
<span class="line-added">1036     }</span>
<span class="line-added">1037     priv_data-&gt;parents[priv_data-&gt;n_parents] = parent;</span>
<span class="line-added">1038     priv_data-&gt;n_parents++;</span>
<span class="line-added">1039 </span>
<span class="line-added">1040     /* Unlock again */</span>
<span class="line-added">1041     g_atomic_int_set (&amp;priv_data-&gt;parent_lock, 0);</span>
<span class="line-added">1042   } else if (priv_state == PRIV_DATA_STATE_NO_PARENT) {</span>
<span class="line-added">1043     object-&gt;priv_pointer = parent;</span>
<span class="line-added">1044 </span>
<span class="line-added">1045     /* Unlock again */</span>
<span class="line-added">1046     g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint, PRIV_DATA_STATE_ONE_PARENT);</span>
<span class="line-added">1047   } else {</span>
<span class="line-added">1048     g_assert_not_reached ();</span>
<span class="line-added">1049   }</span>
<span class="line-added">1050 }</span>
<span class="line-added">1051 </span>
<span class="line-added">1052 /**</span>
<span class="line-added">1053  * gst_mini_object_remove_parent:</span>
<span class="line-added">1054  * @object: a #GstMiniObject</span>
<span class="line-added">1055  * @parent: a parent #GstMiniObject</span>
<span class="line-added">1056  *</span>
<span class="line-added">1057  * This removes @parent as a parent for @object. See</span>
<span class="line-added">1058  * gst_mini_object_add_parent().</span>
<span class="line-added">1059  *</span>
<span class="line-added">1060  * Since: 1.16</span>
<span class="line-added">1061  */</span>
<span class="line-added">1062 void</span>
<span class="line-added">1063 gst_mini_object_remove_parent (GstMiniObject * object, GstMiniObject * parent)</span>
<span class="line-added">1064 {</span>
<span class="line-added">1065   gint priv_state;</span>
<span class="line-added">1066 </span>
<span class="line-added">1067   g_return_if_fail (object != NULL);</span>
<span class="line-added">1068 </span>
<span class="line-added">1069   GST_CAT_TRACE (GST_CAT_REFCOUNTING, &quot;removing parent %p from object %p&quot;,</span>
<span class="line-added">1070       parent, object);</span>
<span class="line-added">1071 </span>
<span class="line-added">1072   priv_state = lock_priv_pointer (object);</span>
<span class="line-added">1073 </span>
<span class="line-added">1074   /* Now we either have to add the new parent to the full struct, or add</span>
<span class="line-added">1075    * our one and only parent to the pointer field */</span>
<span class="line-added">1076   if (priv_state == PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added">1077     PrivData *priv_data = object-&gt;priv_pointer;</span>
<span class="line-added">1078     guint i;</span>
<span class="line-added">1079 </span>
<span class="line-added">1080     /* Lock parents */</span>
<span class="line-added">1081     while (!g_atomic_int_compare_and_exchange (&amp;priv_data-&gt;parent_lock, 0, 1));</span>
<span class="line-added">1082 </span>
<span class="line-added">1083     for (i = 0; i &lt; priv_data-&gt;n_parents; i++)</span>
<span class="line-added">1084       if (parent == priv_data-&gt;parents[i])</span>
<span class="line-added">1085         break;</span>
<span class="line-added">1086 </span>
<span class="line-added">1087     if (i != priv_data-&gt;n_parents) {</span>
<span class="line-added">1088       priv_data-&gt;n_parents--;</span>
<span class="line-added">1089       if (priv_data-&gt;n_parents != i)</span>
<span class="line-added">1090         priv_data-&gt;parents[i] = priv_data-&gt;parents[priv_data-&gt;n_parents];</span>
<span class="line-added">1091     } else {</span>
<span class="line-added">1092       g_warning (&quot;%s: couldn&#39;t find parent %p (object:%p)&quot;, G_STRFUNC,</span>
<span class="line-added">1093           object, parent);</span>
<span class="line-added">1094     }</span>
<span class="line-added">1095 </span>
<span class="line-added">1096     /* Unlock again */</span>
<span class="line-added">1097     g_atomic_int_set (&amp;priv_data-&gt;parent_lock, 0);</span>
<span class="line-added">1098   } else if (priv_state == PRIV_DATA_STATE_ONE_PARENT) {</span>
<span class="line-added">1099     if (object-&gt;priv_pointer != parent) {</span>
<span class="line-added">1100       g_warning (&quot;%s: couldn&#39;t find parent %p (object:%p)&quot;, G_STRFUNC,</span>
<span class="line-added">1101           object, parent);</span>
<span class="line-added">1102       /* Unlock again */</span>
<span class="line-added">1103       g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint, priv_state);</span>
<span class="line-added">1104     } else {</span>
<span class="line-added">1105       object-&gt;priv_pointer = NULL;</span>
<span class="line-added">1106       /* Unlock again */</span>
<span class="line-added">1107       g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint,</span>
<span class="line-added">1108           PRIV_DATA_STATE_NO_PARENT);</span>
<span class="line-added">1109     }</span>
<span class="line-added">1110   } else {</span>
<span class="line-added">1111     /* Unlock again */</span>
<span class="line-added">1112     g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint, PRIV_DATA_STATE_NO_PARENT);</span>
<span class="line-added">1113   }</span>
<span class="line-added">1114 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="gstmeta.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstminiobject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>