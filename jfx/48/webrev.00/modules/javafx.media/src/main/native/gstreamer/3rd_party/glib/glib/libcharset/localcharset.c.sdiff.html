<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/libcharset/localcharset.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="libcharset.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../win_iconv.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/libcharset/localcharset.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
101    read, else NULL.  Its format is:
102    ALIAS_1 &#39;\0&#39; CANONICAL_1 &#39;\0&#39; ... ALIAS_n &#39;\0&#39; CANONICAL_n &#39;\0&#39; &#39;\0&#39;  */
103 static const char * volatile charset_aliases;
104 
105 /* Return a pointer to the contents of the charset.alias file.  */
106 const char *
107 _g_locale_get_charset_aliases (void)
108 {
109   const char *cp;
110 
111   cp = charset_aliases;
112   if (cp == NULL)
113     {
114 #if !(defined VMS || defined WIN32_NATIVE || defined __CYGWIN__)
115       FILE *fp;
116       const char *dir;
117       const char *base = &quot;charset.alias&quot;;
118       char *file_name;
119 
120       /* Make it possible to override the charset.alias location.  This is
<span class="line-modified">121      necessary for running the testsuite before &quot;make install&quot;.  */</span>
122       dir = getenv (&quot;CHARSETALIASDIR&quot;);
123       if (dir == NULL || dir[0] == &#39;\0&#39;)
<span class="line-modified">124     dir = relocate (GLIB_CHARSETALIAS_DIR);</span>
125 
126       /* Concatenate dir and base into freshly allocated file_name.  */
127       {
<span class="line-modified">128     size_t dir_len = strlen (dir);</span>
<span class="line-modified">129     size_t base_len = strlen (base);</span>
<span class="line-modified">130     int add_slash = (dir_len &gt; 0 &amp;&amp; !ISSLASH (dir[dir_len - 1]));</span>
<span class="line-modified">131     file_name = (char *) malloc (dir_len + add_slash + base_len + 1);</span>
<span class="line-modified">132     if (file_name != NULL)</span>
<span class="line-modified">133       {</span>
<span class="line-modified">134         memcpy (file_name, dir, dir_len);</span>
<span class="line-modified">135         if (add_slash)</span>
<span class="line-modified">136           file_name[dir_len] = DIRECTORY_SEPARATOR;</span>
<span class="line-modified">137         memcpy (file_name + dir_len + add_slash, base, base_len + 1);</span>
<span class="line-modified">138       }</span>
139       }
140 
141       if (file_name == NULL || (fp = fopen (file_name, &quot;r&quot;)) == NULL)
<span class="line-modified">142     /* Out of memory or file not found, treat it as empty.  */</span>
<span class="line-modified">143     cp = &quot;&quot;;</span>
144       else



















145     {
<span class="line-modified">146       /* Parse the file&#39;s contents.  */</span>
<span class="line-modified">147       char *res_ptr = NULL;</span>
<span class="line-modified">148       size_t res_size = 0;</span>
<span class="line-modified">149 </span>
<span class="line-modified">150       for (;;)</span>
<span class="line-removed">151         {</span>
<span class="line-removed">152           int c;</span>
<span class="line-removed">153           char buf1[50+1];</span>
<span class="line-removed">154           char buf2[50+1];</span>
<span class="line-removed">155           size_t l1, l2;</span>
<span class="line-removed">156           char *old_res_ptr;</span>
<span class="line-removed">157 </span>
<span class="line-removed">158           c = getc (fp);</span>
<span class="line-removed">159           if (c == EOF)</span>
<span class="line-removed">160         break;</span>
<span class="line-removed">161           if (c == &#39;\n&#39; || c == &#39; &#39; || c == &#39;\t&#39;)</span>
<span class="line-removed">162         continue;</span>
<span class="line-removed">163           if (c == &#39;#&#39;)</span>
<span class="line-removed">164         {</span>
<span class="line-removed">165           /* Skip comment, to end of line.  */</span>
<span class="line-removed">166           do</span>
<span class="line-removed">167             c = getc (fp);</span>
<span class="line-removed">168           while (!(c == EOF || c == &#39;\n&#39;));</span>
<span class="line-removed">169           if (c == EOF)</span>
<span class="line-removed">170             break;</span>
<span class="line-removed">171           continue;</span>
<span class="line-removed">172         }</span>
<span class="line-removed">173           ungetc (c, fp);</span>
<span class="line-removed">174           if (fscanf (fp, &quot;%50s %50s&quot;, buf1, buf2) &lt; 2)</span>
175         break;
<span class="line-modified">176           l1 = strlen (buf1);</span>
<span class="line-removed">177           l2 = strlen (buf2);</span>
<span class="line-removed">178           old_res_ptr = res_ptr;</span>
<span class="line-removed">179           if (res_size == 0)</span>
<span class="line-removed">180         {</span>
<span class="line-removed">181           res_size = l1 + 1 + l2 + 1;</span>
<span class="line-removed">182           res_ptr = (char *) malloc (res_size + 1);</span>
<span class="line-removed">183         }</span>
<span class="line-removed">184           else</span>
<span class="line-removed">185         {</span>
<span class="line-removed">186           res_size += l1 + 1 + l2 + 1;</span>
<span class="line-removed">187           res_ptr = (char *) realloc (res_ptr, res_size + 1);</span>
<span class="line-removed">188         }</span>
<span class="line-removed">189           if (res_ptr == NULL)</span>
<span class="line-removed">190         {</span>
<span class="line-removed">191           /* Out of memory. */</span>
<span class="line-removed">192           res_size = 0;</span>
<span class="line-removed">193           if (old_res_ptr != NULL)</span>
<span class="line-removed">194             free (old_res_ptr);</span>
<span class="line-removed">195           break;</span>
<span class="line-removed">196         }</span>
<span class="line-removed">197           strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);</span>
<span class="line-removed">198           strcpy (res_ptr + res_size - (l2 + 1), buf2);</span>
<span class="line-removed">199         }</span>
<span class="line-removed">200       fclose (fp);</span>
<span class="line-removed">201       if (res_size == 0)</span>
<span class="line-removed">202         cp = &quot;&quot;;</span>
<span class="line-removed">203       else</span>
<span class="line-removed">204         {</span>
<span class="line-removed">205           *(res_ptr + res_size) = &#39;\0&#39;;</span>
<span class="line-removed">206           cp = res_ptr;</span>
<span class="line-removed">207         }</span>
208     }




































209 
210       if (file_name != NULL)
<span class="line-modified">211     free (file_name);</span>
212 
213 #else
214 
215 # if defined VMS
216       /* To avoid the troubles of an extra file charset.alias_vms in the
<span class="line-modified">217      sources of many GNU packages, simply inline the aliases here.  */</span>
218       /* The list of encodings is taken from the OpenVMS 7.3-1 documentation
<span class="line-modified">219      &quot;Compaq C Run-Time Library Reference Manual for OpenVMS systems&quot;</span>
<span class="line-modified">220      section 10.7 &quot;Handling Different Character Sets&quot;.  */</span>
221       cp = &quot;ISO8859-1&quot; &quot;\0&quot; &quot;ISO-8859-1&quot; &quot;\0&quot;
<span class="line-modified">222        &quot;ISO8859-2&quot; &quot;\0&quot; &quot;ISO-8859-2&quot; &quot;\0&quot;</span>
<span class="line-modified">223        &quot;ISO8859-5&quot; &quot;\0&quot; &quot;ISO-8859-5&quot; &quot;\0&quot;</span>
<span class="line-modified">224        &quot;ISO8859-7&quot; &quot;\0&quot; &quot;ISO-8859-7&quot; &quot;\0&quot;</span>
<span class="line-modified">225        &quot;ISO8859-8&quot; &quot;\0&quot; &quot;ISO-8859-8&quot; &quot;\0&quot;</span>
<span class="line-modified">226        &quot;ISO8859-9&quot; &quot;\0&quot; &quot;ISO-8859-9&quot; &quot;\0&quot;</span>
<span class="line-modified">227        /* Japanese */</span>
<span class="line-modified">228        &quot;eucJP&quot; &quot;\0&quot; &quot;EUC-JP&quot; &quot;\0&quot;</span>
<span class="line-modified">229        &quot;SJIS&quot; &quot;\0&quot; &quot;SHIFT_JIS&quot; &quot;\0&quot;</span>
<span class="line-modified">230        &quot;DECKANJI&quot; &quot;\0&quot; &quot;DEC-KANJI&quot; &quot;\0&quot;</span>
<span class="line-modified">231        &quot;SDECKANJI&quot; &quot;\0&quot; &quot;EUC-JP&quot; &quot;\0&quot;</span>
<span class="line-modified">232        /* Chinese */</span>
<span class="line-modified">233        &quot;eucTW&quot; &quot;\0&quot; &quot;EUC-TW&quot; &quot;\0&quot;</span>
<span class="line-modified">234        &quot;DECHANYU&quot; &quot;\0&quot; &quot;DEC-HANYU&quot; &quot;\0&quot;</span>
<span class="line-modified">235        &quot;DECHANZI&quot; &quot;\0&quot; &quot;GB2312&quot; &quot;\0&quot;</span>
<span class="line-modified">236        /* Korean */</span>
<span class="line-modified">237        &quot;DECKOREAN&quot; &quot;\0&quot; &quot;EUC-KR&quot; &quot;\0&quot;;</span>
238 # endif
239 
240 # if defined WIN32_NATIVE || defined __CYGWIN__
241       /* To avoid the troubles of installing a separate file in the same
<span class="line-modified">242      directory as the DLL and of retrieving the DLL&#39;s directory at</span>
<span class="line-modified">243      runtime, simply inline the aliases here.  */</span>
244 
245       cp = &quot;CP936&quot; &quot;\0&quot; &quot;GBK&quot; &quot;\0&quot;
<span class="line-modified">246        &quot;CP1361&quot; &quot;\0&quot; &quot;JOHAB&quot; &quot;\0&quot;</span>
<span class="line-modified">247        &quot;CP20127&quot; &quot;\0&quot; &quot;ASCII&quot; &quot;\0&quot;</span>
<span class="line-modified">248        &quot;CP20866&quot; &quot;\0&quot; &quot;KOI8-R&quot; &quot;\0&quot;</span>
<span class="line-modified">249        &quot;CP20936&quot; &quot;\0&quot; &quot;GB2312&quot; &quot;\0&quot;</span>
<span class="line-modified">250        &quot;CP21866&quot; &quot;\0&quot; &quot;KOI8-RU&quot; &quot;\0&quot;</span>
<span class="line-modified">251        &quot;CP28591&quot; &quot;\0&quot; &quot;ISO-8859-1&quot; &quot;\0&quot;</span>
<span class="line-modified">252        &quot;CP28592&quot; &quot;\0&quot; &quot;ISO-8859-2&quot; &quot;\0&quot;</span>
<span class="line-modified">253        &quot;CP28593&quot; &quot;\0&quot; &quot;ISO-8859-3&quot; &quot;\0&quot;</span>
<span class="line-modified">254        &quot;CP28594&quot; &quot;\0&quot; &quot;ISO-8859-4&quot; &quot;\0&quot;</span>
<span class="line-modified">255        &quot;CP28595&quot; &quot;\0&quot; &quot;ISO-8859-5&quot; &quot;\0&quot;</span>
<span class="line-modified">256        &quot;CP28596&quot; &quot;\0&quot; &quot;ISO-8859-6&quot; &quot;\0&quot;</span>
<span class="line-modified">257        &quot;CP28597&quot; &quot;\0&quot; &quot;ISO-8859-7&quot; &quot;\0&quot;</span>
<span class="line-modified">258        &quot;CP28598&quot; &quot;\0&quot; &quot;ISO-8859-8&quot; &quot;\0&quot;</span>
<span class="line-modified">259        &quot;CP28599&quot; &quot;\0&quot; &quot;ISO-8859-9&quot; &quot;\0&quot;</span>
<span class="line-modified">260        &quot;CP28605&quot; &quot;\0&quot; &quot;ISO-8859-15&quot; &quot;\0&quot;</span>
<span class="line-modified">261        &quot;CP38598&quot; &quot;\0&quot; &quot;ISO-8859-8&quot; &quot;\0&quot;</span>
<span class="line-modified">262        &quot;CP51932&quot; &quot;\0&quot; &quot;EUC-JP&quot; &quot;\0&quot;</span>
<span class="line-modified">263        &quot;CP51936&quot; &quot;\0&quot; &quot;GB2312&quot; &quot;\0&quot;</span>
<span class="line-modified">264        &quot;CP51949&quot; &quot;\0&quot; &quot;EUC-KR&quot; &quot;\0&quot;</span>
<span class="line-modified">265        &quot;CP51950&quot; &quot;\0&quot; &quot;EUC-TW&quot; &quot;\0&quot;</span>
<span class="line-modified">266        &quot;CP54936&quot; &quot;\0&quot; &quot;GB18030&quot; &quot;\0&quot;</span>
<span class="line-modified">267        &quot;CP65001&quot; &quot;\0&quot; &quot;UTF-8&quot; &quot;\0&quot;;</span>
268 # endif
269 #endif
270 
271       charset_aliases = cp;
272     }
273 
274   return cp;
275 }
276 
277 /* Determine the current locale&#39;s character encoding, and canonicalize it
278    into one of the canonical names listed in config.charset.
279    The result must not be freed; it is statically allocated.
280    If the canonical name cannot be determined, the result is a non-canonical
281    name.  */
282 
283 const char *
284 _g_locale_charset_raw (void)
285 {
286   const char *codeset;
287 
288 #if !(defined WIN32_NATIVE || defined OS2)
289 
290 # if HAVE_LANGINFO_CODESET
291 
292   /* Most systems support nl_langinfo (CODESET) nowadays.  */
293   codeset = nl_langinfo (CODESET);
294 
295 #  ifdef __CYGWIN__
296   /* Cygwin 2006 does not have locales.  nl_langinfo (CODESET) always
297      returns &quot;US-ASCII&quot;.  As long as this is not fixed, return the suffix
298      of the locale name from the environment variables (if present) or
299      the codepage as a number.  */
300   if (codeset != NULL &amp;&amp; strcmp (codeset, &quot;US-ASCII&quot;) == 0)
301     {
302       const char *locale;
303       static char buf[2 + 10 + 1];
304 
305       locale = getenv (&quot;LC_ALL&quot;);
306       if (locale == NULL || locale[0] == &#39;\0&#39;)
<span class="line-modified">307     {</span>
<span class="line-modified">308       locale = getenv (&quot;LC_CTYPE&quot;);</span>
<span class="line-modified">309       if (locale == NULL || locale[0] == &#39;\0&#39;)</span>
<span class="line-modified">310         locale = getenv (&quot;LANG&quot;);</span>
<span class="line-modified">311     }</span>
312       if (locale != NULL &amp;&amp; locale[0] != &#39;\0&#39;)
<span class="line-modified">313     {</span>
<span class="line-modified">314       /* If the locale name contains an encoding after the dot, return</span>
<span class="line-modified">315          it.  */</span>
<span class="line-modified">316       const char *dot = strchr (locale, &#39;.&#39;);</span>
317 
<span class="line-modified">318       if (dot != NULL)</span>
<span class="line-modified">319         {</span>
<span class="line-modified">320           const char *modifier;</span>
<span class="line-modified">321 </span>
<span class="line-modified">322           dot++;</span>
<span class="line-modified">323           /* Look for the possible @... trailer and remove it, if any.  */</span>
<span class="line-modified">324           modifier = strchr (dot, &#39;@&#39;);</span>
<span class="line-modified">325           if (modifier == NULL)</span>
<span class="line-modified">326         return dot;</span>
<span class="line-modified">327           if (modifier - dot &lt; sizeof (buf))</span>
<span class="line-modified">328         {</span>
<span class="line-modified">329           memcpy (buf, dot, modifier - dot);</span>
<span class="line-modified">330           buf [modifier - dot] = &#39;\0&#39;;</span>
<span class="line-modified">331           return buf;</span>
<span class="line-removed">332         }</span>
<span class="line-removed">333         }</span>
334     }


335 
336       /* Woe32 has a function returning the locale&#39;s codepage as a number.  */
337       sprintf (buf, &quot;CP%u&quot;, GetACP ());
338       codeset = buf;
339     }
340 #  endif
341 
342 # else
343 
344   /* On old systems which lack it, use setlocale or getenv.  */
345   const char *locale = NULL;
346 
347   /* But most old systems don&#39;t have a complete set of locales.  Some
348      (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don&#39;t
349      use setlocale here; it would return &quot;C&quot; when it doesn&#39;t support the
350      locale name the user has set.  */
351 #  if 0
352   locale = setlocale (LC_CTYPE, NULL);
353 #  endif
354   if (locale == NULL || locale[0] == &#39;\0&#39;)
355     {
356       locale = getenv (&quot;LC_ALL&quot;);
357       if (locale == NULL || locale[0] == &#39;\0&#39;)
<span class="line-modified">358     {</span>
<span class="line-modified">359       locale = getenv (&quot;LC_CTYPE&quot;);</span>
<span class="line-modified">360       if (locale == NULL || locale[0] == &#39;\0&#39;)</span>
<span class="line-modified">361         locale = getenv (&quot;LANG&quot;);</span>
<span class="line-modified">362     }</span>
363     }
364 
365   /* On some old systems, one used to set locale = &quot;iso8859_1&quot;. On others,
366      you set it to &quot;language_COUNTRY.charset&quot;. In any case, we resolve it
367      through the charset.alias file.  */
368   codeset = locale;
369 
370 # endif
371 
372 #elif defined WIN32_NATIVE
373 
374   static char buf[2 + 10 + 1];
375 
376   /* Woe32 has a function returning the locale&#39;s codepage as a number.  */
377   sprintf (buf, &quot;CP%u&quot;, GetACP ());
378   codeset = buf;
379 
380 #elif defined OS2
381 
382   const char *locale;
383   static char buf[2 + 10 + 1];
384   ULONG cp[3];
385   ULONG cplen;
386 
387   /* Allow user to override the codeset, as set in the operating system,
388      with standard language environment variables.  */
389   locale = getenv (&quot;LC_ALL&quot;);
390   if (locale == NULL || locale[0] == &#39;\0&#39;)
391     {
392       locale = getenv (&quot;LC_CTYPE&quot;);
393       if (locale == NULL || locale[0] == &#39;\0&#39;)
<span class="line-modified">394     locale = getenv (&quot;LANG&quot;);</span>
395     }
396   if (locale != NULL &amp;&amp; locale[0] != &#39;\0&#39;)
397     {
398       /* If the locale name contains an encoding after the dot, return it.  */
399       const char *dot = strchr (locale, &#39;.&#39;);
400 
401       if (dot != NULL)
<span class="line-modified">402     {</span>
<span class="line-modified">403       const char *modifier;</span>
<span class="line-modified">404 </span>
<span class="line-modified">405       dot++;</span>
<span class="line-modified">406       /* Look for the possible @... trailer and remove it, if any.  */</span>
<span class="line-modified">407       modifier = strchr (dot, &#39;@&#39;);</span>
<span class="line-modified">408       if (modifier == NULL)</span>
<span class="line-modified">409         return dot;</span>
<span class="line-modified">410       if (modifier - dot &lt; sizeof (buf))</span>
<span class="line-modified">411         {</span>
<span class="line-modified">412           memcpy (buf, dot, modifier - dot);</span>
<span class="line-modified">413           buf [modifier - dot] = &#39;\0&#39;;</span>
<span class="line-modified">414           return buf;</span>
<span class="line-modified">415         }</span>
<span class="line-modified">416     }</span>
417 
418       /* Resolve through the charset.alias file.  */
419       codeset = locale;
420     }
421   else
422     {
423       /* OS/2 has a function returning the locale&#39;s codepage as a number.  */
424       if (DosQueryCp (sizeof (cp), cp, &amp;cplen))
<span class="line-modified">425     codeset = &quot;&quot;;</span>
426       else
<span class="line-modified">427     {</span>
<span class="line-modified">428       sprintf (buf, &quot;CP%u&quot;, cp[0]);</span>
<span class="line-modified">429       codeset = buf;</span>
<span class="line-modified">430     }</span>
431     }
432 
433 #endif
434 
435   return codeset;
436 }
437 
438 const char *
439 _g_locale_charset_unalias (const char *codeset)
440 {
441   const char *aliases;
442 
443   if (codeset == NULL)
444     /* The canonical name cannot be determined.  */
445     codeset = &quot;&quot;;
446 
447   /* Resolve alias. */
448   for (aliases = _g_locale_get_charset_aliases ();
449        *aliases != &#39;\0&#39;;
450        aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)
451     if (strcmp (codeset, aliases) == 0
<span class="line-modified">452     || (aliases[0] == &#39;*&#39; &amp;&amp; aliases[1] == &#39;\0&#39;))</span>
453       {
<span class="line-modified">454     codeset = aliases + strlen (aliases) + 1;</span>
<span class="line-modified">455     break;</span>
456       }
457 
458   /* Don&#39;t return an empty string.  GNU libc and GNU libiconv interpret
459      the empty string as denoting &quot;the locale&#39;s character encoding&quot;,
460      thus GNU libiconv would call this function a second time.  */
461   if (codeset[0] == &#39;\0&#39;)
462     codeset = &quot;ASCII&quot;;
463 
464   return codeset;
465 }
</pre>
</td>
<td>
<hr />
<pre>
101    read, else NULL.  Its format is:
102    ALIAS_1 &#39;\0&#39; CANONICAL_1 &#39;\0&#39; ... ALIAS_n &#39;\0&#39; CANONICAL_n &#39;\0&#39; &#39;\0&#39;  */
103 static const char * volatile charset_aliases;
104 
105 /* Return a pointer to the contents of the charset.alias file.  */
106 const char *
107 _g_locale_get_charset_aliases (void)
108 {
109   const char *cp;
110 
111   cp = charset_aliases;
112   if (cp == NULL)
113     {
114 #if !(defined VMS || defined WIN32_NATIVE || defined __CYGWIN__)
115       FILE *fp;
116       const char *dir;
117       const char *base = &quot;charset.alias&quot;;
118       char *file_name;
119 
120       /* Make it possible to override the charset.alias location.  This is
<span class="line-modified">121    necessary for running the testsuite before &quot;make install&quot;.  */</span>
122       dir = getenv (&quot;CHARSETALIASDIR&quot;);
123       if (dir == NULL || dir[0] == &#39;\0&#39;)
<span class="line-modified">124   dir = relocate (GLIB_CHARSETALIAS_DIR);</span>
125 
126       /* Concatenate dir and base into freshly allocated file_name.  */
127       {
<span class="line-modified">128   size_t dir_len = strlen (dir);</span>
<span class="line-modified">129   size_t base_len = strlen (base);</span>
<span class="line-modified">130   int add_slash = (dir_len &gt; 0 &amp;&amp; !ISSLASH (dir[dir_len - 1]));</span>
<span class="line-modified">131   file_name = (char *) malloc (dir_len + add_slash + base_len + 1);</span>
<span class="line-modified">132   if (file_name != NULL)</span>
<span class="line-modified">133     {</span>
<span class="line-modified">134       memcpy (file_name, dir, dir_len);</span>
<span class="line-modified">135       if (add_slash)</span>
<span class="line-modified">136         file_name[dir_len] = DIRECTORY_SEPARATOR;</span>
<span class="line-modified">137       memcpy (file_name + dir_len + add_slash, base, base_len + 1);</span>
<span class="line-modified">138     }</span>
139       }
140 
141       if (file_name == NULL || (fp = fopen (file_name, &quot;r&quot;)) == NULL)
<span class="line-modified">142   /* Out of memory or file not found, treat it as empty.  */</span>
<span class="line-modified">143   cp = &quot;&quot;;</span>
144       else
<span class="line-added">145   {</span>
<span class="line-added">146     /* Parse the file&#39;s contents.  */</span>
<span class="line-added">147     char *res_ptr = NULL;</span>
<span class="line-added">148     size_t res_size = 0;</span>
<span class="line-added">149 </span>
<span class="line-added">150     for (;;)</span>
<span class="line-added">151       {</span>
<span class="line-added">152         int c;</span>
<span class="line-added">153         char buf1[50+1];</span>
<span class="line-added">154         char buf2[50+1];</span>
<span class="line-added">155         size_t l1, l2;</span>
<span class="line-added">156         char *old_res_ptr;</span>
<span class="line-added">157 </span>
<span class="line-added">158         c = getc (fp);</span>
<span class="line-added">159         if (c == EOF)</span>
<span class="line-added">160     break;</span>
<span class="line-added">161         if (c == &#39;\n&#39; || c == &#39; &#39; || c == &#39;\t&#39;)</span>
<span class="line-added">162     continue;</span>
<span class="line-added">163         if (c == &#39;#&#39;)</span>
164     {
<span class="line-modified">165       /* Skip comment, to end of line.  */</span>
<span class="line-modified">166       do</span>
<span class="line-modified">167         c = getc (fp);</span>
<span class="line-modified">168       while (!(c == EOF || c == &#39;\n&#39;));</span>
<span class="line-modified">169       if (c == EOF)</span>
























170         break;
<span class="line-modified">171       continue;</span>































172     }
<span class="line-added">173         ungetc (c, fp);</span>
<span class="line-added">174         if (fscanf (fp, &quot;%50s %50s&quot;, buf1, buf2) &lt; 2)</span>
<span class="line-added">175     break;</span>
<span class="line-added">176         l1 = strlen (buf1);</span>
<span class="line-added">177         l2 = strlen (buf2);</span>
<span class="line-added">178         old_res_ptr = res_ptr;</span>
<span class="line-added">179         if (res_size == 0)</span>
<span class="line-added">180     {</span>
<span class="line-added">181       res_size = l1 + 1 + l2 + 1;</span>
<span class="line-added">182       res_ptr = (char *) malloc (res_size + 1);</span>
<span class="line-added">183     }</span>
<span class="line-added">184         else</span>
<span class="line-added">185     {</span>
<span class="line-added">186       res_size += l1 + 1 + l2 + 1;</span>
<span class="line-added">187       res_ptr = (char *) realloc (res_ptr, res_size + 1);</span>
<span class="line-added">188     }</span>
<span class="line-added">189         if (res_ptr == NULL)</span>
<span class="line-added">190     {</span>
<span class="line-added">191       /* Out of memory. */</span>
<span class="line-added">192       res_size = 0;</span>
<span class="line-added">193       if (old_res_ptr != NULL)</span>
<span class="line-added">194         free (old_res_ptr);</span>
<span class="line-added">195       break;</span>
<span class="line-added">196     }</span>
<span class="line-added">197         strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);</span>
<span class="line-added">198         strcpy (res_ptr + res_size - (l2 + 1), buf2);</span>
<span class="line-added">199       }</span>
<span class="line-added">200     fclose (fp);</span>
<span class="line-added">201     if (res_size == 0)</span>
<span class="line-added">202       cp = &quot;&quot;;</span>
<span class="line-added">203     else</span>
<span class="line-added">204       {</span>
<span class="line-added">205         *(res_ptr + res_size) = &#39;\0&#39;;</span>
<span class="line-added">206         cp = res_ptr;</span>
<span class="line-added">207       }</span>
<span class="line-added">208   }</span>
209 
210       if (file_name != NULL)
<span class="line-modified">211   free (file_name);</span>
212 
213 #else
214 
215 # if defined VMS
216       /* To avoid the troubles of an extra file charset.alias_vms in the
<span class="line-modified">217    sources of many GNU packages, simply inline the aliases here.  */</span>
218       /* The list of encodings is taken from the OpenVMS 7.3-1 documentation
<span class="line-modified">219    &quot;Compaq C Run-Time Library Reference Manual for OpenVMS systems&quot;</span>
<span class="line-modified">220    section 10.7 &quot;Handling Different Character Sets&quot;.  */</span>
221       cp = &quot;ISO8859-1&quot; &quot;\0&quot; &quot;ISO-8859-1&quot; &quot;\0&quot;
<span class="line-modified">222      &quot;ISO8859-2&quot; &quot;\0&quot; &quot;ISO-8859-2&quot; &quot;\0&quot;</span>
<span class="line-modified">223      &quot;ISO8859-5&quot; &quot;\0&quot; &quot;ISO-8859-5&quot; &quot;\0&quot;</span>
<span class="line-modified">224      &quot;ISO8859-7&quot; &quot;\0&quot; &quot;ISO-8859-7&quot; &quot;\0&quot;</span>
<span class="line-modified">225      &quot;ISO8859-8&quot; &quot;\0&quot; &quot;ISO-8859-8&quot; &quot;\0&quot;</span>
<span class="line-modified">226      &quot;ISO8859-9&quot; &quot;\0&quot; &quot;ISO-8859-9&quot; &quot;\0&quot;</span>
<span class="line-modified">227      /* Japanese */</span>
<span class="line-modified">228      &quot;eucJP&quot; &quot;\0&quot; &quot;EUC-JP&quot; &quot;\0&quot;</span>
<span class="line-modified">229      &quot;SJIS&quot; &quot;\0&quot; &quot;SHIFT_JIS&quot; &quot;\0&quot;</span>
<span class="line-modified">230      &quot;DECKANJI&quot; &quot;\0&quot; &quot;DEC-KANJI&quot; &quot;\0&quot;</span>
<span class="line-modified">231      &quot;SDECKANJI&quot; &quot;\0&quot; &quot;EUC-JP&quot; &quot;\0&quot;</span>
<span class="line-modified">232      /* Chinese */</span>
<span class="line-modified">233      &quot;eucTW&quot; &quot;\0&quot; &quot;EUC-TW&quot; &quot;\0&quot;</span>
<span class="line-modified">234      &quot;DECHANYU&quot; &quot;\0&quot; &quot;DEC-HANYU&quot; &quot;\0&quot;</span>
<span class="line-modified">235      &quot;DECHANZI&quot; &quot;\0&quot; &quot;GB2312&quot; &quot;\0&quot;</span>
<span class="line-modified">236      /* Korean */</span>
<span class="line-modified">237      &quot;DECKOREAN&quot; &quot;\0&quot; &quot;EUC-KR&quot; &quot;\0&quot;;</span>
238 # endif
239 
240 # if defined WIN32_NATIVE || defined __CYGWIN__
241       /* To avoid the troubles of installing a separate file in the same
<span class="line-modified">242    directory as the DLL and of retrieving the DLL&#39;s directory at</span>
<span class="line-modified">243    runtime, simply inline the aliases here.  */</span>
244 
245       cp = &quot;CP936&quot; &quot;\0&quot; &quot;GBK&quot; &quot;\0&quot;
<span class="line-modified">246      &quot;CP1361&quot; &quot;\0&quot; &quot;JOHAB&quot; &quot;\0&quot;</span>
<span class="line-modified">247      &quot;CP20127&quot; &quot;\0&quot; &quot;ASCII&quot; &quot;\0&quot;</span>
<span class="line-modified">248      &quot;CP20866&quot; &quot;\0&quot; &quot;KOI8-R&quot; &quot;\0&quot;</span>
<span class="line-modified">249      &quot;CP20936&quot; &quot;\0&quot; &quot;GB2312&quot; &quot;\0&quot;</span>
<span class="line-modified">250      &quot;CP21866&quot; &quot;\0&quot; &quot;KOI8-RU&quot; &quot;\0&quot;</span>
<span class="line-modified">251      &quot;CP28591&quot; &quot;\0&quot; &quot;ISO-8859-1&quot; &quot;\0&quot;</span>
<span class="line-modified">252      &quot;CP28592&quot; &quot;\0&quot; &quot;ISO-8859-2&quot; &quot;\0&quot;</span>
<span class="line-modified">253      &quot;CP28593&quot; &quot;\0&quot; &quot;ISO-8859-3&quot; &quot;\0&quot;</span>
<span class="line-modified">254      &quot;CP28594&quot; &quot;\0&quot; &quot;ISO-8859-4&quot; &quot;\0&quot;</span>
<span class="line-modified">255      &quot;CP28595&quot; &quot;\0&quot; &quot;ISO-8859-5&quot; &quot;\0&quot;</span>
<span class="line-modified">256      &quot;CP28596&quot; &quot;\0&quot; &quot;ISO-8859-6&quot; &quot;\0&quot;</span>
<span class="line-modified">257      &quot;CP28597&quot; &quot;\0&quot; &quot;ISO-8859-7&quot; &quot;\0&quot;</span>
<span class="line-modified">258      &quot;CP28598&quot; &quot;\0&quot; &quot;ISO-8859-8&quot; &quot;\0&quot;</span>
<span class="line-modified">259      &quot;CP28599&quot; &quot;\0&quot; &quot;ISO-8859-9&quot; &quot;\0&quot;</span>
<span class="line-modified">260      &quot;CP28605&quot; &quot;\0&quot; &quot;ISO-8859-15&quot; &quot;\0&quot;</span>
<span class="line-modified">261      &quot;CP38598&quot; &quot;\0&quot; &quot;ISO-8859-8&quot; &quot;\0&quot;</span>
<span class="line-modified">262      &quot;CP51932&quot; &quot;\0&quot; &quot;EUC-JP&quot; &quot;\0&quot;</span>
<span class="line-modified">263      &quot;CP51936&quot; &quot;\0&quot; &quot;GB2312&quot; &quot;\0&quot;</span>
<span class="line-modified">264      &quot;CP51949&quot; &quot;\0&quot; &quot;EUC-KR&quot; &quot;\0&quot;</span>
<span class="line-modified">265      &quot;CP51950&quot; &quot;\0&quot; &quot;EUC-TW&quot; &quot;\0&quot;</span>
<span class="line-modified">266      &quot;CP54936&quot; &quot;\0&quot; &quot;GB18030&quot; &quot;\0&quot;</span>
<span class="line-modified">267      &quot;CP65001&quot; &quot;\0&quot; &quot;UTF-8&quot; &quot;\0&quot;;</span>
268 # endif
269 #endif
270 
271       charset_aliases = cp;
272     }
273 
274   return cp;
275 }
276 
277 /* Determine the current locale&#39;s character encoding, and canonicalize it
278    into one of the canonical names listed in config.charset.
279    The result must not be freed; it is statically allocated.
280    If the canonical name cannot be determined, the result is a non-canonical
281    name.  */
282 
283 const char *
284 _g_locale_charset_raw (void)
285 {
286   const char *codeset;
287 
288 #if !(defined WIN32_NATIVE || defined OS2)
289 
290 # if HAVE_LANGINFO_CODESET
291 
292   /* Most systems support nl_langinfo (CODESET) nowadays.  */
293   codeset = nl_langinfo (CODESET);
294 
295 #  ifdef __CYGWIN__
296   /* Cygwin 2006 does not have locales.  nl_langinfo (CODESET) always
297      returns &quot;US-ASCII&quot;.  As long as this is not fixed, return the suffix
298      of the locale name from the environment variables (if present) or
299      the codepage as a number.  */
300   if (codeset != NULL &amp;&amp; strcmp (codeset, &quot;US-ASCII&quot;) == 0)
301     {
302       const char *locale;
303       static char buf[2 + 10 + 1];
304 
305       locale = getenv (&quot;LC_ALL&quot;);
306       if (locale == NULL || locale[0] == &#39;\0&#39;)
<span class="line-modified">307   {</span>
<span class="line-modified">308     locale = getenv (&quot;LC_CTYPE&quot;);</span>
<span class="line-modified">309     if (locale == NULL || locale[0] == &#39;\0&#39;)</span>
<span class="line-modified">310       locale = getenv (&quot;LANG&quot;);</span>
<span class="line-modified">311   }</span>
312       if (locale != NULL &amp;&amp; locale[0] != &#39;\0&#39;)
<span class="line-modified">313   {</span>
<span class="line-modified">314     /* If the locale name contains an encoding after the dot, return</span>
<span class="line-modified">315        it.  */</span>
<span class="line-modified">316     const char *dot = strchr (locale, &#39;.&#39;);</span>
317 
<span class="line-modified">318     if (dot != NULL)</span>
<span class="line-modified">319       {</span>
<span class="line-modified">320         const char *modifier;</span>
<span class="line-modified">321 </span>
<span class="line-modified">322         dot++;</span>
<span class="line-modified">323         /* Look for the possible @... trailer and remove it, if any.  */</span>
<span class="line-modified">324         modifier = strchr (dot, &#39;@&#39;);</span>
<span class="line-modified">325         if (modifier == NULL)</span>
<span class="line-modified">326     return dot;</span>
<span class="line-modified">327         if (modifier - dot &lt; sizeof (buf))</span>
<span class="line-modified">328     {</span>
<span class="line-modified">329       memcpy (buf, dot, modifier - dot);</span>
<span class="line-modified">330       buf [modifier - dot] = &#39;\0&#39;;</span>
<span class="line-modified">331       return buf;</span>


332     }
<span class="line-added">333       }</span>
<span class="line-added">334   }</span>
335 
336       /* Woe32 has a function returning the locale&#39;s codepage as a number.  */
337       sprintf (buf, &quot;CP%u&quot;, GetACP ());
338       codeset = buf;
339     }
340 #  endif
341 
342 # else
343 
344   /* On old systems which lack it, use setlocale or getenv.  */
345   const char *locale = NULL;
346 
347   /* But most old systems don&#39;t have a complete set of locales.  Some
348      (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don&#39;t
349      use setlocale here; it would return &quot;C&quot; when it doesn&#39;t support the
350      locale name the user has set.  */
351 #  if 0
352   locale = setlocale (LC_CTYPE, NULL);
353 #  endif
354   if (locale == NULL || locale[0] == &#39;\0&#39;)
355     {
356       locale = getenv (&quot;LC_ALL&quot;);
357       if (locale == NULL || locale[0] == &#39;\0&#39;)
<span class="line-modified">358   {</span>
<span class="line-modified">359     locale = getenv (&quot;LC_CTYPE&quot;);</span>
<span class="line-modified">360     if (locale == NULL || locale[0] == &#39;\0&#39;)</span>
<span class="line-modified">361       locale = getenv (&quot;LANG&quot;);</span>
<span class="line-modified">362   }</span>
363     }
364 
365   /* On some old systems, one used to set locale = &quot;iso8859_1&quot;. On others,
366      you set it to &quot;language_COUNTRY.charset&quot;. In any case, we resolve it
367      through the charset.alias file.  */
368   codeset = locale;
369 
370 # endif
371 
372 #elif defined WIN32_NATIVE
373 
374   static char buf[2 + 10 + 1];
375 
376   /* Woe32 has a function returning the locale&#39;s codepage as a number.  */
377   sprintf (buf, &quot;CP%u&quot;, GetACP ());
378   codeset = buf;
379 
380 #elif defined OS2
381 
382   const char *locale;
383   static char buf[2 + 10 + 1];
384   ULONG cp[3];
385   ULONG cplen;
386 
387   /* Allow user to override the codeset, as set in the operating system,
388      with standard language environment variables.  */
389   locale = getenv (&quot;LC_ALL&quot;);
390   if (locale == NULL || locale[0] == &#39;\0&#39;)
391     {
392       locale = getenv (&quot;LC_CTYPE&quot;);
393       if (locale == NULL || locale[0] == &#39;\0&#39;)
<span class="line-modified">394   locale = getenv (&quot;LANG&quot;);</span>
395     }
396   if (locale != NULL &amp;&amp; locale[0] != &#39;\0&#39;)
397     {
398       /* If the locale name contains an encoding after the dot, return it.  */
399       const char *dot = strchr (locale, &#39;.&#39;);
400 
401       if (dot != NULL)
<span class="line-modified">402   {</span>
<span class="line-modified">403     const char *modifier;</span>
<span class="line-modified">404 </span>
<span class="line-modified">405     dot++;</span>
<span class="line-modified">406     /* Look for the possible @... trailer and remove it, if any.  */</span>
<span class="line-modified">407     modifier = strchr (dot, &#39;@&#39;);</span>
<span class="line-modified">408     if (modifier == NULL)</span>
<span class="line-modified">409       return dot;</span>
<span class="line-modified">410     if (modifier - dot &lt; sizeof (buf))</span>
<span class="line-modified">411       {</span>
<span class="line-modified">412         memcpy (buf, dot, modifier - dot);</span>
<span class="line-modified">413         buf [modifier - dot] = &#39;\0&#39;;</span>
<span class="line-modified">414         return buf;</span>
<span class="line-modified">415       }</span>
<span class="line-modified">416   }</span>
417 
418       /* Resolve through the charset.alias file.  */
419       codeset = locale;
420     }
421   else
422     {
423       /* OS/2 has a function returning the locale&#39;s codepage as a number.  */
424       if (DosQueryCp (sizeof (cp), cp, &amp;cplen))
<span class="line-modified">425   codeset = &quot;&quot;;</span>
426       else
<span class="line-modified">427   {</span>
<span class="line-modified">428     sprintf (buf, &quot;CP%u&quot;, cp[0]);</span>
<span class="line-modified">429     codeset = buf;</span>
<span class="line-modified">430   }</span>
431     }
432 
433 #endif
434 
435   return codeset;
436 }
437 
438 const char *
439 _g_locale_charset_unalias (const char *codeset)
440 {
441   const char *aliases;
442 
443   if (codeset == NULL)
444     /* The canonical name cannot be determined.  */
445     codeset = &quot;&quot;;
446 
447   /* Resolve alias. */
448   for (aliases = _g_locale_get_charset_aliases ();
449        *aliases != &#39;\0&#39;;
450        aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)
451     if (strcmp (codeset, aliases) == 0
<span class="line-modified">452   || (aliases[0] == &#39;*&#39; &amp;&amp; aliases[1] == &#39;\0&#39;))</span>
453       {
<span class="line-modified">454   codeset = aliases + strlen (aliases) + 1;</span>
<span class="line-modified">455   break;</span>
456       }
457 
458   /* Don&#39;t return an empty string.  GNU libc and GNU libiconv interpret
459      the empty string as denoting &quot;the locale&#39;s character encoding&quot;,
460      thus GNU libiconv would call this function a second time.  */
461   if (codeset[0] == &#39;\0&#39;)
462     codeset = &quot;ASCII&quot;;
463 
464   return codeset;
465 }
</pre>
</td>
</tr>
</table>
<center><a href="libcharset.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../win_iconv.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>