<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstpad.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wtay@chello.be&gt;
   4  *
   5  * gstpad.c: Pads for linking elements together
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 /**
  23  * SECTION:gstpad
  24  * @title: GstPad
  25  * @short_description: Object contained by elements that allows links to
  26  *                     other elements
  27  * @see_also: #GstPadTemplate, #GstElement, #GstEvent, #GstQuery, #GstBuffer
  28  *
  29  * A #GstElement is linked to other elements via &quot;pads&quot;, which are extremely
  30  * light-weight generic link points.
  31  *
  32  * Pads have a #GstPadDirection, source pads produce data, sink pads consume
  33  * data.
  34  *
  35  * Pads are typically created from a #GstPadTemplate with
  36  * gst_pad_new_from_template() and are then added to a #GstElement. This usually
  37  * happens when the element is created but it can also happen dynamically based
  38  * on the data that the element is processing or based on the pads that the
  39  * application requests.
  40  *
  41  * Pads without pad templates can be created with gst_pad_new(),
  42  * which takes a direction and a name as an argument.  If the name is %NULL,
  43  * then a guaranteed unique name will be assigned to it.
  44  *
  45  * A #GstElement creating a pad will typically use the various
  46  * gst_pad_set_*_function() calls to register callbacks for events, queries or
  47  * dataflow on the pads.
  48  *
  49  * gst_pad_get_parent() will retrieve the #GstElement that owns the pad.
  50  *
  51  * After two pads are retrieved from an element by gst_element_get_static_pad(),
  52  * the pads can be linked with gst_pad_link(). (For quick links,
  53  * you can also use gst_element_link(), which will make the obvious
  54  * link for you if it&#39;s straightforward.). Pads can be unlinked again with
  55  * gst_pad_unlink(). gst_pad_get_peer() can be used to check what the pad is
  56  * linked to.
  57  *
  58  * Before dataflow is possible on the pads, they need to be activated with
  59  * gst_pad_set_active().
  60  *
  61  * gst_pad_query() and gst_pad_peer_query() can be used to query various
  62  * properties of the pad and the stream.
  63  *
  64  * To send a #GstEvent on a pad, use gst_pad_send_event() and
  65  * gst_pad_push_event(). Some events will be sticky on the pad, meaning that
  66  * after they pass on the pad they can be queried later with
  67  * gst_pad_get_sticky_event() and gst_pad_sticky_events_foreach().
  68  * gst_pad_get_current_caps() and gst_pad_has_current_caps() are convenience
  69  * functions to query the current sticky CAPS event on a pad.
  70  *
  71  * GstElements will use gst_pad_push() and gst_pad_pull_range() to push out
  72  * or pull in a buffer.
  73  *
  74  * The dataflow, events and queries that happen on a pad can be monitored with
  75  * probes that can be installed with gst_pad_add_probe(). gst_pad_is_blocked()
  76  * can be used to check if a block probe is installed on the pad.
  77  * gst_pad_is_blocking() checks if the blocking probe is currently blocking the
  78  * pad. gst_pad_remove_probe() is used to remove a previously installed probe
  79  * and unblock blocking probes if any.
  80  *
  81  * Pad have an offset that can be retrieved with gst_pad_get_offset(). This
  82  * offset will be applied to the running_time of all data passing over the pad.
  83  * gst_pad_set_offset() can be used to change the offset.
  84  *
  85  * Convenience functions exist to start, pause and stop the task on a pad with
  86  * gst_pad_start_task(), gst_pad_pause_task() and gst_pad_stop_task()
  87  * respectively.
  88  */
  89 
  90 #include &quot;gst_private.h&quot;
  91 
  92 #include &quot;gstpad.h&quot;
  93 #include &quot;gstpadtemplate.h&quot;
  94 #include &quot;gstenumtypes.h&quot;
  95 #include &quot;gstutils.h&quot;
  96 #include &quot;gstinfo.h&quot;
  97 #include &quot;gsterror.h&quot;
  98 #include &quot;gsttracerutils.h&quot;
  99 #include &quot;gstvalue.h&quot;
 100 #include &quot;glib-compat-private.h&quot;
 101 
 102 GST_DEBUG_CATEGORY_STATIC (debug_dataflow);
 103 #define GST_CAT_DEFAULT GST_CAT_PADS
 104 
 105 /* Pad signals and args */
 106 enum
 107 {
 108   PAD_LINKED,
 109   PAD_UNLINKED,
 110   /* FILL ME */
 111   LAST_SIGNAL
 112 };
 113 
 114 enum
 115 {
 116   PAD_PROP_0,
 117   PAD_PROP_CAPS,
 118   PAD_PROP_DIRECTION,
 119   PAD_PROP_TEMPLATE,
 120   PAD_PROP_OFFSET
<a name="1" id="anc1"></a><span class="line-modified"> 121   /* FILL ME */</span>
 122 };
 123 
<a name="2" id="anc2"></a><span class="line-removed"> 124 #define GST_PAD_GET_PRIVATE(obj)  \</span>
<span class="line-removed"> 125    (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_PAD, GstPadPrivate))</span>
<span class="line-removed"> 126 </span>
 127 #define _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH (GST_PAD_PROBE_TYPE_ALL_BOTH | GST_PAD_PROBE_TYPE_EVENT_FLUSH)
 128 
 129 /* we have a pending and an active event on the pad. On source pads only the
 130  * active event is used. On sinkpads, events are copied to the pending entry and
 131  * moved to the active event when the eventfunc returned %TRUE. */
 132 typedef struct
 133 {
 134   gboolean received;
 135   GstEvent *event;
 136 } PadEvent;
 137 
 138 struct _GstPadPrivate
 139 {
 140   guint events_cookie;
 141   GArray *events;
 142   guint last_cookie;
 143 
 144   gint using;
 145   guint probe_list_cookie;
 146 
 147   /* counter of how many idle probes are running directly from the add_probe
 148    * call. Used to block any data flowing in the pad while the idle callback
 149    * Doesn&#39;t finish its work */
 150   gint idle_running;
 151 
 152   /* conditional and variable used to ensure pads only get (de)activated
 153    * by a single thread at a time. Protected by the object lock */
 154   GCond activation_cond;
 155   gboolean in_activation;
 156 };
 157 
 158 typedef struct
 159 {
 160   GHook hook;
 161 } GstProbe;
 162 
 163 #define GST_PAD_IS_RUNNING_IDLE_PROBE(p) \
 164     (((GstPad *)(p))-&gt;priv-&gt;idle_running &gt; 0)
 165 
 166 typedef struct
 167 {
 168   GstPad *pad;
 169   GstPadProbeInfo *info;
 170   gboolean dropped;
 171   gboolean pass;
 172   gboolean handled;
 173   gboolean marshalled;
 174 
<a name="3" id="anc3"></a><span class="line-modified"> 175   GHook **called_probes;</span>
 176   guint n_called_probes;
 177   guint called_probes_size;
 178   gboolean retry;
 179 } ProbeMarshall;
 180 
 181 static void gst_pad_dispose (GObject * object);
 182 static void gst_pad_finalize (GObject * object);
 183 static void gst_pad_set_property (GObject * object, guint prop_id,
 184     const GValue * value, GParamSpec * pspec);
 185 static void gst_pad_get_property (GObject * object, guint prop_id,
 186     GValue * value, GParamSpec * pspec);
 187 
 188 static void gst_pad_set_pad_template (GstPad * pad, GstPadTemplate * templ);
 189 static gboolean gst_pad_activate_default (GstPad * pad, GstObject * parent);
 190 static GstFlowReturn gst_pad_chain_list_default (GstPad * pad,
 191     GstObject * parent, GstBufferList * list);
 192 
 193 static GstFlowReturn gst_pad_send_event_unchecked (GstPad * pad,
 194     GstEvent * event, GstPadProbeType type);
 195 static GstFlowReturn gst_pad_push_event_unchecked (GstPad * pad,
 196     GstEvent * event, GstPadProbeType type);
 197 
 198 static gboolean activate_mode_internal (GstPad * pad, GstObject * parent,
 199     GstPadMode mode, gboolean active);
 200 
 201 static guint gst_pad_signals[LAST_SIGNAL] = { 0 };
 202 
 203 static GParamSpec *pspec_caps = NULL;
 204 
 205 /* quarks for probe signals */
 206 static GQuark buffer_quark;
 207 static GQuark buffer_list_quark;
 208 static GQuark event_quark;
 209 
 210 typedef struct
 211 {
 212   const gint ret;
 213   const gchar *name;
 214   GQuark quark;
 215 } GstFlowQuarks;
 216 
 217 static GstFlowQuarks flow_quarks[] = {
 218   {GST_FLOW_CUSTOM_SUCCESS, &quot;custom-success&quot;, 0},
 219   {GST_FLOW_OK, &quot;ok&quot;, 0},
 220   {GST_FLOW_NOT_LINKED, &quot;not-linked&quot;, 0},
 221   {GST_FLOW_FLUSHING, &quot;flushing&quot;, 0},
 222   {GST_FLOW_EOS, &quot;eos&quot;, 0},
 223   {GST_FLOW_NOT_NEGOTIATED, &quot;not-negotiated&quot;, 0},
 224   {GST_FLOW_ERROR, &quot;error&quot;, 0},
 225   {GST_FLOW_NOT_SUPPORTED, &quot;not-supported&quot;, 0},
 226   {GST_FLOW_CUSTOM_ERROR, &quot;custom-error&quot;, 0}
 227 };
 228 
 229 /**
 230  * gst_flow_get_name:
 231  * @ret: a #GstFlowReturn to get the name of.
 232  *
 233  * Gets a string representing the given flow return.
 234  *
 235  * Returns: a static string with the name of the flow return.
 236  */
 237 const gchar *
 238 gst_flow_get_name (GstFlowReturn ret)
 239 {
 240   gint i;
 241 
 242   ret = CLAMP (ret, GST_FLOW_CUSTOM_ERROR, GST_FLOW_CUSTOM_SUCCESS);
 243 
 244   for (i = 0; i &lt; G_N_ELEMENTS (flow_quarks); i++) {
 245     if (ret == flow_quarks[i].ret)
 246       return flow_quarks[i].name;
 247   }
 248   return &quot;unknown&quot;;
 249 }
 250 
 251 /**
 252  * gst_flow_to_quark:
 253  * @ret: a #GstFlowReturn to get the quark of.
 254  *
 255  * Get the unique quark for the given GstFlowReturn.
 256  *
 257  * Returns: the quark associated with the flow return or 0 if an
 258  * invalid return was specified.
 259  */
 260 GQuark
 261 gst_flow_to_quark (GstFlowReturn ret)
 262 {
 263   gint i;
 264 
 265   ret = CLAMP (ret, GST_FLOW_CUSTOM_ERROR, GST_FLOW_CUSTOM_SUCCESS);
 266 
 267   for (i = 0; i &lt; G_N_ELEMENTS (flow_quarks); i++) {
 268     if (ret == flow_quarks[i].ret)
 269       return flow_quarks[i].quark;
 270   }
 271   return 0;
 272 }
 273 
 274 /**
 275  * gst_pad_link_get_name:
 276  * @ret: a #GstPadLinkReturn to get the name of.
 277  *
 278  * Gets a string representing the given pad-link return.
 279  *
 280  * Returns: a static string with the name of the pad-link return.
 281  *
 282  * Since: 1.4
 283  */
 284 const gchar *
 285 gst_pad_link_get_name (GstPadLinkReturn ret)
 286 {
 287   switch (ret) {
 288     case GST_PAD_LINK_OK:
 289       return &quot;ok&quot;;
 290     case GST_PAD_LINK_WRONG_HIERARCHY:
 291       return &quot;wrong hierarchy&quot;;
 292     case GST_PAD_LINK_WAS_LINKED:
 293       return &quot;was linked&quot;;
 294     case GST_PAD_LINK_WRONG_DIRECTION:
 295       return &quot;wrong direction&quot;;
 296     case GST_PAD_LINK_NOFORMAT:
 297       return &quot;no common format&quot;;
 298     case GST_PAD_LINK_NOSCHED:
 299       return &quot;incompatible scheduling&quot;;
 300     case GST_PAD_LINK_REFUSED:
 301       return &quot;refused&quot;;
 302   }
 303   g_return_val_if_reached (&quot;unknown&quot;);
 304 }
 305 
 306 #define _do_init \
 307 { \
 308   gint i; \
 309   \
 310   buffer_quark = g_quark_from_static_string (&quot;buffer&quot;); \
 311   buffer_list_quark = g_quark_from_static_string (&quot;bufferlist&quot;); \
 312   event_quark = g_quark_from_static_string (&quot;event&quot;); \
 313   \
<a name="4" id="anc4"></a><span class="line-modified"> 314   for (i = 0; i &lt; G_N_ELEMENTS (flow_quarks); i++) {            \</span>
 315     flow_quarks[i].quark = g_quark_from_static_string (flow_quarks[i].name); \
 316   } \
 317   \
 318   GST_DEBUG_CATEGORY_INIT (debug_dataflow, &quot;GST_DATAFLOW&quot;, \
 319       GST_DEBUG_BOLD | GST_DEBUG_FG_GREEN, &quot;dataflow inside pads&quot;); \
 320 }
 321 
 322 #define gst_pad_parent_class parent_class
<a name="5" id="anc5"></a><span class="line-modified"> 323 G_DEFINE_TYPE_WITH_CODE (GstPad, gst_pad, GST_TYPE_OBJECT, _do_init);</span>

 324 
 325 static void
 326 gst_pad_class_init (GstPadClass * klass)
 327 {
 328   GObjectClass *gobject_class;
 329   GstObjectClass *gstobject_class;
 330 
 331   gobject_class = G_OBJECT_CLASS (klass);
 332   gstobject_class = GST_OBJECT_CLASS (klass);
 333 
<a name="6" id="anc6"></a><span class="line-removed"> 334   g_type_class_add_private (klass, sizeof (GstPadPrivate));</span>
<span class="line-removed"> 335 </span>
 336   gobject_class-&gt;dispose = gst_pad_dispose;
 337   gobject_class-&gt;finalize = gst_pad_finalize;
 338   gobject_class-&gt;set_property = gst_pad_set_property;
 339   gobject_class-&gt;get_property = gst_pad_get_property;
 340 
 341   /**
 342    * GstPad::linked:
 343    * @pad: the pad that emitted the signal
 344    * @peer: the peer pad that has been connected
 345    *
 346    * Signals that a pad has been linked to the peer pad.
 347    */
 348   gst_pad_signals[PAD_LINKED] =
 349       g_signal_new (&quot;linked&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 350       G_STRUCT_OFFSET (GstPadClass, linked), NULL, NULL,
 351       g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_PAD);
 352   /**
 353    * GstPad::unlinked:
 354    * @pad: the pad that emitted the signal
 355    * @peer: the peer pad that has been disconnected
 356    *
 357    * Signals that a pad has been unlinked from the peer pad.
 358    */
 359   gst_pad_signals[PAD_UNLINKED] =
 360       g_signal_new (&quot;unlinked&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 361       G_STRUCT_OFFSET (GstPadClass, unlinked), NULL, NULL,
 362       g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_PAD);
 363 
 364   pspec_caps = g_param_spec_boxed (&quot;caps&quot;, &quot;Caps&quot;,
 365       &quot;The capabilities of the pad&quot;, GST_TYPE_CAPS,
 366       G_PARAM_READABLE | G_PARAM_STATIC_STRINGS);
 367   g_object_class_install_property (gobject_class, PAD_PROP_CAPS, pspec_caps);
 368 
 369   g_object_class_install_property (gobject_class, PAD_PROP_DIRECTION,
 370       g_param_spec_enum (&quot;direction&quot;, &quot;Direction&quot;, &quot;The direction of the pad&quot;,
 371           GST_TYPE_PAD_DIRECTION, GST_PAD_UNKNOWN,
 372           G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY | G_PARAM_STATIC_STRINGS));
 373 
 374   /* FIXME, Make G_PARAM_CONSTRUCT_ONLY when we fix ghostpads. */
 375   g_object_class_install_property (gobject_class, PAD_PROP_TEMPLATE,
 376       g_param_spec_object (&quot;template&quot;, &quot;Template&quot;,
 377           &quot;The GstPadTemplate of this pad&quot;, GST_TYPE_PAD_TEMPLATE,
 378           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 379 
 380   /**
 381    * GstPad:offset:
 382    *
 383    * The offset that will be applied to the running time of the pad.
 384    *
 385    * Since: 1.6
 386    */
 387   g_object_class_install_property (gobject_class, PAD_PROP_OFFSET,
 388       g_param_spec_int64 (&quot;offset&quot;, &quot;Offset&quot;,
 389           &quot;The running time offset of the pad&quot;, 0, G_MAXINT64, 0,
 390           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 391 
 392   gstobject_class-&gt;path_string_separator = &quot;.&quot;;
 393 
 394   /* Register common function pointer descriptions */
 395   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_activate_default);
 396   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_event_default);
 397   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_query_default);
 398   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_iterate_internal_links_default);
 399   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_chain_list_default);
 400 }
 401 
 402 static void
 403 gst_pad_init (GstPad * pad)
 404 {
<a name="7" id="anc7"></a><span class="line-modified"> 405   pad-&gt;priv = GST_PAD_GET_PRIVATE (pad);</span>
 406 
 407   GST_PAD_DIRECTION (pad) = GST_PAD_UNKNOWN;
 408 
 409   GST_PAD_ACTIVATEFUNC (pad) = gst_pad_activate_default;
 410   GST_PAD_EVENTFUNC (pad) = gst_pad_event_default;
 411   GST_PAD_QUERYFUNC (pad) = gst_pad_query_default;
 412   GST_PAD_ITERINTLINKFUNC (pad) = gst_pad_iterate_internal_links_default;
 413   GST_PAD_CHAINLISTFUNC (pad) = gst_pad_chain_list_default;
 414 
 415   GST_PAD_SET_FLUSHING (pad);
 416 
 417   g_rec_mutex_init (&amp;pad-&gt;stream_rec_lock);
 418 
 419   g_cond_init (&amp;pad-&gt;block_cond);
 420 
 421   g_hook_list_init (&amp;pad-&gt;probes, sizeof (GstProbe));
 422 
 423   pad-&gt;priv-&gt;events = g_array_sized_new (FALSE, TRUE, sizeof (PadEvent), 16);
 424   pad-&gt;priv-&gt;events_cookie = 0;
 425   pad-&gt;priv-&gt;last_cookie = -1;
 426   g_cond_init (&amp;pad-&gt;priv-&gt;activation_cond);
 427 
 428   pad-&gt;ABI.abi.last_flowret = GST_FLOW_FLUSHING;
 429 }
 430 
 431 /* called when setting the pad inactive. It removes all sticky events from
 432  * the pad. must be called with object lock */
 433 static void
 434 remove_events (GstPad * pad)
 435 {
 436   guint i, len;
 437   GArray *events;
 438   gboolean notify = FALSE;
 439 
 440   events = pad-&gt;priv-&gt;events;
 441 
 442   len = events-&gt;len;
 443   for (i = 0; i &lt; len; i++) {
 444     PadEvent *ev = &amp;g_array_index (events, PadEvent, i);
 445     GstEvent *event = ev-&gt;event;
 446 
 447     ev-&gt;event = NULL;
 448 
 449     if (event &amp;&amp; GST_EVENT_TYPE (event) == GST_EVENT_CAPS)
 450       notify = TRUE;
 451 
 452     gst_event_unref (event);
 453   }
 454 
 455   GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_PENDING_EVENTS);
 456   g_array_set_size (events, 0);
 457   pad-&gt;priv-&gt;events_cookie++;
 458 
 459   if (notify) {
 460     GST_OBJECT_UNLOCK (pad);
 461 
 462     GST_DEBUG_OBJECT (pad, &quot;notify caps&quot;);
 463     g_object_notify_by_pspec ((GObject *) pad, pspec_caps);
 464 
 465     GST_OBJECT_LOCK (pad);
 466   }
 467 }
 468 
 469 /* should be called with object lock */
 470 static PadEvent *
 471 find_event_by_type (GstPad * pad, GstEventType type, guint idx)
 472 {
 473   guint i, len;
 474   GArray *events;
 475   PadEvent *ev;
 476 
 477   events = pad-&gt;priv-&gt;events;
 478   len = events-&gt;len;
 479 
 480   for (i = 0; i &lt; len; i++) {
 481     ev = &amp;g_array_index (events, PadEvent, i);
 482     if (ev-&gt;event == NULL)
 483       continue;
 484 
 485     if (GST_EVENT_TYPE (ev-&gt;event) == type) {
 486       if (idx == 0)
 487         goto found;
 488       idx--;
 489     } else if (GST_EVENT_TYPE (ev-&gt;event) &gt; type) {
 490       break;
 491     }
 492   }
 493   ev = NULL;
 494 found:
 495   return ev;
 496 }
 497 
 498 /* should be called with OBJECT lock */
 499 static PadEvent *
 500 find_event (GstPad * pad, GstEvent * event)
 501 {
 502   guint i, len;
 503   GArray *events;
 504   PadEvent *ev;
 505 
 506   events = pad-&gt;priv-&gt;events;
 507   len = events-&gt;len;
 508 
 509   for (i = 0; i &lt; len; i++) {
 510     ev = &amp;g_array_index (events, PadEvent, i);
 511     if (event == ev-&gt;event)
 512       goto found;
 513     else if (GST_EVENT_TYPE (ev-&gt;event) &gt; GST_EVENT_TYPE (event))
 514       break;
 515   }
 516   ev = NULL;
 517 found:
 518   return ev;
 519 }
 520 
 521 /* should be called with OBJECT lock */
 522 static void
 523 remove_event_by_type (GstPad * pad, GstEventType type)
 524 {
 525   guint i, len;
 526   GArray *events;
 527   PadEvent *ev;
 528 
 529   events = pad-&gt;priv-&gt;events;
 530   len = events-&gt;len;
 531 
 532   i = 0;
 533   while (i &lt; len) {
 534     ev = &amp;g_array_index (events, PadEvent, i);
 535     if (ev-&gt;event == NULL)
 536       goto next;
 537 
 538     if (GST_EVENT_TYPE (ev-&gt;event) &gt; type)
 539       break;
 540     else if (GST_EVENT_TYPE (ev-&gt;event) != type)
 541       goto next;
 542 
 543     gst_event_unref (ev-&gt;event);
 544     g_array_remove_index (events, i);
 545     len--;
 546     pad-&gt;priv-&gt;events_cookie++;
 547     continue;
 548 
 549   next:
 550     i++;
 551   }
 552 }
 553 
 554 /* check all events on srcpad against those on sinkpad. All events that are not
 555  * on sinkpad are marked as received=%FALSE and the PENDING_EVENTS is set on the
 556  * srcpad so that the events will be sent next time */
 557 /* should be called with srcpad and sinkpad LOCKS */
 558 static void
 559 schedule_events (GstPad * srcpad, GstPad * sinkpad)
 560 {
 561   gint i, len;
 562   GArray *events;
 563   PadEvent *ev;
 564   gboolean pending = FALSE;
 565 
 566   events = srcpad-&gt;priv-&gt;events;
 567   len = events-&gt;len;
 568 
 569   for (i = 0; i &lt; len; i++) {
 570     ev = &amp;g_array_index (events, PadEvent, i);
 571     if (ev-&gt;event == NULL)
 572       continue;
 573 
 574     if (sinkpad == NULL || !find_event (sinkpad, ev-&gt;event)) {
 575       ev-&gt;received = FALSE;
 576       pending = TRUE;
 577     }
 578   }
 579   if (pending)
 580     GST_OBJECT_FLAG_SET (srcpad, GST_PAD_FLAG_PENDING_EVENTS);
 581 }
 582 
 583 typedef gboolean (*PadEventFunction) (GstPad * pad, PadEvent * ev,
 584     gpointer user_data);
 585 
 586 /* should be called with pad LOCK */
 587 static void
 588 events_foreach (GstPad * pad, PadEventFunction func, gpointer user_data)
 589 {
 590   guint i, len;
 591   GArray *events;
 592   gboolean ret;
 593   guint cookie;
 594 
 595   events = pad-&gt;priv-&gt;events;
 596 
 597 restart:
 598   cookie = pad-&gt;priv-&gt;events_cookie;
 599   i = 0;
 600   len = events-&gt;len;
 601   while (i &lt; len) {
 602     PadEvent *ev, ev_ret;
 603 
 604     ev = &amp;g_array_index (events, PadEvent, i);
 605     if (G_UNLIKELY (ev-&gt;event == NULL))
 606       goto next;
 607 
<a name="8" id="anc8"></a><span class="line-modified"> 608     /* take aditional ref, func might release the lock */</span>
 609     ev_ret.event = gst_event_ref (ev-&gt;event);
 610     ev_ret.received = ev-&gt;received;
 611 
 612     ret = func (pad, &amp;ev_ret, user_data);
 613 
 614     /* recheck the cookie, lock might have been released and the list could have
 615      * changed */
 616     if (G_UNLIKELY (cookie != pad-&gt;priv-&gt;events_cookie)) {
 617       if (G_LIKELY (ev_ret.event))
 618         gst_event_unref (ev_ret.event);
 619       goto restart;
 620     }
 621 
 622     /* store the received state */
 623     ev-&gt;received = ev_ret.received;
 624 
 625     /* if the event changed, we need to do something */
 626     if (G_UNLIKELY (ev-&gt;event != ev_ret.event)) {
 627       if (G_UNLIKELY (ev_ret.event == NULL)) {
 628         /* function unreffed and set the event to NULL, remove it */
 629         gst_event_unref (ev-&gt;event);
 630         g_array_remove_index (events, i);
 631         len--;
 632         cookie = ++pad-&gt;priv-&gt;events_cookie;
 633         continue;
 634       } else {
 635         /* function gave a new event for us */
 636         gst_event_take (&amp;ev-&gt;event, ev_ret.event);
 637       }
 638     } else {
 639       /* just unref, nothing changed */
 640       gst_event_unref (ev_ret.event);
 641     }
 642     if (!ret)
 643       break;
 644   next:
 645     i++;
 646   }
 647 }
 648 
 649 /* should be called with LOCK */
 650 static GstEvent *
 651 _apply_pad_offset (GstPad * pad, GstEvent * event, gboolean upstream,
 652     gint64 pad_offset)
 653 {
<a name="9" id="anc9"></a><span class="line-modified"> 654     gint64 offset;</span>
 655 
 656   GST_DEBUG_OBJECT (pad, &quot;apply pad offset %&quot; GST_STIME_FORMAT,
 657       GST_STIME_ARGS (pad_offset));
 658 
<a name="10" id="anc10"></a><span class="line-modified"> 659     if (GST_EVENT_TYPE (event) == GST_EVENT_SEGMENT) {</span>
<span class="line-modified"> 660       GstSegment segment;</span>
 661 
<a name="11" id="anc11"></a><span class="line-modified"> 662       g_assert (!upstream);</span>
 663 
<a name="12" id="anc12"></a><span class="line-modified"> 664       /* copy segment values */</span>
<span class="line-modified"> 665       gst_event_copy_segment (event, &amp;segment);</span>
<span class="line-modified"> 666       gst_event_unref (event);</span>
 667 
 668     gst_segment_offset_running_time (&amp;segment, segment.format, pad_offset);
<a name="13" id="anc13"></a><span class="line-modified"> 669       event = gst_event_new_segment (&amp;segment);</span>
<span class="line-modified"> 670     }</span>
 671 
<a name="14" id="anc14"></a><span class="line-modified"> 672     event = gst_event_make_writable (event);</span>
<span class="line-modified"> 673     offset = gst_event_get_running_time_offset (event);</span>
<span class="line-modified"> 674     if (upstream)</span>
 675     offset -= pad_offset;
<a name="15" id="anc15"></a><span class="line-modified"> 676     else</span>
 677     offset += pad_offset;
<a name="16" id="anc16"></a><span class="line-modified"> 678     gst_event_set_running_time_offset (event, offset);</span>
 679 
 680   return event;
<a name="17" id="anc17"></a><span class="line-modified"> 681   }</span>
 682 
 683 static inline GstEvent *
 684 apply_pad_offset (GstPad * pad, GstEvent * event, gboolean upstream)
 685 {
 686   if (G_UNLIKELY (pad-&gt;offset != 0))
 687     return _apply_pad_offset (pad, event, upstream, pad-&gt;offset);
 688   return event;
 689 }
 690 
 691 /* should be called with the OBJECT_LOCK */
 692 static GstCaps *
 693 get_pad_caps (GstPad * pad)
 694 {
 695   GstCaps *caps = NULL;
 696   PadEvent *ev;
 697 
 698   ev = find_event_by_type (pad, GST_EVENT_CAPS, 0);
 699   if (ev &amp;&amp; ev-&gt;event)
 700     gst_event_parse_caps (ev-&gt;event, &amp;caps);
 701 
 702   return caps;
 703 }
 704 
 705 static void
 706 gst_pad_dispose (GObject * object)
 707 {
 708   GstPad *pad = GST_PAD_CAST (object);
 709   GstPad *peer;
 710 
 711   GST_CAT_DEBUG_OBJECT (GST_CAT_REFCOUNTING, pad, &quot;%p dispose&quot;, pad);
 712 
 713   /* unlink the peer pad */
 714   if ((peer = gst_pad_get_peer (pad))) {
 715     /* window for MT unsafeness, someone else could unlink here
 716      * and then we call unlink with wrong pads. The unlink
 717      * function would catch this and safely return failed. */
 718     if (GST_PAD_IS_SRC (pad))
 719       gst_pad_unlink (pad, peer);
 720     else
 721       gst_pad_unlink (peer, pad);
 722 
 723     gst_object_unref (peer);
 724   }
 725 
 726   gst_pad_set_pad_template (pad, NULL);
 727 
 728   GST_OBJECT_LOCK (pad);
 729   remove_events (pad);
 730   GST_OBJECT_UNLOCK (pad);
 731 
 732   g_hook_list_clear (&amp;pad-&gt;probes);
 733 
 734   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
 735 }
 736 
 737 static void
 738 gst_pad_finalize (GObject * object)
 739 {
 740   GstPad *pad = GST_PAD_CAST (object);
 741   GstTask *task;
 742 
 743   /* in case the task is still around, clean it up */
 744   if ((task = GST_PAD_TASK (pad))) {
 745     gst_task_join (task);
 746     GST_PAD_TASK (pad) = NULL;
 747     gst_object_unref (task);
 748   }
 749 
 750   if (pad-&gt;activatenotify)
 751     pad-&gt;activatenotify (pad-&gt;activatedata);
 752   if (pad-&gt;activatemodenotify)
 753     pad-&gt;activatemodenotify (pad-&gt;activatemodedata);
 754   if (pad-&gt;linknotify)
 755     pad-&gt;linknotify (pad-&gt;linkdata);
 756   if (pad-&gt;unlinknotify)
 757     pad-&gt;unlinknotify (pad-&gt;unlinkdata);
 758   if (pad-&gt;chainnotify)
 759     pad-&gt;chainnotify (pad-&gt;chaindata);
 760   if (pad-&gt;chainlistnotify)
 761     pad-&gt;chainlistnotify (pad-&gt;chainlistdata);
 762   if (pad-&gt;getrangenotify)
 763     pad-&gt;getrangenotify (pad-&gt;getrangedata);
 764   if (pad-&gt;eventnotify)
 765     pad-&gt;eventnotify (pad-&gt;eventdata);
 766   if (pad-&gt;querynotify)
 767     pad-&gt;querynotify (pad-&gt;querydata);
 768   if (pad-&gt;iterintlinknotify)
 769     pad-&gt;iterintlinknotify (pad-&gt;iterintlinkdata);
 770 
 771   g_rec_mutex_clear (&amp;pad-&gt;stream_rec_lock);
 772   g_cond_clear (&amp;pad-&gt;block_cond);
 773   g_cond_clear (&amp;pad-&gt;priv-&gt;activation_cond);
 774   g_array_free (pad-&gt;priv-&gt;events, TRUE);
 775 
 776   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 777 }
 778 
 779 static void
 780 gst_pad_set_property (GObject * object, guint prop_id,
 781     const GValue * value, GParamSpec * pspec)
 782 {
 783   g_return_if_fail (GST_IS_PAD (object));
 784 
 785   switch (prop_id) {
 786     case PAD_PROP_DIRECTION:
 787       GST_PAD_DIRECTION (object) = (GstPadDirection) g_value_get_enum (value);
 788       break;
 789     case PAD_PROP_TEMPLATE:
 790       gst_pad_set_pad_template (GST_PAD_CAST (object),
 791           (GstPadTemplate *) g_value_get_object (value));
 792       break;
 793     case PAD_PROP_OFFSET:
 794       gst_pad_set_offset (GST_PAD_CAST (object), g_value_get_int64 (value));
 795       break;
 796     default:
 797       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 798       break;
 799   }
 800 }
 801 
 802 static void
 803 gst_pad_get_property (GObject * object, guint prop_id,
 804     GValue * value, GParamSpec * pspec)
 805 {
 806   g_return_if_fail (GST_IS_PAD (object));
 807 
 808   switch (prop_id) {
 809     case PAD_PROP_CAPS:
 810       GST_OBJECT_LOCK (object);
 811       g_value_set_boxed (value, get_pad_caps (GST_PAD_CAST (object)));
 812       GST_OBJECT_UNLOCK (object);
 813       break;
 814     case PAD_PROP_DIRECTION:
 815       g_value_set_enum (value, GST_PAD_DIRECTION (object));
 816       break;
 817     case PAD_PROP_TEMPLATE:
 818       g_value_set_object (value, GST_PAD_PAD_TEMPLATE (object));
 819       break;
 820     case PAD_PROP_OFFSET:
 821       g_value_set_int64 (value, gst_pad_get_offset (GST_PAD_CAST (object)));
 822       break;
 823     default:
 824       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 825       break;
 826   }
 827 }
 828 
 829 /**
 830  * gst_pad_new:
 831  * @name: (allow-none): the name of the new pad.
 832  * @direction: the #GstPadDirection of the pad.
 833  *
 834  * Creates a new pad with the given name in the given direction.
 835  * If name is %NULL, a guaranteed unique name (across all pads)
 836  * will be assigned.
 837  * This function makes a copy of the name so you can safely free the name.
 838  *
<a name="18" id="anc18"></a><span class="line-modified"> 839  * Returns: (transfer floating) (nullable): a new #GstPad, or %NULL in</span>
<span class="line-removed"> 840  * case of an error.</span>
 841  *
 842  * MT safe.
 843  */
 844 GstPad *
 845 gst_pad_new (const gchar * name, GstPadDirection direction)
 846 {
 847   return g_object_new (GST_TYPE_PAD,
 848       &quot;name&quot;, name, &quot;direction&quot;, direction, NULL);
 849 }
 850 
 851 /**
 852  * gst_pad_new_from_template:
 853  * @templ: the pad template to use
 854  * @name: (allow-none): the name of the pad
 855  *
 856  * Creates a new pad with the given name from the given template.
 857  * If name is %NULL, a guaranteed unique name (across all pads)
 858  * will be assigned.
 859  * This function makes a copy of the name so you can safely free the name.
 860  *
<a name="19" id="anc19"></a><span class="line-modified"> 861  * Returns: (transfer floating) (nullable): a new #GstPad, or %NULL in</span>
<span class="line-removed"> 862  * case of an error.</span>
 863  */
 864 GstPad *
 865 gst_pad_new_from_template (GstPadTemplate * templ, const gchar * name)
 866 {
 867   GType pad_type =
 868       GST_PAD_TEMPLATE_GTYPE (templ) ==
 869       G_TYPE_NONE ? GST_TYPE_PAD : GST_PAD_TEMPLATE_GTYPE (templ);
 870 
 871   g_return_val_if_fail (GST_IS_PAD_TEMPLATE (templ), NULL);
 872 
 873   return g_object_new (pad_type,
 874       &quot;name&quot;, name, &quot;direction&quot;, templ-&gt;direction, &quot;template&quot;, templ, NULL);
 875 }
 876 
 877 /**
 878  * gst_pad_new_from_static_template:
 879  * @templ: the #GstStaticPadTemplate to use
 880  * @name: the name of the pad
 881  *
 882  * Creates a new pad with the given name from the given static template.
 883  * If name is %NULL, a guaranteed unique name (across all pads)
 884  * will be assigned.
 885  * This function makes a copy of the name so you can safely free the name.
 886  *
<a name="20" id="anc20"></a><span class="line-modified"> 887  * Returns: (transfer floating) (nullable): a new #GstPad, or %NULL in</span>
<span class="line-removed"> 888  * case of an error.</span>
 889  */
 890 GstPad *
 891 gst_pad_new_from_static_template (GstStaticPadTemplate * templ,
 892     const gchar * name)
 893 {
 894   GstPad *pad;
 895   GstPadTemplate *template;
 896 
 897   template = gst_static_pad_template_get (templ);
 898   pad = gst_pad_new_from_template (template, name);
 899   gst_object_unref (template);
 900   return pad;
 901 }
 902 
 903 #define ACQUIRE_PARENT(pad, parent, label)                      \
 904   G_STMT_START {                                                \
 905     if (G_LIKELY ((parent = GST_OBJECT_PARENT (pad))))          \
 906       gst_object_ref (parent);                                  \
 907     else if (G_LIKELY (GST_PAD_NEEDS_PARENT (pad)))             \
 908       goto label;                                               \
 909   } G_STMT_END
 910 
 911 #define RELEASE_PARENT(parent)                                  \
 912   G_STMT_START {                                                \
 913     if (G_LIKELY (parent))                                      \
 914       gst_object_unref (parent);                                \
 915   } G_STMT_END
 916 
 917 /**
 918  * gst_pad_get_direction:
 919  * @pad: a #GstPad to get the direction of.
 920  *
 921  * Gets the direction of the pad. The direction of the pad is
 922  * decided at construction time so this function does not take
 923  * the LOCK.
 924  *
 925  * Returns: the #GstPadDirection of the pad.
 926  *
 927  * MT safe.
 928  */
 929 GstPadDirection
 930 gst_pad_get_direction (GstPad * pad)
 931 {
 932   GstPadDirection result;
 933 
 934   /* PAD_UNKNOWN is a little silly but we need some sort of
 935    * error return value */
 936   g_return_val_if_fail (GST_IS_PAD (pad), GST_PAD_UNKNOWN);
 937 
 938   result = GST_PAD_DIRECTION (pad);
 939 
 940   return result;
 941 }
 942 
 943 static gboolean
 944 gst_pad_activate_default (GstPad * pad, GstObject * parent)
 945 {
 946   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
 947 
 948   return activate_mode_internal (pad, parent, GST_PAD_MODE_PUSH, TRUE);
 949 }
 950 
 951 /**
 952  * gst_pad_mode_get_name:
 953  * @mode: the pad mode
 954  *
 955  * Return the name of a pad mode, for use in debug messages mostly.
 956  *
 957  * Returns: short mnemonic for pad mode @mode
 958  */
 959 const gchar *
 960 gst_pad_mode_get_name (GstPadMode mode)
 961 {
 962   switch (mode) {
 963     case GST_PAD_MODE_NONE:
 964       return &quot;none&quot;;
 965     case GST_PAD_MODE_PUSH:
 966       return &quot;push&quot;;
 967     case GST_PAD_MODE_PULL:
 968       return &quot;pull&quot;;
 969     default:
 970       break;
 971   }
 972   return &quot;unknown&quot;;
 973 }
 974 
 975 /* Returns TRUE if pad wasn&#39;t already in the new_mode */
 976 static gboolean
 977 pre_activate (GstPad * pad, GstPadMode new_mode)
 978 {
 979   switch (new_mode) {
 980     case GST_PAD_MODE_NONE:
 981       GST_OBJECT_LOCK (pad);
 982       while (G_UNLIKELY (pad-&gt;priv-&gt;in_activation))
 983         g_cond_wait (&amp;pad-&gt;priv-&gt;activation_cond, GST_OBJECT_GET_LOCK (pad));
 984       if (new_mode == GST_PAD_MODE (pad)) {
 985         GST_WARNING_OBJECT (pad,
 986             &quot;Pad is already in the process of being deactivated&quot;);
 987         GST_OBJECT_UNLOCK (pad);
 988         return FALSE;
 989       }
 990       pad-&gt;priv-&gt;in_activation = TRUE;
 991       GST_DEBUG_OBJECT (pad, &quot;setting PAD_MODE NONE, set flushing&quot;);
 992       GST_PAD_SET_FLUSHING (pad);
 993       pad-&gt;ABI.abi.last_flowret = GST_FLOW_FLUSHING;
 994       GST_PAD_MODE (pad) = new_mode;
 995       /* unlock blocked pads so element can resume and stop */
 996       GST_PAD_BLOCK_BROADCAST (pad);
 997       GST_OBJECT_UNLOCK (pad);
 998       break;
 999     case GST_PAD_MODE_PUSH:
1000     case GST_PAD_MODE_PULL:
1001       GST_OBJECT_LOCK (pad);
1002       while (G_UNLIKELY (pad-&gt;priv-&gt;in_activation))
1003         g_cond_wait (&amp;pad-&gt;priv-&gt;activation_cond, GST_OBJECT_GET_LOCK (pad));
1004       if (new_mode == GST_PAD_MODE (pad)) {
1005         GST_WARNING_OBJECT (pad,
1006             &quot;Pad is already in the process of being activated&quot;);
1007         GST_OBJECT_UNLOCK (pad);
1008         return FALSE;
1009       }
1010       pad-&gt;priv-&gt;in_activation = TRUE;
1011       GST_DEBUG_OBJECT (pad, &quot;setting pad into %s mode, unset flushing&quot;,
1012           gst_pad_mode_get_name (new_mode));
1013       GST_PAD_UNSET_FLUSHING (pad);
1014       pad-&gt;ABI.abi.last_flowret = GST_FLOW_OK;
1015       GST_PAD_MODE (pad) = new_mode;
1016       if (GST_PAD_IS_SINK (pad)) {
1017         GstPad *peer;
1018         /* make sure the peer src pad sends us all events */
1019         if ((peer = GST_PAD_PEER (pad))) {
1020           gst_object_ref (peer);
1021           GST_OBJECT_UNLOCK (pad);
1022 
1023           GST_DEBUG_OBJECT (pad, &quot;reschedule events on peer %s:%s&quot;,
1024               GST_DEBUG_PAD_NAME (peer));
1025 
1026           GST_OBJECT_LOCK (peer);
1027           schedule_events (peer, NULL);
1028           GST_OBJECT_UNLOCK (peer);
1029 
1030           gst_object_unref (peer);
1031         } else {
1032           GST_OBJECT_UNLOCK (pad);
1033         }
1034       } else {
1035         GST_OBJECT_UNLOCK (pad);
1036       }
1037       break;
1038   }
1039   return TRUE;
1040 }
1041 
1042 static void
1043 post_activate (GstPad * pad, GstPadMode new_mode)
1044 {
1045   switch (new_mode) {
1046     case GST_PAD_MODE_NONE:
1047       GST_OBJECT_LOCK (pad);
1048       pad-&gt;priv-&gt;in_activation = FALSE;
1049       g_cond_broadcast (&amp;pad-&gt;priv-&gt;activation_cond);
1050       GST_OBJECT_UNLOCK (pad);
1051 
1052       /* ensures that streaming stops */
1053       GST_PAD_STREAM_LOCK (pad);
1054       GST_DEBUG_OBJECT (pad, &quot;stopped streaming&quot;);
1055       GST_OBJECT_LOCK (pad);
1056       remove_events (pad);
1057       GST_OBJECT_UNLOCK (pad);
1058       GST_PAD_STREAM_UNLOCK (pad);
1059       break;
1060     case GST_PAD_MODE_PUSH:
1061     case GST_PAD_MODE_PULL:
1062       GST_OBJECT_LOCK (pad);
1063       pad-&gt;priv-&gt;in_activation = FALSE;
1064       g_cond_broadcast (&amp;pad-&gt;priv-&gt;activation_cond);
1065       GST_OBJECT_UNLOCK (pad);
1066       /* NOP */
1067       break;
1068   }
1069 }
1070 
1071 /**
1072  * gst_pad_set_active:
1073  * @pad: the #GstPad to activate or deactivate.
1074  * @active: whether or not the pad should be active.
1075  *
1076  * Activates or deactivates the given pad.
1077  * Normally called from within core state change functions.
1078  *
1079  * If @active, makes sure the pad is active. If it is already active, either in
1080  * push or pull mode, just return. Otherwise dispatches to the pad&#39;s activate
1081  * function to perform the actual activation.
1082  *
1083  * If not @active, calls gst_pad_activate_mode() with the pad&#39;s current mode
1084  * and a %FALSE argument.
1085  *
1086  * Returns: %TRUE if the operation was successful.
1087  *
1088  * MT safe.
1089  */
1090 gboolean
1091 gst_pad_set_active (GstPad * pad, gboolean active)
1092 {
1093   GstObject *parent;
1094   GstPadMode old;
1095   gboolean ret = FALSE;
1096 
1097   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
1098 
1099   GST_OBJECT_LOCK (pad);
1100   old = GST_PAD_MODE (pad);
1101   ACQUIRE_PARENT (pad, parent, no_parent);
1102   GST_OBJECT_UNLOCK (pad);
1103 
1104   if (active) {
1105     if (old == GST_PAD_MODE_NONE) {
1106       GST_DEBUG_OBJECT (pad, &quot;activating pad from none&quot;);
1107       ret = (GST_PAD_ACTIVATEFUNC (pad)) (pad, parent);
1108       if (ret)
1109         pad-&gt;ABI.abi.last_flowret = GST_FLOW_OK;
1110     } else {
1111       GST_DEBUG_OBJECT (pad, &quot;pad was active in %s mode&quot;,
1112           gst_pad_mode_get_name (old));
1113       ret = TRUE;
1114     }
1115   } else {
1116     if (old == GST_PAD_MODE_NONE) {
1117       GST_DEBUG_OBJECT (pad, &quot;pad was inactive&quot;);
1118       ret = TRUE;
1119     } else {
1120       GST_DEBUG_OBJECT (pad, &quot;deactivating pad from %s mode&quot;,
1121           gst_pad_mode_get_name (old));
1122       ret = activate_mode_internal (pad, parent, old, FALSE);
1123       if (ret)
1124         pad-&gt;ABI.abi.last_flowret = GST_FLOW_FLUSHING;
1125     }
1126   }
1127 
1128   RELEASE_PARENT (parent);
1129 
1130   if (G_UNLIKELY (!ret))
1131     goto failed;
1132 
1133   return ret;
1134 
1135   /* ERRORS */
1136 no_parent:
1137   {
1138     GST_DEBUG_OBJECT (pad, &quot;no parent&quot;);
1139     GST_OBJECT_UNLOCK (pad);
1140     return FALSE;
1141   }
1142 failed:
1143   {
1144     GST_OBJECT_LOCK (pad);
1145     if (!active) {
1146       g_critical (&quot;Failed to deactivate pad %s:%s, very bad&quot;,
1147           GST_DEBUG_PAD_NAME (pad));
1148     } else {
1149       GST_WARNING_OBJECT (pad, &quot;Failed to activate pad&quot;);
1150     }
1151     GST_OBJECT_UNLOCK (pad);
1152     return FALSE;
1153   }
1154 }
1155 
1156 static gboolean
1157 activate_mode_internal (GstPad * pad, GstObject * parent, GstPadMode mode,
1158     gboolean active)
1159 {
1160   gboolean res = FALSE;
1161   GstPadMode old, new;
1162   GstPadDirection dir;
1163   GstPad *peer;
1164 
1165   GST_OBJECT_LOCK (pad);
1166   old = GST_PAD_MODE (pad);
1167   dir = GST_PAD_DIRECTION (pad);
1168   GST_OBJECT_UNLOCK (pad);
1169 
1170   new = active ? mode : GST_PAD_MODE_NONE;
1171 
1172   if (old == new)
1173     goto was_ok;
1174 
1175   if (active &amp;&amp; old != mode &amp;&amp; old != GST_PAD_MODE_NONE) {
1176     /* pad was activate in the wrong direction, deactivate it
1177      * and reactivate it in the requested mode */
1178     GST_DEBUG_OBJECT (pad, &quot;deactivating pad from %s mode&quot;,
1179         gst_pad_mode_get_name (old));
1180 
1181     if (G_UNLIKELY (!activate_mode_internal (pad, parent, old, FALSE)))
1182       goto deactivate_failed;
1183     old = GST_PAD_MODE_NONE;
1184   }
1185 
1186   switch (mode) {
1187     case GST_PAD_MODE_PULL:
1188     {
1189       if (dir == GST_PAD_SINK) {
1190         if ((peer = gst_pad_get_peer (pad))) {
1191           GST_DEBUG_OBJECT (pad, &quot;calling peer&quot;);
1192           if (G_UNLIKELY (!gst_pad_activate_mode (peer, mode, active)))
1193             goto peer_failed;
1194           gst_object_unref (peer);
1195         } else {
1196           /* there is no peer, this is only fatal when we activate. When we
1197            * deactivate, we must assume the application has unlinked the peer and
1198            * will deactivate it eventually. */
1199           if (active)
1200             goto not_linked;
1201           else
1202             GST_DEBUG_OBJECT (pad, &quot;deactivating unlinked pad&quot;);
1203         }
1204       } else {
1205         if (G_UNLIKELY (GST_PAD_GETRANGEFUNC (pad) == NULL))
1206           goto failure;         /* Can&#39;t activate pull on a src without a
1207                                    getrange function */
1208       }
1209       break;
1210     }
1211     default:
1212       break;
1213   }
1214 
1215   /* Mark pad as needing reconfiguration */
1216   if (active)
1217     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
1218 
1219   /* pre_activate returns TRUE if we weren&#39;t already in the process of
1220    * switching to the &#39;new&#39; mode */
1221   if (pre_activate (pad, new)) {
1222 
<a name="21" id="anc21"></a><span class="line-modified">1223   if (GST_PAD_ACTIVATEMODEFUNC (pad)) {</span>
<span class="line-modified">1224     if (G_UNLIKELY (!GST_PAD_ACTIVATEMODEFUNC (pad) (pad, parent, mode,</span>
<span class="line-modified">1225                 active)))</span>
<span class="line-modified">1226       goto failure;</span>
<span class="line-modified">1227   } else {</span>
<span class="line-modified">1228     /* can happen for sinks of passthrough elements */</span>
<span class="line-modified">1229   }</span>
1230 
<a name="22" id="anc22"></a><span class="line-modified">1231   post_activate (pad, new);</span>
1232   }
1233 
1234   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;%s in %s mode&quot;,
1235       active ? &quot;activated&quot; : &quot;deactivated&quot;, gst_pad_mode_get_name (mode));
1236 
1237 exit_success:
1238   res = TRUE;
1239 
1240   /* Clear sticky flags on deactivation */
1241   if (!active) {
1242     GST_OBJECT_LOCK (pad);
1243     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
1244     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_EOS);
1245     GST_OBJECT_UNLOCK (pad);
1246   }
1247 
1248 exit:
1249   return res;
1250 
1251 was_ok:
1252   {
1253     GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;already %s in %s mode&quot;,
1254         active ? &quot;activated&quot; : &quot;deactivated&quot;, gst_pad_mode_get_name (mode));
1255     goto exit_success;
1256   }
1257 deactivate_failed:
1258   {
1259     GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad,
1260         &quot;failed to %s in switch to %s mode from %s mode&quot;,
1261         (active ? &quot;activate&quot; : &quot;deactivate&quot;), gst_pad_mode_get_name (mode),
1262         gst_pad_mode_get_name (old));
1263     goto exit;
1264   }
1265 peer_failed:
1266   {
1267     GST_OBJECT_LOCK (peer);
1268     GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad,
1269         &quot;activate_mode on peer (%s:%s) failed&quot;, GST_DEBUG_PAD_NAME (peer));
1270     GST_OBJECT_UNLOCK (peer);
1271     gst_object_unref (peer);
1272     goto exit;
1273   }
1274 not_linked:
1275   {
1276     GST_CAT_INFO_OBJECT (GST_CAT_PADS, pad, &quot;can&#39;t activate unlinked sink &quot;
1277         &quot;pad in pull mode&quot;);
1278     goto exit;
1279   }
1280 failure:
1281   {
1282     GST_OBJECT_LOCK (pad);
1283     GST_CAT_INFO_OBJECT (GST_CAT_PADS, pad, &quot;failed to %s in %s mode&quot;,
1284         active ? &quot;activate&quot; : &quot;deactivate&quot;, gst_pad_mode_get_name (mode));
1285     GST_PAD_SET_FLUSHING (pad);
1286     GST_PAD_MODE (pad) = old;
1287     pad-&gt;priv-&gt;in_activation = FALSE;
1288     g_cond_broadcast (&amp;pad-&gt;priv-&gt;activation_cond);
1289     GST_OBJECT_UNLOCK (pad);
1290     goto exit;
1291   }
1292 }
1293 
1294 /**
1295  * gst_pad_activate_mode:
1296  * @pad: the #GstPad to activate or deactivate.
1297  * @mode: the requested activation mode
1298  * @active: whether or not the pad should be active.
1299  *
1300  * Activates or deactivates the given pad in @mode via dispatching to the
1301  * pad&#39;s activatemodefunc. For use from within pad activation functions only.
1302  *
1303  * If you don&#39;t know what this is, you probably don&#39;t want to call it.
1304  *
1305  * Returns: %TRUE if the operation was successful.
1306  *
1307  * MT safe.
1308  */
1309 gboolean
1310 gst_pad_activate_mode (GstPad * pad, GstPadMode mode, gboolean active)
1311 {
1312   GstObject *parent;
1313   gboolean res;
1314   GstPadMode old, new;
1315 
1316   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
1317 
1318   GST_OBJECT_LOCK (pad);
1319 
1320   old = GST_PAD_MODE (pad);
1321   new = active ? mode : GST_PAD_MODE_NONE;
1322   if (old == new)
1323     goto was_ok;
1324 
1325   ACQUIRE_PARENT (pad, parent, no_parent);
1326 
1327   GST_OBJECT_UNLOCK (pad);
1328 
1329   res = activate_mode_internal (pad, parent, mode, active);
1330 
1331   RELEASE_PARENT (parent);
1332 
1333   return res;
1334 
1335 was_ok:
1336   {
1337     GST_OBJECT_UNLOCK (pad);
1338     GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;already %s in %s mode&quot;,
1339         active ? &quot;activated&quot; : &quot;deactivated&quot;, gst_pad_mode_get_name (mode));
1340     return TRUE;
1341   }
1342 no_parent:
1343   {
1344     GST_WARNING_OBJECT (pad, &quot;no parent&quot;);
1345     GST_OBJECT_UNLOCK (pad);
1346     return FALSE;
1347   }
1348 }
1349 
1350 /**
1351  * gst_pad_is_active:
1352  * @pad: the #GstPad to query
1353  *
1354  * Query if a pad is active
1355  *
1356  * Returns: %TRUE if the pad is active.
1357  *
1358  * MT safe.
1359  */
1360 gboolean
1361 gst_pad_is_active (GstPad * pad)
1362 {
1363   gboolean result = FALSE;
1364 
1365   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
1366 
1367   GST_OBJECT_LOCK (pad);
1368   result = GST_PAD_IS_ACTIVE (pad);
1369   GST_OBJECT_UNLOCK (pad);
1370 
1371   return result;
1372 }
1373 
1374 static void
1375 cleanup_hook (GstPad * pad, GHook * hook)
1376 {
1377   GstPadProbeType type;
1378 
<a name="23" id="anc23"></a>


1379   if (!G_HOOK_IS_VALID (hook))
1380     return;
1381 
1382   type = (hook-&gt;flags) &gt;&gt; G_HOOK_FLAG_USER_SHIFT;
1383 
1384   if (type &amp; GST_PAD_PROBE_TYPE_BLOCKING) {
1385     /* unblock when we remove the last blocking probe */
1386     pad-&gt;num_blocked--;
1387     GST_DEBUG_OBJECT (pad, &quot;remove blocking probe, now %d left&quot;,
1388         pad-&gt;num_blocked);
1389 
1390     /* Might have new probes now that want to be called */
1391     GST_PAD_BLOCK_BROADCAST (pad);
1392 
1393     if (pad-&gt;num_blocked == 0) {
1394       GST_DEBUG_OBJECT (pad, &quot;last blocking probe removed, unblocking&quot;);
1395       GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_BLOCKED);
1396     }
1397   }
1398   g_hook_destroy_link (&amp;pad-&gt;probes, hook);
1399   pad-&gt;num_probes--;
1400 }
1401 
1402 /**
1403  * gst_pad_add_probe:
1404  * @pad: the #GstPad to add the probe to
1405  * @mask: the probe mask
1406  * @callback: #GstPadProbeCallback that will be called with notifications of
1407  *           the pad state
1408  * @user_data: (closure): user data passed to the callback
1409  * @destroy_data: #GDestroyNotify for user_data
1410  *
1411  * Be notified of different states of pads. The provided callback is called for
1412  * every state that matches @mask.
1413  *
1414  * Probes are called in groups: First GST_PAD_PROBE_TYPE_BLOCK probes are
1415  * called, then others, then finally GST_PAD_PROBE_TYPE_IDLE. The only
1416  * exception here are GST_PAD_PROBE_TYPE_IDLE probes that are called
1417  * immediately if the pad is already idle while calling gst_pad_add_probe().
1418  * In each of the groups, probes are called in the order in which they were
1419  * added.
1420  *
1421  * Returns: an id or 0 if no probe is pending. The id can be used to remove the
1422  * probe with gst_pad_remove_probe(). When using GST_PAD_PROBE_TYPE_IDLE it can
1423  * happen that the probe can be run immediately and if the probe returns
1424  * GST_PAD_PROBE_REMOVE this functions returns 0.
1425  *
1426  * MT safe.
1427  */
1428 gulong
1429 gst_pad_add_probe (GstPad * pad, GstPadProbeType mask,
1430     GstPadProbeCallback callback, gpointer user_data,
1431     GDestroyNotify destroy_data)
1432 {
1433   GHook *hook;
1434   gulong res;
1435 
1436   g_return_val_if_fail (GST_IS_PAD (pad), 0);
1437   g_return_val_if_fail (mask != 0, 0);
1438 
1439   GST_OBJECT_LOCK (pad);
1440 
1441   /* make a new probe */
1442   hook = g_hook_alloc (&amp;pad-&gt;probes);
1443 
1444   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;adding probe for mask 0x%08x&quot;,
1445       mask);
1446 
<a name="24" id="anc24"></a><span class="line-modified">1447   /* when no contraints are given for the types, assume all types are</span>
1448    * acceptable */
1449   if ((mask &amp; _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH) == 0)
1450     mask |= GST_PAD_PROBE_TYPE_ALL_BOTH;
1451   if ((mask &amp; GST_PAD_PROBE_TYPE_SCHEDULING) == 0)
1452     mask |= GST_PAD_PROBE_TYPE_SCHEDULING;
1453 
1454   /* store our flags and other fields */
1455   hook-&gt;flags |= (mask &lt;&lt; G_HOOK_FLAG_USER_SHIFT);
1456   hook-&gt;func = callback;
1457   hook-&gt;data = user_data;
1458   hook-&gt;destroy = destroy_data;
1459 
1460   /* add the probe */
1461   g_hook_append (&amp;pad-&gt;probes, hook);
1462   pad-&gt;num_probes++;
<a name="25" id="anc25"></a><span class="line-modified">1463   /* incremenent cookie so that the new hook get&#39;s called */</span>
1464   pad-&gt;priv-&gt;probe_list_cookie++;
1465 
1466   /* get the id of the hook, we return this and it can be used to remove the
1467    * probe later */
1468   res = hook-&gt;hook_id;
1469 
1470   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;got probe id %lu&quot;, res);
1471 
1472   if (mask &amp; GST_PAD_PROBE_TYPE_BLOCKING) {
1473     /* we have a block probe */
1474     pad-&gt;num_blocked++;
1475     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_BLOCKED);
1476     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;added blocking probe, &quot;
1477         &quot;now %d blocking probes&quot;, pad-&gt;num_blocked);
1478 
1479     /* Might have new probes now that want to be called */
1480     GST_PAD_BLOCK_BROADCAST (pad);
1481   }
1482 
1483   /* call the callback if we need to be called for idle callbacks */
1484   if ((mask &amp; GST_PAD_PROBE_TYPE_IDLE) &amp;&amp; (callback != NULL)) {
1485     if (pad-&gt;priv-&gt;using &gt; 0) {
1486       /* the pad is in use, we can&#39;t signal the idle callback yet. Since we set the
1487        * flag above, the last thread to leave the push will do the callback. New
1488        * threads going into the push will block. */
1489       GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
1490           &quot;pad is in use, delay idle callback&quot;);
1491       GST_OBJECT_UNLOCK (pad);
1492     } else {
1493       GstPadProbeInfo info = { GST_PAD_PROBE_TYPE_IDLE, res, };
1494       GstPadProbeReturn ret;
1495 
1496       /* Keep another ref, the callback could destroy the pad */
1497       gst_object_ref (pad);
1498       pad-&gt;priv-&gt;idle_running++;
1499 
1500       /* the pad is idle now, we can signal the idle callback now */
1501       GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
1502           &quot;pad is idle, trigger idle callback&quot;);
1503       GST_OBJECT_UNLOCK (pad);
1504 
1505       ret = callback (pad, &amp;info, user_data);
1506 
1507       GST_OBJECT_LOCK (pad);
1508       switch (ret) {
1509         case GST_PAD_PROBE_REMOVE:
1510           /* remove the probe */
1511           GST_DEBUG_OBJECT (pad, &quot;asked to remove hook&quot;);
1512           cleanup_hook (pad, hook);
1513           res = 0;
1514           break;
1515         case GST_PAD_PROBE_DROP:
1516           GST_DEBUG_OBJECT (pad, &quot;asked to drop item&quot;);
1517           break;
1518         case GST_PAD_PROBE_PASS:
1519           GST_DEBUG_OBJECT (pad, &quot;asked to pass item&quot;);
1520           break;
1521         case GST_PAD_PROBE_OK:
1522           GST_DEBUG_OBJECT (pad, &quot;probe returned OK&quot;);
1523           break;
1524         case GST_PAD_PROBE_HANDLED:
1525           GST_DEBUG_OBJECT (pad, &quot;probe handled the data&quot;);
1526           break;
1527         default:
1528           GST_DEBUG_OBJECT (pad, &quot;probe returned %d&quot;, ret);
1529           break;
1530       }
1531       pad-&gt;priv-&gt;idle_running--;
1532       if (pad-&gt;priv-&gt;idle_running == 0) {
1533         GST_PAD_BLOCK_BROADCAST (pad);
1534       }
1535       GST_OBJECT_UNLOCK (pad);
1536 
1537       gst_object_unref (pad);
1538     }
1539   } else {
1540     GST_OBJECT_UNLOCK (pad);
1541   }
1542   return res;
1543 }
1544 
1545 /**
1546  * gst_pad_remove_probe:
1547  * @pad: the #GstPad with the probe
1548  * @id: the probe id to remove
1549  *
1550  * Remove the probe with @id from @pad.
1551  *
1552  * MT safe.
1553  */
1554 void
1555 gst_pad_remove_probe (GstPad * pad, gulong id)
1556 {
1557   GHook *hook;
1558 
1559   g_return_if_fail (GST_IS_PAD (pad));
1560 
1561   GST_OBJECT_LOCK (pad);
1562 
1563   hook = g_hook_get (&amp;pad-&gt;probes, id);
1564   if (hook == NULL)
1565     goto not_found;
1566 
1567   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;removing hook %ld&quot;,
1568       hook-&gt;hook_id);
1569   cleanup_hook (pad, hook);
1570   GST_OBJECT_UNLOCK (pad);
1571 
1572   return;
1573 
1574 not_found:
1575   {
1576     GST_OBJECT_UNLOCK (pad);
1577     g_warning (&quot;%s: pad `%p&#39; has no probe with id `%lu&#39;&quot;, G_STRLOC, pad, id);
1578     return;
1579   }
1580 }
1581 
1582 /**
1583  * gst_pad_is_blocked:
1584  * @pad: the #GstPad to query
1585  *
1586  * Checks if the pad is blocked or not. This function returns the
1587  * last requested state of the pad. It is not certain that the pad
1588  * is actually blocking at this point (see gst_pad_is_blocking()).
1589  *
1590  * Returns: %TRUE if the pad is blocked.
1591  *
1592  * MT safe.
1593  */
1594 gboolean
1595 gst_pad_is_blocked (GstPad * pad)
1596 {
1597   gboolean result = FALSE;
1598 
1599   g_return_val_if_fail (GST_IS_PAD (pad), result);
1600 
1601   GST_OBJECT_LOCK (pad);
1602   result = GST_OBJECT_FLAG_IS_SET (pad, GST_PAD_FLAG_BLOCKED);
1603   GST_OBJECT_UNLOCK (pad);
1604 
1605   return result;
1606 }
1607 
1608 /**
1609  * gst_pad_is_blocking:
1610  * @pad: the #GstPad to query
1611  *
1612  * Checks if the pad is blocking or not. This is a guaranteed state
1613  * of whether the pad is actually blocking on a #GstBuffer or a #GstEvent.
1614  *
1615  * Returns: %TRUE if the pad is blocking.
1616  *
1617  * MT safe.
1618  */
1619 gboolean
1620 gst_pad_is_blocking (GstPad * pad)
1621 {
1622   gboolean result = FALSE;
1623 
1624   g_return_val_if_fail (GST_IS_PAD (pad), result);
1625 
1626   GST_OBJECT_LOCK (pad);
1627   /* the blocking flag is only valid if the pad is not flushing */
1628   result = GST_PAD_IS_BLOCKING (pad) &amp;&amp; !GST_PAD_IS_FLUSHING (pad);
1629   GST_OBJECT_UNLOCK (pad);
1630 
1631   return result;
1632 }
1633 
1634 /**
1635  * gst_pad_needs_reconfigure:
1636  * @pad: the #GstPad to check
1637  *
1638  * Check the #GST_PAD_FLAG_NEED_RECONFIGURE flag on @pad and return %TRUE
1639  * if the flag was set.
1640  *
1641  * Returns: %TRUE is the GST_PAD_FLAG_NEED_RECONFIGURE flag is set on @pad.
1642  */
1643 gboolean
1644 gst_pad_needs_reconfigure (GstPad * pad)
1645 {
1646   gboolean reconfigure;
1647 
1648   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
1649 
1650   GST_OBJECT_LOCK (pad);
1651   reconfigure = GST_PAD_NEEDS_RECONFIGURE (pad);
1652   GST_DEBUG_OBJECT (pad, &quot;peeking RECONFIGURE flag %d&quot;, reconfigure);
1653   GST_OBJECT_UNLOCK (pad);
1654 
1655   return reconfigure;
1656 }
1657 
1658 /**
1659  * gst_pad_check_reconfigure:
1660  * @pad: the #GstPad to check
1661  *
1662  * Check and clear the #GST_PAD_FLAG_NEED_RECONFIGURE flag on @pad and return %TRUE
1663  * if the flag was set.
1664  *
1665  * Returns: %TRUE is the GST_PAD_FLAG_NEED_RECONFIGURE flag was set on @pad.
1666  */
1667 gboolean
1668 gst_pad_check_reconfigure (GstPad * pad)
1669 {
1670   gboolean reconfigure;
1671 
1672   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
1673 
1674   GST_OBJECT_LOCK (pad);
1675   reconfigure = GST_PAD_NEEDS_RECONFIGURE (pad);
1676   if (reconfigure) {
1677     GST_DEBUG_OBJECT (pad, &quot;remove RECONFIGURE flag&quot;);
1678     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
1679   }
1680   GST_OBJECT_UNLOCK (pad);
1681 
1682   return reconfigure;
1683 }
1684 
1685 /**
1686  * gst_pad_mark_reconfigure:
1687  * @pad: the #GstPad to mark
1688  *
1689  * Mark a pad for needing reconfiguration. The next call to
1690  * gst_pad_check_reconfigure() will return %TRUE after this call.
1691  */
1692 void
1693 gst_pad_mark_reconfigure (GstPad * pad)
1694 {
1695   g_return_if_fail (GST_IS_PAD (pad));
1696 
1697   GST_OBJECT_LOCK (pad);
1698   GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
1699   GST_OBJECT_UNLOCK (pad);
1700 }
1701 
1702 /**
1703  * gst_pad_set_activate_function:
1704  * @p: a #GstPad.
1705  * @f: the #GstPadActivateFunction to set.
1706  *
1707  * Calls gst_pad_set_activate_function_full() with %NULL for the user_data and
1708  * notify.
1709  */
1710 /**
1711  * gst_pad_set_activate_function_full:
1712  * @pad: a #GstPad.
1713  * @activate: the #GstPadActivateFunction to set.
1714  * @user_data: user_data passed to @notify
1715  * @notify: notify called when @activate will not be used anymore.
1716  *
1717  * Sets the given activate function for @pad. The activate function will
1718  * dispatch to gst_pad_activate_mode() to perform the actual activation.
1719  * Only makes sense to set on sink pads.
1720  *
1721  * Call this function if your sink pad can start a pull-based task.
1722  */
1723 void
1724 gst_pad_set_activate_function_full (GstPad * pad,
1725     GstPadActivateFunction activate, gpointer user_data, GDestroyNotify notify)
1726 {
1727   g_return_if_fail (GST_IS_PAD (pad));
1728 
1729   if (pad-&gt;activatenotify)
1730     pad-&gt;activatenotify (pad-&gt;activatedata);
1731   GST_PAD_ACTIVATEFUNC (pad) = activate;
1732   pad-&gt;activatedata = user_data;
1733   pad-&gt;activatenotify = notify;
1734 
1735   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;activatefunc set to %s&quot;,
1736       GST_DEBUG_FUNCPTR_NAME (activate));
1737 }
1738 
1739 /**
1740  * gst_pad_set_activatemode_function:
1741  * @p: a #GstPad.
1742  * @f: the #GstPadActivateModeFunction to set.
1743  *
1744  * Calls gst_pad_set_activatemode_function_full() with %NULL for the user_data and
1745  * notify.
1746  */
1747 /**
1748  * gst_pad_set_activatemode_function_full:
1749  * @pad: a #GstPad.
1750  * @activatemode: the #GstPadActivateModeFunction to set.
1751  * @user_data: user_data passed to @notify
1752  * @notify: notify called when @activatemode will not be used anymore.
1753  *
1754  * Sets the given activate_mode function for the pad. An activate_mode function
1755  * prepares the element for data passing.
1756  */
1757 void
1758 gst_pad_set_activatemode_function_full (GstPad * pad,
1759     GstPadActivateModeFunction activatemode, gpointer user_data,
1760     GDestroyNotify notify)
1761 {
1762   g_return_if_fail (GST_IS_PAD (pad));
1763 
1764   if (pad-&gt;activatemodenotify)
1765     pad-&gt;activatemodenotify (pad-&gt;activatemodedata);
1766   GST_PAD_ACTIVATEMODEFUNC (pad) = activatemode;
1767   pad-&gt;activatemodedata = user_data;
1768   pad-&gt;activatemodenotify = notify;
1769 
1770   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;activatemodefunc set to %s&quot;,
1771       GST_DEBUG_FUNCPTR_NAME (activatemode));
1772 }
1773 
1774 /**
1775  * gst_pad_set_chain_function:
1776  * @p: a sink #GstPad.
1777  * @f: the #GstPadChainFunction to set.
1778  *
1779  * Calls gst_pad_set_chain_function_full() with %NULL for the user_data and
1780  * notify.
1781  */
1782 /**
1783  * gst_pad_set_chain_function_full:
1784  * @pad: a sink #GstPad.
1785  * @chain: the #GstPadChainFunction to set.
1786  * @user_data: user_data passed to @notify
1787  * @notify: notify called when @chain will not be used anymore.
1788  *
1789  * Sets the given chain function for the pad. The chain function is called to
1790  * process a #GstBuffer input buffer. see #GstPadChainFunction for more details.
1791  */
1792 void
1793 gst_pad_set_chain_function_full (GstPad * pad, GstPadChainFunction chain,
1794     gpointer user_data, GDestroyNotify notify)
1795 {
1796   g_return_if_fail (GST_IS_PAD (pad));
1797   g_return_if_fail (GST_PAD_IS_SINK (pad));
1798 
1799   if (pad-&gt;chainnotify)
1800     pad-&gt;chainnotify (pad-&gt;chaindata);
1801   GST_PAD_CHAINFUNC (pad) = chain;
1802   pad-&gt;chaindata = user_data;
1803   pad-&gt;chainnotify = notify;
1804 
1805   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;chainfunc set to %s&quot;,
1806       GST_DEBUG_FUNCPTR_NAME (chain));
1807 }
1808 
1809 /**
1810  * gst_pad_set_chain_list_function:
1811  * @p: a sink #GstPad.
1812  * @f: the #GstPadChainListFunction to set.
1813  *
1814  * Calls gst_pad_set_chain_list_function_full() with %NULL for the user_data and
1815  * notify.
1816  */
1817 /**
1818  * gst_pad_set_chain_list_function_full:
1819  * @pad: a sink #GstPad.
1820  * @chainlist: the #GstPadChainListFunction to set.
1821  * @user_data: user_data passed to @notify
1822  * @notify: notify called when @chainlist will not be used anymore.
1823  *
1824  * Sets the given chain list function for the pad. The chainlist function is
1825  * called to process a #GstBufferList input buffer list. See
1826  * #GstPadChainListFunction for more details.
1827  */
1828 void
1829 gst_pad_set_chain_list_function_full (GstPad * pad,
1830     GstPadChainListFunction chainlist, gpointer user_data,
1831     GDestroyNotify notify)
1832 {
1833   g_return_if_fail (GST_IS_PAD (pad));
1834   g_return_if_fail (GST_PAD_IS_SINK (pad));
1835 
1836   if (pad-&gt;chainlistnotify)
1837     pad-&gt;chainlistnotify (pad-&gt;chainlistdata);
1838   GST_PAD_CHAINLISTFUNC (pad) = chainlist;
1839   pad-&gt;chainlistdata = user_data;
1840   pad-&gt;chainlistnotify = notify;
1841 
1842   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;chainlistfunc set to %s&quot;,
1843       GST_DEBUG_FUNCPTR_NAME (chainlist));
1844 }
1845 
1846 /**
1847  * gst_pad_set_getrange_function:
1848  * @p: a source #GstPad.
1849  * @f: the #GstPadGetRangeFunction to set.
1850  *
1851  * Calls gst_pad_set_getrange_function_full() with %NULL for the user_data and
1852  * notify.
1853  */
1854 /**
1855  * gst_pad_set_getrange_function_full:
1856  * @pad: a source #GstPad.
1857  * @get: the #GstPadGetRangeFunction to set.
1858  * @user_data: user_data passed to @notify
1859  * @notify: notify called when @get will not be used anymore.
1860  *
1861  * Sets the given getrange function for the pad. The getrange function is
1862  * called to produce a new #GstBuffer to start the processing pipeline. see
1863  * #GstPadGetRangeFunction for a description of the getrange function.
1864  */
1865 void
1866 gst_pad_set_getrange_function_full (GstPad * pad, GstPadGetRangeFunction get,
1867     gpointer user_data, GDestroyNotify notify)
1868 {
1869   g_return_if_fail (GST_IS_PAD (pad));
1870   g_return_if_fail (GST_PAD_IS_SRC (pad));
1871 
1872   if (pad-&gt;getrangenotify)
1873     pad-&gt;getrangenotify (pad-&gt;getrangedata);
1874   GST_PAD_GETRANGEFUNC (pad) = get;
1875   pad-&gt;getrangedata = user_data;
1876   pad-&gt;getrangenotify = notify;
1877 
1878   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;getrangefunc set to %s&quot;,
1879       GST_DEBUG_FUNCPTR_NAME (get));
1880 }
1881 
1882 /**
1883  * gst_pad_set_event_function:
1884  * @p: a #GstPad of either direction.
1885  * @f: the #GstPadEventFunction to set.
1886  *
1887  * Calls gst_pad_set_event_function_full() with %NULL for the user_data and
1888  * notify.
1889  */
1890 /**
1891  * gst_pad_set_event_function_full:
1892  * @pad: a #GstPad of either direction.
1893  * @event: the #GstPadEventFunction to set.
1894  * @user_data: user_data passed to @notify
1895  * @notify: notify called when @event will not be used anymore.
1896  *
1897  * Sets the given event handler for the pad.
1898  */
1899 void
1900 gst_pad_set_event_function_full (GstPad * pad, GstPadEventFunction event,
1901     gpointer user_data, GDestroyNotify notify)
1902 {
1903   g_return_if_fail (GST_IS_PAD (pad));
1904 
1905   if (pad-&gt;eventnotify)
1906     pad-&gt;eventnotify (pad-&gt;eventdata);
1907   GST_PAD_EVENTFUNC (pad) = event;
1908   pad-&gt;eventdata = user_data;
1909   pad-&gt;eventnotify = notify;
1910 
1911   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;eventfunc for set to %s&quot;,
1912       GST_DEBUG_FUNCPTR_NAME (event));
1913 }
1914 
1915 static gboolean
1916 event_wrap (GstPad * pad, GstObject * object, GstEvent * event)
1917 {
1918   GstFlowReturn ret;
1919 
1920   ret = GST_PAD_EVENTFULLFUNC (pad) (pad, object, event);
1921   if (ret == GST_FLOW_OK)
1922     return TRUE;
1923   return FALSE;
1924 }
1925 
1926 /**
1927  * gst_pad_set_event_full_function:
1928  * @p: a #GstPad of either direction.
1929  * @f: the #GstPadEventFullFunction to set.
1930  *
1931  * Calls gst_pad_set_event_full_function_full() with %NULL for the user_data and
1932  * notify.
1933  */
1934 /**
1935  * gst_pad_set_event_full_function_full:
1936  * @pad: a #GstPad of either direction.
1937  * @event: the #GstPadEventFullFunction to set.
1938  * @user_data: user_data passed to @notify
1939  * @notify: notify called when @event will not be used anymore.
1940  *
1941  * Sets the given event handler for the pad.
1942  *
1943  * Since: 1.8
1944  */
1945 void
1946 gst_pad_set_event_full_function_full (GstPad * pad,
1947     GstPadEventFullFunction event, gpointer user_data, GDestroyNotify notify)
1948 {
1949   g_return_if_fail (GST_IS_PAD (pad));
1950 
1951   if (pad-&gt;eventnotify)
1952     pad-&gt;eventnotify (pad-&gt;eventdata);
1953   GST_PAD_EVENTFULLFUNC (pad) = event;
1954   GST_PAD_EVENTFUNC (pad) = event_wrap;
1955   pad-&gt;eventdata = user_data;
1956   pad-&gt;eventnotify = notify;
1957 
1958   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;eventfullfunc for set to %s&quot;,
1959       GST_DEBUG_FUNCPTR_NAME (event));
1960 }
1961 
1962 /**
1963  * gst_pad_set_query_function:
1964  * @p: a #GstPad of either direction.
1965  * @f: the #GstPadQueryFunction to set.
1966  *
1967  * Calls gst_pad_set_query_function_full() with %NULL for the user_data and
1968  * notify.
1969  */
1970 /**
1971  * gst_pad_set_query_function_full:
1972  * @pad: a #GstPad of either direction.
1973  * @query: the #GstPadQueryFunction to set.
1974  * @user_data: user_data passed to @notify
1975  * @notify: notify called when @query will not be used anymore.
1976  *
1977  * Set the given query function for the pad.
1978  */
1979 void
1980 gst_pad_set_query_function_full (GstPad * pad, GstPadQueryFunction query,
1981     gpointer user_data, GDestroyNotify notify)
1982 {
1983   g_return_if_fail (GST_IS_PAD (pad));
1984 
1985   if (pad-&gt;querynotify)
1986     pad-&gt;querynotify (pad-&gt;querydata);
1987   GST_PAD_QUERYFUNC (pad) = query;
1988   pad-&gt;querydata = user_data;
1989   pad-&gt;querynotify = notify;
1990 
1991   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;queryfunc set to %s&quot;,
1992       GST_DEBUG_FUNCPTR_NAME (query));
1993 }
1994 
1995 /**
1996  * gst_pad_set_iterate_internal_links_function:
1997  * @p: a #GstPad of either direction.
1998  * @f: the #GstPadIterIntLinkFunction to set.
1999  *
2000  * Calls gst_pad_set_iterate_internal_links_function_full() with %NULL
2001  * for the user_data and notify.
2002  */
2003 /**
2004  * gst_pad_set_iterate_internal_links_function_full:
2005  * @pad: a #GstPad of either direction.
2006  * @iterintlink: the #GstPadIterIntLinkFunction to set.
2007  * @user_data: user_data passed to @notify
2008  * @notify: notify called when @iterintlink will not be used anymore.
2009  *
2010  * Sets the given internal link iterator function for the pad.
2011  */
2012 void
2013 gst_pad_set_iterate_internal_links_function_full (GstPad * pad,
2014     GstPadIterIntLinkFunction iterintlink, gpointer user_data,
2015     GDestroyNotify notify)
2016 {
2017   g_return_if_fail (GST_IS_PAD (pad));
2018 
2019   if (pad-&gt;iterintlinknotify)
2020     pad-&gt;iterintlinknotify (pad-&gt;iterintlinkdata);
2021   GST_PAD_ITERINTLINKFUNC (pad) = iterintlink;
2022   pad-&gt;iterintlinkdata = user_data;
2023   pad-&gt;iterintlinknotify = notify;
2024 
2025   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;internal link iterator set to %s&quot;,
2026       GST_DEBUG_FUNCPTR_NAME (iterintlink));
2027 }
2028 
2029 /**
2030  * gst_pad_set_link_function:
2031  * @p: a #GstPad.
2032  * @f: the #GstPadLinkFunction to set.
2033  *
2034  * Calls gst_pad_set_link_function_full() with %NULL
2035  * for the user_data and notify.
2036  */
2037 /**
2038  * gst_pad_set_link_function_full:
2039  * @pad: a #GstPad.
2040  * @link: the #GstPadLinkFunction to set.
2041  * @user_data: user_data passed to @notify
2042  * @notify: notify called when @link will not be used anymore.
2043  *
2044  * Sets the given link function for the pad. It will be called when
2045  * the pad is linked with another pad.
2046  *
2047  * The return value #GST_PAD_LINK_OK should be used when the connection can be
2048  * made.
2049  *
2050  * The return value #GST_PAD_LINK_REFUSED should be used when the connection
2051  * cannot be made for some reason.
2052  *
2053  * If @link is installed on a source pad, it should call the #GstPadLinkFunction
2054  * of the peer sink pad, if present.
2055  */
2056 void
2057 gst_pad_set_link_function_full (GstPad * pad, GstPadLinkFunction link,
2058     gpointer user_data, GDestroyNotify notify)
2059 {
2060   g_return_if_fail (GST_IS_PAD (pad));
2061 
2062   if (pad-&gt;linknotify)
2063     pad-&gt;linknotify (pad-&gt;linkdata);
2064   GST_PAD_LINKFUNC (pad) = link;
2065   pad-&gt;linkdata = user_data;
2066   pad-&gt;linknotify = notify;
2067 
2068   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;linkfunc set to %s&quot;,
2069       GST_DEBUG_FUNCPTR_NAME (link));
2070 }
2071 
2072 /**
2073  * gst_pad_set_unlink_function:
2074  * @p: a #GstPad.
2075  * @f: the #GstPadUnlinkFunction to set.
2076  *
2077  * Calls gst_pad_set_unlink_function_full() with %NULL
2078  * for the user_data and notify.
2079  */
2080 /**
2081  * gst_pad_set_unlink_function_full:
2082  * @pad: a #GstPad.
2083  * @unlink: the #GstPadUnlinkFunction to set.
2084  * @user_data: user_data passed to @notify
2085  * @notify: notify called when @unlink will not be used anymore.
2086  *
2087  * Sets the given unlink function for the pad. It will be called
2088  * when the pad is unlinked.
<a name="26" id="anc26"></a>



2089  */
2090 void
2091 gst_pad_set_unlink_function_full (GstPad * pad, GstPadUnlinkFunction unlink,
2092     gpointer user_data, GDestroyNotify notify)
2093 {
2094   g_return_if_fail (GST_IS_PAD (pad));
2095 
2096   if (pad-&gt;unlinknotify)
2097     pad-&gt;unlinknotify (pad-&gt;unlinkdata);
2098   GST_PAD_UNLINKFUNC (pad) = unlink;
2099   pad-&gt;unlinkdata = user_data;
2100   pad-&gt;unlinknotify = notify;
2101 
2102   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;unlinkfunc set to %s&quot;,
2103       GST_DEBUG_FUNCPTR_NAME (unlink));
2104 }
2105 
2106 /**
2107  * gst_pad_unlink:
2108  * @srcpad: the source #GstPad to unlink.
2109  * @sinkpad: the sink #GstPad to unlink.
2110  *
2111  * Unlinks the source pad from the sink pad. Will emit the #GstPad::unlinked
2112  * signal on both pads.
2113  *
2114  * Returns: %TRUE if the pads were unlinked. This function returns %FALSE if
2115  * the pads were not linked together.
2116  *
2117  * MT safe.
2118  */
2119 gboolean
2120 gst_pad_unlink (GstPad * srcpad, GstPad * sinkpad)
2121 {
2122   gboolean result = FALSE;
2123   GstElement *parent = NULL;
2124 
2125   g_return_val_if_fail (GST_IS_PAD (srcpad), FALSE);
2126   g_return_val_if_fail (GST_PAD_IS_SRC (srcpad), FALSE);
2127   g_return_val_if_fail (GST_IS_PAD (sinkpad), FALSE);
2128   g_return_val_if_fail (GST_PAD_IS_SINK (sinkpad), FALSE);
2129 
2130   GST_TRACER_PAD_UNLINK_PRE (srcpad, sinkpad);
2131 
2132   GST_CAT_INFO (GST_CAT_ELEMENT_PADS, &quot;unlinking %s:%s(%p) and %s:%s(%p)&quot;,
2133       GST_DEBUG_PAD_NAME (srcpad), srcpad,
2134       GST_DEBUG_PAD_NAME (sinkpad), sinkpad);
2135 
2136   /* We need to notify the parent before taking any pad locks as the bin in
2137    * question might be waiting for a lock on the pad while holding its lock
2138    * that our message will try to take. */
2139   if ((parent = GST_ELEMENT_CAST (gst_pad_get_parent (srcpad)))) {
2140     if (GST_IS_ELEMENT (parent)) {
2141       gst_element_post_message (parent,
2142           gst_message_new_structure_change (GST_OBJECT_CAST (sinkpad),
2143               GST_STRUCTURE_CHANGE_TYPE_PAD_UNLINK, parent, TRUE));
2144     } else {
2145       gst_object_unref (parent);
2146       parent = NULL;
2147     }
2148   }
2149 
2150   GST_OBJECT_LOCK (srcpad);
2151   GST_OBJECT_LOCK (sinkpad);
2152 
2153   if (G_UNLIKELY (GST_PAD_PEER (srcpad) != sinkpad))
2154     goto not_linked_together;
2155 
2156   if (GST_PAD_UNLINKFUNC (srcpad)) {
2157     GstObject *tmpparent;
2158 
2159     ACQUIRE_PARENT (srcpad, tmpparent, no_src_parent);
2160 
2161     GST_PAD_UNLINKFUNC (srcpad) (srcpad, tmpparent);
2162     RELEASE_PARENT (tmpparent);
2163   }
2164 no_src_parent:
2165   if (GST_PAD_UNLINKFUNC (sinkpad)) {
2166     GstObject *tmpparent;
2167 
2168     ACQUIRE_PARENT (sinkpad, tmpparent, no_sink_parent);
2169 
2170     GST_PAD_UNLINKFUNC (sinkpad) (sinkpad, tmpparent);
2171     RELEASE_PARENT (tmpparent);
2172   }
2173 no_sink_parent:
2174 
2175   /* first clear peers */
2176   GST_PAD_PEER (srcpad) = NULL;
2177   GST_PAD_PEER (sinkpad) = NULL;
2178 
2179   GST_OBJECT_UNLOCK (sinkpad);
2180   GST_OBJECT_UNLOCK (srcpad);
2181 
2182   /* fire off a signal to each of the pads telling them
2183    * that they&#39;ve been unlinked */
2184   g_signal_emit (srcpad, gst_pad_signals[PAD_UNLINKED], 0, sinkpad);
2185   g_signal_emit (sinkpad, gst_pad_signals[PAD_UNLINKED], 0, srcpad);
2186 
2187   GST_CAT_INFO (GST_CAT_ELEMENT_PADS, &quot;unlinked %s:%s and %s:%s&quot;,
2188       GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad));
2189 
2190   result = TRUE;
2191 
2192 done:
2193   if (parent != NULL) {
2194     gst_element_post_message (parent,
2195         gst_message_new_structure_change (GST_OBJECT_CAST (sinkpad),
2196             GST_STRUCTURE_CHANGE_TYPE_PAD_UNLINK, parent, FALSE));
2197     gst_object_unref (parent);
2198   }
2199   GST_TRACER_PAD_UNLINK_POST (srcpad, sinkpad, result);
2200   return result;
2201 
2202   /* ERRORS */
2203 not_linked_together:
2204   {
2205     /* we do not emit a warning in this case because unlinking cannot
2206      * be made MT safe.*/
2207     GST_OBJECT_UNLOCK (sinkpad);
2208     GST_OBJECT_UNLOCK (srcpad);
2209     goto done;
2210   }
2211 }
2212 
2213 /**
2214  * gst_pad_is_linked:
2215  * @pad: pad to check
2216  *
2217  * Checks if a @pad is linked to another pad or not.
2218  *
2219  * Returns: %TRUE if the pad is linked, %FALSE otherwise.
2220  *
2221  * MT safe.
2222  */
2223 gboolean
2224 gst_pad_is_linked (GstPad * pad)
2225 {
2226   gboolean result;
2227 
2228   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
2229 
2230   GST_OBJECT_LOCK (pad);
2231   result = (GST_PAD_PEER (pad) != NULL);
2232   GST_OBJECT_UNLOCK (pad);
2233 
2234   return result;
2235 }
2236 
2237 /* get the caps from both pads and see if the intersection
2238  * is not empty.
2239  *
2240  * This function should be called with the pad LOCK on both
2241  * pads
2242  */
2243 static gboolean
2244 gst_pad_link_check_compatible_unlocked (GstPad * src, GstPad * sink,
2245     GstPadLinkCheck flags)
2246 {
2247   GstCaps *srccaps = NULL;
2248   GstCaps *sinkcaps = NULL;
2249   gboolean compatible = FALSE;
2250 
2251   if (!(flags &amp; (GST_PAD_LINK_CHECK_CAPS | GST_PAD_LINK_CHECK_TEMPLATE_CAPS)))
2252     return TRUE;
2253 
2254   /* Doing the expensive caps checking takes priority over only checking the template caps */
2255   if (flags &amp; GST_PAD_LINK_CHECK_CAPS) {
2256     GST_OBJECT_UNLOCK (sink);
2257     GST_OBJECT_UNLOCK (src);
2258 
2259     srccaps = gst_pad_query_caps (src, NULL);
2260     sinkcaps = gst_pad_query_caps (sink, NULL);
2261 
2262     GST_OBJECT_LOCK (src);
2263     GST_OBJECT_LOCK (sink);
2264   } else {
2265     /* If one of the two pads doesn&#39;t have a template, consider the intersection
2266      * as valid.*/
2267     if (G_UNLIKELY ((GST_PAD_PAD_TEMPLATE (src) == NULL)
2268             || (GST_PAD_PAD_TEMPLATE (sink) == NULL))) {
2269       compatible = TRUE;
2270       goto done;
2271     }
2272     srccaps = gst_caps_ref (GST_PAD_TEMPLATE_CAPS (GST_PAD_PAD_TEMPLATE (src)));
2273     sinkcaps =
2274         gst_caps_ref (GST_PAD_TEMPLATE_CAPS (GST_PAD_PAD_TEMPLATE (sink)));
2275   }
2276 
2277   GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, src, &quot;src caps %&quot; GST_PTR_FORMAT,
2278       srccaps);
2279   GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, sink, &quot;sink caps %&quot; GST_PTR_FORMAT,
2280       sinkcaps);
2281 
2282   /* if we have caps on both pads we can check the intersection. If one
2283    * of the caps is %NULL, we return %TRUE. */
2284   if (G_UNLIKELY (srccaps == NULL || sinkcaps == NULL)) {
2285     if (srccaps)
2286       gst_caps_unref (srccaps);
2287     if (sinkcaps)
2288       gst_caps_unref (sinkcaps);
2289     goto done;
2290   }
2291 
2292   compatible = gst_caps_can_intersect (srccaps, sinkcaps);
2293   gst_caps_unref (srccaps);
2294   gst_caps_unref (sinkcaps);
2295 
2296 done:
2297   GST_CAT_DEBUG (GST_CAT_CAPS, &quot;caps are %scompatible&quot;,
2298       (compatible ? &quot;&quot; : &quot;not &quot;));
2299 
2300   return compatible;
2301 }
2302 
2303 /* check if the grandparents of both pads are the same.
2304  * This check is required so that we don&#39;t try to link
2305  * pads from elements in different bins without ghostpads.
2306  *
2307  * The LOCK should be held on both pads
2308  */
2309 static gboolean
2310 gst_pad_link_check_hierarchy (GstPad * src, GstPad * sink)
2311 {
2312   GstObject *psrc, *psink;
2313 
2314   psrc = GST_OBJECT_PARENT (src);
2315   psink = GST_OBJECT_PARENT (sink);
2316 
2317   /* if one of the pads has no parent, we allow the link */
2318   if (G_UNLIKELY (psrc == NULL || psink == NULL))
2319     goto no_parent;
2320 
2321   /* only care about parents that are elements */
2322   if (G_UNLIKELY (!GST_IS_ELEMENT (psrc) || !GST_IS_ELEMENT (psink)))
2323     goto no_element_parent;
2324 
2325   /* if the parents are the same, we have a loop */
2326   if (G_UNLIKELY (psrc == psink))
2327     goto same_parents;
2328 
2329   /* if they both have a parent, we check the grandparents. We can not lock
2330    * the parent because we hold on the child (pad) and the locking order is
2331    * parent &gt;&gt; child. */
2332   psrc = GST_OBJECT_PARENT (psrc);
2333   psink = GST_OBJECT_PARENT (psink);
2334 
2335   /* if they have grandparents but they are not the same */
2336   if (G_UNLIKELY (psrc != psink))
2337     goto wrong_grandparents;
2338 
2339   return TRUE;
2340 
2341   /* ERRORS */
2342 no_parent:
2343   {
2344     GST_CAT_DEBUG (GST_CAT_CAPS,
2345         &quot;one of the pads has no parent %&quot; GST_PTR_FORMAT &quot; and %&quot;
2346         GST_PTR_FORMAT, psrc, psink);
2347     return TRUE;
2348   }
2349 no_element_parent:
2350   {
2351     GST_CAT_DEBUG (GST_CAT_CAPS,
2352         &quot;one of the pads has no element parent %&quot; GST_PTR_FORMAT &quot; and %&quot;
2353         GST_PTR_FORMAT, psrc, psink);
2354     return TRUE;
2355   }
2356 same_parents:
2357   {
2358     GST_CAT_DEBUG (GST_CAT_CAPS, &quot;pads have same parent %&quot; GST_PTR_FORMAT,
2359         psrc);
2360     return FALSE;
2361   }
2362 wrong_grandparents:
2363   {
2364     GST_CAT_DEBUG (GST_CAT_CAPS,
2365         &quot;pads have different grandparents %&quot; GST_PTR_FORMAT &quot; and %&quot;
2366         GST_PTR_FORMAT, psrc, psink);
2367     return FALSE;
2368   }
2369 }
2370 
2371 /* FIXME leftover from an attempt at refactoring... */
2372 /* call with the two pads unlocked, when this function returns GST_PAD_LINK_OK,
2373  * the two pads will be locked in the srcpad, sinkpad order. */
2374 static GstPadLinkReturn
2375 gst_pad_link_prepare (GstPad * srcpad, GstPad * sinkpad, GstPadLinkCheck flags)
2376 {
2377   GST_CAT_INFO (GST_CAT_PADS, &quot;trying to link %s:%s and %s:%s&quot;,
2378       GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad));
2379 
2380   GST_OBJECT_LOCK (srcpad);
2381 
2382   if (G_UNLIKELY (GST_PAD_PEER (srcpad) != NULL))
2383     goto src_was_linked;
2384 
2385   GST_OBJECT_LOCK (sinkpad);
2386 
2387   if (G_UNLIKELY (GST_PAD_PEER (sinkpad) != NULL))
2388     goto sink_was_linked;
2389 
2390   /* check hierarchy, pads can only be linked if the grandparents
2391    * are the same. */
2392   if ((flags &amp; GST_PAD_LINK_CHECK_HIERARCHY)
2393       &amp;&amp; !gst_pad_link_check_hierarchy (srcpad, sinkpad))
2394     goto wrong_hierarchy;
2395 
2396   /* check pad caps for non-empty intersection */
2397   if (!gst_pad_link_check_compatible_unlocked (srcpad, sinkpad, flags))
2398     goto no_format;
2399 
2400   /* FIXME check pad scheduling for non-empty intersection */
2401 
2402   return GST_PAD_LINK_OK;
2403 
2404 src_was_linked:
2405   {
2406     GST_CAT_INFO (GST_CAT_PADS, &quot;src %s:%s was already linked to %s:%s&quot;,
2407         GST_DEBUG_PAD_NAME (srcpad),
2408         GST_DEBUG_PAD_NAME (GST_PAD_PEER (srcpad)));
2409     /* we do not emit a warning in this case because unlinking cannot
2410      * be made MT safe.*/
2411     GST_OBJECT_UNLOCK (srcpad);
2412     return GST_PAD_LINK_WAS_LINKED;
2413   }
2414 sink_was_linked:
2415   {
2416     GST_CAT_INFO (GST_CAT_PADS, &quot;sink %s:%s was already linked to %s:%s&quot;,
2417         GST_DEBUG_PAD_NAME (sinkpad),
2418         GST_DEBUG_PAD_NAME (GST_PAD_PEER (sinkpad)));
2419     /* we do not emit a warning in this case because unlinking cannot
2420      * be made MT safe.*/
2421     GST_OBJECT_UNLOCK (sinkpad);
2422     GST_OBJECT_UNLOCK (srcpad);
2423     return GST_PAD_LINK_WAS_LINKED;
2424   }
2425 wrong_hierarchy:
2426   {
2427     GST_CAT_INFO (GST_CAT_PADS, &quot;pads have wrong hierarchy&quot;);
2428     GST_OBJECT_UNLOCK (sinkpad);
2429     GST_OBJECT_UNLOCK (srcpad);
2430     return GST_PAD_LINK_WRONG_HIERARCHY;
2431   }
2432 no_format:
2433   {
2434     GST_CAT_INFO (GST_CAT_PADS, &quot;caps are incompatible&quot;);
2435     GST_OBJECT_UNLOCK (sinkpad);
2436     GST_OBJECT_UNLOCK (srcpad);
2437     return GST_PAD_LINK_NOFORMAT;
2438   }
2439 }
2440 
2441 /**
2442  * gst_pad_can_link:
2443  * @srcpad: the source #GstPad.
2444  * @sinkpad: the sink #GstPad.
2445  *
2446  * Checks if the source pad and the sink pad are compatible so they can be
2447  * linked.
2448  *
2449  * Returns: %TRUE if the pads can be linked.
2450  */
2451 gboolean
2452 gst_pad_can_link (GstPad * srcpad, GstPad * sinkpad)
2453 {
2454   GstPadLinkReturn result;
2455 
2456   /* generic checks */
2457   g_return_val_if_fail (GST_IS_PAD (srcpad), FALSE);
2458   g_return_val_if_fail (GST_IS_PAD (sinkpad), FALSE);
2459 
2460   GST_CAT_INFO (GST_CAT_PADS, &quot;check if %s:%s can link with %s:%s&quot;,
2461       GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad));
2462 
2463   /* gst_pad_link_prepare does everything for us, we only release the locks
2464    * on the pads that it gets us. If this function returns !OK the locks are not
2465    * taken anymore. */
2466   result = gst_pad_link_prepare (srcpad, sinkpad, GST_PAD_LINK_CHECK_DEFAULT);
2467   if (result != GST_PAD_LINK_OK)
2468     goto done;
2469 
2470   GST_OBJECT_UNLOCK (srcpad);
2471   GST_OBJECT_UNLOCK (sinkpad);
2472 
2473 done:
2474   return result == GST_PAD_LINK_OK;
2475 }
2476 
2477 /**
2478  * gst_pad_link_full:
2479  * @srcpad: the source #GstPad to link.
2480  * @sinkpad: the sink #GstPad to link.
2481  * @flags: the checks to validate when linking
2482  *
2483  * Links the source pad and the sink pad.
2484  *
2485  * This variant of #gst_pad_link provides a more granular control on the
2486  * checks being done when linking. While providing some considerable speedups
2487  * the caller of this method must be aware that wrong usage of those flags
2488  * can cause severe issues. Refer to the documentation of #GstPadLinkCheck
2489  * for more information.
2490  *
2491  * MT Safe.
2492  *
2493  * Returns: A result code indicating if the connection worked or
2494  *          what went wrong.
2495  */
2496 GstPadLinkReturn
2497 gst_pad_link_full (GstPad * srcpad, GstPad * sinkpad, GstPadLinkCheck flags)
2498 {
2499   GstPadLinkReturn result;
2500   GstElement *parent;
2501   GstPadLinkFunction srcfunc, sinkfunc;
2502 
2503   g_return_val_if_fail (GST_IS_PAD (srcpad), GST_PAD_LINK_REFUSED);
2504   g_return_val_if_fail (GST_PAD_IS_SRC (srcpad), GST_PAD_LINK_WRONG_DIRECTION);
2505   g_return_val_if_fail (GST_IS_PAD (sinkpad), GST_PAD_LINK_REFUSED);
2506   g_return_val_if_fail (GST_PAD_IS_SINK (sinkpad),
2507       GST_PAD_LINK_WRONG_DIRECTION);
2508 
2509   GST_TRACER_PAD_LINK_PRE (srcpad, sinkpad);
2510 
2511   /* Notify the parent early. See gst_pad_unlink for details. */
2512   if (G_LIKELY ((parent = GST_ELEMENT_CAST (gst_pad_get_parent (srcpad))))) {
2513     if (G_LIKELY (GST_IS_ELEMENT (parent))) {
2514       gst_element_post_message (parent,
2515           gst_message_new_structure_change (GST_OBJECT_CAST (sinkpad),
2516               GST_STRUCTURE_CHANGE_TYPE_PAD_LINK, parent, TRUE));
2517     } else {
2518       gst_object_unref (parent);
2519       parent = NULL;
2520     }
2521   }
2522 
2523   /* prepare will also lock the two pads */
2524   result = gst_pad_link_prepare (srcpad, sinkpad, flags);
2525 
2526   if (G_UNLIKELY (result != GST_PAD_LINK_OK)) {
2527     GST_CAT_INFO (GST_CAT_PADS, &quot;link between %s:%s and %s:%s failed: %s&quot;,
2528         GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad),
2529         gst_pad_link_get_name (result));
2530     goto done;
2531   }
2532 
2533   /* must set peers before calling the link function */
2534   GST_PAD_PEER (srcpad) = sinkpad;
2535   GST_PAD_PEER (sinkpad) = srcpad;
2536 
2537   /* check events, when something is different, mark pending */
2538   schedule_events (srcpad, sinkpad);
2539 
2540   /* get the link functions */
2541   srcfunc = GST_PAD_LINKFUNC (srcpad);
2542   sinkfunc = GST_PAD_LINKFUNC (sinkpad);
2543 
2544   if (G_UNLIKELY (srcfunc || sinkfunc)) {
2545     /* custom link functions, execute them */
2546     GST_OBJECT_UNLOCK (sinkpad);
2547     GST_OBJECT_UNLOCK (srcpad);
2548 
2549     if (srcfunc) {
2550       GstObject *tmpparent;
2551 
2552       ACQUIRE_PARENT (srcpad, tmpparent, no_parent);
2553       /* this one will call the peer link function */
2554       result = srcfunc (srcpad, tmpparent, sinkpad);
2555       RELEASE_PARENT (tmpparent);
2556     } else if (sinkfunc) {
2557       GstObject *tmpparent;
2558 
2559       ACQUIRE_PARENT (sinkpad, tmpparent, no_parent);
2560       /* if no source link function, we need to call the sink link
2561        * function ourselves. */
2562       result = sinkfunc (sinkpad, tmpparent, srcpad);
2563       RELEASE_PARENT (tmpparent);
2564     }
2565   no_parent:
2566 
2567     GST_OBJECT_LOCK (srcpad);
2568     GST_OBJECT_LOCK (sinkpad);
2569 
2570     /* we released the lock, check if the same pads are linked still */
2571     if (GST_PAD_PEER (srcpad) != sinkpad || GST_PAD_PEER (sinkpad) != srcpad)
2572       goto concurrent_link;
2573 
2574     if (G_UNLIKELY (result != GST_PAD_LINK_OK))
2575       goto link_failed;
2576   }
2577   GST_OBJECT_UNLOCK (sinkpad);
2578   GST_OBJECT_UNLOCK (srcpad);
2579 
2580   /* fire off a signal to each of the pads telling them
2581    * that they&#39;ve been linked */
2582   g_signal_emit (srcpad, gst_pad_signals[PAD_LINKED], 0, sinkpad);
2583   g_signal_emit (sinkpad, gst_pad_signals[PAD_LINKED], 0, srcpad);
2584 
2585   GST_CAT_INFO (GST_CAT_PADS, &quot;linked %s:%s and %s:%s, successful&quot;,
2586       GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad));
2587 
2588   if (!(flags &amp; GST_PAD_LINK_CHECK_NO_RECONFIGURE))
<a name="27" id="anc27"></a><span class="line-modified">2589   gst_pad_send_event (srcpad, gst_event_new_reconfigure ());</span>
2590 
2591 done:
2592   if (G_LIKELY (parent)) {
2593     gst_element_post_message (parent,
2594         gst_message_new_structure_change (GST_OBJECT_CAST (sinkpad),
2595             GST_STRUCTURE_CHANGE_TYPE_PAD_LINK, parent, FALSE));
2596     gst_object_unref (parent);
2597   }
2598 
2599   GST_TRACER_PAD_LINK_POST (srcpad, sinkpad, result);
2600   return result;
2601 
2602   /* ERRORS */
2603 concurrent_link:
2604   {
2605     GST_CAT_INFO (GST_CAT_PADS, &quot;concurrent link between %s:%s and %s:%s&quot;,
2606         GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad));
2607     GST_OBJECT_UNLOCK (sinkpad);
2608     GST_OBJECT_UNLOCK (srcpad);
2609 
2610     /* The other link operation succeeded first */
2611     result = GST_PAD_LINK_WAS_LINKED;
2612     goto done;
2613   }
2614 link_failed:
2615   {
2616     GST_CAT_INFO (GST_CAT_PADS, &quot;link between %s:%s and %s:%s failed: %s&quot;,
2617         GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad),
2618         gst_pad_link_get_name (result));
2619 
2620     GST_PAD_PEER (srcpad) = NULL;
2621     GST_PAD_PEER (sinkpad) = NULL;
2622 
2623     GST_OBJECT_UNLOCK (sinkpad);
2624     GST_OBJECT_UNLOCK (srcpad);
2625 
2626     goto done;
2627   }
2628 }
2629 
2630 /**
2631  * gst_pad_link:
2632  * @srcpad: the source #GstPad to link.
2633  * @sinkpad: the sink #GstPad to link.
2634  *
2635  * Links the source pad and the sink pad.
2636  *
2637  * Returns: A result code indicating if the connection worked or
2638  *          what went wrong.
2639  *
2640  * MT Safe.
2641  */
2642 GstPadLinkReturn
2643 gst_pad_link (GstPad * srcpad, GstPad * sinkpad)
2644 {
2645   return gst_pad_link_full (srcpad, sinkpad, GST_PAD_LINK_CHECK_DEFAULT);
2646 }
2647 
2648 static void
2649 gst_pad_set_pad_template (GstPad * pad, GstPadTemplate * templ)
2650 {
2651   GstPadTemplate **template_p;
2652 
2653   /* this function would need checks if it weren&#39;t static */
2654 
2655   GST_OBJECT_LOCK (pad);
2656   template_p = &amp;pad-&gt;padtemplate;
2657   gst_object_replace ((GstObject **) template_p, (GstObject *) templ);
2658   GST_OBJECT_UNLOCK (pad);
2659 
2660   if (templ)
2661     gst_pad_template_pad_created (templ, pad);
2662 }
2663 
2664 /**
2665  * gst_pad_get_pad_template:
2666  * @pad: a #GstPad.
2667  *
2668  * Gets the template for @pad.
2669  *
2670  * Returns: (transfer full) (nullable): the #GstPadTemplate from which
2671  *     this pad was instantiated, or %NULL if this pad has no
2672  *     template. Unref after usage.
2673  */
2674 GstPadTemplate *
2675 gst_pad_get_pad_template (GstPad * pad)
2676 {
2677   GstPadTemplate *templ;
2678 
2679   g_return_val_if_fail (GST_IS_PAD (pad), NULL);
2680 
2681   templ = GST_PAD_PAD_TEMPLATE (pad);
2682 
2683   return (templ ? gst_object_ref (templ) : NULL);
2684 }
2685 
2686 /**
2687  * gst_pad_has_current_caps:
2688  * @pad: a  #GstPad to check
2689  *
2690  * Check if @pad has caps set on it with a #GST_EVENT_CAPS event.
2691  *
2692  * Returns: %TRUE when @pad has caps associated with it.
2693  */
2694 gboolean
2695 gst_pad_has_current_caps (GstPad * pad)
2696 {
2697   gboolean result;
2698   GstCaps *caps;
2699 
2700   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
2701 
2702   GST_OBJECT_LOCK (pad);
2703   caps = get_pad_caps (pad);
2704   GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad,
2705       &quot;check current pad caps %&quot; GST_PTR_FORMAT, caps);
2706   result = (caps != NULL);
2707   GST_OBJECT_UNLOCK (pad);
2708 
2709   return result;
2710 }
2711 
2712 /**
2713  * gst_pad_get_current_caps:
2714  * @pad: a  #GstPad to get the current capabilities of.
2715  *
2716  * Gets the capabilities currently configured on @pad with the last
2717  * #GST_EVENT_CAPS event.
2718  *
2719  * Returns: (transfer full) (nullable): the current caps of the pad with
2720  * incremented ref-count or %NULL when pad has no caps. Unref after usage.
2721  */
2722 GstCaps *
2723 gst_pad_get_current_caps (GstPad * pad)
2724 {
2725   GstCaps *result;
2726 
2727   g_return_val_if_fail (GST_IS_PAD (pad), NULL);
2728 
2729   GST_OBJECT_LOCK (pad);
2730   if ((result = get_pad_caps (pad)))
2731     gst_caps_ref (result);
2732   GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad,
2733       &quot;get current pad caps %&quot; GST_PTR_FORMAT, result);
2734   GST_OBJECT_UNLOCK (pad);
2735 
2736   return result;
2737 }
2738 
2739 /**
2740  * gst_pad_get_pad_template_caps:
2741  * @pad: a #GstPad to get the template capabilities from.
2742  *
2743  * Gets the capabilities for @pad&#39;s template.
2744  *
2745  * Returns: (transfer full): the #GstCaps of this pad template.
2746  * Unref after usage.
2747  */
2748 GstCaps *
2749 gst_pad_get_pad_template_caps (GstPad * pad)
2750 {
2751   g_return_val_if_fail (GST_IS_PAD (pad), NULL);
2752 
2753   if (GST_PAD_PAD_TEMPLATE (pad))
2754     return gst_pad_template_get_caps (GST_PAD_PAD_TEMPLATE (pad));
2755 
2756   return gst_caps_ref (GST_CAPS_ANY);
2757 }
2758 
2759 /**
2760  * gst_pad_get_peer:
2761  * @pad: a #GstPad to get the peer of.
2762  *
2763  * Gets the peer of @pad. This function refs the peer pad so
2764  * you need to unref it after use.
2765  *
2766  * Returns: (transfer full) (nullable): the peer #GstPad. Unref after usage.
2767  *
2768  * MT safe.
2769  */
2770 GstPad *
2771 gst_pad_get_peer (GstPad * pad)
2772 {
2773   GstPad *result;
2774 
2775   g_return_val_if_fail (GST_IS_PAD (pad), NULL);
2776 
2777   GST_OBJECT_LOCK (pad);
2778   result = GST_PAD_PEER (pad);
2779   if (result)
2780     gst_object_ref (result);
2781   GST_OBJECT_UNLOCK (pad);
2782 
2783   return result;
2784 }
2785 
2786 /**
2787  * gst_pad_get_allowed_caps:
2788  * @pad: a #GstPad.
2789  *
2790  * Gets the capabilities of the allowed media types that can flow through
2791  * @pad and its peer.
2792  *
2793  * The allowed capabilities is calculated as the intersection of the results of
2794  * calling gst_pad_query_caps() on @pad and its peer. The caller owns a reference
2795  * on the resulting caps.
2796  *
2797  * Returns: (transfer full) (nullable): the allowed #GstCaps of the
2798  *     pad link. Unref the caps when you no longer need it. This
2799  *     function returns %NULL when @pad has no peer.
2800  *
2801  * MT safe.
2802  */
2803 GstCaps *
2804 gst_pad_get_allowed_caps (GstPad * pad)
2805 {
2806   GstCaps *mycaps;
2807   GstCaps *caps = NULL;
2808   GstQuery *query;
2809 
2810   g_return_val_if_fail (GST_IS_PAD (pad), NULL);
2811 
2812   GST_OBJECT_LOCK (pad);
2813   if (G_UNLIKELY (GST_PAD_PEER (pad) == NULL))
2814     goto no_peer;
2815   GST_OBJECT_UNLOCK (pad);
2816 
2817   GST_CAT_DEBUG_OBJECT (GST_CAT_PROPERTIES, pad, &quot;getting allowed caps&quot;);
2818 
2819   mycaps = gst_pad_query_caps (pad, NULL);
2820 
2821   /* Query peer caps */
2822   query = gst_query_new_caps (mycaps);
2823   if (!gst_pad_peer_query (pad, query)) {
2824     GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad, &quot;Caps query failed&quot;);
2825     goto end;
2826   }
2827 
2828   gst_query_parse_caps_result (query, &amp;caps);
2829   if (caps == NULL) {
2830     g_warn_if_fail (caps != NULL);
2831     goto end;
2832   }
2833   gst_caps_ref (caps);
2834 
2835   GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad, &quot;allowed caps %&quot; GST_PTR_FORMAT,
2836       caps);
2837 
2838 end:
2839   gst_query_unref (query);
2840   gst_caps_unref (mycaps);
2841 
2842   return caps;
2843 
2844 no_peer:
2845   {
2846     GST_CAT_DEBUG_OBJECT (GST_CAT_PROPERTIES, pad, &quot;no peer&quot;);
2847     GST_OBJECT_UNLOCK (pad);
2848 
2849     return NULL;
2850   }
2851 }
2852 
2853 /**
2854  * gst_pad_iterate_internal_links_default:
2855  * @pad: the #GstPad to get the internal links of.
2856  * @parent: (allow-none): the parent of @pad or %NULL
2857  *
2858  * Iterate the list of pads to which the given pad is linked to inside of
2859  * the parent element.
2860  * This is the default handler, and thus returns an iterator of all of the
2861  * pads inside the parent element with opposite direction.
2862  *
2863  * The caller must free this iterator after use with gst_iterator_free().
2864  *
2865  * Returns: (nullable): a #GstIterator of #GstPad, or %NULL if @pad
2866  * has no parent. Unref each returned pad with gst_object_unref().
2867  */
2868 GstIterator *
2869 gst_pad_iterate_internal_links_default (GstPad * pad, GstObject * parent)
2870 {
2871   GstIterator *res;
2872   GList **padlist;
2873   guint32 *cookie;
2874   GMutex *lock;
2875   gpointer owner;
2876   GstElement *eparent;
2877 
2878   g_return_val_if_fail (GST_IS_PAD (pad), NULL);
2879 
2880   if (parent != NULL &amp;&amp; GST_IS_ELEMENT (parent)) {
2881     eparent = GST_ELEMENT_CAST (gst_object_ref (parent));
2882   } else {
2883     GST_OBJECT_LOCK (pad);
2884     eparent = GST_PAD_PARENT (pad);
2885     if (!eparent || !GST_IS_ELEMENT (eparent))
2886       goto no_parent;
2887 
2888     gst_object_ref (eparent);
2889     GST_OBJECT_UNLOCK (pad);
2890   }
2891 
2892   if (pad-&gt;direction == GST_PAD_SRC)
2893     padlist = &amp;eparent-&gt;sinkpads;
2894   else
2895     padlist = &amp;eparent-&gt;srcpads;
2896 
2897   GST_DEBUG_OBJECT (pad, &quot;Making iterator&quot;);
2898 
2899   cookie = &amp;eparent-&gt;pads_cookie;
2900   owner = eparent;
2901   lock = GST_OBJECT_GET_LOCK (eparent);
2902 
2903   res = gst_iterator_new_list (GST_TYPE_PAD,
2904       lock, cookie, padlist, (GObject *) owner, NULL);
2905 
2906   gst_object_unref (owner);
2907 
2908   return res;
2909 
2910   /* ERRORS */
2911 no_parent:
2912   {
2913     GST_OBJECT_UNLOCK (pad);
2914     GST_DEBUG_OBJECT (pad, &quot;no parent element&quot;);
2915     return NULL;
2916   }
2917 }
2918 
2919 /**
2920  * gst_pad_iterate_internal_links:
2921  * @pad: the GstPad to get the internal links of.
2922  *
2923  * Gets an iterator for the pads to which the given pad is linked to inside
2924  * of the parent element.
2925  *
2926  * Each #GstPad element yielded by the iterator will have its refcount increased,
2927  * so unref after use.
2928  *
2929  * Free-function: gst_iterator_free
2930  *
2931  * Returns: (transfer full) (nullable): a new #GstIterator of #GstPad
2932  *     or %NULL when the pad does not have an iterator function
2933  *     configured. Use gst_iterator_free() after usage.
2934  */
2935 GstIterator *
2936 gst_pad_iterate_internal_links (GstPad * pad)
2937 {
2938   GstIterator *res = NULL;
2939   GstObject *parent;
2940 
2941   g_return_val_if_fail (GST_IS_PAD (pad), NULL);
2942 
2943   GST_OBJECT_LOCK (pad);
2944   ACQUIRE_PARENT (pad, parent, no_parent);
2945   GST_OBJECT_UNLOCK (pad);
2946 
2947   if (GST_PAD_ITERINTLINKFUNC (pad))
2948     res = GST_PAD_ITERINTLINKFUNC (pad) (pad, parent);
2949 
2950   RELEASE_PARENT (parent);
2951 
2952   return res;
2953 
2954   /* ERRORS */
2955 no_parent:
2956   {
2957     GST_DEBUG_OBJECT (pad, &quot;no parent&quot;);
2958     GST_OBJECT_UNLOCK (pad);
2959     return NULL;
2960   }
2961 }
2962 
2963 /**
2964  * gst_pad_forward:
2965  * @pad: a #GstPad
2966  * @forward: (scope call): a #GstPadForwardFunction
2967  * @user_data: user data passed to @forward
2968  *
2969  * Calls @forward for all internally linked pads of @pad. This function deals with
2970  * dynamically changing internal pads and will make sure that the @forward
2971  * function is only called once for each pad.
2972  *
2973  * When @forward returns %TRUE, no further pads will be processed.
2974  *
2975  * Returns: %TRUE if one of the dispatcher functions returned %TRUE.
2976  */
2977 gboolean
2978 gst_pad_forward (GstPad * pad, GstPadForwardFunction forward,
2979     gpointer user_data)
2980 {
2981   gboolean result = FALSE;
2982   GstIterator *iter;
2983   gboolean done = FALSE;
2984   GValue item = { 0, };
2985   GList *pushed_pads = NULL;
2986 
2987   iter = gst_pad_iterate_internal_links (pad);
2988 
2989   if (!iter)
2990     goto no_iter;
2991 
2992   while (!done) {
2993     switch (gst_iterator_next (iter, &amp;item)) {
2994       case GST_ITERATOR_OK:
2995       {
2996         GstPad *intpad;
2997 
2998         intpad = g_value_get_object (&amp;item);
2999 
3000         /* if already pushed, skip. FIXME, find something faster to tag pads */
3001         if (intpad == NULL || g_list_find (pushed_pads, intpad)) {
3002           g_value_reset (&amp;item);
3003           break;
3004         }
3005 
3006         GST_LOG_OBJECT (pad, &quot;calling forward function on pad %s:%s&quot;,
3007             GST_DEBUG_PAD_NAME (intpad));
3008         done = result = forward (intpad, user_data);
3009 
3010         pushed_pads = g_list_prepend (pushed_pads, intpad);
3011 
3012         g_value_reset (&amp;item);
3013         break;
3014       }
3015       case GST_ITERATOR_RESYNC:
3016         /* We don&#39;t reset the result here because we don&#39;t push the event
3017          * again on pads that got the event already and because we need
3018          * to consider the result of the previous pushes */
3019         gst_iterator_resync (iter);
3020         break;
3021       case GST_ITERATOR_ERROR:
3022         GST_ERROR_OBJECT (pad, &quot;Could not iterate over internally linked pads&quot;);
3023         done = TRUE;
3024         break;
3025       case GST_ITERATOR_DONE:
3026         done = TRUE;
3027         break;
3028     }
3029   }
3030   g_value_unset (&amp;item);
3031   gst_iterator_free (iter);
3032 
3033   g_list_free (pushed_pads);
3034 
3035 no_iter:
3036   return result;
3037 }
3038 
3039 typedef struct
3040 {
3041   GstEvent *event;
3042   gboolean result;
3043   gboolean dispatched;
3044 } EventData;
3045 
3046 static gboolean
3047 event_forward_func (GstPad * pad, EventData * data)
3048 {
3049   /* for each pad we send to, we should ref the event; it&#39;s up
3050    * to downstream to unref again when handled. */
3051   GST_LOG_OBJECT (pad, &quot;Reffing and pushing event %p (%s) to %s:%s&quot;,
3052       data-&gt;event, GST_EVENT_TYPE_NAME (data-&gt;event), GST_DEBUG_PAD_NAME (pad));
3053 
3054   data-&gt;result |= gst_pad_push_event (pad, gst_event_ref (data-&gt;event));
3055 
3056   data-&gt;dispatched = TRUE;
3057 
3058   /* don&#39;t stop */
3059   return FALSE;
3060 }
3061 
3062 /**
3063  * gst_pad_event_default:
3064  * @pad: a #GstPad to call the default event handler on.
3065  * @parent: (allow-none): the parent of @pad or %NULL
3066  * @event: (transfer full): the #GstEvent to handle.
3067  *
3068  * Invokes the default event handler for the given pad.
3069  *
3070  * The EOS event will pause the task associated with @pad before it is forwarded
3071  * to all internally linked pads,
3072  *
3073  * The event is sent to all pads internally linked to @pad. This function
3074  * takes ownership of @event.
3075  *
3076  * Returns: %TRUE if the event was sent successfully.
3077  */
3078 gboolean
3079 gst_pad_event_default (GstPad * pad, GstObject * parent, GstEvent * event)
3080 {
3081   gboolean result, forward = TRUE;
3082 
3083   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
3084   g_return_val_if_fail (event != NULL, FALSE);
3085 
3086   GST_LOG_OBJECT (pad, &quot;default event handler for event %&quot; GST_PTR_FORMAT,
3087       event);
3088 
3089   switch (GST_EVENT_TYPE (event)) {
3090     case GST_EVENT_CAPS:
3091       forward = GST_PAD_IS_PROXY_CAPS (pad);
3092       result = TRUE;
3093       break;
3094     default:
3095       break;
3096   }
3097 
3098   if (forward) {
3099     EventData data;
3100 
3101     data.event = event;
3102     data.dispatched = FALSE;
3103     data.result = FALSE;
3104 
3105     gst_pad_forward (pad, (GstPadForwardFunction) event_forward_func, &amp;data);
3106 
3107     /* for sinkpads without a parent element or without internal links, nothing
3108      * will be dispatched but we still want to return TRUE. */
3109     if (data.dispatched)
3110       result = data.result;
3111     else
3112       result = TRUE;
3113   }
3114 
3115   gst_event_unref (event);
3116 
3117   return result;
3118 }
3119 
3120 /* Default accept caps implementation just checks against
3121  * the allowed caps for the pad */
3122 static gboolean
3123 gst_pad_query_accept_caps_default (GstPad * pad, GstQuery * query)
3124 {
3125   /* get the caps and see if it intersects to something not empty */
3126   GstCaps *caps, *allowed = NULL;
3127   gboolean result;
3128 
3129   GST_DEBUG_OBJECT (pad, &quot;query accept-caps %&quot; GST_PTR_FORMAT, query);
3130 
3131   /* first forward the query to internally linked pads when we are dealing with
3132    * a PROXY CAPS */
3133   if (GST_PAD_IS_PROXY_CAPS (pad)) {
3134     result = gst_pad_proxy_query_accept_caps (pad, query);
3135     if (result)
3136       allowed = gst_pad_get_pad_template_caps (pad);
3137     else
3138       goto done;
<a name="28" id="anc28"></a><span class="line-modified">3139     }</span>
3140 
3141   gst_query_parse_accept_caps (query, &amp;caps);
3142   if (!allowed) {
3143     if (GST_PAD_IS_ACCEPT_TEMPLATE (pad)) {
3144       allowed = gst_pad_get_pad_template_caps (pad);
3145     } else {
<a name="29" id="anc29"></a><span class="line-modified">3146   GST_CAT_DEBUG_OBJECT (GST_CAT_PERFORMANCE, pad,</span>
<span class="line-modified">3147       &quot;fallback ACCEPT_CAPS query, consider implementing a specialized version&quot;);</span>
<span class="line-modified">3148   allowed = gst_pad_query_caps (pad, caps);</span>
3149     }
3150   }
3151 
3152   if (allowed) {
3153     if (GST_PAD_IS_ACCEPT_INTERSECT (pad)) {
3154       GST_DEBUG_OBJECT (pad,
3155           &quot;allowed caps intersect %&quot; GST_PTR_FORMAT &quot;, caps %&quot; GST_PTR_FORMAT,
3156           allowed, caps);
3157       result = gst_caps_can_intersect (caps, allowed);
3158     } else {
3159       GST_DEBUG_OBJECT (pad, &quot;allowed caps subset %&quot; GST_PTR_FORMAT &quot;, caps %&quot;
3160           GST_PTR_FORMAT, allowed, caps);
3161       result = gst_caps_is_subset (caps, allowed);
3162     }
3163     gst_caps_unref (allowed);
3164   } else {
3165     GST_DEBUG_OBJECT (pad, &quot;no compatible caps allowed on the pad&quot;);
3166     result = FALSE;
3167   }
3168   gst_query_set_accept_caps_result (query, result);
3169 
3170 done:
3171   return TRUE;
3172 }
3173 
3174 /* Default caps implementation */
3175 static gboolean
3176 gst_pad_query_caps_default (GstPad * pad, GstQuery * query)
3177 {
3178   GstCaps *result = NULL, *filter;
3179   GstPadTemplate *templ;
3180   gboolean fixed_caps;
3181 
3182   GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad, &quot;query caps %&quot; GST_PTR_FORMAT,
3183       query);
3184 
3185   /* first try to proxy if we must */
3186   if (GST_PAD_IS_PROXY_CAPS (pad)) {
3187     if ((gst_pad_proxy_query_caps (pad, query))) {
3188       goto done;
3189     }
3190   }
3191 
3192   gst_query_parse_caps (query, &amp;filter);
3193 
3194   /* no proxy or it failed, do default handling */
3195   fixed_caps = GST_PAD_IS_FIXED_CAPS (pad);
3196 
3197   GST_OBJECT_LOCK (pad);
3198   if (fixed_caps) {
3199     /* fixed caps, try the negotiated caps first */
3200     GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad, &quot;fixed pad caps: trying pad caps&quot;);
3201     if ((result = get_pad_caps (pad)))
3202       goto filter_done_unlock;
3203   }
3204 
3205   if ((templ = GST_PAD_PAD_TEMPLATE (pad))) {
3206     GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad, &quot;trying pad template caps&quot;);
3207     if ((result = GST_PAD_TEMPLATE_CAPS (templ)))
3208       goto filter_done_unlock;
3209   }
3210 
3211   if (!fixed_caps) {
3212     GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad,
3213         &quot;non-fixed pad caps: trying pad caps&quot;);
3214     /* non fixed caps, try the negotiated caps */
3215     if ((result = get_pad_caps (pad)))
3216       goto filter_done_unlock;
3217   }
3218 
3219   /* this almost never happens */
3220   GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad, &quot;pad has no caps&quot;);
3221   result = GST_CAPS_ANY;
3222 
3223 filter_done_unlock:
3224   GST_OBJECT_UNLOCK (pad);
3225 
3226   /* run the filter on the result */
3227   if (filter) {
3228     GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad,
3229         &quot;using caps %p %&quot; GST_PTR_FORMAT &quot; with filter %p %&quot;
3230         GST_PTR_FORMAT, result, result, filter, filter);
3231     result = gst_caps_intersect_full (filter, result, GST_CAPS_INTERSECT_FIRST);
3232     GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad, &quot;result %p %&quot; GST_PTR_FORMAT,
3233         result, result);
3234   } else {
3235     GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad,
3236         &quot;using caps %p %&quot; GST_PTR_FORMAT, result, result);
3237     result = gst_caps_ref (result);
3238   }
3239   gst_query_set_caps_result (query, result);
3240   gst_caps_unref (result);
3241 
3242 done:
3243   return TRUE;
3244 }
3245 
3246 /* Default latency implementation */
3247 typedef struct
3248 {
3249   gboolean live;
3250   GstClockTime min, max;
3251 } LatencyFoldData;
3252 
3253 static gboolean
3254 query_latency_default_fold (const GValue * item, GValue * ret,
3255     gpointer user_data)
3256 {
3257   GstPad *pad = g_value_get_object (item), *peer;
3258   LatencyFoldData *fold_data = user_data;
3259   GstQuery *query;
3260   gboolean res = FALSE;
3261 
3262   query = gst_query_new_latency ();
3263 
3264   peer = gst_pad_get_peer (pad);
3265   if (peer) {
3266     res = gst_pad_peer_query (pad, query);
3267   } else {
3268     GST_LOG_OBJECT (pad, &quot;No peer pad found, ignoring this pad&quot;);
3269   }
3270 
3271   if (res) {
3272     gboolean live;
3273     GstClockTime min, max;
3274 
3275     gst_query_parse_latency (query, &amp;live, &amp;min, &amp;max);
3276 
3277     GST_LOG_OBJECT (pad, &quot;got latency live:%s min:%&quot; G_GINT64_FORMAT
3278         &quot; max:%&quot; G_GINT64_FORMAT, live ? &quot;true&quot; : &quot;false&quot;, min, max);
3279 
3280     if (live) {
3281       if (min &gt; fold_data-&gt;min)
3282         fold_data-&gt;min = min;
3283 
3284       if (fold_data-&gt;max == GST_CLOCK_TIME_NONE)
3285         fold_data-&gt;max = max;
3286       else if (max &lt; fold_data-&gt;max)
3287         fold_data-&gt;max = max;
3288 
3289       fold_data-&gt;live = TRUE;
3290     }
3291   } else if (peer) {
3292     GST_DEBUG_OBJECT (pad, &quot;latency query failed&quot;);
3293     g_value_set_boolean (ret, FALSE);
3294   }
3295 
3296   gst_query_unref (query);
3297   if (peer)
3298     gst_object_unref (peer);
3299 
3300   return TRUE;
3301 }
3302 
3303 static gboolean
3304 gst_pad_query_latency_default (GstPad * pad, GstQuery * query)
3305 {
3306   GstIterator *it;
3307   GstIteratorResult res;
3308   GValue ret = G_VALUE_INIT;
3309   gboolean query_ret;
3310   LatencyFoldData fold_data;
3311 
3312   it = gst_pad_iterate_internal_links (pad);
3313   if (!it) {
3314     GST_DEBUG_OBJECT (pad, &quot;Can&#39;t iterate internal links&quot;);
3315     return FALSE;
3316   }
3317 
3318   g_value_init (&amp;ret, G_TYPE_BOOLEAN);
3319 
3320 retry:
3321   fold_data.live = FALSE;
3322   fold_data.min = 0;
3323   fold_data.max = GST_CLOCK_TIME_NONE;
3324 
3325   g_value_set_boolean (&amp;ret, TRUE);
3326   res = gst_iterator_fold (it, query_latency_default_fold, &amp;ret, &amp;fold_data);
3327   switch (res) {
3328     case GST_ITERATOR_OK:
3329       g_assert_not_reached ();
3330       break;
3331     case GST_ITERATOR_DONE:
3332       break;
3333     case GST_ITERATOR_ERROR:
3334       g_value_set_boolean (&amp;ret, FALSE);
3335       break;
3336     case GST_ITERATOR_RESYNC:
3337       gst_iterator_resync (it);
3338       goto retry;
3339     default:
3340       g_assert_not_reached ();
3341       break;
3342   }
3343   gst_iterator_free (it);
3344 
3345   query_ret = g_value_get_boolean (&amp;ret);
3346   if (query_ret) {
3347     GST_LOG_OBJECT (pad, &quot;got latency live:%s min:%&quot; G_GINT64_FORMAT
3348         &quot; max:%&quot; G_GINT64_FORMAT, fold_data.live ? &quot;true&quot; : &quot;false&quot;,
3349         fold_data.min, fold_data.max);
3350 
3351     if (fold_data.min &gt; fold_data.max) {
3352       GST_ERROR_OBJECT (pad, &quot;minimum latency bigger than maximum latency&quot;);
3353     }
3354 
3355     gst_query_set_latency (query, fold_data.live, fold_data.min, fold_data.max);
3356   } else {
3357     GST_LOG_OBJECT (pad, &quot;latency query failed&quot;);
3358   }
3359 
3360   return query_ret;
3361 }
3362 
3363 typedef struct
3364 {
3365   GstQuery *query;
3366   gboolean result;
3367   gboolean dispatched;
3368 } QueryData;
3369 
3370 static gboolean
3371 query_forward_func (GstPad * pad, QueryData * data)
3372 {
3373   GST_LOG_OBJECT (pad, &quot;query peer %p (%s) of %s:%s&quot;,
3374       data-&gt;query, GST_QUERY_TYPE_NAME (data-&gt;query), GST_DEBUG_PAD_NAME (pad));
3375 
3376   data-&gt;result |= gst_pad_peer_query (pad, data-&gt;query);
3377 
3378   data-&gt;dispatched = TRUE;
3379 
3380   /* stop on first successful reply */
3381   return data-&gt;result;
3382 }
3383 
3384 /**
3385  * gst_pad_query_default:
3386  * @pad: a #GstPad to call the default query handler on.
3387  * @parent: (allow-none): the parent of @pad or %NULL
3388  * @query: (transfer none): the #GstQuery to handle.
3389  *
3390  * Invokes the default query handler for the given pad.
3391  * The query is sent to all pads internally linked to @pad. Note that
3392  * if there are many possible sink pads that are internally linked to
3393  * @pad, only one will be sent the query.
3394  * Multi-sinkpad elements should implement custom query handlers.
3395  *
3396  * Returns: %TRUE if the query was performed successfully.
3397  */
3398 gboolean
3399 gst_pad_query_default (GstPad * pad, GstObject * parent, GstQuery * query)
3400 {
3401   gboolean forward, ret = FALSE;
3402 
3403   switch (GST_QUERY_TYPE (query)) {
3404     case GST_QUERY_SCHEDULING:
3405       forward = GST_PAD_IS_PROXY_SCHEDULING (pad);
3406       break;
3407     case GST_QUERY_ALLOCATION:
3408       forward = GST_PAD_IS_PROXY_ALLOCATION (pad);
3409       break;
3410     case GST_QUERY_ACCEPT_CAPS:
3411       ret = gst_pad_query_accept_caps_default (pad, query);
3412       forward = FALSE;
3413       break;
3414     case GST_QUERY_CAPS:
3415       ret = gst_pad_query_caps_default (pad, query);
3416       forward = FALSE;
3417       break;
3418     case GST_QUERY_LATENCY:
3419       ret = gst_pad_query_latency_default (pad, query);
3420       forward = FALSE;
3421       break;
<a name="30" id="anc30"></a>



3422     case GST_QUERY_POSITION:
3423     case GST_QUERY_SEEKING:
3424     case GST_QUERY_FORMATS:
3425     case GST_QUERY_JITTER:
3426     case GST_QUERY_RATE:
3427     case GST_QUERY_CONVERT:
3428     default:
3429       forward = TRUE;
3430       break;
3431   }
3432 
3433   GST_DEBUG_OBJECT (pad, &quot;%sforwarding %p (%s) query&quot;, (forward ? &quot;&quot; : &quot;not &quot;),
3434       query, GST_QUERY_TYPE_NAME (query));
3435 
3436   if (forward) {
3437     QueryData data;
3438 
3439     data.query = query;
3440     data.dispatched = FALSE;
3441     data.result = FALSE;
3442 
3443     gst_pad_forward (pad, (GstPadForwardFunction) query_forward_func, &amp;data);
3444 
3445     if (data.dispatched) {
3446       ret = data.result;
3447     } else {
3448       /* nothing dispatched, assume drained */
3449       if (GST_QUERY_TYPE (query) == GST_QUERY_DRAIN)
3450         ret = TRUE;
3451       else
3452         ret = FALSE;
3453     }
3454   }
3455   return ret;
3456 }
3457 
3458 #define N_STACK_ALLOCATE_PROBES (16)
3459 
3460 static void
3461 probe_hook_marshal (GHook * hook, ProbeMarshall * data)
3462 {
3463   GstPad *pad = data-&gt;pad;
3464   GstPadProbeInfo *info = data-&gt;info;
3465   GstPadProbeType type, flags;
3466   GstPadProbeCallback callback;
3467   GstPadProbeReturn ret;
3468   gpointer original_data;
3469   guint i;
3470 
3471   /* if we have called this callback, do nothing. But only check
3472    * if we&#39;re actually calling probes a second time */
3473   if (data-&gt;retry) {
3474     for (i = 0; i &lt; data-&gt;n_called_probes; i++) {
<a name="31" id="anc31"></a><span class="line-modified">3475       if (data-&gt;called_probes[i] == hook) {</span>
<span class="line-modified">3476     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,</span>
3477             &quot;hook %lu already called&quot;, hook-&gt;hook_id);
<a name="32" id="anc32"></a><span class="line-modified">3478     return;</span>
<span class="line-modified">3479   }</span>
3480     }
3481   }
3482 
3483   /* reallocate on the heap if we had more than 16 probes */
3484   if (data-&gt;n_called_probes == data-&gt;called_probes_size) {
3485     if (data-&gt;called_probes_size &gt; N_STACK_ALLOCATE_PROBES) {
3486       data-&gt;called_probes_size *= 2;
3487       data-&gt;called_probes =
<a name="33" id="anc33"></a><span class="line-modified">3488           g_renew (GHook *, data-&gt;called_probes, data-&gt;called_probes_size);</span>
3489     } else {
<a name="34" id="anc34"></a><span class="line-modified">3490       GHook **tmp = data-&gt;called_probes;</span>
3491 
3492       data-&gt;called_probes_size *= 2;
<a name="35" id="anc35"></a><span class="line-modified">3493       data-&gt;called_probes = g_new (GHook *, data-&gt;called_probes_size);</span>
3494       memcpy (data-&gt;called_probes, tmp,
<a name="36" id="anc36"></a><span class="line-modified">3495           N_STACK_ALLOCATE_PROBES * sizeof (GHook *));</span>
3496     }
3497   }
<a name="37" id="anc37"></a><span class="line-modified">3498   data-&gt;called_probes[data-&gt;n_called_probes++] = hook;</span>
3499 
3500   flags = hook-&gt;flags &gt;&gt; G_HOOK_FLAG_USER_SHIFT;
3501   type = info-&gt;type;
3502   original_data = info-&gt;data;
3503 
3504   /* one of the scheduling types */
3505   if ((flags &amp; GST_PAD_PROBE_TYPE_SCHEDULING &amp; type) == 0)
3506     goto no_match;
3507 
3508   if (G_UNLIKELY (data-&gt;handled)) {
3509     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3510         &quot;probe previously returned HANDLED, not calling again&quot;);
3511     goto no_match;
3512   } else if (G_UNLIKELY (data-&gt;dropped)) {
3513     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3514         &quot;probe previously returned DROPPED, not calling again&quot;);
3515     goto no_match;
3516   }
3517 
3518   if (type &amp; GST_PAD_PROBE_TYPE_PUSH) {
<a name="38" id="anc38"></a><span class="line-modified">3519   /* one of the data types for non-idle probes */</span>
<span class="line-modified">3520   if ((type &amp; GST_PAD_PROBE_TYPE_IDLE) == 0</span>
3521         &amp;&amp; (flags &amp; _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH &amp; type) == 0)
<a name="39" id="anc39"></a><span class="line-modified">3522     goto no_match;</span>
3523   } else if (type &amp; GST_PAD_PROBE_TYPE_PULL) {
3524     /* one of the data types for non-idle probes */
3525     if ((type &amp; GST_PAD_PROBE_TYPE_BLOCKING) == 0
3526         &amp;&amp; (flags &amp; _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH &amp; type) == 0)
<a name="40" id="anc40"></a><span class="line-modified">3527     goto no_match;</span>
3528   } else {
3529     /* Type must have PULL or PUSH probe types */
3530     g_assert_not_reached ();
3531   }
3532 
3533   /* one of the blocking types must match */
3534   if ((type &amp; GST_PAD_PROBE_TYPE_BLOCKING) &amp;&amp;
3535       (flags &amp; GST_PAD_PROBE_TYPE_BLOCKING &amp; type) == 0)
3536     goto no_match;
3537   if ((type &amp; GST_PAD_PROBE_TYPE_BLOCKING) == 0 &amp;&amp;
3538       (flags &amp; GST_PAD_PROBE_TYPE_BLOCKING))
3539     goto no_match;
3540   /* only probes that have GST_PAD_PROBE_TYPE_EVENT_FLUSH set */
3541   if ((type &amp; GST_PAD_PROBE_TYPE_EVENT_FLUSH) &amp;&amp;
3542       (flags &amp; GST_PAD_PROBE_TYPE_EVENT_FLUSH &amp; type) == 0)
3543     goto no_match;
3544 
3545   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3546       &quot;hook %lu with flags 0x%08x matches&quot;, hook-&gt;hook_id, flags);
3547 
3548   data-&gt;marshalled = TRUE;
3549 
3550   callback = (GstPadProbeCallback) hook-&gt;func;
3551   if (callback == NULL)
3552     return;
3553 
3554   info-&gt;id = hook-&gt;hook_id;
3555 
3556   if ((flags &amp; GST_PAD_PROBE_TYPE_IDLE))
3557     pad-&gt;priv-&gt;idle_running++;
3558 
3559   GST_OBJECT_UNLOCK (pad);
3560 
3561   ret = callback (pad, info, hook-&gt;data);
3562 
3563   GST_OBJECT_LOCK (pad);
3564 
3565   if ((flags &amp; GST_PAD_PROBE_TYPE_IDLE))
3566     pad-&gt;priv-&gt;idle_running--;
3567 
<a name="41" id="anc41"></a><span class="line-modified">3568   if (original_data != NULL &amp;&amp; info-&gt;data == NULL) {</span>

3569     GST_DEBUG_OBJECT (pad, &quot;data item in pad probe info was dropped&quot;);
3570     info-&gt;type = GST_PAD_PROBE_TYPE_INVALID;
3571     data-&gt;dropped = TRUE;
3572   }
3573 
3574   switch (ret) {
3575     case GST_PAD_PROBE_REMOVE:
3576       /* remove the probe */
3577       GST_DEBUG_OBJECT (pad, &quot;asked to remove hook&quot;);
3578       cleanup_hook (pad, hook);
3579       break;
3580     case GST_PAD_PROBE_DROP:
3581       /* need to drop the data, make sure other probes don&#39;t get called
3582        * anymore */
3583       GST_DEBUG_OBJECT (pad, &quot;asked to drop item&quot;);
3584       info-&gt;type = GST_PAD_PROBE_TYPE_INVALID;
3585       data-&gt;dropped = TRUE;
3586       break;
3587     case GST_PAD_PROBE_HANDLED:
3588       GST_DEBUG_OBJECT (pad, &quot;probe handled data&quot;);
3589       data-&gt;handled = TRUE;
3590       break;
3591     case GST_PAD_PROBE_PASS:
3592       /* inform the pad block to let things pass */
3593       GST_DEBUG_OBJECT (pad, &quot;asked to pass item&quot;);
3594       data-&gt;pass = TRUE;
3595       break;
3596     case GST_PAD_PROBE_OK:
3597       GST_DEBUG_OBJECT (pad, &quot;probe returned OK&quot;);
3598       break;
3599     default:
3600       GST_DEBUG_OBJECT (pad, &quot;probe returned %d&quot;, ret);
3601       break;
3602   }
3603   return;
3604 
3605 no_match:
3606   {
3607     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3608         &quot;hook %lu with flags 0x%08x does not match %08x&quot;,
3609         hook-&gt;hook_id, flags, info-&gt;type);
3610     return;
3611   }
3612 }
3613 
3614 /* a probe that does not take or return any data */
3615 #define PROBE_NO_DATA(pad,mask,label,defaultval)                \
<a name="42" id="anc42"></a><span class="line-modified">3616   G_STMT_START {                        \</span>
<span class="line-modified">3617     if (G_UNLIKELY (pad-&gt;num_probes)) {             \</span>
<span class="line-modified">3618       GstFlowReturn pval = defaultval;              \</span>
3619       /* pass NULL as the data item */                          \
<a name="43" id="anc43"></a><span class="line-modified">3620       GstPadProbeInfo info = { mask, 0, NULL, 0, 0 };       \</span>
<span class="line-modified">3621       info.ABI.abi.flow_ret = defaultval;           \</span>
<span class="line-modified">3622       ret = do_probe_callbacks (pad, &amp;info, defaultval);    \</span>
<span class="line-modified">3623       if (G_UNLIKELY (ret != pval &amp;&amp; ret != GST_FLOW_OK))   \</span>
<span class="line-modified">3624         goto label;                     \</span>
<span class="line-modified">3625     }                               \</span>
3626   } G_STMT_END
3627 
3628 #define PROBE_FULL(pad,mask,data,offs,size,label,handleable,handle_label) \
<a name="44" id="anc44"></a><span class="line-modified">3629   G_STMT_START {                            \</span>
<span class="line-modified">3630     if (G_UNLIKELY (pad-&gt;num_probes)) {                 \</span>
<span class="line-modified">3631       /* pass the data item */                      \</span>
<span class="line-modified">3632       GstPadProbeInfo info = { mask, 0, data, offs, size };     \</span>
<span class="line-modified">3633       info.ABI.abi.flow_ret = GST_FLOW_OK;              \</span>
<span class="line-modified">3634       ret = do_probe_callbacks (pad, &amp;info, GST_FLOW_OK);       \</span>
<span class="line-modified">3635       /* store the possibly updated data item */            \</span>
<span class="line-modified">3636       data = GST_PAD_PROBE_INFO_DATA (&amp;info);               \</span>
<span class="line-modified">3637       /* if something went wrong, exit */               \</span>
<span class="line-modified">3638       if (G_UNLIKELY (ret != GST_FLOW_OK)) {                \</span>
<span class="line-modified">3639     if (handleable &amp;&amp; ret == GST_FLOW_CUSTOM_SUCCESS_1) {       \</span>
<span class="line-modified">3640       ret = info.ABI.abi.flow_ret;                      \</span>
<span class="line-modified">3641       goto handle_label;                        \</span>
<span class="line-modified">3642     }                               \</span>
<span class="line-modified">3643     goto label;                         \</span>
<span class="line-modified">3644       }                                 \</span>
<span class="line-modified">3645     }                                   \</span>
3646   } G_STMT_END
3647 
<a name="45" id="anc45"></a><span class="line-modified">3648 #define PROBE_PUSH(pad,mask,data,label)     \</span>
3649   PROBE_FULL(pad, mask, data, -1, -1, label, FALSE, label);
3650 #define PROBE_HANDLE(pad,mask,data,label,handle_label)  \
3651   PROBE_FULL(pad, mask, data, -1, -1, label, TRUE, handle_label);
<a name="46" id="anc46"></a><span class="line-modified">3652 #define PROBE_PULL(pad,mask,data,offs,size,label)       \</span>
3653   PROBE_FULL(pad, mask, data, offs, size, label, FALSE, label);
3654 
3655 static GstFlowReturn
3656 do_pad_idle_probe_wait (GstPad * pad)
3657 {
3658   while (GST_PAD_IS_RUNNING_IDLE_PROBE (pad)) {
3659     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3660         &quot;waiting idle probe to be removed&quot;);
3661     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_BLOCKING);
3662     GST_PAD_BLOCK_WAIT (pad);
3663     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_BLOCKING);
3664     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;We got unblocked&quot;);
3665 
3666     if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
3667       return GST_FLOW_FLUSHING;
3668   }
3669   return GST_FLOW_OK;
3670 }
3671 
3672 #define PROBE_TYPE_IS_SERIALIZED(i) \
3673     ( \
3674       ( \
3675         (((i)-&gt;type &amp; (GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM | \
3676         GST_PAD_PROBE_TYPE_EVENT_FLUSH)) &amp;&amp; \
3677         GST_EVENT_IS_SERIALIZED ((i)-&gt;data)) \
3678       ) || ( \
3679         (((i)-&gt;type &amp; GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM) &amp;&amp; \
3680         GST_QUERY_IS_SERIALIZED ((i)-&gt;data)) \
3681       ) || ( \
3682         ((i)-&gt;type &amp; (GST_PAD_PROBE_TYPE_BUFFER | \
3683         GST_PAD_PROBE_TYPE_BUFFER_LIST))  \
3684       ) \
3685     )
3686 
3687 static GstFlowReturn
3688 do_probe_callbacks (GstPad * pad, GstPadProbeInfo * info,
3689     GstFlowReturn defaultval)
3690 {
3691   ProbeMarshall data;
3692   guint cookie;
3693   gboolean is_block;
<a name="47" id="anc47"></a><span class="line-modified">3694   GHook *called_probes[N_STACK_ALLOCATE_PROBES];</span>
3695 
3696   data.pad = pad;
3697   data.info = info;
3698   data.pass = FALSE;
3699   data.handled = FALSE;
3700   data.marshalled = FALSE;
3701   data.dropped = FALSE;
3702 
3703   /* We stack-allocate for N_STACK_ALLOCATE_PROBES hooks as a first step. If more are needed,
3704    * we will re-allocate with g_malloc(). This should usually never be needed
3705    */
3706   data.called_probes = called_probes;
3707   data.n_called_probes = 0;
3708   data.called_probes_size = N_STACK_ALLOCATE_PROBES;
3709   data.retry = FALSE;
3710 
3711   is_block =
3712       (info-&gt;type &amp; GST_PAD_PROBE_TYPE_BLOCK) == GST_PAD_PROBE_TYPE_BLOCK;
3713 
3714   if (is_block &amp;&amp; PROBE_TYPE_IS_SERIALIZED (info)) {
3715     if (do_pad_idle_probe_wait (pad) == GST_FLOW_FLUSHING)
3716       goto flushing;
3717   }
3718 
3719 again:
3720   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;do probes&quot;);
3721   cookie = pad-&gt;priv-&gt;probe_list_cookie;
3722 
3723   g_hook_list_marshal (&amp;pad-&gt;probes, TRUE,
3724       (GHookMarshaller) probe_hook_marshal, &amp;data);
3725 
3726   /* if the list changed, call the new callbacks (they will not be in
3727    * called_probes yet) */
3728   if (cookie != pad-&gt;priv-&gt;probe_list_cookie) {
3729     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3730         &quot;probe list changed, restarting&quot;);
3731     data.retry = TRUE;
3732     goto again;
3733   }
3734 
3735   /* the first item that dropped will stop the hooks and then we drop here */
3736   if (data.dropped)
3737     goto dropped;
3738 
3739   /* If one handler took care of it, let the the item pass */
3740   if (data.handled) {
3741     goto handled;
3742   }
3743 
3744   /* if no handler matched and we are blocking, let the item pass */
3745   if (!data.marshalled &amp;&amp; is_block)
3746     goto passed;
3747 
3748   /* At this point, all handlers returned either OK or PASS. If one handler
3749    * returned PASS, let the item pass */
3750   if (data.pass)
3751     goto passed;
3752 
3753   if (is_block) {
3754     while (GST_PAD_IS_BLOCKED (pad)) {
3755       GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3756           &quot;we are blocked %d times&quot;, pad-&gt;num_blocked);
3757 
3758       /* we might have released the lock */
3759       if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
3760         goto flushing;
3761 
3762       /* now we block the streaming thread. It can be unlocked when we
3763        * deactivate the pad (which will also set the FLUSHING flag) or
3764        * when the pad is unblocked. A flushing event will also unblock
3765        * the pad after setting the FLUSHING flag. */
3766       GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3767           &quot;Waiting to be unblocked or set flushing&quot;);
3768       GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_BLOCKING);
3769       GST_PAD_BLOCK_WAIT (pad);
3770       GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_BLOCKING);
3771       GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;We got unblocked&quot;);
3772 
3773       /* if the list changed, call the new callbacks (they will not be in
3774        * called_probes yet) */
3775       if (cookie != pad-&gt;priv-&gt;probe_list_cookie) {
3776         GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3777             &quot;probe list changed, restarting&quot;);
3778         data.retry = TRUE;
3779         goto again;
3780       }
3781 
3782       if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
3783         goto flushing;
3784     }
3785   }
3786 
3787   if (data.called_probes_size &gt; N_STACK_ALLOCATE_PROBES)
3788     g_free (data.called_probes);
3789 
3790   return defaultval;
3791 
3792   /* ERRORS */
3793 flushing:
3794   {
3795     GST_DEBUG_OBJECT (pad, &quot;pad is flushing&quot;);
3796     if (data.called_probes_size &gt; N_STACK_ALLOCATE_PROBES)
3797       g_free (data.called_probes);
3798     return GST_FLOW_FLUSHING;
3799   }
3800 dropped:
3801   {
3802     GST_DEBUG_OBJECT (pad, &quot;data is dropped&quot;);
3803     if (data.called_probes_size &gt; N_STACK_ALLOCATE_PROBES)
3804       g_free (data.called_probes);
3805     return GST_FLOW_CUSTOM_SUCCESS;
3806   }
3807 passed:
3808   {
3809     /* FIXME : Should we return FLOW_OK or the defaultval ?? */
3810     GST_DEBUG_OBJECT (pad, &quot;data is passed&quot;);
3811     if (data.called_probes_size &gt; N_STACK_ALLOCATE_PROBES)
3812       g_free (data.called_probes);
3813     return GST_FLOW_OK;
3814   }
3815 handled:
3816   {
3817     GST_DEBUG_OBJECT (pad, &quot;data was handled&quot;);
3818     if (data.called_probes_size &gt; N_STACK_ALLOCATE_PROBES)
3819       g_free (data.called_probes);
3820     return GST_FLOW_CUSTOM_SUCCESS_1;
<a name="48" id="anc48"></a><span class="line-modified">3821 }</span>
3822 }
3823 
3824 /* pad offsets */
3825 
3826 /**
3827  * gst_pad_get_offset:
3828  * @pad: a #GstPad
3829  *
3830  * Get the offset applied to the running time of @pad. @pad has to be a source
3831  * pad.
3832  *
3833  * Returns: the offset.
3834  */
3835 gint64
3836 gst_pad_get_offset (GstPad * pad)
3837 {
3838   gint64 result;
3839 
3840   g_return_val_if_fail (GST_IS_PAD (pad), 0);
3841 
3842   GST_OBJECT_LOCK (pad);
3843   result = pad-&gt;offset;
3844   GST_OBJECT_UNLOCK (pad);
3845 
3846   return result;
3847 }
3848 
3849 static gboolean
3850 mark_event_not_received (GstPad * pad, PadEvent * ev, gpointer user_data)
3851 {
3852   ev-&gt;received = FALSE;
3853   return TRUE;
3854 }
3855 
3856 /**
3857  * gst_pad_set_offset:
3858  * @pad: a #GstPad
3859  * @offset: the offset
3860  *
3861  * Set the offset that will be applied to the running time of @pad.
3862  */
3863 void
3864 gst_pad_set_offset (GstPad * pad, gint64 offset)
3865 {
3866   g_return_if_fail (GST_IS_PAD (pad));
3867 
3868   GST_OBJECT_LOCK (pad);
3869   /* if nothing changed, do nothing */
3870   if (pad-&gt;offset == offset)
3871     goto done;
3872 
3873   pad-&gt;offset = offset;
3874   GST_DEBUG_OBJECT (pad, &quot;changed offset to %&quot; GST_STIME_FORMAT,
3875       GST_STIME_ARGS (offset));
3876 
3877   /* resend all sticky events with updated offset on next buffer push */
3878   events_foreach (pad, mark_event_not_received, NULL);
3879   GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
3880 
3881 done:
3882   GST_OBJECT_UNLOCK (pad);
3883 }
3884 
3885 typedef struct
3886 {
3887   GstFlowReturn ret;
3888 
3889   /* If TRUE and ret is not OK this means
3890    * that pushing the EOS event failed
3891    */
3892   gboolean was_eos;
3893 
3894   /* If called for an event this is
3895    * the event that would be pushed
3896    * next. Don&#39;t forward sticky events
3897    * that would come after that */
3898   GstEvent *event;
3899 } PushStickyData;
3900 
3901 /* should be called with pad LOCK */
3902 static gboolean
3903 push_sticky (GstPad * pad, PadEvent * ev, gpointer user_data)
3904 {
3905   PushStickyData *data = user_data;
3906   GstEvent *event = ev-&gt;event;
3907 
3908   if (ev-&gt;received) {
3909     GST_DEBUG_OBJECT (pad, &quot;event %s was already received&quot;,
3910         GST_EVENT_TYPE_NAME (event));
3911     return TRUE;
3912   }
3913 
3914   /* If we&#39;re called because of an sticky event, only forward
3915    * events that would come before this new event and the
3916    * event itself */
3917   if (data-&gt;event &amp;&amp; GST_EVENT_IS_STICKY (data-&gt;event) &amp;&amp;
3918       GST_EVENT_TYPE (data-&gt;event) &lt;= GST_EVENT_SEGMENT &amp;&amp;
3919       GST_EVENT_TYPE (data-&gt;event) &lt; GST_EVENT_TYPE (event)) {
3920     data-&gt;ret = GST_FLOW_CUSTOM_SUCCESS_1;
3921   } else {
3922     data-&gt;ret = gst_pad_push_event_unchecked (pad, gst_event_ref (event),
3923         GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM);
3924     if (data-&gt;ret == GST_FLOW_CUSTOM_SUCCESS_1)
3925       data-&gt;ret = GST_FLOW_OK;
3926   }
3927 
3928   switch (data-&gt;ret) {
3929     case GST_FLOW_OK:
3930       ev-&gt;received = TRUE;
3931       GST_DEBUG_OBJECT (pad, &quot;event %s marked received&quot;,
3932           GST_EVENT_TYPE_NAME (event));
3933       break;
3934     case GST_FLOW_CUSTOM_SUCCESS:
3935       /* we can&#39;t assume the event is received when it was dropped */
3936       GST_DEBUG_OBJECT (pad, &quot;event %s was dropped, mark pending&quot;,
3937           GST_EVENT_TYPE_NAME (event));
3938       GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
3939       data-&gt;ret = GST_FLOW_OK;
3940       break;
3941     case GST_FLOW_CUSTOM_SUCCESS_1:
3942       /* event was ignored and should be sent later */
3943       GST_DEBUG_OBJECT (pad, &quot;event %s was ignored, mark pending&quot;,
3944           GST_EVENT_TYPE_NAME (event));
3945       GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
3946       data-&gt;ret = GST_FLOW_OK;
3947       break;
3948     case GST_FLOW_NOT_LINKED:
3949       /* not linked is not a problem, we are sticky so the event will be
3950        * rescheduled to be sent later on re-link, but only for non-EOS events */
3951       GST_DEBUG_OBJECT (pad, &quot;pad was not linked, mark pending&quot;);
3952       if (GST_EVENT_TYPE (event) != GST_EVENT_EOS) {
3953         data-&gt;ret = GST_FLOW_OK;
3954         ev-&gt;received = TRUE;
3955       }
3956       break;
3957     default:
3958       GST_DEBUG_OBJECT (pad, &quot;result %s, mark pending events&quot;,
3959           gst_flow_get_name (data-&gt;ret));
3960       GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
3961       break;
3962   }
3963 
3964   if (data-&gt;ret != GST_FLOW_OK &amp;&amp; GST_EVENT_TYPE (event) == GST_EVENT_EOS)
3965     data-&gt;was_eos = TRUE;
3966 
3967   return data-&gt;ret == GST_FLOW_OK;
3968 }
3969 
3970 /* check sticky events and push them when needed. should be called
3971  * with pad LOCK */
3972 static inline GstFlowReturn
3973 check_sticky (GstPad * pad, GstEvent * event)
3974 {
3975   PushStickyData data = { GST_FLOW_OK, FALSE, event };
3976 
3977   if (G_UNLIKELY (GST_PAD_HAS_PENDING_EVENTS (pad))) {
3978     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_PENDING_EVENTS);
3979 
3980     GST_DEBUG_OBJECT (pad, &quot;pushing all sticky events&quot;);
3981     events_foreach (pad, push_sticky, &amp;data);
3982 
3983     /* If there&#39;s an EOS event we must push it downstream
3984      * even if sending a previous sticky event failed.
3985      * Otherwise the pipeline might wait forever for EOS.
3986      *
3987      * Only do this if pushing another event than the EOS
3988      * event failed.
3989      */
3990     if (data.ret != GST_FLOW_OK &amp;&amp; !data.was_eos) {
3991       PadEvent *ev = find_event_by_type (pad, GST_EVENT_EOS, 0);
3992 
3993       if (ev &amp;&amp; !ev-&gt;received) {
3994         data.ret = gst_pad_push_event_unchecked (pad, gst_event_ref (ev-&gt;event),
3995             GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM);
3996         /* the event could have been dropped. Because this can only
3997          * happen if the user asked for it, it&#39;s not an error */
3998         if (data.ret == GST_FLOW_CUSTOM_SUCCESS)
3999           data.ret = GST_FLOW_OK;
4000       }
4001     }
4002   }
4003   return data.ret;
4004 }
4005 
4006 
4007 /**
4008  * gst_pad_query:
4009  * @pad: a #GstPad to invoke the default query on.
4010  * @query: (transfer none): the #GstQuery to perform.
4011  *
4012  * Dispatches a query to a pad. The query should have been allocated by the
4013  * caller via one of the type-specific allocation functions. The element that
4014  * the pad belongs to is responsible for filling the query with an appropriate
4015  * response, which should then be parsed with a type-specific query parsing
4016  * function.
4017  *
4018  * Again, the caller is responsible for both the allocation and deallocation of
4019  * the query structure.
4020  *
4021  * Please also note that some queries might need a running pipeline to work.
4022  *
4023  * Returns: %TRUE if the query could be performed.
4024  */
4025 gboolean
4026 gst_pad_query (GstPad * pad, GstQuery * query)
4027 {
4028   GstObject *parent;
4029   gboolean res, serialized;
4030   GstPadQueryFunction func;
4031   GstPadProbeType type;
4032   GstFlowReturn ret;
4033 
4034   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
4035   g_return_val_if_fail (GST_IS_QUERY (query), FALSE);
4036 
4037   if (GST_PAD_IS_SRC (pad)) {
4038     if (G_UNLIKELY (!GST_QUERY_IS_UPSTREAM (query)))
4039       goto wrong_direction;
4040     type = GST_PAD_PROBE_TYPE_QUERY_UPSTREAM;
4041   } else if (GST_PAD_IS_SINK (pad)) {
4042     if (G_UNLIKELY (!GST_QUERY_IS_DOWNSTREAM (query)))
4043       goto wrong_direction;
4044     type = GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM;
4045   } else
4046     goto unknown_direction;
4047 
4048   GST_DEBUG_OBJECT (pad, &quot;doing query %p (%s)&quot;, query,
4049       GST_QUERY_TYPE_NAME (query));
4050   GST_TRACER_PAD_QUERY_PRE (pad, query);
4051 
4052   serialized = GST_QUERY_IS_SERIALIZED (query);
4053   if (G_UNLIKELY (serialized))
4054     GST_PAD_STREAM_LOCK (pad);
4055 
4056   GST_OBJECT_LOCK (pad);
4057   PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PUSH |
4058       GST_PAD_PROBE_TYPE_BLOCK, query, probe_stopped);
4059   PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PUSH, query, probe_stopped);
4060 
4061   ACQUIRE_PARENT (pad, parent, no_parent);
4062   GST_OBJECT_UNLOCK (pad);
4063 
4064   if ((func = GST_PAD_QUERYFUNC (pad)) == NULL)
4065     goto no_func;
4066 
4067   res = func (pad, parent, query);
4068 
4069   RELEASE_PARENT (parent);
4070 
4071   GST_DEBUG_OBJECT (pad, &quot;sent query %p (%s), result %d&quot;, query,
4072       GST_QUERY_TYPE_NAME (query), res);
4073   GST_TRACER_PAD_QUERY_POST (pad, query, res);
4074 
4075   if (res != TRUE)
4076     goto query_failed;
4077 
4078   GST_OBJECT_LOCK (pad);
4079   PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PULL, query, probe_stopped);
4080   GST_OBJECT_UNLOCK (pad);
4081 
4082   if (G_UNLIKELY (serialized))
4083     GST_PAD_STREAM_UNLOCK (pad);
4084 
4085   return res;
4086 
4087   /* ERRORS */
4088 wrong_direction:
4089   {
4090     g_warning (&quot;pad %s:%s query %s in wrong direction&quot;,
4091         GST_DEBUG_PAD_NAME (pad), GST_QUERY_TYPE_NAME (query));
4092     return FALSE;
4093   }
4094 unknown_direction:
4095   {
4096     g_warning (&quot;pad %s:%s has invalid direction&quot;, GST_DEBUG_PAD_NAME (pad));
4097     return FALSE;
4098   }
4099 no_parent:
4100   {
4101     GST_DEBUG_OBJECT (pad, &quot;had no parent&quot;);
4102     GST_OBJECT_UNLOCK (pad);
4103     if (G_UNLIKELY (serialized))
4104       GST_PAD_STREAM_UNLOCK (pad);
4105     return FALSE;
4106   }
4107 no_func:
4108   {
4109     GST_DEBUG_OBJECT (pad, &quot;had no query function&quot;);
4110     RELEASE_PARENT (parent);
4111     if (G_UNLIKELY (serialized))
4112       GST_PAD_STREAM_UNLOCK (pad);
4113     return FALSE;
4114   }
4115 query_failed:
4116   {
4117     GST_DEBUG_OBJECT (pad, &quot;query failed&quot;);
4118     if (G_UNLIKELY (serialized))
4119       GST_PAD_STREAM_UNLOCK (pad);
4120     return FALSE;
4121   }
4122 probe_stopped:
4123   {
4124     GST_DEBUG_OBJECT (pad, &quot;probe stopped: %s&quot;, gst_flow_get_name (ret));
4125     GST_OBJECT_UNLOCK (pad);
4126     if (G_UNLIKELY (serialized))
4127       GST_PAD_STREAM_UNLOCK (pad);
4128 
4129     /* if a probe dropped without handling, we don&#39;t sent it further but assume
4130      * that the probe did not answer the query and return FALSE */
4131     if (ret != GST_FLOW_CUSTOM_SUCCESS_1)
4132       res = FALSE;
4133     else
4134       res = TRUE;
4135 
4136     return res;
4137   }
4138 }
4139 
4140 /**
4141  * gst_pad_peer_query:
4142  * @pad: a #GstPad to invoke the peer query on.
4143  * @query: (transfer none): the #GstQuery to perform.
4144  *
4145  * Performs gst_pad_query() on the peer of @pad.
4146  *
4147  * The caller is responsible for both the allocation and deallocation of
4148  * the query structure.
4149  *
4150  * Returns: %TRUE if the query could be performed. This function returns %FALSE
4151  * if @pad has no peer.
4152  */
4153 gboolean
4154 gst_pad_peer_query (GstPad * pad, GstQuery * query)
4155 {
4156   GstPad *peerpad;
4157   GstPadProbeType type;
4158   gboolean res, serialized;
4159   GstFlowReturn ret;
4160 
4161   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
4162   g_return_val_if_fail (GST_IS_QUERY (query), FALSE);
4163 
4164   if (GST_PAD_IS_SRC (pad)) {
4165     if (G_UNLIKELY (!GST_QUERY_IS_DOWNSTREAM (query)))
4166       goto wrong_direction;
4167     type = GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM;
4168   } else if (GST_PAD_IS_SINK (pad)) {
4169     if (G_UNLIKELY (!GST_QUERY_IS_UPSTREAM (query)))
4170       goto wrong_direction;
4171     type = GST_PAD_PROBE_TYPE_QUERY_UPSTREAM;
4172   } else
4173     goto unknown_direction;
4174 
4175   GST_DEBUG_OBJECT (pad, &quot;peer query %p (%s)&quot;, query,
4176       GST_QUERY_TYPE_NAME (query));
4177 
4178   serialized = GST_QUERY_IS_SERIALIZED (query);
4179 
4180   GST_OBJECT_LOCK (pad);
4181   if (GST_PAD_IS_SRC (pad) &amp;&amp; serialized) {
4182     /* all serialized queries on the srcpad trigger push of
4183      * sticky events */
4184     if (check_sticky (pad, NULL) != GST_FLOW_OK)
4185       goto sticky_failed;
4186   }
4187 
4188   PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PUSH |
4189       GST_PAD_PROBE_TYPE_BLOCK, query, probe_stopped);
4190   PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PUSH, query, probe_stopped);
4191 
4192   peerpad = GST_PAD_PEER (pad);
4193   if (G_UNLIKELY (peerpad == NULL))
4194     goto no_peer;
4195 
4196   gst_object_ref (peerpad);
4197   GST_OBJECT_UNLOCK (pad);
4198 
4199   res = gst_pad_query (peerpad, query);
4200 
4201   gst_object_unref (peerpad);
4202 
4203   if (res != TRUE)
4204     goto query_failed;
4205 
4206   GST_OBJECT_LOCK (pad);
4207   PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PULL, query, probe_stopped);
4208   GST_OBJECT_UNLOCK (pad);
4209 
4210   return res;
4211 
4212   /* ERRORS */
4213 wrong_direction:
4214   {
4215     g_warning (&quot;pad %s:%s query %s in wrong direction&quot;,
4216         GST_DEBUG_PAD_NAME (pad), GST_QUERY_TYPE_NAME (query));
4217     return FALSE;
4218   }
4219 unknown_direction:
4220   {
4221     g_warning (&quot;pad %s:%s has invalid direction&quot;, GST_DEBUG_PAD_NAME (pad));
4222     return FALSE;
4223   }
4224 sticky_failed:
4225   {
4226     GST_WARNING_OBJECT (pad, &quot;could not send sticky events&quot;);
4227     GST_OBJECT_UNLOCK (pad);
4228     return FALSE;
4229   }
4230 no_peer:
4231   {
4232     GST_INFO_OBJECT (pad, &quot;pad has no peer&quot;);
4233     GST_OBJECT_UNLOCK (pad);
4234     return FALSE;
4235   }
4236 query_failed:
4237   {
4238     GST_DEBUG_OBJECT (pad, &quot;query failed&quot;);
4239     return FALSE;
4240   }
4241 probe_stopped:
4242   {
4243     GST_DEBUG_OBJECT (pad, &quot;probe stopped: %s&quot;, gst_flow_get_name (ret));
4244     GST_OBJECT_UNLOCK (pad);
4245 
4246     /* if a probe dropped without handling, we don&#39;t sent it further but
4247      * assume that the probe did not answer the query and return FALSE */
4248     if (ret != GST_FLOW_CUSTOM_SUCCESS_1)
4249       res = FALSE;
4250     else
4251       res = TRUE;
4252 
4253     return res;
4254   }
4255 }
4256 
4257 /**********************************************************************
4258  * Data passing functions
4259  */
4260 
4261 /* this is the chain function that does not perform the additional argument
4262  * checking for that little extra speed.
4263  */
4264 static inline GstFlowReturn
4265 gst_pad_chain_data_unchecked (GstPad * pad, GstPadProbeType type, void *data)
4266 {
4267   GstFlowReturn ret;
4268   GstObject *parent;
4269   gboolean handled = FALSE;
4270 
4271   GST_PAD_STREAM_LOCK (pad);
4272 
4273   GST_OBJECT_LOCK (pad);
4274   if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
4275     goto flushing;
4276 
4277   if (G_UNLIKELY (GST_PAD_IS_EOS (pad)))
4278     goto eos;
4279 
4280   if (G_UNLIKELY (GST_PAD_MODE (pad) != GST_PAD_MODE_PUSH))
4281     goto wrong_mode;
4282 
4283 #ifdef GST_ENABLE_EXTRA_CHECKS
4284   if (G_UNLIKELY (pad-&gt;priv-&gt;last_cookie != pad-&gt;priv-&gt;events_cookie)) {
4285     if (!find_event_by_type (pad, GST_EVENT_STREAM_START, 0)) {
4286       g_warning (G_STRLOC
4287           &quot;:%s:&lt;%s:%s&gt; Got data flow before stream-start event&quot;,
4288           G_STRFUNC, GST_DEBUG_PAD_NAME (pad));
4289     }
4290     if (!find_event_by_type (pad, GST_EVENT_SEGMENT, 0)) {
4291       g_warning (G_STRLOC
4292           &quot;:%s:&lt;%s:%s&gt; Got data flow before segment event&quot;,
4293           G_STRFUNC, GST_DEBUG_PAD_NAME (pad));
4294     }
4295     pad-&gt;priv-&gt;last_cookie = pad-&gt;priv-&gt;events_cookie;
4296   }
4297 #endif
4298 
4299   PROBE_HANDLE (pad, type | GST_PAD_PROBE_TYPE_BLOCK, data, probe_stopped,
4300       probe_handled);
4301 
4302   PROBE_HANDLE (pad, type, data, probe_stopped, probe_handled);
4303 
4304   ACQUIRE_PARENT (pad, parent, no_parent);
4305   GST_OBJECT_UNLOCK (pad);
4306 
4307   /* NOTE: we read the chainfunc unlocked.
4308    * we cannot hold the lock for the pad so we might send
4309    * the data to the wrong function. This is not really a
4310    * problem since functions are assigned at creation time
4311    * and don&#39;t change that often... */
4312   if (G_LIKELY (type &amp; GST_PAD_PROBE_TYPE_BUFFER)) {
4313     GstPadChainFunction chainfunc;
4314 
4315     if (G_UNLIKELY ((chainfunc = GST_PAD_CHAINFUNC (pad)) == NULL))
4316       goto no_function;
4317 
4318     GST_CAT_DEBUG_OBJECT (GST_CAT_SCHEDULING, pad,
4319         &quot;calling chainfunction &amp;%s with buffer %&quot; GST_PTR_FORMAT,
4320         GST_DEBUG_FUNCPTR_NAME (chainfunc), GST_BUFFER (data));
4321 
4322     ret = chainfunc (pad, parent, GST_BUFFER_CAST (data));
4323 
4324     GST_CAT_DEBUG_OBJECT (GST_CAT_SCHEDULING, pad,
4325         &quot;called chainfunction &amp;%s with buffer %p, returned %s&quot;,
4326         GST_DEBUG_FUNCPTR_NAME (chainfunc), data, gst_flow_get_name (ret));
4327   } else {
4328     GstPadChainListFunction chainlistfunc;
4329 
4330     if (G_UNLIKELY ((chainlistfunc = GST_PAD_CHAINLISTFUNC (pad)) == NULL))
4331       goto no_function;
4332 
4333     GST_CAT_DEBUG_OBJECT (GST_CAT_SCHEDULING, pad,
4334         &quot;calling chainlistfunction &amp;%s&quot;,
4335         GST_DEBUG_FUNCPTR_NAME (chainlistfunc));
4336 
4337     ret = chainlistfunc (pad, parent, GST_BUFFER_LIST_CAST (data));
4338 
4339     GST_CAT_DEBUG_OBJECT (GST_CAT_SCHEDULING, pad,
4340         &quot;called chainlistfunction &amp;%s, returned %s&quot;,
4341         GST_DEBUG_FUNCPTR_NAME (chainlistfunc), gst_flow_get_name (ret));
4342   }
4343 
4344   RELEASE_PARENT (parent);
4345 
4346   GST_PAD_STREAM_UNLOCK (pad);
4347 
4348   return ret;
4349 
4350   /* ERRORS */
4351 flushing:
4352   {
4353     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4354         &quot;chaining, but pad was flushing&quot;);
4355     GST_OBJECT_UNLOCK (pad);
4356     GST_PAD_STREAM_UNLOCK (pad);
4357     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4358     return GST_FLOW_FLUSHING;
4359   }
4360 eos:
4361   {
4362     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;chaining, but pad was EOS&quot;);
4363     GST_OBJECT_UNLOCK (pad);
4364     GST_PAD_STREAM_UNLOCK (pad);
4365     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4366     return GST_FLOW_EOS;
4367   }
4368 wrong_mode:
4369   {
4370     g_critical (&quot;chain on pad %s:%s but it was not in push mode&quot;,
4371         GST_DEBUG_PAD_NAME (pad));
4372     GST_OBJECT_UNLOCK (pad);
4373     GST_PAD_STREAM_UNLOCK (pad);
4374     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4375     return GST_FLOW_ERROR;
4376   }
4377 probe_handled:
4378   handled = TRUE;
4379   /* PASSTHROUGH */
4380 probe_stopped:
4381   {
4382     GST_OBJECT_UNLOCK (pad);
4383     GST_PAD_STREAM_UNLOCK (pad);
4384     /* We unref the buffer, except if the probe handled it (CUSTOM_SUCCESS_1) */
4385     if (!handled)
<a name="49" id="anc49"></a><span class="line-modified">4386     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));</span>
4387 
4388     switch (ret) {
4389       case GST_FLOW_CUSTOM_SUCCESS:
4390       case GST_FLOW_CUSTOM_SUCCESS_1:
4391         GST_DEBUG_OBJECT (pad, &quot;dropped or handled buffer&quot;);
4392         ret = GST_FLOW_OK;
4393         break;
4394       default:
4395         GST_DEBUG_OBJECT (pad, &quot;an error occurred %s&quot;, gst_flow_get_name (ret));
4396         break;
4397     }
4398     return ret;
4399   }
4400 no_parent:
4401   {
4402     GST_DEBUG_OBJECT (pad, &quot;No parent when chaining %&quot; GST_PTR_FORMAT, data);
4403     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4404     GST_OBJECT_UNLOCK (pad);
4405     GST_PAD_STREAM_UNLOCK (pad);
4406     return GST_FLOW_FLUSHING;
4407   }
4408 no_function:
4409   {
4410     RELEASE_PARENT (parent);
4411     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4412     g_critical (&quot;chain on pad %s:%s but it has no chainfunction&quot;,
4413         GST_DEBUG_PAD_NAME (pad));
4414     GST_PAD_STREAM_UNLOCK (pad);
4415     return GST_FLOW_NOT_SUPPORTED;
4416   }
4417 }
4418 
4419 /**
4420  * gst_pad_chain:
4421  * @pad: a sink #GstPad, returns GST_FLOW_ERROR if not.
4422  * @buffer: (transfer full): the #GstBuffer to send, return GST_FLOW_ERROR
4423  *     if not.
4424  *
4425  * Chain a buffer to @pad.
4426  *
4427  * The function returns #GST_FLOW_FLUSHING if the pad was flushing.
4428  *
4429  * If the buffer type is not acceptable for @pad (as negotiated with a
4430  * preceding GST_EVENT_CAPS event), this function returns
4431  * #GST_FLOW_NOT_NEGOTIATED.
4432  *
4433  * The function proceeds calling the chain function installed on @pad (see
4434  * gst_pad_set_chain_function()) and the return value of that function is
4435  * returned to the caller. #GST_FLOW_NOT_SUPPORTED is returned if @pad has no
4436  * chain function.
4437  *
4438  * In all cases, success or failure, the caller loses its reference to @buffer
4439  * after calling this function.
4440  *
4441  * Returns: a #GstFlowReturn from the pad.
4442  *
4443  * MT safe.
4444  */
4445 GstFlowReturn
4446 gst_pad_chain (GstPad * pad, GstBuffer * buffer)
4447 {
4448   g_return_val_if_fail (GST_IS_PAD (pad), GST_FLOW_ERROR);
4449   g_return_val_if_fail (GST_PAD_IS_SINK (pad), GST_FLOW_ERROR);
4450   g_return_val_if_fail (GST_IS_BUFFER (buffer), GST_FLOW_ERROR);
4451 
4452   return gst_pad_chain_data_unchecked (pad,
4453       GST_PAD_PROBE_TYPE_BUFFER | GST_PAD_PROBE_TYPE_PUSH, buffer);
4454 }
4455 
4456 static GstFlowReturn
4457 gst_pad_chain_list_default (GstPad * pad, GstObject * parent,
4458     GstBufferList * list)
4459 {
4460   guint i, len;
4461   GstBuffer *buffer;
4462   GstFlowReturn ret;
4463 
4464   GST_INFO_OBJECT (pad, &quot;chaining each buffer in list individually&quot;);
4465 
4466   len = gst_buffer_list_length (list);
4467 
4468   ret = GST_FLOW_OK;
4469   for (i = 0; i &lt; len; i++) {
4470     buffer = gst_buffer_list_get (list, i);
4471     ret =
4472         gst_pad_chain_data_unchecked (pad,
4473         GST_PAD_PROBE_TYPE_BUFFER | GST_PAD_PROBE_TYPE_PUSH,
4474         gst_buffer_ref (buffer));
4475     if (ret != GST_FLOW_OK)
4476       break;
4477   }
4478   gst_buffer_list_unref (list);
4479 
4480   return ret;
4481 }
4482 
4483 /**
4484  * gst_pad_chain_list:
4485  * @pad: a sink #GstPad, returns GST_FLOW_ERROR if not.
4486  * @list: (transfer full): the #GstBufferList to send, return GST_FLOW_ERROR
4487  *     if not.
4488  *
4489  * Chain a bufferlist to @pad.
4490  *
4491  * The function returns #GST_FLOW_FLUSHING if the pad was flushing.
4492  *
4493  * If @pad was not negotiated properly with a CAPS event, this function
4494  * returns #GST_FLOW_NOT_NEGOTIATED.
4495  *
4496  * The function proceeds calling the chainlist function installed on @pad (see
4497  * gst_pad_set_chain_list_function()) and the return value of that function is
4498  * returned to the caller. #GST_FLOW_NOT_SUPPORTED is returned if @pad has no
4499  * chainlist function.
4500  *
4501  * In all cases, success or failure, the caller loses its reference to @list
4502  * after calling this function.
4503  *
4504  * MT safe.
4505  *
4506  * Returns: a #GstFlowReturn from the pad.
4507  */
4508 GstFlowReturn
4509 gst_pad_chain_list (GstPad * pad, GstBufferList * list)
4510 {
4511   g_return_val_if_fail (GST_IS_PAD (pad), GST_FLOW_ERROR);
4512   g_return_val_if_fail (GST_PAD_IS_SINK (pad), GST_FLOW_ERROR);
4513   g_return_val_if_fail (GST_IS_BUFFER_LIST (list), GST_FLOW_ERROR);
4514 
4515   return gst_pad_chain_data_unchecked (pad,
4516       GST_PAD_PROBE_TYPE_BUFFER_LIST | GST_PAD_PROBE_TYPE_PUSH, list);
4517 }
4518 
4519 static GstFlowReturn
4520 gst_pad_push_data (GstPad * pad, GstPadProbeType type, void *data)
4521 {
4522   GstPad *peer;
4523   GstFlowReturn ret;
4524   gboolean handled = FALSE;
4525 
4526   GST_OBJECT_LOCK (pad);
4527   if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
4528     goto flushing;
4529 
4530   if (G_UNLIKELY (GST_PAD_IS_EOS (pad)))
4531     goto eos;
4532 
4533   if (G_UNLIKELY (GST_PAD_MODE (pad) != GST_PAD_MODE_PUSH))
4534     goto wrong_mode;
4535 
4536 #ifdef GST_ENABLE_EXTRA_CHECKS
4537   if (G_UNLIKELY (pad-&gt;priv-&gt;last_cookie != pad-&gt;priv-&gt;events_cookie)) {
4538     if (!find_event_by_type (pad, GST_EVENT_STREAM_START, 0)) {
4539       g_warning (G_STRLOC
4540           &quot;:%s:&lt;%s:%s&gt; Got data flow before stream-start event&quot;,
4541           G_STRFUNC, GST_DEBUG_PAD_NAME (pad));
4542     }
4543     if (!find_event_by_type (pad, GST_EVENT_SEGMENT, 0)) {
4544       g_warning (G_STRLOC
4545           &quot;:%s:&lt;%s:%s&gt; Got data flow before segment event&quot;,
4546           G_STRFUNC, GST_DEBUG_PAD_NAME (pad));
4547     }
4548     pad-&gt;priv-&gt;last_cookie = pad-&gt;priv-&gt;events_cookie;
4549   }
4550 #endif
4551 
4552   if (G_UNLIKELY ((ret = check_sticky (pad, NULL))) != GST_FLOW_OK)
4553     goto events_error;
4554 
4555   /* do block probes */
4556   PROBE_HANDLE (pad, type | GST_PAD_PROBE_TYPE_BLOCK, data, probe_stopped,
4557       probe_handled);
4558 
4559   /* recheck sticky events because the probe might have cause a relink */
4560   if (G_UNLIKELY ((ret = check_sticky (pad, NULL))) != GST_FLOW_OK)
4561     goto events_error;
4562 
4563   /* do post-blocking probes */
4564   PROBE_HANDLE (pad, type, data, probe_stopped, probe_handled);
4565 
4566   /* recheck sticky events because the probe might have cause a relink */
4567   if (G_UNLIKELY ((ret = check_sticky (pad, NULL))) != GST_FLOW_OK)
4568     goto events_error;
4569 
4570   if (G_UNLIKELY ((peer = GST_PAD_PEER (pad)) == NULL))
4571     goto not_linked;
4572 
4573   /* take ref to peer pad before releasing the lock */
4574   gst_object_ref (peer);
4575   pad-&gt;priv-&gt;using++;
4576   GST_OBJECT_UNLOCK (pad);
4577 
4578   ret = gst_pad_chain_data_unchecked (peer, type, data);
4579   data = NULL;
4580 
4581   gst_object_unref (peer);
4582 
4583   GST_OBJECT_LOCK (pad);
4584   pad-&gt;ABI.abi.last_flowret = ret;
4585   pad-&gt;priv-&gt;using--;
4586   if (pad-&gt;priv-&gt;using == 0) {
4587     /* pad is not active anymore, trigger idle callbacks */
4588     PROBE_NO_DATA (pad, GST_PAD_PROBE_TYPE_PUSH | GST_PAD_PROBE_TYPE_IDLE,
4589         probe_stopped, ret);
4590   }
4591   GST_OBJECT_UNLOCK (pad);
4592 
4593   return ret;
4594 
4595   /* ERROR recovery here */
4596   /* ERRORS */
4597 flushing:
4598   {
4599     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4600         &quot;pushing, but pad was flushing&quot;);
4601     pad-&gt;ABI.abi.last_flowret = GST_FLOW_FLUSHING;
4602     GST_OBJECT_UNLOCK (pad);
4603     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4604     return GST_FLOW_FLUSHING;
4605   }
4606 eos:
4607   {
4608     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;pushing, but pad was EOS&quot;);
4609     pad-&gt;ABI.abi.last_flowret = GST_FLOW_EOS;
4610     GST_OBJECT_UNLOCK (pad);
4611     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4612     return GST_FLOW_EOS;
4613   }
4614 wrong_mode:
4615   {
4616     g_critical (&quot;pushing on pad %s:%s but it was not activated in push mode&quot;,
4617         GST_DEBUG_PAD_NAME (pad));
4618     pad-&gt;ABI.abi.last_flowret = GST_FLOW_ERROR;
4619     GST_OBJECT_UNLOCK (pad);
4620     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4621     return GST_FLOW_ERROR;
4622   }
4623 events_error:
4624   {
4625     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4626         &quot;error pushing events, return %s&quot;, gst_flow_get_name (ret));
4627     pad-&gt;ABI.abi.last_flowret = ret;
4628     GST_OBJECT_UNLOCK (pad);
4629     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4630     return ret;
4631   }
4632 probe_handled:
4633   handled = TRUE;
4634   /* PASSTHROUGH */
4635 probe_stopped:
4636   {
4637     GST_OBJECT_UNLOCK (pad);
4638     if (data != NULL &amp;&amp; !handled)
<a name="50" id="anc50"></a><span class="line-modified">4639     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));</span>
4640 
4641     switch (ret) {
4642       case GST_FLOW_CUSTOM_SUCCESS:
4643       case GST_FLOW_CUSTOM_SUCCESS_1:
4644         GST_DEBUG_OBJECT (pad, &quot;dropped or handled buffer&quot;);
4645         ret = GST_FLOW_OK;
4646         break;
4647       default:
4648         GST_DEBUG_OBJECT (pad, &quot;an error occurred %s&quot;, gst_flow_get_name (ret));
4649         break;
4650     }
4651     pad-&gt;ABI.abi.last_flowret = ret;
4652     return ret;
4653   }
4654 not_linked:
4655   {
4656     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4657         &quot;pushing, but it was not linked&quot;);
4658     pad-&gt;ABI.abi.last_flowret = GST_FLOW_NOT_LINKED;
4659     GST_OBJECT_UNLOCK (pad);
4660     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4661     return GST_FLOW_NOT_LINKED;
4662   }
4663 }
4664 
4665 /**
4666  * gst_pad_push:
4667  * @pad: a source #GstPad, returns #GST_FLOW_ERROR if not.
4668  * @buffer: (transfer full): the #GstBuffer to push returns GST_FLOW_ERROR
4669  *     if not.
4670  *
4671  * Pushes a buffer to the peer of @pad.
4672  *
4673  * This function will call installed block probes before triggering any
4674  * installed data probes.
4675  *
4676  * The function proceeds calling gst_pad_chain() on the peer pad and returns
4677  * the value from that function. If @pad has no peer, #GST_FLOW_NOT_LINKED will
4678  * be returned.
4679  *
4680  * In all cases, success or failure, the caller loses its reference to @buffer
4681  * after calling this function.
4682  *
4683  * Returns: a #GstFlowReturn from the peer pad.
4684  *
4685  * MT safe.
4686  */
4687 GstFlowReturn
4688 gst_pad_push (GstPad * pad, GstBuffer * buffer)
4689 {
4690   GstFlowReturn res;
4691 
4692   g_return_val_if_fail (GST_IS_PAD (pad), GST_FLOW_ERROR);
4693   g_return_val_if_fail (GST_PAD_IS_SRC (pad), GST_FLOW_ERROR);
4694   g_return_val_if_fail (GST_IS_BUFFER (buffer), GST_FLOW_ERROR);
4695 
4696   GST_TRACER_PAD_PUSH_PRE (pad, buffer);
4697   res = gst_pad_push_data (pad,
4698       GST_PAD_PROBE_TYPE_BUFFER | GST_PAD_PROBE_TYPE_PUSH, buffer);
4699   GST_TRACER_PAD_PUSH_POST (pad, res);
4700   return res;
4701 }
4702 
4703 /**
4704  * gst_pad_push_list:
4705  * @pad: a source #GstPad, returns #GST_FLOW_ERROR if not.
4706  * @list: (transfer full): the #GstBufferList to push returns GST_FLOW_ERROR
4707  *     if not.
4708  *
4709  * Pushes a buffer list to the peer of @pad.
4710  *
4711  * This function will call installed block probes before triggering any
4712  * installed data probes.
4713  *
4714  * The function proceeds calling the chain function on the peer pad and returns
4715  * the value from that function. If @pad has no peer, #GST_FLOW_NOT_LINKED will
4716  * be returned. If the peer pad does not have any installed chainlist function
4717  * every group buffer of the list will be merged into a normal #GstBuffer and
4718  * chained via gst_pad_chain().
4719  *
4720  * In all cases, success or failure, the caller loses its reference to @list
4721  * after calling this function.
4722  *
4723  * Returns: a #GstFlowReturn from the peer pad.
4724  *
4725  * MT safe.
4726  */
4727 GstFlowReturn
4728 gst_pad_push_list (GstPad * pad, GstBufferList * list)
4729 {
4730   GstFlowReturn res;
4731 
4732   g_return_val_if_fail (GST_IS_PAD (pad), GST_FLOW_ERROR);
4733   g_return_val_if_fail (GST_PAD_IS_SRC (pad), GST_FLOW_ERROR);
4734   g_return_val_if_fail (GST_IS_BUFFER_LIST (list), GST_FLOW_ERROR);
4735 
4736   GST_TRACER_PAD_PUSH_LIST_PRE (pad, list);
4737   res = gst_pad_push_data (pad,
4738       GST_PAD_PROBE_TYPE_BUFFER_LIST | GST_PAD_PROBE_TYPE_PUSH, list);
4739   GST_TRACER_PAD_PUSH_LIST_POST (pad, res);
4740   return res;
4741 }
4742 
4743 static GstFlowReturn
4744 gst_pad_get_range_unchecked (GstPad * pad, guint64 offset, guint size,
4745     GstBuffer ** buffer)
4746 {
4747   GstFlowReturn ret;
4748   GstPadGetRangeFunction getrangefunc;
4749   GstObject *parent;
4750   GstBuffer *res_buf;
4751 
4752   GST_PAD_STREAM_LOCK (pad);
4753 
4754   GST_OBJECT_LOCK (pad);
4755   if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
4756     goto flushing;
4757 
4758   if (G_UNLIKELY (GST_PAD_MODE (pad) != GST_PAD_MODE_PULL))
4759     goto wrong_mode;
4760 
4761   if (G_UNLIKELY ((ret = check_sticky (pad, NULL))) != GST_FLOW_OK)
4762     goto events_error;
4763 
4764   res_buf = *buffer;
4765 
4766   /* when one of the probes returns DROPPED, probe_stopped will be called
4767    * and we skip calling the getrange function, res_buf should then contain a
4768    * valid result buffer */
4769   PROBE_PULL (pad, GST_PAD_PROBE_TYPE_PULL | GST_PAD_PROBE_TYPE_BLOCK,
4770       res_buf, offset, size, probe_stopped);
4771 
4772   /* recheck sticky events because the probe might have cause a relink */
4773   if (G_UNLIKELY ((ret = check_sticky (pad, NULL))) != GST_FLOW_OK)
4774     goto events_error;
4775 
4776   ACQUIRE_PARENT (pad, parent, no_parent);
4777   GST_OBJECT_UNLOCK (pad);
4778 
4779   if (G_UNLIKELY ((getrangefunc = GST_PAD_GETRANGEFUNC (pad)) == NULL))
4780     goto no_function;
4781 
4782   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4783       &quot;calling getrangefunc %s, offset %&quot;
4784       G_GUINT64_FORMAT &quot;, size %u&quot;,
4785       GST_DEBUG_FUNCPTR_NAME (getrangefunc), offset, size);
4786 
4787   ret = getrangefunc (pad, parent, offset, size, &amp;res_buf);
4788 
4789   RELEASE_PARENT (parent);
4790 
4791   GST_OBJECT_LOCK (pad);
4792   if (G_UNLIKELY (ret != GST_FLOW_OK))
4793     goto get_range_failed;
4794 
4795   /* can only fire the signal if we have a valid buffer */
4796 probed_data:
4797   PROBE_PULL (pad, GST_PAD_PROBE_TYPE_PULL | GST_PAD_PROBE_TYPE_BUFFER,
4798       res_buf, offset, size, probe_stopped_unref);
4799   pad-&gt;ABI.abi.last_flowret = ret;
4800   GST_OBJECT_UNLOCK (pad);
4801 
4802   GST_PAD_STREAM_UNLOCK (pad);
4803 
4804   *buffer = res_buf;
4805 
4806   return ret;
4807 
4808   /* ERRORS */
4809 flushing:
4810   {
4811     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4812         &quot;getrange, but pad was flushing&quot;);
4813     pad-&gt;ABI.abi.last_flowret = GST_FLOW_FLUSHING;
4814     GST_OBJECT_UNLOCK (pad);
4815     GST_PAD_STREAM_UNLOCK (pad);
4816     return GST_FLOW_FLUSHING;
4817   }
4818 wrong_mode:
4819   {
4820     g_critical (&quot;getrange on pad %s:%s but it was not activated in pull mode&quot;,
4821         GST_DEBUG_PAD_NAME (pad));
4822     pad-&gt;ABI.abi.last_flowret = GST_FLOW_ERROR;
4823     GST_OBJECT_UNLOCK (pad);
4824     GST_PAD_STREAM_UNLOCK (pad);
4825     return GST_FLOW_ERROR;
4826   }
4827 events_error:
4828   {
4829     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;error pushing events&quot;);
4830     pad-&gt;ABI.abi.last_flowret = ret;
4831     GST_OBJECT_UNLOCK (pad);
4832     GST_PAD_STREAM_UNLOCK (pad);
4833     return ret;
4834   }
4835 no_parent:
4836   {
4837     GST_DEBUG_OBJECT (pad, &quot;no parent&quot;);
4838     pad-&gt;ABI.abi.last_flowret = GST_FLOW_FLUSHING;
4839     GST_OBJECT_UNLOCK (pad);
4840     GST_PAD_STREAM_UNLOCK (pad);
4841     return GST_FLOW_FLUSHING;
4842   }
4843 no_function:
4844   {
4845     g_critical (&quot;getrange on pad %s:%s but it has no getrangefunction&quot;,
4846         GST_DEBUG_PAD_NAME (pad));
4847     RELEASE_PARENT (parent);
4848     GST_PAD_STREAM_UNLOCK (pad);
4849     return GST_FLOW_NOT_SUPPORTED;
4850   }
4851 probe_stopped:
4852   {
4853     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4854         &quot;probe returned %s&quot;, gst_flow_get_name (ret));
4855     if (ret == GST_FLOW_CUSTOM_SUCCESS) {
4856       if (res_buf) {
4857         /* the probe filled the buffer and asks us to not call the getrange
4858          * anymore, we continue with the post probes then. */
4859         GST_DEBUG_OBJECT (pad, &quot;handled buffer&quot;);
4860         ret = GST_FLOW_OK;
4861         goto probed_data;
4862       } else {
4863         /* no buffer, we are EOS */
4864         GST_DEBUG_OBJECT (pad, &quot;no buffer, return EOS&quot;);
4865         ret = GST_FLOW_EOS;
4866       }
4867     }
4868     pad-&gt;ABI.abi.last_flowret = ret;
4869     GST_OBJECT_UNLOCK (pad);
4870     GST_PAD_STREAM_UNLOCK (pad);
4871 
4872     return ret;
4873   }
4874 probe_stopped_unref:
4875   {
4876     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4877         &quot;probe returned %s&quot;, gst_flow_get_name (ret));
4878     /* if we drop here, it signals EOS */
4879     if (ret == GST_FLOW_CUSTOM_SUCCESS)
4880       ret = GST_FLOW_EOS;
4881     pad-&gt;ABI.abi.last_flowret = ret;
4882     GST_OBJECT_UNLOCK (pad);
4883     GST_PAD_STREAM_UNLOCK (pad);
4884     if (*buffer == NULL)
4885       gst_buffer_unref (res_buf);
4886     return ret;
4887   }
4888 get_range_failed:
4889   {
4890     pad-&gt;ABI.abi.last_flowret = ret;
4891     GST_OBJECT_UNLOCK (pad);
4892     GST_PAD_STREAM_UNLOCK (pad);
4893     GST_CAT_LEVEL_LOG (GST_CAT_SCHEDULING,
4894         (ret &gt;= GST_FLOW_EOS) ? GST_LEVEL_INFO : GST_LEVEL_WARNING,
4895         pad, &quot;getrange failed, flow: %s&quot;, gst_flow_get_name (ret));
4896     return ret;
4897   }
4898 }
4899 
4900 /**
4901  * gst_pad_get_range:
4902  * @pad: a src #GstPad, returns #GST_FLOW_ERROR if not.
4903  * @offset: The start offset of the buffer
4904  * @size: The length of the buffer
4905  * @buffer: (out callee-allocates): a pointer to hold the #GstBuffer,
4906  *     returns #GST_FLOW_ERROR if %NULL.
4907  *
4908  * When @pad is flushing this function returns #GST_FLOW_FLUSHING
4909  * immediately and @buffer is %NULL.
4910  *
4911  * Calls the getrange function of @pad, see #GstPadGetRangeFunction for a
4912  * description of a getrange function. If @pad has no getrange function
4913  * installed (see gst_pad_set_getrange_function()) this function returns
4914  * #GST_FLOW_NOT_SUPPORTED.
4915  *
4916  * If @buffer points to a variable holding %NULL, a valid new #GstBuffer will be
4917  * placed in @buffer when this function returns #GST_FLOW_OK. The new buffer
4918  * must be freed with gst_buffer_unref() after usage.
4919  *
4920  * When @buffer points to a variable that points to a valid #GstBuffer, the
4921  * buffer will be filled with the result data when this function returns
4922  * #GST_FLOW_OK. If the provided buffer is larger than @size, only
4923  * @size bytes will be filled in the result buffer and its size will be updated
4924  * accordingly.
4925  *
4926  * Note that less than @size bytes can be returned in @buffer when, for example,
4927  * an EOS condition is near or when @buffer is not large enough to hold @size
4928  * bytes. The caller should check the result buffer size to get the result size.
4929  *
4930  * When this function returns any other result value than #GST_FLOW_OK, @buffer
4931  * will be unchanged.
4932  *
4933  * This is a lowlevel function. Usually gst_pad_pull_range() is used.
4934  *
4935  * Returns: a #GstFlowReturn from the pad.
4936  *
4937  * MT safe.
4938  */
4939 GstFlowReturn
4940 gst_pad_get_range (GstPad * pad, guint64 offset, guint size,
4941     GstBuffer ** buffer)
4942 {
4943   g_return_val_if_fail (GST_IS_PAD (pad), GST_FLOW_ERROR);
4944   g_return_val_if_fail (GST_PAD_IS_SRC (pad), GST_FLOW_ERROR);
4945   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
4946   g_return_val_if_fail (*buffer == NULL || (GST_IS_BUFFER (*buffer)
4947           &amp;&amp; gst_buffer_get_size (*buffer) &gt;= size), GST_FLOW_ERROR);
4948 
4949   return gst_pad_get_range_unchecked (pad, offset, size, buffer);
4950 }
4951 
4952 /**
4953  * gst_pad_pull_range:
4954  * @pad: a sink #GstPad, returns GST_FLOW_ERROR if not.
4955  * @offset: The start offset of the buffer
4956  * @size: The length of the buffer
4957  * @buffer: (out callee-allocates): a pointer to hold the #GstBuffer, returns
4958  *     GST_FLOW_ERROR if %NULL.
4959  *
4960  * Pulls a @buffer from the peer pad or fills up a provided buffer.
4961  *
4962  * This function will first trigger the pad block signal if it was
4963  * installed.
4964  *
4965  * When @pad is not linked #GST_FLOW_NOT_LINKED is returned else this
4966  * function returns the result of gst_pad_get_range() on the peer pad.
4967  * See gst_pad_get_range() for a list of return values and for the
4968  * semantics of the arguments of this function.
4969  *
4970  * If @buffer points to a variable holding %NULL, a valid new #GstBuffer will be
4971  * placed in @buffer when this function returns #GST_FLOW_OK. The new buffer
4972  * must be freed with gst_buffer_unref() after usage. When this function
4973  * returns any other result value, @buffer will still point to %NULL.
4974  *
4975  * When @buffer points to a variable that points to a valid #GstBuffer, the
4976  * buffer will be filled with the result data when this function returns
4977  * #GST_FLOW_OK. When this function returns any other result value,
4978  * @buffer will be unchanged. If the provided buffer is larger than @size, only
4979  * @size bytes will be filled in the result buffer and its size will be updated
4980  * accordingly.
4981  *
4982  * Note that less than @size bytes can be returned in @buffer when, for example,
4983  * an EOS condition is near or when @buffer is not large enough to hold @size
4984  * bytes. The caller should check the result buffer size to get the result size.
4985  *
4986  * Returns: a #GstFlowReturn from the peer pad.
4987  *
4988  * MT safe.
4989  */
4990 GstFlowReturn
4991 gst_pad_pull_range (GstPad * pad, guint64 offset, guint size,
4992     GstBuffer ** buffer)
4993 {
4994   GstPad *peer;
4995   GstFlowReturn ret;
4996   GstBuffer *res_buf;
4997 
4998   g_return_val_if_fail (GST_IS_PAD (pad), GST_FLOW_ERROR);
4999   g_return_val_if_fail (GST_PAD_IS_SINK (pad), GST_FLOW_ERROR);
5000   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
5001   g_return_val_if_fail (*buffer == NULL || (GST_IS_BUFFER (*buffer)
5002           &amp;&amp; gst_buffer_get_size (*buffer) &gt;= size), GST_FLOW_ERROR);
5003 
5004   GST_TRACER_PAD_PULL_RANGE_PRE (pad, offset, size);
5005 
5006   GST_OBJECT_LOCK (pad);
5007   if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
5008     goto flushing;
5009 
5010   if (G_UNLIKELY (GST_PAD_MODE (pad) != GST_PAD_MODE_PULL))
5011     goto wrong_mode;
5012 
5013   res_buf = *buffer;
5014 
5015   /* when one of the probes returns DROPPED, probe_stopped will be
5016    * called and we skip calling the peer getrange function. *buffer should then
5017    * contain a valid buffer */
5018   PROBE_PULL (pad, GST_PAD_PROBE_TYPE_PULL | GST_PAD_PROBE_TYPE_BLOCK,
5019       res_buf, offset, size, probe_stopped);
5020 
5021   if (G_UNLIKELY ((peer = GST_PAD_PEER (pad)) == NULL))
5022     goto not_linked;
5023 
5024   gst_object_ref (peer);
5025   pad-&gt;priv-&gt;using++;
5026   GST_OBJECT_UNLOCK (pad);
5027 
5028   ret = gst_pad_get_range_unchecked (peer, offset, size, &amp;res_buf);
5029 
5030   gst_object_unref (peer);
5031 
5032   GST_OBJECT_LOCK (pad);
5033   pad-&gt;priv-&gt;using--;
5034   pad-&gt;ABI.abi.last_flowret = ret;
5035   if (pad-&gt;priv-&gt;using == 0) {
5036     /* pad is not active anymore, trigger idle callbacks */
5037     PROBE_NO_DATA (pad, GST_PAD_PROBE_TYPE_PULL | GST_PAD_PROBE_TYPE_IDLE,
5038         probe_stopped_unref, ret);
5039   }
5040 
5041   if (G_UNLIKELY (ret != GST_FLOW_OK))
5042     goto pull_range_failed;
5043 
5044 probed_data:
5045   PROBE_PULL (pad, GST_PAD_PROBE_TYPE_PULL | GST_PAD_PROBE_TYPE_BUFFER,
5046       res_buf, offset, size, probe_stopped_unref);
5047 
5048   GST_OBJECT_UNLOCK (pad);
5049 
5050   *buffer = res_buf;
5051 
5052   GST_TRACER_PAD_PULL_RANGE_POST (pad, *buffer, ret);
5053   return ret;
5054 
5055   /* ERROR recovery here */
5056 flushing:
5057   {
5058     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
5059         &quot;pullrange, but pad was flushing&quot;);
5060     pad-&gt;ABI.abi.last_flowret = GST_FLOW_FLUSHING;
5061     GST_OBJECT_UNLOCK (pad);
5062     ret = GST_FLOW_FLUSHING;
5063     goto done;
5064   }
5065 wrong_mode:
5066   {
5067     g_critical (&quot;pullrange on pad %s:%s but it was not activated in pull mode&quot;,
5068         GST_DEBUG_PAD_NAME (pad));
5069     pad-&gt;ABI.abi.last_flowret = GST_FLOW_ERROR;
5070     GST_OBJECT_UNLOCK (pad);
5071     ret = GST_FLOW_ERROR;
5072     goto done;
5073   }
5074 probe_stopped:
5075   {
5076     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;pre probe returned %s&quot;,
5077         gst_flow_get_name (ret));
5078     if (ret == GST_FLOW_CUSTOM_SUCCESS) {
5079       if (res_buf) {
5080         /* the probe filled the buffer and asks us to not forward to the peer
5081          * anymore, we continue with the post probes then */
5082         GST_DEBUG_OBJECT (pad, &quot;handled buffer&quot;);
5083         ret = GST_FLOW_OK;
5084         goto probed_data;
5085       } else {
5086         /* no buffer, we are EOS then */
5087         GST_DEBUG_OBJECT (pad, &quot;no buffer, return EOS&quot;);
5088         ret = GST_FLOW_EOS;
5089       }
5090     }
5091     pad-&gt;ABI.abi.last_flowret = ret;
5092     GST_OBJECT_UNLOCK (pad);
5093     goto done;
5094   }
5095 not_linked:
5096   {
5097     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
5098         &quot;pulling range, but it was not linked&quot;);
5099     pad-&gt;ABI.abi.last_flowret = GST_FLOW_NOT_LINKED;
5100     GST_OBJECT_UNLOCK (pad);
5101     ret = GST_FLOW_NOT_LINKED;
5102     goto done;
5103   }
5104 pull_range_failed:
5105   {
5106     pad-&gt;ABI.abi.last_flowret = ret;
5107     GST_OBJECT_UNLOCK (pad);
5108     GST_CAT_LEVEL_LOG (GST_CAT_SCHEDULING,
5109         (ret &gt;= GST_FLOW_EOS) ? GST_LEVEL_INFO : GST_LEVEL_WARNING,
5110         pad, &quot;pullrange failed, flow: %s&quot;, gst_flow_get_name (ret));
5111     goto done;
5112   }
5113 probe_stopped_unref:
5114   {
5115     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
5116         &quot;post probe returned %s&quot;, gst_flow_get_name (ret));
5117 
5118     /* if we drop here, it signals EOS */
5119     if (ret == GST_FLOW_CUSTOM_SUCCESS)
5120       ret = GST_FLOW_EOS;
5121 
5122     pad-&gt;ABI.abi.last_flowret = ret;
5123     GST_OBJECT_UNLOCK (pad);
5124 
5125     if (*buffer == NULL)
5126       gst_buffer_unref (res_buf);
5127     goto done;
5128   }
5129 done:
5130   GST_TRACER_PAD_PULL_RANGE_POST (pad, NULL, ret);
<a name="51" id="anc51"></a><span class="line-modified">5131     return ret;</span>
<span class="line-modified">5132   }</span>
5133 
5134 /* must be called with pad object lock */
5135 static GstFlowReturn
5136 store_sticky_event (GstPad * pad, GstEvent * event)
5137 {
5138   guint i, len;
5139   GstEventType type;
5140   GArray *events;
5141   gboolean res = FALSE;
5142   const gchar *name = NULL;
5143   gboolean insert = TRUE;
5144 
5145   type = GST_EVENT_TYPE (event);
5146 
5147   /* Store all sticky events except SEGMENT/EOS when we&#39;re flushing,
5148    * otherwise they can be dropped and nothing would ever resend them.
5149    * Only do that for activated pads though, everything else is a bug!
5150    */
5151   if (G_UNLIKELY (GST_PAD_MODE (pad) == GST_PAD_MODE_NONE
5152           || (GST_PAD_IS_FLUSHING (pad) &amp;&amp; (type == GST_EVENT_SEGMENT
5153                   || type == GST_EVENT_EOS))))
5154     goto flushed;
5155 
5156   /* Unset the EOS flag when received STREAM_START event, so pad can
5157    * store sticky event and then push it later */
5158   if (type == GST_EVENT_STREAM_START) {
5159     GST_LOG_OBJECT (pad, &quot;Removing pending EOS and StreamGroupDone events&quot;);
5160     remove_event_by_type (pad, GST_EVENT_EOS);
5161     remove_event_by_type (pad, GST_EVENT_STREAM_GROUP_DONE);
5162     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_EOS);
5163   }
5164 
5165   if (G_UNLIKELY (GST_PAD_IS_EOS (pad)))
5166     goto eos;
5167 
5168   if (type &amp; GST_EVENT_TYPE_STICKY_MULTI)
5169     name = gst_structure_get_name (gst_event_get_structure (event));
5170 
5171   events = pad-&gt;priv-&gt;events;
5172   len = events-&gt;len;
5173 
5174   for (i = 0; i &lt; len; i++) {
5175     PadEvent *ev = &amp;g_array_index (events, PadEvent, i);
5176 
5177     if (ev-&gt;event == NULL)
5178       continue;
5179 
5180     if (type == GST_EVENT_TYPE (ev-&gt;event)) {
5181       /* matching types, check matching name if needed */
5182       if (name &amp;&amp; !gst_event_has_name (ev-&gt;event, name))
5183         continue;
5184 
5185       /* overwrite */
5186       if ((res = gst_event_replace (&amp;ev-&gt;event, event)))
5187         ev-&gt;received = FALSE;
5188 
5189       insert = FALSE;
5190       break;
5191     }
5192 
5193     if (type &lt; GST_EVENT_TYPE (ev-&gt;event) || (type != GST_EVENT_TYPE (ev-&gt;event)
5194             &amp;&amp; GST_EVENT_TYPE (ev-&gt;event) == GST_EVENT_EOS)) {
5195       /* STREAM_START, CAPS and SEGMENT must be delivered in this order. By
5196        * storing the sticky ordered we can check that this is respected. */
5197       if (G_UNLIKELY (GST_EVENT_TYPE (ev-&gt;event) &lt;= GST_EVENT_SEGMENT
5198               || GST_EVENT_TYPE (ev-&gt;event) == GST_EVENT_EOS))
5199         g_warning (G_STRLOC
5200             &quot;:%s:&lt;%s:%s&gt; Sticky event misordering, got &#39;%s&#39; before &#39;%s&#39;&quot;,
5201             G_STRFUNC, GST_DEBUG_PAD_NAME (pad),
5202             gst_event_type_get_name (GST_EVENT_TYPE (ev-&gt;event)),
5203             gst_event_type_get_name (type));
5204       break;
5205     }
5206   }
5207   if (insert) {
5208     PadEvent ev;
5209     ev.event = gst_event_ref (event);
5210     ev.received = FALSE;
5211     g_array_insert_val (events, i, ev);
5212     res = TRUE;
5213   }
5214 
5215   if (res) {
5216     pad-&gt;priv-&gt;events_cookie++;
5217     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
5218 
5219     GST_LOG_OBJECT (pad, &quot;stored sticky event %s&quot;, GST_EVENT_TYPE_NAME (event));
5220 
5221     switch (GST_EVENT_TYPE (event)) {
5222       case GST_EVENT_CAPS:
5223         GST_OBJECT_UNLOCK (pad);
5224 
5225         GST_DEBUG_OBJECT (pad, &quot;notify caps&quot;);
5226         g_object_notify_by_pspec ((GObject *) pad, pspec_caps);
5227 
5228         GST_OBJECT_LOCK (pad);
5229         break;
5230       default:
5231         break;
5232     }
5233   }
5234   if (type == GST_EVENT_EOS) {
5235     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_EOS);
5236     pad-&gt;ABI.abi.last_flowret = GST_FLOW_EOS;
5237   }
5238 
5239   return GST_PAD_IS_FLUSHING (pad) ? GST_FLOW_FLUSHING : GST_FLOW_OK;
5240 
5241   /* ERRORS */
5242 flushed:
5243   {
5244     GST_DEBUG_OBJECT (pad, &quot;pad is flushing&quot;);
5245     return GST_FLOW_FLUSHING;
5246   }
5247 eos:
5248   {
5249     GST_DEBUG_OBJECT (pad, &quot;pad is EOS&quot;);
5250     return GST_FLOW_EOS;
5251   }
5252 }
5253 
5254 /**
5255  * gst_pad_store_sticky_event:
5256  * @pad: a #GstPad
5257  * @event: (transfer none): a #GstEvent
5258  *
5259  * Store the sticky @event on @pad
5260  *
5261  * Returns: #GST_FLOW_OK on success, #GST_FLOW_FLUSHING when the pad
5262  * was flushing or #GST_FLOW_EOS when the pad was EOS.
5263  *
5264  * Since: 1.2
5265  */
5266 GstFlowReturn
5267 gst_pad_store_sticky_event (GstPad * pad, GstEvent * event)
5268 {
5269   GstFlowReturn ret;
5270 
5271   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
5272   g_return_val_if_fail (GST_IS_EVENT (event), FALSE);
5273 
5274   GST_OBJECT_LOCK (pad);
5275   ret = store_sticky_event (pad, event);
5276   GST_OBJECT_UNLOCK (pad);
5277 
5278   return ret;
5279 }
5280 
5281 static gboolean
5282 sticky_changed (GstPad * pad, PadEvent * ev, gpointer user_data)
5283 {
5284   PushStickyData *data = user_data;
5285 
5286   /* Forward all sticky events before our current one that are pending */
5287   if (ev-&gt;event != data-&gt;event
5288       &amp;&amp; GST_EVENT_TYPE (ev-&gt;event) &lt; GST_EVENT_TYPE (data-&gt;event))
5289     return push_sticky (pad, ev, data);
5290 
5291   return TRUE;
5292 }
5293 
5294 /* should be called with pad LOCK */
5295 static GstFlowReturn
5296 gst_pad_push_event_unchecked (GstPad * pad, GstEvent * event,
5297     GstPadProbeType type)
5298 {
5299   GstFlowReturn ret;
5300   GstPad *peerpad;
5301   GstEventType event_type;
5302   gint64 old_pad_offset = pad-&gt;offset;
5303 
5304   /* pass the adjusted event on. We need to do this even if
5305    * there is no peer pad because of the probes. */
5306   event = apply_pad_offset (pad, event, GST_PAD_IS_SINK (pad));
5307 
5308   /* Two checks to be made:
5309    * . (un)set the FLUSHING flag for flushing events,
5310    * . handle pad blocking */
5311   event_type = GST_EVENT_TYPE (event);
5312   switch (event_type) {
5313     case GST_EVENT_FLUSH_START:
5314       GST_PAD_SET_FLUSHING (pad);
5315 
5316       GST_PAD_BLOCK_BROADCAST (pad);
5317       type |= GST_PAD_PROBE_TYPE_EVENT_FLUSH;
5318       break;
5319     case GST_EVENT_FLUSH_STOP:
5320       if (G_UNLIKELY (!GST_PAD_IS_ACTIVE (pad)))
5321         goto inactive;
5322 
5323       GST_PAD_UNSET_FLUSHING (pad);
5324 
5325       /* Remove sticky EOS events */
5326       GST_LOG_OBJECT (pad, &quot;Removing pending EOS events&quot;);
5327       remove_event_by_type (pad, GST_EVENT_EOS);
5328       remove_event_by_type (pad, GST_EVENT_STREAM_GROUP_DONE);
5329       remove_event_by_type (pad, GST_EVENT_SEGMENT);
5330       GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_EOS);
5331       pad-&gt;ABI.abi.last_flowret = GST_FLOW_OK;
5332 
5333       type |= GST_PAD_PROBE_TYPE_EVENT_FLUSH;
5334       break;
5335     default:
5336     {
5337       if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
5338         goto flushed;
5339 
5340       /* No need to check for EOS here as either the caller (gst_pad_push_event())
5341        * checked already or this is called as part of pushing sticky events,
5342        * in which case we still want to forward the EOS event downstream.
5343        */
5344 
5345       switch (GST_EVENT_TYPE (event)) {
5346         case GST_EVENT_RECONFIGURE:
5347           if (GST_PAD_IS_SINK (pad))
5348             GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
5349           break;
5350         default:
5351           break;
5352       }
5353       PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PUSH |
5354           GST_PAD_PROBE_TYPE_BLOCK, event, probe_stopped);
5355       /* recheck sticky events because the probe might have cause a relink */
5356       if (GST_PAD_HAS_PENDING_EVENTS (pad) &amp;&amp; GST_PAD_IS_SRC (pad)
5357           &amp;&amp; (GST_EVENT_IS_SERIALIZED (event)
5358               || GST_EVENT_IS_STICKY (event))) {
5359         PushStickyData data = { GST_FLOW_OK, FALSE, event };
5360         GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_PENDING_EVENTS);
5361 
5362         /* Push all sticky events before our current one
5363          * that have changed */
5364         events_foreach (pad, sticky_changed, &amp;data);
5365       }
5366       break;
5367     }
5368   }
5369 
5370   /* send probes after modifying the events above */
5371   PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PUSH, event, probe_stopped);
5372 
5373   /* recheck sticky events because the probe might have cause a relink */
5374   if (GST_PAD_HAS_PENDING_EVENTS (pad) &amp;&amp; GST_PAD_IS_SRC (pad)
5375       &amp;&amp; (GST_EVENT_IS_SERIALIZED (event)
5376           || GST_EVENT_IS_STICKY (event))) {
5377     PushStickyData data = { GST_FLOW_OK, FALSE, event };
5378     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_PENDING_EVENTS);
5379 
5380     /* Push all sticky events before our current one
5381      * that have changed */
5382     events_foreach (pad, sticky_changed, &amp;data);
5383   }
5384 
5385   /* the pad offset might&#39;ve been changed by any of the probes above. It
5386    * would&#39;ve been taken into account when repushing any of the sticky events
5387    * above but not for our current event here */
5388   if (G_UNLIKELY (old_pad_offset != pad-&gt;offset)) {
5389     event =
5390         _apply_pad_offset (pad, event, GST_PAD_IS_SINK (pad),
5391         pad-&gt;offset - old_pad_offset);
5392   }
5393 
5394   /* now check the peer pad */
5395   peerpad = GST_PAD_PEER (pad);
5396   if (peerpad == NULL)
5397     goto not_linked;
5398 
5399   gst_object_ref (peerpad);
5400   pad-&gt;priv-&gt;using++;
5401   GST_OBJECT_UNLOCK (pad);
5402 
5403   GST_LOG_OBJECT (pad, &quot;sending event %p (%s) to peerpad %&quot; GST_PTR_FORMAT,
5404       event, gst_event_type_get_name (event_type), peerpad);
5405 
5406   ret = gst_pad_send_event_unchecked (peerpad, event, type);
5407 
5408   /* Note: we gave away ownership of the event at this point but we can still
5409    * print the old pointer */
5410   GST_LOG_OBJECT (pad,
5411       &quot;sent event %p (%s) to peerpad %&quot; GST_PTR_FORMAT &quot;, ret %s&quot;, event,
5412       gst_event_type_get_name (event_type), peerpad, gst_flow_get_name (ret));
5413 
5414   gst_object_unref (peerpad);
5415 
5416   GST_OBJECT_LOCK (pad);
5417   pad-&gt;priv-&gt;using--;
5418   if (pad-&gt;priv-&gt;using == 0) {
5419     /* pad is not active anymore, trigger idle callbacks */
5420     PROBE_NO_DATA (pad, GST_PAD_PROBE_TYPE_PUSH | GST_PAD_PROBE_TYPE_IDLE,
5421         idle_probe_stopped, ret);
5422   }
5423   return ret;
5424 
5425   /* ERROR handling */
5426 flushed:
5427   {
5428     GST_DEBUG_OBJECT (pad, &quot;We&#39;re flushing&quot;);
5429     gst_event_unref (event);
5430     return GST_FLOW_FLUSHING;
5431   }
5432 inactive:
5433   {
5434     GST_DEBUG_OBJECT (pad, &quot;flush-stop on inactive pad&quot;);
5435     gst_event_unref (event);
5436     return GST_FLOW_FLUSHING;
5437   }
5438 probe_stopped:
5439   {
5440     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
5441     if (ret != GST_FLOW_CUSTOM_SUCCESS_1)
<a name="52" id="anc52"></a><span class="line-modified">5442     gst_event_unref (event);</span>
5443 
5444     switch (ret) {
5445       case GST_FLOW_CUSTOM_SUCCESS_1:
5446         GST_DEBUG_OBJECT (pad, &quot;handled event&quot;);
5447         break;
5448       case GST_FLOW_CUSTOM_SUCCESS:
5449         GST_DEBUG_OBJECT (pad, &quot;dropped event&quot;);
5450         break;
5451       default:
5452         GST_DEBUG_OBJECT (pad, &quot;an error occurred %s&quot;, gst_flow_get_name (ret));
5453         break;
5454     }
5455     return ret;
5456   }
5457 not_linked:
5458   {
5459     GST_DEBUG_OBJECT (pad, &quot;Dropping event %s because pad is not linked&quot;,
5460         gst_event_type_get_name (GST_EVENT_TYPE (event)));
5461     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
5462     gst_event_unref (event);
5463 
5464     /* unlinked pads should not influence latency configuration */
5465     if (event_type == GST_EVENT_LATENCY)
5466       return GST_FLOW_OK;
5467 
5468     return GST_FLOW_NOT_LINKED;
5469   }
5470 idle_probe_stopped:
5471   {
5472     GST_DEBUG_OBJECT (pad, &quot;Idle probe returned %s&quot;, gst_flow_get_name (ret));
5473     return ret;
5474   }
5475 }
5476 
5477 /**
5478  * gst_pad_push_event:
5479  * @pad: a #GstPad to push the event to.
5480  * @event: (transfer full): the #GstEvent to send to the pad.
5481  *
5482  * Sends the event to the peer of the given pad. This function is
5483  * mainly used by elements to send events to their peer
5484  * elements.
5485  *
5486  * This function takes ownership of the provided event so you should
5487  * gst_event_ref() it if you want to reuse the event after this call.
5488  *
5489  * Returns: %TRUE if the event was handled.
5490  *
5491  * MT safe.
5492  */
5493 gboolean
5494 gst_pad_push_event (GstPad * pad, GstEvent * event)
5495 {
5496   gboolean res = FALSE;
5497   GstPadProbeType type;
5498   gboolean sticky, serialized;
5499 
5500   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
5501   g_return_val_if_fail (GST_IS_EVENT (event), FALSE);
5502 
5503   GST_TRACER_PAD_PUSH_EVENT_PRE (pad, event);
5504 
5505   if (GST_PAD_IS_SRC (pad)) {
5506     if (G_UNLIKELY (!GST_EVENT_IS_DOWNSTREAM (event)))
5507       goto wrong_direction;
5508     type = GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM;
5509   } else if (GST_PAD_IS_SINK (pad)) {
5510     if (G_UNLIKELY (!GST_EVENT_IS_UPSTREAM (event)))
5511       goto wrong_direction;
5512     /* events pushed on sinkpad never are sticky */
5513     type = GST_PAD_PROBE_TYPE_EVENT_UPSTREAM;
5514   } else
5515     goto unknown_direction;
5516 
5517   GST_OBJECT_LOCK (pad);
5518   sticky = GST_EVENT_IS_STICKY (event);
5519   serialized = GST_EVENT_IS_SERIALIZED (event);
5520 
5521   if (sticky) {
5522     /* srcpad sticky events are stored immediately, the received flag is set
5523      * to FALSE and will be set to TRUE when we can successfully push the
5524      * event to the peer pad */
5525     switch (store_sticky_event (pad, event)) {
5526       case GST_FLOW_FLUSHING:
5527         goto flushed;
5528       case GST_FLOW_EOS:
5529         goto eos;
5530       default:
5531         break;
5532     }
5533   }
5534   if (GST_PAD_IS_SRC (pad) &amp;&amp; (serialized || sticky)) {
5535     /* all serialized or sticky events on the srcpad trigger push of
5536      * sticky events */
5537     res = (check_sticky (pad, event) == GST_FLOW_OK);
5538   }
5539   if (!sticky) {
5540     GstFlowReturn ret;
5541 
5542     /* other events are pushed right away */
5543     ret = gst_pad_push_event_unchecked (pad, event, type);
5544     /* dropped events by a probe are not an error */
5545     res = (ret == GST_FLOW_OK || ret == GST_FLOW_CUSTOM_SUCCESS
5546         || ret == GST_FLOW_CUSTOM_SUCCESS_1);
5547   } else {
5548     /* Errors in sticky event pushing are no problem and ignored here
5549      * as they will cause more meaningful errors during data flow.
5550      * For EOS events, that are not followed by data flow, we still
5551      * return FALSE here though.
5552      */
5553     if (GST_EVENT_TYPE (event) != GST_EVENT_EOS)
5554       res = TRUE;
5555     gst_event_unref (event);
5556   }
5557   GST_OBJECT_UNLOCK (pad);
5558 
5559   GST_TRACER_PAD_PUSH_EVENT_POST (pad, res);
5560   return res;
5561 
5562   /* ERROR handling */
5563 wrong_direction:
5564   {
5565     g_warning (&quot;pad %s:%s pushing %s event in wrong direction&quot;,
5566         GST_DEBUG_PAD_NAME (pad), GST_EVENT_TYPE_NAME (event));
5567     gst_event_unref (event);
5568     goto done;
5569   }
5570 unknown_direction:
5571   {
5572     g_warning (&quot;pad %s:%s has invalid direction&quot;, GST_DEBUG_PAD_NAME (pad));
5573     gst_event_unref (event);
5574     goto done;
5575   }
5576 flushed:
5577   {
5578     GST_DEBUG_OBJECT (pad, &quot;We&#39;re flushing&quot;);
5579     GST_OBJECT_UNLOCK (pad);
5580     gst_event_unref (event);
5581     goto done;
5582   }
5583 eos:
5584   {
5585     GST_DEBUG_OBJECT (pad, &quot;We&#39;re EOS&quot;);
5586     GST_OBJECT_UNLOCK (pad);
5587     gst_event_unref (event);
5588     goto done;
5589   }
5590 done:
5591   GST_TRACER_PAD_PUSH_EVENT_POST (pad, FALSE);
<a name="53" id="anc53"></a><span class="line-modified">5592     return FALSE;</span>
<span class="line-modified">5593   }</span>
5594 
5595 /* Check if we can call the event function with the given event */
5596 static GstFlowReturn
5597 pre_eventfunc_check (GstPad * pad, GstEvent * event)
5598 {
5599   GstCaps *caps;
5600 
5601   switch (GST_EVENT_TYPE (event)) {
5602     case GST_EVENT_CAPS:
5603     {
5604       /* backwards compatibility mode for caps */
5605       gst_event_parse_caps (event, &amp;caps);
5606 
5607       if (!gst_pad_query_accept_caps (pad, caps))
5608         goto not_accepted;
5609       break;
5610     }
5611     default:
5612       break;
5613   }
5614   return GST_FLOW_OK;
5615 
5616   /* ERRORS */
5617 not_accepted:
5618   {
5619     GST_CAT_DEBUG_OBJECT (GST_CAT_CAPS, pad,
5620         &quot;caps %&quot; GST_PTR_FORMAT &quot; not accepted&quot;, caps);
5621     return GST_FLOW_NOT_NEGOTIATED;
5622   }
5623 }
5624 
5625 static GstFlowReturn
5626 gst_pad_send_event_unchecked (GstPad * pad, GstEvent * event,
5627     GstPadProbeType type)
5628 {
5629   GstFlowReturn ret;
5630   GstEventType event_type;
5631   gboolean serialized, need_unlock = FALSE, sticky;
5632   GstPadEventFunction eventfunc;
5633   GstPadEventFullFunction eventfullfunc = NULL;
5634   GstObject *parent;
5635   gint64 old_pad_offset;
5636 
5637   GST_OBJECT_LOCK (pad);
5638 
5639   old_pad_offset = pad-&gt;offset;
5640   event = apply_pad_offset (pad, event, GST_PAD_IS_SRC (pad));
5641 
5642   if (GST_PAD_IS_SINK (pad))
5643     serialized = GST_EVENT_IS_SERIALIZED (event);
5644   else
5645     serialized = FALSE;
5646   sticky = GST_EVENT_IS_STICKY (event);
5647   event_type = GST_EVENT_TYPE (event);
5648   switch (event_type) {
5649     case GST_EVENT_FLUSH_START:
5650       GST_CAT_DEBUG_OBJECT (GST_CAT_EVENT, pad,
5651           &quot;have event type %d (FLUSH_START)&quot;, GST_EVENT_TYPE (event));
5652 
5653       /* can&#39;t even accept a flush begin event when flushing */
5654       if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
5655         goto flushing;
5656 
5657       GST_PAD_SET_FLUSHING (pad);
5658       GST_CAT_DEBUG_OBJECT (GST_CAT_EVENT, pad, &quot;set flush flag&quot;);
5659       GST_PAD_BLOCK_BROADCAST (pad);
5660       type |= GST_PAD_PROBE_TYPE_EVENT_FLUSH;
5661       break;
5662     case GST_EVENT_FLUSH_STOP:
5663       /* we can&#39;t accept flush-stop on inactive pads else the flushing flag
5664        * would be cleared and it would look like the pad can accept data.
5665        * Also, some elements restart a streaming thread in flush-stop which we
5666        * can&#39;t allow on inactive pads */
5667       if (G_UNLIKELY (!GST_PAD_IS_ACTIVE (pad)))
5668         goto inactive;
5669 
<a name="54" id="anc54"></a><span class="line-modified">5670         GST_PAD_UNSET_FLUSHING (pad);</span>
<span class="line-modified">5671         GST_CAT_DEBUG_OBJECT (GST_CAT_EVENT, pad, &quot;cleared flush flag&quot;);</span>
5672       /* Remove pending EOS events */
5673       GST_LOG_OBJECT (pad, &quot;Removing pending EOS and SEGMENT events&quot;);
5674       remove_event_by_type (pad, GST_EVENT_EOS);
5675       remove_event_by_type (pad, GST_EVENT_STREAM_GROUP_DONE);
5676       remove_event_by_type (pad, GST_EVENT_SEGMENT);
5677       GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_EOS);
5678       pad-&gt;ABI.abi.last_flowret = GST_FLOW_OK;
5679 
5680       GST_OBJECT_UNLOCK (pad);
5681       /* grab stream lock */
5682       GST_PAD_STREAM_LOCK (pad);
5683       need_unlock = TRUE;
5684       GST_OBJECT_LOCK (pad);
5685       if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
5686         goto flushing;
5687       break;
5688     case GST_EVENT_RECONFIGURE:
5689       if (GST_PAD_IS_SRC (pad))
5690         GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
5691     default:
5692       GST_CAT_DEBUG_OBJECT (GST_CAT_EVENT, pad,
5693           &quot;have event type %&quot; GST_PTR_FORMAT, event);
5694 
5695       if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
5696         goto flushing;
5697 
5698       switch (event_type) {
5699         case GST_EVENT_STREAM_START:
5700           /* Remove sticky EOS events */
5701           GST_LOG_OBJECT (pad, &quot;Removing pending EOS events&quot;);
5702           remove_event_by_type (pad, GST_EVENT_EOS);
5703           remove_event_by_type (pad, GST_EVENT_STREAM_GROUP_DONE);
5704           GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_EOS);
5705           break;
5706         default:
5707           break;
5708       }
5709 
5710       if (serialized) {
5711         if (G_UNLIKELY (GST_PAD_IS_EOS (pad)))
5712           goto eos;
5713 
5714         /* lock order: STREAM_LOCK, LOCK, recheck flushing. */
5715         GST_OBJECT_UNLOCK (pad);
5716         GST_PAD_STREAM_LOCK (pad);
5717         need_unlock = TRUE;
5718         GST_OBJECT_LOCK (pad);
5719         if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
5720           goto flushing;
5721 
5722         if (G_UNLIKELY (GST_PAD_IS_EOS (pad)))
5723           goto eos;
5724       }
5725       break;
5726   }
5727 
5728   /* now do the probe */
5729   PROBE_PUSH (pad,
5730       type | GST_PAD_PROBE_TYPE_PUSH |
5731       GST_PAD_PROBE_TYPE_BLOCK, event, probe_stopped);
5732 
5733   PROBE_PUSH (pad, type | GST_PAD_PROBE_TYPE_PUSH, event, probe_stopped);
5734 
5735   /* the pad offset might&#39;ve been changed by any of the probes above. It
5736    * would&#39;ve been taken into account when repushing any of the sticky events
5737    * above but not for our current event here */
5738   if (G_UNLIKELY (old_pad_offset != pad-&gt;offset)) {
5739     event =
5740         _apply_pad_offset (pad, event, GST_PAD_IS_SRC (pad),
5741         pad-&gt;offset - old_pad_offset);
5742   }
5743 
5744   eventfullfunc = GST_PAD_EVENTFULLFUNC (pad);
5745   eventfunc = GST_PAD_EVENTFUNC (pad);
5746   if (G_UNLIKELY (eventfunc == NULL &amp;&amp; eventfullfunc == NULL))
5747     goto no_function;
5748 
5749   ACQUIRE_PARENT (pad, parent, no_parent);
5750   GST_OBJECT_UNLOCK (pad);
5751 
5752   ret = pre_eventfunc_check (pad, event);
5753   if (G_UNLIKELY (ret != GST_FLOW_OK))
5754     goto precheck_failed;
5755 
5756   if (sticky)
5757     gst_event_ref (event);
5758 
5759   if (eventfullfunc) {
5760     ret = eventfullfunc (pad, parent, event);
5761   } else if (eventfunc (pad, parent, event)) {
5762     ret = GST_FLOW_OK;
5763   } else {
5764     /* something went wrong */
5765     switch (event_type) {
5766       case GST_EVENT_CAPS:
5767         ret = GST_FLOW_NOT_NEGOTIATED;
5768         break;
5769       default:
5770         ret = GST_FLOW_ERROR;
5771         break;
5772     }
5773   }
5774   RELEASE_PARENT (parent);
5775 
5776   GST_DEBUG_OBJECT (pad, &quot;sent event, ret %s&quot;, gst_flow_get_name (ret));
5777 
5778   if (sticky) {
5779     if (ret == GST_FLOW_OK) {
5780       GST_OBJECT_LOCK (pad);
5781       /* after the event function accepted the event, we can store the sticky
5782        * event on the pad */
5783       switch (store_sticky_event (pad, event)) {
5784         case GST_FLOW_FLUSHING:
5785           goto flushing;
5786         case GST_FLOW_EOS:
5787           goto eos;
5788         default:
5789           break;
5790       }
5791       GST_OBJECT_UNLOCK (pad);
5792     }
5793     gst_event_unref (event);
5794   }
5795 
5796   if (need_unlock)
5797     GST_PAD_STREAM_UNLOCK (pad);
5798 
5799   return ret;
5800 
5801   /* ERROR handling */
5802 flushing:
5803   {
5804     GST_OBJECT_UNLOCK (pad);
5805     if (need_unlock)
5806       GST_PAD_STREAM_UNLOCK (pad);
5807     GST_CAT_INFO_OBJECT (GST_CAT_EVENT, pad,
5808         &quot;Received event on flushing pad. Discarding&quot;);
5809     gst_event_unref (event);
5810     return GST_FLOW_FLUSHING;
5811   }
5812 inactive:
5813   {
5814     GST_OBJECT_UNLOCK (pad);
5815     if (need_unlock)
5816       GST_PAD_STREAM_UNLOCK (pad);
5817     GST_CAT_INFO_OBJECT (GST_CAT_EVENT, pad,
5818         &quot;Received flush-stop on inactive pad. Discarding&quot;);
5819     gst_event_unref (event);
5820     return GST_FLOW_FLUSHING;
5821   }
5822 eos:
5823   {
5824     GST_OBJECT_UNLOCK (pad);
5825     if (need_unlock)
5826       GST_PAD_STREAM_UNLOCK (pad);
5827     GST_CAT_INFO_OBJECT (GST_CAT_EVENT, pad,
5828         &quot;Received event on EOS pad. Discarding&quot;);
5829     gst_event_unref (event);
5830     return GST_FLOW_EOS;
5831   }
5832 probe_stopped:
5833   {
5834     GST_OBJECT_UNLOCK (pad);
5835     if (need_unlock)
5836       GST_PAD_STREAM_UNLOCK (pad);
5837     /* Only unref if unhandled */
5838     if (ret != GST_FLOW_CUSTOM_SUCCESS_1)
<a name="55" id="anc55"></a><span class="line-modified">5839     gst_event_unref (event);</span>
5840 
5841     switch (ret) {
5842       case GST_FLOW_CUSTOM_SUCCESS_1:
5843       case GST_FLOW_CUSTOM_SUCCESS:
5844         GST_DEBUG_OBJECT (pad, &quot;dropped or handled event&quot;);
5845         ret = GST_FLOW_OK;
5846         break;
5847       default:
5848         GST_DEBUG_OBJECT (pad, &quot;an error occurred %s&quot;, gst_flow_get_name (ret));
5849         break;
5850     }
5851     return ret;
5852   }
5853 no_function:
5854   {
5855     g_warning (&quot;pad %s:%s has no event handler, file a bug.&quot;,
5856         GST_DEBUG_PAD_NAME (pad));
5857     GST_OBJECT_UNLOCK (pad);
5858     if (need_unlock)
5859       GST_PAD_STREAM_UNLOCK (pad);
5860     gst_event_unref (event);
5861     return GST_FLOW_NOT_SUPPORTED;
5862   }
5863 no_parent:
5864   {
5865     GST_DEBUG_OBJECT (pad, &quot;no parent&quot;);
5866     GST_OBJECT_UNLOCK (pad);
5867     if (need_unlock)
5868       GST_PAD_STREAM_UNLOCK (pad);
5869     gst_event_unref (event);
5870     return GST_FLOW_FLUSHING;
5871   }
5872 precheck_failed:
5873   {
5874     GST_DEBUG_OBJECT (pad, &quot;pre event check failed&quot;);
5875     RELEASE_PARENT (parent);
5876     if (need_unlock)
5877       GST_PAD_STREAM_UNLOCK (pad);
5878     gst_event_unref (event);
5879     return ret;
5880   }
5881 }
5882 
5883 /**
5884  * gst_pad_send_event:
5885  * @pad: a #GstPad to send the event to.
5886  * @event: (transfer full): the #GstEvent to send to the pad.
5887  *
5888  * Sends the event to the pad. This function can be used
5889  * by applications to send events in the pipeline.
5890  *
5891  * If @pad is a source pad, @event should be an upstream event. If @pad is a
5892  * sink pad, @event should be a downstream event. For example, you would not
5893  * send a #GST_EVENT_EOS on a src pad; EOS events only propagate downstream.
5894  * Furthermore, some downstream events have to be serialized with data flow,
5895  * like EOS, while some can travel out-of-band, like #GST_EVENT_FLUSH_START. If
5896  * the event needs to be serialized with data flow, this function will take the
5897  * pad&#39;s stream lock while calling its event function.
5898  *
5899  * To find out whether an event type is upstream, downstream, or downstream and
5900  * serialized, see #GstEventTypeFlags, gst_event_type_get_flags(),
5901  * #GST_EVENT_IS_UPSTREAM, #GST_EVENT_IS_DOWNSTREAM, and
5902  * #GST_EVENT_IS_SERIALIZED. Note that in practice that an application or
5903  * plugin doesn&#39;t need to bother itself with this information; the core handles
5904  * all necessary locks and checks.
5905  *
5906  * This function takes ownership of the provided event so you should
5907  * gst_event_ref() it if you want to reuse the event after this call.
5908  *
5909  * Returns: %TRUE if the event was handled.
5910  */
5911 gboolean
5912 gst_pad_send_event (GstPad * pad, GstEvent * event)
5913 {
5914   gboolean result;
5915   GstPadProbeType type;
5916 
5917   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
5918   g_return_val_if_fail (event != NULL, FALSE);
5919 
5920   if (GST_PAD_IS_SINK (pad)) {
5921     if (G_UNLIKELY (!GST_EVENT_IS_DOWNSTREAM (event)))
5922       goto wrong_direction;
5923     type = GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM;
5924   } else if (GST_PAD_IS_SRC (pad)) {
5925     if (G_UNLIKELY (!GST_EVENT_IS_UPSTREAM (event)))
5926       goto wrong_direction;
5927     type = GST_PAD_PROBE_TYPE_EVENT_UPSTREAM;
5928   } else
5929     goto unknown_direction;
5930 
5931   if (gst_pad_send_event_unchecked (pad, event, type) != GST_FLOW_OK)
5932     result = FALSE;
5933   else
5934     result = TRUE;
5935 
5936   return result;
5937 
5938   /* ERROR handling */
5939 wrong_direction:
5940   {
5941     g_warning (&quot;pad %s:%s sending %s event in wrong direction&quot;,
5942         GST_DEBUG_PAD_NAME (pad), GST_EVENT_TYPE_NAME (event));
5943     gst_event_unref (event);
5944     return FALSE;
5945   }
5946 unknown_direction:
5947   {
5948     g_warning (&quot;pad %s:%s has invalid direction&quot;, GST_DEBUG_PAD_NAME (pad));
5949     gst_event_unref (event);
5950     return FALSE;
5951   }
5952 }
5953 
5954 /**
5955  * gst_pad_set_element_private:
5956  * @pad: the #GstPad to set the private data of.
5957  * @priv: The private data to attach to the pad.
5958  *
5959  * Set the given private data gpointer on the pad.
5960  * This function can only be used by the element that owns the pad.
5961  * No locking is performed in this function.
5962  */
5963 void
5964 gst_pad_set_element_private (GstPad * pad, gpointer priv)
5965 {
5966   pad-&gt;element_private = priv;
5967 }
5968 
5969 /**
5970  * gst_pad_get_element_private:
5971  * @pad: the #GstPad to get the private data of.
5972  *
5973  * Gets the private data of a pad.
5974  * No locking is performed in this function.
5975  *
5976  * Returns: (transfer none) (nullable): a #gpointer to the private data.
5977  */
5978 gpointer
5979 gst_pad_get_element_private (GstPad * pad)
5980 {
5981   return pad-&gt;element_private;
5982 }
5983 
5984 /**
5985  * gst_pad_get_sticky_event:
5986  * @pad: the #GstPad to get the event from.
5987  * @event_type: the #GstEventType that should be retrieved.
5988  * @idx: the index of the event
5989  *
5990  * Returns a new reference of the sticky event of type @event_type
5991  * from the event.
5992  *
5993  * Returns: (transfer full) (nullable): a #GstEvent of type
5994  * @event_type or %NULL when no event of @event_type was on
5995  * @pad. Unref after usage.
5996  */
5997 GstEvent *
5998 gst_pad_get_sticky_event (GstPad * pad, GstEventType event_type, guint idx)
5999 {
6000   GstEvent *event = NULL;
6001   PadEvent *ev;
6002 
6003   g_return_val_if_fail (GST_IS_PAD (pad), NULL);
6004   g_return_val_if_fail ((event_type &amp; GST_EVENT_TYPE_STICKY) != 0, NULL);
6005 
6006   GST_OBJECT_LOCK (pad);
6007   ev = find_event_by_type (pad, event_type, idx);
6008   if (ev &amp;&amp; (event = ev-&gt;event))
6009     gst_event_ref (event);
6010   GST_OBJECT_UNLOCK (pad);
6011 
6012   return event;
6013 }
6014 
6015 typedef struct
6016 {
6017   GstPadStickyEventsForeachFunction func;
6018   gpointer user_data;
6019 } ForeachDispatch;
6020 
6021 static gboolean
6022 foreach_dispatch_function (GstPad * pad, PadEvent * ev, gpointer user_data)
6023 {
6024   ForeachDispatch *data = user_data;
6025   gboolean ret = TRUE;
6026 
6027   if (ev-&gt;event) {
6028     GST_OBJECT_UNLOCK (pad);
6029 
6030     ret = data-&gt;func (pad, &amp;ev-&gt;event, data-&gt;user_data);
6031 
6032     GST_OBJECT_LOCK (pad);
6033   }
6034 
6035   return ret;
6036 }
6037 
6038 /**
6039  * gst_pad_sticky_events_foreach:
6040  * @pad: the #GstPad that should be used for iteration.
6041  * @foreach_func: (scope call): the #GstPadStickyEventsForeachFunction that
6042  *                should be called for every event.
6043  * @user_data: (closure): the optional user data.
6044  *
6045  * Iterates all sticky events on @pad and calls @foreach_func for every
6046  * event. If @foreach_func returns %FALSE the iteration is immediately stopped.
6047  */
6048 void
6049 gst_pad_sticky_events_foreach (GstPad * pad,
6050     GstPadStickyEventsForeachFunction foreach_func, gpointer user_data)
6051 {
6052   ForeachDispatch data;
6053 
6054   g_return_if_fail (GST_IS_PAD (pad));
6055   g_return_if_fail (foreach_func != NULL);
6056 
6057   data.func = foreach_func;
6058   data.user_data = user_data;
6059 
6060   GST_OBJECT_LOCK (pad);
6061   events_foreach (pad, foreach_dispatch_function, &amp;data);
6062   GST_OBJECT_UNLOCK (pad);
6063 }
6064 
6065 static void
6066 do_stream_status (GstPad * pad, GstStreamStatusType type,
6067     GThread * thread, GstTask * task)
6068 {
6069   GstElement *parent;
6070 
6071   GST_DEBUG_OBJECT (pad, &quot;doing stream-status %d&quot;, type);
6072 
6073   if ((parent = GST_ELEMENT_CAST (gst_pad_get_parent (pad)))) {
6074     if (GST_IS_ELEMENT (parent)) {
6075       GstMessage *message;
6076       GValue value = { 0 };
6077 
6078       if (type == GST_STREAM_STATUS_TYPE_ENTER) {
6079         gchar *tname, *ename, *pname;
6080 
6081         /* create a good task name */
6082         ename = gst_element_get_name (parent);
6083         pname = gst_pad_get_name (pad);
6084         tname = g_strdup_printf (&quot;%s:%s&quot;, ename, pname);
6085         g_free (ename);
6086         g_free (pname);
6087 
6088         gst_object_set_name (GST_OBJECT_CAST (task), tname);
6089         g_free (tname);
6090       }
6091 
6092       message = gst_message_new_stream_status (GST_OBJECT_CAST (pad),
6093           type, parent);
6094 
6095       g_value_init (&amp;value, GST_TYPE_TASK);
6096       g_value_set_object (&amp;value, task);
6097       gst_message_set_stream_status_object (message, &amp;value);
6098       g_value_unset (&amp;value);
6099 
6100       GST_DEBUG_OBJECT (pad, &quot;posting stream-status %d&quot;, type);
6101       gst_element_post_message (parent, message);
6102     }
6103     gst_object_unref (parent);
6104   }
6105 }
6106 
6107 static void
6108 pad_enter_thread (GstTask * task, GThread * thread, gpointer user_data)
6109 {
6110   do_stream_status (GST_PAD_CAST (user_data), GST_STREAM_STATUS_TYPE_ENTER,
6111       thread, task);
6112 }
6113 
6114 static void
6115 pad_leave_thread (GstTask * task, GThread * thread, gpointer user_data)
6116 {
6117   do_stream_status (GST_PAD_CAST (user_data), GST_STREAM_STATUS_TYPE_LEAVE,
6118       thread, task);
6119 }
6120 
6121 /**
6122  * gst_pad_start_task:
6123  * @pad: the #GstPad to start the task of
6124  * @func: the task function to call
6125  * @user_data: user data passed to the task function
6126  * @notify: called when @user_data is no longer referenced
6127  *
6128  * Starts a task that repeatedly calls @func with @user_data. This function
6129  * is mostly used in pad activation functions to start the dataflow.
6130  * The #GST_PAD_STREAM_LOCK of @pad will automatically be acquired
6131  * before @func is called.
6132  *
6133  * Returns: a %TRUE if the task could be started.
6134  */
6135 gboolean
6136 gst_pad_start_task (GstPad * pad, GstTaskFunction func, gpointer user_data,
6137     GDestroyNotify notify)
6138 {
6139   GstTask *task;
6140   gboolean res;
6141 
6142   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
6143   g_return_val_if_fail (func != NULL, FALSE);
6144 
6145   GST_DEBUG_OBJECT (pad, &quot;start task&quot;);
6146 
6147   GST_OBJECT_LOCK (pad);
6148   task = GST_PAD_TASK (pad);
6149   if (task == NULL) {
6150     task = gst_task_new (func, user_data, notify);
6151     gst_task_set_lock (task, GST_PAD_GET_STREAM_LOCK (pad));
6152     gst_task_set_enter_callback (task, pad_enter_thread, pad, NULL);
6153     gst_task_set_leave_callback (task, pad_leave_thread, pad, NULL);
6154     GST_INFO_OBJECT (pad, &quot;created task %p&quot;, task);
6155     GST_PAD_TASK (pad) = task;
6156     gst_object_ref (task);
6157     /* release lock to post the message */
6158     GST_OBJECT_UNLOCK (pad);
6159 
6160     do_stream_status (pad, GST_STREAM_STATUS_TYPE_CREATE, NULL, task);
6161 
6162     gst_object_unref (task);
6163 
6164     GST_OBJECT_LOCK (pad);
6165     /* nobody else is supposed to have changed the pad now */
6166     if (GST_PAD_TASK (pad) != task)
6167       goto concurrent_stop;
6168   }
6169   res = gst_task_set_state (task, GST_TASK_STARTED);
6170   GST_OBJECT_UNLOCK (pad);
6171 
6172   return res;
6173 
6174   /* ERRORS */
6175 concurrent_stop:
6176   {
6177     GST_OBJECT_UNLOCK (pad);
6178     return TRUE;
6179   }
6180 }
6181 
6182 /**
6183  * gst_pad_pause_task:
6184  * @pad: the #GstPad to pause the task of
6185  *
6186  * Pause the task of @pad. This function will also wait until the
6187  * function executed by the task is finished if this function is not
6188  * called from the task function.
6189  *
6190  * Returns: a %TRUE if the task could be paused or %FALSE when the pad
6191  * has no task.
6192  */
6193 gboolean
6194 gst_pad_pause_task (GstPad * pad)
6195 {
6196   GstTask *task;
6197   gboolean res;
6198 
6199   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
6200 
6201   GST_DEBUG_OBJECT (pad, &quot;pause task&quot;);
6202 
6203   GST_OBJECT_LOCK (pad);
6204   task = GST_PAD_TASK (pad);
6205   if (task == NULL)
6206     goto no_task;
6207   res = gst_task_set_state (task, GST_TASK_PAUSED);
6208   /* unblock activation waits if any */
6209   pad-&gt;priv-&gt;in_activation = FALSE;
6210   g_cond_broadcast (&amp;pad-&gt;priv-&gt;activation_cond);
6211   GST_OBJECT_UNLOCK (pad);
6212 
6213   /* wait for task function to finish, this lock is recursive so it does nothing
6214    * when the pause is called from the task itself */
6215   GST_PAD_STREAM_LOCK (pad);
6216   GST_PAD_STREAM_UNLOCK (pad);
6217 
6218   return res;
6219 
6220 no_task:
6221   {
6222     GST_DEBUG_OBJECT (pad, &quot;pad has no task&quot;);
6223     GST_OBJECT_UNLOCK (pad);
6224     return FALSE;
6225   }
6226 }
6227 
6228 /**
6229  * gst_pad_get_task_state:
6230  * @pad: the #GstPad to get task state from
6231  *
6232  * Get @pad task state. If no task is currently
6233  * set, #GST_TASK_STOPPED is returned.
6234  *
6235  * Returns: The current state of @pad&#39;s task.
6236  *
6237  * Since: 1.12
6238  */
6239 GstTaskState
6240 gst_pad_get_task_state (GstPad * pad)
6241 {
6242   GstTask *task;
6243   GstTaskState res;
6244 
6245   g_return_val_if_fail (GST_IS_PAD (pad), GST_TASK_STOPPED);
6246 
6247   GST_OBJECT_LOCK (pad);
6248   task = GST_PAD_TASK (pad);
6249   if (task == NULL)
6250     goto no_task;
6251   res = gst_task_get_state (task);
6252   GST_OBJECT_UNLOCK (pad);
6253 
6254   return res;
6255 
6256 no_task:
6257   {
6258     GST_DEBUG_OBJECT (pad, &quot;pad has no task&quot;);
6259     GST_OBJECT_UNLOCK (pad);
6260     return GST_TASK_STOPPED;
6261   }
6262 }
6263 
6264 /**
6265  * gst_pad_stop_task:
6266  * @pad: the #GstPad to stop the task of
6267  *
6268  * Stop the task of @pad. This function will also make sure that the
6269  * function executed by the task will effectively stop if not called
6270  * from the GstTaskFunction.
6271  *
6272  * This function will deadlock if called from the GstTaskFunction of
6273  * the task. Use gst_task_pause() instead.
6274  *
6275  * Regardless of whether the pad has a task, the stream lock is acquired and
6276  * released so as to ensure that streaming through this pad has finished.
6277  *
6278  * Returns: a %TRUE if the task could be stopped or %FALSE on error.
6279  */
6280 gboolean
6281 gst_pad_stop_task (GstPad * pad)
6282 {
6283   GstTask *task;
6284   gboolean res;
6285 
6286   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
6287 
6288   GST_DEBUG_OBJECT (pad, &quot;stop task&quot;);
6289 
6290   GST_OBJECT_LOCK (pad);
6291   task = GST_PAD_TASK (pad);
6292   if (task == NULL)
6293     goto no_task;
6294   GST_PAD_TASK (pad) = NULL;
6295   res = gst_task_set_state (task, GST_TASK_STOPPED);
6296   /* unblock activation waits if any */
6297   pad-&gt;priv-&gt;in_activation = FALSE;
6298   g_cond_broadcast (&amp;pad-&gt;priv-&gt;activation_cond);
6299   GST_OBJECT_UNLOCK (pad);
6300 
6301   GST_PAD_STREAM_LOCK (pad);
6302   GST_PAD_STREAM_UNLOCK (pad);
6303 
6304   if (!gst_task_join (task))
6305     goto join_failed;
6306 
6307   gst_object_unref (task);
6308 
6309   return res;
6310 
6311 no_task:
6312   {
6313     GST_DEBUG_OBJECT (pad, &quot;no task&quot;);
6314     GST_OBJECT_UNLOCK (pad);
6315 
6316     GST_PAD_STREAM_LOCK (pad);
6317     GST_PAD_STREAM_UNLOCK (pad);
6318 
6319     /* this is not an error */
6320     return TRUE;
6321   }
6322 join_failed:
6323   {
6324     /* this is bad, possibly the application tried to join the task from
6325      * the task&#39;s thread. We install the task again so that it will be stopped
6326      * again from the right thread next time hopefully. */
6327     GST_OBJECT_LOCK (pad);
6328     GST_DEBUG_OBJECT (pad, &quot;join failed&quot;);
6329     /* we can only install this task if there was no other task */
6330     if (GST_PAD_TASK (pad) == NULL)
6331       GST_PAD_TASK (pad) = task;
6332     GST_OBJECT_UNLOCK (pad);
6333 
6334     return FALSE;
6335   }
6336 }
6337 
6338 /**
6339  * gst_pad_probe_info_get_event:
6340  * @info: a #GstPadProbeInfo
6341  *
6342  * Returns: (transfer none) (nullable): The #GstEvent from the probe
6343  */
6344 
6345 GstEvent *
6346 gst_pad_probe_info_get_event (GstPadProbeInfo * info)
6347 {
6348   g_return_val_if_fail (info-&gt;type &amp; (GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM |
6349           GST_PAD_PROBE_TYPE_EVENT_UPSTREAM), NULL);
6350 
6351   return GST_PAD_PROBE_INFO_EVENT (info);
6352 }
6353 
6354 
6355 /**
6356  * gst_pad_probe_info_get_query:
6357  * @info: a #GstPadProbeInfo
6358  *
6359  * Returns: (transfer none) (nullable): The #GstQuery from the probe
6360  */
6361 
6362 GstQuery *
6363 gst_pad_probe_info_get_query (GstPadProbeInfo * info)
6364 {
6365   g_return_val_if_fail (info-&gt;type &amp; (GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM |
6366           GST_PAD_PROBE_TYPE_QUERY_UPSTREAM), NULL);
6367 
6368   return GST_PAD_PROBE_INFO_QUERY (info);
6369 }
6370 
6371 /**
6372  * gst_pad_probe_info_get_buffer:
6373  * @info: a #GstPadProbeInfo
6374  *
6375  * Returns: (transfer none) (nullable): The #GstBuffer from the probe
6376  */
6377 
6378 GstBuffer *
6379 gst_pad_probe_info_get_buffer (GstPadProbeInfo * info)
6380 {
6381   g_return_val_if_fail (info-&gt;type &amp; GST_PAD_PROBE_TYPE_BUFFER, NULL);
6382 
6383   return GST_PAD_PROBE_INFO_BUFFER (info);
6384 }
6385 
6386 /**
6387  * gst_pad_probe_info_get_buffer_list:
6388  * @info: a #GstPadProbeInfo
6389  *
6390  * Returns: (transfer none) (nullable): The #GstBufferList from the probe
6391  */
6392 
6393 GstBufferList *
6394 gst_pad_probe_info_get_buffer_list (GstPadProbeInfo * info)
6395 {
6396   g_return_val_if_fail (info-&gt;type &amp; GST_PAD_PROBE_TYPE_BUFFER_LIST, NULL);
6397 
6398   return GST_PAD_PROBE_INFO_BUFFER_LIST (info);
6399 }
6400 
6401 /**
6402  * gst_pad_get_last_flow_return:
6403  * @pad: the #GstPad
6404  *
6405  * Gets the #GstFlowReturn return from the last data passed by this pad.
6406  *
6407  * Since: 1.4
6408  */
6409 GstFlowReturn
6410 gst_pad_get_last_flow_return (GstPad * pad)
6411 {
6412   GstFlowReturn ret;
6413 
6414   GST_OBJECT_LOCK (pad);
6415   ret = GST_PAD_LAST_FLOW_RETURN (pad);
6416   GST_OBJECT_UNLOCK (pad);
6417 
6418   return ret;
6419 }
<a name="56" id="anc56"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="56" type="hidden" />
</body>
</html>