<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gsttracer.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* GStreamer
  2  * Copyright (C) 2013 Stefan Sauer &lt;ensonic@users.sf.net&gt;
  3  *
  4  * gsttracer.c: tracer base class
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public
 17  * License along with this library; if not, write to the
 18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 /**
 23  * SECTION:gsttracer
 24  * @title: GstTracer
 25  * @short_description: Tracing base class
 26  *
 27  * Tracing modules will subclass #GstTracer and register through
 28  * gst_tracer_register(). Modules can attach to various hook-types - see
 29  * gst_tracing_register_hook(). When invoked they receive hook specific
 30  * contextual data, which they must not modify.
 31  *
 32  * Since: 1.8
 33  */
 34 
 35 #define GST_USE_UNSTABLE_API
 36 
 37 #include &quot;gst_private.h&quot;
 38 #include &quot;gstenumtypes.h&quot;
 39 #include &quot;gsttracer.h&quot;
 40 #include &quot;gsttracerfactory.h&quot;
 41 #include &quot;gsttracerutils.h&quot;
 42 
 43 GST_DEBUG_CATEGORY_EXTERN (tracer_debug);
 44 #define GST_CAT_DEFAULT tracer_debug
 45 
 46 /* tracing plugins base class */
 47 
 48 enum
 49 {
 50   PROP_0,
 51   PROP_PARAMS,
 52   PROP_LAST
 53 };
 54 
 55 static GParamSpec *properties[PROP_LAST];
 56 
 57 static void gst_tracer_set_property (GObject * object, guint prop_id,
 58     const GValue * value, GParamSpec * pspec);
 59 static void gst_tracer_get_property (GObject * object, guint prop_id,
 60     GValue * value, GParamSpec * pspec);
 61 
 62 struct _GstTracerPrivate
 63 {
 64   gchar *params;
 65 };
 66 
 67 #define gst_tracer_parent_class parent_class
<a name="1" id="anc1"></a><span class="line-modified"> 68 G_DEFINE_ABSTRACT_TYPE (GstTracer, gst_tracer, GST_TYPE_OBJECT);</span>
 69 
 70 static void
 71 gst_tracer_dispose (GObject * object)
 72 {
 73   GstTracer *tracer = GST_TRACER (object);
 74   g_free (tracer-&gt;priv-&gt;params);
 75 }
 76 
 77 static void
 78 gst_tracer_class_init (GstTracerClass * klass)
 79 {
 80   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 81 
 82   gobject_class-&gt;set_property = gst_tracer_set_property;
 83   gobject_class-&gt;get_property = gst_tracer_get_property;
 84   gobject_class-&gt;dispose = gst_tracer_dispose;
 85 
 86   properties[PROP_PARAMS] =
 87       g_param_spec_string (&quot;params&quot;, &quot;Params&quot;, &quot;Extra configuration parameters&quot;,
 88       NULL, G_PARAM_READWRITE | G_PARAM_CONSTRUCT | G_PARAM_STATIC_STRINGS);
 89 
 90   g_object_class_install_properties (gobject_class, PROP_LAST, properties);
<a name="2" id="anc2"></a><span class="line-removed"> 91   g_type_class_add_private (klass, sizeof (GstTracerPrivate));</span>
 92 }
 93 
 94 static void
 95 gst_tracer_init (GstTracer * tracer)
 96 {
<a name="3" id="anc3"></a><span class="line-modified"> 97   tracer-&gt;priv = G_TYPE_INSTANCE_GET_PRIVATE (tracer, GST_TYPE_TRACER,</span>
<span class="line-removed"> 98       GstTracerPrivate);</span>
 99 }
100 
101 static void
102 gst_tracer_set_property (GObject * object, guint prop_id,
103     const GValue * value, GParamSpec * pspec)
104 {
105   GstTracer *self = GST_TRACER_CAST (object);
106 
107   switch (prop_id) {
108     case PROP_PARAMS:
109       self-&gt;priv-&gt;params = g_value_dup_string (value);
110       break;
111     default:
112       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
113       break;
114   }
115 }
116 
117 static void
118 gst_tracer_get_property (GObject * object, guint prop_id,
119     GValue * value, GParamSpec * pspec)
120 {
121   GstTracer *self = GST_TRACER_CAST (object);
122 
123   switch (prop_id) {
124     case PROP_PARAMS:
125       g_value_set_string (value, self-&gt;priv-&gt;params);
126       break;
127     default:
128       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
129       break;
130   }
131 }
132 
133 /* tracing modules */
134 
135 /**
136  * gst_tracer_register:
137  * @plugin: (allow-none): A #GstPlugin, or %NULL for a static typefind function
138  * @name: The name for registering
139  * @type: GType of tracer to register
140  *
141  * Create a new tracer-factory  capable of instantiating objects of the
142  * @type and add the factory to @plugin.
143  *
144  * Returns: %TRUE, if the registering succeeded, %FALSE on error
145  */
146 gboolean
147 gst_tracer_register (GstPlugin * plugin, const gchar * name, GType type)
148 {
149   GstPluginFeature *existing_feature;
150   GstRegistry *registry;
151   GstTracerFactory *factory;
152 
153   g_return_val_if_fail (name != NULL, FALSE);
154   g_return_val_if_fail (g_type_is_a (type, GST_TYPE_TRACER), FALSE);
155 
156   registry = gst_registry_get ();
157   /* check if feature already exists, if it exists there is no need to update it
158    * when the registry is getting updated, outdated plugins and all their
159    * features are removed and readded.
160    */
161   existing_feature = gst_registry_lookup_feature (registry, name);
162   if (existing_feature) {
163     GST_DEBUG_OBJECT (registry, &quot;update existing feature %p (%s)&quot;,
164         existing_feature, name);
165     factory = GST_TRACER_FACTORY_CAST (existing_feature);
166     factory-&gt;type = type;
167     existing_feature-&gt;loaded = TRUE;
168     gst_object_unref (existing_feature);
169     return TRUE;
170   }
171 
172   factory = g_object_new (GST_TYPE_TRACER_FACTORY, NULL);
173   GST_DEBUG_OBJECT (factory, &quot;new tracer factory for %s&quot;, name);
174 
175   gst_plugin_feature_set_name (GST_PLUGIN_FEATURE_CAST (factory), name);
176   gst_plugin_feature_set_rank (GST_PLUGIN_FEATURE_CAST (factory),
177       GST_RANK_NONE);
178 
179   factory-&gt;type = type;
180   GST_DEBUG_OBJECT (factory, &quot;tracer factory for %u:%s&quot;,
181       (guint) type, g_type_name (type));
182 
183   if (plugin &amp;&amp; plugin-&gt;desc.name) {
184     GST_PLUGIN_FEATURE_CAST (factory)-&gt;plugin_name = plugin-&gt;desc.name; /* interned string */
185     GST_PLUGIN_FEATURE_CAST (factory)-&gt;plugin = plugin;
186     g_object_add_weak_pointer ((GObject *) plugin,
187         (gpointer *) &amp; GST_PLUGIN_FEATURE_CAST (factory)-&gt;plugin);
188   } else {
189     GST_PLUGIN_FEATURE_CAST (factory)-&gt;plugin_name = &quot;NULL&quot;;
190     GST_PLUGIN_FEATURE_CAST (factory)-&gt;plugin = NULL;
191   }
192   GST_PLUGIN_FEATURE_CAST (factory)-&gt;loaded = TRUE;
193 
194   gst_registry_add_feature (gst_registry_get (),
195       GST_PLUGIN_FEATURE_CAST (factory));
196 
197   return TRUE;
198 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>