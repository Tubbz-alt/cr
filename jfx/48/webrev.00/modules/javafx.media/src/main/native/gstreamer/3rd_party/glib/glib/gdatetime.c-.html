<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gdatetime.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* gdatetime.c
   2  *
   3  * Copyright (C) 2009-2010 Christian Hergert &lt;chris@dronelabs.com&gt;
   4  * Copyright (C) 2010 Thiago Santos &lt;thiago.sousa.santos@collabora.co.uk&gt;
   5  * Copyright (C) 2010 Emmanuele Bassi &lt;ebassi@linux.intel.com&gt;
   6  * Copyright � 2010 Codethink Limited
   7  * Copyright � 2018 Tomasz Mi?sko
   8  *
   9  * This library is free software; you can redistribute it and/or modify
  10  * it under the terms of the GNU Lesser General Public License as
  11  * published by the Free Software Foundation; either version 2.1 of the
  12  * licence, or (at your option) any later version.
  13  *
  14  * This is distributed in the hope that it will be useful, but WITHOUT
  15  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  16  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
  17  * License for more details.
  18  *
  19  * You should have received a copy of the GNU Lesser General Public License
  20  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  21  *
  22  * Authors: Christian Hergert &lt;chris@dronelabs.com&gt;
  23  *          Thiago Santos &lt;thiago.sousa.santos@collabora.co.uk&gt;
  24  *          Emmanuele Bassi &lt;ebassi@linux.intel.com&gt;
  25  *          Ryan Lortie &lt;desrt@desrt.ca&gt;
  26  *          Robert Ancell &lt;robert.ancell@canonical.com&gt;
  27  */
  28 
  29 /* Algorithms within this file are based on the Calendar FAQ by
  30  * Claus Tondering.  It can be found at
  31  * http://www.tondering.dk/claus/cal/calendar29.txt
  32  *
  33  * Copyright and disclaimer
  34  * ------------------------
  35  *   This document is Copyright (C) 2008 by Claus Tondering.
  36  *   E-mail: claus@tondering.dk. (Please include the word
  37  *   &quot;calendar&quot; in the subject line.)
  38  *   The document may be freely distributed, provided this
  39  *   copyright notice is included and no money is charged for
  40  *   the document.
  41  *
  42  *   This document is provided &quot;as is&quot;. No warranties are made as
  43  *   to its correctness.
  44  */
  45 
  46 /* Prologue {{{1 */
  47 
  48 #include &quot;config.h&quot;
  49 
  50 /* langinfo.h in glibc 2.27 defines ALTMON_* only if _GNU_SOURCE is defined.  */
  51 #ifndef _GNU_SOURCE
  52 #define _GNU_SOURCE 1
  53 #endif
  54 
  55 #include &lt;stdlib.h&gt;
  56 #include &lt;string.h&gt;
  57 
  58 #ifdef HAVE_LANGINFO_TIME
  59 #include &lt;langinfo.h&gt;
  60 #endif
  61 
  62 #include &quot;gdatetime.h&quot;
  63 
  64 #include &quot;gslice.h&quot;
  65 #include &quot;gatomic.h&quot;
  66 #include &quot;gcharset.h&quot;
  67 #include &quot;gconvert.h&quot;
  68 #include &quot;gfileutils.h&quot;
  69 #include &quot;ghash.h&quot;
  70 #include &quot;gmain.h&quot;
  71 #include &quot;gmappedfile.h&quot;
  72 #include &quot;gstrfuncs.h&quot;
  73 #include &quot;gtestutils.h&quot;
  74 #include &quot;gthread.h&quot;
  75 #include &quot;gtimezone.h&quot;
  76 
  77 #include &quot;glibintl.h&quot;
  78 
  79 #ifndef G_OS_WIN32
  80 #include &lt;sys/time.h&gt;
  81 #include &lt;time.h&gt;
  82 #endif /* !G_OS_WIN32 */
  83 
  84 /**
  85  * SECTION:date-time
  86  * @title: GDateTime
  87  * @short_description: a structure representing Date and Time
  88  * @see_also: #GTimeZone
  89  *
  90  * #GDateTime is a structure that combines a Gregorian date and time
  91  * into a single structure.  It provides many conversion and methods to
  92  * manipulate dates and times.  Time precision is provided down to
  93  * microseconds and the time can range (proleptically) from 0001-01-01
  94  * 00:00:00 to 9999-12-31 23:59:59.999999.  #GDateTime follows POSIX
  95  * time in the sense that it is oblivious to leap seconds.
  96  *
  97  * #GDateTime is an immutable object; once it has been created it cannot
  98  * be modified further.  All modifiers will create a new #GDateTime.
  99  * Nearly all such functions can fail due to the date or time going out
 100  * of range, in which case %NULL will be returned.
 101  *
 102  * #GDateTime is reference counted: the reference count is increased by calling
 103  * g_date_time_ref() and decreased by calling g_date_time_unref(). When the
 104  * reference count drops to 0, the resources allocated by the #GDateTime
 105  * structure are released.
 106  *
 107  * Many parts of the API may produce non-obvious results.  As an
 108  * example, adding two months to January 31st will yield March 31st
 109  * whereas adding one month and then one month again will yield either
 110  * March 28th or March 29th.  Also note that adding 24 hours is not
 111  * always the same as adding one day (since days containing daylight
 112  * savings time transitions are either 23 or 25 hours in length).
 113  *
 114  * #GDateTime is available since GLib 2.26.
 115  */
 116 
 117 struct _GDateTime
 118 {
 119   /* Microsecond timekeeping within Day */
 120   guint64 usec;
 121 
 122   /* TimeZone information */
 123   GTimeZone *tz;
 124   gint interval;
 125 
 126   /* 1 is 0001-01-01 in Proleptic Gregorian */
 127   gint32 days;
 128 
 129   volatile gint ref_count;
 130 };
 131 
 132 /* Time conversion {{{1 */
 133 
 134 #define UNIX_EPOCH_START     719163
 135 #define INSTANT_TO_UNIX(instant) \
 136   ((instant)/USEC_PER_SECOND - UNIX_EPOCH_START * SEC_PER_DAY)
 137 #define UNIX_TO_INSTANT(unix) \
 138   (((gint64) (unix) + UNIX_EPOCH_START * SEC_PER_DAY) * USEC_PER_SECOND)
 139 #define UNIX_TO_INSTANT_IS_VALID(unix) \
 140   ((gint64) (unix) &lt;= INSTANT_TO_UNIX (G_MAXINT64))
 141 
 142 #define DAYS_IN_4YEARS    1461    /* days in 4 years */
 143 #define DAYS_IN_100YEARS  36524   /* days in 100 years */
 144 #define DAYS_IN_400YEARS  146097  /* days in 400 years  */
 145 
 146 #define USEC_PER_SECOND      (G_GINT64_CONSTANT (1000000))
 147 #define USEC_PER_MINUTE      (G_GINT64_CONSTANT (60000000))
 148 #define USEC_PER_HOUR        (G_GINT64_CONSTANT (3600000000))
 149 #define USEC_PER_MILLISECOND (G_GINT64_CONSTANT (1000))
 150 #define USEC_PER_DAY         (G_GINT64_CONSTANT (86400000000))
 151 #define SEC_PER_DAY          (G_GINT64_CONSTANT (86400))
 152 
 153 #define SECS_PER_MINUTE (60)
 154 #define SECS_PER_HOUR   (60 * SECS_PER_MINUTE)
 155 #define SECS_PER_DAY    (24 * SECS_PER_HOUR)
 156 #define SECS_PER_YEAR   (365 * SECS_PER_DAY)
 157 #define SECS_PER_JULIAN (DAYS_PER_PERIOD * SECS_PER_DAY)
 158 
 159 #define GREGORIAN_LEAP(y)    ((((y) % 4) == 0) &amp;&amp; (!((((y) % 100) == 0) &amp;&amp; (((y) % 400) != 0))))
 160 #define JULIAN_YEAR(d)       ((d)-&gt;julian / 365.25)
 161 #define DAYS_PER_PERIOD      (G_GINT64_CONSTANT (2914695))
 162 
 163 static const guint16 days_in_months[2][13] =
 164 {
 165   { 0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
 166   { 0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
 167 };
 168 
 169 static const guint16 days_in_year[2][13] =
 170 {
 171   {  0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
 172   {  0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
 173 };
 174 
 175 #ifdef HAVE_LANGINFO_TIME
 176 
 177 #define GET_AMPM(d) ((g_date_time_get_hour (d) &lt; 12) ? \
 178                      nl_langinfo (AM_STR) : \
 179                      nl_langinfo (PM_STR))
 180 #define GET_AMPM_IS_LOCALE TRUE
 181 
 182 #define PREFERRED_DATE_TIME_FMT nl_langinfo (D_T_FMT)
 183 #define PREFERRED_DATE_FMT nl_langinfo (D_FMT)
 184 #define PREFERRED_TIME_FMT nl_langinfo (T_FMT)
 185 #define PREFERRED_12HR_TIME_FMT nl_langinfo (T_FMT_AMPM)
 186 
 187 static const gint weekday_item[2][7] =
 188 {
 189   { ABDAY_2, ABDAY_3, ABDAY_4, ABDAY_5, ABDAY_6, ABDAY_7, ABDAY_1 },
 190   { DAY_2, DAY_3, DAY_4, DAY_5, DAY_6, DAY_7, DAY_1 }
 191 };
 192 
 193 static const gint month_item[2][12] =
 194 {
 195   { ABMON_1, ABMON_2, ABMON_3, ABMON_4, ABMON_5, ABMON_6, ABMON_7, ABMON_8, ABMON_9, ABMON_10, ABMON_11, ABMON_12 },
 196   { MON_1, MON_2, MON_3, MON_4, MON_5, MON_6, MON_7, MON_8, MON_9, MON_10, MON_11, MON_12 },
 197 };
 198 
 199 #define WEEKDAY_ABBR(d) nl_langinfo (weekday_item[0][g_date_time_get_day_of_week (d) - 1])
 200 #define WEEKDAY_ABBR_IS_LOCALE TRUE
 201 #define WEEKDAY_FULL(d) nl_langinfo (weekday_item[1][g_date_time_get_day_of_week (d) - 1])
 202 #define WEEKDAY_FULL_IS_LOCALE TRUE
 203 #define MONTH_ABBR(d) nl_langinfo (month_item[0][g_date_time_get_month (d) - 1])
 204 #define MONTH_ABBR_IS_LOCALE TRUE
 205 #define MONTH_FULL(d) nl_langinfo (month_item[1][g_date_time_get_month (d) - 1])
 206 #define MONTH_FULL_IS_LOCALE TRUE
 207 
 208 #else
 209 
 210 #define GET_AMPM(d)          (get_fallback_ampm (g_date_time_get_hour (d)))
 211 #define GET_AMPM_IS_LOCALE   FALSE
 212 
 213 /* Translators: this is the preferred format for expressing the date and the time */
 214 #define PREFERRED_DATE_TIME_FMT C_(&quot;GDateTime&quot;, &quot;%a %b %e %H:%M:%S %Y&quot;)
 215 
 216 /* Translators: this is the preferred format for expressing the date */
 217 #define PREFERRED_DATE_FMT C_(&quot;GDateTime&quot;, &quot;%m/%d/%y&quot;)
 218 
 219 /* Translators: this is the preferred format for expressing the time */
 220 #define PREFERRED_TIME_FMT C_(&quot;GDateTime&quot;, &quot;%H:%M:%S&quot;)
 221 
 222 /* Translators: this is the preferred format for expressing 12 hour time */
 223 #define PREFERRED_12HR_TIME_FMT C_(&quot;GDateTime&quot;, &quot;%I:%M:%S %p&quot;)
 224 
 225 #define WEEKDAY_ABBR(d)       (get_weekday_name_abbr (g_date_time_get_day_of_week (d)))
 226 #define WEEKDAY_ABBR_IS_LOCALE FALSE
 227 #define WEEKDAY_FULL(d)       (get_weekday_name (g_date_time_get_day_of_week (d)))
 228 #define WEEKDAY_FULL_IS_LOCALE FALSE
 229 /* We don&#39;t yet know if nl_langinfo (MON_n) returns standalone or complete-date
 230  * format forms but if nl_langinfo (ALTMON_n) is not supported then we will
 231  * have to use MONTH_FULL as standalone.  The same if nl_langinfo () does not
 232  * exist at all.  MONTH_ABBR is similar: if nl_langinfo (_NL_ABALTMON_n) is not
 233  * supported then we will use MONTH_ABBR as standalone.
 234  */
 235 #define MONTH_ABBR(d)         (get_month_name_abbr_standalone (g_date_time_get_month (d)))
 236 #define MONTH_ABBR_IS_LOCALE  FALSE
 237 #define MONTH_FULL(d)         (get_month_name_standalone (g_date_time_get_month (d)))
 238 #define MONTH_FULL_IS_LOCALE  FALSE
 239 
 240 static const gchar *
 241 get_month_name_standalone (gint month)
 242 {
 243   switch (month)
 244     {
 245     case 1:
 246       /* Translators: Some languages (Baltic, Slavic, Greek, and some more)
 247        * need different grammatical forms of month names depending on whether
 248        * they are standalone or in a complete date context, with the day
 249        * number.  Some other languages may prefer starting with uppercase when
 250        * they are standalone and with lowercase when they are in a complete
 251        * date context.  Here are full month names in a form appropriate when
 252        * they are used standalone.  If your system is Linux with the glibc
 253        * version 2.27 (released Feb 1, 2018) or newer or if it is from the BSD
 254        * family (which includes OS X) then you can refer to the date command
 255        * line utility and see what the command `date +%OB&#39; produces.  Also in
 256        * the latest Linux the command `locale alt_mon&#39; in your native locale
 257        * produces a complete list of month names almost ready to copy and
 258        * paste here.  Note that in most of the languages (western European,
 259        * non-European) there is no difference between the standalone and
 260        * complete date form.
 261        */
 262       return C_(&quot;full month name&quot;, &quot;January&quot;);
 263     case 2:
 264       return C_(&quot;full month name&quot;, &quot;February&quot;);
 265     case 3:
 266       return C_(&quot;full month name&quot;, &quot;March&quot;);
 267     case 4:
 268       return C_(&quot;full month name&quot;, &quot;April&quot;);
 269     case 5:
 270       return C_(&quot;full month name&quot;, &quot;May&quot;);
 271     case 6:
 272       return C_(&quot;full month name&quot;, &quot;June&quot;);
 273     case 7:
 274       return C_(&quot;full month name&quot;, &quot;July&quot;);
 275     case 8:
 276       return C_(&quot;full month name&quot;, &quot;August&quot;);
 277     case 9:
 278       return C_(&quot;full month name&quot;, &quot;September&quot;);
 279     case 10:
 280       return C_(&quot;full month name&quot;, &quot;October&quot;);
 281     case 11:
 282       return C_(&quot;full month name&quot;, &quot;November&quot;);
 283     case 12:
 284       return C_(&quot;full month name&quot;, &quot;December&quot;);
 285 
 286     default:
 287       g_warning (&quot;Invalid month number %d&quot;, month);
 288     }
 289 
 290   return NULL;
 291 }
 292 
 293 static const gchar *
 294 get_month_name_abbr_standalone (gint month)
 295 {
 296   switch (month)
 297     {
 298     case 1:
 299       /* Translators: Some languages need different grammatical forms of
 300        * month names depending on whether they are standalone or in a complete
 301        * date context, with the day number.  Some may prefer starting with
 302        * uppercase when they are standalone and with lowercase when they are
 303        * in a full date context.  However, as these names are abbreviated
 304        * the grammatical difference is visible probably only in Belarusian
 305        * and Russian.  In other languages there is no difference between
 306        * the standalone and complete date form when they are abbreviated.
 307        * If your system is Linux with the glibc version 2.27 (released
 308        * Feb 1, 2018) or newer then you can refer to the date command line
 309        * utility and see what the command `date +%Ob&#39; produces.  Also in
 310        * the latest Linux the command `locale ab_alt_mon&#39; in your native
 311        * locale produces a complete list of month names almost ready to copy
 312        * and paste here.  Note that this feature is not yet supported by any
 313        * other platform.  Here are abbreviated month names in a form
 314        * appropriate when they are used standalone.
 315        */
 316       return C_(&quot;abbreviated month name&quot;, &quot;Jan&quot;);
 317     case 2:
 318       return C_(&quot;abbreviated month name&quot;, &quot;Feb&quot;);
 319     case 3:
 320       return C_(&quot;abbreviated month name&quot;, &quot;Mar&quot;);
 321     case 4:
 322       return C_(&quot;abbreviated month name&quot;, &quot;Apr&quot;);
 323     case 5:
 324       return C_(&quot;abbreviated month name&quot;, &quot;May&quot;);
 325     case 6:
 326       return C_(&quot;abbreviated month name&quot;, &quot;Jun&quot;);
 327     case 7:
 328       return C_(&quot;abbreviated month name&quot;, &quot;Jul&quot;);
 329     case 8:
 330       return C_(&quot;abbreviated month name&quot;, &quot;Aug&quot;);
 331     case 9:
 332       return C_(&quot;abbreviated month name&quot;, &quot;Sep&quot;);
 333     case 10:
 334       return C_(&quot;abbreviated month name&quot;, &quot;Oct&quot;);
 335     case 11:
 336       return C_(&quot;abbreviated month name&quot;, &quot;Nov&quot;);
 337     case 12:
 338       return C_(&quot;abbreviated month name&quot;, &quot;Dec&quot;);
 339 
 340     default:
 341       g_warning (&quot;Invalid month number %d&quot;, month);
 342     }
 343 
 344   return NULL;
 345 }
 346 
 347 static const gchar *
 348 get_weekday_name (gint day)
 349 {
 350   switch (day)
 351     {
 352     case 1:
 353       return C_(&quot;full weekday name&quot;, &quot;Monday&quot;);
 354     case 2:
 355       return C_(&quot;full weekday name&quot;, &quot;Tuesday&quot;);
 356     case 3:
 357       return C_(&quot;full weekday name&quot;, &quot;Wednesday&quot;);
 358     case 4:
 359       return C_(&quot;full weekday name&quot;, &quot;Thursday&quot;);
 360     case 5:
 361       return C_(&quot;full weekday name&quot;, &quot;Friday&quot;);
 362     case 6:
 363       return C_(&quot;full weekday name&quot;, &quot;Saturday&quot;);
 364     case 7:
 365       return C_(&quot;full weekday name&quot;, &quot;Sunday&quot;);
 366 
 367     default:
 368       g_warning (&quot;Invalid week day number %d&quot;, day);
 369     }
 370 
 371   return NULL;
 372 }
 373 
 374 static const gchar *
 375 get_weekday_name_abbr (gint day)
 376 {
 377   switch (day)
 378     {
 379     case 1:
 380       return C_(&quot;abbreviated weekday name&quot;, &quot;Mon&quot;);
 381     case 2:
 382       return C_(&quot;abbreviated weekday name&quot;, &quot;Tue&quot;);
 383     case 3:
 384       return C_(&quot;abbreviated weekday name&quot;, &quot;Wed&quot;);
 385     case 4:
 386       return C_(&quot;abbreviated weekday name&quot;, &quot;Thu&quot;);
 387     case 5:
 388       return C_(&quot;abbreviated weekday name&quot;, &quot;Fri&quot;);
 389     case 6:
 390       return C_(&quot;abbreviated weekday name&quot;, &quot;Sat&quot;);
 391     case 7:
 392       return C_(&quot;abbreviated weekday name&quot;, &quot;Sun&quot;);
 393 
 394     default:
 395       g_warning (&quot;Invalid week day number %d&quot;, day);
 396     }
 397 
 398   return NULL;
 399 }
 400 
 401 #endif  /* HAVE_LANGINFO_TIME */
 402 
 403 #ifdef HAVE_LANGINFO_ALTMON
 404 
 405 /* If nl_langinfo () supports ALTMON_n then MON_n returns full date format
 406  * forms and ALTMON_n returns standalone forms.
 407  */
 408 
 409 #define MONTH_FULL_WITH_DAY(d) MONTH_FULL(d)
 410 #define MONTH_FULL_WITH_DAY_IS_LOCALE MONTH_FULL_IS_LOCALE
 411 
 412 static const gint alt_month_item[12] =
 413 {
 414   ALTMON_1, ALTMON_2, ALTMON_3, ALTMON_4, ALTMON_5, ALTMON_6,
 415   ALTMON_7, ALTMON_8, ALTMON_9, ALTMON_10, ALTMON_11, ALTMON_12
 416 };
 417 
 418 #define MONTH_FULL_STANDALONE(d) nl_langinfo (alt_month_item[g_date_time_get_month (d) - 1])
 419 #define MONTH_FULL_STANDALONE_IS_LOCALE TRUE
 420 
 421 #else
 422 
 423 /* If nl_langinfo () does not support ALTMON_n then either MON_n returns
 424  * standalone forms or nl_langinfo (MON_n) does not work so we have defined
 425  * it as standalone form.
 426  */
 427 
 428 #define MONTH_FULL_STANDALONE(d) MONTH_FULL(d)
 429 #define MONTH_FULL_STANDALONE_IS_LOCALE MONTH_FULL_IS_LOCALE
 430 #define MONTH_FULL_WITH_DAY(d) (get_month_name_with_day (g_date_time_get_month (d)))
 431 #define MONTH_FULL_WITH_DAY_IS_LOCALE FALSE
 432 
 433 static const gchar *
 434 get_month_name_with_day (gint month)
 435 {
 436   switch (month)
 437     {
 438     case 1:
 439       /* Translators: Some languages need different grammatical forms of
 440        * month names depending on whether they are standalone or in a full
 441        * date context, with the day number.  Some may prefer starting with
 442        * uppercase when they are standalone and with lowercase when they are
 443        * in a full date context.  Here are full month names in a form
 444        * appropriate when they are used in a full date context, with the
 445        * day number.  If your system is Linux with the glibc version 2.27
 446        * (released Feb 1, 2018) or newer or if it is from the BSD family
 447        * (which includes OS X) then you can refer to the date command line
 448        * utility and see what the command `date +%B&#39; produces.  Also in
 449        * the latest Linux the command `locale mon&#39; in your native locale
 450        * produces a complete list of month names almost ready to copy and
 451        * paste here.  In older Linux systems due to a bug the result is
 452        * incorrect in some languages.  Note that in most of the languages
 453        * (western European, non-European) there is no difference between the
 454        * standalone and complete date form.
 455        */
 456       return C_(&quot;full month name with day&quot;, &quot;January&quot;);
 457     case 2:
 458       return C_(&quot;full month name with day&quot;, &quot;February&quot;);
 459     case 3:
 460       return C_(&quot;full month name with day&quot;, &quot;March&quot;);
 461     case 4:
 462       return C_(&quot;full month name with day&quot;, &quot;April&quot;);
 463     case 5:
 464       return C_(&quot;full month name with day&quot;, &quot;May&quot;);
 465     case 6:
 466       return C_(&quot;full month name with day&quot;, &quot;June&quot;);
 467     case 7:
 468       return C_(&quot;full month name with day&quot;, &quot;July&quot;);
 469     case 8:
 470       return C_(&quot;full month name with day&quot;, &quot;August&quot;);
 471     case 9:
 472       return C_(&quot;full month name with day&quot;, &quot;September&quot;);
 473     case 10:
 474       return C_(&quot;full month name with day&quot;, &quot;October&quot;);
 475     case 11:
 476       return C_(&quot;full month name with day&quot;, &quot;November&quot;);
 477     case 12:
 478       return C_(&quot;full month name with day&quot;, &quot;December&quot;);
 479 
 480     default:
 481       g_warning (&quot;Invalid month number %d&quot;, month);
 482     }
 483 
 484   return NULL;
 485 }
 486 
 487 #endif  /* HAVE_LANGINFO_ALTMON */
 488 
 489 #ifdef HAVE_LANGINFO_ABALTMON
 490 
 491 /* If nl_langinfo () supports _NL_ABALTMON_n then ABMON_n returns full
 492  * date format forms and _NL_ABALTMON_n returns standalone forms.
 493  */
 494 
 495 #define MONTH_ABBR_WITH_DAY(d) MONTH_ABBR(d)
 496 #define MONTH_ABBR_WITH_DAY_IS_LOCALE MONTH_ABBR_IS_LOCALE
 497 
 498 static const gint ab_alt_month_item[12] =
 499 {
 500   _NL_ABALTMON_1, _NL_ABALTMON_2, _NL_ABALTMON_3, _NL_ABALTMON_4,
 501   _NL_ABALTMON_5, _NL_ABALTMON_6, _NL_ABALTMON_7, _NL_ABALTMON_8,
 502   _NL_ABALTMON_9, _NL_ABALTMON_10, _NL_ABALTMON_11, _NL_ABALTMON_12
 503 };
 504 
 505 #define MONTH_ABBR_STANDALONE(d) nl_langinfo (ab_alt_month_item[g_date_time_get_month (d) - 1])
 506 #define MONTH_ABBR_STANDALONE_IS_LOCALE TRUE
 507 
 508 #else
 509 
 510 /* If nl_langinfo () does not support _NL_ABALTMON_n then either ABMON_n
 511  * returns standalone forms or nl_langinfo (ABMON_n) does not work so we
 512  * have defined it as standalone form. Now it&#39;s time to swap.
 513  */
 514 
 515 #define MONTH_ABBR_STANDALONE(d) MONTH_ABBR(d)
 516 #define MONTH_ABBR_STANDALONE_IS_LOCALE MONTH_ABBR_IS_LOCALE
 517 #define MONTH_ABBR_WITH_DAY(d) (get_month_name_abbr_with_day (g_date_time_get_month (d)))
 518 #define MONTH_ABBR_WITH_DAY_IS_LOCALE FALSE
 519 
 520 static const gchar *
 521 get_month_name_abbr_with_day (gint month)
 522 {
 523   switch (month)
 524     {
 525     case 1:
 526       /* Translators: Some languages need different grammatical forms of
 527        * month names depending on whether they are standalone or in a full
 528        * date context, with the day number.  Some may prefer starting with
 529        * uppercase when they are standalone and with lowercase when they are
 530        * in a full date context.  Here are abbreviated month names in a form
 531        * appropriate when they are used in a full date context, with the
 532        * day number.  However, as these names are abbreviated the grammatical
 533        * difference is visible probably only in Belarusian and Russian.
 534        * In other languages there is no difference between the standalone
 535        * and complete date form when they are abbreviated.  If your system
 536        * is Linux with the glibc version 2.27 (released Feb 1, 2018) or newer
 537        * then you can refer to the date command line utility and see what the
 538        * command `date +%b&#39; produces.  Also in the latest Linux the command
 539        * `locale abmon&#39; in your native locale produces a complete list of
 540        * month names almost ready to copy and paste here.  In other systems
 541        * due to a bug the result is incorrect in some languages.
 542        */
 543       return C_(&quot;abbreviated month name with day&quot;, &quot;Jan&quot;);
 544     case 2:
 545       return C_(&quot;abbreviated month name with day&quot;, &quot;Feb&quot;);
 546     case 3:
 547       return C_(&quot;abbreviated month name with day&quot;, &quot;Mar&quot;);
 548     case 4:
 549       return C_(&quot;abbreviated month name with day&quot;, &quot;Apr&quot;);
 550     case 5:
 551       return C_(&quot;abbreviated month name with day&quot;, &quot;May&quot;);
 552     case 6:
 553       return C_(&quot;abbreviated month name with day&quot;, &quot;Jun&quot;);
 554     case 7:
 555       return C_(&quot;abbreviated month name with day&quot;, &quot;Jul&quot;);
 556     case 8:
 557       return C_(&quot;abbreviated month name with day&quot;, &quot;Aug&quot;);
 558     case 9:
 559       return C_(&quot;abbreviated month name with day&quot;, &quot;Sep&quot;);
 560     case 10:
 561       return C_(&quot;abbreviated month name with day&quot;, &quot;Oct&quot;);
 562     case 11:
 563       return C_(&quot;abbreviated month name with day&quot;, &quot;Nov&quot;);
 564     case 12:
 565       return C_(&quot;abbreviated month name with day&quot;, &quot;Dec&quot;);
 566 
 567     default:
 568       g_warning (&quot;Invalid month number %d&quot;, month);
 569     }
 570 
 571   return NULL;
 572 }
 573 
 574 #endif  /* HAVE_LANGINFO_ABALTMON */
 575 
 576 /* Format AM/PM indicator if the locale does not have a localized version. */
 577 static const gchar *
 578 get_fallback_ampm (gint hour)
 579 {
 580   if (hour &lt; 12)
 581     /* Translators: &#39;before midday&#39; indicator */
 582     return C_(&quot;GDateTime&quot;, &quot;AM&quot;);
 583   else
 584     /* Translators: &#39;after midday&#39; indicator */
 585     return C_(&quot;GDateTime&quot;, &quot;PM&quot;);
 586 }
 587 
 588 static inline gint
 589 ymd_to_days (gint year,
 590              gint month,
 591              gint day)
 592 {
 593   gint64 days;
 594 
 595   days = (year - 1) * 365 + ((year - 1) / 4) - ((year - 1) / 100)
 596       + ((year - 1) / 400);
 597 
 598   days += days_in_year[0][month - 1];
 599   if (GREGORIAN_LEAP (year) &amp;&amp; month &gt; 2)
 600     day++;
 601 
 602   days += day;
 603 
 604   return days;
 605 }
 606 
 607 static void
 608 g_date_time_get_week_number (GDateTime *datetime,
 609                              gint      *week_number,
 610                              gint      *day_of_week,
 611                              gint      *day_of_year)
 612 {
 613   gint a, b, c, d, e, f, g, n, s, month, day, year;
 614 
 615   g_date_time_get_ymd (datetime, &amp;year, &amp;month, &amp;day);
 616 
 617   if (month &lt;= 2)
 618     {
 619       a = g_date_time_get_year (datetime) - 1;
 620       b = (a / 4) - (a / 100) + (a / 400);
 621       c = ((a - 1) / 4) - ((a - 1) / 100) + ((a - 1) / 400);
 622       s = b - c;
 623       e = 0;
 624       f = day - 1 + (31 * (month - 1));
 625     }
 626   else
 627     {
 628       a = year;
 629       b = (a / 4) - (a / 100) + (a / 400);
 630       c = ((a - 1) / 4) - ((a - 1) / 100) + ((a - 1) / 400);
 631       s = b - c;
 632       e = s + 1;
 633       f = day + (((153 * (month - 3)) + 2) / 5) + 58 + s;
 634     }
 635 
 636   g = (a + b) % 7;
 637   d = (f + g - e) % 7;
 638   n = f + 3 - d;
 639 
 640   if (week_number)
 641     {
 642       if (n &lt; 0)
 643         *week_number = 53 - ((g - s) / 5);
 644       else if (n &gt; 364 + s)
 645         *week_number = 1;
 646       else
 647         *week_number = (n / 7) + 1;
 648     }
 649 
 650   if (day_of_week)
 651     *day_of_week = d + 1;
 652 
 653   if (day_of_year)
 654     *day_of_year = f + 1;
 655 }
 656 
 657 /* Lifecycle {{{1 */
 658 
 659 static GDateTime *
 660 g_date_time_alloc (GTimeZone *tz)
 661 {
 662   GDateTime *datetime;
 663 
 664   datetime = g_slice_new0 (GDateTime);
 665   datetime-&gt;tz = g_time_zone_ref (tz);
 666   datetime-&gt;ref_count = 1;
 667 
 668   return datetime;
 669 }
 670 
 671 /**
 672  * g_date_time_ref:
 673  * @datetime: a #GDateTime
 674  *
 675  * Atomically increments the reference count of @datetime by one.
 676  *
 677  * Returns: the #GDateTime with the reference count increased
 678  *
 679  * Since: 2.26
 680  */
 681 GDateTime *
 682 g_date_time_ref (GDateTime *datetime)
 683 {
 684   g_return_val_if_fail (datetime != NULL, NULL);
 685   g_return_val_if_fail (datetime-&gt;ref_count &gt; 0, NULL);
 686 
 687   g_atomic_int_inc (&amp;datetime-&gt;ref_count);
 688 
 689   return datetime;
 690 }
 691 
 692 /**
 693  * g_date_time_unref:
 694  * @datetime: a #GDateTime
 695  *
 696  * Atomically decrements the reference count of @datetime by one.
 697  *
 698  * When the reference count reaches zero, the resources allocated by
 699  * @datetime are freed
 700  *
 701  * Since: 2.26
 702  */
 703 void
 704 g_date_time_unref (GDateTime *datetime)
 705 {
 706   g_return_if_fail (datetime != NULL);
 707   g_return_if_fail (datetime-&gt;ref_count &gt; 0);
 708 
 709   if (g_atomic_int_dec_and_test (&amp;datetime-&gt;ref_count))
 710     {
 711       g_time_zone_unref (datetime-&gt;tz);
 712       g_slice_free (GDateTime, datetime);
 713     }
 714 }
 715 
 716 /* Internal state transformers {{{1 */
 717 /*&lt; internal &gt;
 718  * g_date_time_to_instant:
 719  * @datetime: a #GDateTime
 720  *
 721  * Convert a @datetime into an instant.
 722  *
 723  * An instant is a number that uniquely describes a particular
 724  * microsecond in time, taking time zone considerations into account.
 725  * (ie: &quot;03:00 -0400&quot; is the same instant as &quot;02:00 -0500&quot;).
 726  *
 727  * An instant is always positive but we use a signed return value to
 728  * avoid troubles with C.
 729  */
 730 static gint64
 731 g_date_time_to_instant (GDateTime *datetime)
 732 {
 733   gint64 offset;
 734 
 735   offset = g_time_zone_get_offset (datetime-&gt;tz, datetime-&gt;interval);
 736   offset *= USEC_PER_SECOND;
 737 
 738   return datetime-&gt;days * USEC_PER_DAY + datetime-&gt;usec - offset;
 739 }
 740 
 741 /*&lt; internal &gt;
 742  * g_date_time_from_instant:
 743  * @tz: a #GTimeZone
 744  * @instant: a instant in time
 745  *
 746  * Creates a #GDateTime from a time zone and an instant.
 747  *
 748  * This might fail if the time ends up being out of range.
 749  */
 750 static GDateTime *
 751 g_date_time_from_instant (GTimeZone *tz,
 752                           gint64     instant)
 753 {
 754   GDateTime *datetime;
 755   gint64 offset;
 756 
 757   if (instant &lt; 0 || instant &gt; G_GINT64_CONSTANT (1000000000000000000))
 758     return NULL;
 759 
 760   datetime = g_date_time_alloc (tz);
 761   datetime-&gt;interval = g_time_zone_find_interval (tz,
 762                                                   G_TIME_TYPE_UNIVERSAL,
 763                                                   INSTANT_TO_UNIX (instant));
 764   offset = g_time_zone_get_offset (datetime-&gt;tz, datetime-&gt;interval);
 765   offset *= USEC_PER_SECOND;
 766 
 767   instant += offset;
 768 
 769   datetime-&gt;days = instant / USEC_PER_DAY;
 770   datetime-&gt;usec = instant % USEC_PER_DAY;
 771 
 772   if (datetime-&gt;days &lt; 1 || 3652059 &lt; datetime-&gt;days)
 773     {
 774       g_date_time_unref (datetime);
 775       datetime = NULL;
 776     }
 777 
 778   return datetime;
 779 }
 780 
 781 
 782 /*&lt; internal &gt;
 783  * g_date_time_deal_with_date_change:
 784  * @datetime: a #GDateTime
 785  *
 786  * This function should be called whenever the date changes by adding
 787  * days, months or years.  It does three things.
 788  *
 789  * First, we ensure that the date falls between 0001-01-01 and
 790  * 9999-12-31 and return %FALSE if it does not.
 791  *
 792  * Next we update the -&gt;interval field.
 793  *
 794  * Finally, we ensure that the resulting date and time pair exists (by
 795  * ensuring that our time zone has an interval containing it) and
 796  * adjusting as required.  For example, if we have the time 02:30:00 on
 797  * March 13 2010 in Toronto and we add 1 day to it, we would end up with
 798  * 2:30am on March 14th, which doesn&#39;t exist.  In that case, we bump the
 799  * time up to 3:00am.
 800  */
 801 static gboolean
 802 g_date_time_deal_with_date_change (GDateTime *datetime)
 803 {
 804   GTimeType was_dst;
 805   gint64 full_time;
 806   gint64 usec;
 807 
 808   if (datetime-&gt;days &lt; 1 || datetime-&gt;days &gt; 3652059)
 809     return FALSE;
 810 
 811   was_dst = g_time_zone_is_dst (datetime-&gt;tz, datetime-&gt;interval);
 812 
 813   full_time = datetime-&gt;days * USEC_PER_DAY + datetime-&gt;usec;
 814 
 815 
 816   usec = full_time % USEC_PER_SECOND;
 817   full_time /= USEC_PER_SECOND;
 818   full_time -= UNIX_EPOCH_START * SEC_PER_DAY;
 819 
 820   datetime-&gt;interval = g_time_zone_adjust_time (datetime-&gt;tz,
 821                                                 was_dst,
 822                                                 &amp;full_time);
 823   full_time += UNIX_EPOCH_START * SEC_PER_DAY;
 824   full_time *= USEC_PER_SECOND;
 825   full_time += usec;
 826 
 827   datetime-&gt;days = full_time / USEC_PER_DAY;
 828   datetime-&gt;usec = full_time % USEC_PER_DAY;
 829 
 830   /* maybe daylight time caused us to shift to a different day,
 831    * but it definitely didn&#39;t push us into a different year */
 832   return TRUE;
 833 }
 834 
 835 static GDateTime *
 836 g_date_time_replace_days (GDateTime *datetime,
 837                           gint       days)
 838 {
 839   GDateTime *new;
 840 
 841   new = g_date_time_alloc (datetime-&gt;tz);
 842   new-&gt;interval = datetime-&gt;interval;
 843   new-&gt;usec = datetime-&gt;usec;
 844   new-&gt;days = days;
 845 
 846   if (!g_date_time_deal_with_date_change (new))
 847     {
 848       g_date_time_unref (new);
 849       new = NULL;
 850     }
 851 
 852   return new;
 853 }
 854 
 855 /* now/unix/timeval Constructors {{{1 */
 856 
 857 /*&lt; internal &gt;
 858  * g_date_time_new_from_timeval:
 859  * @tz: a #GTimeZone
 860  * @tv: a #GTimeVal
 861  *
 862  * Creates a #GDateTime corresponding to the given #GTimeVal @tv in the
 863  * given time zone @tz.
 864  *
 865  * The time contained in a #GTimeVal is always stored in the form of
 866  * seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the
 867  * given time zone.
 868  *
 869  * This call can fail (returning %NULL) if @tv represents a time outside
 870  * of the supported range of #GDateTime.
 871  *
 872  * You should release the return value by calling g_date_time_unref()
 873  * when you are done with it.
 874  *
 875  * Returns: a new #GDateTime, or %NULL
 876  *
 877  * Since: 2.26
 878  **/
 879 static GDateTime *
 880 g_date_time_new_from_timeval (GTimeZone      *tz,
 881                               const GTimeVal *tv)
 882 {
 883   if ((gint64) tv-&gt;tv_sec &gt; G_MAXINT64 - 1 ||
 884       !UNIX_TO_INSTANT_IS_VALID ((gint64) tv-&gt;tv_sec + 1))
 885     return NULL;
 886 
 887   return g_date_time_from_instant (tz, tv-&gt;tv_usec +
 888                                    UNIX_TO_INSTANT (tv-&gt;tv_sec));
 889 }
 890 
 891 /*&lt; internal &gt;
 892  * g_date_time_new_from_unix:
 893  * @tz: a #GTimeZone
 894  * @t: the Unix time
 895  *
 896  * Creates a #GDateTime corresponding to the given Unix time @t in the
 897  * given time zone @tz.
 898  *
 899  * Unix time is the number of seconds that have elapsed since 1970-01-01
 900  * 00:00:00 UTC, regardless of the time zone given.
 901  *
 902  * This call can fail (returning %NULL) if @t represents a time outside
 903  * of the supported range of #GDateTime.
 904  *
 905  * You should release the return value by calling g_date_time_unref()
 906  * when you are done with it.
 907  *
 908  * Returns: a new #GDateTime, or %NULL
 909  *
 910  * Since: 2.26
 911  **/
 912 static GDateTime *
 913 g_date_time_new_from_unix (GTimeZone *tz,
 914                            gint64     secs)
 915 {
 916   if (!UNIX_TO_INSTANT_IS_VALID (secs))
 917     return NULL;
 918 
 919   return g_date_time_from_instant (tz, UNIX_TO_INSTANT (secs));
 920 }
 921 
 922 /**
 923  * g_date_time_new_now:
 924  * @tz: a #GTimeZone
 925  *
 926  * Creates a #GDateTime corresponding to this exact instant in the given
 927  * time zone @tz.  The time is as accurate as the system allows, to a
 928  * maximum accuracy of 1 microsecond.
 929  *
 930  * This function will always succeed unless the system clock is set to
 931  * truly insane values (or unless GLib is still being used after the
 932  * year 9999).
 933  *
 934  * You should release the return value by calling g_date_time_unref()
 935  * when you are done with it.
 936  *
 937  * Returns: a new #GDateTime, or %NULL
 938  *
 939  * Since: 2.26
 940  **/
 941 GDateTime *
 942 g_date_time_new_now (GTimeZone *tz)
 943 {
 944   GTimeVal tv;
 945 
 946   g_get_current_time (&amp;tv);
 947 
 948   return g_date_time_new_from_timeval (tz, &amp;tv);
 949 }
 950 
 951 /**
 952  * g_date_time_new_now_local:
 953  *
 954  * Creates a #GDateTime corresponding to this exact instant in the local
 955  * time zone.
 956  *
 957  * This is equivalent to calling g_date_time_new_now() with the time
 958  * zone returned by g_time_zone_new_local().
 959  *
 960  * Returns: a new #GDateTime, or %NULL
 961  *
 962  * Since: 2.26
 963  **/
 964 GDateTime *
 965 g_date_time_new_now_local (void)
 966 {
 967   GDateTime *datetime;
 968   GTimeZone *local;
 969 
 970   local = g_time_zone_new_local ();
 971   datetime = g_date_time_new_now (local);
 972   g_time_zone_unref (local);
 973 
 974   return datetime;
 975 }
 976 
 977 /**
 978  * g_date_time_new_now_utc:
 979  *
 980  * Creates a #GDateTime corresponding to this exact instant in UTC.
 981  *
 982  * This is equivalent to calling g_date_time_new_now() with the time
 983  * zone returned by g_time_zone_new_utc().
 984  *
 985  * Returns: a new #GDateTime, or %NULL
 986  *
 987  * Since: 2.26
 988  **/
 989 GDateTime *
 990 g_date_time_new_now_utc (void)
 991 {
 992   GDateTime *datetime;
 993   GTimeZone *utc;
 994 
 995   utc = g_time_zone_new_utc ();
 996   datetime = g_date_time_new_now (utc);
 997   g_time_zone_unref (utc);
 998 
 999   return datetime;
1000 }
1001 
1002 /**
1003  * g_date_time_new_from_unix_local:
1004  * @t: the Unix time
1005  *
1006  * Creates a #GDateTime corresponding to the given Unix time @t in the
1007  * local time zone.
1008  *
1009  * Unix time is the number of seconds that have elapsed since 1970-01-01
1010  * 00:00:00 UTC, regardless of the local time offset.
1011  *
1012  * This call can fail (returning %NULL) if @t represents a time outside
1013  * of the supported range of #GDateTime.
1014  *
1015  * You should release the return value by calling g_date_time_unref()
1016  * when you are done with it.
1017  *
1018  * Returns: a new #GDateTime, or %NULL
1019  *
1020  * Since: 2.26
1021  **/
1022 GDateTime *
1023 g_date_time_new_from_unix_local (gint64 t)
1024 {
1025   GDateTime *datetime;
1026   GTimeZone *local;
1027 
1028   local = g_time_zone_new_local ();
1029   datetime = g_date_time_new_from_unix (local, t);
1030   g_time_zone_unref (local);
1031 
1032   return datetime;
1033 }
1034 
1035 /**
1036  * g_date_time_new_from_unix_utc:
1037  * @t: the Unix time
1038  *
1039  * Creates a #GDateTime corresponding to the given Unix time @t in UTC.
1040  *
1041  * Unix time is the number of seconds that have elapsed since 1970-01-01
1042  * 00:00:00 UTC.
1043  *
1044  * This call can fail (returning %NULL) if @t represents a time outside
1045  * of the supported range of #GDateTime.
1046  *
1047  * You should release the return value by calling g_date_time_unref()
1048  * when you are done with it.
1049  *
1050  * Returns: a new #GDateTime, or %NULL
1051  *
1052  * Since: 2.26
1053  **/
1054 GDateTime *
1055 g_date_time_new_from_unix_utc (gint64 t)
1056 {
1057   GDateTime *datetime;
1058   GTimeZone *utc;
1059 
1060   utc = g_time_zone_new_utc ();
1061   datetime = g_date_time_new_from_unix (utc, t);
1062   g_time_zone_unref (utc);
1063 
1064   return datetime;
1065 }
1066 
1067 /**
1068  * g_date_time_new_from_timeval_local:
1069  * @tv: a #GTimeVal
1070  *
1071  * Creates a #GDateTime corresponding to the given #GTimeVal @tv in the
1072  * local time zone.
1073  *
1074  * The time contained in a #GTimeVal is always stored in the form of
1075  * seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the
1076  * local time offset.
1077  *
1078  * This call can fail (returning %NULL) if @tv represents a time outside
1079  * of the supported range of #GDateTime.
1080  *
1081  * You should release the return value by calling g_date_time_unref()
1082  * when you are done with it.
1083  *
1084  * Returns: a new #GDateTime, or %NULL
1085  *
1086  * Since: 2.26
1087  **/
1088 GDateTime *
1089 g_date_time_new_from_timeval_local (const GTimeVal *tv)
1090 {
1091   GDateTime *datetime;
1092   GTimeZone *local;
1093 
1094   local = g_time_zone_new_local ();
1095   datetime = g_date_time_new_from_timeval (local, tv);
1096   g_time_zone_unref (local);
1097 
1098   return datetime;
1099 }
1100 
1101 /**
1102  * g_date_time_new_from_timeval_utc:
1103  * @tv: a #GTimeVal
1104  *
1105  * Creates a #GDateTime corresponding to the given #GTimeVal @tv in UTC.
1106  *
1107  * The time contained in a #GTimeVal is always stored in the form of
1108  * seconds elapsed since 1970-01-01 00:00:00 UTC.
1109  *
1110  * This call can fail (returning %NULL) if @tv represents a time outside
1111  * of the supported range of #GDateTime.
1112  *
1113  * You should release the return value by calling g_date_time_unref()
1114  * when you are done with it.
1115  *
1116  * Returns: a new #GDateTime, or %NULL
1117  *
1118  * Since: 2.26
1119  **/
1120 GDateTime *
1121 g_date_time_new_from_timeval_utc (const GTimeVal *tv)
1122 {
1123   GDateTime *datetime;
1124   GTimeZone *utc;
1125 
1126   utc = g_time_zone_new_utc ();
1127   datetime = g_date_time_new_from_timeval (utc, tv);
1128   g_time_zone_unref (utc);
1129 
1130   return datetime;
1131 }
1132 
1133 /* Parse integers in the form d (week days), dd (hours etc), ddd (ordinal days) or dddd (years) */
1134 static gboolean
1135 get_iso8601_int (const gchar *text, gsize length, gint *value)
1136 {
1137   gint i, v = 0;
1138 
1139   if (length &lt; 1 || length &gt; 4)
1140     return FALSE;
1141 
1142   for (i = 0; i &lt; length; i++)
1143     {
1144       const gchar c = text[i];
1145       if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;)
1146         return FALSE;
1147       v = v * 10 + (c - &#39;0&#39;);
1148     }
1149 
1150   *value = v;
1151   return TRUE;
1152 }
1153 
1154 /* Parse seconds in the form ss or ss.sss (variable length decimal) */
1155 static gboolean
1156 get_iso8601_seconds (const gchar *text, gsize length, gdouble *value)
1157 {
1158   gint i;
1159   gdouble divisor = 1, v = 0;
1160 
1161   if (length &lt; 2)
1162     return FALSE;
1163 
1164   for (i = 0; i &lt; 2; i++)
1165     {
1166       const gchar c = text[i];
1167       if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;)
1168         return FALSE;
1169       v = v * 10 + (c - &#39;0&#39;);
1170     }
1171 
1172   if (length &gt; 2 &amp;&amp; !(text[i] == &#39;.&#39; || text[i] == &#39;,&#39;))
1173     return FALSE;
1174   i++;
1175   if (i == length)
1176     return FALSE;
1177 
1178   for (; i &lt; length; i++)
1179     {
1180       const gchar c = text[i];
1181       if (c &lt; &#39;0&#39; || c &gt; &#39;9&#39;)
1182         return FALSE;
1183       v = v * 10 + (c - &#39;0&#39;);
1184       divisor *= 10;
1185     }
1186 
1187   *value = v / divisor;
1188   return TRUE;
1189 }
1190 
1191 static GDateTime *
1192 g_date_time_new_ordinal (GTimeZone *tz, gint year, gint ordinal_day, gint hour, gint minute, gdouble seconds)
1193 {
1194   GDateTime *dt;
1195 
1196   if (ordinal_day &lt; 1 || ordinal_day &gt; (GREGORIAN_LEAP (year) ? 366 : 365))
1197     return NULL;
1198 
1199   dt = g_date_time_new (tz, year, 1, 1, hour, minute, seconds);
1200 #ifdef GSTREAMER_LITE
1201   if (dt == NULL) {
1202     return NULL;
1203   }
1204 #endif // GSTREAMER_LITE
1205   dt-&gt;days += ordinal_day - 1;
1206 
1207   return dt;
1208 }
1209 
1210 static GDateTime *
1211 g_date_time_new_week (GTimeZone *tz, gint year, gint week, gint week_day, gint hour, gint minute, gdouble seconds)
1212 {
1213   gint64 p;
1214   gint max_week, jan4_week_day, ordinal_day;
1215   GDateTime *dt;
1216 
1217   p = (year * 365 + (year / 4) - (year / 100) + (year / 400)) % 7;
1218   max_week = p == 4 ? 53 : 52;
1219 
1220   if (week &lt; 1 || week &gt; max_week || week_day &lt; 1 || week_day &gt; 7)
1221     return NULL;
1222 
1223   dt = g_date_time_new (tz, year, 1, 4, 0, 0, 0);
1224   g_date_time_get_week_number (dt, NULL, &amp;jan4_week_day, NULL);
1225   g_date_time_unref (dt);
1226 
1227   ordinal_day = (week * 7) + week_day - (jan4_week_day + 3);
1228   if (ordinal_day &lt; 0)
1229     {
1230       year--;
1231       ordinal_day += GREGORIAN_LEAP (year) ? 366 : 365;
1232     }
1233   else if (ordinal_day &gt; (GREGORIAN_LEAP (year) ? 366 : 365))
1234     {
1235       ordinal_day -= (GREGORIAN_LEAP (year) ? 366 : 365);
1236       year++;
1237     }
1238 
1239   return g_date_time_new_ordinal (tz, year, ordinal_day, hour, minute, seconds);
1240 }
1241 
1242 static GDateTime *
1243 parse_iso8601_date (const gchar *text, gsize length,
1244                     gint hour, gint minute, gdouble seconds, GTimeZone *tz)
1245 {
1246   /* YYYY-MM-DD */
1247   if (length == 10 &amp;&amp; text[4] == &#39;-&#39; &amp;&amp; text[7] == &#39;-&#39;)
1248     {
1249       int year, month, day;
1250       if (!get_iso8601_int (text, 4, &amp;year) ||
1251           !get_iso8601_int (text + 5, 2, &amp;month) ||
1252           !get_iso8601_int (text + 8, 2, &amp;day))
1253         return NULL;
1254       return g_date_time_new (tz, year, month, day, hour, minute, seconds);
1255     }
1256   /* YYYY-DDD */
1257   else if (length == 8 &amp;&amp; text[4] == &#39;-&#39;)
1258     {
1259       gint year, ordinal_day;
1260       if (!get_iso8601_int (text, 4, &amp;year) ||
1261           !get_iso8601_int (text + 5, 3, &amp;ordinal_day))
1262         return NULL;
1263       return g_date_time_new_ordinal (tz, year, ordinal_day, hour, minute, seconds);
1264     }
1265   /* YYYY-Www-D */
1266   else if (length == 10 &amp;&amp; text[4] == &#39;-&#39; &amp;&amp; text[5] == &#39;W&#39; &amp;&amp; text[8] == &#39;-&#39;)
1267     {
1268       gint year, week, week_day;
1269       if (!get_iso8601_int (text, 4, &amp;year) ||
1270           !get_iso8601_int (text + 6, 2, &amp;week) ||
1271           !get_iso8601_int (text + 9, 1, &amp;week_day))
1272         return NULL;
1273       return g_date_time_new_week (tz, year, week, week_day, hour, minute, seconds);
1274     }
1275   /* YYYYWwwD */
1276   else if (length == 8 &amp;&amp; text[4] == &#39;W&#39;)
1277     {
1278       gint year, week, week_day;
1279       if (!get_iso8601_int (text, 4, &amp;year) ||
1280           !get_iso8601_int (text + 5, 2, &amp;week) ||
1281           !get_iso8601_int (text + 7, 1, &amp;week_day))
1282         return NULL;
1283       return g_date_time_new_week (tz, year, week, week_day, hour, minute, seconds);
1284     }
1285   /* YYYYMMDD */
1286   else if (length == 8)
1287     {
1288       int year, month, day;
1289       if (!get_iso8601_int (text, 4, &amp;year) ||
1290           !get_iso8601_int (text + 4, 2, &amp;month) ||
1291           !get_iso8601_int (text + 6, 2, &amp;day))
1292         return NULL;
1293       return g_date_time_new (tz, year, month, day, hour, minute, seconds);
1294     }
1295   /* YYYYDDD */
1296   else if (length == 7)
1297     {
1298       gint year, ordinal_day;
1299       if (!get_iso8601_int (text, 4, &amp;year) ||
1300           !get_iso8601_int (text + 4, 3, &amp;ordinal_day))
1301         return NULL;
1302       return g_date_time_new_ordinal (tz, year, ordinal_day, hour, minute, seconds);
1303     }
1304   else
1305     return FALSE;
1306 }
1307 
1308 static GTimeZone *
1309 parse_iso8601_timezone (const gchar *text, gsize length, gssize *tz_offset)
1310 {
1311   gint i, tz_length, offset_sign = 1, offset_hours, offset_minutes;
1312   GTimeZone *tz;
1313 
1314   /* UTC uses Z suffix  */
1315   if (length &gt; 0 &amp;&amp; text[length - 1] == &#39;Z&#39;)
1316     {
1317       *tz_offset = length - 1;
1318       return g_time_zone_new_utc ();
1319     }
1320 
1321   /* Look for &#39;+&#39; or &#39;-&#39; of offset */
1322   for (i = length - 1; i &gt;= 0; i--)
1323     if (text[i] == &#39;+&#39; || text[i] == &#39;-&#39;)
1324       {
1325         offset_sign = text[i] == &#39;-&#39; ? -1 : 1;
1326         break;
1327       }
1328   if (i &lt; 0)
1329     return NULL;
1330   tz_length = length - i;
1331 
1332   /* +hh:mm or -hh:mm */
1333   if (tz_length == 6 &amp;&amp; text[i+3] == &#39;:&#39;)
1334     {
1335       if (!get_iso8601_int (text + i + 1, 2, &amp;offset_hours) ||
1336           !get_iso8601_int (text + i + 4, 2, &amp;offset_minutes))
1337         return NULL;
1338     }
1339   /* +hhmm or -hhmm */
1340   else if (tz_length == 5)
1341     {
1342       if (!get_iso8601_int (text + i + 1, 2, &amp;offset_hours) ||
1343           !get_iso8601_int (text + i + 3, 2, &amp;offset_minutes))
1344         return NULL;
1345     }
1346   /* +hh or -hh */
1347   else if (tz_length == 3)
1348     {
1349       if (!get_iso8601_int (text + i + 1, 2, &amp;offset_hours))
1350         return NULL;
1351       offset_minutes = 0;
1352     }
1353   else
1354     return NULL;
1355 
1356   *tz_offset = i;
1357   tz = g_time_zone_new (text + i);
1358 
1359   /* Double-check that the GTimeZone matches our interpretation of the timezone.
1360    * Failure would indicate a bug either here of in the GTimeZone code. */
1361   g_assert (g_time_zone_get_offset (tz, 0) == offset_sign * (offset_hours * 3600 + offset_minutes * 60));
1362 
1363   return tz;
1364 }
1365 
1366 static gboolean
1367 parse_iso8601_time (const gchar *text, gsize length,
1368                     gint *hour, gint *minute, gdouble *seconds, GTimeZone **tz)
1369 {
1370   gssize tz_offset = -1;
1371 
1372   /* Check for timezone suffix */
1373   *tz = parse_iso8601_timezone (text, length, &amp;tz_offset);
1374   if (tz_offset &gt;= 0)
1375     length = tz_offset;
1376 
1377   /* hh:mm:ss(.sss) */
1378   if (length &gt;= 8 &amp;&amp; text[2] == &#39;:&#39; &amp;&amp; text[5] == &#39;:&#39;)
1379     {
1380       return get_iso8601_int (text, 2, hour) &amp;&amp;
1381              get_iso8601_int (text + 3, 2, minute) &amp;&amp;
1382              get_iso8601_seconds (text + 6, length - 6, seconds);
1383     }
1384   /* hhmmss(.sss) */
1385   else if (length &gt;= 6)
1386     {
1387       return get_iso8601_int (text, 2, hour) &amp;&amp;
1388              get_iso8601_int (text + 2, 2, minute) &amp;&amp;
1389              get_iso8601_seconds (text + 4, length - 4, seconds);
1390     }
1391   else
1392     return FALSE;
1393 }
1394 
1395 /**
1396  * g_date_time_new_from_iso8601:
1397  * @text: an ISO 8601 formatted time string.
1398  * @default_tz: (nullable): a #GTimeZone to use if the text doesn&#39;t contain a
1399  *                          timezone, or %NULL.
1400  *
1401  * Creates a #GDateTime corresponding to the given
1402  * [ISO 8601 formatted string](https://en.wikipedia.org/wiki/ISO_8601)
1403  * @text. ISO 8601 strings of the form &lt;date&gt;&lt;sep&gt;&lt;time&gt;&lt;tz&gt; are supported.
1404  *
1405  * &lt;sep&gt; is the separator and can be either &#39;T&#39;, &#39;t&#39; or &#39; &#39;.
1406  *
1407  * &lt;date&gt; is in the form:
1408  *
1409  * - `YYYY-MM-DD` - Year/month/day, e.g. 2016-08-24.
1410  * - `YYYYMMDD` - Same as above without dividers.
1411  * - `YYYY-DDD` - Ordinal day where DDD is from 001 to 366, e.g. 2016-237.
1412  * - `YYYYDDD` - Same as above without dividers.
1413  * - `YYYY-Www-D` - Week day where ww is from 01 to 52 and D from 1-7,
1414  *   e.g. 2016-W34-3.
1415  * - `YYYYWwwD` - Same as above without dividers.
1416  *
1417  * &lt;time&gt; is in the form:
1418  *
1419  * - `hh:mm:ss(.sss)` - Hours, minutes, seconds (subseconds), e.g. 22:10:42.123.
1420  * - `hhmmss(.sss)` - Same as above without dividers.
1421  *
1422  * &lt;tz&gt; is an optional timezone suffix of the form:
1423  *
1424  * - `Z` - UTC.
1425  * - `+hh:mm` or `-hh:mm` - Offset from UTC in hours and minutes, e.g. +12:00.
1426  * - `+hh` or `-hh` - Offset from UTC in hours, e.g. +12.
1427  *
1428  * If the timezone is not provided in @text it must be provided in @default_tz
1429  * (this field is otherwise ignored).
1430  *
1431  * This call can fail (returning %NULL) if @text is not a valid ISO 8601
1432  * formatted string.
1433  *
1434  * You should release the return value by calling g_date_time_unref()
1435  * when you are done with it.
1436  *
1437  * Returns: (transfer full) (nullable): a new #GDateTime, or %NULL
1438  *
1439  * Since: 2.56
1440  */
1441 GDateTime *
1442 g_date_time_new_from_iso8601 (const gchar *text, GTimeZone *default_tz)
1443 {
1444   gint length, date_length = -1;
1445   gint hour = 0, minute = 0;
1446   gdouble seconds = 0.0;
1447   GTimeZone *tz = NULL;
1448   GDateTime *datetime = NULL;
1449 
1450   g_return_val_if_fail (text != NULL, NULL);
1451 
1452   /* Count length of string and find date / time separator (&#39;T&#39;, &#39;t&#39;, or &#39; &#39;) */
1453   for (length = 0; text[length] != &#39;\0&#39;; length++)
1454     {
1455       if (date_length &lt; 0 &amp;&amp; (text[length] == &#39;T&#39; || text[length] == &#39;t&#39; || text[length] == &#39; &#39;))
1456         date_length = length;
1457     }
1458 
1459   if (date_length &lt; 0)
1460     return NULL;
1461 
1462   if (!parse_iso8601_time (text + date_length + 1, length - (date_length + 1),
1463                            &amp;hour, &amp;minute, &amp;seconds, &amp;tz))
1464     goto out;
1465   if (tz == NULL &amp;&amp; default_tz == NULL)
1466     return NULL;
1467 
1468   datetime = parse_iso8601_date (text, date_length, hour, minute, seconds, tz ? tz : default_tz);
1469 
1470 out:
1471     if (tz != NULL)
1472       g_time_zone_unref (tz);
1473     return datetime;
1474 }
1475 
1476 /* full new functions {{{1 */
1477 
1478 /**
1479  * g_date_time_new:
1480  * @tz: a #GTimeZone
1481  * @year: the year component of the date
1482  * @month: the month component of the date
1483  * @day: the day component of the date
1484  * @hour: the hour component of the date
1485  * @minute: the minute component of the date
1486  * @seconds: the number of seconds past the minute
1487  *
1488  * Creates a new #GDateTime corresponding to the given date and time in
1489  * the time zone @tz.
1490  *
1491  * The @year must be between 1 and 9999, @month between 1 and 12 and @day
1492  * between 1 and 28, 29, 30 or 31 depending on the month and the year.
1493  *
1494  * @hour must be between 0 and 23 and @minute must be between 0 and 59.
1495  *
1496  * @seconds must be at least 0.0 and must be strictly less than 60.0.
1497  * It will be rounded down to the nearest microsecond.
1498  *
1499  * If the given time is not representable in the given time zone (for
1500  * example, 02:30 on March 14th 2010 in Toronto, due to daylight savings
1501  * time) then the time will be rounded up to the nearest existing time
1502  * (in this case, 03:00).  If this matters to you then you should verify
1503  * the return value for containing the same as the numbers you gave.
1504  *
1505  * In the case that the given time is ambiguous in the given time zone
1506  * (for example, 01:30 on November 7th 2010 in Toronto, due to daylight
1507  * savings time) then the time falling within standard (ie:
1508  * non-daylight) time is taken.
1509  *
1510  * It not considered a programmer error for the values to this function
1511  * to be out of range, but in the case that they are, the function will
1512  * return %NULL.
1513  *
1514  * You should release the return value by calling g_date_time_unref()
1515  * when you are done with it.
1516  *
1517  * Returns: a new #GDateTime, or %NULL
1518  *
1519  * Since: 2.26
1520  **/
1521 GDateTime *
1522 g_date_time_new (GTimeZone *tz,
1523                  gint       year,
1524                  gint       month,
1525                  gint       day,
1526                  gint       hour,
1527                  gint       minute,
1528                  gdouble    seconds)
1529 {
1530   GDateTime *datetime;
1531   gint64 full_time;
1532   /* keep these variables as volatile. We do not want them ending up in
1533    * registers - them doing so may cause us to hit precision problems on i386.
1534    * See: https://bugzilla.gnome.org/show_bug.cgi?id=792410 */
1535   volatile gint64 usec;
1536   volatile gdouble usecd;
1537 
1538   g_return_val_if_fail (tz != NULL, NULL);
1539 
1540   if (year &lt; 1 || year &gt; 9999 ||
1541       month &lt; 1 || month &gt; 12 ||
1542       day &lt; 1 || day &gt; days_in_months[GREGORIAN_LEAP (year)][month] ||
1543       hour &lt; 0 || hour &gt; 23 ||
1544       minute &lt; 0 || minute &gt; 59 ||
1545       seconds &lt; 0.0 || seconds &gt;= 60.0)
1546     return NULL;
1547 
1548   datetime = g_date_time_alloc (tz);
1549   datetime-&gt;days = ymd_to_days (year, month, day);
1550   datetime-&gt;usec = (hour   * USEC_PER_HOUR)
1551                  + (minute * USEC_PER_MINUTE)
1552                  + (gint64) (seconds * USEC_PER_SECOND);
1553 
1554   full_time = SEC_PER_DAY *
1555                 (ymd_to_days (year, month, day) - UNIX_EPOCH_START) +
1556               SECS_PER_HOUR * hour +
1557               SECS_PER_MINUTE * minute +
1558               (int) seconds;
1559 
1560   datetime-&gt;interval = g_time_zone_adjust_time (datetime-&gt;tz,
1561                                                 G_TIME_TYPE_STANDARD,
1562                                                 &amp;full_time);
1563 
1564   /* This is the correct way to convert a scaled FP value to integer.
1565    * If this surprises you, please observe that (int)(1.000001 * 1e6)
1566    * is 1000000.  This is not a problem with precision, it&#39;s just how
1567    * FP numbers work.
1568    * See https://bugzilla.gnome.org/show_bug.cgi?id=697715. */
1569   usec = seconds * USEC_PER_SECOND;
1570   usecd = (usec + 1) * 1e-6;
1571   if (usecd &lt;= seconds) {
1572     usec++;
1573   }
1574 
1575   full_time += UNIX_EPOCH_START * SEC_PER_DAY;
1576   datetime-&gt;days = full_time / SEC_PER_DAY;
1577   datetime-&gt;usec = (full_time % SEC_PER_DAY) * USEC_PER_SECOND;
1578   datetime-&gt;usec += usec % USEC_PER_SECOND;
1579 
1580   return datetime;
1581 }
1582 
1583 /**
1584  * g_date_time_new_local:
1585  * @year: the year component of the date
1586  * @month: the month component of the date
1587  * @day: the day component of the date
1588  * @hour: the hour component of the date
1589  * @minute: the minute component of the date
1590  * @seconds: the number of seconds past the minute
1591  *
1592  * Creates a new #GDateTime corresponding to the given date and time in
1593  * the local time zone.
1594  *
1595  * This call is equivalent to calling g_date_time_new() with the time
1596  * zone returned by g_time_zone_new_local().
1597  *
1598  * Returns: a #GDateTime, or %NULL
1599  *
1600  * Since: 2.26
1601  **/
1602 GDateTime *
1603 g_date_time_new_local (gint    year,
1604                        gint    month,
1605                        gint    day,
1606                        gint    hour,
1607                        gint    minute,
1608                        gdouble seconds)
1609 {
1610   GDateTime *datetime;
1611   GTimeZone *local;
1612 
1613   local = g_time_zone_new_local ();
1614   datetime = g_date_time_new (local, year, month, day, hour, minute, seconds);
1615   g_time_zone_unref (local);
1616 
1617   return datetime;
1618 }
1619 
1620 /**
1621  * g_date_time_new_utc:
1622  * @year: the year component of the date
1623  * @month: the month component of the date
1624  * @day: the day component of the date
1625  * @hour: the hour component of the date
1626  * @minute: the minute component of the date
1627  * @seconds: the number of seconds past the minute
1628  *
1629  * Creates a new #GDateTime corresponding to the given date and time in
1630  * UTC.
1631  *
1632  * This call is equivalent to calling g_date_time_new() with the time
1633  * zone returned by g_time_zone_new_utc().
1634  *
1635  * Returns: a #GDateTime, or %NULL
1636  *
1637  * Since: 2.26
1638  **/
1639 GDateTime *
1640 g_date_time_new_utc (gint    year,
1641                      gint    month,
1642                      gint    day,
1643                      gint    hour,
1644                      gint    minute,
1645                      gdouble seconds)
1646 {
1647   GDateTime *datetime;
1648   GTimeZone *utc;
1649 
1650   utc = g_time_zone_new_utc ();
1651   datetime = g_date_time_new (utc, year, month, day, hour, minute, seconds);
1652   g_time_zone_unref (utc);
1653 
1654   return datetime;
1655 }
1656 
1657 /* Adders {{{1 */
1658 
1659 /**
1660  * g_date_time_add:
1661  * @datetime: a #GDateTime
1662  * @timespan: a #GTimeSpan
1663  *
1664  * Creates a copy of @datetime and adds the specified timespan to the copy.
1665  *
1666  * Returns: the newly created #GDateTime which should be freed with
1667  *   g_date_time_unref().
1668  *
1669  * Since: 2.26
1670  */
1671 GDateTime*
1672 g_date_time_add (GDateTime *datetime,
1673                  GTimeSpan  timespan)
1674 {
1675   return g_date_time_from_instant (datetime-&gt;tz, timespan +
1676                                    g_date_time_to_instant (datetime));
1677 }
1678 
1679 /**
1680  * g_date_time_add_years:
1681  * @datetime: a #GDateTime
1682  * @years: the number of years
1683  *
1684  * Creates a copy of @datetime and adds the specified number of years to the
1685  * copy. Add negative values to subtract years.
1686  *
1687  * As with g_date_time_add_months(), if the resulting date would be 29th
1688  * February on a non-leap year, the day will be clamped to 28th February.
1689  *
1690  * Returns: the newly created #GDateTime which should be freed with
1691  *   g_date_time_unref().
1692  *
1693  * Since: 2.26
1694  */
1695 GDateTime *
1696 g_date_time_add_years (GDateTime *datetime,
1697                        gint       years)
1698 {
1699   gint year, month, day;
1700 
1701   g_return_val_if_fail (datetime != NULL, NULL);
1702 
1703   if (years &lt; -10000 || years &gt; 10000)
1704     return NULL;
1705 
1706   g_date_time_get_ymd (datetime, &amp;year, &amp;month, &amp;day);
1707   year += years;
1708 
1709   /* only possible issue is if we&#39;ve entered a year with no February 29
1710    */
1711   if (month == 2 &amp;&amp; day == 29 &amp;&amp; !GREGORIAN_LEAP (year))
1712     day = 28;
1713 
1714   return g_date_time_replace_days (datetime, ymd_to_days (year, month, day));
1715 }
1716 
1717 /**
1718  * g_date_time_add_months:
1719  * @datetime: a #GDateTime
1720  * @months: the number of months
1721  *
1722  * Creates a copy of @datetime and adds the specified number of months to the
1723  * copy. Add negative values to subtract months.
1724  *
1725  * The day of the month of the resulting #GDateTime is clamped to the number
1726  * of days in the updated calendar month. For example, if adding 1 month to
1727  * 31st January 2018, the result would be 28th February 2018. In 2020 (a leap
1728  * year), the result would be 29th February.
1729  *
1730  * Returns: the newly created #GDateTime which should be freed with
1731  *   g_date_time_unref().
1732  *
1733  * Since: 2.26
1734  */
1735 GDateTime*
1736 g_date_time_add_months (GDateTime *datetime,
1737                         gint       months)
1738 {
1739   gint year, month, day;
1740 
1741   g_return_val_if_fail (datetime != NULL, NULL);
1742   g_date_time_get_ymd (datetime, &amp;year, &amp;month, &amp;day);
1743 
1744   if (months &lt; -120000 || months &gt; 120000)
1745     return NULL;
1746 
1747   year += months / 12;
1748   month += months % 12;
1749   if (month &lt; 1)
1750     {
1751       month += 12;
1752       year--;
1753     }
1754   else if (month &gt; 12)
1755     {
1756       month -= 12;
1757       year++;
1758     }
1759 
1760   day = MIN (day, days_in_months[GREGORIAN_LEAP (year)][month]);
1761 
1762   return g_date_time_replace_days (datetime, ymd_to_days (year, month, day));
1763 }
1764 
1765 /**
1766  * g_date_time_add_weeks:
1767  * @datetime: a #GDateTime
1768  * @weeks: the number of weeks
1769  *
1770  * Creates a copy of @datetime and adds the specified number of weeks to the
1771  * copy. Add negative values to subtract weeks.
1772  *
1773  * Returns: the newly created #GDateTime which should be freed with
1774  *   g_date_time_unref().
1775  *
1776  * Since: 2.26
1777  */
1778 GDateTime*
1779 g_date_time_add_weeks (GDateTime *datetime,
1780                        gint             weeks)
1781 {
1782   g_return_val_if_fail (datetime != NULL, NULL);
1783 
1784   return g_date_time_add_days (datetime, weeks * 7);
1785 }
1786 
1787 /**
1788  * g_date_time_add_days:
1789  * @datetime: a #GDateTime
1790  * @days: the number of days
1791  *
1792  * Creates a copy of @datetime and adds the specified number of days to the
1793  * copy. Add negative values to subtract days.
1794  *
1795  * Returns: the newly created #GDateTime which should be freed with
1796  *   g_date_time_unref().
1797  *
1798  * Since: 2.26
1799  */
1800 GDateTime*
1801 g_date_time_add_days (GDateTime *datetime,
1802                       gint       days)
1803 {
1804   g_return_val_if_fail (datetime != NULL, NULL);
1805 
1806   if (days &lt; -3660000 || days &gt; 3660000)
1807     return NULL;
1808 
1809   return g_date_time_replace_days (datetime, datetime-&gt;days + days);
1810 }
1811 
1812 /**
1813  * g_date_time_add_hours:
1814  * @datetime: a #GDateTime
1815  * @hours: the number of hours to add
1816  *
1817  * Creates a copy of @datetime and adds the specified number of hours.
1818  * Add negative values to subtract hours.
1819  *
1820  * Returns: the newly created #GDateTime which should be freed with
1821  *   g_date_time_unref().
1822  *
1823  * Since: 2.26
1824  */
1825 GDateTime*
1826 g_date_time_add_hours (GDateTime *datetime,
1827                        gint       hours)
1828 {
1829   return g_date_time_add (datetime, hours * USEC_PER_HOUR);
1830 }
1831 
1832 /**
1833  * g_date_time_add_minutes:
1834  * @datetime: a #GDateTime
1835  * @minutes: the number of minutes to add
1836  *
1837  * Creates a copy of @datetime adding the specified number of minutes.
1838  * Add negative values to subtract minutes.
1839  *
1840  * Returns: the newly created #GDateTime which should be freed with
1841  *   g_date_time_unref().
1842  *
1843  * Since: 2.26
1844  */
1845 GDateTime*
1846 g_date_time_add_minutes (GDateTime *datetime,
1847                          gint             minutes)
1848 {
1849   return g_date_time_add (datetime, minutes * USEC_PER_MINUTE);
1850 }
1851 
1852 
1853 /**
1854  * g_date_time_add_seconds:
1855  * @datetime: a #GDateTime
1856  * @seconds: the number of seconds to add
1857  *
1858  * Creates a copy of @datetime and adds the specified number of seconds.
1859  * Add negative values to subtract seconds.
1860  *
1861  * Returns: the newly created #GDateTime which should be freed with
1862  *   g_date_time_unref().
1863  *
1864  * Since: 2.26
1865  */
1866 GDateTime*
1867 g_date_time_add_seconds (GDateTime *datetime,
1868                          gdouble    seconds)
1869 {
1870   return g_date_time_add (datetime, seconds * USEC_PER_SECOND);
1871 }
1872 
1873 /**
1874  * g_date_time_add_full:
1875  * @datetime: a #GDateTime
1876  * @years: the number of years to add
1877  * @months: the number of months to add
1878  * @days: the number of days to add
1879  * @hours: the number of hours to add
1880  * @minutes: the number of minutes to add
1881  * @seconds: the number of seconds to add
1882  *
1883  * Creates a new #GDateTime adding the specified values to the current date and
1884  * time in @datetime. Add negative values to subtract.
1885  *
1886  * Returns: the newly created #GDateTime that should be freed with
1887  *   g_date_time_unref().
1888  *
1889  * Since: 2.26
1890  */
1891 GDateTime *
1892 g_date_time_add_full (GDateTime *datetime,
1893                       gint       years,
1894                       gint       months,
1895                       gint       days,
1896                       gint       hours,
1897                       gint       minutes,
1898                       gdouble    seconds)
1899 {
1900   gint year, month, day;
1901   gint64 full_time;
1902   GDateTime *new;
1903   gint interval;
1904 
1905   g_return_val_if_fail (datetime != NULL, NULL);
1906   g_date_time_get_ymd (datetime, &amp;year, &amp;month, &amp;day);
1907 
1908   months += years * 12;
1909 
1910   if (months &lt; -120000 || months &gt; 120000)
1911     return NULL;
1912 
1913   if (days &lt; -3660000 || days &gt; 3660000)
1914     return NULL;
1915 
1916   year += months / 12;
1917   month += months % 12;
1918   if (month &lt; 1)
1919     {
1920       month += 12;
1921       year--;
1922     }
1923   else if (month &gt; 12)
1924     {
1925       month -= 12;
1926       year++;
1927     }
1928 
1929   day = MIN (day, days_in_months[GREGORIAN_LEAP (year)][month]);
1930 
1931   /* full_time is now in unix (local) time */
1932   full_time = datetime-&gt;usec / USEC_PER_SECOND + SEC_PER_DAY *
1933     (ymd_to_days (year, month, day) + days - UNIX_EPOCH_START);
1934 
1935   interval = g_time_zone_adjust_time (datetime-&gt;tz,
1936                                       g_time_zone_is_dst (datetime-&gt;tz,
1937                                                           datetime-&gt;interval),
1938                                       &amp;full_time);
1939 
1940   /* move to UTC unix time */
1941   full_time -= g_time_zone_get_offset (datetime-&gt;tz, interval);
1942 
1943   /* convert back to an instant, add back fractional seconds */
1944   full_time += UNIX_EPOCH_START * SEC_PER_DAY;
1945   full_time = full_time * USEC_PER_SECOND +
1946               datetime-&gt;usec % USEC_PER_SECOND;
1947 
1948   /* do the actual addition now */
1949   full_time += (hours * USEC_PER_HOUR) +
1950                (minutes * USEC_PER_MINUTE) +
1951                (gint64) (seconds * USEC_PER_SECOND);
1952 
1953   /* find the new interval */
1954   interval = g_time_zone_find_interval (datetime-&gt;tz,
1955                                         G_TIME_TYPE_UNIVERSAL,
1956                                         INSTANT_TO_UNIX (full_time));
1957 
1958   /* convert back into local time */
1959   full_time += USEC_PER_SECOND *
1960                g_time_zone_get_offset (datetime-&gt;tz, interval);
1961 
1962   /* split into days and usec of a new datetime */
1963   new = g_date_time_alloc (datetime-&gt;tz);
1964   new-&gt;interval = interval;
1965   new-&gt;days = full_time / USEC_PER_DAY;
1966   new-&gt;usec = full_time % USEC_PER_DAY;
1967 
1968   /* XXX validate */
1969 
1970   return new;
1971 }
1972 
1973 /* Compare, difference, hash, equal {{{1 */
1974 /**
1975  * g_date_time_compare:
1976  * @dt1: (not nullable): first #GDateTime to compare
1977  * @dt2: (not nullable): second #GDateTime to compare
1978  *
1979  * A comparison function for #GDateTimes that is suitable
1980  * as a #GCompareFunc. Both #GDateTimes must be non-%NULL.
1981  *
1982  * Returns: -1, 0 or 1 if @dt1 is less than, equal to or greater
1983  *   than @dt2.
1984  *
1985  * Since: 2.26
1986  */
1987 gint
1988 g_date_time_compare (gconstpointer dt1,
1989                      gconstpointer dt2)
1990 {
1991   gint64 difference;
1992 
1993   difference = g_date_time_difference ((GDateTime *) dt1, (GDateTime *) dt2);
1994 
1995   if (difference &lt; 0)
1996     return -1;
1997 
1998   else if (difference &gt; 0)
1999     return 1;
2000 
2001   else
2002     return 0;
2003 }
2004 
2005 /**
2006  * g_date_time_difference:
2007  * @end: a #GDateTime
2008  * @begin: a #GDateTime
2009  *
2010  * Calculates the difference in time between @end and @begin.  The
2011  * #GTimeSpan that is returned is effectively @end - @begin (ie:
2012  * positive if the first parameter is larger).
2013  *
2014  * Returns: the difference between the two #GDateTime, as a time
2015  *   span expressed in microseconds.
2016  *
2017  * Since: 2.26
2018  */
2019 GTimeSpan
2020 g_date_time_difference (GDateTime *end,
2021                         GDateTime *begin)
2022 {
2023   g_return_val_if_fail (begin != NULL, 0);
2024   g_return_val_if_fail (end != NULL, 0);
2025 
2026   return g_date_time_to_instant (end) -
2027          g_date_time_to_instant (begin);
2028 }
2029 
2030 /**
2031  * g_date_time_hash:
2032  * @datetime: (not nullable): a #GDateTime
2033  *
2034  * Hashes @datetime into a #guint, suitable for use within #GHashTable.
2035  *
2036  * Returns: a #guint containing the hash
2037  *
2038  * Since: 2.26
2039  */
2040 guint
2041 g_date_time_hash (gconstpointer datetime)
2042 {
2043   return g_date_time_to_instant ((GDateTime *) datetime);
2044 }
2045 
2046 /**
2047  * g_date_time_equal:
2048  * @dt1: (not nullable): a #GDateTime
2049  * @dt2: (not nullable): a #GDateTime
2050  *
2051  * Checks to see if @dt1 and @dt2 are equal.
2052  *
2053  * Equal here means that they represent the same moment after converting
2054  * them to the same time zone.
2055  *
2056  * Returns: %TRUE if @dt1 and @dt2 are equal
2057  *
2058  * Since: 2.26
2059  */
2060 gboolean
2061 g_date_time_equal (gconstpointer dt1,
2062                    gconstpointer dt2)
2063 {
2064   return g_date_time_difference ((GDateTime *) dt1, (GDateTime *) dt2) == 0;
2065 }
2066 
2067 /* Year, Month, Day Getters {{{1 */
2068 /**
2069  * g_date_time_get_ymd:
2070  * @datetime: a #GDateTime.
2071  * @year: (out) (optional): the return location for the gregorian year, or %NULL.
2072  * @month: (out) (optional): the return location for the month of the year, or %NULL.
2073  * @day: (out) (optional): the return location for the day of the month, or %NULL.
2074  *
2075  * Retrieves the Gregorian day, month, and year of a given #GDateTime.
2076  *
2077  * Since: 2.26
2078  **/
2079 void
2080 g_date_time_get_ymd (GDateTime *datetime,
2081                      gint      *year,
2082                      gint      *month,
2083                      gint      *day)
2084 {
2085   gint the_year;
2086   gint the_month;
2087   gint the_day;
2088   gint remaining_days;
2089   gint y100_cycles;
2090   gint y4_cycles;
2091   gint y1_cycles;
2092   gint preceding;
2093   gboolean leap;
2094 
2095   g_return_if_fail (datetime != NULL);
2096 #ifdef GSTREAMER_LITE
2097   if (datetime == NULL) {
2098     return;
2099   }
2100 #endif // GSTREAMER_LITE
2101 
2102   remaining_days = datetime-&gt;days;
2103 
2104   /*
2105    * We need to convert an offset in days to its year/month/day representation.
2106    * Leap years makes this a little trickier than it should be, so we use
2107    * 400, 100 and 4 years cycles here to get to the correct year.
2108    */
2109 
2110   /* Our days offset starts sets 0001-01-01 as day 1, if it was day 0 our
2111    * math would be simpler, so let&#39;s do it */
2112   remaining_days--;
2113 
2114   the_year = (remaining_days / DAYS_IN_400YEARS) * 400 + 1;
2115   remaining_days = remaining_days % DAYS_IN_400YEARS;
2116 
2117   y100_cycles = remaining_days / DAYS_IN_100YEARS;
2118   remaining_days = remaining_days % DAYS_IN_100YEARS;
2119   the_year += y100_cycles * 100;
2120 
2121   y4_cycles = remaining_days / DAYS_IN_4YEARS;
2122   remaining_days = remaining_days % DAYS_IN_4YEARS;
2123   the_year += y4_cycles * 4;
2124 
2125   y1_cycles = remaining_days / 365;
2126   the_year += y1_cycles;
2127   remaining_days = remaining_days % 365;
2128 
2129   if (y1_cycles == 4 || y100_cycles == 4) {
2130     g_assert (remaining_days == 0);
2131 
2132     /* special case that indicates that the date is actually one year before,
2133      * in the 31th of December */
2134     the_year--;
2135     the_month = 12;
2136     the_day = 31;
2137     goto end;
2138   }
2139 
2140   /* now get the month and the day */
2141   leap = y1_cycles == 3 &amp;&amp; (y4_cycles != 24 || y100_cycles == 3);
2142 
2143   g_assert (leap == GREGORIAN_LEAP(the_year));
2144 
2145   the_month = (remaining_days + 50) &gt;&gt; 5;
2146   preceding = (days_in_year[0][the_month - 1] + (the_month &gt; 2 &amp;&amp; leap));
2147   if (preceding &gt; remaining_days)
2148     {
2149       /* estimate is too large */
2150       the_month -= 1;
2151       preceding -= leap ? days_in_months[1][the_month]
2152                         : days_in_months[0][the_month];
2153     }
2154 
2155   remaining_days -= preceding;
2156   g_assert(0 &lt;= remaining_days);
2157 
2158   the_day = remaining_days + 1;
2159 
2160 end:
2161   if (year)
2162     *year = the_year;
2163   if (month)
2164     *month = the_month;
2165   if (day)
2166     *day = the_day;
2167 }
2168 
2169 /**
2170  * g_date_time_get_year:
2171  * @datetime: A #GDateTime
2172  *
2173  * Retrieves the year represented by @datetime in the Gregorian calendar.
2174  *
2175  * Returns: the year represented by @datetime
2176  *
2177  * Since: 2.26
2178  */
2179 gint
2180 g_date_time_get_year (GDateTime *datetime)
2181 {
2182   gint year;
2183 
2184   g_return_val_if_fail (datetime != NULL, 0);
2185 
2186   g_date_time_get_ymd (datetime, &amp;year, NULL, NULL);
2187 
2188   return year;
2189 }
2190 
2191 /**
2192  * g_date_time_get_month:
2193  * @datetime: a #GDateTime
2194  *
2195  * Retrieves the month of the year represented by @datetime in the Gregorian
2196  * calendar.
2197  *
2198  * Returns: the month represented by @datetime
2199  *
2200  * Since: 2.26
2201  */
2202 gint
2203 g_date_time_get_month (GDateTime *datetime)
2204 {
2205   gint month;
2206 
2207   g_return_val_if_fail (datetime != NULL, 0);
2208 
2209   g_date_time_get_ymd (datetime, NULL, &amp;month, NULL);
2210 
2211   return month;
2212 }
2213 
2214 /**
2215  * g_date_time_get_day_of_month:
2216  * @datetime: a #GDateTime
2217  *
2218  * Retrieves the day of the month represented by @datetime in the gregorian
2219  * calendar.
2220  *
2221  * Returns: the day of the month
2222  *
2223  * Since: 2.26
2224  */
2225 gint
2226 g_date_time_get_day_of_month (GDateTime *datetime)
2227 {
2228   gint           day_of_year,
2229                  i;
2230   const guint16 *days;
2231   guint16        last = 0;
2232 
2233   g_return_val_if_fail (datetime != NULL, 0);
2234 
2235   days = days_in_year[GREGORIAN_LEAP (g_date_time_get_year (datetime)) ? 1 : 0];
2236   g_date_time_get_week_number (datetime, NULL, NULL, &amp;day_of_year);
2237 
2238   for (i = 1; i &lt;= 12; i++)
2239     {
2240       if (days [i] &gt;= day_of_year)
2241         return day_of_year - last;
2242       last = days [i];
2243     }
2244 
2245   g_warn_if_reached ();
2246   return 0;
2247 }
2248 
2249 /* Week of year / day of week getters {{{1 */
2250 /**
2251  * g_date_time_get_week_numbering_year:
2252  * @datetime: a #GDateTime
2253  *
2254  * Returns the ISO 8601 week-numbering year in which the week containing
2255  * @datetime falls.
2256  *
2257  * This function, taken together with g_date_time_get_week_of_year() and
2258  * g_date_time_get_day_of_week() can be used to determine the full ISO
2259  * week date on which @datetime falls.
2260  *
2261  * This is usually equal to the normal Gregorian year (as returned by
2262  * g_date_time_get_year()), except as detailed below:
2263  *
2264  * For Thursday, the week-numbering year is always equal to the usual
2265  * calendar year.  For other days, the number is such that every day
2266  * within a complete week (Monday to Sunday) is contained within the
2267  * same week-numbering year.
2268  *
2269  * For Monday, Tuesday and Wednesday occurring near the end of the year,
2270  * this may mean that the week-numbering year is one greater than the
2271  * calendar year (so that these days have the same week-numbering year
2272  * as the Thursday occurring early in the next year).
2273  *
2274  * For Friday, Saturday and Sunday occurring near the start of the year,
2275  * this may mean that the week-numbering year is one less than the
2276  * calendar year (so that these days have the same week-numbering year
2277  * as the Thursday occurring late in the previous year).
2278  *
2279  * An equivalent description is that the week-numbering year is equal to
2280  * the calendar year containing the majority of the days in the current
2281  * week (Monday to Sunday).
2282  *
2283  * Note that January 1 0001 in the proleptic Gregorian calendar is a
2284  * Monday, so this function never returns 0.
2285  *
2286  * Returns: the ISO 8601 week-numbering year for @datetime
2287  *
2288  * Since: 2.26
2289  **/
2290 gint
2291 g_date_time_get_week_numbering_year (GDateTime *datetime)
2292 {
2293   gint year, month, day, weekday;
2294 
2295   g_date_time_get_ymd (datetime, &amp;year, &amp;month, &amp;day);
2296   weekday = g_date_time_get_day_of_week (datetime);
2297 
2298   /* January 1, 2, 3 might be in the previous year if they occur after
2299    * Thursday.
2300    *
2301    *   Jan 1:  Friday, Saturday, Sunday    =&gt;  day 1:  weekday 5, 6, 7
2302    *   Jan 2:  Saturday, Sunday            =&gt;  day 2:  weekday 6, 7
2303    *   Jan 3:  Sunday                      =&gt;  day 3:  weekday 7
2304    *
2305    * So we have a special case if (day - weekday) &lt;= -4
2306    */
2307   if (month == 1 &amp;&amp; (day - weekday) &lt;= -4)
2308     return year - 1;
2309 
2310   /* December 29, 30, 31 might be in the next year if they occur before
2311    * Thursday.
2312    *
2313    *   Dec 31: Monday, Tuesday, Wednesday  =&gt;  day 31: weekday 1, 2, 3
2314    *   Dec 30: Monday, Tuesday             =&gt;  day 30: weekday 1, 2
2315    *   Dec 29: Monday                      =&gt;  day 29: weekday 1
2316    *
2317    * So we have a special case if (day - weekday) &gt;= 28
2318    */
2319   else if (month == 12 &amp;&amp; (day - weekday) &gt;= 28)
2320     return year + 1;
2321 
2322   else
2323     return year;
2324 }
2325 
2326 /**
2327  * g_date_time_get_week_of_year:
2328  * @datetime: a #GDateTime
2329  *
2330  * Returns the ISO 8601 week number for the week containing @datetime.
2331  * The ISO 8601 week number is the same for every day of the week (from
2332  * Moday through Sunday).  That can produce some unusual results
2333  * (described below).
2334  *
2335  * The first week of the year is week 1.  This is the week that contains
2336  * the first Thursday of the year.  Equivalently, this is the first week
2337  * that has more than 4 of its days falling within the calendar year.
2338  *
2339  * The value 0 is never returned by this function.  Days contained
2340  * within a year but occurring before the first ISO 8601 week of that
2341  * year are considered as being contained in the last week of the
2342  * previous year.  Similarly, the final days of a calendar year may be
2343  * considered as being part of the first ISO 8601 week of the next year
2344  * if 4 or more days of that week are contained within the new year.
2345  *
2346  * Returns: the ISO 8601 week number for @datetime.
2347  *
2348  * Since: 2.26
2349  */
2350 gint
2351 g_date_time_get_week_of_year (GDateTime *datetime)
2352 {
2353   gint weeknum;
2354 
2355   g_return_val_if_fail (datetime != NULL, 0);
2356 
2357   g_date_time_get_week_number (datetime, &amp;weeknum, NULL, NULL);
2358 
2359   return weeknum;
2360 }
2361 
2362 /**
2363  * g_date_time_get_day_of_week:
2364  * @datetime: a #GDateTime
2365  *
2366  * Retrieves the ISO 8601 day of the week on which @datetime falls (1 is
2367  * Monday, 2 is Tuesday... 7 is Sunday).
2368  *
2369  * Returns: the day of the week
2370  *
2371  * Since: 2.26
2372  */
2373 gint
2374 g_date_time_get_day_of_week (GDateTime *datetime)
2375 {
2376   g_return_val_if_fail (datetime != NULL, 0);
2377 
2378   return (datetime-&gt;days - 1) % 7 + 1;
2379 }
2380 
2381 /* Day of year getter {{{1 */
2382 /**
2383  * g_date_time_get_day_of_year:
2384  * @datetime: a #GDateTime
2385  *
2386  * Retrieves the day of the year represented by @datetime in the Gregorian
2387  * calendar.
2388  *
2389  * Returns: the day of the year
2390  *
2391  * Since: 2.26
2392  */
2393 gint
2394 g_date_time_get_day_of_year (GDateTime *datetime)
2395 {
2396   gint doy = 0;
2397 
2398   g_return_val_if_fail (datetime != NULL, 0);
2399 
2400   g_date_time_get_week_number (datetime, NULL, NULL, &amp;doy);
2401   return doy;
2402 }
2403 
2404 /* Time component getters {{{1 */
2405 
2406 /**
2407  * g_date_time_get_hour:
2408  * @datetime: a #GDateTime
2409  *
2410  * Retrieves the hour of the day represented by @datetime
2411  *
2412  * Returns: the hour of the day
2413  *
2414  * Since: 2.26
2415  */
2416 gint
2417 g_date_time_get_hour (GDateTime *datetime)
2418 {
2419   g_return_val_if_fail (datetime != NULL, 0);
2420 
2421   return (datetime-&gt;usec / USEC_PER_HOUR);
2422 }
2423 
2424 /**
2425  * g_date_time_get_minute:
2426  * @datetime: a #GDateTime
2427  *
2428  * Retrieves the minute of the hour represented by @datetime
2429  *
2430  * Returns: the minute of the hour
2431  *
2432  * Since: 2.26
2433  */
2434 gint
2435 g_date_time_get_minute (GDateTime *datetime)
2436 {
2437   g_return_val_if_fail (datetime != NULL, 0);
2438 
2439   return (datetime-&gt;usec % USEC_PER_HOUR) / USEC_PER_MINUTE;
2440 }
2441 
2442 /**
2443  * g_date_time_get_second:
2444  * @datetime: a #GDateTime
2445  *
2446  * Retrieves the second of the minute represented by @datetime
2447  *
2448  * Returns: the second represented by @datetime
2449  *
2450  * Since: 2.26
2451  */
2452 gint
2453 g_date_time_get_second (GDateTime *datetime)
2454 {
2455   g_return_val_if_fail (datetime != NULL, 0);
2456 
2457   return (datetime-&gt;usec % USEC_PER_MINUTE) / USEC_PER_SECOND;
2458 }
2459 
2460 /**
2461  * g_date_time_get_microsecond:
2462  * @datetime: a #GDateTime
2463  *
2464  * Retrieves the microsecond of the date represented by @datetime
2465  *
2466  * Returns: the microsecond of the second
2467  *
2468  * Since: 2.26
2469  */
2470 gint
2471 g_date_time_get_microsecond (GDateTime *datetime)
2472 {
2473   g_return_val_if_fail (datetime != NULL, 0);
2474 
2475   return (datetime-&gt;usec % USEC_PER_SECOND);
2476 }
2477 
2478 /**
2479  * g_date_time_get_seconds:
2480  * @datetime: a #GDateTime
2481  *
2482  * Retrieves the number of seconds since the start of the last minute,
2483  * including the fractional part.
2484  *
2485  * Returns: the number of seconds
2486  *
2487  * Since: 2.26
2488  **/
2489 gdouble
2490 g_date_time_get_seconds (GDateTime *datetime)
2491 {
2492   g_return_val_if_fail (datetime != NULL, 0);
2493 
2494   return (datetime-&gt;usec % USEC_PER_MINUTE) / 1000000.0;
2495 }
2496 
2497 /* Exporters {{{1 */
2498 /**
2499  * g_date_time_to_unix:
2500  * @datetime: a #GDateTime
2501  *
2502  * Gives the Unix time corresponding to @datetime, rounding down to the
2503  * nearest second.
2504  *
2505  * Unix time is the number of seconds that have elapsed since 1970-01-01
2506  * 00:00:00 UTC, regardless of the time zone associated with @datetime.
2507  *
2508  * Returns: the Unix time corresponding to @datetime
2509  *
2510  * Since: 2.26
2511  **/
2512 gint64
2513 g_date_time_to_unix (GDateTime *datetime)
2514 {
2515   return INSTANT_TO_UNIX (g_date_time_to_instant (datetime));
2516 }
2517 
2518 /**
2519  * g_date_time_to_timeval:
2520  * @datetime: a #GDateTime
2521  * @tv: a #GTimeVal to modify
2522  *
2523  * Stores the instant in time that @datetime represents into @tv.
2524  *
2525  * The time contained in a #GTimeVal is always stored in the form of
2526  * seconds elapsed since 1970-01-01 00:00:00 UTC, regardless of the time
2527  * zone associated with @datetime.
2528  *
2529  * On systems where &#39;long&#39; is 32bit (ie: all 32bit systems and all
2530  * Windows systems), a #GTimeVal is incapable of storing the entire
2531  * range of values that #GDateTime is capable of expressing.  On those
2532  * systems, this function returns %FALSE to indicate that the time is
2533  * out of range.
2534  *
2535  * On systems where &#39;long&#39; is 64bit, this function never fails.
2536  *
2537  * Returns: %TRUE if successful, else %FALSE
2538  *
2539  * Since: 2.26
2540  **/
2541 gboolean
2542 g_date_time_to_timeval (GDateTime *datetime,
2543                         GTimeVal  *tv)
2544 {
2545   tv-&gt;tv_sec = INSTANT_TO_UNIX (g_date_time_to_instant (datetime));
2546   tv-&gt;tv_usec = datetime-&gt;usec % USEC_PER_SECOND;
2547 
2548   return TRUE;
2549 }
2550 
2551 /* Timezone queries {{{1 */
2552 /**
2553  * g_date_time_get_utc_offset:
2554  * @datetime: a #GDateTime
2555  *
2556  * Determines the offset to UTC in effect at the time and in the time
2557  * zone of @datetime.
2558  *
2559  * The offset is the number of microseconds that you add to UTC time to
2560  * arrive at local time for the time zone (ie: negative numbers for time
2561  * zones west of GMT, positive numbers for east).
2562  *
2563  * If @datetime represents UTC time, then the offset is always zero.
2564  *
2565  * Returns: the number of microseconds that should be added to UTC to
2566  *          get the local time
2567  *
2568  * Since: 2.26
2569  **/
2570 GTimeSpan
2571 g_date_time_get_utc_offset (GDateTime *datetime)
2572 {
2573   gint offset;
2574 
2575   g_return_val_if_fail (datetime != NULL, 0);
2576 
2577   offset = g_time_zone_get_offset (datetime-&gt;tz, datetime-&gt;interval);
2578 
2579   return (gint64) offset * USEC_PER_SECOND;
2580 }
2581 
2582 /**
2583  * g_date_time_get_timezone:
2584  * @datetime: a #GDateTime
2585  *
2586  * Get the time zone for this @datetime.
2587  *
2588  * Returns: (transfer none): the time zone
2589  * Since: 2.58
2590  */
2591 GTimeZone *
2592 g_date_time_get_timezone (GDateTime *datetime)
2593 {
2594   g_return_val_if_fail (datetime != NULL, NULL);
2595 
2596   g_assert (datetime-&gt;tz != NULL);
2597   return datetime-&gt;tz;
2598 }
2599 
2600 /**
2601  * g_date_time_get_timezone_abbreviation:
2602  * @datetime: a #GDateTime
2603  *
2604  * Determines the time zone abbreviation to be used at the time and in
2605  * the time zone of @datetime.
2606  *
2607  * For example, in Toronto this is currently &quot;EST&quot; during the winter
2608  * months and &quot;EDT&quot; during the summer months when daylight savings
2609  * time is in effect.
2610  *
2611  * Returns: (transfer none): the time zone abbreviation. The returned
2612  *          string is owned by the #GDateTime and it should not be
2613  *          modified or freed
2614  *
2615  * Since: 2.26
2616  **/
2617 const gchar *
2618 g_date_time_get_timezone_abbreviation (GDateTime *datetime)
2619 {
2620   g_return_val_if_fail (datetime != NULL, NULL);
2621 
2622   return g_time_zone_get_abbreviation (datetime-&gt;tz, datetime-&gt;interval);
2623 }
2624 
2625 /**
2626  * g_date_time_is_daylight_savings:
2627  * @datetime: a #GDateTime
2628  *
2629  * Determines if daylight savings time is in effect at the time and in
2630  * the time zone of @datetime.
2631  *
2632  * Returns: %TRUE if daylight savings time is in effect
2633  *
2634  * Since: 2.26
2635  **/
2636 gboolean
2637 g_date_time_is_daylight_savings (GDateTime *datetime)
2638 {
2639   g_return_val_if_fail (datetime != NULL, FALSE);
2640 
2641   return g_time_zone_is_dst (datetime-&gt;tz, datetime-&gt;interval);
2642 }
2643 
2644 /* Timezone convert {{{1 */
2645 /**
2646  * g_date_time_to_timezone:
2647  * @datetime: a #GDateTime
2648  * @tz: the new #GTimeZone
2649  *
2650  * Create a new #GDateTime corresponding to the same instant in time as
2651  * @datetime, but in the time zone @tz.
2652  *
2653  * This call can fail in the case that the time goes out of bounds.  For
2654  * example, converting 0001-01-01 00:00:00 UTC to a time zone west of
2655  * Greenwich will fail (due to the year 0 being out of range).
2656  *
2657  * You should release the return value by calling g_date_time_unref()
2658  * when you are done with it.
2659  *
2660  * Returns: a new #GDateTime, or %NULL
2661  *
2662  * Since: 2.26
2663  **/
2664 GDateTime *
2665 g_date_time_to_timezone (GDateTime *datetime,
2666                          GTimeZone *tz)
2667 {
2668   return g_date_time_from_instant (tz, g_date_time_to_instant (datetime));
2669 }
2670 
2671 /**
2672  * g_date_time_to_local:
2673  * @datetime: a #GDateTime
2674  *
2675  * Creates a new #GDateTime corresponding to the same instant in time as
2676  * @datetime, but in the local time zone.
2677  *
2678  * This call is equivalent to calling g_date_time_to_timezone() with the
2679  * time zone returned by g_time_zone_new_local().
2680  *
2681  * Returns: the newly created #GDateTime
2682  *
2683  * Since: 2.26
2684  **/
2685 GDateTime *
2686 g_date_time_to_local (GDateTime *datetime)
2687 {
2688   GDateTime *new;
2689   GTimeZone *local;
2690 
2691   local = g_time_zone_new_local ();
2692   new = g_date_time_to_timezone (datetime, local);
2693   g_time_zone_unref (local);
2694 
2695   return new;
2696 }
2697 
2698 /**
2699  * g_date_time_to_utc:
2700  * @datetime: a #GDateTime
2701  *
2702  * Creates a new #GDateTime corresponding to the same instant in time as
2703  * @datetime, but in UTC.
2704  *
2705  * This call is equivalent to calling g_date_time_to_timezone() with the
2706  * time zone returned by g_time_zone_new_utc().
2707  *
2708  * Returns: the newly created #GDateTime
2709  *
2710  * Since: 2.26
2711  **/
2712 GDateTime *
2713 g_date_time_to_utc (GDateTime *datetime)
2714 {
2715   GDateTime *new;
2716   GTimeZone *utc;
2717 
2718   utc = g_time_zone_new_utc ();
2719   new = g_date_time_to_timezone (datetime, utc);
2720   g_time_zone_unref (utc);
2721 
2722   return new;
2723 }
2724 
2725 /* Format {{{1 */
2726 
2727 static gboolean
2728 format_z (GString *outstr,
2729           gint     offset,
2730           guint    colons)
2731 {
2732   gint hours;
2733   gint minutes;
2734   gint seconds;
2735   gchar sign = offset &gt;= 0 ? &#39;+&#39; : &#39;-&#39;;
2736 
2737   offset = ABS (offset);
2738   hours = offset / 3600;
2739   minutes = offset / 60 % 60;
2740   seconds = offset % 60;
2741 
2742   switch (colons)
2743     {
2744     case 0:
2745       g_string_append_printf (outstr, &quot;%c%02d%02d&quot;,
2746                               sign,
2747                               hours,
2748                               minutes);
2749       break;
2750 
2751     case 1:
2752       g_string_append_printf (outstr, &quot;%c%02d:%02d&quot;,
2753                               sign,
2754                               hours,
2755                               minutes);
2756       break;
2757 
2758     case 2:
2759       g_string_append_printf (outstr, &quot;%c%02d:%02d:%02d&quot;,
2760                               sign,
2761                               hours,
2762                               minutes,
2763                               seconds);
2764       break;
2765 
2766     case 3:
2767       g_string_append_printf (outstr, &quot;%c%02d&quot;, sign, hours);
2768 
2769       if (minutes != 0 || seconds != 0)
2770         {
2771           g_string_append_printf (outstr, &quot;:%02d&quot;, minutes);
2772 
2773           if (seconds != 0)
2774             g_string_append_printf (outstr, &quot;:%02d&quot;, seconds);
2775         }
2776       break;
2777 
2778     default:
2779       return FALSE;
2780     }
2781 
2782   return TRUE;
2783 }
2784 
2785 #ifdef HAVE_LANGINFO_OUTDIGIT
2786 /** Initializes the array with UTF-8 encoded alternate digits suibtable for use
2787  * in current locale. Returns NULL when current locale does not use alternate
2788  * digits or there was an error converting them to UTF-8.
2789  */
2790 static const gchar * const *
2791 initialize_alt_digits (void)
2792 {
2793   guint i;
2794   gsize digit_len;
2795   gchar *digit;
2796   const gchar *locale_digit;
2797 #define N_DIGITS 10
2798 #define MAX_UTF8_ENCODING_LEN 4
2799   static gchar buffer[N_DIGITS * (MAX_UTF8_ENCODING_LEN + 1 /* null separator */)];
2800 #undef N_DIGITS
2801 #undef MAX_UTF8_ENCODING_LEN
2802   gchar *buffer_end = buffer;
2803   static const gchar *alt_digits[10];
2804 
2805   for (i = 0; i != 10; ++i)
2806     {
2807       locale_digit = nl_langinfo (_NL_CTYPE_OUTDIGIT0_MB + i);
2808 
2809       if (g_strcmp0 (locale_digit, &quot;&quot;) == 0)
2810         return NULL;
2811 
2812       digit = g_locale_to_utf8 (locale_digit, -1, NULL, &amp;digit_len, NULL);
2813       if (digit == NULL)
2814         return NULL;
2815 
2816       g_assert (digit_len &lt; buffer + sizeof (buffer) - buffer_end);
2817 
2818       alt_digits[i] = buffer_end;
2819       buffer_end = g_stpcpy (buffer_end, digit);
2820       /* skip trailing null byte */
2821       buffer_end += 1;
2822 
2823       g_free (digit);
2824     }
2825 
2826   return alt_digits;
2827 }
2828 #endif /* HAVE_LANGINFO_OUTDIGIT */
2829 
2830 static void
2831 format_number (GString     *str,
2832                gboolean     use_alt_digits,
2833                const gchar *pad,
2834                gint         width,
2835                guint32      number)
2836 {
2837   const gchar *ascii_digits[10] = {
2838     &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;
2839   };
2840   const gchar * const *digits = ascii_digits;
2841   const gchar *tmp[10];
2842   gint i = 0;
2843 
2844   g_return_if_fail (width &lt;= 10);
2845 
2846 #ifdef HAVE_LANGINFO_OUTDIGIT
2847   if (use_alt_digits)
2848     {
2849       static const gchar * const *alt_digits = NULL;
2850       static gsize initialised;
2851 
2852       if G_UNLIKELY (g_once_init_enter (&amp;initialised))
2853         {
2854           alt_digits = initialize_alt_digits ();
2855 
2856           if (alt_digits == NULL)
2857             alt_digits = ascii_digits;
2858 
2859           g_once_init_leave (&amp;initialised, TRUE);
2860         }
2861 
2862       digits = alt_digits;
2863     }
2864 #endif /* HAVE_LANGINFO_OUTDIGIT */
2865 
2866   do
2867     {
2868       tmp[i++] = digits[number % 10];
2869       number /= 10;
2870     }
2871   while (number);
2872 
2873   while (pad &amp;&amp; i &lt; width)
2874     tmp[i++] = *pad == &#39;0&#39; ? digits[0] : pad;
2875 
2876   /* should really be impossible */
2877   g_assert (i &lt;= 10);
2878 
2879   while (i)
2880     g_string_append (str, tmp[--i]);
2881 }
2882 
2883 static gboolean
2884 format_ampm (GDateTime *datetime,
2885              GString   *outstr,
2886              gboolean   locale_is_utf8,
2887              gboolean   uppercase)
2888 {
2889   const gchar *ampm;
2890   gchar       *tmp = NULL, *ampm_dup;
2891 
2892   ampm = GET_AMPM (datetime);
2893 
2894   if (!ampm || ampm[0] == &#39;\0&#39;)
2895     ampm = get_fallback_ampm (g_date_time_get_hour (datetime));
2896 
2897   if (!locale_is_utf8 &amp;&amp; GET_AMPM_IS_LOCALE)
2898     {
2899       /* This assumes that locale encoding can&#39;t have embedded NULs */
2900       ampm = tmp = g_locale_to_utf8 (ampm, -1, NULL, NULL, NULL);
2901       if (tmp == NULL)
2902         return FALSE;
2903     }
2904   if (uppercase)
2905     ampm_dup = g_utf8_strup (ampm, -1);
2906   else
2907     ampm_dup = g_utf8_strdown (ampm, -1);
2908       g_free (tmp);
2909 
2910   g_string_append (outstr, ampm_dup);
2911       g_free (ampm_dup);
2912 
2913   return TRUE;
2914 }
2915 
2916 static gboolean g_date_time_format_utf8 (GDateTime   *datetime,
2917                        const gchar *format,
2918                        GString     *outstr,
2919                        gboolean     locale_is_utf8);
2920 
2921 /* g_date_time_format() subroutine that takes a locale-encoded format
2922  * string and produces a UTF-8 encoded date/time string.
2923  */
2924 static gboolean
2925 g_date_time_format_locale (GDateTime   *datetime,
2926                const gchar *locale_format,
2927                            GString     *outstr,
2928                            gboolean     locale_is_utf8)
2929 {
2930   gchar *utf8_format;
2931   gboolean success;
2932 
2933   if (locale_is_utf8)
2934     return g_date_time_format_utf8 (datetime, locale_format, outstr, locale_is_utf8);
2935 
2936   utf8_format = g_locale_to_utf8 (locale_format, -1, NULL, NULL, NULL);
2937   if (utf8_format == NULL)
2938     return FALSE;
2939 
2940   success = g_date_time_format_utf8 (datetime, utf8_format, outstr,
2941                        locale_is_utf8);
2942   g_free (utf8_format);
2943   return success;
2944 }
2945 
2946 static inline gboolean
2947 string_append (GString     *string,
2948                const gchar *s,
2949                gboolean     s_is_utf8)
2950 {
2951   gchar *utf8;
2952   gsize  utf8_len;
2953 
2954   if (s_is_utf8)
2955     {
2956       g_string_append (string, s);
2957     }
2958   else
2959     {
2960       utf8 = g_locale_to_utf8 (s, -1, NULL, &amp;utf8_len, NULL);
2961       if (utf8 == NULL)
2962         return FALSE;
2963       g_string_append_len (string, utf8, utf8_len);
2964       g_free (utf8);
2965     }
2966 
2967   return TRUE;
2968 }
2969 
2970 /* g_date_time_format() subroutine that takes a UTF-8 encoded format
2971  * string and produces a UTF-8 encoded date/time string.
2972  */
2973 static gboolean
2974 g_date_time_format_utf8 (GDateTime   *datetime,
2975              const gchar *utf8_format,
2976              GString     *outstr,
2977              gboolean     locale_is_utf8)
2978 {
2979   guint     len;
2980   guint     colons;
2981   gunichar  c;
2982   gboolean  alt_digits = FALSE;
2983   gboolean  pad_set = FALSE;
2984   gboolean  name_is_utf8;
2985   const gchar *pad = &quot;&quot;;
2986   const gchar *name;
2987   const gchar *tz;
2988 
2989   while (*utf8_format)
2990     {
2991       len = strcspn (utf8_format, &quot;%&quot;);
2992       if (len)
2993         g_string_append_len (outstr, utf8_format, len);
2994 
2995       utf8_format += len;
2996       if (!*utf8_format)
2997     break;
2998 
2999       g_assert (*utf8_format == &#39;%&#39;);
3000       utf8_format++;
3001       if (!*utf8_format)
3002     break;
3003 
3004       colons = 0;
3005       alt_digits = FALSE;
3006       pad_set = FALSE;
3007 
3008     next_mod:
3009       c = g_utf8_get_char (utf8_format);
3010       utf8_format = g_utf8_next_char (utf8_format);
3011       switch (c)
3012     {
3013     case &#39;a&#39;:
3014       name = WEEKDAY_ABBR (datetime);
3015           if (g_strcmp0 (name, &quot;&quot;) == 0)
3016             return FALSE;
3017 
3018           name_is_utf8 = locale_is_utf8 || !WEEKDAY_ABBR_IS_LOCALE;
3019 
3020           if (!string_append (outstr, name, name_is_utf8))
3021             return FALSE;
3022 
3023       break;
3024     case &#39;A&#39;:
3025       name = WEEKDAY_FULL (datetime);
3026           if (g_strcmp0 (name, &quot;&quot;) == 0)
3027             return FALSE;
3028 
3029           name_is_utf8 = locale_is_utf8 || !WEEKDAY_FULL_IS_LOCALE;
3030 
3031           if (!string_append (outstr, name, name_is_utf8))
3032             return FALSE;
3033 
3034       break;
3035     case &#39;b&#39;:
3036       name = alt_digits ? MONTH_ABBR_STANDALONE (datetime)
3037                 : MONTH_ABBR_WITH_DAY (datetime);
3038           if (g_strcmp0 (name, &quot;&quot;) == 0)
3039             return FALSE;
3040 
3041           name_is_utf8 = locale_is_utf8 ||
3042             ((alt_digits &amp;&amp; !MONTH_ABBR_STANDALONE_IS_LOCALE) ||
3043              (!alt_digits &amp;&amp; !MONTH_ABBR_WITH_DAY_IS_LOCALE));
3044 
3045           if (!string_append (outstr, name, name_is_utf8))
3046             return FALSE;
3047 
3048       break;
3049     case &#39;B&#39;:
3050       name = alt_digits ? MONTH_FULL_STANDALONE (datetime)
3051                 : MONTH_FULL_WITH_DAY (datetime);
3052           if (g_strcmp0 (name, &quot;&quot;) == 0)
3053             return FALSE;
3054 
3055           name_is_utf8 = locale_is_utf8 ||
3056             ((alt_digits &amp;&amp; !MONTH_FULL_STANDALONE_IS_LOCALE) ||
3057              (!alt_digits &amp;&amp; !MONTH_FULL_WITH_DAY_IS_LOCALE));
3058 
3059           if (!string_append (outstr, name, name_is_utf8))
3060               return FALSE;
3061 
3062       break;
3063     case &#39;c&#39;:
3064       {
3065             if (g_strcmp0 (PREFERRED_DATE_TIME_FMT, &quot;&quot;) == 0)
3066               return FALSE;
3067             if (!g_date_time_format_locale (datetime, PREFERRED_DATE_TIME_FMT,
3068                                             outstr, locale_is_utf8))
3069               return FALSE;
3070       }
3071       break;
3072     case &#39;C&#39;:
3073       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3074              g_date_time_get_year (datetime) / 100);
3075       break;
3076     case &#39;d&#39;:
3077       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3078              g_date_time_get_day_of_month (datetime));
3079       break;
3080     case &#39;e&#39;:
3081       format_number (outstr, alt_digits, pad_set ? pad : &quot; &quot;, 2,
3082              g_date_time_get_day_of_month (datetime));
3083       break;
3084     case &#39;F&#39;:
3085       g_string_append_printf (outstr, &quot;%d-%02d-%02d&quot;,
3086                   g_date_time_get_year (datetime),
3087                   g_date_time_get_month (datetime),
3088                   g_date_time_get_day_of_month (datetime));
3089       break;
3090     case &#39;g&#39;:
3091       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3092              g_date_time_get_week_numbering_year (datetime) % 100);
3093       break;
3094     case &#39;G&#39;:
3095       format_number (outstr, alt_digits, pad_set ? pad : 0, 0,
3096              g_date_time_get_week_numbering_year (datetime));
3097       break;
3098     case &#39;h&#39;:
3099       name = alt_digits ? MONTH_ABBR_STANDALONE (datetime)
3100                 : MONTH_ABBR_WITH_DAY (datetime);
3101           if (g_strcmp0 (name, &quot;&quot;) == 0)
3102             return FALSE;
3103 
3104           name_is_utf8 = locale_is_utf8 ||
3105             ((alt_digits &amp;&amp; !MONTH_ABBR_STANDALONE_IS_LOCALE) ||
3106              (!alt_digits &amp;&amp; !MONTH_ABBR_WITH_DAY_IS_LOCALE));
3107 
3108           if (!string_append (outstr, name, name_is_utf8))
3109             return FALSE;
3110 
3111       break;
3112     case &#39;H&#39;:
3113       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3114              g_date_time_get_hour (datetime));
3115       break;
3116     case &#39;I&#39;:
3117       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3118              (g_date_time_get_hour (datetime) + 11) % 12 + 1);
3119       break;
3120     case &#39;j&#39;:
3121       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 3,
3122              g_date_time_get_day_of_year (datetime));
3123       break;
3124     case &#39;k&#39;:
3125       format_number (outstr, alt_digits, pad_set ? pad : &quot; &quot;, 2,
3126              g_date_time_get_hour (datetime));
3127       break;
3128     case &#39;l&#39;:
3129       format_number (outstr, alt_digits, pad_set ? pad : &quot; &quot;, 2,
3130              (g_date_time_get_hour (datetime) + 11) % 12 + 1);
3131       break;
3132     case &#39;n&#39;:
3133       g_string_append_c (outstr, &#39;\n&#39;);
3134       break;
3135     case &#39;m&#39;:
3136       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3137              g_date_time_get_month (datetime));
3138       break;
3139     case &#39;M&#39;:
3140       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3141              g_date_time_get_minute (datetime));
3142       break;
3143     case &#39;O&#39;:
3144       alt_digits = TRUE;
3145       goto next_mod;
3146     case &#39;p&#39;:
3147           if (!format_ampm (datetime, outstr, locale_is_utf8, TRUE))
3148             return FALSE;
3149           break;
3150     case &#39;P&#39;:
3151           if (!format_ampm (datetime, outstr, locale_is_utf8, FALSE))
3152             return FALSE;
3153       break;
3154     case &#39;r&#39;:
3155       {
3156             if (g_strcmp0 (PREFERRED_12HR_TIME_FMT, &quot;&quot;) == 0)
3157               return FALSE;
3158         if (!g_date_time_format_locale (datetime, PREFERRED_12HR_TIME_FMT,
3159                         outstr, locale_is_utf8))
3160           return FALSE;
3161       }
3162       break;
3163     case &#39;R&#39;:
3164       g_string_append_printf (outstr, &quot;%02d:%02d&quot;,
3165                   g_date_time_get_hour (datetime),
3166                   g_date_time_get_minute (datetime));
3167       break;
3168     case &#39;s&#39;:
3169       g_string_append_printf (outstr, &quot;%&quot; G_GINT64_FORMAT, g_date_time_to_unix (datetime));
3170       break;
3171     case &#39;S&#39;:
3172       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3173              g_date_time_get_second (datetime));
3174       break;
3175     case &#39;t&#39;:
3176       g_string_append_c (outstr, &#39;\t&#39;);
3177       break;
3178     case &#39;T&#39;:
3179       g_string_append_printf (outstr, &quot;%02d:%02d:%02d&quot;,
3180                   g_date_time_get_hour (datetime),
3181                   g_date_time_get_minute (datetime),
3182                   g_date_time_get_second (datetime));
3183       break;
3184     case &#39;u&#39;:
3185       format_number (outstr, alt_digits, 0, 0,
3186              g_date_time_get_day_of_week (datetime));
3187       break;
3188     case &#39;V&#39;:
3189       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3190              g_date_time_get_week_of_year (datetime));
3191       break;
3192     case &#39;w&#39;:
3193       format_number (outstr, alt_digits, 0, 0,
3194              g_date_time_get_day_of_week (datetime) % 7);
3195       break;
3196     case &#39;x&#39;:
3197       {
3198             if (g_strcmp0 (PREFERRED_DATE_FMT, &quot;&quot;) == 0)
3199               return FALSE;
3200         if (!g_date_time_format_locale (datetime, PREFERRED_DATE_FMT,
3201                         outstr, locale_is_utf8))
3202           return FALSE;
3203       }
3204       break;
3205     case &#39;X&#39;:
3206       {
3207             if (g_strcmp0 (PREFERRED_TIME_FMT, &quot;&quot;) == 0)
3208               return FALSE;
3209         if (!g_date_time_format_locale (datetime, PREFERRED_TIME_FMT,
3210                         outstr, locale_is_utf8))
3211           return FALSE;
3212       }
3213       break;
3214     case &#39;y&#39;:
3215       format_number (outstr, alt_digits, pad_set ? pad : &quot;0&quot;, 2,
3216              g_date_time_get_year (datetime) % 100);
3217       break;
3218     case &#39;Y&#39;:
3219       format_number (outstr, alt_digits, 0, 0,
3220              g_date_time_get_year (datetime));
3221       break;
3222     case &#39;z&#39;:
3223       {
3224         gint64 offset;
3225         offset = g_date_time_get_utc_offset (datetime) / USEC_PER_SECOND;
3226         if (!format_z (outstr, (int) offset, colons))
3227           return FALSE;
3228       }
3229       break;
3230     case &#39;Z&#39;:
3231       tz = g_date_time_get_timezone_abbreviation (datetime);
3232           g_string_append (outstr, tz);
3233       break;
3234     case &#39;%&#39;:
3235       g_string_append_c (outstr, &#39;%&#39;);
3236       break;
3237     case &#39;-&#39;:
3238       pad_set = TRUE;
3239       pad = &quot;&quot;;
3240       goto next_mod;
3241     case &#39;_&#39;:
3242       pad_set = TRUE;
3243       pad = &quot; &quot;;
3244       goto next_mod;
3245     case &#39;0&#39;:
3246       pad_set = TRUE;
3247       pad = &quot;0&quot;;
3248       goto next_mod;
3249     case &#39;:&#39;:
3250       /* Colons are only allowed before &#39;z&#39; */
3251       if (*utf8_format &amp;&amp; *utf8_format != &#39;z&#39; &amp;&amp; *utf8_format != &#39;:&#39;)
3252         return FALSE;
3253       colons++;
3254       goto next_mod;
3255     default:
3256       return FALSE;
3257     }
3258     }
3259 
3260   return TRUE;
3261 }
3262 
3263 /**
3264  * g_date_time_format:
3265  * @datetime: A #GDateTime
3266  * @format: a valid UTF-8 string, containing the format for the
3267  *          #GDateTime
3268  *
3269  * Creates a newly allocated string representing the requested @format.
3270  *
3271  * The format strings understood by this function are a subset of the
3272  * strftime() format language as specified by C99.  The \%D, \%U and \%W
3273  * conversions are not supported, nor is the &#39;E&#39; modifier.  The GNU
3274  * extensions \%k, \%l, \%s and \%P are supported, however, as are the
3275  * &#39;0&#39;, &#39;_&#39; and &#39;-&#39; modifiers.
3276  *
3277  * In contrast to strftime(), this function always produces a UTF-8
3278  * string, regardless of the current locale.  Note that the rendering of
3279  * many formats is locale-dependent and may not match the strftime()
3280  * output exactly.
3281  *
3282  * The following format specifiers are supported:
3283  *
3284  * - \%a: the abbreviated weekday name according to the current locale
3285  * - \%A: the full weekday name according to the current locale
3286  * - \%b: the abbreviated month name according to the current locale
3287  * - \%B: the full month name according to the current locale
3288  * - \%c: the preferred date and time representation for the current locale
3289  * - \%C: the century number (year/100) as a 2-digit integer (00-99)
3290  * - \%d: the day of the month as a decimal number (range 01 to 31)
3291  * - \%e: the day of the month as a decimal number (range  1 to 31)
3292  * - \%F: equivalent to `%Y-%m-%d` (the ISO 8601 date format)
3293  * - \%g: the last two digits of the ISO 8601 week-based year as a
3294  *   decimal number (00-99). This works well with \%V and \%u.
3295  * - \%G: the ISO 8601 week-based year as a decimal number. This works
3296  *   well with \%V and \%u.
3297  * - \%h: equivalent to \%b
3298  * - \%H: the hour as a decimal number using a 24-hour clock (range 00 to 23)
3299  * - \%I: the hour as a decimal number using a 12-hour clock (range 01 to 12)
3300  * - \%j: the day of the year as a decimal number (range 001 to 366)
3301  * - \%k: the hour (24-hour clock) as a decimal number (range 0 to 23);
3302  *   single digits are preceded by a blank
3303  * - \%l: the hour (12-hour clock) as a decimal number (range 1 to 12);
3304  *   single digits are preceded by a blank
3305  * - \%m: the month as a decimal number (range 01 to 12)
3306  * - \%M: the minute as a decimal number (range 00 to 59)
3307  * - \%p: either &quot;AM&quot; or &quot;PM&quot; according to the given time value, or the
3308  *   corresponding  strings for the current locale.  Noon is treated as
3309  *   &quot;PM&quot; and midnight as &quot;AM&quot;.
3310  * - \%P: like \%p but lowercase: &quot;am&quot; or &quot;pm&quot; or a corresponding string for
3311  *   the current locale
3312  * - \%r: the time in a.m. or p.m. notation
3313  * - \%R: the time in 24-hour notation (\%H:\%M)
3314  * - \%s: the number of seconds since the Epoch, that is, since 1970-01-01
3315  *   00:00:00 UTC
3316  * - \%S: the second as a decimal number (range 00 to 60)
3317  * - \%t: a tab character
3318  * - \%T: the time in 24-hour notation with seconds (\%H:\%M:\%S)
3319  * - \%u: the ISO 8601 standard day of the week as a decimal, range 1 to 7,
3320  *    Monday being 1. This works well with \%G and \%V.
3321  * - \%V: the ISO 8601 standard week number of the current year as a decimal
3322  *   number, range 01 to 53, where week 1 is the first week that has at
3323  *   least 4 days in the new year. See g_date_time_get_week_of_year().
3324  *   This works well with \%G and \%u.
3325  * - \%w: the day of the week as a decimal, range 0 to 6, Sunday being 0.
3326  *   This is not the ISO 8601 standard format -- use \%u instead.
3327  * - \%x: the preferred date representation for the current locale without
3328  *   the time
3329  * - \%X: the preferred time representation for the current locale without
3330  *   the date
3331  * - \%y: the year as a decimal number without the century
3332  * - \%Y: the year as a decimal number including the century
3333  * - \%z: the time zone as an offset from UTC (+hhmm)
3334  * - \%:z: the time zone as an offset from UTC (+hh:mm).
3335  *   This is a gnulib strftime() extension. Since: 2.38
3336  * - \%::z: the time zone as an offset from UTC (+hh:mm:ss). This is a
3337  *   gnulib strftime() extension. Since: 2.38
3338  * - \%:::z: the time zone as an offset from UTC, with : to necessary
3339  *   precision (e.g., -04, +05:30). This is a gnulib strftime() extension. Since: 2.38
3340  * - \%Z: the time zone or name or abbreviation
3341  * - \%\%: a literal \% character
3342  *
3343  * Some conversion specifications can be modified by preceding the
3344  * conversion specifier by one or more modifier characters. The
3345  * following modifiers are supported for many of the numeric
3346  * conversions:
3347  *
3348  * - O: Use alternative numeric symbols, if the current locale supports those.
3349  * - _: Pad a numeric result with spaces. This overrides the default padding
3350  *   for the specifier.
3351  * - -: Do not pad a numeric result. This overrides the default padding
3352  *   for the specifier.
3353  * - 0: Pad a numeric result with zeros. This overrides the default padding
3354  *   for the specifier.
3355  *
3356  * Additionally, when O is used with B, b, or h, it produces the alternative
3357  * form of a month name. The alternative form should be used when the month
3358  * name is used without a day number (e.g., standalone). It is required in
3359  * some languages (Baltic, Slavic, Greek, and more) due to their grammatical
3360  * rules. For other languages there is no difference. \%OB is a GNU and BSD
3361  * strftime() extension expected to be added to the future POSIX specification,
3362  * \%Ob and \%Oh are GNU strftime() extensions. Since: 2.56
3363  *
3364  * Returns: a newly allocated string formatted to the requested format
3365  *     or %NULL in the case that there was an error (such as a format specifier
3366  *     not being supported in the current locale). The string
3367  *     should be freed with g_free().
3368  *
3369  * Since: 2.26
3370  */
3371 gchar *
3372 g_date_time_format (GDateTime   *datetime,
3373                     const gchar *format)
3374 {
3375   GString  *outstr;
3376   const gchar *charset;
3377   /* Avoid conversions from locale charset to UTF-8 if charset is compatible
3378    * with UTF-8 already. Check for UTF-8 and synonymous canonical names of
3379    * ASCII. */
3380   gboolean locale_is_utf8_compatible = g_get_charset (&amp;charset) ||
3381     g_strcmp0 (&quot;ASCII&quot;, charset) == 0 ||
3382     g_strcmp0 (&quot;ANSI_X3.4-1968&quot;, charset) == 0;
3383 
3384   g_return_val_if_fail (datetime != NULL, NULL);
3385   g_return_val_if_fail (format != NULL, NULL);
3386   g_return_val_if_fail (g_utf8_validate (format, -1, NULL), NULL);
3387 
3388   outstr = g_string_sized_new (strlen (format) * 2);
3389 
3390   if (!g_date_time_format_utf8 (datetime, format, outstr,
3391                                 locale_is_utf8_compatible))
3392     {
3393       g_string_free (outstr, TRUE);
3394       return NULL;
3395     }
3396 
3397     return g_string_free (outstr, FALSE);
3398 }
3399 
3400 
3401 /* Epilogue {{{1 */
3402 /* vim:set foldmethod=marker: */
    </pre>
  </body>
</html>