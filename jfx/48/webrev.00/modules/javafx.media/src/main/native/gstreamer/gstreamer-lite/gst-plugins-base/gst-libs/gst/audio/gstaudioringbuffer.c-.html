<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudioringbuffer.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 2005 Wim Taymans &lt;wim@fluendo.com&gt;
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Library General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Library General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Library General Public
  15  * License along with this library; if not, write to the
  16  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  17  * Boston, MA 02110-1301, USA.
  18  */
  19 
  20 /**
  21  * SECTION:gstaudioringbuffer
  22  * @title: GstAudioRingBuffer
  23  * @short_description: Base class for audio ringbuffer implementations
  24  * @see_also: #GstAudioBaseSink, #GstAudioSink
  25  *
  26  * This object is the base class for audio ringbuffers used by the base
  27  * audio source and sink classes.
  28  *
  29  * The ringbuffer abstracts a circular buffer of data. One reader and
  30  * one writer can operate on the data from different threads in a lockfree
  31  * manner. The base class is sufficiently flexible to be used as an
  32  * abstraction for DMA based ringbuffers as well as a pure software
  33  * implementations.
  34  *
  35  */
  36 
  37 #include &lt;string.h&gt;
  38 
  39 #include &lt;gst/audio/audio.h&gt;
  40 #include &quot;gstaudioringbuffer.h&quot;
  41 
  42 GST_DEBUG_CATEGORY_STATIC (gst_audio_ring_buffer_debug);
  43 #define GST_CAT_DEFAULT gst_audio_ring_buffer_debug
  44 
  45 static void gst_audio_ring_buffer_dispose (GObject * object);
  46 static void gst_audio_ring_buffer_finalize (GObject * object);
  47 
  48 static gboolean gst_audio_ring_buffer_pause_unlocked (GstAudioRingBuffer * buf);
  49 static void default_clear_all (GstAudioRingBuffer * buf);
  50 static guint default_commit (GstAudioRingBuffer * buf, guint64 * sample,
  51     guint8 * data, gint in_samples, gint out_samples, gint * accum);
  52 
  53 /* ringbuffer abstract base class */
  54 G_DEFINE_ABSTRACT_TYPE (GstAudioRingBuffer, gst_audio_ring_buffer,
  55     GST_TYPE_OBJECT);
  56 
  57 static void
  58 gst_audio_ring_buffer_class_init (GstAudioRingBufferClass * klass)
  59 {
  60   GObjectClass *gobject_class;
  61   GstAudioRingBufferClass *gstaudioringbuffer_class;
  62 
  63   gobject_class = (GObjectClass *) klass;
  64   gstaudioringbuffer_class = (GstAudioRingBufferClass *) klass;
  65 
  66   GST_DEBUG_CATEGORY_INIT (gst_audio_ring_buffer_debug, &quot;ringbuffer&quot;, 0,
  67       &quot;ringbuffer class&quot;);
  68 
  69   gobject_class-&gt;dispose = gst_audio_ring_buffer_dispose;
  70   gobject_class-&gt;finalize = gst_audio_ring_buffer_finalize;
  71 
  72   gstaudioringbuffer_class-&gt;clear_all = GST_DEBUG_FUNCPTR (default_clear_all);
  73   gstaudioringbuffer_class-&gt;commit = GST_DEBUG_FUNCPTR (default_commit);
  74 }
  75 
  76 static void
  77 gst_audio_ring_buffer_init (GstAudioRingBuffer * ringbuffer)
  78 {
  79   ringbuffer-&gt;open = FALSE;
  80   ringbuffer-&gt;acquired = FALSE;
  81   ringbuffer-&gt;state = GST_AUDIO_RING_BUFFER_STATE_STOPPED;
  82   g_cond_init (&amp;ringbuffer-&gt;cond);
  83   ringbuffer-&gt;waiting = 0;
  84   ringbuffer-&gt;empty_seg = NULL;
  85   ringbuffer-&gt;flushing = TRUE;
  86   ringbuffer-&gt;segbase = 0;
  87   ringbuffer-&gt;segdone = 0;
  88 }
  89 
  90 static void
  91 gst_audio_ring_buffer_dispose (GObject * object)
  92 {
  93   GstAudioRingBuffer *ringbuffer = GST_AUDIO_RING_BUFFER (object);
  94 
  95   gst_caps_replace (&amp;ringbuffer-&gt;spec.caps, NULL);
  96 
  97   G_OBJECT_CLASS (gst_audio_ring_buffer_parent_class)-&gt;dispose (G_OBJECT
  98       (ringbuffer));
  99 }
 100 
 101 static void
 102 gst_audio_ring_buffer_finalize (GObject * object)
 103 {
 104   GstAudioRingBuffer *ringbuffer = GST_AUDIO_RING_BUFFER (object);
 105 
 106   g_cond_clear (&amp;ringbuffer-&gt;cond);
 107   g_free (ringbuffer-&gt;empty_seg);
 108 
 109   if (ringbuffer-&gt;cb_data_notify != NULL)
 110     ringbuffer-&gt;cb_data_notify (ringbuffer-&gt;cb_data);
 111 
 112   G_OBJECT_CLASS (gst_audio_ring_buffer_parent_class)-&gt;finalize (G_OBJECT
 113       (ringbuffer));
 114 }
 115 
 116 #ifndef GST_DISABLE_GST_DEBUG
 117 static const gchar *format_type_names[] = {
 118   &quot;raw&quot;,
 119   &quot;mu law&quot;,
 120   &quot;a law&quot;,
 121   &quot;ima adpcm&quot;,
 122   &quot;mpeg&quot;,
 123   &quot;gsm&quot;,
 124   &quot;iec958&quot;,
 125   &quot;ac3&quot;,
 126   &quot;eac3&quot;,
 127   &quot;dts&quot;,
 128   &quot;aac mpeg2&quot;,
 129   &quot;aac mpeg4&quot;,
 130   &quot;aac mpeg2 raw&quot;,
 131   &quot;aac mpeg4 raw&quot;,
 132   &quot;flac&quot;
 133 };
 134 #endif
 135 
 136 /**
 137  * gst_audio_ring_buffer_debug_spec_caps:
 138  * @spec: the spec to debug
 139  *
 140  * Print debug info about the parsed caps in @spec to the debug log.
 141  */
 142 void
 143 gst_audio_ring_buffer_debug_spec_caps (GstAudioRingBufferSpec * spec)
 144 {
 145 #if 0
 146   gint i, bytes;
 147 #endif
 148 
 149   GST_DEBUG (&quot;spec caps: %p %&quot; GST_PTR_FORMAT, spec-&gt;caps, spec-&gt;caps);
 150   GST_DEBUG (&quot;parsed caps: type:         %d, &#39;%s&#39;&quot;, spec-&gt;type,
 151       format_type_names[spec-&gt;type]);
 152 #if 0
 153   GST_DEBUG (&quot;parsed caps: width:        %d&quot;, spec-&gt;width);
 154   GST_DEBUG (&quot;parsed caps: sign:         %d&quot;, spec-&gt;sign);
 155   GST_DEBUG (&quot;parsed caps: bigend:       %d&quot;, spec-&gt;bigend);
 156   GST_DEBUG (&quot;parsed caps: rate:         %d&quot;, spec-&gt;rate);
 157   GST_DEBUG (&quot;parsed caps: channels:     %d&quot;, spec-&gt;channels);
 158   GST_DEBUG (&quot;parsed caps: sample bytes: %d&quot;, spec-&gt;bytes_per_sample);
 159   bytes = (spec-&gt;width &gt;&gt; 3) * spec-&gt;channels;
 160   for (i = 0; i &lt; bytes; i++) {
 161     GST_DEBUG (&quot;silence byte %d: %02x&quot;, i, spec-&gt;silence_sample[i]);
 162   }
 163 #endif
 164 }
 165 
 166 /**
 167  * gst_audio_ring_buffer_debug_spec_buff:
 168  * @spec: the spec to debug
 169  *
 170  * Print debug info about the buffer sized in @spec to the debug log.
 171  */
 172 void
 173 gst_audio_ring_buffer_debug_spec_buff (GstAudioRingBufferSpec * spec)
 174 {
 175   gint bpf = GST_AUDIO_INFO_BPF (&amp;spec-&gt;info);
 176 
 177   GST_DEBUG (&quot;acquire ringbuffer: buffer time: %&quot; G_GINT64_FORMAT &quot; usec&quot;,
 178       spec-&gt;buffer_time);
 179   GST_DEBUG (&quot;acquire ringbuffer: latency time: %&quot; G_GINT64_FORMAT &quot; usec&quot;,
 180       spec-&gt;latency_time);
 181   GST_DEBUG (&quot;acquire ringbuffer: total segments: %d&quot;, spec-&gt;segtotal);
 182   GST_DEBUG (&quot;acquire ringbuffer: latency segments: %d&quot;, spec-&gt;seglatency);
 183   GST_DEBUG (&quot;acquire ringbuffer: segment size: %d bytes = %d samples&quot;,
 184       spec-&gt;segsize, (bpf != 0) ? (spec-&gt;segsize / bpf) : -1);
 185   GST_DEBUG (&quot;acquire ringbuffer: buffer size: %d bytes = %d samples&quot;,
 186       spec-&gt;segsize * spec-&gt;segtotal,
 187       (bpf != 0) ? (spec-&gt;segsize * spec-&gt;segtotal / bpf) : -1);
 188 }
 189 
 190 /**
 191  * gst_audio_ring_buffer_parse_caps:
 192  * @spec: a spec
 193  * @caps: a #GstCaps
 194  *
 195  * Parse @caps into @spec.
 196  *
 197  * Returns: TRUE if the caps could be parsed.
 198  */
 199 gboolean
 200 gst_audio_ring_buffer_parse_caps (GstAudioRingBufferSpec * spec, GstCaps * caps)
 201 {
 202   const gchar *mimetype;
 203   GstStructure *structure;
 204   gint i;
 205   GstAudioInfo info;
 206 
 207   structure = gst_caps_get_structure (caps, 0);
 208   gst_audio_info_init (&amp;info);
 209 
 210   /* we have to differentiate between int and float formats */
 211   mimetype = gst_structure_get_name (structure);
 212 
 213   if (g_str_equal (mimetype, &quot;audio/x-raw&quot;)) {
 214     if (!gst_audio_info_from_caps (&amp;info, caps))
 215       goto parse_error;
 216 
 217     spec-&gt;type = GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW;
 218   } else if (g_str_equal (mimetype, &quot;audio/x-alaw&quot;)) {
 219     /* extract the needed information from the cap */
 220     if (!(gst_structure_get_int (structure, &quot;rate&quot;, &amp;info.rate) &amp;&amp;
 221             gst_structure_get_int (structure, &quot;channels&quot;, &amp;info.channels)))
 222       goto parse_error;
 223 
 224     if (!(gst_audio_channel_positions_from_mask (info.channels, 0,
 225                 info.position)))
 226       goto parse_error;
 227 
 228     spec-&gt;type = GST_AUDIO_RING_BUFFER_FORMAT_TYPE_A_LAW;
 229     info.bpf = info.channels;
 230   } else if (g_str_equal (mimetype, &quot;audio/x-mulaw&quot;)) {
 231     /* extract the needed information from the cap */
 232     if (!(gst_structure_get_int (structure, &quot;rate&quot;, &amp;info.rate) &amp;&amp;
 233             gst_structure_get_int (structure, &quot;channels&quot;, &amp;info.channels)))
 234       goto parse_error;
 235 
 236     if (!(gst_audio_channel_positions_from_mask (info.channels, 0,
 237                 info.position)))
 238       goto parse_error;
 239 
 240     spec-&gt;type = GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MU_LAW;
 241     info.bpf = info.channels;
 242   } else if (g_str_equal (mimetype, &quot;audio/x-iec958&quot;)) {
 243     /* extract the needed information from the cap */
 244     if (!(gst_structure_get_int (structure, &quot;rate&quot;, &amp;info.rate)))
 245       goto parse_error;
 246 
 247     spec-&gt;type = GST_AUDIO_RING_BUFFER_FORMAT_TYPE_IEC958;
 248     info.bpf = 4;
 249   } else if (g_str_equal (mimetype, &quot;audio/x-ac3&quot;)) {
 250     /* extract the needed information from the cap */
 251     if (!(gst_structure_get_int (structure, &quot;rate&quot;, &amp;info.rate)))
 252       goto parse_error;
 253 
 254     gst_structure_get_int (structure, &quot;channels&quot;, &amp;info.channels);
 255     spec-&gt;type = GST_AUDIO_RING_BUFFER_FORMAT_TYPE_AC3;
 256     info.bpf = 4;
 257   } else if (g_str_equal (mimetype, &quot;audio/x-eac3&quot;)) {
 258     /* extract the needed information from the cap */
 259     if (!(gst_structure_get_int (structure, &quot;rate&quot;, &amp;info.rate)))
 260       goto parse_error;
 261 
 262     gst_structure_get_int (structure, &quot;channels&quot;, &amp;info.channels);
 263     spec-&gt;type = GST_AUDIO_RING_BUFFER_FORMAT_TYPE_EAC3;
 264     info.bpf = 16;
 265   } else if (g_str_equal (mimetype, &quot;audio/x-dts&quot;)) {
 266     /* extract the needed information from the cap */
 267     if (!(gst_structure_get_int (structure, &quot;rate&quot;, &amp;info.rate)))
 268       goto parse_error;
 269 
 270     gst_structure_get_int (structure, &quot;channels&quot;, &amp;info.channels);
 271     spec-&gt;type = GST_AUDIO_RING_BUFFER_FORMAT_TYPE_DTS;
 272     info.bpf = 4;
 273   } else if (g_str_equal (mimetype, &quot;audio/mpeg&quot;) &amp;&amp;
 274       gst_structure_get_int (structure, &quot;mpegaudioversion&quot;, &amp;i) &amp;&amp;
 275       (i == 1 || i == 2 || i == 3)) {
 276     /* Now we know this is MPEG-1, MPEG-2 or MPEG-2.5 (non AAC) */
 277     /* extract the needed information from the cap */
 278     if (!(gst_structure_get_int (structure, &quot;rate&quot;, &amp;info.rate)))
 279       goto parse_error;
 280 
 281     gst_structure_get_int (structure, &quot;channels&quot;, &amp;info.channels);
 282     spec-&gt;type = GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG;
 283     info.bpf = 1;
 284   } else if (g_str_equal (mimetype, &quot;audio/mpeg&quot;) &amp;&amp;
 285       gst_structure_get_int (structure, &quot;mpegversion&quot;, &amp;i) &amp;&amp;
 286       (i == 2 || i == 4) &amp;&amp;
 287       (!g_strcmp0 (gst_structure_get_string (structure, &quot;stream-format&quot;),
 288               &quot;adts&quot;)
 289           || !g_strcmp0 (gst_structure_get_string (structure, &quot;stream-format&quot;),
 290               &quot;raw&quot;))) {
 291     /* MPEG-2 AAC or MPEG-4 AAC */
 292     if (!(gst_structure_get_int (structure, &quot;rate&quot;, &amp;info.rate)))
 293       goto parse_error;
 294 
 295     gst_structure_get_int (structure, &quot;channels&quot;, &amp;info.channels);
 296     if (!g_strcmp0 (gst_structure_get_string (structure, &quot;stream-format&quot;),
 297             &quot;adts&quot;))
 298     spec-&gt;type = (i == 2) ? GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC :
 299         GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC;
 300     else
 301       spec-&gt;type = (i == 2) ?
 302           GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG2_AAC_RAW :
 303           GST_AUDIO_RING_BUFFER_FORMAT_TYPE_MPEG4_AAC_RAW;
 304     info.bpf = 1;
 305   } else if (g_str_equal (mimetype, &quot;audio/x-flac&quot;)) {
 306     /* extract the needed information from the cap */
 307     if (!(gst_structure_get_int (structure, &quot;rate&quot;, &amp;info.rate)))
 308       goto parse_error;
 309 
 310     gst_structure_get_int (structure, &quot;channels&quot;, &amp;info.channels);
 311     spec-&gt;type = GST_AUDIO_RING_BUFFER_FORMAT_TYPE_FLAC;
 312     info.bpf = 1;
 313   } else {
 314     goto parse_error;
 315   }
 316 
 317   gst_caps_replace (&amp;spec-&gt;caps, caps);
 318 
 319   g_return_val_if_fail (spec-&gt;latency_time != 0, FALSE);
 320 
 321   /* calculate suggested segsize and segtotal. segsize should be one unit
 322    * of &#39;latency_time&#39; samples, scaling for the fact that latency_time is
 323    * currently stored in microseconds (FIXME: in 0.11) */
 324   spec-&gt;segsize = gst_util_uint64_scale (info.rate * info.bpf,
 325       spec-&gt;latency_time, GST_SECOND / GST_USECOND);
 326   /* Round to an integer number of samples */
 327   spec-&gt;segsize -= spec-&gt;segsize % info.bpf;
 328 
 329   spec-&gt;segtotal = spec-&gt;buffer_time / spec-&gt;latency_time;
 330   /* leave the latency undefined now, implementations can change it but if it&#39;s
 331    * not changed, we assume the same value as segtotal */
 332   spec-&gt;seglatency = -1;
 333 
 334   spec-&gt;info = info;
 335 
 336   gst_audio_ring_buffer_debug_spec_caps (spec);
 337   gst_audio_ring_buffer_debug_spec_buff (spec);
 338 
 339   return TRUE;
 340 
 341   /* ERRORS */
 342 parse_error:
 343   {
 344     GST_DEBUG (&quot;could not parse caps&quot;);
 345     return FALSE;
 346   }
 347 }
 348 
 349 /**
 350  * gst_audio_ring_buffer_convert:
 351  * @buf: the #GstAudioRingBuffer
 352  * @src_fmt: the source format
 353  * @src_val: the source value
 354  * @dest_fmt: the destination format
 355  * @dest_val: (out): a location to store the converted value
 356  *
 357  * Convert @src_val in @src_fmt to the equivalent value in @dest_fmt. The result
 358  * will be put in @dest_val.
 359  *
 360  * Returns: TRUE if the conversion succeeded.
 361  */
 362 gboolean
 363 gst_audio_ring_buffer_convert (GstAudioRingBuffer * buf,
 364     GstFormat src_fmt, gint64 src_val, GstFormat dest_fmt, gint64 * dest_val)
 365 {
 366   gboolean res;
 367 
 368   GST_OBJECT_LOCK (buf);
 369   res =
 370       gst_audio_info_convert (&amp;buf-&gt;spec.info, src_fmt, src_val, dest_fmt,
 371       dest_val);
 372   GST_OBJECT_UNLOCK (buf);
 373 
 374   return res;
 375 }
 376 
 377 /**
 378  * gst_audio_ring_buffer_set_callback: (skip)
 379  * @buf: the #GstAudioRingBuffer to set the callback on
 380  * @cb: (allow-none): the callback to set
 381  * @user_data: user data passed to the callback
 382  *
 383  * Sets the given callback function on the buffer. This function
 384  * will be called every time a segment has been written to a device.
 385  *
 386  * MT safe.
 387  */
 388 void
 389 gst_audio_ring_buffer_set_callback (GstAudioRingBuffer * buf,
 390     GstAudioRingBufferCallback cb, gpointer user_data)
 391 {
 392   gst_audio_ring_buffer_set_callback_full (buf, cb, user_data, NULL);
 393 }
 394 
 395 /**
 396  * gst_audio_ring_buffer_set_callback_full: (rename-to gst_audio_ring_buffer_set_callback)
 397  * @buf: the #GstAudioRingBuffer to set the callback on
 398  * @cb: (allow-none): the callback to set
 399  * @user_data: user data passed to the callback
 400  * @notify: function to be called when @user_data is no longer needed
 401  *
 402  * Sets the given callback function on the buffer. This function
 403  * will be called every time a segment has been written to a device.
 404  *
 405  * MT safe.
 406  *
 407  * Since: 1.12
 408  */
 409 void
 410 gst_audio_ring_buffer_set_callback_full (GstAudioRingBuffer * buf,
 411     GstAudioRingBufferCallback cb, gpointer user_data, GDestroyNotify notify)
 412 {
 413   gpointer old_data = NULL;
 414   GDestroyNotify old_notify;
 415 
 416   g_return_if_fail (GST_IS_AUDIO_RING_BUFFER (buf));
 417 
 418   GST_OBJECT_LOCK (buf);
 419   old_notify = buf-&gt;cb_data_notify;
 420   old_data = buf-&gt;cb_data;
 421 
 422   buf-&gt;callback = cb;
 423   buf-&gt;cb_data = user_data;
 424   buf-&gt;cb_data_notify = notify;
 425   GST_OBJECT_UNLOCK (buf);
 426 
 427   if (old_notify) {
 428     old_notify (old_data);
 429 }
 430 }
 431 
 432 
 433 /**
 434  * gst_audio_ring_buffer_open_device:
 435  * @buf: the #GstAudioRingBuffer
 436  *
 437  * Open the audio device associated with the ring buffer. Does not perform any
 438  * setup on the device. You must open the device before acquiring the ring
 439  * buffer.
 440  *
 441  * Returns: TRUE if the device could be opened, FALSE on error.
 442  *
 443  * MT safe.
 444  */
 445 gboolean
 446 gst_audio_ring_buffer_open_device (GstAudioRingBuffer * buf)
 447 {
 448   gboolean res = TRUE;
 449   GstAudioRingBufferClass *rclass;
 450 
 451   g_return_val_if_fail (GST_IS_AUDIO_RING_BUFFER (buf), FALSE);
 452 
 453   GST_DEBUG_OBJECT (buf, &quot;opening device&quot;);
 454 
 455   GST_OBJECT_LOCK (buf);
 456   if (G_UNLIKELY (buf-&gt;open))
 457     goto was_opened;
 458 
 459   buf-&gt;open = TRUE;
 460 
 461   /* if this fails, something is wrong in this file */
 462   g_assert (!buf-&gt;acquired);
 463 
 464   rclass = GST_AUDIO_RING_BUFFER_GET_CLASS (buf);
 465   if (G_LIKELY (rclass-&gt;open_device))
 466     res = rclass-&gt;open_device (buf);
 467 
 468   if (G_UNLIKELY (!res))
 469     goto open_failed;
 470 
 471   GST_DEBUG_OBJECT (buf, &quot;opened device&quot;);
 472 
 473 done:
 474   GST_OBJECT_UNLOCK (buf);
 475 
 476   return res;
 477 
 478   /* ERRORS */
 479 was_opened:
 480   {
 481     GST_DEBUG_OBJECT (buf, &quot;Device for ring buffer already open&quot;);
 482     g_warning (&quot;Device for ring buffer %p already open, fix your code&quot;, buf);
 483     res = TRUE;
 484     goto done;
 485   }
 486 open_failed:
 487   {
 488     buf-&gt;open = FALSE;
 489     GST_DEBUG_OBJECT (buf, &quot;failed opening device&quot;);
 490     goto done;
 491   }
 492 }
 493 
 494 /**
 495  * gst_audio_ring_buffer_close_device:
 496  * @buf: the #GstAudioRingBuffer
 497  *
 498  * Close the audio device associated with the ring buffer. The ring buffer
 499  * should already have been released via gst_audio_ring_buffer_release().
 500  *
 501  * Returns: TRUE if the device could be closed, FALSE on error.
 502  *
 503  * MT safe.
 504  */
 505 gboolean
 506 gst_audio_ring_buffer_close_device (GstAudioRingBuffer * buf)
 507 {
 508   gboolean res = TRUE;
 509   GstAudioRingBufferClass *rclass;
 510 
 511   g_return_val_if_fail (GST_IS_AUDIO_RING_BUFFER (buf), FALSE);
 512 
 513   GST_DEBUG_OBJECT (buf, &quot;closing device&quot;);
 514 
 515   GST_OBJECT_LOCK (buf);
 516   if (G_UNLIKELY (!buf-&gt;open))
 517     goto was_closed;
 518 
 519   if (G_UNLIKELY (buf-&gt;acquired))
 520     goto was_acquired;
 521 
 522   buf-&gt;open = FALSE;
 523 
 524   rclass = GST_AUDIO_RING_BUFFER_GET_CLASS (buf);
 525   if (G_LIKELY (rclass-&gt;close_device))
 526     res = rclass-&gt;close_device (buf);
 527 
 528   if (G_UNLIKELY (!res))
 529     goto close_error;
 530 
 531   GST_DEBUG_OBJECT (buf, &quot;closed device&quot;);
 532 
 533 done:
 534   GST_OBJECT_UNLOCK (buf);
 535 
 536   return res;
 537 
 538   /* ERRORS */
 539 was_closed:
 540   {
 541     GST_DEBUG_OBJECT (buf, &quot;Device for ring buffer already closed&quot;);
 542     g_warning (&quot;Device for ring buffer %p already closed, fix your code&quot;, buf);
 543     res = TRUE;
 544     goto done;
 545   }
 546 was_acquired:
 547   {
 548     GST_DEBUG_OBJECT (buf, &quot;Resources for ring buffer still acquired&quot;);
 549     g_critical (&quot;Resources for ring buffer %p still acquired&quot;, buf);
 550     res = FALSE;
 551     goto done;
 552   }
 553 close_error:
 554   {
 555     buf-&gt;open = TRUE;
 556     GST_DEBUG_OBJECT (buf, &quot;error closing device&quot;);
 557     goto done;
 558   }
 559 }
 560 
 561 /**
 562  * gst_audio_ring_buffer_device_is_open:
 563  * @buf: the #GstAudioRingBuffer
 564  *
 565  * Checks the status of the device associated with the ring buffer.
 566  *
 567  * Returns: TRUE if the device was open, FALSE if it was closed.
 568  *
 569  * MT safe.
 570  */
 571 gboolean
 572 gst_audio_ring_buffer_device_is_open (GstAudioRingBuffer * buf)
 573 {
 574   gboolean res = TRUE;
 575 
 576   g_return_val_if_fail (GST_IS_AUDIO_RING_BUFFER (buf), FALSE);
 577 
 578   GST_OBJECT_LOCK (buf);
 579   res = buf-&gt;open;
 580   GST_OBJECT_UNLOCK (buf);
 581 
 582   return res;
 583 }
 584 
 585 /**
 586  * gst_audio_ring_buffer_acquire:
 587  * @buf: the #GstAudioRingBuffer to acquire
 588  * @spec: the specs of the buffer
 589  *
 590  * Allocate the resources for the ringbuffer. This function fills
 591  * in the data pointer of the ring buffer with a valid #GstBuffer
 592  * to which samples can be written.
 593  *
 594  * Returns: TRUE if the device could be acquired, FALSE on error.
 595  *
 596  * MT safe.
 597  */
 598 gboolean
 599 gst_audio_ring_buffer_acquire (GstAudioRingBuffer * buf,
 600     GstAudioRingBufferSpec * spec)
 601 {
 602   gboolean res = FALSE;
 603   GstAudioRingBufferClass *rclass;
 604   gint segsize, bpf, i;
 605 
 606   g_return_val_if_fail (GST_IS_AUDIO_RING_BUFFER (buf), FALSE);
 607 
 608   GST_DEBUG_OBJECT (buf, &quot;acquiring device %p&quot;, buf);
 609 
 610   GST_OBJECT_LOCK (buf);
 611   if (G_UNLIKELY (!buf-&gt;open))
 612     goto not_opened;
 613 
 614   if (G_UNLIKELY (buf-&gt;acquired))
 615     goto was_acquired;
 616 
 617   buf-&gt;acquired = TRUE;
 618   buf-&gt;need_reorder = FALSE;
 619 
 620   rclass = GST_AUDIO_RING_BUFFER_GET_CLASS (buf);
 621   if (G_LIKELY (rclass-&gt;acquire))
 622     res = rclass-&gt;acquire (buf, spec);
 623 
 624   /* Only reorder for raw audio */
 625   buf-&gt;need_reorder = (buf-&gt;need_reorder
 626       &amp;&amp; buf-&gt;spec.type == GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW);
 627 
 628   if (G_UNLIKELY (!res))
 629     goto acquire_failed;
 630 
 631   GST_INFO_OBJECT (buf, &quot;Allocating an array for %d timestamps&quot;,
 632       spec-&gt;segtotal);
 633   buf-&gt;timestamps = g_slice_alloc0 (sizeof (GstClockTime) * spec-&gt;segtotal);
 634   /* initialize array with invalid timestamps */
 635   for (i = 0; i &lt; spec-&gt;segtotal; i++) {
 636     buf-&gt;timestamps[i] = GST_CLOCK_TIME_NONE;
 637   }
 638 
 639   if (G_UNLIKELY ((bpf = buf-&gt;spec.info.bpf) == 0))
 640     goto invalid_bpf;
 641 
 642   /* if the seglatency was overwritten with something else than -1, use it, else
 643    * assume segtotal as the latency */
 644   if (buf-&gt;spec.seglatency == -1)
 645     buf-&gt;spec.seglatency = buf-&gt;spec.segtotal;
 646 
 647   segsize = buf-&gt;spec.segsize;
 648 
 649   buf-&gt;samples_per_seg = segsize / bpf;
 650 
 651   /* create an empty segment */
 652   g_free (buf-&gt;empty_seg);
 653   buf-&gt;empty_seg = g_malloc (segsize);
 654 
 655   if (buf-&gt;spec.type == GST_AUDIO_RING_BUFFER_FORMAT_TYPE_RAW) {
 656     gst_audio_format_fill_silence (buf-&gt;spec.info.finfo, buf-&gt;empty_seg,
 657         segsize);
 658   } else {
 659     /* FIXME, non-raw formats get 0 as the empty sample */
 660     memset (buf-&gt;empty_seg, 0, segsize);
 661   }
 662   GST_DEBUG_OBJECT (buf, &quot;acquired device&quot;);
 663 
 664 done:
 665   GST_OBJECT_UNLOCK (buf);
 666 
 667   return res;
 668 
 669   /* ERRORS */
 670 not_opened:
 671   {
 672     GST_DEBUG_OBJECT (buf, &quot;device not opened&quot;);
 673     g_critical (&quot;Device for %p not opened&quot;, buf);
 674     res = FALSE;
 675     goto done;
 676   }
 677 was_acquired:
 678   {
 679     res = TRUE;
 680     GST_DEBUG_OBJECT (buf, &quot;device was acquired&quot;);
 681     goto done;
 682   }
 683 acquire_failed:
 684   {
 685     buf-&gt;acquired = FALSE;
 686     GST_DEBUG_OBJECT (buf, &quot;failed to acquire device&quot;);
 687     goto done;
 688   }
 689 invalid_bpf:
 690   {
 691     g_warning
 692         (&quot;invalid bytes_per_frame from acquire ringbuffer %p, fix the element&quot;,
 693         buf);
 694     buf-&gt;acquired = FALSE;
 695     res = FALSE;
 696     goto done;
 697   }
 698 }
 699 
 700 /**
 701  * gst_audio_ring_buffer_release:
 702  * @buf: the #GstAudioRingBuffer to release
 703  *
 704  * Free the resources of the ringbuffer.
 705  *
 706  * Returns: TRUE if the device could be released, FALSE on error.
 707  *
 708  * MT safe.
 709  */
 710 gboolean
 711 gst_audio_ring_buffer_release (GstAudioRingBuffer * buf)
 712 {
 713   gboolean res = FALSE;
 714   GstAudioRingBufferClass *rclass;
 715 
 716   g_return_val_if_fail (GST_IS_AUDIO_RING_BUFFER (buf), FALSE);
 717 
 718   GST_DEBUG_OBJECT (buf, &quot;releasing device&quot;);
 719 
 720   gst_audio_ring_buffer_stop (buf);
 721 
 722   GST_OBJECT_LOCK (buf);
 723 
 724   if (G_LIKELY (buf-&gt;timestamps)) {
 725     GST_INFO_OBJECT (buf, &quot;Freeing timestamp buffer, %d entries&quot;,
 726         buf-&gt;spec.segtotal);
 727     g_slice_free1 (sizeof (GstClockTime) * buf-&gt;spec.segtotal, buf-&gt;timestamps);
 728     buf-&gt;timestamps = NULL;
 729   }
 730 
 731   if (G_UNLIKELY (!buf-&gt;acquired))
 732     goto was_released;
 733 
 734   buf-&gt;acquired = FALSE;
 735 
 736   /* if this fails, something is wrong in this file */
 737   g_assert (buf-&gt;open);
 738 
 739   rclass = GST_AUDIO_RING_BUFFER_GET_CLASS (buf);
 740   if (G_LIKELY (rclass-&gt;release))
 741     res = rclass-&gt;release (buf);
 742 
 743   /* signal any waiters */
 744   GST_DEBUG_OBJECT (buf, &quot;signal waiter&quot;);
 745   GST_AUDIO_RING_BUFFER_SIGNAL (buf);
 746 
 747   if (G_UNLIKELY (!res))
 748     goto release_failed;
 749 
 750   g_atomic_int_set (&amp;buf-&gt;segdone, 0);
 751   buf-&gt;segbase = 0;
 752   g_free (buf-&gt;empty_seg);
 753   buf-&gt;empty_seg = NULL;
 754   gst_caps_replace (&amp;buf-&gt;spec.caps, NULL);
 755   gst_audio_info_init (&amp;buf-&gt;spec.info);
 756   GST_DEBUG_OBJECT (buf, &quot;released device&quot;);
 757 
 758 done:
 759   GST_OBJECT_UNLOCK (buf);
 760 
 761   return res;
 762 
 763   /* ERRORS */
 764 was_released:
 765   {
 766     res = TRUE;
 767     GST_DEBUG_OBJECT (buf, &quot;device was released&quot;);
 768     goto done;
 769   }
 770 release_failed:
 771   {
 772     buf-&gt;acquired = TRUE;
 773     GST_DEBUG_OBJECT (buf, &quot;failed to release device&quot;);
 774     goto done;
 775   }
 776 }
 777 
 778 /**
 779  * gst_audio_ring_buffer_is_acquired:
 780  * @buf: the #GstAudioRingBuffer to check
 781  *
 782  * Check if the ringbuffer is acquired and ready to use.
 783  *
 784  * Returns: TRUE if the ringbuffer is acquired, FALSE on error.
 785  *
 786  * MT safe.
 787  */
 788 gboolean
 789 gst_audio_ring_buffer_is_acquired (GstAudioRingBuffer * buf)
 790 {
 791   gboolean res;
 792 
 793   g_return_val_if_fail (GST_IS_AUDIO_RING_BUFFER (buf), FALSE);
 794 
 795   GST_OBJECT_LOCK (buf);
 796   res = buf-&gt;acquired;
 797   GST_OBJECT_UNLOCK (buf);
 798 
 799   return res;
 800 }
 801 
 802 /**
 803  * gst_audio_ring_buffer_activate:
 804  * @buf: the #GstAudioRingBuffer to activate
 805  * @active: the new mode
 806  *
 807  * Activate @buf to start or stop pulling data.
 808  *
 809  * MT safe.
 810  *
 811  * Returns: TRUE if the device could be activated in the requested mode,
 812  * FALSE on error.
 813  */
 814 gboolean
 815 gst_audio_ring_buffer_activate (GstAudioRingBuffer * buf, gboolean active)
 816 {
 817   gboolean res = FALSE;
 818   GstAudioRingBufferClass *rclass;
 819 
 820   g_return_val_if_fail (GST_IS_AUDIO_RING_BUFFER (buf), FALSE);
 821 
 822   GST_DEBUG_OBJECT (buf, &quot;activate device&quot;);
 823 
 824   GST_OBJECT_LOCK (buf);
 825   if (G_UNLIKELY (active &amp;&amp; !buf-&gt;acquired))
 826     goto not_acquired;
 827 
 828   if (G_UNLIKELY (buf-&gt;active == active))
 829     goto was_active;
 830 
 831   rclass = GST_AUDIO_RING_BUFFER_GET_CLASS (buf);
 832   /* if there is no activate function we assume it was started/released
 833    * in the acquire method */
 834   if (G_LIKELY (rclass-&gt;activate))
 835     res = rclass-&gt;activate (buf, active);
 836   else
 837     res = TRUE;
 838 
 839   if (G_UNLIKELY (!res))
 840     goto activate_failed;
 841 
 842   buf-&gt;active = active;
 843 
 844 done:
 845   GST_OBJECT_UNLOCK (buf);
 846 
 847   return res;
 848 
 849   /* ERRORS */
 850 not_acquired:
 851   {
 852     GST_DEBUG_OBJECT (buf, &quot;device not acquired&quot;);
 853     g_critical (&quot;Device for %p not acquired&quot;, buf);
 854     res = FALSE;
 855     goto done;
 856   }
 857 was_active:
 858   {
 859     res = TRUE;
 860     GST_DEBUG_OBJECT (buf, &quot;device was active in mode %d&quot;, active);
 861     goto done;
 862   }
 863 activate_failed:
 864   {
 865     GST_DEBUG_OBJECT (buf, &quot;failed to activate device&quot;);
 866     goto done;
 867   }
 868 }
 869 
 870 /**
 871  * gst_audio_ring_buffer_is_active:
 872  * @buf: the #GstAudioRingBuffer
 873  *
 874  * Check if @buf is activated.
 875  *
 876  * MT safe.
 877  *
 878  * Returns: TRUE if the device is active.
 879  */
 880 gboolean
 881 gst_audio_ring_buffer_is_active (GstAudioRingBuffer * buf)
 882 {
 883   gboolean res;
 884 
 885   g_return_val_if_fail (GST_IS_AUDIO_RING_BUFFER (buf), FALSE);
 886 
 887   GST_OBJECT_LOCK (buf);
 888   res = buf-&gt;active;
 889   GST_OBJECT_UNLOCK (buf);
 890 
 891   return res;
 892 }
 893 
 894 
 895 /**
 896  * gst_audio_ring_buffer_set_flushing:
 897  * @buf: the #GstAudioRingBuffer to flush
 898  * @flushing: the new mode
 899  *
 900  * Set the ringbuffer to flushing mode or normal mode.
 901  *
 902  * MT safe.
 903  */
 904 void
 905 gst_audio_ring_buffer_set_flushing (GstAudioRingBuffer * buf, gboolean flushing)
 906 {
 907   g_return_if_fail (GST_IS_AUDIO_RING_BUFFER (buf));
 908 
 909   GST_OBJECT_LOCK (buf);
 910   buf-&gt;flushing = flushing;
 911 
 912   if (flushing) {
 913     gst_audio_ring_buffer_pause_unlocked (buf);
 914   } else {
 915     gst_audio_ring_buffer_clear_all (buf);
 916   }
 917   GST_OBJECT_UNLOCK (buf);
 918 }
 919 
 920 /**
 921  * gst_audio_ring_buffer_is_flushing:
 922  * @buf: the #GstAudioRingBuffer
 923  *
 924  * Check if @buf is flushing.
 925  *
 926  * MT safe.
 927  *
 928  * Returns: TRUE if the device is flushing.
 929  */
 930 gboolean
 931 gst_audio_ring_buffer_is_flushing (GstAudioRingBuffer * buf)
 932 {
 933   gboolean res;
 934 
 935   g_return_val_if_fail (GST_IS_AUDIO_RING_BUFFER (buf), TRUE);
 936 
 937   GST_OBJECT_LOCK (buf);
 938   res = buf-&gt;flushing;
 939   GST_OBJECT_UNLOCK (buf);
 940 
 941   return res;
 942 }
 943 
 944 /**
 945  * gst_audio_ring_buffer_start:
 946  * @buf: the #GstAudioRingBuffer to start
 947  *
 948  * Start processing samples from the ringbuffer.
 949  *
 950  * Returns: TRUE if the device could be started, FALSE on error.
 951  *
 952  * MT safe.
 953  */
 954 gboolean
 955 gst_audio_ring_buffer_start (GstAudioRingBuffer * buf)
 956 {
 957   gboolean res = FALSE;
 958   GstAudioRingBufferClass *rclass;
 959   gboolean resume = FALSE;
 960 
 961   g_return_val_if_fail (GST_IS_AUDIO_RING_BUFFER (buf), FALSE);
 962 
 963   GST_DEBUG_OBJECT (buf, &quot;starting ringbuffer&quot;);
 964 
 965   GST_OBJECT_LOCK (buf);
 966   if (G_UNLIKELY (buf-&gt;flushing))
 967     goto flushing;
 968 
 969   if (G_UNLIKELY (!buf-&gt;acquired))
 970     goto not_acquired;
 971 
 972   if (G_UNLIKELY (!g_atomic_int_get (&amp;buf-&gt;may_start)))
 973     goto may_not_start;
 974 
 975   /* if stopped, set to started */
 976   res = g_atomic_int_compare_and_exchange (&amp;buf-&gt;state,
 977       GST_AUDIO_RING_BUFFER_STATE_STOPPED, GST_AUDIO_RING_BUFFER_STATE_STARTED);
 978 
 979   if (!res) {
 980     GST_DEBUG_OBJECT (buf, &quot;was not stopped, try paused&quot;);
 981     /* was not stopped, try from paused */
 982     res = g_atomic_int_compare_and_exchange (&amp;buf-&gt;state,
 983         GST_AUDIO_RING_BUFFER_STATE_PAUSED,
 984         GST_AUDIO_RING_BUFFER_STATE_STARTED);
 985     if (!res) {
 986       /* was not paused either, must be started then */
 987       res = TRUE;
 988       GST_DEBUG_OBJECT (buf, &quot;was not paused, must have been started&quot;);
 989       goto done;
 990     }
 991     resume = TRUE;
 992     GST_DEBUG_OBJECT (buf, &quot;resuming&quot;);
 993   }
 994 
 995   rclass = GST_AUDIO_RING_BUFFER_GET_CLASS (buf);
 996   if (resume) {
 997     if (G_LIKELY (rclass-&gt;resume))
 998       res = rclass-&gt;resume (buf);
 999   } else {
1000     if (G_LIKELY (rclass-&gt;start))
1001       res = rclass-&gt;start (buf);
1002   }
1003 
1004   if (G_UNLIKELY (!res)) {
1005     buf-&gt;state = GST_AUDIO_RING_BUFFER_STATE_PAUSED;
1006     GST_DEBUG_OBJECT (buf, &quot;failed to start&quot;);
1007   } else {
1008     GST_DEBUG_OBJECT (buf, &quot;started&quot;);
1009   }
1010 
1011 done:
1012   GST_OBJECT_UNLOCK (buf);
1013 
1014   return res;
1015 
1016 flushing:
1017   {
1018     GST_DEBUG_OBJECT (buf, &quot;we are flushing&quot;);
1019     GST_OBJECT_UNLOCK (buf);
1020     return FALSE;
1021   }
1022 not_acquired:
1023   {
1024     GST_DEBUG_OBJECT (buf, &quot;we are not acquired&quot;);
1025     GST_OBJECT_UNLOCK (buf);
1026     return FALSE;
1027   }
1028 may_not_start:
1029   {
1030     GST_DEBUG_OBJECT (buf, &quot;we may not start&quot;);
1031     GST_OBJECT_UNLOCK (buf);
1032     return FALSE;
1033   }
1034 }
1035 
1036 static gboolean
1037 gst_audio_ring_buffer_pause_unlocked (GstAudioRingBuffer * buf)
1038 {
1039   gboolean res = FALSE;
1040   GstAudioRingBufferClass *rclass;
1041 
1042   GST_DEBUG_OBJECT (buf, &quot;pausing ringbuffer&quot;);
1043 
1044   /* if started, set to paused */
1045   res = g_atomic_int_compare_and_exchange (&amp;buf-&gt;state,
1046       GST_AUDIO_RING_BUFFER_STATE_STARTED, GST_AUDIO_RING_BUFFER_STATE_PAUSED);
1047 
1048   if (!res)
1049     goto not_started;
1050 
1051   /* signal any waiters */
1052   GST_DEBUG_OBJECT (buf, &quot;signal waiter&quot;);
1053   GST_AUDIO_RING_BUFFER_SIGNAL (buf);
1054 
1055   rclass = GST_AUDIO_RING_BUFFER_GET_CLASS (buf);
1056   if (G_LIKELY (rclass-&gt;pause))
1057     res = rclass-&gt;pause (buf);
1058 
1059   if (G_UNLIKELY (!res)) {
1060     buf-&gt;state = GST_AUDIO_RING_BUFFER_STATE_STARTED;
1061     GST_DEBUG_OBJECT (buf, &quot;failed to pause&quot;);
1062   } else {
1063     GST_DEBUG_OBJECT (buf, &quot;paused&quot;);
1064   }
1065 
1066   return res;
1067 
1068 not_started:
1069   {
1070     /* was not started */
1071     GST_DEBUG_OBJECT (buf, &quot;was not started&quot;);
1072     return TRUE;
1073   }
1074 }
1075 
1076 /**
1077  * gst_audio_ring_buffer_pause:
1078  * @buf: the #GstAudioRingBuffer to pause
1079  *
1080  * Pause processing samples from the ringbuffer.
1081  *
1082  * Returns: TRUE if the device could be paused, FALSE on error.
1083  *
1084  * MT safe.
1085  */
1086 gboolean
1087 gst_audio_ring_buffer_pause (GstAudioRingBuffer * buf)
1088 {
1089   gboolean res = FALSE;
1090 
1091   g_return_val_if_fail (GST_IS_AUDIO_RING_BUFFER (buf), FALSE);
1092 
1093   GST_OBJECT_LOCK (buf);
1094   if (G_UNLIKELY (buf-&gt;flushing))
1095     goto flushing;
1096 
1097   if (G_UNLIKELY (!buf-&gt;acquired))
1098     goto not_acquired;
1099 
1100   res = gst_audio_ring_buffer_pause_unlocked (buf);
1101   GST_OBJECT_UNLOCK (buf);
1102 
1103   return res;
1104 
1105   /* ERRORS */
1106 flushing:
1107   {
1108     GST_DEBUG_OBJECT (buf, &quot;we are flushing&quot;);
1109     GST_OBJECT_UNLOCK (buf);
1110     return FALSE;
1111   }
1112 not_acquired:
1113   {
1114     GST_DEBUG_OBJECT (buf, &quot;not acquired&quot;);
1115     GST_OBJECT_UNLOCK (buf);
1116     return FALSE;
1117   }
1118 }
1119 
1120 /**
1121  * gst_audio_ring_buffer_stop:
1122  * @buf: the #GstAudioRingBuffer to stop
1123  *
1124  * Stop processing samples from the ringbuffer.
1125  *
1126  * Returns: TRUE if the device could be stopped, FALSE on error.
1127  *
1128  * MT safe.
1129  */
1130 gboolean
1131 gst_audio_ring_buffer_stop (GstAudioRingBuffer * buf)
1132 {
1133   gboolean res = FALSE;
1134   GstAudioRingBufferClass *rclass;
1135 
1136   g_return_val_if_fail (GST_IS_AUDIO_RING_BUFFER (buf), FALSE);
1137 
1138   GST_DEBUG_OBJECT (buf, &quot;stopping&quot;);
1139 
1140   GST_OBJECT_LOCK (buf);
1141 
1142   /* if started, set to stopped */
1143   res = g_atomic_int_compare_and_exchange (&amp;buf-&gt;state,
1144       GST_AUDIO_RING_BUFFER_STATE_STARTED, GST_AUDIO_RING_BUFFER_STATE_STOPPED);
1145 
1146   if (!res) {
1147     GST_DEBUG_OBJECT (buf, &quot;was not started, try paused&quot;);
1148     /* was not started, try from paused */
1149     res = g_atomic_int_compare_and_exchange (&amp;buf-&gt;state,
1150         GST_AUDIO_RING_BUFFER_STATE_PAUSED,
1151         GST_AUDIO_RING_BUFFER_STATE_STOPPED);
1152     if (!res) {
1153       /* was not paused either, must have been stopped then */
1154       res = TRUE;
1155       GST_DEBUG_OBJECT (buf, &quot;was not paused, must have been stopped&quot;);
1156       goto done;
1157     }
1158   }
1159 
1160   /* signal any waiters */
1161   GST_DEBUG_OBJECT (buf, &quot;signal waiter&quot;);
1162   GST_AUDIO_RING_BUFFER_SIGNAL (buf);
1163 
1164   rclass = GST_AUDIO_RING_BUFFER_GET_CLASS (buf);
1165   if (G_LIKELY (rclass-&gt;stop))
1166     res = rclass-&gt;stop (buf);
1167 
1168   if (G_UNLIKELY (!res)) {
1169     buf-&gt;state = GST_AUDIO_RING_BUFFER_STATE_STARTED;
1170     GST_DEBUG_OBJECT (buf, &quot;failed to stop&quot;);
1171   } else {
1172     GST_DEBUG_OBJECT (buf, &quot;stopped&quot;);
1173   }
1174 done:
1175   GST_OBJECT_UNLOCK (buf);
1176 
1177   return res;
1178 }
1179 
1180 /**
1181  * gst_audio_ring_buffer_delay:
1182  * @buf: the #GstAudioRingBuffer to query
1183  *
1184  * Get the number of samples queued in the audio device. This is
1185  * usually less than the segment size but can be bigger when the
1186  * implementation uses another internal buffer between the audio
1187  * device.
1188  *
1189  * For playback ringbuffers this is the amount of samples transfered from the
1190  * ringbuffer to the device but still not played.
1191  *
1192  * For capture ringbuffers this is the amount of samples in the device that are
1193  * not yet transfered to the ringbuffer.
1194  *
1195  * Returns: The number of samples queued in the audio device.
1196  *
1197  * MT safe.
1198  */
1199 guint
1200 gst_audio_ring_buffer_delay (GstAudioRingBuffer * buf)
1201 {
1202   GstAudioRingBufferClass *rclass;
1203   guint res;
1204 
1205   g_return_val_if_fail (GST_IS_AUDIO_RING_BUFFER (buf), 0);
1206 
1207   /* buffer must be acquired */
1208   if (G_UNLIKELY (!gst_audio_ring_buffer_is_acquired (buf)))
1209     goto not_acquired;
1210 
1211   rclass = GST_AUDIO_RING_BUFFER_GET_CLASS (buf);
1212   if (G_LIKELY (rclass-&gt;delay))
1213     res = rclass-&gt;delay (buf);
1214   else
1215     res = 0;
1216 
1217   return res;
1218 
1219 not_acquired:
1220   {
1221     GST_DEBUG_OBJECT (buf, &quot;not acquired&quot;);
1222     return 0;
1223   }
1224 }
1225 
1226 /**
1227  * gst_audio_ring_buffer_samples_done:
1228  * @buf: the #GstAudioRingBuffer to query
1229  *
1230  * Get the number of samples that were processed by the ringbuffer
1231  * since it was last started. This does not include the number of samples not
1232  * yet processed (see gst_audio_ring_buffer_delay()).
1233  *
1234  * Returns: The number of samples processed by the ringbuffer.
1235  *
1236  * MT safe.
1237  */
1238 guint64
1239 gst_audio_ring_buffer_samples_done (GstAudioRingBuffer * buf)
1240 {
1241   gint segdone;
1242   guint64 samples;
1243 
1244   g_return_val_if_fail (GST_IS_AUDIO_RING_BUFFER (buf), 0);
1245 
1246   /* get the amount of segments we processed */
1247   segdone = g_atomic_int_get (&amp;buf-&gt;segdone);
1248 
1249   /* convert to samples */
1250   samples = ((guint64) segdone) * buf-&gt;samples_per_seg;
1251 
1252   return samples;
1253 }
1254 
1255 /**
1256  * gst_audio_ring_buffer_set_sample:
1257  * @buf: the #GstAudioRingBuffer to use
1258  * @sample: the sample number to set
1259  *
1260  * Make sure that the next sample written to the device is
1261  * accounted for as being the @sample sample written to the
1262  * device. This value will be used in reporting the current
1263  * sample position of the ringbuffer.
1264  *
1265  * This function will also clear the buffer with silence.
1266  *
1267  * MT safe.
1268  */
1269 void
1270 gst_audio_ring_buffer_set_sample (GstAudioRingBuffer * buf, guint64 sample)
1271 {
1272   g_return_if_fail (GST_IS_AUDIO_RING_BUFFER (buf));
1273 
1274   if (sample == -1)
1275     sample = 0;
1276 
1277   if (G_UNLIKELY (buf-&gt;samples_per_seg == 0))
1278     return;
1279 
1280   /* FIXME, we assume the ringbuffer can restart at a random
1281    * position, round down to the beginning and keep track of
1282    * offset when calculating the processed samples. */
1283   buf-&gt;segbase = buf-&gt;segdone - sample / buf-&gt;samples_per_seg;
1284 
1285   gst_audio_ring_buffer_clear_all (buf);
1286 
1287   GST_DEBUG_OBJECT (buf, &quot;set sample to %&quot; G_GUINT64_FORMAT &quot;, segbase %d&quot;,
1288       sample, buf-&gt;segbase);
1289 }
1290 
1291 static void
1292 default_clear_all (GstAudioRingBuffer * buf)
1293 {
1294   gint i;
1295 
1296   /* not fatal, we just are not negotiated yet */
1297   if (G_UNLIKELY (buf-&gt;spec.segtotal &lt;= 0))
1298     return;
1299 
1300   GST_DEBUG_OBJECT (buf, &quot;clear all segments&quot;);
1301 
1302   for (i = 0; i &lt; buf-&gt;spec.segtotal; i++) {
1303     gst_audio_ring_buffer_clear (buf, i);
1304   }
1305 }
1306 
1307 /**
1308  * gst_audio_ring_buffer_clear_all:
1309  * @buf: the #GstAudioRingBuffer to clear
1310  *
1311  * Fill the ringbuffer with silence.
1312  *
1313  * MT safe.
1314  */
1315 void
1316 gst_audio_ring_buffer_clear_all (GstAudioRingBuffer * buf)
1317 {
1318   GstAudioRingBufferClass *rclass;
1319 
1320   g_return_if_fail (GST_IS_AUDIO_RING_BUFFER (buf));
1321 
1322   rclass = GST_AUDIO_RING_BUFFER_GET_CLASS (buf);
1323 
1324   if (G_LIKELY (rclass-&gt;clear_all))
1325     rclass-&gt;clear_all (buf);
1326 }
1327 
1328 
1329 static gboolean
1330 wait_segment (GstAudioRingBuffer * buf)
1331 {
1332   gint segments;
1333   gboolean wait = TRUE;
1334 
1335   /* buffer must be started now or we deadlock since nobody is reading */
1336   if (G_UNLIKELY (g_atomic_int_get (&amp;buf-&gt;state) !=
1337           GST_AUDIO_RING_BUFFER_STATE_STARTED)) {
1338     /* see if we are allowed to start it */
1339     if (G_UNLIKELY (!g_atomic_int_get (&amp;buf-&gt;may_start)))
1340       goto no_start;
1341 
1342     GST_DEBUG_OBJECT (buf, &quot;start!&quot;);
1343     segments = g_atomic_int_get (&amp;buf-&gt;segdone);
1344     gst_audio_ring_buffer_start (buf);
1345 
1346     /* After starting, the writer may have wrote segments already and then we
1347      * don&#39;t need to wait anymore */
1348     if (G_LIKELY (g_atomic_int_get (&amp;buf-&gt;segdone) != segments))
1349       wait = FALSE;
1350   }
1351 
1352   /* take lock first, then update our waiting flag */
1353   GST_OBJECT_LOCK (buf);
1354   if (G_UNLIKELY (buf-&gt;flushing))
1355     goto flushing;
1356 
1357   if (G_UNLIKELY (g_atomic_int_get (&amp;buf-&gt;state) !=
1358           GST_AUDIO_RING_BUFFER_STATE_STARTED))
1359     goto not_started;
1360 
1361   if (G_LIKELY (wait)) {
1362     if (g_atomic_int_compare_and_exchange (&amp;buf-&gt;waiting, 0, 1)) {
1363       GST_DEBUG_OBJECT (buf, &quot;waiting..&quot;);
1364       GST_AUDIO_RING_BUFFER_WAIT (buf);
1365 
1366       if (G_UNLIKELY (buf-&gt;flushing))
1367         goto flushing;
1368 
1369       if (G_UNLIKELY (g_atomic_int_get (&amp;buf-&gt;state) !=
1370               GST_AUDIO_RING_BUFFER_STATE_STARTED))
1371         goto not_started;
1372     }
1373   }
1374   GST_OBJECT_UNLOCK (buf);
1375 
1376   return TRUE;
1377 
1378   /* ERROR */
1379 not_started:
1380   {
1381     g_atomic_int_compare_and_exchange (&amp;buf-&gt;waiting, 1, 0);
1382     GST_DEBUG_OBJECT (buf, &quot;stopped processing&quot;);
1383     GST_OBJECT_UNLOCK (buf);
1384     return FALSE;
1385   }
1386 flushing:
1387   {
1388     g_atomic_int_compare_and_exchange (&amp;buf-&gt;waiting, 1, 0);
1389     GST_DEBUG_OBJECT (buf, &quot;flushing&quot;);
1390     GST_OBJECT_UNLOCK (buf);
1391     return FALSE;
1392   }
1393 no_start:
1394   {
1395     GST_DEBUG_OBJECT (buf, &quot;not allowed to start&quot;);
1396     return FALSE;
1397   }
1398 }
1399 
1400 
1401 
1402 #define REORDER_SAMPLE(d, s, l)                 \
1403 G_STMT_START {                                  \
1404   gint i;                                       \
1405   for (i = 0; i &lt; channels; i++) {              \
1406     memcpy (d + reorder_map[i] * bps, s + i * bps, bps); \
1407   }                                             \
1408 } G_STMT_END
1409 
1410 #define REORDER_SAMPLES(d, s, len)              \
1411 G_STMT_START {                                  \
1412   gint i, len_ = len / bpf;                     \
1413   guint8 *d_ = d, *s_ = s;                      \
1414   for (i = 0; i &lt; len_; i++) {                  \
1415     REORDER_SAMPLE(d_, s_, bpf);                \
1416     d_ += bpf;                                  \
1417     s_ += bpf;                                  \
1418   }                                             \
1419 } G_STMT_END
1420 
1421 #define FWD_SAMPLES(s,se,d,de,F)            \
1422 G_STMT_START {                  \
1423   /* no rate conversion */          \
1424   guint towrite = MIN (se + bpf - s, de - d);   \
1425   /* simple copy */             \
1426   if (!skip)                    \
1427     F (d, s, towrite);                  \
1428   in_samples -= towrite / bpf;          \
1429   out_samples -= towrite / bpf;         \
1430   s += towrite;                 \
1431   GST_DEBUG (&quot;copy %u bytes&quot;, towrite);     \
1432 } G_STMT_END
1433 
1434 /* in_samples &gt;= out_samples, rate &gt; 1.0 */
1435 #define FWD_UP_SAMPLES(s,se,d,de,F)         \
1436 G_STMT_START {                  \
1437   guint8 *sb = s, *db = d;          \
1438   while (s &lt;= se &amp;&amp; d &lt; de) {           \
1439     if (!skip)                  \
1440       F (d, s, bpf);                        \
1441     s += bpf;                   \
1442     *accum += outr;             \
1443     if ((*accum &lt;&lt; 1) &gt;= inr) {         \
1444       *accum -= inr;                \
1445       d += bpf;                 \
1446     }                       \
1447   }                     \
1448   in_samples -= (s - sb)/bpf;           \
1449   out_samples -= (d - db)/bpf;          \
1450   GST_DEBUG (&quot;fwd_up end %d/%d&quot;,*accum,*toprocess); \
1451 } G_STMT_END
1452 
1453 /* out_samples &gt; in_samples, for rates smaller than 1.0 */
1454 #define FWD_DOWN_SAMPLES(s,se,d,de,F)       \
1455 G_STMT_START {                  \
1456   guint8 *sb = s, *db = d;          \
1457   while (s &lt;= se &amp;&amp; d &lt; de) {           \
1458     if (!skip)                  \
1459       F (d, s, bpf);                        \
1460     d += bpf;                   \
1461     *accum += inr;              \
1462     if ((*accum &lt;&lt; 1) &gt;= outr) {        \
1463       *accum -= outr;               \
1464       s += bpf;                 \
1465     }                       \
1466   }                     \
1467   in_samples -= (s - sb)/bpf;           \
1468   out_samples -= (d - db)/bpf;          \
1469   GST_DEBUG (&quot;fwd_down end %d/%d&quot;,*accum,*toprocess);   \
1470 } G_STMT_END
1471 
1472 #define REV_UP_SAMPLES(s,se,d,de,F)         \
1473 G_STMT_START {                  \
1474   guint8 *sb = se, *db = d;         \
1475   while (s &lt;= se &amp;&amp; d &lt; de) {           \
1476     if (!skip)                  \
1477       F (d, se, bpf);                       \
1478     se -= bpf;                  \
1479     *accum += outr;             \
1480     while (d &lt; de &amp;&amp; (*accum &lt;&lt; 1) &gt;= inr) {    \
1481       *accum -= inr;                \
1482       d += bpf;                 \
1483     }                       \
1484   }                     \
1485   in_samples -= (sb - se)/bpf;          \
1486   out_samples -= (d - db)/bpf;          \
1487   GST_DEBUG (&quot;rev_up end %d/%d&quot;,*accum,*toprocess); \
1488 } G_STMT_END
1489 
1490 #define REV_DOWN_SAMPLES(s,se,d,de,F)       \
1491 G_STMT_START {                  \
1492   guint8 *sb = se, *db = d;         \
1493   while (s &lt;= se &amp;&amp; d &lt; de) {           \
1494     if (!skip)                  \
1495       F (d, se, bpf);                   \
1496     d += bpf;                   \
1497     *accum += inr;              \
1498     while (s &lt;= se &amp;&amp; (*accum &lt;&lt; 1) &gt;= outr) {  \
1499       *accum -= outr;               \
1500       se -= bpf;                \
1501     }                       \
1502   }                     \
1503   in_samples -= (sb - se)/bpf;          \
1504   out_samples -= (d - db)/bpf;          \
1505   GST_DEBUG (&quot;rev_down end %d/%d&quot;,*accum,*toprocess);   \
1506 } G_STMT_END
1507 
1508 static guint
1509 default_commit (GstAudioRingBuffer * buf, guint64 * sample,
1510     guint8 * data, gint in_samples, gint out_samples, gint * accum)
1511 {
1512   gint segdone;
1513   gint segsize, segtotal, channels, bps, bpf, sps;
1514   guint8 *dest, *data_end;
1515   gint writeseg, sampleoff;
1516   gint *toprocess;
1517   gint inr, outr;
1518   gboolean reverse;
1519   gboolean need_reorder;
1520 
1521   g_return_val_if_fail (buf-&gt;memory != NULL, -1);
1522   g_return_val_if_fail (data != NULL, -1);
1523 
1524   need_reorder = buf-&gt;need_reorder;
1525 
1526   channels = buf-&gt;spec.info.channels;
1527   dest = buf-&gt;memory;
1528   segsize = buf-&gt;spec.segsize;
1529   segtotal = buf-&gt;spec.segtotal;
1530   bpf = buf-&gt;spec.info.bpf;
1531   bps = bpf / channels;
1532   sps = buf-&gt;samples_per_seg;
1533 
1534   reverse = out_samples &lt; 0;
1535   out_samples = ABS (out_samples);
1536 
1537   if (in_samples &gt;= out_samples)
1538     toprocess = &amp;in_samples;
1539   else
1540     toprocess = &amp;out_samples;
1541 
1542   inr = in_samples - 1;
1543   outr = out_samples - 1;
1544 
1545   /* data_end points to the last sample we have to write, not past it. This is
1546    * needed to properly handle reverse playback: it points to the last sample. */
1547   data_end = data + (bpf * inr);
1548 
1549   /* figure out the segment and the offset inside the segment where
1550    * the first sample should be written. */
1551   writeseg = *sample / sps;
1552   sampleoff = (*sample % sps) * bpf;
1553 
1554   GST_DEBUG_OBJECT (buf, &quot;write %d : %d&quot;, in_samples, out_samples);
1555 
1556   /* write out all samples */
1557   while (*toprocess &gt; 0) {
1558     gint avail;
1559     guint8 *d, *d_end;
1560     gint ws;
1561     gboolean skip;
1562 
1563     while (TRUE) {
1564       gint diff;
1565 
1566       /* get the currently processed segment */
1567       segdone = g_atomic_int_get (&amp;buf-&gt;segdone) - buf-&gt;segbase;
1568 
1569       /* see how far away it is from the write segment */
1570       diff = writeseg - segdone;
1571 
1572       GST_DEBUG_OBJECT (buf,
1573           &quot;pointer at %d, write to %d-%d, diff %d, segtotal %d, segsize %d, base %d&quot;,
1574           segdone, writeseg, sampleoff, diff, segtotal, segsize, buf-&gt;segbase);
1575 
1576       /* segment too far ahead, writer too slow, we need to drop, hopefully UNLIKELY */
1577       if (G_UNLIKELY (diff &lt; 0)) {
1578         /* we need to drop one segment at a time, pretend we wrote a segment. */
1579         skip = TRUE;
1580         break;
1581       }
1582 
1583       /* write segment is within writable range, we can break the loop and
1584        * start writing the data. */
1585       if (diff &lt; segtotal) {
1586         skip = FALSE;
1587         break;
1588       }
1589 
1590       /* else we need to wait for the segment to become writable. */
1591       if (!wait_segment (buf))
1592         goto not_started;
1593     }
1594 
1595     /* we can write now */
1596     ws = writeseg % segtotal;
1597     avail = MIN (segsize - sampleoff, bpf * out_samples);
1598 
1599     d = dest + (ws * segsize) + sampleoff;
1600     d_end = d + avail;
1601     *sample += avail / bpf;
1602 
1603     GST_DEBUG_OBJECT (buf, &quot;write @%p seg %d, sps %d, off %d, avail %d&quot;,
1604         dest + ws * segsize, ws, sps, sampleoff, avail);
1605 
1606     if (need_reorder) {
1607       gint *reorder_map = buf-&gt;channel_reorder_map;
1608 
1609       if (G_LIKELY (inr == outr &amp;&amp; !reverse)) {
1610         /* no rate conversion, simply copy samples */
1611         FWD_SAMPLES (data, data_end, d, d_end, REORDER_SAMPLES);
1612       } else if (!reverse) {
1613         if (inr &gt;= outr)
1614           /* forward speed up */
1615           FWD_UP_SAMPLES (data, data_end, d, d_end, REORDER_SAMPLE);
1616         else
1617           /* forward slow down */
1618           FWD_DOWN_SAMPLES (data, data_end, d, d_end, REORDER_SAMPLE);
1619       } else {
1620         if (inr &gt;= outr)
1621           /* reverse speed up */
1622           REV_UP_SAMPLES (data, data_end, d, d_end, REORDER_SAMPLE);
1623         else
1624           /* reverse slow down */
1625           REV_DOWN_SAMPLES (data, data_end, d, d_end, REORDER_SAMPLE);
1626       }
1627     } else {
1628       if (G_LIKELY (inr == outr &amp;&amp; !reverse)) {
1629         /* no rate conversion, simply copy samples */
1630         FWD_SAMPLES (data, data_end, d, d_end, memcpy);
1631       } else if (!reverse) {
1632         if (inr &gt;= outr)
1633           /* forward speed up */
1634           FWD_UP_SAMPLES (data, data_end, d, d_end, memcpy);
1635         else
1636           /* forward slow down */
1637           FWD_DOWN_SAMPLES (data, data_end, d, d_end, memcpy);
1638       } else {
1639         if (inr &gt;= outr)
1640           /* reverse speed up */
1641           REV_UP_SAMPLES (data, data_end, d, d_end, memcpy);
1642         else
1643           /* reverse slow down */
1644           REV_DOWN_SAMPLES (data, data_end, d, d_end, memcpy);
1645       }
1646     }
1647 
1648     /* for the next iteration we write to the next segment at the beginning. */
1649     writeseg++;
1650     sampleoff = 0;
1651   }
1652   /* we consumed all samples here */
1653   data = data_end + bpf;
1654 
1655 done:
1656   return inr - ((data_end - data) / bpf);
1657 
1658   /* ERRORS */
1659 not_started:
1660   {
1661     GST_DEBUG_OBJECT (buf, &quot;stopped processing&quot;);
1662     goto done;
1663   }
1664 }
1665 
1666 /**
1667  * gst_audio_ring_buffer_commit:
1668  * @buf: the #GstAudioRingBuffer to commit
1669  * @sample: the sample position of the data
1670  * @data: (array length=in_samples): the data to commit
1671  * @in_samples: the number of samples in the data to commit
1672  * @out_samples: the number of samples to write to the ringbuffer
1673  * @accum: (inout): accumulator for rate conversion.
1674  *
1675  * Commit @in_samples samples pointed to by @data to the ringbuffer @buf.
1676  *
1677  * @in_samples and @out_samples define the rate conversion to perform on the
1678  * samples in @data. For negative rates, @out_samples must be negative and
1679  * @in_samples positive.
1680  *
1681  * When @out_samples is positive, the first sample will be written at position @sample
1682  * in the ringbuffer. When @out_samples is negative, the last sample will be written to
1683  * @sample in reverse order.
1684  *
1685  * @out_samples does not need to be a multiple of the segment size of the ringbuffer
1686  * although it is recommended for optimal performance.
1687  *
1688  * @accum will hold a temporary accumulator used in rate conversion and should be
1689  * set to 0 when this function is first called. In case the commit operation is
1690  * interrupted, one can resume the processing by passing the previously returned
1691  * @accum value back to this function.
1692  *
1693  * MT safe.
1694  *
1695  * Returns: The number of samples written to the ringbuffer or -1 on error. The
1696  * number of samples written can be less than @out_samples when @buf was interrupted
1697  * with a flush or stop.
1698  */
1699 guint
1700 gst_audio_ring_buffer_commit (GstAudioRingBuffer * buf, guint64 * sample,
1701     guint8 * data, gint in_samples, gint out_samples, gint * accum)
1702 {
1703   GstAudioRingBufferClass *rclass;
1704   guint res = -1;
1705 
1706   g_return_val_if_fail (GST_IS_AUDIO_RING_BUFFER (buf), -1);
1707 
1708   if (G_UNLIKELY (in_samples == 0 || out_samples == 0))
1709     return in_samples;
1710 
1711   rclass = GST_AUDIO_RING_BUFFER_GET_CLASS (buf);
1712 
1713   if (G_LIKELY (rclass-&gt;commit))
1714     res = rclass-&gt;commit (buf, sample, data, in_samples, out_samples, accum);
1715 
1716   return res;
1717 }
1718 
1719 /**
1720  * gst_audio_ring_buffer_read:
1721  * @buf: the #GstAudioRingBuffer to read from
1722  * @sample: the sample position of the data
1723  * @data: (array length=len): where the data should be read
1724  * @len: the number of samples in data to read
1725  * @timestamp: (out): where the timestamp is returned
1726  *
1727  * Read @len samples from the ringbuffer into the memory pointed
1728  * to by @data.
1729  * The first sample should be read from position @sample in
1730  * the ringbuffer.
1731  *
1732  * @len should not be a multiple of the segment size of the ringbuffer
1733  * although it is recommended.
1734  *
1735  * @timestamp will return the timestamp associated with the data returned.
1736  *
1737  * Returns: The number of samples read from the ringbuffer or -1 on
1738  * error.
1739  *
1740  * MT safe.
1741  */
1742 guint
1743 gst_audio_ring_buffer_read (GstAudioRingBuffer * buf, guint64 sample,
1744     guint8 * data, guint len, GstClockTime * timestamp)
1745 {
1746   gint segdone;
1747   gint segsize, segtotal, channels, bps, bpf, sps, readseg = 0;
1748   guint8 *dest;
1749   guint to_read;
1750   gboolean need_reorder;
1751 
1752   g_return_val_if_fail (GST_IS_AUDIO_RING_BUFFER (buf), -1);
1753   g_return_val_if_fail (buf-&gt;memory != NULL, -1);
1754   g_return_val_if_fail (data != NULL, -1);
1755 
1756   need_reorder = buf-&gt;need_reorder;
1757   dest = buf-&gt;memory;
1758   segsize = buf-&gt;spec.segsize;
1759   segtotal = buf-&gt;spec.segtotal;
1760   channels = buf-&gt;spec.info.channels;
1761   bpf = buf-&gt;spec.info.bpf;
1762   bps = bpf / channels;
1763   sps = buf-&gt;samples_per_seg;
1764 
1765   to_read = len;
1766   /* read enough samples */
1767   while (to_read &gt; 0) {
1768     gint sampleslen;
1769     gint sampleoff;
1770 
1771     /* figure out the segment and the offset inside the segment where
1772      * the sample should be read from. */
1773     readseg = sample / sps;
1774     sampleoff = (sample % sps);
1775 
1776     while (TRUE) {
1777       gint diff;
1778 
1779       /* get the currently processed segment */
1780       segdone = g_atomic_int_get (&amp;buf-&gt;segdone) - buf-&gt;segbase;
1781 
1782       /* see how far away it is from the read segment, normally segdone (where
1783        * the hardware is writing) is bigger than readseg (where software is
1784        * reading) */
1785       diff = segdone - readseg;
1786 
1787       GST_DEBUG_OBJECT
1788           (buf, &quot;pointer at %d, sample %&quot; G_GUINT64_FORMAT
1789           &quot;, read from %d-%d, to_read %d, diff %d, segtotal %d, segsize %d&quot;,
1790           segdone, sample, readseg, sampleoff, to_read, diff, segtotal,
1791           segsize);
1792 
1793       /* segment too far ahead, reader too slow */
1794       if (G_UNLIKELY (diff &gt;= segtotal)) {
1795         /* pretend we read an empty segment. */
1796         sampleslen = MIN (sps, to_read);
1797         memcpy (data, buf-&gt;empty_seg, sampleslen * bpf);
1798         goto next;
1799       }
1800 
1801       /* read segment is within readable range, we can break the loop and
1802        * start reading the data. */
1803       if (diff &gt; 0)
1804         break;
1805 
1806       /* else we need to wait for the segment to become readable. */
1807       if (!wait_segment (buf))
1808         goto not_started;
1809     }
1810 
1811     /* we can read now */
1812     readseg = readseg % segtotal;
1813     sampleslen = MIN (sps - sampleoff, to_read);
1814 
1815     GST_DEBUG_OBJECT (buf, &quot;read @%p seg %d, off %d, sampleslen %d&quot;,
1816         dest + readseg * segsize, readseg, sampleoff, sampleslen);
1817 
1818     if (need_reorder) {
1819       guint8 *ptr = dest + (readseg * segsize) + (sampleoff * bpf);
1820       gint i, j;
1821       gint *reorder_map = buf-&gt;channel_reorder_map;
1822 
1823       /* Reorder from device order to GStreamer order */
1824       for (i = 0; i &lt; sampleslen; i++) {
1825         for (j = 0; j &lt; channels; j++) {
1826           memcpy (data + reorder_map[j] * bps, ptr + j * bps, bps);
1827         }
1828         ptr += bpf;
1829       }
1830     } else {
1831       memcpy (data, dest + (readseg * segsize) + (sampleoff * bpf),
1832           (sampleslen * bpf));
1833     }
1834 
1835   next:
1836     to_read -= sampleslen;
1837     sample += sampleslen;
1838     data += sampleslen * bpf;
1839   }
1840 
1841   if (buf-&gt;timestamps &amp;&amp; timestamp) {
1842     *timestamp = buf-&gt;timestamps[readseg % segtotal];
1843     GST_DEBUG_OBJECT (buf, &quot;Retrieved timestamp %&quot; GST_TIME_FORMAT
1844         &quot; @ %d&quot;, GST_TIME_ARGS (*timestamp), readseg % segtotal);
1845   }
1846 
1847   return len - to_read;
1848 
1849   /* ERRORS */
1850 not_started:
1851   {
1852     GST_DEBUG_OBJECT (buf, &quot;stopped processing&quot;);
1853     return len - to_read;
1854   }
1855 }
1856 
1857 /**
1858  * gst_audio_ring_buffer_prepare_read:
1859  * @buf: the #GstAudioRingBuffer to read from
1860  * @segment: (out): the segment to read
1861  * @readptr: (out) (array length=len):
1862  *     the pointer to the memory where samples can be read
1863  * @len: (out): the number of bytes to read
1864  *
1865  * Returns a pointer to memory where the data from segment @segment
1866  * can be found. This function is mostly used by subclasses.
1867  *
1868  * Returns: FALSE if the buffer is not started.
1869  *
1870  * MT safe.
1871  */
1872 gboolean
1873 gst_audio_ring_buffer_prepare_read (GstAudioRingBuffer * buf, gint * segment,
1874     guint8 ** readptr, gint * len)
1875 {
1876   guint8 *data;
1877   gint segdone;
1878 
1879   g_return_val_if_fail (GST_IS_AUDIO_RING_BUFFER (buf), FALSE);
1880 
1881   if (buf-&gt;callback == NULL) {
1882     /* push mode, fail when nothing is started */
1883     if (g_atomic_int_get (&amp;buf-&gt;state) != GST_AUDIO_RING_BUFFER_STATE_STARTED)
1884       return FALSE;
1885   }
1886 
1887   g_return_val_if_fail (buf-&gt;memory != NULL, FALSE);
1888   g_return_val_if_fail (segment != NULL, FALSE);
1889   g_return_val_if_fail (readptr != NULL, FALSE);
1890   g_return_val_if_fail (len != NULL, FALSE);
1891 
1892   data = buf-&gt;memory;
1893 
1894   /* get the position of the pointer */
1895   segdone = g_atomic_int_get (&amp;buf-&gt;segdone);
1896 
1897   *segment = segdone % buf-&gt;spec.segtotal;
1898   *len = buf-&gt;spec.segsize;
1899   *readptr = data + *segment * *len;
1900 
1901   GST_LOG_OBJECT (buf, &quot;prepare read from segment %d (real %d) @%p&quot;,
1902       *segment, segdone, *readptr);
1903 
1904   /* callback to fill the memory with data, for pull based
1905    * scheduling. */
1906   if (buf-&gt;callback)
1907     buf-&gt;callback (buf, *readptr, *len, buf-&gt;cb_data);
1908 
1909   return TRUE;
1910 }
1911 
1912 /**
1913  * gst_audio_ring_buffer_advance:
1914  * @buf: the #GstAudioRingBuffer to advance
1915  * @advance: the number of segments written
1916  *
1917  * Subclasses should call this function to notify the fact that
1918  * @advance segments are now processed by the device.
1919  *
1920  * MT safe.
1921  */
1922 void
1923 gst_audio_ring_buffer_advance (GstAudioRingBuffer * buf, guint advance)
1924 {
1925   g_return_if_fail (GST_IS_AUDIO_RING_BUFFER (buf));
1926 
1927   /* update counter */
1928   g_atomic_int_add (&amp;buf-&gt;segdone, advance);
1929 
1930   /* the lock is already taken when the waiting flag is set,
1931    * we grab the lock as well to make sure the waiter is actually
1932    * waiting for the signal */
1933   if (g_atomic_int_compare_and_exchange (&amp;buf-&gt;waiting, 1, 0)) {
1934     GST_OBJECT_LOCK (buf);
1935     GST_DEBUG_OBJECT (buf, &quot;signal waiter&quot;);
1936     GST_AUDIO_RING_BUFFER_SIGNAL (buf);
1937     GST_OBJECT_UNLOCK (buf);
1938   }
1939 }
1940 
1941 /**
1942  * gst_audio_ring_buffer_clear:
1943  * @buf: the #GstAudioRingBuffer to clear
1944  * @segment: the segment to clear
1945  *
1946  * Clear the given segment of the buffer with silence samples.
1947  * This function is used by subclasses.
1948  *
1949  * MT safe.
1950  */
1951 void
1952 gst_audio_ring_buffer_clear (GstAudioRingBuffer * buf, gint segment)
1953 {
1954   guint8 *data;
1955 
1956   g_return_if_fail (GST_IS_AUDIO_RING_BUFFER (buf));
1957 
1958   /* no data means it&#39;s already cleared */
1959   if (G_UNLIKELY (buf-&gt;memory == NULL))
1960     return;
1961 
1962   /* no empty_seg means it&#39;s not opened */
1963   if (G_UNLIKELY (buf-&gt;empty_seg == NULL))
1964     return;
1965 
1966   segment %= buf-&gt;spec.segtotal;
1967 
1968   data = buf-&gt;memory;
1969   data += segment * buf-&gt;spec.segsize;
1970 
1971   GST_LOG_OBJECT (buf, &quot;clear segment %d @%p&quot;, segment, data);
1972 
1973   memcpy (data, buf-&gt;empty_seg, buf-&gt;spec.segsize);
1974 }
1975 
1976 /**
1977  * gst_audio_ring_buffer_may_start:
1978  * @buf: the #GstAudioRingBuffer
1979  * @allowed: the new value
1980  *
1981  * Tell the ringbuffer that it is allowed to start playback when
1982  * the ringbuffer is filled with samples.
1983  *
1984  * MT safe.
1985  */
1986 void
1987 gst_audio_ring_buffer_may_start (GstAudioRingBuffer * buf, gboolean allowed)
1988 {
1989   g_return_if_fail (GST_IS_AUDIO_RING_BUFFER (buf));
1990 
1991   GST_LOG_OBJECT (buf, &quot;may start: %d&quot;, allowed);
1992   g_atomic_int_set (&amp;buf-&gt;may_start, allowed);
1993 }
1994 
1995 /* GST_AUDIO_CHANNEL_POSITION_NONE is used for position-less
1996  * mutually exclusive channels. In this case we should not attempt
1997  * to do any reordering.
1998  */
1999 static gboolean
2000 position_less_channels (const GstAudioChannelPosition * pos, guint channels)
2001 {
2002   guint i;
2003 
2004   for (i = 0; i &lt; channels; i++) {
2005     if (pos[i] != GST_AUDIO_CHANNEL_POSITION_NONE)
2006       return FALSE;
2007   }
2008 
2009   return TRUE;
2010 }
2011 
2012 /**
2013  * gst_audio_ring_buffer_set_channel_positions:
2014  * @buf: the #GstAudioRingBuffer
2015  * @position: (array): the device channel positions
2016  *
2017  * Tell the ringbuffer about the device&#39;s channel positions. This must
2018  * be called in when the ringbuffer is acquired.
2019  */
2020 void
2021 gst_audio_ring_buffer_set_channel_positions (GstAudioRingBuffer * buf,
2022     const GstAudioChannelPosition * position)
2023 {
2024   const GstAudioChannelPosition *to;
2025   gint channels;
2026   gint i;
2027 
2028   g_return_if_fail (GST_IS_AUDIO_RING_BUFFER (buf));
2029   g_return_if_fail (buf-&gt;acquired);
2030 
2031   channels = buf-&gt;spec.info.channels;
2032   to = buf-&gt;spec.info.position;
2033 
2034   if (memcmp (position, to, channels * sizeof (to[0])) == 0)
2035     return;
2036 
2037   if (position_less_channels (position, channels)) {
2038     GST_LOG_OBJECT (buf, &quot;position-less channels, no need to reorder&quot;);
2039     return;
2040   }
2041 
2042   buf-&gt;need_reorder = FALSE;
2043   if (!gst_audio_get_channel_reorder_map (channels, position, to,
2044           buf-&gt;channel_reorder_map))
2045     g_return_if_reached ();
2046 
2047   for (i = 0; i &lt; channels; i++) {
2048     if (buf-&gt;channel_reorder_map[i] != i) {
2049 #ifndef GST_DISABLE_GST_DEBUG
2050       {
2051         gchar *tmp1, *tmp2;
2052 
2053         tmp1 = gst_audio_channel_positions_to_string (position, channels);
2054         tmp2 = gst_audio_channel_positions_to_string (to, channels);
2055         GST_LOG_OBJECT (buf, &quot;may have to reorder channels: %s -&gt; %s&quot;, tmp1,
2056             tmp2);
2057         g_free (tmp1);
2058         g_free (tmp2);
2059       }
2060 #endif /* GST_DISABLE_GST_DEBUG */
2061 
2062       buf-&gt;need_reorder = TRUE;
2063       break;
2064     }
2065   }
2066 }
2067 
2068 /**
2069  * gst_ring_buffer_set_timestamp:
2070  * @buf: the #GstRingBuffer
2071  * @readseg: the current data segment
2072  * @timestamp: The new timestamp of the buffer.
2073  *
2074  * Set a new timestamp on the buffer.
2075  *
2076  * MT safe.
2077  */
2078 void
2079 gst_audio_ring_buffer_set_timestamp (GstAudioRingBuffer * buf, gint readseg,
2080     GstClockTime timestamp)
2081 {
2082   g_return_if_fail (GST_IS_AUDIO_RING_BUFFER (buf));
2083 
2084   GST_DEBUG_OBJECT (buf, &quot;Storing timestamp %&quot; GST_TIME_FORMAT
2085       &quot; @ %d&quot;, GST_TIME_ARGS (timestamp), readseg);
2086 
2087   GST_OBJECT_LOCK (buf);
2088   if (G_UNLIKELY (!buf-&gt;acquired))
2089     goto not_acquired;
2090 
2091   buf-&gt;timestamps[readseg] = timestamp;
2092 
2093 done:
2094   GST_OBJECT_UNLOCK (buf);
2095   return;
2096 
2097 not_acquired:
2098   {
2099     GST_DEBUG_OBJECT (buf, &quot;we are not acquired&quot;);
2100     goto done;
2101   }
2102 }
    </pre>
  </body>
</html>