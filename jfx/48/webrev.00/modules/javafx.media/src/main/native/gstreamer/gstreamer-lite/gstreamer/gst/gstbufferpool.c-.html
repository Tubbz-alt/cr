<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstbufferpool.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 2010 Wim Taymans &lt;wim.taymans@gmail.com&gt;
   3  *
   4  * gstbufferpool.c: GstBufferPool baseclass
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 /**
  23  * SECTION:gstbufferpool
  24  * @title: GstBufferPool
  25  * @short_description: Pool for buffers
  26  * @see_also: #GstBuffer
  27  *
  28  * A #GstBufferPool is an object that can be used to pre-allocate and recycle
  29  * buffers of the same size and with the same properties.
  30  *
  31  * A #GstBufferPool is created with gst_buffer_pool_new().
  32  *
  33  * Once a pool is created, it needs to be configured. A call to
  34  * gst_buffer_pool_get_config() returns the current configuration structure from
  35  * the pool. With gst_buffer_pool_config_set_params() and
  36  * gst_buffer_pool_config_set_allocator() the bufferpool parameters and
  37  * allocator can be configured. Other properties can be configured in the pool
  38  * depending on the pool implementation.
  39  *
  40  * A bufferpool can have extra options that can be enabled with
  41  * gst_buffer_pool_config_add_option(). The available options can be retrieved
  42  * with gst_buffer_pool_get_options(). Some options allow for additional
  43  * configuration properties to be set.
  44  *
  45  * After the configuration structure has been configured,
  46  * gst_buffer_pool_set_config() updates the configuration in the pool. This can
  47  * fail when the configuration structure is not accepted.
  48  *
  49  * After the a pool has been configured, it can be activated with
  50  * gst_buffer_pool_set_active(). This will preallocate the configured resources
  51  * in the pool.
  52  *
  53  * When the pool is active, gst_buffer_pool_acquire_buffer() can be used to
  54  * retrieve a buffer from the pool.
  55  *
  56  * Buffers allocated from a bufferpool will automatically be returned to the
  57  * pool with gst_buffer_pool_release_buffer() when their refcount drops to 0.
  58  *
  59  * The bufferpool can be deactivated again with gst_buffer_pool_set_active().
  60  * All further gst_buffer_pool_acquire_buffer() calls will return an error. When
  61  * all buffers are returned to the pool they will be freed.
  62  *
  63  * Use gst_object_unref() to release the reference to a bufferpool. If the
  64  * refcount of the pool reaches 0, the pool will be freed.
  65  */
  66 
  67 #include &quot;gst_private.h&quot;
  68 #include &quot;glib-compat-private.h&quot;
  69 
  70 #include &lt;errno.h&gt;
  71 #ifdef HAVE_UNISTD_H
  72 #  include &lt;unistd.h&gt;
  73 #endif
  74 #include &lt;sys/types.h&gt;
  75 
  76 #include &quot;gstatomicqueue.h&quot;
  77 #include &quot;gstpoll.h&quot;
  78 #include &quot;gstinfo.h&quot;
  79 #include &quot;gstquark.h&quot;
  80 #include &quot;gstvalue.h&quot;
  81 
  82 #include &quot;gstbufferpool.h&quot;
  83 
  84 #ifdef G_OS_WIN32
  85 #  ifndef EWOULDBLOCK
  86 #  define EWOULDBLOCK EAGAIN    /* This is just to placate gcc */
  87 #  endif
  88 #endif /* G_OS_WIN32 */
  89 
  90 GST_DEBUG_CATEGORY_STATIC (gst_buffer_pool_debug);
  91 #define GST_CAT_DEFAULT gst_buffer_pool_debug
  92 
  93 #define GST_BUFFER_POOL_GET_PRIVATE(obj)  \
  94    (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_BUFFER_POOL, GstBufferPoolPrivate))
  95 
  96 #define GST_BUFFER_POOL_LOCK(pool)   (g_rec_mutex_lock(&amp;pool-&gt;priv-&gt;rec_lock))
  97 #define GST_BUFFER_POOL_UNLOCK(pool) (g_rec_mutex_unlock(&amp;pool-&gt;priv-&gt;rec_lock))
  98 
  99 struct _GstBufferPoolPrivate
 100 {
 101   GstAtomicQueue *queue;
 102   GstPoll *poll;
 103 
 104   GRecMutex rec_lock;
 105 
 106   gboolean started;
 107   gboolean active;
 108   gint outstanding;             /* number of buffers that are in use */
 109 
 110   gboolean configured;
 111   GstStructure *config;
 112 
 113   guint size;
 114   guint min_buffers;
 115   guint max_buffers;
 116   guint cur_buffers;
 117   GstAllocator *allocator;
 118   GstAllocationParams params;
 119 };
 120 
 121 static void gst_buffer_pool_finalize (GObject * object);
 122 
 123 G_DEFINE_TYPE (GstBufferPool, gst_buffer_pool, GST_TYPE_OBJECT);
 124 
 125 static gboolean default_start (GstBufferPool * pool);
 126 static gboolean default_stop (GstBufferPool * pool);
 127 static gboolean default_set_config (GstBufferPool * pool,
 128     GstStructure * config);
 129 static GstFlowReturn default_alloc_buffer (GstBufferPool * pool,
 130     GstBuffer ** buffer, GstBufferPoolAcquireParams * params);
 131 static GstFlowReturn default_acquire_buffer (GstBufferPool * pool,
 132     GstBuffer ** buffer, GstBufferPoolAcquireParams * params);
 133 static void default_reset_buffer (GstBufferPool * pool, GstBuffer * buffer);
 134 static void default_free_buffer (GstBufferPool * pool, GstBuffer * buffer);
 135 static void default_release_buffer (GstBufferPool * pool, GstBuffer * buffer);
 136 
 137 static void
 138 gst_buffer_pool_class_init (GstBufferPoolClass * klass)
 139 {
 140   GObjectClass *gobject_class = (GObjectClass *) klass;
 141 
 142   g_type_class_add_private (klass, sizeof (GstBufferPoolPrivate));
 143 
 144   gobject_class-&gt;finalize = gst_buffer_pool_finalize;
 145 
 146   klass-&gt;start = default_start;
 147   klass-&gt;stop = default_stop;
 148   klass-&gt;set_config = default_set_config;
 149   klass-&gt;acquire_buffer = default_acquire_buffer;
 150   klass-&gt;reset_buffer = default_reset_buffer;
 151   klass-&gt;alloc_buffer = default_alloc_buffer;
 152   klass-&gt;release_buffer = default_release_buffer;
 153   klass-&gt;free_buffer = default_free_buffer;
 154 
 155   GST_DEBUG_CATEGORY_INIT (gst_buffer_pool_debug, &quot;bufferpool&quot;, 0,
 156       &quot;bufferpool debug&quot;);
 157 }
 158 
 159 static void
 160 gst_buffer_pool_init (GstBufferPool * pool)
 161 {
 162   GstBufferPoolPrivate *priv;
 163 
 164   priv = pool-&gt;priv = GST_BUFFER_POOL_GET_PRIVATE (pool);
 165 
 166   g_rec_mutex_init (&amp;priv-&gt;rec_lock);
 167 
 168   priv-&gt;poll = gst_poll_new_timer ();
 169   priv-&gt;queue = gst_atomic_queue_new (16);
 170   pool-&gt;flushing = 1;
 171   priv-&gt;active = FALSE;
 172   priv-&gt;configured = FALSE;
 173   priv-&gt;started = FALSE;
 174   priv-&gt;config = gst_structure_new_id_empty (GST_QUARK (BUFFER_POOL_CONFIG));
 175   gst_buffer_pool_config_set_params (priv-&gt;config, NULL, 0, 0, 0);
 176   priv-&gt;allocator = NULL;
 177   gst_allocation_params_init (&amp;priv-&gt;params);
 178   gst_buffer_pool_config_set_allocator (priv-&gt;config, priv-&gt;allocator,
 179       &amp;priv-&gt;params);
 180   /* 1 control write for flushing - the flush token */
 181   gst_poll_write_control (priv-&gt;poll);
 182   /* 1 control write for marking that we are not waiting for poll - the wait token */
 183   gst_poll_write_control (priv-&gt;poll);
 184 
 185   GST_DEBUG_OBJECT (pool, &quot;created&quot;);
 186 }
 187 
 188 static void
 189 gst_buffer_pool_finalize (GObject * object)
 190 {
 191   GstBufferPool *pool;
 192   GstBufferPoolPrivate *priv;
 193 
 194   pool = GST_BUFFER_POOL_CAST (object);
 195   priv = pool-&gt;priv;
 196 
 197   GST_DEBUG_OBJECT (pool, &quot;%p finalize&quot;, pool);
 198 
 199   gst_buffer_pool_set_active (pool, FALSE);
 200   gst_atomic_queue_unref (priv-&gt;queue);
 201   gst_poll_free (priv-&gt;poll);
 202   gst_structure_free (priv-&gt;config);
 203   g_rec_mutex_clear (&amp;priv-&gt;rec_lock);
 204   if (priv-&gt;allocator)
 205     gst_object_unref (priv-&gt;allocator);
 206 
 207   G_OBJECT_CLASS (gst_buffer_pool_parent_class)-&gt;finalize (object);
 208 }
 209 
 210 /**
 211  * gst_buffer_pool_new:
 212  *
 213  * Creates a new #GstBufferPool instance.
 214  *
 215  * Returns: (transfer full): a new #GstBufferPool instance
 216  */
 217 GstBufferPool *
 218 gst_buffer_pool_new (void)
 219 {
 220   GstBufferPool *result;
 221 
 222   result = g_object_new (GST_TYPE_BUFFER_POOL, NULL);
 223   GST_DEBUG_OBJECT (result, &quot;created new buffer pool&quot;);
 224 
 225   /* Clear floating flag */
 226   gst_object_ref_sink (result);
 227 
 228   return result;
 229 }
 230 
 231 static GstFlowReturn
 232 default_alloc_buffer (GstBufferPool * pool, GstBuffer ** buffer,
 233     GstBufferPoolAcquireParams * params)
 234 {
 235   GstBufferPoolPrivate *priv = pool-&gt;priv;
 236 
 237   *buffer =
 238       gst_buffer_new_allocate (priv-&gt;allocator, priv-&gt;size, &amp;priv-&gt;params);
 239 
 240   if (!*buffer)
 241     return GST_FLOW_ERROR;
 242 
 243   return GST_FLOW_OK;
 244 }
 245 
 246 static gboolean
 247 mark_meta_pooled (GstBuffer * buffer, GstMeta ** meta, gpointer user_data)
 248 {
 249   GST_DEBUG_OBJECT (GST_BUFFER_POOL (user_data),
 250       &quot;marking meta %p as POOLED in buffer %p&quot;, *meta, buffer);
 251   GST_META_FLAG_SET (*meta, GST_META_FLAG_POOLED);
 252   GST_META_FLAG_SET (*meta, GST_META_FLAG_LOCKED);
 253 
 254   return TRUE;
 255 }
 256 
 257 static GstFlowReturn
 258 do_alloc_buffer (GstBufferPool * pool, GstBuffer ** buffer,
 259     GstBufferPoolAcquireParams * params)
 260 {
 261   GstBufferPoolPrivate *priv = pool-&gt;priv;
 262   GstFlowReturn result;
 263   gint cur_buffers, max_buffers;
 264   GstBufferPoolClass *pclass;
 265 
 266   pclass = GST_BUFFER_POOL_GET_CLASS (pool);
 267 
 268   if (G_UNLIKELY (!pclass-&gt;alloc_buffer))
 269     goto no_function;
 270 
 271   max_buffers = priv-&gt;max_buffers;
 272 
 273   /* increment the allocation counter */
 274   cur_buffers = g_atomic_int_add (&amp;priv-&gt;cur_buffers, 1);
 275   if (max_buffers &amp;&amp; cur_buffers &gt;= max_buffers)
 276     goto max_reached;
 277 
 278   result = pclass-&gt;alloc_buffer (pool, buffer, params);
 279   if (G_UNLIKELY (result != GST_FLOW_OK))
 280     goto alloc_failed;
 281 
 282   /* lock all metadata and mark as pooled, we want this to remain on
 283    * the buffer and we want to remove any other metadata that gets added
 284    * later */
 285   gst_buffer_foreach_meta (*buffer, mark_meta_pooled, pool);
 286 
 287   /* un-tag memory, this is how we expect the buffer when it is
 288    * released again */
 289   GST_BUFFER_FLAG_UNSET (*buffer, GST_BUFFER_FLAG_TAG_MEMORY);
 290 
 291   GST_LOG_OBJECT (pool, &quot;allocated buffer %d/%d, %p&quot;, cur_buffers,
 292       max_buffers, *buffer);
 293 
 294   return result;
 295 
 296   /* ERRORS */
 297 no_function:
 298   {
 299     GST_ERROR_OBJECT (pool, &quot;no alloc function&quot;);
 300     return GST_FLOW_NOT_SUPPORTED;
 301   }
 302 max_reached:
 303   {
 304     GST_DEBUG_OBJECT (pool, &quot;max buffers reached&quot;);
 305     g_atomic_int_add (&amp;priv-&gt;cur_buffers, -1);
 306     return GST_FLOW_EOS;
 307   }
 308 alloc_failed:
 309   {
 310     GST_WARNING_OBJECT (pool, &quot;alloc function failed&quot;);
 311     g_atomic_int_add (&amp;priv-&gt;cur_buffers, -1);
 312     return result;
 313   }
 314 }
 315 
 316 /* the default implementation for preallocating the buffers in the pool */
 317 static gboolean
 318 default_start (GstBufferPool * pool)
 319 {
 320   guint i;
 321   GstBufferPoolPrivate *priv = pool-&gt;priv;
 322   GstBufferPoolClass *pclass;
 323 
 324   pclass = GST_BUFFER_POOL_GET_CLASS (pool);
 325 
 326   /* we need to prealloc buffers */
 327   for (i = 0; i &lt; priv-&gt;min_buffers; i++) {
 328     GstBuffer *buffer;
 329 
 330     if (do_alloc_buffer (pool, &amp;buffer, NULL) != GST_FLOW_OK)
 331       goto alloc_failed;
 332 
 333     /* release to the queue, we call the vmethod directly, we don&#39;t need to do
 334      * the other refcount handling right now. */
 335     if (G_LIKELY (pclass-&gt;release_buffer))
 336       pclass-&gt;release_buffer (pool, buffer);
 337   }
 338   return TRUE;
 339 
 340   /* ERRORS */
 341 alloc_failed:
 342   {
 343     GST_WARNING_OBJECT (pool, &quot;failed to allocate buffer&quot;);
 344     return FALSE;
 345   }
 346 }
 347 
 348 /* must be called with the lock */
 349 static gboolean
 350 do_start (GstBufferPool * pool)
 351 {
 352   GstBufferPoolPrivate *priv = pool-&gt;priv;
 353 
 354   if (!priv-&gt;started) {
 355     GstBufferPoolClass *pclass;
 356 
 357     pclass = GST_BUFFER_POOL_GET_CLASS (pool);
 358 
 359     GST_LOG_OBJECT (pool, &quot;starting&quot;);
 360     /* start the pool, subclasses should allocate buffers and put them
 361      * in the queue */
 362     if (G_LIKELY (pclass-&gt;start)) {
 363       if (!pclass-&gt;start (pool))
 364         return FALSE;
 365     }
 366     priv-&gt;started = TRUE;
 367   }
 368   return TRUE;
 369 }
 370 
 371 static void
 372 default_free_buffer (GstBufferPool * pool, GstBuffer * buffer)
 373 {
 374   gst_buffer_unref (buffer);
 375 }
 376 
 377 static void
 378 do_free_buffer (GstBufferPool * pool, GstBuffer * buffer)
 379 {
 380   GstBufferPoolPrivate *priv;
 381   GstBufferPoolClass *pclass;
 382 
 383   priv = pool-&gt;priv;
 384   pclass = GST_BUFFER_POOL_GET_CLASS (pool);
 385 
 386   g_atomic_int_add (&amp;priv-&gt;cur_buffers, -1);
 387   GST_LOG_OBJECT (pool, &quot;freeing buffer %p (%u left)&quot;, buffer,
 388       priv-&gt;cur_buffers);
 389 
 390   if (G_LIKELY (pclass-&gt;free_buffer))
 391     pclass-&gt;free_buffer (pool, buffer);
 392 }
 393 
 394 /* must be called with the lock */
 395 static gboolean
 396 default_stop (GstBufferPool * pool)
 397 {
 398   GstBufferPoolPrivate *priv = pool-&gt;priv;
 399   GstBuffer *buffer;
 400 
 401   /* clear the pool */
 402   while ((buffer = gst_atomic_queue_pop (priv-&gt;queue))) {
 403     while (!gst_poll_read_control (priv-&gt;poll)) {
 404       if (errno == EWOULDBLOCK) {
 405         /* We put the buffer into the queue but did not finish writing control
 406          * yet, let&#39;s wait a bit and retry */
 407         g_thread_yield ();
 408         continue;
 409       } else {
 410         /* Critical error but GstPoll already complained */
 411         break;
 412       }
 413     }
 414     do_free_buffer (pool, buffer);
 415   }
 416   return priv-&gt;cur_buffers == 0;
 417 }
 418 
 419 /* must be called with the lock */
 420 static gboolean
 421 do_stop (GstBufferPool * pool)
 422 {
 423   GstBufferPoolPrivate *priv = pool-&gt;priv;
 424 
 425   if (priv-&gt;started) {
 426     GstBufferPoolClass *pclass;
 427 
 428     pclass = GST_BUFFER_POOL_GET_CLASS (pool);
 429 
 430     GST_LOG_OBJECT (pool, &quot;stopping&quot;);
 431     if (G_LIKELY (pclass-&gt;stop)) {
 432       if (!pclass-&gt;stop (pool))
 433         return FALSE;
 434     }
 435     priv-&gt;started = FALSE;
 436   }
 437   return TRUE;
 438 }
 439 
 440 /* must be called with the lock */
 441 static void
 442 do_set_flushing (GstBufferPool * pool, gboolean flushing)
 443 {
 444   GstBufferPoolPrivate *priv = pool-&gt;priv;
 445   GstBufferPoolClass *pclass;
 446 
 447   pclass = GST_BUFFER_POOL_GET_CLASS (pool);
 448 
 449   if (GST_BUFFER_POOL_IS_FLUSHING (pool) == flushing)
 450     return;
 451 
 452   if (flushing) {
 453     g_atomic_int_set (&amp;pool-&gt;flushing, 1);
 454     /* Write the flush token to wake up any waiters */
 455     gst_poll_write_control (priv-&gt;poll);
 456 
 457     if (pclass-&gt;flush_start)
 458       pclass-&gt;flush_start (pool);
 459   } else {
 460     if (pclass-&gt;flush_stop)
 461       pclass-&gt;flush_stop (pool);
 462 
 463     while (!gst_poll_read_control (priv-&gt;poll)) {
 464       if (errno == EWOULDBLOCK) {
 465         /* This should not really happen unless flushing and unflushing
 466          * happens on different threads. Let&#39;s wait a bit to get back flush
 467          * token from the thread that was setting it to flushing */
 468         g_thread_yield ();
 469         continue;
 470       } else {
 471         /* Critical error but GstPoll already complained */
 472         break;
 473       }
 474     }
 475 
 476     g_atomic_int_set (&amp;pool-&gt;flushing, 0);
 477   }
 478 }
 479 
 480 /**
 481  * gst_buffer_pool_set_active:
 482  * @pool: a #GstBufferPool
 483  * @active: the new active state
 484  *
 485  * Control the active state of @pool. When the pool is inactive, new calls to
 486  * gst_buffer_pool_acquire_buffer() will return with %GST_FLOW_FLUSHING.
 487  *
 488  * Activating the bufferpool will preallocate all resources in the pool based on
 489  * the configuration of the pool.
 490  *
 491  * Deactivating will free the resources again when there are no outstanding
 492  * buffers. When there are outstanding buffers, they will be freed as soon as
 493  * they are all returned to the pool.
 494  *
 495  * Returns: %FALSE when the pool was not configured or when preallocation of the
 496  * buffers failed.
 497  */
 498 gboolean
 499 gst_buffer_pool_set_active (GstBufferPool * pool, gboolean active)
 500 {
 501   gboolean res = TRUE;
 502   GstBufferPoolPrivate *priv;
 503 
 504   g_return_val_if_fail (GST_IS_BUFFER_POOL (pool), FALSE);
 505 
 506   GST_LOG_OBJECT (pool, &quot;active %d&quot;, active);
 507 
 508   priv = pool-&gt;priv;
 509 
 510   GST_BUFFER_POOL_LOCK (pool);
 511   /* just return if we are already in the right state */
 512   if (priv-&gt;active == active)
 513     goto was_ok;
 514 
 515   /* we need to be configured */
 516   if (!priv-&gt;configured)
 517     goto not_configured;
 518 
 519   if (active) {
 520     if (!do_start (pool))
 521       goto start_failed;
 522 
 523     /* flush_stop my release buffers, setting to active to avoid running
 524      * do_stop while activating the pool */
 525     priv-&gt;active = TRUE;
 526 
 527     /* unset the flushing state now */
 528     do_set_flushing (pool, FALSE);
 529   } else {
 530     gint outstanding;
 531 
 532     /* set to flushing first */
 533     do_set_flushing (pool, TRUE);
 534 
 535     /* when all buffers are in the pool, free them. Else they will be
 536      * freed when they are released */
 537     outstanding = g_atomic_int_get (&amp;priv-&gt;outstanding);
 538     GST_LOG_OBJECT (pool, &quot;outstanding buffers %d&quot;, outstanding);
 539     if (outstanding == 0) {
 540       if (!do_stop (pool))
 541         goto stop_failed;
 542     }
 543 
 544     priv-&gt;active = FALSE;
 545   }
 546   GST_BUFFER_POOL_UNLOCK (pool);
 547 
 548   return res;
 549 
 550 was_ok:
 551   {
 552     GST_DEBUG_OBJECT (pool, &quot;pool was in the right state&quot;);
 553     GST_BUFFER_POOL_UNLOCK (pool);
 554     return TRUE;
 555   }
 556 not_configured:
 557   {
 558     GST_ERROR_OBJECT (pool, &quot;pool was not configured&quot;);
 559     GST_BUFFER_POOL_UNLOCK (pool);
 560     return FALSE;
 561   }
 562 start_failed:
 563   {
 564     GST_ERROR_OBJECT (pool, &quot;start failed&quot;);
 565     GST_BUFFER_POOL_UNLOCK (pool);
 566     return FALSE;
 567   }
 568 stop_failed:
 569   {
 570     GST_WARNING_OBJECT (pool, &quot;stop failed&quot;);
 571     GST_BUFFER_POOL_UNLOCK (pool);
 572     return FALSE;
 573   }
 574 }
 575 
 576 /**
 577  * gst_buffer_pool_is_active:
 578  * @pool: a #GstBufferPool
 579  *
 580  * Check if @pool is active. A pool can be activated with the
 581  * gst_buffer_pool_set_active() call.
 582  *
 583  * Returns: %TRUE when the pool is active.
 584  */
 585 gboolean
 586 gst_buffer_pool_is_active (GstBufferPool * pool)
 587 {
 588   gboolean res;
 589 
 590   GST_BUFFER_POOL_LOCK (pool);
 591   res = pool-&gt;priv-&gt;active;
 592   GST_BUFFER_POOL_UNLOCK (pool);
 593 
 594   return res;
 595 }
 596 
 597 static gboolean
 598 default_set_config (GstBufferPool * pool, GstStructure * config)
 599 {
 600   GstBufferPoolPrivate *priv = pool-&gt;priv;
 601   GstCaps *caps;
 602   guint size, min_buffers, max_buffers;
 603   GstAllocator *allocator;
 604   GstAllocationParams params;
 605 
 606   /* parse the config and keep around */
 607   if (!gst_buffer_pool_config_get_params (config, &amp;caps, &amp;size, &amp;min_buffers,
 608           &amp;max_buffers))
 609     goto wrong_config;
 610 
 611   if (!gst_buffer_pool_config_get_allocator (config, &amp;allocator, &amp;params))
 612     goto wrong_config;
 613 
 614   GST_DEBUG_OBJECT (pool, &quot;config %&quot; GST_PTR_FORMAT, config);
 615 
 616   priv-&gt;size = size;
 617   priv-&gt;min_buffers = min_buffers;
 618   priv-&gt;max_buffers = max_buffers;
 619   priv-&gt;cur_buffers = 0;
 620 
 621   if (priv-&gt;allocator)
 622     gst_object_unref (priv-&gt;allocator);
 623   if ((priv-&gt;allocator = allocator))
 624     gst_object_ref (allocator);
 625   priv-&gt;params = params;
 626 
 627   return TRUE;
 628 
 629 wrong_config:
 630   {
 631     GST_WARNING_OBJECT (pool, &quot;invalid config %&quot; GST_PTR_FORMAT, config);
 632     return FALSE;
 633   }
 634 }
 635 
 636 /**
 637  * gst_buffer_pool_set_config:
 638  * @pool: a #GstBufferPool
 639  * @config: (transfer full): a #GstStructure
 640  *
 641  * Set the configuration of the pool. If the pool is already configured, and
 642  * the configuration haven&#39;t change, this function will return %TRUE. If the
 643  * pool is active, this method will return %FALSE and active configuration
 644  * will remain. Buffers allocated form this pool must be returned or else this
 645  * function will do nothing and return %FALSE.
 646  *
 647  * @config is a #GstStructure that contains the configuration parameters for
 648  * the pool. A default and mandatory set of parameters can be configured with
 649  * gst_buffer_pool_config_set_params(), gst_buffer_pool_config_set_allocator()
 650  * and gst_buffer_pool_config_add_option().
 651  *
 652  * If the parameters in @config can not be set exactly, this function returns
 653  * %FALSE and will try to update as much state as possible. The new state can
 654  * then be retrieved and refined with gst_buffer_pool_get_config().
 655  *
 656  * This function takes ownership of @config.
 657  *
 658  * Returns: %TRUE when the configuration could be set.
 659  */
 660 gboolean
 661 gst_buffer_pool_set_config (GstBufferPool * pool, GstStructure * config)
 662 {
 663   gboolean result;
 664   GstBufferPoolClass *pclass;
 665   GstBufferPoolPrivate *priv;
 666 
 667   g_return_val_if_fail (GST_IS_BUFFER_POOL (pool), FALSE);
 668   g_return_val_if_fail (config != NULL, FALSE);
 669 
 670   priv = pool-&gt;priv;
 671 
 672   GST_BUFFER_POOL_LOCK (pool);
 673 
 674   /* nothing to do if config is unchanged */
 675   if (priv-&gt;configured &amp;&amp; gst_structure_is_equal (config, priv-&gt;config))
 676     goto config_unchanged;
 677 
 678   /* can&#39;t change the settings when active */
 679     if (priv-&gt;active)
 680       goto was_active;
 681 
 682   /* we can&#39;t change when outstanding buffers */
 683   if (g_atomic_int_get (&amp;priv-&gt;outstanding) != 0)
 684     goto have_outstanding;
 685 
 686   pclass = GST_BUFFER_POOL_GET_CLASS (pool);
 687 
 688   /* set the new config */
 689   if (G_LIKELY (pclass-&gt;set_config))
 690     result = pclass-&gt;set_config (pool, config);
 691   else
 692     result = FALSE;
 693 
 694   /* save the config regardless of the result so user can read back the
 695    * modified config and evaluate if the changes are acceptable */
 696   if (priv-&gt;config)
 697     gst_structure_free (priv-&gt;config);
 698   priv-&gt;config = config;
 699 
 700   if (result) {
 701     /* now we are configured */
 702     priv-&gt;configured = TRUE;
 703   }
 704   GST_BUFFER_POOL_UNLOCK (pool);
 705 
 706   return result;
 707 
 708 config_unchanged:
 709   {
 710     gst_structure_free (config);
 711     GST_BUFFER_POOL_UNLOCK (pool);
 712     return TRUE;
 713   }
 714   /* ERRORS */
 715 was_active:
 716   {
 717     gst_structure_free (config);
 718     GST_INFO_OBJECT (pool, &quot;can&#39;t change config, we are active&quot;);
 719     GST_BUFFER_POOL_UNLOCK (pool);
 720     return FALSE;
 721   }
 722 have_outstanding:
 723   {
 724     gst_structure_free (config);
 725     GST_WARNING_OBJECT (pool, &quot;can&#39;t change config, have outstanding buffers&quot;);
 726     GST_BUFFER_POOL_UNLOCK (pool);
 727     return FALSE;
 728   }
 729 }
 730 
 731 /**
 732  * gst_buffer_pool_get_config:
 733  * @pool: a #GstBufferPool
 734  *
 735  * Get a copy of the current configuration of the pool. This configuration
 736  * can either be modified and used for the gst_buffer_pool_set_config() call
 737  * or it must be freed after usage.
 738  *
 739  * Returns: (transfer full): a copy of the current configuration of @pool. use
 740  * gst_structure_free() after usage or gst_buffer_pool_set_config().
 741  */
 742 GstStructure *
 743 gst_buffer_pool_get_config (GstBufferPool * pool)
 744 {
 745   GstStructure *result;
 746 
 747   g_return_val_if_fail (GST_IS_BUFFER_POOL (pool), NULL);
 748 
 749   GST_BUFFER_POOL_LOCK (pool);
 750   result = gst_structure_copy (pool-&gt;priv-&gt;config);
 751   GST_BUFFER_POOL_UNLOCK (pool);
 752 
 753   return result;
 754 }
 755 
 756 static const gchar *empty_option[] = { NULL };
 757 
 758 /**
 759  * gst_buffer_pool_get_options:
 760  * @pool: a #GstBufferPool
 761  *
 762  * Get a %NULL terminated array of string with supported bufferpool options for
 763  * @pool. An option would typically be enabled with
 764  * gst_buffer_pool_config_add_option().
 765  *
 766  * Returns: (array zero-terminated=1) (transfer none): a %NULL terminated array
 767  *          of strings.
 768  */
 769 const gchar **
 770 gst_buffer_pool_get_options (GstBufferPool * pool)
 771 {
 772   GstBufferPoolClass *pclass;
 773   const gchar **result;
 774 
 775   g_return_val_if_fail (GST_IS_BUFFER_POOL (pool), NULL);
 776 
 777   pclass = GST_BUFFER_POOL_GET_CLASS (pool);
 778 
 779   if (G_LIKELY (pclass-&gt;get_options)) {
 780     if ((result = pclass-&gt;get_options (pool)) == NULL)
 781       goto invalid_result;
 782   } else
 783     result = empty_option;
 784 
 785   return result;
 786 
 787   /* ERROR */
 788 invalid_result:
 789   {
 790     g_warning (&quot;bufferpool subclass returned NULL options&quot;);
 791     return empty_option;
 792   }
 793 }
 794 
 795 /**
 796  * gst_buffer_pool_has_option:
 797  * @pool: a #GstBufferPool
 798  * @option: an option
 799  *
 800  * Check if the bufferpool supports @option.
 801  *
 802  * Returns: %TRUE if the buffer pool contains @option.
 803  */
 804 gboolean
 805 gst_buffer_pool_has_option (GstBufferPool * pool, const gchar * option)
 806 {
 807   guint i;
 808   const gchar **options;
 809 
 810   g_return_val_if_fail (GST_IS_BUFFER_POOL (pool), FALSE);
 811   g_return_val_if_fail (option != NULL, FALSE);
 812 
 813   options = gst_buffer_pool_get_options (pool);
 814 
 815   for (i = 0; options[i]; i++) {
 816     if (g_str_equal (options[i], option))
 817       return TRUE;
 818   }
 819   return FALSE;
 820 }
 821 
 822 /**
 823  * gst_buffer_pool_config_set_params:
 824  * @config: a #GstBufferPool configuration
 825  * @caps: caps for the buffers
 826  * @size: the size of each buffer, not including prefix and padding
 827  * @min_buffers: the minimum amount of buffers to allocate.
 828  * @max_buffers: the maximum amount of buffers to allocate or 0 for unlimited.
 829  *
 830  * Configure @config with the given parameters.
 831  */
 832 void
 833 gst_buffer_pool_config_set_params (GstStructure * config, GstCaps * caps,
 834     guint size, guint min_buffers, guint max_buffers)
 835 {
 836   g_return_if_fail (config != NULL);
 837   g_return_if_fail (max_buffers == 0 || min_buffers &lt;= max_buffers);
 838   g_return_if_fail (caps == NULL || gst_caps_is_fixed (caps));
 839 
 840   gst_structure_id_set (config,
 841       GST_QUARK (CAPS), GST_TYPE_CAPS, caps,
 842       GST_QUARK (SIZE), G_TYPE_UINT, size,
 843       GST_QUARK (MIN_BUFFERS), G_TYPE_UINT, min_buffers,
 844       GST_QUARK (MAX_BUFFERS), G_TYPE_UINT, max_buffers, NULL);
 845 }
 846 
 847 /**
 848  * gst_buffer_pool_config_set_allocator:
 849  * @config: a #GstBufferPool configuration
 850  * @allocator: (allow-none): a #GstAllocator
 851  * @params: (allow-none): #GstAllocationParams
 852  *
 853  * Set the @allocator and @params on @config.
 854  *
 855  * One of @allocator and @params can be %NULL, but not both. When @allocator
 856  * is %NULL, the default allocator of the pool will use the values in @param
 857  * to perform its allocation. When @param is %NULL, the pool will use the
 858  * provided @allocator with its default #GstAllocationParams.
 859  *
 860  * A call to gst_buffer_pool_set_config() can update the allocator and params
 861  * with the values that it is able to do. Some pools are, for example, not able
 862  * to operate with different allocators or cannot allocate with the values
 863  * specified in @params. Use gst_buffer_pool_get_config() to get the currently
 864  * used values.
 865  */
 866 void
 867 gst_buffer_pool_config_set_allocator (GstStructure * config,
 868     GstAllocator * allocator, const GstAllocationParams * params)
 869 {
 870   g_return_if_fail (config != NULL);
 871   g_return_if_fail (allocator != NULL || params != NULL);
 872 
 873   gst_structure_id_set (config,
 874       GST_QUARK (ALLOCATOR), GST_TYPE_ALLOCATOR, allocator,
 875       GST_QUARK (PARAMS), GST_TYPE_ALLOCATION_PARAMS, params, NULL);
 876 }
 877 
 878 /**
 879  * gst_buffer_pool_config_add_option:
 880  * @config: a #GstBufferPool configuration
 881  * @option: an option to add
 882  *
 883  * Enabled the option in @config. This will instruct the @bufferpool to enable
 884  * the specified option on the buffers that it allocates.
 885  *
 886  * The supported options by @pool can be retrieved with gst_buffer_pool_get_options().
 887  */
 888 void
 889 gst_buffer_pool_config_add_option (GstStructure * config, const gchar * option)
 890 {
 891   const GValue *value;
 892   GValue option_value = { 0, };
 893   guint i, len;
 894 
 895   g_return_if_fail (config != NULL);
 896 
 897   value = gst_structure_id_get_value (config, GST_QUARK (OPTIONS));
 898   if (value) {
 899     len = gst_value_array_get_size (value);
 900     for (i = 0; i &lt; len; ++i) {
 901       const GValue *nth_val = gst_value_array_get_value (value, i);
 902 
 903       if (g_str_equal (option, g_value_get_string (nth_val)))
 904         return;
 905     }
 906   } else {
 907     GValue new_array_val = { 0, };
 908 
 909     g_value_init (&amp;new_array_val, GST_TYPE_ARRAY);
 910     gst_structure_id_take_value (config, GST_QUARK (OPTIONS), &amp;new_array_val);
 911     value = gst_structure_id_get_value (config, GST_QUARK (OPTIONS));
 912   }
 913   g_value_init (&amp;option_value, G_TYPE_STRING);
 914   g_value_set_string (&amp;option_value, option);
 915   gst_value_array_append_and_take_value ((GValue *) value, &amp;option_value);
 916 }
 917 
 918 /**
 919  * gst_buffer_pool_config_n_options:
 920  * @config: a #GstBufferPool configuration
 921  *
 922  * Retrieve the number of values currently stored in the options array of the
 923  * @config structure.
 924  *
 925  * Returns: the options array size as a #guint.
 926  */
 927 guint
 928 gst_buffer_pool_config_n_options (GstStructure * config)
 929 {
 930   const GValue *value;
 931   guint size = 0;
 932 
 933   g_return_val_if_fail (config != NULL, 0);
 934 
 935   value = gst_structure_id_get_value (config, GST_QUARK (OPTIONS));
 936   if (value) {
 937     size = gst_value_array_get_size (value);
 938   }
 939   return size;
 940 }
 941 
 942 /**
 943  * gst_buffer_pool_config_get_option:
 944  * @config: a #GstBufferPool configuration
 945  * @index: position in the option array to read
 946  *
 947  * Parse an available @config and get the option at @index of the options API
 948  * array.
 949  *
 950  * Returns: a #gchar of the option at @index.
 951  */
 952 const gchar *
 953 gst_buffer_pool_config_get_option (GstStructure * config, guint index)
 954 {
 955   const GValue *value;
 956   const gchar *ret = NULL;
 957 
 958   g_return_val_if_fail (config != NULL, 0);
 959 
 960   value = gst_structure_id_get_value (config, GST_QUARK (OPTIONS));
 961   if (value) {
 962     const GValue *option_value;
 963 
 964     option_value = gst_value_array_get_value (value, index);
 965     if (option_value)
 966       ret = g_value_get_string (option_value);
 967   }
 968   return ret;
 969 }
 970 
 971 /**
 972  * gst_buffer_pool_config_has_option:
 973  * @config: a #GstBufferPool configuration
 974  * @option: an option
 975  *
 976  * Check if @config contains @option.
 977  *
 978  * Returns: %TRUE if the options array contains @option.
 979  */
 980 gboolean
 981 gst_buffer_pool_config_has_option (GstStructure * config, const gchar * option)
 982 {
 983   const GValue *value;
 984   guint i, len;
 985 
 986   g_return_val_if_fail (config != NULL, 0);
 987 
 988   value = gst_structure_id_get_value (config, GST_QUARK (OPTIONS));
 989   if (value) {
 990     len = gst_value_array_get_size (value);
 991     for (i = 0; i &lt; len; ++i) {
 992       const GValue *nth_val = gst_value_array_get_value (value, i);
 993 
 994       if (g_str_equal (option, g_value_get_string (nth_val)))
 995         return TRUE;
 996     }
 997   }
 998   return FALSE;
 999 }
1000 
1001 /**
1002  * gst_buffer_pool_config_get_params:
1003  * @config: (transfer none): a #GstBufferPool configuration
1004  * @caps: (out) (transfer none) (allow-none): the caps of buffers
1005  * @size: (out) (allow-none): the size of each buffer, not including prefix and padding
1006  * @min_buffers: (out) (allow-none): the minimum amount of buffers to allocate.
1007  * @max_buffers: (out) (allow-none): the maximum amount of buffers to allocate or 0 for unlimited.
1008  *
1009  * Get the configuration values from @config.
1010  *
1011  * Returns: %TRUE if all parameters could be fetched.
1012  */
1013 gboolean
1014 gst_buffer_pool_config_get_params (GstStructure * config, GstCaps ** caps,
1015     guint * size, guint * min_buffers, guint * max_buffers)
1016 {
1017   g_return_val_if_fail (config != NULL, FALSE);
1018 
1019   if (caps) {
1020     *caps = g_value_get_boxed (gst_structure_id_get_value (config,
1021             GST_QUARK (CAPS)));
1022   }
1023   return gst_structure_id_get (config,
1024       GST_QUARK (SIZE), G_TYPE_UINT, size,
1025       GST_QUARK (MIN_BUFFERS), G_TYPE_UINT, min_buffers,
1026       GST_QUARK (MAX_BUFFERS), G_TYPE_UINT, max_buffers, NULL);
1027 }
1028 
1029 /**
1030  * gst_buffer_pool_config_get_allocator:
1031  * @config: (transfer none): a #GstBufferPool configuration
1032  * @allocator: (out) (allow-none) (transfer none): a #GstAllocator, or %NULL
1033  * @params: (out) (allow-none): #GstAllocationParams, or %NULL
1034  *
1035  * Get the @allocator and @params from @config.
1036  *
1037  * Returns: %TRUE, if the values are set.
1038  */
1039 gboolean
1040 gst_buffer_pool_config_get_allocator (GstStructure * config,
1041     GstAllocator ** allocator, GstAllocationParams * params)
1042 {
1043   g_return_val_if_fail (config != NULL, FALSE);
1044 
1045   if (allocator)
1046     *allocator = g_value_get_object (gst_structure_id_get_value (config,
1047             GST_QUARK (ALLOCATOR)));
1048   if (params) {
1049     GstAllocationParams *p;
1050 
1051     p = g_value_get_boxed (gst_structure_id_get_value (config,
1052             GST_QUARK (PARAMS)));
1053     if (p) {
1054       *params = *p;
1055     } else {
1056       gst_allocation_params_init (params);
1057     }
1058   }
1059   return TRUE;
1060 }
1061 
1062 /**
1063  * gst_buffer_pool_config_validate_params:
1064  * @config: (transfer none): a #GstBufferPool configuration
1065  * @caps: (transfer none): the excepted caps of buffers
1066  * @size: the expected size of each buffer, not including prefix and padding
1067  * @min_buffers: the expected minimum amount of buffers to allocate.
1068  * @max_buffers: the expect maximum amount of buffers to allocate or 0 for unlimited.
1069  *
1070  * Validate that changes made to @config are still valid in the context of the
1071  * expected parameters. This function is a helper that can be used to validate
1072  * changes made by a pool to a config when gst_buffer_pool_set_config()
1073  * returns %FALSE. This expects that @caps haven&#39;t changed and that
1074  * @min_buffers aren&#39;t lower then what we initially expected.
1075  * This does not check if options or allocator parameters are still valid,
1076  * won&#39;t check if size have changed, since changing the size is valid to adapt
1077  * padding.
1078  *
1079  * Since: 1.4
1080  *
1081  * Returns: %TRUE, if the parameters are valid in this context.
1082  */
1083 gboolean
1084 gst_buffer_pool_config_validate_params (GstStructure * config, GstCaps * caps,
1085     guint size, guint min_buffers, G_GNUC_UNUSED guint max_buffers)
1086 {
1087   GstCaps *newcaps;
1088   guint newsize, newmin;
1089   gboolean ret = FALSE;
1090 
1091   g_return_val_if_fail (config != NULL, FALSE);
1092 
1093   gst_buffer_pool_config_get_params (config, &amp;newcaps, &amp;newsize, &amp;newmin, NULL);
1094 
1095   if (gst_caps_is_equal (caps, newcaps) &amp;&amp; (newsize &gt;= size)
1096       &amp;&amp; (newmin &gt;= min_buffers))
1097     ret = TRUE;
1098 
1099   return ret;
1100 }
1101 
1102 static GstFlowReturn
1103 default_acquire_buffer (GstBufferPool * pool, GstBuffer ** buffer,
1104     GstBufferPoolAcquireParams * params)
1105 {
1106   GstFlowReturn result;
1107   GstBufferPoolPrivate *priv = pool-&gt;priv;
1108 
1109   while (TRUE) {
1110     if (G_UNLIKELY (GST_BUFFER_POOL_IS_FLUSHING (pool)))
1111       goto flushing;
1112 
1113     /* try to get a buffer from the queue */
1114     *buffer = gst_atomic_queue_pop (priv-&gt;queue);
1115     if (G_LIKELY (*buffer)) {
1116       while (!gst_poll_read_control (priv-&gt;poll)) {
1117         if (errno == EWOULDBLOCK) {
1118           /* We put the buffer into the queue but did not finish writing control
1119            * yet, let&#39;s wait a bit and retry */
1120           g_thread_yield ();
1121           continue;
1122         } else {
1123           /* Critical error but GstPoll already complained */
1124           break;
1125         }
1126       }
1127       result = GST_FLOW_OK;
1128       GST_LOG_OBJECT (pool, &quot;acquired buffer %p&quot;, *buffer);
1129       break;
1130     }
1131 
1132     /* no buffer, try to allocate some more */
1133     GST_LOG_OBJECT (pool, &quot;no buffer, trying to allocate&quot;);
1134     result = do_alloc_buffer (pool, buffer, params);
1135     if (G_LIKELY (result == GST_FLOW_OK))
1136       /* we have a buffer, return it */
1137       break;
1138 
1139     if (G_UNLIKELY (result != GST_FLOW_EOS))
1140       /* something went wrong, return error */
1141       break;
1142 
1143     /* check if we need to wait */
1144     if (params &amp;&amp; (params-&gt;flags &amp; GST_BUFFER_POOL_ACQUIRE_FLAG_DONTWAIT)) {
1145       GST_LOG_OBJECT (pool, &quot;no more buffers&quot;);
1146       break;
1147     }
1148 
1149     /* now we release the control socket, we wait for a buffer release or
1150      * flushing */
1151     if (!gst_poll_read_control (pool-&gt;priv-&gt;poll)) {
1152       if (errno == EWOULDBLOCK) {
1153         /* This means that we have two threads trying to allocate buffers
1154          * already, and the other one already got the wait token. This
1155          * means that we only have to wait for the poll now and not write the
1156          * token afterwards: we will be woken up once the other thread is
1157          * woken up and that one will write the wait token it removed */
1158     GST_LOG_OBJECT (pool, &quot;waiting for free buffers or flushing&quot;);
1159     gst_poll_wait (priv-&gt;poll, GST_CLOCK_TIME_NONE);
1160       } else {
1161         /* This is a critical error, GstPoll already gave a warning */
1162         result = GST_FLOW_ERROR;
1163         break;
1164       }
1165     } else {
1166       /* We&#39;re the first thread waiting, we got the wait token and have to
1167        * write it again later
1168        * OR
1169        * We&#39;re a second thread and just consumed the flush token and block all
1170        * other threads, in which case we must not wait and give it back
1171        * immediately */
1172       if (!GST_BUFFER_POOL_IS_FLUSHING (pool)) {
1173         GST_LOG_OBJECT (pool, &quot;waiting for free buffers or flushing&quot;);
1174         gst_poll_wait (priv-&gt;poll, GST_CLOCK_TIME_NONE);
1175       }
1176     gst_poll_write_control (pool-&gt;priv-&gt;poll);
1177   }
1178   }
1179 
1180   return result;
1181 
1182   /* ERRORS */
1183 flushing:
1184   {
1185     GST_DEBUG_OBJECT (pool, &quot;we are flushing&quot;);
1186     return GST_FLOW_FLUSHING;
1187   }
1188 }
1189 
1190 static inline void
1191 dec_outstanding (GstBufferPool * pool)
1192 {
1193   if (g_atomic_int_dec_and_test (&amp;pool-&gt;priv-&gt;outstanding)) {
1194     /* all buffers are returned to the pool, see if we need to free them */
1195     if (GST_BUFFER_POOL_IS_FLUSHING (pool)) {
1196       /* take the lock so that set_active is not run concurrently */
1197       GST_BUFFER_POOL_LOCK (pool);
1198       /* now that we have the lock, check if we have been de-activated with
1199        * outstanding buffers */
1200       if (!pool-&gt;priv-&gt;active)
1201         do_stop (pool);
1202 
1203       GST_BUFFER_POOL_UNLOCK (pool);
1204     }
1205   }
1206 }
1207 
1208 static gboolean
1209 remove_meta_unpooled (GstBuffer * buffer, GstMeta ** meta, gpointer user_data)
1210 {
1211   if (!GST_META_FLAG_IS_SET (*meta, GST_META_FLAG_POOLED)) {
1212     GST_META_FLAG_UNSET (*meta, GST_META_FLAG_LOCKED);
1213     *meta = NULL;
1214   }
1215   return TRUE;
1216 }
1217 
1218 static void
1219 default_reset_buffer (GstBufferPool * pool, GstBuffer * buffer)
1220 {
1221   GST_BUFFER_FLAGS (buffer) &amp;= GST_BUFFER_FLAG_TAG_MEMORY;
1222 
1223   GST_BUFFER_PTS (buffer) = GST_CLOCK_TIME_NONE;
1224   GST_BUFFER_DTS (buffer) = GST_CLOCK_TIME_NONE;
1225   GST_BUFFER_DURATION (buffer) = GST_CLOCK_TIME_NONE;
1226   GST_BUFFER_OFFSET (buffer) = GST_BUFFER_OFFSET_NONE;
1227   GST_BUFFER_OFFSET_END (buffer) = GST_BUFFER_OFFSET_NONE;
1228 
1229   /* remove all metadata without the POOLED flag */
1230   gst_buffer_foreach_meta (buffer, remove_meta_unpooled, pool);
1231 }
1232 
1233 /**
1234  * gst_buffer_pool_acquire_buffer:
1235  * @pool: a #GstBufferPool
1236  * @buffer: (out): a location for a #GstBuffer
1237  * @params: (transfer none) (allow-none): parameters.
1238  *
1239  * Acquire a buffer from @pool. @buffer should point to a memory location that
1240  * can hold a pointer to the new buffer.
1241  *
1242  * @params can be %NULL or contain optional parameters to influence the
1243  * allocation.
1244  *
1245  * Returns: a #GstFlowReturn such as %GST_FLOW_FLUSHING when the pool is
1246  * inactive.
1247  */
1248 GstFlowReturn
1249 gst_buffer_pool_acquire_buffer (GstBufferPool * pool, GstBuffer ** buffer,
1250     GstBufferPoolAcquireParams * params)
1251 {
1252   GstBufferPoolClass *pclass;
1253   GstFlowReturn result;
1254 
1255   g_return_val_if_fail (GST_IS_BUFFER_POOL (pool), GST_FLOW_ERROR);
1256   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
1257 
1258   pclass = GST_BUFFER_POOL_GET_CLASS (pool);
1259 
1260   /* assume we&#39;ll have one more outstanding buffer we need to do that so
1261    * that concurrent set_active doesn&#39;t clear the buffers */
1262   g_atomic_int_inc (&amp;pool-&gt;priv-&gt;outstanding);
1263 
1264   if (G_LIKELY (pclass-&gt;acquire_buffer))
1265     result = pclass-&gt;acquire_buffer (pool, buffer, params);
1266   else
1267     result = GST_FLOW_NOT_SUPPORTED;
1268 
1269   if (G_LIKELY (result == GST_FLOW_OK)) {
1270     /* all buffers from the pool point to the pool and have the refcount of the
1271      * pool incremented */
1272     (*buffer)-&gt;pool = gst_object_ref (pool);
1273   } else {
1274     dec_outstanding (pool);
1275   }
1276 
1277   return result;
1278 }
1279 
1280 static void
1281 default_release_buffer (GstBufferPool * pool, GstBuffer * buffer)
1282 {
1283   GST_LOG_OBJECT (pool, &quot;released buffer %p %d&quot;, buffer,
1284       GST_MINI_OBJECT_FLAGS (buffer));
1285 
1286   /* memory should be untouched */
1287   if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY)))
1288     goto memory_tagged;
1289 
1290   /* size should have been reset. This is not a catch all, pool with
1291    * size requirement per memory should do their own check. */
1292   if (G_UNLIKELY (gst_buffer_get_size (buffer) != pool-&gt;priv-&gt;size))
1293     goto size_changed;
1294 
1295   /* all memory should be exclusive to this buffer (and thus be writable) */
1296   if (G_UNLIKELY (!gst_buffer_is_all_memory_writable (buffer)))
1297     goto not_writable;
1298 
1299   /* keep it around in our queue */
1300   gst_atomic_queue_push (pool-&gt;priv-&gt;queue, buffer);
1301   gst_poll_write_control (pool-&gt;priv-&gt;poll);
1302 
1303   return;
1304 
1305 memory_tagged:
1306   {
1307     GST_CAT_DEBUG_OBJECT (GST_CAT_PERFORMANCE, pool,
1308         &quot;discarding buffer %p: memory tag set&quot;, buffer);
1309     goto discard;
1310   }
1311 size_changed:
1312   {
1313     GST_CAT_DEBUG_OBJECT (GST_CAT_PERFORMANCE, pool,
1314         &quot;discarding buffer %p: size %&quot; G_GSIZE_FORMAT &quot; != %u&quot;,
1315         buffer, gst_buffer_get_size (buffer), pool-&gt;priv-&gt;size);
1316     goto discard;
1317   }
1318 not_writable:
1319   {
1320     GST_CAT_DEBUG_OBJECT (GST_CAT_PERFORMANCE, pool,
1321         &quot;discarding buffer %p: memory not writable&quot;, buffer);
1322     goto discard;
1323   }
1324 discard:
1325   {
1326     do_free_buffer (pool, buffer);
1327     return;
1328   }
1329 }
1330 
1331 /**
1332  * gst_buffer_pool_release_buffer:
1333  * @pool: a #GstBufferPool
1334  * @buffer: (transfer full): a #GstBuffer
1335  *
1336  * Release @buffer to @pool. @buffer should have previously been allocated from
1337  * @pool with gst_buffer_pool_acquire_buffer().
1338  *
1339  * This function is usually called automatically when the last ref on @buffer
1340  * disappears.
1341  */
1342 void
1343 gst_buffer_pool_release_buffer (GstBufferPool * pool, GstBuffer * buffer)
1344 {
1345   GstBufferPoolClass *pclass;
1346 
1347   g_return_if_fail (GST_IS_BUFFER_POOL (pool));
1348   g_return_if_fail (buffer != NULL);
1349 
1350   /* check that the buffer is ours, all buffers returned to the pool have the
1351    * pool member set to NULL and the pool refcount decreased */
1352   if (!g_atomic_pointer_compare_and_exchange (&amp;buffer-&gt;pool, pool, NULL))
1353     return;
1354 
1355   pclass = GST_BUFFER_POOL_GET_CLASS (pool);
1356 
1357   /* reset the buffer when needed */
1358   if (G_LIKELY (pclass-&gt;reset_buffer))
1359     pclass-&gt;reset_buffer (pool, buffer);
1360 
1361   if (G_LIKELY (pclass-&gt;release_buffer))
1362     pclass-&gt;release_buffer (pool, buffer);
1363 
1364   dec_outstanding (pool);
1365 
1366   /* decrease the refcount that the buffer had to us */
1367   gst_object_unref (pool);
1368 }
1369 
1370 /**
1371  * gst_buffer_pool_set_flushing:
1372  * @pool: a #GstBufferPool
1373  * @flushing: whether to start or stop flushing
1374  *
1375  * Enable or disable the flushing state of a @pool without freeing or
1376  * allocating buffers.
1377  *
1378  * Since: 1.4
1379  */
1380 void
1381 gst_buffer_pool_set_flushing (GstBufferPool * pool, gboolean flushing)
1382 {
1383   GstBufferPoolPrivate *priv;
1384 
1385   g_return_if_fail (GST_IS_BUFFER_POOL (pool));
1386 
1387   GST_LOG_OBJECT (pool, &quot;flushing %d&quot;, flushing);
1388 
1389   priv = pool-&gt;priv;
1390 
1391   GST_BUFFER_POOL_LOCK (pool);
1392 
1393   if (!priv-&gt;active) {
1394     GST_WARNING_OBJECT (pool, &quot;can&#39;t change flushing state of inactive pool&quot;);
1395     goto done;
1396   }
1397 
1398   do_set_flushing (pool, flushing);
1399 
1400 done:
1401   GST_BUFFER_POOL_UNLOCK (pool);
1402 }
    </pre>
  </body>
</html>