<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmem.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* GLIB - Library of useful routines for C programming
  2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Lesser General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2.1 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Lesser General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Lesser General Public
 15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 16  */
 17 
 18 /*
 19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
 20  * file for a list of people on the GLib Team.  See the ChangeLog
 21  * files for a list of changes.  These files are distributed with
 22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
 23  */
 24 
 25 #ifndef __G_MEM_H__
 26 #define __G_MEM_H__
 27 
 28 #if !defined (__GLIB_H_INSIDE__) &amp;&amp; !defined (GLIB_COMPILATION)
 29 #error &quot;Only &lt;glib.h&gt; can be included directly.&quot;
 30 #endif
 31 
 32 #include &lt;glib/gutils.h&gt;
 33 
 34 G_BEGIN_DECLS
 35 
 36 /**
 37  * GMemVTable:
 38  * @malloc: function to use for allocating memory.
 39  * @realloc: function to use for reallocating memory.
 40  * @free: function to use to free memory.
 41  * @calloc: function to use for allocating zero-filled memory.
 42  * @try_malloc: function to use for allocating memory without a default error handler.
 43  * @try_realloc: function to use for reallocating memory without a default error handler.
 44  *
 45  * A set of functions used to perform memory allocation. The same #GMemVTable must
 46  * be used for all allocations in the same program; a call to g_mem_set_vtable(),
 47  * if it exists, should be prior to any use of GLib.
 48  *
 49  * This functions related to this has been deprecated in 2.46, and no longer work.
 50  */
 51 typedef struct _GMemVTable GMemVTable;
 52 
 53 
 54 #if GLIB_SIZEOF_VOID_P &gt; GLIB_SIZEOF_LONG
 55 /**
 56  * G_MEM_ALIGN:
 57  *
 58  * Indicates the number of bytes to which memory will be aligned on the
 59  * current platform.
 60  */
<a name="1" id="anc1"></a><span class="line-modified"> 61 #  define G_MEM_ALIGN GLIB_SIZEOF_VOID_P</span>
<span class="line-modified"> 62 #else /* GLIB_SIZEOF_VOID_P &lt;= GLIB_SIZEOF_LONG */</span>
<span class="line-modified"> 63 #  define G_MEM_ALIGN GLIB_SIZEOF_LONG</span>
 64 #endif  /* GLIB_SIZEOF_VOID_P &lt;= GLIB_SIZEOF_LONG */
 65 
 66 
 67 /* Memory allocation functions
 68  */
 69 
 70 GLIB_AVAILABLE_IN_ALL
<a name="2" id="anc2"></a><span class="line-modified"> 71 void   g_free           (gpointer  mem);</span>
 72 
 73 GLIB_AVAILABLE_IN_2_34
 74 void     g_clear_pointer  (gpointer      *pp,
 75                            GDestroyNotify destroy);
 76 
 77 GLIB_AVAILABLE_IN_ALL
<a name="3" id="anc3"></a><span class="line-modified"> 78 gpointer g_malloc         (gsize   n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
 79 GLIB_AVAILABLE_IN_ALL
<a name="4" id="anc4"></a><span class="line-modified"> 80 gpointer g_malloc0        (gsize   n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
 81 GLIB_AVAILABLE_IN_ALL
 82 gpointer g_realloc        (gpointer  mem,
<a name="5" id="anc5"></a><span class="line-modified"> 83          gsize   n_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
 84 GLIB_AVAILABLE_IN_ALL
<a name="6" id="anc6"></a><span class="line-modified"> 85 gpointer g_try_malloc     (gsize   n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
 86 GLIB_AVAILABLE_IN_ALL
<a name="7" id="anc7"></a><span class="line-modified"> 87 gpointer g_try_malloc0    (gsize   n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
 88 GLIB_AVAILABLE_IN_ALL
 89 gpointer g_try_realloc    (gpointer  mem,
<a name="8" id="anc8"></a><span class="line-modified"> 90          gsize   n_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
 91 
 92 GLIB_AVAILABLE_IN_ALL
<a name="9" id="anc9"></a><span class="line-modified"> 93 gpointer g_malloc_n       (gsize   n_blocks,</span>
<span class="line-modified"> 94          gsize   n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
 95 GLIB_AVAILABLE_IN_ALL
<a name="10" id="anc10"></a><span class="line-modified"> 96 gpointer g_malloc0_n      (gsize   n_blocks,</span>
<span class="line-modified"> 97          gsize   n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
 98 GLIB_AVAILABLE_IN_ALL
 99 gpointer g_realloc_n      (gpointer  mem,
<a name="11" id="anc11"></a><span class="line-modified">100          gsize   n_blocks,</span>
<span class="line-modified">101          gsize   n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
102 GLIB_AVAILABLE_IN_ALL
<a name="12" id="anc12"></a><span class="line-modified">103 gpointer g_try_malloc_n   (gsize   n_blocks,</span>
<span class="line-modified">104          gsize   n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
105 GLIB_AVAILABLE_IN_ALL
<a name="13" id="anc13"></a><span class="line-modified">106 gpointer g_try_malloc0_n  (gsize   n_blocks,</span>
<span class="line-modified">107          gsize   n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
108 GLIB_AVAILABLE_IN_ALL
109 gpointer g_try_realloc_n  (gpointer  mem,
<a name="14" id="anc14"></a><span class="line-modified">110          gsize   n_blocks,</span>
<span class="line-modified">111          gsize   n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
112 
113 #if defined(g_has_typeof) &amp;&amp; GLIB_VERSION_MAX_ALLOWED &gt;= GLIB_VERSION_2_58
114 #define g_clear_pointer(pp, destroy)                                           \
115   G_STMT_START {                                                               \
116     G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));                       \
117     __typeof__((pp)) _pp = (pp);                                               \
118     __typeof__(*(pp)) _ptr = *_pp;                                             \
119     *_pp = NULL;                                                               \
120     if (_ptr)                                                                  \
121       (destroy) (_ptr);                                                        \
<a name="15" id="anc15"></a><span class="line-modified">122   } G_STMT_END                                                                 \</span>
<span class="line-added">123   GLIB_AVAILABLE_MACRO_IN_2_34</span>
124 #else /* __GNUC__ */
125 #define g_clear_pointer(pp, destroy) \
126   G_STMT_START {                                                               \
127     G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));                       \
128     /* Only one access, please; work around type aliasing */                   \
129     union { char *in; gpointer *out; } _pp;                                    \
130     gpointer _p;                                                               \
131     /* This assignment is needed to avoid a gcc warning */                     \
132     GDestroyNotify _destroy = (GDestroyNotify) (destroy);                      \
133                                                                                \
134     _pp.in = (char *) (pp);                                                    \
135     _p = *_pp.out;                                                             \
<a name="16" id="anc16"></a><span class="line-modified">136     if (_p)                        \</span>
<span class="line-modified">137       {                        \</span>
138         *_pp.out = NULL;                                                       \
139         _destroy (_p);                                                         \
140       }                                                                        \
<a name="17" id="anc17"></a><span class="line-modified">141   } G_STMT_END                                                                 \</span>
<span class="line-added">142   GLIB_AVAILABLE_MACRO_IN_2_34</span>
143 #endif /* __GNUC__ */
144 
145 /**
146  * g_steal_pointer:
147  * @pp: (not nullable): a pointer to a pointer
148  *
149  * Sets @pp to %NULL, returning the value that was there before.
150  *
151  * Conceptually, this transfers the ownership of the pointer from the
152  * referenced variable to the &quot;caller&quot; of the macro (ie: &quot;steals&quot; the
153  * reference).
154  *
155  * The return value will be properly typed, according to the type of
156  * @pp.
157  *
158  * This can be very useful when combined with g_autoptr() to prevent the
159  * return value of a function from being automatically freed.  Consider
160  * the following example (which only works on GCC and clang):
161  *
162  * |[
163  * GObject *
164  * create_object (void)
165  * {
166  *   g_autoptr(GObject) obj = g_object_new (G_TYPE_OBJECT, NULL);
167  *
168  *   if (early_error_case)
169  *     return NULL;
170  *
171  *   return g_steal_pointer (&amp;obj);
172  * }
173  * ]|
174  *
175  * It can also be used in similar ways for &#39;out&#39; parameters and is
176  * particularly useful for dealing with optional out parameters:
177  *
178  * |[
179  * gboolean
180  * get_object (GObject **obj_out)
181  * {
182  *   g_autoptr(GObject) obj = g_object_new (G_TYPE_OBJECT, NULL);
183  *
184  *   if (early_error_case)
185  *     return FALSE;
186  *
187  *   if (obj_out)
188  *     *obj_out = g_steal_pointer (&amp;obj);
189  *
190  *   return TRUE;
191  * }
192  * ]|
193  *
194  * In the above example, the object will be automatically freed in the
195  * early error case and also in the case that %NULL was given for
196  * @obj_out.
197  *
198  * Since: 2.44
199  */
200 static inline gpointer
201 g_steal_pointer (gpointer pp)
202 {
203   gpointer *ptr = (gpointer *) pp;
204   gpointer ref;
205 
206   ref = *ptr;
207   *ptr = NULL;
208 
209   return ref;
210 }
211 
212 /* type safety */
213 #if defined(__GNUC__) &amp;&amp; (__GNUC__ &gt; 4 || (__GNUC__ == 4 &amp;&amp; __GNUC_MINOR__ &gt;= 8)) &amp;&amp; !defined(__cplusplus) &amp;&amp; GLIB_VERSION_MAX_ALLOWED &gt;= GLIB_VERSION_2_58
214 #define g_steal_pointer(pp) ((__typeof__(*pp)) (g_steal_pointer) (pp))
215 #else  /* __GNUC__ */
216 /* This version does not depend on gcc extensions, but gcc does not warn
217  * about incompatible-pointer-types: */
218 #define g_steal_pointer(pp) \
219   (0 ? (*(pp)) : (g_steal_pointer) (pp))
220 #endif /* __GNUC__ */
221 
222 /* Optimise: avoid the call to the (slower) _n function if we can
223  * determine at compile-time that no overflow happens.
224  */
225 #if defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 2) &amp;&amp; defined (__OPTIMIZE__)
226 #  define _G_NEW(struct_type, n_structs, func) \
<a name="18" id="anc18"></a><span class="line-modified">227   (struct_type *) (G_GNUC_EXTENSION ({      \</span>
<span class="line-modified">228     gsize __n = (gsize) (n_structs);      \</span>
<span class="line-modified">229     gsize __s = sizeof (struct_type);     \</span>
<span class="line-modified">230     gpointer __p;           \</span>
<span class="line-modified">231     if (__s == 1)           \</span>
<span class="line-modified">232       __p = g_##func (__n);       \</span>
<span class="line-modified">233     else if (__builtin_constant_p (__n) &amp;&amp;    \</span>
<span class="line-modified">234              (__s == 0 || __n &lt;= G_MAXSIZE / __s))  \</span>
<span class="line-modified">235       __p = g_##func (__n * __s);       \</span>
<span class="line-modified">236     else              \</span>
<span class="line-modified">237       __p = g_##func##_n (__n, __s);      \</span>
<span class="line-modified">238     __p;              \</span>
<span class="line-modified">239   }))</span>
240 #  define _G_RENEW(struct_type, mem, n_structs, func) \
<a name="19" id="anc19"></a><span class="line-modified">241   (struct_type *) (G_GNUC_EXTENSION ({      \</span>
<span class="line-modified">242     gsize __n = (gsize) (n_structs);      \</span>
<span class="line-modified">243     gsize __s = sizeof (struct_type);     \</span>
<span class="line-modified">244     gpointer __p = (gpointer) (mem);      \</span>
<span class="line-modified">245     if (__s == 1)           \</span>
<span class="line-modified">246       __p = g_##func (__p, __n);        \</span>
<span class="line-modified">247     else if (__builtin_constant_p (__n) &amp;&amp;    \</span>
<span class="line-modified">248              (__s == 0 || __n &lt;= G_MAXSIZE / __s))  \</span>
<span class="line-modified">249       __p = g_##func (__p, __n * __s);      \</span>
<span class="line-modified">250     else              \</span>
<span class="line-modified">251       __p = g_##func##_n (__p, __n, __s);     \</span>
<span class="line-modified">252     __p;              \</span>
<span class="line-modified">253   }))</span>
254 
255 #else
256 
257 /* Unoptimised version: always call the _n() function. */
258 
259 #define _G_NEW(struct_type, n_structs, func) \
260         ((struct_type *) g_##func##_n ((n_structs), sizeof (struct_type)))
261 #define _G_RENEW(struct_type, mem, n_structs, func) \
262         ((struct_type *) g_##func##_n (mem, (n_structs), sizeof (struct_type)))
263 
264 #endif
265 
266 /**
267  * g_new:
268  * @struct_type: the type of the elements to allocate
269  * @n_structs: the number of elements to allocate
270  *
271  * Allocates @n_structs elements of type @struct_type.
272  * The returned pointer is cast to a pointer to the given type.
273  * If @n_structs is 0 it returns %NULL.
274  * Care is taken to avoid overflow when calculating the size of the allocated block.
275  *
276  * Since the returned pointer is already casted to the right type,
277  * it is normally unnecessary to cast it explicitly, and doing
278  * so might hide memory allocation errors.
279  *
280  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
281  */
<a name="20" id="anc20"></a><span class="line-modified">282 #define g_new(struct_type, n_structs)     _G_NEW (struct_type, n_structs, malloc)</span>
283 /**
284  * g_new0:
285  * @struct_type: the type of the elements to allocate.
286  * @n_structs: the number of elements to allocate.
287  *
288  * Allocates @n_structs elements of type @struct_type, initialized to 0&#39;s.
289  * The returned pointer is cast to a pointer to the given type.
290  * If @n_structs is 0 it returns %NULL.
291  * Care is taken to avoid overflow when calculating the size of the allocated block.
292  *
293  * Since the returned pointer is already casted to the right type,
294  * it is normally unnecessary to cast it explicitly, and doing
295  * so might hide memory allocation errors.
296  *
297  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type.
298  */
<a name="21" id="anc21"></a><span class="line-modified">299 #define g_new0(struct_type, n_structs)      _G_NEW (struct_type, n_structs, malloc0)</span>
300 /**
301  * g_renew:
302  * @struct_type: the type of the elements to allocate
303  * @mem: the currently allocated memory
304  * @n_structs: the number of elements to allocate
305  *
306  * Reallocates the memory pointed to by @mem, so that it now has space for
307  * @n_structs elements of type @struct_type. It returns the new address of
308  * the memory, which may have been moved.
309  * Care is taken to avoid overflow when calculating the size of the allocated block.
310  *
311  * Returns: a pointer to the new allocated memory, cast to a pointer to @struct_type
312  */
<a name="22" id="anc22"></a><span class="line-modified">313 #define g_renew(struct_type, mem, n_structs)    _G_RENEW (struct_type, mem, n_structs, realloc)</span>
314 /**
315  * g_try_new:
316  * @struct_type: the type of the elements to allocate
317  * @n_structs: the number of elements to allocate
318  *
319  * Attempts to allocate @n_structs elements of type @struct_type, and returns
320  * %NULL on failure. Contrast with g_new(), which aborts the program on failure.
321  * The returned pointer is cast to a pointer to the given type.
322  * The function returns %NULL when @n_structs is 0 of if an overflow occurs.
323  *
324  * Since: 2.8
325  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
326  */
<a name="23" id="anc23"></a><span class="line-modified">327 #define g_try_new(struct_type, n_structs)   _G_NEW (struct_type, n_structs, try_malloc)</span>
328 /**
329  * g_try_new0:
330  * @struct_type: the type of the elements to allocate
331  * @n_structs: the number of elements to allocate
332  *
333  * Attempts to allocate @n_structs elements of type @struct_type, initialized
334  * to 0&#39;s, and returns %NULL on failure. Contrast with g_new0(), which aborts
335  * the program on failure.
336  * The returned pointer is cast to a pointer to the given type.
337  * The function returns %NULL when @n_structs is 0 or if an overflow occurs.
338  *
339  * Since: 2.8
340  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
341  */
<a name="24" id="anc24"></a><span class="line-modified">342 #define g_try_new0(struct_type, n_structs)    _G_NEW (struct_type, n_structs, try_malloc0)</span>
343 /**
344  * g_try_renew:
345  * @struct_type: the type of the elements to allocate
346  * @mem: the currently allocated memory
347  * @n_structs: the number of elements to allocate
348  *
349  * Attempts to reallocate the memory pointed to by @mem, so that it now has
350  * space for @n_structs elements of type @struct_type, and returns %NULL on
351  * failure. Contrast with g_renew(), which aborts the program on failure.
352  * It returns the new address of the memory, which may have been moved.
353  * The function returns %NULL if an overflow occurs.
354  *
355  * Since: 2.8
356  * Returns: a pointer to the new allocated memory, cast to a pointer to @struct_type
357  */
<a name="25" id="anc25"></a><span class="line-modified">358 #define g_try_renew(struct_type, mem, n_structs)  _G_RENEW (struct_type, mem, n_structs, try_realloc)</span>
359 
360 
361 /* Memory allocation virtualization for debugging purposes
362  * g_mem_set_vtable() has to be the very first GLib function called
363  * if being used
364  */
365 struct _GMemVTable {
366   gpointer (*malloc)      (gsize    n_bytes);
367   gpointer (*realloc)     (gpointer mem,
<a name="26" id="anc26"></a><span class="line-modified">368          gsize    n_bytes);</span>
369   void     (*free)        (gpointer mem);
370   /* optional; set to NULL if not used ! */
371   gpointer (*calloc)      (gsize    n_blocks,
<a name="27" id="anc27"></a><span class="line-modified">372          gsize    n_block_bytes);</span>
373   gpointer (*try_malloc)  (gsize    n_bytes);
374   gpointer (*try_realloc) (gpointer mem,
<a name="28" id="anc28"></a><span class="line-modified">375          gsize    n_bytes);</span>
376 };
377 GLIB_DEPRECATED_IN_2_46
<a name="29" id="anc29"></a><span class="line-modified">378 void   g_mem_set_vtable (GMemVTable *vtable);</span>
379 GLIB_DEPRECATED_IN_2_46
380 gboolean g_mem_is_system_malloc (void);
381 
382 GLIB_VAR gboolean g_mem_gc_friendly;
383 
384 /* Memory profiler and checker, has to be enabled via g_mem_set_vtable()
385  */
386 GLIB_VAR GMemVTable *glib_mem_profiler_table;
387 GLIB_DEPRECATED_IN_2_46
<a name="30" id="anc30"></a><span class="line-modified">388 void  g_mem_profile (void);</span>
389 
390 G_END_DECLS
391 
392 #endif /* __G_MEM_H__ */
<a name="31" id="anc31"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="31" type="hidden" />
</body>
</html>