<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gdate.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gdatasetprivate.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gdate.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gdate.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;glibconfig.h&quot;
  31 
<span class="line-modified">  32 #define DEBUG_MSG(x)    /* */</span>
  33 #ifdef G_ENABLE_DEBUG
  34 /* #define DEBUG_MSG(args)  g_message args ; */
  35 #endif
  36 
  37 #include &lt;time.h&gt;
  38 #include &lt;string.h&gt;
  39 #include &lt;stdlib.h&gt;
  40 #include &lt;locale.h&gt;
  41 
  42 #ifdef G_OS_WIN32
  43 #include &lt;windows.h&gt;
  44 #endif
  45 
  46 #include &quot;gdate.h&quot;
  47 
  48 #include &quot;gconvert.h&quot;
  49 #include &quot;gmem.h&quot;
  50 #include &quot;gstrfuncs.h&quot;
  51 #include &quot;gtestutils.h&quot;
  52 #include &quot;gthread.h&quot;
</pre>
<hr />
<pre>
 101  *
 102  * GLib also features #GDateTime which represents a precise time.
 103  */
 104 
 105 /**
 106  * G_USEC_PER_SEC:
 107  *
 108  * Number of microseconds in one second (1 million).
 109  * This macro is provided for code readability.
 110  */
 111 
 112 /**
 113  * GTimeVal:
 114  * @tv_sec: seconds
 115  * @tv_usec: microseconds
 116  *
 117  * Represents a precise time, with seconds and microseconds.
 118  * Similar to the struct timeval returned by the gettimeofday()
 119  * UNIX system call.
 120  *
<span class="line-modified"> 121  * GLib is attempting to unify around the use of 64bit integers to</span>
 122  * represent microsecond-precision time. As such, this type will be
 123  * removed from a future version of GLib. A consequence of using `glong` for
 124  * `tv_sec` is that on 32-bit systems `GTimeVal` is subject to the year 2038
 125  * problem.


 126  */
 127 
 128 /**
 129  * GDate:
 130  * @julian_days: the Julian representation of the date
 131  * @julian: this bit is set if @julian_days is valid
 132  * @dmy: this is set if @day, @month and @year are valid
 133  * @day: the day of the day-month-year representation of the date,
 134  *     as a number between 1 and 31
 135  * @month: the day of the day-month-year representation of the date,
 136  *     as a number between 1 and 12
 137  * @year: the day of the day-month-year representation of the date
 138  *
 139  * Represents a day between January 1, Year 1 and a few thousand years in
 140  * the future. None of its members should be accessed directly.
 141  *
 142  * If the #GDate-struct is obtained from g_date_new(), it will be safe
 143  * to mutate but invalid and thus not safe for calendrical computations.
 144  *
 145  * If it&#39;s declared on the stack, it will contain garbage so must be
 146  * initialized with g_date_clear(). g_date_clear() makes the date invalid
 147  * but sane. An invalid date doesn&#39;t represent a day, it&#39;s &quot;empty.&quot; A date
 148  * becomes valid after you set it to a Julian day or you set a day, month,
 149  * and year.
 150  */
 151 
 152 /**
 153  * GTime:
 154  *
<span class="line-modified"> 155  * Simply a replacement for time_t. It has been deprecated</span>
<span class="line-modified"> 156  * since it is not equivalent to time_t on 64-bit platforms</span>
<span class="line-modified"> 157  * with a 64-bit time_t. Unrelated to #GTimer.</span>
 158  *
 159  * Note that #GTime is defined to always be a 32-bit integer,
<span class="line-modified"> 160  * unlike time_t which may be 64-bit on some systems. Therefore,</span>
 161  * #GTime will overflow in the year 2038, and you cannot use the
 162  * address of a #GTime variable as argument to the UNIX time()
 163  * function.
 164  *
 165  * Instead, do the following:
 166  * |[&lt;!-- language=&quot;C&quot; --&gt;
 167  * time_t ttime;
 168  * GTime gtime;
 169  *
 170  * time (&amp;ttime);
 171  * gtime = (GTime)ttime;
 172  * ]|



 173  */
 174 
 175 /**
 176  * GDateDMY:
 177  * @G_DATE_DAY: a day
 178  * @G_DATE_MONTH: a month
 179  * @G_DATE_YEAR: a year
 180  *
 181  * This enumeration isn&#39;t used in the API, but may be useful if you need
 182  * to mark a number as a day, month, or year.
 183  */
 184 
 185 /**
 186  * GDateDay:
 187  *
 188  * Integer representing a day of the month; between 1 and 31.
 189  * #G_DATE_BAD_DAY represents an invalid day of the month.
 190  */
 191 
 192 /**
</pre>
<hr />
<pre>
 477 g_date_valid_julian (guint32 j)
 478 {
 479   return (j &gt; G_DATE_BAD_JULIAN);
 480 }
 481 
 482 /**
 483  * g_date_valid_dmy:
 484  * @day: day
 485  * @month: month
 486  * @year: year
 487  *
 488  * Returns %TRUE if the day-month-year triplet forms a valid, existing day
 489  * in the range of days #GDate understands (Year 1 or later, no more than
 490  * a few thousand years in the future).
 491  *
 492  * Returns: %TRUE if the date is a valid one
 493  */
 494 gboolean
 495 g_date_valid_dmy (GDateDay   d,
 496                   GDateMonth m,
<span class="line-modified"> 497           GDateYear  y)</span>
 498 {
 499   /* No need to check the upper bound of @y, because #GDateYear is 16 bits wide,
 500    * just like #GDate.year. */
 501   return ( (m &gt; G_DATE_BAD_MONTH) &amp;&amp;
 502            (m &lt; 13)               &amp;&amp;
 503            (d &gt; G_DATE_BAD_DAY)   &amp;&amp;
 504            (y &gt; G_DATE_BAD_YEAR)  &amp;&amp;   /* must check before using g_date_is_leap_year */
 505            (d &lt;=  (g_date_is_leap_year (y) ?
<span class="line-modified"> 506            days_in_months[1][m] : days_in_months[0][m])) );</span>
 507 }
 508 
 509 
 510 /* &quot;Julian days&quot; just means an absolute number of days, where Day 1 ==
 511  *   Jan 1, Year 1
 512  */
 513 static void
 514 g_date_update_julian (const GDate *const_d)
 515 {
 516   GDate *d = (GDate *) const_d;
 517   GDateYear year;
 518   gint idx;
 519 
 520   g_return_if_fail (d != NULL);
 521   g_return_if_fail (d-&gt;dmy != 0);
 522   g_return_if_fail (!d-&gt;julian);
 523   g_return_if_fail (g_date_valid_dmy (d-&gt;day, d-&gt;month, d-&gt;year));
 524 
 525   /* What we actually do is: multiply years * 365 days in the year,
 526    * add the number of years divided by 4, subtract the number of
</pre>
<hr />
<pre>
 565    *  1,721,425 to the number of days before doing the formula.
 566    *
 567    * I&#39;m sure this can be simplified for our 1 January 1 AD period
 568    * start, but I can&#39;t figure out how to unpack the formula.
 569    */
 570 
 571   A = d-&gt;julian_days + 1721425 + 32045;
 572   B = ( 4 *(A + 36524) )/ 146097 - 1;
 573   C = A - (146097 * B)/4;
 574   D = ( 4 * (C + 365) ) / 1461 - 1;
 575   E = C - ((1461*D) / 4);
 576   M = (5 * (E - 1) + 2)/153;
 577 
 578   m = M + 3 - (12*(M/10));
 579   day = E - (153*M + 2)/5;
 580   y = 100 * B + D - 4800 + (M/10);
 581 
 582 #ifdef G_ENABLE_DEBUG
 583   if (!g_date_valid_dmy (day, m, y))
 584     g_warning (&quot;OOPS julian: %u  computed dmy: %u %u %u&quot;,
<span class="line-modified"> 585            d-&gt;julian_days, day, m, y);</span>
 586 #endif
 587 
 588   d-&gt;month = m;
 589   d-&gt;day   = day;
 590   d-&gt;year  = y;
 591 
 592   d-&gt;dmy = TRUE;
 593 }
 594 
 595 /**
 596  * g_date_get_weekday:
 597  * @date: a #GDate
 598  *
 599  * Returns the day of the week for a #GDate. The date must be valid.
 600  *
 601  * Returns: day of the week as a #GDateWeekday.
 602  */
 603 GDateWeekday
 604 g_date_get_weekday (const GDate *d)
 605 {
</pre>
<hr />
<pre>
 827   L  = d4 / 1460;
 828   d1 = ((d4 - L) % 365) + L;
 829   w  = d1 / 7 + 1;
 830 
 831   return w;
 832 }
 833 
 834 /**
 835  * g_date_days_between:
 836  * @date1: the first date
 837  * @date2: the second date
 838  *
 839  * Computes the number of days between two dates.
 840  * If @date2 is prior to @date1, the returned value is negative.
 841  * Both dates must be valid.
 842  *
 843  * Returns: the number of days between @date1 and @date2
 844  */
 845 gint
 846 g_date_days_between (const GDate *d1,
<span class="line-modified"> 847              const GDate *d2)</span>
 848 {
 849   g_return_val_if_fail (g_date_valid (d1), 0);
 850   g_return_val_if_fail (g_date_valid (d2), 0);
 851 
 852   return (gint)g_date_get_julian (d2) - (gint)g_date_get_julian (d1);
 853 }
 854 
 855 /**
 856  * g_date_clear:
 857  * @date: pointer to one or more dates to clear
 858  * @n_dates: number of dates to clear
 859  *
 860  * Initializes one or more #GDate structs to a sane but invalid
 861  * state. The cleared dates will not represent an existing date, but will
 862  * not contain garbage. Useful to init a date declared on the stack.
 863  * Validity can be tested with g_date_valid().
 864  */
 865 void
 866 g_date_clear (GDate *d, guint ndates)
 867 {
</pre>
<hr />
<pre>
1002       gsize longest = 0;
1003       gchar *casefold;
1004       gchar *normalized;
1005 
1006       casefold = g_utf8_casefold (str, -1);
1007       normalized = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
1008       g_free (casefold);
1009 
1010       for (i = 1; i &lt; 13; ++i)
1011         {
1012           /* Here month names may be in a genitive case if the language
1013            * grammatical rules require it.
1014            * Examples of how January may look in some languages:
1015            * Catalan: &quot;de gener&quot;, Croatian: &quot;gener&quot;, Polish: &quot;gener&quot;,
1016            * Upper Sorbian: &quot;januara&quot;.
1017            * Note that most of the languages can&#39;t or don&#39;t use the the
1018            * genitive case here so they use nominative everywhere.
1019            * For example, English always uses &quot;January&quot;.
1020            */
1021           if (update_month_match (&amp;longest, normalized, long_month_names[i]))
<span class="line-modified">1022                   pt-&gt;month = i;</span>
1023 
1024           /* Here month names will be in a nominative case.
1025            * Examples of how January may look in some languages:
1026            * Catalan: &quot;gener&quot;, Croatian: &quot;gener&quot;, Polish: &quot;gener&quot;,
1027            * Upper Sorbian: &quot;Januar&quot;.
1028            */
1029           if (update_month_match (&amp;longest, normalized, long_month_names_alternative[i]))
<span class="line-modified">1030                   pt-&gt;month = i;</span>
1031 
1032           /* Differences between abbreviated nominative and abbreviated
1033            * genitive month names are visible in very few languages but
1034            * let&#39;s handle them.
1035            */
1036           if (update_month_match (&amp;longest, normalized, short_month_names[i]))
<span class="line-modified">1037                   pt-&gt;month = i;</span>
1038 
1039           if (update_month_match (&amp;longest, normalized, short_month_names_alternative[i]))
<span class="line-modified">1040                   pt-&gt;month = i;</span>
<span class="line-modified">1041                 }</span>
1042 
1043       g_free (normalized);
1044     }
1045 }
1046 
1047 /* HOLDS: g_date_global_lock */
1048 static void
1049 g_date_prepare_to_parse (const gchar      *str,
1050                          GDateParseTokens *pt)
1051 {
1052   const gchar *locale = setlocale (LC_TIME, NULL);
1053   gboolean recompute_localeinfo = FALSE;
1054   GDate d;
1055 
1056   g_return_if_fail (locale != NULL); /* should not happen */
1057 
1058   g_date_clear (&amp;d, 1);              /* clear for scratch use */
1059 
1060   if ( (current_locale == NULL) || (strcmp (locale, current_locale) != 0) )
1061     recompute_localeinfo = TRUE;  /* Uh, there used to be a reason for the temporary */
1062 
1063   if (recompute_localeinfo)
1064     {
1065       int i = 1;
1066       GDateParseTokens testpt;
1067       gchar buf[128];
1068 
1069       g_free (current_locale); /* still works if current_locale == NULL */
1070 
1071       current_locale = g_strdup (locale);
1072 
1073       short_month_names[0] = &quot;Error&quot;;
1074       long_month_names[0] = &quot;Error&quot;;
1075 
1076       while (i &lt; 13)
1077         {
<span class="line-modified">1078       gchar *casefold;</span>
1079 
1080           g_date_set_dmy (&amp;d, 1, i, 1976);
1081 
1082           g_return_if_fail (g_date_valid (&amp;d));
1083 
1084           g_date_strftime (buf, 127, &quot;%b&quot;, &amp;d);
1085 
<span class="line-modified">1086       casefold = g_utf8_casefold (buf, -1);</span>
1087           g_free (short_month_names[i]);
1088           short_month_names[i] = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
<span class="line-modified">1089       g_free (casefold);</span>
1090 
1091           g_date_strftime (buf, 127, &quot;%B&quot;, &amp;d);
<span class="line-modified">1092       casefold = g_utf8_casefold (buf, -1);</span>
1093           g_free (long_month_names[i]);
1094           long_month_names[i] = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
<span class="line-modified">1095       g_free (casefold);</span>
1096 
1097           g_date_strftime (buf, 127, &quot;%Ob&quot;, &amp;d);
1098           casefold = g_utf8_casefold (buf, -1);
1099           g_free (short_month_names_alternative[i]);
1100           short_month_names_alternative[i] = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
1101           g_free (casefold);
1102 
1103           g_date_strftime (buf, 127, &quot;%OB&quot;, &amp;d);
1104           casefold = g_utf8_casefold (buf, -1);
1105           g_free (long_month_names_alternative[i]);
1106           long_month_names_alternative[i] = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
1107           g_free (casefold);
1108 
1109           ++i;
1110         }
1111 
1112       /* Determine DMY order */
1113 
1114       /* had to pick a random day - don&#39;t change this, some strftimes
1115        * are broken on some days, and this one is good so far. */
</pre>
<hr />
<pre>
1150           ++i;
1151         }
1152 
1153 #if defined(G_ENABLE_DEBUG) &amp;&amp; 0
1154       DEBUG_MSG ((&quot;**GDate prepared a new set of locale-specific parse rules.&quot;));
1155       i = 1;
1156       while (i &lt; 13)
1157         {
1158           DEBUG_MSG ((&quot;  %s   %s&quot;, long_month_names[i], short_month_names[i]));
1159           ++i;
1160         }
1161       DEBUG_MSG ((&quot;Alternative month names:&quot;));
1162       i = 1;
1163       while (i &lt; 13)
1164         {
1165           DEBUG_MSG ((&quot;  %s   %s&quot;, long_month_names_alternative[i], short_month_names_alternative[i]));
1166           ++i;
1167         }
1168       if (using_twodigit_years)
1169         {
<span class="line-modified">1170       DEBUG_MSG ((&quot;**Using twodigit years with cutoff year: %u&quot;, twodigit_start_year));</span>
1171         }
1172       {
1173         gchar *strings[3];
1174         i = 0;
1175         while (i &lt; 3)
1176           {
1177             switch (dmy_order[i])
1178               {
1179               case G_DATE_MONTH:
1180                 strings[i] = &quot;Month&quot;;
1181                 break;
1182               case G_DATE_YEAR:
1183                 strings[i] = &quot;Year&quot;;
1184                 break;
1185               case G_DATE_DAY:
1186                 strings[i] = &quot;Day&quot;;
1187                 break;
1188               default:
1189                 strings[i] = NULL;
1190                 break;
</pre>
<hr />
<pre>
1217  * means by a given string (and it does work pretty well in that
1218  * capacity).
1219  */
1220 void
1221 g_date_set_parse (GDate       *d,
1222                   const gchar *str)
1223 {
1224   GDateParseTokens pt;
1225   guint m = G_DATE_BAD_MONTH, day = G_DATE_BAD_DAY, y = G_DATE_BAD_YEAR;
1226 
1227   g_return_if_fail (d != NULL);
1228 
1229   /* set invalid */
1230   g_date_clear (d, 1);
1231 
1232   G_LOCK (g_date_global);
1233 
1234   g_date_prepare_to_parse (str, &amp;pt);
1235 
1236   DEBUG_MSG ((&quot;Found %d ints, &#39;%d&#39; &#39;%d&#39; &#39;%d&#39; and written out month %d&quot;,
<span class="line-modified">1237           pt.num_ints, pt.n[0], pt.n[1], pt.n[2], pt.month));</span>
1238 
1239 
1240   if (pt.num_ints == 4)
1241     {
1242       G_UNLOCK (g_date_global);
1243       return; /* presumably a typo; bail out. */
1244     }
1245 
1246   if (pt.num_ints &gt; 1)
1247     {
1248       int i = 0;
1249       int j = 0;
1250 
1251       g_assert (pt.num_ints &lt; 4); /* i.e., it is 2 or 3 */
1252 
1253       while (i &lt; pt.num_ints &amp;&amp; j &lt; 3)
1254         {
1255           switch (dmy_order[j])
1256             {
1257             case G_DATE_MONTH:
<span class="line-modified">1258         {</span>
<span class="line-modified">1259           if (pt.num_ints == 2 &amp;&amp; pt.month != G_DATE_BAD_MONTH)</span>
<span class="line-modified">1260         {</span>
<span class="line-modified">1261           m = pt.month;</span>
<span class="line-modified">1262           ++j;      /* skip months, but don&#39;t skip this number */</span>
<span class="line-modified">1263           continue;</span>
<span class="line-modified">1264         }</span>
<span class="line-modified">1265           else</span>
<span class="line-modified">1266         m = pt.n[i];</span>
<span class="line-modified">1267         }</span>
<span class="line-modified">1268         break;</span>
1269             case G_DATE_DAY:
<span class="line-modified">1270         {</span>
<span class="line-modified">1271           if (pt.num_ints == 2 &amp;&amp; pt.month == G_DATE_BAD_MONTH)</span>
<span class="line-modified">1272         {</span>
<span class="line-modified">1273           day = 1;</span>
<span class="line-modified">1274           ++j;      /* skip days, since we may have month/year */</span>
<span class="line-modified">1275           continue;</span>
<span class="line-modified">1276         }</span>
<span class="line-modified">1277           day = pt.n[i];</span>
<span class="line-modified">1278         }</span>
<span class="line-modified">1279         break;</span>
1280             case G_DATE_YEAR:
<span class="line-modified">1281         {</span>
<span class="line-modified">1282           y  = pt.n[i];</span>
1283 
<span class="line-modified">1284           if (locale_era_adjust != 0)</span>
<span class="line-modified">1285             {</span>
<span class="line-modified">1286           y += locale_era_adjust;</span>
<span class="line-modified">1287             }</span>
<span class="line-modified">1288           else if (using_twodigit_years &amp;&amp; y &lt; 100)</span>
<span class="line-modified">1289         {</span>
<span class="line-modified">1290           guint two     =  twodigit_start_year % 100;</span>
<span class="line-modified">1291           guint century = (twodigit_start_year / 100) * 100;</span>
1292 
<span class="line-modified">1293           if (y &lt; two)</span>
<span class="line-modified">1294             century += 100;</span>
1295 
<span class="line-modified">1296           y += century;</span>
<span class="line-modified">1297         }</span>
<span class="line-modified">1298         }</span>
<span class="line-modified">1299         break;</span>
1300             default:
1301               break;
1302             }
1303 
1304           ++i;
1305           ++j;
1306         }
1307 
1308 
1309       if (pt.num_ints == 3 &amp;&amp; !g_date_valid_dmy (day, m, y))
1310         {
1311           /* Try YYYY MM DD */
1312           y   = pt.n[0];
1313           m   = pt.n[1];
1314           day = pt.n[2];
1315 
1316           if (using_twodigit_years &amp;&amp; y &lt; 100)
1317             y = G_DATE_BAD_YEAR; /* avoids ambiguity */
1318         }
1319       else if (pt.num_ints == 2)
<span class="line-modified">1320     {</span>
<span class="line-modified">1321       if (m == G_DATE_BAD_MONTH &amp;&amp; pt.month != G_DATE_BAD_MONTH)</span>
<span class="line-modified">1322         m = pt.month;</span>
<span class="line-modified">1323     }</span>
1324     }
1325   else if (pt.num_ints == 1)
1326     {
1327       if (pt.month != G_DATE_BAD_MONTH)
1328         {
1329           /* Month name and year? */
1330           m    = pt.month;
1331           day  = 1;
1332           y = pt.n[0];
1333         }
1334       else
1335         {
1336           /* Try yyyymmdd and yymmdd */
1337 
1338           m   = (pt.n[0]/100) % 100;
1339           day = pt.n[0] % 100;
1340           y   = pt.n[0]/10000;
1341 
1342           /* FIXME move this into a separate function */
1343           if (using_twodigit_years &amp;&amp; y &lt; 100)
</pre>
<hr />
<pre>
1375  * g_date_set_time_t:
1376  * @date: a #GDate
1377  * @timet: time_t value to set
1378  *
1379  * Sets the value of a date to the date corresponding to a time
1380  * specified as a time_t. The time to date conversion is done using
1381  * the user&#39;s current timezone.
1382  *
1383  * To set the value of a date to the current day, you could write:
1384  * |[&lt;!-- language=&quot;C&quot; --&gt;
1385  *  time_t now = time (NULL);
1386  *  if (now == (time_t) -1)
1387  *    // handle the error
1388  *  g_date_set_time_t (date, now);
1389  * ]|
1390  *
1391  * Since: 2.10
1392  */
1393 void
1394 g_date_set_time_t (GDate *date,
<span class="line-modified">1395            time_t timet)</span>
1396 {
1397   struct tm tm;
1398 
1399   g_return_if_fail (date != NULL);
1400 
1401 #ifdef HAVE_LOCALTIME_R
1402   localtime_r (&amp;timet, &amp;tm);
1403 #else
1404   {
1405     struct tm *ptm = localtime (&amp;timet);
1406 
1407     if (ptm == NULL)
1408       {
<span class="line-modified">1409     /* Happens at least in Microsoft&#39;s C library if you pass a</span>
<span class="line-modified">1410      * negative time_t. Use 2000-01-01 as default date.</span>
<span class="line-modified">1411      */</span>
1412 #ifndef G_DISABLE_CHECKS
<span class="line-modified">1413     g_return_if_fail_warning (G_LOG_DOMAIN, &quot;g_date_set_time&quot;, &quot;ptm != NULL&quot;);</span>
1414 #endif
1415 
<span class="line-modified">1416     tm.tm_mon = 0;</span>
<span class="line-modified">1417     tm.tm_mday = 1;</span>
<span class="line-modified">1418     tm.tm_year = 100;</span>
1419       }
1420     else
1421       memcpy ((void *) &amp;tm, (void *) ptm, sizeof(struct tm));
1422   }
1423 #endif
1424 
1425   date-&gt;julian = FALSE;
1426 
1427   date-&gt;month = tm.tm_mon + 1;
1428   date-&gt;day   = tm.tm_mday;
1429   date-&gt;year  = tm.tm_year + 1900;
1430 
1431   g_return_if_fail (g_date_valid_dmy (date-&gt;day, date-&gt;month, date-&gt;year));
1432 
1433   date-&gt;dmy    = TRUE;
1434 }
1435 
1436 
1437 /**
1438  * g_date_set_time:
1439  * @date: a #GDate.
1440  * @time_: #GTime value to set.
1441  *
1442  * Sets the value of a date from a #GTime value.
1443  * The time to date conversion is done using the user&#39;s current timezone.
1444  *
1445  * Deprecated: 2.10: Use g_date_set_time_t() instead.
1446  */

1447 void
1448 g_date_set_time (GDate *date,
<span class="line-modified">1449          GTime  time_)</span>
1450 {
1451   g_date_set_time_t (date, (time_t) time_);
1452 }

1453 
1454 /**
1455  * g_date_set_time_val:
1456  * @date: a #GDate
1457  * @timeval: #GTimeVal value to set
1458  *
1459  * Sets the value of a date from a #GTimeVal value.  Note that the
1460  * @tv_usec member is ignored, because #GDate can&#39;t make use of the
1461  * additional precision.
1462  *
1463  * The time to date conversion is done using the user&#39;s current timezone.
1464  *
1465  * Since: 2.10


1466  */

1467 void
1468 g_date_set_time_val (GDate    *date,
<span class="line-modified">1469              GTimeVal *timeval)</span>
1470 {
1471   g_date_set_time_t (date, (time_t) timeval-&gt;tv_sec);
1472 }

1473 
1474 /**
1475  * g_date_set_month:
1476  * @date: a #GDate
1477  * @month: month to set
1478  *
1479  * Sets the month of the year for a #GDate.  If the resulting
1480  * day-month-year triplet is invalid, the date will be invalid.
1481  */
1482 void
1483 g_date_set_month (GDate     *d,
1484                   GDateMonth m)
1485 {
1486   g_return_if_fail (d != NULL);
1487   g_return_if_fail (g_date_valid_month (m));
1488 
1489   if (d-&gt;julian &amp;&amp; !d-&gt;dmy) g_date_update_dmy(d);
1490   d-&gt;julian = FALSE;
1491 
1492   d-&gt;month = m;
</pre>
<hr />
<pre>
1712 void
1713 g_date_add_months (GDate *d,
1714                    guint  nmonths)
1715 {
1716   guint years, months;
1717   gint idx;
1718 
1719   g_return_if_fail (g_date_valid (d));
1720 
1721   if (!d-&gt;dmy)
1722     g_date_update_dmy (d);
1723 
1724   g_return_if_fail (d-&gt;dmy != 0);
1725   g_return_if_fail (nmonths &lt;= G_MAXUINT - (d-&gt;month - 1));
1726 
1727   nmonths += d-&gt;month - 1;
1728 
1729   years  = nmonths/12;
1730   months = nmonths%12;
1731 
<span class="line-modified">1732   g_return_if_fail (years &lt;= G_MAXUINT16 - d-&gt;year);</span>
1733 
1734   d-&gt;month = months + 1;
1735   d-&gt;year  += years;
1736 
1737   idx = g_date_is_leap_year (d-&gt;year) ? 1 : 0;
1738 
1739   if (d-&gt;day &gt; days_in_months[idx][d-&gt;month])
1740     d-&gt;day = days_in_months[idx][d-&gt;month];
1741 
1742   d-&gt;julian = FALSE;
1743 
1744   g_return_if_fail (g_date_valid (d));
1745 }
1746 
1747 /**
1748  * g_date_subtract_months:
1749  * @date: a #GDate to decrement
1750  * @n_months: number of months to move
1751  *
1752  * Moves a date some number of months into the past.
</pre>
<hr />
<pre>
1796 /**
1797  * g_date_add_years:
1798  * @date: a #GDate to increment
1799  * @n_years: number of years to move forward
1800  *
1801  * Increments a date by some number of years.
1802  * If the date is February 29, and the destination
1803  * year is not a leap year, the date will be changed
1804  * to February 28. The date must be valid.
1805  */
1806 void
1807 g_date_add_years (GDate *d,
1808                   guint  nyears)
1809 {
1810   g_return_if_fail (g_date_valid (d));
1811 
1812   if (!d-&gt;dmy)
1813     g_date_update_dmy (d);
1814 
1815   g_return_if_fail (d-&gt;dmy != 0);
<span class="line-modified">1816   g_return_if_fail (nyears &lt;= G_MAXUINT16 - d-&gt;year);</span>
1817 
1818   d-&gt;year += nyears;
1819 
1820   if (d-&gt;month == 2 &amp;&amp; d-&gt;day == 29)
1821     {
1822       if (!g_date_is_leap_year (d-&gt;year))
1823         d-&gt;day = 28;
1824     }
1825 
1826   d-&gt;julian = FALSE;
1827 }
1828 
1829 /**
1830  * g_date_subtract_years:
1831  * @date: a #GDate to decrement
1832  * @n_years: number of years to move
1833  *
1834  * Moves a date some number of years into the past.
1835  * If the current day doesn&#39;t exist in the destination
1836  * year (i.e. it&#39;s February 29 and you move to a non-leap-year)
</pre>
<hr />
<pre>
2080   tm-&gt;tm_wday = (int)day;
2081 
2082   tm-&gt;tm_yday = g_date_get_day_of_year (d) - 1; /* 0 to 365 */
2083   tm-&gt;tm_isdst = -1; /* -1 means &quot;information not available&quot; */
2084 }
2085 
2086 /**
2087  * g_date_clamp:
2088  * @date: a #GDate to clamp
2089  * @min_date: minimum accepted value for @date
2090  * @max_date: maximum accepted value for @date
2091  *
2092  * If @date is prior to @min_date, sets @date equal to @min_date.
2093  * If @date falls after @max_date, sets @date equal to @max_date.
2094  * Otherwise, @date is unchanged.
2095  * Either of @min_date and @max_date may be %NULL.
2096  * All non-%NULL dates must be valid.
2097  */
2098 void
2099 g_date_clamp (GDate       *date,
<span class="line-modified">2100           const GDate *min_date,</span>
<span class="line-modified">2101           const GDate *max_date)</span>
2102 {
2103   g_return_if_fail (g_date_valid (date));
2104 
2105   if (min_date != NULL)
2106     g_return_if_fail (g_date_valid (min_date));
2107 
2108   if (max_date != NULL)
2109     g_return_if_fail (g_date_valid (max_date));
2110 
2111   if (min_date != NULL &amp;&amp; max_date != NULL)
2112     g_return_if_fail (g_date_compare (min_date, max_date) &lt;= 0);
2113 
2114   if (min_date &amp;&amp; g_date_compare (date, min_date) &lt; 0)
2115     *date = *min_date;
2116 
2117   if (max_date &amp;&amp; g_date_compare (max_date, date) &lt; 0)
2118     *date = *max_date;
2119 }
2120 
2121 /**
</pre>
<hr />
<pre>
2127  * and swap the values if this is not the case.
2128  */
2129 void
2130 g_date_order (GDate *date1,
2131               GDate *date2)
2132 {
2133   g_return_if_fail (g_date_valid (date1));
2134   g_return_if_fail (g_date_valid (date2));
2135 
2136   if (g_date_compare (date1, date2) &gt; 0)
2137     {
2138       GDate tmp = *date1;
2139       *date1 = *date2;
2140       *date2 = tmp;
2141     }
2142 }
2143 
2144 #ifdef G_OS_WIN32
2145 static void
2146 append_month_name (GArray     *result,
<span class="line-modified">2147            LCID        lcid,</span>
<span class="line-modified">2148            SYSTEMTIME *systemtime,</span>
<span class="line-modified">2149            gboolean    abbreviated,</span>
<span class="line-modified">2150            gboolean    alternative)</span>
2151 {
2152   int n;
2153   WORD base;
2154   LPCWSTR lpFormat;
2155 
2156   if (alternative)
2157     {
2158       base = abbreviated ? LOCALE_SABBREVMONTHNAME1 : LOCALE_SMONTHNAME1;
2159       n = GetLocaleInfoW (lcid, base + systemtime-&gt;wMonth - 1, NULL, 0);
2160       g_array_set_size (result, result-&gt;len + n);
2161       GetLocaleInfoW (lcid, base + systemtime-&gt;wMonth - 1,
<span class="line-modified">2162               ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
2163       g_array_set_size (result, result-&gt;len - 1);
2164     }
2165   else
2166     {
2167       /* According to MSDN, this is the correct method to obtain
2168        * the form of the month name used when formatting a full
2169        * date; it must be a genitive case in some languages.
2170        */
2171       lpFormat = abbreviated ? L&quot;ddMMM&quot; : L&quot;ddMMMM&quot;;
2172       n = GetDateFormatW (lcid, 0, systemtime, lpFormat, NULL, 0);
2173       g_array_set_size (result, result-&gt;len + n);
2174       GetDateFormatW (lcid, 0, systemtime, lpFormat,
<span class="line-modified">2175               ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
2176       /* We have obtained a day number as two digits and the month name.
2177        * Now let&#39;s get rid of those two digits: overwrite them with the
2178        * month name.
2179        */
2180       memmove (((wchar_t *) result-&gt;data) + result-&gt;len - n,
<span class="line-modified">2181            ((wchar_t *) result-&gt;data) + result-&gt;len - n + 2,</span>
<span class="line-modified">2182            (n - 2) * sizeof (wchar_t));</span>
2183       g_array_set_size (result, result-&gt;len - 3);
2184     }
2185 }
2186 
2187 static gsize
2188 win32_strftime_helper (const GDate     *d,
<span class="line-modified">2189                        const gchar     *format,</span>
<span class="line-modified">2190                        const struct tm *tm,</span>
<span class="line-modified">2191                        gchar           *s,</span>
<span class="line-modified">2192                gsize            slen)</span>
2193 {
2194   SYSTEMTIME systemtime;
2195   TIME_ZONE_INFORMATION tzinfo;
2196   LCID lcid;
2197   int n, k;
2198   GArray *result;
2199   const gchar *p;
2200   gunichar c, modifier;
2201   const wchar_t digits[] = L&quot;0123456789&quot;;
2202   gchar *convbuf;
2203   glong convlen = 0;
2204   gsize retval;
2205 
2206   systemtime.wYear = tm-&gt;tm_year + 1900;
2207   systemtime.wMonth = tm-&gt;tm_mon + 1;
2208   systemtime.wDayOfWeek = tm-&gt;tm_wday;
2209   systemtime.wDay = tm-&gt;tm_mday;
2210   systemtime.wHour = tm-&gt;tm_hour;
2211   systemtime.wMinute = tm-&gt;tm_min;
2212   systemtime.wSecond = tm-&gt;tm_sec;
2213   systemtime.wMilliseconds = 0;
2214 
2215   lcid = GetThreadLocale ();
2216   result = g_array_sized_new (FALSE, FALSE, sizeof (wchar_t), MAX (128, strlen (format) * 2));
2217 
2218   p = format;
2219   while (*p)
2220     {
2221       c = g_utf8_get_char (p);
2222       if (c == &#39;%&#39;)
<span class="line-modified">2223     {</span>
<span class="line-modified">2224       p = g_utf8_next_char (p);</span>
<span class="line-modified">2225       if (!*p)</span>
<span class="line-modified">2226         {</span>
<span class="line-modified">2227           s[0] = &#39;\0&#39;;</span>
<span class="line-modified">2228           g_array_free (result, TRUE);</span>
2229 
<span class="line-modified">2230           return 0;</span>
<span class="line-modified">2231         }</span>
2232 
<span class="line-modified">2233       modifier = &#39;\0&#39;;</span>
<span class="line-modified">2234       c = g_utf8_get_char (p);</span>
<span class="line-modified">2235       if (c == &#39;E&#39; || c == &#39;O&#39;)</span>
<span class="line-modified">2236         {</span>
<span class="line-modified">2237           /* &quot;%OB&quot;, &quot;%Ob&quot;, and &quot;%Oh&quot; are supported, ignore other modified</span>
<span class="line-modified">2238            * conversion specifiers for now.</span>
<span class="line-modified">2239            */</span>
<span class="line-modified">2240           modifier = c;</span>
<span class="line-modified">2241           p = g_utf8_next_char (p);</span>
<span class="line-modified">2242           if (!*p)</span>
<span class="line-modified">2243         {</span>
<span class="line-modified">2244           s[0] = &#39;\0&#39;;</span>
<span class="line-modified">2245           g_array_free (result, TRUE);</span>
2246 
<span class="line-modified">2247           return 0;</span>
<span class="line-modified">2248         }</span>
2249 
<span class="line-modified">2250           c = g_utf8_get_char (p);</span>
<span class="line-modified">2251         }</span>
2252 
<span class="line-modified">2253       switch (c)</span>
<span class="line-modified">2254         {</span>
<span class="line-modified">2255         case &#39;a&#39;:</span>
<span class="line-modified">2256           if (systemtime.wDayOfWeek == 0)</span>
<span class="line-modified">2257         k = 6;</span>
<span class="line-modified">2258           else</span>
<span class="line-modified">2259         k = systemtime.wDayOfWeek - 1;</span>
<span class="line-modified">2260           n = GetLocaleInfoW (lcid, LOCALE_SABBREVDAYNAME1+k, NULL, 0);</span>
<span class="line-modified">2261           g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2262           GetLocaleInfoW (lcid, LOCALE_SABBREVDAYNAME1+k, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2263           g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-modified">2264           break;</span>
<span class="line-modified">2265         case &#39;A&#39;:</span>
<span class="line-modified">2266           if (systemtime.wDayOfWeek == 0)</span>
<span class="line-modified">2267         k = 6;</span>
<span class="line-modified">2268           else</span>
<span class="line-modified">2269         k = systemtime.wDayOfWeek - 1;</span>
<span class="line-modified">2270           n = GetLocaleInfoW (lcid, LOCALE_SDAYNAME1+k, NULL, 0);</span>
<span class="line-modified">2271           g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2272           GetLocaleInfoW (lcid, LOCALE_SDAYNAME1+k, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2273           g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-modified">2274           break;</span>
<span class="line-modified">2275         case &#39;b&#39;:</span>
<span class="line-modified">2276         case &#39;h&#39;:</span>
<span class="line-modified">2277           append_month_name (result, lcid, &amp;systemtime, TRUE,</span>
<span class="line-modified">2278                  modifier == &#39;O&#39;);</span>
<span class="line-modified">2279           break;</span>
<span class="line-modified">2280         case &#39;B&#39;:</span>
<span class="line-modified">2281           append_month_name (result, lcid, &amp;systemtime, FALSE,</span>
<span class="line-modified">2282                  modifier == &#39;O&#39;);</span>
<span class="line-modified">2283           break;</span>
<span class="line-modified">2284         case &#39;c&#39;:</span>
<span class="line-modified">2285           n = GetDateFormatW (lcid, 0, &amp;systemtime, NULL, NULL, 0);</span>
<span class="line-modified">2286           if (n &gt; 0)</span>
<span class="line-modified">2287         {</span>
<span class="line-modified">2288           g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2289           GetDateFormatW (lcid, 0, &amp;systemtime, NULL, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2290           g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-modified">2291         }</span>
<span class="line-removed">2292           g_array_append_vals (result, L&quot; &quot;, 1);</span>
<span class="line-removed">2293           n = GetTimeFormatW (lcid, 0, &amp;systemtime, NULL, NULL, 0);</span>
<span class="line-removed">2294           if (n &gt; 0)</span>
<span class="line-removed">2295         {</span>
<span class="line-removed">2296           g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-removed">2297           GetTimeFormatW (lcid, 0, &amp;systemtime, NULL, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-removed">2298           g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-removed">2299         }</span>
<span class="line-removed">2300           break;</span>
<span class="line-removed">2301         case &#39;C&#39;:</span>
<span class="line-removed">2302           g_array_append_vals (result, digits + systemtime.wYear/1000, 1);</span>
<span class="line-removed">2303           g_array_append_vals (result, digits + (systemtime.wYear/1000)%10, 1);</span>
<span class="line-removed">2304           break;</span>
<span class="line-removed">2305         case &#39;d&#39;:</span>
<span class="line-removed">2306           g_array_append_vals (result, digits + systemtime.wDay/10, 1);</span>
<span class="line-removed">2307           g_array_append_vals (result, digits + systemtime.wDay%10, 1);</span>
<span class="line-removed">2308           break;</span>
<span class="line-removed">2309         case &#39;D&#39;:</span>
<span class="line-removed">2310           g_array_append_vals (result, digits + systemtime.wMonth/10, 1);</span>
<span class="line-removed">2311           g_array_append_vals (result, digits + systemtime.wMonth%10, 1);</span>
<span class="line-removed">2312           g_array_append_vals (result, L&quot;/&quot;, 1);</span>
<span class="line-removed">2313           g_array_append_vals (result, digits + systemtime.wDay/10, 1);</span>
<span class="line-removed">2314           g_array_append_vals (result, digits + systemtime.wDay%10, 1);</span>
<span class="line-removed">2315           g_array_append_vals (result, L&quot;/&quot;, 1);</span>
<span class="line-removed">2316           g_array_append_vals (result, digits + (systemtime.wYear/10)%10, 1);</span>
<span class="line-removed">2317           g_array_append_vals (result, digits + systemtime.wYear%10, 1);</span>
<span class="line-removed">2318           break;</span>
<span class="line-removed">2319         case &#39;e&#39;:</span>
<span class="line-removed">2320           if (systemtime.wDay &gt;= 10)</span>
<span class="line-removed">2321         g_array_append_vals (result, digits + systemtime.wDay/10, 1);</span>
<span class="line-removed">2322           else</span>
2323         g_array_append_vals (result, L&quot; &quot;, 1);
<span class="line-modified">2324           g_array_append_vals (result, digits + systemtime.wDay%10, 1);</span>
<span class="line-modified">2325           break;</span>
<span class="line-modified">2326 </span>
<span class="line-modified">2327           /* A GDate has no time fields, so for now we can</span>
<span class="line-modified">2328            * hardcode all time conversions into zeros (or 12 for</span>
<span class="line-modified">2329            * %I). The alternative code snippets in the #else</span>
<span class="line-modified">2330            * branches are here ready to be taken into use when</span>
<span class="line-modified">2331            * needed by a g_strftime() or g_date_and_time_format()</span>
<span class="line-modified">2332            * or whatever.</span>
<span class="line-modified">2333            */</span>
<span class="line-modified">2334         case &#39;H&#39;:</span>































2335 #if 1
<span class="line-modified">2336           g_array_append_vals (result, L&quot;00&quot;, 2);</span>
2337 #else
<span class="line-modified">2338           g_array_append_vals (result, digits + systemtime.wHour/10, 1);</span>
<span class="line-modified">2339           g_array_append_vals (result, digits + systemtime.wHour%10, 1);</span>
2340 #endif
<span class="line-modified">2341           break;</span>
<span class="line-modified">2342         case &#39;I&#39;:</span>
2343 #if 1
<span class="line-removed">2344           g_array_append_vals (result, L&quot;12&quot;, 2);</span>
<span class="line-removed">2345 #else</span>
<span class="line-removed">2346           if (systemtime.wHour == 0)</span>
2347         g_array_append_vals (result, L&quot;12&quot;, 2);
<span class="line-modified">2348           else</span>
<span class="line-modified">2349         {</span>
<span class="line-modified">2350           g_array_append_vals (result, digits + (systemtime.wHour%12)/10, 1);</span>
<span class="line-modified">2351           g_array_append_vals (result, digits + (systemtime.wHour%12)%10, 1);</span>
<span class="line-modified">2352         }</span>



2353 #endif
<span class="line-modified">2354           break;</span>
<span class="line-modified">2355         case  &#39;j&#39;:</span>
<span class="line-modified">2356           g_array_append_vals (result, digits + (tm-&gt;tm_yday+1)/100, 1);</span>
<span class="line-modified">2357           g_array_append_vals (result, digits + ((tm-&gt;tm_yday+1)/10)%10, 1);</span>
<span class="line-modified">2358           g_array_append_vals (result, digits + (tm-&gt;tm_yday+1)%10, 1);</span>
<span class="line-modified">2359           break;</span>
<span class="line-modified">2360         case &#39;m&#39;:</span>
<span class="line-modified">2361           g_array_append_vals (result, digits + systemtime.wMonth/10, 1);</span>
<span class="line-modified">2362           g_array_append_vals (result, digits + systemtime.wMonth%10, 1);</span>
<span class="line-modified">2363           break;</span>
<span class="line-modified">2364         case &#39;M&#39;:</span>
2365 #if 1
<span class="line-modified">2366           g_array_append_vals (result, L&quot;00&quot;, 2);</span>
2367 #else
<span class="line-modified">2368           g_array_append_vals (result, digits + systemtime.wMinute/10, 1);</span>
<span class="line-modified">2369           g_array_append_vals (result, digits + systemtime.wMinute%10, 1);</span>
2370 #endif
<span class="line-modified">2371           break;</span>
<span class="line-modified">2372         case &#39;n&#39;:</span>
<span class="line-modified">2373           g_array_append_vals (result, L&quot;\n&quot;, 1);</span>
<span class="line-modified">2374           break;</span>
<span class="line-modified">2375         case &#39;p&#39;:</span>
<span class="line-modified">2376           n = GetTimeFormatW (lcid, 0, &amp;systemtime, L&quot;tt&quot;, NULL, 0);</span>
<span class="line-modified">2377           if (n &gt; 0)</span>
<span class="line-modified">2378         {</span>
<span class="line-modified">2379           g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2380           GetTimeFormatW (lcid, 0, &amp;systemtime, L&quot;tt&quot;, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2381           g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-modified">2382         }</span>
<span class="line-modified">2383           break;</span>
<span class="line-modified">2384         case &#39;r&#39;:</span>
<span class="line-modified">2385           /* This is a rather odd format. Hard to say what to do.</span>
<span class="line-modified">2386            * Let&#39;s always use the POSIX %I:%M:%S %p</span>
<span class="line-modified">2387            */</span>
2388 #if 1
<span class="line-modified">2389           g_array_append_vals (result, L&quot;12:00:00&quot;, 8);</span>
2390 #else
<span class="line-modified">2391           if (systemtime.wHour == 0)</span>
<span class="line-modified">2392         g_array_append_vals (result, L&quot;12&quot;, 2);</span>
<span class="line-modified">2393           else</span>
<span class="line-modified">2394         {</span>
<span class="line-modified">2395           g_array_append_vals (result, digits + (systemtime.wHour%12)/10, 1);</span>
<span class="line-modified">2396           g_array_append_vals (result, digits + (systemtime.wHour%12)%10, 1);</span>
<span class="line-modified">2397         }</span>
<span class="line-modified">2398           g_array_append_vals (result, L&quot;:&quot;, 1);</span>
<span class="line-modified">2399           g_array_append_vals (result, digits + systemtime.wMinute/10, 1);</span>
<span class="line-modified">2400           g_array_append_vals (result, digits + systemtime.wMinute%10, 1);</span>
<span class="line-modified">2401           g_array_append_vals (result, L&quot;:&quot;, 1);</span>
<span class="line-modified">2402           g_array_append_vals (result, digits + systemtime.wSecond/10, 1);</span>
<span class="line-modified">2403           g_array_append_vals (result, digits + systemtime.wSecond%10, 1);</span>
<span class="line-modified">2404           g_array_append_vals (result, L&quot; &quot;, 1);</span>
2405 #endif
<span class="line-modified">2406           n = GetTimeFormatW (lcid, 0, &amp;systemtime, L&quot;tt&quot;, NULL, 0);</span>
<span class="line-modified">2407           if (n &gt; 0)</span>
<span class="line-modified">2408         {</span>
<span class="line-modified">2409           g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2410           GetTimeFormatW (lcid, 0, &amp;systemtime, L&quot;tt&quot;, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2411           g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-modified">2412         }</span>
<span class="line-modified">2413           break;</span>
<span class="line-modified">2414         case &#39;R&#39;:</span>
2415 #if 1
<span class="line-modified">2416           g_array_append_vals (result, L&quot;00:00&quot;, 5);</span>
2417 #else
<span class="line-modified">2418           g_array_append_vals (result, digits + systemtime.wHour/10, 1);</span>
<span class="line-modified">2419           g_array_append_vals (result, digits + systemtime.wHour%10, 1);</span>
<span class="line-modified">2420           g_array_append_vals (result, L&quot;:&quot;, 1);</span>
<span class="line-modified">2421           g_array_append_vals (result, digits + systemtime.wMinute/10, 1);</span>
<span class="line-modified">2422           g_array_append_vals (result, digits + systemtime.wMinute%10, 1);</span>
2423 #endif
<span class="line-modified">2424           break;</span>
<span class="line-modified">2425         case &#39;S&#39;:</span>
2426 #if 1
<span class="line-modified">2427           g_array_append_vals (result, L&quot;00&quot;, 2);</span>
2428 #else
<span class="line-modified">2429           g_array_append_vals (result, digits + systemtime.wSecond/10, 1);</span>
<span class="line-modified">2430           g_array_append_vals (result, digits + systemtime.wSecond%10, 1);</span>
2431 #endif
<span class="line-modified">2432           break;</span>
<span class="line-modified">2433         case &#39;t&#39;:</span>
<span class="line-modified">2434           g_array_append_vals (result, L&quot;\t&quot;, 1);</span>
<span class="line-modified">2435           break;</span>
<span class="line-modified">2436         case &#39;T&#39;:</span>
2437 #if 1
<span class="line-modified">2438           g_array_append_vals (result, L&quot;00:00:00&quot;, 8);</span>
2439 #else
<span class="line-modified">2440           g_array_append_vals (result, digits + systemtime.wHour/10, 1);</span>
<span class="line-modified">2441           g_array_append_vals (result, digits + systemtime.wHour%10, 1);</span>
<span class="line-modified">2442           g_array_append_vals (result, L&quot;:&quot;, 1);</span>
<span class="line-modified">2443           g_array_append_vals (result, digits + systemtime.wMinute/10, 1);</span>
<span class="line-modified">2444           g_array_append_vals (result, digits + systemtime.wMinute%10, 1);</span>
<span class="line-modified">2445           g_array_append_vals (result, L&quot;:&quot;, 1);</span>
<span class="line-modified">2446           g_array_append_vals (result, digits + systemtime.wSecond/10, 1);</span>
<span class="line-modified">2447           g_array_append_vals (result, digits + systemtime.wSecond%10, 1);</span>
2448 #endif
<span class="line-modified">2449           break;</span>
<span class="line-modified">2450         case &#39;u&#39;:</span>
<span class="line-modified">2451           if (systemtime.wDayOfWeek == 0)</span>
<span class="line-modified">2452         g_array_append_vals (result, L&quot;7&quot;, 1);</span>
<span class="line-modified">2453           else</span>













2454         g_array_append_vals (result, digits + systemtime.wDayOfWeek, 1);
<span class="line-modified">2455           break;</span>
<span class="line-modified">2456         case &#39;U&#39;:</span>
<span class="line-modified">2457           n = g_date_get_sunday_week_of_year (d);</span>
<span class="line-modified">2458           g_array_append_vals (result, digits + n/10, 1);</span>
<span class="line-modified">2459           g_array_append_vals (result, digits + n%10, 1);</span>
<span class="line-modified">2460           break;</span>
<span class="line-modified">2461         case &#39;V&#39;:</span>
<span class="line-modified">2462           n = g_date_get_iso8601_week_of_year (d);</span>
<span class="line-modified">2463           g_array_append_vals (result, digits + n/10, 1);</span>
<span class="line-modified">2464           g_array_append_vals (result, digits + n%10, 1);</span>
<span class="line-modified">2465           break;</span>
<span class="line-modified">2466         case &#39;w&#39;:</span>
<span class="line-modified">2467           g_array_append_vals (result, digits + systemtime.wDayOfWeek, 1);</span>
<span class="line-removed">2468           break;</span>
<span class="line-removed">2469         case &#39;W&#39;:</span>
<span class="line-removed">2470           n = g_date_get_monday_week_of_year (d);</span>
<span class="line-removed">2471           g_array_append_vals (result, digits + n/10, 1);</span>
<span class="line-removed">2472           g_array_append_vals (result, digits + n%10, 1);</span>
<span class="line-removed">2473           break;</span>
<span class="line-removed">2474         case &#39;x&#39;:</span>
<span class="line-removed">2475           n = GetDateFormatW (lcid, 0, &amp;systemtime, NULL, NULL, 0);</span>
<span class="line-removed">2476           if (n &gt; 0)</span>
<span class="line-removed">2477         {</span>
<span class="line-removed">2478           g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-removed">2479           GetDateFormatW (lcid, 0, &amp;systemtime, NULL, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-removed">2480           g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-removed">2481         }</span>
<span class="line-removed">2482           break;</span>
<span class="line-removed">2483         case &#39;X&#39;:</span>
<span class="line-removed">2484           n = GetTimeFormatW (lcid, 0, &amp;systemtime, NULL, NULL, 0);</span>
<span class="line-removed">2485           if (n &gt; 0)</span>
<span class="line-removed">2486         {</span>
<span class="line-removed">2487           g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-removed">2488           GetTimeFormatW (lcid, 0, &amp;systemtime, NULL, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-removed">2489           g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-removed">2490         }</span>
<span class="line-removed">2491           break;</span>
<span class="line-removed">2492         case &#39;y&#39;:</span>
<span class="line-removed">2493           g_array_append_vals (result, digits + (systemtime.wYear/10)%10, 1);</span>
<span class="line-removed">2494           g_array_append_vals (result, digits + systemtime.wYear%10, 1);</span>
<span class="line-removed">2495           break;</span>
<span class="line-removed">2496         case &#39;Y&#39;:</span>
<span class="line-removed">2497           g_array_append_vals (result, digits + systemtime.wYear/1000, 1);</span>
<span class="line-removed">2498           g_array_append_vals (result, digits + (systemtime.wYear/100)%10, 1);</span>
<span class="line-removed">2499           g_array_append_vals (result, digits + (systemtime.wYear/10)%10, 1);</span>
<span class="line-removed">2500           g_array_append_vals (result, digits + systemtime.wYear%10, 1);</span>
<span class="line-removed">2501           break;</span>
<span class="line-removed">2502         case &#39;Z&#39;:</span>
<span class="line-removed">2503           n = GetTimeZoneInformation (&amp;tzinfo);</span>
<span class="line-removed">2504           if (n == TIME_ZONE_ID_UNKNOWN)</span>
<span class="line-removed">2505         ;</span>
<span class="line-removed">2506           else if (n == TIME_ZONE_ID_STANDARD)</span>
<span class="line-removed">2507         g_array_append_vals (result, tzinfo.StandardName, wcslen (tzinfo.StandardName));</span>
<span class="line-removed">2508           else if (n == TIME_ZONE_ID_DAYLIGHT)</span>
<span class="line-removed">2509         g_array_append_vals (result, tzinfo.DaylightName, wcslen (tzinfo.DaylightName));</span>
<span class="line-removed">2510           break;</span>
<span class="line-removed">2511         case &#39;%&#39;:</span>
<span class="line-removed">2512           g_array_append_vals (result, L&quot;%&quot;, 1);</span>
<span class="line-removed">2513           break;</span>
<span class="line-removed">2514         }</span>
2515     }
<span class="line-modified">2516       else if (c &lt;= 0xFFFF)</span>



2517     {
<span class="line-modified">2518       wchar_t wc = c;</span>
<span class="line-modified">2519       g_array_append_vals (result, &amp;wc, 1);</span>

2520     }






























2521       else
<span class="line-modified">2522     {</span>
<span class="line-modified">2523       glong nwc;</span>
<span class="line-modified">2524       wchar_t *ws;</span>
2525 
<span class="line-modified">2526       ws = g_ucs4_to_utf16 (&amp;c, 1, NULL, &amp;nwc, NULL);</span>
<span class="line-modified">2527       g_array_append_vals (result, ws, nwc);</span>
<span class="line-modified">2528       g_free (ws);</span>
<span class="line-modified">2529     }</span>
2530       p = g_utf8_next_char (p);
2531     }
2532 
2533   convbuf = g_utf16_to_utf8 ((wchar_t *) result-&gt;data, result-&gt;len, NULL, &amp;convlen, NULL);
2534   g_array_free (result, TRUE);
2535 
2536   if (!convbuf)
2537     {
2538       s[0] = &#39;\0&#39;;
2539       return 0;
2540     }
2541 
2542   if (slen &lt;= convlen)
2543     {
2544       /* Ensure only whole characters are copied into the buffer. */
2545       gchar *end = g_utf8_find_prev_char (convbuf, convbuf + slen);
2546       g_assert (end != NULL);
2547       convlen = end - convbuf;
2548 
2549       /* Return 0 because the buffer isn&#39;t large enough. */
</pre>
<hr />
<pre>
2567  * @slen: buffer size
2568  * @format: format string
2569  * @date: valid #GDate
2570  *
2571  * Generates a printed representation of the date, in a
2572  * [locale][setlocale]-specific way.
2573  * Works just like the platform&#39;s C library strftime() function,
2574  * but only accepts date-related formats; time-related formats
2575  * give undefined results. Date must be valid. Unlike strftime()
2576  * (which uses the locale encoding), works on a UTF-8 format
2577  * string and stores a UTF-8 result.
2578  *
2579  * This function does not provide any conversion specifiers in
2580  * addition to those implemented by the platform&#39;s C library.
2581  * For example, don&#39;t expect that using g_date_strftime() would
2582  * make the \%F provided by the C99 strftime() work on Windows
2583  * where the C library only complies to C89.
2584  *
2585  * Returns: number of characters written to the buffer, or 0 the buffer was too small
2586  */






2587 #pragma GCC diagnostic push
2588 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;

2589 
2590 gsize
2591 g_date_strftime (gchar       *s,
2592                  gsize        slen,
2593                  const gchar *format,
2594                  const GDate *d)
2595 {
2596   struct tm tm;
2597 #ifndef G_OS_WIN32
2598   gsize locale_format_len = 0;
2599   gchar *locale_format;
2600   gsize tmplen;
2601   gchar *tmpbuf;
2602   gsize tmpbufsize;
2603   gsize convlen = 0;
2604   gchar *convbuf;
2605   GError *error = NULL;
2606   gsize retval;
2607 #endif
2608 
</pre>
<hr />
<pre>
2685        */
2686       gchar *end = g_utf8_find_prev_char (convbuf, convbuf + slen);
2687       g_assert (end != NULL);
2688       convlen = end - convbuf;
2689 
2690       /* Return 0 because the buffer isn&#39;t large enough.
2691        */
2692       retval = 0;
2693     }
2694   else
2695     retval = convlen;
2696 
2697   memcpy (s, convbuf, convlen);
2698   s[convlen] = &#39;\0&#39;;
2699   g_free (convbuf);
2700 
2701   return retval;
2702 #endif
2703 }
2704 


2705 #pragma GCC diagnostic pop




</pre>
</td>
<td>
<hr />
<pre>
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;glibconfig.h&quot;
  31 
<span class="line-modified">  32 #define DEBUG_MSG(x)  /* */</span>
  33 #ifdef G_ENABLE_DEBUG
  34 /* #define DEBUG_MSG(args)  g_message args ; */
  35 #endif
  36 
  37 #include &lt;time.h&gt;
  38 #include &lt;string.h&gt;
  39 #include &lt;stdlib.h&gt;
  40 #include &lt;locale.h&gt;
  41 
  42 #ifdef G_OS_WIN32
  43 #include &lt;windows.h&gt;
  44 #endif
  45 
  46 #include &quot;gdate.h&quot;
  47 
  48 #include &quot;gconvert.h&quot;
  49 #include &quot;gmem.h&quot;
  50 #include &quot;gstrfuncs.h&quot;
  51 #include &quot;gtestutils.h&quot;
  52 #include &quot;gthread.h&quot;
</pre>
<hr />
<pre>
 101  *
 102  * GLib also features #GDateTime which represents a precise time.
 103  */
 104 
 105 /**
 106  * G_USEC_PER_SEC:
 107  *
 108  * Number of microseconds in one second (1 million).
 109  * This macro is provided for code readability.
 110  */
 111 
 112 /**
 113  * GTimeVal:
 114  * @tv_sec: seconds
 115  * @tv_usec: microseconds
 116  *
 117  * Represents a precise time, with seconds and microseconds.
 118  * Similar to the struct timeval returned by the gettimeofday()
 119  * UNIX system call.
 120  *
<span class="line-modified"> 121  * GLib is attempting to unify around the use of 64-bit integers to</span>
 122  * represent microsecond-precision time. As such, this type will be
 123  * removed from a future version of GLib. A consequence of using `glong` for
 124  * `tv_sec` is that on 32-bit systems `GTimeVal` is subject to the year 2038
 125  * problem.
<span class="line-added"> 126  *</span>
<span class="line-added"> 127  * Deprecated: 2.62: Use #GDateTime or #guint64 instead.</span>
 128  */
 129 
 130 /**
 131  * GDate:
 132  * @julian_days: the Julian representation of the date
 133  * @julian: this bit is set if @julian_days is valid
 134  * @dmy: this is set if @day, @month and @year are valid
 135  * @day: the day of the day-month-year representation of the date,
 136  *     as a number between 1 and 31
 137  * @month: the day of the day-month-year representation of the date,
 138  *     as a number between 1 and 12
 139  * @year: the day of the day-month-year representation of the date
 140  *
 141  * Represents a day between January 1, Year 1 and a few thousand years in
 142  * the future. None of its members should be accessed directly.
 143  *
 144  * If the #GDate-struct is obtained from g_date_new(), it will be safe
 145  * to mutate but invalid and thus not safe for calendrical computations.
 146  *
 147  * If it&#39;s declared on the stack, it will contain garbage so must be
 148  * initialized with g_date_clear(). g_date_clear() makes the date invalid
 149  * but sane. An invalid date doesn&#39;t represent a day, it&#39;s &quot;empty.&quot; A date
 150  * becomes valid after you set it to a Julian day or you set a day, month,
 151  * and year.
 152  */
 153 
 154 /**
 155  * GTime:
 156  *
<span class="line-modified"> 157  * Simply a replacement for `time_t`. It has been deprecated</span>
<span class="line-modified"> 158  * since it is not equivalent to `time_t` on 64-bit platforms</span>
<span class="line-modified"> 159  * with a 64-bit `time_t`. Unrelated to #GTimer.</span>
 160  *
 161  * Note that #GTime is defined to always be a 32-bit integer,
<span class="line-modified"> 162  * unlike `time_t` which may be 64-bit on some systems. Therefore,</span>
 163  * #GTime will overflow in the year 2038, and you cannot use the
 164  * address of a #GTime variable as argument to the UNIX time()
 165  * function.
 166  *
 167  * Instead, do the following:
 168  * |[&lt;!-- language=&quot;C&quot; --&gt;
 169  * time_t ttime;
 170  * GTime gtime;
 171  *
 172  * time (&amp;ttime);
 173  * gtime = (GTime)ttime;
 174  * ]|
<span class="line-added"> 175  *</span>
<span class="line-added"> 176  * Deprecated: 2.62: This is not [Y2038-safe](https://en.wikipedia.org/wiki/Year_2038_problem).</span>
<span class="line-added"> 177  *    Use #GDateTime or #time_t instead.</span>
 178  */
 179 
 180 /**
 181  * GDateDMY:
 182  * @G_DATE_DAY: a day
 183  * @G_DATE_MONTH: a month
 184  * @G_DATE_YEAR: a year
 185  *
 186  * This enumeration isn&#39;t used in the API, but may be useful if you need
 187  * to mark a number as a day, month, or year.
 188  */
 189 
 190 /**
 191  * GDateDay:
 192  *
 193  * Integer representing a day of the month; between 1 and 31.
 194  * #G_DATE_BAD_DAY represents an invalid day of the month.
 195  */
 196 
 197 /**
</pre>
<hr />
<pre>
 482 g_date_valid_julian (guint32 j)
 483 {
 484   return (j &gt; G_DATE_BAD_JULIAN);
 485 }
 486 
 487 /**
 488  * g_date_valid_dmy:
 489  * @day: day
 490  * @month: month
 491  * @year: year
 492  *
 493  * Returns %TRUE if the day-month-year triplet forms a valid, existing day
 494  * in the range of days #GDate understands (Year 1 or later, no more than
 495  * a few thousand years in the future).
 496  *
 497  * Returns: %TRUE if the date is a valid one
 498  */
 499 gboolean
 500 g_date_valid_dmy (GDateDay   d,
 501                   GDateMonth m,
<span class="line-modified"> 502       GDateYear  y)</span>
 503 {
 504   /* No need to check the upper bound of @y, because #GDateYear is 16 bits wide,
 505    * just like #GDate.year. */
 506   return ( (m &gt; G_DATE_BAD_MONTH) &amp;&amp;
 507            (m &lt; 13)               &amp;&amp;
 508            (d &gt; G_DATE_BAD_DAY)   &amp;&amp;
 509            (y &gt; G_DATE_BAD_YEAR)  &amp;&amp;   /* must check before using g_date_is_leap_year */
 510            (d &lt;=  (g_date_is_leap_year (y) ?
<span class="line-modified"> 511        days_in_months[1][m] : days_in_months[0][m])) );</span>
 512 }
 513 
 514 
 515 /* &quot;Julian days&quot; just means an absolute number of days, where Day 1 ==
 516  *   Jan 1, Year 1
 517  */
 518 static void
 519 g_date_update_julian (const GDate *const_d)
 520 {
 521   GDate *d = (GDate *) const_d;
 522   GDateYear year;
 523   gint idx;
 524 
 525   g_return_if_fail (d != NULL);
 526   g_return_if_fail (d-&gt;dmy != 0);
 527   g_return_if_fail (!d-&gt;julian);
 528   g_return_if_fail (g_date_valid_dmy (d-&gt;day, d-&gt;month, d-&gt;year));
 529 
 530   /* What we actually do is: multiply years * 365 days in the year,
 531    * add the number of years divided by 4, subtract the number of
</pre>
<hr />
<pre>
 570    *  1,721,425 to the number of days before doing the formula.
 571    *
 572    * I&#39;m sure this can be simplified for our 1 January 1 AD period
 573    * start, but I can&#39;t figure out how to unpack the formula.
 574    */
 575 
 576   A = d-&gt;julian_days + 1721425 + 32045;
 577   B = ( 4 *(A + 36524) )/ 146097 - 1;
 578   C = A - (146097 * B)/4;
 579   D = ( 4 * (C + 365) ) / 1461 - 1;
 580   E = C - ((1461*D) / 4);
 581   M = (5 * (E - 1) + 2)/153;
 582 
 583   m = M + 3 - (12*(M/10));
 584   day = E - (153*M + 2)/5;
 585   y = 100 * B + D - 4800 + (M/10);
 586 
 587 #ifdef G_ENABLE_DEBUG
 588   if (!g_date_valid_dmy (day, m, y))
 589     g_warning (&quot;OOPS julian: %u  computed dmy: %u %u %u&quot;,
<span class="line-modified"> 590          d-&gt;julian_days, day, m, y);</span>
 591 #endif
 592 
 593   d-&gt;month = m;
 594   d-&gt;day   = day;
 595   d-&gt;year  = y;
 596 
 597   d-&gt;dmy = TRUE;
 598 }
 599 
 600 /**
 601  * g_date_get_weekday:
 602  * @date: a #GDate
 603  *
 604  * Returns the day of the week for a #GDate. The date must be valid.
 605  *
 606  * Returns: day of the week as a #GDateWeekday.
 607  */
 608 GDateWeekday
 609 g_date_get_weekday (const GDate *d)
 610 {
</pre>
<hr />
<pre>
 832   L  = d4 / 1460;
 833   d1 = ((d4 - L) % 365) + L;
 834   w  = d1 / 7 + 1;
 835 
 836   return w;
 837 }
 838 
 839 /**
 840  * g_date_days_between:
 841  * @date1: the first date
 842  * @date2: the second date
 843  *
 844  * Computes the number of days between two dates.
 845  * If @date2 is prior to @date1, the returned value is negative.
 846  * Both dates must be valid.
 847  *
 848  * Returns: the number of days between @date1 and @date2
 849  */
 850 gint
 851 g_date_days_between (const GDate *d1,
<span class="line-modified"> 852          const GDate *d2)</span>
 853 {
 854   g_return_val_if_fail (g_date_valid (d1), 0);
 855   g_return_val_if_fail (g_date_valid (d2), 0);
 856 
 857   return (gint)g_date_get_julian (d2) - (gint)g_date_get_julian (d1);
 858 }
 859 
 860 /**
 861  * g_date_clear:
 862  * @date: pointer to one or more dates to clear
 863  * @n_dates: number of dates to clear
 864  *
 865  * Initializes one or more #GDate structs to a sane but invalid
 866  * state. The cleared dates will not represent an existing date, but will
 867  * not contain garbage. Useful to init a date declared on the stack.
 868  * Validity can be tested with g_date_valid().
 869  */
 870 void
 871 g_date_clear (GDate *d, guint ndates)
 872 {
</pre>
<hr />
<pre>
1007       gsize longest = 0;
1008       gchar *casefold;
1009       gchar *normalized;
1010 
1011       casefold = g_utf8_casefold (str, -1);
1012       normalized = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
1013       g_free (casefold);
1014 
1015       for (i = 1; i &lt; 13; ++i)
1016         {
1017           /* Here month names may be in a genitive case if the language
1018            * grammatical rules require it.
1019            * Examples of how January may look in some languages:
1020            * Catalan: &quot;de gener&quot;, Croatian: &quot;gener&quot;, Polish: &quot;gener&quot;,
1021            * Upper Sorbian: &quot;januara&quot;.
1022            * Note that most of the languages can&#39;t or don&#39;t use the the
1023            * genitive case here so they use nominative everywhere.
1024            * For example, English always uses &quot;January&quot;.
1025            */
1026           if (update_month_match (&amp;longest, normalized, long_month_names[i]))
<span class="line-modified">1027             pt-&gt;month = i;</span>
1028 
1029           /* Here month names will be in a nominative case.
1030            * Examples of how January may look in some languages:
1031            * Catalan: &quot;gener&quot;, Croatian: &quot;gener&quot;, Polish: &quot;gener&quot;,
1032            * Upper Sorbian: &quot;Januar&quot;.
1033            */
1034           if (update_month_match (&amp;longest, normalized, long_month_names_alternative[i]))
<span class="line-modified">1035             pt-&gt;month = i;</span>
1036 
1037           /* Differences between abbreviated nominative and abbreviated
1038            * genitive month names are visible in very few languages but
1039            * let&#39;s handle them.
1040            */
1041           if (update_month_match (&amp;longest, normalized, short_month_names[i]))
<span class="line-modified">1042             pt-&gt;month = i;</span>
1043 
1044           if (update_month_match (&amp;longest, normalized, short_month_names_alternative[i]))
<span class="line-modified">1045             pt-&gt;month = i;</span>
<span class="line-modified">1046         }</span>
1047 
1048       g_free (normalized);
1049     }
1050 }
1051 
1052 /* HOLDS: g_date_global_lock */
1053 static void
1054 g_date_prepare_to_parse (const gchar      *str,
1055                          GDateParseTokens *pt)
1056 {
1057   const gchar *locale = setlocale (LC_TIME, NULL);
1058   gboolean recompute_localeinfo = FALSE;
1059   GDate d;
1060 
1061   g_return_if_fail (locale != NULL); /* should not happen */
1062 
1063   g_date_clear (&amp;d, 1);              /* clear for scratch use */
1064 
1065   if ( (current_locale == NULL) || (strcmp (locale, current_locale) != 0) )
1066     recompute_localeinfo = TRUE;  /* Uh, there used to be a reason for the temporary */
1067 
1068   if (recompute_localeinfo)
1069     {
1070       int i = 1;
1071       GDateParseTokens testpt;
1072       gchar buf[128];
1073 
1074       g_free (current_locale); /* still works if current_locale == NULL */
1075 
1076       current_locale = g_strdup (locale);
1077 
1078       short_month_names[0] = &quot;Error&quot;;
1079       long_month_names[0] = &quot;Error&quot;;
1080 
1081       while (i &lt; 13)
1082         {
<span class="line-modified">1083     gchar *casefold;</span>
1084 
1085           g_date_set_dmy (&amp;d, 1, i, 1976);
1086 
1087           g_return_if_fail (g_date_valid (&amp;d));
1088 
1089           g_date_strftime (buf, 127, &quot;%b&quot;, &amp;d);
1090 
<span class="line-modified">1091     casefold = g_utf8_casefold (buf, -1);</span>
1092           g_free (short_month_names[i]);
1093           short_month_names[i] = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
<span class="line-modified">1094     g_free (casefold);</span>
1095 
1096           g_date_strftime (buf, 127, &quot;%B&quot;, &amp;d);
<span class="line-modified">1097     casefold = g_utf8_casefold (buf, -1);</span>
1098           g_free (long_month_names[i]);
1099           long_month_names[i] = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
<span class="line-modified">1100     g_free (casefold);</span>
1101 
1102           g_date_strftime (buf, 127, &quot;%Ob&quot;, &amp;d);
1103           casefold = g_utf8_casefold (buf, -1);
1104           g_free (short_month_names_alternative[i]);
1105           short_month_names_alternative[i] = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
1106           g_free (casefold);
1107 
1108           g_date_strftime (buf, 127, &quot;%OB&quot;, &amp;d);
1109           casefold = g_utf8_casefold (buf, -1);
1110           g_free (long_month_names_alternative[i]);
1111           long_month_names_alternative[i] = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
1112           g_free (casefold);
1113 
1114           ++i;
1115         }
1116 
1117       /* Determine DMY order */
1118 
1119       /* had to pick a random day - don&#39;t change this, some strftimes
1120        * are broken on some days, and this one is good so far. */
</pre>
<hr />
<pre>
1155           ++i;
1156         }
1157 
1158 #if defined(G_ENABLE_DEBUG) &amp;&amp; 0
1159       DEBUG_MSG ((&quot;**GDate prepared a new set of locale-specific parse rules.&quot;));
1160       i = 1;
1161       while (i &lt; 13)
1162         {
1163           DEBUG_MSG ((&quot;  %s   %s&quot;, long_month_names[i], short_month_names[i]));
1164           ++i;
1165         }
1166       DEBUG_MSG ((&quot;Alternative month names:&quot;));
1167       i = 1;
1168       while (i &lt; 13)
1169         {
1170           DEBUG_MSG ((&quot;  %s   %s&quot;, long_month_names_alternative[i], short_month_names_alternative[i]));
1171           ++i;
1172         }
1173       if (using_twodigit_years)
1174         {
<span class="line-modified">1175     DEBUG_MSG ((&quot;**Using twodigit years with cutoff year: %u&quot;, twodigit_start_year));</span>
1176         }
1177       {
1178         gchar *strings[3];
1179         i = 0;
1180         while (i &lt; 3)
1181           {
1182             switch (dmy_order[i])
1183               {
1184               case G_DATE_MONTH:
1185                 strings[i] = &quot;Month&quot;;
1186                 break;
1187               case G_DATE_YEAR:
1188                 strings[i] = &quot;Year&quot;;
1189                 break;
1190               case G_DATE_DAY:
1191                 strings[i] = &quot;Day&quot;;
1192                 break;
1193               default:
1194                 strings[i] = NULL;
1195                 break;
</pre>
<hr />
<pre>
1222  * means by a given string (and it does work pretty well in that
1223  * capacity).
1224  */
1225 void
1226 g_date_set_parse (GDate       *d,
1227                   const gchar *str)
1228 {
1229   GDateParseTokens pt;
1230   guint m = G_DATE_BAD_MONTH, day = G_DATE_BAD_DAY, y = G_DATE_BAD_YEAR;
1231 
1232   g_return_if_fail (d != NULL);
1233 
1234   /* set invalid */
1235   g_date_clear (d, 1);
1236 
1237   G_LOCK (g_date_global);
1238 
1239   g_date_prepare_to_parse (str, &amp;pt);
1240 
1241   DEBUG_MSG ((&quot;Found %d ints, &#39;%d&#39; &#39;%d&#39; &#39;%d&#39; and written out month %d&quot;,
<span class="line-modified">1242         pt.num_ints, pt.n[0], pt.n[1], pt.n[2], pt.month));</span>
1243 
1244 
1245   if (pt.num_ints == 4)
1246     {
1247       G_UNLOCK (g_date_global);
1248       return; /* presumably a typo; bail out. */
1249     }
1250 
1251   if (pt.num_ints &gt; 1)
1252     {
1253       int i = 0;
1254       int j = 0;
1255 
1256       g_assert (pt.num_ints &lt; 4); /* i.e., it is 2 or 3 */
1257 
1258       while (i &lt; pt.num_ints &amp;&amp; j &lt; 3)
1259         {
1260           switch (dmy_order[j])
1261             {
1262             case G_DATE_MONTH:
<span class="line-modified">1263       {</span>
<span class="line-modified">1264         if (pt.num_ints == 2 &amp;&amp; pt.month != G_DATE_BAD_MONTH)</span>
<span class="line-modified">1265     {</span>
<span class="line-modified">1266       m = pt.month;</span>
<span class="line-modified">1267       ++j;      /* skip months, but don&#39;t skip this number */</span>
<span class="line-modified">1268       continue;</span>
<span class="line-modified">1269     }</span>
<span class="line-modified">1270         else</span>
<span class="line-modified">1271     m = pt.n[i];</span>
<span class="line-modified">1272       }</span>
<span class="line-modified">1273       break;</span>
1274             case G_DATE_DAY:
<span class="line-modified">1275       {</span>
<span class="line-modified">1276         if (pt.num_ints == 2 &amp;&amp; pt.month == G_DATE_BAD_MONTH)</span>
<span class="line-modified">1277     {</span>
<span class="line-modified">1278       day = 1;</span>
<span class="line-modified">1279       ++j;      /* skip days, since we may have month/year */</span>
<span class="line-modified">1280       continue;</span>
<span class="line-modified">1281     }</span>
<span class="line-modified">1282         day = pt.n[i];</span>
<span class="line-modified">1283       }</span>
<span class="line-modified">1284       break;</span>
1285             case G_DATE_YEAR:
<span class="line-modified">1286       {</span>
<span class="line-modified">1287         y  = pt.n[i];</span>
1288 
<span class="line-modified">1289         if (locale_era_adjust != 0)</span>
<span class="line-modified">1290           {</span>
<span class="line-modified">1291       y += locale_era_adjust;</span>
<span class="line-modified">1292           }</span>
<span class="line-modified">1293         else if (using_twodigit_years &amp;&amp; y &lt; 100)</span>
<span class="line-modified">1294     {</span>
<span class="line-modified">1295       guint two     =  twodigit_start_year % 100;</span>
<span class="line-modified">1296       guint century = (twodigit_start_year / 100) * 100;</span>
1297 
<span class="line-modified">1298       if (y &lt; two)</span>
<span class="line-modified">1299         century += 100;</span>
1300 
<span class="line-modified">1301       y += century;</span>
<span class="line-modified">1302     }</span>
<span class="line-modified">1303       }</span>
<span class="line-modified">1304       break;</span>
1305             default:
1306               break;
1307             }
1308 
1309           ++i;
1310           ++j;
1311         }
1312 
1313 
1314       if (pt.num_ints == 3 &amp;&amp; !g_date_valid_dmy (day, m, y))
1315         {
1316           /* Try YYYY MM DD */
1317           y   = pt.n[0];
1318           m   = pt.n[1];
1319           day = pt.n[2];
1320 
1321           if (using_twodigit_years &amp;&amp; y &lt; 100)
1322             y = G_DATE_BAD_YEAR; /* avoids ambiguity */
1323         }
1324       else if (pt.num_ints == 2)
<span class="line-modified">1325   {</span>
<span class="line-modified">1326     if (m == G_DATE_BAD_MONTH &amp;&amp; pt.month != G_DATE_BAD_MONTH)</span>
<span class="line-modified">1327       m = pt.month;</span>
<span class="line-modified">1328   }</span>
1329     }
1330   else if (pt.num_ints == 1)
1331     {
1332       if (pt.month != G_DATE_BAD_MONTH)
1333         {
1334           /* Month name and year? */
1335           m    = pt.month;
1336           day  = 1;
1337           y = pt.n[0];
1338         }
1339       else
1340         {
1341           /* Try yyyymmdd and yymmdd */
1342 
1343           m   = (pt.n[0]/100) % 100;
1344           day = pt.n[0] % 100;
1345           y   = pt.n[0]/10000;
1346 
1347           /* FIXME move this into a separate function */
1348           if (using_twodigit_years &amp;&amp; y &lt; 100)
</pre>
<hr />
<pre>
1380  * g_date_set_time_t:
1381  * @date: a #GDate
1382  * @timet: time_t value to set
1383  *
1384  * Sets the value of a date to the date corresponding to a time
1385  * specified as a time_t. The time to date conversion is done using
1386  * the user&#39;s current timezone.
1387  *
1388  * To set the value of a date to the current day, you could write:
1389  * |[&lt;!-- language=&quot;C&quot; --&gt;
1390  *  time_t now = time (NULL);
1391  *  if (now == (time_t) -1)
1392  *    // handle the error
1393  *  g_date_set_time_t (date, now);
1394  * ]|
1395  *
1396  * Since: 2.10
1397  */
1398 void
1399 g_date_set_time_t (GDate *date,
<span class="line-modified">1400        time_t timet)</span>
1401 {
1402   struct tm tm;
1403 
1404   g_return_if_fail (date != NULL);
1405 
1406 #ifdef HAVE_LOCALTIME_R
1407   localtime_r (&amp;timet, &amp;tm);
1408 #else
1409   {
1410     struct tm *ptm = localtime (&amp;timet);
1411 
1412     if (ptm == NULL)
1413       {
<span class="line-modified">1414   /* Happens at least in Microsoft&#39;s C library if you pass a</span>
<span class="line-modified">1415    * negative time_t. Use 2000-01-01 as default date.</span>
<span class="line-modified">1416    */</span>
1417 #ifndef G_DISABLE_CHECKS
<span class="line-modified">1418   g_return_if_fail_warning (G_LOG_DOMAIN, &quot;g_date_set_time&quot;, &quot;ptm != NULL&quot;);</span>
1419 #endif
1420 
<span class="line-modified">1421   tm.tm_mon = 0;</span>
<span class="line-modified">1422   tm.tm_mday = 1;</span>
<span class="line-modified">1423   tm.tm_year = 100;</span>
1424       }
1425     else
1426       memcpy ((void *) &amp;tm, (void *) ptm, sizeof(struct tm));
1427   }
1428 #endif
1429 
1430   date-&gt;julian = FALSE;
1431 
1432   date-&gt;month = tm.tm_mon + 1;
1433   date-&gt;day   = tm.tm_mday;
1434   date-&gt;year  = tm.tm_year + 1900;
1435 
1436   g_return_if_fail (g_date_valid_dmy (date-&gt;day, date-&gt;month, date-&gt;year));
1437 
1438   date-&gt;dmy    = TRUE;
1439 }
1440 
1441 
1442 /**
1443  * g_date_set_time:
1444  * @date: a #GDate.
1445  * @time_: #GTime value to set.
1446  *
1447  * Sets the value of a date from a #GTime value.
1448  * The time to date conversion is done using the user&#39;s current timezone.
1449  *
1450  * Deprecated: 2.10: Use g_date_set_time_t() instead.
1451  */
<span class="line-added">1452 G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
1453 void
1454 g_date_set_time (GDate *date,
<span class="line-modified">1455      GTime  time_)</span>
1456 {
1457   g_date_set_time_t (date, (time_t) time_);
1458 }
<span class="line-added">1459 G_GNUC_END_IGNORE_DEPRECATIONS</span>
1460 
1461 /**
1462  * g_date_set_time_val:
1463  * @date: a #GDate
1464  * @timeval: #GTimeVal value to set
1465  *
1466  * Sets the value of a date from a #GTimeVal value.  Note that the
1467  * @tv_usec member is ignored, because #GDate can&#39;t make use of the
1468  * additional precision.
1469  *
1470  * The time to date conversion is done using the user&#39;s current timezone.
1471  *
1472  * Since: 2.10
<span class="line-added">1473  * Deprecated: 2.62: #GTimeVal is not year-2038-safe. Use g_date_set_time_t()</span>
<span class="line-added">1474  *    instead.</span>
1475  */
<span class="line-added">1476 G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
1477 void
1478 g_date_set_time_val (GDate    *date,
<span class="line-modified">1479          GTimeVal *timeval)</span>
1480 {
1481   g_date_set_time_t (date, (time_t) timeval-&gt;tv_sec);
1482 }
<span class="line-added">1483 G_GNUC_END_IGNORE_DEPRECATIONS</span>
1484 
1485 /**
1486  * g_date_set_month:
1487  * @date: a #GDate
1488  * @month: month to set
1489  *
1490  * Sets the month of the year for a #GDate.  If the resulting
1491  * day-month-year triplet is invalid, the date will be invalid.
1492  */
1493 void
1494 g_date_set_month (GDate     *d,
1495                   GDateMonth m)
1496 {
1497   g_return_if_fail (d != NULL);
1498   g_return_if_fail (g_date_valid_month (m));
1499 
1500   if (d-&gt;julian &amp;&amp; !d-&gt;dmy) g_date_update_dmy(d);
1501   d-&gt;julian = FALSE;
1502 
1503   d-&gt;month = m;
</pre>
<hr />
<pre>
1723 void
1724 g_date_add_months (GDate *d,
1725                    guint  nmonths)
1726 {
1727   guint years, months;
1728   gint idx;
1729 
1730   g_return_if_fail (g_date_valid (d));
1731 
1732   if (!d-&gt;dmy)
1733     g_date_update_dmy (d);
1734 
1735   g_return_if_fail (d-&gt;dmy != 0);
1736   g_return_if_fail (nmonths &lt;= G_MAXUINT - (d-&gt;month - 1));
1737 
1738   nmonths += d-&gt;month - 1;
1739 
1740   years  = nmonths/12;
1741   months = nmonths%12;
1742 
<span class="line-modified">1743   g_return_if_fail (years &lt;= (guint) (G_MAXUINT16 - d-&gt;year));</span>
1744 
1745   d-&gt;month = months + 1;
1746   d-&gt;year  += years;
1747 
1748   idx = g_date_is_leap_year (d-&gt;year) ? 1 : 0;
1749 
1750   if (d-&gt;day &gt; days_in_months[idx][d-&gt;month])
1751     d-&gt;day = days_in_months[idx][d-&gt;month];
1752 
1753   d-&gt;julian = FALSE;
1754 
1755   g_return_if_fail (g_date_valid (d));
1756 }
1757 
1758 /**
1759  * g_date_subtract_months:
1760  * @date: a #GDate to decrement
1761  * @n_months: number of months to move
1762  *
1763  * Moves a date some number of months into the past.
</pre>
<hr />
<pre>
1807 /**
1808  * g_date_add_years:
1809  * @date: a #GDate to increment
1810  * @n_years: number of years to move forward
1811  *
1812  * Increments a date by some number of years.
1813  * If the date is February 29, and the destination
1814  * year is not a leap year, the date will be changed
1815  * to February 28. The date must be valid.
1816  */
1817 void
1818 g_date_add_years (GDate *d,
1819                   guint  nyears)
1820 {
1821   g_return_if_fail (g_date_valid (d));
1822 
1823   if (!d-&gt;dmy)
1824     g_date_update_dmy (d);
1825 
1826   g_return_if_fail (d-&gt;dmy != 0);
<span class="line-modified">1827   g_return_if_fail (nyears &lt;= (guint) (G_MAXUINT16 - d-&gt;year));</span>
1828 
1829   d-&gt;year += nyears;
1830 
1831   if (d-&gt;month == 2 &amp;&amp; d-&gt;day == 29)
1832     {
1833       if (!g_date_is_leap_year (d-&gt;year))
1834         d-&gt;day = 28;
1835     }
1836 
1837   d-&gt;julian = FALSE;
1838 }
1839 
1840 /**
1841  * g_date_subtract_years:
1842  * @date: a #GDate to decrement
1843  * @n_years: number of years to move
1844  *
1845  * Moves a date some number of years into the past.
1846  * If the current day doesn&#39;t exist in the destination
1847  * year (i.e. it&#39;s February 29 and you move to a non-leap-year)
</pre>
<hr />
<pre>
2091   tm-&gt;tm_wday = (int)day;
2092 
2093   tm-&gt;tm_yday = g_date_get_day_of_year (d) - 1; /* 0 to 365 */
2094   tm-&gt;tm_isdst = -1; /* -1 means &quot;information not available&quot; */
2095 }
2096 
2097 /**
2098  * g_date_clamp:
2099  * @date: a #GDate to clamp
2100  * @min_date: minimum accepted value for @date
2101  * @max_date: maximum accepted value for @date
2102  *
2103  * If @date is prior to @min_date, sets @date equal to @min_date.
2104  * If @date falls after @max_date, sets @date equal to @max_date.
2105  * Otherwise, @date is unchanged.
2106  * Either of @min_date and @max_date may be %NULL.
2107  * All non-%NULL dates must be valid.
2108  */
2109 void
2110 g_date_clamp (GDate       *date,
<span class="line-modified">2111         const GDate *min_date,</span>
<span class="line-modified">2112         const GDate *max_date)</span>
2113 {
2114   g_return_if_fail (g_date_valid (date));
2115 
2116   if (min_date != NULL)
2117     g_return_if_fail (g_date_valid (min_date));
2118 
2119   if (max_date != NULL)
2120     g_return_if_fail (g_date_valid (max_date));
2121 
2122   if (min_date != NULL &amp;&amp; max_date != NULL)
2123     g_return_if_fail (g_date_compare (min_date, max_date) &lt;= 0);
2124 
2125   if (min_date &amp;&amp; g_date_compare (date, min_date) &lt; 0)
2126     *date = *min_date;
2127 
2128   if (max_date &amp;&amp; g_date_compare (max_date, date) &lt; 0)
2129     *date = *max_date;
2130 }
2131 
2132 /**
</pre>
<hr />
<pre>
2138  * and swap the values if this is not the case.
2139  */
2140 void
2141 g_date_order (GDate *date1,
2142               GDate *date2)
2143 {
2144   g_return_if_fail (g_date_valid (date1));
2145   g_return_if_fail (g_date_valid (date2));
2146 
2147   if (g_date_compare (date1, date2) &gt; 0)
2148     {
2149       GDate tmp = *date1;
2150       *date1 = *date2;
2151       *date2 = tmp;
2152     }
2153 }
2154 
2155 #ifdef G_OS_WIN32
2156 static void
2157 append_month_name (GArray     *result,
<span class="line-modified">2158        LCID        lcid,</span>
<span class="line-modified">2159        SYSTEMTIME *systemtime,</span>
<span class="line-modified">2160        gboolean    abbreviated,</span>
<span class="line-modified">2161        gboolean    alternative)</span>
2162 {
2163   int n;
2164   WORD base;
2165   LPCWSTR lpFormat;
2166 
2167   if (alternative)
2168     {
2169       base = abbreviated ? LOCALE_SABBREVMONTHNAME1 : LOCALE_SMONTHNAME1;
2170       n = GetLocaleInfoW (lcid, base + systemtime-&gt;wMonth - 1, NULL, 0);
2171       g_array_set_size (result, result-&gt;len + n);
2172       GetLocaleInfoW (lcid, base + systemtime-&gt;wMonth - 1,
<span class="line-modified">2173           ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
2174       g_array_set_size (result, result-&gt;len - 1);
2175     }
2176   else
2177     {
2178       /* According to MSDN, this is the correct method to obtain
2179        * the form of the month name used when formatting a full
2180        * date; it must be a genitive case in some languages.
2181        */
2182       lpFormat = abbreviated ? L&quot;ddMMM&quot; : L&quot;ddMMMM&quot;;
2183       n = GetDateFormatW (lcid, 0, systemtime, lpFormat, NULL, 0);
2184       g_array_set_size (result, result-&gt;len + n);
2185       GetDateFormatW (lcid, 0, systemtime, lpFormat,
<span class="line-modified">2186           ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
2187       /* We have obtained a day number as two digits and the month name.
2188        * Now let&#39;s get rid of those two digits: overwrite them with the
2189        * month name.
2190        */
2191       memmove (((wchar_t *) result-&gt;data) + result-&gt;len - n,
<span class="line-modified">2192          ((wchar_t *) result-&gt;data) + result-&gt;len - n + 2,</span>
<span class="line-modified">2193          (n - 2) * sizeof (wchar_t));</span>
2194       g_array_set_size (result, result-&gt;len - 3);
2195     }
2196 }
2197 
2198 static gsize
2199 win32_strftime_helper (const GDate     *d,
<span class="line-modified">2200            const gchar     *format,</span>
<span class="line-modified">2201            const struct tm *tm,</span>
<span class="line-modified">2202            gchar           *s,</span>
<span class="line-modified">2203            gsize          slen)</span>
2204 {
2205   SYSTEMTIME systemtime;
2206   TIME_ZONE_INFORMATION tzinfo;
2207   LCID lcid;
2208   int n, k;
2209   GArray *result;
2210   const gchar *p;
2211   gunichar c, modifier;
2212   const wchar_t digits[] = L&quot;0123456789&quot;;
2213   gchar *convbuf;
2214   glong convlen = 0;
2215   gsize retval;
2216 
2217   systemtime.wYear = tm-&gt;tm_year + 1900;
2218   systemtime.wMonth = tm-&gt;tm_mon + 1;
2219   systemtime.wDayOfWeek = tm-&gt;tm_wday;
2220   systemtime.wDay = tm-&gt;tm_mday;
2221   systemtime.wHour = tm-&gt;tm_hour;
2222   systemtime.wMinute = tm-&gt;tm_min;
2223   systemtime.wSecond = tm-&gt;tm_sec;
2224   systemtime.wMilliseconds = 0;
2225 
2226   lcid = GetThreadLocale ();
2227   result = g_array_sized_new (FALSE, FALSE, sizeof (wchar_t), MAX (128, strlen (format) * 2));
2228 
2229   p = format;
2230   while (*p)
2231     {
2232       c = g_utf8_get_char (p);
2233       if (c == &#39;%&#39;)
<span class="line-modified">2234   {</span>
<span class="line-modified">2235     p = g_utf8_next_char (p);</span>
<span class="line-modified">2236     if (!*p)</span>
<span class="line-modified">2237       {</span>
<span class="line-modified">2238         s[0] = &#39;\0&#39;;</span>
<span class="line-modified">2239         g_array_free (result, TRUE);</span>
2240 
<span class="line-modified">2241         return 0;</span>
<span class="line-modified">2242       }</span>
2243 
<span class="line-modified">2244     modifier = &#39;\0&#39;;</span>
<span class="line-modified">2245     c = g_utf8_get_char (p);</span>
<span class="line-modified">2246     if (c == &#39;E&#39; || c == &#39;O&#39;)</span>
<span class="line-modified">2247       {</span>
<span class="line-modified">2248         /* &quot;%OB&quot;, &quot;%Ob&quot;, and &quot;%Oh&quot; are supported, ignore other modified</span>
<span class="line-modified">2249          * conversion specifiers for now.</span>
<span class="line-modified">2250          */</span>
<span class="line-modified">2251         modifier = c;</span>
<span class="line-modified">2252         p = g_utf8_next_char (p);</span>
<span class="line-modified">2253         if (!*p)</span>
<span class="line-modified">2254     {</span>
<span class="line-modified">2255       s[0] = &#39;\0&#39;;</span>
<span class="line-modified">2256       g_array_free (result, TRUE);</span>
2257 
<span class="line-modified">2258       return 0;</span>
<span class="line-modified">2259     }</span>
2260 
<span class="line-modified">2261         c = g_utf8_get_char (p);</span>
<span class="line-modified">2262       }</span>
2263 
<span class="line-modified">2264     switch (c)</span>
<span class="line-modified">2265       {</span>
<span class="line-modified">2266       case &#39;a&#39;:</span>
<span class="line-modified">2267         if (systemtime.wDayOfWeek == 0)</span>
<span class="line-modified">2268     k = 6;</span>
<span class="line-modified">2269         else</span>
<span class="line-modified">2270     k = systemtime.wDayOfWeek - 1;</span>
<span class="line-modified">2271         n = GetLocaleInfoW (lcid, LOCALE_SABBREVDAYNAME1+k, NULL, 0);</span>
<span class="line-modified">2272         g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2273         GetLocaleInfoW (lcid, LOCALE_SABBREVDAYNAME1+k, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2274         g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-modified">2275         break;</span>
<span class="line-modified">2276       case &#39;A&#39;:</span>
<span class="line-modified">2277         if (systemtime.wDayOfWeek == 0)</span>
<span class="line-modified">2278     k = 6;</span>
<span class="line-modified">2279         else</span>
<span class="line-modified">2280     k = systemtime.wDayOfWeek - 1;</span>
<span class="line-modified">2281         n = GetLocaleInfoW (lcid, LOCALE_SDAYNAME1+k, NULL, 0);</span>
<span class="line-modified">2282         g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2283         GetLocaleInfoW (lcid, LOCALE_SDAYNAME1+k, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2284         g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-modified">2285         break;</span>
<span class="line-modified">2286       case &#39;b&#39;:</span>
<span class="line-modified">2287       case &#39;h&#39;:</span>
<span class="line-modified">2288         append_month_name (result, lcid, &amp;systemtime, TRUE,</span>
<span class="line-modified">2289          modifier == &#39;O&#39;);</span>
<span class="line-modified">2290         break;</span>
<span class="line-modified">2291       case &#39;B&#39;:</span>
<span class="line-modified">2292         append_month_name (result, lcid, &amp;systemtime, FALSE,</span>
<span class="line-modified">2293          modifier == &#39;O&#39;);</span>
<span class="line-modified">2294         break;</span>
<span class="line-modified">2295       case &#39;c&#39;:</span>
<span class="line-modified">2296         n = GetDateFormatW (lcid, 0, &amp;systemtime, NULL, NULL, 0);</span>
<span class="line-modified">2297         if (n &gt; 0)</span>
<span class="line-modified">2298     {</span>
<span class="line-modified">2299       g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2300       GetDateFormatW (lcid, 0, &amp;systemtime, NULL, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2301       g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-modified">2302     }</span>































2303         g_array_append_vals (result, L&quot; &quot;, 1);
<span class="line-modified">2304         n = GetTimeFormatW (lcid, 0, &amp;systemtime, NULL, NULL, 0);</span>
<span class="line-modified">2305         if (n &gt; 0)</span>
<span class="line-modified">2306     {</span>
<span class="line-modified">2307       g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2308       GetTimeFormatW (lcid, 0, &amp;systemtime, NULL, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2309       g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-modified">2310     }</span>
<span class="line-modified">2311         break;</span>
<span class="line-modified">2312       case &#39;C&#39;:</span>
<span class="line-modified">2313         g_array_append_vals (result, digits + systemtime.wYear/1000, 1);</span>
<span class="line-modified">2314         g_array_append_vals (result, digits + (systemtime.wYear/1000)%10, 1);</span>
<span class="line-added">2315         break;</span>
<span class="line-added">2316       case &#39;d&#39;:</span>
<span class="line-added">2317         g_array_append_vals (result, digits + systemtime.wDay/10, 1);</span>
<span class="line-added">2318         g_array_append_vals (result, digits + systemtime.wDay%10, 1);</span>
<span class="line-added">2319         break;</span>
<span class="line-added">2320       case &#39;D&#39;:</span>
<span class="line-added">2321         g_array_append_vals (result, digits + systemtime.wMonth/10, 1);</span>
<span class="line-added">2322         g_array_append_vals (result, digits + systemtime.wMonth%10, 1);</span>
<span class="line-added">2323         g_array_append_vals (result, L&quot;/&quot;, 1);</span>
<span class="line-added">2324         g_array_append_vals (result, digits + systemtime.wDay/10, 1);</span>
<span class="line-added">2325         g_array_append_vals (result, digits + systemtime.wDay%10, 1);</span>
<span class="line-added">2326         g_array_append_vals (result, L&quot;/&quot;, 1);</span>
<span class="line-added">2327         g_array_append_vals (result, digits + (systemtime.wYear/10)%10, 1);</span>
<span class="line-added">2328         g_array_append_vals (result, digits + systemtime.wYear%10, 1);</span>
<span class="line-added">2329         break;</span>
<span class="line-added">2330       case &#39;e&#39;:</span>
<span class="line-added">2331         if (systemtime.wDay &gt;= 10)</span>
<span class="line-added">2332     g_array_append_vals (result, digits + systemtime.wDay/10, 1);</span>
<span class="line-added">2333         else</span>
<span class="line-added">2334     g_array_append_vals (result, L&quot; &quot;, 1);</span>
<span class="line-added">2335         g_array_append_vals (result, digits + systemtime.wDay%10, 1);</span>
<span class="line-added">2336         break;</span>
<span class="line-added">2337 </span>
<span class="line-added">2338         /* A GDate has no time fields, so for now we can</span>
<span class="line-added">2339          * hardcode all time conversions into zeros (or 12 for</span>
<span class="line-added">2340          * %I). The alternative code snippets in the #else</span>
<span class="line-added">2341          * branches are here ready to be taken into use when</span>
<span class="line-added">2342          * needed by a g_strftime() or g_date_and_time_format()</span>
<span class="line-added">2343          * or whatever.</span>
<span class="line-added">2344          */</span>
<span class="line-added">2345       case &#39;H&#39;:</span>
2346 #if 1
<span class="line-modified">2347         g_array_append_vals (result, L&quot;00&quot;, 2);</span>
2348 #else
<span class="line-modified">2349         g_array_append_vals (result, digits + systemtime.wHour/10, 1);</span>
<span class="line-modified">2350         g_array_append_vals (result, digits + systemtime.wHour%10, 1);</span>
2351 #endif
<span class="line-modified">2352         break;</span>
<span class="line-modified">2353       case &#39;I&#39;:</span>
2354 #if 1



2355         g_array_append_vals (result, L&quot;12&quot;, 2);
<span class="line-modified">2356 #else</span>
<span class="line-modified">2357         if (systemtime.wHour == 0)</span>
<span class="line-modified">2358     g_array_append_vals (result, L&quot;12&quot;, 2);</span>
<span class="line-modified">2359         else</span>
<span class="line-modified">2360     {</span>
<span class="line-added">2361       g_array_append_vals (result, digits + (systemtime.wHour%12)/10, 1);</span>
<span class="line-added">2362       g_array_append_vals (result, digits + (systemtime.wHour%12)%10, 1);</span>
<span class="line-added">2363     }</span>
2364 #endif
<span class="line-modified">2365         break;</span>
<span class="line-modified">2366       case  &#39;j&#39;:</span>
<span class="line-modified">2367         g_array_append_vals (result, digits + (tm-&gt;tm_yday+1)/100, 1);</span>
<span class="line-modified">2368         g_array_append_vals (result, digits + ((tm-&gt;tm_yday+1)/10)%10, 1);</span>
<span class="line-modified">2369         g_array_append_vals (result, digits + (tm-&gt;tm_yday+1)%10, 1);</span>
<span class="line-modified">2370         break;</span>
<span class="line-modified">2371       case &#39;m&#39;:</span>
<span class="line-modified">2372         g_array_append_vals (result, digits + systemtime.wMonth/10, 1);</span>
<span class="line-modified">2373         g_array_append_vals (result, digits + systemtime.wMonth%10, 1);</span>
<span class="line-modified">2374         break;</span>
<span class="line-modified">2375       case &#39;M&#39;:</span>
2376 #if 1
<span class="line-modified">2377         g_array_append_vals (result, L&quot;00&quot;, 2);</span>
2378 #else
<span class="line-modified">2379         g_array_append_vals (result, digits + systemtime.wMinute/10, 1);</span>
<span class="line-modified">2380         g_array_append_vals (result, digits + systemtime.wMinute%10, 1);</span>
2381 #endif
<span class="line-modified">2382         break;</span>
<span class="line-modified">2383       case &#39;n&#39;:</span>
<span class="line-modified">2384         g_array_append_vals (result, L&quot;\n&quot;, 1);</span>
<span class="line-modified">2385         break;</span>
<span class="line-modified">2386       case &#39;p&#39;:</span>
<span class="line-modified">2387         n = GetTimeFormatW (lcid, 0, &amp;systemtime, L&quot;tt&quot;, NULL, 0);</span>
<span class="line-modified">2388         if (n &gt; 0)</span>
<span class="line-modified">2389     {</span>
<span class="line-modified">2390       g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2391       GetTimeFormatW (lcid, 0, &amp;systemtime, L&quot;tt&quot;, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2392       g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-modified">2393     }</span>
<span class="line-modified">2394         break;</span>
<span class="line-modified">2395       case &#39;r&#39;:</span>
<span class="line-modified">2396         /* This is a rather odd format. Hard to say what to do.</span>
<span class="line-modified">2397          * Let&#39;s always use the POSIX %I:%M:%S %p</span>
<span class="line-modified">2398          */</span>
2399 #if 1
<span class="line-modified">2400         g_array_append_vals (result, L&quot;12:00:00&quot;, 8);</span>
2401 #else
<span class="line-modified">2402         if (systemtime.wHour == 0)</span>
<span class="line-modified">2403     g_array_append_vals (result, L&quot;12&quot;, 2);</span>
<span class="line-modified">2404         else</span>
<span class="line-modified">2405     {</span>
<span class="line-modified">2406       g_array_append_vals (result, digits + (systemtime.wHour%12)/10, 1);</span>
<span class="line-modified">2407       g_array_append_vals (result, digits + (systemtime.wHour%12)%10, 1);</span>
<span class="line-modified">2408     }</span>
<span class="line-modified">2409         g_array_append_vals (result, L&quot;:&quot;, 1);</span>
<span class="line-modified">2410         g_array_append_vals (result, digits + systemtime.wMinute/10, 1);</span>
<span class="line-modified">2411         g_array_append_vals (result, digits + systemtime.wMinute%10, 1);</span>
<span class="line-modified">2412         g_array_append_vals (result, L&quot;:&quot;, 1);</span>
<span class="line-modified">2413         g_array_append_vals (result, digits + systemtime.wSecond/10, 1);</span>
<span class="line-modified">2414         g_array_append_vals (result, digits + systemtime.wSecond%10, 1);</span>
<span class="line-modified">2415         g_array_append_vals (result, L&quot; &quot;, 1);</span>
2416 #endif
<span class="line-modified">2417         n = GetTimeFormatW (lcid, 0, &amp;systemtime, L&quot;tt&quot;, NULL, 0);</span>
<span class="line-modified">2418         if (n &gt; 0)</span>
<span class="line-modified">2419     {</span>
<span class="line-modified">2420       g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2421       GetTimeFormatW (lcid, 0, &amp;systemtime, L&quot;tt&quot;, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2422       g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-modified">2423     }</span>
<span class="line-modified">2424         break;</span>
<span class="line-modified">2425       case &#39;R&#39;:</span>
2426 #if 1
<span class="line-modified">2427         g_array_append_vals (result, L&quot;00:00&quot;, 5);</span>
2428 #else
<span class="line-modified">2429         g_array_append_vals (result, digits + systemtime.wHour/10, 1);</span>
<span class="line-modified">2430         g_array_append_vals (result, digits + systemtime.wHour%10, 1);</span>
<span class="line-modified">2431         g_array_append_vals (result, L&quot;:&quot;, 1);</span>
<span class="line-modified">2432         g_array_append_vals (result, digits + systemtime.wMinute/10, 1);</span>
<span class="line-modified">2433         g_array_append_vals (result, digits + systemtime.wMinute%10, 1);</span>
2434 #endif
<span class="line-modified">2435         break;</span>
<span class="line-modified">2436       case &#39;S&#39;:</span>
2437 #if 1
<span class="line-modified">2438         g_array_append_vals (result, L&quot;00&quot;, 2);</span>
2439 #else
<span class="line-modified">2440         g_array_append_vals (result, digits + systemtime.wSecond/10, 1);</span>
<span class="line-modified">2441         g_array_append_vals (result, digits + systemtime.wSecond%10, 1);</span>
2442 #endif
<span class="line-modified">2443         break;</span>
<span class="line-modified">2444       case &#39;t&#39;:</span>
<span class="line-modified">2445         g_array_append_vals (result, L&quot;\t&quot;, 1);</span>
<span class="line-modified">2446         break;</span>
<span class="line-modified">2447       case &#39;T&#39;:</span>
2448 #if 1
<span class="line-modified">2449         g_array_append_vals (result, L&quot;00:00:00&quot;, 8);</span>
2450 #else
<span class="line-modified">2451         g_array_append_vals (result, digits + systemtime.wHour/10, 1);</span>
<span class="line-modified">2452         g_array_append_vals (result, digits + systemtime.wHour%10, 1);</span>
<span class="line-modified">2453         g_array_append_vals (result, L&quot;:&quot;, 1);</span>
<span class="line-modified">2454         g_array_append_vals (result, digits + systemtime.wMinute/10, 1);</span>
<span class="line-modified">2455         g_array_append_vals (result, digits + systemtime.wMinute%10, 1);</span>
<span class="line-modified">2456         g_array_append_vals (result, L&quot;:&quot;, 1);</span>
<span class="line-modified">2457         g_array_append_vals (result, digits + systemtime.wSecond/10, 1);</span>
<span class="line-modified">2458         g_array_append_vals (result, digits + systemtime.wSecond%10, 1);</span>
2459 #endif
<span class="line-modified">2460         break;</span>
<span class="line-modified">2461       case &#39;u&#39;:</span>
<span class="line-modified">2462         if (systemtime.wDayOfWeek == 0)</span>
<span class="line-modified">2463     g_array_append_vals (result, L&quot;7&quot;, 1);</span>
<span class="line-modified">2464         else</span>
<span class="line-added">2465     g_array_append_vals (result, digits + systemtime.wDayOfWeek, 1);</span>
<span class="line-added">2466         break;</span>
<span class="line-added">2467       case &#39;U&#39;:</span>
<span class="line-added">2468         n = g_date_get_sunday_week_of_year (d);</span>
<span class="line-added">2469         g_array_append_vals (result, digits + n/10, 1);</span>
<span class="line-added">2470         g_array_append_vals (result, digits + n%10, 1);</span>
<span class="line-added">2471         break;</span>
<span class="line-added">2472       case &#39;V&#39;:</span>
<span class="line-added">2473         n = g_date_get_iso8601_week_of_year (d);</span>
<span class="line-added">2474         g_array_append_vals (result, digits + n/10, 1);</span>
<span class="line-added">2475         g_array_append_vals (result, digits + n%10, 1);</span>
<span class="line-added">2476         break;</span>
<span class="line-added">2477       case &#39;w&#39;:</span>
2478         g_array_append_vals (result, digits + systemtime.wDayOfWeek, 1);
<span class="line-modified">2479         break;</span>
<span class="line-modified">2480       case &#39;W&#39;:</span>
<span class="line-modified">2481         n = g_date_get_monday_week_of_year (d);</span>
<span class="line-modified">2482         g_array_append_vals (result, digits + n/10, 1);</span>
<span class="line-modified">2483         g_array_append_vals (result, digits + n%10, 1);</span>
<span class="line-modified">2484         break;</span>
<span class="line-modified">2485       case &#39;x&#39;:</span>
<span class="line-modified">2486         n = GetDateFormatW (lcid, 0, &amp;systemtime, NULL, NULL, 0);</span>
<span class="line-modified">2487         if (n &gt; 0)</span>
<span class="line-modified">2488     {</span>
<span class="line-modified">2489       g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2490       GetDateFormatW (lcid, 0, &amp;systemtime, NULL, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2491       g_array_set_size (result, result-&gt;len - 1);</span>















































2492     }
<span class="line-modified">2493         break;</span>
<span class="line-added">2494       case &#39;X&#39;:</span>
<span class="line-added">2495         n = GetTimeFormatW (lcid, 0, &amp;systemtime, NULL, NULL, 0);</span>
<span class="line-added">2496         if (n &gt; 0)</span>
2497     {
<span class="line-modified">2498       g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2499       GetTimeFormatW (lcid, 0, &amp;systemtime, NULL, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-added">2500       g_array_set_size (result, result-&gt;len - 1);</span>
2501     }
<span class="line-added">2502         break;</span>
<span class="line-added">2503       case &#39;y&#39;:</span>
<span class="line-added">2504         g_array_append_vals (result, digits + (systemtime.wYear/10)%10, 1);</span>
<span class="line-added">2505         g_array_append_vals (result, digits + systemtime.wYear%10, 1);</span>
<span class="line-added">2506         break;</span>
<span class="line-added">2507       case &#39;Y&#39;:</span>
<span class="line-added">2508         g_array_append_vals (result, digits + systemtime.wYear/1000, 1);</span>
<span class="line-added">2509         g_array_append_vals (result, digits + (systemtime.wYear/100)%10, 1);</span>
<span class="line-added">2510         g_array_append_vals (result, digits + (systemtime.wYear/10)%10, 1);</span>
<span class="line-added">2511         g_array_append_vals (result, digits + systemtime.wYear%10, 1);</span>
<span class="line-added">2512         break;</span>
<span class="line-added">2513       case &#39;Z&#39;:</span>
<span class="line-added">2514         n = GetTimeZoneInformation (&amp;tzinfo);</span>
<span class="line-added">2515         if (n == TIME_ZONE_ID_UNKNOWN)</span>
<span class="line-added">2516     ;</span>
<span class="line-added">2517         else if (n == TIME_ZONE_ID_STANDARD)</span>
<span class="line-added">2518     g_array_append_vals (result, tzinfo.StandardName, wcslen (tzinfo.StandardName));</span>
<span class="line-added">2519         else if (n == TIME_ZONE_ID_DAYLIGHT)</span>
<span class="line-added">2520     g_array_append_vals (result, tzinfo.DaylightName, wcslen (tzinfo.DaylightName));</span>
<span class="line-added">2521         break;</span>
<span class="line-added">2522       case &#39;%&#39;:</span>
<span class="line-added">2523         g_array_append_vals (result, L&quot;%&quot;, 1);</span>
<span class="line-added">2524         break;</span>
<span class="line-added">2525       }</span>
<span class="line-added">2526   }</span>
<span class="line-added">2527       else if (c &lt;= 0xFFFF)</span>
<span class="line-added">2528   {</span>
<span class="line-added">2529     wchar_t wc = c;</span>
<span class="line-added">2530     g_array_append_vals (result, &amp;wc, 1);</span>
<span class="line-added">2531   }</span>
2532       else
<span class="line-modified">2533   {</span>
<span class="line-modified">2534     glong nwc;</span>
<span class="line-modified">2535     wchar_t *ws;</span>
2536 
<span class="line-modified">2537     ws = g_ucs4_to_utf16 (&amp;c, 1, NULL, &amp;nwc, NULL);</span>
<span class="line-modified">2538     g_array_append_vals (result, ws, nwc);</span>
<span class="line-modified">2539     g_free (ws);</span>
<span class="line-modified">2540   }</span>
2541       p = g_utf8_next_char (p);
2542     }
2543 
2544   convbuf = g_utf16_to_utf8 ((wchar_t *) result-&gt;data, result-&gt;len, NULL, &amp;convlen, NULL);
2545   g_array_free (result, TRUE);
2546 
2547   if (!convbuf)
2548     {
2549       s[0] = &#39;\0&#39;;
2550       return 0;
2551     }
2552 
2553   if (slen &lt;= convlen)
2554     {
2555       /* Ensure only whole characters are copied into the buffer. */
2556       gchar *end = g_utf8_find_prev_char (convbuf, convbuf + slen);
2557       g_assert (end != NULL);
2558       convlen = end - convbuf;
2559 
2560       /* Return 0 because the buffer isn&#39;t large enough. */
</pre>
<hr />
<pre>
2578  * @slen: buffer size
2579  * @format: format string
2580  * @date: valid #GDate
2581  *
2582  * Generates a printed representation of the date, in a
2583  * [locale][setlocale]-specific way.
2584  * Works just like the platform&#39;s C library strftime() function,
2585  * but only accepts date-related formats; time-related formats
2586  * give undefined results. Date must be valid. Unlike strftime()
2587  * (which uses the locale encoding), works on a UTF-8 format
2588  * string and stores a UTF-8 result.
2589  *
2590  * This function does not provide any conversion specifiers in
2591  * addition to those implemented by the platform&#39;s C library.
2592  * For example, don&#39;t expect that using g_date_strftime() would
2593  * make the \%F provided by the C99 strftime() work on Windows
2594  * where the C library only complies to C89.
2595  *
2596  * Returns: number of characters written to the buffer, or 0 the buffer was too small
2597  */
<span class="line-added">2598 #ifdef GSTREAMER_LITE</span>
<span class="line-added">2599 #ifndef G_OS_WIN32</span>
<span class="line-added">2600 #pragma GCC diagnostic push</span>
<span class="line-added">2601 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;</span>
<span class="line-added">2602 #endif // G_OS_WIN32</span>
<span class="line-added">2603 #else // GSTREAMER_LITE</span>
2604 #pragma GCC diagnostic push
2605 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
<span class="line-added">2606 #endif // GSTREAMER_LITE</span>
2607 
2608 gsize
2609 g_date_strftime (gchar       *s,
2610                  gsize        slen,
2611                  const gchar *format,
2612                  const GDate *d)
2613 {
2614   struct tm tm;
2615 #ifndef G_OS_WIN32
2616   gsize locale_format_len = 0;
2617   gchar *locale_format;
2618   gsize tmplen;
2619   gchar *tmpbuf;
2620   gsize tmpbufsize;
2621   gsize convlen = 0;
2622   gchar *convbuf;
2623   GError *error = NULL;
2624   gsize retval;
2625 #endif
2626 
</pre>
<hr />
<pre>
2703        */
2704       gchar *end = g_utf8_find_prev_char (convbuf, convbuf + slen);
2705       g_assert (end != NULL);
2706       convlen = end - convbuf;
2707 
2708       /* Return 0 because the buffer isn&#39;t large enough.
2709        */
2710       retval = 0;
2711     }
2712   else
2713     retval = convlen;
2714 
2715   memcpy (s, convbuf, convlen);
2716   s[convlen] = &#39;\0&#39;;
2717   g_free (convbuf);
2718 
2719   return retval;
2720 #endif
2721 }
2722 
<span class="line-added">2723 #ifdef GSTREAMER_LITE</span>
<span class="line-added">2724 #ifndef G_OS_WIN32</span>
2725 #pragma GCC diagnostic pop
<span class="line-added">2726 #endif // G_OS_WIN32</span>
<span class="line-added">2727 #else // GSTREAMER_LITE</span>
<span class="line-added">2728 #pragma GCC diagnostic pop</span>
<span class="line-added">2729 #endif // GSTREAMER_LITE</span>
</pre>
</td>
</tr>
</table>
<center><a href="gdatasetprivate.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gdate.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>