diff a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/video-overlay-composition.c b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/video-overlay-composition.c
--- a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/video-overlay-composition.c
+++ b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/video-overlay-composition.c
@@ -40,11 +40,11 @@
  *   buffers, thus consolidating blending functionality for raw video in
  *   one place.
  *
  * Together, this allows existing overlay elements to easily handle raw
  * and non-raw video as input in without major changes (once the overlays
- * have been put into a #GstOverlayComposition object anyway) - for raw
+ * have been put into a #GstVideoOverlayComposition object anyway) - for raw
  * video the overlay can just use the blending function to blend the data
  * on top of the video, and for surface buffers it can just attach them to
  * the buffer and let the sink render the overlays.
  *
  */
@@ -310,10 +310,12 @@
   guint num;
 
   num = comp->num_rectangles;
 
   while (num > 0) {
+    gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (comp->rectangles[num -
+                1]), GST_MINI_OBJECT_CAST (comp));
     gst_video_overlay_rectangle_unref (comp->rectangles[num - 1]);
     --num;
   }
 
   g_free (comp->rectangles);
@@ -352,10 +354,12 @@
       (GstMiniObjectCopyFunction) gst_video_overlay_composition_copy,
       NULL, (GstMiniObjectFreeFunction) gst_video_overlay_composition_free);
 
   comp->rectangles = g_new0 (GstVideoOverlayRectangle *, RECTANGLE_ARRAY_STEP);
   comp->rectangles[0] = gst_video_overlay_rectangle_ref (rectangle);
+  gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (rectangle),
+      GST_MINI_OBJECT_CAST (comp));
   comp->num_rectangles = 1;
 
   comp->seq_num = gst_video_overlay_get_seqnum ();
 
   /* since the rectangle was created earlier, its seqnum is smaller than ours */
@@ -380,20 +384,22 @@
 gst_video_overlay_composition_add_rectangle (GstVideoOverlayComposition * comp,
     GstVideoOverlayRectangle * rectangle)
 {
   g_return_if_fail (GST_IS_VIDEO_OVERLAY_COMPOSITION (comp));
   g_return_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle));
-  g_return_if_fail (GST_MINI_OBJECT_REFCOUNT_VALUE (comp) == 1);
+  g_return_if_fail (gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (comp)));
 
   if (comp->num_rectangles % RECTANGLE_ARRAY_STEP == 0) {
     comp->rectangles =
         g_renew (GstVideoOverlayRectangle *, comp->rectangles,
         comp->num_rectangles + RECTANGLE_ARRAY_STEP);
   }
 
   comp->rectangles[comp->num_rectangles] =
       gst_video_overlay_rectangle_ref (rectangle);
+  gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (rectangle),
+      GST_MINI_OBJECT_CAST (comp));
   comp->num_rectangles += 1;
 
   comp->min_seq_num_used = MIN (comp->min_seq_num_used, rectangle->seq_num);
 
   GST_LOG ("composition %p: added rectangle %p", comp, rectangle);
@@ -579,15 +585,16 @@
 {
   GstVideoOverlayComposition *writable_comp;
 
   g_return_val_if_fail (GST_IS_VIDEO_OVERLAY_COMPOSITION (comp), NULL);
 
-  if (GST_MINI_OBJECT_REFCOUNT_VALUE (comp) == 1) {
+  if (gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (comp))) {
     guint n;
 
     for (n = 0; n < comp->num_rectangles; ++n) {
-      if (GST_MINI_OBJECT_REFCOUNT_VALUE (comp->rectangles[n]) != 1)
+      if (!gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (comp->rectangles
+                  [n])))
         goto copy;
     }
     return comp;
   }
 
@@ -626,10 +633,12 @@
 static void
 gst_video_overlay_rectangle_free (GstMiniObject * mini_obj)
 {
   GstVideoOverlayRectangle *rect = (GstVideoOverlayRectangle *) mini_obj;
 
+  gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (rect->pixels),
+      GST_MINI_OBJECT_CAST (rect));
   gst_buffer_replace (&rect->pixels, NULL);
 
   while (rect->scaled_rectangles != NULL) {
     GstVideoOverlayRectangle *scaled_rect = rect->scaled_rectangles->data;
 
@@ -727,10 +736,12 @@
       NULL, (GstMiniObjectFreeFunction) gst_video_overlay_rectangle_free);
 
   g_mutex_init (&rect->lock);
 
   rect->pixels = gst_buffer_ref (pixels);
+  gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (pixels),
+      GST_MINI_OBJECT_CAST (rect));
   rect->scaled_rectangles = NULL;
 
   gst_video_info_init (&rect->info);
   if (!gst_video_info_set_format (&rect->info, format, width, height)) {
     gst_mini_object_unref (GST_MINI_OBJECT_CAST (rect));
@@ -814,11 +825,12 @@
 gst_video_overlay_rectangle_set_render_rectangle (GstVideoOverlayRectangle *
     rectangle, gint render_x, gint render_y, guint render_width,
     guint render_height)
 {
   g_return_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle));
-  g_return_if_fail (GST_MINI_OBJECT_REFCOUNT_VALUE (rectangle) == 1);
+  g_return_if_fail (gst_mini_object_is_writable (GST_MINI_OBJECT_CAST
+          (rectangle)));
 
   rectangle->x = render_x;
   rectangle->y = render_y;
   rectangle->render_width = render_width;
   rectangle->render_height = render_height;
@@ -827,16 +839,21 @@
 /* FIXME: orc-ify */
 static void
 gst_video_overlay_rectangle_premultiply_0 (GstVideoFrame * frame)
 {
   int i, j;
-  for (j = 0; j < GST_VIDEO_FRAME_HEIGHT (frame); ++j) {
+  int width = GST_VIDEO_FRAME_WIDTH (frame);
+  int height = GST_VIDEO_FRAME_HEIGHT (frame);
+  int stride = GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0);
+  guint8 *data = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);
+
+  for (j = 0; j < height; ++j) {
     guint8 *line;
 
-    line = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);
-    line += GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0) * j;
-    for (i = 0; i < GST_VIDEO_FRAME_WIDTH (frame); ++i) {
+    line = data;
+    line += stride * j;
+    for (i = 0; i < width; ++i) {
       int a = line[0];
       line[1] = line[1] * a / 255;
       line[2] = line[2] * a / 255;
       line[3] = line[3] * a / 255;
       line += 4;
@@ -846,16 +863,21 @@
 
 static void
 gst_video_overlay_rectangle_premultiply_3 (GstVideoFrame * frame)
 {
   int i, j;
-  for (j = 0; j < GST_VIDEO_FRAME_HEIGHT (frame); ++j) {
+  int width = GST_VIDEO_FRAME_WIDTH (frame);
+  int height = GST_VIDEO_FRAME_HEIGHT (frame);
+  int stride = GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0);
+  guint8 *data = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);
+
+  for (j = 0; j < height; ++j) {
     guint8 *line;
 
-    line = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);
-    line += GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0) * j;
-    for (i = 0; i < GST_VIDEO_FRAME_WIDTH (frame); ++i) {
+    line = data;
+    line += stride * j;
+    for (i = 0; i < width; ++i) {
       int a = line[3];
       line[0] = line[0] * a / 255;
       line[1] = line[1] * a / 255;
       line[2] = line[2] * a / 255;
       line += 4;
@@ -885,16 +907,21 @@
 /* FIXME: orc-ify */
 static void
 gst_video_overlay_rectangle_unpremultiply_0 (GstVideoFrame * frame)
 {
   int i, j;
-  for (j = 0; j < GST_VIDEO_FRAME_HEIGHT (frame); ++j) {
+  int width = GST_VIDEO_FRAME_WIDTH (frame);
+  int height = GST_VIDEO_FRAME_HEIGHT (frame);
+  int stride = GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0);
+  guint8 *data = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);
+
+  for (j = 0; j < height; ++j) {
     guint8 *line;
 
-    line = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);
-    line += GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0) * j;
-    for (i = 0; i < GST_VIDEO_FRAME_WIDTH (frame); ++i) {
+    line = data;
+    line += stride * j;
+    for (i = 0; i < width; ++i) {
       int a = line[0];
       if (a) {
         line[1] = MIN ((line[1] * 255 + a / 2) / a, 255);
         line[2] = MIN ((line[2] * 255 + a / 2) / a, 255);
         line[3] = MIN ((line[3] * 255 + a / 2) / a, 255);
@@ -906,16 +933,21 @@
 
 static void
 gst_video_overlay_rectangle_unpremultiply_3 (GstVideoFrame * frame)
 {
   int i, j;
-  for (j = 0; j < GST_VIDEO_FRAME_HEIGHT (frame); ++j) {
+  int width = GST_VIDEO_FRAME_WIDTH (frame);
+  int height = GST_VIDEO_FRAME_HEIGHT (frame);
+  int stride = GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0);
+  guint8 *data = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);
+
+  for (j = 0; j < height; ++j) {
     guint8 *line;
 
-    line = GST_VIDEO_FRAME_PLANE_DATA (frame, 0);
-    line += GST_VIDEO_FRAME_PLANE_STRIDE (frame, 0) * j;
-    for (i = 0; i < GST_VIDEO_FRAME_WIDTH (frame); ++i) {
+    line = data;
+    line += stride * j;
+    for (i = 0; i < width; ++i) {
       int a = line[3];
       if (a) {
         line[0] = MIN ((line[0] * 255 + a / 2) / a, 255);
         line[1] = MIN ((line[1] * 255 + a / 2) / a, 255);
         line[2] = MIN ((line[2] * 255 + a / 2) / a, 255);
@@ -998,11 +1030,17 @@
 
   if (rect->initial_alpha == NULL)
     gst_video_overlay_rectangle_extract_alpha (rect);
 
   src = rect->initial_alpha;
-  rect->pixels = gst_buffer_make_writable (rect->pixels);
+  if (!gst_buffer_is_writable (rect->pixels)) {
+    gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (rect->pixels),
+        GST_MINI_OBJECT_CAST (rect));
+    rect->pixels = gst_buffer_copy (rect->pixels);
+    gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (rect->pixels),
+        GST_MINI_OBJECT_CAST (rect));
+  }
 
   gst_video_frame_map (&frame, &rect->info, rect->pixels, GST_MAP_READ);
   dst = GST_VIDEO_FRAME_PLANE_DATA (&frame, 0);
   w = GST_VIDEO_INFO_WIDTH (&rect->info);
   h = GST_VIDEO_INFO_HEIGHT (&rect->info);
@@ -1526,10 +1564,12 @@
 void
 gst_video_overlay_rectangle_set_global_alpha (GstVideoOverlayRectangle *
     rectangle, gfloat global_alpha)
 {
   g_return_if_fail (GST_IS_VIDEO_OVERLAY_RECTANGLE (rectangle));
+  g_return_if_fail (gst_mini_object_is_writable (GST_MINI_OBJECT_CAST
+          (rectangle)));
   g_return_if_fail (global_alpha >= 0 && global_alpha <= 1);
 
   if (rectangle->global_alpha != global_alpha) {
     rectangle->global_alpha = global_alpha;
     if (global_alpha != 1)
