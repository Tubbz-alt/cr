<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gdataset.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * gdataset.c: Generic dataset mechanism, similar to GtkObject data.
   5  * Copyright (C) 1998 Tim Janik
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Lesser General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2.1 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Lesser General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Lesser General Public
  18  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  19  */
  20 
  21 /*
  22  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  23  * file for a list of people on the GLib Team.  See the ChangeLog
  24  * files for a list of changes.  These files are distributed with
  25  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  26  */
  27 
  28 /*
  29  * MT safe ; except for g_data*_foreach()
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 
  34 #include &lt;string.h&gt;
  35 
  36 #include &quot;gdataset.h&quot;
  37 #include &quot;gbitlock.h&quot;
  38 
  39 #include &quot;gslice.h&quot;
  40 #include &quot;gdatasetprivate.h&quot;
  41 #include &quot;ghash.h&quot;
  42 #include &quot;gquark.h&quot;
  43 #include &quot;gstrfuncs.h&quot;
  44 #include &quot;gtestutils.h&quot;
  45 #include &quot;gthread.h&quot;
  46 #include &quot;glib_trace.h&quot;
  47 
  48 /**
  49  * SECTION:datasets
  50  * @title: Datasets
  51  * @short_description: associate groups of data elements with
  52  *                     particular memory locations
  53  *
  54  * Datasets associate groups of data elements with particular memory
  55  * locations. These are useful if you need to associate data with a
  56  * structure returned from an external library. Since you cannot modify
  57  * the structure, you use its location in memory as the key into a
  58  * dataset, where you can associate any number of data elements with it.
  59  *
  60  * There are two forms of most of the dataset functions. The first form
  61  * uses strings to identify the data elements associated with a
  62  * location. The second form uses #GQuark identifiers, which are
  63  * created with a call to g_quark_from_string() or
  64  * g_quark_from_static_string(). The second form is quicker, since it
  65  * does not require looking up the string in the hash table of #GQuark
  66  * identifiers.
  67  *
  68  * There is no function to create a dataset. It is automatically
  69  * created as soon as you add elements to it.
  70  *
  71  * To add data elements to a dataset use g_dataset_id_set_data(),
  72  * g_dataset_id_set_data_full(), g_dataset_set_data() and
  73  * g_dataset_set_data_full().
  74  *
  75  * To get data elements from a dataset use g_dataset_id_get_data() and
  76  * g_dataset_get_data().
  77  *
  78  * To iterate over all data elements in a dataset use
  79  * g_dataset_foreach() (not thread-safe).
  80  *
  81  * To remove data elements from a dataset use
  82  * g_dataset_id_remove_data() and g_dataset_remove_data().
  83  *
  84  * To destroy a dataset, use g_dataset_destroy().
  85  **/
  86 
  87 /**
  88  * SECTION:datalist
  89  * @title: Keyed Data Lists
  90  * @short_description: lists of data elements which are accessible by a
  91  *                     string or GQuark identifier
  92  *
  93  * Keyed data lists provide lists of arbitrary data elements which can
  94  * be accessed either with a string or with a #GQuark corresponding to
  95  * the string.
  96  *
  97  * The #GQuark methods are quicker, since the strings have to be
  98  * converted to #GQuarks anyway.
  99  *
 100  * Data lists are used for associating arbitrary data with #GObjects,
 101  * using g_object_set_data() and related functions.
 102  *
 103  * To create a datalist, use g_datalist_init().
 104  *
 105  * To add data elements to a datalist use g_datalist_id_set_data(),
 106  * g_datalist_id_set_data_full(), g_datalist_set_data() and
 107  * g_datalist_set_data_full().
 108  *
 109  * To get data elements from a datalist use g_datalist_id_get_data()
 110  * and g_datalist_get_data().
 111  *
 112  * To iterate over all data elements in a datalist use
 113  * g_datalist_foreach() (not thread-safe).
 114  *
 115  * To remove data elements from a datalist use
 116  * g_datalist_id_remove_data() and g_datalist_remove_data().
 117  *
 118  * To remove all data elements from a datalist, use g_datalist_clear().
 119  **/
 120 
 121 /**
 122  * GData:
 123  *
 124  * The #GData struct is an opaque data structure to represent a
 125  * [Keyed Data List][glib-Keyed-Data-Lists]. It should only be
 126  * accessed via the following functions.
 127  **/
 128 
 129 /**
 130  * GDestroyNotify:
 131  * @data: the data element.
 132  *
 133  * Specifies the type of function which is called when a data element
 134  * is destroyed. It is passed the pointer to the data element and
 135  * should free any memory and resources allocated for it.
 136  **/
 137 
 138 #define G_DATALIST_FLAGS_MASK_INTERNAL 0x7
 139 
 140 /* datalist pointer accesses have to be carried out atomically */
 141 #define G_DATALIST_GET_POINTER(datalist)                        \
 142   ((GData*) ((gsize) g_atomic_pointer_get (datalist) &amp; ~(gsize) G_DATALIST_FLAGS_MASK_INTERNAL))
 143 
 144 #define G_DATALIST_SET_POINTER(datalist, pointer)       G_STMT_START {                  \
 145   gpointer _oldv, _newv;                                                                \
 146   do {                                                                                  \
 147     _oldv = g_atomic_pointer_get (datalist);                                            \
 148     _newv = (gpointer) (((gsize) _oldv &amp; G_DATALIST_FLAGS_MASK_INTERNAL) | (gsize) pointer);     \
 149   } while (!g_atomic_pointer_compare_and_exchange ((void**) datalist, _oldv, _newv));   \
 150 } G_STMT_END
 151 
 152 /* --- structures --- */
 153 typedef struct {
 154   GQuark          key;
 155   gpointer        data;
 156   GDestroyNotify  destroy;
 157 } GDataElt;
 158 
 159 typedef struct _GDataset GDataset;
 160 struct _GData
 161 {
 162   guint32  len;     /* Number of elements */
 163   guint32  alloc;   /* Number of allocated elements */
 164   GDataElt data[1]; /* Flexible array */
 165 };
 166 
 167 struct _GDataset
 168 {
 169   gconstpointer location;
 170   GData        *datalist;
 171 };
 172 
 173 
 174 /* --- prototypes --- */
 175 static inline GDataset* g_dataset_lookup        (gconstpointer    dataset_location);
 176 static inline void  g_datalist_clear_i      (GData      **datalist);
 177 static void     g_dataset_destroy_internal  (GDataset    *dataset);
 178 static inline gpointer  g_data_set_internal     (GData      **datalist,
 179                              GQuark       key_id,
 180                              gpointer         data,
 181                              GDestroyNotify   destroy_func,
 182                              GDataset    *dataset);
 183 static void     g_data_initialize       (void);
 184 
 185 /* Locking model:
 186  * Each standalone GDataList is protected by a bitlock in the datalist pointer,
 187  * which protects that modification of the non-flags part of the datalist pointer
 188  * and the contents of the datalist.
 189  *
 190  * For GDataSet we have a global lock g_dataset_global that protects
 191  * the global dataset hash and cache, and additionally it protects the
 192  * datalist such that we can avoid to use the bit lock in a few places
 193  * where it is easy.
 194  */
 195 
 196 /* --- variables --- */
 197 G_LOCK_DEFINE_STATIC (g_dataset_global);
 198 static GHashTable   *g_dataset_location_ht = NULL;
 199 static GDataset     *g_dataset_cached = NULL; /* should this be
 200                          thread specific? */
 201 
 202 /* --- functions --- */
 203 
 204 #define DATALIST_LOCK_BIT 2
 205 
 206 static void
 207 g_datalist_lock (GData **datalist)
 208 {
 209   g_pointer_bit_lock ((void **)datalist, DATALIST_LOCK_BIT);
 210 }
 211 
 212 static void
 213 g_datalist_unlock (GData **datalist)
 214 {
 215   g_pointer_bit_unlock ((void **)datalist, DATALIST_LOCK_BIT);
 216 }
 217 
 218 /* Called with the datalist lock held, or the dataset global
 219  * lock for dataset lists
 220  */
 221 static void
 222 g_datalist_clear_i (GData **datalist)
 223 {
 224   GData *data;
 225   gint i;
 226 
 227   data = G_DATALIST_GET_POINTER (datalist);
 228   G_DATALIST_SET_POINTER (datalist, NULL);
 229 
 230   if (data)
 231     {
 232       G_UNLOCK (g_dataset_global);
 233       for (i = 0; i &lt; data-&gt;len; i++)
 234         {
 235           if (data-&gt;data[i].data &amp;&amp; data-&gt;data[i].destroy)
 236             data-&gt;data[i].destroy (data-&gt;data[i].data);
 237         }
 238       G_LOCK (g_dataset_global);
 239 
 240       g_free (data);
 241     }
 242 
 243 }
 244 
 245 /**
 246  * g_datalist_clear: (skip)
 247  * @datalist: a datalist.
 248  *
 249  * Frees all the data elements of the datalist.
 250  * The data elements&#39; destroy functions are called
 251  * if they have been set.
 252  **/
 253 void
 254 g_datalist_clear (GData **datalist)
 255 {
 256   GData *data;
 257   gint i;
 258 
 259   g_return_if_fail (datalist != NULL);
 260 
 261   g_datalist_lock (datalist);
 262 
 263   data = G_DATALIST_GET_POINTER (datalist);
 264   G_DATALIST_SET_POINTER (datalist, NULL);
 265 
 266   g_datalist_unlock (datalist);
 267 
 268   if (data)
 269     {
 270       for (i = 0; i &lt; data-&gt;len; i++)
 271         {
 272           if (data-&gt;data[i].data &amp;&amp; data-&gt;data[i].destroy)
 273             data-&gt;data[i].destroy (data-&gt;data[i].data);
 274         }
 275 
 276       g_free (data);
 277     }
 278 }
 279 
 280 /* HOLDS: g_dataset_global_lock */
 281 static inline GDataset*
 282 g_dataset_lookup (gconstpointer dataset_location)
 283 {
 284   GDataset *dataset;
 285 
 286   if (g_dataset_cached &amp;&amp; g_dataset_cached-&gt;location == dataset_location)
 287     return g_dataset_cached;
 288 
 289   dataset = g_hash_table_lookup (g_dataset_location_ht, dataset_location);
 290   if (dataset)
 291     g_dataset_cached = dataset;
 292 
 293   return dataset;
 294 }
 295 
 296 /* HOLDS: g_dataset_global_lock */
 297 static void
 298 g_dataset_destroy_internal (GDataset *dataset)
 299 {
 300   gconstpointer dataset_location;
 301 
 302   dataset_location = dataset-&gt;location;
 303   while (dataset)
 304     {
 305       if (G_DATALIST_GET_POINTER(&amp;dataset-&gt;datalist) == NULL)
 306     {
 307       if (dataset == g_dataset_cached)
 308         g_dataset_cached = NULL;
 309       g_hash_table_remove (g_dataset_location_ht, dataset_location);
 310       g_slice_free (GDataset, dataset);
 311       break;
 312     }
 313 
 314       g_datalist_clear_i (&amp;dataset-&gt;datalist);
 315       dataset = g_dataset_lookup (dataset_location);
 316     }
 317 }
 318 
 319 /**
 320  * g_dataset_destroy:
 321  * @dataset_location: (not nullable): the location identifying the dataset.
 322  *
 323  * Destroys the dataset, freeing all memory allocated, and calling any
 324  * destroy functions set for data elements.
 325  */
 326 void
 327 g_dataset_destroy (gconstpointer  dataset_location)
 328 {
 329   g_return_if_fail (dataset_location != NULL);
 330 
 331   G_LOCK (g_dataset_global);
 332   if (g_dataset_location_ht)
 333     {
 334       GDataset *dataset;
 335 
 336       dataset = g_dataset_lookup (dataset_location);
 337       if (dataset)
 338     g_dataset_destroy_internal (dataset);
 339     }
 340   G_UNLOCK (g_dataset_global);
 341 }
 342 
 343 /* HOLDS: g_dataset_global_lock if dataset != null */
 344 static inline gpointer
 345 g_data_set_internal (GData    **datalist,
 346                      GQuark         key_id,
 347                      gpointer       new_data,
 348                      GDestroyNotify new_destroy_func,
 349              GDataset      *dataset)
 350 {
 351   GData *d, *old_d;
 352   GDataElt old, *data, *data_last, *data_end;
 353 
 354   g_datalist_lock (datalist);
 355 
 356   d = G_DATALIST_GET_POINTER (datalist);
 357 
 358   if (new_data == NULL) /* remove */
 359     {
 360       if (d)
 361     {
 362       data = d-&gt;data;
 363       data_last = data + d-&gt;len - 1;
 364       while (data &lt;= data_last)
 365         {
 366           if (data-&gt;key == key_id)
 367         {
 368           old = *data;
 369           if (data != data_last)
 370             *data = *data_last;
 371           d-&gt;len--;
 372 
 373           /* We don&#39;t bother to shrink, but if all data are now gone
 374            * we at least free the memory
 375                    */
 376           if (d-&gt;len == 0)
 377             {
 378               G_DATALIST_SET_POINTER (datalist, NULL);
 379               g_free (d);
 380               /* datalist may be situated in dataset, so must not be
 381                * unlocked after we free it
 382                */
 383               g_datalist_unlock (datalist);
 384 
 385               /* the dataset destruction *must* be done
 386                * prior to invocation of the data destroy function
 387                */
 388               if (dataset)
 389             g_dataset_destroy_internal (dataset);
 390             }
 391           else
 392             {
 393               g_datalist_unlock (datalist);
 394             }
 395 
 396           /* We found and removed an old value
 397            * the GData struct *must* already be unlinked
 398            * when invoking the destroy function.
 399            * we use (new_data==NULL &amp;&amp; new_destroy_func!=NULL) as
 400            * a special hint combination to &quot;steal&quot;
 401            * data without destroy notification
 402            */
 403           if (old.destroy &amp;&amp; !new_destroy_func)
 404             {
 405               if (dataset)
 406             G_UNLOCK (g_dataset_global);
 407               old.destroy (old.data);
 408               if (dataset)
 409             G_LOCK (g_dataset_global);
 410               old.data = NULL;
 411             }
 412 
 413           return old.data;
 414         }
 415           data++;
 416         }
 417     }
 418     }
 419   else
 420     {
 421       old.data = NULL;
 422       if (d)
 423     {
 424       data = d-&gt;data;
 425       data_end = data + d-&gt;len;
 426       while (data &lt; data_end)
 427         {
 428           if (data-&gt;key == key_id)
 429         {
 430           if (!data-&gt;destroy)
 431             {
 432               data-&gt;data = new_data;
 433               data-&gt;destroy = new_destroy_func;
 434               g_datalist_unlock (datalist);
 435             }
 436           else
 437             {
 438               old = *data;
 439               data-&gt;data = new_data;
 440               data-&gt;destroy = new_destroy_func;
 441 
 442               g_datalist_unlock (datalist);
 443 
 444               /* We found and replaced an old value
 445                * the GData struct *must* already be unlinked
 446                * when invoking the destroy function.
 447                */
 448               if (dataset)
 449             G_UNLOCK (g_dataset_global);
 450               old.destroy (old.data);
 451               if (dataset)
 452             G_LOCK (g_dataset_global);
 453             }
 454           return NULL;
 455         }
 456           data++;
 457         }
 458     }
 459 
 460       /* The key was not found, insert it */
 461       old_d = d;
 462       if (d == NULL)
 463     {
 464       d = g_malloc (sizeof (GData));
 465       d-&gt;len = 0;
 466       d-&gt;alloc = 1;
 467     }
 468       else if (d-&gt;len == d-&gt;alloc)
 469     {
 470       d-&gt;alloc = d-&gt;alloc * 2;
 471       d = g_realloc (d, sizeof (GData) + (d-&gt;alloc - 1) * sizeof (GDataElt));
 472     }
 473       if (old_d != d)
 474     G_DATALIST_SET_POINTER (datalist, d);
 475 
 476       d-&gt;data[d-&gt;len].key = key_id;
 477       d-&gt;data[d-&gt;len].data = new_data;
 478       d-&gt;data[d-&gt;len].destroy = new_destroy_func;
 479       d-&gt;len++;
 480     }
 481 
 482   g_datalist_unlock (datalist);
 483 
 484   return NULL;
 485 
 486 }
 487 
 488 /**
 489  * g_dataset_id_set_data_full: (skip)
 490  * @dataset_location: (not nullable): the location identifying the dataset.
 491  * @key_id: the #GQuark id to identify the data element.
 492  * @data: the data element.
 493  * @destroy_func: the function to call when the data element is
 494  *                removed. This function will be called with the data
 495  *                element and can be used to free any memory allocated
 496  *                for it.
 497  *
 498  * Sets the data element associated with the given #GQuark id, and also
 499  * the function to call when the data element is destroyed. Any
 500  * previous data with the same key is removed, and its destroy function
 501  * is called.
 502  **/
 503 /**
 504  * g_dataset_set_data_full: (skip)
 505  * @l: the location identifying the dataset.
 506  * @k: the string to identify the data element.
 507  * @d: the data element.
 508  * @f: the function to call when the data element is removed. This
 509  *     function will be called with the data element and can be used to
 510  *     free any memory allocated for it.
 511  *
 512  * Sets the data corresponding to the given string identifier, and the
 513  * function to call when the data element is destroyed.
 514  **/
 515 /**
 516  * g_dataset_id_set_data:
 517  * @l: the location identifying the dataset.
 518  * @k: the #GQuark id to identify the data element.
 519  * @d: the data element.
 520  *
 521  * Sets the data element associated with the given #GQuark id. Any
 522  * previous data with the same key is removed, and its destroy function
 523  * is called.
 524  **/
 525 /**
 526  * g_dataset_set_data:
 527  * @l: the location identifying the dataset.
 528  * @k: the string to identify the data element.
 529  * @d: the data element.
 530  *
 531  * Sets the data corresponding to the given string identifier.
 532  **/
 533 /**
 534  * g_dataset_id_remove_data:
 535  * @l: the location identifying the dataset.
 536  * @k: the #GQuark id identifying the data element.
 537  *
 538  * Removes a data element from a dataset. The data element&#39;s destroy
 539  * function is called if it has been set.
 540  **/
 541 /**
 542  * g_dataset_remove_data:
 543  * @l: the location identifying the dataset.
 544  * @k: the string identifying the data element.
 545  *
 546  * Removes a data element corresponding to a string. Its destroy
 547  * function is called if it has been set.
 548  **/
 549 void
 550 g_dataset_id_set_data_full (gconstpointer  dataset_location,
 551                 GQuark         key_id,
 552                 gpointer       data,
 553                 GDestroyNotify destroy_func)
 554 {
 555   GDataset *dataset;
 556 
 557   g_return_if_fail (dataset_location != NULL);
 558   if (!data)
 559     g_return_if_fail (destroy_func == NULL);
 560   if (!key_id)
 561     {
 562       if (data)
 563     g_return_if_fail (key_id &gt; 0);
 564       else
 565     return;
 566     }
 567 
 568   G_LOCK (g_dataset_global);
 569   if (!g_dataset_location_ht)
 570     g_data_initialize ();
 571 
 572   dataset = g_dataset_lookup (dataset_location);
 573   if (!dataset)
 574     {
 575       dataset = g_slice_new (GDataset);
 576 #ifdef GSTREAMER_LITE
 577       if (dataset == NULL) {
 578         G_UNLOCK (g_dataset_global);
 579         return;
 580       }
 581 #endif // GSTREAMER_LITE
 582       dataset-&gt;location = dataset_location;
 583       g_datalist_init (&amp;dataset-&gt;datalist);
 584       g_hash_table_insert (g_dataset_location_ht,
 585                (gpointer) dataset-&gt;location,
 586                dataset);
 587     }
 588 
 589   g_data_set_internal (&amp;dataset-&gt;datalist, key_id, data, destroy_func, dataset);
 590   G_UNLOCK (g_dataset_global);
 591 }
 592 
 593 /**
 594  * g_datalist_id_set_data_full: (skip)
 595  * @datalist: a datalist.
 596  * @key_id: the #GQuark to identify the data element.
 597  * @data: (nullable): the data element or %NULL to remove any previous element
 598  *        corresponding to @key_id.
 599  * @destroy_func: (nullable): the function to call when the data element is
 600  *                removed. This function will be called with the data
 601  *                element and can be used to free any memory allocated
 602  *                for it. If @data is %NULL, then @destroy_func must
 603  *                also be %NULL.
 604  *
 605  * Sets the data corresponding to the given #GQuark id, and the
 606  * function to be called when the element is removed from the datalist.
 607  * Any previous data with the same key is removed, and its destroy
 608  * function is called.
 609  **/
 610 /**
 611  * g_datalist_set_data_full: (skip)
 612  * @dl: a datalist.
 613  * @k: the string to identify the data element.
 614  * @d: (nullable): the data element, or %NULL to remove any previous element
 615  *     corresponding to @k.
 616  * @f: (nullable): the function to call when the data element is removed.
 617  *     This function will be called with the data element and can be used to
 618  *     free any memory allocated for it. If @d is %NULL, then @f must
 619  *     also be %NULL.
 620  *
 621  * Sets the data element corresponding to the given string identifier,
 622  * and the function to be called when the data element is removed.
 623  **/
 624 /**
 625  * g_datalist_id_set_data:
 626  * @dl: a datalist.
 627  * @q: the #GQuark to identify the data element.
 628  * @d: (nullable): the data element, or %NULL to remove any previous element
 629  *     corresponding to @q.
 630  *
 631  * Sets the data corresponding to the given #GQuark id. Any previous
 632  * data with the same key is removed, and its destroy function is
 633  * called.
 634  **/
 635 /**
 636  * g_datalist_set_data:
 637  * @dl: a datalist.
 638  * @k: the string to identify the data element.
 639  * @d: (nullable): the data element, or %NULL to remove any previous element
 640  *     corresponding to @k.
 641  *
 642  * Sets the data element corresponding to the given string identifier.
 643  **/
 644 /**
 645  * g_datalist_id_remove_data:
 646  * @dl: a datalist.
 647  * @q: the #GQuark identifying the data element.
 648  *
 649  * Removes an element, using its #GQuark identifier.
 650  **/
 651 /**
 652  * g_datalist_remove_data:
 653  * @dl: a datalist.
 654  * @k: the string identifying the data element.
 655  *
 656  * Removes an element using its string identifier. The data element&#39;s
 657  * destroy function is called if it has been set.
 658  **/
 659 void
 660 g_datalist_id_set_data_full (GData    **datalist,
 661                              GQuark         key_id,
 662                              gpointer       data,
 663                              GDestroyNotify destroy_func)
 664 {
 665   g_return_if_fail (datalist != NULL);
 666   if (!data)
 667     g_return_if_fail (destroy_func == NULL);
 668   if (!key_id)
 669     {
 670       if (data)
 671     g_return_if_fail (key_id &gt; 0);
 672       else
 673     return;
 674     }
 675 
 676   g_data_set_internal (datalist, key_id, data, destroy_func, NULL);
 677 }
 678 
 679 /**
 680  * g_dataset_id_remove_no_notify: (skip)
 681  * @dataset_location: (not nullable): the location identifying the dataset.
 682  * @key_id: the #GQuark ID identifying the data element.
 683  *
 684  * Removes an element, without calling its destroy notification
 685  * function.
 686  *
 687  * Returns: (nullable): the data previously stored at @key_id,
 688  *          or %NULL if none.
 689  **/
 690 /**
 691  * g_dataset_remove_no_notify: (skip)
 692  * @l: the location identifying the dataset.
 693  * @k: the string identifying the data element.
 694  *
 695  * Removes an element, without calling its destroy notifier.
 696  **/
 697 gpointer
 698 g_dataset_id_remove_no_notify (gconstpointer  dataset_location,
 699                    GQuark         key_id)
 700 {
 701   gpointer ret_data = NULL;
 702 
 703   g_return_val_if_fail (dataset_location != NULL, NULL);
 704 
 705   G_LOCK (g_dataset_global);
 706   if (key_id &amp;&amp; g_dataset_location_ht)
 707     {
 708       GDataset *dataset;
 709 
 710       dataset = g_dataset_lookup (dataset_location);
 711       if (dataset)
 712     ret_data = g_data_set_internal (&amp;dataset-&gt;datalist, key_id, NULL, (GDestroyNotify) 42, dataset);
 713     }
 714   G_UNLOCK (g_dataset_global);
 715 
 716   return ret_data;
 717 }
 718 
 719 /**
 720  * g_datalist_id_remove_no_notify: (skip)
 721  * @datalist: a datalist.
 722  * @key_id: the #GQuark identifying a data element.
 723  *
 724  * Removes an element, without calling its destroy notification
 725  * function.
 726  *
 727  * Returns: (nullable): the data previously stored at @key_id,
 728  *          or %NULL if none.
 729  **/
 730 /**
 731  * g_datalist_remove_no_notify: (skip)
 732  * @dl: a datalist.
 733  * @k: the string identifying the data element.
 734  *
 735  * Removes an element, without calling its destroy notifier.
 736  **/
 737 gpointer
 738 g_datalist_id_remove_no_notify (GData   **datalist,
 739                                 GQuark    key_id)
 740 {
 741   gpointer ret_data = NULL;
 742 
 743   g_return_val_if_fail (datalist != NULL, NULL);
 744 
 745   if (key_id)
 746     ret_data = g_data_set_internal (datalist, key_id, NULL, (GDestroyNotify) 42, NULL);
 747 
 748   return ret_data;
 749 }
 750 
 751 /**
 752  * g_dataset_id_get_data:
 753  * @dataset_location: (not nullable): the location identifying the dataset.
 754  * @key_id: the #GQuark id to identify the data element.
 755  *
 756  * Gets the data element corresponding to a #GQuark.
 757  *
 758  * Returns: (transfer none) (nullable): the data element corresponding to
 759  *          the #GQuark, or %NULL if it is not found.
 760  **/
 761 /**
 762  * g_dataset_get_data:
 763  * @l: the location identifying the dataset.
 764  * @k: the string identifying the data element.
 765  *
 766  * Gets the data element corresponding to a string.
 767  *
 768  * Returns: (transfer none) (nullable): the data element corresponding to
 769  *          the string, or %NULL if it is not found.
 770  **/
 771 gpointer
 772 g_dataset_id_get_data (gconstpointer  dataset_location,
 773                        GQuark         key_id)
 774 {
 775   gpointer retval = NULL;
 776 
 777   g_return_val_if_fail (dataset_location != NULL, NULL);
 778 
 779   G_LOCK (g_dataset_global);
 780   if (key_id &amp;&amp; g_dataset_location_ht)
 781     {
 782       GDataset *dataset;
 783 
 784       dataset = g_dataset_lookup (dataset_location);
 785       if (dataset)
 786     retval = g_datalist_id_get_data (&amp;dataset-&gt;datalist, key_id);
 787     }
 788   G_UNLOCK (g_dataset_global);
 789 
 790   return retval;
 791 }
 792 
 793 /**
 794  * g_datalist_id_get_data:
 795  * @datalist: a datalist.
 796  * @key_id: the #GQuark identifying a data element.
 797  *
 798  * Retrieves the data element corresponding to @key_id.
 799  *
 800  * Returns: (transfer none) (nullable): the data element, or %NULL if
 801  *          it is not found.
 802  */
 803 gpointer
 804 g_datalist_id_get_data (GData  **datalist,
 805                         GQuark   key_id)
 806 {
 807   return g_datalist_id_dup_data (datalist, key_id, NULL, NULL);
 808 }
 809 
 810 /**
 811  * GDuplicateFunc:
 812  * @data: the data to duplicate
 813  * @user_data: (closure): user data that was specified in
 814  *             g_datalist_id_dup_data()
 815  *
 816  * The type of functions that are used to &#39;duplicate&#39; an object.
 817  * What this means depends on the context, it could just be
 818  * incrementing the reference count, if @data is a ref-counted
 819  * object.
 820  *
 821  * Returns: a duplicate of data
 822  */
 823 
 824 /**
 825  * g_datalist_id_dup_data: (skip)
 826  * @datalist: location of a datalist
 827  * @key_id: the #GQuark identifying a data element
 828  * @dup_func: (nullable) (scope call): function to duplicate the old value
 829  * @user_data: (closure): passed as user_data to @dup_func
 830  *
 831  * This is a variant of g_datalist_id_get_data() which
 832  * returns a &#39;duplicate&#39; of the value. @dup_func defines the
 833  * meaning of &#39;duplicate&#39; in this context, it could e.g.
 834  * take a reference on a ref-counted object.
 835  *
 836  * If the @key_id is not set in the datalist then @dup_func
 837  * will be called with a %NULL argument.
 838  *
 839  * Note that @dup_func is called while the datalist is locked, so it
 840  * is not allowed to read or modify the datalist.
 841  *
 842  * This function can be useful to avoid races when multiple
 843  * threads are using the same datalist and the same key.
 844  *
 845  * Returns: (nullable): the result of calling @dup_func on the value
 846  *     associated with @key_id in @datalist, or %NULL if not set.
 847  *     If @dup_func is %NULL, the value is returned unmodified.
 848  *
 849  * Since: 2.34
 850  */
 851 gpointer
 852 g_datalist_id_dup_data (GData          **datalist,
 853                         GQuark           key_id,
 854                         GDuplicateFunc   dup_func,
 855                         gpointer         user_data)
 856 {
 857   gpointer val = NULL;
 858   gpointer retval = NULL;
 859   GData *d;
 860   GDataElt *data, *data_end;
 861 
 862   g_datalist_lock (datalist);
 863 
 864   d = G_DATALIST_GET_POINTER (datalist);
 865   if (d)
 866     {
 867       data = d-&gt;data;
 868       data_end = data + d-&gt;len;
 869       do
 870         {
 871           if (data-&gt;key == key_id)
 872             {
 873               val = data-&gt;data;
 874               break;
 875             }
 876           data++;
 877         }
 878       while (data &lt; data_end);
 879     }
 880 
 881   if (dup_func)
 882     retval = dup_func (val, user_data);
 883   else
 884     retval = val;
 885 
 886   g_datalist_unlock (datalist);
 887 
 888   return retval;
 889 }
 890 
 891 /**
 892  * g_datalist_id_replace_data: (skip)
 893  * @datalist: location of a datalist
 894  * @key_id: the #GQuark identifying a data element
 895  * @oldval: (nullable): the old value to compare against
 896  * @newval: (nullable): the new value to replace it with
 897  * @destroy: (nullable): destroy notify for the new value
 898  * @old_destroy: (out) (optional): destroy notify for the existing value
 899  *
 900  * Compares the member that is associated with @key_id in
 901  * @datalist to @oldval, and if they are the same, replace
 902  * @oldval with @newval.
 903  *
 904  * This is like a typical atomic compare-and-exchange
 905  * operation, for a member of @datalist.
 906  *
 907  * If the previous value was replaced then ownership of the
 908  * old value (@oldval) is passed to the caller, including
 909  * the registered destroy notify for it (passed out in @old_destroy).
 910  * Its up to the caller to free this as he wishes, which may
 911  * or may not include using @old_destroy as sometimes replacement
 912  * should not destroy the object in the normal way.
 913  *
 914  * Returns: %TRUE if the existing value for @key_id was replaced
 915  *  by @newval, %FALSE otherwise.
 916  *
 917  * Since: 2.34
 918  */
 919 gboolean
 920 g_datalist_id_replace_data (GData          **datalist,
 921                             GQuark           key_id,
 922                             gpointer         oldval,
 923                             gpointer         newval,
 924                             GDestroyNotify   destroy,
 925                             GDestroyNotify  *old_destroy)
 926 {
 927   gpointer val = NULL;
 928   GData *d;
 929   GDataElt *data, *data_end;
 930 
 931   g_return_val_if_fail (datalist != NULL, FALSE);
 932   g_return_val_if_fail (key_id != 0, FALSE);
 933 
 934   if (old_destroy)
 935     *old_destroy = NULL;
 936 
 937   g_datalist_lock (datalist);
 938 
 939   d = G_DATALIST_GET_POINTER (datalist);
 940   if (d)
 941     {
 942       data = d-&gt;data;
 943       data_end = data + d-&gt;len - 1;
 944       while (data &lt;= data_end)
 945         {
 946           if (data-&gt;key == key_id)
 947             {
 948               val = data-&gt;data;
 949               if (val == oldval)
 950                 {
 951                   if (old_destroy)
 952                     *old_destroy = data-&gt;destroy;
 953                   if (newval != NULL)
 954                     {
 955                       data-&gt;data = newval;
 956                       data-&gt;destroy = destroy;
 957                     }
 958                   else
 959                    {
 960                      if (data != data_end)
 961                        *data = *data_end;
 962                      d-&gt;len--;
 963 
 964                      /* We don&#39;t bother to shrink, but if all data are now gone
 965                       * we at least free the memory
 966                       */
 967                      if (d-&gt;len == 0)
 968                        {
 969                          G_DATALIST_SET_POINTER (datalist, NULL);
 970                          g_free (d);
 971                        }
 972                    }
 973                 }
 974               break;
 975             }
 976           data++;
 977         }
 978     }
 979 
 980   if (val == NULL &amp;&amp; oldval == NULL &amp;&amp; newval != NULL)
 981     {
 982       GData *old_d;
 983 
 984       /* insert newval */
 985       old_d = d;
 986       if (d == NULL)
 987     {
 988           d = g_malloc (sizeof (GData));
 989           d-&gt;len = 0;
 990           d-&gt;alloc = 1;
 991         }
 992       else if (d-&gt;len == d-&gt;alloc)
 993         {
 994           d-&gt;alloc = d-&gt;alloc * 2;
 995           d = g_realloc (d, sizeof (GData) + (d-&gt;alloc - 1) * sizeof (GDataElt));
 996         }
 997       if (old_d != d)
 998         G_DATALIST_SET_POINTER (datalist, d);
 999 
1000       d-&gt;data[d-&gt;len].key = key_id;
1001       d-&gt;data[d-&gt;len].data = newval;
1002       d-&gt;data[d-&gt;len].destroy = destroy;
1003       d-&gt;len++;
1004     }
1005 
1006   g_datalist_unlock (datalist);
1007 
1008   return val == oldval;
1009 }
1010 
1011 /**
1012  * g_datalist_get_data:
1013  * @datalist: a datalist.
1014  * @key: the string identifying a data element.
1015  *
1016  * Gets a data element, using its string identifier. This is slower than
1017  * g_datalist_id_get_data() because it compares strings.
1018  *
1019  * Returns: (transfer none) (nullable): the data element, or %NULL if it
1020  *          is not found.
1021  **/
1022 gpointer
1023 g_datalist_get_data (GData   **datalist,
1024                      const gchar *key)
1025 {
1026   gpointer res = NULL;
1027   GData *d;
1028   GDataElt *data, *data_end;
1029 
1030   g_return_val_if_fail (datalist != NULL, NULL);
1031 
1032   g_datalist_lock (datalist);
1033 
1034   d = G_DATALIST_GET_POINTER (datalist);
1035   if (d)
1036     {
1037       data = d-&gt;data;
1038       data_end = data + d-&gt;len;
1039       while (data &lt; data_end)
1040     {
1041       if (g_strcmp0 (g_quark_to_string (data-&gt;key), key) == 0)
1042         {
1043           res = data-&gt;data;
1044           break;
1045         }
1046       data++;
1047     }
1048     }
1049 
1050   g_datalist_unlock (datalist);
1051 
1052   return res;
1053 }
1054 
1055 /**
1056  * GDataForeachFunc:
1057  * @key_id: the #GQuark id to identifying the data element.
1058  * @data: the data element.
1059  * @user_data: (closure): user data passed to g_dataset_foreach().
1060  *
1061  * Specifies the type of function passed to g_dataset_foreach(). It is
1062  * called with each #GQuark id and associated data element, together
1063  * with the @user_data parameter supplied to g_dataset_foreach().
1064  **/
1065 
1066 /**
1067  * g_dataset_foreach:
1068  * @dataset_location: (not nullable): the location identifying the dataset.
1069  * @func: (scope call): the function to call for each data element.
1070  * @user_data: (closure): user data to pass to the function.
1071  *
1072  * Calls the given function for each data element which is associated
1073  * with the given location. Note that this function is NOT thread-safe.
1074  * So unless @dataset_location can be protected from any modifications
1075  * during invocation of this function, it should not be called.
1076  *
1077  * @func can make changes to the dataset, but the iteration will not
1078  * reflect changes made during the g_dataset_foreach() call, other
1079  * than skipping over elements that are removed.
1080  **/
1081 void
1082 g_dataset_foreach (gconstpointer    dataset_location,
1083            GDataForeachFunc func,
1084            gpointer         user_data)
1085 {
1086   GDataset *dataset;
1087 
1088   g_return_if_fail (dataset_location != NULL);
1089   g_return_if_fail (func != NULL);
1090 
1091   G_LOCK (g_dataset_global);
1092   if (g_dataset_location_ht)
1093     {
1094       dataset = g_dataset_lookup (dataset_location);
1095       G_UNLOCK (g_dataset_global);
1096       if (dataset)
1097     g_datalist_foreach (&amp;dataset-&gt;datalist, func, user_data);
1098     }
1099   else
1100     {
1101       G_UNLOCK (g_dataset_global);
1102     }
1103 }
1104 
1105 /**
1106  * g_datalist_foreach:
1107  * @datalist: a datalist.
1108  * @func: (scope call): the function to call for each data element.
1109  * @user_data: (closure): user data to pass to the function.
1110  *
1111  * Calls the given function for each data element of the datalist. The
1112  * function is called with each data element&#39;s #GQuark id and data,
1113  * together with the given @user_data parameter. Note that this
1114  * function is NOT thread-safe. So unless @datalist can be protected
1115  * from any modifications during invocation of this function, it should
1116  * not be called.
1117  *
1118  * @func can make changes to @datalist, but the iteration will not
1119  * reflect changes made during the g_datalist_foreach() call, other
1120  * than skipping over elements that are removed.
1121  **/
1122 void
1123 g_datalist_foreach (GData      **datalist,
1124                     GDataForeachFunc func,
1125                     gpointer         user_data)
1126 {
1127   GData *d;
1128   int i, j, len;
1129   GQuark *keys;
1130 
1131   g_return_if_fail (datalist != NULL);
1132   g_return_if_fail (func != NULL);
1133 
1134   d = G_DATALIST_GET_POINTER (datalist);
1135   if (d == NULL)
1136     return;
1137 
1138   /* We make a copy of the keys so that we can handle it changing
1139      in the callback */
1140   len = d-&gt;len;
1141   keys = g_new (GQuark, len);
1142   for (i = 0; i &lt; len; i++)
1143     keys[i] = d-&gt;data[i].key;
1144 
1145   for (i = 0; i &lt; len; i++)
1146     {
1147       /* A previous callback might have removed a later item, so always check that
1148      it still exists before calling */
1149       d = G_DATALIST_GET_POINTER (datalist);
1150 
1151       if (d == NULL)
1152     break;
1153       for (j = 0; j &lt; d-&gt;len; j++)
1154     {
1155       if (d-&gt;data[j].key == keys[i]) {
1156         func (d-&gt;data[i].key, d-&gt;data[i].data, user_data);
1157         break;
1158       }
1159     }
1160     }
1161   g_free (keys);
1162 }
1163 
1164 /**
1165  * g_datalist_init: (skip)
1166  * @datalist: a pointer to a pointer to a datalist.
1167  *
1168  * Resets the datalist to %NULL. It does not free any memory or call
1169  * any destroy functions.
1170  **/
1171 void
1172 g_datalist_init (GData **datalist)
1173 {
1174   g_return_if_fail (datalist != NULL);
1175 
1176   g_atomic_pointer_set (datalist, NULL);
1177 }
1178 
1179 /**
1180  * g_datalist_set_flags:
1181  * @datalist: pointer to the location that holds a list
1182  * @flags: the flags to turn on. The values of the flags are
1183  *   restricted by %G_DATALIST_FLAGS_MASK (currently
1184  *   3; giving two possible boolean flags).
1185  *   A value for @flags that doesn&#39;t fit within the mask is
1186  *   an error.
1187  *
1188  * Turns on flag values for a data list. This function is used
1189  * to keep a small number of boolean flags in an object with
1190  * a data list without using any additional space. It is
1191  * not generally useful except in circumstances where space
1192  * is very tight. (It is used in the base #GObject type, for
1193  * example.)
1194  *
1195  * Since: 2.8
1196  **/
1197 void
1198 g_datalist_set_flags (GData **datalist,
1199                       guint   flags)
1200 {
1201   g_return_if_fail (datalist != NULL);
1202   g_return_if_fail ((flags &amp; ~G_DATALIST_FLAGS_MASK) == 0);
1203 
1204   g_atomic_pointer_or (datalist, (gsize)flags);
1205 }
1206 
1207 /**
1208  * g_datalist_unset_flags:
1209  * @datalist: pointer to the location that holds a list
1210  * @flags: the flags to turn off. The values of the flags are
1211  *   restricted by %G_DATALIST_FLAGS_MASK (currently
1212  *   3: giving two possible boolean flags).
1213  *   A value for @flags that doesn&#39;t fit within the mask is
1214  *   an error.
1215  *
1216  * Turns off flag values for a data list. See g_datalist_unset_flags()
1217  *
1218  * Since: 2.8
1219  **/
1220 void
1221 g_datalist_unset_flags (GData **datalist,
1222                         guint   flags)
1223 {
1224   g_return_if_fail (datalist != NULL);
1225   g_return_if_fail ((flags &amp; ~G_DATALIST_FLAGS_MASK) == 0);
1226 
1227   g_atomic_pointer_and (datalist, ~(gsize)flags);
1228 }
1229 
1230 /**
1231  * g_datalist_get_flags:
1232  * @datalist: pointer to the location that holds a list
1233  *
1234  * Gets flags values packed in together with the datalist.
1235  * See g_datalist_set_flags().
1236  *
1237  * Returns: the flags of the datalist
1238  *
1239  * Since: 2.8
1240  **/
1241 guint
1242 g_datalist_get_flags (GData **datalist)
1243 {
1244   g_return_val_if_fail (datalist != NULL, 0);
1245 
1246   return G_DATALIST_GET_FLAGS (datalist); /* atomic macro */
1247 }
1248 
1249 /* HOLDS: g_dataset_global_lock */
1250 static void
1251 g_data_initialize (void)
1252 {
1253   g_return_if_fail (g_dataset_location_ht == NULL);
1254 
1255   g_dataset_location_ht = g_hash_table_new (g_direct_hash, NULL);
1256   g_dataset_cached = NULL;
1257 }
    </pre>
  </body>
</html>