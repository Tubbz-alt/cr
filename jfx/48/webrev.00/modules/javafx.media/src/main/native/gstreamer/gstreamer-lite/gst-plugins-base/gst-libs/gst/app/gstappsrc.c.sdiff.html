<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/app/gstappsrc.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstappsink.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../audio/audio-channel-mixer.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/app/gstappsrc.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 225 static gboolean gst_app_src_stop (GstBaseSrc * bsrc);
 226 static gboolean gst_app_src_unlock (GstBaseSrc * bsrc);
 227 static gboolean gst_app_src_unlock_stop (GstBaseSrc * bsrc);
 228 static gboolean gst_app_src_do_seek (GstBaseSrc * src, GstSegment * segment);
 229 static gboolean gst_app_src_is_seekable (GstBaseSrc * src);
 230 static gboolean gst_app_src_do_get_size (GstBaseSrc * src, guint64 * size);
 231 static gboolean gst_app_src_query (GstBaseSrc * src, GstQuery * query);
 232 static gboolean gst_app_src_event (GstBaseSrc * src, GstEvent * event);
 233 
 234 static GstFlowReturn gst_app_src_push_buffer_action (GstAppSrc * appsrc,
 235     GstBuffer * buffer);
 236 static GstFlowReturn gst_app_src_push_buffer_list_action (GstAppSrc * appsrc,
 237     GstBufferList * buffer_list);
 238 static GstFlowReturn gst_app_src_push_sample_action (GstAppSrc * appsrc,
 239     GstSample * sample);
 240 
 241 static guint gst_app_src_signals[LAST_SIGNAL] = { 0 };
 242 
 243 #define gst_app_src_parent_class parent_class
 244 G_DEFINE_TYPE_WITH_CODE (GstAppSrc, gst_app_src, GST_TYPE_BASE_SRC,

 245     G_IMPLEMENT_INTERFACE (GST_TYPE_URI_HANDLER, gst_app_src_uri_handler_init));
 246 
 247 static void
 248 gst_app_src_class_init (GstAppSrcClass * klass)
 249 {
 250   GObjectClass *gobject_class = (GObjectClass *) klass;
 251   GstElementClass *element_class = (GstElementClass *) klass;
 252   GstBaseSrcClass *basesrc_class = (GstBaseSrcClass *) klass;
 253 
 254   GST_DEBUG_CATEGORY_INIT (app_src_debug, &quot;appsrc&quot;, 0, &quot;appsrc element&quot;);
 255 
 256   gobject_class-&gt;dispose = gst_app_src_dispose;
 257   gobject_class-&gt;finalize = gst_app_src_finalize;
 258 
 259   gobject_class-&gt;set_property = gst_app_src_set_property;
 260   gobject_class-&gt;get_property = gst_app_src_get_property;
 261 
 262   /**
 263    * GstAppSrc::caps:
 264    *
</pre>
<hr />
<pre>
 355   g_object_class_install_property (gobject_class, PROP_MAX_LATENCY,
 356       g_param_spec_int64 (&quot;max-latency&quot;, &quot;Max Latency&quot;,
 357           &quot;The maximum latency (-1 = unlimited)&quot;,
 358           -1, G_MAXINT64, DEFAULT_PROP_MAX_LATENCY,
 359           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 360 
 361   /**
 362    * GstAppSrc::emit-signals:
 363    *
 364    * Make appsrc emit the &quot;need-data&quot;, &quot;enough-data&quot; and &quot;seek-data&quot; signals.
 365    * This option is by default enabled for backwards compatibility reasons but
 366    * can disabled when needed because signal emission is expensive.
 367    */
 368   g_object_class_install_property (gobject_class, PROP_EMIT_SIGNALS,
 369       g_param_spec_boolean (&quot;emit-signals&quot;, &quot;Emit signals&quot;,
 370           &quot;Emit need-data, enough-data and seek-data signals&quot;,
 371           DEFAULT_PROP_EMIT_SIGNALS,
 372           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 373 
 374   /**
<span class="line-modified"> 375    * GstAppSrc::empty-percent:</span>
 376    *
 377    * Make appsrc emit the &quot;need-data&quot; signal when the amount of bytes in the
 378    * queue drops below this percentage of max-bytes.
 379    */
 380   g_object_class_install_property (gobject_class, PROP_MIN_PERCENT,
 381       g_param_spec_uint (&quot;min-percent&quot;, &quot;Min Percent&quot;,
 382           &quot;Emit need-data when queued bytes drops below this percent of max-bytes&quot;,
 383           0, 100, DEFAULT_PROP_MIN_PERCENT,
 384           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 385 
 386   /**
 387    * GstAppSrc::current-level-bytes:
 388    *
 389    * The number of currently queued bytes inside appsrc.
 390    *
 391    * Since: 1.2
 392    */
 393   g_object_class_install_property (gobject_class, PROP_CURRENT_LEVEL_BYTES,
 394       g_param_spec_uint64 (&quot;current-level-bytes&quot;, &quot;Current Level Bytes&quot;,
 395           &quot;The number of currently queued bytes&quot;,
</pre>
<hr />
<pre>
 545 
 546   element_class-&gt;send_event = gst_app_src_send_event;
 547 
 548   basesrc_class-&gt;negotiate = gst_app_src_negotiate;
 549   basesrc_class-&gt;get_caps = gst_app_src_internal_get_caps;
 550   basesrc_class-&gt;create = gst_app_src_create;
 551   basesrc_class-&gt;start = gst_app_src_start;
 552   basesrc_class-&gt;stop = gst_app_src_stop;
 553   basesrc_class-&gt;unlock = gst_app_src_unlock;
 554   basesrc_class-&gt;unlock_stop = gst_app_src_unlock_stop;
 555   basesrc_class-&gt;do_seek = gst_app_src_do_seek;
 556   basesrc_class-&gt;is_seekable = gst_app_src_is_seekable;
 557   basesrc_class-&gt;get_size = gst_app_src_do_get_size;
 558   basesrc_class-&gt;query = gst_app_src_query;
 559   basesrc_class-&gt;event = gst_app_src_event;
 560 
 561   klass-&gt;push_buffer = gst_app_src_push_buffer_action;
 562   klass-&gt;push_buffer_list = gst_app_src_push_buffer_list_action;
 563   klass-&gt;push_sample = gst_app_src_push_sample_action;
 564   klass-&gt;end_of_stream = gst_app_src_end_of_stream;
<span class="line-removed"> 565 </span>
<span class="line-removed"> 566   g_type_class_add_private (klass, sizeof (GstAppSrcPrivate));</span>
 567 }
 568 
 569 static void
 570 gst_app_src_init (GstAppSrc * appsrc)
 571 {
 572   GstAppSrcPrivate *priv;
 573 
<span class="line-modified"> 574   priv = appsrc-&gt;priv = G_TYPE_INSTANCE_GET_PRIVATE (appsrc, GST_TYPE_APP_SRC,</span>
<span class="line-removed"> 575       GstAppSrcPrivate);</span>
 576 
 577   g_mutex_init (&amp;priv-&gt;mutex);
 578   g_cond_init (&amp;priv-&gt;cond);
 579   priv-&gt;queue = gst_queue_array_new (16);
 580   priv-&gt;wait_status = NOONE_WAITING;
 581 
 582   priv-&gt;size = DEFAULT_PROP_SIZE;
 583   priv-&gt;duration = DEFAULT_PROP_DURATION;
 584   priv-&gt;stream_type = DEFAULT_PROP_STREAM_TYPE;
 585   priv-&gt;max_bytes = DEFAULT_PROP_MAX_BYTES;
 586   priv-&gt;format = DEFAULT_PROP_FORMAT;
 587   priv-&gt;block = DEFAULT_PROP_BLOCK;
 588   priv-&gt;min_latency = DEFAULT_PROP_MIN_LATENCY;
 589   priv-&gt;max_latency = DEFAULT_PROP_MAX_LATENCY;
 590   priv-&gt;emit_signals = DEFAULT_PROP_EMIT_SIGNALS;
 591   priv-&gt;min_percent = DEFAULT_PROP_MIN_PERCENT;
 592 
 593   gst_base_src_set_live (GST_BASE_SRC (appsrc), DEFAULT_PROP_IS_LIVE);
 594 }
 595 
</pre>
<hr />
<pre>
1185     if (!gst_queue_array_is_empty (priv-&gt;queue)) {
1186       guint buf_size;
1187       GstMiniObject *obj = gst_queue_array_pop_head (priv-&gt;queue);
1188 
1189       if (GST_IS_CAPS (obj)) {
1190         GstCaps *next_caps = GST_CAPS (obj);
1191         gboolean caps_changed = TRUE;
1192 
1193         if (next_caps &amp;&amp; priv-&gt;current_caps)
1194           caps_changed = !gst_caps_is_equal (next_caps, priv-&gt;current_caps);
1195         else
1196           caps_changed = (next_caps != priv-&gt;current_caps);
1197 
1198         gst_caps_replace (&amp;priv-&gt;current_caps, next_caps);
1199 
1200         if (next_caps) {
1201           gst_caps_unref (next_caps);
1202         }
1203 
1204         if (caps_changed)
<span class="line-modified">1205         gst_app_src_do_negotiate (bsrc);</span>
1206 
1207         /* Lock has released so now may need
1208          *- flushing
1209          *- new caps change
1210          *- check queue has data */
1211         if (G_UNLIKELY (priv-&gt;flushing))
1212           goto flushing;
1213 
1214         /* Continue checks caps and queue */
1215         continue;
1216       }
1217 
1218       if (GST_IS_BUFFER (obj)) {
1219         *buf = GST_BUFFER (obj);
<span class="line-modified">1220       buf_size = gst_buffer_get_size (*buf);</span>
1221         GST_LOG_OBJECT (appsrc, &quot;have buffer %p of size %u&quot;, *buf, buf_size);
1222       } else {
1223         GstBufferList *buffer_list;
1224 
1225         g_assert (GST_IS_BUFFER_LIST (obj));
1226 
1227         buffer_list = GST_BUFFER_LIST (obj);
1228 
1229         buf_size = gst_buffer_list_calculate_size (buffer_list);
1230 
1231         GST_LOG_OBJECT (appsrc, &quot;have buffer list %p of size %u, %u buffers&quot;,
1232             buffer_list, buf_size, gst_buffer_list_length (buffer_list));
1233 
1234         gst_base_src_submit_buffer_list (bsrc, buffer_list);
1235         *buf = NULL;
1236       }
1237 
1238       priv-&gt;queued_bytes -= buf_size;
1239 
1240       /* only update the offset when in random_access mode */
1241       if (priv-&gt;stream_type == GST_APP_STREAM_TYPE_RANDOM_ACCESS)
1242         priv-&gt;offset += buf_size;
1243 
1244       /* signal that we removed an item */
1245       if ((priv-&gt;wait_status &amp; APP_WAITING))
<span class="line-modified">1246       g_cond_broadcast (&amp;priv-&gt;cond);</span>
1247 
<span class="line-modified">1248       /* see if we go lower than the empty-percent */</span>
1249       if (priv-&gt;min_percent &amp;&amp; priv-&gt;max_bytes) {
1250         if (priv-&gt;queued_bytes * 100 / priv-&gt;max_bytes &lt;= priv-&gt;min_percent)
1251           /* ignore flushing state, we got a buffer and we will return it now.
1252            * Errors will be handled in the next round */
1253           gst_app_src_emit_need_data (appsrc, size);
1254       }
1255       ret = GST_FLOW_OK;
1256       break;
1257     } else {
1258       gst_app_src_emit_need_data (appsrc, size);
1259 
1260       /* we can be flushing now because we released the lock above */
1261       if (G_UNLIKELY (priv-&gt;flushing))
1262         goto flushing;
1263 
1264       /* if we have a buffer now, continue the loop and try to return it. In
1265        * random-access mode (where a buffer is normally pushed in the above
1266        * signal) we can still be empty because the pushed buffer got flushed or
1267        * when the application pushes the requested buffer later, we support both
1268        * possibilities. */
</pre>
<hr />
<pre>
1324   GstAppSrcPrivate *priv;
1325   gboolean caps_changed;
1326 
1327   g_return_if_fail (GST_IS_APP_SRC (appsrc));
1328 
1329   priv = appsrc-&gt;priv;
1330 
1331   g_mutex_lock (&amp;priv-&gt;mutex);
1332 
1333   GST_OBJECT_LOCK (appsrc);
1334   if (caps &amp;&amp; priv-&gt;last_caps)
1335     caps_changed = !gst_caps_is_equal (caps, priv-&gt;last_caps);
1336   else
1337     caps_changed = (caps != priv-&gt;last_caps);
1338 
1339   if (caps_changed) {
1340     GstCaps *new_caps;
1341     gpointer t;
1342 
1343     new_caps = caps ? gst_caps_copy (caps) : NULL;
<span class="line-modified">1344   GST_DEBUG_OBJECT (appsrc, &quot;setting caps to %&quot; GST_PTR_FORMAT, caps);</span>
1345 
1346     while ((t = gst_queue_array_peek_tail (priv-&gt;queue)) &amp;&amp; GST_IS_CAPS (t)) {
1347       gst_caps_unref (gst_queue_array_pop_tail (priv-&gt;queue));
<span class="line-modified">1348   }</span>
1349     gst_queue_array_push_tail (priv-&gt;queue, new_caps);
1350     gst_caps_replace (&amp;priv-&gt;last_caps, new_caps);
1351   }
1352 
1353   GST_OBJECT_UNLOCK (appsrc);
1354 
1355   g_mutex_unlock (&amp;priv-&gt;mutex);
1356 }
1357 
1358 /**
1359  * gst_app_src_get_caps:
1360  * @appsrc: a #GstAppSrc
1361  *
1362  * Get the configured caps on @appsrc.
1363  *
1364  * Returns: the #GstCaps produced by the source. gst_caps_unref() after usage.
1365  */
1366 GstCaps *
1367 gst_app_src_get_caps (GstAppSrc * appsrc)
1368 {
</pre>
<hr />
<pre>
1843         priv-&gt;wait_status |= APP_WAITING;
1844         g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);
1845         priv-&gt;wait_status &amp;= ~APP_WAITING;
1846       } else {
1847         /* no need to wait for free space, we just pump more data into the
1848          * queue hoping that the caller reacts to the enough-data signal and
1849          * stops pushing buffers. */
1850         break;
1851       }
1852     } else
1853       break;
1854   }
1855 
1856   if (buflist != NULL) {
1857     GST_DEBUG_OBJECT (appsrc, &quot;queueing buffer list %p&quot;, buflist);
1858     if (!steal_ref)
1859       gst_buffer_list_ref (buflist);
1860     gst_queue_array_push_tail (priv-&gt;queue, buflist);
1861     priv-&gt;queued_bytes += gst_buffer_list_calculate_size (buflist);
1862   } else {
<span class="line-modified">1863   GST_DEBUG_OBJECT (appsrc, &quot;queueing buffer %p&quot;, buffer);</span>
<span class="line-modified">1864   if (!steal_ref)</span>
<span class="line-modified">1865     gst_buffer_ref (buffer);</span>
1866     gst_queue_array_push_tail (priv-&gt;queue, buffer);
<span class="line-modified">1867   priv-&gt;queued_bytes += gst_buffer_get_size (buffer);</span>
1868   }
1869 
1870   if ((priv-&gt;wait_status &amp; STREAM_WAITING))
<span class="line-modified">1871   g_cond_broadcast (&amp;priv-&gt;cond);</span>
1872 
1873   g_mutex_unlock (&amp;priv-&gt;mutex);
1874 
1875   return GST_FLOW_OK;
1876 
1877   /* ERRORS */
1878 flushing:
1879   {
1880     GST_DEBUG_OBJECT (appsrc, &quot;refuse buffer %p, we are flushing&quot;, buffer);
1881     if (steal_ref)
1882       gst_buffer_unref (buffer);
1883     g_mutex_unlock (&amp;priv-&gt;mutex);
1884     return GST_FLOW_FLUSHING;
1885   }
1886 eos:
1887   {
1888     GST_DEBUG_OBJECT (appsrc, &quot;refuse buffer %p, we are EOS&quot;, buffer);
1889     if (steal_ref)
1890       gst_buffer_unref (buffer);
1891     g_mutex_unlock (&amp;priv-&gt;mutex);
</pre>
<hr />
<pre>
1967  *
1968  * Since: 1.14
1969  */
1970 GstFlowReturn
1971 gst_app_src_push_buffer_list (GstAppSrc * appsrc, GstBufferList * buffer_list)
1972 {
1973   return gst_app_src_push_internal (appsrc, NULL, buffer_list, TRUE);
1974 }
1975 
1976 /**
1977  * gst_app_src_push_sample:
1978  * @appsrc: a #GstAppSrc
1979  * @sample: (transfer none): a #GstSample from which buffer and caps may be
1980  * extracted
1981  *
1982  * Extract a buffer from the provided sample and adds it to the queue of
1983  * buffers that the appsrc element will push to its source pad. Any
1984  * previous caps that were set on appsrc will be replaced by the caps
1985  * associated with the sample if not equal.
1986  *



1987  * When the block property is TRUE, this function can block until free
1988  * space becomes available in the queue.
1989  *
1990  * Returns: #GST_FLOW_OK when the buffer was successfuly queued.
1991  * #GST_FLOW_FLUSHING when @appsrc is not PAUSED or PLAYING.
1992  * #GST_FLOW_EOS when EOS occured.
1993  *
1994  * Since: 1.6
1995  *
1996  */
1997 GstFlowReturn
1998 gst_app_src_push_sample (GstAppSrc * appsrc, GstSample * sample)
1999 {
2000   return gst_app_src_push_sample_internal (appsrc, sample);
2001 }
2002 
2003 /* push a buffer without stealing the ref of the buffer. This is used for the
2004  * action signal. */
2005 static GstFlowReturn
2006 gst_app_src_push_buffer_action (GstAppSrc * appsrc, GstBuffer * buffer)
</pre>
</td>
<td>
<hr />
<pre>
 225 static gboolean gst_app_src_stop (GstBaseSrc * bsrc);
 226 static gboolean gst_app_src_unlock (GstBaseSrc * bsrc);
 227 static gboolean gst_app_src_unlock_stop (GstBaseSrc * bsrc);
 228 static gboolean gst_app_src_do_seek (GstBaseSrc * src, GstSegment * segment);
 229 static gboolean gst_app_src_is_seekable (GstBaseSrc * src);
 230 static gboolean gst_app_src_do_get_size (GstBaseSrc * src, guint64 * size);
 231 static gboolean gst_app_src_query (GstBaseSrc * src, GstQuery * query);
 232 static gboolean gst_app_src_event (GstBaseSrc * src, GstEvent * event);
 233 
 234 static GstFlowReturn gst_app_src_push_buffer_action (GstAppSrc * appsrc,
 235     GstBuffer * buffer);
 236 static GstFlowReturn gst_app_src_push_buffer_list_action (GstAppSrc * appsrc,
 237     GstBufferList * buffer_list);
 238 static GstFlowReturn gst_app_src_push_sample_action (GstAppSrc * appsrc,
 239     GstSample * sample);
 240 
 241 static guint gst_app_src_signals[LAST_SIGNAL] = { 0 };
 242 
 243 #define gst_app_src_parent_class parent_class
 244 G_DEFINE_TYPE_WITH_CODE (GstAppSrc, gst_app_src, GST_TYPE_BASE_SRC,
<span class="line-added"> 245     G_ADD_PRIVATE (GstAppSrc)</span>
 246     G_IMPLEMENT_INTERFACE (GST_TYPE_URI_HANDLER, gst_app_src_uri_handler_init));
 247 
 248 static void
 249 gst_app_src_class_init (GstAppSrcClass * klass)
 250 {
 251   GObjectClass *gobject_class = (GObjectClass *) klass;
 252   GstElementClass *element_class = (GstElementClass *) klass;
 253   GstBaseSrcClass *basesrc_class = (GstBaseSrcClass *) klass;
 254 
 255   GST_DEBUG_CATEGORY_INIT (app_src_debug, &quot;appsrc&quot;, 0, &quot;appsrc element&quot;);
 256 
 257   gobject_class-&gt;dispose = gst_app_src_dispose;
 258   gobject_class-&gt;finalize = gst_app_src_finalize;
 259 
 260   gobject_class-&gt;set_property = gst_app_src_set_property;
 261   gobject_class-&gt;get_property = gst_app_src_get_property;
 262 
 263   /**
 264    * GstAppSrc::caps:
 265    *
</pre>
<hr />
<pre>
 356   g_object_class_install_property (gobject_class, PROP_MAX_LATENCY,
 357       g_param_spec_int64 (&quot;max-latency&quot;, &quot;Max Latency&quot;,
 358           &quot;The maximum latency (-1 = unlimited)&quot;,
 359           -1, G_MAXINT64, DEFAULT_PROP_MAX_LATENCY,
 360           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 361 
 362   /**
 363    * GstAppSrc::emit-signals:
 364    *
 365    * Make appsrc emit the &quot;need-data&quot;, &quot;enough-data&quot; and &quot;seek-data&quot; signals.
 366    * This option is by default enabled for backwards compatibility reasons but
 367    * can disabled when needed because signal emission is expensive.
 368    */
 369   g_object_class_install_property (gobject_class, PROP_EMIT_SIGNALS,
 370       g_param_spec_boolean (&quot;emit-signals&quot;, &quot;Emit signals&quot;,
 371           &quot;Emit need-data, enough-data and seek-data signals&quot;,
 372           DEFAULT_PROP_EMIT_SIGNALS,
 373           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 374 
 375   /**
<span class="line-modified"> 376    * GstAppSrc::min-percent:</span>
 377    *
 378    * Make appsrc emit the &quot;need-data&quot; signal when the amount of bytes in the
 379    * queue drops below this percentage of max-bytes.
 380    */
 381   g_object_class_install_property (gobject_class, PROP_MIN_PERCENT,
 382       g_param_spec_uint (&quot;min-percent&quot;, &quot;Min Percent&quot;,
 383           &quot;Emit need-data when queued bytes drops below this percent of max-bytes&quot;,
 384           0, 100, DEFAULT_PROP_MIN_PERCENT,
 385           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 386 
 387   /**
 388    * GstAppSrc::current-level-bytes:
 389    *
 390    * The number of currently queued bytes inside appsrc.
 391    *
 392    * Since: 1.2
 393    */
 394   g_object_class_install_property (gobject_class, PROP_CURRENT_LEVEL_BYTES,
 395       g_param_spec_uint64 (&quot;current-level-bytes&quot;, &quot;Current Level Bytes&quot;,
 396           &quot;The number of currently queued bytes&quot;,
</pre>
<hr />
<pre>
 546 
 547   element_class-&gt;send_event = gst_app_src_send_event;
 548 
 549   basesrc_class-&gt;negotiate = gst_app_src_negotiate;
 550   basesrc_class-&gt;get_caps = gst_app_src_internal_get_caps;
 551   basesrc_class-&gt;create = gst_app_src_create;
 552   basesrc_class-&gt;start = gst_app_src_start;
 553   basesrc_class-&gt;stop = gst_app_src_stop;
 554   basesrc_class-&gt;unlock = gst_app_src_unlock;
 555   basesrc_class-&gt;unlock_stop = gst_app_src_unlock_stop;
 556   basesrc_class-&gt;do_seek = gst_app_src_do_seek;
 557   basesrc_class-&gt;is_seekable = gst_app_src_is_seekable;
 558   basesrc_class-&gt;get_size = gst_app_src_do_get_size;
 559   basesrc_class-&gt;query = gst_app_src_query;
 560   basesrc_class-&gt;event = gst_app_src_event;
 561 
 562   klass-&gt;push_buffer = gst_app_src_push_buffer_action;
 563   klass-&gt;push_buffer_list = gst_app_src_push_buffer_list_action;
 564   klass-&gt;push_sample = gst_app_src_push_sample_action;
 565   klass-&gt;end_of_stream = gst_app_src_end_of_stream;


 566 }
 567 
 568 static void
 569 gst_app_src_init (GstAppSrc * appsrc)
 570 {
 571   GstAppSrcPrivate *priv;
 572 
<span class="line-modified"> 573   priv = appsrc-&gt;priv = gst_app_src_get_instance_private (appsrc);</span>

 574 
 575   g_mutex_init (&amp;priv-&gt;mutex);
 576   g_cond_init (&amp;priv-&gt;cond);
 577   priv-&gt;queue = gst_queue_array_new (16);
 578   priv-&gt;wait_status = NOONE_WAITING;
 579 
 580   priv-&gt;size = DEFAULT_PROP_SIZE;
 581   priv-&gt;duration = DEFAULT_PROP_DURATION;
 582   priv-&gt;stream_type = DEFAULT_PROP_STREAM_TYPE;
 583   priv-&gt;max_bytes = DEFAULT_PROP_MAX_BYTES;
 584   priv-&gt;format = DEFAULT_PROP_FORMAT;
 585   priv-&gt;block = DEFAULT_PROP_BLOCK;
 586   priv-&gt;min_latency = DEFAULT_PROP_MIN_LATENCY;
 587   priv-&gt;max_latency = DEFAULT_PROP_MAX_LATENCY;
 588   priv-&gt;emit_signals = DEFAULT_PROP_EMIT_SIGNALS;
 589   priv-&gt;min_percent = DEFAULT_PROP_MIN_PERCENT;
 590 
 591   gst_base_src_set_live (GST_BASE_SRC (appsrc), DEFAULT_PROP_IS_LIVE);
 592 }
 593 
</pre>
<hr />
<pre>
1183     if (!gst_queue_array_is_empty (priv-&gt;queue)) {
1184       guint buf_size;
1185       GstMiniObject *obj = gst_queue_array_pop_head (priv-&gt;queue);
1186 
1187       if (GST_IS_CAPS (obj)) {
1188         GstCaps *next_caps = GST_CAPS (obj);
1189         gboolean caps_changed = TRUE;
1190 
1191         if (next_caps &amp;&amp; priv-&gt;current_caps)
1192           caps_changed = !gst_caps_is_equal (next_caps, priv-&gt;current_caps);
1193         else
1194           caps_changed = (next_caps != priv-&gt;current_caps);
1195 
1196         gst_caps_replace (&amp;priv-&gt;current_caps, next_caps);
1197 
1198         if (next_caps) {
1199           gst_caps_unref (next_caps);
1200         }
1201 
1202         if (caps_changed)
<span class="line-modified">1203           gst_app_src_do_negotiate (bsrc);</span>
1204 
1205         /* Lock has released so now may need
1206          *- flushing
1207          *- new caps change
1208          *- check queue has data */
1209         if (G_UNLIKELY (priv-&gt;flushing))
1210           goto flushing;
1211 
1212         /* Continue checks caps and queue */
1213         continue;
1214       }
1215 
1216       if (GST_IS_BUFFER (obj)) {
1217         *buf = GST_BUFFER (obj);
<span class="line-modified">1218         buf_size = gst_buffer_get_size (*buf);</span>
1219         GST_LOG_OBJECT (appsrc, &quot;have buffer %p of size %u&quot;, *buf, buf_size);
1220       } else {
1221         GstBufferList *buffer_list;
1222 
1223         g_assert (GST_IS_BUFFER_LIST (obj));
1224 
1225         buffer_list = GST_BUFFER_LIST (obj);
1226 
1227         buf_size = gst_buffer_list_calculate_size (buffer_list);
1228 
1229         GST_LOG_OBJECT (appsrc, &quot;have buffer list %p of size %u, %u buffers&quot;,
1230             buffer_list, buf_size, gst_buffer_list_length (buffer_list));
1231 
1232         gst_base_src_submit_buffer_list (bsrc, buffer_list);
1233         *buf = NULL;
1234       }
1235 
1236       priv-&gt;queued_bytes -= buf_size;
1237 
1238       /* only update the offset when in random_access mode */
1239       if (priv-&gt;stream_type == GST_APP_STREAM_TYPE_RANDOM_ACCESS)
1240         priv-&gt;offset += buf_size;
1241 
1242       /* signal that we removed an item */
1243       if ((priv-&gt;wait_status &amp; APP_WAITING))
<span class="line-modified">1244         g_cond_broadcast (&amp;priv-&gt;cond);</span>
1245 
<span class="line-modified">1246       /* see if we go lower than the min-percent */</span>
1247       if (priv-&gt;min_percent &amp;&amp; priv-&gt;max_bytes) {
1248         if (priv-&gt;queued_bytes * 100 / priv-&gt;max_bytes &lt;= priv-&gt;min_percent)
1249           /* ignore flushing state, we got a buffer and we will return it now.
1250            * Errors will be handled in the next round */
1251           gst_app_src_emit_need_data (appsrc, size);
1252       }
1253       ret = GST_FLOW_OK;
1254       break;
1255     } else {
1256       gst_app_src_emit_need_data (appsrc, size);
1257 
1258       /* we can be flushing now because we released the lock above */
1259       if (G_UNLIKELY (priv-&gt;flushing))
1260         goto flushing;
1261 
1262       /* if we have a buffer now, continue the loop and try to return it. In
1263        * random-access mode (where a buffer is normally pushed in the above
1264        * signal) we can still be empty because the pushed buffer got flushed or
1265        * when the application pushes the requested buffer later, we support both
1266        * possibilities. */
</pre>
<hr />
<pre>
1322   GstAppSrcPrivate *priv;
1323   gboolean caps_changed;
1324 
1325   g_return_if_fail (GST_IS_APP_SRC (appsrc));
1326 
1327   priv = appsrc-&gt;priv;
1328 
1329   g_mutex_lock (&amp;priv-&gt;mutex);
1330 
1331   GST_OBJECT_LOCK (appsrc);
1332   if (caps &amp;&amp; priv-&gt;last_caps)
1333     caps_changed = !gst_caps_is_equal (caps, priv-&gt;last_caps);
1334   else
1335     caps_changed = (caps != priv-&gt;last_caps);
1336 
1337   if (caps_changed) {
1338     GstCaps *new_caps;
1339     gpointer t;
1340 
1341     new_caps = caps ? gst_caps_copy (caps) : NULL;
<span class="line-modified">1342     GST_DEBUG_OBJECT (appsrc, &quot;setting caps to %&quot; GST_PTR_FORMAT, caps);</span>
1343 
1344     while ((t = gst_queue_array_peek_tail (priv-&gt;queue)) &amp;&amp; GST_IS_CAPS (t)) {
1345       gst_caps_unref (gst_queue_array_pop_tail (priv-&gt;queue));
<span class="line-modified">1346     }</span>
1347     gst_queue_array_push_tail (priv-&gt;queue, new_caps);
1348     gst_caps_replace (&amp;priv-&gt;last_caps, new_caps);
1349   }
1350 
1351   GST_OBJECT_UNLOCK (appsrc);
1352 
1353   g_mutex_unlock (&amp;priv-&gt;mutex);
1354 }
1355 
1356 /**
1357  * gst_app_src_get_caps:
1358  * @appsrc: a #GstAppSrc
1359  *
1360  * Get the configured caps on @appsrc.
1361  *
1362  * Returns: the #GstCaps produced by the source. gst_caps_unref() after usage.
1363  */
1364 GstCaps *
1365 gst_app_src_get_caps (GstAppSrc * appsrc)
1366 {
</pre>
<hr />
<pre>
1841         priv-&gt;wait_status |= APP_WAITING;
1842         g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);
1843         priv-&gt;wait_status &amp;= ~APP_WAITING;
1844       } else {
1845         /* no need to wait for free space, we just pump more data into the
1846          * queue hoping that the caller reacts to the enough-data signal and
1847          * stops pushing buffers. */
1848         break;
1849       }
1850     } else
1851       break;
1852   }
1853 
1854   if (buflist != NULL) {
1855     GST_DEBUG_OBJECT (appsrc, &quot;queueing buffer list %p&quot;, buflist);
1856     if (!steal_ref)
1857       gst_buffer_list_ref (buflist);
1858     gst_queue_array_push_tail (priv-&gt;queue, buflist);
1859     priv-&gt;queued_bytes += gst_buffer_list_calculate_size (buflist);
1860   } else {
<span class="line-modified">1861     GST_DEBUG_OBJECT (appsrc, &quot;queueing buffer %p&quot;, buffer);</span>
<span class="line-modified">1862     if (!steal_ref)</span>
<span class="line-modified">1863       gst_buffer_ref (buffer);</span>
1864     gst_queue_array_push_tail (priv-&gt;queue, buffer);
<span class="line-modified">1865     priv-&gt;queued_bytes += gst_buffer_get_size (buffer);</span>
1866   }
1867 
1868   if ((priv-&gt;wait_status &amp; STREAM_WAITING))
<span class="line-modified">1869     g_cond_broadcast (&amp;priv-&gt;cond);</span>
1870 
1871   g_mutex_unlock (&amp;priv-&gt;mutex);
1872 
1873   return GST_FLOW_OK;
1874 
1875   /* ERRORS */
1876 flushing:
1877   {
1878     GST_DEBUG_OBJECT (appsrc, &quot;refuse buffer %p, we are flushing&quot;, buffer);
1879     if (steal_ref)
1880       gst_buffer_unref (buffer);
1881     g_mutex_unlock (&amp;priv-&gt;mutex);
1882     return GST_FLOW_FLUSHING;
1883   }
1884 eos:
1885   {
1886     GST_DEBUG_OBJECT (appsrc, &quot;refuse buffer %p, we are EOS&quot;, buffer);
1887     if (steal_ref)
1888       gst_buffer_unref (buffer);
1889     g_mutex_unlock (&amp;priv-&gt;mutex);
</pre>
<hr />
<pre>
1965  *
1966  * Since: 1.14
1967  */
1968 GstFlowReturn
1969 gst_app_src_push_buffer_list (GstAppSrc * appsrc, GstBufferList * buffer_list)
1970 {
1971   return gst_app_src_push_internal (appsrc, NULL, buffer_list, TRUE);
1972 }
1973 
1974 /**
1975  * gst_app_src_push_sample:
1976  * @appsrc: a #GstAppSrc
1977  * @sample: (transfer none): a #GstSample from which buffer and caps may be
1978  * extracted
1979  *
1980  * Extract a buffer from the provided sample and adds it to the queue of
1981  * buffers that the appsrc element will push to its source pad. Any
1982  * previous caps that were set on appsrc will be replaced by the caps
1983  * associated with the sample if not equal.
1984  *
<span class="line-added">1985  * This function does not take ownership of the</span>
<span class="line-added">1986  * sample so the sample needs to be unreffed after calling this function.</span>
<span class="line-added">1987  *</span>
1988  * When the block property is TRUE, this function can block until free
1989  * space becomes available in the queue.
1990  *
1991  * Returns: #GST_FLOW_OK when the buffer was successfuly queued.
1992  * #GST_FLOW_FLUSHING when @appsrc is not PAUSED or PLAYING.
1993  * #GST_FLOW_EOS when EOS occured.
1994  *
1995  * Since: 1.6
1996  *
1997  */
1998 GstFlowReturn
1999 gst_app_src_push_sample (GstAppSrc * appsrc, GstSample * sample)
2000 {
2001   return gst_app_src_push_sample_internal (appsrc, sample);
2002 }
2003 
2004 /* push a buffer without stealing the ref of the buffer. This is used for the
2005  * action signal. */
2006 static GstFlowReturn
2007 gst_app_src_push_buffer_action (GstAppSrc * appsrc, GstBuffer * buffer)
</pre>
</td>
</tr>
</table>
<center><a href="gstappsink.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../audio/audio-channel-mixer.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>