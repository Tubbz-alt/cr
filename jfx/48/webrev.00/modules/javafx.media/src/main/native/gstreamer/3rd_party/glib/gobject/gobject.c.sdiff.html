<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gobject.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gobject-autocleanups.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gobject.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gobject.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  36 /**
  37  * SECTION:objects
  38  * @title: GObject
  39  * @short_description: The base object type
  40  * @see_also: #GParamSpecObject, g_param_spec_object()
  41  *
  42  * GObject is the fundamental type providing the common attributes and
  43  * methods for all object types in GTK+, Pango and other libraries
  44  * based on GObject.  The GObject class provides methods for object
  45  * construction and destruction, property access methods, and signal
  46  * support.  Signals are described in detail [here][gobject-Signals].
  47  *
  48  * For a tutorial on implementing a new GObject class, see [How to define and
  49  * implement a new GObject][howto-gobject]. For a list of naming conventions for
  50  * GObjects and their methods, see the [GType conventions][gtype-conventions].
  51  * For the high-level concepts behind GObject, read [Instantiable classed types:
  52  * Objects][gtype-instantiable-classed].
  53  *
  54  * ## Floating references # {#floating-ref}
  55  *







  56  * GInitiallyUnowned is derived from GObject. The only difference between
  57  * the two is that the initial reference of a GInitiallyUnowned is flagged
  58  * as a &quot;floating&quot; reference. This means that it is not specifically
  59  * claimed to be &quot;owned&quot; by any code portion. The main motivation for
  60  * providing floating references is C convenience. In particular, it
  61  * allows code to be written as:
  62  * |[&lt;!-- language=&quot;C&quot; --&gt;
  63  * container = create_container ();
  64  * container_add_child (container, create_child());
  65  * ]|
  66  * If container_add_child() calls g_object_ref_sink() on the passed-in child,
  67  * no reference of the newly created child is leaked. Without floating
  68  * references, container_add_child() can only g_object_ref() the new child,
  69  * so to implement this code without reference leaks, it would have to be
  70  * written as:
  71  * |[&lt;!-- language=&quot;C&quot; --&gt;
  72  * Child *child;
  73  * container = create_container ();
  74  * child = create_child ();
  75  * container_add_child (container, child);
  76  * g_object_unref (child);
  77  * ]|
  78  * The floating reference can be converted into an ordinary reference by
  79  * calling g_object_ref_sink(). For already sunken objects (objects that
  80  * don&#39;t have a floating reference anymore), g_object_ref_sink() is equivalent
  81  * to g_object_ref() and returns a new reference.
  82  *
  83  * Since floating references are useful almost exclusively for C convenience,
  84  * language bindings that provide automated reference and memory ownership
  85  * maintenance (such as smart pointers or garbage collection) should not
<span class="line-modified">  86  * expose floating references in their API.</span>
















  87  *
  88  * Some object implementations may need to save an objects floating state
  89  * across certain code portions (an example is #GtkMenu), to achieve this,
  90  * the following sequence can be used:
  91  *
  92  * |[&lt;!-- language=&quot;C&quot; --&gt;
  93  * // save floating state
  94  * gboolean was_floating = g_object_is_floating (object);
  95  * g_object_ref_sink (object);
  96  * // protected code portion
  97  *
  98  * ...
  99  *
 100  * // restore floating state
 101  * if (was_floating)
 102  *   g_object_force_floating (object);
 103  * else
 104  *   g_object_unref (object); // release previously acquired reference
 105  * ]|
 106  */
 107 
 108 
 109 /* --- macros --- */
<span class="line-modified"> 110 #define PARAM_SPEC_PARAM_ID(pspec)      ((pspec)-&gt;param_id)</span>
 111 #define PARAM_SPEC_SET_PARAM_ID(pspec, id)  ((pspec)-&gt;param_id = (id))
 112 
 113 #define OBJECT_HAS_TOGGLE_REF_FLAG 0x1
 114 #define OBJECT_HAS_TOGGLE_REF(object) \
 115     ((g_datalist_get_flags (&amp;(object)-&gt;qdata) &amp; OBJECT_HAS_TOGGLE_REF_FLAG) != 0)
 116 #define OBJECT_FLOATING_FLAG 0x2
 117 
 118 #define CLASS_HAS_PROPS_FLAG 0x1
 119 #define CLASS_HAS_PROPS(class) \
 120     ((class)-&gt;flags &amp; CLASS_HAS_PROPS_FLAG)
 121 #define CLASS_HAS_CUSTOM_CONSTRUCTOR(class) \
 122     ((class)-&gt;constructor != g_object_constructor)
 123 #define CLASS_HAS_CUSTOM_CONSTRUCTED(class) \
 124     ((class)-&gt;constructed != g_object_constructed)
 125 
 126 #define CLASS_HAS_DERIVED_CLASS_FLAG 0x2
 127 #define CLASS_HAS_DERIVED_CLASS(class) \
 128     ((class)-&gt;flags &amp; CLASS_HAS_DERIVED_CLASS_FLAG)
 129 
 130 /* --- signals --- */
 131 enum {
 132   NOTIFY,
 133   LAST_SIGNAL
 134 };
 135 
 136 
 137 /* --- properties --- */
 138 enum {
 139   PROP_NONE
 140 };
 141 
 142 
 143 /* --- prototypes --- */
<span class="line-modified"> 144 static void g_object_base_class_init        (GObjectClass   *class);</span>
<span class="line-modified"> 145 static void g_object_base_class_finalize        (GObjectClass   *class);</span>
<span class="line-modified"> 146 static void g_object_do_class_init          (GObjectClass   *class);</span>
<span class="line-modified"> 147 static void g_object_init               (GObject    *object,</span>
<span class="line-modified"> 148                              GObjectClass   *class);</span>
<span class="line-modified"> 149 static GObject* g_object_constructor            (GType                  type,</span>
<span class="line-modified"> 150                              guint                  n_construct_properties,</span>
<span class="line-modified"> 151                              GObjectConstructParam *construct_params);</span>
 152 static void     g_object_constructed                    (GObject        *object);
<span class="line-modified"> 153 static void g_object_real_dispose           (GObject    *object);</span>
<span class="line-modified"> 154 static void g_object_finalize           (GObject    *object);</span>
<span class="line-modified"> 155 static void g_object_do_set_property        (GObject        *object,</span>
<span class="line-modified"> 156                              guint           property_id,</span>
<span class="line-modified"> 157                              const GValue   *value,</span>
<span class="line-modified"> 158                              GParamSpec     *pspec);</span>
<span class="line-modified"> 159 static void g_object_do_get_property        (GObject        *object,</span>
<span class="line-modified"> 160                              guint           property_id,</span>
<span class="line-modified"> 161                              GValue         *value,</span>
<span class="line-modified"> 162                              GParamSpec     *pspec);</span>
<span class="line-modified"> 163 static void g_value_object_init         (GValue     *value);</span>
<span class="line-modified"> 164 static void g_value_object_free_value       (GValue     *value);</span>
<span class="line-modified"> 165 static void g_value_object_copy_value       (const GValue   *src_value,</span>
<span class="line-modified"> 166                              GValue     *dest_value);</span>
<span class="line-modified"> 167 static void g_value_object_transform_value      (const GValue   *src_value,</span>
<span class="line-modified"> 168                              GValue     *dest_value);</span>
 169 static gpointer g_value_object_peek_pointer             (const GValue   *value);
<span class="line-modified"> 170 static gchar*   g_value_object_collect_value        (GValue     *value,</span>
<span class="line-modified"> 171                              guint           n_collect_values,</span>
<span class="line-modified"> 172                              GTypeCValue    *collect_values,</span>
<span class="line-modified"> 173                              guint           collect_flags);</span>
<span class="line-modified"> 174 static gchar*   g_value_object_lcopy_value      (const GValue   *value,</span>
<span class="line-modified"> 175                              guint           n_collect_values,</span>
<span class="line-modified"> 176                              GTypeCValue    *collect_values,</span>
<span class="line-modified"> 177                              guint           collect_flags);</span>
<span class="line-modified"> 178 static void g_object_dispatch_properties_changed    (GObject    *object,</span>
<span class="line-modified"> 179                              guint       n_pspecs,</span>
<span class="line-modified"> 180                              GParamSpec    **pspecs);</span>
 181 static guint               object_floating_flag_handler (GObject        *object,
 182                                                          gint            job);
 183 
 184 static void object_interface_check_properties           (gpointer        check_data,
<span class="line-modified"> 185                              gpointer        g_iface);</span>
 186 
 187 /* --- typedefs --- */
 188 typedef struct _GObjectNotifyQueue            GObjectNotifyQueue;
 189 
 190 struct _GObjectNotifyQueue
 191 {
 192   GSList  *pspecs;
 193   guint16  n_pspecs;
 194   guint16  freeze_count;
 195 };
 196 
 197 /* --- variables --- */
 198 G_LOCK_DEFINE_STATIC (closure_array_mutex);
 199 G_LOCK_DEFINE_STATIC (weak_refs_mutex);
 200 G_LOCK_DEFINE_STATIC (toggle_refs_mutex);
<span class="line-modified"> 201 static GQuark               quark_closure_array = 0;</span>
<span class="line-modified"> 202 static GQuark               quark_weak_refs = 0;</span>
<span class="line-modified"> 203 static GQuark               quark_toggle_refs = 0;</span>
 204 static GQuark               quark_notify_queue;
 205 static GQuark               quark_in_construction;
 206 static GParamSpecPool      *pspec_pool = NULL;
<span class="line-modified"> 207 static gulong               gobject_signals[LAST_SIGNAL] = { 0, };</span>
 208 static guint (*floating_flag_handler) (GObject*, gint) = object_floating_flag_handler;
 209 /* qdata pointing to GSList&lt;GWeakRef *&gt;, protected by weak_locations_lock */
<span class="line-modified"> 210 static GQuark               quark_weak_locations = 0;</span>
 211 static GRWLock              weak_locations_lock;
 212 
 213 G_LOCK_DEFINE_STATIC(notify_lock);
 214 
 215 /* --- functions --- */
 216 static void
 217 g_object_notify_queue_free (gpointer data)
 218 {
 219   GObjectNotifyQueue *nqueue = data;
 220 
 221   g_slist_free (nqueue-&gt;pspecs);
 222   g_slice_free (GObjectNotifyQueue, nqueue);
 223 }
 224 
 225 static GObjectNotifyQueue*
 226 g_object_notify_queue_freeze (GObject  *object,
 227                               gboolean  conditional)
 228 {
 229   GObjectNotifyQueue *nqueue;
 230 
</pre>
<hr />
<pre>
 246   if (nqueue-&gt;freeze_count &gt;= 65535)
 247     g_critical(&quot;Free queue for %s (%p) is larger than 65535,&quot;
 248                &quot; called g_object_freeze_notify() too often.&quot;
 249                &quot; Forgot to call g_object_thaw_notify() or infinite loop&quot;,
 250                G_OBJECT_TYPE_NAME (object), object);
 251   else
 252     nqueue-&gt;freeze_count++;
 253   G_UNLOCK(notify_lock);
 254 
 255   return nqueue;
 256 }
 257 
 258 static void
 259 g_object_notify_queue_thaw (GObject            *object,
 260                             GObjectNotifyQueue *nqueue)
 261 {
 262   GParamSpec *pspecs_mem[16], **pspecs, **free_me = NULL;
 263   GSList *slist;
 264   guint n_pspecs = 0;
 265 
<span class="line-removed"> 266   g_return_if_fail (nqueue-&gt;freeze_count &gt; 0);</span>
 267   g_return_if_fail (g_atomic_int_get(&amp;object-&gt;ref_count) &gt; 0);
 268 
 269   G_LOCK(notify_lock);
 270 
 271   /* Just make sure we never get into some nasty race condition */
 272   if (G_UNLIKELY(nqueue-&gt;freeze_count == 0)) {
 273     G_UNLOCK(notify_lock);
 274     g_warning (&quot;%s: property-changed notification for %s(%p) is not frozen&quot;,
 275                G_STRFUNC, G_OBJECT_TYPE_NAME (object), object);
 276     return;
 277   }
 278 
 279   nqueue-&gt;freeze_count--;
 280   if (nqueue-&gt;freeze_count) {
 281     G_UNLOCK(notify_lock);
 282     return;
 283   }
 284 
 285   pspecs = nqueue-&gt;n_pspecs &gt; 16 ? free_me = g_new (GParamSpec*, nqueue-&gt;n_pspecs) : pspecs_mem;
 286 
</pre>
<hr />
<pre>
 300 static void
 301 g_object_notify_queue_add (GObject            *object,
 302                            GObjectNotifyQueue *nqueue,
 303                            GParamSpec         *pspec)
 304 {
 305   G_LOCK(notify_lock);
 306 
 307   g_assert (nqueue-&gt;n_pspecs &lt; 65535);
 308 
 309   if (g_slist_find (nqueue-&gt;pspecs, pspec) == NULL)
 310     {
 311       nqueue-&gt;pspecs = g_slist_prepend (nqueue-&gt;pspecs, pspec);
 312       nqueue-&gt;n_pspecs++;
 313     }
 314 
 315   G_UNLOCK(notify_lock);
 316 }
 317 
 318 #ifdef  G_ENABLE_DEBUG
 319 G_LOCK_DEFINE_STATIC     (debug_objects);
<span class="line-modified"> 320 static guint         debug_objects_count = 0;</span>
<span class="line-modified"> 321 static GHashTable   *debug_objects_ht = NULL;</span>
 322 
 323 static void
 324 debug_objects_foreach (gpointer key,
<span class="line-modified"> 325                gpointer value,</span>
<span class="line-modified"> 326                gpointer user_data)</span>
 327 {
 328   GObject *object = value;
 329 
 330   g_message (&quot;[%p] stale %s\tref_count=%u&quot;,
<span class="line-modified"> 331          object,</span>
<span class="line-modified"> 332          G_OBJECT_TYPE_NAME (object),</span>
<span class="line-modified"> 333          object-&gt;ref_count);</span>
 334 }
 335 
 336 #ifdef G_HAS_CONSTRUCTORS
 337 #ifdef G_DEFINE_DESTRUCTOR_NEEDS_PRAGMA
 338 #pragma G_DEFINE_DESTRUCTOR_PRAGMA_ARGS(debug_objects_atexit)
 339 #endif
 340 G_DEFINE_DESTRUCTOR(debug_objects_atexit)
 341 #endif /* G_HAS_CONSTRUCTORS */
 342 
 343 static void
 344 debug_objects_atexit (void)
 345 {
 346   GOBJECT_IF_DEBUG (OBJECTS,
 347     {
 348       G_LOCK (debug_objects);
 349       g_message (&quot;stale GObjects: %u&quot;, debug_objects_count);
 350       g_hash_table_foreach (debug_objects_ht, debug_objects_foreach, NULL);
 351       G_UNLOCK (debug_objects);
 352     });
 353 }
 354 #endif  /* G_ENABLE_DEBUG */
 355 
 356 void
 357 _g_object_type_init (void)
 358 {
 359   static gboolean initialized = FALSE;
 360   static const GTypeFundamentalInfo finfo = {
 361     G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE,
 362   };
 363   GTypeInfo info = {
 364     sizeof (GObjectClass),
 365     (GBaseInitFunc) g_object_base_class_init,
 366     (GBaseFinalizeFunc) g_object_base_class_finalize,
 367     (GClassInitFunc) g_object_do_class_init,
<span class="line-modified"> 368     NULL    /* class_destroy */,</span>
<span class="line-modified"> 369     NULL    /* class_data */,</span>
 370     sizeof (GObject),
<span class="line-modified"> 371     0       /* n_preallocs */,</span>
 372     (GInstanceInitFunc) g_object_init,
<span class="line-modified"> 373     NULL,   /* value_table */</span>
 374   };
 375   static const GTypeValueTable value_table = {
<span class="line-modified"> 376     g_value_object_init,      /* value_init */</span>
 377     g_value_object_free_value,    /* value_free */
 378     g_value_object_copy_value,    /* value_copy */
 379     g_value_object_peek_pointer,  /* value_peek_pointer */
<span class="line-modified"> 380     &quot;p&quot;,              /* collect_format */</span>
 381     g_value_object_collect_value, /* collect_value */
<span class="line-modified"> 382     &quot;p&quot;,              /* lcopy_format */</span>
 383     g_value_object_lcopy_value,   /* lcopy_value */
 384   };
<span class="line-modified"> 385   GType type;</span>
 386 
 387   g_return_if_fail (initialized == FALSE);
 388   initialized = TRUE;
 389 
 390   /* G_TYPE_OBJECT
 391    */
 392   info.value_table = &amp;value_table;
 393   type = g_type_register_fundamental (G_TYPE_OBJECT, g_intern_static_string (&quot;GObject&quot;), &amp;info, &amp;finfo, 0);
 394   g_assert (type == G_TYPE_OBJECT);
 395   g_value_register_transform_func (G_TYPE_OBJECT, G_TYPE_OBJECT, g_value_object_transform_value);
 396 
 397 #if G_ENABLE_DEBUG
 398   /* We cannot use GOBJECT_IF_DEBUG here because of the G_HAS_CONSTRUCTORS
 399    * conditional in between, as the C spec leaves conditionals inside macro
 400    * expansions as undefined behavior. Only GCC and Clang are known to work
 401    * but compilation breaks on MSVC.
 402    *
 403    * See: https://bugzilla.gnome.org/show_bug.cgi?id=769504
 404    */
 405   if (_g_type_debug_flags &amp; G_TYPE_DEBUG_OBJECTS) \
</pre>
<hr />
<pre>
 486    * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
 487    * in ::notify being emitted, even if the new value is the same as the old.
 488    * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
 489    * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
 490    * and common practice is to do that only when the value has actually changed.
 491    *
 492    * This signal is typically used to obtain change notification for a
 493    * single property, by specifying the property name as a detail in the
 494    * g_signal_connect() call, like this:
 495    * |[&lt;!-- language=&quot;C&quot; --&gt;
 496    * g_signal_connect (text_view-&gt;buffer, &quot;notify::paste-target-list&quot;,
 497    *                   G_CALLBACK (gtk_text_view_target_list_notify),
 498    *                   text_view)
 499    * ]|
 500    * It is important to note that you must use
 501    * [canonical parameter names][canonical-parameter-names] as
 502    * detail strings for the notify signal.
 503    */
 504   gobject_signals[NOTIFY] =
 505     g_signal_new (g_intern_static_string (&quot;notify&quot;),
<span class="line-modified"> 506           G_TYPE_FROM_CLASS (class),</span>
<span class="line-modified"> 507           G_SIGNAL_RUN_FIRST | G_SIGNAL_NO_RECURSE | G_SIGNAL_DETAILED | G_SIGNAL_NO_HOOKS | G_SIGNAL_ACTION,</span>
<span class="line-modified"> 508           G_STRUCT_OFFSET (GObjectClass, notify),</span>
<span class="line-modified"> 509           NULL, NULL,</span>
<span class="line-modified"> 510           g_cclosure_marshal_VOID__PARAM,</span>
<span class="line-modified"> 511           G_TYPE_NONE,</span>
<span class="line-modified"> 512           1, G_TYPE_PARAM);</span>
 513 
 514   /* Install a check function that we&#39;ll use to verify that classes that
 515    * implement an interface implement all properties for that interface
 516    */
 517   g_type_add_interface_check (NULL, object_interface_check_properties);
 518 }
 519 
 520 static inline gboolean
 521 install_property_internal (GType       g_type,
<span class="line-modified"> 522                guint       property_id,</span>
<span class="line-modified"> 523                GParamSpec *pspec)</span>
 524 {
 525   if (g_param_spec_pool_lookup (pspec_pool, pspec-&gt;name, g_type, FALSE))
 526     {
 527       g_warning (&quot;When installing property: type &#39;%s&#39; already has a property named &#39;%s&#39;&quot;,
<span class="line-modified"> 528          g_type_name (g_type),</span>
<span class="line-modified"> 529          pspec-&gt;name);</span>
 530       return FALSE;
 531     }
 532 
 533   g_param_spec_ref_sink (pspec);
 534   PARAM_SPEC_SET_PARAM_ID (pspec, property_id);
 535   g_param_spec_pool_insert (pspec_pool, pspec, g_type);
 536   return TRUE;
 537 }
 538 
 539 static gboolean
 540 validate_pspec_to_install (GParamSpec *pspec)
 541 {
 542   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), FALSE);
<span class="line-modified"> 543   g_return_val_if_fail (PARAM_SPEC_PARAM_ID (pspec) == 0, FALSE);   /* paranoid */</span>
 544 
 545   g_return_val_if_fail (pspec-&gt;flags &amp; (G_PARAM_READABLE | G_PARAM_WRITABLE), FALSE);
 546 
 547   if (pspec-&gt;flags &amp; G_PARAM_CONSTRUCT)
 548     g_return_val_if_fail ((pspec-&gt;flags &amp; G_PARAM_CONSTRUCT_ONLY) == 0, FALSE);
 549 
 550   if (pspec-&gt;flags &amp; (G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY))
 551     g_return_val_if_fail (pspec-&gt;flags &amp; G_PARAM_WRITABLE, FALSE);
 552 
 553   return TRUE;
 554 }
 555 
 556 static gboolean
 557 validate_and_install_class_property (GObjectClass *class,
 558                                      GType         oclass_type,
 559                                      GType         parent_type,
 560                                      guint         property_id,
 561                                      GParamSpec   *pspec)
 562 {
 563   if (!validate_pspec_to_install (pspec))
</pre>
<hr />
<pre>
 589 
 590 /**
 591  * g_object_class_install_property:
 592  * @oclass: a #GObjectClass
 593  * @property_id: the id for the new property
 594  * @pspec: the #GParamSpec for the new property
 595  *
 596  * Installs a new property.
 597  *
 598  * All properties should be installed during the class initializer.  It
 599  * is possible to install properties after that, but doing so is not
 600  * recommend, and specifically, is not guaranteed to be thread-safe vs.
 601  * use of properties on the same type on other threads.
 602  *
 603  * Note that it is possible to redefine a property in a derived class,
 604  * by installing a property with the same name. This can be useful at times,
 605  * e.g. to change the range of allowed values or the default value.
 606  */
 607 void
 608 g_object_class_install_property (GObjectClass *class,
<span class="line-modified"> 609                  guint         property_id,</span>
<span class="line-modified"> 610                                  GParamSpec   *pspec)</span>
 611 {
 612   GType oclass_type, parent_type;
 613 
 614   g_return_if_fail (G_IS_OBJECT_CLASS (class));
 615   g_return_if_fail (property_id &gt; 0);
 616 
 617   oclass_type = G_OBJECT_CLASS_TYPE (class);
 618   parent_type = g_type_parent (oclass_type);
 619 
 620   if (CLASS_HAS_DERIVED_CLASS (class))
 621     g_error (&quot;Attempt to add property %s::%s to class after it was derived&quot;, G_OBJECT_CLASS_NAME (class), pspec-&gt;name);
 622 
 623   (void) validate_and_install_class_property (class,
 624                                               oclass_type,
 625                                               parent_type,
 626                                               property_id,
 627                                               pspec);
 628 }
 629 
 630 /**
</pre>
<hr />
<pre>
 744  * that are added to GObject-derived types. Adding a property to an
 745  * interface forces all objects classes with that interface to have a
 746  * compatible property. The compatible property could be a newly
 747  * created #GParamSpec, but normally
 748  * g_object_class_override_property() will be used so that the object
 749  * class only needs to provide an implementation and inherits the
 750  * property description, default value, bounds, and so forth from the
 751  * interface property.
 752  *
 753  * This function is meant to be called from the interface&#39;s default
 754  * vtable initialization function (the @class_init member of
 755  * #GTypeInfo.) It must not be called after after @class_init has
 756  * been called for any object types implementing this interface.
 757  *
 758  * If @pspec is a floating reference, it will be consumed.
 759  *
 760  * Since: 2.4
 761  */
 762 void
 763 g_object_interface_install_property (gpointer      g_iface,
<span class="line-modified"> 764                      GParamSpec   *pspec)</span>
 765 {
 766   GTypeInterface *iface_class = g_iface;
 767 
 768   g_return_if_fail (G_TYPE_IS_INTERFACE (iface_class-&gt;g_type));
 769   g_return_if_fail (!G_IS_PARAM_SPEC_OVERRIDE (pspec)); /* paranoid */
 770 
 771   if (!validate_pspec_to_install (pspec))
 772     return;
 773 
 774   (void) install_property_internal (iface_class-&gt;g_type, 0, pspec);
 775 }
 776 
 777 /**
 778  * g_object_class_find_property:
 779  * @oclass: a #GObjectClass
 780  * @property_name: the name of the property to look up
 781  *
 782  * Looks up the #GParamSpec for a property of a class.
 783  *
 784  * Returns: (transfer none): the #GParamSpec for the property, or
 785  *          %NULL if the class doesn&#39;t have a property of that name
 786  */
 787 GParamSpec*
 788 g_object_class_find_property (GObjectClass *class,
<span class="line-modified"> 789                   const gchar  *property_name)</span>
 790 {
 791   GParamSpec *pspec;
 792   GParamSpec *redirect;
 793 
 794   g_return_val_if_fail (G_IS_OBJECT_CLASS (class), NULL);
 795   g_return_val_if_fail (property_name != NULL, NULL);
 796 
 797   pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified"> 798                     property_name,</span>
<span class="line-modified"> 799                     G_OBJECT_CLASS_TYPE (class),</span>
<span class="line-modified"> 800                     TRUE);</span>
 801   if (pspec)
 802     {
 803       redirect = g_param_spec_get_redirect_target (pspec);
 804       if (redirect)
<span class="line-modified"> 805     return redirect;</span>
 806       else
<span class="line-modified"> 807     return pspec;</span>
 808     }
 809   else
 810     return NULL;
 811 }
 812 
 813 /**
 814  * g_object_interface_find_property:
 815  * @g_iface: (type GObject.TypeInterface): any interface vtable for the
 816  *  interface, or the default vtable for the interface
<span class="line-modified"> 817  * @property_name: name of a property to lookup.</span>
 818  *
 819  * Find the #GParamSpec with the given name for an
 820  * interface. Generally, the interface vtable passed in as @g_iface
 821  * will be the default vtable from g_type_default_interface_ref(), or,
 822  * if you know the interface has already been loaded,
 823  * g_type_default_interface_peek().
 824  *
 825  * Since: 2.4
 826  *
 827  * Returns: (transfer none): the #GParamSpec for the property of the
 828  *          interface with the name @property_name, or %NULL if no
 829  *          such property exists.
 830  */
 831 GParamSpec*
 832 g_object_interface_find_property (gpointer      g_iface,
<span class="line-modified"> 833                   const gchar  *property_name)</span>
 834 {
 835   GTypeInterface *iface_class = g_iface;
 836 
 837   g_return_val_if_fail (G_TYPE_IS_INTERFACE (iface_class-&gt;g_type), NULL);
 838   g_return_val_if_fail (property_name != NULL, NULL);
 839 
 840   return g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified"> 841                    property_name,</span>
<span class="line-modified"> 842                    iface_class-&gt;g_type,</span>
<span class="line-modified"> 843                    FALSE);</span>
 844 }
 845 
 846 /**
 847  * g_object_class_override_property:
 848  * @oclass: a #GObjectClass
 849  * @property_id: the new property ID
 850  * @name: the name of a property registered in a parent class or
 851  *  in an interface of this class.
 852  *
 853  * Registers @property_id as referring to a property with the name
 854  * @name in a parent class or in an interface implemented by @oclass.
 855  * This allows this class to &quot;override&quot; a property implementation in
 856  * a parent class or to provide the implementation of a property from
 857  * an interface.
 858  *
 859  * Internally, overriding is implemented by creating a property of type
 860  * #GParamSpecOverride; generally operations that query the properties of
 861  * the object class, such as g_object_class_find_property() or
 862  * g_object_class_list_properties() will return the overridden
 863  * property. However, in one case, the @construct_properties argument of
 864  * the @constructor virtual function, the #GParamSpecOverride is passed
 865  * instead, so that the @param_id field of the #GParamSpec will be
 866  * correct.  For virtually all uses, this makes no difference. If you
 867  * need to get the overridden property, you can call
 868  * g_param_spec_get_redirect_target().
 869  *
 870  * Since: 2.4
 871  */
 872 void
 873 g_object_class_override_property (GObjectClass *oclass,
<span class="line-modified"> 874                   guint         property_id,</span>
<span class="line-modified"> 875                   const gchar  *name)</span>
 876 {
 877   GParamSpec *overridden = NULL;
 878   GParamSpec *new;
 879   GType parent_type;
 880 
 881   g_return_if_fail (G_IS_OBJECT_CLASS (oclass));
 882   g_return_if_fail (property_id &gt; 0);
 883   g_return_if_fail (name != NULL);
 884 
 885   /* Find the overridden property; first check parent types
 886    */
 887   parent_type = g_type_parent (G_OBJECT_CLASS_TYPE (oclass));
 888   if (parent_type != G_TYPE_NONE)
 889     overridden = g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified"> 890                        name,</span>
<span class="line-modified"> 891                        parent_type,</span>
<span class="line-modified"> 892                        TRUE);</span>
 893   if (!overridden)
 894     {
 895       GType *ifaces;
 896       guint n_ifaces;
 897 
 898       /* Now check interfaces
 899        */
 900       ifaces = g_type_interfaces (G_OBJECT_CLASS_TYPE (oclass), &amp;n_ifaces);
 901       while (n_ifaces-- &amp;&amp; !overridden)
<span class="line-modified"> 902     {</span>
<span class="line-modified"> 903       overridden = g_param_spec_pool_lookup (pspec_pool,</span>
<span class="line-modified"> 904                          name,</span>
<span class="line-modified"> 905                          ifaces[n_ifaces],</span>
<span class="line-modified"> 906                          FALSE);</span>
<span class="line-modified"> 907     }</span>
 908 
 909       g_free (ifaces);
 910     }
 911 
 912   if (!overridden)
 913     {
 914       g_warning (&quot;%s: Can&#39;t find property to override for &#39;%s::%s&#39;&quot;,
<span class="line-modified"> 915          G_STRFUNC, G_OBJECT_CLASS_NAME (oclass), name);</span>
 916       return;
 917     }
 918 
 919   new = g_param_spec_override (name, overridden);
 920   g_object_class_install_property (oclass, property_id, new);
 921 }
 922 
 923 /**
 924  * g_object_class_list_properties:
 925  * @oclass: a #GObjectClass
 926  * @n_properties: (out): return location for the length of the returned array
 927  *
 928  * Get an array of #GParamSpec* for all properties of a class.
 929  *
 930  * Returns: (array length=n_properties) (transfer container): an array of
 931  *          #GParamSpec* which should be freed after use
 932  */
 933 GParamSpec** /* free result */
 934 g_object_class_list_properties (GObjectClass *class,
<span class="line-modified"> 935                 guint        *n_properties_p)</span>
 936 {
 937   GParamSpec **pspecs;
 938   guint n;
 939 
 940   g_return_val_if_fail (G_IS_OBJECT_CLASS (class), NULL);
 941 
 942   pspecs = g_param_spec_pool_list (pspec_pool,
<span class="line-modified"> 943                    G_OBJECT_CLASS_TYPE (class),</span>
<span class="line-modified"> 944                    &amp;n);</span>
 945   if (n_properties_p)
 946     *n_properties_p = n;
 947 
 948   return pspecs;
 949 }
 950 
 951 /**
 952  * g_object_interface_list_properties:
 953  * @g_iface: (type GObject.TypeInterface): any interface vtable for the
 954  *  interface, or the default vtable for the interface
 955  * @n_properties_p: (out): location to store number of properties returned.
 956  *
 957  * Lists the properties of an interface.Generally, the interface
 958  * vtable passed in as @g_iface will be the default vtable from
 959  * g_type_default_interface_ref(), or, if you know the interface has
 960  * already been loaded, g_type_default_interface_peek().
 961  *
 962  * Since: 2.4
 963  *
 964  * Returns: (array length=n_properties_p) (transfer container): a
 965  *          pointer to an array of pointers to #GParamSpec
 966  *          structures. The paramspecs are owned by GLib, but the
 967  *          array should be freed with g_free() when you are done with
 968  *          it.
 969  */
 970 GParamSpec**
 971 g_object_interface_list_properties (gpointer      g_iface,
<span class="line-modified"> 972                     guint        *n_properties_p)</span>
 973 {
 974   GTypeInterface *iface_class = g_iface;
 975   GParamSpec **pspecs;
 976   guint n;
 977 
 978   g_return_val_if_fail (G_TYPE_IS_INTERFACE (iface_class-&gt;g_type), NULL);
 979 
 980   pspecs = g_param_spec_pool_list (pspec_pool,
<span class="line-modified"> 981                    iface_class-&gt;g_type,</span>
<span class="line-modified"> 982                    &amp;n);</span>
 983   if (n_properties_p)
 984     *n_properties_p = n;
 985 
 986   return pspecs;
 987 }
 988 
 989 static inline gboolean
 990 object_in_construction (GObject *object)
 991 {
 992   return g_datalist_id_get_data (&amp;object-&gt;qdata, quark_in_construction) != NULL;
 993 }
 994 
 995 static void
<span class="line-modified"> 996 g_object_init (GObject      *object,</span>
<span class="line-modified"> 997            GObjectClass *class)</span>
 998 {
 999   object-&gt;ref_count = 1;
1000   object-&gt;qdata = NULL;
1001 
1002   if (CLASS_HAS_PROPS (class))
1003     {
1004       /* freeze object&#39;s notification queue, g_object_newv() preserves pairedness */
1005       g_object_notify_queue_freeze (object, FALSE);
1006     }
1007 
1008   if (CLASS_HAS_CUSTOM_CONSTRUCTOR (class))
1009     {
1010       /* mark object in-construction for notify_queue_thaw() and to allow construct-only properties */
1011       g_datalist_id_set_data (&amp;object-&gt;qdata, quark_in_construction, object);
1012     }
1013 
1014   GOBJECT_IF_DEBUG (OBJECTS,
1015     {
1016       G_LOCK (debug_objects);
1017       debug_objects_count++;
1018       g_hash_table_add (debug_objects_ht, object);
1019       G_UNLOCK (debug_objects);
1020     });
1021 }
1022 
1023 static void
1024 g_object_do_set_property (GObject      *object,
<span class="line-modified">1025               guint         property_id,</span>
<span class="line-modified">1026               const GValue *value,</span>
<span class="line-modified">1027               GParamSpec   *pspec)</span>
1028 {
1029   switch (property_id)
1030     {
1031     default:
1032       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
1033       break;
1034     }
1035 }
1036 
1037 static void
1038 g_object_do_get_property (GObject     *object,
<span class="line-modified">1039               guint        property_id,</span>
<span class="line-modified">1040               GValue      *value,</span>
<span class="line-modified">1041               GParamSpec  *pspec)</span>
1042 {
1043   switch (property_id)
1044     {
1045     default:
1046       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
1047       break;
1048     }
1049 }
1050 
1051 static void
1052 g_object_real_dispose (GObject *object)
1053 {
1054   g_signal_handlers_destroy (object);
1055   g_datalist_id_set_data (&amp;object-&gt;qdata, quark_closure_array, NULL);
1056   g_datalist_id_set_data (&amp;object-&gt;qdata, quark_weak_refs, NULL);
1057 }
1058 
1059 static void
1060 g_object_finalize (GObject *object)
1061 {
1062   if (object_in_construction (object))
1063     {
1064       g_critical (&quot;object %s %p finalized while still in-construction&quot;,
1065                   G_OBJECT_TYPE_NAME (object), object);
1066     }
1067 
1068   g_datalist_clear (&amp;object-&gt;qdata);
1069 
1070   GOBJECT_IF_DEBUG (OBJECTS,
1071     {
1072       G_LOCK (debug_objects);
1073       g_assert (g_hash_table_contains (debug_objects_ht, object));
1074       g_hash_table_remove (debug_objects_ht, object);
1075       debug_objects_count--;
1076       G_UNLOCK (debug_objects);
1077     });
1078 }
1079 
1080 static void
1081 g_object_dispatch_properties_changed (GObject     *object,
<span class="line-modified">1082                       guint        n_pspecs,</span>
<span class="line-modified">1083                       GParamSpec **pspecs)</span>
1084 {
1085   guint i;
1086 
1087   for (i = 0; i &lt; n_pspecs; i++)
1088     g_signal_emit (object, gobject_signals[NOTIFY], g_param_spec_get_name_quark (pspecs[i]), pspecs[i]);
1089 }
1090 
1091 /**
1092  * g_object_run_dispose:
1093  * @object: a #GObject
1094  *
1095  * Releases all references to other objects. This can be used to break
1096  * reference cycles.
1097  *
1098  * This function should only be called from object system implementations.
1099  */
1100 void
1101 g_object_run_dispose (GObject *object)
1102 {
1103   g_return_if_fail (G_IS_OBJECT (object));
<span class="line-modified">1104   g_return_if_fail (object-&gt;ref_count &gt; 0);</span>
1105 
1106   g_object_ref (object);
1107   TRACE (GOBJECT_OBJECT_DISPOSE(object,G_TYPE_FROM_INSTANCE(object), 0));
1108   G_OBJECT_GET_CLASS (object)-&gt;dispose (object);
1109   TRACE (GOBJECT_OBJECT_DISPOSE_END(object,G_TYPE_FROM_INSTANCE(object), 0));
1110   g_object_unref (object);
1111 }
1112 
1113 /**
1114  * g_object_freeze_notify:
1115  * @object: a #GObject
1116  *
1117  * Increases the freeze count on @object. If the freeze count is
1118  * non-zero, the emission of &quot;notify&quot; signals on @object is
1119  * stopped. The signals are queued until the freeze count is decreased
1120  * to zero. Duplicate notifications are squashed so that at most one
1121  * #GObject::notify signal is emitted for each property modified while the
1122  * object is frozen.
1123  *
1124  * This is necessary for accessors that modify multiple properties to prevent
</pre>
<hr />
<pre>
1140 static GParamSpec *
1141 get_notify_pspec (GParamSpec *pspec)
1142 {
1143   GParamSpec *redirected;
1144 
1145   /* we don&#39;t notify on non-READABLE parameters */
1146   if (~pspec-&gt;flags &amp; G_PARAM_READABLE)
1147     return NULL;
1148 
1149   /* if the paramspec is redirected, notify on the target */
1150   redirected = g_param_spec_get_redirect_target (pspec);
1151   if (redirected != NULL)
1152     return redirected;
1153 
1154   /* else, notify normally */
1155   return pspec;
1156 }
1157 
1158 static inline void
1159 g_object_notify_by_spec_internal (GObject    *object,
<span class="line-modified">1160                   GParamSpec *pspec)</span>
1161 {
1162   GParamSpec *notify_pspec;
1163 
1164   notify_pspec = get_notify_pspec (pspec);
1165 
1166   if (notify_pspec != NULL)
1167     {
1168       GObjectNotifyQueue *nqueue;
1169 
1170       /* conditional freeze: only increase freeze count if already frozen */
1171       nqueue = g_object_notify_queue_freeze (object, TRUE);
1172 
1173       if (nqueue != NULL)
1174         {
1175           /* we&#39;re frozen, so add to the queue and release our freeze */
1176           g_object_notify_queue_add (object, nqueue, notify_pspec);
1177           g_object_notify_queue_thaw (object, nqueue);
1178         }
1179       else
1180         /* not frozen, so just dispatch the notification directly */
</pre>
<hr />
<pre>
1184 }
1185 
1186 /**
1187  * g_object_notify:
1188  * @object: a #GObject
1189  * @property_name: the name of a property installed on the class of @object.
1190  *
1191  * Emits a &quot;notify&quot; signal for the property @property_name on @object.
1192  *
1193  * When possible, eg. when signaling a property change from within the class
1194  * that registered the property, you should use g_object_notify_by_pspec()
1195  * instead.
1196  *
1197  * Note that emission of the notify signal may be blocked with
1198  * g_object_freeze_notify(). In this case, the signal emissions are queued
1199  * and will be emitted (in reverse order) when g_object_thaw_notify() is
1200  * called.
1201  */
1202 void
1203 g_object_notify (GObject     *object,
<span class="line-modified">1204          const gchar *property_name)</span>
1205 {
1206   GParamSpec *pspec;
1207 
1208   g_return_if_fail (G_IS_OBJECT (object));
1209   g_return_if_fail (property_name != NULL);
1210   if (g_atomic_int_get (&amp;object-&gt;ref_count) == 0)
1211     return;
1212 
1213   g_object_ref (object);
1214   /* We don&#39;t need to get the redirect target
1215    * (by, e.g. calling g_object_class_find_property())
1216    * because g_object_notify_queue_add() does that
1217    */
1218   pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified">1219                     property_name,</span>
<span class="line-modified">1220                     G_OBJECT_TYPE (object),</span>
<span class="line-modified">1221                     TRUE);</span>
1222 
1223   if (!pspec)
1224     g_warning (&quot;%s: object class &#39;%s&#39; has no property named &#39;%s&#39;&quot;,
<span class="line-modified">1225            G_STRFUNC,</span>
<span class="line-modified">1226            G_OBJECT_TYPE_NAME (object),</span>
<span class="line-modified">1227            property_name);</span>
1228   else
1229     g_object_notify_by_spec_internal (object, pspec);
1230   g_object_unref (object);
1231 }
1232 
1233 /**
1234  * g_object_notify_by_pspec:
1235  * @object: a #GObject
1236  * @pspec: the #GParamSpec of a property installed on the class of @object.
1237  *
1238  * Emits a &quot;notify&quot; signal for the property specified by @pspec on @object.
1239  *
1240  * This function omits the property name lookup, hence it is faster than
1241  * g_object_notify().
1242  *
1243  * One way to avoid using g_object_notify() from within the
1244  * class that registered the properties, and using g_object_notify_by_pspec()
1245  * instead, is to store the GParamSpec used with
1246  * g_object_class_install_property() inside a static array, e.g.:
1247  *
</pre>
<hr />
<pre>
1261  *     properties[PROP_FOO] = g_param_spec_int (&quot;foo&quot;, &quot;Foo&quot;, &quot;The foo&quot;,
1262  *                                              0, 100,
1263  *                                              50,
1264  *                                              G_PARAM_READWRITE);
1265  *     g_object_class_install_property (gobject_class,
1266  *                                      PROP_FOO,
1267  *                                      properties[PROP_FOO]);
1268  *   }
1269  * ]|
1270  *
1271  * and then notify a change on the &quot;foo&quot; property with:
1272  *
1273  * |[&lt;!-- language=&quot;C&quot; --&gt;
1274  *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
1275  * ]|
1276  *
1277  * Since: 2.26
1278  */
1279 void
1280 g_object_notify_by_pspec (GObject    *object,
<span class="line-modified">1281               GParamSpec *pspec)</span>
1282 {
1283 
1284   g_return_if_fail (G_IS_OBJECT (object));
1285   g_return_if_fail (G_IS_PARAM_SPEC (pspec));
1286 
1287   if (g_atomic_int_get (&amp;object-&gt;ref_count) == 0)
1288     return;
1289 
1290   g_object_ref (object);
1291   g_object_notify_by_spec_internal (object, pspec);
1292   g_object_unref (object);
1293 }
1294 
1295 /**
1296  * g_object_thaw_notify:
1297  * @object: a #GObject
1298  *
1299  * Reverts the effect of a previous call to
1300  * g_object_freeze_notify(). The freeze count is decreased on @object
1301  * and when it reaches zero, queued &quot;notify&quot; signals are emitted.
</pre>
<hr />
<pre>
1362    */
1363   g_mutex_lock (&amp;already_warned_lock);
1364 
1365   if (already_warned_table == NULL)
1366     already_warned_table = g_hash_table_new (NULL, NULL);
1367 
1368   already = g_hash_table_contains (already_warned_table, (gpointer) pspec-&gt;name);
1369   if (!already)
1370     g_hash_table_add (already_warned_table, (gpointer) pspec-&gt;name);
1371 
1372   g_mutex_unlock (&amp;already_warned_lock);
1373 
1374   if (!already)
1375     g_warning (&quot;The property %s:%s is deprecated and shouldn&#39;t be used &quot;
1376                &quot;anymore. It will be removed in a future version.&quot;,
1377                g_type_name (pspec-&gt;owner_type), pspec-&gt;name);
1378 }
1379 
1380 static inline void
1381 object_get_property (GObject     *object,
<span class="line-modified">1382              GParamSpec  *pspec,</span>
<span class="line-modified">1383              GValue      *value)</span>
1384 {
1385   GObjectClass *class = g_type_class_peek (pspec-&gt;owner_type);
1386   guint param_id = PARAM_SPEC_PARAM_ID (pspec);
1387   GParamSpec *redirect;
1388 
1389   if (class == NULL)
1390     {
1391       g_warning (&quot;&#39;%s::%s&#39; is not a valid property name; &#39;%s&#39; is not a GObject subtype&quot;,
1392                  g_type_name (pspec-&gt;owner_type), pspec-&gt;name, g_type_name (pspec-&gt;owner_type));
1393       return;
1394     }
1395 
1396   redirect = g_param_spec_get_redirect_target (pspec);
1397   if (redirect)
1398     pspec = redirect;
1399 
1400   consider_issuing_property_deprecation_warning (pspec);
1401 
1402   class-&gt;get_property (object, param_id, value, pspec);
1403 }
1404 
1405 static inline void
1406 object_set_property (GObject             *object,
<span class="line-modified">1407              GParamSpec          *pspec,</span>
<span class="line-modified">1408              const GValue        *value,</span>
<span class="line-modified">1409              GObjectNotifyQueue  *nqueue)</span>
1410 {
1411   GValue tmp_value = G_VALUE_INIT;
1412   GObjectClass *class = g_type_class_peek (pspec-&gt;owner_type);
1413   guint param_id = PARAM_SPEC_PARAM_ID (pspec);
1414   GParamSpec *redirect;
1415 
1416   if (class == NULL)
1417     {
1418       g_warning (&quot;&#39;%s::%s&#39; is not a valid property name; &#39;%s&#39; is not a GObject subtype&quot;,
1419                  g_type_name (pspec-&gt;owner_type), pspec-&gt;name, g_type_name (pspec-&gt;owner_type));
1420       return;
1421     }
1422 
1423   redirect = g_param_spec_get_redirect_target (pspec);
1424   if (redirect)
1425     pspec = redirect;
1426 
1427   /* provide a copy to work from, convert (if necessary) and validate */
1428   g_value_init (&amp;tmp_value, pspec-&gt;value_type);
1429   if (!g_value_transform (value, &amp;tmp_value))
1430     g_warning (&quot;unable to set property &#39;%s&#39; of type &#39;%s&#39; from value of type &#39;%s&#39;&quot;,
<span class="line-modified">1431            pspec-&gt;name,</span>
<span class="line-modified">1432            g_type_name (pspec-&gt;value_type),</span>
<span class="line-modified">1433            G_VALUE_TYPE_NAME (value));</span>
1434   else if (g_param_value_validate (pspec, &amp;tmp_value) &amp;&amp; !(pspec-&gt;flags &amp; G_PARAM_LAX_VALIDATION))
1435     {
1436       gchar *contents = g_strdup_value_contents (value);
1437 
1438       g_warning (&quot;value \&quot;%s\&quot; of type &#39;%s&#39; is invalid or out of range for property &#39;%s&#39; of type &#39;%s&#39;&quot;,
<span class="line-modified">1439          contents,</span>
<span class="line-modified">1440          G_VALUE_TYPE_NAME (value),</span>
<span class="line-modified">1441          pspec-&gt;name,</span>
<span class="line-modified">1442          g_type_name (pspec-&gt;value_type));</span>
1443       g_free (contents);
1444     }
1445   else
1446     {
1447       class-&gt;set_property (object, param_id, &amp;tmp_value, pspec);
1448 
1449       if (~pspec-&gt;flags &amp; G_PARAM_EXPLICIT_NOTIFY)
1450         {
1451           GParamSpec *notify_pspec;
1452 
1453           notify_pspec = get_notify_pspec (pspec);
1454 
1455           if (notify_pspec != NULL)
1456             g_object_notify_queue_add (object, nqueue, notify_pspec);
1457         }
1458     }
1459   g_value_unset (&amp;tmp_value);
1460 }
1461 
1462 static void
1463 object_interface_check_properties (gpointer check_data,
<span class="line-modified">1464                    gpointer g_iface)</span>
1465 {
1466   GTypeInterface *iface_class = g_iface;
1467   GObjectClass *class;
1468   GType iface_type = iface_class-&gt;g_type;
1469   GParamSpec **pspecs;
1470   guint n;
1471 
1472   class = g_type_class_ref (iface_class-&gt;g_instance_type);
1473 
1474   if (class == NULL)
1475     return;
1476 
1477   if (!G_IS_OBJECT_CLASS (class))
1478     goto out;
1479 
1480   pspecs = g_param_spec_pool_list (pspec_pool, iface_type, &amp;n);
1481 
1482   while (n--)
1483     {
1484       GParamSpec *class_pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified">1485                               pspecs[n]-&gt;name,</span>
<span class="line-modified">1486                               G_OBJECT_CLASS_TYPE (class),</span>
<span class="line-modified">1487                               TRUE);</span>
1488 
1489       if (!class_pspec)
<span class="line-modified">1490     {</span>
<span class="line-modified">1491       g_critical (&quot;Object class %s doesn&#39;t implement property &quot;</span>
<span class="line-modified">1492               &quot;&#39;%s&#39; from interface &#39;%s&#39;&quot;,</span>
<span class="line-modified">1493               g_type_name (G_OBJECT_CLASS_TYPE (class)),</span>
<span class="line-modified">1494               pspecs[n]-&gt;name,</span>
<span class="line-modified">1495               g_type_name (iface_type));</span>
<span class="line-modified">1496 </span>
<span class="line-modified">1497       continue;</span>
<span class="line-modified">1498     }</span>
1499 
1500       /* We do a number of checks on the properties of an interface to
1501        * make sure that all classes implementing the interface are
1502        * overriding the properties in a sane way.
1503        *
1504        * We do the checks in order of importance so that we can give
1505        * more useful error messages first.
1506        *
1507        * First, we check that the implementation doesn&#39;t remove the
1508        * basic functionality (readability, writability) advertised by
1509        * the interface.  Next, we check that it doesn&#39;t introduce
1510        * additional restrictions (such as construct-only).  Finally, we
1511        * make sure the types are compatible.
1512        */
1513 
1514 #define SUBSET(a,b,mask) (((a) &amp; ~(b) &amp; (mask)) == 0)
1515       /* If the property on the interface is readable then the
1516        * implementation must be readable.  If the interface is writable
1517        * then the implementation must be writable.
1518        */
</pre>
<hr />
<pre>
1617     return G_TYPE_OBJECT;
1618 }
1619 
1620 /**
1621  * g_object_new: (skip)
1622  * @object_type: the type id of the #GObject subtype to instantiate
1623  * @first_property_name: the name of the first property
1624  * @...: the value of the first property, followed optionally by more
1625  *  name/value pairs, followed by %NULL
1626  *
1627  * Creates a new instance of a #GObject subtype and sets its properties.
1628  *
1629  * Construction parameters (see #G_PARAM_CONSTRUCT, #G_PARAM_CONSTRUCT_ONLY)
1630  * which are not explicitly specified are set to their default values.
1631  *
1632  * Returns: (transfer full) (type GObject.Object): a new instance of
1633  *   @object_type
1634  */
1635 gpointer
1636 g_object_new (GType    object_type,
<span class="line-modified">1637               const gchar *first_property_name,</span>
<span class="line-modified">1638               ...)</span>
1639 {
1640   GObject *object;
1641   va_list var_args;
1642 
1643   /* short circuit for calls supplying no properties */
1644   if (!first_property_name)
1645     return g_object_new_with_properties (object_type, 0, NULL, NULL);
1646 
1647   va_start (var_args, first_property_name);
1648   object = g_object_new_valist (object_type, first_property_name, var_args);
1649   va_end (var_args);
1650 
1651   return object;
1652 }
1653 
1654 static gpointer
1655 g_object_new_with_custom_constructor (GObjectClass          *class,
1656                                       GObjectConstructParam *params,
1657                                       guint                  n_params)
1658 {
</pre>
<hr />
<pre>
1690    * default value from the class, we had better not pass that in
1691    * and risk it being modified, so we create a new one.
1692    * */
1693   for (node = class-&gt;construct_properties; node; node = node-&gt;next)
1694     {
1695       GParamSpec *pspec;
1696       GValue *value;
1697       gint j;
1698 
1699       pspec = node-&gt;data;
1700       value = NULL; /* to silence gcc... */
1701 
1702       for (j = 0; j &lt; n_params; j++)
1703         if (params[j].pspec == pspec)
1704           {
1705             consider_issuing_property_deprecation_warning (pspec);
1706             value = params[j].value;
1707             break;
1708           }
1709 
<span class="line-modified">1710       if (j == n_params)</span>
1711         {
1712           value = &amp;cvalues[cvals_used++];
1713           g_value_init (value, pspec-&gt;value_type);
1714           g_param_value_set_default (pspec, value);
1715         }
1716 
1717       cparams[i].pspec = pspec;
1718       cparams[i].value = value;
1719       i++;
1720     }
1721 
1722   /* construct object from construction parameters */
1723   object = class-&gt;constructor (class-&gt;g_type_class.g_type, n_cparams, cparams);
1724   /* free construction values */
1725   g_free (cparams);
1726   while (cvals_used--)
1727     g_value_unset (&amp;cvalues[cvals_used]);
1728   g_free (cvalues);
1729 
1730   /* There is code in the wild that relies on being able to return NULL
</pre>
<hr />
<pre>
1816        * properties, but they may come from either the class default
1817        * values or the passed-in parameter list.
1818        */
1819       for (node = class-&gt;construct_properties; node; node = node-&gt;next)
1820         {
1821           const GValue *value;
1822           GParamSpec *pspec;
1823           gint j;
1824 
1825           pspec = node-&gt;data;
1826           value = NULL; /* to silence gcc... */
1827 
1828           for (j = 0; j &lt; n_params; j++)
1829             if (params[j].pspec == pspec)
1830               {
1831                 consider_issuing_property_deprecation_warning (pspec);
1832                 value = params[j].value;
1833                 break;
1834               }
1835 
<span class="line-modified">1836           if (j == n_params)</span>
1837             value = g_param_spec_get_default_value (pspec);
1838 
1839           object_set_property (object, pspec, value, nqueue);
1840         }
1841     }
1842 
1843   /* run &#39;constructed&#39; handler if there is a custom one */
1844   if (CLASS_HAS_CUSTOM_CONSTRUCTED (class))
1845     class-&gt;constructed (object);
1846 
1847   if (nqueue)
1848     {
1849       gint i;
1850 
1851       /* Set remaining properties.  The construct properties will
1852        * already have been taken, so set only the non-construct
1853        * ones.
1854        */
1855       for (i = 0; i &lt; n_params; i++)
1856         if (!(params[i].pspec-&gt;flags &amp; (G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY)))
</pre>
<hr />
<pre>
1978   return object;
1979 }
1980 
1981 /**
1982  * g_object_newv:
1983  * @object_type: the type id of the #GObject subtype to instantiate
1984  * @n_parameters: the length of the @parameters array
1985  * @parameters: (array length=n_parameters): an array of #GParameter
1986  *
1987  * Creates a new instance of a #GObject subtype and sets its properties.
1988  *
1989  * Construction parameters (see #G_PARAM_CONSTRUCT, #G_PARAM_CONSTRUCT_ONLY)
1990  * which are not explicitly specified are set to their default values.
1991  *
1992  * Returns: (type GObject.Object) (transfer full): a new instance of
1993  * @object_type
1994  *
1995  * Deprecated: 2.54: Use g_object_new_with_properties() instead.
1996  * deprecated. See #GParameter for more information.
1997  */

1998 gpointer
1999 g_object_newv (GType       object_type,
2000                guint       n_parameters,
2001                GParameter *parameters)
2002 {
2003   GObjectClass *class, *unref_class = NULL;
2004   GObject *object;
2005 
2006   g_return_val_if_fail (G_TYPE_IS_OBJECT (object_type), NULL);
2007   g_return_val_if_fail (n_parameters == 0 || parameters != NULL, NULL);
2008 
2009   /* Try to avoid thrashing the ref_count if we don&#39;t need to (since
2010    * it&#39;s a locked operation).
2011    */
2012   class = g_type_class_peek_static (object_type);
2013 
2014   if (!class)
2015     class = unref_class = g_type_class_ref (object_type);
2016 
2017   if (n_parameters)
</pre>
<hr />
<pre>
2029           pspec = g_param_spec_pool_lookup (pspec_pool, parameters[i].name, object_type, TRUE);
2030           if (!g_object_new_is_valid_property (object_type, pspec, parameters[i].name, cparams, j))
2031             continue;
2032 
2033           cparams[j].pspec = pspec;
2034           cparams[j].value = &amp;parameters[i].value;
2035           j++;
2036         }
2037 
2038       object = g_object_new_internal (class, cparams, j);
2039     }
2040   else
2041     /* Fast case: no properties passed in. */
2042     object = g_object_new_internal (class, NULL, 0);
2043 
2044   if (unref_class)
2045     g_type_class_unref (unref_class);
2046 
2047   return object;
2048 }

2049 
2050 /**
2051  * g_object_new_valist: (skip)
2052  * @object_type: the type id of the #GObject subtype to instantiate
2053  * @first_property_name: the name of the first property
2054  * @var_args: the value of the first property, followed optionally by more
2055  *  name/value pairs, followed by %NULL
2056  *
2057  * Creates a new instance of a #GObject subtype and sets its properties.
2058  *
2059  * Construction parameters (see #G_PARAM_CONSTRUCT, #G_PARAM_CONSTRUCT_ONLY)
2060  * which are not explicitly specified are set to their default values.
2061  *
2062  * Returns: a new instance of @object_type
2063  */
2064 GObject*
2065 g_object_new_valist (GType        object_type,
2066                      const gchar *first_property_name,
2067                      va_list      var_args)
2068 {
</pre>
<hr />
<pre>
2128       object = g_object_new_internal (class, params, n_params);
2129 
2130       while (n_params--)
2131         g_value_unset (params[n_params].value);
2132 
2133       if (params != stack_params)
2134         g_free (params);
2135     }
2136   else
2137     /* Fast case: no properties passed in. */
2138     object = g_object_new_internal (class, NULL, 0);
2139 
2140   if (unref_class)
2141     g_type_class_unref (unref_class);
2142 
2143   return object;
2144 }
2145 
2146 static GObject*
2147 g_object_constructor (GType                  type,
<span class="line-modified">2148               guint                  n_construct_properties,</span>
<span class="line-modified">2149               GObjectConstructParam *construct_params)</span>
2150 {
2151   GObject *object;
2152 
2153   /* create object */
2154   object = (GObject*) g_type_create_instance (type);
2155 
2156   /* set construction parameters */
2157   if (n_construct_properties)
2158     {
2159       GObjectNotifyQueue *nqueue = g_object_notify_queue_freeze (object, FALSE);
2160 
2161       /* set construct properties */
2162       while (n_construct_properties--)
<span class="line-modified">2163     {</span>
<span class="line-modified">2164       GValue *value = construct_params-&gt;value;</span>
<span class="line-modified">2165       GParamSpec *pspec = construct_params-&gt;pspec;</span>
2166 
<span class="line-modified">2167       construct_params++;</span>
<span class="line-modified">2168       object_set_property (object, pspec, value, nqueue);</span>
<span class="line-modified">2169     }</span>
2170       g_object_notify_queue_thaw (object, nqueue);
2171       /* the notification queue is still frozen from g_object_init(), so
2172        * we don&#39;t need to handle it here, g_object_newv() takes
2173        * care of that
2174        */
2175     }
2176 
2177   return object;
2178 }
2179 
2180 static void
2181 g_object_constructed (GObject *object)
2182 {
2183   /* empty default impl to allow unconditional upchaining */
2184 }
2185 
2186 static inline gboolean
2187 g_object_set_is_valid_property (GObject         *object,
2188                                 GParamSpec      *pspec,
2189                                 const char      *property_name)
</pre>
<hr />
<pre>
2250         break;
2251 
2252       consider_issuing_property_deprecation_warning (pspec);
2253       object_set_property (object, pspec, &amp;values[i], nqueue);
2254     }
2255 
2256   g_object_notify_queue_thaw (object, nqueue);
2257   g_object_unref (object);
2258 }
2259 
2260 /**
2261  * g_object_set_valist: (skip)
2262  * @object: a #GObject
2263  * @first_property_name: name of the first property to set
2264  * @var_args: value for the first property, followed optionally by more
2265  *  name/value pairs, followed by %NULL
2266  *
2267  * Sets properties on an object.
2268  */
2269 void
<span class="line-modified">2270 g_object_set_valist (GObject     *object,</span>
<span class="line-modified">2271                      const gchar *first_property_name,</span>
<span class="line-modified">2272              va_list      var_args)</span>
2273 {
2274   GObjectNotifyQueue *nqueue;
2275   const gchar *name;
2276 
2277   g_return_if_fail (G_IS_OBJECT (object));
2278 
2279   g_object_ref (object);
2280   nqueue = g_object_notify_queue_freeze (object, FALSE);
2281 
2282   name = first_property_name;
2283   while (name)
2284     {
2285       GValue value = G_VALUE_INIT;
2286       GParamSpec *pspec;
2287       gchar *error = NULL;
2288 
2289       pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified">2290                     name,</span>
<span class="line-modified">2291                     G_OBJECT_TYPE (object),</span>
<span class="line-modified">2292                     TRUE);</span>
2293 
2294       if (!g_object_set_is_valid_property (object, pspec, name))
2295         break;
2296 
2297       G_VALUE_COLLECT_INIT (&amp;value, pspec-&gt;value_type, var_args,
<span class="line-modified">2298                 0, &amp;error);</span>
2299       if (error)
<span class="line-modified">2300     {</span>
<span class="line-modified">2301       g_warning (&quot;%s: %s&quot;, G_STRFUNC, error);</span>
<span class="line-modified">2302       g_free (error);</span>
2303           g_value_unset (&amp;value);
<span class="line-modified">2304       break;</span>
<span class="line-modified">2305     }</span>
2306 
2307       consider_issuing_property_deprecation_warning (pspec);
2308       object_set_property (object, pspec, &amp;value, nqueue);
2309       g_value_unset (&amp;value);
2310 
2311       name = va_arg (var_args, gchar*);
2312     }
2313 
2314   g_object_notify_queue_thaw (object, nqueue);
2315   g_object_unref (object);
2316 }
2317 
2318 static inline gboolean
2319 g_object_get_is_valid_property (GObject          *object,
2320                                 GParamSpec       *pspec,
2321                                 const char       *property_name)
2322 {
2323   if (G_UNLIKELY (pspec == NULL))
2324     {
2325       g_warning (&quot;%s: object class &#39;%s&#39; has no property named &#39;%s&#39;&quot;,
</pre>
<hr />
<pre>
2353 g_object_getv (GObject      *object,
2354                guint         n_properties,
2355                const gchar  *names[],
2356                GValue        values[])
2357 {
2358   guint i;
2359   GParamSpec *pspec;
2360   GType obj_type;
2361 
2362   g_return_if_fail (G_IS_OBJECT (object));
2363 
2364   if (n_properties == 0)
2365     return;
2366 
2367   g_object_ref (object);
2368 
2369   obj_type = G_OBJECT_TYPE (object);
2370   for (i = 0; i &lt; n_properties; i++)
2371     {
2372       pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified">2373                         names[i],</span>
<span class="line-modified">2374                         obj_type,</span>
<span class="line-modified">2375                         TRUE);</span>
2376       if (!g_object_get_is_valid_property (object, pspec, names[i]))
2377         break;
2378 
2379       memset (&amp;values[i], 0, sizeof (GValue));
2380       g_value_init (&amp;values[i], pspec-&gt;value_type);
2381       object_get_property (object, pspec, &amp;values[i]);
2382     }
2383   g_object_unref (object);
2384 }
2385 
2386 /**
2387  * g_object_get_valist: (skip)
2388  * @object: a #GObject
2389  * @first_property_name: name of the first property to get
2390  * @var_args: return location for the first property, followed optionally by more
2391  *  name/return location pairs, followed by %NULL
2392  *
2393  * Gets properties of an object.
2394  *
2395  * In general, a copy is made of the property contents and the caller
2396  * is responsible for freeing the memory in the appropriate manner for
2397  * the type, for instance by calling g_free() or g_object_unref().
2398  *
2399  * See g_object_get().
2400  */
2401 void
<span class="line-modified">2402 g_object_get_valist (GObject     *object,</span>
<span class="line-modified">2403                      const gchar *first_property_name,</span>
<span class="line-modified">2404              va_list      var_args)</span>
2405 {
2406   const gchar *name;
2407 
2408   g_return_if_fail (G_IS_OBJECT (object));
2409 
2410   g_object_ref (object);
2411 
2412   name = first_property_name;
2413 
2414   while (name)
2415     {
2416       GValue value = G_VALUE_INIT;
2417       GParamSpec *pspec;
2418       gchar *error;
2419 
2420       pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified">2421                     name,</span>
<span class="line-modified">2422                     G_OBJECT_TYPE (object),</span>
<span class="line-modified">2423                     TRUE);</span>
2424 
2425       if (!g_object_get_is_valid_property (object, pspec, name))
2426         break;
2427 
2428       g_value_init (&amp;value, pspec-&gt;value_type);
2429 
2430       object_get_property (object, pspec, &amp;value);
2431 
2432       G_VALUE_LCOPY (&amp;value, var_args, 0, &amp;error);
2433       if (error)
<span class="line-modified">2434     {</span>
<span class="line-modified">2435       g_warning (&quot;%s: %s&quot;, G_STRFUNC, error);</span>
<span class="line-modified">2436       g_free (error);</span>
<span class="line-modified">2437       g_value_unset (&amp;value);</span>
<span class="line-modified">2438       break;</span>
<span class="line-modified">2439     }</span>
2440 
2441       g_value_unset (&amp;value);
2442 
2443       name = va_arg (var_args, gchar*);
2444     }
2445 
2446   g_object_unref (object);
2447 }
2448 
2449 /**
2450  * g_object_set: (skip)
2451  * @object: (type GObject.Object): a #GObject
2452  * @first_property_name: name of the first property to set
2453  * @...: value for the first property, followed optionally by more
2454  *  name/value pairs, followed by %NULL
2455  *
2456  * Sets properties on an object.
2457  *
2458  * Note that the &quot;notify&quot; signals are queued and only emitted (in
2459  * reverse order) after all properties have been set. See
2460  * g_object_freeze_notify().
2461  */
2462 void
2463 g_object_set (gpointer     _object,
<span class="line-modified">2464           const gchar *first_property_name,</span>
<span class="line-modified">2465           ...)</span>
2466 {
2467   GObject *object = _object;
2468   va_list var_args;
2469 
2470   g_return_if_fail (G_IS_OBJECT (object));
2471 
2472   va_start (var_args, first_property_name);
2473   g_object_set_valist (object, first_property_name, var_args);
2474   va_end (var_args);
2475 }
2476 
2477 /**
2478  * g_object_get: (skip)
2479  * @object: (type GObject.Object): a #GObject
2480  * @first_property_name: name of the first property to get
2481  * @...: return location for the first property, followed optionally by more
2482  *  name/return location pairs, followed by %NULL
2483  *
2484  * Gets properties of an object.
2485  *
</pre>
<hr />
<pre>
2491  * of three properties: an integer, a string and an object:
2492  * |[&lt;!-- language=&quot;C&quot; --&gt;
2493  *  gint intval;
2494  *  gchar *strval;
2495  *  GObject *objval;
2496  *
2497  *  g_object_get (my_object,
2498  *                &quot;int-property&quot;, &amp;intval,
2499  *                &quot;str-property&quot;, &amp;strval,
2500  *                &quot;obj-property&quot;, &amp;objval,
2501  *                NULL);
2502  *
2503  *  // Do something with intval, strval, objval
2504  *
2505  *  g_free (strval);
2506  *  g_object_unref (objval);
2507  *  ]|
2508  */
2509 void
2510 g_object_get (gpointer     _object,
<span class="line-modified">2511           const gchar *first_property_name,</span>
<span class="line-modified">2512           ...)</span>
2513 {
2514   GObject *object = _object;
2515   va_list var_args;
2516 
2517   g_return_if_fail (G_IS_OBJECT (object));
2518 
2519   va_start (var_args, first_property_name);
2520   g_object_get_valist (object, first_property_name, var_args);
2521   va_end (var_args);
2522 }
2523 
2524 /**
2525  * g_object_set_property:
2526  * @object: a #GObject
2527  * @property_name: the name of the property to set
2528  * @value: the value
2529  *
2530  * Sets a property on an object.
2531  */
2532 void
2533 g_object_set_property (GObject      *object,
<span class="line-modified">2534                        const gchar  *property_name,</span>
<span class="line-modified">2535                        const GValue *value)</span>
2536 {
2537   g_object_setv (object, 1, &amp;property_name, value);
2538 }
2539 
2540 /**
2541  * g_object_get_property:
2542  * @object: a #GObject
2543  * @property_name: the name of the property to get
2544  * @value: return location for the property value
2545  *
<span class="line-modified">2546  * Gets a property of an object. @value must have been initialized to the</span>
<span class="line-modified">2547  * expected type of the property (or a type to which the expected type can be</span>
<span class="line-modified">2548  * transformed) using g_value_init().</span>







2549  *
2550  * In general, a copy is made of the property contents and the caller is
2551  * responsible for freeing the memory by calling g_value_unset().
2552  *
2553  * Note that g_object_get_property() is really intended for language
2554  * bindings, g_object_get() is much more convenient for C programming.
2555  */
2556 void
2557 g_object_get_property (GObject     *object,
<span class="line-modified">2558                        const gchar *property_name,</span>
<span class="line-modified">2559                GValue      *value)</span>
2560 {
2561   GParamSpec *pspec;
2562 
2563   g_return_if_fail (G_IS_OBJECT (object));
2564   g_return_if_fail (property_name != NULL);
<span class="line-modified">2565   g_return_if_fail (G_IS_VALUE (value));</span>
2566 
2567   g_object_ref (object);
2568 
2569   pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified">2570                     property_name,</span>
<span class="line-modified">2571                     G_OBJECT_TYPE (object),</span>
<span class="line-modified">2572                     TRUE);</span>
2573 
2574   if (g_object_get_is_valid_property (object, pspec, property_name))
2575     {
2576       GValue *prop_value, tmp_value = G_VALUE_INIT;
2577 
<span class="line-modified">2578       /* auto-conversion of the callers value type</span>
<span class="line-modified">2579        */</span>
<span class="line-modified">2580       if (G_VALUE_TYPE (value) == pspec-&gt;value_type)</span>
<span class="line-modified">2581     {</span>
<span class="line-modified">2582       g_value_reset (value);</span>
<span class="line-modified">2583       prop_value = value;</span>
<span class="line-modified">2584     }</span>





2585       else if (!g_value_type_transformable (pspec-&gt;value_type, G_VALUE_TYPE (value)))
<span class="line-modified">2586     {</span>
<span class="line-modified">2587       g_warning (&quot;%s: can&#39;t retrieve property &#39;%s&#39; of type &#39;%s&#39; as value of type &#39;%s&#39;&quot;,</span>
<span class="line-modified">2588              G_STRFUNC, pspec-&gt;name,</span>
<span class="line-modified">2589              g_type_name (pspec-&gt;value_type),</span>
<span class="line-modified">2590              G_VALUE_TYPE_NAME (value));</span>
<span class="line-modified">2591       g_object_unref (object);</span>
<span class="line-modified">2592       return;</span>
<span class="line-modified">2593     }</span>
2594       else
<span class="line-modified">2595     {</span>
<span class="line-modified">2596       g_value_init (&amp;tmp_value, pspec-&gt;value_type);</span>
<span class="line-modified">2597       prop_value = &amp;tmp_value;</span>
<span class="line-modified">2598     }</span>
2599       object_get_property (object, pspec, prop_value);
2600       if (prop_value != value)
<span class="line-modified">2601     {</span>
<span class="line-modified">2602       g_value_transform (prop_value, value);</span>
<span class="line-modified">2603       g_value_unset (&amp;tmp_value);</span>
<span class="line-modified">2604     }</span>
2605     }
2606 
2607   g_object_unref (object);
2608 }
2609 
2610 /**
2611  * g_object_connect: (skip)
2612  * @object: (type GObject.Object): a #GObject
2613  * @signal_spec: the spec for the first signal
2614  * @...: #GCallback for the first signal, followed by data for the
2615  *       first signal, followed optionally by more signal
2616  *       spec/callback/data triples, followed by %NULL
2617  *
2618  * A convenience function to connect multiple signals at once.
2619  *
2620  * The signal specs expected by this function have the form
2621  * &quot;modifier::signal_name&quot;, where modifier can be one of the following:
<span class="line-modified">2622  * * - signal: equivalent to g_signal_connect_data (..., NULL, 0)</span>
2623  * - object-signal, object_signal: equivalent to g_signal_connect_object (..., 0)
2624  * - swapped-signal, swapped_signal: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED)
2625  * - swapped_object_signal, swapped-object-signal: equivalent to g_signal_connect_object (..., G_CONNECT_SWAPPED)
2626  * - signal_after, signal-after: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_AFTER)
2627  * - object_signal_after, object-signal-after: equivalent to g_signal_connect_object (..., G_CONNECT_AFTER)
2628  * - swapped_signal_after, swapped-signal-after: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED | G_CONNECT_AFTER)
2629  * - swapped_object_signal_after, swapped-object-signal-after: equivalent to g_signal_connect_object (..., G_CONNECT_SWAPPED | G_CONNECT_AFTER)
2630  *
2631  * |[&lt;!-- language=&quot;C&quot; --&gt;
2632  *   menu-&gt;toplevel = g_object_connect (g_object_new (GTK_TYPE_WINDOW,
<span class="line-modified">2633  *                         &quot;type&quot;, GTK_WINDOW_POPUP,</span>
<span class="line-modified">2634  *                         &quot;child&quot;, menu,</span>
<span class="line-modified">2635  *                         NULL),</span>
<span class="line-modified">2636  *                   &quot;signal::event&quot;, gtk_menu_window_event, menu,</span>
<span class="line-modified">2637  *                   &quot;signal::size_request&quot;, gtk_menu_window_size_request, menu,</span>
<span class="line-modified">2638  *                   &quot;signal::destroy&quot;, gtk_widget_destroyed, &amp;menu-&gt;toplevel,</span>
<span class="line-modified">2639  *                   NULL);</span>
2640  * ]|
2641  *
2642  * Returns: (transfer none) (type GObject.Object): @object
2643  */
2644 gpointer
2645 g_object_connect (gpointer     _object,
<span class="line-modified">2646           const gchar *signal_spec,</span>
<span class="line-modified">2647           ...)</span>
2648 {
2649   GObject *object = _object;
2650   va_list var_args;
2651 
2652   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
2653   g_return_val_if_fail (object-&gt;ref_count &gt; 0, object);
2654 
2655   va_start (var_args, signal_spec);
2656   while (signal_spec)
2657     {
2658       GCallback callback = va_arg (var_args, GCallback);
2659       gpointer data = va_arg (var_args, gpointer);
2660 
2661       if (strncmp (signal_spec, &quot;signal::&quot;, 8) == 0)
<span class="line-modified">2662     g_signal_connect_data (object, signal_spec + 8,</span>
<span class="line-modified">2663                    callback, data, NULL,</span>
<span class="line-modified">2664                    0);</span>
2665       else if (strncmp (signal_spec, &quot;object_signal::&quot;, 15) == 0 ||
2666                strncmp (signal_spec, &quot;object-signal::&quot;, 15) == 0)
<span class="line-modified">2667     g_signal_connect_object (object, signal_spec + 15,</span>
<span class="line-modified">2668                  callback, data,</span>
<span class="line-modified">2669                  0);</span>
2670       else if (strncmp (signal_spec, &quot;swapped_signal::&quot;, 16) == 0 ||
2671                strncmp (signal_spec, &quot;swapped-signal::&quot;, 16) == 0)
<span class="line-modified">2672     g_signal_connect_data (object, signal_spec + 16,</span>
<span class="line-modified">2673                    callback, data, NULL,</span>
<span class="line-modified">2674                    G_CONNECT_SWAPPED);</span>
2675       else if (strncmp (signal_spec, &quot;swapped_object_signal::&quot;, 23) == 0 ||
2676                strncmp (signal_spec, &quot;swapped-object-signal::&quot;, 23) == 0)
<span class="line-modified">2677     g_signal_connect_object (object, signal_spec + 23,</span>
<span class="line-modified">2678                  callback, data,</span>
<span class="line-modified">2679                  G_CONNECT_SWAPPED);</span>
2680       else if (strncmp (signal_spec, &quot;signal_after::&quot;, 14) == 0 ||
2681                strncmp (signal_spec, &quot;signal-after::&quot;, 14) == 0)
<span class="line-modified">2682     g_signal_connect_data (object, signal_spec + 14,</span>
<span class="line-modified">2683                    callback, data, NULL,</span>
<span class="line-modified">2684                    G_CONNECT_AFTER);</span>
2685       else if (strncmp (signal_spec, &quot;object_signal_after::&quot;, 21) == 0 ||
2686                strncmp (signal_spec, &quot;object-signal-after::&quot;, 21) == 0)
<span class="line-modified">2687     g_signal_connect_object (object, signal_spec + 21,</span>
<span class="line-modified">2688                  callback, data,</span>
<span class="line-modified">2689                  G_CONNECT_AFTER);</span>
2690       else if (strncmp (signal_spec, &quot;swapped_signal_after::&quot;, 22) == 0 ||
2691                strncmp (signal_spec, &quot;swapped-signal-after::&quot;, 22) == 0)
<span class="line-modified">2692     g_signal_connect_data (object, signal_spec + 22,</span>
<span class="line-modified">2693                    callback, data, NULL,</span>
<span class="line-modified">2694                    G_CONNECT_SWAPPED | G_CONNECT_AFTER);</span>
2695       else if (strncmp (signal_spec, &quot;swapped_object_signal_after::&quot;, 29) == 0 ||
2696                strncmp (signal_spec, &quot;swapped-object-signal-after::&quot;, 29) == 0)
<span class="line-modified">2697     g_signal_connect_object (object, signal_spec + 29,</span>
<span class="line-modified">2698                  callback, data,</span>
<span class="line-modified">2699                  G_CONNECT_SWAPPED | G_CONNECT_AFTER);</span>
2700       else
<span class="line-modified">2701     {</span>
<span class="line-modified">2702       g_warning (&quot;%s: invalid signal spec \&quot;%s\&quot;&quot;, G_STRFUNC, signal_spec);</span>
<span class="line-modified">2703       break;</span>
<span class="line-modified">2704     }</span>
2705       signal_spec = va_arg (var_args, gchar*);
2706     }
2707   va_end (var_args);
2708 
2709   return object;
2710 }
2711 
2712 /**
2713  * g_object_disconnect: (skip)
2714  * @object: (type GObject.Object): a #GObject
2715  * @signal_spec: the spec for the first signal
2716  * @...: #GCallback for the first signal, followed by data for the first signal,
2717  *  followed optionally by more signal spec/callback/data triples,
2718  *  followed by %NULL
2719  *
2720  * A convenience function to disconnect multiple signals at once.
2721  *
2722  * The signal specs expected by this function have the form
2723  * &quot;any_signal&quot;, which means to disconnect any signal with matching
2724  * callback and data, or &quot;any_signal::signal_name&quot;, which only
2725  * disconnects the signal named &quot;signal_name&quot;.
2726  */
2727 void
2728 g_object_disconnect (gpointer     _object,
<span class="line-modified">2729              const gchar *signal_spec,</span>
<span class="line-modified">2730              ...)</span>
2731 {
2732   GObject *object = _object;
2733   va_list var_args;
2734 
2735   g_return_if_fail (G_IS_OBJECT (object));
2736   g_return_if_fail (object-&gt;ref_count &gt; 0);
2737 
2738   va_start (var_args, signal_spec);
2739   while (signal_spec)
2740     {
2741       GCallback callback = va_arg (var_args, GCallback);
2742       gpointer data = va_arg (var_args, gpointer);
2743       guint sid = 0, detail = 0, mask = 0;
2744 
2745       if (strncmp (signal_spec, &quot;any_signal::&quot;, 12) == 0 ||
2746           strncmp (signal_spec, &quot;any-signal::&quot;, 12) == 0)
<span class="line-modified">2747     {</span>
<span class="line-modified">2748       signal_spec += 12;</span>
<span class="line-modified">2749       mask = G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA;</span>
<span class="line-modified">2750     }</span>
2751       else if (strcmp (signal_spec, &quot;any_signal&quot;) == 0 ||
2752                strcmp (signal_spec, &quot;any-signal&quot;) == 0)
<span class="line-modified">2753     {</span>
<span class="line-modified">2754       signal_spec += 10;</span>
<span class="line-modified">2755       mask = G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA;</span>
<span class="line-modified">2756     }</span>
2757       else
<span class="line-modified">2758     {</span>
<span class="line-modified">2759       g_warning (&quot;%s: invalid signal spec \&quot;%s\&quot;&quot;, G_STRFUNC, signal_spec);</span>
<span class="line-modified">2760       break;</span>
<span class="line-modified">2761     }</span>
2762 
2763       if ((mask &amp; G_SIGNAL_MATCH_ID) &amp;&amp;
<span class="line-modified">2764       !g_signal_parse_name (signal_spec, G_OBJECT_TYPE (object), &amp;sid, &amp;detail, FALSE))</span>
<span class="line-modified">2765     g_warning (&quot;%s: invalid signal name \&quot;%s\&quot;&quot;, G_STRFUNC, signal_spec);</span>
2766       else if (!g_signal_handlers_disconnect_matched (object, mask | (detail ? G_SIGNAL_MATCH_DETAIL : 0),
<span class="line-modified">2767                               sid, detail,</span>
<span class="line-modified">2768                               NULL, (gpointer)callback, data))</span>
<span class="line-modified">2769     g_warning (&quot;%s: signal handler %p(%p) is not connected&quot;, G_STRFUNC, callback, data);</span>
2770       signal_spec = va_arg (var_args, gchar*);
2771     }
2772   va_end (var_args);
2773 }
2774 
2775 typedef struct {
2776   GObject *object;
2777   guint n_weak_refs;
2778   struct {
2779     GWeakNotify notify;
2780     gpointer    data;
2781   } weak_refs[1];  /* flexible array */
2782 } WeakRefStack;
2783 
2784 static void
2785 weak_refs_notify (gpointer data)
2786 {
2787   WeakRefStack *wstack = data;
2788   guint i;
2789 
</pre>
<hr />
<pre>
2794 
2795 /**
2796  * g_object_weak_ref: (skip)
2797  * @object: #GObject to reference weakly
2798  * @notify: callback to invoke before the object is freed
2799  * @data: extra data to pass to notify
2800  *
2801  * Adds a weak reference callback to an object. Weak references are
2802  * used for notification when an object is finalized. They are called
2803  * &quot;weak references&quot; because they allow you to safely hold a pointer
2804  * to an object without calling g_object_ref() (g_object_ref() adds a
2805  * strong reference, that is, forces the object to stay alive).
2806  *
2807  * Note that the weak references created by this method are not
2808  * thread-safe: they cannot safely be used in one thread if the
2809  * object&#39;s last g_object_unref() might happen in another thread.
2810  * Use #GWeakRef if thread-safety is required.
2811  */
2812 void
2813 g_object_weak_ref (GObject    *object,
<span class="line-modified">2814            GWeakNotify notify,</span>
<span class="line-modified">2815            gpointer    data)</span>
2816 {
2817   WeakRefStack *wstack;
2818   guint i;
2819 
2820   g_return_if_fail (G_IS_OBJECT (object));
2821   g_return_if_fail (notify != NULL);
<span class="line-modified">2822   g_return_if_fail (object-&gt;ref_count &gt;= 1);</span>
2823 
2824   G_LOCK (weak_refs_mutex);
2825   wstack = g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark_weak_refs);
2826   if (wstack)
2827     {
2828       i = wstack-&gt;n_weak_refs++;
2829       wstack = g_realloc (wstack, sizeof (*wstack) + sizeof (wstack-&gt;weak_refs[0]) * i);
2830     }
2831   else
2832     {
2833       wstack = g_renew (WeakRefStack, NULL, 1);
2834       wstack-&gt;object = object;
2835       wstack-&gt;n_weak_refs = 1;
2836       i = 0;
2837     }
2838   wstack-&gt;weak_refs[i].notify = notify;
2839   wstack-&gt;weak_refs[i].data = data;
2840   g_datalist_id_set_data_full (&amp;object-&gt;qdata, quark_weak_refs, wstack, weak_refs_notify);
2841   G_UNLOCK (weak_refs_mutex);
2842 }
2843 
2844 /**
2845  * g_object_weak_unref: (skip)
2846  * @object: #GObject to remove a weak reference from
2847  * @notify: callback to search for
2848  * @data: data to search for
2849  *
2850  * Removes a weak reference callback to an object.
2851  */
2852 void
2853 g_object_weak_unref (GObject    *object,
<span class="line-modified">2854              GWeakNotify notify,</span>
<span class="line-modified">2855              gpointer    data)</span>
2856 {
2857   WeakRefStack *wstack;
2858   gboolean found_one = FALSE;
2859 
2860   g_return_if_fail (G_IS_OBJECT (object));
2861   g_return_if_fail (notify != NULL);
2862 
2863   G_LOCK (weak_refs_mutex);
2864   wstack = g_datalist_id_get_data (&amp;object-&gt;qdata, quark_weak_refs);
2865   if (wstack)
2866     {
2867       guint i;
2868 
2869       for (i = 0; i &lt; wstack-&gt;n_weak_refs; i++)
<span class="line-modified">2870     if (wstack-&gt;weak_refs[i].notify == notify &amp;&amp;</span>
<span class="line-modified">2871         wstack-&gt;weak_refs[i].data == data)</span>
<span class="line-modified">2872       {</span>
<span class="line-modified">2873         found_one = TRUE;</span>
<span class="line-modified">2874         wstack-&gt;n_weak_refs -= 1;</span>
<span class="line-modified">2875         if (i != wstack-&gt;n_weak_refs)</span>
<span class="line-modified">2876           wstack-&gt;weak_refs[i] = wstack-&gt;weak_refs[wstack-&gt;n_weak_refs];</span>
2877 
<span class="line-modified">2878         break;</span>
<span class="line-modified">2879       }</span>
2880     }
2881   G_UNLOCK (weak_refs_mutex);
2882   if (!found_one)
2883     g_warning (&quot;%s: couldn&#39;t find weak ref %p(%p)&quot;, G_STRFUNC, notify, data);
2884 }
2885 
2886 /**
2887  * g_object_add_weak_pointer: (skip)
2888  * @object: The object that should be weak referenced.
2889  * @weak_pointer_location: (inout) (not optional): The memory address
2890  *    of a pointer.
2891  *
2892  * Adds a weak reference from weak_pointer to @object to indicate that
2893  * the pointer located at @weak_pointer_location is only valid during
2894  * the lifetime of @object. When the @object is finalized,
2895  * @weak_pointer will be set to %NULL.
2896  *
2897  * Note that as with g_object_weak_ref(), the weak references created by
2898  * this method are not thread-safe: they cannot safely be used in one
2899  * thread if the object&#39;s last g_object_unref() might happen in another
</pre>
<hr />
<pre>
2984  *
2985  * In other words, if the object is floating, then this call &quot;assumes
2986  * ownership&quot; of the floating reference, converting it to a normal
2987  * reference by clearing the floating flag while leaving the reference
2988  * count unchanged.  If the object is not floating, then this call
2989  * adds a new normal reference increasing the reference count by one.
2990  *
2991  * Since GLib 2.56, the type of @object will be propagated to the return type
2992  * under the same conditions as for g_object_ref().
2993  *
2994  * Since: 2.10
2995  *
2996  * Returns: (type GObject.Object) (transfer none): @object
2997  */
2998 gpointer
2999 (g_object_ref_sink) (gpointer _object)
3000 {
3001   GObject *object = _object;
3002   gboolean was_floating;
3003   g_return_val_if_fail (G_IS_OBJECT (object), object);
<span class="line-modified">3004   g_return_val_if_fail (object-&gt;ref_count &gt;= 1, object);</span>
3005   g_object_ref (object);
3006   was_floating = floating_flag_handler (object, -1);
3007   if (was_floating)
3008     g_object_unref (object);
3009   return object;
3010 }
3011 
3012 /**
3013  * g_object_force_floating:
3014  * @object: a #GObject
3015  *
3016  * This function is intended for #GObject implementations to re-enforce
3017  * a [floating][floating-ref] object reference. Doing this is seldom
3018  * required: all #GInitiallyUnowneds are created with a floating reference
3019  * which usually just needs to be sunken by calling g_object_ref_sink().
3020  *
3021  * Since: 2.10
3022  */
3023 void
3024 g_object_force_floating (GObject *object)
3025 {
3026   g_return_if_fail (G_IS_OBJECT (object));
<span class="line-modified">3027   g_return_if_fail (object-&gt;ref_count &gt;= 1);</span>
3028 
3029   floating_flag_handler (object, +1);
3030 }
3031 
3032 typedef struct {
3033   GObject *object;
3034   guint n_toggle_refs;
3035   struct {
3036     GToggleNotify notify;
3037     gpointer    data;
3038   } toggle_refs[1];  /* flexible array */
3039 } ToggleRefStack;
3040 
3041 static void
3042 toggle_refs_notify (GObject *object,
<span class="line-modified">3043             gboolean is_last_ref)</span>
3044 {
3045   ToggleRefStack tstack, *tstackptr;
3046 
3047   G_LOCK (toggle_refs_mutex);
3048   tstackptr = g_datalist_id_get_data (&amp;object-&gt;qdata, quark_toggle_refs);
3049   tstack = *tstackptr;
3050   G_UNLOCK (toggle_refs_mutex);
3051 
3052   /* Reentrancy here is not as tricky as it seems, because a toggle reference
3053    * will only be notified when there is exactly one of them.
3054    */
3055   g_assert (tstack.n_toggle_refs == 1);
3056   tstack.toggle_refs[0].notify (tstack.toggle_refs[0].data, tstack.object, is_last_ref);
3057 }
3058 
3059 /**
3060  * g_object_add_toggle_ref: (skip)
3061  * @object: a #GObject
3062  * @notify: a function to call when this reference is the
3063  *  last reference to the object, or is no longer
</pre>
<hr />
<pre>
3080  * to the proxy object, but when there are other references held to
3081  * @object, a strong reference is held. The @notify callback is called
3082  * when the reference from @object to the proxy object should be
3083  * &quot;toggled&quot; from strong to weak (@is_last_ref true) or weak to strong
3084  * (@is_last_ref false).
3085  *
3086  * Since a (normal) reference must be held to the object before
3087  * calling g_object_add_toggle_ref(), the initial state of the reverse
3088  * link is always strong.
3089  *
3090  * Multiple toggle references may be added to the same gobject,
3091  * however if there are multiple toggle references to an object, none
3092  * of them will ever be notified until all but one are removed.  For
3093  * this reason, you should only ever use a toggle reference if there
3094  * is important state in the proxy object.
3095  *
3096  * Since: 2.8
3097  */
3098 void
3099 g_object_add_toggle_ref (GObject       *object,
<span class="line-modified">3100              GToggleNotify  notify,</span>
<span class="line-modified">3101              gpointer       data)</span>
3102 {
3103   ToggleRefStack *tstack;
3104   guint i;
3105 
3106   g_return_if_fail (G_IS_OBJECT (object));
3107   g_return_if_fail (notify != NULL);
<span class="line-modified">3108   g_return_if_fail (object-&gt;ref_count &gt;= 1);</span>
3109 
3110   g_object_ref (object);
3111 
3112   G_LOCK (toggle_refs_mutex);
3113   tstack = g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark_toggle_refs);
3114   if (tstack)
3115     {
3116       i = tstack-&gt;n_toggle_refs++;
3117       /* allocate i = tstate-&gt;n_toggle_refs - 1 positions beyond the 1 declared
3118        * in tstate-&gt;toggle_refs */
3119       tstack = g_realloc (tstack, sizeof (*tstack) + sizeof (tstack-&gt;toggle_refs[0]) * i);
3120     }
3121   else
3122     {
3123       tstack = g_renew (ToggleRefStack, NULL, 1);
3124       tstack-&gt;object = object;
3125       tstack-&gt;n_toggle_refs = 1;
3126       i = 0;
3127     }
3128 
3129   /* Set a flag for fast lookup after adding the first toggle reference */
3130   if (tstack-&gt;n_toggle_refs == 1)
3131     g_datalist_set_flags (&amp;object-&gt;qdata, OBJECT_HAS_TOGGLE_REF_FLAG);
3132 
3133   tstack-&gt;toggle_refs[i].notify = notify;
3134   tstack-&gt;toggle_refs[i].data = data;
3135   g_datalist_id_set_data_full (&amp;object-&gt;qdata, quark_toggle_refs, tstack,
<span class="line-modified">3136                    (GDestroyNotify)g_free);</span>
3137   G_UNLOCK (toggle_refs_mutex);
3138 }
3139 
3140 /**
3141  * g_object_remove_toggle_ref: (skip)
3142  * @object: a #GObject
3143  * @notify: a function to call when this reference is the
3144  *  last reference to the object, or is no longer
3145  *  the last reference.
3146  * @data: data to pass to @notify
3147  *
3148  * Removes a reference added with g_object_add_toggle_ref(). The
3149  * reference count of the object is decreased by one.
3150  *
3151  * Since: 2.8
3152  */
3153 void
3154 g_object_remove_toggle_ref (GObject       *object,
<span class="line-modified">3155                 GToggleNotify  notify,</span>
<span class="line-modified">3156                 gpointer       data)</span>
3157 {
3158   ToggleRefStack *tstack;
3159   gboolean found_one = FALSE;
3160 
3161   g_return_if_fail (G_IS_OBJECT (object));
3162   g_return_if_fail (notify != NULL);
3163 
3164   G_LOCK (toggle_refs_mutex);
3165   tstack = g_datalist_id_get_data (&amp;object-&gt;qdata, quark_toggle_refs);
3166   if (tstack)
3167     {
3168       guint i;
3169 
3170       for (i = 0; i &lt; tstack-&gt;n_toggle_refs; i++)
<span class="line-modified">3171     if (tstack-&gt;toggle_refs[i].notify == notify &amp;&amp;</span>
<span class="line-modified">3172         tstack-&gt;toggle_refs[i].data == data)</span>
<span class="line-modified">3173       {</span>
<span class="line-modified">3174         found_one = TRUE;</span>
<span class="line-modified">3175         tstack-&gt;n_toggle_refs -= 1;</span>
<span class="line-modified">3176         if (i != tstack-&gt;n_toggle_refs)</span>
<span class="line-modified">3177           tstack-&gt;toggle_refs[i] = tstack-&gt;toggle_refs[tstack-&gt;n_toggle_refs];</span>
3178 
<span class="line-modified">3179         if (tstack-&gt;n_toggle_refs == 0)</span>
<span class="line-modified">3180           g_datalist_unset_flags (&amp;object-&gt;qdata, OBJECT_HAS_TOGGLE_REF_FLAG);</span>
3181 
<span class="line-modified">3182         break;</span>
<span class="line-modified">3183       }</span>
3184     }
3185   G_UNLOCK (toggle_refs_mutex);
3186 
3187   if (found_one)
3188     g_object_unref (object);
3189   else
3190     g_warning (&quot;%s: couldn&#39;t find toggle ref %p(%p)&quot;, G_STRFUNC, notify, data);
3191 }
3192 
3193 /**
3194  * g_object_ref:
3195  * @object: (type GObject.Object): a #GObject
3196  *
3197  * Increases the reference count of @object.
3198  *
3199  * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
3200  * of @object will be propagated to the return type (using the GCC typeof()
3201  * extension), so any casting the caller needs to do on the return type must be
3202  * explicit.
3203  *
3204  * Returns: (type GObject.Object) (transfer none): the same @object
3205  */
3206 gpointer
3207 (g_object_ref) (gpointer _object)
3208 {
3209   GObject *object = _object;
3210   gint old_val;
3211 
3212   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
<span class="line-removed">3213   g_return_val_if_fail (object-&gt;ref_count &gt; 0, NULL);</span>
3214 
3215   old_val = g_atomic_int_add (&amp;object-&gt;ref_count, 1);

3216 
3217   if (old_val == 1 &amp;&amp; OBJECT_HAS_TOGGLE_REF (object))
3218     toggle_refs_notify (object, FALSE);
3219 
3220   TRACE (GOBJECT_OBJECT_REF(object,G_TYPE_FROM_INSTANCE(object),old_val));
3221 
3222   return object;
3223 }
3224 
3225 /**
3226  * g_object_unref:
3227  * @object: (type GObject.Object): a #GObject
3228  *
3229  * Decreases the reference count of @object. When its reference count
3230  * drops to 0, the object is finalized (i.e. its memory is freed).
3231  *
3232  * If the pointer to the #GObject may be reused in future (for example, if it is
3233  * an instance variable of another object), it is recommended to clear the
3234  * pointer to %NULL rather than retain a dangling pointer to a potentially
3235  * invalid #GObject instance. Use g_clear_object() for this.
3236  */
3237 void
3238 g_object_unref (gpointer _object)
3239 {
3240   GObject *object = _object;
3241   gint old_ref;
3242 
3243   g_return_if_fail (G_IS_OBJECT (object));
<span class="line-removed">3244   g_return_if_fail (object-&gt;ref_count &gt; 0);</span>
3245 
3246   /* here we want to atomically do: if (ref_count&gt;1) { ref_count--; return; } */
3247  retry_atomic_decrement1:
3248   old_ref = g_atomic_int_get (&amp;object-&gt;ref_count);
3249   if (old_ref &gt; 1)
3250     {
3251       /* valid if last 2 refs are owned by this call to unref and the toggle_ref */
3252       gboolean has_toggle_ref = OBJECT_HAS_TOGGLE_REF (object);
3253 
3254       if (!g_atomic_int_compare_and_exchange ((int *)&amp;object-&gt;ref_count, old_ref, old_ref - 1))
<span class="line-modified">3255     goto retry_atomic_decrement1;</span>
3256 
3257       TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));
3258 
3259       /* if we went from 2-&gt;1 we need to notify toggle refs if any */
3260       if (old_ref == 2 &amp;&amp; has_toggle_ref) /* The last ref being held in this case is owned by the toggle_ref */
<span class="line-modified">3261     toggle_refs_notify (object, TRUE);</span>
3262     }
3263   else
3264     {
3265       GSList **weak_locations;
3266 
3267       /* The only way that this object can live at this point is if
3268        * there are outstanding weak references already established
3269        * before we got here.
3270        *
3271        * If there were not already weak references then no more can be
3272        * established at this time, because the other thread would have
3273        * to hold a strong ref in order to call
3274        * g_object_add_weak_pointer() and then we wouldn&#39;t be here.
3275        */
3276       weak_locations = g_datalist_id_get_data (&amp;object-&gt;qdata, quark_weak_locations);
3277 
3278       if (weak_locations != NULL)
3279         {
3280           g_rw_lock_writer_lock (&amp;weak_locations_lock);
3281 
</pre>
<hr />
<pre>
3301               *weak_locations = g_slist_delete_link (*weak_locations, *weak_locations);
3302             }
3303 
3304           g_rw_lock_writer_unlock (&amp;weak_locations_lock);
3305         }
3306 
3307       /* we are about to remove the last reference */
3308       TRACE (GOBJECT_OBJECT_DISPOSE(object,G_TYPE_FROM_INSTANCE(object), 1));
3309       G_OBJECT_GET_CLASS (object)-&gt;dispose (object);
3310       TRACE (GOBJECT_OBJECT_DISPOSE_END(object,G_TYPE_FROM_INSTANCE(object), 1));
3311 
3312       /* may have been re-referenced meanwhile */
3313     retry_atomic_decrement2:
3314       old_ref = g_atomic_int_get ((int *)&amp;object-&gt;ref_count);
3315       if (old_ref &gt; 1)
3316         {
3317           /* valid if last 2 refs are owned by this call to unref and the toggle_ref */
3318           gboolean has_toggle_ref = OBJECT_HAS_TOGGLE_REF (object);
3319 
3320           if (!g_atomic_int_compare_and_exchange ((int *)&amp;object-&gt;ref_count, old_ref, old_ref - 1))
<span class="line-modified">3321         goto retry_atomic_decrement2;</span>
3322 
<span class="line-modified">3323       TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));</span>
3324 
3325           /* if we went from 2-&gt;1 we need to notify toggle refs if any */
3326           if (old_ref == 2 &amp;&amp; has_toggle_ref) /* The last ref being held in this case is owned by the toggle_ref */
<span class="line-modified">3327         toggle_refs_notify (object, TRUE);</span>
3328 
<span class="line-modified">3329       return;</span>
<span class="line-modified">3330     }</span>
3331 
3332       /* we are still in the process of taking away the last ref */
3333       g_datalist_id_set_data (&amp;object-&gt;qdata, quark_closure_array, NULL);
3334       g_signal_handlers_destroy (object);
3335       g_datalist_id_set_data (&amp;object-&gt;qdata, quark_weak_refs, NULL);
3336 
3337       /* decrement the last reference */
3338       old_ref = g_atomic_int_add (&amp;object-&gt;ref_count, -1);

3339 
3340       TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));
3341 
3342       /* may have been re-referenced meanwhile */
3343       if (G_LIKELY (old_ref == 1))
<span class="line-modified">3344     {</span>
<span class="line-modified">3345       TRACE (GOBJECT_OBJECT_FINALIZE(object,G_TYPE_FROM_INSTANCE(object)));</span>
3346           G_OBJECT_GET_CLASS (object)-&gt;finalize (object);
3347 
<span class="line-modified">3348       TRACE (GOBJECT_OBJECT_FINALIZE_END(object,G_TYPE_FROM_INSTANCE(object)));</span>
3349 
3350           GOBJECT_IF_DEBUG (OBJECTS,
<span class="line-modified">3351         {</span>
<span class="line-modified">3352           /* catch objects not chaining finalize handlers */</span>
<span class="line-modified">3353           G_LOCK (debug_objects);</span>
<span class="line-modified">3354           g_assert (!g_hash_table_contains (debug_objects_ht, object));</span>
<span class="line-modified">3355           G_UNLOCK (debug_objects);</span>
<span class="line-modified">3356         });</span>






3357           g_type_free_instance ((GTypeInstance*) object);
<span class="line-modified">3358     }</span>
3359     }
3360 }
3361 
3362 /**
3363  * g_clear_object: (skip)
3364  * @object_ptr: a pointer to a #GObject reference
3365  *
3366  * Clears a reference to a #GObject.
3367  *
3368  * @object_ptr must not be %NULL.
3369  *
3370  * If the reference is %NULL then this function does nothing.
3371  * Otherwise, the reference count of the object is decreased and the
3372  * pointer is set to %NULL.
3373  *
3374  * A macro is also included that allows this function to be used without
3375  * pointer casts.
3376  *
3377  * Since: 2.28
3378  **/
3379 #undef g_clear_object
3380 void
3381 g_clear_object (GObject **object_ptr)
3382 {
3383   g_clear_pointer (object_ptr, g_object_unref);
3384 }
3385 
3386 /**
3387  * g_object_get_qdata:
3388  * @object: The GObject to get a stored user data pointer from
3389  * @quark: A #GQuark, naming the user data pointer
3390  *
3391  * This function gets back user data pointers stored via
3392  * g_object_set_qdata().
3393  *
3394  * Returns: (transfer none) (nullable): The user data pointer set, or %NULL
3395  */
3396 gpointer
3397 g_object_get_qdata (GObject *object,
<span class="line-modified">3398             GQuark   quark)</span>
3399 {
3400   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
3401 
3402   return quark ? g_datalist_id_get_data (&amp;object-&gt;qdata, quark) : NULL;
3403 }
3404 
3405 /**
3406  * g_object_set_qdata: (skip)
3407  * @object: The GObject to set store a user data pointer
3408  * @quark: A #GQuark, naming the user data pointer
3409  * @data: (nullable): An opaque user data pointer
3410  *
3411  * This sets an opaque, named pointer on an object.
3412  * The name is specified through a #GQuark (retrived e.g. via
3413  * g_quark_from_static_string()), and the pointer
3414  * can be gotten back from the @object with g_object_get_qdata()
3415  * until the @object is finalized.
3416  * Setting a previously set user data pointer, overrides (frees)
3417  * the old pointer set, using #NULL as pointer essentially
3418  * removes the data stored.
3419  */
3420 void
3421 g_object_set_qdata (GObject *object,
<span class="line-modified">3422             GQuark   quark,</span>
<span class="line-modified">3423             gpointer data)</span>
3424 {
3425   g_return_if_fail (G_IS_OBJECT (object));
3426   g_return_if_fail (quark &gt; 0);
3427 
3428   g_datalist_id_set_data (&amp;object-&gt;qdata, quark, data);
3429 }
3430 
3431 /**
3432  * g_object_dup_qdata: (skip)
3433  * @object: the #GObject to store user data on
3434  * @quark: a #GQuark, naming the user data pointer
3435  * @dup_func: (nullable): function to dup the value
3436  * @user_data: (nullable): passed as user_data to @dup_func
3437  *
3438  * This is a variant of g_object_get_qdata() which returns
3439  * a &#39;duplicate&#39; of the value. @dup_func defines the
3440  * meaning of &#39;duplicate&#39; in this context, it could e.g.
3441  * take a reference on a ref-counted object.
3442  *
3443  * If the @quark is not set on the object then @dup_func
</pre>
<hr />
<pre>
3512                                      oldval, newval, destroy,
3513                                      old_destroy);
3514 }
3515 
3516 /**
3517  * g_object_set_qdata_full: (skip)
3518  * @object: The GObject to set store a user data pointer
3519  * @quark: A #GQuark, naming the user data pointer
3520  * @data: (nullable): An opaque user data pointer
3521  * @destroy: (nullable): Function to invoke with @data as argument, when @data
3522  *           needs to be freed
3523  *
3524  * This function works like g_object_set_qdata(), but in addition,
3525  * a void (*destroy) (gpointer) function may be specified which is
3526  * called with @data as argument when the @object is finalized, or
3527  * the data is being overwritten by a call to g_object_set_qdata()
3528  * with the same @quark.
3529  */
3530 void
3531 g_object_set_qdata_full (GObject       *object,
<span class="line-modified">3532              GQuark     quark,</span>
<span class="line-modified">3533              gpointer   data,</span>
<span class="line-modified">3534                          GDestroyNotify destroy)</span>
3535 {
3536   g_return_if_fail (G_IS_OBJECT (object));
3537   g_return_if_fail (quark &gt; 0);
3538 
3539   g_datalist_id_set_data_full (&amp;object-&gt;qdata, quark, data,
<span class="line-modified">3540                    data ? destroy : (GDestroyNotify) NULL);</span>
3541 }
3542 
3543 /**
3544  * g_object_steal_qdata:
3545  * @object: The GObject to get a stored user data pointer from
3546  * @quark: A #GQuark, naming the user data pointer
3547  *
3548  * This function gets back user data pointers stored via
3549  * g_object_set_qdata() and removes the @data from object
3550  * without invoking its destroy() function (if any was
3551  * set).
3552  * Usually, calling this function is only required to update
3553  * user data pointers with a destroy notifier, for example:
3554  * |[&lt;!-- language=&quot;C&quot; --&gt;
3555  * void
3556  * object_add_to_user_list (GObject     *object,
3557  *                          const gchar *new_string)
3558  * {
3559  *   // the quark, naming the object data
3560  *   GQuark quark_string_list = g_quark_from_static_string (&quot;my-string-list&quot;);
</pre>
<hr />
<pre>
3568  * }
3569  * static void
3570  * free_string_list (gpointer data)
3571  * {
3572  *   GList *node, *list = data;
3573  *
3574  *   for (node = list; node; node = node-&gt;next)
3575  *     g_free (node-&gt;data);
3576  *   g_list_free (list);
3577  * }
3578  * ]|
3579  * Using g_object_get_qdata() in the above example, instead of
3580  * g_object_steal_qdata() would have left the destroy function set,
3581  * and thus the partial string list would have been freed upon
3582  * g_object_set_qdata_full().
3583  *
3584  * Returns: (transfer full) (nullable): The user data pointer set, or %NULL
3585  */
3586 gpointer
3587 g_object_steal_qdata (GObject *object,
<span class="line-modified">3588               GQuark   quark)</span>
3589 {
3590   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
3591   g_return_val_if_fail (quark &gt; 0, NULL);
3592 
3593   return g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark);
3594 }
3595 
3596 /**
3597  * g_object_get_data:
3598  * @object: #GObject containing the associations
3599  * @key: name of the key for that association
3600  *
3601  * Gets a named field from the objects table of associations (see g_object_set_data()).
3602  *
3603  * Returns: (transfer none) (nullable): the data if found,
3604  *          or %NULL if no such data exists.
3605  */
3606 gpointer
3607 g_object_get_data (GObject     *object,
3608                    const gchar *key)
3609 {
3610   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
3611   g_return_val_if_fail (key != NULL, NULL);
3612 
3613   return g_datalist_get_data (&amp;object-&gt;qdata, key);
3614 }
3615 
3616 /**
3617  * g_object_set_data:
3618  * @object: #GObject containing the associations.
3619  * @key: name of the key
3620  * @data: (nullable): data to associate with that key
3621  *
3622  * Each object carries around a table of associations from
3623  * strings to pointers.  This function lets you set an association.
3624  *
3625  * If the object already had an association with that name,
3626  * the old association will be destroyed.





3627  */
3628 void
3629 g_object_set_data (GObject     *object,
3630                    const gchar *key,
3631                    gpointer     data)
3632 {
3633   g_return_if_fail (G_IS_OBJECT (object));
3634   g_return_if_fail (key != NULL);
3635 
3636   g_datalist_id_set_data (&amp;object-&gt;qdata, g_quark_from_string (key), data);
3637 }
3638 
3639 /**
3640  * g_object_dup_data: (skip)
3641  * @object: the #GObject to store user data on
3642  * @key: a string, naming the user data pointer
3643  * @dup_func: (nullable): function to dup the value
3644  * @user_data: (nullable): passed as user_data to @dup_func
3645  *
3646  * This is a variant of g_object_get_data() which returns
</pre>
<hr />
<pre>
3685  * @key: a string, naming the user data pointer
3686  * @oldval: (nullable): the old value to compare against
3687  * @newval: (nullable): the new value
3688  * @destroy: (nullable): a destroy notify for the new value
3689  * @old_destroy: (out) (optional): destroy notify for the existing value
3690  *
3691  * Compares the user data for the key @key on @object with
3692  * @oldval, and if they are the same, replaces @oldval with
3693  * @newval.
3694  *
3695  * This is like a typical atomic compare-and-exchange
3696  * operation, for user data on an object.
3697  *
3698  * If the previous value was replaced then ownership of the
3699  * old value (@oldval) is passed to the caller, including
3700  * the registered destroy notify for it (passed out in @old_destroy).
3701  * It&#39;s up to the caller to free this as needed, which may
3702  * or may not include using @old_destroy as sometimes replacement
3703  * should not destroy the object in the normal way.
3704  *



3705  * Returns: %TRUE if the existing value for @key was replaced
3706  *  by @newval, %FALSE otherwise.
3707  *
3708  * Since: 2.34
3709  */
3710 gboolean
3711 g_object_replace_data (GObject        *object,
3712                        const gchar    *key,
3713                        gpointer        oldval,
3714                        gpointer        newval,
3715                        GDestroyNotify  destroy,
3716                        GDestroyNotify *old_destroy)
3717 {
3718   g_return_val_if_fail (G_IS_OBJECT (object), FALSE);
3719   g_return_val_if_fail (key != NULL, FALSE);
3720 
3721   return g_datalist_id_replace_data (&amp;object-&gt;qdata,
3722                                      g_quark_from_string (key),
3723                                      oldval, newval, destroy,
3724                                      old_destroy);
</pre>
<hr />
<pre>
3730  * @key: name of the key
3731  * @data: (nullable): data to associate with that key
3732  * @destroy: (nullable): function to call when the association is destroyed
3733  *
3734  * Like g_object_set_data() except it adds notification
3735  * for when the association is destroyed, either by setting it
3736  * to a different value or when the object is destroyed.
3737  *
3738  * Note that the @destroy callback is not called if @data is %NULL.
3739  */
3740 void
3741 g_object_set_data_full (GObject       *object,
3742                         const gchar   *key,
3743                         gpointer       data,
3744                         GDestroyNotify destroy)
3745 {
3746   g_return_if_fail (G_IS_OBJECT (object));
3747   g_return_if_fail (key != NULL);
3748 
3749   g_datalist_id_set_data_full (&amp;object-&gt;qdata, g_quark_from_string (key), data,
<span class="line-modified">3750                    data ? destroy : (GDestroyNotify) NULL);</span>
3751 }
3752 
3753 /**
3754  * g_object_steal_data:
3755  * @object: #GObject containing the associations
3756  * @key: name of the key
3757  *
3758  * Remove a specified datum from the object&#39;s data associations,
3759  * without invoking the association&#39;s destroy handler.
3760  *
3761  * Returns: (transfer full) (nullable): the data if found, or %NULL
3762  *          if no such data exists.
3763  */
3764 gpointer
3765 g_object_steal_data (GObject     *object,
3766                      const gchar *key)
3767 {
3768   GQuark quark;
3769 
3770   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
</pre>
<hr />
<pre>
3773   quark = g_quark_try_string (key);
3774 
3775   return quark ? g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark) : NULL;
3776 }
3777 
3778 static void
3779 g_value_object_init (GValue *value)
3780 {
3781   value-&gt;data[0].v_pointer = NULL;
3782 }
3783 
3784 static void
3785 g_value_object_free_value (GValue *value)
3786 {
3787   if (value-&gt;data[0].v_pointer)
3788     g_object_unref (value-&gt;data[0].v_pointer);
3789 }
3790 
3791 static void
3792 g_value_object_copy_value (const GValue *src_value,
<span class="line-modified">3793                GValue   *dest_value)</span>
3794 {
3795   if (src_value-&gt;data[0].v_pointer)
3796     dest_value-&gt;data[0].v_pointer = g_object_ref (src_value-&gt;data[0].v_pointer);
3797   else
3798     dest_value-&gt;data[0].v_pointer = NULL;
3799 }
3800 
3801 static void
3802 g_value_object_transform_value (const GValue *src_value,
<span class="line-modified">3803                 GValue       *dest_value)</span>
3804 {
3805   if (src_value-&gt;data[0].v_pointer &amp;&amp; g_type_is_a (G_OBJECT_TYPE (src_value-&gt;data[0].v_pointer), G_VALUE_TYPE (dest_value)))
3806     dest_value-&gt;data[0].v_pointer = g_object_ref (src_value-&gt;data[0].v_pointer);
3807   else
3808     dest_value-&gt;data[0].v_pointer = NULL;
3809 }
3810 
3811 static gpointer
3812 g_value_object_peek_pointer (const GValue *value)
3813 {
3814   return value-&gt;data[0].v_pointer;
3815 }
3816 
3817 static gchar*
<span class="line-modified">3818 g_value_object_collect_value (GValue      *value,</span>
<span class="line-modified">3819                               guint        n_collect_values,</span>
<span class="line-modified">3820                               GTypeCValue *collect_values,</span>
<span class="line-modified">3821                               guint        collect_flags)</span>
3822 {
3823   if (collect_values[0].v_pointer)
3824     {
3825       GObject *object = collect_values[0].v_pointer;
3826 
3827       if (object-&gt;g_type_instance.g_class == NULL)
<span class="line-modified">3828     return g_strconcat (&quot;invalid unclassed object pointer for value type &#39;&quot;,</span>
<span class="line-modified">3829                 G_VALUE_TYPE_NAME (value),</span>
<span class="line-modified">3830                 &quot;&#39;&quot;,</span>
<span class="line-modified">3831                 NULL);</span>
3832       else if (!g_value_type_compatible (G_OBJECT_TYPE (object), G_VALUE_TYPE (value)))
<span class="line-modified">3833     return g_strconcat (&quot;invalid object type &#39;&quot;,</span>
<span class="line-modified">3834                 G_OBJECT_TYPE_NAME (object),</span>
<span class="line-modified">3835                 &quot;&#39; for value type &#39;&quot;,</span>
<span class="line-modified">3836                 G_VALUE_TYPE_NAME (value),</span>
<span class="line-modified">3837                 &quot;&#39;&quot;,</span>
<span class="line-modified">3838                 NULL);</span>
3839       /* never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types */
3840       value-&gt;data[0].v_pointer = g_object_ref (object);
3841     }
3842   else
3843     value-&gt;data[0].v_pointer = NULL;
3844 
3845   return NULL;
3846 }
3847 
3848 static gchar*
3849 g_value_object_lcopy_value (const GValue *value,
<span class="line-modified">3850                 guint        n_collect_values,</span>
<span class="line-modified">3851                 GTypeCValue *collect_values,</span>
<span class="line-modified">3852                 guint        collect_flags)</span>
3853 {
3854   GObject **object_p = collect_values[0].v_pointer;
3855 
3856   if (!object_p)
3857     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
3858 
3859   if (!value-&gt;data[0].v_pointer)
3860     *object_p = NULL;
3861   else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
3862     *object_p = value-&gt;data[0].v_pointer;
3863   else
3864     *object_p = g_object_ref (value-&gt;data[0].v_pointer);
3865 
3866   return NULL;
3867 }
3868 
3869 /**
3870  * g_value_set_object:
3871  * @value: a valid #GValue of %G_TYPE_OBJECT derived type
3872  * @v_object: (type GObject.Object) (nullable): object value to be set
3873  *
3874  * Set the contents of a %G_TYPE_OBJECT derived #GValue to @v_object.
3875  *
3876  * g_value_set_object() increases the reference count of @v_object
3877  * (the #GValue holds a reference to @v_object).  If you do not wish
3878  * to increase the reference count of the object (i.e. you wish to
3879  * pass your current reference to the #GValue because you no longer
3880  * need it), use g_value_take_object() instead.
3881  *
3882  * It is important that your #GValue holds a reference to @v_object (either its
3883  * own, or one it has taken) to ensure that the object won&#39;t be destroyed while
3884  * the #GValue still exists).
3885  */
3886 void
3887 g_value_set_object (GValue   *value,
<span class="line-modified">3888             gpointer  v_object)</span>
3889 {
3890   GObject *old;
3891 
3892   g_return_if_fail (G_VALUE_HOLDS_OBJECT (value));
3893 
3894   old = value-&gt;data[0].v_pointer;
3895 
3896   if (v_object)
3897     {
3898       g_return_if_fail (G_IS_OBJECT (v_object));
3899       g_return_if_fail (g_value_type_compatible (G_OBJECT_TYPE (v_object), G_VALUE_TYPE (value)));
3900 
3901       value-&gt;data[0].v_pointer = v_object;
3902       g_object_ref (value-&gt;data[0].v_pointer);
3903     }
3904   else
3905     value-&gt;data[0].v_pointer = NULL;
3906 
3907   if (old)
3908     g_object_unref (old);
3909 }
3910 
3911 /**
3912  * g_value_set_object_take_ownership: (skip)
3913  * @value: a valid #GValue of %G_TYPE_OBJECT derived type
3914  * @v_object: (nullable): object value to be set
3915  *
3916  * This is an internal function introduced mainly for C marshallers.
3917  *
3918  * Deprecated: 2.4: Use g_value_take_object() instead.
3919  */
3920 void
3921 g_value_set_object_take_ownership (GValue  *value,
<span class="line-modified">3922                    gpointer v_object)</span>
3923 {
3924   g_value_take_object (value, v_object);
3925 }
3926 
3927 /**
3928  * g_value_take_object: (skip)
3929  * @value: a valid #GValue of %G_TYPE_OBJECT derived type
3930  * @v_object: (nullable): object value to be set
3931  *
3932  * Sets the contents of a %G_TYPE_OBJECT derived #GValue to @v_object
<span class="line-modified">3933  * and takes over the ownership of the callers reference to @v_object;</span>
3934  * the caller doesn&#39;t have to unref it any more (i.e. the reference
3935  * count of the object is not increased).
3936  *
3937  * If you want the #GValue to hold its own reference to @v_object, use
3938  * g_value_set_object() instead.
3939  *
3940  * Since: 2.4
3941  */
3942 void
3943 g_value_take_object (GValue  *value,
<span class="line-modified">3944              gpointer v_object)</span>
3945 {
3946   g_return_if_fail (G_VALUE_HOLDS_OBJECT (value));
3947 
3948   if (value-&gt;data[0].v_pointer)
3949     {
3950       g_object_unref (value-&gt;data[0].v_pointer);
3951       value-&gt;data[0].v_pointer = NULL;
3952     }
3953 
3954   if (v_object)
3955     {
3956       g_return_if_fail (G_IS_OBJECT (v_object));
3957       g_return_if_fail (g_value_type_compatible (G_OBJECT_TYPE (v_object), G_VALUE_TYPE (value)));
3958 
3959       value-&gt;data[0].v_pointer = v_object; /* we take over the reference count */
3960     }
3961 }
3962 
3963 /**
3964  * g_value_get_object:
</pre>
<hr />
<pre>
4000  * @instance: (type GObject.TypeInstance): the instance to connect to.
4001  * @detailed_signal: a string of the form &quot;signal-name::detail&quot;.
4002  * @c_handler: the #GCallback to connect.
4003  * @gobject: (type GObject.Object) (nullable): the object to pass as data
4004  *    to @c_handler.
4005  * @connect_flags: a combination of #GConnectFlags.
4006  *
4007  * This is similar to g_signal_connect_data(), but uses a closure which
4008  * ensures that the @gobject stays alive during the call to @c_handler
4009  * by temporarily adding a reference count to @gobject.
4010  *
4011  * When the @gobject is destroyed the signal handler will be automatically
4012  * disconnected.  Note that this is not currently threadsafe (ie:
4013  * emitting a signal while @gobject is being destroyed in another thread
4014  * is not safe).
4015  *
4016  * Returns: the handler id.
4017  */
4018 gulong
4019 g_signal_connect_object (gpointer      instance,
<span class="line-modified">4020              const gchar  *detailed_signal,</span>
<span class="line-modified">4021              GCallback     c_handler,</span>
<span class="line-modified">4022              gpointer      gobject,</span>
<span class="line-modified">4023              GConnectFlags connect_flags)</span>
4024 {
4025   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
4026   g_return_val_if_fail (detailed_signal != NULL, 0);
4027   g_return_val_if_fail (c_handler != NULL, 0);
4028 
4029   if (gobject)
4030     {
4031       GClosure *closure;
4032 
4033       g_return_val_if_fail (G_IS_OBJECT (gobject), 0);
4034 
4035       closure = ((connect_flags &amp; G_CONNECT_SWAPPED) ? g_cclosure_new_object_swap : g_cclosure_new_object) (c_handler, gobject);
4036 
4037       return g_signal_connect_closure (instance, detailed_signal, closure, connect_flags &amp; G_CONNECT_AFTER);
4038     }
4039   else
4040     return g_signal_connect_data (instance, detailed_signal, c_handler, NULL, NULL, connect_flags);
4041 }
4042 
4043 typedef struct {
</pre>
<hr />
<pre>
4049  * watched closures, e.g.:
4050  * GSList* g_object_list_watched_closures (GObject *object)
4051  * {
4052  *   CArray *carray;
4053  *   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
4054  *   carray = g_object_get_data (object, &quot;GObject-closure-array&quot;);
4055  *   if (carray)
4056  *     {
4057  *       GSList *slist = NULL;
4058  *       guint i;
4059  *       for (i = 0; i &lt; carray-&gt;n_closures; i++)
4060  *         slist = g_slist_prepend (slist, carray-&gt;closures[i]);
4061  *       return slist;
4062  *     }
4063  *   return NULL;
4064  * }
4065  */
4066 
4067 static void
4068 object_remove_closure (gpointer  data,
<span class="line-modified">4069                GClosure *closure)</span>
4070 {
4071   GObject *object = data;
4072   CArray *carray;
4073   guint i;
4074 
4075   G_LOCK (closure_array_mutex);
4076   carray = g_object_get_qdata (object, quark_closure_array);
4077   for (i = 0; i &lt; carray-&gt;n_closures; i++)
4078     if (carray-&gt;closures[i] == closure)
4079       {
<span class="line-modified">4080     carray-&gt;n_closures--;</span>
<span class="line-modified">4081     if (i &lt; carray-&gt;n_closures)</span>
<span class="line-modified">4082       carray-&gt;closures[i] = carray-&gt;closures[carray-&gt;n_closures];</span>
<span class="line-modified">4083     G_UNLOCK (closure_array_mutex);</span>
<span class="line-modified">4084     return;</span>
4085       }
4086   G_UNLOCK (closure_array_mutex);
4087   g_assert_not_reached ();
4088 }
4089 
4090 static void
4091 destroy_closure_array (gpointer data)
4092 {
4093   CArray *carray = data;
4094   GObject *object = carray-&gt;object;
4095   guint i, n = carray-&gt;n_closures;
4096 
4097   for (i = 0; i &lt; n; i++)
4098     {
4099       GClosure *closure = carray-&gt;closures[i];
4100 
4101       /* removing object_remove_closure() upfront is probably faster than
4102        * letting it fiddle with quark_closure_array which is empty anyways
4103        */
4104       g_closure_remove_invalidate_notifier (closure, object, object_remove_closure);
4105       g_closure_invalidate (closure);
4106     }
4107   g_free (carray);
4108 }
4109 
4110 /**
4111  * g_object_watch_closure:
<span class="line-modified">4112  * @object: GObject restricting lifetime of @closure</span>
<span class="line-modified">4113  * @closure: GClosure to watch</span>
4114  *
4115  * This function essentially limits the life time of the @closure to
4116  * the life time of the object. That is, when the object is finalized,
4117  * the @closure is invalidated by calling g_closure_invalidate() on
4118  * it, in order to prevent invocations of the closure with a finalized
4119  * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
4120  * added as marshal guards to the @closure, to ensure that an extra
4121  * reference count is held on @object during invocation of the
4122  * @closure.  Usually, this function will be called on closures that
4123  * use this @object as closure data.
4124  */
4125 void
4126 g_object_watch_closure (GObject  *object,
<span class="line-modified">4127             GClosure *closure)</span>
4128 {
4129   CArray *carray;
4130   guint i;
4131 
4132   g_return_if_fail (G_IS_OBJECT (object));
4133   g_return_if_fail (closure != NULL);
4134   g_return_if_fail (closure-&gt;is_invalid == FALSE);
4135   g_return_if_fail (closure-&gt;in_marshal == FALSE);
<span class="line-modified">4136   g_return_if_fail (object-&gt;ref_count &gt; 0); /* this doesn&#39;t work on finalizing objects */</span>
4137 
4138   g_closure_add_invalidate_notifier (closure, object, object_remove_closure);
4139   g_closure_add_marshal_guards (closure,
<span class="line-modified">4140                 object, (GClosureNotify) g_object_ref,</span>
<span class="line-modified">4141                 object, (GClosureNotify) g_object_unref);</span>
4142   G_LOCK (closure_array_mutex);
4143   carray = g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark_closure_array);
4144   if (!carray)
4145     {
4146       carray = g_renew (CArray, NULL, 1);
4147       carray-&gt;object = object;
4148       carray-&gt;n_closures = 1;
4149       i = 0;
4150     }
4151   else
4152     {
4153       i = carray-&gt;n_closures++;
4154       carray = g_realloc (carray, sizeof (*carray) + sizeof (carray-&gt;closures[0]) * i);
4155     }
4156   carray-&gt;closures[i] = closure;
4157   g_datalist_id_set_data_full (&amp;object-&gt;qdata, quark_closure_array, carray, destroy_closure_array);
4158   G_UNLOCK (closure_array_mutex);
4159 }
4160 
4161 /**
4162  * g_closure_new_object:
4163  * @sizeof_closure: the size of the structure to allocate, must be at least
4164  *  `sizeof (GClosure)`
4165  * @object: a #GObject pointer to store in the @data field of the newly
4166  *  allocated #GClosure
4167  *
4168  * A variant of g_closure_new_simple() which stores @object in the
4169  * @data field of the closure and calls g_object_watch_closure() on
4170  * @object and the created closure. This function is mainly useful
4171  * when implementing new types of closures.
4172  *
4173  * Returns: (transfer full): a newly allocated #GClosure
4174  */
4175 GClosure*
4176 g_closure_new_object (guint    sizeof_closure,
<span class="line-modified">4177               GObject *object)</span>
4178 {
4179   GClosure *closure;
4180 
4181   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
<span class="line-modified">4182   g_return_val_if_fail (object-&gt;ref_count &gt; 0, NULL);     /* this doesn&#39;t work on finalizing objects */</span>
4183 
4184   closure = g_closure_new_simple (sizeof_closure, object);
4185   g_object_watch_closure (object, closure);
4186 
4187   return closure;
4188 }
4189 
4190 /**
4191  * g_cclosure_new_object: (skip)
4192  * @callback_func: the function to invoke
4193  * @object: a #GObject pointer to pass to @callback_func
4194  *
4195  * A variant of g_cclosure_new() which uses @object as @user_data and
4196  * calls g_object_watch_closure() on @object and the created
4197  * closure. This function is useful when you have a callback closely
4198  * associated with a #GObject, and want the callback to no longer run
4199  * after the object is is freed.
4200  *
4201  * Returns: a new #GCClosure
4202  */
4203 GClosure*
4204 g_cclosure_new_object (GCallback callback_func,
<span class="line-modified">4205                GObject  *object)</span>
4206 {
4207   GClosure *closure;
4208 
4209   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
<span class="line-modified">4210   g_return_val_if_fail (object-&gt;ref_count &gt; 0, NULL);     /* this doesn&#39;t work on finalizing objects */</span>
4211   g_return_val_if_fail (callback_func != NULL, NULL);
4212 
4213   closure = g_cclosure_new (callback_func, object, NULL);
4214   g_object_watch_closure (object, closure);
4215 
4216   return closure;
4217 }
4218 
4219 /**
4220  * g_cclosure_new_object_swap: (skip)
4221  * @callback_func: the function to invoke
4222  * @object: a #GObject pointer to pass to @callback_func
4223  *
4224  * A variant of g_cclosure_new_swap() which uses @object as @user_data
4225  * and calls g_object_watch_closure() on @object and the created
4226  * closure. This function is useful when you have a callback closely
4227  * associated with a #GObject, and want the callback to no longer run
4228  * after the object is is freed.
4229  *
4230  * Returns: a new #GCClosure
4231  */
4232 GClosure*
4233 g_cclosure_new_object_swap (GCallback callback_func,
<span class="line-modified">4234                 GObject  *object)</span>
4235 {
4236   GClosure *closure;
4237 
4238   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
<span class="line-modified">4239   g_return_val_if_fail (object-&gt;ref_count &gt; 0, NULL);     /* this doesn&#39;t work on finalizing objects */</span>
4240   g_return_val_if_fail (callback_func != NULL, NULL);
4241 
4242   closure = g_cclosure_new_swap (callback_func, object, NULL);
4243   g_object_watch_closure (object, closure);
4244 
4245   return closure;
4246 }
4247 
4248 gsize
4249 g_object_compat_control (gsize           what,
4250                          gpointer        data)
4251 {
4252   switch (what)
4253     {
4254       gpointer *pp;
4255     case 1:     /* floating base type */
4256       return G_TYPE_INITIALLY_UNOWNED;
4257     case 2:     /* FIXME: remove this once GLib/Gtk+ break ABI again */
4258       floating_flag_handler = (guint(*)(GObject*,gint)) data;
4259       return 1;
</pre>
</td>
<td>
<hr />
<pre>
  36 /**
  37  * SECTION:objects
  38  * @title: GObject
  39  * @short_description: The base object type
  40  * @see_also: #GParamSpecObject, g_param_spec_object()
  41  *
  42  * GObject is the fundamental type providing the common attributes and
  43  * methods for all object types in GTK+, Pango and other libraries
  44  * based on GObject.  The GObject class provides methods for object
  45  * construction and destruction, property access methods, and signal
  46  * support.  Signals are described in detail [here][gobject-Signals].
  47  *
  48  * For a tutorial on implementing a new GObject class, see [How to define and
  49  * implement a new GObject][howto-gobject]. For a list of naming conventions for
  50  * GObjects and their methods, see the [GType conventions][gtype-conventions].
  51  * For the high-level concepts behind GObject, read [Instantiable classed types:
  52  * Objects][gtype-instantiable-classed].
  53  *
  54  * ## Floating references # {#floating-ref}
  55  *
<span class="line-added">  56  * **Note**: Floating references are a C convenience API and should not be</span>
<span class="line-added">  57  * used in modern GObject code. Language bindings in particular find the</span>
<span class="line-added">  58  * concept highly problematic, as floating references are not identifiable</span>
<span class="line-added">  59  * through annotations, and neither are deviations from the floating reference</span>
<span class="line-added">  60  * behavior, like types that inherit from #GInitiallyUnowned and still return</span>
<span class="line-added">  61  * a full reference from g_object_new().</span>
<span class="line-added">  62  *</span>
  63  * GInitiallyUnowned is derived from GObject. The only difference between
  64  * the two is that the initial reference of a GInitiallyUnowned is flagged
  65  * as a &quot;floating&quot; reference. This means that it is not specifically
  66  * claimed to be &quot;owned&quot; by any code portion. The main motivation for
  67  * providing floating references is C convenience. In particular, it
  68  * allows code to be written as:
  69  * |[&lt;!-- language=&quot;C&quot; --&gt;
  70  * container = create_container ();
  71  * container_add_child (container, create_child());
  72  * ]|
  73  * If container_add_child() calls g_object_ref_sink() on the passed-in child,
  74  * no reference of the newly created child is leaked. Without floating
  75  * references, container_add_child() can only g_object_ref() the new child,
  76  * so to implement this code without reference leaks, it would have to be
  77  * written as:
  78  * |[&lt;!-- language=&quot;C&quot; --&gt;
  79  * Child *child;
  80  * container = create_container ();
  81  * child = create_child ();
  82  * container_add_child (container, child);
  83  * g_object_unref (child);
  84  * ]|
  85  * The floating reference can be converted into an ordinary reference by
  86  * calling g_object_ref_sink(). For already sunken objects (objects that
  87  * don&#39;t have a floating reference anymore), g_object_ref_sink() is equivalent
  88  * to g_object_ref() and returns a new reference.
  89  *
  90  * Since floating references are useful almost exclusively for C convenience,
  91  * language bindings that provide automated reference and memory ownership
  92  * maintenance (such as smart pointers or garbage collection) should not
<span class="line-modified">  93  * expose floating references in their API. The best practice for handling</span>
<span class="line-added">  94  * types that have initially floating references is to immediately sink those</span>
<span class="line-added">  95  * references after g_object_new() returns, by checking if the #GType</span>
<span class="line-added">  96  * inherits from #GInitiallyUnowned. For instance:</span>
<span class="line-added">  97  *</span>
<span class="line-added">  98  * |[&lt;!-- language=&quot;C&quot; --&gt;</span>
<span class="line-added">  99  * GObject *res = g_object_new_with_properties (gtype,</span>
<span class="line-added"> 100  *                                              n_props,</span>
<span class="line-added"> 101  *                                              prop_names,</span>
<span class="line-added"> 102  *                                              prop_values);</span>
<span class="line-added"> 103  *</span>
<span class="line-added"> 104  * // or: if (g_type_is_a (gtype, G_TYPE_INITIALLY_UNOWNED))</span>
<span class="line-added"> 105  * if (G_IS_INITIALLY_UNOWNED (res))</span>
<span class="line-added"> 106  *   g_object_ref_sink (res);</span>
<span class="line-added"> 107  *</span>
<span class="line-added"> 108  * return res;</span>
<span class="line-added"> 109  * ]|</span>
 110  *
 111  * Some object implementations may need to save an objects floating state
 112  * across certain code portions (an example is #GtkMenu), to achieve this,
 113  * the following sequence can be used:
 114  *
 115  * |[&lt;!-- language=&quot;C&quot; --&gt;
 116  * // save floating state
 117  * gboolean was_floating = g_object_is_floating (object);
 118  * g_object_ref_sink (object);
 119  * // protected code portion
 120  *
 121  * ...
 122  *
 123  * // restore floating state
 124  * if (was_floating)
 125  *   g_object_force_floating (object);
 126  * else
 127  *   g_object_unref (object); // release previously acquired reference
 128  * ]|
 129  */
 130 
 131 
 132 /* --- macros --- */
<span class="line-modified"> 133 #define PARAM_SPEC_PARAM_ID(pspec)    ((pspec)-&gt;param_id)</span>
 134 #define PARAM_SPEC_SET_PARAM_ID(pspec, id)  ((pspec)-&gt;param_id = (id))
 135 
 136 #define OBJECT_HAS_TOGGLE_REF_FLAG 0x1
 137 #define OBJECT_HAS_TOGGLE_REF(object) \
 138     ((g_datalist_get_flags (&amp;(object)-&gt;qdata) &amp; OBJECT_HAS_TOGGLE_REF_FLAG) != 0)
 139 #define OBJECT_FLOATING_FLAG 0x2
 140 
 141 #define CLASS_HAS_PROPS_FLAG 0x1
 142 #define CLASS_HAS_PROPS(class) \
 143     ((class)-&gt;flags &amp; CLASS_HAS_PROPS_FLAG)
 144 #define CLASS_HAS_CUSTOM_CONSTRUCTOR(class) \
 145     ((class)-&gt;constructor != g_object_constructor)
 146 #define CLASS_HAS_CUSTOM_CONSTRUCTED(class) \
 147     ((class)-&gt;constructed != g_object_constructed)
 148 
 149 #define CLASS_HAS_DERIVED_CLASS_FLAG 0x2
 150 #define CLASS_HAS_DERIVED_CLASS(class) \
 151     ((class)-&gt;flags &amp; CLASS_HAS_DERIVED_CLASS_FLAG)
 152 
 153 /* --- signals --- */
 154 enum {
 155   NOTIFY,
 156   LAST_SIGNAL
 157 };
 158 
 159 
 160 /* --- properties --- */
 161 enum {
 162   PROP_NONE
 163 };
 164 
 165 
 166 /* --- prototypes --- */
<span class="line-modified"> 167 static void g_object_base_class_init    (GObjectClass *class);</span>
<span class="line-modified"> 168 static void g_object_base_class_finalize    (GObjectClass *class);</span>
<span class="line-modified"> 169 static void g_object_do_class_init      (GObjectClass *class);</span>
<span class="line-modified"> 170 static void g_object_init       (GObject  *object,</span>
<span class="line-modified"> 171                GObjectClass *class);</span>
<span class="line-modified"> 172 static GObject* g_object_constructor      (GType                  type,</span>
<span class="line-modified"> 173                guint                  n_construct_properties,</span>
<span class="line-modified"> 174                GObjectConstructParam *construct_params);</span>
 175 static void     g_object_constructed                    (GObject        *object);
<span class="line-modified"> 176 static void g_object_real_dispose     (GObject  *object);</span>
<span class="line-modified"> 177 static void g_object_finalize     (GObject  *object);</span>
<span class="line-modified"> 178 static void g_object_do_set_property    (GObject        *object,</span>
<span class="line-modified"> 179                guint           property_id,</span>
<span class="line-modified"> 180                const GValue   *value,</span>
<span class="line-modified"> 181                GParamSpec     *pspec);</span>
<span class="line-modified"> 182 static void g_object_do_get_property    (GObject        *object,</span>
<span class="line-modified"> 183                guint           property_id,</span>
<span class="line-modified"> 184                GValue         *value,</span>
<span class="line-modified"> 185                GParamSpec     *pspec);</span>
<span class="line-modified"> 186 static void g_value_object_init     (GValue   *value);</span>
<span class="line-modified"> 187 static void g_value_object_free_value   (GValue   *value);</span>
<span class="line-modified"> 188 static void g_value_object_copy_value   (const GValue *src_value,</span>
<span class="line-modified"> 189                GValue   *dest_value);</span>
<span class="line-modified"> 190 static void g_value_object_transform_value    (const GValue *src_value,</span>
<span class="line-modified"> 191                GValue   *dest_value);</span>
 192 static gpointer g_value_object_peek_pointer             (const GValue   *value);
<span class="line-modified"> 193 static gchar* g_value_object_collect_value    (GValue   *value,</span>
<span class="line-modified"> 194                guint           n_collect_values,</span>
<span class="line-modified"> 195                GTypeCValue    *collect_values,</span>
<span class="line-modified"> 196                guint           collect_flags);</span>
<span class="line-modified"> 197 static gchar* g_value_object_lcopy_value    (const GValue *value,</span>
<span class="line-modified"> 198                guint           n_collect_values,</span>
<span class="line-modified"> 199                GTypeCValue    *collect_values,</span>
<span class="line-modified"> 200                guint           collect_flags);</span>
<span class="line-modified"> 201 static void g_object_dispatch_properties_changed  (GObject  *object,</span>
<span class="line-modified"> 202                guint     n_pspecs,</span>
<span class="line-modified"> 203                GParamSpec    **pspecs);</span>
 204 static guint               object_floating_flag_handler (GObject        *object,
 205                                                          gint            job);
 206 
 207 static void object_interface_check_properties           (gpointer        check_data,
<span class="line-modified"> 208                gpointer        g_iface);</span>
 209 
 210 /* --- typedefs --- */
 211 typedef struct _GObjectNotifyQueue            GObjectNotifyQueue;
 212 
 213 struct _GObjectNotifyQueue
 214 {
 215   GSList  *pspecs;
 216   guint16  n_pspecs;
 217   guint16  freeze_count;
 218 };
 219 
 220 /* --- variables --- */
 221 G_LOCK_DEFINE_STATIC (closure_array_mutex);
 222 G_LOCK_DEFINE_STATIC (weak_refs_mutex);
 223 G_LOCK_DEFINE_STATIC (toggle_refs_mutex);
<span class="line-modified"> 224 static GQuark             quark_closure_array = 0;</span>
<span class="line-modified"> 225 static GQuark             quark_weak_refs = 0;</span>
<span class="line-modified"> 226 static GQuark             quark_toggle_refs = 0;</span>
 227 static GQuark               quark_notify_queue;
 228 static GQuark               quark_in_construction;
 229 static GParamSpecPool      *pspec_pool = NULL;
<span class="line-modified"> 230 static gulong             gobject_signals[LAST_SIGNAL] = { 0, };</span>
 231 static guint (*floating_flag_handler) (GObject*, gint) = object_floating_flag_handler;
 232 /* qdata pointing to GSList&lt;GWeakRef *&gt;, protected by weak_locations_lock */
<span class="line-modified"> 233 static GQuark             quark_weak_locations = 0;</span>
 234 static GRWLock              weak_locations_lock;
 235 
 236 G_LOCK_DEFINE_STATIC(notify_lock);
 237 
 238 /* --- functions --- */
 239 static void
 240 g_object_notify_queue_free (gpointer data)
 241 {
 242   GObjectNotifyQueue *nqueue = data;
 243 
 244   g_slist_free (nqueue-&gt;pspecs);
 245   g_slice_free (GObjectNotifyQueue, nqueue);
 246 }
 247 
 248 static GObjectNotifyQueue*
 249 g_object_notify_queue_freeze (GObject  *object,
 250                               gboolean  conditional)
 251 {
 252   GObjectNotifyQueue *nqueue;
 253 
</pre>
<hr />
<pre>
 269   if (nqueue-&gt;freeze_count &gt;= 65535)
 270     g_critical(&quot;Free queue for %s (%p) is larger than 65535,&quot;
 271                &quot; called g_object_freeze_notify() too often.&quot;
 272                &quot; Forgot to call g_object_thaw_notify() or infinite loop&quot;,
 273                G_OBJECT_TYPE_NAME (object), object);
 274   else
 275     nqueue-&gt;freeze_count++;
 276   G_UNLOCK(notify_lock);
 277 
 278   return nqueue;
 279 }
 280 
 281 static void
 282 g_object_notify_queue_thaw (GObject            *object,
 283                             GObjectNotifyQueue *nqueue)
 284 {
 285   GParamSpec *pspecs_mem[16], **pspecs, **free_me = NULL;
 286   GSList *slist;
 287   guint n_pspecs = 0;
 288 

 289   g_return_if_fail (g_atomic_int_get(&amp;object-&gt;ref_count) &gt; 0);
 290 
 291   G_LOCK(notify_lock);
 292 
 293   /* Just make sure we never get into some nasty race condition */
 294   if (G_UNLIKELY(nqueue-&gt;freeze_count == 0)) {
 295     G_UNLOCK(notify_lock);
 296     g_warning (&quot;%s: property-changed notification for %s(%p) is not frozen&quot;,
 297                G_STRFUNC, G_OBJECT_TYPE_NAME (object), object);
 298     return;
 299   }
 300 
 301   nqueue-&gt;freeze_count--;
 302   if (nqueue-&gt;freeze_count) {
 303     G_UNLOCK(notify_lock);
 304     return;
 305   }
 306 
 307   pspecs = nqueue-&gt;n_pspecs &gt; 16 ? free_me = g_new (GParamSpec*, nqueue-&gt;n_pspecs) : pspecs_mem;
 308 
</pre>
<hr />
<pre>
 322 static void
 323 g_object_notify_queue_add (GObject            *object,
 324                            GObjectNotifyQueue *nqueue,
 325                            GParamSpec         *pspec)
 326 {
 327   G_LOCK(notify_lock);
 328 
 329   g_assert (nqueue-&gt;n_pspecs &lt; 65535);
 330 
 331   if (g_slist_find (nqueue-&gt;pspecs, pspec) == NULL)
 332     {
 333       nqueue-&gt;pspecs = g_slist_prepend (nqueue-&gt;pspecs, pspec);
 334       nqueue-&gt;n_pspecs++;
 335     }
 336 
 337   G_UNLOCK(notify_lock);
 338 }
 339 
 340 #ifdef  G_ENABLE_DEBUG
 341 G_LOCK_DEFINE_STATIC     (debug_objects);
<span class="line-modified"> 342 static guint     debug_objects_count = 0;</span>
<span class="line-modified"> 343 static GHashTable *debug_objects_ht = NULL;</span>
 344 
 345 static void
 346 debug_objects_foreach (gpointer key,
<span class="line-modified"> 347            gpointer value,</span>
<span class="line-modified"> 348            gpointer user_data)</span>
 349 {
 350   GObject *object = value;
 351 
 352   g_message (&quot;[%p] stale %s\tref_count=%u&quot;,
<span class="line-modified"> 353        object,</span>
<span class="line-modified"> 354        G_OBJECT_TYPE_NAME (object),</span>
<span class="line-modified"> 355        object-&gt;ref_count);</span>
 356 }
 357 
 358 #ifdef G_HAS_CONSTRUCTORS
 359 #ifdef G_DEFINE_DESTRUCTOR_NEEDS_PRAGMA
 360 #pragma G_DEFINE_DESTRUCTOR_PRAGMA_ARGS(debug_objects_atexit)
 361 #endif
 362 G_DEFINE_DESTRUCTOR(debug_objects_atexit)
 363 #endif /* G_HAS_CONSTRUCTORS */
 364 
 365 static void
 366 debug_objects_atexit (void)
 367 {
 368   GOBJECT_IF_DEBUG (OBJECTS,
 369     {
 370       G_LOCK (debug_objects);
 371       g_message (&quot;stale GObjects: %u&quot;, debug_objects_count);
 372       g_hash_table_foreach (debug_objects_ht, debug_objects_foreach, NULL);
 373       G_UNLOCK (debug_objects);
 374     });
 375 }
 376 #endif  /* G_ENABLE_DEBUG */
 377 
 378 void
 379 _g_object_type_init (void)
 380 {
 381   static gboolean initialized = FALSE;
 382   static const GTypeFundamentalInfo finfo = {
 383     G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE,
 384   };
 385   GTypeInfo info = {
 386     sizeof (GObjectClass),
 387     (GBaseInitFunc) g_object_base_class_init,
 388     (GBaseFinalizeFunc) g_object_base_class_finalize,
 389     (GClassInitFunc) g_object_do_class_init,
<span class="line-modified"> 390     NULL  /* class_destroy */,</span>
<span class="line-modified"> 391     NULL  /* class_data */,</span>
 392     sizeof (GObject),
<span class="line-modified"> 393     0   /* n_preallocs */,</span>
 394     (GInstanceInitFunc) g_object_init,
<span class="line-modified"> 395     NULL, /* value_table */</span>
 396   };
 397   static const GTypeValueTable value_table = {
<span class="line-modified"> 398     g_value_object_init,    /* value_init */</span>
 399     g_value_object_free_value,    /* value_free */
 400     g_value_object_copy_value,    /* value_copy */
 401     g_value_object_peek_pointer,  /* value_peek_pointer */
<span class="line-modified"> 402     &quot;p&quot;,        /* collect_format */</span>
 403     g_value_object_collect_value, /* collect_value */
<span class="line-modified"> 404     &quot;p&quot;,        /* lcopy_format */</span>
 405     g_value_object_lcopy_value,   /* lcopy_value */
 406   };
<span class="line-modified"> 407   GType type G_GNUC_UNUSED  /* when compiling with G_DISABLE_ASSERT */;</span>
 408 
 409   g_return_if_fail (initialized == FALSE);
 410   initialized = TRUE;
 411 
 412   /* G_TYPE_OBJECT
 413    */
 414   info.value_table = &amp;value_table;
 415   type = g_type_register_fundamental (G_TYPE_OBJECT, g_intern_static_string (&quot;GObject&quot;), &amp;info, &amp;finfo, 0);
 416   g_assert (type == G_TYPE_OBJECT);
 417   g_value_register_transform_func (G_TYPE_OBJECT, G_TYPE_OBJECT, g_value_object_transform_value);
 418 
 419 #if G_ENABLE_DEBUG
 420   /* We cannot use GOBJECT_IF_DEBUG here because of the G_HAS_CONSTRUCTORS
 421    * conditional in between, as the C spec leaves conditionals inside macro
 422    * expansions as undefined behavior. Only GCC and Clang are known to work
 423    * but compilation breaks on MSVC.
 424    *
 425    * See: https://bugzilla.gnome.org/show_bug.cgi?id=769504
 426    */
 427   if (_g_type_debug_flags &amp; G_TYPE_DEBUG_OBJECTS) \
</pre>
<hr />
<pre>
 508    * %G_PARAM_EXPLICIT_NOTIFY, then any call to g_object_set_property() results
 509    * in ::notify being emitted, even if the new value is the same as the old.
 510    * If they did pass %G_PARAM_EXPLICIT_NOTIFY, then this signal is emitted only
 511    * when they explicitly call g_object_notify() or g_object_notify_by_pspec(),
 512    * and common practice is to do that only when the value has actually changed.
 513    *
 514    * This signal is typically used to obtain change notification for a
 515    * single property, by specifying the property name as a detail in the
 516    * g_signal_connect() call, like this:
 517    * |[&lt;!-- language=&quot;C&quot; --&gt;
 518    * g_signal_connect (text_view-&gt;buffer, &quot;notify::paste-target-list&quot;,
 519    *                   G_CALLBACK (gtk_text_view_target_list_notify),
 520    *                   text_view)
 521    * ]|
 522    * It is important to note that you must use
 523    * [canonical parameter names][canonical-parameter-names] as
 524    * detail strings for the notify signal.
 525    */
 526   gobject_signals[NOTIFY] =
 527     g_signal_new (g_intern_static_string (&quot;notify&quot;),
<span class="line-modified"> 528       G_TYPE_FROM_CLASS (class),</span>
<span class="line-modified"> 529       G_SIGNAL_RUN_FIRST | G_SIGNAL_NO_RECURSE | G_SIGNAL_DETAILED | G_SIGNAL_NO_HOOKS | G_SIGNAL_ACTION,</span>
<span class="line-modified"> 530       G_STRUCT_OFFSET (GObjectClass, notify),</span>
<span class="line-modified"> 531       NULL, NULL,</span>
<span class="line-modified"> 532       NULL,</span>
<span class="line-modified"> 533       G_TYPE_NONE,</span>
<span class="line-modified"> 534       1, G_TYPE_PARAM);</span>
 535 
 536   /* Install a check function that we&#39;ll use to verify that classes that
 537    * implement an interface implement all properties for that interface
 538    */
 539   g_type_add_interface_check (NULL, object_interface_check_properties);
 540 }
 541 
 542 static inline gboolean
 543 install_property_internal (GType       g_type,
<span class="line-modified"> 544          guint       property_id,</span>
<span class="line-modified"> 545          GParamSpec *pspec)</span>
 546 {
 547   if (g_param_spec_pool_lookup (pspec_pool, pspec-&gt;name, g_type, FALSE))
 548     {
 549       g_warning (&quot;When installing property: type &#39;%s&#39; already has a property named &#39;%s&#39;&quot;,
<span class="line-modified"> 550      g_type_name (g_type),</span>
<span class="line-modified"> 551      pspec-&gt;name);</span>
 552       return FALSE;
 553     }
 554 
 555   g_param_spec_ref_sink (pspec);
 556   PARAM_SPEC_SET_PARAM_ID (pspec, property_id);
 557   g_param_spec_pool_insert (pspec_pool, pspec, g_type);
 558   return TRUE;
 559 }
 560 
 561 static gboolean
 562 validate_pspec_to_install (GParamSpec *pspec)
 563 {
 564   g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), FALSE);
<span class="line-modified"> 565   g_return_val_if_fail (PARAM_SPEC_PARAM_ID (pspec) == 0, FALSE); /* paranoid */</span>
 566 
 567   g_return_val_if_fail (pspec-&gt;flags &amp; (G_PARAM_READABLE | G_PARAM_WRITABLE), FALSE);
 568 
 569   if (pspec-&gt;flags &amp; G_PARAM_CONSTRUCT)
 570     g_return_val_if_fail ((pspec-&gt;flags &amp; G_PARAM_CONSTRUCT_ONLY) == 0, FALSE);
 571 
 572   if (pspec-&gt;flags &amp; (G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY))
 573     g_return_val_if_fail (pspec-&gt;flags &amp; G_PARAM_WRITABLE, FALSE);
 574 
 575   return TRUE;
 576 }
 577 
 578 static gboolean
 579 validate_and_install_class_property (GObjectClass *class,
 580                                      GType         oclass_type,
 581                                      GType         parent_type,
 582                                      guint         property_id,
 583                                      GParamSpec   *pspec)
 584 {
 585   if (!validate_pspec_to_install (pspec))
</pre>
<hr />
<pre>
 611 
 612 /**
 613  * g_object_class_install_property:
 614  * @oclass: a #GObjectClass
 615  * @property_id: the id for the new property
 616  * @pspec: the #GParamSpec for the new property
 617  *
 618  * Installs a new property.
 619  *
 620  * All properties should be installed during the class initializer.  It
 621  * is possible to install properties after that, but doing so is not
 622  * recommend, and specifically, is not guaranteed to be thread-safe vs.
 623  * use of properties on the same type on other threads.
 624  *
 625  * Note that it is possible to redefine a property in a derived class,
 626  * by installing a property with the same name. This can be useful at times,
 627  * e.g. to change the range of allowed values or the default value.
 628  */
 629 void
 630 g_object_class_install_property (GObjectClass *class,
<span class="line-modified"> 631          guint         property_id,</span>
<span class="line-modified"> 632          GParamSpec   *pspec)</span>
 633 {
 634   GType oclass_type, parent_type;
 635 
 636   g_return_if_fail (G_IS_OBJECT_CLASS (class));
 637   g_return_if_fail (property_id &gt; 0);
 638 
 639   oclass_type = G_OBJECT_CLASS_TYPE (class);
 640   parent_type = g_type_parent (oclass_type);
 641 
 642   if (CLASS_HAS_DERIVED_CLASS (class))
 643     g_error (&quot;Attempt to add property %s::%s to class after it was derived&quot;, G_OBJECT_CLASS_NAME (class), pspec-&gt;name);
 644 
 645   (void) validate_and_install_class_property (class,
 646                                               oclass_type,
 647                                               parent_type,
 648                                               property_id,
 649                                               pspec);
 650 }
 651 
 652 /**
</pre>
<hr />
<pre>
 766  * that are added to GObject-derived types. Adding a property to an
 767  * interface forces all objects classes with that interface to have a
 768  * compatible property. The compatible property could be a newly
 769  * created #GParamSpec, but normally
 770  * g_object_class_override_property() will be used so that the object
 771  * class only needs to provide an implementation and inherits the
 772  * property description, default value, bounds, and so forth from the
 773  * interface property.
 774  *
 775  * This function is meant to be called from the interface&#39;s default
 776  * vtable initialization function (the @class_init member of
 777  * #GTypeInfo.) It must not be called after after @class_init has
 778  * been called for any object types implementing this interface.
 779  *
 780  * If @pspec is a floating reference, it will be consumed.
 781  *
 782  * Since: 2.4
 783  */
 784 void
 785 g_object_interface_install_property (gpointer      g_iface,
<span class="line-modified"> 786              GParamSpec   *pspec)</span>
 787 {
 788   GTypeInterface *iface_class = g_iface;
 789 
 790   g_return_if_fail (G_TYPE_IS_INTERFACE (iface_class-&gt;g_type));
 791   g_return_if_fail (!G_IS_PARAM_SPEC_OVERRIDE (pspec)); /* paranoid */
 792 
 793   if (!validate_pspec_to_install (pspec))
 794     return;
 795 
 796   (void) install_property_internal (iface_class-&gt;g_type, 0, pspec);
 797 }
 798 
 799 /**
 800  * g_object_class_find_property:
 801  * @oclass: a #GObjectClass
 802  * @property_name: the name of the property to look up
 803  *
 804  * Looks up the #GParamSpec for a property of a class.
 805  *
 806  * Returns: (transfer none): the #GParamSpec for the property, or
 807  *          %NULL if the class doesn&#39;t have a property of that name
 808  */
 809 GParamSpec*
 810 g_object_class_find_property (GObjectClass *class,
<span class="line-modified"> 811             const gchar  *property_name)</span>
 812 {
 813   GParamSpec *pspec;
 814   GParamSpec *redirect;
 815 
 816   g_return_val_if_fail (G_IS_OBJECT_CLASS (class), NULL);
 817   g_return_val_if_fail (property_name != NULL, NULL);
 818 
 819   pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified"> 820             property_name,</span>
<span class="line-modified"> 821             G_OBJECT_CLASS_TYPE (class),</span>
<span class="line-modified"> 822             TRUE);</span>
 823   if (pspec)
 824     {
 825       redirect = g_param_spec_get_redirect_target (pspec);
 826       if (redirect)
<span class="line-modified"> 827   return redirect;</span>
 828       else
<span class="line-modified"> 829   return pspec;</span>
 830     }
 831   else
 832     return NULL;
 833 }
 834 
 835 /**
 836  * g_object_interface_find_property:
 837  * @g_iface: (type GObject.TypeInterface): any interface vtable for the
 838  *  interface, or the default vtable for the interface
<span class="line-modified"> 839  * @property_name: name of a property to look up.</span>
 840  *
 841  * Find the #GParamSpec with the given name for an
 842  * interface. Generally, the interface vtable passed in as @g_iface
 843  * will be the default vtable from g_type_default_interface_ref(), or,
 844  * if you know the interface has already been loaded,
 845  * g_type_default_interface_peek().
 846  *
 847  * Since: 2.4
 848  *
 849  * Returns: (transfer none): the #GParamSpec for the property of the
 850  *          interface with the name @property_name, or %NULL if no
 851  *          such property exists.
 852  */
 853 GParamSpec*
 854 g_object_interface_find_property (gpointer      g_iface,
<span class="line-modified"> 855           const gchar  *property_name)</span>
 856 {
 857   GTypeInterface *iface_class = g_iface;
 858 
 859   g_return_val_if_fail (G_TYPE_IS_INTERFACE (iface_class-&gt;g_type), NULL);
 860   g_return_val_if_fail (property_name != NULL, NULL);
 861 
 862   return g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified"> 863            property_name,</span>
<span class="line-modified"> 864            iface_class-&gt;g_type,</span>
<span class="line-modified"> 865            FALSE);</span>
 866 }
 867 
 868 /**
 869  * g_object_class_override_property:
 870  * @oclass: a #GObjectClass
 871  * @property_id: the new property ID
 872  * @name: the name of a property registered in a parent class or
 873  *  in an interface of this class.
 874  *
 875  * Registers @property_id as referring to a property with the name
 876  * @name in a parent class or in an interface implemented by @oclass.
 877  * This allows this class to &quot;override&quot; a property implementation in
 878  * a parent class or to provide the implementation of a property from
 879  * an interface.
 880  *
 881  * Internally, overriding is implemented by creating a property of type
 882  * #GParamSpecOverride; generally operations that query the properties of
 883  * the object class, such as g_object_class_find_property() or
 884  * g_object_class_list_properties() will return the overridden
 885  * property. However, in one case, the @construct_properties argument of
 886  * the @constructor virtual function, the #GParamSpecOverride is passed
 887  * instead, so that the @param_id field of the #GParamSpec will be
 888  * correct.  For virtually all uses, this makes no difference. If you
 889  * need to get the overridden property, you can call
 890  * g_param_spec_get_redirect_target().
 891  *
 892  * Since: 2.4
 893  */
 894 void
 895 g_object_class_override_property (GObjectClass *oclass,
<span class="line-modified"> 896           guint         property_id,</span>
<span class="line-modified"> 897           const gchar  *name)</span>
 898 {
 899   GParamSpec *overridden = NULL;
 900   GParamSpec *new;
 901   GType parent_type;
 902 
 903   g_return_if_fail (G_IS_OBJECT_CLASS (oclass));
 904   g_return_if_fail (property_id &gt; 0);
 905   g_return_if_fail (name != NULL);
 906 
 907   /* Find the overridden property; first check parent types
 908    */
 909   parent_type = g_type_parent (G_OBJECT_CLASS_TYPE (oclass));
 910   if (parent_type != G_TYPE_NONE)
 911     overridden = g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified"> 912              name,</span>
<span class="line-modified"> 913              parent_type,</span>
<span class="line-modified"> 914              TRUE);</span>
 915   if (!overridden)
 916     {
 917       GType *ifaces;
 918       guint n_ifaces;
 919 
 920       /* Now check interfaces
 921        */
 922       ifaces = g_type_interfaces (G_OBJECT_CLASS_TYPE (oclass), &amp;n_ifaces);
 923       while (n_ifaces-- &amp;&amp; !overridden)
<span class="line-modified"> 924   {</span>
<span class="line-modified"> 925     overridden = g_param_spec_pool_lookup (pspec_pool,</span>
<span class="line-modified"> 926              name,</span>
<span class="line-modified"> 927              ifaces[n_ifaces],</span>
<span class="line-modified"> 928              FALSE);</span>
<span class="line-modified"> 929   }</span>
 930 
 931       g_free (ifaces);
 932     }
 933 
 934   if (!overridden)
 935     {
 936       g_warning (&quot;%s: Can&#39;t find property to override for &#39;%s::%s&#39;&quot;,
<span class="line-modified"> 937      G_STRFUNC, G_OBJECT_CLASS_NAME (oclass), name);</span>
 938       return;
 939     }
 940 
 941   new = g_param_spec_override (name, overridden);
 942   g_object_class_install_property (oclass, property_id, new);
 943 }
 944 
 945 /**
 946  * g_object_class_list_properties:
 947  * @oclass: a #GObjectClass
 948  * @n_properties: (out): return location for the length of the returned array
 949  *
 950  * Get an array of #GParamSpec* for all properties of a class.
 951  *
 952  * Returns: (array length=n_properties) (transfer container): an array of
 953  *          #GParamSpec* which should be freed after use
 954  */
 955 GParamSpec** /* free result */
 956 g_object_class_list_properties (GObjectClass *class,
<span class="line-modified"> 957         guint        *n_properties_p)</span>
 958 {
 959   GParamSpec **pspecs;
 960   guint n;
 961 
 962   g_return_val_if_fail (G_IS_OBJECT_CLASS (class), NULL);
 963 
 964   pspecs = g_param_spec_pool_list (pspec_pool,
<span class="line-modified"> 965            G_OBJECT_CLASS_TYPE (class),</span>
<span class="line-modified"> 966            &amp;n);</span>
 967   if (n_properties_p)
 968     *n_properties_p = n;
 969 
 970   return pspecs;
 971 }
 972 
 973 /**
 974  * g_object_interface_list_properties:
 975  * @g_iface: (type GObject.TypeInterface): any interface vtable for the
 976  *  interface, or the default vtable for the interface
 977  * @n_properties_p: (out): location to store number of properties returned.
 978  *
 979  * Lists the properties of an interface.Generally, the interface
 980  * vtable passed in as @g_iface will be the default vtable from
 981  * g_type_default_interface_ref(), or, if you know the interface has
 982  * already been loaded, g_type_default_interface_peek().
 983  *
 984  * Since: 2.4
 985  *
 986  * Returns: (array length=n_properties_p) (transfer container): a
 987  *          pointer to an array of pointers to #GParamSpec
 988  *          structures. The paramspecs are owned by GLib, but the
 989  *          array should be freed with g_free() when you are done with
 990  *          it.
 991  */
 992 GParamSpec**
 993 g_object_interface_list_properties (gpointer      g_iface,
<span class="line-modified"> 994             guint        *n_properties_p)</span>
 995 {
 996   GTypeInterface *iface_class = g_iface;
 997   GParamSpec **pspecs;
 998   guint n;
 999 
1000   g_return_val_if_fail (G_TYPE_IS_INTERFACE (iface_class-&gt;g_type), NULL);
1001 
1002   pspecs = g_param_spec_pool_list (pspec_pool,
<span class="line-modified">1003            iface_class-&gt;g_type,</span>
<span class="line-modified">1004            &amp;n);</span>
1005   if (n_properties_p)
1006     *n_properties_p = n;
1007 
1008   return pspecs;
1009 }
1010 
1011 static inline gboolean
1012 object_in_construction (GObject *object)
1013 {
1014   return g_datalist_id_get_data (&amp;object-&gt;qdata, quark_in_construction) != NULL;
1015 }
1016 
1017 static void
<span class="line-modified">1018 g_object_init (GObject    *object,</span>
<span class="line-modified">1019          GObjectClass *class)</span>
1020 {
1021   object-&gt;ref_count = 1;
1022   object-&gt;qdata = NULL;
1023 
1024   if (CLASS_HAS_PROPS (class))
1025     {
1026       /* freeze object&#39;s notification queue, g_object_newv() preserves pairedness */
1027       g_object_notify_queue_freeze (object, FALSE);
1028     }
1029 
1030   if (CLASS_HAS_CUSTOM_CONSTRUCTOR (class))
1031     {
1032       /* mark object in-construction for notify_queue_thaw() and to allow construct-only properties */
1033       g_datalist_id_set_data (&amp;object-&gt;qdata, quark_in_construction, object);
1034     }
1035 
1036   GOBJECT_IF_DEBUG (OBJECTS,
1037     {
1038       G_LOCK (debug_objects);
1039       debug_objects_count++;
1040       g_hash_table_add (debug_objects_ht, object);
1041       G_UNLOCK (debug_objects);
1042     });
1043 }
1044 
1045 static void
1046 g_object_do_set_property (GObject      *object,
<span class="line-modified">1047         guint         property_id,</span>
<span class="line-modified">1048         const GValue *value,</span>
<span class="line-modified">1049         GParamSpec   *pspec)</span>
1050 {
1051   switch (property_id)
1052     {
1053     default:
1054       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
1055       break;
1056     }
1057 }
1058 
1059 static void
1060 g_object_do_get_property (GObject     *object,
<span class="line-modified">1061         guint        property_id,</span>
<span class="line-modified">1062         GValue      *value,</span>
<span class="line-modified">1063         GParamSpec  *pspec)</span>
1064 {
1065   switch (property_id)
1066     {
1067     default:
1068       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
1069       break;
1070     }
1071 }
1072 
1073 static void
1074 g_object_real_dispose (GObject *object)
1075 {
1076   g_signal_handlers_destroy (object);
1077   g_datalist_id_set_data (&amp;object-&gt;qdata, quark_closure_array, NULL);
1078   g_datalist_id_set_data (&amp;object-&gt;qdata, quark_weak_refs, NULL);
1079 }
1080 
1081 static void
1082 g_object_finalize (GObject *object)
1083 {
1084   if (object_in_construction (object))
1085     {
1086       g_critical (&quot;object %s %p finalized while still in-construction&quot;,
1087                   G_OBJECT_TYPE_NAME (object), object);
1088     }
1089 
1090   g_datalist_clear (&amp;object-&gt;qdata);
1091 
1092   GOBJECT_IF_DEBUG (OBJECTS,
1093     {
1094       G_LOCK (debug_objects);
1095       g_assert (g_hash_table_contains (debug_objects_ht, object));
1096       g_hash_table_remove (debug_objects_ht, object);
1097       debug_objects_count--;
1098       G_UNLOCK (debug_objects);
1099     });
1100 }
1101 
1102 static void
1103 g_object_dispatch_properties_changed (GObject     *object,
<span class="line-modified">1104               guint        n_pspecs,</span>
<span class="line-modified">1105               GParamSpec **pspecs)</span>
1106 {
1107   guint i;
1108 
1109   for (i = 0; i &lt; n_pspecs; i++)
1110     g_signal_emit (object, gobject_signals[NOTIFY], g_param_spec_get_name_quark (pspecs[i]), pspecs[i]);
1111 }
1112 
1113 /**
1114  * g_object_run_dispose:
1115  * @object: a #GObject
1116  *
1117  * Releases all references to other objects. This can be used to break
1118  * reference cycles.
1119  *
1120  * This function should only be called from object system implementations.
1121  */
1122 void
1123 g_object_run_dispose (GObject *object)
1124 {
1125   g_return_if_fail (G_IS_OBJECT (object));
<span class="line-modified">1126   g_return_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt; 0);</span>
1127 
1128   g_object_ref (object);
1129   TRACE (GOBJECT_OBJECT_DISPOSE(object,G_TYPE_FROM_INSTANCE(object), 0));
1130   G_OBJECT_GET_CLASS (object)-&gt;dispose (object);
1131   TRACE (GOBJECT_OBJECT_DISPOSE_END(object,G_TYPE_FROM_INSTANCE(object), 0));
1132   g_object_unref (object);
1133 }
1134 
1135 /**
1136  * g_object_freeze_notify:
1137  * @object: a #GObject
1138  *
1139  * Increases the freeze count on @object. If the freeze count is
1140  * non-zero, the emission of &quot;notify&quot; signals on @object is
1141  * stopped. The signals are queued until the freeze count is decreased
1142  * to zero. Duplicate notifications are squashed so that at most one
1143  * #GObject::notify signal is emitted for each property modified while the
1144  * object is frozen.
1145  *
1146  * This is necessary for accessors that modify multiple properties to prevent
</pre>
<hr />
<pre>
1162 static GParamSpec *
1163 get_notify_pspec (GParamSpec *pspec)
1164 {
1165   GParamSpec *redirected;
1166 
1167   /* we don&#39;t notify on non-READABLE parameters */
1168   if (~pspec-&gt;flags &amp; G_PARAM_READABLE)
1169     return NULL;
1170 
1171   /* if the paramspec is redirected, notify on the target */
1172   redirected = g_param_spec_get_redirect_target (pspec);
1173   if (redirected != NULL)
1174     return redirected;
1175 
1176   /* else, notify normally */
1177   return pspec;
1178 }
1179 
1180 static inline void
1181 g_object_notify_by_spec_internal (GObject    *object,
<span class="line-modified">1182           GParamSpec *pspec)</span>
1183 {
1184   GParamSpec *notify_pspec;
1185 
1186   notify_pspec = get_notify_pspec (pspec);
1187 
1188   if (notify_pspec != NULL)
1189     {
1190       GObjectNotifyQueue *nqueue;
1191 
1192       /* conditional freeze: only increase freeze count if already frozen */
1193       nqueue = g_object_notify_queue_freeze (object, TRUE);
1194 
1195       if (nqueue != NULL)
1196         {
1197           /* we&#39;re frozen, so add to the queue and release our freeze */
1198           g_object_notify_queue_add (object, nqueue, notify_pspec);
1199           g_object_notify_queue_thaw (object, nqueue);
1200         }
1201       else
1202         /* not frozen, so just dispatch the notification directly */
</pre>
<hr />
<pre>
1206 }
1207 
1208 /**
1209  * g_object_notify:
1210  * @object: a #GObject
1211  * @property_name: the name of a property installed on the class of @object.
1212  *
1213  * Emits a &quot;notify&quot; signal for the property @property_name on @object.
1214  *
1215  * When possible, eg. when signaling a property change from within the class
1216  * that registered the property, you should use g_object_notify_by_pspec()
1217  * instead.
1218  *
1219  * Note that emission of the notify signal may be blocked with
1220  * g_object_freeze_notify(). In this case, the signal emissions are queued
1221  * and will be emitted (in reverse order) when g_object_thaw_notify() is
1222  * called.
1223  */
1224 void
1225 g_object_notify (GObject     *object,
<span class="line-modified">1226      const gchar *property_name)</span>
1227 {
1228   GParamSpec *pspec;
1229 
1230   g_return_if_fail (G_IS_OBJECT (object));
1231   g_return_if_fail (property_name != NULL);
1232   if (g_atomic_int_get (&amp;object-&gt;ref_count) == 0)
1233     return;
1234 
1235   g_object_ref (object);
1236   /* We don&#39;t need to get the redirect target
1237    * (by, e.g. calling g_object_class_find_property())
1238    * because g_object_notify_queue_add() does that
1239    */
1240   pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified">1241             property_name,</span>
<span class="line-modified">1242             G_OBJECT_TYPE (object),</span>
<span class="line-modified">1243             TRUE);</span>
1244 
1245   if (!pspec)
1246     g_warning (&quot;%s: object class &#39;%s&#39; has no property named &#39;%s&#39;&quot;,
<span class="line-modified">1247          G_STRFUNC,</span>
<span class="line-modified">1248          G_OBJECT_TYPE_NAME (object),</span>
<span class="line-modified">1249          property_name);</span>
1250   else
1251     g_object_notify_by_spec_internal (object, pspec);
1252   g_object_unref (object);
1253 }
1254 
1255 /**
1256  * g_object_notify_by_pspec:
1257  * @object: a #GObject
1258  * @pspec: the #GParamSpec of a property installed on the class of @object.
1259  *
1260  * Emits a &quot;notify&quot; signal for the property specified by @pspec on @object.
1261  *
1262  * This function omits the property name lookup, hence it is faster than
1263  * g_object_notify().
1264  *
1265  * One way to avoid using g_object_notify() from within the
1266  * class that registered the properties, and using g_object_notify_by_pspec()
1267  * instead, is to store the GParamSpec used with
1268  * g_object_class_install_property() inside a static array, e.g.:
1269  *
</pre>
<hr />
<pre>
1283  *     properties[PROP_FOO] = g_param_spec_int (&quot;foo&quot;, &quot;Foo&quot;, &quot;The foo&quot;,
1284  *                                              0, 100,
1285  *                                              50,
1286  *                                              G_PARAM_READWRITE);
1287  *     g_object_class_install_property (gobject_class,
1288  *                                      PROP_FOO,
1289  *                                      properties[PROP_FOO]);
1290  *   }
1291  * ]|
1292  *
1293  * and then notify a change on the &quot;foo&quot; property with:
1294  *
1295  * |[&lt;!-- language=&quot;C&quot; --&gt;
1296  *   g_object_notify_by_pspec (self, properties[PROP_FOO]);
1297  * ]|
1298  *
1299  * Since: 2.26
1300  */
1301 void
1302 g_object_notify_by_pspec (GObject    *object,
<span class="line-modified">1303         GParamSpec *pspec)</span>
1304 {
1305 
1306   g_return_if_fail (G_IS_OBJECT (object));
1307   g_return_if_fail (G_IS_PARAM_SPEC (pspec));
1308 
1309   if (g_atomic_int_get (&amp;object-&gt;ref_count) == 0)
1310     return;
1311 
1312   g_object_ref (object);
1313   g_object_notify_by_spec_internal (object, pspec);
1314   g_object_unref (object);
1315 }
1316 
1317 /**
1318  * g_object_thaw_notify:
1319  * @object: a #GObject
1320  *
1321  * Reverts the effect of a previous call to
1322  * g_object_freeze_notify(). The freeze count is decreased on @object
1323  * and when it reaches zero, queued &quot;notify&quot; signals are emitted.
</pre>
<hr />
<pre>
1384    */
1385   g_mutex_lock (&amp;already_warned_lock);
1386 
1387   if (already_warned_table == NULL)
1388     already_warned_table = g_hash_table_new (NULL, NULL);
1389 
1390   already = g_hash_table_contains (already_warned_table, (gpointer) pspec-&gt;name);
1391   if (!already)
1392     g_hash_table_add (already_warned_table, (gpointer) pspec-&gt;name);
1393 
1394   g_mutex_unlock (&amp;already_warned_lock);
1395 
1396   if (!already)
1397     g_warning (&quot;The property %s:%s is deprecated and shouldn&#39;t be used &quot;
1398                &quot;anymore. It will be removed in a future version.&quot;,
1399                g_type_name (pspec-&gt;owner_type), pspec-&gt;name);
1400 }
1401 
1402 static inline void
1403 object_get_property (GObject     *object,
<span class="line-modified">1404          GParamSpec  *pspec,</span>
<span class="line-modified">1405          GValue      *value)</span>
1406 {
1407   GObjectClass *class = g_type_class_peek (pspec-&gt;owner_type);
1408   guint param_id = PARAM_SPEC_PARAM_ID (pspec);
1409   GParamSpec *redirect;
1410 
1411   if (class == NULL)
1412     {
1413       g_warning (&quot;&#39;%s::%s&#39; is not a valid property name; &#39;%s&#39; is not a GObject subtype&quot;,
1414                  g_type_name (pspec-&gt;owner_type), pspec-&gt;name, g_type_name (pspec-&gt;owner_type));
1415       return;
1416     }
1417 
1418   redirect = g_param_spec_get_redirect_target (pspec);
1419   if (redirect)
1420     pspec = redirect;
1421 
1422   consider_issuing_property_deprecation_warning (pspec);
1423 
1424   class-&gt;get_property (object, param_id, value, pspec);
1425 }
1426 
1427 static inline void
1428 object_set_property (GObject             *object,
<span class="line-modified">1429          GParamSpec          *pspec,</span>
<span class="line-modified">1430          const GValue        *value,</span>
<span class="line-modified">1431          GObjectNotifyQueue  *nqueue)</span>
1432 {
1433   GValue tmp_value = G_VALUE_INIT;
1434   GObjectClass *class = g_type_class_peek (pspec-&gt;owner_type);
1435   guint param_id = PARAM_SPEC_PARAM_ID (pspec);
1436   GParamSpec *redirect;
1437 
1438   if (class == NULL)
1439     {
1440       g_warning (&quot;&#39;%s::%s&#39; is not a valid property name; &#39;%s&#39; is not a GObject subtype&quot;,
1441                  g_type_name (pspec-&gt;owner_type), pspec-&gt;name, g_type_name (pspec-&gt;owner_type));
1442       return;
1443     }
1444 
1445   redirect = g_param_spec_get_redirect_target (pspec);
1446   if (redirect)
1447     pspec = redirect;
1448 
1449   /* provide a copy to work from, convert (if necessary) and validate */
1450   g_value_init (&amp;tmp_value, pspec-&gt;value_type);
1451   if (!g_value_transform (value, &amp;tmp_value))
1452     g_warning (&quot;unable to set property &#39;%s&#39; of type &#39;%s&#39; from value of type &#39;%s&#39;&quot;,
<span class="line-modified">1453          pspec-&gt;name,</span>
<span class="line-modified">1454          g_type_name (pspec-&gt;value_type),</span>
<span class="line-modified">1455          G_VALUE_TYPE_NAME (value));</span>
1456   else if (g_param_value_validate (pspec, &amp;tmp_value) &amp;&amp; !(pspec-&gt;flags &amp; G_PARAM_LAX_VALIDATION))
1457     {
1458       gchar *contents = g_strdup_value_contents (value);
1459 
1460       g_warning (&quot;value \&quot;%s\&quot; of type &#39;%s&#39; is invalid or out of range for property &#39;%s&#39; of type &#39;%s&#39;&quot;,
<span class="line-modified">1461      contents,</span>
<span class="line-modified">1462      G_VALUE_TYPE_NAME (value),</span>
<span class="line-modified">1463      pspec-&gt;name,</span>
<span class="line-modified">1464      g_type_name (pspec-&gt;value_type));</span>
1465       g_free (contents);
1466     }
1467   else
1468     {
1469       class-&gt;set_property (object, param_id, &amp;tmp_value, pspec);
1470 
1471       if (~pspec-&gt;flags &amp; G_PARAM_EXPLICIT_NOTIFY)
1472         {
1473           GParamSpec *notify_pspec;
1474 
1475           notify_pspec = get_notify_pspec (pspec);
1476 
1477           if (notify_pspec != NULL)
1478             g_object_notify_queue_add (object, nqueue, notify_pspec);
1479         }
1480     }
1481   g_value_unset (&amp;tmp_value);
1482 }
1483 
1484 static void
1485 object_interface_check_properties (gpointer check_data,
<span class="line-modified">1486            gpointer g_iface)</span>
1487 {
1488   GTypeInterface *iface_class = g_iface;
1489   GObjectClass *class;
1490   GType iface_type = iface_class-&gt;g_type;
1491   GParamSpec **pspecs;
1492   guint n;
1493 
1494   class = g_type_class_ref (iface_class-&gt;g_instance_type);
1495 
1496   if (class == NULL)
1497     return;
1498 
1499   if (!G_IS_OBJECT_CLASS (class))
1500     goto out;
1501 
1502   pspecs = g_param_spec_pool_list (pspec_pool, iface_type, &amp;n);
1503 
1504   while (n--)
1505     {
1506       GParamSpec *class_pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified">1507                 pspecs[n]-&gt;name,</span>
<span class="line-modified">1508                 G_OBJECT_CLASS_TYPE (class),</span>
<span class="line-modified">1509                 TRUE);</span>
1510 
1511       if (!class_pspec)
<span class="line-modified">1512   {</span>
<span class="line-modified">1513     g_critical (&quot;Object class %s doesn&#39;t implement property &quot;</span>
<span class="line-modified">1514           &quot;&#39;%s&#39; from interface &#39;%s&#39;&quot;,</span>
<span class="line-modified">1515           g_type_name (G_OBJECT_CLASS_TYPE (class)),</span>
<span class="line-modified">1516           pspecs[n]-&gt;name,</span>
<span class="line-modified">1517           g_type_name (iface_type));</span>
<span class="line-modified">1518 </span>
<span class="line-modified">1519     continue;</span>
<span class="line-modified">1520   }</span>
1521 
1522       /* We do a number of checks on the properties of an interface to
1523        * make sure that all classes implementing the interface are
1524        * overriding the properties in a sane way.
1525        *
1526        * We do the checks in order of importance so that we can give
1527        * more useful error messages first.
1528        *
1529        * First, we check that the implementation doesn&#39;t remove the
1530        * basic functionality (readability, writability) advertised by
1531        * the interface.  Next, we check that it doesn&#39;t introduce
1532        * additional restrictions (such as construct-only).  Finally, we
1533        * make sure the types are compatible.
1534        */
1535 
1536 #define SUBSET(a,b,mask) (((a) &amp; ~(b) &amp; (mask)) == 0)
1537       /* If the property on the interface is readable then the
1538        * implementation must be readable.  If the interface is writable
1539        * then the implementation must be writable.
1540        */
</pre>
<hr />
<pre>
1639     return G_TYPE_OBJECT;
1640 }
1641 
1642 /**
1643  * g_object_new: (skip)
1644  * @object_type: the type id of the #GObject subtype to instantiate
1645  * @first_property_name: the name of the first property
1646  * @...: the value of the first property, followed optionally by more
1647  *  name/value pairs, followed by %NULL
1648  *
1649  * Creates a new instance of a #GObject subtype and sets its properties.
1650  *
1651  * Construction parameters (see #G_PARAM_CONSTRUCT, #G_PARAM_CONSTRUCT_ONLY)
1652  * which are not explicitly specified are set to their default values.
1653  *
1654  * Returns: (transfer full) (type GObject.Object): a new instance of
1655  *   @object_type
1656  */
1657 gpointer
1658 g_object_new (GType    object_type,
<span class="line-modified">1659         const gchar *first_property_name,</span>
<span class="line-modified">1660         ...)</span>
1661 {
1662   GObject *object;
1663   va_list var_args;
1664 
1665   /* short circuit for calls supplying no properties */
1666   if (!first_property_name)
1667     return g_object_new_with_properties (object_type, 0, NULL, NULL);
1668 
1669   va_start (var_args, first_property_name);
1670   object = g_object_new_valist (object_type, first_property_name, var_args);
1671   va_end (var_args);
1672 
1673   return object;
1674 }
1675 
1676 static gpointer
1677 g_object_new_with_custom_constructor (GObjectClass          *class,
1678                                       GObjectConstructParam *params,
1679                                       guint                  n_params)
1680 {
</pre>
<hr />
<pre>
1712    * default value from the class, we had better not pass that in
1713    * and risk it being modified, so we create a new one.
1714    * */
1715   for (node = class-&gt;construct_properties; node; node = node-&gt;next)
1716     {
1717       GParamSpec *pspec;
1718       GValue *value;
1719       gint j;
1720 
1721       pspec = node-&gt;data;
1722       value = NULL; /* to silence gcc... */
1723 
1724       for (j = 0; j &lt; n_params; j++)
1725         if (params[j].pspec == pspec)
1726           {
1727             consider_issuing_property_deprecation_warning (pspec);
1728             value = params[j].value;
1729             break;
1730           }
1731 
<span class="line-modified">1732       if (value == NULL)</span>
1733         {
1734           value = &amp;cvalues[cvals_used++];
1735           g_value_init (value, pspec-&gt;value_type);
1736           g_param_value_set_default (pspec, value);
1737         }
1738 
1739       cparams[i].pspec = pspec;
1740       cparams[i].value = value;
1741       i++;
1742     }
1743 
1744   /* construct object from construction parameters */
1745   object = class-&gt;constructor (class-&gt;g_type_class.g_type, n_cparams, cparams);
1746   /* free construction values */
1747   g_free (cparams);
1748   while (cvals_used--)
1749     g_value_unset (&amp;cvalues[cvals_used]);
1750   g_free (cvalues);
1751 
1752   /* There is code in the wild that relies on being able to return NULL
</pre>
<hr />
<pre>
1838        * properties, but they may come from either the class default
1839        * values or the passed-in parameter list.
1840        */
1841       for (node = class-&gt;construct_properties; node; node = node-&gt;next)
1842         {
1843           const GValue *value;
1844           GParamSpec *pspec;
1845           gint j;
1846 
1847           pspec = node-&gt;data;
1848           value = NULL; /* to silence gcc... */
1849 
1850           for (j = 0; j &lt; n_params; j++)
1851             if (params[j].pspec == pspec)
1852               {
1853                 consider_issuing_property_deprecation_warning (pspec);
1854                 value = params[j].value;
1855                 break;
1856               }
1857 
<span class="line-modified">1858           if (value == NULL)</span>
1859             value = g_param_spec_get_default_value (pspec);
1860 
1861           object_set_property (object, pspec, value, nqueue);
1862         }
1863     }
1864 
1865   /* run &#39;constructed&#39; handler if there is a custom one */
1866   if (CLASS_HAS_CUSTOM_CONSTRUCTED (class))
1867     class-&gt;constructed (object);
1868 
1869   if (nqueue)
1870     {
1871       gint i;
1872 
1873       /* Set remaining properties.  The construct properties will
1874        * already have been taken, so set only the non-construct
1875        * ones.
1876        */
1877       for (i = 0; i &lt; n_params; i++)
1878         if (!(params[i].pspec-&gt;flags &amp; (G_PARAM_CONSTRUCT | G_PARAM_CONSTRUCT_ONLY)))
</pre>
<hr />
<pre>
2000   return object;
2001 }
2002 
2003 /**
2004  * g_object_newv:
2005  * @object_type: the type id of the #GObject subtype to instantiate
2006  * @n_parameters: the length of the @parameters array
2007  * @parameters: (array length=n_parameters): an array of #GParameter
2008  *
2009  * Creates a new instance of a #GObject subtype and sets its properties.
2010  *
2011  * Construction parameters (see #G_PARAM_CONSTRUCT, #G_PARAM_CONSTRUCT_ONLY)
2012  * which are not explicitly specified are set to their default values.
2013  *
2014  * Returns: (type GObject.Object) (transfer full): a new instance of
2015  * @object_type
2016  *
2017  * Deprecated: 2.54: Use g_object_new_with_properties() instead.
2018  * deprecated. See #GParameter for more information.
2019  */
<span class="line-added">2020 G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
2021 gpointer
2022 g_object_newv (GType       object_type,
2023                guint       n_parameters,
2024                GParameter *parameters)
2025 {
2026   GObjectClass *class, *unref_class = NULL;
2027   GObject *object;
2028 
2029   g_return_val_if_fail (G_TYPE_IS_OBJECT (object_type), NULL);
2030   g_return_val_if_fail (n_parameters == 0 || parameters != NULL, NULL);
2031 
2032   /* Try to avoid thrashing the ref_count if we don&#39;t need to (since
2033    * it&#39;s a locked operation).
2034    */
2035   class = g_type_class_peek_static (object_type);
2036 
2037   if (!class)
2038     class = unref_class = g_type_class_ref (object_type);
2039 
2040   if (n_parameters)
</pre>
<hr />
<pre>
2052           pspec = g_param_spec_pool_lookup (pspec_pool, parameters[i].name, object_type, TRUE);
2053           if (!g_object_new_is_valid_property (object_type, pspec, parameters[i].name, cparams, j))
2054             continue;
2055 
2056           cparams[j].pspec = pspec;
2057           cparams[j].value = &amp;parameters[i].value;
2058           j++;
2059         }
2060 
2061       object = g_object_new_internal (class, cparams, j);
2062     }
2063   else
2064     /* Fast case: no properties passed in. */
2065     object = g_object_new_internal (class, NULL, 0);
2066 
2067   if (unref_class)
2068     g_type_class_unref (unref_class);
2069 
2070   return object;
2071 }
<span class="line-added">2072 G_GNUC_END_IGNORE_DEPRECATIONS</span>
2073 
2074 /**
2075  * g_object_new_valist: (skip)
2076  * @object_type: the type id of the #GObject subtype to instantiate
2077  * @first_property_name: the name of the first property
2078  * @var_args: the value of the first property, followed optionally by more
2079  *  name/value pairs, followed by %NULL
2080  *
2081  * Creates a new instance of a #GObject subtype and sets its properties.
2082  *
2083  * Construction parameters (see #G_PARAM_CONSTRUCT, #G_PARAM_CONSTRUCT_ONLY)
2084  * which are not explicitly specified are set to their default values.
2085  *
2086  * Returns: a new instance of @object_type
2087  */
2088 GObject*
2089 g_object_new_valist (GType        object_type,
2090                      const gchar *first_property_name,
2091                      va_list      var_args)
2092 {
</pre>
<hr />
<pre>
2152       object = g_object_new_internal (class, params, n_params);
2153 
2154       while (n_params--)
2155         g_value_unset (params[n_params].value);
2156 
2157       if (params != stack_params)
2158         g_free (params);
2159     }
2160   else
2161     /* Fast case: no properties passed in. */
2162     object = g_object_new_internal (class, NULL, 0);
2163 
2164   if (unref_class)
2165     g_type_class_unref (unref_class);
2166 
2167   return object;
2168 }
2169 
2170 static GObject*
2171 g_object_constructor (GType                  type,
<span class="line-modified">2172           guint                  n_construct_properties,</span>
<span class="line-modified">2173           GObjectConstructParam *construct_params)</span>
2174 {
2175   GObject *object;
2176 
2177   /* create object */
2178   object = (GObject*) g_type_create_instance (type);
2179 
2180   /* set construction parameters */
2181   if (n_construct_properties)
2182     {
2183       GObjectNotifyQueue *nqueue = g_object_notify_queue_freeze (object, FALSE);
2184 
2185       /* set construct properties */
2186       while (n_construct_properties--)
<span class="line-modified">2187   {</span>
<span class="line-modified">2188     GValue *value = construct_params-&gt;value;</span>
<span class="line-modified">2189     GParamSpec *pspec = construct_params-&gt;pspec;</span>
2190 
<span class="line-modified">2191     construct_params++;</span>
<span class="line-modified">2192     object_set_property (object, pspec, value, nqueue);</span>
<span class="line-modified">2193   }</span>
2194       g_object_notify_queue_thaw (object, nqueue);
2195       /* the notification queue is still frozen from g_object_init(), so
2196        * we don&#39;t need to handle it here, g_object_newv() takes
2197        * care of that
2198        */
2199     }
2200 
2201   return object;
2202 }
2203 
2204 static void
2205 g_object_constructed (GObject *object)
2206 {
2207   /* empty default impl to allow unconditional upchaining */
2208 }
2209 
2210 static inline gboolean
2211 g_object_set_is_valid_property (GObject         *object,
2212                                 GParamSpec      *pspec,
2213                                 const char      *property_name)
</pre>
<hr />
<pre>
2274         break;
2275 
2276       consider_issuing_property_deprecation_warning (pspec);
2277       object_set_property (object, pspec, &amp;values[i], nqueue);
2278     }
2279 
2280   g_object_notify_queue_thaw (object, nqueue);
2281   g_object_unref (object);
2282 }
2283 
2284 /**
2285  * g_object_set_valist: (skip)
2286  * @object: a #GObject
2287  * @first_property_name: name of the first property to set
2288  * @var_args: value for the first property, followed optionally by more
2289  *  name/value pairs, followed by %NULL
2290  *
2291  * Sets properties on an object.
2292  */
2293 void
<span class="line-modified">2294 g_object_set_valist (GObject   *object,</span>
<span class="line-modified">2295          const gchar *first_property_name,</span>
<span class="line-modified">2296          va_list    var_args)</span>
2297 {
2298   GObjectNotifyQueue *nqueue;
2299   const gchar *name;
2300 
2301   g_return_if_fail (G_IS_OBJECT (object));
2302 
2303   g_object_ref (object);
2304   nqueue = g_object_notify_queue_freeze (object, FALSE);
2305 
2306   name = first_property_name;
2307   while (name)
2308     {
2309       GValue value = G_VALUE_INIT;
2310       GParamSpec *pspec;
2311       gchar *error = NULL;
2312 
2313       pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified">2314           name,</span>
<span class="line-modified">2315           G_OBJECT_TYPE (object),</span>
<span class="line-modified">2316           TRUE);</span>
2317 
2318       if (!g_object_set_is_valid_property (object, pspec, name))
2319         break;
2320 
2321       G_VALUE_COLLECT_INIT (&amp;value, pspec-&gt;value_type, var_args,
<span class="line-modified">2322           0, &amp;error);</span>
2323       if (error)
<span class="line-modified">2324   {</span>
<span class="line-modified">2325     g_warning (&quot;%s: %s&quot;, G_STRFUNC, error);</span>
<span class="line-modified">2326     g_free (error);</span>
2327           g_value_unset (&amp;value);
<span class="line-modified">2328     break;</span>
<span class="line-modified">2329   }</span>
2330 
2331       consider_issuing_property_deprecation_warning (pspec);
2332       object_set_property (object, pspec, &amp;value, nqueue);
2333       g_value_unset (&amp;value);
2334 
2335       name = va_arg (var_args, gchar*);
2336     }
2337 
2338   g_object_notify_queue_thaw (object, nqueue);
2339   g_object_unref (object);
2340 }
2341 
2342 static inline gboolean
2343 g_object_get_is_valid_property (GObject          *object,
2344                                 GParamSpec       *pspec,
2345                                 const char       *property_name)
2346 {
2347   if (G_UNLIKELY (pspec == NULL))
2348     {
2349       g_warning (&quot;%s: object class &#39;%s&#39; has no property named &#39;%s&#39;&quot;,
</pre>
<hr />
<pre>
2377 g_object_getv (GObject      *object,
2378                guint         n_properties,
2379                const gchar  *names[],
2380                GValue        values[])
2381 {
2382   guint i;
2383   GParamSpec *pspec;
2384   GType obj_type;
2385 
2386   g_return_if_fail (G_IS_OBJECT (object));
2387 
2388   if (n_properties == 0)
2389     return;
2390 
2391   g_object_ref (object);
2392 
2393   obj_type = G_OBJECT_TYPE (object);
2394   for (i = 0; i &lt; n_properties; i++)
2395     {
2396       pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified">2397                 names[i],</span>
<span class="line-modified">2398                 obj_type,</span>
<span class="line-modified">2399                 TRUE);</span>
2400       if (!g_object_get_is_valid_property (object, pspec, names[i]))
2401         break;
2402 
2403       memset (&amp;values[i], 0, sizeof (GValue));
2404       g_value_init (&amp;values[i], pspec-&gt;value_type);
2405       object_get_property (object, pspec, &amp;values[i]);
2406     }
2407   g_object_unref (object);
2408 }
2409 
2410 /**
2411  * g_object_get_valist: (skip)
2412  * @object: a #GObject
2413  * @first_property_name: name of the first property to get
2414  * @var_args: return location for the first property, followed optionally by more
2415  *  name/return location pairs, followed by %NULL
2416  *
2417  * Gets properties of an object.
2418  *
2419  * In general, a copy is made of the property contents and the caller
2420  * is responsible for freeing the memory in the appropriate manner for
2421  * the type, for instance by calling g_free() or g_object_unref().
2422  *
2423  * See g_object_get().
2424  */
2425 void
<span class="line-modified">2426 g_object_get_valist (GObject   *object,</span>
<span class="line-modified">2427          const gchar *first_property_name,</span>
<span class="line-modified">2428          va_list    var_args)</span>
2429 {
2430   const gchar *name;
2431 
2432   g_return_if_fail (G_IS_OBJECT (object));
2433 
2434   g_object_ref (object);
2435 
2436   name = first_property_name;
2437 
2438   while (name)
2439     {
2440       GValue value = G_VALUE_INIT;
2441       GParamSpec *pspec;
2442       gchar *error;
2443 
2444       pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified">2445           name,</span>
<span class="line-modified">2446           G_OBJECT_TYPE (object),</span>
<span class="line-modified">2447           TRUE);</span>
2448 
2449       if (!g_object_get_is_valid_property (object, pspec, name))
2450         break;
2451 
2452       g_value_init (&amp;value, pspec-&gt;value_type);
2453 
2454       object_get_property (object, pspec, &amp;value);
2455 
2456       G_VALUE_LCOPY (&amp;value, var_args, 0, &amp;error);
2457       if (error)
<span class="line-modified">2458   {</span>
<span class="line-modified">2459     g_warning (&quot;%s: %s&quot;, G_STRFUNC, error);</span>
<span class="line-modified">2460     g_free (error);</span>
<span class="line-modified">2461     g_value_unset (&amp;value);</span>
<span class="line-modified">2462     break;</span>
<span class="line-modified">2463   }</span>
2464 
2465       g_value_unset (&amp;value);
2466 
2467       name = va_arg (var_args, gchar*);
2468     }
2469 
2470   g_object_unref (object);
2471 }
2472 
2473 /**
2474  * g_object_set: (skip)
2475  * @object: (type GObject.Object): a #GObject
2476  * @first_property_name: name of the first property to set
2477  * @...: value for the first property, followed optionally by more
2478  *  name/value pairs, followed by %NULL
2479  *
2480  * Sets properties on an object.
2481  *
2482  * Note that the &quot;notify&quot; signals are queued and only emitted (in
2483  * reverse order) after all properties have been set. See
2484  * g_object_freeze_notify().
2485  */
2486 void
2487 g_object_set (gpointer     _object,
<span class="line-modified">2488         const gchar *first_property_name,</span>
<span class="line-modified">2489         ...)</span>
2490 {
2491   GObject *object = _object;
2492   va_list var_args;
2493 
2494   g_return_if_fail (G_IS_OBJECT (object));
2495 
2496   va_start (var_args, first_property_name);
2497   g_object_set_valist (object, first_property_name, var_args);
2498   va_end (var_args);
2499 }
2500 
2501 /**
2502  * g_object_get: (skip)
2503  * @object: (type GObject.Object): a #GObject
2504  * @first_property_name: name of the first property to get
2505  * @...: return location for the first property, followed optionally by more
2506  *  name/return location pairs, followed by %NULL
2507  *
2508  * Gets properties of an object.
2509  *
</pre>
<hr />
<pre>
2515  * of three properties: an integer, a string and an object:
2516  * |[&lt;!-- language=&quot;C&quot; --&gt;
2517  *  gint intval;
2518  *  gchar *strval;
2519  *  GObject *objval;
2520  *
2521  *  g_object_get (my_object,
2522  *                &quot;int-property&quot;, &amp;intval,
2523  *                &quot;str-property&quot;, &amp;strval,
2524  *                &quot;obj-property&quot;, &amp;objval,
2525  *                NULL);
2526  *
2527  *  // Do something with intval, strval, objval
2528  *
2529  *  g_free (strval);
2530  *  g_object_unref (objval);
2531  *  ]|
2532  */
2533 void
2534 g_object_get (gpointer     _object,
<span class="line-modified">2535         const gchar *first_property_name,</span>
<span class="line-modified">2536         ...)</span>
2537 {
2538   GObject *object = _object;
2539   va_list var_args;
2540 
2541   g_return_if_fail (G_IS_OBJECT (object));
2542 
2543   va_start (var_args, first_property_name);
2544   g_object_get_valist (object, first_property_name, var_args);
2545   va_end (var_args);
2546 }
2547 
2548 /**
2549  * g_object_set_property:
2550  * @object: a #GObject
2551  * @property_name: the name of the property to set
2552  * @value: the value
2553  *
2554  * Sets a property on an object.
2555  */
2556 void
2557 g_object_set_property (GObject      *object,
<span class="line-modified">2558            const gchar  *property_name,</span>
<span class="line-modified">2559            const GValue *value)</span>
2560 {
2561   g_object_setv (object, 1, &amp;property_name, value);
2562 }
2563 
2564 /**
2565  * g_object_get_property:
2566  * @object: a #GObject
2567  * @property_name: the name of the property to get
2568  * @value: return location for the property value
2569  *
<span class="line-modified">2570  * Gets a property of an object.</span>
<span class="line-modified">2571  *</span>
<span class="line-modified">2572  * The @value can be:</span>
<span class="line-added">2573  *</span>
<span class="line-added">2574  *  - an empty #GValue initialized by %G_VALUE_INIT, which will be</span>
<span class="line-added">2575  *    automatically initialized with the expected type of the property</span>
<span class="line-added">2576  *    (since GLib 2.60)</span>
<span class="line-added">2577  *  - a #GValue initialized with the expected type of the property</span>
<span class="line-added">2578  *  - a #GValue initialized with a type to which the expected type</span>
<span class="line-added">2579  *    of the property can be transformed</span>
2580  *
2581  * In general, a copy is made of the property contents and the caller is
2582  * responsible for freeing the memory by calling g_value_unset().
2583  *
2584  * Note that g_object_get_property() is really intended for language
2585  * bindings, g_object_get() is much more convenient for C programming.
2586  */
2587 void
2588 g_object_get_property (GObject     *object,
<span class="line-modified">2589            const gchar *property_name,</span>
<span class="line-modified">2590            GValue    *value)</span>
2591 {
2592   GParamSpec *pspec;
2593 
2594   g_return_if_fail (G_IS_OBJECT (object));
2595   g_return_if_fail (property_name != NULL);
<span class="line-modified">2596   g_return_if_fail (value != NULL);</span>
2597 
2598   g_object_ref (object);
2599 
2600   pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="line-modified">2601             property_name,</span>
<span class="line-modified">2602             G_OBJECT_TYPE (object),</span>
<span class="line-modified">2603             TRUE);</span>
2604 
2605   if (g_object_get_is_valid_property (object, pspec, property_name))
2606     {
2607       GValue *prop_value, tmp_value = G_VALUE_INIT;
2608 
<span class="line-modified">2609       if (G_VALUE_TYPE (value) == G_TYPE_INVALID)</span>
<span class="line-modified">2610         {</span>
<span class="line-modified">2611           /* zero-initialized value */</span>
<span class="line-modified">2612           g_value_init (value, pspec-&gt;value_type);</span>
<span class="line-modified">2613           prop_value = value;</span>
<span class="line-modified">2614         }</span>
<span class="line-modified">2615       else if (G_VALUE_TYPE (value) == pspec-&gt;value_type)</span>
<span class="line-added">2616         {</span>
<span class="line-added">2617           /* auto-conversion of the callers value type */</span>
<span class="line-added">2618           g_value_reset (value);</span>
<span class="line-added">2619           prop_value = value;</span>
<span class="line-added">2620         }</span>
2621       else if (!g_value_type_transformable (pspec-&gt;value_type, G_VALUE_TYPE (value)))
<span class="line-modified">2622         {</span>
<span class="line-modified">2623           g_warning (&quot;%s: can&#39;t retrieve property &#39;%s&#39; of type &#39;%s&#39; as value of type &#39;%s&#39;&quot;,</span>
<span class="line-modified">2624                      G_STRFUNC, pspec-&gt;name,</span>
<span class="line-modified">2625                      g_type_name (pspec-&gt;value_type),</span>
<span class="line-modified">2626                      G_VALUE_TYPE_NAME (value));</span>
<span class="line-modified">2627           g_object_unref (object);</span>
<span class="line-modified">2628           return;</span>
<span class="line-modified">2629         }</span>
2630       else
<span class="line-modified">2631         {</span>
<span class="line-modified">2632           g_value_init (&amp;tmp_value, pspec-&gt;value_type);</span>
<span class="line-modified">2633           prop_value = &amp;tmp_value;</span>
<span class="line-modified">2634         }</span>
2635       object_get_property (object, pspec, prop_value);
2636       if (prop_value != value)
<span class="line-modified">2637         {</span>
<span class="line-modified">2638           g_value_transform (prop_value, value);</span>
<span class="line-modified">2639           g_value_unset (&amp;tmp_value);</span>
<span class="line-modified">2640         }</span>
2641     }
2642 
2643   g_object_unref (object);
2644 }
2645 
2646 /**
2647  * g_object_connect: (skip)
2648  * @object: (type GObject.Object): a #GObject
2649  * @signal_spec: the spec for the first signal
2650  * @...: #GCallback for the first signal, followed by data for the
2651  *       first signal, followed optionally by more signal
2652  *       spec/callback/data triples, followed by %NULL
2653  *
2654  * A convenience function to connect multiple signals at once.
2655  *
2656  * The signal specs expected by this function have the form
2657  * &quot;modifier::signal_name&quot;, where modifier can be one of the following:
<span class="line-modified">2658  * - signal: equivalent to g_signal_connect_data (..., NULL, 0)</span>
2659  * - object-signal, object_signal: equivalent to g_signal_connect_object (..., 0)
2660  * - swapped-signal, swapped_signal: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED)
2661  * - swapped_object_signal, swapped-object-signal: equivalent to g_signal_connect_object (..., G_CONNECT_SWAPPED)
2662  * - signal_after, signal-after: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_AFTER)
2663  * - object_signal_after, object-signal-after: equivalent to g_signal_connect_object (..., G_CONNECT_AFTER)
2664  * - swapped_signal_after, swapped-signal-after: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED | G_CONNECT_AFTER)
2665  * - swapped_object_signal_after, swapped-object-signal-after: equivalent to g_signal_connect_object (..., G_CONNECT_SWAPPED | G_CONNECT_AFTER)
2666  *
2667  * |[&lt;!-- language=&quot;C&quot; --&gt;
2668  *   menu-&gt;toplevel = g_object_connect (g_object_new (GTK_TYPE_WINDOW,
<span class="line-modified">2669  *               &quot;type&quot;, GTK_WINDOW_POPUP,</span>
<span class="line-modified">2670  *               &quot;child&quot;, menu,</span>
<span class="line-modified">2671  *               NULL),</span>
<span class="line-modified">2672  *             &quot;signal::event&quot;, gtk_menu_window_event, menu,</span>
<span class="line-modified">2673  *             &quot;signal::size_request&quot;, gtk_menu_window_size_request, menu,</span>
<span class="line-modified">2674  *             &quot;signal::destroy&quot;, gtk_widget_destroyed, &amp;menu-&gt;toplevel,</span>
<span class="line-modified">2675  *             NULL);</span>
2676  * ]|
2677  *
2678  * Returns: (transfer none) (type GObject.Object): @object
2679  */
2680 gpointer
2681 g_object_connect (gpointer     _object,
<span class="line-modified">2682       const gchar *signal_spec,</span>
<span class="line-modified">2683       ...)</span>
2684 {
2685   GObject *object = _object;
2686   va_list var_args;
2687 
2688   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
2689   g_return_val_if_fail (object-&gt;ref_count &gt; 0, object);
2690 
2691   va_start (var_args, signal_spec);
2692   while (signal_spec)
2693     {
2694       GCallback callback = va_arg (var_args, GCallback);
2695       gpointer data = va_arg (var_args, gpointer);
2696 
2697       if (strncmp (signal_spec, &quot;signal::&quot;, 8) == 0)
<span class="line-modified">2698   g_signal_connect_data (object, signal_spec + 8,</span>
<span class="line-modified">2699              callback, data, NULL,</span>
<span class="line-modified">2700              0);</span>
2701       else if (strncmp (signal_spec, &quot;object_signal::&quot;, 15) == 0 ||
2702                strncmp (signal_spec, &quot;object-signal::&quot;, 15) == 0)
<span class="line-modified">2703   g_signal_connect_object (object, signal_spec + 15,</span>
<span class="line-modified">2704          callback, data,</span>
<span class="line-modified">2705          0);</span>
2706       else if (strncmp (signal_spec, &quot;swapped_signal::&quot;, 16) == 0 ||
2707                strncmp (signal_spec, &quot;swapped-signal::&quot;, 16) == 0)
<span class="line-modified">2708   g_signal_connect_data (object, signal_spec + 16,</span>
<span class="line-modified">2709              callback, data, NULL,</span>
<span class="line-modified">2710              G_CONNECT_SWAPPED);</span>
2711       else if (strncmp (signal_spec, &quot;swapped_object_signal::&quot;, 23) == 0 ||
2712                strncmp (signal_spec, &quot;swapped-object-signal::&quot;, 23) == 0)
<span class="line-modified">2713   g_signal_connect_object (object, signal_spec + 23,</span>
<span class="line-modified">2714          callback, data,</span>
<span class="line-modified">2715          G_CONNECT_SWAPPED);</span>
2716       else if (strncmp (signal_spec, &quot;signal_after::&quot;, 14) == 0 ||
2717                strncmp (signal_spec, &quot;signal-after::&quot;, 14) == 0)
<span class="line-modified">2718   g_signal_connect_data (object, signal_spec + 14,</span>
<span class="line-modified">2719              callback, data, NULL,</span>
<span class="line-modified">2720              G_CONNECT_AFTER);</span>
2721       else if (strncmp (signal_spec, &quot;object_signal_after::&quot;, 21) == 0 ||
2722                strncmp (signal_spec, &quot;object-signal-after::&quot;, 21) == 0)
<span class="line-modified">2723   g_signal_connect_object (object, signal_spec + 21,</span>
<span class="line-modified">2724          callback, data,</span>
<span class="line-modified">2725          G_CONNECT_AFTER);</span>
2726       else if (strncmp (signal_spec, &quot;swapped_signal_after::&quot;, 22) == 0 ||
2727                strncmp (signal_spec, &quot;swapped-signal-after::&quot;, 22) == 0)
<span class="line-modified">2728   g_signal_connect_data (object, signal_spec + 22,</span>
<span class="line-modified">2729              callback, data, NULL,</span>
<span class="line-modified">2730              G_CONNECT_SWAPPED | G_CONNECT_AFTER);</span>
2731       else if (strncmp (signal_spec, &quot;swapped_object_signal_after::&quot;, 29) == 0 ||
2732                strncmp (signal_spec, &quot;swapped-object-signal-after::&quot;, 29) == 0)
<span class="line-modified">2733   g_signal_connect_object (object, signal_spec + 29,</span>
<span class="line-modified">2734          callback, data,</span>
<span class="line-modified">2735          G_CONNECT_SWAPPED | G_CONNECT_AFTER);</span>
2736       else
<span class="line-modified">2737   {</span>
<span class="line-modified">2738     g_warning (&quot;%s: invalid signal spec \&quot;%s\&quot;&quot;, G_STRFUNC, signal_spec);</span>
<span class="line-modified">2739     break;</span>
<span class="line-modified">2740   }</span>
2741       signal_spec = va_arg (var_args, gchar*);
2742     }
2743   va_end (var_args);
2744 
2745   return object;
2746 }
2747 
2748 /**
2749  * g_object_disconnect: (skip)
2750  * @object: (type GObject.Object): a #GObject
2751  * @signal_spec: the spec for the first signal
2752  * @...: #GCallback for the first signal, followed by data for the first signal,
2753  *  followed optionally by more signal spec/callback/data triples,
2754  *  followed by %NULL
2755  *
2756  * A convenience function to disconnect multiple signals at once.
2757  *
2758  * The signal specs expected by this function have the form
2759  * &quot;any_signal&quot;, which means to disconnect any signal with matching
2760  * callback and data, or &quot;any_signal::signal_name&quot;, which only
2761  * disconnects the signal named &quot;signal_name&quot;.
2762  */
2763 void
2764 g_object_disconnect (gpointer     _object,
<span class="line-modified">2765          const gchar *signal_spec,</span>
<span class="line-modified">2766          ...)</span>
2767 {
2768   GObject *object = _object;
2769   va_list var_args;
2770 
2771   g_return_if_fail (G_IS_OBJECT (object));
2772   g_return_if_fail (object-&gt;ref_count &gt; 0);
2773 
2774   va_start (var_args, signal_spec);
2775   while (signal_spec)
2776     {
2777       GCallback callback = va_arg (var_args, GCallback);
2778       gpointer data = va_arg (var_args, gpointer);
2779       guint sid = 0, detail = 0, mask = 0;
2780 
2781       if (strncmp (signal_spec, &quot;any_signal::&quot;, 12) == 0 ||
2782           strncmp (signal_spec, &quot;any-signal::&quot;, 12) == 0)
<span class="line-modified">2783   {</span>
<span class="line-modified">2784     signal_spec += 12;</span>
<span class="line-modified">2785     mask = G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA;</span>
<span class="line-modified">2786   }</span>
2787       else if (strcmp (signal_spec, &quot;any_signal&quot;) == 0 ||
2788                strcmp (signal_spec, &quot;any-signal&quot;) == 0)
<span class="line-modified">2789   {</span>
<span class="line-modified">2790     signal_spec += 10;</span>
<span class="line-modified">2791     mask = G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA;</span>
<span class="line-modified">2792   }</span>
2793       else
<span class="line-modified">2794   {</span>
<span class="line-modified">2795     g_warning (&quot;%s: invalid signal spec \&quot;%s\&quot;&quot;, G_STRFUNC, signal_spec);</span>
<span class="line-modified">2796     break;</span>
<span class="line-modified">2797   }</span>
2798 
2799       if ((mask &amp; G_SIGNAL_MATCH_ID) &amp;&amp;
<span class="line-modified">2800     !g_signal_parse_name (signal_spec, G_OBJECT_TYPE (object), &amp;sid, &amp;detail, FALSE))</span>
<span class="line-modified">2801   g_warning (&quot;%s: invalid signal name \&quot;%s\&quot;&quot;, G_STRFUNC, signal_spec);</span>
2802       else if (!g_signal_handlers_disconnect_matched (object, mask | (detail ? G_SIGNAL_MATCH_DETAIL : 0),
<span class="line-modified">2803                   sid, detail,</span>
<span class="line-modified">2804                   NULL, (gpointer)callback, data))</span>
<span class="line-modified">2805   g_warning (&quot;%s: signal handler %p(%p) is not connected&quot;, G_STRFUNC, callback, data);</span>
2806       signal_spec = va_arg (var_args, gchar*);
2807     }
2808   va_end (var_args);
2809 }
2810 
2811 typedef struct {
2812   GObject *object;
2813   guint n_weak_refs;
2814   struct {
2815     GWeakNotify notify;
2816     gpointer    data;
2817   } weak_refs[1];  /* flexible array */
2818 } WeakRefStack;
2819 
2820 static void
2821 weak_refs_notify (gpointer data)
2822 {
2823   WeakRefStack *wstack = data;
2824   guint i;
2825 
</pre>
<hr />
<pre>
2830 
2831 /**
2832  * g_object_weak_ref: (skip)
2833  * @object: #GObject to reference weakly
2834  * @notify: callback to invoke before the object is freed
2835  * @data: extra data to pass to notify
2836  *
2837  * Adds a weak reference callback to an object. Weak references are
2838  * used for notification when an object is finalized. They are called
2839  * &quot;weak references&quot; because they allow you to safely hold a pointer
2840  * to an object without calling g_object_ref() (g_object_ref() adds a
2841  * strong reference, that is, forces the object to stay alive).
2842  *
2843  * Note that the weak references created by this method are not
2844  * thread-safe: they cannot safely be used in one thread if the
2845  * object&#39;s last g_object_unref() might happen in another thread.
2846  * Use #GWeakRef if thread-safety is required.
2847  */
2848 void
2849 g_object_weak_ref (GObject    *object,
<span class="line-modified">2850        GWeakNotify notify,</span>
<span class="line-modified">2851        gpointer    data)</span>
2852 {
2853   WeakRefStack *wstack;
2854   guint i;
2855 
2856   g_return_if_fail (G_IS_OBJECT (object));
2857   g_return_if_fail (notify != NULL);
<span class="line-modified">2858   g_return_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt;= 1);</span>
2859 
2860   G_LOCK (weak_refs_mutex);
2861   wstack = g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark_weak_refs);
2862   if (wstack)
2863     {
2864       i = wstack-&gt;n_weak_refs++;
2865       wstack = g_realloc (wstack, sizeof (*wstack) + sizeof (wstack-&gt;weak_refs[0]) * i);
2866     }
2867   else
2868     {
2869       wstack = g_renew (WeakRefStack, NULL, 1);
2870       wstack-&gt;object = object;
2871       wstack-&gt;n_weak_refs = 1;
2872       i = 0;
2873     }
2874   wstack-&gt;weak_refs[i].notify = notify;
2875   wstack-&gt;weak_refs[i].data = data;
2876   g_datalist_id_set_data_full (&amp;object-&gt;qdata, quark_weak_refs, wstack, weak_refs_notify);
2877   G_UNLOCK (weak_refs_mutex);
2878 }
2879 
2880 /**
2881  * g_object_weak_unref: (skip)
2882  * @object: #GObject to remove a weak reference from
2883  * @notify: callback to search for
2884  * @data: data to search for
2885  *
2886  * Removes a weak reference callback to an object.
2887  */
2888 void
2889 g_object_weak_unref (GObject    *object,
<span class="line-modified">2890          GWeakNotify notify,</span>
<span class="line-modified">2891          gpointer    data)</span>
2892 {
2893   WeakRefStack *wstack;
2894   gboolean found_one = FALSE;
2895 
2896   g_return_if_fail (G_IS_OBJECT (object));
2897   g_return_if_fail (notify != NULL);
2898 
2899   G_LOCK (weak_refs_mutex);
2900   wstack = g_datalist_id_get_data (&amp;object-&gt;qdata, quark_weak_refs);
2901   if (wstack)
2902     {
2903       guint i;
2904 
2905       for (i = 0; i &lt; wstack-&gt;n_weak_refs; i++)
<span class="line-modified">2906   if (wstack-&gt;weak_refs[i].notify == notify &amp;&amp;</span>
<span class="line-modified">2907       wstack-&gt;weak_refs[i].data == data)</span>
<span class="line-modified">2908     {</span>
<span class="line-modified">2909       found_one = TRUE;</span>
<span class="line-modified">2910       wstack-&gt;n_weak_refs -= 1;</span>
<span class="line-modified">2911       if (i != wstack-&gt;n_weak_refs)</span>
<span class="line-modified">2912         wstack-&gt;weak_refs[i] = wstack-&gt;weak_refs[wstack-&gt;n_weak_refs];</span>
2913 
<span class="line-modified">2914       break;</span>
<span class="line-modified">2915     }</span>
2916     }
2917   G_UNLOCK (weak_refs_mutex);
2918   if (!found_one)
2919     g_warning (&quot;%s: couldn&#39;t find weak ref %p(%p)&quot;, G_STRFUNC, notify, data);
2920 }
2921 
2922 /**
2923  * g_object_add_weak_pointer: (skip)
2924  * @object: The object that should be weak referenced.
2925  * @weak_pointer_location: (inout) (not optional): The memory address
2926  *    of a pointer.
2927  *
2928  * Adds a weak reference from weak_pointer to @object to indicate that
2929  * the pointer located at @weak_pointer_location is only valid during
2930  * the lifetime of @object. When the @object is finalized,
2931  * @weak_pointer will be set to %NULL.
2932  *
2933  * Note that as with g_object_weak_ref(), the weak references created by
2934  * this method are not thread-safe: they cannot safely be used in one
2935  * thread if the object&#39;s last g_object_unref() might happen in another
</pre>
<hr />
<pre>
3020  *
3021  * In other words, if the object is floating, then this call &quot;assumes
3022  * ownership&quot; of the floating reference, converting it to a normal
3023  * reference by clearing the floating flag while leaving the reference
3024  * count unchanged.  If the object is not floating, then this call
3025  * adds a new normal reference increasing the reference count by one.
3026  *
3027  * Since GLib 2.56, the type of @object will be propagated to the return type
3028  * under the same conditions as for g_object_ref().
3029  *
3030  * Since: 2.10
3031  *
3032  * Returns: (type GObject.Object) (transfer none): @object
3033  */
3034 gpointer
3035 (g_object_ref_sink) (gpointer _object)
3036 {
3037   GObject *object = _object;
3038   gboolean was_floating;
3039   g_return_val_if_fail (G_IS_OBJECT (object), object);
<span class="line-modified">3040   g_return_val_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt;= 1, object);</span>
3041   g_object_ref (object);
3042   was_floating = floating_flag_handler (object, -1);
3043   if (was_floating)
3044     g_object_unref (object);
3045   return object;
3046 }
3047 
3048 /**
3049  * g_object_force_floating:
3050  * @object: a #GObject
3051  *
3052  * This function is intended for #GObject implementations to re-enforce
3053  * a [floating][floating-ref] object reference. Doing this is seldom
3054  * required: all #GInitiallyUnowneds are created with a floating reference
3055  * which usually just needs to be sunken by calling g_object_ref_sink().
3056  *
3057  * Since: 2.10
3058  */
3059 void
3060 g_object_force_floating (GObject *object)
3061 {
3062   g_return_if_fail (G_IS_OBJECT (object));
<span class="line-modified">3063   g_return_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt;= 1);</span>
3064 
3065   floating_flag_handler (object, +1);
3066 }
3067 
3068 typedef struct {
3069   GObject *object;
3070   guint n_toggle_refs;
3071   struct {
3072     GToggleNotify notify;
3073     gpointer    data;
3074   } toggle_refs[1];  /* flexible array */
3075 } ToggleRefStack;
3076 
3077 static void
3078 toggle_refs_notify (GObject *object,
<span class="line-modified">3079         gboolean is_last_ref)</span>
3080 {
3081   ToggleRefStack tstack, *tstackptr;
3082 
3083   G_LOCK (toggle_refs_mutex);
3084   tstackptr = g_datalist_id_get_data (&amp;object-&gt;qdata, quark_toggle_refs);
3085   tstack = *tstackptr;
3086   G_UNLOCK (toggle_refs_mutex);
3087 
3088   /* Reentrancy here is not as tricky as it seems, because a toggle reference
3089    * will only be notified when there is exactly one of them.
3090    */
3091   g_assert (tstack.n_toggle_refs == 1);
3092   tstack.toggle_refs[0].notify (tstack.toggle_refs[0].data, tstack.object, is_last_ref);
3093 }
3094 
3095 /**
3096  * g_object_add_toggle_ref: (skip)
3097  * @object: a #GObject
3098  * @notify: a function to call when this reference is the
3099  *  last reference to the object, or is no longer
</pre>
<hr />
<pre>
3116  * to the proxy object, but when there are other references held to
3117  * @object, a strong reference is held. The @notify callback is called
3118  * when the reference from @object to the proxy object should be
3119  * &quot;toggled&quot; from strong to weak (@is_last_ref true) or weak to strong
3120  * (@is_last_ref false).
3121  *
3122  * Since a (normal) reference must be held to the object before
3123  * calling g_object_add_toggle_ref(), the initial state of the reverse
3124  * link is always strong.
3125  *
3126  * Multiple toggle references may be added to the same gobject,
3127  * however if there are multiple toggle references to an object, none
3128  * of them will ever be notified until all but one are removed.  For
3129  * this reason, you should only ever use a toggle reference if there
3130  * is important state in the proxy object.
3131  *
3132  * Since: 2.8
3133  */
3134 void
3135 g_object_add_toggle_ref (GObject       *object,
<span class="line-modified">3136        GToggleNotify  notify,</span>
<span class="line-modified">3137        gpointer       data)</span>
3138 {
3139   ToggleRefStack *tstack;
3140   guint i;
3141 
3142   g_return_if_fail (G_IS_OBJECT (object));
3143   g_return_if_fail (notify != NULL);
<span class="line-modified">3144   g_return_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt;= 1);</span>
3145 
3146   g_object_ref (object);
3147 
3148   G_LOCK (toggle_refs_mutex);
3149   tstack = g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark_toggle_refs);
3150   if (tstack)
3151     {
3152       i = tstack-&gt;n_toggle_refs++;
3153       /* allocate i = tstate-&gt;n_toggle_refs - 1 positions beyond the 1 declared
3154        * in tstate-&gt;toggle_refs */
3155       tstack = g_realloc (tstack, sizeof (*tstack) + sizeof (tstack-&gt;toggle_refs[0]) * i);
3156     }
3157   else
3158     {
3159       tstack = g_renew (ToggleRefStack, NULL, 1);
3160       tstack-&gt;object = object;
3161       tstack-&gt;n_toggle_refs = 1;
3162       i = 0;
3163     }
3164 
3165   /* Set a flag for fast lookup after adding the first toggle reference */
3166   if (tstack-&gt;n_toggle_refs == 1)
3167     g_datalist_set_flags (&amp;object-&gt;qdata, OBJECT_HAS_TOGGLE_REF_FLAG);
3168 
3169   tstack-&gt;toggle_refs[i].notify = notify;
3170   tstack-&gt;toggle_refs[i].data = data;
3171   g_datalist_id_set_data_full (&amp;object-&gt;qdata, quark_toggle_refs, tstack,
<span class="line-modified">3172              (GDestroyNotify)g_free);</span>
3173   G_UNLOCK (toggle_refs_mutex);
3174 }
3175 
3176 /**
3177  * g_object_remove_toggle_ref: (skip)
3178  * @object: a #GObject
3179  * @notify: a function to call when this reference is the
3180  *  last reference to the object, or is no longer
3181  *  the last reference.
3182  * @data: data to pass to @notify
3183  *
3184  * Removes a reference added with g_object_add_toggle_ref(). The
3185  * reference count of the object is decreased by one.
3186  *
3187  * Since: 2.8
3188  */
3189 void
3190 g_object_remove_toggle_ref (GObject       *object,
<span class="line-modified">3191           GToggleNotify  notify,</span>
<span class="line-modified">3192           gpointer       data)</span>
3193 {
3194   ToggleRefStack *tstack;
3195   gboolean found_one = FALSE;
3196 
3197   g_return_if_fail (G_IS_OBJECT (object));
3198   g_return_if_fail (notify != NULL);
3199 
3200   G_LOCK (toggle_refs_mutex);
3201   tstack = g_datalist_id_get_data (&amp;object-&gt;qdata, quark_toggle_refs);
3202   if (tstack)
3203     {
3204       guint i;
3205 
3206       for (i = 0; i &lt; tstack-&gt;n_toggle_refs; i++)
<span class="line-modified">3207   if (tstack-&gt;toggle_refs[i].notify == notify &amp;&amp;</span>
<span class="line-modified">3208       tstack-&gt;toggle_refs[i].data == data)</span>
<span class="line-modified">3209     {</span>
<span class="line-modified">3210       found_one = TRUE;</span>
<span class="line-modified">3211       tstack-&gt;n_toggle_refs -= 1;</span>
<span class="line-modified">3212       if (i != tstack-&gt;n_toggle_refs)</span>
<span class="line-modified">3213         tstack-&gt;toggle_refs[i] = tstack-&gt;toggle_refs[tstack-&gt;n_toggle_refs];</span>
3214 
<span class="line-modified">3215       if (tstack-&gt;n_toggle_refs == 0)</span>
<span class="line-modified">3216         g_datalist_unset_flags (&amp;object-&gt;qdata, OBJECT_HAS_TOGGLE_REF_FLAG);</span>
3217 
<span class="line-modified">3218       break;</span>
<span class="line-modified">3219     }</span>
3220     }
3221   G_UNLOCK (toggle_refs_mutex);
3222 
3223   if (found_one)
3224     g_object_unref (object);
3225   else
3226     g_warning (&quot;%s: couldn&#39;t find toggle ref %p(%p)&quot;, G_STRFUNC, notify, data);
3227 }
3228 
3229 /**
3230  * g_object_ref:
3231  * @object: (type GObject.Object): a #GObject
3232  *
3233  * Increases the reference count of @object.
3234  *
3235  * Since GLib 2.56, if `GLIB_VERSION_MAX_ALLOWED` is 2.56 or greater, the type
3236  * of @object will be propagated to the return type (using the GCC typeof()
3237  * extension), so any casting the caller needs to do on the return type must be
3238  * explicit.
3239  *
3240  * Returns: (type GObject.Object) (transfer none): the same @object
3241  */
3242 gpointer
3243 (g_object_ref) (gpointer _object)
3244 {
3245   GObject *object = _object;
3246   gint old_val;
3247 
3248   g_return_val_if_fail (G_IS_OBJECT (object), NULL);

3249 
3250   old_val = g_atomic_int_add (&amp;object-&gt;ref_count, 1);
<span class="line-added">3251   g_return_val_if_fail (old_val &gt; 0, NULL);</span>
3252 
3253   if (old_val == 1 &amp;&amp; OBJECT_HAS_TOGGLE_REF (object))
3254     toggle_refs_notify (object, FALSE);
3255 
3256   TRACE (GOBJECT_OBJECT_REF(object,G_TYPE_FROM_INSTANCE(object),old_val));
3257 
3258   return object;
3259 }
3260 
3261 /**
3262  * g_object_unref:
3263  * @object: (type GObject.Object): a #GObject
3264  *
3265  * Decreases the reference count of @object. When its reference count
3266  * drops to 0, the object is finalized (i.e. its memory is freed).
3267  *
3268  * If the pointer to the #GObject may be reused in future (for example, if it is
3269  * an instance variable of another object), it is recommended to clear the
3270  * pointer to %NULL rather than retain a dangling pointer to a potentially
3271  * invalid #GObject instance. Use g_clear_object() for this.
3272  */
3273 void
3274 g_object_unref (gpointer _object)
3275 {
3276   GObject *object = _object;
3277   gint old_ref;
3278 
3279   g_return_if_fail (G_IS_OBJECT (object));

3280 
3281   /* here we want to atomically do: if (ref_count&gt;1) { ref_count--; return; } */
3282  retry_atomic_decrement1:
3283   old_ref = g_atomic_int_get (&amp;object-&gt;ref_count);
3284   if (old_ref &gt; 1)
3285     {
3286       /* valid if last 2 refs are owned by this call to unref and the toggle_ref */
3287       gboolean has_toggle_ref = OBJECT_HAS_TOGGLE_REF (object);
3288 
3289       if (!g_atomic_int_compare_and_exchange ((int *)&amp;object-&gt;ref_count, old_ref, old_ref - 1))
<span class="line-modified">3290   goto retry_atomic_decrement1;</span>
3291 
3292       TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));
3293 
3294       /* if we went from 2-&gt;1 we need to notify toggle refs if any */
3295       if (old_ref == 2 &amp;&amp; has_toggle_ref) /* The last ref being held in this case is owned by the toggle_ref */
<span class="line-modified">3296   toggle_refs_notify (object, TRUE);</span>
3297     }
3298   else
3299     {
3300       GSList **weak_locations;
3301 
3302       /* The only way that this object can live at this point is if
3303        * there are outstanding weak references already established
3304        * before we got here.
3305        *
3306        * If there were not already weak references then no more can be
3307        * established at this time, because the other thread would have
3308        * to hold a strong ref in order to call
3309        * g_object_add_weak_pointer() and then we wouldn&#39;t be here.
3310        */
3311       weak_locations = g_datalist_id_get_data (&amp;object-&gt;qdata, quark_weak_locations);
3312 
3313       if (weak_locations != NULL)
3314         {
3315           g_rw_lock_writer_lock (&amp;weak_locations_lock);
3316 
</pre>
<hr />
<pre>
3336               *weak_locations = g_slist_delete_link (*weak_locations, *weak_locations);
3337             }
3338 
3339           g_rw_lock_writer_unlock (&amp;weak_locations_lock);
3340         }
3341 
3342       /* we are about to remove the last reference */
3343       TRACE (GOBJECT_OBJECT_DISPOSE(object,G_TYPE_FROM_INSTANCE(object), 1));
3344       G_OBJECT_GET_CLASS (object)-&gt;dispose (object);
3345       TRACE (GOBJECT_OBJECT_DISPOSE_END(object,G_TYPE_FROM_INSTANCE(object), 1));
3346 
3347       /* may have been re-referenced meanwhile */
3348     retry_atomic_decrement2:
3349       old_ref = g_atomic_int_get ((int *)&amp;object-&gt;ref_count);
3350       if (old_ref &gt; 1)
3351         {
3352           /* valid if last 2 refs are owned by this call to unref and the toggle_ref */
3353           gboolean has_toggle_ref = OBJECT_HAS_TOGGLE_REF (object);
3354 
3355           if (!g_atomic_int_compare_and_exchange ((int *)&amp;object-&gt;ref_count, old_ref, old_ref - 1))
<span class="line-modified">3356       goto retry_atomic_decrement2;</span>
3357 
<span class="line-modified">3358     TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));</span>
3359 
3360           /* if we went from 2-&gt;1 we need to notify toggle refs if any */
3361           if (old_ref == 2 &amp;&amp; has_toggle_ref) /* The last ref being held in this case is owned by the toggle_ref */
<span class="line-modified">3362       toggle_refs_notify (object, TRUE);</span>
3363 
<span class="line-modified">3364     return;</span>
<span class="line-modified">3365   }</span>
3366 
3367       /* we are still in the process of taking away the last ref */
3368       g_datalist_id_set_data (&amp;object-&gt;qdata, quark_closure_array, NULL);
3369       g_signal_handlers_destroy (object);
3370       g_datalist_id_set_data (&amp;object-&gt;qdata, quark_weak_refs, NULL);
3371 
3372       /* decrement the last reference */
3373       old_ref = g_atomic_int_add (&amp;object-&gt;ref_count, -1);
<span class="line-added">3374       g_return_if_fail (old_ref &gt; 0);</span>
3375 
3376       TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));
3377 
3378       /* may have been re-referenced meanwhile */
3379       if (G_LIKELY (old_ref == 1))
<span class="line-modified">3380   {</span>
<span class="line-modified">3381     TRACE (GOBJECT_OBJECT_FINALIZE(object,G_TYPE_FROM_INSTANCE(object)));</span>
3382           G_OBJECT_GET_CLASS (object)-&gt;finalize (object);
3383 
<span class="line-modified">3384     TRACE (GOBJECT_OBJECT_FINALIZE_END(object,G_TYPE_FROM_INSTANCE(object)));</span>
3385 
3386           GOBJECT_IF_DEBUG (OBJECTS,
<span class="line-modified">3387       {</span>
<span class="line-modified">3388               gboolean was_present;</span>
<span class="line-modified">3389 </span>
<span class="line-modified">3390               /* catch objects not chaining finalize handlers */</span>
<span class="line-modified">3391               G_LOCK (debug_objects);</span>
<span class="line-modified">3392               was_present = g_hash_table_remove (debug_objects_ht, object);</span>
<span class="line-added">3393               G_UNLOCK (debug_objects);</span>
<span class="line-added">3394 </span>
<span class="line-added">3395               if (was_present)</span>
<span class="line-added">3396                 g_critical (&quot;Object %p of type %s not finalized correctly.&quot;,</span>
<span class="line-added">3397                             object, G_OBJECT_TYPE_NAME (object));</span>
<span class="line-added">3398       });</span>
3399           g_type_free_instance ((GTypeInstance*) object);
<span class="line-modified">3400   }</span>
3401     }
3402 }
3403 
3404 /**
3405  * g_clear_object: (skip)
3406  * @object_ptr: a pointer to a #GObject reference
3407  *
3408  * Clears a reference to a #GObject.
3409  *
3410  * @object_ptr must not be %NULL.
3411  *
3412  * If the reference is %NULL then this function does nothing.
3413  * Otherwise, the reference count of the object is decreased and the
3414  * pointer is set to %NULL.
3415  *
3416  * A macro is also included that allows this function to be used without
3417  * pointer casts.
3418  *
3419  * Since: 2.28
3420  **/
3421 #undef g_clear_object
3422 void
3423 g_clear_object (GObject **object_ptr)
3424 {
3425   g_clear_pointer (object_ptr, g_object_unref);
3426 }
3427 
3428 /**
3429  * g_object_get_qdata:
3430  * @object: The GObject to get a stored user data pointer from
3431  * @quark: A #GQuark, naming the user data pointer
3432  *
3433  * This function gets back user data pointers stored via
3434  * g_object_set_qdata().
3435  *
3436  * Returns: (transfer none) (nullable): The user data pointer set, or %NULL
3437  */
3438 gpointer
3439 g_object_get_qdata (GObject *object,
<span class="line-modified">3440         GQuark   quark)</span>
3441 {
3442   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
3443 
3444   return quark ? g_datalist_id_get_data (&amp;object-&gt;qdata, quark) : NULL;
3445 }
3446 
3447 /**
3448  * g_object_set_qdata: (skip)
3449  * @object: The GObject to set store a user data pointer
3450  * @quark: A #GQuark, naming the user data pointer
3451  * @data: (nullable): An opaque user data pointer
3452  *
3453  * This sets an opaque, named pointer on an object.
3454  * The name is specified through a #GQuark (retrived e.g. via
3455  * g_quark_from_static_string()), and the pointer
3456  * can be gotten back from the @object with g_object_get_qdata()
3457  * until the @object is finalized.
3458  * Setting a previously set user data pointer, overrides (frees)
3459  * the old pointer set, using #NULL as pointer essentially
3460  * removes the data stored.
3461  */
3462 void
3463 g_object_set_qdata (GObject *object,
<span class="line-modified">3464         GQuark   quark,</span>
<span class="line-modified">3465         gpointer data)</span>
3466 {
3467   g_return_if_fail (G_IS_OBJECT (object));
3468   g_return_if_fail (quark &gt; 0);
3469 
3470   g_datalist_id_set_data (&amp;object-&gt;qdata, quark, data);
3471 }
3472 
3473 /**
3474  * g_object_dup_qdata: (skip)
3475  * @object: the #GObject to store user data on
3476  * @quark: a #GQuark, naming the user data pointer
3477  * @dup_func: (nullable): function to dup the value
3478  * @user_data: (nullable): passed as user_data to @dup_func
3479  *
3480  * This is a variant of g_object_get_qdata() which returns
3481  * a &#39;duplicate&#39; of the value. @dup_func defines the
3482  * meaning of &#39;duplicate&#39; in this context, it could e.g.
3483  * take a reference on a ref-counted object.
3484  *
3485  * If the @quark is not set on the object then @dup_func
</pre>
<hr />
<pre>
3554                                      oldval, newval, destroy,
3555                                      old_destroy);
3556 }
3557 
3558 /**
3559  * g_object_set_qdata_full: (skip)
3560  * @object: The GObject to set store a user data pointer
3561  * @quark: A #GQuark, naming the user data pointer
3562  * @data: (nullable): An opaque user data pointer
3563  * @destroy: (nullable): Function to invoke with @data as argument, when @data
3564  *           needs to be freed
3565  *
3566  * This function works like g_object_set_qdata(), but in addition,
3567  * a void (*destroy) (gpointer) function may be specified which is
3568  * called with @data as argument when the @object is finalized, or
3569  * the data is being overwritten by a call to g_object_set_qdata()
3570  * with the same @quark.
3571  */
3572 void
3573 g_object_set_qdata_full (GObject       *object,
<span class="line-modified">3574        GQuark   quark,</span>
<span class="line-modified">3575        gpointer data,</span>
<span class="line-modified">3576        GDestroyNotify destroy)</span>
3577 {
3578   g_return_if_fail (G_IS_OBJECT (object));
3579   g_return_if_fail (quark &gt; 0);
3580 
3581   g_datalist_id_set_data_full (&amp;object-&gt;qdata, quark, data,
<span class="line-modified">3582              data ? destroy : (GDestroyNotify) NULL);</span>
3583 }
3584 
3585 /**
3586  * g_object_steal_qdata:
3587  * @object: The GObject to get a stored user data pointer from
3588  * @quark: A #GQuark, naming the user data pointer
3589  *
3590  * This function gets back user data pointers stored via
3591  * g_object_set_qdata() and removes the @data from object
3592  * without invoking its destroy() function (if any was
3593  * set).
3594  * Usually, calling this function is only required to update
3595  * user data pointers with a destroy notifier, for example:
3596  * |[&lt;!-- language=&quot;C&quot; --&gt;
3597  * void
3598  * object_add_to_user_list (GObject     *object,
3599  *                          const gchar *new_string)
3600  * {
3601  *   // the quark, naming the object data
3602  *   GQuark quark_string_list = g_quark_from_static_string (&quot;my-string-list&quot;);
</pre>
<hr />
<pre>
3610  * }
3611  * static void
3612  * free_string_list (gpointer data)
3613  * {
3614  *   GList *node, *list = data;
3615  *
3616  *   for (node = list; node; node = node-&gt;next)
3617  *     g_free (node-&gt;data);
3618  *   g_list_free (list);
3619  * }
3620  * ]|
3621  * Using g_object_get_qdata() in the above example, instead of
3622  * g_object_steal_qdata() would have left the destroy function set,
3623  * and thus the partial string list would have been freed upon
3624  * g_object_set_qdata_full().
3625  *
3626  * Returns: (transfer full) (nullable): The user data pointer set, or %NULL
3627  */
3628 gpointer
3629 g_object_steal_qdata (GObject *object,
<span class="line-modified">3630           GQuark   quark)</span>
3631 {
3632   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
3633   g_return_val_if_fail (quark &gt; 0, NULL);
3634 
3635   return g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark);
3636 }
3637 
3638 /**
3639  * g_object_get_data:
3640  * @object: #GObject containing the associations
3641  * @key: name of the key for that association
3642  *
3643  * Gets a named field from the objects table of associations (see g_object_set_data()).
3644  *
3645  * Returns: (transfer none) (nullable): the data if found,
3646  *          or %NULL if no such data exists.
3647  */
3648 gpointer
3649 g_object_get_data (GObject     *object,
3650                    const gchar *key)
3651 {
3652   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
3653   g_return_val_if_fail (key != NULL, NULL);
3654 
3655   return g_datalist_get_data (&amp;object-&gt;qdata, key);
3656 }
3657 
3658 /**
3659  * g_object_set_data:
3660  * @object: #GObject containing the associations.
3661  * @key: name of the key
3662  * @data: (nullable): data to associate with that key
3663  *
3664  * Each object carries around a table of associations from
3665  * strings to pointers.  This function lets you set an association.
3666  *
3667  * If the object already had an association with that name,
3668  * the old association will be destroyed.
<span class="line-added">3669  *</span>
<span class="line-added">3670  * Internally, the @key is converted to a #GQuark using g_quark_from_string().</span>
<span class="line-added">3671  * This means a copy of @key is kept permanently (even after @object has been</span>
<span class="line-added">3672  * finalized) - so it is recommended to only use a small, bounded set of values</span>
<span class="line-added">3673  * for @key in your program, to avoid the #GQuark storage growing unbounded.</span>
3674  */
3675 void
3676 g_object_set_data (GObject     *object,
3677                    const gchar *key,
3678                    gpointer     data)
3679 {
3680   g_return_if_fail (G_IS_OBJECT (object));
3681   g_return_if_fail (key != NULL);
3682 
3683   g_datalist_id_set_data (&amp;object-&gt;qdata, g_quark_from_string (key), data);
3684 }
3685 
3686 /**
3687  * g_object_dup_data: (skip)
3688  * @object: the #GObject to store user data on
3689  * @key: a string, naming the user data pointer
3690  * @dup_func: (nullable): function to dup the value
3691  * @user_data: (nullable): passed as user_data to @dup_func
3692  *
3693  * This is a variant of g_object_get_data() which returns
</pre>
<hr />
<pre>
3732  * @key: a string, naming the user data pointer
3733  * @oldval: (nullable): the old value to compare against
3734  * @newval: (nullable): the new value
3735  * @destroy: (nullable): a destroy notify for the new value
3736  * @old_destroy: (out) (optional): destroy notify for the existing value
3737  *
3738  * Compares the user data for the key @key on @object with
3739  * @oldval, and if they are the same, replaces @oldval with
3740  * @newval.
3741  *
3742  * This is like a typical atomic compare-and-exchange
3743  * operation, for user data on an object.
3744  *
3745  * If the previous value was replaced then ownership of the
3746  * old value (@oldval) is passed to the caller, including
3747  * the registered destroy notify for it (passed out in @old_destroy).
3748  * It&#39;s up to the caller to free this as needed, which may
3749  * or may not include using @old_destroy as sometimes replacement
3750  * should not destroy the object in the normal way.
3751  *
<span class="line-added">3752  * See g_object_set_data() for guidance on using a small, bounded set of values</span>
<span class="line-added">3753  * for @key.</span>
<span class="line-added">3754  *</span>
3755  * Returns: %TRUE if the existing value for @key was replaced
3756  *  by @newval, %FALSE otherwise.
3757  *
3758  * Since: 2.34
3759  */
3760 gboolean
3761 g_object_replace_data (GObject        *object,
3762                        const gchar    *key,
3763                        gpointer        oldval,
3764                        gpointer        newval,
3765                        GDestroyNotify  destroy,
3766                        GDestroyNotify *old_destroy)
3767 {
3768   g_return_val_if_fail (G_IS_OBJECT (object), FALSE);
3769   g_return_val_if_fail (key != NULL, FALSE);
3770 
3771   return g_datalist_id_replace_data (&amp;object-&gt;qdata,
3772                                      g_quark_from_string (key),
3773                                      oldval, newval, destroy,
3774                                      old_destroy);
</pre>
<hr />
<pre>
3780  * @key: name of the key
3781  * @data: (nullable): data to associate with that key
3782  * @destroy: (nullable): function to call when the association is destroyed
3783  *
3784  * Like g_object_set_data() except it adds notification
3785  * for when the association is destroyed, either by setting it
3786  * to a different value or when the object is destroyed.
3787  *
3788  * Note that the @destroy callback is not called if @data is %NULL.
3789  */
3790 void
3791 g_object_set_data_full (GObject       *object,
3792                         const gchar   *key,
3793                         gpointer       data,
3794                         GDestroyNotify destroy)
3795 {
3796   g_return_if_fail (G_IS_OBJECT (object));
3797   g_return_if_fail (key != NULL);
3798 
3799   g_datalist_id_set_data_full (&amp;object-&gt;qdata, g_quark_from_string (key), data,
<span class="line-modified">3800              data ? destroy : (GDestroyNotify) NULL);</span>
3801 }
3802 
3803 /**
3804  * g_object_steal_data:
3805  * @object: #GObject containing the associations
3806  * @key: name of the key
3807  *
3808  * Remove a specified datum from the object&#39;s data associations,
3809  * without invoking the association&#39;s destroy handler.
3810  *
3811  * Returns: (transfer full) (nullable): the data if found, or %NULL
3812  *          if no such data exists.
3813  */
3814 gpointer
3815 g_object_steal_data (GObject     *object,
3816                      const gchar *key)
3817 {
3818   GQuark quark;
3819 
3820   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
</pre>
<hr />
<pre>
3823   quark = g_quark_try_string (key);
3824 
3825   return quark ? g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark) : NULL;
3826 }
3827 
3828 static void
3829 g_value_object_init (GValue *value)
3830 {
3831   value-&gt;data[0].v_pointer = NULL;
3832 }
3833 
3834 static void
3835 g_value_object_free_value (GValue *value)
3836 {
3837   if (value-&gt;data[0].v_pointer)
3838     g_object_unref (value-&gt;data[0].v_pointer);
3839 }
3840 
3841 static void
3842 g_value_object_copy_value (const GValue *src_value,
<span class="line-modified">3843          GValue *dest_value)</span>
3844 {
3845   if (src_value-&gt;data[0].v_pointer)
3846     dest_value-&gt;data[0].v_pointer = g_object_ref (src_value-&gt;data[0].v_pointer);
3847   else
3848     dest_value-&gt;data[0].v_pointer = NULL;
3849 }
3850 
3851 static void
3852 g_value_object_transform_value (const GValue *src_value,
<span class="line-modified">3853         GValue       *dest_value)</span>
3854 {
3855   if (src_value-&gt;data[0].v_pointer &amp;&amp; g_type_is_a (G_OBJECT_TYPE (src_value-&gt;data[0].v_pointer), G_VALUE_TYPE (dest_value)))
3856     dest_value-&gt;data[0].v_pointer = g_object_ref (src_value-&gt;data[0].v_pointer);
3857   else
3858     dest_value-&gt;data[0].v_pointer = NULL;
3859 }
3860 
3861 static gpointer
3862 g_value_object_peek_pointer (const GValue *value)
3863 {
3864   return value-&gt;data[0].v_pointer;
3865 }
3866 
3867 static gchar*
<span class="line-modified">3868 g_value_object_collect_value (GValue    *value,</span>
<span class="line-modified">3869             guint        n_collect_values,</span>
<span class="line-modified">3870             GTypeCValue *collect_values,</span>
<span class="line-modified">3871             guint        collect_flags)</span>
3872 {
3873   if (collect_values[0].v_pointer)
3874     {
3875       GObject *object = collect_values[0].v_pointer;
3876 
3877       if (object-&gt;g_type_instance.g_class == NULL)
<span class="line-modified">3878   return g_strconcat (&quot;invalid unclassed object pointer for value type &#39;&quot;,</span>
<span class="line-modified">3879           G_VALUE_TYPE_NAME (value),</span>
<span class="line-modified">3880           &quot;&#39;&quot;,</span>
<span class="line-modified">3881           NULL);</span>
3882       else if (!g_value_type_compatible (G_OBJECT_TYPE (object), G_VALUE_TYPE (value)))
<span class="line-modified">3883   return g_strconcat (&quot;invalid object type &#39;&quot;,</span>
<span class="line-modified">3884           G_OBJECT_TYPE_NAME (object),</span>
<span class="line-modified">3885           &quot;&#39; for value type &#39;&quot;,</span>
<span class="line-modified">3886           G_VALUE_TYPE_NAME (value),</span>
<span class="line-modified">3887           &quot;&#39;&quot;,</span>
<span class="line-modified">3888           NULL);</span>
3889       /* never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types */
3890       value-&gt;data[0].v_pointer = g_object_ref (object);
3891     }
3892   else
3893     value-&gt;data[0].v_pointer = NULL;
3894 
3895   return NULL;
3896 }
3897 
3898 static gchar*
3899 g_value_object_lcopy_value (const GValue *value,
<span class="line-modified">3900           guint        n_collect_values,</span>
<span class="line-modified">3901           GTypeCValue *collect_values,</span>
<span class="line-modified">3902           guint        collect_flags)</span>
3903 {
3904   GObject **object_p = collect_values[0].v_pointer;
3905 
3906   if (!object_p)
3907     return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
3908 
3909   if (!value-&gt;data[0].v_pointer)
3910     *object_p = NULL;
3911   else if (collect_flags &amp; G_VALUE_NOCOPY_CONTENTS)
3912     *object_p = value-&gt;data[0].v_pointer;
3913   else
3914     *object_p = g_object_ref (value-&gt;data[0].v_pointer);
3915 
3916   return NULL;
3917 }
3918 
3919 /**
3920  * g_value_set_object:
3921  * @value: a valid #GValue of %G_TYPE_OBJECT derived type
3922  * @v_object: (type GObject.Object) (nullable): object value to be set
3923  *
3924  * Set the contents of a %G_TYPE_OBJECT derived #GValue to @v_object.
3925  *
3926  * g_value_set_object() increases the reference count of @v_object
3927  * (the #GValue holds a reference to @v_object).  If you do not wish
3928  * to increase the reference count of the object (i.e. you wish to
3929  * pass your current reference to the #GValue because you no longer
3930  * need it), use g_value_take_object() instead.
3931  *
3932  * It is important that your #GValue holds a reference to @v_object (either its
3933  * own, or one it has taken) to ensure that the object won&#39;t be destroyed while
3934  * the #GValue still exists).
3935  */
3936 void
3937 g_value_set_object (GValue   *value,
<span class="line-modified">3938         gpointer  v_object)</span>
3939 {
3940   GObject *old;
3941 
3942   g_return_if_fail (G_VALUE_HOLDS_OBJECT (value));
3943 
3944   old = value-&gt;data[0].v_pointer;
3945 
3946   if (v_object)
3947     {
3948       g_return_if_fail (G_IS_OBJECT (v_object));
3949       g_return_if_fail (g_value_type_compatible (G_OBJECT_TYPE (v_object), G_VALUE_TYPE (value)));
3950 
3951       value-&gt;data[0].v_pointer = v_object;
3952       g_object_ref (value-&gt;data[0].v_pointer);
3953     }
3954   else
3955     value-&gt;data[0].v_pointer = NULL;
3956 
3957   if (old)
3958     g_object_unref (old);
3959 }
3960 
3961 /**
3962  * g_value_set_object_take_ownership: (skip)
3963  * @value: a valid #GValue of %G_TYPE_OBJECT derived type
3964  * @v_object: (nullable): object value to be set
3965  *
3966  * This is an internal function introduced mainly for C marshallers.
3967  *
3968  * Deprecated: 2.4: Use g_value_take_object() instead.
3969  */
3970 void
3971 g_value_set_object_take_ownership (GValue  *value,
<span class="line-modified">3972            gpointer v_object)</span>
3973 {
3974   g_value_take_object (value, v_object);
3975 }
3976 
3977 /**
3978  * g_value_take_object: (skip)
3979  * @value: a valid #GValue of %G_TYPE_OBJECT derived type
3980  * @v_object: (nullable): object value to be set
3981  *
3982  * Sets the contents of a %G_TYPE_OBJECT derived #GValue to @v_object
<span class="line-modified">3983  * and takes over the ownership of the caller&#39;s reference to @v_object;</span>
3984  * the caller doesn&#39;t have to unref it any more (i.e. the reference
3985  * count of the object is not increased).
3986  *
3987  * If you want the #GValue to hold its own reference to @v_object, use
3988  * g_value_set_object() instead.
3989  *
3990  * Since: 2.4
3991  */
3992 void
3993 g_value_take_object (GValue  *value,
<span class="line-modified">3994          gpointer v_object)</span>
3995 {
3996   g_return_if_fail (G_VALUE_HOLDS_OBJECT (value));
3997 
3998   if (value-&gt;data[0].v_pointer)
3999     {
4000       g_object_unref (value-&gt;data[0].v_pointer);
4001       value-&gt;data[0].v_pointer = NULL;
4002     }
4003 
4004   if (v_object)
4005     {
4006       g_return_if_fail (G_IS_OBJECT (v_object));
4007       g_return_if_fail (g_value_type_compatible (G_OBJECT_TYPE (v_object), G_VALUE_TYPE (value)));
4008 
4009       value-&gt;data[0].v_pointer = v_object; /* we take over the reference count */
4010     }
4011 }
4012 
4013 /**
4014  * g_value_get_object:
</pre>
<hr />
<pre>
4050  * @instance: (type GObject.TypeInstance): the instance to connect to.
4051  * @detailed_signal: a string of the form &quot;signal-name::detail&quot;.
4052  * @c_handler: the #GCallback to connect.
4053  * @gobject: (type GObject.Object) (nullable): the object to pass as data
4054  *    to @c_handler.
4055  * @connect_flags: a combination of #GConnectFlags.
4056  *
4057  * This is similar to g_signal_connect_data(), but uses a closure which
4058  * ensures that the @gobject stays alive during the call to @c_handler
4059  * by temporarily adding a reference count to @gobject.
4060  *
4061  * When the @gobject is destroyed the signal handler will be automatically
4062  * disconnected.  Note that this is not currently threadsafe (ie:
4063  * emitting a signal while @gobject is being destroyed in another thread
4064  * is not safe).
4065  *
4066  * Returns: the handler id.
4067  */
4068 gulong
4069 g_signal_connect_object (gpointer      instance,
<span class="line-modified">4070        const gchar  *detailed_signal,</span>
<span class="line-modified">4071        GCallback     c_handler,</span>
<span class="line-modified">4072        gpointer      gobject,</span>
<span class="line-modified">4073        GConnectFlags connect_flags)</span>
4074 {
4075   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
4076   g_return_val_if_fail (detailed_signal != NULL, 0);
4077   g_return_val_if_fail (c_handler != NULL, 0);
4078 
4079   if (gobject)
4080     {
4081       GClosure *closure;
4082 
4083       g_return_val_if_fail (G_IS_OBJECT (gobject), 0);
4084 
4085       closure = ((connect_flags &amp; G_CONNECT_SWAPPED) ? g_cclosure_new_object_swap : g_cclosure_new_object) (c_handler, gobject);
4086 
4087       return g_signal_connect_closure (instance, detailed_signal, closure, connect_flags &amp; G_CONNECT_AFTER);
4088     }
4089   else
4090     return g_signal_connect_data (instance, detailed_signal, c_handler, NULL, NULL, connect_flags);
4091 }
4092 
4093 typedef struct {
</pre>
<hr />
<pre>
4099  * watched closures, e.g.:
4100  * GSList* g_object_list_watched_closures (GObject *object)
4101  * {
4102  *   CArray *carray;
4103  *   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
4104  *   carray = g_object_get_data (object, &quot;GObject-closure-array&quot;);
4105  *   if (carray)
4106  *     {
4107  *       GSList *slist = NULL;
4108  *       guint i;
4109  *       for (i = 0; i &lt; carray-&gt;n_closures; i++)
4110  *         slist = g_slist_prepend (slist, carray-&gt;closures[i]);
4111  *       return slist;
4112  *     }
4113  *   return NULL;
4114  * }
4115  */
4116 
4117 static void
4118 object_remove_closure (gpointer  data,
<span class="line-modified">4119            GClosure *closure)</span>
4120 {
4121   GObject *object = data;
4122   CArray *carray;
4123   guint i;
4124 
4125   G_LOCK (closure_array_mutex);
4126   carray = g_object_get_qdata (object, quark_closure_array);
4127   for (i = 0; i &lt; carray-&gt;n_closures; i++)
4128     if (carray-&gt;closures[i] == closure)
4129       {
<span class="line-modified">4130   carray-&gt;n_closures--;</span>
<span class="line-modified">4131   if (i &lt; carray-&gt;n_closures)</span>
<span class="line-modified">4132     carray-&gt;closures[i] = carray-&gt;closures[carray-&gt;n_closures];</span>
<span class="line-modified">4133   G_UNLOCK (closure_array_mutex);</span>
<span class="line-modified">4134   return;</span>
4135       }
4136   G_UNLOCK (closure_array_mutex);
4137   g_assert_not_reached ();
4138 }
4139 
4140 static void
4141 destroy_closure_array (gpointer data)
4142 {
4143   CArray *carray = data;
4144   GObject *object = carray-&gt;object;
4145   guint i, n = carray-&gt;n_closures;
4146 
4147   for (i = 0; i &lt; n; i++)
4148     {
4149       GClosure *closure = carray-&gt;closures[i];
4150 
4151       /* removing object_remove_closure() upfront is probably faster than
4152        * letting it fiddle with quark_closure_array which is empty anyways
4153        */
4154       g_closure_remove_invalidate_notifier (closure, object, object_remove_closure);
4155       g_closure_invalidate (closure);
4156     }
4157   g_free (carray);
4158 }
4159 
4160 /**
4161  * g_object_watch_closure:
<span class="line-modified">4162  * @object: #GObject restricting lifetime of @closure</span>
<span class="line-modified">4163  * @closure: #GClosure to watch</span>
4164  *
4165  * This function essentially limits the life time of the @closure to
4166  * the life time of the object. That is, when the object is finalized,
4167  * the @closure is invalidated by calling g_closure_invalidate() on
4168  * it, in order to prevent invocations of the closure with a finalized
4169  * (nonexisting) object. Also, g_object_ref() and g_object_unref() are
4170  * added as marshal guards to the @closure, to ensure that an extra
4171  * reference count is held on @object during invocation of the
4172  * @closure.  Usually, this function will be called on closures that
4173  * use this @object as closure data.
4174  */
4175 void
4176 g_object_watch_closure (GObject  *object,
<span class="line-modified">4177       GClosure *closure)</span>
4178 {
4179   CArray *carray;
4180   guint i;
4181 
4182   g_return_if_fail (G_IS_OBJECT (object));
4183   g_return_if_fail (closure != NULL);
4184   g_return_if_fail (closure-&gt;is_invalid == FALSE);
4185   g_return_if_fail (closure-&gt;in_marshal == FALSE);
<span class="line-modified">4186   g_return_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt; 0); /* this doesn&#39;t work on finalizing objects */</span>
4187 
4188   g_closure_add_invalidate_notifier (closure, object, object_remove_closure);
4189   g_closure_add_marshal_guards (closure,
<span class="line-modified">4190         object, (GClosureNotify) g_object_ref,</span>
<span class="line-modified">4191         object, (GClosureNotify) g_object_unref);</span>
4192   G_LOCK (closure_array_mutex);
4193   carray = g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark_closure_array);
4194   if (!carray)
4195     {
4196       carray = g_renew (CArray, NULL, 1);
4197       carray-&gt;object = object;
4198       carray-&gt;n_closures = 1;
4199       i = 0;
4200     }
4201   else
4202     {
4203       i = carray-&gt;n_closures++;
4204       carray = g_realloc (carray, sizeof (*carray) + sizeof (carray-&gt;closures[0]) * i);
4205     }
4206   carray-&gt;closures[i] = closure;
4207   g_datalist_id_set_data_full (&amp;object-&gt;qdata, quark_closure_array, carray, destroy_closure_array);
4208   G_UNLOCK (closure_array_mutex);
4209 }
4210 
4211 /**
4212  * g_closure_new_object:
4213  * @sizeof_closure: the size of the structure to allocate, must be at least
4214  *  `sizeof (GClosure)`
4215  * @object: a #GObject pointer to store in the @data field of the newly
4216  *  allocated #GClosure
4217  *
4218  * A variant of g_closure_new_simple() which stores @object in the
4219  * @data field of the closure and calls g_object_watch_closure() on
4220  * @object and the created closure. This function is mainly useful
4221  * when implementing new types of closures.
4222  *
4223  * Returns: (transfer full): a newly allocated #GClosure
4224  */
4225 GClosure*
4226 g_closure_new_object (guint    sizeof_closure,
<span class="line-modified">4227           GObject *object)</span>
4228 {
4229   GClosure *closure;
4230 
4231   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
<span class="line-modified">4232   g_return_val_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt; 0, NULL);     /* this doesn&#39;t work on finalizing objects */</span>
4233 
4234   closure = g_closure_new_simple (sizeof_closure, object);
4235   g_object_watch_closure (object, closure);
4236 
4237   return closure;
4238 }
4239 
4240 /**
4241  * g_cclosure_new_object: (skip)
4242  * @callback_func: the function to invoke
4243  * @object: a #GObject pointer to pass to @callback_func
4244  *
4245  * A variant of g_cclosure_new() which uses @object as @user_data and
4246  * calls g_object_watch_closure() on @object and the created
4247  * closure. This function is useful when you have a callback closely
4248  * associated with a #GObject, and want the callback to no longer run
4249  * after the object is is freed.
4250  *
4251  * Returns: a new #GCClosure
4252  */
4253 GClosure*
4254 g_cclosure_new_object (GCallback callback_func,
<span class="line-modified">4255            GObject  *object)</span>
4256 {
4257   GClosure *closure;
4258 
4259   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
<span class="line-modified">4260   g_return_val_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt; 0, NULL);     /* this doesn&#39;t work on finalizing objects */</span>
4261   g_return_val_if_fail (callback_func != NULL, NULL);
4262 
4263   closure = g_cclosure_new (callback_func, object, NULL);
4264   g_object_watch_closure (object, closure);
4265 
4266   return closure;
4267 }
4268 
4269 /**
4270  * g_cclosure_new_object_swap: (skip)
4271  * @callback_func: the function to invoke
4272  * @object: a #GObject pointer to pass to @callback_func
4273  *
4274  * A variant of g_cclosure_new_swap() which uses @object as @user_data
4275  * and calls g_object_watch_closure() on @object and the created
4276  * closure. This function is useful when you have a callback closely
4277  * associated with a #GObject, and want the callback to no longer run
4278  * after the object is is freed.
4279  *
4280  * Returns: a new #GCClosure
4281  */
4282 GClosure*
4283 g_cclosure_new_object_swap (GCallback callback_func,
<span class="line-modified">4284           GObject  *object)</span>
4285 {
4286   GClosure *closure;
4287 
4288   g_return_val_if_fail (G_IS_OBJECT (object), NULL);
<span class="line-modified">4289   g_return_val_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt; 0, NULL);     /* this doesn&#39;t work on finalizing objects */</span>
4290   g_return_val_if_fail (callback_func != NULL, NULL);
4291 
4292   closure = g_cclosure_new_swap (callback_func, object, NULL);
4293   g_object_watch_closure (object, closure);
4294 
4295   return closure;
4296 }
4297 
4298 gsize
4299 g_object_compat_control (gsize           what,
4300                          gpointer        data)
4301 {
4302   switch (what)
4303     {
4304       gpointer *pp;
4305     case 1:     /* floating base type */
4306       return G_TYPE_INITIALLY_UNOWNED;
4307     case 2:     /* FIXME: remove this once GLib/Gtk+ break ABI again */
4308       floating_flag_handler = (guint(*)(GObject*,gint)) data;
4309       return 1;
</pre>
</td>
</tr>
</table>
<center><a href="gobject-autocleanups.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gobject.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>