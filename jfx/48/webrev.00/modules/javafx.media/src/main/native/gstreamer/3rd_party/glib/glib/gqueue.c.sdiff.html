<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gqueue.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gquark.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gqueue.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gqueue.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 132 }
 133 
 134 /**
 135  * g_queue_clear:
 136  * @queue: a #GQueue
 137  *
 138  * Removes all the elements in @queue. If queue elements contain
 139  * dynamically-allocated memory, they should be freed first.
 140  *
 141  * Since: 2.14
 142  */
 143 void
 144 g_queue_clear (GQueue *queue)
 145 {
 146   g_return_if_fail (queue != NULL);
 147 
 148   g_list_free (queue-&gt;head);
 149   g_queue_init (queue);
 150 }
 151 






















 152 /**
 153  * g_queue_is_empty:
 154  * @queue: a #GQueue.
 155  *
 156  * Returns %TRUE if the queue is empty.
 157  *
 158  * Returns: %TRUE if the queue is empty
 159  */
 160 gboolean
 161 g_queue_is_empty (GQueue *queue)
 162 {
 163   g_return_val_if_fail (queue != NULL, TRUE);
 164 
 165   return queue-&gt;head == NULL;
 166 }
 167 
 168 /**
 169  * g_queue_get_length:
 170  * @queue: a #GQueue
 171  *
</pre>
<hr />
<pre>
 490   g_assert (queue-&gt;tail);
 491 
 492   next = g_queue_peek_nth_link (queue, n);
 493 #ifdef GSTREAMER_LITE
 494   if (next == NULL) {
 495     return;
 496   }
 497 #endif // GSTREAMER_LITE
 498   prev = next-&gt;prev;
 499 
 500   if (prev)
 501     prev-&gt;next = link_;
 502   next-&gt;prev = link_;
 503 
 504   link_-&gt;next = next;
 505   link_-&gt;prev = prev;
 506 
 507   if (queue-&gt;head-&gt;prev)
 508     queue-&gt;head = queue-&gt;head-&gt;prev;
 509 
<span class="line-modified"> 510   if (queue-&gt;tail-&gt;next)</span>
<span class="line-modified"> 511     queue-&gt;tail = queue-&gt;tail-&gt;next;</span>


 512 
 513   queue-&gt;length++;
 514 }
 515 
 516 /**
 517  * g_queue_pop_head:
 518  * @queue: a #GQueue
 519  *
 520  * Removes the first element of the queue and returns its data.
 521  *
 522  * Returns: the data of the first element in the queue, or %NULL
 523  *     if the queue is empty
 524  */
 525 gpointer
 526 g_queue_pop_head (GQueue *queue)
 527 {
 528   g_return_val_if_fail (queue != NULL, NULL);
 529 
 530   if (queue-&gt;head)
 531     {
</pre>
<hr />
<pre>
1018  *
1019  * Since: 2.4
1020  */
1021 void
1022 g_queue_insert_before (GQueue   *queue,
1023                        GList    *sibling,
1024                        gpointer  data)
1025 {
1026   g_return_if_fail (queue != NULL);
1027 
1028   if (sibling == NULL)
1029     {
1030       /* We don&#39;t use g_list_insert_before() with a NULL sibling because it
1031        * would be a O(n) operation and we would need to update manually the tail
1032        * pointer.
1033        */
1034       g_queue_push_tail (queue, data);
1035     }
1036   else
1037     {
<span class="line-modified">1038   queue-&gt;head = g_list_insert_before (queue-&gt;head, sibling, data);</span>
<span class="line-modified">1039   queue-&gt;length++;</span>

1040 }





































1041 }
1042 
1043 /**
1044  * g_queue_insert_after:
1045  * @queue: a #GQueue
1046  * @sibling: (nullable): a #GList link that must be part of @queue, or %NULL to
1047  *   push at the head of the queue.
1048  * @data: the data to insert
1049  *
1050  * Inserts @data into @queue after @sibling.
1051  *
1052  * @sibling must be part of @queue. Since GLib 2.44 a %NULL sibling pushes the
1053  * data at the head of the queue.
1054  *
1055  * Since: 2.4
1056  */
1057 void
1058 g_queue_insert_after (GQueue   *queue,
1059                       GList    *sibling,
1060                       gpointer  data)
1061 {
1062   g_return_if_fail (queue != NULL);
1063 
1064   if (sibling == NULL)
1065     g_queue_push_head (queue, data);
1066   else
1067     g_queue_insert_before (queue, sibling-&gt;next, data);
1068 }
1069 





























1070 /**
1071  * g_queue_insert_sorted:
1072  * @queue: a #GQueue
1073  * @data: the data to insert
1074  * @func: the #GCompareDataFunc used to compare elements in the queue. It is
1075  *     called with two elements of the @queue and @user_data. It should
1076  *     return 0 if the elements are equal, a negative value if the first
1077  *     element comes before the second, and a positive value if the second
1078  *     element comes before the first.
1079  * @user_data: user data passed to @func
1080  *
1081  * Inserts @data into @queue using @func to determine the new position.
1082  *
1083  * Since: 2.4
1084  */
1085 void
1086 g_queue_insert_sorted (GQueue           *queue,
1087                        gpointer          data,
1088                        GCompareDataFunc  func,
1089                        gpointer          user_data)
1090 {
1091   GList *list;
1092 
1093   g_return_if_fail (queue != NULL);
1094 
1095   list = queue-&gt;head;
1096   while (list &amp;&amp; func (list-&gt;data, data, user_data) &lt; 0)
1097     list = list-&gt;next;
1098 
<span class="line-modified">1099     g_queue_insert_before (queue, list, data);</span>
1100 }
</pre>
</td>
<td>
<hr />
<pre>
 132 }
 133 
 134 /**
 135  * g_queue_clear:
 136  * @queue: a #GQueue
 137  *
 138  * Removes all the elements in @queue. If queue elements contain
 139  * dynamically-allocated memory, they should be freed first.
 140  *
 141  * Since: 2.14
 142  */
 143 void
 144 g_queue_clear (GQueue *queue)
 145 {
 146   g_return_if_fail (queue != NULL);
 147 
 148   g_list_free (queue-&gt;head);
 149   g_queue_init (queue);
 150 }
 151 
<span class="line-added"> 152 /**</span>
<span class="line-added"> 153  * g_queue_clear_full:</span>
<span class="line-added"> 154  * @queue: a pointer to a #GQueue</span>
<span class="line-added"> 155  * @free_func: (nullable): the function to be called to free memory allocated</span>
<span class="line-added"> 156  *</span>
<span class="line-added"> 157  * Convenience method, which frees all the memory used by a #GQueue,</span>
<span class="line-added"> 158  * and calls the provided @free_func on each item in the #GQueue.</span>
<span class="line-added"> 159  *</span>
<span class="line-added"> 160  * Since: 2.60</span>
<span class="line-added"> 161  */</span>
<span class="line-added"> 162 void</span>
<span class="line-added"> 163 g_queue_clear_full (GQueue          *queue,</span>
<span class="line-added"> 164                     GDestroyNotify  free_func)</span>
<span class="line-added"> 165 {</span>
<span class="line-added"> 166   g_return_if_fail (queue != NULL);</span>
<span class="line-added"> 167 </span>
<span class="line-added"> 168   if (free_func != NULL)</span>
<span class="line-added"> 169     g_queue_foreach (queue, (GFunc) free_func, NULL);</span>
<span class="line-added"> 170 </span>
<span class="line-added"> 171   g_queue_clear (queue);</span>
<span class="line-added"> 172 }</span>
<span class="line-added"> 173 </span>
 174 /**
 175  * g_queue_is_empty:
 176  * @queue: a #GQueue.
 177  *
 178  * Returns %TRUE if the queue is empty.
 179  *
 180  * Returns: %TRUE if the queue is empty
 181  */
 182 gboolean
 183 g_queue_is_empty (GQueue *queue)
 184 {
 185   g_return_val_if_fail (queue != NULL, TRUE);
 186 
 187   return queue-&gt;head == NULL;
 188 }
 189 
 190 /**
 191  * g_queue_get_length:
 192  * @queue: a #GQueue
 193  *
</pre>
<hr />
<pre>
 512   g_assert (queue-&gt;tail);
 513 
 514   next = g_queue_peek_nth_link (queue, n);
 515 #ifdef GSTREAMER_LITE
 516   if (next == NULL) {
 517     return;
 518   }
 519 #endif // GSTREAMER_LITE
 520   prev = next-&gt;prev;
 521 
 522   if (prev)
 523     prev-&gt;next = link_;
 524   next-&gt;prev = link_;
 525 
 526   link_-&gt;next = next;
 527   link_-&gt;prev = prev;
 528 
 529   if (queue-&gt;head-&gt;prev)
 530     queue-&gt;head = queue-&gt;head-&gt;prev;
 531 
<span class="line-modified"> 532   /* The case where we&#39;re pushing @link_ at the end of @queue is handled above</span>
<span class="line-modified"> 533    * using g_queue_push_tail_link(), so we should never have to manually adjust</span>
<span class="line-added"> 534    * queue-&gt;tail. */</span>
<span class="line-added"> 535   g_assert (queue-&gt;tail-&gt;next == NULL);</span>
 536 
 537   queue-&gt;length++;
 538 }
 539 
 540 /**
 541  * g_queue_pop_head:
 542  * @queue: a #GQueue
 543  *
 544  * Removes the first element of the queue and returns its data.
 545  *
 546  * Returns: the data of the first element in the queue, or %NULL
 547  *     if the queue is empty
 548  */
 549 gpointer
 550 g_queue_pop_head (GQueue *queue)
 551 {
 552   g_return_val_if_fail (queue != NULL, NULL);
 553 
 554   if (queue-&gt;head)
 555     {
</pre>
<hr />
<pre>
1042  *
1043  * Since: 2.4
1044  */
1045 void
1046 g_queue_insert_before (GQueue   *queue,
1047                        GList    *sibling,
1048                        gpointer  data)
1049 {
1050   g_return_if_fail (queue != NULL);
1051 
1052   if (sibling == NULL)
1053     {
1054       /* We don&#39;t use g_list_insert_before() with a NULL sibling because it
1055        * would be a O(n) operation and we would need to update manually the tail
1056        * pointer.
1057        */
1058       g_queue_push_tail (queue, data);
1059     }
1060   else
1061     {
<span class="line-modified">1062       queue-&gt;head = g_list_insert_before (queue-&gt;head, sibling, data);</span>
<span class="line-modified">1063       queue-&gt;length++;</span>
<span class="line-added">1064     }</span>
1065 }
<span class="line-added">1066 </span>
<span class="line-added">1067 /**</span>
<span class="line-added">1068  * g_queue_insert_before_link:</span>
<span class="line-added">1069  * @queue: a #GQueue</span>
<span class="line-added">1070  * @sibling: (nullable): a #GList link that must be part of @queue, or %NULL to</span>
<span class="line-added">1071  *   push at the tail of the queue.</span>
<span class="line-added">1072  * @link_: a #GList link to insert which must not be part of any other list.</span>
<span class="line-added">1073  *</span>
<span class="line-added">1074  * Inserts @link_ into @queue before @sibling.</span>
<span class="line-added">1075  *</span>
<span class="line-added">1076  * @sibling must be part of @queue.</span>
<span class="line-added">1077  *</span>
<span class="line-added">1078  * Since: 2.62</span>
<span class="line-added">1079  */</span>
<span class="line-added">1080 void</span>
<span class="line-added">1081 g_queue_insert_before_link (GQueue   *queue,</span>
<span class="line-added">1082                             GList    *sibling,</span>
<span class="line-added">1083                             GList    *link_)</span>
<span class="line-added">1084 {</span>
<span class="line-added">1085   g_return_if_fail (queue != NULL);</span>
<span class="line-added">1086   g_return_if_fail (link_ != NULL);</span>
<span class="line-added">1087   g_return_if_fail (link_-&gt;prev == NULL);</span>
<span class="line-added">1088   g_return_if_fail (link_-&gt;next == NULL);</span>
<span class="line-added">1089 </span>
<span class="line-added">1090   if G_UNLIKELY (sibling == NULL)</span>
<span class="line-added">1091     {</span>
<span class="line-added">1092       /* We don&#39;t use g_list_insert_before_link() with a NULL sibling because it</span>
<span class="line-added">1093        * would be a O(n) operation and we would need to update manually the tail</span>
<span class="line-added">1094        * pointer.</span>
<span class="line-added">1095        */</span>
<span class="line-added">1096       g_queue_push_tail_link (queue, link_);</span>
<span class="line-added">1097     }</span>
<span class="line-added">1098   else</span>
<span class="line-added">1099     {</span>
<span class="line-added">1100       queue-&gt;head = g_list_insert_before_link (queue-&gt;head, sibling, link_);</span>
<span class="line-added">1101       queue-&gt;length++;</span>
<span class="line-added">1102     }</span>
1103 }
1104 
1105 /**
1106  * g_queue_insert_after:
1107  * @queue: a #GQueue
1108  * @sibling: (nullable): a #GList link that must be part of @queue, or %NULL to
1109  *   push at the head of the queue.
1110  * @data: the data to insert
1111  *
1112  * Inserts @data into @queue after @sibling.
1113  *
1114  * @sibling must be part of @queue. Since GLib 2.44 a %NULL sibling pushes the
1115  * data at the head of the queue.
1116  *
1117  * Since: 2.4
1118  */
1119 void
1120 g_queue_insert_after (GQueue   *queue,
1121                       GList    *sibling,
1122                       gpointer  data)
1123 {
1124   g_return_if_fail (queue != NULL);
1125 
1126   if (sibling == NULL)
1127     g_queue_push_head (queue, data);
1128   else
1129     g_queue_insert_before (queue, sibling-&gt;next, data);
1130 }
1131 
<span class="line-added">1132 /**</span>
<span class="line-added">1133  * g_queue_insert_after_link:</span>
<span class="line-added">1134  * @queue: a #GQueue</span>
<span class="line-added">1135  * @sibling: (nullable): a #GList link that must be part of @queue, or %NULL to</span>
<span class="line-added">1136  *   push at the head of the queue.</span>
<span class="line-added">1137  * @link_: a #GList link to insert which must not be part of any other list.</span>
<span class="line-added">1138  *</span>
<span class="line-added">1139  * Inserts @link_ into @queue after @sibling.</span>
<span class="line-added">1140  *</span>
<span class="line-added">1141  * @sibling must be part of @queue.</span>
<span class="line-added">1142  *</span>
<span class="line-added">1143  * Since: 2.62</span>
<span class="line-added">1144  */</span>
<span class="line-added">1145 void</span>
<span class="line-added">1146 g_queue_insert_after_link (GQueue   *queue,</span>
<span class="line-added">1147                            GList    *sibling,</span>
<span class="line-added">1148                            GList    *link_)</span>
<span class="line-added">1149 {</span>
<span class="line-added">1150   g_return_if_fail (queue != NULL);</span>
<span class="line-added">1151   g_return_if_fail (link_ != NULL);</span>
<span class="line-added">1152   g_return_if_fail (link_-&gt;prev == NULL);</span>
<span class="line-added">1153   g_return_if_fail (link_-&gt;next == NULL);</span>
<span class="line-added">1154 </span>
<span class="line-added">1155   if G_UNLIKELY (sibling == NULL)</span>
<span class="line-added">1156     g_queue_push_head_link (queue, link_);</span>
<span class="line-added">1157   else</span>
<span class="line-added">1158     g_queue_insert_before_link (queue, sibling-&gt;next, link_);</span>
<span class="line-added">1159 }</span>
<span class="line-added">1160 </span>
1161 /**
1162  * g_queue_insert_sorted:
1163  * @queue: a #GQueue
1164  * @data: the data to insert
1165  * @func: the #GCompareDataFunc used to compare elements in the queue. It is
1166  *     called with two elements of the @queue and @user_data. It should
1167  *     return 0 if the elements are equal, a negative value if the first
1168  *     element comes before the second, and a positive value if the second
1169  *     element comes before the first.
1170  * @user_data: user data passed to @func
1171  *
1172  * Inserts @data into @queue using @func to determine the new position.
1173  *
1174  * Since: 2.4
1175  */
1176 void
1177 g_queue_insert_sorted (GQueue           *queue,
1178                        gpointer          data,
1179                        GCompareDataFunc  func,
1180                        gpointer          user_data)
1181 {
1182   GList *list;
1183 
1184   g_return_if_fail (queue != NULL);
1185 
1186   list = queue-&gt;head;
1187   while (list &amp;&amp; func (list-&gt;data, data, user_data) &lt; 0)
1188     list = list-&gt;next;
1189 
<span class="line-modified">1190   g_queue_insert_before (queue, list, data);</span>
1191 }
</pre>
</td>
</tr>
</table>
<center><a href="gquark.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gqueue.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>