<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gsttaglist.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gsttaglist.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gsttask.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gsttaglist.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 468  * Returns: the same #GstTagList mini object.
 469  */
 470 static inline GstTagList *
 471 gst_tag_list_ref (GstTagList * taglist)
 472 {
 473   return (GstTagList *) gst_mini_object_ref (GST_MINI_OBJECT_CAST (taglist));
 474 }
 475 
 476 /**
 477  * gst_tag_list_unref:
 478  * @taglist: a #GstTagList.
 479  *
 480  * Unref a #GstTagList, and and free all its memory when the refcount reaches 0.
 481  */
 482 static inline void
 483 gst_tag_list_unref (GstTagList * taglist)
 484 {
 485   gst_mini_object_unref (GST_MINI_OBJECT_CAST (taglist));
 486 }
 487 



















 488 /**
 489  * gst_tag_list_copy:
 490  * @taglist: a #GstTagList.
 491  *
 492  * Creates a new #GstTagList as a copy of the old @taglist. The new taglist
 493  * will have a refcount of 1, owned by the caller, and will be writable as
 494  * a result.
 495  *
 496  * Note that this function is the semantic equivalent of a gst_tag_list_ref()
 497  * followed by a gst_tag_list_make_writable(). If you only want to hold on to a
 498  * reference to the data, you should use gst_tag_list_ref().
 499  *
 500  * When you are finished with the taglist, call gst_tag_list_unref() on it.
 501  *
 502  * Returns: the new #GstTagList
 503  */
 504 static inline GstTagList *
 505 gst_tag_list_copy (const GstTagList * taglist)
 506 {
 507   return GST_TAG_LIST (gst_mini_object_copy (GST_MINI_OBJECT_CAST (taglist)));
 508 }
 509 
















































 510 /**
 511  * gst_tag_list_is_writable:
 512  * @taglist: a #GstTagList
 513  *
 514  * Tests if you can safely modify @taglist. It is only safe to modify taglist
 515  * when there is only one owner of the taglist - ie, the refcount is 1.
 516  */
 517 #define gst_tag_list_is_writable(taglist)    gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (taglist))
 518 
 519 /**
 520  * gst_tag_list_make_writable:
 521  * @taglist: (transfer full): a #GstTagList
 522  *
 523  * Returns a writable copy of @taglist.
 524  *
 525  * If there is only one reference count on @taglist, the caller must be the
 526  * owner, and so this function will return the taglist object unchanged. If on
 527  * the other hand there is more than one reference on the object, a new taglist
 528  * object will be returned (which will be a copy of @taglist). The caller&#39;s
 529  * reference on @taglist will be removed, and instead the caller will own a
</pre>
</td>
<td>
<hr />
<pre>
 468  * Returns: the same #GstTagList mini object.
 469  */
 470 static inline GstTagList *
 471 gst_tag_list_ref (GstTagList * taglist)
 472 {
 473   return (GstTagList *) gst_mini_object_ref (GST_MINI_OBJECT_CAST (taglist));
 474 }
 475 
 476 /**
 477  * gst_tag_list_unref:
 478  * @taglist: a #GstTagList.
 479  *
 480  * Unref a #GstTagList, and and free all its memory when the refcount reaches 0.
 481  */
 482 static inline void
 483 gst_tag_list_unref (GstTagList * taglist)
 484 {
 485   gst_mini_object_unref (GST_MINI_OBJECT_CAST (taglist));
 486 }
 487 
<span class="line-added"> 488 /**</span>
<span class="line-added"> 489  * gst_clear_tag_list: (skip)</span>
<span class="line-added"> 490  * @taglist_ptr: a pointer to a #GstTagList reference</span>
<span class="line-added"> 491  *</span>
<span class="line-added"> 492  * Clears a reference to a #GstTagList.</span>
<span class="line-added"> 493  *</span>
<span class="line-added"> 494  * @taglist_ptr must not be %NULL.</span>
<span class="line-added"> 495  *</span>
<span class="line-added"> 496  * If the reference is %NULL then this function does nothing. Otherwise, the</span>
<span class="line-added"> 497  * reference count of the taglist is decreased and the pointer is set to %NULL.</span>
<span class="line-added"> 498  *</span>
<span class="line-added"> 499  * Since: 1.16</span>
<span class="line-added"> 500  */</span>
<span class="line-added"> 501 static inline void</span>
<span class="line-added"> 502 gst_clear_tag_list (GstTagList ** taglist_ptr)</span>
<span class="line-added"> 503 {</span>
<span class="line-added"> 504   gst_clear_mini_object ((GstMiniObject **) taglist_ptr);</span>
<span class="line-added"> 505 }</span>
<span class="line-added"> 506 </span>
 507 /**
 508  * gst_tag_list_copy:
 509  * @taglist: a #GstTagList.
 510  *
 511  * Creates a new #GstTagList as a copy of the old @taglist. The new taglist
 512  * will have a refcount of 1, owned by the caller, and will be writable as
 513  * a result.
 514  *
 515  * Note that this function is the semantic equivalent of a gst_tag_list_ref()
 516  * followed by a gst_tag_list_make_writable(). If you only want to hold on to a
 517  * reference to the data, you should use gst_tag_list_ref().
 518  *
 519  * When you are finished with the taglist, call gst_tag_list_unref() on it.
 520  *
 521  * Returns: the new #GstTagList
 522  */
 523 static inline GstTagList *
 524 gst_tag_list_copy (const GstTagList * taglist)
 525 {
 526   return GST_TAG_LIST (gst_mini_object_copy (GST_MINI_OBJECT_CAST (taglist)));
 527 }
 528 
<span class="line-added"> 529 /**</span>
<span class="line-added"> 530  * gst_tag_list_replace:</span>
<span class="line-added"> 531  * @old_taglist: (inout) (transfer full) (nullable): pointer to a pointer to a</span>
<span class="line-added"> 532  *     #GstTagList to be replaced.</span>
<span class="line-added"> 533  * @new_taglist: (transfer none) (allow-none): pointer to a #GstTagList that</span>
<span class="line-added"> 534  *     will replace the tag list pointed to by @old_taglist.</span>
<span class="line-added"> 535  *</span>
<span class="line-added"> 536  * Modifies a pointer to a #GstTagList to point to a different #GstTagList. The</span>
<span class="line-added"> 537  * modification is done atomically (so this is useful for ensuring thread</span>
<span class="line-added"> 538  * safety in some cases), and the reference counts are updated appropriately</span>
<span class="line-added"> 539  * (the old tag list is unreffed, the new is reffed).</span>
<span class="line-added"> 540  *</span>
<span class="line-added"> 541  * Either @new_taglist or the #GstTagList pointed to by @old_taglist may be</span>
<span class="line-added"> 542  * %NULL.</span>
<span class="line-added"> 543  *</span>
<span class="line-added"> 544  * Returns: %TRUE if @new_taglist was different from @old_taglist</span>
<span class="line-added"> 545  *</span>
<span class="line-added"> 546  * Since: 1.16</span>
<span class="line-added"> 547  */</span>
<span class="line-added"> 548 static inline gboolean</span>
<span class="line-added"> 549 gst_tag_list_replace (GstTagList **old_taglist, GstTagList *new_taglist)</span>
<span class="line-added"> 550 {</span>
<span class="line-added"> 551     return gst_mini_object_replace ((GstMiniObject **) old_taglist,</span>
<span class="line-added"> 552         (GstMiniObject *) new_taglist);</span>
<span class="line-added"> 553 }</span>
<span class="line-added"> 554 </span>
<span class="line-added"> 555 /**</span>
<span class="line-added"> 556  * gst_tag_list_take:</span>
<span class="line-added"> 557  * @old_taglist: (inout) (transfer full): pointer to a pointer to a #GstTagList</span>
<span class="line-added"> 558  *     to be replaced.</span>
<span class="line-added"> 559  * @new_taglist: (transfer full) (allow-none): pointer to a #GstTagList that</span>
<span class="line-added"> 560  *     will replace the taglist pointed to by @old_taglist.</span>
<span class="line-added"> 561  *</span>
<span class="line-added"> 562  * Modifies a pointer to a #GstTagList to point to a different #GstTagList.</span>
<span class="line-added"> 563  * This function is similar to gst_tag_list_replace() except that it takes</span>
<span class="line-added"> 564  * ownership of @new_taglist.</span>
<span class="line-added"> 565  *</span>
<span class="line-added"> 566  * Returns: %TRUE if @new_taglist was different from @old_taglist</span>
<span class="line-added"> 567  *</span>
<span class="line-added"> 568  * Since: 1.16</span>
<span class="line-added"> 569  */</span>
<span class="line-added"> 570 static inline gboolean</span>
<span class="line-added"> 571 gst_tag_list_take (GstTagList **old_taglist, GstTagList *new_taglist)</span>
<span class="line-added"> 572 {</span>
<span class="line-added"> 573   return gst_mini_object_take ((GstMiniObject **) old_taglist,</span>
<span class="line-added"> 574       (GstMiniObject *) new_taglist);</span>
<span class="line-added"> 575 }</span>
<span class="line-added"> 576 </span>
 577 /**
 578  * gst_tag_list_is_writable:
 579  * @taglist: a #GstTagList
 580  *
 581  * Tests if you can safely modify @taglist. It is only safe to modify taglist
 582  * when there is only one owner of the taglist - ie, the refcount is 1.
 583  */
 584 #define gst_tag_list_is_writable(taglist)    gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (taglist))
 585 
 586 /**
 587  * gst_tag_list_make_writable:
 588  * @taglist: (transfer full): a #GstTagList
 589  *
 590  * Returns a writable copy of @taglist.
 591  *
 592  * If there is only one reference count on @taglist, the caller must be the
 593  * owner, and so this function will return the taglist object unchanged. If on
 594  * the other hand there is more than one reference on the object, a new taglist
 595  * object will be returned (which will be a copy of @taglist). The caller&#39;s
 596  * reference on @taglist will be removed, and instead the caller will own a
</pre>
</td>
</tr>
</table>
<center><a href="gsttaglist.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gsttask.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>