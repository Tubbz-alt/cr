<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvarianttype.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gvariant.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvarianttype.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvarianttype.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright � 2007, 2008 Ryan Lortie</span>
<span class="line-modified">   3  * Copyright � 2009, 2010 Codethink Limited</span>
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public
  16  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  *
  18  * Author: Ryan Lortie &lt;desrt@desrt.ca&gt;
  19  */
  20 
  21 #include &quot;config.h&quot;
  22 
  23 #include &quot;gvarianttype.h&quot;
</pre>
<hr />
<pre>
 183  * that, due to the restriction that the key of a dictionary entry must
 184  * be a basic type, &quot;{**}&quot; is not a valid type string.
 185  */
 186 
 187 
 188 static gboolean
 189 g_variant_type_check (const GVariantType *type)
 190 {
 191   if (type == NULL)
 192     return FALSE;
 193 
 194 #if 0
 195   return g_variant_type_string_scan ((const gchar *) type, NULL, NULL);
 196 #else
 197   return TRUE;
 198 #endif
 199 }
 200 
 201 static gboolean
 202 variant_type_string_scan_internal (const gchar  *string,
<span class="line-modified"> 203                             const gchar  *limit,</span>
 204                                    const gchar **endptr,
 205                                    gsize        *depth,
 206                                    gsize         depth_limit)
 207 {
 208   gsize max_depth = 0, child_depth;
 209 
 210   g_return_val_if_fail (string != NULL, FALSE);
 211 
 212   if (string == limit || *string == &#39;\0&#39;)
 213     return FALSE;
 214 
 215   switch (*string++)
 216     {
 217     case &#39;(&#39;:
 218       while (string == limit || *string != &#39;)&#39;)
 219         {
 220           if (depth_limit == 0 ||
 221               !variant_type_string_scan_internal (string, limit, &amp;string,
 222                                                   &amp;child_depth,
 223                                                   depth_limit - 1))
<span class="line-modified"> 224           return FALSE;</span>
 225 
 226           max_depth = MAX (max_depth, child_depth + 1);
 227         }
 228 
 229       string++;
 230       break;
 231 
 232     case &#39;{&#39;:
 233       if (depth_limit == 0 ||
 234           string == limit || *string == &#39;\0&#39; ||                                  /* { */
 235           !strchr (&quot;bynqihuxtdsog?&quot;, *string++) ||                               /* key */
 236           !variant_type_string_scan_internal (string, limit, &amp;string,
 237                                               &amp;child_depth, depth_limit - 1) ||  /* value */
 238           string == limit || *string++ != &#39;}&#39;)                                   /* } */
 239         return FALSE;
 240 
 241       max_depth = MAX (max_depth, child_depth + 1);
 242       break;
 243 
 244     case &#39;m&#39;: case &#39;a&#39;:
</pre>
<hr />
<pre>
 295 gboolean
 296 g_variant_type_string_scan (const gchar  *string,
 297                             const gchar  *limit,
 298                             const gchar **endptr)
 299 {
 300   return variant_type_string_scan_internal (string, limit, endptr, NULL,
 301                                             G_VARIANT_MAX_RECURSION_DEPTH);
 302 }
 303 
 304 /* &lt; private &gt;
 305  * g_variant_type_string_get_depth_:
 306  * @type_string: a pointer to any string
 307  *
 308  * Get the maximum depth of the nested types in @type_string. A basic type will
 309  * return depth 1, and a container type will return a greater value. The depth
 310  * of a tuple is 1 plus the depth of its deepest child type.
 311  *
 312  * If @type_string is not a valid #GVariant type string, 0 will be returned.
 313  *
 314  * Returns: depth of @type_string, or 0 on error
<span class="line-modified"> 315  * Since: 2.60 (backported to 2.58)</span>
 316  */
 317 gsize
 318 g_variant_type_string_get_depth_ (const gchar *type_string)
 319 {
 320   const gchar *endptr;
 321   gsize depth = 0;
 322 
 323   g_return_val_if_fail (type_string != NULL, 0);
 324 
 325   if (!variant_type_string_scan_internal (type_string, NULL, &amp;endptr, &amp;depth,
 326                                           G_VARIANT_MAX_RECURSION_DEPTH) ||
 327       *endptr != &#39;\0&#39;)
 328     return 0;
 329 
 330   return depth;
 331 }
 332 
 333 /**
 334  * g_variant_type_string_is_valid:
 335  * @type_string: a pointer to any string
</pre>
<hr />
<pre>
1071   g_assert (type_string[0] == &#39;{&#39;);
1072 
1073   return (const GVariantType *) &amp;type_string[1];
1074 }
1075 
1076 /**
1077  * g_variant_type_value:
1078  * @type: a dictionary entry #GVariantType
1079  *
1080  * Determines the value type of a dictionary entry type.
1081  *
1082  * This function may only be used with a dictionary entry type.
1083  *
1084  * Returns: (transfer none): the value type of the dictionary entry
1085  *
1086  * Since 2.24
1087  **/
1088 const GVariantType *
1089 g_variant_type_value (const GVariantType *type)
1090 {

1091   const gchar *type_string;

1092 
1093   g_return_val_if_fail (g_variant_type_check (type), NULL);
1094 

1095   type_string = g_variant_type_peek_string (type);
1096   g_assert (type_string[0] == &#39;{&#39;);

1097 
1098   return g_variant_type_next (g_variant_type_key (type));
1099 }
1100 
1101 /**
1102  * g_variant_type_new_tuple:
1103  * @items: (array length=length): an array of #GVariantTypes, one for each item
1104  * @length: the length of @items, or -1
1105  *
1106  * Constructs a new tuple type, from @items.
1107  *
1108  * @length is the number of items in @items, or -1 to indicate that
1109  * @items is %NULL-terminated.
1110  *
1111  * It is appropriate to call g_variant_type_free() on the return value.
1112  *
1113  * Returns: (transfer full): a new tuple #GVariantType
1114  *
1115  * Since 2.24
1116  **/
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2007, 2008 Ryan Lortie</span>
<span class="line-modified">   3  * Copyright (C) 2009, 2010 Codethink Limited</span>
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public
  16  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  *
  18  * Author: Ryan Lortie &lt;desrt@desrt.ca&gt;
  19  */
  20 
  21 #include &quot;config.h&quot;
  22 
  23 #include &quot;gvarianttype.h&quot;
</pre>
<hr />
<pre>
 183  * that, due to the restriction that the key of a dictionary entry must
 184  * be a basic type, &quot;{**}&quot; is not a valid type string.
 185  */
 186 
 187 
 188 static gboolean
 189 g_variant_type_check (const GVariantType *type)
 190 {
 191   if (type == NULL)
 192     return FALSE;
 193 
 194 #if 0
 195   return g_variant_type_string_scan ((const gchar *) type, NULL, NULL);
 196 #else
 197   return TRUE;
 198 #endif
 199 }
 200 
 201 static gboolean
 202 variant_type_string_scan_internal (const gchar  *string,
<span class="line-modified"> 203                                    const gchar  *limit,</span>
 204                                    const gchar **endptr,
 205                                    gsize        *depth,
 206                                    gsize         depth_limit)
 207 {
 208   gsize max_depth = 0, child_depth;
 209 
 210   g_return_val_if_fail (string != NULL, FALSE);
 211 
 212   if (string == limit || *string == &#39;\0&#39;)
 213     return FALSE;
 214 
 215   switch (*string++)
 216     {
 217     case &#39;(&#39;:
 218       while (string == limit || *string != &#39;)&#39;)
 219         {
 220           if (depth_limit == 0 ||
 221               !variant_type_string_scan_internal (string, limit, &amp;string,
 222                                                   &amp;child_depth,
 223                                                   depth_limit - 1))
<span class="line-modified"> 224             return FALSE;</span>
 225 
 226           max_depth = MAX (max_depth, child_depth + 1);
 227         }
 228 
 229       string++;
 230       break;
 231 
 232     case &#39;{&#39;:
 233       if (depth_limit == 0 ||
 234           string == limit || *string == &#39;\0&#39; ||                                  /* { */
 235           !strchr (&quot;bynqihuxtdsog?&quot;, *string++) ||                               /* key */
 236           !variant_type_string_scan_internal (string, limit, &amp;string,
 237                                               &amp;child_depth, depth_limit - 1) ||  /* value */
 238           string == limit || *string++ != &#39;}&#39;)                                   /* } */
 239         return FALSE;
 240 
 241       max_depth = MAX (max_depth, child_depth + 1);
 242       break;
 243 
 244     case &#39;m&#39;: case &#39;a&#39;:
</pre>
<hr />
<pre>
 295 gboolean
 296 g_variant_type_string_scan (const gchar  *string,
 297                             const gchar  *limit,
 298                             const gchar **endptr)
 299 {
 300   return variant_type_string_scan_internal (string, limit, endptr, NULL,
 301                                             G_VARIANT_MAX_RECURSION_DEPTH);
 302 }
 303 
 304 /* &lt; private &gt;
 305  * g_variant_type_string_get_depth_:
 306  * @type_string: a pointer to any string
 307  *
 308  * Get the maximum depth of the nested types in @type_string. A basic type will
 309  * return depth 1, and a container type will return a greater value. The depth
 310  * of a tuple is 1 plus the depth of its deepest child type.
 311  *
 312  * If @type_string is not a valid #GVariant type string, 0 will be returned.
 313  *
 314  * Returns: depth of @type_string, or 0 on error
<span class="line-modified"> 315  * Since: 2.60</span>
 316  */
 317 gsize
 318 g_variant_type_string_get_depth_ (const gchar *type_string)
 319 {
 320   const gchar *endptr;
 321   gsize depth = 0;
 322 
 323   g_return_val_if_fail (type_string != NULL, 0);
 324 
 325   if (!variant_type_string_scan_internal (type_string, NULL, &amp;endptr, &amp;depth,
 326                                           G_VARIANT_MAX_RECURSION_DEPTH) ||
 327       *endptr != &#39;\0&#39;)
 328     return 0;
 329 
 330   return depth;
 331 }
 332 
 333 /**
 334  * g_variant_type_string_is_valid:
 335  * @type_string: a pointer to any string
</pre>
<hr />
<pre>
1071   g_assert (type_string[0] == &#39;{&#39;);
1072 
1073   return (const GVariantType *) &amp;type_string[1];
1074 }
1075 
1076 /**
1077  * g_variant_type_value:
1078  * @type: a dictionary entry #GVariantType
1079  *
1080  * Determines the value type of a dictionary entry type.
1081  *
1082  * This function may only be used with a dictionary entry type.
1083  *
1084  * Returns: (transfer none): the value type of the dictionary entry
1085  *
1086  * Since 2.24
1087  **/
1088 const GVariantType *
1089 g_variant_type_value (const GVariantType *type)
1090 {
<span class="line-added">1091 #ifndef G_DISABLE_ASSERT</span>
1092   const gchar *type_string;
<span class="line-added">1093 #endif</span>
1094 
1095   g_return_val_if_fail (g_variant_type_check (type), NULL);
1096 
<span class="line-added">1097 #ifndef G_DISABLE_ASSERT</span>
1098   type_string = g_variant_type_peek_string (type);
1099   g_assert (type_string[0] == &#39;{&#39;);
<span class="line-added">1100 #endif</span>
1101 
1102   return g_variant_type_next (g_variant_type_key (type));
1103 }
1104 
1105 /**
1106  * g_variant_type_new_tuple:
1107  * @items: (array length=length): an array of #GVariantTypes, one for each item
1108  * @length: the length of @items, or -1
1109  *
1110  * Constructs a new tuple type, from @items.
1111  *
1112  * @length is the number of items in @items, or -1 to indicate that
1113  * @items is %NULL-terminated.
1114  *
1115  * It is appropriate to call g_variant_type_free() on the return value.
1116  *
1117  * Returns: (transfer full): a new tuple #GVariantType
1118  *
1119  * Since 2.24
1120  **/
</pre>
</td>
</tr>
</table>
<center><a href="gvariant.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvarianttype.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>