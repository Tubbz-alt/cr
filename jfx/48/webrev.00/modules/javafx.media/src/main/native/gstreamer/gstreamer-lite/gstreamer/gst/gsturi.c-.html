<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gsturi.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wtay@chello.be&gt;
   4  * Copyright (C) 2011 Tim-Philipp MÃ¼ller &lt;tim centricular net&gt;
   5  * Copyright (C) 2014 David Waring, British Broadcasting Corporation
   6  *                        &lt;david.waring@rd.bbc.co.uk&gt;
   7  *
   8  * gsturi.c: register URI handlers and IETF RFC 3986 URI manipulations.
   9  *
  10  * This library is free software; you can redistribute it and/or
  11  * modify it under the terms of the GNU Library General Public
  12  * License as published by the Free Software Foundation; either
  13  * version 2 of the License, or (at your option) any later version.
  14  *
  15  * This library is distributed in the hope that it will be useful,
  16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18  * Library General Public License for more details.
  19  *
  20  * You should have received a copy of the GNU Library General Public
  21  * License along with this library; if not, write to the
  22  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  23  * Boston, MA 02110-1301, USA.
  24  */
  25 
  26 /**
  27  * SECTION:gsturihandler
  28  * @title: GstUriHandler
  29  * @short_description: Interface to ease URI handling in plugins.
  30  *
  31  * The #GstURIHandler is an interface that is implemented by Source and Sink
  32  * #GstElement to unify handling of URI.
  33  *
  34  * An application can use the following functions to quickly get an element
  35  * that handles the given URI for reading or writing
  36  * (gst_element_make_from_uri()).
  37  *
  38  * Source and Sink plugins should implement this interface when possible.
  39  */
  40 
  41 #ifdef HAVE_CONFIG_H
  42 #  include &quot;config.h&quot;
  43 #endif
  44 
  45 #include &quot;gst_private.h&quot;
  46 #include &quot;gst.h&quot;
  47 #include &quot;gsturi.h&quot;
  48 #include &quot;gstinfo.h&quot;
  49 #include &quot;gstregistry.h&quot;
  50 
  51 #include &quot;gst-i18n-lib.h&quot;
  52 
  53 #include &lt;string.h&gt;
  54 #include &lt;glib.h&gt;
  55 #include &lt;glib/gprintf.h&gt;
  56 
  57 GST_DEBUG_CATEGORY_STATIC (gst_uri_handler_debug);
  58 #define GST_CAT_DEFAULT gst_uri_handler_debug
  59 
  60 #ifndef HAVE_STRCASESTR
  61 #define strcasestr _gst_ascii_strcasestr
  62 
  63 /* From https://github.com/freebsd/freebsd/blob/master/contrib/file/src/strcasestr.c
  64  * Updated to use GLib types and GLib string functions
  65  *
  66  * Copyright (c) 1990, 1993
  67  *  The Regents of the University of California.  All rights reserved.
  68  *
  69  * This code is derived from software contributed to Berkeley by
  70  * Chris Torek.
  71  *
  72  * Redistribution and use in source and binary forms, with or without
  73  * modification, are permitted provided that the following conditions
  74  * are met:
  75  * 1. Redistributions of source code must retain the above copyright
  76  *    notice, this list of conditions and the following disclaimer.
  77  * 2. Redistributions in binary form must reproduce the above copyright
  78  *    notice, this list of conditions and the following disclaimer in the
  79  *    documentation and/or other materials provided with the distribution.
  80  * 3. Neither the name of the University nor the names of its contributors
  81  *    may be used to endorse or promote products derived from this software
  82  *    without specific prior written permission.
  83  *
  84  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS&#39;&#39; AND
  85  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  86  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  87  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
  88  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
  89  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
  90  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
  91  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
  92  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
  93  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
  94  * SUCH DAMAGE.
  95  */
  96 
  97 /*
  98  * Find the first occurrence of find in s, ignore case.
  99  */
 100 
 101 static gchar *
 102 _gst_ascii_strcasestr (const gchar * s, const gchar * find)
 103 {
 104   gchar c, sc;
 105   gsize len;
 106 
 107   if ((c = *find++) != 0) {
 108     c = g_ascii_tolower (c);
 109     len = strlen (find);
 110     do {
 111       do {
 112         if ((sc = *s++) == 0)
 113           return (NULL);
 114       } while (g_ascii_tolower (sc) != c);
 115     } while (g_ascii_strncasecmp (s, find, len) != 0);
 116     s--;
 117   }
 118   return (gchar *) (gintptr) (s);
 119 }
 120 #endif
 121 
 122 GType
 123 gst_uri_handler_get_type (void)
 124 {
 125   static volatile gsize urihandler_type = 0;
 126 
 127   if (g_once_init_enter (&amp;urihandler_type)) {
 128     GType _type;
 129     static const GTypeInfo urihandler_info = {
 130       sizeof (GstURIHandlerInterface),
 131       NULL,
 132       NULL,
 133       NULL,
 134       NULL,
 135       NULL,
 136       0,
 137       0,
 138       NULL,
 139       NULL
 140     };
 141 
 142     _type = g_type_register_static (G_TYPE_INTERFACE,
 143         &quot;GstURIHandler&quot;, &amp;urihandler_info, 0);
 144 
 145     GST_DEBUG_CATEGORY_INIT (gst_uri_handler_debug, &quot;GST_URI&quot;, GST_DEBUG_BOLD,
 146         &quot;handling of URIs&quot;);
 147     g_once_init_leave (&amp;urihandler_type, _type);
 148   }
 149   return urihandler_type;
 150 }
 151 
 152 GQuark
 153 gst_uri_error_quark (void)
 154 {
 155   return g_quark_from_static_string (&quot;gst-uri-error-quark&quot;);
 156 }
 157 
 158 #define HEX_ESCAPE &#39;%&#39;
 159 
 160 #ifndef GST_REMOVE_DEPRECATED
 161 static const guchar acceptable[96] = {  /* X0   X1   X2   X3   X4   X5   X6   X7   X8   X9   XA   XB   XC   XD   XE   XF */
 162   0x00, 0x3F, 0x20, 0x20, 0x20, 0x00, 0x2C, 0x3F, 0x3F, 0x3F, 0x3F, 0x22, 0x20, 0x3F, 0x3F, 0x1C,       /* 2X  !&quot;#$%&amp;&#39;()*+,-./   */
 163   0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x38, 0x20, 0x20, 0x2C, 0x20, 0x2C,       /* 3X 0123456789:;&lt;=&gt;?   */
 164   0x30, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,       /* 4X @ABCDEFGHIJKLMNO   */
 165   0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x20, 0x20, 0x20, 0x20, 0x3F,       /* 5X PQRSTUVWXYZ[\]^_   */
 166   0x20, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,       /* 6X `abcdefghijklmno   */
 167   0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x20, 0x20, 0x20, 0x3F, 0x20        /* 7X pqrstuvwxyz{|}~DEL */
 168 };
 169 
 170 typedef enum
 171 {
 172   UNSAFE_ALL = 0x1,             /* Escape all unsafe characters   */
 173   UNSAFE_ALLOW_PLUS = 0x2,      /* Allows &#39;+&#39;  */
 174   UNSAFE_PATH = 0x4,            /* Allows &#39;/&#39; and &#39;?&#39; and &#39;&amp;&#39; and &#39;=&#39;  */
 175   UNSAFE_DOS_PATH = 0x8,        /* Allows &#39;/&#39; and &#39;?&#39; and &#39;&amp;&#39; and &#39;=&#39; and &#39;:&#39; */
 176   UNSAFE_HOST = 0x10,           /* Allows &#39;/&#39; and &#39;:&#39; and &#39;@&#39; */
 177   UNSAFE_SLASHES = 0x20         /* Allows all characters except for &#39;/&#39; and &#39;%&#39; */
 178 } UnsafeCharacterSet;
 179 
 180 /*  Escape undesirable characters using %
 181  *  -------------------------------------
 182  *
 183  * This function takes a pointer to a string in which
 184  * some characters may be unacceptable unescaped.
 185  * It returns a string which has these characters
 186  * represented by a &#39;%&#39; character followed by two hex digits.
 187  *
 188  * This routine returns a g_malloced string.
 189  */
 190 
 191 static const gchar hex[16] = &quot;0123456789ABCDEF&quot;;
 192 
 193 static gchar *
 194 escape_string_internal (const gchar * string, UnsafeCharacterSet mask)
 195 {
 196 #define ACCEPTABLE_CHAR(a) ((a)&gt;=32 &amp;&amp; (a)&lt;128 &amp;&amp; (acceptable[(a)-32] &amp; use_mask))
 197 
 198   const gchar *p;
 199   gchar *q;
 200   gchar *result;
 201   guchar c;
 202   gint unacceptable;
 203   UnsafeCharacterSet use_mask;
 204 
 205   g_return_val_if_fail (mask == UNSAFE_ALL
 206       || mask == UNSAFE_ALLOW_PLUS
 207       || mask == UNSAFE_PATH
 208       || mask == UNSAFE_DOS_PATH
 209       || mask == UNSAFE_HOST || mask == UNSAFE_SLASHES, NULL);
 210 
 211   if (string == NULL) {
 212     return NULL;
 213   }
 214 
 215   unacceptable = 0;
 216   use_mask = mask;
 217   for (p = string; *p != &#39;\0&#39;; p++) {
 218     c = *p;
 219     if (!ACCEPTABLE_CHAR (c)) {
 220       unacceptable++;
 221     }
 222     if ((use_mask == UNSAFE_HOST) &amp;&amp; (unacceptable || (c == &#39;/&#39;))) {
 223       /* when escaping a host, if we hit something that needs to be escaped, or we finally
 224        * hit a path separator, revert to path mode (the host segment of the url is over).
 225        */
 226       use_mask = UNSAFE_PATH;
 227     }
 228   }
 229 
 230   result = g_malloc (p - string + unacceptable * 2 + 1);
 231 
 232   use_mask = mask;
 233   for (q = result, p = string; *p != &#39;\0&#39;; p++) {
 234     c = *p;
 235 
 236     if (!ACCEPTABLE_CHAR (c)) {
 237       *q++ = HEX_ESCAPE;        /* means hex coming */
 238       *q++ = hex[c &gt;&gt; 4];
 239       *q++ = hex[c &amp; 15];
 240     } else {
 241       *q++ = c;
 242     }
 243     if ((use_mask == UNSAFE_HOST) &amp;&amp; (!ACCEPTABLE_CHAR (c) || (c == &#39;/&#39;))) {
 244       use_mask = UNSAFE_PATH;
 245     }
 246   }
 247 
 248   *q = &#39;\0&#39;;
 249 
 250   return result;
 251 }
 252 #endif
 253 
 254 static int
 255 hex_to_int (gchar c)
 256 {
 257   return c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39; ? c - &#39;0&#39;
 258       : c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;F&#39; ? c - &#39;A&#39; + 10
 259       : c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;f&#39; ? c - &#39;a&#39; + 10 : -1;
 260 }
 261 
 262 static int
 263 unescape_character (const char *scanner)
 264 {
 265   int first_digit;
 266   int second_digit;
 267 
 268   first_digit = hex_to_int (*scanner++);
 269   if (first_digit &lt; 0) {
 270     return -1;
 271   }
 272 
 273   second_digit = hex_to_int (*scanner);
 274   if (second_digit &lt; 0) {
 275     return -1;
 276   }
 277 
 278   return (first_digit &lt;&lt; 4) | second_digit;
 279 }
 280 
 281 /* unescape_string:
 282  * @escaped_string: an escaped URI, path, or other string
 283  * @illegal_characters: a string containing a sequence of characters
 284  * considered &quot;illegal&quot;, &#39;\0&#39; is automatically in this list.
 285  *
 286  * Decodes escaped characters (i.e. PERCENTxx sequences) in @escaped_string.
 287  * Characters are encoded in PERCENTxy form, where xy is the ASCII hex code
 288  * for character 16x+y.
 289  *
 290  * Return value: (nullable): a newly allocated string with the
 291  * unescaped equivalents, or %NULL if @escaped_string contained one of
 292  * the characters in @illegal_characters.
 293  **/
 294 static char *
 295 unescape_string (const gchar * escaped_string, const gchar * illegal_characters)
 296 {
 297   const gchar *in;
 298   gchar *out, *result;
 299   gint character;
 300 
 301   if (escaped_string == NULL) {
 302     return NULL;
 303   }
 304 
 305   result = g_malloc (strlen (escaped_string) + 1);
 306 
 307   out = result;
 308   for (in = escaped_string; *in != &#39;\0&#39;; in++) {
 309     character = *in;
 310     if (*in == HEX_ESCAPE) {
 311       character = unescape_character (in + 1);
 312 
 313       /* Check for an illegal character. We consider &#39;\0&#39; illegal here. */
 314       if (character &lt;= 0
 315           || (illegal_characters != NULL
 316               &amp;&amp; strchr (illegal_characters, (char) character) != NULL)) {
 317         g_free (result);
 318         return NULL;
 319       }
 320       in += 2;
 321     }
 322     *out++ = (char) character;
 323   }
 324 
 325   *out = &#39;\0&#39;;
 326   g_assert ((gsize) (out - result) &lt;= strlen (escaped_string));
 327   return result;
 328 
 329 }
 330 
 331 
 332 static void
 333 gst_uri_protocol_check_internal (const gchar * uri, gchar ** endptr)
 334 {
 335   gchar *check = (gchar *) uri;
 336 
 337   g_assert (uri != NULL);
 338   g_assert (endptr != NULL);
 339 
 340   if (g_ascii_isalpha (*check)) {
 341     check++;
 342     while (g_ascii_isalnum (*check) || *check == &#39;+&#39;
 343         || *check == &#39;-&#39; || *check == &#39;.&#39;)
 344       check++;
 345   }
 346 
 347   *endptr = check;
 348 }
 349 
 350 /**
 351  * gst_uri_protocol_is_valid:
 352  * @protocol: A string
 353  *
 354  * Tests if the given string is a valid protocol identifier. Protocols
 355  * must consist of alphanumeric characters, &#39;+&#39;, &#39;-&#39; and &#39;.&#39; and must
 356  * start with a alphabetic character. See RFC 3986 Section 3.1.
 357  *
 358  * Returns: %TRUE if the string is a valid protocol identifier, %FALSE otherwise.
 359  */
 360 gboolean
 361 gst_uri_protocol_is_valid (const gchar * protocol)
 362 {
 363   gchar *endptr;
 364 
 365   g_return_val_if_fail (protocol != NULL, FALSE);
 366 
 367   gst_uri_protocol_check_internal (protocol, &amp;endptr);
 368 
 369   return *endptr == &#39;\0&#39; &amp;&amp; ((gsize) (endptr - protocol)) &gt;= 2;
 370 }
 371 
 372 /**
 373  * gst_uri_is_valid:
 374  * @uri: A URI string
 375  *
 376  * Tests if the given string is a valid URI identifier. URIs start with a valid
 377  * scheme followed by &quot;:&quot; and maybe a string identifying the location.
 378  *
 379  * Returns: %TRUE if the string is a valid URI
 380  */
 381 gboolean
 382 gst_uri_is_valid (const gchar * uri)
 383 {
 384   gchar *endptr;
 385 
 386   g_return_val_if_fail (uri != NULL, FALSE);
 387 
 388   gst_uri_protocol_check_internal (uri, &amp;endptr);
 389 
 390   return *endptr == &#39;:&#39; &amp;&amp; ((gsize) (endptr - uri)) &gt;= 2;
 391 }
 392 
 393 /**
 394  * gst_uri_get_protocol:
 395  * @uri: A URI string
 396  *
 397  * Extracts the protocol out of a given valid URI. The returned string must be
 398  * freed using g_free().
 399  *
 400  * Returns: (nullable): The protocol for this URI.
 401  */
 402 gchar *
 403 gst_uri_get_protocol (const gchar * uri)
 404 {
 405   gchar *colon;
 406 
 407   g_return_val_if_fail (uri != NULL, NULL);
 408   g_return_val_if_fail (gst_uri_is_valid (uri), NULL);
 409 
 410   colon = strstr (uri, &quot;:&quot;);
 411 
 412   return g_ascii_strdown (uri, colon - uri);
 413 }
 414 
 415 /**
 416  * gst_uri_has_protocol:
 417  * @uri: a URI string
 418  * @protocol: a protocol string (e.g. &quot;http&quot;)
 419  *
 420  * Checks if the protocol of a given valid URI matches @protocol.
 421  *
 422  * Returns: %TRUE if the protocol matches.
 423  */
 424 gboolean
 425 gst_uri_has_protocol (const gchar * uri, const gchar * protocol)
 426 {
 427   gchar *colon;
 428 
 429   g_return_val_if_fail (uri != NULL, FALSE);
 430   g_return_val_if_fail (protocol != NULL, FALSE);
 431   g_return_val_if_fail (gst_uri_is_valid (uri), FALSE);
 432 
 433   colon = strstr (uri, &quot;:&quot;);
 434 
 435   if (colon == NULL)
 436     return FALSE;
 437 
 438   return (g_ascii_strncasecmp (uri, protocol, (gsize) (colon - uri)) == 0);
 439 }
 440 
 441 /**
 442  * gst_uri_get_location:
 443  * @uri: A URI string
 444  *
 445  * Extracts the location out of a given valid URI, ie. the protocol and &quot;://&quot;
 446  * are stripped from the URI, which means that the location returned includes
 447  * the hostname if one is specified. The returned string must be freed using
 448  * g_free().
 449  *
 450  * Free-function: g_free
 451  *
 452  * Returns: (transfer full) (nullable): the location for this URI. Returns
 453  *     %NULL if the URI isn&#39;t valid. If the URI does not contain a location, an
 454  *     empty string is returned.
 455  */
 456 gchar *
 457 gst_uri_get_location (const gchar * uri)
 458 {
 459   const gchar *colon;
 460   gchar *unescaped = NULL;
 461 
 462   g_return_val_if_fail (uri != NULL, NULL);
 463   g_return_val_if_fail (gst_uri_is_valid (uri), NULL);
 464 
 465   colon = strstr (uri, &quot;://&quot;);
 466   if (!colon)
 467     return NULL;
 468 
 469   unescaped = unescape_string (colon + 3, &quot;/&quot;);
 470 
 471   /* On Windows an URI might look like file:///c:/foo/bar.txt or
 472    * file:///c|/foo/bar.txt (some Netscape versions) and we want to
 473    * return c:/foo/bar.txt as location rather than /c:/foo/bar.txt.
 474    * Can&#39;t use g_filename_from_uri() here because it will only handle the
 475    * file:// protocol */
 476 #ifdef G_OS_WIN32
 477   if (unescaped != NULL &amp;&amp; unescaped[0] == &#39;/&#39; &amp;&amp;
 478       g_ascii_isalpha (unescaped[1]) &amp;&amp;
 479       (unescaped[2] == &#39;:&#39; || unescaped[2] == &#39;|&#39;)) {
 480     unescaped[2] = &#39;:&#39;;
 481     memmove (unescaped, unescaped + 1, strlen (unescaped + 1) + 1);
 482   }
 483 #endif
 484 
 485   GST_LOG (&quot;extracted location &#39;%s&#39; from URI &#39;%s&#39;&quot;, GST_STR_NULL (unescaped),
 486       uri);
 487   return unescaped;
 488 }
 489 
 490 /**
 491  * gst_uri_construct:
 492  * @protocol: Protocol for URI
 493  * @location: (transfer none): Location for URI
 494  *
 495  * Constructs a URI for a given valid protocol and location.
 496  *
 497  * Free-function: g_free
 498  *
 499  * Returns: (transfer full): a new string for this URI. Returns %NULL if the
 500  *     given URI protocol is not valid, or the given location is %NULL.
 501  *
 502  * Deprecated: Use GstURI instead.
 503  */
 504 #ifndef GST_REMOVE_DEPRECATED
 505 gchar *
 506 gst_uri_construct (const gchar * protocol, const gchar * location)
 507 {
 508   char *escaped, *proto_lowercase;
 509   char *retval;
 510 
 511   g_return_val_if_fail (gst_uri_protocol_is_valid (protocol), NULL);
 512   g_return_val_if_fail (location != NULL, NULL);
 513 
 514   proto_lowercase = g_ascii_strdown (protocol, -1);
 515   escaped = escape_string_internal (location, UNSAFE_PATH);
 516   retval = g_strdup_printf (&quot;%s://%s&quot;, proto_lowercase, escaped);
 517   g_free (escaped);
 518   g_free (proto_lowercase);
 519 
 520   return retval;
 521 }
 522 #endif
 523 
 524 typedef struct
 525 {
 526   GstURIType type;
 527   const gchar *protocol;
 528 }
 529 SearchEntry;
 530 
 531 static gboolean
 532 search_by_entry (GstPluginFeature * feature, gpointer search_entry)
 533 {
 534   const gchar *const *protocols;
 535   GstElementFactory *factory;
 536   SearchEntry *entry = (SearchEntry *) search_entry;
 537 
 538   if (!GST_IS_ELEMENT_FACTORY (feature))
 539     return FALSE;
 540   factory = GST_ELEMENT_FACTORY_CAST (feature);
 541 
 542   if (factory-&gt;uri_type != entry-&gt;type)
 543     return FALSE;
 544 
 545   protocols = gst_element_factory_get_uri_protocols (factory);
 546 
 547   if (protocols == NULL) {
 548     g_warning (&quot;Factory &#39;%s&#39; implements GstUriHandler interface but returned &quot;
 549         &quot;no supported protocols!&quot;, gst_plugin_feature_get_name (feature));
 550     return FALSE;
 551   }
 552 
 553   while (*protocols != NULL) {
 554     if (g_ascii_strcasecmp (*protocols, entry-&gt;protocol) == 0)
 555       return TRUE;
 556     protocols++;
 557   }
 558   return FALSE;
 559 }
 560 
 561 static gint
 562 sort_by_rank (GstPluginFeature * first, GstPluginFeature * second)
 563 {
 564   return gst_plugin_feature_get_rank (second) -
 565       gst_plugin_feature_get_rank (first);
 566 }
 567 
 568 static GList *
 569 get_element_factories_from_uri_protocol (const GstURIType type,
 570     const gchar * protocol)
 571 {
 572   GList *possibilities;
 573   SearchEntry entry;
 574 
 575   g_return_val_if_fail (protocol, NULL);
 576 
 577   entry.type = type;
 578   entry.protocol = protocol;
 579   possibilities = gst_registry_feature_filter (gst_registry_get (),
 580       search_by_entry, FALSE, &amp;entry);
 581 
 582   return possibilities;
 583 }
 584 
 585 /**
 586  * gst_uri_protocol_is_supported:
 587  * @type: Whether to check for a source or a sink
 588  * @protocol: Protocol that should be checked for (e.g. &quot;http&quot; or &quot;smb&quot;)
 589  *
 590  * Checks if an element exists that supports the given URI protocol. Note
 591  * that a positive return value does not imply that a subsequent call to
 592  * gst_element_make_from_uri() is guaranteed to work.
 593  *
 594  * Returns: %TRUE
 595 */
 596 gboolean
 597 gst_uri_protocol_is_supported (const GstURIType type, const gchar * protocol)
 598 {
 599   GList *possibilities;
 600 
 601   g_return_val_if_fail (protocol, FALSE);
 602 
 603   possibilities = get_element_factories_from_uri_protocol (type, protocol);
 604 
 605   if (possibilities) {
 606     g_list_free (possibilities);
 607     return TRUE;
 608   } else
 609     return FALSE;
 610 }
 611 
 612 /**
 613  * gst_element_make_from_uri:
 614  * @type: Whether to create a source or a sink
 615  * @uri: URI to create an element for
 616  * @elementname: (allow-none): Name of created element, can be %NULL.
 617  * @error: (allow-none): address where to store error information, or %NULL.
 618  *
 619  * Creates an element for handling the given URI.
 620  *
 621  * Returns: (transfer floating) (nullable): a new element or %NULL if none
 622  * could be created
 623  */
 624 GstElement *
 625 gst_element_make_from_uri (const GstURIType type, const gchar * uri,
 626     const gchar * elementname, GError ** error)
 627 {
 628   GList *possibilities, *walk;
 629   gchar *protocol;
 630   GstElement *ret = NULL;
 631 
 632   g_return_val_if_fail (gst_is_initialized (), NULL);
 633   g_return_val_if_fail (GST_URI_TYPE_IS_VALID (type), NULL);
 634   g_return_val_if_fail (gst_uri_is_valid (uri), NULL);
 635   g_return_val_if_fail (error == NULL || *error == NULL, NULL);
 636 
 637   GST_DEBUG (&quot;type:%d, uri:%s, elementname:%s&quot;, type, uri, elementname);
 638 
 639   protocol = gst_uri_get_protocol (uri);
 640   possibilities = get_element_factories_from_uri_protocol (type, protocol);
 641 
 642   if (!possibilities) {
 643     GST_DEBUG (&quot;No %s for URI &#39;%s&#39;&quot;, type == GST_URI_SINK ? &quot;sink&quot; : &quot;source&quot;,
 644         uri);
 645     /* The error message isn&#39;t great, but we don&#39;t expect applications to
 646      * show that error to users, but call the missing plugins functions */
 647     g_set_error (error, GST_URI_ERROR, GST_URI_ERROR_UNSUPPORTED_PROTOCOL,
 648         _(&quot;No URI handler for the %s protocol found&quot;), protocol);
 649     g_free (protocol);
 650     return NULL;
 651   }
 652   g_free (protocol);
 653 
 654   possibilities = g_list_sort (possibilities, (GCompareFunc) sort_by_rank);
 655   walk = possibilities;
 656   while (walk) {
 657     GstElementFactory *factory = walk-&gt;data;
 658     GError *uri_err = NULL;
 659 
 660     ret = gst_element_factory_create (factory, elementname);
 661     if (ret != NULL) {
 662       GstURIHandler *handler = GST_URI_HANDLER (ret);
 663 
 664       if (gst_uri_handler_set_uri (handler, uri, &amp;uri_err))
 665         break;
 666 
 667       GST_WARNING (&quot;%s didn&#39;t accept URI &#39;%s&#39;: %s&quot;, GST_OBJECT_NAME (ret), uri,
 668           uri_err-&gt;message);
 669 
 670       if (error != NULL &amp;&amp; *error == NULL)
 671         g_propagate_error (error, uri_err);
 672       else
 673         g_error_free (uri_err);
 674 
 675       gst_object_unref (ret);
 676       ret = NULL;
 677     }
 678     walk = walk-&gt;next;
 679   }
 680   gst_plugin_feature_list_free (possibilities);
 681 
 682   GST_LOG_OBJECT (ret, &quot;created %s for URL &#39;%s&#39;&quot;,
 683       type == GST_URI_SINK ? &quot;sink&quot; : &quot;source&quot;, uri);
 684 
 685   /* if the first handler didn&#39;t work, but we found another one that works */
 686   if (ret != NULL)
 687     g_clear_error (error);
 688 
 689   return ret;
 690 }
 691 
 692 /**
 693  * gst_uri_handler_get_uri_type:
 694  * @handler: A #GstURIHandler.
 695  *
 696  * Gets the type of the given URI handler
 697  *
 698  * Returns: the #GstURIType of the URI handler.
 699  * Returns #GST_URI_UNKNOWN if the @handler isn&#39;t implemented correctly.
 700  */
 701 GstURIType
 702 gst_uri_handler_get_uri_type (GstURIHandler * handler)
 703 {
 704   GstURIHandlerInterface *iface;
 705   GstURIType ret;
 706 
 707   g_return_val_if_fail (GST_IS_URI_HANDLER (handler), GST_URI_UNKNOWN);
 708 
 709   iface = GST_URI_HANDLER_GET_INTERFACE (handler);
 710   g_return_val_if_fail (iface != NULL, GST_URI_UNKNOWN);
 711   g_return_val_if_fail (iface-&gt;get_type != NULL, GST_URI_UNKNOWN);
 712 
 713   ret = iface-&gt;get_type (G_OBJECT_TYPE (handler));
 714   g_return_val_if_fail (GST_URI_TYPE_IS_VALID (ret), GST_URI_UNKNOWN);
 715 
 716   return ret;
 717 }
 718 
 719 /**
 720  * gst_uri_handler_get_protocols:
 721  * @handler: A #GstURIHandler.
 722  *
 723  * Gets the list of protocols supported by @handler. This list may not be
 724  * modified.
 725  *
 726  * Returns: (transfer none) (element-type utf8) (nullable): the
 727  *     supported protocols.  Returns %NULL if the @handler isn&#39;t
 728  *     implemented properly, or the @handler doesn&#39;t support any
 729  *     protocols.
 730  */
 731 const gchar *const *
 732 gst_uri_handler_get_protocols (GstURIHandler * handler)
 733 {
 734   GstURIHandlerInterface *iface;
 735   const gchar *const *ret;
 736 
 737   g_return_val_if_fail (GST_IS_URI_HANDLER (handler), NULL);
 738 
 739   iface = GST_URI_HANDLER_GET_INTERFACE (handler);
 740   g_return_val_if_fail (iface != NULL, NULL);
 741   g_return_val_if_fail (iface-&gt;get_protocols != NULL, NULL);
 742 
 743   ret = iface-&gt;get_protocols (G_OBJECT_TYPE (handler));
 744   g_return_val_if_fail (ret != NULL, NULL);
 745 
 746   return ret;
 747 }
 748 
 749 /**
 750  * gst_uri_handler_get_uri:
 751  * @handler: A #GstURIHandler
 752  *
 753  * Gets the currently handled URI.
 754  *
 755  * Returns: (transfer full) (nullable): the URI currently handled by
 756  *   the @handler.  Returns %NULL if there are no URI currently
 757  *   handled. The returned string must be freed with g_free() when no
 758  *   longer needed.
 759  */
 760 gchar *
 761 gst_uri_handler_get_uri (GstURIHandler * handler)
 762 {
 763   GstURIHandlerInterface *iface;
 764   gchar *ret;
 765 
 766   g_return_val_if_fail (GST_IS_URI_HANDLER (handler), NULL);
 767 
 768   iface = GST_URI_HANDLER_GET_INTERFACE (handler);
 769   g_return_val_if_fail (iface != NULL, NULL);
 770   g_return_val_if_fail (iface-&gt;get_uri != NULL, NULL);
 771   ret = iface-&gt;get_uri (handler);
 772   if (ret != NULL)
 773     g_return_val_if_fail (gst_uri_is_valid (ret), NULL);
 774 
 775   return ret;
 776 }
 777 
 778 /**
 779  * gst_uri_handler_set_uri:
 780  * @handler: A #GstURIHandler
 781  * @uri: URI to set
 782  * @error: (allow-none): address where to store a #GError in case of
 783  *    an error, or %NULL
 784  *
 785  * Tries to set the URI of the given handler.
 786  *
 787  * Returns: %TRUE if the URI was set successfully, else %FALSE.
 788  */
 789 gboolean
 790 gst_uri_handler_set_uri (GstURIHandler * handler, const gchar * uri,
 791     GError ** error)
 792 {
 793   GstURIHandlerInterface *iface;
 794   gboolean ret;
 795   gchar *protocol;
 796 
 797   g_return_val_if_fail (GST_IS_URI_HANDLER (handler), FALSE);
 798   g_return_val_if_fail (gst_uri_is_valid (uri), FALSE);
 799   g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
 800 
 801   iface = GST_URI_HANDLER_GET_INTERFACE (handler);
 802   g_return_val_if_fail (iface != NULL, FALSE);
 803   g_return_val_if_fail (iface-&gt;set_uri != NULL, FALSE);
 804 
 805   protocol = gst_uri_get_protocol (uri);
 806 
 807   if (iface-&gt;get_protocols) {
 808     const gchar *const *protocols;
 809     const gchar *const *p;
 810     gboolean found_protocol = FALSE;
 811 
 812     protocols = iface-&gt;get_protocols (G_OBJECT_TYPE (handler));
 813     if (protocols != NULL) {
 814       for (p = protocols; *p != NULL; ++p) {
 815         if (g_ascii_strcasecmp (protocol, *p) == 0) {
 816           found_protocol = TRUE;
 817           break;
 818         }
 819       }
 820 
 821       if (!found_protocol) {
 822         g_set_error (error, GST_URI_ERROR, GST_URI_ERROR_UNSUPPORTED_PROTOCOL,
 823             _(&quot;URI scheme &#39;%s&#39; not supported&quot;), protocol);
 824         g_free (protocol);
 825         return FALSE;
 826       }
 827     }
 828   }
 829 
 830   ret = iface-&gt;set_uri (handler, uri, error);
 831 
 832   g_free (protocol);
 833 
 834   return ret;
 835 }
 836 
 837 static gchar *
 838 gst_file_utils_canonicalise_path (const gchar * path)
 839 {
 840   gchar **parts, **p, *clean_path;
 841 
 842 #ifdef G_OS_WIN32
 843   {
 844     GST_WARNING (&quot;FIXME: canonicalise win32 path&quot;);
 845     return g_strdup (path);
 846   }
 847 #endif
 848 
 849   parts = g_strsplit (path, &quot;/&quot;, -1);
 850 
 851   p = parts;
 852   while (*p != NULL) {
 853     if (strcmp (*p, &quot;.&quot;) == 0) {
 854       /* just move all following parts on top of this, incl. NUL terminator */
 855       g_free (*p);
 856       memmove (p, p + 1, (g_strv_length (p + 1) + 1) * sizeof (gchar *));
 857       /* re-check the new current part again in the next iteration */
 858       continue;
 859     } else if (strcmp (*p, &quot;..&quot;) == 0 &amp;&amp; p &gt; parts) {
 860       /* just move all following parts on top of the previous part, incl.
 861        * NUL terminator */
 862       g_free (*(p - 1));
 863       g_free (*p);
 864       memmove (p - 1, p + 1, (g_strv_length (p + 1) + 1) * sizeof (gchar *));
 865       /* re-check the new current part again in the next iteration */
 866       --p;
 867       continue;
 868     }
 869     ++p;
 870   }
 871   if (*path == &#39;/&#39;) {
 872     guint num_parts;
 873 
 874     num_parts = g_strv_length (parts) + 1;      /* incl. terminator */
 875     parts = g_renew (gchar *, parts, num_parts + 1);
 876     memmove (parts + 1, parts, num_parts * sizeof (gchar *));
 877     parts[0] = g_strdup (&quot;/&quot;);
 878   }
 879 
 880   clean_path = g_build_filenamev (parts);
 881   g_strfreev (parts);
 882   return clean_path;
 883 }
 884 
 885 static gboolean
 886 file_path_contains_relatives (const gchar * path)
 887 {
 888   return (strstr (path, &quot;/./&quot;) != NULL || strstr (path, &quot;/../&quot;) != NULL ||
 889       strstr (path, G_DIR_SEPARATOR_S &quot;.&quot; G_DIR_SEPARATOR_S) != NULL ||
 890       strstr (path, G_DIR_SEPARATOR_S &quot;..&quot; G_DIR_SEPARATOR_S) != NULL);
 891 }
 892 
 893 /**
 894  * gst_filename_to_uri:
 895  * @filename: (type filename): absolute or relative file name path
 896  * @error: pointer to error, or %NULL
 897  *
 898  * Similar to g_filename_to_uri(), but attempts to handle relative file paths
 899  * as well. Before converting @filename into an URI, it will be prefixed by
 900  * the current working directory if it is a relative path, and then the path
 901  * will be canonicalised so that it doesn&#39;t contain any &#39;./&#39; or &#39;../&#39; segments.
 902  *
 903  * On Windows #filename should be in UTF-8 encoding.
 904  *
 905  * Returns: newly-allocated URI string, or NULL on error. The caller must
 906  *   free the URI string with g_free() when no longer needed.
 907  */
 908 gchar *
 909 gst_filename_to_uri (const gchar * filename, GError ** error)
 910 {
 911   gchar *abs_location = NULL;
 912   gchar *uri, *abs_clean;
 913 
 914   g_return_val_if_fail (filename != NULL, NULL);
 915   g_return_val_if_fail (error == NULL || *error == NULL, NULL);
 916 
 917   if (g_path_is_absolute (filename)) {
 918     if (!file_path_contains_relatives (filename)) {
 919       uri = g_filename_to_uri (filename, NULL, error);
 920       goto beach;
 921     }
 922 
 923     abs_location = g_strdup (filename);
 924   } else {
 925     gchar *cwd;
 926 
 927     cwd = g_get_current_dir ();
 928     abs_location = g_build_filename (cwd, filename, NULL);
 929     g_free (cwd);
 930 
 931     if (!file_path_contains_relatives (abs_location)) {
 932       uri = g_filename_to_uri (abs_location, NULL, error);
 933       goto beach;
 934     }
 935   }
 936 
 937   /* path is now absolute, but contains &#39;.&#39; or &#39;..&#39; */
 938   abs_clean = gst_file_utils_canonicalise_path (abs_location);
 939   GST_LOG (&quot;&#39;%s&#39; -&gt; &#39;%s&#39; -&gt; &#39;%s&#39;&quot;, filename, abs_location, abs_clean);
 940   uri = g_filename_to_uri (abs_clean, NULL, error);
 941   g_free (abs_clean);
 942 
 943 beach:
 944 
 945   g_free (abs_location);
 946   GST_DEBUG (&quot;&#39;%s&#39; -&gt; &#39;%s&#39;&quot;, filename, uri);
 947   return uri;
 948 }
 949 
 950 /****************************************************************************
 951  * GstUri - GstMiniObject to parse and merge URIs according to IETF RFC 3986
 952  ****************************************************************************/
 953 
 954 /**
 955  * SECTION:gsturi
 956  * @title: GstUri
 957  * @short_description: URI parsing and manipulation.
 958  *
 959  * A #GstUri object can be used to parse and split a URI string into its
 960  * constituant parts. Two #GstUri objects can be joined to make a new #GstUri
 961  * using the algorithm described in RFC3986.
 962  */
 963 
 964 /* Definition for GstUri object */
 965 struct _GstUri
 966 {
 967   /*&lt; private &gt; */
 968   GstMiniObject mini_object;
 969   gchar *scheme;
 970   gchar *userinfo;
 971   gchar *host;
 972   guint port;
 973   GList *path;
 974   GHashTable *query;
 975   gchar *fragment;
 976 };
 977 
 978 GST_DEFINE_MINI_OBJECT_TYPE (GstUri, gst_uri);
 979 
 980 static GstUri *_gst_uri_copy (const GstUri * uri);
 981 static void _gst_uri_free (GstUri * uri);
 982 static GstUri *_gst_uri_new (void);
 983 static GList *_remove_dot_segments (GList * path);
 984 
 985 /* private GstUri functions */
 986 
 987 static GstUri *
 988 _gst_uri_new (void)
 989 {
 990   GstUri *uri;
 991 
 992   g_return_val_if_fail (gst_is_initialized (), NULL);
 993 
 994   uri = GST_URI_CAST (g_slice_new0 (GstUri));
 995 
 996   if (uri)
 997     gst_mini_object_init (GST_MINI_OBJECT_CAST (uri), 0, gst_uri_get_type (),
 998         (GstMiniObjectCopyFunction) _gst_uri_copy, NULL,
 999         (GstMiniObjectFreeFunction) _gst_uri_free);
1000 
1001   return uri;
1002 }
1003 
1004 static void
1005 _gst_uri_free (GstUri * uri)
1006 {
1007   g_return_if_fail (GST_IS_URI (uri));
1008 
1009   g_free (uri-&gt;scheme);
1010   g_free (uri-&gt;userinfo);
1011   g_free (uri-&gt;host);
1012   g_list_free_full (uri-&gt;path, g_free);
1013   if (uri-&gt;query)
1014     g_hash_table_unref (uri-&gt;query);
1015   g_free (uri-&gt;fragment);
1016 
1017   g_slice_free1 (sizeof (*uri), uri);
1018 }
1019 
1020 static GHashTable *
1021 _gst_uri_copy_query_table (GHashTable * orig)
1022 {
1023   GHashTable *new = NULL;
1024 
1025   if (orig != NULL) {
1026     GHashTableIter iter;
1027     gpointer key, value;
1028     new = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
1029     g_hash_table_iter_init (&amp;iter, orig);
1030     while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value)) {
1031       g_hash_table_insert (new, g_strdup (key), g_strdup (value));
1032     }
1033   }
1034 
1035   return new;
1036 }
1037 
1038 static GstUri *
1039 _gst_uri_copy (const GstUri * orig_uri)
1040 {
1041   GstUri *new_uri;
1042 
1043   g_return_val_if_fail (GST_IS_URI (orig_uri), NULL);
1044 
1045   new_uri = _gst_uri_new ();
1046 
1047   if (new_uri) {
1048     new_uri-&gt;scheme = g_strdup (orig_uri-&gt;scheme);
1049     new_uri-&gt;userinfo = g_strdup (orig_uri-&gt;userinfo);
1050     new_uri-&gt;host = g_strdup (orig_uri-&gt;host);
1051     new_uri-&gt;port = orig_uri-&gt;port;
1052     new_uri-&gt;path = g_list_copy_deep (orig_uri-&gt;path, (GCopyFunc) g_strdup,
1053         NULL);
1054     new_uri-&gt;query = _gst_uri_copy_query_table (orig_uri-&gt;query);
1055     new_uri-&gt;fragment = g_strdup (orig_uri-&gt;fragment);
1056   }
1057 
1058   return new_uri;
1059 }
1060 
1061 /*
1062  * _gst_uri_compare_lists:
1063  *
1064  * Compare two lists for equality. This compares the two lists, item for item,
1065  * comparing items in the same position in the two lists. If @first is
1066  * considered less than @second the result will be negative. If @first is
1067  * considered to be more than @second then the result will be positive. If the
1068  * lists are considered to be equal then the result will be 0. If two lists
1069  * have the same items, but one list is shorter than the other, then the
1070  * shorter list is considered to be less than the longer list.
1071  */
1072 static gint
1073 _gst_uri_compare_lists (GList * first, GList * second, GCompareFunc cmp_fn)
1074 {
1075   GList *itr1, *itr2;
1076   gint result;
1077 
1078   for (itr1 = first, itr2 = second;
1079       itr1 != NULL || itr2 != NULL; itr1 = itr1-&gt;next, itr2 = itr2-&gt;next) {
1080     if (itr1 == NULL)
1081       return -1;
1082     if (itr2 == NULL)
1083       return 1;
1084     result = cmp_fn (itr1-&gt;data, itr2-&gt;data);
1085     if (result != 0)
1086       return result;
1087   }
1088   return 0;
1089 }
1090 
1091 typedef enum
1092 {
1093   _GST_URI_NORMALIZE_LOWERCASE = 1,
1094   _GST_URI_NORMALIZE_UPPERCASE = 2
1095 } _GstUriNormalizations;
1096 
1097 /*
1098  * Find the first character that hasn&#39;t been normalized according to the @flags.
1099  */
1100 static gchar *
1101 _gst_uri_first_non_normalized_char (gchar * str, guint flags)
1102 {
1103   gchar *pos;
1104 
1105   if (str == NULL)
1106     return NULL;
1107 
1108   for (pos = str; *pos; pos++) {
1109     if ((flags &amp; _GST_URI_NORMALIZE_UPPERCASE) &amp;&amp; g_ascii_islower (*pos))
1110       return pos;
1111     if ((flags &amp; _GST_URI_NORMALIZE_LOWERCASE) &amp;&amp; g_ascii_isupper (*pos))
1112       return pos;
1113   }
1114   return NULL;
1115 }
1116 
1117 static gboolean
1118 _gst_uri_normalize_lowercase (gchar * str)
1119 {
1120   gchar *pos;
1121   gboolean ret = FALSE;
1122 
1123   for (pos = _gst_uri_first_non_normalized_char (str,
1124           _GST_URI_NORMALIZE_LOWERCASE);
1125       pos != NULL;
1126       pos = _gst_uri_first_non_normalized_char (pos + 1,
1127           _GST_URI_NORMALIZE_LOWERCASE)) {
1128     *pos = g_ascii_tolower (*pos);
1129     ret = TRUE;
1130   }
1131 
1132   return ret;
1133 }
1134 
1135 #define _gst_uri_normalize_scheme _gst_uri_normalize_lowercase
1136 #define _gst_uri_normalize_hostname _gst_uri_normalize_lowercase
1137 
1138 static gboolean
1139 _gst_uri_normalize_path (GList ** path)
1140 {
1141   GList *new_path;
1142 
1143   new_path = _remove_dot_segments (*path);
1144   if (_gst_uri_compare_lists (new_path, *path, (GCompareFunc) g_strcmp0) != 0) {
1145     g_list_free_full (*path, g_free);
1146     *path = new_path;
1147     return TRUE;
1148   }
1149   g_list_free_full (new_path, g_free);
1150 
1151   return FALSE;
1152 }
1153 
1154 static gboolean
1155 _gst_uri_normalize_str_noop (gchar * str)
1156 {
1157   return FALSE;
1158 }
1159 
1160 static gboolean
1161 _gst_uri_normalize_table_noop (GHashTable * table)
1162 {
1163   return FALSE;
1164 }
1165 
1166 #define _gst_uri_normalize_userinfo _gst_uri_normalize_str_noop
1167 #define _gst_uri_normalize_query _gst_uri_normalize_table_noop
1168 #define _gst_uri_normalize_fragment _gst_uri_normalize_str_noop
1169 
1170 /* RFC 3986 functions */
1171 
1172 static GList *
1173 _merge (GList * base, GList * path)
1174 {
1175   GList *ret, *path_copy, *last;
1176 
1177   path_copy = g_list_copy_deep (path, (GCopyFunc) g_strdup, NULL);
1178   /* if base is NULL make path absolute */
1179   if (base == NULL) {
1180     if (path_copy != NULL &amp;&amp; path_copy-&gt;data != NULL) {
1181       path_copy = g_list_prepend (path_copy, NULL);
1182     }
1183     return path_copy;
1184   }
1185 
1186   ret = g_list_copy_deep (base, (GCopyFunc) g_strdup, NULL);
1187   last = g_list_last (ret);
1188   ret = g_list_remove_link (ret, last);
1189   g_list_free_full (last, g_free);
1190   ret = g_list_concat (ret, path_copy);
1191 
1192   return ret;
1193 }
1194 
1195 static GList *
1196 _remove_dot_segments (GList * path)
1197 {
1198   GList *out, *elem, *next;
1199 
1200   if (path == NULL)
1201     return NULL;
1202 
1203   out = g_list_copy_deep (path, (GCopyFunc) g_strdup, NULL);
1204 
1205   for (elem = out; elem; elem = next) {
1206     next = elem-&gt;next;
1207     if (elem-&gt;data == NULL &amp;&amp; elem != out &amp;&amp; next != NULL) {
1208       out = g_list_delete_link (out, elem);
1209     } else if (g_strcmp0 (elem-&gt;data, &quot;.&quot;) == 0) {
1210       g_free (elem-&gt;data);
1211       out = g_list_delete_link (out, elem);
1212     } else if (g_strcmp0 (elem-&gt;data, &quot;..&quot;) == 0) {
1213       GList *prev = g_list_previous (elem);
1214       if (prev &amp;&amp; (prev != out || prev-&gt;data != NULL)) {
1215         g_free (prev-&gt;data);
1216         out = g_list_delete_link (out, prev);
1217       }
1218       g_free (elem-&gt;data);
1219       if (next != NULL) {
1220         out = g_list_delete_link (out, elem);
1221       } else {
1222         /* path ends in &#39;/..&#39; We need to keep the last &#39;/&#39; */
1223         elem-&gt;data = NULL;
1224       }
1225     }
1226   }
1227 
1228   return out;
1229 }
1230 
1231 static gchar *
1232 _gst_uri_escape_userinfo (const gchar * userinfo)
1233 {
1234   return g_uri_escape_string (userinfo,
1235       G_URI_RESERVED_CHARS_ALLOWED_IN_USERINFO, FALSE);
1236 }
1237 
1238 static gchar *
1239 _gst_uri_escape_host (const gchar * host)
1240 {
1241   return g_uri_escape_string (host,
1242       G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS, FALSE);
1243 }
1244 
1245 static gchar *
1246 _gst_uri_escape_host_colon (const gchar * host)
1247 {
1248   return g_uri_escape_string (host,
1249       G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS &quot;:&quot;, FALSE);
1250 }
1251 
1252 static gchar *
1253 _gst_uri_escape_path_segment (const gchar * segment)
1254 {
1255   return g_uri_escape_string (segment,
1256       G_URI_RESERVED_CHARS_ALLOWED_IN_PATH_ELEMENT, FALSE);
1257 }
1258 
1259 static gchar *
1260 _gst_uri_escape_http_query_element (const gchar * element)
1261 {
1262   gchar *ret, *c;
1263 
1264   ret = g_uri_escape_string (element, &quot;!$&#39;()*,;:@/? &quot;, FALSE);
1265   for (c = ret; *c; c++)
1266     if (*c == &#39; &#39;)
1267       *c = &#39;+&#39;;
1268   return ret;
1269 }
1270 
1271 static gchar *
1272 _gst_uri_escape_fragment (const gchar * fragment)
1273 {
1274   return g_uri_escape_string (fragment,
1275       G_URI_RESERVED_CHARS_ALLOWED_IN_PATH &quot;?&quot;, FALSE);
1276 }
1277 
1278 static GList *
1279 _gst_uri_string_to_list (const gchar * str, const gchar * sep, gboolean convert,
1280     gboolean unescape)
1281 {
1282   GList *new_list = NULL;
1283 
1284   if (str) {
1285     guint pct_sep_len = 0;
1286     gchar *pct_sep = NULL;
1287     gchar **split_str;
1288 
1289     if (convert &amp;&amp; !unescape) {
1290       pct_sep = g_strdup_printf (&quot;%%%2.2X&quot;, (guint) (*sep));
1291       pct_sep_len = 3;
1292     }
1293 
1294     split_str = g_strsplit (str, sep, -1);
1295     if (split_str) {
1296       gchar **next_elem;
1297       for (next_elem = split_str; *next_elem; next_elem += 1) {
1298         gchar *elem = *next_elem;
1299         if (*elem == &#39;\0&#39;) {
1300           new_list = g_list_append (new_list, NULL);
1301         } else {
1302           if (convert &amp;&amp; !unescape) {
1303             gchar *next_sep;
1304             for (next_sep = strcasestr (elem, pct_sep); next_sep;
1305                 next_sep = strcasestr (next_sep + 1, pct_sep)) {
1306               *next_sep = *sep;
1307               memmove (next_sep + 1, next_sep + pct_sep_len,
1308                   strlen (next_sep + pct_sep_len) + 1);
1309             }
1310           }
1311           if (unescape) {
1312             *next_elem = g_uri_unescape_string (elem, NULL);
1313             g_free (elem);
1314             elem = *next_elem;
1315           }
1316           new_list = g_list_append (new_list, g_strdup (elem));
1317         }
1318       }
1319     }
1320     g_strfreev (split_str);
1321     if (convert &amp;&amp; !unescape)
1322       g_free (pct_sep);
1323   }
1324 
1325   return new_list;
1326 }
1327 
1328 static GHashTable *
1329 _gst_uri_string_to_table (const gchar * str, const gchar * part_sep,
1330     const gchar * kv_sep, gboolean convert, gboolean unescape)
1331 {
1332   GHashTable *new_table = NULL;
1333 
1334   if (str) {
1335     gchar *pct_part_sep = NULL, *pct_kv_sep = NULL;
1336     gchar **split_parts;
1337 
1338     new_table = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
1339 
1340     if (convert &amp;&amp; !unescape) {
1341       pct_part_sep = g_strdup_printf (&quot;%%%2.2X&quot;, (guint) (*part_sep));
1342       pct_kv_sep = g_strdup_printf (&quot;%%%2.2X&quot;, (guint) (*kv_sep));
1343     }
1344 
1345     split_parts = g_strsplit (str, part_sep, -1);
1346     if (split_parts) {
1347       gchar **next_part;
1348       for (next_part = split_parts; *next_part; next_part += 1) {
1349         gchar *part = *next_part;
1350         gchar *kv_sep_pos;
1351         gchar *key, *value;
1352         /* if we are converting percent encoded versions of separators then
1353          *  substitute the part separator now. */
1354         if (convert &amp;&amp; !unescape) {
1355           gchar *next_sep;
1356           for (next_sep = strcasestr (part, pct_part_sep); next_sep;
1357               next_sep = strcasestr (next_sep + 1, pct_part_sep)) {
1358             *next_sep = *part_sep;
1359             memmove (next_sep + 1, next_sep + 3, strlen (next_sep + 3) + 1);
1360           }
1361         }
1362         /* find the key/value separator within the part */
1363         kv_sep_pos = g_strstr_len (part, -1, kv_sep);
1364         if (kv_sep_pos == NULL) {
1365           if (unescape) {
1366             key = g_uri_unescape_string (part, NULL);
1367           } else {
1368             key = g_strdup (part);
1369           }
1370           value = NULL;
1371         } else {
1372           if (unescape) {
1373             key = g_uri_unescape_segment (part, kv_sep_pos, NULL);
1374             value = g_uri_unescape_string (kv_sep_pos + 1, NULL);
1375           } else {
1376             key = g_strndup (part, kv_sep_pos - part);
1377             value = g_strdup (kv_sep_pos + 1);
1378           }
1379         }
1380         /* if we are converting percent encoded versions of separators then
1381          *  substitute the key/value separator in both key and value now. */
1382         if (convert &amp;&amp; !unescape) {
1383           gchar *next_sep;
1384           for (next_sep = strcasestr (key, pct_kv_sep); next_sep;
1385               next_sep = strcasestr (next_sep + 1, pct_kv_sep)) {
1386             *next_sep = *kv_sep;
1387             memmove (next_sep + 1, next_sep + 3, strlen (next_sep + 3) + 1);
1388           }
1389           if (value) {
1390             for (next_sep = strcasestr (value, pct_kv_sep); next_sep;
1391                 next_sep = strcasestr (next_sep + 1, pct_kv_sep)) {
1392               *next_sep = *kv_sep;
1393               memmove (next_sep + 1, next_sep + 3, strlen (next_sep + 3) + 1);
1394             }
1395           }
1396         }
1397         /* add value to the table */
1398         g_hash_table_insert (new_table, key, value);
1399       }
1400     }
1401     /* tidy up */
1402     g_strfreev (split_parts);
1403     if (convert &amp;&amp; !unescape) {
1404       g_free (pct_part_sep);
1405       g_free (pct_kv_sep);
1406     }
1407   }
1408 
1409   return new_table;
1410 }
1411 
1412 
1413 /*
1414  * Method definitions.
1415  */
1416 
1417 /**
1418  * gst_uri_new:
1419  * @scheme: (nullable): The scheme for the new URI.
1420  * @userinfo: (nullable): The user-info for the new URI.
1421  * @host: (nullable): The host name for the new URI.
1422  * @port: The port number for the new URI or %GST_URI_NO_PORT.
1423  * @path: (nullable): The path for the new URI with &#39;/&#39; separating path
1424  *                      elements.
1425  * @query: (nullable): The query string for the new URI with &#39;&amp;&#39; separating
1426  *                       query elements. Elements containing &#39;&amp;&#39; characters
1427  *                       should encode them as &quot;&amp;percnt;26&quot;.
1428  * @fragment: (nullable): The fragment name for the new URI.
1429  *
1430  * Creates a new #GstUri object with the given URI parts. The path and query
1431  * strings will be broken down into their elements. All strings should not be
1432  * escaped except where indicated.
1433  *
1434  * Returns: (transfer full): A new #GstUri object.
1435  *
1436  * Since: 1.6
1437  */
1438 GstUri *
1439 gst_uri_new (const gchar * scheme, const gchar * userinfo, const gchar * host,
1440     guint port, const gchar * path, const gchar * query, const gchar * fragment)
1441 {
1442   GstUri *new_uri;
1443 
1444   new_uri = _gst_uri_new ();
1445   if (new_uri) {
1446     new_uri-&gt;scheme = g_strdup (scheme);
1447     new_uri-&gt;userinfo = g_strdup (userinfo);
1448     new_uri-&gt;host = g_strdup (host);
1449     new_uri-&gt;port = port;
1450     new_uri-&gt;path = _gst_uri_string_to_list (path, &quot;/&quot;, FALSE, FALSE);
1451     new_uri-&gt;query = _gst_uri_string_to_table (query, &quot;&amp;&quot;, &quot;=&quot;, TRUE, FALSE);
1452     new_uri-&gt;fragment = g_strdup (fragment);
1453   }
1454 
1455   return new_uri;
1456 }
1457 
1458 /**
1459  * gst_uri_new_with_base:
1460  * @base: (transfer none)(nullable): The base URI to join the new URI to.
1461  * @scheme: (nullable): The scheme for the new URI.
1462  * @userinfo: (nullable): The user-info for the new URI.
1463  * @host: (nullable): The host name for the new URI.
1464  * @port: The port number for the new URI or %GST_URI_NO_PORT.
1465  * @path: (nullable): The path for the new URI with &#39;/&#39; separating path
1466  *                      elements.
1467  * @query: (nullable): The query string for the new URI with &#39;&amp;&#39; separating
1468  *                       query elements. Elements containing &#39;&amp;&#39; characters
1469  *                       should encode them as &quot;&amp;percnt;26&quot;.
1470  * @fragment: (nullable): The fragment name for the new URI.
1471  *
1472  * Like gst_uri_new(), but joins the new URI onto a base URI.
1473  *
1474  * Returns: (transfer full): The new URI joined onto @base.
1475  *
1476  * Since: 1.6
1477  */
1478 GstUri *
1479 gst_uri_new_with_base (GstUri * base, const gchar * scheme,
1480     const gchar * userinfo, const gchar * host, guint port, const gchar * path,
1481     const gchar * query, const gchar * fragment)
1482 {
1483   GstUri *new_rel_uri;
1484   GstUri *new_uri;
1485 
1486   g_return_val_if_fail (base == NULL || GST_IS_URI (base), NULL);
1487 
1488   new_rel_uri = gst_uri_new (scheme, userinfo, host, port, path, query,
1489       fragment);
1490   new_uri = gst_uri_join (base, new_rel_uri);
1491   gst_uri_unref (new_rel_uri);
1492 
1493   return new_uri;
1494 }
1495 
1496 /**
1497  * gst_uri_from_string:
1498  * @uri: The URI string to parse.
1499  *
1500  * Parses a URI string into a new #GstUri object. Will return NULL if the URI
1501  * cannot be parsed.
1502  *
1503  * Returns: (transfer full) (nullable): A new #GstUri object, or NULL.
1504  *
1505  * Since: 1.6
1506  */
1507 GstUri *
1508 gst_uri_from_string (const gchar * uri)
1509 {
1510   const gchar *orig_uri = uri;
1511   GstUri *uri_obj;
1512 
1513   uri_obj = _gst_uri_new ();
1514 
1515   if (uri_obj &amp;&amp; uri != NULL) {
1516     int i = 0;
1517 
1518     /* be helpful and skip initial white space */
1519     while (*uri == &#39;\v&#39; || g_ascii_isspace (*uri))
1520       uri++;
1521 
1522     if (g_ascii_isalpha (uri[i])) {
1523       /* find end of scheme name */
1524       i++;
1525       while (g_ascii_isalnum (uri[i]) || uri[i] == &#39;+&#39; || uri[i] == &#39;-&#39; ||
1526           uri[i] == &#39;.&#39;)
1527         i++;
1528     }
1529     if (i &gt; 0 &amp;&amp; uri[i] == &#39;:&#39;) {
1530       /* get scheme */
1531       uri_obj-&gt;scheme = g_strndup (uri, i);
1532       uri += i + 1;
1533     }
1534     if (uri[0] == &#39;/&#39; &amp;&amp; uri[1] == &#39;/&#39;) {
1535       const gchar *eoa, *eoui, *eoh, *reoh;
1536       /* get authority [userinfo@]host[:port] */
1537       uri += 2;
1538       /* find end of authority */
1539       eoa = uri + strcspn (uri, &quot;/?#&quot;);
1540 
1541       /* find end of userinfo */
1542       eoui = strchr (uri, &#39;@&#39;);
1543       if (eoui != NULL &amp;&amp; eoui &lt; eoa) {
1544         uri_obj-&gt;userinfo = g_uri_unescape_segment (uri, eoui, NULL);
1545         uri = eoui + 1;
1546       }
1547       /* find end of host */
1548       if (uri[0] == &#39;[&#39;) {
1549         eoh = strchr (uri, &#39;]&#39;);
1550         if (eoh == NULL || eoh &gt; eoa) {
1551           GST_DEBUG (&quot;Unable to parse the host part of the URI &#39;%s&#39;.&quot;,
1552               orig_uri);
1553           gst_uri_unref (uri_obj);
1554           return NULL;
1555         }
1556         reoh = eoh + 1;
1557         uri++;
1558       } else {
1559         reoh = eoh = strchr (uri, &#39;:&#39;);
1560         if (eoh == NULL || eoh &gt; eoa)
1561           reoh = eoh = eoa;
1562       }
1563       /* don&#39;t capture empty host strings */
1564       if (eoh != uri)
1565         uri_obj-&gt;host = g_uri_unescape_segment (uri, eoh, NULL);
1566 
1567       uri = reoh;
1568       if (uri &lt; eoa) {
1569         /* if port number is malformed then we can&#39;t parse this */
1570         if (uri[0] != &#39;:&#39; || strspn (uri + 1, &quot;0123456789&quot;) != eoa - uri - 1) {
1571           GST_DEBUG (&quot;Unable to parse host/port part of the URI &#39;%s&#39;.&quot;,
1572               orig_uri);
1573           gst_uri_unref (uri_obj);
1574           return NULL;
1575         }
1576         /* otherwise treat port as unsigned decimal number */
1577         uri++;
1578         while (uri &lt; eoa) {
1579           uri_obj-&gt;port = uri_obj-&gt;port * 10 + g_ascii_digit_value (*uri);
1580           uri++;
1581         }
1582       }
1583       uri = eoa;
1584     }
1585     if (uri != NULL &amp;&amp; uri[0] != &#39;\0&#39;) {
1586       /* get path */
1587       size_t len;
1588       len = strcspn (uri, &quot;?#&quot;);
1589       if (uri[len] == &#39;\0&#39;) {
1590         uri_obj-&gt;path = _gst_uri_string_to_list (uri, &quot;/&quot;, FALSE, TRUE);
1591         uri = NULL;
1592       } else {
1593         if (len &gt; 0) {
1594           gchar *path_str = g_strndup (uri, len);
1595           uri_obj-&gt;path = _gst_uri_string_to_list (path_str, &quot;/&quot;, FALSE, TRUE);
1596           g_free (path_str);
1597         }
1598         uri += len;
1599       }
1600     }
1601     if (uri != NULL &amp;&amp; uri[0] == &#39;?&#39;) {
1602       /* get query */
1603       gchar *eoq;
1604       eoq = strchr (++uri, &#39;#&#39;);
1605       if (eoq == NULL) {
1606         uri_obj-&gt;query = _gst_uri_string_to_table (uri, &quot;&amp;&quot;, &quot;=&quot;, TRUE, TRUE);
1607         uri = NULL;
1608       } else {
1609         if (eoq != uri) {
1610           gchar *query_str = g_strndup (uri, eoq - uri);
1611           uri_obj-&gt;query = _gst_uri_string_to_table (query_str, &quot;&amp;&quot;, &quot;=&quot;, TRUE,
1612               TRUE);
1613           g_free (query_str);
1614         }
1615         uri = eoq;
1616       }
1617     }
1618     if (uri != NULL &amp;&amp; uri[0] == &#39;#&#39;) {
1619       uri_obj-&gt;fragment = g_uri_unescape_string (uri + 1, NULL);
1620     }
1621   }
1622 
1623   return uri_obj;
1624 }
1625 
1626 /**
1627  * gst_uri_from_string_with_base:
1628  * @base: (transfer none)(nullable): The base URI to join the new URI with.
1629  * @uri: The URI string to parse.
1630  *
1631  * Like gst_uri_from_string() but also joins with a base URI.
1632  *
1633  * Returns: (transfer full): A new #GstUri object.
1634  *
1635  * Since: 1.6
1636  */
1637 GstUri *
1638 gst_uri_from_string_with_base (GstUri * base, const gchar * uri)
1639 {
1640   GstUri *new_rel_uri;
1641   GstUri *new_uri;
1642 
1643   g_return_val_if_fail (base == NULL || GST_IS_URI (base), NULL);
1644 
1645   new_rel_uri = gst_uri_from_string (uri);
1646   new_uri = gst_uri_join (base, new_rel_uri);
1647   gst_uri_unref (new_rel_uri);
1648 
1649   return new_uri;
1650 }
1651 
1652 /**
1653  * gst_uri_equal:
1654  * @first: First #GstUri to compare.
1655  * @second: Second #GstUri to compare.
1656  *
1657  * Compares two #GstUri objects to see if they represent the same normalized
1658  * URI.
1659  *
1660  * Returns: %TRUE if the normalized versions of the two URI&#39;s would be equal.
1661  *
1662  * Since: 1.6
1663  */
1664 gboolean
1665 gst_uri_equal (const GstUri * first, const GstUri * second)
1666 {
1667   gchar *first_norm = NULL, *second_norm = NULL;
1668   GList *first_norm_list = NULL, *second_norm_list = NULL;
1669   const gchar *first_cmp, *second_cmp;
1670   GHashTableIter table_iter;
1671   gpointer key, value;
1672   int result;
1673 
1674   g_return_val_if_fail ((first == NULL || GST_IS_URI (first)) &amp;&amp;
1675       (second == NULL || GST_IS_URI (second)), FALSE);
1676 
1677   if (first == second)
1678     return TRUE;
1679 
1680   if (first == NULL || second == NULL)
1681     return FALSE;
1682 
1683   if (first-&gt;port != second-&gt;port)
1684     return FALSE;
1685 
1686 /* work out a version of field value (normalized or not) to compare.
1687  * first_cmp, second_cmp will be the values to compare later.
1688  * first_norm, second_norm will be non-NULL if normalized versions are used,
1689  *  and need to be freed later.
1690  */
1691 #define GST_URI_NORMALIZED_FIELD(pos, field, norm_fn, flags) \
1692   pos##_cmp = pos-&gt;field; \
1693   if (_gst_uri_first_non_normalized_char ((gchar*)pos##_cmp, flags) != NULL) { \
1694     pos##_norm = g_strdup (pos##_cmp); \
1695     norm_fn (pos##_norm); \
1696     pos##_cmp = pos##_norm; \
1697   }
1698 
1699 /* compare two string values, normalizing if needed */
1700 #define GST_URI_NORMALIZED_CMP_STR(field, norm_fn, flags) \
1701   GST_URI_NORMALIZED_FIELD (first, field, norm_fn, flags) \
1702   GST_URI_NORMALIZED_FIELD (second, field, norm_fn, flags) \
1703   result = g_strcmp0 (first_cmp, second_cmp); \
1704   g_free (first_norm); \
1705   first_norm = NULL; \
1706   g_free (second_norm); \
1707   second_norm = NULL; \
1708   if (result != 0) return FALSE
1709 
1710 /* compare two string values */
1711 #define GST_URI_CMP_STR(field) \
1712   if (g_strcmp0 (first-&gt;field, second-&gt;field) != 0) return FALSE
1713 
1714 /* compare two GLists, normalize lists if needed before comparison */
1715 #define GST_URI_NORMALIZED_CMP_LIST(field, norm_fn, copy_fn, cmp_fn, free_fn) \
1716   first_norm_list = g_list_copy_deep (first-&gt;field, (GCopyFunc) copy_fn, NULL); \
1717   norm_fn (&amp;first_norm_list); \
1718   second_norm_list = g_list_copy_deep (second-&gt;field, (GCopyFunc) copy_fn, NULL); \
1719   norm_fn (&amp;second_norm_list); \
1720   result = _gst_uri_compare_lists (first_norm_list, second_norm_list, (GCompareFunc) cmp_fn); \
1721   g_list_free_full (first_norm_list, free_fn); \
1722   g_list_free_full (second_norm_list, free_fn); \
1723   if (result != 0) return FALSE
1724 
1725   GST_URI_CMP_STR (userinfo);
1726 
1727   GST_URI_CMP_STR (fragment);
1728 
1729   GST_URI_NORMALIZED_CMP_STR (scheme, _gst_uri_normalize_scheme,
1730       _GST_URI_NORMALIZE_LOWERCASE);
1731 
1732   GST_URI_NORMALIZED_CMP_STR (host, _gst_uri_normalize_hostname,
1733       _GST_URI_NORMALIZE_LOWERCASE);
1734 
1735   GST_URI_NORMALIZED_CMP_LIST (path, _gst_uri_normalize_path, g_strdup,
1736       g_strcmp0, g_free);
1737 
1738   if (first-&gt;query == NULL &amp;&amp; second-&gt;query != NULL)
1739     return FALSE;
1740   if (first-&gt;query != NULL &amp;&amp; second-&gt;query == NULL)
1741     return FALSE;
1742   if (first-&gt;query != NULL) {
1743     if (g_hash_table_size (first-&gt;query) != g_hash_table_size (second-&gt;query))
1744       return FALSE;
1745 
1746     g_hash_table_iter_init (&amp;table_iter, first-&gt;query);
1747     while (g_hash_table_iter_next (&amp;table_iter, &amp;key, &amp;value)) {
1748       if (!g_hash_table_contains (second-&gt;query, key))
1749         return FALSE;
1750       result = g_strcmp0 (g_hash_table_lookup (second-&gt;query, key), value);
1751       if (result != 0)
1752         return FALSE;
1753     }
1754   }
1755 #undef GST_URI_NORMALIZED_CMP_STR
1756 #undef GST_URI_CMP_STR
1757 #undef GST_URI_NORMALIZED_CMP_LIST
1758 #undef GST_URI_NORMALIZED_FIELD
1759 
1760   return TRUE;
1761 }
1762 
1763 /**
1764  * gst_uri_join:
1765  * @base_uri: (transfer none) (nullable): The base URI to join another to.
1766  * @ref_uri: (transfer none) (nullable): The reference URI to join onto the
1767  *                                       base URI.
1768  *
1769  * Join a reference URI onto a base URI using the method from RFC 3986.
1770  * If either URI is %NULL then the other URI will be returned with the ref count
1771  * increased.
1772  *
1773  * Returns: (transfer full) (nullable): A #GstUri which represents the base
1774  *                                      with the reference URI joined on.
1775  *
1776  * Since: 1.6
1777  */
1778 GstUri *
1779 gst_uri_join (GstUri * base_uri, GstUri * ref_uri)
1780 {
1781   const gchar *r_scheme;
1782   GstUri *t;
1783 
1784   g_return_val_if_fail ((base_uri == NULL || GST_IS_URI (base_uri)) &amp;&amp;
1785       (ref_uri == NULL || GST_IS_URI (ref_uri)), NULL);
1786 
1787   if (base_uri == NULL &amp;&amp; ref_uri == NULL)
1788     return NULL;
1789   if (base_uri == NULL) {
1790     g_return_val_if_fail (GST_IS_URI (ref_uri), NULL);
1791     return gst_uri_ref (ref_uri);
1792   }
1793   if (ref_uri == NULL) {
1794     g_return_val_if_fail (GST_IS_URI (base_uri), NULL);
1795     return gst_uri_ref (base_uri);
1796   }
1797 
1798   g_return_val_if_fail (GST_IS_URI (base_uri) &amp;&amp; GST_IS_URI (ref_uri), NULL);
1799 
1800   t = _gst_uri_new ();
1801 
1802   if (t == NULL)
1803     return t;
1804 
1805   /* process according to RFC3986 */
1806   r_scheme = ref_uri-&gt;scheme;
1807   if (r_scheme != NULL &amp;&amp; g_strcmp0 (base_uri-&gt;scheme, r_scheme) == 0) {
1808     r_scheme = NULL;
1809   }
1810   if (r_scheme != NULL) {
1811     t-&gt;scheme = g_strdup (r_scheme);
1812     t-&gt;userinfo = g_strdup (ref_uri-&gt;userinfo);
1813     t-&gt;host = g_strdup (ref_uri-&gt;host);
1814     t-&gt;port = ref_uri-&gt;port;
1815     t-&gt;path = _remove_dot_segments (ref_uri-&gt;path);
1816     t-&gt;query = _gst_uri_copy_query_table (ref_uri-&gt;query);
1817   } else {
1818     if (ref_uri-&gt;host != NULL) {
1819       t-&gt;userinfo = g_strdup (ref_uri-&gt;userinfo);
1820       t-&gt;host = g_strdup (ref_uri-&gt;host);
1821       t-&gt;port = ref_uri-&gt;port;
1822       t-&gt;path = _remove_dot_segments (ref_uri-&gt;path);
1823       t-&gt;query = _gst_uri_copy_query_table (ref_uri-&gt;query);
1824     } else {
1825       if (ref_uri-&gt;path == NULL) {
1826         t-&gt;path = g_list_copy_deep (base_uri-&gt;path, (GCopyFunc) g_strdup, NULL);
1827         if (ref_uri-&gt;query != NULL)
1828           t-&gt;query = _gst_uri_copy_query_table (ref_uri-&gt;query);
1829         else
1830           t-&gt;query = _gst_uri_copy_query_table (base_uri-&gt;query);
1831       } else {
1832         if (ref_uri-&gt;path-&gt;data == NULL)
1833           t-&gt;path = _remove_dot_segments (ref_uri-&gt;path);
1834         else {
1835           GList *mrgd = _merge (base_uri-&gt;path, ref_uri-&gt;path);
1836           t-&gt;path = _remove_dot_segments (mrgd);
1837           g_list_free_full (mrgd, g_free);
1838         }
1839         t-&gt;query = _gst_uri_copy_query_table (ref_uri-&gt;query);
1840       }
1841       t-&gt;userinfo = g_strdup (base_uri-&gt;userinfo);
1842       t-&gt;host = g_strdup (base_uri-&gt;host);
1843       t-&gt;port = base_uri-&gt;port;
1844     }
1845     t-&gt;scheme = g_strdup (base_uri-&gt;scheme);
1846   }
1847   t-&gt;fragment = g_strdup (ref_uri-&gt;fragment);
1848 
1849   return t;
1850 }
1851 
1852 /**
1853  * gst_uri_join_strings:
1854  * @base_uri: The percent-encoded base URI.
1855  * @ref_uri: The percent-encoded reference URI to join to the @base_uri.
1856  *
1857  * This is a convenience function to join two URI strings and return the result.
1858  * The returned string should be g_free()&#39;d after use.
1859  *
1860  * Returns: (transfer full): A string representing the percent-encoded join of
1861  *          the two URIs.
1862  *
1863  * Since: 1.6
1864  */
1865 gchar *
1866 gst_uri_join_strings (const gchar * base_uri, const gchar * ref_uri)
1867 {
1868   GstUri *base, *result;
1869   gchar *result_uri;
1870 
1871   base = gst_uri_from_string (base_uri);
1872   result = gst_uri_from_string_with_base (base, ref_uri);
1873   result_uri = gst_uri_to_string (result);
1874   gst_uri_unref (base);
1875   gst_uri_unref (result);
1876 
1877   return result_uri;
1878 }
1879 
1880 /**
1881  * gst_uri_is_writable:
1882  * @uri: The #GstUri object to test.
1883  *
1884  * Check if it is safe to write to this #GstUri.
1885  *
1886  * Check if the refcount of @uri is exactly 1, meaning that no other
1887  * reference exists to the #GstUri and that the #GstUri is therefore writable.
1888  *
1889  * Modification of a #GstUri should only be done after verifying that it is
1890  * writable.
1891  *
1892  * Returns: %TRUE if it is safe to write to the object.
1893  *
1894  * Since: 1.6
1895  */
1896 gboolean
1897 gst_uri_is_writable (const GstUri * uri)
1898 {
1899   g_return_val_if_fail (GST_IS_URI (uri), FALSE);
1900   return gst_mini_object_is_writable (GST_MINI_OBJECT_CAST (uri));
1901 }
1902 
1903 /**
1904  * gst_uri_make_writable:
1905  * @uri: (transfer full): The #GstUri object to make writable.
1906  *
1907  * Make the #GstUri writable.
1908  *
1909  * Checks if @uri is writable, and if so the original object is returned. If
1910  * not, then a writable copy is made and returned. This gives away the
1911  * reference to @uri and returns a reference to the new #GstUri.
1912  * If @uri is %NULL then %NULL is returned.
1913  *
1914  * Returns: (transfer full): A writable version of @uri.
1915  *
1916  * Since: 1.6
1917  */
1918 GstUri *
1919 gst_uri_make_writable (GstUri * uri)
1920 {
1921   g_return_val_if_fail (GST_IS_URI (uri), NULL);
1922   return
1923       GST_URI_CAST (gst_mini_object_make_writable (GST_MINI_OBJECT_CAST (uri)));
1924 }
1925 
1926 /**
1927  * gst_uri_to_string:
1928  * @uri: This #GstUri to convert to a string.
1929  *
1930  * Convert the URI to a string.
1931  *
1932  * Returns the URI as held in this object as a #gchar* nul-terminated string.
1933  * The caller should g_free() the string once they are finished with it.
1934  * The string is put together as described in RFC 3986.
1935  *
1936  * Returns: (transfer full): The string version of the URI.
1937  *
1938  * Since: 1.6
1939  */
1940 gchar *
1941 gst_uri_to_string (const GstUri * uri)
1942 {
1943   GString *uri_str;
1944   gchar *escaped;
1945 
1946   g_return_val_if_fail (GST_IS_URI (uri), NULL);
1947 
1948   uri_str = g_string_new (NULL);
1949 
1950   if (uri-&gt;scheme != NULL)
1951     g_string_append_printf (uri_str, &quot;%s:&quot;, uri-&gt;scheme);
1952 
1953   if (uri-&gt;userinfo != NULL || uri-&gt;host != NULL ||
1954       uri-&gt;port != GST_URI_NO_PORT)
1955     g_string_append (uri_str, &quot;//&quot;);
1956 
1957   if (uri-&gt;userinfo != NULL) {
1958     escaped = _gst_uri_escape_userinfo (uri-&gt;userinfo);
1959     g_string_append_printf (uri_str, &quot;%s@&quot;, escaped);
1960     g_free (escaped);
1961   }
1962 
1963   if (uri-&gt;host != NULL) {
1964     if (strchr (uri-&gt;host, &#39;:&#39;) != NULL) {
1965       escaped = _gst_uri_escape_host_colon (uri-&gt;host);
1966       g_string_append_printf (uri_str, &quot;[%s]&quot;, escaped);
1967       g_free (escaped);
1968     } else {
1969       escaped = _gst_uri_escape_host (uri-&gt;host);
1970       g_string_append (uri_str, escaped);
1971       g_free (escaped);
1972     }
1973   }
1974 
1975   if (uri-&gt;port != GST_URI_NO_PORT)
1976     g_string_append_printf (uri_str, &quot;:%u&quot;, uri-&gt;port);
1977 
1978   if (uri-&gt;path != NULL) {
1979     escaped = gst_uri_get_path_string (uri);
1980     g_string_append (uri_str, escaped);
1981     g_free (escaped);
1982   }
1983 
1984   if (uri-&gt;query) {
1985     g_string_append (uri_str, &quot;?&quot;);
1986     escaped = gst_uri_get_query_string (uri);
1987     g_string_append (uri_str, escaped);
1988     g_free (escaped);
1989   }
1990 
1991   if (uri-&gt;fragment != NULL) {
1992     escaped = _gst_uri_escape_fragment (uri-&gt;fragment);
1993     g_string_append_printf (uri_str, &quot;#%s&quot;, escaped);
1994     g_free (escaped);
1995   }
1996 
1997   return g_string_free (uri_str, FALSE);
1998 }
1999 
2000 /**
2001  * gst_uri_is_normalized:
2002  * @uri: The #GstUri to test to see if it is normalized.
2003  *
2004  * Tests the @uri to see if it is normalized. A %NULL @uri is considered to be
2005  * normalized.
2006  *
2007  * Returns: TRUE if the URI is normalized or is %NULL.
2008  *
2009  * Since: 1.6
2010  */
2011 gboolean
2012 gst_uri_is_normalized (const GstUri * uri)
2013 {
2014   GList *new_path;
2015   gboolean ret;
2016 
2017   if (uri == NULL)
2018     return TRUE;
2019 
2020   g_return_val_if_fail (GST_IS_URI (uri), FALSE);
2021 
2022   /* check for non-normalized characters in uri parts */
2023   if (_gst_uri_first_non_normalized_char (uri-&gt;scheme,
2024           _GST_URI_NORMALIZE_LOWERCASE) != NULL ||
2025       /*_gst_uri_first_non_normalized_char (uri-&gt;userinfo,
2026           _GST_URI_NORMALIZE_PERCENTAGES) != NULL || */
2027       _gst_uri_first_non_normalized_char (uri-&gt;host,
2028           _GST_URI_NORMALIZE_LOWERCASE /*| _GST_URI_NORMALIZE_PERCENTAGES */ )
2029       != NULL
2030       /*|| _gst_uri_first_non_normalized_char (uri-&gt;path,
2031          _GST_URI_NORMALIZE_PERCENTAGES) != NULL
2032          || _gst_uri_first_non_normalized_char (uri-&gt;query,
2033          _GST_URI_NORMALIZE_PERCENTAGES) != NULL
2034          || _gst_uri_first_non_normalized_char (uri-&gt;fragment,
2035          _GST_URI_NORMALIZE_PERCENTAGES) != NULL */ )
2036     return FALSE;
2037 
2038   /* also check path has had dot segments removed */
2039   new_path = _remove_dot_segments (uri-&gt;path);
2040   ret =
2041       (_gst_uri_compare_lists (new_path, uri-&gt;path,
2042           (GCompareFunc) g_strcmp0) == 0);
2043   g_list_free_full (new_path, g_free);
2044   return ret;
2045 }
2046 
2047 /**
2048  * gst_uri_normalize:
2049  * @uri: (transfer none): The #GstUri to normalize.
2050  *
2051  * Normalization will remove extra path segments (&quot;.&quot; and &quot;..&quot;) from the URI. It
2052  * will also convert the scheme and host name to lower case and any
2053  * percent-encoded values to uppercase.
2054  *
2055  * The #GstUri object must be writable. Check with gst_uri_is_writable() or use
2056  * gst_uri_make_writable() first.
2057  *
2058  * Returns: TRUE if the URI was modified.
2059  *
2060  * Since: 1.6
2061  */
2062 gboolean
2063 gst_uri_normalize (GstUri * uri)
2064 {
2065   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2066 
2067   return _gst_uri_normalize_scheme (uri-&gt;scheme) |
2068       _gst_uri_normalize_userinfo (uri-&gt;userinfo) |
2069       _gst_uri_normalize_hostname (uri-&gt;host) |
2070       _gst_uri_normalize_path (&amp;uri-&gt;path) |
2071       _gst_uri_normalize_query (uri-&gt;query) |
2072       _gst_uri_normalize_fragment (uri-&gt;fragment);
2073 }
2074 
2075 /**
2076  * gst_uri_get_scheme:
2077  * @uri: (nullable): This #GstUri object.
2078  *
2079  * Get the scheme name from the URI or %NULL if it doesn&#39;t exist.
2080  * If @uri is %NULL then returns %NULL.
2081  *
2082  * Returns: (nullable): The scheme from the #GstUri object or %NULL.
2083  */
2084 const gchar *
2085 gst_uri_get_scheme (const GstUri * uri)
2086 {
2087   g_return_val_if_fail (uri == NULL || GST_IS_URI (uri), NULL);
2088   return (uri ? uri-&gt;scheme : NULL);
2089 }
2090 
2091 /**
2092  * gst_uri_set_scheme:
2093  * @uri: (transfer none)(nullable): The #GstUri to modify.
2094  * @scheme: The new scheme to set or %NULL to unset the scheme.
2095  *
2096  * Set or unset the scheme for the URI.
2097  *
2098  * Returns: %TRUE if the scheme was set/unset successfully.
2099  *
2100  * Since: 1.6
2101  */
2102 gboolean
2103 gst_uri_set_scheme (GstUri * uri, const gchar * scheme)
2104 {
2105   if (!uri)
2106     return scheme == NULL;
2107   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2108 
2109   g_free (uri-&gt;scheme);
2110   uri-&gt;scheme = g_strdup (scheme);
2111 
2112   return TRUE;
2113 }
2114 
2115 /**
2116  * gst_uri_get_userinfo:
2117  * @uri: (nullable): This #GstUri object.
2118  *
2119  * Get the userinfo (usually in the form &quot;username:password&quot;) from the URI
2120  * or %NULL if it doesn&#39;t exist. If @uri is %NULL then returns %NULL.
2121  *
2122  * Returns: (nullable): The userinfo from the #GstUri object or %NULL.
2123  *
2124  * Since: 1.6
2125  */
2126 const gchar *
2127 gst_uri_get_userinfo (const GstUri * uri)
2128 {
2129   g_return_val_if_fail (uri == NULL || GST_IS_URI (uri), NULL);
2130   return (uri ? uri-&gt;userinfo : NULL);
2131 }
2132 
2133 /**
2134  * gst_uri_set_userinfo:
2135  * @uri: (transfer none)(nullable): The #GstUri to modify.
2136  * @userinfo: The new user-information string to set or %NULL to unset.
2137  *
2138  * Set or unset the user information for the URI.
2139  *
2140  * Returns: %TRUE if the user information was set/unset successfully.
2141  *
2142  * Since: 1.6
2143  */
2144 gboolean
2145 gst_uri_set_userinfo (GstUri * uri, const gchar * userinfo)
2146 {
2147   if (!uri)
2148     return userinfo == NULL;
2149   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2150 
2151   g_free (uri-&gt;userinfo);
2152   uri-&gt;userinfo = g_strdup (userinfo);
2153 
2154   return TRUE;
2155 }
2156 
2157 /**
2158  * gst_uri_get_host:
2159  * @uri: (nullable): This #GstUri object.
2160  *
2161  * Get the host name from the URI or %NULL if it doesn&#39;t exist.
2162  * If @uri is %NULL then returns %NULL.
2163  *
2164  * Returns: (nullable): The host name from the #GstUri object or %NULL.
2165  *
2166  * Since: 1.6
2167  */
2168 const gchar *
2169 gst_uri_get_host (const GstUri * uri)
2170 {
2171   g_return_val_if_fail (uri == NULL || GST_IS_URI (uri), NULL);
2172   return (uri ? uri-&gt;host : NULL);
2173 }
2174 
2175 /**
2176  * gst_uri_set_host:
2177  * @uri: (transfer none)(nullable): The #GstUri to modify.
2178  * @host: The new host string to set or %NULL to unset.
2179  *
2180  * Set or unset the host for the URI.
2181  *
2182  * Returns: %TRUE if the host was set/unset successfully.
2183  *
2184  * Since: 1.6
2185  */
2186 gboolean
2187 gst_uri_set_host (GstUri * uri, const gchar * host)
2188 {
2189   if (!uri)
2190     return host == NULL;
2191   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2192 
2193   g_free (uri-&gt;host);
2194   uri-&gt;host = g_strdup (host);
2195 
2196   return TRUE;
2197 }
2198 
2199 /**
2200  * gst_uri_get_port:
2201  * @uri: (nullable): This #GstUri object.
2202  *
2203  * Get the port number from the URI or %GST_URI_NO_PORT if it doesn&#39;t exist.
2204  * If @uri is %NULL then returns %GST_URI_NO_PORT.
2205  *
2206  * Returns: The port number from the #GstUri object or %GST_URI_NO_PORT.
2207  *
2208  * Since: 1.6
2209  */
2210 guint
2211 gst_uri_get_port (const GstUri * uri)
2212 {
2213   g_return_val_if_fail (uri == NULL || GST_IS_URI (uri), GST_URI_NO_PORT);
2214   return (uri ? uri-&gt;port : GST_URI_NO_PORT);
2215 }
2216 
2217 /**
2218  * gst_uri_set_port:
2219  * @uri: (transfer none)(nullable): The #GstUri to modify.
2220  * @port: The new port number to set or %GST_URI_NO_PORT to unset.
2221  *
2222  * Set or unset the port number for the URI.
2223  *
2224  * Returns: %TRUE if the port number was set/unset successfully.
2225  *
2226  * Since: 1.6
2227  */
2228 gboolean
2229 gst_uri_set_port (GstUri * uri, guint port)
2230 {
2231   if (!uri)
2232     return port == GST_URI_NO_PORT;
2233   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2234 
2235   uri-&gt;port = port;
2236 
2237   return TRUE;
2238 }
2239 
2240 /**
2241  * gst_uri_get_path:
2242  * @uri: The #GstUri to get the path from.
2243  *
2244  * Extract the path string from the URI object.
2245  *
2246  * Returns: (transfer full): (nullable): The path from the URI. Once finished
2247  *                                       with the string should be g_free()&#39;d.
2248  *
2249  * Since: 1.6
2250  */
2251 gchar *
2252 gst_uri_get_path (const GstUri * uri)
2253 {
2254   GList *path_segment;
2255   const gchar *sep = &quot;&quot;;
2256   GString *ret;
2257 
2258   if (!uri)
2259     return NULL;
2260   g_return_val_if_fail (GST_IS_URI (uri), NULL);
2261   if (!uri-&gt;path)
2262     return NULL;
2263 
2264   ret = g_string_new (NULL);
2265 
2266   for (path_segment = uri-&gt;path; path_segment;
2267       path_segment = path_segment-&gt;next) {
2268     g_string_append (ret, sep);
2269     if (path_segment-&gt;data) {
2270       g_string_append (ret, path_segment-&gt;data);
2271     }
2272     sep = &quot;/&quot;;
2273   }
2274 
2275   return g_string_free (ret, FALSE);
2276 }
2277 
2278 /**
2279  * gst_uri_set_path:
2280  * @uri: (transfer none) (nullable): The #GstUri to modify.
2281  * @path: The new path to set with path segments separated by &#39;/&#39;, or use %NULL
2282  *        to unset the path.
2283  *
2284  * Sets or unsets the path in the URI.
2285  *
2286  * Returns: %TRUE if the path was set successfully.
2287  *
2288  * Since: 1.6
2289  */
2290 gboolean
2291 gst_uri_set_path (GstUri * uri, const gchar * path)
2292 {
2293   if (!uri)
2294     return path == NULL;
2295   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2296 
2297   g_list_free_full (uri-&gt;path, g_free);
2298   uri-&gt;path = _gst_uri_string_to_list (path, &quot;/&quot;, FALSE, FALSE);
2299 
2300   return TRUE;
2301 }
2302 
2303 /**
2304  * gst_uri_get_path_string:
2305  * @uri: The #GstUri to get the path from.
2306  *
2307  * Extract the path string from the URI object as a percent encoded URI path.
2308  *
2309  * Returns: (transfer full) (nullable): The path from the URI. Once finished
2310  *                                      with the string should be g_free()&#39;d.
2311  *
2312  * Since: 1.6
2313  */
2314 gchar *
2315 gst_uri_get_path_string (const GstUri * uri)
2316 {
2317   GList *path_segment;
2318   const gchar *sep = &quot;&quot;;
2319   GString *ret;
2320   gchar *escaped;
2321 
2322   if (!uri)
2323     return NULL;
2324   g_return_val_if_fail (GST_IS_URI (uri), NULL);
2325   if (!uri-&gt;path)
2326     return NULL;
2327 
2328   ret = g_string_new (NULL);
2329 
2330   for (path_segment = uri-&gt;path; path_segment;
2331       path_segment = path_segment-&gt;next) {
2332     g_string_append (ret, sep);
2333     if (path_segment-&gt;data) {
2334       escaped = _gst_uri_escape_path_segment (path_segment-&gt;data);
2335       g_string_append (ret, escaped);
2336       g_free (escaped);
2337     }
2338     sep = &quot;/&quot;;
2339   }
2340 
2341   return g_string_free (ret, FALSE);
2342 }
2343 
2344 /**
2345  * gst_uri_set_path_string:
2346  * @uri: (transfer none)(nullable): The #GstUri to modify.
2347  * @path: The new percent encoded path to set with path segments separated by
2348  * &#39;/&#39;, or use %NULL to unset the path.
2349  *
2350  * Sets or unsets the path in the URI.
2351  *
2352  * Returns: %TRUE if the path was set successfully.
2353  *
2354  * Since: 1.6
2355  */
2356 gboolean
2357 gst_uri_set_path_string (GstUri * uri, const gchar * path)
2358 {
2359   if (!uri)
2360     return path == NULL;
2361   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2362 
2363   g_list_free_full (uri-&gt;path, g_free);
2364   uri-&gt;path = _gst_uri_string_to_list (path, &quot;/&quot;, FALSE, TRUE);
2365   return TRUE;
2366 }
2367 
2368 /**
2369  * gst_uri_get_path_segments:
2370  * @uri: (nullable): The #GstUri to get the path from.
2371  *
2372  * Get a list of path segments from the URI.
2373  *
2374  * Returns: (transfer full) (element-type gchar*): A #GList of path segment
2375  *          strings or %NULL if no path segments are available. Free the list
2376  *          when no longer needed with g_list_free_full(list, g_free).
2377  *
2378  * Since: 1.6
2379  */
2380 GList *
2381 gst_uri_get_path_segments (const GstUri * uri)
2382 {
2383   GList *ret = NULL;
2384 
2385   g_return_val_if_fail (uri == NULL || GST_IS_URI (uri), NULL);
2386 
2387   if (uri) {
2388     ret = g_list_copy_deep (uri-&gt;path, (GCopyFunc) g_strdup, NULL);
2389   }
2390 
2391   return ret;
2392 }
2393 
2394 /**
2395  * gst_uri_set_path_segments:
2396  * @uri: (transfer none)(nullable): The #GstUri to modify.
2397  * @path_segments: (transfer full)(nullable)(element-type gchar*): The new
2398  *                 path list to set.
2399  *
2400  * Replace the path segments list in the URI.
2401  *
2402  * Returns: %TRUE if the path segments were set successfully.
2403  *
2404  * Since: 1.6
2405  */
2406 gboolean
2407 gst_uri_set_path_segments (GstUri * uri, GList * path_segments)
2408 {
2409   g_return_val_if_fail (uri == NULL || GST_IS_URI (uri), FALSE);
2410 
2411   if (!uri) {
2412     if (path_segments)
2413       g_list_free_full (path_segments, g_free);
2414     return path_segments == NULL;
2415   }
2416 
2417   g_return_val_if_fail (gst_uri_is_writable (uri), FALSE);
2418 
2419   g_list_free_full (uri-&gt;path, g_free);
2420   uri-&gt;path = path_segments;
2421   return TRUE;
2422 }
2423 
2424 /**
2425  * gst_uri_append_path:
2426  * @uri: (transfer none)(nullable): The #GstUri to modify.
2427  * @relative_path: Relative path to append to the end of the current path.
2428  *
2429  * Append a path onto the end of the path in the URI. The path is not
2430  * normalized, call #gst_uri_normalize() to normalize the path.
2431  *
2432  * Returns: %TRUE if the path was appended successfully.
2433  *
2434  * Since: 1.6
2435  */
2436 gboolean
2437 gst_uri_append_path (GstUri * uri, const gchar * relative_path)
2438 {
2439   GList *rel_path_list;
2440 
2441   if (!uri)
2442     return relative_path == NULL;
2443   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2444   if (!relative_path)
2445     return TRUE;
2446 
2447   if (uri-&gt;path) {
2448     GList *last_elem = g_list_last (uri-&gt;path);
2449     if (last_elem-&gt;data == NULL) {
2450       uri-&gt;path = g_list_delete_link (uri-&gt;path, last_elem);
2451     }
2452   }
2453   rel_path_list = _gst_uri_string_to_list (relative_path, &quot;/&quot;, FALSE, FALSE);
2454   /* if path was absolute, make it relative by removing initial NULL element */
2455   if (rel_path_list &amp;&amp; rel_path_list-&gt;data == NULL) {
2456     rel_path_list = g_list_delete_link (rel_path_list, rel_path_list);
2457   }
2458   uri-&gt;path = g_list_concat (uri-&gt;path, rel_path_list);
2459   return TRUE;
2460 }
2461 
2462 /**
2463  * gst_uri_append_path_segment:
2464  * @uri: (transfer none)(nullable): The #GstUri to modify.
2465  * @path_segment: The path segment string to append to the URI path.
2466  *
2467  * Append a single path segment onto the end of the URI path.
2468  *
2469  * Returns: %TRUE if the path was appended successfully.
2470  *
2471  * Since: 1.6
2472  */
2473 gboolean
2474 gst_uri_append_path_segment (GstUri * uri, const gchar * path_segment)
2475 {
2476   if (!uri)
2477     return path_segment == NULL;
2478   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2479   if (!path_segment)
2480     return TRUE;
2481 
2482   /* if base path ends in a directory (i.e. last element is NULL), remove it */
2483   if (uri-&gt;path &amp;&amp; g_list_last (uri-&gt;path)-&gt;data == NULL) {
2484     uri-&gt;path = g_list_delete_link (uri-&gt;path, g_list_last (uri-&gt;path));
2485   }
2486   uri-&gt;path = g_list_append (uri-&gt;path, g_strdup (path_segment));
2487   return TRUE;
2488 }
2489 
2490 /**
2491  * gst_uri_get_query_string:
2492  * @uri: (nullable): The #GstUri to get the query string from.
2493  *
2494  * Get a percent encoded URI query string from the @uri.
2495  *
2496  * Returns: (transfer full) (nullable): A percent encoded query string. Use
2497  *                                      g_free() when no longer needed.
2498  *
2499  * Since: 1.6
2500  */
2501 gchar *
2502 gst_uri_get_query_string (const GstUri * uri)
2503 {
2504   GHashTableIter iter;
2505   gpointer key, value;
2506   const gchar *sep = &quot;&quot;;
2507   gchar *escaped;
2508   GString *ret;
2509 
2510   if (!uri)
2511     return NULL;
2512   g_return_val_if_fail (GST_IS_URI (uri), NULL);
2513   if (!uri-&gt;query)
2514     return NULL;
2515 
2516   ret = g_string_new (NULL);
2517   g_hash_table_iter_init (&amp;iter, uri-&gt;query);
2518   while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value)) {
2519     g_string_append (ret, sep);
2520     escaped = _gst_uri_escape_http_query_element (key);
2521     g_string_append (ret, escaped);
2522     g_free (escaped);
2523     if (value) {
2524       escaped = _gst_uri_escape_http_query_element (value);
2525       g_string_append_printf (ret, &quot;=%s&quot;, escaped);
2526       g_free (escaped);
2527     }
2528     sep = &quot;&amp;&quot;;
2529   }
2530 
2531   return g_string_free (ret, FALSE);
2532 }
2533 
2534 /**
2535  * gst_uri_set_query_string:
2536  * @uri: (transfer none)(nullable): The #GstUri to modify.
2537  * @query: The new percent encoded query string to use to populate the query
2538  *        table, or use %NULL to unset the query table.
2539  *
2540  * Sets or unsets the query table in the URI.
2541  *
2542  * Returns: %TRUE if the query table was set successfully.
2543  *
2544  * Since: 1.6
2545  */
2546 gboolean
2547 gst_uri_set_query_string (GstUri * uri, const gchar * query)
2548 {
2549   if (!uri)
2550     return query == NULL;
2551 
2552   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2553 
2554   if (uri-&gt;query)
2555     g_hash_table_unref (uri-&gt;query);
2556   uri-&gt;query = _gst_uri_string_to_table (query, &quot;&amp;&quot;, &quot;=&quot;, TRUE, TRUE);
2557 
2558   return TRUE;
2559 }
2560 
2561 /**
2562  * gst_uri_get_query_table:
2563  * @uri: (nullable): The #GstUri to get the query table from.
2564  *
2565  * Get the query table from the URI. Keys and values in the table are freed
2566  * with g_free when they are deleted. A value may be %NULL to indicate that
2567  * the key should appear in the query string in the URI, but does not have a
2568  * value. Free the returned #GHashTable with #g_hash_table_unref() when it is
2569  * no longer required. Modifying this hash table will modify the query in the
2570  * URI.
2571  *
2572  * Returns: (transfer full) (element-type gchar* gchar*) (nullable): The query
2573  *          hash table from the URI.
2574  *
2575  * Since: 1.6
2576  */
2577 GHashTable *
2578 gst_uri_get_query_table (const GstUri * uri)
2579 {
2580   if (!uri)
2581     return NULL;
2582   g_return_val_if_fail (GST_IS_URI (uri), NULL);
2583   if (!uri-&gt;query)
2584     return NULL;
2585 
2586   return g_hash_table_ref (uri-&gt;query);
2587 }
2588 
2589 /**
2590  * gst_uri_set_query_table:
2591  * @uri: (transfer none)(nullable): The #GstUri to modify.
2592  * @query_table: (transfer none)(nullable)(element-type gchar* gchar*): The new
2593  *               query table to use.
2594  *
2595  * Set the query table to use in the URI. The old table is unreferenced and a
2596  * reference to the new one is used instead. A value if %NULL for @query_table
2597  * will remove the query string from the URI.
2598  *
2599  * Returns: %TRUE if the new table was sucessfully used for the query table.
2600  *
2601  * Since: 1.6
2602  */
2603 gboolean
2604 gst_uri_set_query_table (GstUri * uri, GHashTable * query_table)
2605 {
2606   GHashTable *old_table = NULL;
2607 
2608   if (!uri)
2609     return query_table == NULL;
2610   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2611 
2612   old_table = uri-&gt;query;
2613   if (query_table)
2614     uri-&gt;query = g_hash_table_ref (query_table);
2615   else
2616     uri-&gt;query = NULL;
2617   if (old_table)
2618     g_hash_table_unref (old_table);
2619 
2620   return TRUE;
2621 }
2622 
2623 /**
2624  * gst_uri_set_query_value:
2625  * @uri: (transfer none)(nullable): The #GstUri to modify.
2626  * @query_key: (transfer none): The key for the query entry.
2627  * @query_value: (transfer none)(nullable): The value for the key.
2628  *
2629  * This inserts or replaces a key in the query table. A @query_value of %NULL
2630  * indicates that the key has no associated value, but will still be present in
2631  * the query string.
2632  *
2633  * Returns: %TRUE if the query table was sucessfully updated.
2634  *
2635  * Since: 1.6
2636  */
2637 gboolean
2638 gst_uri_set_query_value (GstUri * uri, const gchar * query_key,
2639     const gchar * query_value)
2640 {
2641   if (!uri)
2642     return FALSE;
2643   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2644 
2645   if (!uri-&gt;query) {
2646     uri-&gt;query = g_hash_table_new_full (g_str_hash, g_str_equal, g_free,
2647         g_free);
2648   }
2649   g_hash_table_insert (uri-&gt;query, g_strdup (query_key),
2650       g_strdup (query_value));
2651 
2652   return TRUE;
2653 }
2654 
2655 /**
2656  * gst_uri_remove_query_key:
2657  * @uri: (transfer none)(nullable): The #GstUri to modify.
2658  * @query_key: The key to remove.
2659  *
2660  * Remove an entry from the query table by key.
2661  *
2662  * Returns: %TRUE if the key existed in the table and was removed.
2663  *
2664  * Since: 1.6
2665  */
2666 gboolean
2667 gst_uri_remove_query_key (GstUri * uri, const gchar * query_key)
2668 {
2669   gboolean result;
2670 
2671   if (!uri)
2672     return FALSE;
2673   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2674   if (!uri-&gt;query)
2675     return FALSE;
2676 
2677   result = g_hash_table_remove (uri-&gt;query, query_key);
2678   /* if this was the last query entry, remove the query string completely */
2679   if (result &amp;&amp; g_hash_table_size (uri-&gt;query) == 0) {
2680     g_hash_table_unref (uri-&gt;query);
2681     uri-&gt;query = NULL;
2682   }
2683   return result;
2684 }
2685 
2686 /**
2687  * gst_uri_query_has_key:
2688  * @uri: (nullable): The #GstUri to examine.
2689  * @query_key: The key to lookup.
2690  *
2691  * Check if there is a query table entry for the @query_key key.
2692  *
2693  * Returns: %TRUE if @query_key exists in the URI query table.
2694  *
2695  * Since: 1.6
2696  */
2697 gboolean
2698 gst_uri_query_has_key (const GstUri * uri, const gchar * query_key)
2699 {
2700   if (!uri)
2701     return FALSE;
2702   g_return_val_if_fail (GST_IS_URI (uri), FALSE);
2703   if (!uri-&gt;query)
2704     return FALSE;
2705 
2706   return g_hash_table_contains (uri-&gt;query, query_key);
2707 }
2708 
2709 /**
2710  * gst_uri_get_query_value:
2711  * @uri: (nullable): The #GstUri to examine.
2712  * @query_key: The key to lookup.
2713  *
2714  * Get the value associated with the @query_key key. Will return %NULL if the
2715  * key has no value or if the key does not exist in the URI query table. Because
2716  * %NULL is returned for both missing keys and keys with no value, you should
2717  * use gst_uri_query_has_key() to determine if a key is present in the URI
2718  * query.
2719  *
2720  * Returns: (nullable): The value for the given key, or %NULL if not found.
2721  *
2722  * Since: 1.6
2723  */
2724 const gchar *
2725 gst_uri_get_query_value (const GstUri * uri, const gchar * query_key)
2726 {
2727   if (!uri)
2728     return NULL;
2729   g_return_val_if_fail (GST_IS_URI (uri), NULL);
2730   if (!uri-&gt;query)
2731     return NULL;
2732 
2733   return g_hash_table_lookup (uri-&gt;query, query_key);
2734 }
2735 
2736 /**
2737  * gst_uri_get_query_keys:
2738  * @uri: (nullable): The #GstUri to examine.
2739  *
2740  * Get a list of the query keys from the URI.
2741  *
2742  * Returns: (transfer container) (element-type gchar*): A list of keys from
2743  *          the URI query. Free the list with g_list_free().
2744  *
2745  * Since: 1.6
2746  */
2747 GList *
2748 gst_uri_get_query_keys (const GstUri * uri)
2749 {
2750   if (!uri)
2751     return NULL;
2752   g_return_val_if_fail (GST_IS_URI (uri), NULL);
2753   if (!uri-&gt;query)
2754     return NULL;
2755 
2756   return g_hash_table_get_keys (uri-&gt;query);
2757 }
2758 
2759 /**
2760  * gst_uri_get_fragment:
2761  * @uri: (nullable): This #GstUri object.
2762  *
2763  * Get the fragment name from the URI or %NULL if it doesn&#39;t exist.
2764  * If @uri is %NULL then returns %NULL.
2765  *
2766  * Returns: (nullable): The host name from the #GstUri object or %NULL.
2767  *
2768  * Since: 1.6
2769  */
2770 const gchar *
2771 gst_uri_get_fragment (const GstUri * uri)
2772 {
2773   g_return_val_if_fail (uri == NULL || GST_IS_URI (uri), NULL);
2774   return (uri ? uri-&gt;fragment : NULL);
2775 }
2776 
2777 /**
2778  * gst_uri_set_fragment:
2779  * @uri: (transfer none)(nullable): The #GstUri to modify.
2780  * @fragment: (nullable): The fragment string to set.
2781  *
2782  * Sets the fragment string in the URI. Use a value of %NULL in @fragment to
2783  * unset the fragment string.
2784  *
2785  * Returns: %TRUE if the fragment was set/unset successfully.
2786  *
2787  * Since: 1.6
2788  */
2789 gboolean
2790 gst_uri_set_fragment (GstUri * uri, const gchar * fragment)
2791 {
2792   if (!uri)
2793     return fragment == NULL;
2794   g_return_val_if_fail (GST_IS_URI (uri) &amp;&amp; gst_uri_is_writable (uri), FALSE);
2795 
2796   g_free (uri-&gt;fragment);
2797   uri-&gt;fragment = g_strdup (fragment);
2798   return TRUE;
2799 }
2800 
2801 /**
2802  * gst_uri_get_media_fragment_table:
2803  * @uri: (nullable): The #GstUri to get the fragment table from.
2804  *
2805  * Get the media fragment table from the URI, as defined by &quot;Media Fragments URI 1.0&quot;.
2806  * Hash table returned by this API is a list of &quot;key-value&quot; pairs, and the each
2807  * pair is generated by splitting &quot;URI fragment&quot; per &quot;&amp;&quot; sub-delims, then &quot;key&quot;
2808  * and &quot;value&quot; are splitted by &quot;=&quot; sub-delims. The &quot;key&quot; returned by this API may
2809  * be undefined keyword by standard.
2810  * A value may be %NULL to indicate that the key should appear in the fragment
2811  * string in the URI, but does not have a value. Free the returned #GHashTable
2812  * with #g_hash_table_unref() when it is no longer required.
2813  * Modifying this hash table does not affect the fragment in the URI.
2814  *
2815  * See more about Media Fragments URI 1.0 (W3C) at https://www.w3.org/TR/media-frags/
2816  *
2817  * Returns: (transfer full) (element-type gchar* gchar*) (nullable): The
2818  *          fragment hash table from the URI.
2819  *
2820  * Since: 1.12
2821  */
2822 GHashTable *
2823 gst_uri_get_media_fragment_table (const GstUri * uri)
2824 {
2825   g_return_val_if_fail (uri == NULL || GST_IS_URI (uri), NULL);
2826 
2827   if (!uri-&gt;fragment)
2828     return NULL;
2829   return _gst_uri_string_to_table (uri-&gt;fragment, &quot;&amp;&quot;, &quot;=&quot;, TRUE, TRUE);
2830 }
    </pre>
  </body>
</html>