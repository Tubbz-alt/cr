<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gvaluearray.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gvalue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvaluearray.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gvaluearray.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 38  * object property that holds an array of values. A #GValueArray wraps
 39  * an array of #GValue elements in order for it to be used as a boxed
 40  * type through %G_TYPE_VALUE_ARRAY.
 41  *
 42  * #GValueArray is deprecated in favour of #GArray since GLib 2.32. It
 43  * is possible to create a #GArray that behaves like a #GValueArray by
 44  * using the size of #GValue as the element size, and by setting
 45  * g_value_unset() as the clear function using g_array_set_clear_func(),
 46  * for instance, the following code:
 47  *
 48  * |[&lt;!-- language=&quot;C&quot; --&gt;
 49  *   GValueArray *array = g_value_array_new (10);
 50  * ]|
 51  *
 52  * can be replaced by:
 53  *
 54  * |[&lt;!-- language=&quot;C&quot; --&gt;
 55  *   GArray *array = g_array_sized_new (FALSE, TRUE, sizeof (GValue), 10);
 56  *   g_array_set_clear_func (array, (GDestroyNotify) g_value_unset);
 57  * ]|



 58  */
 59 
 60 #define GROUP_N_VALUES  (8) /* power of 2 !! */
 61 
 62 
 63 /* --- functions --- */
 64 /**
 65  * g_value_array_get_nth:
 66  * @value_array: #GValueArray to get a value from
 67  * @index_: index of the value of interest
 68  *
 69  * Return a pointer to the value at @index_ containd in @value_array.
 70  *
 71  * Returns: (transfer none): pointer to a value at @index_ in @value_array
 72  *
 73  * Deprecated: 2.32: Use g_array_index() instead.
 74  */
 75 GValue*
 76 g_value_array_get_nth (GValueArray *value_array,
<span class="line-modified"> 77                guint        index)</span>
 78 {
 79   g_return_val_if_fail (value_array != NULL, NULL);
 80   g_return_val_if_fail (index &lt; value_array-&gt;n_values, NULL);
 81 
 82   return value_array-&gt;values + index;
 83 }
 84 
 85 static inline void
 86 value_array_grow (GValueArray *value_array,
<span class="line-modified"> 87           guint        n_values,</span>
<span class="line-modified"> 88           gboolean     zero_init)</span>
 89 {
 90   g_return_if_fail (n_values &gt;= value_array-&gt;n_values);
 91 
 92   value_array-&gt;n_values = n_values;
 93   if (value_array-&gt;n_values &gt; value_array-&gt;n_prealloced)
 94     {
 95       guint i = value_array-&gt;n_prealloced;
 96 
 97       value_array-&gt;n_prealloced = (value_array-&gt;n_values + GROUP_N_VALUES - 1) &amp; ~(GROUP_N_VALUES - 1);
 98       value_array-&gt;values = g_renew (GValue, value_array-&gt;values, value_array-&gt;n_prealloced);
 99       if (!zero_init)
<span class="line-modified">100     i = value_array-&gt;n_values;</span>
101       memset (value_array-&gt;values + i, 0,
<span class="line-modified">102           (value_array-&gt;n_prealloced - i) * sizeof (value_array-&gt;values[0]));</span>
103     }
104 }
105 
106 /**
107  * g_value_array_new:
108  * @n_prealloced: number of values to preallocate space for
109  *
110  * Allocate and initialize a new #GValueArray, optionally preserve space
111  * for @n_prealloced elements. New arrays always contain 0 elements,
112  * regardless of the value of @n_prealloced.
113  *
114  * Returns: a newly allocated #GValueArray with 0 values
115  *
116  * Deprecated: 2.32: Use #GArray and g_array_sized_new() instead.
117  */
118 GValueArray*
119 g_value_array_new (guint n_prealloced)
120 {
121   GValueArray *value_array = g_slice_new (GValueArray);
122 #ifdef GSTREAMER_LITE
</pre>
<hr />
<pre>
137 /**
138  * g_value_array_free: (skip)
139  * @value_array: #GValueArray to free
140  *
141  * Free a #GValueArray including its contents.
142  *
143  * Deprecated: 2.32: Use #GArray and g_array_unref() instead.
144  */
145 void
146 g_value_array_free (GValueArray *value_array)
147 {
148   guint i;
149 
150   g_return_if_fail (value_array != NULL);
151 
152   for (i = 0; i &lt; value_array-&gt;n_values; i++)
153     {
154       GValue *value = value_array-&gt;values + i;
155 
156       if (G_VALUE_TYPE (value) != 0) /* we allow unset values in the array */
<span class="line-modified">157     g_value_unset (value);</span>
158     }
159   g_free (value_array-&gt;values);
160   g_slice_free (GValueArray, value_array);
161 }
162 
163 /**
164  * g_value_array_copy:
165  * @value_array: #GValueArray to copy
166  *
167  * Construct an exact copy of a #GValueArray by duplicating all its
168  * contents.
169  *
170  * Returns: (transfer full): Newly allocated copy of #GValueArray
171  *
172  * Deprecated: 2.32: Use #GArray and g_array_ref() instead.
173  */
174 GValueArray*
175 g_value_array_copy (const GValueArray *value_array)
176 {
177   GValueArray *new_array;
178   guint i;
179 
180   g_return_val_if_fail (value_array != NULL, NULL);
181 
182   new_array = g_slice_new (GValueArray);
183 #ifdef GSTREAMER_LITE
184   if (new_array == NULL) {
185     return NULL;
186   }
187 #endif // GSTREAMER_LITE
188   new_array-&gt;n_values = 0;
189   new_array-&gt;values = NULL;
190   new_array-&gt;n_prealloced = 0;
191   value_array_grow (new_array, value_array-&gt;n_values, TRUE);
192   for (i = 0; i &lt; new_array-&gt;n_values; i++)
193     if (G_VALUE_TYPE (value_array-&gt;values + i) != 0)
194       {
<span class="line-modified">195     GValue *value = new_array-&gt;values + i;</span>
196 
<span class="line-modified">197     g_value_init (value, G_VALUE_TYPE (value_array-&gt;values + i));</span>
<span class="line-modified">198     g_value_copy (value_array-&gt;values + i, value);</span>
199       }
200   return new_array;
201 }
202 
203 /**
204  * g_value_array_prepend:
205  * @value_array: #GValueArray to add an element to
206  * @value: (nullable): #GValue to copy into #GValueArray, or %NULL
207  *
208  * Insert a copy of @value as first element of @value_array. If @value is
209  * %NULL, an uninitialized value is prepended.
210  *
211  *
212  * Returns: (transfer none): the #GValueArray passed in as @value_array
213  *
214  * Deprecated: 2.32: Use #GArray and g_array_prepend_val() instead.
215  */
216 GValueArray*
217 g_value_array_prepend (GValueArray  *value_array,
<span class="line-modified">218                const GValue *value)</span>
219 {
220   g_return_val_if_fail (value_array != NULL, NULL);
221 
222   G_GNUC_BEGIN_IGNORE_DEPRECATIONS
223   return g_value_array_insert (value_array, 0, value);
224   G_GNUC_END_IGNORE_DEPRECATIONS
225 }
226 
227 /**
228  * g_value_array_append:
229  * @value_array: #GValueArray to add an element to
230  * @value: (nullable): #GValue to copy into #GValueArray, or %NULL
231  *
232  * Insert a copy of @value as last element of @value_array. If @value is
233  * %NULL, an uninitialized value is appended.
234  *
235  * Returns: (transfer none): the #GValueArray passed in as @value_array
236  *
237  * Deprecated: 2.32: Use #GArray and g_array_append_val() instead.
238  */
239 GValueArray*
240 g_value_array_append (GValueArray  *value_array,
<span class="line-modified">241               const GValue *value)</span>
242 {
243   g_return_val_if_fail (value_array != NULL, NULL);
244 
245   G_GNUC_BEGIN_IGNORE_DEPRECATIONS
246   return g_value_array_insert (value_array, value_array-&gt;n_values, value);
247   G_GNUC_END_IGNORE_DEPRECATIONS
248 }
249 
250 /**
251  * g_value_array_insert:
252  * @value_array: #GValueArray to add an element to
253  * @index_: insertion position, must be &lt;= value_array-&gt;;n_values
254  * @value: (nullable): #GValue to copy into #GValueArray, or %NULL
255  *
256  * Insert a copy of @value at specified position into @value_array. If @value
257  * is %NULL, an uninitialized value is inserted.
258  *
259  * Returns: (transfer none): the #GValueArray passed in as @value_array
260  *
261  * Deprecated: 2.32: Use #GArray and g_array_insert_val() instead.
262  */
263 GValueArray*
264 g_value_array_insert (GValueArray  *value_array,
<span class="line-modified">265               guint         index,</span>
<span class="line-modified">266               const GValue *value)</span>
267 {
268   guint i;
269 
270   g_return_val_if_fail (value_array != NULL, NULL);
271   g_return_val_if_fail (index &lt;= value_array-&gt;n_values, value_array);
272 
273   i = value_array-&gt;n_values;
274   value_array_grow (value_array, value_array-&gt;n_values + 1, FALSE);
275   if (index + 1 &lt; value_array-&gt;n_values)
276     memmove (value_array-&gt;values + index + 1, value_array-&gt;values + index,
277              (i - index) * sizeof (value_array-&gt;values[0]));
278   memset (value_array-&gt;values + index, 0, sizeof (value_array-&gt;values[0]));
279   if (value)
280     {
281       g_value_init (value_array-&gt;values + index, G_VALUE_TYPE (value));
282       g_value_copy (value, value_array-&gt;values + index);
283     }
284   return value_array;
285 }
286 
287 /**
288  * g_value_array_remove:
289  * @value_array: #GValueArray to remove an element from
290  * @index_: position of value to remove, which must be less than
291  *     @value_array-&gt;n_values
292  *
293  * Remove the value at position @index_ from @value_array.
294  *
295  * Returns: (transfer none): the #GValueArray passed in as @value_array
296  *
297  * Deprecated: 2.32: Use #GArray and g_array_remove_index() instead.
298  */
299 GValueArray*
300 g_value_array_remove (GValueArray *value_array,
<span class="line-modified">301               guint        index)</span>
302 {
303   g_return_val_if_fail (value_array != NULL, NULL);
304   g_return_val_if_fail (index &lt; value_array-&gt;n_values, value_array);
305 
306   if (G_VALUE_TYPE (value_array-&gt;values + index) != 0)
307     g_value_unset (value_array-&gt;values + index);
308   value_array-&gt;n_values--;
309   if (index &lt; value_array-&gt;n_values)
310     memmove (value_array-&gt;values + index, value_array-&gt;values + index + 1,
311              (value_array-&gt;n_values - index) * sizeof (value_array-&gt;values[0]));
312   if (value_array-&gt;n_prealloced &gt; value_array-&gt;n_values)
313     memset (value_array-&gt;values + value_array-&gt;n_values, 0, sizeof (value_array-&gt;values[0]));
314 
315   return value_array;
316 }
317 
318 /**
319  * g_value_array_sort:
320  * @value_array: #GValueArray to sort
321  * @compare_func: (scope call): function to compare elements
322  *
323  * Sort @value_array using @compare_func to compare the elements according to
324  * the semantics of #GCompareFunc.
325  *
326  * The current implementation uses the same sorting algorithm as standard
327  * C qsort() function.
328  *
329  * Returns: (transfer none): the #GValueArray passed in as @value_array
330  *
331  * Deprecated: 2.32: Use #GArray and g_array_sort().
332  */
333 GValueArray*
334 g_value_array_sort (GValueArray *value_array,
<span class="line-modified">335             GCompareFunc compare_func)</span>
336 {
337   g_return_val_if_fail (compare_func != NULL, NULL);
338 
339   if (value_array-&gt;n_values)
340     qsort (value_array-&gt;values,
<span class="line-modified">341        value_array-&gt;n_values,</span>
<span class="line-modified">342        sizeof (value_array-&gt;values[0]),</span>
<span class="line-modified">343        compare_func);</span>
344   return value_array;
345 }
346 
347 /**
348  * g_value_array_sort_with_data: (rename-to g_value_array_sort)
349  * @value_array: #GValueArray to sort
350  * @compare_func: (scope call): function to compare elements
351  * @user_data: (closure): extra data argument provided for @compare_func
352  *
353  * Sort @value_array using @compare_func to compare the elements according
354  * to the semantics of #GCompareDataFunc.
355  *
356  * The current implementation uses the same sorting algorithm as standard
357  * C qsort() function.
358  *
359  * Returns: (transfer none): the #GValueArray passed in as @value_array
360  *
361  * Deprecated: 2.32: Use #GArray and g_array_sort_with_data().
362  */
363 GValueArray*
364 g_value_array_sort_with_data (GValueArray     *value_array,
<span class="line-modified">365                   GCompareDataFunc compare_func,</span>
<span class="line-modified">366                   gpointer         user_data)</span>
367 {
368   g_return_val_if_fail (value_array != NULL, NULL);
369   g_return_val_if_fail (compare_func != NULL, NULL);
370 
371   if (value_array-&gt;n_values)
372     g_qsort_with_data (value_array-&gt;values,
<span class="line-modified">373                value_array-&gt;n_values,</span>
<span class="line-modified">374                sizeof (value_array-&gt;values[0]),</span>
<span class="line-modified">375                compare_func, user_data);</span>
376   return value_array;
377 }
</pre>
</td>
<td>
<hr />
<pre>
 38  * object property that holds an array of values. A #GValueArray wraps
 39  * an array of #GValue elements in order for it to be used as a boxed
 40  * type through %G_TYPE_VALUE_ARRAY.
 41  *
 42  * #GValueArray is deprecated in favour of #GArray since GLib 2.32. It
 43  * is possible to create a #GArray that behaves like a #GValueArray by
 44  * using the size of #GValue as the element size, and by setting
 45  * g_value_unset() as the clear function using g_array_set_clear_func(),
 46  * for instance, the following code:
 47  *
 48  * |[&lt;!-- language=&quot;C&quot; --&gt;
 49  *   GValueArray *array = g_value_array_new (10);
 50  * ]|
 51  *
 52  * can be replaced by:
 53  *
 54  * |[&lt;!-- language=&quot;C&quot; --&gt;
 55  *   GArray *array = g_array_sized_new (FALSE, TRUE, sizeof (GValue), 10);
 56  *   g_array_set_clear_func (array, (GDestroyNotify) g_value_unset);
 57  * ]|
<span class="line-added"> 58  *</span>
<span class="line-added"> 59  * Deprecated: 2.32: Use #GArray instead, if possible for the given use case,</span>
<span class="line-added"> 60  *    as described above.</span>
 61  */
 62 
 63 #define GROUP_N_VALUES  (8) /* power of 2 !! */
 64 
 65 
 66 /* --- functions --- */
 67 /**
 68  * g_value_array_get_nth:
 69  * @value_array: #GValueArray to get a value from
 70  * @index_: index of the value of interest
 71  *
 72  * Return a pointer to the value at @index_ containd in @value_array.
 73  *
 74  * Returns: (transfer none): pointer to a value at @index_ in @value_array
 75  *
 76  * Deprecated: 2.32: Use g_array_index() instead.
 77  */
 78 GValue*
 79 g_value_array_get_nth (GValueArray *value_array,
<span class="line-modified"> 80            guint        index)</span>
 81 {
 82   g_return_val_if_fail (value_array != NULL, NULL);
 83   g_return_val_if_fail (index &lt; value_array-&gt;n_values, NULL);
 84 
 85   return value_array-&gt;values + index;
 86 }
 87 
 88 static inline void
 89 value_array_grow (GValueArray *value_array,
<span class="line-modified"> 90       guint        n_values,</span>
<span class="line-modified"> 91       gboolean     zero_init)</span>
 92 {
 93   g_return_if_fail (n_values &gt;= value_array-&gt;n_values);
 94 
 95   value_array-&gt;n_values = n_values;
 96   if (value_array-&gt;n_values &gt; value_array-&gt;n_prealloced)
 97     {
 98       guint i = value_array-&gt;n_prealloced;
 99 
100       value_array-&gt;n_prealloced = (value_array-&gt;n_values + GROUP_N_VALUES - 1) &amp; ~(GROUP_N_VALUES - 1);
101       value_array-&gt;values = g_renew (GValue, value_array-&gt;values, value_array-&gt;n_prealloced);
102       if (!zero_init)
<span class="line-modified">103   i = value_array-&gt;n_values;</span>
104       memset (value_array-&gt;values + i, 0,
<span class="line-modified">105         (value_array-&gt;n_prealloced - i) * sizeof (value_array-&gt;values[0]));</span>
106     }
107 }
108 
109 /**
110  * g_value_array_new:
111  * @n_prealloced: number of values to preallocate space for
112  *
113  * Allocate and initialize a new #GValueArray, optionally preserve space
114  * for @n_prealloced elements. New arrays always contain 0 elements,
115  * regardless of the value of @n_prealloced.
116  *
117  * Returns: a newly allocated #GValueArray with 0 values
118  *
119  * Deprecated: 2.32: Use #GArray and g_array_sized_new() instead.
120  */
121 GValueArray*
122 g_value_array_new (guint n_prealloced)
123 {
124   GValueArray *value_array = g_slice_new (GValueArray);
125 #ifdef GSTREAMER_LITE
</pre>
<hr />
<pre>
140 /**
141  * g_value_array_free: (skip)
142  * @value_array: #GValueArray to free
143  *
144  * Free a #GValueArray including its contents.
145  *
146  * Deprecated: 2.32: Use #GArray and g_array_unref() instead.
147  */
148 void
149 g_value_array_free (GValueArray *value_array)
150 {
151   guint i;
152 
153   g_return_if_fail (value_array != NULL);
154 
155   for (i = 0; i &lt; value_array-&gt;n_values; i++)
156     {
157       GValue *value = value_array-&gt;values + i;
158 
159       if (G_VALUE_TYPE (value) != 0) /* we allow unset values in the array */
<span class="line-modified">160   g_value_unset (value);</span>
161     }
162   g_free (value_array-&gt;values);
163   g_slice_free (GValueArray, value_array);
164 }
165 
166 /**
167  * g_value_array_copy:
168  * @value_array: #GValueArray to copy
169  *
170  * Construct an exact copy of a #GValueArray by duplicating all its
171  * contents.
172  *
173  * Returns: (transfer full): Newly allocated copy of #GValueArray
174  *
175  * Deprecated: 2.32: Use #GArray and g_array_ref() instead.
176  */
177 GValueArray*
178 g_value_array_copy (const GValueArray *value_array)
179 {
180   GValueArray *new_array;
181   guint i;
182 
183   g_return_val_if_fail (value_array != NULL, NULL);
184 
185   new_array = g_slice_new (GValueArray);
186 #ifdef GSTREAMER_LITE
187   if (new_array == NULL) {
188     return NULL;
189   }
190 #endif // GSTREAMER_LITE
191   new_array-&gt;n_values = 0;
192   new_array-&gt;values = NULL;
193   new_array-&gt;n_prealloced = 0;
194   value_array_grow (new_array, value_array-&gt;n_values, TRUE);
195   for (i = 0; i &lt; new_array-&gt;n_values; i++)
196     if (G_VALUE_TYPE (value_array-&gt;values + i) != 0)
197       {
<span class="line-modified">198   GValue *value = new_array-&gt;values + i;</span>
199 
<span class="line-modified">200   g_value_init (value, G_VALUE_TYPE (value_array-&gt;values + i));</span>
<span class="line-modified">201   g_value_copy (value_array-&gt;values + i, value);</span>
202       }
203   return new_array;
204 }
205 
206 /**
207  * g_value_array_prepend:
208  * @value_array: #GValueArray to add an element to
209  * @value: (nullable): #GValue to copy into #GValueArray, or %NULL
210  *
211  * Insert a copy of @value as first element of @value_array. If @value is
212  * %NULL, an uninitialized value is prepended.
213  *
214  *
215  * Returns: (transfer none): the #GValueArray passed in as @value_array
216  *
217  * Deprecated: 2.32: Use #GArray and g_array_prepend_val() instead.
218  */
219 GValueArray*
220 g_value_array_prepend (GValueArray  *value_array,
<span class="line-modified">221            const GValue *value)</span>
222 {
223   g_return_val_if_fail (value_array != NULL, NULL);
224 
225   G_GNUC_BEGIN_IGNORE_DEPRECATIONS
226   return g_value_array_insert (value_array, 0, value);
227   G_GNUC_END_IGNORE_DEPRECATIONS
228 }
229 
230 /**
231  * g_value_array_append:
232  * @value_array: #GValueArray to add an element to
233  * @value: (nullable): #GValue to copy into #GValueArray, or %NULL
234  *
235  * Insert a copy of @value as last element of @value_array. If @value is
236  * %NULL, an uninitialized value is appended.
237  *
238  * Returns: (transfer none): the #GValueArray passed in as @value_array
239  *
240  * Deprecated: 2.32: Use #GArray and g_array_append_val() instead.
241  */
242 GValueArray*
243 g_value_array_append (GValueArray  *value_array,
<span class="line-modified">244           const GValue *value)</span>
245 {
246   g_return_val_if_fail (value_array != NULL, NULL);
247 
248   G_GNUC_BEGIN_IGNORE_DEPRECATIONS
249   return g_value_array_insert (value_array, value_array-&gt;n_values, value);
250   G_GNUC_END_IGNORE_DEPRECATIONS
251 }
252 
253 /**
254  * g_value_array_insert:
255  * @value_array: #GValueArray to add an element to
256  * @index_: insertion position, must be &lt;= value_array-&gt;;n_values
257  * @value: (nullable): #GValue to copy into #GValueArray, or %NULL
258  *
259  * Insert a copy of @value at specified position into @value_array. If @value
260  * is %NULL, an uninitialized value is inserted.
261  *
262  * Returns: (transfer none): the #GValueArray passed in as @value_array
263  *
264  * Deprecated: 2.32: Use #GArray and g_array_insert_val() instead.
265  */
266 GValueArray*
267 g_value_array_insert (GValueArray  *value_array,
<span class="line-modified">268           guint         index,</span>
<span class="line-modified">269           const GValue *value)</span>
270 {
271   guint i;
272 
273   g_return_val_if_fail (value_array != NULL, NULL);
274   g_return_val_if_fail (index &lt;= value_array-&gt;n_values, value_array);
275 
276   i = value_array-&gt;n_values;
277   value_array_grow (value_array, value_array-&gt;n_values + 1, FALSE);
278   if (index + 1 &lt; value_array-&gt;n_values)
279     memmove (value_array-&gt;values + index + 1, value_array-&gt;values + index,
280              (i - index) * sizeof (value_array-&gt;values[0]));
281   memset (value_array-&gt;values + index, 0, sizeof (value_array-&gt;values[0]));
282   if (value)
283     {
284       g_value_init (value_array-&gt;values + index, G_VALUE_TYPE (value));
285       g_value_copy (value, value_array-&gt;values + index);
286     }
287   return value_array;
288 }
289 
290 /**
291  * g_value_array_remove:
292  * @value_array: #GValueArray to remove an element from
293  * @index_: position of value to remove, which must be less than
294  *     @value_array-&gt;n_values
295  *
296  * Remove the value at position @index_ from @value_array.
297  *
298  * Returns: (transfer none): the #GValueArray passed in as @value_array
299  *
300  * Deprecated: 2.32: Use #GArray and g_array_remove_index() instead.
301  */
302 GValueArray*
303 g_value_array_remove (GValueArray *value_array,
<span class="line-modified">304           guint        index)</span>
305 {
306   g_return_val_if_fail (value_array != NULL, NULL);
307   g_return_val_if_fail (index &lt; value_array-&gt;n_values, value_array);
308 
309   if (G_VALUE_TYPE (value_array-&gt;values + index) != 0)
310     g_value_unset (value_array-&gt;values + index);
311   value_array-&gt;n_values--;
312   if (index &lt; value_array-&gt;n_values)
313     memmove (value_array-&gt;values + index, value_array-&gt;values + index + 1,
314              (value_array-&gt;n_values - index) * sizeof (value_array-&gt;values[0]));
315   if (value_array-&gt;n_prealloced &gt; value_array-&gt;n_values)
316     memset (value_array-&gt;values + value_array-&gt;n_values, 0, sizeof (value_array-&gt;values[0]));
317 
318   return value_array;
319 }
320 
321 /**
322  * g_value_array_sort:
323  * @value_array: #GValueArray to sort
324  * @compare_func: (scope call): function to compare elements
325  *
326  * Sort @value_array using @compare_func to compare the elements according to
327  * the semantics of #GCompareFunc.
328  *
329  * The current implementation uses the same sorting algorithm as standard
330  * C qsort() function.
331  *
332  * Returns: (transfer none): the #GValueArray passed in as @value_array
333  *
334  * Deprecated: 2.32: Use #GArray and g_array_sort().
335  */
336 GValueArray*
337 g_value_array_sort (GValueArray *value_array,
<span class="line-modified">338         GCompareFunc compare_func)</span>
339 {
340   g_return_val_if_fail (compare_func != NULL, NULL);
341 
342   if (value_array-&gt;n_values)
343     qsort (value_array-&gt;values,
<span class="line-modified">344      value_array-&gt;n_values,</span>
<span class="line-modified">345      sizeof (value_array-&gt;values[0]),</span>
<span class="line-modified">346      compare_func);</span>
347   return value_array;
348 }
349 
350 /**
351  * g_value_array_sort_with_data: (rename-to g_value_array_sort)
352  * @value_array: #GValueArray to sort
353  * @compare_func: (scope call): function to compare elements
354  * @user_data: (closure): extra data argument provided for @compare_func
355  *
356  * Sort @value_array using @compare_func to compare the elements according
357  * to the semantics of #GCompareDataFunc.
358  *
359  * The current implementation uses the same sorting algorithm as standard
360  * C qsort() function.
361  *
362  * Returns: (transfer none): the #GValueArray passed in as @value_array
363  *
364  * Deprecated: 2.32: Use #GArray and g_array_sort_with_data().
365  */
366 GValueArray*
367 g_value_array_sort_with_data (GValueArray     *value_array,
<span class="line-modified">368             GCompareDataFunc compare_func,</span>
<span class="line-modified">369             gpointer         user_data)</span>
370 {
371   g_return_val_if_fail (value_array != NULL, NULL);
372   g_return_val_if_fail (compare_func != NULL, NULL);
373 
374   if (value_array-&gt;n_values)
375     g_qsort_with_data (value_array-&gt;values,
<span class="line-modified">376            value_array-&gt;n_values,</span>
<span class="line-modified">377            sizeof (value_array-&gt;values[0]),</span>
<span class="line-modified">378            compare_func, user_data);</span>
379   return value_array;
380 }
</pre>
</td>
</tr>
</table>
<center><a href="gvalue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvaluearray.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>