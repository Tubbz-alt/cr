<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gclosure.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GObject - GLib Type, Object, Parameter and Signal Library
   2  * Copyright (C) 2000-2001 Red Hat, Inc.
   3  * Copyright (C) 2005 Imendio AB
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General
  16  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  */
  18 
  19 /*
  20  * MT safe with regards to reference counting.
  21  */
  22 
  23 #include &quot;config.h&quot;
  24 
  25 #include &quot;../glib/gvalgrind.h&quot;
  26 #include &lt;string.h&gt;
  27 
  28 #include &lt;ffi.h&gt;
  29 
  30 #include &quot;gclosure.h&quot;
  31 #include &quot;gboxed.h&quot;
  32 #include &quot;gobject.h&quot;
  33 #include &quot;genums.h&quot;
  34 #include &quot;gvalue.h&quot;
  35 #include &quot;gvaluetypes.h&quot;
  36 #include &quot;gtype-private.h&quot;
  37 
  38 
  39 /**
  40  * SECTION:gclosure
  41  * @short_description: Functions as first-class objects
  42  * @title: Closures
  43  *
  44  * A #GClosure represents a callback supplied by the programmer. It
  45  * will generally comprise a function of some kind and a marshaller
  46  * used to call it. It is the responsibility of the marshaller to
  47  * convert the arguments for the invocation from #GValues into
  48  * a suitable form, perform the callback on the converted arguments,
  49  * and transform the return value back into a #GValue.
  50  *
  51  * In the case of C programs, a closure usually just holds a pointer
  52  * to a function and maybe a data argument, and the marshaller
  53  * converts between #GValue and native C types. The GObject
  54  * library provides the #GCClosure type for this purpose. Bindings for
  55  * other languages need marshallers which convert between #GValues
  56  * and suitable representations in the runtime of the language in
  57  * order to use functions written in that language as callbacks. Use
  58  * g_closure_set_marshal() to set the marshaller on such a custom
  59  * closure implementation.
  60  *
  61  * Within GObject, closures play an important role in the
  62  * implementation of signals. When a signal is registered, the
  63  * @c_marshaller argument to g_signal_new() specifies the default C
  64  * marshaller for any closure which is connected to this
  65  * signal. GObject provides a number of C marshallers for this
  66  * purpose, see the g_cclosure_marshal_*() functions. Additional C
  67  * marshallers can be generated with the [glib-genmarshal][glib-genmarshal]
  68  * utility.  Closures can be explicitly connected to signals with
  69  * g_signal_connect_closure(), but it usually more convenient to let
  70  * GObject create a closure automatically by using one of the
  71  * g_signal_connect_*() functions which take a callback function/user
  72  * data pair.
  73  *
  74  * Using closures has a number of important advantages over a simple
  75  * callback function/data pointer combination:
  76  *
  77  * - Closures allow the callee to get the types of the callback parameters,
  78  *   which means that language bindings don&#39;t have to write individual glue
  79  *   for each callback type.
  80  *
  81  * - The reference counting of #GClosure makes it easy to handle reentrancy
  82  *   right; if a callback is removed while it is being invoked, the closure
  83  *   and its parameters won&#39;t be freed until the invocation finishes.
  84  *
  85  * - g_closure_invalidate() and invalidation notifiers allow callbacks to be
  86  *   automatically removed when the objects they point to go away.
  87  */
  88 
<a name="1" id="anc1"></a><span class="line-modified">  89 #define CLOSURE_MAX_REF_COUNT   ((1 &lt;&lt; 15) - 1)</span>
<span class="line-modified">  90 #define CLOSURE_MAX_N_GUARDS    ((1 &lt;&lt; 1) - 1)</span>
<span class="line-modified">  91 #define CLOSURE_MAX_N_FNOTIFIERS  ((1 &lt;&lt; 2) - 1)</span>
<span class="line-modified">  92 #define CLOSURE_MAX_N_INOTIFIERS  ((1 &lt;&lt; 8) - 1)</span>
<span class="line-modified">  93 #define CLOSURE_N_MFUNCS(cl)    (((cl)-&gt;n_guards &lt;&lt; 1L))</span>
  94 /* same as G_CLOSURE_N_NOTIFIERS() (keep in sync) */
<a name="2" id="anc2"></a><span class="line-modified">  95 #define CLOSURE_N_NOTIFIERS(cl)   (CLOSURE_N_MFUNCS (cl) + \</span>
  96                                          (cl)-&gt;n_fnotifiers + \
  97                                          (cl)-&gt;n_inotifiers)
  98 
  99 typedef union {
 100   GClosure closure;
 101   volatile gint vint;
 102 } ClosureInt;
 103 
 104 #define CHANGE_FIELD(_closure, _field, _OP, _value, _must_set, _SET_OLD, _SET_NEW)      \
 105 G_STMT_START {                                                                          \
<a name="3" id="anc3"></a><span class="line-modified"> 106   ClosureInt *cunion = (ClosureInt*) _closure;                                    \</span>
<span class="line-modified"> 107   gint new_int, old_int, success;                                                 \</span>
<span class="line-modified"> 108   do                                                                        \</span>
<span class="line-modified"> 109     {                                                                       \</span>
<span class="line-modified"> 110       ClosureInt tmp;                                                       \</span>
<span class="line-modified"> 111       tmp.vint = old_int = cunion-&gt;vint;                                    \</span>
 112       _SET_OLD tmp.closure._field;                                                      \
<a name="4" id="anc4"></a><span class="line-modified"> 113       tmp.closure._field _OP _value;                                          \</span>
 114       _SET_NEW tmp.closure._field;                                                      \
<a name="5" id="anc5"></a><span class="line-modified"> 115       new_int = tmp.vint;                                                   \</span>
 116       success = g_atomic_int_compare_and_exchange (&amp;cunion-&gt;vint, old_int, new_int);    \
<a name="6" id="anc6"></a><span class="line-modified"> 117     }                                                                       \</span>
 118   while (!success &amp;&amp; _must_set);                                                        \
 119 } G_STMT_END
 120 
 121 #define SWAP(_closure, _field, _value, _oldv)   CHANGE_FIELD (_closure, _field, =, _value, TRUE, *(_oldv) =,     (void) )
 122 #define SET(_closure, _field, _value)           CHANGE_FIELD (_closure, _field, =, _value, TRUE,     (void),     (void) )
 123 #define INC(_closure, _field)                   CHANGE_FIELD (_closure, _field, +=,     1, TRUE,     (void),     (void) )
 124 #define INC_ASSIGN(_closure, _field, _newv)     CHANGE_FIELD (_closure, _field, +=,     1, TRUE,     (void), *(_newv) = )
 125 #define DEC(_closure, _field)                   CHANGE_FIELD (_closure, _field, -=,     1, TRUE,     (void),     (void) )
 126 #define DEC_ASSIGN(_closure, _field, _newv)     CHANGE_FIELD (_closure, _field, -=,     1, TRUE,     (void), *(_newv) = )
 127 
 128 #if 0   /* for non-thread-safe closures */
 129 #define SWAP(cl,f,v,o)     (void) (*(o) = cl-&gt;f, cl-&gt;f = v)
 130 #define SET(cl,f,v)        (void) (cl-&gt;f = v)
 131 #define INC(cl,f)          (void) (cl-&gt;f += 1)
 132 #define INC_ASSIGN(cl,f,n) (void) (cl-&gt;f += 1, *(n) = cl-&gt;f)
 133 #define DEC(cl,f)          (void) (cl-&gt;f -= 1)
 134 #define DEC_ASSIGN(cl,f,n) (void) (cl-&gt;f -= 1, *(n) = cl-&gt;f)
 135 #endif
 136 
 137 enum {
 138   FNOTIFY,
 139   INOTIFY,
 140   PRE_NOTIFY,
 141   POST_NOTIFY
 142 };
 143 
 144 
 145 /* --- functions --- */
 146 /**
 147  * g_closure_new_simple:
 148  * @sizeof_closure: the size of the structure to allocate, must be at least
 149  *                  `sizeof (GClosure)`
 150  * @data: data to store in the @data field of the newly allocated #GClosure
 151  *
 152  * Allocates a struct of the given size and initializes the initial
 153  * part as a #GClosure. This function is mainly useful when
 154  * implementing new types of closures.
 155  *
 156  * |[&lt;!-- language=&quot;C&quot; --&gt;
 157  * typedef struct _MyClosure MyClosure;
 158  * struct _MyClosure
 159  * {
 160  *   GClosure closure;
 161  *   // extra data goes here
 162  * };
 163  *
 164  * static void
 165  * my_closure_finalize (gpointer  notify_data,
 166  *                      GClosure *closure)
 167  * {
 168  *   MyClosure *my_closure = (MyClosure *)closure;
 169  *
 170  *   // free extra data here
 171  * }
 172  *
 173  * MyClosure *my_closure_new (gpointer data)
 174  * {
 175  *   GClosure *closure;
 176  *   MyClosure *my_closure;
 177  *
 178  *   closure = g_closure_new_simple (sizeof (MyClosure), data);
 179  *   my_closure = (MyClosure *) closure;
 180  *
 181  *   // initialize extra data here
 182  *
 183  *   g_closure_add_finalize_notifier (closure, notify_data,
 184  *                                    my_closure_finalize);
 185  *   return my_closure;
 186  * }
 187  * ]|
 188  *
 189  * Returns: (transfer none): a floating reference to a new #GClosure
 190  */
 191 GClosure*
 192 g_closure_new_simple (guint           sizeof_closure,
<a name="7" id="anc7"></a><span class="line-modified"> 193           gpointer        data)</span>
 194 {
 195   GClosure *closure;
 196   gint private_size;
 197   gchar *allocated;
 198 
 199   g_return_val_if_fail (sizeof_closure &gt;= sizeof (GClosure), NULL);
 200 
 201   private_size = sizeof (GRealClosure) - sizeof (GClosure);
 202 
 203 #ifdef ENABLE_VALGRIND
 204   /* See comments in gtype.c about what&#39;s going on here... */
 205   if (RUNNING_ON_VALGRIND)
 206     {
 207       private_size += sizeof (gpointer);
 208 
 209       allocated = g_malloc0 (private_size + sizeof_closure + sizeof (gpointer));
 210 #ifdef GSTREAMER_LITE
 211       if (allocated == NULL)
 212         return NULL;
 213 #endif // GSTREAMER_LITE
 214 
 215       *(gpointer *) (allocated + private_size + sizeof_closure) = allocated + sizeof (gpointer);
 216 
 217       VALGRIND_MALLOCLIKE_BLOCK (allocated + private_size, sizeof_closure + sizeof (gpointer), 0, TRUE);
 218       VALGRIND_MALLOCLIKE_BLOCK (allocated + sizeof (gpointer), private_size - sizeof (gpointer), 0, TRUE);
 219     }
 220   else
 221 #endif
 222     allocated = g_malloc0 (private_size + sizeof_closure);
 223 #ifdef GSTREAMER_LITE
 224     if (allocated == NULL)
 225       return NULL;
 226 #endif // GSTREAMER_LITE
 227 
 228   closure = (GClosure *) (allocated + private_size);
 229 
 230   SET (closure, ref_count, 1);
 231   SET (closure, floating, TRUE);
 232   closure-&gt;data = data;
 233 
 234   return closure;
 235 }
 236 
 237 static inline void
 238 closure_invoke_notifiers (GClosure *closure,
<a name="8" id="anc8"></a><span class="line-modified"> 239         guint     notify_type)</span>
 240 {
 241   /* notifier layout:
 242    *     n_guards    n_guards     n_fnotif.  n_inotifiers
 243    * -&gt;[[pre_guards][post_guards][fnotifiers][inotifiers]]
 244    *
 245    * CLOSURE_N_MFUNCS(cl)    = n_guards + n_guards;
 246    * CLOSURE_N_NOTIFIERS(cl) = CLOSURE_N_MFUNCS(cl) + n_fnotifiers + n_inotifiers
 247    *
 248    * constrains/catches:
 249    * - closure-&gt;notifiers may be reloacted during callback
 250    * - closure-&gt;n_fnotifiers and closure-&gt;n_inotifiers may change during callback
 251    * - i.e. callbacks can be removed/added during invocation
 252    * - must prepare for callback removal during FNOTIFY and INOTIFY (done via -&gt;marshal= &amp; -&gt;data=)
 253    * - must distinguish (-&gt;marshal= &amp; -&gt;data=) for INOTIFY vs. FNOTIFY (via -&gt;in_inotify)
 254    * + closure-&gt;n_guards is const during PRE_NOTIFY &amp; POST_NOTIFY
 255    * + none of the callbacks can cause recursion
 256    * + closure-&gt;n_inotifiers is const 0 during FNOTIFY
 257    */
 258   switch (notify_type)
 259     {
 260       GClosureNotifyData *ndata;
 261       guint i, offs;
 262     case FNOTIFY:
 263       while (closure-&gt;n_fnotifiers)
<a name="9" id="anc9"></a><span class="line-modified"> 264   {</span>
 265           guint n;
<a name="10" id="anc10"></a><span class="line-modified"> 266     DEC_ASSIGN (closure, n_fnotifiers, &amp;n);</span>
 267 
<a name="11" id="anc11"></a><span class="line-modified"> 268     ndata = closure-&gt;notifiers + CLOSURE_N_MFUNCS (closure) + n;</span>
<span class="line-modified"> 269     closure-&gt;marshal = (GClosureMarshal) ndata-&gt;notify;</span>
<span class="line-modified"> 270     closure-&gt;data = ndata-&gt;data;</span>
<span class="line-modified"> 271     ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified"> 272   }</span>
 273       closure-&gt;marshal = NULL;
 274       closure-&gt;data = NULL;
 275       break;
 276     case INOTIFY:
 277       SET (closure, in_inotify, TRUE);
 278       while (closure-&gt;n_inotifiers)
<a name="12" id="anc12"></a><span class="line-modified"> 279   {</span>
 280           guint n;
 281           DEC_ASSIGN (closure, n_inotifiers, &amp;n);
 282 
<a name="13" id="anc13"></a><span class="line-modified"> 283     ndata = closure-&gt;notifiers + CLOSURE_N_MFUNCS (closure) + closure-&gt;n_fnotifiers + n;</span>
<span class="line-modified"> 284     closure-&gt;marshal = (GClosureMarshal) ndata-&gt;notify;</span>
<span class="line-modified"> 285     closure-&gt;data = ndata-&gt;data;</span>
<span class="line-modified"> 286     ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified"> 287   }</span>
 288       closure-&gt;marshal = NULL;
 289       closure-&gt;data = NULL;
 290       SET (closure, in_inotify, FALSE);
 291       break;
 292     case PRE_NOTIFY:
 293       i = closure-&gt;n_guards;
 294       offs = 0;
 295       while (i--)
<a name="14" id="anc14"></a><span class="line-modified"> 296   {</span>
<span class="line-modified"> 297     ndata = closure-&gt;notifiers + offs + i;</span>
<span class="line-modified"> 298     ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified"> 299   }</span>
 300       break;
 301     case POST_NOTIFY:
 302       i = closure-&gt;n_guards;
 303       offs = i;
 304       while (i--)
<a name="15" id="anc15"></a><span class="line-modified"> 305   {</span>
<span class="line-modified"> 306     ndata = closure-&gt;notifiers + offs + i;</span>
<span class="line-modified"> 307     ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified"> 308   }</span>
 309       break;
 310     }
 311 }
 312 
 313 static void
 314 g_closure_set_meta_va_marshal (GClosure       *closure,
<a name="16" id="anc16"></a><span class="line-modified"> 315              GVaClosureMarshal va_meta_marshal)</span>
 316 {
 317   GRealClosure *real_closure;
 318 
 319   g_return_if_fail (closure != NULL);
 320   g_return_if_fail (va_meta_marshal != NULL);
 321   g_return_if_fail (closure-&gt;is_invalid == FALSE);
 322   g_return_if_fail (closure-&gt;in_marshal == FALSE);
 323 
 324   real_closure = G_REAL_CLOSURE (closure);
 325 
 326   g_return_if_fail (real_closure-&gt;meta_marshal != NULL);
 327 
 328   real_closure-&gt;va_meta_marshal = va_meta_marshal;
 329 }
 330 
 331 /**
 332  * g_closure_set_meta_marshal: (skip)
 333  * @closure: a #GClosure
 334  * @marshal_data: (closure meta_marshal): context-dependent data to pass
 335  *  to @meta_marshal
 336  * @meta_marshal: a #GClosureMarshal function
 337  *
 338  * Sets the meta marshaller of @closure.  A meta marshaller wraps
 339  * @closure-&gt;marshal and modifies the way it is called in some
 340  * fashion. The most common use of this facility is for C callbacks.
 341  * The same marshallers (generated by [glib-genmarshal][glib-genmarshal]),
 342  * are used everywhere, but the way that we get the callback function
 343  * differs. In most cases we want to use @closure-&gt;callback, but in
 344  * other cases we want to use some different technique to retrieve the
 345  * callback function.
 346  *
 347  * For example, class closures for signals (see
 348  * g_signal_type_cclosure_new()) retrieve the callback function from a
 349  * fixed offset in the class structure.  The meta marshaller retrieves
 350  * the right callback and passes it to the marshaller as the
 351  * @marshal_data argument.
 352  */
 353 void
 354 g_closure_set_meta_marshal (GClosure       *closure,
<a name="17" id="anc17"></a><span class="line-modified"> 355           gpointer        marshal_data,</span>
<span class="line-modified"> 356           GClosureMarshal meta_marshal)</span>
 357 {
 358   GRealClosure *real_closure;
 359 
 360   g_return_if_fail (closure != NULL);
 361   g_return_if_fail (meta_marshal != NULL);
 362   g_return_if_fail (closure-&gt;is_invalid == FALSE);
 363   g_return_if_fail (closure-&gt;in_marshal == FALSE);
 364 
 365   real_closure = G_REAL_CLOSURE (closure);
 366 
 367   g_return_if_fail (real_closure-&gt;meta_marshal == NULL);
 368 
 369   real_closure-&gt;meta_marshal = meta_marshal;
 370   real_closure-&gt;meta_marshal_data = marshal_data;
 371 }
 372 
 373 /**
 374  * g_closure_add_marshal_guards: (skip)
 375  * @closure: a #GClosure
 376  * @pre_marshal_data: (closure pre_marshal_notify): data to pass
 377  *  to @pre_marshal_notify
 378  * @pre_marshal_notify: a function to call before the closure callback
 379  * @post_marshal_data: (closure post_marshal_notify): data to pass
 380  *  to @post_marshal_notify
 381  * @post_marshal_notify: a function to call after the closure callback
 382  *
 383  * Adds a pair of notifiers which get invoked before and after the
 384  * closure callback, respectively. This is typically used to protect
 385  * the extra arguments for the duration of the callback. See
 386  * g_object_watch_closure() for an example of marshal guards.
 387  */
 388 void
 389 g_closure_add_marshal_guards (GClosure      *closure,
<a name="18" id="anc18"></a><span class="line-modified"> 390             gpointer       pre_marshal_data,</span>
<span class="line-modified"> 391             GClosureNotify pre_marshal_notify,</span>
<span class="line-modified"> 392             gpointer       post_marshal_data,</span>
<span class="line-modified"> 393             GClosureNotify post_marshal_notify)</span>
 394 {
 395   guint i;
 396 
 397   g_return_if_fail (closure != NULL);
 398   g_return_if_fail (pre_marshal_notify != NULL);
 399   g_return_if_fail (post_marshal_notify != NULL);
 400   g_return_if_fail (closure-&gt;is_invalid == FALSE);
 401   g_return_if_fail (closure-&gt;in_marshal == FALSE);
 402   g_return_if_fail (closure-&gt;n_guards &lt; CLOSURE_MAX_N_GUARDS);
 403 
 404   closure-&gt;notifiers = g_renew (GClosureNotifyData, closure-&gt;notifiers, CLOSURE_N_NOTIFIERS (closure) + 2);
 405   if (closure-&gt;n_inotifiers)
 406     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<a name="19" id="anc19"></a><span class="line-modified"> 407       closure-&gt;n_fnotifiers +</span>
<span class="line-modified"> 408       closure-&gt;n_inotifiers + 1)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified"> 409                     closure-&gt;n_fnotifiers + 0)];</span>
 410   if (closure-&gt;n_inotifiers &gt; 1)
 411     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<a name="20" id="anc20"></a><span class="line-modified"> 412       closure-&gt;n_fnotifiers +</span>
<span class="line-modified"> 413       closure-&gt;n_inotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified"> 414                       closure-&gt;n_fnotifiers + 1)];</span>
 415   if (closure-&gt;n_fnotifiers)
 416     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<a name="21" id="anc21"></a><span class="line-modified"> 417       closure-&gt;n_fnotifiers + 1)] = closure-&gt;notifiers[CLOSURE_N_MFUNCS (closure) + 0];</span>
 418   if (closure-&gt;n_fnotifiers &gt; 1)
 419     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<a name="22" id="anc22"></a><span class="line-modified"> 420       closure-&gt;n_fnotifiers)] = closure-&gt;notifiers[CLOSURE_N_MFUNCS (closure) + 1];</span>
 421   if (closure-&gt;n_guards)
 422     closure-&gt;notifiers[(closure-&gt;n_guards +
<a name="23" id="anc23"></a><span class="line-modified"> 423       closure-&gt;n_guards + 1)] = closure-&gt;notifiers[closure-&gt;n_guards];</span>
 424   i = closure-&gt;n_guards;
 425   closure-&gt;notifiers[i].data = pre_marshal_data;
 426   closure-&gt;notifiers[i].notify = pre_marshal_notify;
 427   closure-&gt;notifiers[i + 1].data = post_marshal_data;
 428   closure-&gt;notifiers[i + 1].notify = post_marshal_notify;
 429   INC (closure, n_guards);
 430 }
 431 
 432 /**
 433  * g_closure_add_finalize_notifier: (skip)
 434  * @closure: a #GClosure
 435  * @notify_data: (closure notify_func): data to pass to @notify_func
 436  * @notify_func: the callback function to register
 437  *
 438  * Registers a finalization notifier which will be called when the
 439  * reference count of @closure goes down to 0. Multiple finalization
 440  * notifiers on a single closure are invoked in unspecified order. If
 441  * a single call to g_closure_unref() results in the closure being
 442  * both invalidated and finalized, then the invalidate notifiers will
 443  * be run before the finalize notifiers.
 444  */
 445 void
 446 g_closure_add_finalize_notifier (GClosure      *closure,
<a name="24" id="anc24"></a><span class="line-modified"> 447          gpointer       notify_data,</span>
<span class="line-modified"> 448          GClosureNotify notify_func)</span>
 449 {
 450   guint i;
 451 
 452   g_return_if_fail (closure != NULL);
 453   g_return_if_fail (notify_func != NULL);
 454   g_return_if_fail (closure-&gt;n_fnotifiers &lt; CLOSURE_MAX_N_FNOTIFIERS);
 455 
 456   closure-&gt;notifiers = g_renew (GClosureNotifyData, closure-&gt;notifiers, CLOSURE_N_NOTIFIERS (closure) + 1);
 457   if (closure-&gt;n_inotifiers)
 458     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<a name="25" id="anc25"></a><span class="line-modified"> 459       closure-&gt;n_fnotifiers +</span>
<span class="line-modified"> 460       closure-&gt;n_inotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified"> 461                       closure-&gt;n_fnotifiers + 0)];</span>
 462   i = CLOSURE_N_MFUNCS (closure) + closure-&gt;n_fnotifiers;
 463   closure-&gt;notifiers[i].data = notify_data;
 464   closure-&gt;notifiers[i].notify = notify_func;
 465   INC (closure, n_fnotifiers);
 466 }
 467 
 468 /**
 469  * g_closure_add_invalidate_notifier: (skip)
 470  * @closure: a #GClosure
 471  * @notify_data: (closure notify_func): data to pass to @notify_func
 472  * @notify_func: the callback function to register
 473  *
 474  * Registers an invalidation notifier which will be called when the
 475  * @closure is invalidated with g_closure_invalidate(). Invalidation
 476  * notifiers are invoked before finalization notifiers, in an
 477  * unspecified order.
 478  */
 479 void
 480 g_closure_add_invalidate_notifier (GClosure      *closure,
<a name="26" id="anc26"></a><span class="line-modified"> 481            gpointer       notify_data,</span>
<span class="line-modified"> 482            GClosureNotify notify_func)</span>
 483 {
 484   guint i;
 485 
 486   g_return_if_fail (closure != NULL);
 487   g_return_if_fail (notify_func != NULL);
 488   g_return_if_fail (closure-&gt;is_invalid == FALSE);
 489   g_return_if_fail (closure-&gt;n_inotifiers &lt; CLOSURE_MAX_N_INOTIFIERS);
 490 
 491   closure-&gt;notifiers = g_renew (GClosureNotifyData, closure-&gt;notifiers, CLOSURE_N_NOTIFIERS (closure) + 1);
 492   i = CLOSURE_N_MFUNCS (closure) + closure-&gt;n_fnotifiers + closure-&gt;n_inotifiers;
 493   closure-&gt;notifiers[i].data = notify_data;
 494   closure-&gt;notifiers[i].notify = notify_func;
 495   INC (closure, n_inotifiers);
 496 }
 497 
 498 static inline gboolean
 499 closure_try_remove_inotify (GClosure       *closure,
<a name="27" id="anc27"></a><span class="line-modified"> 500           gpointer       notify_data,</span>
<span class="line-modified"> 501           GClosureNotify notify_func)</span>
 502 {
 503   GClosureNotifyData *ndata, *nlast;
 504 
 505   nlast = closure-&gt;notifiers + CLOSURE_N_NOTIFIERS (closure) - 1;
 506   for (ndata = nlast + 1 - closure-&gt;n_inotifiers; ndata &lt;= nlast; ndata++)
 507     if (ndata-&gt;notify == notify_func &amp;&amp; ndata-&gt;data == notify_data)
 508       {
<a name="28" id="anc28"></a><span class="line-modified"> 509   DEC (closure, n_inotifiers);</span>
<span class="line-modified"> 510   if (ndata &lt; nlast)</span>
<span class="line-modified"> 511     *ndata = *nlast;</span>
 512 
<a name="29" id="anc29"></a><span class="line-modified"> 513   return TRUE;</span>
 514       }
 515   return FALSE;
 516 }
 517 
 518 static inline gboolean
 519 closure_try_remove_fnotify (GClosure       *closure,
<a name="30" id="anc30"></a><span class="line-modified"> 520           gpointer       notify_data,</span>
<span class="line-modified"> 521           GClosureNotify notify_func)</span>
 522 {
 523   GClosureNotifyData *ndata, *nlast;
 524 
 525   nlast = closure-&gt;notifiers + CLOSURE_N_NOTIFIERS (closure) - closure-&gt;n_inotifiers - 1;
 526   for (ndata = nlast + 1 - closure-&gt;n_fnotifiers; ndata &lt;= nlast; ndata++)
 527     if (ndata-&gt;notify == notify_func &amp;&amp; ndata-&gt;data == notify_data)
 528       {
<a name="31" id="anc31"></a><span class="line-modified"> 529   DEC (closure, n_fnotifiers);</span>
<span class="line-modified"> 530   if (ndata &lt; nlast)</span>
<span class="line-modified"> 531     *ndata = *nlast;</span>
<span class="line-modified"> 532   if (closure-&gt;n_inotifiers)</span>
<span class="line-modified"> 533     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified"> 534             closure-&gt;n_fnotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified"> 535                       closure-&gt;n_fnotifiers +</span>
<span class="line-modified"> 536                       closure-&gt;n_inotifiers)];</span>
<span class="line-modified"> 537   return TRUE;</span>
 538       }
 539   return FALSE;
 540 }
 541 
 542 /**
 543  * g_closure_ref:
 544  * @closure: #GClosure to increment the reference count on
 545  *
 546  * Increments the reference count on a closure to force it staying
 547  * alive while the caller holds a pointer to it.
 548  *
 549  * Returns: (transfer none): The @closure passed in, for convenience
 550  */
 551 GClosure*
 552 g_closure_ref (GClosure *closure)
 553 {
 554   guint new_ref_count;
 555   g_return_val_if_fail (closure != NULL, NULL);
 556   g_return_val_if_fail (closure-&gt;ref_count &gt; 0, NULL);
 557   g_return_val_if_fail (closure-&gt;ref_count &lt; CLOSURE_MAX_REF_COUNT, NULL);
 558 
 559   INC_ASSIGN (closure, ref_count, &amp;new_ref_count);
 560   g_return_val_if_fail (new_ref_count &gt; 1, NULL);
 561 
 562   return closure;
 563 }
 564 
 565 /**
 566  * g_closure_invalidate:
<a name="32" id="anc32"></a><span class="line-modified"> 567  * @closure: #GClosure to invalidate</span>
 568  *
 569  * Sets a flag on the closure to indicate that its calling
 570  * environment has become invalid, and thus causes any future
 571  * invocations of g_closure_invoke() on this @closure to be
 572  * ignored. Also, invalidation notifiers installed on the closure will
 573  * be called at this point. Note that unless you are holding a
 574  * reference to the closure yourself, the invalidation notifiers may
 575  * unref the closure and cause it to be destroyed, so if you need to
 576  * access the closure after calling g_closure_invalidate(), make sure
 577  * that you&#39;ve previously called g_closure_ref().
 578  *
 579  * Note that g_closure_invalidate() will also be called when the
 580  * reference count of a closure drops to zero (unless it has already
 581  * been invalidated before).
 582  */
 583 void
 584 g_closure_invalidate (GClosure *closure)
 585 {
 586   g_return_if_fail (closure != NULL);
 587 
 588   if (!closure-&gt;is_invalid)
 589     {
 590       gboolean was_invalid;
 591       g_closure_ref (closure);           /* preserve floating flag */
 592       SWAP (closure, is_invalid, TRUE, &amp;was_invalid);
 593       /* invalidate only once */
 594       if (!was_invalid)
 595         closure_invoke_notifiers (closure, INOTIFY);
 596       g_closure_unref (closure);
 597     }
 598 }
 599 
 600 /**
 601  * g_closure_unref:
 602  * @closure: #GClosure to decrement the reference count on
 603  *
 604  * Decrements the reference count of a closure after it was previously
 605  * incremented by the same caller. If no other callers are using the
 606  * closure, then the closure will be destroyed and freed.
 607  */
 608 void
 609 g_closure_unref (GClosure *closure)
 610 {
 611   guint new_ref_count;
 612 
 613   g_return_if_fail (closure != NULL);
 614   g_return_if_fail (closure-&gt;ref_count &gt; 0);
 615 
 616   if (closure-&gt;ref_count == 1)  /* last unref, invalidate first */
 617     g_closure_invalidate (closure);
 618 
 619   DEC_ASSIGN (closure, ref_count, &amp;new_ref_count);
 620 
 621   if (new_ref_count == 0)
 622     {
 623       closure_invoke_notifiers (closure, FNOTIFY);
 624       g_free (closure-&gt;notifiers);
 625 
 626 #ifdef GSTREAMER_LITE
 627 #ifdef ENABLE_VALGRIND
 628       /* See comments in gtype.c about what&#39;s going on here... */
 629       if (RUNNING_ON_VALGRIND)
 630         {
 631           gchar *allocated;
 632 
 633           allocated = (gchar *) G_REAL_CLOSURE (closure);
 634           allocated -= sizeof (gpointer);
 635 
 636           g_free (allocated);
 637 
 638           VALGRIND_FREELIKE_BLOCK (allocated + sizeof (gpointer), 0);
 639           VALGRIND_FREELIKE_BLOCK (closure, 0);
 640         }
 641       else
 642         g_free (G_REAL_CLOSURE (closure));
 643 #endif // ENABLE_VALGRIND
 644 #endif // GSTREAMER_LITE
 645 
 646 #ifndef GSTREAMER_LITE
 647       /* See comments in gtype.c about what&#39;s going on here... */
 648       if (RUNNING_ON_VALGRIND)
 649         {
 650           gchar *allocated;
 651 
 652           allocated = (gchar *) G_REAL_CLOSURE (closure);
 653           allocated -= sizeof (gpointer);
 654 
 655           g_free (allocated);
 656 
 657           VALGRIND_FREELIKE_BLOCK (allocated + sizeof (gpointer), 0);
 658           VALGRIND_FREELIKE_BLOCK (closure, 0);
 659         }
 660       else
 661         g_free (G_REAL_CLOSURE (closure));
 662 #endif // GSTREAMER_LITE
 663     }
 664 }
 665 
 666 /**
 667  * g_closure_sink:
 668  * @closure: #GClosure to decrement the initial reference count on, if it&#39;s
 669  *           still being held
 670  *
 671  * Takes over the initial ownership of a closure.  Each closure is
 672  * initially created in a &quot;floating&quot; state, which means that the initial
 673  * reference count is not owned by any caller. g_closure_sink() checks
 674  * to see if the object is still floating, and if so, unsets the
 675  * floating state and decreases the reference count. If the closure
 676  * is not floating, g_closure_sink() does nothing. The reason for the
 677  * existence of the floating state is to prevent cumbersome code
 678  * sequences like:
 679  * |[&lt;!-- language=&quot;C&quot; --&gt;
 680  * closure = g_cclosure_new (cb_func, cb_data);
 681  * g_source_set_closure (source, closure);
 682  * g_closure_unref (closure); // GObject doesn&#39;t really need this
 683  * ]|
 684  * Because g_source_set_closure() (and similar functions) take ownership of the
 685  * initial reference count, if it is unowned, we instead can write:
 686  * |[&lt;!-- language=&quot;C&quot; --&gt;
 687  * g_source_set_closure (source, g_cclosure_new (cb_func, cb_data));
 688  * ]|
 689  *
 690  * Generally, this function is used together with g_closure_ref(). Ane example
 691  * of storing a closure for later notification looks like:
 692  * |[&lt;!-- language=&quot;C&quot; --&gt;
 693  * static GClosure *notify_closure = NULL;
 694  * void
 695  * foo_notify_set_closure (GClosure *closure)
 696  * {
 697  *   if (notify_closure)
 698  *     g_closure_unref (notify_closure);
 699  *   notify_closure = closure;
 700  *   if (notify_closure)
 701  *     {
 702  *       g_closure_ref (notify_closure);
 703  *       g_closure_sink (notify_closure);
 704  *     }
 705  * }
 706  * ]|
 707  *
 708  * Because g_closure_sink() may decrement the reference count of a closure
 709  * (if it hasn&#39;t been called on @closure yet) just like g_closure_unref(),
 710  * g_closure_ref() should be called prior to this function.
 711  */
 712 void
 713 g_closure_sink (GClosure *closure)
 714 {
 715   g_return_if_fail (closure != NULL);
 716   g_return_if_fail (closure-&gt;ref_count &gt; 0);
 717 
 718   /* floating is basically a kludge to avoid creating closures
 719    * with a ref_count of 0. so the initial ref_count a closure has
 720    * is unowned. with invoking g_closure_sink() code may
 721    * indicate that it takes over that intiial ref_count.
 722    */
 723   if (closure-&gt;floating)
 724     {
 725       gboolean was_floating;
 726       SWAP (closure, floating, FALSE, &amp;was_floating);
 727       /* unref floating flag only once */
 728       if (was_floating)
 729         g_closure_unref (closure);
 730     }
 731 }
 732 
 733 /**
 734  * g_closure_remove_invalidate_notifier: (skip)
 735  * @closure: a #GClosure
 736  * @notify_data: data which was passed to g_closure_add_invalidate_notifier()
 737  *               when registering @notify_func
 738  * @notify_func: the callback function to remove
 739  *
 740  * Removes an invalidation notifier.
 741  *
 742  * Notice that notifiers are automatically removed after they are run.
 743  */
 744 void
 745 g_closure_remove_invalidate_notifier (GClosure      *closure,
<a name="33" id="anc33"></a><span class="line-modified"> 746               gpointer       notify_data,</span>
<span class="line-modified"> 747               GClosureNotify notify_func)</span>
 748 {
 749   g_return_if_fail (closure != NULL);
 750   g_return_if_fail (notify_func != NULL);
 751 
 752   if (closure-&gt;is_invalid &amp;&amp; closure-&gt;in_inotify &amp;&amp; /* account removal of notify_func() while it&#39;s called */
 753       ((gpointer) closure-&gt;marshal) == ((gpointer) notify_func) &amp;&amp;
 754       closure-&gt;data == notify_data)
 755     closure-&gt;marshal = NULL;
 756   else if (!closure_try_remove_inotify (closure, notify_data, notify_func))
 757     g_warning (G_STRLOC &quot;: unable to remove uninstalled invalidation notifier: %p (%p)&quot;,
<a name="34" id="anc34"></a><span class="line-modified"> 758          notify_func, notify_data);</span>
 759 }
 760 
 761 /**
 762  * g_closure_remove_finalize_notifier: (skip)
 763  * @closure: a #GClosure
 764  * @notify_data: data which was passed to g_closure_add_finalize_notifier()
 765  *  when registering @notify_func
 766  * @notify_func: the callback function to remove
 767  *
 768  * Removes a finalization notifier.
 769  *
 770  * Notice that notifiers are automatically removed after they are run.
 771  */
 772 void
 773 g_closure_remove_finalize_notifier (GClosure      *closure,
<a name="35" id="anc35"></a><span class="line-modified"> 774             gpointer       notify_data,</span>
<span class="line-modified"> 775             GClosureNotify notify_func)</span>
 776 {
 777   g_return_if_fail (closure != NULL);
 778   g_return_if_fail (notify_func != NULL);
 779 
 780   if (closure-&gt;is_invalid &amp;&amp; !closure-&gt;in_inotify &amp;&amp; /* account removal of notify_func() while it&#39;s called */
 781       ((gpointer) closure-&gt;marshal) == ((gpointer) notify_func) &amp;&amp;
 782       closure-&gt;data == notify_data)
 783     closure-&gt;marshal = NULL;
 784   else if (!closure_try_remove_fnotify (closure, notify_data, notify_func))
 785     g_warning (G_STRLOC &quot;: unable to remove uninstalled finalization notifier: %p (%p)&quot;,
 786                notify_func, notify_data);
 787 }
 788 
 789 /**
 790  * g_closure_invoke:
 791  * @closure: a #GClosure
 792  * @return_value: (optional) (out): a #GValue to store the return
 793  *                value. May be %NULL if the callback of @closure
 794  *                doesn&#39;t return a value.
 795  * @n_param_values: the length of the @param_values array
 796  * @param_values: (array length=n_param_values): an array of
 797  *                #GValues holding the arguments on which to
 798  *                invoke the callback of @closure
 799  * @invocation_hint: (nullable): a context-dependent invocation hint
 800  *
 801  * Invokes the closure, i.e. executes the callback represented by the @closure.
 802  */
 803 void
 804 g_closure_invoke (GClosure       *closure,
<a name="36" id="anc36"></a><span class="line-modified"> 805       GValue /*out*/ *return_value,</span>
<span class="line-modified"> 806       guint           n_param_values,</span>
<span class="line-modified"> 807       const GValue   *param_values,</span>
<span class="line-modified"> 808       gpointer        invocation_hint)</span>
 809 {
 810   GRealClosure *real_closure;
 811 
 812   g_return_if_fail (closure != NULL);
 813 
 814   real_closure = G_REAL_CLOSURE (closure);
 815 
 816   g_closure_ref (closure);      /* preserve floating flag */
 817   if (!closure-&gt;is_invalid)
 818     {
 819       GClosureMarshal marshal;
 820       gpointer marshal_data;
 821       gboolean in_marshal = closure-&gt;in_marshal;
 822 
 823       g_return_if_fail (closure-&gt;marshal || real_closure-&gt;meta_marshal);
 824 
 825       SET (closure, in_marshal, TRUE);
 826       if (real_closure-&gt;meta_marshal)
<a name="37" id="anc37"></a><span class="line-modified"> 827   {</span>
<span class="line-modified"> 828     marshal_data = real_closure-&gt;meta_marshal_data;</span>
<span class="line-modified"> 829     marshal = real_closure-&gt;meta_marshal;</span>
<span class="line-modified"> 830   }</span>
 831       else
<a name="38" id="anc38"></a><span class="line-modified"> 832   {</span>
<span class="line-modified"> 833     marshal_data = NULL;</span>
<span class="line-modified"> 834     marshal = closure-&gt;marshal;</span>
<span class="line-modified"> 835   }</span>
 836       if (!in_marshal)
<a name="39" id="anc39"></a><span class="line-modified"> 837   closure_invoke_notifiers (closure, PRE_NOTIFY);</span>
 838       marshal (closure,
<a name="40" id="anc40"></a><span class="line-modified"> 839          return_value,</span>
<span class="line-modified"> 840          n_param_values, param_values,</span>
<span class="line-modified"> 841          invocation_hint,</span>
<span class="line-modified"> 842          marshal_data);</span>
 843       if (!in_marshal)
<a name="41" id="anc41"></a><span class="line-modified"> 844   closure_invoke_notifiers (closure, POST_NOTIFY);</span>
 845       SET (closure, in_marshal, in_marshal);
 846     }
 847   g_closure_unref (closure);
 848 }
 849 
 850 gboolean
 851 _g_closure_supports_invoke_va (GClosure       *closure)
 852 {
 853   GRealClosure *real_closure;
 854 
 855   g_return_val_if_fail (closure != NULL, FALSE);
 856 
 857   real_closure = G_REAL_CLOSURE (closure);
 858 
 859   return
 860     real_closure-&gt;va_marshal != NULL &amp;&amp;
 861     (real_closure-&gt;meta_marshal == NULL ||
 862      real_closure-&gt;va_meta_marshal != NULL);
 863 }
 864 
 865 void
 866 _g_closure_invoke_va (GClosure       *closure,
<a name="42" id="anc42"></a><span class="line-modified"> 867           GValue /*out*/ *return_value,</span>
<span class="line-modified"> 868           gpointer        instance,</span>
<span class="line-modified"> 869           va_list         args,</span>
<span class="line-modified"> 870           int             n_params,</span>
<span class="line-modified"> 871           GType          *param_types)</span>
 872 {
 873   GRealClosure *real_closure;
 874 
 875   g_return_if_fail (closure != NULL);
 876 
 877   real_closure = G_REAL_CLOSURE (closure);
 878 
 879   g_closure_ref (closure);      /* preserve floating flag */
 880   if (!closure-&gt;is_invalid)
 881     {
 882       GVaClosureMarshal marshal;
 883       gpointer marshal_data;
 884       gboolean in_marshal = closure-&gt;in_marshal;
 885 
 886       g_return_if_fail (closure-&gt;marshal || real_closure-&gt;meta_marshal);
 887 
 888       SET (closure, in_marshal, TRUE);
 889       if (real_closure-&gt;va_meta_marshal)
<a name="43" id="anc43"></a><span class="line-modified"> 890   {</span>
<span class="line-modified"> 891     marshal_data = real_closure-&gt;meta_marshal_data;</span>
<span class="line-modified"> 892     marshal = real_closure-&gt;va_meta_marshal;</span>
<span class="line-modified"> 893   }</span>
 894       else
<a name="44" id="anc44"></a><span class="line-modified"> 895   {</span>
<span class="line-modified"> 896     marshal_data = NULL;</span>
<span class="line-modified"> 897     marshal = real_closure-&gt;va_marshal;</span>
<span class="line-modified"> 898   }</span>
 899       if (!in_marshal)
<a name="45" id="anc45"></a><span class="line-modified"> 900   closure_invoke_notifiers (closure, PRE_NOTIFY);</span>
 901       marshal (closure,
<a name="46" id="anc46"></a><span class="line-modified"> 902          return_value,</span>
<span class="line-modified"> 903          instance, args,</span>
<span class="line-modified"> 904          marshal_data,</span>
<span class="line-modified"> 905          n_params, param_types);</span>
 906       if (!in_marshal)
<a name="47" id="anc47"></a><span class="line-modified"> 907   closure_invoke_notifiers (closure, POST_NOTIFY);</span>
 908       SET (closure, in_marshal, in_marshal);
 909     }
 910   g_closure_unref (closure);
 911 }
 912 
 913 
 914 /**
 915  * g_closure_set_marshal: (skip)
 916  * @closure: a #GClosure
 917  * @marshal: a #GClosureMarshal function
 918  *
 919  * Sets the marshaller of @closure. The `marshal_data`
 920  * of @marshal provides a way for a meta marshaller to provide additional
 921  * information to the marshaller. (See g_closure_set_meta_marshal().) For
 922  * GObject&#39;s C predefined marshallers (the g_cclosure_marshal_*()
 923  * functions), what it provides is a callback function to use instead of
 924  * @closure-&gt;callback.
 925  */
 926 void
 927 g_closure_set_marshal (GClosure       *closure,
<a name="48" id="anc48"></a><span class="line-modified"> 928            GClosureMarshal marshal)</span>
 929 {
 930   g_return_if_fail (closure != NULL);
 931   g_return_if_fail (marshal != NULL);
 932 
 933   if (closure-&gt;marshal &amp;&amp; closure-&gt;marshal != marshal)
 934     g_warning (&quot;attempt to override closure-&gt;marshal (%p) with new marshal (%p)&quot;,
<a name="49" id="anc49"></a><span class="line-modified"> 935          closure-&gt;marshal, marshal);</span>
 936   else
 937     closure-&gt;marshal = marshal;
 938 }
 939 
 940 void
 941 _g_closure_set_va_marshal (GClosure       *closure,
<a name="50" id="anc50"></a><span class="line-modified"> 942          GVaClosureMarshal marshal)</span>
 943 {
 944   GRealClosure *real_closure;
 945 
 946   g_return_if_fail (closure != NULL);
 947   g_return_if_fail (marshal != NULL);
 948 
 949   real_closure = G_REAL_CLOSURE (closure);
 950 
 951   if (real_closure-&gt;va_marshal &amp;&amp; real_closure-&gt;va_marshal != marshal)
 952     g_warning (&quot;attempt to override closure-&gt;va_marshal (%p) with new marshal (%p)&quot;,
<a name="51" id="anc51"></a><span class="line-modified"> 953          real_closure-&gt;va_marshal, marshal);</span>
 954   else
 955     real_closure-&gt;va_marshal = marshal;
 956 }
 957 
 958 /**
 959  * g_cclosure_new: (skip)
 960  * @callback_func: the function to invoke
 961  * @user_data: (closure callback_func): user data to pass to @callback_func
 962  * @destroy_data: destroy notify to be called when @user_data is no longer used
 963  *
 964  * Creates a new closure which invokes @callback_func with @user_data as
 965  * the last parameter.
 966  *
<a name="52" id="anc52"></a><span class="line-added"> 967  * @destroy_data will be called as a finalize notifier on the #GClosure.</span>
<span class="line-added"> 968  *</span>
 969  * Returns: (transfer none): a floating reference to a new #GCClosure
 970  */
 971 GClosure*
 972 g_cclosure_new (GCallback      callback_func,
<a name="53" id="anc53"></a><span class="line-modified"> 973     gpointer       user_data,</span>
<span class="line-modified"> 974     GClosureNotify destroy_data)</span>
 975 {
 976   GClosure *closure;
 977 
 978   g_return_val_if_fail (callback_func != NULL, NULL);
 979 
 980   closure = g_closure_new_simple (sizeof (GCClosure), user_data);
 981 #ifdef GSTREAMER_LITE
 982   if (closure == NULL)
 983     return NULL;
 984 #endif // GSTREAMER_LITE
 985   if (destroy_data)
 986     g_closure_add_finalize_notifier (closure, user_data, destroy_data);
 987   ((GCClosure*) closure)-&gt;callback = (gpointer) callback_func;
 988 
 989   return closure;
 990 }
 991 
 992 /**
 993  * g_cclosure_new_swap: (skip)
 994  * @callback_func: the function to invoke
 995  * @user_data: (closure callback_func): user data to pass to @callback_func
 996  * @destroy_data: destroy notify to be called when @user_data is no longer used
 997  *
 998  * Creates a new closure which invokes @callback_func with @user_data as
 999  * the first parameter.
1000  *
<a name="54" id="anc54"></a><span class="line-added">1001  * @destroy_data will be called as a finalize notifier on the #GClosure.</span>
<span class="line-added">1002  *</span>
1003  * Returns: (transfer none): a floating reference to a new #GCClosure
1004  */
1005 GClosure*
1006 g_cclosure_new_swap (GCallback      callback_func,
<a name="55" id="anc55"></a><span class="line-modified">1007          gpointer       user_data,</span>
<span class="line-modified">1008          GClosureNotify destroy_data)</span>
1009 {
1010   GClosure *closure;
1011 
1012   g_return_val_if_fail (callback_func != NULL, NULL);
1013 
1014   closure = g_closure_new_simple (sizeof (GCClosure), user_data);
1015 #ifdef GSTREAMER_LITE
1016   if (closure == NULL)
1017     return NULL;
1018 #endif // GSTREAMER_LITE
1019   if (destroy_data)
1020     g_closure_add_finalize_notifier (closure, user_data, destroy_data);
1021   ((GCClosure*) closure)-&gt;callback = (gpointer) callback_func;
1022   SET (closure, derivative_flag, TRUE);
1023 
1024   return closure;
1025 }
1026 
1027 static void
1028 g_type_class_meta_marshal (GClosure       *closure,
<a name="56" id="anc56"></a><span class="line-modified">1029          GValue /*out*/ *return_value,</span>
<span class="line-modified">1030          guint           n_param_values,</span>
<span class="line-modified">1031          const GValue   *param_values,</span>
<span class="line-modified">1032          gpointer        invocation_hint,</span>
<span class="line-modified">1033          gpointer        marshal_data)</span>
1034 {
1035   GTypeClass *class;
1036   gpointer callback;
1037   /* GType itype = (GType) closure-&gt;data; */
1038   guint offset = GPOINTER_TO_UINT (marshal_data);
1039 
1040   class = G_TYPE_INSTANCE_GET_CLASS (g_value_peek_pointer (param_values + 0), itype, GTypeClass);
1041   callback = G_STRUCT_MEMBER (gpointer, class, offset);
1042   if (callback)
1043     closure-&gt;marshal (closure,
<a name="57" id="anc57"></a><span class="line-modified">1044           return_value,</span>
<span class="line-modified">1045           n_param_values, param_values,</span>
<span class="line-modified">1046           invocation_hint,</span>
<span class="line-modified">1047           callback);</span>
1048 }
1049 
1050 static void
1051 g_type_class_meta_marshalv (GClosure *closure,
<a name="58" id="anc58"></a><span class="line-modified">1052           GValue   *return_value,</span>
<span class="line-modified">1053           gpointer  instance,</span>
<span class="line-modified">1054           va_list   args,</span>
<span class="line-modified">1055           gpointer  marshal_data,</span>
<span class="line-modified">1056           int       n_params,</span>
<span class="line-modified">1057           GType    *param_types)</span>
1058 {
1059   GRealClosure *real_closure;
1060   GTypeClass *class;
1061   gpointer callback;
1062   /* GType itype = (GType) closure-&gt;data; */
1063   guint offset = GPOINTER_TO_UINT (marshal_data);
1064 
1065   real_closure = G_REAL_CLOSURE (closure);
1066 
1067   class = G_TYPE_INSTANCE_GET_CLASS (instance, itype, GTypeClass);
1068   callback = G_STRUCT_MEMBER (gpointer, class, offset);
1069   if (callback)
1070     real_closure-&gt;va_marshal (closure,
<a name="59" id="anc59"></a><span class="line-modified">1071             return_value,</span>
<span class="line-modified">1072             instance, args,</span>
<span class="line-modified">1073             callback,</span>
<span class="line-modified">1074             n_params,</span>
<span class="line-modified">1075             param_types);</span>
1076 }
1077 
1078 static void
1079 g_type_iface_meta_marshal (GClosure       *closure,
<a name="60" id="anc60"></a><span class="line-modified">1080          GValue /*out*/ *return_value,</span>
<span class="line-modified">1081          guint           n_param_values,</span>
<span class="line-modified">1082          const GValue   *param_values,</span>
<span class="line-modified">1083          gpointer        invocation_hint,</span>
<span class="line-modified">1084          gpointer        marshal_data)</span>
1085 {
1086   GTypeClass *class;
1087   gpointer callback;
1088   GType itype = (GType) closure-&gt;data;
1089   guint offset = GPOINTER_TO_UINT (marshal_data);
1090 
1091   class = G_TYPE_INSTANCE_GET_INTERFACE (g_value_peek_pointer (param_values + 0), itype, GTypeClass);
1092   callback = G_STRUCT_MEMBER (gpointer, class, offset);
1093   if (callback)
1094     closure-&gt;marshal (closure,
<a name="61" id="anc61"></a><span class="line-modified">1095           return_value,</span>
<span class="line-modified">1096           n_param_values, param_values,</span>
<span class="line-modified">1097           invocation_hint,</span>
<span class="line-modified">1098           callback);</span>
1099 }
1100 
1101 gboolean
1102 _g_closure_is_void (GClosure *closure,
<a name="62" id="anc62"></a><span class="line-modified">1103         gpointer instance)</span>
1104 {
1105   GRealClosure *real_closure;
1106   GTypeClass *class;
1107   gpointer callback;
1108   GType itype;
1109   guint offset;
1110 
1111   if (closure-&gt;is_invalid)
1112     return TRUE;
1113 
1114   real_closure = G_REAL_CLOSURE (closure);
1115 
1116   if (real_closure-&gt;meta_marshal == g_type_iface_meta_marshal)
1117     {
1118       itype = (GType) closure-&gt;data;
1119       offset = GPOINTER_TO_UINT (real_closure-&gt;meta_marshal_data);
1120 
1121       class = G_TYPE_INSTANCE_GET_INTERFACE (instance, itype, GTypeClass);
1122       callback = G_STRUCT_MEMBER (gpointer, class, offset);
1123       return callback == NULL;
1124     }
1125   else if (real_closure-&gt;meta_marshal == g_type_class_meta_marshal)
1126     {
1127       offset = GPOINTER_TO_UINT (real_closure-&gt;meta_marshal_data);
1128 
1129       class = G_TYPE_INSTANCE_GET_CLASS (instance, itype, GTypeClass);
1130       callback = G_STRUCT_MEMBER (gpointer, class, offset);
1131       return callback == NULL;
1132     }
1133 
1134   return FALSE;
1135 }
1136 
1137 static void
1138 g_type_iface_meta_marshalv (GClosure *closure,
<a name="63" id="anc63"></a><span class="line-modified">1139           GValue   *return_value,</span>
<span class="line-modified">1140           gpointer  instance,</span>
<span class="line-modified">1141           va_list   args,</span>
<span class="line-modified">1142           gpointer  marshal_data,</span>
<span class="line-modified">1143           int       n_params,</span>
<span class="line-modified">1144           GType    *param_types)</span>
1145 {
1146   GRealClosure *real_closure;
1147   GTypeClass *class;
1148   gpointer callback;
1149   GType itype = (GType) closure-&gt;data;
1150   guint offset = GPOINTER_TO_UINT (marshal_data);
1151 
1152   real_closure = G_REAL_CLOSURE (closure);
1153 
1154   class = G_TYPE_INSTANCE_GET_INTERFACE (instance, itype, GTypeClass);
1155   callback = G_STRUCT_MEMBER (gpointer, class, offset);
1156   if (callback)
1157     real_closure-&gt;va_marshal (closure,
<a name="64" id="anc64"></a><span class="line-modified">1158             return_value,</span>
<span class="line-modified">1159             instance, args,</span>
<span class="line-modified">1160             callback,</span>
<span class="line-modified">1161             n_params,</span>
<span class="line-modified">1162             param_types);</span>
1163 }
1164 
1165 /**
1166  * g_signal_type_cclosure_new:
1167  * @itype: the #GType identifier of an interface or classed type
1168  * @struct_offset: the offset of the member function of @itype&#39;s class
1169  *  structure which is to be invoked by the new closure
1170  *
1171  * Creates a new closure which invokes the function found at the offset
1172  * @struct_offset in the class structure of the interface or classed type
1173  * identified by @itype.
1174  *
1175  * Returns: (transfer none): a floating reference to a new #GCClosure
1176  */
1177 GClosure*
1178 g_signal_type_cclosure_new (GType    itype,
<a name="65" id="anc65"></a><span class="line-modified">1179           guint    struct_offset)</span>
1180 {
1181   GClosure *closure;
1182 
1183   g_return_val_if_fail (G_TYPE_IS_CLASSED (itype) || G_TYPE_IS_INTERFACE (itype), NULL);
1184   g_return_val_if_fail (struct_offset &gt;= sizeof (GTypeClass), NULL);
1185 
1186   closure = g_closure_new_simple (sizeof (GClosure), (gpointer) itype);
1187   if (G_TYPE_IS_INTERFACE (itype))
1188     {
1189       g_closure_set_meta_marshal (closure, GUINT_TO_POINTER (struct_offset), g_type_iface_meta_marshal);
1190       g_closure_set_meta_va_marshal (closure, g_type_iface_meta_marshalv);
1191     }
1192   else
1193     {
1194       g_closure_set_meta_marshal (closure, GUINT_TO_POINTER (struct_offset), g_type_class_meta_marshal);
1195       g_closure_set_meta_va_marshal (closure, g_type_class_meta_marshalv);
1196     }
1197   return closure;
1198 }
1199 
1200 #include &lt;ffi.h&gt;
1201 static ffi_type *
1202 value_to_ffi_type (const GValue *gvalue,
1203                    gpointer *value,
1204                    gint *enum_tmpval,
1205                    gboolean *tmpval_used)
1206 {
1207   ffi_type *rettype = NULL;
1208   GType type = g_type_fundamental (G_VALUE_TYPE (gvalue));
1209   g_assert (type != G_TYPE_INVALID);
1210 
1211   if (enum_tmpval)
1212     {
1213       g_assert (tmpval_used != NULL);
1214       *tmpval_used = FALSE;
1215     }
1216 
1217   switch (type)
1218     {
1219     case G_TYPE_BOOLEAN:
1220     case G_TYPE_CHAR:
1221     case G_TYPE_INT:
1222       rettype = &amp;ffi_type_sint;
1223       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_int);
1224       break;
1225     case G_TYPE_ENUM:
1226       /* enums are stored in v_long even though they are integers, which makes
1227        * marshalling through libffi somewhat complicated.  They need to be
1228        * marshalled as signed ints, but we need to use a temporary int sized
1229        * value to pass to libffi otherwise it&#39;ll pull the wrong value on
1230        * BE machines with 32-bit integers when treating v_long as 32-bit int.
1231        */
1232       g_assert (enum_tmpval != NULL);
1233       rettype = &amp;ffi_type_sint;
1234       *enum_tmpval = g_value_get_enum (gvalue);
1235       *value = enum_tmpval;
1236       *tmpval_used = TRUE;
1237       break;
1238     case G_TYPE_FLAGS:
1239       g_assert (enum_tmpval != NULL);
1240       rettype = &amp;ffi_type_uint;
1241       *enum_tmpval = g_value_get_flags (gvalue);
1242       *value = enum_tmpval;
1243       *tmpval_used = TRUE;
1244       break;
1245     case G_TYPE_UCHAR:
1246     case G_TYPE_UINT:
1247       rettype = &amp;ffi_type_uint;
1248       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_uint);
1249       break;
1250     case G_TYPE_STRING:
1251     case G_TYPE_OBJECT:
1252     case G_TYPE_BOXED:
1253     case G_TYPE_PARAM:
1254     case G_TYPE_POINTER:
1255     case G_TYPE_INTERFACE:
1256     case G_TYPE_VARIANT:
1257       rettype = &amp;ffi_type_pointer;
1258       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_pointer);
1259       break;
1260     case G_TYPE_FLOAT:
1261       rettype = &amp;ffi_type_float;
1262       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_float);
1263       break;
1264     case G_TYPE_DOUBLE:
1265       rettype = &amp;ffi_type_double;
1266       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_double);
1267       break;
1268     case G_TYPE_LONG:
1269       rettype = &amp;ffi_type_slong;
1270       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_long);
1271       break;
1272     case G_TYPE_ULONG:
1273       rettype = &amp;ffi_type_ulong;
1274       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_ulong);
1275       break;
1276     case G_TYPE_INT64:
1277       rettype = &amp;ffi_type_sint64;
1278       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_int64);
1279       break;
1280     case G_TYPE_UINT64:
1281       rettype = &amp;ffi_type_uint64;
1282       *value = (gpointer)&amp;(gvalue-&gt;data[0].v_uint64);
1283       break;
1284     default:
1285       rettype = &amp;ffi_type_pointer;
1286       *value = NULL;
1287       g_warning (&quot;value_to_ffi_type: Unsupported fundamental type: %s&quot;, g_type_name (type));
1288       break;
1289     }
1290   return rettype;
1291 }
1292 
1293 static void
1294 value_from_ffi_type (GValue *gvalue, gpointer *value)
1295 {
1296   ffi_arg *int_val = (ffi_arg*) value;
1297 
1298   switch (g_type_fundamental (G_VALUE_TYPE (gvalue)))
1299     {
1300     case G_TYPE_INT:
1301       g_value_set_int (gvalue, (gint) *int_val);
1302       break;
1303     case G_TYPE_FLOAT:
1304       g_value_set_float (gvalue, *(gfloat*)value);
1305       break;
1306     case G_TYPE_DOUBLE:
1307       g_value_set_double (gvalue, *(gdouble*)value);
1308       break;
1309     case G_TYPE_BOOLEAN:
1310       g_value_set_boolean (gvalue, (gboolean) *int_val);
1311       break;
1312     case G_TYPE_STRING:
1313       g_value_take_string (gvalue, *(gchar**)value);
1314       break;
1315     case G_TYPE_CHAR:
1316       g_value_set_schar (gvalue, (gint8) *int_val);
1317       break;
1318     case G_TYPE_UCHAR:
1319       g_value_set_uchar (gvalue, (guchar) *int_val);
1320       break;
1321     case G_TYPE_UINT:
1322       g_value_set_uint (gvalue, (guint) *int_val);
1323       break;
1324     case G_TYPE_POINTER:
1325       g_value_set_pointer (gvalue, *(gpointer*)value);
1326       break;
1327     case G_TYPE_LONG:
1328       g_value_set_long (gvalue, (glong) *int_val);
1329       break;
1330     case G_TYPE_ULONG:
1331       g_value_set_ulong (gvalue, (gulong) *int_val);
1332       break;
1333     case G_TYPE_INT64:
1334       g_value_set_int64 (gvalue, (gint64) *int_val);
1335       break;
1336     case G_TYPE_UINT64:
1337       g_value_set_uint64 (gvalue, (guint64) *int_val);
1338       break;
1339     case G_TYPE_BOXED:
1340       g_value_take_boxed (gvalue, *(gpointer*)value);
1341       break;
1342     case G_TYPE_ENUM:
1343       g_value_set_enum (gvalue, (gint) *int_val);
1344       break;
1345     case G_TYPE_FLAGS:
1346       g_value_set_flags (gvalue, (guint) *int_val);
1347       break;
1348     case G_TYPE_PARAM:
1349       g_value_take_param (gvalue, *(gpointer*)value);
1350       break;
1351     case G_TYPE_OBJECT:
1352       g_value_take_object (gvalue, *(gpointer*)value);
1353       break;
1354     case G_TYPE_VARIANT:
1355       g_value_take_variant (gvalue, *(gpointer*)value);
1356       break;
1357     default:
1358       g_warning (&quot;value_from_ffi_type: Unsupported fundamental type: %s&quot;,
1359                 g_type_name (g_type_fundamental (G_VALUE_TYPE (gvalue))));
1360     }
1361 }
1362 
1363 typedef union {
1364   gpointer _gpointer;
1365   float _float;
1366   double _double;
1367   gint _gint;
1368   guint _guint;
1369   glong _glong;
1370   gulong _gulong;
1371   gint64 _gint64;
1372   guint64 _guint64;
1373 } va_arg_storage;
1374 
1375 static ffi_type *
1376 va_to_ffi_type (GType gtype,
<a name="66" id="anc66"></a><span class="line-modified">1377     va_list *va,</span>
<span class="line-modified">1378     va_arg_storage *storage)</span>
1379 {
1380   ffi_type *rettype = NULL;
1381   GType type = g_type_fundamental (gtype);
1382   g_assert (type != G_TYPE_INVALID);
1383 
1384   switch (type)
1385     {
1386     case G_TYPE_BOOLEAN:
1387     case G_TYPE_CHAR:
1388     case G_TYPE_INT:
1389     case G_TYPE_ENUM:
1390       rettype = &amp;ffi_type_sint;
1391       storage-&gt;_gint = va_arg (*va, gint);
1392       break;
1393     case G_TYPE_UCHAR:
1394     case G_TYPE_UINT:
1395     case G_TYPE_FLAGS:
1396       rettype = &amp;ffi_type_uint;
1397       storage-&gt;_guint = va_arg (*va, guint);
1398       break;
1399     case G_TYPE_STRING:
1400     case G_TYPE_OBJECT:
1401     case G_TYPE_BOXED:
1402     case G_TYPE_PARAM:
1403     case G_TYPE_POINTER:
1404     case G_TYPE_INTERFACE:
1405     case G_TYPE_VARIANT:
1406       rettype = &amp;ffi_type_pointer;
1407       storage-&gt;_gpointer = va_arg (*va, gpointer);
1408       break;
1409     case G_TYPE_FLOAT:
1410       /* Float args are passed as doubles in varargs */
1411       rettype = &amp;ffi_type_float;
1412       storage-&gt;_float = (float)va_arg (*va, double);
1413       break;
1414     case G_TYPE_DOUBLE:
1415       rettype = &amp;ffi_type_double;
1416       storage-&gt;_double = va_arg (*va, double);
1417       break;
1418     case G_TYPE_LONG:
1419       rettype = &amp;ffi_type_slong;
1420       storage-&gt;_glong = va_arg (*va, glong);
1421       break;
1422     case G_TYPE_ULONG:
1423       rettype = &amp;ffi_type_ulong;
1424       storage-&gt;_gulong = va_arg (*va, gulong);
1425       break;
1426     case G_TYPE_INT64:
1427       rettype = &amp;ffi_type_sint64;
1428       storage-&gt;_gint64 = va_arg (*va, gint64);
1429       break;
1430     case G_TYPE_UINT64:
1431       rettype = &amp;ffi_type_uint64;
1432       storage-&gt;_guint64 = va_arg (*va, guint64);
1433       break;
1434     default:
1435       rettype = &amp;ffi_type_pointer;
1436       storage-&gt;_guint64  = 0;
1437       g_warning (&quot;va_to_ffi_type: Unsupported fundamental type: %s&quot;, g_type_name (type));
1438       break;
1439     }
1440   return rettype;
1441 }
1442 
1443 /**
1444  * g_cclosure_marshal_generic:
1445  * @closure: A #GClosure.
1446  * @return_gvalue: A #GValue to store the return value. May be %NULL
1447  *   if the callback of closure doesn&#39;t return a value.
1448  * @n_param_values: The length of the @param_values array.
1449  * @param_values: An array of #GValues holding the arguments
1450  *   on which to invoke the callback of closure.
1451  * @invocation_hint: The invocation hint given as the last argument to
1452  *   g_closure_invoke().
1453  * @marshal_data: Additional data specified when registering the
1454  *   marshaller, see g_closure_set_marshal() and
1455  *   g_closure_set_meta_marshal()
1456  *
1457  * A generic marshaller function implemented via
1458  * [libffi](http://sourceware.org/libffi/).
1459  *
1460  * Normally this function is not passed explicitly to g_signal_new(),
1461  * but used automatically by GLib when specifying a %NULL marshaller.
1462  *
1463  * Since: 2.30
1464  */
1465 void
1466 g_cclosure_marshal_generic (GClosure     *closure,
1467                             GValue       *return_gvalue,
1468                             guint         n_param_values,
1469                             const GValue *param_values,
1470                             gpointer      invocation_hint,
1471                             gpointer      marshal_data)
1472 {
1473   ffi_type *rtype;
1474   void *rvalue;
1475   int n_args;
1476   ffi_type **atypes;
1477   void **args;
1478   int i;
1479   ffi_cif cif;
1480   GCClosure *cc = (GCClosure*) closure;
1481   gint *enum_tmpval;
1482   gboolean tmpval_used = FALSE;
1483 
1484   enum_tmpval = g_alloca (sizeof (gint));
1485   if (return_gvalue &amp;&amp; G_VALUE_TYPE (return_gvalue))
1486     {
1487       rtype = value_to_ffi_type (return_gvalue, &amp;rvalue, enum_tmpval, &amp;tmpval_used);
1488     }
1489   else
1490     {
1491       rtype = &amp;ffi_type_void;
1492     }
1493 
1494   rvalue = g_alloca (MAX (rtype-&gt;size, sizeof (ffi_arg)));
1495 
1496   n_args = n_param_values + 1;
1497   atypes = g_alloca (sizeof (ffi_type *) * n_args);
1498   args =  g_alloca (sizeof (gpointer) * n_args);
1499 
1500   if (tmpval_used)
1501     enum_tmpval = g_alloca (sizeof (gint));
1502 
1503   if (G_CCLOSURE_SWAP_DATA (closure))
1504     {
1505       atypes[n_args-1] = value_to_ffi_type (param_values + 0,
1506                                             &amp;args[n_args-1],
1507                                             enum_tmpval,
1508                                             &amp;tmpval_used);
1509       atypes[0] = &amp;ffi_type_pointer;
1510       args[0] = &amp;closure-&gt;data;
1511     }
1512   else
1513     {
1514       atypes[0] = value_to_ffi_type (param_values + 0,
1515                                      &amp;args[0],
1516                                      enum_tmpval,
1517                                      &amp;tmpval_used);
1518       atypes[n_args-1] = &amp;ffi_type_pointer;
1519       args[n_args-1] = &amp;closure-&gt;data;
1520     }
1521 
1522   for (i = 1; i &lt; n_args - 1; i++)
1523     {
1524       if (tmpval_used)
1525         enum_tmpval = g_alloca (sizeof (gint));
1526 
1527       atypes[i] = value_to_ffi_type (param_values + i,
1528                                      &amp;args[i],
1529                                      enum_tmpval,
1530                                      &amp;tmpval_used);
1531     }
1532 
1533   if (ffi_prep_cif (&amp;cif, FFI_DEFAULT_ABI, n_args, rtype, atypes) != FFI_OK)
1534     return;
1535 
1536   ffi_call (&amp;cif, marshal_data ? marshal_data : cc-&gt;callback, rvalue, args);
1537 
1538   if (return_gvalue &amp;&amp; G_VALUE_TYPE (return_gvalue))
1539     value_from_ffi_type (return_gvalue, rvalue);
1540 }
1541 
1542 /**
1543  * g_cclosure_marshal_generic_va:
1544  * @closure: the #GClosure to which the marshaller belongs
1545  * @return_value: (nullable): a #GValue to store the return
1546  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
1547  *  value.
1548  * @instance: (type GObject.TypeInstance): the instance on which the closure is
1549  *  invoked.
1550  * @args_list: va_list of arguments to be passed to the closure.
1551  * @marshal_data: (nullable): additional data specified when
1552  *  registering the marshaller, see g_closure_set_marshal() and
1553  *  g_closure_set_meta_marshal()
1554  * @n_params: the length of the @param_types array
1555  * @param_types: (array length=n_params): the #GType of each argument from
1556  *  @args_list.
1557  *
1558  * A generic #GVaClosureMarshal function implemented via
1559  * [libffi](http://sourceware.org/libffi/).
1560  *
1561  * Since: 2.30
1562  */
1563 void
1564 g_cclosure_marshal_generic_va (GClosure *closure,
<a name="67" id="anc67"></a><span class="line-modified">1565              GValue   *return_value,</span>
<span class="line-modified">1566              gpointer  instance,</span>
<span class="line-modified">1567              va_list   args_list,</span>
<span class="line-modified">1568              gpointer  marshal_data,</span>
<span class="line-modified">1569              int       n_params,</span>
<span class="line-modified">1570              GType    *param_types)</span>
1571 {
1572   ffi_type *rtype;
1573   void *rvalue;
1574   int n_args;
1575   ffi_type **atypes;
1576   void **args;
1577   va_arg_storage *storage;
1578   int i;
1579   ffi_cif cif;
1580   GCClosure *cc = (GCClosure*) closure;
1581   gint *enum_tmpval;
1582   gboolean tmpval_used = FALSE;
1583   va_list args_copy;
1584 
1585   enum_tmpval = g_alloca (sizeof (gint));
1586   if (return_value &amp;&amp; G_VALUE_TYPE (return_value))
1587     {
1588       rtype = value_to_ffi_type (return_value, &amp;rvalue, enum_tmpval, &amp;tmpval_used);
1589     }
1590   else
1591     {
1592       rtype = &amp;ffi_type_void;
1593     }
1594 
1595   rvalue = g_alloca (MAX (rtype-&gt;size, sizeof (ffi_arg)));
1596 
1597   n_args = n_params + 2;
1598   atypes = g_alloca (sizeof (ffi_type *) * n_args);
1599   args =  g_alloca (sizeof (gpointer) * n_args);
1600   storage = g_alloca (sizeof (va_arg_storage) * n_params);
1601 
1602   if (G_CCLOSURE_SWAP_DATA (closure))
1603     {
1604       atypes[n_args-1] = &amp;ffi_type_pointer;
1605       args[n_args-1] = &amp;instance;
1606       atypes[0] = &amp;ffi_type_pointer;
1607       args[0] = &amp;closure-&gt;data;
1608     }
1609   else
1610     {
1611       atypes[0] = &amp;ffi_type_pointer;
1612       args[0] = &amp;instance;
1613       atypes[n_args-1] = &amp;ffi_type_pointer;
1614       args[n_args-1] = &amp;closure-&gt;data;
1615     }
1616 
1617   G_VA_COPY (args_copy, args_list);
1618 
1619   /* Box non-primitive arguments */
1620   for (i = 0; i &lt; n_params; i++)
1621     {
1622       GType type = param_types[i]  &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
1623       GType fundamental = G_TYPE_FUNDAMENTAL (type);
1624 
1625       atypes[i+1] = va_to_ffi_type (type,
<a name="68" id="anc68"></a><span class="line-modified">1626             &amp;args_copy,</span>
<span class="line-modified">1627             &amp;storage[i]);</span>
1628       args[i+1] = &amp;storage[i];
1629 
1630       if ((param_types[i]  &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0)
<a name="69" id="anc69"></a><span class="line-modified">1631   {</span>
<span class="line-modified">1632     if (fundamental == G_TYPE_STRING &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1633       storage[i]._gpointer = g_strdup (storage[i]._gpointer);</span>
<span class="line-modified">1634     else if (fundamental == G_TYPE_PARAM &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1635       storage[i]._gpointer = g_param_spec_ref (storage[i]._gpointer);</span>
<span class="line-modified">1636     else if (fundamental == G_TYPE_BOXED &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1637       storage[i]._gpointer = g_boxed_copy (type, storage[i]._gpointer);</span>
<span class="line-modified">1638     else if (fundamental == G_TYPE_VARIANT &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1639       storage[i]._gpointer = g_variant_ref_sink (storage[i]._gpointer);</span>
<span class="line-modified">1640   }</span>
1641       if (fundamental == G_TYPE_OBJECT &amp;&amp; storage[i]._gpointer != NULL)
<a name="70" id="anc70"></a><span class="line-modified">1642   storage[i]._gpointer = g_object_ref (storage[i]._gpointer);</span>
1643     }
1644 
1645   va_end (args_copy);
1646 
1647   if (ffi_prep_cif (&amp;cif, FFI_DEFAULT_ABI, n_args, rtype, atypes) != FFI_OK)
1648     return;
1649 
1650   ffi_call (&amp;cif, marshal_data ? marshal_data : cc-&gt;callback, rvalue, args);
1651 
1652   /* Unbox non-primitive arguments */
1653   for (i = 0; i &lt; n_params; i++)
1654     {
1655       GType type = param_types[i]  &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
1656       GType fundamental = G_TYPE_FUNDAMENTAL (type);
1657 
1658       if ((param_types[i]  &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0)
<a name="71" id="anc71"></a><span class="line-modified">1659   {</span>
<span class="line-modified">1660     if (fundamental == G_TYPE_STRING &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1661       g_free (storage[i]._gpointer);</span>
<span class="line-modified">1662     else if (fundamental == G_TYPE_PARAM &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1663       g_param_spec_unref (storage[i]._gpointer);</span>
<span class="line-modified">1664     else if (fundamental == G_TYPE_BOXED &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1665       g_boxed_free (type, storage[i]._gpointer);</span>
<span class="line-modified">1666     else if (fundamental == G_TYPE_VARIANT &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1667       g_variant_unref (storage[i]._gpointer);</span>
<span class="line-modified">1668   }</span>
1669       if (fundamental == G_TYPE_OBJECT &amp;&amp; storage[i]._gpointer != NULL)
<a name="72" id="anc72"></a><span class="line-modified">1670   g_object_unref (storage[i]._gpointer);</span>
1671     }
1672 
1673   if (return_value &amp;&amp; G_VALUE_TYPE (return_value))
1674     value_from_ffi_type (return_value, rvalue);
1675 }
1676 
1677 /**
1678  * g_cclosure_marshal_VOID__VOID:
1679  * @closure: the #GClosure to which the marshaller belongs
1680  * @return_value: ignored
1681  * @n_param_values: 1
1682  * @param_values: a #GValue array holding only the instance
1683  * @invocation_hint: the invocation hint given as the last argument
1684  *  to g_closure_invoke()
1685  * @marshal_data: additional data specified when registering the marshaller
1686  *
1687  * A marshaller for a #GCClosure with a callback of type
1688  * `void (*callback) (gpointer instance, gpointer user_data)`.
1689  */
1690 
1691 /**
1692  * g_cclosure_marshal_VOID__BOOLEAN:
1693  * @closure: the #GClosure to which the marshaller belongs
1694  * @return_value: ignored
1695  * @n_param_values: 2
1696  * @param_values: a #GValue array holding the instance and the #gboolean parameter
1697  * @invocation_hint: the invocation hint given as the last argument
1698  *  to g_closure_invoke()
1699  * @marshal_data: additional data specified when registering the marshaller
1700  *
1701  * A marshaller for a #GCClosure with a callback of type
1702  * `void (*callback) (gpointer instance, gboolean arg1, gpointer user_data)`.
1703  */
1704 
1705 /**
1706  * g_cclosure_marshal_VOID__CHAR:
1707  * @closure: the #GClosure to which the marshaller belongs
1708  * @return_value: ignored
1709  * @n_param_values: 2
1710  * @param_values: a #GValue array holding the instance and the #gchar parameter
1711  * @invocation_hint: the invocation hint given as the last argument
1712  *  to g_closure_invoke()
1713  * @marshal_data: additional data specified when registering the marshaller
1714  *
1715  * A marshaller for a #GCClosure with a callback of type
1716  * `void (*callback) (gpointer instance, gchar arg1, gpointer user_data)`.
1717  */
1718 
1719 /**
1720  * g_cclosure_marshal_VOID__UCHAR:
1721  * @closure: the #GClosure to which the marshaller belongs
1722  * @return_value: ignored
1723  * @n_param_values: 2
1724  * @param_values: a #GValue array holding the instance and the #guchar parameter
1725  * @invocation_hint: the invocation hint given as the last argument
1726  *  to g_closure_invoke()
1727  * @marshal_data: additional data specified when registering the marshaller
1728  *
1729  * A marshaller for a #GCClosure with a callback of type
1730  * `void (*callback) (gpointer instance, guchar arg1, gpointer user_data)`.
1731  */
1732 
1733 /**
1734  * g_cclosure_marshal_VOID__INT:
1735  * @closure: the #GClosure to which the marshaller belongs
1736  * @return_value: ignored
1737  * @n_param_values: 2
1738  * @param_values: a #GValue array holding the instance and the #gint parameter
1739  * @invocation_hint: the invocation hint given as the last argument
1740  *  to g_closure_invoke()
1741  * @marshal_data: additional data specified when registering the marshaller
1742  *
1743  * A marshaller for a #GCClosure with a callback of type
1744  * `void (*callback) (gpointer instance, gint arg1, gpointer user_data)`.
1745  */
1746 
1747 /**
1748  * g_cclosure_marshal_VOID__UINT:
1749  * @closure: the #GClosure to which the marshaller belongs
1750  * @return_value: ignored
1751  * @n_param_values: 2
1752  * @param_values: a #GValue array holding the instance and the #guint parameter
1753  * @invocation_hint: the invocation hint given as the last argument
1754  *  to g_closure_invoke()
1755  * @marshal_data: additional data specified when registering the marshaller
1756  *
1757  * A marshaller for a #GCClosure with a callback of type
1758  * `void (*callback) (gpointer instance, guint arg1, gpointer user_data)`.
1759  */
1760 
1761 /**
1762  * g_cclosure_marshal_VOID__LONG:
1763  * @closure: the #GClosure to which the marshaller belongs
1764  * @return_value: ignored
1765  * @n_param_values: 2
1766  * @param_values: a #GValue array holding the instance and the #glong parameter
1767  * @invocation_hint: the invocation hint given as the last argument
1768  *  to g_closure_invoke()
1769  * @marshal_data: additional data specified when registering the marshaller
1770  *
1771  * A marshaller for a #GCClosure with a callback of type
1772  * `void (*callback) (gpointer instance, glong arg1, gpointer user_data)`.
1773  */
1774 
1775 /**
1776  * g_cclosure_marshal_VOID__ULONG:
1777  * @closure: the #GClosure to which the marshaller belongs
1778  * @return_value: ignored
1779  * @n_param_values: 2
1780  * @param_values: a #GValue array holding the instance and the #gulong parameter
1781  * @invocation_hint: the invocation hint given as the last argument
1782  *  to g_closure_invoke()
1783  * @marshal_data: additional data specified when registering the marshaller
1784  *
1785  * A marshaller for a #GCClosure with a callback of type
1786  * `void (*callback) (gpointer instance, gulong arg1, gpointer user_data)`.
1787  */
1788 
1789 /**
1790  * g_cclosure_marshal_VOID__ENUM:
1791  * @closure: the #GClosure to which the marshaller belongs
1792  * @return_value: ignored
1793  * @n_param_values: 2
1794  * @param_values: a #GValue array holding the instance and the enumeration parameter
1795  * @invocation_hint: the invocation hint given as the last argument
1796  *  to g_closure_invoke()
1797  * @marshal_data: additional data specified when registering the marshaller
1798  *
1799  * A marshaller for a #GCClosure with a callback of type
1800  * `void (*callback) (gpointer instance, gint arg1, gpointer user_data)` where the #gint parameter denotes an enumeration type..
1801  */
1802 
1803 /**
1804  * g_cclosure_marshal_VOID__FLAGS:
1805  * @closure: the #GClosure to which the marshaller belongs
1806  * @return_value: ignored
1807  * @n_param_values: 2
1808  * @param_values: a #GValue array holding the instance and the flags parameter
1809  * @invocation_hint: the invocation hint given as the last argument
1810  *  to g_closure_invoke()
1811  * @marshal_data: additional data specified when registering the marshaller
1812  *
1813  * A marshaller for a #GCClosure with a callback of type
1814  * `void (*callback) (gpointer instance, gint arg1, gpointer user_data)` where the #gint parameter denotes a flags type.
1815  */
1816 
1817 /**
1818  * g_cclosure_marshal_VOID__FLOAT:
1819  * @closure: the #GClosure to which the marshaller belongs
1820  * @return_value: ignored
1821  * @n_param_values: 2
1822  * @param_values: a #GValue array holding the instance and the #gfloat parameter
1823  * @invocation_hint: the invocation hint given as the last argument
1824  *  to g_closure_invoke()
1825  * @marshal_data: additional data specified when registering the marshaller
1826  *
1827  * A marshaller for a #GCClosure with a callback of type
1828  * `void (*callback) (gpointer instance, gfloat arg1, gpointer user_data)`.
1829  */
1830 
1831 /**
1832  * g_cclosure_marshal_VOID__DOUBLE:
1833  * @closure: the #GClosure to which the marshaller belongs
1834  * @return_value: ignored
1835  * @n_param_values: 2
1836  * @param_values: a #GValue array holding the instance and the #gdouble parameter
1837  * @invocation_hint: the invocation hint given as the last argument
1838  *  to g_closure_invoke()
1839  * @marshal_data: additional data specified when registering the marshaller
1840  *
1841  * A marshaller for a #GCClosure with a callback of type
1842  * `void (*callback) (gpointer instance, gdouble arg1, gpointer user_data)`.
1843  */
1844 
1845 /**
1846  * g_cclosure_marshal_VOID__STRING:
1847  * @closure: the #GClosure to which the marshaller belongs
1848  * @return_value: ignored
1849  * @n_param_values: 2
1850  * @param_values: a #GValue array holding the instance and the #gchar* parameter
1851  * @invocation_hint: the invocation hint given as the last argument
1852  *  to g_closure_invoke()
1853  * @marshal_data: additional data specified when registering the marshaller
1854  *
1855  * A marshaller for a #GCClosure with a callback of type
1856  * `void (*callback) (gpointer instance, const gchar *arg1, gpointer user_data)`.
1857  */
1858 
1859 /**
1860  * g_cclosure_marshal_VOID__PARAM:
1861  * @closure: the #GClosure to which the marshaller belongs
1862  * @return_value: ignored
1863  * @n_param_values: 2
1864  * @param_values: a #GValue array holding the instance and the #GParamSpec* parameter
1865  * @invocation_hint: the invocation hint given as the last argument
1866  *  to g_closure_invoke()
1867  * @marshal_data: additional data specified when registering the marshaller
1868  *
1869  * A marshaller for a #GCClosure with a callback of type
1870  * `void (*callback) (gpointer instance, GParamSpec *arg1, gpointer user_data)`.
1871  */
1872 
1873 /**
1874  * g_cclosure_marshal_VOID__BOXED:
1875  * @closure: the #GClosure to which the marshaller belongs
1876  * @return_value: ignored
1877  * @n_param_values: 2
1878  * @param_values: a #GValue array holding the instance and the #GBoxed* parameter
1879  * @invocation_hint: the invocation hint given as the last argument
1880  *  to g_closure_invoke()
1881  * @marshal_data: additional data specified when registering the marshaller
1882  *
1883  * A marshaller for a #GCClosure with a callback of type
1884  * `void (*callback) (gpointer instance, GBoxed *arg1, gpointer user_data)`.
1885  */
1886 
1887 /**
1888  * g_cclosure_marshal_VOID__POINTER:
1889  * @closure: the #GClosure to which the marshaller belongs
1890  * @return_value: ignored
1891  * @n_param_values: 2
1892  * @param_values: a #GValue array holding the instance and the #gpointer parameter
1893  * @invocation_hint: the invocation hint given as the last argument
1894  *  to g_closure_invoke()
1895  * @marshal_data: additional data specified when registering the marshaller
1896  *
1897  * A marshaller for a #GCClosure with a callback of type
1898  * `void (*callback) (gpointer instance, gpointer arg1, gpointer user_data)`.
1899  */
1900 
1901 /**
1902  * g_cclosure_marshal_VOID__OBJECT:
1903  * @closure: the #GClosure to which the marshaller belongs
1904  * @return_value: ignored
1905  * @n_param_values: 2
1906  * @param_values: a #GValue array holding the instance and the #GObject* parameter
1907  * @invocation_hint: the invocation hint given as the last argument
1908  *  to g_closure_invoke()
1909  * @marshal_data: additional data specified when registering the marshaller
1910  *
1911  * A marshaller for a #GCClosure with a callback of type
1912  * `void (*callback) (gpointer instance, GObject *arg1, gpointer user_data)`.
1913  */
1914 
1915 /**
1916  * g_cclosure_marshal_VOID__VARIANT:
1917  * @closure: the #GClosure to which the marshaller belongs
1918  * @return_value: ignored
1919  * @n_param_values: 2
1920  * @param_values: a #GValue array holding the instance and the #GVariant* parameter
1921  * @invocation_hint: the invocation hint given as the last argument
1922  *  to g_closure_invoke()
1923  * @marshal_data: additional data specified when registering the marshaller
1924  *
1925  * A marshaller for a #GCClosure with a callback of type
1926  * `void (*callback) (gpointer instance, GVariant *arg1, gpointer user_data)`.
1927  *
1928  * Since: 2.26
1929  */
1930 
1931 /**
1932  * g_cclosure_marshal_VOID__UINT_POINTER:
1933  * @closure: the #GClosure to which the marshaller belongs
1934  * @return_value: ignored
1935  * @n_param_values: 3
1936  * @param_values: a #GValue array holding instance, arg1 and arg2
1937  * @invocation_hint: the invocation hint given as the last argument
1938  *  to g_closure_invoke()
1939  * @marshal_data: additional data specified when registering the marshaller
1940  *
1941  * A marshaller for a #GCClosure with a callback of type
1942  * `void (*callback) (gpointer instance, guint arg1, gpointer arg2, gpointer user_data)`.
1943  */
1944 
1945 /**
1946  * g_cclosure_marshal_BOOLEAN__FLAGS:
1947  * @closure: the #GClosure to which the marshaller belongs
1948  * @return_value: a #GValue which can store the returned #gboolean
1949  * @n_param_values: 2
1950  * @param_values: a #GValue array holding instance and arg1
1951  * @invocation_hint: the invocation hint given as the last argument
1952  *  to g_closure_invoke()
1953  * @marshal_data: additional data specified when registering the marshaller
1954  *
1955  * A marshaller for a #GCClosure with a callback of type
1956  * `gboolean (*callback) (gpointer instance, gint arg1, gpointer user_data)` where the #gint parameter
1957  * denotes a flags type.
1958  */
1959 
1960 /**
1961  * g_cclosure_marshal_BOOL__FLAGS:
1962  *
1963  * Another name for g_cclosure_marshal_BOOLEAN__FLAGS().
1964  */
1965 /**
1966  * g_cclosure_marshal_STRING__OBJECT_POINTER:
1967  * @closure: the #GClosure to which the marshaller belongs
1968  * @return_value: a #GValue, which can store the returned string
1969  * @n_param_values: 3
1970  * @param_values: a #GValue array holding instance, arg1 and arg2
1971  * @invocation_hint: the invocation hint given as the last argument
1972  *  to g_closure_invoke()
1973  * @marshal_data: additional data specified when registering the marshaller
1974  *
1975  * A marshaller for a #GCClosure with a callback of type
1976  * `gchar* (*callback) (gpointer instance, GObject *arg1, gpointer arg2, gpointer user_data)`.
1977  */
1978 /**
1979  * g_cclosure_marshal_BOOLEAN__OBJECT_BOXED_BOXED:
1980  * @closure: the #GClosure to which the marshaller belongs
1981  * @return_value: a #GValue, which can store the returned string
1982  * @n_param_values: 3
1983  * @param_values: a #GValue array holding instance, arg1 and arg2
1984  * @invocation_hint: the invocation hint given as the last argument
1985  *  to g_closure_invoke()
1986  * @marshal_data: additional data specified when registering the marshaller
1987  *
1988  * A marshaller for a #GCClosure with a callback of type
1989  * `gboolean (*callback) (gpointer instance, GBoxed *arg1, GBoxed *arg2, gpointer user_data)`.
1990  *
1991  * Since: 2.26
1992  */
<a name="73" id="anc73"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="73" type="hidden" />
</body>
</html>