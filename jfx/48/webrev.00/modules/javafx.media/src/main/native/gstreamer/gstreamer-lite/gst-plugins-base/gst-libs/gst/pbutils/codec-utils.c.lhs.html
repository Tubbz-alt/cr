<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/pbutils/codec-utils.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer base utils library codec-specific utility functions
   2  * Copyright (C) 2010 Arun Raghavan &lt;arun.raghavan@collabora.co.uk&gt;
   3  *               2013 Sreerenj Balachandran &lt;sreerenj.balachandran@intel.com&gt;
   4  *               2010 Collabora Multimedia
   5  *               2010 Nokia Corporation
   6  *               2013 Intel Corporation
   7  *               2015 Sebastian Dr√∂ge &lt;sebastian@centricular.com&gt;
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public
  20  * License along with this library; if not, write to the
  21  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 /**
  26  * SECTION:gstpbutilscodecutils
  27  * @title: Codec utilities
  28  * @short_description: Miscellaneous codec-specific utility functions
  29  *
  30  * Provides codec-specific ulility functions such as functions to provide the
  31  * codec profile and level in human-readable string form from header data.
  32  *
  33  */
  34 
  35 #ifdef HAVE_CONFIG_H
  36 #include &quot;config.h&quot;
  37 #endif
  38 
  39 #include &quot;pbutils.h&quot;
  40 #include &lt;gst/base/base.h&gt;
<a name="1" id="anc1"></a>
  41 #include &lt;gst/tag/tag.h&gt;
  42 
  43 #include &lt;string.h&gt;
  44 
  45 #define GST_SIMPLE_CAPS_HAS_NAME(caps,name) \
  46     gst_structure_has_name(gst_caps_get_structure((caps),0),(name))
  47 
  48 #define GST_SIMPLE_CAPS_HAS_FIELD(caps,field) \
  49     gst_structure_has_field(gst_caps_get_structure((caps),0),(field))
  50 
  51 static const guint aac_sample_rates[] = { 96000, 88200, 64000, 48000, 44100,
  52   32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350
  53 };
  54 
  55 static const gchar *
  56 digit_to_string (guint digit)
  57 {
  58   static const char itoa[][2] = {
  59     &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;
  60   };
  61 
  62   if (G_LIKELY (digit &lt; 10))
  63     return itoa[digit];
  64   else
  65     return NULL;
  66 }
  67 
  68 /**
  69  * gst_codec_utils_aac_get_sample_rate_from_index:
  70  * @sr_idx: Sample rate index as from the AudioSpecificConfig (MPEG-4
  71  *          container) or ADTS frame header
  72  *
  73  * Translates the sample rate index found in AAC headers to the actual sample
  74  * rate.
  75  *
  76  * Returns: The sample rate if @sr_idx is valid, 0 otherwise.
  77  */
  78 guint
  79 gst_codec_utils_aac_get_sample_rate_from_index (guint sr_idx)
  80 {
  81   if (G_LIKELY (sr_idx &lt; G_N_ELEMENTS (aac_sample_rates)))
  82     return aac_sample_rates[sr_idx];
  83 
  84   GST_WARNING (&quot;Invalid sample rate index %u&quot;, sr_idx);
  85   return 0;
  86 }
  87 
  88 /**
  89  * gst_codec_utils_aac_get_index_from_sample_rate:
  90  * @rate: Sample rate
  91  *
  92  * Translates the sample rate to the index corresponding to it in AAC spec.
  93  *
  94  * Returns: The AAC index for this sample rate, -1 if the rate is not a
  95  * valid AAC sample rate.
  96  */
  97 gint
  98 gst_codec_utils_aac_get_index_from_sample_rate (guint rate)
  99 {
 100   guint n;
 101 
 102   for (n = 0; n &lt; G_N_ELEMENTS (aac_sample_rates); n++)
 103     if (aac_sample_rates[n] == rate)
 104       return n;
 105 
 106   GST_WARNING (&quot;Invalid sample rate %u&quot;, rate);
 107   return -1;
 108 }
 109 
<a name="2" id="anc2"></a>












































































 110 /**
 111  * gst_codec_utils_aac_get_sample_rate:
 112  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 113  *                as specified in the Elementary Stream Descriptor (esds)
 114  *                in ISO/IEC 14496-1.
 115  * @len: Length of @audio_config
 116  *
 117  * Translates the sample rate index found in AAC headers to the actual sample
 118  * rate.
 119  *
 120  * Returns: The sample rate if sr_idx is valid, 0 otherwise.
 121  *
<a name="3" id="anc3"></a><span class="line-modified"> 122  * Since 1.10</span>
 123  */
 124 guint
 125 gst_codec_utils_aac_get_sample_rate (const guint8 * audio_config, guint len)
 126 {
<a name="4" id="anc4"></a><span class="line-modified"> 127   guint rate_index;</span>


 128 
 129   if (len &lt; 2)
 130     return 0;
 131 
<a name="5" id="anc5"></a><span class="line-modified"> 132   rate_index = ((audio_config[0] &amp; 0x7) &lt;&lt; 1) | ((audio_config[1] &amp; 0x80) &gt;&gt; 7);</span>
<span class="line-modified"> 133   return gst_codec_utils_aac_get_sample_rate_from_index (rate_index);</span>


 134 }
 135 
 136 /**
 137  * gst_codec_utils_aac_get_channels:
 138  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 139  *                as specified in the Elementary Stream Descriptor (esds)
 140  *                in ISO/IEC 14496-1.
 141  * @len: Length of @audio_config in bytes
 142  *
 143  * Returns the channels of the given AAC stream.
 144  *
 145  * Returns: The channels or 0 if the channel could not be determined.
 146  *
<a name="6" id="anc6"></a><span class="line-modified"> 147  * Since 1.10</span>
 148  */
 149 guint
 150 gst_codec_utils_aac_get_channels (const guint8 * audio_config, guint len)
 151 {
 152   guint channels;
 153 
 154   if (len &lt; 2)
 155     return 0;
 156 
 157   channels = (audio_config[1] &amp; 0x7f) &gt;&gt; 3;
 158   if (channels &gt; 0 &amp;&amp; channels &lt; 7)
 159     return channels;
 160   else if (channels == 7)
 161     return 8;
 162   else
 163     return 0;
 164 }
 165 
 166 /**
 167  * gst_codec_utils_aac_get_profile:
 168  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 169  *                as specified in the Elementary Stream Descriptor (esds)
 170  *                in ISO/IEC 14496-1.
 171  * @len: Length of @audio_config in bytes
 172  *
 173  * Returns the profile of the given AAC stream as a string. The profile is
<a name="7" id="anc7"></a><span class="line-modified"> 174  * determined using the AudioObjectType field which is in the first 5 bits of</span>
<span class="line-modified"> 175  * @audio_config.</span>
<span class="line-removed"> 176  *</span>
<span class="line-removed"> 177  * &gt; HE-AAC support has not yet been implemented.</span>
 178  *
 179  * Returns: The profile as a const string and %NULL if the profile could not be
 180  * determined.
 181  */
 182 const gchar *
 183 gst_codec_utils_aac_get_profile (const guint8 * audio_config, guint len)
 184 {
<a name="8" id="anc8"></a><span class="line-modified"> 185   guint profile;</span>



 186 
 187   if (len &lt; 1)
 188     return NULL;
 189 
 190   GST_MEMDUMP (&quot;audio config&quot;, audio_config, len);
 191 
<a name="9" id="anc9"></a><span class="line-modified"> 192   profile = audio_config[0] &gt;&gt; 3;</span>
<span class="line-modified"> 193   switch (profile) {</span>




 194     case 1:
<a name="10" id="anc10"></a><span class="line-modified"> 195       return &quot;main&quot;;</span>

 196     case 2:
<a name="11" id="anc11"></a><span class="line-modified"> 197       return &quot;lc&quot;;</span>

 198     case 3:
<a name="12" id="anc12"></a><span class="line-modified"> 199       return &quot;ssr&quot;;</span>

 200     case 4:
<a name="13" id="anc13"></a><span class="line-modified"> 201       return &quot;ltp&quot;;</span>

 202     default:
<a name="14" id="anc14"></a>
 203       break;
 204   }
 205 
<a name="15" id="anc15"></a><span class="line-modified"> 206   GST_DEBUG (&quot;Invalid profile idx: %u&quot;, profile);</span>
<span class="line-removed"> 207   return NULL;</span>
 208 }
 209 
 210 /**
 211  * gst_codec_utils_aac_get_level:
 212  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 213  *                as specified in the Elementary Stream Descriptor (esds)
 214  *                in ISO/IEC 14496-1.
 215  * @len: Length of @audio_config in bytes
 216  *
 217  * Determines the level of a stream as defined in ISO/IEC 14496-3. For AAC LC
 218  * streams, the constraints from the AAC audio profile are applied. For AAC
 219  * Main, LTP, SSR and others, the Main profile is used.
 220  *
 221  * The @audio_config parameter follows the following format, starting from the
 222  * most significant bit of the first byte:
 223  *
<a name="16" id="anc16"></a><span class="line-modified"> 224  *   * Bit 0:4 contains the AudioObjectType</span>

 225  *   * Bit 5:8 contains the sample frequency index (if this is 0xf, then the
 226  *     next 24 bits define the actual sample frequency, and subsequent
 227  *     fields are appropriately shifted).
 228  *   * Bit 9:12 contains the channel configuration
 229  *
<a name="17" id="anc17"></a><span class="line-removed"> 230  * &gt; HE-AAC support has not yet been implemented.</span>
<span class="line-removed"> 231  *</span>
 232  * Returns: The level as a const string and %NULL if the level could not be
 233  * determined.
 234  */
 235 const gchar *
 236 gst_codec_utils_aac_get_level (const guint8 * audio_config, guint len)
 237 {
<a name="18" id="anc18"></a><span class="line-modified"> 238   int profile, sr_idx, channel_config, rate;</span>

 239   /* Number of single channel elements, channel pair elements, low frequency
 240    * elements, independently switched coupling channel elements, and
 241    * dependently switched coupling channel elements.
 242    *
 243    * Note: The 2 CCE types are ignored for now as they require us to actually
 244    * parse the first frame, and they are rarely found in actual streams.
 245    */
 246   int num_sce = 0, num_cpe = 0, num_lfe = 0, num_cce_indep = 0, num_cce_dep = 0;
 247   int num_channels;
 248   /* Processor and RAM Complexity Units (calculated and &quot;reference&quot; for single
 249    * channel) */
<a name="19" id="anc19"></a><span class="line-modified"> 250   int pcu, rcu, pcu_ref, rcu_ref;</span>
 251   int ret = -1;
<a name="20" id="anc20"></a>
 252 
 253   g_return_val_if_fail (audio_config != NULL, NULL);
 254 
 255   if (len &lt; 2)
 256     return NULL;
 257 
 258   GST_MEMDUMP (&quot;audio config&quot;, audio_config, len);
 259 
<a name="21" id="anc21"></a><span class="line-modified"> 260   profile = audio_config[0] &gt;&gt; 3;</span>
<span class="line-modified"> 261   /* FIXME: add support for sr_idx = 0xf */</span>
<span class="line-removed"> 262   sr_idx = ((audio_config[0] &amp; 0x7) &lt;&lt; 1) | ((audio_config[1] &amp; 0x80) &gt;&gt; 7);</span>
<span class="line-removed"> 263   rate = gst_codec_utils_aac_get_sample_rate_from_index (sr_idx);</span>
<span class="line-removed"> 264   channel_config = (audio_config[1] &amp; 0x7f) &gt;&gt; 3;</span>
<span class="line-removed"> 265 </span>
<span class="line-removed"> 266   if (rate == 0)</span>
 267     return NULL;
<a name="22" id="anc22"></a>
 268 
 269   switch (channel_config) {
 270     case 0:
 271       /* Channel config is defined in the AudioObjectType&#39;s SpecificConfig,
 272        * which requires some amount of digging through the headers. I only see
 273        * this done in the MPEG conformance streams - FIXME */
 274       GST_WARNING (&quot;Found a stream with channel configuration in the &quot;
 275           &quot;AudioSpecificConfig. Please file a bug with a link to the media if &quot;
 276           &quot;possible.&quot;);
 277       return NULL;
 278     case 1:
 279       /* front center */
 280       num_sce = 1;
 281       break;
 282     case 2:
 283       /* front left and right */
 284       num_cpe = 1;
 285       break;
 286     case 3:
 287       /* front left, right, and center */
 288       num_sce = 1;
 289       num_cpe = 1;
 290       break;
 291     case 4:
 292       /* front left, right, and center; rear surround */
 293       num_sce = 2;
 294       num_cpe = 1;
 295       break;
 296     case 5:
 297       /* front left, right, and center; rear left and right surround */
 298       num_sce = 1;
 299       num_cpe = 2;
 300       break;
 301     case 6:
 302       /* front left, right, center and LFE; rear left and right surround */
 303       num_sce = 1;
 304       num_cpe = 2;
 305       break;
 306     case 7:
 307     case 12:
 308     case 14:
 309       /* front left, right, center and LFE; outside front left and right;
 310        * rear left and right surround */
 311       num_sce = 1;
 312       num_cpe = 3;
 313       num_lfe = 1;
 314       break;
 315     case 11:
 316       num_sce = 2;
 317       num_cpe = 2;
 318       num_lfe = 1;
 319       break;
 320     default:
 321       GST_WARNING (&quot;Unknown channel config in header: %d&quot;, channel_config);
 322       return NULL;
 323   }
 324 
<a name="23" id="anc23"></a><span class="line-modified"> 325   switch (profile) {</span>
 326     case 0:                    /* NULL */
 327       GST_WARNING (&quot;profile 0 is not a valid profile&quot;);
 328       return NULL;
 329     case 2:                    /* LC */
 330       pcu_ref = 3;
 331       rcu_ref = 3;
 332       break;
 333     case 3:                    /* SSR */
 334       pcu_ref = 4;
 335       rcu_ref = 3;
 336       break;
 337     case 4:                    /* LTP */
 338       pcu_ref = 4;
 339       rcu_ref = 4;
 340       break;
 341     case 1:                    /* Main */
 342     default:
 343       /* Other than a couple of ER profiles, Main is the worst-case */
 344       pcu_ref = 5;
 345       rcu_ref = 5;
 346       break;
 347   }
 348 
 349   /* &quot;fs_ref&quot; is 48000 Hz for AAC Main/LC/SSR/LTP. SBR&#39;s fs_ref is defined as
 350    * 24000/48000 (in/out), for SBR streams. Actual support is a FIXME */
 351 
 352   pcu = ((float) rate / 48000) * pcu_ref *
 353       ((2 * num_cpe) + num_sce + num_lfe + num_cce_indep + (0.3 * num_cce_dep));
 354 
 355   rcu = ((float) rcu_ref) * (num_sce + (0.5 * num_lfe) + (0.5 * num_cce_indep) +
 356       (0.4 * num_cce_dep));
 357 
 358   if (num_cpe &lt; 2)
 359     rcu += (rcu_ref + (rcu_ref - 1)) * num_cpe;
 360   else
 361     rcu += (rcu_ref + (rcu_ref - 1) * ((2 * num_cpe) - 1));
 362 
 363   num_channels = num_sce + (2 * num_cpe) + num_lfe;
 364 
<a name="24" id="anc24"></a><span class="line-modified"> 365   if (profile == 2) {</span>
 366     /* AAC LC =&gt; return the level as per the &#39;AAC Profile&#39; */
 367     if (num_channels &lt;= 2 &amp;&amp; rate &lt;= 24000 &amp;&amp; pcu &lt;= 3 &amp;&amp; rcu &lt;= 5)
 368       ret = 1;
 369     else if (num_channels &lt;= 2 &amp;&amp; rate &lt;= 48000 &amp;&amp; pcu &lt;= 6 &amp;&amp; rcu &lt;= 5)
 370       ret = 2;
 371     /* There is no level 3 for the AAC Profile */
 372     else if (num_channels &lt;= 5 &amp;&amp; rate &lt;= 48000 &amp;&amp; pcu &lt;= 19 &amp;&amp; rcu &lt;= 15)
 373       ret = 4;
 374     else if (num_channels &lt;= 5 &amp;&amp; rate &lt;= 96000 &amp;&amp; pcu &lt;= 38 &amp;&amp; rcu &lt;= 15)
 375       ret = 5;
 376     else if (num_channels &lt;= 7 &amp;&amp; rate &lt;= 48000 &amp;&amp; pcu &lt;= 25 &amp;&amp; rcu &lt;= 19)
 377       ret = 6;
 378     else if (num_channels &lt;= 7 &amp;&amp; rate &lt;= 96000 &amp;&amp; pcu &lt;= 50 &amp;&amp; rcu &lt;= 19)
 379       ret = 7;
 380   } else {
 381     /* Return the level as per the &#39;Main Profile&#39; */
 382     if (pcu &lt; 40 &amp;&amp; rcu &lt; 20)
 383       ret = 1;
 384     else if (pcu &lt; 80 &amp;&amp; rcu &lt; 64)
 385       ret = 2;
 386     else if (pcu &lt; 160 &amp;&amp; rcu &lt; 128)
 387       ret = 3;
 388     else if (pcu &lt; 320 &amp;&amp; rcu &lt; 256)
 389       ret = 4;
 390   }
 391 
 392   if (ret == -1) {
 393     GST_WARNING (&quot;couldn&#39;t determine level: profile=%u, rate=%u, &quot;
<a name="25" id="anc25"></a><span class="line-modified"> 394         &quot;channel_config=%u, pcu=%d,rcu=%d&quot;, profile, rate, channel_config, pcu,</span>
<span class="line-modified"> 395         rcu);</span>
 396     return NULL;
 397   } else {
 398     return digit_to_string (ret);
 399   }
 400 }
 401 
 402 /**
 403  * gst_codec_utils_aac_caps_set_level_and_profile:
 404  * @caps: the #GstCaps to which level and profile fields are to be added
 405  * @audio_config: (array length=len): a pointer to the AudioSpecificConfig
 406  *                as specified in the Elementary Stream Descriptor (esds)
 407  *                in ISO/IEC 14496-1. (See below for more details)
 408  * @len: Length of @audio_config in bytes
 409  *
 410  * Sets the level and profile on @caps if it can be determined from
 411  * @audio_config. See gst_codec_utils_aac_get_level() and
 412  * gst_codec_utils_aac_get_profile() for more details on the parameters.
 413  * @caps must be audio/mpeg caps with an &quot;mpegversion&quot; field of either 2 or 4.
 414  * If mpegversion is 4, the &quot;base-profile&quot; field is also set in @caps.
 415  *
 416  * Returns: %TRUE if the level and profile could be set, %FALSE otherwise.
 417  */
 418 gboolean
 419 gst_codec_utils_aac_caps_set_level_and_profile (GstCaps * caps,
 420     const guint8 * audio_config, guint len)
 421 {
 422   GstStructure *s;
 423   const gchar *level, *profile;
 424   int mpegversion = 0;
 425 
 426   g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);
 427   g_return_val_if_fail (GST_CAPS_IS_SIMPLE (caps), FALSE);
 428   g_return_val_if_fail (GST_SIMPLE_CAPS_HAS_NAME (caps, &quot;audio/mpeg&quot;), FALSE);
 429   g_return_val_if_fail (GST_SIMPLE_CAPS_HAS_FIELD (caps, &quot;mpegversion&quot;), FALSE);
 430   g_return_val_if_fail (audio_config != NULL, FALSE);
 431 
 432   s = gst_caps_get_structure (caps, 0);
 433 
 434   gst_structure_get_int (s, &quot;mpegversion&quot;, &amp;mpegversion);
 435   g_return_val_if_fail (mpegversion == 2 || mpegversion == 4, FALSE);
 436 
 437   level = gst_codec_utils_aac_get_level (audio_config, len);
 438 
 439   if (level != NULL)
 440     gst_structure_set (s, &quot;level&quot;, G_TYPE_STRING, level, NULL);
 441 
 442   profile = gst_codec_utils_aac_get_profile (audio_config, len);
 443 
 444   if (profile != NULL) {
 445     if (mpegversion == 4) {
 446       gst_structure_set (s, &quot;base-profile&quot;, G_TYPE_STRING, profile,
 447           &quot;profile&quot;, G_TYPE_STRING, profile, NULL);
 448     } else {
 449       gst_structure_set (s, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);
 450     }
 451   }
 452 
 453   GST_LOG (&quot;profile : %s&quot;, (profile) ? profile : &quot;---&quot;);
 454   GST_LOG (&quot;level   : %s&quot;, (level) ? level : &quot;---&quot;);
 455 
 456   return (level != NULL &amp;&amp; profile != NULL);
 457 }
 458 
 459 /**
 460  * gst_codec_utils_h264_get_profile:
 461  * @sps: (array length=len): Pointer to the sequence parameter set for the stream.
 462  * @len: Length of the data available in @sps.
 463  *
 464  * Converts the profile indication (profile_idc) in the stream&#39;s
 465  * sequence parameter set into a string. The SPS is expected to have the
 466  * following format, as defined in the H.264 specification. The SPS is viewed
 467  * as a bitstream here, with bit 0 being the most significant bit of the first
 468  * byte.
 469  *
 470  * * Bit 0:7   - Profile indication
 471  * * Bit 8     - constraint_set0_flag
 472  * * Bit 9     - constraint_set1_flag
 473  * * Bit 10    - constraint_set2_flag
 474  * * Bit 11    - constraint_set3_flag
 475  * * Bit 12    - constraint_set3_flag
 476  * * Bit 13:15 - Reserved
 477  * * Bit 16:24 - Level indication
 478  *
 479  * Returns: The profile as a const string, or %NULL if there is an error.
 480  */
 481 const gchar *
 482 gst_codec_utils_h264_get_profile (const guint8 * sps, guint len)
 483 {
 484   const gchar *profile = NULL;
 485   gint csf1, csf3, csf5;
 486 
 487   g_return_val_if_fail (sps != NULL, NULL);
 488 
 489   if (len &lt; 2)
 490     return NULL;
 491 
 492   GST_MEMDUMP (&quot;SPS&quot;, sps, len);
 493 
 494   csf1 = (sps[1] &amp; 0x40) &gt;&gt; 6;
 495   csf3 = (sps[1] &amp; 0x10) &gt;&gt; 4;
 496   csf5 = (sps[1] &amp; 0x04) &gt;&gt; 2;
 497 
 498   switch (sps[0]) {
 499     case 66:
 500       if (csf1)
 501         profile = &quot;constrained-baseline&quot;;
 502       else
 503         profile = &quot;baseline&quot;;
 504       break;
 505     case 77:
 506       profile = &quot;main&quot;;
 507       break;
 508     case 88:
 509       profile = &quot;extended&quot;;
 510       break;
 511     case 100:
 512       profile = &quot;high&quot;;
 513       break;
 514     case 110:
 515       if (csf3)
 516         profile = &quot;high-10-intra&quot;;
 517       else
 518         profile = &quot;high-10&quot;;
 519       break;
 520     case 122:
 521       if (csf3)
 522         profile = &quot;high-4:2:2-intra&quot;;
 523       else
 524         profile = &quot;high-4:2:2&quot;;
 525       break;
 526     case 244:
 527       if (csf3)
 528         profile = &quot;high-4:4:4-intra&quot;;
 529       else
 530         profile = &quot;high-4:4:4&quot;;
 531       break;
 532     case 44:
 533       profile = &quot;cavlc-4:4:4-intra&quot;;
 534       break;
 535     case 118:
 536       profile = &quot;multiview-high&quot;;
 537       break;
 538     case 128:
 539       profile = &quot;stereo-high&quot;;
 540       break;
 541     case 83:
 542       if (csf5)
 543         profile = &quot;scalable-constrained-baseline&quot;;
 544       else
 545         profile = &quot;scalable-baseline&quot;;
 546       break;
 547     case 86:
 548       if (csf3)
 549         profile = &quot;scalable-high-intra&quot;;
 550       else if (csf5)
 551         profile = &quot;scalable-constrained-high&quot;;
 552       else
 553         profile = &quot;scalable-high&quot;;
 554       break;
 555     default:
 556       return NULL;
 557   }
 558 
 559   return profile;
 560 }
 561 
 562 /**
 563  * gst_codec_utils_h264_get_level:
 564  * @sps: (array length=len): Pointer to the sequence parameter set for the stream.
 565  * @len: Length of the data available in @sps.
 566  *
 567  * Converts the level indication (level_idc) in the stream&#39;s
 568  * sequence parameter set into a string. The SPS is expected to have the
 569  * same format as for gst_codec_utils_h264_get_profile().
 570  *
 571  * Returns: The level as a const string, or %NULL if there is an error.
 572  */
 573 const gchar *
 574 gst_codec_utils_h264_get_level (const guint8 * sps, guint len)
 575 {
 576   gint csf3;
 577 
 578   g_return_val_if_fail (sps != NULL, NULL);
 579 
 580   if (len &lt; 3)
 581     return NULL;
 582 
 583   GST_MEMDUMP (&quot;SPS&quot;, sps, len);
 584 
 585   csf3 = (sps[1] &amp; 0x10) &gt;&gt; 4;
 586 
 587   if (sps[2] == 0)
 588     return NULL;
 589   else if ((sps[2] == 11 &amp;&amp; csf3) || sps[2] == 9)
 590     return &quot;1b&quot;;
 591   else if (sps[2] % 10 == 0)
 592     return digit_to_string (sps[2] / 10);
 593   else {
 594     switch (sps[2]) {
 595       case 11:
 596         return &quot;1.1&quot;;
 597       case 12:
 598         return &quot;1.2&quot;;
 599       case 13:
 600         return &quot;1.3&quot;;
 601       case 21:
 602         return &quot;2.1&quot;;
 603       case 22:
 604         return &quot;2.2&quot;;
 605       case 31:
 606         return &quot;3.1&quot;;
 607       case 32:
 608         return &quot;3.2&quot;;
 609       case 41:
 610         return &quot;4.1&quot;;
 611       case 42:
 612         return &quot;4.2&quot;;
 613       case 51:
 614         return &quot;5.1&quot;;
 615       case 52:
 616         return &quot;5.2&quot;;
 617       default:
 618         return NULL;
 619     }
 620   }
 621 }
 622 
 623 /**
 624  * gst_codec_utils_h264_get_level_idc:
 625  * @level: A level string from caps
 626  *
 627  * Transform a level string from the caps into the level_idc
 628  *
 629  * Returns: the level_idc or 0 if the level is unknown
 630  */
 631 guint8
 632 gst_codec_utils_h264_get_level_idc (const gchar * level)
 633 {
 634   g_return_val_if_fail (level != NULL, 0);
 635 
 636   if (!strcmp (level, &quot;1&quot;))
 637     return 10;
 638   else if (!strcmp (level, &quot;1b&quot;))
 639     return 9;
 640   else if (!strcmp (level, &quot;1.1&quot;))
 641     return 11;
 642   else if (!strcmp (level, &quot;1.2&quot;))
 643     return 12;
 644   else if (!strcmp (level, &quot;1.3&quot;))
 645     return 13;
 646   else if (!strcmp (level, &quot;2&quot;))
 647     return 20;
 648   else if (!strcmp (level, &quot;2.1&quot;))
 649     return 21;
 650   else if (!strcmp (level, &quot;2.2&quot;))
 651     return 22;
 652   else if (!strcmp (level, &quot;3&quot;))
 653     return 30;
 654   else if (!strcmp (level, &quot;3.1&quot;))
 655     return 31;
 656   else if (!strcmp (level, &quot;3.2&quot;))
 657     return 32;
 658   else if (!strcmp (level, &quot;4&quot;))
 659     return 40;
 660   else if (!strcmp (level, &quot;4.1&quot;))
 661     return 41;
 662   else if (!strcmp (level, &quot;4.2&quot;))
 663     return 42;
 664   else if (!strcmp (level, &quot;5&quot;))
 665     return 50;
 666   else if (!strcmp (level, &quot;5.1&quot;))
 667     return 51;
 668   else if (!strcmp (level, &quot;5.2&quot;))
 669     return 52;
 670 
 671   GST_WARNING (&quot;Invalid level %s&quot;, level);
 672   return 0;
 673 }
 674 
 675 /**
 676  * gst_codec_utils_h264_caps_set_level_and_profile:
 677  * @caps: the #GstCaps to which the level and profile are to be added
 678  * @sps: (array length=len): Pointer to the sequence parameter set for the stream.
 679  * @len: Length of the data available in @sps.
 680  *
 681  * Sets the level and profile in @caps if it can be determined from @sps. See
 682  * gst_codec_utils_h264_get_level() and gst_codec_utils_h264_get_profile()
 683  * for more details on the parameters.
 684  *
 685  * Returns: %TRUE if the level and profile could be set, %FALSE otherwise.
 686  */
 687 gboolean
 688 gst_codec_utils_h264_caps_set_level_and_profile (GstCaps * caps,
 689     const guint8 * sps, guint len)
 690 {
 691   const gchar *level, *profile;
 692 
 693   g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);
 694   g_return_val_if_fail (GST_CAPS_IS_SIMPLE (caps), FALSE);
 695   g_return_val_if_fail (GST_SIMPLE_CAPS_HAS_NAME (caps, &quot;video/x-h264&quot;), FALSE);
 696   g_return_val_if_fail (sps != NULL, FALSE);
 697 
 698   level = gst_codec_utils_h264_get_level (sps, len);
 699 
 700   if (level != NULL)
 701     gst_caps_set_simple (caps, &quot;level&quot;, G_TYPE_STRING, level, NULL);
 702 
 703   profile = gst_codec_utils_h264_get_profile (sps, len);
 704 
 705   if (profile != NULL)
 706     gst_caps_set_simple (caps, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);
 707 
 708   GST_LOG (&quot;profile : %s&quot;, (profile) ? profile : &quot;---&quot;);
 709   GST_LOG (&quot;level   : %s&quot;, (level) ? level : &quot;---&quot;);
 710 
 711   return (level != NULL &amp;&amp; profile != NULL);
 712 }
 713 
 714 /**
 715  * gst_codec_utils_h265_get_profile:
 716  * @profile_tier_level: (array length=len): Pointer to the profile_tier_level
 717  *   structure for the stream.
 718  * @len: Length of the data available in @profile_tier_level
 719  *
 720  * Converts the profile indication (general_profile_idc) in the stream&#39;s
 721  * profile_level_tier structure into a string. The profile_tier_level is
 722  * expected to have the following format, as defined in the H.265
 723  * specification. The profile_tier_level is viewed as a bitstream here,
 724  * with bit 0 being the most significant bit of the first byte.
 725  *
 726  * * Bit 0:1   - general_profile_space
 727  * * Bit 2     - general_tier_flag
 728  * * Bit 3:7   - general_profile_idc
 729  * * Bit 8:39  - gernal_profile_compatibility_flags
 730  * * Bit 40    - general_progressive_source_flag
 731  * * Bit 41    - general_interlaced_source_flag
 732  * * Bit 42    - general_non_packed_constraint_flag
 733  * * Bit 43    - general_frame_only_constraint_flag
 734  * * Bit 44:87 - general_reserved_zero_44bits
 735  * * Bit 88:95 - general_level_idc
 736  *
 737  * Returns: The profile as a const string, or %NULL if there is an error.
 738  *
<a name="26" id="anc26"></a><span class="line-modified"> 739  * Since 1.4</span>
 740  */
 741 const gchar *
 742 gst_codec_utils_h265_get_profile (const guint8 * profile_tier_level, guint len)
 743 {
 744   const gchar *profile = NULL;
 745   gint profile_idc;
 746 
 747   g_return_val_if_fail (profile_tier_level != NULL, NULL);
 748 
 749   if (len &lt; 2)
 750     return NULL;
 751 
 752   GST_MEMDUMP (&quot;ProfileTierLevel&quot;, profile_tier_level, len);
 753 
 754   profile_idc = (profile_tier_level[0] &amp; 0x1f);
 755 
 756   if (profile_idc == 1)
 757     profile = &quot;main&quot;;
 758   else if (profile_idc == 2)
 759     profile = &quot;main-10&quot;;
 760   else if (profile_idc == 3)
 761     profile = &quot;main-still-picture&quot;;
 762   else
 763     profile = NULL;
 764 
 765   return profile;
 766 }
 767 
 768 /**
 769  * gst_codec_utils_h265_get_tier:
 770  * @profile_tier_level: (array length=len): Pointer to the profile_tier_level
 771  *   for the stream.
 772  * @len: Length of the data available in @profile_tier_level.
 773  *
 774  * Converts the tier indication (general_tier_flag) in the stream&#39;s
 775  * profile_tier_level structure into a string. The profile_tier_level
 776  * is expected to have the same format as for gst_codec_utils_h264_get_profile().
 777  *
 778  * Returns: The tier as a const string, or %NULL if there is an error.
 779  *
<a name="27" id="anc27"></a><span class="line-modified"> 780  * Since 1.4</span>
 781  */
 782 const gchar *
 783 gst_codec_utils_h265_get_tier (const guint8 * profile_tier_level, guint len)
 784 {
 785   const gchar *tier = NULL;
 786   gint tier_flag = 0;
 787 
 788   g_return_val_if_fail (profile_tier_level != NULL, NULL);
 789 
 790   if (len &lt; 1)
 791     return NULL;
 792 
 793   GST_MEMDUMP (&quot;ProfileTierLevel&quot;, profile_tier_level, len);
 794 
 795   tier_flag = (profile_tier_level[0] &amp; 0x20) &gt;&gt; 5;
 796 
 797   if (tier_flag)
 798     tier = &quot;high&quot;;
 799   else
 800     tier = &quot;main&quot;;
 801 
 802   return tier;
 803 }
 804 
 805 /**
 806  * gst_codec_utils_h265_get_level:
 807  * @profile_tier_level: (array length=len): Pointer to the profile_tier_level
 808  *   for the stream
 809  * @len: Length of the data available in @profile_tier_level.
 810  *
 811  * Converts the level indication (general_level_idc) in the stream&#39;s
 812  * profile_tier_level structure into a string. The profiel_tier_level is
 813  * expected to have the same format as for gst_codec_utils_h264_get_profile().
 814  *
 815  * Returns: The level as a const string, or %NULL if there is an error.
 816  *
<a name="28" id="anc28"></a><span class="line-modified"> 817  * Since 1.4</span>
 818  */
 819 const gchar *
 820 gst_codec_utils_h265_get_level (const guint8 * profile_tier_level, guint len)
 821 {
 822   g_return_val_if_fail (profile_tier_level != NULL, NULL);
 823 
 824   if (len &lt; 12)
 825     return NULL;
 826 
 827   GST_MEMDUMP (&quot;ProfileTierLevel&quot;, profile_tier_level, len);
 828 
 829   if (profile_tier_level[11] == 0)
 830     return NULL;
 831   else if (profile_tier_level[11] % 30 == 0)
 832     return digit_to_string (profile_tier_level[11] / 30);
 833   else {
 834     switch (profile_tier_level[11]) {
 835       case 63:
 836         return &quot;2.1&quot;;
 837         break;
 838       case 93:
 839         return &quot;3.1&quot;;
 840         break;
 841       case 123:
 842         return &quot;4.1&quot;;
 843         break;
 844       case 153:
 845         return &quot;5.1&quot;;
 846         break;
 847       case 156:
 848         return &quot;5.2&quot;;
 849         break;
 850       case 183:
 851         return &quot;6.1&quot;;
 852         break;
 853       case 186:
 854         return &quot;6.2&quot;;
 855         break;
 856       default:
 857         return NULL;
 858     }
 859   }
 860 }
 861 
 862 /**
 863  * gst_codec_utils_h265_get_level_idc:
 864  * @level: A level string from caps
 865  *
 866  * Transform a level string from the caps into the level_idc
 867  *
 868  * Returns: the level_idc or 0 if the level is unknown
 869  *
<a name="29" id="anc29"></a><span class="line-modified"> 870  * Since 1.4</span>
 871  */
 872 guint8
 873 gst_codec_utils_h265_get_level_idc (const gchar * level)
 874 {
 875   g_return_val_if_fail (level != NULL, 0);
 876 
 877   if (!strcmp (level, &quot;1&quot;))
 878     return 30;
 879   else if (!strcmp (level, &quot;2&quot;))
 880     return 60;
 881   else if (!strcmp (level, &quot;2.1&quot;))
 882     return 63;
 883   else if (!strcmp (level, &quot;3&quot;))
 884     return 90;
 885   else if (!strcmp (level, &quot;3.1&quot;))
 886     return 93;
 887   else if (!strcmp (level, &quot;4&quot;))
 888     return 120;
 889   else if (!strcmp (level, &quot;4.1&quot;))
 890     return 123;
 891   else if (!strcmp (level, &quot;5&quot;))
 892     return 150;
 893   else if (!strcmp (level, &quot;5.1&quot;))
 894     return 153;
 895   else if (!strcmp (level, &quot;5.2&quot;))
 896     return 156;
 897   else if (!strcmp (level, &quot;6&quot;))
 898     return 180;
 899   else if (!strcmp (level, &quot;6.1&quot;))
 900     return 183;
 901   else if (!strcmp (level, &quot;6.2&quot;))
 902     return 186;
 903 
 904   GST_WARNING (&quot;Invalid level %s&quot;, level);
 905   return 0;
 906 }
 907 
 908 /**
 909  * gst_codec_utils_h265_caps_set_level_tier_and_profile:
 910  * @caps: the #GstCaps to which the level, tier and profile are to be added
 911  * @profile_tier_level: (array length=len): Pointer to the profile_tier_level
 912  *   struct
 913  * @len: Length of the data available in @profile_tier_level.
 914  *
 915  * Sets the level, tier and profile in @caps if it can be determined from
 916  * @profile_tier_level. See gst_codec_utils_h265_get_level(),
 917  * gst_codec_utils_h265_get_tier() and gst_codec_utils_h265_get_profile()
 918  * for more details on the parameters.
 919  *
 920  * Returns: %TRUE if the level, tier, profile could be set, %FALSE otherwise.
 921  *
<a name="30" id="anc30"></a><span class="line-modified"> 922  * Since 1.4</span>
 923  */
 924 gboolean
 925 gst_codec_utils_h265_caps_set_level_tier_and_profile (GstCaps * caps,
 926     const guint8 * profile_tier_level, guint len)
 927 {
 928   const gchar *level, *tier, *profile;
 929 
 930   g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);
 931   g_return_val_if_fail (GST_CAPS_IS_SIMPLE (caps), FALSE);
 932   g_return_val_if_fail (GST_SIMPLE_CAPS_HAS_NAME (caps, &quot;video/x-h265&quot;), FALSE);
 933   g_return_val_if_fail (profile_tier_level != NULL, FALSE);
 934 
 935   level = gst_codec_utils_h265_get_level (profile_tier_level, len);
 936   if (level != NULL)
 937     gst_caps_set_simple (caps, &quot;level&quot;, G_TYPE_STRING, level, NULL);
 938 
 939   tier = gst_codec_utils_h265_get_tier (profile_tier_level, len);
 940   if (tier != NULL)
 941     gst_caps_set_simple (caps, &quot;tier&quot;, G_TYPE_STRING, tier, NULL);
 942 
 943   profile = gst_codec_utils_h265_get_profile (profile_tier_level, len);
 944   if (profile != NULL)
 945     gst_caps_set_simple (caps, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);
 946 
 947   GST_LOG (&quot;profile : %s&quot;, (profile) ? profile : &quot;---&quot;);
 948   GST_LOG (&quot;tier    : %s&quot;, (tier) ? tier : &quot;---&quot;);
 949   GST_LOG (&quot;level   : %s&quot;, (level) ? level : &quot;---&quot;);
 950 
 951   return (level != NULL &amp;&amp; tier != NULL &amp;&amp; profile != NULL);
 952 }
 953 
 954 /**
 955  * gst_codec_utils_mpeg4video_get_profile:
 956  * @vis_obj_seq: (array length=len): Pointer to the visual object
 957  *   sequence for the stream.
 958  * @len: Length of the data available in @sps.
 959  *
 960  * Converts the profile indication in the stream&#39;s visual object sequence into
 961  * a string. @vis_obj_seq is expected to be the data following the visual
 962  * object sequence start code. Only the first byte
 963  * (profile_and_level_indication) is used.
 964  *
 965  * Returns: The profile as a const string, or NULL if there is an error.
 966  */
 967 const gchar *
 968 gst_codec_utils_mpeg4video_get_profile (const guint8 * vis_obj_seq, guint len)
 969 {
 970   /* The profile/level codes are from 14496-2, table G-1, and the Wireshark
 971    * sources: epan/dissectors/packet-mp4ves.c */
 972 
 973   /* These are a direct mapping from the integer profile id -&gt; string. Profiles
 974    * 0x6, 0xe and 0xf can correspond to more than one profile depending on the
 975    * second 4 bits of vis_obj_seq[0], so they are handled separately. */
 976   static const char *profiles[] = { &quot;simple&quot;, &quot;simple-scalable&quot;, &quot;core&quot;,
 977     &quot;main&quot;, &quot;n-bit&quot;, &quot;scalable&quot;, NULL, &quot;basic-animated-texture&quot;, &quot;hybrid&quot;,
 978     &quot;advanced-real-time-simple&quot;, &quot;core-scalable&quot;, &quot;advanced-coding-efficiency&quot;,
 979     &quot;advanced-core&quot;, &quot;advanced-scalable-texture&quot;,
 980   };
 981   int profile_id, level_id;
 982 
 983   g_return_val_if_fail (vis_obj_seq != NULL, NULL);
 984 
 985   if (len &lt; 1)
 986     return NULL;
 987 
 988   GST_MEMDUMP (&quot;VOS&quot;, vis_obj_seq, len);
 989 
 990   profile_id = vis_obj_seq[0] &gt;&gt; 4;
 991   level_id = vis_obj_seq[0] &amp; 0xf;
 992 
 993   GST_LOG (&quot;profile_id = %d, level_id = %d&quot;, profile_id, level_id);
 994 
 995   if (profile_id != 6 &amp;&amp; profile_id &lt; 0xe)
 996     return profiles[profile_id];
 997 
 998   if (profile_id != 0xf &amp;&amp; level_id == 0)
 999     return NULL;
1000 
1001   switch (profile_id) {
1002     case 0x6:
1003       if (level_id &lt; 3)
1004         return &quot;simple-face&quot;;
1005       else if (level_id &lt; 5)
1006         return &quot;simple-fba&quot;;
1007       break;
1008 
1009     case 0xe:
1010       if (level_id &lt; 5)
1011         return &quot;simple-studio&quot;;
1012       else if (level_id &lt; 9)
1013         return &quot;core-studio&quot;;
1014       break;
1015 
1016     case 0xf:
1017       if (level_id &lt; 6)
1018         return &quot;advanced-simple&quot;;
1019       else if (level_id &gt; 7 &amp;&amp; level_id &lt; 0xe)
1020         return &quot;fine-granularity-scalable&quot;;
1021       break;
1022   }
1023 
1024   return NULL;
1025 }
1026 
1027 /**
1028  * gst_codec_utils_mpeg4video_get_level:
1029  * @vis_obj_seq: (array length=len): Pointer to the visual object
1030  *   sequence for the stream.
1031  * @len: Length of the data available in @sps.
1032  *
1033  * Converts the level indication in the stream&#39;s visual object sequence into
1034  * a string. @vis_obj_seq is expected to be the data following the visual
1035  * object sequence start code. Only the first byte
1036  * (profile_and_level_indication) is used.
1037  *
1038  * Returns: The level as a const string, or NULL if there is an error.
1039  */
1040 const gchar *
1041 gst_codec_utils_mpeg4video_get_level (const guint8 * vis_obj_seq, guint len)
1042 {
1043   /* The profile/level codes are from 14496-2, table G-1, the Wireshark
1044    * sources: epan/dissectors/packet-mp4ves.c and the Xvid Sources:
1045    * src/xvid.h.
1046    * Levels 4a and 5 for SP were added in Amendment 2, level 6 in Amendment 4
1047    * (see Xvid sources vfw/config.c)
1048    *
1049    * Each profile has a different maximum level it defines. Some of them still
1050    * need special case handling, because not all levels start from 1, and the
1051    * Simple profile defines an intermediate level as well. */
1052   static const int level_max[] = { 6, 2, 2, 4, 2, 1, 2, 2, 2, 4, 3, 4, 2, 3, 4,
1053     5
1054   };
1055   int profile_id, level_id;
1056 
1057   g_return_val_if_fail (vis_obj_seq != NULL, NULL);
1058 
1059   if (len &lt; 1)
1060     return NULL;
1061 
1062   GST_MEMDUMP (&quot;VOS&quot;, vis_obj_seq, len);
1063 
1064   profile_id = vis_obj_seq[0] &gt;&gt; 4;
1065   level_id = vis_obj_seq[0] &amp; 0xf;
1066 
1067   GST_LOG (&quot;profile_id = %d, level_id = %d&quot;, profile_id, level_id);
1068 
1069   if (profile_id != 0xf &amp;&amp; level_id == 0)
1070     return NULL;
1071 
1072   /* Let&#39;s do some validation of the level */
1073   switch (profile_id) {
1074     case 0x3:
1075       if (level_id == 1)
1076         return NULL;
1077       break;
1078 
1079     case 0x4:
1080       if (level_id != 2)
1081         return NULL;
1082       break;
1083 
1084     case 0x6:
1085       if (level_id &gt; 5)
1086         return NULL;
1087       break;
1088 
1089     case 0xe:
1090       if (level_id &gt; 9)
1091         return NULL;
1092       break;
1093 
1094     case 0xf:
1095       if (level_id == 6 || level_id == 7 || level_id &gt; 0xd)
1096         return NULL;
1097       break;
1098   }
1099 
1100   if (profile_id == 0 &amp;&amp; level_id == 8)
1101     /* Simple Profile / Level 0 */
1102     return &quot;0&quot;;
1103   else if (profile_id == 0 &amp;&amp; level_id == 9)
1104     /* Simple Profile / Level 0b */
1105     return &quot;0b&quot;;
1106   else if (profile_id == 0 &amp;&amp; level_id == 4)
1107     /* Simple Profile / Level 4a */
1108     return &quot;4a&quot;;
1109   else if (profile_id == 0xf &amp;&amp; level_id &gt; 7)
1110     /* Fine Granularity Scalable Profile */
1111     return digit_to_string (level_id - 8);
1112   else if (level_id &lt;= level_max[profile_id])
1113     /* Levels for all other cases */
1114     return digit_to_string (level_id);
1115 
1116   return NULL;
1117 }
1118 
1119 /**
1120  * gst_codec_utils_mpeg4video_caps_set_level_and_profile:
1121  * @caps: the #GstCaps to which the level and profile are to be added
1122  * @vis_obj_seq: (array length=len): Pointer to the visual object
1123  *   sequence for the stream.
1124  * @len: Length of the data available in @sps.
1125  *
1126  * Sets the level and profile in @caps if it can be determined from
1127  * @vis_obj_seq. See gst_codec_utils_mpeg4video_get_level() and
1128  * gst_codec_utils_mpeg4video_get_profile() for more details on the
1129  * parameters.
1130  *
1131  * Returns: %TRUE if the level and profile could be set, %FALSE otherwise.
1132  */
1133 gboolean
1134 gst_codec_utils_mpeg4video_caps_set_level_and_profile (GstCaps * caps,
1135     const guint8 * vis_obj_seq, guint len)
1136 {
1137   const gchar *profile, *level;
1138 
1139   g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);
1140   g_return_val_if_fail (GST_CAPS_IS_SIMPLE (caps), FALSE);
1141   g_return_val_if_fail (vis_obj_seq != NULL, FALSE);
1142 
1143   profile = gst_codec_utils_mpeg4video_get_profile (vis_obj_seq, len);
1144 
1145   if (profile != NULL)
1146     gst_caps_set_simple (caps, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);
1147 
1148   level = gst_codec_utils_mpeg4video_get_level (vis_obj_seq, len);
1149 
1150   if (level != NULL)
1151     gst_caps_set_simple (caps, &quot;level&quot;, G_TYPE_STRING, level, NULL);
1152 
1153   GST_LOG (&quot;profile : %s&quot;, (profile) ? profile : &quot;---&quot;);
1154   GST_LOG (&quot;level   : %s&quot;, (level) ? level : &quot;---&quot;);
1155 
1156   return (profile != NULL &amp;&amp; level != NULL);
1157 }
1158 
1159 #ifndef GSTREAMER_LITE
1160 /**
1161  * gst_codec_utils_opus_parse_caps:
1162  * @caps: the #GstCaps to parse the data from
1163  * @rate: (out): the sample rate
1164  * @channels: (out): the number of channels
1165  * @channel_mapping_family: (out): the channel mapping family
1166  * @stream_count: (out): the number of independent streams
1167  * @coupled_count: (out): the number of stereo streams
1168  * @channel_mapping: (out) (array fixed-size=256): the mapping between the streams
1169  *
1170  * Parses Opus caps and fills the different fields with defaults if possible.
1171  *
1172  * Returns: %TRUE if parsing was successful, %FALSE otherwise.
1173  *
1174  * Since: 1.8
1175  */
1176 gboolean
1177 gst_codec_utils_opus_parse_caps (GstCaps * caps,
1178     guint32 * rate,
1179     guint8 * channels,
1180     guint8 * channel_mapping_family,
1181     guint8 * stream_count, guint8 * coupled_count, guint8 channel_mapping[256])
1182 {
1183   GstStructure *s;
1184   gint c, f, sc, cc;
1185   const GValue *va, *v;
1186 
1187   g_return_val_if_fail (caps != NULL, FALSE);
1188   g_return_val_if_fail (gst_caps_is_fixed (caps), FALSE);
1189   g_return_val_if_fail (!gst_caps_is_empty (caps), FALSE);
1190 
1191   s = gst_caps_get_structure (caps, 0);
1192 
1193   g_return_val_if_fail (gst_structure_has_name (s, &quot;audio/x-opus&quot;), FALSE);
1194   g_return_val_if_fail (gst_structure_has_field_typed (s,
1195           &quot;channel-mapping-family&quot;, G_TYPE_INT), FALSE);
1196 
1197   if (rate) {
1198     gint r;
1199 
1200     if (gst_structure_get_int (s, &quot;rate&quot;, &amp;r))
1201       *rate = r;
1202     else
1203       *rate = 48000;
1204   }
1205 
1206   gst_structure_get_int (s, &quot;channel-mapping-family&quot;, &amp;f);
1207   if (channel_mapping_family)
1208     *channel_mapping_family = f;
1209 
1210   if (!gst_structure_get_int (s, &quot;channels&quot;, &amp;c)) {
1211     if (f == 0)
1212       c = 2;
1213     else
1214       return FALSE;
1215   }
1216 
1217   if (channels)
1218     *channels = c;
1219 
1220   /* RTP mapping */
1221   if (f == 0) {
1222     if (c &gt; 2)
1223       return FALSE;
1224 
1225     if (stream_count)
1226       *stream_count = 1;
1227     if (coupled_count)
1228       *coupled_count = c == 2 ? 1 : 0;
1229 
1230     if (channel_mapping) {
1231       channel_mapping[0] = 0;
1232       channel_mapping[1] = 1;
1233     }
1234 
1235     return TRUE;
1236   }
1237 
1238   if (!gst_structure_get_int (s, &quot;stream-count&quot;, &amp;sc))
1239     return FALSE;
1240   if (stream_count)
1241     *stream_count = sc;
1242 
1243   if (!gst_structure_get_int (s, &quot;coupled-count&quot;, &amp;cc))
1244     return FALSE;
1245   if (coupled_count)
1246     *coupled_count = cc;
1247 
1248   va = gst_structure_get_value (s, &quot;channel-mapping&quot;);
1249   if (!va || !G_VALUE_HOLDS (va, GST_TYPE_ARRAY))
1250     return FALSE;
1251 
1252   if (gst_value_array_get_size (va) != c)
1253     return FALSE;
1254 
1255   if (channel_mapping) {
1256     gint i;
1257 
1258     for (i = 0; i &lt; c; i++) {
1259       gint cm;
1260 
1261       v = gst_value_array_get_value (va, i);
1262 
1263       if (!G_VALUE_HOLDS (v, G_TYPE_INT))
1264         return FALSE;
1265 
1266       cm = g_value_get_int (v);
1267       if (cm &lt; 0 || cm &gt; 255)
1268         return FALSE;
1269 
1270       channel_mapping[i] = cm;
1271     }
1272   }
1273 
1274   return TRUE;
1275 }
1276 
1277 /**
1278  * gst_codec_utils_opus_create_caps:
1279  * @rate: the sample rate
1280  * @channels: the number of channels
1281  * @channel_mapping_family: the channel mapping family
1282  * @stream_count: the number of independent streams
1283  * @coupled_count: the number of stereo streams
1284  * @channel_mapping: (allow-none) (array): the mapping between the streams
1285  *
1286  * Creates Opus caps from the given parameters.
1287  *
1288  * Returns: The #GstCaps, or %NULL if the parameters would lead to
1289  * invalid Opus caps.
1290  *
1291  * Since: 1.8
1292  */
1293 GstCaps *
1294 gst_codec_utils_opus_create_caps (guint32 rate,
1295     guint8 channels,
1296     guint8 channel_mapping_family,
1297     guint8 stream_count, guint8 coupled_count, const guint8 * channel_mapping)
1298 {
1299   GstCaps *caps = NULL;
1300   GValue va = G_VALUE_INIT;
1301   GValue v = G_VALUE_INIT;
1302   gint i;
1303 
1304   if (rate == 0)
1305     rate = 48000;
1306 
1307   if (channel_mapping_family == 0) {
1308     if (channels &gt; 2) {
1309       GST_ERROR (&quot;Invalid channels count for channel_mapping_family 0: %d&quot;,
1310           channels);
1311       goto done;
1312     }
1313 
1314     if (stream_count &gt; 1) {
1315       GST_ERROR (&quot;Invalid stream count for channel_mapping_family 0: %d&quot;,
1316           stream_count);
1317       goto done;
1318     }
1319 
1320     if (coupled_count &gt; 1) {
1321       GST_ERROR (&quot;Invalid coupled count for channel_mapping_family 0: %d&quot;,
1322           coupled_count);
1323       goto done;
1324     }
1325 
1326     if (channels == 0)
1327       channels = 2;
1328 
1329     if (stream_count == 0)
1330       stream_count = 1;
1331 
1332     if (coupled_count == 0)
1333       coupled_count = channels == 2 ? 1 : 0;
1334 
1335     return gst_caps_new_simple (&quot;audio/x-opus&quot;,
1336         &quot;rate&quot;, G_TYPE_INT, rate,
1337         &quot;channels&quot;, G_TYPE_INT, channels,
1338         &quot;channel-mapping-family&quot;, G_TYPE_INT, channel_mapping_family,
1339         &quot;stream-count&quot;, G_TYPE_INT, stream_count,
1340         &quot;coupled-count&quot;, G_TYPE_INT, coupled_count, NULL);
1341   }
1342 
1343   if (channels == 0) {
1344     GST_ERROR (&quot;Invalid channels count: %d&quot;, channels);
1345     goto done;
1346   }
1347 
1348   if (stream_count == 0) {
1349     GST_ERROR (&quot;Invalid stream count: %d&quot;, stream_count);
1350     goto done;
1351   }
1352 
1353   if (coupled_count &gt; stream_count) {
1354     GST_ERROR (&quot;Coupled count %d &gt; stream count: %d&quot;, coupled_count,
1355         stream_count);
1356     goto done;
1357   }
1358 
1359   if (channel_mapping == NULL) {
1360     GST_ERROR
1361         (&quot;A non NULL channel-mapping is needed for channel_mapping_family != 0&quot;);
1362     goto done;
1363   }
1364 
1365   caps = gst_caps_new_simple (&quot;audio/x-opus&quot;,
1366       &quot;rate&quot;, G_TYPE_INT, rate,
1367       &quot;channels&quot;, G_TYPE_INT, channels,
1368       &quot;channel-mapping-family&quot;, G_TYPE_INT, channel_mapping_family,
1369       &quot;stream-count&quot;, G_TYPE_INT, stream_count,
1370       &quot;coupled-count&quot;, G_TYPE_INT, coupled_count, NULL);
1371 
1372   g_value_init (&amp;va, GST_TYPE_ARRAY);
1373   g_value_init (&amp;v, G_TYPE_INT);
1374   for (i = 0; i &lt; channels; i++) {
1375     g_value_set_int (&amp;v, channel_mapping[i]);
1376     gst_value_array_append_value (&amp;va, &amp;v);
1377   }
1378   gst_structure_set_value (gst_caps_get_structure (caps, 0), &quot;channel-mapping&quot;,
1379       &amp;va);
1380   g_value_unset (&amp;va);
1381   g_value_unset (&amp;v);
1382 
1383 done:
1384   return caps;
1385 }
1386 
1387 /*
1388  * (really really) FIXME: move into core (dixit tpm)
1389  */
1390 /*
1391  * _gst_caps_set_buffer_array:
1392  * @caps: (transfer full): a #GstCaps
1393  * @field: field in caps to set
1394  * @buf: header buffers
1395  *
1396  * Adds given buffers to an array of buffers set as the given @field
1397  * on the given @caps.  List of buffer arguments must be NULL-terminated.
1398  *
1399  * Returns: (transfer full): input caps with a streamheader field added, or NULL
1400  *     if some error occurred
1401  */
1402 static GstCaps *
1403 _gst_caps_set_buffer_array (GstCaps * caps, const gchar * field,
1404     GstBuffer * buf, ...)
1405 {
1406   GstStructure *structure = NULL;
1407   va_list va;
1408   GValue array = { 0 };
1409   GValue value = { 0 };
1410 
1411   g_return_val_if_fail (caps != NULL, NULL);
1412   g_return_val_if_fail (gst_caps_is_fixed (caps), NULL);
1413   g_return_val_if_fail (field != NULL, NULL);
1414 
1415   caps = gst_caps_make_writable (caps);
1416   structure = gst_caps_get_structure (caps, 0);
1417 
1418   g_value_init (&amp;array, GST_TYPE_ARRAY);
1419 
1420   va_start (va, buf);
1421   /* put buffers in a fixed list */
1422   while (buf) {
1423     g_assert (gst_buffer_is_writable (buf));
1424 
1425     /* mark buffer */
1426     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_HEADER);
1427 
1428     g_value_init (&amp;value, GST_TYPE_BUFFER);
1429     buf = gst_buffer_copy (buf);
1430     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_HEADER);
1431     gst_value_set_buffer (&amp;value, buf);
1432     gst_buffer_unref (buf);
1433     gst_value_array_append_value (&amp;array, &amp;value);
1434     g_value_unset (&amp;value);
1435 
1436     buf = va_arg (va, GstBuffer *);
1437   }
1438   va_end (va);
1439 
1440   gst_structure_set_value (structure, field, &amp;array);
1441   g_value_unset (&amp;array);
1442 
1443   return caps;
1444 }
1445 
1446 /**
1447  * gst_codec_utils_opus_create_caps_from_header:
1448  * @header: OpusHead header
1449  * @comments: (allow-none): Comment header or NULL
1450  *
1451  * Creates Opus caps from the given OpusHead @header and comment header
1452  * @comments.
1453  *
1454  * Returns: The #GstCaps.
1455  *
1456  * Since: 1.8
1457  */
1458 GstCaps *
1459 gst_codec_utils_opus_create_caps_from_header (GstBuffer * header,
1460     GstBuffer * comments)
1461 {
1462   GstCaps *caps;
1463   guint32 rate;
1464   guint8 channels;
1465   guint8 channel_mapping_family;
1466   guint8 stream_count;
1467   guint8 coupled_count;
1468   guint8 channel_mapping[256];
1469   GstBuffer *dummy_comments = NULL;
1470 
1471   g_return_val_if_fail (GST_IS_BUFFER (header), NULL);
1472   g_return_val_if_fail (comments == NULL || GST_IS_BUFFER (comments), NULL);
1473 
1474   if (!gst_codec_utils_opus_parse_header (header, &amp;rate, &amp;channels,
1475           &amp;channel_mapping_family, &amp;stream_count, &amp;coupled_count,
1476           channel_mapping, NULL, NULL))
1477     return NULL;
1478 
1479   if (!(caps =
1480           gst_codec_utils_opus_create_caps (rate, channels,
1481               channel_mapping_family, stream_count, coupled_count,
1482               channel_mapping)))
1483     return NULL;
1484 
1485   if (!comments) {
1486     GstTagList *tags = gst_tag_list_new_empty ();
1487     dummy_comments =
1488         gst_tag_list_to_vorbiscomment_buffer (tags, (const guint8 *) &quot;OpusTags&quot;,
1489         8, NULL);
1490     gst_tag_list_unref (tags);
1491   }
1492   _gst_caps_set_buffer_array (caps, &quot;streamheader&quot;, header,
1493       comments ? comments : dummy_comments, NULL);
1494 
1495   if (dummy_comments)
1496     gst_buffer_unref (dummy_comments);
1497 
1498   return caps;
1499 }
1500 
1501 /**
1502  * gst_codec_utils_opus_create_header:
1503  * @rate: the sample rate
1504  * @channels: the number of channels
1505  * @channel_mapping_family: the channel mapping family
1506  * @stream_count: the number of independent streams
1507  * @coupled_count: the number of stereo streams
1508  * @channel_mapping: (allow-none) (array): the mapping between the streams
1509  * @pre_skip: Pre-skip in 48kHz samples or 0
1510  * @output_gain: Output gain or 0
1511  *
1512  * Creates OpusHead header from the given parameters.
1513  *
1514  * Returns: The #GstBuffer containing the OpusHead.
1515  *
1516  * Since: 1.8
1517  */
1518 GstBuffer *
1519 gst_codec_utils_opus_create_header (guint32 rate,
1520     guint8 channels,
1521     guint8 channel_mapping_family,
1522     guint8 stream_count,
1523     guint8 coupled_count,
1524     const guint8 * channel_mapping, guint16 pre_skip, gint16 output_gain)
1525 {
1526   GstBuffer *buffer;
1527   GstByteWriter bw;
1528   gboolean hdl = TRUE;
1529 
1530   if (rate == 0)
1531     rate = 48000;
1532 
1533   if (channel_mapping_family == 0) {
1534     g_return_val_if_fail (channels &lt;= 2, NULL);
1535     if (channels == 0)
1536       channels = 2;
1537 
1538     g_return_val_if_fail (stream_count == 0 || stream_count == 1, NULL);
1539     if (stream_count == 0)
1540       stream_count = 1;
1541 
1542     g_return_val_if_fail (coupled_count == 0 || coupled_count == 1, NULL);
1543     if (coupled_count == 0)
1544       coupled_count = channels == 2 ? 1 : 0;
1545 
1546     channel_mapping = NULL;
1547   } else {
1548     g_return_val_if_fail (channels &gt; 0, NULL);
1549     g_return_val_if_fail (stream_count &gt; 0, NULL);
1550     g_return_val_if_fail (coupled_count &lt;= stream_count, NULL);
1551     g_return_val_if_fail (channel_mapping != NULL, NULL);
1552   }
1553 
1554   gst_byte_writer_init (&amp;bw);
1555   /* See http://wiki.xiph.org/OggOpus */
1556   hdl &amp;= gst_byte_writer_put_data (&amp;bw, (const guint8 *) &quot;OpusHead&quot;, 8);
1557   hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, 0x01); /* version number */
1558   hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, channels);
1559   hdl &amp;= gst_byte_writer_put_uint16_le (&amp;bw, pre_skip);
1560   hdl &amp;= gst_byte_writer_put_uint32_le (&amp;bw, rate);
1561   hdl &amp;= gst_byte_writer_put_uint16_le (&amp;bw, output_gain);
1562   hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, channel_mapping_family);
1563   if (channel_mapping_family &gt; 0) {
1564     hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, stream_count);
1565     hdl &amp;= gst_byte_writer_put_uint8 (&amp;bw, coupled_count);
1566     hdl &amp;= gst_byte_writer_put_data (&amp;bw, channel_mapping, channels);
1567   }
1568 
1569   if (!hdl) {
1570     GST_WARNING (&quot;Error creating header&quot;);
<a name="31" id="anc31"></a>
1571     return NULL;
1572   }
1573 
1574   buffer = gst_byte_writer_reset_and_get_buffer (&amp;bw);
1575   GST_BUFFER_OFFSET (buffer) = 0;
1576   GST_BUFFER_OFFSET_END (buffer) = 0;
1577 
1578   return buffer;
1579 }
1580 
1581 /**
1582  * gst_codec_utils_opus_parse_header:
1583  * @header: the OpusHead #GstBuffer
1584  * @rate: (out): the sample rate
1585  * @channels: (out): the number of channels
1586  * @channel_mapping_family: (out): the channel mapping family
1587  * @stream_count: (out): the number of independent streams
1588  * @coupled_count: (out): the number of stereo streams
1589  * @channel_mapping: (out) (array fixed-size=256): the mapping between the streams
1590  * @pre_skip: (out): Pre-skip in 48kHz samples or 0
1591  * @output_gain: (out): Output gain or 0
1592  *
1593  * Parses the OpusHead header.
1594  *
1595  * Returns: %TRUE if parsing was successful, %FALSE otherwise.
1596  *
1597  * Since: 1.8
1598  */
1599 gboolean
1600 gst_codec_utils_opus_parse_header (GstBuffer * header,
1601     guint32 * rate,
1602     guint8 * channels,
1603     guint8 * channel_mapping_family,
1604     guint8 * stream_count,
1605     guint8 * coupled_count,
1606     guint8 channel_mapping[256], guint16 * pre_skip, gint16 * output_gain)
1607 {
1608   GstByteReader br;
1609   GstMapInfo map;
1610   gboolean ret = TRUE;
1611   guint8 c, f, version;
1612 
1613   g_return_val_if_fail (GST_IS_BUFFER (header), FALSE);
1614   g_return_val_if_fail (gst_buffer_get_size (header) &gt;= 19, FALSE);
1615 
1616   if (!gst_buffer_map (header, &amp;map, GST_MAP_READ))
1617     return FALSE;
1618   gst_byte_reader_init (&amp;br, map.data, map.size);
1619   /* See http://wiki.xiph.org/OggOpus */
1620   if (memcmp (gst_byte_reader_get_data_unchecked (&amp;br, 8), &quot;OpusHead&quot;, 8) != 0) {
1621     ret = FALSE;
1622     goto done;
1623   }
1624   version = gst_byte_reader_get_uint8_unchecked (&amp;br);
1625   if (version == 0x00)
1626     GST_ERROR (&quot;Opus Header version is wrong, should be 0x01 and not 0x00&quot;);
1627   else if (version != 0x01) {
1628     ret = FALSE;
1629     goto done;
1630   }
1631 
1632   c = gst_byte_reader_get_uint8_unchecked (&amp;br);
1633   if (channels)
1634     *channels = c;
1635 
1636   if (pre_skip)
1637     *pre_skip = gst_byte_reader_get_uint16_le_unchecked (&amp;br);
1638   else
1639     gst_byte_reader_skip_unchecked (&amp;br, 2);
1640 
1641   if (rate)
1642     *rate = gst_byte_reader_get_uint32_le_unchecked (&amp;br);
1643   else
1644     gst_byte_reader_skip_unchecked (&amp;br, 4);
1645 
1646   if (output_gain)
1647     *output_gain = gst_byte_reader_get_uint16_le_unchecked (&amp;br);
1648   else
1649     gst_byte_reader_skip_unchecked (&amp;br, 2);
1650 
1651   f = gst_byte_reader_get_uint8_unchecked (&amp;br);
1652   if (channel_mapping_family)
1653     *channel_mapping_family = f;
1654   if (f == 0 &amp;&amp; c &lt;= 2) {
1655     if (stream_count)
1656       *stream_count = 1;
1657     if (coupled_count)
1658       *coupled_count = c == 2 ? 1 : 0;
1659     if (channel_mapping) {
1660       channel_mapping[0] = 0;
1661       channel_mapping[1] = 1;
1662     }
1663 
1664     goto done;
1665   }
1666 
1667   if (gst_byte_reader_get_remaining (&amp;br) &lt; 2 + c) {
1668     ret = FALSE;
1669     goto done;
1670   }
1671 
1672   if (stream_count)
1673     *stream_count = gst_byte_reader_get_uint8_unchecked (&amp;br);
1674   else
1675     gst_byte_reader_skip_unchecked (&amp;br, 1);
1676 
1677   if (coupled_count)
1678     *coupled_count = gst_byte_reader_get_uint8_unchecked (&amp;br);
1679   else
1680     gst_byte_reader_skip_unchecked (&amp;br, 1);
1681 
1682   if (channel_mapping)
1683     memcpy (channel_mapping, gst_byte_reader_get_data_unchecked (&amp;br, c), c);
1684 
1685 done:
1686   gst_buffer_unmap (header, &amp;map);
1687 
1688   return ret;
1689 }
1690 #endif // GSTREAMER_LITE
<a name="32" id="anc32"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="32" type="hidden" />
</body>
</html>