diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gtype.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gtype.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gtype.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gtype.c
@@ -37,11 +37,11 @@
 #ifdef G_OS_WIN32
 #include <windows.h>
 #endif
 
 #ifdef  G_ENABLE_DEBUG
-#define IF_DEBUG(debug_type)    if (_g_type_debug_flags & G_TYPE_DEBUG_ ## debug_type)
+#define IF_DEBUG(debug_type)  if (_g_type_debug_flags & G_TYPE_DEBUG_ ## debug_type)
 #endif
 
 /**
  * SECTION:gtype
  * @short_description: The GLib Runtime type identification and
@@ -98,21 +98,21 @@
  *
  * LOCKING:
  * lock handling issues when calling static functions are indicated by
  * uppercase letter postfixes, all static functions have to have
  * one of the below postfixes:
- * - _I:    [Indifferent about locking]
+ * - _I:  [Indifferent about locking]
  *   function doesn't care about locks at all
- * - _U:    [Unlocked invocation]
+ * - _U:  [Unlocked invocation]
  *   no read or write lock has to be held across function invocation
  *   (locks may be acquired and released during invocation though)
- * - _L:    [Locked invocation]
+ * - _L:  [Locked invocation]
  *   a write lock or more than 0 read locks have to be held across
  *   function invocation
- * - _W:    [Write-locked invocation]
+ * - _W:  [Write-locked invocation]
  *   a write lock has to be held across function invocation
- * - _Wm:   [Write-locked invocation, mutatable]
+ * - _Wm: [Write-locked invocation, mutatable]
  *   like _W, but the write lock might be released and reacquired
  *   during invocation, watch your pointers
  * - _WmREC:    [Write-locked invocation, mutatable, recursive]
  *   like _Wm, but also acquires recursive mutex class_init_rec_mutex
  */
@@ -138,16 +138,16 @@
 }G_STMT_END
 #define g_assert_type_system_initialized() \
   g_assert (static_quark_type_flags)
 
 #define TYPE_FUNDAMENTAL_FLAG_MASK (G_TYPE_FLAG_CLASSED | \
-                    G_TYPE_FLAG_INSTANTIATABLE | \
-                    G_TYPE_FLAG_DERIVABLE | \
-                    G_TYPE_FLAG_DEEP_DERIVABLE)
-#define TYPE_FLAG_MASK         (G_TYPE_FLAG_ABSTRACT | G_TYPE_FLAG_VALUE_ABSTRACT)
+            G_TYPE_FLAG_INSTANTIATABLE | \
+            G_TYPE_FLAG_DERIVABLE | \
+            G_TYPE_FLAG_DEEP_DERIVABLE)
+#define TYPE_FLAG_MASK       (G_TYPE_FLAG_ABSTRACT | G_TYPE_FLAG_VALUE_ABSTRACT)
 #define SIZEOF_FUNDAMENTAL_INFO    ((gssize) MAX (MAX (sizeof (GTypeFundamentalInfo), \
-                               sizeof (gpointer)), \
+                   sizeof (gpointer)), \
                                                   sizeof (glong)))
 
 /* The 2*sizeof(size_t) alignment here is borrowed from
  * GNU libc, so it should be good most everywhere.
  * It is more conservative than is needed on some 64-bit
@@ -173,34 +173,34 @@
 typedef struct _IFaceEntry      IFaceEntry;
 typedef struct _IFaceHolder IFaceHolder;
 
 
 /* --- prototypes --- */
-static inline GTypeFundamentalInfo* type_node_fundamental_info_I    (TypeNode       *node);
-static        void          type_add_flags_W        (TypeNode       *node,
-                                     GTypeFlags      flags);
-static        void          type_data_make_W        (TypeNode       *node,
-                                     const GTypeInfo    *info,
-                                     const GTypeValueTable  *value_table);
-static inline void          type_data_ref_Wm        (TypeNode       *node);
-static inline void          type_data_unref_U               (TypeNode       *node,
-                                     gboolean        uncached);
-static void             type_data_last_unref_Wm     (TypeNode *              node,
-                                     gboolean        uncached);
-static inline gpointer          type_get_qdata_L        (TypeNode       *node,
-                                     GQuark          quark);
-static inline void          type_set_qdata_W        (TypeNode       *node,
-                                     GQuark          quark,
-                                     gpointer        data);
-static IFaceHolder*         type_iface_peek_holder_L    (TypeNode       *iface,
-                                     GType           instance_type);
+static inline GTypeFundamentalInfo* type_node_fundamental_info_I  (TypeNode   *node);
+static        void      type_add_flags_W    (TypeNode   *node,
+                   GTypeFlags    flags);
+static        void      type_data_make_W    (TypeNode   *node,
+                   const GTypeInfo  *info,
+                   const GTypeValueTable  *value_table);
+static inline void      type_data_ref_Wm    (TypeNode   *node);
+static inline void      type_data_unref_U               (TypeNode   *node,
+                   gboolean    uncached);
+static void       type_data_last_unref_Wm   (TypeNode *              node,
+                   gboolean    uncached);
+static inline gpointer      type_get_qdata_L    (TypeNode   *node,
+                   GQuark      quark);
+static inline void      type_set_qdata_W    (TypeNode   *node,
+                   GQuark      quark,
+                   gpointer    data);
+static IFaceHolder*     type_iface_peek_holder_L  (TypeNode   *iface,
+                   GType       instance_type);
 static gboolean                         type_iface_vtable_base_init_Wm  (TypeNode               *iface,
                                                                          TypeNode               *node);
 static void                             type_iface_vtable_iface_init_Wm (TypeNode               *iface,
                                                                          TypeNode               *node);
-static gboolean             type_node_is_a_L        (TypeNode       *node,
-                                     TypeNode       *iface_node);
+static gboolean       type_node_is_a_L    (TypeNode   *node,
+                   TypeNode   *iface_node);
 
 
 /* --- enumeration --- */
 
 /* The InitState enumeration is used to track the progress of initializing
@@ -229,48 +229,48 @@
   guint        n_children; /* writable with lock */
   guint        n_supers : 8;
   guint        n_prerequisites : 9;
   guint        is_classed : 1;
   guint        is_instantiatable : 1;
-  guint        mutatable_check_cache : 1;   /* combines some common path checks */
+  guint        mutatable_check_cache : 1; /* combines some common path checks */
   GType       *children; /* writable with lock */
   TypeData * volatile data;
   GQuark       qname;
   GData       *global_gdata;
   union {
-    GAtomicArray iface_entries;     /* for !iface types */
+    GAtomicArray iface_entries;   /* for !iface types */
     GAtomicArray offsets;
   } _prot;
   GType       *prerequisites;
   GType        supers[1]; /* flexible array */
 };
 
-#define SIZEOF_BASE_TYPE_NODE()         (G_STRUCT_OFFSET (TypeNode, supers))
-#define MAX_N_SUPERS                (255)
-#define MAX_N_CHILDREN              (G_MAXUINT)
-#define MAX_N_INTERFACES            (255) /* Limited by offsets being 8 bits */
-#define MAX_N_PREREQUISITES         (511)
-#define NODE_TYPE(node)             (node->supers[0])
-#define NODE_PARENT_TYPE(node)          (node->supers[1])
-#define NODE_FUNDAMENTAL_TYPE(node)     (node->supers[node->n_supers])
-#define NODE_NAME(node)             (g_quark_to_string (node->qname))
+#define SIZEOF_BASE_TYPE_NODE()     (G_STRUCT_OFFSET (TypeNode, supers))
+#define MAX_N_SUPERS        (255)
+#define MAX_N_CHILDREN        (G_MAXUINT)
+#define MAX_N_INTERFACES      (255) /* Limited by offsets being 8 bits */
+#define MAX_N_PREREQUISITES     (511)
+#define NODE_TYPE(node)       (node->supers[0])
+#define NODE_PARENT_TYPE(node)      (node->supers[1])
+#define NODE_FUNDAMENTAL_TYPE(node)   (node->supers[node->n_supers])
+#define NODE_NAME(node)       (g_quark_to_string (node->qname))
 #define NODE_REFCOUNT(node)                     ((guint) g_atomic_int_get ((int *) &(node)->ref_count))
-#define NODE_IS_BOXED(node)         (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_BOXED)
-#define NODE_IS_IFACE(node)         (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_INTERFACE)
-#define CLASSED_NODE_IFACES_ENTRIES(node)   (&(node)->_prot.iface_entries)
+#define NODE_IS_BOXED(node)     (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_BOXED)
+#define NODE_IS_IFACE(node)     (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_INTERFACE)
+#define CLASSED_NODE_IFACES_ENTRIES(node) (&(node)->_prot.iface_entries)
 #define CLASSED_NODE_IFACES_ENTRIES_LOCKED(node)(G_ATOMIC_ARRAY_GET_LOCKED(CLASSED_NODE_IFACES_ENTRIES((node)), IFaceEntries))
-#define IFACE_NODE_N_PREREQUISITES(node)    ((node)->n_prerequisites)
-#define IFACE_NODE_PREREQUISITES(node)      ((node)->prerequisites)
-#define iface_node_get_holders_L(node)      ((IFaceHolder*) type_get_qdata_L ((node), static_quark_iface_holder))
+#define IFACE_NODE_N_PREREQUISITES(node)  ((node)->n_prerequisites)
+#define IFACE_NODE_PREREQUISITES(node)    ((node)->prerequisites)
+#define iface_node_get_holders_L(node)    ((IFaceHolder*) type_get_qdata_L ((node), static_quark_iface_holder))
 #define iface_node_set_holders_W(node, holders) (type_set_qdata_W ((node), static_quark_iface_holder, (holders)))
-#define iface_node_get_dependants_array_L(n)    ((GType*) type_get_qdata_L ((n), static_quark_dependants_array))
+#define iface_node_get_dependants_array_L(n)  ((GType*) type_get_qdata_L ((n), static_quark_dependants_array))
 #define iface_node_set_dependants_array_W(n,d)  (type_set_qdata_W ((n), static_quark_dependants_array, (d)))
-#define TYPE_ID_MASK                ((GType) ((1 << G_TYPE_FUNDAMENTAL_SHIFT) - 1))
+#define TYPE_ID_MASK        ((GType) ((1 << G_TYPE_FUNDAMENTAL_SHIFT) - 1))
 
 #define NODE_IS_ANCESTOR(ancestor, node)                                                    \
         ((ancestor)->n_supers <= (node)->n_supers &&                                        \
-     (node)->supers[(node)->n_supers - (ancestor)->n_supers] == NODE_TYPE (ancestor))
+   (node)->supers[(node)->n_supers - (ancestor)->n_supers] == NODE_TYPE (ancestor))
 
 struct _IFaceHolder
 {
   GType           instance_type;
   GInterfaceInfo *info;
@@ -378,16 +378,19 @@
 static IFaceCheckFunc *static_iface_check_funcs = NULL;
 static GQuark          static_quark_type_flags = 0;
 static GQuark          static_quark_iface_holder = 0;
 static GQuark          static_quark_dependants_array = 0;
 static guint           type_registration_serial = 0;
+
+G_GNUC_BEGIN_IGNORE_DEPRECATIONS
 GTypeDebugFlags        _g_type_debug_flags = 0;
+G_GNUC_END_IGNORE_DEPRECATIONS
 
 /* --- type nodes --- */
 static GHashTable       *static_type_nodes_ht = NULL;
-static TypeNode     *static_fundamental_type_nodes[(G_TYPE_FUNDAMENTAL_MAX >> G_TYPE_FUNDAMENTAL_SHIFT) + 1] = { NULL, };
-static GType         static_fundamental_next = G_TYPE_RESERVED_USER_FIRST;
+static TypeNode   *static_fundamental_type_nodes[(G_TYPE_FUNDAMENTAL_MAX >> G_TYPE_FUNDAMENTAL_SHIFT) + 1] = { NULL, };
+static GType     static_fundamental_next = G_TYPE_RESERVED_USER_FIRST;
 
 static inline TypeNode*
 lookup_type_node_I (GType utype)
 {
   if (utype > G_TYPE_FUNDAMENTAL_MAX)
@@ -415,28 +418,28 @@
   return (guint)g_atomic_int_get ((gint *)&type_registration_serial);
 }
 
 static TypeNode*
 type_node_any_new_W (TypeNode             *pnode,
-             GType                 ftype,
-             const gchar          *name,
-             GTypePlugin          *plugin,
-             GTypeFundamentalFlags type_flags)
+         GType                 ftype,
+         const gchar          *name,
+         GTypePlugin          *plugin,
+         GTypeFundamentalFlags type_flags)
 {
   guint n_supers;
   GType type;
   TypeNode *node;
   guint i, node_size = 0;
 
   n_supers = pnode ? pnode->n_supers + 1 : 0;
 
   if (!pnode)
-    node_size += SIZEOF_FUNDAMENTAL_INFO;         /* fundamental type info */
-  node_size += SIZEOF_BASE_TYPE_NODE ();          /* TypeNode structure */
+    node_size += SIZEOF_FUNDAMENTAL_INFO;       /* fundamental type info */
+  node_size += SIZEOF_BASE_TYPE_NODE ();        /* TypeNode structure */
   node_size += (sizeof (GType) * (1 + n_supers + 1)); /* self + ancestors + (0) for ->supers[] */
   node = g_malloc0 (node_size);
-  if (!pnode)                         /* offset fundamental types */
+  if (!pnode)               /* offset fundamental types */
     {
       node = G_STRUCT_MEMBER_P (node, SIZEOF_FUNDAMENTAL_INFO);
       static_fundamental_type_nodes[ftype >> G_TYPE_FUNDAMENTAL_SHIFT] = node;
       type = ftype;
     }
@@ -453,49 +456,49 @@
 
       node->is_classed = (type_flags & G_TYPE_FLAG_CLASSED) != 0;
       node->is_instantiatable = (type_flags & G_TYPE_FLAG_INSTANTIATABLE) != 0;
 
       if (NODE_IS_IFACE (node))
-    {
+  {
           IFACE_NODE_N_PREREQUISITES (node) = 0;
-      IFACE_NODE_PREREQUISITES (node) = NULL;
-    }
+    IFACE_NODE_PREREQUISITES (node) = NULL;
+  }
       else
-    _g_atomic_array_init (CLASSED_NODE_IFACES_ENTRIES (node));
+  _g_atomic_array_init (CLASSED_NODE_IFACES_ENTRIES (node));
     }
   else
     {
       node->supers[0] = type;
       memcpy (node->supers + 1, pnode->supers, sizeof (GType) * (1 + pnode->n_supers + 1));
 
       node->is_classed = pnode->is_classed;
       node->is_instantiatable = pnode->is_instantiatable;
 
       if (NODE_IS_IFACE (node))
-    {
-      IFACE_NODE_N_PREREQUISITES (node) = 0;
-      IFACE_NODE_PREREQUISITES (node) = NULL;
-    }
+  {
+    IFACE_NODE_N_PREREQUISITES (node) = 0;
+    IFACE_NODE_PREREQUISITES (node) = NULL;
+  }
       else
+  {
+    guint j;
+    IFaceEntries *entries;
+
+    entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (pnode),
+            IFACE_ENTRIES_HEADER_SIZE,
+            0);
+    if (entries)
+      {
+        for (j = 0; j < IFACE_ENTRIES_N_ENTRIES (entries); j++)
     {
-      guint j;
-      IFaceEntries *entries;
-
-      entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (pnode),
-                      IFACE_ENTRIES_HEADER_SIZE,
-                      0);
-      if (entries)
-        {
-          for (j = 0; j < IFACE_ENTRIES_N_ENTRIES (entries); j++)
-        {
-          entries->entry[j].vtable = NULL;
-          entries->entry[j].init_state = UNINITIALIZED;
-        }
-          _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node),
-                      entries);
-        }
+      entries->entry[j].vtable = NULL;
+      entries->entry[j].init_state = UNINITIALIZED;
     }
+        _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node),
+              entries);
+      }
+  }
 
       i = pnode->n_children++;
       pnode->children = g_renew (GType, pnode->children, pnode->n_children);
       pnode->children[i] = type;
     }
@@ -507,12 +510,12 @@
   node->children = NULL;
   node->data = NULL;
   node->qname = g_quark_from_string (name);
   node->global_gdata = NULL;
   g_hash_table_insert (static_type_nodes_ht,
-               (gpointer) g_quark_to_string (node->qname),
-               (gpointer) type);
+           (gpointer) g_quark_to_string (node->qname),
+           (gpointer) type);
 
   g_atomic_int_inc ((gint *)&type_registration_serial);
 
   return node;
 }
@@ -528,12 +531,12 @@
   return node ? G_STRUCT_MEMBER_P (node, -SIZEOF_FUNDAMENTAL_INFO) : NULL;
 }
 
 static TypeNode*
 type_node_fundamental_new_W (GType                 ftype,
-                 const gchar          *name,
-                 GTypeFundamentalFlags type_flags)
+           const gchar          *name,
+           GTypeFundamentalFlags type_flags)
 {
   GTypeFundamentalInfo *finfo;
   TypeNode *node;
 
   g_assert ((ftype & TYPE_ID_MASK) == 0);
@@ -552,12 +555,12 @@
   return node;
 }
 
 static TypeNode*
 type_node_new_W (TypeNode    *pnode,
-         const gchar *name,
-         GTypePlugin *plugin)
+     const gchar *name,
+     GTypePlugin *plugin)
 
 {
   g_assert (pnode);
   g_assert (pnode->n_supers < MAX_N_SUPERS);
   g_assert (pnode->n_children < MAX_N_CHILDREN);
@@ -565,11 +568,11 @@
   return type_node_any_new_W (pnode, NODE_FUNDAMENTAL_TYPE (pnode), name, plugin, 0);
 }
 
 static inline IFaceEntry*
 lookup_iface_entry_I (volatile IFaceEntries *entries,
-              TypeNode *iface_node)
+          TypeNode *iface_node)
 {
   guint8 *offsets;
   guint offset_index;
   IFaceEntry *check;
   int index;
@@ -583,101 +586,101 @@
 
      entry = NULL;
      offsets = transaction_data;
      offset_index = entries->offset_index;
      if (offsets != NULL &&
-     offset_index < G_ATOMIC_ARRAY_DATA_SIZE(offsets))
-       {
-     index = offsets[offset_index];
-     if (index > 0)
+   offset_index < G_ATOMIC_ARRAY_DATA_SIZE(offsets))
        {
-         /* zero means unset, subtract one to get real index */
-         index -= 1;
-
-         if (index < IFACE_ENTRIES_N_ENTRIES (entries))
-           {
-         check = (IFaceEntry *)&entries->entry[index];
-         if (check->iface_type == NODE_TYPE (iface_node))
-           entry = check;
-           }
-       }
+   index = offsets[offset_index];
+   if (index > 0)
+     {
+       /* zero means unset, subtract one to get real index */
+       index -= 1;
+
+       if (index < IFACE_ENTRIES_N_ENTRIES (entries))
+         {
+     check = (IFaceEntry *)&entries->entry[index];
+     if (check->iface_type == NODE_TYPE (iface_node))
+       entry = check;
+         }
+     }
        }
      );
 
  return entry;
 }
 
 static inline IFaceEntry*
 type_lookup_iface_entry_L (TypeNode *node,
-               TypeNode *iface_node)
+         TypeNode *iface_node)
 {
   if (!NODE_IS_IFACE (iface_node))
     return NULL;
 
   return lookup_iface_entry_I (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node),
-                   iface_node);
+             iface_node);
 }
 
 
 static inline gboolean
 type_lookup_iface_vtable_I (TypeNode *node,
-                TypeNode *iface_node,
-                gpointer *vtable_ptr)
+          TypeNode *iface_node,
+          gpointer *vtable_ptr)
 {
   IFaceEntry *entry;
   gboolean res;
 
   if (!NODE_IS_IFACE (iface_node))
     {
       if (vtable_ptr)
-    *vtable_ptr = NULL;
+  *vtable_ptr = NULL;
       return FALSE;
     }
 
   G_ATOMIC_ARRAY_DO_TRANSACTION
     (CLASSED_NODE_IFACES_ENTRIES (node), IFaceEntries,
 
      entry = lookup_iface_entry_I (transaction_data, iface_node);
      res = entry != NULL;
      if (vtable_ptr)
        {
-     if (entry)
-       *vtable_ptr = entry->vtable;
-     else
-       *vtable_ptr = NULL;
+   if (entry)
+     *vtable_ptr = entry->vtable;
+   else
+     *vtable_ptr = NULL;
        }
      );
 
   return res;
 }
 
 static inline gboolean
 type_lookup_prerequisite_L (TypeNode *iface,
-                GType     prerequisite_type)
+          GType     prerequisite_type)
 {
   if (NODE_IS_IFACE (iface) && IFACE_NODE_N_PREREQUISITES (iface))
     {
       GType *prerequisites = IFACE_NODE_PREREQUISITES (iface) - 1;
       guint n_prerequisites = IFACE_NODE_N_PREREQUISITES (iface);
 
       do
-    {
-      guint i;
-      GType *check;
+  {
+    guint i;
+    GType *check;
 
-      i = (n_prerequisites + 1) >> 1;
-      check = prerequisites + i;
-      if (prerequisite_type == *check)
-        return TRUE;
-      else if (prerequisite_type > *check)
-        {
-          n_prerequisites -= i;
-          prerequisites = check;
-        }
-      else /* if (prerequisite_type < *check) */
-        n_prerequisites = i - 1;
-    }
+    i = (n_prerequisites + 1) >> 1;
+    check = prerequisites + i;
+    if (prerequisite_type == *check)
+      return TRUE;
+    else if (prerequisite_type > *check)
+      {
+        n_prerequisites -= i;
+        prerequisites = check;
+      }
+    else /* if (prerequisite_type < *check) */
+      n_prerequisites = i - 1;
+  }
       while (n_prerequisites);
     }
   return FALSE;
 }
 
@@ -696,38 +699,38 @@
 
 
 /* --- type consistency checks --- */
 static gboolean
 check_plugin_U (GTypePlugin *plugin,
-        gboolean     need_complete_type_info,
-        gboolean     need_complete_interface_info,
-        const gchar *type_name)
+    gboolean     need_complete_type_info,
+    gboolean     need_complete_interface_info,
+    const gchar *type_name)
 {
   /* G_IS_TYPE_PLUGIN() and G_TYPE_PLUGIN_GET_CLASS() are external calls: _U
    */
   if (!plugin)
     {
       g_warning ("plugin handle for type '%s' is NULL",
-         type_name);
+     type_name);
       return FALSE;
     }
   if (!G_IS_TYPE_PLUGIN (plugin))
     {
       g_warning ("plugin pointer (%p) for type '%s' is invalid",
-         plugin, type_name);
+     plugin, type_name);
       return FALSE;
     }
   if (need_complete_type_info && !G_TYPE_PLUGIN_GET_CLASS (plugin)->complete_type_info)
     {
       g_warning ("plugin for type '%s' has no complete_type_info() implementation",
-         type_name);
+     type_name);
       return FALSE;
     }
   if (need_complete_interface_info && !G_TYPE_PLUGIN_GET_CLASS (plugin)->complete_interface_info)
     {
       g_warning ("plugin for type '%s' has no complete_interface_info() implementation",
-         type_name);
+     type_name);
       return FALSE;
     }
   return TRUE;
 }
 
@@ -745,13 +748,13 @@
     }
   /* check the first letter */
   name_valid = (p[0] >= 'A' && p[0] <= 'Z') || (p[0] >= 'a' && p[0] <= 'z') || p[0] == '_';
   for (p = type_name + 1; *p; p++)
     name_valid &= ((p[0] >= 'A' && p[0] <= 'Z') ||
-           (p[0] >= 'a' && p[0] <= 'z') ||
-           (p[0] >= '0' && p[0] <= '9') ||
-           strchr (extra_chars, p[0]));
+       (p[0] >= 'a' && p[0] <= 'z') ||
+       (p[0] >= '0' && p[0] <= '9') ||
+       strchr (extra_chars, p[0]));
   if (!name_valid)
     {
       g_warning ("type name '%s' contains invalid characters", type_name);
       return FALSE;
     }
@@ -764,39 +767,39 @@
   return TRUE;
 }
 
 static gboolean
 check_derivation_I (GType        parent_type,
-            const gchar *type_name)
+        const gchar *type_name)
 {
   TypeNode *pnode;
   GTypeFundamentalInfo* finfo;
 
   pnode = lookup_type_node_I (parent_type);
   if (!pnode)
     {
       g_warning ("cannot derive type '%s' from invalid parent type '%s'",
-         type_name,
-         type_descriptive_name_I (parent_type));
+     type_name,
+     type_descriptive_name_I (parent_type));
       return FALSE;
     }
   finfo = type_node_fundamental_info_I (pnode);
   /* ensure flat derivability */
   if (!(finfo->type_flags & G_TYPE_FLAG_DERIVABLE))
     {
       g_warning ("cannot derive '%s' from non-derivable parent type '%s'",
-         type_name,
-         NODE_NAME (pnode));
+     type_name,
+     NODE_NAME (pnode));
       return FALSE;
     }
   /* ensure deep derivability */
   if (parent_type != NODE_FUNDAMENTAL_TYPE (pnode) &&
       !(finfo->type_flags & G_TYPE_FLAG_DEEP_DERIVABLE))
     {
       g_warning ("cannot derive '%s' from non-fundamental parent type '%s'",
-         type_name,
-         NODE_NAME (pnode));
+     type_name,
+     NODE_NAME (pnode));
       return FALSE;
     }
 
   return TRUE;
 }
@@ -804,86 +807,86 @@
 static gboolean
 check_collect_format_I (const gchar *collect_format)
 {
   const gchar *p = collect_format;
   gchar valid_format[] = { G_VALUE_COLLECT_INT, G_VALUE_COLLECT_LONG,
-               G_VALUE_COLLECT_INT64, G_VALUE_COLLECT_DOUBLE,
-               G_VALUE_COLLECT_POINTER, 0 };
+         G_VALUE_COLLECT_INT64, G_VALUE_COLLECT_DOUBLE,
+         G_VALUE_COLLECT_POINTER, 0 };
 
   while (*p)
     if (!strchr (valid_format, *p++))
       return FALSE;
   return p - collect_format <= G_VALUE_COLLECT_FORMAT_MAX_LENGTH;
 }
 
 static gboolean
 check_value_table_I (const gchar           *type_name,
-             const GTypeValueTable *value_table)
+         const GTypeValueTable *value_table)
 {
   if (!value_table)
     return FALSE;
   else if (value_table->value_init == NULL)
     {
       if (value_table->value_free || value_table->value_copy ||
-      value_table->value_peek_pointer ||
-      value_table->collect_format || value_table->collect_value ||
-      value_table->lcopy_format || value_table->lcopy_value)
-    g_warning ("cannot handle uninitializable values of type '%s'",
-           type_name);
+    value_table->value_peek_pointer ||
+    value_table->collect_format || value_table->collect_value ||
+    value_table->lcopy_format || value_table->lcopy_value)
+  g_warning ("cannot handle uninitializable values of type '%s'",
+       type_name);
       return FALSE;
     }
   else /* value_table->value_init != NULL */
     {
       if (!value_table->value_free)
-    {
-      /* +++ optional +++
-       * g_warning ("missing 'value_free()' for type '%s'", type_name);
-       * return FALSE;
-       */
-    }
+  {
+    /* +++ optional +++
+     * g_warning ("missing 'value_free()' for type '%s'", type_name);
+     * return FALSE;
+     */
+  }
       if (!value_table->value_copy)
-    {
-      g_warning ("missing 'value_copy()' for type '%s'", type_name);
-      return FALSE;
-    }
+  {
+    g_warning ("missing 'value_copy()' for type '%s'", type_name);
+    return FALSE;
+  }
       if ((value_table->collect_format || value_table->collect_value) &&
-      (!value_table->collect_format || !value_table->collect_value))
-    {
-      g_warning ("one of 'collect_format' and 'collect_value()' is unspecified for type '%s'",
-             type_name);
-      return FALSE;
-    }
+    (!value_table->collect_format || !value_table->collect_value))
+  {
+    g_warning ("one of 'collect_format' and 'collect_value()' is unspecified for type '%s'",
+         type_name);
+    return FALSE;
+  }
       if (value_table->collect_format && !check_collect_format_I (value_table->collect_format))
-    {
-      g_warning ("the '%s' specification for type '%s' is too long or invalid",
-             "collect_format",
-             type_name);
-      return FALSE;
-    }
+  {
+    g_warning ("the '%s' specification for type '%s' is too long or invalid",
+         "collect_format",
+         type_name);
+    return FALSE;
+  }
       if ((value_table->lcopy_format || value_table->lcopy_value) &&
-      (!value_table->lcopy_format || !value_table->lcopy_value))
-    {
-      g_warning ("one of 'lcopy_format' and 'lcopy_value()' is unspecified for type '%s'",
-             type_name);
-      return FALSE;
-    }
+    (!value_table->lcopy_format || !value_table->lcopy_value))
+  {
+    g_warning ("one of 'lcopy_format' and 'lcopy_value()' is unspecified for type '%s'",
+         type_name);
+    return FALSE;
+  }
       if (value_table->lcopy_format && !check_collect_format_I (value_table->lcopy_format))
-    {
-      g_warning ("the '%s' specification for type '%s' is too long or invalid",
-             "lcopy_format",
-             type_name);
-      return FALSE;
-    }
+  {
+    g_warning ("the '%s' specification for type '%s' is too long or invalid",
+         "lcopy_format",
+         type_name);
+    return FALSE;
+  }
     }
   return TRUE;
 }
 
 static gboolean
 check_type_info_I (TypeNode        *pnode,
-           GType            ftype,
-           const gchar     *type_name,
-           const GTypeInfo *info)
+       GType            ftype,
+       const gchar     *type_name,
+       const GTypeInfo *info)
 {
   GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (lookup_type_node_I (ftype));
   gboolean is_interface = ftype == G_TYPE_INTERFACE;
 
   g_assert (ftype <= G_TYPE_FUNDAMENTAL_MAX && !(ftype & TYPE_ID_MASK));
@@ -891,82 +894,82 @@
   /* check instance members */
   if (!(finfo->type_flags & G_TYPE_FLAG_INSTANTIATABLE) &&
       (info->instance_size || info->n_preallocs || info->instance_init))
     {
       if (pnode)
-    g_warning ("cannot instantiate '%s', derived from non-instantiatable parent type '%s'",
-           type_name,
-           NODE_NAME (pnode));
+  g_warning ("cannot instantiate '%s', derived from non-instantiatable parent type '%s'",
+       type_name,
+       NODE_NAME (pnode));
       else
-    g_warning ("cannot instantiate '%s' as non-instantiatable fundamental",
-           type_name);
+  g_warning ("cannot instantiate '%s' as non-instantiatable fundamental",
+       type_name);
       return FALSE;
     }
   /* check class & interface members */
   if (!((finfo->type_flags & G_TYPE_FLAG_CLASSED) || is_interface) &&
       (info->class_init || info->class_finalize || info->class_data ||
        info->class_size || info->base_init || info->base_finalize))
     {
       if (pnode)
-    g_warning ("cannot create class for '%s', derived from non-classed parent type '%s'",
-           type_name,
+  g_warning ("cannot create class for '%s', derived from non-classed parent type '%s'",
+       type_name,
                    NODE_NAME (pnode));
       else
-    g_warning ("cannot create class for '%s' as non-classed fundamental",
-           type_name);
+  g_warning ("cannot create class for '%s' as non-classed fundamental",
+       type_name);
       return FALSE;
     }
   /* check interface size */
   if (is_interface && info->class_size < sizeof (GTypeInterface))
     {
       g_warning ("specified interface size for type '%s' is smaller than 'GTypeInterface' size",
-         type_name);
+     type_name);
       return FALSE;
     }
   /* check class size */
   if (finfo->type_flags & G_TYPE_FLAG_CLASSED)
     {
       if (info->class_size < sizeof (GTypeClass))
-    {
-      g_warning ("specified class size for type '%s' is smaller than 'GTypeClass' size",
-             type_name);
-      return FALSE;
-    }
+  {
+    g_warning ("specified class size for type '%s' is smaller than 'GTypeClass' size",
+         type_name);
+    return FALSE;
+  }
       if (pnode && info->class_size < pnode->data->class.class_size)
-    {
-      g_warning ("specified class size for type '%s' is smaller "
-             "than the parent type's '%s' class size",
-             type_name,
-             NODE_NAME (pnode));
-      return FALSE;
-    }
+  {
+    g_warning ("specified class size for type '%s' is smaller "
+         "than the parent type's '%s' class size",
+         type_name,
+         NODE_NAME (pnode));
+    return FALSE;
+  }
     }
   /* check instance size */
   if (finfo->type_flags & G_TYPE_FLAG_INSTANTIATABLE)
     {
       if (info->instance_size < sizeof (GTypeInstance))
-    {
-      g_warning ("specified instance size for type '%s' is smaller than 'GTypeInstance' size",
-             type_name);
-      return FALSE;
-    }
+  {
+    g_warning ("specified instance size for type '%s' is smaller than 'GTypeInstance' size",
+         type_name);
+    return FALSE;
+  }
       if (pnode && info->instance_size < pnode->data->instance.instance_size)
-    {
-      g_warning ("specified instance size for type '%s' is smaller "
-             "than the parent type's '%s' instance size",
-             type_name,
-             NODE_NAME (pnode));
-      return FALSE;
-    }
+  {
+    g_warning ("specified instance size for type '%s' is smaller "
+         "than the parent type's '%s' instance size",
+         type_name,
+         NODE_NAME (pnode));
+    return FALSE;
+  }
     }
 
   return TRUE;
 }
 
 static TypeNode*
 find_conforming_child_type_L (TypeNode *pnode,
-                  TypeNode *iface)
+            TypeNode *iface)
 {
   TypeNode *node = NULL;
   guint i;
 
   if (type_lookup_iface_entry_L (pnode, iface))
@@ -978,11 +981,11 @@
   return node;
 }
 
 static gboolean
 check_add_interface_L (GType instance_type,
-               GType iface_type)
+           GType iface_type)
 {
   TypeNode *node = lookup_type_node_I (instance_type);
   TypeNode *iface = lookup_type_node_I (iface_type);
   IFaceEntry *entry;
   TypeNode *tnode;
@@ -991,18 +994,18 @@
 
 
   if (!node || !node->is_instantiatable)
     {
       g_warning ("cannot add interfaces to invalid (non-instantiatable) type '%s'",
-         type_descriptive_name_I (instance_type));
+     type_descriptive_name_I (instance_type));
       return FALSE;
     }
   if (!iface || !NODE_IS_IFACE (iface))
     {
       g_warning ("cannot add invalid (non-interface) type '%s' to type '%s'",
-         type_descriptive_name_I (iface_type),
-         NODE_NAME (node));
+     type_descriptive_name_I (iface_type),
+     NODE_NAME (node));
       return FALSE;
     }
   if (node->data && node->data->class.class)
     {
       g_warning ("attempting to add an interface (%s) to class (%s) after class_init",
@@ -1012,13 +1015,13 @@
   tnode = lookup_type_node_I (NODE_PARENT_TYPE (iface));
   if (NODE_PARENT_TYPE (tnode) && !type_lookup_iface_entry_L (node, tnode))
     {
       /* 2001/7/31:timj: erk, i guess this warning is junk as interface derivation is flat */
       g_warning ("cannot add sub-interface '%s' to type '%s' which does not conform to super-interface '%s'",
-         NODE_NAME (iface),
-         NODE_NAME (node),
-         NODE_NAME (tnode));
+     NODE_NAME (iface),
+     NODE_NAME (node),
+     NODE_NAME (tnode));
       return FALSE;
     }
   /* allow overriding of interface type introduced for parent type */
   entry = type_lookup_iface_entry_L (node, iface);
   if (entry && entry->vtable == NULL && !type_iface_peek_holder_L (iface, NODE_TYPE (node)))
@@ -1034,52 +1037,52 @@
    */
   tnode = find_conforming_child_type_L (node, iface);  /* tnode is_a node */
   if (tnode)
     {
       g_warning ("cannot add interface type '%s' to type '%s', since type '%s' already conforms to interface",
-         NODE_NAME (iface),
-         NODE_NAME (node),
-         NODE_NAME (tnode));
+     NODE_NAME (iface),
+     NODE_NAME (node),
+     NODE_NAME (tnode));
       return FALSE;
     }
   prerequisites = IFACE_NODE_PREREQUISITES (iface);
   for (i = 0; i < IFACE_NODE_N_PREREQUISITES (iface); i++)
     {
       tnode = lookup_type_node_I (prerequisites[i]);
       if (!type_node_is_a_L (node, tnode))
-    {
-      g_warning ("cannot add interface type '%s' to type '%s' which does not conform to prerequisite '%s'",
-             NODE_NAME (iface),
-             NODE_NAME (node),
-             NODE_NAME (tnode));
-      return FALSE;
-    }
+  {
+    g_warning ("cannot add interface type '%s' to type '%s' which does not conform to prerequisite '%s'",
+         NODE_NAME (iface),
+         NODE_NAME (node),
+         NODE_NAME (tnode));
+    return FALSE;
+  }
     }
   return TRUE;
 }
 
 static gboolean
 check_interface_info_I (TypeNode             *iface,
-            GType                 instance_type,
-            const GInterfaceInfo *info)
+      GType                 instance_type,
+      const GInterfaceInfo *info)
 {
   if ((info->interface_finalize || info->interface_data) && !info->interface_init)
     {
       g_warning ("interface type '%s' for type '%s' comes without initializer",
-         NODE_NAME (iface),
-         type_descriptive_name_I (instance_type));
+     NODE_NAME (iface),
+     type_descriptive_name_I (instance_type));
       return FALSE;
     }
 
   return TRUE;
 }
 
 /* --- type info (type node data) --- */
 static void
 type_data_make_W (TypeNode              *node,
-          const GTypeInfo       *info,
-          const GTypeValueTable *value_table)
+      const GTypeInfo       *info,
+      const GTypeValueTable *value_table)
 {
   TypeData *data;
   GTypeValueTable *vtable = NULL;
   guint vtable_size = 0;
 
@@ -1088,26 +1091,26 @@
   if (!value_table)
     {
       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
 
       if (pnode)
-    vtable = pnode->data->common.value_table;
+  vtable = pnode->data->common.value_table;
       else
-    {
-      static const GTypeValueTable zero_vtable = { NULL, };
+  {
+    static const GTypeValueTable zero_vtable = { NULL, };
 
-      value_table = &zero_vtable;
-    }
+    value_table = &zero_vtable;
+  }
     }
   if (value_table)
     {
       /* need to setup vtable_size since we have to allocate it with data in one chunk */
       vtable_size = sizeof (GTypeValueTable);
       if (value_table->collect_format)
-    vtable_size += strlen (value_table->collect_format);
+  vtable_size += strlen (value_table->collect_format);
       if (value_table->lcopy_format)
-    vtable_size += strlen (value_table->lcopy_format);
+  vtable_size += strlen (value_table->lcopy_format);
       vtable_size += 2;
     }
 
   if (node->is_instantiatable) /* careful, is_instantiatable is also is_classed */
     {
@@ -1117,11 +1120,11 @@
 #ifdef GSTREAMER_LITE
       if (data == NULL)
           return;
 #endif // GSTREAMER_LITE
       if (vtable_size)
-    vtable = G_STRUCT_MEMBER_P (data, sizeof (InstanceData));
+  vtable = G_STRUCT_MEMBER_P (data, sizeof (InstanceData));
       data->instance.class_size = info->class_size;
       data->instance.class_init_base = info->base_init;
       data->instance.class_finalize_base = info->base_finalize;
       data->instance.class_init = info->class_init;
       data->instance.class_finalize = info->class_finalize;
@@ -1143,11 +1146,11 @@
     {
       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
 
       data = g_malloc0 (sizeof (ClassData) + vtable_size);
       if (vtable_size)
-    vtable = G_STRUCT_MEMBER_P (data, sizeof (ClassData));
+  vtable = G_STRUCT_MEMBER_P (data, sizeof (ClassData));
       data->class.class_size = info->class_size;
       data->class.class_init_base = info->base_init;
       data->class.class_finalize_base = info->base_finalize;
       data->class.class_init = info->class_init;
       data->class.class_finalize = info->class_finalize;
@@ -1160,11 +1163,11 @@
     }
   else if (NODE_IS_IFACE (node))
     {
       data = g_malloc0 (sizeof (IFaceData) + vtable_size);
       if (vtable_size)
-    vtable = G_STRUCT_MEMBER_P (data, sizeof (IFaceData));
+  vtable = G_STRUCT_MEMBER_P (data, sizeof (IFaceData));
       data->iface.vtable_size = info->class_size;
       data->iface.vtable_init_base = info->base_init;
       data->iface.vtable_finalize_base = info->base_finalize;
       data->iface.dflt_init = info->class_init;
       data->iface.dflt_finalize = info->class_finalize;
@@ -1173,17 +1176,17 @@
     }
   else if (NODE_IS_BOXED (node))
     {
       data = g_malloc0 (sizeof (BoxedData) + vtable_size);
       if (vtable_size)
-    vtable = G_STRUCT_MEMBER_P (data, sizeof (BoxedData));
+  vtable = G_STRUCT_MEMBER_P (data, sizeof (BoxedData));
     }
   else
     {
       data = g_malloc0 (sizeof (CommonData) + vtable_size);
       if (vtable_size)
-    vtable = G_STRUCT_MEMBER_P (data, sizeof (CommonData));
+  vtable = G_STRUCT_MEMBER_P (data, sizeof (CommonData));
     }
 
   node->data = data;
 
   if (vtable_size)
@@ -1197,24 +1200,24 @@
       *vtable = *value_table;
       p = G_STRUCT_MEMBER_P (vtable, sizeof (*vtable));
       p[0] = 0;
       vtable->collect_format = p;
       if (value_table->collect_format)
-    {
-      strcat (p, value_table->collect_format);
-      p += strlen (value_table->collect_format);
-    }
+  {
+    strcat (p, value_table->collect_format);
+    p += strlen (value_table->collect_format);
+  }
       p++;
       p[0] = 0;
       vtable->lcopy_format = p;
       if (value_table->lcopy_format)
-    strcat  (p, value_table->lcopy_format);
+  strcat  (p, value_table->lcopy_format);
     }
   node->data->common.value_table = vtable;
   node->mutatable_check_cache = (node->data->common.value_table->value_init != NULL &&
-                 !((G_TYPE_FLAG_VALUE_ABSTRACT | G_TYPE_FLAG_ABSTRACT) &
-                   GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))));
+         !((G_TYPE_FLAG_VALUE_ABSTRACT | G_TYPE_FLAG_ABSTRACT) &
+           GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))));
 
   g_assert (node->data->common.value_table != NULL); /* paranoid */
 
   g_atomic_int_set ((int *) &node->ref_count, 1);
 }
@@ -1229,30 +1232,30 @@
       GTypeValueTable tmp_value_table;
 
       g_assert (node->plugin != NULL);
 
       if (pnode)
-    {
-      type_data_ref_Wm (pnode);
-      if (node->data)
-        INVALID_RECURSION ("g_type_plugin_*", node->plugin, NODE_NAME (node));
-    }
+  {
+    type_data_ref_Wm (pnode);
+    if (node->data)
+      INVALID_RECURSION ("g_type_plugin_*", node->plugin, NODE_NAME (node));
+  }
 
       memset (&tmp_info, 0, sizeof (tmp_info));
       memset (&tmp_value_table, 0, sizeof (tmp_value_table));
 
       G_WRITE_UNLOCK (&type_rw_lock);
       g_type_plugin_use (node->plugin);
       g_type_plugin_complete_type_info (node->plugin, NODE_TYPE (node), &tmp_info, &tmp_value_table);
       G_WRITE_LOCK (&type_rw_lock);
       if (node->data)
-    INVALID_RECURSION ("g_type_plugin_*", node->plugin, NODE_NAME (node));
+  INVALID_RECURSION ("g_type_plugin_*", node->plugin, NODE_NAME (node));
 
       check_type_info_I (pnode, NODE_FUNDAMENTAL_TYPE (node), NODE_NAME (node), &tmp_info);
       type_data_make_W (node, &tmp_info,
-            check_value_table_I (NODE_NAME (node),
-                         &tmp_value_table) ? &tmp_value_table : NULL);
+      check_value_table_I (NODE_NAME (node),
+               &tmp_value_table) ? &tmp_value_table : NULL);
     }
   else
     {
       g_assert (NODE_REFCOUNT (node) > 0);
 
@@ -1275,12 +1278,12 @@
   return TRUE;
 }
 
 static gboolean
 iface_node_has_available_offset_L (TypeNode *iface_node,
-                   int offset,
-                   int for_index)
+           int offset,
+           int for_index)
 {
   guint8 *offsets;
 
   offsets = G_ATOMIC_ARRAY_GET_LOCKED (&iface_node->_prot.offsets, guint8);
   if (offsets == NULL)
@@ -1309,27 +1312,27 @@
   offset = -1;
   do
     {
       offset++;
       for (i = 0; i < n_entries; i++)
-    {
-      entry = &entries->entry[i];
-      iface_node = lookup_type_node_I (entry->iface_type);
+  {
+    entry = &entries->entry[i];
+    iface_node = lookup_type_node_I (entry->iface_type);
 
-      if (!iface_node_has_available_offset_L (iface_node, offset, i))
-        break;
-    }
+    if (!iface_node_has_available_offset_L (iface_node, offset, i))
+      break;
+  }
     }
   while (i != n_entries);
 
   return offset;
 }
 
 static void
 iface_node_set_offset_L (TypeNode *iface_node,
-             int offset,
-             int index)
+       int offset,
+       int index)
 {
   guint8 *offsets, *old_offsets;
   int new_size, old_size;
   int i;
 
@@ -1338,17 +1341,17 @@
     old_size = 0;
   else
     {
       old_size = G_ATOMIC_ARRAY_DATA_SIZE (old_offsets);
       if (offset < old_size &&
-      old_offsets[offset] == index + 1)
-    return; /* Already set to this index, return */
+    old_offsets[offset] == index + 1)
+  return; /* Already set to this index, return */
     }
   new_size = MAX (old_size, offset + 1);
 
   offsets = _g_atomic_array_copy (&iface_node->_prot.offsets,
-                  0, new_size - old_size);
+          0, new_size - old_size);
 
   /* Mark new area as unused */
   for (i = old_size; i < new_size; i++)
     offsets[i] = 0;
 
@@ -1357,11 +1360,11 @@
   _g_atomic_array_update (&iface_node->_prot.offsets, offsets);
 }
 
 static void
 type_node_add_iface_entry_W (TypeNode   *node,
-                 GType       iface_type,
+           GType       iface_type,
                              IFaceEntry *parent_entry)
 {
   IFaceEntries *entries;
   IFaceEntry *entry;
   TypeNode *iface_node;
@@ -1376,38 +1379,38 @@
       num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
 
       g_assert (num_entries < MAX_N_INTERFACES);
 
       for (i = 0; i < num_entries; i++)
-    {
-      entry = &entries->entry[i];
-      if (entry->iface_type == iface_type)
-        {
-          /* this can happen in two cases:
-           * - our parent type already conformed to iface_type and node
-           *   got its own holder info. here, our children already have
-           *   entries and NULL vtables, since this will only work for
-           *   uninitialized classes.
-           * - an interface type is added to an ancestor after it was
-           *   added to a child type.
-           */
-          if (!parent_entry)
-        g_assert (entry->vtable == NULL && entry->init_state == UNINITIALIZED);
-          else
-        {
-          /* sick, interface is added to ancestor *after* child type;
-           * nothing todo, the entry and our children were already setup correctly
-           */
-        }
-          return;
-        }
+  {
+    entry = &entries->entry[i];
+    if (entry->iface_type == iface_type)
+      {
+        /* this can happen in two cases:
+         * - our parent type already conformed to iface_type and node
+         *   got its own holder info. here, our children already have
+         *   entries and NULL vtables, since this will only work for
+         *   uninitialized classes.
+         * - an interface type is added to an ancestor after it was
+         *   added to a child type.
+         */
+        if (!parent_entry)
+    g_assert (entry->vtable == NULL && entry->init_state == UNINITIALIZED);
+        else
+    {
+      /* sick, interface is added to ancestor *after* child type;
+       * nothing todo, the entry and our children were already setup correctly
+       */
     }
+        return;
+      }
+  }
     }
 
   entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (node),
-                  IFACE_ENTRIES_HEADER_SIZE,
-                  sizeof (IFaceEntry));
+          IFACE_ENTRIES_HEADER_SIZE,
+          sizeof (IFaceEntry));
   num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
   i = num_entries - 1;
   if (i == 0)
     entries->offset_index = 0;
   entries->entry[i].iface_type = iface_type;
@@ -1425,28 +1428,28 @@
 
   /* Update offsets in iface */
   iface_node = lookup_type_node_I (iface_type);
 
   if (iface_node_has_available_offset_L (iface_node,
-                     entries->offset_index,
-                     i))
+           entries->offset_index,
+           i))
     {
       iface_node_set_offset_L (iface_node,
-                   entries->offset_index, i);
+             entries->offset_index, i);
     }
   else
    {
       entries->offset_index =
-    find_free_iface_offset_L (entries);
+  find_free_iface_offset_L (entries);
       for (j = 0; j < IFACE_ENTRIES_N_ENTRIES (entries); j++)
-    {
-      entry = &entries->entry[j];
-      iface_node =
-        lookup_type_node_I (entry->iface_type);
-      iface_node_set_offset_L (iface_node,
-                   entries->offset_index, j);
-    }
+  {
+    entry = &entries->entry[j];
+    iface_node =
+      lookup_type_node_I (entry->iface_type);
+    iface_node_set_offset_L (iface_node,
+           entries->offset_index, j);
+  }
     }
 
   _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node), entries);
 
   if (parent_entry)
@@ -1497,30 +1500,30 @@
     type_node_add_iface_entry_W (lookup_type_node_I (node->children[i]), NODE_TYPE (iface), entry);
 }
 
 static void
 type_iface_add_prerequisite_W (TypeNode *iface,
-                   TypeNode *prerequisite_node)
+             TypeNode *prerequisite_node)
 {
   GType prerequisite_type = NODE_TYPE (prerequisite_node);
   GType *prerequisites, *dependants;
   guint n_dependants, i;
 
   g_assert (NODE_IS_IFACE (iface) &&
-        IFACE_NODE_N_PREREQUISITES (iface) < MAX_N_PREREQUISITES &&
-        (prerequisite_node->is_instantiatable || NODE_IS_IFACE (prerequisite_node)));
+      IFACE_NODE_N_PREREQUISITES (iface) < MAX_N_PREREQUISITES &&
+      (prerequisite_node->is_instantiatable || NODE_IS_IFACE (prerequisite_node)));
 
   prerequisites = IFACE_NODE_PREREQUISITES (iface);
   for (i = 0; i < IFACE_NODE_N_PREREQUISITES (iface); i++)
     if (prerequisites[i] == prerequisite_type)
-      return;           /* we already have that prerequisiste */
+      return;     /* we already have that prerequisiste */
     else if (prerequisites[i] > prerequisite_type)
       break;
   IFACE_NODE_N_PREREQUISITES (iface) += 1;
   IFACE_NODE_PREREQUISITES (iface) = g_renew (GType,
-                          IFACE_NODE_PREREQUISITES (iface),
-                          IFACE_NODE_N_PREREQUISITES (iface));
+                IFACE_NODE_PREREQUISITES (iface),
+                IFACE_NODE_N_PREREQUISITES (iface));
   prerequisites = IFACE_NODE_PREREQUISITES (iface);
   memmove (prerequisites + i + 1, prerequisites + i,
            sizeof (prerequisites[0]) * (IFACE_NODE_N_PREREQUISITES (iface) - i - 1));
   prerequisites[i] = prerequisite_type;
 
@@ -1554,11 +1557,11 @@
  * interface derivation (which GType doesn't support). An interface can have
  * at most one instantiatable prerequisite type.
  */
 void
 g_type_interface_add_prerequisite (GType interface_type,
-                   GType prerequisite_type)
+           GType prerequisite_type)
 {
   TypeNode *iface, *prerequisite_node;
   IFaceHolder *holders;
 
   g_return_if_fail (G_TYPE_IS_INTERFACE (interface_type));  /* G_TYPE_IS_INTERFACE() is an external call: _U */
@@ -1568,66 +1571,66 @@
   iface = lookup_type_node_I (interface_type);
   prerequisite_node = lookup_type_node_I (prerequisite_type);
   if (!iface || !prerequisite_node || !NODE_IS_IFACE (iface))
     {
       g_warning ("interface type '%s' or prerequisite type '%s' invalid",
-         type_descriptive_name_I (interface_type),
-         type_descriptive_name_I (prerequisite_type));
+     type_descriptive_name_I (interface_type),
+     type_descriptive_name_I (prerequisite_type));
       return;
     }
   G_WRITE_LOCK (&type_rw_lock);
   holders = iface_node_get_holders_L (iface);
   if (holders)
     {
       G_WRITE_UNLOCK (&type_rw_lock);
       g_warning ("unable to add prerequisite '%s' to interface '%s' which is already in use for '%s'",
-         type_descriptive_name_I (prerequisite_type),
-         type_descriptive_name_I (interface_type),
-         type_descriptive_name_I (holders->instance_type));
+     type_descriptive_name_I (prerequisite_type),
+     type_descriptive_name_I (interface_type),
+     type_descriptive_name_I (holders->instance_type));
       return;
     }
   if (prerequisite_node->is_instantiatable)
     {
       guint i;
 
       /* can have at most one publicly installable instantiatable prerequisite */
       for (i = 0; i < IFACE_NODE_N_PREREQUISITES (iface); i++)
-    {
-      TypeNode *prnode = lookup_type_node_I (IFACE_NODE_PREREQUISITES (iface)[i]);
+  {
+    TypeNode *prnode = lookup_type_node_I (IFACE_NODE_PREREQUISITES (iface)[i]);
 
-      if (prnode->is_instantiatable)
-        {
-          G_WRITE_UNLOCK (&type_rw_lock);
-          g_warning ("adding prerequisite '%s' to interface '%s' conflicts with existing prerequisite '%s'",
-             type_descriptive_name_I (prerequisite_type),
-             type_descriptive_name_I (interface_type),
-             type_descriptive_name_I (NODE_TYPE (prnode)));
-          return;
-        }
-    }
+    if (prnode->is_instantiatable)
+      {
+        G_WRITE_UNLOCK (&type_rw_lock);
+        g_warning ("adding prerequisite '%s' to interface '%s' conflicts with existing prerequisite '%s'",
+       type_descriptive_name_I (prerequisite_type),
+       type_descriptive_name_I (interface_type),
+       type_descriptive_name_I (NODE_TYPE (prnode)));
+        return;
+      }
+  }
 
       for (i = 0; i < prerequisite_node->n_supers + 1; i++)
-    type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisite_node->supers[i]));
+  type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisite_node->supers[i]));
       G_WRITE_UNLOCK (&type_rw_lock);
     }
   else if (NODE_IS_IFACE (prerequisite_node))
     {
       GType *prerequisites;
       guint i;
 
       prerequisites = IFACE_NODE_PREREQUISITES (prerequisite_node);
       for (i = 0; i < IFACE_NODE_N_PREREQUISITES (prerequisite_node); i++)
-    type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisites[i]));
+  type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisites[i]));
       type_iface_add_prerequisite_W (iface, prerequisite_node);
       G_WRITE_UNLOCK (&type_rw_lock);
     }
   else
     {
       G_WRITE_UNLOCK (&type_rw_lock);
       g_warning ("prerequisite '%s' for interface '%s' is neither instantiatable nor interface",
-         type_descriptive_name_I (prerequisite_type),
-         type_descriptive_name_I (interface_type));
+     type_descriptive_name_I (prerequisite_type),
+     type_descriptive_name_I (interface_type));
     }
 }
 
 /**
  * g_type_interface_prerequisites:
@@ -1643,11 +1646,11 @@
  *     newly-allocated zero-terminated array of #GType containing
  *     the prerequisites of @interface_type
  */
 GType*
 g_type_interface_prerequisites (GType  interface_type,
-                guint *n_prerequisites)
+        guint *n_prerequisites)
 {
   TypeNode *iface;
 
   g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);
 
@@ -1659,43 +1662,43 @@
       guint i, n = 0;
 
       G_READ_LOCK (&type_rw_lock);
       types = g_new0 (GType, IFACE_NODE_N_PREREQUISITES (iface) + 1);
       for (i = 0; i < IFACE_NODE_N_PREREQUISITES (iface); i++)
-    {
-      GType prerequisite = IFACE_NODE_PREREQUISITES (iface)[i];
-      TypeNode *node = lookup_type_node_I (prerequisite);
-      if (node->is_instantiatable)
+  {
+    GType prerequisite = IFACE_NODE_PREREQUISITES (iface)[i];
+    TypeNode *node = lookup_type_node_I (prerequisite);
+    if (node->is_instantiatable)
             {
               if (!inode || type_node_is_a_L (node, inode))
-            inode = node;
+          inode = node;
             }
-      else
-        types[n++] = NODE_TYPE (node);
-    }
+    else
+      types[n++] = NODE_TYPE (node);
+  }
       if (inode)
-    types[n++] = NODE_TYPE (inode);
+  types[n++] = NODE_TYPE (inode);
 
       if (n_prerequisites)
-    *n_prerequisites = n;
+  *n_prerequisites = n;
       G_READ_UNLOCK (&type_rw_lock);
 
       return types;
     }
   else
     {
       if (n_prerequisites)
-    *n_prerequisites = 0;
+  *n_prerequisites = 0;
 
       return NULL;
     }
 }
 
 
 static IFaceHolder*
 type_iface_peek_holder_L (TypeNode *iface,
-              GType     instance_type)
+        GType     instance_type)
 {
   IFaceHolder *iholder;
 
   g_assert (NODE_IS_IFACE (iface));
 
@@ -1705,12 +1708,12 @@
   return iholder;
 }
 
 static IFaceHolder*
 type_iface_retrieve_holder_info_Wm (TypeNode *iface,
-                    GType     instance_type,
-                    gboolean  need_info)
+            GType     instance_type,
+            gboolean  need_info)
 {
   IFaceHolder *iholder = type_iface_peek_holder_L (iface, instance_type);
 
   if (iholder && !iholder->info && need_info)
     {
@@ -1718,11 +1721,11 @@
 
       g_assert (iholder->plugin != NULL);
 
       type_data_ref_Wm (iface);
       if (iholder->info)
-    INVALID_RECURSION ("g_type_plugin_*", iface->plugin, NODE_NAME (iface));
+  INVALID_RECURSION ("g_type_plugin_*", iface->plugin, NODE_NAME (iface));
 
       memset (&tmp_info, 0, sizeof (tmp_info));
 
       G_WRITE_UNLOCK (&type_rw_lock);
       g_type_plugin_use (iholder->plugin);
@@ -1733,16 +1736,16 @@
 
       check_interface_info_I (iface, instance_type, &tmp_info);
       iholder->info = g_memdup (&tmp_info, sizeof (tmp_info));
     }
 
-  return iholder;   /* we don't modify write lock upon returning NULL */
+  return iholder; /* we don't modify write lock upon returning NULL */
 }
 
 static void
 type_iface_blow_holder_info_Wm (TypeNode *iface,
-                GType     instance_type)
+        GType     instance_type)
 {
   IFaceHolder *iholder = iface_node_get_holders_L (iface);
 
   g_assert (NODE_IS_IFACE (iface));
 
@@ -1803,17 +1806,17 @@
 
   node = lookup_type_node_I (type);
   if (!node || !node->is_instantiatable)
     {
       g_error ("cannot create new instance of invalid (non-instantiatable) type '%s'",
-         type_descriptive_name_I (type));
+     type_descriptive_name_I (type));
     }
   /* G_TYPE_IS_ABSTRACT() is an external call: _U */
   if (!node->mutatable_check_cache && G_TYPE_IS_ABSTRACT (type))
     {
       g_error ("cannot create instance of abstract (non-instantiatable) type '%s'",
-         type_descriptive_name_I (type));
+     type_descriptive_name_I (type));
     }
 
   class = g_type_class_ref (type);
 
   /* We allocate the 'private' areas before the normal instance data, in
@@ -1860,14 +1863,14 @@
     {
       TypeNode *pnode;
 
       pnode = lookup_type_node_I (node->supers[i]);
       if (pnode->data->instance.instance_init)
-    {
-      instance->g_class = pnode->data->instance.class;
-      pnode->data->instance.instance_init (instance, class);
-    }
+  {
+    instance->g_class = pnode->data->instance.class;
+    pnode->data->instance.instance_init (instance, class);
+  }
     }
 
   instance->g_class = class;
   if (node->data->instance.instance_init)
     node->data->instance.instance_init (instance, class);
@@ -1908,18 +1911,18 @@
   class = instance->g_class;
   node = lookup_type_node_I (class->g_type);
   if (!node || !node->is_instantiatable || !node->data || node->data->class.class != (gpointer) class)
     {
       g_warning ("cannot free instance of invalid (non-instantiatable) type '%s'",
-         type_descriptive_name_I (class->g_type));
+     type_descriptive_name_I (class->g_type));
       return;
     }
   /* G_TYPE_IS_ABSTRACT() is an external call: _U */
   if (!node->mutatable_check_cache && G_TYPE_IS_ABSTRACT (NODE_TYPE (node)))
     {
       g_warning ("cannot free instance of abstract (non-instantiatable) type '%s'",
-         NODE_NAME (node));
+     NODE_NAME (node));
       return;
     }
 
   instance->g_class = NULL;
   private_size = node->data->instance.private_size;
@@ -1998,21 +2001,21 @@
  * be used. Note that the write lock is not modified upon a FALSE
  * return.
  */
 static gboolean
 type_iface_vtable_base_init_Wm (TypeNode *iface,
-                TypeNode *node)
+        TypeNode *node)
 {
   IFaceEntry *entry;
   IFaceHolder *iholder;
   GTypeInterface *vtable = NULL;
   TypeNode *pnode;
 
   /* type_iface_retrieve_holder_info_Wm() doesn't modify write lock for returning NULL */
   iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), TRUE);
   if (!iholder)
-    return FALSE;   /* we don't modify write lock upon FALSE */
+    return FALSE; /* we don't modify write lock upon FALSE */
 
   type_iface_ensure_dflt_vtable_Wm (iface);
 
   entry = type_lookup_iface_entry_L (node, iface);
 #ifdef GSTREAMER_LITE
@@ -2023,16 +2026,16 @@
   g_assert (iface->data && entry && entry->vtable == NULL && iholder && iholder->info);
 
   entry->init_state = IFACE_INIT;
 
   pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
-  if (pnode)    /* want to copy over parent iface contents */
+  if (pnode)  /* want to copy over parent iface contents */
     {
       IFaceEntry *pentry = type_lookup_iface_entry_L (pnode, iface);
 
       if (pentry)
-    vtable = g_memdup (pentry->vtable, iface->data->iface.vtable_size);
+  vtable = g_memdup (pentry->vtable, iface->data->iface.vtable_size);
     }
   if (!vtable)
     vtable = g_memdup (iface->data->iface.dflt_vtable, iface->data->iface.vtable_size);
   entry->vtable = vtable;
   vtable->g_type = NODE_TYPE (iface);
@@ -2053,11 +2056,11 @@
  * own interface holder info, i.e. types for which
  * g_type_add_interface*() was called and not children thereof.
  */
 static void
 type_iface_vtable_iface_init_Wm (TypeNode *iface,
-                 TypeNode *node)
+         TypeNode *node)
 {
   IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
   IFaceHolder *iholder = type_iface_peek_holder_L (iface, NODE_TYPE (node));
   GTypeInterface *vtable = NULL;
   guint i;
@@ -2076,11 +2079,11 @@
 
   if (iholder->info->interface_init)
     {
       G_WRITE_UNLOCK (&type_rw_lock);
       if (iholder->info->interface_init)
-    iholder->info->interface_init (vtable, iholder->info->interface_data);
+  iholder->info->interface_init (vtable, iholder->info->interface_data);
       G_WRITE_LOCK (&type_rw_lock);
     }
 
   for (i = 0; i < static_n_iface_check_funcs; i++)
     {
@@ -2093,32 +2096,32 @@
     }
 }
 
 static gboolean
 type_iface_vtable_finalize_Wm (TypeNode       *iface,
-                   TypeNode       *node,
-                   GTypeInterface *vtable)
+             TypeNode       *node,
+             GTypeInterface *vtable)
 {
   IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
   IFaceHolder *iholder;
 
   /* type_iface_retrieve_holder_info_Wm() doesn't modify write lock for returning NULL */
   iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), FALSE);
   if (!iholder)
-    return FALSE;   /* we don't modify write lock upon FALSE */
+    return FALSE; /* we don't modify write lock upon FALSE */
 
   g_assert (entry && entry->vtable == vtable && iholder->info);
 
   entry->vtable = NULL;
   entry->init_state = UNINITIALIZED;
   if (iholder->info->interface_finalize || iface->data->iface.vtable_finalize_base)
     {
       G_WRITE_UNLOCK (&type_rw_lock);
       if (iholder->info->interface_finalize)
-    iholder->info->interface_finalize (vtable, iholder->info->interface_data);
+  iholder->info->interface_finalize (vtable, iholder->info->interface_data);
       if (iface->data->iface.vtable_finalize_base)
-    iface->data->iface.vtable_finalize_base (vtable);
+  iface->data->iface.vtable_finalize_base (vtable);
       G_WRITE_LOCK (&type_rw_lock);
     }
   vtable->g_type = 0;
   vtable->g_instance_type = 0;
   g_free (vtable);
@@ -2128,11 +2131,11 @@
   return TRUE;  /* write lock modified */
 }
 
 static void
 type_class_init_Wm (TypeNode   *node,
-            GTypeClass *pclass)
+        GTypeClass *pclass)
 {
   GSList *slist, *init_slist = NULL;
   GTypeClass *class;
   IFaceEntries *entries;
   IFaceEntry *entry;
@@ -2141,13 +2144,13 @@
 
   /* Accessing data->class will work for instantiable types
    * too because ClassData is a subset of InstanceData
    */
   g_assert (node->is_classed && node->data &&
-        node->data->class.class_size &&
-        !node->data->class.class &&
-        node->data->class.init_state == UNINITIALIZED);
+      node->data->class.class_size &&
+      !node->data->class.class &&
+      node->data->class.init_state == UNINITIALIZED);
   if (node->data->class.class_private_size)
     class = g_malloc0 (ALIGN_STRUCT (node->data->class.class_size) + node->data->class.class_private_size);
   else
     class = g_malloc0 (node->data->class.class_size);
   node->data->class.class = class;
@@ -2159,17 +2162,17 @@
 
       memcpy (class, pclass, pnode->data->class.class_size);
       memcpy (G_STRUCT_MEMBER_P (class, ALIGN_STRUCT (node->data->class.class_size)), G_STRUCT_MEMBER_P (pclass, ALIGN_STRUCT (pnode->data->class.class_size)), pnode->data->class.class_private_size);
 
       if (node->is_instantiatable)
-    {
-      /* We need to initialize the private_size here rather than in
-       * type_data_make_W() since the class init for the parent
-       * class may have changed pnode->data->instance.private_size.
-       */
-      node->data->instance.private_size = pnode->data->instance.private_size;
-    }
+  {
+    /* We need to initialize the private_size here rather than in
+     * type_data_make_W() since the class init for the parent
+     * class may have changed pnode->data->instance.private_size.
+     */
+    node->data->instance.private_size = pnode->data->instance.private_size;
+  }
     }
   class->g_type = NODE_TYPE (node);
 
   G_WRITE_UNLOCK (&type_rw_lock);
 
@@ -2196,47 +2199,47 @@
    */
   pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
 
   i = 0;
   while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL &&
-      i < IFACE_ENTRIES_N_ENTRIES (entries))
+    i < IFACE_ENTRIES_N_ENTRIES (entries))
     {
       entry = &entries->entry[i];
       while (i < IFACE_ENTRIES_N_ENTRIES (entries) &&
-         entry->init_state == IFACE_INIT)
-    {
-      entry++;
-      i++;
-    }
+       entry->init_state == IFACE_INIT)
+  {
+    entry++;
+    i++;
+  }
 
       if (i == IFACE_ENTRIES_N_ENTRIES (entries))
-    break;
+  break;
 
       if (!type_iface_vtable_base_init_Wm (lookup_type_node_I (entry->iface_type), node))
-    {
-      guint j;
-      IFaceEntries *pentries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (pnode);
+  {
+    guint j;
+    IFaceEntries *pentries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (pnode);
 
-      /* need to get this interface from parent, type_iface_vtable_base_init_Wm()
-       * doesn't modify write lock upon FALSE, so entry is still valid;
-       */
-      g_assert (pnode != NULL);
+    /* need to get this interface from parent, type_iface_vtable_base_init_Wm()
+     * doesn't modify write lock upon FALSE, so entry is still valid;
+     */
+    g_assert (pnode != NULL);
 
-      if (pentries)
-        for (j = 0; j < IFACE_ENTRIES_N_ENTRIES (pentries); j++)
-          {
-        IFaceEntry *pentry = &pentries->entry[j];
+    if (pentries)
+      for (j = 0; j < IFACE_ENTRIES_N_ENTRIES (pentries); j++)
+        {
+    IFaceEntry *pentry = &pentries->entry[j];
 
-        if (pentry->iface_type == entry->iface_type)
-          {
-            entry->vtable = pentry->vtable;
-            entry->init_state = INITIALIZED;
-            break;
-          }
-          }
-      g_assert (entry->vtable != NULL);
-    }
+    if (pentry->iface_type == entry->iface_type)
+      {
+        entry->vtable = pentry->vtable;
+        entry->init_state = INITIALIZED;
+        break;
+      }
+        }
+    g_assert (entry->vtable != NULL);
+  }
 
       /* If the write lock was released, additional interface entries might
        * have been inserted into CLASSED_NODE_IFACES_ENTRIES (node); they'll
        * be base-initialized when inserted, so we don't have to worry that
        * we might miss them. Uninitialized entries can only be moved higher
@@ -2265,18 +2268,18 @@
   i = 0;
   while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL)
     {
       entry = &entries->entry[i];
       while (i < IFACE_ENTRIES_N_ENTRIES (entries) &&
-         entry->init_state == INITIALIZED)
-    {
-      entry++;
-      i++;
-    }
+       entry->init_state == INITIALIZED)
+  {
+    entry++;
+    i++;
+  }
 
       if (i == IFACE_ENTRIES_N_ENTRIES (entries))
-    break;
+  break;
 
       type_iface_vtable_iface_init_Wm (lookup_type_node_I (entry->iface_type), node);
 
       /* As in the loop above, additional initialized entries might be inserted
        * if the write lock is released, but that's harmless because the entries
@@ -2300,11 +2303,11 @@
   entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
   for (i = 0; entries != NULL && i < IFACE_ENTRIES_N_ENTRIES (entries); i++)
     {
       IFaceEntry *entry = &entries->entry[i];
       if (entry->vtable)
-    {
+  {
           if (type_iface_vtable_finalize_Wm (lookup_type_node_I (entry->iface_type), node, entry->vtable))
             {
               /* refetch entries, IFACES_ENTRIES might be modified */
               goto reiterate;
             }
@@ -2314,17 +2317,17 @@
                * iface vtable came from parent
                */
               entry->vtable = NULL;
               entry->init_state = UNINITIALIZED;
             }
-    }
+  }
     }
 }
 
 static void
 type_data_finalize_class_U (TypeNode  *node,
-                ClassData *cdata)
+          ClassData *cdata)
 {
   GTypeClass *class = cdata->class;
   TypeNode *bnode;
 
   g_assert (cdata->class && NODE_REFCOUNT (node) == 0);
@@ -2343,18 +2346,18 @@
   g_free (cdata->class);
 }
 
 static void
 type_data_last_unref_Wm (TypeNode *node,
-             gboolean  uncached)
+       gboolean  uncached)
 {
   g_return_if_fail (node != NULL && node->plugin != NULL);
 
   if (!node->data || NODE_REFCOUNT (node) == 0)
     {
       g_warning ("cannot drop last reference to unreferenced type '%s'",
-         NODE_NAME (node));
+     NODE_NAME (node));
       return;
     }
 
   /* call class cache hooks */
   if (node->is_classed && node->data && node->data->class.class && static_n_class_cache_funcs && !uncached)
@@ -2362,23 +2365,23 @@
       guint i;
 
       G_WRITE_UNLOCK (&type_rw_lock);
       G_READ_LOCK (&type_rw_lock);
       for (i = 0; i < static_n_class_cache_funcs; i++)
-    {
-      GTypeClassCacheFunc cache_func = static_class_cache_funcs[i].cache_func;
-      gpointer cache_data = static_class_cache_funcs[i].cache_data;
-      gboolean need_break;
+  {
+    GTypeClassCacheFunc cache_func = static_class_cache_funcs[i].cache_func;
+    gpointer cache_data = static_class_cache_funcs[i].cache_data;
+    gboolean need_break;
 
-      G_READ_UNLOCK (&type_rw_lock);
-      need_break = cache_func (cache_data, node->data->class.class);
-      G_READ_LOCK (&type_rw_lock);
-      if (!node->data || NODE_REFCOUNT (node) == 0)
-        INVALID_RECURSION ("GType class cache function ", cache_func, NODE_NAME (node));
-      if (need_break)
-        break;
-    }
+    G_READ_UNLOCK (&type_rw_lock);
+    need_break = cache_func (cache_data, node->data->class.class);
+    G_READ_LOCK (&type_rw_lock);
+    if (!node->data || NODE_REFCOUNT (node) == 0)
+      INVALID_RECURSION ("GType class cache function ", cache_func, NODE_NAME (node));
+    if (need_break)
+      break;
+  }
       G_READ_UNLOCK (&type_rw_lock);
       G_WRITE_LOCK (&type_rw_lock);
     }
 
   /* may have been re-referenced meanwhile */
@@ -2386,25 +2389,25 @@
     {
       GType ptype = NODE_PARENT_TYPE (node);
       TypeData *tdata;
 
       if (node->is_instantiatable)
-    {
-      /* destroy node->data->instance.mem_chunk */
-    }
+  {
+    /* destroy node->data->instance.mem_chunk */
+  }
 
       tdata = node->data;
       if (node->is_classed && tdata->class.class)
-    {
-      if (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node) != NULL)
-        type_data_finalize_class_ifaces_Wm (node);
-      node->mutatable_check_cache = FALSE;
-      node->data = NULL;
-      G_WRITE_UNLOCK (&type_rw_lock);
-      type_data_finalize_class_U (node, &tdata->class);
-      G_WRITE_LOCK (&type_rw_lock);
-    }
+  {
+    if (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node) != NULL)
+      type_data_finalize_class_ifaces_Wm (node);
+    node->mutatable_check_cache = FALSE;
+    node->data = NULL;
+    G_WRITE_UNLOCK (&type_rw_lock);
+    type_data_finalize_class_U (node, &tdata->class);
+    G_WRITE_LOCK (&type_rw_lock);
+  }
       else if (NODE_IS_IFACE (node) && tdata->iface.dflt_vtable)
         {
           node->mutatable_check_cache = FALSE;
           node->data = NULL;
           if (tdata->iface.dflt_finalize || tdata->iface.vtable_finalize_base)
@@ -2430,11 +2433,11 @@
       g_free (tdata);
 
       G_WRITE_UNLOCK (&type_rw_lock);
       g_type_plugin_unuse (node->plugin);
       if (ptype)
-    type_data_unref_U (lookup_type_node_I (ptype), FALSE);
+  type_data_unref_U (lookup_type_node_I (ptype), FALSE);
       G_WRITE_LOCK (&type_rw_lock);
     }
 }
 
 static inline void
@@ -2447,15 +2450,15 @@
     current = NODE_REFCOUNT (node);
 
     if (current <= 1)
     {
       if (!node->plugin)
-    {
-      g_warning ("static type '%s' unreferenced too often",
-             NODE_NAME (node));
-      return;
-    }
+  {
+    g_warning ("static type '%s' unreferenced too often",
+         NODE_NAME (node));
+    return;
+  }
       else
         {
           /* This is the last reference of a type from a plugin.  We are
            * experimentally disabling support for unloading type
            * plugins, so don't allow the last ref to drop.
@@ -2488,11 +2491,11 @@
  * type, since all classes are routed through the same #GTypeClassCacheFunc
  * chain.
  */
 void
 g_type_add_class_cache_func (gpointer            cache_data,
-                 GTypeClassCacheFunc cache_func)
+           GTypeClassCacheFunc cache_func)
 {
   guint i;
 
   g_return_if_fail (cache_func != NULL);
 
@@ -2513,35 +2516,35 @@
  * maintained by @cache_func has to be empty when calling
  * g_type_remove_class_cache_func() to avoid leaks.
  */
 void
 g_type_remove_class_cache_func (gpointer            cache_data,
-                GTypeClassCacheFunc cache_func)
+        GTypeClassCacheFunc cache_func)
 {
   gboolean found_it = FALSE;
   guint i;
 
   g_return_if_fail (cache_func != NULL);
 
   G_WRITE_LOCK (&type_rw_lock);
   for (i = 0; i < static_n_class_cache_funcs; i++)
     if (static_class_cache_funcs[i].cache_data == cache_data &&
-    static_class_cache_funcs[i].cache_func == cache_func)
+  static_class_cache_funcs[i].cache_func == cache_func)
       {
-    static_n_class_cache_funcs--;
-    memmove (static_class_cache_funcs + i,
+  static_n_class_cache_funcs--;
+  memmove (static_class_cache_funcs + i,
                  static_class_cache_funcs + i + 1,
                  sizeof (static_class_cache_funcs[0]) * (static_n_class_cache_funcs - i));
-    static_class_cache_funcs = g_renew (ClassCacheFunc, static_class_cache_funcs, static_n_class_cache_funcs);
-    found_it = TRUE;
-    break;
+  static_class_cache_funcs = g_renew (ClassCacheFunc, static_class_cache_funcs, static_n_class_cache_funcs);
+  found_it = TRUE;
+  break;
       }
   G_WRITE_UNLOCK (&type_rw_lock);
 
   if (!found_it)
     g_warning (G_STRLOC ": cannot remove unregistered class cache func %p with data %p",
-           cache_func, cache_data);
+         cache_func, cache_data);
 }
 
 
 /**
  * g_type_add_interface_check: (skip)
@@ -2560,12 +2563,12 @@
  * interfaces.
  *
  * Since: 2.4
  */
 void
-g_type_add_interface_check (gpointer                check_data,
-                            GTypeInterfaceCheckFunc check_func)
+g_type_add_interface_check (gpointer              check_data,
+          GTypeInterfaceCheckFunc check_func)
 {
   guint i;
 
   g_return_if_fail (check_func != NULL);
 
@@ -2587,35 +2590,35 @@
  *
  * Since: 2.4
  */
 void
 g_type_remove_interface_check (gpointer                check_data,
-                               GTypeInterfaceCheckFunc check_func)
+             GTypeInterfaceCheckFunc check_func)
 {
   gboolean found_it = FALSE;
   guint i;
 
   g_return_if_fail (check_func != NULL);
 
   G_WRITE_LOCK (&type_rw_lock);
   for (i = 0; i < static_n_iface_check_funcs; i++)
     if (static_iface_check_funcs[i].check_data == check_data &&
-    static_iface_check_funcs[i].check_func == check_func)
+  static_iface_check_funcs[i].check_func == check_func)
       {
-    static_n_iface_check_funcs--;
-    memmove (static_iface_check_funcs + i,
+  static_n_iface_check_funcs--;
+  memmove (static_iface_check_funcs + i,
                  static_iface_check_funcs + i + 1,
                  sizeof (static_iface_check_funcs[0]) * (static_n_iface_check_funcs - i));
-    static_iface_check_funcs = g_renew (IFaceCheckFunc, static_iface_check_funcs, static_n_iface_check_funcs);
-    found_it = TRUE;
-    break;
+  static_iface_check_funcs = g_renew (IFaceCheckFunc, static_iface_check_funcs, static_n_iface_check_funcs);
+  found_it = TRUE;
+  break;
       }
   G_WRITE_UNLOCK (&type_rw_lock);
 
   if (!found_it)
     g_warning (G_STRLOC ": cannot remove unregistered class check func %p with data %p",
-           check_func, check_data);
+         check_func, check_data);
 }
 
 /* --- type registration --- */
 /**
  * g_type_register_fundamental:
@@ -2635,14 +2638,14 @@
  *
  * Returns: the predefined type identifier
  */
 GType
 g_type_register_fundamental (GType                       type_id,
-                             const gchar                *type_name,
-                             const GTypeInfo            *info,
-                             const GTypeFundamentalInfo *finfo,
-                 GTypeFlags          flags)
+           const gchar                *type_name,
+           const GTypeInfo            *info,
+           const GTypeFundamentalInfo *finfo,
+           GTypeFlags      flags)
 {
   TypeNode *node;
 
   g_assert_type_system_initialized ();
   g_return_val_if_fail (type_id > 0, 0);
@@ -2654,36 +2657,36 @@
     return 0;
   if ((type_id & TYPE_ID_MASK) ||
       type_id > G_TYPE_FUNDAMENTAL_MAX)
     {
       g_warning ("attempt to register fundamental type '%s' with invalid type id (%" G_GSIZE_FORMAT ")",
-         type_name,
-         type_id);
+     type_name,
+     type_id);
       return 0;
     }
   if ((finfo->type_flags & G_TYPE_FLAG_INSTANTIATABLE) &&
       !(finfo->type_flags & G_TYPE_FLAG_CLASSED))
     {
       g_warning ("cannot register instantiatable fundamental type '%s' as non-classed",
-         type_name);
+     type_name);
       return 0;
     }
   if (lookup_type_node_I (type_id))
     {
       g_warning ("cannot register existing fundamental type '%s' (as '%s')",
-         type_descriptive_name_I (type_id),
-         type_name);
+     type_descriptive_name_I (type_id),
+     type_name);
       return 0;
     }
 
   G_WRITE_LOCK (&type_rw_lock);
   node = type_node_fundamental_new_W (type_id, type_name, finfo->type_flags);
   type_add_flags_W (node, flags);
 
   if (check_type_info_I (NULL, NODE_FUNDAMENTAL_TYPE (node), type_name, info))
     type_data_make_W (node, info,
-              check_value_table_I (type_name, info->value_table) ? info->value_table : NULL);
+          check_value_table_I (type_name, info->value_table) ? info->value_table : NULL);
   G_WRITE_UNLOCK (&type_rw_lock);
 
   return NODE_TYPE (node);
 }
 
@@ -2706,16 +2709,16 @@
  *
  * Returns: the new type identifier
  */
 GType
 g_type_register_static_simple (GType             parent_type,
-                               const gchar      *type_name,
-                               guint             class_size,
-                               GClassInitFunc    class_init,
-                               guint             instance_size,
-                               GInstanceInitFunc instance_init,
-                   GTypeFlags    flags)
+             const gchar      *type_name,
+             guint             class_size,
+             GClassInitFunc    class_init,
+             guint             instance_size,
+             GInstanceInitFunc instance_init,
+             GTypeFlags  flags)
 {
   GTypeInfo info;
 
   /* Instances are not allowed to be larger than this. If you have a big
    * fixed-length array or something, point to it instead.
@@ -2752,13 +2755,13 @@
  *
  * Returns: the new type identifier
  */
 GType
 g_type_register_static (GType            parent_type,
-                        const gchar     *type_name,
-                        const GTypeInfo *info,
-            GTypeFlags   flags)
+      const gchar     *type_name,
+      const GTypeInfo *info,
+      GTypeFlags   flags)
 {
   TypeNode *pnode, *node;
   GType type = 0;
 
   g_assert_type_system_initialized ();
@@ -2770,11 +2773,11 @@
       !check_derivation_I (parent_type, type_name))
     return 0;
   if (info->class_finalize)
     {
       g_warning ("class finalizer specified for static type '%s'",
-         type_name);
+     type_name);
       return 0;
     }
 
   pnode = lookup_type_node_I (parent_type);
   G_WRITE_LOCK (&type_rw_lock);
@@ -2783,11 +2786,11 @@
     {
       node = type_node_new_W (pnode, type_name, NULL);
       type_add_flags_W (node, flags);
       type = NODE_TYPE (node);
       type_data_make_W (node, info,
-            check_value_table_I (type_name, info->value_table) ? info->value_table : NULL);
+      check_value_table_I (type_name, info->value_table) ? info->value_table : NULL);
     }
   G_WRITE_UNLOCK (&type_rw_lock);
 
   return type;
 }
@@ -2807,13 +2810,13 @@
  *
  * Returns: the new type identifier or #G_TYPE_INVALID if registration failed
  */
 GType
 g_type_register_dynamic (GType        parent_type,
-             const gchar *type_name,
-             GTypePlugin *plugin,
-             GTypeFlags   flags)
+       const gchar *type_name,
+       GTypePlugin *plugin,
+       GTypeFlags   flags)
 {
   TypeNode *pnode, *node;
   GType type;
 
   g_assert_type_system_initialized ();
@@ -2847,12 +2850,12 @@
  * The information contained in the #GInterfaceInfo structure
  * pointed to by @info is used to manage the relationship.
  */
 void
 g_type_add_interface_static (GType                 instance_type,
-                 GType                 interface_type,
-                 const GInterfaceInfo *info)
+           GType                 interface_type,
+           const GInterfaceInfo *info)
 {
   /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
   g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
   g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
 
@@ -2883,12 +2886,12 @@
  * contained in the #GTypePlugin structure pointed to by @plugin
  * is used to manage the relationship.
  */
 void
 g_type_add_interface_dynamic (GType        instance_type,
-                  GType        interface_type,
-                  GTypePlugin *plugin)
+            GType        interface_type,
+            GTypePlugin *plugin)
 {
   TypeNode *node;
   /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
   g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
   g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
@@ -2933,11 +2936,11 @@
   /* optimize for common code path */
   node = lookup_type_node_I (type);
   if (!node || !node->is_classed)
     {
       g_warning ("cannot retrieve class for invalid (unclassed) type '%s'",
-         type_descriptive_name_I (type));
+     type_descriptive_name_I (type));
       return NULL;
     }
 
   if (G_LIKELY (type_data_ref_U (node)))
     {
@@ -2997,11 +3000,11 @@
   node = lookup_type_node_I (class->g_type);
   if (node && node->is_classed && NODE_REFCOUNT (node))
     type_data_unref_U (node, FALSE);
   else
     g_warning ("cannot unreference class of invalid (unclassed) type '%s'",
-           type_descriptive_name_I (class->g_type));
+         type_descriptive_name_I (class->g_type));
 }
 
 /**
  * g_type_class_unref_uncached: (skip)
  * @g_class: (type GObject.TypeClass): a #GTypeClass structure to unref
@@ -3022,11 +3025,11 @@
   node = lookup_type_node_I (class->g_type);
   if (node && node->is_classed && NODE_REFCOUNT (node))
     type_data_unref_U (node, TRUE);
   else
     g_warning ("cannot unreference class of invalid (unclassed) type '%s'",
-           type_descriptive_name_I (class->g_type));
+         type_descriptive_name_I (class->g_type));
 }
 
 /**
  * g_type_class_peek:
  * @type: type ID of a classed type
@@ -3142,11 +3145,11 @@
  *     structure of @iface_type if implemented by @instance_class, %NULL
  *     otherwise
  */
 gpointer
 g_type_interface_peek (gpointer instance_class,
-               GType    iface_type)
+           GType    iface_type)
 {
   TypeNode *node;
   TypeNode *iface;
   gpointer vtable = NULL;
   GTypeClass *class = instance_class;
@@ -3232,11 +3235,11 @@
   if (!node || !NODE_IS_IFACE (node) ||
       (node->data && NODE_REFCOUNT (node) == 0))
     {
       G_WRITE_UNLOCK (&type_rw_lock);
       g_warning ("cannot retrieve default vtable for invalid or non-interface type '%s'",
-         type_descriptive_name_I (g_type));
+     type_descriptive_name_I (g_type));
       return NULL;
     }
 
   if (!node->data || !node->data->iface.dflt_vtable)
     {
@@ -3286,11 +3289,11 @@
 }
 
 /**
  * g_type_default_interface_unref:
  * @g_iface: (type GObject.TypeInterface): the default vtable
- *     structure for a interface, as returned by g_type_default_interface_ref()
+ *     structure for an interface, as returned by g_type_default_interface_ref()
  *
  * Decrements the reference count for the type corresponding to the
  * interface default vtable @g_iface. If the type is dynamic, then
  * when no one is using the interface and all references have
  * been released, the finalize function for the interface's default
@@ -3309,11 +3312,11 @@
   node = lookup_type_node_I (vtable->g_type);
   if (node && NODE_IS_IFACE (node))
     type_data_unref_U (node, FALSE);
   else
     g_warning ("cannot unreference invalid interface default vtable for '%s'",
-           type_descriptive_name_I (vtable->g_type));
+         type_descriptive_name_I (vtable->g_type));
 }
 
 /**
  * g_type_name:
  * @type: type to return name for
@@ -3356,13 +3359,13 @@
   return node ? node->qname : 0;
 }
 
 /**
  * g_type_from_name:
- * @name: type name to lookup
+ * @name: type name to look up
  *
- * Lookup the type ID from a given type name, returning 0 if no type
+ * Look up the type ID from a given type name, returning 0 if no type
  * has been registered under this name (this is the preferred method
  * to find out by name whether a specific type has been registered
  * yet).
  *
  * Returns: corresponding type ID or 0
@@ -3434,39 +3437,39 @@
  *
  * Returns: immediate child of @root_type and anchestor of @leaf_type
  */
 GType
 g_type_next_base (GType type,
-          GType base_type)
+      GType base_type)
 {
   GType atype = 0;
   TypeNode *node;
 
   node = lookup_type_node_I (type);
   if (node)
     {
       TypeNode *base_node = lookup_type_node_I (base_type);
 
       if (base_node && base_node->n_supers < node->n_supers)
-    {
-      guint n = node->n_supers - base_node->n_supers;
+  {
+    guint n = node->n_supers - base_node->n_supers;
 
-      if (node->supers[n] == base_type)
-        atype = node->supers[n - 1];
-    }
+    if (node->supers[n] == base_type)
+      atype = node->supers[n - 1];
+  }
     }
 
   return atype;
 }
 
 static inline gboolean
 type_node_check_conformities_UorL (TypeNode *node,
-                   TypeNode *iface_node,
-                   /*        support_inheritance */
-                   gboolean  support_interfaces,
-                   gboolean  support_prerequisites,
-                   gboolean  have_lock)
+           TypeNode *iface_node,
+           /*        support_inheritance */
+           gboolean  support_interfaces,
+           gboolean  support_prerequisites,
+           gboolean  have_lock)
 {
   gboolean match;
 
   if (/* support_inheritance && */
       NODE_IS_ANCESTOR (iface_node, node))
@@ -3476,45 +3479,45 @@
   support_prerequisites = support_prerequisites && NODE_IS_IFACE (node);
   match = FALSE;
   if (support_interfaces)
     {
       if (have_lock)
-    {
-      if (type_lookup_iface_entry_L (node, iface_node))
-        match = TRUE;
-    }
+  {
+    if (type_lookup_iface_entry_L (node, iface_node))
+      match = TRUE;
+  }
       else
-    {
-      if (type_lookup_iface_vtable_I (node, iface_node, NULL))
-        match = TRUE;
-    }
+  {
+    if (type_lookup_iface_vtable_I (node, iface_node, NULL))
+      match = TRUE;
+  }
     }
   if (!match &&
       support_prerequisites)
     {
       if (!have_lock)
-    G_READ_LOCK (&type_rw_lock);
+  G_READ_LOCK (&type_rw_lock);
       if (support_prerequisites && type_lookup_prerequisite_L (node, NODE_TYPE (iface_node)))
-    match = TRUE;
+  match = TRUE;
       if (!have_lock)
-    G_READ_UNLOCK (&type_rw_lock);
+  G_READ_UNLOCK (&type_rw_lock);
     }
   return match;
 }
 
 static gboolean
 type_node_is_a_L (TypeNode *node,
-          TypeNode *iface_node)
+      TypeNode *iface_node)
 {
   return type_node_check_conformities_UorL (node, iface_node, TRUE, TRUE, TRUE);
 }
 
 static inline gboolean
 type_node_conforms_to_U (TypeNode *node,
-             TypeNode *iface_node,
-             gboolean  support_interfaces,
-             gboolean  support_prerequisites)
+       TypeNode *iface_node,
+       gboolean  support_interfaces,
+       gboolean  support_prerequisites)
 {
   return type_node_check_conformities_UorL (node, iface_node, support_interfaces, support_prerequisites, FALSE);
 }
 
 /**
@@ -3529,11 +3532,11 @@
  *
  * Returns: %TRUE if @type is a @is_a_type
  */
 gboolean
 g_type_is_a (GType type,
-         GType iface_type)
+       GType iface_type)
 {
   TypeNode *node, *iface_node;
   gboolean is_a;
 
   if (type == iface_type)
@@ -3558,11 +3561,11 @@
  * Returns: (array length=n_children) (transfer full): Newly allocated
  *     and 0-terminated array of child types, free with g_free()
  */
 GType*
 g_type_children (GType  type,
-         guint *n_children)
+     guint *n_children)
 {
   TypeNode *node;
 
   node = lookup_type_node_I (type);
   if (node)
@@ -3570,23 +3573,23 @@
       GType *children;
 
       G_READ_LOCK (&type_rw_lock);  /* ->children is relocatable */
       children = g_new (GType, node->n_children + 1);
       if (node->n_children != 0)
-      memcpy (children, node->children, sizeof (GType) * node->n_children);
+        memcpy (children, node->children, sizeof (GType) * node->n_children);
       children[node->n_children] = 0;
 
       if (n_children)
-    *n_children = node->n_children;
+  *n_children = node->n_children;
       G_READ_UNLOCK (&type_rw_lock);
 
       return children;
     }
   else
     {
       if (n_children)
-    *n_children = 0;
+  *n_children = 0;
 
       return NULL;
     }
 }
 
@@ -3602,11 +3605,11 @@
  * Returns: (array length=n_interfaces) (transfer full): Newly allocated
  *     and 0-terminated array of interface types, free with g_free()
  */
 GType*
 g_type_interfaces (GType  type,
-           guint *n_interfaces)
+       guint *n_interfaces)
 {
   TypeNode *node;
 
   node = lookup_type_node_I (type);
   if (node && node->is_instantiatable)
@@ -3616,32 +3619,32 @@
       guint i;
 
       G_READ_LOCK (&type_rw_lock);
       entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
       if (entries)
-    {
-      ifaces = g_new (GType, IFACE_ENTRIES_N_ENTRIES (entries) + 1);
-      for (i = 0; i < IFACE_ENTRIES_N_ENTRIES (entries); i++)
-        ifaces[i] = entries->entry[i].iface_type;
-    }
+  {
+    ifaces = g_new (GType, IFACE_ENTRIES_N_ENTRIES (entries) + 1);
+    for (i = 0; i < IFACE_ENTRIES_N_ENTRIES (entries); i++)
+      ifaces[i] = entries->entry[i].iface_type;
+  }
       else
-    {
-      ifaces = g_new (GType, 1);
-      i = 0;
-    }
+  {
+    ifaces = g_new (GType, 1);
+    i = 0;
+  }
       ifaces[i] = 0;
 
       if (n_interfaces)
-    *n_interfaces = i;
+  *n_interfaces = i;
       G_READ_UNLOCK (&type_rw_lock);
 
       return ifaces;
     }
   else
     {
       if (n_interfaces)
-    *n_interfaces = 0;
+  *n_interfaces = 0;
 
       return NULL;
     }
 }
 
@@ -3657,36 +3660,36 @@
   gpointer data;
 };
 
 static inline gpointer
 type_get_qdata_L (TypeNode *node,
-          GQuark    quark)
+      GQuark    quark)
 {
   GData *gdata = node->global_gdata;
 
   if (quark && gdata && gdata->n_qdatas)
     {
       QData *qdatas = gdata->qdatas - 1;
       guint n_qdatas = gdata->n_qdatas;
 
       do
-    {
-      guint i;
-      QData *check;
-
-      i = (n_qdatas + 1) / 2;
-      check = qdatas + i;
-      if (quark == check->quark)
-        return check->data;
-      else if (quark > check->quark)
-        {
-          n_qdatas -= i;
-          qdatas = check;
-        }
-      else /* if (quark < check->quark) */
-        n_qdatas = i - 1;
-    }
+  {
+    guint i;
+    QData *check;
+
+    i = (n_qdatas + 1) / 2;
+    check = qdatas + i;
+    if (quark == check->quark)
+      return check->data;
+    else if (quark > check->quark)
+      {
+        n_qdatas -= i;
+        qdatas = check;
+      }
+    else /* if (quark < check->quark) */
+      n_qdatas = i - 1;
+  }
       while (n_qdatas);
     }
   return NULL;
 }
 
@@ -3704,11 +3707,11 @@
  *
  * Returns: (transfer none): the data, or %NULL if no data was found
  */
 gpointer
 g_type_get_qdata (GType  type,
-          GQuark quark)
+      GQuark quark)
 {
   TypeNode *node;
   gpointer data;
 
   node = lookup_type_node_I (type);
@@ -3726,12 +3729,12 @@
   return data;
 }
 
 static inline void
 type_set_qdata_W (TypeNode *node,
-          GQuark    quark,
-          gpointer  data)
+      GQuark    quark,
+      gpointer  data)
 {
   GData *gdata;
   QData *qdata;
   guint i;
 
@@ -3743,12 +3746,12 @@
   /* try resetting old data */
   qdata = gdata->qdatas;
   for (i = 0; i < gdata->n_qdatas; i++)
     if (qdata[i].quark == quark)
       {
-    qdata[i].data = data;
-    return;
+  qdata[i].data = data;
+  return;
       }
 
   /* add new entry */
   gdata->n_qdatas++;
   gdata->qdatas = g_renew (QData, gdata->qdatas, gdata->n_qdatas);
@@ -3769,12 +3772,12 @@
  *
  * Attaches arbitrary data to a type.
  */
 void
 g_type_set_qdata (GType    type,
-          GQuark   quark,
-          gpointer data)
+      GQuark   quark,
+      gpointer data)
 {
   TypeNode *node;
 
   g_return_if_fail (quark != 0);
 
@@ -3789,11 +3792,11 @@
     g_return_if_fail (node != NULL);
 }
 
 static void
 type_add_flags_W (TypeNode  *node,
-          GTypeFlags flags)
+      GTypeFlags flags)
 {
   guint dflags;
 
   g_return_if_fail ((flags & ~TYPE_FLAG_MASK) == 0);
   g_return_if_fail (node != NULL);
@@ -3818,11 +3821,11 @@
  * #GTypeQuery structure should be considered constant and have to be
  * left untouched.
  */
 void
 g_type_query (GType       type,
-          GTypeQuery *query)
+        GTypeQuery *query)
 {
   TypeNode *node;
 
   g_return_if_fail (query != NULL);
 
@@ -3831,17 +3834,17 @@
   node = lookup_type_node_I (type);
   if (node && node->is_classed && !node->plugin)
     {
       /* type is classed and probably even instantiatable */
       G_READ_LOCK (&type_rw_lock);
-      if (node->data)   /* type is static or referenced */
-    {
-      query->type = NODE_TYPE (node);
-      query->type_name = NODE_NAME (node);
-      query->class_size = node->data->class.class_size;
-      query->instance_size = node->is_instantiatable ? node->data->instance.instance_size : 0;
-    }
+      if (node->data) /* type is static or referenced */
+  {
+    query->type = NODE_TYPE (node);
+    query->type_name = NODE_NAME (node);
+    query->class_size = node->data->class.class_size;
+    query->instance_size = node->is_instantiatable ? node->data->instance.instance_size : 0;
+  }
       G_READ_UNLOCK (&type_rw_lock);
     }
 }
 
 /**
@@ -3874,11 +3877,11 @@
 }
 
 /* --- implementation details --- */
 gboolean
 g_type_test_flags (GType type,
-           guint flags)
+       guint flags)
 {
   TypeNode *node;
   gboolean result = FALSE;
 
   node = lookup_type_node_I (type);
@@ -3886,26 +3889,26 @@
     {
       guint fflags = flags & TYPE_FUNDAMENTAL_FLAG_MASK;
       guint tflags = flags & TYPE_FLAG_MASK;
 
       if (fflags)
-    {
-      GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (node);
+  {
+    GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (node);
 
-      fflags = (finfo->type_flags & fflags) == fflags;
-    }
+    fflags = (finfo->type_flags & fflags) == fflags;
+  }
       else
-    fflags = TRUE;
+  fflags = TRUE;
 
       if (tflags)
-    {
-      G_READ_LOCK (&type_rw_lock);
-      tflags = (tflags & GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))) == tflags;
-      G_READ_UNLOCK (&type_rw_lock);
-    }
+  {
+    G_READ_LOCK (&type_rw_lock);
+    tflags = (tflags & GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))) == tflags;
+    G_READ_UNLOCK (&type_rw_lock);
+  }
       else
-    tflags = TRUE;
+  tflags = TRUE;
 
       result = tflags && fflags;
     }
 
   return result;
@@ -3943,16 +3946,16 @@
  * Returns: (transfer none): the #GTypePlugin for the dynamic
  *     interface @interface_type of @instance_type
  */
 GTypePlugin*
 g_type_interface_get_plugin (GType instance_type,
-                 GType interface_type)
+           GType interface_type)
 {
   TypeNode *node;
   TypeNode *iface;
 
-  g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);    /* G_TYPE_IS_INTERFACE() is an external call: _U */
+  g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);  /* G_TYPE_IS_INTERFACE() is an external call: _U */
 
   node = lookup_type_node_I (instance_type);
   iface = lookup_type_node_I (interface_type);
   if (node && iface)
     {
@@ -3961,11 +3964,11 @@
 
       G_READ_LOCK (&type_rw_lock);
 
       iholder = iface_node_get_holders_L (iface);
       while (iholder && iholder->instance_type != instance_type)
-    iholder = iholder->next;
+  iholder = iholder->next;
       plugin = iholder ? iholder->plugin : NULL;
 
       G_READ_UNLOCK (&type_rw_lock);
 
       return plugin;
@@ -4019,11 +4022,11 @@
   return node ? NODE_FUNDAMENTAL_TYPE (node) : 0;
 }
 
 gboolean
 g_type_check_instance_is_a (GTypeInstance *type_instance,
-                GType          iface_type)
+          GType          iface_type)
 {
   TypeNode *node, *iface;
   gboolean check;
 
   if (!type_instance || !type_instance->g_class)
@@ -4047,11 +4050,11 @@
   return node && (NODE_FUNDAMENTAL_TYPE(node) == fundamental_type);
 }
 
 gboolean
 g_type_check_class_is_a (GTypeClass *type_class,
-             GType       is_a_type)
+       GType       is_a_type)
 {
   TypeNode *node, *iface;
   gboolean check;
 
   if (!type_class)
@@ -4064,46 +4067,46 @@
   return check;
 }
 
 GTypeInstance*
 g_type_check_instance_cast (GTypeInstance *type_instance,
-                GType          iface_type)
+          GType          iface_type)
 {
   if (type_instance)
     {
       if (type_instance->g_class)
-    {
-      TypeNode *node, *iface;
-      gboolean is_instantiatable, check;
-
-      node = lookup_type_node_I (type_instance->g_class->g_type);
-      is_instantiatable = node && node->is_instantiatable;
-      iface = lookup_type_node_I (iface_type);
-      check = is_instantiatable && iface && type_node_conforms_to_U (node, iface, TRUE, FALSE);
-      if (check)
-        return type_instance;
-
-      if (is_instantiatable)
-        g_warning ("invalid cast from '%s' to '%s'",
-               type_descriptive_name_I (type_instance->g_class->g_type),
-               type_descriptive_name_I (iface_type));
-      else
-        g_warning ("invalid uninstantiatable type '%s' in cast to '%s'",
-               type_descriptive_name_I (type_instance->g_class->g_type),
-               type_descriptive_name_I (iface_type));
-    }
-      else
-    g_warning ("invalid unclassed pointer in cast to '%s'",
+  {
+    TypeNode *node, *iface;
+    gboolean is_instantiatable, check;
+
+    node = lookup_type_node_I (type_instance->g_class->g_type);
+    is_instantiatable = node && node->is_instantiatable;
+    iface = lookup_type_node_I (iface_type);
+    check = is_instantiatable && iface && type_node_conforms_to_U (node, iface, TRUE, FALSE);
+    if (check)
+      return type_instance;
+
+    if (is_instantiatable)
+      g_warning ("invalid cast from '%s' to '%s'",
+           type_descriptive_name_I (type_instance->g_class->g_type),
            type_descriptive_name_I (iface_type));
+    else
+      g_warning ("invalid uninstantiatable type '%s' in cast to '%s'",
+           type_descriptive_name_I (type_instance->g_class->g_type),
+           type_descriptive_name_I (iface_type));
+  }
+      else
+  g_warning ("invalid unclassed pointer in cast to '%s'",
+       type_descriptive_name_I (iface_type));
     }
 
   return type_instance;
 }
 
 GTypeClass*
 g_type_check_class_cast (GTypeClass *type_class,
-             GType       is_a_type)
+       GType       is_a_type)
 {
   if (type_class)
     {
       TypeNode *node, *iface;
       gboolean is_classed, check;
@@ -4111,24 +4114,24 @@
       node = lookup_type_node_I (type_class->g_type);
       is_classed = node && node->is_classed;
       iface = lookup_type_node_I (is_a_type);
       check = is_classed && iface && type_node_conforms_to_U (node, iface, FALSE, FALSE);
       if (check)
-    return type_class;
+  return type_class;
 
       if (is_classed)
-    g_warning ("invalid class cast from '%s' to '%s'",
-           type_descriptive_name_I (type_class->g_type),
-           type_descriptive_name_I (is_a_type));
+  g_warning ("invalid class cast from '%s' to '%s'",
+       type_descriptive_name_I (type_class->g_type),
+       type_descriptive_name_I (is_a_type));
       else
-    g_warning ("invalid unclassed type '%s' in class cast to '%s'",
-           type_descriptive_name_I (type_class->g_type),
-           type_descriptive_name_I (is_a_type));
+  g_warning ("invalid unclassed type '%s' in class cast to '%s'",
+       type_descriptive_name_I (type_class->g_type),
+       type_descriptive_name_I (is_a_type));
     }
   else
     g_warning ("invalid class cast from (NULL) pointer to '%s'",
-           type_descriptive_name_I (is_a_type));
+         type_descriptive_name_I (is_a_type));
   return type_class;
 }
 
 /**
  * g_type_check_instance:
@@ -4146,21 +4149,21 @@
    * conveniently elaborated on instance checks
    */
   if (type_instance)
     {
       if (type_instance->g_class)
-    {
-      TypeNode *node = lookup_type_node_I (type_instance->g_class->g_type);
+  {
+    TypeNode *node = lookup_type_node_I (type_instance->g_class->g_type);
 
-      if (node && node->is_instantiatable)
-        return TRUE;
+    if (node && node->is_instantiatable)
+      return TRUE;
 
-      g_warning ("instance of invalid non-instantiatable type '%s'",
-             type_descriptive_name_I (type_instance->g_class->g_type));
-    }
+    g_warning ("instance of invalid non-instantiatable type '%s'",
+         type_descriptive_name_I (type_instance->g_class->g_type));
+  }
       else
-    g_warning ("instance with invalid (NULL) class pointer");
+  g_warning ("instance with invalid (NULL) class pointer");
     }
   else
     g_warning ("invalid (NULL) pointer instance");
 
   return FALSE;
@@ -4180,29 +4183,29 @@
   G_READ_LOCK (&type_rw_lock);
  restart_check:
   if (node)
     {
       if (node->data && NODE_REFCOUNT (node) > 0 &&
-      node->data->common.value_table->value_init)
-    tflags = GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags));
+    node->data->common.value_table->value_init)
+  tflags = GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags));
       else if (NODE_IS_IFACE (node))
-    {
-      guint i;
+  {
+    guint i;
 
-      for (i = 0; i < IFACE_NODE_N_PREREQUISITES (node); i++)
-        {
-          GType prtype = IFACE_NODE_PREREQUISITES (node)[i];
-          TypeNode *prnode = lookup_type_node_I (prtype);
+    for (i = 0; i < IFACE_NODE_N_PREREQUISITES (node); i++)
+      {
+        GType prtype = IFACE_NODE_PREREQUISITES (node)[i];
+        TypeNode *prnode = lookup_type_node_I (prtype);
 
-          if (prnode->is_instantiatable)
-        {
-          type = prtype;
-          node = lookup_type_node_I (type);
-          goto restart_check;
-        }
-        }
+        if (prnode->is_instantiatable)
+    {
+      type = prtype;
+      node = lookup_type_node_I (type);
+      goto restart_check;
     }
+      }
+  }
     }
   G_READ_UNLOCK (&type_rw_lock);
 
   return !(tflags & G_TYPE_FLAG_VALUE_ABSTRACT);
 }
@@ -4219,11 +4222,11 @@
   return value && type_check_is_value_type_U (value->g_type);
 }
 
 gboolean
 g_type_check_value_holds (const GValue *value,
-              GType         type)
+        GType         type)
 {
   return value && type_check_is_value_type_U (value->g_type) && g_type_is_a (value->g_type, type);
 }
 
 /**
@@ -4255,28 +4258,28 @@
   has_refed_data = node && node->data && NODE_REFCOUNT (node) > 0;
   has_table = has_refed_data && node->data->common.value_table->value_init;
   if (has_refed_data)
     {
       if (has_table)
-    vtable = node->data->common.value_table;
+  vtable = node->data->common.value_table;
       else if (NODE_IS_IFACE (node))
-    {
-      guint i;
+  {
+    guint i;
 
-      for (i = 0; i < IFACE_NODE_N_PREREQUISITES (node); i++)
-        {
-          GType prtype = IFACE_NODE_PREREQUISITES (node)[i];
-          TypeNode *prnode = lookup_type_node_I (prtype);
+    for (i = 0; i < IFACE_NODE_N_PREREQUISITES (node); i++)
+      {
+        GType prtype = IFACE_NODE_PREREQUISITES (node)[i];
+        TypeNode *prnode = lookup_type_node_I (prtype);
 
-          if (prnode->is_instantiatable)
-        {
-          type = prtype;
-          node = lookup_type_node_I (type);
-          goto restart_table_peek;
-        }
-        }
+        if (prnode->is_instantiatable)
+    {
+      type = prtype;
+      node = lookup_type_node_I (type);
+      goto restart_table_peek;
     }
+      }
+  }
     }
 
   G_READ_UNLOCK (&type_rw_lock);
 
   if (vtable)
@@ -4284,11 +4287,11 @@
 
   if (!node)
     g_warning (G_STRLOC ": type id '%" G_GSIZE_FORMAT "' is invalid", type);
   if (!has_refed_data)
     g_warning ("can't peek value table for type '%s' which is not currently referenced",
-           type_descriptive_name_I (type));
+         type_descriptive_name_I (type));
 
   return NULL;
 }
 
 const gchar *
@@ -4351,18 +4354,20 @@
  * If you need to enable debugging features, use the GOBJECT_DEBUG
  * environment variable.
  *
  * Deprecated: 2.36: the type system is now initialised automatically
  */
+G_GNUC_BEGIN_IGNORE_DEPRECATIONS
 void
 g_type_init_with_debug_flags (GTypeDebugFlags debug_flags)
 {
   g_assert_type_system_initialized ();
 
   if (debug_flags)
     g_message ("g_type_init_with_debug_flags() is no longer supported.  Use the GOBJECT_DEBUG environment variable.");
 }
+G_GNUC_END_IGNORE_DEPRECATIONS
 
 /**
  * g_type_init:
  *
  * This function used to initialise the type system.  Since GLib 2.36,
@@ -4394,11 +4399,11 @@
 gobject_init (void)
 {
   const gchar *env_string;
   GTypeInfo info;
   TypeNode *node;
-  GType type;
+  GType type G_GNUC_UNUSED  /* when compiling with G_DISABLE_ASSERT */;
 
   /* Ensure GLib is initialized first, see
    * https://bugzilla.gnome.org/show_bug.cgi?id=756139
    */
   GLIB_PRIVATE_CALL (glib_init) ();
@@ -4601,33 +4606,33 @@
  * Deprecated: 2.58: Use the G_ADD_PRIVATE() macro with the `G_DEFINE_*`
  *   family of macros to add instance private data to a type
  */
 void
 g_type_class_add_private (gpointer g_class,
-              gsize    private_size)
+        gsize    private_size)
 {
   GType instance_type = ((GTypeClass *)g_class)->g_type;
   TypeNode *node = lookup_type_node_I (instance_type);
 
   g_return_if_fail (private_size > 0);
   g_return_if_fail (private_size <= 0xffff);
 
   if (!node || !node->is_instantiatable || !node->data || node->data->class.class != g_class)
     {
       g_warning ("cannot add private field to invalid (non-instantiatable) type '%s'",
-         type_descriptive_name_I (instance_type));
+     type_descriptive_name_I (instance_type));
       return;
     }
 
   if (NODE_PARENT_TYPE (node))
     {
       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
       if (node->data->instance.private_size != pnode->data->instance.private_size)
-    {
-      g_warning ("g_type_class_add_private() called multiple times for the same type");
-      return;
-    }
+  {
+    g_warning ("g_type_class_add_private() called multiple times for the same type");
+    return;
+  }
     }
 
   G_WRITE_LOCK (&type_rw_lock);
 
   private_size = ALIGN_STRUCT (node->data->instance.private_size + private_size);
@@ -4648,11 +4653,11 @@
   g_return_val_if_fail (private_size <= 0xffff, 0);
 
   if (!node || !node->is_classed || !node->is_instantiatable || !node->data)
     {
       g_warning ("cannot add private field to invalid (non-instantiatable) type '%s'",
-         type_descriptive_name_I (class_gtype));
+     type_descriptive_name_I (class_gtype));
       return 0;
     }
 
   if (node->plugin != NULL)
     {
@@ -4715,24 +4720,24 @@
     return;
 
   if (!node || !node->is_classed || !node->is_instantiatable || !node->data)
     {
       g_warning ("cannot add private field to invalid (non-instantiatable) type '%s'",
-         type_descriptive_name_I (class_gtype));
+     type_descriptive_name_I (class_gtype));
       *private_size_or_offset = 0;
       return;
     }
 
   if (NODE_PARENT_TYPE (node))
     {
       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
       if (node->data->instance.private_size != pnode->data->instance.private_size)
-    {
-      g_warning ("g_type_add_instance_private() called multiple times for the same type");
+  {
+    g_warning ("g_type_add_instance_private() called multiple times for the same type");
           *private_size_or_offset = 0;
-      return;
-    }
+    return;
+  }
     }
 
   G_WRITE_LOCK (&type_rw_lock);
 
   private_size = ALIGN_STRUCT (node->data->instance.private_size + *private_size_or_offset);
@@ -4744,11 +4749,11 @@
   G_WRITE_UNLOCK (&type_rw_lock);
 }
 
 gpointer
 g_type_instance_get_private (GTypeInstance *instance,
-                 GType          private_type)
+           GType          private_type)
 {
   TypeNode *node;
 
   g_return_val_if_fail (instance != NULL && instance->g_class != NULL, NULL);
 
@@ -4811,11 +4816,11 @@
   return -(gint) node->data->instance.private_size;
 }
 
 /**
  * g_type_add_class_private:
- * @class_type: GType of an classed type
+ * @class_type: GType of a classed type
  * @private_size: size of private structure
  *
  * Registers a private class structure for a classed type;
  * when the class is allocated, the private structures for
  * the class and all of its parent types are allocated
@@ -4829,32 +4834,32 @@
  *
  * Since: 2.24
  */
 void
 g_type_add_class_private (GType    class_type,
-              gsize    private_size)
+        gsize    private_size)
 {
   TypeNode *node = lookup_type_node_I (class_type);
   gsize offset;
 
   g_return_if_fail (private_size > 0);
 
   if (!node || !node->is_classed || !node->data)
     {
       g_warning ("cannot add class private field to invalid type '%s'",
-         type_descriptive_name_I (class_type));
+     type_descriptive_name_I (class_type));
       return;
     }
 
   if (NODE_PARENT_TYPE (node))
     {
       TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
       if (node->data->class.class_private_size != pnode->data->class.class_private_size)
-    {
-      g_warning ("g_type_add_class_private() called multiple times for the same type");
-      return;
-    }
+  {
+    g_warning ("g_type_add_class_private() called multiple times for the same type");
+    return;
+  }
     }
 
   G_WRITE_LOCK (&type_rw_lock);
 
   offset = ALIGN_STRUCT (node->data->class.class_private_size);
@@ -4863,11 +4868,11 @@
   G_WRITE_UNLOCK (&type_rw_lock);
 }
 
 gpointer
 g_type_class_get_private (GTypeClass *klass,
-              GType       private_type)
+        GType       private_type)
 {
   TypeNode *class_node;
   TypeNode *private_node;
   TypeNode *parent_node;
   gsize offset;
@@ -4876,19 +4881,19 @@
 
   class_node = lookup_type_node_I (klass->g_type);
   if (G_UNLIKELY (!class_node || !class_node->is_classed))
     {
       g_warning ("class of invalid type '%s'",
-         type_descriptive_name_I (klass->g_type));
+     type_descriptive_name_I (klass->g_type));
       return NULL;
     }
 
   private_node = lookup_type_node_I (private_type);
   if (G_UNLIKELY (!private_node || !NODE_IS_ANCESTOR (private_node, class_node)))
     {
       g_warning ("attempt to retrieve private data for invalid type '%s'",
-         type_descriptive_name_I (private_type));
+     type_descriptive_name_I (private_type));
       return NULL;
     }
 
   offset = ALIGN_STRUCT (class_node->data->class.class_size);
 
@@ -4896,14 +4901,14 @@
     {
       parent_node = lookup_type_node_I (NODE_PARENT_TYPE (private_node));
       g_assert (parent_node->data && NODE_REFCOUNT (parent_node) > 0);
 
       if (G_UNLIKELY (private_node->data->class.class_private_size == parent_node->data->class.class_private_size))
-    {
-      g_warning ("g_type_instance_get_class_private() requires a prior call to g_type_add_class_private()");
-      return NULL;
-    }
+  {
+    g_warning ("g_type_instance_get_class_private() requires a prior call to g_type_add_class_private()");
+    return NULL;
+  }
 
       offset += ALIGN_STRUCT (parent_node->data->class.class_private_size);
     }
 
   return G_STRUCT_MEMBER_P (klass, offset);
