<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/giowin32.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="giounix.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gkeyfile.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/giowin32.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 89,53 ***</span>
  #define BUFFER_SIZE 4096
  
  typedef enum {
    G_IO_WIN32_WINDOWS_MESSAGES,  /* Windows messages */
  
<span class="line-modified">!   G_IO_WIN32_FILE_DESC,     /* Unix-like file descriptors from</span>
<span class="line-modified">!                                  * _open() or _pipe(), except for</span>
<span class="line-modified">!                                  * console IO. Separate thread to read</span>
<span class="line-modified">!                                  * or write.</span>
<span class="line-modified">!                                  */</span>
  
<span class="line-modified">!   G_IO_WIN32_CONSOLE,       /* Console IO (usually stdin, stdout, stderr) */</span>
  
<span class="line-modified">!   G_IO_WIN32_SOCKET     /* Sockets. No separate thread. */</span>
  } GIOWin32ChannelType;
  
  struct _GIOWin32Channel {
    GIOChannel channel;
<span class="line-modified">!   gint fd;          /* Either a Unix-like file handle as provided</span>
<span class="line-modified">!                                  * by the Microsoft C runtime, or a SOCKET</span>
<span class="line-modified">!                                  * as provided by WinSock.</span>
<span class="line-modified">!                                  */</span>
    GIOWin32ChannelType type;
  
    gboolean debug;
  
    /* Field used by G_IO_WIN32_WINDOWS_MESSAGES channels */
<span class="line-modified">!   HWND hwnd;            /* Handle of window, or NULL */</span>
  
    /* Fields used by G_IO_WIN32_FILE_DESC channels. */
    CRITICAL_SECTION mutex;
  
<span class="line-modified">!   int direction;        /* 0 means we read from it,</span>
<span class="line-modified">!                                  * 1 means we write to it.</span>
<span class="line-modified">!                                  */</span>
  
<span class="line-modified">!   gboolean running;     /* Is reader or writer thread</span>
<span class="line-modified">!                                  * running. FALSE if EOF has been</span>
<span class="line-modified">!                                  * reached by the reader thread.</span>
<span class="line-modified">!                                  */</span>
  
<span class="line-modified">!   gboolean needs_close;     /* If the channel has been closed while</span>
<span class="line-modified">!                                  * the reader thread was still running.</span>
<span class="line-modified">!                                  */</span>
  
<span class="line-modified">!   guint thread_id;      /* If non-NULL the channel has or has</span>
<span class="line-modified">!                                  * had a reader or writer thread.</span>
<span class="line-modified">!                                  */</span>
    HANDLE data_avail_event;
  
    gushort revents;
  
    /* Data is kept in a circular buffer. To be able to distinguish between
<span class="line-new-header">--- 89,53 ---</span>
  #define BUFFER_SIZE 4096
  
  typedef enum {
    G_IO_WIN32_WINDOWS_MESSAGES,  /* Windows messages */
  
<span class="line-modified">!   G_IO_WIN32_FILE_DESC,   /* Unix-like file descriptors from</span>
<span class="line-modified">!          * _open() or _pipe(), except for</span>
<span class="line-modified">!          * console IO. Separate thread to read</span>
<span class="line-modified">!          * or write.</span>
<span class="line-modified">!          */</span>
  
<span class="line-modified">!   G_IO_WIN32_CONSOLE,   /* Console IO (usually stdin, stdout, stderr) */</span>
  
<span class="line-modified">!   G_IO_WIN32_SOCKET   /* Sockets. No separate thread. */</span>
  } GIOWin32ChannelType;
  
  struct _GIOWin32Channel {
    GIOChannel channel;
<span class="line-modified">!   gint fd;      /* Either a Unix-like file handle as provided</span>
<span class="line-modified">!          * by the Microsoft C runtime, or a SOCKET</span>
<span class="line-modified">!          * as provided by WinSock.</span>
<span class="line-modified">!          */</span>
    GIOWin32ChannelType type;
  
    gboolean debug;
  
    /* Field used by G_IO_WIN32_WINDOWS_MESSAGES channels */
<span class="line-modified">!   HWND hwnd;      /* Handle of window, or NULL */</span>
  
    /* Fields used by G_IO_WIN32_FILE_DESC channels. */
    CRITICAL_SECTION mutex;
  
<span class="line-modified">!   int direction;    /* 0 means we read from it,</span>
<span class="line-modified">!          * 1 means we write to it.</span>
<span class="line-modified">!          */</span>
  
<span class="line-modified">!   gboolean running;   /* Is reader or writer thread</span>
<span class="line-modified">!          * running. FALSE if EOF has been</span>
<span class="line-modified">!          * reached by the reader thread.</span>
<span class="line-modified">!          */</span>
  
<span class="line-modified">!   gboolean needs_close;   /* If the channel has been closed while</span>
<span class="line-modified">!          * the reader thread was still running.</span>
<span class="line-modified">!          */</span>
  
<span class="line-modified">!   guint thread_id;    /* If non-NULL the channel has or has</span>
<span class="line-modified">!          * had a reader or writer thread.</span>
<span class="line-modified">!          */</span>
    HANDLE data_avail_event;
  
    gushort revents;
  
    /* Data is kept in a circular buffer. To be able to distinguish between
</pre>
<hr />
<pre>
<span class="line-old-header">*** 146,12 ***</span>
     *
     * Empty:    wrp == rdp
     * Full:     (wrp + 1) % BUFFER_SIZE == rdp
     * Partial:  otherwise
     */
<span class="line-modified">!   guchar *buffer;       /* (Circular) buffer */</span>
<span class="line-modified">!   gint wrp, rdp;        /* Buffer indices for writing and reading */</span>
    HANDLE space_avail_event;
  
    /* Fields used by G_IO_WIN32_SOCKET channels */
    int event_mask;
    int last_events;
<span class="line-new-header">--- 146,12 ---</span>
     *
     * Empty:    wrp == rdp
     * Full:     (wrp + 1) % BUFFER_SIZE == rdp
     * Partial:  otherwise
     */
<span class="line-modified">!   guchar *buffer;   /* (Circular) buffer */</span>
<span class="line-modified">!   gint wrp, rdp;    /* Buffer indices for writing and reading */</span>
    HANDLE space_avail_event;
  
    /* Fields used by G_IO_WIN32_SOCKET channels */
    int event_mask;
    int last_events;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 169,22 ***</span>
  
  static void
  g_win32_print_access_mode (int flags)
  {
    g_print (&quot;%s%s%s%s%s%s%s%s%s%s&quot;,
<span class="line-modified">!        ((flags &amp; 0x3) == _O_RDWR ? &quot;O_RDWR&quot; :</span>
<span class="line-modified">!         ((flags &amp; 0x3) == _O_RDONLY ? &quot;O_RDONLY&quot; :</span>
<span class="line-modified">!          ((flags &amp; 0x3) == _O_WRONLY ? &quot;O_WRONLY&quot; : &quot;0&quot;))),</span>
<span class="line-modified">!        (flags &amp; _O_APPEND ? &quot;|O_APPEND&quot; : &quot;&quot;),</span>
<span class="line-modified">!        (flags &amp; _O_RANDOM ? &quot;|O_RANDOM&quot; : &quot;&quot;),</span>
<span class="line-modified">!        (flags &amp; _O_SEQUENTIAL ? &quot;|O_SEQUENTIAL&quot; : &quot;&quot;),</span>
<span class="line-modified">!        (flags &amp; _O_TEMPORARY ? &quot;|O_TEMPORARY&quot; : &quot;&quot;),</span>
<span class="line-modified">!        (flags &amp; _O_CREAT ? &quot;|O_CREAT&quot; : &quot;&quot;),</span>
<span class="line-modified">!        (flags &amp; _O_TRUNC ? &quot;|O_TRUNC&quot; : &quot;&quot;),</span>
<span class="line-modified">!        (flags &amp; _O_EXCL ? &quot;|O_EXCL&quot; : &quot;&quot;),</span>
<span class="line-modified">!        (flags &amp; _O_TEXT ? &quot;|O_TEXT&quot; : &quot;&quot;),</span>
<span class="line-modified">!        (flags &amp; _O_BINARY ? &quot;|O_BINARY&quot; : &quot;&quot;));</span>
  }
  
  static void
  g_win32_print_gioflags (GIOFlags flags)
  {
<span class="line-new-header">--- 169,22 ---</span>
  
  static void
  g_win32_print_access_mode (int flags)
  {
    g_print (&quot;%s%s%s%s%s%s%s%s%s%s&quot;,
<span class="line-modified">!      ((flags &amp; 0x3) == _O_RDWR ? &quot;O_RDWR&quot; :</span>
<span class="line-modified">!       ((flags &amp; 0x3) == _O_RDONLY ? &quot;O_RDONLY&quot; :</span>
<span class="line-modified">!        ((flags &amp; 0x3) == _O_WRONLY ? &quot;O_WRONLY&quot; : &quot;0&quot;))),</span>
<span class="line-modified">!      (flags &amp; _O_APPEND ? &quot;|O_APPEND&quot; : &quot;&quot;),</span>
<span class="line-modified">!      (flags &amp; _O_RANDOM ? &quot;|O_RANDOM&quot; : &quot;&quot;),</span>
<span class="line-modified">!      (flags &amp; _O_SEQUENTIAL ? &quot;|O_SEQUENTIAL&quot; : &quot;&quot;),</span>
<span class="line-modified">!      (flags &amp; _O_TEMPORARY ? &quot;|O_TEMPORARY&quot; : &quot;&quot;),</span>
<span class="line-modified">!      (flags &amp; _O_CREAT ? &quot;|O_CREAT&quot; : &quot;&quot;),</span>
<span class="line-modified">!      (flags &amp; _O_TRUNC ? &quot;|O_TRUNC&quot; : &quot;&quot;),</span>
<span class="line-modified">!      (flags &amp; _O_EXCL ? &quot;|O_EXCL&quot; : &quot;&quot;),</span>
<span class="line-modified">!      (flags &amp; _O_TEXT ? &quot;|O_TEXT&quot; : &quot;&quot;),</span>
<span class="line-modified">!      (flags &amp; _O_BINARY ? &quot;|O_BINARY&quot; : &quot;&quot;));</span>
  }
  
  static void
  g_win32_print_gioflags (GIOFlags flags)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 226,11 ***</span>
    BIT (ADDRESS_LIST_CHANGE);
  
  #undef BIT
  
    if ((mask &amp; ~checked_bits) != 0)
<span class="line-modified">!       bufp += sprintf (bufp, &quot;|%#x&quot;, mask &amp; ~checked_bits);</span>
  
    return g_quark_to_string (g_quark_from_string (buf));
  }
  
  static const char *
<span class="line-new-header">--- 226,11 ---</span>
    BIT (ADDRESS_LIST_CHANGE);
  
  #undef BIT
  
    if ((mask &amp; ~checked_bits) != 0)
<span class="line-modified">!     bufp += sprintf (bufp, &quot;|%#x&quot;, mask &amp; ~checked_bits);</span>
  
    return g_quark_to_string (g_quark_from_string (buf));
  }
  
  static const char *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 253,11 ***</span>
    BIT (NVAL);
  
  #undef BIT
  
    if ((condition &amp; ~checked_bits) != 0)
<span class="line-modified">!       bufp += sprintf (bufp, &quot;|%#x&quot;, condition &amp; ~checked_bits);</span>
  
    return g_quark_to_string (g_quark_from_string (buf));
  }
  
  static gboolean
<span class="line-new-header">--- 253,11 ---</span>
    BIT (NVAL);
  
  #undef BIT
  
    if ((condition &amp; ~checked_bits) != 0)
<span class="line-modified">!     bufp += sprintf (bufp, &quot;|%#x&quot;, condition &amp; ~checked_bits);</span>
  
    return g_quark_to_string (g_quark_from_string (buf));
  }
  
  static gboolean
</pre>
<hr />
<pre>
<span class="line-old-header">*** 318,14 ***</span>
  
    g_io_channel_ref ((GIOChannel *)channel);
  
    if (channel-&gt;debug)
      g_print (&quot;read_thread %#x: start fd=%d, data_avail=%p space_avail=%p\n&quot;,
<span class="line-modified">!          channel-&gt;thread_id,</span>
<span class="line-modified">!          channel-&gt;fd,</span>
<span class="line-modified">!          channel-&gt;data_avail_event,</span>
<span class="line-modified">!          channel-&gt;space_avail_event);</span>
  
    channel-&gt;direction = 0;
    channel-&gt;buffer = g_malloc (BUFFER_SIZE);
    channel-&gt;rdp = channel-&gt;wrp = 0;
    channel-&gt;running = TRUE;
<span class="line-new-header">--- 318,14 ---</span>
  
    g_io_channel_ref ((GIOChannel *)channel);
  
    if (channel-&gt;debug)
      g_print (&quot;read_thread %#x: start fd=%d, data_avail=%p space_avail=%p\n&quot;,
<span class="line-modified">!        channel-&gt;thread_id,</span>
<span class="line-modified">!        channel-&gt;fd,</span>
<span class="line-modified">!        channel-&gt;data_avail_event,</span>
<span class="line-modified">!        channel-&gt;space_avail_event);</span>
  
    channel-&gt;direction = 0;
    channel-&gt;buffer = g_malloc (BUFFER_SIZE);
    channel-&gt;rdp = channel-&gt;wrp = 0;
    channel-&gt;running = TRUE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 334,81 ***</span>
  
    EnterCriticalSection (&amp;channel-&gt;mutex);
    while (channel-&gt;running)
      {
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;read_thread %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
        if ((channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)
<span class="line-modified">!     {</span>
<span class="line-modified">!       /* Buffer is full */</span>
<span class="line-modified">!       if (channel-&gt;debug)</span>
<span class="line-modified">!         g_print (&quot;read_thread %#x: resetting space_avail\n&quot;,</span>
<span class="line-modified">!              channel-&gt;thread_id);</span>
<span class="line-modified">!       ResetEvent (channel-&gt;space_avail_event);</span>
<span class="line-modified">!       if (channel-&gt;debug)</span>
<span class="line-modified">!         g_print (&quot;read_thread %#x: waiting for space\n&quot;,</span>
<span class="line-modified">!              channel-&gt;thread_id);</span>
<span class="line-modified">!       LeaveCriticalSection (&amp;channel-&gt;mutex);</span>
<span class="line-modified">!       WaitForSingleObject (channel-&gt;space_avail_event, INFINITE);</span>
<span class="line-modified">!       EnterCriticalSection (&amp;channel-&gt;mutex);</span>
<span class="line-modified">!       if (channel-&gt;debug)</span>
<span class="line-modified">!         g_print (&quot;read_thread %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified">!              channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
<span class="line-modified">!     }</span>
  
        buffer = channel-&gt;buffer + channel-&gt;wrp;
  
        /* Always leave at least one byte unused gap to be able to
         * distinguish between the full and empty condition...
         */
        nbytes = MIN ((channel-&gt;rdp + BUFFER_SIZE - channel-&gt;wrp - 1) % BUFFER_SIZE,
<span class="line-modified">!             BUFFER_SIZE - channel-&gt;wrp);</span>
  
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;read_thread %#x: calling read() for %d bytes\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id, nbytes);</span>
  
        LeaveCriticalSection (&amp;channel-&gt;mutex);
  
        nbytes = read (channel-&gt;fd, buffer, nbytes);
  
        EnterCriticalSection (&amp;channel-&gt;mutex);
  
        channel-&gt;revents = G_IO_IN;
        if (nbytes == 0)
<span class="line-modified">!     channel-&gt;revents |= G_IO_HUP;</span>
        else if (nbytes &lt; 0)
<span class="line-modified">!     channel-&gt;revents |= G_IO_ERR;</span>
  
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;read_thread %#x: read() returned %d, rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id, nbytes, channel-&gt;rdp, channel-&gt;wrp);</span>
  
        if (nbytes &lt;= 0)
<span class="line-modified">!     break;</span>
  
        channel-&gt;wrp = (channel-&gt;wrp + nbytes) % BUFFER_SIZE;
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;read_thread %#x: rdp=%d, wrp=%d, setting data_avail\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
        SetEvent (channel-&gt;data_avail_event);
      }
  
    channel-&gt;running = FALSE;
    if (channel-&gt;needs_close)
      {
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;read_thread %#x: channel fd %d needs closing\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id, channel-&gt;fd);</span>
        close (channel-&gt;fd);
        channel-&gt;fd = -1;
      }
  
    if (channel-&gt;debug)
      g_print (&quot;read_thread %#x: EOF, rdp=%d, wrp=%d, setting data_avail\n&quot;,
<span class="line-modified">!          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
    SetEvent (channel-&gt;data_avail_event);
    LeaveCriticalSection (&amp;channel-&gt;mutex);
  
    g_io_channel_unref ((GIOChannel *)channel);
  
<span class="line-new-header">--- 334,81 ---</span>
  
    EnterCriticalSection (&amp;channel-&gt;mutex);
    while (channel-&gt;running)
      {
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;read_thread %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified">!      channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
        if ((channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)
<span class="line-modified">!   {</span>
<span class="line-modified">!     /* Buffer is full */</span>
<span class="line-modified">!     if (channel-&gt;debug)</span>
<span class="line-modified">!       g_print (&quot;read_thread %#x: resetting space_avail\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id);</span>
<span class="line-modified">!     ResetEvent (channel-&gt;space_avail_event);</span>
<span class="line-modified">!     if (channel-&gt;debug)</span>
<span class="line-modified">!       g_print (&quot;read_thread %#x: waiting for space\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id);</span>
<span class="line-modified">!     LeaveCriticalSection (&amp;channel-&gt;mutex);</span>
<span class="line-modified">!     WaitForSingleObject (channel-&gt;space_avail_event, INFINITE);</span>
<span class="line-modified">!     EnterCriticalSection (&amp;channel-&gt;mutex);</span>
<span class="line-modified">!     if (channel-&gt;debug)</span>
<span class="line-modified">!       g_print (&quot;read_thread %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
<span class="line-modified">!   }</span>
  
        buffer = channel-&gt;buffer + channel-&gt;wrp;
  
        /* Always leave at least one byte unused gap to be able to
         * distinguish between the full and empty condition...
         */
        nbytes = MIN ((channel-&gt;rdp + BUFFER_SIZE - channel-&gt;wrp - 1) % BUFFER_SIZE,
<span class="line-modified">!         BUFFER_SIZE - channel-&gt;wrp);</span>
  
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;read_thread %#x: calling read() for %d bytes\n&quot;,</span>
<span class="line-modified">!      channel-&gt;thread_id, nbytes);</span>
  
        LeaveCriticalSection (&amp;channel-&gt;mutex);
  
        nbytes = read (channel-&gt;fd, buffer, nbytes);
  
        EnterCriticalSection (&amp;channel-&gt;mutex);
  
        channel-&gt;revents = G_IO_IN;
        if (nbytes == 0)
<span class="line-modified">!   channel-&gt;revents |= G_IO_HUP;</span>
        else if (nbytes &lt; 0)
<span class="line-modified">!   channel-&gt;revents |= G_IO_ERR;</span>
  
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;read_thread %#x: read() returned %d, rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified">!      channel-&gt;thread_id, nbytes, channel-&gt;rdp, channel-&gt;wrp);</span>
  
        if (nbytes &lt;= 0)
<span class="line-modified">!   break;</span>
  
        channel-&gt;wrp = (channel-&gt;wrp + nbytes) % BUFFER_SIZE;
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;read_thread %#x: rdp=%d, wrp=%d, setting data_avail\n&quot;,</span>
<span class="line-modified">!      channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
        SetEvent (channel-&gt;data_avail_event);
      }
  
    channel-&gt;running = FALSE;
    if (channel-&gt;needs_close)
      {
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;read_thread %#x: channel fd %d needs closing\n&quot;,</span>
<span class="line-modified">!      channel-&gt;thread_id, channel-&gt;fd);</span>
        close (channel-&gt;fd);
        channel-&gt;fd = -1;
      }
  
    if (channel-&gt;debug)
      g_print (&quot;read_thread %#x: EOF, rdp=%d, wrp=%d, setting data_avail\n&quot;,
<span class="line-modified">!        channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
    SetEvent (channel-&gt;data_avail_event);
    LeaveCriticalSection (&amp;channel-&gt;mutex);
  
    g_io_channel_unref ((GIOChannel *)channel);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 429,14 ***</span>
  
    g_io_channel_ref ((GIOChannel *)channel);
  
    if (channel-&gt;debug)
      g_print (&quot;write_thread %#x: start fd=%d, data_avail=%p space_avail=%p\n&quot;,
<span class="line-modified">!          channel-&gt;thread_id,</span>
<span class="line-modified">!          channel-&gt;fd,</span>
<span class="line-modified">!          channel-&gt;data_avail_event,</span>
<span class="line-modified">!          channel-&gt;space_avail_event);</span>
  
    channel-&gt;direction = 1;
    channel-&gt;buffer = g_malloc (BUFFER_SIZE);
    channel-&gt;rdp = channel-&gt;wrp = 0;
    channel-&gt;running = TRUE;
<span class="line-new-header">--- 429,14 ---</span>
  
    g_io_channel_ref ((GIOChannel *)channel);
  
    if (channel-&gt;debug)
      g_print (&quot;write_thread %#x: start fd=%d, data_avail=%p space_avail=%p\n&quot;,
<span class="line-modified">!        channel-&gt;thread_id,</span>
<span class="line-modified">!        channel-&gt;fd,</span>
<span class="line-modified">!        channel-&gt;data_avail_event,</span>
<span class="line-modified">!        channel-&gt;space_avail_event);</span>
  
    channel-&gt;direction = 1;
    channel-&gt;buffer = g_malloc (BUFFER_SIZE);
    channel-&gt;rdp = channel-&gt;wrp = 0;
    channel-&gt;running = TRUE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 451,77 ***</span>
  
    EnterCriticalSection (&amp;channel-&gt;mutex);
    while (channel-&gt;running || channel-&gt;rdp != channel-&gt;wrp)
      {
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;write_thread %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
        if (channel-&gt;wrp == channel-&gt;rdp)
<span class="line-modified">!     {</span>
<span class="line-modified">!       /* Buffer is empty. */</span>
<span class="line-modified">!       if (channel-&gt;debug)</span>
<span class="line-modified">!         g_print (&quot;write_thread %#x: resetting space_avail\n&quot;,</span>
<span class="line-modified">!              channel-&gt;thread_id);</span>
<span class="line-modified">!       ResetEvent (channel-&gt;space_avail_event);</span>
<span class="line-modified">!       if (channel-&gt;debug)</span>
<span class="line-modified">!         g_print (&quot;write_thread %#x: waiting for data\n&quot;,</span>
<span class="line-modified">!              channel-&gt;thread_id);</span>
<span class="line-modified">!       channel-&gt;revents = G_IO_OUT;</span>
<span class="line-modified">!       SetEvent (channel-&gt;data_avail_event);</span>
<span class="line-modified">!       LeaveCriticalSection (&amp;channel-&gt;mutex);</span>
<span class="line-modified">!       WaitForSingleObject (channel-&gt;space_avail_event, INFINITE);</span>
  
<span class="line-modified">!       EnterCriticalSection (&amp;channel-&gt;mutex);</span>
<span class="line-modified">!       if (channel-&gt;rdp == channel-&gt;wrp)</span>
<span class="line-modified">!         break;</span>
  
<span class="line-modified">!       if (channel-&gt;debug)</span>
<span class="line-modified">!         g_print (&quot;write_thread %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified">!              channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
<span class="line-modified">!     }</span>
  
        buffer = channel-&gt;buffer + channel-&gt;rdp;
        if (channel-&gt;rdp &lt; channel-&gt;wrp)
<span class="line-modified">!     nbytes = channel-&gt;wrp - channel-&gt;rdp;</span>
        else
<span class="line-modified">!     nbytes = BUFFER_SIZE - channel-&gt;rdp;</span>
  
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;write_thread %#x: calling write() for %d bytes\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id, nbytes);</span>
  
        LeaveCriticalSection (&amp;channel-&gt;mutex);
        nbytes = write (channel-&gt;fd, buffer, nbytes);
        EnterCriticalSection (&amp;channel-&gt;mutex);
  
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;write_thread %#x: write(%i) returned %d, rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id, channel-&gt;fd, nbytes, channel-&gt;rdp, channel-&gt;wrp);</span>
  
        channel-&gt;revents = 0;
        if (nbytes &gt; 0)
<span class="line-modified">!     channel-&gt;revents |= G_IO_OUT;</span>
        else if (nbytes &lt;= 0)
<span class="line-modified">!     channel-&gt;revents |= G_IO_ERR;</span>
  
        channel-&gt;rdp = (channel-&gt;rdp + nbytes) % BUFFER_SIZE;
  
        if (nbytes &lt;= 0)
<span class="line-modified">!     break;</span>
  
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;write_thread: setting data_avail for thread %#x\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id);</span>
        SetEvent (channel-&gt;data_avail_event);
      }
  
    channel-&gt;running = FALSE;
    if (channel-&gt;needs_close)
      {
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;write_thread %#x: channel fd %d needs closing\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id, channel-&gt;fd);</span>
        close (channel-&gt;fd);
        channel-&gt;fd = -1;
      }
  
    LeaveCriticalSection (&amp;channel-&gt;mutex);
<span class="line-new-header">--- 451,77 ---</span>
  
    EnterCriticalSection (&amp;channel-&gt;mutex);
    while (channel-&gt;running || channel-&gt;rdp != channel-&gt;wrp)
      {
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;write_thread %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified">!      channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
        if (channel-&gt;wrp == channel-&gt;rdp)
<span class="line-modified">!   {</span>
<span class="line-modified">!     /* Buffer is empty. */</span>
<span class="line-modified">!     if (channel-&gt;debug)</span>
<span class="line-modified">!       g_print (&quot;write_thread %#x: resetting space_avail\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id);</span>
<span class="line-modified">!     ResetEvent (channel-&gt;space_avail_event);</span>
<span class="line-modified">!     if (channel-&gt;debug)</span>
<span class="line-modified">!       g_print (&quot;write_thread %#x: waiting for data\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id);</span>
<span class="line-modified">!     channel-&gt;revents = G_IO_OUT;</span>
<span class="line-modified">!     SetEvent (channel-&gt;data_avail_event);</span>
<span class="line-modified">!     LeaveCriticalSection (&amp;channel-&gt;mutex);</span>
<span class="line-modified">!     WaitForSingleObject (channel-&gt;space_avail_event, INFINITE);</span>
  
<span class="line-modified">!     EnterCriticalSection (&amp;channel-&gt;mutex);</span>
<span class="line-modified">!     if (channel-&gt;rdp == channel-&gt;wrp)</span>
<span class="line-modified">!       break;</span>
  
<span class="line-modified">!     if (channel-&gt;debug)</span>
<span class="line-modified">!       g_print (&quot;write_thread %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
<span class="line-modified">!   }</span>
  
        buffer = channel-&gt;buffer + channel-&gt;rdp;
        if (channel-&gt;rdp &lt; channel-&gt;wrp)
<span class="line-modified">!   nbytes = channel-&gt;wrp - channel-&gt;rdp;</span>
        else
<span class="line-modified">!   nbytes = BUFFER_SIZE - channel-&gt;rdp;</span>
  
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;write_thread %#x: calling write() for %d bytes\n&quot;,</span>
<span class="line-modified">!      channel-&gt;thread_id, nbytes);</span>
  
        LeaveCriticalSection (&amp;channel-&gt;mutex);
        nbytes = write (channel-&gt;fd, buffer, nbytes);
        EnterCriticalSection (&amp;channel-&gt;mutex);
  
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;write_thread %#x: write(%i) returned %d, rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified">!      channel-&gt;thread_id, channel-&gt;fd, nbytes, channel-&gt;rdp, channel-&gt;wrp);</span>
  
        channel-&gt;revents = 0;
        if (nbytes &gt; 0)
<span class="line-modified">!   channel-&gt;revents |= G_IO_OUT;</span>
        else if (nbytes &lt;= 0)
<span class="line-modified">!   channel-&gt;revents |= G_IO_ERR;</span>
  
        channel-&gt;rdp = (channel-&gt;rdp + nbytes) % BUFFER_SIZE;
  
        if (nbytes &lt;= 0)
<span class="line-modified">!   break;</span>
  
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;write_thread: setting data_avail for thread %#x\n&quot;,</span>
<span class="line-modified">!      channel-&gt;thread_id);</span>
        SetEvent (channel-&gt;data_avail_event);
      }
  
    channel-&gt;running = FALSE;
    if (channel-&gt;needs_close)
      {
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;write_thread %#x: channel fd %d needs closing\n&quot;,</span>
<span class="line-modified">!      channel-&gt;thread_id, channel-&gt;fd);</span>
        close (channel-&gt;fd);
        channel-&gt;fd = -1;
      }
  
    LeaveCriticalSection (&amp;channel-&gt;mutex);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 531,22 ***</span>
    return 0;
  }
  
  static void
  create_thread (GIOWin32Channel     *channel,
<span class="line-modified">!            GIOCondition         condition,</span>
<span class="line-modified">!            unsigned (__stdcall *thread) (void *parameter))</span>
  {
    HANDLE thread_handle;
    int errsv;
  
    thread_handle = (HANDLE) _beginthreadex (NULL, 0, thread, channel, 0,
<span class="line-modified">!                        &amp;channel-&gt;thread_id);</span>
    errsv = errno;
    if (thread_handle == 0)
      g_warning (&quot;Error creating thread: %s.&quot;,
<span class="line-modified">!            g_strerror (errsv));</span>
    else if (!CloseHandle (thread_handle))
      {
        gchar *emsg = g_win32_error_message (GetLastError ());
  
        g_warning (&quot;Error closing thread handle: %s.&quot;, emsg);
<span class="line-new-header">--- 531,22 ---</span>
    return 0;
  }
  
  static void
  create_thread (GIOWin32Channel     *channel,
<span class="line-modified">!          GIOCondition         condition,</span>
<span class="line-modified">!          unsigned (__stdcall *thread) (void *parameter))</span>
  {
    HANDLE thread_handle;
    int errsv;
  
    thread_handle = (HANDLE) _beginthreadex (NULL, 0, thread, channel, 0,
<span class="line-modified">!              &amp;channel-&gt;thread_id);</span>
    errsv = errno;
    if (thread_handle == 0)
      g_warning (&quot;Error creating thread: %s.&quot;,
<span class="line-modified">!          g_strerror (errsv));</span>
    else if (!CloseHandle (thread_handle))
      {
        gchar *emsg = g_win32_error_message (GetLastError ());
  
        g_warning (&quot;Error closing thread handle: %s.&quot;, emsg);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 556,67 ***</span>
    WaitForSingleObject (channel-&gt;space_avail_event, INFINITE);
  }
  
  static GIOStatus
  buffer_read (GIOWin32Channel *channel,
<span class="line-modified">!          gchar           *dest,</span>
<span class="line-modified">!          gsize            count,</span>
<span class="line-modified">!          gsize           *bytes_read,</span>
<span class="line-modified">!          GError         **err)</span>
  {
    guint nbytes;
    guint left = count;
  
    EnterCriticalSection (&amp;channel-&gt;mutex);
    if (channel-&gt;debug)
      g_print (&quot;reading from thread %#x %&quot; G_GSIZE_FORMAT &quot; bytes, rdp=%d, wrp=%d\n&quot;,
<span class="line-modified">!          channel-&gt;thread_id, count, channel-&gt;rdp, channel-&gt;wrp);</span>
  
    if (channel-&gt;wrp == channel-&gt;rdp)
      {
        LeaveCriticalSection (&amp;channel-&gt;mutex);
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;waiting for data from thread %#x\n&quot;, channel-&gt;thread_id);</span>
        WaitForSingleObject (channel-&gt;data_avail_event, INFINITE);
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;done waiting for data from thread %#x\n&quot;, channel-&gt;thread_id);</span>
        EnterCriticalSection (&amp;channel-&gt;mutex);
        if (channel-&gt;wrp == channel-&gt;rdp &amp;&amp; !channel-&gt;running)
<span class="line-modified">!     {</span>
<span class="line-modified">!       if (channel-&gt;debug)</span>
<span class="line-modified">!         g_print (&quot;wrp==rdp, !running\n&quot;);</span>
<span class="line-modified">!       LeaveCriticalSection (&amp;channel-&gt;mutex);</span>
            *bytes_read = 0;
<span class="line-modified">!       return G_IO_STATUS_EOF;</span>
<span class="line-modified">!     }</span>
      }
  
    if (channel-&gt;rdp &lt; channel-&gt;wrp)
      nbytes = channel-&gt;wrp - channel-&gt;rdp;
    else
      nbytes = BUFFER_SIZE - channel-&gt;rdp;
    LeaveCriticalSection (&amp;channel-&gt;mutex);
    nbytes = MIN (left, nbytes);
    if (channel-&gt;debug)
      g_print (&quot;moving %d bytes from thread %#x\n&quot;,
<span class="line-modified">!          nbytes, channel-&gt;thread_id);</span>
    memcpy (dest, channel-&gt;buffer + channel-&gt;rdp, nbytes);
    dest += nbytes;
    left -= nbytes;
    EnterCriticalSection (&amp;channel-&gt;mutex);
    channel-&gt;rdp = (channel-&gt;rdp + nbytes) % BUFFER_SIZE;
    if (channel-&gt;debug)
      g_print (&quot;setting space_avail for thread %#x\n&quot;, channel-&gt;thread_id);
    SetEvent (channel-&gt;space_avail_event);
    if (channel-&gt;debug)
      g_print (&quot;for thread %#x: rdp=%d, wrp=%d\n&quot;,
<span class="line-modified">!          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
    if (channel-&gt;running &amp;&amp; channel-&gt;wrp == channel-&gt;rdp)
      {
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;resetting data_avail of thread %#x\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id);</span>
        ResetEvent (channel-&gt;data_avail_event);
      };
    LeaveCriticalSection (&amp;channel-&gt;mutex);
  
    /* We have no way to indicate any errors form the actual
<span class="line-new-header">--- 556,67 ---</span>
    WaitForSingleObject (channel-&gt;space_avail_event, INFINITE);
  }
  
  static GIOStatus
  buffer_read (GIOWin32Channel *channel,
<span class="line-modified">!        gchar           *dest,</span>
<span class="line-modified">!        gsize            count,</span>
<span class="line-modified">!        gsize           *bytes_read,</span>
<span class="line-modified">!        GError         **err)</span>
  {
    guint nbytes;
    guint left = count;
  
    EnterCriticalSection (&amp;channel-&gt;mutex);
    if (channel-&gt;debug)
      g_print (&quot;reading from thread %#x %&quot; G_GSIZE_FORMAT &quot; bytes, rdp=%d, wrp=%d\n&quot;,
<span class="line-modified">!        channel-&gt;thread_id, count, channel-&gt;rdp, channel-&gt;wrp);</span>
  
    if (channel-&gt;wrp == channel-&gt;rdp)
      {
        LeaveCriticalSection (&amp;channel-&gt;mutex);
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;waiting for data from thread %#x\n&quot;, channel-&gt;thread_id);</span>
        WaitForSingleObject (channel-&gt;data_avail_event, INFINITE);
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;done waiting for data from thread %#x\n&quot;, channel-&gt;thread_id);</span>
        EnterCriticalSection (&amp;channel-&gt;mutex);
        if (channel-&gt;wrp == channel-&gt;rdp &amp;&amp; !channel-&gt;running)
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (channel-&gt;debug)</span>
<span class="line-modified">!       g_print (&quot;wrp==rdp, !running\n&quot;);</span>
<span class="line-modified">!     LeaveCriticalSection (&amp;channel-&gt;mutex);</span>
            *bytes_read = 0;
<span class="line-modified">!     return G_IO_STATUS_EOF;</span>
<span class="line-modified">!   }</span>
      }
  
    if (channel-&gt;rdp &lt; channel-&gt;wrp)
      nbytes = channel-&gt;wrp - channel-&gt;rdp;
    else
      nbytes = BUFFER_SIZE - channel-&gt;rdp;
    LeaveCriticalSection (&amp;channel-&gt;mutex);
    nbytes = MIN (left, nbytes);
    if (channel-&gt;debug)
      g_print (&quot;moving %d bytes from thread %#x\n&quot;,
<span class="line-modified">!        nbytes, channel-&gt;thread_id);</span>
    memcpy (dest, channel-&gt;buffer + channel-&gt;rdp, nbytes);
    dest += nbytes;
    left -= nbytes;
    EnterCriticalSection (&amp;channel-&gt;mutex);
    channel-&gt;rdp = (channel-&gt;rdp + nbytes) % BUFFER_SIZE;
    if (channel-&gt;debug)
      g_print (&quot;setting space_avail for thread %#x\n&quot;, channel-&gt;thread_id);
    SetEvent (channel-&gt;space_avail_event);
    if (channel-&gt;debug)
      g_print (&quot;for thread %#x: rdp=%d, wrp=%d\n&quot;,
<span class="line-modified">!        channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
    if (channel-&gt;running &amp;&amp; channel-&gt;wrp == channel-&gt;rdp)
      {
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;resetting data_avail of thread %#x\n&quot;,</span>
<span class="line-modified">!      channel-&gt;thread_id);</span>
        ResetEvent (channel-&gt;data_avail_event);
      };
    LeaveCriticalSection (&amp;channel-&gt;mutex);
  
    /* We have no way to indicate any errors form the actual
</pre>
<hr />
<pre>
<span class="line-old-header">*** 627,66 ***</span>
  }
  
  
  static GIOStatus
  buffer_write (GIOWin32Channel *channel,
<span class="line-modified">!           const gchar     *dest,</span>
<span class="line-modified">!           gsize            count,</span>
<span class="line-modified">!           gsize           *bytes_written,</span>
<span class="line-modified">!           GError         **err)</span>
  {
    guint nbytes;
    guint left = count;
  
    EnterCriticalSection (&amp;channel-&gt;mutex);
    if (channel-&gt;debug)
      g_print (&quot;buffer_write: writing to thread %#x %&quot; G_GSIZE_FORMAT &quot; bytes, rdp=%d, wrp=%d\n&quot;,
<span class="line-modified">!          channel-&gt;thread_id, count, channel-&gt;rdp, channel-&gt;wrp);</span>
  
    if ((channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)
      {
        /* Buffer is full */
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;buffer_write: tid %#x: resetting data_avail\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id);</span>
        ResetEvent (channel-&gt;data_avail_event);
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;buffer_write: tid %#x: waiting for space\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id);</span>
        LeaveCriticalSection (&amp;channel-&gt;mutex);
        WaitForSingleObject (channel-&gt;data_avail_event, INFINITE);
        EnterCriticalSection (&amp;channel-&gt;mutex);
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;buffer_write: tid %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
      }
  
    nbytes = MIN ((channel-&gt;rdp + BUFFER_SIZE - channel-&gt;wrp - 1) % BUFFER_SIZE,
<span class="line-modified">!         BUFFER_SIZE - channel-&gt;wrp);</span>
  
    LeaveCriticalSection (&amp;channel-&gt;mutex);
    nbytes = MIN (left, nbytes);
    if (channel-&gt;debug)
      g_print (&quot;buffer_write: tid %#x: writing %d bytes\n&quot;,
<span class="line-modified">!          channel-&gt;thread_id, nbytes);</span>
    memcpy (channel-&gt;buffer + channel-&gt;wrp, dest, nbytes);
    dest += nbytes;
    left -= nbytes;
    EnterCriticalSection (&amp;channel-&gt;mutex);
  
    channel-&gt;wrp = (channel-&gt;wrp + nbytes) % BUFFER_SIZE;
    if (channel-&gt;debug)
      g_print (&quot;buffer_write: tid %#x: rdp=%d, wrp=%d, setting space_avail\n&quot;,
<span class="line-modified">!          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
    SetEvent (channel-&gt;space_avail_event);
  
    if ((channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)
      {
        /* Buffer is full */
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;buffer_write: tid %#x: resetting data_avail\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id);</span>
        ResetEvent (channel-&gt;data_avail_event);
      }
  
    LeaveCriticalSection (&amp;channel-&gt;mutex);
  
<span class="line-new-header">--- 627,66 ---</span>
  }
  
  
  static GIOStatus
  buffer_write (GIOWin32Channel *channel,
<span class="line-modified">!         const gchar     *dest,</span>
<span class="line-modified">!         gsize            count,</span>
<span class="line-modified">!         gsize           *bytes_written,</span>
<span class="line-modified">!         GError         **err)</span>
  {
    guint nbytes;
    guint left = count;
  
    EnterCriticalSection (&amp;channel-&gt;mutex);
    if (channel-&gt;debug)
      g_print (&quot;buffer_write: writing to thread %#x %&quot; G_GSIZE_FORMAT &quot; bytes, rdp=%d, wrp=%d\n&quot;,
<span class="line-modified">!        channel-&gt;thread_id, count, channel-&gt;rdp, channel-&gt;wrp);</span>
  
    if ((channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)
      {
        /* Buffer is full */
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;buffer_write: tid %#x: resetting data_avail\n&quot;,</span>
<span class="line-modified">!      channel-&gt;thread_id);</span>
        ResetEvent (channel-&gt;data_avail_event);
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;buffer_write: tid %#x: waiting for space\n&quot;,</span>
<span class="line-modified">!      channel-&gt;thread_id);</span>
        LeaveCriticalSection (&amp;channel-&gt;mutex);
        WaitForSingleObject (channel-&gt;data_avail_event, INFINITE);
        EnterCriticalSection (&amp;channel-&gt;mutex);
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;buffer_write: tid %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified">!      channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
      }
  
    nbytes = MIN ((channel-&gt;rdp + BUFFER_SIZE - channel-&gt;wrp - 1) % BUFFER_SIZE,
<span class="line-modified">!     BUFFER_SIZE - channel-&gt;wrp);</span>
  
    LeaveCriticalSection (&amp;channel-&gt;mutex);
    nbytes = MIN (left, nbytes);
    if (channel-&gt;debug)
      g_print (&quot;buffer_write: tid %#x: writing %d bytes\n&quot;,
<span class="line-modified">!        channel-&gt;thread_id, nbytes);</span>
    memcpy (channel-&gt;buffer + channel-&gt;wrp, dest, nbytes);
    dest += nbytes;
    left -= nbytes;
    EnterCriticalSection (&amp;channel-&gt;mutex);
  
    channel-&gt;wrp = (channel-&gt;wrp + nbytes) % BUFFER_SIZE;
    if (channel-&gt;debug)
      g_print (&quot;buffer_write: tid %#x: rdp=%d, wrp=%d, setting space_avail\n&quot;,
<span class="line-modified">!        channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
    SetEvent (channel-&gt;space_avail_event);
  
    if ((channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)
      {
        /* Buffer is full */
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;buffer_write: tid %#x: resetting data_avail\n&quot;,</span>
<span class="line-modified">!      channel-&gt;thread_id);</span>
        ResetEvent (channel-&gt;data_avail_event);
      }
  
    LeaveCriticalSection (&amp;channel-&gt;mutex);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 698,11 ***</span>
  }
  
  
  static gboolean
  g_io_win32_prepare (GSource *source,
<span class="line-modified">!             gint    *timeout)</span>
  {
    GIOWin32Watch *watch = (GIOWin32Watch *)source;
    GIOCondition buffer_condition = g_io_channel_get_buffer_condition (watch-&gt;channel);
    GIOWin32Channel *channel = (GIOWin32Channel *)watch-&gt;channel;
    int event_mask;
<span class="line-new-header">--- 698,11 ---</span>
  }
  
  
  static gboolean
  g_io_win32_prepare (GSource *source,
<span class="line-modified">!         gint    *timeout)</span>
  {
    GIOWin32Watch *watch = (GIOWin32Watch *)source;
    GIOCondition buffer_condition = g_io_channel_get_buffer_condition (watch-&gt;channel);
    GIOWin32Channel *channel = (GIOWin32Channel *)watch-&gt;channel;
    int event_mask;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 714,90 ***</span>
  
    switch (channel-&gt;type)
      {
      case G_IO_WIN32_WINDOWS_MESSAGES:
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot; MSG&quot;);</span>
        break;
  
      case G_IO_WIN32_CONSOLE:
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot; CON&quot;);</span>
        break;
  
      case G_IO_WIN32_FILE_DESC:
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot; FD thread=%#x buffer_condition:{%s}&quot;</span>
<span class="line-modified">!          &quot;\n  watch-&gt;pollfd.events:{%s} watch-&gt;pollfd.revents:{%s} channel-&gt;revents:{%s}&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id, condition_to_string (buffer_condition),</span>
<span class="line-modified">!          condition_to_string (watch-&gt;pollfd.events),</span>
<span class="line-modified">!          condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified">!          condition_to_string (channel-&gt;revents));</span>
  
        EnterCriticalSection (&amp;channel-&gt;mutex);
        if (channel-&gt;running)
<span class="line-modified">!     {</span>
<span class="line-modified">!       if (channel-&gt;direction == 0 &amp;&amp; channel-&gt;wrp == channel-&gt;rdp)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           if (channel-&gt;debug)</span>
<span class="line-modified">!         g_print (&quot;\n  setting revents=0&quot;);</span>
<span class="line-modified">!           channel-&gt;revents = 0;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       if (channel-&gt;direction == 1</span>
<span class="line-modified">!           &amp;&amp; (channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           if (channel-&gt;debug)</span>
<span class="line-modified">!         g_print (&quot;\n setting revents=0&quot;);</span>
<span class="line-modified">!           channel-&gt;revents = 0;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
        LeaveCriticalSection (&amp;channel-&gt;mutex);
        break;
  
      case G_IO_WIN32_SOCKET:
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot; SOCK&quot;);</span>
        event_mask = 0;
        if (watch-&gt;condition &amp; G_IO_IN)
<span class="line-modified">!     event_mask |= (FD_READ | FD_ACCEPT);</span>
        if (watch-&gt;condition &amp; G_IO_OUT)
<span class="line-modified">!     event_mask |= (FD_WRITE | FD_CONNECT);</span>
        event_mask |= FD_CLOSE;
  
        if (channel-&gt;event_mask != event_mask)
<span class="line-modified">!     {</span>
        if (channel-&gt;debug)
<span class="line-modified">!         g_print (&quot;\n  WSAEventSelect(%d,%p,{%s})&quot;,</span>
<span class="line-modified">!              channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd,</span>
<span class="line-removed">-              event_mask_to_string (event_mask));</span>
<span class="line-removed">-       if (WSAEventSelect (channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd,</span>
<span class="line-removed">-                   event_mask) == SOCKET_ERROR)</span>
<span class="line-removed">-         if (channel-&gt;debug)</span>
<span class="line-removed">-           {</span>
<span class="line-removed">-         gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
  
<span class="line-modified">!         g_print (&quot; failed: %s&quot;, emsg);</span>
<span class="line-modified">!         g_free (emsg);</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!       channel-&gt;event_mask = event_mask;</span>
  
<span class="line-modified">!       if (channel-&gt;debug)</span>
<span class="line-modified">!         g_print (&quot;\n  setting last_events=0&quot;);</span>
<span class="line-modified">!       channel-&gt;last_events = 0;</span>
  
<span class="line-modified">!       if ((event_mask &amp; FD_WRITE) &amp;&amp;</span>
<span class="line-modified">!           channel-&gt;ever_writable &amp;&amp;</span>
<span class="line-modified">!           !channel-&gt;write_would_have_blocked)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           if (channel-&gt;debug)</span>
<span class="line-modified">!         g_print (&quot; WSASetEvent(%p)&quot;, (WSAEVENT) watch-&gt;pollfd.fd);</span>
<span class="line-modified">!           WSASetEvent ((WSAEVENT) watch-&gt;pollfd.fd);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
        break;
  
      default:
        g_assert_not_reached ();
        g_abort ();
<span class="line-new-header">--- 714,90 ---</span>
  
    switch (channel-&gt;type)
      {
      case G_IO_WIN32_WINDOWS_MESSAGES:
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot; MSG&quot;);</span>
        break;
  
      case G_IO_WIN32_CONSOLE:
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot; CON&quot;);</span>
        break;
  
      case G_IO_WIN32_FILE_DESC:
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot; FD thread=%#x buffer_condition:{%s}&quot;</span>
<span class="line-modified">!      &quot;\n  watch-&gt;pollfd.events:{%s} watch-&gt;pollfd.revents:{%s} channel-&gt;revents:{%s}&quot;,</span>
<span class="line-modified">!      channel-&gt;thread_id, condition_to_string (buffer_condition),</span>
<span class="line-modified">!      condition_to_string (watch-&gt;pollfd.events),</span>
<span class="line-modified">!      condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified">!      condition_to_string (channel-&gt;revents));</span>
  
        EnterCriticalSection (&amp;channel-&gt;mutex);
        if (channel-&gt;running)
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (channel-&gt;direction == 0 &amp;&amp; channel-&gt;wrp == channel-&gt;rdp)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         if (channel-&gt;debug)</span>
<span class="line-modified">!     g_print (&quot;\n  setting revents=0&quot;);</span>
<span class="line-modified">!         channel-&gt;revents = 0;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (channel-&gt;direction == 1</span>
<span class="line-modified">!         &amp;&amp; (channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         if (channel-&gt;debug)</span>
<span class="line-modified">!     g_print (&quot;\n setting revents=0&quot;);</span>
<span class="line-modified">!         channel-&gt;revents = 0;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!   }</span>
        LeaveCriticalSection (&amp;channel-&gt;mutex);
        break;
  
      case G_IO_WIN32_SOCKET:
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot; SOCK&quot;);</span>
        event_mask = 0;
        if (watch-&gt;condition &amp; G_IO_IN)
<span class="line-modified">!   event_mask |= (FD_READ | FD_ACCEPT);</span>
        if (watch-&gt;condition &amp; G_IO_OUT)
<span class="line-modified">!   event_mask |= (FD_WRITE | FD_CONNECT);</span>
        event_mask |= FD_CLOSE;
  
        if (channel-&gt;event_mask != event_mask)
<span class="line-modified">!   {</span>
<span class="line-added">+     if (channel-&gt;debug)</span>
<span class="line-added">+       g_print (&quot;\n  WSAEventSelect(%d,%p,{%s})&quot;,</span>
<span class="line-added">+          channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd,</span>
<span class="line-added">+          event_mask_to_string (event_mask));</span>
<span class="line-added">+     if (WSAEventSelect (channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd,</span>
<span class="line-added">+             event_mask) == SOCKET_ERROR)</span>
        if (channel-&gt;debug)
<span class="line-modified">!         {</span>
<span class="line-modified">!     gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
  
<span class="line-modified">!     g_print (&quot; failed: %s&quot;, emsg);</span>
<span class="line-modified">!     g_free (emsg);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     channel-&gt;event_mask = event_mask;</span>
  
<span class="line-modified">!     if (channel-&gt;debug)</span>
<span class="line-modified">!       g_print (&quot;\n  setting last_events=0&quot;);</span>
<span class="line-modified">!     channel-&gt;last_events = 0;</span>
  
<span class="line-modified">!     if ((event_mask &amp; FD_WRITE) &amp;&amp;</span>
<span class="line-modified">!         channel-&gt;ever_writable &amp;&amp;</span>
<span class="line-modified">!         !channel-&gt;write_would_have_blocked)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         if (channel-&gt;debug)</span>
<span class="line-modified">!     g_print (&quot; WSASetEvent(%p)&quot;, (WSAEVENT) watch-&gt;pollfd.fd);</span>
<span class="line-modified">!         WSASetEvent ((WSAEVENT) watch-&gt;pollfd.fd);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!   }</span>
        break;
  
      default:
        g_assert_not_reached ();
        g_abort ();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 822,128 ***</span>
  
    switch (channel-&gt;type)
      {
      case G_IO_WIN32_WINDOWS_MESSAGES:
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot; MSG\n&quot;);</span>
        return (PeekMessage (&amp;msg, channel-&gt;hwnd, 0, 0, PM_NOREMOVE));
  
      case G_IO_WIN32_FILE_DESC:
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot; FD thread=%#x buffer_condition=%s\n&quot;</span>
<span class="line-modified">!          &quot;  watch-&gt;pollfd.events={%s} watch-&gt;pollfd.revents={%s} channel-&gt;revents={%s}\n&quot;,</span>
<span class="line-modified">!          channel-&gt;thread_id, condition_to_string (buffer_condition),</span>
<span class="line-modified">!          condition_to_string (watch-&gt;pollfd.events),</span>
<span class="line-modified">!          condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified">!          condition_to_string (channel-&gt;revents));</span>
  
        watch-&gt;pollfd.revents = (watch-&gt;pollfd.events &amp; channel-&gt;revents);
  
        return ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition);
  
      case G_IO_WIN32_CONSOLE:
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot; CON\n&quot;);</span>
        if (watch-&gt;channel-&gt;is_writeable)
<span class="line-modified">!     return TRUE;</span>
        else if (watch-&gt;channel-&gt;is_readable)
          {
<span class="line-modified">!       INPUT_RECORD buffer;</span>
<span class="line-modified">!       DWORD n;</span>
<span class="line-modified">!       if (PeekConsoleInput ((HANDLE) watch-&gt;pollfd.fd, &amp;buffer, 1, &amp;n) &amp;&amp;</span>
<span class="line-modified">!           n == 1)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           /* _kbhit() does quite complex processing to find out</span>
<span class="line-modified">!            * whether at least one of the key events pending corresponds</span>
<span class="line-modified">!            * to a &quot;real&quot; character that can be read.</span>
<span class="line-modified">!            */</span>
<span class="line-modified">!           if (_kbhit ())</span>
<span class="line-modified">!         return TRUE;</span>
<span class="line-modified">! </span>
<span class="line-modified">!           /* Discard all other kinds of events */</span>
<span class="line-modified">!           ReadConsoleInput ((HANDLE) watch-&gt;pollfd.fd, &amp;buffer, 1, &amp;n);</span>
<span class="line-modified">!         }</span>
          }
        return FALSE;
  
      case G_IO_WIN32_SOCKET:
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot; SOCK&quot;);</span>
        if (channel-&gt;last_events &amp; FD_WRITE)
<span class="line-modified">!     {</span>
<span class="line-modified">!       if (channel-&gt;debug)</span>
<span class="line-modified">!         g_print (&quot; sock=%d event=%p last_events has FD_WRITE&quot;,</span>
<span class="line-modified">!              channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd);</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       WSAEnumNetworkEvents (channel-&gt;fd, 0, &amp;events);</span>
  
<span class="line-modified">!       if (channel-&gt;debug)</span>
<span class="line-modified">!         g_print (&quot;\n  revents={%s} condition={%s}&quot;</span>
<span class="line-modified">!              &quot;\n  WSAEnumNetworkEvents(%d,0) sets events={%s}&quot;,</span>
<span class="line-modified">!              condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified">!              condition_to_string (watch-&gt;condition),</span>
<span class="line-modified">!              channel-&gt;fd,</span>
<span class="line-modified">!              event_mask_to_string (events.lNetworkEvents));</span>
<span class="line-modified">! </span>
<span class="line-modified">!       if (watch-&gt;pollfd.revents != 0 &amp;&amp;</span>
<span class="line-modified">!           events.lNetworkEvents == 0 &amp;&amp;</span>
<span class="line-modified">!           !(channel-&gt;event_mask &amp; FD_WRITE))</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           channel-&gt;event_mask = 0;</span>
<span class="line-modified">!           if (channel-&gt;debug)</span>
<span class="line-modified">!         g_print (&quot;\n  WSAEventSelect(%d,%p,{})&quot;,</span>
<span class="line-modified">!              channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd);</span>
<span class="line-modified">!           WSAEventSelect (channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd, 0);</span>
<span class="line-modified">!           if (channel-&gt;debug)</span>
<span class="line-modified">!         g_print (&quot;  ResetEvent(%p)&quot;,</span>
<span class="line-modified">!              (HANDLE) watch-&gt;pollfd.fd);</span>
<span class="line-modified">!           ResetEvent ((HANDLE) watch-&gt;pollfd.fd);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       else if (events.lNetworkEvents &amp; FD_WRITE)</span>
<span class="line-modified">!         channel-&gt;ever_writable = TRUE;</span>
<span class="line-modified">!       channel-&gt;last_events = events.lNetworkEvents;</span>
<span class="line-modified">!     }</span>
  
        watch-&gt;pollfd.revents = 0;
        if (channel-&gt;last_events &amp; (FD_READ | FD_ACCEPT))
<span class="line-modified">!     watch-&gt;pollfd.revents |= G_IO_IN;</span>
  
        if (channel-&gt;last_events &amp; FD_WRITE)
<span class="line-modified">!     watch-&gt;pollfd.revents |= G_IO_OUT;</span>
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       /* We have called WSAEnumNetworkEvents() above but it didn&#39;t</span>
<span class="line-modified">!        * set FD_WRITE.</span>
<span class="line-modified">!        */</span>
<span class="line-modified">!       if (events.lNetworkEvents &amp; FD_CONNECT)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           if (events.iErrorCode[FD_CONNECT_BIT] == 0)</span>
<span class="line-modified">!         watch-&gt;pollfd.revents |= G_IO_OUT;</span>
<span class="line-modified">!           else</span>
<span class="line-modified">!         watch-&gt;pollfd.revents |= (G_IO_HUP | G_IO_ERR);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       if (watch-&gt;pollfd.revents == 0 &amp;&amp; (channel-&gt;last_events &amp; (FD_CLOSE)))</span>
<span class="line-modified">!         watch-&gt;pollfd.revents |= G_IO_HUP;</span>
<span class="line-modified">!     }</span>
  
        /* Regardless of WSAEnumNetworkEvents() result, if watching for
         * writability, and if we have ever got a FD_WRITE event, and
         * unless last write would have blocked, set G_IO_OUT. But never
         * set both G_IO_OUT and G_IO_HUP.
         */
        if (!(watch-&gt;pollfd.revents &amp; G_IO_HUP) &amp;&amp;
<span class="line-modified">!       channel-&gt;ever_writable &amp;&amp;</span>
<span class="line-modified">!       !channel-&gt;write_would_have_blocked &amp;&amp;</span>
<span class="line-modified">!       (channel-&gt;event_mask &amp; FD_WRITE))</span>
<span class="line-modified">!     watch-&gt;pollfd.revents |= G_IO_OUT;</span>
  
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;\n  revents={%s} retval={%s}\n&quot;,</span>
<span class="line-modified">!          condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified">!          condition_to_string ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition));</span>
  
        return ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition);
  
      default:
        g_assert_not_reached ();
<span class="line-new-header">--- 822,128 ---</span>
  
    switch (channel-&gt;type)
      {
      case G_IO_WIN32_WINDOWS_MESSAGES:
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot; MSG\n&quot;);</span>
        return (PeekMessage (&amp;msg, channel-&gt;hwnd, 0, 0, PM_NOREMOVE));
  
      case G_IO_WIN32_FILE_DESC:
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot; FD thread=%#x buffer_condition=%s\n&quot;</span>
<span class="line-modified">!      &quot;  watch-&gt;pollfd.events={%s} watch-&gt;pollfd.revents={%s} channel-&gt;revents={%s}\n&quot;,</span>
<span class="line-modified">!      channel-&gt;thread_id, condition_to_string (buffer_condition),</span>
<span class="line-modified">!      condition_to_string (watch-&gt;pollfd.events),</span>
<span class="line-modified">!      condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified">!      condition_to_string (channel-&gt;revents));</span>
  
        watch-&gt;pollfd.revents = (watch-&gt;pollfd.events &amp; channel-&gt;revents);
  
        return ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition);
  
      case G_IO_WIN32_CONSOLE:
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot; CON\n&quot;);</span>
        if (watch-&gt;channel-&gt;is_writeable)
<span class="line-modified">!   return TRUE;</span>
        else if (watch-&gt;channel-&gt;is_readable)
          {
<span class="line-modified">!     INPUT_RECORD buffer;</span>
<span class="line-modified">!     DWORD n;</span>
<span class="line-modified">!     if (PeekConsoleInput ((HANDLE) watch-&gt;pollfd.fd, &amp;buffer, 1, &amp;n) &amp;&amp;</span>
<span class="line-modified">!         n == 1)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         /* _kbhit() does quite complex processing to find out</span>
<span class="line-modified">!          * whether at least one of the key events pending corresponds</span>
<span class="line-modified">!          * to a &quot;real&quot; character that can be read.</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         if (_kbhit ())</span>
<span class="line-modified">!     return TRUE;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         /* Discard all other kinds of events */</span>
<span class="line-modified">!         ReadConsoleInput ((HANDLE) watch-&gt;pollfd.fd, &amp;buffer, 1, &amp;n);</span>
<span class="line-modified">!       }</span>
          }
        return FALSE;
  
      case G_IO_WIN32_SOCKET:
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot; SOCK&quot;);</span>
        if (channel-&gt;last_events &amp; FD_WRITE)
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (channel-&gt;debug)</span>
<span class="line-modified">!       g_print (&quot; sock=%d event=%p last_events has FD_WRITE&quot;,</span>
<span class="line-modified">!          channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd);</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     WSAEnumNetworkEvents (channel-&gt;fd, 0, &amp;events);</span>
  
<span class="line-modified">!     if (channel-&gt;debug)</span>
<span class="line-modified">!       g_print (&quot;\n  revents={%s} condition={%s}&quot;</span>
<span class="line-modified">!          &quot;\n  WSAEnumNetworkEvents(%d,0) sets events={%s}&quot;,</span>
<span class="line-modified">!          condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified">!          condition_to_string (watch-&gt;condition),</span>
<span class="line-modified">!          channel-&gt;fd,</span>
<span class="line-modified">!          event_mask_to_string (events.lNetworkEvents));</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (watch-&gt;pollfd.revents != 0 &amp;&amp;</span>
<span class="line-modified">!         events.lNetworkEvents == 0 &amp;&amp;</span>
<span class="line-modified">!         !(channel-&gt;event_mask &amp; FD_WRITE))</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         channel-&gt;event_mask = 0;</span>
<span class="line-modified">!         if (channel-&gt;debug)</span>
<span class="line-modified">!     g_print (&quot;\n  WSAEventSelect(%d,%p,{})&quot;,</span>
<span class="line-modified">!        channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd);</span>
<span class="line-modified">!         WSAEventSelect (channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd, 0);</span>
<span class="line-modified">!         if (channel-&gt;debug)</span>
<span class="line-modified">!     g_print (&quot;  ResetEvent(%p)&quot;,</span>
<span class="line-modified">!        (HANDLE) watch-&gt;pollfd.fd);</span>
<span class="line-modified">!         ResetEvent ((HANDLE) watch-&gt;pollfd.fd);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     else if (events.lNetworkEvents &amp; FD_WRITE)</span>
<span class="line-modified">!       channel-&gt;ever_writable = TRUE;</span>
<span class="line-modified">!     channel-&gt;last_events = events.lNetworkEvents;</span>
<span class="line-modified">!   }</span>
  
        watch-&gt;pollfd.revents = 0;
        if (channel-&gt;last_events &amp; (FD_READ | FD_ACCEPT))
<span class="line-modified">!   watch-&gt;pollfd.revents |= G_IO_IN;</span>
  
        if (channel-&gt;last_events &amp; FD_WRITE)
<span class="line-modified">!   watch-&gt;pollfd.revents |= G_IO_OUT;</span>
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     /* We have called WSAEnumNetworkEvents() above but it didn&#39;t</span>
<span class="line-modified">!      * set FD_WRITE.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     if (events.lNetworkEvents &amp; FD_CONNECT)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         if (events.iErrorCode[FD_CONNECT_BIT] == 0)</span>
<span class="line-modified">!     watch-&gt;pollfd.revents |= G_IO_OUT;</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!     watch-&gt;pollfd.revents |= (G_IO_HUP | G_IO_ERR);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     if (watch-&gt;pollfd.revents == 0 &amp;&amp; (channel-&gt;last_events &amp; (FD_CLOSE)))</span>
<span class="line-modified">!       watch-&gt;pollfd.revents |= G_IO_HUP;</span>
<span class="line-modified">!   }</span>
  
        /* Regardless of WSAEnumNetworkEvents() result, if watching for
         * writability, and if we have ever got a FD_WRITE event, and
         * unless last write would have blocked, set G_IO_OUT. But never
         * set both G_IO_OUT and G_IO_HUP.
         */
        if (!(watch-&gt;pollfd.revents &amp; G_IO_HUP) &amp;&amp;
<span class="line-modified">!     channel-&gt;ever_writable &amp;&amp;</span>
<span class="line-modified">!     !channel-&gt;write_would_have_blocked &amp;&amp;</span>
<span class="line-modified">!     (channel-&gt;event_mask &amp; FD_WRITE))</span>
<span class="line-modified">!   watch-&gt;pollfd.revents |= G_IO_OUT;</span>
  
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;\n  revents={%s} retval={%s}\n&quot;,</span>
<span class="line-modified">!      condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified">!      condition_to_string ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition));</span>
  
        return ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition);
  
      default:
        g_assert_not_reached ();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 951,34 ***</span>
      }
  }
  
  static gboolean
  g_io_win32_dispatch (GSource     *source,
<span class="line-modified">!              GSourceFunc  callback,</span>
<span class="line-modified">!              gpointer     user_data)</span>
  {
    GIOFunc func = (GIOFunc)callback;
    GIOWin32Watch *watch = (GIOWin32Watch *)source;
    GIOWin32Channel *channel = (GIOWin32Channel *)watch-&gt;channel;
    GIOCondition buffer_condition = g_io_channel_get_buffer_condition (watch-&gt;channel);
  
    if (!func)
      {
        g_warning (&quot;IO Watch dispatched without callback. &quot;
<span class="line-modified">!          &quot;You must call g_source_connect().&quot;);</span>
        return FALSE;
      }
  
    if (channel-&gt;debug)
      g_print (&quot;g_io_win32_dispatch: pollfd.revents=%s condition=%s result=%s\n&quot;,
<span class="line-modified">!          condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified">!          condition_to_string (watch-&gt;condition),</span>
<span class="line-modified">!          condition_to_string ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition));</span>
  
    return (*func) (watch-&gt;channel,
<span class="line-modified">!           (watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition,</span>
<span class="line-modified">!           user_data);</span>
  }
  
  static void
  g_io_win32_finalize (GSource *source)
  {
<span class="line-new-header">--- 951,34 ---</span>
      }
  }
  
  static gboolean
  g_io_win32_dispatch (GSource     *source,
<span class="line-modified">!          GSourceFunc  callback,</span>
<span class="line-modified">!          gpointer     user_data)</span>
  {
    GIOFunc func = (GIOFunc)callback;
    GIOWin32Watch *watch = (GIOWin32Watch *)source;
    GIOWin32Channel *channel = (GIOWin32Channel *)watch-&gt;channel;
    GIOCondition buffer_condition = g_io_channel_get_buffer_condition (watch-&gt;channel);
  
    if (!func)
      {
        g_warning (&quot;IO Watch dispatched without callback. &quot;
<span class="line-modified">!      &quot;You must call g_source_connect().&quot;);</span>
        return FALSE;
      }
  
    if (channel-&gt;debug)
      g_print (&quot;g_io_win32_dispatch: pollfd.revents=%s condition=%s result=%s\n&quot;,
<span class="line-modified">!        condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified">!        condition_to_string (watch-&gt;condition),</span>
<span class="line-modified">!        condition_to_string ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition));</span>
  
    return (*func) (watch-&gt;channel,
<span class="line-modified">!       (watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition,</span>
<span class="line-modified">!       user_data);</span>
  }
  
  static void
  g_io_win32_finalize (GSource *source)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 990,26 ***</span>
  
    switch (channel-&gt;type)
      {
      case G_IO_WIN32_WINDOWS_MESSAGES:
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot; MSG&quot;);</span>
        break;
  
      case G_IO_WIN32_CONSOLE:
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot; CON&quot;);</span>
        break;
  
      case G_IO_WIN32_FILE_DESC:
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot; FD thread=%#x&quot;, channel-&gt;thread_id);</span>
        break;
  
      case G_IO_WIN32_SOCKET:
        if (channel-&gt;debug)
<span class="line-modified">!     g_print (&quot; SOCK sock=%d&quot;, channel-&gt;fd);</span>
        break;
  
      default:
        g_assert_not_reached ();
        g_abort ();
<span class="line-new-header">--- 990,26 ---</span>
  
    switch (channel-&gt;type)
      {
      case G_IO_WIN32_WINDOWS_MESSAGES:
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot; MSG&quot;);</span>
        break;
  
      case G_IO_WIN32_CONSOLE:
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot; CON&quot;);</span>
        break;
  
      case G_IO_WIN32_FILE_DESC:
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot; FD thread=%#x&quot;, channel-&gt;thread_id);</span>
        break;
  
      case G_IO_WIN32_SOCKET:
        if (channel-&gt;debug)
<span class="line-modified">!   g_print (&quot; SOCK sock=%d&quot;, channel-&gt;fd);</span>
        break;
  
      default:
        g_assert_not_reached ();
        g_abort ();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1026,14 ***</span>
    g_io_win32_finalize
  };
  
  static GIOStatus
  g_io_win32_msg_read (GIOChannel *channel,
<span class="line-modified">!              gchar      *buf,</span>
<span class="line-modified">!              gsize       count,</span>
<span class="line-modified">!              gsize      *bytes_read,</span>
<span class="line-modified">!              GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    MSG msg;               /* In case of alignment problems */
  
    *bytes_read = 0;
<span class="line-new-header">--- 1026,14 ---</span>
    g_io_win32_finalize
  };
  
  static GIOStatus
  g_io_win32_msg_read (GIOChannel *channel,
<span class="line-modified">!          gchar      *buf,</span>
<span class="line-modified">!          gsize       count,</span>
<span class="line-modified">!          gsize      *bytes_read,</span>
<span class="line-modified">!          GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    MSG msg;               /* In case of alignment problems */
  
    *bytes_read = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1045,11 ***</span>
        return G_IO_STATUS_ERROR;
      }
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_win32_msg_read: channel=%p hwnd=%p\n&quot;,
<span class="line-modified">!          channel, win32_channel-&gt;hwnd);</span>
    if (!PeekMessage (&amp;msg, win32_channel-&gt;hwnd, 0, 0, PM_REMOVE))
      return G_IO_STATUS_AGAIN;
  
    memmove (buf, &amp;msg, sizeof (MSG));
    *bytes_read = sizeof (MSG);
<span class="line-new-header">--- 1045,11 ---</span>
        return G_IO_STATUS_ERROR;
      }
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_win32_msg_read: channel=%p hwnd=%p\n&quot;,
<span class="line-modified">!        channel, win32_channel-&gt;hwnd);</span>
    if (!PeekMessage (&amp;msg, win32_channel-&gt;hwnd, 0, 0, PM_REMOVE))
      return G_IO_STATUS_AGAIN;
  
    memmove (buf, &amp;msg, sizeof (MSG));
    *bytes_read = sizeof (MSG);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1057,14 ***</span>
    return G_IO_STATUS_NORMAL;
  }
  
  static GIOStatus
  g_io_win32_msg_write (GIOChannel  *channel,
<span class="line-modified">!               const gchar *buf,</span>
<span class="line-modified">!               gsize        count,</span>
<span class="line-modified">!               gsize       *bytes_written,</span>
<span class="line-modified">!               GError     **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    MSG msg;
  
    *bytes_written = 0;
<span class="line-new-header">--- 1057,14 ---</span>
    return G_IO_STATUS_NORMAL;
  }
  
  static GIOStatus
  g_io_win32_msg_write (GIOChannel  *channel,
<span class="line-modified">!           const gchar *buf,</span>
<span class="line-modified">!           gsize        count,</span>
<span class="line-modified">!           gsize       *bytes_written,</span>
<span class="line-modified">!           GError     **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    MSG msg;
  
    *bytes_written = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1093,11 ***</span>
    return G_IO_STATUS_NORMAL;
  }
  
  static GIOStatus
  g_io_win32_msg_close (GIOChannel *channel,
<span class="line-modified">!               GError    **err)</span>
  {
    /* Nothing to be done. Or should we set hwnd to some invalid value? */
  
    return G_IO_STATUS_NORMAL;
  }
<span class="line-new-header">--- 1093,11 ---</span>
    return G_IO_STATUS_NORMAL;
  }
  
  static GIOStatus
  g_io_win32_msg_close (GIOChannel *channel,
<span class="line-modified">!           GError    **err)</span>
  {
    /* Nothing to be done. Or should we set hwnd to some invalid value? */
  
    return G_IO_STATUS_NORMAL;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1113,60 ***</span>
    DeleteCriticalSection (&amp;win32_channel-&gt;mutex);
  
    if (win32_channel-&gt;data_avail_event)
      if (!CloseHandle (win32_channel-&gt;data_avail_event))
        if (win32_channel-&gt;debug)
<span class="line-modified">!     {</span>
<span class="line-modified">!       gchar *emsg = g_win32_error_message (GetLastError ());</span>
  
<span class="line-modified">!       g_print (&quot;  CloseHandle(%p) failed: %s\n&quot;,</span>
<span class="line-modified">!            win32_channel-&gt;data_avail_event, emsg);</span>
<span class="line-modified">!       g_free (emsg);</span>
<span class="line-modified">!     }</span>
  
    g_free (win32_channel-&gt;buffer);
  
    if (win32_channel-&gt;space_avail_event)
      if (!CloseHandle (win32_channel-&gt;space_avail_event))
        if (win32_channel-&gt;debug)
<span class="line-modified">!     {</span>
<span class="line-modified">!       gchar *emsg = g_win32_error_message (GetLastError ());</span>
  
<span class="line-modified">!       g_print (&quot;  CloseHandle(%p) failed: %s\n&quot;,</span>
<span class="line-modified">!            win32_channel-&gt;space_avail_event, emsg);</span>
<span class="line-modified">!       g_free (emsg);</span>
<span class="line-modified">!     }</span>
  
    if (win32_channel-&gt;type == G_IO_WIN32_SOCKET &amp;&amp;
        win32_channel-&gt;fd != -1)
      if (WSAEventSelect (win32_channel-&gt;fd, NULL, 0) == SOCKET_ERROR)
        if (win32_channel-&gt;debug)
<span class="line-modified">!     {</span>
<span class="line-modified">!       gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
  
<span class="line-modified">!       g_print (&quot;  WSAEventSelect(%d,NULL,{}) failed: %s\n&quot;,</span>
<span class="line-modified">!            win32_channel-&gt;fd, emsg);</span>
<span class="line-modified">!       g_free (emsg);</span>
<span class="line-modified">!     }</span>
  
    if (win32_channel-&gt;event)
      if (!WSACloseEvent (win32_channel-&gt;event))
        if (win32_channel-&gt;debug)
<span class="line-modified">!     {</span>
<span class="line-modified">!       gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
  
<span class="line-modified">!       g_print (&quot;  WSACloseEvent(%p) failed: %s\n&quot;,</span>
<span class="line-modified">!            win32_channel-&gt;event, emsg);</span>
<span class="line-modified">!       g_free (emsg);</span>
<span class="line-modified">!     }</span>
  
    g_free (win32_channel);
  }
  
  static GSource *
  g_io_win32_msg_create_watch (GIOChannel   *channel,
<span class="line-modified">!                  GIOCondition  condition)</span>
  {
    GIOWin32Watch *watch;
    GSource *source;
  
    source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
<span class="line-new-header">--- 1113,60 ---</span>
    DeleteCriticalSection (&amp;win32_channel-&gt;mutex);
  
    if (win32_channel-&gt;data_avail_event)
      if (!CloseHandle (win32_channel-&gt;data_avail_event))
        if (win32_channel-&gt;debug)
<span class="line-modified">!   {</span>
<span class="line-modified">!     gchar *emsg = g_win32_error_message (GetLastError ());</span>
  
<span class="line-modified">!     g_print (&quot;  CloseHandle(%p) failed: %s\n&quot;,</span>
<span class="line-modified">!        win32_channel-&gt;data_avail_event, emsg);</span>
<span class="line-modified">!     g_free (emsg);</span>
<span class="line-modified">!   }</span>
  
    g_free (win32_channel-&gt;buffer);
  
    if (win32_channel-&gt;space_avail_event)
      if (!CloseHandle (win32_channel-&gt;space_avail_event))
        if (win32_channel-&gt;debug)
<span class="line-modified">!   {</span>
<span class="line-modified">!     gchar *emsg = g_win32_error_message (GetLastError ());</span>
  
<span class="line-modified">!     g_print (&quot;  CloseHandle(%p) failed: %s\n&quot;,</span>
<span class="line-modified">!        win32_channel-&gt;space_avail_event, emsg);</span>
<span class="line-modified">!     g_free (emsg);</span>
<span class="line-modified">!   }</span>
  
    if (win32_channel-&gt;type == G_IO_WIN32_SOCKET &amp;&amp;
        win32_channel-&gt;fd != -1)
      if (WSAEventSelect (win32_channel-&gt;fd, NULL, 0) == SOCKET_ERROR)
        if (win32_channel-&gt;debug)
<span class="line-modified">!   {</span>
<span class="line-modified">!     gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
  
<span class="line-modified">!     g_print (&quot;  WSAEventSelect(%d,NULL,{}) failed: %s\n&quot;,</span>
<span class="line-modified">!        win32_channel-&gt;fd, emsg);</span>
<span class="line-modified">!     g_free (emsg);</span>
<span class="line-modified">!   }</span>
  
    if (win32_channel-&gt;event)
      if (!WSACloseEvent (win32_channel-&gt;event))
        if (win32_channel-&gt;debug)
<span class="line-modified">!   {</span>
<span class="line-modified">!     gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
  
<span class="line-modified">!     g_print (&quot;  WSACloseEvent(%p) failed: %s\n&quot;,</span>
<span class="line-modified">!        win32_channel-&gt;event, emsg);</span>
<span class="line-modified">!     g_free (emsg);</span>
<span class="line-modified">!   }</span>
  
    g_free (win32_channel);
  }
  
  static GSource *
  g_io_win32_msg_create_watch (GIOChannel   *channel,
<span class="line-modified">!            GIOCondition  condition)</span>
  {
    GIOWin32Watch *watch;
    GSource *source;
  
    source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1186,22 ***</span>
    return source;
  }
  
  static GIOStatus
  g_io_win32_fd_and_console_read (GIOChannel *channel,
<span class="line-modified">!                 gchar      *buf,</span>
<span class="line-modified">!                 gsize       count,</span>
<span class="line-modified">!                 gsize      *bytes_read,</span>
<span class="line-modified">!                 GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    gint result;
    int errsv;
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_win32_fd_read: fd=%d count=%&quot; G_GSIZE_FORMAT &quot;\n&quot;,
<span class="line-modified">!          win32_channel-&gt;fd, count);</span>
  
    if (win32_channel-&gt;thread_id)
      {
        return buffer_read (win32_channel, buf, count, bytes_read, err);
      }
<span class="line-new-header">--- 1186,22 ---</span>
    return source;
  }
  
  static GIOStatus
  g_io_win32_fd_and_console_read (GIOChannel *channel,
<span class="line-modified">!         gchar      *buf,</span>
<span class="line-modified">!         gsize       count,</span>
<span class="line-modified">!         gsize      *bytes_read,</span>
<span class="line-modified">!         GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    gint result;
    int errsv;
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_win32_fd_read: fd=%d count=%&quot; G_GSIZE_FORMAT &quot;\n&quot;,
<span class="line-modified">!        win32_channel-&gt;fd, count);</span>
  
    if (win32_channel-&gt;thread_id)
      {
        return buffer_read (win32_channel, buf, count, bytes_read, err);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1217,32 ***</span>
        *bytes_read = 0;
  
        switch (errsv)
          {
  #ifdef EAGAIN
<span class="line-modified">!     case EAGAIN:</span>
<span class="line-modified">!       return G_IO_STATUS_AGAIN;</span>
  #endif
<span class="line-modified">!     default:</span>
<span class="line-modified">!       g_set_error_literal (err, G_IO_CHANNEL_ERROR,</span>
                                 g_io_channel_error_from_errno (errsv),
                                 g_strerror (errsv));
<span class="line-modified">!       return G_IO_STATUS_ERROR;</span>
          }
      }
  
    *bytes_read = result;
  
    return (result &gt; 0) ? G_IO_STATUS_NORMAL : G_IO_STATUS_EOF;
  }
  
  static GIOStatus
  g_io_win32_fd_and_console_write (GIOChannel  *channel,
<span class="line-modified">!                  const gchar *buf,</span>
<span class="line-modified">!                  gsize        count,</span>
<span class="line-modified">!                  gsize       *bytes_written,</span>
<span class="line-modified">!                  GError     **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    gint result;
    int errsv;
  
<span class="line-new-header">--- 1217,32 ---</span>
        *bytes_read = 0;
  
        switch (errsv)
          {
  #ifdef EAGAIN
<span class="line-modified">!   case EAGAIN:</span>
<span class="line-modified">!     return G_IO_STATUS_AGAIN;</span>
  #endif
<span class="line-modified">!   default:</span>
<span class="line-modified">!     g_set_error_literal (err, G_IO_CHANNEL_ERROR,</span>
                                 g_io_channel_error_from_errno (errsv),
                                 g_strerror (errsv));
<span class="line-modified">!     return G_IO_STATUS_ERROR;</span>
          }
      }
  
    *bytes_read = result;
  
    return (result &gt; 0) ? G_IO_STATUS_NORMAL : G_IO_STATUS_EOF;
  }
  
  static GIOStatus
  g_io_win32_fd_and_console_write (GIOChannel  *channel,
<span class="line-modified">!          const gchar *buf,</span>
<span class="line-modified">!          gsize        count,</span>
<span class="line-modified">!          gsize       *bytes_written,</span>
<span class="line-modified">!          GError     **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    gint result;
    int errsv;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1254,40 ***</span>
    result = write (win32_channel-&gt;fd, buf, count);
    errsv = errno;
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_win32_fd_write: fd=%d count=%&quot; G_GSIZE_FORMAT &quot; =&gt; %d\n&quot;,
<span class="line-modified">!          win32_channel-&gt;fd, count, result);</span>
  
    if (result &lt; 0)
      {
        *bytes_written = 0;
  
        switch (errsv)
          {
  #ifdef EAGAIN
<span class="line-modified">!     case EAGAIN:</span>
<span class="line-modified">!       return G_IO_STATUS_AGAIN;</span>
  #endif
<span class="line-modified">!     default:</span>
<span class="line-modified">!       g_set_error_literal (err, G_IO_CHANNEL_ERROR,</span>
                                 g_io_channel_error_from_errno (errsv),
                                 g_strerror (errsv));
<span class="line-modified">!       return G_IO_STATUS_ERROR;</span>
          }
      }
  
    *bytes_written = result;
  
    return G_IO_STATUS_NORMAL;
  }
  
  static GIOStatus
  g_io_win32_fd_seek (GIOChannel *channel,
<span class="line-modified">!             gint64      offset,</span>
<span class="line-modified">!             GSeekType   type,</span>
<span class="line-modified">!             GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    int whence, errsv;
    off_t tmp_offset;
    off_t result;
<span class="line-new-header">--- 1254,40 ---</span>
    result = write (win32_channel-&gt;fd, buf, count);
    errsv = errno;
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_win32_fd_write: fd=%d count=%&quot; G_GSIZE_FORMAT &quot; =&gt; %d\n&quot;,
<span class="line-modified">!        win32_channel-&gt;fd, count, result);</span>
  
    if (result &lt; 0)
      {
        *bytes_written = 0;
  
        switch (errsv)
          {
  #ifdef EAGAIN
<span class="line-modified">!   case EAGAIN:</span>
<span class="line-modified">!     return G_IO_STATUS_AGAIN;</span>
  #endif
<span class="line-modified">!   default:</span>
<span class="line-modified">!     g_set_error_literal (err, G_IO_CHANNEL_ERROR,</span>
                                 g_io_channel_error_from_errno (errsv),
                                 g_strerror (errsv));
<span class="line-modified">!     return G_IO_STATUS_ERROR;</span>
          }
      }
  
    *bytes_written = result;
  
    return G_IO_STATUS_NORMAL;
  }
  
  static GIOStatus
  g_io_win32_fd_seek (GIOChannel *channel,
<span class="line-modified">!         gint64      offset,</span>
<span class="line-modified">!         GSeekType   type,</span>
<span class="line-modified">!         GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    int whence, errsv;
    off_t tmp_offset;
    off_t result;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1332,39 ***</span>
    return G_IO_STATUS_NORMAL;
  }
  
  static GIOStatus
  g_io_win32_fd_close (GIOChannel *channel,
<span class="line-modified">!                  GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_win32_fd_close: thread=%#x: fd=%d\n&quot;,
<span class="line-modified">!          win32_channel-&gt;thread_id,</span>
<span class="line-modified">!          win32_channel-&gt;fd);</span>
    EnterCriticalSection (&amp;win32_channel-&gt;mutex);
    if (win32_channel-&gt;running)
      {
        if (win32_channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;thread %#x: running, marking fd %d for later close\n&quot;,</span>
<span class="line-modified">!          win32_channel-&gt;thread_id, win32_channel-&gt;fd);</span>
        win32_channel-&gt;running = FALSE;
        win32_channel-&gt;needs_close = TRUE;
        if (win32_channel-&gt;direction == 0)
<span class="line-modified">!     SetEvent (win32_channel-&gt;data_avail_event);</span>
        else
<span class="line-modified">!     SetEvent (win32_channel-&gt;space_avail_event);</span>
      }
    else
      {
        if (win32_channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;closing fd %d\n&quot;, win32_channel-&gt;fd);</span>
        close (win32_channel-&gt;fd);
        if (win32_channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;closed fd %d, setting to -1\n&quot;,</span>
<span class="line-modified">!          win32_channel-&gt;fd);</span>
        win32_channel-&gt;fd = -1;
      }
    LeaveCriticalSection (&amp;win32_channel-&gt;mutex);
  
    /* FIXME error detection? */
<span class="line-new-header">--- 1332,39 ---</span>
    return G_IO_STATUS_NORMAL;
  }
  
  static GIOStatus
  g_io_win32_fd_close (GIOChannel *channel,
<span class="line-modified">!                GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_win32_fd_close: thread=%#x: fd=%d\n&quot;,
<span class="line-modified">!        win32_channel-&gt;thread_id,</span>
<span class="line-modified">!        win32_channel-&gt;fd);</span>
    EnterCriticalSection (&amp;win32_channel-&gt;mutex);
    if (win32_channel-&gt;running)
      {
        if (win32_channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;thread %#x: running, marking fd %d for later close\n&quot;,</span>
<span class="line-modified">!      win32_channel-&gt;thread_id, win32_channel-&gt;fd);</span>
        win32_channel-&gt;running = FALSE;
        win32_channel-&gt;needs_close = TRUE;
        if (win32_channel-&gt;direction == 0)
<span class="line-modified">!   SetEvent (win32_channel-&gt;data_avail_event);</span>
        else
<span class="line-modified">!   SetEvent (win32_channel-&gt;space_avail_event);</span>
      }
    else
      {
        if (win32_channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;closing fd %d\n&quot;, win32_channel-&gt;fd);</span>
        close (win32_channel-&gt;fd);
        if (win32_channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;closed fd %d, setting to -1\n&quot;,</span>
<span class="line-modified">!      win32_channel-&gt;fd);</span>
        win32_channel-&gt;fd = -1;
      }
    LeaveCriticalSection (&amp;win32_channel-&gt;mutex);
  
    /* FIXME error detection? */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1372,11 ***</span>
    return G_IO_STATUS_NORMAL;
  }
  
  static GSource *
  g_io_win32_fd_create_watch (GIOChannel    *channel,
<span class="line-modified">!                 GIOCondition   condition)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    GSource *source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
    GIOWin32Watch *watch = (GIOWin32Watch *)source;
  
<span class="line-new-header">--- 1372,11 ---</span>
    return G_IO_STATUS_NORMAL;
  }
  
  static GSource *
  g_io_win32_fd_create_watch (GIOChannel    *channel,
<span class="line-modified">!           GIOCondition   condition)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    GSource *source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
    GIOWin32Watch *watch = (GIOWin32Watch *)source;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1391,31 ***</span>
    watch-&gt;pollfd.fd = (gintptr) win32_channel-&gt;data_avail_event;
    watch-&gt;pollfd.events = condition;
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_win32_fd_create_watch: channel=%p fd=%d condition={%s} event=%p\n&quot;,
<span class="line-modified">!          channel, win32_channel-&gt;fd,</span>
<span class="line-modified">!          condition_to_string (condition), (HANDLE) watch-&gt;pollfd.fd);</span>
  
    EnterCriticalSection (&amp;win32_channel-&gt;mutex);
    if (win32_channel-&gt;thread_id == 0)
      {
        if (condition &amp; G_IO_IN)
<span class="line-modified">!     create_thread (win32_channel, condition, read_thread);</span>
        else if (condition &amp; G_IO_OUT)
<span class="line-modified">!     create_thread (win32_channel, condition, write_thread);</span>
      }
  
    g_source_add_poll (source, &amp;watch-&gt;pollfd);
    LeaveCriticalSection (&amp;win32_channel-&gt;mutex);
  
    return source;
  }
  
  static GIOStatus
  g_io_win32_console_close (GIOChannel *channel,
<span class="line-modified">!                   GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
  
    if (close (win32_channel-&gt;fd) &lt; 0)
      {
<span class="line-new-header">--- 1391,31 ---</span>
    watch-&gt;pollfd.fd = (gintptr) win32_channel-&gt;data_avail_event;
    watch-&gt;pollfd.events = condition;
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_win32_fd_create_watch: channel=%p fd=%d condition={%s} event=%p\n&quot;,
<span class="line-modified">!        channel, win32_channel-&gt;fd,</span>
<span class="line-modified">!        condition_to_string (condition), (HANDLE) watch-&gt;pollfd.fd);</span>
  
    EnterCriticalSection (&amp;win32_channel-&gt;mutex);
    if (win32_channel-&gt;thread_id == 0)
      {
        if (condition &amp; G_IO_IN)
<span class="line-modified">!   create_thread (win32_channel, condition, read_thread);</span>
        else if (condition &amp; G_IO_OUT)
<span class="line-modified">!   create_thread (win32_channel, condition, write_thread);</span>
      }
  
    g_source_add_poll (source, &amp;watch-&gt;pollfd);
    LeaveCriticalSection (&amp;win32_channel-&gt;mutex);
  
    return source;
  }
  
  static GIOStatus
  g_io_win32_console_close (GIOChannel *channel,
<span class="line-modified">!               GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
  
    if (close (win32_channel-&gt;fd) &lt; 0)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1429,11 ***</span>
    return G_IO_STATUS_NORMAL;
  }
  
  static GSource *
  g_io_win32_console_create_watch (GIOChannel    *channel,
<span class="line-modified">!                  GIOCondition   condition)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    GSource *source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
    GIOWin32Watch *watch = (GIOWin32Watch *)source;
  
<span class="line-new-header">--- 1429,11 ---</span>
    return G_IO_STATUS_NORMAL;
  }
  
  static GSource *
  g_io_win32_console_create_watch (GIOChannel    *channel,
<span class="line-modified">!          GIOCondition   condition)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    GSource *source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
    GIOWin32Watch *watch = (GIOWin32Watch *)source;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1450,23 ***</span>
    return source;
  }
  
  static GIOStatus
  g_io_win32_sock_read (GIOChannel *channel,
<span class="line-modified">!               gchar      *buf,</span>
<span class="line-modified">!               gsize       count,</span>
<span class="line-modified">!               gsize      *bytes_read,</span>
<span class="line-modified">!               GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    gint result;
    GIOChannelError error;
    int winsock_error;
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_win32_sock_read: channel=%p sock=%d count=%&quot; G_GSIZE_FORMAT,
<span class="line-modified">!          channel, win32_channel-&gt;fd, count);</span>
  
    result = recv (win32_channel-&gt;fd, buf, count, 0);
    if (result == SOCKET_ERROR)
      winsock_error = WSAGetLastError ();
  
<span class="line-new-header">--- 1450,23 ---</span>
    return source;
  }
  
  static GIOStatus
  g_io_win32_sock_read (GIOChannel *channel,
<span class="line-modified">!           gchar      *buf,</span>
<span class="line-modified">!           gsize       count,</span>
<span class="line-modified">!           gsize      *bytes_read,</span>
<span class="line-modified">!           GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    gint result;
    GIOChannelError error;
    int winsock_error;
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_win32_sock_read: channel=%p sock=%d count=%&quot; G_GSIZE_FORMAT,
<span class="line-modified">!        channel, win32_channel-&gt;fd, count);</span>
  
    result = recv (win32_channel-&gt;fd, buf, count, 0);
    if (result == SOCKET_ERROR)
      winsock_error = WSAGetLastError ();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1476,58 ***</span>
    if (result == SOCKET_ERROR)
      {
        gchar *emsg = g_win32_error_message (winsock_error);
  
        if (win32_channel-&gt;debug)
<span class="line-modified">!     g_print (&quot; %s\n&quot;, emsg);</span>
  
        *bytes_read = 0;
  
        switch (winsock_error)
<span class="line-modified">!     {</span>
<span class="line-modified">!     case WSAEINVAL:</span>
            error = G_IO_CHANNEL_ERROR_INVAL;
            break;
<span class="line-modified">!     case WSAEWOULDBLOCK:</span>
<span class="line-modified">!       g_free (emsg);</span>
            return G_IO_STATUS_AGAIN;
<span class="line-modified">!     default:</span>
<span class="line-modified">!       error = G_IO_CHANNEL_ERROR_FAILED;</span>
            break;
<span class="line-modified">!     }</span>
        g_set_error_literal (err, G_IO_CHANNEL_ERROR, error, emsg);
        g_free (emsg);
  
        return G_IO_STATUS_ERROR;
      }
    else
      {
        if (win32_channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;\n&quot;);</span>
        *bytes_read = result;
        if (result == 0)
<span class="line-modified">!     return G_IO_STATUS_EOF;</span>
        else
<span class="line-modified">!     return G_IO_STATUS_NORMAL;</span>
      }
  }
  
  static GIOStatus
  g_io_win32_sock_write (GIOChannel  *channel,
<span class="line-modified">!                const gchar *buf,</span>
<span class="line-modified">!                gsize        count,</span>
<span class="line-modified">!                gsize       *bytes_written,</span>
<span class="line-modified">!                GError     **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    gint result;
    GIOChannelError error;
    int winsock_error;
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_win32_sock_write: channel=%p sock=%d count=%&quot; G_GSIZE_FORMAT,
<span class="line-modified">!          channel, win32_channel-&gt;fd, count);</span>
  
    result = send (win32_channel-&gt;fd, buf, count, 0);
    if (result == SOCKET_ERROR)
      winsock_error = WSAGetLastError ();
  
<span class="line-new-header">--- 1476,58 ---</span>
    if (result == SOCKET_ERROR)
      {
        gchar *emsg = g_win32_error_message (winsock_error);
  
        if (win32_channel-&gt;debug)
<span class="line-modified">!   g_print (&quot; %s\n&quot;, emsg);</span>
  
        *bytes_read = 0;
  
        switch (winsock_error)
<span class="line-modified">!   {</span>
<span class="line-modified">!   case WSAEINVAL:</span>
            error = G_IO_CHANNEL_ERROR_INVAL;
            break;
<span class="line-modified">!   case WSAEWOULDBLOCK:</span>
<span class="line-modified">!     g_free (emsg);</span>
            return G_IO_STATUS_AGAIN;
<span class="line-modified">!   default:</span>
<span class="line-modified">!     error = G_IO_CHANNEL_ERROR_FAILED;</span>
            break;
<span class="line-modified">!   }</span>
        g_set_error_literal (err, G_IO_CHANNEL_ERROR, error, emsg);
        g_free (emsg);
  
        return G_IO_STATUS_ERROR;
      }
    else
      {
        if (win32_channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;\n&quot;);</span>
        *bytes_read = result;
        if (result == 0)
<span class="line-modified">!   return G_IO_STATUS_EOF;</span>
        else
<span class="line-modified">!   return G_IO_STATUS_NORMAL;</span>
      }
  }
  
  static GIOStatus
  g_io_win32_sock_write (GIOChannel  *channel,
<span class="line-modified">!            const gchar *buf,</span>
<span class="line-modified">!            gsize        count,</span>
<span class="line-modified">!            gsize       *bytes_written,</span>
<span class="line-modified">!            GError     **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    gint result;
    GIOChannelError error;
    int winsock_error;
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_win32_sock_write: channel=%p sock=%d count=%&quot; G_GSIZE_FORMAT,
<span class="line-modified">!        channel, win32_channel-&gt;fd, count);</span>
  
    result = send (win32_channel-&gt;fd, buf, count, 0);
    if (result == SOCKET_ERROR)
      winsock_error = WSAGetLastError ();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1537,55 ***</span>
    if (result == SOCKET_ERROR)
      {
        gchar *emsg = g_win32_error_message (winsock_error);
  
        if (win32_channel-&gt;debug)
<span class="line-modified">!     g_print (&quot; %s\n&quot;, emsg);</span>
  
        *bytes_written = 0;
  
        switch (winsock_error)
<span class="line-modified">!     {</span>
<span class="line-modified">!     case WSAEINVAL:</span>
<span class="line-modified">!       error = G_IO_CHANNEL_ERROR_INVAL;</span>
            break;
<span class="line-modified">!     case WSAEWOULDBLOCK:</span>
<span class="line-modified">!       win32_channel-&gt;write_would_have_blocked = TRUE;</span>
<span class="line-modified">!       win32_channel-&gt;last_events = 0;</span>
<span class="line-modified">!       g_free (emsg);</span>
            return G_IO_STATUS_AGAIN;
<span class="line-modified">!     default:</span>
<span class="line-modified">!       error = G_IO_CHANNEL_ERROR_FAILED;</span>
            break;
<span class="line-modified">!     }</span>
        g_set_error_literal (err, G_IO_CHANNEL_ERROR, error, emsg);
        g_free (emsg);
  
        return G_IO_STATUS_ERROR;
      }
    else
      {
        if (win32_channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;\n&quot;);</span>
        *bytes_written = result;
        win32_channel-&gt;write_would_have_blocked = FALSE;
  
        return G_IO_STATUS_NORMAL;
      }
  }
  
  static GIOStatus
  g_io_win32_sock_close (GIOChannel *channel,
<span class="line-modified">!                GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
  
    if (win32_channel-&gt;fd != -1)
      {
        if (win32_channel-&gt;debug)
<span class="line-modified">!     g_print (&quot;g_io_win32_sock_close: channel=%p sock=%d\n&quot;,</span>
<span class="line-modified">!          channel, win32_channel-&gt;fd);</span>
  
        closesocket (win32_channel-&gt;fd);
        win32_channel-&gt;fd = -1;
      }
  
<span class="line-new-header">--- 1537,55 ---</span>
    if (result == SOCKET_ERROR)
      {
        gchar *emsg = g_win32_error_message (winsock_error);
  
        if (win32_channel-&gt;debug)
<span class="line-modified">!   g_print (&quot; %s\n&quot;, emsg);</span>
  
        *bytes_written = 0;
  
        switch (winsock_error)
<span class="line-modified">!   {</span>
<span class="line-modified">!   case WSAEINVAL:</span>
<span class="line-modified">!     error = G_IO_CHANNEL_ERROR_INVAL;</span>
            break;
<span class="line-modified">!   case WSAEWOULDBLOCK:</span>
<span class="line-modified">!     win32_channel-&gt;write_would_have_blocked = TRUE;</span>
<span class="line-modified">!     win32_channel-&gt;last_events = 0;</span>
<span class="line-modified">!     g_free (emsg);</span>
            return G_IO_STATUS_AGAIN;
<span class="line-modified">!   default:</span>
<span class="line-modified">!     error = G_IO_CHANNEL_ERROR_FAILED;</span>
            break;
<span class="line-modified">!   }</span>
        g_set_error_literal (err, G_IO_CHANNEL_ERROR, error, emsg);
        g_free (emsg);
  
        return G_IO_STATUS_ERROR;
      }
    else
      {
        if (win32_channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;\n&quot;);</span>
        *bytes_written = result;
        win32_channel-&gt;write_would_have_blocked = FALSE;
  
        return G_IO_STATUS_NORMAL;
      }
  }
  
  static GIOStatus
  g_io_win32_sock_close (GIOChannel *channel,
<span class="line-modified">!            GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
  
    if (win32_channel-&gt;fd != -1)
      {
        if (win32_channel-&gt;debug)
<span class="line-modified">!   g_print (&quot;g_io_win32_sock_close: channel=%p sock=%d\n&quot;,</span>
<span class="line-modified">!      channel, win32_channel-&gt;fd);</span>
  
        closesocket (win32_channel-&gt;fd);
        win32_channel-&gt;fd = -1;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1594,11 ***</span>
    return G_IO_STATUS_NORMAL;
  }
  
  static GSource *
  g_io_win32_sock_create_watch (GIOChannel    *channel,
<span class="line-modified">!                   GIOCondition   condition)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    GSource *source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
    GIOWin32Watch *watch = (GIOWin32Watch *)source;
  
<span class="line-new-header">--- 1594,11 ---</span>
    return G_IO_STATUS_NORMAL;
  }
  
  static GSource *
  g_io_win32_sock_create_watch (GIOChannel    *channel,
<span class="line-modified">!             GIOCondition   condition)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    GSource *source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
    GIOWin32Watch *watch = (GIOWin32Watch *)source;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1613,12 ***</span>
    watch-&gt;pollfd.fd = (gintptr) win32_channel-&gt;event;
    watch-&gt;pollfd.events = condition;
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_win32_sock_create_watch: channel=%p sock=%d event=%p condition={%s}\n&quot;,
<span class="line-modified">!          channel, win32_channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd,</span>
<span class="line-modified">!          condition_to_string (watch-&gt;condition));</span>
  
    g_source_add_poll (source, &amp;watch-&gt;pollfd);
  
    return source;
  }
<span class="line-new-header">--- 1613,12 ---</span>
    watch-&gt;pollfd.fd = (gintptr) win32_channel-&gt;event;
    watch-&gt;pollfd.events = condition;
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_win32_sock_create_watch: channel=%p sock=%d event=%p condition={%s}\n&quot;,
<span class="line-modified">!        channel, win32_channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd,</span>
<span class="line-modified">!        condition_to_string (watch-&gt;condition));</span>
  
    g_source_add_poll (source, &amp;watch-&gt;pollfd);
  
    return source;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1761,12 ***</span>
    return channel;
  }
  
  static GIOStatus
  g_io_win32_unimpl_set_flags (GIOChannel *channel,
<span class="line-modified">!                  GIOFlags    flags,</span>
<span class="line-modified">!                  GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
  
    if (win32_channel-&gt;debug)
      {
<span class="line-new-header">--- 1761,12 ---</span>
    return channel;
  }
  
  static GIOStatus
  g_io_win32_unimpl_set_flags (GIOChannel *channel,
<span class="line-modified">!            GIOFlags    flags,</span>
<span class="line-modified">!            GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
  
    if (win32_channel-&gt;debug)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1782,30 ***</span>
    return G_IO_STATUS_ERROR;
  }
  
  static GIOFlags
  g_io_win32_fd_get_flags_internal (GIOChannel      *channel,
<span class="line-modified">!                   struct _stati64 *st)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *) channel;
    gchar c;
    DWORD count;
  
    if (st-&gt;st_mode &amp; _S_IFIFO)
      {
        channel-&gt;is_readable =
<span class="line-modified">!     (PeekNamedPipe ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL, NULL) != 0) || GetLastError () == ERROR_BROKEN_PIPE;</span>
        channel-&gt;is_writeable =
<span class="line-modified">!     (WriteFile ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL) != 0);</span>
        channel-&gt;is_seekable  = FALSE;
      }
    else
      {
        channel-&gt;is_readable =
<span class="line-modified">!     (ReadFile ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL) != 0);</span>
        channel-&gt;is_writeable =
<span class="line-modified">!     (WriteFile ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL) != 0);</span>
        channel-&gt;is_seekable = TRUE;
      }
  
    /* XXX: G_IO_FLAG_APPEND */
    /* XXX: G_IO_FLAG_NONBLOCK */
<span class="line-new-header">--- 1782,30 ---</span>
    return G_IO_STATUS_ERROR;
  }
  
  static GIOFlags
  g_io_win32_fd_get_flags_internal (GIOChannel      *channel,
<span class="line-modified">!           struct _stati64 *st)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *) channel;
    gchar c;
    DWORD count;
  
    if (st-&gt;st_mode &amp; _S_IFIFO)
      {
        channel-&gt;is_readable =
<span class="line-modified">!   (PeekNamedPipe ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL, NULL) != 0) || GetLastError () == ERROR_BROKEN_PIPE;</span>
        channel-&gt;is_writeable =
<span class="line-modified">!   (WriteFile ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL) != 0);</span>
        channel-&gt;is_seekable  = FALSE;
      }
    else
      {
        channel-&gt;is_readable =
<span class="line-modified">!   (ReadFile ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL) != 0);</span>
        channel-&gt;is_writeable =
<span class="line-modified">!   (WriteFile ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL) != 0);</span>
        channel-&gt;is_seekable = TRUE;
      }
  
    /* XXX: G_IO_FLAG_APPEND */
    /* XXX: G_IO_FLAG_NONBLOCK */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1861,12 ***</span>
    return 0;
  }
  
  static GIOStatus
  g_io_win32_sock_set_flags (GIOChannel *channel,
<span class="line-modified">!                GIOFlags    flags,</span>
<span class="line-modified">!                GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    u_long arg;
  
    if (win32_channel-&gt;debug)
<span class="line-new-header">--- 1861,12 ---</span>
    return 0;
  }
  
  static GIOStatus
  g_io_win32_sock_set_flags (GIOChannel *channel,
<span class="line-modified">!          GIOFlags    flags,</span>
<span class="line-modified">!          GError    **err)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
    u_long arg;
  
    if (win32_channel-&gt;debug)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1878,35 ***</span>
  
    if (flags &amp; G_IO_FLAG_NONBLOCK)
      {
        arg = 1;
        if (ioctlsocket (win32_channel-&gt;fd, FIONBIO, &amp;arg) == SOCKET_ERROR)
<span class="line-modified">!     {</span>
<span class="line-modified">!       gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
  
<span class="line-modified">!       g_set_error_literal (err, G_IO_CHANNEL_ERROR,</span>
<span class="line-modified">!                    G_IO_CHANNEL_ERROR_FAILED,</span>
<span class="line-modified">!                    emsg);</span>
<span class="line-modified">!       g_free (emsg);</span>
  
<span class="line-modified">!       return G_IO_STATUS_ERROR;</span>
<span class="line-modified">!     }</span>
      }
    else
      {
        arg = 0;
        if (ioctlsocket (win32_channel-&gt;fd, FIONBIO, &amp;arg) == SOCKET_ERROR)
<span class="line-modified">!     {</span>
<span class="line-modified">!       gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
  
<span class="line-modified">!       g_set_error_literal (err, G_IO_CHANNEL_ERROR,</span>
<span class="line-modified">!                    G_IO_CHANNEL_ERROR_FAILED,</span>
<span class="line-modified">!                    emsg);</span>
<span class="line-modified">!       g_free (emsg);</span>
  
<span class="line-modified">!       return G_IO_STATUS_ERROR;</span>
<span class="line-modified">!     }</span>
      }
  
    return G_IO_STATUS_NORMAL;
  }
  
<span class="line-new-header">--- 1878,35 ---</span>
  
    if (flags &amp; G_IO_FLAG_NONBLOCK)
      {
        arg = 1;
        if (ioctlsocket (win32_channel-&gt;fd, FIONBIO, &amp;arg) == SOCKET_ERROR)
<span class="line-modified">!   {</span>
<span class="line-modified">!     gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
  
<span class="line-modified">!     g_set_error_literal (err, G_IO_CHANNEL_ERROR,</span>
<span class="line-modified">!              G_IO_CHANNEL_ERROR_FAILED,</span>
<span class="line-modified">!              emsg);</span>
<span class="line-modified">!     g_free (emsg);</span>
  
<span class="line-modified">!     return G_IO_STATUS_ERROR;</span>
<span class="line-modified">!   }</span>
      }
    else
      {
        arg = 0;
        if (ioctlsocket (win32_channel-&gt;fd, FIONBIO, &amp;arg) == SOCKET_ERROR)
<span class="line-modified">!   {</span>
<span class="line-modified">!     gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
  
<span class="line-modified">!     g_set_error_literal (err, G_IO_CHANNEL_ERROR,</span>
<span class="line-modified">!              G_IO_CHANNEL_ERROR_FAILED,</span>
<span class="line-modified">!              emsg);</span>
<span class="line-modified">!     g_free (emsg);</span>
  
<span class="line-modified">!     return G_IO_STATUS_ERROR;</span>
<span class="line-modified">!   }</span>
      }
  
    return G_IO_STATUS_NORMAL;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1984,11 ***</span>
  
    g_io_channel_init (channel);
    g_io_channel_win32_init (win32_channel);
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_channel_win32_new_messages: channel=%p hwnd=%p\n&quot;,
<span class="line-modified">!          channel, (HWND) hwnd);</span>
    channel-&gt;funcs = &amp;win32_channel_msg_funcs;
    win32_channel-&gt;type = G_IO_WIN32_WINDOWS_MESSAGES;
    win32_channel-&gt;hwnd = (HWND) hwnd;
  
    /* XXX: check this. */
<span class="line-new-header">--- 1984,11 ---</span>
  
    g_io_channel_init (channel);
    g_io_channel_win32_init (win32_channel);
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_channel_win32_new_messages: channel=%p hwnd=%p\n&quot;,
<span class="line-modified">!        channel, (HWND) hwnd);</span>
    channel-&gt;funcs = &amp;win32_channel_msg_funcs;
    win32_channel-&gt;type = G_IO_WIN32_WINDOWS_MESSAGES;
    win32_channel-&gt;hwnd = (HWND) hwnd;
  
    /* XXX: check this. */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2000,11 ***</span>
    return channel;
  }
  
  static GIOChannel *
  g_io_channel_win32_new_fd_internal (gint             fd,
<span class="line-modified">!                     struct _stati64 *st)</span>
  {
    GIOWin32Channel *win32_channel;
    GIOChannel *channel;
  
    win32_channel = g_new (GIOWin32Channel, 1);
<span class="line-new-header">--- 2000,11 ---</span>
    return channel;
  }
  
  static GIOChannel *
  g_io_channel_win32_new_fd_internal (gint             fd,
<span class="line-modified">!             struct _stati64 *st)</span>
  {
    GIOWin32Channel *win32_channel;
    GIOChannel *channel;
  
    win32_channel = g_new (GIOWin32Channel, 1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2015,11 ***</span>
  
    win32_channel-&gt;fd = fd;
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_channel_win32_new_fd: channel=%p fd=%u\n&quot;,
<span class="line-modified">!          channel, fd);</span>
  
    if (st-&gt;st_mode &amp; _S_IFCHR) /* console */
      {
        channel-&gt;funcs = &amp;win32_channel_console_funcs;
        win32_channel-&gt;type = G_IO_WIN32_CONSOLE;
<span class="line-new-header">--- 2015,11 ---</span>
  
    win32_channel-&gt;fd = fd;
  
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_channel_win32_new_fd: channel=%p fd=%u\n&quot;,
<span class="line-modified">!        channel, fd);</span>
  
    if (st-&gt;st_mode &amp; _S_IFCHR) /* console */
      {
        channel-&gt;funcs = &amp;win32_channel_console_funcs;
        win32_channel-&gt;type = G_IO_WIN32_CONSOLE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2109,11 ***</span>
  
    g_io_channel_init (channel);
    g_io_channel_win32_init (win32_channel);
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_channel_win32_new_socket: channel=%p sock=%d\n&quot;,
<span class="line-modified">!          channel, socket);</span>
    channel-&gt;funcs = &amp;win32_channel_sock_funcs;
    win32_channel-&gt;type = G_IO_WIN32_SOCKET;
    win32_channel-&gt;fd = socket;
  
    channel-&gt;is_readable = TRUE;
<span class="line-new-header">--- 2109,11 ---</span>
  
    g_io_channel_init (channel);
    g_io_channel_win32_init (win32_channel);
    if (win32_channel-&gt;debug)
      g_print (&quot;g_io_channel_win32_new_socket: channel=%p sock=%d\n&quot;,
<span class="line-modified">!        channel, socket);</span>
    channel-&gt;funcs = &amp;win32_channel_sock_funcs;
    win32_channel-&gt;type = G_IO_WIN32_SOCKET;
    win32_channel-&gt;fd = socket;
  
    channel-&gt;is_readable = TRUE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2155,55 ***</span>
    return g_io_channel_win32_get_fd (channel);
  }
  
  void
  g_io_channel_win32_set_debug (GIOChannel *channel,
<span class="line-modified">!                   gboolean    flag)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
  
    win32_channel-&gt;debug = flag;
  }
  
  gint
  g_io_channel_win32_poll (GPollFD *fds,
<span class="line-modified">!              gint     n_fds,</span>
<span class="line-modified">!              gint     timeout)</span>
  {
    g_return_val_if_fail (n_fds &gt;= 0, 0);
  
    return g_poll (fds, n_fds, timeout);
  }
  
  void
  g_io_channel_win32_make_pollfd (GIOChannel   *channel,
<span class="line-modified">!                 GIOCondition  condition,</span>
<span class="line-modified">!                 GPollFD      *fd)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
  
    switch (win32_channel-&gt;type)
      {
      case G_IO_WIN32_FILE_DESC:
        if (win32_channel-&gt;data_avail_event == NULL)
<span class="line-modified">!     create_events (win32_channel);</span>
  
        fd-&gt;fd = (gintptr) win32_channel-&gt;data_avail_event;
  
        if (win32_channel-&gt;thread_id == 0)
<span class="line-modified">!     {</span>
<span class="line-modified">!       /* Is it meaningful for a file descriptor to be polled for</span>
<span class="line-modified">!        * both IN and OUT? For what kind of file descriptor would</span>
<span class="line-modified">!        * that be? Doesn&#39;t seem to make sense, in practise the file</span>
<span class="line-modified">!        * descriptors handled here are always read or write ends of</span>
<span class="line-modified">!        * pipes surely, and thus unidirectional.</span>
<span class="line-modified">!        */</span>
<span class="line-modified">!       if (condition &amp; G_IO_IN)</span>
<span class="line-modified">!         create_thread (win32_channel, condition, read_thread);</span>
<span class="line-modified">!       else if (condition &amp; G_IO_OUT)</span>
<span class="line-modified">!         create_thread (win32_channel, condition, write_thread);</span>
<span class="line-modified">!     }</span>
        break;
  
      case G_IO_WIN32_CONSOLE:
        fd-&gt;fd = _get_osfhandle (win32_channel-&gt;fd);
        break;
<span class="line-new-header">--- 2155,55 ---</span>
    return g_io_channel_win32_get_fd (channel);
  }
  
  void
  g_io_channel_win32_set_debug (GIOChannel *channel,
<span class="line-modified">!             gboolean    flag)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
  
    win32_channel-&gt;debug = flag;
  }
  
  gint
  g_io_channel_win32_poll (GPollFD *fds,
<span class="line-modified">!        gint     n_fds,</span>
<span class="line-modified">!        gint     timeout)</span>
  {
    g_return_val_if_fail (n_fds &gt;= 0, 0);
  
    return g_poll (fds, n_fds, timeout);
  }
  
  void
  g_io_channel_win32_make_pollfd (GIOChannel   *channel,
<span class="line-modified">!         GIOCondition  condition,</span>
<span class="line-modified">!         GPollFD      *fd)</span>
  {
    GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
  
    switch (win32_channel-&gt;type)
      {
      case G_IO_WIN32_FILE_DESC:
        if (win32_channel-&gt;data_avail_event == NULL)
<span class="line-modified">!   create_events (win32_channel);</span>
  
        fd-&gt;fd = (gintptr) win32_channel-&gt;data_avail_event;
  
        if (win32_channel-&gt;thread_id == 0)
<span class="line-modified">!   {</span>
<span class="line-modified">!     /* Is it meaningful for a file descriptor to be polled for</span>
<span class="line-modified">!      * both IN and OUT? For what kind of file descriptor would</span>
<span class="line-modified">!      * that be? Doesn&#39;t seem to make sense, in practise the file</span>
<span class="line-modified">!      * descriptors handled here are always read or write ends of</span>
<span class="line-modified">!      * pipes surely, and thus unidirectional.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     if (condition &amp; G_IO_IN)</span>
<span class="line-modified">!       create_thread (win32_channel, condition, read_thread);</span>
<span class="line-modified">!     else if (condition &amp; G_IO_OUT)</span>
<span class="line-modified">!       create_thread (win32_channel, condition, write_thread);</span>
<span class="line-modified">!   }</span>
        break;
  
      case G_IO_WIN32_CONSOLE:
        fd-&gt;fd = _get_osfhandle (win32_channel-&gt;fd);
        break;
</pre>
<center><a href="giounix.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gkeyfile.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>