<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstpad.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstobject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstpad.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstpad.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 101 
 102 GST_DEBUG_CATEGORY_STATIC (debug_dataflow);
 103 #define GST_CAT_DEFAULT GST_CAT_PADS
 104 
 105 /* Pad signals and args */
 106 enum
 107 {
 108   PAD_LINKED,
 109   PAD_UNLINKED,
 110   /* FILL ME */
 111   LAST_SIGNAL
 112 };
 113 
 114 enum
 115 {
 116   PAD_PROP_0,
 117   PAD_PROP_CAPS,
 118   PAD_PROP_DIRECTION,
 119   PAD_PROP_TEMPLATE,
 120   PAD_PROP_OFFSET
<span class="line-modified"> 121   /* FILL ME */</span>
 122 };
 123 
<span class="line-removed"> 124 #define GST_PAD_GET_PRIVATE(obj)  \</span>
<span class="line-removed"> 125    (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_PAD, GstPadPrivate))</span>
<span class="line-removed"> 126 </span>
 127 #define _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH (GST_PAD_PROBE_TYPE_ALL_BOTH | GST_PAD_PROBE_TYPE_EVENT_FLUSH)
 128 
 129 /* we have a pending and an active event on the pad. On source pads only the
 130  * active event is used. On sinkpads, events are copied to the pending entry and
 131  * moved to the active event when the eventfunc returned %TRUE. */
 132 typedef struct
 133 {
 134   gboolean received;
 135   GstEvent *event;
 136 } PadEvent;
 137 
 138 struct _GstPadPrivate
 139 {
 140   guint events_cookie;
 141   GArray *events;
 142   guint last_cookie;
 143 
 144   gint using;
 145   guint probe_list_cookie;
 146 
</pre>
<hr />
<pre>
 155   gboolean in_activation;
 156 };
 157 
 158 typedef struct
 159 {
 160   GHook hook;
 161 } GstProbe;
 162 
 163 #define GST_PAD_IS_RUNNING_IDLE_PROBE(p) \
 164     (((GstPad *)(p))-&gt;priv-&gt;idle_running &gt; 0)
 165 
 166 typedef struct
 167 {
 168   GstPad *pad;
 169   GstPadProbeInfo *info;
 170   gboolean dropped;
 171   gboolean pass;
 172   gboolean handled;
 173   gboolean marshalled;
 174 
<span class="line-modified"> 175   GHook **called_probes;</span>
 176   guint n_called_probes;
 177   guint called_probes_size;
 178   gboolean retry;
 179 } ProbeMarshall;
 180 
 181 static void gst_pad_dispose (GObject * object);
 182 static void gst_pad_finalize (GObject * object);
 183 static void gst_pad_set_property (GObject * object, guint prop_id,
 184     const GValue * value, GParamSpec * pspec);
 185 static void gst_pad_get_property (GObject * object, guint prop_id,
 186     GValue * value, GParamSpec * pspec);
 187 
 188 static void gst_pad_set_pad_template (GstPad * pad, GstPadTemplate * templ);
 189 static gboolean gst_pad_activate_default (GstPad * pad, GstObject * parent);
 190 static GstFlowReturn gst_pad_chain_list_default (GstPad * pad,
 191     GstObject * parent, GstBufferList * list);
 192 
 193 static GstFlowReturn gst_pad_send_event_unchecked (GstPad * pad,
 194     GstEvent * event, GstPadProbeType type);
 195 static GstFlowReturn gst_pad_push_event_unchecked (GstPad * pad,
</pre>
<hr />
<pre>
 294     case GST_PAD_LINK_WRONG_DIRECTION:
 295       return &quot;wrong direction&quot;;
 296     case GST_PAD_LINK_NOFORMAT:
 297       return &quot;no common format&quot;;
 298     case GST_PAD_LINK_NOSCHED:
 299       return &quot;incompatible scheduling&quot;;
 300     case GST_PAD_LINK_REFUSED:
 301       return &quot;refused&quot;;
 302   }
 303   g_return_val_if_reached (&quot;unknown&quot;);
 304 }
 305 
 306 #define _do_init \
 307 { \
 308   gint i; \
 309   \
 310   buffer_quark = g_quark_from_static_string (&quot;buffer&quot;); \
 311   buffer_list_quark = g_quark_from_static_string (&quot;bufferlist&quot;); \
 312   event_quark = g_quark_from_static_string (&quot;event&quot;); \
 313   \
<span class="line-modified"> 314   for (i = 0; i &lt; G_N_ELEMENTS (flow_quarks); i++) {            \</span>
 315     flow_quarks[i].quark = g_quark_from_static_string (flow_quarks[i].name); \
 316   } \
 317   \
 318   GST_DEBUG_CATEGORY_INIT (debug_dataflow, &quot;GST_DATAFLOW&quot;, \
 319       GST_DEBUG_BOLD | GST_DEBUG_FG_GREEN, &quot;dataflow inside pads&quot;); \
 320 }
 321 
 322 #define gst_pad_parent_class parent_class
<span class="line-modified"> 323 G_DEFINE_TYPE_WITH_CODE (GstPad, gst_pad, GST_TYPE_OBJECT, _do_init);</span>

 324 
 325 static void
 326 gst_pad_class_init (GstPadClass * klass)
 327 {
 328   GObjectClass *gobject_class;
 329   GstObjectClass *gstobject_class;
 330 
 331   gobject_class = G_OBJECT_CLASS (klass);
 332   gstobject_class = GST_OBJECT_CLASS (klass);
 333 
<span class="line-removed"> 334   g_type_class_add_private (klass, sizeof (GstPadPrivate));</span>
<span class="line-removed"> 335 </span>
 336   gobject_class-&gt;dispose = gst_pad_dispose;
 337   gobject_class-&gt;finalize = gst_pad_finalize;
 338   gobject_class-&gt;set_property = gst_pad_set_property;
 339   gobject_class-&gt;get_property = gst_pad_get_property;
 340 
 341   /**
 342    * GstPad::linked:
 343    * @pad: the pad that emitted the signal
 344    * @peer: the peer pad that has been connected
 345    *
 346    * Signals that a pad has been linked to the peer pad.
 347    */
 348   gst_pad_signals[PAD_LINKED] =
 349       g_signal_new (&quot;linked&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 350       G_STRUCT_OFFSET (GstPadClass, linked), NULL, NULL,
 351       g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_PAD);
 352   /**
 353    * GstPad::unlinked:
 354    * @pad: the pad that emitted the signal
 355    * @peer: the peer pad that has been disconnected
</pre>
<hr />
<pre>
 385    * Since: 1.6
 386    */
 387   g_object_class_install_property (gobject_class, PAD_PROP_OFFSET,
 388       g_param_spec_int64 (&quot;offset&quot;, &quot;Offset&quot;,
 389           &quot;The running time offset of the pad&quot;, 0, G_MAXINT64, 0,
 390           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 391 
 392   gstobject_class-&gt;path_string_separator = &quot;.&quot;;
 393 
 394   /* Register common function pointer descriptions */
 395   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_activate_default);
 396   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_event_default);
 397   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_query_default);
 398   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_iterate_internal_links_default);
 399   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_chain_list_default);
 400 }
 401 
 402 static void
 403 gst_pad_init (GstPad * pad)
 404 {
<span class="line-modified"> 405   pad-&gt;priv = GST_PAD_GET_PRIVATE (pad);</span>
 406 
 407   GST_PAD_DIRECTION (pad) = GST_PAD_UNKNOWN;
 408 
 409   GST_PAD_ACTIVATEFUNC (pad) = gst_pad_activate_default;
 410   GST_PAD_EVENTFUNC (pad) = gst_pad_event_default;
 411   GST_PAD_QUERYFUNC (pad) = gst_pad_query_default;
 412   GST_PAD_ITERINTLINKFUNC (pad) = gst_pad_iterate_internal_links_default;
 413   GST_PAD_CHAINLISTFUNC (pad) = gst_pad_chain_list_default;
 414 
 415   GST_PAD_SET_FLUSHING (pad);
 416 
 417   g_rec_mutex_init (&amp;pad-&gt;stream_rec_lock);
 418 
 419   g_cond_init (&amp;pad-&gt;block_cond);
 420 
 421   g_hook_list_init (&amp;pad-&gt;probes, sizeof (GstProbe));
 422 
 423   pad-&gt;priv-&gt;events = g_array_sized_new (FALSE, TRUE, sizeof (PadEvent), 16);
 424   pad-&gt;priv-&gt;events_cookie = 0;
 425   pad-&gt;priv-&gt;last_cookie = -1;
</pre>
<hr />
<pre>
 588 events_foreach (GstPad * pad, PadEventFunction func, gpointer user_data)
 589 {
 590   guint i, len;
 591   GArray *events;
 592   gboolean ret;
 593   guint cookie;
 594 
 595   events = pad-&gt;priv-&gt;events;
 596 
 597 restart:
 598   cookie = pad-&gt;priv-&gt;events_cookie;
 599   i = 0;
 600   len = events-&gt;len;
 601   while (i &lt; len) {
 602     PadEvent *ev, ev_ret;
 603 
 604     ev = &amp;g_array_index (events, PadEvent, i);
 605     if (G_UNLIKELY (ev-&gt;event == NULL))
 606       goto next;
 607 
<span class="line-modified"> 608     /* take aditional ref, func might release the lock */</span>
 609     ev_ret.event = gst_event_ref (ev-&gt;event);
 610     ev_ret.received = ev-&gt;received;
 611 
 612     ret = func (pad, &amp;ev_ret, user_data);
 613 
 614     /* recheck the cookie, lock might have been released and the list could have
 615      * changed */
 616     if (G_UNLIKELY (cookie != pad-&gt;priv-&gt;events_cookie)) {
 617       if (G_LIKELY (ev_ret.event))
 618         gst_event_unref (ev_ret.event);
 619       goto restart;
 620     }
 621 
 622     /* store the received state */
 623     ev-&gt;received = ev_ret.received;
 624 
 625     /* if the event changed, we need to do something */
 626     if (G_UNLIKELY (ev-&gt;event != ev_ret.event)) {
 627       if (G_UNLIKELY (ev_ret.event == NULL)) {
 628         /* function unreffed and set the event to NULL, remove it */
</pre>
<hr />
<pre>
 634       } else {
 635         /* function gave a new event for us */
 636         gst_event_take (&amp;ev-&gt;event, ev_ret.event);
 637       }
 638     } else {
 639       /* just unref, nothing changed */
 640       gst_event_unref (ev_ret.event);
 641     }
 642     if (!ret)
 643       break;
 644   next:
 645     i++;
 646   }
 647 }
 648 
 649 /* should be called with LOCK */
 650 static GstEvent *
 651 _apply_pad_offset (GstPad * pad, GstEvent * event, gboolean upstream,
 652     gint64 pad_offset)
 653 {
<span class="line-modified"> 654     gint64 offset;</span>
 655 
 656   GST_DEBUG_OBJECT (pad, &quot;apply pad offset %&quot; GST_STIME_FORMAT,
 657       GST_STIME_ARGS (pad_offset));
 658 
<span class="line-modified"> 659     if (GST_EVENT_TYPE (event) == GST_EVENT_SEGMENT) {</span>
<span class="line-modified"> 660       GstSegment segment;</span>
 661 
<span class="line-modified"> 662       g_assert (!upstream);</span>
 663 
<span class="line-modified"> 664       /* copy segment values */</span>
<span class="line-modified"> 665       gst_event_copy_segment (event, &amp;segment);</span>
<span class="line-modified"> 666       gst_event_unref (event);</span>
 667 
 668     gst_segment_offset_running_time (&amp;segment, segment.format, pad_offset);
<span class="line-modified"> 669       event = gst_event_new_segment (&amp;segment);</span>
<span class="line-modified"> 670     }</span>
 671 
<span class="line-modified"> 672     event = gst_event_make_writable (event);</span>
<span class="line-modified"> 673     offset = gst_event_get_running_time_offset (event);</span>
<span class="line-modified"> 674     if (upstream)</span>
 675     offset -= pad_offset;
<span class="line-modified"> 676     else</span>
 677     offset += pad_offset;
<span class="line-modified"> 678     gst_event_set_running_time_offset (event, offset);</span>
 679 
 680   return event;
<span class="line-modified"> 681   }</span>
 682 
 683 static inline GstEvent *
 684 apply_pad_offset (GstPad * pad, GstEvent * event, gboolean upstream)
 685 {
 686   if (G_UNLIKELY (pad-&gt;offset != 0))
 687     return _apply_pad_offset (pad, event, upstream, pad-&gt;offset);
 688   return event;
 689 }
 690 
 691 /* should be called with the OBJECT_LOCK */
 692 static GstCaps *
 693 get_pad_caps (GstPad * pad)
 694 {
 695   GstCaps *caps = NULL;
 696   PadEvent *ev;
 697 
 698   ev = find_event_by_type (pad, GST_EVENT_CAPS, 0);
 699   if (ev &amp;&amp; ev-&gt;event)
 700     gst_event_parse_caps (ev-&gt;event, &amp;caps);
 701 
</pre>
<hr />
<pre>
 819       break;
 820     case PAD_PROP_OFFSET:
 821       g_value_set_int64 (value, gst_pad_get_offset (GST_PAD_CAST (object)));
 822       break;
 823     default:
 824       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 825       break;
 826   }
 827 }
 828 
 829 /**
 830  * gst_pad_new:
 831  * @name: (allow-none): the name of the new pad.
 832  * @direction: the #GstPadDirection of the pad.
 833  *
 834  * Creates a new pad with the given name in the given direction.
 835  * If name is %NULL, a guaranteed unique name (across all pads)
 836  * will be assigned.
 837  * This function makes a copy of the name so you can safely free the name.
 838  *
<span class="line-modified"> 839  * Returns: (transfer floating) (nullable): a new #GstPad, or %NULL in</span>
<span class="line-removed"> 840  * case of an error.</span>
 841  *
 842  * MT safe.
 843  */
 844 GstPad *
 845 gst_pad_new (const gchar * name, GstPadDirection direction)
 846 {
 847   return g_object_new (GST_TYPE_PAD,
 848       &quot;name&quot;, name, &quot;direction&quot;, direction, NULL);
 849 }
 850 
 851 /**
 852  * gst_pad_new_from_template:
 853  * @templ: the pad template to use
 854  * @name: (allow-none): the name of the pad
 855  *
 856  * Creates a new pad with the given name from the given template.
 857  * If name is %NULL, a guaranteed unique name (across all pads)
 858  * will be assigned.
 859  * This function makes a copy of the name so you can safely free the name.
 860  *
<span class="line-modified"> 861  * Returns: (transfer floating) (nullable): a new #GstPad, or %NULL in</span>
<span class="line-removed"> 862  * case of an error.</span>
 863  */
 864 GstPad *
 865 gst_pad_new_from_template (GstPadTemplate * templ, const gchar * name)
 866 {
 867   GType pad_type =
 868       GST_PAD_TEMPLATE_GTYPE (templ) ==
 869       G_TYPE_NONE ? GST_TYPE_PAD : GST_PAD_TEMPLATE_GTYPE (templ);
 870 
 871   g_return_val_if_fail (GST_IS_PAD_TEMPLATE (templ), NULL);
 872 
 873   return g_object_new (pad_type,
 874       &quot;name&quot;, name, &quot;direction&quot;, templ-&gt;direction, &quot;template&quot;, templ, NULL);
 875 }
 876 
 877 /**
 878  * gst_pad_new_from_static_template:
 879  * @templ: the #GstStaticPadTemplate to use
 880  * @name: the name of the pad
 881  *
 882  * Creates a new pad with the given name from the given static template.
 883  * If name is %NULL, a guaranteed unique name (across all pads)
 884  * will be assigned.
 885  * This function makes a copy of the name so you can safely free the name.
 886  *
<span class="line-modified"> 887  * Returns: (transfer floating) (nullable): a new #GstPad, or %NULL in</span>
<span class="line-removed"> 888  * case of an error.</span>
 889  */
 890 GstPad *
 891 gst_pad_new_from_static_template (GstStaticPadTemplate * templ,
 892     const gchar * name)
 893 {
 894   GstPad *pad;
 895   GstPadTemplate *template;
 896 
 897   template = gst_static_pad_template_get (templ);
 898   pad = gst_pad_new_from_template (template, name);
 899   gst_object_unref (template);
 900   return pad;
 901 }
 902 
 903 #define ACQUIRE_PARENT(pad, parent, label)                      \
 904   G_STMT_START {                                                \
 905     if (G_LIKELY ((parent = GST_OBJECT_PARENT (pad))))          \
 906       gst_object_ref (parent);                                  \
 907     else if (G_LIKELY (GST_PAD_NEEDS_PARENT (pad)))             \
 908       goto label;                                               \
</pre>
<hr />
<pre>
1203         }
1204       } else {
1205         if (G_UNLIKELY (GST_PAD_GETRANGEFUNC (pad) == NULL))
1206           goto failure;         /* Can&#39;t activate pull on a src without a
1207                                    getrange function */
1208       }
1209       break;
1210     }
1211     default:
1212       break;
1213   }
1214 
1215   /* Mark pad as needing reconfiguration */
1216   if (active)
1217     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
1218 
1219   /* pre_activate returns TRUE if we weren&#39;t already in the process of
1220    * switching to the &#39;new&#39; mode */
1221   if (pre_activate (pad, new)) {
1222 
<span class="line-modified">1223   if (GST_PAD_ACTIVATEMODEFUNC (pad)) {</span>
<span class="line-modified">1224     if (G_UNLIKELY (!GST_PAD_ACTIVATEMODEFUNC (pad) (pad, parent, mode,</span>
<span class="line-modified">1225                 active)))</span>
<span class="line-modified">1226       goto failure;</span>
<span class="line-modified">1227   } else {</span>
<span class="line-modified">1228     /* can happen for sinks of passthrough elements */</span>
<span class="line-modified">1229   }</span>
1230 
<span class="line-modified">1231   post_activate (pad, new);</span>
1232   }
1233 
1234   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;%s in %s mode&quot;,
1235       active ? &quot;activated&quot; : &quot;deactivated&quot;, gst_pad_mode_get_name (mode));
1236 
1237 exit_success:
1238   res = TRUE;
1239 
1240   /* Clear sticky flags on deactivation */
1241   if (!active) {
1242     GST_OBJECT_LOCK (pad);
1243     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
1244     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_EOS);
1245     GST_OBJECT_UNLOCK (pad);
1246   }
1247 
1248 exit:
1249   return res;
1250 
1251 was_ok:
</pre>
<hr />
<pre>
1359  */
1360 gboolean
1361 gst_pad_is_active (GstPad * pad)
1362 {
1363   gboolean result = FALSE;
1364 
1365   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
1366 
1367   GST_OBJECT_LOCK (pad);
1368   result = GST_PAD_IS_ACTIVE (pad);
1369   GST_OBJECT_UNLOCK (pad);
1370 
1371   return result;
1372 }
1373 
1374 static void
1375 cleanup_hook (GstPad * pad, GHook * hook)
1376 {
1377   GstPadProbeType type;
1378 



1379   if (!G_HOOK_IS_VALID (hook))
1380     return;
1381 
1382   type = (hook-&gt;flags) &gt;&gt; G_HOOK_FLAG_USER_SHIFT;
1383 
1384   if (type &amp; GST_PAD_PROBE_TYPE_BLOCKING) {
1385     /* unblock when we remove the last blocking probe */
1386     pad-&gt;num_blocked--;
1387     GST_DEBUG_OBJECT (pad, &quot;remove blocking probe, now %d left&quot;,
1388         pad-&gt;num_blocked);
1389 
1390     /* Might have new probes now that want to be called */
1391     GST_PAD_BLOCK_BROADCAST (pad);
1392 
1393     if (pad-&gt;num_blocked == 0) {
1394       GST_DEBUG_OBJECT (pad, &quot;last blocking probe removed, unblocking&quot;);
1395       GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_BLOCKED);
1396     }
1397   }
1398   g_hook_destroy_link (&amp;pad-&gt;probes, hook);
</pre>
<hr />
<pre>
1427  */
1428 gulong
1429 gst_pad_add_probe (GstPad * pad, GstPadProbeType mask,
1430     GstPadProbeCallback callback, gpointer user_data,
1431     GDestroyNotify destroy_data)
1432 {
1433   GHook *hook;
1434   gulong res;
1435 
1436   g_return_val_if_fail (GST_IS_PAD (pad), 0);
1437   g_return_val_if_fail (mask != 0, 0);
1438 
1439   GST_OBJECT_LOCK (pad);
1440 
1441   /* make a new probe */
1442   hook = g_hook_alloc (&amp;pad-&gt;probes);
1443 
1444   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;adding probe for mask 0x%08x&quot;,
1445       mask);
1446 
<span class="line-modified">1447   /* when no contraints are given for the types, assume all types are</span>
1448    * acceptable */
1449   if ((mask &amp; _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH) == 0)
1450     mask |= GST_PAD_PROBE_TYPE_ALL_BOTH;
1451   if ((mask &amp; GST_PAD_PROBE_TYPE_SCHEDULING) == 0)
1452     mask |= GST_PAD_PROBE_TYPE_SCHEDULING;
1453 
1454   /* store our flags and other fields */
1455   hook-&gt;flags |= (mask &lt;&lt; G_HOOK_FLAG_USER_SHIFT);
1456   hook-&gt;func = callback;
1457   hook-&gt;data = user_data;
1458   hook-&gt;destroy = destroy_data;
1459 
1460   /* add the probe */
1461   g_hook_append (&amp;pad-&gt;probes, hook);
1462   pad-&gt;num_probes++;
<span class="line-modified">1463   /* incremenent cookie so that the new hook get&#39;s called */</span>
1464   pad-&gt;priv-&gt;probe_list_cookie++;
1465 
1466   /* get the id of the hook, we return this and it can be used to remove the
1467    * probe later */
1468   res = hook-&gt;hook_id;
1469 
1470   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;got probe id %lu&quot;, res);
1471 
1472   if (mask &amp; GST_PAD_PROBE_TYPE_BLOCKING) {
1473     /* we have a block probe */
1474     pad-&gt;num_blocked++;
1475     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_BLOCKED);
1476     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;added blocking probe, &quot;
1477         &quot;now %d blocking probes&quot;, pad-&gt;num_blocked);
1478 
1479     /* Might have new probes now that want to be called */
1480     GST_PAD_BLOCK_BROADCAST (pad);
1481   }
1482 
1483   /* call the callback if we need to be called for idle callbacks */
</pre>
<hr />
<pre>
2069       GST_DEBUG_FUNCPTR_NAME (link));
2070 }
2071 
2072 /**
2073  * gst_pad_set_unlink_function:
2074  * @p: a #GstPad.
2075  * @f: the #GstPadUnlinkFunction to set.
2076  *
2077  * Calls gst_pad_set_unlink_function_full() with %NULL
2078  * for the user_data and notify.
2079  */
2080 /**
2081  * gst_pad_set_unlink_function_full:
2082  * @pad: a #GstPad.
2083  * @unlink: the #GstPadUnlinkFunction to set.
2084  * @user_data: user_data passed to @notify
2085  * @notify: notify called when @unlink will not be used anymore.
2086  *
2087  * Sets the given unlink function for the pad. It will be called
2088  * when the pad is unlinked.




2089  */
2090 void
2091 gst_pad_set_unlink_function_full (GstPad * pad, GstPadUnlinkFunction unlink,
2092     gpointer user_data, GDestroyNotify notify)
2093 {
2094   g_return_if_fail (GST_IS_PAD (pad));
2095 
2096   if (pad-&gt;unlinknotify)
2097     pad-&gt;unlinknotify (pad-&gt;unlinkdata);
2098   GST_PAD_UNLINKFUNC (pad) = unlink;
2099   pad-&gt;unlinkdata = user_data;
2100   pad-&gt;unlinknotify = notify;
2101 
2102   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;unlinkfunc set to %s&quot;,
2103       GST_DEBUG_FUNCPTR_NAME (unlink));
2104 }
2105 
2106 /**
2107  * gst_pad_unlink:
2108  * @srcpad: the source #GstPad to unlink.
</pre>
<hr />
<pre>
2569 
2570     /* we released the lock, check if the same pads are linked still */
2571     if (GST_PAD_PEER (srcpad) != sinkpad || GST_PAD_PEER (sinkpad) != srcpad)
2572       goto concurrent_link;
2573 
2574     if (G_UNLIKELY (result != GST_PAD_LINK_OK))
2575       goto link_failed;
2576   }
2577   GST_OBJECT_UNLOCK (sinkpad);
2578   GST_OBJECT_UNLOCK (srcpad);
2579 
2580   /* fire off a signal to each of the pads telling them
2581    * that they&#39;ve been linked */
2582   g_signal_emit (srcpad, gst_pad_signals[PAD_LINKED], 0, sinkpad);
2583   g_signal_emit (sinkpad, gst_pad_signals[PAD_LINKED], 0, srcpad);
2584 
2585   GST_CAT_INFO (GST_CAT_PADS, &quot;linked %s:%s and %s:%s, successful&quot;,
2586       GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad));
2587 
2588   if (!(flags &amp; GST_PAD_LINK_CHECK_NO_RECONFIGURE))
<span class="line-modified">2589   gst_pad_send_event (srcpad, gst_event_new_reconfigure ());</span>
2590 
2591 done:
2592   if (G_LIKELY (parent)) {
2593     gst_element_post_message (parent,
2594         gst_message_new_structure_change (GST_OBJECT_CAST (sinkpad),
2595             GST_STRUCTURE_CHANGE_TYPE_PAD_LINK, parent, FALSE));
2596     gst_object_unref (parent);
2597   }
2598 
2599   GST_TRACER_PAD_LINK_POST (srcpad, sinkpad, result);
2600   return result;
2601 
2602   /* ERRORS */
2603 concurrent_link:
2604   {
2605     GST_CAT_INFO (GST_CAT_PADS, &quot;concurrent link between %s:%s and %s:%s&quot;,
2606         GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad));
2607     GST_OBJECT_UNLOCK (sinkpad);
2608     GST_OBJECT_UNLOCK (srcpad);
2609 
</pre>
<hr />
<pre>
3119 
3120 /* Default accept caps implementation just checks against
3121  * the allowed caps for the pad */
3122 static gboolean
3123 gst_pad_query_accept_caps_default (GstPad * pad, GstQuery * query)
3124 {
3125   /* get the caps and see if it intersects to something not empty */
3126   GstCaps *caps, *allowed = NULL;
3127   gboolean result;
3128 
3129   GST_DEBUG_OBJECT (pad, &quot;query accept-caps %&quot; GST_PTR_FORMAT, query);
3130 
3131   /* first forward the query to internally linked pads when we are dealing with
3132    * a PROXY CAPS */
3133   if (GST_PAD_IS_PROXY_CAPS (pad)) {
3134     result = gst_pad_proxy_query_accept_caps (pad, query);
3135     if (result)
3136       allowed = gst_pad_get_pad_template_caps (pad);
3137     else
3138       goto done;
<span class="line-modified">3139     }</span>
3140 
3141   gst_query_parse_accept_caps (query, &amp;caps);
3142   if (!allowed) {
3143     if (GST_PAD_IS_ACCEPT_TEMPLATE (pad)) {
3144       allowed = gst_pad_get_pad_template_caps (pad);
3145     } else {
<span class="line-modified">3146   GST_CAT_DEBUG_OBJECT (GST_CAT_PERFORMANCE, pad,</span>
<span class="line-modified">3147       &quot;fallback ACCEPT_CAPS query, consider implementing a specialized version&quot;);</span>
<span class="line-modified">3148   allowed = gst_pad_query_caps (pad, caps);</span>
3149     }
3150   }
3151 
3152   if (allowed) {
3153     if (GST_PAD_IS_ACCEPT_INTERSECT (pad)) {
3154       GST_DEBUG_OBJECT (pad,
3155           &quot;allowed caps intersect %&quot; GST_PTR_FORMAT &quot;, caps %&quot; GST_PTR_FORMAT,
3156           allowed, caps);
3157       result = gst_caps_can_intersect (caps, allowed);
3158     } else {
3159       GST_DEBUG_OBJECT (pad, &quot;allowed caps subset %&quot; GST_PTR_FORMAT &quot;, caps %&quot;
3160           GST_PTR_FORMAT, allowed, caps);
3161       result = gst_caps_is_subset (caps, allowed);
3162     }
3163     gst_caps_unref (allowed);
3164   } else {
3165     GST_DEBUG_OBJECT (pad, &quot;no compatible caps allowed on the pad&quot;);
3166     result = FALSE;
3167   }
3168   gst_query_set_accept_caps_result (query, result);
</pre>
<hr />
<pre>
3402 
3403   switch (GST_QUERY_TYPE (query)) {
3404     case GST_QUERY_SCHEDULING:
3405       forward = GST_PAD_IS_PROXY_SCHEDULING (pad);
3406       break;
3407     case GST_QUERY_ALLOCATION:
3408       forward = GST_PAD_IS_PROXY_ALLOCATION (pad);
3409       break;
3410     case GST_QUERY_ACCEPT_CAPS:
3411       ret = gst_pad_query_accept_caps_default (pad, query);
3412       forward = FALSE;
3413       break;
3414     case GST_QUERY_CAPS:
3415       ret = gst_pad_query_caps_default (pad, query);
3416       forward = FALSE;
3417       break;
3418     case GST_QUERY_LATENCY:
3419       ret = gst_pad_query_latency_default (pad, query);
3420       forward = FALSE;
3421       break;




3422     case GST_QUERY_POSITION:
3423     case GST_QUERY_SEEKING:
3424     case GST_QUERY_FORMATS:
3425     case GST_QUERY_JITTER:
3426     case GST_QUERY_RATE:
3427     case GST_QUERY_CONVERT:
3428     default:
3429       forward = TRUE;
3430       break;
3431   }
3432 
3433   GST_DEBUG_OBJECT (pad, &quot;%sforwarding %p (%s) query&quot;, (forward ? &quot;&quot; : &quot;not &quot;),
3434       query, GST_QUERY_TYPE_NAME (query));
3435 
3436   if (forward) {
3437     QueryData data;
3438 
3439     data.query = query;
3440     data.dispatched = FALSE;
3441     data.result = FALSE;
</pre>
<hr />
<pre>
3455   return ret;
3456 }
3457 
3458 #define N_STACK_ALLOCATE_PROBES (16)
3459 
3460 static void
3461 probe_hook_marshal (GHook * hook, ProbeMarshall * data)
3462 {
3463   GstPad *pad = data-&gt;pad;
3464   GstPadProbeInfo *info = data-&gt;info;
3465   GstPadProbeType type, flags;
3466   GstPadProbeCallback callback;
3467   GstPadProbeReturn ret;
3468   gpointer original_data;
3469   guint i;
3470 
3471   /* if we have called this callback, do nothing. But only check
3472    * if we&#39;re actually calling probes a second time */
3473   if (data-&gt;retry) {
3474     for (i = 0; i &lt; data-&gt;n_called_probes; i++) {
<span class="line-modified">3475       if (data-&gt;called_probes[i] == hook) {</span>
<span class="line-modified">3476     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,</span>
3477             &quot;hook %lu already called&quot;, hook-&gt;hook_id);
<span class="line-modified">3478     return;</span>
<span class="line-modified">3479   }</span>
3480     }
3481   }
3482 
3483   /* reallocate on the heap if we had more than 16 probes */
3484   if (data-&gt;n_called_probes == data-&gt;called_probes_size) {
3485     if (data-&gt;called_probes_size &gt; N_STACK_ALLOCATE_PROBES) {
3486       data-&gt;called_probes_size *= 2;
3487       data-&gt;called_probes =
<span class="line-modified">3488           g_renew (GHook *, data-&gt;called_probes, data-&gt;called_probes_size);</span>
3489     } else {
<span class="line-modified">3490       GHook **tmp = data-&gt;called_probes;</span>
3491 
3492       data-&gt;called_probes_size *= 2;
<span class="line-modified">3493       data-&gt;called_probes = g_new (GHook *, data-&gt;called_probes_size);</span>
3494       memcpy (data-&gt;called_probes, tmp,
<span class="line-modified">3495           N_STACK_ALLOCATE_PROBES * sizeof (GHook *));</span>
3496     }
3497   }
<span class="line-modified">3498   data-&gt;called_probes[data-&gt;n_called_probes++] = hook;</span>
3499 
3500   flags = hook-&gt;flags &gt;&gt; G_HOOK_FLAG_USER_SHIFT;
3501   type = info-&gt;type;
3502   original_data = info-&gt;data;
3503 
3504   /* one of the scheduling types */
3505   if ((flags &amp; GST_PAD_PROBE_TYPE_SCHEDULING &amp; type) == 0)
3506     goto no_match;
3507 
3508   if (G_UNLIKELY (data-&gt;handled)) {
3509     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3510         &quot;probe previously returned HANDLED, not calling again&quot;);
3511     goto no_match;
3512   } else if (G_UNLIKELY (data-&gt;dropped)) {
3513     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3514         &quot;probe previously returned DROPPED, not calling again&quot;);
3515     goto no_match;
3516   }
3517 
3518   if (type &amp; GST_PAD_PROBE_TYPE_PUSH) {
<span class="line-modified">3519   /* one of the data types for non-idle probes */</span>
<span class="line-modified">3520   if ((type &amp; GST_PAD_PROBE_TYPE_IDLE) == 0</span>
3521         &amp;&amp; (flags &amp; _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH &amp; type) == 0)
<span class="line-modified">3522     goto no_match;</span>
3523   } else if (type &amp; GST_PAD_PROBE_TYPE_PULL) {
3524     /* one of the data types for non-idle probes */
3525     if ((type &amp; GST_PAD_PROBE_TYPE_BLOCKING) == 0
3526         &amp;&amp; (flags &amp; _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH &amp; type) == 0)
<span class="line-modified">3527     goto no_match;</span>
3528   } else {
3529     /* Type must have PULL or PUSH probe types */
3530     g_assert_not_reached ();
3531   }
3532 
3533   /* one of the blocking types must match */
3534   if ((type &amp; GST_PAD_PROBE_TYPE_BLOCKING) &amp;&amp;
3535       (flags &amp; GST_PAD_PROBE_TYPE_BLOCKING &amp; type) == 0)
3536     goto no_match;
3537   if ((type &amp; GST_PAD_PROBE_TYPE_BLOCKING) == 0 &amp;&amp;
3538       (flags &amp; GST_PAD_PROBE_TYPE_BLOCKING))
3539     goto no_match;
3540   /* only probes that have GST_PAD_PROBE_TYPE_EVENT_FLUSH set */
3541   if ((type &amp; GST_PAD_PROBE_TYPE_EVENT_FLUSH) &amp;&amp;
3542       (flags &amp; GST_PAD_PROBE_TYPE_EVENT_FLUSH &amp; type) == 0)
3543     goto no_match;
3544 
3545   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3546       &quot;hook %lu with flags 0x%08x matches&quot;, hook-&gt;hook_id, flags);
3547 
3548   data-&gt;marshalled = TRUE;
3549 
3550   callback = (GstPadProbeCallback) hook-&gt;func;
3551   if (callback == NULL)
3552     return;
3553 
3554   info-&gt;id = hook-&gt;hook_id;
3555 
3556   if ((flags &amp; GST_PAD_PROBE_TYPE_IDLE))
3557     pad-&gt;priv-&gt;idle_running++;
3558 
3559   GST_OBJECT_UNLOCK (pad);
3560 
3561   ret = callback (pad, info, hook-&gt;data);
3562 
3563   GST_OBJECT_LOCK (pad);
3564 
3565   if ((flags &amp; GST_PAD_PROBE_TYPE_IDLE))
3566     pad-&gt;priv-&gt;idle_running--;
3567 
<span class="line-modified">3568   if (original_data != NULL &amp;&amp; info-&gt;data == NULL) {</span>

3569     GST_DEBUG_OBJECT (pad, &quot;data item in pad probe info was dropped&quot;);
3570     info-&gt;type = GST_PAD_PROBE_TYPE_INVALID;
3571     data-&gt;dropped = TRUE;
3572   }
3573 
3574   switch (ret) {
3575     case GST_PAD_PROBE_REMOVE:
3576       /* remove the probe */
3577       GST_DEBUG_OBJECT (pad, &quot;asked to remove hook&quot;);
3578       cleanup_hook (pad, hook);
3579       break;
3580     case GST_PAD_PROBE_DROP:
3581       /* need to drop the data, make sure other probes don&#39;t get called
3582        * anymore */
3583       GST_DEBUG_OBJECT (pad, &quot;asked to drop item&quot;);
3584       info-&gt;type = GST_PAD_PROBE_TYPE_INVALID;
3585       data-&gt;dropped = TRUE;
3586       break;
3587     case GST_PAD_PROBE_HANDLED:
3588       GST_DEBUG_OBJECT (pad, &quot;probe handled data&quot;);
</pre>
<hr />
<pre>
3596     case GST_PAD_PROBE_OK:
3597       GST_DEBUG_OBJECT (pad, &quot;probe returned OK&quot;);
3598       break;
3599     default:
3600       GST_DEBUG_OBJECT (pad, &quot;probe returned %d&quot;, ret);
3601       break;
3602   }
3603   return;
3604 
3605 no_match:
3606   {
3607     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3608         &quot;hook %lu with flags 0x%08x does not match %08x&quot;,
3609         hook-&gt;hook_id, flags, info-&gt;type);
3610     return;
3611   }
3612 }
3613 
3614 /* a probe that does not take or return any data */
3615 #define PROBE_NO_DATA(pad,mask,label,defaultval)                \
<span class="line-modified">3616   G_STMT_START {                        \</span>
<span class="line-modified">3617     if (G_UNLIKELY (pad-&gt;num_probes)) {             \</span>
<span class="line-modified">3618       GstFlowReturn pval = defaultval;              \</span>
3619       /* pass NULL as the data item */                          \
<span class="line-modified">3620       GstPadProbeInfo info = { mask, 0, NULL, 0, 0 };       \</span>
<span class="line-modified">3621       info.ABI.abi.flow_ret = defaultval;           \</span>
<span class="line-modified">3622       ret = do_probe_callbacks (pad, &amp;info, defaultval);    \</span>
<span class="line-modified">3623       if (G_UNLIKELY (ret != pval &amp;&amp; ret != GST_FLOW_OK))   \</span>
<span class="line-modified">3624         goto label;                     \</span>
<span class="line-modified">3625     }                               \</span>
3626   } G_STMT_END
3627 
3628 #define PROBE_FULL(pad,mask,data,offs,size,label,handleable,handle_label) \
<span class="line-modified">3629   G_STMT_START {                            \</span>
<span class="line-modified">3630     if (G_UNLIKELY (pad-&gt;num_probes)) {                 \</span>
<span class="line-modified">3631       /* pass the data item */                      \</span>
<span class="line-modified">3632       GstPadProbeInfo info = { mask, 0, data, offs, size };     \</span>
<span class="line-modified">3633       info.ABI.abi.flow_ret = GST_FLOW_OK;              \</span>
<span class="line-modified">3634       ret = do_probe_callbacks (pad, &amp;info, GST_FLOW_OK);       \</span>
<span class="line-modified">3635       /* store the possibly updated data item */            \</span>
<span class="line-modified">3636       data = GST_PAD_PROBE_INFO_DATA (&amp;info);               \</span>
<span class="line-modified">3637       /* if something went wrong, exit */               \</span>
<span class="line-modified">3638       if (G_UNLIKELY (ret != GST_FLOW_OK)) {                \</span>
<span class="line-modified">3639     if (handleable &amp;&amp; ret == GST_FLOW_CUSTOM_SUCCESS_1) {       \</span>
<span class="line-modified">3640       ret = info.ABI.abi.flow_ret;                      \</span>
<span class="line-modified">3641       goto handle_label;                        \</span>
<span class="line-modified">3642     }                               \</span>
<span class="line-modified">3643     goto label;                         \</span>
<span class="line-modified">3644       }                                 \</span>
<span class="line-modified">3645     }                                   \</span>
3646   } G_STMT_END
3647 
<span class="line-modified">3648 #define PROBE_PUSH(pad,mask,data,label)     \</span>
3649   PROBE_FULL(pad, mask, data, -1, -1, label, FALSE, label);
3650 #define PROBE_HANDLE(pad,mask,data,label,handle_label)  \
3651   PROBE_FULL(pad, mask, data, -1, -1, label, TRUE, handle_label);
<span class="line-modified">3652 #define PROBE_PULL(pad,mask,data,offs,size,label)       \</span>
3653   PROBE_FULL(pad, mask, data, offs, size, label, FALSE, label);
3654 
3655 static GstFlowReturn
3656 do_pad_idle_probe_wait (GstPad * pad)
3657 {
3658   while (GST_PAD_IS_RUNNING_IDLE_PROBE (pad)) {
3659     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3660         &quot;waiting idle probe to be removed&quot;);
3661     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_BLOCKING);
3662     GST_PAD_BLOCK_WAIT (pad);
3663     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_BLOCKING);
3664     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;We got unblocked&quot;);
3665 
3666     if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
3667       return GST_FLOW_FLUSHING;
3668   }
3669   return GST_FLOW_OK;
3670 }
3671 
3672 #define PROBE_TYPE_IS_SERIALIZED(i) \
</pre>
<hr />
<pre>
3674       ( \
3675         (((i)-&gt;type &amp; (GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM | \
3676         GST_PAD_PROBE_TYPE_EVENT_FLUSH)) &amp;&amp; \
3677         GST_EVENT_IS_SERIALIZED ((i)-&gt;data)) \
3678       ) || ( \
3679         (((i)-&gt;type &amp; GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM) &amp;&amp; \
3680         GST_QUERY_IS_SERIALIZED ((i)-&gt;data)) \
3681       ) || ( \
3682         ((i)-&gt;type &amp; (GST_PAD_PROBE_TYPE_BUFFER | \
3683         GST_PAD_PROBE_TYPE_BUFFER_LIST))  \
3684       ) \
3685     )
3686 
3687 static GstFlowReturn
3688 do_probe_callbacks (GstPad * pad, GstPadProbeInfo * info,
3689     GstFlowReturn defaultval)
3690 {
3691   ProbeMarshall data;
3692   guint cookie;
3693   gboolean is_block;
<span class="line-modified">3694   GHook *called_probes[N_STACK_ALLOCATE_PROBES];</span>
3695 
3696   data.pad = pad;
3697   data.info = info;
3698   data.pass = FALSE;
3699   data.handled = FALSE;
3700   data.marshalled = FALSE;
3701   data.dropped = FALSE;
3702 
3703   /* We stack-allocate for N_STACK_ALLOCATE_PROBES hooks as a first step. If more are needed,
3704    * we will re-allocate with g_malloc(). This should usually never be needed
3705    */
3706   data.called_probes = called_probes;
3707   data.n_called_probes = 0;
3708   data.called_probes_size = N_STACK_ALLOCATE_PROBES;
3709   data.retry = FALSE;
3710 
3711   is_block =
3712       (info-&gt;type &amp; GST_PAD_PROBE_TYPE_BLOCK) == GST_PAD_PROBE_TYPE_BLOCK;
3713 
3714   if (is_block &amp;&amp; PROBE_TYPE_IS_SERIALIZED (info)) {
</pre>
<hr />
<pre>
3801   {
3802     GST_DEBUG_OBJECT (pad, &quot;data is dropped&quot;);
3803     if (data.called_probes_size &gt; N_STACK_ALLOCATE_PROBES)
3804       g_free (data.called_probes);
3805     return GST_FLOW_CUSTOM_SUCCESS;
3806   }
3807 passed:
3808   {
3809     /* FIXME : Should we return FLOW_OK or the defaultval ?? */
3810     GST_DEBUG_OBJECT (pad, &quot;data is passed&quot;);
3811     if (data.called_probes_size &gt; N_STACK_ALLOCATE_PROBES)
3812       g_free (data.called_probes);
3813     return GST_FLOW_OK;
3814   }
3815 handled:
3816   {
3817     GST_DEBUG_OBJECT (pad, &quot;data was handled&quot;);
3818     if (data.called_probes_size &gt; N_STACK_ALLOCATE_PROBES)
3819       g_free (data.called_probes);
3820     return GST_FLOW_CUSTOM_SUCCESS_1;
<span class="line-modified">3821 }</span>
3822 }
3823 
3824 /* pad offsets */
3825 
3826 /**
3827  * gst_pad_get_offset:
3828  * @pad: a #GstPad
3829  *
3830  * Get the offset applied to the running time of @pad. @pad has to be a source
3831  * pad.
3832  *
3833  * Returns: the offset.
3834  */
3835 gint64
3836 gst_pad_get_offset (GstPad * pad)
3837 {
3838   gint64 result;
3839 
3840   g_return_val_if_fail (GST_IS_PAD (pad), 0);
3841 
</pre>
<hr />
<pre>
4366     return GST_FLOW_EOS;
4367   }
4368 wrong_mode:
4369   {
4370     g_critical (&quot;chain on pad %s:%s but it was not in push mode&quot;,
4371         GST_DEBUG_PAD_NAME (pad));
4372     GST_OBJECT_UNLOCK (pad);
4373     GST_PAD_STREAM_UNLOCK (pad);
4374     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4375     return GST_FLOW_ERROR;
4376   }
4377 probe_handled:
4378   handled = TRUE;
4379   /* PASSTHROUGH */
4380 probe_stopped:
4381   {
4382     GST_OBJECT_UNLOCK (pad);
4383     GST_PAD_STREAM_UNLOCK (pad);
4384     /* We unref the buffer, except if the probe handled it (CUSTOM_SUCCESS_1) */
4385     if (!handled)
<span class="line-modified">4386     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));</span>
4387 
4388     switch (ret) {
4389       case GST_FLOW_CUSTOM_SUCCESS:
4390       case GST_FLOW_CUSTOM_SUCCESS_1:
4391         GST_DEBUG_OBJECT (pad, &quot;dropped or handled buffer&quot;);
4392         ret = GST_FLOW_OK;
4393         break;
4394       default:
4395         GST_DEBUG_OBJECT (pad, &quot;an error occurred %s&quot;, gst_flow_get_name (ret));
4396         break;
4397     }
4398     return ret;
4399   }
4400 no_parent:
4401   {
4402     GST_DEBUG_OBJECT (pad, &quot;No parent when chaining %&quot; GST_PTR_FORMAT, data);
4403     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4404     GST_OBJECT_UNLOCK (pad);
4405     GST_PAD_STREAM_UNLOCK (pad);
4406     return GST_FLOW_FLUSHING;
</pre>
<hr />
<pre>
4619     GST_OBJECT_UNLOCK (pad);
4620     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4621     return GST_FLOW_ERROR;
4622   }
4623 events_error:
4624   {
4625     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4626         &quot;error pushing events, return %s&quot;, gst_flow_get_name (ret));
4627     pad-&gt;ABI.abi.last_flowret = ret;
4628     GST_OBJECT_UNLOCK (pad);
4629     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4630     return ret;
4631   }
4632 probe_handled:
4633   handled = TRUE;
4634   /* PASSTHROUGH */
4635 probe_stopped:
4636   {
4637     GST_OBJECT_UNLOCK (pad);
4638     if (data != NULL &amp;&amp; !handled)
<span class="line-modified">4639     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));</span>
4640 
4641     switch (ret) {
4642       case GST_FLOW_CUSTOM_SUCCESS:
4643       case GST_FLOW_CUSTOM_SUCCESS_1:
4644         GST_DEBUG_OBJECT (pad, &quot;dropped or handled buffer&quot;);
4645         ret = GST_FLOW_OK;
4646         break;
4647       default:
4648         GST_DEBUG_OBJECT (pad, &quot;an error occurred %s&quot;, gst_flow_get_name (ret));
4649         break;
4650     }
4651     pad-&gt;ABI.abi.last_flowret = ret;
4652     return ret;
4653   }
4654 not_linked:
4655   {
4656     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4657         &quot;pushing, but it was not linked&quot;);
4658     pad-&gt;ABI.abi.last_flowret = GST_FLOW_NOT_LINKED;
4659     GST_OBJECT_UNLOCK (pad);
</pre>
<hr />
<pre>
5111     goto done;
5112   }
5113 probe_stopped_unref:
5114   {
5115     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
5116         &quot;post probe returned %s&quot;, gst_flow_get_name (ret));
5117 
5118     /* if we drop here, it signals EOS */
5119     if (ret == GST_FLOW_CUSTOM_SUCCESS)
5120       ret = GST_FLOW_EOS;
5121 
5122     pad-&gt;ABI.abi.last_flowret = ret;
5123     GST_OBJECT_UNLOCK (pad);
5124 
5125     if (*buffer == NULL)
5126       gst_buffer_unref (res_buf);
5127     goto done;
5128   }
5129 done:
5130   GST_TRACER_PAD_PULL_RANGE_POST (pad, NULL, ret);
<span class="line-modified">5131     return ret;</span>
<span class="line-modified">5132   }</span>
5133 
5134 /* must be called with pad object lock */
5135 static GstFlowReturn
5136 store_sticky_event (GstPad * pad, GstEvent * event)
5137 {
5138   guint i, len;
5139   GstEventType type;
5140   GArray *events;
5141   gboolean res = FALSE;
5142   const gchar *name = NULL;
5143   gboolean insert = TRUE;
5144 
5145   type = GST_EVENT_TYPE (event);
5146 
5147   /* Store all sticky events except SEGMENT/EOS when we&#39;re flushing,
5148    * otherwise they can be dropped and nothing would ever resend them.
5149    * Only do that for activated pads though, everything else is a bug!
5150    */
5151   if (G_UNLIKELY (GST_PAD_MODE (pad) == GST_PAD_MODE_NONE
5152           || (GST_PAD_IS_FLUSHING (pad) &amp;&amp; (type == GST_EVENT_SEGMENT
</pre>
<hr />
<pre>
5422   }
5423   return ret;
5424 
5425   /* ERROR handling */
5426 flushed:
5427   {
5428     GST_DEBUG_OBJECT (pad, &quot;We&#39;re flushing&quot;);
5429     gst_event_unref (event);
5430     return GST_FLOW_FLUSHING;
5431   }
5432 inactive:
5433   {
5434     GST_DEBUG_OBJECT (pad, &quot;flush-stop on inactive pad&quot;);
5435     gst_event_unref (event);
5436     return GST_FLOW_FLUSHING;
5437   }
5438 probe_stopped:
5439   {
5440     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
5441     if (ret != GST_FLOW_CUSTOM_SUCCESS_1)
<span class="line-modified">5442     gst_event_unref (event);</span>
5443 
5444     switch (ret) {
5445       case GST_FLOW_CUSTOM_SUCCESS_1:
5446         GST_DEBUG_OBJECT (pad, &quot;handled event&quot;);
5447         break;
5448       case GST_FLOW_CUSTOM_SUCCESS:
5449         GST_DEBUG_OBJECT (pad, &quot;dropped event&quot;);
5450         break;
5451       default:
5452         GST_DEBUG_OBJECT (pad, &quot;an error occurred %s&quot;, gst_flow_get_name (ret));
5453         break;
5454     }
5455     return ret;
5456   }
5457 not_linked:
5458   {
5459     GST_DEBUG_OBJECT (pad, &quot;Dropping event %s because pad is not linked&quot;,
5460         gst_event_type_get_name (GST_EVENT_TYPE (event)));
5461     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
5462     gst_event_unref (event);
</pre>
<hr />
<pre>
5572     g_warning (&quot;pad %s:%s has invalid direction&quot;, GST_DEBUG_PAD_NAME (pad));
5573     gst_event_unref (event);
5574     goto done;
5575   }
5576 flushed:
5577   {
5578     GST_DEBUG_OBJECT (pad, &quot;We&#39;re flushing&quot;);
5579     GST_OBJECT_UNLOCK (pad);
5580     gst_event_unref (event);
5581     goto done;
5582   }
5583 eos:
5584   {
5585     GST_DEBUG_OBJECT (pad, &quot;We&#39;re EOS&quot;);
5586     GST_OBJECT_UNLOCK (pad);
5587     gst_event_unref (event);
5588     goto done;
5589   }
5590 done:
5591   GST_TRACER_PAD_PUSH_EVENT_POST (pad, FALSE);
<span class="line-modified">5592     return FALSE;</span>
<span class="line-modified">5593   }</span>
5594 
5595 /* Check if we can call the event function with the given event */
5596 static GstFlowReturn
5597 pre_eventfunc_check (GstPad * pad, GstEvent * event)
5598 {
5599   GstCaps *caps;
5600 
5601   switch (GST_EVENT_TYPE (event)) {
5602     case GST_EVENT_CAPS:
5603     {
5604       /* backwards compatibility mode for caps */
5605       gst_event_parse_caps (event, &amp;caps);
5606 
5607       if (!gst_pad_query_accept_caps (pad, caps))
5608         goto not_accepted;
5609       break;
5610     }
5611     default:
5612       break;
5613   }
</pre>
<hr />
<pre>
5650       GST_CAT_DEBUG_OBJECT (GST_CAT_EVENT, pad,
5651           &quot;have event type %d (FLUSH_START)&quot;, GST_EVENT_TYPE (event));
5652 
5653       /* can&#39;t even accept a flush begin event when flushing */
5654       if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
5655         goto flushing;
5656 
5657       GST_PAD_SET_FLUSHING (pad);
5658       GST_CAT_DEBUG_OBJECT (GST_CAT_EVENT, pad, &quot;set flush flag&quot;);
5659       GST_PAD_BLOCK_BROADCAST (pad);
5660       type |= GST_PAD_PROBE_TYPE_EVENT_FLUSH;
5661       break;
5662     case GST_EVENT_FLUSH_STOP:
5663       /* we can&#39;t accept flush-stop on inactive pads else the flushing flag
5664        * would be cleared and it would look like the pad can accept data.
5665        * Also, some elements restart a streaming thread in flush-stop which we
5666        * can&#39;t allow on inactive pads */
5667       if (G_UNLIKELY (!GST_PAD_IS_ACTIVE (pad)))
5668         goto inactive;
5669 
<span class="line-modified">5670         GST_PAD_UNSET_FLUSHING (pad);</span>
<span class="line-modified">5671         GST_CAT_DEBUG_OBJECT (GST_CAT_EVENT, pad, &quot;cleared flush flag&quot;);</span>
5672       /* Remove pending EOS events */
5673       GST_LOG_OBJECT (pad, &quot;Removing pending EOS and SEGMENT events&quot;);
5674       remove_event_by_type (pad, GST_EVENT_EOS);
5675       remove_event_by_type (pad, GST_EVENT_STREAM_GROUP_DONE);
5676       remove_event_by_type (pad, GST_EVENT_SEGMENT);
5677       GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_EOS);
5678       pad-&gt;ABI.abi.last_flowret = GST_FLOW_OK;
5679 
5680       GST_OBJECT_UNLOCK (pad);
5681       /* grab stream lock */
5682       GST_PAD_STREAM_LOCK (pad);
5683       need_unlock = TRUE;
5684       GST_OBJECT_LOCK (pad);
5685       if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
5686         goto flushing;
5687       break;
5688     case GST_EVENT_RECONFIGURE:
5689       if (GST_PAD_IS_SRC (pad))
5690         GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
5691     default:
</pre>
<hr />
<pre>
5819     gst_event_unref (event);
5820     return GST_FLOW_FLUSHING;
5821   }
5822 eos:
5823   {
5824     GST_OBJECT_UNLOCK (pad);
5825     if (need_unlock)
5826       GST_PAD_STREAM_UNLOCK (pad);
5827     GST_CAT_INFO_OBJECT (GST_CAT_EVENT, pad,
5828         &quot;Received event on EOS pad. Discarding&quot;);
5829     gst_event_unref (event);
5830     return GST_FLOW_EOS;
5831   }
5832 probe_stopped:
5833   {
5834     GST_OBJECT_UNLOCK (pad);
5835     if (need_unlock)
5836       GST_PAD_STREAM_UNLOCK (pad);
5837     /* Only unref if unhandled */
5838     if (ret != GST_FLOW_CUSTOM_SUCCESS_1)
<span class="line-modified">5839     gst_event_unref (event);</span>
5840 
5841     switch (ret) {
5842       case GST_FLOW_CUSTOM_SUCCESS_1:
5843       case GST_FLOW_CUSTOM_SUCCESS:
5844         GST_DEBUG_OBJECT (pad, &quot;dropped or handled event&quot;);
5845         ret = GST_FLOW_OK;
5846         break;
5847       default:
5848         GST_DEBUG_OBJECT (pad, &quot;an error occurred %s&quot;, gst_flow_get_name (ret));
5849         break;
5850     }
5851     return ret;
5852   }
5853 no_function:
5854   {
5855     g_warning (&quot;pad %s:%s has no event handler, file a bug.&quot;,
5856         GST_DEBUG_PAD_NAME (pad));
5857     GST_OBJECT_UNLOCK (pad);
5858     if (need_unlock)
5859       GST_PAD_STREAM_UNLOCK (pad);
</pre>
</td>
<td>
<hr />
<pre>
 101 
 102 GST_DEBUG_CATEGORY_STATIC (debug_dataflow);
 103 #define GST_CAT_DEFAULT GST_CAT_PADS
 104 
 105 /* Pad signals and args */
 106 enum
 107 {
 108   PAD_LINKED,
 109   PAD_UNLINKED,
 110   /* FILL ME */
 111   LAST_SIGNAL
 112 };
 113 
 114 enum
 115 {
 116   PAD_PROP_0,
 117   PAD_PROP_CAPS,
 118   PAD_PROP_DIRECTION,
 119   PAD_PROP_TEMPLATE,
 120   PAD_PROP_OFFSET
<span class="line-modified"> 121       /* FILL ME */</span>
 122 };
 123 



 124 #define _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH (GST_PAD_PROBE_TYPE_ALL_BOTH | GST_PAD_PROBE_TYPE_EVENT_FLUSH)
 125 
 126 /* we have a pending and an active event on the pad. On source pads only the
 127  * active event is used. On sinkpads, events are copied to the pending entry and
 128  * moved to the active event when the eventfunc returned %TRUE. */
 129 typedef struct
 130 {
 131   gboolean received;
 132   GstEvent *event;
 133 } PadEvent;
 134 
 135 struct _GstPadPrivate
 136 {
 137   guint events_cookie;
 138   GArray *events;
 139   guint last_cookie;
 140 
 141   gint using;
 142   guint probe_list_cookie;
 143 
</pre>
<hr />
<pre>
 152   gboolean in_activation;
 153 };
 154 
 155 typedef struct
 156 {
 157   GHook hook;
 158 } GstProbe;
 159 
 160 #define GST_PAD_IS_RUNNING_IDLE_PROBE(p) \
 161     (((GstPad *)(p))-&gt;priv-&gt;idle_running &gt; 0)
 162 
 163 typedef struct
 164 {
 165   GstPad *pad;
 166   GstPadProbeInfo *info;
 167   gboolean dropped;
 168   gboolean pass;
 169   gboolean handled;
 170   gboolean marshalled;
 171 
<span class="line-modified"> 172   gulong *called_probes;</span>
 173   guint n_called_probes;
 174   guint called_probes_size;
 175   gboolean retry;
 176 } ProbeMarshall;
 177 
 178 static void gst_pad_dispose (GObject * object);
 179 static void gst_pad_finalize (GObject * object);
 180 static void gst_pad_set_property (GObject * object, guint prop_id,
 181     const GValue * value, GParamSpec * pspec);
 182 static void gst_pad_get_property (GObject * object, guint prop_id,
 183     GValue * value, GParamSpec * pspec);
 184 
 185 static void gst_pad_set_pad_template (GstPad * pad, GstPadTemplate * templ);
 186 static gboolean gst_pad_activate_default (GstPad * pad, GstObject * parent);
 187 static GstFlowReturn gst_pad_chain_list_default (GstPad * pad,
 188     GstObject * parent, GstBufferList * list);
 189 
 190 static GstFlowReturn gst_pad_send_event_unchecked (GstPad * pad,
 191     GstEvent * event, GstPadProbeType type);
 192 static GstFlowReturn gst_pad_push_event_unchecked (GstPad * pad,
</pre>
<hr />
<pre>
 291     case GST_PAD_LINK_WRONG_DIRECTION:
 292       return &quot;wrong direction&quot;;
 293     case GST_PAD_LINK_NOFORMAT:
 294       return &quot;no common format&quot;;
 295     case GST_PAD_LINK_NOSCHED:
 296       return &quot;incompatible scheduling&quot;;
 297     case GST_PAD_LINK_REFUSED:
 298       return &quot;refused&quot;;
 299   }
 300   g_return_val_if_reached (&quot;unknown&quot;);
 301 }
 302 
 303 #define _do_init \
 304 { \
 305   gint i; \
 306   \
 307   buffer_quark = g_quark_from_static_string (&quot;buffer&quot;); \
 308   buffer_list_quark = g_quark_from_static_string (&quot;bufferlist&quot;); \
 309   event_quark = g_quark_from_static_string (&quot;event&quot;); \
 310   \
<span class="line-modified"> 311   for (i = 0; i &lt; G_N_ELEMENTS (flow_quarks); i++) {      \</span>
 312     flow_quarks[i].quark = g_quark_from_static_string (flow_quarks[i].name); \
 313   } \
 314   \
 315   GST_DEBUG_CATEGORY_INIT (debug_dataflow, &quot;GST_DATAFLOW&quot;, \
 316       GST_DEBUG_BOLD | GST_DEBUG_FG_GREEN, &quot;dataflow inside pads&quot;); \
 317 }
 318 
 319 #define gst_pad_parent_class parent_class
<span class="line-modified"> 320 G_DEFINE_TYPE_WITH_CODE (GstPad, gst_pad, GST_TYPE_OBJECT,</span>
<span class="line-added"> 321     G_ADD_PRIVATE (GstPad) _do_init);</span>
 322 
 323 static void
 324 gst_pad_class_init (GstPadClass * klass)
 325 {
 326   GObjectClass *gobject_class;
 327   GstObjectClass *gstobject_class;
 328 
 329   gobject_class = G_OBJECT_CLASS (klass);
 330   gstobject_class = GST_OBJECT_CLASS (klass);
 331 


 332   gobject_class-&gt;dispose = gst_pad_dispose;
 333   gobject_class-&gt;finalize = gst_pad_finalize;
 334   gobject_class-&gt;set_property = gst_pad_set_property;
 335   gobject_class-&gt;get_property = gst_pad_get_property;
 336 
 337   /**
 338    * GstPad::linked:
 339    * @pad: the pad that emitted the signal
 340    * @peer: the peer pad that has been connected
 341    *
 342    * Signals that a pad has been linked to the peer pad.
 343    */
 344   gst_pad_signals[PAD_LINKED] =
 345       g_signal_new (&quot;linked&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 346       G_STRUCT_OFFSET (GstPadClass, linked), NULL, NULL,
 347       g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_PAD);
 348   /**
 349    * GstPad::unlinked:
 350    * @pad: the pad that emitted the signal
 351    * @peer: the peer pad that has been disconnected
</pre>
<hr />
<pre>
 381    * Since: 1.6
 382    */
 383   g_object_class_install_property (gobject_class, PAD_PROP_OFFSET,
 384       g_param_spec_int64 (&quot;offset&quot;, &quot;Offset&quot;,
 385           &quot;The running time offset of the pad&quot;, 0, G_MAXINT64, 0,
 386           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 387 
 388   gstobject_class-&gt;path_string_separator = &quot;.&quot;;
 389 
 390   /* Register common function pointer descriptions */
 391   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_activate_default);
 392   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_event_default);
 393   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_query_default);
 394   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_iterate_internal_links_default);
 395   GST_DEBUG_REGISTER_FUNCPTR (gst_pad_chain_list_default);
 396 }
 397 
 398 static void
 399 gst_pad_init (GstPad * pad)
 400 {
<span class="line-modified"> 401   pad-&gt;priv = gst_pad_get_instance_private (pad);</span>
 402 
 403   GST_PAD_DIRECTION (pad) = GST_PAD_UNKNOWN;
 404 
 405   GST_PAD_ACTIVATEFUNC (pad) = gst_pad_activate_default;
 406   GST_PAD_EVENTFUNC (pad) = gst_pad_event_default;
 407   GST_PAD_QUERYFUNC (pad) = gst_pad_query_default;
 408   GST_PAD_ITERINTLINKFUNC (pad) = gst_pad_iterate_internal_links_default;
 409   GST_PAD_CHAINLISTFUNC (pad) = gst_pad_chain_list_default;
 410 
 411   GST_PAD_SET_FLUSHING (pad);
 412 
 413   g_rec_mutex_init (&amp;pad-&gt;stream_rec_lock);
 414 
 415   g_cond_init (&amp;pad-&gt;block_cond);
 416 
 417   g_hook_list_init (&amp;pad-&gt;probes, sizeof (GstProbe));
 418 
 419   pad-&gt;priv-&gt;events = g_array_sized_new (FALSE, TRUE, sizeof (PadEvent), 16);
 420   pad-&gt;priv-&gt;events_cookie = 0;
 421   pad-&gt;priv-&gt;last_cookie = -1;
</pre>
<hr />
<pre>
 584 events_foreach (GstPad * pad, PadEventFunction func, gpointer user_data)
 585 {
 586   guint i, len;
 587   GArray *events;
 588   gboolean ret;
 589   guint cookie;
 590 
 591   events = pad-&gt;priv-&gt;events;
 592 
 593 restart:
 594   cookie = pad-&gt;priv-&gt;events_cookie;
 595   i = 0;
 596   len = events-&gt;len;
 597   while (i &lt; len) {
 598     PadEvent *ev, ev_ret;
 599 
 600     ev = &amp;g_array_index (events, PadEvent, i);
 601     if (G_UNLIKELY (ev-&gt;event == NULL))
 602       goto next;
 603 
<span class="line-modified"> 604     /* take additional ref, func might release the lock */</span>
 605     ev_ret.event = gst_event_ref (ev-&gt;event);
 606     ev_ret.received = ev-&gt;received;
 607 
 608     ret = func (pad, &amp;ev_ret, user_data);
 609 
 610     /* recheck the cookie, lock might have been released and the list could have
 611      * changed */
 612     if (G_UNLIKELY (cookie != pad-&gt;priv-&gt;events_cookie)) {
 613       if (G_LIKELY (ev_ret.event))
 614         gst_event_unref (ev_ret.event);
 615       goto restart;
 616     }
 617 
 618     /* store the received state */
 619     ev-&gt;received = ev_ret.received;
 620 
 621     /* if the event changed, we need to do something */
 622     if (G_UNLIKELY (ev-&gt;event != ev_ret.event)) {
 623       if (G_UNLIKELY (ev_ret.event == NULL)) {
 624         /* function unreffed and set the event to NULL, remove it */
</pre>
<hr />
<pre>
 630       } else {
 631         /* function gave a new event for us */
 632         gst_event_take (&amp;ev-&gt;event, ev_ret.event);
 633       }
 634     } else {
 635       /* just unref, nothing changed */
 636       gst_event_unref (ev_ret.event);
 637     }
 638     if (!ret)
 639       break;
 640   next:
 641     i++;
 642   }
 643 }
 644 
 645 /* should be called with LOCK */
 646 static GstEvent *
 647 _apply_pad_offset (GstPad * pad, GstEvent * event, gboolean upstream,
 648     gint64 pad_offset)
 649 {
<span class="line-modified"> 650   gint64 offset;</span>
 651 
 652   GST_DEBUG_OBJECT (pad, &quot;apply pad offset %&quot; GST_STIME_FORMAT,
 653       GST_STIME_ARGS (pad_offset));
 654 
<span class="line-modified"> 655   if (GST_EVENT_TYPE (event) == GST_EVENT_SEGMENT) {</span>
<span class="line-modified"> 656     GstSegment segment;</span>
 657 
<span class="line-modified"> 658     g_assert (!upstream);</span>
 659 
<span class="line-modified"> 660     /* copy segment values */</span>
<span class="line-modified"> 661     gst_event_copy_segment (event, &amp;segment);</span>
<span class="line-modified"> 662     gst_event_unref (event);</span>
 663 
 664     gst_segment_offset_running_time (&amp;segment, segment.format, pad_offset);
<span class="line-modified"> 665     event = gst_event_new_segment (&amp;segment);</span>
<span class="line-modified"> 666   }</span>
 667 
<span class="line-modified"> 668   event = gst_event_make_writable (event);</span>
<span class="line-modified"> 669   offset = gst_event_get_running_time_offset (event);</span>
<span class="line-modified"> 670   if (upstream)</span>
 671     offset -= pad_offset;
<span class="line-modified"> 672   else</span>
 673     offset += pad_offset;
<span class="line-modified"> 674   gst_event_set_running_time_offset (event, offset);</span>
 675 
 676   return event;
<span class="line-modified"> 677 }</span>
 678 
 679 static inline GstEvent *
 680 apply_pad_offset (GstPad * pad, GstEvent * event, gboolean upstream)
 681 {
 682   if (G_UNLIKELY (pad-&gt;offset != 0))
 683     return _apply_pad_offset (pad, event, upstream, pad-&gt;offset);
 684   return event;
 685 }
 686 
 687 /* should be called with the OBJECT_LOCK */
 688 static GstCaps *
 689 get_pad_caps (GstPad * pad)
 690 {
 691   GstCaps *caps = NULL;
 692   PadEvent *ev;
 693 
 694   ev = find_event_by_type (pad, GST_EVENT_CAPS, 0);
 695   if (ev &amp;&amp; ev-&gt;event)
 696     gst_event_parse_caps (ev-&gt;event, &amp;caps);
 697 
</pre>
<hr />
<pre>
 815       break;
 816     case PAD_PROP_OFFSET:
 817       g_value_set_int64 (value, gst_pad_get_offset (GST_PAD_CAST (object)));
 818       break;
 819     default:
 820       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 821       break;
 822   }
 823 }
 824 
 825 /**
 826  * gst_pad_new:
 827  * @name: (allow-none): the name of the new pad.
 828  * @direction: the #GstPadDirection of the pad.
 829  *
 830  * Creates a new pad with the given name in the given direction.
 831  * If name is %NULL, a guaranteed unique name (across all pads)
 832  * will be assigned.
 833  * This function makes a copy of the name so you can safely free the name.
 834  *
<span class="line-modified"> 835  * Returns: (transfer floating): a new #GstPad.</span>

 836  *
 837  * MT safe.
 838  */
 839 GstPad *
 840 gst_pad_new (const gchar * name, GstPadDirection direction)
 841 {
 842   return g_object_new (GST_TYPE_PAD,
 843       &quot;name&quot;, name, &quot;direction&quot;, direction, NULL);
 844 }
 845 
 846 /**
 847  * gst_pad_new_from_template:
 848  * @templ: the pad template to use
 849  * @name: (allow-none): the name of the pad
 850  *
 851  * Creates a new pad with the given name from the given template.
 852  * If name is %NULL, a guaranteed unique name (across all pads)
 853  * will be assigned.
 854  * This function makes a copy of the name so you can safely free the name.
 855  *
<span class="line-modified"> 856  * Returns: (transfer floating): a new #GstPad.</span>

 857  */
 858 GstPad *
 859 gst_pad_new_from_template (GstPadTemplate * templ, const gchar * name)
 860 {
 861   GType pad_type =
 862       GST_PAD_TEMPLATE_GTYPE (templ) ==
 863       G_TYPE_NONE ? GST_TYPE_PAD : GST_PAD_TEMPLATE_GTYPE (templ);
 864 
 865   g_return_val_if_fail (GST_IS_PAD_TEMPLATE (templ), NULL);
 866 
 867   return g_object_new (pad_type,
 868       &quot;name&quot;, name, &quot;direction&quot;, templ-&gt;direction, &quot;template&quot;, templ, NULL);
 869 }
 870 
 871 /**
 872  * gst_pad_new_from_static_template:
 873  * @templ: the #GstStaticPadTemplate to use
 874  * @name: the name of the pad
 875  *
 876  * Creates a new pad with the given name from the given static template.
 877  * If name is %NULL, a guaranteed unique name (across all pads)
 878  * will be assigned.
 879  * This function makes a copy of the name so you can safely free the name.
 880  *
<span class="line-modified"> 881  * Returns: (transfer floating): a new #GstPad.</span>

 882  */
 883 GstPad *
 884 gst_pad_new_from_static_template (GstStaticPadTemplate * templ,
 885     const gchar * name)
 886 {
 887   GstPad *pad;
 888   GstPadTemplate *template;
 889 
 890   template = gst_static_pad_template_get (templ);
 891   pad = gst_pad_new_from_template (template, name);
 892   gst_object_unref (template);
 893   return pad;
 894 }
 895 
 896 #define ACQUIRE_PARENT(pad, parent, label)                      \
 897   G_STMT_START {                                                \
 898     if (G_LIKELY ((parent = GST_OBJECT_PARENT (pad))))          \
 899       gst_object_ref (parent);                                  \
 900     else if (G_LIKELY (GST_PAD_NEEDS_PARENT (pad)))             \
 901       goto label;                                               \
</pre>
<hr />
<pre>
1196         }
1197       } else {
1198         if (G_UNLIKELY (GST_PAD_GETRANGEFUNC (pad) == NULL))
1199           goto failure;         /* Can&#39;t activate pull on a src without a
1200                                    getrange function */
1201       }
1202       break;
1203     }
1204     default:
1205       break;
1206   }
1207 
1208   /* Mark pad as needing reconfiguration */
1209   if (active)
1210     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
1211 
1212   /* pre_activate returns TRUE if we weren&#39;t already in the process of
1213    * switching to the &#39;new&#39; mode */
1214   if (pre_activate (pad, new)) {
1215 
<span class="line-modified">1216     if (GST_PAD_ACTIVATEMODEFUNC (pad)) {</span>
<span class="line-modified">1217       if (G_UNLIKELY (!GST_PAD_ACTIVATEMODEFUNC (pad) (pad, parent, mode,</span>
<span class="line-modified">1218                   active)))</span>
<span class="line-modified">1219         goto failure;</span>
<span class="line-modified">1220     } else {</span>
<span class="line-modified">1221       /* can happen for sinks of passthrough elements */</span>
<span class="line-modified">1222     }</span>
1223 
<span class="line-modified">1224     post_activate (pad, new);</span>
1225   }
1226 
1227   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;%s in %s mode&quot;,
1228       active ? &quot;activated&quot; : &quot;deactivated&quot;, gst_pad_mode_get_name (mode));
1229 
1230 exit_success:
1231   res = TRUE;
1232 
1233   /* Clear sticky flags on deactivation */
1234   if (!active) {
1235     GST_OBJECT_LOCK (pad);
1236     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
1237     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_EOS);
1238     GST_OBJECT_UNLOCK (pad);
1239   }
1240 
1241 exit:
1242   return res;
1243 
1244 was_ok:
</pre>
<hr />
<pre>
1352  */
1353 gboolean
1354 gst_pad_is_active (GstPad * pad)
1355 {
1356   gboolean result = FALSE;
1357 
1358   g_return_val_if_fail (GST_IS_PAD (pad), FALSE);
1359 
1360   GST_OBJECT_LOCK (pad);
1361   result = GST_PAD_IS_ACTIVE (pad);
1362   GST_OBJECT_UNLOCK (pad);
1363 
1364   return result;
1365 }
1366 
1367 static void
1368 cleanup_hook (GstPad * pad, GHook * hook)
1369 {
1370   GstPadProbeType type;
1371 
<span class="line-added">1372   GST_DEBUG_OBJECT (pad,</span>
<span class="line-added">1373       &quot;cleaning up hook %lu with flags %08x&quot;, hook-&gt;hook_id, hook-&gt;flags);</span>
<span class="line-added">1374 </span>
1375   if (!G_HOOK_IS_VALID (hook))
1376     return;
1377 
1378   type = (hook-&gt;flags) &gt;&gt; G_HOOK_FLAG_USER_SHIFT;
1379 
1380   if (type &amp; GST_PAD_PROBE_TYPE_BLOCKING) {
1381     /* unblock when we remove the last blocking probe */
1382     pad-&gt;num_blocked--;
1383     GST_DEBUG_OBJECT (pad, &quot;remove blocking probe, now %d left&quot;,
1384         pad-&gt;num_blocked);
1385 
1386     /* Might have new probes now that want to be called */
1387     GST_PAD_BLOCK_BROADCAST (pad);
1388 
1389     if (pad-&gt;num_blocked == 0) {
1390       GST_DEBUG_OBJECT (pad, &quot;last blocking probe removed, unblocking&quot;);
1391       GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_BLOCKED);
1392     }
1393   }
1394   g_hook_destroy_link (&amp;pad-&gt;probes, hook);
</pre>
<hr />
<pre>
1423  */
1424 gulong
1425 gst_pad_add_probe (GstPad * pad, GstPadProbeType mask,
1426     GstPadProbeCallback callback, gpointer user_data,
1427     GDestroyNotify destroy_data)
1428 {
1429   GHook *hook;
1430   gulong res;
1431 
1432   g_return_val_if_fail (GST_IS_PAD (pad), 0);
1433   g_return_val_if_fail (mask != 0, 0);
1434 
1435   GST_OBJECT_LOCK (pad);
1436 
1437   /* make a new probe */
1438   hook = g_hook_alloc (&amp;pad-&gt;probes);
1439 
1440   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;adding probe for mask 0x%08x&quot;,
1441       mask);
1442 
<span class="line-modified">1443   /* when no constraints are given for the types, assume all types are</span>
1444    * acceptable */
1445   if ((mask &amp; _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH) == 0)
1446     mask |= GST_PAD_PROBE_TYPE_ALL_BOTH;
1447   if ((mask &amp; GST_PAD_PROBE_TYPE_SCHEDULING) == 0)
1448     mask |= GST_PAD_PROBE_TYPE_SCHEDULING;
1449 
1450   /* store our flags and other fields */
1451   hook-&gt;flags |= (mask &lt;&lt; G_HOOK_FLAG_USER_SHIFT);
1452   hook-&gt;func = callback;
1453   hook-&gt;data = user_data;
1454   hook-&gt;destroy = destroy_data;
1455 
1456   /* add the probe */
1457   g_hook_append (&amp;pad-&gt;probes, hook);
1458   pad-&gt;num_probes++;
<span class="line-modified">1459   /* incremenent cookie so that the new hook gets called */</span>
1460   pad-&gt;priv-&gt;probe_list_cookie++;
1461 
1462   /* get the id of the hook, we return this and it can be used to remove the
1463    * probe later */
1464   res = hook-&gt;hook_id;
1465 
1466   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;got probe id %lu&quot;, res);
1467 
1468   if (mask &amp; GST_PAD_PROBE_TYPE_BLOCKING) {
1469     /* we have a block probe */
1470     pad-&gt;num_blocked++;
1471     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_BLOCKED);
1472     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;added blocking probe, &quot;
1473         &quot;now %d blocking probes&quot;, pad-&gt;num_blocked);
1474 
1475     /* Might have new probes now that want to be called */
1476     GST_PAD_BLOCK_BROADCAST (pad);
1477   }
1478 
1479   /* call the callback if we need to be called for idle callbacks */
</pre>
<hr />
<pre>
2065       GST_DEBUG_FUNCPTR_NAME (link));
2066 }
2067 
2068 /**
2069  * gst_pad_set_unlink_function:
2070  * @p: a #GstPad.
2071  * @f: the #GstPadUnlinkFunction to set.
2072  *
2073  * Calls gst_pad_set_unlink_function_full() with %NULL
2074  * for the user_data and notify.
2075  */
2076 /**
2077  * gst_pad_set_unlink_function_full:
2078  * @pad: a #GstPad.
2079  * @unlink: the #GstPadUnlinkFunction to set.
2080  * @user_data: user_data passed to @notify
2081  * @notify: notify called when @unlink will not be used anymore.
2082  *
2083  * Sets the given unlink function for the pad. It will be called
2084  * when the pad is unlinked.
<span class="line-added">2085  *</span>
<span class="line-added">2086  * Note that the pad&#39;s lock is already held when the unlink</span>
<span class="line-added">2087  * function is called, so most pad functions cannot be called</span>
<span class="line-added">2088  * from within the callback.</span>
2089  */
2090 void
2091 gst_pad_set_unlink_function_full (GstPad * pad, GstPadUnlinkFunction unlink,
2092     gpointer user_data, GDestroyNotify notify)
2093 {
2094   g_return_if_fail (GST_IS_PAD (pad));
2095 
2096   if (pad-&gt;unlinknotify)
2097     pad-&gt;unlinknotify (pad-&gt;unlinkdata);
2098   GST_PAD_UNLINKFUNC (pad) = unlink;
2099   pad-&gt;unlinkdata = user_data;
2100   pad-&gt;unlinknotify = notify;
2101 
2102   GST_CAT_DEBUG_OBJECT (GST_CAT_PADS, pad, &quot;unlinkfunc set to %s&quot;,
2103       GST_DEBUG_FUNCPTR_NAME (unlink));
2104 }
2105 
2106 /**
2107  * gst_pad_unlink:
2108  * @srcpad: the source #GstPad to unlink.
</pre>
<hr />
<pre>
2569 
2570     /* we released the lock, check if the same pads are linked still */
2571     if (GST_PAD_PEER (srcpad) != sinkpad || GST_PAD_PEER (sinkpad) != srcpad)
2572       goto concurrent_link;
2573 
2574     if (G_UNLIKELY (result != GST_PAD_LINK_OK))
2575       goto link_failed;
2576   }
2577   GST_OBJECT_UNLOCK (sinkpad);
2578   GST_OBJECT_UNLOCK (srcpad);
2579 
2580   /* fire off a signal to each of the pads telling them
2581    * that they&#39;ve been linked */
2582   g_signal_emit (srcpad, gst_pad_signals[PAD_LINKED], 0, sinkpad);
2583   g_signal_emit (sinkpad, gst_pad_signals[PAD_LINKED], 0, srcpad);
2584 
2585   GST_CAT_INFO (GST_CAT_PADS, &quot;linked %s:%s and %s:%s, successful&quot;,
2586       GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad));
2587 
2588   if (!(flags &amp; GST_PAD_LINK_CHECK_NO_RECONFIGURE))
<span class="line-modified">2589     gst_pad_send_event (srcpad, gst_event_new_reconfigure ());</span>
2590 
2591 done:
2592   if (G_LIKELY (parent)) {
2593     gst_element_post_message (parent,
2594         gst_message_new_structure_change (GST_OBJECT_CAST (sinkpad),
2595             GST_STRUCTURE_CHANGE_TYPE_PAD_LINK, parent, FALSE));
2596     gst_object_unref (parent);
2597   }
2598 
2599   GST_TRACER_PAD_LINK_POST (srcpad, sinkpad, result);
2600   return result;
2601 
2602   /* ERRORS */
2603 concurrent_link:
2604   {
2605     GST_CAT_INFO (GST_CAT_PADS, &quot;concurrent link between %s:%s and %s:%s&quot;,
2606         GST_DEBUG_PAD_NAME (srcpad), GST_DEBUG_PAD_NAME (sinkpad));
2607     GST_OBJECT_UNLOCK (sinkpad);
2608     GST_OBJECT_UNLOCK (srcpad);
2609 
</pre>
<hr />
<pre>
3119 
3120 /* Default accept caps implementation just checks against
3121  * the allowed caps for the pad */
3122 static gboolean
3123 gst_pad_query_accept_caps_default (GstPad * pad, GstQuery * query)
3124 {
3125   /* get the caps and see if it intersects to something not empty */
3126   GstCaps *caps, *allowed = NULL;
3127   gboolean result;
3128 
3129   GST_DEBUG_OBJECT (pad, &quot;query accept-caps %&quot; GST_PTR_FORMAT, query);
3130 
3131   /* first forward the query to internally linked pads when we are dealing with
3132    * a PROXY CAPS */
3133   if (GST_PAD_IS_PROXY_CAPS (pad)) {
3134     result = gst_pad_proxy_query_accept_caps (pad, query);
3135     if (result)
3136       allowed = gst_pad_get_pad_template_caps (pad);
3137     else
3138       goto done;
<span class="line-modified">3139   }</span>
3140 
3141   gst_query_parse_accept_caps (query, &amp;caps);
3142   if (!allowed) {
3143     if (GST_PAD_IS_ACCEPT_TEMPLATE (pad)) {
3144       allowed = gst_pad_get_pad_template_caps (pad);
3145     } else {
<span class="line-modified">3146       GST_CAT_DEBUG_OBJECT (GST_CAT_PERFORMANCE, pad,</span>
<span class="line-modified">3147           &quot;fallback ACCEPT_CAPS query, consider implementing a specialized version&quot;);</span>
<span class="line-modified">3148       allowed = gst_pad_query_caps (pad, caps);</span>
3149     }
3150   }
3151 
3152   if (allowed) {
3153     if (GST_PAD_IS_ACCEPT_INTERSECT (pad)) {
3154       GST_DEBUG_OBJECT (pad,
3155           &quot;allowed caps intersect %&quot; GST_PTR_FORMAT &quot;, caps %&quot; GST_PTR_FORMAT,
3156           allowed, caps);
3157       result = gst_caps_can_intersect (caps, allowed);
3158     } else {
3159       GST_DEBUG_OBJECT (pad, &quot;allowed caps subset %&quot; GST_PTR_FORMAT &quot;, caps %&quot;
3160           GST_PTR_FORMAT, allowed, caps);
3161       result = gst_caps_is_subset (caps, allowed);
3162     }
3163     gst_caps_unref (allowed);
3164   } else {
3165     GST_DEBUG_OBJECT (pad, &quot;no compatible caps allowed on the pad&quot;);
3166     result = FALSE;
3167   }
3168   gst_query_set_accept_caps_result (query, result);
</pre>
<hr />
<pre>
3402 
3403   switch (GST_QUERY_TYPE (query)) {
3404     case GST_QUERY_SCHEDULING:
3405       forward = GST_PAD_IS_PROXY_SCHEDULING (pad);
3406       break;
3407     case GST_QUERY_ALLOCATION:
3408       forward = GST_PAD_IS_PROXY_ALLOCATION (pad);
3409       break;
3410     case GST_QUERY_ACCEPT_CAPS:
3411       ret = gst_pad_query_accept_caps_default (pad, query);
3412       forward = FALSE;
3413       break;
3414     case GST_QUERY_CAPS:
3415       ret = gst_pad_query_caps_default (pad, query);
3416       forward = FALSE;
3417       break;
3418     case GST_QUERY_LATENCY:
3419       ret = gst_pad_query_latency_default (pad, query);
3420       forward = FALSE;
3421       break;
<span class="line-added">3422     case GST_QUERY_BITRATE:</span>
<span class="line-added">3423       /* FIXME: better default handling */</span>
<span class="line-added">3424       forward = TRUE;</span>
<span class="line-added">3425       break;</span>
3426     case GST_QUERY_POSITION:
3427     case GST_QUERY_SEEKING:
3428     case GST_QUERY_FORMATS:
3429     case GST_QUERY_JITTER:
3430     case GST_QUERY_RATE:
3431     case GST_QUERY_CONVERT:
3432     default:
3433       forward = TRUE;
3434       break;
3435   }
3436 
3437   GST_DEBUG_OBJECT (pad, &quot;%sforwarding %p (%s) query&quot;, (forward ? &quot;&quot; : &quot;not &quot;),
3438       query, GST_QUERY_TYPE_NAME (query));
3439 
3440   if (forward) {
3441     QueryData data;
3442 
3443     data.query = query;
3444     data.dispatched = FALSE;
3445     data.result = FALSE;
</pre>
<hr />
<pre>
3459   return ret;
3460 }
3461 
3462 #define N_STACK_ALLOCATE_PROBES (16)
3463 
3464 static void
3465 probe_hook_marshal (GHook * hook, ProbeMarshall * data)
3466 {
3467   GstPad *pad = data-&gt;pad;
3468   GstPadProbeInfo *info = data-&gt;info;
3469   GstPadProbeType type, flags;
3470   GstPadProbeCallback callback;
3471   GstPadProbeReturn ret;
3472   gpointer original_data;
3473   guint i;
3474 
3475   /* if we have called this callback, do nothing. But only check
3476    * if we&#39;re actually calling probes a second time */
3477   if (data-&gt;retry) {
3478     for (i = 0; i &lt; data-&gt;n_called_probes; i++) {
<span class="line-modified">3479       if (data-&gt;called_probes[i] == hook-&gt;hook_id) {</span>
<span class="line-modified">3480         GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,</span>
3481             &quot;hook %lu already called&quot;, hook-&gt;hook_id);
<span class="line-modified">3482         return;</span>
<span class="line-modified">3483       }</span>
3484     }
3485   }
3486 
3487   /* reallocate on the heap if we had more than 16 probes */
3488   if (data-&gt;n_called_probes == data-&gt;called_probes_size) {
3489     if (data-&gt;called_probes_size &gt; N_STACK_ALLOCATE_PROBES) {
3490       data-&gt;called_probes_size *= 2;
3491       data-&gt;called_probes =
<span class="line-modified">3492           g_renew (gulong, data-&gt;called_probes, data-&gt;called_probes_size);</span>
3493     } else {
<span class="line-modified">3494       gulong *tmp = data-&gt;called_probes;</span>
3495 
3496       data-&gt;called_probes_size *= 2;
<span class="line-modified">3497       data-&gt;called_probes = g_new (gulong, data-&gt;called_probes_size);</span>
3498       memcpy (data-&gt;called_probes, tmp,
<span class="line-modified">3499           N_STACK_ALLOCATE_PROBES * sizeof (gulong));</span>
3500     }
3501   }
<span class="line-modified">3502   data-&gt;called_probes[data-&gt;n_called_probes++] = hook-&gt;hook_id;</span>
3503 
3504   flags = hook-&gt;flags &gt;&gt; G_HOOK_FLAG_USER_SHIFT;
3505   type = info-&gt;type;
3506   original_data = info-&gt;data;
3507 
3508   /* one of the scheduling types */
3509   if ((flags &amp; GST_PAD_PROBE_TYPE_SCHEDULING &amp; type) == 0)
3510     goto no_match;
3511 
3512   if (G_UNLIKELY (data-&gt;handled)) {
3513     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3514         &quot;probe previously returned HANDLED, not calling again&quot;);
3515     goto no_match;
3516   } else if (G_UNLIKELY (data-&gt;dropped)) {
3517     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3518         &quot;probe previously returned DROPPED, not calling again&quot;);
3519     goto no_match;
3520   }
3521 
3522   if (type &amp; GST_PAD_PROBE_TYPE_PUSH) {
<span class="line-modified">3523     /* one of the data types for non-idle probes */</span>
<span class="line-modified">3524     if ((type &amp; GST_PAD_PROBE_TYPE_IDLE) == 0</span>
3525         &amp;&amp; (flags &amp; _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH &amp; type) == 0)
<span class="line-modified">3526       goto no_match;</span>
3527   } else if (type &amp; GST_PAD_PROBE_TYPE_PULL) {
3528     /* one of the data types for non-idle probes */
3529     if ((type &amp; GST_PAD_PROBE_TYPE_BLOCKING) == 0
3530         &amp;&amp; (flags &amp; _PAD_PROBE_TYPE_ALL_BOTH_AND_FLUSH &amp; type) == 0)
<span class="line-modified">3531       goto no_match;</span>
3532   } else {
3533     /* Type must have PULL or PUSH probe types */
3534     g_assert_not_reached ();
3535   }
3536 
3537   /* one of the blocking types must match */
3538   if ((type &amp; GST_PAD_PROBE_TYPE_BLOCKING) &amp;&amp;
3539       (flags &amp; GST_PAD_PROBE_TYPE_BLOCKING &amp; type) == 0)
3540     goto no_match;
3541   if ((type &amp; GST_PAD_PROBE_TYPE_BLOCKING) == 0 &amp;&amp;
3542       (flags &amp; GST_PAD_PROBE_TYPE_BLOCKING))
3543     goto no_match;
3544   /* only probes that have GST_PAD_PROBE_TYPE_EVENT_FLUSH set */
3545   if ((type &amp; GST_PAD_PROBE_TYPE_EVENT_FLUSH) &amp;&amp;
3546       (flags &amp; GST_PAD_PROBE_TYPE_EVENT_FLUSH &amp; type) == 0)
3547     goto no_match;
3548 
3549   GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3550       &quot;hook %lu with flags 0x%08x matches&quot;, hook-&gt;hook_id, flags);
3551 
3552   data-&gt;marshalled = TRUE;
3553 
3554   callback = (GstPadProbeCallback) hook-&gt;func;
3555   if (callback == NULL)
3556     return;
3557 
3558   info-&gt;id = hook-&gt;hook_id;
3559 
3560   if ((flags &amp; GST_PAD_PROBE_TYPE_IDLE))
3561     pad-&gt;priv-&gt;idle_running++;
3562 
3563   GST_OBJECT_UNLOCK (pad);
3564 
3565   ret = callback (pad, info, hook-&gt;data);
3566 
3567   GST_OBJECT_LOCK (pad);
3568 
3569   if ((flags &amp; GST_PAD_PROBE_TYPE_IDLE))
3570     pad-&gt;priv-&gt;idle_running--;
3571 
<span class="line-modified">3572   if (ret != GST_PAD_PROBE_HANDLED &amp;&amp; original_data != NULL</span>
<span class="line-added">3573       &amp;&amp; info-&gt;data == NULL) {</span>
3574     GST_DEBUG_OBJECT (pad, &quot;data item in pad probe info was dropped&quot;);
3575     info-&gt;type = GST_PAD_PROBE_TYPE_INVALID;
3576     data-&gt;dropped = TRUE;
3577   }
3578 
3579   switch (ret) {
3580     case GST_PAD_PROBE_REMOVE:
3581       /* remove the probe */
3582       GST_DEBUG_OBJECT (pad, &quot;asked to remove hook&quot;);
3583       cleanup_hook (pad, hook);
3584       break;
3585     case GST_PAD_PROBE_DROP:
3586       /* need to drop the data, make sure other probes don&#39;t get called
3587        * anymore */
3588       GST_DEBUG_OBJECT (pad, &quot;asked to drop item&quot;);
3589       info-&gt;type = GST_PAD_PROBE_TYPE_INVALID;
3590       data-&gt;dropped = TRUE;
3591       break;
3592     case GST_PAD_PROBE_HANDLED:
3593       GST_DEBUG_OBJECT (pad, &quot;probe handled data&quot;);
</pre>
<hr />
<pre>
3601     case GST_PAD_PROBE_OK:
3602       GST_DEBUG_OBJECT (pad, &quot;probe returned OK&quot;);
3603       break;
3604     default:
3605       GST_DEBUG_OBJECT (pad, &quot;probe returned %d&quot;, ret);
3606       break;
3607   }
3608   return;
3609 
3610 no_match:
3611   {
3612     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3613         &quot;hook %lu with flags 0x%08x does not match %08x&quot;,
3614         hook-&gt;hook_id, flags, info-&gt;type);
3615     return;
3616   }
3617 }
3618 
3619 /* a probe that does not take or return any data */
3620 #define PROBE_NO_DATA(pad,mask,label,defaultval)                \
<span class="line-modified">3621   G_STMT_START {            \</span>
<span class="line-modified">3622     if (G_UNLIKELY (pad-&gt;num_probes)) {       \</span>
<span class="line-modified">3623       GstFlowReturn pval = defaultval;        \</span>
3624       /* pass NULL as the data item */                          \
<span class="line-modified">3625       GstPadProbeInfo info = { mask, 0, NULL, 0, 0 };   \</span>
<span class="line-modified">3626       info.ABI.abi.flow_ret = defaultval;     \</span>
<span class="line-modified">3627       ret = do_probe_callbacks (pad, &amp;info, defaultval);  \</span>
<span class="line-modified">3628       if (G_UNLIKELY (ret != pval &amp;&amp; ret != GST_FLOW_OK)) \</span>
<span class="line-modified">3629         goto label;           \</span>
<span class="line-modified">3630     }               \</span>
3631   } G_STMT_END
3632 
3633 #define PROBE_FULL(pad,mask,data,offs,size,label,handleable,handle_label) \
<span class="line-modified">3634   G_STMT_START {              \</span>
<span class="line-modified">3635     if (G_UNLIKELY (pad-&gt;num_probes)) {         \</span>
<span class="line-modified">3636       /* pass the data item */            \</span>
<span class="line-modified">3637       GstPadProbeInfo info = { mask, 0, data, offs, size };   \</span>
<span class="line-modified">3638       info.ABI.abi.flow_ret = GST_FLOW_OK;        \</span>
<span class="line-modified">3639       ret = do_probe_callbacks (pad, &amp;info, GST_FLOW_OK);   \</span>
<span class="line-modified">3640       /* store the possibly updated data item */      \</span>
<span class="line-modified">3641       data = GST_PAD_PROBE_INFO_DATA (&amp;info);       \</span>
<span class="line-modified">3642       /* if something went wrong, exit */       \</span>
<span class="line-modified">3643       if (G_UNLIKELY (ret != GST_FLOW_OK)) {        \</span>
<span class="line-modified">3644   if (handleable &amp;&amp; ret == GST_FLOW_CUSTOM_SUCCESS_1) {   \</span>
<span class="line-modified">3645     ret = info.ABI.abi.flow_ret;            \</span>
<span class="line-modified">3646     goto handle_label;            \</span>
<span class="line-modified">3647   }               \</span>
<span class="line-modified">3648   goto label;             \</span>
<span class="line-modified">3649       }                 \</span>
<span class="line-modified">3650     }                 \</span>
3651   } G_STMT_END
3652 
<span class="line-modified">3653 #define PROBE_PUSH(pad,mask,data,label)   \</span>
3654   PROBE_FULL(pad, mask, data, -1, -1, label, FALSE, label);
3655 #define PROBE_HANDLE(pad,mask,data,label,handle_label)  \
3656   PROBE_FULL(pad, mask, data, -1, -1, label, TRUE, handle_label);
<span class="line-modified">3657 #define PROBE_PULL(pad,mask,data,offs,size,label)   \</span>
3658   PROBE_FULL(pad, mask, data, offs, size, label, FALSE, label);
3659 
3660 static GstFlowReturn
3661 do_pad_idle_probe_wait (GstPad * pad)
3662 {
3663   while (GST_PAD_IS_RUNNING_IDLE_PROBE (pad)) {
3664     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
3665         &quot;waiting idle probe to be removed&quot;);
3666     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_BLOCKING);
3667     GST_PAD_BLOCK_WAIT (pad);
3668     GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_BLOCKING);
3669     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad, &quot;We got unblocked&quot;);
3670 
3671     if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
3672       return GST_FLOW_FLUSHING;
3673   }
3674   return GST_FLOW_OK;
3675 }
3676 
3677 #define PROBE_TYPE_IS_SERIALIZED(i) \
</pre>
<hr />
<pre>
3679       ( \
3680         (((i)-&gt;type &amp; (GST_PAD_PROBE_TYPE_EVENT_DOWNSTREAM | \
3681         GST_PAD_PROBE_TYPE_EVENT_FLUSH)) &amp;&amp; \
3682         GST_EVENT_IS_SERIALIZED ((i)-&gt;data)) \
3683       ) || ( \
3684         (((i)-&gt;type &amp; GST_PAD_PROBE_TYPE_QUERY_DOWNSTREAM) &amp;&amp; \
3685         GST_QUERY_IS_SERIALIZED ((i)-&gt;data)) \
3686       ) || ( \
3687         ((i)-&gt;type &amp; (GST_PAD_PROBE_TYPE_BUFFER | \
3688         GST_PAD_PROBE_TYPE_BUFFER_LIST))  \
3689       ) \
3690     )
3691 
3692 static GstFlowReturn
3693 do_probe_callbacks (GstPad * pad, GstPadProbeInfo * info,
3694     GstFlowReturn defaultval)
3695 {
3696   ProbeMarshall data;
3697   guint cookie;
3698   gboolean is_block;
<span class="line-modified">3699   gulong called_probes[N_STACK_ALLOCATE_PROBES];</span>
3700 
3701   data.pad = pad;
3702   data.info = info;
3703   data.pass = FALSE;
3704   data.handled = FALSE;
3705   data.marshalled = FALSE;
3706   data.dropped = FALSE;
3707 
3708   /* We stack-allocate for N_STACK_ALLOCATE_PROBES hooks as a first step. If more are needed,
3709    * we will re-allocate with g_malloc(). This should usually never be needed
3710    */
3711   data.called_probes = called_probes;
3712   data.n_called_probes = 0;
3713   data.called_probes_size = N_STACK_ALLOCATE_PROBES;
3714   data.retry = FALSE;
3715 
3716   is_block =
3717       (info-&gt;type &amp; GST_PAD_PROBE_TYPE_BLOCK) == GST_PAD_PROBE_TYPE_BLOCK;
3718 
3719   if (is_block &amp;&amp; PROBE_TYPE_IS_SERIALIZED (info)) {
</pre>
<hr />
<pre>
3806   {
3807     GST_DEBUG_OBJECT (pad, &quot;data is dropped&quot;);
3808     if (data.called_probes_size &gt; N_STACK_ALLOCATE_PROBES)
3809       g_free (data.called_probes);
3810     return GST_FLOW_CUSTOM_SUCCESS;
3811   }
3812 passed:
3813   {
3814     /* FIXME : Should we return FLOW_OK or the defaultval ?? */
3815     GST_DEBUG_OBJECT (pad, &quot;data is passed&quot;);
3816     if (data.called_probes_size &gt; N_STACK_ALLOCATE_PROBES)
3817       g_free (data.called_probes);
3818     return GST_FLOW_OK;
3819   }
3820 handled:
3821   {
3822     GST_DEBUG_OBJECT (pad, &quot;data was handled&quot;);
3823     if (data.called_probes_size &gt; N_STACK_ALLOCATE_PROBES)
3824       g_free (data.called_probes);
3825     return GST_FLOW_CUSTOM_SUCCESS_1;
<span class="line-modified">3826   }</span>
3827 }
3828 
3829 /* pad offsets */
3830 
3831 /**
3832  * gst_pad_get_offset:
3833  * @pad: a #GstPad
3834  *
3835  * Get the offset applied to the running time of @pad. @pad has to be a source
3836  * pad.
3837  *
3838  * Returns: the offset.
3839  */
3840 gint64
3841 gst_pad_get_offset (GstPad * pad)
3842 {
3843   gint64 result;
3844 
3845   g_return_val_if_fail (GST_IS_PAD (pad), 0);
3846 
</pre>
<hr />
<pre>
4371     return GST_FLOW_EOS;
4372   }
4373 wrong_mode:
4374   {
4375     g_critical (&quot;chain on pad %s:%s but it was not in push mode&quot;,
4376         GST_DEBUG_PAD_NAME (pad));
4377     GST_OBJECT_UNLOCK (pad);
4378     GST_PAD_STREAM_UNLOCK (pad);
4379     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4380     return GST_FLOW_ERROR;
4381   }
4382 probe_handled:
4383   handled = TRUE;
4384   /* PASSTHROUGH */
4385 probe_stopped:
4386   {
4387     GST_OBJECT_UNLOCK (pad);
4388     GST_PAD_STREAM_UNLOCK (pad);
4389     /* We unref the buffer, except if the probe handled it (CUSTOM_SUCCESS_1) */
4390     if (!handled)
<span class="line-modified">4391       gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));</span>
4392 
4393     switch (ret) {
4394       case GST_FLOW_CUSTOM_SUCCESS:
4395       case GST_FLOW_CUSTOM_SUCCESS_1:
4396         GST_DEBUG_OBJECT (pad, &quot;dropped or handled buffer&quot;);
4397         ret = GST_FLOW_OK;
4398         break;
4399       default:
4400         GST_DEBUG_OBJECT (pad, &quot;an error occurred %s&quot;, gst_flow_get_name (ret));
4401         break;
4402     }
4403     return ret;
4404   }
4405 no_parent:
4406   {
4407     GST_DEBUG_OBJECT (pad, &quot;No parent when chaining %&quot; GST_PTR_FORMAT, data);
4408     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4409     GST_OBJECT_UNLOCK (pad);
4410     GST_PAD_STREAM_UNLOCK (pad);
4411     return GST_FLOW_FLUSHING;
</pre>
<hr />
<pre>
4624     GST_OBJECT_UNLOCK (pad);
4625     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4626     return GST_FLOW_ERROR;
4627   }
4628 events_error:
4629   {
4630     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4631         &quot;error pushing events, return %s&quot;, gst_flow_get_name (ret));
4632     pad-&gt;ABI.abi.last_flowret = ret;
4633     GST_OBJECT_UNLOCK (pad);
4634     gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));
4635     return ret;
4636   }
4637 probe_handled:
4638   handled = TRUE;
4639   /* PASSTHROUGH */
4640 probe_stopped:
4641   {
4642     GST_OBJECT_UNLOCK (pad);
4643     if (data != NULL &amp;&amp; !handled)
<span class="line-modified">4644       gst_mini_object_unref (GST_MINI_OBJECT_CAST (data));</span>
4645 
4646     switch (ret) {
4647       case GST_FLOW_CUSTOM_SUCCESS:
4648       case GST_FLOW_CUSTOM_SUCCESS_1:
4649         GST_DEBUG_OBJECT (pad, &quot;dropped or handled buffer&quot;);
4650         ret = GST_FLOW_OK;
4651         break;
4652       default:
4653         GST_DEBUG_OBJECT (pad, &quot;an error occurred %s&quot;, gst_flow_get_name (ret));
4654         break;
4655     }
4656     pad-&gt;ABI.abi.last_flowret = ret;
4657     return ret;
4658   }
4659 not_linked:
4660   {
4661     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
4662         &quot;pushing, but it was not linked&quot;);
4663     pad-&gt;ABI.abi.last_flowret = GST_FLOW_NOT_LINKED;
4664     GST_OBJECT_UNLOCK (pad);
</pre>
<hr />
<pre>
5116     goto done;
5117   }
5118 probe_stopped_unref:
5119   {
5120     GST_CAT_LOG_OBJECT (GST_CAT_SCHEDULING, pad,
5121         &quot;post probe returned %s&quot;, gst_flow_get_name (ret));
5122 
5123     /* if we drop here, it signals EOS */
5124     if (ret == GST_FLOW_CUSTOM_SUCCESS)
5125       ret = GST_FLOW_EOS;
5126 
5127     pad-&gt;ABI.abi.last_flowret = ret;
5128     GST_OBJECT_UNLOCK (pad);
5129 
5130     if (*buffer == NULL)
5131       gst_buffer_unref (res_buf);
5132     goto done;
5133   }
5134 done:
5135   GST_TRACER_PAD_PULL_RANGE_POST (pad, NULL, ret);
<span class="line-modified">5136   return ret;</span>
<span class="line-modified">5137 }</span>
5138 
5139 /* must be called with pad object lock */
5140 static GstFlowReturn
5141 store_sticky_event (GstPad * pad, GstEvent * event)
5142 {
5143   guint i, len;
5144   GstEventType type;
5145   GArray *events;
5146   gboolean res = FALSE;
5147   const gchar *name = NULL;
5148   gboolean insert = TRUE;
5149 
5150   type = GST_EVENT_TYPE (event);
5151 
5152   /* Store all sticky events except SEGMENT/EOS when we&#39;re flushing,
5153    * otherwise they can be dropped and nothing would ever resend them.
5154    * Only do that for activated pads though, everything else is a bug!
5155    */
5156   if (G_UNLIKELY (GST_PAD_MODE (pad) == GST_PAD_MODE_NONE
5157           || (GST_PAD_IS_FLUSHING (pad) &amp;&amp; (type == GST_EVENT_SEGMENT
</pre>
<hr />
<pre>
5427   }
5428   return ret;
5429 
5430   /* ERROR handling */
5431 flushed:
5432   {
5433     GST_DEBUG_OBJECT (pad, &quot;We&#39;re flushing&quot;);
5434     gst_event_unref (event);
5435     return GST_FLOW_FLUSHING;
5436   }
5437 inactive:
5438   {
5439     GST_DEBUG_OBJECT (pad, &quot;flush-stop on inactive pad&quot;);
5440     gst_event_unref (event);
5441     return GST_FLOW_FLUSHING;
5442   }
5443 probe_stopped:
5444   {
5445     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
5446     if (ret != GST_FLOW_CUSTOM_SUCCESS_1)
<span class="line-modified">5447       gst_event_unref (event);</span>
5448 
5449     switch (ret) {
5450       case GST_FLOW_CUSTOM_SUCCESS_1:
5451         GST_DEBUG_OBJECT (pad, &quot;handled event&quot;);
5452         break;
5453       case GST_FLOW_CUSTOM_SUCCESS:
5454         GST_DEBUG_OBJECT (pad, &quot;dropped event&quot;);
5455         break;
5456       default:
5457         GST_DEBUG_OBJECT (pad, &quot;an error occurred %s&quot;, gst_flow_get_name (ret));
5458         break;
5459     }
5460     return ret;
5461   }
5462 not_linked:
5463   {
5464     GST_DEBUG_OBJECT (pad, &quot;Dropping event %s because pad is not linked&quot;,
5465         gst_event_type_get_name (GST_EVENT_TYPE (event)));
5466     GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_PENDING_EVENTS);
5467     gst_event_unref (event);
</pre>
<hr />
<pre>
5577     g_warning (&quot;pad %s:%s has invalid direction&quot;, GST_DEBUG_PAD_NAME (pad));
5578     gst_event_unref (event);
5579     goto done;
5580   }
5581 flushed:
5582   {
5583     GST_DEBUG_OBJECT (pad, &quot;We&#39;re flushing&quot;);
5584     GST_OBJECT_UNLOCK (pad);
5585     gst_event_unref (event);
5586     goto done;
5587   }
5588 eos:
5589   {
5590     GST_DEBUG_OBJECT (pad, &quot;We&#39;re EOS&quot;);
5591     GST_OBJECT_UNLOCK (pad);
5592     gst_event_unref (event);
5593     goto done;
5594   }
5595 done:
5596   GST_TRACER_PAD_PUSH_EVENT_POST (pad, FALSE);
<span class="line-modified">5597   return FALSE;</span>
<span class="line-modified">5598 }</span>
5599 
5600 /* Check if we can call the event function with the given event */
5601 static GstFlowReturn
5602 pre_eventfunc_check (GstPad * pad, GstEvent * event)
5603 {
5604   GstCaps *caps;
5605 
5606   switch (GST_EVENT_TYPE (event)) {
5607     case GST_EVENT_CAPS:
5608     {
5609       /* backwards compatibility mode for caps */
5610       gst_event_parse_caps (event, &amp;caps);
5611 
5612       if (!gst_pad_query_accept_caps (pad, caps))
5613         goto not_accepted;
5614       break;
5615     }
5616     default:
5617       break;
5618   }
</pre>
<hr />
<pre>
5655       GST_CAT_DEBUG_OBJECT (GST_CAT_EVENT, pad,
5656           &quot;have event type %d (FLUSH_START)&quot;, GST_EVENT_TYPE (event));
5657 
5658       /* can&#39;t even accept a flush begin event when flushing */
5659       if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
5660         goto flushing;
5661 
5662       GST_PAD_SET_FLUSHING (pad);
5663       GST_CAT_DEBUG_OBJECT (GST_CAT_EVENT, pad, &quot;set flush flag&quot;);
5664       GST_PAD_BLOCK_BROADCAST (pad);
5665       type |= GST_PAD_PROBE_TYPE_EVENT_FLUSH;
5666       break;
5667     case GST_EVENT_FLUSH_STOP:
5668       /* we can&#39;t accept flush-stop on inactive pads else the flushing flag
5669        * would be cleared and it would look like the pad can accept data.
5670        * Also, some elements restart a streaming thread in flush-stop which we
5671        * can&#39;t allow on inactive pads */
5672       if (G_UNLIKELY (!GST_PAD_IS_ACTIVE (pad)))
5673         goto inactive;
5674 
<span class="line-modified">5675       GST_PAD_UNSET_FLUSHING (pad);</span>
<span class="line-modified">5676       GST_CAT_DEBUG_OBJECT (GST_CAT_EVENT, pad, &quot;cleared flush flag&quot;);</span>
5677       /* Remove pending EOS events */
5678       GST_LOG_OBJECT (pad, &quot;Removing pending EOS and SEGMENT events&quot;);
5679       remove_event_by_type (pad, GST_EVENT_EOS);
5680       remove_event_by_type (pad, GST_EVENT_STREAM_GROUP_DONE);
5681       remove_event_by_type (pad, GST_EVENT_SEGMENT);
5682       GST_OBJECT_FLAG_UNSET (pad, GST_PAD_FLAG_EOS);
5683       pad-&gt;ABI.abi.last_flowret = GST_FLOW_OK;
5684 
5685       GST_OBJECT_UNLOCK (pad);
5686       /* grab stream lock */
5687       GST_PAD_STREAM_LOCK (pad);
5688       need_unlock = TRUE;
5689       GST_OBJECT_LOCK (pad);
5690       if (G_UNLIKELY (GST_PAD_IS_FLUSHING (pad)))
5691         goto flushing;
5692       break;
5693     case GST_EVENT_RECONFIGURE:
5694       if (GST_PAD_IS_SRC (pad))
5695         GST_OBJECT_FLAG_SET (pad, GST_PAD_FLAG_NEED_RECONFIGURE);
5696     default:
</pre>
<hr />
<pre>
5824     gst_event_unref (event);
5825     return GST_FLOW_FLUSHING;
5826   }
5827 eos:
5828   {
5829     GST_OBJECT_UNLOCK (pad);
5830     if (need_unlock)
5831       GST_PAD_STREAM_UNLOCK (pad);
5832     GST_CAT_INFO_OBJECT (GST_CAT_EVENT, pad,
5833         &quot;Received event on EOS pad. Discarding&quot;);
5834     gst_event_unref (event);
5835     return GST_FLOW_EOS;
5836   }
5837 probe_stopped:
5838   {
5839     GST_OBJECT_UNLOCK (pad);
5840     if (need_unlock)
5841       GST_PAD_STREAM_UNLOCK (pad);
5842     /* Only unref if unhandled */
5843     if (ret != GST_FLOW_CUSTOM_SUCCESS_1)
<span class="line-modified">5844       gst_event_unref (event);</span>
5845 
5846     switch (ret) {
5847       case GST_FLOW_CUSTOM_SUCCESS_1:
5848       case GST_FLOW_CUSTOM_SUCCESS:
5849         GST_DEBUG_OBJECT (pad, &quot;dropped or handled event&quot;);
5850         ret = GST_FLOW_OK;
5851         break;
5852       default:
5853         GST_DEBUG_OBJECT (pad, &quot;an error occurred %s&quot;, gst_flow_get_name (ret));
5854         break;
5855     }
5856     return ret;
5857   }
5858 no_function:
5859   {
5860     g_warning (&quot;pad %s:%s has no event handler, file a bug.&quot;,
5861         GST_DEBUG_PAD_NAME (pad));
5862     GST_OBJECT_UNLOCK (pad);
5863     if (need_unlock)
5864       GST_PAD_STREAM_UNLOCK (pad);
</pre>
</td>
</tr>
</table>
<center><a href="gstobject.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstpad.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>