<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gtype.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gtype-private.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gtype.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gtype.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -37,11 +37,11 @@</span>
  #ifdef G_OS_WIN32
  #include &lt;windows.h&gt;
  #endif
  
  #ifdef  G_ENABLE_DEBUG
<span class="udiff-line-modified-removed">- #define IF_DEBUG(debug_type)    if (_g_type_debug_flags &amp; G_TYPE_DEBUG_ ## debug_type)</span>
<span class="udiff-line-modified-added">+ #define IF_DEBUG(debug_type)  if (_g_type_debug_flags &amp; G_TYPE_DEBUG_ ## debug_type)</span>
  #endif
  
  /**
   * SECTION:gtype
   * @short_description: The GLib Runtime type identification and
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -98,21 +98,21 @@</span>
   *
   * LOCKING:
   * lock handling issues when calling static functions are indicated by
   * uppercase letter postfixes, all static functions have to have
   * one of the below postfixes:
<span class="udiff-line-modified-removed">-  * - _I:    [Indifferent about locking]</span>
<span class="udiff-line-modified-added">+  * - _I:  [Indifferent about locking]</span>
   *   function doesn&#39;t care about locks at all
<span class="udiff-line-modified-removed">-  * - _U:    [Unlocked invocation]</span>
<span class="udiff-line-modified-added">+  * - _U:  [Unlocked invocation]</span>
   *   no read or write lock has to be held across function invocation
   *   (locks may be acquired and released during invocation though)
<span class="udiff-line-modified-removed">-  * - _L:    [Locked invocation]</span>
<span class="udiff-line-modified-added">+  * - _L:  [Locked invocation]</span>
   *   a write lock or more than 0 read locks have to be held across
   *   function invocation
<span class="udiff-line-modified-removed">-  * - _W:    [Write-locked invocation]</span>
<span class="udiff-line-modified-added">+  * - _W:  [Write-locked invocation]</span>
   *   a write lock has to be held across function invocation
<span class="udiff-line-modified-removed">-  * - _Wm:   [Write-locked invocation, mutatable]</span>
<span class="udiff-line-modified-added">+  * - _Wm: [Write-locked invocation, mutatable]</span>
   *   like _W, but the write lock might be released and reacquired
   *   during invocation, watch your pointers
   * - _WmREC:    [Write-locked invocation, mutatable, recursive]
   *   like _Wm, but also acquires recursive mutex class_init_rec_mutex
   */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -138,16 +138,16 @@</span>
  }G_STMT_END
  #define g_assert_type_system_initialized() \
    g_assert (static_quark_type_flags)
  
  #define TYPE_FUNDAMENTAL_FLAG_MASK (G_TYPE_FLAG_CLASSED | \
<span class="udiff-line-modified-removed">-                     G_TYPE_FLAG_INSTANTIATABLE | \</span>
<span class="udiff-line-modified-removed">-                     G_TYPE_FLAG_DERIVABLE | \</span>
<span class="udiff-line-modified-removed">-                     G_TYPE_FLAG_DEEP_DERIVABLE)</span>
<span class="udiff-line-modified-removed">- #define TYPE_FLAG_MASK         (G_TYPE_FLAG_ABSTRACT | G_TYPE_FLAG_VALUE_ABSTRACT)</span>
<span class="udiff-line-modified-added">+             G_TYPE_FLAG_INSTANTIATABLE | \</span>
<span class="udiff-line-modified-added">+             G_TYPE_FLAG_DERIVABLE | \</span>
<span class="udiff-line-modified-added">+             G_TYPE_FLAG_DEEP_DERIVABLE)</span>
<span class="udiff-line-modified-added">+ #define TYPE_FLAG_MASK       (G_TYPE_FLAG_ABSTRACT | G_TYPE_FLAG_VALUE_ABSTRACT)</span>
  #define SIZEOF_FUNDAMENTAL_INFO    ((gssize) MAX (MAX (sizeof (GTypeFundamentalInfo), \
<span class="udiff-line-modified-removed">-                                sizeof (gpointer)), \</span>
<span class="udiff-line-modified-added">+                    sizeof (gpointer)), \</span>
                                                    sizeof (glong)))
  
  /* The 2*sizeof(size_t) alignment here is borrowed from
   * GNU libc, so it should be good most everywhere.
   * It is more conservative than is needed on some 64-bit
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -173,34 +173,34 @@</span>
  typedef struct _IFaceEntry      IFaceEntry;
  typedef struct _IFaceHolder IFaceHolder;
  
  
  /* --- prototypes --- */
<span class="udiff-line-modified-removed">- static inline GTypeFundamentalInfo* type_node_fundamental_info_I    (TypeNode       *node);</span>
<span class="udiff-line-modified-removed">- static        void          type_add_flags_W        (TypeNode       *node,</span>
<span class="udiff-line-modified-removed">-                                      GTypeFlags      flags);</span>
<span class="udiff-line-modified-removed">- static        void          type_data_make_W        (TypeNode       *node,</span>
<span class="udiff-line-modified-removed">-                                      const GTypeInfo    *info,</span>
<span class="udiff-line-modified-removed">-                                      const GTypeValueTable  *value_table);</span>
<span class="udiff-line-modified-removed">- static inline void          type_data_ref_Wm        (TypeNode       *node);</span>
<span class="udiff-line-modified-removed">- static inline void          type_data_unref_U               (TypeNode       *node,</span>
<span class="udiff-line-modified-removed">-                                      gboolean        uncached);</span>
<span class="udiff-line-modified-removed">- static void             type_data_last_unref_Wm     (TypeNode *              node,</span>
<span class="udiff-line-modified-removed">-                                      gboolean        uncached);</span>
<span class="udiff-line-modified-removed">- static inline gpointer          type_get_qdata_L        (TypeNode       *node,</span>
<span class="udiff-line-modified-removed">-                                      GQuark          quark);</span>
<span class="udiff-line-modified-removed">- static inline void          type_set_qdata_W        (TypeNode       *node,</span>
<span class="udiff-line-modified-removed">-                                      GQuark          quark,</span>
<span class="udiff-line-modified-removed">-                                      gpointer        data);</span>
<span class="udiff-line-modified-removed">- static IFaceHolder*         type_iface_peek_holder_L    (TypeNode       *iface,</span>
<span class="udiff-line-modified-removed">-                                      GType           instance_type);</span>
<span class="udiff-line-modified-added">+ static inline GTypeFundamentalInfo* type_node_fundamental_info_I  (TypeNode   *node);</span>
<span class="udiff-line-modified-added">+ static        void      type_add_flags_W    (TypeNode   *node,</span>
<span class="udiff-line-modified-added">+                    GTypeFlags    flags);</span>
<span class="udiff-line-modified-added">+ static        void      type_data_make_W    (TypeNode   *node,</span>
<span class="udiff-line-modified-added">+                    const GTypeInfo  *info,</span>
<span class="udiff-line-modified-added">+                    const GTypeValueTable  *value_table);</span>
<span class="udiff-line-modified-added">+ static inline void      type_data_ref_Wm    (TypeNode   *node);</span>
<span class="udiff-line-modified-added">+ static inline void      type_data_unref_U               (TypeNode   *node,</span>
<span class="udiff-line-modified-added">+                    gboolean    uncached);</span>
<span class="udiff-line-modified-added">+ static void       type_data_last_unref_Wm   (TypeNode *              node,</span>
<span class="udiff-line-modified-added">+                    gboolean    uncached);</span>
<span class="udiff-line-modified-added">+ static inline gpointer      type_get_qdata_L    (TypeNode   *node,</span>
<span class="udiff-line-modified-added">+                    GQuark      quark);</span>
<span class="udiff-line-modified-added">+ static inline void      type_set_qdata_W    (TypeNode   *node,</span>
<span class="udiff-line-modified-added">+                    GQuark      quark,</span>
<span class="udiff-line-modified-added">+                    gpointer    data);</span>
<span class="udiff-line-modified-added">+ static IFaceHolder*     type_iface_peek_holder_L  (TypeNode   *iface,</span>
<span class="udiff-line-modified-added">+                    GType       instance_type);</span>
  static gboolean                         type_iface_vtable_base_init_Wm  (TypeNode               *iface,
                                                                           TypeNode               *node);
  static void                             type_iface_vtable_iface_init_Wm (TypeNode               *iface,
                                                                           TypeNode               *node);
<span class="udiff-line-modified-removed">- static gboolean             type_node_is_a_L        (TypeNode       *node,</span>
<span class="udiff-line-modified-removed">-                                      TypeNode       *iface_node);</span>
<span class="udiff-line-modified-added">+ static gboolean       type_node_is_a_L    (TypeNode   *node,</span>
<span class="udiff-line-modified-added">+                    TypeNode   *iface_node);</span>
  
  
  /* --- enumeration --- */
  
  /* The InitState enumeration is used to track the progress of initializing
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -229,48 +229,48 @@</span>
    guint        n_children; /* writable with lock */
    guint        n_supers : 8;
    guint        n_prerequisites : 9;
    guint        is_classed : 1;
    guint        is_instantiatable : 1;
<span class="udiff-line-modified-removed">-   guint        mutatable_check_cache : 1;   /* combines some common path checks */</span>
<span class="udiff-line-modified-added">+   guint        mutatable_check_cache : 1; /* combines some common path checks */</span>
    GType       *children; /* writable with lock */
    TypeData * volatile data;
    GQuark       qname;
    GData       *global_gdata;
    union {
<span class="udiff-line-modified-removed">-     GAtomicArray iface_entries;     /* for !iface types */</span>
<span class="udiff-line-modified-added">+     GAtomicArray iface_entries;   /* for !iface types */</span>
      GAtomicArray offsets;
    } _prot;
    GType       *prerequisites;
    GType        supers[1]; /* flexible array */
  };
  
<span class="udiff-line-modified-removed">- #define SIZEOF_BASE_TYPE_NODE()         (G_STRUCT_OFFSET (TypeNode, supers))</span>
<span class="udiff-line-modified-removed">- #define MAX_N_SUPERS                (255)</span>
<span class="udiff-line-modified-removed">- #define MAX_N_CHILDREN              (G_MAXUINT)</span>
<span class="udiff-line-modified-removed">- #define MAX_N_INTERFACES            (255) /* Limited by offsets being 8 bits */</span>
<span class="udiff-line-modified-removed">- #define MAX_N_PREREQUISITES         (511)</span>
<span class="udiff-line-modified-removed">- #define NODE_TYPE(node)             (node-&gt;supers[0])</span>
<span class="udiff-line-modified-removed">- #define NODE_PARENT_TYPE(node)          (node-&gt;supers[1])</span>
<span class="udiff-line-modified-removed">- #define NODE_FUNDAMENTAL_TYPE(node)     (node-&gt;supers[node-&gt;n_supers])</span>
<span class="udiff-line-modified-removed">- #define NODE_NAME(node)             (g_quark_to_string (node-&gt;qname))</span>
<span class="udiff-line-modified-added">+ #define SIZEOF_BASE_TYPE_NODE()     (G_STRUCT_OFFSET (TypeNode, supers))</span>
<span class="udiff-line-modified-added">+ #define MAX_N_SUPERS        (255)</span>
<span class="udiff-line-modified-added">+ #define MAX_N_CHILDREN        (G_MAXUINT)</span>
<span class="udiff-line-modified-added">+ #define MAX_N_INTERFACES      (255) /* Limited by offsets being 8 bits */</span>
<span class="udiff-line-modified-added">+ #define MAX_N_PREREQUISITES     (511)</span>
<span class="udiff-line-modified-added">+ #define NODE_TYPE(node)       (node-&gt;supers[0])</span>
<span class="udiff-line-modified-added">+ #define NODE_PARENT_TYPE(node)      (node-&gt;supers[1])</span>
<span class="udiff-line-modified-added">+ #define NODE_FUNDAMENTAL_TYPE(node)   (node-&gt;supers[node-&gt;n_supers])</span>
<span class="udiff-line-modified-added">+ #define NODE_NAME(node)       (g_quark_to_string (node-&gt;qname))</span>
  #define NODE_REFCOUNT(node)                     ((guint) g_atomic_int_get ((int *) &amp;(node)-&gt;ref_count))
<span class="udiff-line-modified-removed">- #define NODE_IS_BOXED(node)         (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_BOXED)</span>
<span class="udiff-line-modified-removed">- #define NODE_IS_IFACE(node)         (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_INTERFACE)</span>
<span class="udiff-line-modified-removed">- #define CLASSED_NODE_IFACES_ENTRIES(node)   (&amp;(node)-&gt;_prot.iface_entries)</span>
<span class="udiff-line-modified-added">+ #define NODE_IS_BOXED(node)     (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_BOXED)</span>
<span class="udiff-line-modified-added">+ #define NODE_IS_IFACE(node)     (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_INTERFACE)</span>
<span class="udiff-line-modified-added">+ #define CLASSED_NODE_IFACES_ENTRIES(node) (&amp;(node)-&gt;_prot.iface_entries)</span>
  #define CLASSED_NODE_IFACES_ENTRIES_LOCKED(node)(G_ATOMIC_ARRAY_GET_LOCKED(CLASSED_NODE_IFACES_ENTRIES((node)), IFaceEntries))
<span class="udiff-line-modified-removed">- #define IFACE_NODE_N_PREREQUISITES(node)    ((node)-&gt;n_prerequisites)</span>
<span class="udiff-line-modified-removed">- #define IFACE_NODE_PREREQUISITES(node)      ((node)-&gt;prerequisites)</span>
<span class="udiff-line-modified-removed">- #define iface_node_get_holders_L(node)      ((IFaceHolder*) type_get_qdata_L ((node), static_quark_iface_holder))</span>
<span class="udiff-line-modified-added">+ #define IFACE_NODE_N_PREREQUISITES(node)  ((node)-&gt;n_prerequisites)</span>
<span class="udiff-line-modified-added">+ #define IFACE_NODE_PREREQUISITES(node)    ((node)-&gt;prerequisites)</span>
<span class="udiff-line-modified-added">+ #define iface_node_get_holders_L(node)    ((IFaceHolder*) type_get_qdata_L ((node), static_quark_iface_holder))</span>
  #define iface_node_set_holders_W(node, holders) (type_set_qdata_W ((node), static_quark_iface_holder, (holders)))
<span class="udiff-line-modified-removed">- #define iface_node_get_dependants_array_L(n)    ((GType*) type_get_qdata_L ((n), static_quark_dependants_array))</span>
<span class="udiff-line-modified-added">+ #define iface_node_get_dependants_array_L(n)  ((GType*) type_get_qdata_L ((n), static_quark_dependants_array))</span>
  #define iface_node_set_dependants_array_W(n,d)  (type_set_qdata_W ((n), static_quark_dependants_array, (d)))
<span class="udiff-line-modified-removed">- #define TYPE_ID_MASK                ((GType) ((1 &lt;&lt; G_TYPE_FUNDAMENTAL_SHIFT) - 1))</span>
<span class="udiff-line-modified-added">+ #define TYPE_ID_MASK        ((GType) ((1 &lt;&lt; G_TYPE_FUNDAMENTAL_SHIFT) - 1))</span>
  
  #define NODE_IS_ANCESTOR(ancestor, node)                                                    \
          ((ancestor)-&gt;n_supers &lt;= (node)-&gt;n_supers &amp;&amp;                                        \
<span class="udiff-line-modified-removed">-      (node)-&gt;supers[(node)-&gt;n_supers - (ancestor)-&gt;n_supers] == NODE_TYPE (ancestor))</span>
<span class="udiff-line-modified-added">+    (node)-&gt;supers[(node)-&gt;n_supers - (ancestor)-&gt;n_supers] == NODE_TYPE (ancestor))</span>
  
  struct _IFaceHolder
  {
    GType           instance_type;
    GInterfaceInfo *info;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -378,16 +378,19 @@</span>
  static IFaceCheckFunc *static_iface_check_funcs = NULL;
  static GQuark          static_quark_type_flags = 0;
  static GQuark          static_quark_iface_holder = 0;
  static GQuark          static_quark_dependants_array = 0;
  static guint           type_registration_serial = 0;
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
  GTypeDebugFlags        _g_type_debug_flags = 0;
<span class="udiff-line-added">+ G_GNUC_END_IGNORE_DEPRECATIONS</span>
  
  /* --- type nodes --- */
  static GHashTable       *static_type_nodes_ht = NULL;
<span class="udiff-line-modified-removed">- static TypeNode     *static_fundamental_type_nodes[(G_TYPE_FUNDAMENTAL_MAX &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT) + 1] = { NULL, };</span>
<span class="udiff-line-modified-removed">- static GType         static_fundamental_next = G_TYPE_RESERVED_USER_FIRST;</span>
<span class="udiff-line-modified-added">+ static TypeNode   *static_fundamental_type_nodes[(G_TYPE_FUNDAMENTAL_MAX &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT) + 1] = { NULL, };</span>
<span class="udiff-line-modified-added">+ static GType     static_fundamental_next = G_TYPE_RESERVED_USER_FIRST;</span>
  
  static inline TypeNode*
  lookup_type_node_I (GType utype)
  {
    if (utype &gt; G_TYPE_FUNDAMENTAL_MAX)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -415,28 +418,28 @@</span>
    return (guint)g_atomic_int_get ((gint *)&amp;type_registration_serial);
  }
  
  static TypeNode*
  type_node_any_new_W (TypeNode             *pnode,
<span class="udiff-line-modified-removed">-              GType                 ftype,</span>
<span class="udiff-line-modified-removed">-              const gchar          *name,</span>
<span class="udiff-line-modified-removed">-              GTypePlugin          *plugin,</span>
<span class="udiff-line-modified-removed">-              GTypeFundamentalFlags type_flags)</span>
<span class="udiff-line-modified-added">+          GType                 ftype,</span>
<span class="udiff-line-modified-added">+          const gchar          *name,</span>
<span class="udiff-line-modified-added">+          GTypePlugin          *plugin,</span>
<span class="udiff-line-modified-added">+          GTypeFundamentalFlags type_flags)</span>
  {
    guint n_supers;
    GType type;
    TypeNode *node;
    guint i, node_size = 0;
  
    n_supers = pnode ? pnode-&gt;n_supers + 1 : 0;
  
    if (!pnode)
<span class="udiff-line-modified-removed">-     node_size += SIZEOF_FUNDAMENTAL_INFO;         /* fundamental type info */</span>
<span class="udiff-line-modified-removed">-   node_size += SIZEOF_BASE_TYPE_NODE ();          /* TypeNode structure */</span>
<span class="udiff-line-modified-added">+     node_size += SIZEOF_FUNDAMENTAL_INFO;       /* fundamental type info */</span>
<span class="udiff-line-modified-added">+   node_size += SIZEOF_BASE_TYPE_NODE ();        /* TypeNode structure */</span>
    node_size += (sizeof (GType) * (1 + n_supers + 1)); /* self + ancestors + (0) for -&gt;supers[] */
    node = g_malloc0 (node_size);
<span class="udiff-line-modified-removed">-   if (!pnode)                         /* offset fundamental types */</span>
<span class="udiff-line-modified-added">+   if (!pnode)               /* offset fundamental types */</span>
      {
        node = G_STRUCT_MEMBER_P (node, SIZEOF_FUNDAMENTAL_INFO);
        static_fundamental_type_nodes[ftype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT] = node;
        type = ftype;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -453,49 +456,49 @@</span>
  
        node-&gt;is_classed = (type_flags &amp; G_TYPE_FLAG_CLASSED) != 0;
        node-&gt;is_instantiatable = (type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) != 0;
  
        if (NODE_IS_IFACE (node))
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-added">+   {</span>
            IFACE_NODE_N_PREREQUISITES (node) = 0;
<span class="udiff-line-modified-removed">-       IFACE_NODE_PREREQUISITES (node) = NULL;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     IFACE_NODE_PREREQUISITES (node) = NULL;</span>
<span class="udiff-line-modified-added">+   }</span>
        else
<span class="udiff-line-modified-removed">-     _g_atomic_array_init (CLASSED_NODE_IFACES_ENTRIES (node));</span>
<span class="udiff-line-modified-added">+   _g_atomic_array_init (CLASSED_NODE_IFACES_ENTRIES (node));</span>
      }
    else
      {
        node-&gt;supers[0] = type;
        memcpy (node-&gt;supers + 1, pnode-&gt;supers, sizeof (GType) * (1 + pnode-&gt;n_supers + 1));
  
        node-&gt;is_classed = pnode-&gt;is_classed;
        node-&gt;is_instantiatable = pnode-&gt;is_instantiatable;
  
        if (NODE_IS_IFACE (node))
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       IFACE_NODE_N_PREREQUISITES (node) = 0;</span>
<span class="udiff-line-modified-removed">-       IFACE_NODE_PREREQUISITES (node) = NULL;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     IFACE_NODE_N_PREREQUISITES (node) = 0;</span>
<span class="udiff-line-modified-added">+     IFACE_NODE_PREREQUISITES (node) = NULL;</span>
<span class="udiff-line-modified-added">+   }</span>
        else
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     guint j;</span>
<span class="udiff-line-added">+     IFaceEntries *entries;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (pnode),</span>
<span class="udiff-line-added">+             IFACE_ENTRIES_HEADER_SIZE,</span>
<span class="udiff-line-added">+             0);</span>
<span class="udiff-line-added">+     if (entries)</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (entries); j++)</span>
      {
<span class="udiff-line-modified-removed">-       guint j;</span>
<span class="udiff-line-modified-removed">-       IFaceEntries *entries;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (pnode),</span>
<span class="udiff-line-removed">-                       IFACE_ENTRIES_HEADER_SIZE,</span>
<span class="udiff-line-removed">-                       0);</span>
<span class="udiff-line-removed">-       if (entries)</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-           for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (entries); j++)</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-           entries-&gt;entry[j].vtable = NULL;</span>
<span class="udiff-line-removed">-           entries-&gt;entry[j].init_state = UNINITIALIZED;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-           _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node),</span>
<span class="udiff-line-removed">-                       entries);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+       entries-&gt;entry[j].vtable = NULL;</span>
<span class="udiff-line-modified-added">+       entries-&gt;entry[j].init_state = UNINITIALIZED;</span>
      }
<span class="udiff-line-added">+         _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node),</span>
<span class="udiff-line-added">+               entries);</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+   }</span>
  
        i = pnode-&gt;n_children++;
        pnode-&gt;children = g_renew (GType, pnode-&gt;children, pnode-&gt;n_children);
        pnode-&gt;children[i] = type;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -507,12 +510,12 @@</span>
    node-&gt;children = NULL;
    node-&gt;data = NULL;
    node-&gt;qname = g_quark_from_string (name);
    node-&gt;global_gdata = NULL;
    g_hash_table_insert (static_type_nodes_ht,
<span class="udiff-line-modified-removed">-                (gpointer) g_quark_to_string (node-&gt;qname),</span>
<span class="udiff-line-modified-removed">-                (gpointer) type);</span>
<span class="udiff-line-modified-added">+            (gpointer) g_quark_to_string (node-&gt;qname),</span>
<span class="udiff-line-modified-added">+            (gpointer) type);</span>
  
    g_atomic_int_inc ((gint *)&amp;type_registration_serial);
  
    return node;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -528,12 +531,12 @@</span>
    return node ? G_STRUCT_MEMBER_P (node, -SIZEOF_FUNDAMENTAL_INFO) : NULL;
  }
  
  static TypeNode*
  type_node_fundamental_new_W (GType                 ftype,
<span class="udiff-line-modified-removed">-                  const gchar          *name,</span>
<span class="udiff-line-modified-removed">-                  GTypeFundamentalFlags type_flags)</span>
<span class="udiff-line-modified-added">+            const gchar          *name,</span>
<span class="udiff-line-modified-added">+            GTypeFundamentalFlags type_flags)</span>
  {
    GTypeFundamentalInfo *finfo;
    TypeNode *node;
  
    g_assert ((ftype &amp; TYPE_ID_MASK) == 0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -552,12 +555,12 @@</span>
    return node;
  }
  
  static TypeNode*
  type_node_new_W (TypeNode    *pnode,
<span class="udiff-line-modified-removed">-          const gchar *name,</span>
<span class="udiff-line-modified-removed">-          GTypePlugin *plugin)</span>
<span class="udiff-line-modified-added">+      const gchar *name,</span>
<span class="udiff-line-modified-added">+      GTypePlugin *plugin)</span>
  
  {
    g_assert (pnode);
    g_assert (pnode-&gt;n_supers &lt; MAX_N_SUPERS);
    g_assert (pnode-&gt;n_children &lt; MAX_N_CHILDREN);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -565,11 +568,11 @@</span>
    return type_node_any_new_W (pnode, NODE_FUNDAMENTAL_TYPE (pnode), name, plugin, 0);
  }
  
  static inline IFaceEntry*
  lookup_iface_entry_I (volatile IFaceEntries *entries,
<span class="udiff-line-modified-removed">-               TypeNode *iface_node)</span>
<span class="udiff-line-modified-added">+           TypeNode *iface_node)</span>
  {
    guint8 *offsets;
    guint offset_index;
    IFaceEntry *check;
    int index;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -583,101 +586,101 @@</span>
  
       entry = NULL;
       offsets = transaction_data;
       offset_index = entries-&gt;offset_index;
       if (offsets != NULL &amp;&amp;
<span class="udiff-line-modified-removed">-      offset_index &lt; G_ATOMIC_ARRAY_DATA_SIZE(offsets))</span>
<span class="udiff-line-removed">-        {</span>
<span class="udiff-line-removed">-      index = offsets[offset_index];</span>
<span class="udiff-line-removed">-      if (index &gt; 0)</span>
<span class="udiff-line-modified-added">+    offset_index &lt; G_ATOMIC_ARRAY_DATA_SIZE(offsets))</span>
         {
<span class="udiff-line-modified-removed">-          /* zero means unset, subtract one to get real index */</span>
<span class="udiff-line-modified-removed">-          index -= 1;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-          if (index &lt; IFACE_ENTRIES_N_ENTRIES (entries))</span>
<span class="udiff-line-modified-removed">-            {</span>
<span class="udiff-line-modified-removed">-          check = (IFaceEntry *)&amp;entries-&gt;entry[index];</span>
<span class="udiff-line-modified-removed">-          if (check-&gt;iface_type == NODE_TYPE (iface_node))</span>
<span class="udiff-line-modified-removed">-            entry = check;</span>
<span class="udiff-line-modified-removed">-            }</span>
<span class="udiff-line-modified-removed">-        }</span>
<span class="udiff-line-modified-added">+    index = offsets[offset_index];</span>
<span class="udiff-line-modified-added">+    if (index &gt; 0)</span>
<span class="udiff-line-modified-added">+      {</span>
<span class="udiff-line-modified-added">+        /* zero means unset, subtract one to get real index */</span>
<span class="udiff-line-modified-added">+        index -= 1;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+        if (index &lt; IFACE_ENTRIES_N_ENTRIES (entries))</span>
<span class="udiff-line-modified-added">+          {</span>
<span class="udiff-line-modified-added">+      check = (IFaceEntry *)&amp;entries-&gt;entry[index];</span>
<span class="udiff-line-modified-added">+      if (check-&gt;iface_type == NODE_TYPE (iface_node))</span>
<span class="udiff-line-added">+        entry = check;</span>
<span class="udiff-line-added">+          }</span>
<span class="udiff-line-added">+      }</span>
         }
       );
  
   return entry;
  }
  
  static inline IFaceEntry*
  type_lookup_iface_entry_L (TypeNode *node,
<span class="udiff-line-modified-removed">-                TypeNode *iface_node)</span>
<span class="udiff-line-modified-added">+          TypeNode *iface_node)</span>
  {
    if (!NODE_IS_IFACE (iface_node))
      return NULL;
  
    return lookup_iface_entry_I (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node),
<span class="udiff-line-modified-removed">-                    iface_node);</span>
<span class="udiff-line-modified-added">+              iface_node);</span>
  }
  
  
  static inline gboolean
  type_lookup_iface_vtable_I (TypeNode *node,
<span class="udiff-line-modified-removed">-                 TypeNode *iface_node,</span>
<span class="udiff-line-modified-removed">-                 gpointer *vtable_ptr)</span>
<span class="udiff-line-modified-added">+           TypeNode *iface_node,</span>
<span class="udiff-line-modified-added">+           gpointer *vtable_ptr)</span>
  {
    IFaceEntry *entry;
    gboolean res;
  
    if (!NODE_IS_IFACE (iface_node))
      {
        if (vtable_ptr)
<span class="udiff-line-modified-removed">-     *vtable_ptr = NULL;</span>
<span class="udiff-line-modified-added">+   *vtable_ptr = NULL;</span>
        return FALSE;
      }
  
    G_ATOMIC_ARRAY_DO_TRANSACTION
      (CLASSED_NODE_IFACES_ENTRIES (node), IFaceEntries,
  
       entry = lookup_iface_entry_I (transaction_data, iface_node);
       res = entry != NULL;
       if (vtable_ptr)
         {
<span class="udiff-line-modified-removed">-      if (entry)</span>
<span class="udiff-line-modified-removed">-        *vtable_ptr = entry-&gt;vtable;</span>
<span class="udiff-line-modified-removed">-      else</span>
<span class="udiff-line-modified-removed">-        *vtable_ptr = NULL;</span>
<span class="udiff-line-modified-added">+    if (entry)</span>
<span class="udiff-line-modified-added">+      *vtable_ptr = entry-&gt;vtable;</span>
<span class="udiff-line-modified-added">+    else</span>
<span class="udiff-line-modified-added">+      *vtable_ptr = NULL;</span>
         }
       );
  
    return res;
  }
  
  static inline gboolean
  type_lookup_prerequisite_L (TypeNode *iface,
<span class="udiff-line-modified-removed">-                 GType     prerequisite_type)</span>
<span class="udiff-line-modified-added">+           GType     prerequisite_type)</span>
  {
    if (NODE_IS_IFACE (iface) &amp;&amp; IFACE_NODE_N_PREREQUISITES (iface))
      {
        GType *prerequisites = IFACE_NODE_PREREQUISITES (iface) - 1;
        guint n_prerequisites = IFACE_NODE_N_PREREQUISITES (iface);
  
        do
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       guint i;</span>
<span class="udiff-line-modified-removed">-       GType *check;</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     guint i;</span>
<span class="udiff-line-modified-added">+     GType *check;</span>
  
<span class="udiff-line-modified-removed">-       i = (n_prerequisites + 1) &gt;&gt; 1;</span>
<span class="udiff-line-modified-removed">-       check = prerequisites + i;</span>
<span class="udiff-line-modified-removed">-       if (prerequisite_type == *check)</span>
<span class="udiff-line-modified-removed">-         return TRUE;</span>
<span class="udiff-line-modified-removed">-       else if (prerequisite_type &gt; *check)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           n_prerequisites -= i;</span>
<span class="udiff-line-modified-removed">-           prerequisites = check;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-       else /* if (prerequisite_type &lt; *check) */</span>
<span class="udiff-line-modified-removed">-         n_prerequisites = i - 1;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     i = (n_prerequisites + 1) &gt;&gt; 1;</span>
<span class="udiff-line-modified-added">+     check = prerequisites + i;</span>
<span class="udiff-line-modified-added">+     if (prerequisite_type == *check)</span>
<span class="udiff-line-modified-added">+       return TRUE;</span>
<span class="udiff-line-modified-added">+     else if (prerequisite_type &gt; *check)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         n_prerequisites -= i;</span>
<span class="udiff-line-modified-added">+         prerequisites = check;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+     else /* if (prerequisite_type &lt; *check) */</span>
<span class="udiff-line-modified-added">+       n_prerequisites = i - 1;</span>
<span class="udiff-line-modified-added">+   }</span>
        while (n_prerequisites);
      }
    return FALSE;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -696,38 +699,38 @@</span>
  
  
  /* --- type consistency checks --- */
  static gboolean
  check_plugin_U (GTypePlugin *plugin,
<span class="udiff-line-modified-removed">-         gboolean     need_complete_type_info,</span>
<span class="udiff-line-modified-removed">-         gboolean     need_complete_interface_info,</span>
<span class="udiff-line-modified-removed">-         const gchar *type_name)</span>
<span class="udiff-line-modified-added">+     gboolean     need_complete_type_info,</span>
<span class="udiff-line-modified-added">+     gboolean     need_complete_interface_info,</span>
<span class="udiff-line-modified-added">+     const gchar *type_name)</span>
  {
    /* G_IS_TYPE_PLUGIN() and G_TYPE_PLUGIN_GET_CLASS() are external calls: _U
     */
    if (!plugin)
      {
        g_warning (&quot;plugin handle for type &#39;%s&#39; is NULL&quot;,
<span class="udiff-line-modified-removed">-          type_name);</span>
<span class="udiff-line-modified-added">+      type_name);</span>
        return FALSE;
      }
    if (!G_IS_TYPE_PLUGIN (plugin))
      {
        g_warning (&quot;plugin pointer (%p) for type &#39;%s&#39; is invalid&quot;,
<span class="udiff-line-modified-removed">-          plugin, type_name);</span>
<span class="udiff-line-modified-added">+      plugin, type_name);</span>
        return FALSE;
      }
    if (need_complete_type_info &amp;&amp; !G_TYPE_PLUGIN_GET_CLASS (plugin)-&gt;complete_type_info)
      {
        g_warning (&quot;plugin for type &#39;%s&#39; has no complete_type_info() implementation&quot;,
<span class="udiff-line-modified-removed">-          type_name);</span>
<span class="udiff-line-modified-added">+      type_name);</span>
        return FALSE;
      }
    if (need_complete_interface_info &amp;&amp; !G_TYPE_PLUGIN_GET_CLASS (plugin)-&gt;complete_interface_info)
      {
        g_warning (&quot;plugin for type &#39;%s&#39; has no complete_interface_info() implementation&quot;,
<span class="udiff-line-modified-removed">-          type_name);</span>
<span class="udiff-line-modified-added">+      type_name);</span>
        return FALSE;
      }
    return TRUE;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -745,13 +748,13 @@</span>
      }
    /* check the first letter */
    name_valid = (p[0] &gt;= &#39;A&#39; &amp;&amp; p[0] &lt;= &#39;Z&#39;) || (p[0] &gt;= &#39;a&#39; &amp;&amp; p[0] &lt;= &#39;z&#39;) || p[0] == &#39;_&#39;;
    for (p = type_name + 1; *p; p++)
      name_valid &amp;= ((p[0] &gt;= &#39;A&#39; &amp;&amp; p[0] &lt;= &#39;Z&#39;) ||
<span class="udiff-line-modified-removed">-            (p[0] &gt;= &#39;a&#39; &amp;&amp; p[0] &lt;= &#39;z&#39;) ||</span>
<span class="udiff-line-modified-removed">-            (p[0] &gt;= &#39;0&#39; &amp;&amp; p[0] &lt;= &#39;9&#39;) ||</span>
<span class="udiff-line-modified-removed">-            strchr (extra_chars, p[0]));</span>
<span class="udiff-line-modified-added">+        (p[0] &gt;= &#39;a&#39; &amp;&amp; p[0] &lt;= &#39;z&#39;) ||</span>
<span class="udiff-line-modified-added">+        (p[0] &gt;= &#39;0&#39; &amp;&amp; p[0] &lt;= &#39;9&#39;) ||</span>
<span class="udiff-line-modified-added">+        strchr (extra_chars, p[0]));</span>
    if (!name_valid)
      {
        g_warning (&quot;type name &#39;%s&#39; contains invalid characters&quot;, type_name);
        return FALSE;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -764,39 +767,39 @@</span>
    return TRUE;
  }
  
  static gboolean
  check_derivation_I (GType        parent_type,
<span class="udiff-line-modified-removed">-             const gchar *type_name)</span>
<span class="udiff-line-modified-added">+         const gchar *type_name)</span>
  {
    TypeNode *pnode;
    GTypeFundamentalInfo* finfo;
  
    pnode = lookup_type_node_I (parent_type);
    if (!pnode)
      {
        g_warning (&quot;cannot derive type &#39;%s&#39; from invalid parent type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_name,</span>
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (parent_type));</span>
<span class="udiff-line-modified-added">+      type_name,</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (parent_type));</span>
        return FALSE;
      }
    finfo = type_node_fundamental_info_I (pnode);
    /* ensure flat derivability */
    if (!(finfo-&gt;type_flags &amp; G_TYPE_FLAG_DERIVABLE))
      {
        g_warning (&quot;cannot derive &#39;%s&#39; from non-derivable parent type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_name,</span>
<span class="udiff-line-modified-removed">-          NODE_NAME (pnode));</span>
<span class="udiff-line-modified-added">+      type_name,</span>
<span class="udiff-line-modified-added">+      NODE_NAME (pnode));</span>
        return FALSE;
      }
    /* ensure deep derivability */
    if (parent_type != NODE_FUNDAMENTAL_TYPE (pnode) &amp;&amp;
        !(finfo-&gt;type_flags &amp; G_TYPE_FLAG_DEEP_DERIVABLE))
      {
        g_warning (&quot;cannot derive &#39;%s&#39; from non-fundamental parent type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_name,</span>
<span class="udiff-line-modified-removed">-          NODE_NAME (pnode));</span>
<span class="udiff-line-modified-added">+      type_name,</span>
<span class="udiff-line-modified-added">+      NODE_NAME (pnode));</span>
        return FALSE;
      }
  
    return TRUE;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -804,86 +807,86 @@</span>
  static gboolean
  check_collect_format_I (const gchar *collect_format)
  {
    const gchar *p = collect_format;
    gchar valid_format[] = { G_VALUE_COLLECT_INT, G_VALUE_COLLECT_LONG,
<span class="udiff-line-modified-removed">-                G_VALUE_COLLECT_INT64, G_VALUE_COLLECT_DOUBLE,</span>
<span class="udiff-line-modified-removed">-                G_VALUE_COLLECT_POINTER, 0 };</span>
<span class="udiff-line-modified-added">+          G_VALUE_COLLECT_INT64, G_VALUE_COLLECT_DOUBLE,</span>
<span class="udiff-line-modified-added">+          G_VALUE_COLLECT_POINTER, 0 };</span>
  
    while (*p)
      if (!strchr (valid_format, *p++))
        return FALSE;
    return p - collect_format &lt;= G_VALUE_COLLECT_FORMAT_MAX_LENGTH;
  }
  
  static gboolean
  check_value_table_I (const gchar           *type_name,
<span class="udiff-line-modified-removed">-              const GTypeValueTable *value_table)</span>
<span class="udiff-line-modified-added">+          const GTypeValueTable *value_table)</span>
  {
    if (!value_table)
      return FALSE;
    else if (value_table-&gt;value_init == NULL)
      {
        if (value_table-&gt;value_free || value_table-&gt;value_copy ||
<span class="udiff-line-modified-removed">-       value_table-&gt;value_peek_pointer ||</span>
<span class="udiff-line-modified-removed">-       value_table-&gt;collect_format || value_table-&gt;collect_value ||</span>
<span class="udiff-line-modified-removed">-       value_table-&gt;lcopy_format || value_table-&gt;lcopy_value)</span>
<span class="udiff-line-modified-removed">-     g_warning (&quot;cannot handle uninitializable values of type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-            type_name);</span>
<span class="udiff-line-modified-added">+     value_table-&gt;value_peek_pointer ||</span>
<span class="udiff-line-modified-added">+     value_table-&gt;collect_format || value_table-&gt;collect_value ||</span>
<span class="udiff-line-modified-added">+     value_table-&gt;lcopy_format || value_table-&gt;lcopy_value)</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;cannot handle uninitializable values of type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+        type_name);</span>
        return FALSE;
      }
    else /* value_table-&gt;value_init != NULL */
      {
        if (!value_table-&gt;value_free)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       /* +++ optional +++</span>
<span class="udiff-line-modified-removed">-        * g_warning (&quot;missing &#39;value_free()&#39; for type &#39;%s&#39;&quot;, type_name);</span>
<span class="udiff-line-modified-removed">-        * return FALSE;</span>
<span class="udiff-line-modified-removed">-        */</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     /* +++ optional +++</span>
<span class="udiff-line-modified-added">+      * g_warning (&quot;missing &#39;value_free()&#39; for type &#39;%s&#39;&quot;, type_name);</span>
<span class="udiff-line-modified-added">+      * return FALSE;</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+   }</span>
        if (!value_table-&gt;value_copy)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;missing &#39;value_copy()&#39; for type &#39;%s&#39;&quot;, type_name);</span>
<span class="udiff-line-modified-removed">-       return FALSE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;missing &#39;value_copy()&#39; for type &#39;%s&#39;&quot;, type_name);</span>
<span class="udiff-line-modified-added">+     return FALSE;</span>
<span class="udiff-line-modified-added">+   }</span>
        if ((value_table-&gt;collect_format || value_table-&gt;collect_value) &amp;&amp;
<span class="udiff-line-modified-removed">-       (!value_table-&gt;collect_format || !value_table-&gt;collect_value))</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;one of &#39;collect_format&#39; and &#39;collect_value()&#39; is unspecified for type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-              type_name);</span>
<span class="udiff-line-modified-removed">-       return FALSE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     (!value_table-&gt;collect_format || !value_table-&gt;collect_value))</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;one of &#39;collect_format&#39; and &#39;collect_value()&#39; is unspecified for type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+          type_name);</span>
<span class="udiff-line-modified-added">+     return FALSE;</span>
<span class="udiff-line-modified-added">+   }</span>
        if (value_table-&gt;collect_format &amp;&amp; !check_collect_format_I (value_table-&gt;collect_format))
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;the &#39;%s&#39; specification for type &#39;%s&#39; is too long or invalid&quot;,</span>
<span class="udiff-line-modified-removed">-              &quot;collect_format&quot;,</span>
<span class="udiff-line-modified-removed">-              type_name);</span>
<span class="udiff-line-modified-removed">-       return FALSE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;the &#39;%s&#39; specification for type &#39;%s&#39; is too long or invalid&quot;,</span>
<span class="udiff-line-modified-added">+          &quot;collect_format&quot;,</span>
<span class="udiff-line-modified-added">+          type_name);</span>
<span class="udiff-line-modified-added">+     return FALSE;</span>
<span class="udiff-line-modified-added">+   }</span>
        if ((value_table-&gt;lcopy_format || value_table-&gt;lcopy_value) &amp;&amp;
<span class="udiff-line-modified-removed">-       (!value_table-&gt;lcopy_format || !value_table-&gt;lcopy_value))</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;one of &#39;lcopy_format&#39; and &#39;lcopy_value()&#39; is unspecified for type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-              type_name);</span>
<span class="udiff-line-modified-removed">-       return FALSE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     (!value_table-&gt;lcopy_format || !value_table-&gt;lcopy_value))</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;one of &#39;lcopy_format&#39; and &#39;lcopy_value()&#39; is unspecified for type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+          type_name);</span>
<span class="udiff-line-modified-added">+     return FALSE;</span>
<span class="udiff-line-modified-added">+   }</span>
        if (value_table-&gt;lcopy_format &amp;&amp; !check_collect_format_I (value_table-&gt;lcopy_format))
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;the &#39;%s&#39; specification for type &#39;%s&#39; is too long or invalid&quot;,</span>
<span class="udiff-line-modified-removed">-              &quot;lcopy_format&quot;,</span>
<span class="udiff-line-modified-removed">-              type_name);</span>
<span class="udiff-line-modified-removed">-       return FALSE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;the &#39;%s&#39; specification for type &#39;%s&#39; is too long or invalid&quot;,</span>
<span class="udiff-line-modified-added">+          &quot;lcopy_format&quot;,</span>
<span class="udiff-line-modified-added">+          type_name);</span>
<span class="udiff-line-modified-added">+     return FALSE;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    return TRUE;
  }
  
  static gboolean
  check_type_info_I (TypeNode        *pnode,
<span class="udiff-line-modified-removed">-            GType            ftype,</span>
<span class="udiff-line-modified-removed">-            const gchar     *type_name,</span>
<span class="udiff-line-modified-removed">-            const GTypeInfo *info)</span>
<span class="udiff-line-modified-added">+        GType            ftype,</span>
<span class="udiff-line-modified-added">+        const gchar     *type_name,</span>
<span class="udiff-line-modified-added">+        const GTypeInfo *info)</span>
  {
    GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (lookup_type_node_I (ftype));
    gboolean is_interface = ftype == G_TYPE_INTERFACE;
  
    g_assert (ftype &lt;= G_TYPE_FUNDAMENTAL_MAX &amp;&amp; !(ftype &amp; TYPE_ID_MASK));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -891,82 +894,82 @@</span>
    /* check instance members */
    if (!(finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) &amp;&amp;
        (info-&gt;instance_size || info-&gt;n_preallocs || info-&gt;instance_init))
      {
        if (pnode)
<span class="udiff-line-modified-removed">-     g_warning (&quot;cannot instantiate &#39;%s&#39;, derived from non-instantiatable parent type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-            type_name,</span>
<span class="udiff-line-modified-removed">-            NODE_NAME (pnode));</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;cannot instantiate &#39;%s&#39;, derived from non-instantiatable parent type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+        type_name,</span>
<span class="udiff-line-modified-added">+        NODE_NAME (pnode));</span>
        else
<span class="udiff-line-modified-removed">-     g_warning (&quot;cannot instantiate &#39;%s&#39; as non-instantiatable fundamental&quot;,</span>
<span class="udiff-line-modified-removed">-            type_name);</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;cannot instantiate &#39;%s&#39; as non-instantiatable fundamental&quot;,</span>
<span class="udiff-line-modified-added">+        type_name);</span>
        return FALSE;
      }
    /* check class &amp; interface members */
    if (!((finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED) || is_interface) &amp;&amp;
        (info-&gt;class_init || info-&gt;class_finalize || info-&gt;class_data ||
         info-&gt;class_size || info-&gt;base_init || info-&gt;base_finalize))
      {
        if (pnode)
<span class="udiff-line-modified-removed">-     g_warning (&quot;cannot create class for &#39;%s&#39;, derived from non-classed parent type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-            type_name,</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;cannot create class for &#39;%s&#39;, derived from non-classed parent type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+        type_name,</span>
                     NODE_NAME (pnode));
        else
<span class="udiff-line-modified-removed">-     g_warning (&quot;cannot create class for &#39;%s&#39; as non-classed fundamental&quot;,</span>
<span class="udiff-line-modified-removed">-            type_name);</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;cannot create class for &#39;%s&#39; as non-classed fundamental&quot;,</span>
<span class="udiff-line-modified-added">+        type_name);</span>
        return FALSE;
      }
    /* check interface size */
    if (is_interface &amp;&amp; info-&gt;class_size &lt; sizeof (GTypeInterface))
      {
        g_warning (&quot;specified interface size for type &#39;%s&#39; is smaller than &#39;GTypeInterface&#39; size&quot;,
<span class="udiff-line-modified-removed">-          type_name);</span>
<span class="udiff-line-modified-added">+      type_name);</span>
        return FALSE;
      }
    /* check class size */
    if (finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED)
      {
        if (info-&gt;class_size &lt; sizeof (GTypeClass))
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;specified class size for type &#39;%s&#39; is smaller than &#39;GTypeClass&#39; size&quot;,</span>
<span class="udiff-line-modified-removed">-              type_name);</span>
<span class="udiff-line-modified-removed">-       return FALSE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;specified class size for type &#39;%s&#39; is smaller than &#39;GTypeClass&#39; size&quot;,</span>
<span class="udiff-line-modified-added">+          type_name);</span>
<span class="udiff-line-modified-added">+     return FALSE;</span>
<span class="udiff-line-modified-added">+   }</span>
        if (pnode &amp;&amp; info-&gt;class_size &lt; pnode-&gt;data-&gt;class.class_size)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;specified class size for type &#39;%s&#39; is smaller &quot;</span>
<span class="udiff-line-modified-removed">-              &quot;than the parent type&#39;s &#39;%s&#39; class size&quot;,</span>
<span class="udiff-line-modified-removed">-              type_name,</span>
<span class="udiff-line-modified-removed">-              NODE_NAME (pnode));</span>
<span class="udiff-line-modified-removed">-       return FALSE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;specified class size for type &#39;%s&#39; is smaller &quot;</span>
<span class="udiff-line-modified-added">+          &quot;than the parent type&#39;s &#39;%s&#39; class size&quot;,</span>
<span class="udiff-line-modified-added">+          type_name,</span>
<span class="udiff-line-modified-added">+          NODE_NAME (pnode));</span>
<span class="udiff-line-modified-added">+     return FALSE;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    /* check instance size */
    if (finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE)
      {
        if (info-&gt;instance_size &lt; sizeof (GTypeInstance))
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;specified instance size for type &#39;%s&#39; is smaller than &#39;GTypeInstance&#39; size&quot;,</span>
<span class="udiff-line-modified-removed">-              type_name);</span>
<span class="udiff-line-modified-removed">-       return FALSE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;specified instance size for type &#39;%s&#39; is smaller than &#39;GTypeInstance&#39; size&quot;,</span>
<span class="udiff-line-modified-added">+          type_name);</span>
<span class="udiff-line-modified-added">+     return FALSE;</span>
<span class="udiff-line-modified-added">+   }</span>
        if (pnode &amp;&amp; info-&gt;instance_size &lt; pnode-&gt;data-&gt;instance.instance_size)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;specified instance size for type &#39;%s&#39; is smaller &quot;</span>
<span class="udiff-line-modified-removed">-              &quot;than the parent type&#39;s &#39;%s&#39; instance size&quot;,</span>
<span class="udiff-line-modified-removed">-              type_name,</span>
<span class="udiff-line-modified-removed">-              NODE_NAME (pnode));</span>
<span class="udiff-line-modified-removed">-       return FALSE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;specified instance size for type &#39;%s&#39; is smaller &quot;</span>
<span class="udiff-line-modified-added">+          &quot;than the parent type&#39;s &#39;%s&#39; instance size&quot;,</span>
<span class="udiff-line-modified-added">+          type_name,</span>
<span class="udiff-line-modified-added">+          NODE_NAME (pnode));</span>
<span class="udiff-line-modified-added">+     return FALSE;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
  
    return TRUE;
  }
  
  static TypeNode*
  find_conforming_child_type_L (TypeNode *pnode,
<span class="udiff-line-modified-removed">-                   TypeNode *iface)</span>
<span class="udiff-line-modified-added">+             TypeNode *iface)</span>
  {
    TypeNode *node = NULL;
    guint i;
  
    if (type_lookup_iface_entry_L (pnode, iface))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -978,11 +981,11 @@</span>
    return node;
  }
  
  static gboolean
  check_add_interface_L (GType instance_type,
<span class="udiff-line-modified-removed">-                GType iface_type)</span>
<span class="udiff-line-modified-added">+            GType iface_type)</span>
  {
    TypeNode *node = lookup_type_node_I (instance_type);
    TypeNode *iface = lookup_type_node_I (iface_type);
    IFaceEntry *entry;
    TypeNode *tnode;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -991,18 +994,18 @@</span>
  
  
    if (!node || !node-&gt;is_instantiatable)
      {
        g_warning (&quot;cannot add interfaces to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (instance_type));</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (instance_type));</span>
        return FALSE;
      }
    if (!iface || !NODE_IS_IFACE (iface))
      {
        g_warning (&quot;cannot add invalid (non-interface) type &#39;%s&#39; to type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (iface_type),</span>
<span class="udiff-line-modified-removed">-          NODE_NAME (node));</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (iface_type),</span>
<span class="udiff-line-modified-added">+      NODE_NAME (node));</span>
        return FALSE;
      }
    if (node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class)
      {
        g_warning (&quot;attempting to add an interface (%s) to class (%s) after class_init&quot;,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1012,13 +1015,13 @@</span>
    tnode = lookup_type_node_I (NODE_PARENT_TYPE (iface));
    if (NODE_PARENT_TYPE (tnode) &amp;&amp; !type_lookup_iface_entry_L (node, tnode))
      {
        /* 2001/7/31:timj: erk, i guess this warning is junk as interface derivation is flat */
        g_warning (&quot;cannot add sub-interface &#39;%s&#39; to type &#39;%s&#39; which does not conform to super-interface &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          NODE_NAME (iface),</span>
<span class="udiff-line-modified-removed">-          NODE_NAME (node),</span>
<span class="udiff-line-modified-removed">-          NODE_NAME (tnode));</span>
<span class="udiff-line-modified-added">+      NODE_NAME (iface),</span>
<span class="udiff-line-modified-added">+      NODE_NAME (node),</span>
<span class="udiff-line-modified-added">+      NODE_NAME (tnode));</span>
        return FALSE;
      }
    /* allow overriding of interface type introduced for parent type */
    entry = type_lookup_iface_entry_L (node, iface);
    if (entry &amp;&amp; entry-&gt;vtable == NULL &amp;&amp; !type_iface_peek_holder_L (iface, NODE_TYPE (node)))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1034,52 +1037,52 @@</span>
     */
    tnode = find_conforming_child_type_L (node, iface);  /* tnode is_a node */
    if (tnode)
      {
        g_warning (&quot;cannot add interface type &#39;%s&#39; to type &#39;%s&#39;, since type &#39;%s&#39; already conforms to interface&quot;,
<span class="udiff-line-modified-removed">-          NODE_NAME (iface),</span>
<span class="udiff-line-modified-removed">-          NODE_NAME (node),</span>
<span class="udiff-line-modified-removed">-          NODE_NAME (tnode));</span>
<span class="udiff-line-modified-added">+      NODE_NAME (iface),</span>
<span class="udiff-line-modified-added">+      NODE_NAME (node),</span>
<span class="udiff-line-modified-added">+      NODE_NAME (tnode));</span>
        return FALSE;
      }
    prerequisites = IFACE_NODE_PREREQUISITES (iface);
    for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
      {
        tnode = lookup_type_node_I (prerequisites[i]);
        if (!type_node_is_a_L (node, tnode))
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;cannot add interface type &#39;%s&#39; to type &#39;%s&#39; which does not conform to prerequisite &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-              NODE_NAME (iface),</span>
<span class="udiff-line-modified-removed">-              NODE_NAME (node),</span>
<span class="udiff-line-modified-removed">-              NODE_NAME (tnode));</span>
<span class="udiff-line-modified-removed">-       return FALSE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;cannot add interface type &#39;%s&#39; to type &#39;%s&#39; which does not conform to prerequisite &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+          NODE_NAME (iface),</span>
<span class="udiff-line-modified-added">+          NODE_NAME (node),</span>
<span class="udiff-line-modified-added">+          NODE_NAME (tnode));</span>
<span class="udiff-line-modified-added">+     return FALSE;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    return TRUE;
  }
  
  static gboolean
  check_interface_info_I (TypeNode             *iface,
<span class="udiff-line-modified-removed">-             GType                 instance_type,</span>
<span class="udiff-line-modified-removed">-             const GInterfaceInfo *info)</span>
<span class="udiff-line-modified-added">+       GType                 instance_type,</span>
<span class="udiff-line-modified-added">+       const GInterfaceInfo *info)</span>
  {
    if ((info-&gt;interface_finalize || info-&gt;interface_data) &amp;&amp; !info-&gt;interface_init)
      {
        g_warning (&quot;interface type &#39;%s&#39; for type &#39;%s&#39; comes without initializer&quot;,
<span class="udiff-line-modified-removed">-          NODE_NAME (iface),</span>
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (instance_type));</span>
<span class="udiff-line-modified-added">+      NODE_NAME (iface),</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (instance_type));</span>
        return FALSE;
      }
  
    return TRUE;
  }
  
  /* --- type info (type node data) --- */
  static void
  type_data_make_W (TypeNode              *node,
<span class="udiff-line-modified-removed">-           const GTypeInfo       *info,</span>
<span class="udiff-line-modified-removed">-           const GTypeValueTable *value_table)</span>
<span class="udiff-line-modified-added">+       const GTypeInfo       *info,</span>
<span class="udiff-line-modified-added">+       const GTypeValueTable *value_table)</span>
  {
    TypeData *data;
    GTypeValueTable *vtable = NULL;
    guint vtable_size = 0;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1088,26 +1091,26 @@</span>
    if (!value_table)
      {
        TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
  
        if (pnode)
<span class="udiff-line-modified-removed">-     vtable = pnode-&gt;data-&gt;common.value_table;</span>
<span class="udiff-line-modified-added">+   vtable = pnode-&gt;data-&gt;common.value_table;</span>
        else
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       static const GTypeValueTable zero_vtable = { NULL, };</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     static const GTypeValueTable zero_vtable = { NULL, };</span>
  
<span class="udiff-line-modified-removed">-       value_table = &amp;zero_vtable;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     value_table = &amp;zero_vtable;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    if (value_table)
      {
        /* need to setup vtable_size since we have to allocate it with data in one chunk */
        vtable_size = sizeof (GTypeValueTable);
        if (value_table-&gt;collect_format)
<span class="udiff-line-modified-removed">-     vtable_size += strlen (value_table-&gt;collect_format);</span>
<span class="udiff-line-modified-added">+   vtable_size += strlen (value_table-&gt;collect_format);</span>
        if (value_table-&gt;lcopy_format)
<span class="udiff-line-modified-removed">-     vtable_size += strlen (value_table-&gt;lcopy_format);</span>
<span class="udiff-line-modified-added">+   vtable_size += strlen (value_table-&gt;lcopy_format);</span>
        vtable_size += 2;
      }
  
    if (node-&gt;is_instantiatable) /* careful, is_instantiatable is also is_classed */
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1117,11 +1120,11 @@</span>
  #ifdef GSTREAMER_LITE
        if (data == NULL)
            return;
  #endif // GSTREAMER_LITE
        if (vtable_size)
<span class="udiff-line-modified-removed">-     vtable = G_STRUCT_MEMBER_P (data, sizeof (InstanceData));</span>
<span class="udiff-line-modified-added">+   vtable = G_STRUCT_MEMBER_P (data, sizeof (InstanceData));</span>
        data-&gt;instance.class_size = info-&gt;class_size;
        data-&gt;instance.class_init_base = info-&gt;base_init;
        data-&gt;instance.class_finalize_base = info-&gt;base_finalize;
        data-&gt;instance.class_init = info-&gt;class_init;
        data-&gt;instance.class_finalize = info-&gt;class_finalize;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1143,11 +1146,11 @@</span>
      {
        TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
  
        data = g_malloc0 (sizeof (ClassData) + vtable_size);
        if (vtable_size)
<span class="udiff-line-modified-removed">-     vtable = G_STRUCT_MEMBER_P (data, sizeof (ClassData));</span>
<span class="udiff-line-modified-added">+   vtable = G_STRUCT_MEMBER_P (data, sizeof (ClassData));</span>
        data-&gt;class.class_size = info-&gt;class_size;
        data-&gt;class.class_init_base = info-&gt;base_init;
        data-&gt;class.class_finalize_base = info-&gt;base_finalize;
        data-&gt;class.class_init = info-&gt;class_init;
        data-&gt;class.class_finalize = info-&gt;class_finalize;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1160,11 +1163,11 @@</span>
      }
    else if (NODE_IS_IFACE (node))
      {
        data = g_malloc0 (sizeof (IFaceData) + vtable_size);
        if (vtable_size)
<span class="udiff-line-modified-removed">-     vtable = G_STRUCT_MEMBER_P (data, sizeof (IFaceData));</span>
<span class="udiff-line-modified-added">+   vtable = G_STRUCT_MEMBER_P (data, sizeof (IFaceData));</span>
        data-&gt;iface.vtable_size = info-&gt;class_size;
        data-&gt;iface.vtable_init_base = info-&gt;base_init;
        data-&gt;iface.vtable_finalize_base = info-&gt;base_finalize;
        data-&gt;iface.dflt_init = info-&gt;class_init;
        data-&gt;iface.dflt_finalize = info-&gt;class_finalize;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1173,17 +1176,17 @@</span>
      }
    else if (NODE_IS_BOXED (node))
      {
        data = g_malloc0 (sizeof (BoxedData) + vtable_size);
        if (vtable_size)
<span class="udiff-line-modified-removed">-     vtable = G_STRUCT_MEMBER_P (data, sizeof (BoxedData));</span>
<span class="udiff-line-modified-added">+   vtable = G_STRUCT_MEMBER_P (data, sizeof (BoxedData));</span>
      }
    else
      {
        data = g_malloc0 (sizeof (CommonData) + vtable_size);
        if (vtable_size)
<span class="udiff-line-modified-removed">-     vtable = G_STRUCT_MEMBER_P (data, sizeof (CommonData));</span>
<span class="udiff-line-modified-added">+   vtable = G_STRUCT_MEMBER_P (data, sizeof (CommonData));</span>
      }
  
    node-&gt;data = data;
  
    if (vtable_size)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1197,24 +1200,24 @@</span>
        *vtable = *value_table;
        p = G_STRUCT_MEMBER_P (vtable, sizeof (*vtable));
        p[0] = 0;
        vtable-&gt;collect_format = p;
        if (value_table-&gt;collect_format)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       strcat (p, value_table-&gt;collect_format);</span>
<span class="udiff-line-modified-removed">-       p += strlen (value_table-&gt;collect_format);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     strcat (p, value_table-&gt;collect_format);</span>
<span class="udiff-line-modified-added">+     p += strlen (value_table-&gt;collect_format);</span>
<span class="udiff-line-modified-added">+   }</span>
        p++;
        p[0] = 0;
        vtable-&gt;lcopy_format = p;
        if (value_table-&gt;lcopy_format)
<span class="udiff-line-modified-removed">-     strcat  (p, value_table-&gt;lcopy_format);</span>
<span class="udiff-line-modified-added">+   strcat  (p, value_table-&gt;lcopy_format);</span>
      }
    node-&gt;data-&gt;common.value_table = vtable;
    node-&gt;mutatable_check_cache = (node-&gt;data-&gt;common.value_table-&gt;value_init != NULL &amp;&amp;
<span class="udiff-line-modified-removed">-                  !((G_TYPE_FLAG_VALUE_ABSTRACT | G_TYPE_FLAG_ABSTRACT) &amp;</span>
<span class="udiff-line-modified-removed">-                    GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))));</span>
<span class="udiff-line-modified-added">+          !((G_TYPE_FLAG_VALUE_ABSTRACT | G_TYPE_FLAG_ABSTRACT) &amp;</span>
<span class="udiff-line-modified-added">+            GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))));</span>
  
    g_assert (node-&gt;data-&gt;common.value_table != NULL); /* paranoid */
  
    g_atomic_int_set ((int *) &amp;node-&gt;ref_count, 1);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1229,30 +1232,30 @@</span>
        GTypeValueTable tmp_value_table;
  
        g_assert (node-&gt;plugin != NULL);
  
        if (pnode)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       type_data_ref_Wm (pnode);</span>
<span class="udiff-line-modified-removed">-       if (node-&gt;data)</span>
<span class="udiff-line-modified-removed">-         INVALID_RECURSION (&quot;g_type_plugin_*&quot;, node-&gt;plugin, NODE_NAME (node));</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     type_data_ref_Wm (pnode);</span>
<span class="udiff-line-modified-added">+     if (node-&gt;data)</span>
<span class="udiff-line-modified-added">+       INVALID_RECURSION (&quot;g_type_plugin_*&quot;, node-&gt;plugin, NODE_NAME (node));</span>
<span class="udiff-line-modified-added">+   }</span>
  
        memset (&amp;tmp_info, 0, sizeof (tmp_info));
        memset (&amp;tmp_value_table, 0, sizeof (tmp_value_table));
  
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_type_plugin_use (node-&gt;plugin);
        g_type_plugin_complete_type_info (node-&gt;plugin, NODE_TYPE (node), &amp;tmp_info, &amp;tmp_value_table);
        G_WRITE_LOCK (&amp;type_rw_lock);
        if (node-&gt;data)
<span class="udiff-line-modified-removed">-     INVALID_RECURSION (&quot;g_type_plugin_*&quot;, node-&gt;plugin, NODE_NAME (node));</span>
<span class="udiff-line-modified-added">+   INVALID_RECURSION (&quot;g_type_plugin_*&quot;, node-&gt;plugin, NODE_NAME (node));</span>
  
        check_type_info_I (pnode, NODE_FUNDAMENTAL_TYPE (node), NODE_NAME (node), &amp;tmp_info);
        type_data_make_W (node, &amp;tmp_info,
<span class="udiff-line-modified-removed">-             check_value_table_I (NODE_NAME (node),</span>
<span class="udiff-line-modified-removed">-                          &amp;tmp_value_table) ? &amp;tmp_value_table : NULL);</span>
<span class="udiff-line-modified-added">+       check_value_table_I (NODE_NAME (node),</span>
<span class="udiff-line-modified-added">+                &amp;tmp_value_table) ? &amp;tmp_value_table : NULL);</span>
      }
    else
      {
        g_assert (NODE_REFCOUNT (node) &gt; 0);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1275,12 +1278,12 @@</span>
    return TRUE;
  }
  
  static gboolean
  iface_node_has_available_offset_L (TypeNode *iface_node,
<span class="udiff-line-modified-removed">-                    int offset,</span>
<span class="udiff-line-modified-removed">-                    int for_index)</span>
<span class="udiff-line-modified-added">+            int offset,</span>
<span class="udiff-line-modified-added">+            int for_index)</span>
  {
    guint8 *offsets;
  
    offsets = G_ATOMIC_ARRAY_GET_LOCKED (&amp;iface_node-&gt;_prot.offsets, guint8);
    if (offsets == NULL)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1309,27 +1312,27 @@</span>
    offset = -1;
    do
      {
        offset++;
        for (i = 0; i &lt; n_entries; i++)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       entry = &amp;entries-&gt;entry[i];</span>
<span class="udiff-line-modified-removed">-       iface_node = lookup_type_node_I (entry-&gt;iface_type);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     entry = &amp;entries-&gt;entry[i];</span>
<span class="udiff-line-modified-added">+     iface_node = lookup_type_node_I (entry-&gt;iface_type);</span>
  
<span class="udiff-line-modified-removed">-       if (!iface_node_has_available_offset_L (iface_node, offset, i))</span>
<span class="udiff-line-modified-removed">-         break;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     if (!iface_node_has_available_offset_L (iface_node, offset, i))</span>
<span class="udiff-line-modified-added">+       break;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    while (i != n_entries);
  
    return offset;
  }
  
  static void
  iface_node_set_offset_L (TypeNode *iface_node,
<span class="udiff-line-modified-removed">-              int offset,</span>
<span class="udiff-line-modified-removed">-              int index)</span>
<span class="udiff-line-modified-added">+        int offset,</span>
<span class="udiff-line-modified-added">+        int index)</span>
  {
    guint8 *offsets, *old_offsets;
    int new_size, old_size;
    int i;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1338,17 +1341,17 @@</span>
      old_size = 0;
    else
      {
        old_size = G_ATOMIC_ARRAY_DATA_SIZE (old_offsets);
        if (offset &lt; old_size &amp;&amp;
<span class="udiff-line-modified-removed">-       old_offsets[offset] == index + 1)</span>
<span class="udiff-line-modified-removed">-     return; /* Already set to this index, return */</span>
<span class="udiff-line-modified-added">+     old_offsets[offset] == index + 1)</span>
<span class="udiff-line-modified-added">+   return; /* Already set to this index, return */</span>
      }
    new_size = MAX (old_size, offset + 1);
  
    offsets = _g_atomic_array_copy (&amp;iface_node-&gt;_prot.offsets,
<span class="udiff-line-modified-removed">-                   0, new_size - old_size);</span>
<span class="udiff-line-modified-added">+           0, new_size - old_size);</span>
  
    /* Mark new area as unused */
    for (i = old_size; i &lt; new_size; i++)
      offsets[i] = 0;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1357,11 +1360,11 @@</span>
    _g_atomic_array_update (&amp;iface_node-&gt;_prot.offsets, offsets);
  }
  
  static void
  type_node_add_iface_entry_W (TypeNode   *node,
<span class="udiff-line-modified-removed">-                  GType       iface_type,</span>
<span class="udiff-line-modified-added">+            GType       iface_type,</span>
                               IFaceEntry *parent_entry)
  {
    IFaceEntries *entries;
    IFaceEntry *entry;
    TypeNode *iface_node;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1376,38 +1379,38 @@</span>
        num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
  
        g_assert (num_entries &lt; MAX_N_INTERFACES);
  
        for (i = 0; i &lt; num_entries; i++)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       entry = &amp;entries-&gt;entry[i];</span>
<span class="udiff-line-modified-removed">-       if (entry-&gt;iface_type == iface_type)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           /* this can happen in two cases:</span>
<span class="udiff-line-modified-removed">-            * - our parent type already conformed to iface_type and node</span>
<span class="udiff-line-modified-removed">-            *   got its own holder info. here, our children already have</span>
<span class="udiff-line-modified-removed">-            *   entries and NULL vtables, since this will only work for</span>
<span class="udiff-line-modified-removed">-            *   uninitialized classes.</span>
<span class="udiff-line-modified-removed">-            * - an interface type is added to an ancestor after it was</span>
<span class="udiff-line-modified-removed">-            *   added to a child type.</span>
<span class="udiff-line-modified-removed">-            */</span>
<span class="udiff-line-modified-removed">-           if (!parent_entry)</span>
<span class="udiff-line-modified-removed">-         g_assert (entry-&gt;vtable == NULL &amp;&amp; entry-&gt;init_state == UNINITIALIZED);</span>
<span class="udiff-line-modified-removed">-           else</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           /* sick, interface is added to ancestor *after* child type;</span>
<span class="udiff-line-modified-removed">-            * nothing todo, the entry and our children were already setup correctly</span>
<span class="udiff-line-modified-removed">-            */</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-           return;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     entry = &amp;entries-&gt;entry[i];</span>
<span class="udiff-line-modified-added">+     if (entry-&gt;iface_type == iface_type)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         /* this can happen in two cases:</span>
<span class="udiff-line-modified-added">+          * - our parent type already conformed to iface_type and node</span>
<span class="udiff-line-modified-added">+          *   got its own holder info. here, our children already have</span>
<span class="udiff-line-modified-added">+          *   entries and NULL vtables, since this will only work for</span>
<span class="udiff-line-modified-added">+          *   uninitialized classes.</span>
<span class="udiff-line-modified-added">+          * - an interface type is added to an ancestor after it was</span>
<span class="udiff-line-modified-added">+          *   added to a child type.</span>
<span class="udiff-line-modified-added">+          */</span>
<span class="udiff-line-modified-added">+         if (!parent_entry)</span>
<span class="udiff-line-modified-added">+     g_assert (entry-&gt;vtable == NULL &amp;&amp; entry-&gt;init_state == UNINITIALIZED);</span>
<span class="udiff-line-modified-added">+         else</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       /* sick, interface is added to ancestor *after* child type;</span>
<span class="udiff-line-modified-added">+        * nothing todo, the entry and our children were already setup correctly</span>
<span class="udiff-line-modified-added">+        */</span>
      }
<span class="udiff-line-added">+         return;</span>
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+   }</span>
      }
  
    entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (node),
<span class="udiff-line-modified-removed">-                   IFACE_ENTRIES_HEADER_SIZE,</span>
<span class="udiff-line-modified-removed">-                   sizeof (IFaceEntry));</span>
<span class="udiff-line-modified-added">+           IFACE_ENTRIES_HEADER_SIZE,</span>
<span class="udiff-line-modified-added">+           sizeof (IFaceEntry));</span>
    num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
    i = num_entries - 1;
    if (i == 0)
      entries-&gt;offset_index = 0;
    entries-&gt;entry[i].iface_type = iface_type;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1425,28 +1428,28 @@</span>
  
    /* Update offsets in iface */
    iface_node = lookup_type_node_I (iface_type);
  
    if (iface_node_has_available_offset_L (iface_node,
<span class="udiff-line-modified-removed">-                      entries-&gt;offset_index,</span>
<span class="udiff-line-modified-removed">-                      i))</span>
<span class="udiff-line-modified-added">+            entries-&gt;offset_index,</span>
<span class="udiff-line-modified-added">+            i))</span>
      {
        iface_node_set_offset_L (iface_node,
<span class="udiff-line-modified-removed">-                    entries-&gt;offset_index, i);</span>
<span class="udiff-line-modified-added">+              entries-&gt;offset_index, i);</span>
      }
    else
     {
        entries-&gt;offset_index =
<span class="udiff-line-modified-removed">-     find_free_iface_offset_L (entries);</span>
<span class="udiff-line-modified-added">+   find_free_iface_offset_L (entries);</span>
        for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (entries); j++)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       entry = &amp;entries-&gt;entry[j];</span>
<span class="udiff-line-modified-removed">-       iface_node =</span>
<span class="udiff-line-modified-removed">-         lookup_type_node_I (entry-&gt;iface_type);</span>
<span class="udiff-line-modified-removed">-       iface_node_set_offset_L (iface_node,</span>
<span class="udiff-line-modified-removed">-                    entries-&gt;offset_index, j);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     entry = &amp;entries-&gt;entry[j];</span>
<span class="udiff-line-modified-added">+     iface_node =</span>
<span class="udiff-line-modified-added">+       lookup_type_node_I (entry-&gt;iface_type);</span>
<span class="udiff-line-modified-added">+     iface_node_set_offset_L (iface_node,</span>
<span class="udiff-line-modified-added">+            entries-&gt;offset_index, j);</span>
<span class="udiff-line-modified-added">+   }</span>
      }
  
    _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node), entries);
  
    if (parent_entry)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1497,30 +1500,30 @@</span>
      type_node_add_iface_entry_W (lookup_type_node_I (node-&gt;children[i]), NODE_TYPE (iface), entry);
  }
  
  static void
  type_iface_add_prerequisite_W (TypeNode *iface,
<span class="udiff-line-modified-removed">-                    TypeNode *prerequisite_node)</span>
<span class="udiff-line-modified-added">+              TypeNode *prerequisite_node)</span>
  {
    GType prerequisite_type = NODE_TYPE (prerequisite_node);
    GType *prerequisites, *dependants;
    guint n_dependants, i;
  
    g_assert (NODE_IS_IFACE (iface) &amp;&amp;
<span class="udiff-line-modified-removed">-         IFACE_NODE_N_PREREQUISITES (iface) &lt; MAX_N_PREREQUISITES &amp;&amp;</span>
<span class="udiff-line-modified-removed">-         (prerequisite_node-&gt;is_instantiatable || NODE_IS_IFACE (prerequisite_node)));</span>
<span class="udiff-line-modified-added">+       IFACE_NODE_N_PREREQUISITES (iface) &lt; MAX_N_PREREQUISITES &amp;&amp;</span>
<span class="udiff-line-modified-added">+       (prerequisite_node-&gt;is_instantiatable || NODE_IS_IFACE (prerequisite_node)));</span>
  
    prerequisites = IFACE_NODE_PREREQUISITES (iface);
    for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
      if (prerequisites[i] == prerequisite_type)
<span class="udiff-line-modified-removed">-       return;           /* we already have that prerequisiste */</span>
<span class="udiff-line-modified-added">+       return;     /* we already have that prerequisiste */</span>
      else if (prerequisites[i] &gt; prerequisite_type)
        break;
    IFACE_NODE_N_PREREQUISITES (iface) += 1;
    IFACE_NODE_PREREQUISITES (iface) = g_renew (GType,
<span class="udiff-line-modified-removed">-                           IFACE_NODE_PREREQUISITES (iface),</span>
<span class="udiff-line-modified-removed">-                           IFACE_NODE_N_PREREQUISITES (iface));</span>
<span class="udiff-line-modified-added">+                 IFACE_NODE_PREREQUISITES (iface),</span>
<span class="udiff-line-modified-added">+                 IFACE_NODE_N_PREREQUISITES (iface));</span>
    prerequisites = IFACE_NODE_PREREQUISITES (iface);
    memmove (prerequisites + i + 1, prerequisites + i,
             sizeof (prerequisites[0]) * (IFACE_NODE_N_PREREQUISITES (iface) - i - 1));
    prerequisites[i] = prerequisite_type;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1554,11 +1557,11 @@</span>
   * interface derivation (which GType doesn&#39;t support). An interface can have
   * at most one instantiatable prerequisite type.
   */
  void
  g_type_interface_add_prerequisite (GType interface_type,
<span class="udiff-line-modified-removed">-                    GType prerequisite_type)</span>
<span class="udiff-line-modified-added">+            GType prerequisite_type)</span>
  {
    TypeNode *iface, *prerequisite_node;
    IFaceHolder *holders;
  
    g_return_if_fail (G_TYPE_IS_INTERFACE (interface_type));  /* G_TYPE_IS_INTERFACE() is an external call: _U */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1568,66 +1571,66 @@</span>
    iface = lookup_type_node_I (interface_type);
    prerequisite_node = lookup_type_node_I (prerequisite_type);
    if (!iface || !prerequisite_node || !NODE_IS_IFACE (iface))
      {
        g_warning (&quot;interface type &#39;%s&#39; or prerequisite type &#39;%s&#39; invalid&quot;,
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (interface_type),</span>
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (prerequisite_type));</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (interface_type),</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (prerequisite_type));</span>
        return;
      }
    G_WRITE_LOCK (&amp;type_rw_lock);
    holders = iface_node_get_holders_L (iface);
    if (holders)
      {
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_warning (&quot;unable to add prerequisite &#39;%s&#39; to interface &#39;%s&#39; which is already in use for &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (prerequisite_type),</span>
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (interface_type),</span>
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (holders-&gt;instance_type));</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (prerequisite_type),</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (interface_type),</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (holders-&gt;instance_type));</span>
        return;
      }
    if (prerequisite_node-&gt;is_instantiatable)
      {
        guint i;
  
        /* can have at most one publicly installable instantiatable prerequisite */
        for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       TypeNode *prnode = lookup_type_node_I (IFACE_NODE_PREREQUISITES (iface)[i]);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     TypeNode *prnode = lookup_type_node_I (IFACE_NODE_PREREQUISITES (iface)[i]);</span>
  
<span class="udiff-line-modified-removed">-       if (prnode-&gt;is_instantiatable)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           G_WRITE_UNLOCK (&amp;type_rw_lock);</span>
<span class="udiff-line-modified-removed">-           g_warning (&quot;adding prerequisite &#39;%s&#39; to interface &#39;%s&#39; conflicts with existing prerequisite &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-              type_descriptive_name_I (prerequisite_type),</span>
<span class="udiff-line-modified-removed">-              type_descriptive_name_I (interface_type),</span>
<span class="udiff-line-modified-removed">-              type_descriptive_name_I (NODE_TYPE (prnode)));</span>
<span class="udiff-line-modified-removed">-           return;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     if (prnode-&gt;is_instantiatable)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         G_WRITE_UNLOCK (&amp;type_rw_lock);</span>
<span class="udiff-line-modified-added">+         g_warning (&quot;adding prerequisite &#39;%s&#39; to interface &#39;%s&#39; conflicts with existing prerequisite &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+        type_descriptive_name_I (prerequisite_type),</span>
<span class="udiff-line-modified-added">+        type_descriptive_name_I (interface_type),</span>
<span class="udiff-line-modified-added">+        type_descriptive_name_I (NODE_TYPE (prnode)));</span>
<span class="udiff-line-modified-added">+         return;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+   }</span>
  
        for (i = 0; i &lt; prerequisite_node-&gt;n_supers + 1; i++)
<span class="udiff-line-modified-removed">-     type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisite_node-&gt;supers[i]));</span>
<span class="udiff-line-modified-added">+   type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisite_node-&gt;supers[i]));</span>
        G_WRITE_UNLOCK (&amp;type_rw_lock);
      }
    else if (NODE_IS_IFACE (prerequisite_node))
      {
        GType *prerequisites;
        guint i;
  
        prerequisites = IFACE_NODE_PREREQUISITES (prerequisite_node);
        for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (prerequisite_node); i++)
<span class="udiff-line-modified-removed">-     type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisites[i]));</span>
<span class="udiff-line-modified-added">+   type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisites[i]));</span>
        type_iface_add_prerequisite_W (iface, prerequisite_node);
        G_WRITE_UNLOCK (&amp;type_rw_lock);
      }
    else
      {
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_warning (&quot;prerequisite &#39;%s&#39; for interface &#39;%s&#39; is neither instantiatable nor interface&quot;,
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (prerequisite_type),</span>
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (interface_type));</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (prerequisite_type),</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (interface_type));</span>
      }
  }
  
  /**
   * g_type_interface_prerequisites:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1643,11 +1646,11 @@</span>
   *     newly-allocated zero-terminated array of #GType containing
   *     the prerequisites of @interface_type
   */
  GType*
  g_type_interface_prerequisites (GType  interface_type,
<span class="udiff-line-modified-removed">-                 guint *n_prerequisites)</span>
<span class="udiff-line-modified-added">+         guint *n_prerequisites)</span>
  {
    TypeNode *iface;
  
    g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1659,43 +1662,43 @@</span>
        guint i, n = 0;
  
        G_READ_LOCK (&amp;type_rw_lock);
        types = g_new0 (GType, IFACE_NODE_N_PREREQUISITES (iface) + 1);
        for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       GType prerequisite = IFACE_NODE_PREREQUISITES (iface)[i];</span>
<span class="udiff-line-modified-removed">-       TypeNode *node = lookup_type_node_I (prerequisite);</span>
<span class="udiff-line-modified-removed">-       if (node-&gt;is_instantiatable)</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     GType prerequisite = IFACE_NODE_PREREQUISITES (iface)[i];</span>
<span class="udiff-line-modified-added">+     TypeNode *node = lookup_type_node_I (prerequisite);</span>
<span class="udiff-line-modified-added">+     if (node-&gt;is_instantiatable)</span>
              {
                if (!inode || type_node_is_a_L (node, inode))
<span class="udiff-line-modified-removed">-             inode = node;</span>
<span class="udiff-line-modified-added">+           inode = node;</span>
              }
<span class="udiff-line-modified-removed">-       else</span>
<span class="udiff-line-modified-removed">-         types[n++] = NODE_TYPE (node);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     else</span>
<span class="udiff-line-modified-added">+       types[n++] = NODE_TYPE (node);</span>
<span class="udiff-line-modified-added">+   }</span>
        if (inode)
<span class="udiff-line-modified-removed">-     types[n++] = NODE_TYPE (inode);</span>
<span class="udiff-line-modified-added">+   types[n++] = NODE_TYPE (inode);</span>
  
        if (n_prerequisites)
<span class="udiff-line-modified-removed">-     *n_prerequisites = n;</span>
<span class="udiff-line-modified-added">+   *n_prerequisites = n;</span>
        G_READ_UNLOCK (&amp;type_rw_lock);
  
        return types;
      }
    else
      {
        if (n_prerequisites)
<span class="udiff-line-modified-removed">-     *n_prerequisites = 0;</span>
<span class="udiff-line-modified-added">+   *n_prerequisites = 0;</span>
  
        return NULL;
      }
  }
  
  
  static IFaceHolder*
  type_iface_peek_holder_L (TypeNode *iface,
<span class="udiff-line-modified-removed">-               GType     instance_type)</span>
<span class="udiff-line-modified-added">+         GType     instance_type)</span>
  {
    IFaceHolder *iholder;
  
    g_assert (NODE_IS_IFACE (iface));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1705,12 +1708,12 @@</span>
    return iholder;
  }
  
  static IFaceHolder*
  type_iface_retrieve_holder_info_Wm (TypeNode *iface,
<span class="udiff-line-modified-removed">-                     GType     instance_type,</span>
<span class="udiff-line-modified-removed">-                     gboolean  need_info)</span>
<span class="udiff-line-modified-added">+             GType     instance_type,</span>
<span class="udiff-line-modified-added">+             gboolean  need_info)</span>
  {
    IFaceHolder *iholder = type_iface_peek_holder_L (iface, instance_type);
  
    if (iholder &amp;&amp; !iholder-&gt;info &amp;&amp; need_info)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1718,11 +1721,11 @@</span>
  
        g_assert (iholder-&gt;plugin != NULL);
  
        type_data_ref_Wm (iface);
        if (iholder-&gt;info)
<span class="udiff-line-modified-removed">-     INVALID_RECURSION (&quot;g_type_plugin_*&quot;, iface-&gt;plugin, NODE_NAME (iface));</span>
<span class="udiff-line-modified-added">+   INVALID_RECURSION (&quot;g_type_plugin_*&quot;, iface-&gt;plugin, NODE_NAME (iface));</span>
  
        memset (&amp;tmp_info, 0, sizeof (tmp_info));
  
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_type_plugin_use (iholder-&gt;plugin);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1733,16 +1736,16 @@</span>
  
        check_interface_info_I (iface, instance_type, &amp;tmp_info);
        iholder-&gt;info = g_memdup (&amp;tmp_info, sizeof (tmp_info));
      }
  
<span class="udiff-line-modified-removed">-   return iholder;   /* we don&#39;t modify write lock upon returning NULL */</span>
<span class="udiff-line-modified-added">+   return iholder; /* we don&#39;t modify write lock upon returning NULL */</span>
  }
  
  static void
  type_iface_blow_holder_info_Wm (TypeNode *iface,
<span class="udiff-line-modified-removed">-                 GType     instance_type)</span>
<span class="udiff-line-modified-added">+         GType     instance_type)</span>
  {
    IFaceHolder *iholder = iface_node_get_holders_L (iface);
  
    g_assert (NODE_IS_IFACE (iface));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1803,17 +1806,17 @@</span>
  
    node = lookup_type_node_I (type);
    if (!node || !node-&gt;is_instantiatable)
      {
        g_error (&quot;cannot create new instance of invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (type));</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (type));</span>
      }
    /* G_TYPE_IS_ABSTRACT() is an external call: _U */
    if (!node-&gt;mutatable_check_cache &amp;&amp; G_TYPE_IS_ABSTRACT (type))
      {
        g_error (&quot;cannot create instance of abstract (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (type));</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (type));</span>
      }
  
    class = g_type_class_ref (type);
  
    /* We allocate the &#39;private&#39; areas before the normal instance data, in
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1860,14 +1863,14 @@</span>
      {
        TypeNode *pnode;
  
        pnode = lookup_type_node_I (node-&gt;supers[i]);
        if (pnode-&gt;data-&gt;instance.instance_init)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       instance-&gt;g_class = pnode-&gt;data-&gt;instance.class;</span>
<span class="udiff-line-modified-removed">-       pnode-&gt;data-&gt;instance.instance_init (instance, class);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     instance-&gt;g_class = pnode-&gt;data-&gt;instance.class;</span>
<span class="udiff-line-modified-added">+     pnode-&gt;data-&gt;instance.instance_init (instance, class);</span>
<span class="udiff-line-modified-added">+   }</span>
      }
  
    instance-&gt;g_class = class;
    if (node-&gt;data-&gt;instance.instance_init)
      node-&gt;data-&gt;instance.instance_init (instance, class);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1908,18 +1911,18 @@</span>
    class = instance-&gt;g_class;
    node = lookup_type_node_I (class-&gt;g_type);
    if (!node || !node-&gt;is_instantiatable || !node-&gt;data || node-&gt;data-&gt;class.class != (gpointer) class)
      {
        g_warning (&quot;cannot free instance of invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (class-&gt;g_type));</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (class-&gt;g_type));</span>
        return;
      }
    /* G_TYPE_IS_ABSTRACT() is an external call: _U */
    if (!node-&gt;mutatable_check_cache &amp;&amp; G_TYPE_IS_ABSTRACT (NODE_TYPE (node)))
      {
        g_warning (&quot;cannot free instance of abstract (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          NODE_NAME (node));</span>
<span class="udiff-line-modified-added">+      NODE_NAME (node));</span>
        return;
      }
  
    instance-&gt;g_class = NULL;
    private_size = node-&gt;data-&gt;instance.private_size;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1998,21 +2001,21 @@</span>
   * be used. Note that the write lock is not modified upon a FALSE
   * return.
   */
  static gboolean
  type_iface_vtable_base_init_Wm (TypeNode *iface,
<span class="udiff-line-modified-removed">-                 TypeNode *node)</span>
<span class="udiff-line-modified-added">+         TypeNode *node)</span>
  {
    IFaceEntry *entry;
    IFaceHolder *iholder;
    GTypeInterface *vtable = NULL;
    TypeNode *pnode;
  
    /* type_iface_retrieve_holder_info_Wm() doesn&#39;t modify write lock for returning NULL */
    iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), TRUE);
    if (!iholder)
<span class="udiff-line-modified-removed">-     return FALSE;   /* we don&#39;t modify write lock upon FALSE */</span>
<span class="udiff-line-modified-added">+     return FALSE; /* we don&#39;t modify write lock upon FALSE */</span>
  
    type_iface_ensure_dflt_vtable_Wm (iface);
  
    entry = type_lookup_iface_entry_L (node, iface);
  #ifdef GSTREAMER_LITE
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2023,16 +2026,16 @@</span>
    g_assert (iface-&gt;data &amp;&amp; entry &amp;&amp; entry-&gt;vtable == NULL &amp;&amp; iholder &amp;&amp; iholder-&gt;info);
  
    entry-&gt;init_state = IFACE_INIT;
  
    pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
<span class="udiff-line-modified-removed">-   if (pnode)    /* want to copy over parent iface contents */</span>
<span class="udiff-line-modified-added">+   if (pnode)  /* want to copy over parent iface contents */</span>
      {
        IFaceEntry *pentry = type_lookup_iface_entry_L (pnode, iface);
  
        if (pentry)
<span class="udiff-line-modified-removed">-     vtable = g_memdup (pentry-&gt;vtable, iface-&gt;data-&gt;iface.vtable_size);</span>
<span class="udiff-line-modified-added">+   vtable = g_memdup (pentry-&gt;vtable, iface-&gt;data-&gt;iface.vtable_size);</span>
      }
    if (!vtable)
      vtable = g_memdup (iface-&gt;data-&gt;iface.dflt_vtable, iface-&gt;data-&gt;iface.vtable_size);
    entry-&gt;vtable = vtable;
    vtable-&gt;g_type = NODE_TYPE (iface);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2053,11 +2056,11 @@</span>
   * own interface holder info, i.e. types for which
   * g_type_add_interface*() was called and not children thereof.
   */
  static void
  type_iface_vtable_iface_init_Wm (TypeNode *iface,
<span class="udiff-line-modified-removed">-                  TypeNode *node)</span>
<span class="udiff-line-modified-added">+          TypeNode *node)</span>
  {
    IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
    IFaceHolder *iholder = type_iface_peek_holder_L (iface, NODE_TYPE (node));
    GTypeInterface *vtable = NULL;
    guint i;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2076,11 +2079,11 @@</span>
  
    if (iholder-&gt;info-&gt;interface_init)
      {
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        if (iholder-&gt;info-&gt;interface_init)
<span class="udiff-line-modified-removed">-     iholder-&gt;info-&gt;interface_init (vtable, iholder-&gt;info-&gt;interface_data);</span>
<span class="udiff-line-modified-added">+   iholder-&gt;info-&gt;interface_init (vtable, iholder-&gt;info-&gt;interface_data);</span>
        G_WRITE_LOCK (&amp;type_rw_lock);
      }
  
    for (i = 0; i &lt; static_n_iface_check_funcs; i++)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2093,32 +2096,32 @@</span>
      }
  }
  
  static gboolean
  type_iface_vtable_finalize_Wm (TypeNode       *iface,
<span class="udiff-line-modified-removed">-                    TypeNode       *node,</span>
<span class="udiff-line-modified-removed">-                    GTypeInterface *vtable)</span>
<span class="udiff-line-modified-added">+              TypeNode       *node,</span>
<span class="udiff-line-modified-added">+              GTypeInterface *vtable)</span>
  {
    IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
    IFaceHolder *iholder;
  
    /* type_iface_retrieve_holder_info_Wm() doesn&#39;t modify write lock for returning NULL */
    iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), FALSE);
    if (!iholder)
<span class="udiff-line-modified-removed">-     return FALSE;   /* we don&#39;t modify write lock upon FALSE */</span>
<span class="udiff-line-modified-added">+     return FALSE; /* we don&#39;t modify write lock upon FALSE */</span>
  
    g_assert (entry &amp;&amp; entry-&gt;vtable == vtable &amp;&amp; iholder-&gt;info);
  
    entry-&gt;vtable = NULL;
    entry-&gt;init_state = UNINITIALIZED;
    if (iholder-&gt;info-&gt;interface_finalize || iface-&gt;data-&gt;iface.vtable_finalize_base)
      {
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        if (iholder-&gt;info-&gt;interface_finalize)
<span class="udiff-line-modified-removed">-     iholder-&gt;info-&gt;interface_finalize (vtable, iholder-&gt;info-&gt;interface_data);</span>
<span class="udiff-line-modified-added">+   iholder-&gt;info-&gt;interface_finalize (vtable, iholder-&gt;info-&gt;interface_data);</span>
        if (iface-&gt;data-&gt;iface.vtable_finalize_base)
<span class="udiff-line-modified-removed">-     iface-&gt;data-&gt;iface.vtable_finalize_base (vtable);</span>
<span class="udiff-line-modified-added">+   iface-&gt;data-&gt;iface.vtable_finalize_base (vtable);</span>
        G_WRITE_LOCK (&amp;type_rw_lock);
      }
    vtable-&gt;g_type = 0;
    vtable-&gt;g_instance_type = 0;
    g_free (vtable);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2128,11 +2131,11 @@</span>
    return TRUE;  /* write lock modified */
  }
  
  static void
  type_class_init_Wm (TypeNode   *node,
<span class="udiff-line-modified-removed">-             GTypeClass *pclass)</span>
<span class="udiff-line-modified-added">+         GTypeClass *pclass)</span>
  {
    GSList *slist, *init_slist = NULL;
    GTypeClass *class;
    IFaceEntries *entries;
    IFaceEntry *entry;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2141,13 +2144,13 @@</span>
  
    /* Accessing data-&gt;class will work for instantiable types
     * too because ClassData is a subset of InstanceData
     */
    g_assert (node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp;
<span class="udiff-line-modified-removed">-         node-&gt;data-&gt;class.class_size &amp;&amp;</span>
<span class="udiff-line-modified-removed">-         !node-&gt;data-&gt;class.class &amp;&amp;</span>
<span class="udiff-line-modified-removed">-         node-&gt;data-&gt;class.init_state == UNINITIALIZED);</span>
<span class="udiff-line-modified-added">+       node-&gt;data-&gt;class.class_size &amp;&amp;</span>
<span class="udiff-line-modified-added">+       !node-&gt;data-&gt;class.class &amp;&amp;</span>
<span class="udiff-line-modified-added">+       node-&gt;data-&gt;class.init_state == UNINITIALIZED);</span>
    if (node-&gt;data-&gt;class.class_private_size)
      class = g_malloc0 (ALIGN_STRUCT (node-&gt;data-&gt;class.class_size) + node-&gt;data-&gt;class.class_private_size);
    else
      class = g_malloc0 (node-&gt;data-&gt;class.class_size);
    node-&gt;data-&gt;class.class = class;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2159,17 +2162,17 @@</span>
  
        memcpy (class, pclass, pnode-&gt;data-&gt;class.class_size);
        memcpy (G_STRUCT_MEMBER_P (class, ALIGN_STRUCT (node-&gt;data-&gt;class.class_size)), G_STRUCT_MEMBER_P (pclass, ALIGN_STRUCT (pnode-&gt;data-&gt;class.class_size)), pnode-&gt;data-&gt;class.class_private_size);
  
        if (node-&gt;is_instantiatable)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       /* We need to initialize the private_size here rather than in</span>
<span class="udiff-line-modified-removed">-        * type_data_make_W() since the class init for the parent</span>
<span class="udiff-line-modified-removed">-        * class may have changed pnode-&gt;data-&gt;instance.private_size.</span>
<span class="udiff-line-modified-removed">-        */</span>
<span class="udiff-line-modified-removed">-       node-&gt;data-&gt;instance.private_size = pnode-&gt;data-&gt;instance.private_size;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     /* We need to initialize the private_size here rather than in</span>
<span class="udiff-line-modified-added">+      * type_data_make_W() since the class init for the parent</span>
<span class="udiff-line-modified-added">+      * class may have changed pnode-&gt;data-&gt;instance.private_size.</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     node-&gt;data-&gt;instance.private_size = pnode-&gt;data-&gt;instance.private_size;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    class-&gt;g_type = NODE_TYPE (node);
  
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2196,47 +2199,47 @@</span>
     */
    pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
  
    i = 0;
    while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL &amp;&amp;
<span class="udiff-line-modified-removed">-       i &lt; IFACE_ENTRIES_N_ENTRIES (entries))</span>
<span class="udiff-line-modified-added">+     i &lt; IFACE_ENTRIES_N_ENTRIES (entries))</span>
      {
        entry = &amp;entries-&gt;entry[i];
        while (i &lt; IFACE_ENTRIES_N_ENTRIES (entries) &amp;&amp;
<span class="udiff-line-modified-removed">-          entry-&gt;init_state == IFACE_INIT)</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       entry++;</span>
<span class="udiff-line-modified-removed">-       i++;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+        entry-&gt;init_state == IFACE_INIT)</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     entry++;</span>
<span class="udiff-line-modified-added">+     i++;</span>
<span class="udiff-line-modified-added">+   }</span>
  
        if (i == IFACE_ENTRIES_N_ENTRIES (entries))
<span class="udiff-line-modified-removed">-     break;</span>
<span class="udiff-line-modified-added">+   break;</span>
  
        if (!type_iface_vtable_base_init_Wm (lookup_type_node_I (entry-&gt;iface_type), node))
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       guint j;</span>
<span class="udiff-line-modified-removed">-       IFaceEntries *pentries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (pnode);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     guint j;</span>
<span class="udiff-line-modified-added">+     IFaceEntries *pentries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (pnode);</span>
  
<span class="udiff-line-modified-removed">-       /* need to get this interface from parent, type_iface_vtable_base_init_Wm()</span>
<span class="udiff-line-modified-removed">-        * doesn&#39;t modify write lock upon FALSE, so entry is still valid;</span>
<span class="udiff-line-modified-removed">-        */</span>
<span class="udiff-line-modified-removed">-       g_assert (pnode != NULL);</span>
<span class="udiff-line-modified-added">+     /* need to get this interface from parent, type_iface_vtable_base_init_Wm()</span>
<span class="udiff-line-modified-added">+      * doesn&#39;t modify write lock upon FALSE, so entry is still valid;</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     g_assert (pnode != NULL);</span>
  
<span class="udiff-line-modified-removed">-       if (pentries)</span>
<span class="udiff-line-modified-removed">-         for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (pentries); j++)</span>
<span class="udiff-line-modified-removed">-           {</span>
<span class="udiff-line-modified-removed">-         IFaceEntry *pentry = &amp;pentries-&gt;entry[j];</span>
<span class="udiff-line-modified-added">+     if (pentries)</span>
<span class="udiff-line-modified-added">+       for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (pentries); j++)</span>
<span class="udiff-line-modified-added">+         {</span>
<span class="udiff-line-modified-added">+     IFaceEntry *pentry = &amp;pentries-&gt;entry[j];</span>
  
<span class="udiff-line-modified-removed">-         if (pentry-&gt;iface_type == entry-&gt;iface_type)</span>
<span class="udiff-line-modified-removed">-           {</span>
<span class="udiff-line-modified-removed">-             entry-&gt;vtable = pentry-&gt;vtable;</span>
<span class="udiff-line-modified-removed">-             entry-&gt;init_state = INITIALIZED;</span>
<span class="udiff-line-modified-removed">-             break;</span>
<span class="udiff-line-modified-removed">-           }</span>
<span class="udiff-line-modified-removed">-           }</span>
<span class="udiff-line-modified-removed">-       g_assert (entry-&gt;vtable != NULL);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     if (pentry-&gt;iface_type == entry-&gt;iface_type)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         entry-&gt;vtable = pentry-&gt;vtable;</span>
<span class="udiff-line-modified-added">+         entry-&gt;init_state = INITIALIZED;</span>
<span class="udiff-line-modified-added">+         break;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+     g_assert (entry-&gt;vtable != NULL);</span>
<span class="udiff-line-modified-added">+   }</span>
  
        /* If the write lock was released, additional interface entries might
         * have been inserted into CLASSED_NODE_IFACES_ENTRIES (node); they&#39;ll
         * be base-initialized when inserted, so we don&#39;t have to worry that
         * we might miss them. Uninitialized entries can only be moved higher
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2265,18 +2268,18 @@</span>
    i = 0;
    while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL)
      {
        entry = &amp;entries-&gt;entry[i];
        while (i &lt; IFACE_ENTRIES_N_ENTRIES (entries) &amp;&amp;
<span class="udiff-line-modified-removed">-          entry-&gt;init_state == INITIALIZED)</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       entry++;</span>
<span class="udiff-line-modified-removed">-       i++;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+        entry-&gt;init_state == INITIALIZED)</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     entry++;</span>
<span class="udiff-line-modified-added">+     i++;</span>
<span class="udiff-line-modified-added">+   }</span>
  
        if (i == IFACE_ENTRIES_N_ENTRIES (entries))
<span class="udiff-line-modified-removed">-     break;</span>
<span class="udiff-line-modified-added">+   break;</span>
  
        type_iface_vtable_iface_init_Wm (lookup_type_node_I (entry-&gt;iface_type), node);
  
        /* As in the loop above, additional initialized entries might be inserted
         * if the write lock is released, but that&#39;s harmless because the entries
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2300,11 +2303,11 @@</span>
    entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
    for (i = 0; entries != NULL &amp;&amp; i &lt; IFACE_ENTRIES_N_ENTRIES (entries); i++)
      {
        IFaceEntry *entry = &amp;entries-&gt;entry[i];
        if (entry-&gt;vtable)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-added">+   {</span>
            if (type_iface_vtable_finalize_Wm (lookup_type_node_I (entry-&gt;iface_type), node, entry-&gt;vtable))
              {
                /* refetch entries, IFACES_ENTRIES might be modified */
                goto reiterate;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2314,17 +2317,17 @@</span>
                 * iface vtable came from parent
                 */
                entry-&gt;vtable = NULL;
                entry-&gt;init_state = UNINITIALIZED;
              }
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   }</span>
      }
  }
  
  static void
  type_data_finalize_class_U (TypeNode  *node,
<span class="udiff-line-modified-removed">-                 ClassData *cdata)</span>
<span class="udiff-line-modified-added">+           ClassData *cdata)</span>
  {
    GTypeClass *class = cdata-&gt;class;
    TypeNode *bnode;
  
    g_assert (cdata-&gt;class &amp;&amp; NODE_REFCOUNT (node) == 0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2343,18 +2346,18 @@</span>
    g_free (cdata-&gt;class);
  }
  
  static void
  type_data_last_unref_Wm (TypeNode *node,
<span class="udiff-line-modified-removed">-              gboolean  uncached)</span>
<span class="udiff-line-modified-added">+        gboolean  uncached)</span>
  {
    g_return_if_fail (node != NULL &amp;&amp; node-&gt;plugin != NULL);
  
    if (!node-&gt;data || NODE_REFCOUNT (node) == 0)
      {
        g_warning (&quot;cannot drop last reference to unreferenced type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          NODE_NAME (node));</span>
<span class="udiff-line-modified-added">+      NODE_NAME (node));</span>
        return;
      }
  
    /* call class cache hooks */
    if (node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class &amp;&amp; static_n_class_cache_funcs &amp;&amp; !uncached)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2362,23 +2365,23 @@</span>
        guint i;
  
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        G_READ_LOCK (&amp;type_rw_lock);
        for (i = 0; i &lt; static_n_class_cache_funcs; i++)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       GTypeClassCacheFunc cache_func = static_class_cache_funcs[i].cache_func;</span>
<span class="udiff-line-modified-removed">-       gpointer cache_data = static_class_cache_funcs[i].cache_data;</span>
<span class="udiff-line-modified-removed">-       gboolean need_break;</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     GTypeClassCacheFunc cache_func = static_class_cache_funcs[i].cache_func;</span>
<span class="udiff-line-modified-added">+     gpointer cache_data = static_class_cache_funcs[i].cache_data;</span>
<span class="udiff-line-modified-added">+     gboolean need_break;</span>
  
<span class="udiff-line-modified-removed">-       G_READ_UNLOCK (&amp;type_rw_lock);</span>
<span class="udiff-line-modified-removed">-       need_break = cache_func (cache_data, node-&gt;data-&gt;class.class);</span>
<span class="udiff-line-modified-removed">-       G_READ_LOCK (&amp;type_rw_lock);</span>
<span class="udiff-line-modified-removed">-       if (!node-&gt;data || NODE_REFCOUNT (node) == 0)</span>
<span class="udiff-line-modified-removed">-         INVALID_RECURSION (&quot;GType class cache function &quot;, cache_func, NODE_NAME (node));</span>
<span class="udiff-line-modified-removed">-       if (need_break)</span>
<span class="udiff-line-modified-removed">-         break;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     G_READ_UNLOCK (&amp;type_rw_lock);</span>
<span class="udiff-line-modified-added">+     need_break = cache_func (cache_data, node-&gt;data-&gt;class.class);</span>
<span class="udiff-line-modified-added">+     G_READ_LOCK (&amp;type_rw_lock);</span>
<span class="udiff-line-modified-added">+     if (!node-&gt;data || NODE_REFCOUNT (node) == 0)</span>
<span class="udiff-line-modified-added">+       INVALID_RECURSION (&quot;GType class cache function &quot;, cache_func, NODE_NAME (node));</span>
<span class="udiff-line-modified-added">+     if (need_break)</span>
<span class="udiff-line-modified-added">+       break;</span>
<span class="udiff-line-modified-added">+   }</span>
        G_READ_UNLOCK (&amp;type_rw_lock);
        G_WRITE_LOCK (&amp;type_rw_lock);
      }
  
    /* may have been re-referenced meanwhile */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2386,25 +2389,25 @@</span>
      {
        GType ptype = NODE_PARENT_TYPE (node);
        TypeData *tdata;
  
        if (node-&gt;is_instantiatable)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       /* destroy node-&gt;data-&gt;instance.mem_chunk */</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     /* destroy node-&gt;data-&gt;instance.mem_chunk */</span>
<span class="udiff-line-modified-added">+   }</span>
  
        tdata = node-&gt;data;
        if (node-&gt;is_classed &amp;&amp; tdata-&gt;class.class)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       if (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node) != NULL)</span>
<span class="udiff-line-modified-removed">-         type_data_finalize_class_ifaces_Wm (node);</span>
<span class="udiff-line-modified-removed">-       node-&gt;mutatable_check_cache = FALSE;</span>
<span class="udiff-line-modified-removed">-       node-&gt;data = NULL;</span>
<span class="udiff-line-modified-removed">-       G_WRITE_UNLOCK (&amp;type_rw_lock);</span>
<span class="udiff-line-modified-removed">-       type_data_finalize_class_U (node, &amp;tdata-&gt;class);</span>
<span class="udiff-line-modified-removed">-       G_WRITE_LOCK (&amp;type_rw_lock);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     if (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node) != NULL)</span>
<span class="udiff-line-modified-added">+       type_data_finalize_class_ifaces_Wm (node);</span>
<span class="udiff-line-modified-added">+     node-&gt;mutatable_check_cache = FALSE;</span>
<span class="udiff-line-modified-added">+     node-&gt;data = NULL;</span>
<span class="udiff-line-modified-added">+     G_WRITE_UNLOCK (&amp;type_rw_lock);</span>
<span class="udiff-line-modified-added">+     type_data_finalize_class_U (node, &amp;tdata-&gt;class);</span>
<span class="udiff-line-modified-added">+     G_WRITE_LOCK (&amp;type_rw_lock);</span>
<span class="udiff-line-modified-added">+   }</span>
        else if (NODE_IS_IFACE (node) &amp;&amp; tdata-&gt;iface.dflt_vtable)
          {
            node-&gt;mutatable_check_cache = FALSE;
            node-&gt;data = NULL;
            if (tdata-&gt;iface.dflt_finalize || tdata-&gt;iface.vtable_finalize_base)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2430,11 +2433,11 @@</span>
        g_free (tdata);
  
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_type_plugin_unuse (node-&gt;plugin);
        if (ptype)
<span class="udiff-line-modified-removed">-     type_data_unref_U (lookup_type_node_I (ptype), FALSE);</span>
<span class="udiff-line-modified-added">+   type_data_unref_U (lookup_type_node_I (ptype), FALSE);</span>
        G_WRITE_LOCK (&amp;type_rw_lock);
      }
  }
  
  static inline void
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2447,15 +2450,15 @@</span>
      current = NODE_REFCOUNT (node);
  
      if (current &lt;= 1)
      {
        if (!node-&gt;plugin)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;static type &#39;%s&#39; unreferenced too often&quot;,</span>
<span class="udiff-line-modified-removed">-              NODE_NAME (node));</span>
<span class="udiff-line-modified-removed">-       return;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;static type &#39;%s&#39; unreferenced too often&quot;,</span>
<span class="udiff-line-modified-added">+          NODE_NAME (node));</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   }</span>
        else
          {
            /* This is the last reference of a type from a plugin.  We are
             * experimentally disabling support for unloading type
             * plugins, so don&#39;t allow the last ref to drop.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2488,11 +2491,11 @@</span>
   * type, since all classes are routed through the same #GTypeClassCacheFunc
   * chain.
   */
  void
  g_type_add_class_cache_func (gpointer            cache_data,
<span class="udiff-line-modified-removed">-                  GTypeClassCacheFunc cache_func)</span>
<span class="udiff-line-modified-added">+            GTypeClassCacheFunc cache_func)</span>
  {
    guint i;
  
    g_return_if_fail (cache_func != NULL);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2513,35 +2516,35 @@</span>
   * maintained by @cache_func has to be empty when calling
   * g_type_remove_class_cache_func() to avoid leaks.
   */
  void
  g_type_remove_class_cache_func (gpointer            cache_data,
<span class="udiff-line-modified-removed">-                 GTypeClassCacheFunc cache_func)</span>
<span class="udiff-line-modified-added">+         GTypeClassCacheFunc cache_func)</span>
  {
    gboolean found_it = FALSE;
    guint i;
  
    g_return_if_fail (cache_func != NULL);
  
    G_WRITE_LOCK (&amp;type_rw_lock);
    for (i = 0; i &lt; static_n_class_cache_funcs; i++)
      if (static_class_cache_funcs[i].cache_data == cache_data &amp;&amp;
<span class="udiff-line-modified-removed">-     static_class_cache_funcs[i].cache_func == cache_func)</span>
<span class="udiff-line-modified-added">+   static_class_cache_funcs[i].cache_func == cache_func)</span>
        {
<span class="udiff-line-modified-removed">-     static_n_class_cache_funcs--;</span>
<span class="udiff-line-modified-removed">-     memmove (static_class_cache_funcs + i,</span>
<span class="udiff-line-modified-added">+   static_n_class_cache_funcs--;</span>
<span class="udiff-line-modified-added">+   memmove (static_class_cache_funcs + i,</span>
                   static_class_cache_funcs + i + 1,
                   sizeof (static_class_cache_funcs[0]) * (static_n_class_cache_funcs - i));
<span class="udiff-line-modified-removed">-     static_class_cache_funcs = g_renew (ClassCacheFunc, static_class_cache_funcs, static_n_class_cache_funcs);</span>
<span class="udiff-line-modified-removed">-     found_it = TRUE;</span>
<span class="udiff-line-modified-removed">-     break;</span>
<span class="udiff-line-modified-added">+   static_class_cache_funcs = g_renew (ClassCacheFunc, static_class_cache_funcs, static_n_class_cache_funcs);</span>
<span class="udiff-line-modified-added">+   found_it = TRUE;</span>
<span class="udiff-line-modified-added">+   break;</span>
        }
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  
    if (!found_it)
      g_warning (G_STRLOC &quot;: cannot remove unregistered class cache func %p with data %p&quot;,
<span class="udiff-line-modified-removed">-            cache_func, cache_data);</span>
<span class="udiff-line-modified-added">+          cache_func, cache_data);</span>
  }
  
  
  /**
   * g_type_add_interface_check: (skip)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2560,12 +2563,12 @@</span>
   * interfaces.
   *
   * Since: 2.4
   */
  void
<span class="udiff-line-modified-removed">- g_type_add_interface_check (gpointer                check_data,</span>
<span class="udiff-line-modified-removed">-                             GTypeInterfaceCheckFunc check_func)</span>
<span class="udiff-line-modified-added">+ g_type_add_interface_check (gpointer              check_data,</span>
<span class="udiff-line-modified-added">+           GTypeInterfaceCheckFunc check_func)</span>
  {
    guint i;
  
    g_return_if_fail (check_func != NULL);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2587,35 +2590,35 @@</span>
   *
   * Since: 2.4
   */
  void
  g_type_remove_interface_check (gpointer                check_data,
<span class="udiff-line-modified-removed">-                                GTypeInterfaceCheckFunc check_func)</span>
<span class="udiff-line-modified-added">+              GTypeInterfaceCheckFunc check_func)</span>
  {
    gboolean found_it = FALSE;
    guint i;
  
    g_return_if_fail (check_func != NULL);
  
    G_WRITE_LOCK (&amp;type_rw_lock);
    for (i = 0; i &lt; static_n_iface_check_funcs; i++)
      if (static_iface_check_funcs[i].check_data == check_data &amp;&amp;
<span class="udiff-line-modified-removed">-     static_iface_check_funcs[i].check_func == check_func)</span>
<span class="udiff-line-modified-added">+   static_iface_check_funcs[i].check_func == check_func)</span>
        {
<span class="udiff-line-modified-removed">-     static_n_iface_check_funcs--;</span>
<span class="udiff-line-modified-removed">-     memmove (static_iface_check_funcs + i,</span>
<span class="udiff-line-modified-added">+   static_n_iface_check_funcs--;</span>
<span class="udiff-line-modified-added">+   memmove (static_iface_check_funcs + i,</span>
                   static_iface_check_funcs + i + 1,
                   sizeof (static_iface_check_funcs[0]) * (static_n_iface_check_funcs - i));
<span class="udiff-line-modified-removed">-     static_iface_check_funcs = g_renew (IFaceCheckFunc, static_iface_check_funcs, static_n_iface_check_funcs);</span>
<span class="udiff-line-modified-removed">-     found_it = TRUE;</span>
<span class="udiff-line-modified-removed">-     break;</span>
<span class="udiff-line-modified-added">+   static_iface_check_funcs = g_renew (IFaceCheckFunc, static_iface_check_funcs, static_n_iface_check_funcs);</span>
<span class="udiff-line-modified-added">+   found_it = TRUE;</span>
<span class="udiff-line-modified-added">+   break;</span>
        }
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  
    if (!found_it)
      g_warning (G_STRLOC &quot;: cannot remove unregistered class check func %p with data %p&quot;,
<span class="udiff-line-modified-removed">-            check_func, check_data);</span>
<span class="udiff-line-modified-added">+          check_func, check_data);</span>
  }
  
  /* --- type registration --- */
  /**
   * g_type_register_fundamental:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2635,14 +2638,14 @@</span>
   *
   * Returns: the predefined type identifier
   */
  GType
  g_type_register_fundamental (GType                       type_id,
<span class="udiff-line-modified-removed">-                              const gchar                *type_name,</span>
<span class="udiff-line-modified-removed">-                              const GTypeInfo            *info,</span>
<span class="udiff-line-modified-removed">-                              const GTypeFundamentalInfo *finfo,</span>
<span class="udiff-line-modified-removed">-                  GTypeFlags          flags)</span>
<span class="udiff-line-modified-added">+            const gchar                *type_name,</span>
<span class="udiff-line-modified-added">+            const GTypeInfo            *info,</span>
<span class="udiff-line-modified-added">+            const GTypeFundamentalInfo *finfo,</span>
<span class="udiff-line-modified-added">+            GTypeFlags      flags)</span>
  {
    TypeNode *node;
  
    g_assert_type_system_initialized ();
    g_return_val_if_fail (type_id &gt; 0, 0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2654,36 +2657,36 @@</span>
      return 0;
    if ((type_id &amp; TYPE_ID_MASK) ||
        type_id &gt; G_TYPE_FUNDAMENTAL_MAX)
      {
        g_warning (&quot;attempt to register fundamental type &#39;%s&#39; with invalid type id (%&quot; G_GSIZE_FORMAT &quot;)&quot;,
<span class="udiff-line-modified-removed">-          type_name,</span>
<span class="udiff-line-modified-removed">-          type_id);</span>
<span class="udiff-line-modified-added">+      type_name,</span>
<span class="udiff-line-modified-added">+      type_id);</span>
        return 0;
      }
    if ((finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) &amp;&amp;
        !(finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED))
      {
        g_warning (&quot;cannot register instantiatable fundamental type &#39;%s&#39; as non-classed&quot;,
<span class="udiff-line-modified-removed">-          type_name);</span>
<span class="udiff-line-modified-added">+      type_name);</span>
        return 0;
      }
    if (lookup_type_node_I (type_id))
      {
        g_warning (&quot;cannot register existing fundamental type &#39;%s&#39; (as &#39;%s&#39;)&quot;,
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (type_id),</span>
<span class="udiff-line-modified-removed">-          type_name);</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (type_id),</span>
<span class="udiff-line-modified-added">+      type_name);</span>
        return 0;
      }
  
    G_WRITE_LOCK (&amp;type_rw_lock);
    node = type_node_fundamental_new_W (type_id, type_name, finfo-&gt;type_flags);
    type_add_flags_W (node, flags);
  
    if (check_type_info_I (NULL, NODE_FUNDAMENTAL_TYPE (node), type_name, info))
      type_data_make_W (node, info,
<span class="udiff-line-modified-removed">-               check_value_table_I (type_name, info-&gt;value_table) ? info-&gt;value_table : NULL);</span>
<span class="udiff-line-modified-added">+           check_value_table_I (type_name, info-&gt;value_table) ? info-&gt;value_table : NULL);</span>
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  
    return NODE_TYPE (node);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2706,16 +2709,16 @@</span>
   *
   * Returns: the new type identifier
   */
  GType
  g_type_register_static_simple (GType             parent_type,
<span class="udiff-line-modified-removed">-                                const gchar      *type_name,</span>
<span class="udiff-line-modified-removed">-                                guint             class_size,</span>
<span class="udiff-line-modified-removed">-                                GClassInitFunc    class_init,</span>
<span class="udiff-line-modified-removed">-                                guint             instance_size,</span>
<span class="udiff-line-modified-removed">-                                GInstanceInitFunc instance_init,</span>
<span class="udiff-line-modified-removed">-                    GTypeFlags    flags)</span>
<span class="udiff-line-modified-added">+              const gchar      *type_name,</span>
<span class="udiff-line-modified-added">+              guint             class_size,</span>
<span class="udiff-line-modified-added">+              GClassInitFunc    class_init,</span>
<span class="udiff-line-modified-added">+              guint             instance_size,</span>
<span class="udiff-line-modified-added">+              GInstanceInitFunc instance_init,</span>
<span class="udiff-line-modified-added">+              GTypeFlags  flags)</span>
  {
    GTypeInfo info;
  
    /* Instances are not allowed to be larger than this. If you have a big
     * fixed-length array or something, point to it instead.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2752,13 +2755,13 @@</span>
   *
   * Returns: the new type identifier
   */
  GType
  g_type_register_static (GType            parent_type,
<span class="udiff-line-modified-removed">-                         const gchar     *type_name,</span>
<span class="udiff-line-modified-removed">-                         const GTypeInfo *info,</span>
<span class="udiff-line-modified-removed">-             GTypeFlags   flags)</span>
<span class="udiff-line-modified-added">+       const gchar     *type_name,</span>
<span class="udiff-line-modified-added">+       const GTypeInfo *info,</span>
<span class="udiff-line-modified-added">+       GTypeFlags   flags)</span>
  {
    TypeNode *pnode, *node;
    GType type = 0;
  
    g_assert_type_system_initialized ();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2770,11 +2773,11 @@</span>
        !check_derivation_I (parent_type, type_name))
      return 0;
    if (info-&gt;class_finalize)
      {
        g_warning (&quot;class finalizer specified for static type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_name);</span>
<span class="udiff-line-modified-added">+      type_name);</span>
        return 0;
      }
  
    pnode = lookup_type_node_I (parent_type);
    G_WRITE_LOCK (&amp;type_rw_lock);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2783,11 +2786,11 @@</span>
      {
        node = type_node_new_W (pnode, type_name, NULL);
        type_add_flags_W (node, flags);
        type = NODE_TYPE (node);
        type_data_make_W (node, info,
<span class="udiff-line-modified-removed">-             check_value_table_I (type_name, info-&gt;value_table) ? info-&gt;value_table : NULL);</span>
<span class="udiff-line-modified-added">+       check_value_table_I (type_name, info-&gt;value_table) ? info-&gt;value_table : NULL);</span>
      }
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  
    return type;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2807,13 +2810,13 @@</span>
   *
   * Returns: the new type identifier or #G_TYPE_INVALID if registration failed
   */
  GType
  g_type_register_dynamic (GType        parent_type,
<span class="udiff-line-modified-removed">-              const gchar *type_name,</span>
<span class="udiff-line-modified-removed">-              GTypePlugin *plugin,</span>
<span class="udiff-line-modified-removed">-              GTypeFlags   flags)</span>
<span class="udiff-line-modified-added">+        const gchar *type_name,</span>
<span class="udiff-line-modified-added">+        GTypePlugin *plugin,</span>
<span class="udiff-line-modified-added">+        GTypeFlags   flags)</span>
  {
    TypeNode *pnode, *node;
    GType type;
  
    g_assert_type_system_initialized ();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2847,12 +2850,12 @@</span>
   * The information contained in the #GInterfaceInfo structure
   * pointed to by @info is used to manage the relationship.
   */
  void
  g_type_add_interface_static (GType                 instance_type,
<span class="udiff-line-modified-removed">-                  GType                 interface_type,</span>
<span class="udiff-line-modified-removed">-                  const GInterfaceInfo *info)</span>
<span class="udiff-line-modified-added">+            GType                 interface_type,</span>
<span class="udiff-line-modified-added">+            const GInterfaceInfo *info)</span>
  {
    /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
    g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
    g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2883,12 +2886,12 @@</span>
   * contained in the #GTypePlugin structure pointed to by @plugin
   * is used to manage the relationship.
   */
  void
  g_type_add_interface_dynamic (GType        instance_type,
<span class="udiff-line-modified-removed">-                   GType        interface_type,</span>
<span class="udiff-line-modified-removed">-                   GTypePlugin *plugin)</span>
<span class="udiff-line-modified-added">+             GType        interface_type,</span>
<span class="udiff-line-modified-added">+             GTypePlugin *plugin)</span>
  {
    TypeNode *node;
    /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
    g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
    g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2933,11 +2936,11 @@</span>
    /* optimize for common code path */
    node = lookup_type_node_I (type);
    if (!node || !node-&gt;is_classed)
      {
        g_warning (&quot;cannot retrieve class for invalid (unclassed) type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (type));</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (type));</span>
        return NULL;
      }
  
    if (G_LIKELY (type_data_ref_U (node)))
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2997,11 +3000,11 @@</span>
    node = lookup_type_node_I (class-&gt;g_type);
    if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node))
      type_data_unref_U (node, FALSE);
    else
      g_warning (&quot;cannot unreference class of invalid (unclassed) type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-            type_descriptive_name_I (class-&gt;g_type));</span>
<span class="udiff-line-modified-added">+          type_descriptive_name_I (class-&gt;g_type));</span>
  }
  
  /**
   * g_type_class_unref_uncached: (skip)
   * @g_class: (type GObject.TypeClass): a #GTypeClass structure to unref
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3022,11 +3025,11 @@</span>
    node = lookup_type_node_I (class-&gt;g_type);
    if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node))
      type_data_unref_U (node, TRUE);
    else
      g_warning (&quot;cannot unreference class of invalid (unclassed) type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-            type_descriptive_name_I (class-&gt;g_type));</span>
<span class="udiff-line-modified-added">+          type_descriptive_name_I (class-&gt;g_type));</span>
  }
  
  /**
   * g_type_class_peek:
   * @type: type ID of a classed type
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3142,11 +3145,11 @@</span>
   *     structure of @iface_type if implemented by @instance_class, %NULL
   *     otherwise
   */
  gpointer
  g_type_interface_peek (gpointer instance_class,
<span class="udiff-line-modified-removed">-                GType    iface_type)</span>
<span class="udiff-line-modified-added">+            GType    iface_type)</span>
  {
    TypeNode *node;
    TypeNode *iface;
    gpointer vtable = NULL;
    GTypeClass *class = instance_class;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3232,11 +3235,11 @@</span>
    if (!node || !NODE_IS_IFACE (node) ||
        (node-&gt;data &amp;&amp; NODE_REFCOUNT (node) == 0))
      {
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_warning (&quot;cannot retrieve default vtable for invalid or non-interface type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (g_type));</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (g_type));</span>
        return NULL;
      }
  
    if (!node-&gt;data || !node-&gt;data-&gt;iface.dflt_vtable)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3286,11 +3289,11 @@</span>
  }
  
  /**
   * g_type_default_interface_unref:
   * @g_iface: (type GObject.TypeInterface): the default vtable
<span class="udiff-line-modified-removed">-  *     structure for a interface, as returned by g_type_default_interface_ref()</span>
<span class="udiff-line-modified-added">+  *     structure for an interface, as returned by g_type_default_interface_ref()</span>
   *
   * Decrements the reference count for the type corresponding to the
   * interface default vtable @g_iface. If the type is dynamic, then
   * when no one is using the interface and all references have
   * been released, the finalize function for the interface&#39;s default
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3309,11 +3312,11 @@</span>
    node = lookup_type_node_I (vtable-&gt;g_type);
    if (node &amp;&amp; NODE_IS_IFACE (node))
      type_data_unref_U (node, FALSE);
    else
      g_warning (&quot;cannot unreference invalid interface default vtable for &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-            type_descriptive_name_I (vtable-&gt;g_type));</span>
<span class="udiff-line-modified-added">+          type_descriptive_name_I (vtable-&gt;g_type));</span>
  }
  
  /**
   * g_type_name:
   * @type: type to return name for
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3356,13 +3359,13 @@</span>
    return node ? node-&gt;qname : 0;
  }
  
  /**
   * g_type_from_name:
<span class="udiff-line-modified-removed">-  * @name: type name to lookup</span>
<span class="udiff-line-modified-added">+  * @name: type name to look up</span>
   *
<span class="udiff-line-modified-removed">-  * Lookup the type ID from a given type name, returning 0 if no type</span>
<span class="udiff-line-modified-added">+  * Look up the type ID from a given type name, returning 0 if no type</span>
   * has been registered under this name (this is the preferred method
   * to find out by name whether a specific type has been registered
   * yet).
   *
   * Returns: corresponding type ID or 0
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3434,39 +3437,39 @@</span>
   *
   * Returns: immediate child of @root_type and anchestor of @leaf_type
   */
  GType
  g_type_next_base (GType type,
<span class="udiff-line-modified-removed">-           GType base_type)</span>
<span class="udiff-line-modified-added">+       GType base_type)</span>
  {
    GType atype = 0;
    TypeNode *node;
  
    node = lookup_type_node_I (type);
    if (node)
      {
        TypeNode *base_node = lookup_type_node_I (base_type);
  
        if (base_node &amp;&amp; base_node-&gt;n_supers &lt; node-&gt;n_supers)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       guint n = node-&gt;n_supers - base_node-&gt;n_supers;</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     guint n = node-&gt;n_supers - base_node-&gt;n_supers;</span>
  
<span class="udiff-line-modified-removed">-       if (node-&gt;supers[n] == base_type)</span>
<span class="udiff-line-modified-removed">-         atype = node-&gt;supers[n - 1];</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     if (node-&gt;supers[n] == base_type)</span>
<span class="udiff-line-modified-added">+       atype = node-&gt;supers[n - 1];</span>
<span class="udiff-line-modified-added">+   }</span>
      }
  
    return atype;
  }
  
  static inline gboolean
  type_node_check_conformities_UorL (TypeNode *node,
<span class="udiff-line-modified-removed">-                    TypeNode *iface_node,</span>
<span class="udiff-line-modified-removed">-                    /*        support_inheritance */</span>
<span class="udiff-line-modified-removed">-                    gboolean  support_interfaces,</span>
<span class="udiff-line-modified-removed">-                    gboolean  support_prerequisites,</span>
<span class="udiff-line-modified-removed">-                    gboolean  have_lock)</span>
<span class="udiff-line-modified-added">+            TypeNode *iface_node,</span>
<span class="udiff-line-modified-added">+            /*        support_inheritance */</span>
<span class="udiff-line-modified-added">+            gboolean  support_interfaces,</span>
<span class="udiff-line-modified-added">+            gboolean  support_prerequisites,</span>
<span class="udiff-line-modified-added">+            gboolean  have_lock)</span>
  {
    gboolean match;
  
    if (/* support_inheritance &amp;&amp; */
        NODE_IS_ANCESTOR (iface_node, node))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3476,45 +3479,45 @@</span>
    support_prerequisites = support_prerequisites &amp;&amp; NODE_IS_IFACE (node);
    match = FALSE;
    if (support_interfaces)
      {
        if (have_lock)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       if (type_lookup_iface_entry_L (node, iface_node))</span>
<span class="udiff-line-modified-removed">-         match = TRUE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     if (type_lookup_iface_entry_L (node, iface_node))</span>
<span class="udiff-line-modified-added">+       match = TRUE;</span>
<span class="udiff-line-modified-added">+   }</span>
        else
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       if (type_lookup_iface_vtable_I (node, iface_node, NULL))</span>
<span class="udiff-line-modified-removed">-         match = TRUE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     if (type_lookup_iface_vtable_I (node, iface_node, NULL))</span>
<span class="udiff-line-modified-added">+       match = TRUE;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    if (!match &amp;&amp;
        support_prerequisites)
      {
        if (!have_lock)
<span class="udiff-line-modified-removed">-     G_READ_LOCK (&amp;type_rw_lock);</span>
<span class="udiff-line-modified-added">+   G_READ_LOCK (&amp;type_rw_lock);</span>
        if (support_prerequisites &amp;&amp; type_lookup_prerequisite_L (node, NODE_TYPE (iface_node)))
<span class="udiff-line-modified-removed">-     match = TRUE;</span>
<span class="udiff-line-modified-added">+   match = TRUE;</span>
        if (!have_lock)
<span class="udiff-line-modified-removed">-     G_READ_UNLOCK (&amp;type_rw_lock);</span>
<span class="udiff-line-modified-added">+   G_READ_UNLOCK (&amp;type_rw_lock);</span>
      }
    return match;
  }
  
  static gboolean
  type_node_is_a_L (TypeNode *node,
<span class="udiff-line-modified-removed">-           TypeNode *iface_node)</span>
<span class="udiff-line-modified-added">+       TypeNode *iface_node)</span>
  {
    return type_node_check_conformities_UorL (node, iface_node, TRUE, TRUE, TRUE);
  }
  
  static inline gboolean
  type_node_conforms_to_U (TypeNode *node,
<span class="udiff-line-modified-removed">-              TypeNode *iface_node,</span>
<span class="udiff-line-modified-removed">-              gboolean  support_interfaces,</span>
<span class="udiff-line-modified-removed">-              gboolean  support_prerequisites)</span>
<span class="udiff-line-modified-added">+        TypeNode *iface_node,</span>
<span class="udiff-line-modified-added">+        gboolean  support_interfaces,</span>
<span class="udiff-line-modified-added">+        gboolean  support_prerequisites)</span>
  {
    return type_node_check_conformities_UorL (node, iface_node, support_interfaces, support_prerequisites, FALSE);
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3529,11 +3532,11 @@</span>
   *
   * Returns: %TRUE if @type is a @is_a_type
   */
  gboolean
  g_type_is_a (GType type,
<span class="udiff-line-modified-removed">-          GType iface_type)</span>
<span class="udiff-line-modified-added">+        GType iface_type)</span>
  {
    TypeNode *node, *iface_node;
    gboolean is_a;
  
    if (type == iface_type)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3558,11 +3561,11 @@</span>
   * Returns: (array length=n_children) (transfer full): Newly allocated
   *     and 0-terminated array of child types, free with g_free()
   */
  GType*
  g_type_children (GType  type,
<span class="udiff-line-modified-removed">-          guint *n_children)</span>
<span class="udiff-line-modified-added">+      guint *n_children)</span>
  {
    TypeNode *node;
  
    node = lookup_type_node_I (type);
    if (node)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3570,23 +3573,23 @@</span>
        GType *children;
  
        G_READ_LOCK (&amp;type_rw_lock);  /* -&gt;children is relocatable */
        children = g_new (GType, node-&gt;n_children + 1);
        if (node-&gt;n_children != 0)
<span class="udiff-line-modified-removed">-       memcpy (children, node-&gt;children, sizeof (GType) * node-&gt;n_children);</span>
<span class="udiff-line-modified-added">+         memcpy (children, node-&gt;children, sizeof (GType) * node-&gt;n_children);</span>
        children[node-&gt;n_children] = 0;
  
        if (n_children)
<span class="udiff-line-modified-removed">-     *n_children = node-&gt;n_children;</span>
<span class="udiff-line-modified-added">+   *n_children = node-&gt;n_children;</span>
        G_READ_UNLOCK (&amp;type_rw_lock);
  
        return children;
      }
    else
      {
        if (n_children)
<span class="udiff-line-modified-removed">-     *n_children = 0;</span>
<span class="udiff-line-modified-added">+   *n_children = 0;</span>
  
        return NULL;
      }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3602,11 +3605,11 @@</span>
   * Returns: (array length=n_interfaces) (transfer full): Newly allocated
   *     and 0-terminated array of interface types, free with g_free()
   */
  GType*
  g_type_interfaces (GType  type,
<span class="udiff-line-modified-removed">-            guint *n_interfaces)</span>
<span class="udiff-line-modified-added">+        guint *n_interfaces)</span>
  {
    TypeNode *node;
  
    node = lookup_type_node_I (type);
    if (node &amp;&amp; node-&gt;is_instantiatable)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3616,32 +3619,32 @@</span>
        guint i;
  
        G_READ_LOCK (&amp;type_rw_lock);
        entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
        if (entries)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       ifaces = g_new (GType, IFACE_ENTRIES_N_ENTRIES (entries) + 1);</span>
<span class="udiff-line-modified-removed">-       for (i = 0; i &lt; IFACE_ENTRIES_N_ENTRIES (entries); i++)</span>
<span class="udiff-line-modified-removed">-         ifaces[i] = entries-&gt;entry[i].iface_type;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     ifaces = g_new (GType, IFACE_ENTRIES_N_ENTRIES (entries) + 1);</span>
<span class="udiff-line-modified-added">+     for (i = 0; i &lt; IFACE_ENTRIES_N_ENTRIES (entries); i++)</span>
<span class="udiff-line-modified-added">+       ifaces[i] = entries-&gt;entry[i].iface_type;</span>
<span class="udiff-line-modified-added">+   }</span>
        else
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       ifaces = g_new (GType, 1);</span>
<span class="udiff-line-modified-removed">-       i = 0;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     ifaces = g_new (GType, 1);</span>
<span class="udiff-line-modified-added">+     i = 0;</span>
<span class="udiff-line-modified-added">+   }</span>
        ifaces[i] = 0;
  
        if (n_interfaces)
<span class="udiff-line-modified-removed">-     *n_interfaces = i;</span>
<span class="udiff-line-modified-added">+   *n_interfaces = i;</span>
        G_READ_UNLOCK (&amp;type_rw_lock);
  
        return ifaces;
      }
    else
      {
        if (n_interfaces)
<span class="udiff-line-modified-removed">-     *n_interfaces = 0;</span>
<span class="udiff-line-modified-added">+   *n_interfaces = 0;</span>
  
        return NULL;
      }
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3657,36 +3660,36 @@</span>
    gpointer data;
  };
  
  static inline gpointer
  type_get_qdata_L (TypeNode *node,
<span class="udiff-line-modified-removed">-           GQuark    quark)</span>
<span class="udiff-line-modified-added">+       GQuark    quark)</span>
  {
    GData *gdata = node-&gt;global_gdata;
  
    if (quark &amp;&amp; gdata &amp;&amp; gdata-&gt;n_qdatas)
      {
        QData *qdatas = gdata-&gt;qdatas - 1;
        guint n_qdatas = gdata-&gt;n_qdatas;
  
        do
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       guint i;</span>
<span class="udiff-line-modified-removed">-       QData *check;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       i = (n_qdatas + 1) / 2;</span>
<span class="udiff-line-modified-removed">-       check = qdatas + i;</span>
<span class="udiff-line-modified-removed">-       if (quark == check-&gt;quark)</span>
<span class="udiff-line-modified-removed">-         return check-&gt;data;</span>
<span class="udiff-line-modified-removed">-       else if (quark &gt; check-&gt;quark)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           n_qdatas -= i;</span>
<span class="udiff-line-modified-removed">-           qdatas = check;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-       else /* if (quark &lt; check-&gt;quark) */</span>
<span class="udiff-line-modified-removed">-         n_qdatas = i - 1;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     guint i;</span>
<span class="udiff-line-modified-added">+     QData *check;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     i = (n_qdatas + 1) / 2;</span>
<span class="udiff-line-modified-added">+     check = qdatas + i;</span>
<span class="udiff-line-modified-added">+     if (quark == check-&gt;quark)</span>
<span class="udiff-line-modified-added">+       return check-&gt;data;</span>
<span class="udiff-line-modified-added">+     else if (quark &gt; check-&gt;quark)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         n_qdatas -= i;</span>
<span class="udiff-line-modified-added">+         qdatas = check;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+     else /* if (quark &lt; check-&gt;quark) */</span>
<span class="udiff-line-modified-added">+       n_qdatas = i - 1;</span>
<span class="udiff-line-modified-added">+   }</span>
        while (n_qdatas);
      }
    return NULL;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3704,11 +3707,11 @@</span>
   *
   * Returns: (transfer none): the data, or %NULL if no data was found
   */
  gpointer
  g_type_get_qdata (GType  type,
<span class="udiff-line-modified-removed">-           GQuark quark)</span>
<span class="udiff-line-modified-added">+       GQuark quark)</span>
  {
    TypeNode *node;
    gpointer data;
  
    node = lookup_type_node_I (type);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3726,12 +3729,12 @@</span>
    return data;
  }
  
  static inline void
  type_set_qdata_W (TypeNode *node,
<span class="udiff-line-modified-removed">-           GQuark    quark,</span>
<span class="udiff-line-modified-removed">-           gpointer  data)</span>
<span class="udiff-line-modified-added">+       GQuark    quark,</span>
<span class="udiff-line-modified-added">+       gpointer  data)</span>
  {
    GData *gdata;
    QData *qdata;
    guint i;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3743,12 +3746,12 @@</span>
    /* try resetting old data */
    qdata = gdata-&gt;qdatas;
    for (i = 0; i &lt; gdata-&gt;n_qdatas; i++)
      if (qdata[i].quark == quark)
        {
<span class="udiff-line-modified-removed">-     qdata[i].data = data;</span>
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-modified-added">+   qdata[i].data = data;</span>
<span class="udiff-line-modified-added">+   return;</span>
        }
  
    /* add new entry */
    gdata-&gt;n_qdatas++;
    gdata-&gt;qdatas = g_renew (QData, gdata-&gt;qdatas, gdata-&gt;n_qdatas);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3769,12 +3772,12 @@</span>
   *
   * Attaches arbitrary data to a type.
   */
  void
  g_type_set_qdata (GType    type,
<span class="udiff-line-modified-removed">-           GQuark   quark,</span>
<span class="udiff-line-modified-removed">-           gpointer data)</span>
<span class="udiff-line-modified-added">+       GQuark   quark,</span>
<span class="udiff-line-modified-added">+       gpointer data)</span>
  {
    TypeNode *node;
  
    g_return_if_fail (quark != 0);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3789,11 +3792,11 @@</span>
      g_return_if_fail (node != NULL);
  }
  
  static void
  type_add_flags_W (TypeNode  *node,
<span class="udiff-line-modified-removed">-           GTypeFlags flags)</span>
<span class="udiff-line-modified-added">+       GTypeFlags flags)</span>
  {
    guint dflags;
  
    g_return_if_fail ((flags &amp; ~TYPE_FLAG_MASK) == 0);
    g_return_if_fail (node != NULL);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3818,11 +3821,11 @@</span>
   * #GTypeQuery structure should be considered constant and have to be
   * left untouched.
   */
  void
  g_type_query (GType       type,
<span class="udiff-line-modified-removed">-           GTypeQuery *query)</span>
<span class="udiff-line-modified-added">+         GTypeQuery *query)</span>
  {
    TypeNode *node;
  
    g_return_if_fail (query != NULL);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3831,17 +3834,17 @@</span>
    node = lookup_type_node_I (type);
    if (node &amp;&amp; node-&gt;is_classed &amp;&amp; !node-&gt;plugin)
      {
        /* type is classed and probably even instantiatable */
        G_READ_LOCK (&amp;type_rw_lock);
<span class="udiff-line-modified-removed">-       if (node-&gt;data)   /* type is static or referenced */</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       query-&gt;type = NODE_TYPE (node);</span>
<span class="udiff-line-modified-removed">-       query-&gt;type_name = NODE_NAME (node);</span>
<span class="udiff-line-modified-removed">-       query-&gt;class_size = node-&gt;data-&gt;class.class_size;</span>
<span class="udiff-line-modified-removed">-       query-&gt;instance_size = node-&gt;is_instantiatable ? node-&gt;data-&gt;instance.instance_size : 0;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+       if (node-&gt;data) /* type is static or referenced */</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     query-&gt;type = NODE_TYPE (node);</span>
<span class="udiff-line-modified-added">+     query-&gt;type_name = NODE_NAME (node);</span>
<span class="udiff-line-modified-added">+     query-&gt;class_size = node-&gt;data-&gt;class.class_size;</span>
<span class="udiff-line-modified-added">+     query-&gt;instance_size = node-&gt;is_instantiatable ? node-&gt;data-&gt;instance.instance_size : 0;</span>
<span class="udiff-line-modified-added">+   }</span>
        G_READ_UNLOCK (&amp;type_rw_lock);
      }
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3874,11 +3877,11 @@</span>
  }
  
  /* --- implementation details --- */
  gboolean
  g_type_test_flags (GType type,
<span class="udiff-line-modified-removed">-            guint flags)</span>
<span class="udiff-line-modified-added">+        guint flags)</span>
  {
    TypeNode *node;
    gboolean result = FALSE;
  
    node = lookup_type_node_I (type);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3886,26 +3889,26 @@</span>
      {
        guint fflags = flags &amp; TYPE_FUNDAMENTAL_FLAG_MASK;
        guint tflags = flags &amp; TYPE_FLAG_MASK;
  
        if (fflags)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (node);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (node);</span>
  
<span class="udiff-line-modified-removed">-       fflags = (finfo-&gt;type_flags &amp; fflags) == fflags;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     fflags = (finfo-&gt;type_flags &amp; fflags) == fflags;</span>
<span class="udiff-line-modified-added">+   }</span>
        else
<span class="udiff-line-modified-removed">-     fflags = TRUE;</span>
<span class="udiff-line-modified-added">+   fflags = TRUE;</span>
  
        if (tflags)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       G_READ_LOCK (&amp;type_rw_lock);</span>
<span class="udiff-line-modified-removed">-       tflags = (tflags &amp; GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))) == tflags;</span>
<span class="udiff-line-modified-removed">-       G_READ_UNLOCK (&amp;type_rw_lock);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     G_READ_LOCK (&amp;type_rw_lock);</span>
<span class="udiff-line-modified-added">+     tflags = (tflags &amp; GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))) == tflags;</span>
<span class="udiff-line-modified-added">+     G_READ_UNLOCK (&amp;type_rw_lock);</span>
<span class="udiff-line-modified-added">+   }</span>
        else
<span class="udiff-line-modified-removed">-     tflags = TRUE;</span>
<span class="udiff-line-modified-added">+   tflags = TRUE;</span>
  
        result = tflags &amp;&amp; fflags;
      }
  
    return result;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3943,16 +3946,16 @@</span>
   * Returns: (transfer none): the #GTypePlugin for the dynamic
   *     interface @interface_type of @instance_type
   */
  GTypePlugin*
  g_type_interface_get_plugin (GType instance_type,
<span class="udiff-line-modified-removed">-                  GType interface_type)</span>
<span class="udiff-line-modified-added">+            GType interface_type)</span>
  {
    TypeNode *node;
    TypeNode *iface;
  
<span class="udiff-line-modified-removed">-   g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);    /* G_TYPE_IS_INTERFACE() is an external call: _U */</span>
<span class="udiff-line-modified-added">+   g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);  /* G_TYPE_IS_INTERFACE() is an external call: _U */</span>
  
    node = lookup_type_node_I (instance_type);
    iface = lookup_type_node_I (interface_type);
    if (node &amp;&amp; iface)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3961,11 +3964,11 @@</span>
  
        G_READ_LOCK (&amp;type_rw_lock);
  
        iholder = iface_node_get_holders_L (iface);
        while (iholder &amp;&amp; iholder-&gt;instance_type != instance_type)
<span class="udiff-line-modified-removed">-     iholder = iholder-&gt;next;</span>
<span class="udiff-line-modified-added">+   iholder = iholder-&gt;next;</span>
        plugin = iholder ? iholder-&gt;plugin : NULL;
  
        G_READ_UNLOCK (&amp;type_rw_lock);
  
        return plugin;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4019,11 +4022,11 @@</span>
    return node ? NODE_FUNDAMENTAL_TYPE (node) : 0;
  }
  
  gboolean
  g_type_check_instance_is_a (GTypeInstance *type_instance,
<span class="udiff-line-modified-removed">-                 GType          iface_type)</span>
<span class="udiff-line-modified-added">+           GType          iface_type)</span>
  {
    TypeNode *node, *iface;
    gboolean check;
  
    if (!type_instance || !type_instance-&gt;g_class)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4047,11 +4050,11 @@</span>
    return node &amp;&amp; (NODE_FUNDAMENTAL_TYPE(node) == fundamental_type);
  }
  
  gboolean
  g_type_check_class_is_a (GTypeClass *type_class,
<span class="udiff-line-modified-removed">-              GType       is_a_type)</span>
<span class="udiff-line-modified-added">+        GType       is_a_type)</span>
  {
    TypeNode *node, *iface;
    gboolean check;
  
    if (!type_class)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4064,46 +4067,46 @@</span>
    return check;
  }
  
  GTypeInstance*
  g_type_check_instance_cast (GTypeInstance *type_instance,
<span class="udiff-line-modified-removed">-                 GType          iface_type)</span>
<span class="udiff-line-modified-added">+           GType          iface_type)</span>
  {
    if (type_instance)
      {
        if (type_instance-&gt;g_class)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       TypeNode *node, *iface;</span>
<span class="udiff-line-modified-removed">-       gboolean is_instantiatable, check;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);</span>
<span class="udiff-line-modified-removed">-       is_instantiatable = node &amp;&amp; node-&gt;is_instantiatable;</span>
<span class="udiff-line-modified-removed">-       iface = lookup_type_node_I (iface_type);</span>
<span class="udiff-line-modified-removed">-       check = is_instantiatable &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, TRUE, FALSE);</span>
<span class="udiff-line-modified-removed">-       if (check)</span>
<span class="udiff-line-modified-removed">-         return type_instance;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       if (is_instantiatable)</span>
<span class="udiff-line-modified-removed">-         g_warning (&quot;invalid cast from &#39;%s&#39; to &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-                type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type),</span>
<span class="udiff-line-removed">-                type_descriptive_name_I (iface_type));</span>
<span class="udiff-line-removed">-       else</span>
<span class="udiff-line-removed">-         g_warning (&quot;invalid uninstantiatable type &#39;%s&#39; in cast to &#39;%s&#39;&quot;,</span>
<span class="udiff-line-removed">-                type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type),</span>
<span class="udiff-line-removed">-                type_descriptive_name_I (iface_type));</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-       else</span>
<span class="udiff-line-removed">-     g_warning (&quot;invalid unclassed pointer in cast to &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     TypeNode *node, *iface;</span>
<span class="udiff-line-modified-added">+     gboolean is_instantiatable, check;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);</span>
<span class="udiff-line-modified-added">+     is_instantiatable = node &amp;&amp; node-&gt;is_instantiatable;</span>
<span class="udiff-line-modified-added">+     iface = lookup_type_node_I (iface_type);</span>
<span class="udiff-line-modified-added">+     check = is_instantiatable &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, TRUE, FALSE);</span>
<span class="udiff-line-modified-added">+     if (check)</span>
<span class="udiff-line-modified-added">+       return type_instance;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     if (is_instantiatable)</span>
<span class="udiff-line-modified-added">+       g_warning (&quot;invalid cast from &#39;%s&#39; to &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+            type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type),</span>
             type_descriptive_name_I (iface_type));
<span class="udiff-line-added">+     else</span>
<span class="udiff-line-added">+       g_warning (&quot;invalid uninstantiatable type &#39;%s&#39; in cast to &#39;%s&#39;&quot;,</span>
<span class="udiff-line-added">+            type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type),</span>
<span class="udiff-line-added">+            type_descriptive_name_I (iface_type));</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+       else</span>
<span class="udiff-line-added">+   g_warning (&quot;invalid unclassed pointer in cast to &#39;%s&#39;&quot;,</span>
<span class="udiff-line-added">+        type_descriptive_name_I (iface_type));</span>
      }
  
    return type_instance;
  }
  
  GTypeClass*
  g_type_check_class_cast (GTypeClass *type_class,
<span class="udiff-line-modified-removed">-              GType       is_a_type)</span>
<span class="udiff-line-modified-added">+        GType       is_a_type)</span>
  {
    if (type_class)
      {
        TypeNode *node, *iface;
        gboolean is_classed, check;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4111,24 +4114,24 @@</span>
        node = lookup_type_node_I (type_class-&gt;g_type);
        is_classed = node &amp;&amp; node-&gt;is_classed;
        iface = lookup_type_node_I (is_a_type);
        check = is_classed &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, FALSE, FALSE);
        if (check)
<span class="udiff-line-modified-removed">-     return type_class;</span>
<span class="udiff-line-modified-added">+   return type_class;</span>
  
        if (is_classed)
<span class="udiff-line-modified-removed">-     g_warning (&quot;invalid class cast from &#39;%s&#39; to &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-            type_descriptive_name_I (type_class-&gt;g_type),</span>
<span class="udiff-line-modified-removed">-            type_descriptive_name_I (is_a_type));</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;invalid class cast from &#39;%s&#39; to &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+        type_descriptive_name_I (type_class-&gt;g_type),</span>
<span class="udiff-line-modified-added">+        type_descriptive_name_I (is_a_type));</span>
        else
<span class="udiff-line-modified-removed">-     g_warning (&quot;invalid unclassed type &#39;%s&#39; in class cast to &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-            type_descriptive_name_I (type_class-&gt;g_type),</span>
<span class="udiff-line-modified-removed">-            type_descriptive_name_I (is_a_type));</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;invalid unclassed type &#39;%s&#39; in class cast to &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+        type_descriptive_name_I (type_class-&gt;g_type),</span>
<span class="udiff-line-modified-added">+        type_descriptive_name_I (is_a_type));</span>
      }
    else
      g_warning (&quot;invalid class cast from (NULL) pointer to &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-            type_descriptive_name_I (is_a_type));</span>
<span class="udiff-line-modified-added">+          type_descriptive_name_I (is_a_type));</span>
    return type_class;
  }
  
  /**
   * g_type_check_instance:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4146,21 +4149,21 @@</span>
     * conveniently elaborated on instance checks
     */
    if (type_instance)
      {
        if (type_instance-&gt;g_class)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       TypeNode *node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     TypeNode *node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);</span>
  
<span class="udiff-line-modified-removed">-       if (node &amp;&amp; node-&gt;is_instantiatable)</span>
<span class="udiff-line-modified-removed">-         return TRUE;</span>
<span class="udiff-line-modified-added">+     if (node &amp;&amp; node-&gt;is_instantiatable)</span>
<span class="udiff-line-modified-added">+       return TRUE;</span>
  
<span class="udiff-line-modified-removed">-       g_warning (&quot;instance of invalid non-instantiatable type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-              type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type));</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;instance of invalid non-instantiatable type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+          type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type));</span>
<span class="udiff-line-modified-added">+   }</span>
        else
<span class="udiff-line-modified-removed">-     g_warning (&quot;instance with invalid (NULL) class pointer&quot;);</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;instance with invalid (NULL) class pointer&quot;);</span>
      }
    else
      g_warning (&quot;invalid (NULL) pointer instance&quot;);
  
    return FALSE;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4180,29 +4183,29 @@</span>
    G_READ_LOCK (&amp;type_rw_lock);
   restart_check:
    if (node)
      {
        if (node-&gt;data &amp;&amp; NODE_REFCOUNT (node) &gt; 0 &amp;&amp;
<span class="udiff-line-modified-removed">-       node-&gt;data-&gt;common.value_table-&gt;value_init)</span>
<span class="udiff-line-modified-removed">-     tflags = GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags));</span>
<span class="udiff-line-modified-added">+     node-&gt;data-&gt;common.value_table-&gt;value_init)</span>
<span class="udiff-line-modified-added">+   tflags = GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags));</span>
        else if (NODE_IS_IFACE (node))
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       guint i;</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     guint i;</span>
  
<span class="udiff-line-modified-removed">-       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (node); i++)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           GType prtype = IFACE_NODE_PREREQUISITES (node)[i];</span>
<span class="udiff-line-modified-removed">-           TypeNode *prnode = lookup_type_node_I (prtype);</span>
<span class="udiff-line-modified-added">+     for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (node); i++)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         GType prtype = IFACE_NODE_PREREQUISITES (node)[i];</span>
<span class="udiff-line-modified-added">+         TypeNode *prnode = lookup_type_node_I (prtype);</span>
  
<span class="udiff-line-modified-removed">-           if (prnode-&gt;is_instantiatable)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           type = prtype;</span>
<span class="udiff-line-modified-removed">-           node = lookup_type_node_I (type);</span>
<span class="udiff-line-modified-removed">-           goto restart_check;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         if (prnode-&gt;is_instantiatable)</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       type = prtype;</span>
<span class="udiff-line-modified-added">+       node = lookup_type_node_I (type);</span>
<span class="udiff-line-modified-added">+       goto restart_check;</span>
      }
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+   }</span>
      }
    G_READ_UNLOCK (&amp;type_rw_lock);
  
    return !(tflags &amp; G_TYPE_FLAG_VALUE_ABSTRACT);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4219,11 +4222,11 @@</span>
    return value &amp;&amp; type_check_is_value_type_U (value-&gt;g_type);
  }
  
  gboolean
  g_type_check_value_holds (const GValue *value,
<span class="udiff-line-modified-removed">-               GType         type)</span>
<span class="udiff-line-modified-added">+         GType         type)</span>
  {
    return value &amp;&amp; type_check_is_value_type_U (value-&gt;g_type) &amp;&amp; g_type_is_a (value-&gt;g_type, type);
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4255,28 +4258,28 @@</span>
    has_refed_data = node &amp;&amp; node-&gt;data &amp;&amp; NODE_REFCOUNT (node) &gt; 0;
    has_table = has_refed_data &amp;&amp; node-&gt;data-&gt;common.value_table-&gt;value_init;
    if (has_refed_data)
      {
        if (has_table)
<span class="udiff-line-modified-removed">-     vtable = node-&gt;data-&gt;common.value_table;</span>
<span class="udiff-line-modified-added">+   vtable = node-&gt;data-&gt;common.value_table;</span>
        else if (NODE_IS_IFACE (node))
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       guint i;</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     guint i;</span>
  
<span class="udiff-line-modified-removed">-       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (node); i++)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           GType prtype = IFACE_NODE_PREREQUISITES (node)[i];</span>
<span class="udiff-line-modified-removed">-           TypeNode *prnode = lookup_type_node_I (prtype);</span>
<span class="udiff-line-modified-added">+     for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (node); i++)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         GType prtype = IFACE_NODE_PREREQUISITES (node)[i];</span>
<span class="udiff-line-modified-added">+         TypeNode *prnode = lookup_type_node_I (prtype);</span>
  
<span class="udiff-line-modified-removed">-           if (prnode-&gt;is_instantiatable)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           type = prtype;</span>
<span class="udiff-line-modified-removed">-           node = lookup_type_node_I (type);</span>
<span class="udiff-line-modified-removed">-           goto restart_table_peek;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+         if (prnode-&gt;is_instantiatable)</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       type = prtype;</span>
<span class="udiff-line-modified-added">+       node = lookup_type_node_I (type);</span>
<span class="udiff-line-modified-added">+       goto restart_table_peek;</span>
      }
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+   }</span>
      }
  
    G_READ_UNLOCK (&amp;type_rw_lock);
  
    if (vtable)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4284,11 +4287,11 @@</span>
  
    if (!node)
      g_warning (G_STRLOC &quot;: type id &#39;%&quot; G_GSIZE_FORMAT &quot;&#39; is invalid&quot;, type);
    if (!has_refed_data)
      g_warning (&quot;can&#39;t peek value table for type &#39;%s&#39; which is not currently referenced&quot;,
<span class="udiff-line-modified-removed">-            type_descriptive_name_I (type));</span>
<span class="udiff-line-modified-added">+          type_descriptive_name_I (type));</span>
  
    return NULL;
  }
  
  const gchar *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4351,18 +4354,20 @@</span>
   * If you need to enable debugging features, use the GOBJECT_DEBUG
   * environment variable.
   *
   * Deprecated: 2.36: the type system is now initialised automatically
   */
<span class="udiff-line-added">+ G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
  void
  g_type_init_with_debug_flags (GTypeDebugFlags debug_flags)
  {
    g_assert_type_system_initialized ();
  
    if (debug_flags)
      g_message (&quot;g_type_init_with_debug_flags() is no longer supported.  Use the GOBJECT_DEBUG environment variable.&quot;);
  }
<span class="udiff-line-added">+ G_GNUC_END_IGNORE_DEPRECATIONS</span>
  
  /**
   * g_type_init:
   *
   * This function used to initialise the type system.  Since GLib 2.36,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4394,11 +4399,11 @@</span>
  gobject_init (void)
  {
    const gchar *env_string;
    GTypeInfo info;
    TypeNode *node;
<span class="udiff-line-modified-removed">-   GType type;</span>
<span class="udiff-line-modified-added">+   GType type G_GNUC_UNUSED  /* when compiling with G_DISABLE_ASSERT */;</span>
  
    /* Ensure GLib is initialized first, see
     * https://bugzilla.gnome.org/show_bug.cgi?id=756139
     */
    GLIB_PRIVATE_CALL (glib_init) ();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4601,33 +4606,33 @@</span>
   * Deprecated: 2.58: Use the G_ADD_PRIVATE() macro with the `G_DEFINE_*`
   *   family of macros to add instance private data to a type
   */
  void
  g_type_class_add_private (gpointer g_class,
<span class="udiff-line-modified-removed">-               gsize    private_size)</span>
<span class="udiff-line-modified-added">+         gsize    private_size)</span>
  {
    GType instance_type = ((GTypeClass *)g_class)-&gt;g_type;
    TypeNode *node = lookup_type_node_I (instance_type);
  
    g_return_if_fail (private_size &gt; 0);
    g_return_if_fail (private_size &lt;= 0xffff);
  
    if (!node || !node-&gt;is_instantiatable || !node-&gt;data || node-&gt;data-&gt;class.class != g_class)
      {
        g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (instance_type));</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (instance_type));</span>
        return;
      }
  
    if (NODE_PARENT_TYPE (node))
      {
        TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
        if (node-&gt;data-&gt;instance.private_size != pnode-&gt;data-&gt;instance.private_size)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;g_type_class_add_private() called multiple times for the same type&quot;);</span>
<span class="udiff-line-modified-removed">-       return;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;g_type_class_add_private() called multiple times for the same type&quot;);</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
  
    G_WRITE_LOCK (&amp;type_rw_lock);
  
    private_size = ALIGN_STRUCT (node-&gt;data-&gt;instance.private_size + private_size);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4648,11 +4653,11 @@</span>
    g_return_val_if_fail (private_size &lt;= 0xffff, 0);
  
    if (!node || !node-&gt;is_classed || !node-&gt;is_instantiatable || !node-&gt;data)
      {
        g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (class_gtype));</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (class_gtype));</span>
        return 0;
      }
  
    if (node-&gt;plugin != NULL)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4715,24 +4720,24 @@</span>
      return;
  
    if (!node || !node-&gt;is_classed || !node-&gt;is_instantiatable || !node-&gt;data)
      {
        g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (class_gtype));</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (class_gtype));</span>
        *private_size_or_offset = 0;
        return;
      }
  
    if (NODE_PARENT_TYPE (node))
      {
        TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
        if (node-&gt;data-&gt;instance.private_size != pnode-&gt;data-&gt;instance.private_size)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;g_type_add_instance_private() called multiple times for the same type&quot;);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;g_type_add_instance_private() called multiple times for the same type&quot;);</span>
            *private_size_or_offset = 0;
<span class="udiff-line-modified-removed">-       return;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
  
    G_WRITE_LOCK (&amp;type_rw_lock);
  
    private_size = ALIGN_STRUCT (node-&gt;data-&gt;instance.private_size + *private_size_or_offset);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4744,11 +4749,11 @@</span>
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  }
  
  gpointer
  g_type_instance_get_private (GTypeInstance *instance,
<span class="udiff-line-modified-removed">-                  GType          private_type)</span>
<span class="udiff-line-modified-added">+            GType          private_type)</span>
  {
    TypeNode *node;
  
    g_return_val_if_fail (instance != NULL &amp;&amp; instance-&gt;g_class != NULL, NULL);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4811,11 +4816,11 @@</span>
    return -(gint) node-&gt;data-&gt;instance.private_size;
  }
  
  /**
   * g_type_add_class_private:
<span class="udiff-line-modified-removed">-  * @class_type: GType of an classed type</span>
<span class="udiff-line-modified-added">+  * @class_type: GType of a classed type</span>
   * @private_size: size of private structure
   *
   * Registers a private class structure for a classed type;
   * when the class is allocated, the private structures for
   * the class and all of its parent types are allocated
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4829,32 +4834,32 @@</span>
   *
   * Since: 2.24
   */
  void
  g_type_add_class_private (GType    class_type,
<span class="udiff-line-modified-removed">-               gsize    private_size)</span>
<span class="udiff-line-modified-added">+         gsize    private_size)</span>
  {
    TypeNode *node = lookup_type_node_I (class_type);
    gsize offset;
  
    g_return_if_fail (private_size &gt; 0);
  
    if (!node || !node-&gt;is_classed || !node-&gt;data)
      {
        g_warning (&quot;cannot add class private field to invalid type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (class_type));</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (class_type));</span>
        return;
      }
  
    if (NODE_PARENT_TYPE (node))
      {
        TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
        if (node-&gt;data-&gt;class.class_private_size != pnode-&gt;data-&gt;class.class_private_size)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;g_type_add_class_private() called multiple times for the same type&quot;);</span>
<span class="udiff-line-modified-removed">-       return;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;g_type_add_class_private() called multiple times for the same type&quot;);</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
  
    G_WRITE_LOCK (&amp;type_rw_lock);
  
    offset = ALIGN_STRUCT (node-&gt;data-&gt;class.class_private_size);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4863,11 +4868,11 @@</span>
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  }
  
  gpointer
  g_type_class_get_private (GTypeClass *klass,
<span class="udiff-line-modified-removed">-               GType       private_type)</span>
<span class="udiff-line-modified-added">+         GType       private_type)</span>
  {
    TypeNode *class_node;
    TypeNode *private_node;
    TypeNode *parent_node;
    gsize offset;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4876,19 +4881,19 @@</span>
  
    class_node = lookup_type_node_I (klass-&gt;g_type);
    if (G_UNLIKELY (!class_node || !class_node-&gt;is_classed))
      {
        g_warning (&quot;class of invalid type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (klass-&gt;g_type));</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (klass-&gt;g_type));</span>
        return NULL;
      }
  
    private_node = lookup_type_node_I (private_type);
    if (G_UNLIKELY (!private_node || !NODE_IS_ANCESTOR (private_node, class_node)))
      {
        g_warning (&quot;attempt to retrieve private data for invalid type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          type_descriptive_name_I (private_type));</span>
<span class="udiff-line-modified-added">+      type_descriptive_name_I (private_type));</span>
        return NULL;
      }
  
    offset = ALIGN_STRUCT (class_node-&gt;data-&gt;class.class_size);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4896,14 +4901,14 @@</span>
      {
        parent_node = lookup_type_node_I (NODE_PARENT_TYPE (private_node));
        g_assert (parent_node-&gt;data &amp;&amp; NODE_REFCOUNT (parent_node) &gt; 0);
  
        if (G_UNLIKELY (private_node-&gt;data-&gt;class.class_private_size == parent_node-&gt;data-&gt;class.class_private_size))
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;g_type_instance_get_class_private() requires a prior call to g_type_add_class_private()&quot;);</span>
<span class="udiff-line-modified-removed">-       return NULL;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;g_type_instance_get_class_private() requires a prior call to g_type_add_class_private()&quot;);</span>
<span class="udiff-line-modified-added">+     return NULL;</span>
<span class="udiff-line-modified-added">+   }</span>
  
        offset += ALIGN_STRUCT (parent_node-&gt;data-&gt;class.class_private_size);
      }
  
    return G_STRUCT_MEMBER_P (klass, offset);
</pre>
<center><a href="gtype-private.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gtype.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>