<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn-win32.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gspawn-win32-helper.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gspawn.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn-win32.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 65,21 ***</span>
  #ifdef G_SPAWN_WIN32_DEBUG
    static int debug = 1;
    #define SETUP_DEBUG() /* empty */
  #else
    static int debug = -1;
<span class="line-modified">!   #define SETUP_DEBUG()                 \</span>
<span class="line-modified">!     G_STMT_START                    \</span>
<span class="line-modified">!       {                         \</span>
<span class="line-modified">!     if (debug == -1)                \</span>
<span class="line-modified">!       {                     \</span>
<span class="line-modified">!         if (getenv (&quot;G_SPAWN_WIN32_DEBUG&quot;) != NULL) \</span>
<span class="line-modified">!           debug = 1;                \</span>
<span class="line-modified">!         else                    \</span>
<span class="line-modified">!           debug = 0;                \</span>
<span class="line-modified">!       }                     \</span>
<span class="line-modified">!       }                         \</span>
      G_STMT_END
  #endif
  #endif
  
  enum
<span class="line-new-header">--- 65,21 ---</span>
  #ifdef G_SPAWN_WIN32_DEBUG
    static int debug = 1;
    #define SETUP_DEBUG() /* empty */
  #else
    static int debug = -1;
<span class="line-modified">!   #define SETUP_DEBUG()         \</span>
<span class="line-modified">!     G_STMT_START          \</span>
<span class="line-modified">!       {             \</span>
<span class="line-modified">!   if (debug == -1)        \</span>
<span class="line-modified">!     {           \</span>
<span class="line-modified">!       if (getenv (&quot;G_SPAWN_WIN32_DEBUG&quot;) != NULL) \</span>
<span class="line-modified">!         debug = 1;        \</span>
<span class="line-modified">!       else          \</span>
<span class="line-modified">!         debug = 0;        \</span>
<span class="line-modified">!     }           \</span>
<span class="line-modified">!       }             \</span>
      G_STMT_END
  #endif
  #endif
  
  enum
</pre>
<hr />
<pre>
<span class="line-old-header">*** 103,18 ***</span>
    ARG_PROGRAM,
    ARG_COUNT = ARG_PROGRAM
  };
  
  static int
<span class="line-modified">! dup_noninherited (int fd,</span>
<span class="line-modified">!           int mode)</span>
  {
    HANDLE filehandle;
  
    DuplicateHandle (GetCurrentProcess (), (LPHANDLE) _get_osfhandle (fd),
<span class="line-modified">!            GetCurrentProcess (), &amp;filehandle,</span>
<span class="line-modified">!            0, FALSE, DUPLICATE_SAME_ACCESS);</span>
    close (fd);
    return _open_osfhandle ((gintptr) filehandle, mode | _O_NOINHERIT);
  }
  
  #ifndef GSPAWN_HELPER
<span class="line-new-header">--- 103,18 ---</span>
    ARG_PROGRAM,
    ARG_COUNT = ARG_PROGRAM
  };
  
  static int
<span class="line-modified">! reopen_noninherited (int fd,</span>
<span class="line-modified">!          int mode)</span>
  {
    HANDLE filehandle;
  
    DuplicateHandle (GetCurrentProcess (), (LPHANDLE) _get_osfhandle (fd),
<span class="line-modified">!        GetCurrentProcess (), &amp;filehandle,</span>
<span class="line-modified">!        0, FALSE, DUPLICATE_SAME_ACCESS);</span>
    close (fd);
    return _open_osfhandle ((gintptr) filehandle, mode | _O_NOINHERIT);
  }
  
  #ifndef GSPAWN_HELPER
</pre>
<hr />
<pre>
<span class="line-old-header">*** 123,67 ***</span>
  #define HELPER_PROCESS &quot;gspawn-win64-helper&quot;
  #else
  #define HELPER_PROCESS &quot;gspawn-win32-helper&quot;
  #endif
  
  static gchar *
  protect_argv_string (const gchar *string)
  {
    const gchar *p = string;
    gchar *retval, *q;
    gint len = 0;
    gboolean need_dblquotes = FALSE;
    while (*p)
      {
        if (*p == &#39; &#39; || *p == &#39;\t&#39;)
<span class="line-modified">!     need_dblquotes = TRUE;</span>
<span class="line-modified">!       else if (*p == &#39;&quot;&#39;)</span>
<span class="line-modified">!     len++;</span>
<span class="line-modified">!       else if (*p == &#39;\\&#39;)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       const gchar *pp = p;</span>
<span class="line-removed">-       while (*pp &amp;&amp; *pp == &#39;\\&#39;)</span>
<span class="line-removed">-         pp++;</span>
<span class="line-removed">-       if (*pp == &#39;&quot;&#39;)</span>
<span class="line-removed">-         len++;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-       len++;</span>
        p++;
      }
  
    q = retval = g_malloc (len + need_dblquotes*2 + 1);
    p = string;
  
    if (need_dblquotes)
      *q++ = &#39;&quot;&#39;;
<span class="line-modified">! </span>
    while (*p)
      {
        if (*p == &#39;&quot;&#39;)
      *q++ = &#39;\\&#39;;
<span class="line-modified">!       else if (*p == &#39;\\&#39;)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       const gchar *pp = p;</span>
<span class="line-modified">!       while (*pp &amp;&amp; *pp == &#39;\\&#39;)</span>
<span class="line-modified">!         pp++;</span>
<span class="line-modified">!       if (*pp == &#39;&quot;&#39;)</span>
<span class="line-modified">!         *q++ = &#39;\\&#39;;</span>
<span class="line-modified">!     }</span>
        *q++ = *p;
        p++;
      }
  
    if (need_dblquotes)
<span class="line-modified">!     *q++ = &#39;&quot;&#39;;</span>
    *q++ = &#39;\0&#39;;
  
    return retval;
  }
  
  static gint
  protect_argv (gchar  **argv,
<span class="line-modified">!           gchar ***new_argv)</span>
  {
    gint i;
    gint argc = 0;
  
    while (argv[argc])
<span class="line-new-header">--- 123,78 ---</span>
  #define HELPER_PROCESS &quot;gspawn-win64-helper&quot;
  #else
  #define HELPER_PROCESS &quot;gspawn-win32-helper&quot;
  #endif
  
<span class="line-added">+ /* This logic has a copy for wchar_t in gspawn-win32-helper.c, protect_wargv() */</span>
  static gchar *
  protect_argv_string (const gchar *string)
  {
    const gchar *p = string;
    gchar *retval, *q;
    gint len = 0;
<span class="line-added">+   gint pre_bslash = 0;</span>
    gboolean need_dblquotes = FALSE;
    while (*p)
      {
        if (*p == &#39; &#39; || *p == &#39;\t&#39;)
<span class="line-modified">!   need_dblquotes = TRUE;</span>
<span class="line-modified">!       /* estimate max len, assuming that all escapable chracters will be escaped */</span>
<span class="line-modified">!       if (*p == &#39;&quot;&#39; || *p == &#39;\\&#39;)</span>
<span class="line-modified">!   len += 2;</span>
<span class="line-modified">!       else</span>
<span class="line-modified">!   len += 1;</span>
        p++;
      }
  
    q = retval = g_malloc (len + need_dblquotes*2 + 1);
    p = string;
  
    if (need_dblquotes)
      *q++ = &#39;&quot;&#39;;
<span class="line-modified">!   /* Only quotes and backslashes preceeding quotes are escaped:</span>
<span class="line-added">+    * see &quot;Parsing C Command-Line Arguments&quot; at</span>
<span class="line-added">+    * https://docs.microsoft.com/en-us/cpp/c-language/parsing-c-command-line-arguments</span>
<span class="line-added">+    */</span>
    while (*p)
      {
        if (*p == &#39;&quot;&#39;)
<span class="line-added">+   {</span>
<span class="line-added">+     /* Add backslash for escaping quote itself */</span>
      *q++ = &#39;\\&#39;;
<span class="line-modified">!     /* Add backslash for every preceeding backslash for escaping it */</span>
<span class="line-modified">!     for (;pre_bslash &gt; 0; --pre_bslash)</span>
<span class="line-modified">!       *q++ = &#39;\\&#39;;</span>
<span class="line-modified">!   }</span>
<span class="line-modified">! </span>
<span class="line-modified">!       /* Count length of continuous sequence of preceeding backslashes. */</span>
<span class="line-modified">!       if (*p == &#39;\\&#39;)</span>
<span class="line-modified">!   ++pre_bslash;</span>
<span class="line-added">+       else</span>
<span class="line-added">+   pre_bslash = 0;</span>
<span class="line-added">+ </span>
        *q++ = *p;
        p++;
      }
  
    if (need_dblquotes)
<span class="line-modified">!     {</span>
<span class="line-added">+       /* Add backslash for every preceeding backslash for escaping it,</span>
<span class="line-added">+        * do NOT escape quote itself.</span>
<span class="line-added">+        */</span>
<span class="line-added">+       for (;pre_bslash &gt; 0; --pre_bslash)</span>
<span class="line-added">+   *q++ = &#39;\\&#39;;</span>
<span class="line-added">+       *q++ = &#39;&quot;&#39;;</span>
<span class="line-added">+     }</span>
    *q++ = &#39;\0&#39;;
  
    return retval;
  }
  
  static gint
  protect_argv (gchar  **argv,
<span class="line-modified">!         gchar ***new_argv)</span>
  {
    gint i;
    gint argc = 0;
  
    while (argv[argc])
</pre>
<hr />
<pre>
<span class="line-old-header">*** 194,11 ***</span>
     * reconstructed correctly in the C runtime startup code.  Note that
     * the unquoting algorithm in the C runtime is really weird, and
     * rather different than what Unix shells do. See stdargv.c in the C
     * runtime sources (in the Platform SDK, in src/crt).
     *
<span class="line-modified">!    * Note that an new_argv[0] constructed by this function should</span>
     * *not* be passed as the filename argument to a spawn* or exec*
     * family function. That argument should be the real file name
     * without any quoting.
     */
    for (i = 0; i &lt; argc; i++)
<span class="line-new-header">--- 205,11 ---</span>
     * reconstructed correctly in the C runtime startup code.  Note that
     * the unquoting algorithm in the C runtime is really weird, and
     * rather different than what Unix shells do. See stdargv.c in the C
     * runtime sources (in the Platform SDK, in src/crt).
     *
<span class="line-modified">!    * Note that a new_argv[0] constructed by this function should</span>
     * *not* be passed as the filename argument to a spawn* or exec*
     * family function. That argument should be the real file name
     * without any quoting.
     */
    for (i = 0; i &lt; argc; i++)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 212,28 ***</span>
  G_DEFINE_QUARK (g-exec-error-quark, g_spawn_error)
  G_DEFINE_QUARK (g-spawn-exit-error-quark, g_spawn_exit_error)
  
  gboolean
  g_spawn_async (const gchar          *working_directory,
<span class="line-modified">!             gchar               **argv,</span>
<span class="line-modified">!             gchar               **envp,</span>
<span class="line-modified">!             GSpawnFlags           flags,</span>
<span class="line-modified">!             GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!             gpointer              user_data,</span>
<span class="line-modified">!             GPid                 *child_handle,</span>
<span class="line-modified">!             GError              **error)</span>
  {
    g_return_val_if_fail (argv != NULL, FALSE);
  
    return g_spawn_async_with_pipes (working_directory,
<span class="line-modified">!                     argv, envp,</span>
<span class="line-modified">!                     flags,</span>
<span class="line-modified">!                     child_setup,</span>
<span class="line-modified">!                     user_data,</span>
<span class="line-modified">!                     child_handle,</span>
<span class="line-modified">!                     NULL, NULL, NULL,</span>
<span class="line-modified">!                     error);</span>
  }
  
  /* Avoids a danger in threaded situations (calling close()
   * on a file descriptor twice, and another thread has
   * re-opened it since the first close)
<span class="line-new-header">--- 223,28 ---</span>
  G_DEFINE_QUARK (g-exec-error-quark, g_spawn_error)
  G_DEFINE_QUARK (g-spawn-exit-error-quark, g_spawn_exit_error)
  
  gboolean
  g_spawn_async (const gchar          *working_directory,
<span class="line-modified">!                gchar               **argv,</span>
<span class="line-modified">!                gchar               **envp,</span>
<span class="line-modified">!                GSpawnFlags           flags,</span>
<span class="line-modified">!                GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!                gpointer              user_data,</span>
<span class="line-modified">!                GPid                 *child_handle,</span>
<span class="line-modified">!                GError              **error)</span>
  {
    g_return_val_if_fail (argv != NULL, FALSE);
  
    return g_spawn_async_with_pipes (working_directory,
<span class="line-modified">!                                    argv, envp,</span>
<span class="line-modified">!                                    flags,</span>
<span class="line-modified">!                                    child_setup,</span>
<span class="line-modified">!                                    user_data,</span>
<span class="line-modified">!                                    child_handle,</span>
<span class="line-modified">!                                    NULL, NULL, NULL,</span>
<span class="line-modified">!                                    error);</span>
  }
  
  /* Avoids a danger in threaded situations (calling close()
   * on a file descriptor twice, and another thread has
   * re-opened it since the first close)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 308,31 ***</span>
  /* The helper process writes a status report back to us, through a
   * pipe, consisting of two ints.
   */
  static gboolean
  read_helper_report (int      fd,
<span class="line-modified">!             gintptr  report[2],</span>
<span class="line-modified">!             GError **error)</span>
  {
    gint bytes = 0;
  
    while (bytes &lt; sizeof(gintptr)*2)
      {
        gint chunk;
        int errsv;
  
        if (debug)
<span class="line-modified">!     g_print (&quot;%s:read_helper_report: read %&quot; G_GSIZE_FORMAT &quot;...\n&quot;,</span>
<span class="line-modified">!          __FILE__,</span>
<span class="line-modified">!          sizeof(gintptr)*2 - bytes);</span>
  
        chunk = read (fd, ((gchar*)report) + bytes,
<span class="line-modified">!             sizeof(gintptr)*2 - bytes);</span>
        errsv = errno;
  
        if (debug)
<span class="line-modified">!     g_print (&quot;...got %d bytes\n&quot;, chunk);</span>
  
        if (chunk &lt; 0)
          {
            /* Some weird shit happened, bail out */
            g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-new-header">--- 319,31 ---</span>
  /* The helper process writes a status report back to us, through a
   * pipe, consisting of two ints.
   */
  static gboolean
  read_helper_report (int      fd,
<span class="line-modified">!         gintptr  report[2],</span>
<span class="line-modified">!         GError **error)</span>
  {
    gint bytes = 0;
  
    while (bytes &lt; sizeof(gintptr)*2)
      {
        gint chunk;
        int errsv;
  
        if (debug)
<span class="line-modified">!   g_print (&quot;%s:read_helper_report: read %&quot; G_GSIZE_FORMAT &quot;...\n&quot;,</span>
<span class="line-modified">!      __FILE__,</span>
<span class="line-modified">!      sizeof(gintptr)*2 - bytes);</span>
  
        chunk = read (fd, ((gchar*)report) + bytes,
<span class="line-modified">!         sizeof(gintptr)*2 - bytes);</span>
        errsv = errno;
  
        if (debug)
<span class="line-modified">!   g_print (&quot;...got %d bytes\n&quot;, chunk);</span>
  
        if (chunk &lt; 0)
          {
            /* Some weird shit happened, bail out */
            g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 340,43 ***</span>
                         g_strerror (errsv));
  
            return FALSE;
          }
        else if (chunk == 0)
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,</span>
<span class="line-modified">!                _(&quot;Failed to read from child pipe (%s)&quot;),</span>
<span class="line-modified">!                &quot;EOF&quot;);</span>
<span class="line-modified">!       break; /* EOF */</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     bytes += chunk;</span>
      }
  
    if (bytes &lt; sizeof(gintptr)*2)
      return FALSE;
  
    return TRUE;
  }
  
  static void
  set_child_error (gintptr      report[2],
<span class="line-modified">!          const gchar *working_directory,</span>
<span class="line-modified">!          GError     **error)</span>
  {
    switch (report[0])
      {
      case CHILD_CHDIR_FAILED:
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR,
<span class="line-modified">!            _(&quot;Failed to change to directory &#39;%s&#39; (%s)&quot;),</span>
<span class="line-modified">!            working_directory,</span>
<span class="line-modified">!            g_strerror (report[1]));</span>
        break;
      case CHILD_SPAWN_FAILED:
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!            _(&quot;Failed to execute child process (%s)&quot;),</span>
<span class="line-modified">!            g_strerror (report[1]));</span>
        break;
      case CHILD_SPAWN_NOENT:
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT,
                     _(&quot;Failed to execute child process (%s)&quot;),
                     g_strerror (report[1]));
<span class="line-new-header">--- 351,43 ---</span>
                         g_strerror (errsv));
  
            return FALSE;
          }
        else if (chunk == 0)
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,</span>
<span class="line-modified">!            _(&quot;Failed to read from child pipe (%s)&quot;),</span>
<span class="line-modified">!            &quot;EOF&quot;);</span>
<span class="line-modified">!     break; /* EOF */</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   bytes += chunk;</span>
      }
  
    if (bytes &lt; sizeof(gintptr)*2)
      return FALSE;
  
    return TRUE;
  }
  
  static void
  set_child_error (gintptr      report[2],
<span class="line-modified">!      const gchar *working_directory,</span>
<span class="line-modified">!      GError     **error)</span>
  {
    switch (report[0])
      {
      case CHILD_CHDIR_FAILED:
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR,
<span class="line-modified">!        _(&quot;Failed to change to directory &#39;%s&#39; (%s)&quot;),</span>
<span class="line-modified">!        working_directory,</span>
<span class="line-modified">!        g_strerror (report[1]));</span>
        break;
      case CHILD_SPAWN_FAILED:
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!        _(&quot;Failed to execute child process (%s)&quot;),</span>
<span class="line-modified">!        g_strerror (report[1]));</span>
        break;
      case CHILD_SPAWN_NOENT:
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT,
                     _(&quot;Failed to execute child process (%s)&quot;),
                     g_strerror (report[1]));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 386,54 ***</span>
      }
  }
  
  static gboolean
  utf8_charv_to_wcharv (char     **utf8_charv,
<span class="line-modified">!               wchar_t ***wcharv,</span>
<span class="line-modified">!               int       *error_index,</span>
<span class="line-modified">!               GError   **error)</span>
  {
    wchar_t **retval = NULL;
  
    *wcharv = NULL;
    if (utf8_charv != NULL)
      {
        int n = 0, i;
  
        while (utf8_charv[n])
<span class="line-modified">!     n++;</span>
        retval = g_new (wchar_t *, n + 1);
  
        for (i = 0; i &lt; n; i++)
<span class="line-modified">!     {</span>
<span class="line-modified">!       retval[i] = g_utf8_to_utf16 (utf8_charv[i], -1, NULL, NULL, error);</span>
<span class="line-modified">!       if (retval[i] == NULL)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           if (error_index)</span>
<span class="line-modified">!         *error_index = i;</span>
<span class="line-modified">!           while (i)</span>
<span class="line-modified">!         g_free (retval[--i]);</span>
<span class="line-modified">!           g_free (retval);</span>
<span class="line-modified">!           return FALSE;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
  
        retval[n] = NULL;
      }
    *wcharv = retval;
    return TRUE;
  }
  
  static gboolean
  do_spawn_directly (gint                 *exit_status,
<span class="line-modified">!            gboolean      do_return_handle,</span>
<span class="line-modified">!                    GSpawnFlags           flags,</span>
<span class="line-modified">!                    gchar               **argv,</span>
<span class="line-modified">!                    char                **envp,</span>
<span class="line-modified">!                    char                **protected_argv,</span>
<span class="line-modified">!                    GPid                 *child_handle,</span>
<span class="line-modified">!                    GError              **error)</span>
  {
    const int mode = (exit_status == NULL) ? P_NOWAIT : P_WAIT;
    char **new_argv;
    gintptr rc = -1;
    int errsv;
<span class="line-new-header">--- 397,54 ---</span>
      }
  }
  
  static gboolean
  utf8_charv_to_wcharv (char     **utf8_charv,
<span class="line-modified">!           wchar_t ***wcharv,</span>
<span class="line-modified">!           int       *error_index,</span>
<span class="line-modified">!           GError   **error)</span>
  {
    wchar_t **retval = NULL;
  
    *wcharv = NULL;
    if (utf8_charv != NULL)
      {
        int n = 0, i;
  
        while (utf8_charv[n])
<span class="line-modified">!   n++;</span>
        retval = g_new (wchar_t *, n + 1);
  
        for (i = 0; i &lt; n; i++)
<span class="line-modified">!   {</span>
<span class="line-modified">!     retval[i] = g_utf8_to_utf16 (utf8_charv[i], -1, NULL, NULL, error);</span>
<span class="line-modified">!     if (retval[i] == NULL)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         if (error_index)</span>
<span class="line-modified">!     *error_index = i;</span>
<span class="line-modified">!         while (i)</span>
<span class="line-modified">!     g_free (retval[--i]);</span>
<span class="line-modified">!         g_free (retval);</span>
<span class="line-modified">!         return FALSE;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!   }</span>
  
        retval[n] = NULL;
      }
    *wcharv = retval;
    return TRUE;
  }
  
  static gboolean
  do_spawn_directly (gint                 *exit_status,
<span class="line-modified">!        gboolean    do_return_handle,</span>
<span class="line-modified">!        GSpawnFlags           flags,</span>
<span class="line-modified">!        gchar               **argv,</span>
<span class="line-modified">!        char                **envp,</span>
<span class="line-modified">!        char                **protected_argv,</span>
<span class="line-modified">!        GPid                 *child_handle,</span>
<span class="line-modified">!        GError              **error)</span>
  {
    const int mode = (exit_status == NULL) ? P_NOWAIT : P_WAIT;
    char **new_argv;
    gintptr rc = -1;
    int errsv;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 445,33 ***</span>
  
    wargv0 = g_utf8_to_utf16 (argv[0], -1, NULL, NULL, &amp;conv_error);
    if (wargv0 == NULL)
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!            _(&quot;Invalid program name: %s&quot;),</span>
<span class="line-modified">!            conv_error-&gt;message);</span>
        g_error_free (conv_error);
  
        return FALSE;
      }
  
    if (!utf8_charv_to_wcharv (new_argv, &amp;wargv, &amp;conv_error_index, &amp;conv_error))
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!            _(&quot;Invalid string in argument vector at %d: %s&quot;),</span>
<span class="line-modified">!            conv_error_index, conv_error-&gt;message);</span>
        g_error_free (conv_error);
        g_free (wargv0);
  
        return FALSE;
      }
  
    if (!utf8_charv_to_wcharv (envp, &amp;wenvp, NULL, &amp;conv_error))
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!            _(&quot;Invalid string in environment: %s&quot;),</span>
<span class="line-modified">!            conv_error-&gt;message);</span>
        g_error_free (conv_error);
        g_free (wargv0);
        g_strfreev ((gchar **) wargv);
  
        return FALSE;
<span class="line-new-header">--- 456,33 ---</span>
  
    wargv0 = g_utf8_to_utf16 (argv[0], -1, NULL, NULL, &amp;conv_error);
    if (wargv0 == NULL)
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!        _(&quot;Invalid program name: %s&quot;),</span>
<span class="line-modified">!        conv_error-&gt;message);</span>
        g_error_free (conv_error);
  
        return FALSE;
      }
  
    if (!utf8_charv_to_wcharv (new_argv, &amp;wargv, &amp;conv_error_index, &amp;conv_error))
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!        _(&quot;Invalid string in argument vector at %d: %s&quot;),</span>
<span class="line-modified">!        conv_error_index, conv_error-&gt;message);</span>
        g_error_free (conv_error);
        g_free (wargv0);
  
        return FALSE;
      }
  
    if (!utf8_charv_to_wcharv (envp, &amp;wenvp, NULL, &amp;conv_error))
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!        _(&quot;Invalid string in environment: %s&quot;),</span>
<span class="line-modified">!        conv_error-&gt;message);</span>
        g_error_free (conv_error);
        g_free (wargv0);
        g_strfreev ((gchar **) wargv);
  
        return FALSE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 495,46 ***</span>
    g_strfreev ((gchar **) wenvp);
  
    if (rc == -1 &amp;&amp; errsv != 0)
      {
        g_set_error (error, G_SPAWN_ERROR, _g_spawn_exec_err_to_g_error (errsv),
<span class="line-modified">!                    _(&quot;Failed to execute child process (%s)&quot;),</span>
<span class="line-modified">!            g_strerror (errsv));</span>
        return FALSE;
      }
  
    if (exit_status == NULL)
      {
        if (child_handle &amp;&amp; do_return_handle)
<span class="line-modified">!     *child_handle = (GPid) rc;</span>
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       CloseHandle ((HANDLE) rc);</span>
<span class="line-modified">!       if (child_handle)</span>
<span class="line-modified">!         *child_handle = 0;</span>
<span class="line-modified">!     }</span>
      }
    else
      *exit_status = rc;
  
    return TRUE;
  }
  
  static gboolean
  do_spawn_with_fds (gint                 *exit_status,
<span class="line-modified">!            gboolean        do_return_handle,</span>
<span class="line-modified">!                    const gchar          *working_directory,</span>
<span class="line-modified">!                    gchar               **argv,</span>
<span class="line-modified">!                    char                **envp,</span>
<span class="line-modified">!                    GSpawnFlags           flags,</span>
<span class="line-modified">!                    GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!                    GPid                 *child_handle,</span>
<span class="line-modified">!            gint                  stdin_fd,</span>
<span class="line-modified">!            gint                  stdout_fd,</span>
<span class="line-modified">!            gint                  stderr_fd,</span>
<span class="line-modified">!            gint       *err_report,</span>
<span class="line-modified">!                    GError              **error)</span>
  {
    char **protected_argv;
    char args[ARG_COUNT][10];
    char **new_argv;
    int i;
<span class="line-new-header">--- 506,46 ---</span>
    g_strfreev ((gchar **) wenvp);
  
    if (rc == -1 &amp;&amp; errsv != 0)
      {
        g_set_error (error, G_SPAWN_ERROR, _g_spawn_exec_err_to_g_error (errsv),
<span class="line-modified">!        _(&quot;Failed to execute child process (%s)&quot;),</span>
<span class="line-modified">!        g_strerror (errsv));</span>
        return FALSE;
      }
  
    if (exit_status == NULL)
      {
        if (child_handle &amp;&amp; do_return_handle)
<span class="line-modified">!   *child_handle = (GPid) rc;</span>
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     CloseHandle ((HANDLE) rc);</span>
<span class="line-modified">!     if (child_handle)</span>
<span class="line-modified">!       *child_handle = 0;</span>
<span class="line-modified">!   }</span>
      }
    else
      *exit_status = rc;
  
    return TRUE;
  }
  
  static gboolean
  do_spawn_with_fds (gint                 *exit_status,
<span class="line-modified">!        gboolean      do_return_handle,</span>
<span class="line-modified">!        const gchar          *working_directory,</span>
<span class="line-modified">!        gchar               **argv,</span>
<span class="line-modified">!        char                **envp,</span>
<span class="line-modified">!        GSpawnFlags           flags,</span>
<span class="line-modified">!        GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!        GPid                 *child_handle,</span>
<span class="line-modified">!        gint                  stdin_fd,</span>
<span class="line-modified">!        gint                  stdout_fd,</span>
<span class="line-modified">!        gint                  stderr_fd,</span>
<span class="line-modified">!        gint     *err_report,</span>
<span class="line-modified">!        GError              **error)</span>
  {
    char **protected_argv;
    char args[ARG_COUNT][10];
    char **new_argv;
    int i;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 566,13 ***</span>
        (working_directory == NULL || !*working_directory) &amp;&amp;
        (flags &amp; G_SPAWN_LEAVE_DESCRIPTORS_OPEN))
      {
        /* We can do without the helper process */
        gboolean retval =
<span class="line-modified">!     do_spawn_directly (exit_status, do_return_handle, flags,</span>
<span class="line-modified">!                argv, envp, protected_argv,</span>
<span class="line-modified">!                child_handle, error);</span>
        g_strfreev (protected_argv);
        return retval;
      }
  
    if (!make_pipe (child_err_report_pipe, error))
<span class="line-new-header">--- 577,13 ---</span>
        (working_directory == NULL || !*working_directory) &amp;&amp;
        (flags &amp; G_SPAWN_LEAVE_DESCRIPTORS_OPEN))
      {
        /* We can do without the helper process */
        gboolean retval =
<span class="line-modified">!   do_spawn_directly (exit_status, do_return_handle, flags,</span>
<span class="line-modified">!          argv, envp, protected_argv,</span>
<span class="line-modified">!          child_handle, error);</span>
        g_strfreev (protected_argv);
        return retval;
      }
  
    if (!make_pipe (child_err_report_pipe, error))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 604,11 ***</span>
    /* Make the read end of the child error report pipe
     * noninherited. Otherwise it will needlessly be inherited by the
     * helper process, and the started actual user process. As such that
     * shouldn&#39;t harm, but it is unnecessary.
     */
<span class="line-modified">!   child_err_report_pipe[0] = dup_noninherited (child_err_report_pipe[0], _O_RDONLY);</span>
  
    if (flags &amp; G_SPAWN_FILE_AND_ARGV_ZERO)
      {
        /* Overload ARG_CHILD_ERR_REPORT to also encode the
         * G_SPAWN_FILE_AND_ARGV_ZERO functionality.
<span class="line-new-header">--- 615,11 ---</span>
    /* Make the read end of the child error report pipe
     * noninherited. Otherwise it will needlessly be inherited by the
     * helper process, and the started actual user process. As such that
     * shouldn&#39;t harm, but it is unnecessary.
     */
<span class="line-modified">!   child_err_report_pipe[0] = reopen_noninherited (child_err_report_pipe[0], _O_RDONLY);</span>
  
    if (flags &amp; G_SPAWN_FILE_AND_ARGV_ZERO)
      {
        /* Overload ARG_CHILD_ERR_REPORT to also encode the
         * G_SPAWN_FILE_AND_ARGV_ZERO functionality.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 623,11 ***</span>
     * helper process will inherit it, and thus if this process happens
     * to crash before writing the sync byte to the pipe, the helper
     * process won&#39;t read but won&#39;t get any EOF either, as it has the
     * write end open itself.
     */
<span class="line-modified">!   helper_sync_pipe[1] = dup_noninherited (helper_sync_pipe[1], _O_WRONLY);</span>
  
    if (stdin_fd != -1)
      {
        _g_sprintf (args[ARG_STDIN], &quot;%d&quot;, stdin_fd);
        new_argv[ARG_STDIN] = args[ARG_STDIN];
<span class="line-new-header">--- 634,11 ---</span>
     * helper process will inherit it, and thus if this process happens
     * to crash before writing the sync byte to the pipe, the helper
     * process won&#39;t read but won&#39;t get any EOF either, as it has the
     * write end open itself.
     */
<span class="line-modified">!   helper_sync_pipe[1] = reopen_noninherited (helper_sync_pipe[1], _O_WRONLY);</span>
  
    if (stdin_fd != -1)
      {
        _g_sprintf (args[ARG_STDIN], &quot;%d&quot;, stdin_fd);
        new_argv[ARG_STDIN] = args[ARG_STDIN];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 655,11 ***</span>
    else
      {
        new_argv[ARG_STDOUT] = &quot;-&quot;;
      }
  
<span class="line-modified">!   if (stdout_fd != -1)</span>
      {
        _g_sprintf (args[ARG_STDERR], &quot;%d&quot;, stderr_fd);
        new_argv[ARG_STDERR] = args[ARG_STDERR];
      }
    else if (flags &amp; G_SPAWN_STDERR_TO_DEV_NULL)
<span class="line-new-header">--- 666,11 ---</span>
    else
      {
        new_argv[ARG_STDOUT] = &quot;-&quot;;
      }
  
<span class="line-modified">!   if (stderr_fd != -1)</span>
      {
        _g_sprintf (args[ARG_STDERR], &quot;%d&quot;, stderr_fd);
        new_argv[ARG_STDERR] = args[ARG_STDERR];
      }
    else if (flags &amp; G_SPAWN_STDERR_TO_DEV_NULL)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 698,23 ***</span>
  
    if (debug)
      {
        g_print (&quot;calling %s with argv:\n&quot;, helper_process);
        for (i = 0; i &lt; argc + 1 + ARG_COUNT; i++)
<span class="line-modified">!     g_print (&quot;argv[%d]: %s\n&quot;, i, (new_argv[i] ? new_argv[i] : &quot;NULL&quot;));</span>
      }
  
    if (!utf8_charv_to_wcharv (new_argv, &amp;wargv, &amp;conv_error_index, &amp;conv_error))
      {
        if (conv_error_index == ARG_WORKING_DIRECTORY)
<span class="line-modified">!     g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR,</span>
<span class="line-modified">!              _(&quot;Invalid working directory: %s&quot;),</span>
<span class="line-modified">!              conv_error-&gt;message);</span>
        else
<span class="line-modified">!     g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,</span>
<span class="line-modified">!              _(&quot;Invalid string in argument vector at %d: %s&quot;),</span>
<span class="line-modified">!              conv_error_index - ARG_PROGRAM, conv_error-&gt;message);</span>
        g_error_free (conv_error);
        g_strfreev (protected_argv);
        g_free (new_argv[0]);
        g_free (new_argv[ARG_WORKING_DIRECTORY]);
        g_free (new_argv);
<span class="line-new-header">--- 709,23 ---</span>
  
    if (debug)
      {
        g_print (&quot;calling %s with argv:\n&quot;, helper_process);
        for (i = 0; i &lt; argc + 1 + ARG_COUNT; i++)
<span class="line-modified">!   g_print (&quot;argv[%d]: %s\n&quot;, i, (new_argv[i] ? new_argv[i] : &quot;NULL&quot;));</span>
      }
  
    if (!utf8_charv_to_wcharv (new_argv, &amp;wargv, &amp;conv_error_index, &amp;conv_error))
      {
        if (conv_error_index == ARG_WORKING_DIRECTORY)
<span class="line-modified">!   g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR,</span>
<span class="line-modified">!          _(&quot;Invalid working directory: %s&quot;),</span>
<span class="line-modified">!          conv_error-&gt;message);</span>
        else
<span class="line-modified">!   g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,</span>
<span class="line-modified">!          _(&quot;Invalid string in argument vector at %d: %s&quot;),</span>
<span class="line-modified">!          conv_error_index - ARG_PROGRAM, conv_error-&gt;message);</span>
        g_error_free (conv_error);
        g_strfreev (protected_argv);
        g_free (new_argv[0]);
        g_free (new_argv[ARG_WORKING_DIRECTORY]);
        g_free (new_argv);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 724,12 ***</span>
      }
  
    if (!utf8_charv_to_wcharv (envp, &amp;wenvp, NULL, &amp;conv_error))
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!            _(&quot;Invalid string in environment: %s&quot;),</span>
<span class="line-modified">!            conv_error-&gt;message);</span>
        g_error_free (conv_error);
        g_strfreev (protected_argv);
        g_free (new_argv[0]);
        g_free (new_argv[ARG_WORKING_DIRECTORY]);
        g_free (new_argv);
<span class="line-new-header">--- 735,12 ---</span>
      }
  
    if (!utf8_charv_to_wcharv (envp, &amp;wenvp, NULL, &amp;conv_error))
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!        _(&quot;Invalid string in environment: %s&quot;),</span>
<span class="line-modified">!        conv_error-&gt;message);</span>
        g_error_free (conv_error);
        g_strfreev (protected_argv);
        g_free (new_argv[0]);
        g_free (new_argv[ARG_WORKING_DIRECTORY]);
        g_free (new_argv);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 767,12 ***</span>
  
    /* Check if gspawn-win32-helper couldn&#39;t be run */
    if (rc == -1 &amp;&amp; errsv != 0)
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!                    _(&quot;Failed to execute helper program (%s)&quot;),</span>
<span class="line-modified">!            g_strerror (errsv));</span>
        goto cleanup_and_fail;
      }
  
    if (exit_status != NULL)
      {
<span class="line-new-header">--- 778,12 ---</span>
  
    /* Check if gspawn-win32-helper couldn&#39;t be run */
    if (rc == -1 &amp;&amp; errsv != 0)
      {
        g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">!        _(&quot;Failed to execute helper program (%s)&quot;),</span>
<span class="line-modified">!        g_strerror (errsv));</span>
        goto cleanup_and_fail;
      }
  
    if (exit_status != NULL)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 787,44 ***</span>
      }
    else
      {
        /* Asynchronous case. We read the helper&#39;s report right away. */
        if (!read_helper_report (child_err_report_pipe[0], helper_report, error))
<span class="line-modified">!     goto cleanup_and_fail;</span>
  
        close_and_invalidate (&amp;child_err_report_pipe[0]);
  
        switch (helper_report[0])
      {
<span class="line-modified">!     case CHILD_NO_ERROR:</span>
<span class="line-modified">!       if (child_handle &amp;&amp; do_return_handle)</span>
<span class="line-modified">!         {</span>
<span class="line-removed">-           /* rc is our HANDLE for gspawn-win32-helper. It has</span>
<span class="line-removed">-            * told us the HANDLE of its child. Duplicate that into</span>
<span class="line-removed">-            * a HANDLE valid in this process.</span>
<span class="line-removed">-            */</span>
<span class="line-removed">-           if (!DuplicateHandle ((HANDLE) rc, (HANDLE) helper_report[1],</span>
<span class="line-removed">-                     GetCurrentProcess (), (LPHANDLE) child_handle,</span>
<span class="line-removed">-                     0, TRUE, DUPLICATE_SAME_ACCESS))</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           char *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-removed">-           g_print(&quot;%s\n&quot;, emsg);</span>
<span class="line-removed">-           *child_handle = 0;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       else if (child_handle)</span>
<span class="line-removed">-         *child_handle = 0;</span>
<span class="line-removed">-       write (helper_sync_pipe[1], &quot; &quot;, 1);</span>
<span class="line-removed">-       close_and_invalidate (&amp;helper_sync_pipe[1]);</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-       write (helper_sync_pipe[1], &quot; &quot;, 1);</span>
<span class="line-removed">-       close_and_invalidate (&amp;helper_sync_pipe[1]);</span>
<span class="line-removed">-       set_child_error (helper_report, working_directory, error);</span>
<span class="line-removed">-       goto cleanup_and_fail;</span>
      }
      }
  
    /* Success against all odds! return the information */
  
    if (rc != -1)
<span class="line-new-header">--- 798,44 ---</span>
      }
    else
      {
        /* Asynchronous case. We read the helper&#39;s report right away. */
        if (!read_helper_report (child_err_report_pipe[0], helper_report, error))
<span class="line-modified">!   goto cleanup_and_fail;</span>
  
        close_and_invalidate (&amp;child_err_report_pipe[0]);
  
        switch (helper_report[0])
<span class="line-added">+   {</span>
<span class="line-added">+   case CHILD_NO_ERROR:</span>
<span class="line-added">+     if (child_handle &amp;&amp; do_return_handle)</span>
<span class="line-added">+       {</span>
<span class="line-added">+         /* rc is our HANDLE for gspawn-win32-helper. It has</span>
<span class="line-added">+          * told us the HANDLE of its child. Duplicate that into</span>
<span class="line-added">+          * a HANDLE valid in this process.</span>
<span class="line-added">+          */</span>
<span class="line-added">+         if (!DuplicateHandle ((HANDLE) rc, (HANDLE) helper_report[1],</span>
<span class="line-added">+             GetCurrentProcess (), (LPHANDLE) child_handle,</span>
<span class="line-added">+             0, TRUE, DUPLICATE_SAME_ACCESS))</span>
      {
<span class="line-modified">!       char *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-modified">!       g_print(&quot;%s\n&quot;, emsg);</span>
<span class="line-modified">!       *child_handle = 0;</span>
      }
<span class="line-added">+       }</span>
<span class="line-added">+     else if (child_handle)</span>
<span class="line-added">+       *child_handle = 0;</span>
<span class="line-added">+     write (helper_sync_pipe[1], &quot; &quot;, 1);</span>
<span class="line-added">+     close_and_invalidate (&amp;helper_sync_pipe[1]);</span>
<span class="line-added">+     break;</span>
<span class="line-added">+ </span>
<span class="line-added">+   default:</span>
<span class="line-added">+     write (helper_sync_pipe[1], &quot; &quot;, 1);</span>
<span class="line-added">+     close_and_invalidate (&amp;helper_sync_pipe[1]);</span>
<span class="line-added">+     set_child_error (helper_report, working_directory, error);</span>
<span class="line-added">+     goto cleanup_and_fail;</span>
<span class="line-added">+   }</span>
      }
  
    /* Success against all odds! return the information */
  
    if (rc != -1)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 848,22 ***</span>
    return FALSE;
  }
  
  static gboolean
  do_spawn_with_pipes (gint                 *exit_status,
<span class="line-modified">!              gboolean          do_return_handle,</span>
<span class="line-modified">!              const gchar          *working_directory,</span>
<span class="line-modified">!              gchar               **argv,</span>
<span class="line-modified">!              char                **envp,</span>
<span class="line-modified">!              GSpawnFlags           flags,</span>
<span class="line-modified">!              GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!              GPid                 *child_handle,</span>
<span class="line-modified">!              gint                 *standard_input,</span>
<span class="line-modified">!              gint                 *standard_output,</span>
<span class="line-modified">!              gint                 *standard_error,</span>
<span class="line-modified">!              gint         *err_report,</span>
<span class="line-modified">!              GError              **error)</span>
  {
    int stdin_pipe[2] = { -1, -1 };
    int stdout_pipe[2] = { -1, -1 };
    int stderr_pipe[2] = { -1, -1 };
  
<span class="line-new-header">--- 859,22 ---</span>
    return FALSE;
  }
  
  static gboolean
  do_spawn_with_pipes (gint                 *exit_status,
<span class="line-modified">!          gboolean      do_return_handle,</span>
<span class="line-modified">!          const gchar          *working_directory,</span>
<span class="line-modified">!          gchar               **argv,</span>
<span class="line-modified">!          char                **envp,</span>
<span class="line-modified">!          GSpawnFlags           flags,</span>
<span class="line-modified">!          GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!          GPid                 *child_handle,</span>
<span class="line-modified">!          gint                 *standard_input,</span>
<span class="line-modified">!          gint                 *standard_output,</span>
<span class="line-modified">!          gint                 *standard_error,</span>
<span class="line-modified">!          gint     *err_report,</span>
<span class="line-modified">!          GError              **error)</span>
  {
    int stdin_pipe[2] = { -1, -1 };
    int stdout_pipe[2] = { -1, -1 };
    int stderr_pipe[2] = { -1, -1 };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 875,22 ***</span>
  
    if (standard_error &amp;&amp; !make_pipe (stderr_pipe, error))
      goto cleanup_and_fail;
  
    if (!do_spawn_with_fds (exit_status,
<span class="line-modified">!               do_return_handle,</span>
<span class="line-modified">!               working_directory,</span>
<span class="line-modified">!               argv,</span>
<span class="line-modified">!               envp,</span>
<span class="line-modified">!               flags,</span>
<span class="line-modified">!               child_setup,</span>
<span class="line-modified">!               child_handle,</span>
<span class="line-modified">!               stdin_pipe[0],</span>
<span class="line-modified">!               stdout_pipe[1],</span>
<span class="line-modified">!               stderr_pipe[1],</span>
<span class="line-modified">!               err_report,</span>
<span class="line-modified">!               error))</span>
      goto cleanup_and_fail;
  
    /* Close the other process&#39;s ends of the pipes in this process,
     * otherwise the reader will never get EOF.
     */
<span class="line-new-header">--- 886,22 ---</span>
  
    if (standard_error &amp;&amp; !make_pipe (stderr_pipe, error))
      goto cleanup_and_fail;
  
    if (!do_spawn_with_fds (exit_status,
<span class="line-modified">!         do_return_handle,</span>
<span class="line-modified">!         working_directory,</span>
<span class="line-modified">!         argv,</span>
<span class="line-modified">!         envp,</span>
<span class="line-modified">!         flags,</span>
<span class="line-modified">!         child_setup,</span>
<span class="line-modified">!         child_handle,</span>
<span class="line-modified">!         stdin_pipe[0],</span>
<span class="line-modified">!         stdout_pipe[1],</span>
<span class="line-modified">!         stderr_pipe[1],</span>
<span class="line-modified">!         err_report,</span>
<span class="line-modified">!         error))</span>
      goto cleanup_and_fail;
  
    /* Close the other process&#39;s ends of the pipes in this process,
     * otherwise the reader will never get EOF.
     */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 925,19 ***</span>
    return FALSE;
  }
  
  gboolean
  g_spawn_sync (const gchar          *working_directory,
<span class="line-modified">!            gchar               **argv,</span>
<span class="line-modified">!            gchar               **envp,</span>
<span class="line-modified">!            GSpawnFlags           flags,</span>
<span class="line-modified">!            GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!            gpointer              user_data,</span>
<span class="line-modified">!            gchar               **standard_output,</span>
<span class="line-modified">!            gchar               **standard_error,</span>
<span class="line-modified">!            gint                 *exit_status,</span>
<span class="line-modified">!            GError              **error)</span>
  {
    gint outpipe = -1;
    gint errpipe = -1;
    gint reportpipe = -1;
    GIOChannel *outchannel = NULL;
<span class="line-new-header">--- 936,19 ---</span>
    return FALSE;
  }
  
  gboolean
  g_spawn_sync (const gchar          *working_directory,
<span class="line-modified">!               gchar               **argv,</span>
<span class="line-modified">!               gchar               **envp,</span>
<span class="line-modified">!               GSpawnFlags           flags,</span>
<span class="line-modified">!               GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!               gpointer              user_data,</span>
<span class="line-modified">!               gchar               **standard_output,</span>
<span class="line-modified">!               gchar               **standard_error,</span>
<span class="line-modified">!               gint                 *exit_status,</span>
<span class="line-modified">!               GError              **error)</span>
  {
    gint outpipe = -1;
    gint errpipe = -1;
    gint reportpipe = -1;
    GIOChannel *outchannel = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 968,22 ***</span>
  
    if (standard_error)
      *standard_error = NULL;
  
    if (!do_spawn_with_pipes (&amp;status,
<span class="line-modified">!                 FALSE,</span>
<span class="line-modified">!                 working_directory,</span>
<span class="line-modified">!                 argv,</span>
<span class="line-modified">!                 envp,</span>
<span class="line-modified">!                 flags,</span>
<span class="line-modified">!                 child_setup,</span>
<span class="line-modified">!                 NULL,</span>
<span class="line-modified">!                 NULL,</span>
<span class="line-modified">!                 standard_output ? &amp;outpipe : NULL,</span>
<span class="line-modified">!                 standard_error ? &amp;errpipe : NULL,</span>
<span class="line-modified">!                 &amp;reportpipe,</span>
<span class="line-modified">!                 error))</span>
      return FALSE;
  
    /* Read data from child. */
  
    failed = FALSE;
<span class="line-new-header">--- 979,22 ---</span>
  
    if (standard_error)
      *standard_error = NULL;
  
    if (!do_spawn_with_pipes (&amp;status,
<span class="line-modified">!           FALSE,</span>
<span class="line-modified">!           working_directory,</span>
<span class="line-modified">!           argv,</span>
<span class="line-modified">!           envp,</span>
<span class="line-modified">!           flags,</span>
<span class="line-modified">!           child_setup,</span>
<span class="line-modified">!           NULL,</span>
<span class="line-modified">!           NULL,</span>
<span class="line-modified">!           standard_output ? &amp;outpipe : NULL,</span>
<span class="line-modified">!           standard_error ? &amp;errpipe : NULL,</span>
<span class="line-modified">!           &amp;reportpipe,</span>
<span class="line-modified">!           error))</span>
      return FALSE;
  
    /* Read data from child. */
  
    failed = FALSE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 993,49 ***</span>
        outstr = g_string_new (NULL);
        outchannel = g_io_channel_win32_new_fd (outpipe);
        g_io_channel_set_encoding (outchannel, NULL, NULL);
        g_io_channel_set_buffered (outchannel, FALSE);
        g_io_channel_win32_make_pollfd (outchannel,
<span class="line-modified">!                       G_IO_IN | G_IO_ERR | G_IO_HUP,</span>
<span class="line-modified">!                       &amp;outfd);</span>
        if (debug)
<span class="line-modified">!     g_print (&quot;outfd=%p\n&quot;, (HANDLE) outfd.fd);</span>
      }
  
    if (errpipe &gt;= 0)
      {
        errstr = g_string_new (NULL);
        errchannel = g_io_channel_win32_new_fd (errpipe);
        g_io_channel_set_encoding (errchannel, NULL, NULL);
        g_io_channel_set_buffered (errchannel, FALSE);
        g_io_channel_win32_make_pollfd (errchannel,
<span class="line-modified">!                       G_IO_IN | G_IO_ERR | G_IO_HUP,</span>
<span class="line-modified">!                       &amp;errfd);</span>
        if (debug)
<span class="line-modified">!     g_print (&quot;errfd=%p\n&quot;, (HANDLE) errfd.fd);</span>
      }
  
    /* Read data until we get EOF on all pipes. */
    while (!failed &amp;&amp; (outpipe &gt;= 0 || errpipe &gt;= 0))
      {
        nfds = 0;
        if (outpipe &gt;= 0)
<span class="line-modified">!     {</span>
<span class="line-modified">!       fds[nfds] = outfd;</span>
<span class="line-modified">!       outindex = nfds;</span>
<span class="line-modified">!       nfds++;</span>
<span class="line-modified">!     }</span>
        if (errpipe &gt;= 0)
<span class="line-modified">!     {</span>
<span class="line-modified">!       fds[nfds] = errfd;</span>
<span class="line-modified">!       errindex = nfds;</span>
<span class="line-modified">!       nfds++;</span>
<span class="line-modified">!     }</span>
  
        if (debug)
<span class="line-modified">!     g_print (&quot;g_spawn_sync: calling g_io_channel_win32_poll, nfds=%d\n&quot;,</span>
<span class="line-modified">!          nfds);</span>
  
        ret = g_io_channel_win32_poll (fds, nfds, -1);
  
        if (ret &lt; 0)
          {
<span class="line-new-header">--- 1004,49 ---</span>
        outstr = g_string_new (NULL);
        outchannel = g_io_channel_win32_new_fd (outpipe);
        g_io_channel_set_encoding (outchannel, NULL, NULL);
        g_io_channel_set_buffered (outchannel, FALSE);
        g_io_channel_win32_make_pollfd (outchannel,
<span class="line-modified">!               G_IO_IN | G_IO_ERR | G_IO_HUP,</span>
<span class="line-modified">!               &amp;outfd);</span>
        if (debug)
<span class="line-modified">!   g_print (&quot;outfd=%p\n&quot;, (HANDLE) outfd.fd);</span>
      }
  
    if (errpipe &gt;= 0)
      {
        errstr = g_string_new (NULL);
        errchannel = g_io_channel_win32_new_fd (errpipe);
        g_io_channel_set_encoding (errchannel, NULL, NULL);
        g_io_channel_set_buffered (errchannel, FALSE);
        g_io_channel_win32_make_pollfd (errchannel,
<span class="line-modified">!               G_IO_IN | G_IO_ERR | G_IO_HUP,</span>
<span class="line-modified">!               &amp;errfd);</span>
        if (debug)
<span class="line-modified">!   g_print (&quot;errfd=%p\n&quot;, (HANDLE) errfd.fd);</span>
      }
  
    /* Read data until we get EOF on all pipes. */
    while (!failed &amp;&amp; (outpipe &gt;= 0 || errpipe &gt;= 0))
      {
        nfds = 0;
        if (outpipe &gt;= 0)
<span class="line-modified">!   {</span>
<span class="line-modified">!     fds[nfds] = outfd;</span>
<span class="line-modified">!     outindex = nfds;</span>
<span class="line-modified">!     nfds++;</span>
<span class="line-modified">!   }</span>
        if (errpipe &gt;= 0)
<span class="line-modified">!   {</span>
<span class="line-modified">!     fds[nfds] = errfd;</span>
<span class="line-modified">!     errindex = nfds;</span>
<span class="line-modified">!     nfds++;</span>
<span class="line-modified">!   }</span>
  
        if (debug)
<span class="line-modified">!   g_print (&quot;g_spawn_sync: calling g_io_channel_win32_poll, nfds=%d\n&quot;,</span>
<span class="line-modified">!      nfds);</span>
  
        ret = g_io_channel_win32_poll (fds, nfds, -1);
  
        if (ret &lt; 0)
          {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1050,24 ***</span>
        if (outpipe &gt;= 0 &amp;&amp; (fds[outindex].revents &amp; G_IO_IN))
          {
            switch (read_data (outstr, outchannel, error))
              {
              case READ_FAILED:
<span class="line-modified">!           if (debug)</span>
<span class="line-modified">!         g_print (&quot;g_spawn_sync: outchannel: READ_FAILED\n&quot;);</span>
                failed = TRUE;
                break;
              case READ_EOF:
<span class="line-modified">!           if (debug)</span>
<span class="line-modified">!         g_print (&quot;g_spawn_sync: outchannel: READ_EOF\n&quot;);</span>
                g_io_channel_unref (outchannel);
<span class="line-modified">!           outchannel = NULL;</span>
                close_and_invalidate (&amp;outpipe);
                break;
              default:
<span class="line-modified">!           if (debug)</span>
<span class="line-modified">!         g_print (&quot;g_spawn_sync: outchannel: OK\n&quot;);</span>
                break;
              }
  
            if (failed)
              break;
<span class="line-new-header">--- 1061,24 ---</span>
        if (outpipe &gt;= 0 &amp;&amp; (fds[outindex].revents &amp; G_IO_IN))
          {
            switch (read_data (outstr, outchannel, error))
              {
              case READ_FAILED:
<span class="line-modified">!         if (debug)</span>
<span class="line-modified">!     g_print (&quot;g_spawn_sync: outchannel: READ_FAILED\n&quot;);</span>
                failed = TRUE;
                break;
              case READ_EOF:
<span class="line-modified">!         if (debug)</span>
<span class="line-modified">!     g_print (&quot;g_spawn_sync: outchannel: READ_EOF\n&quot;);</span>
                g_io_channel_unref (outchannel);
<span class="line-modified">!         outchannel = NULL;</span>
                close_and_invalidate (&amp;outpipe);
                break;
              default:
<span class="line-modified">!         if (debug)</span>
<span class="line-modified">!     g_print (&quot;g_spawn_sync: outchannel: OK\n&quot;);</span>
                break;
              }
  
            if (failed)
              break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1076,24 ***</span>
        if (errpipe &gt;= 0 &amp;&amp; (fds[errindex].revents &amp; G_IO_IN))
          {
            switch (read_data (errstr, errchannel, error))
              {
              case READ_FAILED:
<span class="line-modified">!           if (debug)</span>
<span class="line-modified">!         g_print (&quot;g_spawn_sync: errchannel: READ_FAILED\n&quot;);</span>
                failed = TRUE;
                break;
              case READ_EOF:
<span class="line-modified">!           if (debug)</span>
<span class="line-modified">!         g_print (&quot;g_spawn_sync: errchannel: READ_EOF\n&quot;);</span>
<span class="line-modified">!           g_io_channel_unref (errchannel);</span>
<span class="line-modified">!           errchannel = NULL;</span>
                close_and_invalidate (&amp;errpipe);
                break;
              default:
<span class="line-modified">!           if (debug)</span>
<span class="line-modified">!         g_print (&quot;g_spawn_sync: errchannel: OK\n&quot;);</span>
                break;
              }
  
            if (failed)
              break;
<span class="line-new-header">--- 1087,24 ---</span>
        if (errpipe &gt;= 0 &amp;&amp; (fds[errindex].revents &amp; G_IO_IN))
          {
            switch (read_data (errstr, errchannel, error))
              {
              case READ_FAILED:
<span class="line-modified">!         if (debug)</span>
<span class="line-modified">!     g_print (&quot;g_spawn_sync: errchannel: READ_FAILED\n&quot;);</span>
                failed = TRUE;
                break;
              case READ_EOF:
<span class="line-modified">!         if (debug)</span>
<span class="line-modified">!     g_print (&quot;g_spawn_sync: errchannel: READ_EOF\n&quot;);</span>
<span class="line-modified">!         g_io_channel_unref (errchannel);</span>
<span class="line-modified">!         errchannel = NULL;</span>
                close_and_invalidate (&amp;errpipe);
                break;
              default:
<span class="line-modified">!         if (debug)</span>
<span class="line-modified">!     g_print (&quot;g_spawn_sync: errchannel: OK\n&quot;);</span>
                break;
              }
  
            if (failed)
              break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1114,25 ***</span>
         * grandchild has finished.
         */
        gintptr helper_report[2];
  
        if (!read_helper_report (reportpipe, helper_report, error))
<span class="line-modified">!     failed = TRUE;</span>
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       switch (helper_report[0])</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!         case CHILD_NO_ERROR:</span>
<span class="line-modified">!           if (exit_status)</span>
<span class="line-modified">!         *exit_status = helper_report[1];</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!         default:</span>
<span class="line-modified">!           set_child_error (helper_report, working_directory, error);</span>
<span class="line-modified">!           failed = TRUE;</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
        close_and_invalidate (&amp;reportpipe);
      }
  
  
    /* These should only be open still if we had an error.  */
<span class="line-new-header">--- 1125,25 ---</span>
         * grandchild has finished.
         */
        gintptr helper_report[2];
  
        if (!read_helper_report (reportpipe, helper_report, error))
<span class="line-modified">!   failed = TRUE;</span>
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     switch (helper_report[0])</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!       case CHILD_NO_ERROR:</span>
<span class="line-modified">!         if (exit_status)</span>
<span class="line-modified">!     *exit_status = helper_report[1];</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       default:</span>
<span class="line-modified">!         set_child_error (helper_report, working_directory, error);</span>
<span class="line-modified">!         failed = TRUE;</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!   }</span>
        close_and_invalidate (&amp;reportpipe);
      }
  
  
    /* These should only be open still if we had an error.  */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1167,20 ***</span>
      }
  }
  
  gboolean
  g_spawn_async_with_pipes (const gchar          *working_directory,
<span class="line-modified">!                    gchar               **argv,</span>
<span class="line-modified">!                    gchar               **envp,</span>
<span class="line-modified">!                    GSpawnFlags           flags,</span>
<span class="line-modified">!                    GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!                    gpointer              user_data,</span>
<span class="line-modified">!                    GPid                 *child_handle,</span>
<span class="line-modified">!                    gint                 *standard_input,</span>
<span class="line-modified">!                    gint                 *standard_output,</span>
<span class="line-modified">!                    gint                 *standard_error,</span>
<span class="line-modified">!                    GError              **error)</span>
  {
    g_return_val_if_fail (argv != NULL, FALSE);
    g_return_val_if_fail (standard_output == NULL ||
                          !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
    g_return_val_if_fail (standard_error == NULL ||
<span class="line-new-header">--- 1178,20 ---</span>
      }
  }
  
  gboolean
  g_spawn_async_with_pipes (const gchar          *working_directory,
<span class="line-modified">!                           gchar               **argv,</span>
<span class="line-modified">!                           gchar               **envp,</span>
<span class="line-modified">!                           GSpawnFlags           flags,</span>
<span class="line-modified">!                           GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!                           gpointer              user_data,</span>
<span class="line-modified">!                           GPid                 *child_handle,</span>
<span class="line-modified">!                           gint                 *standard_input,</span>
<span class="line-modified">!                           gint                 *standard_output,</span>
<span class="line-modified">!                           gint                 *standard_error,</span>
<span class="line-modified">!                           GError              **error)</span>
  {
    g_return_val_if_fail (argv != NULL, FALSE);
    g_return_val_if_fail (standard_output == NULL ||
                          !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
    g_return_val_if_fail (standard_error == NULL ||
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1188,22 ***</span>
    /* can&#39;t inherit stdin if we have an input pipe. */
    g_return_val_if_fail (standard_input == NULL ||
                          !(flags &amp; G_SPAWN_CHILD_INHERITS_STDIN), FALSE);
  
    return do_spawn_with_pipes (NULL,
<span class="line-modified">!                   (flags &amp; G_SPAWN_DO_NOT_REAP_CHILD),</span>
<span class="line-modified">!                   working_directory,</span>
<span class="line-modified">!                   argv,</span>
<span class="line-modified">!                   envp,</span>
<span class="line-modified">!                   flags,</span>
<span class="line-modified">!                   child_setup,</span>
<span class="line-modified">!                   child_handle,</span>
<span class="line-modified">!                   standard_input,</span>
<span class="line-modified">!                   standard_output,</span>
<span class="line-modified">!                   standard_error,</span>
<span class="line-modified">!                   NULL,</span>
<span class="line-modified">!                   error);</span>
  }
  
  gboolean
  g_spawn_async_with_fds (const gchar          *working_directory,
                          gchar               **argv,
<span class="line-new-header">--- 1199,22 ---</span>
    /* can&#39;t inherit stdin if we have an input pipe. */
    g_return_val_if_fail (standard_input == NULL ||
                          !(flags &amp; G_SPAWN_CHILD_INHERITS_STDIN), FALSE);
  
    return do_spawn_with_pipes (NULL,
<span class="line-modified">!             (flags &amp; G_SPAWN_DO_NOT_REAP_CHILD),</span>
<span class="line-modified">!             working_directory,</span>
<span class="line-modified">!             argv,</span>
<span class="line-modified">!             envp,</span>
<span class="line-modified">!             flags,</span>
<span class="line-modified">!             child_setup,</span>
<span class="line-modified">!             child_handle,</span>
<span class="line-modified">!             standard_input,</span>
<span class="line-modified">!             standard_output,</span>
<span class="line-modified">!             standard_error,</span>
<span class="line-modified">!             NULL,</span>
<span class="line-modified">!             error);</span>
  }
  
  gboolean
  g_spawn_async_with_fds (const gchar          *working_directory,
                          gchar               **argv,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1225,30 ***</span>
    /* can&#39;t inherit stdin if we have an input pipe. */
    g_return_val_if_fail (stdin_fd == -1 ||
                          !(flags &amp; G_SPAWN_CHILD_INHERITS_STDIN), FALSE);
  
    return do_spawn_with_fds (NULL,
<span class="line-modified">!                 (flags &amp; G_SPAWN_DO_NOT_REAP_CHILD),</span>
<span class="line-modified">!                 working_directory,</span>
<span class="line-modified">!                 argv,</span>
<span class="line-modified">!                 envp,</span>
<span class="line-modified">!                 flags,</span>
<span class="line-modified">!                 child_setup,</span>
<span class="line-modified">!                 child_handle,</span>
<span class="line-modified">!                 stdin_fd,</span>
<span class="line-modified">!                 stdout_fd,</span>
<span class="line-modified">!                 stderr_fd,</span>
<span class="line-modified">!                 NULL,</span>
<span class="line-modified">!                 error);</span>
  }
  
  gboolean
  g_spawn_command_line_sync (const gchar  *command_line,
<span class="line-modified">!                 gchar       **standard_output,</span>
<span class="line-modified">!                 gchar       **standard_error,</span>
<span class="line-modified">!                 gint         *exit_status,</span>
<span class="line-modified">!                 GError      **error)</span>
  {
    gboolean retval;
    gchar **argv = 0;
  
    g_return_val_if_fail (command_line != NULL, FALSE);
<span class="line-new-header">--- 1236,30 ---</span>
    /* can&#39;t inherit stdin if we have an input pipe. */
    g_return_val_if_fail (stdin_fd == -1 ||
                          !(flags &amp; G_SPAWN_CHILD_INHERITS_STDIN), FALSE);
  
    return do_spawn_with_fds (NULL,
<span class="line-modified">!           (flags &amp; G_SPAWN_DO_NOT_REAP_CHILD),</span>
<span class="line-modified">!           working_directory,</span>
<span class="line-modified">!           argv,</span>
<span class="line-modified">!           envp,</span>
<span class="line-modified">!           flags,</span>
<span class="line-modified">!           child_setup,</span>
<span class="line-modified">!           child_handle,</span>
<span class="line-modified">!           stdin_fd,</span>
<span class="line-modified">!           stdout_fd,</span>
<span class="line-modified">!           stderr_fd,</span>
<span class="line-modified">!           NULL,</span>
<span class="line-modified">!           error);</span>
  }
  
  gboolean
  g_spawn_command_line_sync (const gchar  *command_line,
<span class="line-modified">!                            gchar       **standard_output,</span>
<span class="line-modified">!                            gchar       **standard_error,</span>
<span class="line-modified">!                            gint         *exit_status,</span>
<span class="line-modified">!                            GError      **error)</span>
  {
    gboolean retval;
    gchar **argv = 0;
  
    g_return_val_if_fail (command_line != NULL, FALSE);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1257,27 ***</span>
                             NULL, &amp;argv,
                             error))
      return FALSE;
  
    retval = g_spawn_sync (NULL,
<span class="line-modified">!                   argv,</span>
<span class="line-modified">!                   NULL,</span>
<span class="line-modified">!                   G_SPAWN_SEARCH_PATH,</span>
<span class="line-modified">!                   NULL,</span>
<span class="line-modified">!                   NULL,</span>
<span class="line-modified">!                   standard_output,</span>
<span class="line-modified">!                   standard_error,</span>
<span class="line-modified">!                   exit_status,</span>
<span class="line-modified">!                   error);</span>
    g_strfreev (argv);
  
    return retval;
  }
  
  gboolean
  g_spawn_command_line_async (const gchar *command_line,
<span class="line-modified">!                  GError     **error)</span>
  {
    gboolean retval;
    gchar **argv = 0;
  
    g_return_val_if_fail (command_line != NULL, FALSE);
<span class="line-new-header">--- 1268,27 ---</span>
                             NULL, &amp;argv,
                             error))
      return FALSE;
  
    retval = g_spawn_sync (NULL,
<span class="line-modified">!                          argv,</span>
<span class="line-modified">!                          NULL,</span>
<span class="line-modified">!                          G_SPAWN_SEARCH_PATH,</span>
<span class="line-modified">!                          NULL,</span>
<span class="line-modified">!                          NULL,</span>
<span class="line-modified">!                          standard_output,</span>
<span class="line-modified">!                          standard_error,</span>
<span class="line-modified">!                          exit_status,</span>
<span class="line-modified">!                          error);</span>
    g_strfreev (argv);
  
    return retval;
  }
  
  gboolean
  g_spawn_command_line_async (const gchar *command_line,
<span class="line-modified">!                             GError     **error)</span>
  {
    gboolean retval;
    gchar **argv = 0;
  
    g_return_val_if_fail (command_line != NULL, FALSE);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1286,17 ***</span>
                             NULL, &amp;argv,
                             error))
      return FALSE;
  
    retval = g_spawn_async (NULL,
<span class="line-modified">!                    argv,</span>
<span class="line-modified">!                    NULL,</span>
<span class="line-modified">!                    G_SPAWN_SEARCH_PATH,</span>
<span class="line-modified">!                    NULL,</span>
<span class="line-modified">!                    NULL,</span>
<span class="line-modified">!                    NULL,</span>
<span class="line-modified">!                    error);</span>
    g_strfreev (argv);
  
    return retval;
  }
  
<span class="line-new-header">--- 1297,17 ---</span>
                             NULL, &amp;argv,
                             error))
      return FALSE;
  
    retval = g_spawn_async (NULL,
<span class="line-modified">!                           argv,</span>
<span class="line-modified">!                           NULL,</span>
<span class="line-modified">!                           G_SPAWN_SEARCH_PATH,</span>
<span class="line-modified">!                           NULL,</span>
<span class="line-modified">!                           NULL,</span>
<span class="line-modified">!                           NULL,</span>
<span class="line-modified">!                           error);</span>
    g_strfreev (argv);
  
    return retval;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1306,19 ***</span>
      CloseHandle (pid);
  }
  
  gboolean
  g_spawn_check_exit_status (gint      exit_status,
<span class="line-modified">!                GError  **error)</span>
  {
    gboolean ret = FALSE;
  
    if (exit_status != 0)
      {
        g_set_error (error, G_SPAWN_EXIT_ERROR, exit_status,
<span class="line-modified">!            _(&quot;Child process exited with code %ld&quot;),</span>
<span class="line-modified">!            (long) exit_status);</span>
        goto out;
      }
  
    ret = TRUE;
   out:
<span class="line-new-header">--- 1317,19 ---</span>
      CloseHandle (pid);
  }
  
  gboolean
  g_spawn_check_exit_status (gint      exit_status,
<span class="line-modified">!          GError  **error)</span>
  {
    gboolean ret = FALSE;
  
    if (exit_status != 0)
      {
        g_set_error (error, G_SPAWN_EXIT_ERROR, exit_status,
<span class="line-modified">!        _(&quot;Child process exited with code %ld&quot;),</span>
<span class="line-modified">!        (long) exit_status);</span>
        goto out;
      }
  
    ret = TRUE;
   out:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1367,95 ***</span>
  _GLIB_EXTERN gboolean g_spawn_command_line_async_utf8 (const gchar           *command_line,
                                                         GError               **error);
  
  gboolean
  g_spawn_async_utf8 (const gchar          *working_directory,
<span class="line-modified">!                           gchar               **argv,</span>
<span class="line-modified">!                           gchar               **envp,</span>
<span class="line-modified">!                           GSpawnFlags           flags,</span>
<span class="line-modified">!                           GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!                           gpointer              user_data,</span>
<span class="line-modified">!                           GPid                 *child_handle,</span>
<span class="line-modified">!                           GError              **error)</span>
  {
    return g_spawn_async (working_directory,
                          argv,
                          envp,
                          flags,
                          child_setup,
                          user_data,
<span class="line-modified">!                       child_handle,</span>
<span class="line-modified">!                       error);</span>
  }
  
  gboolean
  g_spawn_async_with_pipes_utf8 (const gchar          *working_directory,
<span class="line-modified">!            gchar               **argv,</span>
<span class="line-modified">!            gchar               **envp,</span>
<span class="line-modified">!            GSpawnFlags           flags,</span>
<span class="line-modified">!            GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!            gpointer              user_data,</span>
<span class="line-modified">!            GPid                 *child_handle,</span>
                                 gint                 *standard_input,
                                 gint                 *standard_output,
                                 gint                 *standard_error,
<span class="line-modified">!            GError              **error)</span>
  {
    return g_spawn_async_with_pipes (working_directory,
                                     argv,
                                     envp,
<span class="line-modified">!                    flags,</span>
<span class="line-modified">!                    child_setup,</span>
<span class="line-modified">!                    user_data,</span>
<span class="line-modified">!                    child_handle,</span>
                                     standard_input,
                                     standard_output,
                                     standard_error,
<span class="line-modified">!                    error);</span>
  }
  
  gboolean
  g_spawn_sync_utf8 (const gchar          *working_directory,
<span class="line-modified">!           gchar               **argv,</span>
<span class="line-modified">!           gchar               **envp,</span>
<span class="line-modified">!           GSpawnFlags           flags,</span>
<span class="line-modified">!           GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!           gpointer              user_data,</span>
<span class="line-modified">!           gchar               **standard_output,</span>
<span class="line-modified">!           gchar               **standard_error,</span>
<span class="line-modified">!           gint                 *exit_status,</span>
<span class="line-modified">!           GError              **error)</span>
  {
    return g_spawn_sync (working_directory,
                         argv,
                         envp,
                         flags,
                         child_setup,
                         user_data,
                         standard_output,
                         standard_error,
                         exit_status,
<span class="line-modified">!                   error);</span>
  }
  
  gboolean
  g_spawn_command_line_sync_utf8 (const gchar  *command_line,
<span class="line-modified">!                gchar       **standard_output,</span>
<span class="line-modified">!                gchar       **standard_error,</span>
<span class="line-modified">!                gint         *exit_status,</span>
<span class="line-modified">!                GError      **error)</span>
  {
    return g_spawn_command_line_sync (command_line,
<span class="line-modified">!                          standard_output,</span>
<span class="line-modified">!                          standard_error,</span>
<span class="line-modified">!                          exit_status,</span>
<span class="line-modified">!                          error);</span>
  }
  
  gboolean
  g_spawn_command_line_async_utf8 (const gchar *command_line,
<span class="line-modified">!                 GError     **error)</span>
  {
    return g_spawn_command_line_async (command_line, error);
  }
  
  #endif /* G_OS_WIN32 */
<span class="line-new-header">--- 1378,95 ---</span>
  _GLIB_EXTERN gboolean g_spawn_command_line_async_utf8 (const gchar           *command_line,
                                                         GError               **error);
  
  gboolean
  g_spawn_async_utf8 (const gchar          *working_directory,
<span class="line-modified">!                     gchar               **argv,</span>
<span class="line-modified">!                     gchar               **envp,</span>
<span class="line-modified">!                     GSpawnFlags           flags,</span>
<span class="line-modified">!                     GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!                     gpointer              user_data,</span>
<span class="line-modified">!                     GPid                 *child_handle,</span>
<span class="line-modified">!                     GError              **error)</span>
  {
    return g_spawn_async (working_directory,
                          argv,
                          envp,
                          flags,
                          child_setup,
                          user_data,
<span class="line-modified">!                         child_handle,</span>
<span class="line-modified">!                         error);</span>
  }
  
  gboolean
  g_spawn_async_with_pipes_utf8 (const gchar          *working_directory,
<span class="line-modified">!                                gchar               **argv,</span>
<span class="line-modified">!                                gchar               **envp,</span>
<span class="line-modified">!                                GSpawnFlags           flags,</span>
<span class="line-modified">!                                GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!                                gpointer              user_data,</span>
<span class="line-modified">!                                GPid                 *child_handle,</span>
                                 gint                 *standard_input,
                                 gint                 *standard_output,
                                 gint                 *standard_error,
<span class="line-modified">!                                GError              **error)</span>
  {
    return g_spawn_async_with_pipes (working_directory,
                                     argv,
                                     envp,
<span class="line-modified">!                                    flags,</span>
<span class="line-modified">!                                    child_setup,</span>
<span class="line-modified">!                                    user_data,</span>
<span class="line-modified">!                                    child_handle,</span>
                                     standard_input,
                                     standard_output,
                                     standard_error,
<span class="line-modified">!                                    error);</span>
  }
  
  gboolean
  g_spawn_sync_utf8 (const gchar          *working_directory,
<span class="line-modified">!                    gchar               **argv,</span>
<span class="line-modified">!                    gchar               **envp,</span>
<span class="line-modified">!                    GSpawnFlags           flags,</span>
<span class="line-modified">!                    GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">!                    gpointer              user_data,</span>
<span class="line-modified">!                    gchar               **standard_output,</span>
<span class="line-modified">!                    gchar               **standard_error,</span>
<span class="line-modified">!                    gint                 *exit_status,</span>
<span class="line-modified">!                    GError              **error)</span>
  {
    return g_spawn_sync (working_directory,
                         argv,
                         envp,
                         flags,
                         child_setup,
                         user_data,
                         standard_output,
                         standard_error,
                         exit_status,
<span class="line-modified">!                        error);</span>
  }
  
  gboolean
  g_spawn_command_line_sync_utf8 (const gchar  *command_line,
<span class="line-modified">!                                 gchar       **standard_output,</span>
<span class="line-modified">!                                 gchar       **standard_error,</span>
<span class="line-modified">!                                 gint         *exit_status,</span>
<span class="line-modified">!                                 GError      **error)</span>
  {
    return g_spawn_command_line_sync (command_line,
<span class="line-modified">!                                     standard_output,</span>
<span class="line-modified">!                                     standard_error,</span>
<span class="line-modified">!                                     exit_status,</span>
<span class="line-modified">!                                     error);</span>
  }
  
  gboolean
  g_spawn_command_line_async_utf8 (const gchar *command_line,
<span class="line-modified">!                                  GError     **error)</span>
  {
    return g_spawn_command_line_async (command_line, error);
  }
  
  #endif /* G_OS_WIN32 */
</pre>
<center><a href="gspawn-win32-helper.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gspawn.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>