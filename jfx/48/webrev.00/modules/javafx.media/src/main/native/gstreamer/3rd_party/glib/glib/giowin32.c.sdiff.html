<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/giowin32.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="giounix.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gkeyfile.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/giowin32.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  74 #include &lt;windows.h&gt;
  75 #include &lt;conio.h&gt;
  76 #include &lt;fcntl.h&gt;
  77 #include &lt;io.h&gt;
  78 #include &lt;process.h&gt;
  79 #include &lt;errno.h&gt;
  80 #include &lt;sys/stat.h&gt;
  81 
  82 #include &quot;gstdio.h&quot;
  83 #include &quot;glibintl.h&quot;
  84 
  85 
  86 typedef struct _GIOWin32Channel GIOWin32Channel;
  87 typedef struct _GIOWin32Watch GIOWin32Watch;
  88 
  89 #define BUFFER_SIZE 4096
  90 
  91 typedef enum {
  92   G_IO_WIN32_WINDOWS_MESSAGES,  /* Windows messages */
  93 
<span class="line-modified">  94   G_IO_WIN32_FILE_DESC,     /* Unix-like file descriptors from</span>
<span class="line-modified">  95                                  * _open() or _pipe(), except for</span>
<span class="line-modified">  96                                  * console IO. Separate thread to read</span>
<span class="line-modified">  97                                  * or write.</span>
<span class="line-modified">  98                                  */</span>
  99 
<span class="line-modified"> 100   G_IO_WIN32_CONSOLE,       /* Console IO (usually stdin, stdout, stderr) */</span>
 101 
<span class="line-modified"> 102   G_IO_WIN32_SOCKET     /* Sockets. No separate thread. */</span>
 103 } GIOWin32ChannelType;
 104 
 105 struct _GIOWin32Channel {
 106   GIOChannel channel;
<span class="line-modified"> 107   gint fd;          /* Either a Unix-like file handle as provided</span>
<span class="line-modified"> 108                                  * by the Microsoft C runtime, or a SOCKET</span>
<span class="line-modified"> 109                                  * as provided by WinSock.</span>
<span class="line-modified"> 110                                  */</span>
 111   GIOWin32ChannelType type;
 112 
 113   gboolean debug;
 114 
 115   /* Field used by G_IO_WIN32_WINDOWS_MESSAGES channels */
<span class="line-modified"> 116   HWND hwnd;            /* Handle of window, or NULL */</span>
 117 
 118   /* Fields used by G_IO_WIN32_FILE_DESC channels. */
 119   CRITICAL_SECTION mutex;
 120 
<span class="line-modified"> 121   int direction;        /* 0 means we read from it,</span>
<span class="line-modified"> 122                                  * 1 means we write to it.</span>
<span class="line-modified"> 123                                  */</span>
 124 
<span class="line-modified"> 125   gboolean running;     /* Is reader or writer thread</span>
<span class="line-modified"> 126                                  * running. FALSE if EOF has been</span>
<span class="line-modified"> 127                                  * reached by the reader thread.</span>
<span class="line-modified"> 128                                  */</span>
 129 
<span class="line-modified"> 130   gboolean needs_close;     /* If the channel has been closed while</span>
<span class="line-modified"> 131                                  * the reader thread was still running.</span>
<span class="line-modified"> 132                                  */</span>
 133 
<span class="line-modified"> 134   guint thread_id;      /* If non-NULL the channel has or has</span>
<span class="line-modified"> 135                                  * had a reader or writer thread.</span>
<span class="line-modified"> 136                                  */</span>
 137   HANDLE data_avail_event;
 138 
 139   gushort revents;
 140 
 141   /* Data is kept in a circular buffer. To be able to distinguish between
 142    * empty and full buffers, we cannot fill it completely, but have to
 143    * leave a one character gap.
 144    *
 145    * Data available is between indexes rdp and wrp-1 (modulo BUFFER_SIZE).
 146    *
 147    * Empty:    wrp == rdp
 148    * Full:     (wrp + 1) % BUFFER_SIZE == rdp
 149    * Partial:  otherwise
 150    */
<span class="line-modified"> 151   guchar *buffer;       /* (Circular) buffer */</span>
<span class="line-modified"> 152   gint wrp, rdp;        /* Buffer indices for writing and reading */</span>
 153   HANDLE space_avail_event;
 154 
 155   /* Fields used by G_IO_WIN32_SOCKET channels */
 156   int event_mask;
 157   int last_events;
 158   HANDLE event;
 159   gboolean write_would_have_blocked;
 160   gboolean ever_writable;
 161 };
 162 
 163 struct _GIOWin32Watch {
 164   GSource       source;
 165   GPollFD       pollfd;
 166   GIOChannel   *channel;
 167   GIOCondition  condition;
 168 };
 169 
 170 static void
 171 g_win32_print_access_mode (int flags)
 172 {
 173   g_print (&quot;%s%s%s%s%s%s%s%s%s%s&quot;,
<span class="line-modified"> 174        ((flags &amp; 0x3) == _O_RDWR ? &quot;O_RDWR&quot; :</span>
<span class="line-modified"> 175         ((flags &amp; 0x3) == _O_RDONLY ? &quot;O_RDONLY&quot; :</span>
<span class="line-modified"> 176          ((flags &amp; 0x3) == _O_WRONLY ? &quot;O_WRONLY&quot; : &quot;0&quot;))),</span>
<span class="line-modified"> 177        (flags &amp; _O_APPEND ? &quot;|O_APPEND&quot; : &quot;&quot;),</span>
<span class="line-modified"> 178        (flags &amp; _O_RANDOM ? &quot;|O_RANDOM&quot; : &quot;&quot;),</span>
<span class="line-modified"> 179        (flags &amp; _O_SEQUENTIAL ? &quot;|O_SEQUENTIAL&quot; : &quot;&quot;),</span>
<span class="line-modified"> 180        (flags &amp; _O_TEMPORARY ? &quot;|O_TEMPORARY&quot; : &quot;&quot;),</span>
<span class="line-modified"> 181        (flags &amp; _O_CREAT ? &quot;|O_CREAT&quot; : &quot;&quot;),</span>
<span class="line-modified"> 182        (flags &amp; _O_TRUNC ? &quot;|O_TRUNC&quot; : &quot;&quot;),</span>
<span class="line-modified"> 183        (flags &amp; _O_EXCL ? &quot;|O_EXCL&quot; : &quot;&quot;),</span>
<span class="line-modified"> 184        (flags &amp; _O_TEXT ? &quot;|O_TEXT&quot; : &quot;&quot;),</span>
<span class="line-modified"> 185        (flags &amp; _O_BINARY ? &quot;|O_BINARY&quot; : &quot;&quot;));</span>
 186 }
 187 
 188 static void
 189 g_win32_print_gioflags (GIOFlags flags)
 190 {
 191   char *bar = &quot;&quot;;
 192 
 193   if (flags &amp; G_IO_FLAG_APPEND)
 194     bar = &quot;|&quot;, g_print (&quot;APPEND&quot;);
 195   if (flags &amp; G_IO_FLAG_NONBLOCK)
 196     g_print (&quot;%sNONBLOCK&quot;, bar), bar = &quot;|&quot;;
 197   if (flags &amp; G_IO_FLAG_IS_READABLE)
 198     g_print (&quot;%sREADABLE&quot;, bar), bar = &quot;|&quot;;
 199   if (flags &amp; G_IO_FLAG_IS_WRITABLE)
 200     g_print (&quot;%sWRITABLE&quot;, bar), bar = &quot;|&quot;;
 201   if (flags &amp; G_IO_FLAG_IS_SEEKABLE)
 202     g_print (&quot;%sSEEKABLE&quot;, bar), bar = &quot;|&quot;;
 203 }
 204 
 205 static const char *
</pre>
<hr />
<pre>
 211 
 212   if (mask == 0)
 213     return &quot;&quot;;
 214 
 215 #define BIT(n) checked_bits |= FD_##n; if (mask &amp; FD_##n) bufp += sprintf (bufp, &quot;%s&quot; #n, (bufp&gt;buf ? &quot;|&quot; : &quot;&quot;))
 216 
 217   BIT (READ);
 218   BIT (WRITE);
 219   BIT (OOB);
 220   BIT (ACCEPT);
 221   BIT (CONNECT);
 222   BIT (CLOSE);
 223   BIT (QOS);
 224   BIT (GROUP_QOS);
 225   BIT (ROUTING_INTERFACE_CHANGE);
 226   BIT (ADDRESS_LIST_CHANGE);
 227 
 228 #undef BIT
 229 
 230   if ((mask &amp; ~checked_bits) != 0)
<span class="line-modified"> 231       bufp += sprintf (bufp, &quot;|%#x&quot;, mask &amp; ~checked_bits);</span>
 232 
 233   return g_quark_to_string (g_quark_from_string (buf));
 234 }
 235 
 236 static const char *
 237 condition_to_string (GIOCondition condition)
 238 {
 239   char buf[100];
 240   int checked_bits = 0;
 241   char *bufp = buf;
 242 
 243   if (condition == 0)
 244     return &quot;&quot;;
 245 
 246 #define BIT(n) checked_bits |= G_IO_##n; if (condition &amp; G_IO_##n) bufp += sprintf (bufp, &quot;%s&quot; #n, (bufp&gt;buf ? &quot;|&quot; : &quot;&quot;))
 247 
 248   BIT (IN);
 249   BIT (OUT);
 250   BIT (PRI);
 251   BIT (ERR);
 252   BIT (HUP);
 253   BIT (NVAL);
 254 
 255 #undef BIT
 256 
 257   if ((condition &amp; ~checked_bits) != 0)
<span class="line-modified"> 258       bufp += sprintf (bufp, &quot;|%#x&quot;, condition &amp; ~checked_bits);</span>
 259 
 260   return g_quark_to_string (g_quark_from_string (buf));
 261 }
 262 
 263 static gboolean
 264 g_io_win32_get_debug_flag (void)
 265 {
 266   return (getenv (&quot;G_IO_WIN32_DEBUG&quot;) != NULL);
 267 }
 268 
 269 static void
 270 g_io_channel_win32_init (GIOWin32Channel *channel)
 271 {
 272   channel-&gt;debug = g_io_win32_get_debug_flag ();
 273 
 274   InitializeCriticalSection (&amp;channel-&gt;mutex);
 275   channel-&gt;running = FALSE;
 276   channel-&gt;needs_close = FALSE;
 277   channel-&gt;thread_id = 0;
 278   channel-&gt;data_avail_event = NULL;
</pre>
<hr />
<pre>
 303       || !(channel-&gt;space_avail_event = CreateEvent (&amp;sec_attrs, FALSE, FALSE, NULL)))
 304     {
 305       gchar *emsg = g_win32_error_message (GetLastError ());
 306 
 307       g_error (&quot;Error creating event: %s&quot;, emsg);
 308       g_free (emsg);
 309     }
 310 }
 311 
 312 static unsigned __stdcall
 313 read_thread (void *parameter)
 314 {
 315   GIOWin32Channel *channel = parameter;
 316   guchar *buffer;
 317   gint nbytes;
 318 
 319   g_io_channel_ref ((GIOChannel *)channel);
 320 
 321   if (channel-&gt;debug)
 322     g_print (&quot;read_thread %#x: start fd=%d, data_avail=%p space_avail=%p\n&quot;,
<span class="line-modified"> 323          channel-&gt;thread_id,</span>
<span class="line-modified"> 324          channel-&gt;fd,</span>
<span class="line-modified"> 325          channel-&gt;data_avail_event,</span>
<span class="line-modified"> 326          channel-&gt;space_avail_event);</span>
 327 
 328   channel-&gt;direction = 0;
 329   channel-&gt;buffer = g_malloc (BUFFER_SIZE);
 330   channel-&gt;rdp = channel-&gt;wrp = 0;
 331   channel-&gt;running = TRUE;
 332 
 333   SetEvent (channel-&gt;space_avail_event);
 334 
 335   EnterCriticalSection (&amp;channel-&gt;mutex);
 336   while (channel-&gt;running)
 337     {
 338       if (channel-&gt;debug)
<span class="line-modified"> 339     g_print (&quot;read_thread %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified"> 340          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
 341       if ((channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)
<span class="line-modified"> 342     {</span>
<span class="line-modified"> 343       /* Buffer is full */</span>
<span class="line-modified"> 344       if (channel-&gt;debug)</span>
<span class="line-modified"> 345         g_print (&quot;read_thread %#x: resetting space_avail\n&quot;,</span>
<span class="line-modified"> 346              channel-&gt;thread_id);</span>
<span class="line-modified"> 347       ResetEvent (channel-&gt;space_avail_event);</span>
<span class="line-modified"> 348       if (channel-&gt;debug)</span>
<span class="line-modified"> 349         g_print (&quot;read_thread %#x: waiting for space\n&quot;,</span>
<span class="line-modified"> 350              channel-&gt;thread_id);</span>
<span class="line-modified"> 351       LeaveCriticalSection (&amp;channel-&gt;mutex);</span>
<span class="line-modified"> 352       WaitForSingleObject (channel-&gt;space_avail_event, INFINITE);</span>
<span class="line-modified"> 353       EnterCriticalSection (&amp;channel-&gt;mutex);</span>
<span class="line-modified"> 354       if (channel-&gt;debug)</span>
<span class="line-modified"> 355         g_print (&quot;read_thread %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified"> 356              channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
<span class="line-modified"> 357     }</span>
 358 
 359       buffer = channel-&gt;buffer + channel-&gt;wrp;
 360 
 361       /* Always leave at least one byte unused gap to be able to
 362        * distinguish between the full and empty condition...
 363        */
 364       nbytes = MIN ((channel-&gt;rdp + BUFFER_SIZE - channel-&gt;wrp - 1) % BUFFER_SIZE,
<span class="line-modified"> 365             BUFFER_SIZE - channel-&gt;wrp);</span>
 366 
 367       if (channel-&gt;debug)
<span class="line-modified"> 368     g_print (&quot;read_thread %#x: calling read() for %d bytes\n&quot;,</span>
<span class="line-modified"> 369          channel-&gt;thread_id, nbytes);</span>
 370 
 371       LeaveCriticalSection (&amp;channel-&gt;mutex);
 372 
 373       nbytes = read (channel-&gt;fd, buffer, nbytes);
 374 
 375       EnterCriticalSection (&amp;channel-&gt;mutex);
 376 
 377       channel-&gt;revents = G_IO_IN;
 378       if (nbytes == 0)
<span class="line-modified"> 379     channel-&gt;revents |= G_IO_HUP;</span>
 380       else if (nbytes &lt; 0)
<span class="line-modified"> 381     channel-&gt;revents |= G_IO_ERR;</span>
 382 
 383       if (channel-&gt;debug)
<span class="line-modified"> 384     g_print (&quot;read_thread %#x: read() returned %d, rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified"> 385          channel-&gt;thread_id, nbytes, channel-&gt;rdp, channel-&gt;wrp);</span>
 386 
 387       if (nbytes &lt;= 0)
<span class="line-modified"> 388     break;</span>
 389 
 390       channel-&gt;wrp = (channel-&gt;wrp + nbytes) % BUFFER_SIZE;
 391       if (channel-&gt;debug)
<span class="line-modified"> 392     g_print (&quot;read_thread %#x: rdp=%d, wrp=%d, setting data_avail\n&quot;,</span>
<span class="line-modified"> 393          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
 394       SetEvent (channel-&gt;data_avail_event);
 395     }
 396 
 397   channel-&gt;running = FALSE;
 398   if (channel-&gt;needs_close)
 399     {
 400       if (channel-&gt;debug)
<span class="line-modified"> 401     g_print (&quot;read_thread %#x: channel fd %d needs closing\n&quot;,</span>
<span class="line-modified"> 402          channel-&gt;thread_id, channel-&gt;fd);</span>
 403       close (channel-&gt;fd);
 404       channel-&gt;fd = -1;
 405     }
 406 
 407   if (channel-&gt;debug)
 408     g_print (&quot;read_thread %#x: EOF, rdp=%d, wrp=%d, setting data_avail\n&quot;,
<span class="line-modified"> 409          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
 410   SetEvent (channel-&gt;data_avail_event);
 411   LeaveCriticalSection (&amp;channel-&gt;mutex);
 412 
 413   g_io_channel_unref ((GIOChannel *)channel);
 414 
 415   /* No need to call _endthreadex(), the actual thread starter routine
 416    * in MSVCRT (see crt/src/threadex.c:_threadstartex) calls
 417    * _endthreadex() for us.
 418    */
 419 
 420   return 0;
 421 }
 422 
 423 static unsigned __stdcall
 424 write_thread (void *parameter)
 425 {
 426   GIOWin32Channel *channel = parameter;
 427   guchar *buffer;
 428   gint nbytes;
 429 
 430   g_io_channel_ref ((GIOChannel *)channel);
 431 
 432   if (channel-&gt;debug)
 433     g_print (&quot;write_thread %#x: start fd=%d, data_avail=%p space_avail=%p\n&quot;,
<span class="line-modified"> 434          channel-&gt;thread_id,</span>
<span class="line-modified"> 435          channel-&gt;fd,</span>
<span class="line-modified"> 436          channel-&gt;data_avail_event,</span>
<span class="line-modified"> 437          channel-&gt;space_avail_event);</span>
 438 
 439   channel-&gt;direction = 1;
 440   channel-&gt;buffer = g_malloc (BUFFER_SIZE);
 441   channel-&gt;rdp = channel-&gt;wrp = 0;
 442   channel-&gt;running = TRUE;
 443 
 444   SetEvent (channel-&gt;space_avail_event);
 445 
 446   /* We use the same event objects as for a reader thread, but with
 447    * reversed meaning. So, space_avail is used if data is available
 448    * for writing, and data_avail is used if space is available in the
 449    * write buffer.
 450    */
 451 
 452   EnterCriticalSection (&amp;channel-&gt;mutex);
 453   while (channel-&gt;running || channel-&gt;rdp != channel-&gt;wrp)
 454     {
 455       if (channel-&gt;debug)
<span class="line-modified"> 456     g_print (&quot;write_thread %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified"> 457          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
 458       if (channel-&gt;wrp == channel-&gt;rdp)
<span class="line-modified"> 459     {</span>
<span class="line-modified"> 460       /* Buffer is empty. */</span>
<span class="line-modified"> 461       if (channel-&gt;debug)</span>
<span class="line-modified"> 462         g_print (&quot;write_thread %#x: resetting space_avail\n&quot;,</span>
<span class="line-modified"> 463              channel-&gt;thread_id);</span>
<span class="line-modified"> 464       ResetEvent (channel-&gt;space_avail_event);</span>
<span class="line-modified"> 465       if (channel-&gt;debug)</span>
<span class="line-modified"> 466         g_print (&quot;write_thread %#x: waiting for data\n&quot;,</span>
<span class="line-modified"> 467              channel-&gt;thread_id);</span>
<span class="line-modified"> 468       channel-&gt;revents = G_IO_OUT;</span>
<span class="line-modified"> 469       SetEvent (channel-&gt;data_avail_event);</span>
<span class="line-modified"> 470       LeaveCriticalSection (&amp;channel-&gt;mutex);</span>
<span class="line-modified"> 471       WaitForSingleObject (channel-&gt;space_avail_event, INFINITE);</span>
 472 
<span class="line-modified"> 473       EnterCriticalSection (&amp;channel-&gt;mutex);</span>
<span class="line-modified"> 474       if (channel-&gt;rdp == channel-&gt;wrp)</span>
<span class="line-modified"> 475         break;</span>
 476 
<span class="line-modified"> 477       if (channel-&gt;debug)</span>
<span class="line-modified"> 478         g_print (&quot;write_thread %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified"> 479              channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
<span class="line-modified"> 480     }</span>
 481 
 482       buffer = channel-&gt;buffer + channel-&gt;rdp;
 483       if (channel-&gt;rdp &lt; channel-&gt;wrp)
<span class="line-modified"> 484     nbytes = channel-&gt;wrp - channel-&gt;rdp;</span>
 485       else
<span class="line-modified"> 486     nbytes = BUFFER_SIZE - channel-&gt;rdp;</span>
 487 
 488       if (channel-&gt;debug)
<span class="line-modified"> 489     g_print (&quot;write_thread %#x: calling write() for %d bytes\n&quot;,</span>
<span class="line-modified"> 490          channel-&gt;thread_id, nbytes);</span>
 491 
 492       LeaveCriticalSection (&amp;channel-&gt;mutex);
 493       nbytes = write (channel-&gt;fd, buffer, nbytes);
 494       EnterCriticalSection (&amp;channel-&gt;mutex);
 495 
 496       if (channel-&gt;debug)
<span class="line-modified"> 497     g_print (&quot;write_thread %#x: write(%i) returned %d, rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified"> 498          channel-&gt;thread_id, channel-&gt;fd, nbytes, channel-&gt;rdp, channel-&gt;wrp);</span>
 499 
 500       channel-&gt;revents = 0;
 501       if (nbytes &gt; 0)
<span class="line-modified"> 502     channel-&gt;revents |= G_IO_OUT;</span>
 503       else if (nbytes &lt;= 0)
<span class="line-modified"> 504     channel-&gt;revents |= G_IO_ERR;</span>
 505 
 506       channel-&gt;rdp = (channel-&gt;rdp + nbytes) % BUFFER_SIZE;
 507 
 508       if (nbytes &lt;= 0)
<span class="line-modified"> 509     break;</span>
 510 
 511       if (channel-&gt;debug)
<span class="line-modified"> 512     g_print (&quot;write_thread: setting data_avail for thread %#x\n&quot;,</span>
<span class="line-modified"> 513          channel-&gt;thread_id);</span>
 514       SetEvent (channel-&gt;data_avail_event);
 515     }
 516 
 517   channel-&gt;running = FALSE;
 518   if (channel-&gt;needs_close)
 519     {
 520       if (channel-&gt;debug)
<span class="line-modified"> 521     g_print (&quot;write_thread %#x: channel fd %d needs closing\n&quot;,</span>
<span class="line-modified"> 522          channel-&gt;thread_id, channel-&gt;fd);</span>
 523       close (channel-&gt;fd);
 524       channel-&gt;fd = -1;
 525     }
 526 
 527   LeaveCriticalSection (&amp;channel-&gt;mutex);
 528 
 529   g_io_channel_unref ((GIOChannel *)channel);
 530 
 531   return 0;
 532 }
 533 
 534 static void
 535 create_thread (GIOWin32Channel     *channel,
<span class="line-modified"> 536            GIOCondition         condition,</span>
<span class="line-modified"> 537            unsigned (__stdcall *thread) (void *parameter))</span>
 538 {
 539   HANDLE thread_handle;
 540   int errsv;
 541 
 542   thread_handle = (HANDLE) _beginthreadex (NULL, 0, thread, channel, 0,
<span class="line-modified"> 543                        &amp;channel-&gt;thread_id);</span>
 544   errsv = errno;
 545   if (thread_handle == 0)
 546     g_warning (&quot;Error creating thread: %s.&quot;,
<span class="line-modified"> 547            g_strerror (errsv));</span>
 548   else if (!CloseHandle (thread_handle))
 549     {
 550       gchar *emsg = g_win32_error_message (GetLastError ());
 551 
 552       g_warning (&quot;Error closing thread handle: %s.&quot;, emsg);
 553       g_free (emsg);
 554     }
 555 
 556   WaitForSingleObject (channel-&gt;space_avail_event, INFINITE);
 557 }
 558 
 559 static GIOStatus
 560 buffer_read (GIOWin32Channel *channel,
<span class="line-modified"> 561          gchar           *dest,</span>
<span class="line-modified"> 562          gsize            count,</span>
<span class="line-modified"> 563          gsize           *bytes_read,</span>
<span class="line-modified"> 564          GError         **err)</span>
 565 {
 566   guint nbytes;
 567   guint left = count;
 568 
 569   EnterCriticalSection (&amp;channel-&gt;mutex);
 570   if (channel-&gt;debug)
 571     g_print (&quot;reading from thread %#x %&quot; G_GSIZE_FORMAT &quot; bytes, rdp=%d, wrp=%d\n&quot;,
<span class="line-modified"> 572          channel-&gt;thread_id, count, channel-&gt;rdp, channel-&gt;wrp);</span>
 573 
 574   if (channel-&gt;wrp == channel-&gt;rdp)
 575     {
 576       LeaveCriticalSection (&amp;channel-&gt;mutex);
 577       if (channel-&gt;debug)
<span class="line-modified"> 578     g_print (&quot;waiting for data from thread %#x\n&quot;, channel-&gt;thread_id);</span>
 579       WaitForSingleObject (channel-&gt;data_avail_event, INFINITE);
 580       if (channel-&gt;debug)
<span class="line-modified"> 581     g_print (&quot;done waiting for data from thread %#x\n&quot;, channel-&gt;thread_id);</span>
 582       EnterCriticalSection (&amp;channel-&gt;mutex);
 583       if (channel-&gt;wrp == channel-&gt;rdp &amp;&amp; !channel-&gt;running)
<span class="line-modified"> 584     {</span>
<span class="line-modified"> 585       if (channel-&gt;debug)</span>
<span class="line-modified"> 586         g_print (&quot;wrp==rdp, !running\n&quot;);</span>
<span class="line-modified"> 587       LeaveCriticalSection (&amp;channel-&gt;mutex);</span>
 588           *bytes_read = 0;
<span class="line-modified"> 589       return G_IO_STATUS_EOF;</span>
<span class="line-modified"> 590     }</span>
 591     }
 592 
 593   if (channel-&gt;rdp &lt; channel-&gt;wrp)
 594     nbytes = channel-&gt;wrp - channel-&gt;rdp;
 595   else
 596     nbytes = BUFFER_SIZE - channel-&gt;rdp;
 597   LeaveCriticalSection (&amp;channel-&gt;mutex);
 598   nbytes = MIN (left, nbytes);
 599   if (channel-&gt;debug)
 600     g_print (&quot;moving %d bytes from thread %#x\n&quot;,
<span class="line-modified"> 601          nbytes, channel-&gt;thread_id);</span>
 602   memcpy (dest, channel-&gt;buffer + channel-&gt;rdp, nbytes);
 603   dest += nbytes;
 604   left -= nbytes;
 605   EnterCriticalSection (&amp;channel-&gt;mutex);
 606   channel-&gt;rdp = (channel-&gt;rdp + nbytes) % BUFFER_SIZE;
 607   if (channel-&gt;debug)
 608     g_print (&quot;setting space_avail for thread %#x\n&quot;, channel-&gt;thread_id);
 609   SetEvent (channel-&gt;space_avail_event);
 610   if (channel-&gt;debug)
 611     g_print (&quot;for thread %#x: rdp=%d, wrp=%d\n&quot;,
<span class="line-modified"> 612          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
 613   if (channel-&gt;running &amp;&amp; channel-&gt;wrp == channel-&gt;rdp)
 614     {
 615       if (channel-&gt;debug)
<span class="line-modified"> 616     g_print (&quot;resetting data_avail of thread %#x\n&quot;,</span>
<span class="line-modified"> 617          channel-&gt;thread_id);</span>
 618       ResetEvent (channel-&gt;data_avail_event);
 619     };
 620   LeaveCriticalSection (&amp;channel-&gt;mutex);
 621 
 622   /* We have no way to indicate any errors form the actual
 623    * read() or recv() call in the reader thread. Should we have?
 624    */
 625   *bytes_read = count - left;
 626   return (*bytes_read &gt; 0) ? G_IO_STATUS_NORMAL : G_IO_STATUS_EOF;
 627 }
 628 
 629 
 630 static GIOStatus
 631 buffer_write (GIOWin32Channel *channel,
<span class="line-modified"> 632           const gchar     *dest,</span>
<span class="line-modified"> 633           gsize            count,</span>
<span class="line-modified"> 634           gsize           *bytes_written,</span>
<span class="line-modified"> 635           GError         **err)</span>
 636 {
 637   guint nbytes;
 638   guint left = count;
 639 
 640   EnterCriticalSection (&amp;channel-&gt;mutex);
 641   if (channel-&gt;debug)
 642     g_print (&quot;buffer_write: writing to thread %#x %&quot; G_GSIZE_FORMAT &quot; bytes, rdp=%d, wrp=%d\n&quot;,
<span class="line-modified"> 643          channel-&gt;thread_id, count, channel-&gt;rdp, channel-&gt;wrp);</span>
 644 
 645   if ((channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)
 646     {
 647       /* Buffer is full */
 648       if (channel-&gt;debug)
<span class="line-modified"> 649     g_print (&quot;buffer_write: tid %#x: resetting data_avail\n&quot;,</span>
<span class="line-modified"> 650          channel-&gt;thread_id);</span>
 651       ResetEvent (channel-&gt;data_avail_event);
 652       if (channel-&gt;debug)
<span class="line-modified"> 653     g_print (&quot;buffer_write: tid %#x: waiting for space\n&quot;,</span>
<span class="line-modified"> 654          channel-&gt;thread_id);</span>
 655       LeaveCriticalSection (&amp;channel-&gt;mutex);
 656       WaitForSingleObject (channel-&gt;data_avail_event, INFINITE);
 657       EnterCriticalSection (&amp;channel-&gt;mutex);
 658       if (channel-&gt;debug)
<span class="line-modified"> 659     g_print (&quot;buffer_write: tid %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified"> 660          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
 661     }
 662 
 663   nbytes = MIN ((channel-&gt;rdp + BUFFER_SIZE - channel-&gt;wrp - 1) % BUFFER_SIZE,
<span class="line-modified"> 664         BUFFER_SIZE - channel-&gt;wrp);</span>
 665 
 666   LeaveCriticalSection (&amp;channel-&gt;mutex);
 667   nbytes = MIN (left, nbytes);
 668   if (channel-&gt;debug)
 669     g_print (&quot;buffer_write: tid %#x: writing %d bytes\n&quot;,
<span class="line-modified"> 670          channel-&gt;thread_id, nbytes);</span>
 671   memcpy (channel-&gt;buffer + channel-&gt;wrp, dest, nbytes);
 672   dest += nbytes;
 673   left -= nbytes;
 674   EnterCriticalSection (&amp;channel-&gt;mutex);
 675 
 676   channel-&gt;wrp = (channel-&gt;wrp + nbytes) % BUFFER_SIZE;
 677   if (channel-&gt;debug)
 678     g_print (&quot;buffer_write: tid %#x: rdp=%d, wrp=%d, setting space_avail\n&quot;,
<span class="line-modified"> 679          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
 680   SetEvent (channel-&gt;space_avail_event);
 681 
 682   if ((channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)
 683     {
 684       /* Buffer is full */
 685       if (channel-&gt;debug)
<span class="line-modified"> 686     g_print (&quot;buffer_write: tid %#x: resetting data_avail\n&quot;,</span>
<span class="line-modified"> 687          channel-&gt;thread_id);</span>
 688       ResetEvent (channel-&gt;data_avail_event);
 689     }
 690 
 691   LeaveCriticalSection (&amp;channel-&gt;mutex);
 692 
 693   /* We have no way to indicate any errors form the actual
 694    * write() call in the writer thread. Should we have?
 695    */
 696   *bytes_written = count - left;
 697   return (*bytes_written &gt; 0) ? G_IO_STATUS_NORMAL : G_IO_STATUS_EOF;
 698 }
 699 
 700 
 701 static gboolean
 702 g_io_win32_prepare (GSource *source,
<span class="line-modified"> 703             gint    *timeout)</span>
 704 {
 705   GIOWin32Watch *watch = (GIOWin32Watch *)source;
 706   GIOCondition buffer_condition = g_io_channel_get_buffer_condition (watch-&gt;channel);
 707   GIOWin32Channel *channel = (GIOWin32Channel *)watch-&gt;channel;
 708   int event_mask;
 709 
 710   *timeout = -1;
 711 
 712   if (channel-&gt;debug)
 713     g_print (&quot;g_io_win32_prepare: source=%p channel=%p&quot;, source, channel);
 714 
 715   switch (channel-&gt;type)
 716     {
 717     case G_IO_WIN32_WINDOWS_MESSAGES:
 718       if (channel-&gt;debug)
<span class="line-modified"> 719     g_print (&quot; MSG&quot;);</span>
 720       break;
 721 
 722     case G_IO_WIN32_CONSOLE:
 723       if (channel-&gt;debug)
<span class="line-modified"> 724     g_print (&quot; CON&quot;);</span>
 725       break;
 726 
 727     case G_IO_WIN32_FILE_DESC:
 728       if (channel-&gt;debug)
<span class="line-modified"> 729     g_print (&quot; FD thread=%#x buffer_condition:{%s}&quot;</span>
<span class="line-modified"> 730          &quot;\n  watch-&gt;pollfd.events:{%s} watch-&gt;pollfd.revents:{%s} channel-&gt;revents:{%s}&quot;,</span>
<span class="line-modified"> 731          channel-&gt;thread_id, condition_to_string (buffer_condition),</span>
<span class="line-modified"> 732          condition_to_string (watch-&gt;pollfd.events),</span>
<span class="line-modified"> 733          condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified"> 734          condition_to_string (channel-&gt;revents));</span>
 735 
 736       EnterCriticalSection (&amp;channel-&gt;mutex);
 737       if (channel-&gt;running)
<span class="line-modified"> 738     {</span>
<span class="line-modified"> 739       if (channel-&gt;direction == 0 &amp;&amp; channel-&gt;wrp == channel-&gt;rdp)</span>
<span class="line-modified"> 740         {</span>
<span class="line-modified"> 741           if (channel-&gt;debug)</span>
<span class="line-modified"> 742         g_print (&quot;\n  setting revents=0&quot;);</span>
<span class="line-modified"> 743           channel-&gt;revents = 0;</span>
<span class="line-modified"> 744         }</span>
<span class="line-modified"> 745     }</span>
 746       else
<span class="line-modified"> 747     {</span>
<span class="line-modified"> 748       if (channel-&gt;direction == 1</span>
<span class="line-modified"> 749           &amp;&amp; (channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)</span>
<span class="line-modified"> 750         {</span>
<span class="line-modified"> 751           if (channel-&gt;debug)</span>
<span class="line-modified"> 752         g_print (&quot;\n setting revents=0&quot;);</span>
<span class="line-modified"> 753           channel-&gt;revents = 0;</span>
<span class="line-modified"> 754         }</span>
<span class="line-modified"> 755     }</span>
 756       LeaveCriticalSection (&amp;channel-&gt;mutex);
 757       break;
 758 
 759     case G_IO_WIN32_SOCKET:
 760       if (channel-&gt;debug)
<span class="line-modified"> 761     g_print (&quot; SOCK&quot;);</span>
 762       event_mask = 0;
 763       if (watch-&gt;condition &amp; G_IO_IN)
<span class="line-modified"> 764     event_mask |= (FD_READ | FD_ACCEPT);</span>
 765       if (watch-&gt;condition &amp; G_IO_OUT)
<span class="line-modified"> 766     event_mask |= (FD_WRITE | FD_CONNECT);</span>
 767       event_mask |= FD_CLOSE;
 768 
 769       if (channel-&gt;event_mask != event_mask)
<span class="line-modified"> 770     {</span>






 771       if (channel-&gt;debug)
<span class="line-modified"> 772         g_print (&quot;\n  WSAEventSelect(%d,%p,{%s})&quot;,</span>
<span class="line-modified"> 773              channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd,</span>
<span class="line-removed"> 774              event_mask_to_string (event_mask));</span>
<span class="line-removed"> 775       if (WSAEventSelect (channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd,</span>
<span class="line-removed"> 776                   event_mask) == SOCKET_ERROR)</span>
<span class="line-removed"> 777         if (channel-&gt;debug)</span>
<span class="line-removed"> 778           {</span>
<span class="line-removed"> 779         gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
 780 
<span class="line-modified"> 781         g_print (&quot; failed: %s&quot;, emsg);</span>
<span class="line-modified"> 782         g_free (emsg);</span>
<span class="line-modified"> 783           }</span>
<span class="line-modified"> 784       channel-&gt;event_mask = event_mask;</span>
 785 
<span class="line-modified"> 786       if (channel-&gt;debug)</span>
<span class="line-modified"> 787         g_print (&quot;\n  setting last_events=0&quot;);</span>
<span class="line-modified"> 788       channel-&gt;last_events = 0;</span>
 789 
<span class="line-modified"> 790       if ((event_mask &amp; FD_WRITE) &amp;&amp;</span>
<span class="line-modified"> 791           channel-&gt;ever_writable &amp;&amp;</span>
<span class="line-modified"> 792           !channel-&gt;write_would_have_blocked)</span>
<span class="line-modified"> 793         {</span>
<span class="line-modified"> 794           if (channel-&gt;debug)</span>
<span class="line-modified"> 795         g_print (&quot; WSASetEvent(%p)&quot;, (WSAEVENT) watch-&gt;pollfd.fd);</span>
<span class="line-modified"> 796           WSASetEvent ((WSAEVENT) watch-&gt;pollfd.fd);</span>
<span class="line-modified"> 797         }</span>
<span class="line-modified"> 798     }</span>
 799       break;
 800 
 801     default:
 802       g_assert_not_reached ();
 803       g_abort ();
 804     }
 805   if (channel-&gt;debug)
 806     g_print (&quot;\n&quot;);
 807 
 808   return ((watch-&gt;condition &amp; buffer_condition) == watch-&gt;condition);
 809 }
 810 
 811 static gboolean
 812 g_io_win32_check (GSource *source)
 813 {
 814   MSG msg;
 815   GIOWin32Watch *watch = (GIOWin32Watch *)source;
 816   GIOWin32Channel *channel = (GIOWin32Channel *)watch-&gt;channel;
 817   GIOCondition buffer_condition = g_io_channel_get_buffer_condition (watch-&gt;channel);
 818   WSANETWORKEVENTS events;
 819 
 820   if (channel-&gt;debug)
 821     g_print (&quot;g_io_win32_check: source=%p channel=%p&quot;, source, channel);
 822 
 823   switch (channel-&gt;type)
 824     {
 825     case G_IO_WIN32_WINDOWS_MESSAGES:
 826       if (channel-&gt;debug)
<span class="line-modified"> 827     g_print (&quot; MSG\n&quot;);</span>
 828       return (PeekMessage (&amp;msg, channel-&gt;hwnd, 0, 0, PM_NOREMOVE));
 829 
 830     case G_IO_WIN32_FILE_DESC:
 831       if (channel-&gt;debug)
<span class="line-modified"> 832     g_print (&quot; FD thread=%#x buffer_condition=%s\n&quot;</span>
<span class="line-modified"> 833          &quot;  watch-&gt;pollfd.events={%s} watch-&gt;pollfd.revents={%s} channel-&gt;revents={%s}\n&quot;,</span>
<span class="line-modified"> 834          channel-&gt;thread_id, condition_to_string (buffer_condition),</span>
<span class="line-modified"> 835          condition_to_string (watch-&gt;pollfd.events),</span>
<span class="line-modified"> 836          condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified"> 837          condition_to_string (channel-&gt;revents));</span>
 838 
 839       watch-&gt;pollfd.revents = (watch-&gt;pollfd.events &amp; channel-&gt;revents);
 840 
 841       return ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition);
 842 
 843     case G_IO_WIN32_CONSOLE:
 844       if (channel-&gt;debug)
<span class="line-modified"> 845     g_print (&quot; CON\n&quot;);</span>
 846       if (watch-&gt;channel-&gt;is_writeable)
<span class="line-modified"> 847     return TRUE;</span>
 848       else if (watch-&gt;channel-&gt;is_readable)
 849         {
<span class="line-modified"> 850       INPUT_RECORD buffer;</span>
<span class="line-modified"> 851       DWORD n;</span>
<span class="line-modified"> 852       if (PeekConsoleInput ((HANDLE) watch-&gt;pollfd.fd, &amp;buffer, 1, &amp;n) &amp;&amp;</span>
<span class="line-modified"> 853           n == 1)</span>
<span class="line-modified"> 854         {</span>
<span class="line-modified"> 855           /* _kbhit() does quite complex processing to find out</span>
<span class="line-modified"> 856            * whether at least one of the key events pending corresponds</span>
<span class="line-modified"> 857            * to a &quot;real&quot; character that can be read.</span>
<span class="line-modified"> 858            */</span>
<span class="line-modified"> 859           if (_kbhit ())</span>
<span class="line-modified"> 860         return TRUE;</span>
<span class="line-modified"> 861 </span>
<span class="line-modified"> 862           /* Discard all other kinds of events */</span>
<span class="line-modified"> 863           ReadConsoleInput ((HANDLE) watch-&gt;pollfd.fd, &amp;buffer, 1, &amp;n);</span>
<span class="line-modified"> 864         }</span>
 865         }
 866       return FALSE;
 867 
 868     case G_IO_WIN32_SOCKET:
 869       if (channel-&gt;debug)
<span class="line-modified"> 870     g_print (&quot; SOCK&quot;);</span>
 871       if (channel-&gt;last_events &amp; FD_WRITE)
<span class="line-modified"> 872     {</span>
<span class="line-modified"> 873       if (channel-&gt;debug)</span>
<span class="line-modified"> 874         g_print (&quot; sock=%d event=%p last_events has FD_WRITE&quot;,</span>
<span class="line-modified"> 875              channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd);</span>
<span class="line-modified"> 876     }</span>
 877       else
<span class="line-modified"> 878     {</span>
<span class="line-modified"> 879       WSAEnumNetworkEvents (channel-&gt;fd, 0, &amp;events);</span>
 880 
<span class="line-modified"> 881       if (channel-&gt;debug)</span>
<span class="line-modified"> 882         g_print (&quot;\n  revents={%s} condition={%s}&quot;</span>
<span class="line-modified"> 883              &quot;\n  WSAEnumNetworkEvents(%d,0) sets events={%s}&quot;,</span>
<span class="line-modified"> 884              condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified"> 885              condition_to_string (watch-&gt;condition),</span>
<span class="line-modified"> 886              channel-&gt;fd,</span>
<span class="line-modified"> 887              event_mask_to_string (events.lNetworkEvents));</span>
<span class="line-modified"> 888 </span>
<span class="line-modified"> 889       if (watch-&gt;pollfd.revents != 0 &amp;&amp;</span>
<span class="line-modified"> 890           events.lNetworkEvents == 0 &amp;&amp;</span>
<span class="line-modified"> 891           !(channel-&gt;event_mask &amp; FD_WRITE))</span>
<span class="line-modified"> 892         {</span>
<span class="line-modified"> 893           channel-&gt;event_mask = 0;</span>
<span class="line-modified"> 894           if (channel-&gt;debug)</span>
<span class="line-modified"> 895         g_print (&quot;\n  WSAEventSelect(%d,%p,{})&quot;,</span>
<span class="line-modified"> 896              channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd);</span>
<span class="line-modified"> 897           WSAEventSelect (channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd, 0);</span>
<span class="line-modified"> 898           if (channel-&gt;debug)</span>
<span class="line-modified"> 899         g_print (&quot;  ResetEvent(%p)&quot;,</span>
<span class="line-modified"> 900              (HANDLE) watch-&gt;pollfd.fd);</span>
<span class="line-modified"> 901           ResetEvent ((HANDLE) watch-&gt;pollfd.fd);</span>
<span class="line-modified"> 902         }</span>
<span class="line-modified"> 903       else if (events.lNetworkEvents &amp; FD_WRITE)</span>
<span class="line-modified"> 904         channel-&gt;ever_writable = TRUE;</span>
<span class="line-modified"> 905       channel-&gt;last_events = events.lNetworkEvents;</span>
<span class="line-modified"> 906     }</span>
 907 
 908       watch-&gt;pollfd.revents = 0;
 909       if (channel-&gt;last_events &amp; (FD_READ | FD_ACCEPT))
<span class="line-modified"> 910     watch-&gt;pollfd.revents |= G_IO_IN;</span>
 911 
 912       if (channel-&gt;last_events &amp; FD_WRITE)
<span class="line-modified"> 913     watch-&gt;pollfd.revents |= G_IO_OUT;</span>
 914       else
<span class="line-modified"> 915     {</span>
<span class="line-modified"> 916       /* We have called WSAEnumNetworkEvents() above but it didn&#39;t</span>
<span class="line-modified"> 917        * set FD_WRITE.</span>
<span class="line-modified"> 918        */</span>
<span class="line-modified"> 919       if (events.lNetworkEvents &amp; FD_CONNECT)</span>
<span class="line-modified"> 920         {</span>
<span class="line-modified"> 921           if (events.iErrorCode[FD_CONNECT_BIT] == 0)</span>
<span class="line-modified"> 922         watch-&gt;pollfd.revents |= G_IO_OUT;</span>
<span class="line-modified"> 923           else</span>
<span class="line-modified"> 924         watch-&gt;pollfd.revents |= (G_IO_HUP | G_IO_ERR);</span>
<span class="line-modified"> 925         }</span>
<span class="line-modified"> 926       if (watch-&gt;pollfd.revents == 0 &amp;&amp; (channel-&gt;last_events &amp; (FD_CLOSE)))</span>
<span class="line-modified"> 927         watch-&gt;pollfd.revents |= G_IO_HUP;</span>
<span class="line-modified"> 928     }</span>
 929 
 930       /* Regardless of WSAEnumNetworkEvents() result, if watching for
 931        * writability, and if we have ever got a FD_WRITE event, and
 932        * unless last write would have blocked, set G_IO_OUT. But never
 933        * set both G_IO_OUT and G_IO_HUP.
 934        */
 935       if (!(watch-&gt;pollfd.revents &amp; G_IO_HUP) &amp;&amp;
<span class="line-modified"> 936       channel-&gt;ever_writable &amp;&amp;</span>
<span class="line-modified"> 937       !channel-&gt;write_would_have_blocked &amp;&amp;</span>
<span class="line-modified"> 938       (channel-&gt;event_mask &amp; FD_WRITE))</span>
<span class="line-modified"> 939     watch-&gt;pollfd.revents |= G_IO_OUT;</span>
 940 
 941       if (channel-&gt;debug)
<span class="line-modified"> 942     g_print (&quot;\n  revents={%s} retval={%s}\n&quot;,</span>
<span class="line-modified"> 943          condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified"> 944          condition_to_string ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition));</span>
 945 
 946       return ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition);
 947 
 948     default:
 949       g_assert_not_reached ();
 950       g_abort ();
 951     }
 952 }
 953 
 954 static gboolean
 955 g_io_win32_dispatch (GSource     *source,
<span class="line-modified"> 956              GSourceFunc  callback,</span>
<span class="line-modified"> 957              gpointer     user_data)</span>
 958 {
 959   GIOFunc func = (GIOFunc)callback;
 960   GIOWin32Watch *watch = (GIOWin32Watch *)source;
 961   GIOWin32Channel *channel = (GIOWin32Channel *)watch-&gt;channel;
 962   GIOCondition buffer_condition = g_io_channel_get_buffer_condition (watch-&gt;channel);
 963 
 964   if (!func)
 965     {
 966       g_warning (&quot;IO Watch dispatched without callback. &quot;
<span class="line-modified"> 967          &quot;You must call g_source_connect().&quot;);</span>
 968       return FALSE;
 969     }
 970 
 971   if (channel-&gt;debug)
 972     g_print (&quot;g_io_win32_dispatch: pollfd.revents=%s condition=%s result=%s\n&quot;,
<span class="line-modified"> 973          condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified"> 974          condition_to_string (watch-&gt;condition),</span>
<span class="line-modified"> 975          condition_to_string ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition));</span>
 976 
 977   return (*func) (watch-&gt;channel,
<span class="line-modified"> 978           (watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition,</span>
<span class="line-modified"> 979           user_data);</span>
 980 }
 981 
 982 static void
 983 g_io_win32_finalize (GSource *source)
 984 {
 985   GIOWin32Watch *watch = (GIOWin32Watch *)source;
 986   GIOWin32Channel *channel = (GIOWin32Channel *)watch-&gt;channel;
 987 
 988   if (channel-&gt;debug)
 989     g_print (&quot;g_io_win32_finalize: source=%p channel=%p&quot;, source, channel);
 990 
 991   switch (channel-&gt;type)
 992     {
 993     case G_IO_WIN32_WINDOWS_MESSAGES:
 994       if (channel-&gt;debug)
<span class="line-modified"> 995     g_print (&quot; MSG&quot;);</span>
 996       break;
 997 
 998     case G_IO_WIN32_CONSOLE:
 999       if (channel-&gt;debug)
<span class="line-modified">1000     g_print (&quot; CON&quot;);</span>
1001       break;
1002 
1003     case G_IO_WIN32_FILE_DESC:
1004       if (channel-&gt;debug)
<span class="line-modified">1005     g_print (&quot; FD thread=%#x&quot;, channel-&gt;thread_id);</span>
1006       break;
1007 
1008     case G_IO_WIN32_SOCKET:
1009       if (channel-&gt;debug)
<span class="line-modified">1010     g_print (&quot; SOCK sock=%d&quot;, channel-&gt;fd);</span>
1011       break;
1012 
1013     default:
1014       g_assert_not_reached ();
1015       g_abort ();
1016     }
1017   if (channel-&gt;debug)
1018     g_print (&quot;\n&quot;);
1019   g_io_channel_unref (watch-&gt;channel);
1020 }
1021 
1022 GSourceFuncs g_io_watch_funcs = {
1023   g_io_win32_prepare,
1024   g_io_win32_check,
1025   g_io_win32_dispatch,
1026   g_io_win32_finalize
1027 };
1028 
1029 static GIOStatus
1030 g_io_win32_msg_read (GIOChannel *channel,
<span class="line-modified">1031              gchar      *buf,</span>
<span class="line-modified">1032              gsize       count,</span>
<span class="line-modified">1033              gsize      *bytes_read,</span>
<span class="line-modified">1034              GError    **err)</span>
1035 {
1036   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1037   MSG msg;               /* In case of alignment problems */
1038 
1039   *bytes_read = 0;
1040 
1041   if (count &lt; sizeof (MSG))
1042     {
1043       g_set_error_literal (err, G_IO_CHANNEL_ERROR, G_IO_CHANNEL_ERROR_INVAL,
1044                            &quot;Incorrect message size&quot;); /* Informative enough error message? */
1045       return G_IO_STATUS_ERROR;
1046     }
1047 
1048   if (win32_channel-&gt;debug)
1049     g_print (&quot;g_io_win32_msg_read: channel=%p hwnd=%p\n&quot;,
<span class="line-modified">1050          channel, win32_channel-&gt;hwnd);</span>
1051   if (!PeekMessage (&amp;msg, win32_channel-&gt;hwnd, 0, 0, PM_REMOVE))
1052     return G_IO_STATUS_AGAIN;
1053 
1054   memmove (buf, &amp;msg, sizeof (MSG));
1055   *bytes_read = sizeof (MSG);
1056 
1057   return G_IO_STATUS_NORMAL;
1058 }
1059 
1060 static GIOStatus
1061 g_io_win32_msg_write (GIOChannel  *channel,
<span class="line-modified">1062               const gchar *buf,</span>
<span class="line-modified">1063               gsize        count,</span>
<span class="line-modified">1064               gsize       *bytes_written,</span>
<span class="line-modified">1065               GError     **err)</span>
1066 {
1067   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1068   MSG msg;
1069 
1070   *bytes_written = 0;
1071 
1072   if (count != sizeof (MSG))
1073     {
1074       g_set_error_literal (err, G_IO_CHANNEL_ERROR, G_IO_CHANNEL_ERROR_INVAL,
1075                            &quot;Incorrect message size&quot;); /* Informative enough error message? */
1076       return G_IO_STATUS_ERROR;
1077     }
1078 
1079   /* In case of alignment problems */
1080   memmove (&amp;msg, buf, sizeof (MSG));
1081   if (!PostMessage (win32_channel-&gt;hwnd, msg.message, msg.wParam, msg.lParam))
1082     {
1083       gchar *emsg = g_win32_error_message (GetLastError ());
1084 
1085       g_set_error_literal (err, G_IO_CHANNEL_ERROR, G_IO_CHANNEL_ERROR_FAILED, emsg);
1086       g_free (emsg);
1087 
1088       return G_IO_STATUS_ERROR;
1089     }
1090 
1091   *bytes_written = sizeof (MSG);
1092 
1093   return G_IO_STATUS_NORMAL;
1094 }
1095 
1096 static GIOStatus
1097 g_io_win32_msg_close (GIOChannel *channel,
<span class="line-modified">1098               GError    **err)</span>
1099 {
1100   /* Nothing to be done. Or should we set hwnd to some invalid value? */
1101 
1102   return G_IO_STATUS_NORMAL;
1103 }
1104 
1105 static void
1106 g_io_win32_free (GIOChannel *channel)
1107 {
1108   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1109 
1110   if (win32_channel-&gt;debug)
1111     g_print (&quot;g_io_win32_free channel=%p fd=%d\n&quot;, channel, win32_channel-&gt;fd);
1112 
1113   DeleteCriticalSection (&amp;win32_channel-&gt;mutex);
1114 
1115   if (win32_channel-&gt;data_avail_event)
1116     if (!CloseHandle (win32_channel-&gt;data_avail_event))
1117       if (win32_channel-&gt;debug)
<span class="line-modified">1118     {</span>
<span class="line-modified">1119       gchar *emsg = g_win32_error_message (GetLastError ());</span>
1120 
<span class="line-modified">1121       g_print (&quot;  CloseHandle(%p) failed: %s\n&quot;,</span>
<span class="line-modified">1122            win32_channel-&gt;data_avail_event, emsg);</span>
<span class="line-modified">1123       g_free (emsg);</span>
<span class="line-modified">1124     }</span>
1125 
1126   g_free (win32_channel-&gt;buffer);
1127 
1128   if (win32_channel-&gt;space_avail_event)
1129     if (!CloseHandle (win32_channel-&gt;space_avail_event))
1130       if (win32_channel-&gt;debug)
<span class="line-modified">1131     {</span>
<span class="line-modified">1132       gchar *emsg = g_win32_error_message (GetLastError ());</span>
1133 
<span class="line-modified">1134       g_print (&quot;  CloseHandle(%p) failed: %s\n&quot;,</span>
<span class="line-modified">1135            win32_channel-&gt;space_avail_event, emsg);</span>
<span class="line-modified">1136       g_free (emsg);</span>
<span class="line-modified">1137     }</span>
1138 
1139   if (win32_channel-&gt;type == G_IO_WIN32_SOCKET &amp;&amp;
1140       win32_channel-&gt;fd != -1)
1141     if (WSAEventSelect (win32_channel-&gt;fd, NULL, 0) == SOCKET_ERROR)
1142       if (win32_channel-&gt;debug)
<span class="line-modified">1143     {</span>
<span class="line-modified">1144       gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
1145 
<span class="line-modified">1146       g_print (&quot;  WSAEventSelect(%d,NULL,{}) failed: %s\n&quot;,</span>
<span class="line-modified">1147            win32_channel-&gt;fd, emsg);</span>
<span class="line-modified">1148       g_free (emsg);</span>
<span class="line-modified">1149     }</span>
1150 
1151   if (win32_channel-&gt;event)
1152     if (!WSACloseEvent (win32_channel-&gt;event))
1153       if (win32_channel-&gt;debug)
<span class="line-modified">1154     {</span>
<span class="line-modified">1155       gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
1156 
<span class="line-modified">1157       g_print (&quot;  WSACloseEvent(%p) failed: %s\n&quot;,</span>
<span class="line-modified">1158            win32_channel-&gt;event, emsg);</span>
<span class="line-modified">1159       g_free (emsg);</span>
<span class="line-modified">1160     }</span>
1161 
1162   g_free (win32_channel);
1163 }
1164 
1165 static GSource *
1166 g_io_win32_msg_create_watch (GIOChannel   *channel,
<span class="line-modified">1167                  GIOCondition  condition)</span>
1168 {
1169   GIOWin32Watch *watch;
1170   GSource *source;
1171 
1172   source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
1173   g_source_set_name (source, &quot;GIOChannel (Win32)&quot;);
1174   watch = (GIOWin32Watch *)source;
1175 
1176   watch-&gt;channel = channel;
1177   g_io_channel_ref (channel);
1178 
1179   watch-&gt;condition = condition;
1180 
1181   watch-&gt;pollfd.fd = (gintptr) G_WIN32_MSG_HANDLE;
1182   watch-&gt;pollfd.events = condition;
1183 
1184   g_source_add_poll (source, &amp;watch-&gt;pollfd);
1185 
1186   return source;
1187 }
1188 
1189 static GIOStatus
1190 g_io_win32_fd_and_console_read (GIOChannel *channel,
<span class="line-modified">1191                 gchar      *buf,</span>
<span class="line-modified">1192                 gsize       count,</span>
<span class="line-modified">1193                 gsize      *bytes_read,</span>
<span class="line-modified">1194                 GError    **err)</span>
1195 {
1196   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1197   gint result;
1198   int errsv;
1199 
1200   if (win32_channel-&gt;debug)
1201     g_print (&quot;g_io_win32_fd_read: fd=%d count=%&quot; G_GSIZE_FORMAT &quot;\n&quot;,
<span class="line-modified">1202          win32_channel-&gt;fd, count);</span>
1203 
1204   if (win32_channel-&gt;thread_id)
1205     {
1206       return buffer_read (win32_channel, buf, count, bytes_read, err);
1207     }
1208 
1209   result = read (win32_channel-&gt;fd, buf, count);
1210   errsv = errno;
1211 
1212   if (win32_channel-&gt;debug)
1213     g_print (&quot;g_io_win32_fd_read: read() =&gt; %d\n&quot;, result);
1214 
1215   if (result &lt; 0)
1216     {
1217       *bytes_read = 0;
1218 
1219       switch (errsv)
1220         {
1221 #ifdef EAGAIN
<span class="line-modified">1222     case EAGAIN:</span>
<span class="line-modified">1223       return G_IO_STATUS_AGAIN;</span>
1224 #endif
<span class="line-modified">1225     default:</span>
<span class="line-modified">1226       g_set_error_literal (err, G_IO_CHANNEL_ERROR,</span>
1227                                g_io_channel_error_from_errno (errsv),
1228                                g_strerror (errsv));
<span class="line-modified">1229       return G_IO_STATUS_ERROR;</span>
1230         }
1231     }
1232 
1233   *bytes_read = result;
1234 
1235   return (result &gt; 0) ? G_IO_STATUS_NORMAL : G_IO_STATUS_EOF;
1236 }
1237 
1238 static GIOStatus
1239 g_io_win32_fd_and_console_write (GIOChannel  *channel,
<span class="line-modified">1240                  const gchar *buf,</span>
<span class="line-modified">1241                  gsize        count,</span>
<span class="line-modified">1242                  gsize       *bytes_written,</span>
<span class="line-modified">1243                  GError     **err)</span>
1244 {
1245   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1246   gint result;
1247   int errsv;
1248 
1249   if (win32_channel-&gt;thread_id)
1250     {
1251       return buffer_write (win32_channel, buf, count, bytes_written, err);
1252     }
1253 
1254   result = write (win32_channel-&gt;fd, buf, count);
1255   errsv = errno;
1256 
1257   if (win32_channel-&gt;debug)
1258     g_print (&quot;g_io_win32_fd_write: fd=%d count=%&quot; G_GSIZE_FORMAT &quot; =&gt; %d\n&quot;,
<span class="line-modified">1259          win32_channel-&gt;fd, count, result);</span>
1260 
1261   if (result &lt; 0)
1262     {
1263       *bytes_written = 0;
1264 
1265       switch (errsv)
1266         {
1267 #ifdef EAGAIN
<span class="line-modified">1268     case EAGAIN:</span>
<span class="line-modified">1269       return G_IO_STATUS_AGAIN;</span>
1270 #endif
<span class="line-modified">1271     default:</span>
<span class="line-modified">1272       g_set_error_literal (err, G_IO_CHANNEL_ERROR,</span>
1273                                g_io_channel_error_from_errno (errsv),
1274                                g_strerror (errsv));
<span class="line-modified">1275       return G_IO_STATUS_ERROR;</span>
1276         }
1277     }
1278 
1279   *bytes_written = result;
1280 
1281   return G_IO_STATUS_NORMAL;
1282 }
1283 
1284 static GIOStatus
1285 g_io_win32_fd_seek (GIOChannel *channel,
<span class="line-modified">1286             gint64      offset,</span>
<span class="line-modified">1287             GSeekType   type,</span>
<span class="line-modified">1288             GError    **err)</span>
1289 {
1290   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1291   int whence, errsv;
1292   off_t tmp_offset;
1293   off_t result;
1294 
1295   switch (type)
1296     {
1297     case G_SEEK_SET:
1298       whence = SEEK_SET;
1299       break;
1300     case G_SEEK_CUR:
1301       whence = SEEK_CUR;
1302       break;
1303     case G_SEEK_END:
1304       whence = SEEK_END;
1305       break;
1306     default:
1307       whence = -1; /* Keep the compiler quiet */
1308       g_assert_not_reached ();
</pre>
<hr />
<pre>
1317                            g_strerror (EINVAL));
1318       return G_IO_STATUS_ERROR;
1319     }
1320 
1321   result = lseek (win32_channel-&gt;fd, tmp_offset, whence);
1322   errsv = errno;
1323 
1324   if (result &lt; 0)
1325     {
1326       g_set_error_literal (err, G_IO_CHANNEL_ERROR,
1327                            g_io_channel_error_from_errno (errsv),
1328                            g_strerror (errsv));
1329       return G_IO_STATUS_ERROR;
1330     }
1331 
1332   return G_IO_STATUS_NORMAL;
1333 }
1334 
1335 static GIOStatus
1336 g_io_win32_fd_close (GIOChannel *channel,
<span class="line-modified">1337                  GError    **err)</span>
1338 {
1339   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1340 
1341   if (win32_channel-&gt;debug)
1342     g_print (&quot;g_io_win32_fd_close: thread=%#x: fd=%d\n&quot;,
<span class="line-modified">1343          win32_channel-&gt;thread_id,</span>
<span class="line-modified">1344          win32_channel-&gt;fd);</span>
1345   EnterCriticalSection (&amp;win32_channel-&gt;mutex);
1346   if (win32_channel-&gt;running)
1347     {
1348       if (win32_channel-&gt;debug)
<span class="line-modified">1349     g_print (&quot;thread %#x: running, marking fd %d for later close\n&quot;,</span>
<span class="line-modified">1350          win32_channel-&gt;thread_id, win32_channel-&gt;fd);</span>
1351       win32_channel-&gt;running = FALSE;
1352       win32_channel-&gt;needs_close = TRUE;
1353       if (win32_channel-&gt;direction == 0)
<span class="line-modified">1354     SetEvent (win32_channel-&gt;data_avail_event);</span>
1355       else
<span class="line-modified">1356     SetEvent (win32_channel-&gt;space_avail_event);</span>
1357     }
1358   else
1359     {
1360       if (win32_channel-&gt;debug)
<span class="line-modified">1361     g_print (&quot;closing fd %d\n&quot;, win32_channel-&gt;fd);</span>
1362       close (win32_channel-&gt;fd);
1363       if (win32_channel-&gt;debug)
<span class="line-modified">1364     g_print (&quot;closed fd %d, setting to -1\n&quot;,</span>
<span class="line-modified">1365          win32_channel-&gt;fd);</span>
1366       win32_channel-&gt;fd = -1;
1367     }
1368   LeaveCriticalSection (&amp;win32_channel-&gt;mutex);
1369 
1370   /* FIXME error detection? */
1371 
1372   return G_IO_STATUS_NORMAL;
1373 }
1374 
1375 static GSource *
1376 g_io_win32_fd_create_watch (GIOChannel    *channel,
<span class="line-modified">1377                 GIOCondition   condition)</span>
1378 {
1379   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1380   GSource *source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
1381   GIOWin32Watch *watch = (GIOWin32Watch *)source;
1382 
1383   watch-&gt;channel = channel;
1384   g_io_channel_ref (channel);
1385 
1386   watch-&gt;condition = condition;
1387 
1388   if (win32_channel-&gt;data_avail_event == NULL)
1389     create_events (win32_channel);
1390 
1391   watch-&gt;pollfd.fd = (gintptr) win32_channel-&gt;data_avail_event;
1392   watch-&gt;pollfd.events = condition;
1393 
1394   if (win32_channel-&gt;debug)
1395     g_print (&quot;g_io_win32_fd_create_watch: channel=%p fd=%d condition={%s} event=%p\n&quot;,
<span class="line-modified">1396          channel, win32_channel-&gt;fd,</span>
<span class="line-modified">1397          condition_to_string (condition), (HANDLE) watch-&gt;pollfd.fd);</span>
1398 
1399   EnterCriticalSection (&amp;win32_channel-&gt;mutex);
1400   if (win32_channel-&gt;thread_id == 0)
1401     {
1402       if (condition &amp; G_IO_IN)
<span class="line-modified">1403     create_thread (win32_channel, condition, read_thread);</span>
1404       else if (condition &amp; G_IO_OUT)
<span class="line-modified">1405     create_thread (win32_channel, condition, write_thread);</span>
1406     }
1407 
1408   g_source_add_poll (source, &amp;watch-&gt;pollfd);
1409   LeaveCriticalSection (&amp;win32_channel-&gt;mutex);
1410 
1411   return source;
1412 }
1413 
1414 static GIOStatus
1415 g_io_win32_console_close (GIOChannel *channel,
<span class="line-modified">1416                   GError    **err)</span>
1417 {
1418   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1419 
1420   if (close (win32_channel-&gt;fd) &lt; 0)
1421     {
1422       int errsv = errno;
1423       g_set_error_literal (err, G_IO_CHANNEL_ERROR,
1424                            g_io_channel_error_from_errno (errsv),
1425                            g_strerror (errsv));
1426       return G_IO_STATUS_ERROR;
1427     }
1428 
1429   return G_IO_STATUS_NORMAL;
1430 }
1431 
1432 static GSource *
1433 g_io_win32_console_create_watch (GIOChannel    *channel,
<span class="line-modified">1434                  GIOCondition   condition)</span>
1435 {
1436   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1437   GSource *source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
1438   GIOWin32Watch *watch = (GIOWin32Watch *)source;
1439 
1440   watch-&gt;channel = channel;
1441   g_io_channel_ref (channel);
1442 
1443   watch-&gt;condition = condition;
1444 
1445   watch-&gt;pollfd.fd = _get_osfhandle (win32_channel-&gt;fd);
1446   watch-&gt;pollfd.events = condition;
1447 
1448   g_source_add_poll (source, &amp;watch-&gt;pollfd);
1449 
1450   return source;
1451 }
1452 
1453 static GIOStatus
1454 g_io_win32_sock_read (GIOChannel *channel,
<span class="line-modified">1455               gchar      *buf,</span>
<span class="line-modified">1456               gsize       count,</span>
<span class="line-modified">1457               gsize      *bytes_read,</span>
<span class="line-modified">1458               GError    **err)</span>
1459 {
1460   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1461   gint result;
1462   GIOChannelError error;
1463   int winsock_error;
1464 
1465   if (win32_channel-&gt;debug)
1466     g_print (&quot;g_io_win32_sock_read: channel=%p sock=%d count=%&quot; G_GSIZE_FORMAT,
<span class="line-modified">1467          channel, win32_channel-&gt;fd, count);</span>
1468 
1469   result = recv (win32_channel-&gt;fd, buf, count, 0);
1470   if (result == SOCKET_ERROR)
1471     winsock_error = WSAGetLastError ();
1472 
1473   if (win32_channel-&gt;debug)
1474     g_print (&quot; recv=%d&quot;, result);
1475 
1476   if (result == SOCKET_ERROR)
1477     {
1478       gchar *emsg = g_win32_error_message (winsock_error);
1479 
1480       if (win32_channel-&gt;debug)
<span class="line-modified">1481     g_print (&quot; %s\n&quot;, emsg);</span>
1482 
1483       *bytes_read = 0;
1484 
1485       switch (winsock_error)
<span class="line-modified">1486     {</span>
<span class="line-modified">1487     case WSAEINVAL:</span>
1488           error = G_IO_CHANNEL_ERROR_INVAL;
1489           break;
<span class="line-modified">1490     case WSAEWOULDBLOCK:</span>
<span class="line-modified">1491       g_free (emsg);</span>
1492           return G_IO_STATUS_AGAIN;
<span class="line-modified">1493     default:</span>
<span class="line-modified">1494       error = G_IO_CHANNEL_ERROR_FAILED;</span>
1495           break;
<span class="line-modified">1496     }</span>
1497       g_set_error_literal (err, G_IO_CHANNEL_ERROR, error, emsg);
1498       g_free (emsg);
1499 
1500       return G_IO_STATUS_ERROR;
1501     }
1502   else
1503     {
1504       if (win32_channel-&gt;debug)
<span class="line-modified">1505     g_print (&quot;\n&quot;);</span>
1506       *bytes_read = result;
1507       if (result == 0)
<span class="line-modified">1508     return G_IO_STATUS_EOF;</span>
1509       else
<span class="line-modified">1510     return G_IO_STATUS_NORMAL;</span>
1511     }
1512 }
1513 
1514 static GIOStatus
1515 g_io_win32_sock_write (GIOChannel  *channel,
<span class="line-modified">1516                const gchar *buf,</span>
<span class="line-modified">1517                gsize        count,</span>
<span class="line-modified">1518                gsize       *bytes_written,</span>
<span class="line-modified">1519                GError     **err)</span>
1520 {
1521   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1522   gint result;
1523   GIOChannelError error;
1524   int winsock_error;
1525 
1526   if (win32_channel-&gt;debug)
1527     g_print (&quot;g_io_win32_sock_write: channel=%p sock=%d count=%&quot; G_GSIZE_FORMAT,
<span class="line-modified">1528          channel, win32_channel-&gt;fd, count);</span>
1529 
1530   result = send (win32_channel-&gt;fd, buf, count, 0);
1531   if (result == SOCKET_ERROR)
1532     winsock_error = WSAGetLastError ();
1533 
1534   if (win32_channel-&gt;debug)
1535     g_print (&quot; send=%d&quot;, result);
1536 
1537   if (result == SOCKET_ERROR)
1538     {
1539       gchar *emsg = g_win32_error_message (winsock_error);
1540 
1541       if (win32_channel-&gt;debug)
<span class="line-modified">1542     g_print (&quot; %s\n&quot;, emsg);</span>
1543 
1544       *bytes_written = 0;
1545 
1546       switch (winsock_error)
<span class="line-modified">1547     {</span>
<span class="line-modified">1548     case WSAEINVAL:</span>
<span class="line-modified">1549       error = G_IO_CHANNEL_ERROR_INVAL;</span>
1550           break;
<span class="line-modified">1551     case WSAEWOULDBLOCK:</span>
<span class="line-modified">1552       win32_channel-&gt;write_would_have_blocked = TRUE;</span>
<span class="line-modified">1553       win32_channel-&gt;last_events = 0;</span>
<span class="line-modified">1554       g_free (emsg);</span>
1555           return G_IO_STATUS_AGAIN;
<span class="line-modified">1556     default:</span>
<span class="line-modified">1557       error = G_IO_CHANNEL_ERROR_FAILED;</span>
1558           break;
<span class="line-modified">1559     }</span>
1560       g_set_error_literal (err, G_IO_CHANNEL_ERROR, error, emsg);
1561       g_free (emsg);
1562 
1563       return G_IO_STATUS_ERROR;
1564     }
1565   else
1566     {
1567       if (win32_channel-&gt;debug)
<span class="line-modified">1568     g_print (&quot;\n&quot;);</span>
1569       *bytes_written = result;
1570       win32_channel-&gt;write_would_have_blocked = FALSE;
1571 
1572       return G_IO_STATUS_NORMAL;
1573     }
1574 }
1575 
1576 static GIOStatus
1577 g_io_win32_sock_close (GIOChannel *channel,
<span class="line-modified">1578                GError    **err)</span>
1579 {
1580   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1581 
1582   if (win32_channel-&gt;fd != -1)
1583     {
1584       if (win32_channel-&gt;debug)
<span class="line-modified">1585     g_print (&quot;g_io_win32_sock_close: channel=%p sock=%d\n&quot;,</span>
<span class="line-modified">1586          channel, win32_channel-&gt;fd);</span>
1587 
1588       closesocket (win32_channel-&gt;fd);
1589       win32_channel-&gt;fd = -1;
1590     }
1591 
1592   /* FIXME error detection? */
1593 
1594   return G_IO_STATUS_NORMAL;
1595 }
1596 
1597 static GSource *
1598 g_io_win32_sock_create_watch (GIOChannel    *channel,
<span class="line-modified">1599                   GIOCondition   condition)</span>
1600 {
1601   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1602   GSource *source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
1603   GIOWin32Watch *watch = (GIOWin32Watch *)source;
1604 
1605   watch-&gt;channel = channel;
1606   g_io_channel_ref (channel);
1607 
1608   watch-&gt;condition = condition;
1609 
1610   if (win32_channel-&gt;event == 0)
1611     win32_channel-&gt;event = WSACreateEvent ();
1612 
1613   watch-&gt;pollfd.fd = (gintptr) win32_channel-&gt;event;
1614   watch-&gt;pollfd.events = condition;
1615 
1616   if (win32_channel-&gt;debug)
1617     g_print (&quot;g_io_win32_sock_create_watch: channel=%p sock=%d event=%p condition={%s}\n&quot;,
<span class="line-modified">1618          channel, win32_channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd,</span>
<span class="line-modified">1619          condition_to_string (watch-&gt;condition));</span>
1620 
1621   g_source_add_poll (source, &amp;watch-&gt;pollfd);
1622 
1623   return source;
1624 }
1625 
1626 GIOChannel *
1627 g_io_channel_new_file (const gchar  *filename,
1628                        const gchar  *mode,
1629                        GError      **error)
1630 {
1631   int fid, flags, pmode;
1632   GIOChannel *channel;
1633 
1634   enum { /* Cheesy hack */
1635     MODE_R = 1 &lt;&lt; 0,
1636     MODE_W = 1 &lt;&lt; 1,
1637     MODE_A = 1 &lt;&lt; 2,
1638     MODE_PLUS = 1 &lt;&lt; 3,
1639   };
</pre>
<hr />
<pre>
1746         channel-&gt;is_writeable = FALSE;
1747         break;
1748       case MODE_W:
1749       case MODE_A:
1750         channel-&gt;is_readable = FALSE;
1751         break;
1752       case MODE_R | MODE_PLUS:
1753       case MODE_W | MODE_PLUS:
1754       case MODE_A | MODE_PLUS:
1755         break;
1756       default:
1757         g_assert_not_reached ();
1758         g_abort ();
1759     }
1760 
1761   return channel;
1762 }
1763 
1764 static GIOStatus
1765 g_io_win32_unimpl_set_flags (GIOChannel *channel,
<span class="line-modified">1766                  GIOFlags    flags,</span>
<span class="line-modified">1767                  GError    **err)</span>
1768 {
1769   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1770 
1771   if (win32_channel-&gt;debug)
1772     {
1773       g_print (&quot;g_io_win32_unimpl_set_flags: &quot;);
1774       g_win32_print_gioflags (flags);
1775       g_print (&quot;\n&quot;);
1776     }
1777 
1778   g_set_error_literal (err, G_IO_CHANNEL_ERROR,
1779                        G_IO_CHANNEL_ERROR_FAILED,
1780                        &quot;Not implemented on Win32&quot;);
1781 
1782   return G_IO_STATUS_ERROR;
1783 }
1784 
1785 static GIOFlags
1786 g_io_win32_fd_get_flags_internal (GIOChannel      *channel,
<span class="line-modified">1787                   struct _stati64 *st)</span>
1788 {
1789   GIOWin32Channel *win32_channel = (GIOWin32Channel *) channel;
1790   gchar c;
1791   DWORD count;
1792 
1793   if (st-&gt;st_mode &amp; _S_IFIFO)
1794     {
1795       channel-&gt;is_readable =
<span class="line-modified">1796     (PeekNamedPipe ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL, NULL) != 0) || GetLastError () == ERROR_BROKEN_PIPE;</span>
1797       channel-&gt;is_writeable =
<span class="line-modified">1798     (WriteFile ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL) != 0);</span>
1799       channel-&gt;is_seekable  = FALSE;
1800     }
1801   else
1802     {
1803       channel-&gt;is_readable =
<span class="line-modified">1804     (ReadFile ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL) != 0);</span>
1805       channel-&gt;is_writeable =
<span class="line-modified">1806     (WriteFile ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL) != 0);</span>
1807       channel-&gt;is_seekable = TRUE;
1808     }
1809 
1810   /* XXX: G_IO_FLAG_APPEND */
1811   /* XXX: G_IO_FLAG_NONBLOCK */
1812 
1813   return 0;
1814 }
1815 
1816 static GIOFlags
1817 g_io_win32_fd_get_flags (GIOChannel *channel)
1818 {
1819   struct _stati64 st;
1820   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1821 
1822   g_return_val_if_fail (win32_channel != NULL, 0);
1823   g_return_val_if_fail (win32_channel-&gt;type == G_IO_WIN32_FILE_DESC, 0);
1824 
1825   if (0 == _fstati64 (win32_channel-&gt;fd, &amp;st))
1826     return g_io_win32_fd_get_flags_internal (channel, &amp;st);
</pre>
<hr />
<pre>
1846 
1847 static GIOFlags
1848 g_io_win32_console_get_flags (GIOChannel *channel)
1849 {
1850   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1851 
1852   g_return_val_if_fail (win32_channel != NULL, 0);
1853   g_return_val_if_fail (win32_channel-&gt;type == G_IO_WIN32_CONSOLE, 0);
1854 
1855   return g_io_win32_console_get_flags_internal (channel);
1856 }
1857 
1858 static GIOFlags
1859 g_io_win32_msg_get_flags (GIOChannel *channel)
1860 {
1861   return 0;
1862 }
1863 
1864 static GIOStatus
1865 g_io_win32_sock_set_flags (GIOChannel *channel,
<span class="line-modified">1866                GIOFlags    flags,</span>
<span class="line-modified">1867                GError    **err)</span>
1868 {
1869   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1870   u_long arg;
1871 
1872   if (win32_channel-&gt;debug)
1873     {
1874       g_print (&quot;g_io_win32_sock_set_flags: &quot;);
1875       g_win32_print_gioflags (flags);
1876       g_print (&quot;\n&quot;);
1877     }
1878 
1879   if (flags &amp; G_IO_FLAG_NONBLOCK)
1880     {
1881       arg = 1;
1882       if (ioctlsocket (win32_channel-&gt;fd, FIONBIO, &amp;arg) == SOCKET_ERROR)
<span class="line-modified">1883     {</span>
<span class="line-modified">1884       gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
1885 
<span class="line-modified">1886       g_set_error_literal (err, G_IO_CHANNEL_ERROR,</span>
<span class="line-modified">1887                    G_IO_CHANNEL_ERROR_FAILED,</span>
<span class="line-modified">1888                    emsg);</span>
<span class="line-modified">1889       g_free (emsg);</span>
1890 
<span class="line-modified">1891       return G_IO_STATUS_ERROR;</span>
<span class="line-modified">1892     }</span>
1893     }
1894   else
1895     {
1896       arg = 0;
1897       if (ioctlsocket (win32_channel-&gt;fd, FIONBIO, &amp;arg) == SOCKET_ERROR)
<span class="line-modified">1898     {</span>
<span class="line-modified">1899       gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
1900 
<span class="line-modified">1901       g_set_error_literal (err, G_IO_CHANNEL_ERROR,</span>
<span class="line-modified">1902                    G_IO_CHANNEL_ERROR_FAILED,</span>
<span class="line-modified">1903                    emsg);</span>
<span class="line-modified">1904       g_free (emsg);</span>
1905 
<span class="line-modified">1906       return G_IO_STATUS_ERROR;</span>
<span class="line-modified">1907     }</span>
1908     }
1909 
1910   return G_IO_STATUS_NORMAL;
1911 }
1912 
1913 static GIOFlags
1914 g_io_win32_sock_get_flags (GIOChannel *channel)
1915 {
1916   /* Could we do something here? */
1917   return 0;
1918 }
1919 
1920 static GIOFuncs win32_channel_msg_funcs = {
1921   g_io_win32_msg_read,
1922   g_io_win32_msg_write,
1923   NULL,
1924   g_io_win32_msg_close,
1925   g_io_win32_msg_create_watch,
1926   g_io_win32_free,
1927   g_io_win32_unimpl_set_flags,
</pre>
<hr />
<pre>
1969  *
1970  * This function creates a #GIOChannel that can be used to poll for
1971  * Windows messages for the window in question.
1972  *
1973  * Returns: a new #GIOChannel.
1974  **/
1975 GIOChannel *
1976 #if GLIB_SIZEOF_VOID_P == 8
1977 g_io_channel_win32_new_messages (gsize hwnd)
1978 #else
1979 g_io_channel_win32_new_messages (guint hwnd)
1980 #endif
1981 {
1982   GIOWin32Channel *win32_channel = g_new (GIOWin32Channel, 1);
1983   GIOChannel *channel = (GIOChannel *)win32_channel;
1984 
1985   g_io_channel_init (channel);
1986   g_io_channel_win32_init (win32_channel);
1987   if (win32_channel-&gt;debug)
1988     g_print (&quot;g_io_channel_win32_new_messages: channel=%p hwnd=%p\n&quot;,
<span class="line-modified">1989          channel, (HWND) hwnd);</span>
1990   channel-&gt;funcs = &amp;win32_channel_msg_funcs;
1991   win32_channel-&gt;type = G_IO_WIN32_WINDOWS_MESSAGES;
1992   win32_channel-&gt;hwnd = (HWND) hwnd;
1993 
1994   /* XXX: check this. */
1995   channel-&gt;is_readable = IsWindow (win32_channel-&gt;hwnd);
1996   channel-&gt;is_writeable = IsWindow (win32_channel-&gt;hwnd);
1997 
1998   channel-&gt;is_seekable = FALSE;
1999 
2000   return channel;
2001 }
2002 
2003 static GIOChannel *
2004 g_io_channel_win32_new_fd_internal (gint             fd,
<span class="line-modified">2005                     struct _stati64 *st)</span>
2006 {
2007   GIOWin32Channel *win32_channel;
2008   GIOChannel *channel;
2009 
2010   win32_channel = g_new (GIOWin32Channel, 1);
2011   channel = (GIOChannel *)win32_channel;
2012 
2013   g_io_channel_init (channel);
2014   g_io_channel_win32_init (win32_channel);
2015 
2016   win32_channel-&gt;fd = fd;
2017 
2018   if (win32_channel-&gt;debug)
2019     g_print (&quot;g_io_channel_win32_new_fd: channel=%p fd=%u\n&quot;,
<span class="line-modified">2020          channel, fd);</span>
2021 
2022   if (st-&gt;st_mode &amp; _S_IFCHR) /* console */
2023     {
2024       channel-&gt;funcs = &amp;win32_channel_console_funcs;
2025       win32_channel-&gt;type = G_IO_WIN32_CONSOLE;
2026       g_io_win32_console_get_flags_internal (channel);
2027     }
2028   else
2029     {
2030       channel-&gt;funcs = &amp;win32_channel_fd_funcs;
2031       win32_channel-&gt;type = G_IO_WIN32_FILE_DESC;
2032       g_io_win32_fd_get_flags_internal (channel, st);
2033     }
2034 
2035   return channel;
2036 }
2037 
2038 /**
2039  * g_io_channel_win32_new_fd:
2040  * @fd: a C library file descriptor.
</pre>
<hr />
<pre>
2094  *
2095  * This function works for sockets created by Winsock. It&#39;s available
2096  * only in GLib on Windows.
2097  *
2098  * Polling a #GSource created to watch a channel for a socket puts the
2099  * socket in non-blocking mode. This is a side-effect of the
2100  * implementation and unavoidable.
2101  *
2102  * Returns: a new #GIOChannel
2103  **/
2104 GIOChannel *
2105 g_io_channel_win32_new_socket (int socket)
2106 {
2107   GIOWin32Channel *win32_channel = g_new (GIOWin32Channel, 1);
2108   GIOChannel *channel = (GIOChannel *)win32_channel;
2109 
2110   g_io_channel_init (channel);
2111   g_io_channel_win32_init (win32_channel);
2112   if (win32_channel-&gt;debug)
2113     g_print (&quot;g_io_channel_win32_new_socket: channel=%p sock=%d\n&quot;,
<span class="line-modified">2114          channel, socket);</span>
2115   channel-&gt;funcs = &amp;win32_channel_sock_funcs;
2116   win32_channel-&gt;type = G_IO_WIN32_SOCKET;
2117   win32_channel-&gt;fd = socket;
2118 
2119   channel-&gt;is_readable = TRUE;
2120   channel-&gt;is_writeable = TRUE;
2121   channel-&gt;is_seekable = FALSE;
2122 
2123   return channel;
2124 }
2125 
2126 GIOChannel *
2127 g_io_channel_unix_new (gint fd)
2128 {
2129   gboolean is_fd, is_socket;
2130   struct _stati64 st;
2131   int optval, optlen;
2132 
2133   is_fd = (_fstati64 (fd, &amp;st) == 0);
2134 
</pre>
<hr />
<pre>
2140 
2141   if (is_fd)
2142     return g_io_channel_win32_new_fd_internal (fd, &amp;st);
2143 
2144   if (is_socket)
2145     return g_io_channel_win32_new_socket(fd);
2146 
2147   g_warning (&quot;g_io_channel_unix_new: %d is neither a file descriptor or a socket.&quot;, fd);
2148 
2149   return NULL;
2150 }
2151 
2152 gint
2153 g_io_channel_unix_get_fd (GIOChannel *channel)
2154 {
2155   return g_io_channel_win32_get_fd (channel);
2156 }
2157 
2158 void
2159 g_io_channel_win32_set_debug (GIOChannel *channel,
<span class="line-modified">2160                   gboolean    flag)</span>
2161 {
2162   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
2163 
2164   win32_channel-&gt;debug = flag;
2165 }
2166 
2167 gint
2168 g_io_channel_win32_poll (GPollFD *fds,
<span class="line-modified">2169              gint     n_fds,</span>
<span class="line-modified">2170              gint     timeout)</span>
2171 {
2172   g_return_val_if_fail (n_fds &gt;= 0, 0);
2173 
2174   return g_poll (fds, n_fds, timeout);
2175 }
2176 
2177 void
2178 g_io_channel_win32_make_pollfd (GIOChannel   *channel,
<span class="line-modified">2179                 GIOCondition  condition,</span>
<span class="line-modified">2180                 GPollFD      *fd)</span>
2181 {
2182   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
2183 
2184   switch (win32_channel-&gt;type)
2185     {
2186     case G_IO_WIN32_FILE_DESC:
2187       if (win32_channel-&gt;data_avail_event == NULL)
<span class="line-modified">2188     create_events (win32_channel);</span>
2189 
2190       fd-&gt;fd = (gintptr) win32_channel-&gt;data_avail_event;
2191 
2192       if (win32_channel-&gt;thread_id == 0)
<span class="line-modified">2193     {</span>
<span class="line-modified">2194       /* Is it meaningful for a file descriptor to be polled for</span>
<span class="line-modified">2195        * both IN and OUT? For what kind of file descriptor would</span>
<span class="line-modified">2196        * that be? Doesn&#39;t seem to make sense, in practise the file</span>
<span class="line-modified">2197        * descriptors handled here are always read or write ends of</span>
<span class="line-modified">2198        * pipes surely, and thus unidirectional.</span>
<span class="line-modified">2199        */</span>
<span class="line-modified">2200       if (condition &amp; G_IO_IN)</span>
<span class="line-modified">2201         create_thread (win32_channel, condition, read_thread);</span>
<span class="line-modified">2202       else if (condition &amp; G_IO_OUT)</span>
<span class="line-modified">2203         create_thread (win32_channel, condition, write_thread);</span>
<span class="line-modified">2204     }</span>
2205       break;
2206 
2207     case G_IO_WIN32_CONSOLE:
2208       fd-&gt;fd = _get_osfhandle (win32_channel-&gt;fd);
2209       break;
2210 
2211     case G_IO_WIN32_SOCKET:
2212       fd-&gt;fd = (gintptr) WSACreateEvent ();
2213       break;
2214 
2215     case G_IO_WIN32_WINDOWS_MESSAGES:
2216       fd-&gt;fd = G_WIN32_MSG_HANDLE;
2217       break;
2218 
2219     default:
2220       g_assert_not_reached ();
2221       g_abort ();
2222     }
2223 
2224   fd-&gt;events = condition;
</pre>
</td>
<td>
<hr />
<pre>
  74 #include &lt;windows.h&gt;
  75 #include &lt;conio.h&gt;
  76 #include &lt;fcntl.h&gt;
  77 #include &lt;io.h&gt;
  78 #include &lt;process.h&gt;
  79 #include &lt;errno.h&gt;
  80 #include &lt;sys/stat.h&gt;
  81 
  82 #include &quot;gstdio.h&quot;
  83 #include &quot;glibintl.h&quot;
  84 
  85 
  86 typedef struct _GIOWin32Channel GIOWin32Channel;
  87 typedef struct _GIOWin32Watch GIOWin32Watch;
  88 
  89 #define BUFFER_SIZE 4096
  90 
  91 typedef enum {
  92   G_IO_WIN32_WINDOWS_MESSAGES,  /* Windows messages */
  93 
<span class="line-modified">  94   G_IO_WIN32_FILE_DESC,   /* Unix-like file descriptors from</span>
<span class="line-modified">  95          * _open() or _pipe(), except for</span>
<span class="line-modified">  96          * console IO. Separate thread to read</span>
<span class="line-modified">  97          * or write.</span>
<span class="line-modified">  98          */</span>
  99 
<span class="line-modified"> 100   G_IO_WIN32_CONSOLE,   /* Console IO (usually stdin, stdout, stderr) */</span>
 101 
<span class="line-modified"> 102   G_IO_WIN32_SOCKET   /* Sockets. No separate thread. */</span>
 103 } GIOWin32ChannelType;
 104 
 105 struct _GIOWin32Channel {
 106   GIOChannel channel;
<span class="line-modified"> 107   gint fd;      /* Either a Unix-like file handle as provided</span>
<span class="line-modified"> 108          * by the Microsoft C runtime, or a SOCKET</span>
<span class="line-modified"> 109          * as provided by WinSock.</span>
<span class="line-modified"> 110          */</span>
 111   GIOWin32ChannelType type;
 112 
 113   gboolean debug;
 114 
 115   /* Field used by G_IO_WIN32_WINDOWS_MESSAGES channels */
<span class="line-modified"> 116   HWND hwnd;      /* Handle of window, or NULL */</span>
 117 
 118   /* Fields used by G_IO_WIN32_FILE_DESC channels. */
 119   CRITICAL_SECTION mutex;
 120 
<span class="line-modified"> 121   int direction;    /* 0 means we read from it,</span>
<span class="line-modified"> 122          * 1 means we write to it.</span>
<span class="line-modified"> 123          */</span>
 124 
<span class="line-modified"> 125   gboolean running;   /* Is reader or writer thread</span>
<span class="line-modified"> 126          * running. FALSE if EOF has been</span>
<span class="line-modified"> 127          * reached by the reader thread.</span>
<span class="line-modified"> 128          */</span>
 129 
<span class="line-modified"> 130   gboolean needs_close;   /* If the channel has been closed while</span>
<span class="line-modified"> 131          * the reader thread was still running.</span>
<span class="line-modified"> 132          */</span>
 133 
<span class="line-modified"> 134   guint thread_id;    /* If non-NULL the channel has or has</span>
<span class="line-modified"> 135          * had a reader or writer thread.</span>
<span class="line-modified"> 136          */</span>
 137   HANDLE data_avail_event;
 138 
 139   gushort revents;
 140 
 141   /* Data is kept in a circular buffer. To be able to distinguish between
 142    * empty and full buffers, we cannot fill it completely, but have to
 143    * leave a one character gap.
 144    *
 145    * Data available is between indexes rdp and wrp-1 (modulo BUFFER_SIZE).
 146    *
 147    * Empty:    wrp == rdp
 148    * Full:     (wrp + 1) % BUFFER_SIZE == rdp
 149    * Partial:  otherwise
 150    */
<span class="line-modified"> 151   guchar *buffer;   /* (Circular) buffer */</span>
<span class="line-modified"> 152   gint wrp, rdp;    /* Buffer indices for writing and reading */</span>
 153   HANDLE space_avail_event;
 154 
 155   /* Fields used by G_IO_WIN32_SOCKET channels */
 156   int event_mask;
 157   int last_events;
 158   HANDLE event;
 159   gboolean write_would_have_blocked;
 160   gboolean ever_writable;
 161 };
 162 
 163 struct _GIOWin32Watch {
 164   GSource       source;
 165   GPollFD       pollfd;
 166   GIOChannel   *channel;
 167   GIOCondition  condition;
 168 };
 169 
 170 static void
 171 g_win32_print_access_mode (int flags)
 172 {
 173   g_print (&quot;%s%s%s%s%s%s%s%s%s%s&quot;,
<span class="line-modified"> 174      ((flags &amp; 0x3) == _O_RDWR ? &quot;O_RDWR&quot; :</span>
<span class="line-modified"> 175       ((flags &amp; 0x3) == _O_RDONLY ? &quot;O_RDONLY&quot; :</span>
<span class="line-modified"> 176        ((flags &amp; 0x3) == _O_WRONLY ? &quot;O_WRONLY&quot; : &quot;0&quot;))),</span>
<span class="line-modified"> 177      (flags &amp; _O_APPEND ? &quot;|O_APPEND&quot; : &quot;&quot;),</span>
<span class="line-modified"> 178      (flags &amp; _O_RANDOM ? &quot;|O_RANDOM&quot; : &quot;&quot;),</span>
<span class="line-modified"> 179      (flags &amp; _O_SEQUENTIAL ? &quot;|O_SEQUENTIAL&quot; : &quot;&quot;),</span>
<span class="line-modified"> 180      (flags &amp; _O_TEMPORARY ? &quot;|O_TEMPORARY&quot; : &quot;&quot;),</span>
<span class="line-modified"> 181      (flags &amp; _O_CREAT ? &quot;|O_CREAT&quot; : &quot;&quot;),</span>
<span class="line-modified"> 182      (flags &amp; _O_TRUNC ? &quot;|O_TRUNC&quot; : &quot;&quot;),</span>
<span class="line-modified"> 183      (flags &amp; _O_EXCL ? &quot;|O_EXCL&quot; : &quot;&quot;),</span>
<span class="line-modified"> 184      (flags &amp; _O_TEXT ? &quot;|O_TEXT&quot; : &quot;&quot;),</span>
<span class="line-modified"> 185      (flags &amp; _O_BINARY ? &quot;|O_BINARY&quot; : &quot;&quot;));</span>
 186 }
 187 
 188 static void
 189 g_win32_print_gioflags (GIOFlags flags)
 190 {
 191   char *bar = &quot;&quot;;
 192 
 193   if (flags &amp; G_IO_FLAG_APPEND)
 194     bar = &quot;|&quot;, g_print (&quot;APPEND&quot;);
 195   if (flags &amp; G_IO_FLAG_NONBLOCK)
 196     g_print (&quot;%sNONBLOCK&quot;, bar), bar = &quot;|&quot;;
 197   if (flags &amp; G_IO_FLAG_IS_READABLE)
 198     g_print (&quot;%sREADABLE&quot;, bar), bar = &quot;|&quot;;
 199   if (flags &amp; G_IO_FLAG_IS_WRITABLE)
 200     g_print (&quot;%sWRITABLE&quot;, bar), bar = &quot;|&quot;;
 201   if (flags &amp; G_IO_FLAG_IS_SEEKABLE)
 202     g_print (&quot;%sSEEKABLE&quot;, bar), bar = &quot;|&quot;;
 203 }
 204 
 205 static const char *
</pre>
<hr />
<pre>
 211 
 212   if (mask == 0)
 213     return &quot;&quot;;
 214 
 215 #define BIT(n) checked_bits |= FD_##n; if (mask &amp; FD_##n) bufp += sprintf (bufp, &quot;%s&quot; #n, (bufp&gt;buf ? &quot;|&quot; : &quot;&quot;))
 216 
 217   BIT (READ);
 218   BIT (WRITE);
 219   BIT (OOB);
 220   BIT (ACCEPT);
 221   BIT (CONNECT);
 222   BIT (CLOSE);
 223   BIT (QOS);
 224   BIT (GROUP_QOS);
 225   BIT (ROUTING_INTERFACE_CHANGE);
 226   BIT (ADDRESS_LIST_CHANGE);
 227 
 228 #undef BIT
 229 
 230   if ((mask &amp; ~checked_bits) != 0)
<span class="line-modified"> 231     bufp += sprintf (bufp, &quot;|%#x&quot;, mask &amp; ~checked_bits);</span>
 232 
 233   return g_quark_to_string (g_quark_from_string (buf));
 234 }
 235 
 236 static const char *
 237 condition_to_string (GIOCondition condition)
 238 {
 239   char buf[100];
 240   int checked_bits = 0;
 241   char *bufp = buf;
 242 
 243   if (condition == 0)
 244     return &quot;&quot;;
 245 
 246 #define BIT(n) checked_bits |= G_IO_##n; if (condition &amp; G_IO_##n) bufp += sprintf (bufp, &quot;%s&quot; #n, (bufp&gt;buf ? &quot;|&quot; : &quot;&quot;))
 247 
 248   BIT (IN);
 249   BIT (OUT);
 250   BIT (PRI);
 251   BIT (ERR);
 252   BIT (HUP);
 253   BIT (NVAL);
 254 
 255 #undef BIT
 256 
 257   if ((condition &amp; ~checked_bits) != 0)
<span class="line-modified"> 258     bufp += sprintf (bufp, &quot;|%#x&quot;, condition &amp; ~checked_bits);</span>
 259 
 260   return g_quark_to_string (g_quark_from_string (buf));
 261 }
 262 
 263 static gboolean
 264 g_io_win32_get_debug_flag (void)
 265 {
 266   return (getenv (&quot;G_IO_WIN32_DEBUG&quot;) != NULL);
 267 }
 268 
 269 static void
 270 g_io_channel_win32_init (GIOWin32Channel *channel)
 271 {
 272   channel-&gt;debug = g_io_win32_get_debug_flag ();
 273 
 274   InitializeCriticalSection (&amp;channel-&gt;mutex);
 275   channel-&gt;running = FALSE;
 276   channel-&gt;needs_close = FALSE;
 277   channel-&gt;thread_id = 0;
 278   channel-&gt;data_avail_event = NULL;
</pre>
<hr />
<pre>
 303       || !(channel-&gt;space_avail_event = CreateEvent (&amp;sec_attrs, FALSE, FALSE, NULL)))
 304     {
 305       gchar *emsg = g_win32_error_message (GetLastError ());
 306 
 307       g_error (&quot;Error creating event: %s&quot;, emsg);
 308       g_free (emsg);
 309     }
 310 }
 311 
 312 static unsigned __stdcall
 313 read_thread (void *parameter)
 314 {
 315   GIOWin32Channel *channel = parameter;
 316   guchar *buffer;
 317   gint nbytes;
 318 
 319   g_io_channel_ref ((GIOChannel *)channel);
 320 
 321   if (channel-&gt;debug)
 322     g_print (&quot;read_thread %#x: start fd=%d, data_avail=%p space_avail=%p\n&quot;,
<span class="line-modified"> 323        channel-&gt;thread_id,</span>
<span class="line-modified"> 324        channel-&gt;fd,</span>
<span class="line-modified"> 325        channel-&gt;data_avail_event,</span>
<span class="line-modified"> 326        channel-&gt;space_avail_event);</span>
 327 
 328   channel-&gt;direction = 0;
 329   channel-&gt;buffer = g_malloc (BUFFER_SIZE);
 330   channel-&gt;rdp = channel-&gt;wrp = 0;
 331   channel-&gt;running = TRUE;
 332 
 333   SetEvent (channel-&gt;space_avail_event);
 334 
 335   EnterCriticalSection (&amp;channel-&gt;mutex);
 336   while (channel-&gt;running)
 337     {
 338       if (channel-&gt;debug)
<span class="line-modified"> 339   g_print (&quot;read_thread %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified"> 340      channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
 341       if ((channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)
<span class="line-modified"> 342   {</span>
<span class="line-modified"> 343     /* Buffer is full */</span>
<span class="line-modified"> 344     if (channel-&gt;debug)</span>
<span class="line-modified"> 345       g_print (&quot;read_thread %#x: resetting space_avail\n&quot;,</span>
<span class="line-modified"> 346          channel-&gt;thread_id);</span>
<span class="line-modified"> 347     ResetEvent (channel-&gt;space_avail_event);</span>
<span class="line-modified"> 348     if (channel-&gt;debug)</span>
<span class="line-modified"> 349       g_print (&quot;read_thread %#x: waiting for space\n&quot;,</span>
<span class="line-modified"> 350          channel-&gt;thread_id);</span>
<span class="line-modified"> 351     LeaveCriticalSection (&amp;channel-&gt;mutex);</span>
<span class="line-modified"> 352     WaitForSingleObject (channel-&gt;space_avail_event, INFINITE);</span>
<span class="line-modified"> 353     EnterCriticalSection (&amp;channel-&gt;mutex);</span>
<span class="line-modified"> 354     if (channel-&gt;debug)</span>
<span class="line-modified"> 355       g_print (&quot;read_thread %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified"> 356          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
<span class="line-modified"> 357   }</span>
 358 
 359       buffer = channel-&gt;buffer + channel-&gt;wrp;
 360 
 361       /* Always leave at least one byte unused gap to be able to
 362        * distinguish between the full and empty condition...
 363        */
 364       nbytes = MIN ((channel-&gt;rdp + BUFFER_SIZE - channel-&gt;wrp - 1) % BUFFER_SIZE,
<span class="line-modified"> 365         BUFFER_SIZE - channel-&gt;wrp);</span>
 366 
 367       if (channel-&gt;debug)
<span class="line-modified"> 368   g_print (&quot;read_thread %#x: calling read() for %d bytes\n&quot;,</span>
<span class="line-modified"> 369      channel-&gt;thread_id, nbytes);</span>
 370 
 371       LeaveCriticalSection (&amp;channel-&gt;mutex);
 372 
 373       nbytes = read (channel-&gt;fd, buffer, nbytes);
 374 
 375       EnterCriticalSection (&amp;channel-&gt;mutex);
 376 
 377       channel-&gt;revents = G_IO_IN;
 378       if (nbytes == 0)
<span class="line-modified"> 379   channel-&gt;revents |= G_IO_HUP;</span>
 380       else if (nbytes &lt; 0)
<span class="line-modified"> 381   channel-&gt;revents |= G_IO_ERR;</span>
 382 
 383       if (channel-&gt;debug)
<span class="line-modified"> 384   g_print (&quot;read_thread %#x: read() returned %d, rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified"> 385      channel-&gt;thread_id, nbytes, channel-&gt;rdp, channel-&gt;wrp);</span>
 386 
 387       if (nbytes &lt;= 0)
<span class="line-modified"> 388   break;</span>
 389 
 390       channel-&gt;wrp = (channel-&gt;wrp + nbytes) % BUFFER_SIZE;
 391       if (channel-&gt;debug)
<span class="line-modified"> 392   g_print (&quot;read_thread %#x: rdp=%d, wrp=%d, setting data_avail\n&quot;,</span>
<span class="line-modified"> 393      channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
 394       SetEvent (channel-&gt;data_avail_event);
 395     }
 396 
 397   channel-&gt;running = FALSE;
 398   if (channel-&gt;needs_close)
 399     {
 400       if (channel-&gt;debug)
<span class="line-modified"> 401   g_print (&quot;read_thread %#x: channel fd %d needs closing\n&quot;,</span>
<span class="line-modified"> 402      channel-&gt;thread_id, channel-&gt;fd);</span>
 403       close (channel-&gt;fd);
 404       channel-&gt;fd = -1;
 405     }
 406 
 407   if (channel-&gt;debug)
 408     g_print (&quot;read_thread %#x: EOF, rdp=%d, wrp=%d, setting data_avail\n&quot;,
<span class="line-modified"> 409        channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
 410   SetEvent (channel-&gt;data_avail_event);
 411   LeaveCriticalSection (&amp;channel-&gt;mutex);
 412 
 413   g_io_channel_unref ((GIOChannel *)channel);
 414 
 415   /* No need to call _endthreadex(), the actual thread starter routine
 416    * in MSVCRT (see crt/src/threadex.c:_threadstartex) calls
 417    * _endthreadex() for us.
 418    */
 419 
 420   return 0;
 421 }
 422 
 423 static unsigned __stdcall
 424 write_thread (void *parameter)
 425 {
 426   GIOWin32Channel *channel = parameter;
 427   guchar *buffer;
 428   gint nbytes;
 429 
 430   g_io_channel_ref ((GIOChannel *)channel);
 431 
 432   if (channel-&gt;debug)
 433     g_print (&quot;write_thread %#x: start fd=%d, data_avail=%p space_avail=%p\n&quot;,
<span class="line-modified"> 434        channel-&gt;thread_id,</span>
<span class="line-modified"> 435        channel-&gt;fd,</span>
<span class="line-modified"> 436        channel-&gt;data_avail_event,</span>
<span class="line-modified"> 437        channel-&gt;space_avail_event);</span>
 438 
 439   channel-&gt;direction = 1;
 440   channel-&gt;buffer = g_malloc (BUFFER_SIZE);
 441   channel-&gt;rdp = channel-&gt;wrp = 0;
 442   channel-&gt;running = TRUE;
 443 
 444   SetEvent (channel-&gt;space_avail_event);
 445 
 446   /* We use the same event objects as for a reader thread, but with
 447    * reversed meaning. So, space_avail is used if data is available
 448    * for writing, and data_avail is used if space is available in the
 449    * write buffer.
 450    */
 451 
 452   EnterCriticalSection (&amp;channel-&gt;mutex);
 453   while (channel-&gt;running || channel-&gt;rdp != channel-&gt;wrp)
 454     {
 455       if (channel-&gt;debug)
<span class="line-modified"> 456   g_print (&quot;write_thread %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified"> 457      channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
 458       if (channel-&gt;wrp == channel-&gt;rdp)
<span class="line-modified"> 459   {</span>
<span class="line-modified"> 460     /* Buffer is empty. */</span>
<span class="line-modified"> 461     if (channel-&gt;debug)</span>
<span class="line-modified"> 462       g_print (&quot;write_thread %#x: resetting space_avail\n&quot;,</span>
<span class="line-modified"> 463          channel-&gt;thread_id);</span>
<span class="line-modified"> 464     ResetEvent (channel-&gt;space_avail_event);</span>
<span class="line-modified"> 465     if (channel-&gt;debug)</span>
<span class="line-modified"> 466       g_print (&quot;write_thread %#x: waiting for data\n&quot;,</span>
<span class="line-modified"> 467          channel-&gt;thread_id);</span>
<span class="line-modified"> 468     channel-&gt;revents = G_IO_OUT;</span>
<span class="line-modified"> 469     SetEvent (channel-&gt;data_avail_event);</span>
<span class="line-modified"> 470     LeaveCriticalSection (&amp;channel-&gt;mutex);</span>
<span class="line-modified"> 471     WaitForSingleObject (channel-&gt;space_avail_event, INFINITE);</span>
 472 
<span class="line-modified"> 473     EnterCriticalSection (&amp;channel-&gt;mutex);</span>
<span class="line-modified"> 474     if (channel-&gt;rdp == channel-&gt;wrp)</span>
<span class="line-modified"> 475       break;</span>
 476 
<span class="line-modified"> 477     if (channel-&gt;debug)</span>
<span class="line-modified"> 478       g_print (&quot;write_thread %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified"> 479          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
<span class="line-modified"> 480   }</span>
 481 
 482       buffer = channel-&gt;buffer + channel-&gt;rdp;
 483       if (channel-&gt;rdp &lt; channel-&gt;wrp)
<span class="line-modified"> 484   nbytes = channel-&gt;wrp - channel-&gt;rdp;</span>
 485       else
<span class="line-modified"> 486   nbytes = BUFFER_SIZE - channel-&gt;rdp;</span>
 487 
 488       if (channel-&gt;debug)
<span class="line-modified"> 489   g_print (&quot;write_thread %#x: calling write() for %d bytes\n&quot;,</span>
<span class="line-modified"> 490      channel-&gt;thread_id, nbytes);</span>
 491 
 492       LeaveCriticalSection (&amp;channel-&gt;mutex);
 493       nbytes = write (channel-&gt;fd, buffer, nbytes);
 494       EnterCriticalSection (&amp;channel-&gt;mutex);
 495 
 496       if (channel-&gt;debug)
<span class="line-modified"> 497   g_print (&quot;write_thread %#x: write(%i) returned %d, rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified"> 498      channel-&gt;thread_id, channel-&gt;fd, nbytes, channel-&gt;rdp, channel-&gt;wrp);</span>
 499 
 500       channel-&gt;revents = 0;
 501       if (nbytes &gt; 0)
<span class="line-modified"> 502   channel-&gt;revents |= G_IO_OUT;</span>
 503       else if (nbytes &lt;= 0)
<span class="line-modified"> 504   channel-&gt;revents |= G_IO_ERR;</span>
 505 
 506       channel-&gt;rdp = (channel-&gt;rdp + nbytes) % BUFFER_SIZE;
 507 
 508       if (nbytes &lt;= 0)
<span class="line-modified"> 509   break;</span>
 510 
 511       if (channel-&gt;debug)
<span class="line-modified"> 512   g_print (&quot;write_thread: setting data_avail for thread %#x\n&quot;,</span>
<span class="line-modified"> 513      channel-&gt;thread_id);</span>
 514       SetEvent (channel-&gt;data_avail_event);
 515     }
 516 
 517   channel-&gt;running = FALSE;
 518   if (channel-&gt;needs_close)
 519     {
 520       if (channel-&gt;debug)
<span class="line-modified"> 521   g_print (&quot;write_thread %#x: channel fd %d needs closing\n&quot;,</span>
<span class="line-modified"> 522      channel-&gt;thread_id, channel-&gt;fd);</span>
 523       close (channel-&gt;fd);
 524       channel-&gt;fd = -1;
 525     }
 526 
 527   LeaveCriticalSection (&amp;channel-&gt;mutex);
 528 
 529   g_io_channel_unref ((GIOChannel *)channel);
 530 
 531   return 0;
 532 }
 533 
 534 static void
 535 create_thread (GIOWin32Channel     *channel,
<span class="line-modified"> 536          GIOCondition         condition,</span>
<span class="line-modified"> 537          unsigned (__stdcall *thread) (void *parameter))</span>
 538 {
 539   HANDLE thread_handle;
 540   int errsv;
 541 
 542   thread_handle = (HANDLE) _beginthreadex (NULL, 0, thread, channel, 0,
<span class="line-modified"> 543              &amp;channel-&gt;thread_id);</span>
 544   errsv = errno;
 545   if (thread_handle == 0)
 546     g_warning (&quot;Error creating thread: %s.&quot;,
<span class="line-modified"> 547          g_strerror (errsv));</span>
 548   else if (!CloseHandle (thread_handle))
 549     {
 550       gchar *emsg = g_win32_error_message (GetLastError ());
 551 
 552       g_warning (&quot;Error closing thread handle: %s.&quot;, emsg);
 553       g_free (emsg);
 554     }
 555 
 556   WaitForSingleObject (channel-&gt;space_avail_event, INFINITE);
 557 }
 558 
 559 static GIOStatus
 560 buffer_read (GIOWin32Channel *channel,
<span class="line-modified"> 561        gchar           *dest,</span>
<span class="line-modified"> 562        gsize            count,</span>
<span class="line-modified"> 563        gsize           *bytes_read,</span>
<span class="line-modified"> 564        GError         **err)</span>
 565 {
 566   guint nbytes;
 567   guint left = count;
 568 
 569   EnterCriticalSection (&amp;channel-&gt;mutex);
 570   if (channel-&gt;debug)
 571     g_print (&quot;reading from thread %#x %&quot; G_GSIZE_FORMAT &quot; bytes, rdp=%d, wrp=%d\n&quot;,
<span class="line-modified"> 572        channel-&gt;thread_id, count, channel-&gt;rdp, channel-&gt;wrp);</span>
 573 
 574   if (channel-&gt;wrp == channel-&gt;rdp)
 575     {
 576       LeaveCriticalSection (&amp;channel-&gt;mutex);
 577       if (channel-&gt;debug)
<span class="line-modified"> 578   g_print (&quot;waiting for data from thread %#x\n&quot;, channel-&gt;thread_id);</span>
 579       WaitForSingleObject (channel-&gt;data_avail_event, INFINITE);
 580       if (channel-&gt;debug)
<span class="line-modified"> 581   g_print (&quot;done waiting for data from thread %#x\n&quot;, channel-&gt;thread_id);</span>
 582       EnterCriticalSection (&amp;channel-&gt;mutex);
 583       if (channel-&gt;wrp == channel-&gt;rdp &amp;&amp; !channel-&gt;running)
<span class="line-modified"> 584   {</span>
<span class="line-modified"> 585     if (channel-&gt;debug)</span>
<span class="line-modified"> 586       g_print (&quot;wrp==rdp, !running\n&quot;);</span>
<span class="line-modified"> 587     LeaveCriticalSection (&amp;channel-&gt;mutex);</span>
 588           *bytes_read = 0;
<span class="line-modified"> 589     return G_IO_STATUS_EOF;</span>
<span class="line-modified"> 590   }</span>
 591     }
 592 
 593   if (channel-&gt;rdp &lt; channel-&gt;wrp)
 594     nbytes = channel-&gt;wrp - channel-&gt;rdp;
 595   else
 596     nbytes = BUFFER_SIZE - channel-&gt;rdp;
 597   LeaveCriticalSection (&amp;channel-&gt;mutex);
 598   nbytes = MIN (left, nbytes);
 599   if (channel-&gt;debug)
 600     g_print (&quot;moving %d bytes from thread %#x\n&quot;,
<span class="line-modified"> 601        nbytes, channel-&gt;thread_id);</span>
 602   memcpy (dest, channel-&gt;buffer + channel-&gt;rdp, nbytes);
 603   dest += nbytes;
 604   left -= nbytes;
 605   EnterCriticalSection (&amp;channel-&gt;mutex);
 606   channel-&gt;rdp = (channel-&gt;rdp + nbytes) % BUFFER_SIZE;
 607   if (channel-&gt;debug)
 608     g_print (&quot;setting space_avail for thread %#x\n&quot;, channel-&gt;thread_id);
 609   SetEvent (channel-&gt;space_avail_event);
 610   if (channel-&gt;debug)
 611     g_print (&quot;for thread %#x: rdp=%d, wrp=%d\n&quot;,
<span class="line-modified"> 612        channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
 613   if (channel-&gt;running &amp;&amp; channel-&gt;wrp == channel-&gt;rdp)
 614     {
 615       if (channel-&gt;debug)
<span class="line-modified"> 616   g_print (&quot;resetting data_avail of thread %#x\n&quot;,</span>
<span class="line-modified"> 617      channel-&gt;thread_id);</span>
 618       ResetEvent (channel-&gt;data_avail_event);
 619     };
 620   LeaveCriticalSection (&amp;channel-&gt;mutex);
 621 
 622   /* We have no way to indicate any errors form the actual
 623    * read() or recv() call in the reader thread. Should we have?
 624    */
 625   *bytes_read = count - left;
 626   return (*bytes_read &gt; 0) ? G_IO_STATUS_NORMAL : G_IO_STATUS_EOF;
 627 }
 628 
 629 
 630 static GIOStatus
 631 buffer_write (GIOWin32Channel *channel,
<span class="line-modified"> 632         const gchar     *dest,</span>
<span class="line-modified"> 633         gsize            count,</span>
<span class="line-modified"> 634         gsize           *bytes_written,</span>
<span class="line-modified"> 635         GError         **err)</span>
 636 {
 637   guint nbytes;
 638   guint left = count;
 639 
 640   EnterCriticalSection (&amp;channel-&gt;mutex);
 641   if (channel-&gt;debug)
 642     g_print (&quot;buffer_write: writing to thread %#x %&quot; G_GSIZE_FORMAT &quot; bytes, rdp=%d, wrp=%d\n&quot;,
<span class="line-modified"> 643        channel-&gt;thread_id, count, channel-&gt;rdp, channel-&gt;wrp);</span>
 644 
 645   if ((channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)
 646     {
 647       /* Buffer is full */
 648       if (channel-&gt;debug)
<span class="line-modified"> 649   g_print (&quot;buffer_write: tid %#x: resetting data_avail\n&quot;,</span>
<span class="line-modified"> 650      channel-&gt;thread_id);</span>
 651       ResetEvent (channel-&gt;data_avail_event);
 652       if (channel-&gt;debug)
<span class="line-modified"> 653   g_print (&quot;buffer_write: tid %#x: waiting for space\n&quot;,</span>
<span class="line-modified"> 654      channel-&gt;thread_id);</span>
 655       LeaveCriticalSection (&amp;channel-&gt;mutex);
 656       WaitForSingleObject (channel-&gt;data_avail_event, INFINITE);
 657       EnterCriticalSection (&amp;channel-&gt;mutex);
 658       if (channel-&gt;debug)
<span class="line-modified"> 659   g_print (&quot;buffer_write: tid %#x: rdp=%d, wrp=%d\n&quot;,</span>
<span class="line-modified"> 660      channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
 661     }
 662 
 663   nbytes = MIN ((channel-&gt;rdp + BUFFER_SIZE - channel-&gt;wrp - 1) % BUFFER_SIZE,
<span class="line-modified"> 664     BUFFER_SIZE - channel-&gt;wrp);</span>
 665 
 666   LeaveCriticalSection (&amp;channel-&gt;mutex);
 667   nbytes = MIN (left, nbytes);
 668   if (channel-&gt;debug)
 669     g_print (&quot;buffer_write: tid %#x: writing %d bytes\n&quot;,
<span class="line-modified"> 670        channel-&gt;thread_id, nbytes);</span>
 671   memcpy (channel-&gt;buffer + channel-&gt;wrp, dest, nbytes);
 672   dest += nbytes;
 673   left -= nbytes;
 674   EnterCriticalSection (&amp;channel-&gt;mutex);
 675 
 676   channel-&gt;wrp = (channel-&gt;wrp + nbytes) % BUFFER_SIZE;
 677   if (channel-&gt;debug)
 678     g_print (&quot;buffer_write: tid %#x: rdp=%d, wrp=%d, setting space_avail\n&quot;,
<span class="line-modified"> 679        channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);</span>
 680   SetEvent (channel-&gt;space_avail_event);
 681 
 682   if ((channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)
 683     {
 684       /* Buffer is full */
 685       if (channel-&gt;debug)
<span class="line-modified"> 686   g_print (&quot;buffer_write: tid %#x: resetting data_avail\n&quot;,</span>
<span class="line-modified"> 687      channel-&gt;thread_id);</span>
 688       ResetEvent (channel-&gt;data_avail_event);
 689     }
 690 
 691   LeaveCriticalSection (&amp;channel-&gt;mutex);
 692 
 693   /* We have no way to indicate any errors form the actual
 694    * write() call in the writer thread. Should we have?
 695    */
 696   *bytes_written = count - left;
 697   return (*bytes_written &gt; 0) ? G_IO_STATUS_NORMAL : G_IO_STATUS_EOF;
 698 }
 699 
 700 
 701 static gboolean
 702 g_io_win32_prepare (GSource *source,
<span class="line-modified"> 703         gint    *timeout)</span>
 704 {
 705   GIOWin32Watch *watch = (GIOWin32Watch *)source;
 706   GIOCondition buffer_condition = g_io_channel_get_buffer_condition (watch-&gt;channel);
 707   GIOWin32Channel *channel = (GIOWin32Channel *)watch-&gt;channel;
 708   int event_mask;
 709 
 710   *timeout = -1;
 711 
 712   if (channel-&gt;debug)
 713     g_print (&quot;g_io_win32_prepare: source=%p channel=%p&quot;, source, channel);
 714 
 715   switch (channel-&gt;type)
 716     {
 717     case G_IO_WIN32_WINDOWS_MESSAGES:
 718       if (channel-&gt;debug)
<span class="line-modified"> 719   g_print (&quot; MSG&quot;);</span>
 720       break;
 721 
 722     case G_IO_WIN32_CONSOLE:
 723       if (channel-&gt;debug)
<span class="line-modified"> 724   g_print (&quot; CON&quot;);</span>
 725       break;
 726 
 727     case G_IO_WIN32_FILE_DESC:
 728       if (channel-&gt;debug)
<span class="line-modified"> 729   g_print (&quot; FD thread=%#x buffer_condition:{%s}&quot;</span>
<span class="line-modified"> 730      &quot;\n  watch-&gt;pollfd.events:{%s} watch-&gt;pollfd.revents:{%s} channel-&gt;revents:{%s}&quot;,</span>
<span class="line-modified"> 731      channel-&gt;thread_id, condition_to_string (buffer_condition),</span>
<span class="line-modified"> 732      condition_to_string (watch-&gt;pollfd.events),</span>
<span class="line-modified"> 733      condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified"> 734      condition_to_string (channel-&gt;revents));</span>
 735 
 736       EnterCriticalSection (&amp;channel-&gt;mutex);
 737       if (channel-&gt;running)
<span class="line-modified"> 738   {</span>
<span class="line-modified"> 739     if (channel-&gt;direction == 0 &amp;&amp; channel-&gt;wrp == channel-&gt;rdp)</span>
<span class="line-modified"> 740       {</span>
<span class="line-modified"> 741         if (channel-&gt;debug)</span>
<span class="line-modified"> 742     g_print (&quot;\n  setting revents=0&quot;);</span>
<span class="line-modified"> 743         channel-&gt;revents = 0;</span>
<span class="line-modified"> 744       }</span>
<span class="line-modified"> 745   }</span>
 746       else
<span class="line-modified"> 747   {</span>
<span class="line-modified"> 748     if (channel-&gt;direction == 1</span>
<span class="line-modified"> 749         &amp;&amp; (channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)</span>
<span class="line-modified"> 750       {</span>
<span class="line-modified"> 751         if (channel-&gt;debug)</span>
<span class="line-modified"> 752     g_print (&quot;\n setting revents=0&quot;);</span>
<span class="line-modified"> 753         channel-&gt;revents = 0;</span>
<span class="line-modified"> 754       }</span>
<span class="line-modified"> 755   }</span>
 756       LeaveCriticalSection (&amp;channel-&gt;mutex);
 757       break;
 758 
 759     case G_IO_WIN32_SOCKET:
 760       if (channel-&gt;debug)
<span class="line-modified"> 761   g_print (&quot; SOCK&quot;);</span>
 762       event_mask = 0;
 763       if (watch-&gt;condition &amp; G_IO_IN)
<span class="line-modified"> 764   event_mask |= (FD_READ | FD_ACCEPT);</span>
 765       if (watch-&gt;condition &amp; G_IO_OUT)
<span class="line-modified"> 766   event_mask |= (FD_WRITE | FD_CONNECT);</span>
 767       event_mask |= FD_CLOSE;
 768 
 769       if (channel-&gt;event_mask != event_mask)
<span class="line-modified"> 770   {</span>
<span class="line-added"> 771     if (channel-&gt;debug)</span>
<span class="line-added"> 772       g_print (&quot;\n  WSAEventSelect(%d,%p,{%s})&quot;,</span>
<span class="line-added"> 773          channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd,</span>
<span class="line-added"> 774          event_mask_to_string (event_mask));</span>
<span class="line-added"> 775     if (WSAEventSelect (channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd,</span>
<span class="line-added"> 776             event_mask) == SOCKET_ERROR)</span>
 777       if (channel-&gt;debug)
<span class="line-modified"> 778         {</span>
<span class="line-modified"> 779     gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>






 780 
<span class="line-modified"> 781     g_print (&quot; failed: %s&quot;, emsg);</span>
<span class="line-modified"> 782     g_free (emsg);</span>
<span class="line-modified"> 783         }</span>
<span class="line-modified"> 784     channel-&gt;event_mask = event_mask;</span>
 785 
<span class="line-modified"> 786     if (channel-&gt;debug)</span>
<span class="line-modified"> 787       g_print (&quot;\n  setting last_events=0&quot;);</span>
<span class="line-modified"> 788     channel-&gt;last_events = 0;</span>
 789 
<span class="line-modified"> 790     if ((event_mask &amp; FD_WRITE) &amp;&amp;</span>
<span class="line-modified"> 791         channel-&gt;ever_writable &amp;&amp;</span>
<span class="line-modified"> 792         !channel-&gt;write_would_have_blocked)</span>
<span class="line-modified"> 793       {</span>
<span class="line-modified"> 794         if (channel-&gt;debug)</span>
<span class="line-modified"> 795     g_print (&quot; WSASetEvent(%p)&quot;, (WSAEVENT) watch-&gt;pollfd.fd);</span>
<span class="line-modified"> 796         WSASetEvent ((WSAEVENT) watch-&gt;pollfd.fd);</span>
<span class="line-modified"> 797       }</span>
<span class="line-modified"> 798   }</span>
 799       break;
 800 
 801     default:
 802       g_assert_not_reached ();
 803       g_abort ();
 804     }
 805   if (channel-&gt;debug)
 806     g_print (&quot;\n&quot;);
 807 
 808   return ((watch-&gt;condition &amp; buffer_condition) == watch-&gt;condition);
 809 }
 810 
 811 static gboolean
 812 g_io_win32_check (GSource *source)
 813 {
 814   MSG msg;
 815   GIOWin32Watch *watch = (GIOWin32Watch *)source;
 816   GIOWin32Channel *channel = (GIOWin32Channel *)watch-&gt;channel;
 817   GIOCondition buffer_condition = g_io_channel_get_buffer_condition (watch-&gt;channel);
 818   WSANETWORKEVENTS events;
 819 
 820   if (channel-&gt;debug)
 821     g_print (&quot;g_io_win32_check: source=%p channel=%p&quot;, source, channel);
 822 
 823   switch (channel-&gt;type)
 824     {
 825     case G_IO_WIN32_WINDOWS_MESSAGES:
 826       if (channel-&gt;debug)
<span class="line-modified"> 827   g_print (&quot; MSG\n&quot;);</span>
 828       return (PeekMessage (&amp;msg, channel-&gt;hwnd, 0, 0, PM_NOREMOVE));
 829 
 830     case G_IO_WIN32_FILE_DESC:
 831       if (channel-&gt;debug)
<span class="line-modified"> 832   g_print (&quot; FD thread=%#x buffer_condition=%s\n&quot;</span>
<span class="line-modified"> 833      &quot;  watch-&gt;pollfd.events={%s} watch-&gt;pollfd.revents={%s} channel-&gt;revents={%s}\n&quot;,</span>
<span class="line-modified"> 834      channel-&gt;thread_id, condition_to_string (buffer_condition),</span>
<span class="line-modified"> 835      condition_to_string (watch-&gt;pollfd.events),</span>
<span class="line-modified"> 836      condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified"> 837      condition_to_string (channel-&gt;revents));</span>
 838 
 839       watch-&gt;pollfd.revents = (watch-&gt;pollfd.events &amp; channel-&gt;revents);
 840 
 841       return ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition);
 842 
 843     case G_IO_WIN32_CONSOLE:
 844       if (channel-&gt;debug)
<span class="line-modified"> 845   g_print (&quot; CON\n&quot;);</span>
 846       if (watch-&gt;channel-&gt;is_writeable)
<span class="line-modified"> 847   return TRUE;</span>
 848       else if (watch-&gt;channel-&gt;is_readable)
 849         {
<span class="line-modified"> 850     INPUT_RECORD buffer;</span>
<span class="line-modified"> 851     DWORD n;</span>
<span class="line-modified"> 852     if (PeekConsoleInput ((HANDLE) watch-&gt;pollfd.fd, &amp;buffer, 1, &amp;n) &amp;&amp;</span>
<span class="line-modified"> 853         n == 1)</span>
<span class="line-modified"> 854       {</span>
<span class="line-modified"> 855         /* _kbhit() does quite complex processing to find out</span>
<span class="line-modified"> 856          * whether at least one of the key events pending corresponds</span>
<span class="line-modified"> 857          * to a &quot;real&quot; character that can be read.</span>
<span class="line-modified"> 858          */</span>
<span class="line-modified"> 859         if (_kbhit ())</span>
<span class="line-modified"> 860     return TRUE;</span>
<span class="line-modified"> 861 </span>
<span class="line-modified"> 862         /* Discard all other kinds of events */</span>
<span class="line-modified"> 863         ReadConsoleInput ((HANDLE) watch-&gt;pollfd.fd, &amp;buffer, 1, &amp;n);</span>
<span class="line-modified"> 864       }</span>
 865         }
 866       return FALSE;
 867 
 868     case G_IO_WIN32_SOCKET:
 869       if (channel-&gt;debug)
<span class="line-modified"> 870   g_print (&quot; SOCK&quot;);</span>
 871       if (channel-&gt;last_events &amp; FD_WRITE)
<span class="line-modified"> 872   {</span>
<span class="line-modified"> 873     if (channel-&gt;debug)</span>
<span class="line-modified"> 874       g_print (&quot; sock=%d event=%p last_events has FD_WRITE&quot;,</span>
<span class="line-modified"> 875          channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd);</span>
<span class="line-modified"> 876   }</span>
 877       else
<span class="line-modified"> 878   {</span>
<span class="line-modified"> 879     WSAEnumNetworkEvents (channel-&gt;fd, 0, &amp;events);</span>
 880 
<span class="line-modified"> 881     if (channel-&gt;debug)</span>
<span class="line-modified"> 882       g_print (&quot;\n  revents={%s} condition={%s}&quot;</span>
<span class="line-modified"> 883          &quot;\n  WSAEnumNetworkEvents(%d,0) sets events={%s}&quot;,</span>
<span class="line-modified"> 884          condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified"> 885          condition_to_string (watch-&gt;condition),</span>
<span class="line-modified"> 886          channel-&gt;fd,</span>
<span class="line-modified"> 887          event_mask_to_string (events.lNetworkEvents));</span>
<span class="line-modified"> 888 </span>
<span class="line-modified"> 889     if (watch-&gt;pollfd.revents != 0 &amp;&amp;</span>
<span class="line-modified"> 890         events.lNetworkEvents == 0 &amp;&amp;</span>
<span class="line-modified"> 891         !(channel-&gt;event_mask &amp; FD_WRITE))</span>
<span class="line-modified"> 892       {</span>
<span class="line-modified"> 893         channel-&gt;event_mask = 0;</span>
<span class="line-modified"> 894         if (channel-&gt;debug)</span>
<span class="line-modified"> 895     g_print (&quot;\n  WSAEventSelect(%d,%p,{})&quot;,</span>
<span class="line-modified"> 896        channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd);</span>
<span class="line-modified"> 897         WSAEventSelect (channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd, 0);</span>
<span class="line-modified"> 898         if (channel-&gt;debug)</span>
<span class="line-modified"> 899     g_print (&quot;  ResetEvent(%p)&quot;,</span>
<span class="line-modified"> 900        (HANDLE) watch-&gt;pollfd.fd);</span>
<span class="line-modified"> 901         ResetEvent ((HANDLE) watch-&gt;pollfd.fd);</span>
<span class="line-modified"> 902       }</span>
<span class="line-modified"> 903     else if (events.lNetworkEvents &amp; FD_WRITE)</span>
<span class="line-modified"> 904       channel-&gt;ever_writable = TRUE;</span>
<span class="line-modified"> 905     channel-&gt;last_events = events.lNetworkEvents;</span>
<span class="line-modified"> 906   }</span>
 907 
 908       watch-&gt;pollfd.revents = 0;
 909       if (channel-&gt;last_events &amp; (FD_READ | FD_ACCEPT))
<span class="line-modified"> 910   watch-&gt;pollfd.revents |= G_IO_IN;</span>
 911 
 912       if (channel-&gt;last_events &amp; FD_WRITE)
<span class="line-modified"> 913   watch-&gt;pollfd.revents |= G_IO_OUT;</span>
 914       else
<span class="line-modified"> 915   {</span>
<span class="line-modified"> 916     /* We have called WSAEnumNetworkEvents() above but it didn&#39;t</span>
<span class="line-modified"> 917      * set FD_WRITE.</span>
<span class="line-modified"> 918      */</span>
<span class="line-modified"> 919     if (events.lNetworkEvents &amp; FD_CONNECT)</span>
<span class="line-modified"> 920       {</span>
<span class="line-modified"> 921         if (events.iErrorCode[FD_CONNECT_BIT] == 0)</span>
<span class="line-modified"> 922     watch-&gt;pollfd.revents |= G_IO_OUT;</span>
<span class="line-modified"> 923         else</span>
<span class="line-modified"> 924     watch-&gt;pollfd.revents |= (G_IO_HUP | G_IO_ERR);</span>
<span class="line-modified"> 925       }</span>
<span class="line-modified"> 926     if (watch-&gt;pollfd.revents == 0 &amp;&amp; (channel-&gt;last_events &amp; (FD_CLOSE)))</span>
<span class="line-modified"> 927       watch-&gt;pollfd.revents |= G_IO_HUP;</span>
<span class="line-modified"> 928   }</span>
 929 
 930       /* Regardless of WSAEnumNetworkEvents() result, if watching for
 931        * writability, and if we have ever got a FD_WRITE event, and
 932        * unless last write would have blocked, set G_IO_OUT. But never
 933        * set both G_IO_OUT and G_IO_HUP.
 934        */
 935       if (!(watch-&gt;pollfd.revents &amp; G_IO_HUP) &amp;&amp;
<span class="line-modified"> 936     channel-&gt;ever_writable &amp;&amp;</span>
<span class="line-modified"> 937     !channel-&gt;write_would_have_blocked &amp;&amp;</span>
<span class="line-modified"> 938     (channel-&gt;event_mask &amp; FD_WRITE))</span>
<span class="line-modified"> 939   watch-&gt;pollfd.revents |= G_IO_OUT;</span>
 940 
 941       if (channel-&gt;debug)
<span class="line-modified"> 942   g_print (&quot;\n  revents={%s} retval={%s}\n&quot;,</span>
<span class="line-modified"> 943      condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified"> 944      condition_to_string ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition));</span>
 945 
 946       return ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition);
 947 
 948     default:
 949       g_assert_not_reached ();
 950       g_abort ();
 951     }
 952 }
 953 
 954 static gboolean
 955 g_io_win32_dispatch (GSource     *source,
<span class="line-modified"> 956          GSourceFunc  callback,</span>
<span class="line-modified"> 957          gpointer     user_data)</span>
 958 {
 959   GIOFunc func = (GIOFunc)callback;
 960   GIOWin32Watch *watch = (GIOWin32Watch *)source;
 961   GIOWin32Channel *channel = (GIOWin32Channel *)watch-&gt;channel;
 962   GIOCondition buffer_condition = g_io_channel_get_buffer_condition (watch-&gt;channel);
 963 
 964   if (!func)
 965     {
 966       g_warning (&quot;IO Watch dispatched without callback. &quot;
<span class="line-modified"> 967      &quot;You must call g_source_connect().&quot;);</span>
 968       return FALSE;
 969     }
 970 
 971   if (channel-&gt;debug)
 972     g_print (&quot;g_io_win32_dispatch: pollfd.revents=%s condition=%s result=%s\n&quot;,
<span class="line-modified"> 973        condition_to_string (watch-&gt;pollfd.revents),</span>
<span class="line-modified"> 974        condition_to_string (watch-&gt;condition),</span>
<span class="line-modified"> 975        condition_to_string ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition));</span>
 976 
 977   return (*func) (watch-&gt;channel,
<span class="line-modified"> 978       (watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition,</span>
<span class="line-modified"> 979       user_data);</span>
 980 }
 981 
 982 static void
 983 g_io_win32_finalize (GSource *source)
 984 {
 985   GIOWin32Watch *watch = (GIOWin32Watch *)source;
 986   GIOWin32Channel *channel = (GIOWin32Channel *)watch-&gt;channel;
 987 
 988   if (channel-&gt;debug)
 989     g_print (&quot;g_io_win32_finalize: source=%p channel=%p&quot;, source, channel);
 990 
 991   switch (channel-&gt;type)
 992     {
 993     case G_IO_WIN32_WINDOWS_MESSAGES:
 994       if (channel-&gt;debug)
<span class="line-modified"> 995   g_print (&quot; MSG&quot;);</span>
 996       break;
 997 
 998     case G_IO_WIN32_CONSOLE:
 999       if (channel-&gt;debug)
<span class="line-modified">1000   g_print (&quot; CON&quot;);</span>
1001       break;
1002 
1003     case G_IO_WIN32_FILE_DESC:
1004       if (channel-&gt;debug)
<span class="line-modified">1005   g_print (&quot; FD thread=%#x&quot;, channel-&gt;thread_id);</span>
1006       break;
1007 
1008     case G_IO_WIN32_SOCKET:
1009       if (channel-&gt;debug)
<span class="line-modified">1010   g_print (&quot; SOCK sock=%d&quot;, channel-&gt;fd);</span>
1011       break;
1012 
1013     default:
1014       g_assert_not_reached ();
1015       g_abort ();
1016     }
1017   if (channel-&gt;debug)
1018     g_print (&quot;\n&quot;);
1019   g_io_channel_unref (watch-&gt;channel);
1020 }
1021 
1022 GSourceFuncs g_io_watch_funcs = {
1023   g_io_win32_prepare,
1024   g_io_win32_check,
1025   g_io_win32_dispatch,
1026   g_io_win32_finalize
1027 };
1028 
1029 static GIOStatus
1030 g_io_win32_msg_read (GIOChannel *channel,
<span class="line-modified">1031          gchar      *buf,</span>
<span class="line-modified">1032          gsize       count,</span>
<span class="line-modified">1033          gsize      *bytes_read,</span>
<span class="line-modified">1034          GError    **err)</span>
1035 {
1036   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1037   MSG msg;               /* In case of alignment problems */
1038 
1039   *bytes_read = 0;
1040 
1041   if (count &lt; sizeof (MSG))
1042     {
1043       g_set_error_literal (err, G_IO_CHANNEL_ERROR, G_IO_CHANNEL_ERROR_INVAL,
1044                            &quot;Incorrect message size&quot;); /* Informative enough error message? */
1045       return G_IO_STATUS_ERROR;
1046     }
1047 
1048   if (win32_channel-&gt;debug)
1049     g_print (&quot;g_io_win32_msg_read: channel=%p hwnd=%p\n&quot;,
<span class="line-modified">1050        channel, win32_channel-&gt;hwnd);</span>
1051   if (!PeekMessage (&amp;msg, win32_channel-&gt;hwnd, 0, 0, PM_REMOVE))
1052     return G_IO_STATUS_AGAIN;
1053 
1054   memmove (buf, &amp;msg, sizeof (MSG));
1055   *bytes_read = sizeof (MSG);
1056 
1057   return G_IO_STATUS_NORMAL;
1058 }
1059 
1060 static GIOStatus
1061 g_io_win32_msg_write (GIOChannel  *channel,
<span class="line-modified">1062           const gchar *buf,</span>
<span class="line-modified">1063           gsize        count,</span>
<span class="line-modified">1064           gsize       *bytes_written,</span>
<span class="line-modified">1065           GError     **err)</span>
1066 {
1067   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1068   MSG msg;
1069 
1070   *bytes_written = 0;
1071 
1072   if (count != sizeof (MSG))
1073     {
1074       g_set_error_literal (err, G_IO_CHANNEL_ERROR, G_IO_CHANNEL_ERROR_INVAL,
1075                            &quot;Incorrect message size&quot;); /* Informative enough error message? */
1076       return G_IO_STATUS_ERROR;
1077     }
1078 
1079   /* In case of alignment problems */
1080   memmove (&amp;msg, buf, sizeof (MSG));
1081   if (!PostMessage (win32_channel-&gt;hwnd, msg.message, msg.wParam, msg.lParam))
1082     {
1083       gchar *emsg = g_win32_error_message (GetLastError ());
1084 
1085       g_set_error_literal (err, G_IO_CHANNEL_ERROR, G_IO_CHANNEL_ERROR_FAILED, emsg);
1086       g_free (emsg);
1087 
1088       return G_IO_STATUS_ERROR;
1089     }
1090 
1091   *bytes_written = sizeof (MSG);
1092 
1093   return G_IO_STATUS_NORMAL;
1094 }
1095 
1096 static GIOStatus
1097 g_io_win32_msg_close (GIOChannel *channel,
<span class="line-modified">1098           GError    **err)</span>
1099 {
1100   /* Nothing to be done. Or should we set hwnd to some invalid value? */
1101 
1102   return G_IO_STATUS_NORMAL;
1103 }
1104 
1105 static void
1106 g_io_win32_free (GIOChannel *channel)
1107 {
1108   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1109 
1110   if (win32_channel-&gt;debug)
1111     g_print (&quot;g_io_win32_free channel=%p fd=%d\n&quot;, channel, win32_channel-&gt;fd);
1112 
1113   DeleteCriticalSection (&amp;win32_channel-&gt;mutex);
1114 
1115   if (win32_channel-&gt;data_avail_event)
1116     if (!CloseHandle (win32_channel-&gt;data_avail_event))
1117       if (win32_channel-&gt;debug)
<span class="line-modified">1118   {</span>
<span class="line-modified">1119     gchar *emsg = g_win32_error_message (GetLastError ());</span>
1120 
<span class="line-modified">1121     g_print (&quot;  CloseHandle(%p) failed: %s\n&quot;,</span>
<span class="line-modified">1122        win32_channel-&gt;data_avail_event, emsg);</span>
<span class="line-modified">1123     g_free (emsg);</span>
<span class="line-modified">1124   }</span>
1125 
1126   g_free (win32_channel-&gt;buffer);
1127 
1128   if (win32_channel-&gt;space_avail_event)
1129     if (!CloseHandle (win32_channel-&gt;space_avail_event))
1130       if (win32_channel-&gt;debug)
<span class="line-modified">1131   {</span>
<span class="line-modified">1132     gchar *emsg = g_win32_error_message (GetLastError ());</span>
1133 
<span class="line-modified">1134     g_print (&quot;  CloseHandle(%p) failed: %s\n&quot;,</span>
<span class="line-modified">1135        win32_channel-&gt;space_avail_event, emsg);</span>
<span class="line-modified">1136     g_free (emsg);</span>
<span class="line-modified">1137   }</span>
1138 
1139   if (win32_channel-&gt;type == G_IO_WIN32_SOCKET &amp;&amp;
1140       win32_channel-&gt;fd != -1)
1141     if (WSAEventSelect (win32_channel-&gt;fd, NULL, 0) == SOCKET_ERROR)
1142       if (win32_channel-&gt;debug)
<span class="line-modified">1143   {</span>
<span class="line-modified">1144     gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
1145 
<span class="line-modified">1146     g_print (&quot;  WSAEventSelect(%d,NULL,{}) failed: %s\n&quot;,</span>
<span class="line-modified">1147        win32_channel-&gt;fd, emsg);</span>
<span class="line-modified">1148     g_free (emsg);</span>
<span class="line-modified">1149   }</span>
1150 
1151   if (win32_channel-&gt;event)
1152     if (!WSACloseEvent (win32_channel-&gt;event))
1153       if (win32_channel-&gt;debug)
<span class="line-modified">1154   {</span>
<span class="line-modified">1155     gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
1156 
<span class="line-modified">1157     g_print (&quot;  WSACloseEvent(%p) failed: %s\n&quot;,</span>
<span class="line-modified">1158        win32_channel-&gt;event, emsg);</span>
<span class="line-modified">1159     g_free (emsg);</span>
<span class="line-modified">1160   }</span>
1161 
1162   g_free (win32_channel);
1163 }
1164 
1165 static GSource *
1166 g_io_win32_msg_create_watch (GIOChannel   *channel,
<span class="line-modified">1167            GIOCondition  condition)</span>
1168 {
1169   GIOWin32Watch *watch;
1170   GSource *source;
1171 
1172   source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
1173   g_source_set_name (source, &quot;GIOChannel (Win32)&quot;);
1174   watch = (GIOWin32Watch *)source;
1175 
1176   watch-&gt;channel = channel;
1177   g_io_channel_ref (channel);
1178 
1179   watch-&gt;condition = condition;
1180 
1181   watch-&gt;pollfd.fd = (gintptr) G_WIN32_MSG_HANDLE;
1182   watch-&gt;pollfd.events = condition;
1183 
1184   g_source_add_poll (source, &amp;watch-&gt;pollfd);
1185 
1186   return source;
1187 }
1188 
1189 static GIOStatus
1190 g_io_win32_fd_and_console_read (GIOChannel *channel,
<span class="line-modified">1191         gchar      *buf,</span>
<span class="line-modified">1192         gsize       count,</span>
<span class="line-modified">1193         gsize      *bytes_read,</span>
<span class="line-modified">1194         GError    **err)</span>
1195 {
1196   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1197   gint result;
1198   int errsv;
1199 
1200   if (win32_channel-&gt;debug)
1201     g_print (&quot;g_io_win32_fd_read: fd=%d count=%&quot; G_GSIZE_FORMAT &quot;\n&quot;,
<span class="line-modified">1202        win32_channel-&gt;fd, count);</span>
1203 
1204   if (win32_channel-&gt;thread_id)
1205     {
1206       return buffer_read (win32_channel, buf, count, bytes_read, err);
1207     }
1208 
1209   result = read (win32_channel-&gt;fd, buf, count);
1210   errsv = errno;
1211 
1212   if (win32_channel-&gt;debug)
1213     g_print (&quot;g_io_win32_fd_read: read() =&gt; %d\n&quot;, result);
1214 
1215   if (result &lt; 0)
1216     {
1217       *bytes_read = 0;
1218 
1219       switch (errsv)
1220         {
1221 #ifdef EAGAIN
<span class="line-modified">1222   case EAGAIN:</span>
<span class="line-modified">1223     return G_IO_STATUS_AGAIN;</span>
1224 #endif
<span class="line-modified">1225   default:</span>
<span class="line-modified">1226     g_set_error_literal (err, G_IO_CHANNEL_ERROR,</span>
1227                                g_io_channel_error_from_errno (errsv),
1228                                g_strerror (errsv));
<span class="line-modified">1229     return G_IO_STATUS_ERROR;</span>
1230         }
1231     }
1232 
1233   *bytes_read = result;
1234 
1235   return (result &gt; 0) ? G_IO_STATUS_NORMAL : G_IO_STATUS_EOF;
1236 }
1237 
1238 static GIOStatus
1239 g_io_win32_fd_and_console_write (GIOChannel  *channel,
<span class="line-modified">1240          const gchar *buf,</span>
<span class="line-modified">1241          gsize        count,</span>
<span class="line-modified">1242          gsize       *bytes_written,</span>
<span class="line-modified">1243          GError     **err)</span>
1244 {
1245   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1246   gint result;
1247   int errsv;
1248 
1249   if (win32_channel-&gt;thread_id)
1250     {
1251       return buffer_write (win32_channel, buf, count, bytes_written, err);
1252     }
1253 
1254   result = write (win32_channel-&gt;fd, buf, count);
1255   errsv = errno;
1256 
1257   if (win32_channel-&gt;debug)
1258     g_print (&quot;g_io_win32_fd_write: fd=%d count=%&quot; G_GSIZE_FORMAT &quot; =&gt; %d\n&quot;,
<span class="line-modified">1259        win32_channel-&gt;fd, count, result);</span>
1260 
1261   if (result &lt; 0)
1262     {
1263       *bytes_written = 0;
1264 
1265       switch (errsv)
1266         {
1267 #ifdef EAGAIN
<span class="line-modified">1268   case EAGAIN:</span>
<span class="line-modified">1269     return G_IO_STATUS_AGAIN;</span>
1270 #endif
<span class="line-modified">1271   default:</span>
<span class="line-modified">1272     g_set_error_literal (err, G_IO_CHANNEL_ERROR,</span>
1273                                g_io_channel_error_from_errno (errsv),
1274                                g_strerror (errsv));
<span class="line-modified">1275     return G_IO_STATUS_ERROR;</span>
1276         }
1277     }
1278 
1279   *bytes_written = result;
1280 
1281   return G_IO_STATUS_NORMAL;
1282 }
1283 
1284 static GIOStatus
1285 g_io_win32_fd_seek (GIOChannel *channel,
<span class="line-modified">1286         gint64      offset,</span>
<span class="line-modified">1287         GSeekType   type,</span>
<span class="line-modified">1288         GError    **err)</span>
1289 {
1290   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1291   int whence, errsv;
1292   off_t tmp_offset;
1293   off_t result;
1294 
1295   switch (type)
1296     {
1297     case G_SEEK_SET:
1298       whence = SEEK_SET;
1299       break;
1300     case G_SEEK_CUR:
1301       whence = SEEK_CUR;
1302       break;
1303     case G_SEEK_END:
1304       whence = SEEK_END;
1305       break;
1306     default:
1307       whence = -1; /* Keep the compiler quiet */
1308       g_assert_not_reached ();
</pre>
<hr />
<pre>
1317                            g_strerror (EINVAL));
1318       return G_IO_STATUS_ERROR;
1319     }
1320 
1321   result = lseek (win32_channel-&gt;fd, tmp_offset, whence);
1322   errsv = errno;
1323 
1324   if (result &lt; 0)
1325     {
1326       g_set_error_literal (err, G_IO_CHANNEL_ERROR,
1327                            g_io_channel_error_from_errno (errsv),
1328                            g_strerror (errsv));
1329       return G_IO_STATUS_ERROR;
1330     }
1331 
1332   return G_IO_STATUS_NORMAL;
1333 }
1334 
1335 static GIOStatus
1336 g_io_win32_fd_close (GIOChannel *channel,
<span class="line-modified">1337                GError    **err)</span>
1338 {
1339   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1340 
1341   if (win32_channel-&gt;debug)
1342     g_print (&quot;g_io_win32_fd_close: thread=%#x: fd=%d\n&quot;,
<span class="line-modified">1343        win32_channel-&gt;thread_id,</span>
<span class="line-modified">1344        win32_channel-&gt;fd);</span>
1345   EnterCriticalSection (&amp;win32_channel-&gt;mutex);
1346   if (win32_channel-&gt;running)
1347     {
1348       if (win32_channel-&gt;debug)
<span class="line-modified">1349   g_print (&quot;thread %#x: running, marking fd %d for later close\n&quot;,</span>
<span class="line-modified">1350      win32_channel-&gt;thread_id, win32_channel-&gt;fd);</span>
1351       win32_channel-&gt;running = FALSE;
1352       win32_channel-&gt;needs_close = TRUE;
1353       if (win32_channel-&gt;direction == 0)
<span class="line-modified">1354   SetEvent (win32_channel-&gt;data_avail_event);</span>
1355       else
<span class="line-modified">1356   SetEvent (win32_channel-&gt;space_avail_event);</span>
1357     }
1358   else
1359     {
1360       if (win32_channel-&gt;debug)
<span class="line-modified">1361   g_print (&quot;closing fd %d\n&quot;, win32_channel-&gt;fd);</span>
1362       close (win32_channel-&gt;fd);
1363       if (win32_channel-&gt;debug)
<span class="line-modified">1364   g_print (&quot;closed fd %d, setting to -1\n&quot;,</span>
<span class="line-modified">1365      win32_channel-&gt;fd);</span>
1366       win32_channel-&gt;fd = -1;
1367     }
1368   LeaveCriticalSection (&amp;win32_channel-&gt;mutex);
1369 
1370   /* FIXME error detection? */
1371 
1372   return G_IO_STATUS_NORMAL;
1373 }
1374 
1375 static GSource *
1376 g_io_win32_fd_create_watch (GIOChannel    *channel,
<span class="line-modified">1377           GIOCondition   condition)</span>
1378 {
1379   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1380   GSource *source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
1381   GIOWin32Watch *watch = (GIOWin32Watch *)source;
1382 
1383   watch-&gt;channel = channel;
1384   g_io_channel_ref (channel);
1385 
1386   watch-&gt;condition = condition;
1387 
1388   if (win32_channel-&gt;data_avail_event == NULL)
1389     create_events (win32_channel);
1390 
1391   watch-&gt;pollfd.fd = (gintptr) win32_channel-&gt;data_avail_event;
1392   watch-&gt;pollfd.events = condition;
1393 
1394   if (win32_channel-&gt;debug)
1395     g_print (&quot;g_io_win32_fd_create_watch: channel=%p fd=%d condition={%s} event=%p\n&quot;,
<span class="line-modified">1396        channel, win32_channel-&gt;fd,</span>
<span class="line-modified">1397        condition_to_string (condition), (HANDLE) watch-&gt;pollfd.fd);</span>
1398 
1399   EnterCriticalSection (&amp;win32_channel-&gt;mutex);
1400   if (win32_channel-&gt;thread_id == 0)
1401     {
1402       if (condition &amp; G_IO_IN)
<span class="line-modified">1403   create_thread (win32_channel, condition, read_thread);</span>
1404       else if (condition &amp; G_IO_OUT)
<span class="line-modified">1405   create_thread (win32_channel, condition, write_thread);</span>
1406     }
1407 
1408   g_source_add_poll (source, &amp;watch-&gt;pollfd);
1409   LeaveCriticalSection (&amp;win32_channel-&gt;mutex);
1410 
1411   return source;
1412 }
1413 
1414 static GIOStatus
1415 g_io_win32_console_close (GIOChannel *channel,
<span class="line-modified">1416               GError    **err)</span>
1417 {
1418   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1419 
1420   if (close (win32_channel-&gt;fd) &lt; 0)
1421     {
1422       int errsv = errno;
1423       g_set_error_literal (err, G_IO_CHANNEL_ERROR,
1424                            g_io_channel_error_from_errno (errsv),
1425                            g_strerror (errsv));
1426       return G_IO_STATUS_ERROR;
1427     }
1428 
1429   return G_IO_STATUS_NORMAL;
1430 }
1431 
1432 static GSource *
1433 g_io_win32_console_create_watch (GIOChannel    *channel,
<span class="line-modified">1434          GIOCondition   condition)</span>
1435 {
1436   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1437   GSource *source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
1438   GIOWin32Watch *watch = (GIOWin32Watch *)source;
1439 
1440   watch-&gt;channel = channel;
1441   g_io_channel_ref (channel);
1442 
1443   watch-&gt;condition = condition;
1444 
1445   watch-&gt;pollfd.fd = _get_osfhandle (win32_channel-&gt;fd);
1446   watch-&gt;pollfd.events = condition;
1447 
1448   g_source_add_poll (source, &amp;watch-&gt;pollfd);
1449 
1450   return source;
1451 }
1452 
1453 static GIOStatus
1454 g_io_win32_sock_read (GIOChannel *channel,
<span class="line-modified">1455           gchar      *buf,</span>
<span class="line-modified">1456           gsize       count,</span>
<span class="line-modified">1457           gsize      *bytes_read,</span>
<span class="line-modified">1458           GError    **err)</span>
1459 {
1460   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1461   gint result;
1462   GIOChannelError error;
1463   int winsock_error;
1464 
1465   if (win32_channel-&gt;debug)
1466     g_print (&quot;g_io_win32_sock_read: channel=%p sock=%d count=%&quot; G_GSIZE_FORMAT,
<span class="line-modified">1467        channel, win32_channel-&gt;fd, count);</span>
1468 
1469   result = recv (win32_channel-&gt;fd, buf, count, 0);
1470   if (result == SOCKET_ERROR)
1471     winsock_error = WSAGetLastError ();
1472 
1473   if (win32_channel-&gt;debug)
1474     g_print (&quot; recv=%d&quot;, result);
1475 
1476   if (result == SOCKET_ERROR)
1477     {
1478       gchar *emsg = g_win32_error_message (winsock_error);
1479 
1480       if (win32_channel-&gt;debug)
<span class="line-modified">1481   g_print (&quot; %s\n&quot;, emsg);</span>
1482 
1483       *bytes_read = 0;
1484 
1485       switch (winsock_error)
<span class="line-modified">1486   {</span>
<span class="line-modified">1487   case WSAEINVAL:</span>
1488           error = G_IO_CHANNEL_ERROR_INVAL;
1489           break;
<span class="line-modified">1490   case WSAEWOULDBLOCK:</span>
<span class="line-modified">1491     g_free (emsg);</span>
1492           return G_IO_STATUS_AGAIN;
<span class="line-modified">1493   default:</span>
<span class="line-modified">1494     error = G_IO_CHANNEL_ERROR_FAILED;</span>
1495           break;
<span class="line-modified">1496   }</span>
1497       g_set_error_literal (err, G_IO_CHANNEL_ERROR, error, emsg);
1498       g_free (emsg);
1499 
1500       return G_IO_STATUS_ERROR;
1501     }
1502   else
1503     {
1504       if (win32_channel-&gt;debug)
<span class="line-modified">1505   g_print (&quot;\n&quot;);</span>
1506       *bytes_read = result;
1507       if (result == 0)
<span class="line-modified">1508   return G_IO_STATUS_EOF;</span>
1509       else
<span class="line-modified">1510   return G_IO_STATUS_NORMAL;</span>
1511     }
1512 }
1513 
1514 static GIOStatus
1515 g_io_win32_sock_write (GIOChannel  *channel,
<span class="line-modified">1516            const gchar *buf,</span>
<span class="line-modified">1517            gsize        count,</span>
<span class="line-modified">1518            gsize       *bytes_written,</span>
<span class="line-modified">1519            GError     **err)</span>
1520 {
1521   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1522   gint result;
1523   GIOChannelError error;
1524   int winsock_error;
1525 
1526   if (win32_channel-&gt;debug)
1527     g_print (&quot;g_io_win32_sock_write: channel=%p sock=%d count=%&quot; G_GSIZE_FORMAT,
<span class="line-modified">1528        channel, win32_channel-&gt;fd, count);</span>
1529 
1530   result = send (win32_channel-&gt;fd, buf, count, 0);
1531   if (result == SOCKET_ERROR)
1532     winsock_error = WSAGetLastError ();
1533 
1534   if (win32_channel-&gt;debug)
1535     g_print (&quot; send=%d&quot;, result);
1536 
1537   if (result == SOCKET_ERROR)
1538     {
1539       gchar *emsg = g_win32_error_message (winsock_error);
1540 
1541       if (win32_channel-&gt;debug)
<span class="line-modified">1542   g_print (&quot; %s\n&quot;, emsg);</span>
1543 
1544       *bytes_written = 0;
1545 
1546       switch (winsock_error)
<span class="line-modified">1547   {</span>
<span class="line-modified">1548   case WSAEINVAL:</span>
<span class="line-modified">1549     error = G_IO_CHANNEL_ERROR_INVAL;</span>
1550           break;
<span class="line-modified">1551   case WSAEWOULDBLOCK:</span>
<span class="line-modified">1552     win32_channel-&gt;write_would_have_blocked = TRUE;</span>
<span class="line-modified">1553     win32_channel-&gt;last_events = 0;</span>
<span class="line-modified">1554     g_free (emsg);</span>
1555           return G_IO_STATUS_AGAIN;
<span class="line-modified">1556   default:</span>
<span class="line-modified">1557     error = G_IO_CHANNEL_ERROR_FAILED;</span>
1558           break;
<span class="line-modified">1559   }</span>
1560       g_set_error_literal (err, G_IO_CHANNEL_ERROR, error, emsg);
1561       g_free (emsg);
1562 
1563       return G_IO_STATUS_ERROR;
1564     }
1565   else
1566     {
1567       if (win32_channel-&gt;debug)
<span class="line-modified">1568   g_print (&quot;\n&quot;);</span>
1569       *bytes_written = result;
1570       win32_channel-&gt;write_would_have_blocked = FALSE;
1571 
1572       return G_IO_STATUS_NORMAL;
1573     }
1574 }
1575 
1576 static GIOStatus
1577 g_io_win32_sock_close (GIOChannel *channel,
<span class="line-modified">1578            GError    **err)</span>
1579 {
1580   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1581 
1582   if (win32_channel-&gt;fd != -1)
1583     {
1584       if (win32_channel-&gt;debug)
<span class="line-modified">1585   g_print (&quot;g_io_win32_sock_close: channel=%p sock=%d\n&quot;,</span>
<span class="line-modified">1586      channel, win32_channel-&gt;fd);</span>
1587 
1588       closesocket (win32_channel-&gt;fd);
1589       win32_channel-&gt;fd = -1;
1590     }
1591 
1592   /* FIXME error detection? */
1593 
1594   return G_IO_STATUS_NORMAL;
1595 }
1596 
1597 static GSource *
1598 g_io_win32_sock_create_watch (GIOChannel    *channel,
<span class="line-modified">1599             GIOCondition   condition)</span>
1600 {
1601   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1602   GSource *source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
1603   GIOWin32Watch *watch = (GIOWin32Watch *)source;
1604 
1605   watch-&gt;channel = channel;
1606   g_io_channel_ref (channel);
1607 
1608   watch-&gt;condition = condition;
1609 
1610   if (win32_channel-&gt;event == 0)
1611     win32_channel-&gt;event = WSACreateEvent ();
1612 
1613   watch-&gt;pollfd.fd = (gintptr) win32_channel-&gt;event;
1614   watch-&gt;pollfd.events = condition;
1615 
1616   if (win32_channel-&gt;debug)
1617     g_print (&quot;g_io_win32_sock_create_watch: channel=%p sock=%d event=%p condition={%s}\n&quot;,
<span class="line-modified">1618        channel, win32_channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd,</span>
<span class="line-modified">1619        condition_to_string (watch-&gt;condition));</span>
1620 
1621   g_source_add_poll (source, &amp;watch-&gt;pollfd);
1622 
1623   return source;
1624 }
1625 
1626 GIOChannel *
1627 g_io_channel_new_file (const gchar  *filename,
1628                        const gchar  *mode,
1629                        GError      **error)
1630 {
1631   int fid, flags, pmode;
1632   GIOChannel *channel;
1633 
1634   enum { /* Cheesy hack */
1635     MODE_R = 1 &lt;&lt; 0,
1636     MODE_W = 1 &lt;&lt; 1,
1637     MODE_A = 1 &lt;&lt; 2,
1638     MODE_PLUS = 1 &lt;&lt; 3,
1639   };
</pre>
<hr />
<pre>
1746         channel-&gt;is_writeable = FALSE;
1747         break;
1748       case MODE_W:
1749       case MODE_A:
1750         channel-&gt;is_readable = FALSE;
1751         break;
1752       case MODE_R | MODE_PLUS:
1753       case MODE_W | MODE_PLUS:
1754       case MODE_A | MODE_PLUS:
1755         break;
1756       default:
1757         g_assert_not_reached ();
1758         g_abort ();
1759     }
1760 
1761   return channel;
1762 }
1763 
1764 static GIOStatus
1765 g_io_win32_unimpl_set_flags (GIOChannel *channel,
<span class="line-modified">1766            GIOFlags    flags,</span>
<span class="line-modified">1767            GError    **err)</span>
1768 {
1769   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1770 
1771   if (win32_channel-&gt;debug)
1772     {
1773       g_print (&quot;g_io_win32_unimpl_set_flags: &quot;);
1774       g_win32_print_gioflags (flags);
1775       g_print (&quot;\n&quot;);
1776     }
1777 
1778   g_set_error_literal (err, G_IO_CHANNEL_ERROR,
1779                        G_IO_CHANNEL_ERROR_FAILED,
1780                        &quot;Not implemented on Win32&quot;);
1781 
1782   return G_IO_STATUS_ERROR;
1783 }
1784 
1785 static GIOFlags
1786 g_io_win32_fd_get_flags_internal (GIOChannel      *channel,
<span class="line-modified">1787           struct _stati64 *st)</span>
1788 {
1789   GIOWin32Channel *win32_channel = (GIOWin32Channel *) channel;
1790   gchar c;
1791   DWORD count;
1792 
1793   if (st-&gt;st_mode &amp; _S_IFIFO)
1794     {
1795       channel-&gt;is_readable =
<span class="line-modified">1796   (PeekNamedPipe ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL, NULL) != 0) || GetLastError () == ERROR_BROKEN_PIPE;</span>
1797       channel-&gt;is_writeable =
<span class="line-modified">1798   (WriteFile ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL) != 0);</span>
1799       channel-&gt;is_seekable  = FALSE;
1800     }
1801   else
1802     {
1803       channel-&gt;is_readable =
<span class="line-modified">1804   (ReadFile ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL) != 0);</span>
1805       channel-&gt;is_writeable =
<span class="line-modified">1806   (WriteFile ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL) != 0);</span>
1807       channel-&gt;is_seekable = TRUE;
1808     }
1809 
1810   /* XXX: G_IO_FLAG_APPEND */
1811   /* XXX: G_IO_FLAG_NONBLOCK */
1812 
1813   return 0;
1814 }
1815 
1816 static GIOFlags
1817 g_io_win32_fd_get_flags (GIOChannel *channel)
1818 {
1819   struct _stati64 st;
1820   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1821 
1822   g_return_val_if_fail (win32_channel != NULL, 0);
1823   g_return_val_if_fail (win32_channel-&gt;type == G_IO_WIN32_FILE_DESC, 0);
1824 
1825   if (0 == _fstati64 (win32_channel-&gt;fd, &amp;st))
1826     return g_io_win32_fd_get_flags_internal (channel, &amp;st);
</pre>
<hr />
<pre>
1846 
1847 static GIOFlags
1848 g_io_win32_console_get_flags (GIOChannel *channel)
1849 {
1850   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1851 
1852   g_return_val_if_fail (win32_channel != NULL, 0);
1853   g_return_val_if_fail (win32_channel-&gt;type == G_IO_WIN32_CONSOLE, 0);
1854 
1855   return g_io_win32_console_get_flags_internal (channel);
1856 }
1857 
1858 static GIOFlags
1859 g_io_win32_msg_get_flags (GIOChannel *channel)
1860 {
1861   return 0;
1862 }
1863 
1864 static GIOStatus
1865 g_io_win32_sock_set_flags (GIOChannel *channel,
<span class="line-modified">1866          GIOFlags    flags,</span>
<span class="line-modified">1867          GError    **err)</span>
1868 {
1869   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1870   u_long arg;
1871 
1872   if (win32_channel-&gt;debug)
1873     {
1874       g_print (&quot;g_io_win32_sock_set_flags: &quot;);
1875       g_win32_print_gioflags (flags);
1876       g_print (&quot;\n&quot;);
1877     }
1878 
1879   if (flags &amp; G_IO_FLAG_NONBLOCK)
1880     {
1881       arg = 1;
1882       if (ioctlsocket (win32_channel-&gt;fd, FIONBIO, &amp;arg) == SOCKET_ERROR)
<span class="line-modified">1883   {</span>
<span class="line-modified">1884     gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
1885 
<span class="line-modified">1886     g_set_error_literal (err, G_IO_CHANNEL_ERROR,</span>
<span class="line-modified">1887              G_IO_CHANNEL_ERROR_FAILED,</span>
<span class="line-modified">1888              emsg);</span>
<span class="line-modified">1889     g_free (emsg);</span>
1890 
<span class="line-modified">1891     return G_IO_STATUS_ERROR;</span>
<span class="line-modified">1892   }</span>
1893     }
1894   else
1895     {
1896       arg = 0;
1897       if (ioctlsocket (win32_channel-&gt;fd, FIONBIO, &amp;arg) == SOCKET_ERROR)
<span class="line-modified">1898   {</span>
<span class="line-modified">1899     gchar *emsg = g_win32_error_message (WSAGetLastError ());</span>
1900 
<span class="line-modified">1901     g_set_error_literal (err, G_IO_CHANNEL_ERROR,</span>
<span class="line-modified">1902              G_IO_CHANNEL_ERROR_FAILED,</span>
<span class="line-modified">1903              emsg);</span>
<span class="line-modified">1904     g_free (emsg);</span>
1905 
<span class="line-modified">1906     return G_IO_STATUS_ERROR;</span>
<span class="line-modified">1907   }</span>
1908     }
1909 
1910   return G_IO_STATUS_NORMAL;
1911 }
1912 
1913 static GIOFlags
1914 g_io_win32_sock_get_flags (GIOChannel *channel)
1915 {
1916   /* Could we do something here? */
1917   return 0;
1918 }
1919 
1920 static GIOFuncs win32_channel_msg_funcs = {
1921   g_io_win32_msg_read,
1922   g_io_win32_msg_write,
1923   NULL,
1924   g_io_win32_msg_close,
1925   g_io_win32_msg_create_watch,
1926   g_io_win32_free,
1927   g_io_win32_unimpl_set_flags,
</pre>
<hr />
<pre>
1969  *
1970  * This function creates a #GIOChannel that can be used to poll for
1971  * Windows messages for the window in question.
1972  *
1973  * Returns: a new #GIOChannel.
1974  **/
1975 GIOChannel *
1976 #if GLIB_SIZEOF_VOID_P == 8
1977 g_io_channel_win32_new_messages (gsize hwnd)
1978 #else
1979 g_io_channel_win32_new_messages (guint hwnd)
1980 #endif
1981 {
1982   GIOWin32Channel *win32_channel = g_new (GIOWin32Channel, 1);
1983   GIOChannel *channel = (GIOChannel *)win32_channel;
1984 
1985   g_io_channel_init (channel);
1986   g_io_channel_win32_init (win32_channel);
1987   if (win32_channel-&gt;debug)
1988     g_print (&quot;g_io_channel_win32_new_messages: channel=%p hwnd=%p\n&quot;,
<span class="line-modified">1989        channel, (HWND) hwnd);</span>
1990   channel-&gt;funcs = &amp;win32_channel_msg_funcs;
1991   win32_channel-&gt;type = G_IO_WIN32_WINDOWS_MESSAGES;
1992   win32_channel-&gt;hwnd = (HWND) hwnd;
1993 
1994   /* XXX: check this. */
1995   channel-&gt;is_readable = IsWindow (win32_channel-&gt;hwnd);
1996   channel-&gt;is_writeable = IsWindow (win32_channel-&gt;hwnd);
1997 
1998   channel-&gt;is_seekable = FALSE;
1999 
2000   return channel;
2001 }
2002 
2003 static GIOChannel *
2004 g_io_channel_win32_new_fd_internal (gint             fd,
<span class="line-modified">2005             struct _stati64 *st)</span>
2006 {
2007   GIOWin32Channel *win32_channel;
2008   GIOChannel *channel;
2009 
2010   win32_channel = g_new (GIOWin32Channel, 1);
2011   channel = (GIOChannel *)win32_channel;
2012 
2013   g_io_channel_init (channel);
2014   g_io_channel_win32_init (win32_channel);
2015 
2016   win32_channel-&gt;fd = fd;
2017 
2018   if (win32_channel-&gt;debug)
2019     g_print (&quot;g_io_channel_win32_new_fd: channel=%p fd=%u\n&quot;,
<span class="line-modified">2020        channel, fd);</span>
2021 
2022   if (st-&gt;st_mode &amp; _S_IFCHR) /* console */
2023     {
2024       channel-&gt;funcs = &amp;win32_channel_console_funcs;
2025       win32_channel-&gt;type = G_IO_WIN32_CONSOLE;
2026       g_io_win32_console_get_flags_internal (channel);
2027     }
2028   else
2029     {
2030       channel-&gt;funcs = &amp;win32_channel_fd_funcs;
2031       win32_channel-&gt;type = G_IO_WIN32_FILE_DESC;
2032       g_io_win32_fd_get_flags_internal (channel, st);
2033     }
2034 
2035   return channel;
2036 }
2037 
2038 /**
2039  * g_io_channel_win32_new_fd:
2040  * @fd: a C library file descriptor.
</pre>
<hr />
<pre>
2094  *
2095  * This function works for sockets created by Winsock. It&#39;s available
2096  * only in GLib on Windows.
2097  *
2098  * Polling a #GSource created to watch a channel for a socket puts the
2099  * socket in non-blocking mode. This is a side-effect of the
2100  * implementation and unavoidable.
2101  *
2102  * Returns: a new #GIOChannel
2103  **/
2104 GIOChannel *
2105 g_io_channel_win32_new_socket (int socket)
2106 {
2107   GIOWin32Channel *win32_channel = g_new (GIOWin32Channel, 1);
2108   GIOChannel *channel = (GIOChannel *)win32_channel;
2109 
2110   g_io_channel_init (channel);
2111   g_io_channel_win32_init (win32_channel);
2112   if (win32_channel-&gt;debug)
2113     g_print (&quot;g_io_channel_win32_new_socket: channel=%p sock=%d\n&quot;,
<span class="line-modified">2114        channel, socket);</span>
2115   channel-&gt;funcs = &amp;win32_channel_sock_funcs;
2116   win32_channel-&gt;type = G_IO_WIN32_SOCKET;
2117   win32_channel-&gt;fd = socket;
2118 
2119   channel-&gt;is_readable = TRUE;
2120   channel-&gt;is_writeable = TRUE;
2121   channel-&gt;is_seekable = FALSE;
2122 
2123   return channel;
2124 }
2125 
2126 GIOChannel *
2127 g_io_channel_unix_new (gint fd)
2128 {
2129   gboolean is_fd, is_socket;
2130   struct _stati64 st;
2131   int optval, optlen;
2132 
2133   is_fd = (_fstati64 (fd, &amp;st) == 0);
2134 
</pre>
<hr />
<pre>
2140 
2141   if (is_fd)
2142     return g_io_channel_win32_new_fd_internal (fd, &amp;st);
2143 
2144   if (is_socket)
2145     return g_io_channel_win32_new_socket(fd);
2146 
2147   g_warning (&quot;g_io_channel_unix_new: %d is neither a file descriptor or a socket.&quot;, fd);
2148 
2149   return NULL;
2150 }
2151 
2152 gint
2153 g_io_channel_unix_get_fd (GIOChannel *channel)
2154 {
2155   return g_io_channel_win32_get_fd (channel);
2156 }
2157 
2158 void
2159 g_io_channel_win32_set_debug (GIOChannel *channel,
<span class="line-modified">2160             gboolean    flag)</span>
2161 {
2162   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
2163 
2164   win32_channel-&gt;debug = flag;
2165 }
2166 
2167 gint
2168 g_io_channel_win32_poll (GPollFD *fds,
<span class="line-modified">2169        gint     n_fds,</span>
<span class="line-modified">2170        gint     timeout)</span>
2171 {
2172   g_return_val_if_fail (n_fds &gt;= 0, 0);
2173 
2174   return g_poll (fds, n_fds, timeout);
2175 }
2176 
2177 void
2178 g_io_channel_win32_make_pollfd (GIOChannel   *channel,
<span class="line-modified">2179         GIOCondition  condition,</span>
<span class="line-modified">2180         GPollFD      *fd)</span>
2181 {
2182   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
2183 
2184   switch (win32_channel-&gt;type)
2185     {
2186     case G_IO_WIN32_FILE_DESC:
2187       if (win32_channel-&gt;data_avail_event == NULL)
<span class="line-modified">2188   create_events (win32_channel);</span>
2189 
2190       fd-&gt;fd = (gintptr) win32_channel-&gt;data_avail_event;
2191 
2192       if (win32_channel-&gt;thread_id == 0)
<span class="line-modified">2193   {</span>
<span class="line-modified">2194     /* Is it meaningful for a file descriptor to be polled for</span>
<span class="line-modified">2195      * both IN and OUT? For what kind of file descriptor would</span>
<span class="line-modified">2196      * that be? Doesn&#39;t seem to make sense, in practise the file</span>
<span class="line-modified">2197      * descriptors handled here are always read or write ends of</span>
<span class="line-modified">2198      * pipes surely, and thus unidirectional.</span>
<span class="line-modified">2199      */</span>
<span class="line-modified">2200     if (condition &amp; G_IO_IN)</span>
<span class="line-modified">2201       create_thread (win32_channel, condition, read_thread);</span>
<span class="line-modified">2202     else if (condition &amp; G_IO_OUT)</span>
<span class="line-modified">2203       create_thread (win32_channel, condition, write_thread);</span>
<span class="line-modified">2204   }</span>
2205       break;
2206 
2207     case G_IO_WIN32_CONSOLE:
2208       fd-&gt;fd = _get_osfhandle (win32_channel-&gt;fd);
2209       break;
2210 
2211     case G_IO_WIN32_SOCKET:
2212       fd-&gt;fd = (gintptr) WSACreateEvent ();
2213       break;
2214 
2215     case G_IO_WIN32_WINDOWS_MESSAGES:
2216       fd-&gt;fd = G_WIN32_MSG_HANDLE;
2217       break;
2218 
2219     default:
2220       g_assert_not_reached ();
2221       g_abort ();
2222     }
2223 
2224   fd-&gt;events = condition;
</pre>
</td>
</tr>
</table>
<center><a href="giounix.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gkeyfile.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>