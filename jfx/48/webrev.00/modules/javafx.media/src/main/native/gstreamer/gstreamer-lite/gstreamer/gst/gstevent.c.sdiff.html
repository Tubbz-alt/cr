<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstevent.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gsterror.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstevent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstevent.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 211   return ret;
 212 }
 213 
 214 static void
 215 _gst_event_free (GstEvent * event)
 216 {
 217   GstStructure *s;
 218 
 219   g_return_if_fail (event != NULL);
 220   g_return_if_fail (GST_IS_EVENT (event));
 221 
 222   GST_CAT_LOG (GST_CAT_EVENT, &quot;freeing event %p type %s&quot;, event,
 223       GST_EVENT_TYPE_NAME (event));
 224 
 225   s = GST_EVENT_STRUCTURE (event);
 226 
 227   if (s) {
 228     gst_structure_set_parent_refcount (s, NULL);
 229     gst_structure_free (s);
 230   }



 231 
 232   g_slice_free1 (sizeof (GstEventImpl), event);
 233 }
 234 
 235 static void gst_event_init (GstEventImpl * event, GstEventType type);
 236 
 237 static GstEvent *
 238 _gst_event_copy (GstEvent * event)
 239 {
 240   GstEventImpl *copy;
 241   GstStructure *s;
 242 
 243   copy = g_slice_new0 (GstEventImpl);
 244 
 245   gst_event_init (copy, GST_EVENT_TYPE (event));
 246 
 247   GST_EVENT_TIMESTAMP (copy) = GST_EVENT_TIMESTAMP (event);
 248   GST_EVENT_SEQNUM (copy) = GST_EVENT_SEQNUM (event);
 249 
 250   s = GST_EVENT_STRUCTURE (event);
</pre>
<hr />
<pre>
 431   return GST_EVENT_SEQNUM (event);
 432 }
 433 
 434 /**
 435  * gst_event_set_seqnum:
 436  * @event: A #GstEvent.
 437  * @seqnum: A sequence number.
 438  *
 439  * Set the sequence number of a event.
 440  *
 441  * This function might be called by the creator of a event to indicate that the
 442  * event relates to other events or messages. See gst_event_get_seqnum() for
 443  * more information.
 444  *
 445  * MT safe.
 446  */
 447 void
 448 gst_event_set_seqnum (GstEvent * event, guint32 seqnum)
 449 {
 450   g_return_if_fail (GST_IS_EVENT (event));


 451 
 452   GST_EVENT_SEQNUM (event) = seqnum;
 453 }
 454 
 455 /**
 456  * gst_event_get_running_time_offset:
 457  * @event: A #GstEvent.
 458  *
 459  * Retrieve the accumulated running time offset of the event.
 460  *
 461  * Events passing through #GstPads that have a running time
 462  * offset set via gst_pad_set_offset() will get their offset
 463  * adjusted according to the pad&#39;s offset.
 464  *
 465  * If the event contains any information that related to the
 466  * running time, this information will need to be updated
 467  * before usage with this offset.
 468  *
 469  * Returns: The event&#39;s running time offset
 470  *
</pre>
<hr />
<pre>
 479 
 480   return ((GstEventImpl *) event)-&gt;running_time_offset;
 481 }
 482 
 483 /**
 484  * gst_event_set_running_time_offset:
 485  * @event: A #GstEvent.
 486  * @offset: A the new running time offset
 487  *
 488  * Set the running time offset of a event. See
 489  * gst_event_get_running_time_offset() for more information.
 490  *
 491  * MT safe.
 492  *
 493  * Since: 1.4
 494  */
 495 void
 496 gst_event_set_running_time_offset (GstEvent * event, gint64 offset)
 497 {
 498   g_return_if_fail (GST_IS_EVENT (event));

 499 
 500   ((GstEventImpl *) event)-&gt;running_time_offset = offset;
 501 }
 502 
 503 /**
 504  * gst_event_new_flush_start:
 505  *
 506  * Allocate a new flush start event. The flush start event can be sent
 507  * upstream and downstream and travels out-of-bounds with the dataflow.
 508  *
 509  * It marks pads as being flushing and will make them return
 510  * #GST_FLOW_FLUSHING when used for data flow with gst_pad_push(),
 511  * gst_pad_chain(), gst_pad_get_range() and gst_pad_pull_range().
 512  * Any event (except a #GST_EVENT_FLUSH_STOP) received
 513  * on a flushing pad will return %FALSE immediately.
 514  *
 515  * Elements should unlock any blocking functions and exit their streaming
 516  * functions as fast as possible when this event is received.
 517  *
 518  * This event is typically generated after a seek to flush out all queued data
</pre>
<hr />
<pre>
1248  * For negative rates, playback will start from the newly configured stop
1249  * position (if any). If the stop position is updated, it must be different from
1250  * -1 (#GST_CLOCK_TIME_NONE) for negative rates.
1251  *
1252  * It is not possible to seek relative to the current playback position, to do
1253  * this, PAUSE the pipeline, query the current playback position with
1254  * #GST_QUERY_POSITION and update the playback segment current position with a
1255  * #GST_SEEK_TYPE_SET to the desired position.
1256  *
1257  * Returns: (transfer full) (nullable): a new seek event.
1258  */
1259 GstEvent *
1260 gst_event_new_seek (gdouble rate, GstFormat format, GstSeekFlags flags,
1261     GstSeekType start_type, gint64 start, GstSeekType stop_type, gint64 stop)
1262 {
1263   GstEvent *event;
1264   GstStructure *structure;
1265 
1266   g_return_val_if_fail (rate != 0.0, NULL);
1267 












1268   if (format == GST_FORMAT_TIME) {
1269     GST_CAT_INFO (GST_CAT_EVENT,
1270         &quot;creating seek rate %lf, format TIME, flags %d, &quot;
1271         &quot;start_type %d, start %&quot; GST_TIME_FORMAT &quot;, &quot;
1272         &quot;stop_type %d, stop %&quot; GST_TIME_FORMAT,
1273         rate, flags, start_type, GST_TIME_ARGS (start),
1274         stop_type, GST_TIME_ARGS (stop));
1275   } else {
1276     GST_CAT_INFO (GST_CAT_EVENT,
1277         &quot;creating seek rate %lf, format %s, flags %d, &quot;
1278         &quot;start_type %d, start %&quot; G_GINT64_FORMAT &quot;, &quot;
1279         &quot;stop_type %d, stop %&quot; G_GINT64_FORMAT,
1280         rate, gst_format_get_name (format), flags, start_type, start, stop_type,
1281         stop);
1282   }
1283 
1284   structure = gst_structure_new_id (GST_QUARK (EVENT_SEEK),
1285       GST_QUARK (RATE), G_TYPE_DOUBLE, rate,
1286       GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,
1287       GST_QUARK (FLAGS), GST_TYPE_SEEK_FLAGS, flags,
1288       GST_QUARK (CUR_TYPE), GST_TYPE_SEEK_TYPE, start_type,
1289       GST_QUARK (CUR), G_TYPE_INT64, start,
1290       GST_QUARK (STOP_TYPE), GST_TYPE_SEEK_TYPE, stop_type,
<span class="line-modified">1291       GST_QUARK (STOP), G_TYPE_INT64, stop, NULL);</span>


1292   event = gst_event_new_custom (GST_EVENT_SEEK, structure);
1293 
1294   return event;
1295 }
1296 
1297 /**
1298  * gst_event_parse_seek:
1299  * @event: a seek event
1300  * @rate: (out): result location for the rate
1301  * @format: (out): result location for the stream format
1302  * @flags:  (out): result location for the #GstSeekFlags
1303  * @start_type: (out): result location for the #GstSeekType of the start position
1304  * @start: (out): result location for the start position expressed in @format
1305  * @stop_type:  (out): result location for the #GstSeekType of the stop position
1306  * @stop: (out): result location for the stop position expressed in @format
1307  *
1308  * Parses a seek @event and stores the results in the given result locations.
1309  */
1310 void
1311 gst_event_parse_seek (GstEvent * event, gdouble * rate,
</pre>
<hr />
<pre>
1331         g_value_get_flags (gst_structure_id_get_value (structure,
1332             GST_QUARK (FLAGS)));
1333   if (start_type)
1334     *start_type = (GstSeekType)
1335         g_value_get_enum (gst_structure_id_get_value (structure,
1336             GST_QUARK (CUR_TYPE)));
1337   if (start)
1338     *start =
1339         g_value_get_int64 (gst_structure_id_get_value (structure,
1340             GST_QUARK (CUR)));
1341   if (stop_type)
1342     *stop_type = (GstSeekType)
1343         g_value_get_enum (gst_structure_id_get_value (structure,
1344             GST_QUARK (STOP_TYPE)));
1345   if (stop)
1346     *stop =
1347         g_value_get_int64 (gst_structure_id_get_value (structure,
1348             GST_QUARK (STOP)));
1349 }
1350 










































1351 /**
1352  * gst_event_new_navigation:
1353  * @structure: (transfer full): description of the event. The event will take
1354  *     ownership of the structure.
1355  *
1356  * Create a new navigation event from the given description.
1357  *
1358  * Returns: (transfer full): a new #GstEvent
1359  */
1360 GstEvent *
1361 gst_event_new_navigation (GstStructure * structure)
1362 {
1363   g_return_val_if_fail (structure != NULL, NULL);
1364 
1365   return gst_event_new_custom (GST_EVENT_NAVIGATION, structure);
1366 }
1367 
1368 /**
1369  * gst_event_new_latency:
1370  * @latency: the new latency value
</pre>
<hr />
<pre>
1648  * @stream: (transfer none): the stream object to set
1649  *
1650  * Set the @stream on the stream-start @event
1651  *
1652  * Since: 1.10
1653  */
1654 void
1655 gst_event_set_stream (GstEvent * event, GstStream * stream)
1656 {
1657   g_return_if_fail (event != NULL);
1658   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START);
1659   g_return_if_fail (gst_event_is_writable (event));
1660 
1661   gst_structure_id_set (GST_EVENT_STRUCTURE (event),
1662       GST_QUARK (STREAM), GST_TYPE_STREAM, stream, NULL);
1663 }
1664 
1665 /**
1666  * gst_event_parse_stream:
1667  * @event: a stream-start event
<span class="line-modified">1668  * @stream: (out) (transfer full): adress of variable to store the stream</span>
1669  *
1670  * Parse a stream-start @event and extract the #GstStream from it.
1671  *
1672  * Since: 1.10
1673  */
1674 void
1675 gst_event_parse_stream (GstEvent * event, GstStream ** stream)
1676 {
1677   g_return_if_fail (event != NULL);
1678   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START);
1679 
1680   if (stream) {
1681     gst_structure_id_get (GST_EVENT_STRUCTURE (event),
1682         GST_QUARK (STREAM), GST_TYPE_STREAM, stream, NULL);
1683   }
1684 
1685 }
1686 
1687 /**
1688  * gst_event_set_stream_flags:
</pre>
</td>
<td>
<hr />
<pre>
 211   return ret;
 212 }
 213 
 214 static void
 215 _gst_event_free (GstEvent * event)
 216 {
 217   GstStructure *s;
 218 
 219   g_return_if_fail (event != NULL);
 220   g_return_if_fail (GST_IS_EVENT (event));
 221 
 222   GST_CAT_LOG (GST_CAT_EVENT, &quot;freeing event %p type %s&quot;, event,
 223       GST_EVENT_TYPE_NAME (event));
 224 
 225   s = GST_EVENT_STRUCTURE (event);
 226 
 227   if (s) {
 228     gst_structure_set_parent_refcount (s, NULL);
 229     gst_structure_free (s);
 230   }
<span class="line-added"> 231 #ifdef USE_POISONING</span>
<span class="line-added"> 232   memset (event, 0xff, sizeof (GstEventImpl));</span>
<span class="line-added"> 233 #endif</span>
 234 
 235   g_slice_free1 (sizeof (GstEventImpl), event);
 236 }
 237 
 238 static void gst_event_init (GstEventImpl * event, GstEventType type);
 239 
 240 static GstEvent *
 241 _gst_event_copy (GstEvent * event)
 242 {
 243   GstEventImpl *copy;
 244   GstStructure *s;
 245 
 246   copy = g_slice_new0 (GstEventImpl);
 247 
 248   gst_event_init (copy, GST_EVENT_TYPE (event));
 249 
 250   GST_EVENT_TIMESTAMP (copy) = GST_EVENT_TIMESTAMP (event);
 251   GST_EVENT_SEQNUM (copy) = GST_EVENT_SEQNUM (event);
 252 
 253   s = GST_EVENT_STRUCTURE (event);
</pre>
<hr />
<pre>
 434   return GST_EVENT_SEQNUM (event);
 435 }
 436 
 437 /**
 438  * gst_event_set_seqnum:
 439  * @event: A #GstEvent.
 440  * @seqnum: A sequence number.
 441  *
 442  * Set the sequence number of a event.
 443  *
 444  * This function might be called by the creator of a event to indicate that the
 445  * event relates to other events or messages. See gst_event_get_seqnum() for
 446  * more information.
 447  *
 448  * MT safe.
 449  */
 450 void
 451 gst_event_set_seqnum (GstEvent * event, guint32 seqnum)
 452 {
 453   g_return_if_fail (GST_IS_EVENT (event));
<span class="line-added"> 454   g_return_if_fail (seqnum != GST_SEQNUM_INVALID);</span>
<span class="line-added"> 455   g_return_if_fail (gst_event_is_writable (event));</span>
 456 
 457   GST_EVENT_SEQNUM (event) = seqnum;
 458 }
 459 
 460 /**
 461  * gst_event_get_running_time_offset:
 462  * @event: A #GstEvent.
 463  *
 464  * Retrieve the accumulated running time offset of the event.
 465  *
 466  * Events passing through #GstPads that have a running time
 467  * offset set via gst_pad_set_offset() will get their offset
 468  * adjusted according to the pad&#39;s offset.
 469  *
 470  * If the event contains any information that related to the
 471  * running time, this information will need to be updated
 472  * before usage with this offset.
 473  *
 474  * Returns: The event&#39;s running time offset
 475  *
</pre>
<hr />
<pre>
 484 
 485   return ((GstEventImpl *) event)-&gt;running_time_offset;
 486 }
 487 
 488 /**
 489  * gst_event_set_running_time_offset:
 490  * @event: A #GstEvent.
 491  * @offset: A the new running time offset
 492  *
 493  * Set the running time offset of a event. See
 494  * gst_event_get_running_time_offset() for more information.
 495  *
 496  * MT safe.
 497  *
 498  * Since: 1.4
 499  */
 500 void
 501 gst_event_set_running_time_offset (GstEvent * event, gint64 offset)
 502 {
 503   g_return_if_fail (GST_IS_EVENT (event));
<span class="line-added"> 504   g_return_if_fail (gst_event_is_writable (event));</span>
 505 
 506   ((GstEventImpl *) event)-&gt;running_time_offset = offset;
 507 }
 508 
 509 /**
 510  * gst_event_new_flush_start:
 511  *
 512  * Allocate a new flush start event. The flush start event can be sent
 513  * upstream and downstream and travels out-of-bounds with the dataflow.
 514  *
 515  * It marks pads as being flushing and will make them return
 516  * #GST_FLOW_FLUSHING when used for data flow with gst_pad_push(),
 517  * gst_pad_chain(), gst_pad_get_range() and gst_pad_pull_range().
 518  * Any event (except a #GST_EVENT_FLUSH_STOP) received
 519  * on a flushing pad will return %FALSE immediately.
 520  *
 521  * Elements should unlock any blocking functions and exit their streaming
 522  * functions as fast as possible when this event is received.
 523  *
 524  * This event is typically generated after a seek to flush out all queued data
</pre>
<hr />
<pre>
1254  * For negative rates, playback will start from the newly configured stop
1255  * position (if any). If the stop position is updated, it must be different from
1256  * -1 (#GST_CLOCK_TIME_NONE) for negative rates.
1257  *
1258  * It is not possible to seek relative to the current playback position, to do
1259  * this, PAUSE the pipeline, query the current playback position with
1260  * #GST_QUERY_POSITION and update the playback segment current position with a
1261  * #GST_SEEK_TYPE_SET to the desired position.
1262  *
1263  * Returns: (transfer full) (nullable): a new seek event.
1264  */
1265 GstEvent *
1266 gst_event_new_seek (gdouble rate, GstFormat format, GstSeekFlags flags,
1267     GstSeekType start_type, gint64 start, GstSeekType stop_type, gint64 stop)
1268 {
1269   GstEvent *event;
1270   GstStructure *structure;
1271 
1272   g_return_val_if_fail (rate != 0.0, NULL);
1273 
<span class="line-added">1274   /* SNAP flags only make sense in combination with the KEYUNIT flag. Warn</span>
<span class="line-added">1275    * and unset the SNAP flags if they&#39;re set without the KEYUNIT flag */</span>
<span class="line-added">1276   if (!(flags &amp; GST_SEEK_FLAG_KEY_UNIT) &amp;&amp;</span>
<span class="line-added">1277       (flags &amp; (GST_SEEK_FLAG_SNAP_BEFORE | GST_SEEK_FLAG_SNAP_AFTER |</span>
<span class="line-added">1278               GST_SEEK_FLAG_SNAP_NEAREST))) {</span>
<span class="line-added">1279     g_warning (&quot;SNAP seeks only work in combination with the KEY_UNIT &quot;</span>
<span class="line-added">1280         &quot;flag, ignoring SNAP flags&quot;);</span>
<span class="line-added">1281     flags &amp;=</span>
<span class="line-added">1282         ~(GST_SEEK_FLAG_SNAP_BEFORE | GST_SEEK_FLAG_SNAP_AFTER |</span>
<span class="line-added">1283         GST_SEEK_FLAG_SNAP_NEAREST);</span>
<span class="line-added">1284   }</span>
<span class="line-added">1285 </span>
1286   if (format == GST_FORMAT_TIME) {
1287     GST_CAT_INFO (GST_CAT_EVENT,
1288         &quot;creating seek rate %lf, format TIME, flags %d, &quot;
1289         &quot;start_type %d, start %&quot; GST_TIME_FORMAT &quot;, &quot;
1290         &quot;stop_type %d, stop %&quot; GST_TIME_FORMAT,
1291         rate, flags, start_type, GST_TIME_ARGS (start),
1292         stop_type, GST_TIME_ARGS (stop));
1293   } else {
1294     GST_CAT_INFO (GST_CAT_EVENT,
1295         &quot;creating seek rate %lf, format %s, flags %d, &quot;
1296         &quot;start_type %d, start %&quot; G_GINT64_FORMAT &quot;, &quot;
1297         &quot;stop_type %d, stop %&quot; G_GINT64_FORMAT,
1298         rate, gst_format_get_name (format), flags, start_type, start, stop_type,
1299         stop);
1300   }
1301 
1302   structure = gst_structure_new_id (GST_QUARK (EVENT_SEEK),
1303       GST_QUARK (RATE), G_TYPE_DOUBLE, rate,
1304       GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,
1305       GST_QUARK (FLAGS), GST_TYPE_SEEK_FLAGS, flags,
1306       GST_QUARK (CUR_TYPE), GST_TYPE_SEEK_TYPE, start_type,
1307       GST_QUARK (CUR), G_TYPE_INT64, start,
1308       GST_QUARK (STOP_TYPE), GST_TYPE_SEEK_TYPE, stop_type,
<span class="line-modified">1309       GST_QUARK (STOP), G_TYPE_INT64, stop,</span>
<span class="line-added">1310       GST_QUARK (TRICKMODE_INTERVAL), GST_TYPE_CLOCK_TIME, (GstClockTime) 0,</span>
<span class="line-added">1311       NULL);</span>
1312   event = gst_event_new_custom (GST_EVENT_SEEK, structure);
1313 
1314   return event;
1315 }
1316 
1317 /**
1318  * gst_event_parse_seek:
1319  * @event: a seek event
1320  * @rate: (out): result location for the rate
1321  * @format: (out): result location for the stream format
1322  * @flags:  (out): result location for the #GstSeekFlags
1323  * @start_type: (out): result location for the #GstSeekType of the start position
1324  * @start: (out): result location for the start position expressed in @format
1325  * @stop_type:  (out): result location for the #GstSeekType of the stop position
1326  * @stop: (out): result location for the stop position expressed in @format
1327  *
1328  * Parses a seek @event and stores the results in the given result locations.
1329  */
1330 void
1331 gst_event_parse_seek (GstEvent * event, gdouble * rate,
</pre>
<hr />
<pre>
1351         g_value_get_flags (gst_structure_id_get_value (structure,
1352             GST_QUARK (FLAGS)));
1353   if (start_type)
1354     *start_type = (GstSeekType)
1355         g_value_get_enum (gst_structure_id_get_value (structure,
1356             GST_QUARK (CUR_TYPE)));
1357   if (start)
1358     *start =
1359         g_value_get_int64 (gst_structure_id_get_value (structure,
1360             GST_QUARK (CUR)));
1361   if (stop_type)
1362     *stop_type = (GstSeekType)
1363         g_value_get_enum (gst_structure_id_get_value (structure,
1364             GST_QUARK (STOP_TYPE)));
1365   if (stop)
1366     *stop =
1367         g_value_get_int64 (gst_structure_id_get_value (structure,
1368             GST_QUARK (STOP)));
1369 }
1370 
<span class="line-added">1371 /**</span>
<span class="line-added">1372  * gst_event_set_seek_trickmode_interval:</span>
<span class="line-added">1373  *</span>
<span class="line-added">1374  * Sets a trickmode interval on a (writable) seek event. Elements</span>
<span class="line-added">1375  * that support TRICKMODE_KEY_UNITS seeks SHOULD use this as the minimal</span>
<span class="line-added">1376  * interval between each frame they may output.</span>
<span class="line-added">1377  *</span>
<span class="line-added">1378  * Since: 1.16</span>
<span class="line-added">1379  */</span>
<span class="line-added">1380 void</span>
<span class="line-added">1381 gst_event_set_seek_trickmode_interval (GstEvent * event, GstClockTime interval)</span>
<span class="line-added">1382 {</span>
<span class="line-added">1383   g_return_if_fail (event != NULL);</span>
<span class="line-added">1384   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_SEEK);</span>
<span class="line-added">1385   g_return_if_fail (gst_event_is_writable (event));</span>
<span class="line-added">1386   g_return_if_fail (GST_CLOCK_TIME_IS_VALID (interval));</span>
<span class="line-added">1387 </span>
<span class="line-added">1388   gst_structure_id_set (GST_EVENT_STRUCTURE (event),</span>
<span class="line-added">1389       GST_QUARK (TRICKMODE_INTERVAL), GST_TYPE_CLOCK_TIME, interval, NULL);</span>
<span class="line-added">1390 }</span>
<span class="line-added">1391 </span>
<span class="line-added">1392 /**</span>
<span class="line-added">1393  * gst_event_parse_seek_trickmode_interval:</span>
<span class="line-added">1394  * @interval: (out)</span>
<span class="line-added">1395  *</span>
<span class="line-added">1396  * Retrieve the trickmode interval that may have been set on a</span>
<span class="line-added">1397  * seek event with gst_event_set_seek_trickmode_interval().</span>
<span class="line-added">1398  *</span>
<span class="line-added">1399  * Since: 1.16</span>
<span class="line-added">1400  */</span>
<span class="line-added">1401 void</span>
<span class="line-added">1402 gst_event_parse_seek_trickmode_interval (GstEvent * event,</span>
<span class="line-added">1403     GstClockTime * interval)</span>
<span class="line-added">1404 {</span>
<span class="line-added">1405   g_return_if_fail (event != NULL);</span>
<span class="line-added">1406   g_return_if_fail (interval != NULL);</span>
<span class="line-added">1407   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_SEEK);</span>
<span class="line-added">1408 </span>
<span class="line-added">1409   gst_structure_id_get (GST_EVENT_STRUCTURE (event),</span>
<span class="line-added">1410       GST_QUARK (TRICKMODE_INTERVAL), GST_TYPE_CLOCK_TIME, interval, NULL);</span>
<span class="line-added">1411 }</span>
<span class="line-added">1412 </span>
1413 /**
1414  * gst_event_new_navigation:
1415  * @structure: (transfer full): description of the event. The event will take
1416  *     ownership of the structure.
1417  *
1418  * Create a new navigation event from the given description.
1419  *
1420  * Returns: (transfer full): a new #GstEvent
1421  */
1422 GstEvent *
1423 gst_event_new_navigation (GstStructure * structure)
1424 {
1425   g_return_val_if_fail (structure != NULL, NULL);
1426 
1427   return gst_event_new_custom (GST_EVENT_NAVIGATION, structure);
1428 }
1429 
1430 /**
1431  * gst_event_new_latency:
1432  * @latency: the new latency value
</pre>
<hr />
<pre>
1710  * @stream: (transfer none): the stream object to set
1711  *
1712  * Set the @stream on the stream-start @event
1713  *
1714  * Since: 1.10
1715  */
1716 void
1717 gst_event_set_stream (GstEvent * event, GstStream * stream)
1718 {
1719   g_return_if_fail (event != NULL);
1720   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START);
1721   g_return_if_fail (gst_event_is_writable (event));
1722 
1723   gst_structure_id_set (GST_EVENT_STRUCTURE (event),
1724       GST_QUARK (STREAM), GST_TYPE_STREAM, stream, NULL);
1725 }
1726 
1727 /**
1728  * gst_event_parse_stream:
1729  * @event: a stream-start event
<span class="line-modified">1730  * @stream: (out) (transfer full): address of variable to store the stream</span>
1731  *
1732  * Parse a stream-start @event and extract the #GstStream from it.
1733  *
1734  * Since: 1.10
1735  */
1736 void
1737 gst_event_parse_stream (GstEvent * event, GstStream ** stream)
1738 {
1739   g_return_if_fail (event != NULL);
1740   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START);
1741 
1742   if (stream) {
1743     gst_structure_id_get (GST_EVENT_STRUCTURE (event),
1744         GST_QUARK (STREAM), GST_TYPE_STREAM, stream, NULL);
1745   }
1746 
1747 }
1748 
1749 /**
1750  * gst_event_set_stream_flags:
</pre>
</td>
</tr>
</table>
<center><a href="gsterror.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstevent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>