<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gunidecomp.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gunicollate.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gunidecomp.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gunidecomp.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 105,43 ***</span>
   * according to their combining classes.  See the Unicode
   * manual for more information.
   **/
  void
  g_unicode_canonical_ordering (gunichar *string,
<span class="line-modified">!                   gsize     len)</span>
  {
    gsize i;
    int swap = 1;
  
    while (swap)
      {
        int last;
        swap = 0;
        last = COMBINING_CLASS (string[0]);
        for (i = 0; i &lt; len - 1; ++i)
      {
<span class="line-modified">!       int next = COMBINING_CLASS (string[i + 1]);</span>
<span class="line-modified">!       if (next != 0 &amp;&amp; last &gt; next)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           gsize j;</span>
<span class="line-modified">!           /* Percolate item leftward through string.  */</span>
<span class="line-modified">!           for (j = i + 1; j &gt; 0; --j)</span>
<span class="line-modified">!         {</span>
<span class="line-removed">-           gunichar t;</span>
<span class="line-removed">-           if (COMBINING_CLASS (string[j - 1]) &lt;= next)</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-           t = string[j];</span>
<span class="line-removed">-           string[j] = string[j - 1];</span>
<span class="line-removed">-           string[j - 1] = t;</span>
<span class="line-removed">-           swap = 1;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-           /* We&#39;re re-entering the loop looking at the old</span>
<span class="line-removed">-          character again.  */</span>
<span class="line-removed">-           next = last;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       last = next;</span>
      }
      }
  }
  
  /* http://www.unicode.org/unicode/reports/tr15/#Hangul
   * r should be null or have sufficient space. Calling with r == NULL will
<span class="line-new-header">--- 105,43 ---</span>
   * according to their combining classes.  See the Unicode
   * manual for more information.
   **/
  void
  g_unicode_canonical_ordering (gunichar *string,
<span class="line-modified">!             gsize     len)</span>
  {
    gsize i;
    int swap = 1;
  
    while (swap)
      {
        int last;
        swap = 0;
        last = COMBINING_CLASS (string[0]);
        for (i = 0; i &lt; len - 1; ++i)
<span class="line-added">+   {</span>
<span class="line-added">+     int next = COMBINING_CLASS (string[i + 1]);</span>
<span class="line-added">+     if (next != 0 &amp;&amp; last &gt; next)</span>
<span class="line-added">+       {</span>
<span class="line-added">+         gsize j;</span>
<span class="line-added">+         /* Percolate item leftward through string.  */</span>
<span class="line-added">+         for (j = i + 1; j &gt; 0; --j)</span>
      {
<span class="line-modified">!       gunichar t;</span>
<span class="line-modified">!       if (COMBINING_CLASS (string[j - 1]) &lt;= next)</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       t = string[j];</span>
<span class="line-modified">!       string[j] = string[j - 1];</span>
<span class="line-modified">!       string[j - 1] = t;</span>
<span class="line-modified">!       swap = 1;</span>
      }
<span class="line-added">+         /* We&#39;re re-entering the loop looking at the old</span>
<span class="line-added">+      character again.  */</span>
<span class="line-added">+         next = last;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     last = next;</span>
<span class="line-added">+   }</span>
      }
  }
  
  /* http://www.unicode.org/unicode/reports/tr15/#Hangul
   * r should be null or have sufficient space. Calling with r == NULL will
</pre>
<hr />
<pre>
<span class="line-old-header">*** 162,57 ***</span>
      }
  
    if (TIndex)
      {
        if (r)
<span class="line-modified">!     r[2] = TBase + TIndex;</span>
        *result_len = 3;
      }
    else
      *result_len = 2;
  }
  
  /* returns a pointer to a null-terminated UTF-8 string */
  static const gchar *
  find_decomposition (gunichar ch,
<span class="line-modified">!             gboolean compat)</span>
  {
    int start = 0;
    int end = G_N_ELEMENTS (decomp_table);
  
    if (ch &gt;= decomp_table[start].ch &amp;&amp;
        ch &lt;= decomp_table[end - 1].ch)
      {
        while (TRUE)
<span class="line-modified">!     {</span>
<span class="line-modified">!       int half = (start + end) / 2;</span>
<span class="line-modified">!       if (ch == decomp_table[half].ch)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           int offset;</span>
  
<span class="line-modified">!           if (compat)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           offset = decomp_table[half].compat_offset;</span>
<span class="line-modified">!           if (offset == G_UNICODE_NOT_PRESENT_OFFSET)</span>
<span class="line-modified">!             offset = decomp_table[half].canon_offset;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!           else</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           offset = decomp_table[half].canon_offset;</span>
<span class="line-modified">!           if (offset == G_UNICODE_NOT_PRESENT_OFFSET)</span>
<span class="line-modified">!             return NULL;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-           return &amp;(decomp_expansion_string[offset]);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       else if (half == start)</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       else if (ch &gt; decomp_table[half].ch)</span>
<span class="line-removed">-         start = half;</span>
<span class="line-removed">-       else</span>
<span class="line-removed">-         end = half;</span>
      }
      }
  
    return NULL;
  }
  
<span class="line-new-header">--- 162,57 ---</span>
      }
  
    if (TIndex)
      {
        if (r)
<span class="line-modified">!   r[2] = TBase + TIndex;</span>
        *result_len = 3;
      }
    else
      *result_len = 2;
  }
  
  /* returns a pointer to a null-terminated UTF-8 string */
  static const gchar *
  find_decomposition (gunichar ch,
<span class="line-modified">!         gboolean compat)</span>
  {
    int start = 0;
    int end = G_N_ELEMENTS (decomp_table);
  
    if (ch &gt;= decomp_table[start].ch &amp;&amp;
        ch &lt;= decomp_table[end - 1].ch)
      {
        while (TRUE)
<span class="line-modified">!   {</span>
<span class="line-modified">!     int half = (start + end) / 2;</span>
<span class="line-modified">!     if (ch == decomp_table[half].ch)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         int offset;</span>
  
<span class="line-modified">!         if (compat)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       offset = decomp_table[half].compat_offset;</span>
<span class="line-modified">!       if (offset == G_UNICODE_NOT_PRESENT_OFFSET)</span>
<span class="line-modified">!         offset = decomp_table[half].canon_offset;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       offset = decomp_table[half].canon_offset;</span>
<span class="line-modified">!       if (offset == G_UNICODE_NOT_PRESENT_OFFSET)</span>
<span class="line-modified">!         return NULL;</span>
      }
<span class="line-added">+ </span>
<span class="line-added">+         return &amp;(decomp_expansion_string[offset]);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     else if (half == start)</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     else if (ch &gt; decomp_table[half].ch)</span>
<span class="line-added">+       start = half;</span>
<span class="line-added">+     else</span>
<span class="line-added">+       end = half;</span>
<span class="line-added">+   }</span>
      }
  
    return NULL;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 229,11 ***</span>
   * Deprecated: 2.30: Use the more flexible g_unichar_fully_decompose()
   *   instead.
   **/
  gunichar *
  g_unicode_canonical_decomposition (gunichar ch,
<span class="line-modified">!                    gsize   *result_len)</span>
  {
    const gchar *decomp;
    const gchar *p;
    gunichar *r;
  
<span class="line-new-header">--- 229,11 ---</span>
   * Deprecated: 2.30: Use the more flexible g_unichar_fully_decompose()
   *   instead.
   **/
  gunichar *
  g_unicode_canonical_decomposition (gunichar ch,
<span class="line-modified">!            gsize   *result_len)</span>
  {
    const gchar *decomp;
    const gchar *p;
    gunichar *r;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 306,12 ***</span>
  #define COMPOSE_INDEX(Char) \
       (((Char &gt;&gt; 8) &gt; (COMPOSE_TABLE_LAST)) ? 0 : CI((Char) &gt;&gt; 8, (Char) &amp; 0xff))
  
  static gboolean
  combine (gunichar  a,
<span class="line-modified">!      gunichar  b,</span>
<span class="line-modified">!      gunichar *result)</span>
  {
    gushort index_a, index_b;
  
    if (combine_hangul (a, b, result))
      return TRUE;
<span class="line-new-header">--- 306,12 ---</span>
  #define COMPOSE_INDEX(Char) \
       (((Char &gt;&gt; 8) &gt; (COMPOSE_TABLE_LAST)) ? 0 : CI((Char) &gt;&gt; 8, (Char) &amp; 0xff))
  
  static gboolean
  combine (gunichar  a,
<span class="line-modified">!    gunichar  b,</span>
<span class="line-modified">!    gunichar *result)</span>
  {
    gushort index_a, index_b;
  
    if (combine_hangul (a, b, result))
      return TRUE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 319,59 ***</span>
    index_a = COMPOSE_INDEX(a);
  
    if (index_a &gt;= COMPOSE_FIRST_SINGLE_START &amp;&amp; index_a &lt; COMPOSE_SECOND_START)
      {
        if (b == compose_first_single[index_a - COMPOSE_FIRST_SINGLE_START][0])
<span class="line-modified">!     {</span>
<span class="line-modified">!       *result = compose_first_single[index_a - COMPOSE_FIRST_SINGLE_START][1];</span>
<span class="line-modified">!       return TRUE;</span>
<span class="line-modified">!     }</span>
        else
          return FALSE;
      }
  
    index_b = COMPOSE_INDEX(b);
  
    if (index_b &gt;= COMPOSE_SECOND_SINGLE_START)
      {
        if (a == compose_second_single[index_b - COMPOSE_SECOND_SINGLE_START][0])
<span class="line-modified">!     {</span>
<span class="line-modified">!       *result = compose_second_single[index_b - COMPOSE_SECOND_SINGLE_START][1];</span>
<span class="line-modified">!       return TRUE;</span>
<span class="line-modified">!     }</span>
        else
          return FALSE;
      }
  
    if (index_a &gt;= COMPOSE_FIRST_START &amp;&amp; index_a &lt; COMPOSE_FIRST_SINGLE_START &amp;&amp;
        index_b &gt;= COMPOSE_SECOND_START &amp;&amp; index_b &lt; COMPOSE_SECOND_SINGLE_START)
      {
        gunichar res = compose_array[index_a - COMPOSE_FIRST_START][index_b - COMPOSE_SECOND_START];
  
        if (res)
<span class="line-modified">!     {</span>
<span class="line-modified">!       *result = res;</span>
<span class="line-modified">!       return TRUE;</span>
<span class="line-modified">!     }</span>
      }
  
    return FALSE;
  }
  
  gunichar *
  _g_utf8_normalize_wc (const gchar    *str,
<span class="line-modified">!               gssize          max_len,</span>
<span class="line-modified">!               GNormalizeMode  mode)</span>
  {
    gsize n_wc;
    gunichar *wc_buffer;
    const char *p;
    gsize last_start;
    gboolean do_compat = (mode == G_NORMALIZE_NFKC ||
<span class="line-modified">!             mode == G_NORMALIZE_NFKD);</span>
    gboolean do_compose = (mode == G_NORMALIZE_NFC ||
<span class="line-modified">!              mode == G_NORMALIZE_NFKC);</span>
  
    n_wc = 0;
    p = str;
    while ((max_len &lt; 0 || p &lt; str + max_len) &amp;&amp; *p)
      {
<span class="line-new-header">--- 319,59 ---</span>
    index_a = COMPOSE_INDEX(a);
  
    if (index_a &gt;= COMPOSE_FIRST_SINGLE_START &amp;&amp; index_a &lt; COMPOSE_SECOND_START)
      {
        if (b == compose_first_single[index_a - COMPOSE_FIRST_SINGLE_START][0])
<span class="line-modified">!   {</span>
<span class="line-modified">!     *result = compose_first_single[index_a - COMPOSE_FIRST_SINGLE_START][1];</span>
<span class="line-modified">!     return TRUE;</span>
<span class="line-modified">!   }</span>
        else
          return FALSE;
      }
  
    index_b = COMPOSE_INDEX(b);
  
    if (index_b &gt;= COMPOSE_SECOND_SINGLE_START)
      {
        if (a == compose_second_single[index_b - COMPOSE_SECOND_SINGLE_START][0])
<span class="line-modified">!   {</span>
<span class="line-modified">!     *result = compose_second_single[index_b - COMPOSE_SECOND_SINGLE_START][1];</span>
<span class="line-modified">!     return TRUE;</span>
<span class="line-modified">!   }</span>
        else
          return FALSE;
      }
  
    if (index_a &gt;= COMPOSE_FIRST_START &amp;&amp; index_a &lt; COMPOSE_FIRST_SINGLE_START &amp;&amp;
        index_b &gt;= COMPOSE_SECOND_START &amp;&amp; index_b &lt; COMPOSE_SECOND_SINGLE_START)
      {
        gunichar res = compose_array[index_a - COMPOSE_FIRST_START][index_b - COMPOSE_SECOND_START];
  
        if (res)
<span class="line-modified">!   {</span>
<span class="line-modified">!     *result = res;</span>
<span class="line-modified">!     return TRUE;</span>
<span class="line-modified">!   }</span>
      }
  
    return FALSE;
  }
  
  gunichar *
  _g_utf8_normalize_wc (const gchar    *str,
<span class="line-modified">!           gssize          max_len,</span>
<span class="line-modified">!           GNormalizeMode  mode)</span>
  {
    gsize n_wc;
    gunichar *wc_buffer;
    const char *p;
    gsize last_start;
    gboolean do_compat = (mode == G_NORMALIZE_NFKC ||
<span class="line-modified">!       mode == G_NORMALIZE_NFKD);</span>
    gboolean do_compose = (mode == G_NORMALIZE_NFC ||
<span class="line-modified">!        mode == G_NORMALIZE_NFKC);</span>
  
    n_wc = 0;
    p = str;
    while ((max_len &lt; 0 || p &lt; str + max_len) &amp;&amp; *p)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 428,19 ***</span>
            else
              wc_buffer[n_wc++] = wc;
          }
  
        if (n_wc &gt; 0)
<span class="line-modified">!     {</span>
<span class="line-modified">!       cc = COMBINING_CLASS (wc_buffer[old_n_wc]);</span>
  
<span class="line-modified">!       if (cc == 0)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           g_unicode_canonical_ordering (wc_buffer + last_start, n_wc - last_start);</span>
<span class="line-modified">!           last_start = old_n_wc;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
  
        p = g_utf8_next_char (p);
      }
  
    if (n_wc &gt; 0)
<span class="line-new-header">--- 428,19 ---</span>
            else
              wc_buffer[n_wc++] = wc;
          }
  
        if (n_wc &gt; 0)
<span class="line-modified">!   {</span>
<span class="line-modified">!     cc = COMBINING_CLASS (wc_buffer[old_n_wc]);</span>
  
<span class="line-modified">!     if (cc == 0)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         g_unicode_canonical_ordering (wc_buffer + last_start, n_wc - last_start);</span>
<span class="line-modified">!         last_start = old_n_wc;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!   }</span>
  
        p = g_utf8_next_char (p);
      }
  
    if (n_wc &gt; 0)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 458,36 ***</span>
        gsize i, j;
        int last_cc = 0;
        last_start = 0;
  
        for (i = 0; i &lt; n_wc; i++)
<span class="line-modified">!     {</span>
<span class="line-modified">!       int cc = COMBINING_CLASS (wc_buffer[i]);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       if (i &gt; 0 &amp;&amp;</span>
<span class="line-modified">!           (last_cc == 0 || last_cc &lt; cc) &amp;&amp;</span>
<span class="line-modified">!           combine (wc_buffer[last_start], wc_buffer[i],</span>
<span class="line-modified">!                &amp;wc_buffer[last_start]))</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           for (j = i + 1; j &lt; n_wc; j++)</span>
<span class="line-modified">!         wc_buffer[j-1] = wc_buffer[j];</span>
<span class="line-modified">!           n_wc--;</span>
<span class="line-modified">!           i--;</span>
<span class="line-modified">! </span>
<span class="line-modified">!           if (i == last_start)</span>
<span class="line-modified">!         last_cc = 0;</span>
<span class="line-modified">!           else</span>
<span class="line-modified">!         last_cc = COMBINING_CLASS (wc_buffer[i-1]);</span>
<span class="line-modified">! </span>
<span class="line-modified">!           continue;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!       if (cc == 0)</span>
<span class="line-modified">!         last_start = i;</span>
<span class="line-modified">! </span>
<span class="line-modified">!       last_cc = cc;</span>
<span class="line-modified">!     }</span>
      }
  
    wc_buffer[n_wc] = 0;
  
    return wc_buffer;
<span class="line-new-header">--- 458,36 ---</span>
        gsize i, j;
        int last_cc = 0;
        last_start = 0;
  
        for (i = 0; i &lt; n_wc; i++)
<span class="line-modified">!   {</span>
<span class="line-modified">!     int cc = COMBINING_CLASS (wc_buffer[i]);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (i &gt; 0 &amp;&amp;</span>
<span class="line-modified">!         (last_cc == 0 || last_cc &lt; cc) &amp;&amp;</span>
<span class="line-modified">!         combine (wc_buffer[last_start], wc_buffer[i],</span>
<span class="line-modified">!            &amp;wc_buffer[last_start]))</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         for (j = i + 1; j &lt; n_wc; j++)</span>
<span class="line-modified">!     wc_buffer[j-1] = wc_buffer[j];</span>
<span class="line-modified">!         n_wc--;</span>
<span class="line-modified">!         i--;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (i == last_start)</span>
<span class="line-modified">!     last_cc = 0;</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!     last_cc = COMBINING_CLASS (wc_buffer[i-1]);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         continue;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (cc == 0)</span>
<span class="line-modified">!       last_start = i;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     last_cc = cc;</span>
<span class="line-modified">!   }</span>
      }
  
    wc_buffer[n_wc] = 0;
  
    return wc_buffer;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 523,18 ***</span>
   * than a maximally decomposed form. This is often
   * useful if you intend to convert the string to
   * a legacy encoding or pass it to a system with
   * less capable Unicode handling.
   *
<span class="line-modified">!  * Returns: a newly allocated string, that is the</span>
<span class="line-modified">!  *   normalized form of @str, or %NULL if @str is not</span>
<span class="line-modified">!  *   valid UTF-8.</span>
   **/
  gchar *
  g_utf8_normalize (const gchar    *str,
<span class="line-modified">!           gssize          len,</span>
<span class="line-modified">!           GNormalizeMode  mode)</span>
  {
    gunichar *result_wc = _g_utf8_normalize_wc (str, len, mode);
    gchar *result;
  
    result = g_ucs4_to_utf8 (result_wc, -1, NULL, NULL, NULL);
<span class="line-new-header">--- 523,18 ---</span>
   * than a maximally decomposed form. This is often
   * useful if you intend to convert the string to
   * a legacy encoding or pass it to a system with
   * less capable Unicode handling.
   *
<span class="line-modified">!  * Returns: (nullable): a newly allocated string, that</span>
<span class="line-modified">!  *   is the normalized form of @str, or %NULL if @str</span>
<span class="line-modified">!  *   is not valid UTF-8.</span>
   **/
  gchar *
  g_utf8_normalize (const gchar    *str,
<span class="line-modified">!       gssize          len,</span>
<span class="line-modified">!       GNormalizeMode  mode)</span>
  {
    gunichar *result_wc = _g_utf8_normalize_wc (str, len, mode);
    gchar *result;
  
    result = g_ucs4_to_utf8 (result_wc, -1, NULL, NULL, NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 573,12 ***</span>
  }
  
  /**
   * g_unichar_decompose:
   * @ch: a Unicode character
<span class="line-modified">!  * @a: return location for the first component of @ch</span>
<span class="line-modified">!  * @b: return location for the second component of @ch</span>
   *
   * Performs a single decomposition step of the
   * Unicode canonical decomposition algorithm.
   *
   * This function does not include compatibility
<span class="line-new-header">--- 573,12 ---</span>
  }
  
  /**
   * g_unichar_decompose:
   * @ch: a Unicode character
<span class="line-modified">!  * @a: (out) (not optional): return location for the first component of @ch</span>
<span class="line-modified">!  * @b: (out) (not optional): return location for the second component of @ch</span>
   *
   * Performs a single decomposition step of the
   * Unicode canonical decomposition algorithm.
   *
   * This function does not include compatibility
</pre>
<hr />
<pre>
<span class="line-old-header">*** 648,11 ***</span>
  
  /**
   * g_unichar_compose:
   * @a: a Unicode character
   * @b: a Unicode character
<span class="line-modified">!  * @ch: return location for the composed character</span>
   *
   * Performs a single composition step of the
   * Unicode canonical composition algorithm.
   *
   * This function includes algorithmic Hangul Jamo composition,
<span class="line-new-header">--- 648,11 ---</span>
  
  /**
   * g_unichar_compose:
   * @a: a Unicode character
   * @b: a Unicode character
<span class="line-modified">!  * @ch: (out) (not optional): return location for the composed character</span>
   *
   * Performs a single composition step of the
   * Unicode canonical composition algorithm.
   *
   * This function includes algorithmic Hangul Jamo composition,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 687,11 ***</span>
  
  /**
   * g_unichar_fully_decompose:
   * @ch: a Unicode character.
   * @compat: whether perform canonical or compatibility decomposition
<span class="line-modified">!  * @result: (nullable): location to store decomposed result, or %NULL</span>
   * @result_len: length of @result
   *
   * Computes the canonical or compatibility decomposition of a
   * Unicode character.  For compatibility decomposition,
   * pass %TRUE for @compat; for canonical decomposition
<span class="line-new-header">--- 687,11 ---</span>
  
  /**
   * g_unichar_fully_decompose:
   * @ch: a Unicode character.
   * @compat: whether perform canonical or compatibility decomposition
<span class="line-modified">!  * @result: (optional) (out caller-allocates): location to store decomposed result, or %NULL</span>
   * @result_len: length of @result
   *
   * Computes the canonical or compatibility decomposition of a
   * Unicode character.  For compatibility decomposition,
   * pass %TRUE for @compat; for canonical decomposition
</pre>
<hr />
<pre>
<span class="line-old-header">*** 716,13 ***</span>
   *
   * Since: 2.30
   **/
  gsize
  g_unichar_fully_decompose (gunichar  ch,
<span class="line-modified">!                gboolean  compat,</span>
<span class="line-modified">!                gunichar *result,</span>
<span class="line-modified">!                gsize     result_len)</span>
  {
    const gchar *decomp;
    const gchar *p;
  
    /* Hangul syllable */
<span class="line-new-header">--- 716,13 ---</span>
   *
   * Since: 2.30
   **/
  gsize
  g_unichar_fully_decompose (gunichar  ch,
<span class="line-modified">!          gboolean  compat,</span>
<span class="line-modified">!          gunichar *result,</span>
<span class="line-modified">!          gsize     result_len)</span>
  {
    const gchar *decomp;
    const gchar *p;
  
    /* Hangul syllable */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 731,11 ***</span>
        gsize len, i;
        gunichar buffer[3];
        decompose_hangul (ch, result ? buffer : NULL, &amp;len);
        if (result)
          for (i = 0; i &lt; len &amp;&amp; i &lt; result_len; i++)
<span class="line-modified">!       result[i] = buffer[i];</span>
        return len;
      }
    else if ((decomp = find_decomposition (ch, compat)) != NULL)
      {
        /* Found it.  */
<span class="line-new-header">--- 731,11 ---</span>
        gsize len, i;
        gunichar buffer[3];
        decompose_hangul (ch, result ? buffer : NULL, &amp;len);
        if (result)
          for (i = 0; i &lt; len &amp;&amp; i &lt; result_len; i++)
<span class="line-modified">!     result[i] = buffer[i];</span>
        return len;
      }
    else if ((decomp = find_decomposition (ch, compat)) != NULL)
      {
        /* Found it.  */
</pre>
<center><a href="gunicollate.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gunidecomp.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>