<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gsttaglist.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 2003 Benjamin Otte &lt;in7y118@public.uni-hamburg.de&gt;
   3  *
   4  * gsttaglist.c: tag support (aka metadata)
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 /**
  23  * SECTION:gsttaglist
  24  * @title: GstTagList
  25  * @short_description: List of tags and values used to describe media metadata
  26  *
  27  * List of tags and values used to describe media metadata.
  28  *
  29  * Strings in structures must be ASCII or UTF-8 encoded. Other encodings are
  30  * not allowed. Strings must not be empty or %NULL.
  31  */
  32 
  33 #ifdef HAVE_CONFIG_H
  34 #  include &quot;config.h&quot;
  35 #endif
  36 
  37 #include &quot;gst_private.h&quot;
  38 #include &quot;math-compat.h&quot;
  39 #include &quot;gst-i18n-lib.h&quot;
  40 #include &quot;gsttaglist.h&quot;
  41 #include &quot;gstinfo.h&quot;
  42 #include &quot;gstvalue.h&quot;
  43 #include &quot;gstbuffer.h&quot;
  44 #include &quot;gstquark.h&quot;
  45 #include &quot;gststructure.h&quot;
  46 
  47 #include &lt;gobject/gvaluecollector.h&gt;
  48 #include &lt;string.h&gt;
  49 
  50 /* FIXME: add category for tags */
  51 #define GST_CAT_TAGS GST_CAT_DEFAULT
  52 
  53 #define GST_TAG_IS_VALID(tag)           (gst_tag_get_info (tag) != NULL)
  54 
  55 typedef struct _GstTagListImpl
  56 {
  57   GstTagList taglist;
  58 
  59   GstStructure *structure;
  60   GstTagScope scope;
  61 } GstTagListImpl;
  62 
  63 #define GST_TAG_LIST_STRUCTURE(taglist)  ((GstTagListImpl*)(taglist))-&gt;structure
  64 #define GST_TAG_LIST_SCOPE(taglist)  ((GstTagListImpl*)(taglist))-&gt;scope
  65 
  66 typedef struct
  67 {
  68   GType type;                   /* type the data is in */
  69 
  70   const gchar *nick;            /* translated short description */
  71   const gchar *blurb;           /* translated long description  */
  72 
  73   GstTagMergeFunc merge_func;   /* functions to merge the values */
  74   GstTagFlag flag;              /* type of tag */
  75   GQuark name_quark;            /* quark for the name */
  76 }
  77 GstTagInfo;
  78 
  79 #define g_value_get_char g_value_get_schar
  80 
  81 static GMutex __tag_mutex;
  82 #define TAG_LOCK g_mutex_lock (&amp;__tag_mutex)
  83 #define TAG_UNLOCK g_mutex_unlock (&amp;__tag_mutex)
  84 
  85 /* tags hash table: maps tag name string =&gt; GstTagInfo */
  86 static GHashTable *__tags;
  87 
  88 GType _gst_tag_list_type = 0;
  89 GST_DEFINE_MINI_OBJECT_TYPE (GstTagList, gst_tag_list);
  90 
  91 static void __gst_tag_list_free (GstTagList * list);
  92 static GstTagList *__gst_tag_list_copy (const GstTagList * list);
  93 
  94 /* FIXME: had code:
  95  *    g_value_register_transform_func (_gst_tag_list_type, G_TYPE_STRING,
  96  *      _gst_structure_transform_to_string);
  97  */
  98 void
  99 _priv_gst_tag_initialize (void)
 100 {
 101   g_mutex_init (&amp;__tag_mutex);
 102 
 103   _gst_tag_list_type = gst_tag_list_get_type ();
 104 
 105   __tags = g_hash_table_new (g_str_hash, g_str_equal);
 106   gst_tag_register_static (GST_TAG_TITLE, GST_TAG_FLAG_META,
 107       G_TYPE_STRING,
 108       _(&quot;title&quot;), _(&quot;commonly used title&quot;), gst_tag_merge_strings_with_comma);
 109   gst_tag_register_static (GST_TAG_TITLE_SORTNAME, GST_TAG_FLAG_META,
 110       G_TYPE_STRING,
 111       _(&quot;title sortname&quot;), _(&quot;commonly used title for sorting purposes&quot;), NULL);
 112   gst_tag_register_static (GST_TAG_ARTIST, GST_TAG_FLAG_META,
 113       G_TYPE_STRING,
 114       _(&quot;artist&quot;),
 115       _(&quot;person(s) responsible for the recording&quot;),
 116       gst_tag_merge_strings_with_comma);
 117   gst_tag_register_static (GST_TAG_ARTIST_SORTNAME, GST_TAG_FLAG_META,
 118       G_TYPE_STRING,
 119       _(&quot;artist sortname&quot;),
 120       _(&quot;person(s) responsible for the recording for sorting purposes&quot;), NULL);
 121   gst_tag_register_static (GST_TAG_ALBUM, GST_TAG_FLAG_META,
 122       G_TYPE_STRING,
 123       _(&quot;album&quot;),
 124       _(&quot;album containing this data&quot;), gst_tag_merge_strings_with_comma);
 125   gst_tag_register_static (GST_TAG_ALBUM_SORTNAME, GST_TAG_FLAG_META,
 126       G_TYPE_STRING,
 127       _(&quot;album sortname&quot;),
 128       _(&quot;album containing this data for sorting purposes&quot;), NULL);
 129   gst_tag_register_static (GST_TAG_ALBUM_ARTIST, GST_TAG_FLAG_META,
 130       G_TYPE_STRING,
 131       _(&quot;album artist&quot;),
 132       _(&quot;The artist of the entire album, as it should be displayed&quot;),
 133       gst_tag_merge_strings_with_comma);
 134   gst_tag_register_static (GST_TAG_ALBUM_ARTIST_SORTNAME, GST_TAG_FLAG_META,
 135       G_TYPE_STRING,
 136       _(&quot;album artist sortname&quot;),
 137       _(&quot;The artist of the entire album, as it should be sorted&quot;), NULL);
 138   gst_tag_register_static (GST_TAG_DATE, GST_TAG_FLAG_META, G_TYPE_DATE,
 139       _(&quot;date&quot;), _(&quot;date the data was created (as a GDate structure)&quot;), NULL);
 140   gst_tag_register_static (GST_TAG_DATE_TIME, GST_TAG_FLAG_META,
 141       GST_TYPE_DATE_TIME, _(&quot;datetime&quot;),
 142       _(&quot;date and time the data was created (as a GstDateTime structure)&quot;),
 143       NULL);
 144   gst_tag_register_static (GST_TAG_GENRE, GST_TAG_FLAG_META,
 145       G_TYPE_STRING,
 146       _(&quot;genre&quot;),
 147       _(&quot;genre this data belongs to&quot;), gst_tag_merge_strings_with_comma);
 148   gst_tag_register_static (GST_TAG_COMMENT, GST_TAG_FLAG_META,
 149       G_TYPE_STRING,
 150       _(&quot;comment&quot;),
 151       _(&quot;free text commenting the data&quot;), gst_tag_merge_use_first);
 152   gst_tag_register_static (GST_TAG_EXTENDED_COMMENT, GST_TAG_FLAG_META,
 153       G_TYPE_STRING,
 154       _(&quot;extended comment&quot;),
 155       _(&quot;free text commenting the data in key=value or key[en]=comment form&quot;),
 156       gst_tag_merge_use_first);
 157   gst_tag_register_static (GST_TAG_TRACK_NUMBER, GST_TAG_FLAG_META,
 158       G_TYPE_UINT,
 159       _(&quot;track number&quot;),
 160       _(&quot;track number inside a collection&quot;), gst_tag_merge_use_first);
 161   gst_tag_register_static (GST_TAG_TRACK_COUNT, GST_TAG_FLAG_META,
 162       G_TYPE_UINT,
 163       _(&quot;track count&quot;),
 164       _(&quot;count of tracks inside collection this track belongs to&quot;),
 165       gst_tag_merge_use_first);
 166   gst_tag_register_static (GST_TAG_ALBUM_VOLUME_NUMBER, GST_TAG_FLAG_META,
 167       G_TYPE_UINT,
 168       _(&quot;disc number&quot;),
 169       _(&quot;disc number inside a collection&quot;), gst_tag_merge_use_first);
 170   gst_tag_register_static (GST_TAG_ALBUM_VOLUME_COUNT, GST_TAG_FLAG_META,
 171       G_TYPE_UINT,
 172       _(&quot;disc count&quot;),
 173       _(&quot;count of discs inside collection this disc belongs to&quot;),
 174       gst_tag_merge_use_first);
 175   gst_tag_register_static (GST_TAG_LOCATION, GST_TAG_FLAG_META,
 176       G_TYPE_STRING,
 177       _(&quot;location&quot;), _(&quot;Origin of media as a URI (location, where the &quot;
 178           &quot;original of the file or stream is hosted)&quot;),
 179       gst_tag_merge_strings_with_comma);
 180   gst_tag_register_static (GST_TAG_HOMEPAGE, GST_TAG_FLAG_META,
 181       G_TYPE_STRING,
 182       _(&quot;homepage&quot;),
 183       _(&quot;Homepage for this media (i.e. artist or movie homepage)&quot;),
 184       gst_tag_merge_strings_with_comma);
 185   gst_tag_register_static (GST_TAG_DESCRIPTION, GST_TAG_FLAG_META,
 186       G_TYPE_STRING, _(&quot;description&quot;),
 187       _(&quot;short text describing the content of the data&quot;),
 188       gst_tag_merge_strings_with_comma);
 189   gst_tag_register_static (GST_TAG_VERSION, GST_TAG_FLAG_META, G_TYPE_STRING,
 190       _(&quot;version&quot;), _(&quot;version of this data&quot;), NULL);
 191   gst_tag_register_static (GST_TAG_ISRC, GST_TAG_FLAG_META, G_TYPE_STRING,
 192       _(&quot;ISRC&quot;),
 193       _
 194       (&quot;International Standard Recording Code - see http://www.ifpi.org/isrc/&quot;),
 195       NULL);
 196   /* FIXME: organization (fix what? tpm) */
 197   gst_tag_register_static (GST_TAG_ORGANIZATION, GST_TAG_FLAG_META,
 198       G_TYPE_STRING, _(&quot;organization&quot;), _(&quot;organization&quot;),
 199       gst_tag_merge_strings_with_comma);
 200   gst_tag_register_static (GST_TAG_COPYRIGHT, GST_TAG_FLAG_META,
 201       G_TYPE_STRING, _(&quot;copyright&quot;), _(&quot;copyright notice of the data&quot;), NULL);
 202   gst_tag_register_static (GST_TAG_COPYRIGHT_URI, GST_TAG_FLAG_META,
 203       G_TYPE_STRING, _(&quot;copyright uri&quot;),
 204       _(&quot;URI to the copyright notice of the data&quot;), NULL);
 205   gst_tag_register_static (GST_TAG_ENCODED_BY, GST_TAG_FLAG_META, G_TYPE_STRING,
 206       _(&quot;encoded by&quot;), _(&quot;name of the encoding person or organization&quot;),
 207       gst_tag_merge_strings_with_comma);
 208   gst_tag_register_static (GST_TAG_CONTACT, GST_TAG_FLAG_META,
 209       G_TYPE_STRING,
 210       _(&quot;contact&quot;), _(&quot;contact information&quot;), gst_tag_merge_strings_with_comma);
 211   gst_tag_register_static (GST_TAG_LICENSE, GST_TAG_FLAG_META,
 212       G_TYPE_STRING, _(&quot;license&quot;), _(&quot;license of data&quot;), NULL);
 213   gst_tag_register_static (GST_TAG_LICENSE_URI, GST_TAG_FLAG_META,
 214       G_TYPE_STRING, _(&quot;license uri&quot;),
 215       _(&quot;URI to the license of the data&quot;), NULL);
 216   gst_tag_register_static (GST_TAG_PERFORMER, GST_TAG_FLAG_META,
 217       G_TYPE_STRING,
 218       _(&quot;performer&quot;),
 219       _(&quot;person(s) performing&quot;), gst_tag_merge_strings_with_comma);
 220   gst_tag_register_static (GST_TAG_COMPOSER, GST_TAG_FLAG_META,
 221       G_TYPE_STRING,
 222       _(&quot;composer&quot;),
 223       _(&quot;person(s) who composed the recording&quot;),
 224       gst_tag_merge_strings_with_comma);
 225   gst_tag_register_static (GST_TAG_CONDUCTOR, GST_TAG_FLAG_META,
 226       G_TYPE_STRING,
 227       _(&quot;conductor&quot;),
 228       _(&quot;conductor/performer refinement&quot;), gst_tag_merge_strings_with_comma);
 229   gst_tag_register_static (GST_TAG_DURATION, GST_TAG_FLAG_DECODED,
 230       G_TYPE_UINT64,
 231       _(&quot;duration&quot;), _(&quot;length in GStreamer time units (nanoseconds)&quot;), NULL);
 232   gst_tag_register_static (GST_TAG_CODEC, GST_TAG_FLAG_ENCODED,
 233       G_TYPE_STRING,
 234       _(&quot;codec&quot;),
 235       _(&quot;codec the data is stored in&quot;), gst_tag_merge_strings_with_comma);
 236   gst_tag_register_static (GST_TAG_VIDEO_CODEC, GST_TAG_FLAG_ENCODED,
 237       G_TYPE_STRING,
 238       _(&quot;video codec&quot;), _(&quot;codec the video data is stored in&quot;), NULL);
 239   gst_tag_register_static (GST_TAG_AUDIO_CODEC, GST_TAG_FLAG_ENCODED,
 240       G_TYPE_STRING,
 241       _(&quot;audio codec&quot;), _(&quot;codec the audio data is stored in&quot;), NULL);
 242   gst_tag_register_static (GST_TAG_SUBTITLE_CODEC, GST_TAG_FLAG_ENCODED,
 243       G_TYPE_STRING,
 244       _(&quot;subtitle codec&quot;), _(&quot;codec the subtitle data is stored in&quot;), NULL);
 245   gst_tag_register_static (GST_TAG_CONTAINER_FORMAT, GST_TAG_FLAG_ENCODED,
 246       G_TYPE_STRING, _(&quot;container format&quot;),
 247       _(&quot;container format the data is stored in&quot;), NULL);
 248   gst_tag_register_static (GST_TAG_BITRATE, GST_TAG_FLAG_ENCODED,
 249       G_TYPE_UINT, _(&quot;bitrate&quot;), _(&quot;exact or average bitrate in bits/s&quot;), NULL);
 250   gst_tag_register_static (GST_TAG_NOMINAL_BITRATE, GST_TAG_FLAG_ENCODED,
 251       G_TYPE_UINT, _(&quot;nominal bitrate&quot;), _(&quot;nominal bitrate in bits/s&quot;), NULL);
 252   gst_tag_register_static (GST_TAG_MINIMUM_BITRATE, GST_TAG_FLAG_ENCODED,
 253       G_TYPE_UINT, _(&quot;minimum bitrate&quot;), _(&quot;minimum bitrate in bits/s&quot;), NULL);
 254   gst_tag_register_static (GST_TAG_MAXIMUM_BITRATE, GST_TAG_FLAG_ENCODED,
 255       G_TYPE_UINT, _(&quot;maximum bitrate&quot;), _(&quot;maximum bitrate in bits/s&quot;), NULL);
 256   gst_tag_register_static (GST_TAG_ENCODER, GST_TAG_FLAG_ENCODED,
 257       G_TYPE_STRING,
 258       _(&quot;encoder&quot;), _(&quot;encoder used to encode this stream&quot;), NULL);
 259   gst_tag_register_static (GST_TAG_ENCODER_VERSION, GST_TAG_FLAG_ENCODED,
 260       G_TYPE_UINT,
 261       _(&quot;encoder version&quot;),
 262       _(&quot;version of the encoder used to encode this stream&quot;), NULL);
 263   gst_tag_register_static (GST_TAG_SERIAL, GST_TAG_FLAG_ENCODED,
 264       G_TYPE_UINT, _(&quot;serial&quot;), _(&quot;serial number of track&quot;), NULL);
 265   gst_tag_register_static (GST_TAG_TRACK_GAIN, GST_TAG_FLAG_META,
 266       G_TYPE_DOUBLE, _(&quot;replaygain track gain&quot;), _(&quot;track gain in db&quot;), NULL);
 267   gst_tag_register_static (GST_TAG_TRACK_PEAK, GST_TAG_FLAG_META,
 268       G_TYPE_DOUBLE, _(&quot;replaygain track peak&quot;), _(&quot;peak of the track&quot;), NULL);
 269   gst_tag_register_static (GST_TAG_ALBUM_GAIN, GST_TAG_FLAG_META,
 270       G_TYPE_DOUBLE, _(&quot;replaygain album gain&quot;), _(&quot;album gain in db&quot;), NULL);
 271   gst_tag_register_static (GST_TAG_ALBUM_PEAK, GST_TAG_FLAG_META,
 272       G_TYPE_DOUBLE, _(&quot;replaygain album peak&quot;), _(&quot;peak of the album&quot;), NULL);
 273   gst_tag_register_static (GST_TAG_REFERENCE_LEVEL, GST_TAG_FLAG_META,
 274       G_TYPE_DOUBLE, _(&quot;replaygain reference level&quot;),
 275       _(&quot;reference level of track and album gain values&quot;), NULL);
 276   gst_tag_register_static (GST_TAG_LANGUAGE_CODE, GST_TAG_FLAG_META,
 277       G_TYPE_STRING, _(&quot;language code&quot;),
 278       _(&quot;language code for this stream, conforming to ISO-639-1 or ISO-639-2&quot;),
 279       NULL);
 280   gst_tag_register_static (GST_TAG_LANGUAGE_NAME, GST_TAG_FLAG_META,
 281       G_TYPE_STRING, _(&quot;language name&quot;),
 282       _(&quot;freeform name of the language this stream is in&quot;), NULL);
 283   gst_tag_register_static (GST_TAG_IMAGE, GST_TAG_FLAG_META, GST_TYPE_SAMPLE,
 284       _(&quot;image&quot;), _(&quot;image related to this stream&quot;), gst_tag_merge_use_first);
 285   gst_tag_register_static (GST_TAG_PREVIEW_IMAGE, GST_TAG_FLAG_META,
 286       GST_TYPE_SAMPLE,
 287       /* TRANSLATORS: &#39;preview image&#39; = image that shows a preview of the full image */
 288       _(&quot;preview image&quot;), _(&quot;preview image related to this stream&quot;), NULL);
 289   gst_tag_register_static (GST_TAG_ATTACHMENT, GST_TAG_FLAG_META,
 290       GST_TYPE_SAMPLE, _(&quot;attachment&quot;), _(&quot;file attached to this stream&quot;),
 291       gst_tag_merge_use_first);
 292   gst_tag_register_static (GST_TAG_BEATS_PER_MINUTE, GST_TAG_FLAG_META,
 293       G_TYPE_DOUBLE, _(&quot;beats per minute&quot;),
 294       _(&quot;number of beats per minute in audio&quot;), NULL);
 295   gst_tag_register_static (GST_TAG_KEYWORDS, GST_TAG_FLAG_META, G_TYPE_STRING,
 296       _(&quot;keywords&quot;), _(&quot;comma separated keywords describing the content&quot;),
 297       gst_tag_merge_strings_with_comma);
 298   gst_tag_register_static (GST_TAG_GEO_LOCATION_NAME, GST_TAG_FLAG_META,
 299       G_TYPE_STRING, _(&quot;geo location name&quot;),
 300       _(&quot;human readable descriptive location of where &quot;
 301           &quot;the media has been recorded or produced&quot;), NULL);
 302   gst_tag_register_static (GST_TAG_GEO_LOCATION_LATITUDE, GST_TAG_FLAG_META,
 303       G_TYPE_DOUBLE, _(&quot;geo location latitude&quot;),
 304       _(&quot;geo latitude location of where the media has been recorded or &quot;
 305           &quot;produced in degrees according to WGS84 (zero at the equator, &quot;
 306           &quot;negative values for southern latitudes)&quot;), NULL);
 307   gst_tag_register_static (GST_TAG_GEO_LOCATION_LONGITUDE, GST_TAG_FLAG_META,
 308       G_TYPE_DOUBLE, _(&quot;geo location longitude&quot;),
 309       _(&quot;geo longitude location of where the media has been recorded or &quot;
 310           &quot;produced in degrees according to WGS84 (zero at the prime meridian &quot;
 311           &quot;in Greenwich/UK,  negative values for western longitudes)&quot;), NULL);
 312   gst_tag_register_static (GST_TAG_GEO_LOCATION_ELEVATION, GST_TAG_FLAG_META,
 313       G_TYPE_DOUBLE, _(&quot;geo location elevation&quot;),
 314       _(&quot;geo elevation of where the media has been recorded or produced in &quot;
 315           &quot;meters according to WGS84 (zero is average sea level)&quot;), NULL);
 316   gst_tag_register_static (GST_TAG_GEO_LOCATION_COUNTRY, GST_TAG_FLAG_META,
 317       G_TYPE_STRING, _(&quot;geo location country&quot;),
 318       _(&quot;country (english name) where the media has been recorded &quot;
 319           &quot;or produced&quot;), NULL);
 320   gst_tag_register_static (GST_TAG_GEO_LOCATION_CITY, GST_TAG_FLAG_META,
 321       G_TYPE_STRING, _(&quot;geo location city&quot;),
 322       _(&quot;city (english name) where the media has been recorded &quot;
 323           &quot;or produced&quot;), NULL);
 324   gst_tag_register_static (GST_TAG_GEO_LOCATION_SUBLOCATION, GST_TAG_FLAG_META,
 325       G_TYPE_STRING, _(&quot;geo location sublocation&quot;),
 326       _(&quot;a location within a city where the media has been produced &quot;
 327           &quot;or created (e.g. the neighborhood)&quot;), NULL);
 328   gst_tag_register_static (GST_TAG_GEO_LOCATION_HORIZONTAL_ERROR,
 329       GST_TAG_FLAG_META, G_TYPE_DOUBLE, _(&quot;geo location horizontal error&quot;),
 330       _(&quot;expected error of the horizontal positioning measures (in meters)&quot;),
 331       NULL);
 332   gst_tag_register_static (GST_TAG_GEO_LOCATION_MOVEMENT_SPEED,
 333       GST_TAG_FLAG_META, G_TYPE_DOUBLE, _(&quot;geo location movement speed&quot;),
 334       _(&quot;movement speed of the capturing device while performing the capture &quot;
 335           &quot;in m/s&quot;), NULL);
 336   gst_tag_register_static (GST_TAG_GEO_LOCATION_MOVEMENT_DIRECTION,
 337       GST_TAG_FLAG_META, G_TYPE_DOUBLE, _(&quot;geo location movement direction&quot;),
 338       _(&quot;indicates the movement direction of the device performing the capture&quot;
 339           &quot; of a media. It is represented as degrees in floating point &quot;
 340           &quot;representation, 0 means the geographic north, and increases &quot;
 341           &quot;clockwise&quot;), NULL);
 342   gst_tag_register_static (GST_TAG_GEO_LOCATION_CAPTURE_DIRECTION,
 343       GST_TAG_FLAG_META, G_TYPE_DOUBLE, _(&quot;geo location capture direction&quot;),
 344       _(&quot;indicates the direction the device is pointing to when capturing &quot;
 345           &quot; a media. It is represented as degrees in floating point &quot;
 346           &quot; representation, 0 means the geographic north, and increases &quot;
 347           &quot;clockwise&quot;), NULL);
 348   gst_tag_register_static (GST_TAG_SHOW_NAME, GST_TAG_FLAG_META, G_TYPE_STRING,
 349       /* TRANSLATORS: &#39;show name&#39; = &#39;TV/radio/podcast show name&#39; here */
 350       _(&quot;show name&quot;),
 351       _(&quot;Name of the tv/podcast/series show the media is from&quot;),
 352       gst_tag_merge_strings_with_comma);
 353   gst_tag_register_static (GST_TAG_SHOW_SORTNAME, GST_TAG_FLAG_META,
 354       G_TYPE_STRING,
 355       /* TRANSLATORS: &#39;show sortname&#39; = &#39;TV/radio/podcast show name as used for sorting purposes&#39; here */
 356       _(&quot;show sortname&quot;),
 357       _(&quot;Name of the tv/podcast/series show the media is from, for sorting &quot;
 358           &quot;purposes&quot;), NULL);
 359   gst_tag_register_static (GST_TAG_SHOW_EPISODE_NUMBER, GST_TAG_FLAG_META,
 360       G_TYPE_UINT, _(&quot;episode number&quot;),
 361       _(&quot;The episode number in the season the media is part of&quot;),
 362       gst_tag_merge_use_first);
 363   gst_tag_register_static (GST_TAG_SHOW_SEASON_NUMBER, GST_TAG_FLAG_META,
 364       G_TYPE_UINT, _(&quot;season number&quot;),
 365       _(&quot;The season number of the show the media is part of&quot;),
 366       gst_tag_merge_use_first);
 367   gst_tag_register_static (GST_TAG_LYRICS, GST_TAG_FLAG_META, G_TYPE_STRING,
 368       _(&quot;lyrics&quot;), _(&quot;The lyrics of the media, commonly used for songs&quot;),
 369       gst_tag_merge_strings_with_comma);
 370   gst_tag_register_static (GST_TAG_COMPOSER_SORTNAME, GST_TAG_FLAG_META,
 371       G_TYPE_STRING, _(&quot;composer sortname&quot;),
 372       _(&quot;person(s) who composed the recording, for sorting purposes&quot;), NULL);
 373   gst_tag_register_static (GST_TAG_GROUPING, GST_TAG_FLAG_META, G_TYPE_STRING,
 374       _(&quot;grouping&quot;),
 375       _(&quot;Groups related media that spans multiple tracks, like the different &quot;
 376           &quot;pieces of a concerto. It is a higher level than a track, &quot;
 377           &quot;but lower than an album&quot;), NULL);
 378   gst_tag_register_static (GST_TAG_USER_RATING, GST_TAG_FLAG_META, G_TYPE_UINT,
 379       _(&quot;user rating&quot;),
 380       _(&quot;Rating attributed by a user. The higher the rank, &quot;
 381           &quot;the more the user likes this media&quot;), NULL);
 382   gst_tag_register_static (GST_TAG_DEVICE_MANUFACTURER, GST_TAG_FLAG_META,
 383       G_TYPE_STRING, _(&quot;device manufacturer&quot;),
 384       _(&quot;Manufacturer of the device used to create this media&quot;), NULL);
 385   gst_tag_register_static (GST_TAG_DEVICE_MODEL, GST_TAG_FLAG_META,
 386       G_TYPE_STRING, _(&quot;device model&quot;),
 387       _(&quot;Model of the device used to create this media&quot;), NULL);
 388   gst_tag_register_static (GST_TAG_APPLICATION_NAME, GST_TAG_FLAG_META,
 389       G_TYPE_STRING, _(&quot;application name&quot;),
 390       _(&quot;Application used to create the media&quot;), NULL);
 391   gst_tag_register_static (GST_TAG_APPLICATION_DATA, GST_TAG_FLAG_META,
 392       GST_TYPE_SAMPLE, _(&quot;application data&quot;),
 393       _(&quot;Arbitrary application data to be serialized into the media&quot;), NULL);
 394   gst_tag_register_static (GST_TAG_IMAGE_ORIENTATION, GST_TAG_FLAG_META,
 395       G_TYPE_STRING, _(&quot;image orientation&quot;),
 396       _(&quot;How the image should be rotated or flipped before display&quot;), NULL);
 397   gst_tag_register_static (GST_TAG_PUBLISHER, GST_TAG_FLAG_META,
 398       G_TYPE_STRING,
 399       _(&quot;publisher&quot;),
 400       _(&quot;Name of the label or publisher&quot;), gst_tag_merge_strings_with_comma);
 401   gst_tag_register_static (GST_TAG_INTERPRETED_BY, GST_TAG_FLAG_META,
 402       G_TYPE_STRING,
 403       _(&quot;interpreted-by&quot;),
 404       _(&quot;Information about the people behind a remix and similar &quot;
 405           &quot;interpretations&quot;), gst_tag_merge_strings_with_comma);
 406   gst_tag_register_static (GST_TAG_MIDI_BASE_NOTE, GST_TAG_FLAG_META,
 407       G_TYPE_UINT,
 408       _(&quot;midi-base-note&quot;), _(&quot;Midi note number of the audio track.&quot;), NULL);
 409   gst_tag_register_static (GST_TAG_PRIVATE_DATA, GST_TAG_FLAG_META,
 410       GST_TYPE_SAMPLE,
 411       _(&quot;private-data&quot;), _(&quot;Private data&quot;), gst_tag_merge_use_first);
 412 
 413 }
 414 
 415 /**
 416  * gst_tag_merge_use_first:
 417  * @dest: (out caller-allocates): uninitialized GValue to store result in
 418  * @src: GValue to copy from
 419  *
 420  * This is a convenience function for the func argument of gst_tag_register().
 421  * It creates a copy of the first value from the list.
 422  */
 423 void
 424 gst_tag_merge_use_first (GValue * dest, const GValue * src)
 425 {
 426   const GValue *ret = gst_value_list_get_value (src, 0);
 427 
 428   g_value_init (dest, G_VALUE_TYPE (ret));
 429   g_value_copy (ret, dest);
 430 }
 431 
 432 /**
 433  * gst_tag_merge_strings_with_comma:
 434  * @dest: (out caller-allocates): uninitialized GValue to store result in
 435  * @src: GValue to copy from
 436  *
 437  * This is a convenience function for the func argument of gst_tag_register().
 438  * It concatenates all given strings using a comma. The tag must be registered
 439  * as a G_TYPE_STRING or this function will fail.
 440  */
 441 void
 442 gst_tag_merge_strings_with_comma (GValue * dest, const GValue * src)
 443 {
 444   GString *str;
 445   gint i, count;
 446 
 447   count = gst_value_list_get_size (src);
 448   str = g_string_new (g_value_get_string (gst_value_list_get_value (src, 0)));
 449   for (i = 1; i &lt; count; i++) {
 450     /* separator between two strings */
 451     g_string_append (str, _(&quot;, &quot;));
 452     g_string_append (str,
 453         g_value_get_string (gst_value_list_get_value (src, i)));
 454   }
 455 
 456   g_value_init (dest, G_TYPE_STRING);
 457   g_value_take_string (dest, str-&gt;str);
 458   g_string_free (str, FALSE);
 459 }
 460 
 461 static GstTagInfo *
 462 gst_tag_lookup (const gchar * tag_name)
 463 {
 464   GstTagInfo *ret;
 465 
 466   TAG_LOCK;
 467   ret = g_hash_table_lookup (__tags, (gpointer) tag_name);
 468   TAG_UNLOCK;
 469 
 470   return ret;
 471 }
 472 
 473 /**
 474  * gst_tag_register: (skip)
 475  * @name: the name or identifier string
 476  * @flag: a flag describing the type of tag info
 477  * @type: the type this data is in
 478  * @nick: human-readable name
 479  * @blurb: a human-readable description about this tag
 480  * @func: (allow-none): function for merging multiple values of this tag, or %NULL
 481  *
 482  * Registers a new tag type for the use with GStreamer&#39;s type system. If a type
 483  * with that name is already registered, that one is used.
 484  * The old registration may have used a different type however. So don&#39;t rely
 485  * on your supplied values.
 486  *
 487  * Important: if you do not supply a merge function the implication will be
 488  * that there can only be one single value for this tag in a tag list and
 489  * any additional values will silently be discarded when being added (unless
 490  * #GST_TAG_MERGE_REPLACE, #GST_TAG_MERGE_REPLACE_ALL, or
 491  * #GST_TAG_MERGE_PREPEND is used as merge mode, in which case the new
 492  * value will replace the old one in the list).
 493  *
 494  * The merge function will be called from gst_tag_list_copy_value() when
 495  * it is required that one or more values for a tag be condensed into
 496  * one single value. This may happen from gst_tag_list_get_string(),
 497  * gst_tag_list_get_int(), gst_tag_list_get_double() etc. What will happen
 498  * exactly in that case depends on how the tag was registered and if a
 499  * merge function was supplied and if so which one.
 500  *
 501  * Two default merge functions are provided: gst_tag_merge_use_first() and
 502  * gst_tag_merge_strings_with_comma().
 503  */
 504 void
 505 gst_tag_register (const gchar * name, GstTagFlag flag, GType type,
 506     const gchar * nick, const gchar * blurb, GstTagMergeFunc func)
 507 {
 508   g_return_if_fail (name != NULL);
 509   g_return_if_fail (nick != NULL);
 510   g_return_if_fail (blurb != NULL);
 511   g_return_if_fail (type != 0 &amp;&amp; type != GST_TYPE_LIST);
 512 
 513   gst_tag_register_static (g_intern_string (name), flag, type,
 514       g_intern_string (nick), g_intern_string (blurb), func);
 515 }
 516 
 517 /**
 518  * gst_tag_register_static: (skip)
 519  * @name: the name or identifier string (string constant)
 520  * @flag: a flag describing the type of tag info
 521  * @type: the type this data is in
 522  * @nick: human-readable name or short description (string constant)
 523  * @blurb: a human-readable description for this tag (string constant)
 524  * @func: (allow-none): function for merging multiple values of this tag, or %NULL
 525  *
 526  * Registers a new tag type for the use with GStreamer&#39;s type system.
 527  *
 528  * Same as gst_tag_register(), but @name, @nick, and @blurb must be
 529  * static strings or inlined strings, as they will not be copied. (GStreamer
 530  * plugins will be made resident once loaded, so this function can be used
 531  * even from dynamically loaded plugins.)
 532  */
 533 void
 534 gst_tag_register_static (const gchar * name, GstTagFlag flag, GType type,
 535     const gchar * nick, const gchar * blurb, GstTagMergeFunc func)
 536 {
 537   GstTagInfo *info;
 538 
 539   g_return_if_fail (name != NULL);
 540   g_return_if_fail (nick != NULL);
 541   g_return_if_fail (blurb != NULL);
 542   g_return_if_fail (type != 0 &amp;&amp; type != GST_TYPE_LIST);
 543 
 544   info = gst_tag_lookup (name);
 545 
 546   if (info) {
 547     g_return_if_fail (info-&gt;type == type);
 548     return;
 549   }
 550 
 551   info = g_slice_new (GstTagInfo);
 552   info-&gt;flag = flag;
 553   info-&gt;type = type;
 554   info-&gt;name_quark = g_quark_from_static_string (name);
 555   info-&gt;nick = nick;
 556   info-&gt;blurb = blurb;
 557   info-&gt;merge_func = func;
 558 
 559   TAG_LOCK;
 560   g_hash_table_insert (__tags, (gpointer) name, info);
 561   TAG_UNLOCK;
 562 }
 563 
 564 /**
 565  * gst_tag_exists:
 566  * @tag: name of the tag
 567  *
 568  * Checks if the given type is already registered.
 569  *
 570  * Returns: %TRUE if the type is already registered
 571  */
 572 gboolean
 573 gst_tag_exists (const gchar * tag)
 574 {
 575   g_return_val_if_fail (tag != NULL, FALSE);
 576 
 577   return gst_tag_lookup (tag) != NULL;
 578 }
 579 
 580 /**
 581  * gst_tag_get_type:
 582  * @tag: the tag
 583  *
 584  * Gets the #GType used for this tag.
 585  *
 586  * Returns: the #GType of this tag
 587  */
 588 GType
 589 gst_tag_get_type (const gchar * tag)
 590 {
 591   GstTagInfo *info;
 592 
 593   g_return_val_if_fail (tag != NULL, 0);
 594   info = gst_tag_lookup (tag);
 595   g_return_val_if_fail (info != NULL, 0);
 596 
 597   return info-&gt;type;
 598 }
 599 
 600 /**
 601  * gst_tag_get_nick:
 602  * @tag: the tag
 603  *
 604  * Returns the human-readable name of this tag, You must not change or free
 605  * this string.
 606  *
 607  * Returns: (nullable): the human-readable name of this tag
 608  */
 609 const gchar *
 610 gst_tag_get_nick (const gchar * tag)
 611 {
 612   GstTagInfo *info;
 613 
 614   g_return_val_if_fail (tag != NULL, NULL);
 615   info = gst_tag_lookup (tag);
 616   if (!info) {
 617     GST_WARNING (&quot;Unknown tag: %s&quot;, tag);
 618 
 619     return tag;
 620   }
 621 
 622   return info-&gt;nick;
 623 }
 624 
 625 /**
 626  * gst_tag_get_description:
 627  * @tag: the tag
 628  *
 629  * Returns the human-readable description of this tag, You must not change or
 630  * free this string.
 631  *
 632  * Returns: (nullable): the human-readable description of this tag
 633  */
 634 const gchar *
 635 gst_tag_get_description (const gchar * tag)
 636 {
 637   GstTagInfo *info;
 638 
 639   g_return_val_if_fail (tag != NULL, NULL);
 640   info = gst_tag_lookup (tag);
 641   g_return_val_if_fail (info != NULL, NULL);
 642 
 643   return info-&gt;blurb;
 644 }
 645 
 646 /**
 647  * gst_tag_get_flag:
 648  * @tag: the tag
 649  *
 650  * Gets the flag of @tag.
 651  *
 652  * Returns: the flag of this tag.
 653  */
 654 GstTagFlag
 655 gst_tag_get_flag (const gchar * tag)
 656 {
 657   GstTagInfo *info;
 658 
 659   g_return_val_if_fail (tag != NULL, GST_TAG_FLAG_UNDEFINED);
 660   info = gst_tag_lookup (tag);
 661   g_return_val_if_fail (info != NULL, GST_TAG_FLAG_UNDEFINED);
 662 
 663   return info-&gt;flag;
 664 }
 665 
 666 /**
 667  * gst_tag_is_fixed:
 668  * @tag: tag to check
 669  *
 670  * Checks if the given tag is fixed. A fixed tag can only contain one value.
 671  * Unfixed tags can contain lists of values.
 672  *
 673  * Returns: %TRUE, if the given tag is fixed.
 674  */
 675 gboolean
 676 gst_tag_is_fixed (const gchar * tag)
 677 {
 678   GstTagInfo *info;
 679 
 680   g_return_val_if_fail (tag != NULL, FALSE);
 681   info = gst_tag_lookup (tag);
 682   g_return_val_if_fail (info != NULL, FALSE);
 683 
 684   return info-&gt;merge_func == NULL;
 685 }
 686 
 687 /* takes ownership of the structure */
 688 static GstTagList *
 689 gst_tag_list_new_internal (GstStructure * s, GstTagScope scope)
 690 {
 691   GstTagList *tag_list;
 692 
 693   g_assert (s != NULL);
 694 
 695   tag_list = (GstTagList *) g_slice_new (GstTagListImpl);
 696 
 697   gst_mini_object_init (GST_MINI_OBJECT_CAST (tag_list), 0, GST_TYPE_TAG_LIST,
 698       (GstMiniObjectCopyFunction) __gst_tag_list_copy, NULL,
 699       (GstMiniObjectFreeFunction) __gst_tag_list_free);
 700 
 701   GST_TAG_LIST_STRUCTURE (tag_list) = s;
 702   GST_TAG_LIST_SCOPE (tag_list) = scope;
 703 
 704 #ifdef DEBUG_REFCOUNT
 705   GST_CAT_TRACE (GST_CAT_TAGS, &quot;created taglist %p&quot;, tag_list);
 706 #endif
 707 
 708   return tag_list;
 709 }
 710 
 711 static void
 712 __gst_tag_list_free (GstTagList * list)
 713 {
 714   g_return_if_fail (GST_IS_TAG_LIST (list));
 715 
 716 #ifdef DEBUG_REFCOUNT
 717   GST_CAT_TRACE (GST_CAT_TAGS, &quot;freeing taglist %p&quot;, list);
 718 #endif
 719 
 720   gst_structure_free (GST_TAG_LIST_STRUCTURE (list));
 721 
 722 #ifdef USE_POISONING
 723   memset (list, 0xff, sizeof (GstTagListImpl));
 724 #endif
 725 
 726   g_slice_free1 (sizeof (GstTagListImpl), list);
 727 }
 728 
 729 static GstTagList *
 730 __gst_tag_list_copy (const GstTagList * list)
 731 {
 732   const GstStructure *s;
 733 
 734   g_return_val_if_fail (GST_IS_TAG_LIST (list), NULL);
 735 
 736   s = GST_TAG_LIST_STRUCTURE (list);
 737   return gst_tag_list_new_internal (gst_structure_copy (s),
 738       GST_TAG_LIST_SCOPE (list));
 739 }
 740 
 741 /**
 742  * gst_tag_list_new_empty:
 743  *
 744  * Creates a new empty GstTagList.
 745  *
 746  * Free-function: gst_tag_list_unref
 747  *
 748  * Returns: (transfer full): An empty tag list
 749  */
 750 GstTagList *
 751 gst_tag_list_new_empty (void)
 752 {
 753   GstStructure *s;
 754   GstTagList *tag_list;
 755 
 756   s = gst_structure_new_id_empty (GST_QUARK (TAGLIST));
 757   tag_list = gst_tag_list_new_internal (s, GST_TAG_SCOPE_STREAM);
 758   return tag_list;
 759 }
 760 
 761 /**
 762  * gst_tag_list_new:
 763  * @tag: tag
 764  * @...: %NULL-terminated list of values to set
 765  *
 766  * Creates a new taglist and appends the values for the given tags. It expects
 767  * tag-value pairs like gst_tag_list_add(), and a %NULL terminator after the
 768  * last pair. The type of the values is implicit and is documented in the API
 769  * reference, but can also be queried at runtime with gst_tag_get_type(). It
 770  * is an error to pass a value of a type not matching the tag type into this
 771  * function. The tag list will make copies of any arguments passed
 772  * (e.g. strings, buffers).
 773  *
 774  * After creation you might also want to set a #GstTagScope on the returned
 775  * taglist to signal if the contained tags are global or stream tags. By
 776  * default stream scope is assumes. See gst_tag_list_set_scope().
 777  *
 778  * Free-function: gst_tag_list_unref
 779  *
 780  * Returns: (transfer full): a new #GstTagList. Free with gst_tag_list_unref()
 781  *     when no longer needed.
 782  */
 783 GstTagList *
 784 gst_tag_list_new (const gchar * tag, ...)
 785 {
 786   GstTagList *list;
 787   va_list args;
 788 
 789   g_return_val_if_fail (tag != NULL, NULL);
 790 
 791   list = gst_tag_list_new_empty ();
 792   va_start (args, tag);
 793   gst_tag_list_add_valist (list, GST_TAG_MERGE_APPEND, tag, args);
 794   va_end (args);
 795 
 796   return list;
 797 }
 798 
 799 /**
 800  * gst_tag_list_new_valist:
 801  * @var_args: tag / value pairs to set
 802  *
 803  * Just like gst_tag_list_new(), only that it takes a va_list argument.
 804  * Useful mostly for language bindings.
 805  *
 806  * Free-function: gst_tag_list_unref
 807  *
 808  * Returns: (transfer full): a new #GstTagList. Free with gst_tag_list_unref()
 809  *     when no longer needed.
 810  */
 811 GstTagList *
 812 gst_tag_list_new_valist (va_list var_args)
 813 {
 814   GstTagList *list;
 815   const gchar *tag;
 816 
 817   list = gst_tag_list_new_empty ();
 818 
 819   tag = va_arg (var_args, gchar *);
 820   gst_tag_list_add_valist (list, GST_TAG_MERGE_APPEND, tag, var_args);
 821 
 822   return list;
 823 }
 824 
 825 /**
 826  * gst_tag_list_set_scope:
 827  * @list: a #GstTagList
 828  * @scope: new scope for @list
 829  *
 830  * Sets the scope of @list to @scope. By default the scope
 831  * of a taglist is stream scope.
 832  *
 833  */
 834 void
 835 gst_tag_list_set_scope (GstTagList * list, GstTagScope scope)
 836 {
 837   g_return_if_fail (GST_IS_TAG_LIST (list));
 838   g_return_if_fail (gst_tag_list_is_writable (list));
 839 
 840   GST_TAG_LIST_SCOPE (list) = scope;
 841 }
 842 
 843 /**
 844  * gst_tag_list_get_scope:
 845  * @list: a #GstTagList
 846  *
 847  * Gets the scope of @list.
 848  *
 849  * Returns: The scope of @list
 850  */
 851 GstTagScope
 852 gst_tag_list_get_scope (const GstTagList * list)
 853 {
 854   g_return_val_if_fail (GST_IS_TAG_LIST (list), GST_TAG_SCOPE_STREAM);
 855 
 856   return GST_TAG_LIST_SCOPE (list);
 857 }
 858 
 859 /**
 860  * gst_tag_list_to_string:
 861  * @list: a #GstTagList
 862  *
 863  * Serializes a tag list to a string.
 864  *
 865  * Returns: (nullable): a newly-allocated string, or %NULL in case of
 866  *     an error. The string must be freed with g_free() when no longer
 867  *     needed.
 868  */
 869 gchar *
 870 gst_tag_list_to_string (const GstTagList * list)
 871 {
 872   g_return_val_if_fail (GST_IS_TAG_LIST (list), NULL);
 873 
 874   return gst_structure_to_string (GST_TAG_LIST_STRUCTURE (list));
 875 }
 876 
 877 /**
 878  * gst_tag_list_new_from_string:
 879  * @str: a string created with gst_tag_list_to_string()
 880  *
 881  * Deserializes a tag list.
 882  *
 883  * Returns: (nullable): a new #GstTagList, or %NULL in case of an
 884  * error.
 885  */
 886 GstTagList *
 887 gst_tag_list_new_from_string (const gchar * str)
 888 {
 889   GstTagList *tag_list;
 890   GstStructure *s;
 891 
 892   g_return_val_if_fail (str != NULL, NULL);
 893   g_return_val_if_fail (g_str_has_prefix (str, &quot;taglist&quot;), NULL);
 894 
 895   s = gst_structure_from_string (str, NULL);
 896   if (s == NULL)
 897     return NULL;
 898 
 899   tag_list = gst_tag_list_new_internal (s, GST_TAG_SCOPE_STREAM);
 900 
 901   return tag_list;
 902 }
 903 
 904 /**
 905  * gst_tag_list_n_tags:
 906  * @list: A #GstTagList.
 907  *
 908  * Get the number of tags in @list.
 909  *
 910  * Returns: The number of tags in @list.
 911  */
 912 gint
 913 gst_tag_list_n_tags (const GstTagList * list)
 914 {
 915   g_return_val_if_fail (list != NULL, 0);
 916   g_return_val_if_fail (GST_IS_TAG_LIST (list), 0);
 917 
 918   return gst_structure_n_fields (GST_TAG_LIST_STRUCTURE (list));
 919 }
 920 
 921 /**
 922  * gst_tag_list_nth_tag_name:
 923  * @list: A #GstTagList.
 924  * @index: the index
 925  *
 926  * Get the name of the tag in @list at @index.
 927  *
 928  * Returns: The name of the tag at @index.
 929  */
 930 const gchar *
 931 gst_tag_list_nth_tag_name (const GstTagList * list, guint index)
 932 {
 933   g_return_val_if_fail (list != NULL, 0);
 934   g_return_val_if_fail (GST_IS_TAG_LIST (list), 0);
 935 
 936   return gst_structure_nth_field_name (GST_TAG_LIST_STRUCTURE (list), index);
 937 }
 938 
 939 /**
 940  * gst_tag_list_is_empty:
 941  * @list: A #GstTagList.
 942  *
 943  * Checks if the given taglist is empty.
 944  *
 945  * Returns: %TRUE if the taglist is empty, otherwise %FALSE.
 946  */
 947 gboolean
 948 gst_tag_list_is_empty (const GstTagList * list)
 949 {
 950   g_return_val_if_fail (list != NULL, FALSE);
 951   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
 952 
 953   return (gst_structure_n_fields (GST_TAG_LIST_STRUCTURE (list)) == 0);
 954 }
 955 
 956 static gboolean
 957 gst_tag_list_fields_equal (const GValue * value1, const GValue * value2)
 958 {
 959   gdouble d1, d2;
 960 
 961   if (gst_value_compare (value1, value2) == GST_VALUE_EQUAL)
 962     return TRUE;
 963 
 964   /* fields not equal: add some tolerance for doubles, otherwise bail out */
 965   if (!G_VALUE_HOLDS_DOUBLE (value1) || !G_VALUE_HOLDS_DOUBLE (value2))
 966     return FALSE;
 967 
 968   d1 = g_value_get_double (value1);
 969   d2 = g_value_get_double (value2);
 970 
 971   /* This will only work for &#39;normal&#39; values and values around 0,
 972    * which should be good enough for our purposes here
 973    * FIXME: maybe add this to gst_value_compare_double() ? */
 974   return (fabs (d1 - d2) &lt; 0.0000001);
 975 }
 976 
 977 /**
 978  * gst_tag_list_is_equal:
 979  * @list1: a #GstTagList.
 980  * @list2: a #GstTagList.
 981  *
 982  * Checks if the two given taglists are equal.
 983  *
 984  * Returns: %TRUE if the taglists are equal, otherwise %FALSE
 985  */
 986 gboolean
 987 gst_tag_list_is_equal (const GstTagList * list1, const GstTagList * list2)
 988 {
 989   const GstStructure *s1, *s2;
 990   gint num_fields1, num_fields2, i;
 991 
 992   g_return_val_if_fail (GST_IS_TAG_LIST (list1), FALSE);
 993   g_return_val_if_fail (GST_IS_TAG_LIST (list2), FALSE);
 994 
 995   /* we don&#39;t just use gst_structure_is_equal() here so we can add some
 996    * tolerance for doubles, though maybe we should just add that to
 997    * gst_value_compare_double() as well? */
 998   s1 = GST_TAG_LIST_STRUCTURE (list1);
 999   s2 = GST_TAG_LIST_STRUCTURE (list2);
1000 
1001   num_fields1 = gst_structure_n_fields (s1);
1002   num_fields2 = gst_structure_n_fields (s2);
1003 
1004   if (num_fields1 != num_fields2)
1005     return FALSE;
1006 
1007   for (i = 0; i &lt; num_fields1; i++) {
1008     const GValue *value1, *value2;
1009     const gchar *tag_name;
1010 
1011     tag_name = gst_structure_nth_field_name (s1, i);
1012     value1 = gst_structure_get_value (s1, tag_name);
1013     value2 = gst_structure_get_value (s2, tag_name);
1014 
1015     if (value2 == NULL)
1016       return FALSE;
1017 
1018     if (!gst_tag_list_fields_equal (value1, value2))
1019       return FALSE;
1020   }
1021 
1022   return TRUE;
1023 }
1024 
1025 typedef struct
1026 {
1027   GstTagList *list;
1028   GstTagMergeMode mode;
1029 }
1030 GstTagCopyData;
1031 
1032 static void
1033 gst_tag_list_add_value_internal (GstTagList * tag_list, GstTagMergeMode mode,
1034     const gchar * tag, const GValue * value, GstTagInfo * info)
1035 {
1036   GstStructure *list = GST_TAG_LIST_STRUCTURE (tag_list);
1037   const GValue *value2;
1038   GQuark tag_quark;
1039 
1040   if (info == NULL) {
1041     info = gst_tag_lookup (tag);
1042     if (G_UNLIKELY (info == NULL)) {
1043       g_warning (&quot;unknown tag &#39;%s&#39;&quot;, tag);
1044       return;
1045     }
1046   }
1047 
1048   if (G_UNLIKELY (!G_VALUE_HOLDS (value, info-&gt;type) &amp;&amp;
1049           !GST_VALUE_HOLDS_LIST (value))) {
1050     g_warning (&quot;tag &#39;%s&#39; should hold value of type &#39;%s&#39;, but value of &quot;
1051         &quot;type &#39;%s&#39; passed&quot;, info-&gt;nick, g_type_name (info-&gt;type),
1052         g_type_name (G_VALUE_TYPE (value)));
1053     return;
1054   }
1055 
1056   tag_quark = info-&gt;name_quark;
1057 
1058   if (info-&gt;merge_func
1059       &amp;&amp; (value2 = gst_structure_id_get_value (list, tag_quark)) != NULL) {
1060     GValue dest = { 0, };
1061 
1062     switch (mode) {
1063       case GST_TAG_MERGE_REPLACE_ALL:
1064       case GST_TAG_MERGE_REPLACE:
1065         gst_structure_id_set_value (list, tag_quark, value);
1066         break;
1067       case GST_TAG_MERGE_PREPEND:
1068         if (GST_VALUE_HOLDS_LIST (value2) &amp;&amp; !GST_VALUE_HOLDS_LIST (value))
1069           gst_value_list_prepend_value ((GValue *) value2, value);
1070         else {
1071           gst_value_list_merge (&amp;dest, value, value2);
1072           gst_structure_id_take_value (list, tag_quark, &amp;dest);
1073         }
1074         break;
1075       case GST_TAG_MERGE_APPEND:
1076         if (GST_VALUE_HOLDS_LIST (value2) &amp;&amp; !GST_VALUE_HOLDS_LIST (value))
1077           gst_value_list_append_value ((GValue *) value2, value);
1078         else {
1079           gst_value_list_merge (&amp;dest, value2, value);
1080           gst_structure_id_take_value (list, tag_quark, &amp;dest);
1081         }
1082         break;
1083       case GST_TAG_MERGE_KEEP:
1084       case GST_TAG_MERGE_KEEP_ALL:
1085         break;
1086       default:
1087         g_assert_not_reached ();
1088         break;
1089     }
1090   } else {
1091     switch (mode) {
1092       case GST_TAG_MERGE_APPEND:
1093       case GST_TAG_MERGE_KEEP:
1094         if (gst_structure_id_get_value (list, tag_quark) != NULL)
1095           break;
1096         /* fall through */
1097       case GST_TAG_MERGE_REPLACE_ALL:
1098       case GST_TAG_MERGE_REPLACE:
1099       case GST_TAG_MERGE_PREPEND:
1100         gst_structure_id_set_value (list, tag_quark, value);
1101         break;
1102       case GST_TAG_MERGE_KEEP_ALL:
1103         break;
1104       default:
1105         g_assert_not_reached ();
1106         break;
1107     }
1108   }
1109 }
1110 
1111 static gboolean
1112 gst_tag_list_copy_foreach (GQuark tag_quark, const GValue * value,
1113     gpointer user_data)
1114 {
1115   GstTagCopyData *copy = (GstTagCopyData *) user_data;
1116   const gchar *tag;
1117 
1118   tag = g_quark_to_string (tag_quark);
1119   gst_tag_list_add_value_internal (copy-&gt;list, copy-&gt;mode, tag, value, NULL);
1120 
1121   return TRUE;
1122 }
1123 
1124 /**
1125  * gst_tag_list_insert:
1126  * @into: list to merge into
1127  * @from: list to merge from
1128  * @mode: the mode to use
1129  *
1130  * Inserts the tags of the @from list into the first list using the given mode.
1131  */
1132 void
1133 gst_tag_list_insert (GstTagList * into, const GstTagList * from,
1134     GstTagMergeMode mode)
1135 {
1136   GstTagCopyData data;
1137 
1138   g_return_if_fail (GST_IS_TAG_LIST (into));
1139   g_return_if_fail (gst_tag_list_is_writable (into));
1140   g_return_if_fail (GST_IS_TAG_LIST (from));
1141   g_return_if_fail (GST_TAG_MODE_IS_VALID (mode));
1142 
1143   data.list = into;
1144   data.mode = mode;
1145   if (mode == GST_TAG_MERGE_REPLACE_ALL) {
1146     gst_structure_remove_all_fields (GST_TAG_LIST_STRUCTURE (into));
1147   }
1148   gst_structure_foreach (GST_TAG_LIST_STRUCTURE (from),
1149       gst_tag_list_copy_foreach, &amp;data);
1150 }
1151 
1152 /**
1153  * gst_tag_list_merge:
1154  * @list1: (allow-none): first list to merge
1155  * @list2: (allow-none): second list to merge
1156  * @mode: the mode to use
1157  *
1158  * Merges the two given lists into a new list. If one of the lists is %NULL, a
1159  * copy of the other is returned. If both lists are %NULL, %NULL is returned.
1160  *
1161  * Free-function: gst_tag_list_unref
1162  *
1163  * Returns: (transfer full) (nullable): the new list
1164  */
1165 GstTagList *
1166 gst_tag_list_merge (const GstTagList * list1, const GstTagList * list2,
1167     GstTagMergeMode mode)
1168 {
1169   GstTagList *list1_cp;
1170   const GstTagList *list2_cp;
1171 
1172   g_return_val_if_fail (list1 == NULL || GST_IS_TAG_LIST (list1), NULL);
1173   g_return_val_if_fail (list2 == NULL || GST_IS_TAG_LIST (list2), NULL);
1174   g_return_val_if_fail (GST_TAG_MODE_IS_VALID (mode), NULL);
1175 
1176   /* nothing to merge */
1177   if (!list1 &amp;&amp; !list2) {
1178     return NULL;
1179   }
1180 
1181   /* create empty list, we need to do this to correctly handling merge modes */
1182   list1_cp = (list1) ? gst_tag_list_copy (list1) : gst_tag_list_new_empty ();
1183   list2_cp = (list2) ? list2 : gst_tag_list_new_empty ();
1184 
1185   gst_tag_list_insert (list1_cp, list2_cp, mode);
1186 
1187   if (!list2)
1188     gst_tag_list_unref ((GstTagList *) list2_cp);
1189 
1190   return list1_cp;
1191 }
1192 
1193 /**
1194  * gst_tag_list_get_tag_size:
1195  * @list: a taglist
1196  * @tag: the tag to query
1197  *
1198  * Checks how many value are stored in this tag list for the given tag.
1199  *
1200  * Returns: The number of tags stored
1201  */
1202 guint
1203 gst_tag_list_get_tag_size (const GstTagList * list, const gchar * tag)
1204 {
1205   const GValue *value;
1206 
1207   g_return_val_if_fail (GST_IS_TAG_LIST (list), 0);
1208 
1209   value = gst_structure_get_value (GST_TAG_LIST_STRUCTURE (list), tag);
1210   if (value == NULL)
1211     return 0;
1212   if (G_VALUE_TYPE (value) != GST_TYPE_LIST)
1213     return 1;
1214 
1215   return gst_value_list_get_size (value);
1216 }
1217 
1218 /**
1219  * gst_tag_list_add:
1220  * @list: list to set tags in
1221  * @mode: the mode to use
1222  * @tag: tag
1223  * @...: %NULL-terminated list of values to set
1224  *
1225  * Sets the values for the given tags using the specified mode.
1226  */
1227 void
1228 gst_tag_list_add (GstTagList * list, GstTagMergeMode mode, const gchar * tag,
1229     ...)
1230 {
1231   va_list args;
1232 
1233   g_return_if_fail (GST_IS_TAG_LIST (list));
1234   g_return_if_fail (gst_tag_list_is_writable (list));
1235   g_return_if_fail (GST_TAG_MODE_IS_VALID (mode));
1236   g_return_if_fail (tag != NULL);
1237 
1238   va_start (args, tag);
1239   gst_tag_list_add_valist (list, mode, tag, args);
1240   va_end (args);
1241 }
1242 
1243 /**
1244  * gst_tag_list_add_values:
1245  * @list: list to set tags in
1246  * @mode: the mode to use
1247  * @tag: tag
1248  * @...: GValues to set
1249  *
1250  * Sets the GValues for the given tags using the specified mode.
1251  */
1252 void
1253 gst_tag_list_add_values (GstTagList * list, GstTagMergeMode mode,
1254     const gchar * tag, ...)
1255 {
1256   va_list args;
1257 
1258   g_return_if_fail (GST_IS_TAG_LIST (list));
1259   g_return_if_fail (gst_tag_list_is_writable (list));
1260   g_return_if_fail (GST_TAG_MODE_IS_VALID (mode));
1261   g_return_if_fail (tag != NULL);
1262 
1263   va_start (args, tag);
1264   gst_tag_list_add_valist_values (list, mode, tag, args);
1265   va_end (args);
1266 }
1267 
1268 /**
1269  * gst_tag_list_add_valist:
1270  * @list: list to set tags in
1271  * @mode: the mode to use
1272  * @tag: tag
1273  * @var_args: tag / value pairs to set
1274  *
1275  * Sets the values for the given tags using the specified mode.
1276  */
1277 void
1278 gst_tag_list_add_valist (GstTagList * list, GstTagMergeMode mode,
1279     const gchar * tag, va_list var_args)
1280 {
1281   GstTagInfo *info;
1282   gchar *error = NULL;
1283 
1284   g_return_if_fail (GST_IS_TAG_LIST (list));
1285   g_return_if_fail (gst_tag_list_is_writable (list));
1286   g_return_if_fail (GST_TAG_MODE_IS_VALID (mode));
1287   g_return_if_fail (tag != NULL);
1288 
1289   if (mode == GST_TAG_MERGE_REPLACE_ALL) {
1290     gst_structure_remove_all_fields (GST_TAG_LIST_STRUCTURE (list));
1291   }
1292 
1293   while (tag != NULL) {
1294     GValue value = { 0, };
1295 
1296     info = gst_tag_lookup (tag);
1297     if (G_UNLIKELY (info == NULL)) {
1298       g_warning (&quot;unknown tag &#39;%s&#39;&quot;, tag);
1299       return;
1300     }
1301     G_VALUE_COLLECT_INIT (&amp;value, info-&gt;type, var_args, 0, &amp;error);
1302     if (error) {
1303       g_warning (&quot;%s: %s&quot;, G_STRLOC, error);
1304       g_free (error);
1305       /* we purposely leak the value here, it might not be
1306        * in a sane state if an error condition occurred
1307        */
1308       return;
1309     }
1310     /* Facilitate GstBuffer -&gt; GstSample transition */
1311     if (G_UNLIKELY (info-&gt;type == GST_TYPE_SAMPLE &amp;&amp;
1312             !GST_IS_SAMPLE (value.data[0].v_pointer))) {
1313       g_warning (&quot;Expected GstSample argument for tag &#39;%s&#39;&quot;, tag);
1314     } else {
1315       gst_tag_list_add_value_internal (list, mode, tag, &amp;value, info);
1316     }
1317     g_value_unset (&amp;value);
1318     tag = va_arg (var_args, gchar *);
1319   }
1320 }
1321 
1322 /**
1323  * gst_tag_list_add_valist_values:
1324  * @list: list to set tags in
1325  * @mode: the mode to use
1326  * @tag: tag
1327  * @var_args: tag / GValue pairs to set
1328  *
1329  * Sets the GValues for the given tags using the specified mode.
1330  */
1331 void
1332 gst_tag_list_add_valist_values (GstTagList * list, GstTagMergeMode mode,
1333     const gchar * tag, va_list var_args)
1334 {
1335   g_return_if_fail (GST_IS_TAG_LIST (list));
1336   g_return_if_fail (gst_tag_list_is_writable (list));
1337   g_return_if_fail (GST_TAG_MODE_IS_VALID (mode));
1338   g_return_if_fail (tag != NULL);
1339 
1340   if (mode == GST_TAG_MERGE_REPLACE_ALL) {
1341     gst_structure_remove_all_fields (GST_TAG_LIST_STRUCTURE (list));
1342   }
1343 
1344   while (tag != NULL) {
1345     GstTagInfo *info;
1346 
1347     info = gst_tag_lookup (tag);
1348     if (G_UNLIKELY (info == NULL)) {
1349       g_warning (&quot;unknown tag &#39;%s&#39;&quot;, tag);
1350       return;
1351     }
1352     gst_tag_list_add_value_internal (list, mode, tag, va_arg (var_args,
1353             GValue *), info);
1354     tag = va_arg (var_args, gchar *);
1355   }
1356 }
1357 
1358 /**
1359  * gst_tag_list_add_value:
1360  * @list: list to set tags in
1361  * @mode: the mode to use
1362  * @tag: tag
1363  * @value: GValue for this tag
1364  *
1365  * Sets the GValue for a given tag using the specified mode.
1366  */
1367 void
1368 gst_tag_list_add_value (GstTagList * list, GstTagMergeMode mode,
1369     const gchar * tag, const GValue * value)
1370 {
1371   g_return_if_fail (GST_IS_TAG_LIST (list));
1372   g_return_if_fail (gst_tag_list_is_writable (list));
1373   g_return_if_fail (GST_TAG_MODE_IS_VALID (mode));
1374   g_return_if_fail (tag != NULL);
1375 
1376   gst_tag_list_add_value_internal (list, mode, tag, value, NULL);
1377 }
1378 
1379 /**
1380  * gst_tag_list_remove_tag:
1381  * @list: list to remove tag from
1382  * @tag: tag to remove
1383  *
1384  * Removes the given tag from the taglist.
1385  */
1386 void
1387 gst_tag_list_remove_tag (GstTagList * list, const gchar * tag)
1388 {
1389   g_return_if_fail (GST_IS_TAG_LIST (list));
1390   g_return_if_fail (gst_tag_list_is_writable (list));
1391   g_return_if_fail (tag != NULL);
1392 
1393   gst_structure_remove_field (GST_TAG_LIST_STRUCTURE (list), tag);
1394 }
1395 
1396 typedef struct
1397 {
1398   GstTagForeachFunc func;
1399   const GstTagList *tag_list;
1400   gpointer data;
1401 }
1402 TagForeachData;
1403 
1404 static int
1405 structure_foreach_wrapper (GQuark field_id, const GValue * value,
1406     gpointer user_data)
1407 {
1408   TagForeachData *data = (TagForeachData *) user_data;
1409 
1410   data-&gt;func (data-&gt;tag_list, g_quark_to_string (field_id), data-&gt;data);
1411   return TRUE;
1412 }
1413 
1414 /**
1415  * gst_tag_list_foreach:
1416  * @list: list to iterate over
1417  * @func: (scope call): function to be called for each tag
1418  * @user_data: (closure): user specified data
1419  *
1420  * Calls the given function for each tag inside the tag list. Note that if there
1421  * is no tag, the function won&#39;t be called at all.
1422  */
1423 void
1424 gst_tag_list_foreach (const GstTagList * list, GstTagForeachFunc func,
1425     gpointer user_data)
1426 {
1427   TagForeachData data;
1428 
1429   g_return_if_fail (GST_IS_TAG_LIST (list));
1430   g_return_if_fail (func != NULL);
1431 
1432   data.func = func;
1433   data.tag_list = list;
1434   data.data = user_data;
1435   gst_structure_foreach (GST_TAG_LIST_STRUCTURE (list),
1436       structure_foreach_wrapper, &amp;data);
1437 }
1438 
1439 /**
1440  * gst_tag_list_get_value_index:
1441  * @list: a #GstTagList
1442  * @tag: tag to read out
1443  * @index: number of entry to read out
1444  *
1445  * Gets the value that is at the given index for the given tag in the given
1446  * list.
1447  *
1448  * Returns: (transfer none) (nullable): The GValue for the specified
1449  *          entry or %NULL if the tag wasn&#39;t available or the tag
1450  *          doesn&#39;t have as many entries
1451  */
1452 const GValue *
1453 gst_tag_list_get_value_index (const GstTagList * list, const gchar * tag,
1454     guint index)
1455 {
1456   const GValue *value;
1457 
1458   g_return_val_if_fail (GST_IS_TAG_LIST (list), NULL);
1459   g_return_val_if_fail (tag != NULL, NULL);
1460 
1461   value = gst_structure_get_value (GST_TAG_LIST_STRUCTURE (list), tag);
1462   if (value == NULL)
1463     return NULL;
1464 
1465   if (GST_VALUE_HOLDS_LIST (value)) {
1466     if (index &gt;= gst_value_list_get_size (value))
1467       return NULL;
1468     return gst_value_list_get_value (value, index);
1469   } else {
1470     if (index &gt; 0)
1471       return NULL;
1472     return value;
1473   }
1474 }
1475 
1476 /**
1477  * gst_tag_list_copy_value:
1478  * @dest: (out caller-allocates): uninitialized #GValue to copy into
1479  * @list: list to get the tag from
1480  * @tag: tag to read out
1481  *
1482  * Copies the contents for the given tag into the value,
1483  * merging multiple values into one if multiple values are associated
1484  * with the tag.
1485  * You must g_value_unset() the value after use.
1486  *
1487  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1488  *          given list.
1489  */
1490 gboolean
1491 gst_tag_list_copy_value (GValue * dest, const GstTagList * list,
1492     const gchar * tag)
1493 {
1494   const GValue *src;
1495 
1496   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
1497   g_return_val_if_fail (tag != NULL, FALSE);
1498   g_return_val_if_fail (dest != NULL, FALSE);
1499   g_return_val_if_fail (G_VALUE_TYPE (dest) == 0, FALSE);
1500 
1501   src = gst_structure_get_value (GST_TAG_LIST_STRUCTURE (list), tag);
1502   if (!src)
1503     return FALSE;
1504 
1505   if (G_VALUE_TYPE (src) == GST_TYPE_LIST) {
1506     GstTagInfo *info = gst_tag_lookup (tag);
1507 
1508     if (!info)
1509       return FALSE;
1510 
1511     /* must be there or lists aren&#39;t allowed */
1512     g_assert (info-&gt;merge_func);
1513     info-&gt;merge_func (dest, src);
1514   } else {
1515     g_value_init (dest, G_VALUE_TYPE (src));
1516     g_value_copy (src, dest);
1517   }
1518   return TRUE;
1519 }
1520 
1521 /* FIXME 2.0: this whole merge function business is overdesigned, and the
1522  * _get_foo() API is misleading as well - how many application developers will
1523  * expect gst_tag_list_get_string (list, GST_TAG_ARTIST, &amp;val) might return a
1524  * string with multiple comma-separated artists? _get_foo() should just be
1525  * a convenience wrapper around _get_foo_index (list, tag, 0, &amp;val),
1526  * supplemented by a special _tag_list_get_string_merged() function if needed
1527  * (unless someone can actually think of real use cases where the merge
1528  * function is not &#39;use first&#39; for non-strings and merge for strings) */
1529 
1530 /***** evil macros to get all the gst_tag_list_get_*() functions right *****/
1531 
1532 #define TAG_MERGE_FUNCS(name,type,ret)                                  \
1533 gboolean                                                                \
1534 gst_tag_list_get_ ## name (const GstTagList *list, const gchar *tag,    \
1535                            type *value)                                 \
1536 {                                                                       \
1537   GValue v = { 0, };                                                    \
1538                                                                         \
1539   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);                 \
1540   g_return_val_if_fail (tag != NULL, FALSE);                            \
1541   g_return_val_if_fail (value != NULL, FALSE);                          \
1542                                                                         \
1543   if (!gst_tag_list_copy_value (&amp;v, list, tag))                         \
1544       return FALSE;                                                     \
1545   *value = COPY_FUNC (g_value_get_ ## name (&amp;v));                       \
1546   g_value_unset (&amp;v);                                                   \
1547   return ret;                                                           \
1548 }                                                                       \
1549                                                                         \
1550 gboolean                                                                \
1551 gst_tag_list_get_ ## name ## _index (const GstTagList *list,            \
1552                                      const gchar *tag,                  \
1553                                      guint index, type *value)          \
1554 {                                                                       \
1555   const GValue *v;                                                      \
1556                                                                         \
1557   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);                 \
1558   g_return_val_if_fail (tag != NULL, FALSE);                            \
1559   g_return_val_if_fail (value != NULL, FALSE);                          \
1560                                                                         \
1561   if ((v = gst_tag_list_get_value_index (list, tag, index)) == NULL)    \
1562       return FALSE;                                                     \
1563   *value = COPY_FUNC (g_value_get_ ## name (v));                        \
1564   return ret;                                                           \
1565 }
1566 
1567 #define COPY_FUNC /**/
1568 /**
1569  * gst_tag_list_get_boolean:
1570  * @list: a #GstTagList to get the tag from
1571  * @tag: tag to read out
1572  * @value: (out): location for the result
1573  *
1574  * Copies the contents for the given tag into the value, merging multiple values
1575  * into one if multiple values are associated with the tag.
1576  *
1577  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1578  *              given list.
1579  */
1580 /**
1581  * gst_tag_list_get_boolean_index:
1582  * @list: a #GstTagList to get the tag from
1583  * @tag: tag to read out
1584  * @index: number of entry to read out
1585  * @value: (out): location for the result
1586  *
1587  * Gets the value that is at the given index for the given tag in the given
1588  * list.
1589  *
1590  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1591  *              given list.
1592  */
1593 TAG_MERGE_FUNCS (boolean, gboolean, TRUE);
1594 /**
1595  * gst_tag_list_get_int:
1596  * @list: a #GstTagList to get the tag from
1597  * @tag: tag to read out
1598  * @value: (out): location for the result
1599  *
1600  * Copies the contents for the given tag into the value, merging multiple values
1601  * into one if multiple values are associated with the tag.
1602  *
1603  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1604  *              given list.
1605  */
1606 /**
1607  * gst_tag_list_get_int_index:
1608  * @list: a #GstTagList to get the tag from
1609  * @tag: tag to read out
1610  * @index: number of entry to read out
1611  * @value: (out): location for the result
1612  *
1613  * Gets the value that is at the given index for the given tag in the given
1614  * list.
1615  *
1616  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1617  *              given list.
1618  */
1619 TAG_MERGE_FUNCS (int, gint, TRUE);
1620 /**
1621  * gst_tag_list_get_uint:
1622  * @list: a #GstTagList to get the tag from
1623  * @tag: tag to read out
1624  * @value: (out): location for the result
1625  *
1626  * Copies the contents for the given tag into the value, merging multiple values
1627  * into one if multiple values are associated with the tag.
1628  *
1629  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1630  *              given list.
1631  */
1632 /**
1633  * gst_tag_list_get_uint_index:
1634  * @list: a #GstTagList to get the tag from
1635  * @tag: tag to read out
1636  * @index: number of entry to read out
1637  * @value: (out): location for the result
1638  *
1639  * Gets the value that is at the given index for the given tag in the given
1640  * list.
1641  *
1642  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1643  *              given list.
1644  */
1645 TAG_MERGE_FUNCS (uint, guint, TRUE);
1646 /**
1647  * gst_tag_list_get_int64:
1648  * @list: a #GstTagList to get the tag from
1649  * @tag: tag to read out
1650  * @value: (out): location for the result
1651  *
1652  * Copies the contents for the given tag into the value, merging multiple values
1653  * into one if multiple values are associated with the tag.
1654  *
1655  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1656  *              given list.
1657  */
1658 /**
1659  * gst_tag_list_get_int64_index:
1660  * @list: a #GstTagList to get the tag from
1661  * @tag: tag to read out
1662  * @index: number of entry to read out
1663  * @value: (out): location for the result
1664  *
1665  * Gets the value that is at the given index for the given tag in the given
1666  * list.
1667  *
1668  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1669  *              given list.
1670  */
1671 TAG_MERGE_FUNCS (int64, gint64, TRUE);
1672 /**
1673  * gst_tag_list_get_uint64:
1674  * @list: a #GstTagList to get the tag from
1675  * @tag: tag to read out
1676  * @value: (out): location for the result
1677  *
1678  * Copies the contents for the given tag into the value, merging multiple values
1679  * into one if multiple values are associated with the tag.
1680  *
1681  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1682  *              given list.
1683  */
1684 /**
1685  * gst_tag_list_get_uint64_index:
1686  * @list: a #GstTagList to get the tag from
1687  * @tag: tag to read out
1688  * @index: number of entry to read out
1689  * @value: (out): location for the result
1690  *
1691  * Gets the value that is at the given index for the given tag in the given
1692  * list.
1693  *
1694  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1695  *              given list.
1696  */
1697 TAG_MERGE_FUNCS (uint64, guint64, TRUE);
1698 /**
1699  * gst_tag_list_get_float:
1700  * @list: a #GstTagList to get the tag from
1701  * @tag: tag to read out
1702  * @value: (out): location for the result
1703  *
1704  * Copies the contents for the given tag into the value, merging multiple values
1705  * into one if multiple values are associated with the tag.
1706  *
1707  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1708  *              given list.
1709  */
1710 /**
1711  * gst_tag_list_get_float_index:
1712  * @list: a #GstTagList to get the tag from
1713  * @tag: tag to read out
1714  * @index: number of entry to read out
1715  * @value: (out): location for the result
1716  *
1717  * Gets the value that is at the given index for the given tag in the given
1718  * list.
1719  *
1720  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1721  *              given list.
1722  */
1723 TAG_MERGE_FUNCS (float, gfloat, TRUE);
1724 /**
1725  * gst_tag_list_get_double:
1726  * @list: a #GstTagList to get the tag from
1727  * @tag: tag to read out
1728  * @value: (out): location for the result
1729  *
1730  * Copies the contents for the given tag into the value, merging multiple values
1731  * into one if multiple values are associated with the tag.
1732  *
1733  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1734  *              given list.
1735  */
1736 /**
1737  * gst_tag_list_get_double_index:
1738  * @list: a #GstTagList to get the tag from
1739  * @tag: tag to read out
1740  * @index: number of entry to read out
1741  * @value: (out): location for the result
1742  *
1743  * Gets the value that is at the given index for the given tag in the given
1744  * list.
1745  *
1746  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1747  *              given list.
1748  */
1749 TAG_MERGE_FUNCS (double, gdouble, TRUE);
1750 /**
1751  * gst_tag_list_get_pointer:
1752  * @list: a #GstTagList to get the tag from
1753  * @tag: tag to read out
1754  * @value: (out) (transfer none): location for the result
1755  *
1756  * Copies the contents for the given tag into the value, merging multiple values
1757  * into one if multiple values are associated with the tag.
1758  *
1759  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1760  *              given list.
1761  */
1762 /**
1763  * gst_tag_list_get_pointer_index:
1764  * @list: a #GstTagList to get the tag from
1765  * @tag: tag to read out
1766  * @index: number of entry to read out
1767  * @value: (out) (transfer none): location for the result
1768  *
1769  * Gets the value that is at the given index for the given tag in the given
1770  * list.
1771  *
1772  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1773  *              given list.
1774  */
1775 TAG_MERGE_FUNCS (pointer, gpointer, (*value != NULL));
1776 
1777 static inline gchar *
1778 _gst_strdup0 (const gchar * s)
1779 {
1780   if (s == NULL || *s == &#39;\0&#39;)
1781     return NULL;
1782 
1783   return g_strdup (s);
1784 }
1785 
1786 #undef COPY_FUNC
1787 #define COPY_FUNC _gst_strdup0
1788 
1789 /**
1790  * gst_tag_list_get_string:
1791  * @list: a #GstTagList to get the tag from
1792  * @tag: tag to read out
1793  * @value: (out callee-allocates) (transfer full): location for the result
1794  *
1795  * Copies the contents for the given tag into the value, possibly merging
1796  * multiple values into one if multiple values are associated with the tag.
1797  *
1798  * Use gst_tag_list_get_string_index (list, tag, 0, value) if you want
1799  * to retrieve the first string associated with this tag unmodified.
1800  *
1801  * The resulting string in @value will be in UTF-8 encoding and should be
1802  * freed by the caller using g_free when no longer needed. The
1803  * returned string is also guaranteed to be non-%NULL and non-empty.
1804  *
1805  * Free-function: g_free
1806  *
1807  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1808  *              given list.
1809  */
1810 /**
1811  * gst_tag_list_get_string_index:
1812  * @list: a #GstTagList to get the tag from
1813  * @tag: tag to read out
1814  * @index: number of entry to read out
1815  * @value: (out callee-allocates) (transfer full): location for the result
1816  *
1817  * Gets the value that is at the given index for the given tag in the given
1818  * list.
1819  *
1820  * The resulting string in @value will be in UTF-8 encoding and should be
1821  * freed by the caller using g_free when no longer needed. The
1822  * returned string is also guaranteed to be non-%NULL and non-empty.
1823  *
1824  * Free-function: g_free
1825  *
1826  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1827  *              given list.
1828  */
1829 TAG_MERGE_FUNCS (string, gchar *, (*value != NULL));
1830 
1831 /*
1832  *FIXME 2.0: Instead of _peek (non-copy) and _get (copy), we could have
1833  *            _get (non-copy) and _dup (copy) for strings, seems more
1834  *            widely used
1835  */
1836 /**
1837  * gst_tag_list_peek_string_index:
1838  * @list: a #GstTagList to get the tag from
1839  * @tag: tag to read out
1840  * @index: number of entry to read out
1841  * @value: (out) (transfer none): location for the result
1842  *
1843  * Peeks at the value that is at the given index for the given tag in the given
1844  * list.
1845  *
1846  * The resulting string in @value will be in UTF-8 encoding and doesn&#39;t need
1847  * to be freed by the caller. The returned string is also guaranteed to
1848  * be non-%NULL and non-empty.
1849  *
1850  * Returns: %TRUE, if a value was set, %FALSE if the tag didn&#39;t exist in the
1851  *              given list.
1852  */
1853 gboolean
1854 gst_tag_list_peek_string_index (const GstTagList * list,
1855     const gchar * tag, guint index, const gchar ** value)
1856 {
1857   const GValue *v;
1858 
1859   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
1860   g_return_val_if_fail (tag != NULL, FALSE);
1861   g_return_val_if_fail (value != NULL, FALSE);
1862 
1863   if ((v = gst_tag_list_get_value_index (list, tag, index)) == NULL)
1864     return FALSE;
1865   *value = g_value_get_string (v);
1866   return *value != NULL &amp;&amp; **value != &#39;\0&#39;;
1867 }
1868 
1869 /**
1870  * gst_tag_list_get_date:
1871  * @list: a #GstTagList to get the tag from
1872  * @tag: tag to read out
1873  * @value: (out callee-allocates) (transfer full): address of a GDate pointer
1874  *     variable to store the result into
1875  *
1876  * Copies the first date for the given tag in the taglist into the variable
1877  * pointed to by @value. Free the date with g_date_free() when it is no longer
1878  * needed.
1879  *
1880  * Free-function: g_date_free
1881  *
1882  * Returns: %TRUE, if a date was copied, %FALSE if the tag didn&#39;t exist in the
1883  *              given list or if it was %NULL.
1884  */
1885 gboolean
1886 gst_tag_list_get_date (const GstTagList * list, const gchar * tag,
1887     GDate ** value)
1888 {
1889   GValue v = { 0, };
1890 
1891   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
1892   g_return_val_if_fail (tag != NULL, FALSE);
1893   g_return_val_if_fail (value != NULL, FALSE);
1894 
1895   if (!gst_tag_list_copy_value (&amp;v, list, tag))
1896     return FALSE;
1897   *value = (GDate *) g_value_dup_boxed (&amp;v);
1898   g_value_unset (&amp;v);
1899   return (*value != NULL);
1900 }
1901 
1902 /**
1903  * gst_tag_list_get_date_index:
1904  * @list: a #GstTagList to get the tag from
1905  * @tag: tag to read out
1906  * @index: number of entry to read out
1907  * @value: (out callee-allocates) (transfer full): location for the result
1908  *
1909  * Gets the date that is at the given index for the given tag in the given
1910  * list and copies it into the variable pointed to by @value. Free the date
1911  * with g_date_free() when it is no longer needed.
1912  *
1913  * Free-function: g_date_free
1914  *
1915  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1916  *              given list or if it was %NULL.
1917  */
1918 gboolean
1919 gst_tag_list_get_date_index (const GstTagList * list,
1920     const gchar * tag, guint index, GDate ** value)
1921 {
1922   const GValue *v;
1923 
1924   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
1925   g_return_val_if_fail (tag != NULL, FALSE);
1926   g_return_val_if_fail (value != NULL, FALSE);
1927 
1928   if ((v = gst_tag_list_get_value_index (list, tag, index)) == NULL)
1929     return FALSE;
1930   *value = (GDate *) g_value_dup_boxed (v);
1931   return (*value != NULL);
1932 }
1933 
1934 /**
1935  * gst_tag_list_get_date_time:
1936  * @list: a #GstTagList to get the tag from
1937  * @tag: tag to read out
1938  * @value: (out callee-allocates) (transfer full): address of a #GstDateTime
1939  *     pointer variable to store the result into
1940  *
1941  * Copies the first datetime for the given tag in the taglist into the variable
1942  * pointed to by @value. Unref the date with gst_date_time_unref() when
1943  * it is no longer needed.
1944  *
1945  * Free-function: gst_date_time_unref
1946  *
1947  * Returns: %TRUE, if a datetime was copied, %FALSE if the tag didn&#39;t exist in
1948  *              the given list or if it was %NULL.
1949  */
1950 gboolean
1951 gst_tag_list_get_date_time (const GstTagList * list, const gchar * tag,
1952     GstDateTime ** value)
1953 {
1954   GValue v = { 0, };
1955 
1956   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
1957   g_return_val_if_fail (tag != NULL, FALSE);
1958   g_return_val_if_fail (value != NULL, FALSE);
1959 
1960   if (!gst_tag_list_copy_value (&amp;v, list, tag))
1961     return FALSE;
1962 
1963   *value = (GstDateTime *) g_value_dup_boxed (&amp;v);
1964   g_value_unset (&amp;v);
1965   return (*value != NULL);
1966 }
1967 
1968 /**
1969  * gst_tag_list_get_date_time_index:
1970  * @list: a #GstTagList to get the tag from
1971  * @tag: tag to read out
1972  * @index: number of entry to read out
1973  * @value: (out callee-allocates) (transfer full): location for the result
1974  *
1975  * Gets the datetime that is at the given index for the given tag in the given
1976  * list and copies it into the variable pointed to by @value. Unref the datetime
1977  * with gst_date_time_unref() when it is no longer needed.
1978  *
1979  * Free-function: gst_date_time_unref
1980  *
1981  * Returns: %TRUE, if a value was copied, %FALSE if the tag didn&#39;t exist in the
1982  *              given list or if it was %NULL.
1983  */
1984 gboolean
1985 gst_tag_list_get_date_time_index (const GstTagList * list,
1986     const gchar * tag, guint index, GstDateTime ** value)
1987 {
1988   const GValue *v;
1989 
1990   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
1991   g_return_val_if_fail (tag != NULL, FALSE);
1992   g_return_val_if_fail (value != NULL, FALSE);
1993 
1994   if ((v = gst_tag_list_get_value_index (list, tag, index)) == NULL)
1995     return FALSE;
1996   *value = (GstDateTime *) g_value_dup_boxed (v);
1997   return (*value != NULL);
1998 }
1999 
2000 /**
2001  * gst_tag_list_get_sample:
2002  * @list: a #GstTagList to get the tag from
2003  * @tag: tag to read out
2004  * @sample: (out callee-allocates) (transfer full): address of a GstSample
2005  *     pointer variable to store the result into
2006  *
2007  * Copies the first sample for the given tag in the taglist into the variable
2008  * pointed to by @sample. Free the sample with gst_sample_unref() when it is
2009  * no longer needed. You can retrieve the buffer from the sample using
2010  * gst_sample_get_buffer() and the associated caps (if any) with
2011  * gst_sample_get_caps().
2012  *
2013  * Free-function: gst_sample_unref
2014  *
2015  * Returns: %TRUE, if a sample was returned, %FALSE if the tag didn&#39;t exist in
2016  *              the given list or if it was %NULL.
2017  */
2018 gboolean
2019 gst_tag_list_get_sample (const GstTagList * list, const gchar * tag,
2020     GstSample ** sample)
2021 {
2022   GValue v = { 0, };
2023 
2024   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
2025   g_return_val_if_fail (tag != NULL, FALSE);
2026   g_return_val_if_fail (sample != NULL, FALSE);
2027 
2028   if (!gst_tag_list_copy_value (&amp;v, list, tag))
2029     return FALSE;
2030   *sample = g_value_dup_boxed (&amp;v);
2031   g_value_unset (&amp;v);
2032   return (*sample != NULL);
2033 }
2034 
2035 /**
2036  * gst_tag_list_get_sample_index:
2037  * @list: a #GstTagList to get the tag from
2038  * @tag: tag to read out
2039  * @index: number of entry to read out
2040  * @sample: (out callee-allocates) (transfer full): address of a GstSample
2041  *     pointer variable to store the result into
2042  *
2043  * Gets the sample that is at the given index for the given tag in the given
2044  * list and copies it into the variable pointed to by @sample. Free the sample
2045  * with gst_sample_unref() when it is no longer needed. You can retrieve the
2046  * buffer from the sample using gst_sample_get_buffer() and the associated
2047  * caps (if any) with gst_sample_get_caps().
2048  *
2049  * Free-function: gst_sample_unref
2050  *
2051  * Returns: %TRUE, if a sample was copied, %FALSE if the tag didn&#39;t exist in the
2052  *              given list or if it was %NULL.
2053  */
2054 gboolean
2055 gst_tag_list_get_sample_index (const GstTagList * list,
2056     const gchar * tag, guint index, GstSample ** sample)
2057 {
2058   const GValue *v;
2059 
2060   g_return_val_if_fail (GST_IS_TAG_LIST (list), FALSE);
2061   g_return_val_if_fail (tag != NULL, FALSE);
2062   g_return_val_if_fail (sample != NULL, FALSE);
2063 
2064   if ((v = gst_tag_list_get_value_index (list, tag, index)) == NULL)
2065     return FALSE;
2066   *sample = g_value_dup_boxed (v);
2067   return (*sample != NULL);
2068 }
    </pre>
  </body>
</html>