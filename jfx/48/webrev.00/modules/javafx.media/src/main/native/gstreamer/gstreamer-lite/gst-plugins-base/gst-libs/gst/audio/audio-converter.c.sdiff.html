<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/audio-converter.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="audio-channels.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="audio-converter.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/audio-converter.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 #ifdef HAVE_CONFIG_H
  24 #include &quot;config.h&quot;
  25 #endif
  26 
  27 #include &lt;math.h&gt;
  28 #include &lt;string.h&gt;
  29 
  30 #include &quot;audio-converter.h&quot;
  31 #include &quot;gstaudiopack.h&quot;
  32 
  33 /**
<span class="line-modified">  34  * SECTION:audioconverter</span>
  35  * @title: GstAudioConverter
  36  * @short_description: Generic audio conversion
  37  *
  38  * This object is used to convert audio samples from one format to another.
  39  * The object can perform conversion of:
  40  *
  41  *  * audio format with optional dithering and noise shaping
  42  *
  43  *  * audio samplerate
  44  *
  45  *  * audio channels and channel layout
  46  *
  47  */
  48 
  49 #ifndef GST_DISABLE_GST_DEBUG
  50 #define GST_CAT_DEFAULT ensure_debug_category()
  51 static GstDebugCategory *
  52 ensure_debug_category (void)
  53 {
  54   static gsize cat_gonce = 0;
</pre>
<hr />
<pre>
  94 struct _GstAudioConverter
  95 {
  96   GstAudioInfo in;
  97   GstAudioInfo out;
  98 
  99   GstStructure *config;
 100 
 101   GstAudioConverterFlags flags;
 102   GstAudioFormat current_format;
 103   GstAudioLayout current_layout;
 104   gint current_channels;
 105 
 106   gboolean in_writable;
 107   gpointer *in_data;
 108   gsize in_frames;
 109   gpointer *out_data;
 110   gsize out_frames;
 111 
 112   gboolean in_place;            /* the conversion can be done in place; returned by gst_audio_converter_supports_inplace() */
 113 


 114   /* unpack */
 115   gboolean in_default;
 116   gboolean unpack_ip;
 117 
 118   /* convert in */
 119   AudioConvertFunc convert_in;
 120 
 121   /* channel mix */
 122   gboolean mix_passthrough;
 123   GstAudioChannelMixer *mix;
 124 
 125   /* resample */
 126   GstAudioResampler *resampler;
 127 
 128   /* convert out */
 129   AudioConvertFunc convert_out;
 130 
 131   /* quant */
 132   GstAudioQuantize *quant;
 133 





 134   /* pack */
 135   gboolean out_default;
 136   AudioChain *chain_end;        /* NULL for empty chain or points to the last element in the chain */
 137 
 138   /* endian swap */
 139   AudioConvertEndianFunc swap_endian;
 140 
 141   AudioConvertSamplesFunc convert;
 142 };
 143 
 144 static GstAudioConverter *
 145 gst_audio_converter_copy (GstAudioConverter * convert)
 146 {
 147   GstAudioConverter *res =
 148       gst_audio_converter_new (convert-&gt;flags, &amp;convert-&gt;in, &amp;convert-&gt;out,
 149       convert-&gt;config);
 150 
 151   return res;
 152 }
 153 
</pre>
<hr />
<pre>
 565 }
 566 
 567 static gboolean
 568 do_quantize (AudioChain * chain, gpointer user_data)
 569 {
 570   GstAudioConverter *convert = user_data;
 571   gsize num_samples;
 572   gpointer *in, *out;
 573 
 574   in = audio_chain_get_samples (chain-&gt;prev, &amp;num_samples);
 575   out = (chain-&gt;allow_ip ? in : audio_chain_alloc_samples (chain, num_samples));
 576   GST_LOG (&quot;quantize %p, %p %&quot; G_GSIZE_FORMAT, in, out, num_samples);
 577 
 578   gst_audio_quantize_samples (convert-&gt;quant, in, out, num_samples);
 579 
 580   audio_chain_set_samples (chain, out, num_samples);
 581 
 582   return TRUE;
 583 }
 584 








































































































 585 static gboolean
 586 is_intermediate_format (GstAudioFormat format)
 587 {
 588   return (format == GST_AUDIO_FORMAT_S16 ||
 589       format == GST_AUDIO_FORMAT_S32 ||
 590       format == GST_AUDIO_FORMAT_F32 || format == GST_AUDIO_FORMAT_F64);
 591 }
 592 
 593 static AudioChain *
 594 chain_unpack (GstAudioConverter * convert)
 595 {
 596   AudioChain *prev;
 597   GstAudioInfo *in = &amp;convert-&gt;in;
 598   GstAudioInfo *out = &amp;convert-&gt;out;
 599   gboolean same_format;
 600 
 601   same_format = in-&gt;finfo-&gt;format == out-&gt;finfo-&gt;format;
 602 
 603   /* do not unpack if we have the same input format as the output format
 604    * and it is a possible intermediate format */
</pre>
<hr />
<pre>
 702     for (i = 0; i &lt; in_channels; i++) {
 703       const GValue *itm;
 704       gfloat coefficient;
 705 
 706       itm = gst_value_array_get_value (row, i);
 707       coefficient = g_value_get_float (itm);
 708       matrix[i][j] = coefficient;
 709     }
 710   }
 711 
 712   return matrix;
 713 }
 714 
 715 static AudioChain *
 716 chain_mix (GstAudioConverter * convert, AudioChain * prev)
 717 {
 718   GstAudioInfo *in = &amp;convert-&gt;in;
 719   GstAudioInfo *out = &amp;convert-&gt;out;
 720   GstAudioFormat format = convert-&gt;current_format;
 721   const GValue *opt_matrix = GET_OPT_MIX_MATRIX (convert);

 722 
 723   convert-&gt;current_channels = out-&gt;channels;
 724 






 725   if (opt_matrix) {
 726     gfloat **matrix = NULL;
 727 
 728     if (gst_value_array_get_size (opt_matrix))
 729       matrix =
 730           mix_matrix_from_g_value (in-&gt;channels, out-&gt;channels, opt_matrix);
 731 
 732     convert-&gt;mix =
<span class="line-modified"> 733         gst_audio_channel_mixer_new_with_matrix (0, format, in-&gt;channels,</span>
 734         out-&gt;channels, matrix);
 735   } else {
<span class="line-modified"> 736     GstAudioChannelMixerFlags flags;</span>
<span class="line-removed"> 737 </span>
<span class="line-removed"> 738     flags =</span>
 739         GST_AUDIO_INFO_IS_UNPOSITIONED (in) ?
 740         GST_AUDIO_CHANNEL_MIXER_FLAGS_UNPOSITIONED_IN : 0;
 741     flags |=
 742         GST_AUDIO_INFO_IS_UNPOSITIONED (out) ?
 743         GST_AUDIO_CHANNEL_MIXER_FLAGS_UNPOSITIONED_OUT : 0;
 744 
 745     convert-&gt;mix =
 746         gst_audio_channel_mixer_new (flags, format, in-&gt;channels, in-&gt;position,
 747         out-&gt;channels, out-&gt;position);
 748   }
 749 
 750   convert-&gt;mix_passthrough =
 751       gst_audio_channel_mixer_is_passthrough (convert-&gt;mix);
 752   GST_INFO (&quot;mix format %s, passthrough %d, in_channels %d, out_channels %d&quot;,
 753       gst_audio_format_to_string (format), convert-&gt;mix_passthrough,
 754       in-&gt;channels, out-&gt;channels);
 755 
 756   if (!convert-&gt;mix_passthrough) {
 757     prev = audio_chain_new (prev, convert);
 758     prev-&gt;allow_ip = FALSE;
</pre>
<hr />
<pre>
 764 
 765 static AudioChain *
 766 chain_resample (GstAudioConverter * convert, AudioChain * prev)
 767 {
 768   GstAudioInfo *in = &amp;convert-&gt;in;
 769   GstAudioInfo *out = &amp;convert-&gt;out;
 770   GstAudioResamplerMethod method;
 771   GstAudioResamplerFlags flags;
 772   GstAudioFormat format = convert-&gt;current_format;
 773   gint channels = convert-&gt;current_channels;
 774   gboolean variable_rate;
 775 
 776   variable_rate = convert-&gt;flags &amp; GST_AUDIO_CONVERTER_FLAG_VARIABLE_RATE;
 777 
 778   if (in-&gt;rate != out-&gt;rate || variable_rate) {
 779     method = GET_OPT_RESAMPLER_METHOD (convert);
 780 
 781     flags = 0;
 782     if (convert-&gt;current_layout == GST_AUDIO_LAYOUT_NON_INTERLEAVED) {
 783       flags |= GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_IN;



 784       flags |= GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_OUT;
 785     }


 786     if (variable_rate)
 787       flags |= GST_AUDIO_RESAMPLER_FLAG_VARIABLE_RATE;
 788 
 789     convert-&gt;resampler =
 790         gst_audio_resampler_new (method, flags, format, channels, in-&gt;rate,
 791         out-&gt;rate, convert-&gt;config);
 792 
 793     prev = audio_chain_new (prev, convert);
 794     prev-&gt;allow_ip = FALSE;
 795     prev-&gt;pass_alloc = FALSE;
 796     audio_chain_set_make_func (prev, do_resample, convert, NULL);
 797   }
 798   return prev;
 799 }
 800 
 801 static AudioChain *
 802 chain_convert_out (GstAudioConverter * convert, AudioChain * prev)
 803 {
 804   gboolean in_int, out_int;
 805   GstAudioInfo *in = &amp;convert-&gt;in;
</pre>
<hr />
<pre>
 858     if (ns &gt; GST_AUDIO_NOISE_SHAPING_ERROR_FEEDBACK &amp;&amp; out-&gt;rate &lt; 32000)
 859       ns = GST_AUDIO_NOISE_SHAPING_ERROR_FEEDBACK;
 860   }
 861   /* we still want to run the quantization step when reducing bits to get
 862    * the rounding correct */
 863   if (out_int &amp;&amp; out_depth &lt; 32
 864       &amp;&amp; convert-&gt;current_format == GST_AUDIO_FORMAT_S32) {
 865     GST_INFO (&quot;quantize to %d bits, dither %d, ns %d&quot;, out_depth, dither, ns);
 866     convert-&gt;quant =
 867         gst_audio_quantize_new (dither, ns, 0, convert-&gt;current_format,
 868         out-&gt;channels, 1U &lt;&lt; (32 - out_depth));
 869 
 870     prev = audio_chain_new (prev, convert);
 871     prev-&gt;allow_ip = TRUE;
 872     prev-&gt;pass_alloc = TRUE;
 873     audio_chain_set_make_func (prev, do_quantize, convert, NULL);
 874   }
 875   return prev;
 876 }
 877 























 878 static AudioChain *
 879 chain_pack (GstAudioConverter * convert, AudioChain * prev)
 880 {
 881   GstAudioInfo *out = &amp;convert-&gt;out;
 882   GstAudioFormat format = convert-&gt;current_format;
 883 
 884   convert-&gt;current_format = out-&gt;finfo-&gt;format;
 885 
 886   convert-&gt;out_default = format == out-&gt;finfo-&gt;format;
 887   GST_INFO (&quot;pack format %s to %s&quot;, gst_audio_format_to_string (format),
 888       gst_audio_format_to_string (out-&gt;finfo-&gt;format));
 889 
 890   return prev;
 891 }
 892 
 893 static void
 894 setup_allocators (GstAudioConverter * convert)
 895 {
 896   AudioChain *chain;
 897   AudioChainAllocFunc alloc_func;
</pre>
<hr />
<pre>
1135     /* and pack if needed */
1136     for (i = 0; i &lt; chain-&gt;blocks; i++)
1137       convert-&gt;out.finfo-&gt;pack_func (convert-&gt;out.finfo, 0, tmp[i], out[i],
1138           produced * chain-&gt;inc);
1139   }
1140   return TRUE;
1141 }
1142 
1143 static gboolean
1144 converter_resample (GstAudioConverter * convert,
1145     GstAudioConverterFlags flags, gpointer in[], gsize in_frames,
1146     gpointer out[], gsize out_frames)
1147 {
1148   gst_audio_resampler_resample (convert-&gt;resampler, in, in_frames, out,
1149       out_frames);
1150 
1151   return TRUE;
1152 }
1153 
1154 #define GST_AUDIO_FORMAT_IS_ENDIAN_CONVERSION(info1, info2) \
<span class="line-modified">1155         ( \</span>
<span class="line-modified">1156             !(((info1)-&gt;flags ^ (info2)-&gt;flags) &amp; (~GST_AUDIO_FORMAT_FLAG_UNPACK)) &amp;&amp; \</span>
<span class="line-modified">1157             (info1)-&gt;endianness != (info2)-&gt;endianness &amp;&amp; \</span>
<span class="line-modified">1158             (info1)-&gt;width == (info2)-&gt;width &amp;&amp; \</span>
<span class="line-modified">1159             (info1)-&gt;depth == (info2)-&gt;depth \</span>
<span class="line-modified">1160         )</span>
1161 
1162 /**
1163  * gst_audio_converter_new:
1164  * @flags: extra #GstAudioConverterFlags
1165  * @in_info: a source #GstAudioInfo
1166  * @out_info: a destination #GstAudioInfo
1167  * @config: (transfer full) (nullable): a #GstStructure with configuration options
1168  *
1169  * Create a new #GstAudioConverter that is able to convert between @in and @out
1170  * audio formats.
1171  *
<span class="line-modified">1172  * @config contains extra configuration options, see #GST_VIDEO_CONVERTER_OPT_*</span>
1173  * parameters for details about the options and values.
1174  *
1175  * Returns: a #GstAudioConverter or %NULL if conversion is not possible.
1176  */
1177 GstAudioConverter *
1178 gst_audio_converter_new (GstAudioConverterFlags flags, GstAudioInfo * in_info,
1179     GstAudioInfo * out_info, GstStructure * config)
1180 {
1181   GstAudioConverter *convert;
1182   AudioChain *prev;
1183   const GValue *opt_matrix = NULL;
1184 
1185   g_return_val_if_fail (in_info != NULL, FALSE);
1186   g_return_val_if_fail (out_info != NULL, FALSE);
<span class="line-removed">1187   g_return_val_if_fail (in_info-&gt;layout == GST_AUDIO_LAYOUT_INTERLEAVED, FALSE);</span>
<span class="line-removed">1188   g_return_val_if_fail (in_info-&gt;layout == out_info-&gt;layout, FALSE);</span>
1189 
1190   if (config)
1191     opt_matrix =
1192         gst_structure_get_value (config, GST_AUDIO_CONVERTER_OPT_MIX_MATRIX);
1193 
1194   if (opt_matrix
1195       &amp;&amp; !check_mix_matrix (in_info-&gt;channels, out_info-&gt;channels, opt_matrix))
1196     goto invalid_mix_matrix;
1197 
1198   if ((GST_AUDIO_INFO_CHANNELS (in_info) != GST_AUDIO_INFO_CHANNELS (out_info))
1199       &amp;&amp; (GST_AUDIO_INFO_IS_UNPOSITIONED (in_info)
1200           || GST_AUDIO_INFO_IS_UNPOSITIONED (out_info))
1201       &amp;&amp; !opt_matrix)
1202     goto unpositioned;
1203 
1204   convert = g_slice_new0 (GstAudioConverter);
1205 
1206   convert-&gt;flags = flags;
1207   convert-&gt;in = *in_info;
1208   convert-&gt;out = *out_info;
1209 
1210   /* default config */
1211   convert-&gt;config = gst_structure_new_empty (&quot;GstAudioConverter&quot;);
1212   if (config)
1213     gst_audio_converter_update_config (convert, 0, 0, config);
1214 
1215   GST_INFO (&quot;unitsizes: %d -&gt; %d&quot;, in_info-&gt;bpf, out_info-&gt;bpf);
1216 
1217   /* step 1, unpack */
1218   prev = chain_unpack (convert);
1219   /* step 2, optional convert from S32 to F64 for channel mix */
1220   prev = chain_convert_in (convert, prev);
1221   /* step 3, channel mix */
1222   prev = chain_mix (convert, prev);
1223   /* step 4, resample */
1224   prev = chain_resample (convert, prev);
1225   /* step 5, optional convert for quantize */
1226   prev = chain_convert_out (convert, prev);
1227   /* step 6, optional quantize */
1228   prev = chain_quantize (convert, prev);
<span class="line-modified">1229   /* step 7, pack */</span>


1230   convert-&gt;chain_end = chain_pack (convert, prev);
1231 
1232   convert-&gt;convert = converter_generic;
1233   convert-&gt;in_place = FALSE;

1234 
1235   /* optimize */
1236   if (convert-&gt;mix_passthrough) {
1237     if (out_info-&gt;finfo-&gt;format == in_info-&gt;finfo-&gt;format) {
1238       if (convert-&gt;resampler == NULL) {
<span class="line-modified">1239         GST_INFO</span>
<span class="line-modified">1240             (&quot;same formats, no resampler and passthrough mixing -&gt; passthrough&quot;);</span>
<span class="line-modified">1241         convert-&gt;convert = converter_passthrough;</span>
<span class="line-modified">1242         convert-&gt;in_place = TRUE;</span>



1243       } else {
1244         if (is_intermediate_format (in_info-&gt;finfo-&gt;format)) {
1245           GST_INFO (&quot;same formats, and passthrough mixing -&gt; only resampling&quot;);
1246           convert-&gt;convert = converter_resample;
1247         }
1248       }
1249     } else if (GST_AUDIO_FORMAT_IS_ENDIAN_CONVERSION (out_info-&gt;finfo,
1250             in_info-&gt;finfo)) {
<span class="line-modified">1251       if (convert-&gt;resampler == NULL) {</span>
1252         GST_INFO (&quot;no resampler, passthrough mixing -&gt; only endian conversion&quot;);
1253         convert-&gt;convert = converter_endian;
1254         convert-&gt;in_place = TRUE;
1255 
<span class="line-modified">1256         switch (GST_AUDIO_INFO_BPS (in_info)) {</span>
<span class="line-modified">1257           case 2:</span>
1258             GST_DEBUG (&quot;initializing 16-bit endian conversion&quot;);
1259             convert-&gt;swap_endian = converter_swap_endian_16;
1260             break;
<span class="line-modified">1261           case 3:</span>
1262             GST_DEBUG (&quot;initializing 24-bit endian conversion&quot;);
1263             convert-&gt;swap_endian = converter_swap_endian_24;
1264             break;
<span class="line-modified">1265           case 4:</span>
1266             GST_DEBUG (&quot;initializing 32-bit endian conversion&quot;);
1267             convert-&gt;swap_endian = converter_swap_endian_32;
1268             break;
<span class="line-modified">1269           case 8:</span>
1270             GST_DEBUG (&quot;initializing 64-bit endian conversion&quot;);
1271             convert-&gt;swap_endian = converter_swap_endian_64;
1272             break;
1273           default:
1274             GST_ERROR (&quot;unsupported sample width for endian conversion&quot;);
1275             g_assert_not_reached ();
1276         }
1277       }
1278     }
1279   }
1280 
1281   setup_allocators (convert);
1282 
1283   return convert;
1284 
1285   /* ERRORS */
1286 unpositioned:
1287   {
1288     GST_WARNING (&quot;unpositioned channels&quot;);
1289     return NULL;
</pre>
<hr />
<pre>
1433  *
1434  * Returns: %TRUE is the conversion could be performed.
1435  */
1436 gboolean
1437 gst_audio_converter_samples (GstAudioConverter * convert,
1438     GstAudioConverterFlags flags, gpointer in[], gsize in_frames,
1439     gpointer out[], gsize out_frames)
1440 {
1441   g_return_val_if_fail (convert != NULL, FALSE);
1442   g_return_val_if_fail (out != NULL, FALSE);
1443 
1444   if (in_frames == 0) {
1445     GST_LOG (&quot;skipping empty buffer&quot;);
1446     return TRUE;
1447   }
1448   return convert-&gt;convert (convert, flags, in, in_frames, out, out_frames);
1449 }
1450 
1451 /**
1452  * gst_audio_converter_convert:

1453  * @flags: extra #GstAudioConverterFlags
1454  * @in: (array length=in_size) (element-type guint8): input data
1455  * @in_size: size of @in
1456  * @out: (out) (array length=out_size) (element-type guint8): a pointer where
1457  *  the output data will be written
1458  * @out_size: (out): a pointer where the size of @out will be written
1459  *
1460  * Convenience wrapper around gst_audio_converter_samples(), which will
1461  * perform allocation of the output buffer based on the result from
1462  * gst_audio_converter_get_out_frames().
1463  *
1464  * Returns: %TRUE is the conversion could be performed.
1465  *
1466  * Since: 1.14
1467  */
1468 gboolean
1469 gst_audio_converter_convert (GstAudioConverter * convert,
1470     GstAudioConverterFlags flags, gpointer in, gsize in_size,
1471     gpointer * out, gsize * out_size)
1472 {
</pre>
<hr />
<pre>
1483   *out = g_malloc0 (*out_size);
1484 
1485   return gst_audio_converter_samples (convert, flags, &amp;in, in_frames, out,
1486       out_frames);
1487 }
1488 
1489 /**
1490  * gst_audio_converter_supports_inplace:
1491  * @convert: a #GstAudioConverter
1492  *
1493  * Returns whether the audio converter can perform the conversion in-place.
1494  * The return value would be typically input to gst_base_transform_set_in_place()
1495  *
1496  * Returns: %TRUE when the conversion can be done in place.
1497  */
1498 gboolean
1499 gst_audio_converter_supports_inplace (GstAudioConverter * convert)
1500 {
1501   return convert-&gt;in_place;
1502 }
















</pre>
</td>
<td>
<hr />
<pre>
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 #ifdef HAVE_CONFIG_H
  24 #include &quot;config.h&quot;
  25 #endif
  26 
  27 #include &lt;math.h&gt;
  28 #include &lt;string.h&gt;
  29 
  30 #include &quot;audio-converter.h&quot;
  31 #include &quot;gstaudiopack.h&quot;
  32 
  33 /**
<span class="line-modified">  34  * SECTION:gstaudioconverter</span>
  35  * @title: GstAudioConverter
  36  * @short_description: Generic audio conversion
  37  *
  38  * This object is used to convert audio samples from one format to another.
  39  * The object can perform conversion of:
  40  *
  41  *  * audio format with optional dithering and noise shaping
  42  *
  43  *  * audio samplerate
  44  *
  45  *  * audio channels and channel layout
  46  *
  47  */
  48 
  49 #ifndef GST_DISABLE_GST_DEBUG
  50 #define GST_CAT_DEFAULT ensure_debug_category()
  51 static GstDebugCategory *
  52 ensure_debug_category (void)
  53 {
  54   static gsize cat_gonce = 0;
</pre>
<hr />
<pre>
  94 struct _GstAudioConverter
  95 {
  96   GstAudioInfo in;
  97   GstAudioInfo out;
  98 
  99   GstStructure *config;
 100 
 101   GstAudioConverterFlags flags;
 102   GstAudioFormat current_format;
 103   GstAudioLayout current_layout;
 104   gint current_channels;
 105 
 106   gboolean in_writable;
 107   gpointer *in_data;
 108   gsize in_frames;
 109   gpointer *out_data;
 110   gsize out_frames;
 111 
 112   gboolean in_place;            /* the conversion can be done in place; returned by gst_audio_converter_supports_inplace() */
 113 
<span class="line-added"> 114   gboolean passthrough;</span>
<span class="line-added"> 115 </span>
 116   /* unpack */
 117   gboolean in_default;
 118   gboolean unpack_ip;
 119 
 120   /* convert in */
 121   AudioConvertFunc convert_in;
 122 
 123   /* channel mix */
 124   gboolean mix_passthrough;
 125   GstAudioChannelMixer *mix;
 126 
 127   /* resample */
 128   GstAudioResampler *resampler;
 129 
 130   /* convert out */
 131   AudioConvertFunc convert_out;
 132 
 133   /* quant */
 134   GstAudioQuantize *quant;
 135 
<span class="line-added"> 136   /* change layout */</span>
<span class="line-added"> 137   GstAudioFormat chlayout_format;</span>
<span class="line-added"> 138   GstAudioLayout chlayout_target;</span>
<span class="line-added"> 139   gint chlayout_channels;</span>
<span class="line-added"> 140 </span>
 141   /* pack */
 142   gboolean out_default;
 143   AudioChain *chain_end;        /* NULL for empty chain or points to the last element in the chain */
 144 
 145   /* endian swap */
 146   AudioConvertEndianFunc swap_endian;
 147 
 148   AudioConvertSamplesFunc convert;
 149 };
 150 
 151 static GstAudioConverter *
 152 gst_audio_converter_copy (GstAudioConverter * convert)
 153 {
 154   GstAudioConverter *res =
 155       gst_audio_converter_new (convert-&gt;flags, &amp;convert-&gt;in, &amp;convert-&gt;out,
 156       convert-&gt;config);
 157 
 158   return res;
 159 }
 160 
</pre>
<hr />
<pre>
 572 }
 573 
 574 static gboolean
 575 do_quantize (AudioChain * chain, gpointer user_data)
 576 {
 577   GstAudioConverter *convert = user_data;
 578   gsize num_samples;
 579   gpointer *in, *out;
 580 
 581   in = audio_chain_get_samples (chain-&gt;prev, &amp;num_samples);
 582   out = (chain-&gt;allow_ip ? in : audio_chain_alloc_samples (chain, num_samples));
 583   GST_LOG (&quot;quantize %p, %p %&quot; G_GSIZE_FORMAT, in, out, num_samples);
 584 
 585   gst_audio_quantize_samples (convert-&gt;quant, in, out, num_samples);
 586 
 587   audio_chain_set_samples (chain, out, num_samples);
 588 
 589   return TRUE;
 590 }
 591 
<span class="line-added"> 592 #define MAKE_INTERLEAVE_FUNC(type) \</span>
<span class="line-added"> 593 static inline void \</span>
<span class="line-added"> 594 interleave_##type (const type * in[], type * out[], \</span>
<span class="line-added"> 595     gsize num_samples, gint channels) \</span>
<span class="line-added"> 596 { \</span>
<span class="line-added"> 597   gsize s; \</span>
<span class="line-added"> 598   gint c; \</span>
<span class="line-added"> 599   for (s = 0; s &lt; num_samples; s++) { \</span>
<span class="line-added"> 600     for (c = 0; c &lt; channels; c++) { \</span>
<span class="line-added"> 601       out[0][s * channels + c] = in[c][s]; \</span>
<span class="line-added"> 602     } \</span>
<span class="line-added"> 603   } \</span>
<span class="line-added"> 604 }</span>
<span class="line-added"> 605 </span>
<span class="line-added"> 606 #define MAKE_DEINTERLEAVE_FUNC(type) \</span>
<span class="line-added"> 607 static inline void \</span>
<span class="line-added"> 608 deinterleave_##type (const type * in[], type * out[], \</span>
<span class="line-added"> 609     gsize num_samples, gint channels) \</span>
<span class="line-added"> 610 { \</span>
<span class="line-added"> 611   gsize s; \</span>
<span class="line-added"> 612   gint c; \</span>
<span class="line-added"> 613   for (s = 0; s &lt; num_samples; s++) { \</span>
<span class="line-added"> 614     for (c = 0; c &lt; channels; c++) { \</span>
<span class="line-added"> 615       out[c][s] = in[0][s * channels + c]; \</span>
<span class="line-added"> 616     } \</span>
<span class="line-added"> 617   } \</span>
<span class="line-added"> 618 }</span>
<span class="line-added"> 619 </span>
<span class="line-added"> 620 MAKE_INTERLEAVE_FUNC (gint16);</span>
<span class="line-added"> 621 MAKE_INTERLEAVE_FUNC (gint32);</span>
<span class="line-added"> 622 MAKE_INTERLEAVE_FUNC (gfloat);</span>
<span class="line-added"> 623 MAKE_INTERLEAVE_FUNC (gdouble);</span>
<span class="line-added"> 624 MAKE_DEINTERLEAVE_FUNC (gint16);</span>
<span class="line-added"> 625 MAKE_DEINTERLEAVE_FUNC (gint32);</span>
<span class="line-added"> 626 MAKE_DEINTERLEAVE_FUNC (gfloat);</span>
<span class="line-added"> 627 MAKE_DEINTERLEAVE_FUNC (gdouble);</span>
<span class="line-added"> 628 </span>
<span class="line-added"> 629 static gboolean</span>
<span class="line-added"> 630 do_change_layout (AudioChain * chain, gpointer user_data)</span>
<span class="line-added"> 631 {</span>
<span class="line-added"> 632   GstAudioConverter *convert = user_data;</span>
<span class="line-added"> 633   GstAudioFormat format = convert-&gt;chlayout_format;</span>
<span class="line-added"> 634   GstAudioLayout out_layout = convert-&gt;chlayout_target;</span>
<span class="line-added"> 635   gint channels = convert-&gt;chlayout_channels;</span>
<span class="line-added"> 636   gsize num_samples;</span>
<span class="line-added"> 637   gpointer *in, *out;</span>
<span class="line-added"> 638 </span>
<span class="line-added"> 639   in = audio_chain_get_samples (chain-&gt;prev, &amp;num_samples);</span>
<span class="line-added"> 640   out = (chain-&gt;allow_ip ? in : audio_chain_alloc_samples (chain, num_samples));</span>
<span class="line-added"> 641 </span>
<span class="line-added"> 642   if (out_layout == GST_AUDIO_LAYOUT_INTERLEAVED) {</span>
<span class="line-added"> 643     /* interleave */</span>
<span class="line-added"> 644     GST_LOG (&quot;interleaving %p, %p %&quot; G_GSIZE_FORMAT, in, out, num_samples);</span>
<span class="line-added"> 645     switch (format) {</span>
<span class="line-added"> 646       case GST_AUDIO_FORMAT_S16:</span>
<span class="line-added"> 647         interleave_gint16 ((const gint16 **) in, (gint16 **) out,</span>
<span class="line-added"> 648             num_samples, channels);</span>
<span class="line-added"> 649         break;</span>
<span class="line-added"> 650       case GST_AUDIO_FORMAT_S32:</span>
<span class="line-added"> 651         interleave_gint32 ((const gint32 **) in, (gint32 **) out,</span>
<span class="line-added"> 652             num_samples, channels);</span>
<span class="line-added"> 653         break;</span>
<span class="line-added"> 654       case GST_AUDIO_FORMAT_F32:</span>
<span class="line-added"> 655         interleave_gfloat ((const gfloat **) in, (gfloat **) out,</span>
<span class="line-added"> 656             num_samples, channels);</span>
<span class="line-added"> 657         break;</span>
<span class="line-added"> 658       case GST_AUDIO_FORMAT_F64:</span>
<span class="line-added"> 659         interleave_gdouble ((const gdouble **) in, (gdouble **) out,</span>
<span class="line-added"> 660             num_samples, channels);</span>
<span class="line-added"> 661         break;</span>
<span class="line-added"> 662       default:</span>
<span class="line-added"> 663         g_assert_not_reached ();</span>
<span class="line-added"> 664         break;</span>
<span class="line-added"> 665     }</span>
<span class="line-added"> 666   } else {</span>
<span class="line-added"> 667     /* deinterleave */</span>
<span class="line-added"> 668     GST_LOG (&quot;deinterleaving %p, %p %&quot; G_GSIZE_FORMAT, in, out, num_samples);</span>
<span class="line-added"> 669     switch (format) {</span>
<span class="line-added"> 670       case GST_AUDIO_FORMAT_S16:</span>
<span class="line-added"> 671         deinterleave_gint16 ((const gint16 **) in, (gint16 **) out,</span>
<span class="line-added"> 672             num_samples, channels);</span>
<span class="line-added"> 673         break;</span>
<span class="line-added"> 674       case GST_AUDIO_FORMAT_S32:</span>
<span class="line-added"> 675         deinterleave_gint32 ((const gint32 **) in, (gint32 **) out,</span>
<span class="line-added"> 676             num_samples, channels);</span>
<span class="line-added"> 677         break;</span>
<span class="line-added"> 678       case GST_AUDIO_FORMAT_F32:</span>
<span class="line-added"> 679         deinterleave_gfloat ((const gfloat **) in, (gfloat **) out,</span>
<span class="line-added"> 680             num_samples, channels);</span>
<span class="line-added"> 681         break;</span>
<span class="line-added"> 682       case GST_AUDIO_FORMAT_F64:</span>
<span class="line-added"> 683         deinterleave_gdouble ((const gdouble **) in, (gdouble **) out,</span>
<span class="line-added"> 684             num_samples, channels);</span>
<span class="line-added"> 685         break;</span>
<span class="line-added"> 686       default:</span>
<span class="line-added"> 687         g_assert_not_reached ();</span>
<span class="line-added"> 688         break;</span>
<span class="line-added"> 689     }</span>
<span class="line-added"> 690   }</span>
<span class="line-added"> 691 </span>
<span class="line-added"> 692   audio_chain_set_samples (chain, out, num_samples);</span>
<span class="line-added"> 693   return TRUE;</span>
<span class="line-added"> 694 }</span>
<span class="line-added"> 695 </span>
 696 static gboolean
 697 is_intermediate_format (GstAudioFormat format)
 698 {
 699   return (format == GST_AUDIO_FORMAT_S16 ||
 700       format == GST_AUDIO_FORMAT_S32 ||
 701       format == GST_AUDIO_FORMAT_F32 || format == GST_AUDIO_FORMAT_F64);
 702 }
 703 
 704 static AudioChain *
 705 chain_unpack (GstAudioConverter * convert)
 706 {
 707   AudioChain *prev;
 708   GstAudioInfo *in = &amp;convert-&gt;in;
 709   GstAudioInfo *out = &amp;convert-&gt;out;
 710   gboolean same_format;
 711 
 712   same_format = in-&gt;finfo-&gt;format == out-&gt;finfo-&gt;format;
 713 
 714   /* do not unpack if we have the same input format as the output format
 715    * and it is a possible intermediate format */
</pre>
<hr />
<pre>
 813     for (i = 0; i &lt; in_channels; i++) {
 814       const GValue *itm;
 815       gfloat coefficient;
 816 
 817       itm = gst_value_array_get_value (row, i);
 818       coefficient = g_value_get_float (itm);
 819       matrix[i][j] = coefficient;
 820     }
 821   }
 822 
 823   return matrix;
 824 }
 825 
 826 static AudioChain *
 827 chain_mix (GstAudioConverter * convert, AudioChain * prev)
 828 {
 829   GstAudioInfo *in = &amp;convert-&gt;in;
 830   GstAudioInfo *out = &amp;convert-&gt;out;
 831   GstAudioFormat format = convert-&gt;current_format;
 832   const GValue *opt_matrix = GET_OPT_MIX_MATRIX (convert);
<span class="line-added"> 833   GstAudioChannelMixerFlags flags = 0;</span>
 834 
 835   convert-&gt;current_channels = out-&gt;channels;
 836 
<span class="line-added"> 837   /* keep the input layout */</span>
<span class="line-added"> 838   if (convert-&gt;current_layout == GST_AUDIO_LAYOUT_NON_INTERLEAVED) {</span>
<span class="line-added"> 839     flags |= GST_AUDIO_CHANNEL_MIXER_FLAGS_NON_INTERLEAVED_IN;</span>
<span class="line-added"> 840     flags |= GST_AUDIO_CHANNEL_MIXER_FLAGS_NON_INTERLEAVED_OUT;</span>
<span class="line-added"> 841   }</span>
<span class="line-added"> 842 </span>
 843   if (opt_matrix) {
 844     gfloat **matrix = NULL;
 845 
 846     if (gst_value_array_get_size (opt_matrix))
 847       matrix =
 848           mix_matrix_from_g_value (in-&gt;channels, out-&gt;channels, opt_matrix);
 849 
 850     convert-&gt;mix =
<span class="line-modified"> 851         gst_audio_channel_mixer_new_with_matrix (flags, format, in-&gt;channels,</span>
 852         out-&gt;channels, matrix);
 853   } else {
<span class="line-modified"> 854     flags |=</span>


 855         GST_AUDIO_INFO_IS_UNPOSITIONED (in) ?
 856         GST_AUDIO_CHANNEL_MIXER_FLAGS_UNPOSITIONED_IN : 0;
 857     flags |=
 858         GST_AUDIO_INFO_IS_UNPOSITIONED (out) ?
 859         GST_AUDIO_CHANNEL_MIXER_FLAGS_UNPOSITIONED_OUT : 0;
 860 
 861     convert-&gt;mix =
 862         gst_audio_channel_mixer_new (flags, format, in-&gt;channels, in-&gt;position,
 863         out-&gt;channels, out-&gt;position);
 864   }
 865 
 866   convert-&gt;mix_passthrough =
 867       gst_audio_channel_mixer_is_passthrough (convert-&gt;mix);
 868   GST_INFO (&quot;mix format %s, passthrough %d, in_channels %d, out_channels %d&quot;,
 869       gst_audio_format_to_string (format), convert-&gt;mix_passthrough,
 870       in-&gt;channels, out-&gt;channels);
 871 
 872   if (!convert-&gt;mix_passthrough) {
 873     prev = audio_chain_new (prev, convert);
 874     prev-&gt;allow_ip = FALSE;
</pre>
<hr />
<pre>
 880 
 881 static AudioChain *
 882 chain_resample (GstAudioConverter * convert, AudioChain * prev)
 883 {
 884   GstAudioInfo *in = &amp;convert-&gt;in;
 885   GstAudioInfo *out = &amp;convert-&gt;out;
 886   GstAudioResamplerMethod method;
 887   GstAudioResamplerFlags flags;
 888   GstAudioFormat format = convert-&gt;current_format;
 889   gint channels = convert-&gt;current_channels;
 890   gboolean variable_rate;
 891 
 892   variable_rate = convert-&gt;flags &amp; GST_AUDIO_CONVERTER_FLAG_VARIABLE_RATE;
 893 
 894   if (in-&gt;rate != out-&gt;rate || variable_rate) {
 895     method = GET_OPT_RESAMPLER_METHOD (convert);
 896 
 897     flags = 0;
 898     if (convert-&gt;current_layout == GST_AUDIO_LAYOUT_NON_INTERLEAVED) {
 899       flags |= GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_IN;
<span class="line-added"> 900     }</span>
<span class="line-added"> 901     /* if the resampler is activated, it is optimal to change layout here */</span>
<span class="line-added"> 902     if (out-&gt;layout == GST_AUDIO_LAYOUT_NON_INTERLEAVED) {</span>
 903       flags |= GST_AUDIO_RESAMPLER_FLAG_NON_INTERLEAVED_OUT;
 904     }
<span class="line-added"> 905     convert-&gt;current_layout = out-&gt;layout;</span>
<span class="line-added"> 906 </span>
 907     if (variable_rate)
 908       flags |= GST_AUDIO_RESAMPLER_FLAG_VARIABLE_RATE;
 909 
 910     convert-&gt;resampler =
 911         gst_audio_resampler_new (method, flags, format, channels, in-&gt;rate,
 912         out-&gt;rate, convert-&gt;config);
 913 
 914     prev = audio_chain_new (prev, convert);
 915     prev-&gt;allow_ip = FALSE;
 916     prev-&gt;pass_alloc = FALSE;
 917     audio_chain_set_make_func (prev, do_resample, convert, NULL);
 918   }
 919   return prev;
 920 }
 921 
 922 static AudioChain *
 923 chain_convert_out (GstAudioConverter * convert, AudioChain * prev)
 924 {
 925   gboolean in_int, out_int;
 926   GstAudioInfo *in = &amp;convert-&gt;in;
</pre>
<hr />
<pre>
 979     if (ns &gt; GST_AUDIO_NOISE_SHAPING_ERROR_FEEDBACK &amp;&amp; out-&gt;rate &lt; 32000)
 980       ns = GST_AUDIO_NOISE_SHAPING_ERROR_FEEDBACK;
 981   }
 982   /* we still want to run the quantization step when reducing bits to get
 983    * the rounding correct */
 984   if (out_int &amp;&amp; out_depth &lt; 32
 985       &amp;&amp; convert-&gt;current_format == GST_AUDIO_FORMAT_S32) {
 986     GST_INFO (&quot;quantize to %d bits, dither %d, ns %d&quot;, out_depth, dither, ns);
 987     convert-&gt;quant =
 988         gst_audio_quantize_new (dither, ns, 0, convert-&gt;current_format,
 989         out-&gt;channels, 1U &lt;&lt; (32 - out_depth));
 990 
 991     prev = audio_chain_new (prev, convert);
 992     prev-&gt;allow_ip = TRUE;
 993     prev-&gt;pass_alloc = TRUE;
 994     audio_chain_set_make_func (prev, do_quantize, convert, NULL);
 995   }
 996   return prev;
 997 }
 998 
<span class="line-added"> 999 static AudioChain *</span>
<span class="line-added">1000 chain_change_layout (GstAudioConverter * convert, AudioChain * prev)</span>
<span class="line-added">1001 {</span>
<span class="line-added">1002   GstAudioInfo *out = &amp;convert-&gt;out;</span>
<span class="line-added">1003 </span>
<span class="line-added">1004   if (convert-&gt;current_layout != out-&gt;layout) {</span>
<span class="line-added">1005     convert-&gt;current_layout = out-&gt;layout;</span>
<span class="line-added">1006 </span>
<span class="line-added">1007     /* if there is only 1 channel, layouts are identical */</span>
<span class="line-added">1008     if (convert-&gt;current_channels &gt; 1) {</span>
<span class="line-added">1009       convert-&gt;chlayout_target = convert-&gt;current_layout;</span>
<span class="line-added">1010       convert-&gt;chlayout_format = convert-&gt;current_format;</span>
<span class="line-added">1011       convert-&gt;chlayout_channels = convert-&gt;current_channels;</span>
<span class="line-added">1012 </span>
<span class="line-added">1013       prev = audio_chain_new (prev, convert);</span>
<span class="line-added">1014       prev-&gt;allow_ip = FALSE;</span>
<span class="line-added">1015       prev-&gt;pass_alloc = FALSE;</span>
<span class="line-added">1016       audio_chain_set_make_func (prev, do_change_layout, convert, NULL);</span>
<span class="line-added">1017     }</span>
<span class="line-added">1018   }</span>
<span class="line-added">1019   return prev;</span>
<span class="line-added">1020 }</span>
<span class="line-added">1021 </span>
1022 static AudioChain *
1023 chain_pack (GstAudioConverter * convert, AudioChain * prev)
1024 {
1025   GstAudioInfo *out = &amp;convert-&gt;out;
1026   GstAudioFormat format = convert-&gt;current_format;
1027 
1028   convert-&gt;current_format = out-&gt;finfo-&gt;format;
1029 
1030   convert-&gt;out_default = format == out-&gt;finfo-&gt;format;
1031   GST_INFO (&quot;pack format %s to %s&quot;, gst_audio_format_to_string (format),
1032       gst_audio_format_to_string (out-&gt;finfo-&gt;format));
1033 
1034   return prev;
1035 }
1036 
1037 static void
1038 setup_allocators (GstAudioConverter * convert)
1039 {
1040   AudioChain *chain;
1041   AudioChainAllocFunc alloc_func;
</pre>
<hr />
<pre>
1279     /* and pack if needed */
1280     for (i = 0; i &lt; chain-&gt;blocks; i++)
1281       convert-&gt;out.finfo-&gt;pack_func (convert-&gt;out.finfo, 0, tmp[i], out[i],
1282           produced * chain-&gt;inc);
1283   }
1284   return TRUE;
1285 }
1286 
1287 static gboolean
1288 converter_resample (GstAudioConverter * convert,
1289     GstAudioConverterFlags flags, gpointer in[], gsize in_frames,
1290     gpointer out[], gsize out_frames)
1291 {
1292   gst_audio_resampler_resample (convert-&gt;resampler, in, in_frames, out,
1293       out_frames);
1294 
1295   return TRUE;
1296 }
1297 
1298 #define GST_AUDIO_FORMAT_IS_ENDIAN_CONVERSION(info1, info2) \
<span class="line-modified">1299     ( \</span>
<span class="line-modified">1300       !(((info1)-&gt;flags ^ (info2)-&gt;flags) &amp; (~GST_AUDIO_FORMAT_FLAG_UNPACK)) &amp;&amp; \</span>
<span class="line-modified">1301       (info1)-&gt;endianness != (info2)-&gt;endianness &amp;&amp; \</span>
<span class="line-modified">1302       (info1)-&gt;width == (info2)-&gt;width &amp;&amp; \</span>
<span class="line-modified">1303       (info1)-&gt;depth == (info2)-&gt;depth \</span>
<span class="line-modified">1304     )</span>
1305 
1306 /**
1307  * gst_audio_converter_new:
1308  * @flags: extra #GstAudioConverterFlags
1309  * @in_info: a source #GstAudioInfo
1310  * @out_info: a destination #GstAudioInfo
1311  * @config: (transfer full) (nullable): a #GstStructure with configuration options
1312  *
1313  * Create a new #GstAudioConverter that is able to convert between @in and @out
1314  * audio formats.
1315  *
<span class="line-modified">1316  * @config contains extra configuration options, see #GST_AUDIO_CONVERTER_OPT_*</span>
1317  * parameters for details about the options and values.
1318  *
1319  * Returns: a #GstAudioConverter or %NULL if conversion is not possible.
1320  */
1321 GstAudioConverter *
1322 gst_audio_converter_new (GstAudioConverterFlags flags, GstAudioInfo * in_info,
1323     GstAudioInfo * out_info, GstStructure * config)
1324 {
1325   GstAudioConverter *convert;
1326   AudioChain *prev;
1327   const GValue *opt_matrix = NULL;
1328 
1329   g_return_val_if_fail (in_info != NULL, FALSE);
1330   g_return_val_if_fail (out_info != NULL, FALSE);


1331 
1332   if (config)
1333     opt_matrix =
1334         gst_structure_get_value (config, GST_AUDIO_CONVERTER_OPT_MIX_MATRIX);
1335 
1336   if (opt_matrix
1337       &amp;&amp; !check_mix_matrix (in_info-&gt;channels, out_info-&gt;channels, opt_matrix))
1338     goto invalid_mix_matrix;
1339 
1340   if ((GST_AUDIO_INFO_CHANNELS (in_info) != GST_AUDIO_INFO_CHANNELS (out_info))
1341       &amp;&amp; (GST_AUDIO_INFO_IS_UNPOSITIONED (in_info)
1342           || GST_AUDIO_INFO_IS_UNPOSITIONED (out_info))
1343       &amp;&amp; !opt_matrix)
1344     goto unpositioned;
1345 
1346   convert = g_slice_new0 (GstAudioConverter);
1347 
1348   convert-&gt;flags = flags;
1349   convert-&gt;in = *in_info;
1350   convert-&gt;out = *out_info;
1351 
1352   /* default config */
1353   convert-&gt;config = gst_structure_new_empty (&quot;GstAudioConverter&quot;);
1354   if (config)
1355     gst_audio_converter_update_config (convert, 0, 0, config);
1356 
1357   GST_INFO (&quot;unitsizes: %d -&gt; %d&quot;, in_info-&gt;bpf, out_info-&gt;bpf);
1358 
1359   /* step 1, unpack */
1360   prev = chain_unpack (convert);
1361   /* step 2, optional convert from S32 to F64 for channel mix */
1362   prev = chain_convert_in (convert, prev);
1363   /* step 3, channel mix */
1364   prev = chain_mix (convert, prev);
1365   /* step 4, resample */
1366   prev = chain_resample (convert, prev);
1367   /* step 5, optional convert for quantize */
1368   prev = chain_convert_out (convert, prev);
1369   /* step 6, optional quantize */
1370   prev = chain_quantize (convert, prev);
<span class="line-modified">1371   /* step 7, change layout */</span>
<span class="line-added">1372   prev = chain_change_layout (convert, prev);</span>
<span class="line-added">1373   /* step 8, pack */</span>
1374   convert-&gt;chain_end = chain_pack (convert, prev);
1375 
1376   convert-&gt;convert = converter_generic;
1377   convert-&gt;in_place = FALSE;
<span class="line-added">1378   convert-&gt;passthrough = FALSE;</span>
1379 
1380   /* optimize */
1381   if (convert-&gt;mix_passthrough) {
1382     if (out_info-&gt;finfo-&gt;format == in_info-&gt;finfo-&gt;format) {
1383       if (convert-&gt;resampler == NULL) {
<span class="line-modified">1384         if (out_info-&gt;layout == in_info-&gt;layout) {</span>
<span class="line-modified">1385           GST_INFO (&quot;same formats, same layout, no resampler and &quot;</span>
<span class="line-modified">1386               &quot;passthrough mixing -&gt; passthrough&quot;);</span>
<span class="line-modified">1387           convert-&gt;convert = converter_passthrough;</span>
<span class="line-added">1388           convert-&gt;in_place = TRUE;</span>
<span class="line-added">1389           convert-&gt;passthrough = TRUE;</span>
<span class="line-added">1390         }</span>
1391       } else {
1392         if (is_intermediate_format (in_info-&gt;finfo-&gt;format)) {
1393           GST_INFO (&quot;same formats, and passthrough mixing -&gt; only resampling&quot;);
1394           convert-&gt;convert = converter_resample;
1395         }
1396       }
1397     } else if (GST_AUDIO_FORMAT_IS_ENDIAN_CONVERSION (out_info-&gt;finfo,
1398             in_info-&gt;finfo)) {
<span class="line-modified">1399       if (convert-&gt;resampler == NULL &amp;&amp; out_info-&gt;layout == in_info-&gt;layout) {</span>
1400         GST_INFO (&quot;no resampler, passthrough mixing -&gt; only endian conversion&quot;);
1401         convert-&gt;convert = converter_endian;
1402         convert-&gt;in_place = TRUE;
1403 
<span class="line-modified">1404         switch (GST_AUDIO_INFO_WIDTH (in_info)) {</span>
<span class="line-modified">1405           case 16:</span>
1406             GST_DEBUG (&quot;initializing 16-bit endian conversion&quot;);
1407             convert-&gt;swap_endian = converter_swap_endian_16;
1408             break;
<span class="line-modified">1409           case 24:</span>
1410             GST_DEBUG (&quot;initializing 24-bit endian conversion&quot;);
1411             convert-&gt;swap_endian = converter_swap_endian_24;
1412             break;
<span class="line-modified">1413           case 32:</span>
1414             GST_DEBUG (&quot;initializing 32-bit endian conversion&quot;);
1415             convert-&gt;swap_endian = converter_swap_endian_32;
1416             break;
<span class="line-modified">1417           case 64:</span>
1418             GST_DEBUG (&quot;initializing 64-bit endian conversion&quot;);
1419             convert-&gt;swap_endian = converter_swap_endian_64;
1420             break;
1421           default:
1422             GST_ERROR (&quot;unsupported sample width for endian conversion&quot;);
1423             g_assert_not_reached ();
1424         }
1425       }
1426     }
1427   }
1428 
1429   setup_allocators (convert);
1430 
1431   return convert;
1432 
1433   /* ERRORS */
1434 unpositioned:
1435   {
1436     GST_WARNING (&quot;unpositioned channels&quot;);
1437     return NULL;
</pre>
<hr />
<pre>
1581  *
1582  * Returns: %TRUE is the conversion could be performed.
1583  */
1584 gboolean
1585 gst_audio_converter_samples (GstAudioConverter * convert,
1586     GstAudioConverterFlags flags, gpointer in[], gsize in_frames,
1587     gpointer out[], gsize out_frames)
1588 {
1589   g_return_val_if_fail (convert != NULL, FALSE);
1590   g_return_val_if_fail (out != NULL, FALSE);
1591 
1592   if (in_frames == 0) {
1593     GST_LOG (&quot;skipping empty buffer&quot;);
1594     return TRUE;
1595   }
1596   return convert-&gt;convert (convert, flags, in, in_frames, out, out_frames);
1597 }
1598 
1599 /**
1600  * gst_audio_converter_convert:
<span class="line-added">1601  * @convert: a #GstAudioConverter</span>
1602  * @flags: extra #GstAudioConverterFlags
1603  * @in: (array length=in_size) (element-type guint8): input data
1604  * @in_size: size of @in
1605  * @out: (out) (array length=out_size) (element-type guint8): a pointer where
1606  *  the output data will be written
1607  * @out_size: (out): a pointer where the size of @out will be written
1608  *
1609  * Convenience wrapper around gst_audio_converter_samples(), which will
1610  * perform allocation of the output buffer based on the result from
1611  * gst_audio_converter_get_out_frames().
1612  *
1613  * Returns: %TRUE is the conversion could be performed.
1614  *
1615  * Since: 1.14
1616  */
1617 gboolean
1618 gst_audio_converter_convert (GstAudioConverter * convert,
1619     GstAudioConverterFlags flags, gpointer in, gsize in_size,
1620     gpointer * out, gsize * out_size)
1621 {
</pre>
<hr />
<pre>
1632   *out = g_malloc0 (*out_size);
1633 
1634   return gst_audio_converter_samples (convert, flags, &amp;in, in_frames, out,
1635       out_frames);
1636 }
1637 
1638 /**
1639  * gst_audio_converter_supports_inplace:
1640  * @convert: a #GstAudioConverter
1641  *
1642  * Returns whether the audio converter can perform the conversion in-place.
1643  * The return value would be typically input to gst_base_transform_set_in_place()
1644  *
1645  * Returns: %TRUE when the conversion can be done in place.
1646  */
1647 gboolean
1648 gst_audio_converter_supports_inplace (GstAudioConverter * convert)
1649 {
1650   return convert-&gt;in_place;
1651 }
<span class="line-added">1652 </span>
<span class="line-added">1653 /**</span>
<span class="line-added">1654  * gst_audio_converter_is_passthrough:</span>
<span class="line-added">1655  *</span>
<span class="line-added">1656  * Returns whether the audio converter will operate in passthrough mode.</span>
<span class="line-added">1657  * The return value would be typically input to gst_base_transform_set_passthrough()</span>
<span class="line-added">1658  *</span>
<span class="line-added">1659  * Returns: %TRUE when no conversion will actually occur.</span>
<span class="line-added">1660  *</span>
<span class="line-added">1661  * Since: 1.16</span>
<span class="line-added">1662  */</span>
<span class="line-added">1663 gboolean</span>
<span class="line-added">1664 gst_audio_converter_is_passthrough (GstAudioConverter * convert)</span>
<span class="line-added">1665 {</span>
<span class="line-added">1666   return convert-&gt;passthrough;</span>
<span class="line-added">1667 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="audio-channels.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="audio-converter.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>