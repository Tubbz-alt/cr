<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gdir.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* GLIB - Library of useful routines for C programming
  2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
  3  *
  4  * gdir.c: Simplified wrapper around the DIRENT functions.
  5  *
  6  * Copyright 2001 Hans Breuer
  7  * Copyright 2004 Tor Lillqvist
  8  *
  9  * This library is free software; you can redistribute it and/or
 10  * modify it under the terms of the GNU Lesser General Public
 11  * License as published by the Free Software Foundation; either
 12  * version 2.1 of the License, or (at your option) any later version.
 13  *
 14  * This library is distributed in the hope that it will be useful,
 15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 17  * Lesser General Public License for more details.
 18  *
 19  * You should have received a copy of the GNU Lesser General Public
 20  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 21  */
 22 
 23 #include &quot;config.h&quot;
 24 
 25 #include &lt;errno.h&gt;
 26 #include &lt;string.h&gt;
 27 #include &lt;stdio.h&gt;
 28 #include &lt;sys/stat.h&gt;
 29 
 30 #ifdef HAVE_DIRENT_H
 31 #include &lt;sys/types.h&gt;
 32 #include &lt;dirent.h&gt;
 33 #endif
 34 
 35 #include &quot;gdir.h&quot;
 36 
 37 #include &quot;gconvert.h&quot;
 38 #include &quot;gfileutils.h&quot;
 39 #include &quot;gstrfuncs.h&quot;
 40 #include &quot;gtestutils.h&quot;
 41 #include &quot;glibintl.h&quot;
 42 
 43 #if defined (_MSC_VER) &amp;&amp; !defined (HAVE_DIRENT_H)
<a name="1" id="anc1"></a><span class="line-modified"> 44 #include &quot;../build/win32/dirent/dirent.h&quot;</span>
<span class="line-removed"> 45 #include &quot;../build/win32/dirent/wdirent.c&quot;</span>
 46 #endif
 47 
<a name="2" id="anc2"></a>





 48 #include &quot;glib-private.h&quot; /* g_dir_open_with_errno, g_dir_new_from_dirp */
 49 
 50 /**
 51  * GDir:
 52  *
 53  * An opaque structure representing an opened directory.
 54  */
 55 
 56 struct _GDir
 57 {
 58 #ifdef G_OS_WIN32
 59   _WDIR *wdirp;
 60 #else
 61   DIR *dirp;
 62 #endif
 63 #ifdef G_OS_WIN32
 64   gchar utf8_buf[FILENAME_MAX*4];
 65 #endif
 66 };
 67 
 68 /*&lt; private &gt;
 69  * g_dir_open_with_errno:
 70  * @path: the path to the directory you are interested in.
 71  * @flags: Currently must be set to 0. Reserved for future use.
 72  *
 73  * Opens a directory for reading.
 74  *
 75  * This function is equivalent to g_dir_open() except in the error case,
 76  * errno will be set accordingly.
 77  *
 78  * This is useful if you want to construct your own error message.
 79  *
 80  * Returns: a newly allocated #GDir on success, or %NULL on failure,
 81  *   with errno set accordingly.
 82  *
 83  * Since: 2.38
 84  */
 85 GDir *
 86 g_dir_open_with_errno (const gchar *path,
 87                        guint        flags)
 88 {
 89   GDir dir;
 90 #ifdef G_OS_WIN32
 91   gint saved_errno;
 92   wchar_t *wpath;
 93 #endif
 94 
 95   g_return_val_if_fail (path != NULL, NULL);
 96 
 97 #ifdef G_OS_WIN32
 98   wpath = g_utf8_to_utf16 (path, -1, NULL, NULL, NULL);
 99 
100   g_return_val_if_fail (wpath != NULL, NULL);
101 
102   dir.wdirp = _wopendir (wpath);
103   saved_errno = errno;
104   g_free (wpath);
105   errno = saved_errno;
106 
107   if (dir.wdirp == NULL)
108     return NULL;
109 #else
110   dir.dirp = opendir (path);
111 
112   if (dir.dirp == NULL)
113     return NULL;
114 #endif
115 
116   return g_memdup (&amp;dir, sizeof dir);
117 }
118 
119 /**
120  * g_dir_open:
121  * @path: the path to the directory you are interested in. On Unix
122  *         in the on-disk encoding. On Windows in UTF-8
123  * @flags: Currently must be set to 0. Reserved for future use.
124  * @error: return location for a #GError, or %NULL.
125  *         If non-%NULL, an error will be set if and only if
126  *         g_dir_open() fails.
127  *
128  * Opens a directory for reading. The names of the files in the
129  * directory can then be retrieved using g_dir_read_name().  Note
130  * that the ordering is not defined.
131  *
132  * Returns: a newly allocated #GDir on success, %NULL on failure.
133  *   If non-%NULL, you must free the result with g_dir_close()
134  *   when you are finished with it.
135  **/
136 GDir *
137 g_dir_open (const gchar  *path,
138             guint         flags,
139             GError      **error)
140 {
141   gint saved_errno;
142   GDir *dir;
143 
144   dir = g_dir_open_with_errno (path, flags);
145 
146   if (dir == NULL)
147     {
148       gchar *utf8_path;
149 
150       saved_errno = errno;
151 
152       utf8_path = g_filename_to_utf8 (path, -1, NULL, NULL, NULL);
153 
154       g_set_error (error, G_FILE_ERROR, g_file_error_from_errno (saved_errno),
155                    _(&quot;Error opening directory &#39;%s&#39;: %s&quot;), utf8_path, g_strerror (saved_errno));
156       g_free (utf8_path);
157     }
158 
159   return dir;
160 }
161 
162 /*&lt; private &gt;
163  * g_dir_new_from_dirp:
164  * @dirp: a #DIR* created by opendir() or fdopendir()
165  *
166  * Creates a #GDir object from the DIR object that is created using
167  * opendir() or fdopendir().  The created #GDir assumes ownership of the
168  * passed-in #DIR pointer.
169  *
170  * @dirp must not be %NULL.
171  *
172  * This function never fails.
173  *
174  * Returns: a newly allocated #GDir, which should be closed using
175  *     g_dir_close().
176  *
177  * Since: 2.38
178  **/
179 GDir *
180 g_dir_new_from_dirp (gpointer dirp)
181 {
182 #ifdef G_OS_UNIX
183   GDir *dir;
184 
185   g_return_val_if_fail (dirp != NULL, NULL);
186 
187   dir = g_new (GDir, 1);
188   dir-&gt;dirp = dirp;
189 
190   return dir;
191 #else
192   g_assert_not_reached ();
<a name="3" id="anc3"></a>

193 #endif
194 }
195 
196 /**
197  * g_dir_read_name:
198  * @dir: a #GDir* created by g_dir_open()
199  *
200  * Retrieves the name of another entry in the directory, or %NULL.
201  * The order of entries returned from this function is not defined,
202  * and may vary by file system or other operating-system dependent
203  * factors.
204  *
205  * %NULL may also be returned in case of errors. On Unix, you can
206  * check `errno` to find out if %NULL was returned because of an error.
207  *
208  * On Unix, the &#39;.&#39; and &#39;..&#39; entries are omitted, and the returned
209  * name is in the on-disk encoding.
210  *
211  * On Windows, as is true of all GLib functions which operate on
212  * filenames, the returned name is in UTF-8.
213  *
214  * Returns: (type filename): The entry&#39;s name or %NULL if there are no
215  *   more entries. The return value is owned by GLib and
216  *   must not be modified or freed.
217  **/
218 const gchar *
219 g_dir_read_name (GDir *dir)
220 {
221 #ifdef G_OS_WIN32
222   gchar *utf8_name;
223   struct _wdirent *wentry;
224 #else
225   struct dirent *entry;
226 #endif
227 
228   g_return_val_if_fail (dir != NULL, NULL);
229 
230 #ifdef G_OS_WIN32
231   while (1)
232     {
233       wentry = _wreaddir (dir-&gt;wdirp);
234       while (wentry
<a name="4" id="anc4"></a><span class="line-modified">235          &amp;&amp; (0 == wcscmp (wentry-&gt;d_name, L&quot;.&quot;) ||</span>
<span class="line-modified">236          0 == wcscmp (wentry-&gt;d_name, L&quot;..&quot;)))</span>
<span class="line-modified">237     wentry = _wreaddir (dir-&gt;wdirp);</span>
238 
239       if (wentry == NULL)
<a name="5" id="anc5"></a><span class="line-modified">240     return NULL;</span>
241 
242       utf8_name = g_utf16_to_utf8 (wentry-&gt;d_name, -1, NULL, NULL, NULL);
243 
244       if (utf8_name == NULL)
<a name="6" id="anc6"></a><span class="line-modified">245     continue;       /* Huh, impossible? Skip it anyway */</span>
246 
247       strcpy (dir-&gt;utf8_buf, utf8_name);
248       g_free (utf8_name);
249 
250       return dir-&gt;utf8_buf;
251     }
252 #else
253   entry = readdir (dir-&gt;dirp);
254   while (entry
255          &amp;&amp; (0 == strcmp (entry-&gt;d_name, &quot;.&quot;) ||
256              0 == strcmp (entry-&gt;d_name, &quot;..&quot;)))
257     entry = readdir (dir-&gt;dirp);
258 
259   if (entry)
260     return entry-&gt;d_name;
261   else
262     return NULL;
263 #endif
264 }
265 
266 /**
267  * g_dir_rewind:
268  * @dir: a #GDir* created by g_dir_open()
269  *
270  * Resets the given directory. The next call to g_dir_read_name()
271  * will return the first entry again.
272  **/
273 void
274 g_dir_rewind (GDir *dir)
275 {
276   g_return_if_fail (dir != NULL);
277 
278 #ifdef G_OS_WIN32
279   _wrewinddir (dir-&gt;wdirp);
280 #else
281   rewinddir (dir-&gt;dirp);
282 #endif
283 }
284 
285 /**
286  * g_dir_close:
287  * @dir: a #GDir* created by g_dir_open()
288  *
289  * Closes the directory and deallocates all related resources.
290  **/
291 void
292 g_dir_close (GDir *dir)
293 {
294   g_return_if_fail (dir != NULL);
295 
296 #ifdef G_OS_WIN32
297   _wclosedir (dir-&gt;wdirp);
298 #else
299   closedir (dir-&gt;dirp);
300 #endif
301   g_free (dir);
302 }
303 
304 #ifdef G_OS_WIN32
305 
306 /* Binary compatibility versions. Not for newly compiled code. */
307 
308 _GLIB_EXTERN GDir        *g_dir_open_utf8      (const gchar  *path,
309                                                 guint         flags,
310                                                 GError      **error);
311 _GLIB_EXTERN const gchar *g_dir_read_name_utf8 (GDir         *dir);
312 
313 GDir *
314 g_dir_open_utf8 (const gchar  *path,
315                  guint         flags,
316                  GError      **error)
317 {
318   return g_dir_open (path, flags, error);
319 }
320 
321 const gchar *
322 g_dir_read_name_utf8 (GDir *dir)
323 {
324   return g_dir_read_name (dir);
325 }
326 
327 #endif
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>