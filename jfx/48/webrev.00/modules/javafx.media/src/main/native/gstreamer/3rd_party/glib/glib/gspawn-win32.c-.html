<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn-win32.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* gspawn-win32.c - Process launching on Win32
   2  *
   3  *  Copyright 2000 Red Hat, Inc.
   4  *  Copyright 2003 Tor Lillqvist
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Lesser General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2.1 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Lesser General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Lesser General Public License
  17  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  18  */
  19 
  20 /*
  21  * Implementation details on Win32.
  22  *
  23  * - There is no way to set the no-inherit flag for
  24  *   a &quot;file descriptor&quot; in the MS C runtime. The flag is there,
  25  *   and the dospawn() function uses it, but unfortunately
  26  *   this flag can only be set when opening the file.
  27  * - As there is no fork(), we cannot reliably change directory
  28  *   before starting the child process. (There might be several threads
  29  *   running, and the current directory is common for all threads.)
  30  *
  31  * Thus, we must in many cases use a helper program to handle closing
  32  * of (inherited) file descriptors and changing of directory. The
  33  * helper process is also needed if the standard input, standard
  34  * output, or standard error of the process to be run are supposed to
  35  * be redirected somewhere.
  36  *
  37  * The structure of the source code in this file is a mess, I know.
  38  */
  39 
  40 /* Define this to get some logging all the time */
  41 /* #define G_SPAWN_WIN32_DEBUG */
  42 
  43 #include &quot;config.h&quot;
  44 
  45 #include &quot;glib.h&quot;
  46 #include &quot;glib-private.h&quot;
  47 #include &quot;gprintfint.h&quot;
  48 #include &quot;glibintl.h&quot;
  49 #include &quot;gspawn-private.h&quot;
  50 #include &quot;gthread.h&quot;
  51 
  52 #include &lt;string.h&gt;
  53 #include &lt;stdlib.h&gt;
  54 #include &lt;stdio.h&gt;
  55 
  56 #include &lt;windows.h&gt;
  57 #include &lt;errno.h&gt;
  58 #include &lt;fcntl.h&gt;
  59 #include &lt;io.h&gt;
  60 #include &lt;process.h&gt;
  61 #include &lt;direct.h&gt;
  62 #include &lt;wchar.h&gt;
  63 
  64 #ifndef GSPAWN_HELPER
  65 #ifdef G_SPAWN_WIN32_DEBUG
  66   static int debug = 1;
  67   #define SETUP_DEBUG() /* empty */
  68 #else
  69   static int debug = -1;
  70   #define SETUP_DEBUG()                 \
  71     G_STMT_START                    \
  72       {                         \
  73     if (debug == -1)                \
  74       {                     \
  75         if (getenv (&quot;G_SPAWN_WIN32_DEBUG&quot;) != NULL) \
  76           debug = 1;                \
  77         else                    \
  78           debug = 0;                \
  79       }                     \
  80       }                         \
  81     G_STMT_END
  82 #endif
  83 #endif
  84 
  85 enum
  86 {
  87   CHILD_NO_ERROR,
  88   CHILD_CHDIR_FAILED,
  89   CHILD_SPAWN_FAILED,
  90   CHILD_SPAWN_NOENT,
  91 };
  92 
  93 enum {
  94   ARG_CHILD_ERR_REPORT = 1,
  95   ARG_HELPER_SYNC,
  96   ARG_STDIN,
  97   ARG_STDOUT,
  98   ARG_STDERR,
  99   ARG_WORKING_DIRECTORY,
 100   ARG_CLOSE_DESCRIPTORS,
 101   ARG_USE_PATH,
 102   ARG_WAIT,
 103   ARG_PROGRAM,
 104   ARG_COUNT = ARG_PROGRAM
 105 };
 106 
 107 static int
 108 dup_noninherited (int fd,
 109           int mode)
 110 {
 111   HANDLE filehandle;
 112 
 113   DuplicateHandle (GetCurrentProcess (), (LPHANDLE) _get_osfhandle (fd),
 114            GetCurrentProcess (), &amp;filehandle,
 115            0, FALSE, DUPLICATE_SAME_ACCESS);
 116   close (fd);
 117   return _open_osfhandle ((gintptr) filehandle, mode | _O_NOINHERIT);
 118 }
 119 
 120 #ifndef GSPAWN_HELPER
 121 
 122 #ifdef _WIN64
 123 #define HELPER_PROCESS &quot;gspawn-win64-helper&quot;
 124 #else
 125 #define HELPER_PROCESS &quot;gspawn-win32-helper&quot;
 126 #endif
 127 
 128 static gchar *
 129 protect_argv_string (const gchar *string)
 130 {
 131   const gchar *p = string;
 132   gchar *retval, *q;
 133   gint len = 0;
 134   gboolean need_dblquotes = FALSE;
 135   while (*p)
 136     {
 137       if (*p == &#39; &#39; || *p == &#39;\t&#39;)
 138     need_dblquotes = TRUE;
 139       else if (*p == &#39;&quot;&#39;)
 140     len++;
 141       else if (*p == &#39;\\&#39;)
 142     {
 143       const gchar *pp = p;
 144       while (*pp &amp;&amp; *pp == &#39;\\&#39;)
 145         pp++;
 146       if (*pp == &#39;&quot;&#39;)
 147         len++;
 148     }
 149       len++;
 150       p++;
 151     }
 152 
 153   q = retval = g_malloc (len + need_dblquotes*2 + 1);
 154   p = string;
 155 
 156   if (need_dblquotes)
 157     *q++ = &#39;&quot;&#39;;
 158 
 159   while (*p)
 160     {
 161       if (*p == &#39;&quot;&#39;)
 162     *q++ = &#39;\\&#39;;
 163       else if (*p == &#39;\\&#39;)
 164     {
 165       const gchar *pp = p;
 166       while (*pp &amp;&amp; *pp == &#39;\\&#39;)
 167         pp++;
 168       if (*pp == &#39;&quot;&#39;)
 169         *q++ = &#39;\\&#39;;
 170     }
 171       *q++ = *p;
 172       p++;
 173     }
 174 
 175   if (need_dblquotes)
 176     *q++ = &#39;&quot;&#39;;
 177   *q++ = &#39;\0&#39;;
 178 
 179   return retval;
 180 }
 181 
 182 static gint
 183 protect_argv (gchar  **argv,
 184           gchar ***new_argv)
 185 {
 186   gint i;
 187   gint argc = 0;
 188 
 189   while (argv[argc])
 190     ++argc;
 191   *new_argv = g_new (gchar *, argc+1);
 192 
 193   /* Quote each argv element if necessary, so that it will get
 194    * reconstructed correctly in the C runtime startup code.  Note that
 195    * the unquoting algorithm in the C runtime is really weird, and
 196    * rather different than what Unix shells do. See stdargv.c in the C
 197    * runtime sources (in the Platform SDK, in src/crt).
 198    *
 199    * Note that an new_argv[0] constructed by this function should
 200    * *not* be passed as the filename argument to a spawn* or exec*
 201    * family function. That argument should be the real file name
 202    * without any quoting.
 203    */
 204   for (i = 0; i &lt; argc; i++)
 205     (*new_argv)[i] = protect_argv_string (argv[i]);
 206 
 207   (*new_argv)[argc] = NULL;
 208 
 209   return argc;
 210 }
 211 
 212 G_DEFINE_QUARK (g-exec-error-quark, g_spawn_error)
 213 G_DEFINE_QUARK (g-spawn-exit-error-quark, g_spawn_exit_error)
 214 
 215 gboolean
 216 g_spawn_async (const gchar          *working_directory,
 217             gchar               **argv,
 218             gchar               **envp,
 219             GSpawnFlags           flags,
 220             GSpawnChildSetupFunc  child_setup,
 221             gpointer              user_data,
 222             GPid                 *child_handle,
 223             GError              **error)
 224 {
 225   g_return_val_if_fail (argv != NULL, FALSE);
 226 
 227   return g_spawn_async_with_pipes (working_directory,
 228                     argv, envp,
 229                     flags,
 230                     child_setup,
 231                     user_data,
 232                     child_handle,
 233                     NULL, NULL, NULL,
 234                     error);
 235 }
 236 
 237 /* Avoids a danger in threaded situations (calling close()
 238  * on a file descriptor twice, and another thread has
 239  * re-opened it since the first close)
 240  */
 241 static void
 242 close_and_invalidate (gint *fd)
 243 {
 244   if (*fd &lt; 0)
 245     return;
 246 
 247   close (*fd);
 248   *fd = -1;
 249 }
 250 
 251 typedef enum
 252 {
 253   READ_FAILED = 0, /* FALSE */
 254   READ_OK,
 255   READ_EOF
 256 } ReadResult;
 257 
 258 static ReadResult
 259 read_data (GString     *str,
 260            GIOChannel  *iochannel,
 261            GError     **error)
 262 {
 263   GIOStatus giostatus;
 264   gsize bytes;
 265   gchar buf[4096];
 266 
 267  again:
 268 
 269   giostatus = g_io_channel_read_chars (iochannel, buf, sizeof (buf), &amp;bytes, NULL);
 270 
 271   if (bytes == 0)
 272     return READ_EOF;
 273   else if (bytes &gt; 0)
 274     {
 275       g_string_append_len (str, buf, bytes);
 276       return READ_OK;
 277     }
 278   else if (giostatus == G_IO_STATUS_AGAIN)
 279     goto again;
 280   else if (giostatus == G_IO_STATUS_ERROR)
 281     {
 282       g_set_error_literal (error, G_SPAWN_ERROR, G_SPAWN_ERROR_READ,
 283                            _(&quot;Failed to read data from child process&quot;));
 284 
 285       return READ_FAILED;
 286     }
 287   else
 288     return READ_OK;
 289 }
 290 
 291 static gboolean
 292 make_pipe (gint     p[2],
 293            GError **error)
 294 {
 295   if (_pipe (p, 4096, _O_BINARY) &lt; 0)
 296     {
 297       int errsv = errno;
 298 
 299       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
 300                    _(&quot;Failed to create pipe for communicating with child process (%s)&quot;),
 301                    g_strerror (errsv));
 302       return FALSE;
 303     }
 304   else
 305     return TRUE;
 306 }
 307 
 308 /* The helper process writes a status report back to us, through a
 309  * pipe, consisting of two ints.
 310  */
 311 static gboolean
 312 read_helper_report (int      fd,
 313             gintptr  report[2],
 314             GError **error)
 315 {
 316   gint bytes = 0;
 317 
 318   while (bytes &lt; sizeof(gintptr)*2)
 319     {
 320       gint chunk;
 321       int errsv;
 322 
 323       if (debug)
 324     g_print (&quot;%s:read_helper_report: read %&quot; G_GSIZE_FORMAT &quot;...\n&quot;,
 325          __FILE__,
 326          sizeof(gintptr)*2 - bytes);
 327 
 328       chunk = read (fd, ((gchar*)report) + bytes,
 329             sizeof(gintptr)*2 - bytes);
 330       errsv = errno;
 331 
 332       if (debug)
 333     g_print (&quot;...got %d bytes\n&quot;, chunk);
 334 
 335       if (chunk &lt; 0)
 336         {
 337           /* Some weird shit happened, bail out */
 338           g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
 339                        _(&quot;Failed to read from child pipe (%s)&quot;),
 340                        g_strerror (errsv));
 341 
 342           return FALSE;
 343         }
 344       else if (chunk == 0)
 345     {
 346       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
 347                _(&quot;Failed to read from child pipe (%s)&quot;),
 348                &quot;EOF&quot;);
 349       break; /* EOF */
 350     }
 351       else
 352     bytes += chunk;
 353     }
 354 
 355   if (bytes &lt; sizeof(gintptr)*2)
 356     return FALSE;
 357 
 358   return TRUE;
 359 }
 360 
 361 static void
 362 set_child_error (gintptr      report[2],
 363          const gchar *working_directory,
 364          GError     **error)
 365 {
 366   switch (report[0])
 367     {
 368     case CHILD_CHDIR_FAILED:
 369       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR,
 370            _(&quot;Failed to change to directory &#39;%s&#39; (%s)&quot;),
 371            working_directory,
 372            g_strerror (report[1]));
 373       break;
 374     case CHILD_SPAWN_FAILED:
 375       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
 376            _(&quot;Failed to execute child process (%s)&quot;),
 377            g_strerror (report[1]));
 378       break;
 379     case CHILD_SPAWN_NOENT:
 380       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT,
 381                    _(&quot;Failed to execute child process (%s)&quot;),
 382                    g_strerror (report[1]));
 383       break;
 384     default:
 385       g_assert_not_reached ();
 386     }
 387 }
 388 
 389 static gboolean
 390 utf8_charv_to_wcharv (char     **utf8_charv,
 391               wchar_t ***wcharv,
 392               int       *error_index,
 393               GError   **error)
 394 {
 395   wchar_t **retval = NULL;
 396 
 397   *wcharv = NULL;
 398   if (utf8_charv != NULL)
 399     {
 400       int n = 0, i;
 401 
 402       while (utf8_charv[n])
 403     n++;
 404       retval = g_new (wchar_t *, n + 1);
 405 
 406       for (i = 0; i &lt; n; i++)
 407     {
 408       retval[i] = g_utf8_to_utf16 (utf8_charv[i], -1, NULL, NULL, error);
 409       if (retval[i] == NULL)
 410         {
 411           if (error_index)
 412         *error_index = i;
 413           while (i)
 414         g_free (retval[--i]);
 415           g_free (retval);
 416           return FALSE;
 417         }
 418     }
 419 
 420       retval[n] = NULL;
 421     }
 422   *wcharv = retval;
 423   return TRUE;
 424 }
 425 
 426 static gboolean
 427 do_spawn_directly (gint                 *exit_status,
 428            gboolean      do_return_handle,
 429                    GSpawnFlags           flags,
 430                    gchar               **argv,
 431                    char                **envp,
 432                    char                **protected_argv,
 433                    GPid                 *child_handle,
 434                    GError              **error)
 435 {
 436   const int mode = (exit_status == NULL) ? P_NOWAIT : P_WAIT;
 437   char **new_argv;
 438   gintptr rc = -1;
 439   int errsv;
 440   GError *conv_error = NULL;
 441   gint conv_error_index;
 442   wchar_t *wargv0, **wargv, **wenvp;
 443 
 444   new_argv = (flags &amp; G_SPAWN_FILE_AND_ARGV_ZERO) ? protected_argv + 1 : protected_argv;
 445 
 446   wargv0 = g_utf8_to_utf16 (argv[0], -1, NULL, NULL, &amp;conv_error);
 447   if (wargv0 == NULL)
 448     {
 449       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
 450            _(&quot;Invalid program name: %s&quot;),
 451            conv_error-&gt;message);
 452       g_error_free (conv_error);
 453 
 454       return FALSE;
 455     }
 456 
 457   if (!utf8_charv_to_wcharv (new_argv, &amp;wargv, &amp;conv_error_index, &amp;conv_error))
 458     {
 459       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
 460            _(&quot;Invalid string in argument vector at %d: %s&quot;),
 461            conv_error_index, conv_error-&gt;message);
 462       g_error_free (conv_error);
 463       g_free (wargv0);
 464 
 465       return FALSE;
 466     }
 467 
 468   if (!utf8_charv_to_wcharv (envp, &amp;wenvp, NULL, &amp;conv_error))
 469     {
 470       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
 471            _(&quot;Invalid string in environment: %s&quot;),
 472            conv_error-&gt;message);
 473       g_error_free (conv_error);
 474       g_free (wargv0);
 475       g_strfreev ((gchar **) wargv);
 476 
 477       return FALSE;
 478     }
 479 
 480   if (flags &amp; G_SPAWN_SEARCH_PATH)
 481     if (wenvp != NULL)
 482       rc = _wspawnvpe (mode, wargv0, (const wchar_t **) wargv, (const wchar_t **) wenvp);
 483     else
 484       rc = _wspawnvp (mode, wargv0, (const wchar_t **) wargv);
 485   else
 486     if (wenvp != NULL)
 487       rc = _wspawnve (mode, wargv0, (const wchar_t **) wargv, (const wchar_t **) wenvp);
 488     else
 489       rc = _wspawnv (mode, wargv0, (const wchar_t **) wargv);
 490 
 491   errsv = errno;
 492 
 493   g_free (wargv0);
 494   g_strfreev ((gchar **) wargv);
 495   g_strfreev ((gchar **) wenvp);
 496 
 497   if (rc == -1 &amp;&amp; errsv != 0)
 498     {
 499       g_set_error (error, G_SPAWN_ERROR, _g_spawn_exec_err_to_g_error (errsv),
 500                    _(&quot;Failed to execute child process (%s)&quot;),
 501            g_strerror (errsv));
 502       return FALSE;
 503     }
 504 
 505   if (exit_status == NULL)
 506     {
 507       if (child_handle &amp;&amp; do_return_handle)
 508     *child_handle = (GPid) rc;
 509       else
 510     {
 511       CloseHandle ((HANDLE) rc);
 512       if (child_handle)
 513         *child_handle = 0;
 514     }
 515     }
 516   else
 517     *exit_status = rc;
 518 
 519   return TRUE;
 520 }
 521 
 522 static gboolean
 523 do_spawn_with_fds (gint                 *exit_status,
 524            gboolean        do_return_handle,
 525                    const gchar          *working_directory,
 526                    gchar               **argv,
 527                    char                **envp,
 528                    GSpawnFlags           flags,
 529                    GSpawnChildSetupFunc  child_setup,
 530                    GPid                 *child_handle,
 531            gint                  stdin_fd,
 532            gint                  stdout_fd,
 533            gint                  stderr_fd,
 534            gint       *err_report,
 535                    GError              **error)
 536 {
 537   char **protected_argv;
 538   char args[ARG_COUNT][10];
 539   char **new_argv;
 540   int i;
 541   gintptr rc = -1;
 542   int errsv;
 543   int argc;
 544   int child_err_report_pipe[2] = { -1, -1 };
 545   int helper_sync_pipe[2] = { -1, -1 };
 546   gintptr helper_report[2];
 547   static gboolean warned_about_child_setup = FALSE;
 548   GError *conv_error = NULL;
 549   gint conv_error_index;
 550   gchar *helper_process;
 551   wchar_t *whelper, **wargv, **wenvp;
 552   gchar *glib_dll_directory;
 553 
 554   if (child_setup &amp;&amp; !warned_about_child_setup)
 555     {
 556       warned_about_child_setup = TRUE;
 557       g_warning (&quot;passing a child setup function to the g_spawn functions is pointless on Windows and it is ignored&quot;);
 558     }
 559 
 560   argc = protect_argv (argv, &amp;protected_argv);
 561 
 562   if (stdin_fd == -1 &amp;&amp; stdout_fd == -1 &amp;&amp; stderr_fd == -1 &amp;&amp;
 563       (flags &amp; G_SPAWN_CHILD_INHERITS_STDIN) &amp;&amp;
 564       !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL) &amp;&amp;
 565       !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL) &amp;&amp;
 566       (working_directory == NULL || !*working_directory) &amp;&amp;
 567       (flags &amp; G_SPAWN_LEAVE_DESCRIPTORS_OPEN))
 568     {
 569       /* We can do without the helper process */
 570       gboolean retval =
 571     do_spawn_directly (exit_status, do_return_handle, flags,
 572                argv, envp, protected_argv,
 573                child_handle, error);
 574       g_strfreev (protected_argv);
 575       return retval;
 576     }
 577 
 578   if (!make_pipe (child_err_report_pipe, error))
 579     goto cleanup_and_fail;
 580 
 581   if (!make_pipe (helper_sync_pipe, error))
 582     goto cleanup_and_fail;
 583 
 584   new_argv = g_new (char *, argc + 1 + ARG_COUNT);
 585   if (GetConsoleWindow () != NULL)
 586     helper_process = HELPER_PROCESS &quot;-console.exe&quot;;
 587   else
 588     helper_process = HELPER_PROCESS &quot;.exe&quot;;
 589 
 590   glib_dll_directory = _glib_get_dll_directory ();
 591   if (glib_dll_directory != NULL)
 592     {
 593       helper_process = g_build_filename (glib_dll_directory, helper_process, NULL);
 594       g_free (glib_dll_directory);
 595     }
 596   else
 597     helper_process = g_strdup (helper_process);
 598 
 599   new_argv[0] = protect_argv_string (helper_process);
 600 
 601   _g_sprintf (args[ARG_CHILD_ERR_REPORT], &quot;%d&quot;, child_err_report_pipe[1]);
 602   new_argv[ARG_CHILD_ERR_REPORT] = args[ARG_CHILD_ERR_REPORT];
 603 
 604   /* Make the read end of the child error report pipe
 605    * noninherited. Otherwise it will needlessly be inherited by the
 606    * helper process, and the started actual user process. As such that
 607    * shouldn&#39;t harm, but it is unnecessary.
 608    */
 609   child_err_report_pipe[0] = dup_noninherited (child_err_report_pipe[0], _O_RDONLY);
 610 
 611   if (flags &amp; G_SPAWN_FILE_AND_ARGV_ZERO)
 612     {
 613       /* Overload ARG_CHILD_ERR_REPORT to also encode the
 614        * G_SPAWN_FILE_AND_ARGV_ZERO functionality.
 615        */
 616       strcat (args[ARG_CHILD_ERR_REPORT], &quot;#&quot;);
 617     }
 618 
 619   _g_sprintf (args[ARG_HELPER_SYNC], &quot;%d&quot;, helper_sync_pipe[0]);
 620   new_argv[ARG_HELPER_SYNC] = args[ARG_HELPER_SYNC];
 621 
 622   /* Make the write end of the sync pipe noninherited. Otherwise the
 623    * helper process will inherit it, and thus if this process happens
 624    * to crash before writing the sync byte to the pipe, the helper
 625    * process won&#39;t read but won&#39;t get any EOF either, as it has the
 626    * write end open itself.
 627    */
 628   helper_sync_pipe[1] = dup_noninherited (helper_sync_pipe[1], _O_WRONLY);
 629 
 630   if (stdin_fd != -1)
 631     {
 632       _g_sprintf (args[ARG_STDIN], &quot;%d&quot;, stdin_fd);
 633       new_argv[ARG_STDIN] = args[ARG_STDIN];
 634     }
 635   else if (flags &amp; G_SPAWN_CHILD_INHERITS_STDIN)
 636     {
 637       /* Let stdin be alone */
 638       new_argv[ARG_STDIN] = &quot;-&quot;;
 639     }
 640   else
 641     {
 642       /* Keep process from blocking on a read of stdin */
 643       new_argv[ARG_STDIN] = &quot;z&quot;;
 644     }
 645 
 646   if (stdout_fd != -1)
 647     {
 648       _g_sprintf (args[ARG_STDOUT], &quot;%d&quot;, stdout_fd);
 649       new_argv[ARG_STDOUT] = args[ARG_STDOUT];
 650     }
 651   else if (flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL)
 652     {
 653       new_argv[ARG_STDOUT] = &quot;z&quot;;
 654     }
 655   else
 656     {
 657       new_argv[ARG_STDOUT] = &quot;-&quot;;
 658     }
 659 
 660   if (stdout_fd != -1)
 661     {
 662       _g_sprintf (args[ARG_STDERR], &quot;%d&quot;, stderr_fd);
 663       new_argv[ARG_STDERR] = args[ARG_STDERR];
 664     }
 665   else if (flags &amp; G_SPAWN_STDERR_TO_DEV_NULL)
 666     {
 667       new_argv[ARG_STDERR] = &quot;z&quot;;
 668     }
 669   else
 670     {
 671       new_argv[ARG_STDERR] = &quot;-&quot;;
 672     }
 673 
 674   if (working_directory &amp;&amp; *working_directory)
 675     new_argv[ARG_WORKING_DIRECTORY] = protect_argv_string (working_directory);
 676   else
 677     new_argv[ARG_WORKING_DIRECTORY] = g_strdup (&quot;-&quot;);
 678 
 679   if (!(flags &amp; G_SPAWN_LEAVE_DESCRIPTORS_OPEN))
 680     new_argv[ARG_CLOSE_DESCRIPTORS] = &quot;y&quot;;
 681   else
 682     new_argv[ARG_CLOSE_DESCRIPTORS] = &quot;-&quot;;
 683 
 684   if (flags &amp; G_SPAWN_SEARCH_PATH)
 685     new_argv[ARG_USE_PATH] = &quot;y&quot;;
 686   else
 687     new_argv[ARG_USE_PATH] = &quot;-&quot;;
 688 
 689   if (exit_status == NULL)
 690     new_argv[ARG_WAIT] = &quot;-&quot;;
 691   else
 692     new_argv[ARG_WAIT] = &quot;w&quot;;
 693 
 694   for (i = 0; i &lt;= argc; i++)
 695     new_argv[ARG_PROGRAM + i] = protected_argv[i];
 696 
 697   SETUP_DEBUG();
 698 
 699   if (debug)
 700     {
 701       g_print (&quot;calling %s with argv:\n&quot;, helper_process);
 702       for (i = 0; i &lt; argc + 1 + ARG_COUNT; i++)
 703     g_print (&quot;argv[%d]: %s\n&quot;, i, (new_argv[i] ? new_argv[i] : &quot;NULL&quot;));
 704     }
 705 
 706   if (!utf8_charv_to_wcharv (new_argv, &amp;wargv, &amp;conv_error_index, &amp;conv_error))
 707     {
 708       if (conv_error_index == ARG_WORKING_DIRECTORY)
 709     g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR,
 710              _(&quot;Invalid working directory: %s&quot;),
 711              conv_error-&gt;message);
 712       else
 713     g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
 714              _(&quot;Invalid string in argument vector at %d: %s&quot;),
 715              conv_error_index - ARG_PROGRAM, conv_error-&gt;message);
 716       g_error_free (conv_error);
 717       g_strfreev (protected_argv);
 718       g_free (new_argv[0]);
 719       g_free (new_argv[ARG_WORKING_DIRECTORY]);
 720       g_free (new_argv);
 721       g_free (helper_process);
 722 
 723       goto cleanup_and_fail;
 724     }
 725 
 726   if (!utf8_charv_to_wcharv (envp, &amp;wenvp, NULL, &amp;conv_error))
 727     {
 728       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
 729            _(&quot;Invalid string in environment: %s&quot;),
 730            conv_error-&gt;message);
 731       g_error_free (conv_error);
 732       g_strfreev (protected_argv);
 733       g_free (new_argv[0]);
 734       g_free (new_argv[ARG_WORKING_DIRECTORY]);
 735       g_free (new_argv);
 736       g_free (helper_process);
 737       g_strfreev ((gchar **) wargv);
 738 
 739       goto cleanup_and_fail;
 740     }
 741 
 742   whelper = g_utf8_to_utf16 (helper_process, -1, NULL, NULL, NULL);
 743   g_free (helper_process);
 744 
 745   if (wenvp != NULL)
 746     rc = _wspawnvpe (P_NOWAIT, whelper, (const wchar_t **) wargv, (const wchar_t **) wenvp);
 747   else
 748     rc = _wspawnvp (P_NOWAIT, whelper, (const wchar_t **) wargv);
 749 
 750   errsv = errno;
 751 
 752   g_free (whelper);
 753   g_strfreev ((gchar **) wargv);
 754   g_strfreev ((gchar **) wenvp);
 755 
 756   /* Close the other process&#39;s ends of the pipes in this process,
 757    * otherwise the reader will never get EOF.
 758    */
 759   close_and_invalidate (&amp;child_err_report_pipe[1]);
 760   close_and_invalidate (&amp;helper_sync_pipe[0]);
 761 
 762   g_strfreev (protected_argv);
 763 
 764   g_free (new_argv[0]);
 765   g_free (new_argv[ARG_WORKING_DIRECTORY]);
 766   g_free (new_argv);
 767 
 768   /* Check if gspawn-win32-helper couldn&#39;t be run */
 769   if (rc == -1 &amp;&amp; errsv != 0)
 770     {
 771       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
 772                    _(&quot;Failed to execute helper program (%s)&quot;),
 773            g_strerror (errsv));
 774       goto cleanup_and_fail;
 775     }
 776 
 777   if (exit_status != NULL)
 778     {
 779       /* Synchronous case. Pass helper&#39;s report pipe back to caller,
 780        * which takes care of reading it after the grandchild has
 781        * finished.
 782        */
 783       g_assert (err_report != NULL);
 784       *err_report = child_err_report_pipe[0];
 785       write (helper_sync_pipe[1], &quot; &quot;, 1);
 786       close_and_invalidate (&amp;helper_sync_pipe[1]);
 787     }
 788   else
 789     {
 790       /* Asynchronous case. We read the helper&#39;s report right away. */
 791       if (!read_helper_report (child_err_report_pipe[0], helper_report, error))
 792     goto cleanup_and_fail;
 793 
 794       close_and_invalidate (&amp;child_err_report_pipe[0]);
 795 
 796       switch (helper_report[0])
 797     {
 798     case CHILD_NO_ERROR:
 799       if (child_handle &amp;&amp; do_return_handle)
 800         {
 801           /* rc is our HANDLE for gspawn-win32-helper. It has
 802            * told us the HANDLE of its child. Duplicate that into
 803            * a HANDLE valid in this process.
 804            */
 805           if (!DuplicateHandle ((HANDLE) rc, (HANDLE) helper_report[1],
 806                     GetCurrentProcess (), (LPHANDLE) child_handle,
 807                     0, TRUE, DUPLICATE_SAME_ACCESS))
 808         {
 809           char *emsg = g_win32_error_message (GetLastError ());
 810           g_print(&quot;%s\n&quot;, emsg);
 811           *child_handle = 0;
 812         }
 813         }
 814       else if (child_handle)
 815         *child_handle = 0;
 816       write (helper_sync_pipe[1], &quot; &quot;, 1);
 817       close_and_invalidate (&amp;helper_sync_pipe[1]);
 818       break;
 819 
 820     default:
 821       write (helper_sync_pipe[1], &quot; &quot;, 1);
 822       close_and_invalidate (&amp;helper_sync_pipe[1]);
 823       set_child_error (helper_report, working_directory, error);
 824       goto cleanup_and_fail;
 825     }
 826     }
 827 
 828   /* Success against all odds! return the information */
 829 
 830   if (rc != -1)
 831     CloseHandle ((HANDLE) rc);
 832 
 833   return TRUE;
 834 
 835  cleanup_and_fail:
 836 
 837   if (rc != -1)
 838     CloseHandle ((HANDLE) rc);
 839   if (child_err_report_pipe[0] != -1)
 840     close (child_err_report_pipe[0]);
 841   if (child_err_report_pipe[1] != -1)
 842     close (child_err_report_pipe[1]);
 843   if (helper_sync_pipe[0] != -1)
 844     close (helper_sync_pipe[0]);
 845   if (helper_sync_pipe[1] != -1)
 846     close (helper_sync_pipe[1]);
 847 
 848   return FALSE;
 849 }
 850 
 851 static gboolean
 852 do_spawn_with_pipes (gint                 *exit_status,
 853              gboolean          do_return_handle,
 854              const gchar          *working_directory,
 855              gchar               **argv,
 856              char                **envp,
 857              GSpawnFlags           flags,
 858              GSpawnChildSetupFunc  child_setup,
 859              GPid                 *child_handle,
 860              gint                 *standard_input,
 861              gint                 *standard_output,
 862              gint                 *standard_error,
 863              gint         *err_report,
 864              GError              **error)
 865 {
 866   int stdin_pipe[2] = { -1, -1 };
 867   int stdout_pipe[2] = { -1, -1 };
 868   int stderr_pipe[2] = { -1, -1 };
 869 
 870   if (standard_input &amp;&amp; !make_pipe (stdin_pipe, error))
 871     goto cleanup_and_fail;
 872 
 873   if (standard_output &amp;&amp; !make_pipe (stdout_pipe, error))
 874     goto cleanup_and_fail;
 875 
 876   if (standard_error &amp;&amp; !make_pipe (stderr_pipe, error))
 877     goto cleanup_and_fail;
 878 
 879   if (!do_spawn_with_fds (exit_status,
 880               do_return_handle,
 881               working_directory,
 882               argv,
 883               envp,
 884               flags,
 885               child_setup,
 886               child_handle,
 887               stdin_pipe[0],
 888               stdout_pipe[1],
 889               stderr_pipe[1],
 890               err_report,
 891               error))
 892     goto cleanup_and_fail;
 893 
 894   /* Close the other process&#39;s ends of the pipes in this process,
 895    * otherwise the reader will never get EOF.
 896    */
 897   close_and_invalidate (&amp;stdin_pipe[0]);
 898   close_and_invalidate (&amp;stdout_pipe[1]);
 899   close_and_invalidate (&amp;stderr_pipe[1]);
 900 
 901   if (standard_input)
 902     *standard_input = stdin_pipe[1];
 903   if (standard_output)
 904     *standard_output = stdout_pipe[0];
 905   if (standard_error)
 906     *standard_error = stderr_pipe[0];
 907 
 908   return TRUE;
 909 
 910  cleanup_and_fail:
 911 
 912   if (stdin_pipe[0] != -1)
 913     close (stdin_pipe[0]);
 914   if (stdin_pipe[1] != -1)
 915     close (stdin_pipe[1]);
 916   if (stdout_pipe[0] != -1)
 917     close (stdout_pipe[0]);
 918   if (stdout_pipe[1] != -1)
 919     close (stdout_pipe[1]);
 920   if (stderr_pipe[0] != -1)
 921     close (stderr_pipe[0]);
 922   if (stderr_pipe[1] != -1)
 923     close (stderr_pipe[1]);
 924 
 925   return FALSE;
 926 }
 927 
 928 gboolean
 929 g_spawn_sync (const gchar          *working_directory,
 930            gchar               **argv,
 931            gchar               **envp,
 932            GSpawnFlags           flags,
 933            GSpawnChildSetupFunc  child_setup,
 934            gpointer              user_data,
 935            gchar               **standard_output,
 936            gchar               **standard_error,
 937            gint                 *exit_status,
 938            GError              **error)
 939 {
 940   gint outpipe = -1;
 941   gint errpipe = -1;
 942   gint reportpipe = -1;
 943   GIOChannel *outchannel = NULL;
 944   GIOChannel *errchannel = NULL;
 945   GPollFD outfd, errfd;
 946   GPollFD fds[2];
 947   gint nfds;
 948   gint outindex = -1;
 949   gint errindex = -1;
 950   gint ret;
 951   GString *outstr = NULL;
 952   GString *errstr = NULL;
 953   gboolean failed;
 954   gint status;
 955 
 956   g_return_val_if_fail (argv != NULL, FALSE);
 957   g_return_val_if_fail (!(flags &amp; G_SPAWN_DO_NOT_REAP_CHILD), FALSE);
 958   g_return_val_if_fail (standard_output == NULL ||
 959                         !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
 960   g_return_val_if_fail (standard_error == NULL ||
 961                         !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL), FALSE);
 962 
 963   /* Just to ensure segfaults if callers try to use
 964    * these when an error is reported.
 965    */
 966   if (standard_output)
 967     *standard_output = NULL;
 968 
 969   if (standard_error)
 970     *standard_error = NULL;
 971 
 972   if (!do_spawn_with_pipes (&amp;status,
 973                 FALSE,
 974                 working_directory,
 975                 argv,
 976                 envp,
 977                 flags,
 978                 child_setup,
 979                 NULL,
 980                 NULL,
 981                 standard_output ? &amp;outpipe : NULL,
 982                 standard_error ? &amp;errpipe : NULL,
 983                 &amp;reportpipe,
 984                 error))
 985     return FALSE;
 986 
 987   /* Read data from child. */
 988 
 989   failed = FALSE;
 990 
 991   if (outpipe &gt;= 0)
 992     {
 993       outstr = g_string_new (NULL);
 994       outchannel = g_io_channel_win32_new_fd (outpipe);
 995       g_io_channel_set_encoding (outchannel, NULL, NULL);
 996       g_io_channel_set_buffered (outchannel, FALSE);
 997       g_io_channel_win32_make_pollfd (outchannel,
 998                       G_IO_IN | G_IO_ERR | G_IO_HUP,
 999                       &amp;outfd);
1000       if (debug)
1001     g_print (&quot;outfd=%p\n&quot;, (HANDLE) outfd.fd);
1002     }
1003 
1004   if (errpipe &gt;= 0)
1005     {
1006       errstr = g_string_new (NULL);
1007       errchannel = g_io_channel_win32_new_fd (errpipe);
1008       g_io_channel_set_encoding (errchannel, NULL, NULL);
1009       g_io_channel_set_buffered (errchannel, FALSE);
1010       g_io_channel_win32_make_pollfd (errchannel,
1011                       G_IO_IN | G_IO_ERR | G_IO_HUP,
1012                       &amp;errfd);
1013       if (debug)
1014     g_print (&quot;errfd=%p\n&quot;, (HANDLE) errfd.fd);
1015     }
1016 
1017   /* Read data until we get EOF on all pipes. */
1018   while (!failed &amp;&amp; (outpipe &gt;= 0 || errpipe &gt;= 0))
1019     {
1020       nfds = 0;
1021       if (outpipe &gt;= 0)
1022     {
1023       fds[nfds] = outfd;
1024       outindex = nfds;
1025       nfds++;
1026     }
1027       if (errpipe &gt;= 0)
1028     {
1029       fds[nfds] = errfd;
1030       errindex = nfds;
1031       nfds++;
1032     }
1033 
1034       if (debug)
1035     g_print (&quot;g_spawn_sync: calling g_io_channel_win32_poll, nfds=%d\n&quot;,
1036          nfds);
1037 
1038       ret = g_io_channel_win32_poll (fds, nfds, -1);
1039 
1040       if (ret &lt; 0)
1041         {
1042           failed = TRUE;
1043 
1044           g_set_error_literal (error, G_SPAWN_ERROR, G_SPAWN_ERROR_READ,
1045                                _(&quot;Unexpected error in g_io_channel_win32_poll() reading data from a child process&quot;));
1046 
1047           break;
1048         }
1049 
1050       if (outpipe &gt;= 0 &amp;&amp; (fds[outindex].revents &amp; G_IO_IN))
1051         {
1052           switch (read_data (outstr, outchannel, error))
1053             {
1054             case READ_FAILED:
1055           if (debug)
1056         g_print (&quot;g_spawn_sync: outchannel: READ_FAILED\n&quot;);
1057               failed = TRUE;
1058               break;
1059             case READ_EOF:
1060           if (debug)
1061         g_print (&quot;g_spawn_sync: outchannel: READ_EOF\n&quot;);
1062               g_io_channel_unref (outchannel);
1063           outchannel = NULL;
1064               close_and_invalidate (&amp;outpipe);
1065               break;
1066             default:
1067           if (debug)
1068         g_print (&quot;g_spawn_sync: outchannel: OK\n&quot;);
1069               break;
1070             }
1071 
1072           if (failed)
1073             break;
1074         }
1075 
1076       if (errpipe &gt;= 0 &amp;&amp; (fds[errindex].revents &amp; G_IO_IN))
1077         {
1078           switch (read_data (errstr, errchannel, error))
1079             {
1080             case READ_FAILED:
1081           if (debug)
1082         g_print (&quot;g_spawn_sync: errchannel: READ_FAILED\n&quot;);
1083               failed = TRUE;
1084               break;
1085             case READ_EOF:
1086           if (debug)
1087         g_print (&quot;g_spawn_sync: errchannel: READ_EOF\n&quot;);
1088           g_io_channel_unref (errchannel);
1089           errchannel = NULL;
1090               close_and_invalidate (&amp;errpipe);
1091               break;
1092             default:
1093           if (debug)
1094         g_print (&quot;g_spawn_sync: errchannel: OK\n&quot;);
1095               break;
1096             }
1097 
1098           if (failed)
1099             break;
1100         }
1101     }
1102 
1103   if (reportpipe == -1)
1104     {
1105       /* No helper process, exit status of actual spawned process
1106        * already available.
1107        */
1108       if (exit_status)
1109         *exit_status = status;
1110     }
1111   else
1112     {
1113       /* Helper process was involved. Read its report now after the
1114        * grandchild has finished.
1115        */
1116       gintptr helper_report[2];
1117 
1118       if (!read_helper_report (reportpipe, helper_report, error))
1119     failed = TRUE;
1120       else
1121     {
1122       switch (helper_report[0])
1123         {
1124         case CHILD_NO_ERROR:
1125           if (exit_status)
1126         *exit_status = helper_report[1];
1127           break;
1128         default:
1129           set_child_error (helper_report, working_directory, error);
1130           failed = TRUE;
1131           break;
1132         }
1133     }
1134       close_and_invalidate (&amp;reportpipe);
1135     }
1136 
1137 
1138   /* These should only be open still if we had an error.  */
1139 
1140   if (outchannel != NULL)
1141     g_io_channel_unref (outchannel);
1142   if (errchannel != NULL)
1143     g_io_channel_unref (errchannel);
1144   if (outpipe &gt;= 0)
1145     close_and_invalidate (&amp;outpipe);
1146   if (errpipe &gt;= 0)
1147     close_and_invalidate (&amp;errpipe);
1148 
1149   if (failed)
1150     {
1151       if (outstr)
1152         g_string_free (outstr, TRUE);
1153       if (errstr)
1154         g_string_free (errstr, TRUE);
1155 
1156       return FALSE;
1157     }
1158   else
1159     {
1160       if (standard_output)
1161         *standard_output = g_string_free (outstr, FALSE);
1162 
1163       if (standard_error)
1164         *standard_error = g_string_free (errstr, FALSE);
1165 
1166       return TRUE;
1167     }
1168 }
1169 
1170 gboolean
1171 g_spawn_async_with_pipes (const gchar          *working_directory,
1172                    gchar               **argv,
1173                    gchar               **envp,
1174                    GSpawnFlags           flags,
1175                    GSpawnChildSetupFunc  child_setup,
1176                    gpointer              user_data,
1177                    GPid                 *child_handle,
1178                    gint                 *standard_input,
1179                    gint                 *standard_output,
1180                    gint                 *standard_error,
1181                    GError              **error)
1182 {
1183   g_return_val_if_fail (argv != NULL, FALSE);
1184   g_return_val_if_fail (standard_output == NULL ||
1185                         !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
1186   g_return_val_if_fail (standard_error == NULL ||
1187                         !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL), FALSE);
1188   /* can&#39;t inherit stdin if we have an input pipe. */
1189   g_return_val_if_fail (standard_input == NULL ||
1190                         !(flags &amp; G_SPAWN_CHILD_INHERITS_STDIN), FALSE);
1191 
1192   return do_spawn_with_pipes (NULL,
1193                   (flags &amp; G_SPAWN_DO_NOT_REAP_CHILD),
1194                   working_directory,
1195                   argv,
1196                   envp,
1197                   flags,
1198                   child_setup,
1199                   child_handle,
1200                   standard_input,
1201                   standard_output,
1202                   standard_error,
1203                   NULL,
1204                   error);
1205 }
1206 
1207 gboolean
1208 g_spawn_async_with_fds (const gchar          *working_directory,
1209                         gchar               **argv,
1210                         gchar               **envp,
1211                         GSpawnFlags           flags,
1212                         GSpawnChildSetupFunc  child_setup,
1213                         gpointer              user_data,
1214                         GPid                 *child_handle,
1215                         gint                  stdin_fd,
1216                         gint                  stdout_fd,
1217                         gint                  stderr_fd,
1218                         GError              **error)
1219 {
1220   g_return_val_if_fail (argv != NULL, FALSE);
1221   g_return_val_if_fail (stdin_fd == -1 ||
1222                         !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
1223   g_return_val_if_fail (stderr_fd == -1 ||
1224                         !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL), FALSE);
1225   /* can&#39;t inherit stdin if we have an input pipe. */
1226   g_return_val_if_fail (stdin_fd == -1 ||
1227                         !(flags &amp; G_SPAWN_CHILD_INHERITS_STDIN), FALSE);
1228 
1229   return do_spawn_with_fds (NULL,
1230                 (flags &amp; G_SPAWN_DO_NOT_REAP_CHILD),
1231                 working_directory,
1232                 argv,
1233                 envp,
1234                 flags,
1235                 child_setup,
1236                 child_handle,
1237                 stdin_fd,
1238                 stdout_fd,
1239                 stderr_fd,
1240                 NULL,
1241                 error);
1242 }
1243 
1244 gboolean
1245 g_spawn_command_line_sync (const gchar  *command_line,
1246                 gchar       **standard_output,
1247                 gchar       **standard_error,
1248                 gint         *exit_status,
1249                 GError      **error)
1250 {
1251   gboolean retval;
1252   gchar **argv = 0;
1253 
1254   g_return_val_if_fail (command_line != NULL, FALSE);
1255 
1256   if (!g_shell_parse_argv (command_line,
1257                            NULL, &amp;argv,
1258                            error))
1259     return FALSE;
1260 
1261   retval = g_spawn_sync (NULL,
1262                   argv,
1263                   NULL,
1264                   G_SPAWN_SEARCH_PATH,
1265                   NULL,
1266                   NULL,
1267                   standard_output,
1268                   standard_error,
1269                   exit_status,
1270                   error);
1271   g_strfreev (argv);
1272 
1273   return retval;
1274 }
1275 
1276 gboolean
1277 g_spawn_command_line_async (const gchar *command_line,
1278                  GError     **error)
1279 {
1280   gboolean retval;
1281   gchar **argv = 0;
1282 
1283   g_return_val_if_fail (command_line != NULL, FALSE);
1284 
1285   if (!g_shell_parse_argv (command_line,
1286                            NULL, &amp;argv,
1287                            error))
1288     return FALSE;
1289 
1290   retval = g_spawn_async (NULL,
1291                    argv,
1292                    NULL,
1293                    G_SPAWN_SEARCH_PATH,
1294                    NULL,
1295                    NULL,
1296                    NULL,
1297                    error);
1298   g_strfreev (argv);
1299 
1300   return retval;
1301 }
1302 
1303 void
1304 g_spawn_close_pid (GPid pid)
1305 {
1306     CloseHandle (pid);
1307 }
1308 
1309 gboolean
1310 g_spawn_check_exit_status (gint      exit_status,
1311                GError  **error)
1312 {
1313   gboolean ret = FALSE;
1314 
1315   if (exit_status != 0)
1316     {
1317       g_set_error (error, G_SPAWN_EXIT_ERROR, exit_status,
1318            _(&quot;Child process exited with code %ld&quot;),
1319            (long) exit_status);
1320       goto out;
1321     }
1322 
1323   ret = TRUE;
1324  out:
1325   return ret;
1326 }
1327 
1328 #ifndef GSTREAMER_LITE
1329 #ifdef G_OS_WIN32
1330 
1331 /* Binary compatibility versions. Not for newly compiled code. */
1332 
1333 _GLIB_EXTERN gboolean g_spawn_async_utf8              (const gchar           *working_directory,
1334                                                        gchar                **argv,
1335                                                        gchar                **envp,
1336                                                        GSpawnFlags            flags,
1337                                                        GSpawnChildSetupFunc   child_setup,
1338                                                        gpointer               user_data,
1339                                                        GPid                  *child_pid,
1340                                                        GError               **error);
1341 _GLIB_EXTERN gboolean g_spawn_async_with_pipes_utf8   (const gchar           *working_directory,
1342                                                        gchar                **argv,
1343                                                        gchar                **envp,
1344                                                        GSpawnFlags            flags,
1345                                                        GSpawnChildSetupFunc   child_setup,
1346                                                        gpointer               user_data,
1347                                                        GPid                  *child_pid,
1348                                                        gint                  *standard_input,
1349                                                        gint                  *standard_output,
1350                                                        gint                  *standard_error,
1351                                                        GError               **error);
1352 _GLIB_EXTERN gboolean g_spawn_sync_utf8               (const gchar           *working_directory,
1353                                                        gchar                **argv,
1354                                                        gchar                **envp,
1355                                                        GSpawnFlags            flags,
1356                                                        GSpawnChildSetupFunc   child_setup,
1357                                                        gpointer               user_data,
1358                                                        gchar                **standard_output,
1359                                                        gchar                **standard_error,
1360                                                        gint                  *exit_status,
1361                                                        GError               **error);
1362 _GLIB_EXTERN gboolean g_spawn_command_line_sync_utf8  (const gchar           *command_line,
1363                                                        gchar                **standard_output,
1364                                                        gchar                **standard_error,
1365                                                        gint                  *exit_status,
1366                                                        GError               **error);
1367 _GLIB_EXTERN gboolean g_spawn_command_line_async_utf8 (const gchar           *command_line,
1368                                                        GError               **error);
1369 
1370 gboolean
1371 g_spawn_async_utf8 (const gchar          *working_directory,
1372                           gchar               **argv,
1373                           gchar               **envp,
1374                           GSpawnFlags           flags,
1375                           GSpawnChildSetupFunc  child_setup,
1376                           gpointer              user_data,
1377                           GPid                 *child_handle,
1378                           GError              **error)
1379 {
1380   return g_spawn_async (working_directory,
1381                         argv,
1382                         envp,
1383                         flags,
1384                         child_setup,
1385                         user_data,
1386                       child_handle,
1387                       error);
1388 }
1389 
1390 gboolean
1391 g_spawn_async_with_pipes_utf8 (const gchar          *working_directory,
1392            gchar               **argv,
1393            gchar               **envp,
1394            GSpawnFlags           flags,
1395            GSpawnChildSetupFunc  child_setup,
1396            gpointer              user_data,
1397            GPid                 *child_handle,
1398                                gint                 *standard_input,
1399                                gint                 *standard_output,
1400                                gint                 *standard_error,
1401            GError              **error)
1402 {
1403   return g_spawn_async_with_pipes (working_directory,
1404                                    argv,
1405                                    envp,
1406                    flags,
1407                    child_setup,
1408                    user_data,
1409                    child_handle,
1410                                    standard_input,
1411                                    standard_output,
1412                                    standard_error,
1413                    error);
1414 }
1415 
1416 gboolean
1417 g_spawn_sync_utf8 (const gchar          *working_directory,
1418           gchar               **argv,
1419           gchar               **envp,
1420           GSpawnFlags           flags,
1421           GSpawnChildSetupFunc  child_setup,
1422           gpointer              user_data,
1423           gchar               **standard_output,
1424           gchar               **standard_error,
1425           gint                 *exit_status,
1426           GError              **error)
1427 {
1428   return g_spawn_sync (working_directory,
1429                        argv,
1430                        envp,
1431                        flags,
1432                        child_setup,
1433                        user_data,
1434                        standard_output,
1435                        standard_error,
1436                        exit_status,
1437                   error);
1438 }
1439 
1440 gboolean
1441 g_spawn_command_line_sync_utf8 (const gchar  *command_line,
1442                gchar       **standard_output,
1443                gchar       **standard_error,
1444                gint         *exit_status,
1445                GError      **error)
1446 {
1447   return g_spawn_command_line_sync (command_line,
1448                          standard_output,
1449                          standard_error,
1450                          exit_status,
1451                          error);
1452 }
1453 
1454 gboolean
1455 g_spawn_command_line_async_utf8 (const gchar *command_line,
1456                 GError     **error)
1457 {
1458   return g_spawn_command_line_async (command_line, error);
1459 }
1460 
1461 #endif /* G_OS_WIN32 */
1462 #endif // GSTREAMER_LITE
1463 
1464 #endif /* !GSPAWN_HELPER */
    </pre>
  </body>
</html>