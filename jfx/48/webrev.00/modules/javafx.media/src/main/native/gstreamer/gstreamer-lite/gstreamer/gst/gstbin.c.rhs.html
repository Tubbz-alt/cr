<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstbin.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  *
   3  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   4  *                    2004 Wim Taymans &lt;wim.taymans@gmail.com&gt;
   5  *
   6  * gstbin.c: GstBin container object and support code
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public
  19  * License along with this library; if not, write to the
  20  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  *
  23  * MT safe.
  24  */
  25 
  26 /**
  27  * SECTION:gstbin
  28  * @title: GstBin
  29  * @short_description: Base class and element that can contain other elements
  30  *
  31  * #GstBin is an element that can contain other #GstElement, allowing them to be
  32  * managed as a group.
  33  * Pads from the child elements can be ghosted to the bin, see #GstGhostPad.
  34  * This makes the bin look like any other elements and enables creation of
  35  * higher-level abstraction elements.
  36  *
  37  * A new #GstBin is created with gst_bin_new(). Use a #GstPipeline instead if you
  38  * want to create a toplevel bin because a normal bin doesn&#39;t have a bus or
  39  * handle clock distribution of its own.
  40  *
  41  * After the bin has been created you will typically add elements to it with
  42  * gst_bin_add(). You can remove elements with gst_bin_remove().
  43  *
  44  * An element can be retrieved from a bin with gst_bin_get_by_name(), using the
  45  * elements name. gst_bin_get_by_name_recurse_up() is mainly used for internal
  46  * purposes and will query the parent bins when the element is not found in the
  47  * current bin.
  48  *
  49  * An iterator of elements in a bin can be retrieved with
  50  * gst_bin_iterate_elements(). Various other iterators exist to retrieve the
  51  * elements in a bin.
  52  *
  53  * gst_object_unref() is used to drop your reference to the bin.
  54  *
  55  * The #GstBin::element-added signal is fired whenever a new element is added to
  56  * the bin. Likewise the #GstBin::element-removed signal is fired whenever an
  57  * element is removed from the bin.
  58  *
  59  * ## Notes
  60  *
  61  * A #GstBin internally intercepts every #GstMessage posted by its children and
  62  * implements the following default behaviour for each of them:
  63  *
  64  * * GST_MESSAGE_EOS: This message is only posted by sinks in the PLAYING
  65  * state. If all sinks posted the EOS message, this bin will post and EOS
  66  * message upwards.
  67  *
  68  * * GST_MESSAGE_SEGMENT_START: Just collected and never forwarded upwards.
  69  * The messages are used to decide when all elements have completed playback
  70  * of their segment.
  71  *
  72  * * GST_MESSAGE_SEGMENT_DONE: Is posted by #GstBin when all elements that posted
  73  * a SEGMENT_START have posted a SEGMENT_DONE.
  74  *
  75  * * GST_MESSAGE_DURATION_CHANGED: Is posted by an element that detected a change
  76  * in the stream duration. The default bin behaviour is to clear any
  77  * cached duration values so that the next duration query will perform
  78  * a full duration recalculation. The duration change is posted to the
  79  * application so that it can refetch the new duration with a duration
  80  * query. Note that these messages can be posted before the bin is
  81  * prerolled, in which case the duration query might fail.
  82  *
  83  * * GST_MESSAGE_CLOCK_LOST: This message is posted by an element when it
  84  * can no longer provide a clock. The default bin behaviour is to
  85  * check if the lost clock was the one provided by the bin. If so and
  86  * the bin is currently in the PLAYING state, the message is forwarded to
  87  * the bin parent.
  88  * This message is also generated when a clock provider is removed from
  89  * the bin. If this message is received by the application, it should
  90  * PAUSE the pipeline and set it back to PLAYING to force a new clock
  91  * distribution.
  92  *
  93  * * GST_MESSAGE_CLOCK_PROVIDE: This message is generated when an element
  94  * can provide a clock. This mostly happens when a new clock
  95  * provider is added to the bin. The default behaviour of the bin is to
  96  * mark the currently selected clock as dirty, which will perform a clock
  97  * recalculation the next time the bin is asked to provide a clock.
  98  * This message is never sent tot the application but is forwarded to
  99  * the parent of the bin.
 100  *
 101  * * OTHERS: posted upwards.
 102  *
 103  * A #GstBin implements the following default behaviour for answering to a
 104  * #GstQuery:
 105  *
 106  * * GST_QUERY_DURATION:If the query has been asked before with the same format
 107  * and the bin is a toplevel bin (ie. has no parent),
 108  * use the cached previous value. If no previous value was cached, the
 109  * query is sent to all sink elements in the bin and the MAXIMUM of all
 110  * values is returned. If the bin is a toplevel bin the value is cached.
 111  * If no sinks are available in the bin, the query fails.
 112  *
 113  * * GST_QUERY_POSITION:The query is sent to all sink elements in the bin and the
 114  * MAXIMUM of all values is returned. If no sinks are available in the bin,
 115  * the query fails.
 116  *
 117  * * OTHERS:the query is forwarded to all sink elements, the result
 118  * of the first sink that answers the query successfully is returned. If no
 119  * sink is in the bin, the query fails.
 120  *
 121  * A #GstBin will by default forward any event sent to it to all sink
 122  * (#GST_EVENT_TYPE_DOWNSTREAM) or source (#GST_EVENT_TYPE_UPSTREAM) elements
 123  * depending on the event type.
 124  * If all the elements return %TRUE, the bin will also return %TRUE, else %FALSE
 125  * is returned. If no elements of the required type are in the bin, the event
 126  * handler will return %TRUE.
 127  *
 128  */
 129 
 130 #include &quot;gst_private.h&quot;
 131 
 132 #include &quot;gstevent.h&quot;
 133 #include &quot;gstbin.h&quot;
 134 #include &quot;gstinfo.h&quot;
 135 #include &quot;gsterror.h&quot;
 136 
 137 #include &quot;gstutils.h&quot;
 138 #include &quot;gstchildproxy.h&quot;
 139 
 140 GST_DEBUG_CATEGORY_STATIC (bin_debug);
 141 #define GST_CAT_DEFAULT bin_debug
 142 
 143 /* a bin is toplevel if it has no parent or when it is configured to behave like
 144  * a toplevel bin */
 145 #define BIN_IS_TOPLEVEL(bin) ((GST_OBJECT_PARENT (bin) == NULL) || bin-&gt;priv-&gt;asynchandling)
 146 
<a name="1" id="anc1"></a>


 147 struct _GstBinPrivate
 148 {
 149   gboolean asynchandling;
 150   /* if we get an ASYNC_DONE message from ourselves, this means that the
 151    * subclass will simulate ASYNC behaviour without having ASYNC children. When
 152    * such an ASYNC_DONE message is posted while we are doing a state change, we
 153    * have to process the message after finishing the state change even when no
 154    * child returned GST_STATE_CHANGE_ASYNC. */
 155   gboolean pending_async_done;
 156 
 157   guint32 structure_cookie;
 158 
 159 #if 0
 160   /* cached index */
 161   GstIndex *index;
 162 #endif
 163 
 164   /* forward messages from our children */
 165   gboolean message_forward;
 166 
 167   gboolean posted_eos;
 168   gboolean posted_playing;
 169   GstElementFlags suppressed_flags;
 170 };
 171 
 172 typedef struct
 173 {
 174   guint32 cookie;
 175   GstState pending;
 176 } BinContinueData;
 177 
 178 static void gst_bin_dispose (GObject * object);
 179 
 180 static void gst_bin_set_property (GObject * object, guint prop_id,
 181     const GValue * value, GParamSpec * pspec);
 182 static void gst_bin_get_property (GObject * object, guint prop_id,
 183     GValue * value, GParamSpec * pspec);
 184 
 185 static GstStateChangeReturn gst_bin_change_state_func (GstElement * element,
 186     GstStateChange transition);
 187 static gboolean gst_bin_post_message (GstElement * element, GstMessage * msg);
 188 static GstStateChangeReturn gst_bin_get_state_func (GstElement * element,
 189     GstState * state, GstState * pending, GstClockTime timeout);
 190 static void bin_handle_async_done (GstBin * bin, GstStateChangeReturn ret,
 191     gboolean flag_pending, GstClockTime running_time);
 192 static void bin_handle_async_start (GstBin * bin);
 193 static void bin_push_state_continue (GstBin * bin, BinContinueData * data);
 194 static void bin_do_eos (GstBin * bin);
 195 
 196 static gboolean gst_bin_add_func (GstBin * bin, GstElement * element);
 197 static gboolean gst_bin_remove_func (GstBin * bin, GstElement * element);
 198 static void gst_bin_deep_element_added_func (GstBin * bin, GstBin * sub_bin,
 199     GstElement * element);
 200 static void gst_bin_deep_element_removed_func (GstBin * bin, GstBin * sub_bin,
 201     GstElement * element);
 202 static void gst_bin_update_context (GstBin * bin, GstContext * context);
 203 static void gst_bin_update_context_unlocked (GstBin * bin,
 204     GstContext * context);
 205 
 206 #if 0
 207 static void gst_bin_set_index_func (GstElement * element, GstIndex * index);
 208 static GstIndex *gst_bin_get_index_func (GstElement * element);
 209 #endif
 210 
 211 static GstClock *gst_bin_provide_clock_func (GstElement * element);
 212 static gboolean gst_bin_set_clock_func (GstElement * element, GstClock * clock);
 213 
 214 static void gst_bin_handle_message_func (GstBin * bin, GstMessage * message);
 215 static gboolean gst_bin_send_event (GstElement * element, GstEvent * event);
 216 static GstBusSyncReply bin_bus_handler (GstBus * bus,
 217     GstMessage * message, GstBin * bin);
 218 static gboolean gst_bin_query (GstElement * element, GstQuery * query);
 219 static void gst_bin_set_context (GstElement * element, GstContext * context);
 220 
 221 static gboolean gst_bin_do_latency_func (GstBin * bin);
 222 
 223 static void bin_remove_messages (GstBin * bin, GstObject * src,
 224     GstMessageType types);
 225 static void gst_bin_continue_func (GstBin * bin, BinContinueData * data);
 226 static gint bin_element_is_sink (GstElement * child, GstBin * bin);
 227 static gint bin_element_is_src (GstElement * child, GstBin * bin);
 228 
 229 static GstIterator *gst_bin_sort_iterator_new (GstBin * bin);
 230 
 231 /* Bin signals and properties */
 232 enum
 233 {
 234   ELEMENT_ADDED,
 235   ELEMENT_REMOVED,
 236   DO_LATENCY,
 237   DEEP_ELEMENT_ADDED,
 238   DEEP_ELEMENT_REMOVED,
 239   LAST_SIGNAL
 240 };
 241 
 242 #define DEFAULT_ASYNC_HANDLING  FALSE
 243 #define DEFAULT_MESSAGE_FORWARD FALSE
 244 
 245 enum
 246 {
 247   PROP_0,
 248   PROP_ASYNC_HANDLING,
 249   PROP_MESSAGE_FORWARD,
 250   PROP_LAST
 251 };
 252 
 253 static void gst_bin_child_proxy_init (gpointer g_iface, gpointer iface_data);
 254 
 255 static guint gst_bin_signals[LAST_SIGNAL] = { 0 };
 256 
 257 #define _do_init \
 258 { \
 259   static const GInterfaceInfo iface_info = { \
 260     gst_bin_child_proxy_init, \
 261     NULL, \
 262     NULL}; \
 263   \
 264   g_type_add_interface_static (g_define_type_id, GST_TYPE_CHILD_PROXY, &amp;iface_info); \
 265   \
 266   GST_DEBUG_CATEGORY_INIT (bin_debug, &quot;bin&quot;, GST_DEBUG_BOLD, \
 267       &quot;debugging info for the &#39;bin&#39; container element&quot;); \
 268   \
 269 }
 270 
 271 #define gst_bin_parent_class parent_class
<a name="2" id="anc2"></a><span class="line-modified"> 272 G_DEFINE_TYPE_WITH_CODE (GstBin, gst_bin, GST_TYPE_ELEMENT,</span>
<span class="line-added"> 273     G_ADD_PRIVATE (GstBin)</span>
<span class="line-added"> 274     _do_init);</span>
 275 
 276 static GObject *
 277 gst_bin_child_proxy_get_child_by_index (GstChildProxy * child_proxy,
 278     guint index)
 279 {
 280   GstObject *res;
 281   GstBin *bin;
 282 
 283   bin = GST_BIN_CAST (child_proxy);
 284 
 285   GST_OBJECT_LOCK (bin);
 286   if ((res = g_list_nth_data (bin-&gt;children, index)))
 287     gst_object_ref (res);
 288   GST_OBJECT_UNLOCK (bin);
 289 
 290   return (GObject *) res;
 291 }
 292 
 293 static guint
 294 gst_bin_child_proxy_get_children_count (GstChildProxy * child_proxy)
 295 {
 296   guint num;
 297   GstBin *bin;
 298 
 299   bin = GST_BIN_CAST (child_proxy);
 300 
 301   GST_OBJECT_LOCK (bin);
 302   num = bin-&gt;numchildren;
 303   GST_OBJECT_UNLOCK (bin);
 304 
 305   return num;
 306 }
 307 
 308 static void
 309 gst_bin_child_proxy_init (gpointer g_iface, gpointer iface_data)
 310 {
 311   GstChildProxyInterface *iface = g_iface;
 312 
 313   iface-&gt;get_children_count = gst_bin_child_proxy_get_children_count;
 314   iface-&gt;get_child_by_index = gst_bin_child_proxy_get_child_by_index;
 315 }
 316 
 317 static gboolean
 318 _gst_boolean_accumulator (GSignalInvocationHint * ihint,
 319     GValue * return_accu, const GValue * handler_return, gpointer dummy)
 320 {
 321   gboolean myboolean;
 322 
 323   myboolean = g_value_get_boolean (handler_return);
 324   if (!(ihint-&gt;run_type &amp; G_SIGNAL_RUN_CLEANUP))
 325     g_value_set_boolean (return_accu, myboolean);
 326 
 327   GST_DEBUG (&quot;invocation %d, %d&quot;, ihint-&gt;run_type, myboolean);
 328 
 329   /* stop emission */
 330   return FALSE;
 331 }
 332 
 333 static void
 334 gst_bin_class_init (GstBinClass * klass)
 335 {
 336   GObjectClass *gobject_class;
 337   GstElementClass *gstelement_class;
 338 
 339   gobject_class = (GObjectClass *) klass;
 340   gstelement_class = (GstElementClass *) klass;
 341 
<a name="3" id="anc3"></a>

 342   gobject_class-&gt;set_property = gst_bin_set_property;
 343   gobject_class-&gt;get_property = gst_bin_get_property;
 344 
 345   /**
 346    * GstBin:async-handling:
 347    *
 348    * If set to %TRUE, the bin will handle asynchronous state changes.
 349    * This should be used only if the bin subclass is modifying the state
 350    * of its children on its own.
 351    */
 352   g_object_class_install_property (gobject_class, PROP_ASYNC_HANDLING,
 353       g_param_spec_boolean (&quot;async-handling&quot;, &quot;Async Handling&quot;,
 354           &quot;The bin will handle Asynchronous state changes&quot;,
 355           DEFAULT_ASYNC_HANDLING, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 356 
 357   /**
 358    * GstBin::element-added:
 359    * @bin: the #GstBin
 360    * @element: the #GstElement that was added to the bin
 361    *
 362    * Will be emitted after the element was added to the bin.
 363    */
 364   gst_bin_signals[ELEMENT_ADDED] =
 365       g_signal_new (&quot;element-added&quot;, G_TYPE_FROM_CLASS (klass),
 366       G_SIGNAL_RUN_FIRST, G_STRUCT_OFFSET (GstBinClass, element_added), NULL,
 367       NULL, g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_ELEMENT);
 368   /**
 369    * GstBin::element-removed:
 370    * @bin: the #GstBin
 371    * @element: the #GstElement that was removed from the bin
 372    *
 373    * Will be emitted after the element was removed from the bin.
 374    */
 375   gst_bin_signals[ELEMENT_REMOVED] =
 376       g_signal_new (&quot;element-removed&quot;, G_TYPE_FROM_CLASS (klass),
 377       G_SIGNAL_RUN_FIRST, G_STRUCT_OFFSET (GstBinClass, element_removed), NULL,
 378       NULL, g_cclosure_marshal_generic, G_TYPE_NONE, 1, GST_TYPE_ELEMENT);
 379   /**
 380    * GstBin::deep-element-added:
 381    * @bin: the #GstBin
 382    * @sub_bin: the #GstBin the element was added to
 383    * @element: the #GstElement that was added to @sub_bin
 384    *
 385    * Will be emitted after the element was added to sub_bin.
 386    *
 387    * Since: 1.10
 388    */
 389   gst_bin_signals[DEEP_ELEMENT_ADDED] =
 390       g_signal_new (&quot;deep-element-added&quot;, G_TYPE_FROM_CLASS (klass),
 391       G_SIGNAL_RUN_FIRST, G_STRUCT_OFFSET (GstBinClass, deep_element_added),
 392       NULL, NULL, g_cclosure_marshal_generic, G_TYPE_NONE, 2, GST_TYPE_BIN,
 393       GST_TYPE_ELEMENT);
 394   /**
 395    * GstBin::deep-element-removed:
 396    * @bin: the #GstBin
 397    * @sub_bin: the #GstBin the element was removed from
 398    * @element: the #GstElement that was removed from @sub_bin
 399    *
 400    * Will be emitted after the element was removed from sub_bin.
 401    *
 402    * Since: 1.10
 403    */
 404   gst_bin_signals[DEEP_ELEMENT_REMOVED] =
 405       g_signal_new (&quot;deep-element-removed&quot;, G_TYPE_FROM_CLASS (klass),
 406       G_SIGNAL_RUN_FIRST, G_STRUCT_OFFSET (GstBinClass, deep_element_removed),
 407       NULL, NULL, g_cclosure_marshal_generic, G_TYPE_NONE, 2, GST_TYPE_BIN,
 408       GST_TYPE_ELEMENT);
 409   /**
 410    * GstBin::do-latency:
 411    * @bin: the #GstBin
 412    *
 413    * Will be emitted when the bin needs to perform latency calculations. This
 414    * signal is only emitted for toplevel bins or when async-handling is
 415    * enabled.
 416    *
 417    * Only one signal handler is invoked. If no signals are connected, the
 418    * default handler is invoked, which will query and distribute the lowest
 419    * possible latency to all sinks.
 420    *
 421    * Connect to this signal if the default latency calculations are not
 422    * sufficient, like when you need different latencies for different sinks in
 423    * the same pipeline.
 424    */
 425   gst_bin_signals[DO_LATENCY] =
 426       g_signal_new (&quot;do-latency&quot;, G_TYPE_FROM_CLASS (klass),
 427       G_SIGNAL_RUN_LAST, G_STRUCT_OFFSET (GstBinClass, do_latency),
 428       _gst_boolean_accumulator, NULL, g_cclosure_marshal_generic,
 429       G_TYPE_BOOLEAN, 0, G_TYPE_NONE);
 430 
 431   /**
 432    * GstBin:message-forward:
 433    *
 434    * Forward all children messages, even those that would normally be filtered by
 435    * the bin. This can be interesting when one wants to be notified of the EOS
 436    * state of individual elements, for example.
 437    *
 438    * The messages are converted to an ELEMENT message with the bin as the
 439    * source. The structure of the message is named &#39;GstBinForwarded&#39; and contains
 440    * a field named &#39;message&#39; of type GST_TYPE_MESSAGE that contains the original
 441    * forwarded message.
 442    */
 443   g_object_class_install_property (gobject_class, PROP_MESSAGE_FORWARD,
 444       g_param_spec_boolean (&quot;message-forward&quot;, &quot;Message Forward&quot;,
 445           &quot;Forwards all children messages&quot;,
 446           DEFAULT_MESSAGE_FORWARD, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 447 
 448   gobject_class-&gt;dispose = gst_bin_dispose;
 449 
 450   gst_element_class_set_static_metadata (gstelement_class, &quot;Generic bin&quot;,
 451       &quot;Generic/Bin&quot;,
 452       &quot;Simple container object&quot;,
 453       &quot;Erik Walthinsen &lt;omega@cse.ogi.edu&gt;,&quot;
 454       &quot;Wim Taymans &lt;wim.taymans@gmail.com&gt;&quot;);
 455 
 456   gstelement_class-&gt;change_state =
 457       GST_DEBUG_FUNCPTR (gst_bin_change_state_func);
 458   gstelement_class-&gt;post_message = GST_DEBUG_FUNCPTR (gst_bin_post_message);
 459   gstelement_class-&gt;get_state = GST_DEBUG_FUNCPTR (gst_bin_get_state_func);
 460 #if 0
 461   gstelement_class-&gt;get_index = GST_DEBUG_FUNCPTR (gst_bin_get_index_func);
 462   gstelement_class-&gt;set_index = GST_DEBUG_FUNCPTR (gst_bin_set_index_func);
 463 #endif
 464   gstelement_class-&gt;provide_clock =
 465       GST_DEBUG_FUNCPTR (gst_bin_provide_clock_func);
 466   gstelement_class-&gt;set_clock = GST_DEBUG_FUNCPTR (gst_bin_set_clock_func);
 467 
 468   gstelement_class-&gt;send_event = GST_DEBUG_FUNCPTR (gst_bin_send_event);
 469   gstelement_class-&gt;query = GST_DEBUG_FUNCPTR (gst_bin_query);
 470   gstelement_class-&gt;set_context = GST_DEBUG_FUNCPTR (gst_bin_set_context);
 471 
 472   klass-&gt;add_element = GST_DEBUG_FUNCPTR (gst_bin_add_func);
 473   klass-&gt;remove_element = GST_DEBUG_FUNCPTR (gst_bin_remove_func);
 474   klass-&gt;handle_message = GST_DEBUG_FUNCPTR (gst_bin_handle_message_func);
 475 
 476   klass-&gt;deep_element_added = gst_bin_deep_element_added_func;
 477   klass-&gt;deep_element_removed = gst_bin_deep_element_removed_func;
 478 
 479   klass-&gt;do_latency = GST_DEBUG_FUNCPTR (gst_bin_do_latency_func);
<a name="4" id="anc4"></a><span class="line-modified"> 480 }</span>
 481 
 482 static void
 483 gst_bin_init (GstBin * bin)
 484 {
 485   GstBus *bus;
 486 
 487   bin-&gt;numchildren = 0;
 488   bin-&gt;children = NULL;
 489   bin-&gt;children_cookie = 0;
 490   bin-&gt;messages = NULL;
 491   bin-&gt;provided_clock = NULL;
 492   bin-&gt;clock_dirty = FALSE;
 493 
 494   /* Set up a bus for listening to child elements */
 495   bus = g_object_new (GST_TYPE_BUS, &quot;enable-async&quot;, FALSE, NULL);
 496   gst_object_ref_sink (bus);
 497   bin-&gt;child_bus = bus;
 498   GST_DEBUG_OBJECT (bin, &quot;using bus %&quot; GST_PTR_FORMAT &quot; to listen to children&quot;,
 499       bus);
 500   gst_bus_set_sync_handler (bus, (GstBusSyncHandler) bin_bus_handler, bin,
 501       NULL);
 502 
<a name="5" id="anc5"></a><span class="line-modified"> 503   bin-&gt;priv = gst_bin_get_instance_private (bin);</span>
 504   bin-&gt;priv-&gt;asynchandling = DEFAULT_ASYNC_HANDLING;
 505   bin-&gt;priv-&gt;structure_cookie = 0;
 506   bin-&gt;priv-&gt;message_forward = DEFAULT_MESSAGE_FORWARD;
 507 }
 508 
 509 static void
 510 gst_bin_dispose (GObject * object)
 511 {
 512   GstBin *bin = GST_BIN_CAST (object);
 513   GstBus **child_bus_p = &amp;bin-&gt;child_bus;
 514   GstClock **provided_clock_p = &amp;bin-&gt;provided_clock;
 515   GstElement **clock_provider_p = &amp;bin-&gt;clock_provider;
 516 
 517   GST_CAT_DEBUG_OBJECT (GST_CAT_REFCOUNTING, object, &quot;%p dispose&quot;, object);
 518 
 519   GST_OBJECT_LOCK (object);
 520   gst_object_replace ((GstObject **) child_bus_p, NULL);
 521   gst_object_replace ((GstObject **) provided_clock_p, NULL);
 522   gst_object_replace ((GstObject **) clock_provider_p, NULL);
 523   bin_remove_messages (bin, NULL, GST_MESSAGE_ANY);
 524   GST_OBJECT_UNLOCK (object);
 525 
 526   while (bin-&gt;children) {
 527     gst_bin_remove (bin, GST_ELEMENT_CAST (bin-&gt;children-&gt;data));
 528   }
 529   if (G_UNLIKELY (bin-&gt;children != NULL)) {
 530     g_critical (&quot;could not remove elements from bin &#39;%s&#39;&quot;,
 531         GST_STR_NULL (GST_OBJECT_NAME (object)));
 532   }
 533 
 534   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
 535 }
 536 
 537 /**
 538  * gst_bin_new:
 539  * @name: (allow-none): the name of the new bin
 540  *
 541  * Creates a new bin with the given name.
 542  *
 543  * Returns: (transfer floating): a new #GstBin
 544  */
 545 GstElement *
 546 gst_bin_new (const gchar * name)
 547 {
 548   return gst_element_factory_make (&quot;bin&quot;, name);
 549 }
 550 
 551 static void
 552 gst_bin_set_property (GObject * object, guint prop_id,
 553     const GValue * value, GParamSpec * pspec)
 554 {
 555   GstBin *gstbin;
 556 
 557   gstbin = GST_BIN_CAST (object);
 558 
 559   switch (prop_id) {
 560     case PROP_ASYNC_HANDLING:
 561       GST_OBJECT_LOCK (gstbin);
 562       gstbin-&gt;priv-&gt;asynchandling = g_value_get_boolean (value);
 563       GST_OBJECT_UNLOCK (gstbin);
 564       break;
 565     case PROP_MESSAGE_FORWARD:
 566       GST_OBJECT_LOCK (gstbin);
 567       gstbin-&gt;priv-&gt;message_forward = g_value_get_boolean (value);
 568       GST_OBJECT_UNLOCK (gstbin);
 569       break;
 570     default:
 571       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 572       break;
 573   }
 574 }
 575 
 576 static void
 577 gst_bin_get_property (GObject * object, guint prop_id,
 578     GValue * value, GParamSpec * pspec)
 579 {
 580   GstBin *gstbin;
 581 
 582   gstbin = GST_BIN_CAST (object);
 583 
 584   switch (prop_id) {
 585     case PROP_ASYNC_HANDLING:
 586       GST_OBJECT_LOCK (gstbin);
 587       g_value_set_boolean (value, gstbin-&gt;priv-&gt;asynchandling);
 588       GST_OBJECT_UNLOCK (gstbin);
 589       break;
 590     case PROP_MESSAGE_FORWARD:
 591       GST_OBJECT_LOCK (gstbin);
 592       g_value_set_boolean (value, gstbin-&gt;priv-&gt;message_forward);
 593       GST_OBJECT_UNLOCK (gstbin);
 594       break;
 595     default:
 596       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 597       break;
 598   }
 599 }
 600 
 601 #if 0
 602 /* return the cached index */
 603 static GstIndex *
 604 gst_bin_get_index_func (GstElement * element)
 605 {
 606   GstBin *bin;
 607   GstIndex *result;
 608 
 609   bin = GST_BIN_CAST (element);
 610 
 611   GST_OBJECT_LOCK (bin);
 612   if ((result = bin-&gt;priv-&gt;index))
 613     gst_object_ref (result);
 614   GST_OBJECT_UNLOCK (bin);
 615 
 616   return result;
 617 }
 618 
 619 /* set the index on all elements in this bin
 620  *
 621  * MT safe
 622  */
 623 static void
 624 gst_bin_set_index_func (GstElement * element, GstIndex * index)
 625 {
 626   GstBin *bin;
 627   gboolean done;
 628   GstIterator *it;
 629   GstIndex *old;
 630   GValue data = { 0, };
 631 
 632   bin = GST_BIN_CAST (element);
 633 
 634   GST_OBJECT_LOCK (bin);
 635   old = bin-&gt;priv-&gt;index;
 636   if (G_UNLIKELY (old == index))
 637     goto was_set;
 638   if (index)
 639     gst_object_ref (index);
 640   bin-&gt;priv-&gt;index = index;
 641   GST_OBJECT_UNLOCK (bin);
 642 
 643   if (old)
 644     gst_object_unref (old);
 645 
 646   it = gst_bin_iterate_elements (bin);
 647 
 648   /* set the index on all elements in the bin */
 649   done = FALSE;
 650   while (!done) {
 651     switch (gst_iterator_next (it, &amp;data)) {
 652       case GST_ITERATOR_OK:
 653       {
 654         GstElement *child = g_value_get_object (&amp;data);
 655 
 656         GST_DEBUG_OBJECT (bin, &quot;setting index on &#39;%s&#39;&quot;,
 657             GST_ELEMENT_NAME (child));
 658         gst_element_set_index (child, index);
 659 
 660         g_value_reset (&amp;data);
 661         break;
 662       }
 663       case GST_ITERATOR_RESYNC:
 664         GST_DEBUG_OBJECT (bin, &quot;iterator doing resync&quot;);
 665         gst_iterator_resync (it);
 666         break;
 667       default:
 668       case GST_ITERATOR_DONE:
 669         GST_DEBUG_OBJECT (bin, &quot;iterator done&quot;);
 670         done = TRUE;
 671         break;
 672     }
 673   }
 674   g_value_unset (&amp;data);
 675   gst_iterator_free (it);
 676   return;
 677 
 678 was_set:
 679   {
 680     GST_DEBUG_OBJECT (bin, &quot;index was already set&quot;);
 681     GST_OBJECT_UNLOCK (bin);
 682     return;
 683   }
 684 }
 685 #endif
 686 
 687 /* set the clock on all elements in this bin
 688  *
 689  * MT safe
 690  */
 691 static gboolean
 692 gst_bin_set_clock_func (GstElement * element, GstClock * clock)
 693 {
 694   GstBin *bin;
 695   gboolean done;
 696   GstIterator *it;
 697   gboolean res = TRUE;
 698   GValue data = { 0, };
 699 
 700   bin = GST_BIN_CAST (element);
 701 
 702   it = gst_bin_iterate_elements (bin);
 703 
 704   done = FALSE;
 705   while (!done) {
 706     switch (gst_iterator_next (it, &amp;data)) {
 707       case GST_ITERATOR_OK:
 708       {
 709         GstElement *child = g_value_get_object (&amp;data);
 710 
 711         res &amp;= gst_element_set_clock (child, clock);
 712 
 713         g_value_reset (&amp;data);
 714         break;
 715       }
 716       case GST_ITERATOR_RESYNC:
 717         GST_DEBUG_OBJECT (bin, &quot;iterator doing resync&quot;);
 718         gst_iterator_resync (it);
 719         res = TRUE;
 720         break;
 721       default:
 722       case GST_ITERATOR_DONE:
 723         GST_DEBUG_OBJECT (bin, &quot;iterator done&quot;);
 724         done = TRUE;
 725         break;
 726     }
 727   }
 728   g_value_unset (&amp;data);
 729   gst_iterator_free (it);
 730 
 731   if (res)
 732     res = GST_ELEMENT_CLASS (parent_class)-&gt;set_clock (element, clock);
 733 
 734   return res;
 735 }
 736 
 737 /* get the clock for this bin by asking all of the children in this bin
 738  *
 739  * The ref of the returned clock in increased so unref after usage.
 740  *
 741  * We loop the elements in state order and pick the last clock we can
 742  * get. This makes sure we get a clock from the source.
 743  *
 744  * MT safe
 745  */
 746 static GstClock *
 747 gst_bin_provide_clock_func (GstElement * element)
 748 {
 749   GstClock *result = NULL;
 750   GstElement *provider = NULL;
 751   GstBin *bin;
 752   GstIterator *it;
 753   gboolean done;
 754   GValue val = { 0, };
 755   GstClock **provided_clock_p;
 756   GstElement **clock_provider_p;
 757 
 758   bin = GST_BIN_CAST (element);
 759 
 760   GST_OBJECT_LOCK (bin);
 761   if (!bin-&gt;clock_dirty)
 762     goto not_dirty;
 763 
 764   GST_DEBUG_OBJECT (bin, &quot;finding new clock&quot;);
 765 
 766   it = gst_bin_sort_iterator_new (bin);
 767   GST_OBJECT_UNLOCK (bin);
 768 
 769   done = FALSE;
 770   while (!done) {
 771     switch (gst_iterator_next (it, &amp;val)) {
 772       case GST_ITERATOR_OK:
 773       {
 774         GstElement *child = g_value_get_object (&amp;val);
 775         GstClock *clock;
 776 
 777         clock = gst_element_provide_clock (child);
 778         if (clock) {
 779           GST_DEBUG_OBJECT (bin, &quot;found candidate clock %p by element %s&quot;,
 780               clock, GST_ELEMENT_NAME (child));
 781           if (result) {
 782             gst_object_unref (result);
 783             gst_object_unref (provider);
 784           }
 785           result = clock;
 786           provider = gst_object_ref (child);
 787         }
 788 
 789         g_value_reset (&amp;val);
 790         break;
 791       }
 792       case GST_ITERATOR_RESYNC:
 793         gst_iterator_resync (it);
 794         break;
 795       default:
 796       case GST_ITERATOR_DONE:
 797         done = TRUE;
 798         break;
 799     }
 800   }
 801   g_value_unset (&amp;val);
 802   gst_iterator_free (it);
 803 
 804   GST_OBJECT_LOCK (bin);
 805   if (!bin-&gt;clock_dirty) {
 806     if (provider)
 807       gst_object_unref (provider);
 808     if (result)
 809       gst_object_unref (result);
 810     result = NULL;
 811 
 812     goto not_dirty;
 813   }
 814 
 815   provided_clock_p = &amp;bin-&gt;provided_clock;
 816   clock_provider_p = &amp;bin-&gt;clock_provider;
 817   gst_object_replace ((GstObject **) provided_clock_p, (GstObject *) result);
 818   gst_object_replace ((GstObject **) clock_provider_p, (GstObject *) provider);
 819   bin-&gt;clock_dirty = FALSE;
 820   GST_DEBUG_OBJECT (bin,
 821       &quot;provided new clock %&quot; GST_PTR_FORMAT &quot; by provider %&quot; GST_PTR_FORMAT,
 822       result, provider);
 823   /* Provider is not being returned to caller, just the result */
 824   if (provider)
 825     gst_object_unref (provider);
 826   GST_OBJECT_UNLOCK (bin);
 827 
 828   return result;
 829 
 830 not_dirty:
 831   {
 832     if ((result = bin-&gt;provided_clock))
 833       gst_object_ref (result);
 834     GST_DEBUG_OBJECT (bin, &quot;returning old clock %p&quot;, result);
 835     GST_OBJECT_UNLOCK (bin);
 836 
 837     return result;
 838   }
 839 }
 840 
 841 /*
 842  * functions for manipulating cached messages
 843  */
 844 typedef struct
 845 {
 846   GstObject *src;
 847   GstMessageType types;
 848 } MessageFind;
 849 
 850 /* check if a message is of given src and type */
 851 static gint
 852 message_check (GstMessage * message, MessageFind * target)
 853 {
 854   gboolean eq = TRUE;
 855 
 856   if (target-&gt;src)
 857     eq &amp;= GST_MESSAGE_SRC (message) == target-&gt;src;
 858   if (target-&gt;types)
 859     eq &amp;= (GST_MESSAGE_TYPE (message) &amp; target-&gt;types) != 0;
 860   GST_LOG (&quot;looking at message %p: %d&quot;, message, eq);
 861 
 862   return (eq ? 0 : 1);
 863 }
 864 
 865 static GList *
 866 find_message (GstBin * bin, GstObject * src, GstMessageType types)
 867 {
 868   GList *result;
 869   MessageFind find;
 870 
 871   find.src = src;
 872   find.types = types;
 873 
 874   result = g_list_find_custom (bin-&gt;messages, &amp;find,
 875       (GCompareFunc) message_check);
 876 
 877   if (result) {
 878     GST_DEBUG_OBJECT (bin, &quot;we found a message %p from %s matching types %08x&quot;,
 879         result-&gt;data, GST_OBJECT_NAME (GST_MESSAGE_CAST (result-&gt;data)-&gt;src),
 880         types);
 881   } else {
 882     GST_DEBUG_OBJECT (bin, &quot;no message found matching types %08x&quot;, types);
 883 #ifndef GST_DISABLE_GST_DEBUG
 884     {
 885       guint i;
 886 
 887       for (i = 0; i &lt; 32; i++)
 888         if (types &amp; (1U &lt;&lt; i))
 889           GST_DEBUG_OBJECT (bin, &quot;  %s&quot;, gst_message_type_get_name (1U &lt;&lt; i));
 890     }
 891 #endif
 892   }
 893 
 894   return result;
 895 }
 896 
 897 /* with LOCK, returns TRUE if message had a valid SRC, takes ownership of
 898  * the message.
 899  *
 900  * A message that is cached and has the same SRC and type is replaced
 901  * by the given message.
 902  */
 903 static gboolean
 904 bin_replace_message (GstBin * bin, GstMessage * message, GstMessageType types)
 905 {
 906   GList *previous;
 907   GstObject *src;
 908   gboolean res = TRUE;
 909 
 910   if ((src = GST_MESSAGE_SRC (message))) {
 911     /* first find the previous message posted by this element */
 912     if ((previous = find_message (bin, src, types))) {
 913       GstMessage *previous_msg;
 914 
 915       /* if we found a previous message, replace it */
 916       previous_msg = previous-&gt;data;
 917       previous-&gt;data = message;
 918 
 919       GST_DEBUG_OBJECT (bin, &quot;replace old message %s from %s with %s message&quot;,
 920           GST_MESSAGE_TYPE_NAME (previous_msg), GST_ELEMENT_NAME (src),
 921           GST_MESSAGE_TYPE_NAME (message));
 922 
 923       gst_message_unref (previous_msg);
 924     } else {
 925       /* keep new message */
 926       bin-&gt;messages = g_list_prepend (bin-&gt;messages, message);
 927 
 928       GST_DEBUG_OBJECT (bin, &quot;got new message %p, %s from %s&quot;,
 929           message, GST_MESSAGE_TYPE_NAME (message), GST_ELEMENT_NAME (src));
 930     }
 931   } else {
 932     GST_DEBUG_OBJECT (bin, &quot;got message %s from (NULL), not processing&quot;,
 933         GST_MESSAGE_TYPE_NAME (message));
 934     res = FALSE;
 935     gst_message_unref (message);
 936   }
 937   return res;
 938 }
 939 
 940 /* with LOCK. Remove all messages of given types */
 941 static void
 942 bin_remove_messages (GstBin * bin, GstObject * src, GstMessageType types)
 943 {
 944   MessageFind find;
 945   GList *walk, *next;
 946 
 947   find.src = src;
 948   find.types = types;
 949 
 950   for (walk = bin-&gt;messages; walk; walk = next) {
 951     GstMessage *message = (GstMessage *) walk-&gt;data;
 952 
 953     next = g_list_next (walk);
 954 
 955     if (message_check (message, &amp;find) == 0) {
 956       GST_DEBUG_OBJECT (GST_MESSAGE_SRC (message),
 957           &quot;deleting message %p of type %s (types 0x%08x)&quot;, message,
 958           GST_MESSAGE_TYPE_NAME (message), types);
 959       bin-&gt;messages = g_list_delete_link (bin-&gt;messages, walk);
 960       gst_message_unref (message);
 961     } else {
 962       GST_DEBUG_OBJECT (GST_MESSAGE_SRC (message),
 963           &quot;not deleting message %p of type 0x%08x&quot;, message,
 964           GST_MESSAGE_TYPE (message));
 965     }
 966   }
 967 }
 968 
 969 
 970 /* Check if the bin is EOS. We do this by scanning all sinks and
 971  * checking if they posted an EOS message.
 972  *
 973  * call with bin LOCK */
 974 static gboolean
 975 is_eos (GstBin * bin, guint32 * seqnum)
 976 {
 977   gboolean result;
 978   gint n_eos = 0;
 979   GList *walk, *msgs;
 980 
 981   result = TRUE;
 982   for (walk = bin-&gt;children; walk; walk = g_list_next (walk)) {
 983     GstElement *element;
 984 
 985     element = GST_ELEMENT_CAST (walk-&gt;data);
 986     if (bin_element_is_sink (element, bin) == 0) {
 987       /* check if element posted EOS */
 988       if ((msgs =
 989               find_message (bin, GST_OBJECT_CAST (element), GST_MESSAGE_EOS))) {
 990         GST_DEBUG (&quot;sink &#39;%s&#39; posted EOS&quot;, GST_ELEMENT_NAME (element));
 991         *seqnum = gst_message_get_seqnum (GST_MESSAGE_CAST (msgs-&gt;data));
 992         n_eos++;
 993       } else {
 994         GST_DEBUG (&quot;sink &#39;%s&#39; did not post EOS yet&quot;,
 995             GST_ELEMENT_NAME (element));
 996         result = FALSE;
 997         break;
 998       }
 999     }
1000   }
1001   /* FIXME: Some tests (e.g. elements/capsfilter) use
1002    * pipelines with a dangling sinkpad but no sink element.
1003    * These tests assume that no EOS message is ever
1004    * posted on the bus so let&#39;s keep that behaviour.
1005    * In valid pipelines this doesn&#39;t make a difference.
1006    */
1007   return result &amp;&amp; n_eos &gt; 0;
1008 }
1009 
1010 
1011 /* Check if the bin is STREAM_START. We do this by scanning all sinks and
1012  * checking if they posted an STREAM_START message.
1013  *
1014  * call with bin LOCK */
1015 static gboolean
1016 is_stream_start (GstBin * bin, guint32 * seqnum, gboolean * have_group_id,
1017     guint * group_id)
1018 {
1019   gboolean result;
1020   GList *walk, *msgs;
1021   guint tmp_group_id;
1022   gboolean first = TRUE, same_group_id = TRUE;
1023 
1024   *have_group_id = TRUE;
1025   *group_id = 0;
1026   result = TRUE;
1027   for (walk = bin-&gt;children; walk; walk = g_list_next (walk)) {
1028     GstElement *element;
1029 
1030     element = GST_ELEMENT_CAST (walk-&gt;data);
1031     if (bin_element_is_sink (element, bin) == 0) {
1032       /* check if element posted STREAM_START */
1033       if ((msgs =
1034               find_message (bin, GST_OBJECT_CAST (element),
1035                   GST_MESSAGE_STREAM_START))) {
1036         GST_DEBUG (&quot;sink &#39;%s&#39; posted STREAM_START&quot;, GST_ELEMENT_NAME (element));
1037         *seqnum = gst_message_get_seqnum (GST_MESSAGE_CAST (msgs-&gt;data));
1038         if (gst_message_parse_group_id (GST_MESSAGE_CAST (msgs-&gt;data),
1039                 &amp;tmp_group_id)) {
1040           if (first) {
1041             first = FALSE;
1042             *group_id = tmp_group_id;
1043           } else {
1044             if (tmp_group_id != *group_id)
1045               same_group_id = FALSE;
1046           }
1047         } else {
1048           *have_group_id = FALSE;
1049         }
1050       } else {
1051         GST_DEBUG (&quot;sink &#39;%s&#39; did not post STREAM_START yet&quot;,
1052             GST_ELEMENT_NAME (element));
1053         result = FALSE;
1054         break;
1055       }
1056     }
1057   }
1058 
1059   /* If all have a group_id we only consider this stream started
1060    * if all group ids were the same and all sinks posted a stream-start
1061    * message */
1062   if (*have_group_id)
1063     return same_group_id &amp;&amp; result;
1064   /* otherwise consider this stream started after all sinks
1065    * have reported stream-start for backward compatibility.
1066    * FIXME 2.0: This should go away! */
1067   return result;
1068 }
1069 
1070 static void
1071 unlink_pads (const GValue * item, gpointer user_data)
1072 {
1073   GstPad *pad;
1074   GstPad *peer;
1075 
1076   pad = g_value_get_object (item);
1077 
1078   if ((peer = gst_pad_get_peer (pad))) {
1079     if (gst_pad_get_direction (pad) == GST_PAD_SRC)
1080       gst_pad_unlink (pad, peer);
1081     else
1082       gst_pad_unlink (peer, pad);
1083     gst_object_unref (peer);
1084   }
1085 }
1086 
1087 static void
1088 bin_deep_iterator_foreach (const GValue * item, gpointer user_data)
1089 {
1090   GQueue *queue = user_data;
1091 
1092   g_queue_push_tail (queue, g_value_dup_object (item));
1093 }
1094 
1095 static void
1096 gst_bin_do_deep_add_remove (GstBin * bin, gint sig_id, const gchar * sig_name,
1097     GstElement * element)
1098 {
1099   g_signal_emit (bin, sig_id, 0, bin, element);
1100 
1101   /* When removing a bin, emit deep-element-* for everything in the bin too */
1102   if (GST_IS_BIN (element)) {
1103     GstIterator *it;
1104     GstIteratorResult ires;
1105     GQueue elements = G_QUEUE_INIT;
1106 
1107     GST_LOG_OBJECT (bin, &quot;Recursing into bin %&quot; GST_PTR_FORMAT &quot; for %s&quot;,
1108         element, sig_name);
1109     it = gst_bin_iterate_recurse (GST_BIN_CAST (element));
1110     do {
1111       ires = gst_iterator_foreach (it, bin_deep_iterator_foreach, &amp;elements);
1112       if (ires != GST_ITERATOR_DONE) {
1113         g_queue_foreach (&amp;elements, (GFunc) g_object_unref, NULL);
1114         g_queue_clear (&amp;elements);
1115       }
1116       if (ires == GST_ITERATOR_RESYNC)
1117         gst_iterator_resync (it);
1118     } while (ires == GST_ITERATOR_RESYNC);
1119     if (ires != GST_ITERATOR_ERROR) {
1120       GstElement *e;
1121 
1122       while ((e = g_queue_pop_head (&amp;elements))) {
1123         GstObject *parent = gst_object_get_parent (GST_OBJECT_CAST (e));
1124 
<a name="6" id="anc6"></a><span class="line-modified">1125         /* an element could have removed some of its internal elements</span>
<span class="line-modified">1126          * meanwhile, so protect against that */</span>
<span class="line-modified">1127         if (parent) {</span>
<span class="line-modified">1128           GST_LOG_OBJECT (bin, &quot;calling %s for element %&quot; GST_PTR_FORMAT</span>
<span class="line-modified">1129               &quot; in bin %&quot; GST_PTR_FORMAT, sig_name, e, parent);</span>
<span class="line-added">1130           g_signal_emit (bin, sig_id, 0, parent, e);</span>
<span class="line-added">1131           gst_object_unref (parent);</span>
<span class="line-added">1132           g_object_unref (e);</span>
<span class="line-added">1133         }</span>
1134       }
1135     }
1136     gst_iterator_free (it);
1137   }
1138 }
1139 
1140 /* vmethod that adds an element to a bin
1141  *
1142  * MT safe
1143  */
1144 static gboolean
1145 gst_bin_add_func (GstBin * bin, GstElement * element)
1146 {
1147   gchar *elem_name;
1148   GstIterator *it;
1149   gboolean is_sink, is_source, provides_clock, requires_clock;
1150   GstMessage *clock_message = NULL, *async_message = NULL;
1151   GstStateChangeReturn ret;
1152   GList *l, *elem_contexts, *need_context_messages;
1153 
1154   GST_DEBUG_OBJECT (bin, &quot;element :%s&quot;, GST_ELEMENT_NAME (element));
1155 
1156   /* we obviously can&#39;t add ourself to ourself */
1157   if (G_UNLIKELY (element == GST_ELEMENT_CAST (bin)))
1158     goto adding_itself;
1159 
1160   /* get the element name to make sure it is unique in this bin. */
1161   GST_OBJECT_LOCK (element);
1162   elem_name = g_strdup (GST_ELEMENT_NAME (element));
1163   is_sink = GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_SINK);
1164   is_source = GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_SOURCE);
1165   provides_clock =
1166       GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
1167   requires_clock =
1168       GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_REQUIRE_CLOCK);
1169   GST_OBJECT_UNLOCK (element);
1170 
1171   GST_OBJECT_LOCK (bin);
1172 
1173   /* then check to see if the element&#39;s name is already taken in the bin,
1174    * we can safely take the lock here. This check is probably bogus because
1175    * you can safely change the element name after this check and before setting
1176    * the object parent. The window is very small though... */
1177   if (G_UNLIKELY (!gst_object_check_uniqueness (bin-&gt;children, elem_name)))
1178     goto duplicate_name;
1179 
1180   /* set the element&#39;s parent and add the element to the bin&#39;s list of children */
1181   if (G_UNLIKELY (!gst_object_set_parent (GST_OBJECT_CAST (element),
1182               GST_OBJECT_CAST (bin))))
1183     goto had_parent;
1184 
1185   /* if we add a sink we become a sink */
1186   if (is_sink &amp;&amp; !(bin-&gt;priv-&gt;suppressed_flags &amp; GST_ELEMENT_FLAG_SINK)) {
1187     GST_CAT_DEBUG_OBJECT (GST_CAT_PARENTAGE, bin, &quot;element \&quot;%s\&quot; was sink&quot;,
1188         elem_name);
1189     GST_OBJECT_FLAG_SET (bin, GST_ELEMENT_FLAG_SINK);
1190   }
1191   if (is_source &amp;&amp; !(bin-&gt;priv-&gt;suppressed_flags &amp; GST_ELEMENT_FLAG_SOURCE)) {
1192     GST_CAT_DEBUG_OBJECT (GST_CAT_PARENTAGE, bin, &quot;element \&quot;%s\&quot; was source&quot;,
1193         elem_name);
1194     GST_OBJECT_FLAG_SET (bin, GST_ELEMENT_FLAG_SOURCE);
1195   }
1196   if (provides_clock
1197       &amp;&amp; !(bin-&gt;priv-&gt;suppressed_flags &amp; GST_ELEMENT_FLAG_PROVIDE_CLOCK)) {
1198     GST_DEBUG_OBJECT (bin, &quot;element \&quot;%s\&quot; can provide a clock&quot;, elem_name);
1199     clock_message =
1200         gst_message_new_clock_provide (GST_OBJECT_CAST (element), NULL, TRUE);
1201     GST_OBJECT_FLAG_SET (bin, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
1202   }
1203   if (requires_clock
1204       &amp;&amp; !(bin-&gt;priv-&gt;suppressed_flags &amp; GST_ELEMENT_FLAG_REQUIRE_CLOCK)) {
1205     GST_DEBUG_OBJECT (bin, &quot;element \&quot;%s\&quot; requires a clock&quot;, elem_name);
1206     GST_OBJECT_FLAG_SET (bin, GST_ELEMENT_FLAG_REQUIRE_CLOCK);
1207   }
1208 
1209   bin-&gt;children = g_list_prepend (bin-&gt;children, element);
1210   bin-&gt;numchildren++;
1211   bin-&gt;children_cookie++;
1212   if (!GST_BIN_IS_NO_RESYNC (bin))
1213     bin-&gt;priv-&gt;structure_cookie++;
1214 
1215   /* distribute the bus */
1216   gst_element_set_bus (element, bin-&gt;child_bus);
1217 
1218   /* propagate the current base_time, start_time and clock */
1219   gst_element_set_base_time (element, GST_ELEMENT_CAST (bin)-&gt;base_time);
1220   gst_element_set_start_time (element, GST_ELEMENT_START_TIME (bin));
1221   /* it&#39;s possible that the element did not accept the clock but
1222    * that is not important right now. When the pipeline goes to PLAYING,
1223    * a new clock will be selected */
1224   gst_element_set_clock (element, GST_ELEMENT_CLOCK (bin));
1225 
1226   /* get the element&#39;s list of contexts before propagating our own */
1227   elem_contexts = gst_element_get_contexts (element);
1228   for (l = GST_ELEMENT_CAST (bin)-&gt;contexts; l; l = l-&gt;next)
1229     gst_element_set_context (element, l-&gt;data);
1230 
1231   need_context_messages = NULL;
1232   for (l = elem_contexts; l; l = l-&gt;next) {
1233     GstContext *replacement, *context = l-&gt;data;
1234     const gchar *context_type;
1235 
1236     context_type = gst_context_get_context_type (context);
1237 
1238     /* we already set this context above? */
1239     replacement =
1240         gst_element_get_context_unlocked (GST_ELEMENT (bin), context_type);
1241     if (replacement) {
1242       gst_context_unref (replacement);
1243     } else {
1244       GstMessage *msg;
1245       GstStructure *s;
1246 
1247       /* ask our parent for the context */
1248       msg = gst_message_new_need_context (GST_OBJECT_CAST (bin), context_type);
1249       s = (GstStructure *) gst_message_get_structure (msg);
1250       gst_structure_set (s, &quot;bin.old.context&quot;, GST_TYPE_CONTEXT, context, NULL);
1251 
1252       need_context_messages = g_list_prepend (need_context_messages, msg);
1253     }
1254   }
1255 
1256 #if 0
1257   /* set the cached index on the children */
1258   if (bin-&gt;priv-&gt;index)
1259     gst_element_set_index (element, bin-&gt;priv-&gt;index);
1260 #endif
1261 
1262   ret = GST_STATE_RETURN (bin);
1263   /* no need to update the state if we are in error */
1264   if (ret == GST_STATE_CHANGE_FAILURE)
1265     goto no_state_recalc;
1266 
1267   /* update the bin state, the new element could have been an ASYNC or
1268    * NO_PREROLL element */
1269   ret = GST_STATE_RETURN (element);
1270   GST_DEBUG_OBJECT (bin, &quot;added %s element&quot;,
1271       gst_element_state_change_return_get_name (ret));
1272 
1273   switch (ret) {
1274     case GST_STATE_CHANGE_ASYNC:
1275     {
1276       /* create message to track this aync element when it posts an async-done
1277        * message */
1278       async_message = gst_message_new_async_start (GST_OBJECT_CAST (element));
1279       break;
1280     }
1281     case GST_STATE_CHANGE_NO_PREROLL:
1282       /* ignore all async elements we might have and commit our state */
1283       bin_handle_async_done (bin, ret, FALSE, GST_CLOCK_TIME_NONE);
1284       break;
1285     case GST_STATE_CHANGE_FAILURE:
1286       break;
1287     default:
1288       break;
1289   }
1290 
1291 no_state_recalc:
1292   GST_OBJECT_UNLOCK (bin);
1293 
1294   for (l = need_context_messages; l; l = l-&gt;next) {
1295     GstMessage *msg = l-&gt;data;
1296     GstStructure *s;
1297     const gchar *context_type;
1298     GstContext *replacement, *context;
1299 
1300     gst_message_parse_context_type (msg, &amp;context_type);
1301 
1302     GST_LOG_OBJECT (bin, &quot;asking parent for context type: %s &quot;
1303         &quot;from %&quot; GST_PTR_FORMAT, context_type, element);
1304 
1305     s = (GstStructure *) gst_message_get_structure (msg);
1306     gst_structure_get (s, &quot;bin.old.context&quot;, GST_TYPE_CONTEXT, &amp;context, NULL);
1307     gst_structure_remove_field (s, &quot;bin.old.context&quot;);
1308     /* Keep the msg around while we still need access to the context_type */
1309     gst_element_post_message (GST_ELEMENT_CAST (bin), gst_message_ref (msg));
1310 
1311     /* lock to avoid losing a potential write */
1312     GST_OBJECT_LOCK (bin);
1313     replacement =
1314         gst_element_get_context_unlocked (GST_ELEMENT_CAST (bin), context_type);
1315     gst_message_unref (msg);
1316 
1317     if (replacement) {
1318       /* we got the context set from GstElement::set_context */
1319       gst_context_unref (replacement);
1320       GST_OBJECT_UNLOCK (bin);
1321     } else {
1322       /* Propagate the element&#39;s context upwards */
1323       GST_LOG_OBJECT (bin, &quot;propagating existing context type: %s %p &quot;
1324           &quot;from %&quot; GST_PTR_FORMAT, context_type, context, element);
1325 
1326       gst_bin_update_context_unlocked (bin, context);
1327 
1328       msg =
1329           gst_message_new_have_context (GST_OBJECT_CAST (bin),
1330           gst_context_ref (context));
1331       GST_OBJECT_UNLOCK (bin);
1332       gst_element_post_message (GST_ELEMENT_CAST (bin), msg);
1333     }
1334     gst_context_unref (context);
1335   }
1336   g_list_free_full (elem_contexts, (GDestroyNotify) gst_context_unref);
1337   g_list_free (need_context_messages);
1338 
1339   /* post the messages on the bus of the element so that the bin can handle
1340    * them */
1341   if (clock_message)
1342     gst_element_post_message (element, clock_message);
1343 
1344   if (async_message)
1345     gst_element_post_message (element, async_message);
1346 
1347   /* unlink all linked pads */
1348   it = gst_element_iterate_pads (element);
1349   while (gst_iterator_foreach (it, (GstIteratorForeachFunction) unlink_pads,
1350           NULL) == GST_ITERATOR_RESYNC)
1351     gst_iterator_resync (it);
1352   gst_iterator_free (it);
1353 
1354   GST_CAT_DEBUG_OBJECT (GST_CAT_PARENTAGE, bin, &quot;added element \&quot;%s\&quot;&quot;,
1355       elem_name);
1356 
1357   g_signal_emit (bin, gst_bin_signals[ELEMENT_ADDED], 0, element);
1358   gst_child_proxy_child_added ((GstChildProxy *) bin, (GObject *) element,
1359       elem_name);
1360 
1361   gst_bin_do_deep_add_remove (bin, gst_bin_signals[DEEP_ELEMENT_ADDED],
1362       &quot;deep-element-added&quot;, element);
1363 
1364   g_free (elem_name);
1365 
1366   return TRUE;
1367 
1368   /* ERROR handling here */
1369 adding_itself:
1370   {
1371     GST_OBJECT_LOCK (bin);
1372     g_warning (&quot;Cannot add bin &#39;%s&#39; to itself&quot;, GST_ELEMENT_NAME (bin));
1373     GST_OBJECT_UNLOCK (bin);
1374     gst_object_ref_sink (element);
1375     gst_object_unref (element);
1376     return FALSE;
1377   }
1378 duplicate_name:
1379   {
1380     g_warning (&quot;Name &#39;%s&#39; is not unique in bin &#39;%s&#39;, not adding&quot;,
1381         elem_name, GST_ELEMENT_NAME (bin));
1382     GST_OBJECT_UNLOCK (bin);
1383     g_free (elem_name);
1384     gst_object_ref_sink (element);
1385     gst_object_unref (element);
1386     return FALSE;
1387   }
1388 had_parent:
1389   {
1390     g_warning (&quot;Element &#39;%s&#39; already has parent&quot;, elem_name);
1391     GST_OBJECT_UNLOCK (bin);
1392     g_free (elem_name);
1393     return FALSE;
1394   }
1395 }
1396 
1397 /**
1398  * gst_bin_set_suppressed_flags:
1399  * @bin: a #GstBin
1400  * @flags: the #GstElementFlags to suppress
1401  *
1402  * Suppress the given flags on the bin. #GstElementFlags of a
1403  * child element are propagated when it is added to the bin.
1404  * When suppressed flags are set, those specified flags will
1405  * not be propagated to the bin.
1406  *
1407  * MT safe.
1408  *
1409  * Since: 1.10
1410  */
1411 void
1412 gst_bin_set_suppressed_flags (GstBin * bin, GstElementFlags flags)
1413 {
1414   g_return_if_fail (GST_IS_BIN (bin));
1415 
1416   GST_OBJECT_LOCK (bin);
1417   bin-&gt;priv-&gt;suppressed_flags = bin-&gt;priv-&gt;suppressed_flags | flags;
1418   GST_OBJECT_UNLOCK (bin);
1419 
1420   GST_DEBUG_OBJECT (bin, &quot;Set suppressed flags(0x%x) to bin &#39;%s&#39;&quot;, flags,
1421       GST_ELEMENT_NAME (bin));
1422 }
1423 
1424 /**
1425  * gst_bin_get_suppressed_flags:
1426  * @bin: a #GstBin
1427  *
1428  * Return the suppressed flags of the bin.
1429  *
1430  * MT safe.
1431  *
1432  * Returns: the bin&#39;s suppressed #GstElementFlags.
1433  *
1434  * Since: 1.10
1435  */
1436 GstElementFlags
1437 gst_bin_get_suppressed_flags (GstBin * bin)
1438 {
1439   GstElementFlags res;
1440 
1441   g_return_val_if_fail (GST_IS_BIN (bin), 0);
1442 
1443   GST_OBJECT_LOCK (bin);
1444   res = bin-&gt;priv-&gt;suppressed_flags;
1445   GST_OBJECT_UNLOCK (bin);
1446 
1447   return res;
1448 }
1449 
1450 /* signal vfunc, will be called when a new element was added */
1451 static void
1452 gst_bin_deep_element_added_func (GstBin * bin, GstBin * sub_bin,
1453     GstElement * child)
1454 {
1455   GstBin *parent_bin;
1456 
1457   parent_bin = (GstBin *) gst_object_get_parent (GST_OBJECT_CAST (bin));
1458   if (parent_bin == NULL) {
1459     GST_LOG_OBJECT (bin, &quot;no parent, reached top-level&quot;);
1460     return;
1461   }
1462 
1463   GST_LOG_OBJECT (parent_bin, &quot;emitting deep-element-added for element &quot;
1464       &quot;%&quot; GST_PTR_FORMAT &quot; which has just been added to %&quot; GST_PTR_FORMAT,
1465       child, sub_bin);
1466 
1467   g_signal_emit (parent_bin, gst_bin_signals[DEEP_ELEMENT_ADDED], 0, sub_bin,
1468       child);
1469 
1470   gst_object_unref (parent_bin);
1471 }
1472 
1473 /* signal vfunc, will be called when an element was removed */
1474 static void
1475 gst_bin_deep_element_removed_func (GstBin * bin, GstBin * sub_bin,
1476     GstElement * child)
1477 {
1478   GstBin *parent_bin;
1479 
1480   parent_bin = (GstBin *) gst_object_get_parent (GST_OBJECT_CAST (bin));
1481   if (parent_bin == NULL) {
1482     GST_LOG_OBJECT (bin, &quot;no parent, reached top-level&quot;);
1483     return;
1484   }
1485 
1486   GST_LOG_OBJECT (parent_bin, &quot;emitting deep-element-removed for element &quot;
1487       &quot;%&quot; GST_PTR_FORMAT &quot; which has just been removed from %&quot; GST_PTR_FORMAT,
1488       sub_bin, child);
1489 
1490   g_signal_emit (parent_bin, gst_bin_signals[DEEP_ELEMENT_REMOVED], 0, sub_bin,
1491       child);
1492 
1493   gst_object_unref (parent_bin);
1494 }
1495 
1496 /**
1497  * gst_bin_add:
1498  * @bin: a #GstBin
1499  * @element: (transfer floating): the #GstElement to add
1500  *
1501  * Adds the given element to the bin.  Sets the element&#39;s parent, and thus
1502  * takes ownership of the element. An element can only be added to one bin.
1503  *
1504  * If the element&#39;s pads are linked to other pads, the pads will be unlinked
1505  * before the element is added to the bin.
1506  *
1507  * &gt; When you add an element to an already-running pipeline, you will have to
1508  * &gt; take care to set the state of the newly-added element to the desired
1509  * &gt; state (usually PLAYING or PAUSED, same you set the pipeline to originally)
1510  * &gt; with gst_element_set_state(), or use gst_element_sync_state_with_parent().
1511  * &gt; The bin or pipeline will not take care of this for you.
1512  *
1513  * MT safe.
1514  *
1515  * Returns: %TRUE if the element could be added, %FALSE if
1516  * the bin does not want to accept the element.
1517  */
1518 gboolean
1519 gst_bin_add (GstBin * bin, GstElement * element)
1520 {
1521   GstBinClass *bclass;
1522   gboolean result;
1523 
1524   g_return_val_if_fail (GST_IS_BIN (bin), FALSE);
1525   g_return_val_if_fail (GST_IS_ELEMENT (element), FALSE);
1526   g_return_val_if_fail (GST_ELEMENT_CAST (bin) != element, FALSE);
1527 
1528   bclass = GST_BIN_GET_CLASS (bin);
1529 
1530   if (G_UNLIKELY (bclass-&gt;add_element == NULL))
1531     goto no_function;
1532 
1533   GST_CAT_DEBUG (GST_CAT_PARENTAGE, &quot;adding element %s to bin %s&quot;,
1534       GST_STR_NULL (GST_ELEMENT_NAME (element)),
1535       GST_STR_NULL (GST_ELEMENT_NAME (bin)));
1536 
1537   GST_TRACER_BIN_ADD_PRE (bin, element);
1538   result = bclass-&gt;add_element (bin, element);
1539   GST_TRACER_BIN_ADD_POST (bin, element, result);
1540 
1541   return result;
1542 
1543   /* ERROR handling */
1544 no_function:
1545   {
1546     g_warning (&quot;adding elements to bin &#39;%s&#39; is not supported&quot;,
1547         GST_ELEMENT_NAME (bin));
1548     gst_object_ref_sink (element);
1549     gst_object_unref (element);
1550     return FALSE;
1551   }
1552 }
1553 
1554 /* remove an element from the bin
1555  *
1556  * MT safe
1557  */
1558 static gboolean
1559 gst_bin_remove_func (GstBin * bin, GstElement * element)
1560 {
1561   gchar *elem_name;
1562   GstIterator *it;
1563   gboolean is_sink, is_source, provides_clock, requires_clock;
1564   gboolean othersink, othersource, otherprovider, otherrequirer, found;
1565   GstMessage *clock_message = NULL;
1566   GstClock **provided_clock_p;
1567   GstElement **clock_provider_p;
1568   GList *walk, *next;
1569   gboolean other_async, this_async, have_no_preroll;
1570   GstStateChangeReturn ret;
1571 
1572   GST_DEBUG_OBJECT (bin, &quot;element :%s&quot;, GST_ELEMENT_NAME (element));
1573 
1574   /* we obviously can&#39;t remove ourself from ourself */
1575   if (G_UNLIKELY (element == GST_ELEMENT_CAST (bin)))
1576     goto removing_itself;
1577 
1578   GST_OBJECT_LOCK (bin);
1579 
1580   GST_OBJECT_LOCK (element);
1581   elem_name = g_strdup (GST_ELEMENT_NAME (element));
1582 
1583   if (GST_OBJECT_PARENT (element) != GST_OBJECT_CAST (bin))
1584     goto not_in_bin;
1585 
1586   /* remove the parent ref */
1587   GST_OBJECT_PARENT (element) = NULL;
1588 
1589   /* grab element name so we can print it */
1590   is_sink = GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_SINK);
1591   is_source = GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_SOURCE);
1592   provides_clock =
1593       GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
1594   requires_clock =
1595       GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_REQUIRE_CLOCK);
1596   GST_OBJECT_UNLOCK (element);
1597 
1598   found = FALSE;
1599   othersink = FALSE;
1600   othersource = FALSE;
1601   otherprovider = FALSE;
1602   otherrequirer = FALSE;
1603   have_no_preroll = FALSE;
1604   /* iterate the elements, we collect which ones are async and no_preroll. We
1605    * also remove the element when we find it. */
1606   for (walk = bin-&gt;children; walk; walk = next) {
1607     GstElement *child = GST_ELEMENT_CAST (walk-&gt;data);
1608 
1609     next = g_list_next (walk);
1610 
1611     if (child == element) {
1612       found = TRUE;
1613       /* remove the element */
1614       bin-&gt;children = g_list_delete_link (bin-&gt;children, walk);
1615     } else {
1616       gboolean child_sink, child_source, child_provider, child_requirer;
1617 
1618       GST_OBJECT_LOCK (child);
1619       child_sink = GST_OBJECT_FLAG_IS_SET (child, GST_ELEMENT_FLAG_SINK);
1620       child_source = GST_OBJECT_FLAG_IS_SET (child, GST_ELEMENT_FLAG_SOURCE);
1621       child_provider =
1622           GST_OBJECT_FLAG_IS_SET (child, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
1623       child_requirer =
1624           GST_OBJECT_FLAG_IS_SET (child, GST_ELEMENT_FLAG_REQUIRE_CLOCK);
1625       /* when we remove a sink, check if there are other sinks. */
1626       if (is_sink &amp;&amp; !othersink &amp;&amp; child_sink)
1627         othersink = TRUE;
1628       if (is_source &amp;&amp; !othersource &amp;&amp; child_source)
1629         othersource = TRUE;
1630       if (provides_clock &amp;&amp; !otherprovider &amp;&amp; child_provider)
1631         otherprovider = TRUE;
1632       if (requires_clock &amp;&amp; !otherrequirer &amp;&amp; child_requirer)
1633         otherrequirer = TRUE;
1634       /* check if we have NO_PREROLL children */
1635       if (GST_STATE_RETURN (child) == GST_STATE_CHANGE_NO_PREROLL)
1636         have_no_preroll = TRUE;
1637       GST_OBJECT_UNLOCK (child);
1638     }
1639   }
1640 
1641   /* the element must have been in the bin&#39;s list of children */
1642   if (G_UNLIKELY (!found))
1643     goto not_in_bin;
1644 
1645   /* we now removed the element from the list of elements, increment the cookie
1646    * so that others can detect a change in the children list. */
1647   bin-&gt;numchildren--;
1648   bin-&gt;children_cookie++;
1649   if (!GST_BIN_IS_NO_RESYNC (bin))
1650     bin-&gt;priv-&gt;structure_cookie++;
1651 
1652   if (is_sink &amp;&amp; !othersink
1653       &amp;&amp; !(bin-&gt;priv-&gt;suppressed_flags &amp; GST_ELEMENT_FLAG_SINK)) {
1654     /* we&#39;re not a sink anymore */
1655     GST_DEBUG_OBJECT (bin, &quot;we removed the last sink&quot;);
1656     GST_OBJECT_FLAG_UNSET (bin, GST_ELEMENT_FLAG_SINK);
1657   }
1658   if (is_source &amp;&amp; !othersource
1659       &amp;&amp; !(bin-&gt;priv-&gt;suppressed_flags &amp; GST_ELEMENT_FLAG_SOURCE)) {
1660     /* we&#39;re not a source anymore */
1661     GST_DEBUG_OBJECT (bin, &quot;we removed the last source&quot;);
1662     GST_OBJECT_FLAG_UNSET (bin, GST_ELEMENT_FLAG_SOURCE);
1663   }
1664   if (provides_clock &amp;&amp; !otherprovider
1665       &amp;&amp; !(bin-&gt;priv-&gt;suppressed_flags &amp; GST_ELEMENT_FLAG_PROVIDE_CLOCK)) {
1666     /* we&#39;re not a clock provider anymore */
1667     GST_DEBUG_OBJECT (bin, &quot;we removed the last clock provider&quot;);
1668     GST_OBJECT_FLAG_UNSET (bin, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
1669   }
1670   if (requires_clock &amp;&amp; !otherrequirer
1671       &amp;&amp; !(bin-&gt;priv-&gt;suppressed_flags &amp; GST_ELEMENT_FLAG_REQUIRE_CLOCK)) {
1672     /* we&#39;re not a clock requirer anymore */
1673     GST_DEBUG_OBJECT (bin, &quot;we removed the last clock requirer&quot;);
1674     GST_OBJECT_FLAG_UNSET (bin, GST_ELEMENT_FLAG_REQUIRE_CLOCK);
1675   }
1676 
1677   /* if the clock provider for this element is removed, we lost
1678    * the clock as well, we need to inform the parent of this
1679    * so that it can select a new clock */
1680   if (bin-&gt;clock_provider == element) {
1681     GST_DEBUG_OBJECT (bin, &quot;element \&quot;%s\&quot; provided the clock&quot;, elem_name);
1682     bin-&gt;clock_dirty = TRUE;
1683     clock_message =
1684         gst_message_new_clock_lost (GST_OBJECT_CAST (bin), bin-&gt;provided_clock);
1685     provided_clock_p = &amp;bin-&gt;provided_clock;
1686     clock_provider_p = &amp;bin-&gt;clock_provider;
1687     gst_object_replace ((GstObject **) provided_clock_p, NULL);
1688     gst_object_replace ((GstObject **) clock_provider_p, NULL);
1689   }
1690 
1691   /* remove messages for the element, if there was a pending ASYNC_START
1692    * message we must see if removing the element caused the bin to lose its
1693    * async state. */
1694   this_async = FALSE;
1695   other_async = FALSE;
1696   for (walk = bin-&gt;messages; walk; walk = next) {
1697     GstMessage *message = (GstMessage *) walk-&gt;data;
1698     GstElement *src = GST_ELEMENT_CAST (GST_MESSAGE_SRC (message));
1699     gboolean remove;
1700 
1701     next = g_list_next (walk);
1702     remove = FALSE;
1703 
1704     switch (GST_MESSAGE_TYPE (message)) {
1705       case GST_MESSAGE_ASYNC_START:
1706         if (src == element)
1707           this_async = TRUE;
1708         else
1709           other_async = TRUE;
1710 
1711         GST_DEBUG_OBJECT (src, &quot;looking at message %p&quot;, message);
1712         break;
1713       case GST_MESSAGE_STRUCTURE_CHANGE:
1714       {
1715         GstElement *owner;
1716 
1717         GST_DEBUG_OBJECT (src, &quot;looking at structure change message %p&quot;,
1718             message);
1719         /* it&#39;s unlikely that this message is still in the list of messages
1720          * because this would mean that a link/unlink is busy in another thread
1721          * while we remove the element. We still have to remove the message
1722          * because we might not receive the done message anymore when the element
1723          * is removed from the bin. */
1724         gst_message_parse_structure_change (message, NULL, &amp;owner, NULL);
1725         if (owner == element)
1726           remove = TRUE;
1727         break;
1728       }
1729       default:
1730         break;
1731     }
1732     if (src == element)
1733       remove = TRUE;
1734 
1735     if (remove) {
1736       /* delete all message types */
1737       GST_DEBUG_OBJECT (src, &quot;deleting message %p of element \&quot;%s\&quot;&quot;,
1738           message, elem_name);
1739       bin-&gt;messages = g_list_delete_link (bin-&gt;messages, walk);
1740       gst_message_unref (message);
1741     }
1742   }
1743 
1744   /* get last return */
1745   ret = GST_STATE_RETURN (bin);
1746 
1747   /* no need to update the state if we are in error */
1748   if (ret == GST_STATE_CHANGE_FAILURE)
1749     goto no_state_recalc;
1750 
1751   if (!other_async &amp;&amp; this_async) {
1752     /* all other elements were not async and we removed the async one,
1753      * handle the async-done case because we are not async anymore now. */
1754     GST_DEBUG_OBJECT (bin,
1755         &quot;we removed the last async element, have no_preroll %d&quot;,
1756         have_no_preroll);
1757 
1758     /* the current state return of the bin depends on if there are no_preroll
1759      * elements in the pipeline or not */
1760     if (have_no_preroll)
1761       ret = GST_STATE_CHANGE_NO_PREROLL;
1762     else
1763       ret = GST_STATE_CHANGE_SUCCESS;
1764 
1765     bin_handle_async_done (bin, ret, FALSE, GST_CLOCK_TIME_NONE);
1766   } else {
1767     GST_DEBUG_OBJECT (bin,
1768         &quot;recalc state preroll: %d, other async: %d, this async %d&quot;,
1769         have_no_preroll, other_async, this_async);
1770 
1771     if (have_no_preroll) {
1772       ret = GST_STATE_CHANGE_NO_PREROLL;
1773     } else if (other_async) {
1774       /* there are other async elements and we were not doing an async state
1775        * change, change our pending state and go async */
1776       if (GST_STATE_PENDING (bin) == GST_STATE_VOID_PENDING) {
1777         GST_STATE_NEXT (bin) = GST_STATE (bin);
1778         GST_STATE_PENDING (bin) = GST_STATE (bin);
1779       }
1780       ret = GST_STATE_CHANGE_ASYNC;
1781     }
1782     GST_STATE_RETURN (bin) = ret;
1783   }
1784 no_state_recalc:
1785   /* clear bus */
1786   gst_element_set_bus (element, NULL);
1787   /* Clear the clock we provided to the element */
1788   gst_element_set_clock (element, NULL);
1789   GST_OBJECT_UNLOCK (bin);
1790 
1791   if (clock_message)
1792     gst_element_post_message (GST_ELEMENT_CAST (bin), clock_message);
1793 
1794   /* unlink all linked pads */
1795   it = gst_element_iterate_pads (element);
1796   while (gst_iterator_foreach (it, (GstIteratorForeachFunction) unlink_pads,
1797           NULL) == GST_ITERATOR_RESYNC)
1798     gst_iterator_resync (it);
1799   gst_iterator_free (it);
1800 
1801   GST_CAT_INFO_OBJECT (GST_CAT_PARENTAGE, bin, &quot;removed child \&quot;%s\&quot;&quot;,
1802       elem_name);
1803 
1804   g_signal_emit (bin, gst_bin_signals[ELEMENT_REMOVED], 0, element);
1805   gst_child_proxy_child_removed ((GstChildProxy *) bin, (GObject *) element,
1806       elem_name);
1807 
1808   gst_bin_do_deep_add_remove (bin, gst_bin_signals[DEEP_ELEMENT_REMOVED],
1809       &quot;deep-element-removed&quot;, element);
1810 
1811   g_free (elem_name);
1812   /* element is really out of our control now */
1813   gst_object_unref (element);
1814 
1815   return TRUE;
1816 
1817   /* ERROR handling */
1818 removing_itself:
1819   {
1820     GST_OBJECT_LOCK (bin);
1821     g_warning (&quot;Cannot remove bin &#39;%s&#39; from itself&quot;, GST_ELEMENT_NAME (bin));
1822     GST_OBJECT_UNLOCK (bin);
1823     return FALSE;
1824   }
1825 not_in_bin:
1826   {
1827     g_warning (&quot;Element &#39;%s&#39; is not in bin &#39;%s&#39;&quot;, elem_name,
1828         GST_ELEMENT_NAME (bin));
1829     GST_OBJECT_UNLOCK (element);
1830     GST_OBJECT_UNLOCK (bin);
1831     g_free (elem_name);
1832     return FALSE;
1833   }
1834 }
1835 
1836 /**
1837  * gst_bin_remove:
1838  * @bin: a #GstBin
1839  * @element: (transfer none): the #GstElement to remove
1840  *
1841  * Removes the element from the bin, unparenting it as well.
1842  * Unparenting the element means that the element will be dereferenced,
1843  * so if the bin holds the only reference to the element, the element
1844  * will be freed in the process of removing it from the bin.  If you
1845  * want the element to still exist after removing, you need to call
1846  * gst_object_ref() before removing it from the bin.
1847  *
1848  * If the element&#39;s pads are linked to other pads, the pads will be unlinked
1849  * before the element is removed from the bin.
1850  *
1851  * MT safe.
1852  *
1853  * Returns: %TRUE if the element could be removed, %FALSE if
1854  * the bin does not want to remove the element.
1855  */
1856 gboolean
1857 gst_bin_remove (GstBin * bin, GstElement * element)
1858 {
1859   GstBinClass *bclass;
1860   gboolean result;
1861 
1862   g_return_val_if_fail (GST_IS_BIN (bin), FALSE);
1863   g_return_val_if_fail (GST_IS_ELEMENT (element), FALSE);
1864   g_return_val_if_fail (GST_ELEMENT_CAST (bin) != element, FALSE);
1865 
1866   bclass = GST_BIN_GET_CLASS (bin);
1867 
1868   if (G_UNLIKELY (bclass-&gt;remove_element == NULL))
1869     goto no_function;
1870 
1871   GST_CAT_DEBUG (GST_CAT_PARENTAGE, &quot;removing element %s from bin %s&quot;,
1872       GST_ELEMENT_NAME (element), GST_ELEMENT_NAME (bin));
1873 
1874   GST_TRACER_BIN_REMOVE_PRE (bin, element);
1875   result = bclass-&gt;remove_element (bin, element);
1876   GST_TRACER_BIN_REMOVE_POST (bin, result);
1877 
1878   return result;
1879 
1880   /* ERROR handling */
1881 no_function:
1882   {
1883     g_warning (&quot;removing elements from bin &#39;%s&#39; is not supported&quot;,
1884         GST_ELEMENT_NAME (bin));
1885     return FALSE;
1886   }
1887 }
1888 
1889 /**
1890  * gst_bin_iterate_elements:
1891  * @bin: a #GstBin
1892  *
1893  * Gets an iterator for the elements in this bin.
1894  *
1895  * MT safe.  Caller owns returned value.
1896  *
1897  * Returns: (transfer full) (nullable): a #GstIterator of #GstElement,
1898  * or %NULL
1899  */
1900 GstIterator *
1901 gst_bin_iterate_elements (GstBin * bin)
1902 {
1903   GstIterator *result;
1904 
1905   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
1906 
1907   GST_OBJECT_LOCK (bin);
1908   result = gst_iterator_new_list (GST_TYPE_ELEMENT,
1909       GST_OBJECT_GET_LOCK (bin),
1910       &amp;bin-&gt;children_cookie, &amp;bin-&gt;children, (GObject *) bin, NULL);
1911   GST_OBJECT_UNLOCK (bin);
1912 
1913   return result;
1914 }
1915 
1916 static GstIteratorItem
1917 iterate_child_recurse (GstIterator * it, const GValue * item)
1918 {
1919   GstElement *child = g_value_get_object (item);
1920 
1921   if (GST_IS_BIN (child)) {
1922     GstIterator *other = gst_bin_iterate_recurse (GST_BIN_CAST (child));
1923 
1924     gst_iterator_push (it, other);
1925   }
1926   return GST_ITERATOR_ITEM_PASS;
1927 }
1928 
1929 /**
1930  * gst_bin_iterate_recurse:
1931  * @bin: a #GstBin
1932  *
1933  * Gets an iterator for the elements in this bin.
1934  * This iterator recurses into GstBin children.
1935  *
1936  * MT safe.  Caller owns returned value.
1937  *
1938  * Returns: (transfer full) (nullable): a #GstIterator of #GstElement,
1939  * or %NULL
1940  */
1941 GstIterator *
1942 gst_bin_iterate_recurse (GstBin * bin)
1943 {
1944   GstIterator *result;
1945 
1946   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
1947 
1948   GST_OBJECT_LOCK (bin);
1949   result = gst_iterator_new_list (GST_TYPE_ELEMENT,
1950       GST_OBJECT_GET_LOCK (bin),
1951       &amp;bin-&gt;children_cookie,
1952       &amp;bin-&gt;children,
1953       (GObject *) bin, (GstIteratorItemFunction) iterate_child_recurse);
1954   GST_OBJECT_UNLOCK (bin);
1955 
1956   return result;
1957 }
1958 
1959 /* returns 0 when TRUE because this is a GCompareFunc */
1960 /* MT safe */
1961 static gint
1962 bin_element_is_sink (GstElement * child, GstBin * bin)
1963 {
1964   gboolean is_sink;
1965 
1966 #ifdef GSTREAMER_LITE
1967   if (child == NULL)
1968       return 1;
1969 #endif // GSTREAMER_LITE
1970 
1971   /* we lock the child here for the remainder of the function to
1972    * get its name and flag safely. */
1973   GST_OBJECT_LOCK (child);
1974   is_sink = GST_OBJECT_FLAG_IS_SET (child, GST_ELEMENT_FLAG_SINK);
1975 
1976   GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin,
1977       &quot;child %s %s sink&quot;, GST_OBJECT_NAME (child), is_sink ? &quot;is&quot; : &quot;is not&quot;);
1978 
1979   GST_OBJECT_UNLOCK (child);
1980   return is_sink ? 0 : 1;
1981 }
1982 
1983 static gint
1984 sink_iterator_filter (const GValue * vchild, GValue * vbin)
1985 {
1986   GstBin *bin = g_value_get_object (vbin);
1987   GstElement *child = g_value_get_object (vchild);
1988 
1989   return (bin_element_is_sink (child, bin));
1990 }
1991 
1992 /**
1993  * gst_bin_iterate_sinks:
1994  * @bin: a #GstBin
1995  *
1996  * Gets an iterator for all elements in the bin that have the
1997  * #GST_ELEMENT_FLAG_SINK flag set.
1998  *
1999  * MT safe.  Caller owns returned value.
2000  *
2001  * Returns: (transfer full) (nullable): a #GstIterator of #GstElement,
2002  * or %NULL
2003  */
2004 GstIterator *
2005 gst_bin_iterate_sinks (GstBin * bin)
2006 {
2007   GstIterator *children;
2008   GstIterator *result;
2009   GValue vbin = { 0, };
2010 
2011   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
2012 
2013   g_value_init (&amp;vbin, GST_TYPE_BIN);
2014   g_value_set_object (&amp;vbin, bin);
2015 
2016   children = gst_bin_iterate_elements (bin);
2017   result = gst_iterator_filter (children,
2018       (GCompareFunc) sink_iterator_filter, &amp;vbin);
2019 
2020   g_value_unset (&amp;vbin);
2021 
2022   return result;
2023 }
2024 
2025 /* returns 0 when TRUE because this is a GCompareFunc */
2026 /* MT safe */
2027 static gint
2028 bin_element_is_src (GstElement * child, GstBin * bin)
2029 {
2030   gboolean is_src;
2031 
2032   /* we lock the child here for the remainder of the function to
2033    * get its name and other info safely. */
2034   GST_OBJECT_LOCK (child);
2035   is_src = GST_OBJECT_FLAG_IS_SET (child, GST_ELEMENT_FLAG_SOURCE);
2036 
2037   GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin,
2038       &quot;child %s %s src&quot;, GST_OBJECT_NAME (child), is_src ? &quot;is&quot; : &quot;is not&quot;);
2039 
2040   GST_OBJECT_UNLOCK (child);
2041   return is_src ? 0 : 1;
2042 }
2043 
2044 static gint
2045 src_iterator_filter (const GValue * vchild, GValue * vbin)
2046 {
2047   GstBin *bin = g_value_get_object (vbin);
2048   GstElement *child = g_value_get_object (vchild);
2049 
2050   return (bin_element_is_src (child, bin));
2051 }
2052 
2053 /**
2054  * gst_bin_iterate_sources:
2055  * @bin: a #GstBin
2056  *
2057  * Gets an iterator for all elements in the bin that have the
2058  * #GST_ELEMENT_FLAG_SOURCE flag set.
2059  *
2060  * MT safe.  Caller owns returned value.
2061  *
2062  * Returns: (transfer full) (nullable): a #GstIterator of #GstElement,
2063  * or %NULL
2064  */
2065 GstIterator *
2066 gst_bin_iterate_sources (GstBin * bin)
2067 {
2068   GstIterator *children;
2069   GstIterator *result;
2070   GValue vbin = { 0, };
2071 
2072   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
2073 
2074   g_value_init (&amp;vbin, GST_TYPE_BIN);
2075   g_value_set_object (&amp;vbin, bin);
2076 
2077   children = gst_bin_iterate_elements (bin);
2078   result = gst_iterator_filter (children,
2079       (GCompareFunc) src_iterator_filter, &amp;vbin);
2080 
2081   g_value_unset (&amp;vbin);
2082 
2083   return result;
2084 }
2085 
2086 /*
2087  * MT safe
2088  */
2089 static GstStateChangeReturn
2090 gst_bin_get_state_func (GstElement * element, GstState * state,
2091     GstState * pending, GstClockTime timeout)
2092 {
2093   GstStateChangeReturn ret;
2094 
2095   GST_CAT_INFO_OBJECT (GST_CAT_STATES, element, &quot;getting state&quot;);
2096 
2097   ret =
2098       GST_ELEMENT_CLASS (parent_class)-&gt;get_state (element, state, pending,
2099       timeout);
2100 
2101   return ret;
2102 }
2103 
2104 /***********************************************
2105  * Topologically sorted iterator
2106  * see http://en.wikipedia.org/wiki/Topological_sorting
2107  *
2108  * For each element in the graph, an entry is kept in a HashTable
2109  * with its number of srcpad connections (degree).
2110  * We then change state of all elements without dependencies
2111  * (degree 0) and decrement the degree of all elements connected
2112  * on the sinkpads. When an element reaches degree 0, its state is
2113  * changed next.
2114  * When all elements are handled the algorithm stops.
2115  */
2116 typedef struct _GstBinSortIterator
2117 {
2118   GstIterator it;
2119   GQueue queue;                 /* elements queued for state change */
2120   GstBin *bin;                  /* bin we iterate */
2121   gint mode;                    /* adding or removing dependency */
2122   GstElement *best;             /* next element with least dependencies */
2123   gint best_deg;                /* best degree */
2124   GHashTable *hash;             /* hashtable with element dependencies */
2125   gboolean dirty;               /* we detected structure change */
2126 } GstBinSortIterator;
2127 
2128 static void
2129 copy_to_queue (gpointer data, gpointer user_data)
2130 {
2131   GstElement *element = data;
2132   GQueue *queue = user_data;
2133 
2134   gst_object_ref (element);
2135   g_queue_push_tail (queue, element);
2136 }
2137 
2138 static void
2139 gst_bin_sort_iterator_copy (const GstBinSortIterator * it,
2140     GstBinSortIterator * copy)
2141 {
2142   GHashTableIter iter;
2143   gpointer key, value;
2144 
2145   g_queue_init (&amp;copy-&gt;queue);
2146   g_queue_foreach ((GQueue *) &amp; it-&gt;queue, copy_to_queue, &amp;copy-&gt;queue);
2147 
2148   copy-&gt;bin = gst_object_ref (it-&gt;bin);
2149   if (it-&gt;best)
2150     copy-&gt;best = gst_object_ref (it-&gt;best);
2151 
2152   copy-&gt;hash = g_hash_table_new (NULL, NULL);
2153   g_hash_table_iter_init (&amp;iter, it-&gt;hash);
2154   while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
2155     g_hash_table_insert (copy-&gt;hash, key, value);
2156 }
2157 
2158 /* we add and subtract 1 to make sure we don&#39;t confuse NULL and 0 */
2159 #define HASH_SET_DEGREE(bit, elem, deg) \
2160     g_hash_table_replace (bit-&gt;hash, elem, GINT_TO_POINTER(deg+1))
2161 #define HASH_GET_DEGREE(bit, elem) \
2162     (GPOINTER_TO_INT(g_hash_table_lookup (bit-&gt;hash, elem))-1)
2163 
2164 /* add element to queue of next elements in the iterator.
2165  * We push at the tail to give higher priority elements a
2166  * chance first */
2167 static void
2168 add_to_queue (GstBinSortIterator * bit, GstElement * element)
2169 {
2170   GST_DEBUG_OBJECT (bit-&gt;bin, &quot;adding &#39;%s&#39; to queue&quot;,
2171       GST_ELEMENT_NAME (element));
2172   gst_object_ref (element);
2173   g_queue_push_tail (&amp;bit-&gt;queue, element);
2174   HASH_SET_DEGREE (bit, element, -1);
2175 }
2176 
2177 static void
2178 remove_from_queue (GstBinSortIterator * bit, GstElement * element)
2179 {
2180   GList *find;
2181 
2182   if ((find = g_queue_find (&amp;bit-&gt;queue, element))) {
2183     GST_DEBUG_OBJECT (bit-&gt;bin, &quot;removing &#39;%s&#39; from queue&quot;,
2184         GST_ELEMENT_NAME (element));
2185 
2186     g_queue_delete_link (&amp;bit-&gt;queue, find);
2187     gst_object_unref (element);
2188   } else {
2189     GST_DEBUG_OBJECT (bit-&gt;bin, &quot;unable to remove &#39;%s&#39; from queue&quot;,
2190         GST_ELEMENT_NAME (element));
2191   }
2192 }
2193 
2194 /* clear the queue, unref all objects as we took a ref when
2195  * we added them to the queue */
2196 static void
2197 clear_queue (GQueue * queue)
2198 {
2199   gpointer p;
2200 
2201   while ((p = g_queue_pop_head (queue)))
2202     gst_object_unref (p);
2203 }
2204 
2205 /* set all degrees to 0. Elements marked as a sink are
2206  * added to the queue immediately. Since we only look at the SINK flag of the
2207  * element, it is possible that we add non-sinks to the queue. These will be
2208  * removed from the queue again when we can prove that it provides data for some
2209  * other element. */
2210 static void
2211 reset_degree (GstElement * element, GstBinSortIterator * bit)
2212 {
2213   gboolean is_sink;
2214 
2215   /* sinks are added right away */
2216   GST_OBJECT_LOCK (element);
2217   is_sink = GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_SINK);
2218   GST_OBJECT_UNLOCK (element);
2219 
2220   if (is_sink) {
2221     add_to_queue (bit, element);
2222   } else {
2223     /* others are marked with 0 and handled when sinks are done */
2224     HASH_SET_DEGREE (bit, element, 0);
2225   }
2226 }
2227 
2228 /* adjust the degree of all elements connected to the given
2229  * element. If a degree of an element drops to 0, it is
2230  * added to the queue of elements to schedule next.
2231  *
2232  * We have to make sure not to cross the bin boundary this element
2233  * belongs to.
2234  */
2235 static void
2236 update_degree (GstElement * element, GstBinSortIterator * bit)
2237 {
2238   gboolean linked = FALSE;
2239 
2240   GST_OBJECT_LOCK (element);
2241   /* don&#39;t touch degree if element has no sinkpads */
2242   if (element-&gt;numsinkpads != 0) {
2243     /* loop over all sinkpads, decrement degree for all connected
2244      * elements in this bin */
2245     GList *pads;
2246 
2247     for (pads = element-&gt;sinkpads; pads; pads = g_list_next (pads)) {
2248       GstPad *pad, *peer;
2249 
2250       pad = GST_PAD_CAST (pads-&gt;data);
2251 
2252       /* we&#39;re iterating over the sinkpads, check if it&#39;s busy in a link/unlink */
2253       if (G_UNLIKELY (find_message (bit-&gt;bin, GST_OBJECT_CAST (pad),
2254                   GST_MESSAGE_STRUCTURE_CHANGE))) {
2255         /* mark the iterator as dirty because we won&#39;t be updating the degree
2256          * of the peer parent now. This would result in the &#39;loop detected&#39;
2257          * later on because the peer parent element could become the best next
2258          * element with a degree &gt; 0. We will simply continue our state
2259          * changes and we&#39;ll eventually resync when the unlink completed and
2260          * the iterator cookie is updated. */
2261         bit-&gt;dirty = TRUE;
2262         continue;
2263       }
2264 
2265       if ((peer = gst_pad_get_peer (pad))) {
2266         GstElement *peer_element;
2267 
2268         if ((peer_element = gst_pad_get_parent_element (peer))) {
2269           GST_OBJECT_LOCK (peer_element);
2270           /* check that we don&#39;t go outside of this bin */
2271           if (GST_OBJECT_CAST (peer_element)-&gt;parent ==
2272               GST_OBJECT_CAST (bit-&gt;bin)) {
2273             gint old_deg, new_deg;
2274 
2275             old_deg = HASH_GET_DEGREE (bit, peer_element);
2276 
2277             /* check to see if we added an element as sink that was not really a
2278              * sink because it was connected to some other element. */
2279             if (old_deg == -1) {
2280               remove_from_queue (bit, peer_element);
2281               old_deg = 0;
2282             }
2283             new_deg = old_deg + bit-&gt;mode;
2284 
2285             GST_DEBUG_OBJECT (bit-&gt;bin,
2286                 &quot;change element %s, degree %d-&gt;%d, linked to %s&quot;,
2287                 GST_ELEMENT_NAME (peer_element), old_deg, new_deg,
2288                 GST_ELEMENT_NAME (element));
2289 
2290             /* update degree, it is possible that an element was in 0 and
2291              * reaches -1 here. This would mean that the element had no sinkpads
2292              * but became linked while the state change was happening. We will
2293              * resync on this with the structure change message. */
2294             if (new_deg == 0) {
2295               /* degree hit 0, add to queue */
2296               add_to_queue (bit, peer_element);
2297             } else {
2298               HASH_SET_DEGREE (bit, peer_element, new_deg);
2299             }
2300             linked = TRUE;
2301           }
2302           GST_OBJECT_UNLOCK (peer_element);
2303           gst_object_unref (peer_element);
2304         }
2305         gst_object_unref (peer);
2306       }
2307     }
2308   }
2309   if (!linked) {
2310     GST_DEBUG_OBJECT (bit-&gt;bin, &quot;element %s not linked on any sinkpads&quot;,
2311         GST_ELEMENT_NAME (element));
2312   }
2313   GST_OBJECT_UNLOCK (element);
2314 }
2315 
2316 /* find the next best element not handled yet. This is the one
2317  * with the lowest non-negative degree */
2318 static void
2319 find_element (GstElement * element, GstBinSortIterator * bit)
2320 {
2321   gint degree;
2322 
2323   /* element is already handled */
2324   if ((degree = HASH_GET_DEGREE (bit, element)) &lt; 0)
2325     return;
2326 
2327   /* first element or element with smaller degree */
2328   if (bit-&gt;best == NULL || bit-&gt;best_deg &gt; degree) {
2329     bit-&gt;best = element;
2330     bit-&gt;best_deg = degree;
2331   } else if (bit-&gt;best_deg == degree
2332       &amp;&amp; GST_OBJECT_FLAG_IS_SET (bit-&gt;best, GST_ELEMENT_FLAG_SOURCE)
2333       &amp;&amp; !GST_OBJECT_FLAG_IS_SET (element, GST_ELEMENT_FLAG_SOURCE)) {
2334     /* If two elements have the same degree, we want to ensure we
2335      * return non-source elements first. */
2336     bit-&gt;best = element;
2337   }
2338 }
2339 
2340 /* get next element in iterator. */
2341 static GstIteratorResult
2342 gst_bin_sort_iterator_next (GstBinSortIterator * bit, GValue * result)
2343 {
2344   GstElement *best;
2345   GstBin *bin = bit-&gt;bin;
2346 
2347   /* empty queue, we have to find a next best element */
2348   if (g_queue_is_empty (&amp;bit-&gt;queue)) {
2349     bit-&gt;best = NULL;
2350     bit-&gt;best_deg = G_MAXINT;
2351     g_list_foreach (bin-&gt;children, (GFunc) find_element, bit);
2352     if ((best = bit-&gt;best)) {
2353       /* when we detected an unlink, don&#39;t warn because our degrees might be
2354        * screwed up. We will resync later */
2355       if (bit-&gt;best_deg != 0 &amp;&amp; !bit-&gt;dirty) {
2356         /* we don&#39;t fail on this one yet */
2357         GST_WARNING_OBJECT (bin, &quot;loop dected in graph&quot;);
2358         g_warning (&quot;loop detected in the graph of bin &#39;%s&#39;!!&quot;,
2359             GST_ELEMENT_NAME (bin));
2360       }
2361       /* best unhandled element, schedule as next element */
2362       GST_DEBUG_OBJECT (bin, &quot;queue empty, next best: %s&quot;,
2363           GST_ELEMENT_NAME (best));
2364       HASH_SET_DEGREE (bit, best, -1);
2365       g_value_set_object (result, best);
2366     } else {
2367       GST_DEBUG_OBJECT (bin, &quot;queue empty, elements exhausted&quot;);
2368       /* no more unhandled elements, we are done */
2369       return GST_ITERATOR_DONE;
2370     }
2371   } else {
2372     /* everything added to the queue got reffed */
2373     best = g_queue_pop_head (&amp;bit-&gt;queue);
2374     g_value_set_object (result, best);
2375     gst_object_unref (best);
2376   }
2377 
2378   GST_DEBUG_OBJECT (bin, &quot;queue head gives %s&quot;, GST_ELEMENT_NAME (best));
2379   /* update degrees of linked elements */
2380   update_degree (best, bit);
2381 
2382   return GST_ITERATOR_OK;
2383 }
2384 
2385 /* clear queues, recalculate the degrees and restart. */
2386 static void
2387 gst_bin_sort_iterator_resync (GstBinSortIterator * bit)
2388 {
2389   GstBin *bin = bit-&gt;bin;
2390 
2391   GST_DEBUG_OBJECT (bin, &quot;resync&quot;);
2392   bit-&gt;dirty = FALSE;
2393   clear_queue (&amp;bit-&gt;queue);
2394   /* reset degrees */
2395   g_list_foreach (bin-&gt;children, (GFunc) reset_degree, bit);
2396   /* calc degrees, incrementing */
2397   bit-&gt;mode = 1;
2398   g_list_foreach (bin-&gt;children, (GFunc) update_degree, bit);
2399   /* for the rest of the function we decrement the degrees */
2400   bit-&gt;mode = -1;
2401 }
2402 
2403 /* clear queues, unref bin and free iterator. */
2404 static void
2405 gst_bin_sort_iterator_free (GstBinSortIterator * bit)
2406 {
2407   GstBin *bin = bit-&gt;bin;
2408 
2409   GST_DEBUG_OBJECT (bin, &quot;free&quot;);
2410   clear_queue (&amp;bit-&gt;queue);
2411   g_hash_table_destroy (bit-&gt;hash);
2412   gst_object_unref (bin);
2413 }
2414 
2415 /* should be called with the bin LOCK held */
2416 static GstIterator *
2417 gst_bin_sort_iterator_new (GstBin * bin)
2418 {
2419   GstBinSortIterator *result;
2420 
2421   /* we don&#39;t need an ItemFunction because we ref the items in the _next
2422    * method already */
2423   result = (GstBinSortIterator *)
2424       gst_iterator_new (sizeof (GstBinSortIterator),
2425       GST_TYPE_ELEMENT,
2426       GST_OBJECT_GET_LOCK (bin),
2427       &amp;bin-&gt;priv-&gt;structure_cookie,
2428       (GstIteratorCopyFunction) gst_bin_sort_iterator_copy,
2429       (GstIteratorNextFunction) gst_bin_sort_iterator_next,
2430       (GstIteratorItemFunction) NULL,
2431       (GstIteratorResyncFunction) gst_bin_sort_iterator_resync,
2432       (GstIteratorFreeFunction) gst_bin_sort_iterator_free);
2433   g_queue_init (&amp;result-&gt;queue);
2434   result-&gt;hash = g_hash_table_new (NULL, NULL);
2435   gst_object_ref (bin);
2436   result-&gt;bin = bin;
2437   gst_bin_sort_iterator_resync (result);
2438 
2439   return (GstIterator *) result;
2440 }
2441 
2442 /**
2443  * gst_bin_iterate_sorted:
2444  * @bin: a #GstBin
2445  *
2446  * Gets an iterator for the elements in this bin in topologically
2447  * sorted order. This means that the elements are returned from
2448  * the most downstream elements (sinks) to the sources.
2449  *
2450  * This function is used internally to perform the state changes
2451  * of the bin elements and for clock selection.
2452  *
2453  * MT safe.  Caller owns returned value.
2454  *
2455  * Returns: (transfer full) (nullable): a #GstIterator of #GstElement,
2456  * or %NULL
2457  */
2458 GstIterator *
2459 gst_bin_iterate_sorted (GstBin * bin)
2460 {
2461   GstIterator *result;
2462 
2463   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
2464 
2465   GST_OBJECT_LOCK (bin);
2466   result = gst_bin_sort_iterator_new (bin);
2467   GST_OBJECT_UNLOCK (bin);
2468 
2469   return result;
2470 }
2471 
2472 static GstStateChangeReturn
2473 gst_bin_element_set_state (GstBin * bin, GstElement * element,
2474     GstClockTime base_time, GstClockTime start_time, GstState current,
2475     GstState next)
2476 {
2477   GstStateChangeReturn ret;
2478   GstState child_current, child_pending;
2479   gboolean locked;
2480   GList *found;
2481 
2482   GST_STATE_LOCK (element);
2483 
2484   GST_OBJECT_LOCK (element);
2485   /* set base_time and start time on child */
2486   GST_ELEMENT_START_TIME (element) = start_time;
2487   element-&gt;base_time = base_time;
2488   /* peel off the locked flag */
2489   locked = GST_ELEMENT_IS_LOCKED_STATE (element);
2490   /* Get the previous set_state result to preserve NO_PREROLL and ASYNC */
2491   ret = GST_STATE_RETURN (element);
2492   child_current = GST_STATE (element);
2493   child_pending = GST_STATE_PENDING (element);
2494   GST_OBJECT_UNLOCK (element);
2495 
2496   /* skip locked elements */
2497   if (G_UNLIKELY (locked))
2498     goto locked;
2499 
2500   /* if the element was no preroll, just start changing the state regardless
2501    * if it had async elements (in the case of a bin) because they won&#39;t preroll
2502    * anyway. */
2503   if (G_UNLIKELY (ret == GST_STATE_CHANGE_NO_PREROLL)) {
2504     GST_DEBUG_OBJECT (element, &quot;element is NO_PREROLL, ignore async elements&quot;);
2505     goto no_preroll;
2506   }
2507 
2508   GST_CAT_INFO_OBJECT (GST_CAT_STATES, element,
2509       &quot;current %s pending %s, desired next %s&quot;,
2510       gst_element_state_get_name (child_current),
2511       gst_element_state_get_name (child_pending),
2512       gst_element_state_get_name (next));
2513 
2514   /* always recurse into bins so that we can set the base time */
2515   if (GST_IS_BIN (element))
2516     goto do_state;
2517 
2518   /* Try not to change the state of elements that are already in the state we&#39;re
2519    * going to */
2520   if (child_current == next &amp;&amp; child_pending == GST_STATE_VOID_PENDING) {
2521     /* child is already at the requested state, return previous return. Note that
2522      * if the child has a pending state to next, we will still call the
2523      * set_state function */
2524     goto unneeded;
2525   } else if (next &gt; current) {
2526     /* upward state change */
2527     if (child_pending == GST_STATE_VOID_PENDING) {
2528       /* .. and the child is not busy doing anything */
2529       if (child_current &gt; next) {
2530         /* .. and is already past the requested state, assume it got there
2531          * without error */
2532         ret = GST_STATE_CHANGE_SUCCESS;
2533         goto unneeded;
2534       }
2535     } else if (child_pending &gt; child_current) {
2536       /* .. and the child is busy going upwards */
2537       if (child_current &gt;= next) {
2538         /* .. and is already past the requested state, assume it got there
2539          * without error */
2540         ret = GST_STATE_CHANGE_SUCCESS;
2541         goto unneeded;
2542       }
2543     } else {
2544       /* .. and the child is busy going downwards */
2545       if (child_current &gt; next) {
2546         /* .. and is already past the requested state, assume it got there
2547          * without error */
2548         ret = GST_STATE_CHANGE_SUCCESS;
2549         goto unneeded;
2550       }
2551     }
2552   } else if (next &lt; current) {
2553     /* downward state change */
2554     if (child_pending == GST_STATE_VOID_PENDING) {
2555       /* .. and the child is not busy doing anything */
2556       if (child_current &lt; next) {
2557         /* .. and is already past the requested state, assume it got there
2558          * without error */
2559         ret = GST_STATE_CHANGE_SUCCESS;
2560         goto unneeded;
2561       }
2562     } else if (child_pending &lt; child_current) {
2563       /* .. and the child is busy going downwards */
2564       if (child_current &lt;= next) {
2565         /* .. and is already past the requested state, assume it got there
2566          * without error */
2567         ret = GST_STATE_CHANGE_SUCCESS;
2568         goto unneeded;
2569       }
2570     } else {
2571       /* .. and the child is busy going upwards */
2572       if (child_current &lt; next) {
2573         /* .. and is already past the requested state, assume it got there
2574          * without error */
2575         ret = GST_STATE_CHANGE_SUCCESS;
2576         goto unneeded;
2577       }
2578     }
2579   }
2580 
2581 do_state:
2582   GST_OBJECT_LOCK (bin);
2583   /* the element was busy with an upwards async state change, we must wait for
<a name="7" id="anc7"></a><span class="line-modified">2584    * an ASYNC_DONE message before we attempt to change the state. */</span>
2585   if ((found =
2586           find_message (bin, GST_OBJECT_CAST (element),
2587               GST_MESSAGE_ASYNC_START))) {
2588 #ifndef GST_DISABLE_GST_DEBUG
2589     GstMessage *message = GST_MESSAGE_CAST (found-&gt;data);
2590 
2591     GST_DEBUG_OBJECT (element, &quot;element message %p, %s async busy&quot;,
2592         message, GST_ELEMENT_NAME (GST_MESSAGE_SRC (message)));
2593 #endif
2594     /* only wait for upward state changes */
2595     if (next &gt; current) {
2596       /* We found an async element check if we can force its state to change or
2597        * if we have to wait for it to preroll. */
2598       goto was_busy;
2599     }
2600   }
2601   GST_OBJECT_UNLOCK (bin);
2602 
2603 no_preroll:
2604   GST_DEBUG_OBJECT (bin,
2605       &quot;setting element %s to %s, base_time %&quot; GST_TIME_FORMAT,
2606       GST_ELEMENT_NAME (element), gst_element_state_get_name (next),
2607       GST_TIME_ARGS (base_time));
2608 
2609   /* change state */
2610   ret = gst_element_set_state (element, next);
2611 
2612   GST_STATE_UNLOCK (element);
2613 
2614   return ret;
2615 
2616 locked:
2617   {
2618     GST_DEBUG_OBJECT (element,
2619         &quot;element is locked, return previous return %s&quot;,
2620         gst_element_state_change_return_get_name (ret));
2621     GST_STATE_UNLOCK (element);
2622     return ret;
2623   }
2624 unneeded:
2625   {
2626     GST_CAT_INFO_OBJECT (GST_CAT_STATES, element,
2627         &quot;skipping transition from %s to  %s&quot;,
2628         gst_element_state_get_name (child_current),
2629         gst_element_state_get_name (next));
2630     GST_STATE_UNLOCK (element);
2631     return ret;
2632   }
2633 was_busy:
2634   {
2635     GST_DEBUG_OBJECT (element, &quot;element was busy, delaying state change&quot;);
2636     GST_OBJECT_UNLOCK (bin);
2637     GST_STATE_UNLOCK (element);
2638     return GST_STATE_CHANGE_ASYNC;
2639   }
2640 }
2641 
2642 /* gst_iterator_fold functions for pads_activate
2643  * Stop the iterator if activating one pad failed, but only if that pad
2644  * has not been removed from the element. */
2645 static gboolean
2646 activate_pads (const GValue * vpad, GValue * ret, gboolean * active)
2647 {
2648   GstPad *pad = g_value_get_object (vpad);
2649   gboolean cont = TRUE;
2650 
2651   if (!gst_pad_set_active (pad, *active)) {
2652     if (GST_PAD_PARENT (pad) != NULL) {
2653       cont = FALSE;
<a name="8" id="anc8"></a><span class="line-modified">2654       g_value_set_boolean (ret, FALSE);</span>
2655     }
2656   }
2657 
2658   return cont;
2659 }
2660 
2661 /* returns false on error or early cutout of the fold, true if all
2662  * pads in @iter were (de)activated successfully. */
2663 static gboolean
2664 iterator_activate_fold_with_resync (GstIterator * iter, gpointer user_data)
2665 {
2666   GstIteratorResult ires;
2667   GValue ret = { 0 };
2668 
2669   /* no need to unset this later, it&#39;s just a boolean */
2670   g_value_init (&amp;ret, G_TYPE_BOOLEAN);
2671   g_value_set_boolean (&amp;ret, TRUE);
2672 
2673   while (1) {
2674     ires = gst_iterator_fold (iter, (GstIteratorFoldFunction) activate_pads,
2675         &amp;ret, user_data);
2676     switch (ires) {
2677       case GST_ITERATOR_RESYNC:
2678         /* need to reset the result again */
2679         g_value_set_boolean (&amp;ret, TRUE);
2680         gst_iterator_resync (iter);
2681         break;
2682       case GST_ITERATOR_DONE:
2683         /* all pads iterated, return collected value */
2684         goto done;
2685       default:
2686         /* iterator returned _ERROR or premature end with _OK,
2687          * mark an error and exit */
2688         g_value_set_boolean (&amp;ret, FALSE);
2689         goto done;
2690     }
2691   }
2692 done:
2693   /* return collected value */
2694   return g_value_get_boolean (&amp;ret);
2695 }
2696 
2697 /* is called with STATE_LOCK
2698  */
2699 static gboolean
2700 gst_bin_src_pads_activate (GstBin * bin, gboolean active)
2701 {
2702   GstIterator *iter;
2703   gboolean fold_ok;
2704 
2705   GST_DEBUG_OBJECT (bin, &quot;%s pads&quot;, active ? &quot;activate&quot; : &quot;deactivate&quot;);
2706 
2707   iter = gst_element_iterate_src_pads ((GstElement *) bin);
2708   fold_ok = iterator_activate_fold_with_resync (iter, &amp;active);
2709   gst_iterator_free (iter);
2710   if (G_UNLIKELY (!fold_ok))
2711     goto failed;
2712 
2713   GST_DEBUG_OBJECT (bin, &quot;pad %sactivation successful&quot;, active ? &quot;&quot; : &quot;de&quot;);
2714 
2715   return TRUE;
2716 
2717   /* ERRORS */
2718 failed:
2719   {
2720     GST_DEBUG_OBJECT (bin, &quot;pad %sactivation failed&quot;, active ? &quot;&quot; : &quot;de&quot;);
2721     return FALSE;
2722   }
2723 }
2724 
2725 /**
2726  * gst_bin_recalculate_latency:
2727  * @bin: a #GstBin
2728  *
2729  * Query @bin for the current latency using and reconfigures this latency to all the
2730  * elements with a LATENCY event.
2731  *
2732  * This method is typically called on the pipeline when a #GST_MESSAGE_LATENCY
2733  * is posted on the bus.
2734  *
2735  * This function simply emits the &#39;do-latency&#39; signal so any custom latency
2736  * calculations will be performed.
2737  *
2738  * Returns: %TRUE if the latency could be queried and reconfigured.
2739  */
2740 gboolean
2741 gst_bin_recalculate_latency (GstBin * bin)
2742 {
2743   gboolean res;
2744 
2745   g_signal_emit (bin, gst_bin_signals[DO_LATENCY], 0, &amp;res);
2746   GST_DEBUG_OBJECT (bin, &quot;latency returned %d&quot;, res);
2747 
2748   return res;
2749 }
2750 
2751 static gboolean
2752 gst_bin_do_latency_func (GstBin * bin)
2753 {
2754   GstQuery *query;
2755   GstElement *element;
2756   GstClockTime min_latency, max_latency;
2757   gboolean res;
2758 
2759   g_return_val_if_fail (GST_IS_BIN (bin), FALSE);
2760 
2761   element = GST_ELEMENT_CAST (bin);
2762 
2763   GST_DEBUG_OBJECT (element, &quot;querying latency&quot;);
2764 
2765   query = gst_query_new_latency ();
2766   if ((res = gst_element_query (element, query))) {
2767     gboolean live;
2768 
2769     gst_query_parse_latency (query, &amp;live, &amp;min_latency, &amp;max_latency);
2770 
2771     GST_DEBUG_OBJECT (element,
2772         &quot;got min latency %&quot; GST_TIME_FORMAT &quot;, max latency %&quot;
2773         GST_TIME_FORMAT &quot;, live %d&quot;, GST_TIME_ARGS (min_latency),
2774         GST_TIME_ARGS (max_latency), live);
2775 
2776     if (max_latency &lt; min_latency) {
2777       /* this is an impossible situation, some parts of the pipeline might not
2778        * work correctly. We post a warning for now. */
2779       GST_ELEMENT_WARNING (element, CORE, CLOCK, (NULL),
2780           (&quot;Impossible to configure latency: max %&quot; GST_TIME_FORMAT &quot; &lt; min %&quot;
2781               GST_TIME_FORMAT &quot;. Add queues or other buffering elements.&quot;,
2782               GST_TIME_ARGS (max_latency), GST_TIME_ARGS (min_latency)));
2783     }
2784 
2785     /* configure latency on elements */
2786     res = gst_element_send_event (element, gst_event_new_latency (min_latency));
2787     if (res) {
2788       GST_INFO_OBJECT (element, &quot;configured latency of %&quot; GST_TIME_FORMAT,
2789           GST_TIME_ARGS (min_latency));
2790     } else {
2791       GST_WARNING_OBJECT (element,
2792           &quot;did not really configure latency of %&quot; GST_TIME_FORMAT,
2793           GST_TIME_ARGS (min_latency));
2794     }
2795   } else {
2796     /* this is not a real problem, we just don&#39;t configure any latency. */
2797     GST_WARNING_OBJECT (element, &quot;failed to query latency&quot;);
2798   }
2799   gst_query_unref (query);
2800 
2801   return res;
2802 }
2803 
2804 static gboolean
2805 gst_bin_post_message (GstElement * element, GstMessage * msg)
2806 {
2807   GstElementClass *pklass = (GstElementClass *) parent_class;
2808   gboolean ret;
2809 
2810   ret = pklass-&gt;post_message (element, gst_message_ref (msg));
2811 
2812   if (GST_MESSAGE_TYPE (msg) == GST_MESSAGE_STATE_CHANGED &amp;&amp;
2813       GST_MESSAGE_SRC (msg) == GST_OBJECT_CAST (element)) {
2814     GstState newstate, pending;
2815 
2816     gst_message_parse_state_changed (msg, NULL, &amp;newstate, &amp;pending);
2817     if (newstate == GST_STATE_PLAYING &amp;&amp; pending == GST_STATE_VOID_PENDING) {
2818       GST_BIN_CAST (element)-&gt;priv-&gt;posted_playing = TRUE;
2819       bin_do_eos (GST_BIN_CAST (element));
2820     } else {
2821       GST_BIN_CAST (element)-&gt;priv-&gt;posted_playing = FALSE;
2822     }
2823   }
2824 
2825   gst_message_unref (msg);
2826 
2827   return ret;
2828 }
2829 
2830 static void
2831 reset_state (const GValue * data, gpointer user_data)
2832 {
2833   GstElement *e = g_value_get_object (data);
2834   GstState state = GPOINTER_TO_INT (user_data);
2835 
2836   if (gst_element_set_state (e, state) == GST_STATE_CHANGE_FAILURE)
2837     GST_WARNING_OBJECT (e, &quot;Failed to switch back down to %s&quot;,
2838         gst_element_state_get_name (state));
2839 }
2840 
2841 static GstStateChangeReturn
2842 gst_bin_change_state_func (GstElement * element, GstStateChange transition)
2843 {
2844   GstBin *bin;
2845   GstStateChangeReturn ret;
2846   GstState current, next;
2847   gboolean have_async;
2848   gboolean have_no_preroll;
2849   GstClockTime base_time, start_time;
2850   GstIterator *it;
2851   gboolean done;
2852   GValue data = { 0, };
2853 
2854   /* we don&#39;t need to take the STATE_LOCK, it is already taken */
2855   current = (GstState) GST_STATE_TRANSITION_CURRENT (transition);
2856   next = (GstState) GST_STATE_TRANSITION_NEXT (transition);
2857 
2858   GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element,
2859       &quot;changing state of children from %s to %s&quot;,
2860       gst_element_state_get_name (current), gst_element_state_get_name (next));
2861 
2862   bin = GST_BIN_CAST (element);
2863 
2864   switch (next) {
2865     case GST_STATE_PLAYING:
2866     {
2867       gboolean toplevel, asynchandling;
2868 
2869       GST_OBJECT_LOCK (bin);
2870       toplevel = BIN_IS_TOPLEVEL (bin);
2871       asynchandling = bin-&gt;priv-&gt;asynchandling;
2872       GST_OBJECT_UNLOCK (bin);
2873 
2874       if (toplevel)
2875         gst_bin_recalculate_latency (bin);
2876       if (asynchandling)
2877         gst_element_post_message (element,
2878             gst_message_new_latency (GST_OBJECT_CAST (element)));
2879       break;
2880     }
2881     case GST_STATE_PAUSED:
2882       /* Clear EOS list on next PAUSED */
2883       GST_OBJECT_LOCK (bin);
2884       GST_DEBUG_OBJECT (element, &quot;clearing EOS elements&quot;);
2885       bin_remove_messages (bin, NULL, GST_MESSAGE_EOS);
2886       bin-&gt;priv-&gt;posted_eos = FALSE;
2887       if (current == GST_STATE_READY)
2888         bin_remove_messages (bin, NULL, GST_MESSAGE_STREAM_START);
2889       GST_OBJECT_UNLOCK (bin);
2890       if (current == GST_STATE_READY)
2891         if (!(gst_bin_src_pads_activate (bin, TRUE)))
2892           goto activate_failure;
2893       break;
2894     case GST_STATE_READY:
2895       /* Clear message list on next READY */
2896       GST_OBJECT_LOCK (bin);
2897       GST_DEBUG_OBJECT (element, &quot;clearing all cached messages&quot;);
2898       bin_remove_messages (bin, NULL, GST_MESSAGE_ANY);
2899       GST_OBJECT_UNLOCK (bin);
2900       /* We might not have reached PAUSED yet due to async errors,
2901        * make sure to always deactivate the pads nonetheless */
2902       if (!(gst_bin_src_pads_activate (bin, FALSE)))
2903         goto activate_failure;
2904       break;
2905     case GST_STATE_NULL:
2906       /* Clear message list on next NULL */
2907       GST_OBJECT_LOCK (bin);
2908       GST_DEBUG_OBJECT (element, &quot;clearing all cached messages&quot;);
2909       bin_remove_messages (bin, NULL, GST_MESSAGE_ANY);
2910       GST_OBJECT_UNLOCK (bin);
2911       if (current == GST_STATE_READY) {
2912         if (!(gst_bin_src_pads_activate (bin, FALSE)))
2913           goto activate_failure;
<a name="9" id="anc9"></a><span class="line-modified">2914       }</span>
2915       break;
2916     default:
2917       break;
2918   }
2919 
2920   /* this flag is used to make the async state changes return immediately. We
2921    * don&#39;t want them to interfere with this state change */
2922   GST_OBJECT_LOCK (bin);
2923   bin-&gt;polling = TRUE;
2924   GST_OBJECT_UNLOCK (bin);
2925 
2926   /* iterate in state change order */
2927   it = gst_bin_iterate_sorted (bin);
2928 
2929   /* mark if we&#39;ve seen an ASYNC element in the bin when we did a state change.
2930    * Note how we don&#39;t reset this value when a resync happens, the reason being
2931    * that the async element posted ASYNC_START and we want to post ASYNC_DONE
2932    * even after a resync when the async element is gone */
2933   have_async = FALSE;
2934 
2935 restart:
2936   /* take base_time */
2937   base_time = gst_element_get_base_time (element);
2938   start_time = gst_element_get_start_time (element);
2939 
2940   have_no_preroll = FALSE;
2941 
2942   done = FALSE;
2943   while (!done) {
2944     switch (gst_iterator_next (it, &amp;data)) {
2945       case GST_ITERATOR_OK:
2946       {
2947         GstElement *child;
2948 
2949         child = g_value_get_object (&amp;data);
2950 
2951         /* set state and base_time now */
2952         ret = gst_bin_element_set_state (bin, child, base_time, start_time,
2953             current, next);
2954 
2955         switch (ret) {
2956           case GST_STATE_CHANGE_SUCCESS:
2957             GST_CAT_INFO_OBJECT (GST_CAT_STATES, element,
2958                 &quot;child &#39;%s&#39; changed state to %d(%s) successfully&quot;,
2959                 GST_ELEMENT_NAME (child), next,
2960                 gst_element_state_get_name (next));
2961             break;
2962           case GST_STATE_CHANGE_ASYNC:
2963           {
2964             GST_CAT_INFO_OBJECT (GST_CAT_STATES, element,
2965                 &quot;child &#39;%s&#39; is changing state asynchronously to %s&quot;,
2966                 GST_ELEMENT_NAME (child), gst_element_state_get_name (next));
2967             have_async = TRUE;
2968             break;
2969           }
2970           case GST_STATE_CHANGE_FAILURE:{
2971             GstObject *parent;
2972 
2973             GST_CAT_INFO_OBJECT (GST_CAT_STATES, element,
2974                 &quot;child &#39;%s&#39; failed to go to state %d(%s)&quot;,
2975                 GST_ELEMENT_NAME (child),
2976                 next, gst_element_state_get_name (next));
2977 
2978             /* Only fail if the child is still inside
2979              * this bin. It might&#39;ve been removed already
2980              * because of the error by the bin subclass
2981              * to ignore the error.  */
2982             parent = gst_object_get_parent (GST_OBJECT_CAST (child));
2983             if (parent == GST_OBJECT_CAST (element)) {
2984               /* element is still in bin, really error now */
2985               gst_object_unref (parent);
2986               goto undo;
2987             }
2988             /* child removed from bin, let the resync code redo the state
2989              * change */
2990             GST_CAT_INFO_OBJECT (GST_CAT_STATES, element,
2991                 &quot;child &#39;%s&#39; was removed from the bin&quot;,
2992                 GST_ELEMENT_NAME (child));
2993 
2994             if (parent)
2995               gst_object_unref (parent);
2996 
2997             break;
2998           }
2999           case GST_STATE_CHANGE_NO_PREROLL:
3000             GST_CAT_INFO_OBJECT (GST_CAT_STATES, element,
3001                 &quot;child &#39;%s&#39; changed state to %d(%s) successfully without preroll&quot;,
3002                 GST_ELEMENT_NAME (child), next,
3003                 gst_element_state_get_name (next));
3004             have_no_preroll = TRUE;
3005             break;
3006           default:
3007             g_assert_not_reached ();
3008             break;
3009         }
3010         g_value_reset (&amp;data);
3011         break;
3012       }
3013       case GST_ITERATOR_RESYNC:
3014         GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element, &quot;iterator doing resync&quot;);
3015         gst_iterator_resync (it);
3016         goto restart;
3017       default:
3018       case GST_ITERATOR_DONE:
3019         GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element, &quot;iterator done&quot;);
3020         done = TRUE;
3021         break;
3022     }
3023   }
3024 
3025   ret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
3026   if (G_UNLIKELY (ret == GST_STATE_CHANGE_FAILURE))
3027     goto done;
3028 
3029   if (have_no_preroll) {
3030     GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin,
3031         &quot;we have NO_PREROLL elements %s -&gt; NO_PREROLL&quot;,
3032         gst_element_state_change_return_get_name (ret));
3033     ret = GST_STATE_CHANGE_NO_PREROLL;
3034   } else if (have_async) {
3035     GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin,
3036         &quot;we have ASYNC elements %s -&gt; ASYNC&quot;,
3037         gst_element_state_change_return_get_name (ret));
3038     ret = GST_STATE_CHANGE_ASYNC;
3039   }
3040 
3041 done:
3042   g_value_unset (&amp;data);
3043   gst_iterator_free (it);
3044 
3045   GST_OBJECT_LOCK (bin);
3046   bin-&gt;polling = FALSE;
3047   /* it&#39;s possible that we did not get ASYNC from the children while the bin is
3048    * simulating ASYNC behaviour by posting an ASYNC_DONE message on the bus with
3049    * itself as the source. In that case we still want to check if the state
3050    * change completed. */
3051   if (ret != GST_STATE_CHANGE_ASYNC &amp;&amp; !bin-&gt;priv-&gt;pending_async_done) {
3052     /* no element returned ASYNC and there are no pending async_done messages,
3053      * we can just complete. */
3054     GST_DEBUG_OBJECT (bin, &quot;no async elements&quot;);
3055     goto state_end;
3056   }
3057   /* when we get here an ASYNC element was found */
3058   if (GST_STATE_TARGET (bin) &lt;= GST_STATE_READY) {
3059     /* we ignore ASYNC state changes when we go to READY or NULL */
3060     GST_DEBUG_OBJECT (bin, &quot;target state %s &lt;= READY&quot;,
3061         gst_element_state_get_name (GST_STATE_TARGET (bin)));
3062     goto state_end;
3063   }
3064 
3065   GST_DEBUG_OBJECT (bin, &quot;check async elements&quot;);
3066   /* check if all elements managed to commit their state already */
3067   if (!find_message (bin, NULL, GST_MESSAGE_ASYNC_START)) {
3068     /* nothing found, remove all old ASYNC_DONE messages. This can happen when
<a name="10" id="anc10"></a><span class="line-modified">3069      * all the elements committed their state while we were doing the state</span>
3070      * change. We will still return ASYNC for consistency but we commit the
3071      * state already so that a _get_state() will return immediately. */
3072     bin_remove_messages (bin, NULL, GST_MESSAGE_ASYNC_DONE);
3073 
<a name="11" id="anc11"></a><span class="line-modified">3074     GST_DEBUG_OBJECT (bin, &quot;async elements committed&quot;);</span>
3075     bin_handle_async_done (bin, GST_STATE_CHANGE_SUCCESS, FALSE,
3076         GST_CLOCK_TIME_NONE);
3077   }
3078 
3079 state_end:
3080   bin-&gt;priv-&gt;pending_async_done = FALSE;
3081   GST_OBJECT_UNLOCK (bin);
3082 
3083   GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, element,
3084       &quot;done changing bin&#39;s state from %s to %s, now in %s, ret %s&quot;,
3085       gst_element_state_get_name (current),
3086       gst_element_state_get_name (next),
3087       gst_element_state_get_name (GST_STATE (element)),
3088       gst_element_state_change_return_get_name (ret));
3089 
3090   return ret;
3091 
3092   /* ERRORS */
3093 activate_failure:
3094   {
3095     GST_CAT_WARNING_OBJECT (GST_CAT_STATES, element,
3096         &quot;failure (de)activating src pads&quot;);
3097     return GST_STATE_CHANGE_FAILURE;
3098   }
3099 
3100 undo:
3101   {
3102     if (current &lt; next) {
3103       GstIterator *it = gst_bin_iterate_sorted (GST_BIN (element));
3104       GstIteratorResult ret;
3105 
3106       GST_DEBUG_OBJECT (element,
3107           &quot;Bin failed to change state, switching children back to %s&quot;,
3108           gst_element_state_get_name (current));
3109       while (TRUE) {
3110         ret =
3111             gst_iterator_foreach (it, &amp;reset_state, GINT_TO_POINTER (current));
3112         if (ret != GST_ITERATOR_RESYNC)
3113           break;
3114         gst_iterator_resync (it);
<a name="12" id="anc12"></a><span class="line-modified">3115       }</span>
3116       gst_iterator_free (it);
3117     }
3118     goto done;
3119   }
3120 }
3121 
3122 /*
3123  * This function is a utility event handler. It will send the event to all sinks
3124  * or sources and appropriate ghost pads depending on the event-direction.
3125  *
3126  * Applications are free to override this behaviour and implement their own
3127  * handler, but this will work for pretty much all cases in practice.
3128  */
3129 static gboolean
3130 gst_bin_send_event (GstElement * element, GstEvent * event)
3131 {
3132   GstBin *bin = GST_BIN_CAST (element);
3133   GstIterator *iter;
3134   gboolean res = TRUE;
3135   gboolean done = FALSE;
3136   GValue data = { 0, };
3137 
3138   if (GST_EVENT_IS_DOWNSTREAM (event)) {
3139     iter = gst_bin_iterate_sources (bin);
3140     GST_DEBUG_OBJECT (bin, &quot;Sending %s event to src children&quot;,
3141         GST_EVENT_TYPE_NAME (event));
3142   } else {
3143     iter = gst_bin_iterate_sinks (bin);
3144     GST_DEBUG_OBJECT (bin, &quot;Sending %s event to sink children&quot;,
3145         GST_EVENT_TYPE_NAME (event));
3146   }
3147 
3148   while (!done) {
3149     switch (gst_iterator_next (iter, &amp;data)) {
3150       case GST_ITERATOR_OK:
3151       {
3152         GstElement *child = g_value_get_object (&amp;data);
3153 
3154         gst_event_ref (event);
3155         res &amp;= gst_element_send_event (child, event);
3156 
3157         GST_LOG_OBJECT (child, &quot;After handling %s event: %d&quot;,
3158             GST_EVENT_TYPE_NAME (event), res);
3159 
3160         g_value_reset (&amp;data);
3161         break;
3162       }
3163       case GST_ITERATOR_RESYNC:
3164         gst_iterator_resync (iter);
3165         res = TRUE;
3166         break;
3167       case GST_ITERATOR_DONE:
3168         done = TRUE;
3169         break;
3170       case GST_ITERATOR_ERROR:
3171         g_assert_not_reached ();
3172         break;
3173     }
3174   }
3175   g_value_unset (&amp;data);
3176   gst_iterator_free (iter);
3177 
3178   if (GST_EVENT_IS_DOWNSTREAM (event)) {
3179     iter = gst_element_iterate_sink_pads (GST_ELEMENT (bin));
3180     GST_DEBUG_OBJECT (bin, &quot;Sending %s event to sink pads&quot;,
3181         GST_EVENT_TYPE_NAME (event));
3182   } else {
3183     iter = gst_element_iterate_src_pads (GST_ELEMENT (bin));
3184     GST_DEBUG_OBJECT (bin, &quot;Sending %s event to src pads&quot;,
3185         GST_EVENT_TYPE_NAME (event));
3186   }
3187 
3188   done = FALSE;
3189   while (!done) {
3190     switch (gst_iterator_next (iter, &amp;data)) {
3191       case GST_ITERATOR_OK:
3192       {
3193         GstPad *pad = g_value_get_object (&amp;data);
3194 
3195         gst_event_ref (event);
3196         res &amp;= gst_pad_send_event (pad, event);
3197         GST_LOG_OBJECT (pad, &quot;After handling %s event: %d&quot;,
3198             GST_EVENT_TYPE_NAME (event), res);
3199         break;
3200       }
3201       case GST_ITERATOR_RESYNC:
3202         gst_iterator_resync (iter);
3203         res = TRUE;
3204         break;
3205       case GST_ITERATOR_DONE:
3206         done = TRUE;
3207         break;
3208       case GST_ITERATOR_ERROR:
3209         g_assert_not_reached ();
3210         break;
3211     }
3212   }
3213 
3214   g_value_unset (&amp;data);
3215   gst_iterator_free (iter);
3216   gst_event_unref (event);
3217 
3218   return res;
3219 }
3220 
3221 /* this is the function called by the threadpool. When async elements commit
3222  * their state, this function will attempt to bring the bin to the next state.
3223  */
3224 static void
3225 gst_bin_continue_func (GstBin * bin, BinContinueData * data)
3226 {
3227   GstState current, next, pending;
3228   GstStateChange transition;
3229 
3230   pending = data-&gt;pending;
3231 
3232   GST_DEBUG_OBJECT (bin, &quot;waiting for state lock&quot;);
3233   GST_STATE_LOCK (bin);
3234 
3235   GST_DEBUG_OBJECT (bin, &quot;doing state continue&quot;);
3236   GST_OBJECT_LOCK (bin);
3237 
3238   /* if a new state change happened after this thread was scheduled, we return
3239    * immediately. */
3240   if (data-&gt;cookie != GST_ELEMENT_CAST (bin)-&gt;state_cookie)
3241     goto interrupted;
3242 
3243   current = GST_STATE (bin);
3244   next = GST_STATE_GET_NEXT (current, pending);
3245   transition = (GstStateChange) GST_STATE_TRANSITION (current, next);
3246 
3247   GST_STATE_NEXT (bin) = next;
3248   GST_STATE_PENDING (bin) = pending;
3249   /* mark busy */
3250   GST_STATE_RETURN (bin) = GST_STATE_CHANGE_ASYNC;
3251   GST_OBJECT_UNLOCK (bin);
3252 
3253   GST_CAT_INFO_OBJECT (GST_CAT_STATES, bin,
3254       &quot;continue state change %s to %s, final %s&quot;,
3255       gst_element_state_get_name (current),
3256       gst_element_state_get_name (next), gst_element_state_get_name (pending));
3257 
3258   gst_element_change_state (GST_ELEMENT_CAST (bin), transition);
3259 
3260   GST_STATE_UNLOCK (bin);
3261   GST_DEBUG_OBJECT (bin, &quot;state continue done&quot;);
3262 
3263   return;
3264 
3265 interrupted:
3266   {
3267     GST_OBJECT_UNLOCK (bin);
3268     GST_STATE_UNLOCK (bin);
3269     GST_DEBUG_OBJECT (bin, &quot;state continue aborted due to intervening change&quot;);
3270     return;
3271   }
3272 }
3273 
3274 static GstBusSyncReply
3275 bin_bus_handler (GstBus * bus, GstMessage * message, GstBin * bin)
3276 {
3277   GstBinClass *bclass;
3278 
3279   bclass = GST_BIN_GET_CLASS (bin);
3280   if (bclass-&gt;handle_message)
3281     bclass-&gt;handle_message (bin, message);
3282   else
3283     gst_message_unref (message);
3284 
3285   return GST_BUS_DROP;
3286 }
3287 
3288 static void
3289 free_bin_continue_data (BinContinueData * data)
3290 {
3291   g_slice_free (BinContinueData, data);
3292 }
3293 
3294 static void
3295 bin_push_state_continue (GstBin * bin, BinContinueData * data)
3296 {
3297   GST_DEBUG_OBJECT (bin, &quot;pushing continue on thread pool&quot;);
3298   gst_element_call_async (GST_ELEMENT_CAST (bin),
3299       (GstElementCallAsyncFunc) gst_bin_continue_func, data,
3300       (GDestroyNotify) free_bin_continue_data);
3301 }
3302 
3303 /* an element started an async state change, if we were not busy with a state
3304  * change, we perform a lost state.
3305  * This function is called with the OBJECT lock.
3306  */
3307 static void
3308 bin_handle_async_start (GstBin * bin)
3309 {
3310   GstState old_state, new_state;
3311   gboolean toplevel;
3312   GstMessage *amessage = NULL;
3313 
3314   if (GST_STATE_RETURN (bin) == GST_STATE_CHANGE_FAILURE)
3315     goto had_error;
3316 
3317   /* get our toplevel state */
3318   toplevel = BIN_IS_TOPLEVEL (bin);
3319 
3320   /* prepare an ASYNC_START message, we always post the start message even if we
3321    * are busy with a state change or when we are NO_PREROLL. */
3322   if (!toplevel)
3323     /* non toplevel bin, prepare async-start for the parent */
3324     amessage = gst_message_new_async_start (GST_OBJECT_CAST (bin));
3325 
3326   if (bin-&gt;polling || GST_STATE_PENDING (bin) != GST_STATE_VOID_PENDING)
3327     goto was_busy;
3328 
3329   /* async starts are ignored when we are NO_PREROLL */
3330   if (GST_STATE_RETURN (bin) == GST_STATE_CHANGE_NO_PREROLL)
3331     goto was_no_preroll;
3332 
3333   old_state = GST_STATE (bin);
3334 
3335   /* when we PLAYING we go back to PAUSED, when preroll happens, we go back to
3336    * PLAYING after optionally redistributing the base_time. */
3337   if (old_state &gt; GST_STATE_PAUSED)
3338     new_state = GST_STATE_PAUSED;
3339   else
3340     new_state = old_state;
3341 
3342   GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin,
3343       &quot;lost state of %s, new %s&quot;, gst_element_state_get_name (old_state),
3344       gst_element_state_get_name (new_state));
3345 
3346   GST_STATE (bin) = new_state;
3347   GST_STATE_NEXT (bin) = new_state;
3348   GST_STATE_PENDING (bin) = new_state;
3349   GST_STATE_RETURN (bin) = GST_STATE_CHANGE_ASYNC;
3350   GST_OBJECT_UNLOCK (bin);
3351 
3352   /* post message */
3353   _priv_gst_element_state_changed (GST_ELEMENT_CAST (bin), new_state, new_state,
3354       new_state);
3355 
3356 post_start:
3357   if (amessage) {
3358     /* post our ASYNC_START. */
3359     GST_DEBUG_OBJECT (bin, &quot;posting ASYNC_START to parent&quot;);
3360     gst_element_post_message (GST_ELEMENT_CAST (bin), amessage);
3361   }
3362   GST_OBJECT_LOCK (bin);
3363 
3364   return;
3365 
3366 had_error:
3367   {
3368     GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin, &quot;we had an error&quot;);
3369     return;
3370   }
3371 was_busy:
3372   {
3373     GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin, &quot;state change busy&quot;);
3374     GST_OBJECT_UNLOCK (bin);
3375     goto post_start;
3376   }
3377 was_no_preroll:
3378   {
3379     GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin, &quot;ignoring, we are NO_PREROLL&quot;);
3380     GST_OBJECT_UNLOCK (bin);
3381     goto post_start;
3382   }
3383 }
3384 
3385 /* this function is called when there are no more async elements in the bin. We
3386  * post a state changed message and an ASYNC_DONE message.
3387  * This function is called with the OBJECT lock.
3388  */
3389 static void
3390 bin_handle_async_done (GstBin * bin, GstStateChangeReturn ret,
3391     gboolean flag_pending, GstClockTime running_time)
3392 {
3393   GstState current, pending, target;
3394   GstStateChangeReturn old_ret;
3395   GstState old_state, old_next;
3396   gboolean toplevel, state_changed = FALSE;
3397   GstMessage *amessage = NULL;
3398   BinContinueData *cont = NULL;
3399 
3400   if (GST_STATE_RETURN (bin) == GST_STATE_CHANGE_FAILURE)
3401     goto had_error;
3402 
3403   pending = GST_STATE_PENDING (bin);
3404 
3405   if (bin-&gt;polling)
3406     goto was_busy;
3407 
3408   /* check if there is something to commit */
3409   if (pending == GST_STATE_VOID_PENDING)
3410     goto nothing_pending;
3411 
3412   old_ret = GST_STATE_RETURN (bin);
3413   GST_STATE_RETURN (bin) = ret;
3414 
3415   /* move to the next target state */
3416   target = GST_STATE_TARGET (bin);
3417   pending = GST_STATE_PENDING (bin) = target;
3418 
3419   amessage = gst_message_new_async_done (GST_OBJECT_CAST (bin), running_time);
3420 
3421   old_state = GST_STATE (bin);
3422   /* this is the state we should go to next */
3423   old_next = GST_STATE_NEXT (bin);
3424 
3425   if (old_next != GST_STATE_PLAYING) {
3426     GST_CAT_INFO_OBJECT (GST_CAT_STATES, bin,
3427         &quot;committing state from %s to %s, old pending %s&quot;,
3428         gst_element_state_get_name (old_state),
3429         gst_element_state_get_name (old_next),
3430         gst_element_state_get_name (pending));
3431 
3432     /* update current state */
3433     current = GST_STATE (bin) = old_next;
3434   } else {
3435     GST_CAT_INFO_OBJECT (GST_CAT_STATES, bin,
3436         &quot;setting state from %s to %s, pending %s&quot;,
3437         gst_element_state_get_name (old_state),
3438         gst_element_state_get_name (old_state),
3439         gst_element_state_get_name (pending));
3440     current = old_state;
3441   }
3442 
3443   /* get our toplevel state */
3444   toplevel = BIN_IS_TOPLEVEL (bin);
3445 
3446   /* see if we reached the final state. If we are not toplevel, we also have to
3447    * stop here, the parent will continue our state. */
3448   if ((pending == current) || !toplevel) {
3449     GST_CAT_INFO_OBJECT (GST_CAT_STATES, bin,
3450         &quot;completed state change, pending VOID&quot;);
3451 
3452     /* mark VOID pending */
3453     pending = GST_STATE_VOID_PENDING;
3454     GST_STATE_PENDING (bin) = pending;
3455     GST_STATE_NEXT (bin) = GST_STATE_VOID_PENDING;
3456   } else {
3457     GST_CAT_INFO_OBJECT (GST_CAT_STATES, bin,
3458         &quot;continue state change, pending %s&quot;,
3459         gst_element_state_get_name (pending));
3460 
3461     cont = g_slice_new (BinContinueData);
3462 
3463     /* cookie to detect concurrent state change */
3464     cont-&gt;cookie = GST_ELEMENT_CAST (bin)-&gt;state_cookie;
3465     /* pending target state */
3466     cont-&gt;pending = pending;
3467     /* mark busy */
3468     GST_STATE_RETURN (bin) = GST_STATE_CHANGE_ASYNC;
3469     GST_STATE_NEXT (bin) = GST_STATE_GET_NEXT (old_state, pending);
3470   }
3471 
3472   if (old_next != GST_STATE_PLAYING) {
3473     if (old_state != old_next || old_ret == GST_STATE_CHANGE_ASYNC) {
3474       state_changed = TRUE;
3475     }
3476   }
3477   GST_OBJECT_UNLOCK (bin);
3478 
3479   if (state_changed) {
3480     _priv_gst_element_state_changed (GST_ELEMENT_CAST (bin), old_state,
3481         old_next, pending);
3482   }
3483   if (amessage) {
3484     /* post our combined ASYNC_DONE when all is ASYNC_DONE. */
3485     GST_DEBUG_OBJECT (bin, &quot;posting ASYNC_DONE to parent&quot;);
3486     gst_element_post_message (GST_ELEMENT_CAST (bin), amessage);
3487   }
3488 
3489   GST_OBJECT_LOCK (bin);
3490   if (cont) {
3491     /* toplevel, start continue state */
3492     GST_DEBUG_OBJECT (bin, &quot;all async-done, starting state continue&quot;);
3493     bin_push_state_continue (bin, cont);
3494   } else {
3495     GST_DEBUG_OBJECT (bin, &quot;state change complete&quot;);
3496     GST_STATE_BROADCAST (bin);
3497   }
3498   return;
3499 
3500 had_error:
3501   {
3502     GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin, &quot;we had an error&quot;);
3503     return;
3504   }
3505 was_busy:
3506   {
3507     GST_CAT_DEBUG_OBJECT (GST_CAT_STATES, bin, &quot;state change busy&quot;);
3508     /* if we were busy with a state change and we are requested to flag a
3509      * pending async done, we do so here */
3510     if (flag_pending)
3511       bin-&gt;priv-&gt;pending_async_done = TRUE;
3512     return;
3513   }
3514 nothing_pending:
3515   {
3516     GST_CAT_INFO_OBJECT (GST_CAT_STATES, bin, &quot;nothing pending&quot;);
3517     return;
3518   }
3519 }
3520 
3521 static void
3522 bin_do_eos (GstBin * bin)
3523 {
<a name="13" id="anc13"></a><span class="line-modified">3524   guint32 seqnum = GST_SEQNUM_INVALID;</span>
3525   gboolean eos;
3526 
3527   GST_OBJECT_LOCK (bin);
3528   /* If all sinks are EOS, we&#39;re in PLAYING and no state change is pending
<a name="14" id="anc14"></a><span class="line-modified">3529    * (or we&#39;re doing playing to playing and no one else will trigger posting</span>
3530    * EOS for us) we forward the EOS message to the parent bin or application
3531    */
3532   eos = GST_STATE (bin) == GST_STATE_PLAYING
3533       &amp;&amp; (GST_STATE_PENDING (bin) == GST_STATE_VOID_PENDING ||
3534       GST_STATE_PENDING (bin) == GST_STATE_PLAYING)
3535       &amp;&amp; bin-&gt;priv-&gt;posted_playing &amp;&amp; is_eos (bin, &amp;seqnum);
3536   GST_OBJECT_UNLOCK (bin);
3537 
3538   if (eos
3539       &amp;&amp; g_atomic_int_compare_and_exchange (&amp;bin-&gt;priv-&gt;posted_eos, FALSE,
3540           TRUE)) {
3541     GstMessage *tmessage;
3542 
3543     /* Clear out any further messages, and reset posted_eos so we can
3544        detect any new EOS that happens (eg, after a seek). Since all
3545        sinks have now posted an EOS, there will be no further EOS events
3546        seen unless there is a new logical EOS */
3547     GST_OBJECT_LOCK (bin);
3548     bin_remove_messages (bin, NULL, GST_MESSAGE_EOS);
3549     bin-&gt;priv-&gt;posted_eos = FALSE;
3550     GST_OBJECT_UNLOCK (bin);
3551 
3552     tmessage = gst_message_new_eos (GST_OBJECT_CAST (bin));
<a name="15" id="anc15"></a><span class="line-modified">3553     if (seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added">3554       gst_message_set_seqnum (tmessage, seqnum);</span>
3555     GST_DEBUG_OBJECT (bin,
3556         &quot;all sinks posted EOS, posting seqnum #%&quot; G_GUINT32_FORMAT, seqnum);
3557     gst_element_post_message (GST_ELEMENT_CAST (bin), tmessage);
3558   } else {
3559     GST_LOG_OBJECT (bin, &quot;Not forwarding EOS due to in progress state change, &quot;
3560         &quot; or already posted, or waiting for more EOS&quot;);
3561   }
3562 }
3563 
3564 static void
3565 bin_do_stream_start (GstBin * bin)
3566 {
<a name="16" id="anc16"></a><span class="line-modified">3567   guint32 seqnum = GST_SEQNUM_INVALID;</span>
3568   gboolean stream_start;
3569   gboolean have_group_id = FALSE;
3570   guint group_id = 0;
3571 
3572   GST_OBJECT_LOCK (bin);
3573   /* If all sinks are STREAM_START we forward the STREAM_START message
3574    * to the parent bin or application
3575    */
3576   stream_start = is_stream_start (bin, &amp;seqnum, &amp;have_group_id, &amp;group_id);
3577   GST_OBJECT_UNLOCK (bin);
3578 
3579   if (stream_start) {
3580     GstMessage *tmessage;
3581 
3582     GST_OBJECT_LOCK (bin);
3583     bin_remove_messages (bin, NULL, GST_MESSAGE_STREAM_START);
3584     GST_OBJECT_UNLOCK (bin);
3585 
3586     tmessage = gst_message_new_stream_start (GST_OBJECT_CAST (bin));
<a name="17" id="anc17"></a><span class="line-modified">3587     if (seqnum != GST_SEQNUM_INVALID)</span>
<span class="line-added">3588       gst_message_set_seqnum (tmessage, seqnum);</span>
3589     if (have_group_id)
3590       gst_message_set_group_id (tmessage, group_id);
3591 
3592     GST_DEBUG_OBJECT (bin,
3593         &quot;all sinks posted STREAM_START, posting seqnum #%&quot; G_GUINT32_FORMAT,
3594         seqnum);
3595     gst_element_post_message (GST_ELEMENT_CAST (bin), tmessage);
3596   }
3597 }
3598 
3599 /* must be called without the object lock as it posts messages */
3600 static void
3601 bin_do_message_forward (GstBin * bin, GstMessage * message)
3602 {
3603   if (bin-&gt;priv-&gt;message_forward) {
3604     GstMessage *forwarded;
3605 
3606     GST_DEBUG_OBJECT (bin, &quot;pass %s message upward&quot;,
3607         GST_MESSAGE_TYPE_NAME (message));
3608 
3609     /* we need to convert these messages to element messages so that our parent
3610      * bin can easily ignore them and so that the application can easily
3611      * distinguish between the internally forwarded and the real messages. */
3612     forwarded = gst_message_new_element (GST_OBJECT_CAST (bin),
3613         gst_structure_new (&quot;GstBinForwarded&quot;,
3614             &quot;message&quot;, GST_TYPE_MESSAGE, message, NULL));
3615 
3616     gst_element_post_message (GST_ELEMENT_CAST (bin), forwarded);
3617   }
3618 }
3619 
3620 static void
3621 gst_bin_update_context (GstBin * bin, GstContext * context)
3622 {
3623   GST_OBJECT_LOCK (bin);
3624   gst_bin_update_context_unlocked (bin, context);
3625   GST_OBJECT_UNLOCK (bin);
3626 }
3627 
3628 static void
3629 gst_bin_update_context_unlocked (GstBin * bin, GstContext * context)
3630 {
3631   const gchar *context_type;
3632   GList *l, **contexts;
3633 
3634   contexts = &amp;GST_ELEMENT_CAST (bin)-&gt;contexts;
3635   context_type = gst_context_get_context_type (context);
3636 
3637   GST_DEBUG_OBJECT (bin, &quot;set context %p %&quot; GST_PTR_FORMAT, context,
3638       gst_context_get_structure (context));
3639   for (l = *contexts; l; l = l-&gt;next) {
3640     GstContext *tmp = l-&gt;data;
3641     const gchar *tmp_type = gst_context_get_context_type (tmp);
3642 
3643     /* Always store newest context but never replace
3644      * a persistent one by a non-persistent one */
3645     if (strcmp (context_type, tmp_type) == 0 &amp;&amp;
3646         (gst_context_is_persistent (context) ||
3647             !gst_context_is_persistent (tmp))) {
3648       gst_context_replace ((GstContext **) &amp; l-&gt;data, context);
3649       break;
3650     }
3651   }
3652   /* Not found? Add */
3653   if (l == NULL) {
3654     *contexts = g_list_prepend (*contexts, gst_context_ref (context));
<a name="18" id="anc18"></a><span class="line-modified">3655   }</span>
3656 }
3657 
3658 /* handle child messages:
3659  *
3660  * This method is called synchronously when a child posts a message on
3661  * the internal bus.
3662  *
3663  * GST_MESSAGE_EOS: This message is only posted by sinks
3664  *     in the PLAYING state. If all sinks posted the EOS message, post
3665  *     one upwards.
3666  *
3667  * GST_MESSAGE_STATE_DIRTY: Deprecated
3668  *
3669  * GST_MESSAGE_SEGMENT_START: just collect, never forward upwards. If an
3670  *     element posts segment_start twice, only the last message is kept.
3671  *
3672  * GST_MESSAGE_SEGMENT_DONE: replace SEGMENT_START message from same poster
3673  *     with the segment_done message. If there are no more segment_start
3674  *     messages, post segment_done message upwards.
3675  *
3676  * GST_MESSAGE_DURATION_CHANGED: clear any cached durations.
3677  *     Whenever someone performs a duration query on the bin, we store the
3678  *     result so we can answer it quicker the next time. Any element that
3679  *     changes its duration marks our cached values invalid.
3680  *     This message is also posted upwards. This is currently disabled
3681  *     because too many elements don&#39;t post DURATION_CHANGED messages when
3682  *     the duration changes.
3683  *
3684  * GST_MESSAGE_CLOCK_LOST: This message is posted by an element when it
3685  *     can no longer provide a clock. The default bin behaviour is to
3686  *     check if the lost clock was the one provided by the bin. If so and
3687  *     we are currently in the PLAYING state, we forward the message to
3688  *     our parent.
3689  *     This message is also generated when we remove a clock provider from
3690  *     a bin. If this message is received by the application, it should
3691  *     PAUSE the pipeline and set it back to PLAYING to force a new clock
3692  *     and a new base_time distribution.
3693  *
3694  * GST_MESSAGE_CLOCK_PROVIDE: This message is generated when an element
3695  *     can provide a clock. This mostly happens when we add a new clock
3696  *     provider to the bin. The default behaviour of the bin is to mark the
3697  *     currently selected clock as dirty, which will perform a clock
3698  *     recalculation the next time we are asked to provide a clock.
3699  *     This message is never sent to the application but is forwarded to
3700  *     the parent.
3701  *
3702  * GST_MESSAGE_ASYNC_START: Create an internal ELEMENT message that stores
3703  *     the state of the element and the fact that the element will need a
3704  *     new base_time. This message is not forwarded to the application.
3705  *
3706  * GST_MESSAGE_ASYNC_DONE: Find the internal ELEMENT message we kept for the
3707  *     element when it posted ASYNC_START. If all elements are done, post a
3708  *     ASYNC_DONE message to the parent.
3709  *
3710  * OTHER: post upwards.
3711  */
3712 static void
3713 gst_bin_handle_message_func (GstBin * bin, GstMessage * message)
3714 {
3715   GstObject *src;
3716   GstMessageType type;
3717   GstMessage *tmessage;
3718   guint32 seqnum;
3719 
3720   src = GST_MESSAGE_SRC (message);
3721   type = GST_MESSAGE_TYPE (message);
3722 
3723   GST_DEBUG_OBJECT (bin, &quot;[msg %p] handling child %s message of type %s&quot;,
3724       message, src ? GST_ELEMENT_NAME (src) : &quot;(NULL)&quot;,
3725       GST_MESSAGE_TYPE_NAME (message));
3726 
3727   switch (type) {
3728     case GST_MESSAGE_ERROR:
3729     {
3730       GST_OBJECT_LOCK (bin);
3731       /* flag error */
3732       GST_DEBUG_OBJECT (bin, &quot;got ERROR message, unlocking state change&quot;);
3733       GST_STATE_RETURN (bin) = GST_STATE_CHANGE_FAILURE;
3734       GST_STATE_BROADCAST (bin);
3735       GST_OBJECT_UNLOCK (bin);
3736 
3737       goto forward;
3738     }
3739     case GST_MESSAGE_EOS:
3740     {
3741 
3742       /* collect all eos messages from the children */
3743       bin_do_message_forward (bin, message);
3744       GST_OBJECT_LOCK (bin);
3745       /* ref message for future use  */
3746       bin_replace_message (bin, message, GST_MESSAGE_EOS);
3747       GST_OBJECT_UNLOCK (bin);
3748 
3749       bin_do_eos (bin);
3750       break;
3751     }
3752     case GST_MESSAGE_STREAM_START:
3753     {
3754 
3755       /* collect all stream_start messages from the children */
3756       GST_OBJECT_LOCK (bin);
3757       /* ref message for future use  */
3758       bin_replace_message (bin, message, GST_MESSAGE_STREAM_START);
3759       GST_OBJECT_UNLOCK (bin);
3760 
3761       bin_do_stream_start (bin);
3762       break;
3763     }
3764     case GST_MESSAGE_STATE_DIRTY:
3765     {
3766       GST_WARNING_OBJECT (bin, &quot;received deprecated STATE_DIRTY message&quot;);
3767 
3768       /* free message */
3769       gst_message_unref (message);
3770       break;
3771     }
3772     case GST_MESSAGE_SEGMENT_START:{
3773       gboolean post = FALSE;
3774       GstFormat format;
3775       gint64 position;
3776 
3777       gst_message_parse_segment_start (message, &amp;format, &amp;position);
3778       seqnum = gst_message_get_seqnum (message);
3779 
3780       bin_do_message_forward (bin, message);
3781 
3782       GST_OBJECT_LOCK (bin);
3783       /* if this is the first segment-start, post to parent but not to the
3784        * application */
3785       if (!find_message (bin, NULL, GST_MESSAGE_SEGMENT_START) &amp;&amp;
3786           (GST_OBJECT_PARENT (bin) != NULL)) {
3787         post = TRUE;
3788       }
3789       /* replace any previous segment_start message from this source
3790        * with the new segment start message */
3791       bin_replace_message (bin, message, GST_MESSAGE_SEGMENT_START);
3792       GST_OBJECT_UNLOCK (bin);
3793       if (post) {
3794         tmessage = gst_message_new_segment_start (GST_OBJECT_CAST (bin),
3795             format, position);
3796         gst_message_set_seqnum (tmessage, seqnum);
3797 
3798         /* post segment start with initial format and position. */
3799         GST_DEBUG_OBJECT (bin, &quot;posting SEGMENT_START (%u) bus message: %p&quot;,
3800             seqnum, message);
3801         gst_element_post_message (GST_ELEMENT_CAST (bin), tmessage);
3802       }
3803       break;
3804     }
3805     case GST_MESSAGE_SEGMENT_DONE:
3806     {
3807       gboolean post = FALSE;
3808       GstFormat format;
3809       gint64 position;
3810 
3811       gst_message_parse_segment_done (message, &amp;format, &amp;position);
3812       seqnum = gst_message_get_seqnum (message);
3813 
3814       bin_do_message_forward (bin, message);
3815 
3816       GST_OBJECT_LOCK (bin);
3817       bin_replace_message (bin, message, GST_MESSAGE_SEGMENT_START);
3818       /* if there are no more segment_start messages, everybody posted
3819        * a segment_done and we can post one on the bus. */
3820 
3821       /* we don&#39;t care who still has a pending segment start */
3822       if (!find_message (bin, NULL, GST_MESSAGE_SEGMENT_START)) {
3823         /* nothing found */
3824         post = TRUE;
3825         /* remove all old segment_done messages */
3826         bin_remove_messages (bin, NULL, GST_MESSAGE_SEGMENT_DONE);
3827       }
3828       GST_OBJECT_UNLOCK (bin);
3829       if (post) {
3830         tmessage = gst_message_new_segment_done (GST_OBJECT_CAST (bin),
3831             format, position);
3832         gst_message_set_seqnum (tmessage, seqnum);
3833 
3834         /* post segment done with latest format and position. */
3835         GST_DEBUG_OBJECT (bin, &quot;posting SEGMENT_DONE (%u) bus message: %p&quot;,
3836             seqnum, message);
3837         gst_element_post_message (GST_ELEMENT_CAST (bin), tmessage);
3838       }
3839       break;
3840     }
3841     case GST_MESSAGE_DURATION_CHANGED:
3842     {
3843       /* FIXME: remove all cached durations, next time somebody asks
3844        * for duration, we will recalculate. */
3845 #if 0
3846       GST_OBJECT_LOCK (bin);
3847       bin_remove_messages (bin, NULL, GST_MESSAGE_DURATION_CHANGED);
3848       GST_OBJECT_UNLOCK (bin);
3849 #endif
3850       goto forward;
3851     }
3852     case GST_MESSAGE_CLOCK_LOST:
3853     {
3854       GstClock **provided_clock_p;
3855       GstElement **clock_provider_p;
3856       gboolean playing, toplevel, provided, forward;
3857       GstClock *clock;
3858 
3859       gst_message_parse_clock_lost (message, &amp;clock);
3860 
3861       GST_OBJECT_LOCK (bin);
3862       bin-&gt;clock_dirty = TRUE;
3863       /* if we lost the clock that we provided, post to parent but
3864        * only if we are not a top-level bin or PLAYING.
3865        * The reason for this is that applications should be able
3866        * to PAUSE/PLAY if they receive this message without worrying
3867        * about the state of the pipeline. */
3868       provided = (clock == bin-&gt;provided_clock);
3869       playing = (GST_STATE (bin) == GST_STATE_PLAYING);
3870       toplevel = GST_OBJECT_PARENT (bin) == NULL;
3871       forward = provided &amp;&amp; (playing || !toplevel);
3872       if (provided) {
3873         GST_DEBUG_OBJECT (bin,
3874             &quot;Lost clock %&quot; GST_PTR_FORMAT &quot; provided by %&quot; GST_PTR_FORMAT,
3875             bin-&gt;provided_clock, bin-&gt;clock_provider);
3876         provided_clock_p = &amp;bin-&gt;provided_clock;
3877         clock_provider_p = &amp;bin-&gt;clock_provider;
3878         gst_object_replace ((GstObject **) provided_clock_p, NULL);
3879         gst_object_replace ((GstObject **) clock_provider_p, NULL);
3880       }
3881       GST_DEBUG_OBJECT (bin, &quot;provided %d, playing %d, forward %d&quot;,
3882           provided, playing, forward);
3883       GST_OBJECT_UNLOCK (bin);
3884 
3885       if (forward)
3886         goto forward;
3887 
3888       /* free message */
3889       gst_message_unref (message);
3890       break;
3891     }
3892     case GST_MESSAGE_CLOCK_PROVIDE:
3893     {
3894       gboolean forward;
3895 
3896       GST_OBJECT_LOCK (bin);
3897       bin-&gt;clock_dirty = TRUE;
3898       /* a new clock is available, post to parent but not
3899        * to the application */
3900       forward = GST_OBJECT_PARENT (bin) != NULL;
3901       GST_OBJECT_UNLOCK (bin);
3902 
3903       if (forward)
3904         goto forward;
3905 
3906       /* free message */
3907       gst_message_unref (message);
3908       break;
3909     }
3910     case GST_MESSAGE_ASYNC_START:
3911     {
3912       GstState target;
3913 
3914       GST_DEBUG_OBJECT (bin, &quot;ASYNC_START message %p, %s&quot;, message,
3915           src ? GST_OBJECT_NAME (src) : &quot;(NULL)&quot;);
3916 
3917       bin_do_message_forward (bin, message);
3918 
3919       GST_OBJECT_LOCK (bin);
3920       /* we ignore the message if we are going to &lt;= READY */
3921       if ((target = GST_STATE_TARGET (bin)) &lt;= GST_STATE_READY)
3922         goto ignore_start_message;
3923 
3924       /* takes ownership of the message */
3925       bin_replace_message (bin, message, GST_MESSAGE_ASYNC_START);
3926 
3927       bin_handle_async_start (bin);
3928       GST_OBJECT_UNLOCK (bin);
3929       break;
3930 
3931     ignore_start_message:
3932       {
3933         GST_DEBUG_OBJECT (bin, &quot;ignoring message, target %s&quot;,
3934             gst_element_state_get_name (target));
3935         GST_OBJECT_UNLOCK (bin);
3936         gst_message_unref (message);
3937         break;
3938       }
3939     }
3940     case GST_MESSAGE_ASYNC_DONE:
3941     {
3942       GstClockTime running_time;
3943       GstState target;
3944 
3945       GST_DEBUG_OBJECT (bin, &quot;ASYNC_DONE message %p, %s&quot;, message,
3946           src ? GST_OBJECT_NAME (src) : &quot;(NULL)&quot;);
3947 
3948       gst_message_parse_async_done (message, &amp;running_time);
3949 
3950       bin_do_message_forward (bin, message);
3951 
3952       GST_OBJECT_LOCK (bin);
3953       /* ignore messages if we are shutting down */
3954       if ((target = GST_STATE_TARGET (bin)) &lt;= GST_STATE_READY)
3955         goto ignore_done_message;
3956 
3957       bin_replace_message (bin, message, GST_MESSAGE_ASYNC_START);
3958       /* if there are no more ASYNC_START messages, everybody posted
3959        * a ASYNC_DONE and we can post one on the bus. When checking, we
3960        * don&#39;t care who still has a pending ASYNC_START */
3961       if (!find_message (bin, NULL, GST_MESSAGE_ASYNC_START)) {
3962         /* nothing found, remove all old ASYNC_DONE messages */
3963         bin_remove_messages (bin, NULL, GST_MESSAGE_ASYNC_DONE);
3964 
<a name="19" id="anc19"></a><span class="line-modified">3965         GST_DEBUG_OBJECT (bin, &quot;async elements committed&quot;);</span>
3966         /* when we get an async done message when a state change was busy, we
3967          * need to set the pending_done flag so that at the end of the state
3968          * change we can see if we need to verify pending async elements, hence
3969          * the TRUE argument here. */
3970         bin_handle_async_done (bin, GST_STATE_CHANGE_SUCCESS, TRUE,
3971             running_time);
3972       } else {
3973         GST_DEBUG_OBJECT (bin, &quot;there are more async elements pending&quot;);
3974       }
3975       GST_OBJECT_UNLOCK (bin);
3976       break;
3977 
3978     ignore_done_message:
3979       {
3980         GST_DEBUG_OBJECT (bin, &quot;ignoring message, target %s&quot;,
3981             gst_element_state_get_name (target));
3982         GST_OBJECT_UNLOCK (bin);
3983         gst_message_unref (message);
3984         break;
3985       }
3986     }
3987     case GST_MESSAGE_STRUCTURE_CHANGE:
3988     {
3989       gboolean busy;
3990 
3991       gst_message_parse_structure_change (message, NULL, NULL, &amp;busy);
3992 
3993       GST_OBJECT_LOCK (bin);
3994       if (busy) {
3995         /* while the pad is busy, avoid following it when doing state changes.
3996          * Don&#39;t update the cookie yet, we will do that after the structure
3997          * change finished and we are ready to inspect the new updated
3998          * structure. */
3999         bin_replace_message (bin, message, GST_MESSAGE_STRUCTURE_CHANGE);
4000         message = NULL;
4001       } else {
4002         /* a pad link/unlink ended, signal the state change iterator that we
4003          * need to resync by updating the structure_cookie. */
4004         bin_remove_messages (bin, GST_MESSAGE_SRC (message),
4005             GST_MESSAGE_STRUCTURE_CHANGE);
4006         if (!GST_BIN_IS_NO_RESYNC (bin))
4007           bin-&gt;priv-&gt;structure_cookie++;
4008       }
4009       GST_OBJECT_UNLOCK (bin);
4010 
4011       if (message)
4012         gst_message_unref (message);
4013 
4014       break;
4015     }
4016     case GST_MESSAGE_NEED_CONTEXT:{
4017       const gchar *context_type;
4018       GList *l, *contexts;
4019 
4020       gst_message_parse_context_type (message, &amp;context_type);
4021       GST_OBJECT_LOCK (bin);
4022       contexts = GST_ELEMENT_CAST (bin)-&gt;contexts;
4023       GST_LOG_OBJECT (bin, &quot;got need-context message type: %s&quot;, context_type);
4024       for (l = contexts; l; l = l-&gt;next) {
4025         GstContext *tmp = l-&gt;data;
4026         const gchar *tmp_type = gst_context_get_context_type (tmp);
4027 
4028         if (strcmp (context_type, tmp_type) == 0) {
4029           gst_element_set_context (GST_ELEMENT (src), l-&gt;data);
4030           break;
4031         }
4032       }
4033       GST_OBJECT_UNLOCK (bin);
4034 
4035       /* Forward if we couldn&#39;t answer the message */
4036       if (l == NULL) {
4037         goto forward;
4038       } else {
4039         gst_message_unref (message);
4040       }
4041 
4042       break;
4043     }
4044     case GST_MESSAGE_HAVE_CONTEXT:{
4045       GstContext *context;
4046 
4047       gst_message_parse_have_context (message, &amp;context);
4048       gst_bin_update_context (bin, context);
4049       gst_context_unref (context);
4050 
4051       goto forward;
4052       break;
4053     }
4054     default:
4055       goto forward;
4056   }
4057   return;
4058 
4059 forward:
4060   {
4061     /* Send all other messages upward */
4062     GST_DEBUG_OBJECT (bin, &quot;posting message upward&quot;);
4063     gst_element_post_message (GST_ELEMENT_CAST (bin), message);
4064     return;
4065   }
4066 }
4067 
4068 /* generic struct passed to all query fold methods */
4069 typedef struct
4070 {
4071   GstQuery *query;
4072   gint64 min;
4073   gint64 max;
4074   gboolean live;
4075 } QueryFold;
4076 
4077 typedef void (*QueryInitFunction) (GstBin * bin, QueryFold * fold);
4078 typedef void (*QueryDoneFunction) (GstBin * bin, QueryFold * fold);
4079 
4080 /* for duration/position we collect all durations/positions and take
4081  * the MAX of all valid results */
4082 static void
4083 bin_query_min_max_init (GstBin * bin, QueryFold * fold)
4084 {
4085   fold-&gt;min = 0;
4086   fold-&gt;max = -1;
4087   fold-&gt;live = FALSE;
4088 }
4089 
4090 static gboolean
4091 bin_query_duration_fold (const GValue * vitem, GValue * ret, QueryFold * fold)
4092 {
4093   gboolean res = FALSE;
4094   GstObject *item = g_value_get_object (vitem);
4095   if (GST_IS_PAD (item))
4096     res = gst_pad_query (GST_PAD (item), fold-&gt;query);
4097   else
4098     res = gst_element_query (GST_ELEMENT (item), fold-&gt;query);
4099 
4100   if (res) {
4101     gint64 duration;
4102 
4103     g_value_set_boolean (ret, TRUE);
4104 
4105     gst_query_parse_duration (fold-&gt;query, NULL, &amp;duration);
4106 
4107     GST_DEBUG_OBJECT (item, &quot;got duration %&quot; G_GINT64_FORMAT, duration);
4108 
4109     if (duration == -1) {
4110       /* duration query succeeded, but duration is unknown */
4111       fold-&gt;max = -1;
4112       return FALSE;
4113     }
4114 
4115     if (duration &gt; fold-&gt;max)
4116       fold-&gt;max = duration;
4117   }
4118 
4119   return TRUE;
4120 }
4121 
4122 static void
4123 bin_query_duration_done (GstBin * bin, QueryFold * fold)
4124 {
4125   GstFormat format;
4126 
4127   gst_query_parse_duration (fold-&gt;query, &amp;format, NULL);
4128   /* store max in query result */
4129   gst_query_set_duration (fold-&gt;query, format, fold-&gt;max);
4130 
4131   GST_DEBUG_OBJECT (bin, &quot;max duration %&quot; G_GINT64_FORMAT, fold-&gt;max);
4132 
4133   /* FIXME: re-implement duration caching */
4134 #if 0
4135   /* and cache now */
4136   GST_OBJECT_LOCK (bin);
4137   bin-&gt;messages = g_list_prepend (bin-&gt;messages,
4138       gst_message_new_duration (GST_OBJECT_CAST (bin), format, fold-&gt;max));
4139   GST_OBJECT_UNLOCK (bin);
4140 #endif
4141 }
4142 
4143 static gboolean
4144 bin_query_position_fold (const GValue * vitem, GValue * ret, QueryFold * fold)
4145 {
4146   gboolean res = FALSE;
4147   GstObject *item = g_value_get_object (vitem);
4148   if (GST_IS_PAD (item))
4149     res = gst_pad_query (GST_PAD (item), fold-&gt;query);
4150   else
4151     res = gst_element_query (GST_ELEMENT (item), fold-&gt;query);
4152 
4153   if (res) {
4154     gint64 position;
4155 
4156     g_value_set_boolean (ret, TRUE);
4157 
4158     gst_query_parse_position (fold-&gt;query, NULL, &amp;position);
4159 
4160     GST_DEBUG_OBJECT (item, &quot;got position %&quot; G_GINT64_FORMAT, position);
4161 
4162     if (position &gt; fold-&gt;max)
4163       fold-&gt;max = position;
4164   }
4165 
4166   return TRUE;
4167 }
4168 
4169 static void
4170 bin_query_position_done (GstBin * bin, QueryFold * fold)
4171 {
4172   GstFormat format;
4173 
4174   gst_query_parse_position (fold-&gt;query, &amp;format, NULL);
4175   /* store max in query result */
4176   gst_query_set_position (fold-&gt;query, format, fold-&gt;max);
4177 
4178   GST_DEBUG_OBJECT (bin, &quot;max position %&quot; G_GINT64_FORMAT, fold-&gt;max);
4179 }
4180 
4181 static gboolean
4182 bin_query_latency_fold (const GValue * vitem, GValue * ret, QueryFold * fold)
4183 {
4184   gboolean res = FALSE;
4185   GstObject *item = g_value_get_object (vitem);
4186   if (GST_IS_PAD (item))
4187     res = gst_pad_query (GST_PAD (item), fold-&gt;query);
4188   else
4189     res = gst_element_query (GST_ELEMENT (item), fold-&gt;query);
4190   if (res) {
4191     GstClockTime min, max;
4192     gboolean live;
4193 
4194     gst_query_parse_latency (fold-&gt;query, &amp;live, &amp;min, &amp;max);
4195 
4196     GST_DEBUG_OBJECT (item,
4197         &quot;got latency min %&quot; GST_TIME_FORMAT &quot;, max %&quot; GST_TIME_FORMAT
4198         &quot;, live %d&quot;, GST_TIME_ARGS (min), GST_TIME_ARGS (max), live);
4199 
4200     /* for the combined latency we collect the MAX of all min latencies and
4201      * the MIN of all max latencies */
4202     if (live) {
4203       if (min &gt; fold-&gt;min)
4204         fold-&gt;min = min;
4205       if (fold-&gt;max == -1)
4206         fold-&gt;max = max;
4207       else if (max &lt; fold-&gt;max)
4208         fold-&gt;max = max;
4209       if (!fold-&gt;live)
4210         fold-&gt;live = live;
4211     }
4212   } else {
4213     g_value_set_boolean (ret, FALSE);
4214     GST_DEBUG_OBJECT (item, &quot;failed query&quot;);
4215   }
4216 
4217   return TRUE;
4218 }
4219 
4220 static void
4221 bin_query_latency_done (GstBin * bin, QueryFold * fold)
4222 {
4223   /* store max in query result */
4224   gst_query_set_latency (fold-&gt;query, fold-&gt;live, fold-&gt;min, fold-&gt;max);
4225 
4226   GST_DEBUG_OBJECT (bin,
4227       &quot;latency min %&quot; GST_TIME_FORMAT &quot;, max %&quot; GST_TIME_FORMAT
4228       &quot;, live %d&quot;, GST_TIME_ARGS (fold-&gt;min), GST_TIME_ARGS (fold-&gt;max),
4229       fold-&gt;live);
4230 }
4231 
4232 /* generic fold, return first valid result */
4233 static gboolean
4234 bin_query_generic_fold (const GValue * vitem, GValue * ret, QueryFold * fold)
4235 {
4236   gboolean res = FALSE;
4237   GstObject *item = g_value_get_object (vitem);
4238   if (GST_IS_PAD (item))
4239     res = gst_pad_query (GST_PAD (item), fold-&gt;query);
4240   else
4241     res = gst_element_query (GST_ELEMENT (item), fold-&gt;query);
4242   if (res) {
4243     g_value_set_boolean (ret, TRUE);
4244     GST_DEBUG_OBJECT (item, &quot;answered query %p&quot;, fold-&gt;query);
4245   }
4246 
4247   /* and stop as soon as we have a valid result */
4248   return !res;
4249 }
4250 
4251 /* Perform a query iteration for the given bin. The query is stored in
4252  * QueryFold and iter should be either a GstPad iterator or a
4253  * GstElement iterator. */
4254 static gboolean
4255 bin_iterate_fold (GstBin * bin, GstIterator * iter, QueryInitFunction fold_init,
4256     QueryDoneFunction fold_done, GstIteratorFoldFunction fold_func,
4257     QueryFold * fold_data, gboolean default_return)
4258 {
4259   gboolean res = default_return;
4260   GValue ret = { 0 };
4261   /* set the result of the query to FALSE initially */
4262   g_value_init (&amp;ret, G_TYPE_BOOLEAN);
4263   g_value_set_boolean (&amp;ret, res);
4264 
4265   while (TRUE) {
4266     GstIteratorResult ires;
4267 
4268     ires = gst_iterator_fold (iter, fold_func, &amp;ret, fold_data);
4269 
4270     switch (ires) {
4271       case GST_ITERATOR_RESYNC:
4272         gst_iterator_resync (iter);
4273         if (fold_init)
4274           fold_init (bin, fold_data);
4275         g_value_set_boolean (&amp;ret, res);
4276         break;
4277       case GST_ITERATOR_OK:
4278       case GST_ITERATOR_DONE:
4279         res = g_value_get_boolean (&amp;ret);
4280         if (fold_done != NULL &amp;&amp; res)
4281           fold_done (bin, fold_data);
4282         goto done;
4283       default:
4284         res = FALSE;
4285         goto done;
4286     }
4287   }
4288 done:
4289   return res;
4290 }
4291 
4292 static gboolean
4293 gst_bin_query (GstElement * element, GstQuery * query)
4294 {
4295   GstBin *bin = GST_BIN_CAST (element);
4296   GstIterator *iter;
4297   gboolean default_return = FALSE;
4298   gboolean res = FALSE;
4299   gboolean src_pads_query_result = FALSE;
4300   GstIteratorFoldFunction fold_func;
4301   QueryInitFunction fold_init = NULL;
4302   QueryDoneFunction fold_done = NULL;
4303   QueryFold fold_data;
4304 
4305   switch (GST_QUERY_TYPE (query)) {
4306     case GST_QUERY_DURATION:
4307     {
4308       /* FIXME: implement duration caching in GstBin again */
4309 #if 0
4310       GList *cached;
4311       GstFormat qformat;
4312 
4313       gst_query_parse_duration (query, &amp;qformat, NULL);
4314 
4315       /* find cached duration query */
4316       GST_OBJECT_LOCK (bin);
4317       for (cached = bin-&gt;messages; cached; cached = g_list_next (cached)) {
4318         GstMessage *message = (GstMessage *) cached-&gt;data;
4319 
4320         if (GST_MESSAGE_TYPE (message) == GST_MESSAGE_DURATION_CHANGED &amp;&amp;
4321             GST_MESSAGE_SRC (message) == GST_OBJECT_CAST (bin)) {
4322           GstFormat format;
4323           gint64 duration;
4324 
4325           gst_message_parse_duration (message, &amp;format, &amp;duration);
4326 
4327           /* if cached same format, copy duration in query result */
4328           if (format == qformat) {
4329             GST_DEBUG_OBJECT (bin, &quot;return cached duration %&quot; G_GINT64_FORMAT,
4330                 duration);
4331             GST_OBJECT_UNLOCK (bin);
4332 
4333             gst_query_set_duration (query, qformat, duration);
4334             res = TRUE;
4335             goto exit;
4336           }
4337         }
4338       }
4339       GST_OBJECT_UNLOCK (bin);
4340 #else
4341 #ifndef GST_DISABLE_GST_DEBUG
4342       G_STMT_START {
4343         /* Quieten this particularly annoying FIXME a bit: */
4344         static gboolean printed_fixme = FALSE;
4345         if (!printed_fixme) {
<a name="20" id="anc20"></a><span class="line-modified">4346           GST_FIXME (&quot;implement duration caching in GstBin again&quot;);</span>
4347           printed_fixme = TRUE;
4348         }
4349       }
4350       G_STMT_END;
4351 #endif
4352 #endif
4353       /* no cached value found, iterate and collect durations */
4354       fold_func = (GstIteratorFoldFunction) bin_query_duration_fold;
4355       fold_init = bin_query_min_max_init;
4356       fold_done = bin_query_duration_done;
4357       break;
4358     }
4359     case GST_QUERY_POSITION:
4360     {
4361       fold_func = (GstIteratorFoldFunction) bin_query_position_fold;
4362       fold_init = bin_query_min_max_init;
4363       fold_done = bin_query_position_done;
4364       break;
4365     }
4366     case GST_QUERY_LATENCY:
4367     {
4368       fold_func = (GstIteratorFoldFunction) bin_query_latency_fold;
4369       fold_init = bin_query_min_max_init;
4370       fold_done = bin_query_latency_done;
4371       default_return = TRUE;
4372       break;
4373     }
4374     default:
4375       fold_func = (GstIteratorFoldFunction) bin_query_generic_fold;
4376       break;
4377   }
4378 
4379   fold_data.query = query;
4380 
4381   iter = gst_bin_iterate_sinks (bin);
4382   GST_DEBUG_OBJECT (bin, &quot;Sending query %p (type %s) to sink children&quot;,
4383       query, GST_QUERY_TYPE_NAME (query));
4384 
4385   if (fold_init)
4386     fold_init (bin, &amp;fold_data);
4387 
4388   res =
4389       bin_iterate_fold (bin, iter, fold_init, fold_done, fold_func, &amp;fold_data,
4390       default_return);
4391   gst_iterator_free (iter);
4392 
4393   if (!res) {
4394     /* Query the source pads of the element */
4395     iter = gst_element_iterate_src_pads (element);
4396     src_pads_query_result =
4397         bin_iterate_fold (bin, iter, fold_init, fold_done, fold_func,
4398         &amp;fold_data, default_return);
4399     gst_iterator_free (iter);
4400 
4401     if (src_pads_query_result)
4402       res = TRUE;
4403   }
4404 
4405   GST_DEBUG_OBJECT (bin, &quot;query %p result %d&quot;, query, res);
4406 
4407   return res;
4408 }
4409 
4410 static void
4411 set_context (const GValue * item, gpointer user_data)
4412 {
4413   GstElement *element = g_value_get_object (item);
4414 
4415   gst_element_set_context (element, user_data);
4416 }
4417 
4418 static void
4419 gst_bin_set_context (GstElement * element, GstContext * context)
4420 {
4421   GstBin *bin;
4422   GstIterator *children;
4423 
4424   g_return_if_fail (GST_IS_BIN (element));
4425 
4426   bin = GST_BIN (element);
4427 
4428   GST_ELEMENT_CLASS (parent_class)-&gt;set_context (element, context);
4429 
4430   children = gst_bin_iterate_elements (bin);
4431   while (gst_iterator_foreach (children, set_context,
4432           context) == GST_ITERATOR_RESYNC)
4433     gst_iterator_resync (children);
4434   gst_iterator_free (children);
4435 }
4436 
4437 static gint
4438 compare_name (const GValue * velement, const gchar * name)
4439 {
4440   gint eq;
4441   GstElement *element = g_value_get_object (velement);
4442 
4443   GST_OBJECT_LOCK (element);
4444   eq = strcmp (GST_ELEMENT_NAME (element), name);
4445   GST_OBJECT_UNLOCK (element);
4446 
4447   return eq;
4448 }
4449 
4450 /**
4451  * gst_bin_get_by_name:
4452  * @bin: a #GstBin
4453  * @name: the element name to search for
4454  *
4455  * Gets the element with the given name from a bin. This
4456  * function recurses into child bins.
4457  *
4458  * Returns %NULL if no element with the given name is found in the bin.
4459  *
4460  * MT safe.  Caller owns returned reference.
4461  *
4462  * Returns: (transfer full) (nullable): the #GstElement with the given
4463  * name, or %NULL
4464  */
4465 GstElement *
4466 gst_bin_get_by_name (GstBin * bin, const gchar * name)
4467 {
4468   GstIterator *children;
4469   GValue result = { 0, };
4470   GstElement *element;
4471   gboolean found;
4472 
4473   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
4474 
4475   GST_CAT_INFO (GST_CAT_PARENTAGE, &quot;[%s]: looking up child element %s&quot;,
4476       GST_ELEMENT_NAME (bin), name);
4477 
4478   children = gst_bin_iterate_recurse (bin);
4479   found = gst_iterator_find_custom (children,
4480       (GCompareFunc) compare_name, &amp;result, (gpointer) name);
4481   gst_iterator_free (children);
4482 
4483   if (found) {
4484     element = g_value_dup_object (&amp;result);
4485     g_value_unset (&amp;result);
4486   } else {
4487     element = NULL;
4488   }
4489 
4490   return element;
4491 }
4492 
4493 /**
4494  * gst_bin_get_by_name_recurse_up:
4495  * @bin: a #GstBin
4496  * @name: the element name to search for
4497  *
4498  * Gets the element with the given name from this bin. If the
4499  * element is not found, a recursion is performed on the parent bin.
4500  *
4501  * Returns %NULL if:
4502  * - no element with the given name is found in the bin
4503  *
4504  * MT safe.  Caller owns returned reference.
4505  *
4506  * Returns: (transfer full) (nullable): the #GstElement with the given
4507  * name, or %NULL
4508  */
4509 GstElement *
4510 gst_bin_get_by_name_recurse_up (GstBin * bin, const gchar * name)
4511 {
4512   GstElement *result;
4513 
4514   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
4515   g_return_val_if_fail (name != NULL, NULL);
4516 
4517   result = gst_bin_get_by_name (bin, name);
4518 
4519   if (!result) {
4520     GstObject *parent;
4521 
4522     parent = gst_object_get_parent (GST_OBJECT_CAST (bin));
4523     if (parent) {
4524       if (GST_IS_BIN (parent)) {
4525         result = gst_bin_get_by_name_recurse_up (GST_BIN_CAST (parent), name);
4526       }
4527       gst_object_unref (parent);
4528     }
4529   }
4530 
4531   return result;
4532 }
4533 
4534 static gint
4535 compare_interface (const GValue * velement, GValue * interface)
4536 {
4537   GstElement *element = g_value_get_object (velement);
4538   GType interface_type = (GType) g_value_get_pointer (interface);
4539   gint ret;
4540 
4541   if (G_TYPE_CHECK_INSTANCE_TYPE (element, interface_type)) {
4542     ret = 0;
4543   } else {
4544     ret = 1;
4545   }
4546   return ret;
4547 }
4548 
4549 /**
4550  * gst_bin_get_by_interface:
4551  * @bin: a #GstBin
4552  * @iface: the #GType of an interface
4553  *
4554  * Looks for an element inside the bin that implements the given
4555  * interface. If such an element is found, it returns the element.
4556  * You can cast this element to the given interface afterwards.  If you want
4557  * all elements that implement the interface, use
4558  * gst_bin_iterate_all_by_interface(). This function recurses into child bins.
4559  *
4560  * MT safe.  Caller owns returned reference.
4561  *
4562  * Returns: (transfer full) (nullable): A #GstElement inside the bin
4563  * implementing the interface
4564  */
4565 GstElement *
4566 gst_bin_get_by_interface (GstBin * bin, GType iface)
4567 {
4568   GstIterator *children;
4569   GValue result = { 0, };
4570   GstElement *element;
4571   gboolean found;
4572   GValue viface = { 0, };
4573 
4574   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
4575   g_return_val_if_fail (G_TYPE_IS_INTERFACE (iface), NULL);
4576 
4577   g_value_init (&amp;viface, G_TYPE_POINTER);
4578   g_value_set_pointer (&amp;viface, (gpointer) iface);
4579 
4580   children = gst_bin_iterate_recurse (bin);
4581   found = gst_iterator_find_custom (children, (GCompareFunc) compare_interface,
4582       &amp;result, &amp;viface);
4583   gst_iterator_free (children);
4584 
4585   if (found) {
4586     element = g_value_dup_object (&amp;result);
4587     g_value_unset (&amp;result);
4588   } else {
4589     element = NULL;
4590   }
4591   g_value_unset (&amp;viface);
4592 
4593   return element;
4594 }
4595 
4596 /**
4597  * gst_bin_iterate_all_by_interface:
4598  * @bin: a #GstBin
4599  * @iface: the #GType of an interface
4600  *
4601  * Looks for all elements inside the bin that implements the given
4602  * interface. You can safely cast all returned elements to the given interface.
4603  * The function recurses inside child bins. The iterator will yield a series
4604  * of #GstElement that should be unreffed after use.
4605  *
4606  * MT safe.  Caller owns returned value.
4607  *
4608  * Returns: (transfer full) (nullable): a #GstIterator of #GstElement
4609  *     for all elements in the bin implementing the given interface,
4610  *     or %NULL
4611  */
4612 GstIterator *
4613 gst_bin_iterate_all_by_interface (GstBin * bin, GType iface)
4614 {
4615   GstIterator *children;
4616   GstIterator *result;
4617   GValue viface = { 0, };
4618 
4619   g_return_val_if_fail (GST_IS_BIN (bin), NULL);
4620   g_return_val_if_fail (G_TYPE_IS_INTERFACE (iface), NULL);
4621 
4622   g_value_init (&amp;viface, G_TYPE_POINTER);
4623   g_value_set_pointer (&amp;viface, (gpointer) iface);
4624 
4625   children = gst_bin_iterate_recurse (bin);
4626   result = gst_iterator_filter (children, (GCompareFunc) compare_interface,
4627       &amp;viface);
4628 
4629   g_value_unset (&amp;viface);
4630 
4631   return result;
4632 }
<a name="21" id="anc21"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="21" type="hidden" />
</body>
</html>