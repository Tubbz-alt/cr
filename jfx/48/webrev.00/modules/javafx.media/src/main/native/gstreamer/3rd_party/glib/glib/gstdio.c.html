<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gstdio.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* gstdio.c - wrappers for C library functions
   2  *
   3  * Copyright 2004 Tor Lillqvist
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public License
  16  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  */
  18 
  19 #include &quot;config.h&quot;
  20 #include &quot;glibconfig.h&quot;
  21 
  22 /* Don&#39;t redefine (for example) g_open() to open(), since we actually want to
  23  * define g_open() in this file and export it as a symbol. See gstdio.h. */
  24 #define G_STDIO_WRAP_ON_UNIX
  25 
  26 #include &lt;sys/types.h&gt;
  27 #include &lt;sys/stat.h&gt;
  28 #include &lt;fcntl.h&gt;
  29 
  30 #ifdef G_OS_UNIX
  31 #include &lt;unistd.h&gt;
  32 #endif
  33 
  34 #ifdef G_OS_WIN32
  35 #include &lt;windows.h&gt;
  36 #include &lt;errno.h&gt;
  37 #include &lt;wchar.h&gt;
  38 #include &lt;direct.h&gt;
  39 #include &lt;io.h&gt;
  40 #include &lt;sys/utime.h&gt;
  41 #include &lt;stdlib.h&gt; /* for MB_CUR_MAX */
  42 #else
  43 #include &lt;utime.h&gt;
  44 #include &lt;errno.h&gt;
  45 #endif
  46 
  47 #include &quot;gstdio.h&quot;
  48 #include &quot;gstdioprivate.h&quot;
  49 
  50 #if !defined (G_OS_UNIX) &amp;&amp; !defined (G_OS_WIN32)
  51 #error Please port this to your operating system
  52 #endif
  53 
  54 #if defined (_MSC_VER) &amp;&amp; !defined(_WIN64)
  55 #undef _wstat
  56 #define _wstat _wstat32
  57 #endif
  58 
  59 #if defined (G_OS_WIN32)
  60 
  61 /* We can&#39;t include Windows DDK and Windows SDK simultaneously,
  62  * so let&#39;s copy this here from MinGW-w64 DDK.
  63  * The structure is ultimately documented here:
  64  * https://msdn.microsoft.com/en-us/library/ff552012(v=vs.85).aspx
  65  */
  66 typedef struct _REPARSE_DATA_BUFFER
  67 {
  68   ULONG  ReparseTag;
  69   USHORT ReparseDataLength;
  70   USHORT Reserved;
  71   union
  72   {
  73     struct
  74     {
  75       USHORT SubstituteNameOffset;
  76       USHORT SubstituteNameLength;
  77       USHORT PrintNameOffset;
  78       USHORT PrintNameLength;
  79       ULONG  Flags;
  80       WCHAR  PathBuffer[1];
  81     } SymbolicLinkReparseBuffer;
  82     struct
  83     {
  84       USHORT SubstituteNameOffset;
  85       USHORT SubstituteNameLength;
  86       USHORT PrintNameOffset;
  87       USHORT PrintNameLength;
  88       WCHAR  PathBuffer[1];
  89     } MountPointReparseBuffer;
  90     struct
  91     {
  92       UCHAR  DataBuffer[1];
  93     } GenericReparseBuffer;
  94   };
  95 } REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;
  96 
  97 static int
  98 w32_error_to_errno (DWORD error_code)
  99 {
 100   switch (error_code)
 101     {
 102     case ERROR_ACCESS_DENIED:
 103       return EACCES;
 104       break;
 105     case ERROR_ALREADY_EXISTS:
 106     case ERROR_FILE_EXISTS:
 107       return EEXIST;
 108     case ERROR_FILE_NOT_FOUND:
 109       return ENOENT;
 110       break;
 111     case ERROR_INVALID_FUNCTION:
 112       return EFAULT;
 113       break;
 114     case ERROR_INVALID_HANDLE:
 115       return EBADF;
 116       break;
 117     case ERROR_INVALID_PARAMETER:
 118       return EINVAL;
 119       break;
 120     case ERROR_LOCK_VIOLATION:
 121     case ERROR_SHARING_VIOLATION:
 122       return EACCES;
 123       break;
 124     case ERROR_NOT_ENOUGH_MEMORY:
 125     case ERROR_OUTOFMEMORY:
 126       return ENOMEM;
 127       break;
 128     case ERROR_NOT_SAME_DEVICE:
 129       return EXDEV;
 130       break;
 131     case ERROR_PATH_NOT_FOUND:
 132       return ENOENT; /* or ELOOP, or ENAMETOOLONG */
 133       break;
 134     default:
 135       return EIO;
 136       break;
 137     }
 138 }
 139 
 140 #include &quot;gstdio-private.c&quot;
 141 
 142 /* Windows implementation of fopen() does not accept modes such as
 143  * &quot;wb+&quot;. The &#39;b&#39; needs to be appended to &quot;w+&quot;, i.e. &quot;w+b&quot;. Note
 144  * that otherwise these 2 modes are supposed to be aliases, hence
 145  * swappable at will. TODO: Is this still true?
 146  */
 147 static void
 148 _g_win32_fix_mode (wchar_t *mode)
 149 {
 150   wchar_t *ptr;
 151   wchar_t temp;
 152 
 153   ptr = wcschr (mode, L&#39;+&#39;);
 154   if (ptr != NULL &amp;&amp; (ptr - mode) &gt; 1)
 155     {
 156       temp = mode[1];
 157       mode[1] = *ptr;
 158       *ptr = temp;
 159     }
 160 }
 161 
 162 /* From
 163  * https://support.microsoft.com/en-ca/help/167296/how-to-convert-a-unix-time-t-to-a-win32-filetime-or-systemtime
 164  * FT = UT * 10000000 + 116444736000000000.
 165  * Therefore:
 166  * UT = (FT - 116444736000000000) / 10000000.
 167  * Converts FILETIME to unix epoch time in form
 168  * of a signed 64-bit integer (can be negative).
 169  */
 170 static gint64
 171 _g_win32_filetime_to_unix_time (FILETIME *ft)
 172 {
 173   gint64 result;
 174   /* 1 unit of FILETIME is 100ns */
 175   const gint64 hundreds_of_usec_per_sec = 10000000;
 176   /* The difference between January 1, 1601 UTC (FILETIME epoch) and UNIX epoch
 177    * in hundreds of nanoseconds.
 178    */
 179   const gint64 filetime_unix_epoch_offset = 116444736000000000;
 180 
 181   result = ((gint64) ft-&gt;dwLowDateTime) | (((gint64) ft-&gt;dwHighDateTime) &lt;&lt; 32);
 182   return (result - filetime_unix_epoch_offset) / hundreds_of_usec_per_sec;
 183 }
 184 
 185 #  ifdef _MSC_VER
 186 #    ifndef S_IXUSR
 187 #      define _S_IRUSR _S_IREAD
 188 #      define _S_IWUSR _S_IWRITE
 189 #      define _S_IXUSR _S_IEXEC
 190 #      define S_IRUSR _S_IRUSR
 191 #      define S_IWUSR _S_IWUSR
 192 #      define S_IXUSR _S_IXUSR
 193 #      define S_IRGRP (S_IRUSR &gt;&gt; 3)
 194 #      define S_IWGRP (S_IWUSR &gt;&gt; 3)
 195 #      define S_IXGRP (S_IXUSR &gt;&gt; 3)
 196 #      define S_IROTH (S_IRGRP &gt;&gt; 3)
 197 #      define S_IWOTH (S_IWGRP &gt;&gt; 3)
 198 #      define S_IXOTH (S_IXGRP &gt;&gt; 3)
 199 #    endif
 200 #    ifndef S_ISDIR
 201 #      define S_ISDIR(m) (((m) &amp; _S_IFMT) == _S_IFDIR)
 202 #    endif
 203 #  endif
 204 
 205 /* Uses filename and BHFI to fill a stat64 structure.
 206  * Tries to reproduce the behaviour and quirks of MS C runtime stat().
 207  */
 208 static int
 209 _g_win32_fill_statbuf_from_handle_info (const wchar_t              *filename,
 210                                         const wchar_t              *filename_target,
 211                                         BY_HANDLE_FILE_INFORMATION *handle_info,
 212                                         struct __stat64            *statbuf)
 213 {
 214   wchar_t drive_letter_w = 0;
 215   size_t drive_letter_size = MB_CUR_MAX;
 216   char *drive_letter = _alloca (drive_letter_size);
 217 
 218   /* If filename (target or link) is absolute,
 219    * then use the drive letter from it as-is.
 220    */
 221   if (filename_target != NULL &amp;&amp;
 222       filename_target[0] != L&#39;\0&#39; &amp;&amp;
 223       filename_target[1] == L&#39;:&#39;)
 224     drive_letter_w = filename_target[0];
 225   else if (filename[0] != L&#39;\0&#39; &amp;&amp;
 226            filename[1] == L&#39;:&#39;)
 227     drive_letter_w = filename[0];
 228 
 229   if (drive_letter_w &gt; 0 &amp;&amp;
 230       iswalpha (drive_letter_w) &amp;&amp;
 231       iswascii (drive_letter_w) &amp;&amp;
 232       wctomb (drive_letter, drive_letter_w) == 1)
 233     statbuf-&gt;st_dev = toupper (drive_letter[0]) - &#39;A&#39;; /* 0 means A: drive */
 234   else
 235     /* Otherwise use the PWD drive.
 236      * Return value of 0 gives us 0 - 1 = -1,
 237      * which is the &quot;no idea&quot; value for st_dev.
 238      */
 239     statbuf-&gt;st_dev = _getdrive () - 1;
 240 
 241   statbuf-&gt;st_rdev = statbuf-&gt;st_dev;
 242   /* Theoretically, it&#39;s possible to set it for ext-FS. No idea how.
 243    * Meaningless for all filesystems that Windows normally uses.
 244    */
 245   statbuf-&gt;st_ino = 0;
 246   statbuf-&gt;st_mode = 0;
 247 
 248   if ((handle_info-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)
 249     statbuf-&gt;st_mode |= S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;
 250   else
 251     statbuf-&gt;st_mode |= S_IFREG;
 252   /* No idea what S_IFCHR means here. */
 253   /* S_IFIFO is not even mentioned in MSDN */
 254   /* S_IFBLK is also not mentioned */
 255 
 256   /* The aim here is to reproduce MS stat() behaviour,
 257    * even if it&#39;s braindead.
 258    */
 259   statbuf-&gt;st_mode |= S_IRUSR | S_IRGRP | S_IROTH;
 260   if ((handle_info-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_READONLY) != FILE_ATTRIBUTE_READONLY)
 261     statbuf-&gt;st_mode |= S_IWUSR | S_IWGRP | S_IWOTH;
 262 
 263   if (!S_ISDIR (statbuf-&gt;st_mode))
 264     {
 265       const wchar_t *name;
 266       const wchar_t *dot = NULL;
 267 
 268       if (filename_target != NULL)
 269         name = filename_target;
 270       else
 271         name = filename;
 272 
 273       do
 274         {
 275           wchar_t *last_dot = wcschr (name, L&#39;.&#39;);
 276           if (last_dot == NULL)
 277             break;
 278           dot = last_dot;
 279           name = &amp;last_dot[1];
 280         }
 281       while (TRUE);
 282 
 283       if ((dot != NULL &amp;&amp;
 284           (wcsicmp (dot, L&quot;.exe&quot;) == 0 ||
 285            wcsicmp (dot, L&quot;.com&quot;) == 0 ||
 286            wcsicmp (dot, L&quot;.bat&quot;) == 0 ||
 287            wcsicmp (dot, L&quot;.cmd&quot;) == 0)))
 288         statbuf-&gt;st_mode |= S_IXUSR | S_IXGRP | S_IXOTH;
 289     }
 290 
 291   statbuf-&gt;st_nlink = handle_info-&gt;nNumberOfLinks;
 292   statbuf-&gt;st_uid = statbuf-&gt;st_gid = 0;
 293   statbuf-&gt;st_size = (((guint64) handle_info-&gt;nFileSizeHigh) &lt;&lt; 32) | handle_info-&gt;nFileSizeLow;
 294   statbuf-&gt;st_ctime = _g_win32_filetime_to_unix_time (&amp;handle_info-&gt;ftCreationTime);
 295   statbuf-&gt;st_mtime = _g_win32_filetime_to_unix_time (&amp;handle_info-&gt;ftLastWriteTime);
 296   statbuf-&gt;st_atime = _g_win32_filetime_to_unix_time (&amp;handle_info-&gt;ftLastAccessTime);
 297 
 298   return 0;
 299 }
 300 
 301 /* Fills our private stat-like structure using data from
 302  * a normal stat64 struct, BHFI, FSI and a reparse tag.
 303  */
 304 static void
 305 _g_win32_fill_privatestat (const struct __stat64            *statbuf,
 306                            const BY_HANDLE_FILE_INFORMATION *handle_info,
 307                            const FILE_STANDARD_INFO         *std_info,
 308                            DWORD                             reparse_tag,
 309                            GWin32PrivateStat                *buf)
 310 {
 311   buf-&gt;st_dev = statbuf-&gt;st_dev;
 312   buf-&gt;st_mode = statbuf-&gt;st_mode;
 313   buf-&gt;volume_serial = handle_info-&gt;dwVolumeSerialNumber;
 314   buf-&gt;file_index = (((guint64) handle_info-&gt;nFileIndexHigh) &lt;&lt; 32) | handle_info-&gt;nFileIndexLow;
 315   buf-&gt;attributes = handle_info-&gt;dwFileAttributes;
 316   buf-&gt;st_nlink = handle_info-&gt;nNumberOfLinks;
 317   buf-&gt;st_size = (((guint64) handle_info-&gt;nFileSizeHigh) &lt;&lt; 32) | handle_info-&gt;nFileSizeLow;
 318   buf-&gt;allocated_size = std_info-&gt;AllocationSize.QuadPart;
 319 
 320   buf-&gt;reparse_tag = reparse_tag;
 321 
 322   buf-&gt;st_ctime = statbuf-&gt;st_ctime;
 323   buf-&gt;st_atime = statbuf-&gt;st_atime;
 324   buf-&gt;st_mtime = statbuf-&gt;st_mtime;
 325 }
 326 
 327 /* Read the link data from a symlink/mountpoint represented
 328  * by the handle. Also reads reparse tag.
 329  * @reparse_tag receives the tag. Can be %NULL if @buf or @alloc_buf
 330  *              is non-NULL.
 331  * @buf receives the link data. Can be %NULL if reparse_tag is non-%NULL.
 332  *      Mutually-exclusive with @alloc_buf.
 333  * @buf_size is the size of the @buf, in bytes.
 334  * @alloc_buf points to a location where internally-allocated buffer
 335  *            pointer will be written. That buffer receives the
 336  *            link data. Mutually-exclusive with @buf.
 337  * @terminate ensures that the buffer is NUL-terminated if
 338  *            it isn&#39;t already. Note that this can erase useful
 339  *            data if @buf is provided and @buf_size is too small.
 340  *            Specifically, with @buf_size &lt;= 2 the buffer will
 341  *            receive an empty string, even if there is some
 342  *            data in the reparse point.
 343  * The contents of @buf or @alloc_buf are presented as-is - could
 344  * be non-NUL-terminated (unless @terminate is %TRUE) or even malformed.
 345  * Returns the number of bytes (!) placed into @buf or @alloc_buf,
 346  * including NUL-terminator (if any).
 347  *
 348  * Returned value of 0 means that there&#39;s no recognizable data in the
 349  * reparse point. @alloc_buf will not be allocated in that case,
 350  * and @buf will be left unmodified.
 351  *
 352  * If @buf and @alloc_buf are %NULL, returns 0 to indicate success.
 353  * Returns -1 to indicate an error, sets errno.
 354  */
 355 static int
 356 _g_win32_readlink_handle_raw (HANDLE      h,
 357                               DWORD      *reparse_tag,
 358                               gunichar2  *buf,
 359                               gsize       buf_size,
 360                               gunichar2 **alloc_buf,
 361                               gboolean    terminate)
 362 {
 363   DWORD error_code;
 364   DWORD returned_bytes = 0;
 365   BYTE *data;
 366   gsize to_copy;
 367   /* This is 16k. It&#39;s impossible to make DeviceIoControl() tell us
 368    * the required size. NtFsControlFile() does have such a feature,
 369    * but for some reason it doesn&#39;t work with CreateFile()-returned handles.
 370    * The only alternative is to repeatedly call DeviceIoControl()
 371    * with bigger and bigger buffers, until it succeeds.
 372    * We choose to sacrifice stack space for speed.
 373    */
 374   BYTE max_buffer[sizeof (REPARSE_DATA_BUFFER) + MAXIMUM_REPARSE_DATA_BUFFER_SIZE] = {0,};
 375   DWORD max_buffer_size = sizeof (REPARSE_DATA_BUFFER) + MAXIMUM_REPARSE_DATA_BUFFER_SIZE;
 376   REPARSE_DATA_BUFFER *rep_buf;
 377 
 378   g_return_val_if_fail ((buf != NULL || alloc_buf != NULL || reparse_tag != NULL) &amp;&amp;
 379                         (buf == NULL || alloc_buf == NULL),
 380                         -1);
 381 
 382   if (!DeviceIoControl (h, FSCTL_GET_REPARSE_POINT, NULL, 0,
 383                         max_buffer,
 384                         max_buffer_size,
 385                         &amp;returned_bytes, NULL))
 386     {
 387       error_code = GetLastError ();
 388       errno = w32_error_to_errno (error_code);
 389       return -1;
 390     }
 391 
 392   rep_buf = (REPARSE_DATA_BUFFER *) max_buffer;
 393 
 394   if (reparse_tag != NULL)
 395     *reparse_tag = rep_buf-&gt;ReparseTag;
 396 
 397   if (buf == NULL &amp;&amp; alloc_buf == NULL)
 398     return 0;
 399 
 400   if (rep_buf-&gt;ReparseTag == IO_REPARSE_TAG_SYMLINK)
 401     {
 402       data = &amp;((BYTE *) rep_buf-&gt;SymbolicLinkReparseBuffer.PathBuffer)[rep_buf-&gt;SymbolicLinkReparseBuffer.SubstituteNameOffset];
 403 
 404       to_copy = rep_buf-&gt;SymbolicLinkReparseBuffer.SubstituteNameLength;
 405     }
 406   else if (rep_buf-&gt;ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)
 407     {
 408       data = &amp;((BYTE *) rep_buf-&gt;MountPointReparseBuffer.PathBuffer)[rep_buf-&gt;MountPointReparseBuffer.SubstituteNameOffset];
 409 
 410       to_copy = rep_buf-&gt;MountPointReparseBuffer.SubstituteNameLength;
 411     }
 412   else
 413     to_copy = 0;
 414 
 415   return _g_win32_copy_and_maybe_terminate (data, to_copy, buf, buf_size, alloc_buf, terminate);
 416 }
 417 
 418 /* Read the link data from a symlink/mountpoint represented
 419  * by the @filename.
 420  * @filename is the name of the file.
 421  * @reparse_tag receives the tag. Can be %NULL if @buf or @alloc_buf
 422  *              is non-%NULL.
 423  * @buf receives the link data. Mutually-exclusive with @alloc_buf.
 424  * @buf_size is the size of the @buf, in bytes.
 425  * @alloc_buf points to a location where internally-allocated buffer
 426  *            pointer will be written. That buffer receives the
 427  *            link data. Mutually-exclusive with @buf.
 428  * @terminate ensures that the buffer is NUL-terminated if
 429  *            it isn&#39;t already
 430  * The contents of @buf or @alloc_buf are presented as-is - could
 431  * be non-NUL-terminated (unless @terminate is TRUE) or even malformed.
 432  * Returns the number of bytes (!) placed into @buf or @alloc_buf.
 433  * Returned value of 0 means that there&#39;s no recognizable data in the
 434  * reparse point. @alloc_buf will not be allocated in that case,
 435  * and @buf will be left unmodified.
 436  * If @buf and @alloc_buf are %NULL, returns 0 to indicate success.
 437  * Returns -1 to indicate an error, sets errno.
 438  */
 439 static int
 440 _g_win32_readlink_utf16_raw (const gunichar2  *filename,
 441                              DWORD            *reparse_tag,
 442                              gunichar2        *buf,
 443                              gsize             buf_size,
 444                              gunichar2       **alloc_buf,
 445                              gboolean          terminate)
 446 {
 447   HANDLE h;
 448   DWORD attributes;
 449   DWORD to_copy;
 450   DWORD error_code;
 451 
 452   if ((attributes = GetFileAttributesW (filename)) == 0)
 453     {
 454       error_code = GetLastError ();
 455       errno = w32_error_to_errno (error_code);
 456       return -1;
 457     }
 458 
 459   if ((attributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == 0)
 460     {
 461       errno = EINVAL;
 462       return -1;
 463     }
 464 
 465   /* To read symlink target we need to open the file as a reparse
 466    * point and use DeviceIoControl() on it.
 467    */
 468   h = CreateFileW (filename,
 469                    FILE_READ_EA,
 470                    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
 471                    NULL, OPEN_EXISTING,
 472                    FILE_ATTRIBUTE_NORMAL
 473                    | FILE_FLAG_OPEN_REPARSE_POINT
 474                    | (attributes &amp; FILE_ATTRIBUTE_DIRECTORY ? FILE_FLAG_BACKUP_SEMANTICS : 0),
 475                    NULL);
 476 
 477   if (h == INVALID_HANDLE_VALUE)
 478     {
 479       error_code = GetLastError ();
 480       errno = w32_error_to_errno (error_code);
 481       return -1;
 482     }
 483 
 484   to_copy = _g_win32_readlink_handle_raw (h, reparse_tag, buf, buf_size, alloc_buf, terminate);
 485 
 486   CloseHandle (h);
 487 
 488   return to_copy;
 489 }
 490 
 491 /* Read the link data from a symlink/mountpoint represented
 492  * by a UTF-16 filename or a file handle.
 493  * @filename is the name of the file. Mutually-exclusive with @file_handle.
 494  * @file_handle is the handle of the file. Mutually-exclusive with @filename.
 495  * @reparse_tag receives the tag. Can be %NULL if @buf or @alloc_buf
 496  *              is non-%NULL.
 497  * @buf receives the link data. Mutually-exclusive with @alloc_buf.
 498  * @buf_size is the size of the @buf, in bytes.
 499  * @alloc_buf points to a location where internally-allocated buffer
 500  *            pointer will be written. That buffer receives the
 501  *            link data. Mutually-exclusive with @buf.
 502  * @terminate ensures that the buffer is NUL-terminated if
 503  *            it isn&#39;t already
 504  * The contents of @buf or @alloc_buf are adjusted
 505  * (extended or nt object manager prefix is stripped),
 506  * but otherwise they are presented as-is - could be non-NUL-terminated
 507  * (unless @terminate is TRUE) or even malformed.
 508  * Returns the number of bytes (!) placed into @buf or @alloc_buf.
 509  * Returned value of 0 means that there&#39;s no recognizable data in the
 510  * reparse point. @alloc_buf will not be allocated in that case,
 511  * and @buf will be left unmodified.
 512  * Returns -1 to indicate an error, sets errno.
 513  */
 514 static int
 515 _g_win32_readlink_utf16_handle (const gunichar2  *filename,
 516                                 HANDLE            file_handle,
 517                                 DWORD            *reparse_tag,
 518                                 gunichar2        *buf,
 519                                 gsize             buf_size,
 520                                 gunichar2       **alloc_buf,
 521                                 gboolean          terminate)
 522 {
 523   int   result;
 524   gsize string_size;
 525 
 526   g_return_val_if_fail ((buf != NULL || alloc_buf != NULL || reparse_tag != NULL) &amp;&amp;
 527                         (filename != NULL || file_handle != NULL) &amp;&amp;
 528                         (buf == NULL || alloc_buf == NULL) &amp;&amp;
 529                         (filename == NULL || file_handle == NULL),
 530                         -1);
 531 
 532   if (filename)
 533     result = _g_win32_readlink_utf16_raw (filename, reparse_tag, buf, buf_size, alloc_buf, terminate);
 534   else
 535     result = _g_win32_readlink_handle_raw (file_handle, reparse_tag, buf, buf_size, alloc_buf, terminate);
 536 
 537   if (result &lt;= 0)
 538     return result;
 539 
 540   /* Ensure that output is a multiple of sizeof (gunichar2),
 541    * cutting any trailing partial gunichar2, if present.
 542    */
 543   result -= result % sizeof (gunichar2);
 544 
 545   if (result &lt;= 0)
 546     return result;
 547 
 548   /* DeviceIoControl () tends to return filenames as NT Object Manager
 549    * names , i.e. &quot;\\??\\C:\\foo\\bar&quot;.
 550    * Remove the leading 4-byte &quot;\\??\\&quot; prefix, as glib (as well as many W32 API
 551    * functions) is unprepared to deal with it. Unless it has no &#39;x:&#39; drive
 552    * letter part after the prefix, in which case we leave everything
 553    * as-is, because the path could be &quot;\\??\\Volume{GUID}&quot; - stripping
 554    * the prefix will allow it to be confused with relative links
 555    * targeting &quot;Volume{GUID}&quot;.
 556    */
 557   string_size = result / sizeof (gunichar2);
 558   _g_win32_strip_extended_ntobjm_prefix (buf ? buf : *alloc_buf, &amp;string_size);
 559 
 560   return string_size * sizeof (gunichar2);
 561 }
 562 
 563 /* Works like stat() or lstat(), depending on the value of @for_symlink,
 564  * but accepts filename in UTF-16 and fills our custom stat structure.
 565  * The @filename must not have trailing slashes.
 566  */
 567 static int
 568 _g_win32_stat_utf16_no_trailing_slashes (const gunichar2    *filename,
 569                                          GWin32PrivateStat  *buf,
 570                                          gboolean            for_symlink)
 571 {
 572   struct __stat64 statbuf;
 573   BY_HANDLE_FILE_INFORMATION handle_info;
 574   FILE_STANDARD_INFO std_info;
 575   gboolean is_symlink = FALSE;
 576   wchar_t *filename_target = NULL;
 577   DWORD immediate_attributes;
 578   DWORD open_flags;
 579   gboolean is_directory;
 580   DWORD reparse_tag = 0;
 581   DWORD error_code;
 582   BOOL succeeded_so_far;
 583   HANDLE file_handle;
 584 
 585   immediate_attributes = GetFileAttributesW (filename);
 586 
 587   if (immediate_attributes == INVALID_FILE_ATTRIBUTES)
 588     {
 589       error_code = GetLastError ();
 590       errno = w32_error_to_errno (error_code);
 591 
 592       return -1;
 593     }
 594 
 595   is_symlink = (immediate_attributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;
 596   is_directory = (immediate_attributes &amp; FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY;
 597 
 598   open_flags = FILE_ATTRIBUTE_NORMAL;
 599 
 600   if (for_symlink &amp;&amp; is_symlink)
 601     open_flags |= FILE_FLAG_OPEN_REPARSE_POINT;
 602 
 603   if (is_directory)
 604     open_flags |= FILE_FLAG_BACKUP_SEMANTICS;
 605 
 606   file_handle = CreateFileW (filename, FILE_READ_ATTRIBUTES | FILE_READ_EA,
 607                              FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
 608                              NULL, OPEN_EXISTING,
 609                              open_flags,
 610                              NULL);
 611 
 612   if (file_handle == INVALID_HANDLE_VALUE)
 613     {
 614       error_code = GetLastError ();
 615       errno = w32_error_to_errno (error_code);
 616       return -1;
 617     }
 618 
 619   succeeded_so_far = GetFileInformationByHandle (file_handle,
 620                                                  &amp;handle_info);
 621   error_code = GetLastError ();
 622 
 623   if (succeeded_so_far)
 624     {
 625       succeeded_so_far = GetFileInformationByHandleEx (file_handle,
 626                                                        FileStandardInfo,
 627                                                        &amp;std_info,
 628                                                        sizeof (std_info));
 629       error_code = GetLastError ();
 630     }
 631 
 632   if (!succeeded_so_far)
 633     {
 634       CloseHandle (file_handle);
 635       errno = w32_error_to_errno (error_code);
 636       return -1;
 637     }
 638 
 639   /* It&#39;s tempting to use GetFileInformationByHandleEx(FileAttributeTagInfo),
 640    * but it always reports that the ReparseTag is 0.
 641    * We already have a handle open for symlink, use that.
 642    * For the target we have to specify a filename, and the function
 643    * will open another handle internally.
 644    */
 645   if (is_symlink &amp;&amp;
 646       _g_win32_readlink_utf16_handle (for_symlink ? NULL : filename,
 647                                       for_symlink ? file_handle : NULL,
 648                                       &amp;reparse_tag,
 649                                       NULL, 0,
 650                                       for_symlink ? NULL : &amp;filename_target,
 651                                       TRUE) &lt; 0)
 652     {
 653       CloseHandle (file_handle);
 654       return -1;
 655     }
 656 
 657   CloseHandle (file_handle);
 658 
 659   _g_win32_fill_statbuf_from_handle_info (filename,
 660                                           filename_target,
 661                                           &amp;handle_info,
 662                                           &amp;statbuf);
 663   g_free (filename_target);
 664   _g_win32_fill_privatestat (&amp;statbuf,
 665                              &amp;handle_info,
 666                              &amp;std_info,
 667                              reparse_tag,
 668                              buf);
 669 
 670   return 0;
 671 }
 672 
 673 /* Works like fstat(), but fills our custom stat structure. */
 674 static int
 675 _g_win32_stat_fd (int                 fd,
 676                   GWin32PrivateStat  *buf)
 677 {
 678   HANDLE file_handle;
 679   gboolean succeeded_so_far;
 680   DWORD error_code;
 681   struct __stat64 statbuf;
 682   BY_HANDLE_FILE_INFORMATION handle_info;
 683   FILE_STANDARD_INFO std_info;
 684   DWORD reparse_tag = 0;
 685   gboolean is_symlink = FALSE;
 686 
 687   file_handle = (HANDLE) _get_osfhandle (fd);
 688 
 689   if (file_handle == INVALID_HANDLE_VALUE)
 690     return -1;
 691 
 692   succeeded_so_far = GetFileInformationByHandle (file_handle,
 693                                                  &amp;handle_info);
 694   error_code = GetLastError ();
 695 
 696   if (succeeded_so_far)
 697     {
 698       succeeded_so_far = GetFileInformationByHandleEx (file_handle,
 699                                                        FileStandardInfo,
 700                                                        &amp;std_info,
 701                                                        sizeof (std_info));
 702       error_code = GetLastError ();
 703     }
 704 
 705   if (!succeeded_so_far)
 706     {
 707       errno = w32_error_to_errno (error_code);
 708       return -1;
 709     }
 710 
 711   is_symlink = (handle_info.dwFileAttributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;
 712 
 713   if (is_symlink &amp;&amp;
 714       _g_win32_readlink_handle_raw (file_handle, &amp;reparse_tag, NULL, 0, NULL, FALSE) &lt; 0)
 715     return -1;
 716 
 717   if (_fstat64 (fd, &amp;statbuf) != 0)
 718     return -1;
 719 
 720   _g_win32_fill_privatestat (&amp;statbuf,
 721                              &amp;handle_info,
 722                              &amp;std_info,
 723                              reparse_tag,
 724                              buf);
 725 
 726   return 0;
 727 }
 728 
 729 /* Works like stat() or lstat(), depending on the value of @for_symlink,
 730  * but accepts filename in UTF-8 and fills our custom stat structure.
 731  */
 732 static int
 733 _g_win32_stat_utf8 (const gchar       *filename,
 734                     GWin32PrivateStat *buf,
 735                     gboolean           for_symlink)
 736 {
 737   wchar_t *wfilename;
 738   int result;
 739   gsize len;
 740 
 741   if (filename == NULL)
 742     {
 743       errno = EINVAL;
 744       return -1;
 745     }
 746 
 747   len = strlen (filename);
 748 
 749   while (len &gt; 0 &amp;&amp; G_IS_DIR_SEPARATOR (filename[len - 1]))
 750     len--;
 751 
 752   if (len &lt;= 0 ||
 753       (g_path_is_absolute (filename) &amp;&amp; len &lt;= g_path_skip_root (filename) - filename))
 754     len = strlen (filename);
 755 
 756   wfilename = g_utf8_to_utf16 (filename, len, NULL, NULL, NULL);
 757 
 758   if (wfilename == NULL)
 759     {
 760       errno = EINVAL;
 761       return -1;
 762     }
 763 
 764   result = _g_win32_stat_utf16_no_trailing_slashes (wfilename, buf, for_symlink);
 765 
 766   g_free (wfilename);
 767 
 768   return result;
 769 }
 770 
 771 /* Works like stat(), but accepts filename in UTF-8
 772  * and fills our custom stat structure.
 773  */
 774 int
 775 g_win32_stat_utf8 (const gchar       *filename,
 776                    GWin32PrivateStat *buf)
 777 {
 778   return _g_win32_stat_utf8 (filename, buf, FALSE);
 779 }
 780 
 781 /* Works like lstat(), but accepts filename in UTF-8
 782  * and fills our custom stat structure.
 783  */
 784 int
 785 g_win32_lstat_utf8 (const gchar       *filename,
 786                     GWin32PrivateStat *buf)
 787 {
 788   return _g_win32_stat_utf8 (filename, buf, TRUE);
 789 }
 790 
 791 /* Works like fstat(), but accepts filename in UTF-8
 792  * and fills our custom stat structure.
 793  */
 794 int
 795 g_win32_fstat (int                fd,
 796                GWin32PrivateStat *buf)
 797 {
 798   return _g_win32_stat_fd (fd, buf);
 799 }
 800 
 801 /**
 802  * g_win32_readlink_utf8:
 803  * @filename: (type filename): a pathname in UTF-8
 804  * @buf: (array length=buf_size) : a buffer to receive the reparse point
 805  *                                 target path. Mutually-exclusive
 806  *                                 with @alloc_buf.
 807  * @buf_size: size of the @buf, in bytes
 808  * @alloc_buf: points to a location where internally-allocated buffer
 809  *             pointer will be written. That buffer receives the
 810  *             link data. Mutually-exclusive with @buf.
 811  * @terminate: ensures that the buffer is NUL-terminated if
 812  *             it isn&#39;t already. If %FALSE, the returned string
 813  *             might not be NUL-terminated (depends entirely on
 814  *             what the contents of the filesystem are).
 815  *
 816  * Tries to read the reparse point indicated by @filename, filling
 817  * @buf or @alloc_buf with the path that the reparse point redirects to.
 818  * The path will be UTF-8-encoded, and an extended path prefix
 819  * or a NT object manager prefix will be removed from it, if
 820  * possible, but otherwise the path is returned as-is. Specifically,
 821  * it could be a &quot;\\\\Volume{GUID}\\&quot; path. It also might use
 822  * backslashes as path separators.
 823  *
 824  * Returns: -1 on error (sets errno), 0 if there&#39;s no (recognizable)
 825  * path in the reparse point (@alloc_buf will not be allocated in that case,
 826  * and @buf will be left unmodified),
 827  * or the number of bytes placed into @buf otherwise,
 828  * including NUL-terminator (if present or if @terminate is TRUE).
 829  * The buffer returned via @alloc_buf should be freed with g_free().
 830  *
 831  * Since: 2.60
 832  */
 833 int
 834 g_win32_readlink_utf8 (const gchar  *filename,
 835                        gchar        *buf,
 836                        gsize         buf_size,
 837                        gchar       **alloc_buf,
 838                        gboolean      terminate)
 839 {
 840   wchar_t *wfilename;
 841   int result;
 842   wchar_t *buf_utf16;
 843   glong tmp_len;
 844   gchar *tmp;
 845 
 846   g_return_val_if_fail ((buf != NULL || alloc_buf != NULL) &amp;&amp;
 847                         (buf == NULL || alloc_buf == NULL),
 848                         -1);
 849 
 850   wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 851 
 852   if (wfilename == NULL)
 853     {
 854       errno = EINVAL;
 855       return -1;
 856     }
 857 
 858   result = _g_win32_readlink_utf16_handle (wfilename, NULL, NULL,
 859                                            NULL, 0, &amp;buf_utf16, terminate);
 860 
 861   g_free (wfilename);
 862 
 863   if (result &lt;= 0)
 864     return result;
 865 
 866   tmp = g_utf16_to_utf8 (buf_utf16,
 867                          result / sizeof (gunichar2),
 868                          NULL,
 869                          &amp;tmp_len,
 870                          NULL);
 871 
 872   g_free (buf_utf16);
 873 
 874   if (tmp == NULL)
 875     {
 876       errno = EINVAL;
 877       return -1;
 878     }
 879 
 880   if (alloc_buf)
 881     {
 882       *alloc_buf = tmp;
 883       return tmp_len;
 884     }
 885 
 886   if (tmp_len &gt; buf_size)
 887     tmp_len = buf_size;
 888 
 889   memcpy (buf, tmp, tmp_len);
 890   g_free (tmp);
 891 
 892   return tmp_len;
 893 }
 894 
 895 #endif
 896 
 897 /**
 898  * g_access:
 899  * @filename: (type filename): a pathname in the GLib file name encoding
 900  *     (UTF-8 on Windows)
 901  * @mode: as in access()
 902  *
 903  * A wrapper for the POSIX access() function. This function is used to
 904  * test a pathname for one or several of read, write or execute
 905  * permissions, or just existence.
 906  *
 907  * On Windows, the file protection mechanism is not at all POSIX-like,
 908  * and the underlying function in the C library only checks the
 909  * FAT-style READONLY attribute, and does not look at the ACL of a
 910  * file at all. This function is this in practise almost useless on
 911  * Windows. Software that needs to handle file permissions on Windows
 912  * more exactly should use the Win32 API.
 913  *
 914  * See your C library manual for more details about access().
 915  *
 916  * Returns: zero if the pathname refers to an existing file system
 917  *     object that has all the tested permissions, or -1 otherwise
 918  *     or on error.
 919  *
 920  * Since: 2.8
 921  */
 922 int
 923 g_access (const gchar *filename,
 924     int          mode)
 925 {
 926 #ifdef G_OS_WIN32
 927   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 928   int retval;
 929   int save_errno;
 930 
 931   if (wfilename == NULL)
 932     {
 933       errno = EINVAL;
 934       return -1;
 935     }
 936 
 937 #ifndef X_OK
 938 #define X_OK 1
 939 #endif
 940 
 941   retval = _waccess (wfilename, mode &amp; ~X_OK);
 942   save_errno = errno;
 943 
 944   g_free (wfilename);
 945 
 946   errno = save_errno;
 947   return retval;
 948 #else
 949   return access (filename, mode);
 950 #endif
 951 }
 952 
 953 /**
 954  * g_chmod:
 955  * @filename: (type filename): a pathname in the GLib file name encoding
 956  *     (UTF-8 on Windows)
 957  * @mode: as in chmod()
 958  *
 959  * A wrapper for the POSIX chmod() function. The chmod() function is
 960  * used to set the permissions of a file system object.
 961  *
 962  * On Windows the file protection mechanism is not at all POSIX-like,
 963  * and the underlying chmod() function in the C library just sets or
 964  * clears the FAT-style READONLY attribute. It does not touch any
 965  * ACL. Software that needs to manage file permissions on Windows
 966  * exactly should use the Win32 API.
 967  *
 968  * See your C library manual for more details about chmod().
 969  *
 970  * Returns: 0 if the operation succeeded, -1 on error
 971  *
 972  * Since: 2.8
 973  */
 974 int
 975 g_chmod (const gchar *filename,
 976    int          mode)
 977 {
 978 #ifdef G_OS_WIN32
 979   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
 980   int retval;
 981   int save_errno;
 982 
 983   if (wfilename == NULL)
 984     {
 985       errno = EINVAL;
 986       return -1;
 987     }
 988 
 989   retval = _wchmod (wfilename, mode);
 990   save_errno = errno;
 991 
 992   g_free (wfilename);
 993 
 994   errno = save_errno;
 995   return retval;
 996 #else
 997   return chmod (filename, mode);
 998 #endif
 999 }
1000 /**
1001  * g_open:
1002  * @filename: (type filename): a pathname in the GLib file name encoding
1003  *     (UTF-8 on Windows)
1004  * @flags: as in open()
1005  * @mode: as in open()
1006  *
1007  * A wrapper for the POSIX open() function. The open() function is
1008  * used to convert a pathname into a file descriptor.
1009  *
1010  * On POSIX systems file descriptors are implemented by the operating
1011  * system. On Windows, it&#39;s the C library that implements open() and
1012  * file descriptors. The actual Win32 API for opening files is quite
1013  * different, see MSDN documentation for CreateFile(). The Win32 API
1014  * uses file handles, which are more randomish integers, not small
1015  * integers like file descriptors.
1016  *
1017  * Because file descriptors are specific to the C library on Windows,
1018  * the file descriptor returned by this function makes sense only to
1019  * functions in the same C library. Thus if the GLib-using code uses a
1020  * different C library than GLib does, the file descriptor returned by
1021  * this function cannot be passed to C library functions like write()
1022  * or read().
1023  *
1024  * See your C library manual for more details about open().
1025  *
1026  * Returns: a new file descriptor, or -1 if an error occurred.
1027  *     The return value can be used exactly like the return value
1028  *     from open().
1029  *
1030  * Since: 2.6
1031  */
1032 int
1033 g_open (const gchar *filename,
1034   int          flags,
1035   int          mode)
1036 {
1037 #ifdef G_OS_WIN32
1038   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1039   int retval;
1040   int save_errno;
1041 
1042   if (wfilename == NULL)
1043     {
1044       errno = EINVAL;
1045       return -1;
1046     }
1047 
1048   retval = _wopen (wfilename, flags, mode);
1049   save_errno = errno;
1050 
1051   g_free (wfilename);
1052 
1053   errno = save_errno;
1054   return retval;
1055 #else
1056   int fd;
1057   do
1058     fd = open (filename, flags, mode);
1059   while (G_UNLIKELY (fd == -1 &amp;&amp; errno == EINTR));
1060   return fd;
1061 #endif
1062 }
1063 
1064 /**
1065  * g_creat:
1066  * @filename: (type filename): a pathname in the GLib file name encoding
1067  *     (UTF-8 on Windows)
1068  * @mode: as in creat()
1069  *
1070  * A wrapper for the POSIX creat() function. The creat() function is
1071  * used to convert a pathname into a file descriptor, creating a file
1072  * if necessary.
1073  *
1074  * On POSIX systems file descriptors are implemented by the operating
1075  * system. On Windows, it&#39;s the C library that implements creat() and
1076  * file descriptors. The actual Windows API for opening files is
1077  * different, see MSDN documentation for CreateFile(). The Win32 API
1078  * uses file handles, which are more randomish integers, not small
1079  * integers like file descriptors.
1080  *
1081  * Because file descriptors are specific to the C library on Windows,
1082  * the file descriptor returned by this function makes sense only to
1083  * functions in the same C library. Thus if the GLib-using code uses a
1084  * different C library than GLib does, the file descriptor returned by
1085  * this function cannot be passed to C library functions like write()
1086  * or read().
1087  *
1088  * See your C library manual for more details about creat().
1089  *
1090  * Returns: a new file descriptor, or -1 if an error occurred.
1091  *     The return value can be used exactly like the return value
1092  *     from creat().
1093  *
1094  * Since: 2.8
1095  */
1096 int
1097 g_creat (const gchar *filename,
1098    int          mode)
1099 {
1100 #ifdef G_OS_WIN32
1101   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1102   int retval;
1103   int save_errno;
1104 
1105   if (wfilename == NULL)
1106     {
1107       errno = EINVAL;
1108       return -1;
1109     }
1110 
1111   retval = _wcreat (wfilename, mode);
1112   save_errno = errno;
1113 
1114   g_free (wfilename);
1115 
1116   errno = save_errno;
1117   return retval;
1118 #else
1119   return creat (filename, mode);
1120 #endif
1121 }
1122 
1123 /**
1124  * g_rename:
1125  * @oldfilename: (type filename): a pathname in the GLib file name encoding
1126  *     (UTF-8 on Windows)
1127  * @newfilename: (type filename): a pathname in the GLib file name encoding
1128  *
1129  * A wrapper for the POSIX rename() function. The rename() function
1130  * renames a file, moving it between directories if required.
1131  *
1132  * See your C library manual for more details about how rename() works
1133  * on your system. It is not possible in general on Windows to rename
1134  * a file that is open to some process.
1135  *
1136  * Returns: 0 if the renaming succeeded, -1 if an error occurred
1137  *
1138  * Since: 2.6
1139  */
1140 int
1141 g_rename (const gchar *oldfilename,
1142     const gchar *newfilename)
1143 {
1144 #ifdef G_OS_WIN32
1145   wchar_t *woldfilename = g_utf8_to_utf16 (oldfilename, -1, NULL, NULL, NULL);
1146   wchar_t *wnewfilename;
1147   int retval;
1148   int save_errno = 0;
1149 
1150   if (woldfilename == NULL)
1151     {
1152       errno = EINVAL;
1153       return -1;
1154     }
1155 
1156   wnewfilename = g_utf8_to_utf16 (newfilename, -1, NULL, NULL, NULL);
1157 
1158   if (wnewfilename == NULL)
1159     {
1160       g_free (woldfilename);
1161       errno = EINVAL;
1162       return -1;
1163     }
1164 
1165   if (MoveFileExW (woldfilename, wnewfilename, MOVEFILE_REPLACE_EXISTING))
1166     retval = 0;
1167   else
1168     {
1169       retval = -1;
1170       save_errno = w32_error_to_errno (GetLastError ());
1171     }
1172 
1173   g_free (woldfilename);
1174   g_free (wnewfilename);
1175 
1176   errno = save_errno;
1177   return retval;
1178 #else
1179   return rename (oldfilename, newfilename);
1180 #endif
1181 }
1182 
1183 /**
1184  * g_mkdir:
1185  * @filename: (type filename): a pathname in the GLib file name encoding
1186  *     (UTF-8 on Windows)
1187  * @mode: permissions to use for the newly created directory
1188  *
1189  * A wrapper for the POSIX mkdir() function. The mkdir() function
1190  * attempts to create a directory with the given name and permissions.
1191  * The mode argument is ignored on Windows.
1192  *
1193  * See your C library manual for more details about mkdir().
1194  *
1195  * Returns: 0 if the directory was successfully created, -1 if an error
1196  *    occurred
1197  *
1198  * Since: 2.6
1199  */
1200 int
1201 g_mkdir (const gchar *filename,
1202    int          mode)
1203 {
1204 #ifdef G_OS_WIN32
1205   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1206   int retval;
1207   int save_errno;
1208 
1209   if (wfilename == NULL)
1210     {
1211       errno = EINVAL;
1212       return -1;
1213     }
1214 
1215   retval = _wmkdir (wfilename);
1216   save_errno = errno;
1217 
1218   g_free (wfilename);
1219 
1220   errno = save_errno;
1221   return retval;
1222 #else
1223   return mkdir (filename, mode);
1224 #endif
1225 }
1226 
1227 /**
1228  * g_chdir:
1229  * @path: (type filename): a pathname in the GLib file name encoding
1230  *     (UTF-8 on Windows)
1231  *
1232  * A wrapper for the POSIX chdir() function. The function changes the
1233  * current directory of the process to @path.
1234  *
1235  * See your C library manual for more details about chdir().
1236  *
1237  * Returns: 0 on success, -1 if an error occurred.
1238  *
1239  * Since: 2.8
1240  */
1241 int
1242 g_chdir (const gchar *path)
1243 {
1244 #ifdef G_OS_WIN32
1245   wchar_t *wpath = g_utf8_to_utf16 (path, -1, NULL, NULL, NULL);
1246   int retval;
1247   int save_errno;
1248 
1249   if (wpath == NULL)
1250     {
1251       errno = EINVAL;
1252       return -1;
1253     }
1254 
1255   retval = _wchdir (wpath);
1256   save_errno = errno;
1257 
1258   g_free (wpath);
1259 
1260   errno = save_errno;
1261   return retval;
1262 #else
1263   return chdir (path);
1264 #endif
1265 }
1266 
1267 /**
1268  * GStatBuf:
1269  *
1270  * A type corresponding to the appropriate struct type for the stat()
1271  * system call, depending on the platform and/or compiler being used.
1272  *
1273  * See g_stat() for more information.
1274  */
1275 /**
1276  * g_stat:
1277  * @filename: (type filename): a pathname in the GLib file name encoding
1278  *     (UTF-8 on Windows)
1279  * @buf: a pointer to a stat struct, which will be filled with the file
1280  *     information
1281  *
1282  * A wrapper for the POSIX stat() function. The stat() function
1283  * returns information about a file. On Windows the stat() function in
1284  * the C library checks only the FAT-style READONLY attribute and does
1285  * not look at the ACL at all. Thus on Windows the protection bits in
1286  * the @st_mode field are a fabrication of little use.
1287  *
1288  * On Windows the Microsoft C libraries have several variants of the
1289  * stat struct and stat() function with names like _stat(), _stat32(),
1290  * _stat32i64() and _stat64i32(). The one used here is for 32-bit code
1291  * the one with 32-bit size and time fields, specifically called _stat32().
1292  *
1293  * In Microsoft&#39;s compiler, by default struct stat means one with
1294  * 64-bit time fields while in MinGW struct stat is the legacy one
1295  * with 32-bit fields. To hopefully clear up this messs, the gstdio.h
1296  * header defines a type #GStatBuf which is the appropriate struct type
1297  * depending on the platform and/or compiler being used. On POSIX it
1298  * is just struct stat, but note that even on POSIX platforms, stat()
1299  * might be a macro.
1300  *
1301  * See your C library manual for more details about stat().
1302  *
1303  * Returns: 0 if the information was successfully retrieved,
1304  *     -1 if an error occurred
1305  *
1306  * Since: 2.6
1307  */
1308 int
1309 g_stat (const gchar *filename,
1310   GStatBuf    *buf)
1311 {
1312 #ifdef G_OS_WIN32
1313   GWin32PrivateStat w32_buf;
1314   int retval = g_win32_stat_utf8 (filename, &amp;w32_buf);
1315 
1316   buf-&gt;st_dev = w32_buf.st_dev;
1317   buf-&gt;st_ino = w32_buf.st_ino;
1318   buf-&gt;st_mode = w32_buf.st_mode;
1319   buf-&gt;st_nlink = w32_buf.st_nlink;
1320   buf-&gt;st_uid = w32_buf.st_uid;
1321   buf-&gt;st_gid = w32_buf.st_gid;
1322   buf-&gt;st_rdev = w32_buf.st_dev;
1323   buf-&gt;st_size = w32_buf.st_size;
1324   buf-&gt;st_atime = w32_buf.st_atime;
1325   buf-&gt;st_mtime = w32_buf.st_mtime;
1326   buf-&gt;st_ctime = w32_buf.st_ctime;
1327 
1328   return retval;
1329 #else
1330   return stat (filename, buf);
1331 #endif
1332 }
1333 
1334 /**
1335  * g_lstat:
1336  * @filename: (type filename): a pathname in the GLib file name encoding
1337  *     (UTF-8 on Windows)
1338  * @buf: a pointer to a stat struct, which will be filled with the file
1339  *     information
1340  *
1341  * A wrapper for the POSIX lstat() function. The lstat() function is
1342  * like stat() except that in the case of symbolic links, it returns
1343  * information about the symbolic link itself and not the file that it
1344  * refers to. If the system does not support symbolic links g_lstat()
1345  * is identical to g_stat().
1346  *
1347  * See your C library manual for more details about lstat().
1348  *
1349  * Returns: 0 if the information was successfully retrieved,
1350  *     -1 if an error occurred
1351  *
1352  * Since: 2.6
1353  */
1354 int
1355 g_lstat (const gchar *filename,
1356    GStatBuf    *buf)
1357 {
1358 #ifdef HAVE_LSTAT
1359   /* This can&#39;t be Win32, so don&#39;t do the widechar dance. */
1360   return lstat (filename, buf);
1361 #elif defined (G_OS_WIN32)
1362   GWin32PrivateStat w32_buf;
1363   int retval = g_win32_lstat_utf8 (filename, &amp;w32_buf);
1364 
1365   buf-&gt;st_dev = w32_buf.st_dev;
1366   buf-&gt;st_ino = w32_buf.st_ino;
1367   buf-&gt;st_mode = w32_buf.st_mode;
1368   buf-&gt;st_nlink = w32_buf.st_nlink;
1369   buf-&gt;st_uid = w32_buf.st_uid;
1370   buf-&gt;st_gid = w32_buf.st_gid;
1371   buf-&gt;st_rdev = w32_buf.st_dev;
1372   buf-&gt;st_size = w32_buf.st_size;
1373   buf-&gt;st_atime = w32_buf.st_atime;
1374   buf-&gt;st_mtime = w32_buf.st_mtime;
1375   buf-&gt;st_ctime = w32_buf.st_ctime;
1376 
1377   return retval;
1378 #else
1379   return g_stat (filename, buf);
1380 #endif
1381 }
1382 
1383 /**
1384  * g_unlink:
1385  * @filename: (type filename): a pathname in the GLib file name encoding
1386  *     (UTF-8 on Windows)
1387  *
1388  * A wrapper for the POSIX unlink() function. The unlink() function
1389  * deletes a name from the filesystem. If this was the last link to the
1390  * file and no processes have it opened, the diskspace occupied by the
1391  * file is freed.
1392  *
1393  * See your C library manual for more details about unlink(). Note
1394  * that on Windows, it is in general not possible to delete files that
1395  * are open to some process, or mapped into memory.
1396  *
1397  * Returns: 0 if the name was successfully deleted, -1 if an error
1398  *    occurred
1399  *
1400  * Since: 2.6
1401  */
1402 int
1403 g_unlink (const gchar *filename)
1404 {
1405 #ifdef G_OS_WIN32
1406   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1407   int retval;
1408   int save_errno;
1409 
1410   if (wfilename == NULL)
1411     {
1412       errno = EINVAL;
1413       return -1;
1414     }
1415 
1416   retval = _wunlink (wfilename);
1417   save_errno = errno;
1418 
1419   g_free (wfilename);
1420 
1421   errno = save_errno;
1422   return retval;
1423 #else
1424   return unlink (filename);
1425 #endif
1426 }
1427 
1428 /**
1429  * g_remove:
1430  * @filename: (type filename): a pathname in the GLib file name encoding
1431  *     (UTF-8 on Windows)
1432  *
1433  * A wrapper for the POSIX remove() function. The remove() function
1434  * deletes a name from the filesystem.
1435  *
1436  * See your C library manual for more details about how remove() works
1437  * on your system. On Unix, remove() removes also directories, as it
1438  * calls unlink() for files and rmdir() for directories. On Windows,
1439  * although remove() in the C library only works for files, this
1440  * function tries first remove() and then if that fails rmdir(), and
1441  * thus works for both files and directories. Note however, that on
1442  * Windows, it is in general not possible to remove a file that is
1443  * open to some process, or mapped into memory.
1444  *
1445  * If this function fails on Windows you can&#39;t infer too much from the
1446  * errno value. rmdir() is tried regardless of what caused remove() to
1447  * fail. Any errno value set by remove() will be overwritten by that
1448  * set by rmdir().
1449  *
1450  * Returns: 0 if the file was successfully removed, -1 if an error
1451  *    occurred
1452  *
1453  * Since: 2.6
1454  */
1455 int
1456 g_remove (const gchar *filename)
1457 {
1458 #ifdef G_OS_WIN32
1459   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1460   int retval;
1461   int save_errno;
1462 
1463   if (wfilename == NULL)
1464     {
1465       errno = EINVAL;
1466       return -1;
1467     }
1468 
1469   retval = _wremove (wfilename);
1470   if (retval == -1)
1471     retval = _wrmdir (wfilename);
1472   save_errno = errno;
1473 
1474   g_free (wfilename);
1475 
1476   errno = save_errno;
1477   return retval;
1478 #else
1479   return remove (filename);
1480 #endif
1481 }
1482 
1483 /**
1484  * g_rmdir:
1485  * @filename: (type filename): a pathname in the GLib file name encoding
1486  *     (UTF-8 on Windows)
1487  *
1488  * A wrapper for the POSIX rmdir() function. The rmdir() function
1489  * deletes a directory from the filesystem.
1490  *
1491  * See your C library manual for more details about how rmdir() works
1492  * on your system.
1493  *
1494  * Returns: 0 if the directory was successfully removed, -1 if an error
1495  *    occurred
1496  *
1497  * Since: 2.6
1498  */
1499 int
1500 g_rmdir (const gchar *filename)
1501 {
1502 #ifdef G_OS_WIN32
1503   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1504   int retval;
1505   int save_errno;
1506 
1507   if (wfilename == NULL)
1508     {
1509       errno = EINVAL;
1510       return -1;
1511     }
1512 
1513   retval = _wrmdir (wfilename);
1514   save_errno = errno;
1515 
1516   g_free (wfilename);
1517 
1518   errno = save_errno;
1519   return retval;
1520 #else
1521   return rmdir (filename);
1522 #endif
1523 }
1524 
1525 /**
1526  * g_fopen:
1527  * @filename: (type filename): a pathname in the GLib file name encoding
1528  *     (UTF-8 on Windows)
1529  * @mode: a string describing the mode in which the file should be opened
1530  *
1531  * A wrapper for the stdio fopen() function. The fopen() function
1532  * opens a file and associates a new stream with it.
1533  *
1534  * Because file descriptors are specific to the C library on Windows,
1535  * and a file descriptor is part of the FILE struct, the FILE* returned
1536  * by this function makes sense only to functions in the same C library.
1537  * Thus if the GLib-using code uses a different C library than GLib does,
1538  * the FILE* returned by this function cannot be passed to C library
1539  * functions like fprintf() or fread().
1540  *
1541  * See your C library manual for more details about fopen().
1542  *
1543  * Returns: A FILE* if the file was successfully opened, or %NULL if
1544  *     an error occurred
1545  *
1546  * Since: 2.6
1547  */
1548 FILE *
1549 g_fopen (const gchar *filename,
1550    const gchar *mode)
1551 {
1552 #ifdef G_OS_WIN32
1553   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1554   wchar_t *wmode;
1555   FILE *retval;
1556   int save_errno;
1557 
1558   if (wfilename == NULL)
1559     {
1560       errno = EINVAL;
1561       return NULL;
1562     }
1563 
1564   wmode = g_utf8_to_utf16 (mode, -1, NULL, NULL, NULL);
1565 
1566   if (wmode == NULL)
1567     {
1568       g_free (wfilename);
1569       errno = EINVAL;
1570       return NULL;
1571     }
1572 
1573   _g_win32_fix_mode (wmode);
1574   retval = _wfopen (wfilename, wmode);
1575   save_errno = errno;
1576 
1577   g_free (wfilename);
1578   g_free (wmode);
1579 
1580   errno = save_errno;
1581   return retval;
1582 #else
1583   return fopen (filename, mode);
1584 #endif
1585 }
1586 
1587 /**
1588  * g_freopen:
1589  * @filename: (type filename): a pathname in the GLib file name encoding
1590  *     (UTF-8 on Windows)
1591  * @mode: a string describing the mode in which the file should be  opened
1592  * @stream: (nullable): an existing stream which will be reused, or %NULL
1593  *
1594  * A wrapper for the POSIX freopen() function. The freopen() function
1595  * opens a file and associates it with an existing stream.
1596  *
1597  * See your C library manual for more details about freopen().
1598  *
1599  * Returns: A FILE* if the file was successfully opened, or %NULL if
1600  *     an error occurred.
1601  *
1602  * Since: 2.6
1603  */
1604 FILE *
1605 g_freopen (const gchar *filename,
1606      const gchar *mode,
1607      FILE        *stream)
1608 {
1609 #ifdef G_OS_WIN32
1610   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1611   wchar_t *wmode;
1612   FILE *retval;
1613   int save_errno;
1614 
1615   if (wfilename == NULL)
1616     {
1617       errno = EINVAL;
1618       return NULL;
1619     }
1620 
1621   wmode = g_utf8_to_utf16 (mode, -1, NULL, NULL, NULL);
1622 
1623   if (wmode == NULL)
1624     {
1625       g_free (wfilename);
1626       errno = EINVAL;
1627       return NULL;
1628     }
1629 
1630   _g_win32_fix_mode (wmode);
1631   retval = _wfreopen (wfilename, wmode, stream);
1632   save_errno = errno;
1633 
1634   g_free (wfilename);
1635   g_free (wmode);
1636 
1637   errno = save_errno;
1638   return retval;
1639 #else
1640   return freopen (filename, mode, stream);
1641 #endif
1642 }
1643 
1644 /**
1645  * g_utime:
1646  * @filename: (type filename): a pathname in the GLib file name encoding
1647  *     (UTF-8 on Windows)
1648  * @utb: a pointer to a struct utimbuf.
1649  *
1650  * A wrapper for the POSIX utime() function. The utime() function
1651  * sets the access and modification timestamps of a file.
1652  *
1653  * See your C library manual for more details about how utime() works
1654  * on your system.
1655  *
1656  * Returns: 0 if the operation was successful, -1 if an error occurred
1657  *
1658  * Since: 2.18
1659  */
1660 int
1661 g_utime (const gchar    *filename,
1662    struct utimbuf *utb)
1663 {
1664 #ifdef G_OS_WIN32
1665   wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
1666   int retval;
1667   int save_errno;
1668 
1669   if (wfilename == NULL)
1670     {
1671       errno = EINVAL;
1672       return -1;
1673     }
1674 
1675   retval = _wutime (wfilename, (struct _utimbuf*) utb);
1676   save_errno = errno;
1677 
1678   g_free (wfilename);
1679 
1680   errno = save_errno;
1681   return retval;
1682 #else
1683   return utime (filename, utb);
1684 #endif
1685 }
1686 
1687 /**
1688  * g_close:
1689  * @fd: A file descriptor
1690  * @error: a #GError
1691  *
1692  * This wraps the close() call; in case of error, %errno will be
1693  * preserved, but the error will also be stored as a #GError in @error.
1694  *
1695  * Besides using #GError, there is another major reason to prefer this
1696  * function over the call provided by the system; on Unix, it will
1697  * attempt to correctly handle %EINTR, which has platform-specific
1698  * semantics.
1699  *
1700  * Returns: %TRUE on success, %FALSE if there was an error.
1701  *
1702  * Since: 2.36
1703  */
1704 gboolean
1705 g_close (gint       fd,
1706          GError   **error)
1707 {
1708   int res;
1709   res = close (fd);
1710   /* Just ignore EINTR for now; a retry loop is the wrong thing to do
1711    * on Linux at least.  Anyone who wants to add a conditional check
1712    * for e.g. HP-UX is welcome to do so later...
1713    *
1714    * http://lkml.indiana.edu/hypermail/linux/kernel/0509.1/0877.html
1715    * https://bugzilla.gnome.org/show_bug.cgi?id=682819
1716    * http://utcc.utoronto.ca/~cks/space/blog/unix/CloseEINTR
1717    * https://sites.google.com/site/michaelsafyan/software-engineering/checkforeintrwheninvokingclosethinkagain
1718    */
1719   if (G_UNLIKELY (res == -1 &amp;&amp; errno == EINTR))
1720     return TRUE;
1721   else if (res == -1)
1722     {
1723       int errsv = errno;
1724       g_set_error_literal (error, G_FILE_ERROR,
1725                            g_file_error_from_errno (errsv),
1726                            g_strerror (errsv));
1727       errno = errsv;
1728       return FALSE;
1729     }
1730   return TRUE;
1731 }
1732 
    </pre>
  </body>
</html>