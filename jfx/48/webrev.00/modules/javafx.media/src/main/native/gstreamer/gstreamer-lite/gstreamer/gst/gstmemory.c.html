<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstmemory.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /* GStreamer
  2  * Copyright (C) 2011 Wim Taymans &lt;wim.taymans@gmail.be&gt;
  3  *
  4  * gstmemory.c: memory block handling
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public
 17  * License along with this library; if not, write to the
 18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 /**
 23  * SECTION:gstmemory
 24  * @title: GstMemory
 25  * @short_description: refcounted wrapper for memory blocks
 26  * @see_also: #GstBuffer
 27  *
 28  * GstMemory is a lightweight refcounted object that wraps a region of memory.
 29  * They are typically used to manage the data of a #GstBuffer.
 30  *
 31  * A GstMemory object has an allocated region of memory of maxsize. The maximum
 32  * size does not change during the lifetime of the memory object. The memory
 33  * also has an offset and size property that specifies the valid range of memory
 34  * in the allocated region.
 35  *
 36  * Memory is usually created by allocators with a gst_allocator_alloc()
 37  * method call. When %NULL is used as the allocator, the default allocator will
 38  * be used.
 39  *
 40  * New allocators can be registered with gst_allocator_register().
 41  * Allocators are identified by name and can be retrieved with
 42  * gst_allocator_find(). gst_allocator_set_default() can be used to change the
 43  * default allocator.
 44  *
 45  * New memory can be created with gst_memory_new_wrapped() that wraps the memory
 46  * allocated elsewhere.
 47  *
 48  * Refcounting of the memory block is performed with gst_memory_ref() and
 49  * gst_memory_unref().
 50  *
 51  * The size of the memory can be retrieved and changed with
 52  * gst_memory_get_sizes() and gst_memory_resize() respectively.
 53  *
 54  * Getting access to the data of the memory is performed with gst_memory_map().
 55  * The call will return a pointer to offset bytes into the region of memory.
 56  * After the memory access is completed, gst_memory_unmap() should be called.
 57  *
 58  * Memory can be copied with gst_memory_copy(), which will return a writable
 59  * copy. gst_memory_share() will create a new memory block that shares the
 60  * memory with an existing memory block at a custom offset and with a custom
 61  * size.
 62  *
 63  * Memory can be efficiently merged when gst_memory_is_span() returns %TRUE.
 64  */
 65 
 66 #ifdef HAVE_CONFIG_H
 67 #include &quot;config.h&quot;
 68 #endif
 69 
 70 #include &quot;gst_private.h&quot;
 71 #include &quot;gstmemory.h&quot;
 72 
 73 GType _gst_memory_type = 0;
 74 GST_DEFINE_MINI_OBJECT_TYPE (GstMemory, gst_memory);
 75 
 76 static GstMemory *
 77 _gst_memory_copy (GstMemory * mem)
 78 {
 79   GST_CAT_DEBUG (GST_CAT_MEMORY, &quot;copy memory %p&quot;, mem);
 80   return gst_memory_copy (mem, 0, -1);
 81 }
 82 
 83 static void
 84 _gst_memory_free (GstMemory * mem)
 85 {
 86   GstAllocator *allocator;
 87 
 88   GST_CAT_DEBUG (GST_CAT_MEMORY, &quot;free memory %p&quot;, mem);
 89 
 90   if (mem-&gt;parent) {
 91     gst_memory_unlock (mem-&gt;parent, GST_LOCK_FLAG_EXCLUSIVE);
 92     gst_memory_unref (mem-&gt;parent);
 93   }
 94 
 95   allocator = mem-&gt;allocator;
 96 
 97   gst_allocator_free (allocator, mem);
 98 
 99   gst_object_unref (allocator);
100 }
101 
102 /**
103  * gst_memory_init: (skip)
104  * @mem: a #GstMemory
105  * @flags: #GstMemoryFlags
106  * @allocator: the #GstAllocator
107  * @parent: the parent of @mem
108  * @maxsize: the total size of the memory
109  * @align: the alignment of the memory
110  * @offset: The offset in the memory
111  * @size: the size of valid data in the memory
112 
113  * Initializes a newly allocated @mem with the given parameters. This function
114  * will call gst_mini_object_init() with the default memory parameters.
115  */
116 void
117 gst_memory_init (GstMemory * mem, GstMemoryFlags flags,
118     GstAllocator * allocator, GstMemory * parent, gsize maxsize, gsize align,
119     gsize offset, gsize size)
120 {
121   gst_mini_object_init (GST_MINI_OBJECT_CAST (mem),
122       flags | GST_MINI_OBJECT_FLAG_LOCKABLE, GST_TYPE_MEMORY,
123       (GstMiniObjectCopyFunction) _gst_memory_copy, NULL,
124       (GstMiniObjectFreeFunction) _gst_memory_free);
125 
126   mem-&gt;allocator = gst_object_ref (allocator);
127   if (parent) {
128     /* FIXME 2.0: this can fail if the memory is already write locked */
129     gst_memory_lock (parent, GST_LOCK_FLAG_EXCLUSIVE);
130     gst_memory_ref (parent);
131   }
132   mem-&gt;parent = parent;
133   mem-&gt;maxsize = maxsize;
134   mem-&gt;align = align;
135   mem-&gt;offset = offset;
136   mem-&gt;size = size;
137 
138   GST_CAT_DEBUG (GST_CAT_MEMORY, &quot;new memory %p, maxsize:%&quot; G_GSIZE_FORMAT
139       &quot; offset:%&quot; G_GSIZE_FORMAT &quot; size:%&quot; G_GSIZE_FORMAT, mem, maxsize,
140       offset, size);
141 }
142 
143 /**
144  * gst_memory_is_type:
145  * @mem: a #GstMemory
146  * @mem_type: a memory type
147  *
148  * Check if @mem if allocated with an allocator for @mem_type.
149  *
150  * Returns: %TRUE if @mem was allocated from an allocator for @mem_type.
151  *
152  * Since: 1.2
153  */
154 gboolean
155 gst_memory_is_type (GstMemory * mem, const gchar * mem_type)
156 {
157   g_return_val_if_fail (mem != NULL, FALSE);
158   g_return_val_if_fail (mem-&gt;allocator != NULL, FALSE);
159   g_return_val_if_fail (mem_type != NULL, FALSE);
160 
161   return (g_strcmp0 (mem-&gt;allocator-&gt;mem_type, mem_type) == 0);
162 }
163 
164 /**
165  * gst_memory_get_sizes:
166  * @mem: a #GstMemory
167  * @offset: (out) (allow-none): pointer to offset
168  * @maxsize: (out) (allow-none): pointer to maxsize
169  *
170  * Get the current @size, @offset and @maxsize of @mem.
171  *
172  * Returns: the current sizes of @mem
173  */
174 gsize
175 gst_memory_get_sizes (GstMemory * mem, gsize * offset, gsize * maxsize)
176 {
177   g_return_val_if_fail (mem != NULL, 0);
178 
179   if (offset)
180     *offset = mem-&gt;offset;
181   if (maxsize)
182     *maxsize = mem-&gt;maxsize;
183 
184   return mem-&gt;size;
185 }
186 
187 /**
188  * gst_memory_resize:
189  * @mem: a #GstMemory
190  * @offset: a new offset
191  * @size: a new size
192  *
193  * Resize the memory region. @mem should be writable and offset + size should be
194  * less than the maxsize of @mem.
195  *
196  * #GST_MEMORY_FLAG_ZERO_PREFIXED and #GST_MEMORY_FLAG_ZERO_PADDED will be
197  * cleared when offset or padding is increased respectively.
198  */
199 void
200 gst_memory_resize (GstMemory * mem, gssize offset, gsize size)
201 {
202   g_return_if_fail (mem != NULL);
203   g_return_if_fail (gst_memory_is_writable (mem));
204   g_return_if_fail (offset &gt;= 0 || mem-&gt;offset &gt;= -offset);
205   g_return_if_fail (size + mem-&gt;offset + offset &lt;= mem-&gt;maxsize);
206 
207   /* if we increase the prefix, we can&#39;t guarantee it is still 0 filled */
208   if ((offset &gt; 0) &amp;&amp; GST_MEMORY_IS_ZERO_PREFIXED (mem))
209     GST_MEMORY_FLAG_UNSET (mem, GST_MEMORY_FLAG_ZERO_PREFIXED);
210 
211   /* if we increase the padding, we can&#39;t guarantee it is still 0 filled */
212   if ((offset + size &lt; mem-&gt;size) &amp;&amp; GST_MEMORY_IS_ZERO_PADDED (mem))
213     GST_MEMORY_FLAG_UNSET (mem, GST_MEMORY_FLAG_ZERO_PADDED);
214 
215   mem-&gt;offset += offset;
216   mem-&gt;size = size;
217 }
218 
219 /**
220  * gst_memory_make_mapped:
221  * @mem: (transfer full): a #GstMemory
222  * @info: (out): pointer for info
223  * @flags: mapping flags
224  *
225  * Create a #GstMemory object that is mapped with @flags. If @mem is mappable
226  * with @flags, this function returns the mapped @mem directly. Otherwise a
227  * mapped copy of @mem is returned.
228  *
229  * This function takes ownership of old @mem and returns a reference to a new
230  * #GstMemory.
231  *
232  * Returns: (transfer full) (nullable): a #GstMemory object mapped
233  * with @flags or %NULL when a mapping is not possible.
234  */
235 GstMemory *
236 gst_memory_make_mapped (GstMemory * mem, GstMapInfo * info, GstMapFlags flags)
237 {
238   GstMemory *result;
239 
240   if (gst_memory_map (mem, info, flags)) {
241     result = mem;
242   } else {
243     result = gst_memory_copy (mem, 0, -1);
244     gst_memory_unref (mem);
245 
246     if (result == NULL)
247       goto cannot_copy;
248 
249     if (!gst_memory_map (result, info, flags))
250       goto cannot_map;
251   }
252   return result;
253 
254   /* ERRORS */
255 cannot_copy:
256   {
257     GST_CAT_DEBUG (GST_CAT_MEMORY, &quot;cannot copy memory %p&quot;, mem);
258     return NULL;
259   }
260 cannot_map:
261   {
262     GST_CAT_DEBUG (GST_CAT_MEMORY, &quot;cannot map memory %p with flags %d&quot;, mem,
263         flags);
264     gst_memory_unref (result);
265     return NULL;
266   }
267 }
268 
269 /**
270  * gst_memory_map:
271  * @mem: a #GstMemory
272  * @info: (out): pointer for info
273  * @flags: mapping flags
274  *
275  * Fill @info with the pointer and sizes of the memory in @mem that can be
276  * accessed according to @flags.
277  *
278  * This function can return %FALSE for various reasons:
279  * - the memory backed by @mem is not accessible with the given @flags.
280  * - the memory was already mapped with a different mapping.
281  *
282  * @info and its contents remain valid for as long as @mem is valid and
283  * until gst_memory_unmap() is called.
284  *
285  * For each gst_memory_map() call, a corresponding gst_memory_unmap() call
286  * should be done.
287  *
288  * Returns: %TRUE if the map operation was successful.
289  */
290 gboolean
291 gst_memory_map (GstMemory * mem, GstMapInfo * info, GstMapFlags flags)
292 {
293   g_return_val_if_fail (mem != NULL, FALSE);
294   g_return_val_if_fail (info != NULL, FALSE);
295 
296   if (!gst_memory_lock (mem, (GstLockFlags) flags))
297     goto lock_failed;
298 
299   info-&gt;flags = flags;
300   info-&gt;memory = mem;
301   info-&gt;size = mem-&gt;size;
302   info-&gt;maxsize = mem-&gt;maxsize - mem-&gt;offset;
303 
304   if (mem-&gt;allocator-&gt;mem_map_full)
305     info-&gt;data = mem-&gt;allocator-&gt;mem_map_full (mem, info, mem-&gt;maxsize);
306   else
307     info-&gt;data = mem-&gt;allocator-&gt;mem_map (mem, mem-&gt;maxsize, flags);
308 
309   if (G_UNLIKELY (info-&gt;data == NULL))
310     goto error;
311 
312   info-&gt;data = info-&gt;data + mem-&gt;offset;
313 
314   return TRUE;
315 
316   /* ERRORS */
317 lock_failed:
318   {
319     GST_CAT_DEBUG (GST_CAT_MEMORY, &quot;mem %p: lock %d failed&quot;, mem, flags);
320     memset (info, 0, sizeof (GstMapInfo));
321     return FALSE;
322   }
323 error:
324   {
325     /* something went wrong, restore the original state again
326      * it is up to the subclass to log an error if needed. */
327     GST_CAT_INFO (GST_CAT_MEMORY, &quot;mem %p: subclass map failed&quot;, mem);
328     gst_memory_unlock (mem, (GstLockFlags) flags);
329     memset (info, 0, sizeof (GstMapInfo));
330     return FALSE;
331   }
332 }
333 
334 /**
335  * gst_memory_unmap:
336  * @mem: a #GstMemory
337  * @info: a #GstMapInfo
338  *
339  * Release the memory obtained with gst_memory_map()
340  */
341 void
342 gst_memory_unmap (GstMemory * mem, GstMapInfo * info)
343 {
344   g_return_if_fail (mem != NULL);
345   g_return_if_fail (info != NULL);
346   g_return_if_fail (info-&gt;memory == mem);
347 
348   if (mem-&gt;allocator-&gt;mem_unmap_full)
349     mem-&gt;allocator-&gt;mem_unmap_full (mem, info);
350   else
351     mem-&gt;allocator-&gt;mem_unmap (mem);
352   gst_memory_unlock (mem, (GstLockFlags) info-&gt;flags);
353 }
354 
355 /**
356  * gst_memory_copy:
357  * @mem: a #GstMemory
358  * @offset: offset to copy from
359  * @size: size to copy, or -1 to copy to the end of the memory region
360  *
361  * Return a copy of @size bytes from @mem starting from @offset. This copy is
362  * guaranteed to be writable. @size can be set to -1 to return a copy
363  * from @offset to the end of the memory region.
364  *
365  * Returns: a new #GstMemory.
366  */
367 GstMemory *
368 gst_memory_copy (GstMemory * mem, gssize offset, gssize size)
369 {
370   GstMemory *copy;
371 
372   g_return_val_if_fail (mem != NULL, NULL);
373 
374   copy = mem-&gt;allocator-&gt;mem_copy (mem, offset, size);
375 
376   return copy;
377 }
378 
379 /**
380  * gst_memory_share:
381  * @mem: a #GstMemory
382  * @offset: offset to share from
383  * @size: size to share, or -1 to share to the end of the memory region
384  *
385  * Return a shared copy of @size bytes from @mem starting from @offset. No
386  * memory copy is performed and the memory region is simply shared. The result
387  * is guaranteed to be non-writable. @size can be set to -1 to return a shared
388  * copy from @offset to the end of the memory region.
389  *
390  * Returns: a new #GstMemory.
391  */
392 GstMemory *
393 gst_memory_share (GstMemory * mem, gssize offset, gssize size)
394 {
395   GstMemory *shared;
396 
397   g_return_val_if_fail (mem != NULL, NULL);
398   g_return_val_if_fail (!GST_MEMORY_FLAG_IS_SET (mem, GST_MEMORY_FLAG_NO_SHARE),
399       NULL);
400 
401   /* whether we can lock the memory exclusively */
402   /* in order to maintain backwards compatibility by not requiring subclasses
403    * to lock the memory themselves and propagate the possible failure in their
404    * mem_share implementation */
405   /* FIXME 2.0: remove and fix gst_memory_init() and/or all memory subclasses
406    * to propagate this failure case */
407   if (!gst_memory_lock (mem, GST_LOCK_FLAG_EXCLUSIVE))
408     return NULL;
409 
410   /* double lock to ensure we are not mapped writable without an
411    * exclusive lock. */
412   if (!gst_memory_lock (mem, GST_LOCK_FLAG_EXCLUSIVE)) {
413     gst_memory_unlock (mem, GST_LOCK_FLAG_EXCLUSIVE);
414     return NULL;
415   }
416 
417   shared = mem-&gt;allocator-&gt;mem_share (mem, offset, size);
418 
419   /* unlocking before calling the subclass would be racy */
420   gst_memory_unlock (mem, GST_LOCK_FLAG_EXCLUSIVE);
421   gst_memory_unlock (mem, GST_LOCK_FLAG_EXCLUSIVE);
422 
423   return shared;
424 }
425 
426 /**
427  * gst_memory_is_span:
428  * @mem1: a #GstMemory
429  * @mem2: a #GstMemory
430  * @offset: (out): a pointer to a result offset
431  *
432  * Check if @mem1 and mem2 share the memory with a common parent memory object
433  * and that the memory is contiguous.
434  *
435  * If this is the case, the memory of @mem1 and @mem2 can be merged
436  * efficiently by performing gst_memory_share() on the parent object from
437  * the returned @offset.
438  *
439  * Returns: %TRUE if the memory is contiguous and of a common parent.
440  */
441 gboolean
442 gst_memory_is_span (GstMemory * mem1, GstMemory * mem2, gsize * offset)
443 {
444   g_return_val_if_fail (mem1 != NULL, FALSE);
445   g_return_val_if_fail (mem2 != NULL, FALSE);
446 
447   /* need to have the same allocators */
448   if (mem1-&gt;allocator != mem2-&gt;allocator)
449     return FALSE;
450 
451   /* need to have the same parent */
452   if (mem1-&gt;parent == NULL || mem1-&gt;parent != mem2-&gt;parent)
453     return FALSE;
454 
455   /* and memory is contiguous */
456   if (!mem1-&gt;allocator-&gt;mem_is_span (mem1, mem2, offset))
457     return FALSE;
458 
459   return TRUE;
460 }
461 
462 void
463 _priv_gst_memory_initialize (void)
464 {
465   _gst_memory_type = gst_memory_get_type ();
466 }
    </pre>
  </body>
</html>