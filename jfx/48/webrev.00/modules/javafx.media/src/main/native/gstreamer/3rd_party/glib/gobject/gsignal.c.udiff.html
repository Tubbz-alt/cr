<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gsignal.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gparamspecs.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gsignal.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gsignal.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -124,11 +124,11 @@</span>
   * effective memory leaks of the user data if the signal handler is never
   * disconnected for some reason.
   */
  
  
<span class="udiff-line-modified-removed">- #define REPORT_BUG      &quot;please report occurrence circumstances to gtk-devel-list@gnome.org&quot;</span>
<span class="udiff-line-modified-added">+ #define REPORT_BUG      &quot;please report occurrence circumstances to https://gitlab.gnome.org/GNOME/glib/issues/new&quot;</span>
  
  /* --- typedefs --- */
  typedef struct _SignalNode   SignalNode;
  typedef struct _SignalKey    SignalKey;
  typedef struct _Emission     Emission;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -143,66 +143,66 @@</span>
    EMISSION_RESTART
  } EmissionState;
  
  
  /* --- prototypes --- */
<span class="udiff-line-modified-removed">- static inline guint     signal_id_lookup    (GQuark       quark,</span>
<span class="udiff-line-modified-removed">-                              GType        itype);</span>
<span class="udiff-line-modified-removed">- static        void      signal_destroy_R    (SignalNode  *signal_node);</span>
<span class="udiff-line-modified-removed">- static inline HandlerList*  handler_list_ensure (guint        signal_id,</span>
<span class="udiff-line-modified-removed">-                              gpointer     instance);</span>
<span class="udiff-line-modified-removed">- static inline HandlerList*  handler_list_lookup (guint        signal_id,</span>
<span class="udiff-line-modified-removed">-                              gpointer     instance);</span>
<span class="udiff-line-modified-removed">- static inline Handler*      handler_new     (guint            signal_id,</span>
<span class="udiff-line-modified-removed">-                              gpointer         instance,</span>
<span class="udiff-line-modified-removed">-                                                          gboolean     after);</span>
<span class="udiff-line-modified-removed">- static        void      handler_insert      (guint        signal_id,</span>
<span class="udiff-line-modified-removed">-                              gpointer     instance,</span>
<span class="udiff-line-modified-removed">-                              Handler     *handler);</span>
<span class="udiff-line-modified-removed">- static        Handler*      handler_lookup      (gpointer     instance,</span>
<span class="udiff-line-modified-removed">-                              gulong       handler_id,</span>
<span class="udiff-line-modified-removed">-                              GClosure        *closure,</span>
<span class="udiff-line-modified-removed">-                              guint       *signal_id_p);</span>
<span class="udiff-line-modified-removed">- static inline HandlerMatch* handler_match_prepend   (HandlerMatch    *list,</span>
<span class="udiff-line-modified-removed">-                              Handler     *handler,</span>
<span class="udiff-line-modified-removed">-                              guint        signal_id);</span>
<span class="udiff-line-modified-removed">- static inline HandlerMatch* handler_match_free1_R   (HandlerMatch    *node,</span>
<span class="udiff-line-modified-removed">-                              gpointer     instance);</span>
<span class="udiff-line-modified-removed">- static        HandlerMatch* handlers_find       (gpointer     instance,</span>
<span class="udiff-line-modified-removed">-                              GSignalMatchType mask,</span>
<span class="udiff-line-modified-removed">-                              guint        signal_id,</span>
<span class="udiff-line-modified-removed">-                              GQuark       detail,</span>
<span class="udiff-line-modified-removed">-                              GClosure    *closure,</span>
<span class="udiff-line-modified-removed">-                              gpointer     func,</span>
<span class="udiff-line-modified-removed">-                              gpointer     data,</span>
<span class="udiff-line-modified-removed">-                              gboolean     one_and_only);</span>
<span class="udiff-line-modified-removed">- static inline void      handler_ref     (Handler     *handler);</span>
<span class="udiff-line-modified-removed">- static inline void      handler_unref_R     (guint        signal_id,</span>
<span class="udiff-line-modified-removed">-                              gpointer     instance,</span>
<span class="udiff-line-modified-removed">-                              Handler     *handler);</span>
<span class="udiff-line-modified-removed">- static gint         handler_lists_cmp   (gconstpointer    node1,</span>
<span class="udiff-line-modified-removed">-                              gconstpointer    node2);</span>
<span class="udiff-line-modified-removed">- static inline void      emission_push       (Emission    *emission);</span>
<span class="udiff-line-modified-removed">- static inline void      emission_pop        (Emission    *emission);</span>
<span class="udiff-line-modified-removed">- static inline Emission*     emission_find       (guint        signal_id,</span>
<span class="udiff-line-modified-removed">-                              GQuark       detail,</span>
<span class="udiff-line-modified-removed">-                              gpointer     instance);</span>
<span class="udiff-line-modified-removed">- static gint         class_closures_cmp  (gconstpointer    node1,</span>
<span class="udiff-line-modified-removed">-                              gconstpointer    node2);</span>
<span class="udiff-line-modified-removed">- static gint         signal_key_cmp      (gconstpointer    node1,</span>
<span class="udiff-line-modified-removed">-                              gconstpointer    node2);</span>
<span class="udiff-line-modified-removed">- static        gboolean      signal_emit_unlocked_R  (SignalNode  *node,</span>
<span class="udiff-line-modified-removed">-                              GQuark       detail,</span>
<span class="udiff-line-modified-removed">-                              gpointer     instance,</span>
<span class="udiff-line-modified-removed">-                              GValue      *return_value,</span>
<span class="udiff-line-modified-removed">-                              const GValue    *instance_and_params);</span>
<span class="udiff-line-modified-added">+ static inline guint   signal_id_lookup  (GQuark     quark,</span>
<span class="udiff-line-modified-added">+                GType      itype);</span>
<span class="udiff-line-modified-added">+ static        void    signal_destroy_R  (SignalNode  *signal_node);</span>
<span class="udiff-line-modified-added">+ static inline HandlerList*  handler_list_ensure (guint      signal_id,</span>
<span class="udiff-line-modified-added">+                gpointer   instance);</span>
<span class="udiff-line-modified-added">+ static inline HandlerList*  handler_list_lookup (guint      signal_id,</span>
<span class="udiff-line-modified-added">+                gpointer   instance);</span>
<span class="udiff-line-modified-added">+ static inline Handler*    handler_new   (guint            signal_id,</span>
<span class="udiff-line-modified-added">+                gpointer         instance,</span>
<span class="udiff-line-modified-added">+                                                          gboolean   after);</span>
<span class="udiff-line-modified-added">+ static        void    handler_insert    (guint      signal_id,</span>
<span class="udiff-line-modified-added">+                gpointer   instance,</span>
<span class="udiff-line-modified-added">+                Handler   *handler);</span>
<span class="udiff-line-modified-added">+ static        Handler*    handler_lookup    (gpointer   instance,</span>
<span class="udiff-line-modified-added">+                gulong     handler_id,</span>
<span class="udiff-line-modified-added">+                GClosure        *closure,</span>
<span class="udiff-line-modified-added">+                guint     *signal_id_p);</span>
<span class="udiff-line-modified-added">+ static inline HandlerMatch* handler_match_prepend (HandlerMatch  *list,</span>
<span class="udiff-line-modified-added">+                Handler   *handler,</span>
<span class="udiff-line-modified-added">+                guint      signal_id);</span>
<span class="udiff-line-modified-added">+ static inline HandlerMatch* handler_match_free1_R (HandlerMatch  *node,</span>
<span class="udiff-line-modified-added">+                gpointer   instance);</span>
<span class="udiff-line-modified-added">+ static        HandlerMatch* handlers_find   (gpointer   instance,</span>
<span class="udiff-line-modified-added">+                GSignalMatchType mask,</span>
<span class="udiff-line-modified-added">+                guint      signal_id,</span>
<span class="udiff-line-modified-added">+                GQuark     detail,</span>
<span class="udiff-line-modified-added">+                GClosure  *closure,</span>
<span class="udiff-line-modified-added">+                gpointer   func,</span>
<span class="udiff-line-modified-added">+                gpointer   data,</span>
<span class="udiff-line-modified-added">+                gboolean   one_and_only);</span>
<span class="udiff-line-modified-added">+ static inline void    handler_ref   (Handler   *handler);</span>
<span class="udiff-line-modified-added">+ static inline void    handler_unref_R   (guint      signal_id,</span>
<span class="udiff-line-modified-added">+                gpointer   instance,</span>
<span class="udiff-line-modified-added">+                Handler   *handler);</span>
<span class="udiff-line-modified-added">+ static gint     handler_lists_cmp (gconstpointer    node1,</span>
<span class="udiff-line-modified-added">+                gconstpointer    node2);</span>
<span class="udiff-line-modified-added">+ static inline void    emission_push   (Emission  *emission);</span>
<span class="udiff-line-modified-added">+ static inline void    emission_pop    (Emission  *emission);</span>
<span class="udiff-line-modified-added">+ static inline Emission*   emission_find   (guint      signal_id,</span>
<span class="udiff-line-modified-added">+                GQuark     detail,</span>
<span class="udiff-line-modified-added">+                gpointer   instance);</span>
<span class="udiff-line-modified-added">+ static gint     class_closures_cmp  (gconstpointer    node1,</span>
<span class="udiff-line-modified-added">+                gconstpointer    node2);</span>
<span class="udiff-line-modified-added">+ static gint     signal_key_cmp    (gconstpointer    node1,</span>
<span class="udiff-line-modified-added">+                gconstpointer    node2);</span>
<span class="udiff-line-modified-added">+ static        gboolean    signal_emit_unlocked_R  (SignalNode  *node,</span>
<span class="udiff-line-modified-added">+                GQuark     detail,</span>
<span class="udiff-line-modified-added">+                gpointer   instance,</span>
<span class="udiff-line-modified-added">+                GValue    *return_value,</span>
<span class="udiff-line-modified-added">+                const GValue  *instance_and_params);</span>
  static       void               add_invalid_closure_notify    (Handler         *handler,
<span class="udiff-line-modified-removed">-                                    gpointer         instance);</span>
<span class="udiff-line-modified-added">+                      gpointer         instance);</span>
  static       void               remove_invalid_closure_notify (Handler         *handler,
<span class="udiff-line-modified-removed">-                                    gpointer         instance);</span>
<span class="udiff-line-modified-added">+                      gpointer         instance);</span>
  static       void               invalid_closure_notify  (gpointer         data,
<span class="udiff-line-modified-removed">-                              GClosure        *closure);</span>
<span class="udiff-line-modified-added">+                GClosure        *closure);</span>
  static const gchar *            type_debug_name         (GType            type);
  static void                     node_check_deprecated   (const SignalNode *node);
  static void                     node_update_single_va_closure (SignalNode *node);
  
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -215,11 +215,11 @@</span>
  typedef struct
  {
    GHook hook;
    GQuark detail;
  } SignalHook;
<span class="udiff-line-modified-removed">- #define SIGNAL_HOOK(hook)   ((SignalHook*) (hook))</span>
<span class="udiff-line-modified-added">+ #define SIGNAL_HOOK(hook) ((SignalHook*) (hook))</span>
  
  struct _SignalNode
  {
    /* permanent portion */
    guint              signal_id;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -230,22 +230,22 @@</span>
    /* reinitializable portion */
    guint              flags : 9;
    guint              n_params : 8;
    guint              single_va_closure_is_valid : 1;
    guint              single_va_closure_is_after : 1;
<span class="udiff-line-modified-removed">-   GType         *param_types; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */</span>
<span class="udiff-line-modified-removed">-   GType          return_type; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */</span>
<span class="udiff-line-modified-added">+   GType       *param_types; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */</span>
<span class="udiff-line-modified-added">+   GType        return_type; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */</span>
    GBSearchArray     *class_closure_bsa;
    SignalAccumulator *accumulator;
    GSignalCMarshaller c_marshaller;
    GSignalCVaMarshaller va_marshaller;
    GHookList         *emission_hooks;
  
    GClosure *single_va_closure;
  };
  
<span class="udiff-line-modified-removed">- #define SINGLE_VA_CLOSURE_EMPTY_MAGIC GINT_TO_POINTER(1)    /* indicates single_va_closure is valid but empty */</span>
<span class="udiff-line-modified-added">+ #define SINGLE_VA_CLOSURE_EMPTY_MAGIC GINT_TO_POINTER(1)  /* indicates single_va_closure is valid but empty */</span>
  
  struct _SignalKey
  {
    GType  itype;
    GQuark quark;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -256,11 +256,11 @@</span>
  {
    Emission             *next;
    gpointer              instance;
    GSignalInvocationHint ihint;
    EmissionState         state;
<span class="udiff-line-modified-removed">-   GType         chain_type;</span>
<span class="udiff-line-modified-added">+   GType     chain_type;</span>
  };
  
  struct _HandlerList
  {
    guint    signal_id;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -272,11 +272,11 @@</span>
  struct _Handler
  {
    gulong        sequential_number;
    Handler      *next;
    Handler      *prev;
<span class="udiff-line-modified-removed">-   GQuark    detail;</span>
<span class="udiff-line-modified-added">+   GQuark  detail;</span>
    guint         signal_id;
    guint         ref_count;
    guint         block_count : 16;
  #define HANDLER_MAX_BLOCK_COUNT (1 &lt;&lt; 16)
    guint         after : 1;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -319,12 +319,12 @@</span>
  static Emission      *g_emissions = NULL;
  static gulong         g_handler_sequential_number = 1;
  static GHashTable    *g_handlers = NULL;
  
  G_LOCK_DEFINE_STATIC (g_signal_mutex);
<span class="udiff-line-modified-removed">- #define SIGNAL_LOCK()       G_LOCK (g_signal_mutex)</span>
<span class="udiff-line-modified-removed">- #define SIGNAL_UNLOCK()     G_UNLOCK (g_signal_mutex)</span>
<span class="udiff-line-modified-added">+ #define SIGNAL_LOCK()   G_LOCK (g_signal_mutex)</span>
<span class="udiff-line-modified-added">+ #define SIGNAL_UNLOCK()   G_UNLOCK (g_signal_mutex)</span>
  
  
  /* --- signal nodes --- */
  static guint          g_n_signal_nodes = 0;
  static SignalNode   **g_signal_nodes = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -340,11 +340,11 @@</span>
  
  
  /* --- functions --- */
  static inline guint
  signal_id_lookup (GQuark quark,
<span class="udiff-line-modified-removed">-           GType  itype)</span>
<span class="udiff-line-modified-added">+       GType  itype)</span>
  {
    GType *ifaces, type = itype;
    SignalKey key;
    guint n_ifaces;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -357,11 +357,11 @@</span>
  
        key.itype = type;
        signal_key = g_bsearch_array_lookup (g_signal_key_bsa, &amp;g_signal_key_bconfig, &amp;key);
  
        if (signal_key)
<span class="udiff-line-modified-removed">-     return signal_key-&gt;signal_id;</span>
<span class="udiff-line-modified-added">+   return signal_key-&gt;signal_id;</span>
  
        type = g_type_parent (type);
      }
    while (type);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -373,23 +373,23 @@</span>
  
        key.itype = ifaces[n_ifaces];
        signal_key = g_bsearch_array_lookup (g_signal_key_bsa, &amp;g_signal_key_bconfig, &amp;key);
  
        if (signal_key)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_free (ifaces);</span>
<span class="udiff-line-modified-removed">-       return signal_key-&gt;signal_id;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_free (ifaces);</span>
<span class="udiff-line-modified-added">+     return signal_key-&gt;signal_id;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    g_free (ifaces);
  
    return 0;
  }
  
  static gint
  class_closures_cmp (gconstpointer node1,
<span class="udiff-line-modified-removed">-             gconstpointer node2)</span>
<span class="udiff-line-modified-added">+         gconstpointer node2)</span>
  {
    const ClassClosure *c1 = node1, *c2 = node2;
  
    return G_BSEARCH_ARRAY_CMP (c1-&gt;instance_type, c2-&gt;instance_type);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -403,11 +403,11 @@</span>
    return G_BSEARCH_ARRAY_CMP (hlist1-&gt;signal_id, hlist2-&gt;signal_id);
  }
  
  static inline HandlerList*
  handler_list_ensure (guint    signal_id,
<span class="udiff-line-modified-removed">-              gpointer instance)</span>
<span class="udiff-line-modified-added">+          gpointer instance)</span>
  {
    GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
    HandlerList key;
  
    key.signal_id = signal_id;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -424,18 +424,18 @@</span>
      {
        GBSearchArray *o = hlbsa;
  
        hlbsa = g_bsearch_array_insert (o, &amp;g_signal_hlbsa_bconfig, &amp;key);
        if (hlbsa != o)
<span class="udiff-line-modified-removed">-     g_hash_table_insert (g_handler_list_bsa_ht, instance, hlbsa);</span>
<span class="udiff-line-modified-added">+   g_hash_table_insert (g_handler_list_bsa_ht, instance, hlbsa);</span>
      }
    return g_bsearch_array_lookup (hlbsa, &amp;g_signal_hlbsa_bconfig, &amp;key);
  }
  
  static inline HandlerList*
  handler_list_lookup (guint    signal_id,
<span class="udiff-line-modified-removed">-              gpointer instance)</span>
<span class="udiff-line-modified-added">+          gpointer instance)</span>
  {
    GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
    HandlerList key;
  
    key.signal_id = signal_id;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -458,13 +458,13 @@</span>
        (ha-&gt;instance  == hb-&gt;instance);
  }
  
  static Handler*
  handler_lookup (gpointer  instance,
<span class="udiff-line-modified-removed">-         gulong    handler_id,</span>
<span class="udiff-line-modified-removed">-         GClosure *closure,</span>
<span class="udiff-line-modified-removed">-         guint    *signal_id_p)</span>
<span class="udiff-line-modified-added">+     gulong    handler_id,</span>
<span class="udiff-line-modified-added">+     GClosure *closure,</span>
<span class="udiff-line-modified-added">+     guint    *signal_id_p)</span>
  {
    GBSearchArray *hlbsa;
  
    if (handler_id)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -500,12 +500,12 @@</span>
    return NULL;
  }
  
  static inline HandlerMatch*
  handler_match_prepend (HandlerMatch *list,
<span class="udiff-line-modified-removed">-                        Handler      *handler,</span>
<span class="udiff-line-modified-removed">-                guint         signal_id)</span>
<span class="udiff-line-modified-added">+            Handler      *handler,</span>
<span class="udiff-line-modified-added">+            guint       signal_id)</span>
  {
    HandlerMatch *node;
  
    node = g_slice_new (HandlerMatch);
  #ifdef GSTREAMER_LITE
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -520,11 +520,11 @@</span>
  
    return node;
  }
  static inline HandlerMatch*
  handler_match_free1_R (HandlerMatch *node,
<span class="udiff-line-modified-removed">-                gpointer      instance)</span>
<span class="udiff-line-modified-added">+            gpointer      instance)</span>
  {
    HandlerMatch *next = node-&gt;next;
  
    handler_unref_R (node-&gt;signal_id, instance, node-&gt;handler);
    g_slice_free (HandlerMatch, node);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -532,48 +532,48 @@</span>
    return next;
  }
  
  static HandlerMatch*
  handlers_find (gpointer         instance,
<span class="udiff-line-modified-removed">-            GSignalMatchType mask,</span>
<span class="udiff-line-modified-removed">-            guint            signal_id,</span>
<span class="udiff-line-modified-removed">-            GQuark           detail,</span>
<span class="udiff-line-modified-removed">-            GClosure        *closure,</span>
<span class="udiff-line-modified-removed">-            gpointer         func,</span>
<span class="udiff-line-modified-removed">-            gpointer         data,</span>
<span class="udiff-line-modified-removed">-            gboolean         one_and_only)</span>
<span class="udiff-line-modified-added">+          GSignalMatchType mask,</span>
<span class="udiff-line-modified-added">+          guint            signal_id,</span>
<span class="udiff-line-modified-added">+          GQuark           detail,</span>
<span class="udiff-line-modified-added">+          GClosure        *closure,</span>
<span class="udiff-line-modified-added">+          gpointer         func,</span>
<span class="udiff-line-modified-added">+          gpointer         data,</span>
<span class="udiff-line-modified-added">+          gboolean         one_and_only)</span>
  {
    HandlerMatch *mlist = NULL;
  
    if (mask &amp; G_SIGNAL_MATCH_ID)
      {
        HandlerList *hlist = handler_list_lookup (signal_id, instance);
        Handler *handler;
        SignalNode *node = NULL;
  
        if (mask &amp; G_SIGNAL_MATCH_FUNC)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       node = LOOKUP_SIGNAL_NODE (signal_id);</span>
<span class="udiff-line-modified-removed">-       if (!node || !node-&gt;c_marshaller)</span>
<span class="udiff-line-modified-removed">-         return NULL;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     node = LOOKUP_SIGNAL_NODE (signal_id);</span>
<span class="udiff-line-modified-added">+     if (!node || !node-&gt;c_marshaller)</span>
<span class="udiff-line-modified-added">+       return NULL;</span>
<span class="udiff-line-modified-added">+   }</span>
  
        mask = ~mask;
        for (handler = hlist ? hlist-&gt;handlers : NULL; handler; handler = handler-&gt;next)
          if (handler-&gt;sequential_number &amp;&amp;
<span class="udiff-line-modified-removed">-         ((mask &amp; G_SIGNAL_MATCH_DETAIL) || handler-&gt;detail == detail) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-         ((mask &amp; G_SIGNAL_MATCH_CLOSURE) || handler-&gt;closure == closure) &amp;&amp;</span>
<span class="udiff-line-modified-added">+       ((mask &amp; G_SIGNAL_MATCH_DETAIL) || handler-&gt;detail == detail) &amp;&amp;</span>
<span class="udiff-line-modified-added">+       ((mask &amp; G_SIGNAL_MATCH_CLOSURE) || handler-&gt;closure == closure) &amp;&amp;</span>
              ((mask &amp; G_SIGNAL_MATCH_DATA) || handler-&gt;closure-&gt;data == data) &amp;&amp;
<span class="udiff-line-modified-removed">-         ((mask &amp; G_SIGNAL_MATCH_UNBLOCKED) || handler-&gt;block_count == 0) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-         ((mask &amp; G_SIGNAL_MATCH_FUNC) || (handler-&gt;closure-&gt;marshal == node-&gt;c_marshaller &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                           G_REAL_CLOSURE (handler-&gt;closure)-&gt;meta_marshal == NULL &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                           ((GCClosure*) handler-&gt;closure)-&gt;callback == func)))</span>
<span class="udiff-line-modified-removed">-       {</span>
<span class="udiff-line-modified-removed">-         mlist = handler_match_prepend (mlist, handler, signal_id);</span>
<span class="udiff-line-modified-removed">-         if (one_and_only)</span>
<span class="udiff-line-modified-removed">-           return mlist;</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-added">+       ((mask &amp; G_SIGNAL_MATCH_UNBLOCKED) || handler-&gt;block_count == 0) &amp;&amp;</span>
<span class="udiff-line-modified-added">+       ((mask &amp; G_SIGNAL_MATCH_FUNC) || (handler-&gt;closure-&gt;marshal == node-&gt;c_marshaller &amp;&amp;</span>
<span class="udiff-line-modified-added">+                 G_REAL_CLOSURE (handler-&gt;closure)-&gt;meta_marshal == NULL &amp;&amp;</span>
<span class="udiff-line-modified-added">+                 ((GCClosure*) handler-&gt;closure)-&gt;callback == func)))</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       mlist = handler_match_prepend (mlist, handler, signal_id);</span>
<span class="udiff-line-modified-added">+       if (one_and_only)</span>
<span class="udiff-line-modified-added">+         return mlist;</span>
<span class="udiff-line-modified-added">+     }</span>
      }
    else
      {
        GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -583,38 +583,38 @@</span>
            guint i;
  
            for (i = 0; i &lt; hlbsa-&gt;n_nodes; i++)
              {
                HandlerList *hlist = g_bsearch_array_get_nth (hlbsa, &amp;g_signal_hlbsa_bconfig, i);
<span class="udiff-line-modified-removed">-           SignalNode *node = NULL;</span>
<span class="udiff-line-modified-added">+         SignalNode *node = NULL;</span>
                Handler *handler;
  
<span class="udiff-line-modified-removed">-           if (!(mask &amp; G_SIGNAL_MATCH_FUNC))</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           node = LOOKUP_SIGNAL_NODE (hlist-&gt;signal_id);</span>
<span class="udiff-line-modified-added">+         if (!(mask &amp; G_SIGNAL_MATCH_FUNC))</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       node = LOOKUP_SIGNAL_NODE (hlist-&gt;signal_id);</span>
  #ifndef GSTREAMER_LITE
<span class="udiff-line-modified-removed">-           if (!node-&gt;c_marshaller)</span>
<span class="udiff-line-modified-added">+       if (!node-&gt;c_marshaller)</span>
  #else // GSTREAMER_LITE
            if (!node || !node-&gt;c_marshaller)
  #endif // GSTREAMER_LITE
<span class="udiff-line-modified-removed">-             continue;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+         continue;</span>
<span class="udiff-line-modified-added">+     }</span>
  
                for (handler = hlist-&gt;handlers; handler; handler = handler-&gt;next)
<span class="udiff-line-modified-removed">-         if (handler-&gt;sequential_number &amp;&amp;</span>
<span class="udiff-line-modified-removed">-             ((mask &amp; G_SIGNAL_MATCH_DETAIL) || handler-&gt;detail == detail) &amp;&amp;</span>
<span class="udiff-line-modified-added">+     if (handler-&gt;sequential_number &amp;&amp;</span>
<span class="udiff-line-modified-added">+         ((mask &amp; G_SIGNAL_MATCH_DETAIL) || handler-&gt;detail == detail) &amp;&amp;</span>
                      ((mask &amp; G_SIGNAL_MATCH_CLOSURE) || handler-&gt;closure == closure) &amp;&amp;
                      ((mask &amp; G_SIGNAL_MATCH_DATA) || handler-&gt;closure-&gt;data == data) &amp;&amp;
<span class="udiff-line-modified-removed">-             ((mask &amp; G_SIGNAL_MATCH_UNBLOCKED) || handler-&gt;block_count == 0) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-             ((mask &amp; G_SIGNAL_MATCH_FUNC) || (handler-&gt;closure-&gt;marshal == node-&gt;c_marshaller &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                               G_REAL_CLOSURE (handler-&gt;closure)-&gt;meta_marshal == NULL &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                               ((GCClosure*) handler-&gt;closure)-&gt;callback == func)))</span>
<span class="udiff-line-modified-removed">-           {</span>
<span class="udiff-line-modified-removed">-             mlist = handler_match_prepend (mlist, handler, hlist-&gt;signal_id);</span>
<span class="udiff-line-modified-removed">-             if (one_and_only)</span>
<span class="udiff-line-modified-removed">-               return mlist;</span>
<span class="udiff-line-modified-removed">-           }</span>
<span class="udiff-line-modified-added">+         ((mask &amp; G_SIGNAL_MATCH_UNBLOCKED) || handler-&gt;block_count == 0) &amp;&amp;</span>
<span class="udiff-line-modified-added">+         ((mask &amp; G_SIGNAL_MATCH_FUNC) || (handler-&gt;closure-&gt;marshal == node-&gt;c_marshaller &amp;&amp;</span>
<span class="udiff-line-modified-added">+                   G_REAL_CLOSURE (handler-&gt;closure)-&gt;meta_marshal == NULL &amp;&amp;</span>
<span class="udiff-line-modified-added">+                   ((GCClosure*) handler-&gt;closure)-&gt;callback == func)))</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         mlist = handler_match_prepend (mlist, handler, hlist-&gt;signal_id);</span>
<span class="udiff-line-modified-added">+         if (one_and_only)</span>
<span class="udiff-line-modified-added">+           return mlist;</span>
<span class="udiff-line-modified-added">+       }</span>
              }
          }
      }
  
    return mlist;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -654,12 +654,12 @@</span>
    handler-&gt;ref_count++;
  }
  
  static inline void
  handler_unref_R (guint    signal_id,
<span class="udiff-line-modified-removed">-          gpointer instance,</span>
<span class="udiff-line-modified-removed">-          Handler *handler)</span>
<span class="udiff-line-modified-added">+      gpointer instance,</span>
<span class="udiff-line-modified-added">+      Handler *handler)</span>
  {
    g_return_if_fail (handler-&gt;ref_count &gt; 0);
  
    handler-&gt;ref_count--;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -712,12 +712,12 @@</span>
      }
  }
  
  static void
  handler_insert (guint    signal_id,
<span class="udiff-line-modified-removed">-         gpointer instance,</span>
<span class="udiff-line-modified-removed">-         Handler  *handler)</span>
<span class="udiff-line-modified-added">+     gpointer instance,</span>
<span class="udiff-line-modified-added">+     Handler  *handler)</span>
  {
    HandlerList *hlist;
  
    g_assert (handler-&gt;prev == NULL &amp;&amp; handler-&gt;next == NULL); /* paranoid */
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -771,28 +771,28 @@</span>
        GSignalFlags run_type;
        ClassClosure * cc;
        GBSearchArray *bsa = node-&gt;class_closure_bsa;
  
        if (bsa == NULL || bsa-&gt;n_nodes == 0)
<span class="udiff-line-modified-removed">-     closure = SINGLE_VA_CLOSURE_EMPTY_MAGIC;</span>
<span class="udiff-line-modified-added">+   closure = SINGLE_VA_CLOSURE_EMPTY_MAGIC;</span>
        else if (bsa-&gt;n_nodes == 1)
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     /* Look for default class closure (can&#39;t support non-default as it</span>
<span class="udiff-line-added">+        chains up using GValues */</span>
<span class="udiff-line-added">+     cc = g_bsearch_array_get_nth (bsa, &amp;g_class_closure_bconfig, 0);</span>
<span class="udiff-line-added">+     if (cc-&gt;instance_type == 0)</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         run_type = node-&gt;flags &amp; (G_SIGNAL_RUN_FIRST|G_SIGNAL_RUN_LAST|G_SIGNAL_RUN_CLEANUP);</span>
<span class="udiff-line-added">+         /* Only support *one* of run-first or run-last, not multiple or cleanup */</span>
<span class="udiff-line-added">+         if (run_type == G_SIGNAL_RUN_FIRST ||</span>
<span class="udiff-line-added">+       run_type == G_SIGNAL_RUN_LAST)</span>
      {
<span class="udiff-line-modified-removed">-       /* Look for default class closure (can&#39;t support non-default as it</span>
<span class="udiff-line-modified-removed">-          chains up using GValues */</span>
<span class="udiff-line-removed">-       cc = g_bsearch_array_get_nth (bsa, &amp;g_class_closure_bconfig, 0);</span>
<span class="udiff-line-removed">-       if (cc-&gt;instance_type == 0)</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-           run_type = node-&gt;flags &amp; (G_SIGNAL_RUN_FIRST|G_SIGNAL_RUN_LAST|G_SIGNAL_RUN_CLEANUP);</span>
<span class="udiff-line-removed">-           /* Only support *one* of run-first or run-last, not multiple or cleanup */</span>
<span class="udiff-line-removed">-           if (run_type == G_SIGNAL_RUN_FIRST ||</span>
<span class="udiff-line-removed">-           run_type == G_SIGNAL_RUN_LAST)</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-           closure = cc-&gt;closure;</span>
<span class="udiff-line-removed">-           is_after = (run_type == G_SIGNAL_RUN_LAST);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+       closure = cc-&gt;closure;</span>
<span class="udiff-line-modified-added">+       is_after = (run_type == G_SIGNAL_RUN_LAST);</span>
      }
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+   }</span>
      }
  
    node-&gt;single_va_closure_is_valid = TRUE;
    node-&gt;single_va_closure = closure;
    node-&gt;single_va_closure_is_after = is_after;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -811,30 +811,30 @@</span>
    Emission *node, *last = NULL;
  
    for (node = g_emissions; node; last = node, node = last-&gt;next)
      if (node == emission)
        {
<span class="udiff-line-modified-removed">-     if (last)</span>
<span class="udiff-line-modified-removed">-       last-&gt;next = node-&gt;next;</span>
<span class="udiff-line-modified-removed">-     else</span>
<span class="udiff-line-modified-removed">-       g_emissions = node-&gt;next;</span>
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-modified-added">+   if (last)</span>
<span class="udiff-line-modified-added">+     last-&gt;next = node-&gt;next;</span>
<span class="udiff-line-modified-added">+   else</span>
<span class="udiff-line-modified-added">+     g_emissions = node-&gt;next;</span>
<span class="udiff-line-modified-added">+   return;</span>
        }
    g_assert_not_reached ();
  }
  
  static inline Emission*
  emission_find (guint     signal_id,
<span class="udiff-line-modified-removed">-            GQuark    detail,</span>
<span class="udiff-line-modified-removed">-            gpointer  instance)</span>
<span class="udiff-line-modified-added">+          GQuark    detail,</span>
<span class="udiff-line-modified-added">+          gpointer  instance)</span>
  {
    Emission *emission;
  
    for (emission = g_emissions; emission; emission = emission-&gt;next)
      if (emission-&gt;instance == instance &amp;&amp;
<span class="udiff-line-modified-removed">-     emission-&gt;ihint.signal_id == signal_id &amp;&amp;</span>
<span class="udiff-line-modified-removed">-     emission-&gt;ihint.detail == detail)</span>
<span class="udiff-line-modified-added">+   emission-&gt;ihint.signal_id == signal_id &amp;&amp;</span>
<span class="udiff-line-modified-added">+   emission-&gt;ihint.detail == detail)</span>
        return emission;
    return NULL;
  }
  
  static inline Emission*
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -845,11 +845,11 @@</span>
    for (emission = g_emissions; emission; emission = emission-&gt;next)
      if (emission-&gt;instance == instance)
        return emission;
  
    return NULL;
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-added">+ }</span>
  
  static gint
  signal_key_cmp (gconstpointer node1,
                  gconstpointer node2)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -895,11 +895,11 @@</span>
            if (node-&gt;destroyed)
              g_warning (G_STRLOC &quot;: signal \&quot;%s\&quot; of type &#39;%s&#39; already destroyed&quot;,
                         node-&gt;name,
                         type_debug_name (node-&gt;itype));
            else
<span class="udiff-line-modified-removed">-         signal_destroy_R (node);</span>
<span class="udiff-line-modified-added">+       signal_destroy_R (node);</span>
          }
      }
    SIGNAL_UNLOCK ();
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -918,11 +918,11 @@</span>
   * Prints a warning if used on a signal which isn&#39;t being emitted.
   */
  void
  g_signal_stop_emission (gpointer instance,
                          guint    signal_id,
<span class="udiff-line-modified-removed">-             GQuark   detail)</span>
<span class="udiff-line-modified-added">+       GQuark   detail)</span>
  {
    SignalNode *node;
  
    g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
    g_return_if_fail (signal_id &gt; 0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -956,11 +956,11 @@</span>
    SIGNAL_UNLOCK ();
  }
  
  static void
  signal_finalize_hook (GHookList *hook_list,
<span class="udiff-line-modified-removed">-               GHook     *hook)</span>
<span class="udiff-line-modified-added">+           GHook     *hook)</span>
  {
    GDestroyNotify destroy = hook-&gt;destroy;
  
    if (destroy)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -985,14 +985,14 @@</span>
   *
   * Returns: the hook id, for later use with g_signal_remove_emission_hook().
   */
  gulong
  g_signal_add_emission_hook (guint               signal_id,
<span class="udiff-line-modified-removed">-                 GQuark              detail,</span>
<span class="udiff-line-modified-removed">-                 GSignalEmissionHook hook_func,</span>
<span class="udiff-line-modified-removed">-                 gpointer            hook_data,</span>
<span class="udiff-line-modified-removed">-                 GDestroyNotify      data_destroy)</span>
<span class="udiff-line-modified-added">+           GQuark              detail,</span>
<span class="udiff-line-modified-added">+           GSignalEmissionHook hook_func,</span>
<span class="udiff-line-modified-added">+           gpointer            hook_data,</span>
<span class="udiff-line-modified-added">+           GDestroyNotify      data_destroy)</span>
  {
    static gulong seq_hook_id = 1;
    SignalNode *node;
    GHook *hook;
    SignalHook *signal_hook;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1053,11 +1053,11 @@</span>
   *
   * Deletes an emission hook.
   */
  void
  g_signal_remove_emission_hook (guint  signal_id,
<span class="udiff-line-modified-removed">-                    gulong hook_id)</span>
<span class="udiff-line-modified-added">+              gulong hook_id)</span>
  {
    SignalNode *node;
  
    g_return_if_fail (signal_id &gt; 0);
    g_return_if_fail (hook_id &gt; 0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1078,46 +1078,46 @@</span>
    SIGNAL_UNLOCK ();
  }
  
  static inline guint
  signal_parse_name (const gchar *name,
<span class="udiff-line-modified-removed">-            GType        itype,</span>
<span class="udiff-line-modified-removed">-            GQuark      *detail_p,</span>
<span class="udiff-line-modified-removed">-            gboolean     force_quark)</span>
<span class="udiff-line-modified-added">+        GType        itype,</span>
<span class="udiff-line-modified-added">+        GQuark      *detail_p,</span>
<span class="udiff-line-modified-added">+        gboolean     force_quark)</span>
  {
    const gchar *colon = strchr (name, &#39;:&#39;);
    guint signal_id;
  
    if (!colon)
      {
        signal_id = signal_id_lookup (g_quark_try_string (name), itype);
        if (signal_id &amp;&amp; detail_p)
<span class="udiff-line-modified-removed">-     *detail_p = 0;</span>
<span class="udiff-line-modified-added">+   *detail_p = 0;</span>
      }
    else if (colon[1] == &#39;:&#39;)
      {
        gchar buffer[32];
        guint l = colon - name;
  
        if (l &lt; 32)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       memcpy (buffer, name, l);</span>
<span class="udiff-line-modified-removed">-       buffer[l] = 0;</span>
<span class="udiff-line-modified-removed">-       signal_id = signal_id_lookup (g_quark_try_string (buffer), itype);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     memcpy (buffer, name, l);</span>
<span class="udiff-line-modified-added">+     buffer[l] = 0;</span>
<span class="udiff-line-modified-added">+     signal_id = signal_id_lookup (g_quark_try_string (buffer), itype);</span>
<span class="udiff-line-modified-added">+   }</span>
        else
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       gchar *signal = g_new (gchar, l + 1);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     gchar *signal = g_new (gchar, l + 1);</span>
  
<span class="udiff-line-modified-removed">-       memcpy (signal, name, l);</span>
<span class="udiff-line-modified-removed">-       signal[l] = 0;</span>
<span class="udiff-line-modified-removed">-       signal_id = signal_id_lookup (g_quark_try_string (signal), itype);</span>
<span class="udiff-line-modified-removed">-       g_free (signal);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     memcpy (signal, name, l);</span>
<span class="udiff-line-modified-added">+     signal[l] = 0;</span>
<span class="udiff-line-modified-added">+     signal_id = signal_id_lookup (g_quark_try_string (signal), itype);</span>
<span class="udiff-line-modified-added">+     g_free (signal);</span>
<span class="udiff-line-modified-added">+   }</span>
  
        if (signal_id &amp;&amp; detail_p)
<span class="udiff-line-modified-removed">-     *detail_p = colon[2] ? (force_quark ? g_quark_from_string : g_quark_try_string) (colon + 2) : 0;</span>
<span class="udiff-line-modified-added">+   *detail_p = colon[2] ? (force_quark ? g_quark_from_string : g_quark_try_string) (colon + 2) : 0;</span>
      }
    else
      signal_id = 0;
    return signal_id;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1135,14 +1135,14 @@</span>
   *
   * Returns: Whether the signal name could successfully be parsed and @signal_id_p and @detail_p contain valid return values.
   */
  gboolean
  g_signal_parse_name (const gchar *detailed_signal,
<span class="udiff-line-modified-removed">-                      GType        itype,</span>
<span class="udiff-line-modified-removed">-                      guint       *signal_id_p,</span>
<span class="udiff-line-modified-removed">-                      GQuark      *detail_p,</span>
<span class="udiff-line-modified-removed">-              gboolean     force_detail_quark)</span>
<span class="udiff-line-modified-added">+          GType        itype,</span>
<span class="udiff-line-modified-added">+          guint       *signal_id_p,</span>
<span class="udiff-line-modified-added">+          GQuark      *detail_p,</span>
<span class="udiff-line-modified-added">+          gboolean   force_detail_quark)</span>
  {
    SignalNode *node;
    GQuark detail = 0;
    guint signal_id;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1176,11 +1176,11 @@</span>
   * This is just like g_signal_stop_emission() except it will look up the
   * signal id for you.
   */
  void
  g_signal_stop_emission_by_name (gpointer     instance,
<span class="udiff-line-modified-removed">-                 const gchar *detailed_signal)</span>
<span class="udiff-line-modified-added">+         const gchar *detailed_signal)</span>
  {
    guint signal_id;
    GQuark detail = 0;
    GType itype;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1193,30 +1193,30 @@</span>
    if (signal_id)
      {
        SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
  
        if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
<span class="udiff-line-modified-removed">-     g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);</span>
        else if (!g_type_is_a (itype, node-&gt;itype))
          g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                     G_STRLOC, detailed_signal, instance, g_type_name (itype));
        else
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       Emission *emission = emission_find (signal_id, detail, instance);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     Emission *emission = emission_find (signal_id, detail, instance);</span>
  
<span class="udiff-line-modified-removed">-       if (emission)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           if (emission-&gt;state == EMISSION_HOOK)</span>
<span class="udiff-line-modified-removed">-         g_warning (G_STRLOC &quot;: emission of signal \&quot;%s\&quot; for instance &#39;%p&#39; cannot be stopped from emission hook&quot;,</span>
<span class="udiff-line-modified-removed">-                node-&gt;name, instance);</span>
<span class="udiff-line-modified-removed">-           else if (emission-&gt;state == EMISSION_RUN)</span>
<span class="udiff-line-modified-removed">-         emission-&gt;state = EMISSION_STOP;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-       else</span>
<span class="udiff-line-modified-removed">-         g_warning (G_STRLOC &quot;: no emission of signal \&quot;%s\&quot; to stop for instance &#39;%p&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-                node-&gt;name, instance);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     if (emission)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         if (emission-&gt;state == EMISSION_HOOK)</span>
<span class="udiff-line-modified-added">+     g_warning (G_STRLOC &quot;: emission of signal \&quot;%s\&quot; for instance &#39;%p&#39; cannot be stopped from emission hook&quot;,</span>
<span class="udiff-line-modified-added">+          node-&gt;name, instance);</span>
<span class="udiff-line-modified-added">+         else if (emission-&gt;state == EMISSION_RUN)</span>
<span class="udiff-line-modified-added">+     emission-&gt;state = EMISSION_STOP;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+     else</span>
<span class="udiff-line-modified-added">+       g_warning (G_STRLOC &quot;: no emission of signal \&quot;%s\&quot; to stop for instance &#39;%p&#39;&quot;,</span>
<span class="udiff-line-modified-added">+            node-&gt;name, instance);</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    else
      g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                 G_STRLOC, detailed_signal, instance, g_type_name (itype));
    SIGNAL_UNLOCK ();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1250,18 +1250,18 @@</span>
    SIGNAL_UNLOCK ();
    if (!signal_id)
      {
        /* give elaborate warnings */
        if (!g_type_name (itype))
<span class="udiff-line-modified-removed">-     g_warning (G_STRLOC &quot;: unable to lookup signal \&quot;%s\&quot; for invalid type id &#39;%&quot;G_GSIZE_FORMAT&quot;&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-            name, itype);</span>
<span class="udiff-line-modified-added">+   g_warning (G_STRLOC &quot;: unable to look up signal \&quot;%s\&quot; for invalid type id &#39;%&quot;G_GSIZE_FORMAT&quot;&#39;&quot;,</span>
<span class="udiff-line-modified-added">+        name, itype);</span>
        else if (!G_TYPE_IS_INSTANTIATABLE (itype))
<span class="udiff-line-modified-removed">-     g_warning (G_STRLOC &quot;: unable to lookup signal \&quot;%s\&quot; for non instantiatable type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-            name, g_type_name (itype));</span>
<span class="udiff-line-modified-added">+   g_warning (G_STRLOC &quot;: unable to look up signal \&quot;%s\&quot; for non instantiatable type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+        name, g_type_name (itype));</span>
        else if (!g_type_class_peek (itype))
<span class="udiff-line-modified-removed">-     g_warning (G_STRLOC &quot;: unable to lookup signal \&quot;%s\&quot; of unloaded type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-            name, g_type_name (itype));</span>
<span class="udiff-line-modified-added">+   g_warning (G_STRLOC &quot;: unable to look up signal \&quot;%s\&quot; of unloaded type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+        name, g_type_name (itype));</span>
      }
  
    return signal_id;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1276,11 +1276,11 @@</span>
   *
   * Returns: (array length=n_ids) (transfer full): Newly allocated array of signal IDs.
   */
  guint*
  g_signal_list_ids (GType  itype,
<span class="udiff-line-modified-removed">-            guint *n_ids)</span>
<span class="udiff-line-modified-added">+        guint *n_ids)</span>
  {
    SignalKey *keys;
    GArray *result;
    guint n_nodes;
    guint i;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1300,32 +1300,32 @@</span>
  #endif // GSTREAMER_LITE
  
    for (i = 0; i &lt; n_nodes; i++)
      if (keys[i].itype == itype)
        {
<span class="udiff-line-modified-removed">-     const gchar *name = g_quark_to_string (keys[i].quark);</span>
<span class="udiff-line-modified-added">+   const gchar *name = g_quark_to_string (keys[i].quark);</span>
  
<span class="udiff-line-modified-removed">-     /* Signal names with &quot;_&quot; in them are aliases to the same</span>
<span class="udiff-line-modified-removed">-      * name with &quot;-&quot; instead of &quot;_&quot;.</span>
<span class="udiff-line-modified-removed">-      */</span>
<span class="udiff-line-modified-removed">-     if (!strchr (name, &#39;_&#39;))</span>
<span class="udiff-line-modified-removed">-       g_array_append_val (result, keys[i].signal_id);</span>
<span class="udiff-line-modified-added">+   /* Signal names with &quot;_&quot; in them are aliases to the same</span>
<span class="udiff-line-modified-added">+    * name with &quot;-&quot; instead of &quot;_&quot;.</span>
<span class="udiff-line-modified-added">+    */</span>
<span class="udiff-line-modified-added">+   if (!strchr (name, &#39;_&#39;))</span>
<span class="udiff-line-modified-added">+     g_array_append_val (result, keys[i].signal_id);</span>
        }
    *n_ids = result-&gt;len;
    SIGNAL_UNLOCK ();
    if (!n_nodes)
      {
        /* give elaborate warnings */
        if (!g_type_name (itype))
<span class="udiff-line-modified-removed">-     g_warning (G_STRLOC &quot;: unable to list signals for invalid type id &#39;%&quot;G_GSIZE_FORMAT&quot;&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-            itype);</span>
<span class="udiff-line-modified-added">+   g_warning (G_STRLOC &quot;: unable to list signals for invalid type id &#39;%&quot;G_GSIZE_FORMAT&quot;&#39;&quot;,</span>
<span class="udiff-line-modified-added">+        itype);</span>
        else if (!G_TYPE_IS_INSTANTIATABLE (itype) &amp;&amp; !G_TYPE_IS_INTERFACE (itype))
<span class="udiff-line-modified-removed">-     g_warning (G_STRLOC &quot;: unable to list signals of non instantiatable type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-            g_type_name (itype));</span>
<span class="udiff-line-modified-added">+   g_warning (G_STRLOC &quot;: unable to list signals of non instantiatable type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+        g_type_name (itype));</span>
        else if (!g_type_class_peek (itype) &amp;&amp; !G_TYPE_IS_INTERFACE (itype))
<span class="udiff-line-modified-removed">-     g_warning (G_STRLOC &quot;: unable to list signals of unloaded type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-            g_type_name (itype));</span>
<span class="udiff-line-modified-added">+   g_warning (G_STRLOC &quot;: unable to list signals of unloaded type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+        g_type_name (itype));</span>
      }
  
    return (guint*) g_array_free (result, FALSE);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1366,11 +1366,11 @@</span>
   * is 0. All members filled into the #GSignalQuery structure should
   * be considered constant and have to be left untouched.
   */
  void
  g_signal_query (guint         signal_id,
<span class="udiff-line-modified-removed">-         GSignalQuery *query)</span>
<span class="udiff-line-modified-added">+     GSignalQuery *query)</span>
  {
    SignalNode *node;
  
    g_return_if_fail (query != NULL);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1423,37 +1423,43 @@</span>
   *
   * If 0 is used for @class_offset subclasses cannot override the class handler
   * in their class_init method by doing super_class-&gt;signal_handler = my_signal_handler.
   * Instead they will have to use g_signal_override_class_handler().
   *
<span class="udiff-line-modified-removed">-  * If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as</span>
<span class="udiff-line-modified-removed">-  * the marshaller for this signal.</span>
<span class="udiff-line-modified-added">+  * If @c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as</span>
<span class="udiff-line-modified-added">+  * the marshaller for this signal. In some simple cases, g_signal_new()</span>
<span class="udiff-line-added">+  * will use a more optimized c_marshaller and va_marshaller for the signal</span>
<span class="udiff-line-added">+  * instead of g_cclosure_marshal_generic().</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * If @c_marshaller is non-%NULL, you need to also specify a va_marshaller</span>
<span class="udiff-line-added">+  * using g_signal_set_va_marshaller() or the generic va_marshaller will</span>
<span class="udiff-line-added">+  * be used.</span>
   *
   * Returns: the signal id
   */
  guint
<span class="udiff-line-modified-removed">- g_signal_new (const gchar    *signal_name,</span>
<span class="udiff-line-modified-removed">-           GType       itype,</span>
<span class="udiff-line-modified-removed">-           GSignalFlags    signal_flags,</span>
<span class="udiff-line-modified-removed">-               guint               class_offset,</span>
<span class="udiff-line-modified-removed">-               GSignalAccumulator  accumulator,</span>
<span class="udiff-line-modified-removed">-           gpointer        accu_data,</span>
<span class="udiff-line-modified-removed">-               GSignalCMarshaller  c_marshaller,</span>
<span class="udiff-line-modified-removed">-           GType       return_type,</span>
<span class="udiff-line-modified-removed">-           guint       n_params,</span>
<span class="udiff-line-modified-removed">-               ...)</span>
<span class="udiff-line-modified-added">+ g_signal_new (const gchar  *signal_name,</span>
<span class="udiff-line-modified-added">+         GType     itype,</span>
<span class="udiff-line-modified-added">+         GSignalFlags    signal_flags,</span>
<span class="udiff-line-modified-added">+         guint               class_offset,</span>
<span class="udiff-line-modified-added">+         GSignalAccumulator  accumulator,</span>
<span class="udiff-line-modified-added">+         gpointer      accu_data,</span>
<span class="udiff-line-modified-added">+         GSignalCMarshaller  c_marshaller,</span>
<span class="udiff-line-modified-added">+         GType     return_type,</span>
<span class="udiff-line-modified-added">+         guint     n_params,</span>
<span class="udiff-line-modified-added">+         ...)</span>
  {
    va_list args;
    guint signal_id;
  
    g_return_val_if_fail (signal_name != NULL, 0);
  
    va_start (args, n_params);
  
    signal_id = g_signal_new_valist (signal_name, itype, signal_flags,
                                     class_offset ? g_signal_type_cclosure_new (itype, class_offset) : NULL,
<span class="udiff-line-modified-removed">-                    accumulator, accu_data, c_marshaller,</span>
<span class="udiff-line-modified-added">+            accumulator, accu_data, c_marshaller,</span>
                                     return_type, n_params, args);
  
    va_end (args);
  
    return signal_id;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1529,11 +1535,11 @@</span>
    return signal_id;
  }
  
  static inline ClassClosure*
  signal_find_class_closure (SignalNode *node,
<span class="udiff-line-modified-removed">-                GType       itype)</span>
<span class="udiff-line-modified-added">+          GType       itype)</span>
  {
    GBSearchArray *bsa = node-&gt;class_closure_bsa;
    ClassClosure *cc;
  
    if (bsa)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1550,52 +1556,52 @@</span>
          }
  
        key.instance_type = itype;
        cc = g_bsearch_array_lookup (bsa, &amp;g_class_closure_bconfig, &amp;key);
        while (!cc &amp;&amp; key.instance_type)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       key.instance_type = g_type_parent (key.instance_type);</span>
<span class="udiff-line-modified-removed">-       cc = g_bsearch_array_lookup (bsa, &amp;g_class_closure_bconfig, &amp;key);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     key.instance_type = g_type_parent (key.instance_type);</span>
<span class="udiff-line-modified-added">+     cc = g_bsearch_array_lookup (bsa, &amp;g_class_closure_bconfig, &amp;key);</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    else
      cc = NULL;
    return cc;
  }
  
  static inline GClosure*
  signal_lookup_closure (SignalNode    *node,
<span class="udiff-line-modified-removed">-                GTypeInstance *instance)</span>
<span class="udiff-line-modified-added">+            GTypeInstance *instance)</span>
  {
    ClassClosure *cc;
  
    cc = signal_find_class_closure (node, G_TYPE_FROM_INSTANCE (instance));
    return cc ? cc-&gt;closure : NULL;
  }
  
  static void
  signal_add_class_closure (SignalNode *node,
<span class="udiff-line-modified-removed">-               GType       itype,</span>
<span class="udiff-line-modified-removed">-               GClosure   *closure)</span>
<span class="udiff-line-modified-added">+         GType       itype,</span>
<span class="udiff-line-modified-added">+         GClosure   *closure)</span>
  {
    ClassClosure key;
  
    node-&gt;single_va_closure_is_valid = FALSE;
  
    if (!node-&gt;class_closure_bsa)
      node-&gt;class_closure_bsa = g_bsearch_array_create (&amp;g_class_closure_bconfig);
    key.instance_type = itype;
    key.closure = g_closure_ref (closure);
    node-&gt;class_closure_bsa = g_bsearch_array_insert (node-&gt;class_closure_bsa,
<span class="udiff-line-modified-removed">-                             &amp;g_class_closure_bconfig,</span>
<span class="udiff-line-modified-removed">-                             &amp;key);</span>
<span class="udiff-line-modified-added">+                 &amp;g_class_closure_bconfig,</span>
<span class="udiff-line-modified-added">+                 &amp;key);</span>
    g_closure_sink (closure);
    if (node-&gt;c_marshaller &amp;&amp; closure &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (closure))
      {
        g_closure_set_marshal (closure, node-&gt;c_marshaller);
        if (node-&gt;va_marshaller)
<span class="udiff-line-modified-removed">-     _g_closure_set_va_marshal (closure, node-&gt;va_marshaller);</span>
<span class="udiff-line-modified-added">+   _g_closure_set_va_marshal (closure, node-&gt;va_marshaller);</span>
      }
  }
  
  /**
   * g_signal_newv:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1631,15 +1637,15 @@</span>
  g_signal_newv (const gchar       *signal_name,
                 GType              itype,
                 GSignalFlags       signal_flags,
                 GClosure          *class_closure,
                 GSignalAccumulator accumulator,
<span class="udiff-line-modified-removed">-            gpointer       accu_data,</span>
<span class="udiff-line-modified-added">+          gpointer     accu_data,</span>
                 GSignalCMarshaller c_marshaller,
<span class="udiff-line-modified-removed">-                GType          return_type,</span>
<span class="udiff-line-modified-added">+                GType      return_type,</span>
                 guint              n_params,
<span class="udiff-line-modified-removed">-                GType         *param_types)</span>
<span class="udiff-line-modified-added">+                GType     *param_types)</span>
  {
    gchar *name;
    guint signal_id, i;
    SignalNode *node;
    GSignalCMarshaller builtin_c_marshaller;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1684,29 +1690,29 @@</span>
        return 0;
      }
    for (i = 0; i &lt; n_params; i++)
      if (!G_TYPE_IS_VALUE (param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
        {
<span class="udiff-line-modified-removed">-     g_warning (G_STRLOC &quot;: parameter %d of type &#39;%s&#39; for signal \&quot;%s::%s\&quot; is not a value type&quot;,</span>
<span class="udiff-line-modified-removed">-            i + 1, type_debug_name (param_types[i]), type_debug_name (itype), name);</span>
<span class="udiff-line-modified-removed">-     g_free (name);</span>
<span class="udiff-line-modified-removed">-     SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-removed">-     return 0;</span>
<span class="udiff-line-modified-added">+   g_warning (G_STRLOC &quot;: parameter %d of type &#39;%s&#39; for signal \&quot;%s::%s\&quot; is not a value type&quot;,</span>
<span class="udiff-line-modified-added">+        i + 1, type_debug_name (param_types[i]), type_debug_name (itype), name);</span>
<span class="udiff-line-modified-added">+   g_free (name);</span>
<span class="udiff-line-modified-added">+   SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-added">+   return 0;</span>
        }
    if (return_type != G_TYPE_NONE &amp;&amp; !G_TYPE_IS_VALUE (return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
      {
        g_warning (G_STRLOC &quot;: return value of type &#39;%s&#39; for signal \&quot;%s::%s\&quot; is not a value type&quot;,
<span class="udiff-line-modified-removed">-          type_debug_name (return_type), type_debug_name (itype), name);</span>
<span class="udiff-line-modified-added">+      type_debug_name (return_type), type_debug_name (itype), name);</span>
        g_free (name);
        SIGNAL_UNLOCK ();
        return 0;
      }
    if (return_type != G_TYPE_NONE &amp;&amp;
        (signal_flags &amp; (G_SIGNAL_RUN_FIRST | G_SIGNAL_RUN_LAST | G_SIGNAL_RUN_CLEANUP)) == G_SIGNAL_RUN_FIRST)
      {
        g_warning (G_STRLOC &quot;: signal \&quot;%s::%s\&quot; has return type &#39;%s&#39; and is only G_SIGNAL_RUN_FIRST&quot;,
<span class="udiff-line-modified-removed">-          type_debug_name (itype), name, type_debug_name (return_type));</span>
<span class="udiff-line-modified-added">+      type_debug_name (itype), name, type_debug_name (return_type));</span>
        g_free (name);
        SIGNAL_UNLOCK ();
        return 0;
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1763,14 +1769,14 @@</span>
      }
    else if (n_params == 1 &amp;&amp; return_type == G_TYPE_NONE)
      {
  #define ADD_CHECK(__type__) \
        else if (g_type_is_a (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, G_TYPE_ ##__type__))         \
<span class="udiff-line-modified-removed">-     {                                                                \</span>
<span class="udiff-line-modified-removed">-       builtin_c_marshaller = g_cclosure_marshal_VOID__ ## __type__;  \</span>
<span class="udiff-line-modified-removed">-       builtin_va_marshaller = g_cclosure_marshal_VOID__ ## __type__ ##v;     \</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {                                                                \</span>
<span class="udiff-line-modified-added">+     builtin_c_marshaller = g_cclosure_marshal_VOID__ ## __type__;  \</span>
<span class="udiff-line-modified-added">+     builtin_va_marshaller = g_cclosure_marshal_VOID__ ## __type__ ##v;     \</span>
<span class="udiff-line-modified-added">+   }</span>
  
        if (0) {}
        ADD_CHECK (BOOLEAN)
        ADD_CHECK (CHAR)
        ADD_CHECK (UCHAR)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1796,14 +1802,14 @@</span>
          {
      c_marshaller = builtin_c_marshaller;
            va_marshaller = builtin_va_marshaller;
          }
        else
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       c_marshaller = g_cclosure_marshal_generic;</span>
<span class="udiff-line-modified-removed">-       va_marshaller = g_cclosure_marshal_generic_va;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     c_marshaller = g_cclosure_marshal_generic;</span>
<span class="udiff-line-modified-added">+     va_marshaller = g_cclosure_marshal_generic_va;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    else
      va_marshaller = NULL;
  
    node-&gt;c_marshaller = c_marshaller;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1832,12 +1838,12 @@</span>
   *
   * Since: 2.32
   */
  void
  g_signal_set_va_marshaller (guint              signal_id,
<span class="udiff-line-modified-removed">-                 GType              instance_type,</span>
<span class="udiff-line-modified-removed">-                 GSignalCVaMarshaller va_marshaller)</span>
<span class="udiff-line-modified-added">+           GType              instance_type,</span>
<span class="udiff-line-modified-added">+           GSignalCVaMarshaller va_marshaller)</span>
  {
    SignalNode *node;
  
    g_return_if_fail (signal_id &gt; 0);
    g_return_if_fail (va_marshaller != NULL);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1846,15 +1852,15 @@</span>
    node = LOOKUP_SIGNAL_NODE (signal_id);
    if (node)
      {
        node-&gt;va_marshaller = va_marshaller;
        if (node-&gt;class_closure_bsa)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       ClassClosure *cc = g_bsearch_array_get_nth (node-&gt;class_closure_bsa, &amp;g_class_closure_bconfig, 0);</span>
<span class="udiff-line-modified-removed">-       if (cc-&gt;closure-&gt;marshal == node-&gt;c_marshaller)</span>
<span class="udiff-line-modified-removed">-         _g_closure_set_va_marshal (cc-&gt;closure, va_marshaller);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     ClassClosure *cc = g_bsearch_array_get_nth (node-&gt;class_closure_bsa, &amp;g_class_closure_bconfig, 0);</span>
<span class="udiff-line-modified-added">+     if (cc-&gt;closure-&gt;marshal == node-&gt;c_marshaller)</span>
<span class="udiff-line-modified-added">+       _g_closure_set_va_marshal (cc-&gt;closure, va_marshaller);</span>
<span class="udiff-line-modified-added">+   }</span>
  
        node-&gt;single_va_closure_is_valid = FALSE;
      }
  
    SIGNAL_UNLOCK ();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1892,11 +1898,11 @@</span>
  g_signal_new_valist (const gchar       *signal_name,
                       GType              itype,
                       GSignalFlags       signal_flags,
                       GClosure          *class_closure,
                       GSignalAccumulator accumulator,
<span class="udiff-line-modified-removed">-              gpointer       accu_data,</span>
<span class="udiff-line-modified-added">+          gpointer   accu_data,</span>
                       GSignalCMarshaller c_marshaller,
                       GType              return_type,
                       guint              n_params,
                       va_list            args)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1907,18 +1913,18 @@</span>
    if (n_params &gt; 0)
      {
        param_types = g_new (GType, n_params);
  
        for (i = 0; i &lt; n_params; i++)
<span class="udiff-line-modified-removed">-     param_types[i] = va_arg (args, GType);</span>
<span class="udiff-line-modified-added">+   param_types[i] = va_arg (args, GType);</span>
      }
    else
      param_types = NULL;
  
    signal_id = g_signal_newv (signal_name, itype, signal_flags,
<span class="udiff-line-modified-removed">-                  class_closure, accumulator, accu_data, c_marshaller,</span>
<span class="udiff-line-modified-removed">-                  return_type, n_params, param_types);</span>
<span class="udiff-line-modified-added">+            class_closure, accumulator, accu_data, c_marshaller,</span>
<span class="udiff-line-modified-added">+            return_type, n_params, param_types);</span>
    g_free (param_types);
  
    return signal_id;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1959,15 +1965,15 @@</span>
    if (node.class_closure_bsa)
      {
        guint i;
  
        for (i = 0; i &lt; node.class_closure_bsa-&gt;n_nodes; i++)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       ClassClosure *cc = g_bsearch_array_get_nth (node.class_closure_bsa, &amp;g_class_closure_bconfig, i);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     ClassClosure *cc = g_bsearch_array_get_nth (node.class_closure_bsa, &amp;g_class_closure_bconfig, i);</span>
  
<span class="udiff-line-modified-removed">-       g_closure_unref (cc-&gt;closure);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     g_closure_unref (cc-&gt;closure);</span>
<span class="udiff-line-modified-added">+   }</span>
        g_bsearch_array_free (node.class_closure_bsa, &amp;g_class_closure_bconfig);
      }
    g_free (node.accumulator);
    if (node.emission_hooks)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1992,12 +1998,12 @@</span>
   * g_signal_chain_from_overridden_handler() for how to chain up to the
   * parent class closure from inside the overridden one.
   */
  void
  g_signal_override_class_closure (guint     signal_id,
<span class="udiff-line-modified-removed">-                  GType     instance_type,</span>
<span class="udiff-line-modified-removed">-                  GClosure *class_closure)</span>
<span class="udiff-line-modified-added">+          GType     instance_type,</span>
<span class="udiff-line-modified-added">+          GClosure *class_closure)</span>
  {
    SignalNode *node;
  
    g_return_if_fail (signal_id &gt; 0);
    g_return_if_fail (class_closure != NULL);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2014,13 +2020,13 @@</span>
    else
      {
        ClassClosure *cc = signal_find_class_closure (node, instance_type);
  
        if (cc &amp;&amp; cc-&gt;instance_type == instance_type)
<span class="udiff-line-modified-removed">-     g_warning (&quot;%s: type &#39;%s&#39; is already overridden for signal id &#39;%u&#39;&quot;, G_STRLOC, type_debug_name (instance_type), signal_id);</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;%s: type &#39;%s&#39; is already overridden for signal id &#39;%u&#39;&quot;, G_STRLOC, type_debug_name (instance_type), signal_id);</span>
        else
<span class="udiff-line-modified-removed">-     signal_add_class_closure (node, instance_type, class_closure);</span>
<span class="udiff-line-modified-added">+   signal_add_class_closure (node, instance_type, class_closure);</span>
      }
    SIGNAL_UNLOCK ();
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2041,12 +2047,12 @@</span>
   *
   * Since: 2.18
   */
  void
  g_signal_override_class_handler (const gchar *signal_name,
<span class="udiff-line-modified-removed">-                  GType        instance_type,</span>
<span class="udiff-line-modified-removed">-                  GCallback    class_handler)</span>
<span class="udiff-line-modified-added">+          GType        instance_type,</span>
<span class="udiff-line-modified-added">+          GCallback    class_handler)</span>
  {
    guint signal_id;
  
    g_return_if_fail (signal_name != NULL);
    g_return_if_fail (instance_type != G_TYPE_NONE);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2075,11 +2081,11 @@</span>
   * g_signal_override_class_closure() and
   * g_signal_override_class_handler().
   */
  void
  g_signal_chain_from_overridden (const GValue *instance_and_params,
<span class="udiff-line-modified-removed">-                 GValue       *return_value)</span>
<span class="udiff-line-modified-added">+         GValue       *return_value)</span>
  {
    GType chain_type = 0, restore_type = 0;
    Emission *emission = NULL;
    GClosure *closure = NULL;
    guint n_params = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2098,39 +2104,39 @@</span>
        g_assert (node != NULL);  /* paranoid */
  
        /* we should probably do the same parameter checks as g_signal_emit() here.
         */
        if (emission-&gt;chain_type != G_TYPE_NONE)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       ClassClosure *cc = signal_find_class_closure (node, emission-&gt;chain_type);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     ClassClosure *cc = signal_find_class_closure (node, emission-&gt;chain_type);</span>
  
<span class="udiff-line-modified-removed">-       g_assert (cc != NULL);    /* closure currently in call stack */</span>
<span class="udiff-line-modified-added">+     g_assert (cc != NULL);  /* closure currently in call stack */</span>
  
<span class="udiff-line-modified-removed">-       n_params = node-&gt;n_params;</span>
<span class="udiff-line-modified-removed">-       restore_type = cc-&gt;instance_type;</span>
<span class="udiff-line-modified-removed">-       cc = signal_find_class_closure (node, g_type_parent (cc-&gt;instance_type));</span>
<span class="udiff-line-modified-removed">-       if (cc &amp;&amp; cc-&gt;instance_type != restore_type)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           closure = cc-&gt;closure;</span>
<span class="udiff-line-modified-removed">-           chain_type = cc-&gt;instance_type;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     n_params = node-&gt;n_params;</span>
<span class="udiff-line-modified-added">+     restore_type = cc-&gt;instance_type;</span>
<span class="udiff-line-modified-added">+     cc = signal_find_class_closure (node, g_type_parent (cc-&gt;instance_type));</span>
<span class="udiff-line-modified-added">+     if (cc &amp;&amp; cc-&gt;instance_type != restore_type)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         closure = cc-&gt;closure;</span>
<span class="udiff-line-modified-added">+         chain_type = cc-&gt;instance_type;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+   }</span>
        else
<span class="udiff-line-modified-removed">-     g_warning (&quot;%s: signal id &#39;%u&#39; cannot be chained from current emission stage for instance &#39;%p&#39;&quot;, G_STRLOC, node-&gt;signal_id, instance);</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;%s: signal id &#39;%u&#39; cannot be chained from current emission stage for instance &#39;%p&#39;&quot;, G_STRLOC, node-&gt;signal_id, instance);</span>
      }
    else
      g_warning (&quot;%s: no signal is currently being emitted for instance &#39;%p&#39;&quot;, G_STRLOC, instance);
  
    if (closure)
      {
        emission-&gt;chain_type = chain_type;
        SIGNAL_UNLOCK ();
        g_closure_invoke (closure,
<span class="udiff-line-modified-removed">-             return_value,</span>
<span class="udiff-line-modified-removed">-             n_params + 1,</span>
<span class="udiff-line-modified-removed">-             instance_and_params,</span>
<span class="udiff-line-modified-removed">-             &amp;emission-&gt;ihint);</span>
<span class="udiff-line-modified-added">+       return_value,</span>
<span class="udiff-line-modified-added">+       n_params + 1,</span>
<span class="udiff-line-modified-added">+       instance_and_params,</span>
<span class="udiff-line-modified-added">+       &amp;emission-&gt;ihint);</span>
        SIGNAL_LOCK ();
        emission-&gt;chain_type = restore_type;
      }
    SIGNAL_UNLOCK ();
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2171,26 +2177,26 @@</span>
        g_assert (node != NULL);  /* paranoid */
  
        /* we should probably do the same parameter checks as g_signal_emit() here.
         */
        if (emission-&gt;chain_type != G_TYPE_NONE)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       ClassClosure *cc = signal_find_class_closure (node, emission-&gt;chain_type);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     ClassClosure *cc = signal_find_class_closure (node, emission-&gt;chain_type);</span>
  
<span class="udiff-line-modified-removed">-       g_assert (cc != NULL);    /* closure currently in call stack */</span>
<span class="udiff-line-modified-added">+     g_assert (cc != NULL);  /* closure currently in call stack */</span>
  
<span class="udiff-line-modified-removed">-       n_params = node-&gt;n_params;</span>
<span class="udiff-line-modified-removed">-       restore_type = cc-&gt;instance_type;</span>
<span class="udiff-line-modified-removed">-       cc = signal_find_class_closure (node, g_type_parent (cc-&gt;instance_type));</span>
<span class="udiff-line-modified-removed">-       if (cc &amp;&amp; cc-&gt;instance_type != restore_type)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           closure = cc-&gt;closure;</span>
<span class="udiff-line-modified-removed">-           chain_type = cc-&gt;instance_type;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     n_params = node-&gt;n_params;</span>
<span class="udiff-line-modified-added">+     restore_type = cc-&gt;instance_type;</span>
<span class="udiff-line-modified-added">+     cc = signal_find_class_closure (node, g_type_parent (cc-&gt;instance_type));</span>
<span class="udiff-line-modified-added">+     if (cc &amp;&amp; cc-&gt;instance_type != restore_type)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         closure = cc-&gt;closure;</span>
<span class="udiff-line-modified-added">+         chain_type = cc-&gt;instance_type;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+   }</span>
        else
<span class="udiff-line-modified-removed">-     g_warning (&quot;%s: signal id &#39;%u&#39; cannot be chained from current emission stage for instance &#39;%p&#39;&quot;, G_STRLOC, node-&gt;signal_id, instance);</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;%s: signal id &#39;%u&#39; cannot be chained from current emission stage for instance &#39;%p&#39;&quot;, G_STRLOC, node-&gt;signal_id, instance);</span>
      }
    else
      g_warning (&quot;%s: no signal is currently being emitted for instance &#39;%p&#39;&quot;, G_STRLOC, instance);
  
    if (closure)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2214,13 +2220,13 @@</span>
            GType ptype = node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
            gboolean static_scope = node-&gt;param_types[i] &amp; G_SIGNAL_TYPE_STATIC_SCOPE;
  
            SIGNAL_UNLOCK ();
            G_VALUE_COLLECT_INIT (param_values + i, ptype,
<span class="udiff-line-modified-removed">-                 var_args,</span>
<span class="udiff-line-modified-removed">-                 static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="udiff-line-modified-removed">-                 &amp;error);</span>
<span class="udiff-line-modified-added">+         var_args,</span>
<span class="udiff-line-modified-added">+         static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="udiff-line-modified-added">+         &amp;error);</span>
            if (error)
              {
                g_warning (&quot;%s: %s&quot;, G_STRLOC, error);
                g_free (error);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2333,14 +2339,14 @@</span>
   *
   * Returns: the handler ID (always greater than 0 for successful connections)
   */
  gulong
  g_signal_connect_closure_by_id (gpointer  instance,
<span class="udiff-line-modified-removed">-                 guint     signal_id,</span>
<span class="udiff-line-modified-removed">-                 GQuark    detail,</span>
<span class="udiff-line-modified-removed">-                 GClosure *closure,</span>
<span class="udiff-line-modified-removed">-                 gboolean  after)</span>
<span class="udiff-line-modified-added">+         guint     signal_id,</span>
<span class="udiff-line-modified-added">+         GQuark    detail,</span>
<span class="udiff-line-modified-added">+         GClosure *closure,</span>
<span class="udiff-line-modified-added">+         gboolean  after)</span>
  {
    SignalNode *node;
    gulong handler_seq_no = 0;
  
    g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2350,30 +2356,30 @@</span>
    SIGNAL_LOCK ();
    node = LOOKUP_SIGNAL_NODE (signal_id);
    if (node)
      {
        if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
<span class="udiff-line-modified-removed">-     g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);</span>
        else if (!g_type_is_a (G_TYPE_FROM_INSTANCE (instance), node-&gt;itype))
<span class="udiff-line-modified-removed">-     g_warning (&quot;%s: signal id &#39;%u&#39; is invalid for instance &#39;%p&#39;&quot;, G_STRLOC, signal_id, instance);</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;%s: signal id &#39;%u&#39; is invalid for instance &#39;%p&#39;&quot;, G_STRLOC, signal_id, instance);</span>
        else
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       Handler *handler = handler_new (signal_id, instance, after);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       handler_seq_no = handler-&gt;sequential_number;</span>
<span class="udiff-line-modified-removed">-       handler-&gt;detail = detail;</span>
<span class="udiff-line-modified-removed">-       handler-&gt;closure = g_closure_ref (closure);</span>
<span class="udiff-line-modified-removed">-       g_closure_sink (closure);</span>
<span class="udiff-line-modified-removed">-       add_invalid_closure_notify (handler, instance);</span>
<span class="udiff-line-modified-removed">-       handler_insert (signal_id, instance, handler);</span>
<span class="udiff-line-modified-removed">-       if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (closure))</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           g_closure_set_marshal (closure, node-&gt;c_marshaller);</span>
<span class="udiff-line-modified-removed">-           if (node-&gt;va_marshaller)</span>
<span class="udiff-line-modified-removed">-         _g_closure_set_va_marshal (closure, node-&gt;va_marshaller);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     Handler *handler = handler_new (signal_id, instance, after);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     handler_seq_no = handler-&gt;sequential_number;</span>
<span class="udiff-line-modified-added">+     handler-&gt;detail = detail;</span>
<span class="udiff-line-modified-added">+     handler-&gt;closure = g_closure_ref (closure);</span>
<span class="udiff-line-modified-added">+     g_closure_sink (closure);</span>
<span class="udiff-line-modified-added">+     add_invalid_closure_notify (handler, instance);</span>
<span class="udiff-line-modified-added">+     handler_insert (signal_id, instance, handler);</span>
<span class="udiff-line-modified-added">+     if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (closure))</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         g_closure_set_marshal (closure, node-&gt;c_marshaller);</span>
<span class="udiff-line-modified-added">+         if (node-&gt;va_marshaller)</span>
<span class="udiff-line-modified-added">+     _g_closure_set_va_marshal (closure, node-&gt;va_marshaller);</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    else
      g_warning (&quot;%s: signal id &#39;%u&#39; is invalid for instance &#39;%p&#39;&quot;, G_STRLOC, signal_id, instance);
    SIGNAL_UNLOCK ();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2392,13 +2398,13 @@</span>
   *
   * Returns: the handler ID (always greater than 0 for successful connections)
   */
  gulong
  g_signal_connect_closure (gpointer     instance,
<span class="udiff-line-modified-removed">-               const gchar *detailed_signal,</span>
<span class="udiff-line-modified-removed">-               GClosure    *closure,</span>
<span class="udiff-line-modified-removed">-               gboolean     after)</span>
<span class="udiff-line-modified-added">+         const gchar *detailed_signal,</span>
<span class="udiff-line-modified-added">+         GClosure    *closure,</span>
<span class="udiff-line-modified-added">+         gboolean     after)</span>
  {
    guint signal_id;
    gulong handler_seq_no = 0;
    GQuark detail = 0;
    GType itype;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2413,31 +2419,31 @@</span>
    if (signal_id)
      {
        SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
  
        if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
<span class="udiff-line-modified-removed">-     g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);</span>
        else if (!g_type_is_a (itype, node-&gt;itype))
          g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                     G_STRLOC, detailed_signal, instance, g_type_name (itype));
        else
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       Handler *handler = handler_new (signal_id, instance, after);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       handler_seq_no = handler-&gt;sequential_number;</span>
<span class="udiff-line-modified-removed">-       handler-&gt;detail = detail;</span>
<span class="udiff-line-modified-removed">-       handler-&gt;closure = g_closure_ref (closure);</span>
<span class="udiff-line-modified-removed">-       g_closure_sink (closure);</span>
<span class="udiff-line-modified-removed">-       add_invalid_closure_notify (handler, instance);</span>
<span class="udiff-line-modified-removed">-       handler_insert (signal_id, instance, handler);</span>
<span class="udiff-line-modified-removed">-       if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (handler-&gt;closure))</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           g_closure_set_marshal (handler-&gt;closure, node-&gt;c_marshaller);</span>
<span class="udiff-line-modified-removed">-           if (node-&gt;va_marshaller)</span>
<span class="udiff-line-modified-removed">-         _g_closure_set_va_marshal (handler-&gt;closure, node-&gt;va_marshaller);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     Handler *handler = handler_new (signal_id, instance, after);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     handler_seq_no = handler-&gt;sequential_number;</span>
<span class="udiff-line-modified-added">+     handler-&gt;detail = detail;</span>
<span class="udiff-line-modified-added">+     handler-&gt;closure = g_closure_ref (closure);</span>
<span class="udiff-line-modified-added">+     g_closure_sink (closure);</span>
<span class="udiff-line-modified-added">+     add_invalid_closure_notify (handler, instance);</span>
<span class="udiff-line-modified-added">+     handler_insert (signal_id, instance, handler);</span>
<span class="udiff-line-modified-added">+     if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (handler-&gt;closure))</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         g_closure_set_marshal (handler-&gt;closure, node-&gt;c_marshaller);</span>
<span class="udiff-line-modified-added">+         if (node-&gt;va_marshaller)</span>
<span class="udiff-line-modified-added">+     _g_closure_set_va_marshal (handler-&gt;closure, node-&gt;va_marshaller);</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    else
      g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                 G_STRLOC, detailed_signal, instance, g_type_name (itype));
    SIGNAL_UNLOCK ();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2485,15 +2491,15 @@</span>
   *
   * Returns: the handler ID (always greater than 0 for successful connections)
   */
  gulong
  g_signal_connect_data (gpointer       instance,
<span class="udiff-line-modified-removed">-                const gchar   *detailed_signal,</span>
<span class="udiff-line-modified-removed">-                GCallback      c_handler,</span>
<span class="udiff-line-modified-removed">-                gpointer       data,</span>
<span class="udiff-line-modified-removed">-                GClosureNotify destroy_data,</span>
<span class="udiff-line-modified-removed">-                GConnectFlags  connect_flags)</span>
<span class="udiff-line-modified-added">+            const gchar   *detailed_signal,</span>
<span class="udiff-line-modified-added">+            GCallback      c_handler,</span>
<span class="udiff-line-modified-added">+            gpointer       data,</span>
<span class="udiff-line-modified-added">+            GClosureNotify destroy_data,</span>
<span class="udiff-line-modified-added">+            GConnectFlags  connect_flags)</span>
  {
    guint signal_id;
    gulong handler_seq_no = 0;
    GQuark detail = 0;
    GType itype;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2514,29 +2520,29 @@</span>
        SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
  
        node_check_deprecated (node);
  
        if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
<span class="udiff-line-modified-removed">-     g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);</span>
        else if (!g_type_is_a (itype, node-&gt;itype))
          g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                     G_STRLOC, detailed_signal, instance, g_type_name (itype));
        else
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       Handler *handler = handler_new (signal_id, instance, after);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       handler_seq_no = handler-&gt;sequential_number;</span>
<span class="udiff-line-modified-removed">-       handler-&gt;detail = detail;</span>
<span class="udiff-line-modified-removed">-       handler-&gt;closure = g_closure_ref ((swapped ? g_cclosure_new_swap : g_cclosure_new) (c_handler, data, destroy_data));</span>
<span class="udiff-line-modified-removed">-       g_closure_sink (handler-&gt;closure);</span>
<span class="udiff-line-modified-removed">-       handler_insert (signal_id, instance, handler);</span>
<span class="udiff-line-modified-removed">-       if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (handler-&gt;closure))</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           g_closure_set_marshal (handler-&gt;closure, node-&gt;c_marshaller);</span>
<span class="udiff-line-modified-removed">-           if (node-&gt;va_marshaller)</span>
<span class="udiff-line-modified-removed">-         _g_closure_set_va_marshal (handler-&gt;closure, node-&gt;va_marshaller);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     Handler *handler = handler_new (signal_id, instance, after);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     handler_seq_no = handler-&gt;sequential_number;</span>
<span class="udiff-line-modified-added">+     handler-&gt;detail = detail;</span>
<span class="udiff-line-modified-added">+     handler-&gt;closure = g_closure_ref ((swapped ? g_cclosure_new_swap : g_cclosure_new) (c_handler, data, destroy_data));</span>
<span class="udiff-line-modified-added">+     g_closure_sink (handler-&gt;closure);</span>
<span class="udiff-line-modified-added">+     handler_insert (signal_id, instance, handler);</span>
<span class="udiff-line-modified-added">+     if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (handler-&gt;closure))</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         g_closure_set_marshal (handler-&gt;closure, node-&gt;c_marshaller);</span>
<span class="udiff-line-modified-added">+         if (node-&gt;va_marshaller)</span>
<span class="udiff-line-modified-added">+     _g_closure_set_va_marshal (handler-&gt;closure, node-&gt;va_marshaller);</span>
<span class="udiff-line-modified-added">+       }</span>
          }
      }
    else
      g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                 G_STRLOC, detailed_signal, instance, g_type_name (itype));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2670,11 +2676,11 @@</span>
   *
   * Returns: whether @handler_id identifies a handler connected to @instance.
   */
  gboolean
  g_signal_handler_is_connected (gpointer instance,
<span class="udiff-line-modified-removed">-                    gulong   handler_id)</span>
<span class="udiff-line-modified-added">+              gulong   handler_id)</span>
  {
    Handler *handler;
    gboolean connected;
  
    g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), FALSE);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2724,16 +2730,16 @@</span>
                tmp-&gt;block_count = 1;
                /* cruel unlink, this works because _all_ handlers vanish */
                tmp-&gt;next = NULL;
                tmp-&gt;prev = tmp;
                if (tmp-&gt;sequential_number)
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-added">+     {</span>
                    g_hash_table_remove (g_handlers, tmp);
<span class="udiff-line-modified-removed">-           remove_invalid_closure_notify (tmp, instance);</span>
<span class="udiff-line-modified-removed">-           tmp-&gt;sequential_number = 0;</span>
<span class="udiff-line-modified-removed">-           handler_unref_R (0, NULL, tmp);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+       remove_invalid_closure_notify (tmp, instance);</span>
<span class="udiff-line-modified-added">+       tmp-&gt;sequential_number = 0;</span>
<span class="udiff-line-modified-added">+       handler_unref_R (0, NULL, tmp);</span>
<span class="udiff-line-modified-added">+     }</span>
              }
          }
        g_bsearch_array_free (hlbsa, &amp;g_signal_hlbsa_bconfig);
      }
    SIGNAL_UNLOCK ();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2760,11 +2766,11 @@</span>
   */
  gulong
  g_signal_handler_find (gpointer         instance,
                         GSignalMatchType mask,
                         guint            signal_id,
<span class="udiff-line-modified-removed">-                GQuark       detail,</span>
<span class="udiff-line-modified-added">+            GQuark   detail,</span>
                         GClosure        *closure,
                         gpointer         func,
                         gpointer         data)
  {
    gulong handler_seq_no = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2777,44 +2783,44 @@</span>
        HandlerMatch *mlist;
  
        SIGNAL_LOCK ();
        mlist = handlers_find (instance, mask, signal_id, detail, closure, func, data, TRUE);
        if (mlist)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       handler_seq_no = mlist-&gt;handler-&gt;sequential_number;</span>
<span class="udiff-line-modified-removed">-       handler_match_free1_R (mlist, instance);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     handler_seq_no = mlist-&gt;handler-&gt;sequential_number;</span>
<span class="udiff-line-modified-added">+     handler_match_free1_R (mlist, instance);</span>
<span class="udiff-line-modified-added">+   }</span>
        SIGNAL_UNLOCK ();
      }
  
    return handler_seq_no;
  }
  
  static guint
  signal_handlers_foreach_matched_R (gpointer         instance,
<span class="udiff-line-modified-removed">-                                    GSignalMatchType mask,</span>
<span class="udiff-line-modified-removed">-                                    guint            signal_id,</span>
<span class="udiff-line-modified-removed">-                                    GQuark           detail,</span>
<span class="udiff-line-modified-removed">-                                    GClosure        *closure,</span>
<span class="udiff-line-modified-removed">-                                    gpointer         func,</span>
<span class="udiff-line-modified-removed">-                                    gpointer         data,</span>
<span class="udiff-line-modified-removed">-                    void       (*callback) (gpointer instance,</span>
<span class="udiff-line-modified-removed">-                                    gulong   handler_seq_no))</span>
<span class="udiff-line-modified-added">+            GSignalMatchType mask,</span>
<span class="udiff-line-modified-added">+            guint            signal_id,</span>
<span class="udiff-line-modified-added">+            GQuark           detail,</span>
<span class="udiff-line-modified-added">+            GClosure        *closure,</span>
<span class="udiff-line-modified-added">+            gpointer         func,</span>
<span class="udiff-line-modified-added">+            gpointer         data,</span>
<span class="udiff-line-modified-added">+            void     (*callback) (gpointer instance,</span>
<span class="udiff-line-modified-added">+                      gulong   handler_seq_no))</span>
  {
    HandlerMatch *mlist;
    guint n_handlers = 0;
  
    mlist = handlers_find (instance, mask, signal_id, detail, closure, func, data, FALSE);
    while (mlist)
      {
        n_handlers++;
        if (mlist-&gt;handler-&gt;sequential_number)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-removed">-       callback (instance, mlist-&gt;handler-&gt;sequential_number);</span>
<span class="udiff-line-modified-removed">-       SIGNAL_LOCK ();</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-added">+     callback (instance, mlist-&gt;handler-&gt;sequential_number);</span>
<span class="udiff-line-modified-added">+     SIGNAL_LOCK ();</span>
<span class="udiff-line-modified-added">+   }</span>
        mlist = handler_match_free1_R (mlist, instance);
      }
  
    return n_handlers;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2840,28 +2846,28 @@</span>
   *
   * Returns: The number of handlers that matched.
   */
  guint
  g_signal_handlers_block_matched (gpointer         instance,
<span class="udiff-line-modified-removed">-                  GSignalMatchType mask,</span>
<span class="udiff-line-modified-removed">-                  guint            signal_id,</span>
<span class="udiff-line-modified-removed">-                  GQuark           detail,</span>
<span class="udiff-line-modified-removed">-                  GClosure        *closure,</span>
<span class="udiff-line-modified-removed">-                  gpointer         func,</span>
<span class="udiff-line-modified-removed">-                  gpointer         data)</span>
<span class="udiff-line-modified-added">+          GSignalMatchType mask,</span>
<span class="udiff-line-modified-added">+          guint            signal_id,</span>
<span class="udiff-line-modified-added">+          GQuark           detail,</span>
<span class="udiff-line-modified-added">+          GClosure        *closure,</span>
<span class="udiff-line-modified-added">+          gpointer         func,</span>
<span class="udiff-line-modified-added">+          gpointer         data)</span>
  {
    guint n_handlers = 0;
  
    g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
    g_return_val_if_fail ((mask &amp; ~G_SIGNAL_MATCH_MASK) == 0, 0);
  
    if (mask &amp; (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
      {
        SIGNAL_LOCK ();
        n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
<span class="udiff-line-modified-removed">-                               closure, func, data,</span>
<span class="udiff-line-modified-removed">-                               g_signal_handler_block);</span>
<span class="udiff-line-modified-added">+                   closure, func, data,</span>
<span class="udiff-line-modified-added">+                   g_signal_handler_block);</span>
        SIGNAL_UNLOCK ();
      }
  
    return n_handlers;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2888,28 +2894,28 @@</span>
   *
   * Returns: The number of handlers that matched.
   */
  guint
  g_signal_handlers_unblock_matched (gpointer         instance,
<span class="udiff-line-modified-removed">-                    GSignalMatchType mask,</span>
<span class="udiff-line-modified-removed">-                    guint            signal_id,</span>
<span class="udiff-line-modified-removed">-                    GQuark           detail,</span>
<span class="udiff-line-modified-removed">-                    GClosure        *closure,</span>
<span class="udiff-line-modified-removed">-                    gpointer         func,</span>
<span class="udiff-line-modified-removed">-                    gpointer         data)</span>
<span class="udiff-line-modified-added">+            GSignalMatchType mask,</span>
<span class="udiff-line-modified-added">+            guint            signal_id,</span>
<span class="udiff-line-modified-added">+            GQuark           detail,</span>
<span class="udiff-line-modified-added">+            GClosure        *closure,</span>
<span class="udiff-line-modified-added">+            gpointer         func,</span>
<span class="udiff-line-modified-added">+            gpointer         data)</span>
  {
    guint n_handlers = 0;
  
    g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
    g_return_val_if_fail ((mask &amp; ~G_SIGNAL_MATCH_MASK) == 0, 0);
  
    if (mask &amp; (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
      {
        SIGNAL_LOCK ();
        n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
<span class="udiff-line-modified-removed">-                               closure, func, data,</span>
<span class="udiff-line-modified-removed">-                               g_signal_handler_unblock);</span>
<span class="udiff-line-modified-added">+                   closure, func, data,</span>
<span class="udiff-line-modified-added">+                   g_signal_handler_unblock);</span>
        SIGNAL_UNLOCK ();
      }
  
    return n_handlers;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2936,28 +2942,28 @@</span>
   *
   * Returns: The number of handlers that matched.
   */
  guint
  g_signal_handlers_disconnect_matched (gpointer         instance,
<span class="udiff-line-modified-removed">-                       GSignalMatchType mask,</span>
<span class="udiff-line-modified-removed">-                       guint            signal_id,</span>
<span class="udiff-line-modified-removed">-                       GQuark           detail,</span>
<span class="udiff-line-modified-removed">-                       GClosure        *closure,</span>
<span class="udiff-line-modified-removed">-                       gpointer         func,</span>
<span class="udiff-line-modified-removed">-                       gpointer         data)</span>
<span class="udiff-line-modified-added">+               GSignalMatchType mask,</span>
<span class="udiff-line-modified-added">+               guint            signal_id,</span>
<span class="udiff-line-modified-added">+               GQuark           detail,</span>
<span class="udiff-line-modified-added">+               GClosure        *closure,</span>
<span class="udiff-line-modified-added">+               gpointer         func,</span>
<span class="udiff-line-modified-added">+               gpointer         data)</span>
  {
    guint n_handlers = 0;
  
    g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
    g_return_val_if_fail ((mask &amp; ~G_SIGNAL_MATCH_MASK) == 0, 0);
  
    if (mask &amp; (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
      {
        SIGNAL_LOCK ();
        n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
<span class="udiff-line-modified-removed">-                               closure, func, data,</span>
<span class="udiff-line-modified-removed">-                               g_signal_handler_disconnect);</span>
<span class="udiff-line-modified-added">+                   closure, func, data,</span>
<span class="udiff-line-modified-added">+                   g_signal_handler_disconnect);</span>
        SIGNAL_UNLOCK ();
      }
  
    return n_handlers;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2989,13 +2995,13 @@</span>
   * Returns: %TRUE if a handler is connected to the signal, %FALSE
   *          otherwise.
   */
  gboolean
  g_signal_has_handler_pending (gpointer instance,
<span class="udiff-line-modified-removed">-                   guint    signal_id,</span>
<span class="udiff-line-modified-removed">-                   GQuark   detail,</span>
<span class="udiff-line-modified-removed">-                   gboolean may_be_blocked)</span>
<span class="udiff-line-modified-added">+             guint    signal_id,</span>
<span class="udiff-line-modified-added">+             GQuark   detail,</span>
<span class="udiff-line-modified-added">+             gboolean may_be_blocked)</span>
  {
    HandlerMatch *mlist;
    gboolean has_pending;
    SignalNode *node;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3010,19 +3016,19 @@</span>
  #ifndef GSTREAMER_LITE
        if (!(node-&gt;flags &amp; G_SIGNAL_DETAILED))
  #else // GSTREAMER_LITE
        if (node == NULL || !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
  #endif // GSTREAMER_LITE
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);</span>
<span class="udiff-line-modified-removed">-       SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-removed">-       return FALSE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);</span>
<span class="udiff-line-modified-added">+     SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-added">+     return FALSE;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    mlist = handlers_find (instance,
<span class="udiff-line-modified-removed">-              (G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | (may_be_blocked ? 0 : G_SIGNAL_MATCH_UNBLOCKED)),</span>
<span class="udiff-line-modified-removed">-              signal_id, detail, NULL, NULL, NULL, TRUE);</span>
<span class="udiff-line-modified-added">+        (G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | (may_be_blocked ? 0 : G_SIGNAL_MATCH_UNBLOCKED)),</span>
<span class="udiff-line-modified-added">+        signal_id, detail, NULL, NULL, NULL, TRUE);</span>
    if (mlist)
      {
        has_pending = TRUE;
        handler_match_free1_R (mlist, instance);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3030,11 +3036,11 @@</span>
      {
        ClassClosure *class_closure = signal_find_class_closure (node, G_TYPE_FROM_INSTANCE (instance));
        if (class_closure != NULL &amp;&amp; class_closure-&gt;instance_type != 0)
          has_pending = TRUE;
        else
<span class="udiff-line-modified-removed">-     has_pending = FALSE;</span>
<span class="udiff-line-modified-added">+         has_pending = FALSE;</span>
      }
    SIGNAL_UNLOCK ();
  
    return has_pending;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3055,13 +3061,13 @@</span>
   * Note that g_signal_emitv() doesn&#39;t change @return_value if no handlers are
   * connected, in contrast to g_signal_emit() and g_signal_emit_valist().
   */
  void
  g_signal_emitv (const GValue *instance_and_params,
<span class="udiff-line-modified-removed">-                 guint         signal_id,</span>
<span class="udiff-line-modified-removed">-         GQuark        detail,</span>
<span class="udiff-line-modified-removed">-                 GValue       *return_value)</span>
<span class="udiff-line-modified-added">+     guint         signal_id,</span>
<span class="udiff-line-modified-added">+     GQuark        detail,</span>
<span class="udiff-line-modified-added">+     GValue       *return_value)</span>
  {
    gpointer instance;
    SignalNode *node;
  #ifdef G_ENABLE_DEBUG
    const GValue *param_values;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3093,40 +3099,40 @@</span>
        return;
      }
    for (i = 0; i &lt; node-&gt;n_params; i++)
      if (!G_TYPE_CHECK_VALUE_TYPE (param_values + i, node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
        {
<span class="udiff-line-modified-removed">-     g_critical (&quot;%s: value for &#39;%s&#39; parameter %u for signal \&quot;%s\&quot; is of type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-             G_STRLOC,</span>
<span class="udiff-line-modified-removed">-             type_debug_name (node-&gt;param_types[i]),</span>
<span class="udiff-line-modified-removed">-             i,</span>
<span class="udiff-line-modified-removed">-             node-&gt;name,</span>
<span class="udiff-line-modified-removed">-             G_VALUE_TYPE_NAME (param_values + i));</span>
<span class="udiff-line-modified-removed">-     SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-modified-added">+   g_critical (&quot;%s: value for &#39;%s&#39; parameter %u for signal \&quot;%s\&quot; is of type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+         G_STRLOC,</span>
<span class="udiff-line-modified-added">+         type_debug_name (node-&gt;param_types[i]),</span>
<span class="udiff-line-modified-added">+         i,</span>
<span class="udiff-line-modified-added">+         node-&gt;name,</span>
<span class="udiff-line-modified-added">+         G_VALUE_TYPE_NAME (param_values + i));</span>
<span class="udiff-line-modified-added">+   SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-added">+   return;</span>
        }
    if (node-&gt;return_type != G_TYPE_NONE)
      {
        if (!return_value)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_critical (&quot;%s: return value &#39;%s&#39; for signal \&quot;%s\&quot; is (NULL)&quot;,</span>
<span class="udiff-line-modified-removed">-               G_STRLOC,</span>
<span class="udiff-line-modified-removed">-               type_debug_name (node-&gt;return_type),</span>
<span class="udiff-line-modified-removed">-               node-&gt;name);</span>
<span class="udiff-line-modified-removed">-       SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-removed">-       return;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_critical (&quot;%s: return value &#39;%s&#39; for signal \&quot;%s\&quot; is (NULL)&quot;,</span>
<span class="udiff-line-modified-added">+           G_STRLOC,</span>
<span class="udiff-line-modified-added">+           type_debug_name (node-&gt;return_type),</span>
<span class="udiff-line-modified-added">+           node-&gt;name);</span>
<span class="udiff-line-modified-added">+     SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   }</span>
        else if (!node-&gt;accumulator &amp;&amp; !G_TYPE_CHECK_VALUE_TYPE (return_value, node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_critical (&quot;%s: return value &#39;%s&#39; for signal \&quot;%s\&quot; is of type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-               G_STRLOC,</span>
<span class="udiff-line-modified-removed">-               type_debug_name (node-&gt;return_type),</span>
<span class="udiff-line-modified-removed">-               node-&gt;name,</span>
<span class="udiff-line-modified-removed">-               G_VALUE_TYPE_NAME (return_value));</span>
<span class="udiff-line-modified-removed">-       SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-removed">-       return;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_critical (&quot;%s: return value &#39;%s&#39; for signal \&quot;%s\&quot; is of type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+           G_STRLOC,</span>
<span class="udiff-line-modified-added">+           type_debug_name (node-&gt;return_type),</span>
<span class="udiff-line-modified-added">+           node-&gt;name,</span>
<span class="udiff-line-modified-added">+           G_VALUE_TYPE_NAME (return_value));</span>
<span class="udiff-line-modified-added">+     SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    else
      return_value = NULL;
  #endif  /* G_ENABLE_DEBUG */
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3138,27 +3144,27 @@</span>
        (node-&gt;single_va_closure == SINGLE_VA_CLOSURE_EMPTY_MAGIC ||
         _g_closure_is_void (node-&gt;single_va_closure, instance)))
      {
        HandlerList* hlist = handler_list_lookup (node-&gt;signal_id, instance);
        if (hlist == NULL || hlist-&gt;handlers == NULL)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       /* nothing to do to emit this signal */</span>
<span class="udiff-line-modified-removed">-       SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-removed">-       /* g_printerr (&quot;omitting emission of \&quot;%s\&quot;\n&quot;, node-&gt;name); */</span>
<span class="udiff-line-modified-removed">-       return;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     /* nothing to do to emit this signal */</span>
<span class="udiff-line-modified-added">+     SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-added">+     /* g_printerr (&quot;omitting emission of \&quot;%s\&quot;\n&quot;, node-&gt;name); */</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
  
    SIGNAL_UNLOCK ();
    signal_emit_unlocked_R (node, detail, instance, return_value, instance_and_params);
  }
  
  static inline gboolean
  accumulate (GSignalInvocationHint *ihint,
<span class="udiff-line-modified-removed">-             GValue                *return_accu,</span>
<span class="udiff-line-modified-removed">-         GValue            *handler_return,</span>
<span class="udiff-line-modified-removed">-             SignalAccumulator     *accumulator)</span>
<span class="udiff-line-modified-added">+       GValue                *return_accu,</span>
<span class="udiff-line-modified-added">+       GValue            *handler_return,</span>
<span class="udiff-line-modified-added">+       SignalAccumulator     *accumulator)</span>
  {
    gboolean continue_emission;
  
    if (!accumulator)
      return TRUE;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3184,13 +3190,13 @@</span>
   * Note that g_signal_emit_valist() resets the return value to the default
   * if no handlers are connected, in contrast to g_signal_emitv().
   */
  void
  g_signal_emit_valist (gpointer instance,
<span class="udiff-line-modified-removed">-               guint    signal_id,</span>
<span class="udiff-line-modified-removed">-               GQuark   detail,</span>
<span class="udiff-line-modified-removed">-               va_list  var_args)</span>
<span class="udiff-line-modified-added">+           guint    signal_id,</span>
<span class="udiff-line-modified-added">+           GQuark   detail,</span>
<span class="udiff-line-modified-added">+           va_list  var_args)</span>
  {
    GValue *instance_and_params;
    GType signal_return_type;
    GValue *param_values;
    SignalNode *node;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3227,155 +3233,155 @@</span>
        GClosure *closure = NULL;
        gboolean fastpath = TRUE;
        GSignalFlags run_type = G_SIGNAL_RUN_FIRST;
  
        if (node-&gt;single_va_closure != SINGLE_VA_CLOSURE_EMPTY_MAGIC &amp;&amp;
<span class="udiff-line-modified-removed">-       !_g_closure_is_void (node-&gt;single_va_closure, instance))</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       if (_g_closure_supports_invoke_va (node-&gt;single_va_closure))</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           closure = node-&gt;single_va_closure;</span>
<span class="udiff-line-modified-removed">-           if (node-&gt;single_va_closure_is_after)</span>
<span class="udiff-line-modified-removed">-         run_type = G_SIGNAL_RUN_LAST;</span>
<span class="udiff-line-modified-removed">-           else</span>
<span class="udiff-line-modified-removed">-         run_type = G_SIGNAL_RUN_FIRST;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-       else</span>
<span class="udiff-line-modified-removed">-         fastpath = FALSE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     !_g_closure_is_void (node-&gt;single_va_closure, instance))</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     if (_g_closure_supports_invoke_va (node-&gt;single_va_closure))</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         closure = node-&gt;single_va_closure;</span>
<span class="udiff-line-modified-added">+         if (node-&gt;single_va_closure_is_after)</span>
<span class="udiff-line-modified-added">+     run_type = G_SIGNAL_RUN_LAST;</span>
<span class="udiff-line-modified-added">+         else</span>
<span class="udiff-line-modified-added">+     run_type = G_SIGNAL_RUN_FIRST;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+     else</span>
<span class="udiff-line-modified-added">+       fastpath = FALSE;</span>
<span class="udiff-line-modified-added">+   }</span>
  
        for (l = hlist ? hlist-&gt;handlers : NULL; fastpath &amp;&amp; l != NULL; l = l-&gt;next)
<span class="udiff-line-added">+   {</span>
<span class="udiff-line-added">+     if (!l-&gt;block_count &amp;&amp;</span>
<span class="udiff-line-added">+         (!l-&gt;detail || l-&gt;detail == detail))</span>
<span class="udiff-line-added">+       {</span>
<span class="udiff-line-added">+         if (closure != NULL || !_g_closure_supports_invoke_va (l-&gt;closure))</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       fastpath = FALSE;</span>
<span class="udiff-line-added">+       break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+         else</span>
      {
<span class="udiff-line-removed">-       if (!l-&gt;block_count &amp;&amp;</span>
<span class="udiff-line-removed">-           (!l-&gt;detail || l-&gt;detail == detail))</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-           if (closure != NULL || !_g_closure_supports_invoke_va (l-&gt;closure))</span>
<span class="udiff-line-removed">-         {</span>
<span class="udiff-line-removed">-           fastpath = FALSE;</span>
<span class="udiff-line-removed">-           break;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-           else</span>
<span class="udiff-line-removed">-         {</span>
                    fastpath_handler = l;
<span class="udiff-line-modified-removed">-           closure = l-&gt;closure;</span>
<span class="udiff-line-modified-removed">-           if (l-&gt;after)</span>
<span class="udiff-line-modified-removed">-             run_type = G_SIGNAL_RUN_LAST;</span>
<span class="udiff-line-modified-removed">-           else</span>
<span class="udiff-line-modified-removed">-             run_type = G_SIGNAL_RUN_FIRST;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-modified-added">+       closure = l-&gt;closure;</span>
<span class="udiff-line-modified-added">+       if (l-&gt;after)</span>
<span class="udiff-line-modified-added">+         run_type = G_SIGNAL_RUN_LAST;</span>
<span class="udiff-line-modified-added">+       else</span>
<span class="udiff-line-modified-added">+         run_type = G_SIGNAL_RUN_FIRST;</span>
      }
<span class="udiff-line-added">+       }</span>
<span class="udiff-line-added">+   }</span>
  
        if (fastpath &amp;&amp; closure == NULL &amp;&amp; node-&gt;return_type == G_TYPE_NONE)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-removed">-       return;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   }</span>
  
        /* Don&#39;t allow no-recurse emission as we might have to restart, which means
<span class="udiff-line-modified-removed">-      we will run multiple handlers and thus must ref all arguments */</span>
<span class="udiff-line-modified-added">+    we will run multiple handlers and thus must ref all arguments */</span>
        if (closure != NULL &amp;&amp; (node-&gt;flags &amp; (G_SIGNAL_NO_RECURSE)) != 0)
<span class="udiff-line-modified-removed">-     fastpath = FALSE;</span>
<span class="udiff-line-modified-added">+   fastpath = FALSE;</span>
  
        if (fastpath)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       SignalAccumulator *accumulator;</span>
<span class="udiff-line-modified-removed">-       Emission emission;</span>
<span class="udiff-line-modified-removed">-       GValue *return_accu, accu = G_VALUE_INIT;</span>
<span class="udiff-line-modified-removed">-       guint signal_id;</span>
<span class="udiff-line-modified-removed">-       GType instance_type = G_TYPE_FROM_INSTANCE (instance);</span>
<span class="udiff-line-modified-removed">-       GValue emission_return = G_VALUE_INIT;</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     SignalAccumulator *accumulator;</span>
<span class="udiff-line-modified-added">+     Emission emission;</span>
<span class="udiff-line-modified-added">+     GValue *return_accu, accu = G_VALUE_INIT;</span>
<span class="udiff-line-modified-added">+     guint signal_id;</span>
<span class="udiff-line-modified-added">+     GType instance_type = G_TYPE_FROM_INSTANCE (instance);</span>
<span class="udiff-line-modified-added">+     GValue emission_return = G_VALUE_INIT;</span>
            GType rtype = node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
<span class="udiff-line-modified-removed">-       gboolean static_scope = node-&gt;return_type &amp; G_SIGNAL_TYPE_STATIC_SCOPE;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-       signal_id = node-&gt;signal_id;</span>
<span class="udiff-line-removed">-       accumulator = node-&gt;accumulator;</span>
<span class="udiff-line-removed">-       if (rtype == G_TYPE_NONE)</span>
<span class="udiff-line-removed">-         return_accu = NULL;</span>
<span class="udiff-line-removed">-       else if (accumulator)</span>
<span class="udiff-line-removed">-         return_accu = &amp;accu;</span>
<span class="udiff-line-removed">-       else</span>
<span class="udiff-line-removed">-         return_accu = &amp;emission_return;</span>
<span class="udiff-line-modified-added">+     gboolean static_scope = node-&gt;return_type &amp; G_SIGNAL_TYPE_STATIC_SCOPE;</span>
  
<span class="udiff-line-modified-removed">-       emission.instance = instance;</span>
<span class="udiff-line-modified-removed">-       emission.ihint.signal_id = signal_id;</span>
<span class="udiff-line-modified-removed">-       emission.ihint.detail = detail;</span>
<span class="udiff-line-modified-removed">-       emission.ihint.run_type = run_type;</span>
<span class="udiff-line-modified-removed">-       emission.state = EMISSION_RUN;</span>
<span class="udiff-line-modified-removed">-       emission.chain_type = instance_type;</span>
<span class="udiff-line-modified-removed">-       emission_push (&amp;emission);</span>
<span class="udiff-line-modified-added">+     signal_id = node-&gt;signal_id;</span>
<span class="udiff-line-modified-added">+     accumulator = node-&gt;accumulator;</span>
<span class="udiff-line-modified-added">+     if (rtype == G_TYPE_NONE)</span>
<span class="udiff-line-modified-added">+       return_accu = NULL;</span>
<span class="udiff-line-modified-added">+     else if (accumulator)</span>
<span class="udiff-line-modified-added">+       return_accu = &amp;accu;</span>
<span class="udiff-line-modified-added">+     else</span>
<span class="udiff-line-added">+       return_accu = &amp;emission_return;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     emission.instance = instance;</span>
<span class="udiff-line-added">+     emission.ihint.signal_id = signal_id;</span>
<span class="udiff-line-added">+     emission.ihint.detail = detail;</span>
<span class="udiff-line-added">+     emission.ihint.run_type = run_type;</span>
<span class="udiff-line-added">+     emission.state = EMISSION_RUN;</span>
<span class="udiff-line-added">+     emission.chain_type = instance_type;</span>
<span class="udiff-line-added">+     emission_push (&amp;emission);</span>
  
            if (fastpath_handler)
              handler_ref (fastpath_handler);
  
<span class="udiff-line-modified-removed">-       SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-added">+     SIGNAL_UNLOCK ();</span>
  
<span class="udiff-line-modified-removed">-       TRACE(GOBJECT_SIGNAL_EMIT(signal_id, detail, instance, instance_type));</span>
<span class="udiff-line-modified-added">+     TRACE(GOBJECT_SIGNAL_EMIT(signal_id, detail, instance, instance_type));</span>
  
<span class="udiff-line-modified-removed">-       if (rtype != G_TYPE_NONE)</span>
<span class="udiff-line-modified-removed">-         g_value_init (&amp;emission_return, rtype);</span>
<span class="udiff-line-modified-added">+     if (rtype != G_TYPE_NONE)</span>
<span class="udiff-line-modified-added">+       g_value_init (&amp;emission_return, rtype);</span>
  
<span class="udiff-line-modified-removed">-       if (accumulator)</span>
<span class="udiff-line-modified-removed">-         g_value_init (&amp;accu, rtype);</span>
<span class="udiff-line-modified-added">+     if (accumulator)</span>
<span class="udiff-line-modified-added">+       g_value_init (&amp;accu, rtype);</span>
  
<span class="udiff-line-modified-removed">-       if (closure != NULL)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           g_object_ref (instance);</span>
<span class="udiff-line-modified-removed">-           _g_closure_invoke_va (closure,</span>
<span class="udiff-line-modified-removed">-                     return_accu,</span>
<span class="udiff-line-modified-removed">-                     instance,</span>
<span class="udiff-line-modified-removed">-                     var_args,</span>
<span class="udiff-line-modified-removed">-                     node-&gt;n_params,</span>
<span class="udiff-line-modified-removed">-                     node-&gt;param_types);</span>
<span class="udiff-line-modified-removed">-           accumulate (&amp;emission.ihint, &amp;emission_return, &amp;accu, accumulator);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+     if (closure != NULL)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         g_object_ref (instance);</span>
<span class="udiff-line-modified-added">+         _g_closure_invoke_va (closure,</span>
<span class="udiff-line-modified-added">+             return_accu,</span>
<span class="udiff-line-modified-added">+             instance,</span>
<span class="udiff-line-modified-added">+             var_args,</span>
<span class="udiff-line-modified-added">+             node-&gt;n_params,</span>
<span class="udiff-line-modified-added">+             node-&gt;param_types);</span>
<span class="udiff-line-modified-added">+         accumulate (&amp;emission.ihint, &amp;emission_return, &amp;accu, accumulator);</span>
<span class="udiff-line-modified-added">+       }</span>
  
<span class="udiff-line-modified-removed">-       SIGNAL_LOCK ();</span>
<span class="udiff-line-modified-added">+     SIGNAL_LOCK ();</span>
  
<span class="udiff-line-modified-removed">-       emission.chain_type = G_TYPE_NONE;</span>
<span class="udiff-line-modified-removed">-       emission_pop (&amp;emission);</span>
<span class="udiff-line-modified-added">+     emission.chain_type = G_TYPE_NONE;</span>
<span class="udiff-line-modified-added">+     emission_pop (&amp;emission);</span>
  
            if (fastpath_handler)
              handler_unref_R (signal_id, instance, fastpath_handler);
  
<span class="udiff-line-modified-removed">-       SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-added">+     SIGNAL_UNLOCK ();</span>
  
<span class="udiff-line-modified-removed">-       if (accumulator)</span>
<span class="udiff-line-modified-removed">-         g_value_unset (&amp;accu);</span>
<span class="udiff-line-modified-added">+     if (accumulator)</span>
<span class="udiff-line-modified-added">+       g_value_unset (&amp;accu);</span>
  
<span class="udiff-line-modified-removed">-       if (rtype != G_TYPE_NONE)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           gchar *error = NULL;</span>
<span class="udiff-line-modified-removed">-           for (i = 0; i &lt; node-&gt;n_params; i++)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           GType ptype = node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;</span>
<span class="udiff-line-modified-removed">-           G_VALUE_COLLECT_SKIP (ptype, var_args);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+     if (rtype != G_TYPE_NONE)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         gchar *error = NULL;</span>
<span class="udiff-line-modified-added">+         for (i = 0; i &lt; node-&gt;n_params; i++)</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       GType ptype = node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;</span>
<span class="udiff-line-modified-added">+       G_VALUE_COLLECT_SKIP (ptype, var_args);</span>
<span class="udiff-line-modified-added">+     }</span>
  
<span class="udiff-line-modified-removed">-           G_VALUE_LCOPY (&amp;emission_return,</span>
<span class="udiff-line-modified-removed">-                  var_args,</span>
<span class="udiff-line-modified-removed">-                  static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="udiff-line-modified-removed">-                  &amp;error);</span>
<span class="udiff-line-modified-removed">-           if (!error)</span>
<span class="udiff-line-modified-removed">-         g_value_unset (&amp;emission_return);</span>
<span class="udiff-line-modified-removed">-           else</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           g_warning (&quot;%s: %s&quot;, G_STRLOC, error);</span>
<span class="udiff-line-modified-removed">-           g_free (error);</span>
<span class="udiff-line-modified-removed">-           /* we purposely leak the value here, it might not be</span>
<span class="udiff-line-modified-removed">-            * in a sane state if an error condition occurred</span>
<span class="udiff-line-modified-removed">-            */</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-added">+         G_VALUE_LCOPY (&amp;emission_return,</span>
<span class="udiff-line-modified-added">+            var_args,</span>
<span class="udiff-line-modified-added">+            static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="udiff-line-modified-added">+            &amp;error);</span>
<span class="udiff-line-modified-added">+         if (!error)</span>
<span class="udiff-line-modified-added">+     g_value_unset (&amp;emission_return);</span>
<span class="udiff-line-modified-added">+         else</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       g_warning (&quot;%s: %s&quot;, G_STRLOC, error);</span>
<span class="udiff-line-modified-added">+       g_free (error);</span>
<span class="udiff-line-modified-added">+       /* we purposely leak the value here, it might not be</span>
<span class="udiff-line-modified-added">+        * in a sane state if an error condition occurred</span>
<span class="udiff-line-modified-added">+        */</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-modified-added">+       }</span>
  
<span class="udiff-line-modified-removed">-       TRACE(GOBJECT_SIGNAL_EMIT_END(signal_id, detail, instance, instance_type));</span>
<span class="udiff-line-modified-added">+     TRACE(GOBJECT_SIGNAL_EMIT_END(signal_id, detail, instance, instance_type));</span>
  
            if (closure != NULL)
              g_object_unref (instance);
  
<span class="udiff-line-modified-removed">-       return;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    SIGNAL_UNLOCK ();
  
    n_params = node-&gt;n_params;
    signal_return_type = node-&gt;return_type;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3388,26 +3394,26 @@</span>
        gchar *error;
        GType ptype = node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
        gboolean static_scope = node-&gt;param_types[i] &amp; G_SIGNAL_TYPE_STATIC_SCOPE;
  
        G_VALUE_COLLECT_INIT (param_values + i, ptype,
<span class="udiff-line-modified-removed">-                 var_args,</span>
<span class="udiff-line-modified-removed">-                 static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="udiff-line-modified-removed">-                 &amp;error);</span>
<span class="udiff-line-modified-added">+           var_args,</span>
<span class="udiff-line-modified-added">+           static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="udiff-line-modified-added">+           &amp;error);</span>
        if (error)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;%s: %s&quot;, G_STRLOC, error);</span>
<span class="udiff-line-modified-removed">-       g_free (error);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;%s: %s&quot;, G_STRLOC, error);</span>
<span class="udiff-line-modified-added">+     g_free (error);</span>
  
<span class="udiff-line-modified-removed">-       /* we purposely leak the value here, it might not be</span>
<span class="udiff-line-modified-removed">-        * in a sane state if an error condition occoured</span>
<span class="udiff-line-modified-removed">-        */</span>
<span class="udiff-line-modified-removed">-       while (i--)</span>
<span class="udiff-line-modified-removed">-         g_value_unset (param_values + i);</span>
<span class="udiff-line-modified-added">+     /* we purposely leak the value here, it might not be</span>
<span class="udiff-line-modified-added">+      * in a sane state if an error condition occoured</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+     while (i--)</span>
<span class="udiff-line-modified-added">+       g_value_unset (param_values + i);</span>
  
<span class="udiff-line-modified-removed">-       return;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
  
    instance_and_params-&gt;g_type = 0;
    g_value_init_from_instance (instance_and_params, instance);
    if (signal_return_type == G_TYPE_NONE)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3422,24 +3428,24 @@</span>
        g_value_init (&amp;return_value, rtype);
  
        signal_emit_unlocked_R (node, detail, instance, &amp;return_value, instance_and_params);
  
        G_VALUE_LCOPY (&amp;return_value,
<span class="udiff-line-modified-removed">-              var_args,</span>
<span class="udiff-line-modified-removed">-              static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="udiff-line-modified-removed">-              &amp;error);</span>
<span class="udiff-line-modified-added">+          var_args,</span>
<span class="udiff-line-modified-added">+          static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="udiff-line-modified-added">+          &amp;error);</span>
        if (!error)
<span class="udiff-line-modified-removed">-     g_value_unset (&amp;return_value);</span>
<span class="udiff-line-modified-added">+   g_value_unset (&amp;return_value);</span>
        else
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;%s: %s&quot;, G_STRLOC, error);</span>
<span class="udiff-line-modified-removed">-       g_free (error);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;%s: %s&quot;, G_STRLOC, error);</span>
<span class="udiff-line-modified-added">+     g_free (error);</span>
  
<span class="udiff-line-modified-removed">-       /* we purposely leak the value here, it might not be</span>
<span class="udiff-line-modified-removed">-        * in a sane state if an error condition occurred</span>
<span class="udiff-line-modified-removed">-        */</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     /* we purposely leak the value here, it might not be</span>
<span class="udiff-line-modified-added">+      * in a sane state if an error condition occurred</span>
<span class="udiff-line-modified-added">+      */</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    for (i = 0; i &lt; n_params; i++)
      g_value_unset (param_values + i);
    g_value_unset (instance_and_params);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3458,13 +3464,13 @@</span>
   * Note that g_signal_emit() resets the return value to the default
   * if no handlers are connected, in contrast to g_signal_emitv().
   */
  void
  g_signal_emit (gpointer instance,
<span class="udiff-line-modified-removed">-            guint    signal_id,</span>
<span class="udiff-line-modified-removed">-            GQuark   detail,</span>
<span class="udiff-line-modified-removed">-            ...)</span>
<span class="udiff-line-modified-added">+          guint    signal_id,</span>
<span class="udiff-line-modified-added">+          GQuark   detail,</span>
<span class="udiff-line-modified-added">+          ...)</span>
  {
    va_list var_args;
  
    va_start (var_args, detail);
    g_signal_emit_valist (instance, signal_id, detail, var_args);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3484,12 +3490,12 @@</span>
   * Note that g_signal_emit_by_name() resets the return value to the default
   * if no handlers are connected, in contrast to g_signal_emitv().
   */
  void
  g_signal_emit_by_name (gpointer     instance,
<span class="udiff-line-modified-removed">-                const gchar *detailed_signal,</span>
<span class="udiff-line-modified-removed">-                ...)</span>
<span class="udiff-line-modified-added">+            const gchar *detailed_signal,</span>
<span class="udiff-line-modified-added">+            ...)</span>
  {
    GQuark detail = 0;
    guint signal_id;
    GType itype;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3515,14 +3521,14 @@</span>
                 G_STRLOC, detailed_signal, instance, g_type_name (itype));
  }
  
  static gboolean
  signal_emit_unlocked_R (SignalNode   *node,
<span class="udiff-line-modified-removed">-             GQuark        detail,</span>
<span class="udiff-line-modified-removed">-                         gpointer      instance,</span>
<span class="udiff-line-modified-removed">-             GValue       *emission_return,</span>
<span class="udiff-line-modified-removed">-                         const GValue *instance_and_params)</span>
<span class="udiff-line-modified-added">+       GQuark        detail,</span>
<span class="udiff-line-modified-added">+       gpointer      instance,</span>
<span class="udiff-line-modified-added">+       GValue       *emission_return,</span>
<span class="udiff-line-modified-added">+       const GValue *instance_and_params)</span>
  {
    SignalAccumulator *accumulator;
    Emission emission;
    GClosure *class_closure;
    HandlerList *hlist;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3540,15 +3546,15 @@</span>
    if (node-&gt;flags &amp; G_SIGNAL_NO_RECURSE)
      {
        Emission *node = emission_find (signal_id, detail, instance);
  
        if (node)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       node-&gt;state = EMISSION_RESTART;</span>
<span class="udiff-line-modified-removed">-       SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-removed">-       return return_value_altered;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     node-&gt;state = EMISSION_RESTART;</span>
<span class="udiff-line-modified-added">+     SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-added">+     return return_value_altered;</span>
<span class="udiff-line-modified-added">+   }</span>
      }
    accumulator = node-&gt;accumulator;
    if (accumulator)
      {
        SIGNAL_UNLOCK ();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3584,107 +3590,107 @@</span>
        emission.state = EMISSION_RUN;
  
        emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
        SIGNAL_UNLOCK ();
        g_closure_invoke (class_closure,
<span class="udiff-line-modified-removed">-             return_accu,</span>
<span class="udiff-line-modified-removed">-             node-&gt;n_params + 1,</span>
<span class="udiff-line-modified-removed">-             instance_and_params,</span>
<span class="udiff-line-modified-removed">-             &amp;emission.ihint);</span>
<span class="udiff-line-modified-added">+       return_accu,</span>
<span class="udiff-line-modified-added">+       node-&gt;n_params + 1,</span>
<span class="udiff-line-modified-added">+       instance_and_params,</span>
<span class="udiff-line-modified-added">+       &amp;emission.ihint);</span>
        if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;
<span class="udiff-line-modified-removed">-       emission.state == EMISSION_RUN)</span>
<span class="udiff-line-modified-removed">-     emission.state = EMISSION_STOP;</span>
<span class="udiff-line-modified-added">+     emission.state == EMISSION_RUN)</span>
<span class="udiff-line-modified-added">+   emission.state = EMISSION_STOP;</span>
        SIGNAL_LOCK ();
        emission.chain_type = G_TYPE_NONE;
        return_value_altered = TRUE;
  
        if (emission.state == EMISSION_STOP)
<span class="udiff-line-modified-removed">-     goto EMIT_CLEANUP;</span>
<span class="udiff-line-modified-added">+   goto EMIT_CLEANUP;</span>
        else if (emission.state == EMISSION_RESTART)
<span class="udiff-line-modified-removed">-     goto EMIT_RESTART;</span>
<span class="udiff-line-modified-added">+   goto EMIT_RESTART;</span>
      }
  
    if (node-&gt;emission_hooks)
      {
        gboolean need_destroy, was_in_call, may_recurse = TRUE;
        GHook *hook;
  
        emission.state = EMISSION_HOOK;
        hook = g_hook_first_valid (node-&gt;emission_hooks, may_recurse);
        while (hook)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       SignalHook *signal_hook = SIGNAL_HOOK (hook);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     SignalHook *signal_hook = SIGNAL_HOOK (hook);</span>
  
<span class="udiff-line-modified-removed">-       if (!signal_hook-&gt;detail || signal_hook-&gt;detail == detail)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           GSignalEmissionHook hook_func = (GSignalEmissionHook) hook-&gt;func;</span>
<span class="udiff-line-modified-added">+     if (!signal_hook-&gt;detail || signal_hook-&gt;detail == detail)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         GSignalEmissionHook hook_func = (GSignalEmissionHook) hook-&gt;func;</span>
  
<span class="udiff-line-modified-removed">-           was_in_call = G_HOOK_IN_CALL (hook);</span>
<span class="udiff-line-modified-removed">-           hook-&gt;flags |= G_HOOK_FLAG_IN_CALL;</span>
<span class="udiff-line-modified-added">+         was_in_call = G_HOOK_IN_CALL (hook);</span>
<span class="udiff-line-modified-added">+         hook-&gt;flags |= G_HOOK_FLAG_IN_CALL;</span>
                SIGNAL_UNLOCK ();
<span class="udiff-line-modified-removed">-           need_destroy = !hook_func (&amp;emission.ihint, node-&gt;n_params + 1, instance_and_params, hook-&gt;data);</span>
<span class="udiff-line-modified-removed">-           SIGNAL_LOCK ();</span>
<span class="udiff-line-modified-removed">-           if (!was_in_call)</span>
<span class="udiff-line-modified-removed">-         hook-&gt;flags &amp;= ~G_HOOK_FLAG_IN_CALL;</span>
<span class="udiff-line-modified-removed">-           if (need_destroy)</span>
<span class="udiff-line-modified-removed">-         g_hook_destroy_link (node-&gt;emission_hooks, hook);</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-       hook = g_hook_next_valid (node-&gt;emission_hooks, hook, may_recurse);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+         need_destroy = !hook_func (&amp;emission.ihint, node-&gt;n_params + 1, instance_and_params, hook-&gt;data);</span>
<span class="udiff-line-modified-added">+         SIGNAL_LOCK ();</span>
<span class="udiff-line-modified-added">+         if (!was_in_call)</span>
<span class="udiff-line-modified-added">+     hook-&gt;flags &amp;= ~G_HOOK_FLAG_IN_CALL;</span>
<span class="udiff-line-modified-added">+         if (need_destroy)</span>
<span class="udiff-line-modified-added">+     g_hook_destroy_link (node-&gt;emission_hooks, hook);</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+     hook = g_hook_next_valid (node-&gt;emission_hooks, hook, may_recurse);</span>
<span class="udiff-line-modified-added">+   }</span>
  
        if (emission.state == EMISSION_RESTART)
<span class="udiff-line-modified-removed">-     goto EMIT_RESTART;</span>
<span class="udiff-line-modified-added">+   goto EMIT_RESTART;</span>
      }
  
    if (handler_list)
      {
        Handler *handler = handler_list;
  
        emission.state = EMISSION_RUN;
        handler_ref (handler);
        do
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       Handler *tmp;</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     Handler *tmp;</span>
  
<span class="udiff-line-modified-removed">-       if (handler-&gt;after)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           handler_unref_R (signal_id, instance, handler_list);</span>
<span class="udiff-line-modified-removed">-           handler_list = handler;</span>
<span class="udiff-line-modified-removed">-           break;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-       else if (!handler-&gt;block_count &amp;&amp; (!handler-&gt;detail || handler-&gt;detail == detail) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-            handler-&gt;sequential_number &lt; max_sequential_handler_number)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-removed">-           g_closure_invoke (handler-&gt;closure,</span>
<span class="udiff-line-modified-removed">-                 return_accu,</span>
<span class="udiff-line-modified-removed">-                 node-&gt;n_params + 1,</span>
<span class="udiff-line-modified-removed">-                 instance_and_params,</span>
<span class="udiff-line-modified-removed">-                 &amp;emission.ihint);</span>
<span class="udiff-line-modified-removed">-           if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-           emission.state == EMISSION_RUN)</span>
<span class="udiff-line-modified-removed">-         emission.state = EMISSION_STOP;</span>
<span class="udiff-line-modified-removed">-           SIGNAL_LOCK ();</span>
<span class="udiff-line-modified-removed">-           return_value_altered = TRUE;</span>
<span class="udiff-line-modified-added">+     if (handler-&gt;after)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         handler_unref_R (signal_id, instance, handler_list);</span>
<span class="udiff-line-modified-added">+         handler_list = handler;</span>
<span class="udiff-line-modified-added">+         break;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+     else if (!handler-&gt;block_count &amp;&amp; (!handler-&gt;detail || handler-&gt;detail == detail) &amp;&amp;</span>
<span class="udiff-line-modified-added">+        handler-&gt;sequential_number &lt; max_sequential_handler_number)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-added">+         g_closure_invoke (handler-&gt;closure,</span>
<span class="udiff-line-modified-added">+         return_accu,</span>
<span class="udiff-line-modified-added">+         node-&gt;n_params + 1,</span>
<span class="udiff-line-modified-added">+         instance_and_params,</span>
<span class="udiff-line-modified-added">+         &amp;emission.ihint);</span>
<span class="udiff-line-modified-added">+         if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;</span>
<span class="udiff-line-modified-added">+       emission.state == EMISSION_RUN)</span>
<span class="udiff-line-modified-added">+     emission.state = EMISSION_STOP;</span>
<span class="udiff-line-modified-added">+         SIGNAL_LOCK ();</span>
<span class="udiff-line-modified-added">+         return_value_altered = TRUE;</span>
  
<span class="udiff-line-modified-removed">-           tmp = emission.state == EMISSION_RUN ? handler-&gt;next : NULL;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-       else</span>
<span class="udiff-line-modified-removed">-         tmp = handler-&gt;next;</span>
<span class="udiff-line-modified-added">+         tmp = emission.state == EMISSION_RUN ? handler-&gt;next : NULL;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+     else</span>
<span class="udiff-line-modified-added">+       tmp = handler-&gt;next;</span>
  
<span class="udiff-line-modified-removed">-       if (tmp)</span>
<span class="udiff-line-modified-removed">-         handler_ref (tmp);</span>
<span class="udiff-line-modified-removed">-       handler_unref_R (signal_id, instance, handler_list);</span>
<span class="udiff-line-modified-removed">-       handler_list = handler;</span>
<span class="udiff-line-modified-removed">-       handler = tmp;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     if (tmp)</span>
<span class="udiff-line-modified-added">+       handler_ref (tmp);</span>
<span class="udiff-line-modified-added">+     handler_unref_R (signal_id, instance, handler_list);</span>
<span class="udiff-line-modified-added">+     handler_list = handler;</span>
<span class="udiff-line-modified-added">+     handler = tmp;</span>
<span class="udiff-line-modified-added">+   }</span>
        while (handler);
  
        if (emission.state == EMISSION_STOP)
<span class="udiff-line-modified-removed">-     goto EMIT_CLEANUP;</span>
<span class="udiff-line-modified-added">+   goto EMIT_CLEANUP;</span>
        else if (emission.state == EMISSION_RESTART)
<span class="udiff-line-modified-removed">-     goto EMIT_RESTART;</span>
<span class="udiff-line-modified-added">+   goto EMIT_RESTART;</span>
      }
  
    emission.ihint.run_type = G_SIGNAL_RUN_LAST;
  
    if ((node-&gt;flags &amp; G_SIGNAL_RUN_LAST) &amp;&amp; class_closure)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3692,68 +3698,68 @@</span>
        emission.state = EMISSION_RUN;
  
        emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
        SIGNAL_UNLOCK ();
        g_closure_invoke (class_closure,
<span class="udiff-line-modified-removed">-             return_accu,</span>
<span class="udiff-line-modified-removed">-             node-&gt;n_params + 1,</span>
<span class="udiff-line-modified-removed">-             instance_and_params,</span>
<span class="udiff-line-modified-removed">-             &amp;emission.ihint);</span>
<span class="udiff-line-modified-added">+       return_accu,</span>
<span class="udiff-line-modified-added">+       node-&gt;n_params + 1,</span>
<span class="udiff-line-modified-added">+       instance_and_params,</span>
<span class="udiff-line-modified-added">+       &amp;emission.ihint);</span>
        if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;
<span class="udiff-line-modified-removed">-       emission.state == EMISSION_RUN)</span>
<span class="udiff-line-modified-removed">-     emission.state = EMISSION_STOP;</span>
<span class="udiff-line-modified-added">+     emission.state == EMISSION_RUN)</span>
<span class="udiff-line-modified-added">+   emission.state = EMISSION_STOP;</span>
        SIGNAL_LOCK ();
        emission.chain_type = G_TYPE_NONE;
        return_value_altered = TRUE;
  
        if (emission.state == EMISSION_STOP)
<span class="udiff-line-modified-removed">-     goto EMIT_CLEANUP;</span>
<span class="udiff-line-modified-added">+   goto EMIT_CLEANUP;</span>
        else if (emission.state == EMISSION_RESTART)
<span class="udiff-line-modified-removed">-     goto EMIT_RESTART;</span>
<span class="udiff-line-modified-added">+   goto EMIT_RESTART;</span>
      }
  
    if (handler_list)
      {
        Handler *handler = handler_list;
  
        emission.state = EMISSION_RUN;
        handler_ref (handler);
        do
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       Handler *tmp;</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     Handler *tmp;</span>
  
<span class="udiff-line-modified-removed">-       if (handler-&gt;after &amp;&amp; !handler-&gt;block_count &amp;&amp; (!handler-&gt;detail || handler-&gt;detail == detail) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-           handler-&gt;sequential_number &lt; max_sequential_handler_number)</span>
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-removed">-           g_closure_invoke (handler-&gt;closure,</span>
<span class="udiff-line-modified-removed">-                 return_accu,</span>
<span class="udiff-line-modified-removed">-                 node-&gt;n_params + 1,</span>
<span class="udiff-line-modified-removed">-                 instance_and_params,</span>
<span class="udiff-line-modified-removed">-                 &amp;emission.ihint);</span>
<span class="udiff-line-modified-removed">-           if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;</span>
<span class="udiff-line-modified-removed">-           emission.state == EMISSION_RUN)</span>
<span class="udiff-line-modified-removed">-         emission.state = EMISSION_STOP;</span>
<span class="udiff-line-modified-removed">-           SIGNAL_LOCK ();</span>
<span class="udiff-line-modified-removed">-           return_value_altered = TRUE;</span>
<span class="udiff-line-modified-added">+     if (handler-&gt;after &amp;&amp; !handler-&gt;block_count &amp;&amp; (!handler-&gt;detail || handler-&gt;detail == detail) &amp;&amp;</span>
<span class="udiff-line-modified-added">+         handler-&gt;sequential_number &lt; max_sequential_handler_number)</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+         SIGNAL_UNLOCK ();</span>
<span class="udiff-line-modified-added">+         g_closure_invoke (handler-&gt;closure,</span>
<span class="udiff-line-modified-added">+         return_accu,</span>
<span class="udiff-line-modified-added">+         node-&gt;n_params + 1,</span>
<span class="udiff-line-modified-added">+         instance_and_params,</span>
<span class="udiff-line-modified-added">+         &amp;emission.ihint);</span>
<span class="udiff-line-modified-added">+         if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;</span>
<span class="udiff-line-modified-added">+       emission.state == EMISSION_RUN)</span>
<span class="udiff-line-modified-added">+     emission.state = EMISSION_STOP;</span>
<span class="udiff-line-modified-added">+         SIGNAL_LOCK ();</span>
<span class="udiff-line-modified-added">+         return_value_altered = TRUE;</span>
  
<span class="udiff-line-modified-removed">-           tmp = emission.state == EMISSION_RUN ? handler-&gt;next : NULL;</span>
<span class="udiff-line-modified-removed">-         }</span>
<span class="udiff-line-modified-removed">-       else</span>
<span class="udiff-line-modified-removed">-         tmp = handler-&gt;next;</span>
<span class="udiff-line-modified-added">+         tmp = emission.state == EMISSION_RUN ? handler-&gt;next : NULL;</span>
<span class="udiff-line-modified-added">+       }</span>
<span class="udiff-line-modified-added">+     else</span>
<span class="udiff-line-modified-added">+       tmp = handler-&gt;next;</span>
  
<span class="udiff-line-modified-removed">-       if (tmp)</span>
<span class="udiff-line-modified-removed">-         handler_ref (tmp);</span>
<span class="udiff-line-modified-removed">-       handler_unref_R (signal_id, instance, handler);</span>
<span class="udiff-line-modified-removed">-       handler = tmp;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     if (tmp)</span>
<span class="udiff-line-modified-added">+       handler_ref (tmp);</span>
<span class="udiff-line-modified-added">+     handler_unref_R (signal_id, instance, handler);</span>
<span class="udiff-line-modified-added">+     handler = tmp;</span>
<span class="udiff-line-modified-added">+   }</span>
        while (handler);
  
        if (emission.state == EMISSION_STOP)
<span class="udiff-line-modified-removed">-     goto EMIT_CLEANUP;</span>
<span class="udiff-line-modified-added">+   goto EMIT_CLEANUP;</span>
        else if (emission.state == EMISSION_RESTART)
<span class="udiff-line-modified-removed">-     goto EMIT_RESTART;</span>
<span class="udiff-line-modified-added">+   goto EMIT_RESTART;</span>
      }
  
   EMIT_CLEANUP:
  
    emission.ihint.run_type = G_SIGNAL_RUN_CLEANUP;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3765,26 +3771,31 @@</span>
        emission.state = EMISSION_STOP;
  
        emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
        SIGNAL_UNLOCK ();
        if (node-&gt;return_type != G_TYPE_NONE &amp;&amp; !accumulator)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_value_init (&amp;accu, node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE);</span>
<span class="udiff-line-modified-removed">-       need_unset = TRUE;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_value_init (&amp;accu, node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE);</span>
<span class="udiff-line-modified-added">+     need_unset = TRUE;</span>
<span class="udiff-line-modified-added">+   }</span>
        g_closure_invoke (class_closure,
<span class="udiff-line-modified-removed">-             node-&gt;return_type != G_TYPE_NONE ? &amp;accu : NULL,</span>
<span class="udiff-line-modified-removed">-             node-&gt;n_params + 1,</span>
<span class="udiff-line-modified-removed">-             instance_and_params,</span>
<span class="udiff-line-modified-removed">-             &amp;emission.ihint);</span>
<span class="udiff-line-modified-added">+       node-&gt;return_type != G_TYPE_NONE ? &amp;accu : NULL,</span>
<span class="udiff-line-modified-added">+       node-&gt;n_params + 1,</span>
<span class="udiff-line-modified-added">+       instance_and_params,</span>
<span class="udiff-line-modified-added">+       &amp;emission.ihint);</span>
<span class="udiff-line-added">+       if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;</span>
<span class="udiff-line-added">+           emission.state == EMISSION_RUN)</span>
<span class="udiff-line-added">+         emission.state = EMISSION_STOP;</span>
        if (need_unset)
<span class="udiff-line-modified-removed">-     g_value_unset (&amp;accu);</span>
<span class="udiff-line-modified-added">+   g_value_unset (&amp;accu);</span>
        SIGNAL_LOCK ();
<span class="udiff-line-added">+       return_value_altered = TRUE;</span>
<span class="udiff-line-added">+ </span>
        emission.chain_type = G_TYPE_NONE;
  
        if (emission.state == EMISSION_RESTART)
<span class="udiff-line-modified-removed">-     goto EMIT_RESTART;</span>
<span class="udiff-line-modified-added">+   goto EMIT_RESTART;</span>
      }
  
    if (handler_list)
      handler_unref_R (signal_id, instance, handler_list);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3798,30 +3809,30 @@</span>
    return return_value_altered;
  }
  
  static void
  add_invalid_closure_notify (Handler  *handler,
<span class="udiff-line-modified-removed">-                 gpointer  instance)</span>
<span class="udiff-line-modified-added">+           gpointer  instance)</span>
  {
    g_closure_add_invalidate_notifier (handler-&gt;closure, instance, invalid_closure_notify);
    handler-&gt;has_invalid_closure_notify = 1;
  }
  
  static void
  remove_invalid_closure_notify (Handler  *handler,
<span class="udiff-line-modified-removed">-                    gpointer  instance)</span>
<span class="udiff-line-modified-added">+              gpointer  instance)</span>
  {
    if (handler-&gt;has_invalid_closure_notify)
      {
        g_closure_remove_invalidate_notifier (handler-&gt;closure, instance, invalid_closure_notify);
        handler-&gt;has_invalid_closure_notify = 0;
      }
  }
  
  static void
  invalid_closure_notify (gpointer  instance,
<span class="udiff-line-modified-removed">-                 GClosure *closure)</span>
<span class="udiff-line-modified-added">+             GClosure *closure)</span>
  {
    Handler *handler;
    guint signal_id;
  
    SIGNAL_LOCK ();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3873,13 +3884,13 @@</span>
   *
   * Returns: standard #GSignalAccumulator result
   */
  gboolean
  g_signal_accumulator_true_handled (GSignalInvocationHint *ihint,
<span class="udiff-line-modified-removed">-                    GValue                *return_accu,</span>
<span class="udiff-line-modified-removed">-                    const GValue          *handler_return,</span>
<span class="udiff-line-modified-removed">-                    gpointer               dummy)</span>
<span class="udiff-line-modified-added">+            GValue                *return_accu,</span>
<span class="udiff-line-modified-added">+            const GValue          *handler_return,</span>
<span class="udiff-line-modified-added">+            gpointer               dummy)</span>
  {
    gboolean continue_emission;
    gboolean signal_handled;
  
    signal_handled = g_value_get_boolean (handler_return);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3918,5 +3929,35 @@</span>
                                   gpointer               dummy)
  {
    g_value_copy (handler_return, return_accu);
    return FALSE;
  }
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ /**</span>
<span class="udiff-line-added">+  * g_clear_signal_handler:</span>
<span class="udiff-line-added">+  * @handler_id_ptr: A pointer to a handler ID (of type #gulong) of the handler to be disconnected.</span>
<span class="udiff-line-added">+  * @instance: (type GObject.Object): The instance to remove the signal handler from.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Disconnects a handler from @instance so it will not be called during</span>
<span class="udiff-line-added">+  * any future or currently ongoing emissions of the signal it has been</span>
<span class="udiff-line-added">+  * connected to. The @handler_id_ptr is then set to zero, which is never a valid handler ID value (see g_signal_connect()).</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * If the handler ID is 0 then this function does nothing.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * A macro is also included that allows this function to be used without</span>
<span class="udiff-line-added">+  * pointer casts.</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Since: 2.62</span>
<span class="udiff-line-added">+  */</span>
<span class="udiff-line-added">+ #undef g_clear_signal_handler</span>
<span class="udiff-line-added">+ void</span>
<span class="udiff-line-added">+ g_clear_signal_handler (gulong   *handler_id_ptr,</span>
<span class="udiff-line-added">+                         gpointer  instance)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   g_return_if_fail (handler_id_ptr != NULL);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   if (*handler_id_ptr != 0)</span>
<span class="udiff-line-added">+     {</span>
<span class="udiff-line-added">+       g_signal_handler_disconnect (instance, *handler_id_ptr);</span>
<span class="udiff-line-added">+       *handler_id_ptr = 0;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
</pre>
<center><a href="gparamspecs.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gsignal.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>