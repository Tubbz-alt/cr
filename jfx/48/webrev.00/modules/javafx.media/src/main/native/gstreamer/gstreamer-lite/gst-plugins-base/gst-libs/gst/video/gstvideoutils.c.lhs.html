<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/gstvideoutils.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* GStreamer
  2  * Copyright (C) 2008 David Schleef &lt;ds@schleef.org&gt;
  3  * Copyright (C) 2012 Collabora Ltd.
  4  *  Author : Edward Hervey &lt;edward@collabora.com&gt;
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public
 17  * License along with this library; if not, write to the
 18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #ifdef HAVE_CONFIG_H
 23 #include &quot;config.h&quot;
 24 #endif
 25 
 26 #include &lt;gst/video/video.h&gt;
 27 #include &quot;gstvideoutils.h&quot;
 28 
<a name="1" id="anc1"></a>





 29 #include &lt;string.h&gt;
 30 
 31 G_DEFINE_BOXED_TYPE (GstVideoCodecFrame, gst_video_codec_frame,
 32     (GBoxedCopyFunc) gst_video_codec_frame_ref,
 33     (GBoxedFreeFunc) gst_video_codec_frame_unref);
 34 
 35 static void
 36 _gst_video_codec_frame_free (GstVideoCodecFrame * frame)
 37 {
 38   g_return_if_fail (frame != NULL);
 39 
 40   GST_DEBUG (&quot;free frame %p&quot;, frame);
 41 
 42   if (frame-&gt;input_buffer) {
 43     gst_buffer_unref (frame-&gt;input_buffer);
 44   }
 45 
 46   if (frame-&gt;output_buffer) {
 47     gst_buffer_unref (frame-&gt;output_buffer);
 48   }
 49 
 50   g_list_free_full (frame-&gt;events, (GDestroyNotify) gst_event_unref);
 51   frame-&gt;events = NULL;
 52 
 53   if (frame-&gt;user_data_destroy_notify)
 54     frame-&gt;user_data_destroy_notify (frame-&gt;user_data);
 55 
 56   g_slice_free (GstVideoCodecFrame, frame);
 57 }
 58 
 59 /**
 60  * gst_video_codec_frame_set_user_data:
 61  * @frame: a #GstVideoCodecFrame
 62  * @user_data: private data
 63  * @notify: (closure user_data): a #GDestroyNotify
 64  *
 65  * Sets @user_data on the frame and the #GDestroyNotify that will be called when
 66  * the frame is freed. Allows to attach private data by the subclass to frames.
 67  *
 68  * If a @user_data was previously set, then the previous set @notify will be called
 69  * before the @user_data is replaced.
 70  */
 71 void
 72 gst_video_codec_frame_set_user_data (GstVideoCodecFrame * frame,
 73     gpointer user_data, GDestroyNotify notify)
 74 {
 75   if (frame-&gt;user_data_destroy_notify)
 76     frame-&gt;user_data_destroy_notify (frame-&gt;user_data);
 77 
 78   frame-&gt;user_data = user_data;
 79   frame-&gt;user_data_destroy_notify = notify;
 80 }
 81 
 82 /**
 83  * gst_video_codec_frame_get_user_data:
 84  * @frame: a #GstVideoCodecFrame
 85  *
 86  * Gets private data set on the frame by the subclass via
 87  * gst_video_codec_frame_set_user_data() previously.
 88  *
 89  * Returns: (transfer none): The previously set user_data
 90  */
 91 gpointer
 92 gst_video_codec_frame_get_user_data (GstVideoCodecFrame * frame)
 93 {
 94   return frame-&gt;user_data;
 95 }
 96 
 97 /**
 98  * gst_video_codec_frame_ref:
 99  * @frame: a #GstVideoCodecFrame
100  *
101  * Increases the refcount of the given frame by one.
102  *
103  * Returns: @buf
104  */
105 GstVideoCodecFrame *
106 gst_video_codec_frame_ref (GstVideoCodecFrame * frame)
107 {
108   g_return_val_if_fail (frame != NULL, NULL);
109 
110   GST_TRACE (&quot;%p ref %d-&gt;%d&quot;, frame, frame-&gt;ref_count, frame-&gt;ref_count + 1);
111 
112   g_atomic_int_inc (&amp;frame-&gt;ref_count);
113 
114   return frame;
115 }
116 
117 /**
118  * gst_video_codec_frame_unref:
119  * @frame: a #GstVideoCodecFrame
120  *
121  * Decreases the refcount of the frame. If the refcount reaches 0, the frame
122  * will be freed.
123  */
124 void
125 gst_video_codec_frame_unref (GstVideoCodecFrame * frame)
126 {
127   g_return_if_fail (frame != NULL);
128   g_return_if_fail (frame-&gt;ref_count &gt; 0);
129 
130   GST_TRACE (&quot;%p unref %d-&gt;%d&quot;, frame, frame-&gt;ref_count, frame-&gt;ref_count - 1);
131 
132   if (g_atomic_int_dec_and_test (&amp;frame-&gt;ref_count)) {
133     _gst_video_codec_frame_free (frame);
134   }
135 }
136 
137 
138 /**
139  * gst_video_codec_state_ref:
140  * @state: a #GstVideoCodecState
141  *
142  * Increases the refcount of the given state by one.
143  *
144  * Returns: @buf
145  */
146 GstVideoCodecState *
147 gst_video_codec_state_ref (GstVideoCodecState * state)
148 {
149   g_return_val_if_fail (state != NULL, NULL);
150 
151   GST_TRACE (&quot;%p ref %d-&gt;%d&quot;, state, state-&gt;ref_count, state-&gt;ref_count + 1);
152 
153   g_atomic_int_inc (&amp;state-&gt;ref_count);
154 
155   return state;
156 }
157 
158 static void
159 _gst_video_codec_state_free (GstVideoCodecState * state)
160 {
161   GST_DEBUG (&quot;free state %p&quot;, state);
162 
163   if (state-&gt;caps)
164     gst_caps_unref (state-&gt;caps);
165   if (state-&gt;allocation_caps)
166     gst_caps_unref (state-&gt;allocation_caps);
167   if (state-&gt;codec_data)
168     gst_buffer_unref (state-&gt;codec_data);
169   g_slice_free (GstVideoCodecState, state);
170 }
171 
172 /**
173  * gst_video_codec_state_unref:
174  * @state: a #GstVideoCodecState
175  *
176  * Decreases the refcount of the state. If the refcount reaches 0, the state
177  * will be freed.
178  */
179 void
180 gst_video_codec_state_unref (GstVideoCodecState * state)
181 {
182   g_return_if_fail (state != NULL);
183   g_return_if_fail (state-&gt;ref_count &gt; 0);
184 
185   GST_TRACE (&quot;%p unref %d-&gt;%d&quot;, state, state-&gt;ref_count, state-&gt;ref_count - 1);
186 
187   if (g_atomic_int_dec_and_test (&amp;state-&gt;ref_count)) {
188     _gst_video_codec_state_free (state);
189   }
190 }
191 
192 G_DEFINE_BOXED_TYPE (GstVideoCodecState, gst_video_codec_state,
193     (GBoxedCopyFunc) gst_video_codec_state_ref,
194     (GBoxedFreeFunc) gst_video_codec_state_unref);
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>