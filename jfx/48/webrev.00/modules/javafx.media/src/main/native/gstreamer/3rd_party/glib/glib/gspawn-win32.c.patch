diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn-win32.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn-win32.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn-win32.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn-win32.c
@@ -65,21 +65,21 @@
 #ifdef G_SPAWN_WIN32_DEBUG
   static int debug = 1;
   #define SETUP_DEBUG() /* empty */
 #else
   static int debug = -1;
-  #define SETUP_DEBUG()                 \
-    G_STMT_START                    \
-      {                         \
-    if (debug == -1)                \
-      {                     \
-        if (getenv ("G_SPAWN_WIN32_DEBUG") != NULL) \
-          debug = 1;                \
-        else                    \
-          debug = 0;                \
-      }                     \
-      }                         \
+  #define SETUP_DEBUG()         \
+    G_STMT_START          \
+      {             \
+  if (debug == -1)        \
+    {           \
+      if (getenv ("G_SPAWN_WIN32_DEBUG") != NULL) \
+        debug = 1;        \
+      else          \
+        debug = 0;        \
+    }           \
+      }             \
     G_STMT_END
 #endif
 #endif
 
 enum
@@ -103,18 +103,18 @@
   ARG_PROGRAM,
   ARG_COUNT = ARG_PROGRAM
 };
 
 static int
-dup_noninherited (int fd,
-          int mode)
+reopen_noninherited (int fd,
+         int mode)
 {
   HANDLE filehandle;
 
   DuplicateHandle (GetCurrentProcess (), (LPHANDLE) _get_osfhandle (fd),
-           GetCurrentProcess (), &filehandle,
-           0, FALSE, DUPLICATE_SAME_ACCESS);
+       GetCurrentProcess (), &filehandle,
+       0, FALSE, DUPLICATE_SAME_ACCESS);
   close (fd);
   return _open_osfhandle ((gintptr) filehandle, mode | _O_NOINHERIT);
 }
 
 #ifndef GSPAWN_HELPER
@@ -123,67 +123,78 @@
 #define HELPER_PROCESS "gspawn-win64-helper"
 #else
 #define HELPER_PROCESS "gspawn-win32-helper"
 #endif
 
+/* This logic has a copy for wchar_t in gspawn-win32-helper.c, protect_wargv() */
 static gchar *
 protect_argv_string (const gchar *string)
 {
   const gchar *p = string;
   gchar *retval, *q;
   gint len = 0;
+  gint pre_bslash = 0;
   gboolean need_dblquotes = FALSE;
   while (*p)
     {
       if (*p == ' ' || *p == '\t')
-    need_dblquotes = TRUE;
-      else if (*p == '"')
-    len++;
-      else if (*p == '\\')
-    {
-      const gchar *pp = p;
-      while (*pp && *pp == '\\')
-        pp++;
-      if (*pp == '"')
-        len++;
-    }
-      len++;
+  need_dblquotes = TRUE;
+      /* estimate max len, assuming that all escapable chracters will be escaped */
+      if (*p == '"' || *p == '\\')
+  len += 2;
+      else
+  len += 1;
       p++;
     }
 
   q = retval = g_malloc (len + need_dblquotes*2 + 1);
   p = string;
 
   if (need_dblquotes)
     *q++ = '"';
-
+  /* Only quotes and backslashes preceeding quotes are escaped:
+   * see "Parsing C Command-Line Arguments" at
+   * https://docs.microsoft.com/en-us/cpp/c-language/parsing-c-command-line-arguments
+   */
   while (*p)
     {
       if (*p == '"')
+  {
+    /* Add backslash for escaping quote itself */
     *q++ = '\\';
-      else if (*p == '\\')
-    {
-      const gchar *pp = p;
-      while (*pp && *pp == '\\')
-        pp++;
-      if (*pp == '"')
-        *q++ = '\\';
-    }
+    /* Add backslash for every preceeding backslash for escaping it */
+    for (;pre_bslash > 0; --pre_bslash)
+      *q++ = '\\';
+  }
+
+      /* Count length of continuous sequence of preceeding backslashes. */
+      if (*p == '\\')
+  ++pre_bslash;
+      else
+  pre_bslash = 0;
+
       *q++ = *p;
       p++;
     }
 
   if (need_dblquotes)
-    *q++ = '"';
+    {
+      /* Add backslash for every preceeding backslash for escaping it,
+       * do NOT escape quote itself.
+       */
+      for (;pre_bslash > 0; --pre_bslash)
+  *q++ = '\\';
+      *q++ = '"';
+    }
   *q++ = '\0';
 
   return retval;
 }
 
 static gint
 protect_argv (gchar  **argv,
-          gchar ***new_argv)
+        gchar ***new_argv)
 {
   gint i;
   gint argc = 0;
 
   while (argv[argc])
@@ -194,11 +205,11 @@
    * reconstructed correctly in the C runtime startup code.  Note that
    * the unquoting algorithm in the C runtime is really weird, and
    * rather different than what Unix shells do. See stdargv.c in the C
    * runtime sources (in the Platform SDK, in src/crt).
    *
-   * Note that an new_argv[0] constructed by this function should
+   * Note that a new_argv[0] constructed by this function should
    * *not* be passed as the filename argument to a spawn* or exec*
    * family function. That argument should be the real file name
    * without any quoting.
    */
   for (i = 0; i < argc; i++)
@@ -212,28 +223,28 @@
 G_DEFINE_QUARK (g-exec-error-quark, g_spawn_error)
 G_DEFINE_QUARK (g-spawn-exit-error-quark, g_spawn_exit_error)
 
 gboolean
 g_spawn_async (const gchar          *working_directory,
-            gchar               **argv,
-            gchar               **envp,
-            GSpawnFlags           flags,
-            GSpawnChildSetupFunc  child_setup,
-            gpointer              user_data,
-            GPid                 *child_handle,
-            GError              **error)
+               gchar               **argv,
+               gchar               **envp,
+               GSpawnFlags           flags,
+               GSpawnChildSetupFunc  child_setup,
+               gpointer              user_data,
+               GPid                 *child_handle,
+               GError              **error)
 {
   g_return_val_if_fail (argv != NULL, FALSE);
 
   return g_spawn_async_with_pipes (working_directory,
-                    argv, envp,
-                    flags,
-                    child_setup,
-                    user_data,
-                    child_handle,
-                    NULL, NULL, NULL,
-                    error);
+                                   argv, envp,
+                                   flags,
+                                   child_setup,
+                                   user_data,
+                                   child_handle,
+                                   NULL, NULL, NULL,
+                                   error);
 }
 
 /* Avoids a danger in threaded situations (calling close()
  * on a file descriptor twice, and another thread has
  * re-opened it since the first close)
@@ -308,31 +319,31 @@
 /* The helper process writes a status report back to us, through a
  * pipe, consisting of two ints.
  */
 static gboolean
 read_helper_report (int      fd,
-            gintptr  report[2],
-            GError **error)
+        gintptr  report[2],
+        GError **error)
 {
   gint bytes = 0;
 
   while (bytes < sizeof(gintptr)*2)
     {
       gint chunk;
       int errsv;
 
       if (debug)
-    g_print ("%s:read_helper_report: read %" G_GSIZE_FORMAT "...\n",
-         __FILE__,
-         sizeof(gintptr)*2 - bytes);
+  g_print ("%s:read_helper_report: read %" G_GSIZE_FORMAT "...\n",
+     __FILE__,
+     sizeof(gintptr)*2 - bytes);
 
       chunk = read (fd, ((gchar*)report) + bytes,
-            sizeof(gintptr)*2 - bytes);
+        sizeof(gintptr)*2 - bytes);
       errsv = errno;
 
       if (debug)
-    g_print ("...got %d bytes\n", chunk);
+  g_print ("...got %d bytes\n", chunk);
 
       if (chunk < 0)
         {
           /* Some weird shit happened, bail out */
           g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
@@ -340,43 +351,43 @@
                        g_strerror (errsv));
 
           return FALSE;
         }
       else if (chunk == 0)
-    {
-      g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
-               _("Failed to read from child pipe (%s)"),
-               "EOF");
-      break; /* EOF */
-    }
+  {
+    g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
+           _("Failed to read from child pipe (%s)"),
+           "EOF");
+    break; /* EOF */
+  }
       else
-    bytes += chunk;
+  bytes += chunk;
     }
 
   if (bytes < sizeof(gintptr)*2)
     return FALSE;
 
   return TRUE;
 }
 
 static void
 set_child_error (gintptr      report[2],
-         const gchar *working_directory,
-         GError     **error)
+     const gchar *working_directory,
+     GError     **error)
 {
   switch (report[0])
     {
     case CHILD_CHDIR_FAILED:
       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR,
-           _("Failed to change to directory '%s' (%s)"),
-           working_directory,
-           g_strerror (report[1]));
+       _("Failed to change to directory '%s' (%s)"),
+       working_directory,
+       g_strerror (report[1]));
       break;
     case CHILD_SPAWN_FAILED:
       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
-           _("Failed to execute child process (%s)"),
-           g_strerror (report[1]));
+       _("Failed to execute child process (%s)"),
+       g_strerror (report[1]));
       break;
     case CHILD_SPAWN_NOENT:
       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT,
                    _("Failed to execute child process (%s)"),
                    g_strerror (report[1]));
@@ -386,54 +397,54 @@
     }
 }
 
 static gboolean
 utf8_charv_to_wcharv (char     **utf8_charv,
-              wchar_t ***wcharv,
-              int       *error_index,
-              GError   **error)
+          wchar_t ***wcharv,
+          int       *error_index,
+          GError   **error)
 {
   wchar_t **retval = NULL;
 
   *wcharv = NULL;
   if (utf8_charv != NULL)
     {
       int n = 0, i;
 
       while (utf8_charv[n])
-    n++;
+  n++;
       retval = g_new (wchar_t *, n + 1);
 
       for (i = 0; i < n; i++)
-    {
-      retval[i] = g_utf8_to_utf16 (utf8_charv[i], -1, NULL, NULL, error);
-      if (retval[i] == NULL)
-        {
-          if (error_index)
-        *error_index = i;
-          while (i)
-        g_free (retval[--i]);
-          g_free (retval);
-          return FALSE;
-        }
-    }
+  {
+    retval[i] = g_utf8_to_utf16 (utf8_charv[i], -1, NULL, NULL, error);
+    if (retval[i] == NULL)
+      {
+        if (error_index)
+    *error_index = i;
+        while (i)
+    g_free (retval[--i]);
+        g_free (retval);
+        return FALSE;
+      }
+  }
 
       retval[n] = NULL;
     }
   *wcharv = retval;
   return TRUE;
 }
 
 static gboolean
 do_spawn_directly (gint                 *exit_status,
-           gboolean      do_return_handle,
-                   GSpawnFlags           flags,
-                   gchar               **argv,
-                   char                **envp,
-                   char                **protected_argv,
-                   GPid                 *child_handle,
-                   GError              **error)
+       gboolean    do_return_handle,
+       GSpawnFlags           flags,
+       gchar               **argv,
+       char                **envp,
+       char                **protected_argv,
+       GPid                 *child_handle,
+       GError              **error)
 {
   const int mode = (exit_status == NULL) ? P_NOWAIT : P_WAIT;
   char **new_argv;
   gintptr rc = -1;
   int errsv;
@@ -445,33 +456,33 @@
 
   wargv0 = g_utf8_to_utf16 (argv[0], -1, NULL, NULL, &conv_error);
   if (wargv0 == NULL)
     {
       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
-           _("Invalid program name: %s"),
-           conv_error->message);
+       _("Invalid program name: %s"),
+       conv_error->message);
       g_error_free (conv_error);
 
       return FALSE;
     }
 
   if (!utf8_charv_to_wcharv (new_argv, &wargv, &conv_error_index, &conv_error))
     {
       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
-           _("Invalid string in argument vector at %d: %s"),
-           conv_error_index, conv_error->message);
+       _("Invalid string in argument vector at %d: %s"),
+       conv_error_index, conv_error->message);
       g_error_free (conv_error);
       g_free (wargv0);
 
       return FALSE;
     }
 
   if (!utf8_charv_to_wcharv (envp, &wenvp, NULL, &conv_error))
     {
       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
-           _("Invalid string in environment: %s"),
-           conv_error->message);
+       _("Invalid string in environment: %s"),
+       conv_error->message);
       g_error_free (conv_error);
       g_free (wargv0);
       g_strfreev ((gchar **) wargv);
 
       return FALSE;
@@ -495,46 +506,46 @@
   g_strfreev ((gchar **) wenvp);
 
   if (rc == -1 && errsv != 0)
     {
       g_set_error (error, G_SPAWN_ERROR, _g_spawn_exec_err_to_g_error (errsv),
-                   _("Failed to execute child process (%s)"),
-           g_strerror (errsv));
+       _("Failed to execute child process (%s)"),
+       g_strerror (errsv));
       return FALSE;
     }
 
   if (exit_status == NULL)
     {
       if (child_handle && do_return_handle)
-    *child_handle = (GPid) rc;
+  *child_handle = (GPid) rc;
       else
-    {
-      CloseHandle ((HANDLE) rc);
-      if (child_handle)
-        *child_handle = 0;
-    }
+  {
+    CloseHandle ((HANDLE) rc);
+    if (child_handle)
+      *child_handle = 0;
+  }
     }
   else
     *exit_status = rc;
 
   return TRUE;
 }
 
 static gboolean
 do_spawn_with_fds (gint                 *exit_status,
-           gboolean        do_return_handle,
-                   const gchar          *working_directory,
-                   gchar               **argv,
-                   char                **envp,
-                   GSpawnFlags           flags,
-                   GSpawnChildSetupFunc  child_setup,
-                   GPid                 *child_handle,
-           gint                  stdin_fd,
-           gint                  stdout_fd,
-           gint                  stderr_fd,
-           gint       *err_report,
-                   GError              **error)
+       gboolean      do_return_handle,
+       const gchar          *working_directory,
+       gchar               **argv,
+       char                **envp,
+       GSpawnFlags           flags,
+       GSpawnChildSetupFunc  child_setup,
+       GPid                 *child_handle,
+       gint                  stdin_fd,
+       gint                  stdout_fd,
+       gint                  stderr_fd,
+       gint     *err_report,
+       GError              **error)
 {
   char **protected_argv;
   char args[ARG_COUNT][10];
   char **new_argv;
   int i;
@@ -566,13 +577,13 @@
       (working_directory == NULL || !*working_directory) &&
       (flags & G_SPAWN_LEAVE_DESCRIPTORS_OPEN))
     {
       /* We can do without the helper process */
       gboolean retval =
-    do_spawn_directly (exit_status, do_return_handle, flags,
-               argv, envp, protected_argv,
-               child_handle, error);
+  do_spawn_directly (exit_status, do_return_handle, flags,
+         argv, envp, protected_argv,
+         child_handle, error);
       g_strfreev (protected_argv);
       return retval;
     }
 
   if (!make_pipe (child_err_report_pipe, error))
@@ -604,11 +615,11 @@
   /* Make the read end of the child error report pipe
    * noninherited. Otherwise it will needlessly be inherited by the
    * helper process, and the started actual user process. As such that
    * shouldn't harm, but it is unnecessary.
    */
-  child_err_report_pipe[0] = dup_noninherited (child_err_report_pipe[0], _O_RDONLY);
+  child_err_report_pipe[0] = reopen_noninherited (child_err_report_pipe[0], _O_RDONLY);
 
   if (flags & G_SPAWN_FILE_AND_ARGV_ZERO)
     {
       /* Overload ARG_CHILD_ERR_REPORT to also encode the
        * G_SPAWN_FILE_AND_ARGV_ZERO functionality.
@@ -623,11 +634,11 @@
    * helper process will inherit it, and thus if this process happens
    * to crash before writing the sync byte to the pipe, the helper
    * process won't read but won't get any EOF either, as it has the
    * write end open itself.
    */
-  helper_sync_pipe[1] = dup_noninherited (helper_sync_pipe[1], _O_WRONLY);
+  helper_sync_pipe[1] = reopen_noninherited (helper_sync_pipe[1], _O_WRONLY);
 
   if (stdin_fd != -1)
     {
       _g_sprintf (args[ARG_STDIN], "%d", stdin_fd);
       new_argv[ARG_STDIN] = args[ARG_STDIN];
@@ -655,11 +666,11 @@
   else
     {
       new_argv[ARG_STDOUT] = "-";
     }
 
-  if (stdout_fd != -1)
+  if (stderr_fd != -1)
     {
       _g_sprintf (args[ARG_STDERR], "%d", stderr_fd);
       new_argv[ARG_STDERR] = args[ARG_STDERR];
     }
   else if (flags & G_SPAWN_STDERR_TO_DEV_NULL)
@@ -698,23 +709,23 @@
 
   if (debug)
     {
       g_print ("calling %s with argv:\n", helper_process);
       for (i = 0; i < argc + 1 + ARG_COUNT; i++)
-    g_print ("argv[%d]: %s\n", i, (new_argv[i] ? new_argv[i] : "NULL"));
+  g_print ("argv[%d]: %s\n", i, (new_argv[i] ? new_argv[i] : "NULL"));
     }
 
   if (!utf8_charv_to_wcharv (new_argv, &wargv, &conv_error_index, &conv_error))
     {
       if (conv_error_index == ARG_WORKING_DIRECTORY)
-    g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR,
-             _("Invalid working directory: %s"),
-             conv_error->message);
+  g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_CHDIR,
+         _("Invalid working directory: %s"),
+         conv_error->message);
       else
-    g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
-             _("Invalid string in argument vector at %d: %s"),
-             conv_error_index - ARG_PROGRAM, conv_error->message);
+  g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
+         _("Invalid string in argument vector at %d: %s"),
+         conv_error_index - ARG_PROGRAM, conv_error->message);
       g_error_free (conv_error);
       g_strfreev (protected_argv);
       g_free (new_argv[0]);
       g_free (new_argv[ARG_WORKING_DIRECTORY]);
       g_free (new_argv);
@@ -724,12 +735,12 @@
     }
 
   if (!utf8_charv_to_wcharv (envp, &wenvp, NULL, &conv_error))
     {
       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
-           _("Invalid string in environment: %s"),
-           conv_error->message);
+       _("Invalid string in environment: %s"),
+       conv_error->message);
       g_error_free (conv_error);
       g_strfreev (protected_argv);
       g_free (new_argv[0]);
       g_free (new_argv[ARG_WORKING_DIRECTORY]);
       g_free (new_argv);
@@ -767,12 +778,12 @@
 
   /* Check if gspawn-win32-helper couldn't be run */
   if (rc == -1 && errsv != 0)
     {
       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
-                   _("Failed to execute helper program (%s)"),
-           g_strerror (errsv));
+       _("Failed to execute helper program (%s)"),
+       g_strerror (errsv));
       goto cleanup_and_fail;
     }
 
   if (exit_status != NULL)
     {
@@ -787,44 +798,44 @@
     }
   else
     {
       /* Asynchronous case. We read the helper's report right away. */
       if (!read_helper_report (child_err_report_pipe[0], helper_report, error))
-    goto cleanup_and_fail;
+  goto cleanup_and_fail;
 
       close_and_invalidate (&child_err_report_pipe[0]);
 
       switch (helper_report[0])
+  {
+  case CHILD_NO_ERROR:
+    if (child_handle && do_return_handle)
+      {
+        /* rc is our HANDLE for gspawn-win32-helper. It has
+         * told us the HANDLE of its child. Duplicate that into
+         * a HANDLE valid in this process.
+         */
+        if (!DuplicateHandle ((HANDLE) rc, (HANDLE) helper_report[1],
+            GetCurrentProcess (), (LPHANDLE) child_handle,
+            0, TRUE, DUPLICATE_SAME_ACCESS))
     {
-    case CHILD_NO_ERROR:
-      if (child_handle && do_return_handle)
-        {
-          /* rc is our HANDLE for gspawn-win32-helper. It has
-           * told us the HANDLE of its child. Duplicate that into
-           * a HANDLE valid in this process.
-           */
-          if (!DuplicateHandle ((HANDLE) rc, (HANDLE) helper_report[1],
-                    GetCurrentProcess (), (LPHANDLE) child_handle,
-                    0, TRUE, DUPLICATE_SAME_ACCESS))
-        {
-          char *emsg = g_win32_error_message (GetLastError ());
-          g_print("%s\n", emsg);
-          *child_handle = 0;
-        }
-        }
-      else if (child_handle)
-        *child_handle = 0;
-      write (helper_sync_pipe[1], " ", 1);
-      close_and_invalidate (&helper_sync_pipe[1]);
-      break;
-
-    default:
-      write (helper_sync_pipe[1], " ", 1);
-      close_and_invalidate (&helper_sync_pipe[1]);
-      set_child_error (helper_report, working_directory, error);
-      goto cleanup_and_fail;
+      char *emsg = g_win32_error_message (GetLastError ());
+      g_print("%s\n", emsg);
+      *child_handle = 0;
     }
+      }
+    else if (child_handle)
+      *child_handle = 0;
+    write (helper_sync_pipe[1], " ", 1);
+    close_and_invalidate (&helper_sync_pipe[1]);
+    break;
+
+  default:
+    write (helper_sync_pipe[1], " ", 1);
+    close_and_invalidate (&helper_sync_pipe[1]);
+    set_child_error (helper_report, working_directory, error);
+    goto cleanup_and_fail;
+  }
     }
 
   /* Success against all odds! return the information */
 
   if (rc != -1)
@@ -848,22 +859,22 @@
   return FALSE;
 }
 
 static gboolean
 do_spawn_with_pipes (gint                 *exit_status,
-             gboolean          do_return_handle,
-             const gchar          *working_directory,
-             gchar               **argv,
-             char                **envp,
-             GSpawnFlags           flags,
-             GSpawnChildSetupFunc  child_setup,
-             GPid                 *child_handle,
-             gint                 *standard_input,
-             gint                 *standard_output,
-             gint                 *standard_error,
-             gint         *err_report,
-             GError              **error)
+         gboolean      do_return_handle,
+         const gchar          *working_directory,
+         gchar               **argv,
+         char                **envp,
+         GSpawnFlags           flags,
+         GSpawnChildSetupFunc  child_setup,
+         GPid                 *child_handle,
+         gint                 *standard_input,
+         gint                 *standard_output,
+         gint                 *standard_error,
+         gint     *err_report,
+         GError              **error)
 {
   int stdin_pipe[2] = { -1, -1 };
   int stdout_pipe[2] = { -1, -1 };
   int stderr_pipe[2] = { -1, -1 };
 
@@ -875,22 +886,22 @@
 
   if (standard_error && !make_pipe (stderr_pipe, error))
     goto cleanup_and_fail;
 
   if (!do_spawn_with_fds (exit_status,
-              do_return_handle,
-              working_directory,
-              argv,
-              envp,
-              flags,
-              child_setup,
-              child_handle,
-              stdin_pipe[0],
-              stdout_pipe[1],
-              stderr_pipe[1],
-              err_report,
-              error))
+        do_return_handle,
+        working_directory,
+        argv,
+        envp,
+        flags,
+        child_setup,
+        child_handle,
+        stdin_pipe[0],
+        stdout_pipe[1],
+        stderr_pipe[1],
+        err_report,
+        error))
     goto cleanup_and_fail;
 
   /* Close the other process's ends of the pipes in this process,
    * otherwise the reader will never get EOF.
    */
@@ -925,19 +936,19 @@
   return FALSE;
 }
 
 gboolean
 g_spawn_sync (const gchar          *working_directory,
-           gchar               **argv,
-           gchar               **envp,
-           GSpawnFlags           flags,
-           GSpawnChildSetupFunc  child_setup,
-           gpointer              user_data,
-           gchar               **standard_output,
-           gchar               **standard_error,
-           gint                 *exit_status,
-           GError              **error)
+              gchar               **argv,
+              gchar               **envp,
+              GSpawnFlags           flags,
+              GSpawnChildSetupFunc  child_setup,
+              gpointer              user_data,
+              gchar               **standard_output,
+              gchar               **standard_error,
+              gint                 *exit_status,
+              GError              **error)
 {
   gint outpipe = -1;
   gint errpipe = -1;
   gint reportpipe = -1;
   GIOChannel *outchannel = NULL;
@@ -968,22 +979,22 @@
 
   if (standard_error)
     *standard_error = NULL;
 
   if (!do_spawn_with_pipes (&status,
-                FALSE,
-                working_directory,
-                argv,
-                envp,
-                flags,
-                child_setup,
-                NULL,
-                NULL,
-                standard_output ? &outpipe : NULL,
-                standard_error ? &errpipe : NULL,
-                &reportpipe,
-                error))
+          FALSE,
+          working_directory,
+          argv,
+          envp,
+          flags,
+          child_setup,
+          NULL,
+          NULL,
+          standard_output ? &outpipe : NULL,
+          standard_error ? &errpipe : NULL,
+          &reportpipe,
+          error))
     return FALSE;
 
   /* Read data from child. */
 
   failed = FALSE;
@@ -993,49 +1004,49 @@
       outstr = g_string_new (NULL);
       outchannel = g_io_channel_win32_new_fd (outpipe);
       g_io_channel_set_encoding (outchannel, NULL, NULL);
       g_io_channel_set_buffered (outchannel, FALSE);
       g_io_channel_win32_make_pollfd (outchannel,
-                      G_IO_IN | G_IO_ERR | G_IO_HUP,
-                      &outfd);
+              G_IO_IN | G_IO_ERR | G_IO_HUP,
+              &outfd);
       if (debug)
-    g_print ("outfd=%p\n", (HANDLE) outfd.fd);
+  g_print ("outfd=%p\n", (HANDLE) outfd.fd);
     }
 
   if (errpipe >= 0)
     {
       errstr = g_string_new (NULL);
       errchannel = g_io_channel_win32_new_fd (errpipe);
       g_io_channel_set_encoding (errchannel, NULL, NULL);
       g_io_channel_set_buffered (errchannel, FALSE);
       g_io_channel_win32_make_pollfd (errchannel,
-                      G_IO_IN | G_IO_ERR | G_IO_HUP,
-                      &errfd);
+              G_IO_IN | G_IO_ERR | G_IO_HUP,
+              &errfd);
       if (debug)
-    g_print ("errfd=%p\n", (HANDLE) errfd.fd);
+  g_print ("errfd=%p\n", (HANDLE) errfd.fd);
     }
 
   /* Read data until we get EOF on all pipes. */
   while (!failed && (outpipe >= 0 || errpipe >= 0))
     {
       nfds = 0;
       if (outpipe >= 0)
-    {
-      fds[nfds] = outfd;
-      outindex = nfds;
-      nfds++;
-    }
+  {
+    fds[nfds] = outfd;
+    outindex = nfds;
+    nfds++;
+  }
       if (errpipe >= 0)
-    {
-      fds[nfds] = errfd;
-      errindex = nfds;
-      nfds++;
-    }
+  {
+    fds[nfds] = errfd;
+    errindex = nfds;
+    nfds++;
+  }
 
       if (debug)
-    g_print ("g_spawn_sync: calling g_io_channel_win32_poll, nfds=%d\n",
-         nfds);
+  g_print ("g_spawn_sync: calling g_io_channel_win32_poll, nfds=%d\n",
+     nfds);
 
       ret = g_io_channel_win32_poll (fds, nfds, -1);
 
       if (ret < 0)
         {
@@ -1050,24 +1061,24 @@
       if (outpipe >= 0 && (fds[outindex].revents & G_IO_IN))
         {
           switch (read_data (outstr, outchannel, error))
             {
             case READ_FAILED:
-          if (debug)
-        g_print ("g_spawn_sync: outchannel: READ_FAILED\n");
+        if (debug)
+    g_print ("g_spawn_sync: outchannel: READ_FAILED\n");
               failed = TRUE;
               break;
             case READ_EOF:
-          if (debug)
-        g_print ("g_spawn_sync: outchannel: READ_EOF\n");
+        if (debug)
+    g_print ("g_spawn_sync: outchannel: READ_EOF\n");
               g_io_channel_unref (outchannel);
-          outchannel = NULL;
+        outchannel = NULL;
               close_and_invalidate (&outpipe);
               break;
             default:
-          if (debug)
-        g_print ("g_spawn_sync: outchannel: OK\n");
+        if (debug)
+    g_print ("g_spawn_sync: outchannel: OK\n");
               break;
             }
 
           if (failed)
             break;
@@ -1076,24 +1087,24 @@
       if (errpipe >= 0 && (fds[errindex].revents & G_IO_IN))
         {
           switch (read_data (errstr, errchannel, error))
             {
             case READ_FAILED:
-          if (debug)
-        g_print ("g_spawn_sync: errchannel: READ_FAILED\n");
+        if (debug)
+    g_print ("g_spawn_sync: errchannel: READ_FAILED\n");
               failed = TRUE;
               break;
             case READ_EOF:
-          if (debug)
-        g_print ("g_spawn_sync: errchannel: READ_EOF\n");
-          g_io_channel_unref (errchannel);
-          errchannel = NULL;
+        if (debug)
+    g_print ("g_spawn_sync: errchannel: READ_EOF\n");
+        g_io_channel_unref (errchannel);
+        errchannel = NULL;
               close_and_invalidate (&errpipe);
               break;
             default:
-          if (debug)
-        g_print ("g_spawn_sync: errchannel: OK\n");
+        if (debug)
+    g_print ("g_spawn_sync: errchannel: OK\n");
               break;
             }
 
           if (failed)
             break;
@@ -1114,25 +1125,25 @@
        * grandchild has finished.
        */
       gintptr helper_report[2];
 
       if (!read_helper_report (reportpipe, helper_report, error))
-    failed = TRUE;
+  failed = TRUE;
       else
-    {
-      switch (helper_report[0])
-        {
-        case CHILD_NO_ERROR:
-          if (exit_status)
-        *exit_status = helper_report[1];
-          break;
-        default:
-          set_child_error (helper_report, working_directory, error);
-          failed = TRUE;
-          break;
-        }
-    }
+  {
+    switch (helper_report[0])
+      {
+      case CHILD_NO_ERROR:
+        if (exit_status)
+    *exit_status = helper_report[1];
+        break;
+      default:
+        set_child_error (helper_report, working_directory, error);
+        failed = TRUE;
+        break;
+      }
+  }
       close_and_invalidate (&reportpipe);
     }
 
 
   /* These should only be open still if we had an error.  */
@@ -1167,20 +1178,20 @@
     }
 }
 
 gboolean
 g_spawn_async_with_pipes (const gchar          *working_directory,
-                   gchar               **argv,
-                   gchar               **envp,
-                   GSpawnFlags           flags,
-                   GSpawnChildSetupFunc  child_setup,
-                   gpointer              user_data,
-                   GPid                 *child_handle,
-                   gint                 *standard_input,
-                   gint                 *standard_output,
-                   gint                 *standard_error,
-                   GError              **error)
+                          gchar               **argv,
+                          gchar               **envp,
+                          GSpawnFlags           flags,
+                          GSpawnChildSetupFunc  child_setup,
+                          gpointer              user_data,
+                          GPid                 *child_handle,
+                          gint                 *standard_input,
+                          gint                 *standard_output,
+                          gint                 *standard_error,
+                          GError              **error)
 {
   g_return_val_if_fail (argv != NULL, FALSE);
   g_return_val_if_fail (standard_output == NULL ||
                         !(flags & G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
   g_return_val_if_fail (standard_error == NULL ||
@@ -1188,22 +1199,22 @@
   /* can't inherit stdin if we have an input pipe. */
   g_return_val_if_fail (standard_input == NULL ||
                         !(flags & G_SPAWN_CHILD_INHERITS_STDIN), FALSE);
 
   return do_spawn_with_pipes (NULL,
-                  (flags & G_SPAWN_DO_NOT_REAP_CHILD),
-                  working_directory,
-                  argv,
-                  envp,
-                  flags,
-                  child_setup,
-                  child_handle,
-                  standard_input,
-                  standard_output,
-                  standard_error,
-                  NULL,
-                  error);
+            (flags & G_SPAWN_DO_NOT_REAP_CHILD),
+            working_directory,
+            argv,
+            envp,
+            flags,
+            child_setup,
+            child_handle,
+            standard_input,
+            standard_output,
+            standard_error,
+            NULL,
+            error);
 }
 
 gboolean
 g_spawn_async_with_fds (const gchar          *working_directory,
                         gchar               **argv,
@@ -1225,30 +1236,30 @@
   /* can't inherit stdin if we have an input pipe. */
   g_return_val_if_fail (stdin_fd == -1 ||
                         !(flags & G_SPAWN_CHILD_INHERITS_STDIN), FALSE);
 
   return do_spawn_with_fds (NULL,
-                (flags & G_SPAWN_DO_NOT_REAP_CHILD),
-                working_directory,
-                argv,
-                envp,
-                flags,
-                child_setup,
-                child_handle,
-                stdin_fd,
-                stdout_fd,
-                stderr_fd,
-                NULL,
-                error);
+          (flags & G_SPAWN_DO_NOT_REAP_CHILD),
+          working_directory,
+          argv,
+          envp,
+          flags,
+          child_setup,
+          child_handle,
+          stdin_fd,
+          stdout_fd,
+          stderr_fd,
+          NULL,
+          error);
 }
 
 gboolean
 g_spawn_command_line_sync (const gchar  *command_line,
-                gchar       **standard_output,
-                gchar       **standard_error,
-                gint         *exit_status,
-                GError      **error)
+                           gchar       **standard_output,
+                           gchar       **standard_error,
+                           gint         *exit_status,
+                           GError      **error)
 {
   gboolean retval;
   gchar **argv = 0;
 
   g_return_val_if_fail (command_line != NULL, FALSE);
@@ -1257,27 +1268,27 @@
                            NULL, &argv,
                            error))
     return FALSE;
 
   retval = g_spawn_sync (NULL,
-                  argv,
-                  NULL,
-                  G_SPAWN_SEARCH_PATH,
-                  NULL,
-                  NULL,
-                  standard_output,
-                  standard_error,
-                  exit_status,
-                  error);
+                         argv,
+                         NULL,
+                         G_SPAWN_SEARCH_PATH,
+                         NULL,
+                         NULL,
+                         standard_output,
+                         standard_error,
+                         exit_status,
+                         error);
   g_strfreev (argv);
 
   return retval;
 }
 
 gboolean
 g_spawn_command_line_async (const gchar *command_line,
-                 GError     **error)
+                            GError     **error)
 {
   gboolean retval;
   gchar **argv = 0;
 
   g_return_val_if_fail (command_line != NULL, FALSE);
@@ -1286,17 +1297,17 @@
                            NULL, &argv,
                            error))
     return FALSE;
 
   retval = g_spawn_async (NULL,
-                   argv,
-                   NULL,
-                   G_SPAWN_SEARCH_PATH,
-                   NULL,
-                   NULL,
-                   NULL,
-                   error);
+                          argv,
+                          NULL,
+                          G_SPAWN_SEARCH_PATH,
+                          NULL,
+                          NULL,
+                          NULL,
+                          error);
   g_strfreev (argv);
 
   return retval;
 }
 
@@ -1306,19 +1317,19 @@
     CloseHandle (pid);
 }
 
 gboolean
 g_spawn_check_exit_status (gint      exit_status,
-               GError  **error)
+         GError  **error)
 {
   gboolean ret = FALSE;
 
   if (exit_status != 0)
     {
       g_set_error (error, G_SPAWN_EXIT_ERROR, exit_status,
-           _("Child process exited with code %ld"),
-           (long) exit_status);
+       _("Child process exited with code %ld"),
+       (long) exit_status);
       goto out;
     }
 
   ret = TRUE;
  out:
@@ -1367,95 +1378,95 @@
 _GLIB_EXTERN gboolean g_spawn_command_line_async_utf8 (const gchar           *command_line,
                                                        GError               **error);
 
 gboolean
 g_spawn_async_utf8 (const gchar          *working_directory,
-                          gchar               **argv,
-                          gchar               **envp,
-                          GSpawnFlags           flags,
-                          GSpawnChildSetupFunc  child_setup,
-                          gpointer              user_data,
-                          GPid                 *child_handle,
-                          GError              **error)
+                    gchar               **argv,
+                    gchar               **envp,
+                    GSpawnFlags           flags,
+                    GSpawnChildSetupFunc  child_setup,
+                    gpointer              user_data,
+                    GPid                 *child_handle,
+                    GError              **error)
 {
   return g_spawn_async (working_directory,
                         argv,
                         envp,
                         flags,
                         child_setup,
                         user_data,
-                      child_handle,
-                      error);
+                        child_handle,
+                        error);
 }
 
 gboolean
 g_spawn_async_with_pipes_utf8 (const gchar          *working_directory,
-           gchar               **argv,
-           gchar               **envp,
-           GSpawnFlags           flags,
-           GSpawnChildSetupFunc  child_setup,
-           gpointer              user_data,
-           GPid                 *child_handle,
+                               gchar               **argv,
+                               gchar               **envp,
+                               GSpawnFlags           flags,
+                               GSpawnChildSetupFunc  child_setup,
+                               gpointer              user_data,
+                               GPid                 *child_handle,
                                gint                 *standard_input,
                                gint                 *standard_output,
                                gint                 *standard_error,
-           GError              **error)
+                               GError              **error)
 {
   return g_spawn_async_with_pipes (working_directory,
                                    argv,
                                    envp,
-                   flags,
-                   child_setup,
-                   user_data,
-                   child_handle,
+                                   flags,
+                                   child_setup,
+                                   user_data,
+                                   child_handle,
                                    standard_input,
                                    standard_output,
                                    standard_error,
-                   error);
+                                   error);
 }
 
 gboolean
 g_spawn_sync_utf8 (const gchar          *working_directory,
-          gchar               **argv,
-          gchar               **envp,
-          GSpawnFlags           flags,
-          GSpawnChildSetupFunc  child_setup,
-          gpointer              user_data,
-          gchar               **standard_output,
-          gchar               **standard_error,
-          gint                 *exit_status,
-          GError              **error)
+                   gchar               **argv,
+                   gchar               **envp,
+                   GSpawnFlags           flags,
+                   GSpawnChildSetupFunc  child_setup,
+                   gpointer              user_data,
+                   gchar               **standard_output,
+                   gchar               **standard_error,
+                   gint                 *exit_status,
+                   GError              **error)
 {
   return g_spawn_sync (working_directory,
                        argv,
                        envp,
                        flags,
                        child_setup,
                        user_data,
                        standard_output,
                        standard_error,
                        exit_status,
-                  error);
+                       error);
 }
 
 gboolean
 g_spawn_command_line_sync_utf8 (const gchar  *command_line,
-               gchar       **standard_output,
-               gchar       **standard_error,
-               gint         *exit_status,
-               GError      **error)
+                                gchar       **standard_output,
+                                gchar       **standard_error,
+                                gint         *exit_status,
+                                GError      **error)
 {
   return g_spawn_command_line_sync (command_line,
-                         standard_output,
-                         standard_error,
-                         exit_status,
-                         error);
+                                    standard_output,
+                                    standard_error,
+                                    exit_status,
+                                    error);
 }
 
 gboolean
 g_spawn_command_line_async_utf8 (const gchar *command_line,
-                GError     **error)
+                                 GError     **error)
 {
   return g_spawn_command_line_async (command_line, error);
 }
 
 #endif /* G_OS_WIN32 */
