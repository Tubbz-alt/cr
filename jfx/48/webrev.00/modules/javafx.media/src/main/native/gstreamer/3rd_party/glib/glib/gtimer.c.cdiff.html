<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gtimer.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gthreadprivate.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gtimer.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gtimer.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 214,11 ***</span>
   * Returns: seconds elapsed as a floating point value, including any
   *          fractional part.
   **/
  gdouble
  g_timer_elapsed (GTimer *timer,
<span class="line-modified">!          gulong *microseconds)</span>
  {
    gdouble total;
    gint64 elapsed;
  
    g_return_val_if_fail (timer != NULL, 0);
<span class="line-new-header">--- 214,11 ---</span>
   * Returns: seconds elapsed as a floating point value, including any
   *          fractional part.
   **/
  gdouble
  g_timer_elapsed (GTimer *timer,
<span class="line-modified">!      gulong *microseconds)</span>
  {
    gdouble total;
    gint64 elapsed;
  
    g_return_val_if_fail (timer != NULL, 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 234,10 ***</span>
<span class="line-new-header">--- 234,27 ---</span>
      *microseconds = elapsed % 1000000;
  
    return total;
  }
  
<span class="line-added">+ /**</span>
<span class="line-added">+  * g_timer_is_active:</span>
<span class="line-added">+  * @timer: a #GTimer.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Exposes whether the timer is currently active.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Returns: %TRUE if the timer is running, %FALSE otherwise</span>
<span class="line-added">+  * Since: 2.62</span>
<span class="line-added">+  **/</span>
<span class="line-added">+ gboolean</span>
<span class="line-added">+ g_timer_is_active (GTimer *timer)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   g_return_val_if_fail (timer != NULL, FALSE);</span>
<span class="line-added">+ </span>
<span class="line-added">+   return timer-&gt;active;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  /**
   * g_usleep:
   * @microseconds: number of microseconds to pause
   *
   * Pauses the current thread for the given number of microseconds.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 267,11 ***</span>
<span class="line-new-header">--- 284,15 ---</span>
   * @time_: a #GTimeVal
   * @microseconds: number of microseconds to add to @time
   *
   * Adds the given number of microseconds to @time_. @microseconds can
   * also be negative to decrease the value of @time_.
<span class="line-added">+  *</span>
<span class="line-added">+  * Deprecated: 2.62: #GTimeVal is not year-2038-safe. Use `guint64` for</span>
<span class="line-added">+  *    representing microseconds since the epoch, or use #GDateTime.</span>
   **/
<span class="line-added">+ G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
  void
  g_time_val_add (GTimeVal *time_, glong microseconds)
  {
    g_return_if_fail (time_-&gt;tv_usec &gt;= 0 &amp;&amp; time_-&gt;tv_usec &lt; G_USEC_PER_SEC);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 295,10 ***</span>
<span class="line-new-header">--- 316,11 ---</span>
           time_-&gt;tv_usec += G_USEC_PER_SEC;
           time_-&gt;tv_sec--;
         }
      }
  }
<span class="line-added">+ G_GNUC_END_IGNORE_DEPRECATIONS</span>
  
  /* converts a broken down date representation, relative to UTC,
   * to a timestamp; it uses timegm() if it&#39;s available.
   */
  static time_t
</pre>
<hr />
<pre>
<span class="line-old-header">*** 345,17 ***</span>
   * zone indicator. (In the absence of any time zone indication, the
   * timestamp is assumed to be in local time.)
   *
   * Any leading or trailing space in @iso_date is ignored.
   *
   * Returns: %TRUE if the conversion was successful.
   *
   * Since: 2.12
   */
  gboolean
  g_time_val_from_iso8601 (const gchar *iso_date,
<span class="line-modified">!              GTimeVal    *time_)</span>
  {
    struct tm tm = {0};
    long val;
    long mday, mon, year;
    long hour, min, sec;
<span class="line-new-header">--- 367,28 ---</span>
   * zone indicator. (In the absence of any time zone indication, the
   * timestamp is assumed to be in local time.)
   *
   * Any leading or trailing space in @iso_date is ignored.
   *
<span class="line-added">+  * This function was deprecated, along with #GTimeVal itself, in GLib 2.62.</span>
<span class="line-added">+  * Equivalent functionality is available using code like:</span>
<span class="line-added">+  * |[</span>
<span class="line-added">+  * GDateTime *dt = g_date_time_new_from_iso8601 (iso8601_string, NULL);</span>
<span class="line-added">+  * gint64 time_val = g_date_time_to_unix (dt);</span>
<span class="line-added">+  * g_date_time_unref (dt);</span>
<span class="line-added">+  * ]|</span>
<span class="line-added">+  *</span>
   * Returns: %TRUE if the conversion was successful.
   *
   * Since: 2.12
<span class="line-added">+  * Deprecated: 2.62: #GTimeVal is not year-2038-safe. Use</span>
<span class="line-added">+  *    g_date_time_new_from_iso8601() instead.</span>
   */
<span class="line-added">+ G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
  gboolean
  g_time_val_from_iso8601 (const gchar *iso_date,
<span class="line-modified">!        GTimeVal    *time_)</span>
  {
    struct tm tm = {0};
    long val;
    long mday, mon, year;
    long hour, min, sec;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 460,11 ***</span>
          {
            time_-&gt;tv_usec += (*iso_date - &#39;0&#39;) * mul;
            mul /= 10;
          }
  
<span class="line-modified">!       /* Skip any remaining digits after weâ€™ve reached our limit of precision. */</span>
        while (g_ascii_isdigit (*iso_date))
          iso_date++;
      }
  
    /* Now parse the offset and convert tm to a time_t */
<span class="line-new-header">--- 493,11 ---</span>
          {
            time_-&gt;tv_usec += (*iso_date - &#39;0&#39;) * mul;
            mul /= 10;
          }
  
<span class="line-modified">!       /* Skip any remaining digits after we&#39;ve reached our limit of precision. */</span>
        while (g_ascii_isdigit (*iso_date))
          iso_date++;
      }
  
    /* Now parse the offset and convert tm to a time_t */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 509,10 ***</span>
<span class="line-new-header">--- 542,11 ---</span>
    while (g_ascii_isspace (*iso_date))
      iso_date++;
  
    return *iso_date == &#39;\0&#39;;
  }
<span class="line-added">+ G_GNUC_END_IGNORE_DEPRECATIONS</span>
  
  /**
   * g_time_val_to_iso8601:
   * @time_: a #GTimeVal
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 538,20 ***</span>
   * variation of ISO 8601 format is required.
   *
   * If @time_ represents a date which is too large to fit into a `struct tm`,
   * %NULL will be returned. This is platform dependent. Note also that since
   * `GTimeVal` stores the number of seconds as a `glong`, on 32-bit systems it
<span class="line-modified">!  * is subject to the year 2038 problem.</span>
   *
   * The return value of g_time_val_to_iso8601() has been nullable since GLib
   * 2.54; before then, GLib would crash under the same conditions.
   *
   * Returns: (nullable): a newly allocated string containing an ISO 8601 date,
   *    or %NULL if @time_ was too large
   *
   * Since: 2.12
   */
  gchar *
  g_time_val_to_iso8601 (GTimeVal *time_)
  {
    gchar *retval;
    struct tm *tm;
<span class="line-new-header">--- 572,29 ---</span>
   * variation of ISO 8601 format is required.
   *
   * If @time_ represents a date which is too large to fit into a `struct tm`,
   * %NULL will be returned. This is platform dependent. Note also that since
   * `GTimeVal` stores the number of seconds as a `glong`, on 32-bit systems it
<span class="line-modified">!  * is subject to the year 2038 problem. Accordingly, since GLib 2.62, this</span>
<span class="line-added">+  * function has been deprecated. Equivalent functionality is available using:</span>
<span class="line-added">+  * |[</span>
<span class="line-added">+  * GDateTime *dt = g_date_time_new_from_unix_utc (time_val);</span>
<span class="line-added">+  * iso8601_string = g_date_time_format_iso8601 (dt);</span>
<span class="line-added">+  * g_date_time_unref (dt);</span>
<span class="line-added">+  * ]|</span>
   *
   * The return value of g_time_val_to_iso8601() has been nullable since GLib
   * 2.54; before then, GLib would crash under the same conditions.
   *
   * Returns: (nullable): a newly allocated string containing an ISO 8601 date,
   *    or %NULL if @time_ was too large
   *
   * Since: 2.12
<span class="line-added">+  * Deprecated: 2.62: #GTimeVal is not year-2038-safe. Use</span>
<span class="line-added">+  *    g_date_time_format_iso8601(dt) instead.</span>
   */
<span class="line-added">+ G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
  gchar *
  g_time_val_to_iso8601 (GTimeVal *time_)
  {
    gchar *retval;
    struct tm *tm;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 605,5 ***</span>
<span class="line-new-header">--- 648,6 ---</span>
                                  tm-&gt;tm_sec);
      }
  
    return retval;
  }
<span class="line-added">+ G_GNUC_END_IGNORE_DEPRECATIONS</span>
</pre>
<center><a href="gthreadprivate.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gtimer.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>