<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gunicollate.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gunicodeprivate.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gunidecomp.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gunicollate.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 18,11 ***</span>
  
  #include &quot;config.h&quot;
  
  #include &lt;locale.h&gt;
  #include &lt;string.h&gt;
<span class="line-modified">! #ifdef __STDC_ISO_10646__</span>
  #include &lt;wchar.h&gt;
  #endif
  
  #ifdef HAVE_CARBON
  #include &lt;CoreServices/CoreServices.h&gt;
<span class="line-new-header">--- 18,11 ---</span>
  
  #include &quot;config.h&quot;
  
  #include &lt;locale.h&gt;
  #include &lt;string.h&gt;
<span class="line-modified">! #ifdef HAVE_WCHAR_H</span>
  #include &lt;wchar.h&gt;
  #endif
  
  #ifdef HAVE_CARBON
  #include &lt;CoreServices/CoreServices.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 33,21 ***</span>
  #include &quot;gunicodeprivate.h&quot;
  #include &quot;gstring.h&quot;
  #include &quot;gstrfuncs.h&quot;
  #include &quot;gtestutils.h&quot;
  #include &quot;gcharset.h&quot;
<span class="line-removed">- #ifndef __STDC_ISO_10646__</span>
  #include &quot;gconvert.h&quot;
<span class="line-removed">- #endif</span>
  
  
  #ifdef _MSC_VER
  /* Workaround for bug in MSVCR80.DLL */
  static gsize
  msc_strxfrm_wrapper (char       *string1,
<span class="line-modified">!              const char *string2,</span>
<span class="line-modified">!              gsize       count)</span>
  {
    if (!string1 || count &lt;= 0)
      {
        char tmp;
  
<span class="line-new-header">--- 33,22 ---</span>
  #include &quot;gunicodeprivate.h&quot;
  #include &quot;gstring.h&quot;
  #include &quot;gstrfuncs.h&quot;
  #include &quot;gtestutils.h&quot;
  #include &quot;gcharset.h&quot;
  #include &quot;gconvert.h&quot;
  
<span class="line-added">+ #if SIZEOF_WCHAR_T == 4 &amp;&amp; defined(__STDC_ISO_10646__)</span>
<span class="line-added">+ #define GUNICHAR_EQUALS_WCHAR_T 1</span>
<span class="line-added">+ #endif</span>
  
  #ifdef _MSC_VER
  /* Workaround for bug in MSVCR80.DLL */
  static gsize
  msc_strxfrm_wrapper (char       *string1,
<span class="line-modified">!          const char *string2,</span>
<span class="line-modified">!          gsize       count)</span>
  {
    if (!string1 || count &lt;= 0)
      {
        char tmp;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 73,11 ***</span>
   * Returns: &lt; 0 if @str1 compares before @str2,
   *   0 if they compare equal, &gt; 0 if @str1 compares after @str2.
   **/
  gint
  g_utf8_collate (const gchar *str1,
<span class="line-modified">!         const gchar *str2)</span>
  {
    gint result;
  
  #ifdef HAVE_CARBON
  
<span class="line-new-header">--- 74,11 ---</span>
   * Returns: &lt; 0 if @str1 compares before @str2,
   *   0 if they compare equal, &gt; 0 if @str1 compares after @str2.
   **/
  gint
  g_utf8_collate (const gchar *str1,
<span class="line-modified">!     const gchar *str2)</span>
  {
    gint result;
  
  #ifdef HAVE_CARBON
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 99,11 ***</span>
    result = retval;
  
    g_free (str2_utf16);
    g_free (str1_utf16);
  
<span class="line-modified">! #elif defined(__STDC_ISO_10646__)</span>
  
    gunichar *str1_norm;
    gunichar *str2_norm;
  
    g_return_val_if_fail (str1 != NULL, 0);
<span class="line-new-header">--- 100,11 ---</span>
    result = retval;
  
    g_free (str2_utf16);
    g_free (str1_utf16);
  
<span class="line-modified">! #elif defined(HAVE_WCHAR_H) &amp;&amp; defined(GUNICHAR_EQUALS_WCHAR_T)</span>
  
    gunichar *str1_norm;
    gunichar *str2_norm;
  
    g_return_val_if_fail (str1 != NULL, 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 115,11 ***</span>
    result = wcscoll ((wchar_t *)str1_norm, (wchar_t *)str2_norm);
  
    g_free (str1_norm);
    g_free (str2_norm);
  
<span class="line-modified">! #else /* !__STDC_ISO_10646__ */</span>
  
    const gchar *charset;
    gchar *str1_norm;
    gchar *str2_norm;
  
<span class="line-new-header">--- 116,11 ---</span>
    result = wcscoll ((wchar_t *)str1_norm, (wchar_t *)str2_norm);
  
    g_free (str1_norm);
    g_free (str2_norm);
  
<span class="line-modified">! #else</span>
  
    const gchar *charset;
    gchar *str1_norm;
    gchar *str2_norm;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 137,31 ***</span>
      {
        gchar *str1_locale = g_convert (str1_norm, -1, charset, &quot;UTF-8&quot;, NULL, NULL, NULL);
        gchar *str2_locale = g_convert (str2_norm, -1, charset, &quot;UTF-8&quot;, NULL, NULL, NULL);
  
        if (str1_locale &amp;&amp; str2_locale)
<span class="line-modified">!     result =  strcoll (str1_locale, str2_locale);</span>
        else if (str1_locale)
<span class="line-modified">!     result = -1;</span>
        else if (str2_locale)
<span class="line-modified">!     result = 1;</span>
        else
<span class="line-modified">!     result = strcmp (str1_norm, str2_norm);</span>
  
        g_free (str1_locale);
        g_free (str2_locale);
      }
  
    g_free (str1_norm);
    g_free (str2_norm);
  
<span class="line-modified">! #endif /* __STDC_ISO_10646__ */</span>
  
    return result;
  }
  
<span class="line-modified">! #if defined(__STDC_ISO_10646__)</span>
  /* We need UTF-8 encoding of numbers to encode the weights if
   * we are using wcsxfrm. However, we aren&#39;t encoding Unicode
   * characters, so we can&#39;t simply use g_unichar_to_utf8.
   *
   * The following routine is taken (with modification) from GNU
<span class="line-new-header">--- 138,31 ---</span>
      {
        gchar *str1_locale = g_convert (str1_norm, -1, charset, &quot;UTF-8&quot;, NULL, NULL, NULL);
        gchar *str2_locale = g_convert (str2_norm, -1, charset, &quot;UTF-8&quot;, NULL, NULL, NULL);
  
        if (str1_locale &amp;&amp; str2_locale)
<span class="line-modified">!   result =  strcoll (str1_locale, str2_locale);</span>
        else if (str1_locale)
<span class="line-modified">!   result = -1;</span>
        else if (str2_locale)
<span class="line-modified">!   result = 1;</span>
        else
<span class="line-modified">!   result = strcmp (str1_norm, str2_norm);</span>
  
        g_free (str1_locale);
        g_free (str2_locale);
      }
  
    g_free (str1_norm);
    g_free (str2_norm);
  
<span class="line-modified">! #endif</span>
  
    return result;
  }
  
<span class="line-modified">! #if defined(HAVE_WCHAR_H) &amp;&amp; defined(GUNICHAR_EQUALS_WCHAR_T)</span>
  /* We need UTF-8 encoding of numbers to encode the weights if
   * we are using wcsxfrm. However, we aren&#39;t encoding Unicode
   * characters, so we can&#39;t simply use g_unichar_to_utf8.
   *
   * The following routine is taken (with modification) from GNU
</pre>
<hr />
<pre>
<span class="line-old-header">*** 176,11 ***</span>
    int retval;
  
    if (val &lt; 0x80)
      {
        if (buf)
<span class="line-modified">!     *buf++ = (char) val;</span>
        retval = 1;
      }
    else
      {
        int step;
<span class="line-new-header">--- 177,11 ---</span>
    int retval;
  
    if (val &lt; 0x80)
      {
        if (buf)
<span class="line-modified">!   *buf++ = (char) val;</span>
        retval = 1;
      }
    else
      {
        int step;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 189,26 ***</span>
          if ((val &amp; (~(guint32)0 &lt;&lt; (5 * step + 1))) == 0)
            break;
        retval = step;
  
        if (buf)
<span class="line-modified">!     {</span>
<span class="line-modified">!       *buf = (unsigned char) (~0xff &gt;&gt; step);</span>
<span class="line-modified">!       --step;</span>
<span class="line-modified">!       do</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           buf[step] = 0x80 | (val &amp; 0x3f);</span>
<span class="line-modified">!           val &gt;&gt;= 6;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       while (--step &gt; 0);</span>
<span class="line-modified">!       *buf |= val;</span>
<span class="line-modified">!     }</span>
      }
  
    return retval;
  }
<span class="line-modified">! #endif /* __STDC_ISO_10646__ */</span>
  
  #ifdef HAVE_CARBON
  
  static gchar *
  collate_key_to_string (UCCollationValue *key,
<span class="line-new-header">--- 190,26 ---</span>
          if ((val &amp; (~(guint32)0 &lt;&lt; (5 * step + 1))) == 0)
            break;
        retval = step;
  
        if (buf)
<span class="line-modified">!   {</span>
<span class="line-modified">!     *buf = (unsigned char) (~0xff &gt;&gt; step);</span>
<span class="line-modified">!     --step;</span>
<span class="line-modified">!     do</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         buf[step] = 0x80 | (val &amp; 0x3f);</span>
<span class="line-modified">!         val &gt;&gt;= 6;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     while (--step &gt; 0);</span>
<span class="line-modified">!     *buf |= val;</span>
<span class="line-modified">!   }</span>
      }
  
    return retval;
  }
<span class="line-modified">! #endif</span>
  
  #ifdef HAVE_CARBON
  
  static gchar *
  collate_key_to_string (UCCollationValue *key,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 371,20 ***</span>
   * Returns: a newly allocated string. This string should
   *   be freed with g_free() when you are done with it.
   **/
  gchar *
  g_utf8_collate_key (const gchar *str,
<span class="line-modified">!             gssize       len)</span>
  {
    gchar *result;
  
  #ifdef HAVE_CARBON
  
    g_return_val_if_fail (str != NULL, NULL);
    result = carbon_collate_key (str, len);
  
<span class="line-modified">! #elif defined(__STDC_ISO_10646__)</span>
  
    gsize xfrm_len;
    gunichar *str_norm;
    wchar_t *result_wc;
    gsize i;
<span class="line-new-header">--- 372,20 ---</span>
   * Returns: a newly allocated string. This string should
   *   be freed with g_free() when you are done with it.
   **/
  gchar *
  g_utf8_collate_key (const gchar *str,
<span class="line-modified">!         gssize       len)</span>
  {
    gchar *result;
  
  #ifdef HAVE_CARBON
  
    g_return_val_if_fail (str != NULL, NULL);
    result = carbon_collate_key (str, len);
  
<span class="line-modified">! #elif defined(HAVE_WCHAR_H) &amp;&amp; defined(GUNICHAR_EQUALS_WCHAR_T)</span>
  
    gsize xfrm_len;
    gunichar *str_norm;
    wchar_t *result_wc;
    gsize i;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 410,11 ***</span>
  
    g_free (result_wc);
    g_free (str_norm);
  
    return result;
<span class="line-modified">! #else /* !__STDC_ISO_10646__ */</span>
  
    gsize xfrm_len;
    const gchar *charset;
    gchar *str_norm;
  
<span class="line-new-header">--- 411,11 ---</span>
  
    g_free (result_wc);
    g_free (str_norm);
  
    return result;
<span class="line-modified">! #else</span>
  
    gsize xfrm_len;
    const gchar *charset;
    gchar *str_norm;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 436,26 ***</span>
    else
      {
        gchar *str_locale = g_convert (str_norm, -1, charset, &quot;UTF-8&quot;, NULL, NULL, NULL);
  
        if (str_locale)
<span class="line-modified">!     {</span>
<span class="line-modified">!       xfrm_len = strxfrm (NULL, str_locale, 0);</span>
<span class="line-modified">!       if (xfrm_len &lt; 0 || xfrm_len &gt;= G_MAXINT - 2)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           g_free (str_locale);</span>
<span class="line-modified">!           str_locale = NULL;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
        if (str_locale)
<span class="line-modified">!     {</span>
<span class="line-modified">!       result = g_malloc (xfrm_len + 2);</span>
<span class="line-modified">!       result[0] = &#39;A&#39;;</span>
<span class="line-modified">!       strxfrm (result + 1, str_locale, xfrm_len + 1);</span>
  
<span class="line-modified">!       g_free (str_locale);</span>
<span class="line-modified">!     }</span>
      }
  
    if (!result)
      {
        xfrm_len = strlen (str_norm);
<span class="line-new-header">--- 437,26 ---</span>
    else
      {
        gchar *str_locale = g_convert (str_norm, -1, charset, &quot;UTF-8&quot;, NULL, NULL, NULL);
  
        if (str_locale)
<span class="line-modified">!   {</span>
<span class="line-modified">!     xfrm_len = strxfrm (NULL, str_locale, 0);</span>
<span class="line-modified">!     if (xfrm_len &lt; 0 || xfrm_len &gt;= G_MAXINT - 2)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         g_free (str_locale);</span>
<span class="line-modified">!         str_locale = NULL;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!   }</span>
        if (str_locale)
<span class="line-modified">!   {</span>
<span class="line-modified">!     result = g_malloc (xfrm_len + 2);</span>
<span class="line-modified">!     result[0] = &#39;A&#39;;</span>
<span class="line-modified">!     strxfrm (result + 1, str_locale, xfrm_len + 1);</span>
  
<span class="line-modified">!     g_free (str_locale);</span>
<span class="line-modified">!   }</span>
      }
  
    if (!result)
      {
        xfrm_len = strlen (str_norm);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 464,11 ***</span>
        memcpy (result + 1, str_norm, xfrm_len);
        result[xfrm_len+1] = &#39;\0&#39;;
      }
  
    g_free (str_norm);
<span class="line-modified">! #endif /* __STDC_ISO_10646__ */</span>
  
    return result;
  }
  
  /* This is a collation key that is very very likely to sort before any
<span class="line-new-header">--- 465,11 ---</span>
        memcpy (result + 1, str_norm, xfrm_len);
        result[xfrm_len+1] = &#39;\0&#39;;
      }
  
    g_free (str_norm);
<span class="line-modified">! #endif</span>
  
    return result;
  }
  
  /* This is a collation key that is very very likely to sort before any
</pre>
<hr />
<pre>
<span class="line-old-header">*** 500,11 ***</span>
   *
   * Since: 2.8
   */
  gchar *
  g_utf8_collate_key_for_filename (const gchar *str,
<span class="line-modified">!                  gssize       len)</span>
  {
  #ifndef HAVE_CARBON
    GString *result;
    GString *append;
    const gchar *p;
<span class="line-new-header">--- 501,11 ---</span>
   *
   * Since: 2.8
   */
  gchar *
  g_utf8_collate_key_for_filename (const gchar *str,
<span class="line-modified">!          gssize       len)</span>
  {
  #ifndef HAVE_CARBON
    GString *result;
    GString *append;
    const gchar *p;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 570,101 ***</span>
  
    /* No need to use utf8 functions, since we&#39;re only looking for ascii chars */
    for (prev = p = str; p &lt; end; p++)
      {
        switch (*p)
<span class="line-modified">!     {</span>
<span class="line-modified">!     case &#39;.&#39;:</span>
<span class="line-modified">!       if (prev != p)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           collate_key = g_utf8_collate_key (prev, p - prev);</span>
<span class="line-modified">!           g_string_append (result, collate_key);</span>
<span class="line-modified">!           g_free (collate_key);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!       g_string_append (result, COLLATION_SENTINEL &quot;\1&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       /* skip the dot */</span>
<span class="line-modified">!       prev = p + 1;</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     case &#39;0&#39;:</span>
<span class="line-modified">!     case &#39;1&#39;:</span>
<span class="line-modified">!     case &#39;2&#39;:</span>
<span class="line-modified">!     case &#39;3&#39;:</span>
<span class="line-modified">!     case &#39;4&#39;:</span>
<span class="line-modified">!     case &#39;5&#39;:</span>
<span class="line-modified">!     case &#39;6&#39;:</span>
<span class="line-modified">!     case &#39;7&#39;:</span>
<span class="line-modified">!     case &#39;8&#39;:</span>
<span class="line-modified">!     case &#39;9&#39;:</span>
<span class="line-modified">!       if (prev != p)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           collate_key = g_utf8_collate_key (prev, p - prev);</span>
<span class="line-modified">!           g_string_append (result, collate_key);</span>
<span class="line-modified">!           g_free (collate_key);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!       g_string_append (result, COLLATION_SENTINEL &quot;\2&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       prev = p;</span>
<span class="line-modified">! </span>
<span class="line-modified">!       /* write d-1 colons */</span>
<span class="line-modified">!       if (*p == &#39;0&#39;)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           leading_zeros = 1;</span>
<span class="line-modified">!           digits = 0;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       else</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           leading_zeros = 0;</span>
<span class="line-modified">!           digits = 1;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">! </span>
<span class="line-modified">!       while (++p &lt; end)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           if (*p == &#39;0&#39; &amp;&amp; !digits)</span>
<span class="line-modified">!         ++leading_zeros;</span>
<span class="line-modified">!           else if (g_ascii_isdigit(*p))</span>
<span class="line-modified">!         ++digits;</span>
<span class="line-modified">!           else</span>
                  {
<span class="line-modified">!           /* count an all-zero sequence as</span>
                     * one digit plus leading zeros
                     */
                if (!digits)
                      {
                        ++digits;
                        --leading_zeros;
                      }
<span class="line-removed">-           break;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       while (digits &gt; 1)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           g_string_append_c (result, &#39;:&#39;);</span>
<span class="line-removed">-           --digits;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (leading_zeros &gt; 0)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           g_string_append_c (append, (char)leading_zeros);</span>
<span class="line-removed">-           prev += leading_zeros;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       /* write the number itself */</span>
<span class="line-removed">-       g_string_append_len (result, prev, p - prev);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       prev = p;</span>
<span class="line-removed">-       --p;    /* go one step back to avoid disturbing outer loop */</span>
<span class="line-removed">-       break;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-       /* other characters just accumulate */</span>
        break;
<span class="line-modified">!     }</span>
      }
  
    if (prev != p)
      {
        collate_key = g_utf8_collate_key (prev, p - prev);
<span class="line-new-header">--- 571,101 ---</span>
  
    /* No need to use utf8 functions, since we&#39;re only looking for ascii chars */
    for (prev = p = str; p &lt; end; p++)
      {
        switch (*p)
<span class="line-modified">!   {</span>
<span class="line-modified">!   case &#39;.&#39;:</span>
<span class="line-modified">!     if (prev != p)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         collate_key = g_utf8_collate_key (prev, p - prev);</span>
<span class="line-modified">!         g_string_append (result, collate_key);</span>
<span class="line-modified">!         g_free (collate_key);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     g_string_append (result, COLLATION_SENTINEL &quot;\1&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     /* skip the dot */</span>
<span class="line-modified">!     prev = p + 1;</span>
<span class="line-modified">!     break;</span>
<span class="line-modified">! </span>
<span class="line-modified">!   case &#39;0&#39;:</span>
<span class="line-modified">!   case &#39;1&#39;:</span>
<span class="line-modified">!   case &#39;2&#39;:</span>
<span class="line-modified">!   case &#39;3&#39;:</span>
<span class="line-modified">!   case &#39;4&#39;:</span>
<span class="line-modified">!   case &#39;5&#39;:</span>
<span class="line-modified">!   case &#39;6&#39;:</span>
<span class="line-modified">!   case &#39;7&#39;:</span>
<span class="line-modified">!   case &#39;8&#39;:</span>
<span class="line-modified">!   case &#39;9&#39;:</span>
<span class="line-modified">!     if (prev != p)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         collate_key = g_utf8_collate_key (prev, p - prev);</span>
<span class="line-modified">!         g_string_append (result, collate_key);</span>
<span class="line-modified">!         g_free (collate_key);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     g_string_append (result, COLLATION_SENTINEL &quot;\2&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     prev = p;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     /* write d-1 colons */</span>
<span class="line-modified">!     if (*p == &#39;0&#39;)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         leading_zeros = 1;</span>
<span class="line-modified">!         digits = 0;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         leading_zeros = 0;</span>
<span class="line-modified">!         digits = 1;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     while (++p &lt; end)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         if (*p == &#39;0&#39; &amp;&amp; !digits)</span>
<span class="line-modified">!     ++leading_zeros;</span>
<span class="line-modified">!         else if (g_ascii_isdigit(*p))</span>
<span class="line-modified">!     ++digits;</span>
<span class="line-modified">!         else</span>
                  {
<span class="line-modified">!       /* count an all-zero sequence as</span>
                     * one digit plus leading zeros
                     */
                if (!digits)
                      {
                        ++digits;
                        --leading_zeros;
                      }
        break;
<span class="line-modified">!                 }</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+     while (digits &gt; 1)</span>
<span class="line-added">+       {</span>
<span class="line-added">+         g_string_append_c (result, &#39;:&#39;);</span>
<span class="line-added">+         --digits;</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (leading_zeros &gt; 0)</span>
<span class="line-added">+       {</span>
<span class="line-added">+         g_string_append_c (append, (char)leading_zeros);</span>
<span class="line-added">+         prev += leading_zeros;</span>
<span class="line-added">+       }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* write the number itself */</span>
<span class="line-added">+     g_string_append_len (result, prev, p - prev);</span>
<span class="line-added">+ </span>
<span class="line-added">+     prev = p;</span>
<span class="line-added">+     --p;    /* go one step back to avoid disturbing outer loop */</span>
<span class="line-added">+     break;</span>
<span class="line-added">+ </span>
<span class="line-added">+   default:</span>
<span class="line-added">+     /* other characters just accumulate */</span>
<span class="line-added">+     break;</span>
<span class="line-added">+   }</span>
      }
  
    if (prev != p)
      {
        collate_key = g_utf8_collate_key (prev, p - prev);
</pre>
<center><a href="gunicodeprivate.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gunidecomp.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>