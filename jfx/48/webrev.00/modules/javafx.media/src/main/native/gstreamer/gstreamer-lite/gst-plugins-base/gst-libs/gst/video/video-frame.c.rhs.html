<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/video-frame.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* GStreamer
  2  * Copyright (C) &lt;1999&gt; Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
  3  * Library       &lt;2002&gt; Ronald Bultje &lt;rbultje@ronald.bitfreak.net&gt;
  4  * Copyright (C) 2007 David A. Schleef &lt;ds@schleef.org&gt;
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public
 17  * License along with this library; if not, write to the
 18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #ifdef HAVE_CONFIG_H
 23 #  include &quot;config.h&quot;
 24 #endif
 25 
 26 #include &lt;string.h&gt;
 27 #include &lt;stdio.h&gt;
 28 
 29 #include &lt;gst/video/video.h&gt;
 30 #include &quot;video-frame.h&quot;
 31 #include &quot;video-tile.h&quot;
 32 #include &quot;gstvideometa.h&quot;
 33 
 34 #define CAT_PERFORMANCE video_frame_get_perf_category()
 35 
 36 static inline GstDebugCategory *
 37 video_frame_get_perf_category (void)
 38 {
 39   static GstDebugCategory *cat = NULL;
 40 
 41   if (g_once_init_enter (&amp;cat)) {
 42     GstDebugCategory *c;
 43 
 44     GST_DEBUG_CATEGORY_GET (c, &quot;GST_PERFORMANCE&quot;);
 45     g_once_init_leave (&amp;cat, c);
 46   }
 47   return cat;
 48 }
 49 
 50 /**
 51  * gst_video_frame_map_id:
 52  * @frame: pointer to #GstVideoFrame
 53  * @info: a #GstVideoInfo
 54  * @buffer: the buffer to map
 55  * @id: the frame id to map
 56  * @flags: #GstMapFlags
 57  *
 58  * Use @info and @buffer to fill in the values of @frame with the video frame
 59  * information of frame @id.
 60  *
 61  * When @id is -1, the default frame is mapped. When @id != -1, this function
 62  * will return %FALSE when there is no GstVideoMeta with that id.
 63  *
 64  * All video planes of @buffer will be mapped and the pointers will be set in
 65  * @frame-&gt;data.
 66  *
 67  * Returns: %TRUE on success.
 68  */
 69 gboolean
 70 gst_video_frame_map_id (GstVideoFrame * frame, GstVideoInfo * info,
 71     GstBuffer * buffer, gint id, GstMapFlags flags)
 72 {
 73   GstVideoMeta *meta;
 74   gint i;
 75 
 76   g_return_val_if_fail (frame != NULL, FALSE);
 77   g_return_val_if_fail (info != NULL, FALSE);
<a name="1" id="anc1"></a><span class="line-added"> 78   g_return_val_if_fail (info-&gt;finfo != NULL, FALSE);</span>
 79   g_return_val_if_fail (GST_IS_BUFFER (buffer), FALSE);
 80 
 81   if (id == -1)
 82     meta = gst_buffer_get_video_meta (buffer);
 83   else
 84     meta = gst_buffer_get_video_meta_id (buffer, id);
 85 
 86   /* copy the info */
 87   frame-&gt;info = *info;
 88 
 89   if (meta) {
 90     /* All these values must be consistent */
 91     g_return_val_if_fail (info-&gt;finfo-&gt;format == meta-&gt;format, FALSE);
 92     g_return_val_if_fail (info-&gt;width &lt;= meta-&gt;width, FALSE);
 93     g_return_val_if_fail (info-&gt;height &lt;= meta-&gt;height, FALSE);
 94     g_return_val_if_fail (info-&gt;finfo-&gt;n_planes == meta-&gt;n_planes, FALSE);
 95 
 96     frame-&gt;info.finfo = gst_video_format_get_info (meta-&gt;format);
 97     frame-&gt;info.width = meta-&gt;width;
 98     frame-&gt;info.height = meta-&gt;height;
 99     frame-&gt;id = meta-&gt;id;
100     frame-&gt;flags = meta-&gt;flags;
101 
102     for (i = 0; i &lt; meta-&gt;n_planes; i++) {
103       frame-&gt;info.offset[i] = meta-&gt;offset[i];
104       if (!gst_video_meta_map (meta, i, &amp;frame-&gt;map[i], &amp;frame-&gt;data[i],
105               &amp;frame-&gt;info.stride[i], flags))
106         goto frame_map_failed;
107     }
108   } else {
109     /* no metadata, we really need to have the metadata when the id is
110      * specified. */
111     if (id != -1)
112       goto no_metadata;
113 
114     frame-&gt;id = id;
115     frame-&gt;flags = 0;
116 
117     if (!gst_buffer_map (buffer, &amp;frame-&gt;map[0], flags))
118       goto map_failed;
119 
120     /* do some sanity checks */
121     if (frame-&gt;map[0].size &lt; info-&gt;size)
122       goto invalid_size;
123 
124     /* set up pointers */
125     for (i = 0; i &lt; info-&gt;finfo-&gt;n_planes; i++) {
126       frame-&gt;data[i] = frame-&gt;map[0].data + info-&gt;offset[i];
127     }
128   }
129   frame-&gt;buffer = buffer;
130   if ((flags &amp; GST_VIDEO_FRAME_MAP_FLAG_NO_REF) == 0)
131     gst_buffer_ref (frame-&gt;buffer);
132 
133   frame-&gt;meta = meta;
134 
135   /* buffer flags enhance the frame flags */
136   if (GST_VIDEO_INFO_IS_INTERLACED (info)) {
137     if (GST_VIDEO_INFO_INTERLACE_MODE (info) == GST_VIDEO_INTERLACE_MODE_MIXED) {
138       if (GST_BUFFER_FLAG_IS_SET (buffer, GST_VIDEO_BUFFER_FLAG_INTERLACED)) {
139         frame-&gt;flags |= GST_VIDEO_FRAME_FLAG_INTERLACED;
140       }
<a name="2" id="anc2"></a><span class="line-modified">141     } else {</span>
142       frame-&gt;flags |= GST_VIDEO_FRAME_FLAG_INTERLACED;
<a name="3" id="anc3"></a><span class="line-added">143     }</span>
144 
<a name="4" id="anc4"></a><span class="line-modified">145     if (GST_VIDEO_INFO_FIELD_ORDER (info) ==</span>
<span class="line-added">146         GST_VIDEO_FIELD_ORDER_TOP_FIELD_FIRST) {</span>
147       frame-&gt;flags |= GST_VIDEO_FRAME_FLAG_TFF;
<a name="5" id="anc5"></a><span class="line-modified">148     } else {</span>
<span class="line-modified">149       if (GST_BUFFER_FLAG_IS_SET (buffer, GST_VIDEO_BUFFER_FLAG_TFF))</span>
<span class="line-modified">150         frame-&gt;flags |= GST_VIDEO_FRAME_FLAG_TFF;</span>
<span class="line-modified">151       if (GST_BUFFER_FLAG_IS_SET (buffer, GST_VIDEO_BUFFER_FLAG_RFF))</span>
<span class="line-added">152         frame-&gt;flags |= GST_VIDEO_FRAME_FLAG_RFF;</span>
<span class="line-added">153       if (GST_BUFFER_FLAG_IS_SET (buffer, GST_VIDEO_BUFFER_FLAG_ONEFIELD))</span>
<span class="line-added">154         frame-&gt;flags |= GST_VIDEO_FRAME_FLAG_ONEFIELD;</span>
<span class="line-added">155     }</span>
156   }
157   return TRUE;
158 
159   /* ERRORS */
160 no_metadata:
161   {
162     GST_ERROR (&quot;no GstVideoMeta for id %d&quot;, id);
163     memset (frame, 0, sizeof (GstVideoFrame));
164     return FALSE;
165   }
166 frame_map_failed:
167   {
168     GST_ERROR (&quot;failed to map video frame plane %d&quot;, i);
169     while (--i &gt;= 0)
170       gst_video_meta_unmap (meta, i, &amp;frame-&gt;map[i]);
171     memset (frame, 0, sizeof (GstVideoFrame));
172     return FALSE;
173   }
174 map_failed:
175   {
176     GST_ERROR (&quot;failed to map buffer&quot;);
177     return FALSE;
178   }
179 invalid_size:
180   {
181     GST_ERROR (&quot;invalid buffer size %&quot; G_GSIZE_FORMAT &quot; &lt; %&quot; G_GSIZE_FORMAT,
182         frame-&gt;map[0].size, info-&gt;size);
183     gst_buffer_unmap (buffer, &amp;frame-&gt;map[0]);
184     memset (frame, 0, sizeof (GstVideoFrame));
185     return FALSE;
186   }
187 }
188 
189 /**
190  * gst_video_frame_map:
191  * @frame: pointer to #GstVideoFrame
192  * @info: a #GstVideoInfo
193  * @buffer: the buffer to map
194  * @flags: #GstMapFlags
195  *
196  * Use @info and @buffer to fill in the values of @frame. @frame is usually
197  * allocated on the stack, and you will pass the address to the #GstVideoFrame
198  * structure allocated on the stack; gst_video_frame_map() will then fill in
199  * the structures with the various video-specific information you need to access
200  * the pixels of the video buffer. You can then use accessor macros such as
201  * GST_VIDEO_FRAME_COMP_DATA(), GST_VIDEO_FRAME_PLANE_DATA(),
202  * GST_VIDEO_FRAME_COMP_STRIDE(), GST_VIDEO_FRAME_PLANE_STRIDE() etc.
203  * to get to the pixels.
204  *
205  * |[&lt;!-- language=&quot;C&quot; --&gt;
206  *   GstVideoFrame vframe;
207  *   ...
208  *   // set RGB pixels to black one at a time
209  *   if (gst_video_frame_map (&amp;amp;vframe, video_info, video_buffer, GST_MAP_WRITE)) {
210  *     guint8 *pixels = GST_VIDEO_FRAME_PLANE_DATA (vframe, 0);
211  *     guint stride = GST_VIDEO_FRAME_PLANE_STRIDE (vframe, 0);
212  *     guint pixel_stride = GST_VIDEO_FRAME_COMP_PSTRIDE (vframe, 0);
213  *
214  *     for (h = 0; h &lt; height; ++h) {
215  *       for (w = 0; w &lt; width; ++w) {
216  *         guint8 *pixel = pixels + h * stride + w * pixel_stride;
217  *
218  *         memset (pixel, 0, pixel_stride);
219  *       }
220  *     }
221  *
222  *     gst_video_frame_unmap (&amp;amp;vframe);
223  *   }
224  *   ...
225  * ]|
226  *
227  * All video planes of @buffer will be mapped and the pointers will be set in
228  * @frame-&gt;data.
229  *
230  * The purpose of this function is to make it easy for you to get to the video
231  * pixels in a generic way, without you having to worry too much about details
232  * such as whether the video data is allocated in one contiguous memory chunk
233  * or multiple memory chunks (e.g. one for each plane); or if custom strides
234  * and custom plane offsets are used or not (as signalled by GstVideoMeta on
235  * each buffer). This function will just fill the #GstVideoFrame structure
236  * with the right values and if you use the accessor macros everything will
237  * just work and you can access the data easily. It also maps the underlying
238  * memory chunks for you.
239  *
240  * Returns: %TRUE on success.
241  */
242 gboolean
243 gst_video_frame_map (GstVideoFrame * frame, GstVideoInfo * info,
244     GstBuffer * buffer, GstMapFlags flags)
245 {
246   return gst_video_frame_map_id (frame, info, buffer, -1, flags);
247 }
248 
249 /**
250  * gst_video_frame_unmap:
251  * @frame: a #GstVideoFrame
252  *
253  * Unmap the memory previously mapped with gst_video_frame_map.
254  */
255 void
256 gst_video_frame_unmap (GstVideoFrame * frame)
257 {
258   GstBuffer *buffer;
259   GstVideoMeta *meta;
260   gint i;
261   GstMapFlags flags;
262 
263   g_return_if_fail (frame != NULL);
264 
265   buffer = frame-&gt;buffer;
266   meta = frame-&gt;meta;
267   flags = frame-&gt;map[0].flags;
268 
269   if (meta) {
270     for (i = 0; i &lt; frame-&gt;info.finfo-&gt;n_planes; i++) {
271       gst_video_meta_unmap (meta, i, &amp;frame-&gt;map[i]);
272     }
273   } else {
274     gst_buffer_unmap (buffer, &amp;frame-&gt;map[0]);
275   }
276 
277   if ((flags &amp; GST_VIDEO_FRAME_MAP_FLAG_NO_REF) == 0)
278     gst_buffer_unref (frame-&gt;buffer);
279 }
280 
281 /**
282  * gst_video_frame_copy_plane:
283  * @dest: a #GstVideoFrame
284  * @src: a #GstVideoFrame
285  * @plane: a plane
286  *
287  * Copy the plane with index @plane from @src to @dest.
288  *
289  * Returns: TRUE if the contents could be copied.
290  */
291 gboolean
292 gst_video_frame_copy_plane (GstVideoFrame * dest, const GstVideoFrame * src,
293     guint plane)
294 {
295   const GstVideoInfo *sinfo;
296   GstVideoInfo *dinfo;
297   const GstVideoFormatInfo *finfo;
298   guint8 *sp, *dp;
299   guint w, h;
300   gint ss, ds;
301 
302   g_return_val_if_fail (dest != NULL, FALSE);
303   g_return_val_if_fail (src != NULL, FALSE);
304 
305   sinfo = &amp;src-&gt;info;
306   dinfo = &amp;dest-&gt;info;
307 
308   g_return_val_if_fail (dinfo-&gt;finfo-&gt;format == sinfo-&gt;finfo-&gt;format, FALSE);
309 
310   finfo = dinfo-&gt;finfo;
311 
312   g_return_val_if_fail (dinfo-&gt;width == sinfo-&gt;width
313       &amp;&amp; dinfo-&gt;height == sinfo-&gt;height, FALSE);
314   g_return_val_if_fail (finfo-&gt;n_planes &gt; plane, FALSE);
315 
316   sp = src-&gt;data[plane];
317   dp = dest-&gt;data[plane];
318 
319   if (GST_VIDEO_FORMAT_INFO_HAS_PALETTE (finfo) &amp;&amp; plane == 1) {
320     /* copy the palette and we&#39;re done */
321     memcpy (dp, sp, 256 * 4);
322     return TRUE;
323   }
324 
325   /* FIXME: assumes subsampling of component N is the same as plane N, which is
326    * currently true for all formats we have but it might not be in the future. */
327   w = GST_VIDEO_FRAME_COMP_WIDTH (dest,
328       plane) * GST_VIDEO_FRAME_COMP_PSTRIDE (dest, plane);
329   /* FIXME: workaround for complex formats like v210, UYVP and IYU1 that have
330    * pstride == 0 */
331   if (w == 0)
332     w = MIN (GST_VIDEO_INFO_PLANE_STRIDE (dinfo, plane),
333         GST_VIDEO_INFO_PLANE_STRIDE (sinfo, plane));
334 
335   h = GST_VIDEO_FRAME_COMP_HEIGHT (dest, plane);
336 
337   ss = GST_VIDEO_INFO_PLANE_STRIDE (sinfo, plane);
338   ds = GST_VIDEO_INFO_PLANE_STRIDE (dinfo, plane);
339 
340   if (GST_VIDEO_FORMAT_INFO_IS_TILED (finfo)) {
341     gint tile_size;
342     gint sx_tiles, sy_tiles, dx_tiles, dy_tiles;
343     guint i, j, ws, hs, ts;
344     GstVideoTileMode mode;
345 
346     ws = GST_VIDEO_FORMAT_INFO_TILE_WS (finfo);
347     hs = GST_VIDEO_FORMAT_INFO_TILE_HS (finfo);
348     ts = ws + hs;
349 
350     tile_size = 1 &lt;&lt; ts;
351 
352     mode = GST_VIDEO_FORMAT_INFO_TILE_MODE (finfo);
353 
354     sx_tiles = GST_VIDEO_TILE_X_TILES (ss);
355     sy_tiles = GST_VIDEO_TILE_Y_TILES (ss);
356 
357     dx_tiles = GST_VIDEO_TILE_X_TILES (ds);
358     dy_tiles = GST_VIDEO_TILE_Y_TILES (ds);
359 
360     /* this is the amount of tiles to copy */
361     w = ((w - 1) &gt;&gt; ws) + 1;
362     h = ((h - 1) &gt;&gt; hs) + 1;
363 
364     /* FIXME can possibly do better when no retiling is needed, it depends on
365      * the stride and the tile_size */
366     for (j = 0; j &lt; h; j++) {
367       for (i = 0; i &lt; w; i++) {
368         guint si, di;
369 
370         si = gst_video_tile_get_index (mode, i, j, sx_tiles, sy_tiles);
371         di = gst_video_tile_get_index (mode, i, j, dx_tiles, dy_tiles);
372 
373         memcpy (dp + (di &lt;&lt; ts), sp + (si &lt;&lt; ts), tile_size);
374       }
375     }
376   } else {
377     guint j;
378 
379     GST_CAT_DEBUG (CAT_PERFORMANCE, &quot;copy plane %d, w:%d h:%d &quot;, plane, w, h);
380 
381     for (j = 0; j &lt; h; j++) {
382       memcpy (dp, sp, w);
383       dp += ds;
384       sp += ss;
385     }
386   }
387 
388   return TRUE;
389 }
390 
391 /**
392  * gst_video_frame_copy:
393  * @dest: a #GstVideoFrame
394  * @src: a #GstVideoFrame
395  *
396  * Copy the contents from @src to @dest.
397  *
398  * Returns: TRUE if the contents could be copied.
399  */
400 gboolean
401 gst_video_frame_copy (GstVideoFrame * dest, const GstVideoFrame * src)
402 {
403   guint i, n_planes;
404   const GstVideoInfo *sinfo;
405   GstVideoInfo *dinfo;
406 
407   g_return_val_if_fail (dest != NULL, FALSE);
408   g_return_val_if_fail (src != NULL, FALSE);
409 
410   sinfo = &amp;src-&gt;info;
411   dinfo = &amp;dest-&gt;info;
412 
413   g_return_val_if_fail (dinfo-&gt;finfo-&gt;format == sinfo-&gt;finfo-&gt;format, FALSE);
414   g_return_val_if_fail (dinfo-&gt;width == sinfo-&gt;width
415       &amp;&amp; dinfo-&gt;height == sinfo-&gt;height, FALSE);
416 
417   n_planes = dinfo-&gt;finfo-&gt;n_planes;
418 
419   for (i = 0; i &lt; n_planes; i++)
420     gst_video_frame_copy_plane (dest, src, i);
421 
422   return TRUE;
423 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>