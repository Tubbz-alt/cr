<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gbookmarkfile.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* gbookmarkfile.c: parsing and building desktop bookmarks
   2  *
   3  * Copyright (C) 2005-2006 Emmanuele Bassi
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public License
  16  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  */
  18 
  19 #include &quot;config.h&quot;
  20 
  21 #include &quot;gbookmarkfile.h&quot;
  22 
  23 #include &lt;stdio.h&gt;
  24 #include &lt;stdlib.h&gt;
  25 #include &lt;string.h&gt;
  26 #include &lt;errno.h&gt;
  27 #include &lt;fcntl.h&gt;
  28 #include &lt;locale.h&gt;
  29 #include &lt;time.h&gt;
  30 #include &lt;stdarg.h&gt;
  31 
  32 #include &quot;gconvert.h&quot;
  33 #include &quot;gdataset.h&quot;
  34 #include &quot;gerror.h&quot;
  35 #include &quot;gfileutils.h&quot;
  36 #include &quot;ghash.h&quot;
  37 #include &quot;glibintl.h&quot;
  38 #include &quot;glist.h&quot;
  39 #include &quot;gmain.h&quot;
  40 #include &quot;gmarkup.h&quot;
  41 #include &quot;gmem.h&quot;
  42 #include &quot;gmessages.h&quot;
  43 #include &quot;gshell.h&quot;
  44 #include &quot;gslice.h&quot;
  45 #include &quot;gstdio.h&quot;
  46 #include &quot;gstring.h&quot;
  47 #include &quot;gstrfuncs.h&quot;
  48 #include &quot;gtimer.h&quot;
  49 #include &quot;gutils.h&quot;
  50 
  51 
  52 /**
  53  * SECTION:bookmarkfile
  54  * @title: Bookmark file parser
  55  * @short_description: parses files containing bookmarks
  56  *
  57  * GBookmarkFile lets you parse, edit or create files containing bookmarks
  58  * to URI, along with some meta-data about the resource pointed by the URI
  59  * like its MIME type, the application that is registering the bookmark and
  60  * the icon that should be used to represent the bookmark. The data is stored
  61  * using the
  62  * [Desktop Bookmark Specification](http://www.gnome.org/~ebassi/bookmark-spec).
  63  *
  64  * The syntax of the bookmark files is described in detail inside the
  65  * Desktop Bookmark Specification, here is a quick summary: bookmark
  66  * files use a sub-class of the XML Bookmark Exchange Language
  67  * specification, consisting of valid UTF-8 encoded XML, under the
  68  * &lt;xbel&gt; root element; each bookmark is stored inside a
  69  * &lt;bookmark&gt; element, using its URI: no relative paths can
  70  * be used inside a bookmark file. The bookmark may have a user defined
  71  * title and description, to be used instead of the URI. Under the
  72  * &lt;metadata&gt; element, with its owner attribute set to
  73  * `http://freedesktop.org`, is stored the meta-data about a resource
  74  * pointed by its URI. The meta-data consists of the resource&#39;s MIME
  75  * type; the applications that have registered a bookmark; the groups
  76  * to which a bookmark belongs to; a visibility flag, used to set the
  77  * bookmark as &quot;private&quot; to the applications and groups that has it
  78  * registered; the URI and MIME type of an icon, to be used when
  79  * displaying the bookmark inside a GUI.
  80  *
  81  * Here is an example of a bookmark file:
  82  * [bookmarks.xbel](https://git.gnome.org/browse/glib/tree/glib/tests/bookmarks.xbel)
  83  *
  84  * A bookmark file might contain more than one bookmark; each bookmark
  85  * is accessed through its URI.
  86  *
  87  * The important caveat of bookmark files is that when you add a new
  88  * bookmark you must also add the application that is registering it, using
  89  * g_bookmark_file_add_application() or g_bookmark_file_set_app_info().
  90  * If a bookmark has no applications then it won&#39;t be dumped when creating
  91  * the on disk representation, using g_bookmark_file_to_data() or
  92  * g_bookmark_file_to_file().
  93  *
  94  * The #GBookmarkFile parser was added in GLib 2.12.
  95  */
  96 
  97 /* XBEL 1.0 standard entities */
  98 #define XBEL_VERSION    &quot;1.0&quot;
  99 #define XBEL_DTD_NICK   &quot;xbel&quot;
 100 #define XBEL_DTD_SYSTEM   &quot;+//IDN python.org//DTD XML Bookmark &quot; \
 101         &quot;Exchange Language 1.0//EN//XML&quot;
 102 
 103 #define XBEL_DTD_URI    &quot;http://www.python.org/topics/xml/dtds/xbel-1.0.dtd&quot;
 104 
 105 #define XBEL_ROOT_ELEMENT &quot;xbel&quot;
 106 #define XBEL_FOLDER_ELEMENT &quot;folder&quot;  /* unused */
 107 #define XBEL_BOOKMARK_ELEMENT &quot;bookmark&quot;
 108 #define XBEL_ALIAS_ELEMENT  &quot;alias&quot;   /* unused */
 109 #define XBEL_SEPARATOR_ELEMENT  &quot;separator&quot;   /* unused */
 110 #define XBEL_TITLE_ELEMENT  &quot;title&quot;
 111 #define XBEL_DESC_ELEMENT &quot;desc&quot;
 112 #define XBEL_INFO_ELEMENT &quot;info&quot;
 113 #define XBEL_METADATA_ELEMENT &quot;metadata&quot;
 114 
 115 #define XBEL_VERSION_ATTRIBUTE  &quot;version&quot;
 116 #define XBEL_FOLDED_ATTRIBUTE &quot;folded&quot;  /* unused */
 117 #define XBEL_OWNER_ATTRIBUTE  &quot;owner&quot;
 118 #define XBEL_ADDED_ATTRIBUTE  &quot;added&quot;
 119 #define XBEL_VISITED_ATTRIBUTE  &quot;visited&quot;
 120 #define XBEL_MODIFIED_ATTRIBUTE &quot;modified&quot;
 121 #define XBEL_ID_ATTRIBUTE &quot;id&quot;
 122 #define XBEL_HREF_ATTRIBUTE &quot;href&quot;
 123 #define XBEL_REF_ATTRIBUTE  &quot;ref&quot;     /* unused */
 124 
 125 #define XBEL_YES_VALUE    &quot;yes&quot;
 126 #define XBEL_NO_VALUE   &quot;no&quot;
 127 
 128 /* Desktop bookmark spec entities */
 129 #define BOOKMARK_METADATA_OWNER   &quot;http://freedesktop.org&quot;
 130 
 131 #define BOOKMARK_NAMESPACE_NAME   &quot;bookmark&quot;
 132 #define BOOKMARK_NAMESPACE_URI    &quot;http://www.freedesktop.org/standards/desktop-bookmarks&quot;
 133 
 134 #define BOOKMARK_GROUPS_ELEMENT   &quot;groups&quot;
 135 #define BOOKMARK_GROUP_ELEMENT    &quot;group&quot;
 136 #define BOOKMARK_APPLICATIONS_ELEMENT &quot;applications&quot;
 137 #define BOOKMARK_APPLICATION_ELEMENT  &quot;application&quot;
 138 #define BOOKMARK_ICON_ELEMENT     &quot;icon&quot;
 139 #define BOOKMARK_PRIVATE_ELEMENT  &quot;private&quot;
 140 
 141 #define BOOKMARK_NAME_ATTRIBUTE   &quot;name&quot;
 142 #define BOOKMARK_EXEC_ATTRIBUTE   &quot;exec&quot;
 143 #define BOOKMARK_COUNT_ATTRIBUTE  &quot;count&quot;
 144 #define BOOKMARK_TIMESTAMP_ATTRIBUTE  &quot;timestamp&quot;     /* deprecated by &quot;modified&quot; */
 145 #define BOOKMARK_MODIFIED_ATTRIBUTE     &quot;modified&quot;
 146 #define BOOKMARK_HREF_ATTRIBUTE   &quot;href&quot;
 147 #define BOOKMARK_TYPE_ATTRIBUTE   &quot;type&quot;
 148 
 149 /* Shared MIME Info entities */
 150 #define MIME_NAMESPACE_NAME     &quot;mime&quot;
 151 #define MIME_NAMESPACE_URI    &quot;http://www.freedesktop.org/standards/shared-mime-info&quot;
 152 #define MIME_TYPE_ELEMENT     &quot;mime-type&quot;
 153 #define MIME_TYPE_ATTRIBUTE     &quot;type&quot;
 154 
 155 
 156 typedef struct _BookmarkAppInfo  BookmarkAppInfo;
 157 typedef struct _BookmarkMetadata BookmarkMetadata;
 158 typedef struct _BookmarkItem     BookmarkItem;
 159 typedef struct _ParseData        ParseData;
 160 
 161 struct _BookmarkAppInfo
 162 {
 163   gchar *name;
 164   gchar *exec;
 165 
 166   guint count;
 167 
 168   time_t stamp;
 169 };
 170 
 171 struct _BookmarkMetadata
 172 {
 173   gchar *mime_type;
 174 
 175   GList *groups;
 176 
 177   GList *applications;
 178   GHashTable *apps_by_name;
 179 
 180   gchar *icon_href;
 181   gchar *icon_mime;
 182 
 183   guint is_private : 1;
 184 };
 185 
 186 struct _BookmarkItem
 187 {
 188   gchar *uri;
 189 
 190   gchar *title;
 191   gchar *description;
 192 
 193   time_t added;
 194   time_t modified;
 195   time_t visited;
 196 
 197   BookmarkMetadata *metadata;
 198 };
 199 
 200 struct _GBookmarkFile
 201 {
 202   gchar *title;
 203   gchar *description;
 204 
 205   /* we store our items in a list and keep a copy inside
 206    * a hash table for faster lookup performances
 207    */
 208   GList *items;
 209   GHashTable *items_by_uri;
 210 };
 211 
 212 /* parser state machine */
 213 typedef enum
 214 {
 215   STATE_STARTED        = 0,
 216 
 217   STATE_ROOT,
 218   STATE_BOOKMARK,
 219   STATE_TITLE,
 220   STATE_DESC,
 221   STATE_INFO,
 222   STATE_METADATA,
 223   STATE_APPLICATIONS,
 224   STATE_APPLICATION,
 225   STATE_GROUPS,
 226   STATE_GROUP,
 227   STATE_MIME,
 228   STATE_ICON,
 229 
 230   STATE_FINISHED
 231 } ParserState;
 232 
 233 static void          g_bookmark_file_init        (GBookmarkFile  *bookmark);
 234 static void          g_bookmark_file_clear       (GBookmarkFile  *bookmark);
 235 static gboolean      g_bookmark_file_parse       (GBookmarkFile  *bookmark,
 236               const gchar    *buffer,
 237               gsize           length,
 238               GError        **error);
 239 static gchar *       g_bookmark_file_dump        (GBookmarkFile  *bookmark,
 240               gsize          *length,
 241               GError        **error);
 242 static BookmarkItem *g_bookmark_file_lookup_item (GBookmarkFile  *bookmark,
 243               const gchar    *uri);
 244 static void          g_bookmark_file_add_item    (GBookmarkFile  *bookmark,
 245               BookmarkItem   *item,
 246               GError        **error);
 247 
 248 static gboolean  timestamp_from_iso8601 (const gchar  *iso_date,
 249                                          time_t       *out_timestamp,
 250                                          GError      **error);
 251 static gchar    *timestamp_to_iso8601   (time_t        timestamp);
 252 
 253 /********************************
 254  * BookmarkAppInfo              *
 255  *                              *
 256  * Application metadata storage *
 257  ********************************/
 258 static BookmarkAppInfo *
 259 bookmark_app_info_new (const gchar *name)
 260 {
 261   BookmarkAppInfo *retval;
 262 
 263   g_warn_if_fail (name != NULL);
 264 
 265   retval = g_slice_new (BookmarkAppInfo);
 266 #ifdef GSTREAMER_LITE
 267   if (retval == NULL) {
 268     return NULL;
 269   }
 270 #endif // GSTREAMER_LITE
 271 
 272   retval-&gt;name = g_strdup (name);
 273   retval-&gt;exec = NULL;
 274   retval-&gt;count = 0;
 275   retval-&gt;stamp = 0;
 276 
 277   return retval;
 278 }
 279 
 280 static void
 281 bookmark_app_info_free (BookmarkAppInfo *app_info)
 282 {
 283   if (!app_info)
 284     return;
 285 
 286   g_free (app_info-&gt;name);
 287   g_free (app_info-&gt;exec);
 288 
 289   g_slice_free (BookmarkAppInfo, app_info);
 290 }
 291 
 292 static gchar *
 293 bookmark_app_info_dump (BookmarkAppInfo *app_info)
 294 {
 295   gchar *retval;
 296   gchar *name, *exec, *modified, *count;
 297 
 298   g_warn_if_fail (app_info != NULL);
 299 
 300   if (app_info-&gt;count == 0)
 301     return NULL;
 302 
 303   name = g_markup_escape_text (app_info-&gt;name, -1);
 304   exec = g_markup_escape_text (app_info-&gt;exec, -1);
 305   modified = timestamp_to_iso8601 (app_info-&gt;stamp);
 306   count = g_strdup_printf (&quot;%u&quot;, app_info-&gt;count);
 307 
 308   retval = g_strconcat (&quot;          &quot;
 309                         &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME &quot;:&quot; BOOKMARK_APPLICATION_ELEMENT
 310                         &quot; &quot; BOOKMARK_NAME_ATTRIBUTE &quot;=\&quot;&quot;, name, &quot;\&quot;&quot;
 311                         &quot; &quot; BOOKMARK_EXEC_ATTRIBUTE &quot;=\&quot;&quot;, exec, &quot;\&quot;&quot;
 312                         &quot; &quot; BOOKMARK_MODIFIED_ATTRIBUTE &quot;=\&quot;&quot;, modified, &quot;\&quot;&quot;
 313                         &quot; &quot; BOOKMARK_COUNT_ATTRIBUTE &quot;=\&quot;&quot;, count, &quot;\&quot;/&gt;\n&quot;,
 314                         NULL);
 315 
 316   g_free (name);
 317   g_free (exec);
 318   g_free (modified);
 319   g_free (count);
 320 
 321   return retval;
 322 }
 323 
 324 
 325 /***********************
 326  * BookmarkMetadata    *
 327  *                     *
 328  * Metadata storage    *
 329  ***********************/
 330 static BookmarkMetadata *
 331 bookmark_metadata_new (void)
 332 {
 333   BookmarkMetadata *retval;
 334 
 335   retval = g_slice_new (BookmarkMetadata);
 336 #ifdef GSTREAMER_LITE
 337   if (retval == NULL) {
 338     return NULL;
 339   }
 340 #endif // GSTREAMER_LITE
 341 
 342   retval-&gt;mime_type = NULL;
 343 
 344   retval-&gt;groups = NULL;
 345 
 346   retval-&gt;applications = NULL;
 347   retval-&gt;apps_by_name = g_hash_table_new_full (g_str_hash,
 348                                                 g_str_equal,
 349                                                 NULL,
 350                                                 NULL);
 351 
 352   retval-&gt;is_private = FALSE;
 353 
 354   retval-&gt;icon_href = NULL;
 355   retval-&gt;icon_mime = NULL;
 356 
 357   return retval;
 358 }
 359 
 360 static void
 361 bookmark_metadata_free (BookmarkMetadata *metadata)
 362 {
 363   if (!metadata)
 364     return;
 365 
 366   g_free (metadata-&gt;mime_type);
 367 
 368   g_list_free_full (metadata-&gt;groups, g_free);
 369   g_list_free_full (metadata-&gt;applications, (GDestroyNotify) bookmark_app_info_free);
 370 
 371   g_hash_table_destroy (metadata-&gt;apps_by_name);
 372 
 373   g_free (metadata-&gt;icon_href);
 374   g_free (metadata-&gt;icon_mime);
 375 
 376   g_slice_free (BookmarkMetadata, metadata);
 377 }
 378 
 379 static gchar *
 380 bookmark_metadata_dump (BookmarkMetadata *metadata)
 381 {
 382   GString *retval;
 383   gchar *buffer;
 384 
 385   if (!metadata-&gt;applications)
 386     return NULL;
 387 
 388   retval = g_string_sized_new (1024);
 389 
 390   /* metadata container */
 391   g_string_append (retval,
 392        &quot;      &quot;
 393        &quot;&lt;&quot; XBEL_METADATA_ELEMENT
 394        &quot; &quot; XBEL_OWNER_ATTRIBUTE &quot;=\&quot;&quot; BOOKMARK_METADATA_OWNER
 395        &quot;\&quot;&gt;\n&quot;);
 396 
 397   /* mime type */
 398   if (metadata-&gt;mime_type) {
 399     buffer = g_strconcat (&quot;        &quot;
 400         &quot;&lt;&quot; MIME_NAMESPACE_NAME &quot;:&quot; MIME_TYPE_ELEMENT &quot; &quot;
 401         MIME_TYPE_ATTRIBUTE &quot;=\&quot;&quot;, metadata-&gt;mime_type, &quot;\&quot;/&gt;\n&quot;,
 402         NULL);
 403     g_string_append (retval, buffer);
 404     g_free (buffer);
 405   }
 406 
 407   if (metadata-&gt;groups)
 408     {
 409       GList *l;
 410 
 411       /* open groups container */
 412       g_string_append (retval,
 413            &quot;        &quot;
 414            &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME
 415            &quot;:&quot; BOOKMARK_GROUPS_ELEMENT &quot;&gt;\n&quot;);
 416 
 417       for (l = g_list_last (metadata-&gt;groups); l != NULL; l = l-&gt;prev)
 418         {
 419           gchar *group_name;
 420 
 421     group_name = g_markup_escape_text ((gchar *) l-&gt;data, -1);
 422     buffer = g_strconcat (&quot;          &quot;
 423         &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME
 424         &quot;:&quot; BOOKMARK_GROUP_ELEMENT &quot;&gt;&quot;,
 425         group_name,
 426         &quot;&lt;/&quot; BOOKMARK_NAMESPACE_NAME
 427         &quot;:&quot;  BOOKMARK_GROUP_ELEMENT &quot;&gt;\n&quot;, NULL);
 428     g_string_append (retval, buffer);
 429 
 430     g_free (buffer);
 431     g_free (group_name);
 432         }
 433 
 434       /* close groups container */
 435       g_string_append (retval,
 436            &quot;        &quot;
 437            &quot;&lt;/&quot; BOOKMARK_NAMESPACE_NAME
 438            &quot;:&quot; BOOKMARK_GROUPS_ELEMENT &quot;&gt;\n&quot;);
 439     }
 440 
 441   if (metadata-&gt;applications)
 442     {
 443       GList *l;
 444 
 445       /* open applications container */
 446       g_string_append (retval,
 447            &quot;        &quot;
 448            &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME
 449            &quot;:&quot; BOOKMARK_APPLICATIONS_ELEMENT &quot;&gt;\n&quot;);
 450 
 451       for (l = g_list_last (metadata-&gt;applications); l != NULL; l = l-&gt;prev)
 452         {
 453           BookmarkAppInfo *app_info = (BookmarkAppInfo *) l-&gt;data;
 454           gchar *app_data;
 455 
 456     g_warn_if_fail (app_info != NULL);
 457 
 458           app_data = bookmark_app_info_dump (app_info);
 459 
 460     if (app_data)
 461             {
 462               retval = g_string_append (retval, app_data);
 463 
 464         g_free (app_data);
 465       }
 466         }
 467 
 468       /* close applications container */
 469       g_string_append (retval,
 470            &quot;        &quot;
 471            &quot;&lt;/&quot; BOOKMARK_NAMESPACE_NAME
 472            &quot;:&quot; BOOKMARK_APPLICATIONS_ELEMENT &quot;&gt;\n&quot;);
 473     }
 474 
 475   /* icon */
 476   if (metadata-&gt;icon_href)
 477     {
 478       if (!metadata-&gt;icon_mime)
 479         metadata-&gt;icon_mime = g_strdup (&quot;application/octet-stream&quot;);
 480 
 481       buffer = g_strconcat (&quot;       &quot;
 482           &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME
 483           &quot;:&quot; BOOKMARK_ICON_ELEMENT
 484           &quot; &quot; BOOKMARK_HREF_ATTRIBUTE &quot;=\&quot;&quot;, metadata-&gt;icon_href,
 485           &quot;\&quot; &quot; BOOKMARK_TYPE_ATTRIBUTE &quot;=\&quot;&quot;, metadata-&gt;icon_mime, &quot;\&quot;/&gt;\n&quot;, NULL);
 486       g_string_append (retval, buffer);
 487 
 488       g_free (buffer);
 489     }
 490 
 491   /* private hint */
 492   if (metadata-&gt;is_private)
 493     g_string_append (retval,
 494          &quot;        &quot;
 495          &quot;&lt;&quot; BOOKMARK_NAMESPACE_NAME
 496          &quot;:&quot; BOOKMARK_PRIVATE_ELEMENT &quot;/&gt;\n&quot;);
 497 
 498   /* close metadata container */
 499   g_string_append (retval,
 500        &quot;      &quot;
 501        &quot;&lt;/&quot; XBEL_METADATA_ELEMENT &quot;&gt;\n&quot;);
 502 
 503   return g_string_free (retval, FALSE);
 504 }
 505 
 506 /******************************************************
 507  * BookmarkItem                                       *
 508  *                                                    *
 509  * Storage for a single bookmark item inside the list *
 510  ******************************************************/
 511 static BookmarkItem *
 512 bookmark_item_new (const gchar *uri)
 513 {
 514   BookmarkItem *item;
 515 
 516   g_warn_if_fail (uri != NULL);
 517 
 518   item = g_slice_new (BookmarkItem);
 519 #ifdef GSTREAMER_LITE
 520   if (item == NULL) {
 521     return NULL;
 522   }
 523 #endif // GSTREAMER_LITE
 524 
 525   item-&gt;uri = g_strdup (uri);
 526 
 527   item-&gt;title = NULL;
 528   item-&gt;description = NULL;
 529 
 530   item-&gt;added = (time_t) -1;
 531   item-&gt;modified = (time_t) -1;
 532   item-&gt;visited = (time_t) -1;
 533 
 534   item-&gt;metadata = NULL;
 535 
 536   return item;
 537 }
 538 
 539 static void
 540 bookmark_item_free (BookmarkItem *item)
 541 {
 542   if (!item)
 543     return;
 544 
 545   g_free (item-&gt;uri);
 546   g_free (item-&gt;title);
 547   g_free (item-&gt;description);
 548 
 549   if (item-&gt;metadata)
 550     bookmark_metadata_free (item-&gt;metadata);
 551 
 552   g_slice_free (BookmarkItem, item);
 553 }
 554 
 555 static gchar *
 556 bookmark_item_dump (BookmarkItem *item)
 557 {
 558   GString *retval;
 559   gchar *added, *visited, *modified;
 560   gchar *escaped_uri;
 561   gchar *buffer;
 562 
 563   /* at this point, we must have at least a registered application; if we don&#39;t
 564    * we don&#39;t screw up the bookmark file, and just skip this item
 565    */
 566   if (!item-&gt;metadata || !item-&gt;metadata-&gt;applications)
 567     {
 568       g_warning (&quot;Item for URI &#39;%s&#39; has no registered applications: skipping.&quot;, item-&gt;uri);
 569       return NULL;
 570     }
 571 
 572   retval = g_string_sized_new (4096);
 573 
 574   added = timestamp_to_iso8601 (item-&gt;added);
 575   modified = timestamp_to_iso8601 (item-&gt;modified);
 576   visited = timestamp_to_iso8601 (item-&gt;visited);
 577 
 578   escaped_uri = g_markup_escape_text (item-&gt;uri, -1);
 579 
 580   buffer = g_strconcat (&quot;  &lt;&quot;
 581                         XBEL_BOOKMARK_ELEMENT
 582                         &quot; &quot;
 583                         XBEL_HREF_ATTRIBUTE &quot;=\&quot;&quot;, escaped_uri, &quot;\&quot; &quot;
 584                         XBEL_ADDED_ATTRIBUTE &quot;=\&quot;&quot;, added, &quot;\&quot; &quot;
 585                         XBEL_MODIFIED_ATTRIBUTE &quot;=\&quot;&quot;, modified, &quot;\&quot; &quot;
 586                         XBEL_VISITED_ATTRIBUTE &quot;=\&quot;&quot;, visited, &quot;\&quot;&gt;\n&quot;,
 587                         NULL);
 588 
 589   g_string_append (retval, buffer);
 590 
 591   g_free (escaped_uri);
 592   g_free (visited);
 593   g_free (modified);
 594   g_free (added);
 595   g_free (buffer);
 596 
 597   if (item-&gt;title)
 598     {
 599       gchar *escaped_title;
 600 
 601       escaped_title = g_markup_escape_text (item-&gt;title, -1);
 602       buffer = g_strconcat (&quot;    &quot;
 603                             &quot;&lt;&quot; XBEL_TITLE_ELEMENT &quot;&gt;&quot;,
 604                             escaped_title,
 605                             &quot;&lt;/&quot; XBEL_TITLE_ELEMENT &quot;&gt;\n&quot;,
 606                             NULL);
 607       g_string_append (retval, buffer);
 608 
 609       g_free (escaped_title);
 610       g_free (buffer);
 611     }
 612 
 613   if (item-&gt;description)
 614     {
 615       gchar *escaped_desc;
 616 
 617       escaped_desc = g_markup_escape_text (item-&gt;description, -1);
 618       buffer = g_strconcat (&quot;    &quot;
 619                             &quot;&lt;&quot; XBEL_DESC_ELEMENT &quot;&gt;&quot;,
 620                             escaped_desc,
 621                             &quot;&lt;/&quot; XBEL_DESC_ELEMENT &quot;&gt;\n&quot;,
 622                             NULL);
 623       g_string_append (retval, buffer);
 624 
 625       g_free (escaped_desc);
 626       g_free (buffer);
 627     }
 628 
 629   if (item-&gt;metadata)
 630     {
 631       gchar *metadata;
 632 
 633       metadata = bookmark_metadata_dump (item-&gt;metadata);
 634       if (metadata)
 635         {
 636           buffer = g_strconcat (&quot;    &quot;
 637                                 &quot;&lt;&quot; XBEL_INFO_ELEMENT &quot;&gt;\n&quot;,
 638                                 metadata,
 639                                 &quot;    &quot;
 640         &quot;&lt;/&quot; XBEL_INFO_ELEMENT &quot;&gt;\n&quot;,
 641                                 NULL);
 642           retval = g_string_append (retval, buffer);
 643 
 644           g_free (buffer);
 645     g_free (metadata);
 646   }
 647     }
 648 
 649   g_string_append (retval, &quot;  &lt;/&quot; XBEL_BOOKMARK_ELEMENT &quot;&gt;\n&quot;);
 650 
 651   return g_string_free (retval, FALSE);
 652 }
 653 
 654 static BookmarkAppInfo *
 655 bookmark_item_lookup_app_info (BookmarkItem *item,
 656              const gchar  *app_name)
 657 {
 658   g_warn_if_fail (item != NULL &amp;&amp; app_name != NULL);
 659 
 660   if (!item-&gt;metadata)
 661     return NULL;
 662 
 663   return g_hash_table_lookup (item-&gt;metadata-&gt;apps_by_name, app_name);
 664 }
 665 
 666 /*************************
 667  *    GBookmarkFile    *
 668  *************************/
 669 
 670 static void
 671 g_bookmark_file_init (GBookmarkFile *bookmark)
 672 {
 673   bookmark-&gt;title = NULL;
 674   bookmark-&gt;description = NULL;
 675 
 676   bookmark-&gt;items = NULL;
 677   bookmark-&gt;items_by_uri = g_hash_table_new_full (g_str_hash,
 678                                                   g_str_equal,
 679                                                   NULL,
 680                                                   NULL);
 681 }
 682 
 683 static void
 684 g_bookmark_file_clear (GBookmarkFile *bookmark)
 685 {
 686   g_free (bookmark-&gt;title);
 687   g_free (bookmark-&gt;description);
 688 
 689   g_list_free_full (bookmark-&gt;items, (GDestroyNotify) bookmark_item_free);
 690   bookmark-&gt;items = NULL;
 691 
 692   if (bookmark-&gt;items_by_uri)
 693     {
 694       g_hash_table_destroy (bookmark-&gt;items_by_uri);
 695 
 696       bookmark-&gt;items_by_uri = NULL;
 697     }
 698 }
 699 
 700 struct _ParseData
 701 {
 702   ParserState state;
 703 
 704   GHashTable *namespaces;
 705 
 706   GBookmarkFile *bookmark_file;
 707   BookmarkItem *current_item;
 708 };
 709 
 710 static ParseData *
 711 parse_data_new (void)
 712 {
 713   ParseData *retval;
 714 
 715   retval = g_new (ParseData, 1);
 716 
 717   retval-&gt;state = STATE_STARTED;
 718   retval-&gt;namespaces = g_hash_table_new_full (g_str_hash, g_str_equal,
 719                   (GDestroyNotify) g_free,
 720                   (GDestroyNotify) g_free);
 721   retval-&gt;bookmark_file = NULL;
 722   retval-&gt;current_item = NULL;
 723 
 724   return retval;
 725 }
 726 
 727 static void
 728 parse_data_free (ParseData *parse_data)
 729 {
 730   g_hash_table_destroy (parse_data-&gt;namespaces);
 731 
 732   g_free (parse_data);
 733 }
 734 
 735 #define IS_ATTRIBUTE(s,a) ((0 == strcmp ((s), (a))))
 736 
 737 static void
 738 parse_bookmark_element (GMarkupParseContext  *context,
 739       ParseData            *parse_data,
 740       const gchar         **attribute_names,
 741       const gchar         **attribute_values,
 742       GError              **error)
 743 {
 744   const gchar *uri, *added, *modified, *visited;
 745   const gchar *attr;
 746   gint i;
 747   BookmarkItem *item;
 748   GError *add_error;
 749 
 750   g_warn_if_fail ((parse_data != NULL) &amp;&amp; (parse_data-&gt;state == STATE_BOOKMARK));
 751 
 752   i = 0;
 753   uri = added = modified = visited = NULL;
 754   for (attr = attribute_names[i]; attr != NULL; attr = attribute_names[++i])
 755     {
 756       if (IS_ATTRIBUTE (attr, XBEL_HREF_ATTRIBUTE))
 757         uri = attribute_values[i];
 758       else if (IS_ATTRIBUTE (attr, XBEL_ADDED_ATTRIBUTE))
 759         added = attribute_values[i];
 760       else if (IS_ATTRIBUTE (attr, XBEL_MODIFIED_ATTRIBUTE))
 761         modified = attribute_values[i];
 762       else if (IS_ATTRIBUTE (attr, XBEL_VISITED_ATTRIBUTE))
 763         visited = attribute_values[i];
 764       else
 765         {
 766           /* bookmark is defined by the XBEL spec, so we need
 767            * to error out if the element has different or
 768            * missing attributes
 769            */
 770           g_set_error (error, G_MARKUP_ERROR,
 771            G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE,
 772                    _(&quot;Unexpected attribute &#39;%s&#39; for element &#39;%s&#39;&quot;),
 773                    attr,
 774                    XBEL_BOOKMARK_ELEMENT);
 775           return;
 776         }
 777     }
 778 
 779   if (!uri)
 780     {
 781       g_set_error (error, G_MARKUP_ERROR,
 782              G_MARKUP_ERROR_INVALID_CONTENT,
 783              _(&quot;Attribute &#39;%s&#39; of element &#39;%s&#39; not found&quot;),
 784              XBEL_HREF_ATTRIBUTE,
 785              XBEL_BOOKMARK_ELEMENT);
 786       return;
 787     }
 788 
 789   g_warn_if_fail (parse_data-&gt;current_item == NULL);
 790 
 791   item = bookmark_item_new (uri);
 792 #ifdef GSTREAMER_LITE
 793   if (item == NULL) {
 794     return;
 795   }
 796 #endif // GSTREAMER_LITE
 797 
 798   if (added != NULL &amp;&amp; !timestamp_from_iso8601 (added, &amp;item-&gt;added, error))
 799     return;
 800 
 801   if (modified != NULL &amp;&amp; !timestamp_from_iso8601 (modified, &amp;item-&gt;modified, error))
 802     return;
 803 
 804   if (visited != NULL &amp;&amp; !timestamp_from_iso8601 (visited, &amp;item-&gt;visited, error))
 805     return;
 806 
 807   add_error = NULL;
 808   g_bookmark_file_add_item (parse_data-&gt;bookmark_file,
 809             item,
 810             &amp;add_error);
 811   if (add_error)
 812     {
 813       bookmark_item_free (item);
 814 
 815       g_propagate_error (error, add_error);
 816 
 817       return;
 818     }
 819 
 820   parse_data-&gt;current_item = item;
 821 }
 822 
 823 static void
 824 parse_application_element (GMarkupParseContext  *context,
 825          ParseData            *parse_data,
 826          const gchar         **attribute_names,
 827          const gchar         **attribute_values,
 828          GError              **error)
 829 {
 830   const gchar *name, *exec, *count, *stamp, *modified;
 831   const gchar *attr;
 832   gint i;
 833   BookmarkItem *item;
 834   BookmarkAppInfo *ai;
 835 
 836   g_warn_if_fail ((parse_data != NULL) &amp;&amp; (parse_data-&gt;state == STATE_APPLICATION));
 837 
 838   i = 0;
 839   name = exec = count = stamp = modified = NULL;
 840   for (attr = attribute_names[i]; attr != NULL; attr = attribute_names[++i])
 841     {
 842       if (IS_ATTRIBUTE (attr, BOOKMARK_NAME_ATTRIBUTE))
 843         name = attribute_values[i];
 844       else if (IS_ATTRIBUTE (attr, BOOKMARK_EXEC_ATTRIBUTE))
 845         exec = attribute_values[i];
 846       else if (IS_ATTRIBUTE (attr, BOOKMARK_COUNT_ATTRIBUTE))
 847         count = attribute_values[i];
 848       else if (IS_ATTRIBUTE (attr, BOOKMARK_TIMESTAMP_ATTRIBUTE))
 849         stamp = attribute_values[i];
 850       else if (IS_ATTRIBUTE (attr, BOOKMARK_MODIFIED_ATTRIBUTE))
 851         modified = attribute_values[i];
 852     }
 853 
 854   /* the &quot;name&quot; and &quot;exec&quot; attributes are mandatory */
 855   if (!name)
 856     {
 857       g_set_error (error, G_MARKUP_ERROR,
 858              G_MARKUP_ERROR_INVALID_CONTENT,
 859              _(&quot;Attribute &#39;%s&#39; of element &#39;%s&#39; not found&quot;),
 860              BOOKMARK_NAME_ATTRIBUTE,
 861              BOOKMARK_APPLICATION_ELEMENT);
 862       return;
 863     }
 864 
 865   if (!exec)
 866     {
 867       g_set_error (error, G_MARKUP_ERROR,
 868              G_MARKUP_ERROR_INVALID_CONTENT,
 869              _(&quot;Attribute &#39;%s&#39; of element &#39;%s&#39; not found&quot;),
 870              BOOKMARK_EXEC_ATTRIBUTE,
 871              BOOKMARK_APPLICATION_ELEMENT);
 872       return;
 873     }
 874 
 875   g_warn_if_fail (parse_data-&gt;current_item != NULL);
 876   item = parse_data-&gt;current_item;
 877 
 878   ai = bookmark_item_lookup_app_info (item, name);
 879   if (!ai)
 880     {
 881       ai = bookmark_app_info_new (name);
 882 #ifdef GSTREAMER_LITE
 883       if (ai == NULL) {
 884           g_set_error (error, G_MARKUP_ERROR,
 885                G_MARKUP_ERROR_INVALID_CONTENT,
 886                _(&quot;AI is NULL&quot;));
 887           return;
 888       }
 889 #endif // GSTREAMER_LITE
 890 
 891       if (!item-&gt;metadata)
 892   item-&gt;metadata = bookmark_metadata_new ();
 893 
 894       item-&gt;metadata-&gt;applications = g_list_prepend (item-&gt;metadata-&gt;applications, ai);
 895       g_hash_table_replace (item-&gt;metadata-&gt;apps_by_name, ai-&gt;name, ai);
 896     }
 897 
 898   g_free (ai-&gt;exec);
 899   ai-&gt;exec = g_strdup (exec);
 900 
 901   if (count)
 902     ai-&gt;count = atoi (count);
 903   else
 904     ai-&gt;count = 1;
 905 
 906   if (modified != NULL)
 907     {
 908       if (!timestamp_from_iso8601 (modified, &amp;ai-&gt;stamp, error))
 909         return;
 910     }
 911   else
 912     {
 913       /* the timestamp attribute has been deprecated but we still parse
 914        * it for backward compatibility
 915        */
 916       if (stamp)
 917         ai-&gt;stamp = (time_t) atol (stamp);
 918       else
 919         ai-&gt;stamp = time (NULL);
 920     }
 921 }
 922 
 923 static void
 924 parse_mime_type_element (GMarkupParseContext  *context,
 925        ParseData            *parse_data,
 926        const gchar         **attribute_names,
 927        const gchar         **attribute_values,
 928        GError              **error)
 929 {
 930   const gchar *type;
 931   const gchar *attr;
 932   gint i;
 933   BookmarkItem *item;
 934 
 935   g_warn_if_fail ((parse_data != NULL) &amp;&amp; (parse_data-&gt;state == STATE_MIME));
 936 
 937   i = 0;
 938   type = NULL;
 939   for (attr = attribute_names[i]; attr != NULL; attr = attribute_names[++i])
 940     {
 941       if (IS_ATTRIBUTE (attr, MIME_TYPE_ATTRIBUTE))
 942         type = attribute_values[i];
 943     }
 944 
 945   if (!type)
 946     type = &quot;application/octet-stream&quot;;
 947 
 948   g_warn_if_fail (parse_data-&gt;current_item != NULL);
 949   item = parse_data-&gt;current_item;
 950 
 951   if (!item-&gt;metadata)
 952     item-&gt;metadata = bookmark_metadata_new ();
 953 
 954   g_free (item-&gt;metadata-&gt;mime_type);
 955   item-&gt;metadata-&gt;mime_type = g_strdup (type);
 956 }
 957 
 958 static void
 959 parse_icon_element (GMarkupParseContext  *context,
 960         ParseData            *parse_data,
 961         const gchar         **attribute_names,
 962         const gchar         **attribute_values,
 963         GError              **error)
 964 {
 965   const gchar *href;
 966   const gchar *type;
 967   const gchar *attr;
 968   gint i;
 969   BookmarkItem *item;
 970 
 971   g_warn_if_fail ((parse_data != NULL) &amp;&amp; (parse_data-&gt;state == STATE_ICON));
 972 
 973   i = 0;
 974   href = NULL;
 975   type = NULL;
 976   for (attr = attribute_names[i]; attr != NULL; attr = attribute_names[++i])
 977     {
 978       if (IS_ATTRIBUTE (attr, BOOKMARK_HREF_ATTRIBUTE))
 979         href = attribute_values[i];
 980       else if (IS_ATTRIBUTE (attr, BOOKMARK_TYPE_ATTRIBUTE))
 981         type = attribute_values[i];
 982     }
 983 
 984   /* the &quot;href&quot; attribute is mandatory */
 985   if (!href)
 986     {
 987       g_set_error (error, G_MARKUP_ERROR,
 988              G_MARKUP_ERROR_INVALID_CONTENT,
 989              _(&quot;Attribute &#39;%s&#39; of element &#39;%s&#39; not found&quot;),
 990              BOOKMARK_HREF_ATTRIBUTE,
 991              BOOKMARK_ICON_ELEMENT);
 992       return;
 993     }
 994 
 995   if (!type)
 996     type = &quot;application/octet-stream&quot;;
 997 
 998   g_warn_if_fail (parse_data-&gt;current_item != NULL);
 999   item = parse_data-&gt;current_item;
1000 
1001   if (!item-&gt;metadata)
1002     item-&gt;metadata = bookmark_metadata_new ();
1003 
1004   g_free (item-&gt;metadata-&gt;icon_href);
1005   g_free (item-&gt;metadata-&gt;icon_mime);
1006   item-&gt;metadata-&gt;icon_href = g_strdup (href);
1007   item-&gt;metadata-&gt;icon_mime = g_strdup (type);
1008 }
1009 
1010 /* scans through the attributes of an element for the &quot;xmlns&quot; pragma, and
1011  * adds any resulting namespace declaration to a per-parser hashtable, using
1012  * the namespace name as a key for the namespace URI; if no key was found,
1013  * the namespace is considered as default, and stored under the &quot;default&quot; key.
1014  *
1015  * FIXME: this works on the assumption that the generator of the XBEL file
1016  * is either this code or is smart enough to place the namespace declarations
1017  * inside the main root node or inside the metadata node and does not redefine
1018  * a namespace inside an inner node; this does *not* conform to the
1019  * XML-NS standard, although is a close approximation.  In order to make this
1020  * conformant to the XML-NS specification we should use a per-element
1021  * namespace table inside GMarkup and ask it to resolve the namespaces for us.
1022  */
1023 static void
1024 map_namespace_to_name (ParseData    *parse_data,
1025                        const gchar **attribute_names,
1026            const gchar **attribute_values)
1027 {
1028   const gchar *attr;
1029   gint i;
1030 
1031   g_warn_if_fail (parse_data != NULL);
1032 
1033   if (!attribute_names || !attribute_names[0])
1034     return;
1035 
1036   i = 0;
1037   for (attr = attribute_names[i]; attr; attr = attribute_names[++i])
1038     {
1039       if (g_str_has_prefix (attr, &quot;xmlns&quot;))
1040         {
1041           gchar *namespace_name, *namespace_uri;
1042           gchar *p;
1043 
1044           p = g_utf8_strchr (attr, -1, &#39;:&#39;);
1045           if (p)
1046             p = g_utf8_next_char (p);
1047           else
1048             p = &quot;default&quot;;
1049 
1050           namespace_name = g_strdup (p);
1051           namespace_uri = g_strdup (attribute_values[i]);
1052 
1053           g_hash_table_replace (parse_data-&gt;namespaces,
1054                                 namespace_name,
1055                                 namespace_uri);
1056         }
1057      }
1058 }
1059 
1060 /* checks whether @element_full is equal to @element.
1061  *
1062  * if @namespace is set, it tries to resolve the namespace to a known URI,
1063  * and if found is prepended to the element name, from which is separated
1064  * using the character specified in the @sep parameter.
1065  */
1066 static gboolean
1067 is_element_full (ParseData   *parse_data,
1068                  const gchar *element_full,
1069                  const gchar *namespace,
1070                  const gchar *element,
1071                  const gchar  sep)
1072 {
1073   gchar *ns_uri, *ns_name;
1074   const gchar *p, *element_name;
1075   gboolean retval;
1076 
1077   g_warn_if_fail (parse_data != NULL);
1078   g_warn_if_fail (element_full != NULL);
1079 
1080   if (!element)
1081     return FALSE;
1082 
1083   /* no namespace requested: dumb element compare */
1084   if (!namespace)
1085     return (0 == strcmp (element_full, element));
1086 
1087   /* search for namespace separator; if none found, assume we are under the
1088    * default namespace, and set ns_name to our &quot;default&quot; marker; if no default
1089    * namespace has been set, just do a plain comparison between @full_element
1090    * and @element.
1091    */
1092   p = g_utf8_strchr (element_full, -1, &#39;:&#39;);
1093   if (p)
1094     {
1095       ns_name = g_strndup (element_full, p - element_full);
1096       element_name = g_utf8_next_char (p);
1097     }
1098   else
1099     {
1100       ns_name = g_strdup (&quot;default&quot;);
1101       element_name = element_full;
1102     }
1103 
1104   ns_uri = g_hash_table_lookup (parse_data-&gt;namespaces, ns_name);
1105   if (!ns_uri)
1106     {
1107       /* no default namespace found */
1108       g_free (ns_name);
1109 
1110       return (0 == strcmp (element_full, element));
1111     }
1112 
1113   retval = (0 == strcmp (ns_uri, namespace) &amp;&amp;
1114             0 == strcmp (element_name, element));
1115 
1116   g_free (ns_name);
1117 
1118   return retval;
1119 }
1120 
1121 #define IS_ELEMENT(p,s,e) (is_element_full ((p), (s), NULL, (e), &#39;\0&#39;))
1122 #define IS_ELEMENT_NS(p,s,n,e)  (is_element_full ((p), (s), (n), (e), &#39;|&#39;))
1123 
1124 static const gchar *
1125 parser_state_to_element_name (ParserState state)
1126 {
1127   switch (state)
1128     {
1129     case STATE_STARTED:
1130     case STATE_FINISHED:
1131       return &quot;(top-level)&quot;;
1132     case STATE_ROOT:
1133       return XBEL_ROOT_ELEMENT;
1134     case STATE_BOOKMARK:
1135       return XBEL_BOOKMARK_ELEMENT;
1136     case STATE_TITLE:
1137       return XBEL_TITLE_ELEMENT;
1138     case STATE_DESC:
1139       return XBEL_DESC_ELEMENT;
1140     case STATE_INFO:
1141       return XBEL_INFO_ELEMENT;
1142     case STATE_METADATA:
1143       return XBEL_METADATA_ELEMENT;
1144     case STATE_APPLICATIONS:
1145       return BOOKMARK_APPLICATIONS_ELEMENT;
1146     case STATE_APPLICATION:
1147       return BOOKMARK_APPLICATION_ELEMENT;
1148     case STATE_GROUPS:
1149       return BOOKMARK_GROUPS_ELEMENT;
1150     case STATE_GROUP:
1151       return BOOKMARK_GROUP_ELEMENT;
1152     case STATE_MIME:
1153       return MIME_TYPE_ELEMENT;
1154     case STATE_ICON:
1155       return BOOKMARK_ICON_ELEMENT;
1156     default:
1157       g_assert_not_reached ();
1158     }
1159 }
1160 
1161 static void
1162 start_element_raw_cb (GMarkupParseContext *context,
1163                       const gchar         *element_name,
1164                       const gchar        **attribute_names,
1165                       const gchar        **attribute_values,
1166                       gpointer             user_data,
1167                       GError             **error)
1168 {
1169   ParseData *parse_data = (ParseData *) user_data;
1170 
1171   /* we must check for namespace declarations first
1172    *
1173    * XXX - we could speed up things by checking for namespace declarations
1174    * only on the root node, where they usually are; this would probably break
1175    * on streams not produced by us or by &quot;smart&quot; generators
1176    */
1177   map_namespace_to_name (parse_data, attribute_names, attribute_values);
1178 
1179   switch (parse_data-&gt;state)
1180     {
1181     case STATE_STARTED:
1182       if (IS_ELEMENT (parse_data, element_name, XBEL_ROOT_ELEMENT))
1183         {
1184           const gchar *attr;
1185           gint i;
1186 
1187           i = 0;
1188           for (attr = attribute_names[i]; attr; attr = attribute_names[++i])
1189             {
1190               if ((IS_ATTRIBUTE (attr, XBEL_VERSION_ATTRIBUTE)) &amp;&amp;
1191                   (0 == strcmp (attribute_values[i], XBEL_VERSION)))
1192                 parse_data-&gt;state = STATE_ROOT;
1193             }
1194   }
1195       else
1196         g_set_error (error, G_MARKUP_ERROR,
1197          G_MARKUP_ERROR_INVALID_CONTENT,
1198                  _(&quot;Unexpected tag &#39;%s&#39;, tag &#39;%s&#39; expected&quot;),
1199                  element_name, XBEL_ROOT_ELEMENT);
1200       break;
1201     case STATE_ROOT:
1202       if (IS_ELEMENT (parse_data, element_name, XBEL_TITLE_ELEMENT))
1203         parse_data-&gt;state = STATE_TITLE;
1204       else if (IS_ELEMENT (parse_data, element_name, XBEL_DESC_ELEMENT))
1205         parse_data-&gt;state = STATE_DESC;
1206       else if (IS_ELEMENT (parse_data, element_name, XBEL_BOOKMARK_ELEMENT))
1207         {
1208           GError *inner_error = NULL;
1209 
1210           parse_data-&gt;state = STATE_BOOKMARK;
1211 
1212           parse_bookmark_element (context,
1213                   parse_data,
1214                   attribute_names,
1215                   attribute_values,
1216                   &amp;inner_error);
1217           if (inner_error)
1218             g_propagate_error (error, inner_error);
1219         }
1220       else
1221         g_set_error (error, G_MARKUP_ERROR,
1222                G_MARKUP_ERROR_INVALID_CONTENT,
1223                _(&quot;Unexpected tag &#39;%s&#39; inside &#39;%s&#39;&quot;),
1224                element_name,
1225                XBEL_ROOT_ELEMENT);
1226       break;
1227     case STATE_BOOKMARK:
1228       if (IS_ELEMENT (parse_data, element_name, XBEL_TITLE_ELEMENT))
1229         parse_data-&gt;state = STATE_TITLE;
1230       else if (IS_ELEMENT (parse_data, element_name, XBEL_DESC_ELEMENT))
1231         parse_data-&gt;state = STATE_DESC;
1232       else if (IS_ELEMENT (parse_data, element_name, XBEL_INFO_ELEMENT))
1233         parse_data-&gt;state = STATE_INFO;
1234       else
1235         g_set_error (error, G_MARKUP_ERROR,
1236                G_MARKUP_ERROR_INVALID_CONTENT,
1237                  _(&quot;Unexpected tag &#39;%s&#39; inside &#39;%s&#39;&quot;),
1238                  element_name,
1239                  XBEL_BOOKMARK_ELEMENT);
1240       break;
1241     case STATE_INFO:
1242       if (IS_ELEMENT (parse_data, element_name, XBEL_METADATA_ELEMENT))
1243         {
1244           const gchar *attr;
1245           gint i;
1246 
1247           i = 0;
1248           for (attr = attribute_names[i]; attr; attr = attribute_names[++i])
1249             {
1250               if ((IS_ATTRIBUTE (attr, XBEL_OWNER_ATTRIBUTE)) &amp;&amp;
1251                   (0 == strcmp (attribute_values[i], BOOKMARK_METADATA_OWNER)))
1252                 {
1253                   parse_data-&gt;state = STATE_METADATA;
1254 
1255                   if (!parse_data-&gt;current_item-&gt;metadata)
1256                     parse_data-&gt;current_item-&gt;metadata = bookmark_metadata_new ();
1257                 }
1258             }
1259         }
1260       else
1261         g_set_error (error, G_MARKUP_ERROR,
1262                G_MARKUP_ERROR_INVALID_CONTENT,
1263                _(&quot;Unexpected tag &#39;%s&#39;, tag &#39;%s&#39; expected&quot;),
1264                element_name,
1265                XBEL_METADATA_ELEMENT);
1266       break;
1267     case STATE_METADATA:
1268       if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_APPLICATIONS_ELEMENT))
1269         parse_data-&gt;state = STATE_APPLICATIONS;
1270       else if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_GROUPS_ELEMENT))
1271         parse_data-&gt;state = STATE_GROUPS;
1272       else if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_PRIVATE_ELEMENT))
1273         parse_data-&gt;current_item-&gt;metadata-&gt;is_private = TRUE;
1274       else if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_ICON_ELEMENT))
1275         {
1276           GError *inner_error = NULL;
1277 
1278     parse_data-&gt;state = STATE_ICON;
1279 
1280           parse_icon_element (context,
1281                     parse_data,
1282                     attribute_names,
1283                     attribute_values,
1284                     &amp;inner_error);
1285           if (inner_error)
1286             g_propagate_error (error, inner_error);
1287         }
1288       else if (IS_ELEMENT_NS (parse_data, element_name, MIME_NAMESPACE_URI, MIME_TYPE_ELEMENT))
1289         {
1290           GError *inner_error = NULL;
1291 
1292           parse_data-&gt;state = STATE_MIME;
1293 
1294           parse_mime_type_element (context,
1295                    parse_data,
1296                    attribute_names,
1297                    attribute_values,
1298                    &amp;inner_error);
1299           if (inner_error)
1300             g_propagate_error (error, inner_error);
1301         }
1302       else
1303         g_set_error (error, G_MARKUP_ERROR,
1304                G_MARKUP_ERROR_UNKNOWN_ELEMENT,
1305                _(&quot;Unexpected tag &#39;%s&#39; inside &#39;%s&#39;&quot;),
1306                element_name,
1307                XBEL_METADATA_ELEMENT);
1308       break;
1309     case STATE_APPLICATIONS:
1310       if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_APPLICATION_ELEMENT))
1311         {
1312           GError *inner_error = NULL;
1313 
1314           parse_data-&gt;state = STATE_APPLICATION;
1315 
1316           parse_application_element (context,
1317                      parse_data,
1318                      attribute_names,
1319                      attribute_values,
1320                      &amp;inner_error);
1321           if (inner_error)
1322             g_propagate_error (error, inner_error);
1323         }
1324       else
1325         g_set_error (error, G_MARKUP_ERROR,
1326                G_MARKUP_ERROR_INVALID_CONTENT,
1327                _(&quot;Unexpected tag &#39;%s&#39;, tag &#39;%s&#39; expected&quot;),
1328                element_name,
1329                BOOKMARK_APPLICATION_ELEMENT);
1330       break;
1331     case STATE_GROUPS:
1332       if (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_GROUP_ELEMENT))
1333         parse_data-&gt;state = STATE_GROUP;
1334       else
1335         g_set_error (error, G_MARKUP_ERROR,
1336                G_MARKUP_ERROR_INVALID_CONTENT,
1337                _(&quot;Unexpected tag &#39;%s&#39;, tag &#39;%s&#39; expected&quot;),
1338                element_name,
1339                BOOKMARK_GROUP_ELEMENT);
1340       break;
1341 
1342     case STATE_TITLE:
1343     case STATE_DESC:
1344     case STATE_APPLICATION:
1345     case STATE_GROUP:
1346     case STATE_MIME:
1347     case STATE_ICON:
1348     case STATE_FINISHED:
1349       g_set_error (error, G_MARKUP_ERROR,
1350                    G_MARKUP_ERROR_INVALID_CONTENT,
1351                    _(&quot;Unexpected tag &#39;%s&#39; inside &#39;%s&#39;&quot;),
1352                    element_name,
1353                    parser_state_to_element_name (parse_data-&gt;state));
1354       break;
1355 
1356     default:
1357       g_assert_not_reached ();
1358       break;
1359     }
1360 }
1361 
1362 static void
1363 end_element_raw_cb (GMarkupParseContext *context,
1364                     const gchar         *element_name,
1365                     gpointer             user_data,
1366                     GError             **error)
1367 {
1368   ParseData *parse_data = (ParseData *) user_data;
1369 
1370   if (IS_ELEMENT (parse_data, element_name, XBEL_ROOT_ELEMENT))
1371     parse_data-&gt;state = STATE_FINISHED;
1372   else if (IS_ELEMENT (parse_data, element_name, XBEL_BOOKMARK_ELEMENT))
1373     {
1374       parse_data-&gt;current_item = NULL;
1375 
1376       parse_data-&gt;state = STATE_ROOT;
1377     }
1378   else if ((IS_ELEMENT (parse_data, element_name, XBEL_INFO_ELEMENT)) ||
1379            (IS_ELEMENT (parse_data, element_name, XBEL_TITLE_ELEMENT)) ||
1380            (IS_ELEMENT (parse_data, element_name, XBEL_DESC_ELEMENT)))
1381     {
1382       if (parse_data-&gt;current_item)
1383         parse_data-&gt;state = STATE_BOOKMARK;
1384       else
1385         parse_data-&gt;state = STATE_ROOT;
1386     }
1387   else if (IS_ELEMENT (parse_data, element_name, XBEL_METADATA_ELEMENT))
1388     parse_data-&gt;state = STATE_INFO;
1389   else if (IS_ELEMENT_NS (parse_data, element_name,
1390                           BOOKMARK_NAMESPACE_URI,
1391                           BOOKMARK_APPLICATION_ELEMENT))
1392     parse_data-&gt;state = STATE_APPLICATIONS;
1393   else if (IS_ELEMENT_NS (parse_data, element_name,
1394                           BOOKMARK_NAMESPACE_URI,
1395                           BOOKMARK_GROUP_ELEMENT))
1396     parse_data-&gt;state = STATE_GROUPS;
1397   else if ((IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_APPLICATIONS_ELEMENT)) ||
1398            (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_GROUPS_ELEMENT)) ||
1399            (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_PRIVATE_ELEMENT)) ||
1400            (IS_ELEMENT_NS (parse_data, element_name, BOOKMARK_NAMESPACE_URI, BOOKMARK_ICON_ELEMENT)) ||
1401            (IS_ELEMENT_NS (parse_data, element_name, MIME_NAMESPACE_URI, MIME_TYPE_ELEMENT)))
1402     parse_data-&gt;state = STATE_METADATA;
1403 }
1404 
1405 static void
1406 text_raw_cb (GMarkupParseContext *context,
1407              const gchar         *text,
1408              gsize                length,
1409              gpointer             user_data,
1410              GError             **error)
1411 {
1412   ParseData *parse_data = (ParseData *) user_data;
1413   gchar *payload;
1414 
1415   payload = g_strndup (text, length);
1416 
1417   switch (parse_data-&gt;state)
1418     {
1419     case STATE_TITLE:
1420       if (parse_data-&gt;current_item)
1421         {
1422           g_free (parse_data-&gt;current_item-&gt;title);
1423           parse_data-&gt;current_item-&gt;title = g_strdup (payload);
1424         }
1425       else
1426         {
1427           g_free (parse_data-&gt;bookmark_file-&gt;title);
1428           parse_data-&gt;bookmark_file-&gt;title = g_strdup (payload);
1429         }
1430       break;
1431     case STATE_DESC:
1432       if (parse_data-&gt;current_item)
1433         {
1434           g_free (parse_data-&gt;current_item-&gt;description);
1435           parse_data-&gt;current_item-&gt;description = g_strdup (payload);
1436         }
1437       else
1438         {
1439           g_free (parse_data-&gt;bookmark_file-&gt;description);
1440           parse_data-&gt;bookmark_file-&gt;description = g_strdup (payload);
1441         }
1442       break;
1443     case STATE_GROUP:
1444       {
1445       GList *groups;
1446 
1447       g_warn_if_fail (parse_data-&gt;current_item != NULL);
1448 
1449       if (!parse_data-&gt;current_item-&gt;metadata)
1450         parse_data-&gt;current_item-&gt;metadata = bookmark_metadata_new ();
1451 
1452       groups = parse_data-&gt;current_item-&gt;metadata-&gt;groups;
1453       parse_data-&gt;current_item-&gt;metadata-&gt;groups = g_list_prepend (groups, g_strdup (payload));
1454       }
1455       break;
1456     case STATE_ROOT:
1457     case STATE_BOOKMARK:
1458     case STATE_INFO:
1459     case STATE_METADATA:
1460     case STATE_APPLICATIONS:
1461     case STATE_APPLICATION:
1462     case STATE_GROUPS:
1463     case STATE_MIME:
1464     case STATE_ICON:
1465       break;
1466     default:
1467       g_warn_if_reached ();
1468       break;
1469     }
1470 
1471   g_free (payload);
1472 }
1473 
1474 static const GMarkupParser markup_parser =
1475 {
1476   start_element_raw_cb, /* start_element */
1477   end_element_raw_cb,   /* end_element */
1478   text_raw_cb,          /* text */
1479   NULL,                 /* passthrough */
1480   NULL
1481 };
1482 
1483 static gboolean
1484 g_bookmark_file_parse (GBookmarkFile  *bookmark,
1485        const gchar  *buffer,
1486        gsize         length,
1487        GError       **error)
1488 {
1489   GMarkupParseContext *context;
1490   ParseData *parse_data;
1491   GError *parse_error, *end_error;
1492   gboolean retval;
1493 
1494   g_warn_if_fail (bookmark != NULL);
1495 
1496   if (!buffer)
1497     return FALSE;
1498 
1499   parse_error = NULL;
1500   end_error = NULL;
1501 
1502   if (length == (gsize) -1)
1503     length = strlen (buffer);
1504 
1505   parse_data = parse_data_new ();
1506   parse_data-&gt;bookmark_file = bookmark;
1507 
1508   context = g_markup_parse_context_new (&amp;markup_parser,
1509             0,
1510             parse_data,
1511             (GDestroyNotify) parse_data_free);
1512 
1513   retval = g_markup_parse_context_parse (context,
1514              buffer,
1515              length,
1516              &amp;parse_error);
1517   if (!retval)
1518     g_propagate_error (error, parse_error);
1519   else
1520    {
1521      retval = g_markup_parse_context_end_parse (context, &amp;end_error);
1522       if (!retval)
1523         g_propagate_error (error, end_error);
1524    }
1525 
1526   g_markup_parse_context_free (context);
1527 
1528   return retval;
1529 }
1530 
1531 static gchar *
1532 g_bookmark_file_dump (GBookmarkFile  *bookmark,
1533           gsize          *length,
1534           GError        **error)
1535 {
1536   GString *retval;
1537   gchar *buffer;
1538   GList *l;
1539 
1540   retval = g_string_sized_new (4096);
1541 
1542   g_string_append (retval,
1543        &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;
1544 #if 0
1545        /* XXX - do we really need the doctype? */
1546        &quot;&lt;!DOCTYPE &quot; XBEL_DTD_NICK &quot;\n&quot;
1547        &quot;  PUBLIC \&quot;&quot; XBEL_DTD_SYSTEM &quot;\&quot;\n&quot;
1548        &quot;         \&quot;&quot; XBEL_DTD_URI &quot;\&quot;&gt;\n&quot;
1549 #endif
1550        &quot;&lt;&quot; XBEL_ROOT_ELEMENT &quot; &quot; XBEL_VERSION_ATTRIBUTE &quot;=\&quot;&quot; XBEL_VERSION &quot;\&quot;\n&quot;
1551        &quot;      xmlns:&quot; BOOKMARK_NAMESPACE_NAME &quot;=\&quot;&quot; BOOKMARK_NAMESPACE_URI &quot;\&quot;\n&quot;
1552        &quot;      xmlns:&quot; MIME_NAMESPACE_NAME     &quot;=\&quot;&quot; MIME_NAMESPACE_URI &quot;\&quot;\n&gt;&quot;);
1553 
1554   if (bookmark-&gt;title)
1555     {
1556       gchar *escaped_title;
1557 
1558       escaped_title = g_markup_escape_text (bookmark-&gt;title, -1);
1559 
1560       buffer = g_strconcat (&quot;  &quot;
1561           &quot;&lt;&quot; XBEL_TITLE_ELEMENT &quot;&gt;&quot;,
1562           escaped_title,
1563           &quot;&lt;/&quot; XBEL_TITLE_ELEMENT &quot;&gt;\n&quot;, NULL);
1564 
1565       g_string_append (retval, buffer);
1566 
1567       g_free (buffer);
1568       g_free (escaped_title);
1569     }
1570 
1571   if (bookmark-&gt;description)
1572     {
1573       gchar *escaped_desc;
1574 
1575       escaped_desc = g_markup_escape_text (bookmark-&gt;description, -1);
1576 
1577       buffer = g_strconcat (&quot;  &quot;
1578           &quot;&lt;&quot; XBEL_DESC_ELEMENT &quot;&gt;&quot;,
1579           escaped_desc,
1580           &quot;&lt;/&quot; XBEL_DESC_ELEMENT &quot;&gt;\n&quot;, NULL);
1581       g_string_append (retval, buffer);
1582 
1583       g_free (buffer);
1584       g_free (escaped_desc);
1585     }
1586 
1587   if (!bookmark-&gt;items)
1588     goto out;
1589   else
1590     retval = g_string_append (retval, &quot;\n&quot;);
1591 
1592   /* the items are stored in reverse order */
1593   for (l = g_list_last (bookmark-&gt;items);
1594        l != NULL;
1595        l = l-&gt;prev)
1596     {
1597       BookmarkItem *item = (BookmarkItem *) l-&gt;data;
1598       gchar *item_dump;
1599 
1600       item_dump = bookmark_item_dump (item);
1601       if (!item_dump)
1602         continue;
1603 
1604       retval = g_string_append (retval, item_dump);
1605 
1606       g_free (item_dump);
1607     }
1608 
1609 out:
1610   g_string_append (retval, &quot;&lt;/&quot; XBEL_ROOT_ELEMENT &quot;&gt;&quot;);
1611 
1612   if (length)
1613     *length = retval-&gt;len;
1614 
1615   return g_string_free (retval, FALSE);
1616 }
1617 
1618 /**************
1619  *    Misc    *
1620  **************/
1621 
1622 /* converts a Unix timestamp in a ISO 8601 compliant string; you
1623  * should free the returned string.
1624  */
1625 static gchar *
1626 timestamp_to_iso8601 (time_t timestamp)
1627 {
1628   GDateTime *dt = g_date_time_new_from_unix_utc (timestamp);
1629   gchar *iso8601_string = g_date_time_format_iso8601 (dt);
1630   g_date_time_unref (dt);
1631 
1632   return g_steal_pointer (&amp;iso8601_string);
1633 }
1634 
1635 static gboolean
1636 timestamp_from_iso8601 (const gchar  *iso_date,
1637                         time_t       *out_timestamp,
1638                         GError      **error)
1639 {
1640   gint64 time_val;
1641   GDateTime *dt = g_date_time_new_from_iso8601 (iso_date, NULL);
1642   if (dt == NULL)
1643     {
1644       g_set_error (error, G_BOOKMARK_FILE_ERROR, G_BOOKMARK_FILE_ERROR_READ,
1645                    _(&quot;Invalid date/time &#39;%s&#39; in bookmark file&quot;), iso_date);
1646       return FALSE;
1647     }
1648 
1649   time_val = g_date_time_to_unix (dt);
1650   g_date_time_unref (dt);
1651 
1652   *out_timestamp = time_val;
1653   return TRUE;
1654 }
1655 
1656 G_DEFINE_QUARK (g-bookmark-file-error-quark, g_bookmark_file_error)
1657 
1658 /********************
1659  *    Public API    *
1660  ********************/
1661 
1662 /**
1663  * g_bookmark_file_new: (constructor)
1664  *
1665  * Creates a new empty #GBookmarkFile object.
1666  *
1667  * Use g_bookmark_file_load_from_file(), g_bookmark_file_load_from_data()
1668  * or g_bookmark_file_load_from_data_dirs() to read an existing bookmark
1669  * file.
1670  *
1671  * Returns: an empty #GBookmarkFile
1672  *
1673  * Since: 2.12
1674  */
1675 GBookmarkFile *
1676 g_bookmark_file_new (void)
1677 {
1678   GBookmarkFile *bookmark;
1679 
1680   bookmark = g_new (GBookmarkFile, 1);
1681 
1682   g_bookmark_file_init (bookmark);
1683 
1684   return bookmark;
1685 }
1686 
1687 /**
1688  * g_bookmark_file_free:
1689  * @bookmark: a #GBookmarkFile
1690  *
1691  * Frees a #GBookmarkFile.
1692  *
1693  * Since: 2.12
1694  */
1695 void
1696 g_bookmark_file_free (GBookmarkFile *bookmark)
1697 {
1698   if (!bookmark)
1699     return;
1700 
1701   g_bookmark_file_clear (bookmark);
1702 
1703   g_free (bookmark);
1704 }
1705 
1706 /**
1707  * g_bookmark_file_load_from_data:
1708  * @bookmark: an empty #GBookmarkFile struct
1709  * @data: (array length=length) (element-type guint8): desktop bookmarks
1710  *    loaded in memory
1711  * @length: the length of @data in bytes
1712  * @error: return location for a #GError, or %NULL
1713  *
1714  * Loads a bookmark file from memory into an empty #GBookmarkFile
1715  * structure.  If the object cannot be created then @error is set to a
1716  * #GBookmarkFileError.
1717  *
1718  * Returns: %TRUE if a desktop bookmark could be loaded.
1719  *
1720  * Since: 2.12
1721  */
1722 gboolean
1723 g_bookmark_file_load_from_data (GBookmarkFile  *bookmark,
1724         const gchar    *data,
1725         gsize           length,
1726         GError        **error)
1727 {
1728   GError *parse_error;
1729   gboolean retval;
1730 
1731   g_return_val_if_fail (bookmark != NULL, FALSE);
1732 
1733   if (length == (gsize) -1)
1734     length = strlen (data);
1735 
1736   if (bookmark-&gt;items)
1737     {
1738       g_bookmark_file_clear (bookmark);
1739       g_bookmark_file_init (bookmark);
1740     }
1741 
1742   parse_error = NULL;
1743   retval = g_bookmark_file_parse (bookmark, data, length, &amp;parse_error);
1744 
1745   if (!retval)
1746     g_propagate_error (error, parse_error);
1747 
1748   return retval;
1749 }
1750 
1751 /**
1752  * g_bookmark_file_load_from_file:
1753  * @bookmark: an empty #GBookmarkFile struct
1754  * @filename: (type filename): the path of a filename to load, in the
1755  *     GLib file name encoding
1756  * @error: return location for a #GError, or %NULL
1757  *
1758  * Loads a desktop bookmark file into an empty #GBookmarkFile structure.
1759  * If the file could not be loaded then @error is set to either a #GFileError
1760  * or #GBookmarkFileError.
1761  *
1762  * Returns: %TRUE if a desktop bookmark file could be loaded
1763  *
1764  * Since: 2.12
1765  */
1766 gboolean
1767 g_bookmark_file_load_from_file (GBookmarkFile  *bookmark,
1768         const gchar    *filename,
1769         GError        **error)
1770 {
1771   gboolean ret = FALSE;
1772   gchar *buffer = NULL;
1773   gsize len;
1774 
1775   g_return_val_if_fail (bookmark != NULL, FALSE);
1776   g_return_val_if_fail (filename != NULL, FALSE);
1777 
1778   if (!g_file_get_contents (filename, &amp;buffer, &amp;len, error))
1779     goto out;
1780 
1781   if (!g_bookmark_file_load_from_data (bookmark, buffer, len, error))
1782     goto out;
1783 
1784   ret = TRUE;
1785  out:
1786   g_free (buffer);
1787   return ret;
1788 }
1789 
1790 
1791 /* Iterates through all the directories in *dirs trying to
1792  * find file.  When it successfully locates file, returns a
1793  * string its absolute path.  It also leaves the unchecked
1794  * directories in *dirs.  You should free the returned string
1795  *
1796  * Adapted from gkeyfile.c
1797  */
1798 static gchar *
1799 find_file_in_data_dirs (const gchar   *file,
1800                         gchar       ***dirs,
1801                         GError       **error)
1802 {
1803   gchar **data_dirs, *data_dir, *path;
1804 
1805   path = NULL;
1806 
1807   if (dirs == NULL)
1808     return NULL;
1809 
1810   data_dirs = *dirs;
1811   path = NULL;
1812   while (data_dirs &amp;&amp; (data_dir = *data_dirs) &amp;&amp; !path)
1813     {
1814       gchar *candidate_file, *sub_dir;
1815 
1816       candidate_file = (gchar *) file;
1817       sub_dir = g_strdup (&quot;&quot;);
1818       while (candidate_file != NULL &amp;&amp; !path)
1819         {
1820           gchar *p;
1821 
1822           path = g_build_filename (data_dir, sub_dir,
1823                                    candidate_file, NULL);
1824 
1825           candidate_file = strchr (candidate_file, &#39;-&#39;);
1826 
1827           if (candidate_file == NULL)
1828             break;
1829 
1830           candidate_file++;
1831 
1832           g_free (sub_dir);
1833           sub_dir = g_strndup (file, candidate_file - file - 1);
1834 
1835           for (p = sub_dir; *p != &#39;\0&#39;; p++)
1836             {
1837               if (*p == &#39;-&#39;)
1838                 *p = G_DIR_SEPARATOR;
1839             }
1840         }
1841       g_free (sub_dir);
1842       data_dirs++;
1843     }
1844 
1845   *dirs = data_dirs;
1846 
1847   if (!path)
1848     {
1849       g_set_error_literal (error, G_BOOKMARK_FILE_ERROR,
1850                            G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND,
1851                            _(&quot;No valid bookmark file found in data dirs&quot;));
1852 
1853       return NULL;
1854     }
1855 
1856   return path;
1857 }
1858 
1859 
1860 /**
1861  * g_bookmark_file_load_from_data_dirs:
1862  * @bookmark: a #GBookmarkFile
1863  * @file: (type filename): a relative path to a filename to open and parse
1864  * @full_path: (out) (optional) (type filename): return location for a string
1865  *    containing the full path of the file, or %NULL
1866  * @error: return location for a #GError, or %NULL
1867  *
1868  * This function looks for a desktop bookmark file named @file in the
1869  * paths returned from g_get_user_data_dir() and g_get_system_data_dirs(),
1870  * loads the file into @bookmark and returns the file&#39;s full path in
1871  * @full_path.  If the file could not be loaded then @error is
1872  * set to either a #GFileError or #GBookmarkFileError.
1873  *
1874  * Returns: %TRUE if a key file could be loaded, %FALSE otherwise
1875  *
1876  * Since: 2.12
1877  */
1878 gboolean
1879 g_bookmark_file_load_from_data_dirs (GBookmarkFile  *bookmark,
1880              const gchar    *file,
1881              gchar         **full_path,
1882              GError        **error)
1883 {
1884   GError *file_error = NULL;
1885   gchar **all_data_dirs, **data_dirs;
1886   const gchar *user_data_dir;
1887   const gchar * const * system_data_dirs;
1888   gsize i, j;
1889   gchar *output_path;
1890   gboolean found_file;
1891 
1892   g_return_val_if_fail (bookmark != NULL, FALSE);
1893   g_return_val_if_fail (!g_path_is_absolute (file), FALSE);
1894 
1895   user_data_dir = g_get_user_data_dir ();
1896   system_data_dirs = g_get_system_data_dirs ();
1897   all_data_dirs = g_new0 (gchar *, g_strv_length ((gchar **)system_data_dirs) + 2);
1898 
1899   i = 0;
1900   all_data_dirs[i++] = g_strdup (user_data_dir);
1901 
1902   j = 0;
1903   while (system_data_dirs[j] != NULL)
1904     all_data_dirs[i++] = g_strdup (system_data_dirs[j++]);
1905 
1906   found_file = FALSE;
1907   data_dirs = all_data_dirs;
1908   output_path = NULL;
1909   while (*data_dirs != NULL &amp;&amp; !found_file)
1910     {
1911       g_free (output_path);
1912 
1913       output_path = find_file_in_data_dirs (file, &amp;data_dirs, &amp;file_error);
1914 
1915       if (file_error)
1916         {
1917           g_propagate_error (error, file_error);
1918     break;
1919         }
1920 
1921       found_file = g_bookmark_file_load_from_file (bookmark,
1922                      output_path,
1923                      &amp;file_error);
1924       if (file_error)
1925         {
1926     g_propagate_error (error, file_error);
1927     break;
1928         }
1929     }
1930 
1931   if (found_file &amp;&amp; full_path)
1932     *full_path = output_path;
1933   else
1934     g_free (output_path);
1935 
1936   g_strfreev (all_data_dirs);
1937 
1938   return found_file;
1939 }
1940 
1941 
1942 /**
1943  * g_bookmark_file_to_data:
1944  * @bookmark: a #GBookmarkFile
1945  * @length: (out) (optional): return location for the length of the returned string, or %NULL
1946  * @error: return location for a #GError, or %NULL
1947  *
1948  * This function outputs @bookmark as a string.
1949  *
1950  * Returns: (array length=length) (element-type guint8):
1951  *   a newly allocated string holding the contents of the #GBookmarkFile
1952  *
1953  * Since: 2.12
1954  */
1955 gchar *
1956 g_bookmark_file_to_data (GBookmarkFile  *bookmark,
1957        gsize          *length,
1958        GError        **error)
1959 {
1960   GError *write_error = NULL;
1961   gchar *retval;
1962 
1963   g_return_val_if_fail (bookmark != NULL, NULL);
1964 
1965   retval = g_bookmark_file_dump (bookmark, length, &amp;write_error);
1966   if (write_error)
1967     {
1968       g_propagate_error (error, write_error);
1969 
1970       return NULL;
1971     }
1972 
1973   return retval;
1974 }
1975 
1976 /**
1977  * g_bookmark_file_to_file:
1978  * @bookmark: a #GBookmarkFile
1979  * @filename: (type filename): path of the output file
1980  * @error: return location for a #GError, or %NULL
1981  *
1982  * This function outputs @bookmark into a file.  The write process is
1983  * guaranteed to be atomic by using g_file_set_contents() internally.
1984  *
1985  * Returns: %TRUE if the file was successfully written.
1986  *
1987  * Since: 2.12
1988  */
1989 gboolean
1990 g_bookmark_file_to_file (GBookmarkFile  *bookmark,
1991        const gchar    *filename,
1992        GError        **error)
1993 {
1994   gchar *data;
1995   GError *data_error, *write_error;
1996   gsize len;
1997   gboolean retval;
1998 
1999   g_return_val_if_fail (bookmark != NULL, FALSE);
2000   g_return_val_if_fail (filename != NULL, FALSE);
2001 
2002   data_error = NULL;
2003   data = g_bookmark_file_to_data (bookmark, &amp;len, &amp;data_error);
2004   if (data_error)
2005     {
2006       g_propagate_error (error, data_error);
2007 
2008       return FALSE;
2009     }
2010 
2011   write_error = NULL;
2012   g_file_set_contents (filename, data, len, &amp;write_error);
2013   if (write_error)
2014     {
2015       g_propagate_error (error, write_error);
2016 
2017       retval = FALSE;
2018     }
2019   else
2020     retval = TRUE;
2021 
2022   g_free (data);
2023 
2024   return retval;
2025 }
2026 
2027 static BookmarkItem *
2028 g_bookmark_file_lookup_item (GBookmarkFile *bookmark,
2029            const gchar   *uri)
2030 {
2031   g_warn_if_fail (bookmark != NULL &amp;&amp; uri != NULL);
2032 
2033   return g_hash_table_lookup (bookmark-&gt;items_by_uri, uri);
2034 }
2035 
2036 /* this function adds a new item to the list */
2037 static void
2038 g_bookmark_file_add_item (GBookmarkFile  *bookmark,
2039         BookmarkItem   *item,
2040         GError        **error)
2041 {
2042   g_warn_if_fail (bookmark != NULL);
2043   g_warn_if_fail (item != NULL);
2044 
2045 #ifdef GSTREAMER_LITE
2046   if (bookmark == NULL || item == NULL) {
2047     return;
2048   }
2049 #endif // GSTREAMER_LITE
2050 
2051   /* this should never happen; and if it does, then we are
2052    * screwing up something big time.
2053    */
2054   if (G_UNLIKELY (g_bookmark_file_has_item (bookmark, item-&gt;uri)))
2055     {
2056       g_set_error (error, G_BOOKMARK_FILE_ERROR,
2057        G_BOOKMARK_FILE_ERROR_INVALID_URI,
2058        _(&quot;A bookmark for URI &#39;%s&#39; already exists&quot;),
2059        item-&gt;uri);
2060       return;
2061     }
2062 
2063   bookmark-&gt;items = g_list_prepend (bookmark-&gt;items, item);
2064 
2065   g_hash_table_replace (bookmark-&gt;items_by_uri,
2066       item-&gt;uri,
2067       item);
2068 
2069   if (item-&gt;added == (time_t) -1)
2070     item-&gt;added = time (NULL);
2071 
2072   if (item-&gt;modified == (time_t) -1)
2073     item-&gt;modified = time (NULL);
2074 }
2075 
2076 /**
2077  * g_bookmark_file_remove_item:
2078  * @bookmark: a #GBookmarkFile
2079  * @uri: a valid URI
2080  * @error: return location for a #GError, or %NULL
2081  *
2082  * Removes the bookmark for @uri from the bookmark file @bookmark.
2083  *
2084  * Returns: %TRUE if the bookmark was removed successfully.
2085  *
2086  * Since: 2.12
2087  */
2088 gboolean
2089 g_bookmark_file_remove_item (GBookmarkFile  *bookmark,
2090            const gchar    *uri,
2091            GError        **error)
2092 {
2093   BookmarkItem *item;
2094 
2095   g_return_val_if_fail (bookmark != NULL, FALSE);
2096   g_return_val_if_fail (uri != NULL, FALSE);
2097 
2098   item = g_bookmark_file_lookup_item (bookmark, uri);
2099 
2100   if (!item)
2101     {
2102       g_set_error (error, G_BOOKMARK_FILE_ERROR,
2103        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
2104        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),
2105        uri);
2106       return FALSE;
2107     }
2108 
2109   bookmark-&gt;items = g_list_remove (bookmark-&gt;items, item);
2110   g_hash_table_remove (bookmark-&gt;items_by_uri, item-&gt;uri);
2111 
2112   bookmark_item_free (item);
2113 
2114   return TRUE;
2115 }
2116 
2117 /**
2118  * g_bookmark_file_has_item:
2119  * @bookmark: a #GBookmarkFile
2120  * @uri: a valid URI
2121  *
2122  * Looks whether the desktop bookmark has an item with its URI set to @uri.
2123  *
2124  * Returns: %TRUE if @uri is inside @bookmark, %FALSE otherwise
2125  *
2126  * Since: 2.12
2127  */
2128 gboolean
2129 g_bookmark_file_has_item (GBookmarkFile *bookmark,
2130         const gchar   *uri)
2131 {
2132   g_return_val_if_fail (bookmark != NULL, FALSE);
2133   g_return_val_if_fail (uri != NULL, FALSE);
2134 
2135   return (NULL != g_hash_table_lookup (bookmark-&gt;items_by_uri, uri));
2136 }
2137 
2138 /**
2139  * g_bookmark_file_get_uris:
2140  * @bookmark: a #GBookmarkFile
2141  * @length: (out) (optional): return location for the number of returned URIs, or %NULL
2142  *
2143  * Returns all URIs of the bookmarks in the bookmark file @bookmark.
2144  * The array of returned URIs will be %NULL-terminated, so @length may
2145  * optionally be %NULL.
2146  *
2147  * Returns: (array length=length) (transfer full): a newly allocated %NULL-terminated array of strings.
2148  *   Use g_strfreev() to free it.
2149  *
2150  * Since: 2.12
2151  */
2152 gchar **
2153 g_bookmark_file_get_uris (GBookmarkFile *bookmark,
2154         gsize         *length)
2155 {
2156   GList *l;
2157   gchar **uris;
2158   gsize i, n_items;
2159 
2160   g_return_val_if_fail (bookmark != NULL, NULL);
2161 
2162   n_items = g_list_length (bookmark-&gt;items);
2163   uris = g_new0 (gchar *, n_items + 1);
2164 
2165   /* the items are stored in reverse order, so we walk the list backward */
2166   for (l = g_list_last (bookmark-&gt;items), i = 0; l != NULL; l = l-&gt;prev)
2167     {
2168       BookmarkItem *item = (BookmarkItem *) l-&gt;data;
2169 
2170       g_warn_if_fail (item != NULL);
2171 
2172       uris[i++] = g_strdup (item-&gt;uri);
2173     }
2174   uris[i] = NULL;
2175 
2176   if (length)
2177     *length = i;
2178 
2179   return uris;
2180 }
2181 
2182 /**
2183  * g_bookmark_file_set_title:
2184  * @bookmark: a #GBookmarkFile
2185  * @uri: (nullable): a valid URI or %NULL
2186  * @title: a UTF-8 encoded string
2187  *
2188  * Sets @title as the title of the bookmark for @uri inside the
2189  * bookmark file @bookmark.
2190  *
2191  * If @uri is %NULL, the title of @bookmark is set.
2192  *
2193  * If a bookmark for @uri cannot be found then it is created.
2194  *
2195  * Since: 2.12
2196  */
2197 void
2198 g_bookmark_file_set_title (GBookmarkFile *bookmark,
2199          const gchar   *uri,
2200          const gchar   *title)
2201 {
2202   g_return_if_fail (bookmark != NULL);
2203 
2204   if (!uri)
2205     {
2206       g_free (bookmark-&gt;title);
2207       bookmark-&gt;title = g_strdup (title);
2208     }
2209   else
2210     {
2211       BookmarkItem *item;
2212 
2213       item = g_bookmark_file_lookup_item (bookmark, uri);
2214       if (!item)
2215         {
2216           item = bookmark_item_new (uri);
2217           g_bookmark_file_add_item (bookmark, item, NULL);
2218         }
2219 
2220       g_free (item-&gt;title);
2221       item-&gt;title = g_strdup (title);
2222 
2223       item-&gt;modified = time (NULL);
2224     }
2225 }
2226 
2227 /**
2228  * g_bookmark_file_get_title:
2229  * @bookmark: a #GBookmarkFile
2230  * @uri: (nullable): a valid URI or %NULL
2231  * @error: return location for a #GError, or %NULL
2232  *
2233  * Returns the title of the bookmark for @uri.
2234  *
2235  * If @uri is %NULL, the title of @bookmark is returned.
2236  *
2237  * In the event the URI cannot be found, %NULL is returned and
2238  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2239  *
2240  * Returns: a newly allocated string or %NULL if the specified
2241  *   URI cannot be found.
2242  *
2243  * Since: 2.12
2244  */
2245 gchar *
2246 g_bookmark_file_get_title (GBookmarkFile  *bookmark,
2247          const gchar    *uri,
2248          GError        **error)
2249 {
2250   BookmarkItem *item;
2251 
2252   g_return_val_if_fail (bookmark != NULL, NULL);
2253 
2254   if (!uri)
2255     return g_strdup (bookmark-&gt;title);
2256 
2257   item = g_bookmark_file_lookup_item (bookmark, uri);
2258   if (!item)
2259     {
2260       g_set_error (error, G_BOOKMARK_FILE_ERROR,
2261        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
2262        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),
2263        uri);
2264       return NULL;
2265     }
2266 
2267   return g_strdup (item-&gt;title);
2268 }
2269 
2270 /**
2271  * g_bookmark_file_set_description:
2272  * @bookmark: a #GBookmarkFile
2273  * @uri: (nullable): a valid URI or %NULL
2274  * @description: a string
2275  *
2276  * Sets @description as the description of the bookmark for @uri.
2277  *
2278  * If @uri is %NULL, the description of @bookmark is set.
2279  *
2280  * If a bookmark for @uri cannot be found then it is created.
2281  *
2282  * Since: 2.12
2283  */
2284 void
2285 g_bookmark_file_set_description (GBookmarkFile *bookmark,
2286          const gchar   *uri,
2287          const gchar   *description)
2288 {
2289   g_return_if_fail (bookmark != NULL);
2290 
2291   if (!uri)
2292     {
2293       g_free (bookmark-&gt;description);
2294       bookmark-&gt;description = g_strdup (description);
2295     }
2296   else
2297     {
2298       BookmarkItem *item;
2299 
2300       item = g_bookmark_file_lookup_item (bookmark, uri);
2301       if (!item)
2302         {
2303           item = bookmark_item_new (uri);
2304           g_bookmark_file_add_item (bookmark, item, NULL);
2305         }
2306 
2307       g_free (item-&gt;description);
2308       item-&gt;description = g_strdup (description);
2309 
2310       item-&gt;modified = time (NULL);
2311     }
2312 }
2313 
2314 /**
2315  * g_bookmark_file_get_description:
2316  * @bookmark: a #GBookmarkFile
2317  * @uri: a valid URI
2318  * @error: return location for a #GError, or %NULL
2319  *
2320  * Retrieves the description of the bookmark for @uri.
2321  *
2322  * In the event the URI cannot be found, %NULL is returned and
2323  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2324  *
2325  * Returns: a newly allocated string or %NULL if the specified
2326  *   URI cannot be found.
2327  *
2328  * Since: 2.12
2329  */
2330 gchar *
2331 g_bookmark_file_get_description (GBookmarkFile  *bookmark,
2332          const gchar    *uri,
2333          GError        **error)
2334 {
2335   BookmarkItem *item;
2336 
2337   g_return_val_if_fail (bookmark != NULL, NULL);
2338 
2339   if (!uri)
2340     return g_strdup (bookmark-&gt;description);
2341 
2342   item = g_bookmark_file_lookup_item (bookmark, uri);
2343   if (!item)
2344     {
2345       g_set_error (error, G_BOOKMARK_FILE_ERROR,
2346        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
2347        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),
2348        uri);
2349       return NULL;
2350     }
2351 
2352   return g_strdup (item-&gt;description);
2353 }
2354 
2355 /**
2356  * g_bookmark_file_set_mime_type:
2357  * @bookmark: a #GBookmarkFile
2358  * @uri: a valid URI
2359  * @mime_type: a MIME type
2360  *
2361  * Sets @mime_type as the MIME type of the bookmark for @uri.
2362  *
2363  * If a bookmark for @uri cannot be found then it is created.
2364  *
2365  * Since: 2.12
2366  */
2367 void
2368 g_bookmark_file_set_mime_type (GBookmarkFile *bookmark,
2369              const gchar   *uri,
2370              const gchar   *mime_type)
2371 {
2372   BookmarkItem *item;
2373 
2374   g_return_if_fail (bookmark != NULL);
2375   g_return_if_fail (uri != NULL);
2376   g_return_if_fail (mime_type != NULL);
2377 
2378   item = g_bookmark_file_lookup_item (bookmark, uri);
2379   if (!item)
2380     {
2381       item = bookmark_item_new (uri);
2382       g_bookmark_file_add_item (bookmark, item, NULL);
2383     }
2384 
2385   if (!item-&gt;metadata)
2386     item-&gt;metadata = bookmark_metadata_new ();
2387 
2388   g_free (item-&gt;metadata-&gt;mime_type);
2389 
2390   item-&gt;metadata-&gt;mime_type = g_strdup (mime_type);
2391   item-&gt;modified = time (NULL);
2392 }
2393 
2394 /**
2395  * g_bookmark_file_get_mime_type:
2396  * @bookmark: a #GBookmarkFile
2397  * @uri: a valid URI
2398  * @error: return location for a #GError, or %NULL
2399  *
2400  * Retrieves the MIME type of the resource pointed by @uri.
2401  *
2402  * In the event the URI cannot be found, %NULL is returned and
2403  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
2404  * event that the MIME type cannot be found, %NULL is returned and
2405  * @error is set to #G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
2406  *
2407  * Returns: a newly allocated string or %NULL if the specified
2408  *   URI cannot be found.
2409  *
2410  * Since: 2.12
2411  */
2412 gchar *
2413 g_bookmark_file_get_mime_type (GBookmarkFile  *bookmark,
2414              const gchar    *uri,
2415              GError        **error)
2416 {
2417   BookmarkItem *item;
2418 
2419   g_return_val_if_fail (bookmark != NULL, NULL);
2420   g_return_val_if_fail (uri != NULL, NULL);
2421 
2422   item = g_bookmark_file_lookup_item (bookmark, uri);
2423   if (!item)
2424     {
2425       g_set_error (error, G_BOOKMARK_FILE_ERROR,
2426        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
2427        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),
2428        uri);
2429       return NULL;
2430     }
2431 
2432   if (!item-&gt;metadata)
2433     {
2434       g_set_error (error, G_BOOKMARK_FILE_ERROR,
2435        G_BOOKMARK_FILE_ERROR_INVALID_VALUE,
2436        _(&quot;No MIME type defined in the bookmark for URI &#39;%s&#39;&quot;),
2437        uri);
2438       return NULL;
2439     }
2440 
2441   return g_strdup (item-&gt;metadata-&gt;mime_type);
2442 }
2443 
2444 /**
2445  * g_bookmark_file_set_is_private:
2446  * @bookmark: a #GBookmarkFile
2447  * @uri: a valid URI
2448  * @is_private: %TRUE if the bookmark should be marked as private
2449  *
2450  * Sets the private flag of the bookmark for @uri.
2451  *
2452  * If a bookmark for @uri cannot be found then it is created.
2453  *
2454  * Since: 2.12
2455  */
2456 void
2457 g_bookmark_file_set_is_private (GBookmarkFile *bookmark,
2458         const gchar   *uri,
2459         gboolean       is_private)
2460 {
2461   BookmarkItem *item;
2462 
2463   g_return_if_fail (bookmark != NULL);
2464   g_return_if_fail (uri != NULL);
2465 
2466   item = g_bookmark_file_lookup_item (bookmark, uri);
2467   if (!item)
2468     {
2469       item = bookmark_item_new (uri);
2470       g_bookmark_file_add_item (bookmark, item, NULL);
2471     }
2472 
2473   if (!item-&gt;metadata)
2474     item-&gt;metadata = bookmark_metadata_new ();
2475 
2476   item-&gt;metadata-&gt;is_private = (is_private == TRUE);
2477   item-&gt;modified = time (NULL);
2478 }
2479 
2480 /**
2481  * g_bookmark_file_get_is_private:
2482  * @bookmark: a #GBookmarkFile
2483  * @uri: a valid URI
2484  * @error: return location for a #GError, or %NULL
2485  *
2486  * Gets whether the private flag of the bookmark for @uri is set.
2487  *
2488  * In the event the URI cannot be found, %FALSE is returned and
2489  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
2490  * event that the private flag cannot be found, %FALSE is returned and
2491  * @error is set to #G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
2492  *
2493  * Returns: %TRUE if the private flag is set, %FALSE otherwise.
2494  *
2495  * Since: 2.12
2496  */
2497 gboolean
2498 g_bookmark_file_get_is_private (GBookmarkFile  *bookmark,
2499         const gchar    *uri,
2500         GError        **error)
2501 {
2502   BookmarkItem *item;
2503 
2504   g_return_val_if_fail (bookmark != NULL, FALSE);
2505   g_return_val_if_fail (uri != NULL, FALSE);
2506 
2507   item = g_bookmark_file_lookup_item (bookmark, uri);
2508   if (!item)
2509     {
2510       g_set_error (error, G_BOOKMARK_FILE_ERROR,
2511        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
2512        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),
2513        uri);
2514       return FALSE;
2515     }
2516 
2517   if (!item-&gt;metadata)
2518     {
2519       g_set_error (error, G_BOOKMARK_FILE_ERROR,
2520        G_BOOKMARK_FILE_ERROR_INVALID_VALUE,
2521        _(&quot;No private flag has been defined in bookmark for URI &#39;%s&#39;&quot;),
2522         uri);
2523       return FALSE;
2524     }
2525 
2526   return item-&gt;metadata-&gt;is_private;
2527 }
2528 
2529 /**
2530  * g_bookmark_file_set_added:
2531  * @bookmark: a #GBookmarkFile
2532  * @uri: a valid URI
2533  * @added: a timestamp or -1 to use the current time
2534  *
2535  * Sets the time the bookmark for @uri was added into @bookmark.
2536  *
2537  * If no bookmark for @uri is found then it is created.
2538  *
2539  * Since: 2.12
2540  */
2541 void
2542 g_bookmark_file_set_added (GBookmarkFile *bookmark,
2543          const gchar   *uri,
2544          time_t         added)
2545 {
2546   BookmarkItem *item;
2547 
2548   g_return_if_fail (bookmark != NULL);
2549   g_return_if_fail (uri != NULL);
2550 
2551   item = g_bookmark_file_lookup_item (bookmark, uri);
2552   if (!item)
2553     {
2554       item = bookmark_item_new (uri);
2555       g_bookmark_file_add_item (bookmark, item, NULL);
2556     }
2557 
2558   if (added == (time_t) -1)
2559     time (&amp;added);
2560 
2561   item-&gt;added = added;
2562   item-&gt;modified = added;
2563 }
2564 
2565 /**
2566  * g_bookmark_file_get_added:
2567  * @bookmark: a #GBookmarkFile
2568  * @uri: a valid URI
2569  * @error: return location for a #GError, or %NULL
2570  *
2571  * Gets the time the bookmark for @uri was added to @bookmark
2572  *
2573  * In the event the URI cannot be found, -1 is returned and
2574  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2575  *
2576  * Returns: a timestamp
2577  *
2578  * Since: 2.12
2579  */
2580 time_t
2581 g_bookmark_file_get_added (GBookmarkFile  *bookmark,
2582          const gchar    *uri,
2583          GError        **error)
2584 {
2585   BookmarkItem *item;
2586 
2587   g_return_val_if_fail (bookmark != NULL, (time_t) -1);
2588   g_return_val_if_fail (uri != NULL, (time_t) -1);
2589 
2590   item = g_bookmark_file_lookup_item (bookmark, uri);
2591   if (!item)
2592     {
2593       g_set_error (error, G_BOOKMARK_FILE_ERROR,
2594        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
2595        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),
2596        uri);
2597       return (time_t) -1;
2598     }
2599 
2600   return item-&gt;added;
2601 }
2602 
2603 /**
2604  * g_bookmark_file_set_modified:
2605  * @bookmark: a #GBookmarkFile
2606  * @uri: a valid URI
2607  * @modified: a timestamp or -1 to use the current time
2608  *
2609  * Sets the last time the bookmark for @uri was last modified.
2610  *
2611  * If no bookmark for @uri is found then it is created.
2612  *
2613  * The &quot;modified&quot; time should only be set when the bookmark&#39;s meta-data
2614  * was actually changed.  Every function of #GBookmarkFile that
2615  * modifies a bookmark also changes the modification time, except for
2616  * g_bookmark_file_set_visited().
2617  *
2618  * Since: 2.12
2619  */
2620 void
2621 g_bookmark_file_set_modified (GBookmarkFile *bookmark,
2622             const gchar   *uri,
2623             time_t         modified)
2624 {
2625   BookmarkItem *item;
2626 
2627   g_return_if_fail (bookmark != NULL);
2628   g_return_if_fail (uri != NULL);
2629 
2630   item = g_bookmark_file_lookup_item (bookmark, uri);
2631   if (!item)
2632     {
2633       item = bookmark_item_new (uri);
2634       g_bookmark_file_add_item (bookmark, item, NULL);
2635     }
2636 
2637   if (modified == (time_t) -1)
2638     time (&amp;modified);
2639 
2640   item-&gt;modified = modified;
2641 }
2642 
2643 /**
2644  * g_bookmark_file_get_modified:
2645  * @bookmark: a #GBookmarkFile
2646  * @uri: a valid URI
2647  * @error: return location for a #GError, or %NULL
2648  *
2649  * Gets the time when the bookmark for @uri was last modified.
2650  *
2651  * In the event the URI cannot be found, -1 is returned and
2652  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2653  *
2654  * Returns: a timestamp
2655  *
2656  * Since: 2.12
2657  */
2658 time_t
2659 g_bookmark_file_get_modified (GBookmarkFile  *bookmark,
2660             const gchar    *uri,
2661             GError        **error)
2662 {
2663   BookmarkItem *item;
2664 
2665   g_return_val_if_fail (bookmark != NULL, (time_t) -1);
2666   g_return_val_if_fail (uri != NULL, (time_t) -1);
2667 
2668   item = g_bookmark_file_lookup_item (bookmark, uri);
2669   if (!item)
2670     {
2671       g_set_error (error, G_BOOKMARK_FILE_ERROR,
2672        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
2673        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),
2674        uri);
2675       return (time_t) -1;
2676     }
2677 
2678   return item-&gt;modified;
2679 }
2680 
2681 /**
2682  * g_bookmark_file_set_visited:
2683  * @bookmark: a #GBookmarkFile
2684  * @uri: a valid URI
2685  * @visited: a timestamp or -1 to use the current time
2686  *
2687  * Sets the time the bookmark for @uri was last visited.
2688  *
2689  * If no bookmark for @uri is found then it is created.
2690  *
2691  * The &quot;visited&quot; time should only be set if the bookmark was launched,
2692  * either using the command line retrieved by g_bookmark_file_get_app_info()
2693  * or by the default application for the bookmark&#39;s MIME type, retrieved
2694  * using g_bookmark_file_get_mime_type().  Changing the &quot;visited&quot; time
2695  * does not affect the &quot;modified&quot; time.
2696  *
2697  * Since: 2.12
2698  */
2699 void
2700 g_bookmark_file_set_visited (GBookmarkFile *bookmark,
2701            const gchar   *uri,
2702            time_t         visited)
2703 {
2704   BookmarkItem *item;
2705 
2706   g_return_if_fail (bookmark != NULL);
2707   g_return_if_fail (uri != NULL);
2708 
2709   item = g_bookmark_file_lookup_item (bookmark, uri);
2710   if (!item)
2711     {
2712       item = bookmark_item_new (uri);
2713       g_bookmark_file_add_item (bookmark, item, NULL);
2714     }
2715 
2716   if (visited == (time_t) -1)
2717     time (&amp;visited);
2718 
2719   item-&gt;visited = visited;
2720 }
2721 
2722 /**
2723  * g_bookmark_file_get_visited:
2724  * @bookmark: a #GBookmarkFile
2725  * @uri: a valid URI
2726  * @error: return location for a #GError, or %NULL
2727  *
2728  * Gets the time the bookmark for @uri was last visited.
2729  *
2730  * In the event the URI cannot be found, -1 is returned and
2731  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2732  *
2733  * Returns: a timestamp.
2734  *
2735  * Since: 2.12
2736  */
2737 time_t
2738 g_bookmark_file_get_visited (GBookmarkFile  *bookmark,
2739            const gchar    *uri,
2740            GError        **error)
2741 {
2742   BookmarkItem *item;
2743 
2744   g_return_val_if_fail (bookmark != NULL, (time_t) -1);
2745   g_return_val_if_fail (uri != NULL, (time_t) -1);
2746 
2747   item = g_bookmark_file_lookup_item (bookmark, uri);
2748   if (!item)
2749     {
2750       g_set_error (error, G_BOOKMARK_FILE_ERROR,
2751        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
2752        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),
2753        uri);
2754       return (time_t) -1;
2755     }
2756 
2757   return item-&gt;visited;
2758 }
2759 
2760 /**
2761  * g_bookmark_file_has_group:
2762  * @bookmark: a #GBookmarkFile
2763  * @uri: a valid URI
2764  * @group: the group name to be searched
2765  * @error: return location for a #GError, or %NULL
2766  *
2767  * Checks whether @group appears in the list of groups to which
2768  * the bookmark for @uri belongs to.
2769  *
2770  * In the event the URI cannot be found, %FALSE is returned and
2771  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2772  *
2773  * Returns: %TRUE if @group was found.
2774  *
2775  * Since: 2.12
2776  */
2777 gboolean
2778 g_bookmark_file_has_group (GBookmarkFile  *bookmark,
2779          const gchar    *uri,
2780          const gchar    *group,
2781          GError        **error)
2782 {
2783   BookmarkItem *item;
2784   GList *l;
2785 
2786   g_return_val_if_fail (bookmark != NULL, FALSE);
2787   g_return_val_if_fail (uri != NULL, FALSE);
2788 
2789   item = g_bookmark_file_lookup_item (bookmark, uri);
2790   if (!item)
2791     {
2792       g_set_error (error, G_BOOKMARK_FILE_ERROR,
2793        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
2794        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),
2795        uri);
2796       return FALSE;
2797     }
2798 
2799   if (!item-&gt;metadata)
2800     return FALSE;
2801 
2802   for (l = item-&gt;metadata-&gt;groups; l != NULL; l = l-&gt;next)
2803     {
2804       if (strcmp (l-&gt;data, group) == 0)
2805         return TRUE;
2806     }
2807 
2808   return FALSE;
2809 
2810 }
2811 
2812 /**
2813  * g_bookmark_file_add_group:
2814  * @bookmark: a #GBookmarkFile
2815  * @uri: a valid URI
2816  * @group: the group name to be added
2817  *
2818  * Adds @group to the list of groups to which the bookmark for @uri
2819  * belongs to.
2820  *
2821  * If no bookmark for @uri is found then it is created.
2822  *
2823  * Since: 2.12
2824  */
2825 void
2826 g_bookmark_file_add_group (GBookmarkFile *bookmark,
2827          const gchar   *uri,
2828          const gchar   *group)
2829 {
2830   BookmarkItem *item;
2831 
2832   g_return_if_fail (bookmark != NULL);
2833   g_return_if_fail (uri != NULL);
2834   g_return_if_fail (group != NULL &amp;&amp; group[0] != &#39;\0&#39;);
2835 
2836   item = g_bookmark_file_lookup_item (bookmark, uri);
2837   if (!item)
2838     {
2839       item = bookmark_item_new (uri);
2840       g_bookmark_file_add_item (bookmark, item, NULL);
2841     }
2842 
2843   if (!item-&gt;metadata)
2844     item-&gt;metadata = bookmark_metadata_new ();
2845 
2846   if (!g_bookmark_file_has_group (bookmark, uri, group, NULL))
2847     {
2848       item-&gt;metadata-&gt;groups = g_list_prepend (item-&gt;metadata-&gt;groups,
2849                                                g_strdup (group));
2850 
2851       item-&gt;modified = time (NULL);
2852     }
2853 }
2854 
2855 /**
2856  * g_bookmark_file_remove_group:
2857  * @bookmark: a #GBookmarkFile
2858  * @uri: a valid URI
2859  * @group: the group name to be removed
2860  * @error: return location for a #GError, or %NULL
2861  *
2862  * Removes @group from the list of groups to which the bookmark
2863  * for @uri belongs to.
2864  *
2865  * In the event the URI cannot be found, %FALSE is returned and
2866  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2867  * In the event no group was defined, %FALSE is returned and
2868  * @error is set to #G_BOOKMARK_FILE_ERROR_INVALID_VALUE.
2869  *
2870  * Returns: %TRUE if @group was successfully removed.
2871  *
2872  * Since: 2.12
2873  */
2874 gboolean
2875 g_bookmark_file_remove_group (GBookmarkFile  *bookmark,
2876             const gchar    *uri,
2877             const gchar    *group,
2878             GError        **error)
2879 {
2880   BookmarkItem *item;
2881   GList *l;
2882 
2883   g_return_val_if_fail (bookmark != NULL, FALSE);
2884   g_return_val_if_fail (uri != NULL, FALSE);
2885 
2886   item = g_bookmark_file_lookup_item (bookmark, uri);
2887   if (!item)
2888     {
2889       g_set_error (error, G_BOOKMARK_FILE_ERROR,
2890        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
2891        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),
2892        uri);
2893       return FALSE;
2894     }
2895 
2896   if (!item-&gt;metadata)
2897     {
2898       g_set_error (error, G_BOOKMARK_FILE_ERROR,
2899                    G_BOOKMARK_FILE_ERROR_INVALID_VALUE,
2900                    _(&quot;No groups set in bookmark for URI &#39;%s&#39;&quot;),
2901                    uri);
2902       return FALSE;
2903     }
2904 
2905   for (l = item-&gt;metadata-&gt;groups; l != NULL; l = l-&gt;next)
2906     {
2907       if (strcmp (l-&gt;data, group) == 0)
2908         {
2909           item-&gt;metadata-&gt;groups = g_list_remove_link (item-&gt;metadata-&gt;groups, l);
2910           g_free (l-&gt;data);
2911     g_list_free_1 (l);
2912 
2913           item-&gt;modified = time (NULL);
2914 
2915           return TRUE;
2916         }
2917     }
2918 
2919   return FALSE;
2920 }
2921 
2922 /**
2923  * g_bookmark_file_set_groups:
2924  * @bookmark: a #GBookmarkFile
2925  * @uri: an item&#39;s URI
2926  * @groups: (nullable) (array length=length) (element-type utf8): an array of
2927  *    group names, or %NULL to remove all groups
2928  * @length: number of group name values in @groups
2929  *
2930  * Sets a list of group names for the item with URI @uri.  Each previously
2931  * set group name list is removed.
2932  *
2933  * If @uri cannot be found then an item for it is created.
2934  *
2935  * Since: 2.12
2936  */
2937 void
2938 g_bookmark_file_set_groups (GBookmarkFile  *bookmark,
2939           const gchar    *uri,
2940           const gchar   **groups,
2941           gsize           length)
2942 {
2943   BookmarkItem *item;
2944   gsize i;
2945 
2946   g_return_if_fail (bookmark != NULL);
2947   g_return_if_fail (uri != NULL);
2948   g_return_if_fail (groups != NULL);
2949 
2950   item = g_bookmark_file_lookup_item (bookmark, uri);
2951   if (!item)
2952     {
2953       item = bookmark_item_new (uri);
2954       g_bookmark_file_add_item (bookmark, item, NULL);
2955     }
2956 
2957   if (!item-&gt;metadata)
2958     item-&gt;metadata = bookmark_metadata_new ();
2959 
2960   g_list_free_full (item-&gt;metadata-&gt;groups, g_free);
2961   item-&gt;metadata-&gt;groups = NULL;
2962 
2963   if (groups)
2964     {
2965       for (i = 0; i &lt; length &amp;&amp; groups[i] != NULL; i++)
2966         item-&gt;metadata-&gt;groups = g_list_append (item-&gt;metadata-&gt;groups,
2967                   g_strdup (groups[i]));
2968     }
2969 
2970   item-&gt;modified = time (NULL);
2971 }
2972 
2973 /**
2974  * g_bookmark_file_get_groups:
2975  * @bookmark: a #GBookmarkFile
2976  * @uri: a valid URI
2977  * @length: (out) (optional): return location for the length of the returned string, or %NULL
2978  * @error: return location for a #GError, or %NULL
2979  *
2980  * Retrieves the list of group names of the bookmark for @uri.
2981  *
2982  * In the event the URI cannot be found, %NULL is returned and
2983  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
2984  *
2985  * The returned array is %NULL terminated, so @length may optionally
2986  * be %NULL.
2987  *
2988  * Returns: (array length=length) (transfer full): a newly allocated %NULL-terminated array of group names.
2989  *   Use g_strfreev() to free it.
2990  *
2991  * Since: 2.12
2992  */
2993 gchar **
2994 g_bookmark_file_get_groups (GBookmarkFile  *bookmark,
2995           const gchar    *uri,
2996           gsize          *length,
2997           GError        **error)
2998 {
2999   BookmarkItem *item;
3000   GList *l;
3001   gsize len, i;
3002   gchar **retval;
3003 
3004   g_return_val_if_fail (bookmark != NULL, NULL);
3005   g_return_val_if_fail (uri != NULL, NULL);
3006 
3007   item = g_bookmark_file_lookup_item (bookmark, uri);
3008   if (!item)
3009     {
3010       g_set_error (error, G_BOOKMARK_FILE_ERROR,
3011        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
3012        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),
3013        uri);
3014       return NULL;
3015     }
3016 
3017   if (!item-&gt;metadata)
3018     {
3019       if (length)
3020   *length = 0;
3021 
3022       return NULL;
3023     }
3024 
3025   len = g_list_length (item-&gt;metadata-&gt;groups);
3026   retval = g_new0 (gchar *, len + 1);
3027   for (l = g_list_last (item-&gt;metadata-&gt;groups), i = 0;
3028        l != NULL;
3029        l = l-&gt;prev)
3030     {
3031       gchar *group_name = (gchar *) l-&gt;data;
3032 
3033       g_warn_if_fail (group_name != NULL);
3034 
3035       retval[i++] = g_strdup (group_name);
3036     }
3037   retval[i] = NULL;
3038 
3039   if (length)
3040     *length = len;
3041 
3042   return retval;
3043 }
3044 
3045 /**
3046  * g_bookmark_file_add_application:
3047  * @bookmark: a #GBookmarkFile
3048  * @uri: a valid URI
3049  * @name: (nullable): the name of the application registering the bookmark
3050  *   or %NULL
3051  * @exec: (nullable): command line to be used to launch the bookmark or %NULL
3052  *
3053  * Adds the application with @name and @exec to the list of
3054  * applications that have registered a bookmark for @uri into
3055  * @bookmark.
3056  *
3057  * Every bookmark inside a #GBookmarkFile must have at least an
3058  * application registered.  Each application must provide a name, a
3059  * command line useful for launching the bookmark, the number of times
3060  * the bookmark has been registered by the application and the last
3061  * time the application registered this bookmark.
3062  *
3063  * If @name is %NULL, the name of the application will be the
3064  * same returned by g_get_application_name(); if @exec is %NULL, the
3065  * command line will be a composition of the program name as
3066  * returned by g_get_prgname() and the &quot;\%u&quot; modifier, which will be
3067  * expanded to the bookmark&#39;s URI.
3068  *
3069  * This function will automatically take care of updating the
3070  * registrations count and timestamping in case an application
3071  * with the same @name had already registered a bookmark for
3072  * @uri inside @bookmark.
3073  *
3074  * If no bookmark for @uri is found, one is created.
3075  *
3076  * Since: 2.12
3077  */
3078 void
3079 g_bookmark_file_add_application (GBookmarkFile *bookmark,
3080          const gchar   *uri,
3081          const gchar   *name,
3082          const gchar   *exec)
3083 {
3084   BookmarkItem *item;
3085   gchar *app_name, *app_exec;
3086 
3087   g_return_if_fail (bookmark != NULL);
3088   g_return_if_fail (uri != NULL);
3089 
3090   item = g_bookmark_file_lookup_item (bookmark, uri);
3091   if (!item)
3092     {
3093       item = bookmark_item_new (uri);
3094       g_bookmark_file_add_item (bookmark, item, NULL);
3095     }
3096 
3097   if (name &amp;&amp; name[0] != &#39;\0&#39;)
3098     app_name = g_strdup (name);
3099   else
3100     app_name = g_strdup (g_get_application_name ());
3101 
3102   if (exec &amp;&amp; exec[0] != &#39;\0&#39;)
3103     app_exec = g_strdup (exec);
3104   else
3105     app_exec = g_strjoin (&quot; &quot;, g_get_prgname(), &quot;%u&quot;, NULL);
3106 
3107   g_bookmark_file_set_app_info (bookmark, uri,
3108                                 app_name,
3109                                 app_exec,
3110                                 -1,
3111                                 (time_t) -1,
3112                                 NULL);
3113 
3114   g_free (app_exec);
3115   g_free (app_name);
3116 }
3117 
3118 /**
3119  * g_bookmark_file_remove_application:
3120  * @bookmark: a #GBookmarkFile
3121  * @uri: a valid URI
3122  * @name: the name of the application
3123  * @error: return location for a #GError or %NULL
3124  *
3125  * Removes application registered with @name from the list of applications
3126  * that have registered a bookmark for @uri inside @bookmark.
3127  *
3128  * In the event the URI cannot be found, %FALSE is returned and
3129  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3130  * In the event that no application with name @app_name has registered
3131  * a bookmark for @uri,  %FALSE is returned and error is set to
3132  * #G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.
3133  *
3134  * Returns: %TRUE if the application was successfully removed.
3135  *
3136  * Since: 2.12
3137  */
3138 gboolean
3139 g_bookmark_file_remove_application (GBookmarkFile  *bookmark,
3140             const gchar    *uri,
3141             const gchar    *name,
3142             GError        **error)
3143 {
3144   GError *set_error;
3145   gboolean retval;
3146 
3147   g_return_val_if_fail (bookmark != NULL, FALSE);
3148   g_return_val_if_fail (uri != NULL, FALSE);
3149   g_return_val_if_fail (name != NULL, FALSE);
3150 
3151   set_error = NULL;
3152   retval = g_bookmark_file_set_app_info (bookmark, uri,
3153              name,
3154              &quot;&quot;,
3155              0,
3156              (time_t) -1,
3157              &amp;set_error);
3158   if (set_error)
3159     {
3160       g_propagate_error (error, set_error);
3161 
3162       return FALSE;
3163     }
3164 
3165   return retval;
3166 }
3167 
3168 /**
3169  * g_bookmark_file_has_application:
3170  * @bookmark: a #GBookmarkFile
3171  * @uri: a valid URI
3172  * @name: the name of the application
3173  * @error: return location for a #GError or %NULL
3174  *
3175  * Checks whether the bookmark for @uri inside @bookmark has been
3176  * registered by application @name.
3177  *
3178  * In the event the URI cannot be found, %FALSE is returned and
3179  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3180  *
3181  * Returns: %TRUE if the application @name was found
3182  *
3183  * Since: 2.12
3184  */
3185 gboolean
3186 g_bookmark_file_has_application (GBookmarkFile  *bookmark,
3187          const gchar    *uri,
3188          const gchar    *name,
3189          GError        **error)
3190 {
3191   BookmarkItem *item;
3192 
3193   g_return_val_if_fail (bookmark != NULL, FALSE);
3194   g_return_val_if_fail (uri != NULL, FALSE);
3195   g_return_val_if_fail (name != NULL, FALSE);
3196 
3197   item = g_bookmark_file_lookup_item (bookmark, uri);
3198   if (!item)
3199     {
3200       g_set_error (error, G_BOOKMARK_FILE_ERROR,
3201        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
3202        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),
3203        uri);
3204       return FALSE;
3205     }
3206 
3207   return (NULL != bookmark_item_lookup_app_info (item, name));
3208 }
3209 
3210 /**
3211  * g_bookmark_file_set_app_info:
3212  * @bookmark: a #GBookmarkFile
3213  * @uri: a valid URI
3214  * @name: an application&#39;s name
3215  * @exec: an application&#39;s command line
3216  * @count: the number of registrations done for this application
3217  * @stamp: the time of the last registration for this application
3218  * @error: return location for a #GError or %NULL
3219  *
3220  * Sets the meta-data of application @name inside the list of
3221  * applications that have registered a bookmark for @uri inside
3222  * @bookmark.
3223  *
3224  * You should rarely use this function; use g_bookmark_file_add_application()
3225  * and g_bookmark_file_remove_application() instead.
3226  *
3227  * @name can be any UTF-8 encoded string used to identify an
3228  * application.
3229  * @exec can have one of these two modifiers: &quot;\%f&quot;, which will
3230  * be expanded as the local file name retrieved from the bookmark&#39;s
3231  * URI; &quot;\%u&quot;, which will be expanded as the bookmark&#39;s URI.
3232  * The expansion is done automatically when retrieving the stored
3233  * command line using the g_bookmark_file_get_app_info() function.
3234  * @count is the number of times the application has registered the
3235  * bookmark; if is &lt; 0, the current registration count will be increased
3236  * by one, if is 0, the application with @name will be removed from
3237  * the list of registered applications.
3238  * @stamp is the Unix time of the last registration; if it is -1, the
3239  * current time will be used.
3240  *
3241  * If you try to remove an application by setting its registration count to
3242  * zero, and no bookmark for @uri is found, %FALSE is returned and
3243  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND; similarly,
3244  * in the event that no application @name has registered a bookmark
3245  * for @uri,  %FALSE is returned and error is set to
3246  * #G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED.  Otherwise, if no bookmark
3247  * for @uri is found, one is created.
3248  *
3249  * Returns: %TRUE if the application&#39;s meta-data was successfully
3250  *   changed.
3251  *
3252  * Since: 2.12
3253  */
3254 gboolean
3255 g_bookmark_file_set_app_info (GBookmarkFile  *bookmark,
3256             const gchar    *uri,
3257             const gchar    *name,
3258             const gchar    *exec,
3259             gint            count,
3260             time_t          stamp,
3261             GError        **error)
3262 {
3263   BookmarkItem *item;
3264   BookmarkAppInfo *ai;
3265 
3266   g_return_val_if_fail (bookmark != NULL, FALSE);
3267   g_return_val_if_fail (uri != NULL, FALSE);
3268   g_return_val_if_fail (name != NULL, FALSE);
3269   g_return_val_if_fail (exec != NULL, FALSE);
3270 
3271   item = g_bookmark_file_lookup_item (bookmark, uri);
3272   if (!item)
3273     {
3274       if (count == 0)
3275         {
3276           g_set_error (error, G_BOOKMARK_FILE_ERROR,
3277            G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
3278            _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),
3279            uri);
3280     return FALSE;
3281   }
3282       else
3283         {
3284           item = bookmark_item_new (uri);
3285     g_bookmark_file_add_item (bookmark, item, NULL);
3286   }
3287     }
3288 
3289   if (!item-&gt;metadata)
3290     item-&gt;metadata = bookmark_metadata_new ();
3291 
3292   ai = bookmark_item_lookup_app_info (item, name);
3293   if (!ai)
3294     {
3295       if (count == 0)
3296         {
3297           g_set_error (error, G_BOOKMARK_FILE_ERROR,
3298            G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED,
3299            _(&quot;No application with name &#39;%s&#39; registered a bookmark for &#39;%s&#39;&quot;),
3300            name,
3301            uri);
3302           return FALSE;
3303         }
3304       else
3305         {
3306           ai = bookmark_app_info_new (name);
3307 #ifdef GSTREAMER_LITE
3308           if (ai == NULL) {
3309             return FALSE;
3310           }
3311 #endif // GSTREAMER_LITE
3312 
3313           item-&gt;metadata-&gt;applications = g_list_prepend (item-&gt;metadata-&gt;applications, ai);
3314           g_hash_table_replace (item-&gt;metadata-&gt;apps_by_name, ai-&gt;name, ai);
3315         }
3316     }
3317 
3318   if (count == 0)
3319     {
3320       item-&gt;metadata-&gt;applications = g_list_remove (item-&gt;metadata-&gt;applications, ai);
3321       g_hash_table_remove (item-&gt;metadata-&gt;apps_by_name, ai-&gt;name);
3322       bookmark_app_info_free (ai);
3323 
3324       item-&gt;modified = time (NULL);
3325 
3326       return TRUE;
3327     }
3328   else if (count &gt; 0)
3329     ai-&gt;count = count;
3330   else
3331     ai-&gt;count += 1;
3332 
3333   if (stamp != (time_t) -1)
3334     ai-&gt;stamp = stamp;
3335   else
3336     ai-&gt;stamp = time (NULL);
3337 
3338   if (exec &amp;&amp; exec[0] != &#39;\0&#39;)
3339     {
3340       g_free (ai-&gt;exec);
3341       ai-&gt;exec = g_shell_quote (exec);
3342     }
3343 
3344   item-&gt;modified = time (NULL);
3345 
3346   return TRUE;
3347 }
3348 
3349 /* expands the application&#39;s command line */
3350 static gchar *
3351 expand_exec_line (const gchar *exec_fmt,
3352       const gchar *uri)
3353 {
3354   GString *exec;
3355   gchar ch;
3356 
3357   exec = g_string_sized_new (512);
3358   while ((ch = *exec_fmt++) != &#39;\0&#39;)
3359    {
3360      if (ch != &#39;%&#39;)
3361        {
3362          exec = g_string_append_c (exec, ch);
3363          continue;
3364        }
3365 
3366      ch = *exec_fmt++;
3367      switch (ch)
3368        {
3369        case &#39;\0&#39;:
3370    goto out;
3371        case &#39;U&#39;:
3372        case &#39;u&#39;:
3373          g_string_append (exec, uri);
3374          break;
3375        case &#39;F&#39;:
3376        case &#39;f&#39;:
3377          {
3378      gchar *file = g_filename_from_uri (uri, NULL, NULL);
3379            if (file)
3380              {
3381          g_string_append (exec, file);
3382          g_free (file);
3383              }
3384            else
3385              {
3386                g_string_free (exec, TRUE);
3387                return NULL;
3388              }
3389          }
3390          break;
3391        case &#39;%&#39;:
3392        default:
3393          exec = g_string_append_c (exec, ch);
3394          break;
3395        }
3396    }
3397 
3398  out:
3399   return g_string_free (exec, FALSE);
3400 }
3401 
3402 /**
3403  * g_bookmark_file_get_app_info:
3404  * @bookmark: a #GBookmarkFile
3405  * @uri: a valid URI
3406  * @name: an application&#39;s name
3407  * @exec: (out) (optional): return location for the command line of the application, or %NULL
3408  * @count: (out) (optional): return location for the registration count, or %NULL
3409  * @stamp: (out) (optional): return location for the last registration time, or %NULL
3410  * @error: return location for a #GError, or %NULL
3411  *
3412  * Gets the registration information of @app_name for the bookmark for
3413  * @uri.  See g_bookmark_file_set_app_info() for more information about
3414  * the returned data.
3415  *
3416  * The string returned in @app_exec must be freed.
3417  *
3418  * In the event the URI cannot be found, %FALSE is returned and
3419  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.  In the
3420  * event that no application with name @app_name has registered a bookmark
3421  * for @uri,  %FALSE is returned and error is set to
3422  * #G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED. In the event that unquoting
3423  * the command line fails, an error of the #G_SHELL_ERROR domain is
3424  * set and %FALSE is returned.
3425  *
3426  * Returns: %TRUE on success.
3427  *
3428  * Since: 2.12
3429  */
3430 gboolean
3431 g_bookmark_file_get_app_info (GBookmarkFile  *bookmark,
3432             const gchar    *uri,
3433             const gchar    *name,
3434             gchar         **exec,
3435             guint          *count,
3436             time_t         *stamp,
3437             GError        **error)
3438 {
3439   BookmarkItem *item;
3440   BookmarkAppInfo *ai;
3441 
3442   g_return_val_if_fail (bookmark != NULL, FALSE);
3443   g_return_val_if_fail (uri != NULL, FALSE);
3444   g_return_val_if_fail (name != NULL, FALSE);
3445 
3446   item = g_bookmark_file_lookup_item (bookmark, uri);
3447   if (!item)
3448     {
3449       g_set_error (error, G_BOOKMARK_FILE_ERROR,
3450        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
3451        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),
3452        uri);
3453       return FALSE;
3454     }
3455 
3456   ai = bookmark_item_lookup_app_info (item, name);
3457   if (!ai)
3458     {
3459       g_set_error (error, G_BOOKMARK_FILE_ERROR,
3460        G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED,
3461        _(&quot;No application with name &#39;%s&#39; registered a bookmark for &#39;%s&#39;&quot;),
3462        name,
3463        uri);
3464       return FALSE;
3465     }
3466 
3467   if (exec)
3468     {
3469       GError *unquote_error = NULL;
3470       gchar *command_line;
3471 
3472       command_line = g_shell_unquote (ai-&gt;exec, &amp;unquote_error);
3473       if (unquote_error)
3474         {
3475           g_propagate_error (error, unquote_error);
3476           return FALSE;
3477         }
3478 
3479       *exec = expand_exec_line (command_line, uri);
3480       if (!*exec)
3481         {
3482           g_set_error (error, G_BOOKMARK_FILE_ERROR,
3483            G_BOOKMARK_FILE_ERROR_INVALID_URI,
3484            _(&quot;Failed to expand exec line &#39;%s&#39; with URI &#39;%s&#39;&quot;),
3485          ai-&gt;exec, uri);
3486           g_free (command_line);
3487 
3488           return FALSE;
3489         }
3490       else
3491         g_free (command_line);
3492     }
3493 
3494   if (count)
3495     *count = ai-&gt;count;
3496 
3497   if (stamp)
3498     *stamp = ai-&gt;stamp;
3499 
3500   return TRUE;
3501 }
3502 
3503 /**
3504  * g_bookmark_file_get_applications:
3505  * @bookmark: a #GBookmarkFile
3506  * @uri: a valid URI
3507  * @length: (out) (optional): return location of the length of the returned list, or %NULL
3508  * @error: return location for a #GError, or %NULL
3509  *
3510  * Retrieves the names of the applications that have registered the
3511  * bookmark for @uri.
3512  *
3513  * In the event the URI cannot be found, %NULL is returned and
3514  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3515  *
3516  * Returns: (array length=length) (transfer full): a newly allocated %NULL-terminated array of strings.
3517  *   Use g_strfreev() to free it.
3518  *
3519  * Since: 2.12
3520  */
3521 gchar **
3522 g_bookmark_file_get_applications (GBookmarkFile  *bookmark,
3523           const gchar    *uri,
3524           gsize          *length,
3525           GError        **error)
3526 {
3527   BookmarkItem *item;
3528   GList *l;
3529   gchar **apps;
3530   gsize i, n_apps;
3531 
3532   g_return_val_if_fail (bookmark != NULL, NULL);
3533   g_return_val_if_fail (uri != NULL, NULL);
3534 
3535   item = g_bookmark_file_lookup_item (bookmark, uri);
3536   if (!item)
3537     {
3538       g_set_error (error, G_BOOKMARK_FILE_ERROR,
3539        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
3540        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),
3541        uri);
3542       return NULL;
3543     }
3544 
3545   if (!item-&gt;metadata)
3546     {
3547       if (length)
3548   *length = 0;
3549 
3550       return NULL;
3551     }
3552 
3553   n_apps = g_list_length (item-&gt;metadata-&gt;applications);
3554   apps = g_new0 (gchar *, n_apps + 1);
3555 
3556   for (l = g_list_last (item-&gt;metadata-&gt;applications), i = 0;
3557        l != NULL;
3558        l = l-&gt;prev)
3559     {
3560       BookmarkAppInfo *ai;
3561 
3562       ai = (BookmarkAppInfo *) l-&gt;data;
3563 
3564       g_warn_if_fail (ai != NULL);
3565       g_warn_if_fail (ai-&gt;name != NULL);
3566 
3567       apps[i++] = g_strdup (ai-&gt;name);
3568     }
3569   apps[i] = NULL;
3570 
3571   if (length)
3572     *length = i;
3573 
3574   return apps;
3575 }
3576 
3577 /**
3578  * g_bookmark_file_get_size:
3579  * @bookmark: a #GBookmarkFile
3580  *
3581  * Gets the number of bookmarks inside @bookmark.
3582  *
3583  * Returns: the number of bookmarks
3584  *
3585  * Since: 2.12
3586  */
3587 gint
3588 g_bookmark_file_get_size (GBookmarkFile *bookmark)
3589 {
3590   g_return_val_if_fail (bookmark != NULL, 0);
3591 
3592   return g_list_length (bookmark-&gt;items);
3593 }
3594 
3595 /**
3596  * g_bookmark_file_move_item:
3597  * @bookmark: a #GBookmarkFile
3598  * @old_uri: a valid URI
3599  * @new_uri: (nullable): a valid URI, or %NULL
3600  * @error: return location for a #GError or %NULL
3601  *
3602  * Changes the URI of a bookmark item from @old_uri to @new_uri.  Any
3603  * existing bookmark for @new_uri will be overwritten.  If @new_uri is
3604  * %NULL, then the bookmark is removed.
3605  *
3606  * In the event the URI cannot be found, %FALSE is returned and
3607  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3608  *
3609  * Returns: %TRUE if the URI was successfully changed
3610  *
3611  * Since: 2.12
3612  */
3613 gboolean
3614 g_bookmark_file_move_item (GBookmarkFile  *bookmark,
3615          const gchar    *old_uri,
3616          const gchar    *new_uri,
3617          GError        **error)
3618 {
3619   BookmarkItem *item;
3620 
3621   g_return_val_if_fail (bookmark != NULL, FALSE);
3622   g_return_val_if_fail (old_uri != NULL, FALSE);
3623 
3624   item = g_bookmark_file_lookup_item (bookmark, old_uri);
3625   if (!item)
3626     {
3627       g_set_error (error, G_BOOKMARK_FILE_ERROR,
3628        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
3629        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),
3630        old_uri);
3631       return FALSE;
3632     }
3633 
3634   if (new_uri &amp;&amp; new_uri[0] != &#39;\0&#39;)
3635     {
3636       if (g_strcmp0 (old_uri, new_uri) == 0)
3637         return TRUE;
3638 
3639       if (g_bookmark_file_has_item (bookmark, new_uri))
3640         {
3641           if (!g_bookmark_file_remove_item (bookmark, new_uri, error))
3642             return FALSE;
3643         }
3644 
3645       g_hash_table_steal (bookmark-&gt;items_by_uri, item-&gt;uri);
3646 
3647       g_free (item-&gt;uri);
3648       item-&gt;uri = g_strdup (new_uri);
3649       item-&gt;modified = time (NULL);
3650 
3651       g_hash_table_replace (bookmark-&gt;items_by_uri, item-&gt;uri, item);
3652 
3653       return TRUE;
3654     }
3655   else
3656     {
3657       if (!g_bookmark_file_remove_item (bookmark, old_uri, error))
3658         return FALSE;
3659 
3660       return TRUE;
3661     }
3662 }
3663 
3664 /**
3665  * g_bookmark_file_set_icon:
3666  * @bookmark: a #GBookmarkFile
3667  * @uri: a valid URI
3668  * @href: (nullable): the URI of the icon for the bookmark, or %NULL
3669  * @mime_type: the MIME type of the icon for the bookmark
3670  *
3671  * Sets the icon for the bookmark for @uri. If @href is %NULL, unsets
3672  * the currently set icon. @href can either be a full URL for the icon
3673  * file or the icon name following the Icon Naming specification.
3674  *
3675  * If no bookmark for @uri is found one is created.
3676  *
3677  * Since: 2.12
3678  */
3679 void
3680 g_bookmark_file_set_icon (GBookmarkFile *bookmark,
3681         const gchar   *uri,
3682         const gchar   *href,
3683         const gchar   *mime_type)
3684 {
3685   BookmarkItem *item;
3686 
3687   g_return_if_fail (bookmark != NULL);
3688   g_return_if_fail (uri != NULL);
3689 
3690   item = g_bookmark_file_lookup_item (bookmark, uri);
3691   if (!item)
3692     {
3693       item = bookmark_item_new (uri);
3694       g_bookmark_file_add_item (bookmark, item, NULL);
3695     }
3696 
3697   if (!item-&gt;metadata)
3698     item-&gt;metadata = bookmark_metadata_new ();
3699 
3700   g_free (item-&gt;metadata-&gt;icon_href);
3701   g_free (item-&gt;metadata-&gt;icon_mime);
3702 
3703   item-&gt;metadata-&gt;icon_href = g_strdup (href);
3704 
3705   if (mime_type &amp;&amp; mime_type[0] != &#39;\0&#39;)
3706     item-&gt;metadata-&gt;icon_mime = g_strdup (mime_type);
3707   else
3708     item-&gt;metadata-&gt;icon_mime = g_strdup (&quot;application/octet-stream&quot;);
3709 
3710   item-&gt;modified = time (NULL);
3711 }
3712 
3713 /**
3714  * g_bookmark_file_get_icon:
3715  * @bookmark: a #GBookmarkFile
3716  * @uri: a valid URI
3717  * @href: (out) (optional): return location for the icon&#39;s location or %NULL
3718  * @mime_type: (out) (optional): return location for the icon&#39;s MIME type or %NULL
3719  * @error: return location for a #GError or %NULL
3720  *
3721  * Gets the icon of the bookmark for @uri.
3722  *
3723  * In the event the URI cannot be found, %FALSE is returned and
3724  * @error is set to #G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND.
3725  *
3726  * Returns: %TRUE if the icon for the bookmark for the URI was found.
3727  *   You should free the returned strings.
3728  *
3729  * Since: 2.12
3730  */
3731 gboolean
3732 g_bookmark_file_get_icon (GBookmarkFile  *bookmark,
3733         const gchar    *uri,
3734         gchar         **href,
3735         gchar         **mime_type,
3736         GError        **error)
3737 {
3738   BookmarkItem *item;
3739 
3740   g_return_val_if_fail (bookmark != NULL, FALSE);
3741   g_return_val_if_fail (uri != NULL, FALSE);
3742 
3743   item = g_bookmark_file_lookup_item (bookmark, uri);
3744   if (!item)
3745     {
3746       g_set_error (error, G_BOOKMARK_FILE_ERROR,
3747        G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
3748        _(&quot;No bookmark found for URI &#39;%s&#39;&quot;),
3749        uri);
3750       return FALSE;
3751     }
3752 
3753   if ((!item-&gt;metadata) || (!item-&gt;metadata-&gt;icon_href))
3754     return FALSE;
3755 
3756   if (href)
3757     *href = g_strdup (item-&gt;metadata-&gt;icon_href);
3758 
3759   if (mime_type)
3760     *mime_type = g_strdup (item-&gt;metadata-&gt;icon_mime);
3761 
3762   return TRUE;
3763 }
    </pre>
  </body>
</html>