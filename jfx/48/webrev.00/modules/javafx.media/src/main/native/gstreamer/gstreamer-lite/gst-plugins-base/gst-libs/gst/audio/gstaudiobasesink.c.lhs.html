<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudiobasesink.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2005 Wim Taymans &lt;wim@fluendo.com&gt;
   4  *
   5  * gstaudiobasesink.c:
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 /**
  24  * SECTION:gstaudiobasesink
  25  * @title: GstAudioBaseSink
  26  * @short_description: Base class for audio sinks
  27  * @see_also: #GstAudioSink, #GstAudioRingBuffer.
  28  *
  29  * This is the base class for audio sinks. Subclasses need to implement the
  30  * ::create_ringbuffer vmethod. This base class will then take care of
  31  * writing samples to the ringbuffer, synchronisation, clipping and flushing.
  32  */
<a name="1" id="anc1"></a>


  33 
  34 #include &lt;string.h&gt;
  35 
  36 #include &lt;gst/audio/audio.h&gt;
  37 #include &quot;gstaudiobasesink.h&quot;
  38 
  39 GST_DEBUG_CATEGORY_STATIC (gst_audio_base_sink_debug);
  40 #define GST_CAT_DEFAULT gst_audio_base_sink_debug
  41 
<a name="2" id="anc2"></a><span class="line-removed">  42 #define GST_AUDIO_BASE_SINK_GET_PRIVATE(obj)  \</span>
<span class="line-removed">  43    (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_AUDIO_BASE_SINK, GstAudioBaseSinkPrivate))</span>
<span class="line-removed">  44 </span>
  45 struct _GstAudioBaseSinkPrivate
  46 {
  47   /* upstream latency */
  48   GstClockTime us_latency;
  49   /* the clock slaving algorithm in use */
  50   GstAudioBaseSinkSlaveMethod slave_method;
  51   /* running average of clock skew */
  52   GstClockTimeDiff avg_skew;
  53   /* the number of samples we aligned last time */
  54   gint64 last_align;
  55 
  56   gboolean sync_latency;
  57 
  58   GstClockTime eos_time;
  59 
  60   /* number of microseconds we allow clock slaving to drift
  61    * before resyncing */
  62   guint64 drift_tolerance;
  63 
  64   /* number of nanoseconds we allow timestamps to drift
  65    * before resyncing */
  66   GstClockTime alignment_threshold;
  67 
  68   /* time of the previous detected discont candidate */
  69   GstClockTime discont_time;
  70 
  71   /* number of nanoseconds to wait until creating a discontinuity */
  72   GstClockTime discont_wait;
  73 
  74   /* custom slaving algorithm callback */
  75   GstAudioBaseSinkCustomSlavingCallback custom_slaving_callback;
  76   gpointer custom_slaving_cb_data;
  77   GDestroyNotify custom_slaving_cb_notify;
  78 };
  79 
  80 /* BaseAudioSink signals and args */
  81 enum
  82 {
  83   /* FILL ME */
  84   LAST_SIGNAL
  85 };
  86 
  87 /* FIXME: 2.0, store the buffer_time and latency_time in nanoseconds */
  88 #define DEFAULT_BUFFER_TIME     ((200 * GST_MSECOND) / GST_USECOND)
  89 #ifdef GSTREAMER_LITE
  90 #define DEFAULT_LATENCY_TIME    ((40 * GST_MSECOND) / GST_USECOND)
  91 #else // GSTREAMER_LITE
  92 #define DEFAULT_LATENCY_TIME    ((10 * GST_MSECOND) / GST_USECOND)
  93 #endif // GSTREAMER_LITE
  94 #define DEFAULT_PROVIDE_CLOCK   TRUE
  95 #define DEFAULT_SLAVE_METHOD    GST_AUDIO_BASE_SINK_SLAVE_SKEW
  96 
  97 /* FIXME, enable pull mode when clock slaving and trick modes are figured out */
  98 #define DEFAULT_CAN_ACTIVATE_PULL FALSE
  99 
 100 /* when timestamps drift for more than 40ms we resync. This should
 101  * be enough to compensate for timestamp rounding errors. */
 102 #define DEFAULT_ALIGNMENT_THRESHOLD   (40 * GST_MSECOND)
 103 
 104 /* when clock slaving drift for more than 40ms we resync. This is
 105  * a reasonable default */
 106 #define DEFAULT_DRIFT_TOLERANCE   ((40 * GST_MSECOND) / GST_USECOND)
 107 
 108 /* allow for one second before resyncing to see if the timestamps drift will
 109  * fix itself, or is a permanent offset */
 110 #define DEFAULT_DISCONT_WAIT        (1 * GST_SECOND)
 111 
 112 enum
 113 {
 114   PROP_0,
 115 
 116   PROP_BUFFER_TIME,
 117   PROP_LATENCY_TIME,
 118   PROP_PROVIDE_CLOCK,
 119   PROP_SLAVE_METHOD,
 120   PROP_CAN_ACTIVATE_PULL,
 121   PROP_ALIGNMENT_THRESHOLD,
 122   PROP_DRIFT_TOLERANCE,
 123   PROP_DISCONT_WAIT,
 124 
 125   PROP_LAST
 126 };
 127 
 128 #define _do_init \
 129     GST_DEBUG_CATEGORY_INIT (gst_audio_base_sink_debug, &quot;audiobasesink&quot;, 0, &quot;audiobasesink element&quot;);
 130 #define gst_audio_base_sink_parent_class parent_class
 131 G_DEFINE_TYPE_WITH_CODE (GstAudioBaseSink, gst_audio_base_sink,
<a name="3" id="anc3"></a><span class="line-modified"> 132     GST_TYPE_BASE_SINK, _do_init);</span>
 133 
 134 static void gst_audio_base_sink_dispose (GObject * object);
 135 
 136 static void gst_audio_base_sink_set_property (GObject * object, guint prop_id,
 137     const GValue * value, GParamSpec * pspec);
 138 static void gst_audio_base_sink_get_property (GObject * object, guint prop_id,
 139     GValue * value, GParamSpec * pspec);
 140 
 141 static GstStateChangeReturn gst_audio_base_sink_change_state (GstElement *
 142     element, GstStateChange transition);
 143 static gboolean gst_audio_base_sink_activate_pull (GstBaseSink * basesink,
 144     gboolean active);
 145 static gboolean gst_audio_base_sink_query (GstElement * element, GstQuery *
 146     query);
 147 
 148 static GstClock *gst_audio_base_sink_provide_clock (GstElement * elem);
 149 static inline void gst_audio_base_sink_reset_sync (GstAudioBaseSink * sink);
 150 static GstClockTime gst_audio_base_sink_get_time (GstClock * clock,
 151     GstAudioBaseSink * sink);
 152 static void gst_audio_base_sink_callback (GstAudioRingBuffer * rbuf,
 153     guint8 * data, guint len, gpointer user_data);
 154 
 155 static GstFlowReturn gst_audio_base_sink_preroll (GstBaseSink * bsink,
 156     GstBuffer * buffer);
 157 static GstFlowReturn gst_audio_base_sink_render (GstBaseSink * bsink,
 158     GstBuffer * buffer);
 159 static gboolean gst_audio_base_sink_event (GstBaseSink * bsink,
 160     GstEvent * event);
 161 static GstFlowReturn gst_audio_base_sink_wait_event (GstBaseSink * bsink,
 162     GstEvent * event);
 163 static void gst_audio_base_sink_get_times (GstBaseSink * bsink,
 164     GstBuffer * buffer, GstClockTime * start, GstClockTime * end);
 165 static gboolean gst_audio_base_sink_setcaps (GstBaseSink * bsink,
 166     GstCaps * caps);
 167 static GstCaps *gst_audio_base_sink_fixate (GstBaseSink * bsink,
 168     GstCaps * caps);
 169 
 170 static gboolean gst_audio_base_sink_query_pad (GstBaseSink * bsink,
 171     GstQuery * query);
 172 
 173 
 174 /* static guint gst_audio_base_sink_signals[LAST_SIGNAL] = { 0 }; */
 175 
 176 static void
 177 gst_audio_base_sink_class_init (GstAudioBaseSinkClass * klass)
 178 {
 179   GObjectClass *gobject_class;
 180   GstElementClass *gstelement_class;
 181   GstBaseSinkClass *gstbasesink_class;
 182 
 183   gobject_class = (GObjectClass *) klass;
 184   gstelement_class = (GstElementClass *) klass;
 185   gstbasesink_class = (GstBaseSinkClass *) klass;
 186 
<a name="4" id="anc4"></a><span class="line-removed"> 187   g_type_class_add_private (klass, sizeof (GstAudioBaseSinkPrivate));</span>
<span class="line-removed"> 188 </span>
 189   gobject_class-&gt;set_property = gst_audio_base_sink_set_property;
 190   gobject_class-&gt;get_property = gst_audio_base_sink_get_property;
 191   gobject_class-&gt;dispose = gst_audio_base_sink_dispose;
 192 
 193   g_object_class_install_property (gobject_class, PROP_BUFFER_TIME,
 194       g_param_spec_int64 (&quot;buffer-time&quot;, &quot;Buffer Time&quot;,
 195           &quot;Size of audio buffer in microseconds, this is the minimum &quot;
 196           &quot;latency that the sink reports&quot;, 1, G_MAXINT64, DEFAULT_BUFFER_TIME,
 197           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 198 
 199   g_object_class_install_property (gobject_class, PROP_LATENCY_TIME,
 200       g_param_spec_int64 (&quot;latency-time&quot;, &quot;Latency Time&quot;,
 201           &quot;The minimum amount of data to write in each iteration &quot;
 202           &quot;in microseconds&quot;, 1, G_MAXINT64, DEFAULT_LATENCY_TIME,
 203           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 204 
 205   g_object_class_install_property (gobject_class, PROP_PROVIDE_CLOCK,
 206       g_param_spec_boolean (&quot;provide-clock&quot;, &quot;Provide Clock&quot;,
 207           &quot;Provide a clock to be used as the global pipeline clock&quot;,
 208           DEFAULT_PROVIDE_CLOCK, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 209 
 210   g_object_class_install_property (gobject_class, PROP_SLAVE_METHOD,
 211       g_param_spec_enum (&quot;slave-method&quot;, &quot;Slave Method&quot;,
 212           &quot;Algorithm used to match the rate of the masterclock&quot;,
 213           GST_TYPE_AUDIO_BASE_SINK_SLAVE_METHOD, DEFAULT_SLAVE_METHOD,
 214           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 215 
 216   g_object_class_install_property (gobject_class, PROP_CAN_ACTIVATE_PULL,
 217       g_param_spec_boolean (&quot;can-activate-pull&quot;, &quot;Allow Pull Scheduling&quot;,
 218           &quot;Allow pull-based scheduling&quot;, DEFAULT_CAN_ACTIVATE_PULL,
 219           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 220   /**
 221    * GstAudioBaseSink:drift-tolerance:
 222    *
 223    * Controls the amount of time in microseconds that clocks are allowed
 224    * to drift before resynchronisation happens.
 225    */
 226   g_object_class_install_property (gobject_class, PROP_DRIFT_TOLERANCE,
 227       g_param_spec_int64 (&quot;drift-tolerance&quot;, &quot;Drift Tolerance&quot;,
 228           &quot;Tolerance for clock drift in microseconds&quot;, 1,
 229           G_MAXINT64, DEFAULT_DRIFT_TOLERANCE,
 230           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 231   /**
 232    * GstAudioBaseSink:alignment_threshold:
 233    *
 234    * Controls the amount of time in nanoseconds that timestamps are allowed
 235    * to drift from their ideal time before choosing not to align them.
 236    */
 237   g_object_class_install_property (gobject_class, PROP_ALIGNMENT_THRESHOLD,
 238       g_param_spec_uint64 (&quot;alignment-threshold&quot;, &quot;Alignment Threshold&quot;,
 239           &quot;Timestamp alignment threshold in nanoseconds&quot;, 1,
 240           G_MAXUINT64 - 1, DEFAULT_ALIGNMENT_THRESHOLD,
 241           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 242 
 243   /**
 244    * GstAudioBaseSink:discont-wait:
 245    *
 246    * A window of time in nanoseconds to wait before creating a discontinuity as
 247    * a result of breaching the drift-tolerance.
 248    */
 249   g_object_class_install_property (gobject_class, PROP_DISCONT_WAIT,
 250       g_param_spec_uint64 (&quot;discont-wait&quot;, &quot;Discont Wait&quot;,
 251           &quot;Window of time in nanoseconds to wait before &quot;
 252           &quot;creating a discontinuity&quot;, 0,
 253           G_MAXUINT64 - 1, DEFAULT_DISCONT_WAIT,
 254           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 255 
 256   gstelement_class-&gt;change_state =
 257       GST_DEBUG_FUNCPTR (gst_audio_base_sink_change_state);
 258   gstelement_class-&gt;provide_clock =
 259       GST_DEBUG_FUNCPTR (gst_audio_base_sink_provide_clock);
 260   gstelement_class-&gt;query = GST_DEBUG_FUNCPTR (gst_audio_base_sink_query);
 261 
 262   gstbasesink_class-&gt;fixate = GST_DEBUG_FUNCPTR (gst_audio_base_sink_fixate);
 263   gstbasesink_class-&gt;set_caps = GST_DEBUG_FUNCPTR (gst_audio_base_sink_setcaps);
 264   gstbasesink_class-&gt;event = GST_DEBUG_FUNCPTR (gst_audio_base_sink_event);
 265   gstbasesink_class-&gt;wait_event =
 266       GST_DEBUG_FUNCPTR (gst_audio_base_sink_wait_event);
 267   gstbasesink_class-&gt;get_times =
 268       GST_DEBUG_FUNCPTR (gst_audio_base_sink_get_times);
 269   gstbasesink_class-&gt;preroll = GST_DEBUG_FUNCPTR (gst_audio_base_sink_preroll);
 270   gstbasesink_class-&gt;render = GST_DEBUG_FUNCPTR (gst_audio_base_sink_render);
 271   gstbasesink_class-&gt;query = GST_DEBUG_FUNCPTR (gst_audio_base_sink_query_pad);
 272   gstbasesink_class-&gt;activate_pull =
 273       GST_DEBUG_FUNCPTR (gst_audio_base_sink_activate_pull);
 274 
 275   /* ref class from a thread-safe context to work around missing bit of
 276    * thread-safety in GObject */
 277   g_type_class_ref (GST_TYPE_AUDIO_CLOCK);
 278   g_type_class_ref (GST_TYPE_AUDIO_RING_BUFFER);
 279 
 280 }
 281 
 282 static void
 283 gst_audio_base_sink_init (GstAudioBaseSink * audiobasesink)
 284 {
<a name="5" id="anc5"></a><span class="line-modified"> 285   GstBaseSink *basesink;</span>
 286 
<a name="6" id="anc6"></a><span class="line-modified"> 287   audiobasesink-&gt;priv = GST_AUDIO_BASE_SINK_GET_PRIVATE (audiobasesink);</span>

 288 
 289   audiobasesink-&gt;buffer_time = DEFAULT_BUFFER_TIME;
 290   audiobasesink-&gt;latency_time = DEFAULT_LATENCY_TIME;
 291   audiobasesink-&gt;priv-&gt;slave_method = DEFAULT_SLAVE_METHOD;
 292   audiobasesink-&gt;priv-&gt;drift_tolerance = DEFAULT_DRIFT_TOLERANCE;
 293   audiobasesink-&gt;priv-&gt;alignment_threshold = DEFAULT_ALIGNMENT_THRESHOLD;
 294   audiobasesink-&gt;priv-&gt;discont_wait = DEFAULT_DISCONT_WAIT;
 295   audiobasesink-&gt;priv-&gt;custom_slaving_callback = NULL;
 296   audiobasesink-&gt;priv-&gt;custom_slaving_cb_data = NULL;
 297   audiobasesink-&gt;priv-&gt;custom_slaving_cb_notify = NULL;
 298 
 299   audiobasesink-&gt;provided_clock = gst_audio_clock_new (&quot;GstAudioSinkClock&quot;,
 300       (GstAudioClockGetTimeFunc) gst_audio_base_sink_get_time, audiobasesink,
 301       NULL);
 302 
<a name="7" id="anc7"></a><span class="line-removed"> 303   basesink = GST_BASE_SINK_CAST (audiobasesink);</span>
 304   basesink-&gt;can_activate_push = TRUE;
 305   basesink-&gt;can_activate_pull = DEFAULT_CAN_ACTIVATE_PULL;
 306 
 307   gst_base_sink_set_last_sample_enabled (basesink, FALSE);
 308   if (DEFAULT_PROVIDE_CLOCK)
 309     GST_OBJECT_FLAG_SET (basesink, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 310   else
 311     GST_OBJECT_FLAG_UNSET (basesink, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 312 }
 313 
 314 static void
 315 gst_audio_base_sink_dispose (GObject * object)
 316 {
 317   GstAudioBaseSink *sink;
 318 
 319   sink = GST_AUDIO_BASE_SINK (object);
 320 
 321   if (sink-&gt;priv-&gt;custom_slaving_cb_notify)
 322     sink-&gt;priv-&gt;custom_slaving_cb_notify (sink-&gt;priv-&gt;custom_slaving_cb_data);
 323 
 324   if (sink-&gt;provided_clock) {
 325     gst_audio_clock_invalidate (GST_AUDIO_CLOCK (sink-&gt;provided_clock));
 326     gst_object_unref (sink-&gt;provided_clock);
 327     sink-&gt;provided_clock = NULL;
 328   }
 329 
 330   if (sink-&gt;ringbuffer) {
 331     gst_object_unparent (GST_OBJECT_CAST (sink-&gt;ringbuffer));
 332     sink-&gt;ringbuffer = NULL;
 333   }
 334 
 335   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
 336 }
 337 
 338 
 339 static GstClock *
 340 gst_audio_base_sink_provide_clock (GstElement * elem)
 341 {
 342   GstAudioBaseSink *sink;
 343   GstClock *clock;
 344 
 345   sink = GST_AUDIO_BASE_SINK (elem);
 346 
 347 #ifdef GSTREAMER_LITE
 348   GST_OBJECT_LOCK (sink);
 349 #endif // GSTREAMER_LITE
 350 
 351   /* we have no ringbuffer (must be NULL state) */
 352   if (sink-&gt;ringbuffer == NULL)
 353     goto wrong_state;
 354 
 355   if (!gst_audio_ring_buffer_is_acquired (sink-&gt;ringbuffer))
 356     goto wrong_state;
 357 
 358 #ifndef GSTREAMER_LITE
 359   GST_OBJECT_LOCK (sink);
 360 #endif // GSTREAMER_LITE
 361 
 362   if (!GST_OBJECT_FLAG_IS_SET (sink, GST_ELEMENT_FLAG_PROVIDE_CLOCK))
 363     goto clock_disabled;
 364 
 365   clock = GST_CLOCK_CAST (gst_object_ref (sink-&gt;provided_clock));
 366   GST_OBJECT_UNLOCK (sink);
 367 
 368   return clock;
 369 
 370   /* ERRORS */
 371 wrong_state:
 372   {
 373     GST_DEBUG_OBJECT (sink, &quot;ringbuffer not acquired&quot;);
 374 #ifdef GSTREAMER_LITE
 375     GST_OBJECT_UNLOCK (sink);
 376 #endif // GSTREAMER_LITE
 377     return NULL;
 378   }
 379 clock_disabled:
 380   {
 381     GST_DEBUG_OBJECT (sink, &quot;clock provide disabled&quot;);
 382     GST_OBJECT_UNLOCK (sink);
 383     return NULL;
 384   }
 385 }
 386 
 387 static gboolean
 388 gst_audio_base_sink_is_self_provided_clock (GstAudioBaseSink * sink)
 389 {
 390   return (sink-&gt;provided_clock &amp;&amp; GST_IS_AUDIO_CLOCK (sink-&gt;provided_clock) &amp;&amp;
 391       GST_AUDIO_CLOCK_CAST (sink-&gt;provided_clock)-&gt;func ==
 392       (GstAudioClockGetTimeFunc) gst_audio_base_sink_get_time);
 393 }
 394 
 395 static gboolean
 396 gst_audio_base_sink_query_pad (GstBaseSink * bsink, GstQuery * query)
 397 {
 398   gboolean res = FALSE;
 399   GstAudioBaseSink *basesink;
 400 
 401   basesink = GST_AUDIO_BASE_SINK (bsink);
 402 
 403   switch (GST_QUERY_TYPE (query)) {
 404     case GST_QUERY_CONVERT:
 405     {
 406       GstFormat src_fmt, dest_fmt;
 407       gint64 src_val, dest_val;
 408 
 409       GST_LOG_OBJECT (basesink, &quot;query convert&quot;);
 410 
 411       if (basesink-&gt;ringbuffer) {
 412         gst_query_parse_convert (query, &amp;src_fmt, &amp;src_val, &amp;dest_fmt, NULL);
 413         res =
 414             gst_audio_ring_buffer_convert (basesink-&gt;ringbuffer, src_fmt,
 415             src_val, dest_fmt, &amp;dest_val);
 416         if (res) {
 417           gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
 418         }
 419       }
 420       break;
 421     }
 422     default:
 423       res = GST_BASE_SINK_CLASS (parent_class)-&gt;query (bsink, query);
 424       break;
 425   }
 426   return res;
 427 }
 428 
 429 static gboolean
 430 gst_audio_base_sink_query (GstElement * element, GstQuery * query)
 431 {
 432   gboolean res = FALSE;
 433   GstAudioBaseSink *basesink;
 434 
 435   basesink = GST_AUDIO_BASE_SINK (element);
 436 
 437   switch (GST_QUERY_TYPE (query)) {
 438     case GST_QUERY_LATENCY:
 439     {
 440       gboolean live, us_live;
 441       GstClockTime min_l, max_l;
 442 
 443       GST_DEBUG_OBJECT (basesink, &quot;latency query&quot;);
 444 
 445       /* ask parent first, it will do an upstream query for us. */
 446       if ((res =
 447               gst_base_sink_query_latency (GST_BASE_SINK_CAST (basesink), &amp;live,
 448                   &amp;us_live, &amp;min_l, &amp;max_l))) {
 449         GstClockTime base_latency, min_latency, max_latency;
 450 
 451         /* we and upstream are both live, adjust the min_latency */
 452         if (live &amp;&amp; us_live) {
 453           GstAudioRingBufferSpec *spec;
 454 
 455           GST_OBJECT_LOCK (basesink);
 456           if (!basesink-&gt;ringbuffer || !basesink-&gt;ringbuffer-&gt;spec.info.rate) {
 457             GST_OBJECT_UNLOCK (basesink);
 458 
 459             GST_DEBUG_OBJECT (basesink,
 460                 &quot;we are not negotiated, can&#39;t report latency yet&quot;);
 461             res = FALSE;
 462             goto done;
 463           }
 464           spec = &amp;basesink-&gt;ringbuffer-&gt;spec;
 465 
 466           basesink-&gt;priv-&gt;us_latency = min_l;
 467 
 468           base_latency =
 469               gst_util_uint64_scale_int (spec-&gt;seglatency * spec-&gt;segsize,
 470               GST_SECOND, spec-&gt;info.rate * spec-&gt;info.bpf);
 471           GST_OBJECT_UNLOCK (basesink);
 472 
 473           /* we cannot go lower than the buffer size and the min peer latency */
 474           min_latency = base_latency + min_l;
 475           /* the max latency is the max of the peer, we can delay an infinite
 476            * amount of time. */
 477           max_latency = (max_l == -1) ? -1 : (base_latency + max_l);
 478 
 479           GST_DEBUG_OBJECT (basesink,
 480               &quot;peer min %&quot; GST_TIME_FORMAT &quot;, our min latency: %&quot;
 481               GST_TIME_FORMAT, GST_TIME_ARGS (min_l),
 482               GST_TIME_ARGS (min_latency));
 483           GST_DEBUG_OBJECT (basesink,
 484               &quot;peer max %&quot; GST_TIME_FORMAT &quot;, our max latency: %&quot;
 485               GST_TIME_FORMAT, GST_TIME_ARGS (max_l),
 486               GST_TIME_ARGS (max_latency));
 487         } else {
 488           GST_DEBUG_OBJECT (basesink,
 489               &quot;peer or we are not live, don&#39;t care about latency&quot;);
 490           min_latency = min_l;
 491           max_latency = max_l;
 492         }
 493         gst_query_set_latency (query, live, min_latency, max_latency);
 494       }
 495       break;
 496     }
 497     case GST_QUERY_CONVERT:
 498     {
 499       GstFormat src_fmt, dest_fmt;
 500       gint64 src_val, dest_val;
 501 
 502       GST_LOG_OBJECT (basesink, &quot;query convert&quot;);
 503 
 504       if (basesink-&gt;ringbuffer) {
 505         gst_query_parse_convert (query, &amp;src_fmt, &amp;src_val, &amp;dest_fmt, NULL);
 506         res =
 507             gst_audio_ring_buffer_convert (basesink-&gt;ringbuffer, src_fmt,
 508             src_val, dest_fmt, &amp;dest_val);
 509         if (res) {
 510           gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
 511         }
 512       }
 513       break;
 514     }
 515     default:
 516       res = GST_ELEMENT_CLASS (parent_class)-&gt;query (element, query);
 517       break;
 518   }
 519 
 520 done:
 521   return res;
 522 }
 523 
 524 
 525 /* we call this function without holding the lock on sink for performance
 526  * reasons. Try hard to not deal with and invalid ringbuffer and rate. */
 527 static GstClockTime
 528 gst_audio_base_sink_get_time (GstClock * clock, GstAudioBaseSink * sink)
 529 {
 530   guint64 raw, samples;
 531   guint delay;
 532   GstClockTime result;
 533   GstAudioRingBuffer *ringbuffer;
 534   gint rate;
 535 
 536   if ((ringbuffer = sink-&gt;ringbuffer) == NULL)
 537     return GST_CLOCK_TIME_NONE;
 538 
 539   if ((rate = ringbuffer-&gt;spec.info.rate) == 0)
 540     return GST_CLOCK_TIME_NONE;
 541 
 542   /* our processed samples are always increasing */
 543   raw = samples = gst_audio_ring_buffer_samples_done (ringbuffer);
 544 
 545   /* the number of samples not yet processed, this is still queued in the
 546    * device (not played for playback). */
 547   delay = gst_audio_ring_buffer_delay (ringbuffer);
 548 
 549   if (G_LIKELY (samples &gt;= delay))
 550     samples -= delay;
 551   else
 552     samples = 0;
 553 
 554   result = gst_util_uint64_scale_int (samples, GST_SECOND, rate);
 555 
 556   GST_DEBUG_OBJECT (sink,
 557       &quot;processed samples: raw %&quot; G_GUINT64_FORMAT &quot;, delay %u, real %&quot;
 558       G_GUINT64_FORMAT &quot;, time %&quot; GST_TIME_FORMAT,
 559       raw, delay, samples, GST_TIME_ARGS (result));
 560 
 561   return result;
 562 }
 563 
 564 /**
 565  * gst_audio_base_sink_set_provide_clock:
 566  * @sink: a #GstAudioBaseSink
 567  * @provide: new state
 568  *
 569  * Controls whether @sink will provide a clock or not. If @provide is %TRUE,
 570  * gst_element_provide_clock() will return a clock that reflects the datarate
 571  * of @sink. If @provide is %FALSE, gst_element_provide_clock() will return
 572  * NULL.
 573  */
 574 void
 575 gst_audio_base_sink_set_provide_clock (GstAudioBaseSink * sink,
 576     gboolean provide)
 577 {
 578   g_return_if_fail (GST_IS_AUDIO_BASE_SINK (sink));
 579 
 580   GST_OBJECT_LOCK (sink);
 581   if (provide)
 582     GST_OBJECT_FLAG_SET (sink, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 583   else
 584     GST_OBJECT_FLAG_UNSET (sink, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 585   GST_OBJECT_UNLOCK (sink);
 586 }
 587 
 588 /**
 589  * gst_audio_base_sink_get_provide_clock:
 590  * @sink: a #GstAudioBaseSink
 591  *
 592  * Queries whether @sink will provide a clock or not. See also
 593  * gst_audio_base_sink_set_provide_clock.
 594  *
 595  * Returns: %TRUE if @sink will provide a clock.
 596  */
 597 gboolean
 598 gst_audio_base_sink_get_provide_clock (GstAudioBaseSink * sink)
 599 {
 600   gboolean result;
 601 
 602   g_return_val_if_fail (GST_IS_AUDIO_BASE_SINK (sink), FALSE);
 603 
 604   GST_OBJECT_LOCK (sink);
 605   result = GST_OBJECT_FLAG_IS_SET (sink, GST_ELEMENT_FLAG_PROVIDE_CLOCK);
 606   GST_OBJECT_UNLOCK (sink);
 607 
 608   return result;
 609 }
 610 
 611 /**
 612  * gst_audio_base_sink_set_slave_method:
 613  * @sink: a #GstAudioBaseSink
 614  * @method: the new slave method
 615  *
 616  * Controls how clock slaving will be performed in @sink.
 617  */
 618 void
 619 gst_audio_base_sink_set_slave_method (GstAudioBaseSink * sink,
 620     GstAudioBaseSinkSlaveMethod method)
 621 {
 622   g_return_if_fail (GST_IS_AUDIO_BASE_SINK (sink));
 623 
 624   GST_OBJECT_LOCK (sink);
 625   sink-&gt;priv-&gt;slave_method = method;
 626   GST_OBJECT_UNLOCK (sink);
 627 }
 628 
 629 /**
 630  * gst_audio_base_sink_get_slave_method:
 631  * @sink: a #GstAudioBaseSink
 632  *
 633  * Get the current slave method used by @sink.
 634  *
 635  * Returns: The current slave method used by @sink.
 636  */
 637 GstAudioBaseSinkSlaveMethod
 638 gst_audio_base_sink_get_slave_method (GstAudioBaseSink * sink)
 639 {
 640   GstAudioBaseSinkSlaveMethod result;
 641 
 642   g_return_val_if_fail (GST_IS_AUDIO_BASE_SINK (sink), -1);
 643 
 644   GST_OBJECT_LOCK (sink);
 645   result = sink-&gt;priv-&gt;slave_method;
 646   GST_OBJECT_UNLOCK (sink);
 647 
 648   return result;
 649 }
 650 
 651 
 652 /**
 653  * gst_audio_base_sink_set_drift_tolerance:
 654  * @sink: a #GstAudioBaseSink
 655  * @drift_tolerance: the new drift tolerance in microseconds
 656  *
 657  * Controls the sink&#39;s drift tolerance.
 658  */
 659 void
 660 gst_audio_base_sink_set_drift_tolerance (GstAudioBaseSink * sink,
 661     gint64 drift_tolerance)
 662 {
 663   g_return_if_fail (GST_IS_AUDIO_BASE_SINK (sink));
 664 
 665   GST_OBJECT_LOCK (sink);
 666   sink-&gt;priv-&gt;drift_tolerance = drift_tolerance;
 667   GST_OBJECT_UNLOCK (sink);
 668 }
 669 
 670 /**
 671  * gst_audio_base_sink_get_drift_tolerance:
 672  * @sink: a #GstAudioBaseSink
 673  *
 674  * Get the current drift tolerance, in microseconds, used by @sink.
 675  *
 676  * Returns: The current drift tolerance used by @sink.
 677  */
 678 gint64
 679 gst_audio_base_sink_get_drift_tolerance (GstAudioBaseSink * sink)
 680 {
 681   gint64 result;
 682 
 683   g_return_val_if_fail (GST_IS_AUDIO_BASE_SINK (sink), -1);
 684 
 685   GST_OBJECT_LOCK (sink);
 686   result = sink-&gt;priv-&gt;drift_tolerance;
 687   GST_OBJECT_UNLOCK (sink);
 688 
 689   return result;
 690 }
 691 
 692 /**
 693  * gst_audio_base_sink_set_alignment_threshold:
 694  * @sink: a #GstAudioBaseSink
 695  * @alignment_threshold: the new alignment threshold in nanoseconds
 696  *
 697  * Controls the sink&#39;s alignment threshold.
 698  */
 699 void
 700 gst_audio_base_sink_set_alignment_threshold (GstAudioBaseSink * sink,
 701     GstClockTime alignment_threshold)
 702 {
 703   g_return_if_fail (GST_IS_AUDIO_BASE_SINK (sink));
 704 
 705   GST_OBJECT_LOCK (sink);
 706   sink-&gt;priv-&gt;alignment_threshold = alignment_threshold;
 707   GST_OBJECT_UNLOCK (sink);
 708 }
 709 
 710 /**
 711  * gst_audio_base_sink_get_alignment_threshold:
 712  * @sink: a #GstAudioBaseSink
 713  *
 714  * Get the current alignment threshold, in nanoseconds, used by @sink.
 715  *
 716  * Returns: The current alignment threshold used by @sink.
 717  */
 718 GstClockTime
 719 gst_audio_base_sink_get_alignment_threshold (GstAudioBaseSink * sink)
 720 {
 721   GstClockTime result;
 722 
 723   g_return_val_if_fail (GST_IS_AUDIO_BASE_SINK (sink), GST_CLOCK_TIME_NONE);
 724 
 725   GST_OBJECT_LOCK (sink);
 726   result = sink-&gt;priv-&gt;alignment_threshold;
 727   GST_OBJECT_UNLOCK (sink);
 728 
 729   return result;
 730 }
 731 
 732 /**
 733  * gst_audio_base_sink_set_discont_wait:
 734  * @sink: a #GstAudioBaseSink
 735  * @discont_wait: the new discont wait in nanoseconds
 736  *
 737  * Controls how long the sink will wait before creating a discontinuity.
 738  */
 739 void
 740 gst_audio_base_sink_set_discont_wait (GstAudioBaseSink * sink,
 741     GstClockTime discont_wait)
 742 {
 743   g_return_if_fail (GST_IS_AUDIO_BASE_SINK (sink));
 744 
 745   GST_OBJECT_LOCK (sink);
 746   sink-&gt;priv-&gt;discont_wait = discont_wait;
 747   GST_OBJECT_UNLOCK (sink);
 748 }
 749 
 750 /**
 751  * gst_audio_base_sink_set_custom_slaving_callback:
 752  * @sink: a #GstAudioBaseSink
 753  * @callback: a #GstAudioBaseSinkCustomSlavingCallback
 754  * @user_data: user data passed to the callback
 755  * @notify : called when user_data becomes unused
 756  *
 757  * Sets the custom slaving callback. This callback will
 758  * be invoked if the slave-method property is set to
 759  * GST_AUDIO_BASE_SINK_SLAVE_CUSTOM and the audio sink
 760  * receives and plays samples.
 761  *
 762  * Setting the callback to NULL causes the sink to
 763  * behave as if the GST_AUDIO_BASE_SINK_SLAVE_NONE
 764  * method were used.
 765  *
 766  * Since: 1.6
 767  */
 768 void
 769 gst_audio_base_sink_set_custom_slaving_callback (GstAudioBaseSink * sink,
 770     GstAudioBaseSinkCustomSlavingCallback callback,
 771     gpointer user_data, GDestroyNotify notify)
 772 {
 773   g_return_if_fail (GST_IS_AUDIO_BASE_SINK (sink));
 774 
 775   GST_OBJECT_LOCK (sink);
 776   sink-&gt;priv-&gt;custom_slaving_callback = callback;
 777   sink-&gt;priv-&gt;custom_slaving_cb_data = user_data;
 778   sink-&gt;priv-&gt;custom_slaving_cb_notify = notify;
 779   GST_OBJECT_UNLOCK (sink);
 780 }
 781 
 782 static void
 783 gst_audio_base_sink_custom_cb_report_discont (GstAudioBaseSink * sink,
 784     GstAudioBaseSinkDiscontReason discont_reason)
 785 {
 786   if ((sink-&gt;priv-&gt;custom_slaving_callback != NULL) &amp;&amp;
 787       (sink-&gt;priv-&gt;slave_method == GST_AUDIO_BASE_SINK_SLAVE_CUSTOM)) {
 788     sink-&gt;priv-&gt;custom_slaving_callback (sink, GST_CLOCK_TIME_NONE,
 789         GST_CLOCK_TIME_NONE, NULL, discont_reason,
 790         sink-&gt;priv-&gt;custom_slaving_cb_data);
 791   }
 792 }
 793 
 794 /**
 795  * gst_audio_base_sink_report_device_failure:
 796  * @sink: a #GstAudioBaseSink
 797  *
 798  * Informs this base class that the audio output device has failed for
 799  * some reason, causing a discontinuity (for example, because the device
 800  * recovered from the error, but lost all contents of its ring buffer).
 801  * This function is typically called by derived classes, and is useful
 802  * for the custom slave method.
 803  *
 804  * Since: 1.6
 805  */
 806 void
 807 gst_audio_base_sink_report_device_failure (GstAudioBaseSink * sink)
 808 {
 809   g_return_if_fail (GST_IS_AUDIO_BASE_SINK (sink));
 810 
 811   GST_OBJECT_LOCK (sink);
 812   gst_audio_base_sink_custom_cb_report_discont (sink,
 813       GST_AUDIO_BASE_SINK_DISCONT_REASON_DEVICE_FAILURE);
 814   GST_OBJECT_UNLOCK (sink);
 815 }
 816 
 817 /**
 818  * gst_audio_base_sink_get_discont_wait:
 819  * @sink: a #GstAudioBaseSink
 820  *
 821  * Get the current discont wait, in nanoseconds, used by @sink.
 822  *
 823  * Returns: The current discont wait used by @sink.
 824  */
 825 GstClockTime
 826 gst_audio_base_sink_get_discont_wait (GstAudioBaseSink * sink)
 827 {
 828   GstClockTime result;
 829 
 830   g_return_val_if_fail (GST_IS_AUDIO_BASE_SINK (sink), -1);
 831 
 832   GST_OBJECT_LOCK (sink);
 833   result = sink-&gt;priv-&gt;discont_wait;
 834   GST_OBJECT_UNLOCK (sink);
 835 
 836   return result;
 837 }
 838 
 839 static void
 840 gst_audio_base_sink_set_property (GObject * object, guint prop_id,
 841     const GValue * value, GParamSpec * pspec)
 842 {
 843   GstAudioBaseSink *sink;
 844 
 845   sink = GST_AUDIO_BASE_SINK (object);
 846 
 847   switch (prop_id) {
 848     case PROP_BUFFER_TIME:
 849       sink-&gt;buffer_time = g_value_get_int64 (value);
 850       break;
 851     case PROP_LATENCY_TIME:
 852       sink-&gt;latency_time = g_value_get_int64 (value);
 853       break;
 854     case PROP_PROVIDE_CLOCK:
 855       gst_audio_base_sink_set_provide_clock (sink, g_value_get_boolean (value));
 856       break;
 857     case PROP_SLAVE_METHOD:
 858       gst_audio_base_sink_set_slave_method (sink, g_value_get_enum (value));
 859       break;
 860     case PROP_CAN_ACTIVATE_PULL:
 861       GST_BASE_SINK (sink)-&gt;can_activate_pull = g_value_get_boolean (value);
 862       break;
 863     case PROP_DRIFT_TOLERANCE:
 864       gst_audio_base_sink_set_drift_tolerance (sink, g_value_get_int64 (value));
 865       break;
 866     case PROP_ALIGNMENT_THRESHOLD:
 867       gst_audio_base_sink_set_alignment_threshold (sink,
 868           g_value_get_uint64 (value));
 869       break;
 870     case PROP_DISCONT_WAIT:
 871       gst_audio_base_sink_set_discont_wait (sink, g_value_get_uint64 (value));
 872       break;
 873     default:
 874       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 875       break;
 876   }
 877 }
 878 
 879 static void
 880 gst_audio_base_sink_get_property (GObject * object, guint prop_id,
 881     GValue * value, GParamSpec * pspec)
 882 {
 883   GstAudioBaseSink *sink;
 884 
 885   sink = GST_AUDIO_BASE_SINK (object);
 886 
 887   switch (prop_id) {
 888     case PROP_BUFFER_TIME:
 889       g_value_set_int64 (value, sink-&gt;buffer_time);
 890       break;
 891     case PROP_LATENCY_TIME:
 892       g_value_set_int64 (value, sink-&gt;latency_time);
 893       break;
 894     case PROP_PROVIDE_CLOCK:
 895       g_value_set_boolean (value, gst_audio_base_sink_get_provide_clock (sink));
 896       break;
 897     case PROP_SLAVE_METHOD:
 898       g_value_set_enum (value, gst_audio_base_sink_get_slave_method (sink));
 899       break;
 900     case PROP_CAN_ACTIVATE_PULL:
 901       g_value_set_boolean (value, GST_BASE_SINK (sink)-&gt;can_activate_pull);
 902       break;
 903     case PROP_DRIFT_TOLERANCE:
 904       g_value_set_int64 (value, gst_audio_base_sink_get_drift_tolerance (sink));
 905       break;
 906     case PROP_ALIGNMENT_THRESHOLD:
 907       g_value_set_uint64 (value,
 908           gst_audio_base_sink_get_alignment_threshold (sink));
 909       break;
 910     case PROP_DISCONT_WAIT:
 911       g_value_set_uint64 (value, gst_audio_base_sink_get_discont_wait (sink));
 912       break;
 913     default:
 914       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 915       break;
 916   }
 917 }
 918 
 919 static gboolean
 920 gst_audio_base_sink_setcaps (GstBaseSink * bsink, GstCaps * caps)
 921 {
 922   GstAudioBaseSink *sink = GST_AUDIO_BASE_SINK (bsink);
 923   GstAudioRingBufferSpec *spec;
 924   GstClockTime now, internal_time;
 925   GstClockTime crate_num, crate_denom;
 926 
 927   if (!sink-&gt;ringbuffer)
 928     return FALSE;
 929 
 930   spec = &amp;sink-&gt;ringbuffer-&gt;spec;
 931 
 932   if (G_UNLIKELY (spec-&gt;caps &amp;&amp; gst_caps_is_equal (spec-&gt;caps, caps))) {
 933     GST_DEBUG_OBJECT (sink,
 934         &quot;Ringbuffer caps haven&#39;t changed, skipping reconfiguration&quot;);
 935     return TRUE;
 936   }
 937 
 938   GST_DEBUG_OBJECT (sink, &quot;release old ringbuffer&quot;);
 939 
 940   /* get current time, updates the last_time. When the subclass has a clock that
 941    * restarts from 0 when a new format is negotiated, it will call
 942    * gst_audio_clock_reset() which will use this last_time to create an offset
 943    * so that time from the clock keeps on increasing monotonically. */
 944   now = gst_clock_get_time (sink-&gt;provided_clock);
 945   internal_time = gst_clock_get_internal_time (sink-&gt;provided_clock);
 946 
 947   GST_DEBUG_OBJECT (sink, &quot;time was %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (now));
 948 
 949   /* release old ringbuffer */
 950   gst_audio_ring_buffer_pause (sink-&gt;ringbuffer);
 951   gst_audio_ring_buffer_activate (sink-&gt;ringbuffer, FALSE);
 952   gst_audio_ring_buffer_release (sink-&gt;ringbuffer);
 953 
 954   GST_DEBUG_OBJECT (sink, &quot;parse caps&quot;);
 955 
 956   spec-&gt;buffer_time = sink-&gt;buffer_time;
 957   spec-&gt;latency_time = sink-&gt;latency_time;
 958 
 959   /* parse new caps */
 960   if (!gst_audio_ring_buffer_parse_caps (spec, caps))
 961     goto parse_error;
 962 
 963   gst_audio_ring_buffer_debug_spec_buff (spec);
 964 
 965   GST_DEBUG_OBJECT (sink, &quot;acquire ringbuffer&quot;);
 966   if (!gst_audio_ring_buffer_acquire (sink-&gt;ringbuffer, spec))
 967     goto acquire_error;
 968 
 969   /* If we use our own clock, we need to adjust the offset since it will now
 970    * restart from zero */
 971   if (gst_audio_base_sink_is_self_provided_clock (sink))
 972     gst_audio_clock_reset (GST_AUDIO_CLOCK (sink-&gt;provided_clock), 0);
 973 
 974   /* We need to resync since the ringbuffer restarted */
 975   gst_audio_base_sink_reset_sync (sink);
 976 
 977   gst_audio_base_sink_custom_cb_report_discont (sink,
 978       GST_AUDIO_BASE_SINK_DISCONT_REASON_NEW_CAPS);
 979 
 980   if (bsink-&gt;pad_mode == GST_PAD_MODE_PUSH) {
 981     GST_DEBUG_OBJECT (sink, &quot;activate ringbuffer&quot;);
 982     gst_audio_ring_buffer_activate (sink-&gt;ringbuffer, TRUE);
 983   }
 984 
 985   /* due to possible changes in the spec file we should recalibrate the clock */
 986   gst_clock_get_calibration (sink-&gt;provided_clock, NULL, NULL,
 987       &amp;crate_num, &amp;crate_denom);
 988   gst_clock_set_calibration (sink-&gt;provided_clock,
 989       internal_time, now, crate_num, crate_denom);
 990 
 991   /* calculate actual latency and buffer times.
 992    * FIXME: In 2.0, store the latency_time internally in ns */
 993   spec-&gt;latency_time = gst_util_uint64_scale (spec-&gt;segsize,
 994       (GST_SECOND / GST_USECOND), spec-&gt;info.rate * spec-&gt;info.bpf);
 995 
 996   spec-&gt;buffer_time = spec-&gt;segtotal * spec-&gt;latency_time;
 997 
 998   gst_audio_ring_buffer_debug_spec_buff (spec);
 999 
1000   gst_element_post_message (GST_ELEMENT_CAST (bsink),
1001       gst_message_new_latency (GST_OBJECT (bsink)));
1002 
1003   return TRUE;
1004 
1005   /* ERRORS */
1006 parse_error:
1007   {
1008     GST_DEBUG_OBJECT (sink, &quot;could not parse caps&quot;);
1009     GST_ELEMENT_ERROR (sink, STREAM, FORMAT,
1010         (NULL), (&quot;cannot parse audio format.&quot;));
1011     return FALSE;
1012   }
1013 acquire_error:
1014   {
1015     GST_DEBUG_OBJECT (sink, &quot;could not acquire ringbuffer&quot;);
1016     return FALSE;
1017   }
1018 }
1019 
1020 static GstCaps *
1021 gst_audio_base_sink_fixate (GstBaseSink * bsink, GstCaps * caps)
1022 {
1023   GstStructure *s;
1024   gint width, depth;
1025 
1026   caps = gst_caps_make_writable (caps);
1027 
1028   s = gst_caps_get_structure (caps, 0);
1029 
1030   /* fields for all formats */
1031   gst_structure_fixate_field_nearest_int (s, &quot;rate&quot;, 44100);
1032   gst_structure_fixate_field_nearest_int (s, &quot;channels&quot;, 2);
1033   gst_structure_fixate_field_nearest_int (s, &quot;width&quot;, 16);
1034 
1035   /* fields for int */
1036   if (gst_structure_has_field (s, &quot;depth&quot;)) {
1037     gst_structure_get_int (s, &quot;width&quot;, &amp;width);
1038     /* round width to nearest multiple of 8 for the depth */
1039     depth = GST_ROUND_UP_8 (width);
1040     gst_structure_fixate_field_nearest_int (s, &quot;depth&quot;, depth);
1041   }
1042   if (gst_structure_has_field (s, &quot;signed&quot;))
1043     gst_structure_fixate_field_boolean (s, &quot;signed&quot;, TRUE);
1044   if (gst_structure_has_field (s, &quot;endianness&quot;))
1045     gst_structure_fixate_field_nearest_int (s, &quot;endianness&quot;, G_BYTE_ORDER);
1046 
1047   caps = GST_BASE_SINK_CLASS (parent_class)-&gt;fixate (bsink, caps);
1048 
1049   return caps;
1050 }
1051 
1052 static inline void
1053 gst_audio_base_sink_reset_sync (GstAudioBaseSink * sink)
1054 {
1055   sink-&gt;next_sample = -1;
1056   sink-&gt;priv-&gt;eos_time = -1;
1057   sink-&gt;priv-&gt;discont_time = -1;
1058   sink-&gt;priv-&gt;avg_skew = -1;
1059   sink-&gt;priv-&gt;last_align = 0;
1060 }
1061 
1062 static void
1063 gst_audio_base_sink_get_times (GstBaseSink * bsink, GstBuffer * buffer,
1064     GstClockTime * start, GstClockTime * end)
1065 {
1066   /* our clock sync is a bit too much for the base class to handle so
1067    * we implement it ourselves. */
1068   *start = GST_CLOCK_TIME_NONE;
1069   *end = GST_CLOCK_TIME_NONE;
1070 }
1071 
1072 static void
1073 gst_audio_base_sink_force_start (GstAudioBaseSink * sink)
1074 {
1075   /* Set the eos_rendering flag so sub-classes definitely start the clock.
1076    * FIXME 2.0: Pass this as a flag to gst_audio_ring_buffer_start() */
1077   g_atomic_int_set (&amp;sink-&gt;eos_rendering, 1);
1078   gst_audio_ring_buffer_start (sink-&gt;ringbuffer);
1079   g_atomic_int_set (&amp;sink-&gt;eos_rendering, 0);
1080 }
1081 
1082 /* This waits for the drain to happen and can be canceled */
1083 static GstFlowReturn
1084 gst_audio_base_sink_drain (GstAudioBaseSink * sink)
1085 {
1086   GstFlowReturn ret = GST_FLOW_OK;
1087   if (!sink-&gt;ringbuffer)
1088     return ret;
1089   if (!sink-&gt;ringbuffer-&gt;spec.info.rate)
1090     return ret;
1091 
1092   /* if PLAYING is interrupted,
1093    * arrange to have clock running when going to PLAYING again */
1094   g_atomic_int_set (&amp;sink-&gt;eos_rendering, 1);
1095 
1096   /* need to start playback before we can drain, but only when
1097    * we have successfully negotiated a format and thus acquired the
1098    * ringbuffer. */
1099   if (gst_audio_ring_buffer_is_acquired (sink-&gt;ringbuffer))
1100     gst_audio_ring_buffer_start (sink-&gt;ringbuffer);
1101 
1102   if (sink-&gt;priv-&gt;eos_time != -1) {
1103     GST_DEBUG_OBJECT (sink,
1104         &quot;last sample time %&quot; GST_TIME_FORMAT,
1105         GST_TIME_ARGS (sink-&gt;priv-&gt;eos_time));
1106 
1107     /* wait for the EOS time to be reached, this is the time when the last
1108      * sample is played. */
1109     ret = gst_base_sink_wait (GST_BASE_SINK (sink), sink-&gt;priv-&gt;eos_time, NULL);
1110 
1111     GST_DEBUG_OBJECT (sink, &quot;drained audio&quot;);
1112   }
1113   g_atomic_int_set (&amp;sink-&gt;eos_rendering, 0);
1114   return ret;
1115 }
1116 
1117 static GstFlowReturn
1118 gst_audio_base_sink_wait_event (GstBaseSink * bsink, GstEvent * event)
1119 {
1120   GstAudioBaseSink *sink = GST_AUDIO_BASE_SINK (bsink);
1121   GstFlowReturn ret = GST_FLOW_OK;
1122   gboolean clear_force_start_flag = FALSE;
1123 
1124   /* For both gap and EOS events, make sure the ringbuffer is running
1125    * before trying to wait on the event! */
1126   switch (GST_EVENT_TYPE (event)) {
1127     case GST_EVENT_EOS:
1128     case GST_EVENT_GAP:
1129       /* We must have a negotiated format before starting the ringbuffer */
1130       if (G_UNLIKELY (!gst_audio_ring_buffer_is_acquired (sink-&gt;ringbuffer))) {
1131         GST_ELEMENT_ERROR (sink, STREAM, FORMAT, (NULL),
1132             (&quot;Sink not negotiated before %s event.&quot;,
1133                 GST_EVENT_TYPE_NAME (event)));
1134         return GST_FLOW_ERROR;
1135       }
1136 
1137       gst_audio_base_sink_force_start (sink);
1138       /* Make sure the ringbuffer will start again if interrupted during event_wait() */
1139       g_atomic_int_set (&amp;sink-&gt;eos_rendering, 1);
1140       clear_force_start_flag = TRUE;
<a name="8" id="anc8"></a><span class="line-modified">1141         break;</span>
1142     default:
1143       break;
<a name="9" id="anc9"></a><span class="line-modified">1144       }</span>
1145 
1146   ret = GST_BASE_SINK_CLASS (parent_class)-&gt;wait_event (bsink, event);
1147   if (ret != GST_FLOW_OK)
1148     goto done;
1149 
1150   switch (GST_EVENT_TYPE (event)) {
1151     case GST_EVENT_EOS:
1152       /* now wait till we played everything */
1153       ret = gst_audio_base_sink_drain (sink);
1154       break;
1155     default:
1156       break;
1157   }
1158 
1159 done:
1160   if (clear_force_start_flag)
1161     g_atomic_int_set (&amp;sink-&gt;eos_rendering, 0);
1162   return ret;
1163 }
1164 
1165 static gboolean
1166 gst_audio_base_sink_event (GstBaseSink * bsink, GstEvent * event)
1167 {
1168   GstAudioBaseSink *sink = GST_AUDIO_BASE_SINK (bsink);
1169 
1170   switch (GST_EVENT_TYPE (event)) {
1171     case GST_EVENT_FLUSH_START:
1172       if (sink-&gt;ringbuffer)
1173         gst_audio_ring_buffer_set_flushing (sink-&gt;ringbuffer, TRUE);
1174       break;
1175     case GST_EVENT_FLUSH_STOP:
1176       /* always resync on sample after a flush */
1177       gst_audio_base_sink_reset_sync (sink);
1178 
1179       gst_audio_base_sink_custom_cb_report_discont (sink,
1180           GST_AUDIO_BASE_SINK_DISCONT_REASON_FLUSH);
1181 
1182       if (sink-&gt;ringbuffer)
1183         gst_audio_ring_buffer_set_flushing (sink-&gt;ringbuffer, FALSE);
1184       break;
1185     default:
1186       break;
1187   }
1188   return GST_BASE_SINK_CLASS (parent_class)-&gt;event (bsink, event);
1189 }
1190 
1191 static GstFlowReturn
1192 gst_audio_base_sink_preroll (GstBaseSink * bsink, GstBuffer * buffer)
1193 {
1194   GstAudioBaseSink *sink = GST_AUDIO_BASE_SINK (bsink);
1195 
1196   if (!gst_audio_ring_buffer_is_acquired (sink-&gt;ringbuffer))
1197     goto wrong_state;
1198 
1199   /* we don&#39;t really do anything when prerolling. We could make a
1200    * property to play this buffer to have some sort of scrubbing
1201    * support. */
1202   return GST_FLOW_OK;
1203 
1204 wrong_state:
1205   {
1206     GST_DEBUG_OBJECT (sink, &quot;ringbuffer in wrong state&quot;);
1207     GST_ELEMENT_ERROR (sink, STREAM, FORMAT, (NULL), (&quot;sink not negotiated.&quot;));
1208     return GST_FLOW_NOT_NEGOTIATED;
1209   }
1210 }
1211 
1212 static guint64
1213 gst_audio_base_sink_get_offset (GstAudioBaseSink * sink)
1214 {
1215   guint64 sample, sps;
1216   gint writeseg, segdone;
1217   gint diff;
1218 
1219   /* assume we can append to the previous sample */
1220   sample = sink-&gt;next_sample;
1221   /* no previous sample, try to insert at position 0 */
1222   if (sample == -1)
1223     sample = 0;
1224 
1225   sps = sink-&gt;ringbuffer-&gt;samples_per_seg;
1226 
1227   /* figure out the segment and the offset inside the segment where
1228    * the sample should be written. */
1229   writeseg = sample / sps;
1230 
1231   /* get the currently processed segment */
1232   segdone = g_atomic_int_get (&amp;sink-&gt;ringbuffer-&gt;segdone)
1233       - sink-&gt;ringbuffer-&gt;segbase;
1234 
1235   /* see how far away it is from the write segment */
1236   diff = writeseg - segdone;
1237   if (diff &lt; 0) {
1238     /* sample would be dropped, position to next playable position */
1239     sample = (segdone + 1) * sps;
1240   }
1241 
1242   return sample;
1243 }
1244 
1245 static GstClockTime
1246 clock_convert_external (GstClockTime external, GstClockTime cinternal,
1247     GstClockTime cexternal, GstClockTime crate_num, GstClockTime crate_denom)
1248 {
1249   /* adjust for rate and speed */
1250   if (external &gt;= cexternal) {
1251     external =
1252         gst_util_uint64_scale (external - cexternal, crate_denom, crate_num);
1253     external += cinternal;
1254   } else {
1255     external =
1256         gst_util_uint64_scale (cexternal - external, crate_denom, crate_num);
1257     if (cinternal &gt; external)
1258       external = cinternal - external;
1259     else
1260       external = 0;
1261   }
1262   return external;
1263 }
1264 
1265 
1266 /* apply the clock offset and invoke a custom callback
1267  * which might also request changes to the playout pointer
1268  *
1269  * this reuses code from the skewing algorithm, but leaves
1270  * decision on whether or not to skew (and how much to skew)
1271  * up to the callback */
1272 static void
1273 gst_audio_base_sink_custom_slaving (GstAudioBaseSink * sink,
1274     GstClockTime render_start, GstClockTime render_stop,
1275     GstClockTime * srender_start, GstClockTime * srender_stop)
1276 {
1277   GstClockTime cinternal, cexternal, crate_num, crate_denom;
1278   GstClockTime etime, itime;
1279   GstClockTimeDiff requested_skew;
1280   gint driftsamples;
1281   gint64 last_align;
1282 
1283   /* get calibration parameters to compensate for offsets */
1284   gst_clock_get_calibration (sink-&gt;provided_clock, &amp;cinternal, &amp;cexternal,
1285       &amp;crate_num, &amp;crate_denom);
1286 
1287   /* sample clocks and figure out clock skew */
1288   etime = gst_clock_get_time (GST_ELEMENT_CLOCK (sink));
1289   itime = gst_audio_clock_get_time (GST_AUDIO_CLOCK (sink-&gt;provided_clock));
1290   itime =
1291       gst_audio_clock_adjust (GST_AUDIO_CLOCK (sink-&gt;provided_clock), itime);
1292 
1293   GST_DEBUG_OBJECT (sink,
1294       &quot;internal %&quot; GST_TIME_FORMAT &quot; external %&quot; GST_TIME_FORMAT
1295       &quot; cinternal %&quot; GST_TIME_FORMAT &quot; cexternal %&quot; GST_TIME_FORMAT,
1296       GST_TIME_ARGS (itime), GST_TIME_ARGS (etime),
1297       GST_TIME_ARGS (cinternal), GST_TIME_ARGS (cexternal));
1298 
1299   /* make sure we never go below 0 */
1300   etime = etime &gt; cexternal ? etime - cexternal : 0;
1301   itime = itime &gt; cinternal ? itime - cinternal : 0;
1302 
1303   /* don&#39;t do any skewing unless the callback explicitely requests one */
1304   requested_skew = 0;
1305 
1306   if (sink-&gt;priv-&gt;custom_slaving_callback != NULL) {
1307     sink-&gt;priv-&gt;custom_slaving_callback (sink, etime, itime, &amp;requested_skew,
1308         FALSE, sink-&gt;priv-&gt;custom_slaving_cb_data);
1309     GST_DEBUG_OBJECT (sink, &quot;custom slaving requested skew %&quot; GST_STIME_FORMAT,
1310         GST_STIME_ARGS (requested_skew));
1311   } else {
1312     GST_DEBUG_OBJECT (sink,
1313         &quot;no custom slaving callback set - clock drift will not be compensated&quot;);
1314   }
1315 
1316   if (requested_skew &gt; 0) {
1317     cexternal = (cexternal &gt; requested_skew) ? (cexternal - requested_skew) : 0;
1318 
1319     driftsamples =
1320         (sink-&gt;ringbuffer-&gt;spec.info.rate * requested_skew) / GST_SECOND;
1321     last_align = sink-&gt;priv-&gt;last_align;
1322 
1323     /* if we were aligning in the wrong direction or we aligned more than what we
1324      * will correct, resync */
1325     if ((last_align &lt; 0) || (last_align &gt; driftsamples))
1326       sink-&gt;next_sample = -1;
1327 
1328     GST_DEBUG_OBJECT (sink,
1329         &quot;last_align %&quot; G_GINT64_FORMAT &quot; driftsamples %u, next %&quot;
1330         G_GUINT64_FORMAT, last_align, driftsamples, sink-&gt;next_sample);
1331 
1332     gst_clock_set_calibration (sink-&gt;provided_clock, cinternal, cexternal,
1333         crate_num, crate_denom);
1334   } else if (requested_skew &lt; 0) {
1335     cexternal += ABS (requested_skew);
1336 
1337     driftsamples =
1338         (sink-&gt;ringbuffer-&gt;spec.info.rate * ABS (requested_skew)) / GST_SECOND;
1339     last_align = sink-&gt;priv-&gt;last_align;
1340 
1341     /* if we were aligning in the wrong direction or we aligned more than what we
1342      * will correct, resync */
1343     if ((last_align &gt; 0) || (-last_align &gt; driftsamples))
1344       sink-&gt;next_sample = -1;
1345 
1346     GST_DEBUG_OBJECT (sink,
1347         &quot;last_align %&quot; G_GINT64_FORMAT &quot; driftsamples %u, next %&quot;
1348         G_GUINT64_FORMAT, last_align, driftsamples, sink-&gt;next_sample);
1349 
1350     gst_clock_set_calibration (sink-&gt;provided_clock, cinternal, cexternal,
1351         crate_num, crate_denom);
1352   }
1353 
1354   /* convert, ignoring speed */
1355   render_start = clock_convert_external (render_start, cinternal, cexternal,
1356       crate_num, crate_denom);
1357   render_stop = clock_convert_external (render_stop, cinternal, cexternal,
1358       crate_num, crate_denom);
1359 
1360   *srender_start = render_start;
1361   *srender_stop = render_stop;
1362 }
1363 
1364 /* algorithm to calculate sample positions that will result in resampling to
1365  * match the clock rate of the master */
1366 static void
1367 gst_audio_base_sink_resample_slaving (GstAudioBaseSink * sink,
1368     GstClockTime render_start, GstClockTime render_stop,
1369     GstClockTime * srender_start, GstClockTime * srender_stop)
1370 {
1371   GstClockTime cinternal, cexternal;
1372   GstClockTime crate_num, crate_denom;
1373 
1374   /* FIXME, we can sample and add observations here or use the timeouts on the
1375    * clock. No idea which one is better or more stable. The timeout seems more
1376    * arbitrary but this one seems more demanding and does not work when there is
1377    * no data comming in to the sink. */
1378 #if 0
1379   GstClockTime etime, itime;
1380   gdouble r_squared;
1381 
1382   /* sample clocks and figure out clock skew */
1383   etime = gst_clock_get_time (GST_ELEMENT_CLOCK (sink));
1384   itime = gst_audio_clock_get_time (sink-&gt;provided_clock);
1385 
1386   /* add new observation */
1387   gst_clock_add_observation (sink-&gt;provided_clock, itime, etime, &amp;r_squared);
1388 #endif
1389 
1390   /* get calibration parameters to compensate for speed and offset differences
1391    * when we are slaved */
1392   gst_clock_get_calibration (sink-&gt;provided_clock, &amp;cinternal, &amp;cexternal,
1393       &amp;crate_num, &amp;crate_denom);
1394 
1395   GST_DEBUG_OBJECT (sink, &quot;internal %&quot; GST_TIME_FORMAT &quot; external %&quot;
1396       GST_TIME_FORMAT &quot; %&quot; G_GUINT64_FORMAT &quot;/%&quot; G_GUINT64_FORMAT &quot; = %f&quot;,
1397       GST_TIME_ARGS (cinternal), GST_TIME_ARGS (cexternal), crate_num,
1398       crate_denom, gst_guint64_to_gdouble (crate_num) /
1399       gst_guint64_to_gdouble (crate_denom));
1400 
1401   if (crate_num == 0)
1402     crate_denom = crate_num = 1;
1403 
1404   /* bring external time to internal time */
1405   render_start = clock_convert_external (render_start, cinternal, cexternal,
1406       crate_num, crate_denom);
1407   render_stop = clock_convert_external (render_stop, cinternal, cexternal,
1408       crate_num, crate_denom);
1409 
1410   GST_DEBUG_OBJECT (sink,
1411       &quot;after slaving: start %&quot; GST_TIME_FORMAT &quot; - stop %&quot; GST_TIME_FORMAT,
1412       GST_TIME_ARGS (render_start), GST_TIME_ARGS (render_stop));
1413 
1414   *srender_start = render_start;
1415   *srender_stop = render_stop;
1416 }
1417 
1418 /* algorithm to calculate sample positions that will result in changing the
1419  * playout pointer to match the clock rate of the master */
1420 static void
1421 gst_audio_base_sink_skew_slaving (GstAudioBaseSink * sink,
1422     GstClockTime render_start, GstClockTime render_stop,
1423     GstClockTime * srender_start, GstClockTime * srender_stop)
1424 {
1425   GstClockTime cinternal, cexternal, crate_num, crate_denom;
1426   GstClockTime etime, itime;
<a name="10" id="anc10"></a><span class="line-modified">1427   GstClockTimeDiff skew, mdrift, mdrift2;</span>
1428   gint driftsamples;
1429   gint64 last_align;
1430 
1431   /* get calibration parameters to compensate for offsets */
1432   gst_clock_get_calibration (sink-&gt;provided_clock, &amp;cinternal, &amp;cexternal,
1433       &amp;crate_num, &amp;crate_denom);
1434 
1435   /* sample clocks and figure out clock skew */
1436   etime = gst_clock_get_time (GST_ELEMENT_CLOCK (sink));
1437   itime = gst_audio_clock_get_time (GST_AUDIO_CLOCK (sink-&gt;provided_clock));
1438   itime =
1439       gst_audio_clock_adjust (GST_AUDIO_CLOCK (sink-&gt;provided_clock), itime);
1440 
1441   GST_DEBUG_OBJECT (sink,
1442       &quot;internal %&quot; GST_TIME_FORMAT &quot; external %&quot; GST_TIME_FORMAT
1443       &quot; cinternal %&quot; GST_TIME_FORMAT &quot; cexternal %&quot; GST_TIME_FORMAT,
1444       GST_TIME_ARGS (itime), GST_TIME_ARGS (etime),
1445       GST_TIME_ARGS (cinternal), GST_TIME_ARGS (cexternal));
1446 
1447   /* make sure we never go below 0 */
1448   etime = etime &gt; cexternal ? etime - cexternal : 0;
1449   itime = itime &gt; cinternal ? itime - cinternal : 0;
1450 
1451   /* do itime - etime.
1452    * positive value means external clock goes slower
1453    * negative value means external clock goes faster */
1454   skew = GST_CLOCK_DIFF (etime, itime);
1455   if (sink-&gt;priv-&gt;avg_skew == -1) {
1456     /* first observation */
1457     sink-&gt;priv-&gt;avg_skew = skew;
1458   } else {
1459     /* next observations use a moving average */
1460     sink-&gt;priv-&gt;avg_skew = (31 * sink-&gt;priv-&gt;avg_skew + skew) / 32;
1461   }
1462 
1463   GST_DEBUG_OBJECT (sink, &quot;internal %&quot; GST_TIME_FORMAT &quot; external %&quot;
1464       GST_TIME_FORMAT &quot; skew %&quot; GST_STIME_FORMAT &quot; avg %&quot; GST_STIME_FORMAT,
1465       GST_TIME_ARGS (itime), GST_TIME_ARGS (etime), GST_STIME_ARGS (skew),
1466       GST_STIME_ARGS (sink-&gt;priv-&gt;avg_skew));
1467 
1468   /* the max drift we allow */
<a name="11" id="anc11"></a><span class="line-modified">1469   mdrift = sink-&gt;priv-&gt;drift_tolerance * 1000;</span>
<span class="line-removed">1470   mdrift2 = mdrift / 2;</span>
1471 
1472   /* adjust playout pointer based on skew */
1473   if (sink-&gt;priv-&gt;avg_skew &gt; mdrift2) {
<a name="12" id="anc12"></a><span class="line-modified">1474     /* master is running slower, move internal time forward */</span>
1475     GST_WARNING_OBJECT (sink,
1476         &quot;correct clock skew %&quot; GST_STIME_FORMAT &quot; &gt; %&quot; GST_STIME_FORMAT,
1477         GST_STIME_ARGS (sink-&gt;priv-&gt;avg_skew), GST_STIME_ARGS (mdrift2));
1478 
<a name="13" id="anc13"></a><span class="line-modified">1479     if (sink-&gt;priv-&gt;avg_skew &gt; (2 * mdrift)) {</span>
<span class="line-modified">1480       cexternal -= sink-&gt;priv-&gt;avg_skew;</span>
<span class="line-modified">1481       sink-&gt;priv-&gt;avg_skew = 0;</span>
<span class="line-modified">1482     } else {</span>
<span class="line-modified">1483     cexternal = cexternal &gt; mdrift ? cexternal - mdrift : 0;</span>
<span class="line-modified">1484     sink-&gt;priv-&gt;avg_skew -= mdrift;</span>
<span class="line-modified">1485     }</span>



1486 
<a name="14" id="anc14"></a><span class="line-modified">1487     driftsamples = (sink-&gt;ringbuffer-&gt;spec.info.rate * mdrift) / GST_SECOND;</span>
1488     last_align = sink-&gt;priv-&gt;last_align;
1489 
1490     /* if we were aligning in the wrong direction or we aligned more than what
1491      * we will correct, resync */
1492     if (last_align &lt; 0 || last_align &gt; driftsamples)
1493       sink-&gt;next_sample = -1;
1494 
1495     GST_DEBUG_OBJECT (sink,
1496         &quot;last_align %&quot; G_GINT64_FORMAT &quot; driftsamples %u, next %&quot;
1497         G_GUINT64_FORMAT, last_align, driftsamples, sink-&gt;next_sample);
1498 
1499     gst_clock_set_calibration (sink-&gt;provided_clock, cinternal, cexternal,
1500         crate_num, crate_denom);
1501   } else if (sink-&gt;priv-&gt;avg_skew &lt; -mdrift2) {
1502     /* master is running faster, move external time forwards */
1503     GST_WARNING_OBJECT (sink,
1504         &quot;correct clock skew %&quot; GST_STIME_FORMAT &quot; &lt; -%&quot; GST_STIME_FORMAT,
1505         GST_STIME_ARGS (sink-&gt;priv-&gt;avg_skew), GST_STIME_ARGS (mdrift2));
1506 
<a name="15" id="anc15"></a><span class="line-modified">1507     if (sink-&gt;priv-&gt;avg_skew &lt; (2 * -mdrift)) {</span>
<span class="line-modified">1508       cexternal -= sink-&gt;priv-&gt;avg_skew;</span>
<span class="line-modified">1509       sink-&gt;priv-&gt;avg_skew = 0;</span>
<span class="line-modified">1510     } else {</span>
<span class="line-modified">1511     cexternal += mdrift;</span>
<span class="line-modified">1512     sink-&gt;priv-&gt;avg_skew += mdrift;</span>
<span class="line-modified">1513     }</span>
1514 
<a name="16" id="anc16"></a><span class="line-modified">1515     driftsamples = (sink-&gt;ringbuffer-&gt;spec.info.rate * mdrift) / GST_SECOND;</span>
1516     last_align = sink-&gt;priv-&gt;last_align;
1517 
1518     /* if we were aligning in the wrong direction or we aligned more than what
1519      * we will correct, resync */
1520     if (last_align &gt; 0 || -last_align &gt; driftsamples)
1521       sink-&gt;next_sample = -1;
1522 
1523     GST_DEBUG_OBJECT (sink,
1524         &quot;last_align %&quot; G_GINT64_FORMAT &quot; driftsamples %u, next %&quot;
1525         G_GUINT64_FORMAT, last_align, driftsamples, sink-&gt;next_sample);
1526 
1527     gst_clock_set_calibration (sink-&gt;provided_clock, cinternal, cexternal,
1528         crate_num, crate_denom);
1529   }
1530 
1531   /* convert, ignoring speed */
1532   render_start = clock_convert_external (render_start, cinternal, cexternal,
1533       crate_num, crate_denom);
1534   render_stop = clock_convert_external (render_stop, cinternal, cexternal,
1535       crate_num, crate_denom);
1536 
1537   *srender_start = render_start;
1538   *srender_stop = render_stop;
1539 }
1540 
1541 /* apply the clock offset but do no slaving otherwise */
1542 static void
1543 gst_audio_base_sink_none_slaving (GstAudioBaseSink * sink,
1544     GstClockTime render_start, GstClockTime render_stop,
1545     GstClockTime * srender_start, GstClockTime * srender_stop)
1546 {
1547   GstClockTime cinternal, cexternal, crate_num, crate_denom;
1548 
1549   /* get calibration parameters to compensate for offsets */
1550   gst_clock_get_calibration (sink-&gt;provided_clock, &amp;cinternal, &amp;cexternal,
1551       &amp;crate_num, &amp;crate_denom);
1552 
1553   /* convert, ignoring speed */
1554   render_start = clock_convert_external (render_start, cinternal, cexternal,
1555       crate_num, crate_denom);
1556   render_stop = clock_convert_external (render_stop, cinternal, cexternal,
1557       crate_num, crate_denom);
1558 
1559   *srender_start = render_start;
1560   *srender_stop = render_stop;
1561 }
1562 
1563 /* converts render_start and render_stop to their slaved values */
1564 static void
1565 gst_audio_base_sink_handle_slaving (GstAudioBaseSink * sink,
1566     GstClockTime render_start, GstClockTime render_stop,
1567     GstClockTime * srender_start, GstClockTime * srender_stop)
1568 {
1569   switch (sink-&gt;priv-&gt;slave_method) {
1570     case GST_AUDIO_BASE_SINK_SLAVE_RESAMPLE:
1571       gst_audio_base_sink_resample_slaving (sink, render_start, render_stop,
1572           srender_start, srender_stop);
1573       break;
1574     case GST_AUDIO_BASE_SINK_SLAVE_SKEW:
1575       gst_audio_base_sink_skew_slaving (sink, render_start, render_stop,
1576           srender_start, srender_stop);
1577       break;
1578     case GST_AUDIO_BASE_SINK_SLAVE_NONE:
1579       gst_audio_base_sink_none_slaving (sink, render_start, render_stop,
1580           srender_start, srender_stop);
1581       break;
1582     case GST_AUDIO_BASE_SINK_SLAVE_CUSTOM:
1583       gst_audio_base_sink_custom_slaving (sink, render_start, render_stop,
1584           srender_start, srender_stop);
1585       break;
1586     default:
1587       g_warning (&quot;unknown slaving method %d&quot;, sink-&gt;priv-&gt;slave_method);
1588       break;
1589   }
1590 }
1591 
1592 /* must be called with LOCK */
1593 static GstFlowReturn
1594 gst_audio_base_sink_sync_latency (GstBaseSink * bsink, GstMiniObject * obj)
1595 {
1596   GstClock *clock;
1597   GstClockReturn status;
1598   GstClockTime time, render_delay;
1599   GstFlowReturn ret;
1600   GstAudioBaseSink *sink;
1601   GstClockTime itime, etime;
1602   GstClockTime rate_num, rate_denom;
1603   GstClockTimeDiff jitter;
1604 
1605   sink = GST_AUDIO_BASE_SINK (bsink);
1606 
1607   clock = GST_ELEMENT_CLOCK (sink);
1608   if (G_UNLIKELY (clock == NULL))
1609     goto no_clock;
1610 
1611   /* we provided the global clock, don&#39;t need to do anything special */
1612   if (clock == sink-&gt;provided_clock)
1613     goto no_slaving;
1614 
1615   GST_OBJECT_UNLOCK (sink);
1616 
1617   do {
1618     GST_DEBUG_OBJECT (sink, &quot;checking preroll&quot;);
1619 
1620     ret = gst_base_sink_do_preroll (bsink, obj);
1621     if (ret != GST_FLOW_OK)
1622       goto flushing;
1623 
1624     GST_OBJECT_LOCK (sink);
1625     time = sink-&gt;priv-&gt;us_latency;
1626     GST_OBJECT_UNLOCK (sink);
1627 
1628     /* Renderdelay is added onto our own latency, and needs
1629      * to be subtracted as well */
1630     render_delay = gst_base_sink_get_render_delay (bsink);
1631 
1632     if (G_LIKELY (time &gt; render_delay))
1633       time -= render_delay;
1634     else
1635       time = 0;
1636 
1637     /* preroll done, we can sync since we are in PLAYING now. */
1638     GST_DEBUG_OBJECT (sink, &quot;possibly waiting for clock to reach %&quot;
1639         GST_TIME_FORMAT, GST_TIME_ARGS (time));
1640 
1641     /* wait for the clock, this can be interrupted because we got shut down or
1642      * we PAUSED. */
1643     status = gst_base_sink_wait_clock (bsink, time, &amp;jitter);
1644 
1645     GST_DEBUG_OBJECT (sink, &quot;clock returned %d %&quot; GST_TIME_FORMAT, status,
1646         GST_TIME_ARGS (jitter));
1647 
1648     /* invalid time, no clock or sync disabled, just continue then */
1649     if (status == GST_CLOCK_BADTIME)
1650       break;
1651 
1652     /* waiting could have been interrupted and we can be flushing now */
1653     if (G_UNLIKELY (bsink-&gt;flushing))
1654       goto flushing;
1655 
1656     /* retry if we got unscheduled, which means we did not reach the timeout
1657      * yet. if some other error occures, we continue. */
1658   } while (status == GST_CLOCK_UNSCHEDULED);
1659 
1660   GST_DEBUG_OBJECT (sink, &quot;latency synced&quot;);
1661 
1662   /* We might need to take the object lock within gst_audio_clock_get_time(),
1663    * so call that before we take it again */
1664   itime = gst_audio_clock_get_time (GST_AUDIO_CLOCK (sink-&gt;provided_clock));
1665   itime =
1666       gst_audio_clock_adjust (GST_AUDIO_CLOCK (sink-&gt;provided_clock), itime);
1667 
1668   GST_OBJECT_LOCK (sink);
1669 
1670   /* when we prerolled in time, we can accurately set the calibration,
1671    * our internal clock should exactly have been the latency (== the running
1672    * time of the external clock) */
1673   etime = GST_ELEMENT_CAST (sink)-&gt;base_time + time;
1674 
1675   if (status == GST_CLOCK_EARLY) {
1676     /* when we prerolled late, we have to take into account the lateness */
1677     GST_DEBUG_OBJECT (sink, &quot;late preroll, adding jitter&quot;);
1678     etime += jitter;
1679   }
1680 
1681   /* start ringbuffer so we can start slaving right away when we need to */
1682   gst_audio_base_sink_force_start (sink);
1683 
1684   GST_DEBUG_OBJECT (sink,
1685       &quot;internal time: %&quot; GST_TIME_FORMAT &quot; external time: %&quot; GST_TIME_FORMAT,
1686       GST_TIME_ARGS (itime), GST_TIME_ARGS (etime));
1687 
1688   /* copy the original calibrated rate but update the internal and external
1689    * times. */
1690   gst_clock_get_calibration (sink-&gt;provided_clock, NULL, NULL, &amp;rate_num,
1691       &amp;rate_denom);
1692   gst_clock_set_calibration (sink-&gt;provided_clock, itime, etime,
1693       rate_num, rate_denom);
1694 
1695   switch (sink-&gt;priv-&gt;slave_method) {
1696     case GST_AUDIO_BASE_SINK_SLAVE_RESAMPLE:
1697       /* only set as master when we are resampling */
1698       GST_DEBUG_OBJECT (sink, &quot;Setting clock as master&quot;);
1699       gst_clock_set_master (sink-&gt;provided_clock, clock);
1700       break;
1701     case GST_AUDIO_BASE_SINK_SLAVE_SKEW:
1702     case GST_AUDIO_BASE_SINK_SLAVE_NONE:
1703     case GST_AUDIO_BASE_SINK_SLAVE_CUSTOM:
1704     default:
1705       break;
1706   }
1707 
1708   gst_audio_base_sink_reset_sync (sink);
1709 
1710   gst_audio_base_sink_custom_cb_report_discont (sink,
1711       GST_AUDIO_BASE_SINK_DISCONT_REASON_SYNC_LATENCY);
1712 
1713   return GST_FLOW_OK;
1714 
1715   /* ERRORS */
1716 no_clock:
1717   {
1718     GST_DEBUG_OBJECT (sink, &quot;we have no clock&quot;);
1719     return GST_FLOW_OK;
1720   }
1721 no_slaving:
1722   {
1723     GST_DEBUG_OBJECT (sink, &quot;we are not slaved&quot;);
1724     return GST_FLOW_OK;
1725   }
1726 flushing:
1727   {
1728     GST_DEBUG_OBJECT (sink, &quot;we are flushing&quot;);
1729     GST_OBJECT_LOCK (sink);
1730     return GST_FLOW_FLUSHING;
1731   }
1732 }
1733 
1734 static gint64
1735 gst_audio_base_sink_get_alignment (GstAudioBaseSink * sink,
1736     GstClockTime sample_offset)
1737 {
1738   GstAudioRingBuffer *ringbuf = sink-&gt;ringbuffer;
1739   gint64 align;
1740   gint64 sample_diff;
1741   gint64 max_sample_diff;
1742   gint segdone = g_atomic_int_get (&amp;ringbuf-&gt;segdone) - ringbuf-&gt;segbase;
1743   gint64 samples_done = segdone * (gint64) ringbuf-&gt;samples_per_seg;
1744   gint64 headroom = sample_offset - samples_done;
1745   gboolean allow_align = TRUE;
1746   gboolean discont = FALSE;
1747   gint rate;
1748 
1749   /* now try to align the sample to the previous one. */
1750 
1751   /* calc align with previous sample and determine how big the
1752    * difference is. */
1753   align = sink-&gt;next_sample - sample_offset;
1754   sample_diff = ABS (align);
1755 
1756   /* calculate the max allowed drift in units of samples. */
1757   rate = GST_AUDIO_INFO_RATE (&amp;ringbuf-&gt;spec.info);
1758   max_sample_diff = gst_util_uint64_scale_int (sink-&gt;priv-&gt;alignment_threshold,
1759       rate, GST_SECOND);
1760 
1761   /* don&#39;t align if it means writing behind the read-segment */
1762   if (sample_diff &gt; headroom &amp;&amp; align &lt; 0)
1763     allow_align = FALSE;
1764 
1765   if (G_UNLIKELY (sample_diff &gt;= max_sample_diff)) {
1766     /* wait before deciding to make a discontinuity */
1767     if (sink-&gt;priv-&gt;discont_wait &gt; 0) {
1768       GstClockTime time = gst_util_uint64_scale_int (sample_offset,
1769           GST_SECOND, rate);
1770       if (sink-&gt;priv-&gt;discont_time == -1) {
1771         /* discont candidate */
1772         sink-&gt;priv-&gt;discont_time = time;
1773       } else if (time - sink-&gt;priv-&gt;discont_time &gt;= sink-&gt;priv-&gt;discont_wait) {
1774         /* discont_wait expired, discontinuity detected */
1775         discont = TRUE;
1776         sink-&gt;priv-&gt;discont_time = -1;
1777       }
1778     } else {
1779       discont = TRUE;
1780     }
1781   } else if (G_UNLIKELY (sink-&gt;priv-&gt;discont_time != -1)) {
1782     /* we have had a discont, but are now back on track! */
1783     sink-&gt;priv-&gt;discont_time = -1;
1784   }
1785 
1786   if (G_LIKELY (!discont &amp;&amp; allow_align)) {
1787     GST_DEBUG_OBJECT (sink,
1788         &quot;align with prev sample, ABS (%&quot; G_GINT64_FORMAT &quot;) &lt; %&quot;
1789         G_GINT64_FORMAT, align, max_sample_diff);
1790   } else {
1791     gint64 diff_s G_GNUC_UNUSED;
1792 
1793     /* calculate sample diff in seconds for error message */
1794     diff_s = gst_util_uint64_scale_int (sample_diff, GST_SECOND, rate);
1795 
1796     /* timestamps drifted apart from previous samples too much, we need to
1797      * resync. We log this as an element warning. */
1798     GST_WARNING_OBJECT (sink,
1799         &quot;Unexpected discontinuity in audio timestamps of &quot;
1800         &quot;%s%&quot; GST_TIME_FORMAT &quot;, resyncing&quot;,
1801         sample_offset &gt; sink-&gt;next_sample ? &quot;+&quot; : &quot;-&quot;, GST_TIME_ARGS (diff_s));
1802     align = 0;
1803 
1804     gst_audio_base_sink_custom_cb_report_discont (sink,
1805         GST_AUDIO_BASE_SINK_DISCONT_REASON_ALIGNMENT);
1806   }
1807 
1808   return align;
1809 }
1810 
1811 static GstFlowReturn
1812 gst_audio_base_sink_render (GstBaseSink * bsink, GstBuffer * buf)
1813 {
1814   GstClockTime time, stop, render_start, render_stop, sample_offset;
1815   GstClockTimeDiff sync_offset, ts_offset;
1816   GstAudioBaseSinkClass *bclass;
1817   GstAudioBaseSink *sink;
1818   GstAudioRingBuffer *ringbuf;
1819   gint64 diff, align;
1820   guint64 ctime, cstop;
1821   gsize offset;
1822   GstMapInfo info;
1823   gsize size;
1824   guint samples, written;
1825   gint bpf, rate;
1826   gint accum;
1827   gint out_samples;
1828   GstClockTime base_time, render_delay, latency;
1829   GstClock *clock;
1830   gboolean sync, slaved, align_next;
1831   GstFlowReturn ret;
1832   GstSegment clip_seg;
1833   gint64 time_offset;
1834   GstBuffer *out = NULL;
1835 
1836   sink = GST_AUDIO_BASE_SINK (bsink);
1837   bclass = GST_AUDIO_BASE_SINK_GET_CLASS (sink);
1838 
1839   ringbuf = sink-&gt;ringbuffer;
1840 
1841   /* can&#39;t do anything when we don&#39;t have the device */
1842   if (G_UNLIKELY (!gst_audio_ring_buffer_is_acquired (ringbuf)))
1843     goto wrong_state;
1844 
1845   /* Wait for upstream latency before starting the ringbuffer, we do this so
1846    * that we can align the first sample of the ringbuffer to the base_time +
1847    * latency. */
1848   GST_OBJECT_LOCK (sink);
1849   base_time = GST_ELEMENT_CAST (sink)-&gt;base_time;
1850   if (G_UNLIKELY (sink-&gt;priv-&gt;sync_latency)) {
1851     ret = gst_audio_base_sink_sync_latency (bsink, GST_MINI_OBJECT_CAST (buf));
1852     GST_OBJECT_UNLOCK (sink);
1853     if (G_UNLIKELY (ret != GST_FLOW_OK))
1854       goto sync_latency_failed;
1855     /* only do this once until we are set back to PLAYING */
1856     sink-&gt;priv-&gt;sync_latency = FALSE;
1857   } else {
1858     GST_OBJECT_UNLOCK (sink);
1859   }
1860 
1861   /* Before we go on, let&#39;s see if we need to payload the data. If yes, we also
1862    * need to unref the output buffer before leaving. */
1863   if (bclass-&gt;payload) {
1864     out = bclass-&gt;payload (sink, buf);
1865 
1866     if (!out)
1867       goto payload_failed;
1868 
1869     buf = out;
1870   }
1871 
1872   bpf = GST_AUDIO_INFO_BPF (&amp;ringbuf-&gt;spec.info);
1873   rate = GST_AUDIO_INFO_RATE (&amp;ringbuf-&gt;spec.info);
1874 
1875   size = gst_buffer_get_size (buf);
1876   if (G_UNLIKELY (size % bpf) != 0)
1877     goto wrong_size;
1878 
1879   samples = size / bpf;
<a name="17" id="anc17"></a><span class="line-removed">1880   out_samples = samples;</span>
1881 
1882   time = GST_BUFFER_TIMESTAMP (buf);
1883 
1884   /* Last ditch attempt to ensure that we only play silence if
1885    * we are in trickmode no-audio mode (or if a buffer is marked as a GAP)
1886    * by dropping the buffer contents and rendering as a gap event instead */
1887   if (G_UNLIKELY ((bsink-&gt;segment.flags &amp; GST_SEGMENT_FLAG_TRICKMODE_NO_AUDIO)
1888           || (buf &amp;&amp; GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_GAP)))) {
1889     GstClockTime duration;
1890     GstEvent *event;
1891     GstBaseSinkClass *bclass;
1892     GST_DEBUG_OBJECT (bsink,
1893         &quot;Received GAP or ignoring audio for trickplay. Dropping contents&quot;);
1894 
1895     duration = gst_util_uint64_scale_int (samples, GST_SECOND, rate);
1896     event = gst_event_new_gap (time, duration);
1897 
1898     bclass = GST_BASE_SINK_GET_CLASS (bsink);
1899     ret = bclass-&gt;wait_event (bsink, event);
1900     gst_event_unref (event);
1901 
1902     /* Ensure we&#39;ll resync on the next buffer as if discont */
1903     sink-&gt;next_sample = -1;
1904     goto done;
1905   }
1906 
1907   GST_DEBUG_OBJECT (sink,
1908       &quot;time %&quot; GST_TIME_FORMAT &quot;, start %&quot;
1909       GST_TIME_FORMAT &quot;, samples %u&quot;, GST_TIME_ARGS (time),
1910       GST_TIME_ARGS (bsink-&gt;segment.start), samples);
1911 
1912   offset = 0;
1913 
1914   /* if not valid timestamp or we can&#39;t clip or sync, try to play
1915    * sample ASAP */
1916   if (!GST_CLOCK_TIME_IS_VALID (time)) {
1917     render_start = gst_audio_base_sink_get_offset (sink);
1918     render_stop = render_start + samples;
1919     GST_DEBUG_OBJECT (sink, &quot;Buffer of size %&quot; G_GSIZE_FORMAT &quot; has no time.&quot;
1920         &quot; Using render_start=%&quot; G_GUINT64_FORMAT, size, render_start);
1921     /* we don&#39;t have a start so we don&#39;t know stop either */
1922     stop = -1;
1923     goto no_align;
1924   }
1925 
1926   /* let&#39;s calc stop based on the number of samples in the buffer instead
1927    * of trusting the DURATION */
1928   stop = time + gst_util_uint64_scale_int (samples, GST_SECOND, rate);
1929 
1930   /* prepare the clipping segment. Since we will be subtracting ts-offset and
1931    * device-delay later we scale the start and stop with those values so that we
1932    * can correctly clip them */
1933   clip_seg.format = GST_FORMAT_TIME;
1934   clip_seg.start = bsink-&gt;segment.start;
1935   clip_seg.stop = bsink-&gt;segment.stop;
1936   clip_seg.duration = -1;
1937 
1938   /* the sync offset is the combination of ts-offset and device-delay */
1939   latency = gst_base_sink_get_latency (bsink);
1940   ts_offset = gst_base_sink_get_ts_offset (bsink);
1941   render_delay = gst_base_sink_get_render_delay (bsink);
1942   sync_offset = ts_offset - render_delay + latency;
1943 
1944   GST_DEBUG_OBJECT (sink,
1945       &quot;sync-offset %&quot; GST_STIME_FORMAT &quot;, render-delay %&quot; GST_TIME_FORMAT
1946       &quot;, ts-offset %&quot; GST_STIME_FORMAT, GST_STIME_ARGS (sync_offset),
1947       GST_TIME_ARGS (render_delay), GST_STIME_ARGS (ts_offset));
1948 
1949   /* compensate for ts-offset and device-delay when negative we need to
1950    * clip. */
1951   if (G_UNLIKELY (sync_offset &lt; 0)) {
1952     clip_seg.start += -sync_offset;
1953     if (clip_seg.stop != -1)
1954       clip_seg.stop += -sync_offset;
1955   }
1956 
1957   /* samples should be rendered based on their timestamp. All samples
1958    * arriving before the segment.start or after segment.stop are to be
1959    * thrown away. All samples should also be clipped to the segment
1960    * boundaries */
1961   if (G_UNLIKELY (!gst_segment_clip (&amp;clip_seg, GST_FORMAT_TIME, time, stop,
1962               &amp;ctime, &amp;cstop)))
1963     goto out_of_segment;
1964 
1965   /* see if some clipping happened */
1966   diff = ctime - time;
1967   if (G_UNLIKELY (diff &gt; 0)) {
1968     /* bring clipped time to samples */
1969     diff = gst_util_uint64_scale_int (diff, rate, GST_SECOND);
1970     GST_DEBUG_OBJECT (sink, &quot;clipping start to %&quot; GST_TIME_FORMAT &quot; %&quot;
1971         G_GUINT64_FORMAT &quot; samples&quot;, GST_TIME_ARGS (ctime), diff);
1972     samples -= diff;
1973     offset += diff * bpf;
1974     time = ctime;
1975   }
1976   diff = stop - cstop;
1977   if (G_UNLIKELY (diff &gt; 0)) {
1978     /* bring clipped time to samples */
1979     diff = gst_util_uint64_scale_int (diff, rate, GST_SECOND);
1980     GST_DEBUG_OBJECT (sink, &quot;clipping stop to %&quot; GST_TIME_FORMAT &quot; %&quot;
1981         G_GUINT64_FORMAT &quot; samples&quot;, GST_TIME_ARGS (cstop), diff);
1982     samples -= diff;
1983     stop = cstop;
1984   }
1985 
1986   /* figure out how to sync */
1987   if (G_LIKELY ((clock = GST_ELEMENT_CLOCK (bsink))))
1988     sync = bsink-&gt;sync;
1989   else
1990     sync = FALSE;
1991 
1992   if (G_UNLIKELY (!sync)) {
1993     /* no sync needed, play sample ASAP */
1994     render_start = gst_audio_base_sink_get_offset (sink);
1995     render_stop = render_start + samples;
1996     GST_DEBUG_OBJECT (sink,
1997         &quot;no sync needed. Using render_start=%&quot; G_GUINT64_FORMAT, render_start);
1998     goto no_align;
1999   }
2000 
2001   /* bring buffer start and stop times to running time */
2002   render_start =
2003       gst_segment_to_running_time (&amp;bsink-&gt;segment, GST_FORMAT_TIME, time);
2004   render_stop =
2005       gst_segment_to_running_time (&amp;bsink-&gt;segment, GST_FORMAT_TIME, stop);
2006 
2007   GST_DEBUG_OBJECT (sink,
2008       &quot;running: start %&quot; GST_TIME_FORMAT &quot; - stop %&quot; GST_TIME_FORMAT,
2009       GST_TIME_ARGS (render_start), GST_TIME_ARGS (render_stop));
2010 
2011   /* store the time of the last sample, we&#39;ll use this to perform sync on the
2012    * last sample when draining the buffer */
2013   if (G_LIKELY (bsink-&gt;segment.rate &gt;= 0.0)) {
2014     sink-&gt;priv-&gt;eos_time = render_stop;
2015   } else {
2016     sink-&gt;priv-&gt;eos_time = render_start;
2017   }
2018 
2019   if (G_UNLIKELY (sync_offset != 0)) {
2020     /* compensate for ts-offset and delay. We know this will not underflow
2021      * because we clipped above. */
<a name="18" id="anc18"></a><span class="line-modified">2022   GST_DEBUG_OBJECT (sink,</span>
<span class="line-modified">2023       &quot;compensating for sync-offset %&quot; GST_TIME_FORMAT,</span>
<span class="line-modified">2024       GST_TIME_ARGS (sync_offset));</span>
<span class="line-modified">2025   render_start += sync_offset;</span>
<span class="line-modified">2026   render_stop += sync_offset;</span>
2027   }
2028 
2029   if (base_time != 0) {
2030     GST_DEBUG_OBJECT (sink, &quot;adding base_time %&quot; GST_TIME_FORMAT,
<a name="19" id="anc19"></a><span class="line-modified">2031       GST_TIME_ARGS (base_time));</span>
2032 
<a name="20" id="anc20"></a><span class="line-modified">2033   /* add base time to sync against the clock */</span>
<span class="line-modified">2034   render_start += base_time;</span>
<span class="line-modified">2035   render_stop += base_time;</span>
2036   }
2037 
2038   if (G_UNLIKELY ((slaved = (clock != sink-&gt;provided_clock)))) {
2039     /* handle clock slaving */
2040     gst_audio_base_sink_handle_slaving (sink, render_start, render_stop,
2041         &amp;render_start, &amp;render_stop);
2042   } else {
2043     /* no slaving needed but we need to adapt to the clock calibration
2044      * parameters */
2045     gst_audio_base_sink_none_slaving (sink, render_start, render_stop,
2046         &amp;render_start, &amp;render_stop);
2047   }
2048 
2049   GST_DEBUG_OBJECT (sink,
2050       &quot;final timestamps: start %&quot; GST_TIME_FORMAT &quot; - stop %&quot; GST_TIME_FORMAT,
2051       GST_TIME_ARGS (render_start), GST_TIME_ARGS (render_stop));
2052 
2053   /* bring to position in the ringbuffer */
2054   time_offset = GST_AUDIO_CLOCK_CAST (sink-&gt;provided_clock)-&gt;time_offset;
2055 
2056   if (G_UNLIKELY (time_offset != 0)) {
2057     GST_DEBUG_OBJECT (sink,
2058         &quot;apply time offset %&quot; GST_STIME_FORMAT, GST_STIME_ARGS (time_offset));
2059 
2060     if (render_start &gt; time_offset)
2061       render_start -= time_offset;
2062     else
2063       render_start = 0;
2064     if (render_stop &gt; time_offset)
2065       render_stop -= time_offset;
2066     else
2067       render_stop = 0;
2068   }
2069 
2070   /* in some clock slaving cases, all late samples end up at 0 first,
2071    * and subsequent ones align with that until threshold exceeded,
2072    * and then sync back to 0 and so on, so avoid that altogether */
2073   if (G_UNLIKELY (render_start == 0 &amp;&amp; render_stop == 0))
2074     goto too_late;
2075 
2076   /* and bring the time to the rate corrected offset in the buffer */
2077   render_start = gst_util_uint64_scale_int (render_start, rate, GST_SECOND);
2078   render_stop = gst_util_uint64_scale_int (render_stop, rate, GST_SECOND);
2079 
2080   /* If the slaving got us an interval spanning 0, render_start will
2081      have been set to 0. So if render_start is 0, we check whether
2082      render_stop is set to contain all samples. If not, we need to
2083      drop samples to match. */
2084   if (render_start == 0) {
2085     guint nsamples = render_stop - render_start;
2086     if (nsamples &lt; samples) {
2087       guint diff;
2088 
2089       diff = samples - nsamples;
2090       GST_DEBUG_OBJECT (bsink, &quot;Clipped start: %u/%u samples&quot;, nsamples,
2091           samples);
2092       samples -= diff;
2093       offset += diff * bpf;
2094     }
2095   }
2096 
2097   /* positive playback rate, first sample is render_start, negative rate, first
2098    * sample is render_stop. When no rate conversion is active, render exactly
2099    * the amount of input samples to avoid aligning to rounding errors. */
2100   if (G_LIKELY (bsink-&gt;segment.rate &gt;= 0.0)) {
2101     sample_offset = render_start;
2102     if (G_LIKELY (bsink-&gt;segment.rate == 1.0))
2103       render_stop = sample_offset + samples;
2104   } else {
2105     sample_offset = render_stop;
2106     if (bsink-&gt;segment.rate == -1.0)
2107       render_start = sample_offset + samples;
2108   }
2109 
2110   /* always resync after a discont */
2111   if (G_UNLIKELY (GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DISCONT) ||
2112           GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_RESYNC))) {
2113     GST_DEBUG_OBJECT (sink, &quot;resync after discont/resync&quot;);
2114     goto no_align;
2115   }
2116 
2117   /* resync when we don&#39;t know what to align the sample with */
2118   if (G_UNLIKELY (sink-&gt;next_sample == -1)) {
2119     GST_DEBUG_OBJECT (sink,
2120         &quot;no align possible: no previous sample position known&quot;);
2121     goto no_align;
2122   }
2123 
2124   align = gst_audio_base_sink_get_alignment (sink, sample_offset);
2125   sink-&gt;priv-&gt;last_align = align;
2126 
2127   /* apply alignment */
2128   render_start += align;
2129 
2130   /* only align stop if we are not slaved to resample */
2131   if (G_UNLIKELY (slaved
2132           &amp;&amp; sink-&gt;priv-&gt;slave_method == GST_AUDIO_BASE_SINK_SLAVE_RESAMPLE)) {
2133     GST_DEBUG_OBJECT (sink, &quot;no stop time align needed: we are slaved&quot;);
2134     goto no_align;
2135   }
2136   render_stop += align;
2137 
2138 no_align:
2139   /* number of target samples is difference between start and stop */
2140   out_samples = render_stop - render_start;
2141 
2142   /* we render the first or last sample first, depending on the rate */
2143   if (G_LIKELY (bsink-&gt;segment.rate &gt;= 0.0))
2144     sample_offset = render_start;
2145   else
2146     sample_offset = render_stop;
2147 
2148   GST_DEBUG_OBJECT (sink, &quot;rendering at %&quot; G_GUINT64_FORMAT &quot; %d/%d&quot;,
2149       sample_offset, samples, out_samples);
2150 
2151   /* we need to accumulate over different runs for when we get interrupted */
2152   accum = 0;
2153   align_next = TRUE;
2154   gst_buffer_map (buf, &amp;info, GST_MAP_READ);
2155   do {
2156     written =
2157         gst_audio_ring_buffer_commit (ringbuf, &amp;sample_offset,
2158         info.data + offset, samples, out_samples, &amp;accum);
2159 
2160     GST_DEBUG_OBJECT (sink, &quot;wrote %u of %u&quot;, written, samples);
2161     /* if we wrote all, we&#39;re done */
2162     if (G_LIKELY (written == samples))
2163       break;
2164 
2165 #ifdef GSTREAMER_LITE
2166     memset(info.data + offset, 0x00, samples*bpf);
2167 #endif // GSTREAMER_LITE
2168 
2169     /* else something interrupted us and we wait for preroll. */
2170     if ((ret = gst_base_sink_wait_preroll (bsink)) != GST_FLOW_OK)
2171       goto stopping;
2172 
2173     /* if we got interrupted, we cannot assume that the next sample should
2174      * be aligned to this one */
2175     align_next = FALSE;
2176 
2177     /* update the output samples. FIXME, this will just skip them when pausing
2178      * during trick mode */
2179     if (out_samples &gt; written) {
2180       out_samples -= written;
2181       accum = 0;
2182     } else
2183       break;
2184 
2185     samples -= written;
2186     offset += written * bpf;
2187   } while (TRUE);
2188   gst_buffer_unmap (buf, &amp;info);
2189 
2190   if (G_LIKELY (align_next))
2191     sink-&gt;next_sample = sample_offset;
2192   else
2193     sink-&gt;next_sample = -1;
2194 
2195   GST_DEBUG_OBJECT (sink, &quot;next sample expected at %&quot; G_GUINT64_FORMAT,
2196       sink-&gt;next_sample);
2197 
2198   if (G_UNLIKELY (GST_CLOCK_TIME_IS_VALID (stop)
2199           &amp;&amp; stop &gt;= bsink-&gt;segment.stop)) {
2200     GST_DEBUG_OBJECT (sink,
2201         &quot;start playback because we are at the end of segment&quot;);
2202     gst_audio_base_sink_force_start (sink);
2203   }
2204 
2205   ret = GST_FLOW_OK;
2206 
2207 done:
2208   if (out)
2209     gst_buffer_unref (out);
2210 
2211   return ret;
2212 
2213   /* SPECIAL cases */
2214 out_of_segment:
2215   {
2216     GST_DEBUG_OBJECT (sink,
2217         &quot;dropping sample out of segment time %&quot; GST_TIME_FORMAT &quot;, start %&quot;
2218         GST_TIME_FORMAT, GST_TIME_ARGS (time),
2219         GST_TIME_ARGS (bsink-&gt;segment.start));
2220     ret = GST_FLOW_OK;
2221     goto done;
2222   }
2223 too_late:
2224   {
2225     GST_DEBUG_OBJECT (sink, &quot;dropping late sample&quot;);
2226     ret = GST_FLOW_OK;
2227     goto done;
2228   }
2229   /* ERRORS */
2230 payload_failed:
2231   {
2232     GST_ELEMENT_ERROR (sink, STREAM, FORMAT, (NULL), (&quot;failed to payload.&quot;));
2233     ret = GST_FLOW_ERROR;
2234     goto done;
2235   }
2236 wrong_state:
2237   {
2238     GST_DEBUG_OBJECT (sink, &quot;ringbuffer not negotiated&quot;);
2239     GST_ELEMENT_ERROR (sink, STREAM, FORMAT, (NULL), (&quot;sink not negotiated.&quot;));
2240     ret = GST_FLOW_NOT_NEGOTIATED;
2241     goto done;
2242   }
2243 wrong_size:
2244   {
2245     GST_DEBUG_OBJECT (sink, &quot;wrong size&quot;);
2246     GST_ELEMENT_ERROR (sink, STREAM, WRONG_TYPE,
2247         (NULL), (&quot;sink received buffer of wrong size.&quot;));
2248     ret = GST_FLOW_ERROR;
2249     goto done;
2250   }
2251 stopping:
2252   {
2253     GST_DEBUG_OBJECT (sink, &quot;preroll got interrupted: %d (%s)&quot;, ret,
2254         gst_flow_get_name (ret));
2255     gst_buffer_unmap (buf, &amp;info);
2256     goto done;
2257   }
2258 sync_latency_failed:
2259   {
2260     GST_DEBUG_OBJECT (sink, &quot;failed waiting for latency&quot;);
2261     goto done;
2262   }
2263 }
2264 
2265 /**
2266  * gst_audio_base_sink_create_ringbuffer:
2267  * @sink: a #GstAudioBaseSink.
2268  *
2269  * Create and return the #GstAudioRingBuffer for @sink. This function will
2270  * call the ::create_ringbuffer vmethod and will set @sink as the parent of
2271  * the returned buffer (see gst_object_set_parent()).
2272  *
2273  * Returns: (transfer none): The new ringbuffer of @sink.
2274  */
2275 GstAudioRingBuffer *
2276 gst_audio_base_sink_create_ringbuffer (GstAudioBaseSink * sink)
2277 {
2278   GstAudioBaseSinkClass *bclass;
2279   GstAudioRingBuffer *buffer = NULL;
2280 
2281   bclass = GST_AUDIO_BASE_SINK_GET_CLASS (sink);
2282   if (bclass-&gt;create_ringbuffer)
2283     buffer = bclass-&gt;create_ringbuffer (sink);
2284 
2285   if (buffer)
2286     gst_object_set_parent (GST_OBJECT (buffer), GST_OBJECT (sink));
2287 
2288   return buffer;
2289 }
2290 
2291 static void
2292 gst_audio_base_sink_callback (GstAudioRingBuffer * rbuf, guint8 * data,
2293     guint len, gpointer user_data)
2294 {
2295   GstBaseSink *basesink;
2296   GstAudioBaseSink *sink;
2297   GstBuffer *buf = NULL;
2298   GstFlowReturn ret;
2299   gsize size;
2300 
2301   basesink = GST_BASE_SINK (user_data);
2302   sink = GST_AUDIO_BASE_SINK (user_data);
2303 
2304   GST_PAD_STREAM_LOCK (basesink-&gt;sinkpad);
2305 
2306   /* would be nice to arrange for pad_alloc_buffer to return data -- as it is we
2307    * will copy twice, once into data, once into DMA */
2308   GST_LOG_OBJECT (basesink, &quot;pulling %u bytes offset %&quot; G_GUINT64_FORMAT
2309       &quot; to fill audio buffer&quot;, len, basesink-&gt;offset);
2310   ret =
2311       gst_pad_pull_range (basesink-&gt;sinkpad, basesink-&gt;segment.position, len,
2312       &amp;buf);
2313 
2314   if (ret != GST_FLOW_OK) {
2315     if (ret == GST_FLOW_EOS)
2316       goto eos;
2317     else
2318       goto error;
2319   }
2320 
2321   GST_BASE_SINK_PREROLL_LOCK (basesink);
2322   if (basesink-&gt;flushing)
2323     goto flushing;
2324 
2325   /* complete preroll and wait for PLAYING */
2326   ret = gst_base_sink_do_preroll (basesink, GST_MINI_OBJECT_CAST (buf));
2327   if (ret != GST_FLOW_OK)
2328     goto preroll_error;
2329 
2330   size = gst_buffer_get_size (buf);
2331 
2332   if (len != size) {
2333     GST_INFO_OBJECT (basesink,
2334         &quot;got different size than requested from sink pad: %u&quot;
2335         &quot; != %&quot; G_GSIZE_FORMAT, len, size);
2336     len = MIN (size, len);
2337   }
2338 
2339   basesink-&gt;segment.position += len;
2340 
2341   gst_buffer_extract (buf, 0, data, len);
2342   GST_BASE_SINK_PREROLL_UNLOCK (basesink);
2343 
2344   GST_PAD_STREAM_UNLOCK (basesink-&gt;sinkpad);
2345 
2346   return;
2347 
2348 error:
2349   {
2350     GST_WARNING_OBJECT (basesink, &quot;Got flow &#39;%s&#39; but can&#39;t return it: %d&quot;,
2351         gst_flow_get_name (ret), ret);
2352     gst_audio_ring_buffer_pause (rbuf);
2353     GST_PAD_STREAM_UNLOCK (basesink-&gt;sinkpad);
2354     return;
2355   }
2356 eos:
2357   {
2358     /* FIXME: this is not quite correct; we&#39;ll be called endlessly until
2359      * the sink gets shut down; maybe we should set a flag somewhere, or
2360      * set segment.stop and segment.duration to the last sample or so */
2361     GST_DEBUG_OBJECT (sink, &quot;EOS&quot;);
2362     gst_audio_base_sink_drain (sink);
2363     gst_audio_ring_buffer_pause (rbuf);
2364     gst_element_post_message (GST_ELEMENT_CAST (sink),
2365         gst_message_new_eos (GST_OBJECT_CAST (sink)));
2366     GST_PAD_STREAM_UNLOCK (basesink-&gt;sinkpad);
2367   }
2368 flushing:
2369   {
2370     GST_DEBUG_OBJECT (sink, &quot;we are flushing&quot;);
2371     gst_audio_ring_buffer_pause (rbuf);
2372     GST_BASE_SINK_PREROLL_UNLOCK (basesink);
2373     GST_PAD_STREAM_UNLOCK (basesink-&gt;sinkpad);
2374     return;
2375   }
2376 preroll_error:
2377   {
2378     GST_DEBUG_OBJECT (sink, &quot;error %s&quot;, gst_flow_get_name (ret));
2379     gst_audio_ring_buffer_pause (rbuf);
2380     GST_BASE_SINK_PREROLL_UNLOCK (basesink);
2381     GST_PAD_STREAM_UNLOCK (basesink-&gt;sinkpad);
2382     return;
2383   }
2384 }
2385 
2386 static gboolean
2387 gst_audio_base_sink_activate_pull (GstBaseSink * basesink, gboolean active)
2388 {
2389   gboolean ret;
2390   GstAudioBaseSink *sink = GST_AUDIO_BASE_SINK (basesink);
2391 
2392   if (active) {
2393     GST_DEBUG_OBJECT (basesink, &quot;activating pull&quot;);
2394 
2395     gst_audio_ring_buffer_set_callback (sink-&gt;ringbuffer,
2396         gst_audio_base_sink_callback, sink);
2397 
2398     ret = gst_audio_ring_buffer_activate (sink-&gt;ringbuffer, TRUE);
2399   } else {
2400     GST_DEBUG_OBJECT (basesink, &quot;deactivating pull&quot;);
2401     gst_audio_ring_buffer_set_callback (sink-&gt;ringbuffer, NULL, NULL);
2402     ret = gst_audio_ring_buffer_activate (sink-&gt;ringbuffer, FALSE);
2403   }
2404 
2405   return ret;
2406 }
2407 
2408 static GstStateChangeReturn
2409 gst_audio_base_sink_change_state (GstElement * element,
2410     GstStateChange transition)
2411 {
2412   GstStateChangeReturn ret = GST_STATE_CHANGE_SUCCESS;
2413   GstAudioBaseSink *sink = GST_AUDIO_BASE_SINK (element);
2414 
2415   switch (transition) {
2416     case GST_STATE_CHANGE_NULL_TO_READY:{
2417       GstAudioRingBuffer *rb;
2418 
<a name="21" id="anc21"></a><span class="line-modified">2419         gst_audio_clock_reset (GST_AUDIO_CLOCK (sink-&gt;provided_clock), 0);</span>
2420       rb = gst_audio_base_sink_create_ringbuffer (sink);
2421       if (rb == NULL)
2422         goto create_failed;
2423 
2424       GST_OBJECT_LOCK (sink);
2425       sink-&gt;ringbuffer = rb;
2426       GST_OBJECT_UNLOCK (sink);
2427 
2428       if (!gst_audio_ring_buffer_open_device (sink-&gt;ringbuffer)) {
2429         GST_OBJECT_LOCK (sink);
2430         gst_object_unparent (GST_OBJECT_CAST (sink-&gt;ringbuffer));
2431         sink-&gt;ringbuffer = NULL;
2432         GST_OBJECT_UNLOCK (sink);
2433         goto open_failed;
2434       }
2435       break;
2436     }
2437     case GST_STATE_CHANGE_READY_TO_PAUSED:
2438       gst_audio_base_sink_reset_sync (sink);
2439       gst_audio_ring_buffer_set_flushing (sink-&gt;ringbuffer, FALSE);
2440       gst_audio_ring_buffer_may_start (sink-&gt;ringbuffer, FALSE);
2441 
2442       /* Only post clock-provide messages if this is the clock that
2443        * we&#39;ve created. If the subclass has overriden it the subclass
2444        * should post this messages whenever necessary */
2445       if (gst_audio_base_sink_is_self_provided_clock (sink))
2446         gst_element_post_message (element,
2447             gst_message_new_clock_provide (GST_OBJECT_CAST (element),
2448                 sink-&gt;provided_clock, TRUE));
2449       break;
2450     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
2451     {
2452       gboolean eos;
2453 
2454       GST_OBJECT_LOCK (sink);
2455       GST_DEBUG_OBJECT (sink, &quot;ringbuffer may start now&quot;);
2456       sink-&gt;priv-&gt;sync_latency = TRUE;
2457       eos = GST_BASE_SINK (sink)-&gt;eos;
2458       GST_OBJECT_UNLOCK (sink);
2459 
2460 #ifdef GSTREAMER_LITE
2461       gst_audio_ring_buffer_clear_all(sink-&gt;ringbuffer);
2462 #endif // GSTREAMER_LITE
2463 
2464       gst_audio_ring_buffer_may_start (sink-&gt;ringbuffer, TRUE);
2465       if (GST_BASE_SINK_CAST (sink)-&gt;pad_mode == GST_PAD_MODE_PULL ||
2466           g_atomic_int_get (&amp;sink-&gt;eos_rendering) || eos) {
2467         /* we always start the ringbuffer in pull mode immediatly */
2468         /* sync rendering on eos needs running clock,
2469          * and others need running clock when finished rendering eos */
2470         gst_audio_ring_buffer_start (sink-&gt;ringbuffer);
2471       }
2472       break;
2473     }
2474     case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
2475       /* ringbuffer cannot start anymore */
2476       gst_audio_ring_buffer_may_start (sink-&gt;ringbuffer, FALSE);
2477       gst_audio_ring_buffer_pause (sink-&gt;ringbuffer);
2478 
2479       GST_OBJECT_LOCK (sink);
2480       sink-&gt;priv-&gt;sync_latency = FALSE;
2481       GST_OBJECT_UNLOCK (sink);
2482       break;
2483     case GST_STATE_CHANGE_PAUSED_TO_READY:
2484       /* Only post clock-lost messages if this is the clock that
2485        * we&#39;ve created. If the subclass has overriden it the subclass
2486        * should post this messages whenever necessary */
2487       if (gst_audio_base_sink_is_self_provided_clock (sink))
2488         gst_element_post_message (element,
2489             gst_message_new_clock_lost (GST_OBJECT_CAST (element),
2490                 sink-&gt;provided_clock));
2491 
2492       /* make sure we unblock before calling the parent state change
2493        * so it can grab the STREAM_LOCK */
2494       gst_audio_ring_buffer_set_flushing (sink-&gt;ringbuffer, TRUE);
2495       break;
2496     default:
2497       break;
2498   }
2499 
2500   ret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
2501 
2502   switch (transition) {
2503     case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
2504       /* stop slaving ourselves to the master, if any */
2505       gst_clock_set_master (sink-&gt;provided_clock, NULL);
2506       break;
2507     case GST_STATE_CHANGE_PAUSED_TO_READY:
2508       gst_audio_ring_buffer_activate (sink-&gt;ringbuffer, FALSE);
2509       gst_audio_ring_buffer_release (sink-&gt;ringbuffer);
2510       break;
2511     case GST_STATE_CHANGE_READY_TO_NULL:
2512       /* we release again here because the acquire happens when setting the
2513        * caps, which happens before we commit the state to PAUSED and thus the
2514        * PAUSED-&gt;READY state change (see above, where we release the ringbuffer)
2515        * might not be called when we get here. */
2516       gst_audio_ring_buffer_activate (sink-&gt;ringbuffer, FALSE);
2517       gst_audio_ring_buffer_release (sink-&gt;ringbuffer);
2518       gst_audio_ring_buffer_close_device (sink-&gt;ringbuffer);
2519       GST_OBJECT_LOCK (sink);
2520       gst_object_unparent (GST_OBJECT_CAST (sink-&gt;ringbuffer));
2521       sink-&gt;ringbuffer = NULL;
2522       GST_OBJECT_UNLOCK (sink);
2523       break;
2524     default:
2525       break;
2526   }
2527 
2528   return ret;
2529 
2530   /* ERRORS */
2531 create_failed:
2532   {
2533     /* subclass must post a meaningful error message */
2534     GST_DEBUG_OBJECT (sink, &quot;create failed&quot;);
2535     return GST_STATE_CHANGE_FAILURE;
2536   }
2537 open_failed:
2538   {
2539     /* subclass must post a meaningful error message */
2540     GST_DEBUG_OBJECT (sink, &quot;open failed&quot;);
2541     return GST_STATE_CHANGE_FAILURE;
2542   }
2543 }
<a name="22" id="anc22"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="22" type="hidden" />
</body>
</html>