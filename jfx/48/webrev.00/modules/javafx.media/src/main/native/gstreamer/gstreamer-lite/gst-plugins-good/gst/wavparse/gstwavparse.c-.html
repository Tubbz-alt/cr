<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/wavparse/gstwavparse.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* -*- Mode: C; tab-width: 2; indent-tabs-mode: t; c-basic-offset: 2 -*- */
   2 /* GStreamer
   3  * Copyright (C) &lt;1999&gt; Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   4  * Copyright (C) &lt;2006&gt; Nokia Corporation, Stefan Kost &lt;stefan.kost@nokia.com&gt;.
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 /**
  23  * SECTION:element-wavparse
  24  *
  25  * Parse a .wav file into raw or compressed audio.
  26  *
  27  * Wavparse supports both push and pull mode operations, making it possible to
  28  * stream from a network source.
  29  *
  30  * &lt;refsect2&gt;
  31  * &lt;title&gt;Example launch line&lt;/title&gt;
  32  * |[
  33  * gst-launch-1.0 filesrc location=sine.wav ! wavparse ! audioconvert ! alsasink
  34  * ]| Read a wav file and output to the soundcard using the ALSA element. The
  35  * wav file is assumed to contain raw uncompressed samples.
  36  * |[
  37  * gst-launch-1.0 gnomevfssrc location=http://www.example.org/sine.wav ! queue ! wavparse ! audioconvert ! alsasink
  38  * ]| Stream data from a network url.
  39  * &lt;/refsect2&gt;
  40  */
  41 
  42 /*
  43  * TODO:
  44  * http://replaygain.hydrogenaudio.org/file_format_wav.html
  45  */
  46 
  47 #ifdef HAVE_CONFIG_H
  48 #include &quot;config.h&quot;
  49 #endif
  50 
  51 #include &lt;string.h&gt;
  52 #include &lt;math.h&gt;
  53 
  54 #include &quot;gstwavparse.h&quot;
  55 #include &quot;gst/riff/riff-media.h&quot;
  56 #include &lt;gst/base/gsttypefindhelper.h&gt;
  57 #include &lt;gst/pbutils/descriptions.h&gt;
  58 #include &lt;gst/gst-i18n-plugin.h&gt;
  59 
  60 #ifdef GSTREAMER_LITE
  61 #include &lt;fxplugins_common.h&gt;
  62 #endif // GSTREAMER_LITE
  63 
  64 GST_DEBUG_CATEGORY_STATIC (wavparse_debug);
  65 #define GST_CAT_DEFAULT (wavparse_debug)
  66 
  67 /* Data size chunk of RF64,
  68  * see http://tech.ebu.ch/docs/tech/tech3306-2009.pdf */
  69 #define GST_RS64_TAG_DS64 GST_MAKE_FOURCC (&#39;d&#39;,&#39;s&#39;,&#39;6&#39;,&#39;4&#39;)
  70 
  71 static void gst_wavparse_dispose (GObject * object);
  72 
  73 static gboolean gst_wavparse_sink_activate (GstPad * sinkpad,
  74     GstObject * parent);
  75 static gboolean gst_wavparse_sink_activate_mode (GstPad * sinkpad,
  76     GstObject * parent, GstPadMode mode, gboolean active);
  77 static gboolean gst_wavparse_send_event (GstElement * element,
  78     GstEvent * event);
  79 static GstStateChangeReturn gst_wavparse_change_state (GstElement * element,
  80     GstStateChange transition);
  81 #ifdef GSTREAMER_LITE
  82 static gboolean gst_wavparse_sink_query (GstPad * pad, GstObject *parent, GstQuery * query);
  83 #endif // GSTREAMER_LITE
  84 
  85 static gboolean gst_wavparse_pad_query (GstPad * pad, GstObject * parent,
  86     GstQuery * query);
  87 static gboolean gst_wavparse_pad_convert (GstPad * pad, GstFormat src_format,
  88     gint64 src_value, GstFormat * dest_format, gint64 * dest_value);
  89 
  90 static GstFlowReturn gst_wavparse_chain (GstPad * pad, GstObject * parent,
  91     GstBuffer * buf);
  92 static gboolean gst_wavparse_sink_event (GstPad * pad, GstObject * parent,
  93     GstEvent * event);
  94 static void gst_wavparse_loop (GstPad * pad);
  95 static gboolean gst_wavparse_srcpad_event (GstPad * pad, GstObject * parent,
  96     GstEvent * event);
  97 
  98 static void gst_wavparse_set_property (GObject * object, guint prop_id,
  99     const GValue * value, GParamSpec * pspec);
 100 static void gst_wavparse_get_property (GObject * object, guint prop_id,
 101     GValue * value, GParamSpec * pspec);
 102 
 103 #define DEFAULT_IGNORE_LENGTH FALSE
 104 
 105 enum
 106 {
 107   PROP_0,
 108   PROP_IGNORE_LENGTH,
 109 };
 110 
 111 static GstStaticPadTemplate sink_template_factory =
 112 GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,
 113     GST_PAD_SINK,
 114     GST_PAD_ALWAYS,
 115     GST_STATIC_CAPS (&quot;audio/x-wav&quot;)
 116     );
 117 
 118 #define DEBUG_INIT \
 119   GST_DEBUG_CATEGORY_INIT (wavparse_debug, &quot;wavparse&quot;, 0, &quot;WAV parser&quot;);
 120 
 121 #define gst_wavparse_parent_class parent_class
 122 G_DEFINE_TYPE_WITH_CODE (GstWavParse, gst_wavparse, GST_TYPE_ELEMENT,
 123     DEBUG_INIT);
 124 
 125 typedef struct
 126 {
 127   /* Offset Size    Description   Value
 128    * 0x00   4       ID            unique identification value
 129    * 0x04   4       Position      play order position
 130    * 0x08   4       Data Chunk ID RIFF ID of corresponding data chunk
 131    * 0x0c   4       Chunk Start   Byte Offset of Data Chunk *
 132    * 0x10   4       Block Start   Byte Offset to sample of First Channel
 133    * 0x14   4       Sample Offset Byte Offset to sample byte of First Channel
 134    */
 135   guint32 id;
 136   guint32 position;
 137   guint32 data_chunk_id;
 138   guint32 chunk_start;
 139   guint32 block_start;
 140   guint32 sample_offset;
 141 } GstWavParseCue;
 142 
 143 typedef struct
 144 {
 145   /* Offset Size    Description     Value
 146    * 0x08   4       Cue Point ID    0 - 0xFFFFFFFF
 147    * 0x0c           Text
 148    */
 149   guint32 cue_point_id;
 150   gchar *text;
 151 } GstWavParseLabl, GstWavParseNote;
 152 
 153 static void
 154 gst_wavparse_class_init (GstWavParseClass * klass)
 155 {
 156   GstElementClass *gstelement_class;
 157   GObjectClass *object_class;
 158   GstPadTemplate *src_template;
 159 
 160   gstelement_class = (GstElementClass *) klass;
 161   object_class = (GObjectClass *) klass;
 162 
 163   parent_class = g_type_class_peek_parent (klass);
 164 
 165   object_class-&gt;dispose = gst_wavparse_dispose;
 166 
 167   object_class-&gt;set_property = gst_wavparse_set_property;
 168   object_class-&gt;get_property = gst_wavparse_get_property;
 169 
 170   /**
 171    * GstWavParse:ignore-length:
 172    *
 173    * This selects whether the length found in a data chunk
 174    * should be ignored. This may be useful for streamed audio
 175    * where the length is unknown until the end of streaming,
 176    * and various software/hardware just puts some random value
 177    * in there and hopes it doesn&#39;t break too much.
 178    */
 179   g_object_class_install_property (object_class, PROP_IGNORE_LENGTH,
 180       g_param_spec_boolean (&quot;ignore-length&quot;,
 181           &quot;Ignore length&quot;,
 182           &quot;Ignore length from the Wave header&quot;,
 183           DEFAULT_IGNORE_LENGTH, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS)
 184       );
 185 
 186   gstelement_class-&gt;change_state = gst_wavparse_change_state;
 187   gstelement_class-&gt;send_event = gst_wavparse_send_event;
 188 
 189   /* register pads */
 190   gst_element_class_add_static_pad_template (gstelement_class,
 191       &amp;sink_template_factory);
 192 
 193   src_template = gst_pad_template_new (&quot;src&quot;, GST_PAD_SRC,
 194       GST_PAD_ALWAYS, gst_riff_create_audio_template_caps ());
 195   gst_element_class_add_pad_template (gstelement_class, src_template);
 196 
 197   gst_element_class_set_static_metadata (gstelement_class, &quot;WAV audio demuxer&quot;,
 198       &quot;Codec/Demuxer/Audio&quot;,
 199       &quot;Parse a .wav file into raw audio&quot;,
 200       &quot;Erik Walthinsen &lt;omega@cse.ogi.edu&gt;&quot;);
 201 }
 202 
 203 static void
 204 gst_wavparse_notes_free (GstWavParseNote * note)
 205 {
 206   if (note)
 207     g_free (note-&gt;text);
 208   g_free (note);
 209 }
 210 
 211 static void
 212 gst_wavparse_labls_free (GstWavParseLabl * labl)
 213 {
 214   if (labl)
 215     g_free (labl-&gt;text);
 216   g_free (labl);
 217 }
 218 
 219 static void
 220 gst_wavparse_reset (GstWavParse * wav)
 221 {
 222   wav-&gt;state = GST_WAVPARSE_START;
 223 
 224   /* These will all be set correctly in the fmt chunk */
 225   wav-&gt;depth = 0;
 226   wav-&gt;rate = 0;
 227   wav-&gt;width = 0;
 228   wav-&gt;channels = 0;
 229   wav-&gt;blockalign = 0;
 230   wav-&gt;bps = 0;
 231   wav-&gt;fact = 0;
 232   wav-&gt;offset = 0;
 233   wav-&gt;end_offset = 0;
 234   wav-&gt;dataleft = 0;
 235   wav-&gt;datasize = 0;
 236   wav-&gt;datastart = 0;
 237   wav-&gt;chunk_size = 0;
 238   wav-&gt;duration = 0;
 239   wav-&gt;got_fmt = FALSE;
 240   wav-&gt;first = TRUE;
 241 
 242   if (wav-&gt;seek_event)
 243     gst_event_unref (wav-&gt;seek_event);
 244   wav-&gt;seek_event = NULL;
 245   if (wav-&gt;adapter) {
 246     gst_adapter_clear (wav-&gt;adapter);
 247     g_object_unref (wav-&gt;adapter);
 248     wav-&gt;adapter = NULL;
 249   }
 250   if (wav-&gt;tags)
 251     gst_tag_list_unref (wav-&gt;tags);
 252   wav-&gt;tags = NULL;
 253   if (wav-&gt;toc)
 254     gst_toc_unref (wav-&gt;toc);
 255   wav-&gt;toc = NULL;
 256   if (wav-&gt;cues)
 257     g_list_free_full (wav-&gt;cues, g_free);
 258   wav-&gt;cues = NULL;
 259   if (wav-&gt;labls)
 260     g_list_free_full (wav-&gt;labls, (GDestroyNotify) gst_wavparse_labls_free);
 261   wav-&gt;labls = NULL;
 262   if (wav-&gt;notes)
 263     g_list_free_full (wav-&gt;notes, (GDestroyNotify) gst_wavparse_notes_free);
 264   wav-&gt;notes = NULL;
 265   if (wav-&gt;caps)
 266     gst_caps_unref (wav-&gt;caps);
 267   wav-&gt;caps = NULL;
 268   if (wav-&gt;start_segment)
 269     gst_event_unref (wav-&gt;start_segment);
 270   wav-&gt;start_segment = NULL;
 271 }
 272 
 273 static void
 274 gst_wavparse_dispose (GObject * object)
 275 {
 276   GstWavParse *wav = GST_WAVPARSE (object);
 277 
 278   GST_DEBUG_OBJECT (wav, &quot;WAV: Dispose&quot;);
 279   gst_wavparse_reset (wav);
 280 
 281   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
 282 }
 283 
 284 static void
 285 gst_wavparse_init (GstWavParse * wavparse)
 286 {
 287 #ifdef GSTREAMER_LITE
 288     GstElementClass *klass = GST_ELEMENT_GET_CLASS (wavparse);
 289     GstPadTemplate *src_template;
 290 #endif // GSTREAMER_LITE
 291 
 292   gst_wavparse_reset (wavparse);
 293 
 294   /* sink */
 295   wavparse-&gt;sinkpad =
 296       gst_pad_new_from_static_template (&amp;sink_template_factory, &quot;sink&quot;);
 297   gst_pad_set_activate_function (wavparse-&gt;sinkpad,
 298       GST_DEBUG_FUNCPTR (gst_wavparse_sink_activate));
 299   gst_pad_set_activatemode_function (wavparse-&gt;sinkpad,
 300       GST_DEBUG_FUNCPTR (gst_wavparse_sink_activate_mode));
 301   gst_pad_set_chain_function (wavparse-&gt;sinkpad,
 302       GST_DEBUG_FUNCPTR (gst_wavparse_chain));
 303   gst_pad_set_event_function (wavparse-&gt;sinkpad,
 304       GST_DEBUG_FUNCPTR (gst_wavparse_sink_event));
 305 
 306 #ifdef GSTREAMER_LITE
 307     gst_pad_set_query_function (wavparse-&gt;sinkpad,
 308             GST_DEBUG_FUNCPTR (gst_wavparse_sink_query));
 309 #endif // GSTREAMER_LITE
 310 
 311   gst_element_add_pad (GST_ELEMENT_CAST (wavparse), wavparse-&gt;sinkpad);
 312 
 313   /* src */
 314   wavparse-&gt;srcpad =
 315       gst_pad_new_from_template (gst_element_class_get_pad_template
 316       (GST_ELEMENT_GET_CLASS (wavparse), &quot;src&quot;), &quot;src&quot;);
 317   gst_pad_use_fixed_caps (wavparse-&gt;srcpad);
 318   gst_pad_set_query_function (wavparse-&gt;srcpad,
 319       GST_DEBUG_FUNCPTR (gst_wavparse_pad_query));
 320   gst_pad_set_event_function (wavparse-&gt;srcpad,
 321       GST_DEBUG_FUNCPTR (gst_wavparse_srcpad_event));
 322     gst_element_add_pad (GST_ELEMENT_CAST (wavparse), wavparse-&gt;srcpad);
 323 }
 324 
 325 static gboolean
 326 gst_wavparse_parse_file_header (GstElement * element, GstBuffer * buf)
 327 {
 328   guint32 doctype;
 329 
 330   if (!gst_riff_parse_file_header (element, buf, &amp;doctype))
 331     return FALSE;
 332 
 333   if (doctype != GST_RIFF_RIFF_WAVE)
 334     goto not_wav;
 335 
 336   return TRUE;
 337 
 338   /* ERRORS */
 339 not_wav:
 340   {
 341     GST_ELEMENT_ERROR (element, STREAM, WRONG_TYPE, (NULL),
 342         (&quot;File is not a WAVE file: 0x%&quot; G_GINT32_MODIFIER &quot;x&quot;, doctype));
 343     return FALSE;
 344   }
 345 }
 346 
 347 static GstFlowReturn
 348 gst_wavparse_stream_init (GstWavParse * wav)
 349 {
 350   GstFlowReturn res;
 351   GstBuffer *buf = NULL;
 352 
 353   if ((res = gst_pad_pull_range (wav-&gt;sinkpad,
 354               wav-&gt;offset, 12, &amp;buf)) != GST_FLOW_OK)
 355     return res;
 356   else if (!gst_wavparse_parse_file_header (GST_ELEMENT_CAST (wav), buf))
 357     return GST_FLOW_ERROR;
 358 
 359   wav-&gt;offset += 12;
 360 
 361   return GST_FLOW_OK;
 362 }
 363 
 364 static gboolean
 365 gst_wavparse_time_to_bytepos (GstWavParse * wav, gint64 ts, gint64 * bytepos)
 366 {
 367   /* -1 always maps to -1 */
 368   if (ts == -1) {
 369     *bytepos = -1;
 370     return TRUE;
 371   }
 372 
 373   /* 0 always maps to 0 */
 374   if (ts == 0) {
 375     *bytepos = 0;
 376     return TRUE;
 377   }
 378 
 379   if (wav-&gt;bps &gt; 0) {
 380     *bytepos = gst_util_uint64_scale_ceil (ts, (guint64) wav-&gt;bps, GST_SECOND);
 381     return TRUE;
 382   } else if (wav-&gt;fact) {
 383     guint64 bps = gst_util_uint64_scale (wav-&gt;datasize, wav-&gt;rate, wav-&gt;fact);
 384     *bytepos = gst_util_uint64_scale_ceil (ts, bps, GST_SECOND);
 385     return TRUE;
 386   }
 387 
 388   return FALSE;
 389 }
 390 
 391 /* This function is used to perform seeks on the element.
 392  *
 393  * It also works when event is NULL, in which case it will just
 394  * start from the last configured segment. This technique is
 395  * used when activating the element and to perform the seek in
 396  * READY.
 397  */
 398 static gboolean
 399 gst_wavparse_perform_seek (GstWavParse * wav, GstEvent * event)
 400 {
 401   gboolean res;
 402   gdouble rate;
 403   GstFormat format, bformat;
 404   GstSeekFlags flags;
 405   GstSeekType cur_type = GST_SEEK_TYPE_NONE, stop_type;
 406   gint64 cur, stop, upstream_size;
 407   gboolean flush;
 408   gboolean update;
 409   GstSegment seeksegment = { 0, };
 410   gint64 last_stop;
 411   guint32 seqnum = 0;
 412 
 413   if (event) {
 414     GST_DEBUG_OBJECT (wav, &quot;doing seek with event&quot;);
 415 
 416     gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags,
 417         &amp;cur_type, &amp;cur, &amp;stop_type, &amp;stop);
 418     seqnum = gst_event_get_seqnum (event);
 419 
 420     /* no negative rates yet */
 421     if (rate &lt; 0.0)
 422       goto negative_rate;
 423 
 424     if (format != wav-&gt;segment.format) {
 425       GST_INFO_OBJECT (wav, &quot;converting seek-event from %s to %s&quot;,
 426           gst_format_get_name (format),
 427           gst_format_get_name (wav-&gt;segment.format));
 428       res = TRUE;
 429       if (cur_type != GST_SEEK_TYPE_NONE)
 430         res =
 431             gst_pad_query_convert (wav-&gt;srcpad, format, cur,
 432             wav-&gt;segment.format, &amp;cur);
 433       if (res &amp;&amp; stop_type != GST_SEEK_TYPE_NONE)
 434         res =
 435             gst_pad_query_convert (wav-&gt;srcpad, format, stop,
 436             wav-&gt;segment.format, &amp;stop);
 437       if (!res)
 438         goto no_format;
 439 
 440       format = wav-&gt;segment.format;
 441     }
 442   } else {
 443     GST_DEBUG_OBJECT (wav, &quot;doing seek without event&quot;);
 444     flags = 0;
 445     rate = 1.0;
 446     cur_type = GST_SEEK_TYPE_SET;
 447     stop_type = GST_SEEK_TYPE_SET;
 448   }
 449 
 450   /* in push mode, we must delegate to upstream */
 451   if (wav-&gt;streaming) {
 452     gboolean res = FALSE;
 453 
 454     /* if streaming not yet started; only prepare initial newsegment */
 455     if (!event || wav-&gt;state != GST_WAVPARSE_DATA) {
 456       if (wav-&gt;start_segment)
 457         gst_event_unref (wav-&gt;start_segment);
 458       wav-&gt;start_segment = gst_event_new_segment (&amp;wav-&gt;segment);
 459       res = TRUE;
 460     } else {
 461       /* convert seek positions to byte positions in data sections */
 462       if (format == GST_FORMAT_TIME) {
 463         /* should not fail */
 464         if (!gst_wavparse_time_to_bytepos (wav, cur, &amp;cur))
 465           goto no_position;
 466         if (!gst_wavparse_time_to_bytepos (wav, stop, &amp;stop))
 467           goto no_position;
 468       }
 469       /* mind sample boundary and header */
 470       if (cur &gt;= 0) {
 471         cur -= (cur % wav-&gt;bytes_per_sample);
 472         cur += wav-&gt;datastart;
 473       }
 474       if (stop &gt;= 0) {
 475         stop -= (stop % wav-&gt;bytes_per_sample);
 476         stop += wav-&gt;datastart;
 477       }
 478       GST_DEBUG_OBJECT (wav, &quot;Pushing BYTE seek rate %g, &quot;
 479           &quot;start %&quot; G_GINT64_FORMAT &quot;, stop %&quot; G_GINT64_FORMAT, rate, cur,
 480           stop);
 481       /* BYTE seek event */
 482       event = gst_event_new_seek (rate, GST_FORMAT_BYTES, flags, cur_type, cur,
 483           stop_type, stop);
 484       gst_event_set_seqnum (event, seqnum);
 485       res = gst_pad_push_event (wav-&gt;sinkpad, event);
 486     }
 487     return res;
 488   }
 489 
 490   /* get flush flag */
 491   flush = flags &amp; GST_SEEK_FLAG_FLUSH;
 492 
 493   /* now we need to make sure the streaming thread is stopped. We do this by
 494    * either sending a FLUSH_START event downstream which will cause the
 495    * streaming thread to stop with a WRONG_STATE.
 496    * For a non-flushing seek we simply pause the task, which will happen as soon
 497    * as it completes one iteration (and thus might block when the sink is
 498    * blocking in preroll). */
 499   if (flush) {
 500     GstEvent *fevent;
 501       GST_DEBUG_OBJECT (wav, &quot;sending flush start&quot;);
 502 
 503     fevent = gst_event_new_flush_start ();
 504     gst_event_set_seqnum (fevent, seqnum);
 505     gst_pad_push_event (wav-&gt;sinkpad, gst_event_ref (fevent));
 506     gst_pad_push_event (wav-&gt;srcpad, fevent);
 507   } else {
 508     gst_pad_pause_task (wav-&gt;sinkpad);
 509   }
 510 
 511   /* we should now be able to grab the streaming thread because we stopped it
 512    * with the above flush/pause code */
 513   GST_PAD_STREAM_LOCK (wav-&gt;sinkpad);
 514 
 515   /* save current position */
 516   last_stop = wav-&gt;segment.position;
 517 
 518   GST_DEBUG_OBJECT (wav, &quot;stopped streaming at %&quot; G_GINT64_FORMAT, last_stop);
 519 
 520   /* copy segment, we need this because we still need the old
 521    * segment when we close the current segment. */
 522   memcpy (&amp;seeksegment, &amp;wav-&gt;segment, sizeof (GstSegment));
 523 
 524   /* configure the seek parameters in the seeksegment. We will then have the
 525    * right values in the segment to perform the seek */
 526   if (event) {
 527     GST_DEBUG_OBJECT (wav, &quot;configuring seek&quot;);
 528     gst_segment_do_seek (&amp;seeksegment, rate, format, flags,
 529         cur_type, cur, stop_type, stop, &amp;update);
 530   }
 531 
 532   /* figure out the last position we need to play. If it&#39;s configured (stop !=
 533    * -1), use that, else we play until the total duration of the file */
 534   if ((stop = seeksegment.stop) == -1)
 535     stop = seeksegment.duration;
 536 
 537   GST_DEBUG_OBJECT (wav, &quot;cur_type =%d&quot;, cur_type);
 538   if ((cur_type != GST_SEEK_TYPE_NONE)) {
 539     /* bring offset to bytes, if the bps is 0, we have the segment in BYTES and
 540      * we can just copy the last_stop. If not, we use the bps to convert TIME to
 541      * bytes. */
 542     if (!gst_wavparse_time_to_bytepos (wav, seeksegment.position,
 543             (gint64 *) &amp; wav-&gt;offset))
 544       wav-&gt;offset = seeksegment.position;
 545     GST_LOG_OBJECT (wav, &quot;offset=%&quot; G_GUINT64_FORMAT, wav-&gt;offset);
 546     wav-&gt;offset -= (wav-&gt;offset % wav-&gt;bytes_per_sample);
 547     GST_LOG_OBJECT (wav, &quot;offset=%&quot; G_GUINT64_FORMAT, wav-&gt;offset);
 548     wav-&gt;offset += wav-&gt;datastart;
 549     GST_LOG_OBJECT (wav, &quot;offset=%&quot; G_GUINT64_FORMAT, wav-&gt;offset);
 550   } else {
 551     GST_LOG_OBJECT (wav, &quot;continue from offset=%&quot; G_GUINT64_FORMAT,
 552         wav-&gt;offset);
 553   }
 554 
 555   if (stop_type != GST_SEEK_TYPE_NONE) {
 556     if (!gst_wavparse_time_to_bytepos (wav, stop, (gint64 *) &amp; wav-&gt;end_offset))
 557       wav-&gt;end_offset = stop;
 558     GST_LOG_OBJECT (wav, &quot;end_offset=%&quot; G_GUINT64_FORMAT, wav-&gt;end_offset);
 559     wav-&gt;end_offset -= (wav-&gt;end_offset % wav-&gt;bytes_per_sample);
 560     GST_LOG_OBJECT (wav, &quot;end_offset=%&quot; G_GUINT64_FORMAT, wav-&gt;end_offset);
 561     wav-&gt;end_offset += wav-&gt;datastart;
 562     GST_LOG_OBJECT (wav, &quot;end_offset=%&quot; G_GUINT64_FORMAT, wav-&gt;end_offset);
 563   } else {
 564     GST_LOG_OBJECT (wav, &quot;continue to end_offset=%&quot; G_GUINT64_FORMAT,
 565         wav-&gt;end_offset);
 566   }
 567 
 568   /* make sure filesize is not exceeded due to rounding errors or so,
 569    * same precaution as in _stream_headers */
 570   bformat = GST_FORMAT_BYTES;
 571   if (gst_pad_peer_query_duration (wav-&gt;sinkpad, bformat, &amp;upstream_size))
 572     wav-&gt;end_offset = MIN (wav-&gt;end_offset, upstream_size);
 573 
 574   if (wav-&gt;datasize &gt; 0 &amp;&amp; wav-&gt;end_offset &gt; wav-&gt;datastart + wav-&gt;datasize)
 575     wav-&gt;end_offset = wav-&gt;datastart + wav-&gt;datasize;
 576 
 577   /* this is the range of bytes we will use for playback */
 578   wav-&gt;offset = MIN (wav-&gt;offset, wav-&gt;end_offset);
 579   wav-&gt;dataleft = wav-&gt;end_offset - wav-&gt;offset;
 580 
 581   GST_DEBUG_OBJECT (wav,
 582       &quot;seek: rate %lf, offset %&quot; G_GUINT64_FORMAT &quot;, end %&quot; G_GUINT64_FORMAT
 583       &quot;, segment %&quot; GST_TIME_FORMAT &quot; -- %&quot; GST_TIME_FORMAT, rate, wav-&gt;offset,
 584       wav-&gt;end_offset, GST_TIME_ARGS (seeksegment.start), GST_TIME_ARGS (stop));
 585 
 586   /* prepare for streaming again */
 587     if (flush) {
 588     GstEvent *fevent;
 589 
 590       /* if we sent a FLUSH_START, we now send a FLUSH_STOP */
 591       GST_DEBUG_OBJECT (wav, &quot;sending flush stop&quot;);
 592 
 593     fevent = gst_event_new_flush_stop (TRUE);
 594     gst_event_set_seqnum (fevent, seqnum);
 595     gst_pad_push_event (wav-&gt;sinkpad, gst_event_ref (fevent));
 596     gst_pad_push_event (wav-&gt;srcpad, fevent);
 597     }
 598 
 599   /* now we did the seek and can activate the new segment values */
 600   memcpy (&amp;wav-&gt;segment, &amp;seeksegment, sizeof (GstSegment));
 601 
 602   /* if we&#39;re doing a segment seek, post a SEGMENT_START message */
 603   if (wav-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
 604     gst_element_post_message (GST_ELEMENT_CAST (wav),
 605         gst_message_new_segment_start (GST_OBJECT_CAST (wav),
 606             wav-&gt;segment.format, wav-&gt;segment.position));
 607   }
 608 
 609   /* now create the newsegment */
 610   GST_DEBUG_OBJECT (wav, &quot;Creating newsegment from %&quot; G_GINT64_FORMAT
 611       &quot; to %&quot; G_GINT64_FORMAT, wav-&gt;segment.position, stop);
 612 
 613   /* store the newsegment event so it can be sent from the streaming thread. */
 614   if (wav-&gt;start_segment)
 615     gst_event_unref (wav-&gt;start_segment);
 616   wav-&gt;start_segment = gst_event_new_segment (&amp;wav-&gt;segment);
 617   gst_event_set_seqnum (wav-&gt;start_segment, seqnum);
 618 
 619   /* mark discont if we are going to stream from another position. */
 620   if (last_stop != wav-&gt;segment.position) {
 621     GST_DEBUG_OBJECT (wav, &quot;mark DISCONT, we did a seek to another position&quot;);
 622     wav-&gt;discont = TRUE;
 623   }
 624 
 625   /* and start the streaming task again */
 626   if (!wav-&gt;streaming) {
 627     gst_pad_start_task (wav-&gt;sinkpad, (GstTaskFunction) gst_wavparse_loop,
 628         wav-&gt;sinkpad, NULL);
 629   }
 630 
 631   GST_PAD_STREAM_UNLOCK (wav-&gt;sinkpad);
 632 
 633   return TRUE;
 634 
 635   /* ERRORS */
 636 negative_rate:
 637   {
 638     GST_DEBUG_OBJECT (wav, &quot;negative playback rates are not supported yet.&quot;);
 639     return FALSE;
 640   }
 641 no_format:
 642   {
 643     GST_DEBUG_OBJECT (wav, &quot;unsupported format given, seek aborted.&quot;);
 644     return FALSE;
 645   }
 646 no_position:
 647   {
 648     GST_DEBUG_OBJECT (wav,
 649         &quot;Could not determine byte position for desired time&quot;);
 650     return FALSE;
 651   }
 652 }
 653 
 654 /*
 655  * gst_wavparse_peek_chunk_info:
 656  * @wav Wavparse object
 657  * @tag holder for tag
 658  * @size holder for tag size
 659  *
 660  * Peek next chunk info (tag and size)
 661  *
 662  * Returns: %TRUE when the chunk info (header) is available
 663  */
 664 static gboolean
 665 gst_wavparse_peek_chunk_info (GstWavParse * wav, guint32 * tag, guint32 * size)
 666 {
 667   const guint8 *data = NULL;
 668 
 669   if (gst_adapter_available (wav-&gt;adapter) &lt; 8)
 670     return FALSE;
 671 
 672   data = gst_adapter_map (wav-&gt;adapter, 8);
 673   *tag = GST_READ_UINT32_LE (data);
 674   *size = GST_READ_UINT32_LE (data + 4);
 675   gst_adapter_unmap (wav-&gt;adapter);
 676 
 677   GST_DEBUG (&quot;Next chunk size is %u bytes, type %&quot; GST_FOURCC_FORMAT, *size,
 678       GST_FOURCC_ARGS (*tag));
 679 
 680   return TRUE;
 681 }
 682 
 683 /*
 684  * gst_wavparse_peek_chunk:
 685  * @wav Wavparse object
 686  * @tag holder for tag
 687  * @size holder for tag size
 688  *
 689  * Peek enough data for one full chunk
 690  *
 691  * Returns: %TRUE when the full chunk is available
 692  */
 693 static gboolean
 694 gst_wavparse_peek_chunk (GstWavParse * wav, guint32 * tag, guint32 * size)
 695 {
 696   guint32 peek_size = 0;
 697   guint available;
 698 
 699   if (!gst_wavparse_peek_chunk_info (wav, tag, size))
 700     return FALSE;
 701 
 702   /* size 0 -&gt; empty data buffer would surprise most callers,
 703    * large size -&gt; do not bother trying to squeeze that into adapter,
 704    * so we throw poor man&#39;s exception, which can be caught if caller really
 705    * wants to handle 0 size chunk */
 706   if (!(*size) || (*size) &gt;= (1 &lt;&lt; 30)) {
 707     GST_INFO (&quot;Invalid/unexpected chunk size %u for tag %&quot; GST_FOURCC_FORMAT,
 708         *size, GST_FOURCC_ARGS (*tag));
 709     /* chain should give up */
 710     wav-&gt;abort_buffering = TRUE;
 711     return FALSE;
 712   }
 713   peek_size = (*size + 1) &amp; ~1;
 714   available = gst_adapter_available (wav-&gt;adapter);
 715 
 716   if (available &gt;= (8 + peek_size)) {
 717     return TRUE;
 718   } else {
 719     GST_LOG (&quot;but only %u bytes available now&quot;, available);
 720     return FALSE;
 721   }
 722 }
 723 
 724 /*
 725  * gst_wavparse_calculate_duration:
 726  * @wav: wavparse object
 727  *
 728  * Calculate duration on demand and store in @wav. Prefer bps, but use fact as a
 729  * fallback.
 730  *
 731  * Returns: %TRUE if duration is available.
 732  */
 733 static gboolean
 734 gst_wavparse_calculate_duration (GstWavParse * wav)
 735 {
 736   if (wav-&gt;duration &gt; 0)
 737     return TRUE;
 738 
 739   if (wav-&gt;bps &gt; 0) {
 740     GST_INFO_OBJECT (wav, &quot;Got datasize %&quot; G_GUINT64_FORMAT, wav-&gt;datasize);
 741     wav-&gt;duration =
 742         gst_util_uint64_scale_ceil (wav-&gt;datasize, GST_SECOND,
 743         (guint64) wav-&gt;bps);
 744     GST_INFO_OBJECT (wav, &quot;Got duration (bps) %&quot; GST_TIME_FORMAT,
 745         GST_TIME_ARGS (wav-&gt;duration));
 746     return TRUE;
 747   } else if (wav-&gt;fact) {
 748     wav-&gt;duration =
 749         gst_util_uint64_scale_ceil (GST_SECOND, wav-&gt;fact, wav-&gt;rate);
 750     GST_INFO_OBJECT (wav, &quot;Got duration (fact) %&quot; GST_TIME_FORMAT,
 751         GST_TIME_ARGS (wav-&gt;duration));
 752     return TRUE;
 753   }
 754   return FALSE;
 755 }
 756 
 757 static gboolean
 758 gst_waveparse_ignore_chunk (GstWavParse * wav, GstBuffer * buf, guint32 tag,
 759     guint32 size)
 760 {
 761   guint flush;
 762 
 763   if (wav-&gt;streaming) {
 764     if (!gst_wavparse_peek_chunk (wav, &amp;tag, &amp;size))
 765       return FALSE;
 766   }
 767   GST_DEBUG_OBJECT (wav, &quot;Ignoring tag %&quot; GST_FOURCC_FORMAT,
 768       GST_FOURCC_ARGS (tag));
 769   flush = 8 + ((size + 1) &amp; ~1);
 770   wav-&gt;offset += flush;
 771   if (wav-&gt;streaming) {
 772     gst_adapter_flush (wav-&gt;adapter, flush);
 773   } else {
 774     gst_buffer_unref (buf);
 775   }
 776 
 777   return TRUE;
 778 }
 779 
 780 /*
 781  * gst_wavparse_cue_chunk:
 782  * @wav GstWavParse object
 783  * @data holder for data
 784  * @size holder for data size
 785  *
 786  * Parse cue chunk from @data to wav-&gt;cues.
 787  *
 788  * Returns: %TRUE when cue chunk is available
 789  */
 790 static gboolean
 791 gst_wavparse_cue_chunk (GstWavParse * wav, const guint8 * data, guint32 size)
 792 {
 793   guint32 i, ncues;
 794   GList *cues = NULL;
 795   GstWavParseCue *cue;
 796 
 797   if (wav-&gt;cues) {
 798     GST_WARNING_OBJECT (wav, &quot;found another cue&#39;s&quot;);
 799     return TRUE;
 800   }
 801 
 802   ncues = GST_READ_UINT32_LE (data);
 803 
 804   if (size &lt; 4 + ncues * 24) {
 805     GST_WARNING_OBJECT (wav, &quot;broken file %d %d&quot;, size, ncues);
 806     return FALSE;
 807   }
 808 
 809   /* parse data */
 810   data += 4;
 811   for (i = 0; i &lt; ncues; i++) {
 812     cue = g_new0 (GstWavParseCue, 1);
 813     cue-&gt;id = GST_READ_UINT32_LE (data);
 814     cue-&gt;position = GST_READ_UINT32_LE (data + 4);
 815     cue-&gt;data_chunk_id = GST_READ_UINT32_LE (data + 8);
 816     cue-&gt;chunk_start = GST_READ_UINT32_LE (data + 12);
 817     cue-&gt;block_start = GST_READ_UINT32_LE (data + 16);
 818     cue-&gt;sample_offset = GST_READ_UINT32_LE (data + 20);
 819     cues = g_list_append (cues, cue);
 820     data += 24;
 821   }
 822 
 823   wav-&gt;cues = cues;
 824 
 825   return TRUE;
 826 }
 827 
 828 /*
 829  * gst_wavparse_labl_chunk:
 830  * @wav GstWavParse object
 831  * @data holder for data
 832  * @size holder for data size
 833  *
 834  * Parse labl from @data to wav-&gt;labls.
 835  *
 836  * Returns: %TRUE when labl chunk is available
 837  */
 838 static gboolean
 839 gst_wavparse_labl_chunk (GstWavParse * wav, const guint8 * data, guint32 size)
 840 {
 841   GstWavParseLabl *labl;
 842 
 843   if (size &lt; 5)
 844     return FALSE;
 845 
 846   labl = g_new0 (GstWavParseLabl, 1);
 847 
 848   /* parse data */
 849   data += 8;
 850   labl-&gt;cue_point_id = GST_READ_UINT32_LE (data);
 851   labl-&gt;text = g_memdup (data + 4, size - 4);
 852 
 853   wav-&gt;labls = g_list_append (wav-&gt;labls, labl);
 854 
 855   return TRUE;
 856 }
 857 
 858 /*
 859  * gst_wavparse_note_chunk:
 860  * @wav GstWavParse object
 861  * @data holder for data
 862  * @size holder for data size
 863  *
 864  * Parse note from @data to wav-&gt;notes.
 865  *
 866  * Returns: %TRUE when note chunk is available
 867  */
 868 static gboolean
 869 gst_wavparse_note_chunk (GstWavParse * wav, const guint8 * data, guint32 size)
 870 {
 871   GstWavParseNote *note;
 872 
 873   if (size &lt; 5)
 874     return FALSE;
 875 
 876   note = g_new0 (GstWavParseNote, 1);
 877 
 878   /* parse data */
 879   data += 8;
 880   note-&gt;cue_point_id = GST_READ_UINT32_LE (data);
 881   note-&gt;text = g_memdup (data + 4, size - 4);
 882 
 883   wav-&gt;notes = g_list_append (wav-&gt;notes, note);
 884 
 885   return TRUE;
 886 }
 887 
 888 /*
 889  * gst_wavparse_smpl_chunk:
 890  * @wav GstWavParse object
 891  * @data holder for data
 892  * @size holder for data size
 893  *
 894  * Parse smpl chunk from @data.
 895  *
 896  * Returns: %TRUE when cue chunk is available
 897  */
 898 static gboolean
 899 gst_wavparse_smpl_chunk (GstWavParse * wav, const guint8 * data, guint32 size)
 900 {
 901   guint32 note_number;
 902 
 903   /*
 904      manufacturer_id = GST_READ_UINT32_LE (data);
 905      product_id = GST_READ_UINT32_LE (data + 4);
 906      sample_period = GST_READ_UINT32_LE (data + 8);
 907    */
 908   note_number = GST_READ_UINT32_LE (data + 12);
 909   /*
 910      pitch_fraction = GST_READ_UINT32_LE (data + 16);
 911      SMPTE_format = GST_READ_UINT32_LE (data + 20);
 912      SMPTE_offset = GST_READ_UINT32_LE (data + 24);
 913      num_sample_loops = GST_READ_UINT32_LE (data + 28);
 914      List of Sample Loops, 24 bytes each
 915    */
 916 
 917   if (!wav-&gt;tags)
 918     wav-&gt;tags = gst_tag_list_new_empty ();
 919   gst_tag_list_add (wav-&gt;tags, GST_TAG_MERGE_REPLACE,
 920       GST_TAG_MIDI_BASE_NOTE, (guint) note_number, NULL);
 921   return TRUE;
 922 }
 923 
 924 /*
 925  * gst_wavparse_adtl_chunk:
 926  * @wav GstWavParse object
 927  * @data holder for data
 928  * @size holder for data size
 929  *
 930  * Parse adtl from @data.
 931  *
 932  * Returns: %TRUE when adtl chunk is available
 933  */
 934 static gboolean
 935 gst_wavparse_adtl_chunk (GstWavParse * wav, const guint8 * data, guint32 size)
 936 {
 937   guint32 ltag, lsize, offset = 0;
 938 
 939   while (size &gt;= 8) {
 940     ltag = GST_READ_UINT32_LE (data + offset);
 941     lsize = GST_READ_UINT32_LE (data + offset + 4);
 942 
 943     if (lsize + 8 &gt; size) {
 944       GST_WARNING_OBJECT (wav, &quot;Invalid adtl size: %u + 8 &gt; %u&quot;, lsize, size);
 945       return FALSE;
 946     }
 947 
 948     switch (ltag) {
 949       case GST_RIFF_TAG_labl:
 950         gst_wavparse_labl_chunk (wav, data + offset, size);
 951         break;
 952       case GST_RIFF_TAG_note:
 953         gst_wavparse_note_chunk (wav, data + offset, size);
 954         break;
 955       default:
 956         GST_WARNING_OBJECT (wav, &quot;Unknowm adtl %&quot; GST_FOURCC_FORMAT,
 957             GST_FOURCC_ARGS (ltag));
 958         GST_MEMDUMP_OBJECT (wav, &quot;Unknowm adtl&quot;, &amp;data[offset], lsize);
 959         break;
 960     }
 961     offset += 8 + GST_ROUND_UP_2 (lsize);
 962     size -= 8 + GST_ROUND_UP_2 (lsize);
 963   }
 964 
 965   return TRUE;
 966 }
 967 
 968 static GstTagList *
 969 gst_wavparse_get_tags_toc_entry (GstToc * toc, gchar * id)
 970 {
 971   GstTagList *tags = NULL;
 972   GstTocEntry *entry = NULL;
 973 
 974   entry = gst_toc_find_entry (toc, id);
 975   if (entry != NULL) {
 976     tags = gst_toc_entry_get_tags (entry);
 977     if (tags == NULL) {
 978       tags = gst_tag_list_new_empty ();
 979       gst_toc_entry_set_tags (entry, tags);
 980     }
 981   }
 982 
 983   return tags;
 984 }
 985 
 986 /*
 987  * gst_wavparse_create_toc:
 988  * @wav GstWavParse object
 989  *
 990  * Create TOC from wav-&gt;cues and wav-&gt;labls.
 991  */
 992 static gboolean
 993 gst_wavparse_create_toc (GstWavParse * wav)
 994 {
 995   gint64 start, stop;
 996   gchar *id;
 997   GList *list;
 998   GstWavParseCue *cue;
 999   GstWavParseLabl *labl;
1000   GstWavParseNote *note;
1001   GstTagList *tags;
1002   GstToc *toc;
1003   GstTocEntry *entry = NULL, *cur_subentry = NULL, *prev_subentry = NULL;
1004 
1005   GST_OBJECT_LOCK (wav);
1006   if (wav-&gt;toc) {
1007     GST_OBJECT_UNLOCK (wav);
1008     GST_WARNING_OBJECT (wav, &quot;found another TOC&quot;);
1009     return FALSE;
1010   }
1011 
1012   if (!wav-&gt;cues) {
1013     GST_OBJECT_UNLOCK (wav);
1014     return TRUE;
1015   }
1016 
1017   /* FIXME: send CURRENT scope toc too */
1018   toc = gst_toc_new (GST_TOC_SCOPE_GLOBAL);
1019 
1020   /* add cue edition */
1021   entry = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_EDITION, &quot;cue&quot;);
1022   gst_toc_entry_set_start_stop_times (entry, 0, wav-&gt;duration);
1023   gst_toc_append_entry (toc, entry);
1024 
1025   /* add tracks in cue edition */
1026   list = wav-&gt;cues;
1027   while (list) {
1028     cue = list-&gt;data;
1029     prev_subentry = cur_subentry;
1030     /* previous track stop time = current track start time */
1031     if (prev_subentry != NULL) {
1032       gst_toc_entry_get_start_stop_times (prev_subentry, &amp;start, NULL);
1033       stop = gst_util_uint64_scale_round (cue-&gt;position, GST_SECOND, wav-&gt;rate);
1034       gst_toc_entry_set_start_stop_times (prev_subentry, start, stop);
1035     }
1036     id = g_strdup_printf (&quot;%08x&quot;, cue-&gt;id);
1037     cur_subentry = gst_toc_entry_new (GST_TOC_ENTRY_TYPE_TRACK, id);
1038     g_free (id);
1039     start = gst_util_uint64_scale_round (cue-&gt;position, GST_SECOND, wav-&gt;rate);
1040     stop = wav-&gt;duration;
1041     gst_toc_entry_set_start_stop_times (cur_subentry, start, stop);
1042     gst_toc_entry_append_sub_entry (entry, cur_subentry);
1043     list = g_list_next (list);
1044   }
1045 
1046   /* add tags in tracks */
1047   list = wav-&gt;labls;
1048   while (list) {
1049     labl = list-&gt;data;
1050     id = g_strdup_printf (&quot;%08x&quot;, labl-&gt;cue_point_id);
1051     tags = gst_wavparse_get_tags_toc_entry (toc, id);
1052     g_free (id);
1053     if (tags != NULL) {
1054       gst_tag_list_add (tags, GST_TAG_MERGE_APPEND, GST_TAG_TITLE, labl-&gt;text,
1055           NULL);
1056     }
1057     list = g_list_next (list);
1058   }
1059   list = wav-&gt;notes;
1060   while (list) {
1061     note = list-&gt;data;
1062     id = g_strdup_printf (&quot;%08x&quot;, note-&gt;cue_point_id);
1063     tags = gst_wavparse_get_tags_toc_entry (toc, id);
1064     g_free (id);
1065     if (tags != NULL) {
1066       gst_tag_list_add (tags, GST_TAG_MERGE_PREPEND, GST_TAG_COMMENT,
1067           note-&gt;text, NULL);
1068     }
1069     list = g_list_next (list);
1070   }
1071 
1072   /* send data as TOC */
1073   wav-&gt;toc = toc;
1074 
1075   /* send TOC event */
1076   if (wav-&gt;toc) {
1077     GST_OBJECT_UNLOCK (wav);
1078     gst_pad_push_event (wav-&gt;srcpad, gst_event_new_toc (wav-&gt;toc, FALSE));
1079   }
1080 
1081   return TRUE;
1082 }
1083 
1084 #define MAX_BUFFER_SIZE 4096
1085 
1086 static gboolean
1087 parse_ds64 (GstWavParse * wav, GstBuffer * buf)
1088 {
1089   GstMapInfo map;
1090   guint32 dataSizeLow, dataSizeHigh;
1091   guint32 sampleCountLow, sampleCountHigh;
1092 
1093   gst_buffer_map (buf, &amp;map, GST_MAP_READ);
1094   dataSizeLow = GST_READ_UINT32_LE (map.data + 2 * 4);
1095   dataSizeHigh = GST_READ_UINT32_LE (map.data + 3 * 4);
1096   sampleCountLow = GST_READ_UINT32_LE (map.data + 4 * 4);
1097   sampleCountHigh = GST_READ_UINT32_LE (map.data + 5 * 4);
1098   gst_buffer_unmap (buf, &amp;map);
1099   if (dataSizeHigh != 0xFFFFFFFF &amp;&amp; dataSizeLow != 0xFFFFFFFF) {
1100     wav-&gt;datasize = ((guint64) dataSizeHigh &lt;&lt; 32) | dataSizeLow;
1101   }
1102   if (sampleCountHigh != 0xFFFFFFFF &amp;&amp; sampleCountLow != 0xFFFFFFFF) {
1103     wav-&gt;fact = ((guint64) sampleCountHigh &lt;&lt; 32) | sampleCountLow;
1104   }
1105 
1106   GST_DEBUG_OBJECT (wav, &quot;Got &#39;ds64&#39; TAG, datasize : %&quot; G_GINT64_FORMAT
1107       &quot; fact: %&quot; G_GINT64_FORMAT, wav-&gt;datasize, wav-&gt;fact);
1108   return TRUE;
1109 }
1110 
1111 static GstFlowReturn
1112 gst_wavparse_stream_headers (GstWavParse * wav)
1113 {
1114   GstFlowReturn res = GST_FLOW_OK;
1115   GstBuffer *buf = NULL;
1116   gst_riff_strf_auds *header = NULL;
1117   guint32 tag, size;
1118   gboolean gotdata = FALSE;
1119   GstCaps *caps = NULL;
1120   gchar *codec_name = NULL;
1121   gint64 upstream_size = 0;
1122   GstStructure *s;
1123 
1124   /* search for &quot;_fmt&quot; chunk, which must be before &quot;data&quot; */
1125   while (!wav-&gt;got_fmt) {
1126     GstBuffer *extra;
1127 
1128     if (wav-&gt;streaming) {
1129       if (!gst_wavparse_peek_chunk (wav, &amp;tag, &amp;size))
1130         return res;
1131 
1132       gst_adapter_flush (wav-&gt;adapter, 8);
1133       wav-&gt;offset += 8;
1134 
1135       if (size) {
1136         buf = gst_adapter_take_buffer (wav-&gt;adapter, size);
1137         if (size &amp; 1)
1138           gst_adapter_flush (wav-&gt;adapter, 1);
1139         wav-&gt;offset += GST_ROUND_UP_2 (size);
1140       } else {
1141         buf = gst_buffer_new ();
1142       }
1143     } else {
1144       if ((res = gst_riff_read_chunk (GST_ELEMENT_CAST (wav), wav-&gt;sinkpad,
1145                   &amp;wav-&gt;offset, &amp;tag, &amp;buf)) != GST_FLOW_OK)
1146         return res;
1147     }
1148 
1149     if (tag == GST_RS64_TAG_DS64) {
1150       if (!parse_ds64 (wav, buf))
1151         goto fail;
1152       else
1153         continue;
1154     }
1155 
1156     if (tag != GST_RIFF_TAG_fmt) {
1157       GST_DEBUG_OBJECT (wav, &quot;skipping %&quot; GST_FOURCC_FORMAT &quot; chunk&quot;,
1158           GST_FOURCC_ARGS (tag));
1159       gst_buffer_unref (buf);
1160       buf = NULL;
1161       continue;
1162     }
1163 
1164     if (!(gst_riff_parse_strf_auds (GST_ELEMENT_CAST (wav), buf, &amp;header,
1165                 &amp;extra)))
1166       goto parse_header_error;
1167 
1168     buf = NULL;                 /* parse_strf_auds() took ownership of buffer */
1169 
1170     /* do sanity checks of header fields */
1171     if (header-&gt;channels == 0)
1172       goto no_channels;
1173     if (header-&gt;rate == 0)
1174       goto no_rate;
1175 
1176     GST_DEBUG_OBJECT (wav, &quot;creating the caps&quot;);
1177 
1178     /* Note: gst_riff_create_audio_caps might need to fix values in
1179      * the header header depending on the format, so call it first */
1180     /* FIXME: Need to handle the channel reorder map */
1181     caps = gst_riff_create_audio_caps (header-&gt;format, NULL, header, extra,
1182         NULL, &amp;codec_name, NULL);
1183 
1184     if (extra)
1185       gst_buffer_unref (extra);
1186 
1187     if (!caps)
1188       goto unknown_format;
1189 
1190     /* If we got raw audio from upstream, we remove the codec_data field,
1191      * which may have been added if the wav header included an extended
1192      * chunk. We want to keep it for non raw audio.
1193      */
1194     s = gst_caps_get_structure (caps, 0);
1195     if (s &amp;&amp; gst_structure_has_name (s, &quot;audio/x-raw&quot;)) {
1196       gst_structure_remove_field (s, &quot;codec_data&quot;);
1197     }
1198 
1199     /* do more sanity checks of header fields
1200      * (these can be sanitized by gst_riff_create_audio_caps()
1201      */
1202     wav-&gt;format = header-&gt;format;
1203     wav-&gt;rate = header-&gt;rate;
1204     wav-&gt;channels = header-&gt;channels;
1205     wav-&gt;blockalign = header-&gt;blockalign;
1206     wav-&gt;depth = header-&gt;bits_per_sample;
1207     wav-&gt;av_bps = header-&gt;av_bps;
1208     wav-&gt;vbr = FALSE;
1209 
1210     g_free (header);
1211     header = NULL;
1212 
1213     /* do format specific handling */
1214     switch (wav-&gt;format) {
1215       case GST_RIFF_WAVE_FORMAT_MPEGL12:
1216       case GST_RIFF_WAVE_FORMAT_MPEGL3:
1217       {
1218         /* Note: workaround for mp2/mp3 embedded in wav, that relies on the
1219          * bitrate inside the mpeg stream */
1220         GST_INFO (&quot;resetting bps from %u to 0 for mp2/3&quot;, wav-&gt;av_bps);
1221         wav-&gt;bps = 0;
1222         break;
1223       }
1224       case GST_RIFF_WAVE_FORMAT_PCM:
1225         if (wav-&gt;blockalign &gt; wav-&gt;channels * ((wav-&gt;depth + 7) / 8))
1226           goto invalid_blockalign;
1227         /* fall through */
1228       default:
1229         if (wav-&gt;av_bps &gt; wav-&gt;blockalign * wav-&gt;rate)
1230           goto invalid_bps;
1231         /* use the configured bps */
1232         wav-&gt;bps = wav-&gt;av_bps;
1233         break;
1234     }
1235 
1236     wav-&gt;width = (wav-&gt;blockalign * 8) / wav-&gt;channels;
1237     wav-&gt;bytes_per_sample = wav-&gt;channels * wav-&gt;width / 8;
1238 
1239     if (wav-&gt;bytes_per_sample &lt;= 0)
1240       goto no_bytes_per_sample;
1241 
1242     GST_DEBUG_OBJECT (wav, &quot;blockalign = %u&quot;, (guint) wav-&gt;blockalign);
1243     GST_DEBUG_OBJECT (wav, &quot;width      = %u&quot;, (guint) wav-&gt;width);
1244     GST_DEBUG_OBJECT (wav, &quot;depth      = %u&quot;, (guint) wav-&gt;depth);
1245     GST_DEBUG_OBJECT (wav, &quot;av_bps     = %u&quot;, (guint) wav-&gt;av_bps);
1246     GST_DEBUG_OBJECT (wav, &quot;frequency  = %u&quot;, (guint) wav-&gt;rate);
1247     GST_DEBUG_OBJECT (wav, &quot;channels   = %u&quot;, (guint) wav-&gt;channels);
1248     GST_DEBUG_OBJECT (wav, &quot;bytes_per_sample = %u&quot;, wav-&gt;bytes_per_sample);
1249 
1250     /* bps can be 0 when we don&#39;t have a valid bitrate (mostly for compressed
1251      * formats). This will make the element output a BYTE format segment and
1252      * will not timestamp the outgoing buffers.
1253      */
1254     GST_DEBUG_OBJECT (wav, &quot;bps        = %u&quot;, (guint) wav-&gt;bps);
1255 
1256     GST_DEBUG_OBJECT (wav, &quot;caps = %&quot; GST_PTR_FORMAT, caps);
1257 
1258     /* create pad later so we can sniff the first few bytes
1259      * of the real data and correct our caps if necessary */
1260     gst_caps_replace (&amp;wav-&gt;caps, caps);
1261     gst_caps_replace (&amp;caps, NULL);
1262 
1263     wav-&gt;got_fmt = TRUE;
1264 
1265     if (wav-&gt;tags == NULL)
1266       wav-&gt;tags = gst_tag_list_new_empty ();
1267 
1268     {
1269       GstCaps *templ_caps = gst_pad_get_pad_template_caps (wav-&gt;sinkpad);
1270       gst_pb_utils_add_codec_description_to_tag_list (wav-&gt;tags,
1271           GST_TAG_CONTAINER_FORMAT, templ_caps);
1272       gst_caps_unref (templ_caps);
1273     }
1274 
1275     /* If bps is nonzero, then we do have a valid bitrate that can be
1276      * announced in a tag list. */
1277     if (wav-&gt;bps) {
1278       guint bitrate = wav-&gt;bps * 8;
1279       gst_tag_list_add (wav-&gt;tags, GST_TAG_MERGE_REPLACE,
1280           GST_TAG_BITRATE, bitrate, NULL);
1281     }
1282 
1283     if (codec_name) {
1284       gst_tag_list_add (wav-&gt;tags, GST_TAG_MERGE_REPLACE,
1285           GST_TAG_AUDIO_CODEC, codec_name, NULL);
1286 
1287       g_free (codec_name);
1288       codec_name = NULL;
1289     }
1290 
1291   }
1292 
1293   gst_pad_peer_query_duration (wav-&gt;sinkpad, GST_FORMAT_BYTES, &amp;upstream_size);
1294   GST_DEBUG_OBJECT (wav, &quot;upstream size %&quot; G_GUINT64_FORMAT, upstream_size);
1295 
1296   /* loop headers until we get data */
1297   while (!gotdata) {
1298     if (wav-&gt;streaming) {
1299       if (!gst_wavparse_peek_chunk_info (wav, &amp;tag, &amp;size))
1300         goto exit;
1301     } else {
1302       GstMapInfo map;
1303 
1304       buf = NULL;
1305       if ((res =
1306               gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset, 8,
1307                   &amp;buf)) != GST_FLOW_OK)
1308 #ifdef GSTREAMER_LITE
1309         if (res == GST_FLOW_FLUSHING)
1310           goto exit;
1311         else
1312 #endif // GSTREAMER_LITE
1313         goto header_read_error;
1314       gst_buffer_map (buf, &amp;map, GST_MAP_READ);
1315       tag = GST_READ_UINT32_LE (map.data);
1316       size = GST_READ_UINT32_LE (map.data + 4);
1317       gst_buffer_unmap (buf, &amp;map);
1318     }
1319 
1320     GST_INFO_OBJECT (wav,
1321         &quot;Got TAG: %&quot; GST_FOURCC_FORMAT &quot;, offset %&quot; G_GUINT64_FORMAT &quot;, size %&quot;
1322         G_GUINT32_FORMAT, GST_FOURCC_ARGS (tag), wav-&gt;offset, size);
1323 
1324     /* Maximum valid size is INT_MAX */
1325     if (size &amp; 0x80000000) {
1326       GST_WARNING_OBJECT (wav, &quot;Invalid size, clipping to 0x7fffffff&quot;);
1327       size = 0x7fffffff;
1328     }
1329 
1330     /* Clip to upstream size if known */
1331     if (upstream_size &gt; 0 &amp;&amp; size + wav-&gt;offset &gt; upstream_size) {
1332       GST_WARNING_OBJECT (wav, &quot;Clipping chunk size to file size&quot;);
1333       g_assert (upstream_size &gt;= wav-&gt;offset);
1334       size = upstream_size - wav-&gt;offset;
1335     }
1336 
1337     /* wav is a st00pid format, we don&#39;t know for sure where data starts.
1338      * So we have to go bit by bit until we find the &#39;data&#39; header
1339      */
1340     switch (tag) {
1341       case GST_RIFF_TAG_data:{
1342         guint64 size64;
1343 
1344         GST_DEBUG_OBJECT (wav, &quot;Got &#39;data&#39; TAG, size : %u&quot;, size);
1345         size64 = size;
1346         if (wav-&gt;ignore_length) {
1347           GST_DEBUG_OBJECT (wav, &quot;Ignoring length&quot;);
1348           size64 = 0;
1349         }
1350         if (wav-&gt;streaming) {
1351           gst_adapter_flush (wav-&gt;adapter, 8);
1352           gotdata = TRUE;
1353         } else {
1354           gst_buffer_unref (buf);
1355         }
1356         wav-&gt;offset += 8;
1357         wav-&gt;datastart = wav-&gt;offset;
1358         /* use size from ds64 chunk if available */
1359         if (size64 == -1 &amp;&amp; wav-&gt;datasize &gt; 0) {
1360           GST_DEBUG_OBJECT (wav, &quot;Using ds64 datasize&quot;);
1361           size64 = wav-&gt;datasize;
1362         }
1363         wav-&gt;chunk_size = size64;
1364 
1365         /* If size is zero, then the data chunk probably actually extends to
1366            the end of the file */
1367         if (size64 == 0 &amp;&amp; upstream_size) {
1368           size64 = upstream_size - wav-&gt;datastart;
1369         }
1370         /* Or the file might be truncated */
1371         else if (upstream_size) {
1372           size64 = MIN (size64, (upstream_size - wav-&gt;datastart));
1373         }
1374         wav-&gt;datasize = size64;
1375         wav-&gt;dataleft = size64;
1376         wav-&gt;end_offset = size64 + wav-&gt;datastart;
1377         if (!wav-&gt;streaming) {
1378           /* We will continue parsing tags &#39;till end */
1379           wav-&gt;offset += size64;
1380         }
1381         GST_DEBUG_OBJECT (wav, &quot;datasize = %&quot; G_GUINT64_FORMAT, size64);
1382         break;
1383       }
1384       case GST_RIFF_TAG_fact:{
1385         if (wav-&gt;fact == 0 &amp;&amp;
1386             wav-&gt;format != GST_RIFF_WAVE_FORMAT_MPEGL12 &amp;&amp;
1387             wav-&gt;format != GST_RIFF_WAVE_FORMAT_MPEGL3) {
1388           const guint data_size = 4;
1389 
1390           GST_INFO_OBJECT (wav, &quot;Have fact chunk&quot;);
1391           if (size &lt; data_size) {
1392             if (!gst_waveparse_ignore_chunk (wav, buf, tag, size)) {
1393               /* need more data */
1394               goto exit;
1395             }
1396             GST_DEBUG_OBJECT (wav, &quot;need %u, available %u; ignoring chunk&quot;,
1397                 data_size, size);
1398             break;
1399           }
1400           /* number of samples (for compressed formats) */
1401           if (wav-&gt;streaming) {
1402             const guint8 *data = NULL;
1403 
1404             if (!gst_wavparse_peek_chunk (wav, &amp;tag, &amp;size)) {
1405               goto exit;
1406             }
1407             gst_adapter_flush (wav-&gt;adapter, 8);
1408             data = gst_adapter_map (wav-&gt;adapter, data_size);
1409 #ifdef GSTREAMER_LITE
1410             if (data == NULL) {
1411                 goto header_read_error;
1412             }
1413 #endif // GSTREAMER_LITE
1414             wav-&gt;fact = GST_READ_UINT32_LE (data);
1415             gst_adapter_unmap (wav-&gt;adapter);
1416             gst_adapter_flush (wav-&gt;adapter, GST_ROUND_UP_2 (size));
1417           } else {
1418             gst_buffer_unref (buf);
1419             buf = NULL;
1420             if ((res =
1421                     gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset + 8,
1422                         data_size, &amp;buf)) != GST_FLOW_OK)
1423 #ifdef GSTREAMER_LITE
1424             if (res == GST_FLOW_FLUSHING)
1425               goto exit;
1426             else
1427 #endif // GSTREAMER_LITE
1428               goto header_read_error;
1429             gst_buffer_extract (buf, 0, &amp;wav-&gt;fact, 4);
1430             wav-&gt;fact = GUINT32_FROM_LE (wav-&gt;fact);
1431             gst_buffer_unref (buf);
1432           }
1433           GST_DEBUG_OBJECT (wav, &quot;have fact %&quot; G_GUINT64_FORMAT, wav-&gt;fact);
1434           wav-&gt;offset += 8 + GST_ROUND_UP_2 (size);
1435           break;
1436         } else {
1437           if (!gst_waveparse_ignore_chunk (wav, buf, tag, size)) {
1438             /* need more data */
1439             goto exit;
1440           }
1441         }
1442         break;
1443       }
1444       case GST_RIFF_TAG_acid:{
1445         const gst_riff_acid *acid = NULL;
1446         const guint data_size = sizeof (gst_riff_acid);
1447         gfloat tempo;
1448 
1449         GST_INFO_OBJECT (wav, &quot;Have acid chunk&quot;);
1450         if (size &lt; data_size) {
1451           if (!gst_waveparse_ignore_chunk (wav, buf, tag, size)) {
1452             /* need more data */
1453             goto exit;
1454           }
1455           GST_DEBUG_OBJECT (wav, &quot;need %u, available %u; ignoring chunk&quot;,
1456               data_size, size);
1457           break;
1458         }
1459         if (wav-&gt;streaming) {
1460           if (!gst_wavparse_peek_chunk (wav, &amp;tag, &amp;size)) {
1461             goto exit;
1462           }
1463           gst_adapter_flush (wav-&gt;adapter, 8);
1464           acid = (const gst_riff_acid *) gst_adapter_map (wav-&gt;adapter,
1465               data_size);
1466           tempo = acid-&gt;tempo;
1467           gst_adapter_unmap (wav-&gt;adapter);
1468         } else {
1469           GstMapInfo map;
1470           gst_buffer_unref (buf);
1471           buf = NULL;
1472           if ((res =
1473                   gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset + 8,
1474                       size, &amp;buf)) != GST_FLOW_OK)
1475 #ifdef GSTREAMER_LITE
1476           if (res == GST_FLOW_FLUSHING)
1477             goto exit;
1478           else
1479 #endif // GSTREAMER_LITE
1480             goto header_read_error;
1481           gst_buffer_map (buf, &amp;map, GST_MAP_READ);
1482           acid = (const gst_riff_acid *) map.data;
1483           tempo = acid-&gt;tempo;
1484           gst_buffer_unmap (buf, &amp;map);
1485         }
1486         /* send data as tags */
1487         if (!wav-&gt;tags)
1488           wav-&gt;tags = gst_tag_list_new_empty ();
1489         gst_tag_list_add (wav-&gt;tags, GST_TAG_MERGE_REPLACE,
1490             GST_TAG_BEATS_PER_MINUTE, tempo, NULL);
1491 
1492         size = GST_ROUND_UP_2 (size);
1493         if (wav-&gt;streaming) {
1494           gst_adapter_flush (wav-&gt;adapter, size);
1495         } else {
1496           gst_buffer_unref (buf);
1497         }
1498         wav-&gt;offset += 8 + size;
1499         break;
1500       }
1501         /* FIXME: all list tags after data are ignored in streaming mode */
1502       case GST_RIFF_TAG_LIST:{
1503         guint32 ltag;
1504 
1505         if (wav-&gt;streaming) {
1506           const guint8 *data = NULL;
1507 
1508           if (gst_adapter_available (wav-&gt;adapter) &lt; 12) {
1509             goto exit;
1510           }
1511           data = gst_adapter_map (wav-&gt;adapter, 12);
1512           ltag = GST_READ_UINT32_LE (data + 8);
1513           gst_adapter_unmap (wav-&gt;adapter);
1514         } else {
1515           gst_buffer_unref (buf);
1516           buf = NULL;
1517           if ((res =
1518                   gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset, 12,
1519                       &amp;buf)) != GST_FLOW_OK)
1520 #ifdef GSTREAMER_LITE
1521           if (res == GST_FLOW_FLUSHING)
1522             goto exit;
1523           else
1524 #endif // GSTREAMER_LITE
1525             goto header_read_error;
1526           gst_buffer_extract (buf, 8, &amp;ltag, 4);
1527           ltag = GUINT32_FROM_LE (ltag);
1528         }
1529         switch (ltag) {
1530           case GST_RIFF_LIST_INFO:{
1531             const gint data_size = size - 4;
1532             GstTagList *new;
1533 
1534             GST_INFO_OBJECT (wav, &quot;Have LIST chunk INFO size %u&quot;, data_size);
1535             if (wav-&gt;streaming) {
1536               if (!gst_wavparse_peek_chunk (wav, &amp;tag, &amp;size)) {
1537                 goto exit;
1538               }
1539               gst_adapter_flush (wav-&gt;adapter, 12);
1540               wav-&gt;offset += 12;
1541               if (data_size &gt; 0) {
1542                 buf = gst_adapter_take_buffer (wav-&gt;adapter, data_size);
1543                 if (data_size &amp; 1)
1544                   gst_adapter_flush (wav-&gt;adapter, 1);
1545               }
1546             } else {
1547               wav-&gt;offset += 12;
1548               gst_buffer_unref (buf);
1549               buf = NULL;
1550               if (data_size &gt; 0) {
1551                 if ((res =
1552                         gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset,
1553                             data_size, &amp;buf)) != GST_FLOW_OK)
1554 #ifdef GSTREAMER_LITE
1555                 if (res == GST_FLOW_FLUSHING)
1556                   goto exit;
1557                 else
1558 #endif // GSTREAMER_LITE
1559                   goto header_read_error;
1560               }
1561             }
1562             if (data_size &gt; 0) {
1563               /* parse tags */
1564               gst_riff_parse_info (GST_ELEMENT (wav), buf, &amp;new);
1565               if (new) {
1566                 GstTagList *old = wav-&gt;tags;
1567                 wav-&gt;tags =
1568                     gst_tag_list_merge (old, new, GST_TAG_MERGE_REPLACE);
1569                 if (old)
1570                   gst_tag_list_unref (old);
1571                 gst_tag_list_unref (new);
1572               }
1573               gst_buffer_unref (buf);
1574               wav-&gt;offset += GST_ROUND_UP_2 (data_size);
1575             }
1576             break;
1577           }
1578           case GST_RIFF_LIST_adtl:{
1579             const gint data_size = size - 4;
1580 
1581             GST_INFO_OBJECT (wav, &quot;Have &#39;adtl&#39; LIST, size %u&quot;, data_size);
1582             if (wav-&gt;streaming) {
1583               const guint8 *data = NULL;
1584 
1585               gst_adapter_flush (wav-&gt;adapter, 12);
1586               wav-&gt;offset += 12;
1587               data = gst_adapter_map (wav-&gt;adapter, data_size);
1588               gst_wavparse_adtl_chunk (wav, data, data_size);
1589               gst_adapter_unmap (wav-&gt;adapter);
1590             } else {
1591               GstMapInfo map;
1592 
1593               gst_buffer_unref (buf);
1594               buf = NULL;
1595               wav-&gt;offset += 12;
1596               if ((res =
1597                       gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset,
1598                           data_size, &amp;buf)) != GST_FLOW_OK)
1599                 goto header_read_error;
1600               gst_buffer_map (buf, &amp;map, GST_MAP_READ);
1601               gst_wavparse_adtl_chunk (wav, (const guint8 *) map.data,
1602                   data_size);
1603               gst_buffer_unmap (buf, &amp;map);
1604             }
1605             wav-&gt;offset += GST_ROUND_UP_2 (data_size);
1606             break;
1607           }
1608           default:
1609             GST_WARNING_OBJECT (wav, &quot;Ignoring LIST chunk %&quot; GST_FOURCC_FORMAT,
1610                 GST_FOURCC_ARGS (ltag));
1611             if (!gst_waveparse_ignore_chunk (wav, buf, tag, size))
1612               /* need more data */
1613               goto exit;
1614             break;
1615         }
1616         break;
1617       }
1618       case GST_RIFF_TAG_cue:{
1619         const guint data_size = size;
1620 
1621         GST_DEBUG_OBJECT (wav, &quot;Have &#39;cue&#39; TAG, size : %u&quot;, data_size);
1622         if (wav-&gt;streaming) {
1623           const guint8 *data = NULL;
1624 
1625           if (!gst_wavparse_peek_chunk (wav, &amp;tag, &amp;size)) {
1626             goto exit;
1627           }
1628           gst_adapter_flush (wav-&gt;adapter, 8);
1629           wav-&gt;offset += 8;
1630           data = gst_adapter_map (wav-&gt;adapter, data_size);
1631           if (!gst_wavparse_cue_chunk (wav, data, data_size)) {
1632             goto header_read_error;
1633           }
1634           gst_adapter_unmap (wav-&gt;adapter);
1635         } else {
1636           GstMapInfo map;
1637 
1638           wav-&gt;offset += 8;
1639           gst_buffer_unref (buf);
1640           buf = NULL;
1641           if ((res =
1642                   gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset,
1643                       data_size, &amp;buf)) != GST_FLOW_OK)
1644             goto header_read_error;
1645           gst_buffer_map (buf, &amp;map, GST_MAP_READ);
1646           if (!gst_wavparse_cue_chunk (wav, (const guint8 *) map.data,
1647                   data_size)) {
1648             goto header_read_error;
1649           }
1650           gst_buffer_unmap (buf, &amp;map);
1651         }
1652         size = GST_ROUND_UP_2 (size);
1653         if (wav-&gt;streaming) {
1654           gst_adapter_flush (wav-&gt;adapter, size);
1655         } else {
1656           gst_buffer_unref (buf);
1657         }
1658         size = GST_ROUND_UP_2 (size);
1659         wav-&gt;offset += size;
1660         break;
1661       }
1662       case GST_RIFF_TAG_smpl:{
1663         const gint data_size = size;
1664 
1665         GST_DEBUG_OBJECT (wav, &quot;Have &#39;smpl&#39; TAG, size : %u&quot;, data_size);
1666         if (wav-&gt;streaming) {
1667           const guint8 *data = NULL;
1668 
1669           if (!gst_wavparse_peek_chunk (wav, &amp;tag, &amp;size)) {
1670             goto exit;
1671           }
1672           gst_adapter_flush (wav-&gt;adapter, 8);
1673           wav-&gt;offset += 8;
1674           data = gst_adapter_map (wav-&gt;adapter, data_size);
1675           if (!gst_wavparse_smpl_chunk (wav, data, data_size)) {
1676             goto header_read_error;
1677           }
1678           gst_adapter_unmap (wav-&gt;adapter);
1679         } else {
1680           GstMapInfo map;
1681 
1682           wav-&gt;offset += 8;
1683           gst_buffer_unref (buf);
1684           buf = NULL;
1685           if ((res =
1686                   gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset,
1687                       data_size, &amp;buf)) != GST_FLOW_OK)
1688             goto header_read_error;
1689           gst_buffer_map (buf, &amp;map, GST_MAP_READ);
1690           if (!gst_wavparse_smpl_chunk (wav, (const guint8 *) map.data,
1691                   data_size)) {
1692             goto header_read_error;
1693           }
1694           gst_buffer_unmap (buf, &amp;map);
1695         }
1696         size = GST_ROUND_UP_2 (size);
1697         if (wav-&gt;streaming) {
1698           gst_adapter_flush (wav-&gt;adapter, size);
1699         } else {
1700           gst_buffer_unref (buf);
1701         }
1702         size = GST_ROUND_UP_2 (size);
1703         wav-&gt;offset += size;
1704         break;
1705       }
1706       default:
1707         GST_WARNING_OBJECT (wav, &quot;Ignoring chunk %&quot; GST_FOURCC_FORMAT,
1708             GST_FOURCC_ARGS (tag));
1709         if (!gst_waveparse_ignore_chunk (wav, buf, tag, size))
1710           /* need more data */
1711           goto exit;
1712         break;
1713     }
1714 
1715     if (upstream_size &amp;&amp; (wav-&gt;offset &gt;= upstream_size)) {
1716       /* Now we are gone through the whole file */
1717       gotdata = TRUE;
1718     }
1719   }
1720 
1721   GST_DEBUG_OBJECT (wav, &quot;Finished parsing headers&quot;);
1722 
1723   if (wav-&gt;bps &lt;= 0 &amp;&amp; wav-&gt;fact) {
1724 #if 0
1725     /* not a good idea, as for embedded mp2/mp3 we set bps to 0 earlier */
1726     wav-&gt;bps =
1727         (guint32) gst_util_uint64_scale ((guint64) wav-&gt;rate, wav-&gt;datasize,
1728         (guint64) wav-&gt;fact);
1729     GST_INFO_OBJECT (wav, &quot;calculated bps : %u, enabling VBR&quot;, wav-&gt;bps);
1730 #endif
1731     wav-&gt;vbr = TRUE;
1732   }
1733 
1734   if (gst_wavparse_calculate_duration (wav)) {
1735     gst_segment_init (&amp;wav-&gt;segment, GST_FORMAT_TIME);
1736     if (!wav-&gt;ignore_length)
1737       wav-&gt;segment.duration = wav-&gt;duration;
1738     if (!wav-&gt;toc)
1739       gst_wavparse_create_toc (wav);
1740   } else {
1741     /* no bitrate, let downstream peer do the math, we&#39;ll feed it bytes. */
1742     gst_segment_init (&amp;wav-&gt;segment, GST_FORMAT_BYTES);
1743     if (!wav-&gt;ignore_length)
1744       wav-&gt;segment.duration = wav-&gt;datasize;
1745   }
1746 
1747   /* now we have all the info to perform a pending seek if any, if no
1748    * event, this will still do the right thing and it will also send
1749    * the right newsegment event downstream. */
1750   gst_wavparse_perform_seek (wav, wav-&gt;seek_event);
1751   /* remove pending event */
1752   gst_event_replace (&amp;wav-&gt;seek_event, NULL);
1753 
1754   /* we just started, we are discont */
1755   wav-&gt;discont = TRUE;
1756 
1757   wav-&gt;state = GST_WAVPARSE_DATA;
1758 
1759   /* determine reasonable max buffer size,
1760    * that is, buffers not too small either size or time wise
1761    * so we do not end up with too many of them */
1762   /* var abuse */
1763   if (gst_wavparse_time_to_bytepos (wav, 40 * GST_MSECOND, &amp;upstream_size))
1764   wav-&gt;max_buf_size = upstream_size;
1765   else
1766     wav-&gt;max_buf_size = 0;
1767   wav-&gt;max_buf_size = MAX (wav-&gt;max_buf_size, MAX_BUFFER_SIZE);
1768   if (wav-&gt;blockalign &gt; 0)
1769     wav-&gt;max_buf_size -= (wav-&gt;max_buf_size % wav-&gt;blockalign);
1770 
1771   GST_DEBUG_OBJECT (wav, &quot;max buffer size %u&quot;, wav-&gt;max_buf_size);
1772 
1773   return GST_FLOW_OK;
1774 
1775   /* ERROR */
1776 exit:
1777   {
1778       g_free (codec_name);
1779       g_free (header);
1780     if (caps)
1781       gst_caps_unref (caps);
1782     return res;
1783   }
1784 fail:
1785   {
1786     res = GST_FLOW_ERROR;
1787     goto exit;
1788   }
1789 parse_header_error:
1790   {
1791     GST_ELEMENT_ERROR (wav, STREAM, DEMUX, (NULL),
1792         (&quot;Couldn&#39;t parse audio header&quot;));
1793     goto fail;
1794   }
1795 no_channels:
1796   {
1797     GST_ELEMENT_ERROR (wav, STREAM, FAILED, (NULL),
1798         (&quot;Stream claims to contain no channels - invalid data&quot;));
1799     goto fail;
1800   }
1801 no_rate:
1802   {
1803     GST_ELEMENT_ERROR (wav, STREAM, FAILED, (NULL),
1804         (&quot;Stream with sample_rate == 0 - invalid data&quot;));
1805     goto fail;
1806   }
1807 invalid_blockalign:
1808   {
1809     GST_ELEMENT_ERROR (wav, STREAM, FAILED, (NULL),
1810         (&quot;Stream claims blockalign = %u, which is more than %u - invalid data&quot;,
1811             wav-&gt;blockalign, wav-&gt;channels * ((wav-&gt;depth + 7) / 8)));
1812     goto fail;
1813   }
1814 invalid_bps:
1815   {
1816     GST_ELEMENT_ERROR (wav, STREAM, FAILED, (NULL),
1817         (&quot;Stream claims av_bsp = %u, which is more than %u - invalid data&quot;,
1818             wav-&gt;av_bps, wav-&gt;blockalign * wav-&gt;rate));
1819     goto fail;
1820   }
1821 no_bytes_per_sample:
1822   {
1823     GST_ELEMENT_ERROR (wav, STREAM, FAILED, (NULL),
1824         (&quot;Could not caluclate bytes per sample - invalid data&quot;));
1825     goto fail;
1826   }
1827 unknown_format:
1828   {
1829     GST_ELEMENT_ERROR (wav, STREAM, TYPE_NOT_FOUND, (NULL),
1830         (&quot;No caps found for format 0x%x, %u channels, %u Hz&quot;,
1831             wav-&gt;format, wav-&gt;channels, wav-&gt;rate));
1832     goto fail;
1833   }
1834 header_read_error:
1835   {
1836     GST_ELEMENT_ERROR (wav, STREAM, DEMUX, (NULL),
1837         (&quot;Couldn&#39;t read in header %d (%s)&quot;, res, gst_flow_get_name (res)));
1838     goto fail;
1839   }
1840 }
1841 
1842 /*
1843  * Read WAV file tag when streaming
1844  */
1845 static GstFlowReturn
1846 gst_wavparse_parse_stream_init (GstWavParse * wav)
1847 {
1848   if (gst_adapter_available (wav-&gt;adapter) &gt;= 12) {
1849     GstBuffer *tmp;
1850 
1851     /* _take flushes the data */
1852     tmp = gst_adapter_take_buffer (wav-&gt;adapter, 12);
1853 
1854     GST_DEBUG (&quot;Parsing wav header&quot;);
1855     if (!gst_wavparse_parse_file_header (GST_ELEMENT_CAST (wav), tmp))
1856       return GST_FLOW_ERROR;
1857 
1858     wav-&gt;offset += 12;
1859     /* Go to next state */
1860     wav-&gt;state = GST_WAVPARSE_HEADER;
1861   }
1862   return GST_FLOW_OK;
1863 }
1864 
1865 /* handle an event sent directly to the element.
1866  *
1867  * This event can be sent either in the READY state or the
1868  * &gt;READY state. The only event of interest really is the seek
1869  * event.
1870  *
1871  * In the READY state we can only store the event and try to
1872  * respect it when going to PAUSED. We assume we are in the
1873  * READY state when our parsing state != GST_WAVPARSE_DATA.
1874  *
1875  * When we are steaming, we can simply perform the seek right
1876  * away.
1877  */
1878 static gboolean
1879 gst_wavparse_send_event (GstElement * element, GstEvent * event)
1880 {
1881   GstWavParse *wav = GST_WAVPARSE (element);
1882   gboolean res = FALSE;
1883 
1884   GST_DEBUG_OBJECT (wav, &quot;received event %s&quot;, GST_EVENT_TYPE_NAME (event));
1885 
1886   switch (GST_EVENT_TYPE (event)) {
1887     case GST_EVENT_SEEK:
1888       if (wav-&gt;state == GST_WAVPARSE_DATA) {
1889         /* we can handle the seek directly when streaming data */
1890         res = gst_wavparse_perform_seek (wav, event);
1891       } else {
1892         GST_DEBUG_OBJECT (wav, &quot;queuing seek for later&quot;);
1893 
1894         gst_event_replace (&amp;wav-&gt;seek_event, event);
1895 
1896         /* we always return true */
1897         res = TRUE;
1898       }
1899       break;
1900     default:
1901       break;
1902   }
1903   gst_event_unref (event);
1904   return res;
1905 }
1906 
1907 static gboolean
1908 gst_wavparse_have_dts_caps (const GstCaps * caps, GstTypeFindProbability prob)
1909 {
1910   GstStructure *s;
1911 
1912   s = gst_caps_get_structure (caps, 0);
1913   if (!gst_structure_has_name (s, &quot;audio/x-dts&quot;))
1914     return FALSE;
1915   /* typefind behavior for DTS:
1916    *  MAXIMUM: multiple frame syncs detected, certainly DTS
1917    *  LIKELY: single frame sync at offset 0.  Maybe DTS?
1918    *  POSSIBLE: single frame sync, not at offset 0.  Highly unlikely
1919    *    to be DTS.  */
1920   if (prob &gt; GST_TYPE_FIND_LIKELY)
1921     return TRUE;
1922   if (prob &lt;= GST_TYPE_FIND_POSSIBLE)
1923     return FALSE;
1924   /* for maybe, check for at least a valid-looking rate and channels */
1925   if (!gst_structure_has_field (s, &quot;channels&quot;))
1926     return FALSE;
1927   /* and for extra assurance we could also check the rate from the DTS frame
1928    * against the one in the wav header, but for now let&#39;s not do that */
1929   return gst_structure_has_field (s, &quot;rate&quot;);
1930 }
1931 
1932 static GstTagList *
1933 gst_wavparse_get_upstream_tags (GstWavParse * wav, GstTagScope scope)
1934 {
1935   GstTagList *tags = NULL;
1936   GstEvent *ev;
1937   gint i;
1938 
1939   i = 0;
1940   while ((ev = gst_pad_get_sticky_event (wav-&gt;sinkpad, GST_EVENT_TAG, i++))) {
1941     gst_event_parse_tag (ev, &amp;tags);
1942     if (tags != NULL &amp;&amp; gst_tag_list_get_scope (tags) == scope) {
1943       tags = gst_tag_list_copy (tags);
1944       gst_tag_list_remove_tag (tags, GST_TAG_CONTAINER_FORMAT);
1945       gst_event_unref (ev);
1946       break;
1947     }
1948     tags = NULL;
1949     gst_event_unref (ev);
1950   }
1951   return tags;
1952 }
1953 
1954 static void
1955 gst_wavparse_add_src_pad (GstWavParse * wav, GstBuffer * buf)
1956 {
1957   GstStructure *s;
1958   GstTagList *tags, *utags;
1959 
1960   GST_DEBUG_OBJECT (wav, &quot;adding src pad&quot;);
1961 
1962   g_assert (wav-&gt;caps != NULL);
1963 
1964     s = gst_caps_get_structure (wav-&gt;caps, 0);
1965   if (s &amp;&amp; gst_structure_has_name (s, &quot;audio/x-raw&quot;) &amp;&amp; buf != NULL) {
1966       GstTypeFindProbability prob;
1967       GstCaps *tf_caps;
1968 
1969       tf_caps = gst_type_find_helper_for_buffer (GST_OBJECT (wav), buf, &amp;prob);
1970       if (tf_caps != NULL) {
1971         GST_LOG (&quot;typefind caps = %&quot; GST_PTR_FORMAT &quot;, P=%d&quot;, tf_caps, prob);
1972         if (gst_wavparse_have_dts_caps (tf_caps, prob)) {
1973           GST_INFO_OBJECT (wav, &quot;Found DTS marker in file marked as raw PCM&quot;);
1974           gst_caps_unref (wav-&gt;caps);
1975           wav-&gt;caps = tf_caps;
1976 
1977           gst_tag_list_add (wav-&gt;tags, GST_TAG_MERGE_REPLACE,
1978               GST_TAG_AUDIO_CODEC, &quot;dts&quot;, NULL);
1979         } else {
1980           GST_DEBUG_OBJECT (wav, &quot;found caps %&quot; GST_PTR_FORMAT &quot; for stream &quot;
1981               &quot;marked as raw PCM audio, but ignoring for now&quot;, tf_caps);
1982           gst_caps_unref (tf_caps);
1983         }
1984       }
1985     }
1986 
1987   gst_pad_set_caps (wav-&gt;srcpad, wav-&gt;caps);
1988 
1989   if (wav-&gt;start_segment) {
1990     GST_DEBUG_OBJECT (wav, &quot;Send start segment event on newpad&quot;);
1991     gst_pad_push_event (wav-&gt;srcpad, wav-&gt;start_segment);
1992     wav-&gt;start_segment = NULL;
1993   }
1994 
1995   /* upstream tags, e.g. from id3/ape tag before the wav file; assume for now
1996    * that there&#39;ll be only one scope/type of tag list from upstream, if any */
1997   utags = gst_wavparse_get_upstream_tags (wav, GST_TAG_SCOPE_GLOBAL);
1998   if (utags == NULL)
1999     utags = gst_wavparse_get_upstream_tags (wav, GST_TAG_SCOPE_STREAM);
2000 
2001   /* if there&#39;s a tag upstream it&#39;s probably been added to override the
2002    * tags from inside the wav header, so keep upstream tags if in doubt */
2003   tags = gst_tag_list_merge (utags, wav-&gt;tags, GST_TAG_MERGE_KEEP);
2004 
2005   if (wav-&gt;tags != NULL) {
2006     gst_tag_list_unref (wav-&gt;tags);
2007     wav-&gt;tags = NULL;
2008   }
2009 
2010   if (utags != NULL)
2011     gst_tag_list_unref (utags);
2012 
2013   /* send tags downstream, if any */
2014   if (tags != NULL)
2015     gst_pad_push_event (wav-&gt;srcpad, gst_event_new_tag (tags));
2016 }
2017 
2018 static GstFlowReturn
2019 gst_wavparse_stream_data (GstWavParse * wav)
2020 {
2021   GstBuffer *buf = NULL;
2022   GstFlowReturn res = GST_FLOW_OK;
2023   guint64 desired, obtained;
2024   GstClockTime timestamp, next_timestamp, duration;
2025   guint64 pos, nextpos;
2026 
2027 iterate_adapter:
2028   GST_LOG_OBJECT (wav,
2029       &quot;offset: %&quot; G_GINT64_FORMAT &quot; , end: %&quot; G_GINT64_FORMAT &quot; , dataleft: %&quot;
2030       G_GINT64_FORMAT, wav-&gt;offset, wav-&gt;end_offset, wav-&gt;dataleft);
2031 
2032   if ((wav-&gt;dataleft == 0 || wav-&gt;dataleft &lt; wav-&gt;blockalign)) {
2033     /* In case chunk size is not declared in the begining get size from the
2034      * file size directly */
2035     if (wav-&gt;chunk_size == 0) {
2036       gint64 upstream_size = 0;
2037 
2038       /* Get the size of the file   */
2039       if (!gst_pad_peer_query_duration (wav-&gt;sinkpad, GST_FORMAT_BYTES,
2040               &amp;upstream_size))
2041         goto found_eos;
2042 
2043       if (upstream_size &lt; wav-&gt;offset + wav-&gt;datastart)
2044         goto found_eos;
2045 
2046       /* If file has updated since the beggining continue reading the file */
2047       wav-&gt;dataleft = upstream_size - wav-&gt;offset - wav-&gt;datastart;
2048       wav-&gt;end_offset = upstream_size;
2049 
2050       /* Get the next n bytes and output them, if we can */
2051   if (wav-&gt;dataleft == 0 || wav-&gt;dataleft &lt; wav-&gt;blockalign)
2052     goto found_eos;
2053     } else {
2054       goto found_eos;
2055     }
2056   }
2057 
2058   /* scale the amount of data by the segment rate so we get equal
2059    * amounts of data regardless of the playback rate */
2060   desired =
2061       MIN (gst_guint64_to_gdouble (wav-&gt;dataleft),
2062       wav-&gt;max_buf_size * ABS (wav-&gt;segment.rate));
2063 
2064   if (desired &gt;= wav-&gt;blockalign &amp;&amp; wav-&gt;blockalign &gt; 0)
2065     desired -= (desired % wav-&gt;blockalign);
2066 
2067 #ifdef GSTREAMER_LITE
2068   if (desired == 0) {
2069     GST_ELEMENT_ERROR (wav, STREAM, DEMUX, (NULL),
2070               (&quot;Invalid stream&quot;));
2071     return GST_FLOW_ERROR;
2072   }
2073 #endif // GSTREAMER_LITE
2074 
2075   GST_LOG_OBJECT (wav, &quot;Fetching %&quot; G_GINT64_FORMAT &quot; bytes of data &quot;
2076       &quot;from the sinkpad&quot;, desired);
2077 
2078   if (wav-&gt;streaming) {
2079     guint avail = gst_adapter_available (wav-&gt;adapter);
2080     guint extra;
2081 
2082     /* flush some bytes if evil upstream sends segment that starts
2083      * before data or does is not send sample aligned segment */
2084     if (G_LIKELY (wav-&gt;offset &gt;= wav-&gt;datastart)) {
2085       extra = (wav-&gt;offset - wav-&gt;datastart) % wav-&gt;bytes_per_sample;
2086     } else {
2087       extra = wav-&gt;datastart - wav-&gt;offset;
2088     }
2089 
2090     if (G_UNLIKELY (extra)) {
2091       extra = wav-&gt;bytes_per_sample - extra;
2092       if (extra &lt;= avail) {
2093         GST_DEBUG_OBJECT (wav, &quot;flushing %u bytes to sample boundary&quot;, extra);
2094         gst_adapter_flush (wav-&gt;adapter, extra);
2095         wav-&gt;offset += extra;
2096         wav-&gt;dataleft -= extra;
2097         goto iterate_adapter;
2098       } else {
2099         GST_DEBUG_OBJECT (wav, &quot;flushing %u bytes&quot;, avail);
2100         gst_adapter_clear (wav-&gt;adapter);
2101         wav-&gt;offset += avail;
2102         wav-&gt;dataleft -= avail;
2103         return GST_FLOW_OK;
2104       }
2105     }
2106 
2107     if (avail &lt; desired) {
2108       GST_LOG_OBJECT (wav, &quot;Got only %u bytes of data from the sinkpad&quot;, avail);
2109       return GST_FLOW_OK;
2110     }
2111 
2112     buf = gst_adapter_take_buffer (wav-&gt;adapter, desired);
2113   } else {
2114     if ((res = gst_pad_pull_range (wav-&gt;sinkpad, wav-&gt;offset,
2115                 desired, &amp;buf)) != GST_FLOW_OK)
2116       goto pull_error;
2117 
2118     /* we may get a short buffer at the end of the file */
2119     if (gst_buffer_get_size (buf) &lt; desired) {
2120       gsize size = gst_buffer_get_size (buf);
2121 
2122       GST_LOG_OBJECT (wav, &quot;Got only %&quot; G_GSIZE_FORMAT &quot; bytes of data&quot;, size);
2123       if (size &gt;= wav-&gt;blockalign) {
2124         if (wav-&gt;blockalign &gt; 0) {
2125           buf = gst_buffer_make_writable (buf);
2126           gst_buffer_resize (buf, 0, size - (size % wav-&gt;blockalign));
2127         }
2128       } else {
2129         gst_buffer_unref (buf);
2130         goto found_eos;
2131       }
2132     }
2133   }
2134 
2135   obtained = gst_buffer_get_size (buf);
2136 
2137   /* our positions in bytes */
2138   pos = wav-&gt;offset - wav-&gt;datastart;
2139   nextpos = pos + obtained;
2140 
2141   /* update offsets, does not overflow. */
2142   buf = gst_buffer_make_writable (buf);
2143   GST_BUFFER_OFFSET (buf) = pos / wav-&gt;bytes_per_sample;
2144   GST_BUFFER_OFFSET_END (buf) = nextpos / wav-&gt;bytes_per_sample;
2145 
2146   /* first chunk of data? create the source pad. We do this only here so
2147    * we can detect broken .wav files with dts disguised as raw PCM (sigh) */
2148   if (G_UNLIKELY (wav-&gt;first)) {
2149     wav-&gt;first = FALSE;
2150     /* this will also push the segment events */
2151     gst_wavparse_add_src_pad (wav, buf);
2152   } else {
2153     /* If we have a pending start segment, send it now. */
2154     if (G_UNLIKELY (wav-&gt;start_segment != NULL)) {
2155       gst_pad_push_event (wav-&gt;srcpad, wav-&gt;start_segment);
2156       wav-&gt;start_segment = NULL;
2157     }
2158   }
2159 
2160   if (wav-&gt;bps &gt; 0) {
2161     /* and timestamps if we have a bitrate, be careful for overflows */
2162     timestamp =
2163         gst_util_uint64_scale_ceil (pos, GST_SECOND, (guint64) wav-&gt;bps);
2164     next_timestamp =
2165         gst_util_uint64_scale_ceil (nextpos, GST_SECOND, (guint64) wav-&gt;bps);
2166     duration = next_timestamp - timestamp;
2167 
2168     /* update current running segment position */
2169     if (G_LIKELY (next_timestamp &gt;= wav-&gt;segment.start))
2170       wav-&gt;segment.position = next_timestamp;
2171   } else if (wav-&gt;fact) {
2172     guint64 bps =
2173         gst_util_uint64_scale_int (wav-&gt;datasize, wav-&gt;rate, wav-&gt;fact);
2174     /* and timestamps if we have a bitrate, be careful for overflows */
2175     timestamp = gst_util_uint64_scale_ceil (pos, GST_SECOND, bps);
2176     next_timestamp = gst_util_uint64_scale_ceil (nextpos, GST_SECOND, bps);
2177     duration = next_timestamp - timestamp;
2178   } else {
2179     /* no bitrate, all we know is that the first sample has timestamp 0, all
2180      * other positions and durations have unknown timestamp. */
2181     if (pos == 0)
2182       timestamp = 0;
2183     else
2184       timestamp = GST_CLOCK_TIME_NONE;
2185     duration = GST_CLOCK_TIME_NONE;
2186     /* update current running segment position with byte offset */
2187     if (G_LIKELY (nextpos &gt;= wav-&gt;segment.start))
2188       wav-&gt;segment.position = nextpos;
2189   }
2190   if ((pos &gt; 0) &amp;&amp; wav-&gt;vbr) {
2191     /* don&#39;t set timestamps for VBR files if it&#39;s not the first buffer */
2192     timestamp = GST_CLOCK_TIME_NONE;
2193     duration = GST_CLOCK_TIME_NONE;
2194   }
2195   if (wav-&gt;discont) {
2196     GST_DEBUG_OBJECT (wav, &quot;marking DISCONT&quot;);
2197     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);
2198     wav-&gt;discont = FALSE;
2199   }
2200 
2201   GST_BUFFER_TIMESTAMP (buf) = timestamp;
2202   GST_BUFFER_DURATION (buf) = duration;
2203 
2204   GST_LOG_OBJECT (wav,
2205       &quot;Got buffer. timestamp:%&quot; GST_TIME_FORMAT &quot; , duration:%&quot; GST_TIME_FORMAT
2206       &quot;, size:%&quot; G_GSIZE_FORMAT, GST_TIME_ARGS (timestamp),
2207       GST_TIME_ARGS (duration), gst_buffer_get_size (buf));
2208 
2209   if ((res = gst_pad_push (wav-&gt;srcpad, buf)) != GST_FLOW_OK)
2210     goto push_error;
2211 
2212   if (obtained &lt; wav-&gt;dataleft) {
2213     wav-&gt;offset += obtained;
2214     wav-&gt;dataleft -= obtained;
2215   } else {
2216     wav-&gt;offset += wav-&gt;dataleft;
2217     wav-&gt;dataleft = 0;
2218   }
2219 
2220   /* Iterate until need more data, so adapter size won&#39;t grow */
2221   if (wav-&gt;streaming) {
2222     GST_LOG_OBJECT (wav,
2223         &quot;offset: %&quot; G_GINT64_FORMAT &quot; , end: %&quot; G_GINT64_FORMAT, wav-&gt;offset,
2224         wav-&gt;end_offset);
2225     goto iterate_adapter;
2226   }
2227   return res;
2228 
2229   /* ERROR */
2230 found_eos:
2231   {
2232     GST_DEBUG_OBJECT (wav, &quot;found EOS&quot;);
2233     return GST_FLOW_EOS;
2234   }
2235 pull_error:
2236   {
2237     /* check if we got EOS */
2238     if (res == GST_FLOW_EOS)
2239       goto found_eos;
2240 
2241     GST_WARNING_OBJECT (wav,
2242         &quot;Error getting %&quot; G_GINT64_FORMAT &quot; bytes from the &quot;
2243         &quot;sinkpad (dataleft = %&quot; G_GINT64_FORMAT &quot;)&quot;, desired, wav-&gt;dataleft);
2244     return res;
2245   }
2246 push_error:
2247   {
2248     GST_INFO_OBJECT (wav,
2249         &quot;Error pushing on srcpad %s:%s, reason %s, is linked? = %d&quot;,
2250         GST_DEBUG_PAD_NAME (wav-&gt;srcpad), gst_flow_get_name (res),
2251         gst_pad_is_linked (wav-&gt;srcpad));
2252     return res;
2253   }
2254 }
2255 
2256 static void
2257 gst_wavparse_loop (GstPad * pad)
2258 {
2259   GstFlowReturn ret;
2260   GstWavParse *wav = GST_WAVPARSE (GST_PAD_PARENT (pad));
2261   GstEvent *event;
2262   gchar *stream_id;
2263 
2264   GST_LOG_OBJECT (wav, &quot;process data&quot;);
2265 
2266   switch (wav-&gt;state) {
2267     case GST_WAVPARSE_START:
2268       GST_INFO_OBJECT (wav, &quot;GST_WAVPARSE_START&quot;);
2269       if ((ret = gst_wavparse_stream_init (wav)) != GST_FLOW_OK)
2270         goto pause;
2271 
2272       stream_id =
2273           gst_pad_create_stream_id (wav-&gt;srcpad, GST_ELEMENT_CAST (wav), NULL);
2274       event = gst_event_new_stream_start (stream_id);
2275       gst_event_set_group_id (event, gst_util_group_id_next ());
2276       gst_pad_push_event (wav-&gt;srcpad, event);
2277       g_free (stream_id);
2278 
2279       wav-&gt;state = GST_WAVPARSE_HEADER;
2280       /* fall-through */
2281 
2282     case GST_WAVPARSE_HEADER:
2283       GST_INFO_OBJECT (wav, &quot;GST_WAVPARSE_HEADER&quot;);
2284       if ((ret = gst_wavparse_stream_headers (wav)) != GST_FLOW_OK)
2285         goto pause;
2286 
2287       wav-&gt;state = GST_WAVPARSE_DATA;
2288       GST_INFO_OBJECT (wav, &quot;GST_WAVPARSE_DATA&quot;);
2289       /* fall-through */
2290 
2291     case GST_WAVPARSE_DATA:
2292       if ((ret = gst_wavparse_stream_data (wav)) != GST_FLOW_OK)
2293         goto pause;
2294       break;
2295     default:
2296       g_assert_not_reached ();
2297   }
2298   return;
2299 
2300   /* ERRORS */
2301 pause:
2302   {
2303     const gchar *reason = gst_flow_get_name (ret);
2304 
2305     GST_DEBUG_OBJECT (wav, &quot;pausing task, reason %s&quot;, reason);
2306     gst_pad_pause_task (pad);
2307 
2308     if (ret == GST_FLOW_EOS) {
2309       /* handle end-of-stream/segment */
2310       /* so align our position with the end of it, if there is one
2311        * this ensures a subsequent will arrive at correct base/acc time */
2312       if (wav-&gt;segment.format == GST_FORMAT_TIME) {
2313         if (wav-&gt;segment.rate &gt; 0.0 &amp;&amp;
2314             GST_CLOCK_TIME_IS_VALID (wav-&gt;segment.stop))
2315           wav-&gt;segment.position = wav-&gt;segment.stop;
2316         else if (wav-&gt;segment.rate &lt; 0.0)
2317           wav-&gt;segment.position = wav-&gt;segment.start;
2318       }
2319       if (wav-&gt;state == GST_WAVPARSE_START || !wav-&gt;caps) {
2320         GST_ELEMENT_ERROR (wav, STREAM, WRONG_TYPE, (NULL),
2321             (&quot;No valid input found before end of stream&quot;));
2322         gst_pad_push_event (wav-&gt;srcpad, gst_event_new_eos ());
2323       } else {
2324       /* add pad before we perform EOS */
2325       if (G_UNLIKELY (wav-&gt;first)) {
2326         wav-&gt;first = FALSE;
2327         gst_wavparse_add_src_pad (wav, NULL);
2328       }
2329 
2330       /* perform EOS logic */
2331       if (wav-&gt;segment.flags &amp; GST_SEEK_FLAG_SEGMENT) {
2332         GstClockTime stop;
2333 
2334         if ((stop = wav-&gt;segment.stop) == -1)
2335           stop = wav-&gt;segment.duration;
2336 
2337         gst_element_post_message (GST_ELEMENT_CAST (wav),
2338             gst_message_new_segment_done (GST_OBJECT_CAST (wav),
2339                 wav-&gt;segment.format, stop));
2340           gst_pad_push_event (wav-&gt;srcpad,
2341               gst_event_new_segment_done (wav-&gt;segment.format, stop));
2342       } else {
2343           gst_pad_push_event (wav-&gt;srcpad, gst_event_new_eos ());
2344       }
2345       }
2346     } else if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS) {
2347       /* for fatal errors we post an error message, post the error
2348        * first so the app knows about the error first. */
2349       GST_ELEMENT_FLOW_ERROR (wav, ret);
2350         gst_pad_push_event (wav-&gt;srcpad, gst_event_new_eos ());
2351     }
2352     return;
2353   }
2354 }
2355 
2356 static GstFlowReturn
2357 gst_wavparse_chain (GstPad * pad, GstObject * parent, GstBuffer * buf)
2358 {
2359   GstFlowReturn ret;
2360   GstWavParse *wav = GST_WAVPARSE (parent);
2361 
2362   GST_LOG_OBJECT (wav, &quot;adapter_push %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
2363       gst_buffer_get_size (buf));
2364 
2365   gst_adapter_push (wav-&gt;adapter, buf);
2366 
2367   switch (wav-&gt;state) {
2368     case GST_WAVPARSE_START:
2369       GST_INFO_OBJECT (wav, &quot;GST_WAVPARSE_START&quot;);
2370       if ((ret = gst_wavparse_parse_stream_init (wav)) != GST_FLOW_OK)
2371         goto done;
2372 
2373       if (wav-&gt;state != GST_WAVPARSE_HEADER)
2374         break;
2375 
2376       /* otherwise fall-through */
2377     case GST_WAVPARSE_HEADER:
2378       GST_INFO_OBJECT (wav, &quot;GST_WAVPARSE_HEADER&quot;);
2379       if ((ret = gst_wavparse_stream_headers (wav)) != GST_FLOW_OK)
2380         goto done;
2381 
2382       if (!wav-&gt;got_fmt || wav-&gt;datastart == 0)
2383         break;
2384 
2385       wav-&gt;state = GST_WAVPARSE_DATA;
2386       GST_INFO_OBJECT (wav, &quot;GST_WAVPARSE_DATA&quot;);
2387 
2388       /* fall-through */
2389     case GST_WAVPARSE_DATA:
2390       if (buf &amp;&amp; GST_BUFFER_FLAG_IS_SET (buf, GST_BUFFER_FLAG_DISCONT))
2391         wav-&gt;discont = TRUE;
2392       if ((ret = gst_wavparse_stream_data (wav)) != GST_FLOW_OK)
2393         goto done;
2394       break;
2395     default:
2396       g_return_val_if_reached (GST_FLOW_ERROR);
2397   }
2398 done:
2399   if (G_UNLIKELY (wav-&gt;abort_buffering)) {
2400     wav-&gt;abort_buffering = FALSE;
2401     ret = GST_FLOW_ERROR;
2402     /* sort of demux/parse error */
2403     GST_ELEMENT_ERROR (wav, STREAM, DEMUX, (NULL), (&quot;unhandled buffer size&quot;));
2404   }
2405 #ifdef GSTREAMER_LITE
2406   else if (G_UNLIKELY(ret != GST_FLOW_OK &amp;&amp; ret != GST_FLOW_FLUSHING &amp;&amp; ret != GST_FLOW_EOS))
2407   {
2408       GST_ELEMENT_ERROR (wav, STREAM, FAILED,
2409           (_(&quot;Internal data flow error.&quot;)),
2410           (&quot;streaming task paused, reason %s (%d)&quot;,
2411               gst_flow_get_name (ret), ret));
2412   }
2413 #endif // GSTREAMER_LITE
2414 
2415   return ret;
2416 }
2417 
2418 static GstFlowReturn
2419 gst_wavparse_flush_data (GstWavParse * wav)
2420 {
2421   GstFlowReturn ret = GST_FLOW_OK;
2422   guint av;
2423 
2424   if ((av = gst_adapter_available (wav-&gt;adapter)) &gt; 0) {
2425     ret = gst_wavparse_stream_data (wav);
2426   }
2427 
2428   return ret;
2429 }
2430 
2431 static gboolean
2432 gst_wavparse_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
2433 {
2434   GstWavParse *wav = GST_WAVPARSE (parent);
2435   gboolean ret = TRUE;
2436 
2437   GST_LOG_OBJECT (wav, &quot;handling %s event&quot;, GST_EVENT_TYPE_NAME (event));
2438 
2439   switch (GST_EVENT_TYPE (event)) {
2440     case GST_EVENT_CAPS:
2441     {
2442       /* discard, we&#39;ll come up with proper src caps */
2443       gst_event_unref (event);
2444       break;
2445     }
2446     case GST_EVENT_SEGMENT:
2447     {
2448       gint64 start, stop, offset = 0, end_offset = -1;
2449       GstSegment segment;
2450 
2451       /* some debug output */
2452       gst_event_copy_segment (event, &amp;segment);
2453       GST_DEBUG_OBJECT (wav, &quot;received newsegment %&quot; GST_SEGMENT_FORMAT,
2454           &amp;segment);
2455 
2456       if (wav-&gt;state != GST_WAVPARSE_DATA) {
2457         GST_DEBUG_OBJECT (wav, &quot;still starting, eating event&quot;);
2458         goto exit;
2459       }
2460 
2461       /* now we are either committed to TIME or BYTE format,
2462        * and we only expect a BYTE segment, e.g. following a seek */
2463       if (segment.format == GST_FORMAT_BYTES) {
2464         /* handle (un)signed issues */
2465         start = segment.start;
2466         stop = segment.stop;
2467         if (start &gt; 0) {
2468           offset = start;
2469           start -= wav-&gt;datastart;
2470           start = MAX (start, 0);
2471         }
2472         if (stop &gt; 0) {
2473           end_offset = stop;
2474           stop -= wav-&gt;datastart;
2475           stop = MAX (stop, 0);
2476         }
2477         if (wav-&gt;segment.format == GST_FORMAT_TIME) {
2478           guint64 bps = wav-&gt;bps;
2479 
2480           /* operating in format TIME, so we can convert */
2481           if (!bps &amp;&amp; wav-&gt;fact)
2482             bps =
2483                 gst_util_uint64_scale_int (wav-&gt;datasize, wav-&gt;rate, wav-&gt;fact);
2484           if (bps) {
2485             if (start &gt;= 0)
2486               start =
2487                   gst_util_uint64_scale_ceil (start, GST_SECOND,
2488                   (guint64) wav-&gt;bps);
2489             if (stop &gt;= 0)
2490               stop =
2491                   gst_util_uint64_scale_ceil (stop, GST_SECOND,
2492                   (guint64) wav-&gt;bps);
2493           }
2494         }
2495       } else {
2496         GST_DEBUG_OBJECT (wav, &quot;unsupported segment format, ignoring&quot;);
2497         goto exit;
2498       }
2499 
2500       segment.start = start;
2501       segment.stop = stop;
2502 
2503       /* accept upstream&#39;s notion of segment and distribute along */
2504       segment.format = wav-&gt;segment.format;
2505       segment.time = segment.position = segment.start;
2506       segment.duration = wav-&gt;segment.duration;
2507       segment.base = gst_segment_to_running_time (&amp;wav-&gt;segment,
2508           GST_FORMAT_TIME, wav-&gt;segment.position);
2509 
2510       gst_segment_copy_into (&amp;segment, &amp;wav-&gt;segment);
2511 
2512       /* also store the newsegment event for the streaming thread */
2513       if (wav-&gt;start_segment)
2514         gst_event_unref (wav-&gt;start_segment);
2515       GST_DEBUG_OBJECT (wav, &quot;Storing newseg %&quot; GST_SEGMENT_FORMAT, &amp;segment);
2516       wav-&gt;start_segment = gst_event_new_segment (&amp;segment);
2517 
2518       /* stream leftover data in current segment */
2519       gst_wavparse_flush_data (wav);
2520       /* and set up streaming thread for next one */
2521       wav-&gt;offset = offset;
2522       wav-&gt;end_offset = end_offset;
2523 
2524       if (wav-&gt;datasize &gt; 0 &amp;&amp; (wav-&gt;end_offset == -1
2525               || wav-&gt;end_offset &gt; wav-&gt;datastart + wav-&gt;datasize))
2526         wav-&gt;end_offset = wav-&gt;datastart + wav-&gt;datasize;
2527 
2528       if (wav-&gt;end_offset != -1) {
2529 #ifdef GSTREAMER_LITE
2530         wav-&gt;dataleft = MIN(wav-&gt;datasize, wav-&gt;end_offset - wav-&gt;offset);
2531 #else
2532         wav-&gt;dataleft = wav-&gt;end_offset - wav-&gt;offset;
2533 #endif // GSTREAMER_LITE
2534       } else {
2535         /* infinity; upstream will EOS when done */
2536         wav-&gt;dataleft = G_MAXUINT64;
2537       }
2538     exit:
2539       gst_event_unref (event);
2540       break;
2541     }
2542 #ifdef GSTREAMER_LITE
2543     case FX_EVENT_RANGE_READY: // This event appears only in pull mode during outrange seeking.
2544         ret = gst_pad_start_task (pad, (GstTaskFunction) gst_wavparse_loop, pad, NULL);
2545         gst_event_unref(event);
2546         break;
2547 #endif // GSTREAMER_LITE
2548     case GST_EVENT_EOS:
2549       if (wav-&gt;state == GST_WAVPARSE_START || !wav-&gt;caps) {
2550         GST_ELEMENT_ERROR (wav, STREAM, WRONG_TYPE, (NULL),
2551             (&quot;No valid input found before end of stream&quot;));
2552       } else {
2553       /* add pad if needed so EOS is seen downstream */
2554       if (G_UNLIKELY (wav-&gt;first)) {
2555         wav-&gt;first = FALSE;
2556         gst_wavparse_add_src_pad (wav, NULL);
2557       } else {
2558         /* stream leftover data in current segment */
2559         gst_wavparse_flush_data (wav);
2560       }
2561       }
2562 
2563       /* fall-through */
2564     case GST_EVENT_FLUSH_STOP:
2565     {
2566       GstClockTime dur;
2567 
2568       if (wav-&gt;adapter)
2569       gst_adapter_clear (wav-&gt;adapter);
2570       wav-&gt;discont = TRUE;
2571       dur = wav-&gt;segment.duration;
2572       gst_segment_init (&amp;wav-&gt;segment, wav-&gt;segment.format);
2573       wav-&gt;segment.duration = dur;
2574       /* fall-through */
2575     }
2576     default:
2577       ret = gst_pad_event_default (wav-&gt;sinkpad, parent, event);
2578       break;
2579   }
2580 
2581   return ret;
2582 }
2583 
2584 #if 0
2585 /* convert and query stuff */
2586 static const GstFormat *
2587 gst_wavparse_get_formats (GstPad * pad)
2588 {
2589   static const GstFormat formats[] = {
2590     GST_FORMAT_TIME,
2591     GST_FORMAT_BYTES,
2592     GST_FORMAT_DEFAULT,         /* a &quot;frame&quot;, ie a set of samples per Hz */
2593     0
2594   };
2595 
2596   return formats;
2597 }
2598 #endif
2599 
2600 static gboolean
2601 gst_wavparse_pad_convert (GstPad * pad,
2602     GstFormat src_format, gint64 src_value,
2603     GstFormat * dest_format, gint64 * dest_value)
2604 {
2605   GstWavParse *wavparse;
2606   gboolean res = TRUE;
2607 
2608   wavparse = GST_WAVPARSE (GST_PAD_PARENT (pad));
2609 
2610   if (*dest_format == src_format) {
2611     *dest_value = src_value;
2612     return TRUE;
2613   }
2614 
2615   if ((wavparse-&gt;bps == 0) &amp;&amp; !wavparse-&gt;fact)
2616     goto no_bps_fact;
2617 
2618   GST_INFO_OBJECT (wavparse, &quot;converting value from %s to %s&quot;,
2619       gst_format_get_name (src_format), gst_format_get_name (*dest_format));
2620 
2621   switch (src_format) {
2622     case GST_FORMAT_BYTES:
2623       switch (*dest_format) {
2624         case GST_FORMAT_DEFAULT:
2625           *dest_value = src_value / wavparse-&gt;bytes_per_sample;
2626           /* make sure we end up on a sample boundary */
2627           *dest_value -= *dest_value % wavparse-&gt;bytes_per_sample;
2628           break;
2629         case GST_FORMAT_TIME:
2630           /* src_value + datastart = offset */
2631           GST_INFO_OBJECT (wavparse,
2632               &quot;src=%&quot; G_GINT64_FORMAT &quot;, offset=%&quot; G_GINT64_FORMAT, src_value,
2633               wavparse-&gt;offset);
2634           if (wavparse-&gt;bps &gt; 0)
2635             *dest_value = gst_util_uint64_scale_ceil (src_value, GST_SECOND,
2636                 (guint64) wavparse-&gt;bps);
2637           else if (wavparse-&gt;fact) {
2638             guint64 bps = gst_util_uint64_scale_int_ceil (wavparse-&gt;datasize,
2639                 wavparse-&gt;rate, wavparse-&gt;fact);
2640 
2641             *dest_value =
2642                 gst_util_uint64_scale_int_ceil (src_value, GST_SECOND, bps);
2643           } else {
2644             res = FALSE;
2645           }
2646           break;
2647         default:
2648           res = FALSE;
2649           goto done;
2650       }
2651       break;
2652 
2653     case GST_FORMAT_DEFAULT:
2654       switch (*dest_format) {
2655         case GST_FORMAT_BYTES:
2656           *dest_value = src_value * wavparse-&gt;bytes_per_sample;
2657           break;
2658         case GST_FORMAT_TIME:
2659           *dest_value = gst_util_uint64_scale (src_value, GST_SECOND,
2660               (guint64) wavparse-&gt;rate);
2661           break;
2662         default:
2663           res = FALSE;
2664           goto done;
2665       }
2666       break;
2667 
2668     case GST_FORMAT_TIME:
2669       switch (*dest_format) {
2670         case GST_FORMAT_BYTES:
2671           if (wavparse-&gt;bps &gt; 0)
2672             *dest_value = gst_util_uint64_scale (src_value,
2673                 (guint64) wavparse-&gt;bps, GST_SECOND);
2674           else {
2675             guint64 bps = gst_util_uint64_scale_int (wavparse-&gt;datasize,
2676                 wavparse-&gt;rate, wavparse-&gt;fact);
2677 
2678             *dest_value = gst_util_uint64_scale (src_value, bps, GST_SECOND);
2679           }
2680           /* make sure we end up on a sample boundary */
2681           *dest_value -= *dest_value % wavparse-&gt;blockalign;
2682           break;
2683         case GST_FORMAT_DEFAULT:
2684           *dest_value = gst_util_uint64_scale (src_value,
2685               (guint64) wavparse-&gt;rate, GST_SECOND);
2686           break;
2687         default:
2688           res = FALSE;
2689           goto done;
2690       }
2691       break;
2692 
2693     default:
2694       res = FALSE;
2695       goto done;
2696   }
2697 
2698 done:
2699   return res;
2700 
2701   /* ERRORS */
2702 no_bps_fact:
2703   {
2704     GST_DEBUG_OBJECT (wavparse, &quot;bps 0 or no fact chunk, cannot convert&quot;);
2705     res = FALSE;
2706     goto done;
2707   }
2708 }
2709 
2710 /* handle queries for location and length in requested format */
2711 static gboolean
2712 gst_wavparse_pad_query (GstPad * pad, GstObject * parent, GstQuery * query)
2713 {
2714   gboolean res = TRUE;
2715   GstWavParse *wav = GST_WAVPARSE (parent);
2716 
2717   /* only if we know */
2718   if (wav-&gt;state != GST_WAVPARSE_DATA) {
2719     return FALSE;
2720   }
2721 
2722   GST_LOG_OBJECT (pad, &quot;%s query&quot;, GST_QUERY_TYPE_NAME (query));
2723 
2724   switch (GST_QUERY_TYPE (query)) {
2725     case GST_QUERY_POSITION:
2726     {
2727       gint64 curb;
2728       gint64 cur;
2729       GstFormat format;
2730 
2731       /* this is not very precise, as we have pushed severla buffer upstream for prerolling */
2732       curb = wav-&gt;offset - wav-&gt;datastart;
2733       gst_query_parse_position (query, &amp;format, NULL);
2734       GST_INFO_OBJECT (wav, &quot;pos query at %&quot; G_GINT64_FORMAT, curb);
2735 
2736       switch (format) {
2737         case GST_FORMAT_BYTES:
2738           format = GST_FORMAT_BYTES;
2739           cur = curb;
2740           break;
2741         default:
2742           res = gst_wavparse_pad_convert (pad, GST_FORMAT_BYTES, curb,
2743               &amp;format, &amp;cur);
2744           break;
2745       }
2746       if (res)
2747         gst_query_set_position (query, format, cur);
2748       break;
2749     }
2750     case GST_QUERY_DURATION:
2751     {
2752       gint64 duration = 0;
2753       GstFormat format;
2754 
2755       if (wav-&gt;ignore_length) {
2756         res = FALSE;
2757         break;
2758       }
2759 
2760       gst_query_parse_duration (query, &amp;format, NULL);
2761 
2762       switch (format) {
2763         case GST_FORMAT_BYTES:{
2764           format = GST_FORMAT_BYTES;
2765           duration = wav-&gt;datasize;
2766           break;
2767         }
2768         case GST_FORMAT_TIME:
2769           if ((res = gst_wavparse_calculate_duration (wav))) {
2770             duration = wav-&gt;duration;
2771           }
2772           break;
2773         default:
2774           res = FALSE;
2775           break;
2776       }
2777       if (res)
2778         gst_query_set_duration (query, format, duration);
2779       break;
2780     }
2781     case GST_QUERY_CONVERT:
2782     {
2783       gint64 srcvalue, dstvalue;
2784       GstFormat srcformat, dstformat;
2785 
2786       gst_query_parse_convert (query, &amp;srcformat, &amp;srcvalue,
2787           &amp;dstformat, &amp;dstvalue);
2788       res = gst_wavparse_pad_convert (pad, srcformat, srcvalue,
2789           &amp;dstformat, &amp;dstvalue);
2790       if (res)
2791         gst_query_set_convert (query, srcformat, srcvalue, dstformat, dstvalue);
2792       break;
2793     }
2794     case GST_QUERY_SEEKING:{
2795       GstFormat fmt;
2796       gboolean seekable = FALSE;
2797 
2798       gst_query_parse_seeking (query, &amp;fmt, NULL, NULL, NULL);
2799       if (fmt == wav-&gt;segment.format) {
2800         if (wav-&gt;streaming) {
2801           GstQuery *q;
2802 
2803           q = gst_query_new_seeking (GST_FORMAT_BYTES);
2804           if ((res = gst_pad_peer_query (wav-&gt;sinkpad, q))) {
2805             gst_query_parse_seeking (q, &amp;fmt, &amp;seekable, NULL, NULL);
2806             GST_LOG_OBJECT (wav, &quot;upstream BYTE seekable %d&quot;, seekable);
2807           }
2808           gst_query_unref (q);
2809         } else {
2810           GST_LOG_OBJECT (wav, &quot;looping =&gt; seekable&quot;);
2811           seekable = TRUE;
2812           res = TRUE;
2813         }
2814       } else if (fmt == GST_FORMAT_TIME) {
2815         res = TRUE;
2816       }
2817       if (res) {
2818         gst_query_set_seeking (query, fmt, seekable, 0, wav-&gt;segment.duration);
2819       }
2820       break;
2821     }
2822     default:
2823       res = gst_pad_query_default (pad, parent, query);
2824       break;
2825   }
2826   return res;
2827 }
2828 
2829 #ifdef GSTREAMER_LITE
2830 static gboolean
2831 gst_wavparse_sink_query (GstPad* pad, GstObject *parent, GstQuery* query)
2832 {
2833     gboolean result = TRUE;
2834     switch (GST_QUERY_TYPE(query))
2835     {
2836         case GST_QUERY_CUSTOM:
2837         {
2838             const GstStructure *s = gst_query_get_structure(query);
2839             if (gst_structure_has_name(s, GETRANGE_QUERY_NAME))
2840                 gst_structure_set(s, GETRANGE_QUERY_SUPPORTS_FIELDNANE,
2841                                      GETRANGE_QUERY_SUPPORTS_FIELDTYPE,
2842                                      TRUE,
2843                                      NULL);
2844             break;
2845         }
2846         default:
2847             result = gst_pad_query_default(pad, parent, query);
2848             break;
2849     }
2850     return result;
2851 }
2852 #endif // GSTREAMER_LITE
2853 
2854 static gboolean
2855 gst_wavparse_srcpad_event (GstPad * pad, GstObject * parent, GstEvent * event)
2856 {
2857   GstWavParse *wavparse = GST_WAVPARSE (parent);
2858   gboolean res = FALSE;
2859 
2860   GST_DEBUG_OBJECT (wavparse, &quot;%s event&quot;, GST_EVENT_TYPE_NAME (event));
2861 
2862   switch (GST_EVENT_TYPE (event)) {
2863     case GST_EVENT_SEEK:
2864       /* can only handle events when we are in the data state */
2865       if (wavparse-&gt;state == GST_WAVPARSE_DATA) {
2866         res = gst_wavparse_perform_seek (wavparse, event);
2867       }
2868       gst_event_unref (event);
2869       break;
2870 
2871     case GST_EVENT_TOC_SELECT:
2872     {
2873       char *uid = NULL;
2874       GstTocEntry *entry = NULL;
2875       GstEvent *seek_event;
2876       gint64 start_pos;
2877 
2878       if (!wavparse-&gt;toc) {
2879         GST_DEBUG_OBJECT (wavparse, &quot;no TOC to select&quot;);
2880         return FALSE;
2881       } else {
2882         gst_event_parse_toc_select (event, &amp;uid);
2883         if (uid != NULL) {
2884           GST_OBJECT_LOCK (wavparse);
2885           entry = gst_toc_find_entry (wavparse-&gt;toc, uid);
2886           if (entry == NULL) {
2887             GST_OBJECT_UNLOCK (wavparse);
2888             GST_WARNING_OBJECT (wavparse, &quot;no TOC entry with given UID: %s&quot;,
2889                 uid);
2890             res = FALSE;
2891           } else {
2892             gst_toc_entry_get_start_stop_times (entry, &amp;start_pos, NULL);
2893             GST_OBJECT_UNLOCK (wavparse);
2894             seek_event = gst_event_new_seek (1.0,
2895                 GST_FORMAT_TIME,
2896                 GST_SEEK_FLAG_FLUSH,
2897                 GST_SEEK_TYPE_SET, start_pos, GST_SEEK_TYPE_SET, -1);
2898             res = gst_wavparse_perform_seek (wavparse, seek_event);
2899             gst_event_unref (seek_event);
2900           }
2901           g_free (uid);
2902         } else {
2903           GST_WARNING_OBJECT (wavparse, &quot;received empty TOC select event&quot;);
2904           res = FALSE;
2905         }
2906       }
2907       gst_event_unref (event);
2908       break;
2909     }
2910 
2911     default:
2912       res = gst_pad_push_event (wavparse-&gt;sinkpad, event);
2913       break;
2914   }
2915   return res;
2916 }
2917 
2918 static gboolean
2919 gst_wavparse_sink_activate (GstPad * sinkpad, GstObject * parent)
2920 {
2921   GstWavParse *wav = GST_WAVPARSE (parent);
2922   GstQuery *query;
2923   gboolean pull_mode;
2924 
2925   if (wav-&gt;adapter) {
2926     gst_adapter_clear (wav-&gt;adapter);
2927     g_object_unref (wav-&gt;adapter);
2928     wav-&gt;adapter = NULL;
2929   }
2930 
2931   query = gst_query_new_scheduling ();
2932 
2933   if (!gst_pad_peer_query (sinkpad, query)) {
2934     gst_query_unref (query);
2935     goto activate_push;
2936   }
2937 
2938   pull_mode = gst_query_has_scheduling_mode_with_flags (query,
2939       GST_PAD_MODE_PULL, GST_SCHEDULING_FLAG_SEEKABLE);
2940   gst_query_unref (query);
2941 
2942   if (!pull_mode)
2943     goto activate_push;
2944 
2945   GST_DEBUG_OBJECT (sinkpad, &quot;activating pull&quot;);
2946     wav-&gt;streaming = FALSE;
2947   return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PULL, TRUE);
2948 
2949 activate_push:
2950   {
2951     GST_DEBUG_OBJECT (sinkpad, &quot;activating push&quot;);
2952     wav-&gt;streaming = TRUE;
2953     wav-&gt;adapter = gst_adapter_new ();
2954     return gst_pad_activate_mode (sinkpad, GST_PAD_MODE_PUSH, TRUE);
2955   }
2956 }
2957 
2958 
2959 static gboolean
2960 gst_wavparse_sink_activate_mode (GstPad * sinkpad, GstObject * parent,
2961     GstPadMode mode, gboolean active)
2962 {
2963   gboolean res;
2964 
2965   switch (mode) {
2966     case GST_PAD_MODE_PUSH:
2967       res = TRUE;
2968       break;
2969     case GST_PAD_MODE_PULL:
2970   if (active) {
2971     /* if we have a scheduler we can start the task */
2972         res = gst_pad_start_task (sinkpad, (GstTaskFunction) gst_wavparse_loop,
2973             sinkpad, NULL);
2974   } else {
2975         res = gst_pad_stop_task (sinkpad);
2976   }
2977       break;
2978     default:
2979       res = FALSE;
2980       break;
2981   }
2982   return res;
2983 }
2984 
2985 static GstStateChangeReturn
2986 gst_wavparse_change_state (GstElement * element, GstStateChange transition)
2987 {
2988   GstStateChangeReturn ret;
2989   GstWavParse *wav = GST_WAVPARSE (element);
2990 
2991   switch (transition) {
2992     case GST_STATE_CHANGE_NULL_TO_READY:
2993       break;
2994     case GST_STATE_CHANGE_READY_TO_PAUSED:
2995       gst_wavparse_reset (wav);
2996       break;
2997     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
2998       break;
2999     default:
3000       break;
3001   }
3002 
3003   ret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
3004 
3005   switch (transition) {
3006     case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
3007       break;
3008     case GST_STATE_CHANGE_PAUSED_TO_READY:
3009 #ifndef GSTREAMER_LITE
3010       gst_wavparse_destroy_sourcepad (wav);
3011 #endif // GSTREAMER_LITE
3012       gst_wavparse_reset (wav);
3013       break;
3014     case GST_STATE_CHANGE_READY_TO_NULL:
3015       break;
3016     default:
3017       break;
3018   }
3019   return ret;
3020 }
3021 
3022 static void
3023 gst_wavparse_set_property (GObject * object, guint prop_id,
3024     const GValue * value, GParamSpec * pspec)
3025 {
3026   GstWavParse *self;
3027 
3028   g_return_if_fail (GST_IS_WAVPARSE (object));
3029   self = GST_WAVPARSE (object);
3030 
3031   switch (prop_id) {
3032     case PROP_IGNORE_LENGTH:
3033       self-&gt;ignore_length = g_value_get_boolean (value);
3034       break;
3035     default:
3036       G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
3037   }
3038 
3039 }
3040 
3041 static void
3042 gst_wavparse_get_property (GObject * object, guint prop_id,
3043     GValue * value, GParamSpec * pspec)
3044 {
3045   GstWavParse *self;
3046 
3047   g_return_if_fail (GST_IS_WAVPARSE (object));
3048   self = GST_WAVPARSE (object);
3049 
3050   switch (prop_id) {
3051     case PROP_IGNORE_LENGTH:
3052       g_value_set_boolean (value, self-&gt;ignore_length);
3053       break;
3054     default:
3055       G_OBJECT_WARN_INVALID_PROPERTY_ID (self, prop_id, pspec);
3056   }
3057 }
3058 
3059 #ifdef GSTREAMER_LITE
3060 gboolean
3061 plugin_init_wavparse (GstPlugin * plugin)
3062 #else // GSTREAMER_LITE
3063 static gboolean
3064 plugin_init (GstPlugin * plugin)
3065 #endif // GSTREAMER_LITE
3066 {
3067   gst_riff_init ();
3068 
3069   return gst_element_register (plugin, &quot;wavparse&quot;, GST_RANK_PRIMARY,
3070       GST_TYPE_WAVPARSE);
3071 }
3072 
3073 #ifndef GSTREAMER_LITE
3074 GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
3075     GST_VERSION_MINOR,
3076     wavparse,
3077     &quot;Parse a .wav file into raw audio&quot;,
3078     plugin_init, VERSION, GST_LICENSE, GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
3079 #endif // GSTREAMER_LITE
    </pre>
  </body>
</html>