<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gutf8.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gurifuncs.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gutils.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gutf8.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  22 #include &lt;stdlib.h&gt;
  23 #ifdef HAVE_CODESET
  24 #include &lt;langinfo.h&gt;
  25 #endif
  26 #include &lt;string.h&gt;
  27 
  28 #ifdef G_PLATFORM_WIN32
  29 #include &lt;stdio.h&gt;
  30 #define STRICT
  31 #include &lt;windows.h&gt;
  32 #undef STRICT
  33 #endif
  34 
  35 #include &quot;gconvert.h&quot;
  36 #include &quot;ghash.h&quot;
  37 #include &quot;gstrfuncs.h&quot;
  38 #include &quot;gtestutils.h&quot;
  39 #include &quot;gtypes.h&quot;
  40 #include &quot;gthread.h&quot;
  41 #include &quot;glibintl.h&quot;
<span class="line-modified">  42 #include &quot;gunicodeprivate.h&quot;</span>
<span class="line-modified">  43 </span>
<span class="line-modified">  44 #define UTF8_COMPUTE(Char, Mask, Len)                         \</span>
<span class="line-modified">  45   if (Char &lt; 128)                                 \</span>
<span class="line-modified">  46     {                                         \</span>
<span class="line-modified">  47       Len = 1;                                    \</span>
<span class="line-modified">  48       Mask = 0x7f;                                \</span>
<span class="line-modified">  49     }                                         \</span>
<span class="line-modified">  50   else if ((Char &amp; 0xe0) == 0xc0)                         \</span>
<span class="line-modified">  51     {                                         \</span>
<span class="line-modified">  52       Len = 2;                                    \</span>
<span class="line-modified">  53       Mask = 0x1f;                                \</span>
<span class="line-modified">  54     }                                         \</span>
<span class="line-modified">  55   else if ((Char &amp; 0xf0) == 0xe0)                         \</span>
<span class="line-modified">  56     {                                         \</span>
<span class="line-modified">  57       Len = 3;                                    \</span>
<span class="line-modified">  58       Mask = 0x0f;                                \</span>
<span class="line-modified">  59     }                                         \</span>
<span class="line-modified">  60   else if ((Char &amp; 0xf8) == 0xf0)                         \</span>
<span class="line-modified">  61     {                                         \</span>
<span class="line-modified">  62       Len = 4;                                    \</span>
<span class="line-modified">  63       Mask = 0x07;                                \</span>
<span class="line-modified">  64     }                                         \</span>
<span class="line-modified">  65   else if ((Char &amp; 0xfc) == 0xf8)                         \</span>
<span class="line-modified">  66     {                                         \</span>
<span class="line-modified">  67       Len = 5;                                    \</span>
<span class="line-modified">  68       Mask = 0x03;                                \</span>
<span class="line-modified">  69     }                                         \</span>
<span class="line-modified">  70   else if ((Char &amp; 0xfe) == 0xfc)                         \</span>
<span class="line-modified">  71     {                                         \</span>
<span class="line-modified">  72       Len = 6;                                    \</span>
<span class="line-modified">  73       Mask = 0x01;                                \</span>
<span class="line-modified">  74     }                                         \</span>
<span class="line-removed">  75   else                                        \</span>
  76     Len = -1;
  77 
  78 #define UTF8_LENGTH(Char)              \
  79   ((Char) &lt; 0x80 ? 1 :                 \
  80    ((Char) &lt; 0x800 ? 2 :               \
  81     ((Char) &lt; 0x10000 ? 3 :            \
  82      ((Char) &lt; 0x200000 ? 4 :          \
  83       ((Char) &lt; 0x4000000 ? 5 : 6)))))
  84 
  85 
<span class="line-modified">  86 #define UTF8_GET(Result, Chars, Count, Mask, Len)                 \</span>
<span class="line-modified">  87   (Result) = (Chars)[0] &amp; (Mask);                         \</span>
<span class="line-modified">  88   for ((Count) = 1; (Count) &lt; (Len); ++(Count))                   \</span>
<span class="line-modified">  89     {                                         \</span>
<span class="line-modified">  90       if (((Chars)[(Count)] &amp; 0xc0) != 0x80)                      \</span>
<span class="line-modified">  91     {                                     \</span>
<span class="line-modified">  92       (Result) = -1;                              \</span>
<span class="line-modified">  93       break;                                  \</span>
<span class="line-modified">  94     }                                     \</span>
<span class="line-modified">  95       (Result) &lt;&lt;= 6;                                 \</span>
<span class="line-modified">  96       (Result) |= ((Chars)[(Count)] &amp; 0x3f);                      \</span>
  97     }
  98 
  99 /*
 100  * Check whether a Unicode (5.2) char is in a valid range.
 101  *
 102  * The first check comes from the Unicode guarantee to never encode
 103  * a point above 0x0010ffff, since UTF-16 couldn&#39;t represent it.
 104  *
 105  * The second check covers surrogate pairs (category Cs).
 106  *
 107  * @param Char the character
 108  */
 109 #define UNICODE_VALID(Char)                   \
 110     ((Char) &lt; 0x110000 &amp;&amp;                     \
 111      (((Char) &amp; 0xFFFFF800) != 0xD800))
 112 
 113 
 114 static const gchar utf8_skip_data[256] = {
 115   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 116   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
</pre>
<hr />
<pre>
 120   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 121   2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
 122   3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,1,1
 123 };
 124 
 125 const gchar * const g_utf8_skip = utf8_skip_data;
 126 
 127 /**
 128  * g_utf8_find_prev_char:
 129  * @str: pointer to the beginning of a UTF-8 encoded string
 130  * @p: pointer to some position within @str
 131  *
 132  * Given a position @p with a UTF-8 encoded string @str, find the start
 133  * of the previous UTF-8 character starting before @p. Returns %NULL if no
 134  * UTF-8 characters are present in @str before @p.
 135  *
 136  * @p does not have to be at the beginning of a UTF-8 character. No check
 137  * is made to see if the character found is actually valid other than
 138  * it starts with an appropriate byte.
 139  *
<span class="line-modified"> 140  * Returns: a pointer to the found character or %NULL.</span>
 141  */
 142 gchar *
 143 g_utf8_find_prev_char (const char *str,
<span class="line-modified"> 144                const char *p)</span>
 145 {
 146   for (--p; p &gt;= str; --p)
 147     {
 148       if ((*p &amp; 0xc0) != 0x80)
<span class="line-modified"> 149     return (gchar *)p;</span>
 150     }
 151   return NULL;
 152 }
 153 
 154 /**
 155  * g_utf8_find_next_char:
 156  * @p: a pointer to a position within a UTF-8 encoded string
 157  * @end: (nullable): a pointer to the byte following the end of the string,
 158  *     or %NULL to indicate that the string is nul-terminated
 159  *
 160  * Finds the start of the next UTF-8 character in the string after @p.
 161  *
 162  * @p does not have to be at the beginning of a UTF-8 character. No check
 163  * is made to see if the character found is actually valid other than
 164  * it starts with an appropriate byte.
 165  *
 166  * If @end is %NULL, the return value will never be %NULL: if the end of the
 167  * string is reached, a pointer to the terminating nul byte is returned. If
 168  * @end is non-%NULL, the return value will be %NULL if the end of the string
 169  * is reached.
 170  *
<span class="line-modified"> 171  * Returns: (nullable): a pointer to the found character or %NULL if @end is</span>
 172  *    set and is reached
 173  */
 174 gchar *
 175 g_utf8_find_next_char (const gchar *p,
<span class="line-modified"> 176                const gchar *end)</span>
 177 {
 178   if (end)
 179     {
 180       for (++p; p &lt; end &amp;&amp; (*p &amp; 0xc0) == 0x80; ++p)
 181         ;
 182       return (p &gt;= end) ? NULL : (gchar *)p;
 183     }
 184   else
 185     {
 186       for (++p; (*p &amp; 0xc0) == 0x80; ++p)
 187         ;
 188       return (gchar *)p;
 189     }
 190 }
 191 
 192 /**
 193  * g_utf8_prev_char:
 194  * @p: a pointer to a position within a UTF-8 encoded string
 195  *
 196  * Finds the previous UTF-8 character in the string before @p.
 197  *
 198  * @p does not have to be at the beginning of a UTF-8 character. No check
 199  * is made to see if the character found is actually valid other than
 200  * it starts with an appropriate byte. If @p might be the first
 201  * character of the string, you must use g_utf8_find_prev_char() instead.
 202  *
<span class="line-modified"> 203  * Returns: a pointer to the found character</span>
 204  */
 205 gchar *
 206 g_utf8_prev_char (const gchar *p)
 207 {
 208   while (TRUE)
 209     {
 210       p--;
 211       if ((*p &amp; 0xc0) != 0x80)
<span class="line-modified"> 212     return (gchar *)p;</span>
 213     }
 214 }
 215 
 216 /**
 217  * g_utf8_strlen:
 218  * @p: pointer to the start of a UTF-8 encoded string
 219  * @max: the maximum number of bytes to examine. If @max
 220  *       is less than 0, then the string is assumed to be
 221  *       nul-terminated. If @max is 0, @p will not be examined and
 222  *       may be %NULL. If @max is greater than 0, up to @max
 223  *       bytes are examined
 224  *
 225  * Computes the length of the string in characters, not including
 226  * the terminating nul character. If the @max&#39;th byte falls in the
 227  * middle of a character, the last (partial) character is not counted.
 228  *
 229  * Returns: the length of the string in characters
 230  */
 231 glong
 232 g_utf8_strlen (const gchar *p,
</pre>
<hr />
<pre>
 259 
 260       /* only do the last len increment if we got a complete
 261        * char (don&#39;t count partial chars)
 262        */
 263       if (p - start &lt;= max)
 264         ++len;
 265     }
 266 
 267   return len;
 268 }
 269 
 270 /**
 271  * g_utf8_substring:
 272  * @str: a UTF-8 encoded string
 273  * @start_pos: a character offset within @str
 274  * @end_pos: another character offset within @str
 275  *
 276  * Copies a substring out of a UTF-8 encoded string.
 277  * The substring will contain @end_pos - @start_pos characters.
 278  *
<span class="line-modified"> 279  * Returns: a newly allocated copy of the requested</span>
 280  *     substring. Free with g_free() when no longer needed.
 281  *
 282  * Since: 2.30
 283  */
 284 gchar *
 285 g_utf8_substring (const gchar *str,
 286                   glong        start_pos,
 287                   glong        end_pos)
 288 {
 289   gchar *start, *end, *out;
 290 
 291   start = g_utf8_offset_to_pointer (str, start_pos);
 292   end = g_utf8_offset_to_pointer (start, end_pos - start_pos);
 293 
 294   out = g_malloc (end - start + 1);
 295   memcpy (out, start, end - start);
 296   out[end - start] = 0;
 297 
 298   return out;
 299 }
</pre>
<hr />
<pre>
 328 
 329 /**
 330  * g_utf8_offset_to_pointer:
 331  * @str: a UTF-8 encoded string
 332  * @offset: a character offset within @str
 333  *
 334  * Converts from an integer character offset to a pointer to a position
 335  * within the string.
 336  *
 337  * Since 2.10, this function allows to pass a negative @offset to
 338  * step backwards. It is usually worth stepping backwards from the end
 339  * instead of forwards if @offset is in the last fourth of the string,
 340  * since moving forward is about 3 times faster than moving backward.
 341  *
 342  * Note that this function doesn&#39;t abort when reaching the end of @str.
 343  * Therefore you should be sure that @offset is within string boundaries
 344  * before calling that function. Call g_utf8_strlen() when unsure.
 345  * This limitation exists as this function is called frequently during
 346  * text rendering and therefore has to be as fast as possible.
 347  *
<span class="line-modified"> 348  * Returns: the resulting pointer</span>
 349  */
 350 gchar *
 351 g_utf8_offset_to_pointer  (const gchar *str,
<span class="line-modified"> 352                glong        offset)</span>
 353 {
 354   const gchar *s = str;
 355 
 356   if (offset &gt; 0)
 357     while (offset--)
 358       s = g_utf8_next_char (s);
 359   else
 360     {
 361       const char *s1;
 362 
 363       /* This nice technique for fast backwards stepping
 364        * through a UTF-8 string was dubbed &quot;stutter stepping&quot;
 365        * by its inventor, Larry Ewing.
 366        */
 367       while (offset)
<span class="line-modified"> 368     {</span>
<span class="line-modified"> 369       s1 = s;</span>
<span class="line-modified"> 370       s += offset;</span>
<span class="line-modified"> 371       while ((*s &amp; 0xc0) == 0x80)</span>
<span class="line-modified"> 372         s--;</span>
 373 
<span class="line-modified"> 374       offset += g_utf8_pointer_to_offset (s, s1);</span>
<span class="line-modified"> 375     }</span>
 376     }
 377 
 378   return (gchar *)s;
 379 }
 380 
 381 /**
 382  * g_utf8_pointer_to_offset:
 383  * @str: a UTF-8 encoded string
 384  * @pos: a pointer to a position within @str
 385  *
<span class="line-modified"> 386  * Converts from a pointer to position within a string to a integer</span>
 387  * character offset.
 388  *
 389  * Since 2.10, this function allows @pos to be before @str, and returns
 390  * a negative offset in this case.
 391  *
 392  * Returns: the resulting character offset
 393  */
 394 glong
 395 g_utf8_pointer_to_offset (const gchar *str,
<span class="line-modified"> 396               const gchar *pos)</span>
 397 {
 398   const gchar *s = str;
 399   glong offset = 0;
 400 
 401   if (pos &lt; str)
 402     offset = - g_utf8_pointer_to_offset (pos, str);
 403   else
 404     while (s &lt; pos)
 405       {
<span class="line-modified"> 406     s = g_utf8_next_char (s);</span>
<span class="line-modified"> 407     offset++;</span>
 408       }
 409 
 410   return offset;
 411 }
 412 
 413 
 414 /**
 415  * g_utf8_strncpy:
<span class="line-modified"> 416  * @dest: buffer to fill with characters from @src</span>
 417  * @src: UTF-8 encoded string
 418  * @n: character count
 419  *
 420  * Like the standard C strncpy() function, but copies a given number
 421  * of characters instead of a given number of bytes. The @src string
 422  * must be valid UTF-8 encoded text. (Use g_utf8_validate() on all
 423  * text before trying to use UTF-8 utility functions with it.)
 424  *
 425  * Note you must ensure @dest is at least 4 * @n to fit the
 426  * largest possible UTF-8 characters
 427  *
<span class="line-modified"> 428  * Returns: @dest</span>
 429  */
 430 gchar *
 431 g_utf8_strncpy (gchar       *dest,
<span class="line-modified"> 432         const gchar *src,</span>
<span class="line-modified"> 433         gsize        n)</span>
 434 {
 435   const gchar *s = src;
 436   while (n &amp;&amp; *s)
 437     {
 438       s = g_utf8_next_char(s);
 439       n--;
 440     }
 441   strncpy(dest, src, s - src);
 442   dest[s - src] = 0;
 443   return dest;
 444 }
 445 
 446 /* unicode_strchr */
 447 
 448 /**
 449  * g_unichar_to_utf8:
 450  * @c: a Unicode character code
 451  * @outbuf: (out caller-allocates) (optional): output buffer, must have at
 452  *       least 6 bytes of space. If %NULL, the length will be computed and
 453  *       returned and nothing will be written to @outbuf.
 454  *
 455  * Converts a single character to UTF-8.
 456  *
 457  * Returns: number of bytes written
 458  */
 459 int
 460 g_unichar_to_utf8 (gunichar c,
<span class="line-modified"> 461            gchar   *outbuf)</span>
 462 {
 463   /* If this gets modified, also update the copy in g_string_insert_unichar() */
 464   guint len = 0;
 465   int first;
 466   int i;
 467 
 468   if (c &lt; 0x80)
 469     {
 470       first = 0;
 471       len = 1;
 472     }
 473   else if (c &lt; 0x800)
 474     {
 475       first = 0xc0;
 476       len = 2;
 477     }
 478   else if (c &lt; 0x10000)
 479     {
 480       first = 0xe0;
 481       len = 3;
 482     }
 483    else if (c &lt; 0x200000)
 484     {
 485       first = 0xf0;
 486       len = 4;
 487     }
 488   else if (c &lt; 0x4000000)
 489     {
 490       first = 0xf8;
 491       len = 5;
 492     }
 493   else
 494     {
 495       first = 0xfc;
 496       len = 6;
 497     }
 498 
 499   if (outbuf)
 500     {
 501       for (i = len - 1; i &gt; 0; --i)
<span class="line-modified"> 502     {</span>
<span class="line-modified"> 503       outbuf[i] = (c &amp; 0x3f) | 0x80;</span>
<span class="line-modified"> 504       c &gt;&gt;= 6;</span>
<span class="line-modified"> 505     }</span>
 506       outbuf[0] = c | first;
 507     }
 508 
 509   return len;
 510 }
 511 
 512 /**
 513  * g_utf8_strchr:
 514  * @p: a nul-terminated UTF-8 encoded string
 515  * @len: the maximum length of @p
 516  * @c: a Unicode character
 517  *
 518  * Finds the leftmost occurrence of the given Unicode character
 519  * in a UTF-8 encoded string, while limiting the search to @len bytes.
 520  * If @len is -1, allow unbounded search.
 521  *
<span class="line-modified"> 522  * Returns: %NULL if the string does not contain the character,</span>
 523  *     otherwise, a pointer to the start of the leftmost occurrence
 524  *     of the character in the string.
 525  */
 526 gchar *
 527 g_utf8_strchr (const char *p,
<span class="line-modified"> 528            gssize      len,</span>
<span class="line-modified"> 529            gunichar    c)</span>
 530 {
 531   gchar ch[10];
 532 
 533   gint charlen = g_unichar_to_utf8 (c, ch);
 534   ch[charlen] = &#39;\0&#39;;
 535 
 536   return g_strstr_len (p, len, ch);
 537 }
 538 
 539 
 540 /**
 541  * g_utf8_strrchr:
 542  * @p: a nul-terminated UTF-8 encoded string
 543  * @len: the maximum length of @p
 544  * @c: a Unicode character
 545  *
 546  * Find the rightmost occurrence of the given Unicode character
 547  * in a UTF-8 encoded string, while limiting the search to @len bytes.
 548  * If @len is -1, allow unbounded search.
 549  *
<span class="line-modified"> 550  * Returns: %NULL if the string does not contain the character,</span>
 551  *     otherwise, a pointer to the start of the rightmost occurrence
 552  *     of the character in the string.
 553  */
 554 gchar *
 555 g_utf8_strrchr (const char *p,
<span class="line-modified"> 556         gssize      len,</span>
<span class="line-modified"> 557         gunichar    c)</span>
 558 {
 559   gchar ch[10];
 560 
 561   gint charlen = g_unichar_to_utf8 (c, ch);
 562   ch[charlen] = &#39;\0&#39;;
 563 
 564   return g_strrstr_len (p, len, ch);
 565 }
 566 
 567 
 568 /* Like g_utf8_get_char, but take a maximum length
 569  * and return (gunichar)-2 on incomplete trailing character;
 570  * also check for malformed or overlong sequences
 571  * and return (gunichar)-1 in this case.
 572  */
 573 static inline gunichar
 574 g_utf8_get_char_extended (const  gchar *p,
<span class="line-modified"> 575               gssize max_len)</span>
 576 {
 577   guint i, len;
 578   gunichar min_code;
 579   gunichar wc = (guchar) *p;
 580   const gunichar partial_sequence = (gunichar) -2;
 581   const gunichar malformed_sequence = (gunichar) -1;
 582 
 583   if (wc &lt; 0x80)
 584     {
 585       return wc;
 586     }
 587   else if (G_UNLIKELY (wc &lt; 0xc0))
 588     {
 589       return malformed_sequence;
 590     }
 591   else if (wc &lt; 0xe0)
 592     {
 593       len = 2;
 594       wc &amp;= 0x1f;
 595       min_code = 1 &lt;&lt; 7;
</pre>
<hr />
<pre>
 609   else if (wc &lt; 0xfc)
 610     {
 611       len = 5;
 612       wc &amp;= 0x03;
 613       min_code = 1 &lt;&lt; 21;
 614     }
 615   else if (wc &lt; 0xfe)
 616     {
 617       len = 6;
 618       wc &amp;= 0x01;
 619       min_code = 1 &lt;&lt; 26;
 620     }
 621   else
 622     {
 623       return malformed_sequence;
 624     }
 625 
 626   if (G_UNLIKELY (max_len &gt;= 0 &amp;&amp; len &gt; max_len))
 627     {
 628       for (i = 1; i &lt; max_len; i++)
<span class="line-modified"> 629     {</span>
<span class="line-modified"> 630       if ((((guchar *)p)[i] &amp; 0xc0) != 0x80)</span>
<span class="line-modified"> 631         return malformed_sequence;</span>
<span class="line-modified"> 632     }</span>
 633       return partial_sequence;
 634     }
 635 
 636   for (i = 1; i &lt; len; ++i)
 637     {
 638       gunichar ch = ((guchar *)p)[i];
 639 
 640       if (G_UNLIKELY ((ch &amp; 0xc0) != 0x80))
<span class="line-modified"> 641     {</span>
<span class="line-modified"> 642       if (ch)</span>
<span class="line-modified"> 643         return malformed_sequence;</span>
<span class="line-modified"> 644       else</span>
<span class="line-modified"> 645         return partial_sequence;</span>
<span class="line-modified"> 646     }</span>
 647 
 648       wc &lt;&lt;= 6;
 649       wc |= (ch &amp; 0x3f);
 650     }
 651 
 652   if (G_UNLIKELY (wc &lt; min_code))
 653     return malformed_sequence;
 654 
 655   return wc;
 656 }
 657 
 658 /**
 659  * g_utf8_get_char_validated:
 660  * @p: a pointer to Unicode character encoded as UTF-8
 661  * @max_len: the maximum number of bytes to read, or -1 if @p is nul-terminated
 662  *
 663  * Convert a sequence of bytes encoded as UTF-8 to a Unicode character.
 664  * This function checks for incomplete characters, for invalid characters
 665  * such as characters that are out of the range of Unicode, and for
 666  * overlong encodings of valid characters.
 667  *
 668  * Note that g_utf8_get_char_validated() returns (gunichar)-2 if
 669  * @max_len is positive and any of the bytes in the first UTF-8 character
 670  * sequence are nul.
 671  *
 672  * Returns: the resulting character. If @p points to a partial
 673  *     sequence at the end of a string that could begin a valid
 674  *     character (or if @max_len is zero), returns (gunichar)-2;
 675  *     otherwise, if @p does not point to a valid UTF-8 encoded
 676  *     Unicode character, returns (gunichar)-1.
 677  */
 678 gunichar
 679 g_utf8_get_char_validated (const gchar *p,
<span class="line-modified"> 680                gssize       max_len)</span>
 681 {
 682   gunichar result;
 683 
 684   if (max_len == 0)
 685     return (gunichar)-2;
 686 
 687   result = g_utf8_get_char_extended (p, max_len);
 688 
 689   if (result &amp; 0x80000000)
 690     return result;
 691   else if (!UNICODE_VALID (result))
 692     return (gunichar)-1;
 693   else
 694     return result;
 695 }
 696 
 697 #define CONT_BYTE_FAST(p) ((guchar)*p++ &amp; 0x3f)
 698 
 699 /**
 700  * g_utf8_to_ucs4_fast:
 701  * @str: a UTF-8 encoded string
 702  * @len: the maximum length of @str to use, in bytes. If @len &lt; 0,
 703  *     then the string is nul-terminated.
 704  * @items_written: (out caller-allocates) (optional): location to store the
 705  *     number of characters in the result, or %NULL.
 706  *
 707  * Convert a string from UTF-8 to a 32-bit fixed width
 708  * representation as UCS-4, assuming valid UTF-8 input.
 709  * This function is roughly twice as fast as g_utf8_to_ucs4()
 710  * but does no error checking on the input. A trailing 0 character
 711  * will be added to the string after the converted text.
 712  *
<span class="line-modified"> 713  * Returns: a pointer to a newly allocated UCS-4 string.</span>
 714  *     This value must be freed with g_free().
 715  */
 716 gunichar *
 717 g_utf8_to_ucs4_fast (const gchar *str,
<span class="line-modified"> 718              glong        len,</span>
<span class="line-modified"> 719              glong       *items_written)</span>
 720 {
 721   gunichar *result;
 722   gint n_chars, i;
 723   const gchar *p;
 724 
 725   g_return_val_if_fail (str != NULL, NULL);
 726 
 727   p = str;
 728   n_chars = 0;
 729   if (len &lt; 0)
 730     {
 731       while (*p)
<span class="line-modified"> 732     {</span>
<span class="line-modified"> 733       p = g_utf8_next_char (p);</span>
<span class="line-modified"> 734       ++n_chars;</span>
<span class="line-modified"> 735     }</span>
 736     }
 737   else
 738     {
 739       while (p &lt; str + len &amp;&amp; *p)
<span class="line-modified"> 740     {</span>
<span class="line-modified"> 741       p = g_utf8_next_char (p);</span>
<span class="line-modified"> 742       ++n_chars;</span>
<span class="line-modified"> 743     }</span>
 744     }
 745 
 746   result = g_new (gunichar, n_chars + 1);
 747 
 748   p = str;
 749   for (i=0; i &lt; n_chars; i++)
 750     {
 751       guchar first = (guchar)*p++;
 752       gunichar wc;
 753 
 754       if (first &lt; 0xc0)
<span class="line-modified"> 755     {</span>
 756           /* We really hope first &lt; 0x80, but we don&#39;t want to test an
 757            * extra branch for invalid input, which this function
 758            * does not care about. Handling unexpected continuation bytes
 759            * here will do the least damage. */
<span class="line-modified"> 760       wc = first;</span>
<span class="line-modified"> 761     }</span>
 762       else
<span class="line-modified"> 763     {</span>
 764           gunichar c1 = CONT_BYTE_FAST(p);
 765           if (first &lt; 0xe0)
 766             {
 767               wc = ((first &amp; 0x1f) &lt;&lt; 6) | c1;
 768             }
 769           else
 770             {
 771               gunichar c2 = CONT_BYTE_FAST(p);
 772               if (first &lt; 0xf0)
 773                 {
 774                   wc = ((first &amp; 0x0f) &lt;&lt; 12) | (c1 &lt;&lt; 6) | c2;
 775                 }
 776               else
 777                 {
 778                   gunichar c3 = CONT_BYTE_FAST(p);
 779                   wc = ((first &amp; 0x07) &lt;&lt; 18) | (c1 &lt;&lt; 12) | (c2 &lt;&lt; 6) | c3;
 780                   if (G_UNLIKELY (first &gt;= 0xf8))
 781                     {
 782                       /* This can&#39;t be valid UTF-8, but g_utf8_next_char()
 783                        * and company allow out-of-range sequences */
 784                       gunichar mask = 1 &lt;&lt; 20;
 785                       while ((wc &amp; mask) != 0)
 786                         {
 787                           wc &lt;&lt;= 6;
 788                           wc |= CONT_BYTE_FAST(p);
 789                           mask &lt;&lt;= 5;
 790                         }
 791                       wc &amp;= mask - 1;
 792                     }
 793                 }
 794             }
<span class="line-modified"> 795     }</span>
 796       result[i] = wc;
 797     }
 798   result[i] = 0;
 799 
 800   if (items_written)
 801     *items_written = i;
 802 
 803   return result;
 804 }
 805 
 806 static gpointer
 807 try_malloc_n (gsize n_blocks, gsize n_block_bytes, GError **error)
 808 {
 809     gpointer ptr = g_try_malloc_n (n_blocks, n_block_bytes);
 810     if (ptr == NULL)
 811       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_NO_MEMORY,
 812                            _(&quot;Failed to allocate memory&quot;));
 813     return ptr;
 814 }
 815 
</pre>
<hr />
<pre>
 818  * @str: a UTF-8 encoded string
 819  * @len: the maximum length of @str to use, in bytes. If @len &lt; 0,
 820  *     then the string is nul-terminated.
 821  * @items_read: (out caller-allocates) (optional): location to store number of
 822   *    bytes read, or %NULL.
 823  *     If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will be
 824  *     returned in case @str contains a trailing partial
 825  *     character. If an error occurs then the index of the
 826  *     invalid input is stored here.
 827  * @items_written: (out caller-allocates) (optional): location to store number
 828  *     of characters written or %NULL. The value here stored does not include
 829  *     the trailing 0 character.
 830  * @error: location to store the error occurring, or %NULL to ignore
 831  *     errors. Any of the errors in #GConvertError other than
 832  *     %G_CONVERT_ERROR_NO_CONVERSION may occur.
 833  *
 834  * Convert a string from UTF-8 to a 32-bit fixed width
 835  * representation as UCS-4. A trailing 0 character will be added to the
 836  * string after the converted text.
 837  *
<span class="line-modified"> 838  * Returns: a pointer to a newly allocated UCS-4 string.</span>
 839  *     This value must be freed with g_free(). If an error occurs,
 840  *     %NULL will be returned and @error set.
 841  */
 842 gunichar *
 843 g_utf8_to_ucs4 (const gchar *str,
<span class="line-modified"> 844         glong        len,</span>
<span class="line-modified"> 845         glong       *items_read,</span>
<span class="line-modified"> 846         glong       *items_written,</span>
<span class="line-modified"> 847         GError     **error)</span>
 848 {
 849   gunichar *result = NULL;
 850   gint n_chars, i;
 851   const gchar *in;
 852 
 853   in = str;
 854   n_chars = 0;
 855   while ((len &lt; 0 || str + len - in &gt; 0) &amp;&amp; *in)
 856     {
 857       gunichar wc = g_utf8_get_char_extended (in, len &lt; 0 ? 6 : str + len - in);
 858       if (wc &amp; 0x80000000)
<span class="line-modified"> 859     {</span>
<span class="line-modified"> 860       if (wc == (gunichar)-2)</span>
<span class="line-modified"> 861         {</span>
<span class="line-modified"> 862           if (items_read)</span>
<span class="line-modified"> 863         break;</span>
<span class="line-modified"> 864           else</span>
<span class="line-modified"> 865         g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_PARTIAL_INPUT,</span>
 866                                      _(&quot;Partial character sequence at end of input&quot;));
<span class="line-modified"> 867         }</span>
<span class="line-modified"> 868       else</span>
<span class="line-modified"> 869         g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
 870                                  _(&quot;Invalid byte sequence in conversion input&quot;));
 871 
<span class="line-modified"> 872       goto err_out;</span>
<span class="line-modified"> 873     }</span>
 874 
 875       n_chars++;
 876 
 877       in = g_utf8_next_char (in);
 878     }
 879 
 880   result = try_malloc_n (n_chars + 1, sizeof (gunichar), error);
 881   if (result == NULL)
 882       goto err_out;
 883 
 884   in = str;
 885   for (i=0; i &lt; n_chars; i++)
 886     {
 887       result[i] = g_utf8_get_char (in);
 888       in = g_utf8_next_char (in);
 889     }
 890   result[i] = 0;
 891 
 892   if (items_written)
 893     *items_written = n_chars;
</pre>
<hr />
<pre>
 899   return result;
 900 }
 901 
 902 /**
 903  * g_ucs4_to_utf8:
 904  * @str: a UCS-4 encoded string
 905  * @len: the maximum length (number of characters) of @str to use.
 906  *     If @len &lt; 0, then the string is nul-terminated.
 907  * @items_read: (out caller-allocates) (optional): location to store number of
 908  *     characters read, or %NULL.
 909  * @items_written: (out caller-allocates) (optional): location to store number
 910  *     of bytes written or %NULL. The value here stored does not include the
 911  *     trailing 0 byte.
 912  * @error: location to store the error occurring, or %NULL to ignore
 913  *         errors. Any of the errors in #GConvertError other than
 914  *         %G_CONVERT_ERROR_NO_CONVERSION may occur.
 915  *
 916  * Convert a string from a 32-bit fixed width representation as UCS-4.
 917  * to UTF-8. The result will be terminated with a 0 byte.
 918  *
<span class="line-modified"> 919  * Returns: a pointer to a newly allocated UTF-8 string.</span>
 920  *     This value must be freed with g_free(). If an error occurs,
 921  *     %NULL will be returned and @error set. In that case, @items_read
 922  *     will be set to the position of the first invalid input character.
 923  */
 924 gchar *
 925 g_ucs4_to_utf8 (const gunichar *str,
<span class="line-modified"> 926         glong           len,</span>
<span class="line-modified"> 927         glong          *items_read,</span>
<span class="line-modified"> 928         glong          *items_written,</span>
<span class="line-modified"> 929         GError        **error)</span>
 930 {
 931   gint result_length;
 932   gchar *result = NULL;
 933   gchar *p;
 934   gint i;
 935 
 936   result_length = 0;
 937   for (i = 0; len &lt; 0 || i &lt; len ; i++)
 938     {
 939       if (!str[i])
<span class="line-modified"> 940     break;</span>
 941 
 942       if (str[i] &gt;= 0x80000000)
<span class="line-modified"> 943     {</span>
<span class="line-modified"> 944       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
 945                                _(&quot;Character out of range for UTF-8&quot;));
<span class="line-modified"> 946       goto err_out;</span>
<span class="line-modified"> 947     }</span>
 948 
 949       result_length += UTF8_LENGTH (str[i]);
 950     }
 951 
 952   result = try_malloc_n (result_length + 1, 1, error);
 953   if (result == NULL)
 954       goto err_out;
 955 
 956   p = result;
 957 
 958   i = 0;
 959   while (p &lt; result + result_length)
 960     p += g_unichar_to_utf8 (str[i++], p);
 961 
 962   *p = &#39;\0&#39;;
 963 
 964   if (items_written)
 965     *items_written = p - result;
 966 
 967  err_out:
</pre>
<hr />
<pre>
 986  *     of bytes written, or %NULL. The value stored here does not include the
 987  *     trailing 0 byte.
 988  * @error: location to store the error occurring, or %NULL to ignore
 989  *     errors. Any of the errors in #GConvertError other than
 990  *     %G_CONVERT_ERROR_NO_CONVERSION may occur.
 991  *
 992  * Convert a string from UTF-16 to UTF-8. The result will be
 993  * terminated with a 0 byte.
 994  *
 995  * Note that the input is expected to be already in native endianness,
 996  * an initial byte-order-mark character is not handled specially.
 997  * g_convert() can be used to convert a byte buffer of UTF-16 data of
 998  * ambiguous endianess.
 999  *
1000  * Further note that this function does not validate the result
1001  * string; it may e.g. include embedded NUL characters. The only
1002  * validation done by this function is to ensure that the input can
1003  * be correctly interpreted as UTF-16, i.e. it doesn&#39;t contain
1004  * things unpaired surrogates.
1005  *
<span class="line-modified">1006  * Returns: a pointer to a newly allocated UTF-8 string.</span>
1007  *     This value must be freed with g_free(). If an error occurs,
1008  *     %NULL will be returned and @error set.
1009  **/
1010 gchar *
1011 g_utf16_to_utf8 (const gunichar2  *str,
<span class="line-modified">1012          glong             len,</span>
<span class="line-modified">1013          glong            *items_read,</span>
<span class="line-modified">1014          glong            *items_written,</span>
<span class="line-modified">1015          GError          **error)</span>
1016 {
1017   /* This function and g_utf16_to_ucs4 are almost exactly identical -
1018    * The lines that differ are marked.
1019    */
1020   const gunichar2 *in;
1021   gchar *out;
1022   gchar *result = NULL;
1023   gint n_bytes;
1024   gunichar high_surrogate;
1025 
1026   g_return_val_if_fail (str != NULL, NULL);
1027 
1028   n_bytes = 0;
1029   in = str;
1030   high_surrogate = 0;
1031   while ((len &lt; 0 || in - str &lt; len) &amp;&amp; *in)
1032     {
1033       gunichar2 c = *in;
1034       gunichar wc;
1035 
1036       if (c &gt;= 0xdc00 &amp;&amp; c &lt; 0xe000) /* low surrogate */
<span class="line-modified">1037     {</span>
<span class="line-modified">1038       if (high_surrogate)</span>
<span class="line-modified">1039         {</span>
<span class="line-modified">1040           wc = SURROGATE_VALUE (high_surrogate, c);</span>
<span class="line-modified">1041           high_surrogate = 0;</span>
<span class="line-modified">1042         }</span>
<span class="line-modified">1043       else</span>
<span class="line-modified">1044         {</span>
<span class="line-modified">1045           g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1046                                    _(&quot;Invalid sequence in conversion input&quot;));
<span class="line-modified">1047           goto err_out;</span>
<span class="line-modified">1048         }</span>
<span class="line-modified">1049     }</span>
1050       else
<span class="line-modified">1051     {</span>
<span class="line-modified">1052       if (high_surrogate)</span>
<span class="line-modified">1053         {</span>
<span class="line-modified">1054           g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1055                                    _(&quot;Invalid sequence in conversion input&quot;));
<span class="line-modified">1056           goto err_out;</span>
<span class="line-modified">1057         }</span>
1058 
<span class="line-modified">1059       if (c &gt;= 0xd800 &amp;&amp; c &lt; 0xdc00) /* high surrogate */</span>
<span class="line-modified">1060         {</span>
<span class="line-modified">1061           high_surrogate = c;</span>
<span class="line-modified">1062           goto next1;</span>
<span class="line-modified">1063         }</span>
<span class="line-modified">1064       else</span>
<span class="line-modified">1065         wc = c;</span>
<span class="line-modified">1066     }</span>
1067 
1068       /********** DIFFERENT for UTF8/UCS4 **********/
1069       n_bytes += UTF8_LENGTH (wc);
1070 
1071     next1:
1072       in++;
1073     }
1074 
1075   if (high_surrogate &amp;&amp; !items_read)
1076     {
1077       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_PARTIAL_INPUT,
1078                            _(&quot;Partial character sequence at end of input&quot;));
1079       goto err_out;
1080     }
1081 
1082   /* At this point, everything is valid, and we just need to convert
1083    */
1084   /********** DIFFERENT for UTF8/UCS4 **********/
1085   result = try_malloc_n (n_bytes + 1, 1, error);
1086   if (result == NULL)
1087       goto err_out;
1088 
1089   high_surrogate = 0;
1090   out = result;
1091   in = str;
1092   while (out &lt; result + n_bytes)
1093     {
1094       gunichar2 c = *in;
1095       gunichar wc;
1096 
1097       if (c &gt;= 0xdc00 &amp;&amp; c &lt; 0xe000) /* low surrogate */
<span class="line-modified">1098     {</span>
<span class="line-modified">1099       wc = SURROGATE_VALUE (high_surrogate, c);</span>
<span class="line-modified">1100       high_surrogate = 0;</span>
<span class="line-modified">1101     }</span>
1102       else if (c &gt;= 0xd800 &amp;&amp; c &lt; 0xdc00) /* high surrogate */
<span class="line-modified">1103     {</span>
<span class="line-modified">1104       high_surrogate = c;</span>
<span class="line-modified">1105       goto next2;</span>
<span class="line-modified">1106     }</span>
1107       else
<span class="line-modified">1108     wc = c;</span>
1109 
1110       /********** DIFFERENT for UTF8/UCS4 **********/
1111       out += g_unichar_to_utf8 (wc, out);
1112 
1113     next2:
1114       in++;
1115     }
1116 
1117   /********** DIFFERENT for UTF8/UCS4 **********/
1118   *out = &#39;\0&#39;;
1119 
1120   if (items_written)
1121     /********** DIFFERENT for UTF8/UCS4 **********/
1122     *items_written = out - result;
1123 
1124  err_out:
1125   if (items_read)
1126     *items_read = in - str;
1127 
1128   return result;
</pre>
<hr />
<pre>
1130 
1131 /**
1132  * g_utf16_to_ucs4:
1133  * @str: a UTF-16 encoded string
1134  * @len: the maximum length (number of #gunichar2) of @str to use.
1135  *     If @len &lt; 0, then the string is nul-terminated.
1136  * @items_read: (out caller-allocates) (optional): location to store number of
1137  *     words read, or %NULL. If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will
1138  *     be returned in case @str contains a trailing partial character. If
1139  *     an error occurs then the index of the invalid input is stored here.
1140  * @items_written: (out caller-allocates) (optional): location to store number
1141  *     of characters written, or %NULL. The value stored here does not include
1142  *     the trailing 0 character.
1143  * @error: location to store the error occurring, or %NULL to ignore
1144  *     errors. Any of the errors in #GConvertError other than
1145  *     %G_CONVERT_ERROR_NO_CONVERSION may occur.
1146  *
1147  * Convert a string from UTF-16 to UCS-4. The result will be
1148  * nul-terminated.
1149  *
<span class="line-modified">1150  * Returns: a pointer to a newly allocated UCS-4 string.</span>
1151  *     This value must be freed with g_free(). If an error occurs,
1152  *     %NULL will be returned and @error set.
1153  */
1154 gunichar *
1155 g_utf16_to_ucs4 (const gunichar2  *str,
<span class="line-modified">1156          glong             len,</span>
<span class="line-modified">1157          glong            *items_read,</span>
<span class="line-modified">1158          glong            *items_written,</span>
<span class="line-modified">1159          GError          **error)</span>
1160 {
1161   const gunichar2 *in;
1162   gchar *out;
1163   gchar *result = NULL;
1164   gint n_bytes;
1165   gunichar high_surrogate;
1166 
1167   g_return_val_if_fail (str != NULL, NULL);
1168 
1169   n_bytes = 0;
1170   in = str;
1171   high_surrogate = 0;
1172   while ((len &lt; 0 || in - str &lt; len) &amp;&amp; *in)
1173     {
1174       gunichar2 c = *in;
1175 
1176       if (c &gt;= 0xdc00 &amp;&amp; c &lt; 0xe000) /* low surrogate */
<span class="line-modified">1177     {</span>
<span class="line-modified">1178       if (high_surrogate)</span>
<span class="line-modified">1179         {</span>
<span class="line-modified">1180           high_surrogate = 0;</span>
<span class="line-modified">1181         }</span>
<span class="line-modified">1182       else</span>
<span class="line-modified">1183         {</span>
<span class="line-modified">1184           g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1185                                    _(&quot;Invalid sequence in conversion input&quot;));
<span class="line-modified">1186           goto err_out;</span>
<span class="line-modified">1187         }</span>
<span class="line-modified">1188     }</span>
1189       else
<span class="line-modified">1190     {</span>
<span class="line-modified">1191       if (high_surrogate)</span>
<span class="line-modified">1192         {</span>
<span class="line-modified">1193           g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1194                                    _(&quot;Invalid sequence in conversion input&quot;));
<span class="line-modified">1195           goto err_out;</span>
<span class="line-modified">1196         }</span>
1197 
<span class="line-modified">1198       if (c &gt;= 0xd800 &amp;&amp; c &lt; 0xdc00) /* high surrogate */</span>
<span class="line-modified">1199         {</span>
<span class="line-modified">1200           high_surrogate = c;</span>
<span class="line-modified">1201           goto next1;</span>
<span class="line-modified">1202         }</span>
<span class="line-modified">1203     }</span>
1204 
1205       /********** DIFFERENT for UTF8/UCS4 **********/
1206       n_bytes += sizeof (gunichar);
1207 
1208     next1:
1209       in++;
1210     }
1211 
1212   if (high_surrogate &amp;&amp; !items_read)
1213     {
1214       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_PARTIAL_INPUT,
1215                            _(&quot;Partial character sequence at end of input&quot;));
1216       goto err_out;
1217     }
1218 
1219   /* At this point, everything is valid, and we just need to convert
1220    */
1221   /********** DIFFERENT for UTF8/UCS4 **********/
1222   result = try_malloc_n (n_bytes + 4, 1, error);
1223   if (result == NULL)
1224       goto err_out;
1225 
1226   high_surrogate = 0;
1227   out = result;
1228   in = str;
1229   while (out &lt; result + n_bytes)
1230     {
1231       gunichar2 c = *in;
1232       gunichar wc;
1233 
1234       if (c &gt;= 0xdc00 &amp;&amp; c &lt; 0xe000) /* low surrogate */
<span class="line-modified">1235     {</span>
<span class="line-modified">1236       wc = SURROGATE_VALUE (high_surrogate, c);</span>
<span class="line-modified">1237       high_surrogate = 0;</span>
<span class="line-modified">1238     }</span>
1239       else if (c &gt;= 0xd800 &amp;&amp; c &lt; 0xdc00) /* high surrogate */
<span class="line-modified">1240     {</span>
<span class="line-modified">1241       high_surrogate = c;</span>
<span class="line-modified">1242       goto next2;</span>
<span class="line-modified">1243     }</span>
1244       else
<span class="line-modified">1245     wc = c;</span>
1246 
1247       /********** DIFFERENT for UTF8/UCS4 **********/
1248       *(gunichar *)out = wc;
1249       out += sizeof (gunichar);
1250 
1251     next2:
1252       in++;
1253     }
1254 
1255   /********** DIFFERENT for UTF8/UCS4 **********/
1256   *(gunichar *)out = 0;
1257 
1258   if (items_written)
1259     /********** DIFFERENT for UTF8/UCS4 **********/
1260     *items_written = (out - result) / sizeof (gunichar);
1261 
1262  err_out:
1263   if (items_read)
1264     *items_read = in - str;
1265 
</pre>
<hr />
<pre>
1268 
1269 /**
1270  * g_utf8_to_utf16:
1271  * @str: a UTF-8 encoded string
1272  * @len: the maximum length (number of bytes) of @str to use.
1273  *     If @len &lt; 0, then the string is nul-terminated.
1274  * @items_read: (out caller-allocates) (optional): location to store number of
1275  *     bytes read, or %NULL. If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will
1276  *     be returned in case @str contains a trailing partial character. If
1277  *     an error occurs then the index of the invalid input is stored here.
1278  * @items_written: (out caller-allocates) (optional): location to store number
1279  *     of #gunichar2 written, or %NULL. The value stored here does not include
1280  *     the trailing 0.
1281  * @error: location to store the error occurring, or %NULL to ignore
1282  *     errors. Any of the errors in #GConvertError other than
1283  *     %G_CONVERT_ERROR_NO_CONVERSION may occur.
1284  *
1285  * Convert a string from UTF-8 to UTF-16. A 0 character will be
1286  * added to the result after the converted text.
1287  *
<span class="line-modified">1288  * Returns: a pointer to a newly allocated UTF-16 string.</span>
1289  *     This value must be freed with g_free(). If an error occurs,
1290  *     %NULL will be returned and @error set.
1291  */
1292 gunichar2 *
1293 g_utf8_to_utf16 (const gchar *str,
<span class="line-modified">1294          glong        len,</span>
<span class="line-modified">1295          glong       *items_read,</span>
<span class="line-modified">1296          glong       *items_written,</span>
<span class="line-modified">1297          GError     **error)</span>
1298 {
1299   gunichar2 *result = NULL;
1300   gint n16;
1301   const gchar *in;
1302   gint i;
1303 
1304   g_return_val_if_fail (str != NULL, NULL);
1305 
1306   in = str;
1307   n16 = 0;
1308   while ((len &lt; 0 || str + len - in &gt; 0) &amp;&amp; *in)
1309     {
1310       gunichar wc = g_utf8_get_char_extended (in, len &lt; 0 ? 6 : str + len - in);
1311       if (wc &amp; 0x80000000)
<span class="line-modified">1312     {</span>
<span class="line-modified">1313       if (wc == (gunichar)-2)</span>
<span class="line-modified">1314         {</span>
<span class="line-modified">1315           if (items_read)</span>
<span class="line-modified">1316         break;</span>
<span class="line-modified">1317           else</span>
<span class="line-modified">1318         g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_PARTIAL_INPUT,</span>
1319                                      _(&quot;Partial character sequence at end of input&quot;));
<span class="line-modified">1320         }</span>
<span class="line-modified">1321       else</span>
<span class="line-modified">1322         g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1323                                  _(&quot;Invalid byte sequence in conversion input&quot;));
1324 
<span class="line-modified">1325       goto err_out;</span>
<span class="line-modified">1326     }</span>
1327 
1328       if (wc &lt; 0xd800)
<span class="line-modified">1329     n16 += 1;</span>
1330       else if (wc &lt; 0xe000)
<span class="line-modified">1331     {</span>
<span class="line-modified">1332       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1333                                _(&quot;Invalid sequence in conversion input&quot;));
1334 
<span class="line-modified">1335       goto err_out;</span>
<span class="line-modified">1336     }</span>
1337       else if (wc &lt; 0x10000)
<span class="line-modified">1338     n16 += 1;</span>
1339       else if (wc &lt; 0x110000)
<span class="line-modified">1340     n16 += 2;</span>
1341       else
<span class="line-modified">1342     {</span>
<span class="line-modified">1343       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1344                                _(&quot;Character out of range for UTF-16&quot;));
1345 
<span class="line-modified">1346       goto err_out;</span>
<span class="line-modified">1347     }</span>
1348 
1349       in = g_utf8_next_char (in);
1350     }
1351 
1352   result = try_malloc_n (n16 + 1, sizeof (gunichar2), error);
1353   if (result == NULL)
1354       goto err_out;
1355 
1356   in = str;
1357   for (i = 0; i &lt; n16;)
1358     {
1359       gunichar wc = g_utf8_get_char (in);
1360 
1361       if (wc &lt; 0x10000)
<span class="line-modified">1362     {</span>
<span class="line-modified">1363       result[i++] = wc;</span>
<span class="line-modified">1364     }</span>
1365       else
<span class="line-modified">1366     {</span>
<span class="line-modified">1367       result[i++] = (wc - 0x10000) / 0x400 + 0xd800;</span>
<span class="line-modified">1368       result[i++] = (wc - 0x10000) % 0x400 + 0xdc00;</span>
<span class="line-modified">1369     }</span>
1370 
1371       in = g_utf8_next_char (in);
1372     }
1373 
1374   result[i] = 0;
1375 
1376   if (items_written)
1377     *items_written = n16;
1378 
1379  err_out:
1380   if (items_read)
1381     *items_read = in - str;
1382 
1383   return result;
1384 }
1385 
1386 /**
1387  * g_ucs4_to_utf16:
1388  * @str: a UCS-4 encoded string
1389  * @len: the maximum length (number of characters) of @str to use.
1390  *     If @len &lt; 0, then the string is nul-terminated.
1391  * @items_read: (out caller-allocates) (optional): location to store number of
1392  *     bytes read, or %NULL. If an error occurs then the index of the invalid
1393  *     input is stored here.
1394  * @items_written: (out caller-allocates) (optional): location to store number
1395  *     of #gunichar2  written, or %NULL. The value stored here does not include
1396  *     the trailing 0.
1397  * @error: location to store the error occurring, or %NULL to ignore
1398  *     errors. Any of the errors in #GConvertError other than
1399  *     %G_CONVERT_ERROR_NO_CONVERSION may occur.
1400  *
1401  * Convert a string from UCS-4 to UTF-16. A 0 character will be
1402  * added to the result after the converted text.
1403  *
<span class="line-modified">1404  * Returns: a pointer to a newly allocated UTF-16 string.</span>
1405  *     This value must be freed with g_free(). If an error occurs,
1406  *     %NULL will be returned and @error set.
1407  */
1408 gunichar2 *
1409 g_ucs4_to_utf16 (const gunichar  *str,
<span class="line-modified">1410          glong            len,</span>
<span class="line-modified">1411          glong           *items_read,</span>
<span class="line-modified">1412          glong           *items_written,</span>
<span class="line-modified">1413          GError         **error)</span>
1414 {
1415   gunichar2 *result = NULL;
1416   gint n16;
1417   gint i, j;
1418 
1419   n16 = 0;
1420   i = 0;
1421   while ((len &lt; 0 || i &lt; len) &amp;&amp; str[i])
1422     {
1423       gunichar wc = str[i];
1424 
1425       if (wc &lt; 0xd800)
<span class="line-modified">1426     n16 += 1;</span>
1427       else if (wc &lt; 0xe000)
<span class="line-modified">1428     {</span>
<span class="line-modified">1429       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1430                                _(&quot;Invalid sequence in conversion input&quot;));
1431 
<span class="line-modified">1432       goto err_out;</span>
<span class="line-modified">1433     }</span>
1434       else if (wc &lt; 0x10000)
<span class="line-modified">1435     n16 += 1;</span>
1436       else if (wc &lt; 0x110000)
<span class="line-modified">1437     n16 += 2;</span>
1438       else
<span class="line-modified">1439     {</span>
<span class="line-modified">1440       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1441                                _(&quot;Character out of range for UTF-16&quot;));
1442 
<span class="line-modified">1443       goto err_out;</span>
<span class="line-modified">1444     }</span>
1445 
1446       i++;
1447     }
1448 
1449   result = try_malloc_n (n16 + 1, sizeof (gunichar2), error);
1450   if (result == NULL)
1451       goto err_out;
1452 
1453   for (i = 0, j = 0; j &lt; n16; i++)
1454     {
1455       gunichar wc = str[i];
1456 
1457       if (wc &lt; 0x10000)
<span class="line-modified">1458     {</span>
<span class="line-modified">1459       result[j++] = wc;</span>
<span class="line-modified">1460     }</span>
1461       else
<span class="line-modified">1462     {</span>
<span class="line-modified">1463       result[j++] = (wc - 0x10000) / 0x400 + 0xd800;</span>
<span class="line-modified">1464       result[j++] = (wc - 0x10000) % 0x400 + 0xdc00;</span>
<span class="line-modified">1465     }</span>
1466     }
1467   result[j] = 0;
1468 
1469   if (items_written)
1470     *items_written = n16;
1471 
1472  err_out:
1473   if (items_read)
1474     *items_read = i;
1475 
1476   return result;
1477 }
1478 
1479 #define VALIDATE_BYTE(mask, expect)                      \
1480   G_STMT_START {                                         \
1481     if (G_UNLIKELY((*(guchar *)p &amp; (mask)) != (expect))) \
1482       goto error;                                        \
1483   } G_STMT_END
1484 
1485 /* see IETF RFC 3629 Section 4 */
1486 
1487 static const gchar *
1488 fast_validate (const char *str)
1489 
1490 {
1491   const gchar *p;
1492 
1493   for (p = str; *p; p++)
1494     {
1495       if (*(guchar *)p &lt; 128)
<span class="line-modified">1496     /* done */;</span>
1497       else
<span class="line-modified">1498     {</span>
<span class="line-modified">1499       const gchar *last;</span>
1500 
<span class="line-modified">1501       last = p;</span>
<span class="line-modified">1502       if (*(guchar *)p &lt; 0xe0) /* 110xxxxx */</span>
<span class="line-modified">1503         {</span>
<span class="line-modified">1504           if (G_UNLIKELY (*(guchar *)p &lt; 0xc2))</span>
<span class="line-modified">1505         goto error;</span>
<span class="line-modified">1506         }</span>
<span class="line-modified">1507       else</span>
<span class="line-modified">1508         {</span>
<span class="line-modified">1509           if (*(guchar *)p &lt; 0xf0) /* 1110xxxx */</span>


1510         {
<span class="line-modified">1511           switch (*(guchar *)p++ &amp; 0x0f)</span>
<span class="line-modified">1512             {</span>
<span class="line-modified">1513             case 0:</span>
<span class="line-modified">1514               VALIDATE_BYTE(0xe0, 0xa0); /* 0xa0 ... 0xbf */</span>
<span class="line-modified">1515               break;</span>
<span class="line-modified">1516             case 0x0d:</span>
<span class="line-modified">1517               VALIDATE_BYTE(0xe0, 0x80); /* 0x80 ... 0x9f */</span>
<span class="line-modified">1518               break;</span>
<span class="line-removed">1519             default:</span>
<span class="line-removed">1520               VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */</span>
<span class="line-removed">1521             }</span>
1522         }
<span class="line-modified">1523           else if (*(guchar *)p &lt; 0xf5) /* 11110xxx excluding out-of-range */</span>



1524         {
<span class="line-modified">1525           switch (*(guchar *)p++ &amp; 0x07)</span>
<span class="line-modified">1526             {</span>
<span class="line-modified">1527             case 0:</span>
<span class="line-modified">1528               VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */</span>
<span class="line-modified">1529               if (G_UNLIKELY((*(guchar *)p &amp; 0x30) == 0))</span>
<span class="line-modified">1530             goto error;</span>
<span class="line-modified">1531               break;</span>
<span class="line-modified">1532             case 4:</span>
<span class="line-modified">1533               VALIDATE_BYTE(0xf0, 0x80); /* 0x80 ... 0x8f */</span>
<span class="line-removed">1534               break;</span>
<span class="line-removed">1535             default:</span>
<span class="line-removed">1536               VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */</span>
<span class="line-removed">1537             }</span>
<span class="line-removed">1538           p++;</span>
1539           VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */
1540         }
<span class="line-removed">1541           else</span>
<span class="line-removed">1542         goto error;</span>
<span class="line-removed">1543         }</span>
<span class="line-removed">1544 </span>
1545       p++;
1546       VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */




1547 
<span class="line-modified">1548       continue;</span>

1549 
<span class="line-modified">1550     error:</span>
<span class="line-modified">1551       return last;</span>
<span class="line-modified">1552     }</span>


1553     }
1554 
1555   return p;
1556 }
1557 
1558 static const gchar *
1559 fast_validate_len (const char *str,
<span class="line-modified">1560            gssize      max_len)</span>
1561 
1562 {
1563   const gchar *p;
1564 
1565   g_assert (max_len &gt;= 0);
1566 
1567   for (p = str; ((p - str) &lt; max_len) &amp;&amp; *p; p++)
1568     {
1569       if (*(guchar *)p &lt; 128)
<span class="line-modified">1570     /* done */;</span>
1571       else
<span class="line-modified">1572     {</span>
<span class="line-modified">1573       const gchar *last;</span>
1574 
<span class="line-modified">1575       last = p;</span>
<span class="line-modified">1576       if (*(guchar *)p &lt; 0xe0) /* 110xxxxx */</span>
<span class="line-modified">1577         {</span>
<span class="line-modified">1578           if (G_UNLIKELY (max_len - (p - str) &lt; 2))</span>
<span class="line-modified">1579         goto error;</span>
1580 
<span class="line-modified">1581           if (G_UNLIKELY (*(guchar *)p &lt; 0xc2))</span>







1582         goto error;
<span class="line-removed">1583         }</span>
<span class="line-removed">1584       else</span>
<span class="line-removed">1585         {</span>
<span class="line-removed">1586           if (*(guchar *)p &lt; 0xf0) /* 1110xxxx */</span>
<span class="line-removed">1587         {</span>
<span class="line-removed">1588           if (G_UNLIKELY (max_len - (p - str) &lt; 3))</span>
<span class="line-removed">1589             goto error;</span>
1590 
<span class="line-modified">1591           switch (*(guchar *)p++ &amp; 0x0f)</span>
<span class="line-removed">1592             {</span>
<span class="line-removed">1593             case 0:</span>
<span class="line-removed">1594               VALIDATE_BYTE(0xe0, 0xa0); /* 0xa0 ... 0xbf */</span>
<span class="line-removed">1595               break;</span>
<span class="line-removed">1596             case 0x0d:</span>
<span class="line-removed">1597               VALIDATE_BYTE(0xe0, 0x80); /* 0x80 ... 0x9f */</span>
<span class="line-removed">1598               break;</span>
<span class="line-removed">1599             default:</span>
<span class="line-removed">1600               VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */</span>
<span class="line-removed">1601             }</span>
<span class="line-removed">1602         }</span>
<span class="line-removed">1603           else if (*(guchar *)p &lt; 0xf5) /* 11110xxx excluding out-of-range */</span>
1604         {
<span class="line-modified">1605           if (G_UNLIKELY (max_len - (p - str) &lt; 4))</span>
<span class="line-modified">1606             goto error;</span>
<span class="line-modified">1607 </span>
<span class="line-modified">1608           switch (*(guchar *)p++ &amp; 0x07)</span>
<span class="line-modified">1609             {</span>
<span class="line-modified">1610             case 0:</span>
<span class="line-modified">1611               VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */</span>
<span class="line-removed">1612               if (G_UNLIKELY((*(guchar *)p &amp; 0x30) == 0))</span>
<span class="line-removed">1613             goto error;</span>
<span class="line-removed">1614               break;</span>
<span class="line-removed">1615             case 4:</span>
<span class="line-removed">1616               VALIDATE_BYTE(0xf0, 0x80); /* 0x80 ... 0x8f */</span>
<span class="line-removed">1617               break;</span>
<span class="line-removed">1618             default:</span>
<span class="line-removed">1619               VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */</span>
<span class="line-removed">1620             }</span>
<span class="line-removed">1621           p++;</span>
1622           VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */
1623         }
<span class="line-modified">1624           else</span>



1625         goto error;
<span class="line-removed">1626         }</span>
1627 













1628       p++;
1629       VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */




1630 
<span class="line-modified">1631       continue;</span>

1632 
<span class="line-modified">1633     error:</span>
<span class="line-modified">1634       return last;</span>
<span class="line-modified">1635     }</span>


1636     }
1637 
1638   return p;
1639 }
1640 
1641 /**
1642  * g_utf8_validate:
1643  * @str: (array length=max_len) (element-type guint8): a pointer to character data
1644  * @max_len: max bytes to validate, or -1 to go until NUL
1645  * @end: (out) (optional) (transfer none): return location for end of valid data
1646  *
1647  * Validates UTF-8 encoded text. @str is the text to validate;
1648  * if @str is nul-terminated, then @max_len can be -1, otherwise
1649  * @max_len should be the number of bytes to validate.
1650  * If @end is non-%NULL, then the end of the valid range
1651  * will be stored there (i.e. the start of the first invalid
1652  * character if some bytes were invalid, or the end of the text
1653  * being validated otherwise).
1654  *
1655  * Note that g_utf8_validate() returns %FALSE if @max_len is
1656  * positive and any of the @max_len bytes are nul.
1657  *
1658  * Returns %TRUE if all of @str was valid. Many GLib and GTK+
1659  * routines require valid UTF-8 as input; so data read from a file
1660  * or the network should be checked with g_utf8_validate() before
1661  * doing anything else with it.
1662  *
1663  * Returns: %TRUE if the text was valid UTF-8
1664  */
1665 gboolean
1666 g_utf8_validate (const char   *str,
<span class="line-modified">1667          gssize        max_len,</span>
<span class="line-modified">1668          const gchar **end)</span>
1669 
1670 {
1671   const gchar *p;
1672 
1673   if (max_len &gt;= 0)
<span class="line-modified">1674     return _g_utf8_validate_len (str, max_len, end);</span>
1675 
<span class="line-modified">1676     p = fast_validate (str);</span>
1677 
1678   if (end)
1679     *end = p;
1680 
1681   if (*p != &#39;\0&#39;)
1682     return FALSE;
1683   else
1684     return TRUE;
1685 }
1686 
<span class="line-modified">1687 /*</span>
<span class="line-modified">1688  * _g_utf8_validate_len:</span>
1689  * @str: (array length=max_len) (element-type guint8): a pointer to character data
1690  * @max_len: max bytes to validate
1691  * @end: (out) (optional) (transfer none): return location for end of valid data
1692  *
1693  * Validates UTF-8 encoded text.
1694  *
1695  * As with g_utf8_validate(), but @max_len must be set, and hence this function
1696  * will always return %FALSE if any of the bytes of @str are nul.
1697  *
1698  * Returns: %TRUE if the text was valid UTF-8
<span class="line-modified">1699  * Since: 2.60 (backported to 2.58)</span>
1700  */
1701 gboolean
<span class="line-modified">1702 _g_utf8_validate_len (const char   *str,</span>
<span class="line-modified">1703                       gsize         max_len,</span>
<span class="line-modified">1704                       const gchar **end)</span>
1705 
1706 {
1707   const gchar *p;
1708 
<span class="line-modified">1709     p = fast_validate_len (str, max_len);</span>
1710 
1711   if (end)
1712     *end = p;
1713 
1714   if (p != str + max_len)
1715     return FALSE;
1716   else
1717     return TRUE;
1718 }
1719 
1720 /**
1721  * g_unichar_validate:
1722  * @ch: a Unicode character
1723  *
1724  * Checks whether @ch is a valid Unicode character. Some possible
1725  * integer values of @ch will not be valid. 0 is considered a valid
1726  * character, though it&#39;s normally a string terminator.
1727  *
1728  * Returns: %TRUE if @ch is a valid Unicode character
1729  **/
</pre>
<hr />
<pre>
1736 /**
1737  * g_utf8_strreverse:
1738  * @str: a UTF-8 encoded string
1739  * @len: the maximum length of @str to use, in bytes. If @len &lt; 0,
1740  *     then the string is nul-terminated.
1741  *
1742  * Reverses a UTF-8 string. @str must be valid UTF-8 encoded text.
1743  * (Use g_utf8_validate() on all text before trying to use UTF-8
1744  * utility functions with it.)
1745  *
1746  * This function is intended for programmatic uses of reversed strings.
1747  * It pays no attention to decomposed characters, combining marks, byte
1748  * order marks, directional indicators (LRM, LRO, etc) and similar
1749  * characters which might need special handling when reversing a string
1750  * for display purposes.
1751  *
1752  * Note that unlike g_strreverse(), this function returns
1753  * newly-allocated memory, which should be freed with g_free() when
1754  * no longer needed.
1755  *
<span class="line-modified">1756  * Returns: a newly-allocated string which is the reverse of @str</span>
1757  *
1758  * Since: 2.2
1759  */
1760 gchar *
1761 g_utf8_strreverse (const gchar *str,
<span class="line-modified">1762            gssize       len)</span>
1763 {
1764   gchar *r, *result;
1765   const gchar *p;
1766 
1767   if (len &lt; 0)
1768     len = strlen (str);
1769 
1770   result = g_new (gchar, len + 1);
1771   r = result + len;
1772   p = str;
1773   while (r &gt; result)
1774     {
1775       gchar *m, skip = g_utf8_skip[*(guchar*) p];
1776       r -= skip;

1777       for (m = r; skip; skip--)
1778         *m++ = *p++;
1779     }
1780   result[len] = 0;
1781 
1782   return result;
1783 }
1784 
1785 /**
1786  * g_utf8_make_valid:
1787  * @str: string to coerce into UTF-8
1788  * @len: the maximum length of @str to use, in bytes. If @len &lt; 0,
1789  *     then the string is nul-terminated.
1790  *
1791  * If the provided string is valid UTF-8, return a copy of it. If not,
1792  * return a copy in which bytes that could not be interpreted as valid Unicode
1793  * are replaced with the Unicode replacement character (U+FFFD).
1794  *
1795  * For example, this is an appropriate function to use if you have received
1796  * a string that was incorrectly declared to be UTF-8, and you need a valid
</pre>
<hr />
<pre>
1805 gchar *
1806 g_utf8_make_valid (const gchar *str,
1807                    gssize       len)
1808 {
1809   GString *string;
1810   const gchar *remainder, *invalid;
1811   gsize remaining_bytes, valid_bytes;
1812 
1813   g_return_val_if_fail (str != NULL, NULL);
1814 
1815   if (len &lt; 0)
1816     len = strlen (str);
1817 
1818   string = NULL;
1819   remainder = str;
1820   remaining_bytes = len;
1821 
1822   while (remaining_bytes != 0)
1823     {
1824       if (g_utf8_validate (remainder, remaining_bytes, &amp;invalid))
<span class="line-modified">1825     break;</span>
1826       valid_bytes = invalid - remainder;
1827 
1828       if (string == NULL)
<span class="line-modified">1829     string = g_string_sized_new (remaining_bytes);</span>
1830 
1831       g_string_append_len (string, remainder, valid_bytes);
1832       /* append U+FFFD REPLACEMENT CHARACTER */
1833       g_string_append (string, &quot;\357\277\275&quot;);
1834 
1835       remaining_bytes -= valid_bytes + 1;
1836       remainder = invalid + 1;
1837     }
1838 
1839   if (string == NULL)
1840     return g_strndup (str, len);
1841 
1842   g_string_append_len (string, remainder, remaining_bytes);
1843   g_string_append_c (string, &#39;\0&#39;);
1844 
1845   g_assert (g_utf8_validate (string-&gt;str, -1, NULL));
1846 
1847   return g_string_free (string, FALSE);
1848 }
</pre>
</td>
<td>
<hr />
<pre>
  22 #include &lt;stdlib.h&gt;
  23 #ifdef HAVE_CODESET
  24 #include &lt;langinfo.h&gt;
  25 #endif
  26 #include &lt;string.h&gt;
  27 
  28 #ifdef G_PLATFORM_WIN32
  29 #include &lt;stdio.h&gt;
  30 #define STRICT
  31 #include &lt;windows.h&gt;
  32 #undef STRICT
  33 #endif
  34 
  35 #include &quot;gconvert.h&quot;
  36 #include &quot;ghash.h&quot;
  37 #include &quot;gstrfuncs.h&quot;
  38 #include &quot;gtestutils.h&quot;
  39 #include &quot;gtypes.h&quot;
  40 #include &quot;gthread.h&quot;
  41 #include &quot;glibintl.h&quot;
<span class="line-modified">  42 </span>
<span class="line-modified">  43 #define UTF8_COMPUTE(Char, Mask, Len)               \</span>
<span class="line-modified">  44   if (Char &lt; 128)                   \</span>
<span class="line-modified">  45     {                       \</span>
<span class="line-modified">  46       Len = 1;                      \</span>
<span class="line-modified">  47       Mask = 0x7f;                    \</span>
<span class="line-modified">  48     }                       \</span>
<span class="line-modified">  49   else if ((Char &amp; 0xe0) == 0xc0)               \</span>
<span class="line-modified">  50     {                       \</span>
<span class="line-modified">  51       Len = 2;                      \</span>
<span class="line-modified">  52       Mask = 0x1f;                    \</span>
<span class="line-modified">  53     }                       \</span>
<span class="line-modified">  54   else if ((Char &amp; 0xf0) == 0xe0)               \</span>
<span class="line-modified">  55     {                       \</span>
<span class="line-modified">  56       Len = 3;                      \</span>
<span class="line-modified">  57       Mask = 0x0f;                    \</span>
<span class="line-modified">  58     }                       \</span>
<span class="line-modified">  59   else if ((Char &amp; 0xf8) == 0xf0)               \</span>
<span class="line-modified">  60     {                       \</span>
<span class="line-modified">  61       Len = 4;                      \</span>
<span class="line-modified">  62       Mask = 0x07;                    \</span>
<span class="line-modified">  63     }                       \</span>
<span class="line-modified">  64   else if ((Char &amp; 0xfc) == 0xf8)               \</span>
<span class="line-modified">  65     {                       \</span>
<span class="line-modified">  66       Len = 5;                      \</span>
<span class="line-modified">  67       Mask = 0x03;                    \</span>
<span class="line-modified">  68     }                       \</span>
<span class="line-modified">  69   else if ((Char &amp; 0xfe) == 0xfc)               \</span>
<span class="line-modified">  70     {                       \</span>
<span class="line-modified">  71       Len = 6;                      \</span>
<span class="line-modified">  72       Mask = 0x01;                    \</span>
<span class="line-modified">  73     }                       \</span>
<span class="line-modified">  74   else                        \</span>

  75     Len = -1;
  76 
  77 #define UTF8_LENGTH(Char)              \
  78   ((Char) &lt; 0x80 ? 1 :                 \
  79    ((Char) &lt; 0x800 ? 2 :               \
  80     ((Char) &lt; 0x10000 ? 3 :            \
  81      ((Char) &lt; 0x200000 ? 4 :          \
  82       ((Char) &lt; 0x4000000 ? 5 : 6)))))
  83 
  84 
<span class="line-modified">  85 #define UTF8_GET(Result, Chars, Count, Mask, Len)           \</span>
<span class="line-modified">  86   (Result) = (Chars)[0] &amp; (Mask);               \</span>
<span class="line-modified">  87   for ((Count) = 1; (Count) &lt; (Len); ++(Count))             \</span>
<span class="line-modified">  88     {                       \</span>
<span class="line-modified">  89       if (((Chars)[(Count)] &amp; 0xc0) != 0x80)              \</span>
<span class="line-modified">  90   {                     \</span>
<span class="line-modified">  91     (Result) = -1;                  \</span>
<span class="line-modified">  92     break;                    \</span>
<span class="line-modified">  93   }                     \</span>
<span class="line-modified">  94       (Result) &lt;&lt;= 6;                   \</span>
<span class="line-modified">  95       (Result) |= ((Chars)[(Count)] &amp; 0x3f);              \</span>
  96     }
  97 
  98 /*
  99  * Check whether a Unicode (5.2) char is in a valid range.
 100  *
 101  * The first check comes from the Unicode guarantee to never encode
 102  * a point above 0x0010ffff, since UTF-16 couldn&#39;t represent it.
 103  *
 104  * The second check covers surrogate pairs (category Cs).
 105  *
 106  * @param Char the character
 107  */
 108 #define UNICODE_VALID(Char)                   \
 109     ((Char) &lt; 0x110000 &amp;&amp;                     \
 110      (((Char) &amp; 0xFFFFF800) != 0xD800))
 111 
 112 
 113 static const gchar utf8_skip_data[256] = {
 114   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 115   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
</pre>
<hr />
<pre>
 119   1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 120   2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,
 121   3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,6,6,1,1
 122 };
 123 
 124 const gchar * const g_utf8_skip = utf8_skip_data;
 125 
 126 /**
 127  * g_utf8_find_prev_char:
 128  * @str: pointer to the beginning of a UTF-8 encoded string
 129  * @p: pointer to some position within @str
 130  *
 131  * Given a position @p with a UTF-8 encoded string @str, find the start
 132  * of the previous UTF-8 character starting before @p. Returns %NULL if no
 133  * UTF-8 characters are present in @str before @p.
 134  *
 135  * @p does not have to be at the beginning of a UTF-8 character. No check
 136  * is made to see if the character found is actually valid other than
 137  * it starts with an appropriate byte.
 138  *
<span class="line-modified"> 139  * Returns: (transfer none) (nullable): a pointer to the found character or %NULL.</span>
 140  */
 141 gchar *
 142 g_utf8_find_prev_char (const char *str,
<span class="line-modified"> 143            const char *p)</span>
 144 {
 145   for (--p; p &gt;= str; --p)
 146     {
 147       if ((*p &amp; 0xc0) != 0x80)
<span class="line-modified"> 148   return (gchar *)p;</span>
 149     }
 150   return NULL;
 151 }
 152 
 153 /**
 154  * g_utf8_find_next_char:
 155  * @p: a pointer to a position within a UTF-8 encoded string
 156  * @end: (nullable): a pointer to the byte following the end of the string,
 157  *     or %NULL to indicate that the string is nul-terminated
 158  *
 159  * Finds the start of the next UTF-8 character in the string after @p.
 160  *
 161  * @p does not have to be at the beginning of a UTF-8 character. No check
 162  * is made to see if the character found is actually valid other than
 163  * it starts with an appropriate byte.
 164  *
 165  * If @end is %NULL, the return value will never be %NULL: if the end of the
 166  * string is reached, a pointer to the terminating nul byte is returned. If
 167  * @end is non-%NULL, the return value will be %NULL if the end of the string
 168  * is reached.
 169  *
<span class="line-modified"> 170  * Returns: (transfer none) (nullable): a pointer to the found character or %NULL if @end is</span>
 171  *    set and is reached
 172  */
 173 gchar *
 174 g_utf8_find_next_char (const gchar *p,
<span class="line-modified"> 175            const gchar *end)</span>
 176 {
 177   if (end)
 178     {
 179       for (++p; p &lt; end &amp;&amp; (*p &amp; 0xc0) == 0x80; ++p)
 180         ;
 181       return (p &gt;= end) ? NULL : (gchar *)p;
 182     }
 183   else
 184     {
 185       for (++p; (*p &amp; 0xc0) == 0x80; ++p)
 186         ;
 187       return (gchar *)p;
 188     }
 189 }
 190 
 191 /**
 192  * g_utf8_prev_char:
 193  * @p: a pointer to a position within a UTF-8 encoded string
 194  *
 195  * Finds the previous UTF-8 character in the string before @p.
 196  *
 197  * @p does not have to be at the beginning of a UTF-8 character. No check
 198  * is made to see if the character found is actually valid other than
 199  * it starts with an appropriate byte. If @p might be the first
 200  * character of the string, you must use g_utf8_find_prev_char() instead.
 201  *
<span class="line-modified"> 202  * Returns: (transfer none) (not nullable): a pointer to the found character</span>
 203  */
 204 gchar *
 205 g_utf8_prev_char (const gchar *p)
 206 {
 207   while (TRUE)
 208     {
 209       p--;
 210       if ((*p &amp; 0xc0) != 0x80)
<span class="line-modified"> 211   return (gchar *)p;</span>
 212     }
 213 }
 214 
 215 /**
 216  * g_utf8_strlen:
 217  * @p: pointer to the start of a UTF-8 encoded string
 218  * @max: the maximum number of bytes to examine. If @max
 219  *       is less than 0, then the string is assumed to be
 220  *       nul-terminated. If @max is 0, @p will not be examined and
 221  *       may be %NULL. If @max is greater than 0, up to @max
 222  *       bytes are examined
 223  *
 224  * Computes the length of the string in characters, not including
 225  * the terminating nul character. If the @max&#39;th byte falls in the
 226  * middle of a character, the last (partial) character is not counted.
 227  *
 228  * Returns: the length of the string in characters
 229  */
 230 glong
 231 g_utf8_strlen (const gchar *p,
</pre>
<hr />
<pre>
 258 
 259       /* only do the last len increment if we got a complete
 260        * char (don&#39;t count partial chars)
 261        */
 262       if (p - start &lt;= max)
 263         ++len;
 264     }
 265 
 266   return len;
 267 }
 268 
 269 /**
 270  * g_utf8_substring:
 271  * @str: a UTF-8 encoded string
 272  * @start_pos: a character offset within @str
 273  * @end_pos: another character offset within @str
 274  *
 275  * Copies a substring out of a UTF-8 encoded string.
 276  * The substring will contain @end_pos - @start_pos characters.
 277  *
<span class="line-modified"> 278  * Returns: (transfer full): a newly allocated copy of the requested</span>
 279  *     substring. Free with g_free() when no longer needed.
 280  *
 281  * Since: 2.30
 282  */
 283 gchar *
 284 g_utf8_substring (const gchar *str,
 285                   glong        start_pos,
 286                   glong        end_pos)
 287 {
 288   gchar *start, *end, *out;
 289 
 290   start = g_utf8_offset_to_pointer (str, start_pos);
 291   end = g_utf8_offset_to_pointer (start, end_pos - start_pos);
 292 
 293   out = g_malloc (end - start + 1);
 294   memcpy (out, start, end - start);
 295   out[end - start] = 0;
 296 
 297   return out;
 298 }
</pre>
<hr />
<pre>
 327 
 328 /**
 329  * g_utf8_offset_to_pointer:
 330  * @str: a UTF-8 encoded string
 331  * @offset: a character offset within @str
 332  *
 333  * Converts from an integer character offset to a pointer to a position
 334  * within the string.
 335  *
 336  * Since 2.10, this function allows to pass a negative @offset to
 337  * step backwards. It is usually worth stepping backwards from the end
 338  * instead of forwards if @offset is in the last fourth of the string,
 339  * since moving forward is about 3 times faster than moving backward.
 340  *
 341  * Note that this function doesn&#39;t abort when reaching the end of @str.
 342  * Therefore you should be sure that @offset is within string boundaries
 343  * before calling that function. Call g_utf8_strlen() when unsure.
 344  * This limitation exists as this function is called frequently during
 345  * text rendering and therefore has to be as fast as possible.
 346  *
<span class="line-modified"> 347  * Returns: (transfer none): the resulting pointer</span>
 348  */
 349 gchar *
 350 g_utf8_offset_to_pointer  (const gchar *str,
<span class="line-modified"> 351          glong        offset)</span>
 352 {
 353   const gchar *s = str;
 354 
 355   if (offset &gt; 0)
 356     while (offset--)
 357       s = g_utf8_next_char (s);
 358   else
 359     {
 360       const char *s1;
 361 
 362       /* This nice technique for fast backwards stepping
 363        * through a UTF-8 string was dubbed &quot;stutter stepping&quot;
 364        * by its inventor, Larry Ewing.
 365        */
 366       while (offset)
<span class="line-modified"> 367   {</span>
<span class="line-modified"> 368     s1 = s;</span>
<span class="line-modified"> 369     s += offset;</span>
<span class="line-modified"> 370     while ((*s &amp; 0xc0) == 0x80)</span>
<span class="line-modified"> 371       s--;</span>
 372 
<span class="line-modified"> 373     offset += g_utf8_pointer_to_offset (s, s1);</span>
<span class="line-modified"> 374   }</span>
 375     }
 376 
 377   return (gchar *)s;
 378 }
 379 
 380 /**
 381  * g_utf8_pointer_to_offset:
 382  * @str: a UTF-8 encoded string
 383  * @pos: a pointer to a position within @str
 384  *
<span class="line-modified"> 385  * Converts from a pointer to position within a string to an integer</span>
 386  * character offset.
 387  *
 388  * Since 2.10, this function allows @pos to be before @str, and returns
 389  * a negative offset in this case.
 390  *
 391  * Returns: the resulting character offset
 392  */
 393 glong
 394 g_utf8_pointer_to_offset (const gchar *str,
<span class="line-modified"> 395         const gchar *pos)</span>
 396 {
 397   const gchar *s = str;
 398   glong offset = 0;
 399 
 400   if (pos &lt; str)
 401     offset = - g_utf8_pointer_to_offset (pos, str);
 402   else
 403     while (s &lt; pos)
 404       {
<span class="line-modified"> 405   s = g_utf8_next_char (s);</span>
<span class="line-modified"> 406   offset++;</span>
 407       }
 408 
 409   return offset;
 410 }
 411 
 412 
 413 /**
 414  * g_utf8_strncpy:
<span class="line-modified"> 415  * @dest: (transfer none): buffer to fill with characters from @src</span>
 416  * @src: UTF-8 encoded string
 417  * @n: character count
 418  *
 419  * Like the standard C strncpy() function, but copies a given number
 420  * of characters instead of a given number of bytes. The @src string
 421  * must be valid UTF-8 encoded text. (Use g_utf8_validate() on all
 422  * text before trying to use UTF-8 utility functions with it.)
 423  *
 424  * Note you must ensure @dest is at least 4 * @n to fit the
 425  * largest possible UTF-8 characters
 426  *
<span class="line-modified"> 427  * Returns: (transfer none): @dest</span>
 428  */
 429 gchar *
 430 g_utf8_strncpy (gchar       *dest,
<span class="line-modified"> 431     const gchar *src,</span>
<span class="line-modified"> 432     gsize        n)</span>
 433 {
 434   const gchar *s = src;
 435   while (n &amp;&amp; *s)
 436     {
 437       s = g_utf8_next_char(s);
 438       n--;
 439     }
 440   strncpy(dest, src, s - src);
 441   dest[s - src] = 0;
 442   return dest;
 443 }
 444 
 445 /* unicode_strchr */
 446 
 447 /**
 448  * g_unichar_to_utf8:
 449  * @c: a Unicode character code
 450  * @outbuf: (out caller-allocates) (optional): output buffer, must have at
 451  *       least 6 bytes of space. If %NULL, the length will be computed and
 452  *       returned and nothing will be written to @outbuf.
 453  *
 454  * Converts a single character to UTF-8.
 455  *
 456  * Returns: number of bytes written
 457  */
 458 int
 459 g_unichar_to_utf8 (gunichar c,
<span class="line-modified"> 460        gchar   *outbuf)</span>
 461 {
 462   /* If this gets modified, also update the copy in g_string_insert_unichar() */
 463   guint len = 0;
 464   int first;
 465   int i;
 466 
 467   if (c &lt; 0x80)
 468     {
 469       first = 0;
 470       len = 1;
 471     }
 472   else if (c &lt; 0x800)
 473     {
 474       first = 0xc0;
 475       len = 2;
 476     }
 477   else if (c &lt; 0x10000)
 478     {
 479       first = 0xe0;
 480       len = 3;
 481     }
 482    else if (c &lt; 0x200000)
 483     {
 484       first = 0xf0;
 485       len = 4;
 486     }
 487   else if (c &lt; 0x4000000)
 488     {
 489       first = 0xf8;
 490       len = 5;
 491     }
 492   else
 493     {
 494       first = 0xfc;
 495       len = 6;
 496     }
 497 
 498   if (outbuf)
 499     {
 500       for (i = len - 1; i &gt; 0; --i)
<span class="line-modified"> 501   {</span>
<span class="line-modified"> 502     outbuf[i] = (c &amp; 0x3f) | 0x80;</span>
<span class="line-modified"> 503     c &gt;&gt;= 6;</span>
<span class="line-modified"> 504   }</span>
 505       outbuf[0] = c | first;
 506     }
 507 
 508   return len;
 509 }
 510 
 511 /**
 512  * g_utf8_strchr:
 513  * @p: a nul-terminated UTF-8 encoded string
 514  * @len: the maximum length of @p
 515  * @c: a Unicode character
 516  *
 517  * Finds the leftmost occurrence of the given Unicode character
 518  * in a UTF-8 encoded string, while limiting the search to @len bytes.
 519  * If @len is -1, allow unbounded search.
 520  *
<span class="line-modified"> 521  * Returns: (transfer none) (nullable): %NULL if the string does not contain the character,</span>
 522  *     otherwise, a pointer to the start of the leftmost occurrence
 523  *     of the character in the string.
 524  */
 525 gchar *
 526 g_utf8_strchr (const char *p,
<span class="line-modified"> 527          gssize      len,</span>
<span class="line-modified"> 528          gunichar    c)</span>
 529 {
 530   gchar ch[10];
 531 
 532   gint charlen = g_unichar_to_utf8 (c, ch);
 533   ch[charlen] = &#39;\0&#39;;
 534 
 535   return g_strstr_len (p, len, ch);
 536 }
 537 
 538 
 539 /**
 540  * g_utf8_strrchr:
 541  * @p: a nul-terminated UTF-8 encoded string
 542  * @len: the maximum length of @p
 543  * @c: a Unicode character
 544  *
 545  * Find the rightmost occurrence of the given Unicode character
 546  * in a UTF-8 encoded string, while limiting the search to @len bytes.
 547  * If @len is -1, allow unbounded search.
 548  *
<span class="line-modified"> 549  * Returns: (transfer none) (nullable): %NULL if the string does not contain the character,</span>
 550  *     otherwise, a pointer to the start of the rightmost occurrence
 551  *     of the character in the string.
 552  */
 553 gchar *
 554 g_utf8_strrchr (const char *p,
<span class="line-modified"> 555     gssize      len,</span>
<span class="line-modified"> 556     gunichar    c)</span>
 557 {
 558   gchar ch[10];
 559 
 560   gint charlen = g_unichar_to_utf8 (c, ch);
 561   ch[charlen] = &#39;\0&#39;;
 562 
 563   return g_strrstr_len (p, len, ch);
 564 }
 565 
 566 
 567 /* Like g_utf8_get_char, but take a maximum length
 568  * and return (gunichar)-2 on incomplete trailing character;
 569  * also check for malformed or overlong sequences
 570  * and return (gunichar)-1 in this case.
 571  */
 572 static inline gunichar
 573 g_utf8_get_char_extended (const  gchar *p,
<span class="line-modified"> 574         gssize max_len)</span>
 575 {
 576   guint i, len;
 577   gunichar min_code;
 578   gunichar wc = (guchar) *p;
 579   const gunichar partial_sequence = (gunichar) -2;
 580   const gunichar malformed_sequence = (gunichar) -1;
 581 
 582   if (wc &lt; 0x80)
 583     {
 584       return wc;
 585     }
 586   else if (G_UNLIKELY (wc &lt; 0xc0))
 587     {
 588       return malformed_sequence;
 589     }
 590   else if (wc &lt; 0xe0)
 591     {
 592       len = 2;
 593       wc &amp;= 0x1f;
 594       min_code = 1 &lt;&lt; 7;
</pre>
<hr />
<pre>
 608   else if (wc &lt; 0xfc)
 609     {
 610       len = 5;
 611       wc &amp;= 0x03;
 612       min_code = 1 &lt;&lt; 21;
 613     }
 614   else if (wc &lt; 0xfe)
 615     {
 616       len = 6;
 617       wc &amp;= 0x01;
 618       min_code = 1 &lt;&lt; 26;
 619     }
 620   else
 621     {
 622       return malformed_sequence;
 623     }
 624 
 625   if (G_UNLIKELY (max_len &gt;= 0 &amp;&amp; len &gt; max_len))
 626     {
 627       for (i = 1; i &lt; max_len; i++)
<span class="line-modified"> 628   {</span>
<span class="line-modified"> 629     if ((((guchar *)p)[i] &amp; 0xc0) != 0x80)</span>
<span class="line-modified"> 630       return malformed_sequence;</span>
<span class="line-modified"> 631   }</span>
 632       return partial_sequence;
 633     }
 634 
 635   for (i = 1; i &lt; len; ++i)
 636     {
 637       gunichar ch = ((guchar *)p)[i];
 638 
 639       if (G_UNLIKELY ((ch &amp; 0xc0) != 0x80))
<span class="line-modified"> 640   {</span>
<span class="line-modified"> 641     if (ch)</span>
<span class="line-modified"> 642       return malformed_sequence;</span>
<span class="line-modified"> 643     else</span>
<span class="line-modified"> 644       return partial_sequence;</span>
<span class="line-modified"> 645   }</span>
 646 
 647       wc &lt;&lt;= 6;
 648       wc |= (ch &amp; 0x3f);
 649     }
 650 
 651   if (G_UNLIKELY (wc &lt; min_code))
 652     return malformed_sequence;
 653 
 654   return wc;
 655 }
 656 
 657 /**
 658  * g_utf8_get_char_validated:
 659  * @p: a pointer to Unicode character encoded as UTF-8
 660  * @max_len: the maximum number of bytes to read, or -1 if @p is nul-terminated
 661  *
 662  * Convert a sequence of bytes encoded as UTF-8 to a Unicode character.
 663  * This function checks for incomplete characters, for invalid characters
 664  * such as characters that are out of the range of Unicode, and for
 665  * overlong encodings of valid characters.
 666  *
 667  * Note that g_utf8_get_char_validated() returns (gunichar)-2 if
 668  * @max_len is positive and any of the bytes in the first UTF-8 character
 669  * sequence are nul.
 670  *
 671  * Returns: the resulting character. If @p points to a partial
 672  *     sequence at the end of a string that could begin a valid
 673  *     character (or if @max_len is zero), returns (gunichar)-2;
 674  *     otherwise, if @p does not point to a valid UTF-8 encoded
 675  *     Unicode character, returns (gunichar)-1.
 676  */
 677 gunichar
 678 g_utf8_get_char_validated (const gchar *p,
<span class="line-modified"> 679          gssize       max_len)</span>
 680 {
 681   gunichar result;
 682 
 683   if (max_len == 0)
 684     return (gunichar)-2;
 685 
 686   result = g_utf8_get_char_extended (p, max_len);
 687 
 688   if (result &amp; 0x80000000)
 689     return result;
 690   else if (!UNICODE_VALID (result))
 691     return (gunichar)-1;
 692   else
 693     return result;
 694 }
 695 
 696 #define CONT_BYTE_FAST(p) ((guchar)*p++ &amp; 0x3f)
 697 
 698 /**
 699  * g_utf8_to_ucs4_fast:
 700  * @str: a UTF-8 encoded string
 701  * @len: the maximum length of @str to use, in bytes. If @len &lt; 0,
 702  *     then the string is nul-terminated.
 703  * @items_written: (out caller-allocates) (optional): location to store the
 704  *     number of characters in the result, or %NULL.
 705  *
 706  * Convert a string from UTF-8 to a 32-bit fixed width
 707  * representation as UCS-4, assuming valid UTF-8 input.
 708  * This function is roughly twice as fast as g_utf8_to_ucs4()
 709  * but does no error checking on the input. A trailing 0 character
 710  * will be added to the string after the converted text.
 711  *
<span class="line-modified"> 712  * Returns: (transfer full): a pointer to a newly allocated UCS-4 string.</span>
 713  *     This value must be freed with g_free().
 714  */
 715 gunichar *
 716 g_utf8_to_ucs4_fast (const gchar *str,
<span class="line-modified"> 717          glong        len,</span>
<span class="line-modified"> 718          glong       *items_written)</span>
 719 {
 720   gunichar *result;
 721   gint n_chars, i;
 722   const gchar *p;
 723 
 724   g_return_val_if_fail (str != NULL, NULL);
 725 
 726   p = str;
 727   n_chars = 0;
 728   if (len &lt; 0)
 729     {
 730       while (*p)
<span class="line-modified"> 731   {</span>
<span class="line-modified"> 732     p = g_utf8_next_char (p);</span>
<span class="line-modified"> 733     ++n_chars;</span>
<span class="line-modified"> 734   }</span>
 735     }
 736   else
 737     {
 738       while (p &lt; str + len &amp;&amp; *p)
<span class="line-modified"> 739   {</span>
<span class="line-modified"> 740     p = g_utf8_next_char (p);</span>
<span class="line-modified"> 741     ++n_chars;</span>
<span class="line-modified"> 742   }</span>
 743     }
 744 
 745   result = g_new (gunichar, n_chars + 1);
 746 
 747   p = str;
 748   for (i=0; i &lt; n_chars; i++)
 749     {
 750       guchar first = (guchar)*p++;
 751       gunichar wc;
 752 
 753       if (first &lt; 0xc0)
<span class="line-modified"> 754   {</span>
 755           /* We really hope first &lt; 0x80, but we don&#39;t want to test an
 756            * extra branch for invalid input, which this function
 757            * does not care about. Handling unexpected continuation bytes
 758            * here will do the least damage. */
<span class="line-modified"> 759     wc = first;</span>
<span class="line-modified"> 760   }</span>
 761       else
<span class="line-modified"> 762   {</span>
 763           gunichar c1 = CONT_BYTE_FAST(p);
 764           if (first &lt; 0xe0)
 765             {
 766               wc = ((first &amp; 0x1f) &lt;&lt; 6) | c1;
 767             }
 768           else
 769             {
 770               gunichar c2 = CONT_BYTE_FAST(p);
 771               if (first &lt; 0xf0)
 772                 {
 773                   wc = ((first &amp; 0x0f) &lt;&lt; 12) | (c1 &lt;&lt; 6) | c2;
 774                 }
 775               else
 776                 {
 777                   gunichar c3 = CONT_BYTE_FAST(p);
 778                   wc = ((first &amp; 0x07) &lt;&lt; 18) | (c1 &lt;&lt; 12) | (c2 &lt;&lt; 6) | c3;
 779                   if (G_UNLIKELY (first &gt;= 0xf8))
 780                     {
 781                       /* This can&#39;t be valid UTF-8, but g_utf8_next_char()
 782                        * and company allow out-of-range sequences */
 783                       gunichar mask = 1 &lt;&lt; 20;
 784                       while ((wc &amp; mask) != 0)
 785                         {
 786                           wc &lt;&lt;= 6;
 787                           wc |= CONT_BYTE_FAST(p);
 788                           mask &lt;&lt;= 5;
 789                         }
 790                       wc &amp;= mask - 1;
 791                     }
 792                 }
 793             }
<span class="line-modified"> 794   }</span>
 795       result[i] = wc;
 796     }
 797   result[i] = 0;
 798 
 799   if (items_written)
 800     *items_written = i;
 801 
 802   return result;
 803 }
 804 
 805 static gpointer
 806 try_malloc_n (gsize n_blocks, gsize n_block_bytes, GError **error)
 807 {
 808     gpointer ptr = g_try_malloc_n (n_blocks, n_block_bytes);
 809     if (ptr == NULL)
 810       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_NO_MEMORY,
 811                            _(&quot;Failed to allocate memory&quot;));
 812     return ptr;
 813 }
 814 
</pre>
<hr />
<pre>
 817  * @str: a UTF-8 encoded string
 818  * @len: the maximum length of @str to use, in bytes. If @len &lt; 0,
 819  *     then the string is nul-terminated.
 820  * @items_read: (out caller-allocates) (optional): location to store number of
 821   *    bytes read, or %NULL.
 822  *     If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will be
 823  *     returned in case @str contains a trailing partial
 824  *     character. If an error occurs then the index of the
 825  *     invalid input is stored here.
 826  * @items_written: (out caller-allocates) (optional): location to store number
 827  *     of characters written or %NULL. The value here stored does not include
 828  *     the trailing 0 character.
 829  * @error: location to store the error occurring, or %NULL to ignore
 830  *     errors. Any of the errors in #GConvertError other than
 831  *     %G_CONVERT_ERROR_NO_CONVERSION may occur.
 832  *
 833  * Convert a string from UTF-8 to a 32-bit fixed width
 834  * representation as UCS-4. A trailing 0 character will be added to the
 835  * string after the converted text.
 836  *
<span class="line-modified"> 837  * Returns: (transfer full): a pointer to a newly allocated UCS-4 string.</span>
 838  *     This value must be freed with g_free(). If an error occurs,
 839  *     %NULL will be returned and @error set.
 840  */
 841 gunichar *
 842 g_utf8_to_ucs4 (const gchar *str,
<span class="line-modified"> 843     glong        len,</span>
<span class="line-modified"> 844     glong       *items_read,</span>
<span class="line-modified"> 845     glong       *items_written,</span>
<span class="line-modified"> 846     GError     **error)</span>
 847 {
 848   gunichar *result = NULL;
 849   gint n_chars, i;
 850   const gchar *in;
 851 
 852   in = str;
 853   n_chars = 0;
 854   while ((len &lt; 0 || str + len - in &gt; 0) &amp;&amp; *in)
 855     {
 856       gunichar wc = g_utf8_get_char_extended (in, len &lt; 0 ? 6 : str + len - in);
 857       if (wc &amp; 0x80000000)
<span class="line-modified"> 858   {</span>
<span class="line-modified"> 859     if (wc == (gunichar)-2)</span>
<span class="line-modified"> 860       {</span>
<span class="line-modified"> 861         if (items_read)</span>
<span class="line-modified"> 862     break;</span>
<span class="line-modified"> 863         else</span>
<span class="line-modified"> 864     g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_PARTIAL_INPUT,</span>
 865                                      _(&quot;Partial character sequence at end of input&quot;));
<span class="line-modified"> 866       }</span>
<span class="line-modified"> 867     else</span>
<span class="line-modified"> 868       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
 869                                  _(&quot;Invalid byte sequence in conversion input&quot;));
 870 
<span class="line-modified"> 871     goto err_out;</span>
<span class="line-modified"> 872   }</span>
 873 
 874       n_chars++;
 875 
 876       in = g_utf8_next_char (in);
 877     }
 878 
 879   result = try_malloc_n (n_chars + 1, sizeof (gunichar), error);
 880   if (result == NULL)
 881       goto err_out;
 882 
 883   in = str;
 884   for (i=0; i &lt; n_chars; i++)
 885     {
 886       result[i] = g_utf8_get_char (in);
 887       in = g_utf8_next_char (in);
 888     }
 889   result[i] = 0;
 890 
 891   if (items_written)
 892     *items_written = n_chars;
</pre>
<hr />
<pre>
 898   return result;
 899 }
 900 
 901 /**
 902  * g_ucs4_to_utf8:
 903  * @str: a UCS-4 encoded string
 904  * @len: the maximum length (number of characters) of @str to use.
 905  *     If @len &lt; 0, then the string is nul-terminated.
 906  * @items_read: (out caller-allocates) (optional): location to store number of
 907  *     characters read, or %NULL.
 908  * @items_written: (out caller-allocates) (optional): location to store number
 909  *     of bytes written or %NULL. The value here stored does not include the
 910  *     trailing 0 byte.
 911  * @error: location to store the error occurring, or %NULL to ignore
 912  *         errors. Any of the errors in #GConvertError other than
 913  *         %G_CONVERT_ERROR_NO_CONVERSION may occur.
 914  *
 915  * Convert a string from a 32-bit fixed width representation as UCS-4.
 916  * to UTF-8. The result will be terminated with a 0 byte.
 917  *
<span class="line-modified"> 918  * Returns: (transfer full): a pointer to a newly allocated UTF-8 string.</span>
 919  *     This value must be freed with g_free(). If an error occurs,
 920  *     %NULL will be returned and @error set. In that case, @items_read
 921  *     will be set to the position of the first invalid input character.
 922  */
 923 gchar *
 924 g_ucs4_to_utf8 (const gunichar *str,
<span class="line-modified"> 925     glong           len,</span>
<span class="line-modified"> 926     glong          *items_read,</span>
<span class="line-modified"> 927     glong          *items_written,</span>
<span class="line-modified"> 928     GError        **error)</span>
 929 {
 930   gint result_length;
 931   gchar *result = NULL;
 932   gchar *p;
 933   gint i;
 934 
 935   result_length = 0;
 936   for (i = 0; len &lt; 0 || i &lt; len ; i++)
 937     {
 938       if (!str[i])
<span class="line-modified"> 939   break;</span>
 940 
 941       if (str[i] &gt;= 0x80000000)
<span class="line-modified"> 942   {</span>
<span class="line-modified"> 943     g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
 944                                _(&quot;Character out of range for UTF-8&quot;));
<span class="line-modified"> 945     goto err_out;</span>
<span class="line-modified"> 946   }</span>
 947 
 948       result_length += UTF8_LENGTH (str[i]);
 949     }
 950 
 951   result = try_malloc_n (result_length + 1, 1, error);
 952   if (result == NULL)
 953       goto err_out;
 954 
 955   p = result;
 956 
 957   i = 0;
 958   while (p &lt; result + result_length)
 959     p += g_unichar_to_utf8 (str[i++], p);
 960 
 961   *p = &#39;\0&#39;;
 962 
 963   if (items_written)
 964     *items_written = p - result;
 965 
 966  err_out:
</pre>
<hr />
<pre>
 985  *     of bytes written, or %NULL. The value stored here does not include the
 986  *     trailing 0 byte.
 987  * @error: location to store the error occurring, or %NULL to ignore
 988  *     errors. Any of the errors in #GConvertError other than
 989  *     %G_CONVERT_ERROR_NO_CONVERSION may occur.
 990  *
 991  * Convert a string from UTF-16 to UTF-8. The result will be
 992  * terminated with a 0 byte.
 993  *
 994  * Note that the input is expected to be already in native endianness,
 995  * an initial byte-order-mark character is not handled specially.
 996  * g_convert() can be used to convert a byte buffer of UTF-16 data of
 997  * ambiguous endianess.
 998  *
 999  * Further note that this function does not validate the result
1000  * string; it may e.g. include embedded NUL characters. The only
1001  * validation done by this function is to ensure that the input can
1002  * be correctly interpreted as UTF-16, i.e. it doesn&#39;t contain
1003  * things unpaired surrogates.
1004  *
<span class="line-modified">1005  * Returns: (transfer full): a pointer to a newly allocated UTF-8 string.</span>
1006  *     This value must be freed with g_free(). If an error occurs,
1007  *     %NULL will be returned and @error set.
1008  **/
1009 gchar *
1010 g_utf16_to_utf8 (const gunichar2  *str,
<span class="line-modified">1011      glong             len,</span>
<span class="line-modified">1012      glong            *items_read,</span>
<span class="line-modified">1013      glong            *items_written,</span>
<span class="line-modified">1014      GError          **error)</span>
1015 {
1016   /* This function and g_utf16_to_ucs4 are almost exactly identical -
1017    * The lines that differ are marked.
1018    */
1019   const gunichar2 *in;
1020   gchar *out;
1021   gchar *result = NULL;
1022   gint n_bytes;
1023   gunichar high_surrogate;
1024 
1025   g_return_val_if_fail (str != NULL, NULL);
1026 
1027   n_bytes = 0;
1028   in = str;
1029   high_surrogate = 0;
1030   while ((len &lt; 0 || in - str &lt; len) &amp;&amp; *in)
1031     {
1032       gunichar2 c = *in;
1033       gunichar wc;
1034 
1035       if (c &gt;= 0xdc00 &amp;&amp; c &lt; 0xe000) /* low surrogate */
<span class="line-modified">1036   {</span>
<span class="line-modified">1037     if (high_surrogate)</span>
<span class="line-modified">1038       {</span>
<span class="line-modified">1039         wc = SURROGATE_VALUE (high_surrogate, c);</span>
<span class="line-modified">1040         high_surrogate = 0;</span>
<span class="line-modified">1041       }</span>
<span class="line-modified">1042     else</span>
<span class="line-modified">1043       {</span>
<span class="line-modified">1044         g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1045                                    _(&quot;Invalid sequence in conversion input&quot;));
<span class="line-modified">1046         goto err_out;</span>
<span class="line-modified">1047       }</span>
<span class="line-modified">1048   }</span>
1049       else
<span class="line-modified">1050   {</span>
<span class="line-modified">1051     if (high_surrogate)</span>
<span class="line-modified">1052       {</span>
<span class="line-modified">1053         g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1054                                    _(&quot;Invalid sequence in conversion input&quot;));
<span class="line-modified">1055         goto err_out;</span>
<span class="line-modified">1056       }</span>
1057 
<span class="line-modified">1058     if (c &gt;= 0xd800 &amp;&amp; c &lt; 0xdc00) /* high surrogate */</span>
<span class="line-modified">1059       {</span>
<span class="line-modified">1060         high_surrogate = c;</span>
<span class="line-modified">1061         goto next1;</span>
<span class="line-modified">1062       }</span>
<span class="line-modified">1063     else</span>
<span class="line-modified">1064       wc = c;</span>
<span class="line-modified">1065   }</span>
1066 
1067       /********** DIFFERENT for UTF8/UCS4 **********/
1068       n_bytes += UTF8_LENGTH (wc);
1069 
1070     next1:
1071       in++;
1072     }
1073 
1074   if (high_surrogate &amp;&amp; !items_read)
1075     {
1076       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_PARTIAL_INPUT,
1077                            _(&quot;Partial character sequence at end of input&quot;));
1078       goto err_out;
1079     }
1080 
1081   /* At this point, everything is valid, and we just need to convert
1082    */
1083   /********** DIFFERENT for UTF8/UCS4 **********/
1084   result = try_malloc_n (n_bytes + 1, 1, error);
1085   if (result == NULL)
1086       goto err_out;
1087 
1088   high_surrogate = 0;
1089   out = result;
1090   in = str;
1091   while (out &lt; result + n_bytes)
1092     {
1093       gunichar2 c = *in;
1094       gunichar wc;
1095 
1096       if (c &gt;= 0xdc00 &amp;&amp; c &lt; 0xe000) /* low surrogate */
<span class="line-modified">1097   {</span>
<span class="line-modified">1098     wc = SURROGATE_VALUE (high_surrogate, c);</span>
<span class="line-modified">1099     high_surrogate = 0;</span>
<span class="line-modified">1100   }</span>
1101       else if (c &gt;= 0xd800 &amp;&amp; c &lt; 0xdc00) /* high surrogate */
<span class="line-modified">1102   {</span>
<span class="line-modified">1103     high_surrogate = c;</span>
<span class="line-modified">1104     goto next2;</span>
<span class="line-modified">1105   }</span>
1106       else
<span class="line-modified">1107   wc = c;</span>
1108 
1109       /********** DIFFERENT for UTF8/UCS4 **********/
1110       out += g_unichar_to_utf8 (wc, out);
1111 
1112     next2:
1113       in++;
1114     }
1115 
1116   /********** DIFFERENT for UTF8/UCS4 **********/
1117   *out = &#39;\0&#39;;
1118 
1119   if (items_written)
1120     /********** DIFFERENT for UTF8/UCS4 **********/
1121     *items_written = out - result;
1122 
1123  err_out:
1124   if (items_read)
1125     *items_read = in - str;
1126 
1127   return result;
</pre>
<hr />
<pre>
1129 
1130 /**
1131  * g_utf16_to_ucs4:
1132  * @str: a UTF-16 encoded string
1133  * @len: the maximum length (number of #gunichar2) of @str to use.
1134  *     If @len &lt; 0, then the string is nul-terminated.
1135  * @items_read: (out caller-allocates) (optional): location to store number of
1136  *     words read, or %NULL. If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will
1137  *     be returned in case @str contains a trailing partial character. If
1138  *     an error occurs then the index of the invalid input is stored here.
1139  * @items_written: (out caller-allocates) (optional): location to store number
1140  *     of characters written, or %NULL. The value stored here does not include
1141  *     the trailing 0 character.
1142  * @error: location to store the error occurring, or %NULL to ignore
1143  *     errors. Any of the errors in #GConvertError other than
1144  *     %G_CONVERT_ERROR_NO_CONVERSION may occur.
1145  *
1146  * Convert a string from UTF-16 to UCS-4. The result will be
1147  * nul-terminated.
1148  *
<span class="line-modified">1149  * Returns: (transfer full): a pointer to a newly allocated UCS-4 string.</span>
1150  *     This value must be freed with g_free(). If an error occurs,
1151  *     %NULL will be returned and @error set.
1152  */
1153 gunichar *
1154 g_utf16_to_ucs4 (const gunichar2  *str,
<span class="line-modified">1155      glong             len,</span>
<span class="line-modified">1156      glong            *items_read,</span>
<span class="line-modified">1157      glong            *items_written,</span>
<span class="line-modified">1158      GError          **error)</span>
1159 {
1160   const gunichar2 *in;
1161   gchar *out;
1162   gchar *result = NULL;
1163   gint n_bytes;
1164   gunichar high_surrogate;
1165 
1166   g_return_val_if_fail (str != NULL, NULL);
1167 
1168   n_bytes = 0;
1169   in = str;
1170   high_surrogate = 0;
1171   while ((len &lt; 0 || in - str &lt; len) &amp;&amp; *in)
1172     {
1173       gunichar2 c = *in;
1174 
1175       if (c &gt;= 0xdc00 &amp;&amp; c &lt; 0xe000) /* low surrogate */
<span class="line-modified">1176   {</span>
<span class="line-modified">1177     if (high_surrogate)</span>
<span class="line-modified">1178       {</span>
<span class="line-modified">1179         high_surrogate = 0;</span>
<span class="line-modified">1180       }</span>
<span class="line-modified">1181     else</span>
<span class="line-modified">1182       {</span>
<span class="line-modified">1183         g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1184                                    _(&quot;Invalid sequence in conversion input&quot;));
<span class="line-modified">1185         goto err_out;</span>
<span class="line-modified">1186       }</span>
<span class="line-modified">1187   }</span>
1188       else
<span class="line-modified">1189   {</span>
<span class="line-modified">1190     if (high_surrogate)</span>
<span class="line-modified">1191       {</span>
<span class="line-modified">1192         g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1193                                    _(&quot;Invalid sequence in conversion input&quot;));
<span class="line-modified">1194         goto err_out;</span>
<span class="line-modified">1195       }</span>
1196 
<span class="line-modified">1197     if (c &gt;= 0xd800 &amp;&amp; c &lt; 0xdc00) /* high surrogate */</span>
<span class="line-modified">1198       {</span>
<span class="line-modified">1199         high_surrogate = c;</span>
<span class="line-modified">1200         goto next1;</span>
<span class="line-modified">1201       }</span>
<span class="line-modified">1202   }</span>
1203 
1204       /********** DIFFERENT for UTF8/UCS4 **********/
1205       n_bytes += sizeof (gunichar);
1206 
1207     next1:
1208       in++;
1209     }
1210 
1211   if (high_surrogate &amp;&amp; !items_read)
1212     {
1213       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_PARTIAL_INPUT,
1214                            _(&quot;Partial character sequence at end of input&quot;));
1215       goto err_out;
1216     }
1217 
1218   /* At this point, everything is valid, and we just need to convert
1219    */
1220   /********** DIFFERENT for UTF8/UCS4 **********/
1221   result = try_malloc_n (n_bytes + 4, 1, error);
1222   if (result == NULL)
1223       goto err_out;
1224 
1225   high_surrogate = 0;
1226   out = result;
1227   in = str;
1228   while (out &lt; result + n_bytes)
1229     {
1230       gunichar2 c = *in;
1231       gunichar wc;
1232 
1233       if (c &gt;= 0xdc00 &amp;&amp; c &lt; 0xe000) /* low surrogate */
<span class="line-modified">1234   {</span>
<span class="line-modified">1235     wc = SURROGATE_VALUE (high_surrogate, c);</span>
<span class="line-modified">1236     high_surrogate = 0;</span>
<span class="line-modified">1237   }</span>
1238       else if (c &gt;= 0xd800 &amp;&amp; c &lt; 0xdc00) /* high surrogate */
<span class="line-modified">1239   {</span>
<span class="line-modified">1240     high_surrogate = c;</span>
<span class="line-modified">1241     goto next2;</span>
<span class="line-modified">1242   }</span>
1243       else
<span class="line-modified">1244   wc = c;</span>
1245 
1246       /********** DIFFERENT for UTF8/UCS4 **********/
1247       *(gunichar *)out = wc;
1248       out += sizeof (gunichar);
1249 
1250     next2:
1251       in++;
1252     }
1253 
1254   /********** DIFFERENT for UTF8/UCS4 **********/
1255   *(gunichar *)out = 0;
1256 
1257   if (items_written)
1258     /********** DIFFERENT for UTF8/UCS4 **********/
1259     *items_written = (out - result) / sizeof (gunichar);
1260 
1261  err_out:
1262   if (items_read)
1263     *items_read = in - str;
1264 
</pre>
<hr />
<pre>
1267 
1268 /**
1269  * g_utf8_to_utf16:
1270  * @str: a UTF-8 encoded string
1271  * @len: the maximum length (number of bytes) of @str to use.
1272  *     If @len &lt; 0, then the string is nul-terminated.
1273  * @items_read: (out caller-allocates) (optional): location to store number of
1274  *     bytes read, or %NULL. If %NULL, then %G_CONVERT_ERROR_PARTIAL_INPUT will
1275  *     be returned in case @str contains a trailing partial character. If
1276  *     an error occurs then the index of the invalid input is stored here.
1277  * @items_written: (out caller-allocates) (optional): location to store number
1278  *     of #gunichar2 written, or %NULL. The value stored here does not include
1279  *     the trailing 0.
1280  * @error: location to store the error occurring, or %NULL to ignore
1281  *     errors. Any of the errors in #GConvertError other than
1282  *     %G_CONVERT_ERROR_NO_CONVERSION may occur.
1283  *
1284  * Convert a string from UTF-8 to UTF-16. A 0 character will be
1285  * added to the result after the converted text.
1286  *
<span class="line-modified">1287  * Returns: (transfer full): a pointer to a newly allocated UTF-16 string.</span>
1288  *     This value must be freed with g_free(). If an error occurs,
1289  *     %NULL will be returned and @error set.
1290  */
1291 gunichar2 *
1292 g_utf8_to_utf16 (const gchar *str,
<span class="line-modified">1293      glong        len,</span>
<span class="line-modified">1294      glong       *items_read,</span>
<span class="line-modified">1295      glong       *items_written,</span>
<span class="line-modified">1296      GError     **error)</span>
1297 {
1298   gunichar2 *result = NULL;
1299   gint n16;
1300   const gchar *in;
1301   gint i;
1302 
1303   g_return_val_if_fail (str != NULL, NULL);
1304 
1305   in = str;
1306   n16 = 0;
1307   while ((len &lt; 0 || str + len - in &gt; 0) &amp;&amp; *in)
1308     {
1309       gunichar wc = g_utf8_get_char_extended (in, len &lt; 0 ? 6 : str + len - in);
1310       if (wc &amp; 0x80000000)
<span class="line-modified">1311   {</span>
<span class="line-modified">1312     if (wc == (gunichar)-2)</span>
<span class="line-modified">1313       {</span>
<span class="line-modified">1314         if (items_read)</span>
<span class="line-modified">1315     break;</span>
<span class="line-modified">1316         else</span>
<span class="line-modified">1317     g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_PARTIAL_INPUT,</span>
1318                                      _(&quot;Partial character sequence at end of input&quot;));
<span class="line-modified">1319       }</span>
<span class="line-modified">1320     else</span>
<span class="line-modified">1321       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1322                                  _(&quot;Invalid byte sequence in conversion input&quot;));
1323 
<span class="line-modified">1324     goto err_out;</span>
<span class="line-modified">1325   }</span>
1326 
1327       if (wc &lt; 0xd800)
<span class="line-modified">1328   n16 += 1;</span>
1329       else if (wc &lt; 0xe000)
<span class="line-modified">1330   {</span>
<span class="line-modified">1331     g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1332                                _(&quot;Invalid sequence in conversion input&quot;));
1333 
<span class="line-modified">1334     goto err_out;</span>
<span class="line-modified">1335   }</span>
1336       else if (wc &lt; 0x10000)
<span class="line-modified">1337   n16 += 1;</span>
1338       else if (wc &lt; 0x110000)
<span class="line-modified">1339   n16 += 2;</span>
1340       else
<span class="line-modified">1341   {</span>
<span class="line-modified">1342     g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1343                                _(&quot;Character out of range for UTF-16&quot;));
1344 
<span class="line-modified">1345     goto err_out;</span>
<span class="line-modified">1346   }</span>
1347 
1348       in = g_utf8_next_char (in);
1349     }
1350 
1351   result = try_malloc_n (n16 + 1, sizeof (gunichar2), error);
1352   if (result == NULL)
1353       goto err_out;
1354 
1355   in = str;
1356   for (i = 0; i &lt; n16;)
1357     {
1358       gunichar wc = g_utf8_get_char (in);
1359 
1360       if (wc &lt; 0x10000)
<span class="line-modified">1361   {</span>
<span class="line-modified">1362     result[i++] = wc;</span>
<span class="line-modified">1363   }</span>
1364       else
<span class="line-modified">1365   {</span>
<span class="line-modified">1366     result[i++] = (wc - 0x10000) / 0x400 + 0xd800;</span>
<span class="line-modified">1367     result[i++] = (wc - 0x10000) % 0x400 + 0xdc00;</span>
<span class="line-modified">1368   }</span>
1369 
1370       in = g_utf8_next_char (in);
1371     }
1372 
1373   result[i] = 0;
1374 
1375   if (items_written)
1376     *items_written = n16;
1377 
1378  err_out:
1379   if (items_read)
1380     *items_read = in - str;
1381 
1382   return result;
1383 }
1384 
1385 /**
1386  * g_ucs4_to_utf16:
1387  * @str: a UCS-4 encoded string
1388  * @len: the maximum length (number of characters) of @str to use.
1389  *     If @len &lt; 0, then the string is nul-terminated.
1390  * @items_read: (out caller-allocates) (optional): location to store number of
1391  *     bytes read, or %NULL. If an error occurs then the index of the invalid
1392  *     input is stored here.
1393  * @items_written: (out caller-allocates) (optional): location to store number
1394  *     of #gunichar2  written, or %NULL. The value stored here does not include
1395  *     the trailing 0.
1396  * @error: location to store the error occurring, or %NULL to ignore
1397  *     errors. Any of the errors in #GConvertError other than
1398  *     %G_CONVERT_ERROR_NO_CONVERSION may occur.
1399  *
1400  * Convert a string from UCS-4 to UTF-16. A 0 character will be
1401  * added to the result after the converted text.
1402  *
<span class="line-modified">1403  * Returns: (transfer full): a pointer to a newly allocated UTF-16 string.</span>
1404  *     This value must be freed with g_free(). If an error occurs,
1405  *     %NULL will be returned and @error set.
1406  */
1407 gunichar2 *
1408 g_ucs4_to_utf16 (const gunichar  *str,
<span class="line-modified">1409      glong            len,</span>
<span class="line-modified">1410      glong           *items_read,</span>
<span class="line-modified">1411      glong           *items_written,</span>
<span class="line-modified">1412      GError         **error)</span>
1413 {
1414   gunichar2 *result = NULL;
1415   gint n16;
1416   gint i, j;
1417 
1418   n16 = 0;
1419   i = 0;
1420   while ((len &lt; 0 || i &lt; len) &amp;&amp; str[i])
1421     {
1422       gunichar wc = str[i];
1423 
1424       if (wc &lt; 0xd800)
<span class="line-modified">1425   n16 += 1;</span>
1426       else if (wc &lt; 0xe000)
<span class="line-modified">1427   {</span>
<span class="line-modified">1428     g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1429                                _(&quot;Invalid sequence in conversion input&quot;));
1430 
<span class="line-modified">1431     goto err_out;</span>
<span class="line-modified">1432   }</span>
1433       else if (wc &lt; 0x10000)
<span class="line-modified">1434   n16 += 1;</span>
1435       else if (wc &lt; 0x110000)
<span class="line-modified">1436   n16 += 2;</span>
1437       else
<span class="line-modified">1438   {</span>
<span class="line-modified">1439     g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
1440                                _(&quot;Character out of range for UTF-16&quot;));
1441 
<span class="line-modified">1442     goto err_out;</span>
<span class="line-modified">1443   }</span>
1444 
1445       i++;
1446     }
1447 
1448   result = try_malloc_n (n16 + 1, sizeof (gunichar2), error);
1449   if (result == NULL)
1450       goto err_out;
1451 
1452   for (i = 0, j = 0; j &lt; n16; i++)
1453     {
1454       gunichar wc = str[i];
1455 
1456       if (wc &lt; 0x10000)
<span class="line-modified">1457   {</span>
<span class="line-modified">1458     result[j++] = wc;</span>
<span class="line-modified">1459   }</span>
1460       else
<span class="line-modified">1461   {</span>
<span class="line-modified">1462     result[j++] = (wc - 0x10000) / 0x400 + 0xd800;</span>
<span class="line-modified">1463     result[j++] = (wc - 0x10000) % 0x400 + 0xdc00;</span>
<span class="line-modified">1464   }</span>
1465     }
1466   result[j] = 0;
1467 
1468   if (items_written)
1469     *items_written = n16;
1470 
1471  err_out:
1472   if (items_read)
1473     *items_read = i;
1474 
1475   return result;
1476 }
1477 
1478 #define VALIDATE_BYTE(mask, expect)                      \
1479   G_STMT_START {                                         \
1480     if (G_UNLIKELY((*(guchar *)p &amp; (mask)) != (expect))) \
1481       goto error;                                        \
1482   } G_STMT_END
1483 
1484 /* see IETF RFC 3629 Section 4 */
1485 
1486 static const gchar *
1487 fast_validate (const char *str)
1488 
1489 {
1490   const gchar *p;
1491 
1492   for (p = str; *p; p++)
1493     {
1494       if (*(guchar *)p &lt; 128)
<span class="line-modified">1495   /* done */;</span>
1496       else
<span class="line-modified">1497   {</span>
<span class="line-modified">1498     const gchar *last;</span>
1499 
<span class="line-modified">1500     last = p;</span>
<span class="line-modified">1501     if (*(guchar *)p &lt; 0xe0) /* 110xxxxx */</span>
<span class="line-modified">1502       {</span>
<span class="line-modified">1503         if (G_UNLIKELY (*(guchar *)p &lt; 0xc2))</span>
<span class="line-modified">1504     goto error;</span>
<span class="line-modified">1505       }</span>
<span class="line-modified">1506     else</span>
<span class="line-modified">1507       {</span>
<span class="line-modified">1508         if (*(guchar *)p &lt; 0xf0) /* 1110xxxx */</span>
<span class="line-added">1509     {</span>
<span class="line-added">1510       switch (*(guchar *)p++ &amp; 0x0f)</span>
1511         {
<span class="line-modified">1512         case 0:</span>
<span class="line-modified">1513           VALIDATE_BYTE(0xe0, 0xa0); /* 0xa0 ... 0xbf */</span>
<span class="line-modified">1514           break;</span>
<span class="line-modified">1515         case 0x0d:</span>
<span class="line-modified">1516           VALIDATE_BYTE(0xe0, 0x80); /* 0x80 ... 0x9f */</span>
<span class="line-modified">1517           break;</span>
<span class="line-modified">1518         default:</span>
<span class="line-modified">1519           VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */</span>



1520         }
<span class="line-modified">1521     }</span>
<span class="line-added">1522         else if (*(guchar *)p &lt; 0xf5) /* 11110xxx excluding out-of-range */</span>
<span class="line-added">1523     {</span>
<span class="line-added">1524       switch (*(guchar *)p++ &amp; 0x07)</span>
1525         {
<span class="line-modified">1526         case 0:</span>
<span class="line-modified">1527           VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */</span>
<span class="line-modified">1528           if (G_UNLIKELY((*(guchar *)p &amp; 0x30) == 0))</span>
<span class="line-modified">1529       goto error;</span>
<span class="line-modified">1530           break;</span>
<span class="line-modified">1531         case 4:</span>
<span class="line-modified">1532           VALIDATE_BYTE(0xf0, 0x80); /* 0x80 ... 0x8f */</span>
<span class="line-modified">1533           break;</span>
<span class="line-modified">1534         default:</span>





1535           VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */
1536         }




1537       p++;
1538       VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */
<span class="line-added">1539     }</span>
<span class="line-added">1540         else</span>
<span class="line-added">1541     goto error;</span>
<span class="line-added">1542       }</span>
1543 
<span class="line-modified">1544     p++;</span>
<span class="line-added">1545     VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */</span>
1546 
<span class="line-modified">1547     continue;</span>
<span class="line-modified">1548 </span>
<span class="line-modified">1549   error:</span>
<span class="line-added">1550     return last;</span>
<span class="line-added">1551   }</span>
1552     }
1553 
1554   return p;
1555 }
1556 
1557 static const gchar *
1558 fast_validate_len (const char *str,
<span class="line-modified">1559        gssize      max_len)</span>
1560 
1561 {
1562   const gchar *p;
1563 
1564   g_assert (max_len &gt;= 0);
1565 
1566   for (p = str; ((p - str) &lt; max_len) &amp;&amp; *p; p++)
1567     {
1568       if (*(guchar *)p &lt; 128)
<span class="line-modified">1569   /* done */;</span>
1570       else
<span class="line-modified">1571   {</span>
<span class="line-modified">1572     const gchar *last;</span>
1573 
<span class="line-modified">1574     last = p;</span>
<span class="line-modified">1575     if (*(guchar *)p &lt; 0xe0) /* 110xxxxx */</span>
<span class="line-modified">1576       {</span>
<span class="line-modified">1577         if (G_UNLIKELY (max_len - (p - str) &lt; 2))</span>
<span class="line-modified">1578     goto error;</span>
1579 
<span class="line-modified">1580         if (G_UNLIKELY (*(guchar *)p &lt; 0xc2))</span>
<span class="line-added">1581     goto error;</span>
<span class="line-added">1582       }</span>
<span class="line-added">1583     else</span>
<span class="line-added">1584       {</span>
<span class="line-added">1585         if (*(guchar *)p &lt; 0xf0) /* 1110xxxx */</span>
<span class="line-added">1586     {</span>
<span class="line-added">1587       if (G_UNLIKELY (max_len - (p - str) &lt; 3))</span>
1588         goto error;







1589 
<span class="line-modified">1590       switch (*(guchar *)p++ &amp; 0x0f)</span>












1591         {
<span class="line-modified">1592         case 0:</span>
<span class="line-modified">1593           VALIDATE_BYTE(0xe0, 0xa0); /* 0xa0 ... 0xbf */</span>
<span class="line-modified">1594           break;</span>
<span class="line-modified">1595         case 0x0d:</span>
<span class="line-modified">1596           VALIDATE_BYTE(0xe0, 0x80); /* 0x80 ... 0x9f */</span>
<span class="line-modified">1597           break;</span>
<span class="line-modified">1598         default:</span>










1599           VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */
1600         }
<span class="line-modified">1601     }</span>
<span class="line-added">1602         else if (*(guchar *)p &lt; 0xf5) /* 11110xxx excluding out-of-range */</span>
<span class="line-added">1603     {</span>
<span class="line-added">1604       if (G_UNLIKELY (max_len - (p - str) &lt; 4))</span>
1605         goto error;

1606 
<span class="line-added">1607       switch (*(guchar *)p++ &amp; 0x07)</span>
<span class="line-added">1608         {</span>
<span class="line-added">1609         case 0:</span>
<span class="line-added">1610           VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */</span>
<span class="line-added">1611           if (G_UNLIKELY((*(guchar *)p &amp; 0x30) == 0))</span>
<span class="line-added">1612       goto error;</span>
<span class="line-added">1613           break;</span>
<span class="line-added">1614         case 4:</span>
<span class="line-added">1615           VALIDATE_BYTE(0xf0, 0x80); /* 0x80 ... 0x8f */</span>
<span class="line-added">1616           break;</span>
<span class="line-added">1617         default:</span>
<span class="line-added">1618           VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */</span>
<span class="line-added">1619         }</span>
1620       p++;
1621       VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */
<span class="line-added">1622     }</span>
<span class="line-added">1623         else</span>
<span class="line-added">1624     goto error;</span>
<span class="line-added">1625       }</span>
1626 
<span class="line-modified">1627     p++;</span>
<span class="line-added">1628     VALIDATE_BYTE(0xc0, 0x80); /* 10xxxxxx */</span>
1629 
<span class="line-modified">1630     continue;</span>
<span class="line-modified">1631 </span>
<span class="line-modified">1632   error:</span>
<span class="line-added">1633     return last;</span>
<span class="line-added">1634   }</span>
1635     }
1636 
1637   return p;
1638 }
1639 
1640 /**
1641  * g_utf8_validate:
1642  * @str: (array length=max_len) (element-type guint8): a pointer to character data
1643  * @max_len: max bytes to validate, or -1 to go until NUL
1644  * @end: (out) (optional) (transfer none): return location for end of valid data
1645  *
1646  * Validates UTF-8 encoded text. @str is the text to validate;
1647  * if @str is nul-terminated, then @max_len can be -1, otherwise
1648  * @max_len should be the number of bytes to validate.
1649  * If @end is non-%NULL, then the end of the valid range
1650  * will be stored there (i.e. the start of the first invalid
1651  * character if some bytes were invalid, or the end of the text
1652  * being validated otherwise).
1653  *
1654  * Note that g_utf8_validate() returns %FALSE if @max_len is
1655  * positive and any of the @max_len bytes are nul.
1656  *
1657  * Returns %TRUE if all of @str was valid. Many GLib and GTK+
1658  * routines require valid UTF-8 as input; so data read from a file
1659  * or the network should be checked with g_utf8_validate() before
1660  * doing anything else with it.
1661  *
1662  * Returns: %TRUE if the text was valid UTF-8
1663  */
1664 gboolean
1665 g_utf8_validate (const char   *str,
<span class="line-modified">1666      gssize        max_len,</span>
<span class="line-modified">1667      const gchar **end)</span>
1668 
1669 {
1670   const gchar *p;
1671 
1672   if (max_len &gt;= 0)
<span class="line-modified">1673     return g_utf8_validate_len (str, max_len, end);</span>
1674 
<span class="line-modified">1675   p = fast_validate (str);</span>
1676 
1677   if (end)
1678     *end = p;
1679 
1680   if (*p != &#39;\0&#39;)
1681     return FALSE;
1682   else
1683     return TRUE;
1684 }
1685 
<span class="line-modified">1686 /**</span>
<span class="line-modified">1687  * g_utf8_validate_len:</span>
1688  * @str: (array length=max_len) (element-type guint8): a pointer to character data
1689  * @max_len: max bytes to validate
1690  * @end: (out) (optional) (transfer none): return location for end of valid data
1691  *
1692  * Validates UTF-8 encoded text.
1693  *
1694  * As with g_utf8_validate(), but @max_len must be set, and hence this function
1695  * will always return %FALSE if any of the bytes of @str are nul.
1696  *
1697  * Returns: %TRUE if the text was valid UTF-8
<span class="line-modified">1698  * Since: 2.60</span>
1699  */
1700 gboolean
<span class="line-modified">1701 g_utf8_validate_len (const char   *str,</span>
<span class="line-modified">1702                      gsize         max_len,</span>
<span class="line-modified">1703                      const gchar **end)</span>
1704 
1705 {
1706   const gchar *p;
1707 
<span class="line-modified">1708   p = fast_validate_len (str, max_len);</span>
1709 
1710   if (end)
1711     *end = p;
1712 
1713   if (p != str + max_len)
1714     return FALSE;
1715   else
1716     return TRUE;
1717 }
1718 
1719 /**
1720  * g_unichar_validate:
1721  * @ch: a Unicode character
1722  *
1723  * Checks whether @ch is a valid Unicode character. Some possible
1724  * integer values of @ch will not be valid. 0 is considered a valid
1725  * character, though it&#39;s normally a string terminator.
1726  *
1727  * Returns: %TRUE if @ch is a valid Unicode character
1728  **/
</pre>
<hr />
<pre>
1735 /**
1736  * g_utf8_strreverse:
1737  * @str: a UTF-8 encoded string
1738  * @len: the maximum length of @str to use, in bytes. If @len &lt; 0,
1739  *     then the string is nul-terminated.
1740  *
1741  * Reverses a UTF-8 string. @str must be valid UTF-8 encoded text.
1742  * (Use g_utf8_validate() on all text before trying to use UTF-8
1743  * utility functions with it.)
1744  *
1745  * This function is intended for programmatic uses of reversed strings.
1746  * It pays no attention to decomposed characters, combining marks, byte
1747  * order marks, directional indicators (LRM, LRO, etc) and similar
1748  * characters which might need special handling when reversing a string
1749  * for display purposes.
1750  *
1751  * Note that unlike g_strreverse(), this function returns
1752  * newly-allocated memory, which should be freed with g_free() when
1753  * no longer needed.
1754  *
<span class="line-modified">1755  * Returns: (transfer full): a newly-allocated string which is the reverse of @str</span>
1756  *
1757  * Since: 2.2
1758  */
1759 gchar *
1760 g_utf8_strreverse (const gchar *str,
<span class="line-modified">1761        gssize       len)</span>
1762 {
1763   gchar *r, *result;
1764   const gchar *p;
1765 
1766   if (len &lt; 0)
1767     len = strlen (str);
1768 
1769   result = g_new (gchar, len + 1);
1770   r = result + len;
1771   p = str;
1772   while (r &gt; result)
1773     {
1774       gchar *m, skip = g_utf8_skip[*(guchar*) p];
1775       r -= skip;
<span class="line-added">1776       g_assert (r &gt;= result);</span>
1777       for (m = r; skip; skip--)
1778         *m++ = *p++;
1779     }
1780   result[len] = 0;
1781 
1782   return result;
1783 }
1784 
1785 /**
1786  * g_utf8_make_valid:
1787  * @str: string to coerce into UTF-8
1788  * @len: the maximum length of @str to use, in bytes. If @len &lt; 0,
1789  *     then the string is nul-terminated.
1790  *
1791  * If the provided string is valid UTF-8, return a copy of it. If not,
1792  * return a copy in which bytes that could not be interpreted as valid Unicode
1793  * are replaced with the Unicode replacement character (U+FFFD).
1794  *
1795  * For example, this is an appropriate function to use if you have received
1796  * a string that was incorrectly declared to be UTF-8, and you need a valid
</pre>
<hr />
<pre>
1805 gchar *
1806 g_utf8_make_valid (const gchar *str,
1807                    gssize       len)
1808 {
1809   GString *string;
1810   const gchar *remainder, *invalid;
1811   gsize remaining_bytes, valid_bytes;
1812 
1813   g_return_val_if_fail (str != NULL, NULL);
1814 
1815   if (len &lt; 0)
1816     len = strlen (str);
1817 
1818   string = NULL;
1819   remainder = str;
1820   remaining_bytes = len;
1821 
1822   while (remaining_bytes != 0)
1823     {
1824       if (g_utf8_validate (remainder, remaining_bytes, &amp;invalid))
<span class="line-modified">1825   break;</span>
1826       valid_bytes = invalid - remainder;
1827 
1828       if (string == NULL)
<span class="line-modified">1829   string = g_string_sized_new (remaining_bytes);</span>
1830 
1831       g_string_append_len (string, remainder, valid_bytes);
1832       /* append U+FFFD REPLACEMENT CHARACTER */
1833       g_string_append (string, &quot;\357\277\275&quot;);
1834 
1835       remaining_bytes -= valid_bytes + 1;
1836       remainder = invalid + 1;
1837     }
1838 
1839   if (string == NULL)
1840     return g_strndup (str, len);
1841 
1842   g_string_append_len (string, remainder, remaining_bytes);
1843   g_string_append_c (string, &#39;\0&#39;);
1844 
1845   g_assert (g_utf8_validate (string-&gt;str, -1, NULL));
1846 
1847   return g_string_free (string, FALSE);
1848 }
</pre>
</td>
</tr>
</table>
<center><a href="gurifuncs.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gutils.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>