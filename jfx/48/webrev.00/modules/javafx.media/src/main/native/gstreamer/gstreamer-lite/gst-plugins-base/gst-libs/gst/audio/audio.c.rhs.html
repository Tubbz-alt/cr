<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/audio.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* GStreamer
  2  * Copyright (C) &lt;1999&gt; Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public
 15  * License along with this library; if not, write to the
 16  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 /**
 20  * SECTION:gstaudio
 21  * @title: GstAudio
 22  * @short_description: Support library for audio elements
 23  *
 24  * This library contains some helper functions for audio elements.
 25  */
 26 
 27 #ifdef HAVE_CONFIG_H
 28 #  include &quot;config.h&quot;
 29 #endif
 30 
 31 #include &lt;string.h&gt;
 32 
 33 #include &quot;audio.h&quot;
 34 #include &quot;audio-enumtypes.h&quot;
 35 
 36 #ifndef GST_DISABLE_GST_DEBUG
 37 #define GST_CAT_DEFAULT ensure_debug_category()
 38 static GstDebugCategory *
 39 ensure_debug_category (void)
 40 {
 41   static gsize cat_gonce = 0;
 42 
 43   if (g_once_init_enter (&amp;cat_gonce)) {
 44     gsize cat_done;
 45 
 46     cat_done = (gsize) _gst_debug_category_new (&quot;audio&quot;, 0, &quot;audio library&quot;);
 47 
 48     g_once_init_leave (&amp;cat_gonce, cat_done);
 49   }
 50 
 51   return (GstDebugCategory *) cat_gonce;
 52 }
 53 #else
 54 #define ensure_debug_category() /* NOOP */
 55 #endif /* GST_DISABLE_GST_DEBUG */
 56 
 57 
 58 /**
 59  * gst_audio_buffer_clip:
 60  * @buffer: (transfer full): The buffer to clip.
 61  * @segment: Segment in %GST_FORMAT_TIME or %GST_FORMAT_DEFAULT to which
 62  *           the buffer should be clipped.
 63  * @rate: sample rate.
 64  * @bpf: size of one audio frame in bytes. This is the size of one sample *
 65  * number of channels.
 66  *
 67  * Clip the buffer to the given %GstSegment.
 68  *
 69  * After calling this function the caller does not own a reference to
 70  * @buffer anymore.
 71  *
 72  * Returns: (transfer full): %NULL if the buffer is completely outside the configured segment,
 73  * otherwise the clipped buffer is returned.
 74  *
 75  * If the buffer has no timestamp, it is assumed to be inside the segment and
 76  * is not clipped
 77  */
 78 GstBuffer *
 79 gst_audio_buffer_clip (GstBuffer * buffer, const GstSegment * segment,
 80     gint rate, gint bpf)
 81 {
 82   GstBuffer *ret;
<a name="1" id="anc1"></a><span class="line-added"> 83   GstAudioMeta *meta;</span>
 84   GstClockTime timestamp = GST_CLOCK_TIME_NONE, duration = GST_CLOCK_TIME_NONE;
 85   guint64 offset = GST_BUFFER_OFFSET_NONE, offset_end = GST_BUFFER_OFFSET_NONE;
 86   gsize trim, size, osize;
 87   gboolean change_duration = TRUE, change_offset = TRUE, change_offset_end =
 88       TRUE;
 89 
 90   g_return_val_if_fail (segment-&gt;format == GST_FORMAT_TIME ||
 91       segment-&gt;format == GST_FORMAT_DEFAULT, buffer);
 92   g_return_val_if_fail (GST_IS_BUFFER (buffer), NULL);
 93 
 94   if (!GST_BUFFER_TIMESTAMP_IS_VALID (buffer))
 95     /* No timestamp - assume the buffer is completely in the segment */
 96     return buffer;
 97 
 98   /* Get copies of the buffer metadata to change later.
 99    * Calculate the missing values for the calculations,
100    * they won&#39;t be changed later though. */
101 
<a name="2" id="anc2"></a><span class="line-added">102   meta = gst_buffer_get_audio_meta (buffer);</span>
<span class="line-added">103 </span>
<span class="line-added">104   /* these variables measure samples */</span>
105   trim = 0;
<a name="3" id="anc3"></a><span class="line-modified">106   osize = size = meta ? meta-&gt;samples : (gst_buffer_get_size (buffer) / bpf);</span>
107 
108   /* no data, nothing to clip */
109   if (!size)
110     return buffer;
111 
112   timestamp = GST_BUFFER_TIMESTAMP (buffer);
113   GST_DEBUG (&quot;timestamp %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (timestamp));
114   if (GST_BUFFER_DURATION_IS_VALID (buffer)) {
115     duration = GST_BUFFER_DURATION (buffer);
116   } else {
117     change_duration = FALSE;
<a name="4" id="anc4"></a><span class="line-modified">118     duration = gst_util_uint64_scale (size, GST_SECOND, rate);</span>
119   }
120 
121   if (GST_BUFFER_OFFSET_IS_VALID (buffer)) {
122     offset = GST_BUFFER_OFFSET (buffer);
123   } else {
124     change_offset = FALSE;
125     offset = 0;
126   }
127 
128   if (GST_BUFFER_OFFSET_END_IS_VALID (buffer)) {
129     offset_end = GST_BUFFER_OFFSET_END (buffer);
130   } else {
131     change_offset_end = FALSE;
<a name="5" id="anc5"></a><span class="line-modified">132     offset_end = offset + size;</span>
133   }
134 
135   if (segment-&gt;format == GST_FORMAT_TIME) {
136     /* Handle clipping for GST_FORMAT_TIME */
137 
138     guint64 start, stop, cstart, cstop, diff;
139 
140     start = timestamp;
141     stop = timestamp + duration;
142 
143     if (gst_segment_clip (segment, GST_FORMAT_TIME,
144             start, stop, &amp;cstart, &amp;cstop)) {
145 
146       diff = cstart - start;
147       if (diff &gt; 0) {
148         timestamp = cstart;
149 
150         if (change_duration)
151           duration -= diff;
152 
153         diff = gst_util_uint64_scale (diff, rate, GST_SECOND);
154         if (change_offset)
155           offset += diff;
<a name="6" id="anc6"></a><span class="line-modified">156         trim += diff;</span>
<span class="line-modified">157         size -= diff;</span>
158       }
159 
160       diff = stop - cstop;
161       if (diff &gt; 0) {
162         /* duration is always valid if stop is valid */
163         duration -= diff;
164 
165         diff = gst_util_uint64_scale (diff, rate, GST_SECOND);
166         if (change_offset_end)
167           offset_end -= diff;
<a name="7" id="anc7"></a><span class="line-modified">168         size -= diff;</span>
169       }
170     } else {
171       gst_buffer_unref (buffer);
172       return NULL;
173     }
174   } else {
175     /* Handle clipping for GST_FORMAT_DEFAULT */
176     guint64 start, stop, cstart, cstop, diff;
177 
178     g_return_val_if_fail (GST_BUFFER_OFFSET_IS_VALID (buffer), buffer);
179 
180     start = offset;
181     stop = offset_end;
182 
183     if (gst_segment_clip (segment, GST_FORMAT_DEFAULT,
184             start, stop, &amp;cstart, &amp;cstop)) {
185 
186       diff = cstart - start;
187       if (diff &gt; 0) {
188         offset = cstart;
189 
190         timestamp = gst_util_uint64_scale (cstart, GST_SECOND, rate);
191 
192         if (change_duration)
193           duration -= gst_util_uint64_scale (diff, GST_SECOND, rate);
194 
<a name="8" id="anc8"></a><span class="line-modified">195         trim += diff;</span>
<span class="line-modified">196         size -= diff;</span>
197       }
198 
199       diff = stop - cstop;
200       if (diff &gt; 0) {
201         offset_end = cstop;
202 
203         if (change_duration)
204           duration -= gst_util_uint64_scale (diff, GST_SECOND, rate);
205 
<a name="9" id="anc9"></a><span class="line-modified">206         size -= diff;</span>
207       }
208     } else {
209       gst_buffer_unref (buffer);
210       return NULL;
211     }
212   }
213 
214   if (trim == 0 &amp;&amp; size == osize) {
215     ret = buffer;
216 
217     if (GST_BUFFER_TIMESTAMP (ret) != timestamp) {
218       ret = gst_buffer_make_writable (ret);
219       GST_BUFFER_TIMESTAMP (ret) = timestamp;
220     }
221     if (GST_BUFFER_DURATION (ret) != duration) {
222       ret = gst_buffer_make_writable (ret);
223       GST_BUFFER_DURATION (ret) = duration;
224     }
225   } else {
<a name="10" id="anc10"></a><span class="line-modified">226     /* cut out all the samples that are no longer relevant */</span>
227     GST_DEBUG (&quot;trim %&quot; G_GSIZE_FORMAT &quot; size %&quot; G_GSIZE_FORMAT, trim, size);
<a name="11" id="anc11"></a><span class="line-modified">228     ret = gst_audio_buffer_truncate (buffer, bpf, trim, size);</span>

229 
230     GST_DEBUG (&quot;timestamp %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (timestamp));
231     if (ret) {
<a name="12" id="anc12"></a><span class="line-modified">232       GST_BUFFER_TIMESTAMP (ret) = timestamp;</span>
233 
<a name="13" id="anc13"></a><span class="line-modified">234       if (change_duration)</span>
<span class="line-modified">235         GST_BUFFER_DURATION (ret) = duration;</span>
<span class="line-modified">236       if (change_offset)</span>
<span class="line-modified">237         GST_BUFFER_OFFSET (ret) = offset;</span>
<span class="line-modified">238       if (change_offset_end)</span>
<span class="line-modified">239         GST_BUFFER_OFFSET_END (ret) = offset_end;</span>
240     } else {
<a name="14" id="anc14"></a><span class="line-modified">241       GST_ERROR (&quot;gst_audio_buffer_truncate failed&quot;);</span>
<span class="line-added">242     }</span>
243   }
<a name="15" id="anc15"></a><span class="line-added">244   return ret;</span>
<span class="line-added">245 }</span>
<span class="line-added">246 </span>
<span class="line-added">247 /**</span>
<span class="line-added">248  * gst_audio_buffer_truncate:</span>
<span class="line-added">249  * @buffer: (transfer full): The buffer to truncate.</span>
<span class="line-added">250  * @bpf: size of one audio frame in bytes. This is the size of one sample *</span>
<span class="line-added">251  * number of channels.</span>
<span class="line-added">252  * @trim: the number of samples to remove from the beginning of the buffer</span>
<span class="line-added">253  * @samples: the final number of samples that should exist in this buffer or -1</span>
<span class="line-added">254  * to use all the remaining samples if you are only removing samples from the</span>
<span class="line-added">255  * beginning.</span>
<span class="line-added">256  *</span>
<span class="line-added">257  * Truncate the buffer to finally have @samples number of samples, removing</span>
<span class="line-added">258  * the necessary amount of samples from the end and @trim number of samples</span>
<span class="line-added">259  * from the beginning.</span>
<span class="line-added">260  *</span>
<span class="line-added">261  * After calling this function the caller does not own a reference to</span>
<span class="line-added">262  * @buffer anymore.</span>
<span class="line-added">263  *</span>
<span class="line-added">264  * Returns: (transfer full): the truncated buffer or %NULL if the arguments</span>
<span class="line-added">265  *   were invalid</span>
<span class="line-added">266  *</span>
<span class="line-added">267  * Since: 1.16</span>
<span class="line-added">268  */</span>
<span class="line-added">269 GstBuffer *</span>
<span class="line-added">270 gst_audio_buffer_truncate (GstBuffer * buffer, gint bpf, gsize trim,</span>
<span class="line-added">271     gsize samples)</span>
<span class="line-added">272 {</span>
<span class="line-added">273   GstAudioMeta *meta = NULL;</span>
<span class="line-added">274   GstBuffer *ret = NULL;</span>
<span class="line-added">275   gsize orig_samples;</span>
<span class="line-added">276   gint i;</span>
<span class="line-added">277 </span>
<span class="line-added">278   g_return_val_if_fail (GST_IS_BUFFER (buffer), NULL);</span>
<span class="line-added">279 </span>
<span class="line-added">280   meta = gst_buffer_get_audio_meta (buffer);</span>
<span class="line-added">281   orig_samples = meta ? meta-&gt;samples : gst_buffer_get_size (buffer) / bpf;</span>
<span class="line-added">282 </span>
<span class="line-added">283   g_return_val_if_fail (trim &lt; orig_samples, NULL);</span>
<span class="line-added">284   g_return_val_if_fail (samples == -1 || trim + samples &lt;= orig_samples, NULL);</span>
<span class="line-added">285 </span>
<span class="line-added">286   if (samples == -1)</span>
<span class="line-added">287     samples = orig_samples - trim;</span>
<span class="line-added">288 </span>
<span class="line-added">289   /* nothing to truncate */</span>
<span class="line-added">290   if (samples == orig_samples)</span>
<span class="line-added">291     return buffer;</span>
<span class="line-added">292 </span>
<span class="line-added">293   if (!meta || meta-&gt;info.layout == GST_AUDIO_LAYOUT_INTERLEAVED) {</span>
<span class="line-added">294     /* interleaved */</span>
<span class="line-added">295     ret = gst_buffer_copy_region (buffer, GST_BUFFER_COPY_ALL, trim * bpf,</span>
<span class="line-added">296         samples * bpf);</span>
<span class="line-added">297     gst_buffer_unref (buffer);</span>
<span class="line-added">298 </span>
<span class="line-added">299     if ((meta = gst_buffer_get_audio_meta (ret)))</span>
<span class="line-added">300       meta-&gt;samples = samples;</span>
<span class="line-added">301   } else {</span>
<span class="line-added">302     /* non-interleaved */</span>
<span class="line-added">303     ret = gst_buffer_make_writable (buffer);</span>
<span class="line-added">304     meta = gst_buffer_get_audio_meta (buffer);</span>
<span class="line-added">305     meta-&gt;samples = samples;</span>
<span class="line-added">306     for (i = 0; i &lt; meta-&gt;info.channels; i++) {</span>
<span class="line-added">307       meta-&gt;offsets[i] += trim * bpf / meta-&gt;info.channels;</span>
<span class="line-added">308     }</span>
309   }
<a name="16" id="anc16"></a><span class="line-added">310 </span>
311   return ret;
312 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>