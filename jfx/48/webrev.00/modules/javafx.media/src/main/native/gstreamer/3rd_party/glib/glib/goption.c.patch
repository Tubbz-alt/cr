diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/goption.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/goption.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/goption.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/goption.c
@@ -192,10 +192,14 @@
 #include "goption.h"
 
 #include "gprintf.h"
 #include "glibintl.h"
 
+#if defined G_OS_WIN32
+#include <windows.h>
+#endif
+
 #define TRANSLATE(group, str) (((group)->translate_func ? (* (group)->translate_func) ((str), (group)->translate_data) : (str)))
 
 #define NO_ARG(entry) ((entry)->arg == G_OPTION_ARG_NONE ||       \
                        ((entry)->arg == G_OPTION_ARG_CALLBACK &&  \
                         ((entry)->flags & G_OPTION_FLAG_NO_ARG)))
@@ -275,11 +279,11 @@
   GTranslateFunc   translate_func;
   GDestroyNotify   translate_notify;
   gpointer         translate_data;
 
   GOptionEntry    *entries;
-  gint             n_entries;
+  gsize            n_entries;
 
   GOptionParseFunc pre_parse_func;
   GOptionParseFunc post_parse_func;
   GOptionErrorFunc error_func;
 };
@@ -649,10 +653,11 @@
 void
 g_option_context_add_main_entries (GOptionContext      *context,
                                    const GOptionEntry  *entries,
                                    const gchar         *translation_domain)
 {
+  g_return_if_fail (context != NULL);
   g_return_if_fail (entries != NULL);
 
   if (!context->main_group)
     context->main_group = g_option_group_new (NULL, NULL, NULL, NULL, NULL);
 
@@ -663,11 +668,11 @@
 static gint
 calculate_max_length (GOptionGroup *group,
                       GHashTable   *aliases)
 {
   GOptionEntry *entry;
-  gint i, len, max_length;
+  gsize i, len, max_length;
   const gchar *long_name;
 
   max_length = 0;
 
   for (i = 0; i < group->n_entries; i++)
@@ -826,19 +831,21 @@
                            gboolean        main_help,
                            GOptionGroup   *group)
 {
   GList *list;
   gint max_length = 0, len;
-  gint i;
+  gsize i;
   GOptionEntry *entry;
   GHashTable *shadow_map;
   GHashTable *aliases;
   gboolean seen[256];
   const gchar *rest_description;
   GString *string;
   guchar token;
 
+  g_return_val_if_fail (context != NULL, NULL);
+
   string = g_string_sized_new (1024);
 
   rest_description = NULL;
   if (context->main_group)
     {
@@ -1042,11 +1049,11 @@
        group_list_has_visible_entries (context, context->groups, TRUE)))
     {
       list = context->groups;
 
       if (context->help_enabled || list)
-      g_string_append (string,  _("Application Options:"));
+        g_string_append (string,  _("Application Options:"));
       else
         g_string_append (string, _("Options:"));
       g_string_append (string, "\n");
       if (context->main_group)
         for (i = 0; i < context->main_group->n_entries; i++)
@@ -1283,11 +1290,11 @@
                              entry->arg_data);
 
         if (!change->allocated.str)
           change->prev.str = *(gchar **)entry->arg_data;
         else
-        g_free (change->allocated.str);
+          g_free (change->allocated.str);
 
         change->allocated.str = data;
 
         *(gchar **)entry->arg_data = data;
         break;
@@ -1350,11 +1357,11 @@
                              entry->arg_data);
 
         if (!change->allocated.str)
           change->prev.str = *(gchar **)entry->arg_data;
         else
-        g_free (change->allocated.str);
+          g_free (change->allocated.str);
 
         change->allocated.str = data;
 
         *(gchar **)entry->arg_data = data;
         break;
@@ -1503,11 +1510,11 @@
                     gint           *argc,
                     gchar        ***argv,
                     GError        **error,
                     gboolean       *parsed)
 {
-  gint j;
+  gsize j;
 
   for (j = 0; j < group->n_entries; j++)
     {
       if (arg == group->entries[j].short_name)
         {
@@ -1585,11 +1592,11 @@
                    gint           *argc,
                    gchar        ***argv,
                    GError        **error,
                    gboolean       *parsed)
 {
-  gint j;
+  gsize j;
 
   for (j = 0; j < group->n_entries; j++)
     {
       if (*idx >= *argc)
         return TRUE;
@@ -1696,11 +1703,11 @@
                      gint           *argc,
                      gchar        ***argv,
                      GError        **error,
                      gboolean       *parsed)
 {
-  gint j;
+  gsize j;
 
   for (j = 0; j < group->n_entries; j++)
     {
       if (*idx >= *argc)
         return TRUE;
@@ -1813,23 +1820,24 @@
  * tests/option-argv0.c
  */
 static char *
 platform_get_argv0 (void)
 {
-#if defined __linux
+#ifdef HAVE_PROC_SELF_CMDLINE
   char *cmdline;
   char *base_arg0;
   gsize len;
 
   if (!g_file_get_contents ("/proc/self/cmdline",
-                &cmdline,
-                &len,
-                NULL))
+          &cmdline,
+          &len,
+          NULL))
     return NULL;
+
   /* Sanity check for a NUL terminator. */
-  if (!memchr (cmdline, 0, len))
-    return NULL;
+  g_assert (memchr (cmdline, 0, len));
+
   /* We could just return cmdline, but I think it's better
    * to hold on to a smaller malloc block; the arguments
    * could be large.
    */
   base_arg0 = g_path_get_basename (cmdline);
@@ -1858,10 +1866,55 @@
    * could be large.
    */
   base_arg0 = g_path_get_basename (*cmdline);
   g_free (cmdline);
   return base_arg0;
+#elif defined G_OS_WIN32
+  const wchar_t *cmdline;
+  wchar_t **wargv;
+  int wargc;
+  gchar *utf8_buf = NULL;
+  char *base_arg0 = NULL;
+
+  /* Pretend it's const, since we're not allowed to free it */
+  cmdline = (const wchar_t *) GetCommandLineW ();
+  if (G_UNLIKELY (cmdline == NULL))
+    return NULL;
+
+  /* Skip leading whitespace. CommandLineToArgvW() is documented
+   * to behave weirdly with that. The character codes below
+   * correspond to the *only* unicode characters that are
+   * considered to be spaces by CommandLineToArgvW(). The rest
+   * (such as 0xa0 - NO-BREAK SPACE) are treated as
+   * normal characters.
+   */
+  while (cmdline[0] == 0x09 ||
+         cmdline[0] == 0x0a ||
+         cmdline[0] == 0x0c ||
+         cmdline[0] == 0x0d ||
+         cmdline[0] == 0x20)
+    cmdline++;
+
+  wargv = CommandLineToArgvW (cmdline, &wargc);
+  if (G_UNLIKELY (wargv == NULL))
+    return NULL;
+
+  if (wargc > 0)
+    utf8_buf = g_utf16_to_utf8 (wargv[0], -1, NULL, NULL, NULL);
+
+  LocalFree (wargv);
+
+  if (G_UNLIKELY (utf8_buf == NULL))
+    return NULL;
+
+  /* We could just return cmdline, but I think it's better
+   * to hold on to a smaller malloc block; the arguments
+   * could be large.
+   */
+  base_arg0 = g_path_get_basename (utf8_buf);
+  g_free (utf8_buf);
+  return base_arg0;
 #endif
 
   return NULL;
 }
 
@@ -1906,24 +1959,26 @@
                         GError          **error)
 {
   gint i, j, k;
   GList *list;
 
+  g_return_val_if_fail (context != NULL, FALSE);
+
   /* Set program name */
   if (!g_get_prgname())
     {
       gchar *prgname;
 
       if (argc && argv && *argc)
-    prgname = g_path_get_basename ((*argv)[0]);
+  prgname = g_path_get_basename ((*argv)[0]);
       else
-    prgname = platform_get_argv0 ();
+  prgname = platform_get_argv0 ();
 
       if (prgname)
-    g_set_prgname (prgname);
+  g_set_prgname (prgname);
       else
-    g_set_prgname ("<unknown>");
+  g_set_prgname ("<unknown>");
 
       g_free (prgname);
     }
 
   /* Call pre-parse hooks */
@@ -2322,24 +2377,24 @@
 {
   g_return_if_fail (group != NULL);
 
   if (--group->ref_count == 0)
     {
-  g_free (group->name);
-  g_free (group->description);
-  g_free (group->help_description);
+      g_free (group->name);
+      g_free (group->description);
+      g_free (group->help_description);
 
-  g_free (group->entries);
+      g_free (group->entries);
 
-  if (group->destroy_notify)
-    (* group->destroy_notify) (group->user_data);
+      if (group->destroy_notify)
+        (* group->destroy_notify) (group->user_data);
 
-  if (group->translate_notify)
-    (* group->translate_notify) (group->translate_data);
+      if (group->translate_notify)
+        (* group->translate_notify) (group->translate_data);
 
-  g_free (group);
-}
+      g_free (group);
+    }
 }
 
 /**
  * g_option_group_add_entries:
  * @group: a #GOptionGroup
@@ -2351,22 +2406,23 @@
  **/
 void
 g_option_group_add_entries (GOptionGroup       *group,
                             const GOptionEntry *entries)
 {
-  gint i, n_entries;
+  gsize i, n_entries;
 
+  g_return_if_fail (group != NULL);
   g_return_if_fail (entries != NULL);
 
   for (n_entries = 0; entries[n_entries].long_name != NULL; n_entries++) ;
 
   group->entries = g_renew (GOptionEntry, group->entries, group->n_entries + n_entries);
 
   /* group->entries could be NULL in the trivial case where we add no
    * entries to no entries */
   if (n_entries != 0)
-  memcpy (group->entries + group->n_entries, entries, sizeof (GOptionEntry) * n_entries);
+    memcpy (group->entries + group->n_entries, entries, sizeof (GOptionEntry) * n_entries);
 
   for (i = group->n_entries; i < group->n_entries + n_entries; i++)
     {
       gchar c = group->entries[i].short_name;
 
@@ -2657,12 +2713,14 @@
 }
 
 /**
  * g_option_context_parse_strv:
  * @context: a #GOptionContext
- * @arguments: (inout) (array null-terminated=1): a pointer to the
- *    command line arguments (which must be in UTF-8 on Windows)
+ * @arguments: (inout) (array null-terminated=1) (optional): a pointer
+ *    to the command line arguments (which must be in UTF-8 on Windows).
+ *    Starting with GLib 2.62, @arguments can be %NULL, which matches
+ *    g_option_context_parse().
  * @error: a return location for errors
  *
  * Parses the command line arguments.
  *
  * This function is similar to g_option_context_parse() except that it
@@ -2691,12 +2749,14 @@
                              GError          **error)
 {
   gboolean success;
   gint argc;
 
+  g_return_val_if_fail (context != NULL, FALSE);
+
   context->strv_mode = TRUE;
-  argc = g_strv_length (*arguments);
+  argc = arguments && *arguments ? g_strv_length (*arguments) : 0;
   success = g_option_context_parse (context, &argc, arguments, error);
   context->strv_mode = FALSE;
 
   return success;
 }
