<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gspawn-win32.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gspawn.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 435          (outpipe &gt;= 0 ||
 436           errpipe &gt;= 0))
 437     {
 438       ret = 0;
 439 
 440       FD_ZERO (&amp;fds);
 441       if (outpipe &gt;= 0)
 442         FD_SET (outpipe, &amp;fds);
 443       if (errpipe &gt;= 0)
 444         FD_SET (errpipe, &amp;fds);
 445 
 446       ret = select (MAX (outpipe, errpipe) + 1,
 447                     &amp;fds,
 448                     NULL, NULL,
 449                     NULL /* no timeout */);
 450 
 451       if (ret &lt; 0)
 452         {
 453           int errsv = errno;
 454 
<span class="line-modified"> 455       if (errno == EINTR)</span>
<span class="line-modified"> 456         continue;</span>
 457 
 458           failed = TRUE;
 459 
 460           g_set_error (error,
 461                        G_SPAWN_ERROR,
 462                        G_SPAWN_ERROR_READ,
 463                        _(&quot;Unexpected error in select() reading data from a child process (%s)&quot;),
 464                        g_strerror (errsv));
 465 
 466           break;
 467         }
 468 
 469       if (outpipe &gt;= 0 &amp;&amp; FD_ISSET (outpipe, &amp;fds))
 470         {
 471           switch (read_data (outstr, outpipe, error))
 472             {
 473             case READ_FAILED:
 474               failed = TRUE;
 475               break;
 476             case READ_EOF:
</pre>
<hr />
<pre>
 616  * On Windows, note that all the string or string vector arguments to
 617  * this function and the other g_spawn*() functions are in UTF-8, the
 618  * GLib file name encoding. Unicode characters that are not part of
 619  * the system codepage passed in these arguments will be correctly
 620  * available in the spawned program only if it uses wide character API
 621  * to retrieve its command line. For C programs built with Microsoft&#39;s
 622  * tools it is enough to make the program have a wmain() instead of
 623  * main(). wmain() has a wide character argument vector as parameter.
 624  *
 625  * At least currently, mingw doesn&#39;t support wmain(), so if you use
 626  * mingw to develop the spawned program, it should call
 627  * g_win32_get_command_line() to get arguments in UTF-8.
 628  *
 629  * On Windows the low-level child process creation API CreateProcess()
 630  * doesn&#39;t use argument vectors, but a command line. The C runtime
 631  * library&#39;s spawn*() family of functions (which g_spawn_async_with_pipes()
 632  * eventually calls) paste the argument vector elements together into
 633  * a command line, and the C runtime startup code does a corresponding
 634  * reconstruction of an argument vector from the command line, to be
 635  * passed to main(). Complications arise when you have argument vector
<span class="line-modified"> 636  * elements that contain spaces of double quotes. The spawn*() functions</span>
 637  * don&#39;t do any quoting or escaping, but on the other hand the startup
 638  * code does do unquoting and unescaping in order to enable receiving
 639  * arguments with embedded spaces or double quotes. To work around this
 640  * asymmetry, g_spawn_async_with_pipes() will do quoting and escaping on
 641  * argument vector elements that need it before calling the C runtime
 642  * spawn() function.
 643  *
 644  * The returned @child_pid on Windows is a handle to the child
 645  * process, not its identifier. Process handles and process
 646  * identifiers are different concepts on Windows.
 647  *
 648  * @envp is a %NULL-terminated array of strings, where each string
 649  * has the form `KEY=VALUE`. This will become the child&#39;s environment.
 650  * If @envp is %NULL, the child inherits its parent&#39;s environment.
 651  *
 652  * @flags should be the bitwise OR of any flags you want to affect the
 653  * function&#39;s behaviour. The %G_SPAWN_DO_NOT_REAP_CHILD means that the
 654  * child will not automatically be reaped; you must use a child watch
 655  * (g_child_watch_add()) to be notified about the death of the child process,
 656  * otherwise it will stay around as a zombie process until this process exits.
</pre>
<hr />
<pre>
1027  * code set in @error, and the domain will be %G_SPAWN_EXIT_ERROR.
1028  * This allows you to differentiate between different exit codes.
1029  *
1030  * If the process was terminated by some means other than an exit
1031  * status, the domain will be %G_SPAWN_ERROR, and the code will be
1032  * %G_SPAWN_ERROR_FAILED.
1033  *
1034  * This function just offers convenience; you can of course also check
1035  * the available platform via a macro such as %G_OS_UNIX, and use
1036  * WIFEXITED() and WEXITSTATUS() on @exit_status directly. Do not attempt
1037  * to scan or parse the error message string; it may be translated and/or
1038  * change in future versions of GLib.
1039  *
1040  * Returns: %TRUE if child exited successfully, %FALSE otherwise (and
1041  *     @error will be set)
1042  *
1043  * Since: 2.34
1044  */
1045 gboolean
1046 g_spawn_check_exit_status (gint      exit_status,
<span class="line-modified">1047                GError  **error)</span>
1048 {
1049   gboolean ret = FALSE;
1050 
1051   if (WIFEXITED (exit_status))
1052     {
1053       if (WEXITSTATUS (exit_status) != 0)
<span class="line-modified">1054     {</span>
<span class="line-modified">1055       g_set_error (error, G_SPAWN_EXIT_ERROR, WEXITSTATUS (exit_status),</span>
<span class="line-modified">1056                _(&quot;Child process exited with code %ld&quot;),</span>
<span class="line-modified">1057                (long) WEXITSTATUS (exit_status));</span>
<span class="line-modified">1058       goto out;</span>
<span class="line-modified">1059     }</span>
1060     }
1061   else if (WIFSIGNALED (exit_status))
1062     {
1063       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">1064            _(&quot;Child process killed by signal %ld&quot;),</span>
<span class="line-modified">1065            (long) WTERMSIG (exit_status));</span>
1066       goto out;
1067     }
1068   else if (WIFSTOPPED (exit_status))
1069     {
1070       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">1071            _(&quot;Child process stopped by signal %ld&quot;),</span>
<span class="line-modified">1072            (long) WSTOPSIG (exit_status));</span>
1073       goto out;
1074     }
1075   else
1076     {
1077       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">1078            _(&quot;Child process exited abnormally&quot;));</span>
1079       goto out;
1080     }
1081 
1082   ret = TRUE;
1083  out:
1084   return ret;
1085 }
1086 
1087 static gssize
1088 write_all (gint fd, gconstpointer vbuf, gsize to_write)
1089 {
1090   gchar *buf = (gchar *) vbuf;
1091 
1092   while (to_write &gt; 0)
1093     {
1094       gssize count = write (fd, buf, to_write);
1095       if (count &lt; 0)
1096         {
1097           if (errno != EINTR)
1098             return FALSE;
</pre>
<hr />
<pre>
1178   struct rlimit rl;
1179 #endif
1180 
1181 #ifdef __linux__
1182   /* Avoid use of opendir/closedir since these are not async-signal-safe. */
1183   int dir_fd = open (&quot;/proc/self/fd&quot;, O_RDONLY | O_DIRECTORY);
1184   if (dir_fd &gt;= 0)
1185     {
1186       char buf[4096];
1187       int pos, nread;
1188       struct linux_dirent64 *de;
1189 
1190       while ((nread = syscall (SYS_getdents64, dir_fd, buf, sizeof(buf))) &gt; 0)
1191         {
1192           for (pos = 0; pos &lt; nread; pos += de-&gt;d_reclen)
1193             {
1194               de = (struct linux_dirent64 *)(buf + pos);
1195 
1196               fd = filename_to_fd (de-&gt;d_name);
1197               if (fd &lt; 0 || fd == dir_fd)
<span class="line-modified">1198               continue;</span>
1199 
<span class="line-modified">1200           if ((res = cb (data, fd)) != 0)</span>
<span class="line-modified">1201               break;</span>
<span class="line-modified">1202         }</span>
1203         }
1204 
1205       close (dir_fd);
1206       return res;
<span class="line-modified">1207   }</span>
1208 
1209   /* If /proc is not mounted or not accessible we fall back to the old
1210    * rlimit trick */
1211 
1212 #endif
1213 
1214 #ifdef HAVE_SYS_RESOURCE_H
1215 
1216   if (getrlimit(RLIMIT_NOFILE, &amp;rl) == 0 &amp;&amp; rl.rlim_max != RLIM_INFINITY)
1217       open_max = rl.rlim_max;
1218   else
1219 #endif
1220       open_max = sysconf (_SC_OPEN_MAX);
1221 
1222   for (fd = 0; fd &lt; open_max; fd++)
1223       if ((res = cb (data, fd)) != 0)
1224           break;
1225 
1226   return res;
1227 }
</pre>
<hr />
<pre>
1393                     sizeof(gint) * n_ints_in_buf - bytes);
1394       if (chunk &lt; 0 &amp;&amp; errno == EINTR)
1395         goto again;
1396 
1397       if (chunk &lt; 0)
1398         {
1399           int errsv = errno;
1400 
1401           /* Some weird shit happened, bail out */
1402           g_set_error (error,
1403                        G_SPAWN_ERROR,
1404                        G_SPAWN_ERROR_FAILED,
1405                        _(&quot;Failed to read from child pipe (%s)&quot;),
1406                        g_strerror (errsv));
1407 
1408           return FALSE;
1409         }
1410       else if (chunk == 0)
1411         break; /* EOF */
1412       else /* chunk &gt; 0 */
<span class="line-modified">1413     bytes += chunk;</span>
1414     }
1415 
1416   *n_ints_read = (gint)(bytes / sizeof(gint));
1417 
1418   return TRUE;
1419 }
1420 
1421 #ifdef POSIX_SPAWN_AVAILABLE
1422 static gboolean
1423 do_posix_spawn (gchar     **argv,
1424                 gchar     **envp,
1425                 gboolean    search_path,
1426                 gboolean    stdout_to_null,
1427                 gboolean    stderr_to_null,
1428                 gboolean    child_inherits_stdin,
1429                 gboolean    file_and_argv_zero,
1430                 GPid       *child_pid,
1431                 gint       *child_close_fds,
1432                 gint        stdin_fd,
1433                 gint        stdout_fd,
</pre>
<hr />
<pre>
1582     r = posix_spawnp (&amp;pid, argv[0], &amp;file_actions, &amp;attr, argv_pass, envp);
1583 
1584   if (r == 0 &amp;&amp; child_pid != NULL)
1585     *child_pid = pid;
1586 
1587 out_close_fds:
1588   for (i = 0; i &lt; num_parent_close_fds; i++)
1589     close_and_invalidate (&amp;parent_close_fds [i]);
1590 
1591   posix_spawn_file_actions_destroy (&amp;file_actions);
1592 out_free_spawnattr:
1593   posix_spawnattr_destroy (&amp;attr);
1594   g_slist_free (child_close);
1595 
1596   return r;
1597 }
1598 #endif /* POSIX_SPAWN_AVAILABLE */
1599 
1600 static gboolean
1601 fork_exec_with_fds (gboolean              intermediate_child,
<span class="line-modified">1602                       const gchar          *working_directory,</span>
<span class="line-modified">1603                       gchar               **argv,</span>
<span class="line-modified">1604                       gchar               **envp,</span>
<span class="line-modified">1605                       gboolean              close_descriptors,</span>
<span class="line-modified">1606                       gboolean              search_path,</span>
<span class="line-modified">1607                       gboolean              search_path_from_envp,</span>
<span class="line-modified">1608                       gboolean              stdout_to_null,</span>
<span class="line-modified">1609                       gboolean              stderr_to_null,</span>
<span class="line-modified">1610                       gboolean              child_inherits_stdin,</span>
<span class="line-modified">1611                       gboolean              file_and_argv_zero,</span>
<span class="line-modified">1612                       gboolean              cloexec_pipes,</span>
<span class="line-modified">1613                       GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">1614                       gpointer              user_data,</span>
<span class="line-modified">1615                       GPid                 *child_pid,</span>
<span class="line-modified">1616                       gint                 *child_close_fds,</span>
<span class="line-modified">1617                       gint                  stdin_fd,</span>
<span class="line-modified">1618                       gint                  stdout_fd,</span>
<span class="line-modified">1619                       gint                  stderr_fd,</span>
<span class="line-modified">1620                       GError              **error)</span>
1621 {
1622   GPid pid = -1;
1623   gint child_err_report_pipe[2] = { -1, -1 };
1624   gint child_pid_report_pipe[2] = { -1, -1 };
1625   guint pipe_flags = cloexec_pipes ? FD_CLOEXEC : 0;
1626   gint status;
1627 
1628 #ifdef POSIX_SPAWN_AVAILABLE
1629   if (!intermediate_child &amp;&amp; working_directory == NULL &amp;&amp; !close_descriptors &amp;&amp;
1630       !search_path_from_envp &amp;&amp; child_setup == NULL)
1631     {
1632       g_debug (&quot;Launching with posix_spawn&quot;);
1633       status = do_posix_spawn (argv,
1634                                envp,
1635                                search_path,
1636                                stdout_to_null,
1637                                stderr_to_null,
1638                                child_inherits_stdin,
1639                                file_and_argv_zero,
1640                                child_pid,
1641                                child_close_fds,
1642                                stdin_fd,
1643                                stdout_fd,
1644                                stderr_fd);
1645       if (status == 0)
1646         return TRUE;
1647 
1648       if (status != ENOEXEC)
1649         {
1650           g_set_error (error,
1651                        G_SPAWN_ERROR,
1652                        G_SPAWN_ERROR_FAILED,
<span class="line-modified">1653                        _(&quot;Failed to spawn child process “%s” (%s)&quot;),</span>
1654                        argv[0],
1655                        g_strerror (status));
1656           return FALSE;
1657        }
1658 
1659       /* posix_spawn is not intended to support script execution. It does in
1660        * some situations on some glibc versions, but that will be fixed.
1661        * So if it fails with ENOEXEC, we fall through to the regular
1662        * gspawn codepath so that script execution can be attempted,
1663        * per standard gspawn behaviour. */
1664       g_debug (&quot;posix_spawn failed (ENOEXEC), fall back to regular gspawn&quot;);
1665     }
1666   else
1667     {
1668       g_debug (&quot;posix_spawn avoided %s%s%s%s%s&quot;,
1669                !intermediate_child ? &quot;&quot; : &quot;(automatic reaping requested) &quot;,
1670                working_directory == NULL ? &quot;&quot; : &quot;(workdir specified) &quot;,
1671                !close_descriptors ? &quot;&quot; : &quot;(fd close requested) &quot;,
1672                !search_path_from_envp ? &quot;&quot; : &quot;(using envp for search path) &quot;,
1673                child_setup == NULL ? &quot;&quot; : &quot;(child_setup specified) &quot;);
</pre>
<hr />
<pre>
1801 
1802       gint buf[2];
1803       gint n_ints = 0;
1804 
1805       /* Close the uncared-about ends of the pipes */
1806       close_and_invalidate (&amp;child_err_report_pipe[1]);
1807       close_and_invalidate (&amp;child_pid_report_pipe[1]);
1808 
1809       /* If we had an intermediate child, reap it */
1810       if (intermediate_child)
1811         {
1812         wait_again:
1813           if (waitpid (pid, &amp;status, 0) &lt; 0)
1814             {
1815               if (errno == EINTR)
1816                 goto wait_again;
1817               else if (errno == ECHILD)
1818                 ; /* do nothing, child already reaped */
1819               else
1820                 g_warning (&quot;waitpid() should not fail in &quot;
<span class="line-modified">1821                &quot;&#39;fork_exec_with_pipes&#39;&quot;);</span>
1822             }
1823         }
1824 
1825 
1826       if (!read_ints (child_err_report_pipe[0],
1827                       buf, 2, &amp;n_ints,
1828                       error))
1829         goto cleanup_and_fail;
1830 
1831       if (n_ints &gt;= 2)
1832         {
1833           /* Error from the child. */
1834 
1835           switch (buf[0])
1836             {
1837             case CHILD_CHDIR_FAILED:
1838               g_set_error (error,
1839                            G_SPAWN_ERROR,
1840                            G_SPAWN_ERROR_CHDIR,
1841                            _(&quot;Failed to change to directory &#39;%s&#39; (%s)&quot;),
1842                            working_directory,
1843                            g_strerror (buf[1]));
1844 
1845               break;
1846 
1847             case CHILD_EXEC_FAILED:
1848               g_set_error (error,
1849                            G_SPAWN_ERROR,
1850                            _g_spawn_exec_err_to_g_error (buf[1]),
<span class="line-modified">1851                            _(&quot;Failed to execute child process \&quot;%s\&quot; (%s)&quot;),</span>
1852                            argv[0],
1853                            g_strerror (buf[1]));
1854 
1855               break;
1856 
1857             case CHILD_DUP2_FAILED:
1858               g_set_error (error,
1859                            G_SPAWN_ERROR,
1860                            G_SPAWN_ERROR_FAILED,
1861                            _(&quot;Failed to redirect output or input of child process (%s)&quot;),
1862                            g_strerror (buf[1]));
1863 
1864               break;
1865 
1866             case CHILD_FORK_FAILED:
1867               g_set_error (error,
1868                            G_SPAWN_ERROR,
1869                            G_SPAWN_ERROR_FORK,
1870                            _(&quot;Failed to fork child process (%s)&quot;),
1871                            g_strerror (buf[1]));
1872               break;
1873 
1874             default:
1875               g_set_error (error,
1876                            G_SPAWN_ERROR,
1877                            G_SPAWN_ERROR_FAILED,
<span class="line-modified">1878                            _(&quot;Unknown error executing child process \&quot;%s\&quot;&quot;),</span>
1879                            argv[0]);
1880               break;
1881             }
1882 
1883           goto cleanup_and_fail;
1884         }
1885 
1886       /* Get child pid from intermediate child pipe. */
1887       if (intermediate_child)
1888         {
1889           n_ints = 0;
1890 
1891           if (!read_ints (child_pid_report_pipe[0],
1892                           buf, 1, &amp;n_ints, error))
1893             goto cleanup_and_fail;
1894 
1895           if (n_ints &lt; 1)
1896             {
1897               int errsv = errno;
1898 
</pre>
<hr />
<pre>
2046 static void
2047 script_execute (const gchar *file,
2048                 gchar      **argv,
2049                 gchar      **envp)
2050 {
2051   /* Count the arguments.  */
2052   int argc = 0;
2053   while (argv[argc])
2054     ++argc;
2055 
2056   /* Construct an argument list for the shell.  */
2057   {
2058     gchar **new_argv;
2059 
2060     new_argv = g_new0 (gchar*, argc + 2); /* /bin/sh and NULL */
2061 
2062     new_argv[0] = (char *) &quot;/bin/sh&quot;;
2063     new_argv[1] = (char *) file;
2064     while (argc &gt; 0)
2065       {
<span class="line-modified">2066     new_argv[argc + 1] = argv[argc];</span>
<span class="line-modified">2067     --argc;</span>
2068       }
2069 
2070     /* Execute the shell. */
2071     if (envp)
2072       execve (new_argv[0], new_argv, envp);
2073     else
2074       execv (new_argv[0], new_argv);
2075 
2076     g_free (new_argv);
2077   }
2078 }
2079 
2080 static gchar*
2081 my_strchrnul (const gchar *str, gchar c)
2082 {
2083   gchar *p = (gchar*) str;
2084   while (*p &amp;&amp; (*p != c))
2085     ++p;
2086 
2087   return p;
</pre>
<hr />
<pre>
2093            gchar      **envp,
2094            gboolean     search_path,
2095            gboolean     search_path_from_envp)
2096 {
2097   if (*file == &#39;\0&#39;)
2098     {
2099       /* We check the simple case first. */
2100       errno = ENOENT;
2101       return -1;
2102     }
2103 
2104   if (!(search_path || search_path_from_envp) || strchr (file, &#39;/&#39;) != NULL)
2105     {
2106       /* Don&#39;t search when it contains a slash. */
2107       if (envp)
2108         execve (file, argv, envp);
2109       else
2110         execv (file, argv);
2111 
2112       if (errno == ENOEXEC)
<span class="line-modified">2113     script_execute (file, argv, envp);</span>
2114     }
2115   else
2116     {
2117       gboolean got_eacces = 0;
2118       const gchar *path, *p;
2119       gchar *name, *freeme;
2120       gsize len;
2121       gsize pathlen;
2122 
2123       path = NULL;
2124       if (search_path_from_envp)
2125         path = g_environ_getenv (envp, &quot;PATH&quot;);
2126       if (search_path &amp;&amp; path == NULL)
2127         path = g_getenv (&quot;PATH&quot;);
2128 
2129       if (path == NULL)
<span class="line-modified">2130     {</span>
<span class="line-modified">2131       /* There is no &#39;PATH&#39; in the environment.  The default</span>
<span class="line-modified">2132        * search path in libc is the current directory followed by</span>
<span class="line-modified">2133        * the path &#39;confstr&#39; returns for &#39;_CS_PATH&#39;.</span>
2134            */
2135 
2136           /* In GLib we put . last, for security, and don&#39;t use the
2137            * unportable confstr(); UNIX98 does not actually specify
2138            * what to search if PATH is unset. POSIX may, dunno.
2139            */
2140 
2141           path = &quot;/bin:/usr/bin:.&quot;;
<span class="line-modified">2142     }</span>
2143 
2144       len = strlen (file) + 1;
2145       pathlen = strlen (path);
2146       freeme = name = g_malloc (pathlen + len + 1);
2147 
2148       /* Copy the file name at the top, including &#39;\0&#39;  */
2149       memcpy (name + pathlen + 1, file, len);
2150       name = name + pathlen;
2151       /* And add the slash before the filename  */
2152       *name = &#39;/&#39;;
2153 
2154       p = path;
2155       do
<span class="line-modified">2156     {</span>
<span class="line-modified">2157       char *startp;</span>
2158 
<span class="line-modified">2159       path = p;</span>
<span class="line-modified">2160       p = my_strchrnul (path, &#39;:&#39;);</span>
2161 
<span class="line-modified">2162       if (p == path)</span>
<span class="line-modified">2163         /* Two adjacent colons, or a colon at the beginning or the end</span>
2164              * of &#39;PATH&#39; means to search the current directory.
2165              */
<span class="line-modified">2166         startp = name + 1;</span>
<span class="line-modified">2167       else</span>
<span class="line-modified">2168         startp = memcpy (name - (p - path), path, p - path);</span>
2169 
<span class="line-modified">2170       /* Try to execute this name.  If it works, execv will not return.  */</span>
2171           if (envp)
2172             execve (startp, argv, envp);
2173           else
2174             execv (startp, argv);
2175 
<span class="line-modified">2176       if (errno == ENOEXEC)</span>
<span class="line-modified">2177         script_execute (startp, argv, envp);</span>
2178 
<span class="line-modified">2179       switch (errno)</span>
<span class="line-modified">2180         {</span>
<span class="line-modified">2181         case EACCES:</span>
<span class="line-modified">2182           /* Record the we got a &#39;Permission denied&#39; error.  If we end</span>
2183                * up finding no executable we can use, we want to diagnose
2184                * that we did find one but were denied access.
2185                */
<span class="line-modified">2186           got_eacces = TRUE;</span>
2187 
2188               /* FALL THRU */
2189 
<span class="line-modified">2190         case ENOENT:</span>
2191 #ifdef ESTALE
<span class="line-modified">2192         case ESTALE:</span>
2193 #endif
2194 #ifdef ENOTDIR
<span class="line-modified">2195         case ENOTDIR:</span>
2196 #endif
<span class="line-modified">2197           /* Those errors indicate the file is missing or not executable</span>
2198                * by us, in which case we want to just try the next path
2199                * directory.
2200                */
<span class="line-modified">2201           break;</span>
2202 
<span class="line-modified">2203         case ENODEV:</span>
<span class="line-modified">2204         case ETIMEDOUT:</span>
<span class="line-modified">2205           /* Some strange filesystems like AFS return even</span>
<span class="line-modified">2206            * stranger error numbers.  They cannot reasonably mean anything</span>
<span class="line-modified">2207            * else so ignore those, too.</span>
<span class="line-modified">2208            */</span>
<span class="line-modified">2209           break;</span>
2210 
<span class="line-modified">2211         default:</span>
<span class="line-modified">2212           /* Some other error means we found an executable file, but</span>
2213                * something went wrong executing it; return the error to our
2214                * caller.
2215                */
2216               g_free (freeme);
<span class="line-modified">2217           return -1;</span>
<span class="line-modified">2218         }</span>
<span class="line-modified">2219     }</span>
2220       while (*p++ != &#39;\0&#39;);
2221 
2222       /* We tried every element and none of them worked.  */
2223       if (got_eacces)
<span class="line-modified">2224     /* At least one failure was due to permissions, so report that</span>
2225          * error.
2226          */
2227         errno = EACCES;
2228 
2229       g_free (freeme);
2230     }
2231 
2232   /* Return the error from the last attempt (probably ENOENT).  */
2233   return -1;
2234 }
2235 
2236 /**
2237  * g_spawn_close_pid:
2238  * @pid: The process reference to close
2239  *
2240  * On some platforms, notably Windows, the #GPid type represents a resource
2241  * which must be closed to prevent resource leaking. g_spawn_close_pid()
2242  * is provided for this purpose. It should be used on all platforms, even
2243  * though it doesn&#39;t do anything under UNIX.
2244  **/
</pre>
</td>
<td>
<hr />
<pre>
 435          (outpipe &gt;= 0 ||
 436           errpipe &gt;= 0))
 437     {
 438       ret = 0;
 439 
 440       FD_ZERO (&amp;fds);
 441       if (outpipe &gt;= 0)
 442         FD_SET (outpipe, &amp;fds);
 443       if (errpipe &gt;= 0)
 444         FD_SET (errpipe, &amp;fds);
 445 
 446       ret = select (MAX (outpipe, errpipe) + 1,
 447                     &amp;fds,
 448                     NULL, NULL,
 449                     NULL /* no timeout */);
 450 
 451       if (ret &lt; 0)
 452         {
 453           int errsv = errno;
 454 
<span class="line-modified"> 455     if (errno == EINTR)</span>
<span class="line-modified"> 456       continue;</span>
 457 
 458           failed = TRUE;
 459 
 460           g_set_error (error,
 461                        G_SPAWN_ERROR,
 462                        G_SPAWN_ERROR_READ,
 463                        _(&quot;Unexpected error in select() reading data from a child process (%s)&quot;),
 464                        g_strerror (errsv));
 465 
 466           break;
 467         }
 468 
 469       if (outpipe &gt;= 0 &amp;&amp; FD_ISSET (outpipe, &amp;fds))
 470         {
 471           switch (read_data (outstr, outpipe, error))
 472             {
 473             case READ_FAILED:
 474               failed = TRUE;
 475               break;
 476             case READ_EOF:
</pre>
<hr />
<pre>
 616  * On Windows, note that all the string or string vector arguments to
 617  * this function and the other g_spawn*() functions are in UTF-8, the
 618  * GLib file name encoding. Unicode characters that are not part of
 619  * the system codepage passed in these arguments will be correctly
 620  * available in the spawned program only if it uses wide character API
 621  * to retrieve its command line. For C programs built with Microsoft&#39;s
 622  * tools it is enough to make the program have a wmain() instead of
 623  * main(). wmain() has a wide character argument vector as parameter.
 624  *
 625  * At least currently, mingw doesn&#39;t support wmain(), so if you use
 626  * mingw to develop the spawned program, it should call
 627  * g_win32_get_command_line() to get arguments in UTF-8.
 628  *
 629  * On Windows the low-level child process creation API CreateProcess()
 630  * doesn&#39;t use argument vectors, but a command line. The C runtime
 631  * library&#39;s spawn*() family of functions (which g_spawn_async_with_pipes()
 632  * eventually calls) paste the argument vector elements together into
 633  * a command line, and the C runtime startup code does a corresponding
 634  * reconstruction of an argument vector from the command line, to be
 635  * passed to main(). Complications arise when you have argument vector
<span class="line-modified"> 636  * elements that contain spaces or double quotes. The `spawn*()` functions</span>
 637  * don&#39;t do any quoting or escaping, but on the other hand the startup
 638  * code does do unquoting and unescaping in order to enable receiving
 639  * arguments with embedded spaces or double quotes. To work around this
 640  * asymmetry, g_spawn_async_with_pipes() will do quoting and escaping on
 641  * argument vector elements that need it before calling the C runtime
 642  * spawn() function.
 643  *
 644  * The returned @child_pid on Windows is a handle to the child
 645  * process, not its identifier. Process handles and process
 646  * identifiers are different concepts on Windows.
 647  *
 648  * @envp is a %NULL-terminated array of strings, where each string
 649  * has the form `KEY=VALUE`. This will become the child&#39;s environment.
 650  * If @envp is %NULL, the child inherits its parent&#39;s environment.
 651  *
 652  * @flags should be the bitwise OR of any flags you want to affect the
 653  * function&#39;s behaviour. The %G_SPAWN_DO_NOT_REAP_CHILD means that the
 654  * child will not automatically be reaped; you must use a child watch
 655  * (g_child_watch_add()) to be notified about the death of the child process,
 656  * otherwise it will stay around as a zombie process until this process exits.
</pre>
<hr />
<pre>
1027  * code set in @error, and the domain will be %G_SPAWN_EXIT_ERROR.
1028  * This allows you to differentiate between different exit codes.
1029  *
1030  * If the process was terminated by some means other than an exit
1031  * status, the domain will be %G_SPAWN_ERROR, and the code will be
1032  * %G_SPAWN_ERROR_FAILED.
1033  *
1034  * This function just offers convenience; you can of course also check
1035  * the available platform via a macro such as %G_OS_UNIX, and use
1036  * WIFEXITED() and WEXITSTATUS() on @exit_status directly. Do not attempt
1037  * to scan or parse the error message string; it may be translated and/or
1038  * change in future versions of GLib.
1039  *
1040  * Returns: %TRUE if child exited successfully, %FALSE otherwise (and
1041  *     @error will be set)
1042  *
1043  * Since: 2.34
1044  */
1045 gboolean
1046 g_spawn_check_exit_status (gint      exit_status,
<span class="line-modified">1047          GError  **error)</span>
1048 {
1049   gboolean ret = FALSE;
1050 
1051   if (WIFEXITED (exit_status))
1052     {
1053       if (WEXITSTATUS (exit_status) != 0)
<span class="line-modified">1054   {</span>
<span class="line-modified">1055     g_set_error (error, G_SPAWN_EXIT_ERROR, WEXITSTATUS (exit_status),</span>
<span class="line-modified">1056            _(&quot;Child process exited with code %ld&quot;),</span>
<span class="line-modified">1057            (long) WEXITSTATUS (exit_status));</span>
<span class="line-modified">1058     goto out;</span>
<span class="line-modified">1059   }</span>
1060     }
1061   else if (WIFSIGNALED (exit_status))
1062     {
1063       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">1064        _(&quot;Child process killed by signal %ld&quot;),</span>
<span class="line-modified">1065        (long) WTERMSIG (exit_status));</span>
1066       goto out;
1067     }
1068   else if (WIFSTOPPED (exit_status))
1069     {
1070       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">1071        _(&quot;Child process stopped by signal %ld&quot;),</span>
<span class="line-modified">1072        (long) WSTOPSIG (exit_status));</span>
1073       goto out;
1074     }
1075   else
1076     {
1077       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<span class="line-modified">1078        _(&quot;Child process exited abnormally&quot;));</span>
1079       goto out;
1080     }
1081 
1082   ret = TRUE;
1083  out:
1084   return ret;
1085 }
1086 
1087 static gssize
1088 write_all (gint fd, gconstpointer vbuf, gsize to_write)
1089 {
1090   gchar *buf = (gchar *) vbuf;
1091 
1092   while (to_write &gt; 0)
1093     {
1094       gssize count = write (fd, buf, to_write);
1095       if (count &lt; 0)
1096         {
1097           if (errno != EINTR)
1098             return FALSE;
</pre>
<hr />
<pre>
1178   struct rlimit rl;
1179 #endif
1180 
1181 #ifdef __linux__
1182   /* Avoid use of opendir/closedir since these are not async-signal-safe. */
1183   int dir_fd = open (&quot;/proc/self/fd&quot;, O_RDONLY | O_DIRECTORY);
1184   if (dir_fd &gt;= 0)
1185     {
1186       char buf[4096];
1187       int pos, nread;
1188       struct linux_dirent64 *de;
1189 
1190       while ((nread = syscall (SYS_getdents64, dir_fd, buf, sizeof(buf))) &gt; 0)
1191         {
1192           for (pos = 0; pos &lt; nread; pos += de-&gt;d_reclen)
1193             {
1194               de = (struct linux_dirent64 *)(buf + pos);
1195 
1196               fd = filename_to_fd (de-&gt;d_name);
1197               if (fd &lt; 0 || fd == dir_fd)
<span class="line-modified">1198                   continue;</span>
1199 
<span class="line-modified">1200               if ((res = cb (data, fd)) != 0)</span>
<span class="line-modified">1201                   break;</span>
<span class="line-modified">1202             }</span>
1203         }
1204 
1205       close (dir_fd);
1206       return res;
<span class="line-modified">1207     }</span>
1208 
1209   /* If /proc is not mounted or not accessible we fall back to the old
1210    * rlimit trick */
1211 
1212 #endif
1213 
1214 #ifdef HAVE_SYS_RESOURCE_H
1215 
1216   if (getrlimit(RLIMIT_NOFILE, &amp;rl) == 0 &amp;&amp; rl.rlim_max != RLIM_INFINITY)
1217       open_max = rl.rlim_max;
1218   else
1219 #endif
1220       open_max = sysconf (_SC_OPEN_MAX);
1221 
1222   for (fd = 0; fd &lt; open_max; fd++)
1223       if ((res = cb (data, fd)) != 0)
1224           break;
1225 
1226   return res;
1227 }
</pre>
<hr />
<pre>
1393                     sizeof(gint) * n_ints_in_buf - bytes);
1394       if (chunk &lt; 0 &amp;&amp; errno == EINTR)
1395         goto again;
1396 
1397       if (chunk &lt; 0)
1398         {
1399           int errsv = errno;
1400 
1401           /* Some weird shit happened, bail out */
1402           g_set_error (error,
1403                        G_SPAWN_ERROR,
1404                        G_SPAWN_ERROR_FAILED,
1405                        _(&quot;Failed to read from child pipe (%s)&quot;),
1406                        g_strerror (errsv));
1407 
1408           return FALSE;
1409         }
1410       else if (chunk == 0)
1411         break; /* EOF */
1412       else /* chunk &gt; 0 */
<span class="line-modified">1413   bytes += chunk;</span>
1414     }
1415 
1416   *n_ints_read = (gint)(bytes / sizeof(gint));
1417 
1418   return TRUE;
1419 }
1420 
1421 #ifdef POSIX_SPAWN_AVAILABLE
1422 static gboolean
1423 do_posix_spawn (gchar     **argv,
1424                 gchar     **envp,
1425                 gboolean    search_path,
1426                 gboolean    stdout_to_null,
1427                 gboolean    stderr_to_null,
1428                 gboolean    child_inherits_stdin,
1429                 gboolean    file_and_argv_zero,
1430                 GPid       *child_pid,
1431                 gint       *child_close_fds,
1432                 gint        stdin_fd,
1433                 gint        stdout_fd,
</pre>
<hr />
<pre>
1582     r = posix_spawnp (&amp;pid, argv[0], &amp;file_actions, &amp;attr, argv_pass, envp);
1583 
1584   if (r == 0 &amp;&amp; child_pid != NULL)
1585     *child_pid = pid;
1586 
1587 out_close_fds:
1588   for (i = 0; i &lt; num_parent_close_fds; i++)
1589     close_and_invalidate (&amp;parent_close_fds [i]);
1590 
1591   posix_spawn_file_actions_destroy (&amp;file_actions);
1592 out_free_spawnattr:
1593   posix_spawnattr_destroy (&amp;attr);
1594   g_slist_free (child_close);
1595 
1596   return r;
1597 }
1598 #endif /* POSIX_SPAWN_AVAILABLE */
1599 
1600 static gboolean
1601 fork_exec_with_fds (gboolean              intermediate_child,
<span class="line-modified">1602                     const gchar          *working_directory,</span>
<span class="line-modified">1603                     gchar               **argv,</span>
<span class="line-modified">1604                     gchar               **envp,</span>
<span class="line-modified">1605                     gboolean              close_descriptors,</span>
<span class="line-modified">1606                     gboolean              search_path,</span>
<span class="line-modified">1607                     gboolean              search_path_from_envp,</span>
<span class="line-modified">1608                     gboolean              stdout_to_null,</span>
<span class="line-modified">1609                     gboolean              stderr_to_null,</span>
<span class="line-modified">1610                     gboolean              child_inherits_stdin,</span>
<span class="line-modified">1611                     gboolean              file_and_argv_zero,</span>
<span class="line-modified">1612                     gboolean              cloexec_pipes,</span>
<span class="line-modified">1613                     GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">1614                     gpointer              user_data,</span>
<span class="line-modified">1615                     GPid                 *child_pid,</span>
<span class="line-modified">1616                     gint                 *child_close_fds,</span>
<span class="line-modified">1617                     gint                  stdin_fd,</span>
<span class="line-modified">1618                     gint                  stdout_fd,</span>
<span class="line-modified">1619                     gint                  stderr_fd,</span>
<span class="line-modified">1620                     GError              **error)</span>
1621 {
1622   GPid pid = -1;
1623   gint child_err_report_pipe[2] = { -1, -1 };
1624   gint child_pid_report_pipe[2] = { -1, -1 };
1625   guint pipe_flags = cloexec_pipes ? FD_CLOEXEC : 0;
1626   gint status;
1627 
1628 #ifdef POSIX_SPAWN_AVAILABLE
1629   if (!intermediate_child &amp;&amp; working_directory == NULL &amp;&amp; !close_descriptors &amp;&amp;
1630       !search_path_from_envp &amp;&amp; child_setup == NULL)
1631     {
1632       g_debug (&quot;Launching with posix_spawn&quot;);
1633       status = do_posix_spawn (argv,
1634                                envp,
1635                                search_path,
1636                                stdout_to_null,
1637                                stderr_to_null,
1638                                child_inherits_stdin,
1639                                file_and_argv_zero,
1640                                child_pid,
1641                                child_close_fds,
1642                                stdin_fd,
1643                                stdout_fd,
1644                                stderr_fd);
1645       if (status == 0)
1646         return TRUE;
1647 
1648       if (status != ENOEXEC)
1649         {
1650           g_set_error (error,
1651                        G_SPAWN_ERROR,
1652                        G_SPAWN_ERROR_FAILED,
<span class="line-modified">1653                        _(&quot;Failed to spawn child process &#39;%s&#39; (%s)&quot;),</span>
1654                        argv[0],
1655                        g_strerror (status));
1656           return FALSE;
1657        }
1658 
1659       /* posix_spawn is not intended to support script execution. It does in
1660        * some situations on some glibc versions, but that will be fixed.
1661        * So if it fails with ENOEXEC, we fall through to the regular
1662        * gspawn codepath so that script execution can be attempted,
1663        * per standard gspawn behaviour. */
1664       g_debug (&quot;posix_spawn failed (ENOEXEC), fall back to regular gspawn&quot;);
1665     }
1666   else
1667     {
1668       g_debug (&quot;posix_spawn avoided %s%s%s%s%s&quot;,
1669                !intermediate_child ? &quot;&quot; : &quot;(automatic reaping requested) &quot;,
1670                working_directory == NULL ? &quot;&quot; : &quot;(workdir specified) &quot;,
1671                !close_descriptors ? &quot;&quot; : &quot;(fd close requested) &quot;,
1672                !search_path_from_envp ? &quot;&quot; : &quot;(using envp for search path) &quot;,
1673                child_setup == NULL ? &quot;&quot; : &quot;(child_setup specified) &quot;);
</pre>
<hr />
<pre>
1801 
1802       gint buf[2];
1803       gint n_ints = 0;
1804 
1805       /* Close the uncared-about ends of the pipes */
1806       close_and_invalidate (&amp;child_err_report_pipe[1]);
1807       close_and_invalidate (&amp;child_pid_report_pipe[1]);
1808 
1809       /* If we had an intermediate child, reap it */
1810       if (intermediate_child)
1811         {
1812         wait_again:
1813           if (waitpid (pid, &amp;status, 0) &lt; 0)
1814             {
1815               if (errno == EINTR)
1816                 goto wait_again;
1817               else if (errno == ECHILD)
1818                 ; /* do nothing, child already reaped */
1819               else
1820                 g_warning (&quot;waitpid() should not fail in &quot;
<span class="line-modified">1821          &quot;&#39;fork_exec_with_pipes&#39;&quot;);</span>
1822             }
1823         }
1824 
1825 
1826       if (!read_ints (child_err_report_pipe[0],
1827                       buf, 2, &amp;n_ints,
1828                       error))
1829         goto cleanup_and_fail;
1830 
1831       if (n_ints &gt;= 2)
1832         {
1833           /* Error from the child. */
1834 
1835           switch (buf[0])
1836             {
1837             case CHILD_CHDIR_FAILED:
1838               g_set_error (error,
1839                            G_SPAWN_ERROR,
1840                            G_SPAWN_ERROR_CHDIR,
1841                            _(&quot;Failed to change to directory &#39;%s&#39; (%s)&quot;),
1842                            working_directory,
1843                            g_strerror (buf[1]));
1844 
1845               break;
1846 
1847             case CHILD_EXEC_FAILED:
1848               g_set_error (error,
1849                            G_SPAWN_ERROR,
1850                            _g_spawn_exec_err_to_g_error (buf[1]),
<span class="line-modified">1851                            _(&quot;Failed to execute child process &#39;%s&#39; (%s)&quot;),</span>
1852                            argv[0],
1853                            g_strerror (buf[1]));
1854 
1855               break;
1856 
1857             case CHILD_DUP2_FAILED:
1858               g_set_error (error,
1859                            G_SPAWN_ERROR,
1860                            G_SPAWN_ERROR_FAILED,
1861                            _(&quot;Failed to redirect output or input of child process (%s)&quot;),
1862                            g_strerror (buf[1]));
1863 
1864               break;
1865 
1866             case CHILD_FORK_FAILED:
1867               g_set_error (error,
1868                            G_SPAWN_ERROR,
1869                            G_SPAWN_ERROR_FORK,
1870                            _(&quot;Failed to fork child process (%s)&quot;),
1871                            g_strerror (buf[1]));
1872               break;
1873 
1874             default:
1875               g_set_error (error,
1876                            G_SPAWN_ERROR,
1877                            G_SPAWN_ERROR_FAILED,
<span class="line-modified">1878                            _(&quot;Unknown error executing child process &#39;%s&#39;&quot;),</span>
1879                            argv[0]);
1880               break;
1881             }
1882 
1883           goto cleanup_and_fail;
1884         }
1885 
1886       /* Get child pid from intermediate child pipe. */
1887       if (intermediate_child)
1888         {
1889           n_ints = 0;
1890 
1891           if (!read_ints (child_pid_report_pipe[0],
1892                           buf, 1, &amp;n_ints, error))
1893             goto cleanup_and_fail;
1894 
1895           if (n_ints &lt; 1)
1896             {
1897               int errsv = errno;
1898 
</pre>
<hr />
<pre>
2046 static void
2047 script_execute (const gchar *file,
2048                 gchar      **argv,
2049                 gchar      **envp)
2050 {
2051   /* Count the arguments.  */
2052   int argc = 0;
2053   while (argv[argc])
2054     ++argc;
2055 
2056   /* Construct an argument list for the shell.  */
2057   {
2058     gchar **new_argv;
2059 
2060     new_argv = g_new0 (gchar*, argc + 2); /* /bin/sh and NULL */
2061 
2062     new_argv[0] = (char *) &quot;/bin/sh&quot;;
2063     new_argv[1] = (char *) file;
2064     while (argc &gt; 0)
2065       {
<span class="line-modified">2066   new_argv[argc + 1] = argv[argc];</span>
<span class="line-modified">2067   --argc;</span>
2068       }
2069 
2070     /* Execute the shell. */
2071     if (envp)
2072       execve (new_argv[0], new_argv, envp);
2073     else
2074       execv (new_argv[0], new_argv);
2075 
2076     g_free (new_argv);
2077   }
2078 }
2079 
2080 static gchar*
2081 my_strchrnul (const gchar *str, gchar c)
2082 {
2083   gchar *p = (gchar*) str;
2084   while (*p &amp;&amp; (*p != c))
2085     ++p;
2086 
2087   return p;
</pre>
<hr />
<pre>
2093            gchar      **envp,
2094            gboolean     search_path,
2095            gboolean     search_path_from_envp)
2096 {
2097   if (*file == &#39;\0&#39;)
2098     {
2099       /* We check the simple case first. */
2100       errno = ENOENT;
2101       return -1;
2102     }
2103 
2104   if (!(search_path || search_path_from_envp) || strchr (file, &#39;/&#39;) != NULL)
2105     {
2106       /* Don&#39;t search when it contains a slash. */
2107       if (envp)
2108         execve (file, argv, envp);
2109       else
2110         execv (file, argv);
2111 
2112       if (errno == ENOEXEC)
<span class="line-modified">2113   script_execute (file, argv, envp);</span>
2114     }
2115   else
2116     {
2117       gboolean got_eacces = 0;
2118       const gchar *path, *p;
2119       gchar *name, *freeme;
2120       gsize len;
2121       gsize pathlen;
2122 
2123       path = NULL;
2124       if (search_path_from_envp)
2125         path = g_environ_getenv (envp, &quot;PATH&quot;);
2126       if (search_path &amp;&amp; path == NULL)
2127         path = g_getenv (&quot;PATH&quot;);
2128 
2129       if (path == NULL)
<span class="line-modified">2130   {</span>
<span class="line-modified">2131     /* There is no &#39;PATH&#39; in the environment.  The default</span>
<span class="line-modified">2132      * search path in libc is the current directory followed by</span>
<span class="line-modified">2133      * the path &#39;confstr&#39; returns for &#39;_CS_PATH&#39;.</span>
2134            */
2135 
2136           /* In GLib we put . last, for security, and don&#39;t use the
2137            * unportable confstr(); UNIX98 does not actually specify
2138            * what to search if PATH is unset. POSIX may, dunno.
2139            */
2140 
2141           path = &quot;/bin:/usr/bin:.&quot;;
<span class="line-modified">2142   }</span>
2143 
2144       len = strlen (file) + 1;
2145       pathlen = strlen (path);
2146       freeme = name = g_malloc (pathlen + len + 1);
2147 
2148       /* Copy the file name at the top, including &#39;\0&#39;  */
2149       memcpy (name + pathlen + 1, file, len);
2150       name = name + pathlen;
2151       /* And add the slash before the filename  */
2152       *name = &#39;/&#39;;
2153 
2154       p = path;
2155       do
<span class="line-modified">2156   {</span>
<span class="line-modified">2157     char *startp;</span>
2158 
<span class="line-modified">2159     path = p;</span>
<span class="line-modified">2160     p = my_strchrnul (path, &#39;:&#39;);</span>
2161 
<span class="line-modified">2162     if (p == path)</span>
<span class="line-modified">2163       /* Two adjacent colons, or a colon at the beginning or the end</span>
2164              * of &#39;PATH&#39; means to search the current directory.
2165              */
<span class="line-modified">2166       startp = name + 1;</span>
<span class="line-modified">2167     else</span>
<span class="line-modified">2168       startp = memcpy (name - (p - path), path, p - path);</span>
2169 
<span class="line-modified">2170     /* Try to execute this name.  If it works, execv will not return.  */</span>
2171           if (envp)
2172             execve (startp, argv, envp);
2173           else
2174             execv (startp, argv);
2175 
<span class="line-modified">2176     if (errno == ENOEXEC)</span>
<span class="line-modified">2177       script_execute (startp, argv, envp);</span>
2178 
<span class="line-modified">2179     switch (errno)</span>
<span class="line-modified">2180       {</span>
<span class="line-modified">2181       case EACCES:</span>
<span class="line-modified">2182         /* Record the we got a &#39;Permission denied&#39; error.  If we end</span>
2183                * up finding no executable we can use, we want to diagnose
2184                * that we did find one but were denied access.
2185                */
<span class="line-modified">2186         got_eacces = TRUE;</span>
2187 
2188               /* FALL THRU */
2189 
<span class="line-modified">2190       case ENOENT:</span>
2191 #ifdef ESTALE
<span class="line-modified">2192       case ESTALE:</span>
2193 #endif
2194 #ifdef ENOTDIR
<span class="line-modified">2195       case ENOTDIR:</span>
2196 #endif
<span class="line-modified">2197         /* Those errors indicate the file is missing or not executable</span>
2198                * by us, in which case we want to just try the next path
2199                * directory.
2200                */
<span class="line-modified">2201         break;</span>
2202 
<span class="line-modified">2203       case ENODEV:</span>
<span class="line-modified">2204       case ETIMEDOUT:</span>
<span class="line-modified">2205         /* Some strange filesystems like AFS return even</span>
<span class="line-modified">2206          * stranger error numbers.  They cannot reasonably mean anything</span>
<span class="line-modified">2207          * else so ignore those, too.</span>
<span class="line-modified">2208          */</span>
<span class="line-modified">2209         break;</span>
2210 
<span class="line-modified">2211       default:</span>
<span class="line-modified">2212         /* Some other error means we found an executable file, but</span>
2213                * something went wrong executing it; return the error to our
2214                * caller.
2215                */
2216               g_free (freeme);
<span class="line-modified">2217         return -1;</span>
<span class="line-modified">2218       }</span>
<span class="line-modified">2219   }</span>
2220       while (*p++ != &#39;\0&#39;);
2221 
2222       /* We tried every element and none of them worked.  */
2223       if (got_eacces)
<span class="line-modified">2224   /* At least one failure was due to permissions, so report that</span>
2225          * error.
2226          */
2227         errno = EACCES;
2228 
2229       g_free (freeme);
2230     }
2231 
2232   /* Return the error from the last attempt (probably ENOENT).  */
2233   return -1;
2234 }
2235 
2236 /**
2237  * g_spawn_close_pid:
2238  * @pid: The process reference to close
2239  *
2240  * On some platforms, notably Windows, the #GPid type represents a resource
2241  * which must be closed to prevent resource leaking. g_spawn_close_pid()
2242  * is provided for this purpose. It should be used on all platforms, even
2243  * though it doesn&#39;t do anything under UNIX.
2244  **/
</pre>
</td>
</tr>
</table>
<center><a href="gspawn-win32.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gspawn.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>