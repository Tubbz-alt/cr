<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant-core.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright � 2007, 2008 Ryan Lortie
   3  * Copyright � 2010 Codethink Limited
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public
  16  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  */
  18 
  19 #include &quot;config.h&quot;
  20 
  21 #include &lt;glib/gvariant-core.h&gt;
  22 
  23 #include &lt;glib/gvariant-internal.h&gt;
  24 #include &lt;glib/gvariant-serialiser.h&gt;
  25 #include &lt;glib/gtestutils.h&gt;
  26 #include &lt;glib/gbitlock.h&gt;
  27 #include &lt;glib/gatomic.h&gt;
  28 #include &lt;glib/gbytes.h&gt;
  29 #include &lt;glib/gslice.h&gt;
  30 #include &lt;glib/gmem.h&gt;
  31 #include &lt;string.h&gt;
  32 
  33 
  34 /*
  35  * This file includes the structure definition for GVariant and a small
  36  * set of functions that are allowed to access the structure directly.
  37  *
  38  * This minimises the amount of code that can possibly touch a GVariant
  39  * structure directly to a few simple fundamental operations.  These few
  40  * operations are written to be completely threadsafe with respect to
  41  * all possible outside access.  This means that we only need to be
  42  * concerned about thread safety issues in this one small file.
  43  *
  44  * Most GVariant API functions are in gvariant.c.
  45  */
  46 
  47 /**
  48  * GVariant:
  49  *
  50  * #GVariant is an opaque data structure and can only be accessed
  51  * using the following functions.
  52  *
  53  * Since: 2.24
  54  **/
  55 struct _GVariant
  56 /* see below for field member documentation */
  57 {
  58   GVariantTypeInfo *type_info;
  59   gsize size;
  60 
  61   union
  62   {
  63     struct
  64     {
  65       GBytes *bytes;
  66       gconstpointer data;
  67     } serialised;
  68 
  69     struct
  70     {
  71       GVariant **children;
  72       gsize n_children;
  73     } tree;
  74   } contents;
  75 
  76   gint state;
  77   gint ref_count;
  78   gsize depth;
  79 };
  80 
  81 /* struct GVariant:
  82  *
  83  * There are two primary forms of GVariant instances: &quot;serialised form&quot;
  84  * and &quot;tree form&quot;.
  85  *
  86  * &quot;serialised form&quot;: A serialised GVariant instance stores its value in
  87  *                    the GVariant serialisation format.  All
  88  *                    basic-typed instances (ie: non-containers) are in
  89  *                    serialised format, as are some containers.
  90  *
  91  * &quot;tree form&quot;: Some containers are in &quot;tree form&quot;.  In this case,
  92  *              instead of containing the serialised data for the
  93  *              container, the instance contains an array of pointers to
  94  *              the child values of the container (thus forming a tree).
  95  *
  96  * It is possible for an instance to transition from tree form to
  97  * serialised form.  This happens, implicitly, if the serialised data is
  98  * requested (eg: via g_variant_get_data()).  Serialised form instances
  99  * never transition into tree form.
 100  *
 101  *
 102  * The fields of the structure are documented here:
 103  *
 104  * type_info: this is a reference to a GVariantTypeInfo describing the
 105  *            type of the instance.  When the instance is freed, this
 106  *            reference must be released with g_variant_type_info_unref().
 107  *
 108  *            The type_info field never changes during the life of the
 109  *            instance, so it can be accessed without a lock.
 110  *
 111  * size: this is the size of the serialised form for the instance, if it
 112  *       is known.  If the instance is in serialised form then it is, by
 113  *       definition, known.  If the instance is in tree form then it may
 114  *       be unknown (in which case it is -1).  It is possible for the
 115  *       size to be known when in tree form if, for example, the user
 116  *       has called g_variant_get_size() without calling
 117  *       g_variant_get_data().  Additionally, even when the user calls
 118  *       g_variant_get_data() the size of the data must first be
 119  *       determined so that a large enough buffer can be allocated for
 120  *       the data.
 121  *
 122  *       Once the size is known, it can never become unknown again.
 123  *       g_variant_ensure_size() is used to ensure that the size is in
 124  *       the known state -- it calculates the size if needed.  After
 125  *       that, the size field can be accessed without a lock.
 126  *
 127  * contents: a union containing either the information associated with
 128  *           holding a value in serialised form or holding a value in
 129  *           tree form.
 130  *
 131  *   .serialised: Only valid when the instance is in serialised form.
 132  *
 133  *                Since an instance can never transition away from
 134  *                serialised form, once these fields are set, they will
 135  *                never be changed.  It is therefore valid to access
 136  *                them without holding a lock.
 137  *
 138  *     .bytes:  the #GBytes that contains the memory pointed to by
 139  *              .data, or %NULL if .data is %NULL.  In the event that
 140  *              the instance was deserialised from another instance,
 141  *              then the bytes will be shared by both of them.  When
 142  *              the instance is freed, this reference must be released
 143  *              with g_bytes_unref().
 144  *
 145  *     .data: the serialised data (of size &#39;size&#39;) of the instance.
 146  *            This pointer should not be freed or modified in any way.
 147  *            #GBytes is responsible for memory management.
 148  *
 149  *            This pointer may be %NULL in two cases:
 150  *
 151  *              - if the serialised size of the instance is 0
 152  *
 153  *              - if the instance is of a fixed-sized type and was
 154  *                deserialised out of a corrupted container such that
 155  *                the container contains too few bytes to point to the
 156  *                entire proper fixed-size of this instance.  In this
 157  *                case, &#39;size&#39; will still be equal to the proper fixed
 158  *                size, but this pointer will be %NULL.  This is exactly
 159  *                the reason that g_variant_get_data() sometimes returns
 160  *                %NULL.  For all other calls, the effect should be as
 161  *                if .data pointed to the appropriate number of nul
 162  *                bytes.
 163  *
 164  *   .tree: Only valid when the instance is in tree form.
 165  *
 166  *          Note that accesses from other threads could result in
 167  *          conversion of the instance from tree form to serialised form
 168  *          at any time.  For this reason, the instance lock must always
 169  *          be held while performing any operations on &#39;contents.tree&#39;.
 170  *
 171  *     .children: the array of the child instances of this instance.
 172  *                When the instance is freed (or converted to serialised
 173  *                form) then each child must have g_variant_unref()
 174  *                called on it and the array must be freed using
 175  *                g_free().
 176  *
 177  *     .n_children: the number of items in the .children array.
 178  *
 179  * state: a bitfield describing the state of the instance.  It is a
 180  *        bitwise-or of the following STATE_* constants:
 181  *
 182  *    STATE_LOCKED: the instance lock is held.  This is the bit used by
 183  *                  g_bit_lock().
 184  *
 185  *    STATE_SERIALISED: the instance is in serialised form.  If this
 186  *                      flag is not set then the instance is in tree
 187  *                      form.
 188  *
 189  *    STATE_TRUSTED: for serialised form instances, this means that the
 190  *                   serialised data is known to be in normal form (ie:
 191  *                   not corrupted).
 192  *
 193  *                   For tree form instances, this means that all of the
 194  *                   child instances in the contents.tree.children array
 195  *                   are trusted.  This means that if the container is
 196  *                   serialised then the resulting data will be in
 197  *                   normal form.
 198  *
 199  *                   If this flag is unset it does not imply that the
 200  *                   data is corrupted.  It merely means that we&#39;re not
 201  *                   sure that it&#39;s valid.  See g_variant_is_trusted().
 202  *
 203  *    STATE_FLOATING: if this flag is set then the object has a floating
 204  *                    reference.  See g_variant_ref_sink().
 205  *
 206  * ref_count: the reference count of the instance
 207  *
 208  * depth: the depth of the GVariant in a hierarchy of nested containers,
 209  *        increasing with the level of nesting. The top-most GVariant has depth
 210  *        zero.  This is used to avoid recursing too deeply and overflowing the
 211  *        stack when handling deeply nested untrusted serialised GVariants.
 212  */
 213 #define STATE_LOCKED     1
 214 #define STATE_SERIALISED 2
 215 #define STATE_TRUSTED    4
 216 #define STATE_FLOATING   8
 217 
 218 /* -- private -- */
 219 /* &lt; private &gt;
 220  * g_variant_lock:
 221  * @value: a #GVariant
 222  *
 223  * Locks @value for performing sensitive operations.
 224  */
 225 static void
 226 g_variant_lock (GVariant *value)
 227 {
 228   g_bit_lock (&amp;value-&gt;state, 0);
 229 }
 230 
 231 /* &lt; private &gt;
 232  * g_variant_unlock:
 233  * @value: a #GVariant
 234  *
 235  * Unlocks @value after performing sensitive operations.
 236  */
 237 static void
 238 g_variant_unlock (GVariant *value)
 239 {
 240   g_bit_unlock (&amp;value-&gt;state, 0);
 241 }
 242 
 243 /* &lt; private &gt;
 244  * g_variant_release_children:
 245  * @value: a #GVariant
 246  *
 247  * Releases the reference held on each child in the &#39;children&#39; array of
 248  * @value and frees the array itself.  @value must be in tree form.
 249  *
 250  * This is done when freeing a tree-form instance or converting it to
 251  * serialised form.
 252  *
 253  * The current thread must hold the lock on @value.
 254  */
 255 static void
 256 g_variant_release_children (GVariant *value)
 257 {
 258   gsize i;
 259 
 260   g_assert (value-&gt;state &amp; STATE_LOCKED);
 261   g_assert (~value-&gt;state &amp; STATE_SERIALISED);
 262 
 263   for (i = 0; i &lt; value-&gt;contents.tree.n_children; i++)
 264     g_variant_unref (value-&gt;contents.tree.children[i]);
 265 
 266   g_free (value-&gt;contents.tree.children);
 267 }
 268 
 269 /* This begins the main body of the recursive serialiser.
 270  *
 271  * There are 3 functions here that work as a team with the serialiser to
 272  * get things done.  g_variant_store() has a trivial role, but as a
 273  * public API function, it has its definition elsewhere.
 274  *
 275  * Note that &quot;serialisation&quot; of an instance does not mean that the
 276  * instance is converted to serialised form -- it means that the
 277  * serialised form of an instance is written to an external buffer.
 278  * g_variant_ensure_serialised() (which is not part of this set of
 279  * functions) is the function that is responsible for converting an
 280  * instance to serialised form.
 281  *
 282  * We are only concerned here with container types since non-container
 283  * instances are always in serialised form.  For these instances,
 284  * storing their serialised form merely involves a memcpy().
 285  *
 286  * Serialisation is a two-step process.  First, the size of the
 287  * serialised data must be calculated so that an appropriately-sized
 288  * buffer can be allocated.  Second, the data is written into the
 289  * buffer.
 290  *
 291  * Determining the size:
 292  *   The process of determining the size is triggered by a call to
 293  *   g_variant_ensure_size() on a container.  This invokes the
 294  *   serialiser code to determine the size.  The serialiser is passed
 295  *   g_variant_fill_gvs() as a callback.
 296  *
 297  *   g_variant_fill_gvs() is called by the serialiser on each child of
 298  *   the container which, in turn, calls g_variant_ensure_size() on
 299  *   itself and fills in the result of its own size calculation.
 300  *
 301  *   The serialiser uses the size information from the children to
 302  *   calculate the size needed for the entire container.
 303  *
 304  * Writing the data:
 305  *   After the buffer has been allocated, g_variant_serialise() is
 306  *   called on the container.  This invokes the serialiser code to write
 307  *   the bytes to the container.  The serialiser is, again, passed
 308  *   g_variant_fill_gvs() as a callback.
 309  *
 310  *   This time, when g_variant_fill_gvs() is called for each child, the
 311  *   child is given a pointer to a sub-region of the allocated buffer
 312  *   where it should write its data.  This is done by calling
 313  *   g_variant_store().  In the event that the instance is in serialised
 314  *   form this means a memcpy() of the serialised data into the
 315  *   allocated buffer.  In the event that the instance is in tree form
 316  *   this means a recursive call back into g_variant_serialise().
 317  *
 318  *
 319  * The forward declaration here allows corecursion via callback:
 320  */
 321 static void g_variant_fill_gvs (GVariantSerialised *, gpointer);
 322 
 323 /* &lt; private &gt;
 324  * g_variant_ensure_size:
 325  * @value: a #GVariant
 326  *
 327  * Ensures that the -&gt;size field of @value is filled in properly.  This
 328  * must be done as a precursor to any serialisation of the value in
 329  * order to know how large of a buffer is needed to store the data.
 330  *
 331  * The current thread must hold the lock on @value.
 332  */
 333 static void
 334 g_variant_ensure_size (GVariant *value)
 335 {
 336   g_assert (value-&gt;state &amp; STATE_LOCKED);
 337 
 338   if (value-&gt;size == (gssize) -1)
 339     {
 340       gpointer *children;
 341       gsize n_children;
 342 
 343       children = (gpointer *) value-&gt;contents.tree.children;
 344       n_children = value-&gt;contents.tree.n_children;
 345       value-&gt;size = g_variant_serialiser_needed_size (value-&gt;type_info,
 346                                                       g_variant_fill_gvs,
 347                                                       children, n_children);
 348     }
 349 }
 350 
 351 /* &lt; private &gt;
 352  * g_variant_serialise:
 353  * @value: a #GVariant
 354  * @data: an appropriately-sized buffer
 355  *
 356  * Serialises @value into @data.  @value must be in tree form.
 357  *
 358  * No change is made to @value.
 359  *
 360  * The current thread must hold the lock on @value.
 361  */
 362 static void
 363 g_variant_serialise (GVariant *value,
 364                      gpointer  data)
 365 {
 366   GVariantSerialised serialised = { 0, };
 367   gpointer *children;
 368   gsize n_children;
 369 
 370   g_assert (~value-&gt;state &amp; STATE_SERIALISED);
 371   g_assert (value-&gt;state &amp; STATE_LOCKED);
 372 
 373   serialised.type_info = value-&gt;type_info;
 374   serialised.size = value-&gt;size;
 375   serialised.data = data;
 376   serialised.depth = value-&gt;depth;
 377 
 378   children = (gpointer *) value-&gt;contents.tree.children;
 379   n_children = value-&gt;contents.tree.n_children;
 380 
 381   g_variant_serialiser_serialise (serialised, g_variant_fill_gvs,
 382                                   children, n_children);
 383 }
 384 
 385 /* &lt; private &gt;
 386  * g_variant_fill_gvs:
 387  * @serialised: a pointer to a #GVariantSerialised
 388  * @data: a #GVariant instance
 389  *
 390  * This is the callback that is passed by a tree-form container instance
 391  * to the serialiser.  This callback gets called on each child of the
 392  * container.  Each child is responsible for performing the following
 393  * actions:
 394  *
 395  *  - reporting its type
 396  *
 397  *  - reporting its serialised size (requires knowing the size first)
 398  *
 399  *  - possibly storing its serialised form into the provided buffer
 400  */
 401 static void
 402 g_variant_fill_gvs (GVariantSerialised *serialised,
 403                     gpointer            data)
 404 {
 405   GVariant *value = data;
 406 
 407   g_variant_lock (value);
 408   g_variant_ensure_size (value);
 409   g_variant_unlock (value);
 410 
 411   if (serialised-&gt;type_info == NULL)
 412     serialised-&gt;type_info = value-&gt;type_info;
 413   g_assert (serialised-&gt;type_info == value-&gt;type_info);
 414 
 415   if (serialised-&gt;size == 0)
 416     serialised-&gt;size = value-&gt;size;
 417   g_assert (serialised-&gt;size == value-&gt;size);
 418   serialised-&gt;depth = value-&gt;depth;
 419 
 420   if (serialised-&gt;data)
 421     /* g_variant_store() is a public API, so it
 422      * it will reacquire the lock if it needs to.
 423      */
 424     g_variant_store (value, serialised-&gt;data);
 425 }
 426 
 427 /* this ends the main body of the recursive serialiser */
 428 
 429 /* &lt; private &gt;
 430  * g_variant_ensure_serialised:
 431  * @value: a #GVariant
 432  *
 433  * Ensures that @value is in serialised form.
 434  *
 435  * If @value is in tree form then this function ensures that the
 436  * serialised size is known and then allocates a buffer of that size and
 437  * serialises the instance into the buffer.  The &#39;children&#39; array is
 438  * then released and the instance is set to serialised form based on the
 439  * contents of the buffer.
 440  *
 441  * The current thread must hold the lock on @value.
 442  */
 443 static void
 444 g_variant_ensure_serialised (GVariant *value)
 445 {
 446   g_assert (value-&gt;state &amp; STATE_LOCKED);
 447 
 448   if (~value-&gt;state &amp; STATE_SERIALISED)
 449     {
 450       GBytes *bytes;
 451       gpointer data;
 452 
 453       g_variant_ensure_size (value);
 454       data = g_malloc (value-&gt;size);
 455       g_variant_serialise (value, data);
 456 
 457       g_variant_release_children (value);
 458 
 459       bytes = g_bytes_new_take (data, value-&gt;size);
 460       value-&gt;contents.serialised.data = g_bytes_get_data (bytes, NULL);
 461       value-&gt;contents.serialised.bytes = bytes;
 462       value-&gt;state |= STATE_SERIALISED;
 463     }
 464 }
 465 
 466 /* &lt; private &gt;
 467  * g_variant_alloc:
 468  * @type: the type of the new instance
 469  * @serialised: if the instance will be in serialised form
 470  * @trusted: if the instance will be trusted
 471  *
 472  * Allocates a #GVariant instance and does some common work (such as
 473  * looking up and filling in the type info), setting the state field,
 474  * and setting the ref_count to 1.
 475  *
 476  * Returns: a new #GVariant with a floating reference
 477  */
 478 static GVariant *
 479 g_variant_alloc (const GVariantType *type,
 480                  gboolean            serialised,
 481                  gboolean            trusted)
 482 {
 483   GVariant *value;
 484 
 485   value = g_slice_new (GVariant);
 486 #ifdef GSTREAMER_LITE
 487   if (value == NULL) {
 488     return NULL;
 489   }
 490 #endif // GSTREAMER_LITE
 491   value-&gt;type_info = g_variant_type_info_get (type);
 492   value-&gt;state = (serialised ? STATE_SERIALISED : 0) |
 493                  (trusted ? STATE_TRUSTED : 0) |
 494                  STATE_FLOATING;
 495   value-&gt;size = (gssize) -1;
 496   value-&gt;ref_count = 1;
 497   value-&gt;depth = 0;
 498 
 499   return value;
 500 }
 501 
 502 /**
 503  * g_variant_new_from_bytes:
 504  * @type: a #GVariantType
 505  * @bytes: a #GBytes
 506  * @trusted: if the contents of @bytes are trusted
 507  *
 508  * Constructs a new serialised-mode #GVariant instance.  This is the
 509  * inner interface for creation of new serialised values that gets
 510  * called from various functions in gvariant.c.
 511  *
 512  * A reference is taken on @bytes.
 513  *
 514  * Returns: (transfer none): a new #GVariant with a floating reference
 515  *
 516  * Since: 2.36
 517  */
 518 GVariant *
 519 g_variant_new_from_bytes (const GVariantType *type,
 520                           GBytes             *bytes,
 521                           gboolean            trusted)
 522 {
 523   GVariant *value;
 524   guint alignment;
 525   gsize size;
 526 
 527   value = g_variant_alloc (type, TRUE, trusted);
 528 #ifdef GSTREAMER_LITE
 529   if (value == NULL) {
 530     return NULL;
 531   }
 532 #endif // GSTREAMER_LITE
 533 
 534   value-&gt;contents.serialised.bytes = g_bytes_ref (bytes);
 535 
 536   g_variant_type_info_query (value-&gt;type_info,
 537                              &amp;alignment, &amp;size);
 538 
 539   if (size &amp;&amp; g_bytes_get_size (bytes) != size)
 540     {
 541       /* Creating a fixed-sized GVariant with a bytes of the wrong
 542        * size.
 543        *
 544        * We should do the equivalent of pulling a fixed-sized child out
 545        * of a brozen container (ie: data is NULL size is equal to the correct
 546        * fixed size).
 547        */
 548       value-&gt;contents.serialised.data = NULL;
 549       value-&gt;size = size;
 550     }
 551   else
 552     {
 553       value-&gt;contents.serialised.data = g_bytes_get_data (bytes, &amp;value-&gt;size);
 554     }
 555 
 556   return value;
 557 }
 558 
 559 /* -- internal -- */
 560 
 561 /* &lt; internal &gt;
 562  * g_variant_new_from_children:
 563  * @type: a #GVariantType
 564  * @children: an array of #GVariant pointers.  Consumed.
 565  * @n_children: the length of @children
 566  * @trusted: %TRUE if every child in @children in trusted
 567  *
 568  * Constructs a new tree-mode #GVariant instance.  This is the inner
 569  * interface for creation of new serialised values that gets called from
 570  * various functions in gvariant.c.
 571  *
 572  * @children is consumed by this function.  g_free() will be called on
 573  * it some time later.
 574  *
 575  * Returns: a new #GVariant with a floating reference
 576  */
 577 GVariant *
 578 g_variant_new_from_children (const GVariantType  *type,
 579                              GVariant           **children,
 580                              gsize                n_children,
 581                              gboolean             trusted)
 582 {
 583   GVariant *value;
 584 
 585   value = g_variant_alloc (type, FALSE, trusted);
 586 #ifdef GSTREAMER_LITE
 587   if (value == NULL) {
 588     return NULL;
 589   }
 590 #endif // GSTREAMER_LITE
 591   value-&gt;contents.tree.children = children;
 592   value-&gt;contents.tree.n_children = n_children;
 593 
 594   return value;
 595 }
 596 
 597 /* &lt; internal &gt;
 598  * g_variant_get_type_info:
 599  * @value: a #GVariant
 600  *
 601  * Returns the #GVariantTypeInfo corresponding to the type of @value.  A
 602  * reference is not added, so the return value is only good for the
 603  * duration of the life of @value.
 604  *
 605  * Returns: the #GVariantTypeInfo for @value
 606  */
 607 GVariantTypeInfo *
 608 g_variant_get_type_info (GVariant *value)
 609 {
 610   return value-&gt;type_info;
 611 }
 612 
 613 /* &lt; internal &gt;
 614  * g_variant_is_trusted:
 615  * @value: a #GVariant
 616  *
 617  * Determines if @value is trusted by #GVariant to contain only
 618  * fully-valid data.  All values constructed solely via #GVariant APIs
 619  * are trusted, but values containing data read in from other sources
 620  * are usually not trusted.
 621  *
 622  * The main advantage of trusted data is that certain checks can be
 623  * skipped.  For example, we don&#39;t need to check that a string is
 624  * properly nul-terminated or that an object path is actually a
 625  * properly-formatted object path.
 626  *
 627  * Returns: if @value is trusted
 628  */
 629 gboolean
 630 g_variant_is_trusted (GVariant *value)
 631 {
 632   return (value-&gt;state &amp; STATE_TRUSTED) != 0;
 633 }
 634 
 635 /* -- public -- */
 636 
 637 /**
 638  * g_variant_unref:
 639  * @value: a #GVariant
 640  *
 641  * Decreases the reference count of @value.  When its reference count
 642  * drops to 0, the memory used by the variant is freed.
 643  *
 644  * Since: 2.24
 645  **/
 646 void
 647 g_variant_unref (GVariant *value)
 648 {
 649   g_return_if_fail (value != NULL);
 650   g_return_if_fail (value-&gt;ref_count &gt; 0);
 651 
 652   if (g_atomic_int_dec_and_test (&amp;value-&gt;ref_count))
 653     {
 654       if G_UNLIKELY (value-&gt;state &amp; STATE_LOCKED)
 655         g_critical (&quot;attempting to free a locked GVariant instance.  &quot;
 656                     &quot;This should never happen.&quot;);
 657 
 658       value-&gt;state |= STATE_LOCKED;
 659 
 660       g_variant_type_info_unref (value-&gt;type_info);
 661 
 662       if (value-&gt;state &amp; STATE_SERIALISED)
 663         g_bytes_unref (value-&gt;contents.serialised.bytes);
 664       else
 665         g_variant_release_children (value);
 666 
 667       memset (value, 0, sizeof (GVariant));
 668       g_slice_free (GVariant, value);
 669     }
 670 }
 671 
 672 /**
 673  * g_variant_ref:
 674  * @value: a #GVariant
 675  *
 676  * Increases the reference count of @value.
 677  *
 678  * Returns: the same @value
 679  *
 680  * Since: 2.24
 681  **/
 682 GVariant *
 683 g_variant_ref (GVariant *value)
 684 {
 685   g_return_val_if_fail (value != NULL, NULL);
 686   g_return_val_if_fail (value-&gt;ref_count &gt; 0, NULL);
 687 
 688   g_atomic_int_inc (&amp;value-&gt;ref_count);
 689 
 690   return value;
 691 }
 692 
 693 /**
 694  * g_variant_ref_sink:
 695  * @value: a #GVariant
 696  *
 697  * #GVariant uses a floating reference count system.  All functions with
 698  * names starting with `g_variant_new_` return floating
 699  * references.
 700  *
 701  * Calling g_variant_ref_sink() on a #GVariant with a floating reference
 702  * will convert the floating reference into a full reference.  Calling
 703  * g_variant_ref_sink() on a non-floating #GVariant results in an
 704  * additional normal reference being added.
 705  *
 706  * In other words, if the @value is floating, then this call &quot;assumes
 707  * ownership&quot; of the floating reference, converting it to a normal
 708  * reference.  If the @value is not floating, then this call adds a
 709  * new normal reference increasing the reference count by one.
 710  *
 711  * All calls that result in a #GVariant instance being inserted into a
 712  * container will call g_variant_ref_sink() on the instance.  This means
 713  * that if the value was just created (and has only its floating
 714  * reference) then the container will assume sole ownership of the value
 715  * at that point and the caller will not need to unreference it.  This
 716  * makes certain common styles of programming much easier while still
 717  * maintaining normal refcounting semantics in situations where values
 718  * are not floating.
 719  *
 720  * Returns: the same @value
 721  *
 722  * Since: 2.24
 723  **/
 724 GVariant *
 725 g_variant_ref_sink (GVariant *value)
 726 {
 727   g_return_val_if_fail (value != NULL, NULL);
 728   g_return_val_if_fail (value-&gt;ref_count &gt; 0, NULL);
 729 
 730   g_variant_lock (value);
 731 
 732   if (~value-&gt;state &amp; STATE_FLOATING)
 733     g_variant_ref (value);
 734   else
 735     value-&gt;state &amp;= ~STATE_FLOATING;
 736 
 737   g_variant_unlock (value);
 738 
 739   return value;
 740 }
 741 
 742 /**
 743  * g_variant_take_ref:
 744  * @value: a #GVariant
 745  *
 746  * If @value is floating, sink it.  Otherwise, do nothing.
 747  *
 748  * Typically you want to use g_variant_ref_sink() in order to
 749  * automatically do the correct thing with respect to floating or
 750  * non-floating references, but there is one specific scenario where
 751  * this function is helpful.
 752  *
 753  * The situation where this function is helpful is when creating an API
 754  * that allows the user to provide a callback function that returns a
 755  * #GVariant.  We certainly want to allow the user the flexibility to
 756  * return a non-floating reference from this callback (for the case
 757  * where the value that is being returned already exists).
 758  *
 759  * At the same time, the style of the #GVariant API makes it likely that
 760  * for newly-created #GVariant instances, the user can be saved some
 761  * typing if they are allowed to return a #GVariant with a floating
 762  * reference.
 763  *
 764  * Using this function on the return value of the user&#39;s callback allows
 765  * the user to do whichever is more convenient for them.  The caller
 766  * will alway receives exactly one full reference to the value: either
 767  * the one that was returned in the first place, or a floating reference
 768  * that has been converted to a full reference.
 769  *
 770  * This function has an odd interaction when combined with
 771  * g_variant_ref_sink() running at the same time in another thread on
 772  * the same #GVariant instance.  If g_variant_ref_sink() runs first then
 773  * the result will be that the floating reference is converted to a hard
 774  * reference.  If g_variant_take_ref() runs first then the result will
 775  * be that the floating reference is converted to a hard reference and
 776  * an additional reference on top of that one is added.  It is best to
 777  * avoid this situation.
 778  *
 779  * Returns: the same @value
 780  **/
 781 GVariant *
 782 g_variant_take_ref (GVariant *value)
 783 {
 784   g_return_val_if_fail (value != NULL, NULL);
 785   g_return_val_if_fail (value-&gt;ref_count &gt; 0, NULL);
 786 
 787   g_atomic_int_and (&amp;value-&gt;state, ~STATE_FLOATING);
 788 
 789   return value;
 790 }
 791 
 792 /**
 793  * g_variant_is_floating:
 794  * @value: a #GVariant
 795  *
 796  * Checks whether @value has a floating reference count.
 797  *
 798  * This function should only ever be used to assert that a given variant
 799  * is or is not floating, or for debug purposes. To acquire a reference
 800  * to a variant that might be floating, always use g_variant_ref_sink()
 801  * or g_variant_take_ref().
 802  *
 803  * See g_variant_ref_sink() for more information about floating reference
 804  * counts.
 805  *
 806  * Returns: whether @value is floating
 807  *
 808  * Since: 2.26
 809  **/
 810 gboolean
 811 g_variant_is_floating (GVariant *value)
 812 {
 813   g_return_val_if_fail (value != NULL, FALSE);
 814 
 815   return (value-&gt;state &amp; STATE_FLOATING) != 0;
 816 }
 817 
 818 /**
 819  * g_variant_get_size:
 820  * @value: a #GVariant instance
 821  *
 822  * Determines the number of bytes that would be required to store @value
 823  * with g_variant_store().
 824  *
 825  * If @value has a fixed-sized type then this function always returned
 826  * that fixed size.
 827  *
 828  * In the case that @value is already in serialised form or the size has
 829  * already been calculated (ie: this function has been called before)
 830  * then this function is O(1).  Otherwise, the size is calculated, an
 831  * operation which is approximately O(n) in the number of values
 832  * involved.
 833  *
 834  * Returns: the serialised size of @value
 835  *
 836  * Since: 2.24
 837  **/
 838 gsize
 839 g_variant_get_size (GVariant *value)
 840 {
 841   g_variant_lock (value);
 842   g_variant_ensure_size (value);
 843   g_variant_unlock (value);
 844 
 845   return value-&gt;size;
 846 }
 847 
 848 /**
 849  * g_variant_get_data:
 850  * @value: a #GVariant instance
 851  *
 852  * Returns a pointer to the serialised form of a #GVariant instance.
 853  * The returned data may not be in fully-normalised form if read from an
 854  * untrusted source.  The returned data must not be freed; it remains
 855  * valid for as long as @value exists.
 856  *
 857  * If @value is a fixed-sized value that was deserialised from a
 858  * corrupted serialised container then %NULL may be returned.  In this
 859  * case, the proper thing to do is typically to use the appropriate
 860  * number of nul bytes in place of @value.  If @value is not fixed-sized
 861  * then %NULL is never returned.
 862  *
 863  * In the case that @value is already in serialised form, this function
 864  * is O(1).  If the value is not already in serialised form,
 865  * serialisation occurs implicitly and is approximately O(n) in the size
 866  * of the result.
 867  *
 868  * To deserialise the data returned by this function, in addition to the
 869  * serialised data, you must know the type of the #GVariant, and (if the
 870  * machine might be different) the endianness of the machine that stored
 871  * it. As a result, file formats or network messages that incorporate
 872  * serialised #GVariants must include this information either
 873  * implicitly (for instance &quot;the file always contains a
 874  * %G_VARIANT_TYPE_VARIANT and it is always in little-endian order&quot;) or
 875  * explicitly (by storing the type and/or endianness in addition to the
 876  * serialised data).
 877  *
 878  * Returns: (transfer none): the serialised form of @value, or %NULL
 879  *
 880  * Since: 2.24
 881  **/
 882 gconstpointer
 883 g_variant_get_data (GVariant *value)
 884 {
 885   g_variant_lock (value);
 886   g_variant_ensure_serialised (value);
 887   g_variant_unlock (value);
 888 
 889   return value-&gt;contents.serialised.data;
 890 }
 891 
 892 /**
 893  * g_variant_get_data_as_bytes:
 894  * @value: a #GVariant
 895  *
 896  * Returns a pointer to the serialised form of a #GVariant instance.
 897  * The semantics of this function are exactly the same as
 898  * g_variant_get_data(), except that the returned #GBytes holds
 899  * a reference to the variant data.
 900  *
 901  * Returns: (transfer full): A new #GBytes representing the variant data
 902  *
 903  * Since: 2.36
 904  */
 905 GBytes *
 906 g_variant_get_data_as_bytes (GVariant *value)
 907 {
 908   const gchar *bytes_data;
 909   const gchar *data;
 910   gsize bytes_size;
 911   gsize size;
 912 
 913   g_variant_lock (value);
 914   g_variant_ensure_serialised (value);
 915   g_variant_unlock (value);
 916 
 917   bytes_data = g_bytes_get_data (value-&gt;contents.serialised.bytes, &amp;bytes_size);
 918   data = value-&gt;contents.serialised.data;
 919   size = value-&gt;size;
 920 
 921   if (data == bytes_data &amp;&amp; size == bytes_size)
 922     return g_bytes_ref (value-&gt;contents.serialised.bytes);
 923   else
 924     return g_bytes_new_from_bytes (value-&gt;contents.serialised.bytes,
 925                                    data - bytes_data, size);
 926 }
 927 
 928 
 929 /**
 930  * g_variant_n_children:
 931  * @value: a container #GVariant
 932  *
 933  * Determines the number of children in a container #GVariant instance.
 934  * This includes variants, maybes, arrays, tuples and dictionary
 935  * entries.  It is an error to call this function on any other type of
 936  * #GVariant.
 937  *
 938  * For variants, the return value is always 1.  For values with maybe
 939  * types, it is always zero or one.  For arrays, it is the length of the
 940  * array.  For tuples it is the number of tuple items (which depends
 941  * only on the type).  For dictionary entries, it is always 2
 942  *
 943  * This function is O(1).
 944  *
 945  * Returns: the number of children in the container
 946  *
 947  * Since: 2.24
 948  **/
 949 gsize
 950 g_variant_n_children (GVariant *value)
 951 {
 952   gsize n_children;
 953 
 954 #ifdef GSTREAMER_LITE
 955   if (value == NULL) {
 956     return 0;
 957   }
 958 #endif // GSTREAMER_LITE
 959 
 960   g_variant_lock (value);
 961 
 962   if (value-&gt;state &amp; STATE_SERIALISED)
 963     {
 964       GVariantSerialised serialised = {
 965         value-&gt;type_info,
 966         (gpointer) value-&gt;contents.serialised.data,
 967         value-&gt;size,
 968         value-&gt;depth,
 969       };
 970 
 971       n_children = g_variant_serialised_n_children (serialised);
 972     }
 973   else
 974     n_children = value-&gt;contents.tree.n_children;
 975 
 976   g_variant_unlock (value);
 977 
 978   return n_children;
 979 }
 980 
 981 /**
 982  * g_variant_get_child_value:
 983  * @value: a container #GVariant
 984  * @index_: the index of the child to fetch
 985  *
 986  * Reads a child item out of a container #GVariant instance.  This
 987  * includes variants, maybes, arrays, tuples and dictionary
 988  * entries.  It is an error to call this function on any other type of
 989  * #GVariant.
 990  *
 991  * It is an error if @index_ is greater than the number of child items
 992  * in the container.  See g_variant_n_children().
 993  *
 994  * The returned value is never floating.  You should free it with
 995  * g_variant_unref() when you&#39;re done with it.
 996  *
 997  * There may be implementation specific restrictions on deeply nested values,
 998  * which would result in the unit tuple being returned as the child value,
 999  * instead of further nested children. #GVariant is guaranteed to handle
1000  * nesting up to at least 64 levels.
1001  *
1002  * This function is O(1).
1003  *
1004  * Returns: (transfer full): the child at the specified index
1005  *
1006  * Since: 2.24
1007  **/
1008 GVariant *
1009 g_variant_get_child_value (GVariant *value,
1010                            gsize     index_)
1011 {
1012   g_return_val_if_fail (index_ &lt; g_variant_n_children (value), NULL);
1013   g_return_val_if_fail (value-&gt;depth &lt; G_MAXSIZE, NULL);
1014 
1015   if (~g_atomic_int_get (&amp;value-&gt;state) &amp; STATE_SERIALISED)
1016     {
1017       g_variant_lock (value);
1018 
1019       if (~value-&gt;state &amp; STATE_SERIALISED)
1020         {
1021           GVariant *child;
1022 
1023           child = g_variant_ref (value-&gt;contents.tree.children[index_]);
1024           g_variant_unlock (value);
1025 
1026           return child;
1027         }
1028 
1029       g_variant_unlock (value);
1030     }
1031 
1032   {
1033     GVariantSerialised serialised = {
1034       value-&gt;type_info,
1035       (gpointer) value-&gt;contents.serialised.data,
1036       value-&gt;size,
1037       value-&gt;depth,
1038     };
1039     GVariantSerialised s_child;
1040     GVariant *child;
1041 
1042     /* get the serialiser to extract the serialised data for the child
1043      * from the serialised data for the container
1044      */
1045     s_child = g_variant_serialised_get_child (serialised, index_);
1046 
1047     /* Check whether this would cause nesting too deep. If so, return a fake
1048      * child. The only situation we expect this to happen in is with a variant,
1049      * as all other deeply-nested types have a static type, and hence should
1050      * have been rejected earlier. In the case of a variant whose nesting plus
1051      * the depth of its child is too great, return a unit variant () instead of
1052      * the real child. */
1053     if (!(value-&gt;state &amp; STATE_TRUSTED) &amp;&amp;
1054         g_variant_type_info_query_depth (s_child.type_info) &gt;=
1055         G_VARIANT_MAX_RECURSION_DEPTH - value-&gt;depth)
1056       {
1057         g_assert (g_variant_is_of_type (value, G_VARIANT_TYPE_VARIANT));
1058         return g_variant_new_tuple (NULL, 0);
1059       }
1060 
1061     /* create a new serialised instance out of it */
1062     child = g_slice_new (GVariant);
1063 #ifdef GSTREAMER_LITE
1064     if (child == NULL) {
1065       return NULL;
1066     }
1067 #endif // GSTREAMER_LITE
1068     child-&gt;type_info = s_child.type_info;
1069     child-&gt;state = (value-&gt;state &amp; STATE_TRUSTED) |
1070                    STATE_SERIALISED;
1071     child-&gt;size = s_child.size;
1072     child-&gt;ref_count = 1;
1073     child-&gt;depth = value-&gt;depth + 1;
1074     child-&gt;contents.serialised.bytes =
1075       g_bytes_ref (value-&gt;contents.serialised.bytes);
1076     child-&gt;contents.serialised.data = s_child.data;
1077 
1078     return child;
1079   }
1080 }
1081 
1082 /**
1083  * g_variant_store:
1084  * @value: the #GVariant to store
1085  * @data: (not nullable): the location to store the serialised data at
1086  *
1087  * Stores the serialised form of @value at @data.  @data should be
1088  * large enough.  See g_variant_get_size().
1089  *
1090  * The stored data is in machine native byte order but may not be in
1091  * fully-normalised form if read from an untrusted source.  See
1092  * g_variant_get_normal_form() for a solution.
1093  *
1094  * As with g_variant_get_data(), to be able to deserialise the
1095  * serialised variant successfully, its type and (if the destination
1096  * machine might be different) its endianness must also be available.
1097  *
1098  * This function is approximately O(n) in the size of @data.
1099  *
1100  * Since: 2.24
1101  **/
1102 void
1103 g_variant_store (GVariant *value,
1104                  gpointer  data)
1105 {
1106   g_variant_lock (value);
1107 
1108   if (value-&gt;state &amp; STATE_SERIALISED)
1109     {
1110       if (value-&gt;contents.serialised.data != NULL)
1111         memcpy (data, value-&gt;contents.serialised.data, value-&gt;size);
1112       else
1113         memset (data, 0, value-&gt;size);
1114     }
1115   else
1116     g_variant_serialise (value, data);
1117 
1118   g_variant_unlock (value);
1119 }
1120 
1121 /**
1122  * g_variant_is_normal_form:
1123  * @value: a #GVariant instance
1124  *
1125  * Checks if @value is in normal form.
1126  *
1127  * The main reason to do this is to detect if a given chunk of
1128  * serialised data is in normal form: load the data into a #GVariant
1129  * using g_variant_new_from_data() and then use this function to
1130  * check.
1131  *
1132  * If @value is found to be in normal form then it will be marked as
1133  * being trusted.  If the value was already marked as being trusted then
1134  * this function will immediately return %TRUE.
1135  *
1136  * There may be implementation specific restrictions on deeply nested values.
1137  * GVariant is guaranteed to handle nesting up to at least 64 levels.
1138  *
1139  * Returns: %TRUE if @value is in normal form
1140  *
1141  * Since: 2.24
1142  **/
1143 gboolean
1144 g_variant_is_normal_form (GVariant *value)
1145 {
1146   if (value-&gt;state &amp; STATE_TRUSTED)
1147     return TRUE;
1148 
1149   g_variant_lock (value);
1150 
1151   if (value-&gt;depth &gt;= G_VARIANT_MAX_RECURSION_DEPTH)
1152     return FALSE;
1153 
1154   if (value-&gt;state &amp; STATE_SERIALISED)
1155     {
1156       GVariantSerialised serialised = {
1157         value-&gt;type_info,
1158         (gpointer) value-&gt;contents.serialised.data,
1159         value-&gt;size,
1160         value-&gt;depth
1161       };
1162 
1163       if (g_variant_serialised_is_normal (serialised))
1164         value-&gt;state |= STATE_TRUSTED;
1165     }
1166   else
1167     {
1168       gboolean normal = TRUE;
1169       gsize i;
1170 
1171       for (i = 0; i &lt; value-&gt;contents.tree.n_children; i++)
1172         normal &amp;= g_variant_is_normal_form (value-&gt;contents.tree.children[i]);
1173 
1174       if (normal)
1175         value-&gt;state |= STATE_TRUSTED;
1176     }
1177 
1178   g_variant_unlock (value);
1179 
1180   return (value-&gt;state &amp; STATE_TRUSTED) != 0;
1181 }
    </pre>
  </body>
</html>