<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstbasesrc.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *               2000,2005 Wim Taymans &lt;wim@fluendo.com&gt;
   4  *
   5  * gstbasesrc.c:
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Library General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Library General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Library General Public
  18  * License along with this library; if not, write to the
  19  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  20  * Boston, MA 02110-1301, USA.
  21  */
  22 
  23 /**
  24  * SECTION:gstbasesrc
  25  * @title: GstBaseSrc
  26  * @short_description: Base class for getrange based source elements
  27  * @see_also: #GstPushSrc, #GstBaseTransform, #GstBaseSink
  28  *
  29  * This is a generic base class for source elements. The following
  30  * types of sources are supported:
  31  *
  32  *   * random access sources like files
  33  *   * seekable sources
  34  *   * live sources
  35  *
  36  * The source can be configured to operate in any #GstFormat with the
  37  * gst_base_src_set_format() method. The currently set format determines
  38  * the format of the internal #GstSegment and any %GST_EVENT_SEGMENT
  39  * events. The default format for #GstBaseSrc is %GST_FORMAT_BYTES.
  40  *
  41  * #GstBaseSrc always supports push mode scheduling. If the following
  42  * conditions are met, it also supports pull mode scheduling:
  43  *
  44  *   * The format is set to %GST_FORMAT_BYTES (default).
  45  *   * #GstBaseSrcClass.is_seekable() returns %TRUE.
  46  *
  47  * If all the conditions are met for operating in pull mode, #GstBaseSrc is
  48  * automatically seekable in push mode as well. The following conditions must
  49  * be met to make the element seekable in push mode when the format is not
  50  * %GST_FORMAT_BYTES:
  51  *
  52  * * #GstBaseSrcClass.is_seekable() returns %TRUE.
  53  * * #GstBaseSrcClass.query() can convert all supported seek formats to the
  54  *   internal format as set with gst_base_src_set_format().
  55  * * #GstBaseSrcClass.do_seek() is implemented, performs the seek and returns
  56  *    %TRUE.
  57  *
  58  * When the element does not meet the requirements to operate in pull mode, the
  59  * offset and length in the #GstBaseSrcClass.create() method should be ignored.
  60  * It is recommended to subclass #GstPushSrc instead, in this situation. If the
  61  * element can operate in pull mode but only with specific offsets and
  62  * lengths, it is allowed to generate an error when the wrong values are passed
  63  * to the #GstBaseSrcClass.create() function.
  64  *
  65  * #GstBaseSrc has support for live sources. Live sources are sources that when
  66  * paused discard data, such as audio or video capture devices. A typical live
  67  * source also produces data at a fixed rate and thus provides a clock to publish
  68  * this rate.
  69  * Use gst_base_src_set_live() to activate the live source mode.
  70  *
  71  * A live source does not produce data in the PAUSED state. This means that the
  72  * #GstBaseSrcClass.create() method will not be called in PAUSED but only in
  73  * PLAYING. To signal the pipeline that the element will not produce data, the
  74  * return value from the READY to PAUSED state will be
  75  * %GST_STATE_CHANGE_NO_PREROLL.
  76  *
  77  * A typical live source will timestamp the buffers it creates with the
  78  * current running time of the pipeline. This is one reason why a live source
  79  * can only produce data in the PLAYING state, when the clock is actually
  80  * distributed and running.
  81  *
  82  * Live sources that synchronize and block on the clock (an audio source, for
  83  * example) can use gst_base_src_wait_playing() when the
  84  * #GstBaseSrcClass.create() function was interrupted by a state change to
  85  * PAUSED.
  86  *
  87  * The #GstBaseSrcClass.get_times() method can be used to implement pseudo-live
  88  * sources. It only makes sense to implement the #GstBaseSrcClass.get_times()
  89  * function if the source is a live source. The #GstBaseSrcClass.get_times()
  90  * function should return timestamps starting from 0, as if it were a non-live
  91  * source. The base class will make sure that the timestamps are transformed
  92  * into the current running_time. The base source will then wait for the
  93  * calculated running_time before pushing out the buffer.
  94  *
  95  * For live sources, the base class will by default report a latency of 0.
  96  * For pseudo live sources, the base class will by default measure the difference
  97  * between the first buffer timestamp and the start time of get_times and will
  98  * report this value as the latency.
  99  * Subclasses should override the query function when this behaviour is not
 100  * acceptable.
 101  *
 102  * There is only support in #GstBaseSrc for exactly one source pad, which
 103  * should be named &quot;src&quot;. A source implementation (subclass of #GstBaseSrc)
 104  * should install a pad template in its class_init function, like so:
 105  * |[&lt;!-- language=&quot;C&quot; --&gt;
 106  * static void
 107  * my_element_class_init (GstMyElementClass *klass)
 108  * {
 109  *   GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
 110  *   // srctemplate should be a #GstStaticPadTemplate with direction
 111  *   // %GST_PAD_SRC and name &quot;src&quot;
 112  *   gst_element_class_add_static_pad_template (gstelement_class, &amp;amp;srctemplate);
 113  *
 114  *   gst_element_class_set_static_metadata (gstelement_class,
 115  *      &quot;Source name&quot;,
 116  *      &quot;Source&quot;,
 117  *      &quot;My Source element&quot;,
 118  *      &quot;The author &lt;my.sink@my.email&gt;&quot;);
 119  * }
 120  * ]|
 121  *
 122  * ## Controlled shutdown of live sources in applications
 123  *
 124  * Applications that record from a live source may want to stop recording
 125  * in a controlled way, so that the recording is stopped, but the data
 126  * already in the pipeline is processed to the end (remember that many live
 127  * sources would go on recording forever otherwise). For that to happen the
 128  * application needs to make the source stop recording and send an EOS
 129  * event down the pipeline. The application would then wait for an
 130  * EOS message posted on the pipeline&#39;s bus to know when all data has
 131  * been processed and the pipeline can safely be stopped.
 132  *
 133  * An application may send an EOS event to a source element to make it
 134  * perform the EOS logic (send EOS event downstream or post a
 135  * %GST_MESSAGE_SEGMENT_DONE on the bus). This can typically be done
 136  * with the gst_element_send_event() function on the element or its parent bin.
 137  *
 138  * After the EOS has been sent to the element, the application should wait for
 139  * an EOS message to be posted on the pipeline&#39;s bus. Once this EOS message is
 140  * received, it may safely shut down the entire pipeline.
 141  *
 142  */
 143 
 144 #ifdef HAVE_CONFIG_H
 145 #  include &quot;config.h&quot;
 146 #endif
 147 
 148 #include &lt;stdlib.h&gt;
 149 #include &lt;string.h&gt;
 150 
 151 #include &lt;gst/gst_private.h&gt;
 152 #include &lt;gst/glib-compat-private.h&gt;
 153 
 154 #include &quot;gstbasesrc.h&quot;
 155 #include &lt;gst/gst-i18n-lib.h&gt;
 156 
 157 GST_DEBUG_CATEGORY_STATIC (gst_base_src_debug);
 158 #define GST_CAT_DEFAULT gst_base_src_debug
 159 
 160 #define GST_LIVE_GET_LOCK(elem)               (&amp;GST_BASE_SRC_CAST(elem)-&gt;live_lock)
 161 #define GST_LIVE_LOCK(elem)                   g_mutex_lock(GST_LIVE_GET_LOCK(elem))
 162 #define GST_LIVE_TRYLOCK(elem)                g_mutex_trylock(GST_LIVE_GET_LOCK(elem))
 163 #define GST_LIVE_UNLOCK(elem)                 g_mutex_unlock(GST_LIVE_GET_LOCK(elem))
 164 #define GST_LIVE_GET_COND(elem)               (&amp;GST_BASE_SRC_CAST(elem)-&gt;live_cond)
 165 #define GST_LIVE_WAIT(elem)                   g_cond_wait (GST_LIVE_GET_COND (elem), GST_LIVE_GET_LOCK (elem))
 166 #define GST_LIVE_WAIT_UNTIL(elem, end_time)   g_cond_timed_wait (GST_LIVE_GET_COND (elem), GST_LIVE_GET_LOCK (elem), end_time)
 167 #define GST_LIVE_SIGNAL(elem)                 g_cond_signal (GST_LIVE_GET_COND (elem));
 168 #define GST_LIVE_BROADCAST(elem)              g_cond_broadcast (GST_LIVE_GET_COND (elem));
 169 
 170 
 171 #define GST_ASYNC_GET_COND(elem)              (&amp;GST_BASE_SRC_CAST(elem)-&gt;priv-&gt;async_cond)
 172 #define GST_ASYNC_WAIT(elem)                  g_cond_wait (GST_ASYNC_GET_COND (elem), GST_OBJECT_GET_LOCK (elem))
 173 #define GST_ASYNC_SIGNAL(elem)                g_cond_signal (GST_ASYNC_GET_COND (elem));
 174 
 175 #define CLEAR_PENDING_EOS(bsrc) \
 176   G_STMT_START { \
 177     g_atomic_int_set (&amp;bsrc-&gt;priv-&gt;has_pending_eos, FALSE); \
 178     gst_event_replace (&amp;bsrc-&gt;priv-&gt;pending_eos, NULL); \
 179   } G_STMT_END
 180 
 181 
 182 /* BaseSrc signals and args */
 183 enum
 184 {
 185   /* FILL ME */
 186   LAST_SIGNAL
 187 };
 188 
 189 #define DEFAULT_BLOCKSIZE       4096
 190 #define DEFAULT_NUM_BUFFERS     -1
 191 #define DEFAULT_DO_TIMESTAMP    FALSE
 192 
 193 enum
 194 {
 195   PROP_0,
 196   PROP_BLOCKSIZE,
 197   PROP_NUM_BUFFERS,
 198 #ifndef GST_REMOVE_DEPRECATED
 199   PROP_TYPEFIND,
 200 #endif
 201   PROP_DO_TIMESTAMP
 202 };
 203 
<a name="1" id="anc1"></a><span class="line-removed"> 204 #define GST_BASE_SRC_GET_PRIVATE(obj)  \</span>
<span class="line-removed"> 205    (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_BASE_SRC, GstBaseSrcPrivate))</span>
<span class="line-removed"> 206 </span>
 207 /* The basesrc implementation need to respect the following locking order:
 208  *   1. STREAM_LOCK
 209  *   2. LIVE_LOCK
 210  *   3. OBJECT_LOCK
 211  */
 212 struct _GstBaseSrcPrivate
 213 {
 214   gboolean discont;             /* STREAM_LOCK */
 215   gboolean flushing;            /* LIVE_LOCK */
 216 
 217   GstFlowReturn start_result;   /* OBJECT_LOCK */
 218   gboolean async;               /* OBJECT_LOCK */
 219 
 220   /* if a stream-start event should be sent */
 221   gboolean stream_start_pending;        /* STREAM_LOCK */
 222 
 223   /* if segment should be sent and a
 224    * seqnum if it was originated by a seek */
 225   gboolean segment_pending;     /* OBJECT_LOCK */
 226   guint32 segment_seqnum;       /* OBJECT_LOCK */
 227 
 228   /* if EOS is pending (atomic) */
 229   GstEvent *pending_eos;        /* OBJECT_LOCK */
 230   gint has_pending_eos;         /* atomic */
 231 
 232   /* if the eos was caused by a forced eos from the application */
 233   gboolean forced_eos;          /* LIVE_LOCK */
 234 
 235   /* startup latency is the time it takes between going to PLAYING and producing
 236    * the first BUFFER with running_time 0. This value is included in the latency
 237    * reporting. */
 238   GstClockTime latency;         /* OBJECT_LOCK */
 239   /* timestamp offset, this is the offset add to the values of gst_times for
 240    * pseudo live sources */
 241   GstClockTimeDiff ts_offset;   /* OBJECT_LOCK */
 242 
 243   gboolean do_timestamp;        /* OBJECT_LOCK */
 244   volatile gint dynamic_size;   /* atomic */
 245   volatile gint automatic_eos;  /* atomic */
 246 
 247   /* stream sequence number */
 248   guint32 seqnum;               /* STREAM_LOCK */
 249 
 250   /* pending events (TAG, CUSTOM_BOTH, CUSTOM_DOWNSTREAM) to be
 251    * pushed in the data stream */
 252   GList *pending_events;        /* OBJECT_LOCK */
 253   volatile gint have_events;    /* OBJECT_LOCK */
 254 
 255   /* QoS *//* with LOCK */
 256   gdouble proportion;           /* OBJECT_LOCK */
 257   GstClockTime earliest_time;   /* OBJECT_LOCK */
 258 
 259   GstBufferPool *pool;          /* OBJECT_LOCK */
 260   GstAllocator *allocator;      /* OBJECT_LOCK */
 261   GstAllocationParams params;   /* OBJECT_LOCK */
 262 
 263   GCond async_cond;             /* OBJECT_LOCK */
 264 
 265   /* for _submit_buffer_list() */
 266   GstBufferList *pending_bufferlist;
 267 };
 268 
 269 #define BASE_SRC_HAS_PENDING_BUFFER_LIST(src) \
 270     ((src)-&gt;priv-&gt;pending_bufferlist != NULL)
 271 
 272 static GstElementClass *parent_class = NULL;
<a name="2" id="anc2"></a>
 273 
 274 static void gst_base_src_class_init (GstBaseSrcClass * klass);
 275 static void gst_base_src_init (GstBaseSrc * src, gpointer g_class);
 276 static void gst_base_src_finalize (GObject * object);
 277 
 278 
 279 GType
 280 gst_base_src_get_type (void)
 281 {
 282   static volatile gsize base_src_type = 0;
 283 
 284   if (g_once_init_enter (&amp;base_src_type)) {
 285     GType _type;
 286     static const GTypeInfo base_src_info = {
 287       sizeof (GstBaseSrcClass),
 288       NULL,
 289       NULL,
 290       (GClassInitFunc) gst_base_src_class_init,
 291       NULL,
 292       NULL,
 293       sizeof (GstBaseSrc),
 294       0,
 295       (GInstanceInitFunc) gst_base_src_init,
 296     };
 297 
 298     _type = g_type_register_static (GST_TYPE_ELEMENT,
 299         &quot;GstBaseSrc&quot;, &amp;base_src_info, G_TYPE_FLAG_ABSTRACT);
<a name="3" id="anc3"></a>



 300     g_once_init_leave (&amp;base_src_type, _type);
 301   }
 302   return base_src_type;
 303 }
 304 
<a name="4" id="anc4"></a>





 305 static GstCaps *gst_base_src_default_get_caps (GstBaseSrc * bsrc,
 306     GstCaps * filter);
 307 static GstCaps *gst_base_src_default_fixate (GstBaseSrc * src, GstCaps * caps);
 308 static GstCaps *gst_base_src_fixate (GstBaseSrc * src, GstCaps * caps);
 309 
 310 static gboolean gst_base_src_is_random_access (GstBaseSrc * src);
 311 static gboolean gst_base_src_activate_mode (GstPad * pad, GstObject * parent,
 312     GstPadMode mode, gboolean active);
 313 static void gst_base_src_set_property (GObject * object, guint prop_id,
 314     const GValue * value, GParamSpec * pspec);
 315 static void gst_base_src_get_property (GObject * object, guint prop_id,
 316     GValue * value, GParamSpec * pspec);
 317 static gboolean gst_base_src_event (GstPad * pad, GstObject * parent,
 318     GstEvent * event);
 319 static gboolean gst_base_src_send_event (GstElement * elem, GstEvent * event);
 320 static gboolean gst_base_src_default_event (GstBaseSrc * src, GstEvent * event);
 321 
 322 static gboolean gst_base_src_query (GstPad * pad, GstObject * parent,
 323     GstQuery * query);
 324 
 325 static void gst_base_src_set_pool_flushing (GstBaseSrc * basesrc,
 326     gboolean flushing);
 327 static gboolean gst_base_src_default_negotiate (GstBaseSrc * basesrc);
 328 static gboolean gst_base_src_default_do_seek (GstBaseSrc * src,
 329     GstSegment * segment);
 330 static gboolean gst_base_src_default_query (GstBaseSrc * src, GstQuery * query);
 331 static gboolean gst_base_src_default_prepare_seek_segment (GstBaseSrc * src,
 332     GstEvent * event, GstSegment * segment);
 333 static GstFlowReturn gst_base_src_default_create (GstBaseSrc * basesrc,
 334     guint64 offset, guint size, GstBuffer ** buf);
 335 static GstFlowReturn gst_base_src_default_alloc (GstBaseSrc * basesrc,
 336     guint64 offset, guint size, GstBuffer ** buf);
 337 static gboolean gst_base_src_decide_allocation_default (GstBaseSrc * basesrc,
 338     GstQuery * query);
 339 
 340 static gboolean gst_base_src_set_flushing (GstBaseSrc * basesrc,
 341     gboolean flushing);
 342 
 343 static gboolean gst_base_src_start (GstBaseSrc * basesrc);
 344 static gboolean gst_base_src_stop (GstBaseSrc * basesrc);
 345 
 346 static GstStateChangeReturn gst_base_src_change_state (GstElement * element,
 347     GstStateChange transition);
 348 
 349 static void gst_base_src_loop (GstPad * pad);
 350 static GstFlowReturn gst_base_src_getrange (GstPad * pad, GstObject * parent,
 351     guint64 offset, guint length, GstBuffer ** buf);
 352 static GstFlowReturn gst_base_src_get_range (GstBaseSrc * src, guint64 offset,
 353     guint length, GstBuffer ** buf);
 354 static gboolean gst_base_src_seekable (GstBaseSrc * src);
 355 static gboolean gst_base_src_negotiate (GstBaseSrc * basesrc);
 356 static gboolean gst_base_src_update_length (GstBaseSrc * src, guint64 offset,
 357     guint * length, gboolean force);
 358 
 359 static void
 360 gst_base_src_class_init (GstBaseSrcClass * klass)
 361 {
 362   GObjectClass *gobject_class;
 363   GstElementClass *gstelement_class;
 364 
 365   gobject_class = G_OBJECT_CLASS (klass);
 366   gstelement_class = GST_ELEMENT_CLASS (klass);
 367 
<a name="5" id="anc5"></a><span class="line-modified"> 368   GST_DEBUG_CATEGORY_INIT (gst_base_src_debug, &quot;basesrc&quot;, 0, &quot;basesrc element&quot;);</span>

 369 
<a name="6" id="anc6"></a><span class="line-modified"> 370   g_type_class_add_private (klass, sizeof (GstBaseSrcPrivate));</span>
 371 
 372   parent_class = g_type_class_peek_parent (klass);
 373 
 374   gobject_class-&gt;finalize = gst_base_src_finalize;
 375   gobject_class-&gt;set_property = gst_base_src_set_property;
 376   gobject_class-&gt;get_property = gst_base_src_get_property;
 377 
 378   g_object_class_install_property (gobject_class, PROP_BLOCKSIZE,
 379       g_param_spec_uint (&quot;blocksize&quot;, &quot;Block size&quot;,
 380           &quot;Size in bytes to read per buffer (-1 = default)&quot;, 0, G_MAXUINT,
 381           DEFAULT_BLOCKSIZE, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 382   g_object_class_install_property (gobject_class, PROP_NUM_BUFFERS,
 383       g_param_spec_int (&quot;num-buffers&quot;, &quot;num-buffers&quot;,
 384           &quot;Number of buffers to output before sending EOS (-1 = unlimited)&quot;,
 385           -1, G_MAXINT, DEFAULT_NUM_BUFFERS, G_PARAM_READWRITE |
 386           G_PARAM_STATIC_STRINGS));
 387 #ifndef GST_REMOVE_DEPRECATED
 388   g_object_class_install_property (gobject_class, PROP_TYPEFIND,
 389       g_param_spec_boolean (&quot;typefind&quot;, &quot;Typefind&quot;,
 390           &quot;Run typefind before negotiating (deprecated, non-functional)&quot;, FALSE,
 391           G_PARAM_READWRITE | G_PARAM_DEPRECATED | G_PARAM_STATIC_STRINGS));
 392 #endif
 393   g_object_class_install_property (gobject_class, PROP_DO_TIMESTAMP,
 394       g_param_spec_boolean (&quot;do-timestamp&quot;, &quot;Do timestamp&quot;,
 395           &quot;Apply current stream time to buffers&quot;, DEFAULT_DO_TIMESTAMP,
 396           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 397 
 398   gstelement_class-&gt;change_state =
 399       GST_DEBUG_FUNCPTR (gst_base_src_change_state);
 400   gstelement_class-&gt;send_event = GST_DEBUG_FUNCPTR (gst_base_src_send_event);
 401 
 402   klass-&gt;get_caps = GST_DEBUG_FUNCPTR (gst_base_src_default_get_caps);
 403   klass-&gt;negotiate = GST_DEBUG_FUNCPTR (gst_base_src_default_negotiate);
 404   klass-&gt;fixate = GST_DEBUG_FUNCPTR (gst_base_src_default_fixate);
 405   klass-&gt;prepare_seek_segment =
 406       GST_DEBUG_FUNCPTR (gst_base_src_default_prepare_seek_segment);
 407   klass-&gt;do_seek = GST_DEBUG_FUNCPTR (gst_base_src_default_do_seek);
 408   klass-&gt;query = GST_DEBUG_FUNCPTR (gst_base_src_default_query);
 409   klass-&gt;event = GST_DEBUG_FUNCPTR (gst_base_src_default_event);
 410   klass-&gt;create = GST_DEBUG_FUNCPTR (gst_base_src_default_create);
 411   klass-&gt;alloc = GST_DEBUG_FUNCPTR (gst_base_src_default_alloc);
 412   klass-&gt;decide_allocation =
 413       GST_DEBUG_FUNCPTR (gst_base_src_decide_allocation_default);
 414 
 415   /* Registering debug symbols for function pointers */
 416   GST_DEBUG_REGISTER_FUNCPTR (gst_base_src_activate_mode);
 417   GST_DEBUG_REGISTER_FUNCPTR (gst_base_src_event);
 418   GST_DEBUG_REGISTER_FUNCPTR (gst_base_src_query);
 419   GST_DEBUG_REGISTER_FUNCPTR (gst_base_src_getrange);
 420   GST_DEBUG_REGISTER_FUNCPTR (gst_base_src_fixate);
 421 }
 422 
 423 static void
 424 gst_base_src_init (GstBaseSrc * basesrc, gpointer g_class)
 425 {
 426   GstPad *pad;
 427   GstPadTemplate *pad_template;
 428 
<a name="7" id="anc7"></a><span class="line-modified"> 429   basesrc-&gt;priv = GST_BASE_SRC_GET_PRIVATE (basesrc);</span>
 430 
 431   basesrc-&gt;is_live = FALSE;
 432   g_mutex_init (&amp;basesrc-&gt;live_lock);
 433   g_cond_init (&amp;basesrc-&gt;live_cond);
 434   basesrc-&gt;num_buffers = DEFAULT_NUM_BUFFERS;
 435   basesrc-&gt;num_buffers_left = -1;
 436   basesrc-&gt;priv-&gt;automatic_eos = TRUE;
 437 
 438   basesrc-&gt;can_activate_push = TRUE;
 439 
 440   pad_template =
 441       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (g_class), &quot;src&quot;);
 442   g_return_if_fail (pad_template != NULL);
 443 
 444   GST_DEBUG_OBJECT (basesrc, &quot;creating src pad&quot;);
 445   pad = gst_pad_new_from_template (pad_template, &quot;src&quot;);
 446 
 447   GST_DEBUG_OBJECT (basesrc, &quot;setting functions on src pad&quot;);
 448   gst_pad_set_activatemode_function (pad, gst_base_src_activate_mode);
 449   gst_pad_set_event_function (pad, gst_base_src_event);
 450   gst_pad_set_query_function (pad, gst_base_src_query);
 451   gst_pad_set_getrange_function (pad, gst_base_src_getrange);
 452 
 453   /* hold pointer to pad */
 454   basesrc-&gt;srcpad = pad;
 455   GST_DEBUG_OBJECT (basesrc, &quot;adding src pad&quot;);
 456   gst_element_add_pad (GST_ELEMENT (basesrc), pad);
 457 
 458   basesrc-&gt;blocksize = DEFAULT_BLOCKSIZE;
 459   basesrc-&gt;clock_id = NULL;
 460   /* we operate in BYTES by default */
 461   gst_base_src_set_format (basesrc, GST_FORMAT_BYTES);
 462   basesrc-&gt;priv-&gt;do_timestamp = DEFAULT_DO_TIMESTAMP;
 463   g_atomic_int_set (&amp;basesrc-&gt;priv-&gt;have_events, FALSE);
 464 
 465   g_cond_init (&amp;basesrc-&gt;priv-&gt;async_cond);
 466   basesrc-&gt;priv-&gt;start_result = GST_FLOW_FLUSHING;
 467   GST_OBJECT_FLAG_UNSET (basesrc, GST_BASE_SRC_FLAG_STARTED);
 468   GST_OBJECT_FLAG_UNSET (basesrc, GST_BASE_SRC_FLAG_STARTING);
 469   GST_OBJECT_FLAG_SET (basesrc, GST_ELEMENT_FLAG_SOURCE);
 470 
 471   GST_DEBUG_OBJECT (basesrc, &quot;init done&quot;);
 472 }
 473 
 474 static void
 475 gst_base_src_finalize (GObject * object)
 476 {
 477   GstBaseSrc *basesrc;
 478   GstEvent **event_p;
 479 
 480   basesrc = GST_BASE_SRC (object);
 481 
 482   g_mutex_clear (&amp;basesrc-&gt;live_lock);
 483   g_cond_clear (&amp;basesrc-&gt;live_cond);
 484   g_cond_clear (&amp;basesrc-&gt;priv-&gt;async_cond);
 485 
 486   event_p = &amp;basesrc-&gt;pending_seek;
 487   gst_event_replace (event_p, NULL);
 488 
 489   if (basesrc-&gt;priv-&gt;pending_events) {
 490     g_list_foreach (basesrc-&gt;priv-&gt;pending_events, (GFunc) gst_event_unref,
 491         NULL);
 492     g_list_free (basesrc-&gt;priv-&gt;pending_events);
 493   }
 494 
 495   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 496 }
 497 
 498 /* Call with LIVE_LOCK held */
 499 static GstFlowReturn
 500 gst_base_src_wait_playing_unlocked (GstBaseSrc * src)
 501 {
 502   while (G_UNLIKELY (!src-&gt;live_running &amp;&amp; !src-&gt;priv-&gt;flushing)) {
 503     /* block until the state changes, or we get a flush, or something */
 504     GST_DEBUG_OBJECT (src, &quot;live source waiting for running state&quot;);
 505     GST_LIVE_WAIT (src);
 506     GST_DEBUG_OBJECT (src, &quot;live source unlocked&quot;);
 507   }
 508 
 509   if (src-&gt;priv-&gt;flushing)
 510     goto flushing;
 511 
 512   return GST_FLOW_OK;
 513 
 514   /* ERRORS */
 515 flushing:
 516   {
 517     GST_DEBUG_OBJECT (src, &quot;we are flushing&quot;);
 518     return GST_FLOW_FLUSHING;
 519   }
 520 }
 521 
 522 
 523 /**
 524  * gst_base_src_wait_playing:
 525  * @src: the src
 526  *
 527  * If the #GstBaseSrcClass.create() method performs its own synchronisation
 528  * against the clock it must unblock when going from PLAYING to the PAUSED state
 529  * and call this method before continuing to produce the remaining data.
 530  *
 531  * This function will block until a state change to PLAYING happens (in which
 532  * case this function returns %GST_FLOW_OK) or the processing must be stopped due
 533  * to a state change to READY or a FLUSH event (in which case this function
 534  * returns %GST_FLOW_FLUSHING).
 535  *
 536  * Returns: %GST_FLOW_OK if @src is PLAYING and processing can
 537  * continue. Any other return value should be returned from the create vmethod.
 538  */
 539 GstFlowReturn
 540 gst_base_src_wait_playing (GstBaseSrc * src)
 541 {
 542   GstFlowReturn ret;
 543 
 544   g_return_val_if_fail (GST_IS_BASE_SRC (src), GST_FLOW_ERROR);
 545 
 546   GST_LIVE_LOCK (src);
 547   ret = gst_base_src_wait_playing_unlocked (src);
 548   GST_LIVE_UNLOCK (src);
 549 
 550   return ret;
 551 }
 552 
 553 /**
 554  * gst_base_src_set_live:
 555  * @src: base source instance
 556  * @live: new live-mode
 557  *
 558  * If the element listens to a live source, @live should
 559  * be set to %TRUE.
 560  *
 561  * A live source will not produce data in the PAUSED state and
 562  * will therefore not be able to participate in the PREROLL phase
 563  * of a pipeline. To signal this fact to the application and the
 564  * pipeline, the state change return value of the live source will
 565  * be GST_STATE_CHANGE_NO_PREROLL.
 566  */
 567 void
 568 gst_base_src_set_live (GstBaseSrc * src, gboolean live)
 569 {
 570   g_return_if_fail (GST_IS_BASE_SRC (src));
 571 
 572   GST_OBJECT_LOCK (src);
 573   src-&gt;is_live = live;
 574   GST_OBJECT_UNLOCK (src);
 575 }
 576 
 577 /**
 578  * gst_base_src_is_live:
 579  * @src: base source instance
 580  *
 581  * Check if an element is in live mode.
 582  *
 583  * Returns: %TRUE if element is in live mode.
 584  */
 585 gboolean
 586 gst_base_src_is_live (GstBaseSrc * src)
 587 {
 588   gboolean result;
 589 
 590   g_return_val_if_fail (GST_IS_BASE_SRC (src), FALSE);
 591 
 592   GST_OBJECT_LOCK (src);
 593   result = src-&gt;is_live;
 594   GST_OBJECT_UNLOCK (src);
 595 
 596   return result;
 597 }
 598 
 599 /**
 600  * gst_base_src_set_format:
 601  * @src: base source instance
 602  * @format: the format to use
 603  *
 604  * Sets the default format of the source. This will be the format used
 605  * for sending SEGMENT events and for performing seeks.
 606  *
 607  * If a format of GST_FORMAT_BYTES is set, the element will be able to
 608  * operate in pull mode if the #GstBaseSrcClass.is_seekable() returns %TRUE.
 609  *
 610  * This function must only be called in states &lt; %GST_STATE_PAUSED.
 611  */
 612 void
 613 gst_base_src_set_format (GstBaseSrc * src, GstFormat format)
 614 {
 615   g_return_if_fail (GST_IS_BASE_SRC (src));
 616   g_return_if_fail (GST_STATE (src) &lt;= GST_STATE_READY);
 617 
 618   GST_OBJECT_LOCK (src);
 619   gst_segment_init (&amp;src-&gt;segment, format);
 620   GST_OBJECT_UNLOCK (src);
 621 }
 622 
 623 /**
 624  * gst_base_src_set_dynamic_size:
 625  * @src: base source instance
 626  * @dynamic: new dynamic size mode
 627  *
 628  * If not @dynamic, size is only updated when needed, such as when trying to
 629  * read past current tracked size.  Otherwise, size is checked for upon each
 630  * read.
 631  */
 632 void
 633 gst_base_src_set_dynamic_size (GstBaseSrc * src, gboolean dynamic)
 634 {
 635   g_return_if_fail (GST_IS_BASE_SRC (src));
 636 
 637   g_atomic_int_set (&amp;src-&gt;priv-&gt;dynamic_size, dynamic);
 638 }
 639 
 640 /**
 641  * gst_base_src_set_automatic_eos:
 642  * @src: base source instance
 643  * @automatic_eos: automatic eos
 644  *
 645  * If @automatic_eos is %TRUE, @src will automatically go EOS if a buffer
 646  * after the total size is returned. By default this is %TRUE but sources
 647  * that can&#39;t return an authoritative size and only know that they&#39;re EOS
 648  * when trying to read more should set this to %FALSE.
 649  *
<a name="8" id="anc8"></a>





 650  * Since: 1.4
 651  */
 652 void
 653 gst_base_src_set_automatic_eos (GstBaseSrc * src, gboolean automatic_eos)
 654 {
 655   g_return_if_fail (GST_IS_BASE_SRC (src));
 656 
 657   g_atomic_int_set (&amp;src-&gt;priv-&gt;automatic_eos, automatic_eos);
 658 }
 659 
 660 /**
 661  * gst_base_src_set_async:
 662  * @src: base source instance
 663  * @async: new async mode
 664  *
 665  * Configure async behaviour in @src, no state change will block. The open,
 666  * close, start, stop, play and pause virtual methods will be executed in a
 667  * different thread and are thus allowed to perform blocking operations. Any
 668  * blocking operation should be unblocked with the unlock vmethod.
 669  */
 670 void
 671 gst_base_src_set_async (GstBaseSrc * src, gboolean async)
 672 {
 673   g_return_if_fail (GST_IS_BASE_SRC (src));
 674 
 675   GST_OBJECT_LOCK (src);
 676   src-&gt;priv-&gt;async = async;
 677   GST_OBJECT_UNLOCK (src);
 678 }
 679 
 680 /**
 681  * gst_base_src_is_async:
 682  * @src: base source instance
 683  *
 684  * Get the current async behaviour of @src. See also gst_base_src_set_async().
 685  *
 686  * Returns: %TRUE if @src is operating in async mode.
 687  */
 688 gboolean
 689 gst_base_src_is_async (GstBaseSrc * src)
 690 {
 691   gboolean res;
 692 
 693   g_return_val_if_fail (GST_IS_BASE_SRC (src), FALSE);
 694 
 695   GST_OBJECT_LOCK (src);
 696   res = src-&gt;priv-&gt;async;
 697   GST_OBJECT_UNLOCK (src);
 698 
 699   return res;
 700 }
 701 
 702 
 703 /**
 704  * gst_base_src_query_latency:
 705  * @src: the source
 706  * @live: (out) (allow-none): if the source is live
 707  * @min_latency: (out) (allow-none): the min latency of the source
 708  * @max_latency: (out) (allow-none): the max latency of the source
 709  *
 710  * Query the source for the latency parameters. @live will be %TRUE when @src is
 711  * configured as a live source. @min_latency and @max_latency will be set
 712  * to the difference between the running time and the timestamp of the first
 713  * buffer.
 714  *
 715  * This function is mostly used by subclasses.
 716  *
 717  * Returns: %TRUE if the query succeeded.
 718  */
 719 gboolean
 720 gst_base_src_query_latency (GstBaseSrc * src, gboolean * live,
 721     GstClockTime * min_latency, GstClockTime * max_latency)
 722 {
 723   GstClockTime min;
 724 
 725   g_return_val_if_fail (GST_IS_BASE_SRC (src), FALSE);
 726 
 727   GST_OBJECT_LOCK (src);
 728   if (live)
 729     *live = src-&gt;is_live;
 730 
 731   /* if we have a startup latency, report this one, else report 0. Subclasses
 732    * are supposed to override the query function if they want something
 733    * else. */
 734   if (src-&gt;priv-&gt;latency != -1)
 735     min = src-&gt;priv-&gt;latency;
 736   else
 737     min = 0;
 738 
 739   if (min_latency)
 740     *min_latency = min;
 741   if (max_latency)
 742     *max_latency = min;
 743 
 744   GST_LOG_OBJECT (src, &quot;latency: live %d, min %&quot; GST_TIME_FORMAT
 745       &quot;, max %&quot; GST_TIME_FORMAT, src-&gt;is_live, GST_TIME_ARGS (min),
 746       GST_TIME_ARGS (min));
 747   GST_OBJECT_UNLOCK (src);
 748 
 749   return TRUE;
 750 }
 751 
 752 /**
 753  * gst_base_src_set_blocksize:
 754  * @src: the source
 755  * @blocksize: the new blocksize in bytes
 756  *
 757  * Set the number of bytes that @src will push out with each buffer. When
 758  * @blocksize is set to -1, a default length will be used.
 759  */
 760 void
 761 gst_base_src_set_blocksize (GstBaseSrc * src, guint blocksize)
 762 {
 763   g_return_if_fail (GST_IS_BASE_SRC (src));
 764 
 765   GST_OBJECT_LOCK (src);
 766   src-&gt;blocksize = blocksize;
 767   GST_OBJECT_UNLOCK (src);
 768 }
 769 
 770 /**
 771  * gst_base_src_get_blocksize:
 772  * @src: the source
 773  *
 774  * Get the number of bytes that @src will push out with each buffer.
 775  *
 776  * Returns: the number of bytes pushed with each buffer.
 777  */
 778 guint
 779 gst_base_src_get_blocksize (GstBaseSrc * src)
 780 {
 781   gint res;
 782 
 783   g_return_val_if_fail (GST_IS_BASE_SRC (src), 0);
 784 
 785   GST_OBJECT_LOCK (src);
 786   res = src-&gt;blocksize;
 787   GST_OBJECT_UNLOCK (src);
 788 
 789   return res;
 790 }
 791 
 792 
 793 /**
 794  * gst_base_src_set_do_timestamp:
 795  * @src: the source
 796  * @timestamp: enable or disable timestamping
 797  *
 798  * Configure @src to automatically timestamp outgoing buffers based on the
 799  * current running_time of the pipeline. This property is mostly useful for live
 800  * sources.
 801  */
 802 void
 803 gst_base_src_set_do_timestamp (GstBaseSrc * src, gboolean timestamp)
 804 {
 805   g_return_if_fail (GST_IS_BASE_SRC (src));
 806 
 807   GST_OBJECT_LOCK (src);
 808   src-&gt;priv-&gt;do_timestamp = timestamp;
 809   if (timestamp &amp;&amp; src-&gt;segment.format != GST_FORMAT_TIME)
 810     gst_segment_init (&amp;src-&gt;segment, GST_FORMAT_TIME);
 811   GST_OBJECT_UNLOCK (src);
 812 }
 813 
 814 /**
 815  * gst_base_src_get_do_timestamp:
 816  * @src: the source
 817  *
 818  * Query if @src timestamps outgoing buffers based on the current running_time.
 819  *
 820  * Returns: %TRUE if the base class will automatically timestamp outgoing buffers.
 821  */
 822 gboolean
 823 gst_base_src_get_do_timestamp (GstBaseSrc * src)
 824 {
 825   gboolean res;
 826 
 827   g_return_val_if_fail (GST_IS_BASE_SRC (src), FALSE);
 828 
 829   GST_OBJECT_LOCK (src);
 830   res = src-&gt;priv-&gt;do_timestamp;
 831   GST_OBJECT_UNLOCK (src);
 832 
 833   return res;
 834 }
 835 
 836 /**
 837  * gst_base_src_new_seamless_segment:
 838  * @src: The source
 839  * @start: The new start value for the segment
 840  * @stop: Stop value for the new segment
 841  * @time: The new time value for the start of the new segment
 842  *
 843  * Prepare a new seamless segment for emission downstream. This function must
 844  * only be called by derived sub-classes, and only from the create() function,
 845  * as the stream-lock needs to be held.
 846  *
 847  * The format for the new segment will be the current format of the source, as
 848  * configured with gst_base_src_set_format()
 849  *
 850  * Returns: %TRUE if preparation of the seamless segment succeeded.
 851  */
 852 gboolean
 853 gst_base_src_new_seamless_segment (GstBaseSrc * src, gint64 start, gint64 stop,
 854     gint64 time)
 855 {
 856   gboolean res = TRUE;
 857 
 858   GST_OBJECT_LOCK (src);
 859 
 860   src-&gt;segment.base = gst_segment_to_running_time (&amp;src-&gt;segment,
 861       src-&gt;segment.format, src-&gt;segment.position);
 862   src-&gt;segment.position = src-&gt;segment.start = start;
 863   src-&gt;segment.stop = stop;
 864   src-&gt;segment.time = time;
 865 
 866   /* Mark pending segment. Will be sent before next data */
 867   src-&gt;priv-&gt;segment_pending = TRUE;
 868   src-&gt;priv-&gt;segment_seqnum = gst_util_seqnum_next ();
 869 
 870   GST_DEBUG_OBJECT (src,
 871       &quot;Starting new seamless segment. Start %&quot; GST_TIME_FORMAT &quot; stop %&quot;
 872       GST_TIME_FORMAT &quot; time %&quot; GST_TIME_FORMAT &quot; base %&quot; GST_TIME_FORMAT,
 873       GST_TIME_ARGS (start), GST_TIME_ARGS (stop), GST_TIME_ARGS (time),
 874       GST_TIME_ARGS (src-&gt;segment.base));
 875 
 876   GST_OBJECT_UNLOCK (src);
 877 
 878   src-&gt;priv-&gt;discont = TRUE;
 879   src-&gt;running = TRUE;
 880 
 881   return res;
 882 }
 883 
 884 /* called with STREAM_LOCK */
 885 static gboolean
 886 gst_base_src_send_stream_start (GstBaseSrc * src)
 887 {
 888   gboolean ret = TRUE;
 889 
 890   if (src-&gt;priv-&gt;stream_start_pending) {
 891     gchar *stream_id;
 892     GstEvent *event;
 893 
 894     stream_id =
 895         gst_pad_create_stream_id (src-&gt;srcpad, GST_ELEMENT_CAST (src), NULL);
 896 
 897     GST_DEBUG_OBJECT (src, &quot;Pushing STREAM_START&quot;);
 898     event = gst_event_new_stream_start (stream_id);
 899     gst_event_set_group_id (event, gst_util_group_id_next ());
 900 
 901     ret = gst_pad_push_event (src-&gt;srcpad, event);
 902     src-&gt;priv-&gt;stream_start_pending = FALSE;
 903     g_free (stream_id);
 904   }
 905 
 906   return ret;
 907 }
 908 
 909 /**
 910  * gst_base_src_set_caps:
 911  * @src: a #GstBaseSrc
 912  * @caps: (transfer none): a #GstCaps
 913  *
 914  * Set new caps on the basesrc source pad.
 915  *
 916  * Returns: %TRUE if the caps could be set
 917  */
 918 gboolean
 919 gst_base_src_set_caps (GstBaseSrc * src, GstCaps * caps)
 920 {
 921   GstBaseSrcClass *bclass;
 922   gboolean res = TRUE;
 923   GstCaps *current_caps;
 924 
 925   bclass = GST_BASE_SRC_GET_CLASS (src);
 926 
 927   gst_base_src_send_stream_start (src);
 928 
 929   current_caps = gst_pad_get_current_caps (GST_BASE_SRC_PAD (src));
 930   if (current_caps &amp;&amp; gst_caps_is_equal (current_caps, caps)) {
 931     GST_DEBUG_OBJECT (src, &quot;New caps equal to old ones: %&quot; GST_PTR_FORMAT,
 932         caps);
 933     res = TRUE;
 934   } else {
 935     if (bclass-&gt;set_caps)
 936       res = bclass-&gt;set_caps (src, caps);
 937 
 938     if (res)
 939       res = gst_pad_push_event (src-&gt;srcpad, gst_event_new_caps (caps));
 940   }
 941 
 942   if (current_caps)
 943     gst_caps_unref (current_caps);
 944 
 945   return res;
 946 }
 947 
 948 static GstCaps *
 949 gst_base_src_default_get_caps (GstBaseSrc * bsrc, GstCaps * filter)
 950 {
 951   GstCaps *caps = NULL;
 952   GstPadTemplate *pad_template;
 953   GstBaseSrcClass *bclass;
 954 
 955   bclass = GST_BASE_SRC_GET_CLASS (bsrc);
 956 
 957   pad_template =
 958       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;src&quot;);
 959 
 960   if (pad_template != NULL) {
 961     caps = gst_pad_template_get_caps (pad_template);
 962 
 963     if (filter) {
 964       GstCaps *intersection;
 965 
 966       intersection =
 967           gst_caps_intersect_full (filter, caps, GST_CAPS_INTERSECT_FIRST);
 968       gst_caps_unref (caps);
 969       caps = intersection;
 970     }
 971   }
 972   return caps;
 973 }
 974 
 975 static GstCaps *
 976 gst_base_src_default_fixate (GstBaseSrc * bsrc, GstCaps * caps)
 977 {
 978   GST_DEBUG_OBJECT (bsrc, &quot;using default caps fixate function&quot;);
 979   return gst_caps_fixate (caps);
 980 }
 981 
 982 static GstCaps *
 983 gst_base_src_fixate (GstBaseSrc * bsrc, GstCaps * caps)
 984 {
 985   GstBaseSrcClass *bclass;
 986 
 987   bclass = GST_BASE_SRC_GET_CLASS (bsrc);
 988 
 989   if (bclass-&gt;fixate)
 990     caps = bclass-&gt;fixate (bsrc, caps);
 991 
 992   return caps;
 993 }
 994 
 995 static gboolean
 996 gst_base_src_default_query (GstBaseSrc * src, GstQuery * query)
 997 {
 998   gboolean res;
 999 
1000   switch (GST_QUERY_TYPE (query)) {
1001     case GST_QUERY_POSITION:
1002     {
1003       GstFormat format;
1004 
1005       gst_query_parse_position (query, &amp;format, NULL);
1006 
1007       GST_DEBUG_OBJECT (src, &quot;position query in format %s&quot;,
1008           gst_format_get_name (format));
1009 
1010       switch (format) {
1011         case GST_FORMAT_PERCENT:
1012         {
1013           gint64 percent;
1014           gint64 position;
1015           gint64 duration;
1016 
1017           GST_OBJECT_LOCK (src);
1018           position = src-&gt;segment.position;
1019           duration = src-&gt;segment.duration;
1020           GST_OBJECT_UNLOCK (src);
1021 
1022           if (position != -1 &amp;&amp; duration != -1) {
1023             if (position &lt; duration)
1024               percent = gst_util_uint64_scale (GST_FORMAT_PERCENT_MAX, position,
1025                   duration);
1026             else
1027               percent = GST_FORMAT_PERCENT_MAX;
1028           } else
1029             percent = -1;
1030 
1031           gst_query_set_position (query, GST_FORMAT_PERCENT, percent);
1032           res = TRUE;
1033           break;
1034         }
1035         default:
1036         {
1037           gint64 position;
1038           GstFormat seg_format;
1039 
1040           GST_OBJECT_LOCK (src);
1041           position =
1042               gst_segment_to_stream_time (&amp;src-&gt;segment, src-&gt;segment.format,
1043               src-&gt;segment.position);
1044           seg_format = src-&gt;segment.format;
1045           GST_OBJECT_UNLOCK (src);
1046 
1047           if (position != -1) {
1048             /* convert to requested format */
1049             res =
1050                 gst_pad_query_convert (src-&gt;srcpad, seg_format,
1051                 position, format, &amp;position);
1052           } else
1053             res = TRUE;
1054 
1055           if (res)
1056             gst_query_set_position (query, format, position);
1057 
1058           break;
1059         }
1060       }
1061       break;
1062     }
1063     case GST_QUERY_DURATION:
1064     {
1065       GstFormat format;
1066 
1067       gst_query_parse_duration (query, &amp;format, NULL);
1068 
1069       GST_DEBUG_OBJECT (src, &quot;duration query in format %s&quot;,
1070           gst_format_get_name (format));
1071 
1072       switch (format) {
1073         case GST_FORMAT_PERCENT:
1074           gst_query_set_duration (query, GST_FORMAT_PERCENT,
1075               GST_FORMAT_PERCENT_MAX);
1076           res = TRUE;
1077           break;
1078         default:
1079         {
1080           gint64 duration;
1081           GstFormat seg_format;
1082           guint length = 0;
1083 
1084           /* may have to refresh duration */
1085           gst_base_src_update_length (src, 0, &amp;length,
1086               g_atomic_int_get (&amp;src-&gt;priv-&gt;dynamic_size));
1087 
1088           /* this is the duration as configured by the subclass. */
1089           GST_OBJECT_LOCK (src);
1090           duration = src-&gt;segment.duration;
1091           seg_format = src-&gt;segment.format;
1092           GST_OBJECT_UNLOCK (src);
1093 
1094           GST_LOG_OBJECT (src, &quot;duration %&quot; G_GINT64_FORMAT &quot;, format %s&quot;,
1095               duration, gst_format_get_name (seg_format));
1096 
1097           if (duration != -1) {
1098             /* convert to requested format, if this fails, we have a duration
1099              * but we cannot answer the query, we must return FALSE. */
1100             res =
1101                 gst_pad_query_convert (src-&gt;srcpad, seg_format,
1102                 duration, format, &amp;duration);
1103           } else {
1104             /* The subclass did not configure a duration, we assume that the
1105              * media has an unknown duration then and we return TRUE to report
1106              * this. Note that this is not the same as returning FALSE, which
1107              * means that we cannot report the duration at all. */
1108             res = TRUE;
1109           }
1110 
1111           if (res)
1112             gst_query_set_duration (query, format, duration);
1113 
1114           break;
1115         }
1116       }
1117       break;
1118     }
1119 
1120     case GST_QUERY_SEEKING:
1121     {
1122       GstFormat format, seg_format;
1123       gint64 duration;
1124 
1125       GST_OBJECT_LOCK (src);
1126       duration = src-&gt;segment.duration;
1127       seg_format = src-&gt;segment.format;
1128       GST_OBJECT_UNLOCK (src);
1129 
1130       gst_query_parse_seeking (query, &amp;format, NULL, NULL, NULL);
1131       if (format == seg_format) {
1132         gst_query_set_seeking (query, seg_format,
1133             gst_base_src_seekable (src), 0, duration);
1134         res = TRUE;
1135       } else {
1136         /* FIXME 2.0: return TRUE + seekable=FALSE for SEEKING query here */
1137         /* Don&#39;t reply to the query to make up for demuxers which don&#39;t
1138          * handle the SEEKING query yet. Players like Totem will fall back
1139          * to the duration when the SEEKING query isn&#39;t answered. */
1140         res = FALSE;
1141       }
1142       break;
1143     }
1144     case GST_QUERY_SEGMENT:
1145     {
1146       GstFormat format;
1147       gint64 start, stop;
1148 
1149       GST_OBJECT_LOCK (src);
1150 
1151       format = src-&gt;segment.format;
1152 
1153       start =
1154           gst_segment_to_stream_time (&amp;src-&gt;segment, format,
1155           src-&gt;segment.start);
1156       if ((stop = src-&gt;segment.stop) == -1)
1157         stop = src-&gt;segment.duration;
1158       else
1159         stop = gst_segment_to_stream_time (&amp;src-&gt;segment, format, stop);
1160 
1161       gst_query_set_segment (query, src-&gt;segment.rate, format, start, stop);
1162 
1163       GST_OBJECT_UNLOCK (src);
1164       res = TRUE;
1165       break;
1166     }
1167 
1168     case GST_QUERY_FORMATS:
1169     {
1170       gst_query_set_formats (query, 3, GST_FORMAT_DEFAULT,
1171           GST_FORMAT_BYTES, GST_FORMAT_PERCENT);
1172       res = TRUE;
1173       break;
1174     }
1175     case GST_QUERY_CONVERT:
1176     {
1177       GstFormat src_fmt, dest_fmt;
1178       gint64 src_val, dest_val;
1179 
1180       gst_query_parse_convert (query, &amp;src_fmt, &amp;src_val, &amp;dest_fmt, &amp;dest_val);
1181 
1182       /* we can only convert between equal formats... */
1183       if (src_fmt == dest_fmt) {
1184         dest_val = src_val;
1185         res = TRUE;
1186       } else
1187         res = FALSE;
1188 
1189       gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
1190       break;
1191     }
1192     case GST_QUERY_LATENCY:
1193     {
1194       GstClockTime min, max;
1195       gboolean live;
1196 
1197       /* Subclasses should override and implement something useful */
1198       res = gst_base_src_query_latency (src, &amp;live, &amp;min, &amp;max);
1199 
1200       GST_LOG_OBJECT (src, &quot;report latency: live %d, min %&quot; GST_TIME_FORMAT
1201           &quot;, max %&quot; GST_TIME_FORMAT, live, GST_TIME_ARGS (min),
1202           GST_TIME_ARGS (max));
1203 
1204       gst_query_set_latency (query, live, min, max);
1205       break;
1206     }
1207     case GST_QUERY_JITTER:
1208     case GST_QUERY_RATE:
1209       res = FALSE;
1210       break;
1211     case GST_QUERY_BUFFERING:
1212     {
1213       GstFormat format, seg_format;
1214       gint64 start, stop, estimated;
1215 
1216       gst_query_parse_buffering_range (query, &amp;format, NULL, NULL, NULL);
1217 
1218       GST_DEBUG_OBJECT (src, &quot;buffering query in format %s&quot;,
1219           gst_format_get_name (format));
1220 
1221       GST_OBJECT_LOCK (src);
1222       if (src-&gt;random_access) {
1223         estimated = 0;
1224         start = 0;
1225         if (format == GST_FORMAT_PERCENT)
1226           stop = GST_FORMAT_PERCENT_MAX;
1227         else
1228           stop = src-&gt;segment.duration;
1229       } else {
1230         estimated = -1;
1231         start = -1;
1232         stop = -1;
1233       }
1234       seg_format = src-&gt;segment.format;
1235       GST_OBJECT_UNLOCK (src);
1236 
1237       /* convert to required format. When the conversion fails, we can&#39;t answer
1238        * the query. When the value is unknown, we can don&#39;t perform conversion
1239        * but report TRUE. */
1240       if (format != GST_FORMAT_PERCENT &amp;&amp; stop != -1) {
1241         res = gst_pad_query_convert (src-&gt;srcpad, seg_format,
1242             stop, format, &amp;stop);
1243       } else {
1244         res = TRUE;
1245       }
1246       if (res &amp;&amp; format != GST_FORMAT_PERCENT &amp;&amp; start != -1)
1247         res = gst_pad_query_convert (src-&gt;srcpad, seg_format,
1248             start, format, &amp;start);
1249 
1250       gst_query_set_buffering_range (query, format, start, stop, estimated);
1251       break;
1252     }
1253     case GST_QUERY_SCHEDULING:
1254     {
1255       gboolean random_access;
1256 
1257       random_access = gst_base_src_is_random_access (src);
1258 
1259       /* we can operate in getrange mode if the native format is bytes
1260        * and we are seekable, this condition is set in the random_access
1261        * flag and is set in the _start() method. */
1262       gst_query_set_scheduling (query, GST_SCHEDULING_FLAG_SEEKABLE, 1, -1, 0);
1263       if (random_access)
1264         gst_query_add_scheduling_mode (query, GST_PAD_MODE_PULL);
1265       gst_query_add_scheduling_mode (query, GST_PAD_MODE_PUSH);
1266 
1267       res = TRUE;
1268       break;
1269     }
1270     case GST_QUERY_CAPS:
1271     {
1272       GstBaseSrcClass *bclass;
1273       GstCaps *caps, *filter;
1274 
1275       bclass = GST_BASE_SRC_GET_CLASS (src);
1276       if (bclass-&gt;get_caps) {
1277         gst_query_parse_caps (query, &amp;filter);
1278         if ((caps = bclass-&gt;get_caps (src, filter))) {
1279           gst_query_set_caps_result (query, caps);
1280           gst_caps_unref (caps);
1281           res = TRUE;
1282         } else {
1283           res = FALSE;
1284         }
1285       } else
1286         res = FALSE;
1287       break;
1288     }
1289     case GST_QUERY_URI:{
1290       if (GST_IS_URI_HANDLER (src)) {
1291         gchar *uri = gst_uri_handler_get_uri (GST_URI_HANDLER (src));
1292 
1293         if (uri != NULL) {
1294           gst_query_set_uri (query, uri);
1295           g_free (uri);
1296           res = TRUE;
1297         } else {
1298           res = FALSE;
1299         }
1300       } else {
1301         res = FALSE;
1302       }
1303       break;
1304     }
1305     default:
1306       res = FALSE;
1307       break;
1308   }
1309   GST_DEBUG_OBJECT (src, &quot;query %s returns %d&quot;, GST_QUERY_TYPE_NAME (query),
1310       res);
1311 
1312   return res;
1313 }
1314 
1315 static gboolean
1316 gst_base_src_query (GstPad * pad, GstObject * parent, GstQuery * query)
1317 {
1318   GstBaseSrc *src;
1319   GstBaseSrcClass *bclass;
1320   gboolean result = FALSE;
1321 
1322   src = GST_BASE_SRC (parent);
1323   bclass = GST_BASE_SRC_GET_CLASS (src);
1324 
1325   if (bclass-&gt;query)
1326     result = bclass-&gt;query (src, query);
1327 
1328   return result;
1329 }
1330 
1331 static gboolean
1332 gst_base_src_default_do_seek (GstBaseSrc * src, GstSegment * segment)
1333 {
1334   gboolean res = TRUE;
1335 
1336   /* update our offset if the start/stop position was updated */
1337   if (segment-&gt;format == GST_FORMAT_BYTES) {
1338     segment-&gt;time = segment-&gt;start;
1339   } else if (segment-&gt;start == 0) {
1340     /* seek to start, we can implement a default for this. */
1341     segment-&gt;time = 0;
1342   } else {
1343     res = FALSE;
1344     GST_INFO_OBJECT (src, &quot;Can&#39;t do a default seek&quot;);
1345   }
1346 
1347   return res;
1348 }
1349 
1350 static gboolean
1351 gst_base_src_do_seek (GstBaseSrc * src, GstSegment * segment)
1352 {
1353   GstBaseSrcClass *bclass;
1354   gboolean result = FALSE;
1355 
1356   bclass = GST_BASE_SRC_GET_CLASS (src);
1357 
1358   GST_INFO_OBJECT (src, &quot;seeking: %&quot; GST_SEGMENT_FORMAT, segment);
1359 
1360   if (bclass-&gt;do_seek)
1361     result = bclass-&gt;do_seek (src, segment);
1362 
1363   return result;
1364 }
1365 
1366 #define SEEK_TYPE_IS_RELATIVE(t) (((t) != GST_SEEK_TYPE_NONE) &amp;&amp; ((t) != GST_SEEK_TYPE_SET))
1367 
1368 static gboolean
1369 gst_base_src_default_prepare_seek_segment (GstBaseSrc * src, GstEvent * event,
1370     GstSegment * segment)
1371 {
1372   /* By default, we try one of 2 things:
1373    *   - For absolute seek positions, convert the requested position to our
1374    *     configured processing format and place it in the output segment \
1375    *   - For relative seek positions, convert our current (input) values to the
1376    *     seek format, adjust by the relative seek offset and then convert back to
1377    *     the processing format
1378    */
1379   GstSeekType start_type, stop_type;
1380   gint64 start, stop;
1381   GstSeekFlags flags;
1382   GstFormat seek_format, dest_format;
1383   gdouble rate;
1384   gboolean update;
1385   gboolean res = TRUE;
1386 
1387   gst_event_parse_seek (event, &amp;rate, &amp;seek_format, &amp;flags,
1388       &amp;start_type, &amp;start, &amp;stop_type, &amp;stop);
1389   dest_format = segment-&gt;format;
1390 
1391   if (seek_format == dest_format) {
1392     gst_segment_do_seek (segment, rate, seek_format, flags,
1393         start_type, start, stop_type, stop, &amp;update);
1394     return TRUE;
1395   }
1396 
1397   if (start_type != GST_SEEK_TYPE_NONE) {
1398     /* FIXME: Handle seek_end by converting the input segment vals */
1399     res =
1400         gst_pad_query_convert (src-&gt;srcpad, seek_format, start, dest_format,
1401         &amp;start);
1402     start_type = GST_SEEK_TYPE_SET;
1403   }
1404 
1405   if (res &amp;&amp; stop_type != GST_SEEK_TYPE_NONE) {
1406     /* FIXME: Handle seek_end by converting the input segment vals */
1407     res =
1408         gst_pad_query_convert (src-&gt;srcpad, seek_format, stop, dest_format,
1409         &amp;stop);
1410     stop_type = GST_SEEK_TYPE_SET;
1411   }
1412 
1413   /* And finally, configure our output segment in the desired format */
1414   gst_segment_do_seek (segment, rate, dest_format, flags, start_type, start,
1415       stop_type, stop, &amp;update);
1416 
1417   if (!res)
1418     goto no_format;
1419 
1420   return res;
1421 
1422 no_format:
1423   {
1424     GST_DEBUG_OBJECT (src, &quot;undefined format given, seek aborted.&quot;);
1425     return FALSE;
1426   }
1427 }
1428 
1429 static gboolean
1430 gst_base_src_prepare_seek_segment (GstBaseSrc * src, GstEvent * event,
1431     GstSegment * seeksegment)
1432 {
1433   GstBaseSrcClass *bclass;
1434   gboolean result = FALSE;
1435 
1436   bclass = GST_BASE_SRC_GET_CLASS (src);
1437 
1438   if (bclass-&gt;prepare_seek_segment)
1439     result = bclass-&gt;prepare_seek_segment (src, event, seeksegment);
1440 
1441   return result;
1442 }
1443 
1444 static GstFlowReturn
1445 gst_base_src_default_alloc (GstBaseSrc * src, guint64 offset,
1446     guint size, GstBuffer ** buffer)
1447 {
1448   GstFlowReturn ret;
1449   GstBaseSrcPrivate *priv = src-&gt;priv;
1450   GstBufferPool *pool = NULL;
1451   GstAllocator *allocator = NULL;
1452   GstAllocationParams params;
1453 
1454   GST_OBJECT_LOCK (src);
1455   if (priv-&gt;pool) {
1456     pool = gst_object_ref (priv-&gt;pool);
1457   } else if (priv-&gt;allocator) {
1458     allocator = gst_object_ref (priv-&gt;allocator);
1459   }
1460   params = priv-&gt;params;
1461   GST_OBJECT_UNLOCK (src);
1462 
1463   if (pool) {
1464     ret = gst_buffer_pool_acquire_buffer (pool, buffer, NULL);
1465   } else if (size != -1) {
1466     *buffer = gst_buffer_new_allocate (allocator, size, &amp;params);
1467     if (G_UNLIKELY (*buffer == NULL))
1468       goto alloc_failed;
1469 
1470     ret = GST_FLOW_OK;
1471   } else {
1472     GST_WARNING_OBJECT (src, &quot;Not trying to alloc %u bytes. Blocksize not set?&quot;,
1473         size);
1474     goto alloc_failed;
1475   }
1476 
1477 done:
1478   if (pool)
1479     gst_object_unref (pool);
1480   if (allocator)
1481     gst_object_unref (allocator);
1482 
1483   return ret;
1484 
1485   /* ERRORS */
1486 alloc_failed:
1487   {
1488     GST_ERROR_OBJECT (src, &quot;Failed to allocate %u bytes&quot;, size);
1489     ret = GST_FLOW_ERROR;
1490     goto done;
1491   }
1492 }
1493 
1494 static GstFlowReturn
1495 gst_base_src_default_create (GstBaseSrc * src, guint64 offset,
1496     guint size, GstBuffer ** buffer)
1497 {
1498   GstBaseSrcClass *bclass;
1499   GstFlowReturn ret;
1500   GstBuffer *res_buf;
1501 
1502   bclass = GST_BASE_SRC_GET_CLASS (src);
1503 
1504   if (G_UNLIKELY (!bclass-&gt;alloc))
1505     goto no_function;
1506   if (G_UNLIKELY (!bclass-&gt;fill))
1507     goto no_function;
1508 
1509   if (*buffer == NULL) {
1510     /* downstream did not provide us with a buffer to fill, allocate one
1511      * ourselves */
1512     ret = bclass-&gt;alloc (src, offset, size, &amp;res_buf);
1513     if (G_UNLIKELY (ret != GST_FLOW_OK))
1514       goto alloc_failed;
1515   } else {
1516     res_buf = *buffer;
1517   }
1518 
1519   if (G_LIKELY (size &gt; 0)) {
1520     /* only call fill when there is a size */
1521     ret = bclass-&gt;fill (src, offset, size, res_buf);
1522     if (G_UNLIKELY (ret != GST_FLOW_OK))
1523       goto not_ok;
1524   }
1525 
1526   *buffer = res_buf;
1527 
1528   return GST_FLOW_OK;
1529 
1530   /* ERRORS */
1531 no_function:
1532   {
1533     GST_DEBUG_OBJECT (src, &quot;no fill or alloc function&quot;);
1534     return GST_FLOW_NOT_SUPPORTED;
1535   }
1536 alloc_failed:
1537   {
1538     GST_DEBUG_OBJECT (src, &quot;Failed to allocate buffer of %u bytes&quot;, size);
1539     return ret;
1540   }
1541 not_ok:
1542   {
1543     GST_DEBUG_OBJECT (src, &quot;fill returned %d (%s)&quot;, ret,
1544         gst_flow_get_name (ret));
1545     if (*buffer == NULL)
1546       gst_buffer_unref (res_buf);
1547     return ret;
1548   }
1549 }
1550 
1551 /* this code implements the seeking. It is a good example
1552  * handling all cases.
1553  *
1554  * A seek updates the currently configured segment.start
1555  * and segment.stop values based on the SEEK_TYPE. If the
1556  * segment.start value is updated, a seek to this new position
1557  * should be performed.
1558  *
1559  * The seek can only be executed when we are not currently
1560  * streaming any data, to make sure that this is the case, we
1561  * acquire the STREAM_LOCK which is taken when we are in the
1562  * _loop() function or when a getrange() is called. Normally
1563  * we will not receive a seek if we are operating in pull mode
1564  * though. When we operate as a live source we might block on the live
1565  * cond, which does not release the STREAM_LOCK. Therefore we will try
1566  * to grab the LIVE_LOCK instead of the STREAM_LOCK to make sure it is
1567  * safe to perform the seek.
1568  *
1569  * When we are in the loop() function, we might be in the middle
1570  * of pushing a buffer, which might block in a sink. To make sure
1571  * that the push gets unblocked we push out a FLUSH_START event.
1572  * Our loop function will get a FLUSHING return value from
1573  * the push and will pause, effectively releasing the STREAM_LOCK.
1574  *
1575  * For a non-flushing seek, we pause the task, which might eventually
1576  * release the STREAM_LOCK. We say eventually because when the sink
1577  * blocks on the sample we might wait a very long time until the sink
1578  * unblocks the sample. In any case we acquire the STREAM_LOCK and
1579  * can continue the seek. A non-flushing seek is normally done in a
1580  * running pipeline to perform seamless playback, this means that the sink is
1581  * PLAYING and will return from its chain function.
1582  * In the case of a non-flushing seek we need to make sure that the
1583  * data we output after the seek is continuous with the previous data,
1584  * this is because a non-flushing seek does not reset the running-time
1585  * to 0. We do this by closing the currently running segment, ie. sending
1586  * a new_segment event with the stop position set to the last processed
1587  * position.
1588  *
1589  * After updating the segment.start/stop values, we prepare for
1590  * streaming again. We push out a FLUSH_STOP to make the peer pad
1591  * accept data again and we start our task again.
1592  *
1593  * A segment seek posts a message on the bus saying that the playback
1594  * of the segment started. We store the segment flag internally because
1595  * when we reach the segment.stop we have to post a segment.done
1596  * instead of EOS when doing a segment seek.
1597  */
1598 static gboolean
1599 gst_base_src_perform_seek (GstBaseSrc * src, GstEvent * event, gboolean unlock)
1600 {
1601   gboolean res = TRUE, tres;
1602   gdouble rate;
1603   GstFormat seek_format, dest_format;
1604   GstSeekFlags flags;
1605   GstSeekType start_type, stop_type;
1606   gint64 start, stop;
1607   gboolean flush;
1608   gboolean update;
1609   gboolean relative_seek = FALSE;
1610   gboolean seekseg_configured = FALSE;
1611   GstSegment seeksegment;
1612   guint32 seqnum;
1613   GstEvent *tevent;
1614 
1615   GST_DEBUG_OBJECT (src, &quot;doing seek: %&quot; GST_PTR_FORMAT, event);
1616 
1617   GST_OBJECT_LOCK (src);
1618   dest_format = src-&gt;segment.format;
1619   GST_OBJECT_UNLOCK (src);
1620 
1621   if (event) {
1622     gst_event_parse_seek (event, &amp;rate, &amp;seek_format, &amp;flags,
1623         &amp;start_type, &amp;start, &amp;stop_type, &amp;stop);
1624 
1625     relative_seek = SEEK_TYPE_IS_RELATIVE (start_type) ||
1626         SEEK_TYPE_IS_RELATIVE (stop_type);
1627 
1628     if (dest_format != seek_format &amp;&amp; !relative_seek) {
1629       /* If we have an ABSOLUTE position (SEEK_SET only), we can convert it
1630        * here before taking the stream lock, otherwise we must convert it later,
1631        * once we have the stream lock and can read the last configures segment
1632        * start and stop positions */
1633       gst_segment_init (&amp;seeksegment, dest_format);
1634 
1635       if (!gst_base_src_prepare_seek_segment (src, event, &amp;seeksegment))
1636         goto prepare_failed;
1637 
1638       seekseg_configured = TRUE;
1639     }
1640 
1641     flush = flags &amp; GST_SEEK_FLAG_FLUSH;
1642     seqnum = gst_event_get_seqnum (event);
1643   } else {
1644     flush = FALSE;
1645     /* get next seqnum */
1646     seqnum = gst_util_seqnum_next ();
1647   }
1648 
1649   /* send flush start */
1650   if (flush) {
1651     tevent = gst_event_new_flush_start ();
1652     gst_event_set_seqnum (tevent, seqnum);
1653     gst_pad_push_event (src-&gt;srcpad, tevent);
1654   } else
1655     gst_pad_pause_task (src-&gt;srcpad);
1656 
1657   /* unblock streaming thread. */
1658   if (unlock)
1659     gst_base_src_set_flushing (src, TRUE);
1660 
1661   /* grab streaming lock, this should eventually be possible, either
1662    * because the task is paused, our streaming thread stopped
1663    * or because our peer is flushing. */
1664   GST_PAD_STREAM_LOCK (src-&gt;srcpad);
1665   if (G_UNLIKELY (src-&gt;priv-&gt;seqnum == seqnum)) {
1666     /* we have seen this event before, issue a warning for now */
1667     GST_WARNING_OBJECT (src, &quot;duplicate event found %&quot; G_GUINT32_FORMAT,
1668         seqnum);
1669   } else {
1670     src-&gt;priv-&gt;seqnum = seqnum;
1671     GST_DEBUG_OBJECT (src, &quot;seek with seqnum %&quot; G_GUINT32_FORMAT, seqnum);
1672   }
1673 
1674   if (unlock)
1675     gst_base_src_set_flushing (src, FALSE);
1676 
1677   /* If we configured the seeksegment above, don&#39;t overwrite it now. Otherwise
1678    * copy the current segment info into the temp segment that we can actually
1679    * attempt the seek with. We only update the real segment if the seek succeeds. */
1680   if (!seekseg_configured) {
1681     memcpy (&amp;seeksegment, &amp;src-&gt;segment, sizeof (GstSegment));
1682 
1683     /* now configure the final seek segment */
1684     if (event) {
1685       if (seeksegment.format != seek_format) {
1686         /* OK, here&#39;s where we give the subclass a chance to convert the relative
1687          * seek into an absolute one in the processing format. We set up any
1688          * absolute seek above, before taking the stream lock. */
1689         if (!gst_base_src_prepare_seek_segment (src, event, &amp;seeksegment)) {
1690           GST_DEBUG_OBJECT (src, &quot;Preparing the seek failed after flushing. &quot;
1691               &quot;Aborting seek&quot;);
1692           res = FALSE;
1693         }
1694       } else {
1695         /* The seek format matches our processing format, no need to ask the
1696          * the subclass to configure the segment. */
1697         gst_segment_do_seek (&amp;seeksegment, rate, seek_format, flags,
1698             start_type, start, stop_type, stop, &amp;update);
1699       }
1700     }
1701     /* Else, no seek event passed, so we&#39;re just (re)starting the
1702        current segment. */
1703   }
1704 
1705   if (res) {
1706     GST_DEBUG_OBJECT (src, &quot;segment configured from %&quot; G_GINT64_FORMAT
1707         &quot; to %&quot; G_GINT64_FORMAT &quot;, position %&quot; G_GINT64_FORMAT,
1708         seeksegment.start, seeksegment.stop, seeksegment.position);
1709 
1710     /* do the seek, segment.position contains the new position. */
1711     res = gst_base_src_do_seek (src, &amp;seeksegment);
1712   }
1713 
1714   /* and prepare to continue streaming */
1715   if (flush) {
1716     tevent = gst_event_new_flush_stop (TRUE);
1717     gst_event_set_seqnum (tevent, seqnum);
1718     /* send flush stop, peer will accept data and events again. We
1719      * are not yet providing data as we still have the STREAM_LOCK. */
1720     gst_pad_push_event (src-&gt;srcpad, tevent);
1721   }
1722 
1723   /* The subclass must have converted the segment to the processing format
1724    * by now */
1725   if (res &amp;&amp; seeksegment.format != dest_format) {
1726     GST_DEBUG_OBJECT (src, &quot;Subclass failed to prepare a seek segment &quot;
1727         &quot;in the correct format. Aborting seek.&quot;);
1728     res = FALSE;
1729   }
1730 
1731   /* if the seek was successful, we update our real segment and push
1732    * out the new segment. */
1733   if (res) {
1734     GST_OBJECT_LOCK (src);
1735     memcpy (&amp;src-&gt;segment, &amp;seeksegment, sizeof (GstSegment));
1736     GST_OBJECT_UNLOCK (src);
1737 
1738     if (seeksegment.flags &amp; GST_SEGMENT_FLAG_SEGMENT) {
1739       GstMessage *message;
1740 
1741       message = gst_message_new_segment_start (GST_OBJECT (src),
1742           seeksegment.format, seeksegment.position);
1743       gst_message_set_seqnum (message, seqnum);
1744 
1745       gst_element_post_message (GST_ELEMENT (src), message);
1746     }
1747 
1748     src-&gt;priv-&gt;segment_pending = TRUE;
1749     src-&gt;priv-&gt;segment_seqnum = seqnum;
1750   }
1751 
1752   src-&gt;priv-&gt;discont = TRUE;
1753   src-&gt;running = TRUE;
1754   /* and restart the task in case it got paused explicitly or by
1755    * the FLUSH_START event we pushed out. */
1756   tres = gst_pad_start_task (src-&gt;srcpad, (GstTaskFunction) gst_base_src_loop,
1757       src-&gt;srcpad, NULL);
1758   if (res &amp;&amp; !tres)
1759     res = FALSE;
1760 
1761   /* and release the lock again so we can continue streaming */
1762   GST_PAD_STREAM_UNLOCK (src-&gt;srcpad);
1763 
1764   return res;
1765 
1766   /* ERROR */
1767 prepare_failed:
1768   GST_DEBUG_OBJECT (src, &quot;Preparing the seek failed before flushing. &quot;
1769       &quot;Aborting seek&quot;);
1770   return FALSE;
1771 }
1772 
1773 /* all events send to this element directly. This is mainly done from the
1774  * application.
1775  */
1776 static gboolean
1777 gst_base_src_send_event (GstElement * element, GstEvent * event)
1778 {
1779   GstBaseSrc *src;
1780   gboolean result = FALSE;
1781   GstBaseSrcClass *bclass;
1782 
1783   src = GST_BASE_SRC (element);
1784   bclass = GST_BASE_SRC_GET_CLASS (src);
1785 
1786   GST_DEBUG_OBJECT (src, &quot;handling event %p %&quot; GST_PTR_FORMAT, event, event);
1787 
1788   switch (GST_EVENT_TYPE (event)) {
1789       /* bidirectional events */
1790     case GST_EVENT_FLUSH_START:
1791       GST_DEBUG_OBJECT (src, &quot;pushing flush-start event downstream&quot;);
1792 
1793       result = gst_pad_push_event (src-&gt;srcpad, event);
1794       gst_base_src_set_flushing (src, TRUE);
1795       event = NULL;
1796       break;
1797     case GST_EVENT_FLUSH_STOP:
1798     {
1799       gboolean start;
1800 
1801       GST_PAD_STREAM_LOCK (src-&gt;srcpad);
1802       gst_base_src_set_flushing (src, FALSE);
1803 
1804       GST_DEBUG_OBJECT (src, &quot;pushing flush-stop event downstream&quot;);
1805       result = gst_pad_push_event (src-&gt;srcpad, event);
1806 
1807       /* For external flush, restart the task .. */
1808       GST_LIVE_LOCK (src);
1809       src-&gt;priv-&gt;segment_pending = TRUE;
1810 
1811       GST_OBJECT_LOCK (src-&gt;srcpad);
1812       start = (GST_PAD_MODE (src-&gt;srcpad) == GST_PAD_MODE_PUSH);
1813       GST_OBJECT_UNLOCK (src-&gt;srcpad);
1814 
1815       /* ... and for live sources, only if in playing state */
1816       if (src-&gt;is_live) {
1817         if (!src-&gt;live_running)
1818           start = FALSE;
1819       }
1820 
1821       if (start)
1822         gst_pad_start_task (src-&gt;srcpad, (GstTaskFunction) gst_base_src_loop,
1823             src-&gt;srcpad, NULL);
1824 
1825       GST_LIVE_UNLOCK (src);
1826       GST_PAD_STREAM_UNLOCK (src-&gt;srcpad);
1827 
1828       event = NULL;
1829       break;
1830     }
1831 
1832       /* downstream serialized events */
1833     case GST_EVENT_EOS:
1834     {
1835       gboolean push_mode;
1836 
1837       /* queue EOS and make sure the task or pull function performs the EOS
1838        * actions.
1839        *
1840        * For push mode, This will be done in 3 steps. It is required to not
1841        * block here as gst_element_send_event() will hold the STATE_LOCK, hence
1842        * blocking would prevent asynchronous state change to complete.
1843        *
1844        * 1. We stop the streaming thread
1845        * 2. We set the pending eos
1846        * 3. We start the streaming thread again, so it is performed
1847        *    asynchronously.
1848        *
1849        * For pull mode, we simply mark the pending EOS without flushing.
1850        */
1851 
1852       GST_OBJECT_LOCK (src-&gt;srcpad);
1853       push_mode = GST_PAD_MODE (src-&gt;srcpad) == GST_PAD_MODE_PUSH;
1854       GST_OBJECT_UNLOCK (src-&gt;srcpad);
1855 
1856       if (push_mode) {
1857         gst_base_src_set_flushing (src, TRUE);
1858 
1859         GST_PAD_STREAM_LOCK (src-&gt;srcpad);
1860         gst_base_src_set_flushing (src, FALSE);
1861 
1862         GST_OBJECT_LOCK (src);
1863         g_atomic_int_set (&amp;src-&gt;priv-&gt;has_pending_eos, TRUE);
1864         if (src-&gt;priv-&gt;pending_eos)
1865           gst_event_unref (src-&gt;priv-&gt;pending_eos);
1866         src-&gt;priv-&gt;pending_eos = event;
1867         GST_OBJECT_UNLOCK (src);
1868 
1869         GST_DEBUG_OBJECT (src,
1870             &quot;EOS marked, start task for asynchronous handling&quot;);
1871         gst_pad_start_task (src-&gt;srcpad, (GstTaskFunction) gst_base_src_loop,
1872             src-&gt;srcpad, NULL);
1873 
1874         GST_PAD_STREAM_UNLOCK (src-&gt;srcpad);
1875       } else {
1876         /* In pull mode, we need not to return flushing to downstream, though
1877          * the stream lock is not kept after getrange was unblocked */
1878         GST_OBJECT_LOCK (src);
1879         g_atomic_int_set (&amp;src-&gt;priv-&gt;has_pending_eos, TRUE);
1880         if (src-&gt;priv-&gt;pending_eos)
1881           gst_event_unref (src-&gt;priv-&gt;pending_eos);
1882         src-&gt;priv-&gt;pending_eos = event;
1883         GST_OBJECT_UNLOCK (src);
1884 
1885         gst_base_src_set_pool_flushing (src, TRUE);
1886         if (bclass-&gt;unlock)
1887           bclass-&gt;unlock (src);
1888 
1889         GST_PAD_STREAM_LOCK (src-&gt;srcpad);
1890         if (bclass-&gt;unlock_stop)
1891           bclass-&gt;unlock_stop (src);
1892         gst_base_src_set_pool_flushing (src, TRUE);
1893         GST_PAD_STREAM_UNLOCK (src-&gt;srcpad);
1894       }
1895 
1896 
1897       event = NULL;
1898       result = TRUE;
1899       break;
1900     }
1901     case GST_EVENT_SEGMENT:
1902       /* sending random SEGMENT downstream can break sync. */
1903       break;
1904     case GST_EVENT_TAG:
1905     case GST_EVENT_SINK_MESSAGE:
1906     case GST_EVENT_CUSTOM_DOWNSTREAM:
1907     case GST_EVENT_CUSTOM_BOTH:
1908     case GST_EVENT_PROTECTION:
1909       /* Insert TAG, CUSTOM_DOWNSTREAM, CUSTOM_BOTH, PROTECTION in the dataflow */
1910       GST_OBJECT_LOCK (src);
1911       src-&gt;priv-&gt;pending_events =
1912           g_list_append (src-&gt;priv-&gt;pending_events, event);
1913       g_atomic_int_set (&amp;src-&gt;priv-&gt;have_events, TRUE);
1914       GST_OBJECT_UNLOCK (src);
1915       event = NULL;
1916       result = TRUE;
1917       break;
1918     case GST_EVENT_BUFFERSIZE:
1919       /* does not seem to make much sense currently */
1920       break;
1921 
1922       /* upstream events */
1923     case GST_EVENT_QOS:
1924       /* elements should override send_event and do something */
1925       break;
1926     case GST_EVENT_SEEK:
1927     {
1928       gboolean started;
1929 
1930       GST_OBJECT_LOCK (src-&gt;srcpad);
1931       if (GST_PAD_MODE (src-&gt;srcpad) == GST_PAD_MODE_PULL)
1932         goto wrong_mode;
1933       started = GST_PAD_MODE (src-&gt;srcpad) == GST_PAD_MODE_PUSH;
1934       GST_OBJECT_UNLOCK (src-&gt;srcpad);
1935 
1936       if (started) {
1937         GST_DEBUG_OBJECT (src, &quot;performing seek&quot;);
1938         /* when we are running in push mode, we can execute the
1939          * seek right now. */
1940         result = gst_base_src_perform_seek (src, event, TRUE);
1941       } else {
1942         GstEvent **event_p;
1943 
1944         /* else we store the event and execute the seek when we
1945          * get activated */
1946         GST_OBJECT_LOCK (src);
1947         GST_DEBUG_OBJECT (src, &quot;queueing seek&quot;);
1948         event_p = &amp;src-&gt;pending_seek;
1949         gst_event_replace ((GstEvent **) event_p, event);
1950         GST_OBJECT_UNLOCK (src);
1951         /* assume the seek will work */
1952         result = TRUE;
1953       }
1954       break;
1955     }
1956     case GST_EVENT_NAVIGATION:
1957       /* could make sense for elements that do something with navigation events
1958        * but then they would need to override the send_event function */
1959       break;
1960     case GST_EVENT_LATENCY:
1961       /* does not seem to make sense currently */
1962       break;
1963 
1964       /* custom events */
1965     case GST_EVENT_CUSTOM_UPSTREAM:
1966       /* override send_event if you want this */
1967       break;
1968     case GST_EVENT_CUSTOM_DOWNSTREAM_OOB:
1969     case GST_EVENT_CUSTOM_BOTH_OOB:
1970       /* insert a random custom event into the pipeline */
1971       GST_DEBUG_OBJECT (src, &quot;pushing custom OOB event downstream&quot;);
1972       result = gst_pad_push_event (src-&gt;srcpad, event);
1973       /* we gave away the ref to the event in the push */
1974       event = NULL;
1975       break;
1976     default:
1977       break;
1978   }
1979 done:
1980   /* if we still have a ref to the event, unref it now */
1981   if (event)
1982     gst_event_unref (event);
1983 
1984   return result;
1985 
1986   /* ERRORS */
1987 wrong_mode:
1988   {
1989     GST_DEBUG_OBJECT (src, &quot;cannot perform seek when operating in pull mode&quot;);
1990     GST_OBJECT_UNLOCK (src-&gt;srcpad);
1991     result = FALSE;
1992     goto done;
1993   }
1994 }
1995 
1996 static gboolean
1997 gst_base_src_seekable (GstBaseSrc * src)
1998 {
1999   GstBaseSrcClass *bclass;
2000   bclass = GST_BASE_SRC_GET_CLASS (src);
2001   if (bclass-&gt;is_seekable)
2002     return bclass-&gt;is_seekable (src);
2003   else
2004     return FALSE;
2005 }
2006 
2007 static void
2008 gst_base_src_update_qos (GstBaseSrc * src,
2009     gdouble proportion, GstClockTimeDiff diff, GstClockTime timestamp)
2010 {
2011   GST_CAT_DEBUG_OBJECT (GST_CAT_QOS, src,
2012       &quot;qos: proportion: %lf, diff %&quot; G_GINT64_FORMAT &quot;, timestamp %&quot;
2013       GST_TIME_FORMAT, proportion, diff, GST_TIME_ARGS (timestamp));
2014 
2015   GST_OBJECT_LOCK (src);
2016   src-&gt;priv-&gt;proportion = proportion;
2017   src-&gt;priv-&gt;earliest_time = timestamp + diff;
2018   GST_OBJECT_UNLOCK (src);
2019 }
2020 
2021 
2022 static gboolean
2023 gst_base_src_default_event (GstBaseSrc * src, GstEvent * event)
2024 {
2025   gboolean result;
2026 
2027   GST_DEBUG_OBJECT (src, &quot;handle event %&quot; GST_PTR_FORMAT, event);
2028 
2029   switch (GST_EVENT_TYPE (event)) {
2030     case GST_EVENT_SEEK:
2031       /* is normally called when in push mode */
2032       if (!gst_base_src_seekable (src))
2033         goto not_seekable;
2034 
2035       result = gst_base_src_perform_seek (src, event, TRUE);
2036       break;
2037     case GST_EVENT_FLUSH_START:
2038       /* cancel any blocking getrange, is normally called
2039        * when in pull mode. */
2040       result = gst_base_src_set_flushing (src, TRUE);
2041       break;
2042     case GST_EVENT_FLUSH_STOP:
2043       result = gst_base_src_set_flushing (src, FALSE);
2044       break;
2045     case GST_EVENT_QOS:
2046     {
2047       gdouble proportion;
2048       GstClockTimeDiff diff;
2049       GstClockTime timestamp;
2050 
2051       gst_event_parse_qos (event, NULL, &amp;proportion, &amp;diff, &amp;timestamp);
2052       gst_base_src_update_qos (src, proportion, diff, timestamp);
2053       result = TRUE;
2054       break;
2055     }
2056     case GST_EVENT_RECONFIGURE:
2057       result = TRUE;
2058       break;
2059     case GST_EVENT_LATENCY:
2060       result = TRUE;
2061       break;
2062     default:
2063       result = FALSE;
2064       break;
2065   }
2066   return result;
2067 
2068   /* ERRORS */
2069 not_seekable:
2070   {
2071     GST_DEBUG_OBJECT (src, &quot;is not seekable&quot;);
2072     return FALSE;
2073   }
2074 }
2075 
2076 static gboolean
2077 gst_base_src_event (GstPad * pad, GstObject * parent, GstEvent * event)
2078 {
2079   GstBaseSrc *src;
2080   GstBaseSrcClass *bclass;
2081   gboolean result = FALSE;
2082 
2083   src = GST_BASE_SRC (parent);
2084   bclass = GST_BASE_SRC_GET_CLASS (src);
2085 
2086   if (bclass-&gt;event) {
2087     if (!(result = bclass-&gt;event (src, event)))
2088       goto subclass_failed;
2089   }
2090 
2091 done:
2092   gst_event_unref (event);
2093 
2094   return result;
2095 
2096   /* ERRORS */
2097 subclass_failed:
2098   {
2099     GST_DEBUG_OBJECT (src, &quot;subclass refused event&quot;);
2100     goto done;
2101   }
2102 }
2103 
2104 static void
2105 gst_base_src_set_property (GObject * object, guint prop_id,
2106     const GValue * value, GParamSpec * pspec)
2107 {
2108   GstBaseSrc *src;
2109 
2110   src = GST_BASE_SRC (object);
2111 
2112   switch (prop_id) {
2113     case PROP_BLOCKSIZE:
2114       gst_base_src_set_blocksize (src, g_value_get_uint (value));
2115       break;
2116     case PROP_NUM_BUFFERS:
2117       src-&gt;num_buffers = g_value_get_int (value);
2118       break;
2119 #ifndef GST_REMOVE_DEPRECATED
2120     case PROP_TYPEFIND:
2121       src-&gt;typefind = g_value_get_boolean (value);
2122       break;
2123 #endif
2124     case PROP_DO_TIMESTAMP:
2125       gst_base_src_set_do_timestamp (src, g_value_get_boolean (value));
2126       break;
2127     default:
2128       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
2129       break;
2130   }
2131 }
2132 
2133 static void
2134 gst_base_src_get_property (GObject * object, guint prop_id, GValue * value,
2135     GParamSpec * pspec)
2136 {
2137   GstBaseSrc *src;
2138 
2139   src = GST_BASE_SRC (object);
2140 
2141   switch (prop_id) {
2142     case PROP_BLOCKSIZE:
2143       g_value_set_uint (value, gst_base_src_get_blocksize (src));
2144       break;
2145     case PROP_NUM_BUFFERS:
2146       g_value_set_int (value, src-&gt;num_buffers);
2147       break;
2148 #ifndef GST_REMOVE_DEPRECATED
2149     case PROP_TYPEFIND:
2150       g_value_set_boolean (value, src-&gt;typefind);
2151       break;
2152 #endif
2153     case PROP_DO_TIMESTAMP:
2154       g_value_set_boolean (value, gst_base_src_get_do_timestamp (src));
2155       break;
2156     default:
2157       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
2158       break;
2159   }
2160 }
2161 
2162 /* with STREAM_LOCK and LOCK */
2163 static GstClockReturn
2164 gst_base_src_wait (GstBaseSrc * basesrc, GstClock * clock, GstClockTime time)
2165 {
2166   GstClockReturn ret;
2167   GstClockID id;
2168 
2169   id = gst_clock_new_single_shot_id (clock, time);
2170 
2171   basesrc-&gt;clock_id = id;
2172   /* release the live lock while waiting */
2173   GST_LIVE_UNLOCK (basesrc);
2174 
2175   ret = gst_clock_id_wait (id, NULL);
2176 
2177   GST_LIVE_LOCK (basesrc);
2178   gst_clock_id_unref (id);
2179   basesrc-&gt;clock_id = NULL;
2180 
2181   return ret;
2182 }
2183 
2184 /* perform synchronisation on a buffer.
2185  * with STREAM_LOCK.
2186  */
2187 static GstClockReturn
2188 gst_base_src_do_sync (GstBaseSrc * basesrc, GstBuffer * buffer)
2189 {
2190   GstClockReturn result;
2191   GstClockTime start, end;
2192   GstBaseSrcClass *bclass;
2193   GstClockTime base_time;
2194   GstClock *clock;
2195   GstClockTime now = GST_CLOCK_TIME_NONE, pts, dts, timestamp;
2196   gboolean do_timestamp, first, pseudo_live, is_live;
2197 
2198   bclass = GST_BASE_SRC_GET_CLASS (basesrc);
2199 
2200   start = end = -1;
2201   if (bclass-&gt;get_times)
2202     bclass-&gt;get_times (basesrc, buffer, &amp;start, &amp;end);
2203 
2204   /* get buffer timestamp */
2205   dts = GST_BUFFER_DTS (buffer);
2206   pts = GST_BUFFER_PTS (buffer);
2207 
2208   if (GST_CLOCK_TIME_IS_VALID (dts))
2209     timestamp = dts;
2210   else
2211     timestamp = pts;
2212 
2213   /* grab the lock to prepare for clocking and calculate the startup
2214    * latency. */
2215   GST_OBJECT_LOCK (basesrc);
2216 
2217   is_live = basesrc-&gt;is_live;
2218   /* if we are asked to sync against the clock we are a pseudo live element */
2219   pseudo_live = (start != -1 &amp;&amp; is_live);
2220   /* check for the first buffer */
2221   first = (basesrc-&gt;priv-&gt;latency == -1);
2222 
2223   if (timestamp != -1 &amp;&amp; pseudo_live) {
2224     GstClockTime latency;
2225 
2226     /* we have a timestamp and a sync time, latency is the diff */
2227     if (timestamp &lt;= start)
2228       latency = start - timestamp;
2229     else
2230       latency = 0;
2231 
2232     if (first) {
2233       GST_DEBUG_OBJECT (basesrc, &quot;pseudo_live with latency %&quot; GST_TIME_FORMAT,
2234           GST_TIME_ARGS (latency));
2235       /* first time we calculate latency, just configure */
2236       basesrc-&gt;priv-&gt;latency = latency;
2237     } else {
2238       if (basesrc-&gt;priv-&gt;latency != latency) {
2239         /* we have a new latency, FIXME post latency message */
2240         basesrc-&gt;priv-&gt;latency = latency;
2241         GST_DEBUG_OBJECT (basesrc, &quot;latency changed to %&quot; GST_TIME_FORMAT,
2242             GST_TIME_ARGS (latency));
2243       }
2244     }
2245   } else if (first) {
2246     GST_DEBUG_OBJECT (basesrc, &quot;no latency needed, live %d, sync %d&quot;,
2247         is_live, start != -1);
2248     basesrc-&gt;priv-&gt;latency = 0;
2249   }
2250 
2251   /* get clock, if no clock, we can&#39;t sync or do timestamps */
2252   if ((clock = GST_ELEMENT_CLOCK (basesrc)) == NULL)
2253     goto no_clock;
2254   else
2255     gst_object_ref (clock);
2256 
2257   base_time = GST_ELEMENT_CAST (basesrc)-&gt;base_time;
2258 
2259   do_timestamp = basesrc-&gt;priv-&gt;do_timestamp;
2260   GST_OBJECT_UNLOCK (basesrc);
2261 
2262   /* first buffer, calculate the timestamp offset */
2263   if (first) {
2264     GstClockTime running_time;
2265 
2266     now = gst_clock_get_time (clock);
2267     running_time = now - base_time;
2268 
2269     GST_LOG_OBJECT (basesrc,
2270         &quot;startup PTS: %&quot; GST_TIME_FORMAT &quot;, DTS %&quot; GST_TIME_FORMAT
2271         &quot;, running_time %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (pts),
2272         GST_TIME_ARGS (dts), GST_TIME_ARGS (running_time));
2273 
2274     if (pseudo_live &amp;&amp; timestamp != -1) {
2275       /* live source and we need to sync, add startup latency to all timestamps
2276        * to get the real running_time. Live sources should always timestamp
2277        * according to the current running time. */
2278       basesrc-&gt;priv-&gt;ts_offset = GST_CLOCK_DIFF (timestamp, running_time);
2279 
2280       GST_LOG_OBJECT (basesrc, &quot;live with sync, ts_offset %&quot; GST_TIME_FORMAT,
2281           GST_TIME_ARGS (basesrc-&gt;priv-&gt;ts_offset));
2282     } else {
2283       basesrc-&gt;priv-&gt;ts_offset = 0;
2284       GST_LOG_OBJECT (basesrc, &quot;no timestamp offset needed&quot;);
2285     }
2286 
2287     if (!GST_CLOCK_TIME_IS_VALID (dts)) {
2288       if (do_timestamp) {
2289         dts = running_time;
2290       } else if (!GST_CLOCK_TIME_IS_VALID (pts)) {
2291         if (GST_CLOCK_TIME_IS_VALID (basesrc-&gt;segment.start)) {
2292           dts = basesrc-&gt;segment.start;
2293         } else {
2294           dts = 0;
2295         }
2296       }
2297       GST_BUFFER_DTS (buffer) = dts;
2298 
2299       GST_LOG_OBJECT (basesrc, &quot;created DTS %&quot; GST_TIME_FORMAT,
2300           GST_TIME_ARGS (dts));
2301     }
2302   } else {
2303     /* not the first buffer, the timestamp is the diff between the clock and
2304      * base_time */
2305     if (do_timestamp &amp;&amp; !GST_CLOCK_TIME_IS_VALID (dts)) {
2306       now = gst_clock_get_time (clock);
2307 
2308       dts = now - base_time;
2309       GST_BUFFER_DTS (buffer) = dts;
2310 
2311       GST_LOG_OBJECT (basesrc, &quot;created DTS %&quot; GST_TIME_FORMAT,
2312           GST_TIME_ARGS (dts));
2313     }
2314   }
2315   if (!GST_CLOCK_TIME_IS_VALID (pts)) {
2316     if (!GST_BUFFER_FLAG_IS_SET (buffer, GST_BUFFER_FLAG_DELTA_UNIT))
2317       pts = dts;
2318 
2319     GST_BUFFER_PTS (buffer) = dts;
2320 
2321     GST_LOG_OBJECT (basesrc, &quot;created PTS %&quot; GST_TIME_FORMAT,
2322         GST_TIME_ARGS (pts));
2323   }
2324 
2325   /* if we don&#39;t have a buffer timestamp, we don&#39;t sync */
2326   if (!GST_CLOCK_TIME_IS_VALID (start))
2327     goto no_sync;
2328 
2329   if (is_live) {
2330     /* for pseudo live sources, add our ts_offset to the timestamp */
2331     if (GST_CLOCK_TIME_IS_VALID (pts))
2332       GST_BUFFER_PTS (buffer) += basesrc-&gt;priv-&gt;ts_offset;
2333     if (GST_CLOCK_TIME_IS_VALID (dts))
2334       GST_BUFFER_DTS (buffer) += basesrc-&gt;priv-&gt;ts_offset;
2335     start += basesrc-&gt;priv-&gt;ts_offset;
2336   }
2337 
2338   GST_LOG_OBJECT (basesrc,
2339       &quot;waiting for clock, base time %&quot; GST_TIME_FORMAT
2340       &quot;, stream_start %&quot; GST_TIME_FORMAT,
2341       GST_TIME_ARGS (base_time), GST_TIME_ARGS (start));
2342 
2343   result = gst_base_src_wait (basesrc, clock, start + base_time);
2344 
2345   gst_object_unref (clock);
2346 
2347   GST_LOG_OBJECT (basesrc, &quot;clock entry done: %d&quot;, result);
2348 
2349   return result;
2350 
2351   /* special cases */
2352 no_clock:
2353   {
2354     GST_DEBUG_OBJECT (basesrc, &quot;we have no clock&quot;);
2355     GST_OBJECT_UNLOCK (basesrc);
2356     return GST_CLOCK_OK;
2357   }
2358 no_sync:
2359   {
2360     GST_DEBUG_OBJECT (basesrc, &quot;no sync needed&quot;);
2361     gst_object_unref (clock);
2362     return GST_CLOCK_OK;
2363   }
2364 }
2365 
2366 /* Called with STREAM_LOCK and LIVE_LOCK */
2367 static gboolean
2368 gst_base_src_update_length (GstBaseSrc * src, guint64 offset, guint * length,
2369     gboolean force)
2370 {
2371   guint64 size, maxsize;
2372   GstBaseSrcClass *bclass;
2373   gint64 stop;
2374 
2375   /* only operate if we are working with bytes */
2376   if (src-&gt;segment.format != GST_FORMAT_BYTES)
2377     return TRUE;
2378 
2379   bclass = GST_BASE_SRC_GET_CLASS (src);
2380 
2381   stop = src-&gt;segment.stop;
2382   /* get total file size */
2383   size = src-&gt;segment.duration;
2384 
2385   /* when not doing automatic EOS, just use the stop position. We don&#39;t use
2386    * the size to check for EOS */
2387   if (!g_atomic_int_get (&amp;src-&gt;priv-&gt;automatic_eos))
2388     maxsize = stop;
2389   /* Otherwise, the max amount of bytes to read is the total
2390    * size or up to the segment.stop if present. */
2391   else if (stop != -1)
2392     maxsize = size != -1 ? MIN (size, stop) : stop;
2393   else
2394     maxsize = size;
2395 
2396   GST_DEBUG_OBJECT (src,
2397       &quot;reading offset %&quot; G_GUINT64_FORMAT &quot;, length %u, size %&quot; G_GINT64_FORMAT
2398       &quot;, segment.stop %&quot; G_GINT64_FORMAT &quot;, maxsize %&quot; G_GINT64_FORMAT, offset,
2399       *length, size, stop, maxsize);
2400 
2401   /* check size if we have one */
2402   if (maxsize != -1) {
2403     /* if we run past the end, check if the file became bigger and
2404      * retry.  Mind wrap when checking. */
2405     if (G_UNLIKELY (offset &gt;= maxsize || offset + *length &gt;= maxsize || force)) {
2406       /* see if length of the file changed */
2407       if (bclass-&gt;get_size)
2408         if (!bclass-&gt;get_size (src, &amp;size))
2409           size = -1;
2410 
2411       /* when not doing automatic EOS, just use the stop position. We don&#39;t use
2412        * the size to check for EOS */
2413       if (!g_atomic_int_get (&amp;src-&gt;priv-&gt;automatic_eos))
2414         maxsize = stop;
2415       /* Otherwise, the max amount of bytes to read is the total
2416        * size or up to the segment.stop if present. */
2417       else if (stop != -1)
2418         maxsize = size != -1 ? MIN (size, stop) : stop;
2419       else
2420         maxsize = size;
2421 
2422       if (maxsize != -1) {
2423         /* if we are at or past the end, EOS */
2424         if (G_UNLIKELY (offset &gt;= maxsize))
2425           goto unexpected_length;
2426 
2427         /* else we can clip to the end */
2428         if (G_UNLIKELY (offset + *length &gt;= maxsize))
2429           *length = maxsize - offset;
2430       }
2431     }
2432   }
2433 
2434   /* keep track of current duration. segment is in bytes, we checked
2435    * that above. */
2436   GST_OBJECT_LOCK (src);
2437   src-&gt;segment.duration = size;
2438   GST_OBJECT_UNLOCK (src);
2439 
2440   return TRUE;
2441 
2442   /* ERRORS */
2443 unexpected_length:
2444   {
<a name="9" id="anc9"></a><span class="line-modified">2445     GST_WARNING_OBJECT (src, &quot;processing at or past EOS&quot;);</span>
2446     return FALSE;
2447   }
2448 }
2449 
2450 /* must be called with LIVE_LOCK */
2451 static GstFlowReturn
2452 gst_base_src_get_range (GstBaseSrc * src, guint64 offset, guint length,
2453     GstBuffer ** buf)
2454 {
2455   GstFlowReturn ret;
2456   GstBaseSrcClass *bclass;
2457   GstClockReturn status;
2458   GstBuffer *res_buf;
2459   GstBuffer *in_buf;
2460   gboolean own_res_buf;
2461 
2462   bclass = GST_BASE_SRC_GET_CLASS (src);
2463 
2464 again:
2465   if (src-&gt;is_live) {
2466     if (G_UNLIKELY (!src-&gt;live_running)) {
2467       ret = gst_base_src_wait_playing_unlocked (src);
2468       if (ret != GST_FLOW_OK)
2469         goto stopped;
2470     }
2471   }
2472 
2473   if (G_UNLIKELY (!GST_BASE_SRC_IS_STARTED (src)
2474           &amp;&amp; !GST_BASE_SRC_IS_STARTING (src)))
2475     goto not_started;
2476 
2477   if (G_UNLIKELY (!bclass-&gt;create))
2478     goto no_function;
2479 
2480   if (G_UNLIKELY (!gst_base_src_update_length (src, offset, &amp;length, FALSE)))
2481     goto unexpected_length;
2482 
2483   /* track position */
2484   GST_OBJECT_LOCK (src);
2485   if (src-&gt;segment.format == GST_FORMAT_BYTES)
2486     src-&gt;segment.position = offset;
2487   GST_OBJECT_UNLOCK (src);
2488 
2489   /* normally we don&#39;t count buffers */
2490   if (G_UNLIKELY (src-&gt;num_buffers_left &gt;= 0)) {
2491     if (src-&gt;num_buffers_left == 0)
2492       goto reached_num_buffers;
2493     else
2494       src-&gt;num_buffers_left--;
2495   }
2496 
2497   /* don&#39;t enter the create function if a pending EOS event was set. For the
2498    * logic of the has_pending_eos, check the event function of this class. */
2499   if (G_UNLIKELY (g_atomic_int_get (&amp;src-&gt;priv-&gt;has_pending_eos))) {
2500     src-&gt;priv-&gt;forced_eos = TRUE;
2501     goto eos;
2502   }
2503 
2504   GST_DEBUG_OBJECT (src,
2505       &quot;calling create offset %&quot; G_GUINT64_FORMAT &quot; length %u, time %&quot;
2506       G_GINT64_FORMAT, offset, length, src-&gt;segment.time);
2507 
2508   res_buf = in_buf = *buf;
2509   own_res_buf = (*buf == NULL);
2510 
2511   GST_LIVE_UNLOCK (src);
2512   ret = bclass-&gt;create (src, offset, length, &amp;res_buf);
2513   GST_LIVE_LOCK (src);
2514 
2515   /* As we released the LIVE_LOCK, the state may have changed */
2516   if (src-&gt;is_live) {
2517     if (G_UNLIKELY (!src-&gt;live_running)) {
2518       GstFlowReturn wait_ret;
2519       wait_ret = gst_base_src_wait_playing_unlocked (src);
2520       if (wait_ret != GST_FLOW_OK) {
2521         if (ret == GST_FLOW_OK &amp;&amp; own_res_buf)
2522           gst_buffer_unref (res_buf);
2523         ret = wait_ret;
2524         goto stopped;
2525       }
2526     }
2527   }
2528 
2529   /* The create function could be unlocked because we have a pending EOS. It&#39;s
2530    * possible that we have a valid buffer from create that we need to
2531    * discard when the create function returned _OK. */
2532   if (G_UNLIKELY (g_atomic_int_get (&amp;src-&gt;priv-&gt;has_pending_eos))) {
2533     if (ret == GST_FLOW_OK) {
2534       if (own_res_buf)
2535         gst_buffer_unref (res_buf);
2536     }
2537     src-&gt;priv-&gt;forced_eos = TRUE;
2538     goto eos;
2539   }
2540 
2541   if (G_UNLIKELY (ret != GST_FLOW_OK))
2542     goto not_ok;
2543 
2544   /* fallback in case the create function didn&#39;t fill a provided buffer */
2545   if (in_buf != NULL &amp;&amp; res_buf != in_buf) {
2546     GstMapInfo info;
2547     gsize copied_size;
2548 
2549     GST_CAT_DEBUG_OBJECT (GST_CAT_PERFORMANCE, src, &quot;create function didn&#39;t &quot;
2550         &quot;fill the provided buffer, copying&quot;);
2551 
2552     if (!gst_buffer_map (in_buf, &amp;info, GST_MAP_WRITE))
2553       goto map_failed;
2554 
2555     copied_size = gst_buffer_extract (res_buf, 0, info.data, info.size);
2556     gst_buffer_unmap (in_buf, &amp;info);
2557     gst_buffer_set_size (in_buf, copied_size);
2558 
2559     gst_buffer_copy_into (in_buf, res_buf, GST_BUFFER_COPY_METADATA, 0, -1);
2560 
2561     gst_buffer_unref (res_buf);
2562     res_buf = in_buf;
2563   }
2564 
2565   if (res_buf == NULL) {
2566     GstBufferList *pending_list = src-&gt;priv-&gt;pending_bufferlist;
2567 
2568     if (pending_list == NULL || gst_buffer_list_length (pending_list) == 0)
2569       goto null_buffer;
2570 
2571     res_buf = gst_buffer_list_get_writable (pending_list, 0);
2572     own_res_buf = FALSE;
2573   }
2574 
2575   /* no timestamp set and we are at offset 0, we can timestamp with 0 */
2576   if (offset == 0 &amp;&amp; src-&gt;segment.time == 0
2577       &amp;&amp; GST_BUFFER_DTS (res_buf) == -1 &amp;&amp; !src-&gt;is_live) {
2578     GST_DEBUG_OBJECT (src, &quot;setting first timestamp to 0&quot;);
2579     res_buf = gst_buffer_make_writable (res_buf);
2580     GST_BUFFER_DTS (res_buf) = 0;
2581   }
2582 
2583   /* now sync before pushing the buffer */
2584   status = gst_base_src_do_sync (src, res_buf);
2585 
2586   /* waiting for the clock could have made us flushing */
2587   if (G_UNLIKELY (src-&gt;priv-&gt;flushing))
2588     goto flushing;
2589 
2590   switch (status) {
2591     case GST_CLOCK_EARLY:
2592       /* the buffer is too late. We currently don&#39;t drop the buffer. */
2593       GST_DEBUG_OBJECT (src, &quot;buffer too late!, returning anyway&quot;);
2594       break;
2595     case GST_CLOCK_OK:
2596       /* buffer synchronised properly */
2597       GST_DEBUG_OBJECT (src, &quot;buffer ok&quot;);
2598       break;
2599     case GST_CLOCK_UNSCHEDULED:
2600       /* this case is triggered when we were waiting for the clock and
2601        * it got unlocked because we did a state change. In any case, get rid of
2602        * the buffer. */
2603       if (own_res_buf)
2604         gst_buffer_unref (res_buf);
2605 
2606       if (!src-&gt;live_running) {
2607         /* We return FLUSHING when we are not running to stop the dataflow also
2608          * get rid of the produced buffer. */
2609         GST_DEBUG_OBJECT (src,
2610             &quot;clock was unscheduled (%d), returning FLUSHING&quot;, status);
2611         ret = GST_FLOW_FLUSHING;
2612       } else {
2613         /* If we are running when this happens, we quickly switched between
2614          * pause and playing. We try to produce a new buffer */
2615         GST_DEBUG_OBJECT (src,
2616             &quot;clock was unscheduled (%d), but we are running&quot;, status);
2617         goto again;
2618       }
2619       break;
2620     default:
2621       /* all other result values are unexpected and errors */
2622       GST_ELEMENT_ERROR (src, CORE, CLOCK,
2623           (_(&quot;Internal clock error.&quot;)),
2624           (&quot;clock returned unexpected return value %d&quot;, status));
2625       if (own_res_buf)
2626         gst_buffer_unref (res_buf);
2627       ret = GST_FLOW_ERROR;
2628       break;
2629   }
2630   if (G_LIKELY (ret == GST_FLOW_OK))
2631     *buf = res_buf;
2632 
2633   return ret;
2634 
2635   /* ERROR */
2636 stopped:
2637   {
2638     GST_DEBUG_OBJECT (src, &quot;wait_playing returned %d (%s)&quot;, ret,
2639         gst_flow_get_name (ret));
2640     return ret;
2641   }
2642 not_ok:
2643   {
2644     GST_DEBUG_OBJECT (src, &quot;create returned %d (%s)&quot;, ret,
2645         gst_flow_get_name (ret));
2646     return ret;
2647   }
2648 map_failed:
2649   {
2650     GST_ELEMENT_ERROR (src, RESOURCE, BUSY,
2651         (_(&quot;Failed to map buffer.&quot;)),
2652         (&quot;failed to map result buffer in WRITE mode&quot;));
2653     if (own_res_buf)
2654       gst_buffer_unref (res_buf);
2655     return GST_FLOW_ERROR;
2656   }
2657 not_started:
2658   {
2659     GST_DEBUG_OBJECT (src, &quot;getrange but not started&quot;);
2660     return GST_FLOW_FLUSHING;
2661   }
2662 no_function:
2663   {
2664     GST_DEBUG_OBJECT (src, &quot;no create function&quot;);
2665     return GST_FLOW_NOT_SUPPORTED;
2666   }
2667 unexpected_length:
2668   {
2669     GST_DEBUG_OBJECT (src, &quot;unexpected length %u (offset=%&quot; G_GUINT64_FORMAT
2670         &quot;, size=%&quot; G_GINT64_FORMAT &quot;)&quot;, length, offset, src-&gt;segment.duration);
2671     return GST_FLOW_EOS;
2672   }
2673 reached_num_buffers:
2674   {
2675     GST_DEBUG_OBJECT (src, &quot;sent all buffers&quot;);
2676     return GST_FLOW_EOS;
2677   }
2678 flushing:
2679   {
2680     GST_DEBUG_OBJECT (src, &quot;we are flushing&quot;);
2681     if (own_res_buf)
2682       gst_buffer_unref (res_buf);
2683     return GST_FLOW_FLUSHING;
2684   }
2685 eos:
2686   {
2687     GST_DEBUG_OBJECT (src, &quot;we are EOS&quot;);
2688     return GST_FLOW_EOS;
2689   }
2690 null_buffer:
2691   {
2692     GST_ELEMENT_ERROR (src, STREAM, FAILED,
2693         (_(&quot;Internal data flow error.&quot;)),
2694         (&quot;Subclass %s neither returned a buffer nor submitted a buffer list &quot;
2695             &quot;from its create function&quot;, G_OBJECT_TYPE_NAME (src)));
2696     return GST_FLOW_ERROR;
2697   }
2698 }
2699 
2700 static GstFlowReturn
2701 gst_base_src_getrange (GstPad * pad, GstObject * parent, guint64 offset,
2702     guint length, GstBuffer ** buf)
2703 {
2704   GstBaseSrc *src;
2705   GstFlowReturn res;
2706 
2707   src = GST_BASE_SRC_CAST (parent);
2708 
2709   GST_LIVE_LOCK (src);
2710   if (G_UNLIKELY (src-&gt;priv-&gt;flushing))
2711     goto flushing;
2712 
2713   res = gst_base_src_get_range (src, offset, length, buf);
2714 
2715 done:
2716   GST_LIVE_UNLOCK (src);
2717 
2718   return res;
2719 
2720   /* ERRORS */
2721 flushing:
2722   {
2723     GST_DEBUG_OBJECT (src, &quot;we are flushing&quot;);
2724     res = GST_FLOW_FLUSHING;
2725     goto done;
2726   }
2727 }
2728 
2729 static gboolean
2730 gst_base_src_is_random_access (GstBaseSrc * src)
2731 {
2732   /* we need to start the basesrc to check random access */
2733   if (!GST_BASE_SRC_IS_STARTED (src)) {
2734     GST_LOG_OBJECT (src, &quot;doing start/stop to check get_range support&quot;);
2735     if (G_LIKELY (gst_base_src_start (src))) {
2736       if (gst_base_src_start_wait (src) != GST_FLOW_OK)
2737         goto start_failed;
2738       gst_base_src_stop (src);
2739     }
2740   }
2741 
2742   return src-&gt;random_access;
2743 
2744   /* ERRORS */
2745 start_failed:
2746   {
2747     GST_DEBUG_OBJECT (src, &quot;failed to start&quot;);
2748     return FALSE;
2749   }
2750 }
2751 
2752 /* Called with STREAM_LOCK */
2753 static void
2754 gst_base_src_loop (GstPad * pad)
2755 {
2756   GstBaseSrc *src;
2757   GstBuffer *buf = NULL;
2758   GstFlowReturn ret;
2759   gint64 position;
2760   gboolean eos;
2761   guint blocksize;
2762   GList *pending_events = NULL, *tmp;
2763 
2764   eos = FALSE;
2765 
2766   src = GST_BASE_SRC (GST_OBJECT_PARENT (pad));
2767 
2768   /* Just leave immediately if we&#39;re flushing */
2769   GST_LIVE_LOCK (src);
2770   if (G_UNLIKELY (src-&gt;priv-&gt;flushing || GST_PAD_IS_FLUSHING (pad)))
2771     goto flushing;
2772   GST_LIVE_UNLOCK (src);
2773 
2774   /* Just return if EOS is pushed again, as the app might be unaware that an
2775    * EOS have been sent already */
2776   if (GST_PAD_IS_EOS (pad)) {
2777     GST_DEBUG_OBJECT (src, &quot;Pad is marked as EOS, pause the task&quot;);
2778     gst_pad_pause_task (pad);
2779     goto done;
2780   }
2781 
2782   gst_base_src_send_stream_start (src);
2783 
2784   /* The stream-start event could&#39;ve caused something to flush us */
2785   GST_LIVE_LOCK (src);
2786   if (G_UNLIKELY (src-&gt;priv-&gt;flushing || GST_PAD_IS_FLUSHING (pad)))
2787     goto flushing;
2788   GST_LIVE_UNLOCK (src);
2789 
2790   /* check if we need to renegotiate */
2791   if (gst_pad_check_reconfigure (pad)) {
2792     if (!gst_base_src_negotiate (src)) {
2793       gst_pad_mark_reconfigure (pad);
2794       if (GST_PAD_IS_FLUSHING (pad)) {
2795         GST_LIVE_LOCK (src);
2796         goto flushing;
2797       } else {
2798         goto negotiate_failed;
2799       }
2800     }
2801   }
2802 
2803   GST_LIVE_LOCK (src);
2804 
2805   if (G_UNLIKELY (src-&gt;priv-&gt;flushing || GST_PAD_IS_FLUSHING (pad)))
2806     goto flushing;
2807 
2808   blocksize = src-&gt;blocksize;
2809 
2810   /* if we operate in bytes, we can calculate an offset */
2811   if (src-&gt;segment.format == GST_FORMAT_BYTES) {
2812     position = src-&gt;segment.position;
2813     /* for negative rates, start with subtracting the blocksize */
2814     if (src-&gt;segment.rate &lt; 0.0) {
2815       /* we cannot go below segment.start */
2816       if (position &gt; src-&gt;segment.start + blocksize)
2817         position -= blocksize;
2818       else {
2819         /* last block, remainder up to segment.start */
2820         blocksize = position - src-&gt;segment.start;
2821         position = src-&gt;segment.start;
2822       }
2823     }
2824   } else
2825     position = -1;
2826 
2827   GST_LOG_OBJECT (src, &quot;next_ts %&quot; GST_TIME_FORMAT &quot; size %u&quot;,
2828       GST_TIME_ARGS (position), blocksize);
2829 
2830   /* clean up just in case we got interrupted or so last time round */
2831   if (src-&gt;priv-&gt;pending_bufferlist != NULL) {
2832     gst_buffer_list_unref (src-&gt;priv-&gt;pending_bufferlist);
2833     src-&gt;priv-&gt;pending_bufferlist = NULL;
2834   }
2835 
2836   ret = gst_base_src_get_range (src, position, blocksize, &amp;buf);
2837   if (G_UNLIKELY (ret != GST_FLOW_OK)) {
2838     GST_INFO_OBJECT (src, &quot;pausing after gst_base_src_get_range() = %s&quot;,
2839         gst_flow_get_name (ret));
2840     GST_LIVE_UNLOCK (src);
2841     goto pause;
2842   }
2843 
2844   /* Note: at this point buf might be a single buf returned which we own or
2845    * the first buf of a pending buffer list submitted via submit_buffer_list(),
2846    * in which case the buffer is owned by the pending buffer list and not us. */
2847   g_assert (buf != NULL);
2848 
2849   /* push events to close/start our segment before we push the buffer. */
2850   if (G_UNLIKELY (src-&gt;priv-&gt;segment_pending)) {
2851     GstEvent *seg_event = gst_event_new_segment (&amp;src-&gt;segment);
2852 
2853     gst_event_set_seqnum (seg_event, src-&gt;priv-&gt;segment_seqnum);
2854     src-&gt;priv-&gt;segment_seqnum = gst_util_seqnum_next ();
2855     gst_pad_push_event (pad, seg_event);
2856     src-&gt;priv-&gt;segment_pending = FALSE;
2857   }
2858 
2859   if (g_atomic_int_get (&amp;src-&gt;priv-&gt;have_events)) {
2860     GST_OBJECT_LOCK (src);
2861     /* take the events */
2862     pending_events = src-&gt;priv-&gt;pending_events;
2863     src-&gt;priv-&gt;pending_events = NULL;
2864     g_atomic_int_set (&amp;src-&gt;priv-&gt;have_events, FALSE);
2865     GST_OBJECT_UNLOCK (src);
2866   }
2867 
2868   /* Push out pending events if any */
2869   if (G_UNLIKELY (pending_events != NULL)) {
2870     for (tmp = pending_events; tmp; tmp = g_list_next (tmp)) {
2871       GstEvent *ev = (GstEvent *) tmp-&gt;data;
2872       gst_pad_push_event (pad, ev);
2873     }
2874     g_list_free (pending_events);
2875   }
2876 
2877   /* figure out the new position */
2878   switch (src-&gt;segment.format) {
2879     case GST_FORMAT_BYTES:
2880     {
2881       guint bufsize = gst_buffer_get_size (buf);
2882 
2883       /* we subtracted above for negative rates */
2884       if (src-&gt;segment.rate &gt;= 0.0)
2885         position += bufsize;
2886       break;
2887     }
2888     case GST_FORMAT_TIME:
2889     {
2890       GstClockTime start, duration;
2891 
2892       start = GST_BUFFER_TIMESTAMP (buf);
2893       duration = GST_BUFFER_DURATION (buf);
2894 
2895       if (GST_CLOCK_TIME_IS_VALID (start))
2896         position = start;
2897       else
2898         position = src-&gt;segment.position;
2899 
2900       if (GST_CLOCK_TIME_IS_VALID (duration)) {
2901         if (src-&gt;segment.rate &gt;= 0.0)
2902           position += duration;
2903         else if (position &gt; duration)
2904           position -= duration;
2905         else
2906           position = 0;
2907       }
2908       break;
2909     }
2910     case GST_FORMAT_DEFAULT:
2911       if (src-&gt;segment.rate &gt;= 0.0)
2912         position = GST_BUFFER_OFFSET_END (buf);
2913       else
2914         position = GST_BUFFER_OFFSET (buf);
2915       break;
2916     default:
2917       position = -1;
2918       break;
2919   }
2920   if (position != -1) {
2921     if (src-&gt;segment.rate &gt;= 0.0) {
2922       /* positive rate, check if we reached the stop */
2923       if (src-&gt;segment.stop != -1) {
2924         if (position &gt;= src-&gt;segment.stop) {
<a name="10" id="anc10"></a><span class="line-modified">2925           eos = TRUE;</span>

2926           position = src-&gt;segment.stop;
2927         }
2928       }
2929     } else {
2930       /* negative rate, check if we reached the start. start is always set to
2931        * something different from -1 */
2932       if (position &lt;= src-&gt;segment.start) {
<a name="11" id="anc11"></a><span class="line-modified">2933         eos = TRUE;</span>

2934         position = src-&gt;segment.start;
2935       }
2936       /* when going reverse, all buffers are DISCONT */
2937       src-&gt;priv-&gt;discont = TRUE;
2938     }
2939     GST_OBJECT_LOCK (src);
2940     src-&gt;segment.position = position;
2941     GST_OBJECT_UNLOCK (src);
2942   }
2943 
2944   if (G_UNLIKELY (src-&gt;priv-&gt;discont)) {
2945     GST_INFO_OBJECT (src, &quot;marking pending DISCONT&quot;);
2946     buf = gst_buffer_make_writable (buf);
2947     GST_BUFFER_FLAG_SET (buf, GST_BUFFER_FLAG_DISCONT);
2948     src-&gt;priv-&gt;discont = FALSE;
2949   }
2950   GST_LIVE_UNLOCK (src);
2951 
2952   /* push buffer or buffer list */
2953   if (src-&gt;priv-&gt;pending_bufferlist != NULL) {
2954     ret = gst_pad_push_list (pad, src-&gt;priv-&gt;pending_bufferlist);
2955     src-&gt;priv-&gt;pending_bufferlist = NULL;
2956   } else {
2957     ret = gst_pad_push (pad, buf);
2958   }
2959 
2960   if (G_UNLIKELY (ret != GST_FLOW_OK)) {
2961     if (ret == GST_FLOW_NOT_NEGOTIATED) {
2962       goto not_negotiated;
2963     }
2964     GST_INFO_OBJECT (src, &quot;pausing after gst_pad_push() = %s&quot;,
2965         gst_flow_get_name (ret));
2966     goto pause;
2967   }
2968 
2969   /* Segment pending means that a new segment was configured
2970    * during this loop run */
2971   if (G_UNLIKELY (eos &amp;&amp; !src-&gt;priv-&gt;segment_pending)) {
2972     GST_INFO_OBJECT (src, &quot;pausing after end of segment&quot;);
2973     ret = GST_FLOW_EOS;
2974     goto pause;
2975   }
2976 
2977 done:
2978   return;
2979 
2980   /* special cases */
2981 not_negotiated:
2982   {
2983     if (gst_pad_needs_reconfigure (pad)) {
2984       GST_DEBUG_OBJECT (src, &quot;Retrying to renegotiate&quot;);
2985       return;
2986     }
2987     /* fallthrough when push returns NOT_NEGOTIATED and we don&#39;t have
2988      * a pending negotiation request on our srcpad */
2989   }
2990 negotiate_failed:
2991   {
2992     GST_DEBUG_OBJECT (src, &quot;Not negotiated&quot;);
2993     ret = GST_FLOW_NOT_NEGOTIATED;
2994     goto pause;
2995   }
2996 flushing:
2997   {
2998     GST_DEBUG_OBJECT (src, &quot;we are flushing&quot;);
2999     GST_LIVE_UNLOCK (src);
3000     ret = GST_FLOW_FLUSHING;
3001     goto pause;
3002   }
3003 pause:
3004   {
3005     const gchar *reason = gst_flow_get_name (ret);
3006     GstEvent *event;
3007 
3008     GST_DEBUG_OBJECT (src, &quot;pausing task, reason %s&quot;, reason);
3009     src-&gt;running = FALSE;
3010     gst_pad_pause_task (pad);
3011     if (ret == GST_FLOW_EOS) {
3012       gboolean flag_segment;
3013       GstFormat format;
3014       gint64 position;
3015 
3016       flag_segment = (src-&gt;segment.flags &amp; GST_SEGMENT_FLAG_SEGMENT) != 0;
3017       format = src-&gt;segment.format;
3018       position = src-&gt;segment.position;
3019 
3020       /* perform EOS logic */
3021       if (src-&gt;priv-&gt;forced_eos) {
3022         g_assert (g_atomic_int_get (&amp;src-&gt;priv-&gt;has_pending_eos));
3023         GST_OBJECT_LOCK (src);
3024         event = src-&gt;priv-&gt;pending_eos;
3025         src-&gt;priv-&gt;pending_eos = NULL;
3026         GST_OBJECT_UNLOCK (src);
3027 
3028       } else if (flag_segment) {
3029         GstMessage *message;
3030 
3031         message = gst_message_new_segment_done (GST_OBJECT_CAST (src),
3032             format, position);
3033         gst_message_set_seqnum (message, src-&gt;priv-&gt;seqnum);
3034         gst_element_post_message (GST_ELEMENT_CAST (src), message);
3035         event = gst_event_new_segment_done (format, position);
3036         gst_event_set_seqnum (event, src-&gt;priv-&gt;seqnum);
3037 
3038       } else {
3039         event = gst_event_new_eos ();
3040         gst_event_set_seqnum (event, src-&gt;priv-&gt;seqnum);
3041       }
3042 
3043       gst_pad_push_event (pad, event);
3044       src-&gt;priv-&gt;forced_eos = FALSE;
3045 
3046     } else if (ret == GST_FLOW_NOT_LINKED || ret &lt;= GST_FLOW_EOS) {
3047       event = gst_event_new_eos ();
3048       gst_event_set_seqnum (event, src-&gt;priv-&gt;seqnum);
3049       /* for fatal errors we post an error message, post the error
3050        * first so the app knows about the error first.
3051        * Also don&#39;t do this for FLUSHING because it happens
3052        * due to flushing and posting an error message because of
3053        * that is the wrong thing to do, e.g. when we&#39;re doing
3054        * a flushing seek. */
3055       GST_ELEMENT_FLOW_ERROR (src, ret);
3056       gst_pad_push_event (pad, event);
3057     }
3058     goto done;
3059   }
3060 }
3061 
3062 static gboolean
3063 gst_base_src_set_allocation (GstBaseSrc * basesrc, GstBufferPool * pool,
3064     GstAllocator * allocator, GstAllocationParams * params)
3065 {
3066   GstAllocator *oldalloc;
3067   GstBufferPool *oldpool;
3068   GstBaseSrcPrivate *priv = basesrc-&gt;priv;
3069 
3070   if (pool) {
3071     GST_DEBUG_OBJECT (basesrc, &quot;activate pool&quot;);
3072     if (!gst_buffer_pool_set_active (pool, TRUE))
3073       goto activate_failed;
3074   }
3075 
3076   GST_OBJECT_LOCK (basesrc);
3077   oldpool = priv-&gt;pool;
3078   priv-&gt;pool = pool;
3079 
3080   oldalloc = priv-&gt;allocator;
3081   priv-&gt;allocator = allocator;
3082 
3083   if (priv-&gt;pool)
3084     gst_object_ref (priv-&gt;pool);
3085   if (priv-&gt;allocator)
3086     gst_object_ref (priv-&gt;allocator);
3087 
3088   if (params)
3089     priv-&gt;params = *params;
3090   else
3091     gst_allocation_params_init (&amp;priv-&gt;params);
3092   GST_OBJECT_UNLOCK (basesrc);
3093 
3094   if (oldpool) {
3095     /* only deactivate if the pool is not the one we&#39;re using */
3096     if (oldpool != pool) {
3097       GST_DEBUG_OBJECT (basesrc, &quot;deactivate old pool&quot;);
3098       gst_buffer_pool_set_active (oldpool, FALSE);
3099     }
3100     gst_object_unref (oldpool);
3101   }
3102   if (oldalloc) {
3103     gst_object_unref (oldalloc);
3104   }
3105   return TRUE;
3106 
3107   /* ERRORS */
3108 activate_failed:
3109   {
3110     GST_ERROR_OBJECT (basesrc, &quot;failed to activate bufferpool.&quot;);
3111     return FALSE;
3112   }
3113 }
3114 
3115 static void
3116 gst_base_src_set_pool_flushing (GstBaseSrc * basesrc, gboolean flushing)
3117 {
3118   GstBaseSrcPrivate *priv = basesrc-&gt;priv;
3119   GstBufferPool *pool;
3120 
3121   GST_OBJECT_LOCK (basesrc);
3122   if ((pool = priv-&gt;pool))
3123     pool = gst_object_ref (pool);
3124   GST_OBJECT_UNLOCK (basesrc);
3125 
3126   if (pool) {
3127     gst_buffer_pool_set_flushing (pool, flushing);
3128     gst_object_unref (pool);
3129   }
3130 }
3131 
3132 
3133 static gboolean
3134 gst_base_src_decide_allocation_default (GstBaseSrc * basesrc, GstQuery * query)
3135 {
3136   GstCaps *outcaps;
3137   GstBufferPool *pool;
3138   guint size, min, max;
3139   GstAllocator *allocator;
3140   GstAllocationParams params;
3141   GstStructure *config;
3142   gboolean update_allocator;
3143 
3144   gst_query_parse_allocation (query, &amp;outcaps, NULL);
3145 
3146   /* we got configuration from our peer or the decide_allocation method,
3147    * parse them */
3148   if (gst_query_get_n_allocation_params (query) &gt; 0) {
3149     /* try the allocator */
3150     gst_query_parse_nth_allocation_param (query, 0, &amp;allocator, &amp;params);
3151     update_allocator = TRUE;
3152   } else {
3153     allocator = NULL;
3154     gst_allocation_params_init (&amp;params);
3155     update_allocator = FALSE;
3156   }
3157 
3158   if (gst_query_get_n_allocation_pools (query) &gt; 0) {
3159     gst_query_parse_nth_allocation_pool (query, 0, &amp;pool, &amp;size, &amp;min, &amp;max);
3160 
3161     if (pool == NULL) {
3162       /* no pool, we can make our own */
3163       GST_DEBUG_OBJECT (basesrc, &quot;no pool, making new pool&quot;);
3164       pool = gst_buffer_pool_new ();
3165     }
3166   } else {
3167     pool = NULL;
3168     size = min = max = 0;
3169   }
3170 
3171   /* now configure */
3172   if (pool) {
3173     config = gst_buffer_pool_get_config (pool);
3174     gst_buffer_pool_config_set_params (config, outcaps, size, min, max);
3175     gst_buffer_pool_config_set_allocator (config, allocator, &amp;params);
3176 
3177     /* buffer pool may have to do some changes */
3178     if (!gst_buffer_pool_set_config (pool, config)) {
3179       config = gst_buffer_pool_get_config (pool);
3180 
3181       /* If change are not acceptable, fallback to generic pool */
3182       if (!gst_buffer_pool_config_validate_params (config, outcaps, size, min,
3183               max)) {
3184         GST_DEBUG_OBJECT (basesrc, &quot;unsupported pool, making new pool&quot;);
3185 
3186         gst_object_unref (pool);
3187         pool = gst_buffer_pool_new ();
3188         gst_buffer_pool_config_set_params (config, outcaps, size, min, max);
3189         gst_buffer_pool_config_set_allocator (config, allocator, &amp;params);
3190       }
3191 
3192       if (!gst_buffer_pool_set_config (pool, config))
3193         goto config_failed;
3194     }
3195   }
3196 
3197   if (update_allocator)
3198     gst_query_set_nth_allocation_param (query, 0, allocator, &amp;params);
3199   else
3200     gst_query_add_allocation_param (query, allocator, &amp;params);
3201   if (allocator)
3202     gst_object_unref (allocator);
3203 
3204   if (pool) {
3205     gst_query_set_nth_allocation_pool (query, 0, pool, size, min, max);
3206     gst_object_unref (pool);
3207   }
3208 
3209   return TRUE;
3210 
3211 config_failed:
3212   GST_ELEMENT_ERROR (basesrc, RESOURCE, SETTINGS,
3213       (&quot;Failed to configure the buffer pool&quot;),
3214       (&quot;Configuration is most likely invalid, please report this issue.&quot;));
3215   gst_object_unref (pool);
3216   return FALSE;
3217 }
3218 
3219 static gboolean
3220 gst_base_src_prepare_allocation (GstBaseSrc * basesrc, GstCaps * caps)
3221 {
3222   GstBaseSrcClass *bclass;
3223   gboolean result = TRUE;
3224   GstQuery *query;
3225   GstBufferPool *pool = NULL;
3226   GstAllocator *allocator = NULL;
3227   GstAllocationParams params;
3228 
3229   bclass = GST_BASE_SRC_GET_CLASS (basesrc);
3230 
3231   /* make query and let peer pad answer, we don&#39;t really care if it worked or
3232    * not, if it failed, the allocation query would contain defaults and the
3233    * subclass would then set better values if needed */
3234   query = gst_query_new_allocation (caps, TRUE);
3235   if (!gst_pad_peer_query (basesrc-&gt;srcpad, query)) {
3236     /* not a problem, just debug a little */
3237     GST_DEBUG_OBJECT (basesrc, &quot;peer ALLOCATION query failed&quot;);
3238   }
3239 
3240   g_assert (bclass-&gt;decide_allocation != NULL);
3241   result = bclass-&gt;decide_allocation (basesrc, query);
3242 
3243   GST_DEBUG_OBJECT (basesrc, &quot;ALLOCATION (%d) params: %&quot; GST_PTR_FORMAT, result,
3244       query);
3245 
3246   if (!result)
3247     goto no_decide_allocation;
3248 
3249   /* we got configuration from our peer or the decide_allocation method,
3250    * parse them */
3251   if (gst_query_get_n_allocation_params (query) &gt; 0) {
3252     gst_query_parse_nth_allocation_param (query, 0, &amp;allocator, &amp;params);
3253   } else {
3254     allocator = NULL;
3255     gst_allocation_params_init (&amp;params);
3256   }
3257 
3258   if (gst_query_get_n_allocation_pools (query) &gt; 0)
3259     gst_query_parse_nth_allocation_pool (query, 0, &amp;pool, NULL, NULL, NULL);
3260 
3261   result = gst_base_src_set_allocation (basesrc, pool, allocator, &amp;params);
3262 
3263   if (allocator)
3264     gst_object_unref (allocator);
3265   if (pool)
3266     gst_object_unref (pool);
3267 
3268   gst_query_unref (query);
3269 
3270   return result;
3271 
3272   /* Errors */
3273 no_decide_allocation:
3274   {
3275     GST_WARNING_OBJECT (basesrc, &quot;Subclass failed to decide allocation&quot;);
3276     gst_query_unref (query);
3277 
3278     return result;
3279   }
3280 }
3281 
3282 /* default negotiation code.
3283  *
3284  * Take intersection between src and sink pads, take first
3285  * caps and fixate.
3286  */
3287 static gboolean
3288 gst_base_src_default_negotiate (GstBaseSrc * basesrc)
3289 {
3290   GstCaps *thiscaps;
3291   GstCaps *caps = NULL;
3292   GstCaps *peercaps = NULL;
3293   gboolean result = FALSE;
3294 
3295   /* first see what is possible on our source pad */
3296   thiscaps = gst_pad_query_caps (GST_BASE_SRC_PAD (basesrc), NULL);
3297   GST_DEBUG_OBJECT (basesrc, &quot;caps of src: %&quot; GST_PTR_FORMAT, thiscaps);
3298   /* nothing or anything is allowed, we&#39;re done */
3299   if (thiscaps == NULL || gst_caps_is_any (thiscaps))
3300     goto no_nego_needed;
3301 
3302   if (G_UNLIKELY (gst_caps_is_empty (thiscaps)))
3303     goto no_caps;
3304 
3305   /* get the peer caps */
3306   peercaps = gst_pad_peer_query_caps (GST_BASE_SRC_PAD (basesrc), thiscaps);
3307   GST_DEBUG_OBJECT (basesrc, &quot;caps of peer: %&quot; GST_PTR_FORMAT, peercaps);
3308   if (peercaps) {
3309     /* The result is already a subset of our caps */
3310     caps = peercaps;
3311     gst_caps_unref (thiscaps);
3312   } else {
3313     /* no peer, work with our own caps then */
3314     caps = thiscaps;
3315   }
3316   if (caps &amp;&amp; !gst_caps_is_empty (caps)) {
3317     /* now fixate */
3318     GST_DEBUG_OBJECT (basesrc, &quot;have caps: %&quot; GST_PTR_FORMAT, caps);
3319     if (gst_caps_is_any (caps)) {
3320       GST_DEBUG_OBJECT (basesrc, &quot;any caps, we stop&quot;);
3321       /* hmm, still anything, so element can do anything and
3322        * nego is not needed */
3323       result = TRUE;
3324     } else {
3325       caps = gst_base_src_fixate (basesrc, caps);
3326       GST_DEBUG_OBJECT (basesrc, &quot;fixated to: %&quot; GST_PTR_FORMAT, caps);
3327       if (gst_caps_is_fixed (caps)) {
3328         /* yay, fixed caps, use those then, it&#39;s possible that the subclass does
3329          * not accept this caps after all and we have to fail. */
3330         result = gst_base_src_set_caps (basesrc, caps);
3331       }
3332     }
3333     gst_caps_unref (caps);
3334   } else {
3335     if (caps)
3336       gst_caps_unref (caps);
3337     GST_DEBUG_OBJECT (basesrc, &quot;no common caps&quot;);
3338   }
3339   return result;
3340 
3341 no_nego_needed:
3342   {
3343     GST_DEBUG_OBJECT (basesrc, &quot;no negotiation needed&quot;);
3344     if (thiscaps)
3345       gst_caps_unref (thiscaps);
3346     return TRUE;
3347   }
3348 no_caps:
3349   {
3350     GST_ELEMENT_ERROR (basesrc, STREAM, FORMAT,
3351         (&quot;No supported formats found&quot;),
3352         (&quot;This element did not produce valid caps&quot;));
3353     if (thiscaps)
3354       gst_caps_unref (thiscaps);
3355     return TRUE;
3356   }
3357 }
3358 
3359 static gboolean
3360 gst_base_src_negotiate (GstBaseSrc * basesrc)
3361 {
3362   GstBaseSrcClass *bclass;
3363   gboolean result;
3364 
3365   bclass = GST_BASE_SRC_GET_CLASS (basesrc);
3366 
3367   GST_DEBUG_OBJECT (basesrc, &quot;starting negotiation&quot;);
3368 
3369   if (G_LIKELY (bclass-&gt;negotiate))
3370     result = bclass-&gt;negotiate (basesrc);
3371   else
3372     result = TRUE;
3373 
3374   if (G_LIKELY (result)) {
3375     GstCaps *caps;
3376 
3377     caps = gst_pad_get_current_caps (basesrc-&gt;srcpad);
3378 
3379     result = gst_base_src_prepare_allocation (basesrc, caps);
3380 
3381     if (caps)
3382       gst_caps_unref (caps);
3383   }
3384   return result;
3385 }
3386 
3387 static gboolean
3388 gst_base_src_start (GstBaseSrc * basesrc)
3389 {
3390   GstBaseSrcClass *bclass;
3391   gboolean result;
3392 
3393   GST_LIVE_LOCK (basesrc);
3394 
3395   GST_OBJECT_LOCK (basesrc);
3396   if (GST_BASE_SRC_IS_STARTING (basesrc))
3397     goto was_starting;
3398   if (GST_BASE_SRC_IS_STARTED (basesrc))
3399     goto was_started;
3400 
3401   basesrc-&gt;priv-&gt;start_result = GST_FLOW_FLUSHING;
3402   GST_OBJECT_FLAG_SET (basesrc, GST_BASE_SRC_FLAG_STARTING);
3403   gst_segment_init (&amp;basesrc-&gt;segment, basesrc-&gt;segment.format);
3404   GST_OBJECT_UNLOCK (basesrc);
3405 
3406   basesrc-&gt;num_buffers_left = basesrc-&gt;num_buffers;
3407   basesrc-&gt;running = FALSE;
3408   basesrc-&gt;priv-&gt;segment_pending = FALSE;
3409   basesrc-&gt;priv-&gt;segment_seqnum = gst_util_seqnum_next ();
3410   basesrc-&gt;priv-&gt;forced_eos = FALSE;
3411   GST_LIVE_UNLOCK (basesrc);
3412 
3413   bclass = GST_BASE_SRC_GET_CLASS (basesrc);
3414   if (bclass-&gt;start)
3415     result = bclass-&gt;start (basesrc);
3416   else
3417     result = TRUE;
3418 
3419   if (!result)
3420     goto could_not_start;
3421 
3422   if (!gst_base_src_is_async (basesrc)) {
3423     gst_base_src_start_complete (basesrc, GST_FLOW_OK);
3424     /* not really waiting here, we call this to get the result
3425      * from the start_complete call */
3426     result = gst_base_src_start_wait (basesrc) == GST_FLOW_OK;
3427   }
3428 
3429   return result;
3430 
3431   /* ERROR */
3432 was_starting:
3433   {
3434     GST_DEBUG_OBJECT (basesrc, &quot;was starting&quot;);
3435     GST_OBJECT_UNLOCK (basesrc);
3436     GST_LIVE_UNLOCK (basesrc);
3437     return TRUE;
3438   }
3439 was_started:
3440   {
3441     GST_DEBUG_OBJECT (basesrc, &quot;was started&quot;);
3442     GST_OBJECT_UNLOCK (basesrc);
3443     GST_LIVE_UNLOCK (basesrc);
3444     return TRUE;
3445   }
3446 could_not_start:
3447   {
3448     GST_DEBUG_OBJECT (basesrc, &quot;could not start&quot;);
3449     /* subclass is supposed to post a message but we post one as a fallback
3450      * just in case. We don&#39;t have to call _stop. */
3451     GST_ELEMENT_ERROR (basesrc, CORE, STATE_CHANGE, (NULL),
3452         (&quot;Failed to start&quot;));
3453     gst_base_src_start_complete (basesrc, GST_FLOW_ERROR);
3454     return FALSE;
3455   }
3456 }
3457 
3458 /**
3459  * gst_base_src_start_complete:
3460  * @basesrc: base source instance
3461  * @ret: a #GstFlowReturn
3462  *
3463  * Complete an asynchronous start operation. When the subclass overrides the
3464  * start method, it should call gst_base_src_start_complete() when the start
3465  * operation completes either from the same thread or from an asynchronous
3466  * helper thread.
3467  */
3468 void
3469 gst_base_src_start_complete (GstBaseSrc * basesrc, GstFlowReturn ret)
3470 {
3471   gboolean have_size;
3472   guint64 size;
3473   gboolean seekable;
3474   GstFormat format;
3475   GstPadMode mode;
3476   GstEvent *event;
3477 
3478   if (ret != GST_FLOW_OK)
3479     goto error;
3480 
3481   GST_DEBUG_OBJECT (basesrc, &quot;starting source&quot;);
3482   format = basesrc-&gt;segment.format;
3483 
3484   /* figure out the size */
3485   have_size = FALSE;
3486   size = -1;
3487   if (format == GST_FORMAT_BYTES) {
3488     GstBaseSrcClass *bclass = GST_BASE_SRC_GET_CLASS (basesrc);
3489 
3490     if (bclass-&gt;get_size) {
3491       if (!(have_size = bclass-&gt;get_size (basesrc, &amp;size)))
3492         size = -1;
3493     }
3494     GST_DEBUG_OBJECT (basesrc, &quot;setting size %&quot; G_GUINT64_FORMAT, size);
3495     /* only update the size when operating in bytes, subclass is supposed
3496      * to set duration in the start method for other formats */
3497     GST_OBJECT_LOCK (basesrc);
3498     basesrc-&gt;segment.duration = size;
3499     GST_OBJECT_UNLOCK (basesrc);
3500   }
3501 
3502   GST_DEBUG_OBJECT (basesrc,
3503       &quot;format: %s, have size: %d, size: %&quot; G_GUINT64_FORMAT &quot;, duration: %&quot;
3504       G_GINT64_FORMAT, gst_format_get_name (format), have_size, size,
3505       basesrc-&gt;segment.duration);
3506 
3507   seekable = gst_base_src_seekable (basesrc);
3508   GST_DEBUG_OBJECT (basesrc, &quot;is seekable: %d&quot;, seekable);
3509 
3510   /* update for random access flag */
3511   basesrc-&gt;random_access = seekable &amp;&amp; format == GST_FORMAT_BYTES;
3512 
3513   GST_DEBUG_OBJECT (basesrc, &quot;is random_access: %d&quot;, basesrc-&gt;random_access);
3514 
3515   gst_pad_mark_reconfigure (GST_BASE_SRC_PAD (basesrc));
3516 
3517   GST_OBJECT_LOCK (basesrc-&gt;srcpad);
3518   mode = GST_PAD_MODE (basesrc-&gt;srcpad);
3519   GST_OBJECT_UNLOCK (basesrc-&gt;srcpad);
3520 
3521   /* take the stream lock here, we only want to let the task run when we have
3522    * set the STARTED flag */
3523   GST_PAD_STREAM_LOCK (basesrc-&gt;srcpad);
3524   switch (mode) {
3525     case GST_PAD_MODE_PUSH:
3526       /* do initial seek, which will start the task */
3527       GST_OBJECT_LOCK (basesrc);
3528       event = basesrc-&gt;pending_seek;
3529       basesrc-&gt;pending_seek = NULL;
3530       GST_OBJECT_UNLOCK (basesrc);
3531 
3532       /* The perform seek code will start the task when finished. We don&#39;t have to
3533        * unlock the streaming thread because it is not running yet */
3534       if (G_UNLIKELY (!gst_base_src_perform_seek (basesrc, event, FALSE)))
3535         goto seek_failed;
3536 
3537       if (event)
3538         gst_event_unref (event);
3539       break;
3540     case GST_PAD_MODE_PULL:
3541       /* if not random_access, we cannot operate in pull mode for now */
3542       if (G_UNLIKELY (!basesrc-&gt;random_access))
3543         goto no_get_range;
3544       break;
3545     default:
3546       goto not_activated_yet;
3547       break;
3548   }
3549 
3550   GST_OBJECT_LOCK (basesrc);
3551   GST_OBJECT_FLAG_SET (basesrc, GST_BASE_SRC_FLAG_STARTED);
3552   GST_OBJECT_FLAG_UNSET (basesrc, GST_BASE_SRC_FLAG_STARTING);
3553   basesrc-&gt;priv-&gt;start_result = ret;
3554   GST_ASYNC_SIGNAL (basesrc);
3555   GST_OBJECT_UNLOCK (basesrc);
3556 
3557   GST_PAD_STREAM_UNLOCK (basesrc-&gt;srcpad);
3558 
3559   return;
3560 
3561 seek_failed:
3562   {
3563     GST_PAD_STREAM_UNLOCK (basesrc-&gt;srcpad);
3564     GST_ERROR_OBJECT (basesrc, &quot;Failed to perform initial seek&quot;);
3565     gst_base_src_stop (basesrc);
3566     if (event)
3567       gst_event_unref (event);
3568     ret = GST_FLOW_ERROR;
3569     goto error;
3570   }
3571 no_get_range:
3572   {
3573     GST_PAD_STREAM_UNLOCK (basesrc-&gt;srcpad);
3574     gst_base_src_stop (basesrc);
3575     GST_ERROR_OBJECT (basesrc, &quot;Cannot operate in pull mode, stopping&quot;);
3576     ret = GST_FLOW_ERROR;
3577     goto error;
3578   }
3579 not_activated_yet:
3580   {
3581     GST_PAD_STREAM_UNLOCK (basesrc-&gt;srcpad);
3582     gst_base_src_stop (basesrc);
3583     GST_WARNING_OBJECT (basesrc, &quot;pad not activated yet&quot;);
3584     ret = GST_FLOW_ERROR;
3585     goto error;
3586   }
3587 error:
3588   {
3589     GST_OBJECT_LOCK (basesrc);
3590     basesrc-&gt;priv-&gt;start_result = ret;
3591     GST_OBJECT_FLAG_UNSET (basesrc, GST_BASE_SRC_FLAG_STARTING);
3592     GST_ASYNC_SIGNAL (basesrc);
3593     GST_OBJECT_UNLOCK (basesrc);
3594     return;
3595   }
3596 }
3597 
3598 /**
3599  * gst_base_src_start_wait:
3600  * @basesrc: base source instance
3601  *
3602  * Wait until the start operation completes.
3603  *
3604  * Returns: a #GstFlowReturn.
3605  */
3606 GstFlowReturn
3607 gst_base_src_start_wait (GstBaseSrc * basesrc)
3608 {
3609   GstFlowReturn result;
3610 
3611   GST_OBJECT_LOCK (basesrc);
3612   while (GST_BASE_SRC_IS_STARTING (basesrc)) {
3613     GST_ASYNC_WAIT (basesrc);
3614   }
3615   result = basesrc-&gt;priv-&gt;start_result;
3616   GST_OBJECT_UNLOCK (basesrc);
3617 
3618   GST_DEBUG_OBJECT (basesrc, &quot;got %s&quot;, gst_flow_get_name (result));
3619 
3620   return result;
3621 }
3622 
3623 static gboolean
3624 gst_base_src_stop (GstBaseSrc * basesrc)
3625 {
3626   GstBaseSrcClass *bclass;
3627   gboolean result = TRUE;
3628 
3629   GST_DEBUG_OBJECT (basesrc, &quot;stopping source&quot;);
3630 
3631   /* flush all */
3632   gst_base_src_set_flushing (basesrc, TRUE);
3633 
3634   /* stop the task */
3635   gst_pad_stop_task (basesrc-&gt;srcpad);
3636   /* stop flushing, this will balance unlock/unlock_stop calls */
3637   gst_base_src_set_flushing (basesrc, FALSE);
3638 
3639   GST_OBJECT_LOCK (basesrc);
3640   if (!GST_BASE_SRC_IS_STARTED (basesrc) &amp;&amp; !GST_BASE_SRC_IS_STARTING (basesrc))
3641     goto was_stopped;
3642 
3643   GST_OBJECT_FLAG_UNSET (basesrc, GST_BASE_SRC_FLAG_STARTING);
3644   GST_OBJECT_FLAG_UNSET (basesrc, GST_BASE_SRC_FLAG_STARTED);
3645   basesrc-&gt;priv-&gt;start_result = GST_FLOW_FLUSHING;
3646   GST_ASYNC_SIGNAL (basesrc);
3647   GST_OBJECT_UNLOCK (basesrc);
3648 
3649   bclass = GST_BASE_SRC_GET_CLASS (basesrc);
3650   if (bclass-&gt;stop)
3651     result = bclass-&gt;stop (basesrc);
3652 
3653   if (basesrc-&gt;priv-&gt;pending_bufferlist != NULL) {
3654     gst_buffer_list_unref (basesrc-&gt;priv-&gt;pending_bufferlist);
3655     basesrc-&gt;priv-&gt;pending_bufferlist = NULL;
3656   }
3657 
3658   gst_base_src_set_allocation (basesrc, NULL, NULL, NULL);
3659 
3660   return result;
3661 
3662 was_stopped:
3663   {
3664     GST_DEBUG_OBJECT (basesrc, &quot;was stopped&quot;);
3665     GST_OBJECT_UNLOCK (basesrc);
3666     return TRUE;
3667   }
3668 }
3669 
3670 /* start or stop flushing dataprocessing
3671  */
3672 static gboolean
3673 gst_base_src_set_flushing (GstBaseSrc * basesrc, gboolean flushing)
3674 {
3675   GstBaseSrcClass *bclass;
3676 
3677   bclass = GST_BASE_SRC_GET_CLASS (basesrc);
3678 
3679   GST_DEBUG_OBJECT (basesrc, &quot;flushing %d&quot;, flushing);
3680 
3681   if (flushing) {
3682     gst_base_src_set_pool_flushing (basesrc, TRUE);
3683     /* unlock any subclasses to allow turning off the streaming thread */
3684     if (bclass-&gt;unlock)
3685       bclass-&gt;unlock (basesrc);
3686   }
3687 
3688   /* the live lock is released when we are blocked, waiting for playing,
3689    * when we sync to the clock or creating a buffer */
3690   GST_LIVE_LOCK (basesrc);
3691   basesrc-&gt;priv-&gt;flushing = flushing;
3692   if (flushing) {
3693     /* clear pending EOS if any */
3694     if (g_atomic_int_get (&amp;basesrc-&gt;priv-&gt;has_pending_eos)) {
3695       GST_OBJECT_LOCK (basesrc);
3696       CLEAR_PENDING_EOS (basesrc);
3697       basesrc-&gt;priv-&gt;forced_eos = FALSE;
3698       GST_OBJECT_UNLOCK (basesrc);
3699     }
3700 
3701     /* unblock clock sync (if any) or any other blocking thing */
3702     if (basesrc-&gt;clock_id)
3703       gst_clock_id_unschedule (basesrc-&gt;clock_id);
3704   } else {
3705     gst_base_src_set_pool_flushing (basesrc, FALSE);
3706 
3707     /* Drop all delayed events */
3708     GST_OBJECT_LOCK (basesrc);
3709     if (basesrc-&gt;priv-&gt;pending_events) {
3710       g_list_foreach (basesrc-&gt;priv-&gt;pending_events, (GFunc) gst_event_unref,
3711           NULL);
3712       g_list_free (basesrc-&gt;priv-&gt;pending_events);
3713       basesrc-&gt;priv-&gt;pending_events = NULL;
3714       g_atomic_int_set (&amp;basesrc-&gt;priv-&gt;have_events, FALSE);
3715     }
3716     GST_OBJECT_UNLOCK (basesrc);
3717   }
3718 
3719   GST_LIVE_SIGNAL (basesrc);
3720   GST_LIVE_UNLOCK (basesrc);
3721 
3722   if (!flushing) {
3723     /* Now wait for the stream lock to be released and clear our unlock request */
3724     GST_PAD_STREAM_LOCK (basesrc-&gt;srcpad);
3725     if (bclass-&gt;unlock_stop)
3726       bclass-&gt;unlock_stop (basesrc);
3727     GST_PAD_STREAM_UNLOCK (basesrc-&gt;srcpad);
3728   }
3729 
3730   return TRUE;
3731 }
3732 
3733 /* the purpose of this function is to make sure that a live source blocks in the
3734  * LIVE lock or leaves the LIVE lock and continues playing. */
3735 static gboolean
3736 gst_base_src_set_playing (GstBaseSrc * basesrc, gboolean live_play)
3737 {
3738   /* we are now able to grab the LIVE lock, when we get it, we can be
3739    * waiting for PLAYING while blocked in the LIVE cond or we can be waiting
3740    * for the clock. */
3741   GST_LIVE_LOCK (basesrc);
3742   GST_DEBUG_OBJECT (basesrc, &quot;unschedule clock&quot;);
3743 
3744   /* unblock clock sync (if any) */
3745   if (basesrc-&gt;clock_id)
3746     gst_clock_id_unschedule (basesrc-&gt;clock_id);
3747 
3748   /* configure what to do when we get to the LIVE lock. */
3749   GST_DEBUG_OBJECT (basesrc, &quot;live running %d&quot;, live_play);
3750   basesrc-&gt;live_running = live_play;
3751 
3752   if (live_play) {
3753     gboolean start;
3754 
3755     /* for live sources we restart the timestamp correction */
3756     GST_OBJECT_LOCK (basesrc);
3757     basesrc-&gt;priv-&gt;latency = -1;
3758     GST_OBJECT_UNLOCK (basesrc);
3759     /* have to restart the task in case it stopped because of the unlock when
3760      * we went to PAUSED. Only do this if we operating in push mode. */
3761     GST_OBJECT_LOCK (basesrc-&gt;srcpad);
3762     start = (GST_PAD_MODE (basesrc-&gt;srcpad) == GST_PAD_MODE_PUSH);
3763     GST_OBJECT_UNLOCK (basesrc-&gt;srcpad);
3764     if (start)
3765       gst_pad_start_task (basesrc-&gt;srcpad, (GstTaskFunction) gst_base_src_loop,
3766           basesrc-&gt;srcpad, NULL);
3767     GST_DEBUG_OBJECT (basesrc, &quot;signal&quot;);
3768     GST_LIVE_SIGNAL (basesrc);
3769   }
3770   GST_LIVE_UNLOCK (basesrc);
3771 
3772   return TRUE;
3773 }
3774 
3775 static gboolean
3776 gst_base_src_activate_push (GstPad * pad, GstObject * parent, gboolean active)
3777 {
3778   GstBaseSrc *basesrc;
3779 
3780   basesrc = GST_BASE_SRC (parent);
3781 
3782   /* prepare subclass first */
3783   if (active) {
3784     GST_DEBUG_OBJECT (basesrc, &quot;Activating in push mode&quot;);
3785 
3786     if (G_UNLIKELY (!basesrc-&gt;can_activate_push))
3787       goto no_push_activation;
3788 
3789     if (G_UNLIKELY (!gst_base_src_start (basesrc)))
3790       goto error_start;
3791   } else {
3792     GST_DEBUG_OBJECT (basesrc, &quot;Deactivating in push mode&quot;);
3793     /* now we can stop the source */
3794     if (G_UNLIKELY (!gst_base_src_stop (basesrc)))
3795       goto error_stop;
3796   }
3797   return TRUE;
3798 
3799   /* ERRORS */
3800 no_push_activation:
3801   {
3802     GST_WARNING_OBJECT (basesrc, &quot;Subclass disabled push-mode activation&quot;);
3803     return FALSE;
3804   }
3805 error_start:
3806   {
3807     GST_WARNING_OBJECT (basesrc, &quot;Failed to start in push mode&quot;);
3808     return FALSE;
3809   }
3810 error_stop:
3811   {
3812     GST_DEBUG_OBJECT (basesrc, &quot;Failed to stop in push mode&quot;);
3813     return FALSE;
3814   }
3815 }
3816 
3817 static gboolean
3818 gst_base_src_activate_pull (GstPad * pad, GstObject * parent, gboolean active)
3819 {
3820   GstBaseSrc *basesrc;
3821 
3822   basesrc = GST_BASE_SRC (parent);
3823 
3824   /* prepare subclass first */
3825   if (active) {
3826     GST_DEBUG_OBJECT (basesrc, &quot;Activating in pull mode&quot;);
3827     if (G_UNLIKELY (!gst_base_src_start (basesrc)))
3828       goto error_start;
3829   } else {
3830     GST_DEBUG_OBJECT (basesrc, &quot;Deactivating in pull mode&quot;);
3831     if (G_UNLIKELY (!gst_base_src_stop (basesrc)))
3832       goto error_stop;
3833   }
3834   return TRUE;
3835 
3836   /* ERRORS */
3837 error_start:
3838   {
3839     GST_ERROR_OBJECT (basesrc, &quot;Failed to start in pull mode&quot;);
3840     return FALSE;
3841   }
3842 error_stop:
3843   {
3844     GST_ERROR_OBJECT (basesrc, &quot;Failed to stop in pull mode&quot;);
3845     return FALSE;
3846   }
3847 }
3848 
3849 static gboolean
3850 gst_base_src_activate_mode (GstPad * pad, GstObject * parent,
3851     GstPadMode mode, gboolean active)
3852 {
3853   gboolean res;
3854   GstBaseSrc *src = GST_BASE_SRC (parent);
3855 
3856   src-&gt;priv-&gt;stream_start_pending = FALSE;
3857 
3858   GST_DEBUG_OBJECT (pad, &quot;activating in mode %d&quot;, mode);
3859 
3860   switch (mode) {
3861     case GST_PAD_MODE_PULL:
3862       res = gst_base_src_activate_pull (pad, parent, active);
3863       break;
3864     case GST_PAD_MODE_PUSH:
3865       src-&gt;priv-&gt;stream_start_pending = active;
3866       res = gst_base_src_activate_push (pad, parent, active);
3867       break;
3868     default:
3869       GST_LOG_OBJECT (pad, &quot;unknown activation mode %d&quot;, mode);
3870       res = FALSE;
3871       break;
3872   }
3873   return res;
3874 }
3875 
3876 
3877 static GstStateChangeReturn
3878 gst_base_src_change_state (GstElement * element, GstStateChange transition)
3879 {
3880   GstBaseSrc *basesrc;
3881   GstStateChangeReturn result;
3882   gboolean no_preroll = FALSE;
3883 
3884   basesrc = GST_BASE_SRC (element);
3885 
3886   switch (transition) {
3887     case GST_STATE_CHANGE_NULL_TO_READY:
3888       break;
3889     case GST_STATE_CHANGE_READY_TO_PAUSED:
3890       no_preroll = gst_base_src_is_live (basesrc);
3891       break;
3892     case GST_STATE_CHANGE_PAUSED_TO_PLAYING:
3893       GST_DEBUG_OBJECT (basesrc, &quot;PAUSED-&gt;PLAYING&quot;);
3894       if (gst_base_src_is_live (basesrc)) {
3895         /* now we can start playback */
3896         gst_base_src_set_playing (basesrc, TRUE);
3897       }
3898       break;
3899     default:
3900       break;
3901   }
3902 
3903   if ((result =
3904           GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element,
3905               transition)) == GST_STATE_CHANGE_FAILURE)
3906     goto failure;
3907 
3908   switch (transition) {
3909     case GST_STATE_CHANGE_PLAYING_TO_PAUSED:
3910       GST_DEBUG_OBJECT (basesrc, &quot;PLAYING-&gt;PAUSED&quot;);
3911       if (gst_base_src_is_live (basesrc)) {
3912         /* make sure we block in the live cond in PAUSED */
3913         gst_base_src_set_playing (basesrc, FALSE);
3914         no_preroll = TRUE;
3915       }
3916       break;
3917     case GST_STATE_CHANGE_PAUSED_TO_READY:
3918     {
3919       /* we don&#39;t need to unblock anything here, the pad deactivation code
3920        * already did this */
3921       if (g_atomic_int_get (&amp;basesrc-&gt;priv-&gt;has_pending_eos)) {
3922         GST_OBJECT_LOCK (basesrc);
3923         CLEAR_PENDING_EOS (basesrc);
3924         GST_OBJECT_UNLOCK (basesrc);
3925       }
3926       gst_event_replace (&amp;basesrc-&gt;pending_seek, NULL);
3927       break;
3928     }
3929     case GST_STATE_CHANGE_READY_TO_NULL:
3930       break;
3931     default:
3932       break;
3933   }
3934 
3935   if (no_preroll &amp;&amp; result == GST_STATE_CHANGE_SUCCESS)
3936     result = GST_STATE_CHANGE_NO_PREROLL;
3937 
3938   return result;
3939 
3940   /* ERRORS */
3941 failure:
3942   {
3943     GST_DEBUG_OBJECT (basesrc, &quot;parent failed state change&quot;);
3944     return result;
3945   }
3946 }
3947 
3948 /**
3949  * gst_base_src_get_buffer_pool:
3950  * @src: a #GstBaseSrc
3951  *
3952  * Returns: (transfer full): the instance of the #GstBufferPool used
3953  * by the src; unref it after usage.
3954  */
3955 GstBufferPool *
3956 gst_base_src_get_buffer_pool (GstBaseSrc * src)
3957 {
3958   GstBufferPool *ret = NULL;
3959 
3960   g_return_val_if_fail (GST_IS_BASE_SRC (src), NULL);
3961 
3962   GST_OBJECT_LOCK (src);
3963   if (src-&gt;priv-&gt;pool)
3964     ret = gst_object_ref (src-&gt;priv-&gt;pool);
3965   GST_OBJECT_UNLOCK (src);
3966 
3967   return ret;
3968 }
3969 
3970 /**
3971  * gst_base_src_get_allocator:
3972  * @src: a #GstBaseSrc
3973  * @allocator: (out) (allow-none) (transfer full): the #GstAllocator
3974  * used
3975  * @params: (out) (allow-none) (transfer full): the
3976  * #GstAllocationParams of @allocator
3977  *
3978  * Lets #GstBaseSrc sub-classes to know the memory @allocator
3979  * used by the base class and its @params.
3980  *
3981  * Unref the @allocator after usage.
3982  */
3983 void
3984 gst_base_src_get_allocator (GstBaseSrc * src,
3985     GstAllocator ** allocator, GstAllocationParams * params)
3986 {
3987   g_return_if_fail (GST_IS_BASE_SRC (src));
3988 
3989   GST_OBJECT_LOCK (src);
3990   if (allocator)
3991     *allocator = src-&gt;priv-&gt;allocator ?
3992         gst_object_ref (src-&gt;priv-&gt;allocator) : NULL;
3993 
3994   if (params)
3995     *params = src-&gt;priv-&gt;params;
3996   GST_OBJECT_UNLOCK (src);
3997 }
3998 
3999 /**
4000  * gst_base_src_submit_buffer_list:
4001  * @src: a #GstBaseSrc
4002  * @buffer_list: (transfer full): a #GstBufferList
4003  *
4004  * Subclasses can call this from their create virtual method implementation
4005  * to submit a buffer list to be pushed out later. This is useful in
4006  * cases where the create function wants to produce multiple buffers to be
4007  * pushed out in one go in form of a #GstBufferList, which can reduce overhead
4008  * drastically, especially for packetised inputs (for data streams where
4009  * the packetisation/chunking is not important it is usually more efficient
4010  * to return larger buffers instead).
4011  *
4012  * Subclasses that use this function from their create function must return
4013  * %GST_FLOW_OK and no buffer from their create virtual method implementation.
4014  * If a buffer is returned after a buffer list has also been submitted via this
4015  * function the behaviour is undefined.
4016  *
4017  * Subclasses must only call this function once per create function call and
4018  * subclasses must only call this function when the source operates in push
4019  * mode.
4020  *
4021  * Since: 1.14
4022  */
4023 void
4024 gst_base_src_submit_buffer_list (GstBaseSrc * src, GstBufferList * buffer_list)
4025 {
4026   g_return_if_fail (GST_IS_BASE_SRC (src));
4027   g_return_if_fail (GST_IS_BUFFER_LIST (buffer_list));
4028   g_return_if_fail (BASE_SRC_HAS_PENDING_BUFFER_LIST (src) == FALSE);
4029 
<a name="12" id="anc12"></a><span class="line-modified">4030   src-&gt;priv-&gt;pending_bufferlist = buffer_list;</span>

4031 
4032   GST_LOG_OBJECT (src, &quot;%u buffers submitted in buffer list&quot;,
4033       gst_buffer_list_length (buffer_list));
4034 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>