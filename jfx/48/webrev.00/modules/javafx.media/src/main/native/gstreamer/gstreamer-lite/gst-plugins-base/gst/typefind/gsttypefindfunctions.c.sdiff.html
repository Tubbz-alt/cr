<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst/typefind/gsttypefindfunctions.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../audioconvert/gstaudioconvert.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../volume/gstvolume.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst/typefind/gsttypefindfunctions.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  38 
  39 #include &lt;stdio.h&gt;
  40 #include &lt;string.h&gt;
  41 #include &lt;ctype.h&gt;
  42 
  43 #include &lt;gst/pbutils/pbutils.h&gt;
  44 #include &lt;gst/base/gstbytereader.h&gt;
  45 
  46 GST_DEBUG_CATEGORY_STATIC (type_find_debug);
  47 #define GST_CAT_DEFAULT type_find_debug
  48 
  49 /* DataScanCtx: helper for typefind functions that scan through data
  50  * step-by-step, to avoid doing a peek at each and every offset */
  51 
  52 #define DATA_SCAN_CTX_CHUNK_SIZE 4096
  53 
  54 typedef struct
  55 {
  56   guint64 offset;
  57   const guint8 *data;
<span class="line-modified">  58   gint size;</span>
  59 } DataScanCtx;
  60 
  61 static inline void
  62 data_scan_ctx_advance (GstTypeFind * tf, DataScanCtx * c, guint bytes_to_skip)
  63 {
  64   c-&gt;offset += bytes_to_skip;
  65   if (G_LIKELY (c-&gt;size &gt; bytes_to_skip)) {
  66     c-&gt;size -= bytes_to_skip;
  67     c-&gt;data += bytes_to_skip;
  68   } else {
  69     c-&gt;data += c-&gt;size;
  70     c-&gt;size = 0;
  71   }
  72 }
  73 
  74 static inline gboolean
<span class="line-modified">  75 data_scan_ctx_ensure_data (GstTypeFind * tf, DataScanCtx * c, gint min_len)</span>
  76 {
  77   const guint8 *data;
  78   guint64 len;
  79   guint chunk_len = MAX (DATA_SCAN_CTX_CHUNK_SIZE, min_len);
  80 
  81   if (G_LIKELY (c-&gt;size &gt;= min_len))
  82     return TRUE;
  83 
  84   data = gst_type_find_peek (tf, c-&gt;offset, chunk_len);
  85   if (G_LIKELY (data != NULL)) {
  86     c-&gt;data = data;
  87     c-&gt;size = chunk_len;
  88     return TRUE;
  89   }
  90 
  91   /* if there&#39;s less than our chunk size, try to get as much as we can, but
  92    * always at least min_len bytes (we might be typefinding the first buffer
  93    * of the stream and not have as much data available as we&#39;d like) */
  94   len = gst_type_find_get_length (tf);
  95   if (len &gt; 0) {
  96     len = CLAMP (len - c-&gt;offset, min_len, chunk_len);
  97   } else {
  98     len = min_len;
  99   }
 100 
 101   data = gst_type_find_peek (tf, c-&gt;offset, len);
 102   if (data != NULL) {
 103     c-&gt;data = data;
 104     c-&gt;size = len;
 105     return TRUE;
 106   }
 107 
 108   return FALSE;
 109 }
 110 
 111 static inline gboolean
 112 data_scan_ctx_memcmp (GstTypeFind * tf, DataScanCtx * c, guint offset,
 113     const gchar * data, guint len)
 114 {



 115   if (!data_scan_ctx_ensure_data (tf, c, offset + len))
 116     return FALSE;
 117 
 118   return (memcmp (c-&gt;data + offset, data, len) == 0);
 119 }
 120 
 121 /*** text/plain ***/
 122 static gboolean xml_check_first_element (GstTypeFind * tf,
 123     const gchar * element, guint elen, gboolean strict);
 124 static gboolean sdp_check_header (GstTypeFind * tf);
 125 
 126 static GstStaticCaps utf8_caps = GST_STATIC_CAPS (&quot;text/plain&quot;);
 127 
 128 #define UTF8_CAPS gst_static_caps_get(&amp;utf8_caps)
 129 
 130 static gboolean
 131 utf8_type_find_have_valid_utf8_at_offset (GstTypeFind * tf, guint64 offset,
 132     GstTypeFindProbability * prob)
 133 {
 134   const guint8 *data;
</pre>
<hr />
<pre>
 262   if (len &amp; 3)
 263     return FALSE;
 264   while (len &gt; 3) {
 265     guint32 v;
 266     if (endianness == G_BIG_ENDIAN)
 267       v = GST_READ_UINT32_BE (data);
 268     else
 269       v = GST_READ_UINT32_LE (data);
 270     if (v &gt;= 0x10FFFF)
 271       return FALSE;
 272     data += 4;
 273     len -= 4;
 274   }
 275   return TRUE;
 276 }
 277 
 278 static void
 279 unicode_type_find (GstTypeFind * tf, const GstUnicodeTester * tester,
 280     guint n_tester, const char *media_type, gboolean require_bom)
 281 {
<span class="line-modified"> 282   size_t n;</span>
<span class="line-modified"> 283   gint len = 4;</span>
 284   const guint8 *data = gst_type_find_peek (tf, 0, len);
 285   int prob = -1;
 286   const gint max_scan_size = 256 * 1024;
 287   int endianness = 0;
 288 
 289   if (!data) {
 290     len = 2;
 291     data = gst_type_find_peek (tf, 0, len);
 292     if (!data)
 293       return;
 294   }
 295 
 296   /* find a large enough size that works */
 297   while (len &lt; max_scan_size) {
 298     size_t newlen = len &lt;&lt; 1;
 299     const guint8 *newdata = gst_type_find_peek (tf, 0, newlen);
 300     if (!newdata)
 301       break;
 302     len = newlen;
 303     data = newdata;
</pre>
<hr />
<pre>
 663   if (xml_check_first_element (tf, &quot;&quot;, 0, TRUE)) {
 664     gst_type_find_suggest (tf, GST_TYPE_FIND_MINIMUM, GENERIC_XML_CAPS);
 665   }
 666 }
 667 
 668 /*** application/dash+xml ****************************************************/
 669 
 670 static GstStaticCaps dash_caps = GST_STATIC_CAPS (&quot;application/dash+xml&quot;);
 671 
 672 #define DASH_CAPS gst_static_caps_get (&amp;dash_caps)
 673 
 674 static void
 675 dash_mpd_type_find (GstTypeFind * tf, gpointer unused)
 676 {
 677   if (xml_check_first_element (tf, &quot;MPD&quot;, 3, FALSE) ||
 678       xml_check_first_element (tf, &quot;mpd&quot;, 3, FALSE)) {
 679     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, DASH_CAPS);
 680   }
 681 }
 682 















 683 /*** application/sdp *********************************************************/
 684 
 685 static GstStaticCaps sdp_caps = GST_STATIC_CAPS (&quot;application/sdp&quot;);
 686 
 687 #define SDP_CAPS (gst_static_caps_get(&amp;sdp_caps))
 688 static gboolean
 689 sdp_check_header (GstTypeFind * tf)
 690 {
 691   const guint8 *data;
 692 
 693   data = gst_type_find_peek (tf, 0, 5);
 694   if (!data)
 695     return FALSE;
 696 
 697   /* sdp must start with v=0[\r]\n */
 698   if (memcmp (data, &quot;v=0&quot;, 3))
 699     return FALSE;
 700 
 701   if (data[3] == &#39;\r&#39; &amp;&amp; data[4] == &#39;\n&#39;)
 702     return TRUE;
</pre>
<hr />
<pre>
1079 
1080     data_scan_ctx_advance (tf, &amp;c, len);
1081   } while (count &lt; max_frames &amp;&amp; (c.offset - scan_ctx-&gt;offset) &lt; 64 * 1024);
1082 
1083   GST_DEBUG (&quot;found %d consecutive frames&quot;, count);
1084   return count;
1085 }
1086 
1087 /*** audio/mpeg version 2, 4 ***/
1088 
1089 static GstStaticCaps aac_caps = GST_STATIC_CAPS (&quot;audio/mpeg, &quot;
1090     &quot;mpegversion = (int) { 2, 4 }, framed = (bool) false&quot;);
1091 #define AAC_CAPS (gst_static_caps_get(&amp;aac_caps))
1092 #define AAC_AMOUNT (4096)
1093 static void
1094 aac_type_find (GstTypeFind * tf, gpointer unused)
1095 {
1096   DataScanCtx c = { 0, NULL, 0 };
1097   GstTypeFindProbability best_probability = GST_TYPE_FIND_NONE;
1098   GstCaps *best_caps = NULL;
<span class="line-modified">1099   guint best_count = 0;</span>
1100 
1101   while (c.offset &lt; AAC_AMOUNT) {
1102     guint snc, len, offset, i;
1103 
1104     /* detect adts header or adif header.
1105      * The ADIF header is 4 bytes, that should be OK. The ADTS header, on
1106      * the other hand, is 14 bits only, so we require one valid frame with
1107      * again a valid syncpoint on the next one (28 bits) for certainty. We
1108      * require 4 kB, which is quite a lot, since frames are generally 200-400
1109      * bytes.
1110      * LOAS has 2 possible syncwords, which are 11 bits and 16 bits long.
1111      * The following stream syntax depends on which one is found.
1112      */
1113     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 6)))
1114       break;
1115 
1116     snc = GST_READ_UINT16_BE (c.data);
1117     if (G_UNLIKELY ((snc &amp; 0xfff6) == 0xfff0)) {
1118       /* ADTS header - find frame length */
1119       GST_DEBUG (&quot;Found one ADTS syncpoint at offset 0x%&quot; G_GINT64_MODIFIER
</pre>
<hr />
<pre>
1166             &quot;framed&quot;, G_TYPE_BOOLEAN, FALSE,
1167             &quot;mpegversion&quot;, G_TYPE_INT, mpegversion,
1168             &quot;stream-format&quot;, G_TYPE_STRING, &quot;adts&quot;, NULL);
1169 
1170         gst_codec_utils_aac_caps_set_level_and_profile (caps, audio_config, 2);
1171 
1172         /* add rate and number of channels if we can */
1173         if (channel_config != 0 &amp;&amp; channel_config &lt;= 7) {
1174           const guint channels_map[] = { 0, 1, 2, 3, 4, 5, 6, 8 };
1175 
1176           gst_caps_set_simple (caps, &quot;channels&quot;, G_TYPE_INT,
1177               channels_map[channel_config], &quot;rate&quot;, G_TYPE_INT, rate, NULL);
1178         }
1179 
1180         /* length of the second ADTS frame */
1181         len = ((c.data[offset + 3] &amp; 0x03) &lt;&lt; 11) |
1182             (c.data[offset + 4] &lt;&lt; 3) | ((c.data[offset + 5] &amp; 0xe0) &gt;&gt; 5);
1183 
1184         if (len == 0 || !data_scan_ctx_ensure_data (tf, &amp;c, offset + len + 6)) {
1185           GST_DEBUG (&quot;Wrong sync or next frame not within reach, len=%u&quot;, len);
<span class="line-modified">1186         gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, caps);</span>
1187         } else {
1188           offset += len;
1189           /* find more aac sync to select correctly */
1190           /* check if there&#39;s a third/fourth/fifth/sixth ADTS frame, if there is a sixth frame, set probability to maximum:100% */
1191           for (i = 3; i &lt;= 6; i++) {
1192             len = ((c.data[offset + 3] &amp; 0x03) &lt;&lt; 11) |
1193                 (c.data[offset + 4] &lt;&lt; 3) | ((c.data[offset + 5] &amp; 0xe0) &gt;&gt; 5);
1194             if (len == 0
1195                 || !data_scan_ctx_ensure_data (tf, &amp;c, offset + len + 6)) {
1196               GST_DEBUG (&quot;Wrong sync or next frame not within reach, len=%u&quot;,
1197                   len);
1198               break;
1199             }
1200             snc = GST_READ_UINT16_BE (c.data + offset);
1201             if ((snc &amp; 0xfff6) == 0xfff0) {
1202               GST_DEBUG (&quot;Find %und Sync..probability is %u &quot;, i,
1203                   GST_TYPE_FIND_LIKELY + 5 * (i - 2));
1204               offset += len;
1205             } else {
1206               break;
</pre>
<hr />
<pre>
1218       gint count;
1219 
1220       /* LOAS frame */
1221       GST_INFO (&quot;Possible LOAS syncword at offset 0x%&quot; G_GINT64_MODIFIER
1222           &quot;x, scanning for more frames...&quot;, c.offset);
1223 
1224       if (snc == 0x4de1)
1225         count = aac_type_find_scan_loas_frames_ep (tf, &amp;c, 20);
1226       else
1227         count = aac_type_find_scan_loas_frames (tf, &amp;c, 20);
1228 
1229       if (count &gt;= 3 &amp;&amp; count &gt; best_count) {
1230         gst_caps_replace (&amp;best_caps, NULL);
1231         best_caps = gst_caps_new_simple (&quot;audio/mpeg&quot;,
1232             &quot;framed&quot;, G_TYPE_BOOLEAN, FALSE,
1233             &quot;mpegversion&quot;, G_TYPE_INT, 4,
1234             &quot;stream-format&quot;, G_TYPE_STRING, &quot;loas&quot;, NULL);
1235         best_count = count;
1236         best_probability = GST_TYPE_FIND_POSSIBLE - 10 + count * 3;
1237         if (best_probability &gt;= GST_TYPE_FIND_LIKELY)
<span class="line-modified">1238         break;</span>
1239       }
1240     } else if (!memcmp (c.data, &quot;ADIF&quot;, 4)) {
1241       /* ADIF header */
1242       gst_type_find_suggest_simple (tf, GST_TYPE_FIND_LIKELY, &quot;audio/mpeg&quot;,
1243           &quot;framed&quot;, G_TYPE_BOOLEAN, FALSE, &quot;mpegversion&quot;, G_TYPE_INT, 4,
1244           &quot;stream-format&quot;, G_TYPE_STRING, &quot;adif&quot;, NULL);
1245       break;
1246     }
1247 
1248   next:
1249 
1250     data_scan_ctx_advance (tf, &amp;c, 1);
1251   }
1252 
1253   if (best_probability &gt; GST_TYPE_FIND_NONE) {
1254     gst_type_find_suggest (tf, best_probability, best_caps);
1255     gst_caps_unref (best_caps);
1256   }
1257 }
1258 
</pre>
<hr />
<pre>
1581       GST_LOG (&quot;detected audio/mpeg only in the middle (p=%u)&quot;, mid_prob);
1582       layer = mid_layer;
1583       prob = mid_prob;
1584       goto suggest;
1585     }
1586 
1587     if (layer != mid_layer) {
1588       GST_WARNING (&quot;audio/mpeg layer discrepancy: %u vs. %u&quot;, layer, mid_layer);
1589       return;                   /* FIXME: or should we just go with the one in the middle? */
1590     }
1591 
1592     /* detected mpeg audio both in middle of the file and at the start */
1593     prob = (prob + mid_prob) / 2;
1594     goto suggest;
1595   }
1596 
1597   /* a valid header right at the start makes it more likely
1598    * that this is actually plain mpeg-1 audio */
1599   if (prob &gt; 0) {
1600     data = gst_type_find_peek (tf, 0, 4);       /* use min. frame size? */
<span class="line-modified">1601   if (data &amp;&amp; mp3_type_frame_length_from_header (GST_READ_UINT32_BE (data),</span>
<span class="line-modified">1602           &amp;layer, NULL, NULL, NULL, NULL, 0) != 0) {</span>
1603       prob = MIN (prob + 10, GST_TYPE_FIND_MAXIMUM);
<span class="line-modified">1604   }</span>
1605   }
1606 
1607   if (prob &gt; 0)
1608     goto suggest;
1609 
1610   return;
1611 
1612 suggest:
1613   {
1614     g_return_if_fail (layer &gt;= 1 &amp;&amp; layer &lt;= 3);
1615 
1616     gst_type_find_suggest_simple (tf, prob, &quot;audio/mpeg&quot;,
1617         &quot;mpegversion&quot;, G_TYPE_INT, 1, &quot;layer&quot;, G_TYPE_INT, layer,
1618         &quot;parsed&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
1619   }
1620 }
1621 
1622 /*** audio/x-musepack ***/
1623 
1624 static GstStaticCaps musepack_caps =
</pre>
<hr />
<pre>
2453 static void
2454 mpeg_ts_type_find (GstTypeFind * tf, gpointer unused)
2455 {
2456   /* TS packet sizes to test: normal, DVHS packet size and
2457    * FEC with 16 or 20 byte codes packet size. */
2458   const gint pack_sizes[] = { 188, 192, 204, 208 };
2459   const guint8 *data = NULL;
2460   guint size = 0;
2461   guint64 skipped = 0;
2462 
2463   while (skipped &lt; GST_MPEGTS_TYPEFIND_SCAN_LENGTH) {
2464     if (size &lt; MPEGTS_HDR_SIZE) {
2465       data = gst_type_find_peek (tf, skipped, GST_MPEGTS_TYPEFIND_SYNC_SIZE);
2466       if (!data)
2467         break;
2468       size = GST_MPEGTS_TYPEFIND_SYNC_SIZE;
2469     }
2470 
2471     /* Have at least MPEGTS_HDR_SIZE bytes at this point */
2472     if (IS_MPEGTS_HEADER (data)) {
<span class="line-modified">2473       gint p;</span>
2474 
2475       GST_LOG (&quot;possible mpeg-ts sync at offset %&quot; G_GUINT64_FORMAT, skipped);
2476 
2477       for (p = 0; p &lt; G_N_ELEMENTS (pack_sizes); p++) {
2478         gint found;
2479 
2480         /* Probe ahead at size pack_sizes[p] */
2481         found = mpeg_ts_probe_headers (tf, skipped, pack_sizes[p]);
2482         if (found &gt;= GST_MPEGTS_TYPEFIND_MIN_HEADERS) {
2483           gint probability;
2484 
2485           /* found at least 4 headers. 10 headers = MAXIMUM probability.
2486            * Arbitrarily, I assigned 10% probability for each header we
2487            * found, 40% -&gt; 100% */
2488           probability = MIN (10 * found, GST_TYPE_FIND_MAXIMUM);
2489 
2490           gst_type_find_suggest_simple (tf, probability, &quot;video/mpegts&quot;,
2491               &quot;systemstream&quot;, G_TYPE_BOOLEAN, TRUE,
2492               &quot;packetsize&quot;, G_TYPE_INT, pack_sizes[p], NULL);
2493           return;
</pre>
<hr />
<pre>
2675       break;
2676 
2677     /* Find the picture start code */
2678     data = (data &lt;&lt; 8) + c.data[0];
2679     psc = data &amp; G_GUINT64_CONSTANT (0xfffffc0000);
2680     if (psc == 0x800000) {
2681       /* Found PSC */
2682       /* PTYPE */
2683       ptype = (data &amp; 0x3fc) &gt;&gt; 2;
2684       /* Source Format */
2685       format = ptype &amp; 0x07;
2686 
2687       /* Now that we have a Valid PSC, check if we also have a valid PTYPE and
2688          the Source Format, which should range between 1 and 5 */
2689       if (((ptype &gt;&gt; 6) == 0x2) &amp;&amp; (format &gt; 0 &amp;&amp; format &lt; 6)) {
2690         pc_type = data &amp; 0x02;
2691         pb_mode = c.data[1] &amp; 0x20 &gt;&gt; 4;
2692         if (!pc_type &amp;&amp; pb_mode)
2693           bad++;
2694         else
<span class="line-modified">2695         good++;</span>
2696       } else
2697         bad++;
2698 
2699       /* FIXME: maybe bail out early if we get mostly bad syncs ? */
2700     }
2701 
2702     data_scan_ctx_advance (tf, &amp;c, 1);
2703   }
2704 
2705   GST_LOG (&quot;good: %d, bad: %d&quot;, good, bad);
2706 
2707   if (good &gt; 2 * bad)
2708     gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, H263_VIDEO_CAPS);
2709 
2710   return;
2711 }
2712 
2713 /*** video/x-h264 H264 elementary video stream ***/
2714 
2715 static GstStaticCaps h264_video_caps =
</pre>
<hr />
<pre>
2756           bad++;
2757         } else {
2758           if (nut == 7)
2759             seen_sps = TRUE;
2760           else if (nut == 8)
2761             seen_pps = TRUE;
2762           else if (nut == 5)
2763             seen_idr = TRUE;
2764 
2765           good++;
2766         }
2767       } else if (nut &gt;= 14 &amp;&amp; nut &lt;= 33) {
2768         if (nut == 15) {
2769           seen_ssps = TRUE;
2770           good++;
2771         } else if (nut == 14 || nut == 20) {
2772           /* Sometimes we see NAL 14 or 20 without SSPS
2773            * if dropped into the middle of a stream -
2774            * just ignore those (don&#39;t add to bad count) */
2775           if (seen_ssps)
<span class="line-modified">2776           good++;</span>
2777         } else {
<span class="line-modified">2778         /* reserved */</span>
<span class="line-modified">2779         /* Theoretically these are good, since if they exist in the</span>
<span class="line-modified">2780            stream it merely means that a newer backwards-compatible</span>
<span class="line-modified">2781            h.264 stream.  But we should be identifying that separately. */</span>
<span class="line-modified">2782         bad++;</span>
2783         }
2784       } else {
2785         /* unspecified, application specific */
2786         /* don&#39;t consider these bad */
2787       }
2788 
2789       GST_LOG (&quot;good:%d, bad:%d, pps:%d, sps:%d, idr:%d ssps:%d&quot;, good, bad,
2790           seen_pps, seen_sps, seen_idr, seen_ssps);
2791 
2792       if (seen_sps &amp;&amp; seen_pps &amp;&amp; seen_idr &amp;&amp; good &gt;= 10 &amp;&amp; bad &lt; 4) {
2793         gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, H264_VIDEO_CAPS);
2794         return;
2795       }
2796 
2797       data_scan_ctx_advance (tf, &amp;c, 4);
2798     }
2799     data_scan_ctx_advance (tf, &amp;c, 1);
2800   }
2801 
2802   GST_LOG (&quot;good:%d, bad:%d, pps:%d, sps:%d, idr:%d ssps=%d&quot;, good, bad,
</pre>
<hr />
<pre>
2906     &quot;systemstream = (boolean) false&quot;);
2907 #define MPEG_VIDEO_CAPS gst_static_caps_get(&amp;mpeg_video_caps)
2908 
2909 /*
2910  * Idea is the same as MPEG system stream typefinding: We check each
2911  * byte of the stream to see if - from that point on - the stream
2912  * matches a predefined set of marker bits as defined in the MPEG
2913  * video specs.
2914  *
2915  * I&#39;m sure someone will do a chance calculation here too.
2916  */
2917 
2918 static void
2919 mpeg_video_stream_type_find (GstTypeFind * tf, gpointer unused)
2920 {
2921   DataScanCtx c = { 0, NULL, 0 };
2922   gboolean seen_seq_at_0 = FALSE;
2923   gboolean seen_seq = FALSE;
2924   gboolean seen_gop = FALSE;
2925   guint64 last_pic_offset = 0;
<span class="line-modified">2926   guint num_pic_headers = 0;</span>
2927   gint found = 0;
2928 
2929   while (c.offset &lt; GST_MPEGVID_TYPEFIND_TRY_SYNC) {
2930     if (found &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES)
2931       break;
2932 
2933     if (!data_scan_ctx_ensure_data (tf, &amp;c, 5))
2934       break;
2935 
2936     if (!IS_MPEG_HEADER (c.data))
2937       goto next;
2938 
2939     /* a pack header indicates that this isn&#39;t an elementary stream */
2940     if (c.data[3] == 0xBA &amp;&amp; mpeg_sys_is_valid_pack (tf, c.data, c.size, NULL))
2941       return;
2942 
2943     /* do we have a sequence header? */
2944     if (c.data[3] == 0xB3) {
2945       seen_seq_at_0 = seen_seq_at_0 || (c.offset == 0);
2946       seen_seq = TRUE;
</pre>
<hr />
<pre>
3105   switch (GST_MAKE_FOURCC (data[0], data[1], data[2], 0)) {
3106     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;g&#39;, &#39;g&#39;, 0):
3107       return &quot;general&quot;;
3108     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;g&#39;, &#39;p&#39;, 0):
3109       return &quot;basic&quot;;
3110     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;g&#39;, &#39;s&#39;, 0):
3111       return &quot;streaming-server&quot;;
3112     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;g&#39;, &#39;r&#39;, 0):
3113       return &quot;progressive-download&quot;;
3114     default:
3115       break;
3116   }
3117   return NULL;
3118 }
3119 
3120 static void
3121 q3gp_type_find (GstTypeFind * tf, gpointer unused)
3122 {
3123   const gchar *profile;
3124   guint32 ftyp_size = 0;
<span class="line-modified">3125   gint offset = 0;</span>
3126   const guint8 *data = NULL;
3127 
3128   if ((data = gst_type_find_peek (tf, 0, 12)) == NULL) {
3129     return;
3130   }
3131 
3132   data += 4;
3133   if (memcmp (data, &quot;ftyp&quot;, 4) != 0) {
3134     return;
3135   }
3136 
3137   /* check major brand */
3138   data += 4;
3139   if ((profile = q3gp_type_find_get_profile (data))) {
3140     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,
3141         &quot;application/x-3gp&quot;, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);
3142     return;
3143   }
3144 
3145   /* check compatible brands */
3146   if ((data = gst_type_find_peek (tf, 0, 4)) != NULL) {
3147     ftyp_size = GST_READ_UINT32_BE (data);
3148   }
3149   if ((data = gst_type_find_peek (tf, 0, ftyp_size)) != NULL) {
3150     for (offset = 16; offset + 4 &lt; ftyp_size; offset += 4) {
3151       if ((profile = q3gp_type_find_get_profile (data + offset))) {
<span class="line-modified">3152       gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,</span>
<span class="line-modified">3153           &quot;application/x-3gp&quot;, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);</span>
<span class="line-modified">3154       return;</span>

3155     }
3156   }
<span class="line-removed">3157   }</span>
3158 
3159   return;
3160 
3161 }
3162 
3163 /*** video/mj2 and image/jp2 ***/
3164 static GstStaticCaps mj2_caps = GST_STATIC_CAPS (&quot;video/mj2&quot;);
3165 
3166 #define MJ2_CAPS gst_static_caps_get(&amp;mj2_caps)
3167 
3168 static GstStaticCaps jp2_caps = GST_STATIC_CAPS (&quot;image/jp2&quot;);
3169 
3170 #define JP2_CAPS gst_static_caps_get(&amp;jp2_caps)
3171 
3172 static void
3173 jp2_type_find (GstTypeFind * tf, gpointer unused)
3174 {
3175   const guint8 *data;
3176 
3177   data = gst_type_find_peek (tf, 0, 24);
</pre>
<hr />
<pre>
3347       }
3348     }
3349     /* other box/atom types, apparently quicktime specific */
3350     else if (STRNCMP (&amp;data[4], &quot;pnot&quot;, 4) == 0 ||
3351         STRNCMP (&amp;data[4], &quot;PICT&quot;, 4) == 0 ||
3352         STRNCMP (&amp;data[4], &quot;wide&quot;, 4) == 0 ||
3353         STRNCMP (&amp;data[4], &quot;prfl&quot;, 4) == 0) {
3354       tip = GST_TYPE_FIND_MAXIMUM;
3355       break;
3356     } else {
3357       tip = 0;
3358       break;
3359     }
3360 
3361     size = GST_READ_UINT32_BE (data);
3362     if (size + offset &gt;= G_MAXINT64)
3363       break;
3364     /* check compatible brands rather than ever expaning major brands above */
3365     if ((STRNCMP (&amp;data[4], &quot;ftyp&quot;, 4) == 0) &amp;&amp; (size &gt;= 16)) {
3366       data = gst_type_find_peek (tf, offset, size);
<span class="line-modified">3367         if (data == NULL)</span>
<span class="line-modified">3368           goto done;</span>
3369       new_offset = 12;
3370       while (new_offset + 4 &lt;= size) {
3371         if (STRNCMP (&amp;data[new_offset], &quot;isom&quot;, 4) == 0 ||
3372             STRNCMP (&amp;data[new_offset], &quot;dash&quot;, 4) == 0 ||
3373             STRNCMP (&amp;data[new_offset], &quot;avc1&quot;, 4) == 0 ||
3374             STRNCMP (&amp;data[new_offset], &quot;avc3&quot;, 4) == 0 ||
3375             STRNCMP (&amp;data[new_offset], &quot;mp41&quot;, 4) == 0 ||
3376             STRNCMP (&amp;data[new_offset], &quot;mp42&quot;, 4) == 0) {
3377           tip = GST_TYPE_FIND_MAXIMUM;
3378           variant = &quot;iso&quot;;
3379           goto done;
3380         }
3381         new_offset += 4;
3382       }
3383     }
3384     if (size == 1) {
3385       const guint8 *sizedata;
3386 
3387       sizedata = gst_type_find_peek (tf, offset + 8, 8);
3388       if (sizedata == NULL)
</pre>
<hr />
<pre>
3584     if (memcmp (data, &quot;PSM&quot;, 3) == 0) {
3585       unsigned char fbyte = data[3];
3586       if ((fbyte == &#39; &#39;) || (fbyte == 254)) {
3587         mod_type = &quot;psm&quot;;
3588         probability = GST_TYPE_FIND_MAXIMUM;
3589         goto suggest_audio_mod_caps;
3590       }
3591     }
3592     /* 669 */
3593     if ((memcmp (data, &quot;if&quot;, 2) == 0) || (memcmp (data, &quot;JN&quot;, 2) == 0)) {
3594       mod_type = &quot;669&quot;;
3595       probability = GST_TYPE_FIND_LIKELY;
3596       goto suggest_audio_mod_caps;
3597     }
3598     /* AMF */
3599     if ((memcmp (data, &quot;AMF&quot;, 3) == 0) &amp;&amp; (data[3] &gt; 10) &amp;&amp; (data[3] &lt; 14)) {
3600       mod_type = &quot;dsmi-amf&quot;;
3601       probability = GST_TYPE_FIND_MAXIMUM;
3602       goto suggest_audio_mod_caps;
3603     }
<span class="line-modified">3604         /* IT */</span>
3605     if (memcmp (data, &quot;IMPM&quot;, 4) == 0) {
3606       mod_type = &quot;it&quot;;
3607       probability = GST_TYPE_FIND_MAXIMUM;
3608       goto suggest_audio_mod_caps;
3609     }
3610     /* DBM (DigiBooster Pro) */
3611     if (memcmp (data, &quot;DBM0&quot;, 4) == 0) {
3612       mod_type = &quot;dbm&quot;;
3613       probability = GST_TYPE_FIND_MAXIMUM;
3614       goto suggest_audio_mod_caps;
3615     }
3616     /* MDL (DigiTrakker) */
3617     if (memcmp (data, &quot;DMDL&quot;, 4) == 0) {
3618       mod_type = &quot;mdl&quot;;
3619       probability = GST_TYPE_FIND_MAXIMUM;
3620       goto suggest_audio_mod_caps;
3621     }
3622     /* MT2 (MadTracker 2.0) */
3623     if (memcmp (data, &quot;MT20&quot;, 4) == 0) {
3624       mod_type = &quot;mt2&quot;;
3625       probability = GST_TYPE_FIND_MAXIMUM;
3626       goto suggest_audio_mod_caps;
3627     }
3628     /* DMF (X-Tracker) */
3629     if (memcmp (data, &quot;DDMF&quot;, 4) == 0) {
3630       mod_type = &quot;dmf&quot;;
3631       probability = GST_TYPE_FIND_MAXIMUM;
3632       goto suggest_audio_mod_caps;
3633     }
<span class="line-modified">3634         /* MED */</span>
3635     if ((memcmp (data, &quot;MMD0&quot;, 4) == 0) || (memcmp (data, &quot;MMD1&quot;, 4) == 0)) {
3636       mod_type = &quot;med&quot;;
3637       probability = GST_TYPE_FIND_MAXIMUM;
3638       goto suggest_audio_mod_caps;
3639     }
<span class="line-modified">3640         /* MTM */</span>
3641     if (memcmp (data, &quot;MTM&quot;, 3) == 0) {
3642       mod_type = &quot;mtm&quot;;
3643       probability = GST_TYPE_FIND_MAXIMUM;
3644       goto suggest_audio_mod_caps;
3645     }
3646     /* DSM */
3647     if (memcmp (data, &quot;RIFF&quot;, 4) == 0) {
3648       const guint8 *data2 = gst_type_find_peek (tf, 8, 4);
3649 
3650       if (data2) {
3651         if (memcmp (data2, &quot;DSMF&quot;, 4) == 0) {
3652           mod_type = &quot;dsm&quot;;
3653           probability = GST_TYPE_FIND_MAXIMUM;
3654           goto suggest_audio_mod_caps;
3655         }
3656       }
3657     }
3658     /* FAR (Farandole) */
3659     if (memcmp (data, &quot;FAR\xFE&quot;, 4) == 0) {
3660       mod_type = &quot;far&quot;;
</pre>
<hr />
<pre>
3683       const guint8 *data2 = gst_type_find_peek (tf, 71, 4);
3684 
3685       if (data2) {
3686         if (memcmp (data2, &quot;GMFS&quot;, 4) == 0) {
3687           mod_type = &quot;gdm&quot;;
3688           probability = GST_TYPE_FIND_MAXIMUM;
3689           goto suggest_audio_mod_caps;
3690         }
3691         /* otherwise do not suggest anything */
3692       } else {
3693         mod_type = &quot;gdm&quot;;
3694         probability = GST_TYPE_FIND_LIKELY;
3695         goto suggest_audio_mod_caps;
3696       }
3697     }
3698     /* UMX */
3699     if (memcmp (data, &quot;\xC1\x83\x2A\x9E&quot;, 4) == 0) {
3700       mod_type = &quot;umx&quot;;
3701       probability = GST_TYPE_FIND_POSSIBLE;
3702       goto suggest_audio_mod_caps;
<span class="line-modified">3703   }</span>
3704   }
3705   /* FAR (Farandole) (secondary detection) */
3706   if ((data = gst_type_find_peek (tf, 44, 3)) != NULL) {
3707     if (memcmp (data, &quot;\x0D\x0A\x1A&quot;, 3) == 0) {
3708       mod_type = &quot;far&quot;;
3709       probability = GST_TYPE_FIND_POSSIBLE;
3710       goto suggest_audio_mod_caps;
3711     }
3712   }
3713   /* IMF */
3714   if ((data = gst_type_find_peek (tf, 60, 4)) != NULL) {
3715     if (memcmp (data, &quot;IM10&quot;, 4) == 0) {
3716       mod_type = &quot;imf&quot;;
3717       probability = GST_TYPE_FIND_MAXIMUM;
3718       goto suggest_audio_mod_caps;
3719     }
3720   }
3721   /* S3M */
3722   if ((data = gst_type_find_peek (tf, 44, 4)) != NULL) {
3723     if (memcmp (data, &quot;SCRM&quot;, 4) == 0) {
</pre>
<hr />
<pre>
3797 GST_STATIC_CAPS (&quot;application/vnd.ms-sstr+xml&quot;);
3798 #define MSS_MANIFEST_CAPS (gst_static_caps_get(&amp;mss_manifest_caps))
3799 static void
3800 mss_manifest_type_find (GstTypeFind * tf, gpointer unused)
3801 {
3802   gunichar2 utf16_ne[512];
3803   const guint8 *data;
3804   guint data_endianness = 0;
3805   glong n_read = 0, size = 0;
3806   guint length;
3807   gchar *utf8;
3808   gboolean utf8_bom_detected = FALSE;
3809 
3810   if (xml_check_first_element (tf, &quot;SmoothStreamingMedia&quot;, 20, TRUE)) {
3811     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MSS_MANIFEST_CAPS);
3812     return;
3813   }
3814 
3815   length = gst_type_find_get_length (tf);
3816 
<span class="line-modified">3817     /* try detecting the charset */</span>
3818   data = gst_type_find_peek (tf, 0, 3);
3819 
<span class="line-modified">3820     if (data == NULL)</span>
<span class="line-modified">3821       return;</span>
3822 
<span class="line-modified">3823     /* look for a possible BOM */</span>
3824   if (data[0] == 0xEF &amp;&amp; data[1] == 0xBB &amp;&amp; data[2] == 0xBF)
3825     utf8_bom_detected = TRUE;
3826   else if (data[0] == 0xFF &amp;&amp; data[1] == 0xFE)
3827     data_endianness = G_LITTLE_ENDIAN;
3828   else if (data[0] == 0xFE &amp;&amp; data[1] == 0xFF)
3829     data_endianness = G_BIG_ENDIAN;
3830   else
3831     return;
3832 
<span class="line-modified">3833       /* try a default that should be enough */</span>
<span class="line-modified">3834       if (length == 0)</span>
<span class="line-modified">3835         length = 512;</span>
3836   else if (length &lt; 64)
3837     return;
3838   else                          /* the first few bytes should be enough */
3839     length = MIN (1024, length);
3840 
<span class="line-modified">3841       data = gst_type_find_peek (tf, 0, length);</span>
3842 
3843   if (data == NULL)
3844     return;
3845 
<span class="line-modified">3846         /* skip the BOM */</span>
<span class="line-modified">3847         data += 2;</span>
<span class="line-modified">3848         length -= 2;</span>
3849 
3850   if (utf8_bom_detected) {
3851     /* skip last byte of the BOM */
3852     data++;
3853     length--;
3854 
3855     if (xml_check_first_element_from_data (data, length,
<span class="line-modified">3856                   &quot;SmoothStreamingMedia&quot;, 20, TRUE))</span>
3857       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MSS_MANIFEST_CAPS);
3858   } else {
3859     length = GST_ROUND_DOWN_2 (length);
3860 
3861     /* convert to native endian UTF-16 */
3862     mss_manifest_load_utf16 (utf16_ne, data, length, data_endianness);
3863 
3864     /* and now convert to UTF-8 */
3865     utf8 = g_utf16_to_utf8 (utf16_ne, length / 2, &amp;n_read, &amp;size, NULL);
3866     if (utf8 != NULL &amp;&amp; n_read &gt; 0) {
3867       if (xml_check_first_element_from_data ((const guint8 *) utf8, size,
3868               &quot;SmoothStreamingMedia&quot;, 20, TRUE))
3869         gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MSS_MANIFEST_CAPS);
<span class="line-removed">3870         }</span>
<span class="line-removed">3871     g_free (utf8);</span>
<span class="line-removed">3872       }</span>
3873     }



3874 
3875 /*** image/jpeg ***/
3876 
3877 #define JPEG_MARKER_IS_START_OF_FRAME(x) \
3878     ((x)&gt;=0xc0 &amp;&amp; (x) &lt;= 0xcf &amp;&amp; (x)!=0xc4 &amp;&amp; (x)!=0xc8 &amp;&amp; (x)!=0xcc)
3879 
3880 static GstStaticCaps jpeg_caps = GST_STATIC_CAPS (&quot;image/jpeg&quot;);
3881 
3882 #define JPEG_CAPS (gst_static_caps_get(&amp;jpeg_caps))
3883 static void
3884 jpeg_type_find (GstTypeFind * tf, gpointer unused)
3885 {
3886   GstTypeFindProbability prob = GST_TYPE_FIND_POSSIBLE;
3887   DataScanCtx c = { 0, NULL, 0 };
3888   GstCaps *caps;
3889   guint num_markers;
3890 
3891   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 2)))
3892     return;
3893 
</pre>
<hr />
<pre>
4344   data_scan_ctx_advance (tf, c, 1 + len);
4345 
4346   /* undefined/unknown size? (all bits 1) */
4347   if (*size == mask) {
4348     /* allow unknown size for SEGMENT chunk, bail out otherwise */
4349     if (*id == MATROSKA_SEGMENT)
4350       *size = G_MAXUINT64;
4351     else
4352       return 0;
4353   }
4354 
4355   return id_len + (1 + len);
4356 }
4357 
4358 static gboolean
4359 ebml_parse_chunk (GstTypeFind * tf, DataScanCtx * ctx, guint32 chunk_id,
4360     guint chunk_size, GstMatroskaInfo * info, guint depth)
4361 {                               /* FIXME: make sure input size is clipped to 32 bit */
4362   static const gchar SPACES[] = &quot;                &quot;;
4363   DataScanCtx c = *ctx;
<span class="line-modified">4364   guint64 element_size;</span>
4365   guint32 id, hdr_len;
4366 
4367   if (depth &gt;= 8)               /* keep SPACES large enough for depth */
4368     return FALSE;
4369 
4370   while (chunk_size &gt; 0) {
4371     if (c.offset &gt; EBML_MAX_LEN || !data_scan_ctx_ensure_data (tf, &amp;c, 64))
<span class="line-modified">4372     return FALSE;</span>
4373 
4374     hdr_len = ebml_read_chunk_header (tf, &amp;c, chunk_size, &amp;id, &amp;element_size);
4375     if (hdr_len == 0)
<span class="line-modified">4376     return FALSE;</span>
4377 
4378     g_assert (hdr_len &lt;= chunk_size);
4379     chunk_size -= hdr_len;
4380 
4381     if (element_size &gt; chunk_size)
<span class="line-modified">4382     return FALSE;</span>
4383 
4384     GST_DEBUG (&quot;%s %08x, size %&quot; G_GUINT64_FORMAT &quot; / %&quot; G_GUINT64_FORMAT,
4385         SPACES + sizeof (SPACES) - 1 - (2 * depth), id, element_size,
4386         hdr_len + element_size);
4387 





4388     if (!data_scan_ctx_ensure_data (tf, &amp;c, element_size)) {
4389       GST_DEBUG (&quot;not enough data&quot;);
4390       return FALSE;
4391     }
4392 
4393     switch (id) {
4394       case EBML_DOCTYPE:
4395         if (element_size &gt;= 8 &amp;&amp; memcmp (c.data, &quot;matroska&quot;, 8) == 0)
4396           info-&gt;doctype = EBML_DOCTYPE_MATROSKA;
4397         else if (element_size &gt;= 4 &amp;&amp; memcmp (c.data, &quot;webm&quot;, 4) == 0)
4398           info-&gt;doctype = EBML_DOCTYPE_WEBM;
4399         break;
4400       case MATROSKA_SEGMENT:
4401         GST_LOG (&quot;parsing segment&quot;);
4402         ebml_parse_chunk (tf, &amp;c, id, element_size, info, depth + 1);
4403         GST_LOG (&quot;parsed segment, done&quot;);
<span class="line-modified">4404   return FALSE;</span>
4405       case MATROSKA_TRACKS:
4406         GST_LOG (&quot;parsing tracks&quot;);
4407         info-&gt;tracks_ok =
4408             ebml_parse_chunk (tf, &amp;c, id, element_size, info, depth + 1);
4409         GST_LOG (&quot;parsed tracks: %s, done (after %&quot; G_GUINT64_FORMAT &quot; bytes)&quot;,
4410             info-&gt;tracks_ok ? &quot;ok&quot; : &quot;FAIL&quot;, c.offset + element_size);
4411         return FALSE;
4412       case MATROSKA_TRACK_ENTRY:
4413         GST_LOG (&quot;parsing track entry&quot;);
4414         if (!ebml_parse_chunk (tf, &amp;c, id, element_size, info, depth + 1))
4415           return FALSE;
4416         break;
4417       case MATROSKA_TRACK_TYPE:{
4418         guint type = 0, i;
4419 
4420         /* is supposed to always be 1-byte, but not everyone&#39;s following that */
4421         for (i = 0; i &lt; element_size; ++i)
4422           type = (type &lt;&lt; 8) | c.data[i];
4423 
4424         GST_DEBUG (&quot;%s   track type %u&quot;,
</pre>
<hr />
<pre>
5221 
5222 /* NOTE: we cannot replace this function with TYPE_FIND_REGISTER_START_WITH,
5223  * as it is only possible to register one typefind factory per &#39;name&#39;
5224  * (which is in this case the caps), and the first one would be replaced by
5225  * the second one. */
5226 static GstStaticCaps dirac_caps = GST_STATIC_CAPS (&quot;video/x-dirac&quot;);
5227 
5228 #define DIRAC_CAPS (gst_static_caps_get(&amp;dirac_caps))
5229 static void
5230 dirac_type_find (GstTypeFind * tf, gpointer unused)
5231 {
5232   const guint8 *data = gst_type_find_peek (tf, 0, 8);
5233 
5234   if (data) {
5235     if (memcmp (data, &quot;BBCD&quot;, 4) == 0 || memcmp (data, &quot;KW-DIRAC&quot;, 8) == 0) {
5236       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, DIRAC_CAPS);
5237     }
5238   }
5239 }
5240 






















5241 /*** video/vivo ***/
5242 
5243 static GstStaticCaps vivo_caps = GST_STATIC_CAPS (&quot;video/vivo&quot;);
5244 
5245 #define VIVO_CAPS gst_static_caps_get(&amp;vivo_caps)
5246 
5247 static void
5248 vivo_type_find (GstTypeFind * tf, gpointer unused)
5249 {
5250   static const guint8 vivo_marker[] = { &#39;V&#39;, &#39;e&#39;, &#39;r&#39;, &#39;s&#39;, &#39;i&#39;, &#39;o&#39;, &#39;n&#39;,
5251     &#39;:&#39;, &#39;V&#39;, &#39;i&#39;, &#39;v&#39;, &#39;o&#39;, &#39;/&#39;
5252   };
5253   const guint8 *data;
5254   guint hdr_len, pos;
5255 
5256   data = gst_type_find_peek (tf, 0, 1024);
5257   if (data == NULL || data[0] != 0x00)
5258     return;
5259 
5260   if ((data[1] &amp; 0x80)) {
</pre>
<hr />
<pre>
5598       media_type = &quot;application/x-ssa&quot;;
5599   }
5600 
5601   if (media_type == NULL) {
5602     if (strstr (str, &quot;[v4+ Styles]&quot;) || strstr (str, &quot;[V4+ Styles]&quot;))
5603       media_type = &quot;application/x-ass&quot;;
5604     else if (strstr (str, &quot;[v4 Styles]&quot;) || strstr (str, &quot;[V4 Styles]&quot;))
5605       media_type = &quot;application/x-ssa&quot;;
5606   }
5607 
5608   if (media_type != NULL) {
5609     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,
5610         media_type, &quot;parsed&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
5611   } else {
5612     GST_WARNING (&quot;could not detect SSA/ASS variant&quot;);
5613   }
5614 
5615   g_free (str);
5616 }
5617 


























5618 /*** video/x-pva ***/
5619 
5620 static GstStaticCaps pva_caps = GST_STATIC_CAPS (&quot;video/x-pva&quot;);
5621 
5622 #define PVA_CAPS gst_static_caps_get(&amp;pva_caps)
5623 
5624 static void
5625 pva_type_find (GstTypeFind * tf, gpointer private)
5626 {
5627   const guint8 *data;
5628 
5629   data = gst_type_find_peek (tf, 0, 5);
5630 
5631   if (data == NULL)
5632     return;
5633 
5634   if (data[0] == &#39;A&#39; &amp;&amp; data[1] == &#39;V&#39; &amp;&amp; data[2] &lt; 3 &amp;&amp; data[4] == 0x55)
5635     gst_type_find_suggest (tf, GST_TYPE_FIND_NEARLY_CERTAIN, PVA_CAPS);
5636 }
5637 
</pre>
<hr />
<pre>
5768 #ifndef GSTREAMER_LITE
5769   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-ms-asf&quot;, GST_RANK_SECONDARY,
5770       &quot;asf,wm,wma,wmv&quot;,
5771       &quot;\060\046\262\165\216\146\317\021\246\331\000\252\000\142\316\154&quot;, 16,
5772       GST_TYPE_FIND_MAXIMUM);
5773   TYPE_FIND_REGISTER (plugin, &quot;audio/x-musepack&quot;, GST_RANK_PRIMARY,
5774       musepack_type_find, &quot;mpc,mpp,mp+&quot;, MUSEPACK_CAPS, NULL, NULL);
5775   TYPE_FIND_REGISTER (plugin, &quot;audio/x-au&quot;, GST_RANK_MARGINAL,
5776       au_type_find, &quot;au,snd&quot;, AU_CAPS, NULL, NULL);
5777   TYPE_FIND_REGISTER_RIFF (plugin, &quot;video/x-msvideo&quot;, GST_RANK_PRIMARY,
5778       &quot;avi&quot;, &quot;AVI &quot;);
5779   TYPE_FIND_REGISTER_RIFF (plugin, &quot;audio/qcelp&quot;, GST_RANK_PRIMARY,
5780       &quot;qcp&quot;, &quot;QLCM&quot;);
5781   TYPE_FIND_REGISTER_RIFF (plugin, &quot;video/x-cdxa&quot;, GST_RANK_PRIMARY,
5782       &quot;dat&quot;, &quot;CDXA&quot;);
5783   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-vcd&quot;, GST_RANK_PRIMARY,
5784       &quot;dat&quot;, &quot;\000\377\377\377\377\377\377\377\377\377\377\000&quot;, 12,
5785       GST_TYPE_FIND_MAXIMUM);
5786   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-imelody&quot;, GST_RANK_PRIMARY,
5787       &quot;imy,ime,imelody&quot;, &quot;BEGIN:IMELODY&quot;, 13, GST_TYPE_FIND_MAXIMUM);





5788 #if 0
5789   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-smoke&quot;, GST_RANK_PRIMARY,
5790       NULL, &quot;\x80smoke\x00\x01\x00&quot;, 6, GST_TYPE_FIND_MAXIMUM);
5791 #endif
5792   TYPE_FIND_REGISTER (plugin, &quot;audio/midi&quot;, GST_RANK_PRIMARY, mid_type_find,
5793       &quot;mid,midi&quot;, MID_CAPS, NULL, NULL);
5794   TYPE_FIND_REGISTER_RIFF (plugin, &quot;audio/riff-midi&quot;, GST_RANK_PRIMARY,
5795       &quot;mid,midi&quot;, &quot;RMID&quot;);
5796   TYPE_FIND_REGISTER (plugin, &quot;audio/mobile-xmf&quot;, GST_RANK_PRIMARY,
5797       mxmf_type_find, &quot;mxmf&quot;, MXMF_CAPS, NULL, NULL);
5798   TYPE_FIND_REGISTER (plugin, &quot;video/x-fli&quot;, GST_RANK_MARGINAL, flx_type_find,
5799       &quot;flc,fli&quot;, FLX_CAPS, NULL, NULL);
5800   TYPE_FIND_REGISTER (plugin, &quot;application/x-id3v2&quot;, GST_RANK_PRIMARY + 103,
5801       id3v2_type_find, &quot;mp3,mp2,mp1,mpga,ogg,flac,tta&quot;, ID3_CAPS, NULL, NULL);
5802   TYPE_FIND_REGISTER (plugin, &quot;application/x-id3v1&quot;, GST_RANK_PRIMARY + 101,
5803       id3v1_type_find, &quot;mp3,mp2,mp1,mpga,ogg,flac,tta&quot;, ID3_CAPS, NULL, NULL);
5804   TYPE_FIND_REGISTER (plugin, &quot;application/x-apetag&quot;, GST_RANK_PRIMARY + 102,
5805       apetag_type_find, &quot;mp3,ape,mpc,wv&quot;, APETAG_CAPS, NULL, NULL);
5806   TYPE_FIND_REGISTER (plugin, &quot;audio/x-ttafile&quot;, GST_RANK_PRIMARY,
5807       tta_type_find, &quot;tta&quot;, TTA_CAPS, NULL, NULL);
</pre>
<hr />
<pre>
5846   TYPE_FIND_REGISTER (plugin, &quot;video/quicktime&quot;, GST_RANK_PRIMARY,
5847       qt_type_find, &quot;mov,mp4&quot;, QT_CAPS, NULL, NULL);
5848   TYPE_FIND_REGISTER (plugin, &quot;image/x-quicktime&quot;, GST_RANK_SECONDARY,
5849       qtif_type_find, &quot;qif,qtif,qti&quot;, QTIF_CAPS, NULL, NULL);
5850   TYPE_FIND_REGISTER (plugin, &quot;image/jp2&quot;, GST_RANK_PRIMARY,
5851       jp2_type_find, &quot;jp2&quot;, JP2_CAPS, NULL, NULL);
5852   TYPE_FIND_REGISTER (plugin, &quot;image/x-jpc&quot;, GST_RANK_PRIMARY,
5853       jpc_type_find, &quot;jpc,j2k&quot;, JPC_CAPS, NULL, NULL);
5854   TYPE_FIND_REGISTER (plugin, &quot;video/mj2&quot;, GST_RANK_PRIMARY,
5855       jp2_type_find, &quot;mj2&quot;, MJ2_CAPS, NULL, NULL);
5856 
5857   TYPE_FIND_REGISTER (plugin, &quot;text/html&quot;, GST_RANK_SECONDARY, html_type_find,
5858       &quot;htm,html&quot;, HTML_CAPS, NULL, NULL);
5859   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/vnd.rn-realmedia&quot;,
5860       GST_RANK_SECONDARY, &quot;ra,ram,rm,rmvb&quot;, &quot;.RMF&quot;, 4, GST_TYPE_FIND_MAXIMUM);
5861   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-pn-realaudio&quot;,
5862       GST_RANK_SECONDARY, &quot;ra,ram,rm,rmvb&quot;, &quot;.ra\375&quot;, 4,
5863       GST_TYPE_FIND_MAXIMUM);
5864   TYPE_FIND_REGISTER (plugin, &quot;application/x-shockwave-flash&quot;,
5865       GST_RANK_SECONDARY, swf_type_find, &quot;swf,swfl&quot;, SWF_CAPS, NULL, NULL);


5866   TYPE_FIND_REGISTER (plugin, &quot;application/dash+xml&quot;,
5867       GST_RANK_PRIMARY, dash_mpd_type_find, &quot;mpd,MPD&quot;, DASH_CAPS, NULL, NULL);
5868   TYPE_FIND_REGISTER (plugin, &quot;application/vnd.ms-sstr+xml&quot;,
5869       GST_RANK_PRIMARY, mss_manifest_type_find, NULL, MSS_MANIFEST_CAPS, NULL,
5870       NULL);
5871 #endif // GSTREAMER_LITE
5872   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-flv&quot;, GST_RANK_SECONDARY,
5873       &quot;flv&quot;, &quot;FLV&quot;, 3, GST_TYPE_FIND_MAXIMUM);
5874 #ifndef GSTREAMER_LITE
5875   TYPE_FIND_REGISTER (plugin, &quot;text/plain&quot;, GST_RANK_MARGINAL, utf8_type_find,
5876       &quot;txt&quot;, UTF8_CAPS, NULL, NULL);
5877   TYPE_FIND_REGISTER (plugin, &quot;text/utf-16&quot;, GST_RANK_MARGINAL, utf16_type_find,
5878       &quot;txt&quot;, UTF16_CAPS, NULL, NULL);
5879   TYPE_FIND_REGISTER (plugin, &quot;text/utf-32&quot;, GST_RANK_MARGINAL, utf32_type_find,
5880       &quot;txt&quot;, UTF32_CAPS, NULL, NULL);
5881   TYPE_FIND_REGISTER (plugin, &quot;text/uri-list&quot;, GST_RANK_MARGINAL, uri_type_find,
5882       &quot;ram&quot;, URI_CAPS, NULL, NULL);
5883   TYPE_FIND_REGISTER (plugin, &quot;application/itc&quot;, GST_RANK_SECONDARY,
5884       itc_type_find, &quot;itc&quot;, ITC_CAPS, NULL, NULL);
5885   TYPE_FIND_REGISTER (plugin, &quot;application/x-hls&quot;, GST_RANK_MARGINAL,
</pre>
<hr />
<pre>
6069 #endif
6070 
6071   TYPE_FIND_REGISTER (plugin, &quot;image/x-degas&quot;, GST_RANK_MARGINAL,
6072       degas_type_find, NULL, NULL, NULL, NULL);
6073   TYPE_FIND_REGISTER (plugin, &quot;application/octet-stream&quot;, GST_RANK_MARGINAL,
6074       dvdiso_type_find, NULL, NULL, NULL, NULL);
6075 
6076   TYPE_FIND_REGISTER (plugin, &quot;application/x-ssa&quot;, GST_RANK_SECONDARY,
6077       ssa_type_find, &quot;ssa,ass&quot;, NULL, NULL, NULL);
6078 
6079   TYPE_FIND_REGISTER (plugin, &quot;video/x-pva&quot;, GST_RANK_SECONDARY,
6080       pva_type_find, &quot;pva&quot;, PVA_CAPS, NULL, NULL);
6081 
6082   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-xi&quot;, GST_RANK_SECONDARY,
6083       &quot;xi&quot;, &quot;Extended Instrument: &quot;, 21, GST_TYPE_FIND_MAXIMUM);
6084 
6085   TYPE_FIND_REGISTER (plugin, &quot;audio/audible&quot;, GST_RANK_MARGINAL,
6086       aa_type_find, &quot;aa,aax&quot;, AA_CAPS, NULL, NULL);
6087 #endif // GSTREAMER_LITE
6088 





6089   return TRUE;
6090 }
6091 
6092 #ifndef GSTREAMER_LITE
6093 GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
6094     GST_VERSION_MINOR,
6095     typefindfunctions,
6096     &quot;default typefind functions&quot;,
6097     plugin_init, VERSION, GST_LICENSE, GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
<span class="line-modified">6098 #endif // GSTREAMER_LITE</span>
</pre>
</td>
<td>
<hr />
<pre>
  38 
  39 #include &lt;stdio.h&gt;
  40 #include &lt;string.h&gt;
  41 #include &lt;ctype.h&gt;
  42 
  43 #include &lt;gst/pbutils/pbutils.h&gt;
  44 #include &lt;gst/base/gstbytereader.h&gt;
  45 
  46 GST_DEBUG_CATEGORY_STATIC (type_find_debug);
  47 #define GST_CAT_DEFAULT type_find_debug
  48 
  49 /* DataScanCtx: helper for typefind functions that scan through data
  50  * step-by-step, to avoid doing a peek at each and every offset */
  51 
  52 #define DATA_SCAN_CTX_CHUNK_SIZE 4096
  53 
  54 typedef struct
  55 {
  56   guint64 offset;
  57   const guint8 *data;
<span class="line-modified">  58   guint size;</span>
  59 } DataScanCtx;
  60 
  61 static inline void
  62 data_scan_ctx_advance (GstTypeFind * tf, DataScanCtx * c, guint bytes_to_skip)
  63 {
  64   c-&gt;offset += bytes_to_skip;
  65   if (G_LIKELY (c-&gt;size &gt; bytes_to_skip)) {
  66     c-&gt;size -= bytes_to_skip;
  67     c-&gt;data += bytes_to_skip;
  68   } else {
  69     c-&gt;data += c-&gt;size;
  70     c-&gt;size = 0;
  71   }
  72 }
  73 
  74 static inline gboolean
<span class="line-modified">  75 data_scan_ctx_ensure_data (GstTypeFind * tf, DataScanCtx * c, guint min_len)</span>
  76 {
  77   const guint8 *data;
  78   guint64 len;
  79   guint chunk_len = MAX (DATA_SCAN_CTX_CHUNK_SIZE, min_len);
  80 
  81   if (G_LIKELY (c-&gt;size &gt;= min_len))
  82     return TRUE;
  83 
  84   data = gst_type_find_peek (tf, c-&gt;offset, chunk_len);
  85   if (G_LIKELY (data != NULL)) {
  86     c-&gt;data = data;
  87     c-&gt;size = chunk_len;
  88     return TRUE;
  89   }
  90 
  91   /* if there&#39;s less than our chunk size, try to get as much as we can, but
  92    * always at least min_len bytes (we might be typefinding the first buffer
  93    * of the stream and not have as much data available as we&#39;d like) */
  94   len = gst_type_find_get_length (tf);
  95   if (len &gt; 0) {
  96     len = CLAMP (len - c-&gt;offset, min_len, chunk_len);
  97   } else {
  98     len = min_len;
  99   }
 100 
 101   data = gst_type_find_peek (tf, c-&gt;offset, len);
 102   if (data != NULL) {
 103     c-&gt;data = data;
 104     c-&gt;size = len;
 105     return TRUE;
 106   }
 107 
 108   return FALSE;
 109 }
 110 
 111 static inline gboolean
 112 data_scan_ctx_memcmp (GstTypeFind * tf, DataScanCtx * c, guint offset,
 113     const gchar * data, guint len)
 114 {
<span class="line-added"> 115   if (G_UNLIKELY (offset + len &gt;= G_MAXUINT32))</span>
<span class="line-added"> 116     return FALSE;</span>
<span class="line-added"> 117 </span>
 118   if (!data_scan_ctx_ensure_data (tf, c, offset + len))
 119     return FALSE;
 120 
 121   return (memcmp (c-&gt;data + offset, data, len) == 0);
 122 }
 123 
 124 /*** text/plain ***/
 125 static gboolean xml_check_first_element (GstTypeFind * tf,
 126     const gchar * element, guint elen, gboolean strict);
 127 static gboolean sdp_check_header (GstTypeFind * tf);
 128 
 129 static GstStaticCaps utf8_caps = GST_STATIC_CAPS (&quot;text/plain&quot;);
 130 
 131 #define UTF8_CAPS gst_static_caps_get(&amp;utf8_caps)
 132 
 133 static gboolean
 134 utf8_type_find_have_valid_utf8_at_offset (GstTypeFind * tf, guint64 offset,
 135     GstTypeFindProbability * prob)
 136 {
 137   const guint8 *data;
</pre>
<hr />
<pre>
 265   if (len &amp; 3)
 266     return FALSE;
 267   while (len &gt; 3) {
 268     guint32 v;
 269     if (endianness == G_BIG_ENDIAN)
 270       v = GST_READ_UINT32_BE (data);
 271     else
 272       v = GST_READ_UINT32_LE (data);
 273     if (v &gt;= 0x10FFFF)
 274       return FALSE;
 275     data += 4;
 276     len -= 4;
 277   }
 278   return TRUE;
 279 }
 280 
 281 static void
 282 unicode_type_find (GstTypeFind * tf, const GstUnicodeTester * tester,
 283     guint n_tester, const char *media_type, gboolean require_bom)
 284 {
<span class="line-modified"> 285   gsize n;</span>
<span class="line-modified"> 286   gsize len = 4;</span>
 287   const guint8 *data = gst_type_find_peek (tf, 0, len);
 288   int prob = -1;
 289   const gint max_scan_size = 256 * 1024;
 290   int endianness = 0;
 291 
 292   if (!data) {
 293     len = 2;
 294     data = gst_type_find_peek (tf, 0, len);
 295     if (!data)
 296       return;
 297   }
 298 
 299   /* find a large enough size that works */
 300   while (len &lt; max_scan_size) {
 301     size_t newlen = len &lt;&lt; 1;
 302     const guint8 *newdata = gst_type_find_peek (tf, 0, newlen);
 303     if (!newdata)
 304       break;
 305     len = newlen;
 306     data = newdata;
</pre>
<hr />
<pre>
 666   if (xml_check_first_element (tf, &quot;&quot;, 0, TRUE)) {
 667     gst_type_find_suggest (tf, GST_TYPE_FIND_MINIMUM, GENERIC_XML_CAPS);
 668   }
 669 }
 670 
 671 /*** application/dash+xml ****************************************************/
 672 
 673 static GstStaticCaps dash_caps = GST_STATIC_CAPS (&quot;application/dash+xml&quot;);
 674 
 675 #define DASH_CAPS gst_static_caps_get (&amp;dash_caps)
 676 
 677 static void
 678 dash_mpd_type_find (GstTypeFind * tf, gpointer unused)
 679 {
 680   if (xml_check_first_element (tf, &quot;MPD&quot;, 3, FALSE) ||
 681       xml_check_first_element (tf, &quot;mpd&quot;, 3, FALSE)) {
 682     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, DASH_CAPS);
 683   }
 684 }
 685 
<span class="line-added"> 686 /*** application/xges ****************************************************/</span>
<span class="line-added"> 687 </span>
<span class="line-added"> 688 static GstStaticCaps xges_caps = GST_STATIC_CAPS (&quot;application/xges&quot;);</span>
<span class="line-added"> 689 </span>
<span class="line-added"> 690 #define XGES_CAPS gst_static_caps_get (&amp;xges_caps)</span>
<span class="line-added"> 691 </span>
<span class="line-added"> 692 static void</span>
<span class="line-added"> 693 xges_type_find (GstTypeFind * tf, gpointer unused)</span>
<span class="line-added"> 694 {</span>
<span class="line-added"> 695   if (xml_check_first_element (tf, &quot;ges&quot;, 3, FALSE)) {</span>
<span class="line-added"> 696     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, XGES_CAPS);</span>
<span class="line-added"> 697   }</span>
<span class="line-added"> 698 }</span>
<span class="line-added"> 699 </span>
<span class="line-added"> 700 </span>
 701 /*** application/sdp *********************************************************/
 702 
 703 static GstStaticCaps sdp_caps = GST_STATIC_CAPS (&quot;application/sdp&quot;);
 704 
 705 #define SDP_CAPS (gst_static_caps_get(&amp;sdp_caps))
 706 static gboolean
 707 sdp_check_header (GstTypeFind * tf)
 708 {
 709   const guint8 *data;
 710 
 711   data = gst_type_find_peek (tf, 0, 5);
 712   if (!data)
 713     return FALSE;
 714 
 715   /* sdp must start with v=0[\r]\n */
 716   if (memcmp (data, &quot;v=0&quot;, 3))
 717     return FALSE;
 718 
 719   if (data[3] == &#39;\r&#39; &amp;&amp; data[4] == &#39;\n&#39;)
 720     return TRUE;
</pre>
<hr />
<pre>
1097 
1098     data_scan_ctx_advance (tf, &amp;c, len);
1099   } while (count &lt; max_frames &amp;&amp; (c.offset - scan_ctx-&gt;offset) &lt; 64 * 1024);
1100 
1101   GST_DEBUG (&quot;found %d consecutive frames&quot;, count);
1102   return count;
1103 }
1104 
1105 /*** audio/mpeg version 2, 4 ***/
1106 
1107 static GstStaticCaps aac_caps = GST_STATIC_CAPS (&quot;audio/mpeg, &quot;
1108     &quot;mpegversion = (int) { 2, 4 }, framed = (bool) false&quot;);
1109 #define AAC_CAPS (gst_static_caps_get(&amp;aac_caps))
1110 #define AAC_AMOUNT (4096)
1111 static void
1112 aac_type_find (GstTypeFind * tf, gpointer unused)
1113 {
1114   DataScanCtx c = { 0, NULL, 0 };
1115   GstTypeFindProbability best_probability = GST_TYPE_FIND_NONE;
1116   GstCaps *best_caps = NULL;
<span class="line-modified">1117   gint best_count = 0;</span>
1118 
1119   while (c.offset &lt; AAC_AMOUNT) {
1120     guint snc, len, offset, i;
1121 
1122     /* detect adts header or adif header.
1123      * The ADIF header is 4 bytes, that should be OK. The ADTS header, on
1124      * the other hand, is 14 bits only, so we require one valid frame with
1125      * again a valid syncpoint on the next one (28 bits) for certainty. We
1126      * require 4 kB, which is quite a lot, since frames are generally 200-400
1127      * bytes.
1128      * LOAS has 2 possible syncwords, which are 11 bits and 16 bits long.
1129      * The following stream syntax depends on which one is found.
1130      */
1131     if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 6)))
1132       break;
1133 
1134     snc = GST_READ_UINT16_BE (c.data);
1135     if (G_UNLIKELY ((snc &amp; 0xfff6) == 0xfff0)) {
1136       /* ADTS header - find frame length */
1137       GST_DEBUG (&quot;Found one ADTS syncpoint at offset 0x%&quot; G_GINT64_MODIFIER
</pre>
<hr />
<pre>
1184             &quot;framed&quot;, G_TYPE_BOOLEAN, FALSE,
1185             &quot;mpegversion&quot;, G_TYPE_INT, mpegversion,
1186             &quot;stream-format&quot;, G_TYPE_STRING, &quot;adts&quot;, NULL);
1187 
1188         gst_codec_utils_aac_caps_set_level_and_profile (caps, audio_config, 2);
1189 
1190         /* add rate and number of channels if we can */
1191         if (channel_config != 0 &amp;&amp; channel_config &lt;= 7) {
1192           const guint channels_map[] = { 0, 1, 2, 3, 4, 5, 6, 8 };
1193 
1194           gst_caps_set_simple (caps, &quot;channels&quot;, G_TYPE_INT,
1195               channels_map[channel_config], &quot;rate&quot;, G_TYPE_INT, rate, NULL);
1196         }
1197 
1198         /* length of the second ADTS frame */
1199         len = ((c.data[offset + 3] &amp; 0x03) &lt;&lt; 11) |
1200             (c.data[offset + 4] &lt;&lt; 3) | ((c.data[offset + 5] &amp; 0xe0) &gt;&gt; 5);
1201 
1202         if (len == 0 || !data_scan_ctx_ensure_data (tf, &amp;c, offset + len + 6)) {
1203           GST_DEBUG (&quot;Wrong sync or next frame not within reach, len=%u&quot;, len);
<span class="line-modified">1204           gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, caps);</span>
1205         } else {
1206           offset += len;
1207           /* find more aac sync to select correctly */
1208           /* check if there&#39;s a third/fourth/fifth/sixth ADTS frame, if there is a sixth frame, set probability to maximum:100% */
1209           for (i = 3; i &lt;= 6; i++) {
1210             len = ((c.data[offset + 3] &amp; 0x03) &lt;&lt; 11) |
1211                 (c.data[offset + 4] &lt;&lt; 3) | ((c.data[offset + 5] &amp; 0xe0) &gt;&gt; 5);
1212             if (len == 0
1213                 || !data_scan_ctx_ensure_data (tf, &amp;c, offset + len + 6)) {
1214               GST_DEBUG (&quot;Wrong sync or next frame not within reach, len=%u&quot;,
1215                   len);
1216               break;
1217             }
1218             snc = GST_READ_UINT16_BE (c.data + offset);
1219             if ((snc &amp; 0xfff6) == 0xfff0) {
1220               GST_DEBUG (&quot;Find %und Sync..probability is %u &quot;, i,
1221                   GST_TYPE_FIND_LIKELY + 5 * (i - 2));
1222               offset += len;
1223             } else {
1224               break;
</pre>
<hr />
<pre>
1236       gint count;
1237 
1238       /* LOAS frame */
1239       GST_INFO (&quot;Possible LOAS syncword at offset 0x%&quot; G_GINT64_MODIFIER
1240           &quot;x, scanning for more frames...&quot;, c.offset);
1241 
1242       if (snc == 0x4de1)
1243         count = aac_type_find_scan_loas_frames_ep (tf, &amp;c, 20);
1244       else
1245         count = aac_type_find_scan_loas_frames (tf, &amp;c, 20);
1246 
1247       if (count &gt;= 3 &amp;&amp; count &gt; best_count) {
1248         gst_caps_replace (&amp;best_caps, NULL);
1249         best_caps = gst_caps_new_simple (&quot;audio/mpeg&quot;,
1250             &quot;framed&quot;, G_TYPE_BOOLEAN, FALSE,
1251             &quot;mpegversion&quot;, G_TYPE_INT, 4,
1252             &quot;stream-format&quot;, G_TYPE_STRING, &quot;loas&quot;, NULL);
1253         best_count = count;
1254         best_probability = GST_TYPE_FIND_POSSIBLE - 10 + count * 3;
1255         if (best_probability &gt;= GST_TYPE_FIND_LIKELY)
<span class="line-modified">1256           break;</span>
1257       }
1258     } else if (!memcmp (c.data, &quot;ADIF&quot;, 4)) {
1259       /* ADIF header */
1260       gst_type_find_suggest_simple (tf, GST_TYPE_FIND_LIKELY, &quot;audio/mpeg&quot;,
1261           &quot;framed&quot;, G_TYPE_BOOLEAN, FALSE, &quot;mpegversion&quot;, G_TYPE_INT, 4,
1262           &quot;stream-format&quot;, G_TYPE_STRING, &quot;adif&quot;, NULL);
1263       break;
1264     }
1265 
1266   next:
1267 
1268     data_scan_ctx_advance (tf, &amp;c, 1);
1269   }
1270 
1271   if (best_probability &gt; GST_TYPE_FIND_NONE) {
1272     gst_type_find_suggest (tf, best_probability, best_caps);
1273     gst_caps_unref (best_caps);
1274   }
1275 }
1276 
</pre>
<hr />
<pre>
1599       GST_LOG (&quot;detected audio/mpeg only in the middle (p=%u)&quot;, mid_prob);
1600       layer = mid_layer;
1601       prob = mid_prob;
1602       goto suggest;
1603     }
1604 
1605     if (layer != mid_layer) {
1606       GST_WARNING (&quot;audio/mpeg layer discrepancy: %u vs. %u&quot;, layer, mid_layer);
1607       return;                   /* FIXME: or should we just go with the one in the middle? */
1608     }
1609 
1610     /* detected mpeg audio both in middle of the file and at the start */
1611     prob = (prob + mid_prob) / 2;
1612     goto suggest;
1613   }
1614 
1615   /* a valid header right at the start makes it more likely
1616    * that this is actually plain mpeg-1 audio */
1617   if (prob &gt; 0) {
1618     data = gst_type_find_peek (tf, 0, 4);       /* use min. frame size? */
<span class="line-modified">1619     if (data &amp;&amp; mp3_type_frame_length_from_header (GST_READ_UINT32_BE (data),</span>
<span class="line-modified">1620             &amp;layer, NULL, NULL, NULL, NULL, 0) != 0) {</span>
1621       prob = MIN (prob + 10, GST_TYPE_FIND_MAXIMUM);
<span class="line-modified">1622     }</span>
1623   }
1624 
1625   if (prob &gt; 0)
1626     goto suggest;
1627 
1628   return;
1629 
1630 suggest:
1631   {
1632     g_return_if_fail (layer &gt;= 1 &amp;&amp; layer &lt;= 3);
1633 
1634     gst_type_find_suggest_simple (tf, prob, &quot;audio/mpeg&quot;,
1635         &quot;mpegversion&quot;, G_TYPE_INT, 1, &quot;layer&quot;, G_TYPE_INT, layer,
1636         &quot;parsed&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
1637   }
1638 }
1639 
1640 /*** audio/x-musepack ***/
1641 
1642 static GstStaticCaps musepack_caps =
</pre>
<hr />
<pre>
2471 static void
2472 mpeg_ts_type_find (GstTypeFind * tf, gpointer unused)
2473 {
2474   /* TS packet sizes to test: normal, DVHS packet size and
2475    * FEC with 16 or 20 byte codes packet size. */
2476   const gint pack_sizes[] = { 188, 192, 204, 208 };
2477   const guint8 *data = NULL;
2478   guint size = 0;
2479   guint64 skipped = 0;
2480 
2481   while (skipped &lt; GST_MPEGTS_TYPEFIND_SCAN_LENGTH) {
2482     if (size &lt; MPEGTS_HDR_SIZE) {
2483       data = gst_type_find_peek (tf, skipped, GST_MPEGTS_TYPEFIND_SYNC_SIZE);
2484       if (!data)
2485         break;
2486       size = GST_MPEGTS_TYPEFIND_SYNC_SIZE;
2487     }
2488 
2489     /* Have at least MPEGTS_HDR_SIZE bytes at this point */
2490     if (IS_MPEGTS_HEADER (data)) {
<span class="line-modified">2491       gsize p;</span>
2492 
2493       GST_LOG (&quot;possible mpeg-ts sync at offset %&quot; G_GUINT64_FORMAT, skipped);
2494 
2495       for (p = 0; p &lt; G_N_ELEMENTS (pack_sizes); p++) {
2496         gint found;
2497 
2498         /* Probe ahead at size pack_sizes[p] */
2499         found = mpeg_ts_probe_headers (tf, skipped, pack_sizes[p]);
2500         if (found &gt;= GST_MPEGTS_TYPEFIND_MIN_HEADERS) {
2501           gint probability;
2502 
2503           /* found at least 4 headers. 10 headers = MAXIMUM probability.
2504            * Arbitrarily, I assigned 10% probability for each header we
2505            * found, 40% -&gt; 100% */
2506           probability = MIN (10 * found, GST_TYPE_FIND_MAXIMUM);
2507 
2508           gst_type_find_suggest_simple (tf, probability, &quot;video/mpegts&quot;,
2509               &quot;systemstream&quot;, G_TYPE_BOOLEAN, TRUE,
2510               &quot;packetsize&quot;, G_TYPE_INT, pack_sizes[p], NULL);
2511           return;
</pre>
<hr />
<pre>
2693       break;
2694 
2695     /* Find the picture start code */
2696     data = (data &lt;&lt; 8) + c.data[0];
2697     psc = data &amp; G_GUINT64_CONSTANT (0xfffffc0000);
2698     if (psc == 0x800000) {
2699       /* Found PSC */
2700       /* PTYPE */
2701       ptype = (data &amp; 0x3fc) &gt;&gt; 2;
2702       /* Source Format */
2703       format = ptype &amp; 0x07;
2704 
2705       /* Now that we have a Valid PSC, check if we also have a valid PTYPE and
2706          the Source Format, which should range between 1 and 5 */
2707       if (((ptype &gt;&gt; 6) == 0x2) &amp;&amp; (format &gt; 0 &amp;&amp; format &lt; 6)) {
2708         pc_type = data &amp; 0x02;
2709         pb_mode = c.data[1] &amp; 0x20 &gt;&gt; 4;
2710         if (!pc_type &amp;&amp; pb_mode)
2711           bad++;
2712         else
<span class="line-modified">2713           good++;</span>
2714       } else
2715         bad++;
2716 
2717       /* FIXME: maybe bail out early if we get mostly bad syncs ? */
2718     }
2719 
2720     data_scan_ctx_advance (tf, &amp;c, 1);
2721   }
2722 
2723   GST_LOG (&quot;good: %d, bad: %d&quot;, good, bad);
2724 
2725   if (good &gt; 2 * bad)
2726     gst_type_find_suggest (tf, GST_TYPE_FIND_POSSIBLE, H263_VIDEO_CAPS);
2727 
2728   return;
2729 }
2730 
2731 /*** video/x-h264 H264 elementary video stream ***/
2732 
2733 static GstStaticCaps h264_video_caps =
</pre>
<hr />
<pre>
2774           bad++;
2775         } else {
2776           if (nut == 7)
2777             seen_sps = TRUE;
2778           else if (nut == 8)
2779             seen_pps = TRUE;
2780           else if (nut == 5)
2781             seen_idr = TRUE;
2782 
2783           good++;
2784         }
2785       } else if (nut &gt;= 14 &amp;&amp; nut &lt;= 33) {
2786         if (nut == 15) {
2787           seen_ssps = TRUE;
2788           good++;
2789         } else if (nut == 14 || nut == 20) {
2790           /* Sometimes we see NAL 14 or 20 without SSPS
2791            * if dropped into the middle of a stream -
2792            * just ignore those (don&#39;t add to bad count) */
2793           if (seen_ssps)
<span class="line-modified">2794             good++;</span>
2795         } else {
<span class="line-modified">2796           /* reserved */</span>
<span class="line-modified">2797           /* Theoretically these are good, since if they exist in the</span>
<span class="line-modified">2798              stream it merely means that a newer backwards-compatible</span>
<span class="line-modified">2799              h.264 stream.  But we should be identifying that separately. */</span>
<span class="line-modified">2800           bad++;</span>
2801         }
2802       } else {
2803         /* unspecified, application specific */
2804         /* don&#39;t consider these bad */
2805       }
2806 
2807       GST_LOG (&quot;good:%d, bad:%d, pps:%d, sps:%d, idr:%d ssps:%d&quot;, good, bad,
2808           seen_pps, seen_sps, seen_idr, seen_ssps);
2809 
2810       if (seen_sps &amp;&amp; seen_pps &amp;&amp; seen_idr &amp;&amp; good &gt;= 10 &amp;&amp; bad &lt; 4) {
2811         gst_type_find_suggest (tf, GST_TYPE_FIND_LIKELY, H264_VIDEO_CAPS);
2812         return;
2813       }
2814 
2815       data_scan_ctx_advance (tf, &amp;c, 4);
2816     }
2817     data_scan_ctx_advance (tf, &amp;c, 1);
2818   }
2819 
2820   GST_LOG (&quot;good:%d, bad:%d, pps:%d, sps:%d, idr:%d ssps=%d&quot;, good, bad,
</pre>
<hr />
<pre>
2924     &quot;systemstream = (boolean) false&quot;);
2925 #define MPEG_VIDEO_CAPS gst_static_caps_get(&amp;mpeg_video_caps)
2926 
2927 /*
2928  * Idea is the same as MPEG system stream typefinding: We check each
2929  * byte of the stream to see if - from that point on - the stream
2930  * matches a predefined set of marker bits as defined in the MPEG
2931  * video specs.
2932  *
2933  * I&#39;m sure someone will do a chance calculation here too.
2934  */
2935 
2936 static void
2937 mpeg_video_stream_type_find (GstTypeFind * tf, gpointer unused)
2938 {
2939   DataScanCtx c = { 0, NULL, 0 };
2940   gboolean seen_seq_at_0 = FALSE;
2941   gboolean seen_seq = FALSE;
2942   gboolean seen_gop = FALSE;
2943   guint64 last_pic_offset = 0;
<span class="line-modified">2944   gint num_pic_headers = 0;</span>
2945   gint found = 0;
2946 
2947   while (c.offset &lt; GST_MPEGVID_TYPEFIND_TRY_SYNC) {
2948     if (found &gt;= GST_MPEGVID_TYPEFIND_TRY_PICTURES)
2949       break;
2950 
2951     if (!data_scan_ctx_ensure_data (tf, &amp;c, 5))
2952       break;
2953 
2954     if (!IS_MPEG_HEADER (c.data))
2955       goto next;
2956 
2957     /* a pack header indicates that this isn&#39;t an elementary stream */
2958     if (c.data[3] == 0xBA &amp;&amp; mpeg_sys_is_valid_pack (tf, c.data, c.size, NULL))
2959       return;
2960 
2961     /* do we have a sequence header? */
2962     if (c.data[3] == 0xB3) {
2963       seen_seq_at_0 = seen_seq_at_0 || (c.offset == 0);
2964       seen_seq = TRUE;
</pre>
<hr />
<pre>
3123   switch (GST_MAKE_FOURCC (data[0], data[1], data[2], 0)) {
3124     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;g&#39;, &#39;g&#39;, 0):
3125       return &quot;general&quot;;
3126     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;g&#39;, &#39;p&#39;, 0):
3127       return &quot;basic&quot;;
3128     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;g&#39;, &#39;s&#39;, 0):
3129       return &quot;streaming-server&quot;;
3130     case GST_MAKE_FOURCC (&#39;3&#39;, &#39;g&#39;, &#39;r&#39;, 0):
3131       return &quot;progressive-download&quot;;
3132     default:
3133       break;
3134   }
3135   return NULL;
3136 }
3137 
3138 static void
3139 q3gp_type_find (GstTypeFind * tf, gpointer unused)
3140 {
3141   const gchar *profile;
3142   guint32 ftyp_size = 0;
<span class="line-modified">3143   guint32 offset = 0;</span>
3144   const guint8 *data = NULL;
3145 
3146   if ((data = gst_type_find_peek (tf, 0, 12)) == NULL) {
3147     return;
3148   }
3149 
3150   data += 4;
3151   if (memcmp (data, &quot;ftyp&quot;, 4) != 0) {
3152     return;
3153   }
3154 
3155   /* check major brand */
3156   data += 4;
3157   if ((profile = q3gp_type_find_get_profile (data))) {
3158     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,
3159         &quot;application/x-3gp&quot;, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);
3160     return;
3161   }
3162 
3163   /* check compatible brands */
3164   if ((data = gst_type_find_peek (tf, 0, 4)) != NULL) {
3165     ftyp_size = GST_READ_UINT32_BE (data);
3166   }
3167   if ((data = gst_type_find_peek (tf, 0, ftyp_size)) != NULL) {
3168     for (offset = 16; offset + 4 &lt; ftyp_size; offset += 4) {
3169       if ((profile = q3gp_type_find_get_profile (data + offset))) {
<span class="line-modified">3170         gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,</span>
<span class="line-modified">3171             &quot;application/x-3gp&quot;, &quot;profile&quot;, G_TYPE_STRING, profile, NULL);</span>
<span class="line-modified">3172         return;</span>
<span class="line-added">3173       }</span>
3174     }
3175   }

3176 
3177   return;
3178 
3179 }
3180 
3181 /*** video/mj2 and image/jp2 ***/
3182 static GstStaticCaps mj2_caps = GST_STATIC_CAPS (&quot;video/mj2&quot;);
3183 
3184 #define MJ2_CAPS gst_static_caps_get(&amp;mj2_caps)
3185 
3186 static GstStaticCaps jp2_caps = GST_STATIC_CAPS (&quot;image/jp2&quot;);
3187 
3188 #define JP2_CAPS gst_static_caps_get(&amp;jp2_caps)
3189 
3190 static void
3191 jp2_type_find (GstTypeFind * tf, gpointer unused)
3192 {
3193   const guint8 *data;
3194 
3195   data = gst_type_find_peek (tf, 0, 24);
</pre>
<hr />
<pre>
3365       }
3366     }
3367     /* other box/atom types, apparently quicktime specific */
3368     else if (STRNCMP (&amp;data[4], &quot;pnot&quot;, 4) == 0 ||
3369         STRNCMP (&amp;data[4], &quot;PICT&quot;, 4) == 0 ||
3370         STRNCMP (&amp;data[4], &quot;wide&quot;, 4) == 0 ||
3371         STRNCMP (&amp;data[4], &quot;prfl&quot;, 4) == 0) {
3372       tip = GST_TYPE_FIND_MAXIMUM;
3373       break;
3374     } else {
3375       tip = 0;
3376       break;
3377     }
3378 
3379     size = GST_READ_UINT32_BE (data);
3380     if (size + offset &gt;= G_MAXINT64)
3381       break;
3382     /* check compatible brands rather than ever expaning major brands above */
3383     if ((STRNCMP (&amp;data[4], &quot;ftyp&quot;, 4) == 0) &amp;&amp; (size &gt;= 16)) {
3384       data = gst_type_find_peek (tf, offset, size);
<span class="line-modified">3385       if (data == NULL)</span>
<span class="line-modified">3386         goto done;</span>
3387       new_offset = 12;
3388       while (new_offset + 4 &lt;= size) {
3389         if (STRNCMP (&amp;data[new_offset], &quot;isom&quot;, 4) == 0 ||
3390             STRNCMP (&amp;data[new_offset], &quot;dash&quot;, 4) == 0 ||
3391             STRNCMP (&amp;data[new_offset], &quot;avc1&quot;, 4) == 0 ||
3392             STRNCMP (&amp;data[new_offset], &quot;avc3&quot;, 4) == 0 ||
3393             STRNCMP (&amp;data[new_offset], &quot;mp41&quot;, 4) == 0 ||
3394             STRNCMP (&amp;data[new_offset], &quot;mp42&quot;, 4) == 0) {
3395           tip = GST_TYPE_FIND_MAXIMUM;
3396           variant = &quot;iso&quot;;
3397           goto done;
3398         }
3399         new_offset += 4;
3400       }
3401     }
3402     if (size == 1) {
3403       const guint8 *sizedata;
3404 
3405       sizedata = gst_type_find_peek (tf, offset + 8, 8);
3406       if (sizedata == NULL)
</pre>
<hr />
<pre>
3602     if (memcmp (data, &quot;PSM&quot;, 3) == 0) {
3603       unsigned char fbyte = data[3];
3604       if ((fbyte == &#39; &#39;) || (fbyte == 254)) {
3605         mod_type = &quot;psm&quot;;
3606         probability = GST_TYPE_FIND_MAXIMUM;
3607         goto suggest_audio_mod_caps;
3608       }
3609     }
3610     /* 669 */
3611     if ((memcmp (data, &quot;if&quot;, 2) == 0) || (memcmp (data, &quot;JN&quot;, 2) == 0)) {
3612       mod_type = &quot;669&quot;;
3613       probability = GST_TYPE_FIND_LIKELY;
3614       goto suggest_audio_mod_caps;
3615     }
3616     /* AMF */
3617     if ((memcmp (data, &quot;AMF&quot;, 3) == 0) &amp;&amp; (data[3] &gt; 10) &amp;&amp; (data[3] &lt; 14)) {
3618       mod_type = &quot;dsmi-amf&quot;;
3619       probability = GST_TYPE_FIND_MAXIMUM;
3620       goto suggest_audio_mod_caps;
3621     }
<span class="line-modified">3622     /* IT */</span>
3623     if (memcmp (data, &quot;IMPM&quot;, 4) == 0) {
3624       mod_type = &quot;it&quot;;
3625       probability = GST_TYPE_FIND_MAXIMUM;
3626       goto suggest_audio_mod_caps;
3627     }
3628     /* DBM (DigiBooster Pro) */
3629     if (memcmp (data, &quot;DBM0&quot;, 4) == 0) {
3630       mod_type = &quot;dbm&quot;;
3631       probability = GST_TYPE_FIND_MAXIMUM;
3632       goto suggest_audio_mod_caps;
3633     }
3634     /* MDL (DigiTrakker) */
3635     if (memcmp (data, &quot;DMDL&quot;, 4) == 0) {
3636       mod_type = &quot;mdl&quot;;
3637       probability = GST_TYPE_FIND_MAXIMUM;
3638       goto suggest_audio_mod_caps;
3639     }
3640     /* MT2 (MadTracker 2.0) */
3641     if (memcmp (data, &quot;MT20&quot;, 4) == 0) {
3642       mod_type = &quot;mt2&quot;;
3643       probability = GST_TYPE_FIND_MAXIMUM;
3644       goto suggest_audio_mod_caps;
3645     }
3646     /* DMF (X-Tracker) */
3647     if (memcmp (data, &quot;DDMF&quot;, 4) == 0) {
3648       mod_type = &quot;dmf&quot;;
3649       probability = GST_TYPE_FIND_MAXIMUM;
3650       goto suggest_audio_mod_caps;
3651     }
<span class="line-modified">3652     /* MED */</span>
3653     if ((memcmp (data, &quot;MMD0&quot;, 4) == 0) || (memcmp (data, &quot;MMD1&quot;, 4) == 0)) {
3654       mod_type = &quot;med&quot;;
3655       probability = GST_TYPE_FIND_MAXIMUM;
3656       goto suggest_audio_mod_caps;
3657     }
<span class="line-modified">3658     /* MTM */</span>
3659     if (memcmp (data, &quot;MTM&quot;, 3) == 0) {
3660       mod_type = &quot;mtm&quot;;
3661       probability = GST_TYPE_FIND_MAXIMUM;
3662       goto suggest_audio_mod_caps;
3663     }
3664     /* DSM */
3665     if (memcmp (data, &quot;RIFF&quot;, 4) == 0) {
3666       const guint8 *data2 = gst_type_find_peek (tf, 8, 4);
3667 
3668       if (data2) {
3669         if (memcmp (data2, &quot;DSMF&quot;, 4) == 0) {
3670           mod_type = &quot;dsm&quot;;
3671           probability = GST_TYPE_FIND_MAXIMUM;
3672           goto suggest_audio_mod_caps;
3673         }
3674       }
3675     }
3676     /* FAR (Farandole) */
3677     if (memcmp (data, &quot;FAR\xFE&quot;, 4) == 0) {
3678       mod_type = &quot;far&quot;;
</pre>
<hr />
<pre>
3701       const guint8 *data2 = gst_type_find_peek (tf, 71, 4);
3702 
3703       if (data2) {
3704         if (memcmp (data2, &quot;GMFS&quot;, 4) == 0) {
3705           mod_type = &quot;gdm&quot;;
3706           probability = GST_TYPE_FIND_MAXIMUM;
3707           goto suggest_audio_mod_caps;
3708         }
3709         /* otherwise do not suggest anything */
3710       } else {
3711         mod_type = &quot;gdm&quot;;
3712         probability = GST_TYPE_FIND_LIKELY;
3713         goto suggest_audio_mod_caps;
3714       }
3715     }
3716     /* UMX */
3717     if (memcmp (data, &quot;\xC1\x83\x2A\x9E&quot;, 4) == 0) {
3718       mod_type = &quot;umx&quot;;
3719       probability = GST_TYPE_FIND_POSSIBLE;
3720       goto suggest_audio_mod_caps;
<span class="line-modified">3721     }</span>
3722   }
3723   /* FAR (Farandole) (secondary detection) */
3724   if ((data = gst_type_find_peek (tf, 44, 3)) != NULL) {
3725     if (memcmp (data, &quot;\x0D\x0A\x1A&quot;, 3) == 0) {
3726       mod_type = &quot;far&quot;;
3727       probability = GST_TYPE_FIND_POSSIBLE;
3728       goto suggest_audio_mod_caps;
3729     }
3730   }
3731   /* IMF */
3732   if ((data = gst_type_find_peek (tf, 60, 4)) != NULL) {
3733     if (memcmp (data, &quot;IM10&quot;, 4) == 0) {
3734       mod_type = &quot;imf&quot;;
3735       probability = GST_TYPE_FIND_MAXIMUM;
3736       goto suggest_audio_mod_caps;
3737     }
3738   }
3739   /* S3M */
3740   if ((data = gst_type_find_peek (tf, 44, 4)) != NULL) {
3741     if (memcmp (data, &quot;SCRM&quot;, 4) == 0) {
</pre>
<hr />
<pre>
3815 GST_STATIC_CAPS (&quot;application/vnd.ms-sstr+xml&quot;);
3816 #define MSS_MANIFEST_CAPS (gst_static_caps_get(&amp;mss_manifest_caps))
3817 static void
3818 mss_manifest_type_find (GstTypeFind * tf, gpointer unused)
3819 {
3820   gunichar2 utf16_ne[512];
3821   const guint8 *data;
3822   guint data_endianness = 0;
3823   glong n_read = 0, size = 0;
3824   guint length;
3825   gchar *utf8;
3826   gboolean utf8_bom_detected = FALSE;
3827 
3828   if (xml_check_first_element (tf, &quot;SmoothStreamingMedia&quot;, 20, TRUE)) {
3829     gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MSS_MANIFEST_CAPS);
3830     return;
3831   }
3832 
3833   length = gst_type_find_get_length (tf);
3834 
<span class="line-modified">3835   /* try detecting the charset */</span>
3836   data = gst_type_find_peek (tf, 0, 3);
3837 
<span class="line-modified">3838   if (data == NULL)</span>
<span class="line-modified">3839     return;</span>
3840 
<span class="line-modified">3841   /* look for a possible BOM */</span>
3842   if (data[0] == 0xEF &amp;&amp; data[1] == 0xBB &amp;&amp; data[2] == 0xBF)
3843     utf8_bom_detected = TRUE;
3844   else if (data[0] == 0xFF &amp;&amp; data[1] == 0xFE)
3845     data_endianness = G_LITTLE_ENDIAN;
3846   else if (data[0] == 0xFE &amp;&amp; data[1] == 0xFF)
3847     data_endianness = G_BIG_ENDIAN;
3848   else
3849     return;
3850 
<span class="line-modified">3851   /* try a default that should be enough */</span>
<span class="line-modified">3852   if (length == 0)</span>
<span class="line-modified">3853     length = 512;</span>
3854   else if (length &lt; 64)
3855     return;
3856   else                          /* the first few bytes should be enough */
3857     length = MIN (1024, length);
3858 
<span class="line-modified">3859   data = gst_type_find_peek (tf, 0, length);</span>
3860 
3861   if (data == NULL)
3862     return;
3863 
<span class="line-modified">3864   /* skip the BOM */</span>
<span class="line-modified">3865   data += 2;</span>
<span class="line-modified">3866   length -= 2;</span>
3867 
3868   if (utf8_bom_detected) {
3869     /* skip last byte of the BOM */
3870     data++;
3871     length--;
3872 
3873     if (xml_check_first_element_from_data (data, length,
<span class="line-modified">3874             &quot;SmoothStreamingMedia&quot;, 20, TRUE))</span>
3875       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MSS_MANIFEST_CAPS);
3876   } else {
3877     length = GST_ROUND_DOWN_2 (length);
3878 
3879     /* convert to native endian UTF-16 */
3880     mss_manifest_load_utf16 (utf16_ne, data, length, data_endianness);
3881 
3882     /* and now convert to UTF-8 */
3883     utf8 = g_utf16_to_utf8 (utf16_ne, length / 2, &amp;n_read, &amp;size, NULL);
3884     if (utf8 != NULL &amp;&amp; n_read &gt; 0) {
3885       if (xml_check_first_element_from_data ((const guint8 *) utf8, size,
3886               &quot;SmoothStreamingMedia&quot;, 20, TRUE))
3887         gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, MSS_MANIFEST_CAPS);



3888     }
<span class="line-added">3889     g_free (utf8);</span>
<span class="line-added">3890   }</span>
<span class="line-added">3891 }</span>
3892 
3893 /*** image/jpeg ***/
3894 
3895 #define JPEG_MARKER_IS_START_OF_FRAME(x) \
3896     ((x)&gt;=0xc0 &amp;&amp; (x) &lt;= 0xcf &amp;&amp; (x)!=0xc4 &amp;&amp; (x)!=0xc8 &amp;&amp; (x)!=0xcc)
3897 
3898 static GstStaticCaps jpeg_caps = GST_STATIC_CAPS (&quot;image/jpeg&quot;);
3899 
3900 #define JPEG_CAPS (gst_static_caps_get(&amp;jpeg_caps))
3901 static void
3902 jpeg_type_find (GstTypeFind * tf, gpointer unused)
3903 {
3904   GstTypeFindProbability prob = GST_TYPE_FIND_POSSIBLE;
3905   DataScanCtx c = { 0, NULL, 0 };
3906   GstCaps *caps;
3907   guint num_markers;
3908 
3909   if (G_UNLIKELY (!data_scan_ctx_ensure_data (tf, &amp;c, 2)))
3910     return;
3911 
</pre>
<hr />
<pre>
4362   data_scan_ctx_advance (tf, c, 1 + len);
4363 
4364   /* undefined/unknown size? (all bits 1) */
4365   if (*size == mask) {
4366     /* allow unknown size for SEGMENT chunk, bail out otherwise */
4367     if (*id == MATROSKA_SEGMENT)
4368       *size = G_MAXUINT64;
4369     else
4370       return 0;
4371   }
4372 
4373   return id_len + (1 + len);
4374 }
4375 
4376 static gboolean
4377 ebml_parse_chunk (GstTypeFind * tf, DataScanCtx * ctx, guint32 chunk_id,
4378     guint chunk_size, GstMatroskaInfo * info, guint depth)
4379 {                               /* FIXME: make sure input size is clipped to 32 bit */
4380   static const gchar SPACES[] = &quot;                &quot;;
4381   DataScanCtx c = *ctx;
<span class="line-modified">4382   guint64 element_size = 0;</span>
4383   guint32 id, hdr_len;
4384 
4385   if (depth &gt;= 8)               /* keep SPACES large enough for depth */
4386     return FALSE;
4387 
4388   while (chunk_size &gt; 0) {
4389     if (c.offset &gt; EBML_MAX_LEN || !data_scan_ctx_ensure_data (tf, &amp;c, 64))
<span class="line-modified">4390       return FALSE;</span>
4391 
4392     hdr_len = ebml_read_chunk_header (tf, &amp;c, chunk_size, &amp;id, &amp;element_size);
4393     if (hdr_len == 0)
<span class="line-modified">4394       return FALSE;</span>
4395 
4396     g_assert (hdr_len &lt;= chunk_size);
4397     chunk_size -= hdr_len;
4398 
4399     if (element_size &gt; chunk_size)
<span class="line-modified">4400       return FALSE;</span>
4401 
4402     GST_DEBUG (&quot;%s %08x, size %&quot; G_GUINT64_FORMAT &quot; / %&quot; G_GUINT64_FORMAT,
4403         SPACES + sizeof (SPACES) - 1 - (2 * depth), id, element_size,
4404         hdr_len + element_size);
4405 
<span class="line-added">4406     if (element_size &gt;= G_MAXUINT32) {</span>
<span class="line-added">4407       GST_DEBUG (&quot;Chunk too big for typefinding&quot;);</span>
<span class="line-added">4408       return FALSE;</span>
<span class="line-added">4409     }</span>
<span class="line-added">4410 </span>
4411     if (!data_scan_ctx_ensure_data (tf, &amp;c, element_size)) {
4412       GST_DEBUG (&quot;not enough data&quot;);
4413       return FALSE;
4414     }
4415 
4416     switch (id) {
4417       case EBML_DOCTYPE:
4418         if (element_size &gt;= 8 &amp;&amp; memcmp (c.data, &quot;matroska&quot;, 8) == 0)
4419           info-&gt;doctype = EBML_DOCTYPE_MATROSKA;
4420         else if (element_size &gt;= 4 &amp;&amp; memcmp (c.data, &quot;webm&quot;, 4) == 0)
4421           info-&gt;doctype = EBML_DOCTYPE_WEBM;
4422         break;
4423       case MATROSKA_SEGMENT:
4424         GST_LOG (&quot;parsing segment&quot;);
4425         ebml_parse_chunk (tf, &amp;c, id, element_size, info, depth + 1);
4426         GST_LOG (&quot;parsed segment, done&quot;);
<span class="line-modified">4427         return FALSE;</span>
4428       case MATROSKA_TRACKS:
4429         GST_LOG (&quot;parsing tracks&quot;);
4430         info-&gt;tracks_ok =
4431             ebml_parse_chunk (tf, &amp;c, id, element_size, info, depth + 1);
4432         GST_LOG (&quot;parsed tracks: %s, done (after %&quot; G_GUINT64_FORMAT &quot; bytes)&quot;,
4433             info-&gt;tracks_ok ? &quot;ok&quot; : &quot;FAIL&quot;, c.offset + element_size);
4434         return FALSE;
4435       case MATROSKA_TRACK_ENTRY:
4436         GST_LOG (&quot;parsing track entry&quot;);
4437         if (!ebml_parse_chunk (tf, &amp;c, id, element_size, info, depth + 1))
4438           return FALSE;
4439         break;
4440       case MATROSKA_TRACK_TYPE:{
4441         guint type = 0, i;
4442 
4443         /* is supposed to always be 1-byte, but not everyone&#39;s following that */
4444         for (i = 0; i &lt; element_size; ++i)
4445           type = (type &lt;&lt; 8) | c.data[i];
4446 
4447         GST_DEBUG (&quot;%s   track type %u&quot;,
</pre>
<hr />
<pre>
5244 
5245 /* NOTE: we cannot replace this function with TYPE_FIND_REGISTER_START_WITH,
5246  * as it is only possible to register one typefind factory per &#39;name&#39;
5247  * (which is in this case the caps), and the first one would be replaced by
5248  * the second one. */
5249 static GstStaticCaps dirac_caps = GST_STATIC_CAPS (&quot;video/x-dirac&quot;);
5250 
5251 #define DIRAC_CAPS (gst_static_caps_get(&amp;dirac_caps))
5252 static void
5253 dirac_type_find (GstTypeFind * tf, gpointer unused)
5254 {
5255   const guint8 *data = gst_type_find_peek (tf, 0, 8);
5256 
5257   if (data) {
5258     if (memcmp (data, &quot;BBCD&quot;, 4) == 0 || memcmp (data, &quot;KW-DIRAC&quot;, 8) == 0) {
5259       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, DIRAC_CAPS);
5260     }
5261   }
5262 }
5263 
<span class="line-added">5264 /*** audio/x-tap-tap ***/</span>
<span class="line-added">5265 </span>
<span class="line-added">5266 /* NOTE: we cannot replace this function with TYPE_FIND_REGISTER_START_WITH,</span>
<span class="line-added">5267  * as it is only possible to register one typefind factory per &#39;name&#39;</span>
<span class="line-added">5268  * (which is in this case the caps), and the first one would be replaced by</span>
<span class="line-added">5269  * the second one. */</span>
<span class="line-added">5270 static GstStaticCaps tap_caps = GST_STATIC_CAPS (&quot;audio/x-tap-tap&quot;);</span>
<span class="line-added">5271 </span>
<span class="line-added">5272 #define TAP_CAPS (gst_static_caps_get(&amp;tap_caps))</span>
<span class="line-added">5273 static void</span>
<span class="line-added">5274 tap_type_find (GstTypeFind * tf, gpointer unused)</span>
<span class="line-added">5275 {</span>
<span class="line-added">5276   const guint8 *data = gst_type_find_peek (tf, 0, 16);</span>
<span class="line-added">5277 </span>
<span class="line-added">5278   if (data) {</span>
<span class="line-added">5279     if (memcmp (data, &quot;C64-TAPE-RAW&quot;, 12) == 0</span>
<span class="line-added">5280         || memcmp (data, &quot;C16-TAPE-RAW&quot;, 12) == 0) {</span>
<span class="line-added">5281       gst_type_find_suggest (tf, GST_TYPE_FIND_MAXIMUM, TAP_CAPS);</span>
<span class="line-added">5282     }</span>
<span class="line-added">5283   }</span>
<span class="line-added">5284 }</span>
<span class="line-added">5285 </span>
5286 /*** video/vivo ***/
5287 
5288 static GstStaticCaps vivo_caps = GST_STATIC_CAPS (&quot;video/vivo&quot;);
5289 
5290 #define VIVO_CAPS gst_static_caps_get(&amp;vivo_caps)
5291 
5292 static void
5293 vivo_type_find (GstTypeFind * tf, gpointer unused)
5294 {
5295   static const guint8 vivo_marker[] = { &#39;V&#39;, &#39;e&#39;, &#39;r&#39;, &#39;s&#39;, &#39;i&#39;, &#39;o&#39;, &#39;n&#39;,
5296     &#39;:&#39;, &#39;V&#39;, &#39;i&#39;, &#39;v&#39;, &#39;o&#39;, &#39;/&#39;
5297   };
5298   const guint8 *data;
5299   guint hdr_len, pos;
5300 
5301   data = gst_type_find_peek (tf, 0, 1024);
5302   if (data == NULL || data[0] != 0x00)
5303     return;
5304 
5305   if ((data[1] &amp; 0x80)) {
</pre>
<hr />
<pre>
5643       media_type = &quot;application/x-ssa&quot;;
5644   }
5645 
5646   if (media_type == NULL) {
5647     if (strstr (str, &quot;[v4+ Styles]&quot;) || strstr (str, &quot;[V4+ Styles]&quot;))
5648       media_type = &quot;application/x-ass&quot;;
5649     else if (strstr (str, &quot;[v4 Styles]&quot;) || strstr (str, &quot;[V4 Styles]&quot;))
5650       media_type = &quot;application/x-ssa&quot;;
5651   }
5652 
5653   if (media_type != NULL) {
5654     gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,
5655         media_type, &quot;parsed&quot;, G_TYPE_BOOLEAN, FALSE, NULL);
5656   } else {
5657     GST_WARNING (&quot;could not detect SSA/ASS variant&quot;);
5658   }
5659 
5660   g_free (str);
5661 }
5662 
<span class="line-added">5663 /*** application/x-mcc ***/</span>
<span class="line-added">5664 static GstStaticCaps mcc_caps = GST_STATIC_CAPS (&quot;application/x-mcc&quot;);</span>
<span class="line-added">5665 </span>
<span class="line-added">5666 #define MCC_CAPS gst_static_caps_get(&amp;mcc_caps)</span>
<span class="line-added">5667 </span>
<span class="line-added">5668 static void</span>
<span class="line-added">5669 mcc_type_find (GstTypeFind * tf, gpointer private)</span>
<span class="line-added">5670 {</span>
<span class="line-added">5671   const guint8 *data;</span>
<span class="line-added">5672 </span>
<span class="line-added">5673   data = gst_type_find_peek (tf, 0, 31);</span>
<span class="line-added">5674 </span>
<span class="line-added">5675   if (data == NULL)</span>
<span class="line-added">5676     return;</span>
<span class="line-added">5677 </span>
<span class="line-added">5678   /* MCC files always start with this followed by the version */</span>
<span class="line-added">5679   if (memcmp (data, &quot;File Format=MacCaption_MCC V&quot;, 28) != 0 ||</span>
<span class="line-added">5680       !g_ascii_isdigit (data[28]) || data[29] != &#39;.&#39; ||</span>
<span class="line-added">5681       !g_ascii_isdigit (data[30])) {</span>
<span class="line-added">5682     return;</span>
<span class="line-added">5683   }</span>
<span class="line-added">5684 </span>
<span class="line-added">5685   gst_type_find_suggest_simple (tf, GST_TYPE_FIND_MAXIMUM,</span>
<span class="line-added">5686       &quot;application/x-mcc&quot;, &quot;version&quot;, G_TYPE_INT, data[28] - &#39;0&#39;, NULL);</span>
<span class="line-added">5687 }</span>
<span class="line-added">5688 </span>
5689 /*** video/x-pva ***/
5690 
5691 static GstStaticCaps pva_caps = GST_STATIC_CAPS (&quot;video/x-pva&quot;);
5692 
5693 #define PVA_CAPS gst_static_caps_get(&amp;pva_caps)
5694 
5695 static void
5696 pva_type_find (GstTypeFind * tf, gpointer private)
5697 {
5698   const guint8 *data;
5699 
5700   data = gst_type_find_peek (tf, 0, 5);
5701 
5702   if (data == NULL)
5703     return;
5704 
5705   if (data[0] == &#39;A&#39; &amp;&amp; data[1] == &#39;V&#39; &amp;&amp; data[2] &lt; 3 &amp;&amp; data[4] == 0x55)
5706     gst_type_find_suggest (tf, GST_TYPE_FIND_NEARLY_CERTAIN, PVA_CAPS);
5707 }
5708 
</pre>
<hr />
<pre>
5839 #ifndef GSTREAMER_LITE
5840   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-ms-asf&quot;, GST_RANK_SECONDARY,
5841       &quot;asf,wm,wma,wmv&quot;,
5842       &quot;\060\046\262\165\216\146\317\021\246\331\000\252\000\142\316\154&quot;, 16,
5843       GST_TYPE_FIND_MAXIMUM);
5844   TYPE_FIND_REGISTER (plugin, &quot;audio/x-musepack&quot;, GST_RANK_PRIMARY,
5845       musepack_type_find, &quot;mpc,mpp,mp+&quot;, MUSEPACK_CAPS, NULL, NULL);
5846   TYPE_FIND_REGISTER (plugin, &quot;audio/x-au&quot;, GST_RANK_MARGINAL,
5847       au_type_find, &quot;au,snd&quot;, AU_CAPS, NULL, NULL);
5848   TYPE_FIND_REGISTER_RIFF (plugin, &quot;video/x-msvideo&quot;, GST_RANK_PRIMARY,
5849       &quot;avi&quot;, &quot;AVI &quot;);
5850   TYPE_FIND_REGISTER_RIFF (plugin, &quot;audio/qcelp&quot;, GST_RANK_PRIMARY,
5851       &quot;qcp&quot;, &quot;QLCM&quot;);
5852   TYPE_FIND_REGISTER_RIFF (plugin, &quot;video/x-cdxa&quot;, GST_RANK_PRIMARY,
5853       &quot;dat&quot;, &quot;CDXA&quot;);
5854   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-vcd&quot;, GST_RANK_PRIMARY,
5855       &quot;dat&quot;, &quot;\000\377\377\377\377\377\377\377\377\377\377\000&quot;, 12,
5856       GST_TYPE_FIND_MAXIMUM);
5857   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-imelody&quot;, GST_RANK_PRIMARY,
5858       &quot;imy,ime,imelody&quot;, &quot;BEGIN:IMELODY&quot;, 13, GST_TYPE_FIND_MAXIMUM);
<span class="line-added">5859   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-scc&quot;, GST_RANK_PRIMARY,</span>
<span class="line-added">5860       &quot;scc&quot;, &quot;Scenarist_SCC V1.0&quot;, 18, GST_TYPE_FIND_MAXIMUM);</span>
<span class="line-added">5861   TYPE_FIND_REGISTER (plugin, &quot;application/x-mcc&quot;, GST_RANK_PRIMARY,</span>
<span class="line-added">5862       mcc_type_find, &quot;mcc&quot;, MCC_CAPS, NULL, NULL);</span>
<span class="line-added">5863 </span>
5864 #if 0
5865   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-smoke&quot;, GST_RANK_PRIMARY,
5866       NULL, &quot;\x80smoke\x00\x01\x00&quot;, 6, GST_TYPE_FIND_MAXIMUM);
5867 #endif
5868   TYPE_FIND_REGISTER (plugin, &quot;audio/midi&quot;, GST_RANK_PRIMARY, mid_type_find,
5869       &quot;mid,midi&quot;, MID_CAPS, NULL, NULL);
5870   TYPE_FIND_REGISTER_RIFF (plugin, &quot;audio/riff-midi&quot;, GST_RANK_PRIMARY,
5871       &quot;mid,midi&quot;, &quot;RMID&quot;);
5872   TYPE_FIND_REGISTER (plugin, &quot;audio/mobile-xmf&quot;, GST_RANK_PRIMARY,
5873       mxmf_type_find, &quot;mxmf&quot;, MXMF_CAPS, NULL, NULL);
5874   TYPE_FIND_REGISTER (plugin, &quot;video/x-fli&quot;, GST_RANK_MARGINAL, flx_type_find,
5875       &quot;flc,fli&quot;, FLX_CAPS, NULL, NULL);
5876   TYPE_FIND_REGISTER (plugin, &quot;application/x-id3v2&quot;, GST_RANK_PRIMARY + 103,
5877       id3v2_type_find, &quot;mp3,mp2,mp1,mpga,ogg,flac,tta&quot;, ID3_CAPS, NULL, NULL);
5878   TYPE_FIND_REGISTER (plugin, &quot;application/x-id3v1&quot;, GST_RANK_PRIMARY + 101,
5879       id3v1_type_find, &quot;mp3,mp2,mp1,mpga,ogg,flac,tta&quot;, ID3_CAPS, NULL, NULL);
5880   TYPE_FIND_REGISTER (plugin, &quot;application/x-apetag&quot;, GST_RANK_PRIMARY + 102,
5881       apetag_type_find, &quot;mp3,ape,mpc,wv&quot;, APETAG_CAPS, NULL, NULL);
5882   TYPE_FIND_REGISTER (plugin, &quot;audio/x-ttafile&quot;, GST_RANK_PRIMARY,
5883       tta_type_find, &quot;tta&quot;, TTA_CAPS, NULL, NULL);
</pre>
<hr />
<pre>
5922   TYPE_FIND_REGISTER (plugin, &quot;video/quicktime&quot;, GST_RANK_PRIMARY,
5923       qt_type_find, &quot;mov,mp4&quot;, QT_CAPS, NULL, NULL);
5924   TYPE_FIND_REGISTER (plugin, &quot;image/x-quicktime&quot;, GST_RANK_SECONDARY,
5925       qtif_type_find, &quot;qif,qtif,qti&quot;, QTIF_CAPS, NULL, NULL);
5926   TYPE_FIND_REGISTER (plugin, &quot;image/jp2&quot;, GST_RANK_PRIMARY,
5927       jp2_type_find, &quot;jp2&quot;, JP2_CAPS, NULL, NULL);
5928   TYPE_FIND_REGISTER (plugin, &quot;image/x-jpc&quot;, GST_RANK_PRIMARY,
5929       jpc_type_find, &quot;jpc,j2k&quot;, JPC_CAPS, NULL, NULL);
5930   TYPE_FIND_REGISTER (plugin, &quot;video/mj2&quot;, GST_RANK_PRIMARY,
5931       jp2_type_find, &quot;mj2&quot;, MJ2_CAPS, NULL, NULL);
5932 
5933   TYPE_FIND_REGISTER (plugin, &quot;text/html&quot;, GST_RANK_SECONDARY, html_type_find,
5934       &quot;htm,html&quot;, HTML_CAPS, NULL, NULL);
5935   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/vnd.rn-realmedia&quot;,
5936       GST_RANK_SECONDARY, &quot;ra,ram,rm,rmvb&quot;, &quot;.RMF&quot;, 4, GST_TYPE_FIND_MAXIMUM);
5937   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;application/x-pn-realaudio&quot;,
5938       GST_RANK_SECONDARY, &quot;ra,ram,rm,rmvb&quot;, &quot;.ra\375&quot;, 4,
5939       GST_TYPE_FIND_MAXIMUM);
5940   TYPE_FIND_REGISTER (plugin, &quot;application/x-shockwave-flash&quot;,
5941       GST_RANK_SECONDARY, swf_type_find, &quot;swf,swfl&quot;, SWF_CAPS, NULL, NULL);
<span class="line-added">5942   TYPE_FIND_REGISTER (plugin, &quot;application/xges&quot;,</span>
<span class="line-added">5943       GST_RANK_PRIMARY, xges_type_find, &quot;xges&quot;, XGES_CAPS, NULL, NULL);</span>
5944   TYPE_FIND_REGISTER (plugin, &quot;application/dash+xml&quot;,
5945       GST_RANK_PRIMARY, dash_mpd_type_find, &quot;mpd,MPD&quot;, DASH_CAPS, NULL, NULL);
5946   TYPE_FIND_REGISTER (plugin, &quot;application/vnd.ms-sstr+xml&quot;,
5947       GST_RANK_PRIMARY, mss_manifest_type_find, NULL, MSS_MANIFEST_CAPS, NULL,
5948       NULL);
5949 #endif // GSTREAMER_LITE
5950   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;video/x-flv&quot;, GST_RANK_SECONDARY,
5951       &quot;flv&quot;, &quot;FLV&quot;, 3, GST_TYPE_FIND_MAXIMUM);
5952 #ifndef GSTREAMER_LITE
5953   TYPE_FIND_REGISTER (plugin, &quot;text/plain&quot;, GST_RANK_MARGINAL, utf8_type_find,
5954       &quot;txt&quot;, UTF8_CAPS, NULL, NULL);
5955   TYPE_FIND_REGISTER (plugin, &quot;text/utf-16&quot;, GST_RANK_MARGINAL, utf16_type_find,
5956       &quot;txt&quot;, UTF16_CAPS, NULL, NULL);
5957   TYPE_FIND_REGISTER (plugin, &quot;text/utf-32&quot;, GST_RANK_MARGINAL, utf32_type_find,
5958       &quot;txt&quot;, UTF32_CAPS, NULL, NULL);
5959   TYPE_FIND_REGISTER (plugin, &quot;text/uri-list&quot;, GST_RANK_MARGINAL, uri_type_find,
5960       &quot;ram&quot;, URI_CAPS, NULL, NULL);
5961   TYPE_FIND_REGISTER (plugin, &quot;application/itc&quot;, GST_RANK_SECONDARY,
5962       itc_type_find, &quot;itc&quot;, ITC_CAPS, NULL, NULL);
5963   TYPE_FIND_REGISTER (plugin, &quot;application/x-hls&quot;, GST_RANK_MARGINAL,
</pre>
<hr />
<pre>
6147 #endif
6148 
6149   TYPE_FIND_REGISTER (plugin, &quot;image/x-degas&quot;, GST_RANK_MARGINAL,
6150       degas_type_find, NULL, NULL, NULL, NULL);
6151   TYPE_FIND_REGISTER (plugin, &quot;application/octet-stream&quot;, GST_RANK_MARGINAL,
6152       dvdiso_type_find, NULL, NULL, NULL, NULL);
6153 
6154   TYPE_FIND_REGISTER (plugin, &quot;application/x-ssa&quot;, GST_RANK_SECONDARY,
6155       ssa_type_find, &quot;ssa,ass&quot;, NULL, NULL, NULL);
6156 
6157   TYPE_FIND_REGISTER (plugin, &quot;video/x-pva&quot;, GST_RANK_SECONDARY,
6158       pva_type_find, &quot;pva&quot;, PVA_CAPS, NULL, NULL);
6159 
6160   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-xi&quot;, GST_RANK_SECONDARY,
6161       &quot;xi&quot;, &quot;Extended Instrument: &quot;, 21, GST_TYPE_FIND_MAXIMUM);
6162 
6163   TYPE_FIND_REGISTER (plugin, &quot;audio/audible&quot;, GST_RANK_MARGINAL,
6164       aa_type_find, &quot;aa,aax&quot;, AA_CAPS, NULL, NULL);
6165 #endif // GSTREAMER_LITE
6166 
<span class="line-added">6167   TYPE_FIND_REGISTER (plugin, &quot;audio/x-tap-tap&quot;, GST_RANK_PRIMARY,</span>
<span class="line-added">6168       tap_type_find, &quot;tap&quot;, TAP_CAPS, NULL, NULL);</span>
<span class="line-added">6169   TYPE_FIND_REGISTER_START_WITH (plugin, &quot;audio/x-tap-dmp&quot;,</span>
<span class="line-added">6170       GST_RANK_SECONDARY, &quot;dmp&quot;, &quot;DC2N-TAP-RAW&quot;, 12, GST_TYPE_FIND_LIKELY);</span>
<span class="line-added">6171 </span>
6172   return TRUE;
6173 }
6174 
6175 #ifndef GSTREAMER_LITE
6176 GST_PLUGIN_DEFINE (GST_VERSION_MAJOR,
6177     GST_VERSION_MINOR,
6178     typefindfunctions,
6179     &quot;default typefind functions&quot;,
6180     plugin_init, VERSION, GST_LICENSE, GST_PACKAGE_NAME, GST_PACKAGE_ORIGIN)
<span class="line-modified">6181 #endif // GSTREAMER_LITE</span>
</pre>
</td>
</tr>
</table>
<center><a href="../audioconvert/gstaudioconvert.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../volume/gstvolume.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>