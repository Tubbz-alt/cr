<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/video-format.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) &lt;1999&gt; Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  * Library       &lt;2002&gt; Ronald Bultje &lt;rbultje@ronald.bitfreak.net&gt;
   4  * Copyright (C) 2007 David A. Schleef &lt;ds@schleef.org&gt;
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 #ifdef HAVE_CONFIG_H
  23 #  include &quot;config.h&quot;
  24 #endif
  25 
  26 #include &lt;string.h&gt;
  27 #include &lt;stdio.h&gt;
  28 
  29 #include &quot;video-format.h&quot;
  30 #ifndef GSTREAMER_LITE
  31 #include &quot;video-orc.h&quot;
  32 #else // GSTREAMER_LITE
  33 #include &quot;video-orc-dist.h&quot;
  34 #endif // GSTREAMER_LITE
  35 
  36 #ifndef restrict
  37 #if defined(__STDC_VERSION__) &amp;&amp; __STDC_VERSION__ &gt;= 199901L
  38 /* restrict should be available */
  39 #elif defined(__GNUC__) &amp;&amp; __GNUC__ &gt;= 4
  40 #define restrict __restrict__
  41 #elif defined(_MSC_VER) &amp;&amp;  _MSC_VER &gt;= 1500
  42 #define restrict __restrict
  43 #else
  44 #define restrict                /* no op */
  45 #endif
  46 #endif
  47 
  48 /* Line conversion to AYUV */
  49 
  50 #define GET_PLANE_STRIDE(plane) (stride(plane))
  51 #define GET_PLANE_LINE(plane, line) \
  52   (gpointer)(((guint8*)(data[plane])) + stride[plane] * (line))
  53 
  54 #define GET_COMP_STRIDE(comp) \
  55   GST_VIDEO_FORMAT_INFO_STRIDE (info, stride, comp)
  56 #define GET_COMP_DATA(comp) \
  57   GST_VIDEO_FORMAT_INFO_DATA (info, data, comp)
  58 
  59 #define GET_COMP_LINE(comp, line) \
  60   (gpointer)(((guint8*)GET_COMP_DATA (comp)) + \
  61       GET_COMP_STRIDE(comp) * (line))
  62 
  63 #define GET_LINE(line)               GET_PLANE_LINE (0, line)
  64 
  65 #define GET_Y_LINE(line)             GET_COMP_LINE(GST_VIDEO_COMP_Y, line)
  66 #define GET_U_LINE(line)             GET_COMP_LINE(GST_VIDEO_COMP_U, line)
  67 #define GET_V_LINE(line)             GET_COMP_LINE(GST_VIDEO_COMP_V, line)
  68 
  69 #define GET_R_LINE(line)             GET_COMP_LINE(GST_VIDEO_COMP_R, line)
  70 #define GET_G_LINE(line)             GET_COMP_LINE(GST_VIDEO_COMP_G, line)
  71 #define GET_B_LINE(line)             GET_COMP_LINE(GST_VIDEO_COMP_B, line)
  72 
  73 #define GET_A_LINE(line)             GET_COMP_LINE(GST_VIDEO_COMP_A, line)
  74 
  75 #define GET_UV_420(line, flags)                 \
  76   (flags &amp; GST_VIDEO_PACK_FLAG_INTERLACED ?     \
  77    ((line &amp; ~3) &gt;&gt; 1) + (line &amp; 1) :            \
  78    line &gt;&gt; 1)
  79 #define GET_UV_410(line, flags)                 \
  80   (flags &amp; GST_VIDEO_PACK_FLAG_INTERLACED ?     \
  81    ((line &amp; ~7) &gt;&gt; 2) + (line &amp; 1) :            \
  82    line &gt;&gt; 2)
  83 
  84 #define IS_CHROMA_LINE_420(line, flags)         \
  85   (flags &amp; GST_VIDEO_PACK_FLAG_INTERLACED ?     \
  86    !(line &amp; 2) : !(line &amp; 1))
  87 #define IS_CHROMA_LINE_410(line, flags)         \
  88   (flags &amp; GST_VIDEO_PACK_FLAG_INTERLACED ?     \
  89    !(line &amp; 6) : !(line &amp; 3))
  90 
  91 #define IS_ALIGNED(x,n) ((((guintptr)(x)&amp;((n)-1))) == 0)
  92 
  93 #define PACK_420 GST_VIDEO_FORMAT_AYUV, unpack_planar_420, 1, pack_planar_420
  94 static void
  95 unpack_planar_420 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
  96     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
  97     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
  98 {
  99   gint uv = GET_UV_420 (y, flags);
 100   const guint8 *restrict sy = GET_Y_LINE (y);
 101   const guint8 *restrict su = GET_U_LINE (uv);
 102   const guint8 *restrict sv = GET_V_LINE (uv);
 103   guint8 *restrict d = dest;
 104 
 105   sy += x;
 106   su += x &gt;&gt; 1;
 107   sv += x &gt;&gt; 1;
 108 
 109   if (x &amp; 1) {
 110     d[0] = 0xff;
 111     d[1] = *sy++;
 112     d[2] = *su++;
 113     d[3] = *sv++;
 114     width--;
 115     d += 4;
 116   }
 117   video_orc_unpack_I420 (d, sy, su, sv, width);
 118 }
 119 
 120 static void
 121 pack_planar_420 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 122     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 123     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 124     gint y, gint width)
 125 {
 126   gint uv = GET_UV_420 (y, flags);
 127   guint8 *dy = GET_Y_LINE (y);
 128   guint8 *du = GET_U_LINE (uv);
 129   guint8 *dv = GET_V_LINE (uv);
 130   const guint8 *s = src;
 131 
 132   if (IS_CHROMA_LINE_420 (y, flags)) {
 133     if (IS_ALIGNED (s, 8))
 134       video_orc_pack_I420 (dy, du, dv, s, width / 2);
 135     else {
 136       gint i;
 137 
 138       for (i = 0; i &lt; width / 2; i++) {
 139         dy[i * 2 + 0] = s[i * 8 + 1];
 140         dy[i * 2 + 1] = s[i * 8 + 5];
 141         du[i] = s[i * 8 + 2];
 142         dv[i] = s[i * 8 + 3];
 143       }
 144     }
<a name="1" id="anc1"></a><span class="line-modified"> 145   if (width &amp; 1) {</span>
<span class="line-modified"> 146     gint i = width - 1;</span>
 147 
 148       dy[i] = s[i * 4 + 1];
 149       du[i &gt;&gt; 1] = s[i * 4 + 2];
 150       dv[i &gt;&gt; 1] = s[i * 4 + 3];
<a name="2" id="anc2"></a><span class="line-modified"> 151   }</span>
 152   } else
 153     video_orc_pack_Y (dy, s, width);
 154 }
 155 
 156 #define PACK_YUY2 GST_VIDEO_FORMAT_AYUV, unpack_YUY2, 1, pack_YUY2
 157 static void
 158 unpack_YUY2 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 159     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 160     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 161 {
 162   const guint8 *restrict s = GET_LINE (y);
 163   guint8 *restrict d = dest;
 164 
 165   s += (x &amp; ~1) &lt;&lt; 1;
 166   if (x &amp; 1) {
 167     d[0] = 0xff;
 168     d[1] = s[2];
 169     d[2] = s[1];
 170     d[3] = s[3];
 171     s += 4;
 172     d += 4;
 173     width--;
 174   }
 175 
 176   if (IS_ALIGNED (d, 8))
 177     video_orc_unpack_YUY2 (d, s, width / 2);
 178   else {
 179     gint i;
 180 
 181     for (i = 0; i &lt; width / 2; i++) {
 182       d[i * 8 + 0] = 0xff;
 183       d[i * 8 + 1] = s[i * 4 + 0];
 184       d[i * 8 + 2] = s[i * 4 + 1];
 185       d[i * 8 + 3] = s[i * 4 + 3];
 186       d[i * 8 + 4] = 0xff;
 187       d[i * 8 + 5] = s[i * 4 + 2];
 188       d[i * 8 + 6] = s[i * 4 + 1];
 189       d[i * 8 + 7] = s[i * 4 + 3];
 190     }
 191   }
 192 
 193   if (width &amp; 1) {
 194     gint i = width - 1;
 195 
 196     d[i * 4 + 0] = 0xff;
 197     d[i * 4 + 1] = s[i * 2 + 0];
 198     d[i * 4 + 2] = s[i * 2 + 1];
 199     d[i * 4 + 3] = s[i * 2 + 3];
 200   }
 201 }
 202 
 203 static void
 204 pack_YUY2 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 205     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 206     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 207     gint y, gint width)
 208 {
 209   guint8 *restrict d = GET_LINE (y);
 210   const guint8 *restrict s = src;
 211 
 212   if (IS_ALIGNED (s, 8))
 213     video_orc_pack_YUY2 (d, s, width / 2);
 214   else {
 215     gint i;
 216     for (i = 0; i &lt; width / 2; i++) {
 217       d[i * 4 + 0] = s[i * 8 + 1];
 218       d[i * 4 + 1] = s[i * 8 + 2];
 219       d[i * 4 + 2] = s[i * 8 + 5];
 220       d[i * 4 + 3] = s[i * 8 + 3];
 221     }
 222   }
 223 
 224   if (width &amp; 1) {
 225     gint i = width - 1;
 226 
 227     d[i * 2 + 0] = s[i * 4 + 1];
 228     d[i * 2 + 1] = s[i * 4 + 2];
 229     d[i * 2 + 3] = s[i * 4 + 3];
 230   }
 231 }
 232 
 233 #define PACK_UYVY GST_VIDEO_FORMAT_AYUV, unpack_UYVY, 1, pack_UYVY
 234 static void
 235 unpack_UYVY (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 236     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 237     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 238 {
 239   const guint8 *s = GET_LINE (y);
 240   guint8 *d = dest;
 241 
 242   s += (x &amp; ~1) &lt;&lt; 1;
 243   if (x &amp; 1) {
 244     d[0] = 0xff;
 245     d[1] = s[3];
 246     d[2] = s[0];
 247     d[3] = s[2];
 248     s += 4;
 249     d += 4;
 250     width--;
 251   }
 252 
 253   if (IS_ALIGNED (d, 8))
 254     video_orc_unpack_UYVY (d, s, width / 2);
 255   else {
 256     gint i;
 257 
 258     for (i = 0; i &lt; width / 2; i++) {
 259       d[i * 8 + 0] = 0xff;
 260       d[i * 8 + 1] = s[i * 4 + 1];
 261       d[i * 8 + 2] = s[i * 4 + 0];
 262       d[i * 8 + 3] = s[i * 4 + 2];
 263       d[i * 8 + 4] = 0xff;
 264       d[i * 8 + 5] = s[i * 4 + 3];
 265       d[i * 8 + 6] = s[i * 4 + 0];
 266       d[i * 8 + 7] = s[i * 4 + 2];
 267     }
 268   }
 269 
 270   if (width &amp; 1) {
 271     gint i = width - 1;
 272 
 273     d[i * 4 + 0] = 0xff;
 274     d[i * 4 + 1] = s[i * 2 + 1];
 275     d[i * 4 + 2] = s[i * 2 + 0];
 276     d[i * 4 + 3] = s[i * 2 + 2];
 277   }
 278 }
 279 
 280 static void
 281 pack_UYVY (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 282     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 283     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 284     gint y, gint width)
 285 {
 286   guint8 *restrict d = GET_LINE (y);
 287   const guint8 *restrict s = src;
 288 
 289   if (IS_ALIGNED (s, 8))
 290     video_orc_pack_UYVY (d, s, width / 2);
 291   else {
 292     gint i;
 293     for (i = 0; i &lt; width / 2; i++) {
 294       d[i * 4 + 0] = s[i * 8 + 2];
 295       d[i * 4 + 1] = s[i * 8 + 1];
 296       d[i * 4 + 2] = s[i * 8 + 3];
 297       d[i * 4 + 3] = s[i * 8 + 5];
 298     }
 299   }
 300   if (width &amp; 1) {
 301     gint i = width - 1;
 302 
 303     d[i * 2 + 0] = s[i * 4 + 2];
 304     d[i * 2 + 1] = s[i * 4 + 1];
 305     d[i * 2 + 2] = s[i * 4 + 3];
 306   }
 307 }
 308 
 309 #define PACK_VYUY GST_VIDEO_FORMAT_AYUV, unpack_VYUY, 1, pack_VYUY
 310 static void
 311 unpack_VYUY (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 312     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 313     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 314 {
 315   const guint8 *s = GET_LINE (y);
 316   guint8 *d = dest;
 317 
 318   s += (x &amp; ~1) &lt;&lt; 1;
 319   if (x &amp; 1) {
 320     d[0] = 0xff;
 321     d[1] = s[3];
 322     d[2] = s[0];
 323     d[3] = s[2];
 324     s += 4;
 325     d += 4;
 326     width--;
 327   }
 328 
 329   if (IS_ALIGNED (d, 8))
 330     video_orc_unpack_VYUY (d, s, width / 2);
 331   else {
 332     gint i;
 333 
 334     for (i = 0; i &lt; width / 2; i++) {
 335       d[i * 8 + 0] = 0xff;
 336       d[i * 8 + 1] = s[i * 4 + 1];
 337       d[i * 8 + 2] = s[i * 4 + 0];
 338       d[i * 8 + 3] = s[i * 4 + 2];
 339       d[i * 8 + 4] = 0xff;
 340       d[i * 8 + 5] = s[i * 4 + 3];
 341       d[i * 8 + 6] = s[i * 4 + 0];
 342       d[i * 8 + 7] = s[i * 4 + 2];
 343     }
 344   }
 345 
 346   if (width &amp; 1) {
 347     gint i = width - 1;
 348 
 349     d[i * 4 + 0] = 0xff;
 350     d[i * 4 + 1] = s[i * 2 + 1];
 351     d[i * 4 + 2] = s[i * 2 + 0];
 352     d[i * 4 + 3] = s[i * 2 + 2];
 353   }
 354 }
 355 
 356 static void
 357 pack_VYUY (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 358     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 359     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 360     gint y, gint width)
 361 {
 362   guint8 *restrict d = GET_LINE (y);
 363   const guint8 *restrict s = src;
 364 
 365   if (IS_ALIGNED (s, 8))
 366     video_orc_pack_VYUY (d, s, width / 2);
 367   else {
 368     gint i;
 369     for (i = 0; i &lt; width / 2; i++) {
 370       d[i * 4 + 0] = s[i * 8 + 2];
 371       d[i * 4 + 1] = s[i * 8 + 1];
 372       d[i * 4 + 2] = s[i * 8 + 3];
 373       d[i * 4 + 3] = s[i * 8 + 5];
 374     }
 375   }
 376   if (width &amp; 1) {
 377     gint i = width - 1;
 378 
 379     d[i * 2 + 0] = s[i * 4 + 2];
 380     d[i * 2 + 1] = s[i * 4 + 1];
 381     d[i * 2 + 2] = s[i * 4 + 3];
 382   }
 383 }
 384 
 385 #define PACK_YVYU GST_VIDEO_FORMAT_AYUV, unpack_YVYU, 1, pack_YVYU
 386 static void
 387 unpack_YVYU (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 388     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 389     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 390 {
 391   const guint8 *restrict s = GET_LINE (y);
 392   guint8 *restrict d = dest;
 393 
 394   s += (x &amp; ~1) &lt;&lt; 1;
 395   if (x &amp; 1) {
 396     d[0] = 0xff;
 397     d[1] = s[2];
 398     d[2] = s[3];
 399     d[3] = s[1];
 400     s += 4;
 401     d += 4;
 402     width--;
 403   }
 404 
 405   if (IS_ALIGNED (d, 8))
 406     video_orc_unpack_YVYU (d, s, width / 2);
 407   else {
 408     gint i;
 409 
 410     for (i = 0; i &lt; width / 2; i++) {
 411       d[i * 8 + 0] = 0xff;
 412       d[i * 8 + 1] = s[i * 4 + 0];
 413       d[i * 8 + 2] = s[i * 4 + 3];
 414       d[i * 8 + 3] = s[i * 4 + 1];
 415       d[i * 8 + 4] = 0xff;
 416       d[i * 8 + 5] = s[i * 4 + 2];
 417       d[i * 8 + 6] = s[i * 4 + 3];
 418       d[i * 8 + 7] = s[i * 4 + 1];
 419     }
 420   }
 421 
 422   if (width &amp; 1) {
 423     gint i = width - 1;
 424 
 425     d[i * 4 + 0] = 0xff;
 426     d[i * 4 + 1] = s[i * 2 + 0];
 427     d[i * 4 + 2] = s[i * 2 + 3];
 428     d[i * 4 + 3] = s[i * 2 + 1];
 429   }
 430 }
 431 
 432 static void
 433 pack_YVYU (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 434     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 435     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 436     gint y, gint width)
 437 {
 438   guint8 *restrict d = GET_LINE (y);
 439   const guint8 *restrict s = src;
 440 
 441   if (IS_ALIGNED (s, 8))
 442     video_orc_pack_YVYU (d, s, width / 2);
 443   else {
 444     gint i;
 445     for (i = 0; i &lt; width / 2; i++) {
 446       d[i * 4 + 0] = s[i * 8 + 1];
 447       d[i * 4 + 1] = s[i * 8 + 3];
 448       d[i * 4 + 2] = s[i * 8 + 5];
 449       d[i * 4 + 3] = s[i * 8 + 2];
 450     }
 451   }
 452 
 453   if (width &amp; 1) {
 454     gint i = width - 1;
 455 
 456     d[i * 2 + 0] = s[i * 4 + 1];
 457     d[i * 2 + 1] = s[i * 4 + 3];
 458     d[i * 2 + 3] = s[i * 4 + 2];
 459   }
 460 }
 461 
 462 #define PACK_v308 GST_VIDEO_FORMAT_AYUV, unpack_v308, 1, pack_v308
 463 static void
 464 unpack_v308 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 465     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 466     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 467 {
 468   int i;
 469   const guint8 *restrict s = GET_LINE (y);
 470   guint8 *restrict d = dest;
 471 
 472   s += x * 3;
 473 
 474   for (i = 0; i &lt; width; i++) {
 475     d[i * 4 + 0] = 0xff;
 476     d[i * 4 + 1] = s[i * 3 + 0];
 477     d[i * 4 + 2] = s[i * 3 + 1];
 478     d[i * 4 + 3] = s[i * 3 + 2];
 479   }
 480 }
 481 
 482 static void
 483 pack_v308 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 484     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 485     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 486     gint y, gint width)
 487 {
 488   int i;
 489   guint8 *restrict d = GET_LINE (y);
 490   const guint8 *restrict s = src;
 491 
 492   for (i = 0; i &lt; width; i++) {
 493     d[i * 3 + 0] = s[i * 4 + 1];
 494     d[i * 3 + 1] = s[i * 4 + 2];
 495     d[i * 3 + 2] = s[i * 4 + 3];
 496   }
 497 }
 498 
 499 #define PACK_IYU2 GST_VIDEO_FORMAT_AYUV, unpack_IYU2, 1, pack_IYU2
 500 static void
 501 unpack_IYU2 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 502     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 503     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 504 {
 505   int i;
 506   const guint8 *restrict s = GET_LINE (y);
 507   guint8 *restrict d = dest;
 508 
 509   s += x * 3;
 510 
 511   for (i = 0; i &lt; width; i++) {
 512     d[i * 4 + 0] = 0xff;
 513     d[i * 4 + 1] = s[i * 3 + 1];
 514     d[i * 4 + 2] = s[i * 3 + 0];
 515     d[i * 4 + 3] = s[i * 3 + 2];
 516   }
 517 }
 518 
 519 static void
 520 pack_IYU2 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 521     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 522     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 523     gint y, gint width)
 524 {
 525   int i;
 526   guint8 *restrict d = GET_LINE (y);
 527   const guint8 *restrict s = src;
 528 
 529   for (i = 0; i &lt; width; i++) {
 530     d[i * 3 + 0] = s[i * 4 + 2];
 531     d[i * 3 + 1] = s[i * 4 + 1];
 532     d[i * 3 + 2] = s[i * 4 + 3];
 533   }
 534 }
 535 
 536 #define PACK_AYUV GST_VIDEO_FORMAT_AYUV, unpack_copy4, 1, pack_copy4
 537 #define PACK_ARGB GST_VIDEO_FORMAT_ARGB, unpack_copy4, 1, pack_copy4
 538 static void
 539 unpack_copy4 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 540     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 541     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 542 {
 543   const guint8 *restrict s = GET_LINE (y);
 544 
 545   s += x * 4;
 546 
 547   memcpy (dest, s, width * 4);
 548 }
 549 
 550 static void
 551 pack_copy4 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 552     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 553     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 554     gint y, gint width)
 555 {
 556   guint8 *restrict d = GET_LINE (y);
 557 
 558   memcpy (d, src, width * 4);
 559 }
 560 
 561 #define PACK_v210 GST_VIDEO_FORMAT_AYUV64, unpack_v210, 1, pack_v210
 562 static void
 563 unpack_v210 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 564     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 565     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 566 {
 567   int i;
 568   const guint8 *restrict s = GET_LINE (y);
 569   guint16 *restrict d = dest;
 570   guint32 a0, a1, a2, a3;
 571   guint16 y0, y1, y2, y3, y4, y5;
 572   guint16 u0, u2, u4;
 573   guint16 v0, v2, v4;
 574 
 575   /* FIXME */
 576   s += x * 2;
 577 
 578   for (i = 0; i &lt; width; i += 6) {
 579     a0 = GST_READ_UINT32_LE (s + (i / 6) * 16 + 0);
 580     a1 = GST_READ_UINT32_LE (s + (i / 6) * 16 + 4);
 581     a2 = GST_READ_UINT32_LE (s + (i / 6) * 16 + 8);
 582     a3 = GST_READ_UINT32_LE (s + (i / 6) * 16 + 12);
 583 
 584     u0 = ((a0 &gt;&gt; 0) &amp; 0x3ff) &lt;&lt; 6;
 585     y0 = ((a0 &gt;&gt; 10) &amp; 0x3ff) &lt;&lt; 6;
 586     v0 = ((a0 &gt;&gt; 20) &amp; 0x3ff) &lt;&lt; 6;
 587     y1 = ((a1 &gt;&gt; 0) &amp; 0x3ff) &lt;&lt; 6;
 588 
 589     u2 = ((a1 &gt;&gt; 10) &amp; 0x3ff) &lt;&lt; 6;
 590     y2 = ((a1 &gt;&gt; 20) &amp; 0x3ff) &lt;&lt; 6;
 591     v2 = ((a2 &gt;&gt; 0) &amp; 0x3ff) &lt;&lt; 6;
 592     y3 = ((a2 &gt;&gt; 10) &amp; 0x3ff) &lt;&lt; 6;
 593 
 594     u4 = ((a2 &gt;&gt; 20) &amp; 0x3ff) &lt;&lt; 6;
 595     y4 = ((a3 &gt;&gt; 0) &amp; 0x3ff) &lt;&lt; 6;
 596     v4 = ((a3 &gt;&gt; 10) &amp; 0x3ff) &lt;&lt; 6;
 597     y5 = ((a3 &gt;&gt; 20) &amp; 0x3ff) &lt;&lt; 6;
 598 
 599     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
 600       y0 |= (y0 &gt;&gt; 10);
 601       y1 |= (y1 &gt;&gt; 10);
 602       u0 |= (u0 &gt;&gt; 10);
 603       v0 |= (v0 &gt;&gt; 10);
 604 
 605       y2 |= (y2 &gt;&gt; 10);
 606       y3 |= (y3 &gt;&gt; 10);
 607       u2 |= (u2 &gt;&gt; 10);
 608       v2 |= (v2 &gt;&gt; 10);
 609 
 610       y4 |= (y4 &gt;&gt; 10);
 611       y5 |= (y5 &gt;&gt; 10);
 612       u4 |= (u4 &gt;&gt; 10);
 613       v4 |= (v4 &gt;&gt; 10);
 614     }
 615 
 616     d[4 * (i + 0) + 0] = 0xffff;
 617     d[4 * (i + 0) + 1] = y0;
 618     d[4 * (i + 0) + 2] = u0;
 619     d[4 * (i + 0) + 3] = v0;
 620 
 621     if (i &lt; width - 1) {
 622       d[4 * (i + 1) + 0] = 0xffff;
 623       d[4 * (i + 1) + 1] = y1;
 624       d[4 * (i + 1) + 2] = u0;
 625       d[4 * (i + 1) + 3] = v0;
 626     }
 627     if (i &lt; width - 2) {
 628       d[4 * (i + 2) + 0] = 0xffff;
 629       d[4 * (i + 2) + 1] = y2;
 630       d[4 * (i + 2) + 2] = u2;
 631       d[4 * (i + 2) + 3] = v2;
 632     }
 633     if (i &lt; width - 3) {
 634       d[4 * (i + 3) + 0] = 0xffff;
 635       d[4 * (i + 3) + 1] = y3;
 636       d[4 * (i + 3) + 2] = u2;
 637       d[4 * (i + 3) + 3] = v2;
 638     }
 639     if (i &lt; width - 4) {
 640       d[4 * (i + 4) + 0] = 0xffff;
 641       d[4 * (i + 4) + 1] = y4;
 642       d[4 * (i + 4) + 2] = u4;
 643       d[4 * (i + 4) + 3] = v4;
 644     }
 645     if (i &lt; width - 5) {
 646       d[4 * (i + 5) + 0] = 0xffff;
 647       d[4 * (i + 5) + 1] = y5;
 648       d[4 * (i + 5) + 2] = u4;
 649       d[4 * (i + 5) + 3] = v4;
 650     }
 651   }
 652 }
 653 
 654 static void
 655 pack_v210 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 656     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 657     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 658     gint y, gint width)
 659 {
 660   int i;
 661   guint8 *restrict d = GET_LINE (y);
 662   const guint16 *restrict s = src;
 663   guint32 a0, a1, a2, a3;
 664   guint16 y0, y1, y2, y3, y4, y5;
 665   guint16 u0, u1, u2;
 666   guint16 v0, v1, v2;
 667 
 668   for (i = 0; i &lt; width - 5; i += 6) {
 669     y0 = s[4 * (i + 0) + 1] &gt;&gt; 6;
 670     y1 = s[4 * (i + 1) + 1] &gt;&gt; 6;
 671     y2 = s[4 * (i + 2) + 1] &gt;&gt; 6;
 672     y3 = s[4 * (i + 3) + 1] &gt;&gt; 6;
 673     y4 = s[4 * (i + 4) + 1] &gt;&gt; 6;
 674     y5 = s[4 * (i + 5) + 1] &gt;&gt; 6;
 675 
 676     u0 = s[4 * (i + 0) + 2] &gt;&gt; 6;
 677     u1 = s[4 * (i + 2) + 2] &gt;&gt; 6;
 678     u2 = s[4 * (i + 4) + 2] &gt;&gt; 6;
 679 
 680     v0 = s[4 * (i + 0) + 3] &gt;&gt; 6;
 681     v1 = s[4 * (i + 2) + 3] &gt;&gt; 6;
 682     v2 = s[4 * (i + 4) + 3] &gt;&gt; 6;
 683 
 684     a0 = u0 | (y0 &lt;&lt; 10) | (v0 &lt;&lt; 20);
 685     a1 = y1 | (u1 &lt;&lt; 10) | (y2 &lt;&lt; 20);
 686     a2 = v1 | (y3 &lt;&lt; 10) | (u2 &lt;&lt; 20);
 687     a3 = y4 | (v2 &lt;&lt; 10) | (y5 &lt;&lt; 20);
 688 
 689     GST_WRITE_UINT32_LE (d + (i / 6) * 16 + 0, a0);
 690     GST_WRITE_UINT32_LE (d + (i / 6) * 16 + 4, a1);
 691     GST_WRITE_UINT32_LE (d + (i / 6) * 16 + 8, a2);
 692     GST_WRITE_UINT32_LE (d + (i / 6) * 16 + 12, a3);
 693   }
 694   if (i &lt; width) {
 695     y0 = s[4 * (i + 0) + 1] &gt;&gt; 6;
 696     u0 = s[4 * (i + 0) + 2] &gt;&gt; 6;
 697     v0 = s[4 * (i + 0) + 3] &gt;&gt; 6;
 698     if (i &lt; width - 1)
 699       y1 = s[4 * (i + 1) + 1] &gt;&gt; 6;
 700     else
 701       y1 = y0;
 702     if (i &lt; width - 2) {
 703       y2 = s[4 * (i + 2) + 1] &gt;&gt; 6;
 704       u1 = s[4 * (i + 2) + 2] &gt;&gt; 6;
 705       v1 = s[4 * (i + 2) + 3] &gt;&gt; 6;
 706     } else {
 707       y2 = y1;
 708       u1 = u0;
 709       v1 = v0;
 710     }
 711     if (i &lt; width - 3)
 712       y3 = s[4 * (i + 3) + 1] &gt;&gt; 6;
 713     else
 714       y3 = y2;
 715     if (i &lt; width - 4) {
 716       y4 = s[4 * (i + 4) + 1] &gt;&gt; 6;
 717       u2 = s[4 * (i + 4) + 2] &gt;&gt; 6;
 718       v2 = s[4 * (i + 4) + 3] &gt;&gt; 6;
 719     } else {
 720       y4 = y3;
 721       u2 = u1;
 722       v2 = v1;
 723     }
 724     y5 = y4;
 725 
 726     a0 = u0 | (y0 &lt;&lt; 10) | (v0 &lt;&lt; 20);
 727     a1 = y1 | (u1 &lt;&lt; 10) | (y2 &lt;&lt; 20);
 728     a2 = v1 | (y3 &lt;&lt; 10) | (u2 &lt;&lt; 20);
 729     a3 = y4 | (v2 &lt;&lt; 10) | (y5 &lt;&lt; 20);
 730 
 731     GST_WRITE_UINT32_LE (d + (i / 6) * 16 + 0, a0);
 732     GST_WRITE_UINT32_LE (d + (i / 6) * 16 + 4, a1);
 733     GST_WRITE_UINT32_LE (d + (i / 6) * 16 + 8, a2);
 734     GST_WRITE_UINT32_LE (d + (i / 6) * 16 + 12, a3);
 735   }
 736 }
 737 
 738 #define PACK_v216 GST_VIDEO_FORMAT_AYUV64, unpack_v216, 1, pack_v216
 739 static void
 740 unpack_v216 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 741     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 742     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 743 {
 744   int i;
 745   const guint8 *restrict s = GET_LINE (y);
 746   guint16 *restrict d = dest;
 747 
 748   s += (x &amp; ~1) &lt;&lt; 2;
 749   if (x &amp; 1) {
 750     d[0] = 0xffff;
 751     d[1] = GST_READ_UINT16_LE (s + 6);
 752     d[2] = GST_READ_UINT16_LE (s + 0);
 753     d[3] = GST_READ_UINT16_LE (s + 4);
 754     s += 8;
 755     d += 4;
 756     width--;
 757   }
 758 
 759   for (i = 0; i &lt; width; i++) {
 760     d[i * 4 + 0] = 0xffff;
 761     d[i * 4 + 1] = GST_READ_UINT16_LE (s + i * 4 + 2);
 762     d[i * 4 + 2] = GST_READ_UINT16_LE (s + (i &gt;&gt; 1) * 8 + 0);
 763     d[i * 4 + 3] = GST_READ_UINT16_LE (s + (i &gt;&gt; 1) * 8 + 4);
 764   }
 765 }
 766 
 767 static void
 768 pack_v216 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 769     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 770     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 771     gint y, gint width)
 772 {
 773   int i;
 774   guint8 *restrict d = GET_LINE (y);
 775   const guint16 *restrict s = src;
 776 
 777   for (i = 0; i &lt; width - 1; i += 2) {
 778     GST_WRITE_UINT16_LE (d + i * 4 + 0, s[(i + 0) * 4 + 2]);
 779     GST_WRITE_UINT16_LE (d + i * 4 + 2, s[(i + 0) * 4 + 1]);
 780     GST_WRITE_UINT16_LE (d + i * 4 + 4, s[(i + 0) * 4 + 3]);
 781     GST_WRITE_UINT16_LE (d + i * 4 + 6, s[(i + 1) * 4 + 1]);
 782   }
 783   if (i == width - 1) {
 784     GST_WRITE_UINT16_LE (d + i * 4 + 0, s[i * 4 + 2]);
 785     GST_WRITE_UINT16_LE (d + i * 4 + 2, s[i * 4 + 1]);
 786     GST_WRITE_UINT16_LE (d + i * 4 + 4, s[i * 4 + 3]);
 787     GST_WRITE_UINT16_LE (d + i * 4 + 6, s[i * 4 + 1]);
 788   }
 789 }
 790 
<a name="3" id="anc3"></a>


































































































































































 791 #define PACK_Y41B GST_VIDEO_FORMAT_AYUV, unpack_Y41B, 1, pack_Y41B
 792 static void
 793 unpack_Y41B (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 794     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 795     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 796 {
 797   const guint8 *restrict sy = GET_Y_LINE (y);
 798   const guint8 *restrict su = GET_U_LINE (y);
 799   const guint8 *restrict sv = GET_V_LINE (y);
 800   guint8 *restrict d = dest;
 801 
 802   sy += x;
 803   su += x &gt;&gt; 2;
 804   sv += x &gt;&gt; 2;
 805 
 806   if (x &amp; 3) {
 807     for (; x &amp; 3; x++) {
 808       d[0] = 0xff;
 809       d[1] = *sy++;
 810       d[2] = *su;
 811       d[3] = *sv;
 812       width--;
 813       d += 4;
 814     }
 815     su++;
 816     sy++;
 817   }
 818 
 819   if (IS_ALIGNED (d, 8))
 820     video_orc_unpack_YUV9 (d, sy, su, sv, width / 2);
 821   else {
 822     gint i;
 823     for (i = 0; i &lt; width / 2; i++) {
 824       d[i * 8 + 0] = 0xff;
 825       d[i * 8 + 1] = sy[i * 2 + 0];
 826       d[i * 8 + 2] = su[i &gt;&gt; 1];
 827       d[i * 8 + 3] = sv[i &gt;&gt; 1];
 828       d[i * 8 + 4] = 0xff;
 829       d[i * 8 + 5] = sy[i * 2 + 1];
 830       d[i * 8 + 6] = su[i &gt;&gt; 1];
 831       d[i * 8 + 7] = sv[i &gt;&gt; 1];
 832     }
 833   }
 834 
 835   if (width &amp; 1) {
 836     gint i = width - 1;
 837 
 838     d[i * 4 + 0] = 0xff;
 839     d[i * 4 + 1] = sy[i];
 840     d[i * 4 + 2] = su[i &gt;&gt; 2];
 841     d[i * 4 + 3] = sv[i &gt;&gt; 2];
 842   }
 843 }
 844 
 845 static void
 846 pack_Y41B (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 847     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 848     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 849     gint y, gint width)
 850 {
 851   int i;
 852   guint8 *restrict dy = GET_Y_LINE (y);
 853   guint8 *restrict du = GET_U_LINE (y);
 854   guint8 *restrict dv = GET_V_LINE (y);
 855   const guint8 *restrict s = src;
 856 
 857   for (i = 0; i &lt; width - 3; i += 4) {
 858     dy[i] = s[i * 4 + 1];
 859     dy[i + 1] = s[i * 4 + 5];
 860     dy[i + 2] = s[i * 4 + 9];
 861     dy[i + 3] = s[i * 4 + 13];
 862 
 863     du[i &gt;&gt; 2] = s[i * 4 + 2];
 864     dv[i &gt;&gt; 2] = s[i * 4 + 3];
 865   }
 866   if (i &lt; width) {
 867     dy[i] = s[i * 4 + 1];
 868     du[i &gt;&gt; 2] = s[i * 4 + 2];
 869     dv[i &gt;&gt; 2] = s[i * 4 + 3];
 870     if (i &lt; width - 1)
 871       dy[i + 1] = s[i * 4 + 5];
 872     if (i &lt; width - 2)
 873       dy[i + 2] = s[i * 4 + 9];
 874   }
 875 }
 876 
 877 #define PACK_Y42B GST_VIDEO_FORMAT_AYUV, unpack_Y42B, 1, pack_Y42B
 878 static void
 879 unpack_Y42B (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 880     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 881     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 882 {
 883   const guint8 *restrict sy = GET_Y_LINE (y);
 884   const guint8 *restrict su = GET_U_LINE (y);
 885   const guint8 *restrict sv = GET_V_LINE (y);
 886   guint8 *restrict d = dest;
 887 
 888   sy += x;
 889   su += x &gt;&gt; 1;
 890   sv += x &gt;&gt; 1;
 891 
 892   if (x &amp; 1) {
 893     d[0] = 0xff;
 894     d[1] = *sy++;
 895     d[2] = *su++;
 896     d[3] = *sv++;
 897     width--;
 898     d += 4;
 899   }
 900 
 901   if (IS_ALIGNED (d, 8))
 902     video_orc_unpack_Y42B (d, sy, su, sv, width / 2);
 903   else {
 904     gint i;
 905     for (i = 0; i &lt; width / 2; i++) {
 906       d[i * 8 + 0] = 0xff;
 907       d[i * 8 + 1] = sy[i * 2 + 0];
 908       d[i * 8 + 2] = su[i];
 909       d[i * 8 + 3] = sv[i];
 910       d[i * 8 + 4] = 0xff;
 911       d[i * 8 + 5] = sy[i * 2 + 1];
 912       d[i * 8 + 6] = su[i];
 913       d[i * 8 + 7] = sv[i];
 914     }
 915   }
 916 
 917   if (width &amp; 1) {
 918     gint i = width - 1;
 919 
 920     d[i * 4 + 0] = 0xff;
 921     d[i * 4 + 1] = sy[i];
 922     d[i * 4 + 2] = su[i &gt;&gt; 1];
 923     d[i * 4 + 3] = sv[i &gt;&gt; 1];
 924   }
 925 }
 926 
 927 static void
 928 pack_Y42B (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 929     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 930     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 931     gint y, gint width)
 932 {
 933   guint8 *restrict dy = GET_Y_LINE (y);
 934   guint8 *restrict du = GET_U_LINE (y);
 935   guint8 *restrict dv = GET_V_LINE (y);
 936   const guint8 *restrict s = src;
 937 
 938   if (IS_ALIGNED (s, 8))
 939     video_orc_pack_Y42B (dy, du, dv, s, width / 2);
 940   else {
 941     gint i;
 942     for (i = 0; i &lt; width / 2; i++) {
 943       dy[i * 2 + 0] = s[i * 8 + 1];
 944       dy[i * 2 + 1] = s[i * 8 + 5];
 945       du[i] = s[i * 8 + 2];
 946       dv[i] = s[i * 8 + 3];
 947     }
 948   }
 949 
 950   if (width &amp; 1) {
 951     gint i = width - 1;
 952 
 953     dy[i] = s[i * 4 + 1];
 954     du[i &gt;&gt; 1] = s[i * 4 + 2];
 955     dv[i &gt;&gt; 1] = s[i * 4 + 3];
 956   }
 957 }
 958 
 959 #define PACK_Y444 GST_VIDEO_FORMAT_AYUV, unpack_Y444, 1, pack_Y444
 960 static void
 961 unpack_Y444 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 962     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 963     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 964 {
 965   const guint8 *restrict sy = GET_Y_LINE (y);
 966   const guint8 *restrict su = GET_U_LINE (y);
 967   const guint8 *restrict sv = GET_V_LINE (y);
 968 
 969   sy += x;
 970   su += x;
 971   sv += x;
 972 
 973   video_orc_unpack_Y444 (dest, sy, su, sv, width);
 974 }
 975 
 976 static void
 977 pack_Y444 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 978     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
 979     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
 980     gint y, gint width)
 981 {
 982   guint8 *restrict dy = GET_Y_LINE (y);
 983   guint8 *restrict du = GET_U_LINE (y);
 984   guint8 *restrict dv = GET_V_LINE (y);
 985 
 986   video_orc_pack_Y444 (dy, du, dv, src, width);
 987 }
 988 
 989 #define PACK_GBR GST_VIDEO_FORMAT_ARGB, unpack_GBR, 1, pack_GBR
 990 static void
 991 unpack_GBR (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
 992     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
 993     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
 994 {
 995   const guint8 *restrict sr = GET_R_LINE (y);
 996   const guint8 *restrict sg = GET_G_LINE (y);
 997   const guint8 *restrict sb = GET_B_LINE (y);
 998 
 999   sr += x;
1000   sg += x;
1001   sb += x;
1002 
1003   video_orc_unpack_Y444 (dest, sr, sg, sb, width);
1004 }
1005 
1006 static void
1007 pack_GBR (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1008     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1009     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1010     gint y, gint width)
1011 {
1012   guint8 *restrict dr = GET_R_LINE (y);
1013   guint8 *restrict dg = GET_G_LINE (y);
1014   guint8 *restrict db = GET_B_LINE (y);
1015 
1016   video_orc_pack_Y444 (dr, dg, db, src, width);
1017 }
1018 
1019 #define PACK_GBRA GST_VIDEO_FORMAT_ARGB, unpack_GBRA, 1, pack_GBRA
1020 static void
1021 unpack_GBRA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1022     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1023     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1024 {
1025   int i;
1026   const guint8 *sg = GET_G_LINE (y);
1027   const guint8 *sb = GET_B_LINE (y);
1028   const guint8 *sr = GET_R_LINE (y);
1029   const guint8 *sa = GET_A_LINE (y);
1030   guint8 *d = dest, G, B, R, A;
1031 
1032   sg += x;
1033   sb += x;
1034   sr += x;
1035   sa += x;
1036 
1037   for (i = 0; i &lt; width; i++) {
1038     G = GST_READ_UINT8 (sg + i);
1039     B = GST_READ_UINT8 (sb + i);
1040     R = GST_READ_UINT8 (sr + i);
1041     A = GST_READ_UINT8 (sa + i);
1042 
1043     d[i * 4 + 0] = A;
1044     d[i * 4 + 1] = R;
1045     d[i * 4 + 2] = G;
1046     d[i * 4 + 3] = B;
1047   }
1048 }
1049 
1050 static void
1051 pack_GBRA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1052     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1053     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1054     gint y, gint width)
1055 {
1056   int i;
1057   guint8 *restrict dg = GET_G_LINE (y);
1058   guint8 *restrict db = GET_B_LINE (y);
1059   guint8 *restrict dr = GET_R_LINE (y);
1060   guint8 *restrict da = GET_A_LINE (y);
1061   guint8 G, B, R, A;
1062   const guint8 *restrict s = src;
1063 
1064   for (i = 0; i &lt; width; i++) {
1065     G = (s[i * 4 + 2]);
1066     B = (s[i * 4 + 3]);
1067     R = (s[i * 4 + 1]);
1068     A = (s[i * 4 + 0]);
1069 
1070     GST_WRITE_UINT8 (dg + i, G);
1071     GST_WRITE_UINT8 (db + i, B);
1072     GST_WRITE_UINT8 (dr + i, R);
1073     GST_WRITE_UINT8 (da + i, A);
1074   }
1075 }
1076 
1077 #define PACK_GRAY8 GST_VIDEO_FORMAT_AYUV, unpack_GRAY8, 1, pack_GRAY8
1078 static void
1079 unpack_GRAY8 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1080     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1081     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1082 {
1083   const guint8 *restrict s = GET_LINE (y);
1084 
1085   s += x;
1086 
1087   video_orc_unpack_GRAY8 (dest, s, width);
1088 }
1089 
1090 static void
1091 pack_GRAY8 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1092     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1093     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1094     gint y, gint width)
1095 {
1096   guint8 *restrict d = GET_LINE (y);
1097 
1098   video_orc_pack_GRAY8 (d, src, width);
1099 }
1100 
1101 #define PACK_GRAY16_BE GST_VIDEO_FORMAT_AYUV64, unpack_GRAY16_BE, 1, pack_GRAY16_BE
1102 static void
1103 unpack_GRAY16_BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1104     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1105     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1106 {
1107   int i;
1108   const guint16 *restrict s = GET_LINE (y);
1109   guint16 *restrict d = dest;
1110 
1111   s += x;
1112 
1113   for (i = 0; i &lt; width; i++) {
1114     d[i * 4 + 0] = 0xffff;
1115     d[i * 4 + 1] = GST_READ_UINT16_BE (s + i);
1116     d[i * 4 + 2] = 0x8000;
1117     d[i * 4 + 3] = 0x8000;
1118   }
1119 }
1120 
1121 static void
1122 pack_GRAY16_BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1123     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1124     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1125     gint y, gint width)
1126 {
1127   int i;
1128   guint16 *restrict d = GET_LINE (y);
1129   const guint16 *restrict s = src;
1130 
1131   for (i = 0; i &lt; width; i++) {
1132     GST_WRITE_UINT16_BE (d + i, s[i * 4 + 1]);
1133   }
1134 }
1135 
1136 #define PACK_GRAY16_LE GST_VIDEO_FORMAT_AYUV64, unpack_GRAY16_LE, 1, pack_GRAY16_LE
1137 static void
1138 unpack_GRAY16_LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1139     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1140     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1141 {
1142   int i;
1143   const guint16 *restrict s = GET_LINE (y);
1144   guint16 *restrict d = dest;
1145 
1146   s += x;
1147 
1148   for (i = 0; i &lt; width; i++) {
1149     d[i * 4 + 0] = 0xffff;
1150     d[i * 4 + 1] = GST_READ_UINT16_LE (s + i);
1151     d[i * 4 + 2] = 0x8000;
1152     d[i * 4 + 3] = 0x8000;
1153   }
1154 }
1155 
1156 static void
1157 pack_GRAY16_LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1158     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1159     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1160     gint y, gint width)
1161 {
1162   int i;
1163   guint16 *restrict d = GET_LINE (y);
1164   const guint16 *restrict s = src;
1165 
1166   for (i = 0; i &lt; width; i++) {
1167     GST_WRITE_UINT16_LE (d + i, s[i * 4 + 1]);
1168   }
1169 }
1170 
1171 #define PACK_RGB16 GST_VIDEO_FORMAT_ARGB, unpack_RGB16, 1, pack_RGB16
1172 static void
1173 unpack_RGB16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1174     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1175     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1176 {
1177   const guint16 *restrict s = GET_LINE (y);
1178 
1179   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1180     video_orc_unpack_RGB16_trunc (dest, s + x, width);
1181   else
1182     video_orc_unpack_RGB16 (dest, s + x, width);
<a name="4" id="anc4"></a><span class="line-modified">1183     }</span>
1184 
1185 static void
1186 pack_RGB16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1187     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1188     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1189     gint y, gint width)
1190 {
1191   guint16 *restrict d = GET_LINE (y);
1192 
1193 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1194   video_orc_pack_RGB16_le (d, src, width);
1195 #else
1196   video_orc_pack_RGB16_be (d, src, width);
1197 #endif
<a name="5" id="anc5"></a><span class="line-modified">1198   }</span>
1199 
1200 #define PACK_BGR16 GST_VIDEO_FORMAT_ARGB, unpack_BGR16, 1, pack_BGR16
1201 static void
1202 unpack_BGR16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1203     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1204     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1205 {
1206   const guint16 *restrict s = GET_LINE (y);
1207 
1208   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1209     video_orc_unpack_BGR16_trunc (dest, s + x, width);
1210   else
1211     video_orc_unpack_BGR16 (dest, s + x, width);
<a name="6" id="anc6"></a><span class="line-modified">1212     }</span>
1213 
1214 static void
1215 pack_BGR16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1216     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1217     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1218     gint y, gint width)
1219 {
1220   guint16 *restrict d = GET_LINE (y);
1221 
1222 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1223   video_orc_pack_BGR16_le (d, src, width);
1224 #else
1225   video_orc_pack_BGR16_be (d, src, width);
1226 #endif
<a name="7" id="anc7"></a><span class="line-modified">1227   }</span>
1228 
1229 #define PACK_RGB15 GST_VIDEO_FORMAT_ARGB, unpack_RGB15, 1, pack_RGB15
1230 static void
1231 unpack_RGB15 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1232     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1233     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1234 {
1235   const guint16 *restrict s = GET_LINE (y);
1236 
1237 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1238   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1239     video_orc_unpack_RGB15_le_trunc (dest, s + x, width);
1240   else
1241     video_orc_unpack_RGB15_le (dest, s + x, width);
1242 #else
1243   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1244     video_orc_unpack_RGB15_be_trunc (dest, s + x, width);
1245   else
1246     video_orc_unpack_RGB15_be (dest, s + x, width);
1247 #endif
<a name="8" id="anc8"></a><span class="line-modified">1248     }</span>
1249 
1250 static void
1251 pack_RGB15 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1252     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1253     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1254     gint y, gint width)
1255 {
1256   guint16 *restrict d = GET_LINE (y);
1257 
1258 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1259   video_orc_pack_RGB15_le (d, src, width);
1260 #else
1261   video_orc_pack_RGB15_be (d, src, width);
1262 #endif
<a name="9" id="anc9"></a><span class="line-modified">1263   }</span>
1264 
1265 #define PACK_BGR15 GST_VIDEO_FORMAT_ARGB, unpack_BGR15, 1, pack_BGR15
1266 static void
1267 unpack_BGR15 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1268     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1269     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1270 {
1271   const guint16 *restrict s = GET_LINE (y);
1272 
1273 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1274   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1275     video_orc_unpack_BGR15_le_trunc (dest, s + x, width);
1276   else
1277     video_orc_unpack_BGR15_le (dest, s + x, width);
1278 #else
1279   if (flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)
1280     video_orc_unpack_BGR15_be_trunc (dest, s + x, width);
1281   else
1282     video_orc_unpack_BGR15_be (dest, s + x, width);
1283 #endif
<a name="10" id="anc10"></a><span class="line-modified">1284     }</span>
1285 
1286 static void
1287 pack_BGR15 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1288     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1289     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1290     gint y, gint width)
1291 {
1292   guint16 *restrict d = GET_LINE (y);
1293 
1294 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1295   video_orc_pack_BGR15_le (d, src, width);
1296 #else
1297   video_orc_pack_BGR15_be (d, src, width);
1298 #endif
<a name="11" id="anc11"></a><span class="line-modified">1299   }</span>
1300 
1301 #define PACK_BGRA GST_VIDEO_FORMAT_ARGB, unpack_BGRA, 1, pack_BGRA
1302 static void
1303 unpack_BGRA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1304     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1305     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1306 {
1307   const guint8 *restrict s = GET_LINE (y);
1308 
1309   s += x * 4;
1310 
1311   video_orc_unpack_BGRA (dest, s, width);
1312 }
1313 
1314 static void
1315 pack_BGRA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1316     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1317     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1318     gint y, gint width)
1319 {
1320   guint8 *restrict d = GET_LINE (y);
1321 
1322   video_orc_pack_BGRA (d, src, width);
1323 }
1324 
1325 #define PACK_ABGR GST_VIDEO_FORMAT_ARGB, unpack_ABGR, 1, pack_ABGR
1326 static void
1327 unpack_ABGR (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1328     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1329     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1330 {
1331   const guint8 *restrict s = GET_LINE (y);
1332 
1333   s += x * 4;
1334 
1335 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1336   video_orc_unpack_ABGR_le (dest, s, width);
1337 #else
1338   video_orc_unpack_ABGR_be (dest, s, width);
1339 #endif
1340 }
1341 
1342 static void
1343 pack_ABGR (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1344     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1345     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1346     gint y, gint width)
1347 {
1348   guint8 *restrict d = GET_LINE (y);
1349 
1350 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1351   video_orc_pack_ABGR_le (d, src, width);
1352 #else
1353   video_orc_pack_ABGR_be (d, src, width);
1354 #endif
1355 }
1356 
1357 #define PACK_RGBA GST_VIDEO_FORMAT_ARGB, unpack_RGBA, 1, pack_RGBA
1358 static void
1359 unpack_RGBA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1360     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1361     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1362 {
1363   const guint8 *restrict s = GET_LINE (y);
1364 
1365   s += x * 4;
1366 
1367 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1368   video_orc_unpack_RGBA_le (dest, s, width);
1369 #else
1370   video_orc_unpack_RGBA_be (dest, s, width);
1371 #endif
1372 }
1373 
1374 static void
1375 pack_RGBA (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1376     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1377     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1378     gint y, gint width)
1379 {
1380   guint8 *restrict d = GET_LINE (y);
1381 
1382 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
1383   video_orc_pack_RGBA_le (d, src, width);
1384 #else
1385   video_orc_pack_RGBA_be (d, src, width);
1386 #endif
1387 }
1388 
1389 #define PACK_RGB GST_VIDEO_FORMAT_ARGB, unpack_RGB, 1, pack_RGB
1390 static void
1391 unpack_RGB (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1392     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1393     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1394 {
1395   int i;
1396   const guint8 *restrict s = GET_LINE (y);
1397   guint8 *restrict d = dest;
1398 
1399   s += x * 3;
1400 
1401   for (i = 0; i &lt; width; i++) {
1402     d[i * 4 + 0] = 0xff;
1403     d[i * 4 + 1] = s[i * 3 + 0];
1404     d[i * 4 + 2] = s[i * 3 + 1];
1405     d[i * 4 + 3] = s[i * 3 + 2];
1406   }
1407 }
1408 
1409 static void
1410 pack_RGB (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1411     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1412     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1413     gint y, gint width)
1414 {
1415   int i;
1416   guint8 *restrict d = GET_LINE (y);
1417   const guint8 *restrict s = src;
1418 
1419   for (i = 0; i &lt; width; i++) {
1420     d[i * 3 + 0] = s[i * 4 + 1];
1421     d[i * 3 + 1] = s[i * 4 + 2];
1422     d[i * 3 + 2] = s[i * 4 + 3];
1423   }
1424 }
1425 
1426 #define PACK_BGR GST_VIDEO_FORMAT_ARGB, unpack_BGR, 1, pack_BGR
1427 static void
1428 unpack_BGR (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1429     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1430     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1431 {
1432   int i;
1433   const guint8 *restrict s = GET_LINE (y);
1434   guint8 *restrict d = dest;
1435 
1436   s += x * 3;
1437 
1438   for (i = 0; i &lt; width; i++) {
1439     d[i * 4 + 0] = 0xff;
1440     d[i * 4 + 1] = s[i * 3 + 2];
1441     d[i * 4 + 2] = s[i * 3 + 1];
1442     d[i * 4 + 3] = s[i * 3 + 0];
1443   }
1444 }
1445 
1446 static void
1447 pack_BGR (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1448     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1449     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1450     gint y, gint width)
1451 {
1452   int i;
1453   guint8 *restrict d = GET_LINE (y);
1454   const guint8 *restrict s = src;
1455 
1456   for (i = 0; i &lt; width; i++) {
1457     d[i * 3 + 0] = s[i * 4 + 3];
1458     d[i * 3 + 1] = s[i * 4 + 2];
1459     d[i * 3 + 2] = s[i * 4 + 1];
1460   }
1461 }
1462 
1463 #define PACK_NV12 GST_VIDEO_FORMAT_AYUV, unpack_NV12, 1, pack_NV12
1464 static void
1465 unpack_NV12 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1466     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1467     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1468 {
1469   gint uv = GET_UV_420 (y, flags);
1470   const guint8 *restrict sy = GET_PLANE_LINE (0, y);
1471   const guint8 *restrict suv = GET_PLANE_LINE (1, uv);
1472   guint8 *restrict d = dest;
1473 
1474   sy += x;
1475   suv += (x &amp; ~1);
1476 
1477   if (x &amp; 1) {
1478     d[0] = 0xff;
1479     d[1] = *sy++;
1480     d[2] = suv[0];
1481     d[3] = suv[1];
1482     width--;
1483     d += 4;
1484     suv += 2;
1485   }
1486 
1487   if (IS_ALIGNED (d, 8))
1488     video_orc_unpack_NV12 (d, sy, suv, width / 2);
1489   else {
1490     gint i;
1491     for (i = 0; i &lt; width / 2; i++) {
1492       d[i * 8 + 0] = 0xff;
1493       d[i * 8 + 1] = sy[i * 2 + 0];
1494       d[i * 8 + 2] = suv[i * 2 + 0];
1495       d[i * 8 + 3] = suv[i * 2 + 1];
1496       d[i * 8 + 4] = 0xff;
1497       d[i * 8 + 5] = sy[i * 2 + 1];
1498       d[i * 8 + 6] = suv[i * 2 + 0];
1499       d[i * 8 + 7] = suv[i * 2 + 1];
1500     }
1501   }
1502 
1503   if (width &amp; 1) {
1504     gint i = width - 1;
1505 
1506     d[i * 4 + 0] = 0xff;
1507     d[i * 4 + 1] = sy[i];
1508     d[i * 4 + 2] = suv[i + 0];
1509     d[i * 4 + 3] = suv[i + 1];
1510   }
1511 }
1512 
1513 static void
1514 pack_NV12 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1515     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1516     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1517     gint y, gint width)
1518 {
1519   gint uv = GET_UV_420 (y, flags);
1520   guint8 *restrict dy = GET_PLANE_LINE (0, y);
1521   guint8 *restrict duv = GET_PLANE_LINE (1, uv);
1522   const guint8 *restrict s = src;
1523 
1524   if (IS_CHROMA_LINE_420 (y, flags)) {
1525     if (IS_ALIGNED (s, 8))
1526       video_orc_pack_NV12 (dy, duv, s, width / 2);
1527     else {
1528       gint i;
1529       for (i = 0; i &lt; width / 2; i++) {
1530         dy[i * 2 + 0] = s[i * 8 + 1];
1531         dy[i * 2 + 1] = s[i * 8 + 5];
1532         duv[i * 2 + 0] = s[i * 8 + 2];
1533         duv[i * 2 + 1] = s[i * 8 + 3];
1534       }
1535     }
<a name="12" id="anc12"></a><span class="line-modified">1536   if (width &amp; 1) {</span>
<span class="line-modified">1537     gint i = width - 1;</span>
1538 
1539       dy[i] = s[i * 4 + 1];
1540       duv[i + 0] = s[i * 4 + 2];
1541       duv[i + 1] = s[i * 4 + 3];
<a name="13" id="anc13"></a><span class="line-modified">1542   }</span>
1543   } else
1544     video_orc_pack_Y (dy, s, width);
1545 }
1546 
1547 #define PACK_NV21 GST_VIDEO_FORMAT_AYUV, unpack_NV21, 1, pack_NV21
1548 static void
1549 unpack_NV21 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1550     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1551     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1552 {
1553   gint uv = GET_UV_420 (y, flags);
1554   const guint8 *restrict sy = GET_PLANE_LINE (0, y);
1555   const guint8 *restrict suv = GET_PLANE_LINE (1, uv);
1556   guint8 *restrict d = dest;
1557 
1558   sy += x;
1559   suv += (x &amp; ~1);
1560 
1561   if (x &amp; 1) {
1562     d[0] = 0xff;
1563     d[1] = *sy++;
1564     d[2] = suv[1];
1565     d[3] = suv[0];
1566     width--;
1567     d += 4;
1568     suv += 2;
1569   }
1570 
1571   if (IS_ALIGNED (d, 8))
1572     video_orc_unpack_NV21 (d, sy, suv, width / 2);
1573   else {
1574     gint i;
1575     for (i = 0; i &lt; width / 2; i++) {
1576       d[i * 8 + 0] = 0xff;
1577       d[i * 8 + 1] = sy[i * 2 + 0];
1578       d[i * 8 + 2] = suv[i * 2 + 1];
1579       d[i * 8 + 3] = suv[i * 2 + 0];
1580       d[i * 8 + 4] = 0xff;
1581       d[i * 8 + 5] = sy[i * 2 + 1];
1582       d[i * 8 + 6] = suv[i * 2 + 1];
1583       d[i * 8 + 7] = suv[i * 2 + 0];
1584     }
1585   }
1586 
1587   if (width &amp; 1) {
1588     gint i = width - 1;
1589 
1590     d[i * 4 + 0] = 0xff;
1591     d[i * 4 + 1] = sy[i];
1592     d[i * 4 + 2] = suv[i + 1];
1593     d[i * 4 + 3] = suv[i + 0];
1594   }
1595 }
1596 
1597 static void
1598 pack_NV21 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1599     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1600     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1601     gint y, gint width)
1602 {
1603   gint uv = GET_UV_420 (y, flags);
1604   guint8 *restrict dy = GET_PLANE_LINE (0, y);
1605   guint8 *restrict duv = GET_PLANE_LINE (1, uv);
1606   const guint8 *restrict s = src;
1607 
1608   if (IS_CHROMA_LINE_420 (y, flags)) {
1609     if (IS_ALIGNED (s, 8))
1610       video_orc_pack_NV21 (dy, duv, s, width / 2);
1611     else {
1612       gint i;
1613       for (i = 0; i &lt; width / 2; i++) {
1614         dy[i * 2 + 0] = s[i * 8 + 1];
1615         dy[i * 2 + 1] = s[i * 8 + 5];
1616         duv[i * 2 + 0] = s[i * 8 + 3];
1617         duv[i * 2 + 1] = s[i * 8 + 2];
1618       }
1619     }
<a name="14" id="anc14"></a><span class="line-modified">1620   if (width &amp; 1) {</span>
<span class="line-modified">1621     gint i = width - 1;</span>
1622 
1623       dy[i] = s[i * 4 + 1];
1624       duv[i + 0] = s[i * 4 + 3];
1625       duv[i + 1] = s[i * 4 + 2];
<a name="15" id="anc15"></a><span class="line-modified">1626   }</span>
1627   } else
1628     video_orc_pack_Y (dy, s, width);
1629 }
1630 
1631 #define PACK_NV16 GST_VIDEO_FORMAT_AYUV, unpack_NV16, 1, pack_NV16
1632 static void
1633 unpack_NV16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1634     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1635     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1636 {
1637   const guint8 *restrict sy = GET_PLANE_LINE (0, y);
1638   const guint8 *restrict suv = GET_PLANE_LINE (1, y);
1639   guint8 *restrict d = dest;
1640 
1641   sy += x;
1642   suv += (x &amp; ~1);
1643 
1644   if (x &amp; 1) {
1645     d[0] = 0xff;
1646     d[1] = *sy++;
1647     d[2] = suv[0];
1648     d[3] = suv[1];
1649     width--;
1650     d += 4;
1651     suv += 2;
1652   }
1653 
1654   if (IS_ALIGNED (d, 8))
1655     video_orc_unpack_NV12 (d, sy, suv, width / 2);
1656   else {
1657     gint i;
1658     for (i = 0; i &lt; width / 2; i++) {
1659       d[i * 8 + 0] = 0xff;
1660       d[i * 8 + 1] = sy[i * 2 + 0];
1661       d[i * 8 + 2] = suv[i * 2 + 0];
1662       d[i * 8 + 3] = suv[i * 2 + 1];
1663       d[i * 8 + 4] = 0xff;
1664       d[i * 8 + 5] = sy[i * 2 + 1];
1665       d[i * 8 + 6] = suv[i * 2 + 0];
1666       d[i * 8 + 7] = suv[i * 2 + 1];
1667     }
1668   }
1669 
1670   if (width &amp; 1) {
1671     gint i = width - 1;
1672 
1673     d[i * 4 + 0] = 0xff;
1674     d[i * 4 + 1] = sy[i];
1675     d[i * 4 + 2] = suv[i + 0];
1676     d[i * 4 + 3] = suv[i + 1];
1677   }
1678 }
1679 
1680 static void
1681 pack_NV16 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1682     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1683     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1684     gint y, gint width)
1685 {
1686   guint8 *restrict dy = GET_PLANE_LINE (0, y);
1687   guint8 *restrict duv = GET_PLANE_LINE (1, y);
1688   const guint8 *restrict s = src;
1689 
1690   if (IS_ALIGNED (s, 8))
1691     video_orc_pack_NV12 (dy, duv, s, width / 2);
1692   else {
1693     gint i;
1694     for (i = 0; i &lt; width / 2; i++) {
1695       dy[i * 2 + 0] = s[i * 8 + 1];
1696       dy[i * 2 + 1] = s[i * 8 + 5];
1697       duv[i * 2 + 0] = s[i * 8 + 2];
1698       duv[i * 2 + 1] = s[i * 8 + 3];
1699     }
1700   }
1701 
1702   if (width &amp; 1) {
1703     gint i = width - 1;
1704 
1705     dy[i] = s[i * 4 + 1];
1706     duv[i + 0] = s[i * 4 + 2];
1707     duv[i + 1] = s[i * 4 + 3];
1708   }
1709 }
1710 
1711 #define PACK_NV61 GST_VIDEO_FORMAT_AYUV, unpack_NV61, 1, pack_NV61
1712 static void
1713 unpack_NV61 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1714     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1715     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1716 {
1717   const guint8 *restrict sy = GET_PLANE_LINE (0, y);
1718   const guint8 *restrict svu = GET_PLANE_LINE (1, y);
1719   guint8 *restrict d = dest;
1720 
1721   sy += x;
1722   svu += (x &amp; ~1);
1723 
1724   if (x &amp; 1) {
1725     d[0] = 0xff;
1726     d[1] = *sy++;
1727     d[2] = svu[1];
1728     d[3] = svu[0];
1729     width--;
1730     d += 4;
1731     svu += 2;
1732   }
1733 
1734   if (IS_ALIGNED (d, 8)) {
1735     video_orc_unpack_NV21 (d, sy, svu, width / 2);
1736   } else {
1737     gint i;
1738 
1739     for (i = 0; i &lt; width / 2; i++) {
1740       d[i * 8 + 0] = 0xff;
1741       d[i * 8 + 1] = sy[i * 2 + 0];
1742       d[i * 8 + 2] = svu[i * 2 + 1];
1743       d[i * 8 + 3] = svu[i * 2 + 0];
1744       d[i * 8 + 4] = 0xff;
1745       d[i * 8 + 5] = sy[i * 2 + 1];
1746       d[i * 8 + 6] = svu[i * 2 + 1];
1747       d[i * 8 + 7] = svu[i * 2 + 0];
1748     }
1749   }
1750 
1751   if (width &amp; 1) {
1752     gint i = width - 1;
1753 
1754     d[i * 4 + 0] = 0xff;
1755     d[i * 4 + 1] = sy[i];
1756     d[i * 4 + 2] = svu[i + 1];
1757     d[i * 4 + 3] = svu[i + 0];
1758   }
1759 }
1760 
1761 static void
1762 pack_NV61 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1763     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1764     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1765     gint y, gint width)
1766 {
1767   const guint8 *restrict s = src;
1768   guint8 *restrict dy = GET_PLANE_LINE (0, y);
1769   guint8 *restrict dvu = GET_PLANE_LINE (1, y);
1770 
1771   if (IS_ALIGNED (s, 8)) {
1772     video_orc_pack_NV21 (dy, dvu, s, width / 2);
1773   } else {
1774     gint i;
1775 
1776     for (i = 0; i &lt; width / 2; i++) {
1777       dy[i * 2 + 0] = s[i * 8 + 1];
1778       dy[i * 2 + 1] = s[i * 8 + 5];
1779       dvu[i * 2 + 0] = s[i * 8 + 3];
1780       dvu[i * 2 + 1] = s[i * 8 + 2];
1781     }
1782   }
1783 
1784   if (width &amp; 1) {
1785     gint i = width - 1;
1786 
1787     dy[i] = s[i * 4 + 1];
1788     dvu[i + 0] = s[i * 4 + 2];
1789     dvu[i + 1] = s[i * 4 + 3];
1790   }
1791 }
1792 
1793 #define PACK_NV24 GST_VIDEO_FORMAT_AYUV, unpack_NV24, 1, pack_NV24
1794 static void
1795 unpack_NV24 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1796     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1797     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1798 {
1799   const guint8 *restrict sy = GET_PLANE_LINE (0, y);
1800   const guint8 *restrict suv = GET_PLANE_LINE (1, y);
1801 
1802   sy += x;
1803   suv += x &lt;&lt; 1;
1804 
1805   video_orc_unpack_NV24 (dest, sy, suv, width);
1806 }
1807 
1808 static void
1809 pack_NV24 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1810     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1811     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1812     gint y, gint width)
1813 {
1814   guint8 *restrict dy = GET_PLANE_LINE (0, y);
1815   guint8 *restrict duv = GET_PLANE_LINE (1, y);
1816 
1817   video_orc_pack_NV24 (dy, duv, src, width);
1818 }
1819 
1820 #define PACK_UYVP GST_VIDEO_FORMAT_AYUV64, unpack_UYVP, 1, pack_UYVP
1821 static void
1822 unpack_UYVP (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1823     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1824     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1825 {
1826   int i;
1827   const guint8 *restrict s = GET_LINE (y);
1828   guint16 *restrict d = dest;
1829 
1830   /* FIXME */
1831   s += x &lt;&lt; 1;
1832 
1833   for (i = 0; i &lt; width; i += 2) {
1834     guint16 y0, y1;
1835     guint16 u0;
1836     guint16 v0;
1837 
1838     u0 = ((s[(i / 2) * 5 + 0] &lt;&lt; 2) | (s[(i / 2) * 5 + 1] &gt;&gt; 6)) &lt;&lt; 6;
1839     y0 = (((s[(i / 2) * 5 + 1] &amp; 0x3f) &lt;&lt; 4) | (s[(i / 2) * 5 + 2] &gt;&gt; 4)) &lt;&lt; 6;
1840     v0 = (((s[(i / 2) * 5 + 2] &amp; 0x0f) &lt;&lt; 6) | (s[(i / 2) * 5 + 3] &gt;&gt; 2)) &lt;&lt; 6;
1841     y1 = (((s[(i / 2) * 5 + 3] &amp; 0x03) &lt;&lt; 8) | s[(i / 2) * 5 + 4]) &lt;&lt; 6;
1842 
1843     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
1844       y0 |= (y0 &gt;&gt; 10);
1845       y1 |= (y1 &gt;&gt; 10);
1846       u0 |= (u0 &gt;&gt; 10);
1847       v0 |= (v0 &gt;&gt; 10);
1848     }
1849 
1850     d[i * 4 + 0] = 0xffff;
1851     d[i * 4 + 1] = y0;
1852     d[i * 4 + 2] = u0;
1853     d[i * 4 + 3] = v0;
1854 
1855     if (i &lt; width - 1) {
1856       d[i * 4 + 4] = 0xffff;
1857       d[i * 4 + 5] = y1;
1858       d[i * 4 + 6] = u0;
1859       d[i * 4 + 7] = v0;
1860     }
1861   }
1862 }
1863 
1864 static void
1865 pack_UYVP (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1866     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1867     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1868     gint y, gint width)
1869 {
1870   int i;
1871   guint8 *restrict d = GET_LINE (y);
1872   const guint16 *restrict s = src;
1873 
1874   for (i = 0; i &lt; width; i += 2) {
1875     guint16 y0, y1;
1876     guint16 u0;
1877     guint16 v0;
1878 
1879     y0 = s[4 * (i + 0) + 1];
1880     if (i &lt; width - 1)
1881       y1 = s[4 * (i + 1) + 1];
1882     else
1883       y1 = y0;
1884 
1885     u0 = s[4 * (i + 0) + 2];
1886     v0 = s[4 * (i + 0) + 3];
1887 
1888     d[(i / 2) * 5 + 0] = u0 &gt;&gt; 8;
1889     d[(i / 2) * 5 + 1] = (u0 &amp; 0xc0) | y0 &gt;&gt; 10;
1890     d[(i / 2) * 5 + 2] = ((y0 &amp; 0x3c0) &gt;&gt; 2) | (v0 &gt;&gt; 12);
1891     d[(i / 2) * 5 + 3] = ((v0 &amp; 0xfc0) &gt;&gt; 4) | (y1 &gt;&gt; 14);
1892     d[(i / 2) * 5 + 4] = (y1 &gt;&gt; 6);
1893   }
1894 }
1895 
1896 #define PACK_A420 GST_VIDEO_FORMAT_AYUV, unpack_A420, 1, pack_A420
1897 static void
1898 unpack_A420 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1899     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1900     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1901 {
1902   gint uv = GET_UV_420 (y, flags);
1903   const guint8 *restrict sy = GET_Y_LINE (y);
1904   const guint8 *restrict su = GET_U_LINE (uv);
1905   const guint8 *restrict sv = GET_V_LINE (uv);
1906   const guint8 *restrict sa = GET_A_LINE (y);
1907   guint8 *restrict d = dest;
1908 
1909   sy += x;
1910   su += x &gt;&gt; 1;
1911   sv += x &gt;&gt; 1;
1912   sa += x;
1913 
1914   if (x &amp; 1) {
1915     d[0] = *sa++;
1916     d[1] = *sy++;
1917     d[2] = *su++;
1918     d[3] = *sv++;
1919     width--;
1920     d += 4;
<a name="16" id="anc16"></a><span class="line-modified">1921 }</span>
1922   video_orc_unpack_A420 (d, sy, su, sv, sa, width);
1923 }
1924 
1925 static void
1926 pack_A420 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1927     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
1928     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
1929     gint y, gint width)
1930 {
1931   gint uv = GET_UV_420 (y, flags);
1932   guint8 *restrict dy = GET_Y_LINE (y);
1933   guint8 *restrict du = GET_U_LINE (uv);
1934   guint8 *restrict dv = GET_V_LINE (uv);
1935   guint8 *restrict da = GET_A_LINE (y);
1936   const guint8 *restrict s = src;
1937 
1938   if (IS_CHROMA_LINE_420 (y, flags)) {
1939     if (IS_ALIGNED (s, 8))
1940       video_orc_pack_A420 (dy, du, dv, da, s, width / 2);
1941     else {
1942       gint i;
1943       for (i = 0; i &lt; width / 2; i++) {
1944         da[i * 2 + 0] = s[i * 8 + 0];
1945         dy[i * 2 + 0] = s[i * 8 + 1];
1946         da[i * 2 + 1] = s[i * 8 + 4];
1947         dy[i * 2 + 1] = s[i * 8 + 5];
1948         du[i] = s[i * 8 + 2];
1949         dv[i] = s[i * 8 + 3];
1950       }
1951     }
1952 
<a name="17" id="anc17"></a><span class="line-modified">1953   if (width &amp; 1) {</span>
<span class="line-modified">1954     gint i = width - 1;</span>
1955 
1956       da[i] = s[i * 4 + 0];
1957       dy[i] = s[i * 4 + 1];
1958       du[i &gt;&gt; 1] = s[i * 4 + 2];
1959       dv[i &gt;&gt; 1] = s[i * 4 + 3];
<a name="18" id="anc18"></a><span class="line-modified">1960   }</span>
1961   } else
1962     video_orc_pack_AY (dy, da, s, width);
1963 }
1964 
1965 #define PACK_RGB8P GST_VIDEO_FORMAT_ARGB, unpack_RGB8P, 1, pack_RGB8P
1966 static void
1967 unpack_RGB8P (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
1968     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
1969     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
1970 {
1971   int i;
1972   const guint8 *restrict s = GET_LINE (y);
1973   const guint32 *restrict p = data[1];
1974   guint8 *restrict d = dest;
1975 
1976   s += x;
1977 
1978   for (i = 0; i &lt; width; i++) {
1979     guint32 v = p[s[i]];
1980     d[i * 4 + 0] = (v &gt;&gt; 24) &amp; 0xff;
1981     d[i * 4 + 1] = (v &gt;&gt; 16) &amp; 0xff;
1982     d[i * 4 + 2] = (v &gt;&gt; 8) &amp; 0xff;
1983     d[i * 4 + 3] = (v) &amp; 0xff;
1984   }
1985 }
1986 
1987 static const guint32 std_palette_RGB8P[] = {
1988   0xff000000, 0xff000033, 0xff000066, 0xff000099, 0xff0000cc, 0xff0000ff,
1989   0xff003300, 0xff003333, 0xff003366, 0xff003399, 0xff0033cc, 0xff0033ff,
1990   0xff006600, 0xff006633, 0xff006666, 0xff006699, 0xff0066cc, 0xff0066ff,
1991   0xff009900, 0xff009933, 0xff009966, 0xff009999, 0xff0099cc, 0xff0099ff,
1992   0xff00cc00, 0xff00cc33, 0xff00cc66, 0xff00cc99, 0xff00cccc, 0xff00ccff,
1993   0xff00ff00, 0xff00ff33, 0xff00ff66, 0xff00ff99, 0xff00ffcc, 0xff00ffff,
1994   0xff330000, 0xff330033, 0xff330066, 0xff330099, 0xff3300cc, 0xff3300ff,
1995   0xff333300, 0xff333333, 0xff333366, 0xff333399, 0xff3333cc, 0xff3333ff,
1996   0xff336600, 0xff336633, 0xff336666, 0xff336699, 0xff3366cc, 0xff3366ff,
1997   0xff339900, 0xff339933, 0xff339966, 0xff339999, 0xff3399cc, 0xff3399ff,
1998   0xff33cc00, 0xff33cc33, 0xff33cc66, 0xff33cc99, 0xff33cccc, 0xff33ccff,
1999   0xff33ff00, 0xff33ff33, 0xff33ff66, 0xff33ff99, 0xff33ffcc, 0xff33ffff,
2000   0xff660000, 0xff660033, 0xff660066, 0xff660099, 0xff6600cc, 0xff6600ff,
2001   0xff663300, 0xff663333, 0xff663366, 0xff663399, 0xff6633cc, 0xff6633ff,
2002   0xff666600, 0xff666633, 0xff666666, 0xff666699, 0xff6666cc, 0xff6666ff,
2003   0xff669900, 0xff669933, 0xff669966, 0xff669999, 0xff6699cc, 0xff6699ff,
2004   0xff66cc00, 0xff66cc33, 0xff66cc66, 0xff66cc99, 0xff66cccc, 0xff66ccff,
2005   0xff66ff00, 0xff66ff33, 0xff66ff66, 0xff66ff99, 0xff66ffcc, 0xff66ffff,
2006   0xff990000, 0xff990033, 0xff990066, 0xff990099, 0xff9900cc, 0xff9900ff,
2007   0xff993300, 0xff993333, 0xff993366, 0xff993399, 0xff9933cc, 0xff9933ff,
2008   0xff996600, 0xff996633, 0xff996666, 0xff996699, 0xff9966cc, 0xff9966ff,
2009   0xff999900, 0xff999933, 0xff999966, 0xff999999, 0xff9999cc, 0xff9999ff,
2010   0xff99cc00, 0xff99cc33, 0xff99cc66, 0xff99cc99, 0xff99cccc, 0xff99ccff,
2011   0xff99ff00, 0xff99ff33, 0xff99ff66, 0xff99ff99, 0xff99ffcc, 0xff99ffff,
2012   0xffcc0000, 0xffcc0033, 0xffcc0066, 0xffcc0099, 0xffcc00cc, 0xffcc00ff,
2013   0xffcc3300, 0xffcc3333, 0xffcc3366, 0xffcc3399, 0xffcc33cc, 0xffcc33ff,
2014   0xffcc6600, 0xffcc6633, 0xffcc6666, 0xffcc6699, 0xffcc66cc, 0xffcc66ff,
2015   0xffcc9900, 0xffcc9933, 0xffcc9966, 0xffcc9999, 0xffcc99cc, 0xffcc99ff,
2016   0xffcccc00, 0xffcccc33, 0xffcccc66, 0xffcccc99, 0xffcccccc, 0xffccccff,
2017   0xffccff00, 0xffccff33, 0xffccff66, 0xffccff99, 0xffccffcc, 0xffccffff,
2018   0xffff0000, 0xffff0033, 0xffff0066, 0xffff0099, 0xffff00cc, 0xffff00ff,
2019   0xffff3300, 0xffff3333, 0xffff3366, 0xffff3399, 0xffff33cc, 0xffff33ff,
2020   0xffff6600, 0xffff6633, 0xffff6666, 0xffff6699, 0xffff66cc, 0xffff66ff,
2021   0xffff9900, 0xffff9933, 0xffff9966, 0xffff9999, 0xffff99cc, 0xffff99ff,
2022   0xffffcc00, 0xffffcc33, 0xffffcc66, 0xffffcc99, 0xffffcccc, 0xffffccff,
2023   0xffffff00, 0xffffff33, 0xffffff66, 0xffffff99, 0xffffffcc, 0xffffffff,
2024   0x00000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000,
2025   0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000,
2026   0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000,
2027   0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000,
2028   0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000,
2029   0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000, 0xff000000,
2030   0xff000000, 0xff000000, 0xff000000, 0xff000000
2031 };
2032 
2033 static void
2034 pack_RGB8P (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2035     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2036     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2037     gint y, gint width)
2038 {
2039   int i;
2040   guint8 *restrict d = GET_LINE (y);
2041   const guint8 *restrict s = src;
2042 
2043   /* Use our poor man&#39;s palette, taken from ffmpegcolorspace too */
2044   for (i = 0; i &lt; width; i++) {
2045     /* crude approximation for alpha ! */
2046     if (s[i * 4 + 0] &lt; 0x80)
2047       d[i] = 6 * 6 * 6;
2048     else
2049       d[i] =
2050           ((((s[i * 4 + 1]) / 47) % 6) * 6 * 6 + (((s[i * 4 +
2051                           2]) / 47) % 6) * 6 + (((s[i * 4 + 3]) / 47) % 6));
2052   }
2053 }
2054 
2055 #define PACK_410 GST_VIDEO_FORMAT_AYUV, unpack_410, 1, pack_410
2056 static void
2057 unpack_410 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2058     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2059     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2060 {
2061   gint uv = GET_UV_410 (y, flags);
2062   const guint8 *restrict sy = GET_Y_LINE (y);
2063   const guint8 *restrict su = GET_U_LINE (uv);
2064   const guint8 *restrict sv = GET_V_LINE (uv);
2065   guint8 *restrict d = dest;
2066 
2067   sy += x;
2068   su += x &gt;&gt; 2;
2069   sv += x &gt;&gt; 2;
2070 
2071   if (x &amp; 3) {
2072     for (; x &amp; 3; x++) {
2073       d[0] = 0xff;
2074       d[1] = *sy++;
2075       d[2] = *su;
2076       d[3] = *sv;
2077       width--;
2078       d += 4;
2079     }
2080     su++;
2081     sy++;
2082   }
2083 
2084   if (IS_ALIGNED (d, 8))
2085     video_orc_unpack_YUV9 (d, sy, su, sv, width / 2);
2086   else {
2087     gint i;
2088     for (i = 0; i &lt; width / 2; i++) {
2089       d[i * 8 + 0] = 0xff;
2090       d[i * 8 + 1] = sy[i * 2 + 0];
2091       d[i * 8 + 2] = su[i &gt;&gt; 1];
2092       d[i * 8 + 3] = sv[i &gt;&gt; 1];
2093       d[i * 8 + 4] = 0xff;
2094       d[i * 8 + 5] = sy[i * 2 + 1];
2095       d[i * 8 + 6] = su[i &gt;&gt; 1];
2096       d[i * 8 + 7] = sv[i &gt;&gt; 1];
2097     }
2098   }
2099 
2100   if (width &amp; 1) {
2101     gint i = width - 1;
2102 
2103     d[i * 4 + 0] = 0xff;
2104     d[i * 4 + 1] = sy[i];
2105     d[i * 4 + 2] = su[i &gt;&gt; 2];
2106     d[i * 4 + 3] = sv[i &gt;&gt; 2];
2107   }
2108 }
2109 
2110 static void
2111 pack_410 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2112     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2113     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2114     gint y, gint width)
2115 {
2116   int i;
2117   gint uv = GET_UV_410 (y, flags);
2118   guint8 *restrict dy = GET_Y_LINE (y);
2119   guint8 *restrict du = GET_U_LINE (uv);
2120   guint8 *restrict dv = GET_V_LINE (uv);
2121   const guint8 *restrict s = src;
2122 
2123   for (i = 0; i &lt; width - 3; i += 4) {
2124     dy[i] = s[i * 4 + 1];
2125     dy[i + 1] = s[i * 4 + 5];
2126     dy[i + 2] = s[i * 4 + 9];
2127     dy[i + 3] = s[i * 4 + 13];
2128     if (IS_CHROMA_LINE_410 (y, flags)) {
2129       du[i &gt;&gt; 2] = s[i * 4 + 2];
2130       dv[i &gt;&gt; 2] = s[i * 4 + 3];
2131     }
2132   }
2133   if (i &lt; width) {
2134     dy[i] = s[i * 4 + 1];
2135     if (IS_CHROMA_LINE_410 (y, flags)) {
2136       du[i &gt;&gt; 2] = s[i * 4 + 2];
2137       dv[i &gt;&gt; 2] = s[i * 4 + 3];
2138     }
2139     if (i &lt; width - 1)
2140       dy[i + 1] = s[i * 4 + 5];
2141     if (i &lt; width - 2)
2142       dy[i + 2] = s[i * 4 + 9];
2143   }
2144 }
2145 
2146 #define PACK_IYU1 GST_VIDEO_FORMAT_AYUV, unpack_IYU1, 1, pack_IYU1
2147 static void
2148 unpack_IYU1 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2149     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2150     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2151 {
2152   int i;
2153   const guint8 *restrict s = GET_LINE (y);
2154   guint8 *restrict d = dest;
2155   guint8 y0, y1, y2, y3;
2156   guint8 u0;
2157   guint8 v0;
2158 
2159   /* FIXME */
2160   s += x * 4;
2161 
2162   for (i = 0; i &lt; width - 3; i += 4) {
2163     y0 = s[(i &gt;&gt; 2) * 6 + 1];
2164     y1 = s[(i &gt;&gt; 2) * 6 + 2];
2165     y2 = s[(i &gt;&gt; 2) * 6 + 4];
2166     y3 = s[(i &gt;&gt; 2) * 6 + 5];
2167 
2168     u0 = s[(i &gt;&gt; 2) * 6 + 0];
2169     v0 = s[(i &gt;&gt; 2) * 6 + 3];
2170 
2171     d[i * 4 + 0] = 0xff;
2172     d[i * 4 + 1] = y0;
2173     d[i * 4 + 2] = u0;
2174     d[i * 4 + 3] = v0;
2175 
2176     d[i * 4 + 4] = 0xff;
2177     d[i * 4 + 5] = y1;
2178     d[i * 4 + 6] = u0;
2179     d[i * 4 + 7] = v0;
2180 
2181     d[i * 4 + 8] = 0xff;
2182     d[i * 4 + 9] = y2;
2183     d[i * 4 + 10] = u0;
2184     d[i * 4 + 11] = v0;
2185 
2186     d[i * 4 + 12] = 0xff;
2187     d[i * 4 + 13] = y3;
2188     d[i * 4 + 14] = u0;
2189     d[i * 4 + 15] = v0;
2190   }
2191   if (i &lt; width) {
2192     u0 = s[(i &gt;&gt; 2) * 6 + 0];
2193     v0 = s[(i &gt;&gt; 2) * 6 + 3];
2194 
2195     d[i * 4 + 0] = 0xff;
2196     d[i * 4 + 1] = s[(i &gt;&gt; 2) * 6 + 1];
2197     d[i * 4 + 2] = u0;
2198     d[i * 4 + 3] = v0;
2199 
2200     if (i &lt; width - 1) {
2201       d[i * 4 + 4] = 0xff;
2202       d[i * 4 + 5] = s[(i &gt;&gt; 2) * 6 + 2];
2203       d[i * 4 + 6] = u0;
2204       d[i * 4 + 7] = v0;
2205     }
2206     if (i &lt; width - 2) {
2207       d[i * 4 + 8] = 0xff;
2208       d[i * 4 + 9] = s[(i &gt;&gt; 2) * 6 + 4];
2209       d[i * 4 + 10] = u0;
2210       d[i * 4 + 11] = v0;
2211     }
2212   }
2213 }
2214 
2215 static void
2216 pack_IYU1 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2217     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2218     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2219     gint y, gint width)
2220 {
2221   int i;
2222   guint8 *restrict d = GET_LINE (y);
2223   const guint8 *restrict s = src;
2224 
2225   for (i = 0; i &lt; width - 3; i += 4) {
2226     d[(i &gt;&gt; 2) * 6 + 0] = s[i * 4 + 2];
2227     d[(i &gt;&gt; 2) * 6 + 1] = s[i * 4 + 1];
2228     d[(i &gt;&gt; 2) * 6 + 2] = s[i * 4 + 5];
2229     d[(i &gt;&gt; 2) * 6 + 3] = s[i * 4 + 3];
2230     d[(i &gt;&gt; 2) * 6 + 4] = s[i * 4 + 9];
2231     d[(i &gt;&gt; 2) * 6 + 5] = s[i * 4 + 13];
2232   }
2233   if (i &lt; width) {
2234     d[(i &gt;&gt; 2) * 6 + 1] = s[i * 4 + 1];
2235     d[(i &gt;&gt; 2) * 6 + 0] = s[i * 4 + 2];
2236     d[(i &gt;&gt; 2) * 6 + 3] = s[i * 4 + 3];
2237     if (i &lt; width - 1)
2238       d[(i &gt;&gt; 2) * 6 + 2] = s[i * 4 + 5];
2239     if (i &lt; width - 2)
2240       d[(i &gt;&gt; 2) * 6 + 4] = s[i * 4 + 9];
2241   }
2242 }
2243 
2244 #define PACK_ARGB64 GST_VIDEO_FORMAT_ARGB64, unpack_copy8, 1, pack_copy8
2245 #define PACK_AYUV64 GST_VIDEO_FORMAT_AYUV64, unpack_copy8, 1, pack_copy8
2246 static void
2247 unpack_copy8 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2248     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2249     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2250 {
2251   const guint8 *s = GET_LINE (y);
2252 
2253   s += x * 8;
2254 
2255   memcpy (dest, s, width * 8);
2256 }
2257 
2258 static void
2259 pack_copy8 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2260     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2261     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2262     gint y, gint width)
2263 {
2264   guint8 *restrict d = GET_LINE (y);
2265 
2266   memcpy (d, src, width * 8);
2267 }
2268 
2269 #define PACK_r210 GST_VIDEO_FORMAT_ARGB64, unpack_r210, 1, pack_r210
2270 static void
2271 unpack_r210 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2272     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2273     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2274 {
2275   int i;
2276   const guint8 *restrict s = GET_LINE (y);
2277   guint16 *restrict d = dest, R, G, B;
2278 
2279   s += x * 4;
2280 
2281   for (i = 0; i &lt; width; i++) {
2282     guint32 x = GST_READ_UINT32_BE (s + i * 4);
2283 
2284     R = ((x &gt;&gt; 14) &amp; 0xffc0);
2285     G = ((x &gt;&gt; 4) &amp; 0xffc0);
2286     B = ((x &lt;&lt; 6) &amp; 0xffc0);
2287 
2288     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2289       R |= (R &gt;&gt; 10);
2290       G |= (G &gt;&gt; 10);
2291       B |= (B &gt;&gt; 10);
2292     }
2293 
2294     d[i * 4 + 0] = 0xffff;
2295     d[i * 4 + 1] = R;
2296     d[i * 4 + 2] = G;
2297     d[i * 4 + 3] = B;
2298   }
2299 }
2300 
2301 static void
2302 pack_r210 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2303     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2304     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2305     gint y, gint width)
2306 {
2307   int i;
2308   guint8 *restrict d = GET_LINE (y);
2309   const guint16 *restrict s = src;
2310 
2311   for (i = 0; i &lt; width; i++) {
2312     guint32 x = 0;
2313     x |= (s[i * 4 + 1] &amp; 0xffc0) &lt;&lt; 14;
2314     x |= (s[i * 4 + 2] &amp; 0xffc0) &lt;&lt; 4;
2315     x |= (s[i * 4 + 3] &amp; 0xffc0) &gt;&gt; 6;
2316     GST_WRITE_UINT32_BE (d + i * 4, x);
2317   }
2318 }
2319 
2320 #define PACK_GBR_10LE GST_VIDEO_FORMAT_ARGB64, unpack_GBR_10LE, 1, pack_GBR_10LE
2321 static void
2322 unpack_GBR_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2323     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2324     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2325 {
2326   int i;
2327   const guint16 *sg = GET_G_LINE (y);
2328   const guint16 *sb = GET_B_LINE (y);
2329   const guint16 *sr = GET_R_LINE (y);
2330   guint16 *d = dest, G, B, R;
2331 
2332   sg += x;
2333   sb += x;
2334   sr += x;
2335 
2336   for (i = 0; i &lt; width; i++) {
2337     G = GST_READ_UINT16_LE (sg + i) &lt;&lt; 6;
2338     B = GST_READ_UINT16_LE (sb + i) &lt;&lt; 6;
2339     R = GST_READ_UINT16_LE (sr + i) &lt;&lt; 6;
2340 
2341     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2342       R |= (R &gt;&gt; 10);
2343       G |= (G &gt;&gt; 10);
2344       B |= (B &gt;&gt; 10);
2345     }
2346 
2347     d[i * 4 + 0] = 0xffff;
2348     d[i * 4 + 1] = R;
2349     d[i * 4 + 2] = G;
2350     d[i * 4 + 3] = B;
2351   }
2352 }
2353 
2354 static void
2355 pack_GBR_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2356     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2357     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2358     gint y, gint width)
2359 {
2360   int i;
2361   guint16 *restrict dg = GET_G_LINE (y);
2362   guint16 *restrict db = GET_B_LINE (y);
2363   guint16 *restrict dr = GET_R_LINE (y);
2364   guint16 G, B, R;
2365   const guint16 *restrict s = src;
2366 
2367   for (i = 0; i &lt; width; i++) {
2368     G = (s[i * 4 + 2]) &gt;&gt; 6;
2369     B = (s[i * 4 + 3]) &gt;&gt; 6;
2370     R = (s[i * 4 + 1]) &gt;&gt; 6;
2371 
2372     GST_WRITE_UINT16_LE (dg + i, G);
2373     GST_WRITE_UINT16_LE (db + i, B);
2374     GST_WRITE_UINT16_LE (dr + i, R);
2375   }
2376 }
2377 
2378 #define PACK_GBR_10BE GST_VIDEO_FORMAT_ARGB64, unpack_GBR_10BE, 1, pack_GBR_10BE
2379 static void
2380 unpack_GBR_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2381     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2382     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2383 {
2384   int i;
2385   const guint16 *restrict sg = GET_G_LINE (y);
2386   const guint16 *restrict sb = GET_B_LINE (y);
2387   const guint16 *restrict sr = GET_R_LINE (y);
2388   guint16 *restrict d = dest, G, B, R;
2389 
2390   sg += x;
2391   sb += x;
2392   sr += x;
2393 
2394   for (i = 0; i &lt; width; i++) {
2395     G = GST_READ_UINT16_BE (sg + i) &lt;&lt; 6;
2396     B = GST_READ_UINT16_BE (sb + i) &lt;&lt; 6;
2397     R = GST_READ_UINT16_BE (sr + i) &lt;&lt; 6;
2398 
2399     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2400       R |= (R &gt;&gt; 10);
2401       G |= (G &gt;&gt; 10);
2402       B |= (B &gt;&gt; 10);
2403     }
2404 
2405     d[i * 4 + 0] = 0xffff;
2406     d[i * 4 + 1] = R;
2407     d[i * 4 + 2] = G;
2408     d[i * 4 + 3] = B;
2409   }
2410 }
2411 
2412 static void
2413 pack_GBR_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2414     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2415     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2416     gint y, gint width)
2417 {
2418   int i;
2419   guint16 *restrict dg = GET_G_LINE (y);
2420   guint16 *restrict db = GET_B_LINE (y);
2421   guint16 *restrict dr = GET_R_LINE (y);
2422   guint16 G, B, R;
2423   const guint16 *restrict s = src;
2424 
2425   for (i = 0; i &lt; width; i++) {
2426     G = s[i * 4 + 2] &gt;&gt; 6;
2427     B = s[i * 4 + 3] &gt;&gt; 6;
2428     R = s[i * 4 + 1] &gt;&gt; 6;
2429 
2430     GST_WRITE_UINT16_BE (dg + i, G);
2431     GST_WRITE_UINT16_BE (db + i, B);
2432     GST_WRITE_UINT16_BE (dr + i, R);
2433   }
2434 }
2435 
2436 #define PACK_GBRA_10LE GST_VIDEO_FORMAT_ARGB64, unpack_GBRA_10LE, 1, pack_GBRA_10LE
2437 static void
2438 unpack_GBRA_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2439     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2440     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2441 {
2442   int i;
2443   const guint16 *sg = GET_G_LINE (y);
2444   const guint16 *sb = GET_B_LINE (y);
2445   const guint16 *sr = GET_R_LINE (y);
2446   const guint16 *sa = GET_A_LINE (y);
2447   guint16 *d = dest, G, B, R, A;
2448 
2449   sg += x;
2450   sb += x;
2451   sr += x;
2452   sa += x;
2453 
2454   for (i = 0; i &lt; width; i++) {
2455     G = GST_READ_UINT16_LE (sg + i) &lt;&lt; 6;
2456     B = GST_READ_UINT16_LE (sb + i) &lt;&lt; 6;
2457     R = GST_READ_UINT16_LE (sr + i) &lt;&lt; 6;
2458     A = GST_READ_UINT16_LE (sa + i) &lt;&lt; 6;
2459 
2460     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2461       R |= (R &gt;&gt; 10);
2462       G |= (G &gt;&gt; 10);
2463       B |= (B &gt;&gt; 10);
2464       A |= (A &gt;&gt; 10);
2465     }
2466 
2467     d[i * 4 + 0] = A;
2468     d[i * 4 + 1] = R;
2469     d[i * 4 + 2] = G;
2470     d[i * 4 + 3] = B;
2471   }
2472 }
2473 
2474 static void
2475 pack_GBRA_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2476     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2477     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2478     gint y, gint width)
2479 {
2480   int i;
2481   guint16 *restrict dg = GET_G_LINE (y);
2482   guint16 *restrict db = GET_B_LINE (y);
2483   guint16 *restrict dr = GET_R_LINE (y);
2484   guint16 *restrict da = GET_A_LINE (y);
2485   guint16 G, B, R, A;
2486   const guint16 *restrict s = src;
2487 
2488   for (i = 0; i &lt; width; i++) {
2489     G = (s[i * 4 + 2]) &gt;&gt; 6;
2490     B = (s[i * 4 + 3]) &gt;&gt; 6;
2491     R = (s[i * 4 + 1]) &gt;&gt; 6;
2492     A = (s[i * 4 + 0]) &gt;&gt; 6;
2493 
2494     GST_WRITE_UINT16_LE (dg + i, G);
2495     GST_WRITE_UINT16_LE (db + i, B);
2496     GST_WRITE_UINT16_LE (dr + i, R);
2497     GST_WRITE_UINT16_LE (da + i, A);
2498   }
2499 }
2500 
2501 #define PACK_GBRA_10BE GST_VIDEO_FORMAT_ARGB64, unpack_GBRA_10BE, 1, pack_GBRA_10BE
2502 static void
2503 unpack_GBRA_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2504     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2505     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2506 {
2507   int i;
2508   const guint16 *restrict sg = GET_G_LINE (y);
2509   const guint16 *restrict sb = GET_B_LINE (y);
2510   const guint16 *restrict sr = GET_R_LINE (y);
2511   const guint16 *restrict sa = GET_A_LINE (y);
2512   guint16 *restrict d = dest, G, B, R, A;
2513 
2514   sg += x;
2515   sb += x;
2516   sr += x;
2517   sa += x;
2518 
2519   for (i = 0; i &lt; width; i++) {
2520     G = GST_READ_UINT16_BE (sg + i) &lt;&lt; 6;
2521     B = GST_READ_UINT16_BE (sb + i) &lt;&lt; 6;
2522     R = GST_READ_UINT16_BE (sr + i) &lt;&lt; 6;
2523     A = GST_READ_UINT16_BE (sa + i) &lt;&lt; 6;
2524 
2525     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2526       R |= (R &gt;&gt; 10);
2527       G |= (G &gt;&gt; 10);
2528       B |= (B &gt;&gt; 10);
2529       A |= (A &gt;&gt; 10);
2530     }
2531 
2532     d[i * 4 + 0] = A;
2533     d[i * 4 + 1] = R;
2534     d[i * 4 + 2] = G;
2535     d[i * 4 + 3] = B;
2536   }
2537 }
2538 
2539 static void
2540 pack_GBRA_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2541     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2542     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2543     gint y, gint width)
2544 {
2545   int i;
2546   guint16 *restrict dg = GET_G_LINE (y);
2547   guint16 *restrict db = GET_B_LINE (y);
2548   guint16 *restrict dr = GET_R_LINE (y);
2549   guint16 *restrict da = GET_A_LINE (y);
2550   guint16 G, B, R, A;
2551   const guint16 *restrict s = src;
2552 
2553   for (i = 0; i &lt; width; i++) {
2554     G = s[i * 4 + 2] &gt;&gt; 6;
2555     B = s[i * 4 + 3] &gt;&gt; 6;
2556     R = s[i * 4 + 1] &gt;&gt; 6;
2557     A = s[i * 4 + 0] &gt;&gt; 6;
2558 
2559     GST_WRITE_UINT16_BE (dg + i, G);
2560     GST_WRITE_UINT16_BE (db + i, B);
2561     GST_WRITE_UINT16_BE (dr + i, R);
2562     GST_WRITE_UINT16_BE (da + i, A);
2563   }
2564 }
2565 
2566 #define PACK_GBR_12LE GST_VIDEO_FORMAT_ARGB64, unpack_GBR_12LE, 1, pack_GBR_12LE
2567 static void
2568 unpack_GBR_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2569     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2570     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2571 {
2572   int i;
2573   const guint16 *sg = GET_G_LINE (y);
2574   const guint16 *sb = GET_B_LINE (y);
2575   const guint16 *sr = GET_R_LINE (y);
2576   guint16 *d = dest, G, B, R;
2577 
2578   sg += x;
2579   sb += x;
2580   sr += x;
2581 
2582   for (i = 0; i &lt; width; i++) {
2583     G = GST_READ_UINT16_LE (sg + i) &lt;&lt; 4;
2584     B = GST_READ_UINT16_LE (sb + i) &lt;&lt; 4;
2585     R = GST_READ_UINT16_LE (sr + i) &lt;&lt; 4;
2586 
2587     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2588       R |= (R &gt;&gt; 12);
2589       G |= (G &gt;&gt; 12);
2590       B |= (B &gt;&gt; 12);
2591     }
2592 
2593     d[i * 4 + 0] = 0xffff;
2594     d[i * 4 + 1] = R;
2595     d[i * 4 + 2] = G;
2596     d[i * 4 + 3] = B;
2597   }
2598 }
2599 
2600 static void
2601 pack_GBR_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2602     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2603     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2604     gint y, gint width)
2605 {
2606   int i;
2607   guint16 *restrict dg = GET_G_LINE (y);
2608   guint16 *restrict db = GET_B_LINE (y);
2609   guint16 *restrict dr = GET_R_LINE (y);
2610   guint16 G, B, R;
2611   const guint16 *restrict s = src;
2612 
2613   for (i = 0; i &lt; width; i++) {
2614     G = (s[i * 4 + 2]) &gt;&gt; 4;
2615     B = (s[i * 4 + 3]) &gt;&gt; 4;
2616     R = (s[i * 4 + 1]) &gt;&gt; 4;
2617 
2618     GST_WRITE_UINT16_LE (dg + i, G);
2619     GST_WRITE_UINT16_LE (db + i, B);
2620     GST_WRITE_UINT16_LE (dr + i, R);
2621   }
2622 }
2623 
2624 #define PACK_GBR_12BE GST_VIDEO_FORMAT_ARGB64, unpack_GBR_12BE, 1, pack_GBR_12BE
2625 static void
2626 unpack_GBR_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2627     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2628     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2629 {
2630   int i;
2631   const guint16 *restrict sg = GET_G_LINE (y);
2632   const guint16 *restrict sb = GET_B_LINE (y);
2633   const guint16 *restrict sr = GET_R_LINE (y);
2634   guint16 *restrict d = dest, G, B, R;
2635 
2636   sg += x;
2637   sb += x;
2638   sr += x;
2639 
2640   for (i = 0; i &lt; width; i++) {
2641     G = GST_READ_UINT16_BE (sg + i) &lt;&lt; 4;
2642     B = GST_READ_UINT16_BE (sb + i) &lt;&lt; 4;
2643     R = GST_READ_UINT16_BE (sr + i) &lt;&lt; 4;
2644 
2645     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2646       R |= (R &gt;&gt; 12);
2647       G |= (G &gt;&gt; 12);
2648       B |= (B &gt;&gt; 12);
2649     }
2650 
2651     d[i * 4 + 0] = 0xffff;
2652     d[i * 4 + 1] = R;
2653     d[i * 4 + 2] = G;
2654     d[i * 4 + 3] = B;
2655   }
2656 }
2657 
2658 static void
2659 pack_GBR_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2660     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2661     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2662     gint y, gint width)
2663 {
2664   int i;
2665   guint16 *restrict dg = GET_G_LINE (y);
2666   guint16 *restrict db = GET_B_LINE (y);
2667   guint16 *restrict dr = GET_R_LINE (y);
2668   guint16 G, B, R;
2669   const guint16 *restrict s = src;
2670 
2671   for (i = 0; i &lt; width; i++) {
2672     G = s[i * 4 + 2] &gt;&gt; 4;
2673     B = s[i * 4 + 3] &gt;&gt; 4;
2674     R = s[i * 4 + 1] &gt;&gt; 4;
2675 
2676     GST_WRITE_UINT16_BE (dg + i, G);
2677     GST_WRITE_UINT16_BE (db + i, B);
2678     GST_WRITE_UINT16_BE (dr + i, R);
2679   }
2680 }
2681 
2682 #define PACK_GBRA_12LE GST_VIDEO_FORMAT_ARGB64, unpack_GBRA_12LE, 1, pack_GBRA_12LE
2683 static void
2684 unpack_GBRA_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2685     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2686     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2687 {
2688   int i;
2689   const guint16 *sg = GET_G_LINE (y);
2690   const guint16 *sb = GET_B_LINE (y);
2691   const guint16 *sr = GET_R_LINE (y);
2692   const guint16 *sa = GET_A_LINE (y);
2693   guint16 *d = dest, G, B, R, A;
2694 
2695   sg += x;
2696   sb += x;
2697   sr += x;
2698   sa += x;
2699 
2700   for (i = 0; i &lt; width; i++) {
2701     G = GST_READ_UINT16_LE (sg + i) &lt;&lt; 4;
2702     B = GST_READ_UINT16_LE (sb + i) &lt;&lt; 4;
2703     R = GST_READ_UINT16_LE (sr + i) &lt;&lt; 4;
2704     A = GST_READ_UINT16_LE (sa + i) &lt;&lt; 4;
2705 
2706     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2707       A |= (A &gt;&gt; 12);
2708       R |= (R &gt;&gt; 12);
2709       G |= (G &gt;&gt; 12);
2710       B |= (B &gt;&gt; 12);
2711     }
2712 
2713     d[i * 4 + 0] = A;
2714     d[i * 4 + 1] = R;
2715     d[i * 4 + 2] = G;
2716     d[i * 4 + 3] = B;
2717   }
2718 }
2719 
2720 static void
2721 pack_GBRA_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2722     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2723     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2724     gint y, gint width)
2725 {
2726   int i;
2727   guint16 *restrict dg = GET_G_LINE (y);
2728   guint16 *restrict db = GET_B_LINE (y);
2729   guint16 *restrict dr = GET_R_LINE (y);
2730   guint16 *restrict da = GET_A_LINE (y);
2731   guint16 G, B, R, A;
2732   const guint16 *restrict s = src;
2733 
2734   for (i = 0; i &lt; width; i++) {
2735     G = (s[i * 4 + 2]) &gt;&gt; 4;
2736     B = (s[i * 4 + 3]) &gt;&gt; 4;
2737     R = (s[i * 4 + 1]) &gt;&gt; 4;
2738     A = (s[i * 4 + 0]) &gt;&gt; 4;
2739 
2740     GST_WRITE_UINT16_LE (dg + i, G);
2741     GST_WRITE_UINT16_LE (db + i, B);
2742     GST_WRITE_UINT16_LE (dr + i, R);
2743     GST_WRITE_UINT16_LE (da + i, A);
2744   }
2745 }
2746 
2747 #define PACK_GBRA_12BE GST_VIDEO_FORMAT_ARGB64, unpack_GBRA_12BE, 1, pack_GBRA_12BE
2748 static void
2749 unpack_GBRA_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2750     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2751     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2752 {
2753   int i;
2754   const guint16 *restrict sg = GET_G_LINE (y);
2755   const guint16 *restrict sb = GET_B_LINE (y);
2756   const guint16 *restrict sr = GET_R_LINE (y);
2757   const guint16 *restrict sa = GET_A_LINE (y);
2758   guint16 *restrict d = dest, G, B, R, A;
2759 
2760   sg += x;
2761   sb += x;
2762   sr += x;
2763   sa += x;
2764 
2765   for (i = 0; i &lt; width; i++) {
2766     G = GST_READ_UINT16_BE (sg + i) &lt;&lt; 4;
2767     B = GST_READ_UINT16_BE (sb + i) &lt;&lt; 4;
2768     R = GST_READ_UINT16_BE (sr + i) &lt;&lt; 4;
2769     A = GST_READ_UINT16_BE (sa + i) &lt;&lt; 4;
2770 
2771     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2772       R |= (R &gt;&gt; 12);
2773       G |= (G &gt;&gt; 12);
2774       B |= (B &gt;&gt; 12);
2775       A |= (A &gt;&gt; 12);
2776     }
2777 
2778     d[i * 4 + 0] = A;
2779     d[i * 4 + 1] = R;
2780     d[i * 4 + 2] = G;
2781     d[i * 4 + 3] = B;
2782   }
2783 }
2784 
2785 static void
2786 pack_GBRA_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2787     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2788     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2789     gint y, gint width)
2790 {
2791   int i;
2792   guint16 *restrict dg = GET_G_LINE (y);
2793   guint16 *restrict db = GET_B_LINE (y);
2794   guint16 *restrict dr = GET_R_LINE (y);
2795   guint16 *restrict da = GET_A_LINE (y);
2796   guint16 G, B, R, A;
2797   const guint16 *restrict s = src;
2798 
2799   for (i = 0; i &lt; width; i++) {
2800     G = s[i * 4 + 2] &gt;&gt; 4;
2801     B = s[i * 4 + 3] &gt;&gt; 4;
2802     R = s[i * 4 + 1] &gt;&gt; 4;
2803     A = s[i * 4 + 0] &gt;&gt; 4;
2804 
2805     GST_WRITE_UINT16_BE (dg + i, G);
2806     GST_WRITE_UINT16_BE (db + i, B);
2807     GST_WRITE_UINT16_BE (dr + i, R);
2808     GST_WRITE_UINT16_BE (da + i, A);
2809   }
2810 }
2811 
2812 #define PACK_Y444_10LE GST_VIDEO_FORMAT_AYUV64, unpack_Y444_10LE, 1, pack_Y444_10LE
2813 static void
2814 unpack_Y444_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2815     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2816     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2817 {
2818   int i;
2819   guint16 *restrict sy = GET_Y_LINE (y);
2820   guint16 *restrict su = GET_U_LINE (y);
2821   guint16 *restrict sv = GET_V_LINE (y);
2822   guint16 *restrict d = dest, Y, U, V;
2823 
2824   sy += x;
2825   su += x;
2826   sv += x;
2827 
2828   for (i = 0; i &lt; width; i++) {
2829     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 6;
2830     U = GST_READ_UINT16_LE (su + i) &lt;&lt; 6;
2831     V = GST_READ_UINT16_LE (sv + i) &lt;&lt; 6;
2832 
2833     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2834       Y |= (Y &gt;&gt; 10);
2835       U |= (U &gt;&gt; 10);
2836       V |= (V &gt;&gt; 10);
2837     }
2838 
2839     d[i * 4 + 0] = 0xffff;
2840     d[i * 4 + 1] = Y;
2841     d[i * 4 + 2] = U;
2842     d[i * 4 + 3] = V;
2843   }
2844 }
2845 
2846 static void
2847 pack_Y444_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2848     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2849     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2850     gint y, gint width)
2851 {
2852   int i;
2853   guint16 *restrict dy = GET_Y_LINE (y);
2854   guint16 *restrict du = GET_U_LINE (y);
2855   guint16 *restrict dv = GET_V_LINE (y);
2856   guint16 Y, U, V;
2857   const guint16 *restrict s = src;
2858 
2859   for (i = 0; i &lt; width; i++) {
2860     Y = (s[i * 4 + 1]) &gt;&gt; 6;
2861     U = (s[i * 4 + 2]) &gt;&gt; 6;
2862     V = (s[i * 4 + 3]) &gt;&gt; 6;
2863 
2864     GST_WRITE_UINT16_LE (dy + i, Y);
2865     GST_WRITE_UINT16_LE (du + i, U);
2866     GST_WRITE_UINT16_LE (dv + i, V);
2867   }
2868 }
2869 
2870 #define PACK_Y444_10BE GST_VIDEO_FORMAT_AYUV64, unpack_Y444_10BE, 1, pack_Y444_10BE
2871 static void
2872 unpack_Y444_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2873     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2874     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2875 {
2876   int i;
2877   const guint16 *restrict sy = GET_Y_LINE (y);
2878   const guint16 *restrict su = GET_U_LINE (y);
2879   const guint16 *restrict sv = GET_V_LINE (y);
2880   guint16 *restrict d = dest, Y, U, V;
2881 
2882   sy += x;
2883   su += x;
2884   sv += x;
2885 
2886   for (i = 0; i &lt; width; i++) {
2887     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 6;
2888     U = GST_READ_UINT16_BE (su + i) &lt;&lt; 6;
2889     V = GST_READ_UINT16_BE (sv + i) &lt;&lt; 6;
2890 
2891     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2892       Y |= (Y &gt;&gt; 10);
2893       U |= (U &gt;&gt; 10);
2894       V |= (V &gt;&gt; 10);
2895     }
2896 
2897     d[i * 4 + 0] = 0xffff;
2898     d[i * 4 + 1] = Y;
2899     d[i * 4 + 2] = U;
2900     d[i * 4 + 3] = V;
2901   }
2902 }
2903 
2904 static void
2905 pack_Y444_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2906     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2907     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2908     gint y, gint width)
2909 {
2910   int i;
2911   guint16 *restrict dy = GET_Y_LINE (y);
2912   guint16 *restrict du = GET_U_LINE (y);
2913   guint16 *restrict dv = GET_V_LINE (y);
2914   guint16 Y, U, V;
2915   const guint16 *restrict s = src;
2916 
2917   for (i = 0; i &lt; width; i++) {
2918     Y = s[i * 4 + 1] &gt;&gt; 6;
2919     U = s[i * 4 + 2] &gt;&gt; 6;
2920     V = s[i * 4 + 3] &gt;&gt; 6;
2921 
2922     GST_WRITE_UINT16_BE (dy + i, Y);
2923     GST_WRITE_UINT16_BE (du + i, U);
2924     GST_WRITE_UINT16_BE (dv + i, V);
2925   }
2926 }
2927 
2928 #define PACK_I420_10LE GST_VIDEO_FORMAT_AYUV64, unpack_I420_10LE, 1, pack_I420_10LE
2929 static void
2930 unpack_I420_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2931     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
2932     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
2933 {
2934   int i;
2935   gint uv = GET_UV_420 (y, flags);
2936   const guint16 *restrict sy = GET_Y_LINE (y);
2937   const guint16 *restrict su = GET_U_LINE (uv);
2938   const guint16 *restrict sv = GET_V_LINE (uv);
2939   guint16 *restrict d = dest, Y, U, V;
2940 
2941   sy += x;
2942   su += x &gt;&gt; 1;
2943   sv += x &gt;&gt; 1;
2944 
2945   for (i = 0; i &lt; width; i++) {
2946     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 6;
2947     U = GST_READ_UINT16_LE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
2948     V = GST_READ_UINT16_LE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
2949 
2950     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
2951       Y |= (Y &gt;&gt; 10);
2952       U |= (U &gt;&gt; 10);
2953       V |= (V &gt;&gt; 10);
2954     }
2955 
2956     d[i * 4 + 0] = 0xffff;
2957     d[i * 4 + 1] = Y;
2958     d[i * 4 + 2] = U;
2959     d[i * 4 + 3] = V;
2960 
2961     if (x &amp; 1) {
2962       x = 0;
2963       su++;
2964       sv++;
<a name="19" id="anc19"></a>
2965   }
2966 }
<a name="20" id="anc20"></a><span class="line-removed">2967 }</span>
2968 
2969 static void
2970 pack_I420_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
2971     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
2972     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
2973     gint y, gint width)
2974 {
2975   int i;
2976   gint uv = GET_UV_420 (y, flags);
2977   guint16 *restrict dy = GET_Y_LINE (y);
2978   guint16 *restrict du = GET_U_LINE (uv);
2979   guint16 *restrict dv = GET_V_LINE (uv);
2980   guint16 Y0, Y1, U, V;
2981   const guint16 *restrict s = src;
2982 
2983   if (IS_CHROMA_LINE_420 (y, flags)) {
<a name="21" id="anc21"></a><span class="line-modified">2984   for (i = 0; i &lt; width - 1; i += 2) {</span>
<span class="line-modified">2985     Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-modified">2986     Y1 = s[i * 4 + 5] &gt;&gt; 6;</span>
<span class="line-modified">2987     U = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-modified">2988     V = s[i * 4 + 3] &gt;&gt; 6;</span>
2989 
2990       GST_WRITE_UINT16_LE (dy + i + 0, Y0);
2991       GST_WRITE_UINT16_LE (dy + i + 1, Y1);
2992       GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
2993       GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
<a name="22" id="anc22"></a><span class="line-modified">2994   }</span>
<span class="line-modified">2995   if (i == width - 1) {</span>
<span class="line-modified">2996     Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-modified">2997     U = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-modified">2998     V = s[i * 4 + 3] &gt;&gt; 6;</span>
2999 
3000       GST_WRITE_UINT16_LE (dy + i, Y0);
3001       GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3002       GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
<a name="23" id="anc23"></a><span class="line-modified">3003   }</span>
3004   } else {
3005     for (i = 0; i &lt; width; i++) {
3006       Y0 = s[i * 4 + 1] &gt;&gt; 6;
3007       GST_WRITE_UINT16_LE (dy + i, Y0);
<a name="24" id="anc24"></a><span class="line-modified">3008 }</span>
3009   }
3010 }
3011 
3012 #define PACK_I420_10BE GST_VIDEO_FORMAT_AYUV64, unpack_I420_10BE, 1, pack_I420_10BE
3013 static void
3014 unpack_I420_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3015     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3016     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3017 {
3018   int i;
3019   gint uv = GET_UV_420 (y, flags);
3020   const guint16 *restrict sy = GET_Y_LINE (y);
3021   const guint16 *restrict su = GET_U_LINE (uv);
3022   const guint16 *restrict sv = GET_V_LINE (uv);
3023   guint16 *restrict d = dest, Y, U, V;
3024 
3025   sy += x;
3026   su += x &gt;&gt; 1;
3027   sv += x &gt;&gt; 1;
3028 
3029   for (i = 0; i &lt; width; i++) {
3030     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 6;
3031     U = GST_READ_UINT16_BE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
3032     V = GST_READ_UINT16_BE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
3033 
3034     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3035       Y |= (Y &gt;&gt; 10);
3036       U |= (U &gt;&gt; 10);
3037       V |= (V &gt;&gt; 10);
3038     }
3039 
3040     d[i * 4 + 0] = 0xffff;
3041     d[i * 4 + 1] = Y;
3042     d[i * 4 + 2] = U;
3043     d[i * 4 + 3] = V;
3044 
3045     if (x &amp; 1) {
3046       x = 0;
3047       su++;
3048       sv++;
<a name="25" id="anc25"></a>
3049   }
3050 }
<a name="26" id="anc26"></a><span class="line-removed">3051 }</span>
3052 
3053 static void
3054 pack_I420_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3055     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3056     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3057     gint y, gint width)
3058 {
3059   int i;
3060   gint uv = GET_UV_420 (y, flags);
3061   guint16 *restrict dy = GET_Y_LINE (y);
3062   guint16 *restrict du = GET_U_LINE (uv);
3063   guint16 *restrict dv = GET_V_LINE (uv);
3064   guint16 Y0, Y1, U, V;
3065   const guint16 *restrict s = src;
3066 
3067   if (IS_CHROMA_LINE_420 (y, flags)) {
<a name="27" id="anc27"></a><span class="line-modified">3068   for (i = 0; i &lt; width - 1; i += 2) {</span>
<span class="line-modified">3069     Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-modified">3070     Y1 = s[i * 4 + 5] &gt;&gt; 6;</span>
<span class="line-modified">3071     U = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-modified">3072     V = s[i * 4 + 3] &gt;&gt; 6;</span>
3073 
3074       GST_WRITE_UINT16_BE (dy + i + 0, Y0);
3075       GST_WRITE_UINT16_BE (dy + i + 1, Y1);
3076       GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3077       GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
<a name="28" id="anc28"></a><span class="line-modified">3078   }</span>
<span class="line-modified">3079   if (i == width - 1) {</span>
<span class="line-modified">3080     Y0 = s[i * 4 + 1] &gt;&gt; 6;</span>
<span class="line-modified">3081     U = s[i * 4 + 2] &gt;&gt; 6;</span>
<span class="line-modified">3082     V = s[i * 4 + 3] &gt;&gt; 6;</span>
3083 
3084       GST_WRITE_UINT16_BE (dy + i, Y0);
3085       GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3086       GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
<a name="29" id="anc29"></a><span class="line-modified">3087   }</span>
3088   } else {
3089     for (i = 0; i &lt; width; i++) {
3090       Y0 = s[i * 4 + 1] &gt;&gt; 6;
3091       GST_WRITE_UINT16_BE (dy + i, Y0);
<a name="30" id="anc30"></a><span class="line-modified">3092 }</span>
3093   }
3094 }
3095 
3096 #define PACK_I422_10LE GST_VIDEO_FORMAT_AYUV64, unpack_I422_10LE, 1, pack_I422_10LE
3097 static void
3098 unpack_I422_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3099     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3100     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3101 {
3102   int i;
3103   const guint16 *restrict sy = GET_Y_LINE (y);
3104   const guint16 *restrict su = GET_U_LINE (y);
3105   const guint16 *restrict sv = GET_V_LINE (y);
3106   guint16 *restrict d = dest, Y, U, V;
3107 
3108   sy += x;
3109   su += x &gt;&gt; 1;
3110   sv += x &gt;&gt; 1;
3111 
3112   for (i = 0; i &lt; width; i++) {
3113     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 6;
3114     U = GST_READ_UINT16_LE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
3115     V = GST_READ_UINT16_LE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
3116 
3117     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3118       Y |= (Y &gt;&gt; 10);
3119       U |= (U &gt;&gt; 10);
3120       V |= (V &gt;&gt; 10);
3121     }
3122 
3123     d[i * 4 + 0] = 0xffff;
3124     d[i * 4 + 1] = Y;
3125     d[i * 4 + 2] = U;
3126     d[i * 4 + 3] = V;
3127 
3128     if (x &amp; 1) {
3129       x = 0;
3130       su++;
3131       sv++;
<a name="31" id="anc31"></a>
3132   }
3133 }
<a name="32" id="anc32"></a><span class="line-removed">3134 }</span>
3135 
3136 static void
3137 pack_I422_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3138     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3139     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3140     gint y, gint width)
3141 {
3142   int i;
3143   guint16 *restrict dy = GET_Y_LINE (y);
3144   guint16 *restrict du = GET_U_LINE (y);
3145   guint16 *restrict dv = GET_V_LINE (y);
3146   guint16 Y0, Y1, U, V;
3147   const guint16 *restrict s = src;
3148 
3149   for (i = 0; i &lt; width - 1; i += 2) {
3150     Y0 = s[i * 4 + 1] &gt;&gt; 6;
3151     Y1 = s[i * 4 + 5] &gt;&gt; 6;
3152     U = s[i * 4 + 2] &gt;&gt; 6;
3153     V = s[i * 4 + 3] &gt;&gt; 6;
3154 
3155     GST_WRITE_UINT16_LE (dy + i + 0, Y0);
3156     GST_WRITE_UINT16_LE (dy + i + 1, Y1);
3157     GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3158     GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
3159   }
3160   if (i == width - 1) {
3161     Y0 = s[i * 4 + 1] &gt;&gt; 6;
3162     U = s[i * 4 + 2] &gt;&gt; 6;
3163     V = s[i * 4 + 3] &gt;&gt; 6;
3164 
3165     GST_WRITE_UINT16_LE (dy + i, Y0);
3166     GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3167     GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
3168   }
3169 }
3170 
3171 #define PACK_I422_10BE GST_VIDEO_FORMAT_AYUV64, unpack_I422_10BE, 1, pack_I422_10BE
3172 static void
3173 unpack_I422_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3174     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3175     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3176 {
3177   int i;
3178   const guint16 *restrict sy = GET_Y_LINE (y);
3179   const guint16 *restrict su = GET_U_LINE (y);
3180   const guint16 *restrict sv = GET_V_LINE (y);
3181   guint16 *restrict d = dest, Y, U, V;
3182 
3183   sy += x;
3184   su += x &gt;&gt; 1;
3185   sv += x &gt;&gt; 1;
3186 
3187   for (i = 0; i &lt; width; i++) {
3188     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 6;
3189     U = GST_READ_UINT16_BE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
3190     V = GST_READ_UINT16_BE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
3191 
3192     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3193       Y |= (Y &gt;&gt; 10);
3194       U |= (U &gt;&gt; 10);
3195       V |= (V &gt;&gt; 10);
3196     }
3197 
3198     d[i * 4 + 0] = 0xffff;
3199     d[i * 4 + 1] = Y;
3200     d[i * 4 + 2] = U;
3201     d[i * 4 + 3] = V;
3202 
3203     if (x &amp; 1) {
3204       x = 0;
3205       su++;
3206       sv++;
<a name="33" id="anc33"></a>
3207   }
3208 }
<a name="34" id="anc34"></a><span class="line-removed">3209 }</span>
3210 
3211 static void
3212 pack_I422_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3213     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3214     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3215     gint y, gint width)
3216 {
3217   int i;
3218   guint16 *restrict dy = GET_Y_LINE (y);
3219   guint16 *restrict du = GET_U_LINE (y);
3220   guint16 *restrict dv = GET_V_LINE (y);
3221   guint16 Y0, Y1, U, V;
3222   const guint16 *restrict s = src;
3223 
3224   for (i = 0; i &lt; width - 1; i += 2) {
3225     Y0 = s[i * 4 + 1] &gt;&gt; 6;
3226     Y1 = s[i * 4 + 5] &gt;&gt; 6;
3227     U = s[i * 4 + 2] &gt;&gt; 6;
3228     V = s[i * 4 + 3] &gt;&gt; 6;
3229 
3230     GST_WRITE_UINT16_BE (dy + i + 0, Y0);
3231     GST_WRITE_UINT16_BE (dy + i + 1, Y1);
3232     GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3233     GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
3234   }
3235   if (i == width - 1) {
3236     Y0 = s[i * 4 + 1] &gt;&gt; 6;
3237     U = s[i * 4 + 2] &gt;&gt; 6;
3238     V = s[i * 4 + 3] &gt;&gt; 6;
3239 
3240     GST_WRITE_UINT16_BE (dy + i, Y0);
3241     GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3242     GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
3243   }
3244 }
3245 
3246 #define PACK_Y444_12LE GST_VIDEO_FORMAT_AYUV64, unpack_Y444_12LE, 1, pack_Y444_12LE
3247 static void
3248 unpack_Y444_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3249     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3250     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3251 {
3252   int i;
3253   guint16 *restrict sy = GET_Y_LINE (y);
3254   guint16 *restrict su = GET_U_LINE (y);
3255   guint16 *restrict sv = GET_V_LINE (y);
3256   guint16 *restrict d = dest, Y, U, V;
3257 
3258   sy += x;
3259   su += x;
3260   sv += x;
3261 
3262   for (i = 0; i &lt; width; i++) {
3263     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 4;
3264     U = GST_READ_UINT16_LE (su + i) &lt;&lt; 4;
3265     V = GST_READ_UINT16_LE (sv + i) &lt;&lt; 4;
3266 
3267     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3268       Y |= (Y &gt;&gt; 12);
3269       U |= (U &gt;&gt; 12);
3270       V |= (V &gt;&gt; 12);
3271     }
3272 
3273     d[i * 4 + 0] = 0xffff;
3274     d[i * 4 + 1] = Y;
3275     d[i * 4 + 2] = U;
3276     d[i * 4 + 3] = V;
3277   }
3278 }
3279 
3280 static void
3281 pack_Y444_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3282     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3283     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3284     gint y, gint width)
3285 {
3286   int i;
3287   guint16 *restrict dy = GET_Y_LINE (y);
3288   guint16 *restrict du = GET_U_LINE (y);
3289   guint16 *restrict dv = GET_V_LINE (y);
3290   guint16 Y, U, V;
3291   const guint16 *restrict s = src;
3292 
3293   for (i = 0; i &lt; width; i++) {
3294     Y = (s[i * 4 + 1]) &gt;&gt; 4;
3295     U = (s[i * 4 + 2]) &gt;&gt; 4;
3296     V = (s[i * 4 + 3]) &gt;&gt; 4;
3297 
3298     GST_WRITE_UINT16_LE (dy + i, Y);
3299     GST_WRITE_UINT16_LE (du + i, U);
3300     GST_WRITE_UINT16_LE (dv + i, V);
3301   }
3302 }
3303 
3304 #define PACK_Y444_12BE GST_VIDEO_FORMAT_AYUV64, unpack_Y444_12BE, 1, pack_Y444_12BE
3305 static void
3306 unpack_Y444_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3307     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3308     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3309 {
3310   int i;
3311   const guint16 *restrict sy = GET_Y_LINE (y);
3312   const guint16 *restrict su = GET_U_LINE (y);
3313   const guint16 *restrict sv = GET_V_LINE (y);
3314   guint16 *restrict d = dest, Y, U, V;
3315 
3316   sy += x;
3317   su += x;
3318   sv += x;
3319 
3320   for (i = 0; i &lt; width; i++) {
3321     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 4;
3322     U = GST_READ_UINT16_BE (su + i) &lt;&lt; 4;
3323     V = GST_READ_UINT16_BE (sv + i) &lt;&lt; 4;
3324 
3325     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3326       Y |= (Y &gt;&gt; 12);
3327       U |= (U &gt;&gt; 12);
3328       V |= (V &gt;&gt; 12);
3329     }
3330 
3331     d[i * 4 + 0] = 0xffff;
3332     d[i * 4 + 1] = Y;
3333     d[i * 4 + 2] = U;
3334     d[i * 4 + 3] = V;
3335   }
3336 }
3337 
3338 static void
3339 pack_Y444_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3340     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3341     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3342     gint y, gint width)
3343 {
3344   int i;
3345   guint16 *restrict dy = GET_Y_LINE (y);
3346   guint16 *restrict du = GET_U_LINE (y);
3347   guint16 *restrict dv = GET_V_LINE (y);
3348   guint16 Y, U, V;
3349   const guint16 *restrict s = src;
3350 
3351   for (i = 0; i &lt; width; i++) {
3352     Y = s[i * 4 + 1] &gt;&gt; 4;
3353     U = s[i * 4 + 2] &gt;&gt; 4;
3354     V = s[i * 4 + 3] &gt;&gt; 4;
3355 
3356     GST_WRITE_UINT16_BE (dy + i, Y);
3357     GST_WRITE_UINT16_BE (du + i, U);
3358     GST_WRITE_UINT16_BE (dv + i, V);
3359   }
3360 }
3361 
3362 #define PACK_I420_12LE GST_VIDEO_FORMAT_AYUV64, unpack_I420_12LE, 1, pack_I420_12LE
3363 static void
3364 unpack_I420_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3365     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3366     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3367 {
3368   int i;
3369   gint uv = GET_UV_420 (y, flags);
3370   const guint16 *restrict sy = GET_Y_LINE (y);
3371   const guint16 *restrict su = GET_U_LINE (uv);
3372   const guint16 *restrict sv = GET_V_LINE (uv);
3373   guint16 *restrict d = dest, Y, U, V;
3374 
3375   sy += x;
3376   su += x &gt;&gt; 1;
3377   sv += x &gt;&gt; 1;
3378 
3379   for (i = 0; i &lt; width; i++) {
3380     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 4;
3381     U = GST_READ_UINT16_LE (su + (i &gt;&gt; 1)) &lt;&lt; 4;
3382     V = GST_READ_UINT16_LE (sv + (i &gt;&gt; 1)) &lt;&lt; 4;
3383 
3384     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3385       Y |= (Y &gt;&gt; 12);
3386       U |= (U &gt;&gt; 12);
3387       V |= (V &gt;&gt; 12);
3388     }
3389 
3390     d[i * 4 + 0] = 0xffff;
3391     d[i * 4 + 1] = Y;
3392     d[i * 4 + 2] = U;
3393     d[i * 4 + 3] = V;
3394 
3395     if (x &amp; 1) {
3396       x = 0;
3397       su++;
3398       sv++;
3399     }
3400   }
3401 }
3402 
3403 static void
3404 pack_I420_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3405     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3406     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3407     gint y, gint width)
3408 {
3409   int i;
3410   gint uv = GET_UV_420 (y, flags);
3411   guint16 *restrict dy = GET_Y_LINE (y);
3412   guint16 *restrict du = GET_U_LINE (uv);
3413   guint16 *restrict dv = GET_V_LINE (uv);
3414   guint16 Y0, Y1, U, V;
3415   const guint16 *restrict s = src;
3416 
3417   if (IS_CHROMA_LINE_420 (y, flags)) {
3418     for (i = 0; i &lt; width - 1; i += 2) {
3419       Y0 = s[i * 4 + 1] &gt;&gt; 4;
3420       Y1 = s[i * 4 + 5] &gt;&gt; 4;
3421       U = s[i * 4 + 2] &gt;&gt; 4;
3422       V = s[i * 4 + 3] &gt;&gt; 4;
3423 
3424       GST_WRITE_UINT16_LE (dy + i + 0, Y0);
3425       GST_WRITE_UINT16_LE (dy + i + 1, Y1);
3426       GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3427       GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
3428     }
3429     if (i == width - 1) {
3430       Y0 = s[i * 4 + 1] &gt;&gt; 4;
3431       U = s[i * 4 + 2] &gt;&gt; 4;
3432       V = s[i * 4 + 3] &gt;&gt; 4;
3433 
3434       GST_WRITE_UINT16_LE (dy + i, Y0);
3435       GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3436       GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
3437     }
3438   } else {
3439     for (i = 0; i &lt; width; i++) {
3440       Y0 = s[i * 4 + 1] &gt;&gt; 4;
3441       GST_WRITE_UINT16_LE (dy + i, Y0);
3442     }
3443   }
3444 }
3445 
3446 #define PACK_I420_12BE GST_VIDEO_FORMAT_AYUV64, unpack_I420_12BE, 1, pack_I420_12BE
3447 static void
3448 unpack_I420_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3449     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3450     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3451 {
3452   int i;
3453   gint uv = GET_UV_420 (y, flags);
3454   const guint16 *restrict sy = GET_Y_LINE (y);
3455   const guint16 *restrict su = GET_U_LINE (uv);
3456   const guint16 *restrict sv = GET_V_LINE (uv);
3457   guint16 *restrict d = dest, Y, U, V;
3458 
3459   sy += x;
3460   su += x &gt;&gt; 1;
3461   sv += x &gt;&gt; 1;
3462 
3463   for (i = 0; i &lt; width; i++) {
3464     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 4;
3465     U = GST_READ_UINT16_BE (su + (i &gt;&gt; 1)) &lt;&lt; 4;
3466     V = GST_READ_UINT16_BE (sv + (i &gt;&gt; 1)) &lt;&lt; 4;
3467 
3468     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3469       Y |= (Y &gt;&gt; 12);
3470       U |= (U &gt;&gt; 12);
3471       V |= (V &gt;&gt; 12);
3472     }
3473 
3474     d[i * 4 + 0] = 0xffff;
3475     d[i * 4 + 1] = Y;
3476     d[i * 4 + 2] = U;
3477     d[i * 4 + 3] = V;
3478 
3479     if (x &amp; 1) {
3480       x = 0;
3481       su++;
3482       sv++;
3483     }
3484   }
3485 }
3486 
3487 static void
3488 pack_I420_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3489     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3490     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3491     gint y, gint width)
3492 {
3493   int i;
3494   gint uv = GET_UV_420 (y, flags);
3495   guint16 *restrict dy = GET_Y_LINE (y);
3496   guint16 *restrict du = GET_U_LINE (uv);
3497   guint16 *restrict dv = GET_V_LINE (uv);
3498   guint16 Y0, Y1, U, V;
3499   const guint16 *restrict s = src;
3500 
3501   if (IS_CHROMA_LINE_420 (y, flags)) {
3502     for (i = 0; i &lt; width - 1; i += 2) {
3503       Y0 = s[i * 4 + 1] &gt;&gt; 4;
3504       Y1 = s[i * 4 + 5] &gt;&gt; 4;
3505       U = s[i * 4 + 2] &gt;&gt; 4;
3506       V = s[i * 4 + 3] &gt;&gt; 4;
3507 
3508       GST_WRITE_UINT16_BE (dy + i + 0, Y0);
3509       GST_WRITE_UINT16_BE (dy + i + 1, Y1);
3510       GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3511       GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
3512     }
3513     if (i == width - 1) {
3514       Y0 = s[i * 4 + 1] &gt;&gt; 4;
3515       U = s[i * 4 + 2] &gt;&gt; 4;
3516       V = s[i * 4 + 3] &gt;&gt; 4;
3517 
3518       GST_WRITE_UINT16_BE (dy + i, Y0);
3519       GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3520       GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
3521     }
3522   } else {
3523     for (i = 0; i &lt; width; i++) {
3524       Y0 = s[i * 4 + 1] &gt;&gt; 4;
3525       GST_WRITE_UINT16_BE (dy + i, Y0);
3526     }
3527   }
3528 }
3529 
3530 #define PACK_I422_12LE GST_VIDEO_FORMAT_AYUV64, unpack_I422_12LE, 1, pack_I422_12LE
3531 static void
3532 unpack_I422_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3533     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3534     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3535 {
3536   int i;
3537   const guint16 *restrict sy = GET_Y_LINE (y);
3538   const guint16 *restrict su = GET_U_LINE (y);
3539   const guint16 *restrict sv = GET_V_LINE (y);
3540   guint16 *restrict d = dest, Y, U, V;
3541 
3542   sy += x;
3543   su += x &gt;&gt; 1;
3544   sv += x &gt;&gt; 1;
3545 
3546   for (i = 0; i &lt; width; i++) {
3547     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 4;
3548     U = GST_READ_UINT16_LE (su + (i &gt;&gt; 1)) &lt;&lt; 4;
3549     V = GST_READ_UINT16_LE (sv + (i &gt;&gt; 1)) &lt;&lt; 4;
3550 
3551     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3552       Y |= (Y &gt;&gt; 12);
3553       U |= (U &gt;&gt; 12);
3554       V |= (V &gt;&gt; 12);
3555     }
3556 
3557     d[i * 4 + 0] = 0xffff;
3558     d[i * 4 + 1] = Y;
3559     d[i * 4 + 2] = U;
3560     d[i * 4 + 3] = V;
3561 
3562     if (x &amp; 1) {
3563       x = 0;
3564       su++;
3565       sv++;
3566     }
3567   }
3568 }
3569 
3570 static void
3571 pack_I422_12LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3572     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3573     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3574     gint y, gint width)
3575 {
3576   int i;
3577   guint16 *restrict dy = GET_Y_LINE (y);
3578   guint16 *restrict du = GET_U_LINE (y);
3579   guint16 *restrict dv = GET_V_LINE (y);
3580   guint16 Y0, Y1, U, V;
3581   const guint16 *restrict s = src;
3582 
3583   for (i = 0; i &lt; width - 1; i += 2) {
3584     Y0 = s[i * 4 + 1] &gt;&gt; 4;
3585     Y1 = s[i * 4 + 5] &gt;&gt; 4;
3586     U = s[i * 4 + 2] &gt;&gt; 4;
3587     V = s[i * 4 + 3] &gt;&gt; 4;
3588 
3589     GST_WRITE_UINT16_LE (dy + i + 0, Y0);
3590     GST_WRITE_UINT16_LE (dy + i + 1, Y1);
3591     GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3592     GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
3593   }
3594   if (i == width - 1) {
3595     Y0 = s[i * 4 + 1] &gt;&gt; 4;
3596     U = s[i * 4 + 2] &gt;&gt; 4;
3597     V = s[i * 4 + 3] &gt;&gt; 4;
3598 
3599     GST_WRITE_UINT16_LE (dy + i, Y0);
3600     GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3601     GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
3602   }
3603 }
3604 
3605 #define PACK_I422_12BE GST_VIDEO_FORMAT_AYUV64, unpack_I422_12BE, 1, pack_I422_12BE
3606 static void
3607 unpack_I422_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3608     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3609     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3610 {
3611   int i;
3612   const guint16 *restrict sy = GET_Y_LINE (y);
3613   const guint16 *restrict su = GET_U_LINE (y);
3614   const guint16 *restrict sv = GET_V_LINE (y);
3615   guint16 *restrict d = dest, Y, U, V;
3616 
3617   sy += x;
3618   su += x &gt;&gt; 1;
3619   sv += x &gt;&gt; 1;
3620 
3621   for (i = 0; i &lt; width; i++) {
3622     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 4;
3623     U = GST_READ_UINT16_BE (su + (i &gt;&gt; 1)) &lt;&lt; 4;
3624     V = GST_READ_UINT16_BE (sv + (i &gt;&gt; 1)) &lt;&lt; 4;
3625 
3626     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3627       Y |= (Y &gt;&gt; 12);
3628       U |= (U &gt;&gt; 12);
3629       V |= (V &gt;&gt; 12);
3630     }
3631 
3632     d[i * 4 + 0] = 0xffff;
3633     d[i * 4 + 1] = Y;
3634     d[i * 4 + 2] = U;
3635     d[i * 4 + 3] = V;
3636 
3637     if (x &amp; 1) {
3638       x = 0;
3639       su++;
3640       sv++;
3641     }
3642   }
3643 }
3644 
3645 static void
3646 pack_I422_12BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3647     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3648     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3649     gint y, gint width)
3650 {
3651   int i;
3652   guint16 *restrict dy = GET_Y_LINE (y);
3653   guint16 *restrict du = GET_U_LINE (y);
3654   guint16 *restrict dv = GET_V_LINE (y);
3655   guint16 Y0, Y1, U, V;
3656   const guint16 *restrict s = src;
3657 
3658   for (i = 0; i &lt; width - 1; i += 2) {
3659     Y0 = s[i * 4 + 1] &gt;&gt; 4;
3660     Y1 = s[i * 4 + 5] &gt;&gt; 4;
3661     U = s[i * 4 + 2] &gt;&gt; 4;
3662     V = s[i * 4 + 3] &gt;&gt; 4;
3663 
3664     GST_WRITE_UINT16_BE (dy + i + 0, Y0);
3665     GST_WRITE_UINT16_BE (dy + i + 1, Y1);
3666     GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3667     GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
3668   }
3669   if (i == width - 1) {
3670     Y0 = s[i * 4 + 1] &gt;&gt; 4;
3671     U = s[i * 4 + 2] &gt;&gt; 4;
3672     V = s[i * 4 + 3] &gt;&gt; 4;
3673 
3674     GST_WRITE_UINT16_BE (dy + i, Y0);
3675     GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3676     GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
3677   }
3678 }
3679 
3680 #define PACK_A444_10LE GST_VIDEO_FORMAT_AYUV64, unpack_A444_10LE, 1, pack_A444_10LE
3681 static void
3682 unpack_A444_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3683     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3684     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3685 {
3686   int i;
3687   guint16 *restrict sa = GET_A_LINE (y);
3688   guint16 *restrict sy = GET_Y_LINE (y);
3689   guint16 *restrict su = GET_U_LINE (y);
3690   guint16 *restrict sv = GET_V_LINE (y);
3691   guint16 *restrict d = dest, A, Y, U, V;
3692 
3693   sa += x;
3694   sy += x;
3695   su += x;
3696   sv += x;
3697 
3698   for (i = 0; i &lt; width; i++) {
3699     A = GST_READ_UINT16_LE (sa + i) &lt;&lt; 6;
3700     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 6;
3701     U = GST_READ_UINT16_LE (su + i) &lt;&lt; 6;
3702     V = GST_READ_UINT16_LE (sv + i) &lt;&lt; 6;
3703 
3704     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3705       A |= (A &gt;&gt; 10);
3706       Y |= (Y &gt;&gt; 10);
3707       U |= (U &gt;&gt; 10);
3708       V |= (V &gt;&gt; 10);
3709     }
3710 
3711     d[i * 4 + 0] = A;
3712     d[i * 4 + 1] = Y;
3713     d[i * 4 + 2] = U;
3714     d[i * 4 + 3] = V;
3715   }
3716 }
3717 
3718 static void
3719 pack_A444_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3720     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3721     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3722     gint y, gint width)
3723 {
3724   int i;
3725   guint16 *restrict da = GET_A_LINE (y);
3726   guint16 *restrict dy = GET_Y_LINE (y);
3727   guint16 *restrict du = GET_U_LINE (y);
3728   guint16 *restrict dv = GET_V_LINE (y);
3729   guint16 A, Y, U, V;
3730   const guint16 *restrict s = src;
3731 
3732   for (i = 0; i &lt; width; i++) {
3733     A = (s[i * 4 + 0]) &gt;&gt; 6;
3734     Y = (s[i * 4 + 1]) &gt;&gt; 6;
3735     U = (s[i * 4 + 2]) &gt;&gt; 6;
3736     V = (s[i * 4 + 3]) &gt;&gt; 6;
3737 
3738     GST_WRITE_UINT16_LE (da + i, A);
3739     GST_WRITE_UINT16_LE (dy + i, Y);
3740     GST_WRITE_UINT16_LE (du + i, U);
3741     GST_WRITE_UINT16_LE (dv + i, V);
3742   }
3743 }
3744 
3745 #define PACK_A444_10BE GST_VIDEO_FORMAT_AYUV64, unpack_A444_10BE, 1, pack_A444_10BE
3746 static void
3747 unpack_A444_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3748     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3749     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3750 {
3751   int i;
3752   const guint16 *restrict sa = GET_A_LINE (y);
3753   const guint16 *restrict sy = GET_Y_LINE (y);
3754   const guint16 *restrict su = GET_U_LINE (y);
3755   const guint16 *restrict sv = GET_V_LINE (y);
3756   guint16 *restrict d = dest, A, Y, U, V;
3757 
3758   sa += x;
3759   sy += x;
3760   su += x;
3761   sv += x;
3762 
3763   for (i = 0; i &lt; width; i++) {
3764     A = GST_READ_UINT16_BE (sa + i) &lt;&lt; 6;
3765     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 6;
3766     U = GST_READ_UINT16_BE (su + i) &lt;&lt; 6;
3767     V = GST_READ_UINT16_BE (sv + i) &lt;&lt; 6;
3768 
3769     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3770       A |= (A &gt;&gt; 10);
3771       Y |= (Y &gt;&gt; 10);
3772       U |= (U &gt;&gt; 10);
3773       V |= (V &gt;&gt; 10);
3774     }
3775 
3776     d[i * 4 + 0] = A;
3777     d[i * 4 + 1] = Y;
3778     d[i * 4 + 2] = U;
3779     d[i * 4 + 3] = V;
3780   }
3781 }
3782 
3783 static void
3784 pack_A444_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3785     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3786     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3787     gint y, gint width)
3788 {
3789   int i;
3790   guint16 *restrict da = GET_A_LINE (y);
3791   guint16 *restrict dy = GET_Y_LINE (y);
3792   guint16 *restrict du = GET_U_LINE (y);
3793   guint16 *restrict dv = GET_V_LINE (y);
3794   guint16 A, Y, U, V;
3795   const guint16 *restrict s = src;
3796 
3797   for (i = 0; i &lt; width; i++) {
3798     A = s[i * 4 + 0] &gt;&gt; 6;
3799     Y = s[i * 4 + 1] &gt;&gt; 6;
3800     U = s[i * 4 + 2] &gt;&gt; 6;
3801     V = s[i * 4 + 3] &gt;&gt; 6;
3802 
3803     GST_WRITE_UINT16_BE (da + i, A);
3804     GST_WRITE_UINT16_BE (dy + i, Y);
3805     GST_WRITE_UINT16_BE (du + i, U);
3806     GST_WRITE_UINT16_BE (dv + i, V);
3807   }
3808 }
3809 
3810 #define PACK_A420_10LE GST_VIDEO_FORMAT_AYUV64, unpack_A420_10LE, 1, pack_A420_10LE
3811 static void
3812 unpack_A420_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3813     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3814     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3815 {
3816   int i;
3817   gint uv = GET_UV_420 (y, flags);
3818   const guint16 *restrict sa = GET_A_LINE (y);
3819   const guint16 *restrict sy = GET_Y_LINE (y);
3820   const guint16 *restrict su = GET_U_LINE (uv);
3821   const guint16 *restrict sv = GET_V_LINE (uv);
3822   guint16 *restrict d = dest, A, Y, U, V;
3823 
3824   sa += x;
3825   sy += x;
3826   su += x &gt;&gt; 1;
3827   sv += x &gt;&gt; 1;
3828 
3829   for (i = 0; i &lt; width; i++) {
3830     A = GST_READ_UINT16_LE (sa + i) &lt;&lt; 6;
3831     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 6;
3832     U = GST_READ_UINT16_LE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
3833     V = GST_READ_UINT16_LE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
3834 
3835     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3836       A |= (A &gt;&gt; 10);
3837       Y |= (Y &gt;&gt; 10);
3838       U |= (U &gt;&gt; 10);
3839       V |= (V &gt;&gt; 10);
3840     }
3841 
3842     d[i * 4 + 0] = A;
3843     d[i * 4 + 1] = Y;
3844     d[i * 4 + 2] = U;
3845     d[i * 4 + 3] = V;
3846 
3847     if (x &amp; 1) {
3848       x = 0;
3849       su++;
3850       sv++;
3851     }
3852   }
3853 }
3854 
3855 static void
3856 pack_A420_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3857     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3858     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3859     gint y, gint width)
3860 {
3861   int i;
3862   gint uv = GET_UV_420 (y, flags);
3863   guint16 *restrict da = GET_A_LINE (y);
3864   guint16 *restrict dy = GET_Y_LINE (y);
3865   guint16 *restrict du = GET_U_LINE (uv);
3866   guint16 *restrict dv = GET_V_LINE (uv);
3867   guint16 A0, Y0, A1, Y1, U, V;
3868   const guint16 *restrict s = src;
3869 
3870   if (IS_CHROMA_LINE_420 (y, flags)) {
3871     for (i = 0; i &lt; width - 1; i += 2) {
3872       A0 = s[i * 4 + 0] &gt;&gt; 6;
3873       Y0 = s[i * 4 + 1] &gt;&gt; 6;
3874       A1 = s[i * 4 + 4] &gt;&gt; 6;
3875       Y1 = s[i * 4 + 5] &gt;&gt; 6;
3876       U = s[i * 4 + 2] &gt;&gt; 6;
3877       V = s[i * 4 + 3] &gt;&gt; 6;
3878 
3879       GST_WRITE_UINT16_LE (da + i + 0, A0);
3880       GST_WRITE_UINT16_LE (dy + i + 0, Y0);
3881       GST_WRITE_UINT16_LE (da + i + 1, A1);
3882       GST_WRITE_UINT16_LE (dy + i + 1, Y1);
3883       GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3884       GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
3885     }
3886     if (i == width - 1) {
3887       A0 = s[i * 4 + 0] &gt;&gt; 6;
3888       Y0 = s[i * 4 + 1] &gt;&gt; 6;
3889       U = s[i * 4 + 2] &gt;&gt; 6;
3890       V = s[i * 4 + 3] &gt;&gt; 6;
3891 
3892       GST_WRITE_UINT16_LE (da + i, A0);
3893       GST_WRITE_UINT16_LE (dy + i, Y0);
3894       GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
3895       GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
3896     }
3897   } else {
3898     for (i = 0; i &lt; width; i++) {
3899       A0 = s[i * 4 + 0] &gt;&gt; 6;
3900       Y0 = s[i * 4 + 1] &gt;&gt; 6;
3901       GST_WRITE_UINT16_LE (da + i, A0);
3902       GST_WRITE_UINT16_LE (dy + i, Y0);
3903     }
3904   }
3905 }
3906 
3907 #define PACK_A420_10BE GST_VIDEO_FORMAT_AYUV64, unpack_A420_10BE, 1, pack_A420_10BE
3908 static void
3909 unpack_A420_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3910     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
3911     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
3912 {
3913   int i;
3914   gint uv = GET_UV_420 (y, flags);
3915   const guint16 *restrict sa = GET_A_LINE (y);
3916   const guint16 *restrict sy = GET_Y_LINE (y);
3917   const guint16 *restrict su = GET_U_LINE (uv);
3918   const guint16 *restrict sv = GET_V_LINE (uv);
3919   guint16 *restrict d = dest, A, Y, U, V;
3920 
3921   sa += x;
3922   sy += x;
3923   su += x &gt;&gt; 1;
3924   sv += x &gt;&gt; 1;
3925 
3926   for (i = 0; i &lt; width; i++) {
3927     A = GST_READ_UINT16_BE (sa + i) &lt;&lt; 6;
3928     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 6;
3929     U = GST_READ_UINT16_BE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
3930     V = GST_READ_UINT16_BE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
3931 
3932     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
3933       A |= (A &gt;&gt; 10);
3934       Y |= (Y &gt;&gt; 10);
3935       U |= (U &gt;&gt; 10);
3936       V |= (V &gt;&gt; 10);
3937     }
3938 
3939     d[i * 4 + 0] = A;
3940     d[i * 4 + 1] = Y;
3941     d[i * 4 + 2] = U;
3942     d[i * 4 + 3] = V;
3943 
3944     if (x &amp; 1) {
3945       x = 0;
3946       su++;
3947       sv++;
3948     }
3949   }
3950 }
3951 
3952 static void
3953 pack_A420_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
3954     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
3955     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
3956     gint y, gint width)
3957 {
3958   int i;
3959   gint uv = GET_UV_420 (y, flags);
3960   guint16 *restrict da = GET_A_LINE (y);
3961   guint16 *restrict dy = GET_Y_LINE (y);
3962   guint16 *restrict du = GET_U_LINE (uv);
3963   guint16 *restrict dv = GET_V_LINE (uv);
3964   guint16 A0, Y0, A1, Y1, U, V;
3965   const guint16 *restrict s = src;
3966 
3967   if (IS_CHROMA_LINE_420 (y, flags)) {
3968     for (i = 0; i &lt; width - 1; i += 2) {
3969       A0 = s[i * 4 + 0] &gt;&gt; 6;
3970       Y0 = s[i * 4 + 1] &gt;&gt; 6;
3971       A1 = s[i * 4 + 4] &gt;&gt; 6;
3972       Y1 = s[i * 4 + 5] &gt;&gt; 6;
3973       U = s[i * 4 + 2] &gt;&gt; 6;
3974       V = s[i * 4 + 3] &gt;&gt; 6;
3975 
3976       GST_WRITE_UINT16_BE (da + i + 0, A0);
3977       GST_WRITE_UINT16_BE (dy + i + 0, Y0);
3978       GST_WRITE_UINT16_BE (da + i + 1, A1);
3979       GST_WRITE_UINT16_BE (dy + i + 1, Y1);
3980       GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3981       GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
3982     }
3983     if (i == width - 1) {
3984       A0 = s[i * 4 + 0] &gt;&gt; 6;
3985       Y0 = s[i * 4 + 1] &gt;&gt; 6;
3986       U = s[i * 4 + 2] &gt;&gt; 6;
3987       V = s[i * 4 + 3] &gt;&gt; 6;
3988 
3989       GST_WRITE_UINT16_BE (da + i, A0);
3990       GST_WRITE_UINT16_BE (dy + i, Y0);
3991       GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
3992       GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
3993     }
3994   } else {
3995     for (i = 0; i &lt; width; i++) {
3996       A0 = s[i * 4 + 0] &gt;&gt; 6;
3997       Y0 = s[i * 4 + 1] &gt;&gt; 6;
3998       GST_WRITE_UINT16_BE (da + i, A0);
3999       GST_WRITE_UINT16_BE (dy + i, Y0);
4000     }
4001   }
4002 }
4003 
4004 #define PACK_A422_10LE GST_VIDEO_FORMAT_AYUV64, unpack_A422_10LE, 1, pack_A422_10LE
4005 static void
4006 unpack_A422_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4007     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
4008     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
4009 {
4010   int i;
4011   const guint16 *restrict sa = GET_A_LINE (y);
4012   const guint16 *restrict sy = GET_Y_LINE (y);
4013   const guint16 *restrict su = GET_U_LINE (y);
4014   const guint16 *restrict sv = GET_V_LINE (y);
4015   guint16 *restrict d = dest, A, Y, U, V;
4016 
4017   sa += x;
4018   sy += x;
4019   su += x &gt;&gt; 1;
4020   sv += x &gt;&gt; 1;
4021 
4022   for (i = 0; i &lt; width; i++) {
4023     A = GST_READ_UINT16_LE (sa + i) &lt;&lt; 6;
4024     Y = GST_READ_UINT16_LE (sy + i) &lt;&lt; 6;
4025     U = GST_READ_UINT16_LE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
4026     V = GST_READ_UINT16_LE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
4027 
4028     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4029       A |= (A &gt;&gt; 10);
4030       Y |= (Y &gt;&gt; 10);
4031       U |= (U &gt;&gt; 10);
4032       V |= (V &gt;&gt; 10);
4033     }
4034 
4035     d[i * 4 + 0] = A;
4036     d[i * 4 + 1] = Y;
4037     d[i * 4 + 2] = U;
4038     d[i * 4 + 3] = V;
4039 
4040     if (x &amp; 1) {
4041       x = 0;
4042       su++;
4043       sv++;
4044     }
4045   }
4046 }
4047 
4048 static void
4049 pack_A422_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4050     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
4051     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
4052     gint y, gint width)
4053 {
4054   int i;
4055   guint16 *restrict da = GET_A_LINE (y);
4056   guint16 *restrict dy = GET_Y_LINE (y);
4057   guint16 *restrict du = GET_U_LINE (y);
4058   guint16 *restrict dv = GET_V_LINE (y);
4059   guint16 A0, Y0, A1, Y1, U, V;
4060   const guint16 *restrict s = src;
4061 
4062   for (i = 0; i &lt; width - 1; i += 2) {
4063     A0 = s[i * 4 + 0] &gt;&gt; 6;
4064     Y0 = s[i * 4 + 1] &gt;&gt; 6;
4065     A1 = s[i * 4 + 4] &gt;&gt; 6;
4066     Y1 = s[i * 4 + 5] &gt;&gt; 6;
4067     U = s[i * 4 + 2] &gt;&gt; 6;
4068     V = s[i * 4 + 3] &gt;&gt; 6;
4069 
4070     GST_WRITE_UINT16_LE (da + i + 0, A0);
4071     GST_WRITE_UINT16_LE (dy + i + 0, Y0);
4072     GST_WRITE_UINT16_LE (da + i + 1, A1);
4073     GST_WRITE_UINT16_LE (dy + i + 1, Y1);
4074     GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
4075     GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
4076   }
4077   if (i == width - 1) {
4078     A0 = s[i * 4 + 0] &gt;&gt; 6;
4079     Y0 = s[i * 4 + 1] &gt;&gt; 6;
4080     U = s[i * 4 + 2] &gt;&gt; 6;
4081     V = s[i * 4 + 3] &gt;&gt; 6;
4082 
4083     GST_WRITE_UINT16_LE (da + i, A0);
4084     GST_WRITE_UINT16_LE (dy + i, Y0);
4085     GST_WRITE_UINT16_LE (du + (i &gt;&gt; 1), U);
4086     GST_WRITE_UINT16_LE (dv + (i &gt;&gt; 1), V);
4087   }
4088 }
4089 
4090 #define PACK_A422_10BE GST_VIDEO_FORMAT_AYUV64, unpack_A422_10BE, 1, pack_A422_10BE
4091 static void
4092 unpack_A422_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4093     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
4094     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
4095 {
4096   int i;
4097   const guint16 *restrict sa = GET_A_LINE (y);
4098   const guint16 *restrict sy = GET_Y_LINE (y);
4099   const guint16 *restrict su = GET_U_LINE (y);
4100   const guint16 *restrict sv = GET_V_LINE (y);
4101   guint16 *restrict d = dest, A, Y, U, V;
4102 
4103   sa += x;
4104   sy += x;
4105   su += x &gt;&gt; 1;
4106   sv += x &gt;&gt; 1;
4107 
4108   for (i = 0; i &lt; width; i++) {
4109     A = GST_READ_UINT16_BE (sa + i) &lt;&lt; 6;
4110     Y = GST_READ_UINT16_BE (sy + i) &lt;&lt; 6;
4111     U = GST_READ_UINT16_BE (su + (i &gt;&gt; 1)) &lt;&lt; 6;
4112     V = GST_READ_UINT16_BE (sv + (i &gt;&gt; 1)) &lt;&lt; 6;
4113 
4114     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4115       A |= (A &gt;&gt; 10);
4116       Y |= (Y &gt;&gt; 10);
4117       U |= (U &gt;&gt; 10);
4118       V |= (V &gt;&gt; 10);
4119     }
4120 
4121     d[i * 4 + 0] = A;
4122     d[i * 4 + 1] = Y;
4123     d[i * 4 + 2] = U;
4124     d[i * 4 + 3] = V;
4125 
4126     if (x &amp; 1) {
4127       x = 0;
4128       su++;
4129       sv++;
4130     }
4131   }
4132 }
4133 
4134 static void
4135 pack_A422_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4136     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
4137     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
4138     gint y, gint width)
4139 {
4140   int i;
4141   guint16 *restrict da = GET_A_LINE (y);
4142   guint16 *restrict dy = GET_Y_LINE (y);
4143   guint16 *restrict du = GET_U_LINE (y);
4144   guint16 *restrict dv = GET_V_LINE (y);
4145   guint16 A0, Y0, A1, Y1, U, V;
4146   const guint16 *restrict s = src;
4147 
4148   for (i = 0; i &lt; width - 1; i += 2) {
4149     A0 = s[i * 4 + 0] &gt;&gt; 6;
4150     Y0 = s[i * 4 + 1] &gt;&gt; 6;
4151     A1 = s[i * 4 + 4] &gt;&gt; 6;
4152     Y1 = s[i * 4 + 5] &gt;&gt; 6;
4153     U = s[i * 4 + 2] &gt;&gt; 6;
4154     V = s[i * 4 + 3] &gt;&gt; 6;
4155 
4156     GST_WRITE_UINT16_BE (da + i + 0, A0);
4157     GST_WRITE_UINT16_BE (dy + i + 0, Y0);
4158     GST_WRITE_UINT16_BE (da + i + 1, A1);
4159     GST_WRITE_UINT16_BE (dy + i + 1, Y1);
4160     GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
4161     GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
4162   }
4163   if (i == width - 1) {
4164     A0 = s[i * 4 + 0] &gt;&gt; 6;
4165     Y0 = s[i * 4 + 1] &gt;&gt; 6;
4166     U = s[i * 4 + 2] &gt;&gt; 6;
4167     V = s[i * 4 + 3] &gt;&gt; 6;
4168 
4169     GST_WRITE_UINT16_BE (da + i, A0);
4170     GST_WRITE_UINT16_BE (dy + i, Y0);
4171     GST_WRITE_UINT16_BE (du + (i &gt;&gt; 1), U);
4172     GST_WRITE_UINT16_BE (dv + (i &gt;&gt; 1), V);
4173   }
4174 }
4175 
4176 static void
4177 get_tile_NV12 (gint tile_width, gint ts, gint tx, gint ty,
4178     const gpointer data[GST_VIDEO_MAX_PLANES],
4179     const gint stride[GST_VIDEO_MAX_PLANES],
4180     gpointer tile_data[GST_VIDEO_MAX_PLANES],
4181     gint tile_stride[GST_VIDEO_MAX_PLANES])
4182 {
4183   gsize offset;
4184 
4185   /* index of Y tile */
4186   offset = gst_video_tile_get_index (GST_VIDEO_TILE_MODE_ZFLIPZ_2X2,
4187       tx, ty, GST_VIDEO_TILE_X_TILES (stride[0]),
4188       GST_VIDEO_TILE_Y_TILES (stride[0]));
4189   offset &lt;&lt;= ts;
4190   tile_data[0] = ((guint8 *) data[0]) + offset;
4191 
4192   /* index of UV tile */
4193   offset = gst_video_tile_get_index (GST_VIDEO_TILE_MODE_ZFLIPZ_2X2,
4194       tx, ty &gt;&gt; 1, GST_VIDEO_TILE_X_TILES (stride[1]),
4195       GST_VIDEO_TILE_Y_TILES (stride[1]));
4196   offset &lt;&lt;= ts;
4197   /* On odd rows we return the second part of the UV tile */
4198   offset |= (ty &amp; 1) &lt;&lt; (ts - 1);
4199   tile_data[1] = ((guint8 *) data[1]) + offset;
4200 
4201   tile_stride[0] = tile_stride[1] = tile_width;
4202 }
4203 
4204 #define PACK_NV12_64Z32 GST_VIDEO_FORMAT_AYUV, unpack_NV12_64Z32, 1, pack_NV12_64Z32
4205 static void
4206 unpack_NV12_64Z32 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4207     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
4208     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
4209 {
4210   const GstVideoFormatInfo *unpack_info, *finfo;
4211   guint8 *line = dest;
4212   gint ws, hs, ts, tile_width;
4213   gint ntx, tx, ty;
4214   gint unpack_pstride;
4215 
4216   ws = GST_VIDEO_FORMAT_INFO_TILE_WS (info);
4217   hs = GST_VIDEO_FORMAT_INFO_TILE_HS (info);
4218   ts = ws + hs;
4219 
4220   tile_width = 1 &lt;&lt; ws;
4221 
4222   /* we reuse these unpack functions */
4223   finfo = gst_video_format_get_info (GST_VIDEO_FORMAT_NV12);
4224 
4225   /* get pstride of unpacked format */
4226   unpack_info = gst_video_format_get_info (info-&gt;unpack_format);
4227   unpack_pstride = GST_VIDEO_FORMAT_INFO_PSTRIDE (unpack_info, 0);
4228 
4229   /* first x tile to convert */
4230   tx = x &gt;&gt; ws;
4231   /* Last tile to convert */
4232   ntx = ((x + width - 1) &gt;&gt; ws) + 1;
4233   /* The row we are going to convert */
4234   ty = y &gt;&gt; hs;
4235 
4236   /* y position in a tile */
4237   y = y &amp; ((1 &lt;&lt; hs) - 1);
4238   /* x position in a tile */
4239   x = x &amp; (tile_width - 1);
4240 
4241   for (; tx &lt; ntx; tx++) {
4242     gpointer tdata[GST_VIDEO_MAX_PLANES];
4243     gint tstride[GST_VIDEO_MAX_PLANES];
4244     gint unpack_width;
4245 
4246     get_tile_NV12 (tile_width, ts, tx, ty, data, stride, tdata, tstride);
4247 
4248     /* the number of bytes left to unpack */
4249     unpack_width = MIN (width - x, tile_width - x);
4250 
4251     finfo-&gt;unpack_func (finfo, flags, line, tdata, tstride, x, y, unpack_width);
4252 
4253     x = 0;
4254     width -= unpack_width;
4255     line += unpack_width * unpack_pstride;
4256   }
4257 }
4258 
4259 static void
4260 pack_NV12_64Z32 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4261     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
4262     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
4263     gint y, gint width)
4264 {
4265   const GstVideoFormatInfo *pack_info, *finfo;
4266   guint8 *line = src;
4267   gint ws, hs, ts, tile_width;
4268   gint ntx, tx, ty;
4269   gint pack_pstride;
4270 
4271   ws = GST_VIDEO_FORMAT_INFO_TILE_WS (info);
4272   hs = GST_VIDEO_FORMAT_INFO_TILE_HS (info);
4273   ts = ws + hs;
4274 
4275   tile_width = 1 &lt;&lt; ws;
4276 
4277   /* we reuse these pack functions */
4278   finfo = gst_video_format_get_info (GST_VIDEO_FORMAT_NV12);
4279 
4280   /* get pstride of packed format */
4281   pack_info = gst_video_format_get_info (info-&gt;unpack_format);
4282   pack_pstride = GST_VIDEO_FORMAT_INFO_PSTRIDE (pack_info, 0);
4283 
4284   /* Last tile to convert */
4285   ntx = ((width - 1) &gt;&gt; ws) + 1;
4286   /* The row we are going to convert */
4287   ty = y &gt;&gt; hs;
4288 
4289   /* y position in a tile */
4290   y = y &amp; ((1 &lt;&lt; hs) - 1);
4291 
4292   for (tx = 0; tx &lt; ntx; tx++) {
4293     gpointer tdata[GST_VIDEO_MAX_PLANES];
4294     gint tstride[GST_VIDEO_MAX_PLANES];
4295     gint pack_width;
4296 
4297     get_tile_NV12 (tile_width, ts, tx, ty, data, stride, tdata, tstride);
4298 
4299     /* the number of bytes left to pack */
4300     pack_width = MIN (width, tile_width);
4301 
4302     finfo-&gt;pack_func (finfo, flags, line, sstride, tdata, tstride,
4303         chroma_site, y, pack_width);
4304 
4305     width -= pack_width;
4306     line += pack_width * pack_pstride;
4307   }
4308 }
4309 
4310 #define PACK_P010_10BE GST_VIDEO_FORMAT_AYUV64, unpack_P010_10BE, 1, pack_P010_10BE
4311 static void
4312 unpack_P010_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4313     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
4314     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
4315 {
4316   int i;
4317   gint uv = GET_UV_420 (y, flags);
4318   const guint16 *restrict sy = GET_PLANE_LINE (0, y);
4319   const guint16 *restrict suv = GET_PLANE_LINE (1, uv);
4320   guint16 *restrict d = dest, Y0, Y1, U, V;
4321 
4322   sy += x;
4323   suv += (x &amp; ~1);
4324 
4325   if (x &amp; 1) {
4326     Y0 = GST_READ_UINT16_BE (sy);
4327     U = GST_READ_UINT16_BE (suv);
4328     V = GST_READ_UINT16_BE (suv + 1);
4329 
4330     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4331       Y0 |= (Y0 &gt;&gt; 10);
4332       U |= (U &gt;&gt; 10);
4333       V |= (V &gt;&gt; 10);
4334     }
4335 
4336     d[0] = 0xffff;
4337     d[1] = Y0;
4338     d[2] = U;
4339     d[3] = V;
4340     width--;
4341     d += 4;
4342     sy += 1;
4343     suv += 2;
4344   }
4345 
4346   for (i = 0; i &lt; width / 2; i++) {
4347     Y0 = GST_READ_UINT16_BE (sy + 2 * i);
4348     Y1 = GST_READ_UINT16_BE (sy + 2 * i + 1);
4349     U = GST_READ_UINT16_BE (suv + 2 * i);
4350     V = GST_READ_UINT16_BE (suv + 2 * i + 1);
4351 
4352     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4353       Y0 |= (Y0 &gt;&gt; 10);
4354       Y1 |= (Y1 &gt;&gt; 10);
4355       U |= (U &gt;&gt; 10);
4356       V |= (V &gt;&gt; 10);
4357     }
4358 
4359     d[i * 8 + 0] = 0xffff;
4360     d[i * 8 + 1] = Y0;
4361     d[i * 8 + 2] = U;
4362     d[i * 8 + 3] = V;
4363     d[i * 8 + 4] = 0xffff;
4364     d[i * 8 + 5] = Y1;
4365     d[i * 8 + 6] = U;
4366     d[i * 8 + 7] = V;
4367   }
4368 
4369   if (width &amp; 1) {
4370     gint i = width - 1;
4371 
4372     Y0 = GST_READ_UINT16_BE (sy + i);
4373     U = GST_READ_UINT16_BE (suv + i);
4374     V = GST_READ_UINT16_BE (suv + i + 1);
4375 
4376     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4377       Y0 |= (Y0 &gt;&gt; 10);
4378       U |= (U &gt;&gt; 10);
4379       V |= (V &gt;&gt; 10);
4380     }
4381 
4382     d[i * 4 + 0] = 0xffff;
4383     d[i * 4 + 1] = Y0;
4384     d[i * 4 + 2] = U;
4385     d[i * 4 + 3] = V;
4386   }
4387 }
4388 
4389 static void
4390 pack_P010_10BE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4391     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
4392     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
4393     gint y, gint width)
4394 {
4395   int i;
4396   gint uv = GET_UV_420 (y, flags);
4397   guint16 *restrict dy = GET_PLANE_LINE (0, y);
4398   guint16 *restrict duv = GET_PLANE_LINE (1, uv);
4399   guint16 Y0, Y1, U, V;
4400   const guint16 *restrict s = src;
4401 
4402   if (IS_CHROMA_LINE_420 (y, flags)) {
4403     for (i = 0; i &lt; width / 2; i++) {
4404       Y0 = s[i * 8 + 1] &amp; 0xffc0;
4405       Y1 = s[i * 8 + 5] &amp; 0xffc0;
4406       U = s[i * 8 + 2] &amp; 0xffc0;
4407       V = s[i * 8 + 3] &amp; 0xffc0;
4408 
4409       GST_WRITE_UINT16_BE (dy + i * 2 + 0, Y0);
4410       GST_WRITE_UINT16_BE (dy + i * 2 + 1, Y1);
4411       GST_WRITE_UINT16_BE (duv + i * 2 + 0, U);
4412       GST_WRITE_UINT16_BE (duv + i * 2 + 1, V);
4413     }
4414     if (width &amp; 1) {
4415       gint i = width - 1;
4416 
4417       Y0 = s[i * 4 + 1] &amp; 0xffc0;
4418       U = s[i * 4 + 2] &amp; 0xffc0;
4419       V = s[i * 4 + 3] &amp; 0xffc0;
4420 
4421       GST_WRITE_UINT16_BE (dy + i, Y0);
4422       GST_WRITE_UINT16_BE (duv + i + 0, U);
4423       GST_WRITE_UINT16_BE (duv + i + 1, V);
4424     }
4425   } else {
4426     for (i = 0; i &lt; width; i++) {
4427       Y0 = s[i * 4 + 1] &amp; 0xffc0;
4428       GST_WRITE_UINT16_BE (dy + i, Y0);
4429     }
4430   }
4431 }
4432 
4433 #define PACK_P010_10LE GST_VIDEO_FORMAT_AYUV64, unpack_P010_10LE, 1, pack_P010_10LE
4434 static void
4435 unpack_P010_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4436     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
4437     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
4438 {
4439   int i;
4440   gint uv = GET_UV_420 (y, flags);
4441   const guint16 *restrict sy = GET_PLANE_LINE (0, y);
4442   const guint16 *restrict suv = GET_PLANE_LINE (1, uv);
4443   guint16 *restrict d = dest, Y0, Y1, U, V;
4444 
4445   sy += x;
4446   suv += (x &amp; ~1);
4447 
4448   if (x &amp; 1) {
4449     Y0 = GST_READ_UINT16_LE (sy);
4450     U = GST_READ_UINT16_LE (suv);
4451     V = GST_READ_UINT16_LE (suv + 1);
4452 
4453     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4454       Y0 |= (Y0 &gt;&gt; 10);
4455       U |= (U &gt;&gt; 10);
4456       V |= (V &gt;&gt; 10);
4457     }
4458 
4459     d[0] = 0xffff;
4460     d[1] = Y0;
4461     d[2] = U;
4462     d[3] = V;
4463     width--;
4464     d += 4;
4465     sy += 1;
4466     suv += 2;
4467   }
4468 
4469   for (i = 0; i &lt; width / 2; i++) {
4470     Y0 = GST_READ_UINT16_LE (sy + 2 * i);
4471     Y1 = GST_READ_UINT16_LE (sy + 2 * i + 1);
4472     U = GST_READ_UINT16_LE (suv + 2 * i);
4473     V = GST_READ_UINT16_LE (suv + 2 * i + 1);
4474 
4475     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4476       Y0 |= (Y0 &gt;&gt; 10);
4477       Y1 |= (Y1 &gt;&gt; 10);
4478       U |= (U &gt;&gt; 10);
4479       V |= (V &gt;&gt; 10);
4480     }
4481 
4482     d[i * 8 + 0] = 0xffff;
4483     d[i * 8 + 1] = Y0;
4484     d[i * 8 + 2] = U;
4485     d[i * 8 + 3] = V;
4486     d[i * 8 + 4] = 0xffff;
4487     d[i * 8 + 5] = Y1;
4488     d[i * 8 + 6] = U;
4489     d[i * 8 + 7] = V;
4490   }
4491 
4492   if (width &amp; 1) {
4493     gint i = width - 1;
4494 
4495     Y0 = GST_READ_UINT16_LE (sy + i);
4496     U = GST_READ_UINT16_LE (suv + i);
4497     V = GST_READ_UINT16_LE (suv + i + 1);
4498 
4499     if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4500       Y0 |= (Y0 &gt;&gt; 10);
4501       U |= (U &gt;&gt; 10);
4502       V |= (V &gt;&gt; 10);
4503     }
4504 
4505     d[i * 4 + 0] = 0xffff;
4506     d[i * 4 + 1] = Y0;
4507     d[i * 4 + 2] = U;
4508     d[i * 4 + 3] = V;
4509   }
4510 }
4511 
4512 static void
4513 pack_P010_10LE (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4514     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
4515     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
4516     gint y, gint width)
4517 {
4518   int i;
4519   gint uv = GET_UV_420 (y, flags);
4520   guint16 *restrict dy = GET_PLANE_LINE (0, y);
4521   guint16 *restrict duv = GET_PLANE_LINE (1, uv);
4522   guint16 Y0, Y1, U, V;
4523   const guint16 *restrict s = src;
4524 
4525   if (IS_CHROMA_LINE_420 (y, flags)) {
4526     for (i = 0; i &lt; width / 2; i++) {
4527       Y0 = s[i * 8 + 1] &amp; 0xffc0;
4528       Y1 = s[i * 8 + 5] &amp; 0xffc0;
4529       U = s[i * 8 + 2] &amp; 0xffc0;
4530       V = s[i * 8 + 3] &amp; 0xffc0;
4531 
4532       GST_WRITE_UINT16_LE (dy + i * 2 + 0, Y0);
4533       GST_WRITE_UINT16_LE (dy + i * 2 + 1, Y1);
4534       GST_WRITE_UINT16_LE (duv + i * 2 + 0, U);
4535       GST_WRITE_UINT16_LE (duv + i * 2 + 1, V);
4536     }
4537     if (width &amp; 1) {
4538       gint i = width - 1;
4539 
4540       Y0 = s[i * 4 + 1] &amp; 0xffc0;
4541       U = s[i * 4 + 2] &amp; 0xffc0;
4542       V = s[i * 4 + 3] &amp; 0xffc0;
4543 
4544       GST_WRITE_UINT16_LE (dy + i, Y0);
4545       GST_WRITE_UINT16_LE (duv + i + 0, U);
4546       GST_WRITE_UINT16_LE (duv + i + 1, V);
4547     }
4548   } else {
4549     for (i = 0; i &lt; width; i++) {
4550       Y0 = s[i * 4 + 1] &amp; 0xffc0;
4551       GST_WRITE_UINT16_LE (dy + i, Y0);
4552     }
4553   }
4554 }
4555 
4556 #define PACK_GRAY10_LE32 GST_VIDEO_FORMAT_AYUV64, unpack_GRAY10_LE32, 1, pack_GRAY10_LE32
4557 static void
4558 unpack_GRAY10_LE32 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4559     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
4560     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
4561 {
4562   gint i;
4563   const guint32 *restrict sy = GET_PLANE_LINE (0, y);
4564   guint16 *restrict d = dest;
4565   gint num_words = (width + 2) / 3;
4566 
4567   /* Y data is packed into little endian 32bit words, with the 2 MSB being
4568    * padding. There is only 1 pattern.
4569    * -&gt; padding | Y1 | Y2 | Y3
4570    */
4571 
4572   for (i = 0; i &lt; num_words; i++) {
4573     gint num_comps = MIN (3, width - i * 3);
4574     guint pix = i * 3;
4575     gsize doff = pix * 4;
4576     gint c;
4577     guint32 Y;
4578 
4579     Y = GST_READ_UINT32_LE (sy + i);
4580 
4581     for (c = 0; c &lt; num_comps; c++) {
4582       guint16 Yn;
4583 
4584       /* For Y, we simply read 10 bit and shift it out */
4585       Yn = (Y &amp; 0x03ff) &lt;&lt; 6;
4586       Y &gt;&gt;= 10;
4587 
4588       if (G_UNLIKELY (pix + c &lt; x))
4589         continue;
4590 
4591       if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE))
4592         Yn |= Yn &gt;&gt; 10;
4593 
4594       d[doff + 0] = 0xffff;
4595       d[doff + 1] = Yn;
4596       d[doff + 2] = 0x8000;
4597       d[doff + 3] = 0x8000;
4598 
4599       doff += 4;
4600     }
4601   }
4602 }
4603 
4604 static void
4605 pack_GRAY10_LE32 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4606     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
4607     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
4608     gint y, gint width)
4609 {
4610   gint i;
4611   guint32 *restrict dy = GET_PLANE_LINE (0, y);
4612   const guint16 *restrict s = src;
4613   gint num_words = (width + 2) / 3;
4614 
4615   for (i = 0; i &lt; num_words; i++) {
4616     gint num_comps = MIN (3, width - i * 3);
4617     guint pix = i * 3;
4618     gsize soff = pix * 4;
4619     gint c;
4620     guint32 Y = 0;
4621 
4622     for (c = 0; c &lt; num_comps; c++) {
4623       Y |= s[soff + 1] &gt;&gt; 6 &lt;&lt; (10 * c);
4624       soff += 4;
4625     }
4626 
4627     GST_WRITE_UINT32_LE (dy + i, Y);
4628   }
4629 }
4630 
4631 #define PACK_NV12_10LE32 GST_VIDEO_FORMAT_AYUV64, unpack_NV12_10LE32, 1, pack_NV12_10LE32
4632 static void
4633 unpack_NV12_10LE32 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4634     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
4635     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
4636 {
4637   gint i;
4638   gint uv = GET_UV_420 (y, flags);
4639   const guint32 *restrict sy = GET_PLANE_LINE (0, y);
4640   const guint32 *restrict suv = GET_PLANE_LINE (1, uv);
4641   guint16 *restrict d = dest;
4642   gint num_words = (width + 2) / 3;
4643   guint32 UV = 0;
4644   guint16 Un = 0, Vn = 0;
4645 
4646   /* Y data is packed into little endian 32bit words, with the 2 MSB being
4647    * padding. There is only 1 pattern.
4648    * -&gt; padding | Y1 | Y2 | Y3
4649    *
4650    * UV is packed the same way, though we end up with 2 patterns:
4651    * -&gt; U | V | U | padding
4652    * -&gt; V | U | V | padding
4653    */
4654 
4655   /* FIXME unroll the 6 states ? */
4656 
4657   for (i = 0; i &lt; num_words; i++) {
4658     gint num_comps = MIN (3, width - i * 3);
4659     guint pix = i * 3;
4660     gsize doff = pix * 4;
4661     gint c;
4662     guint32 Y;
4663 
4664     Y = GST_READ_UINT32_LE (sy + i);
4665 
4666     for (c = 0; c &lt; num_comps; c++) {
4667       guint16 Yn;
4668 
4669       /* For Y, we simply read 10 bit and shift it out */
4670       Yn = (Y &amp; 0x03ff) &lt;&lt; 6;
4671       Y &gt;&gt;= 10;
4672 
4673       /* Unpacking UV has been reduced to a cycle of 6 states. The following
4674        * code is a reduce version of:
4675        * 0: - Read first UV word (UVU)
4676        *      Unpack U and V
4677        * 1: - Resued U/V from 1 (sub-sampling)
4678        * 2: - Unpack remaining U value
4679        *    - Read following UV word (VUV)
4680        *    - Unpack V value
4681        * 3: - Reuse U/V from 2 (sub-sampling)
4682        * 4: - Unpack remaining U
4683        *    - Unpack remaining V
4684        * 5: - Reuse UV/V from 4 (sub-sampling)
4685        */
4686       switch ((pix + c) % 6) {
4687         case 0:
4688           UV = GST_READ_UINT32_LE (suv + i);
4689           /* fallthrough */
4690         case 4:
4691           Un = (UV &amp; 0x03ff) &lt;&lt; 6;
4692           UV &gt;&gt;= 10;
4693           Vn = (UV &amp; 0x03ff) &lt;&lt; 6;
4694           UV &gt;&gt;= 10;
4695           break;
4696         case 2:
4697           Un = (UV &amp; 0x03ff) &lt;&lt; 6;
4698           UV = GST_READ_UINT32_LE (suv + i + 1);
4699           Vn = (UV &amp; 0x03ff) &lt;&lt; 6;
4700           UV &gt;&gt;= 10;
4701           break;
4702         default:
4703           /* keep value */
4704           break;
4705       }
4706 
4707       if (G_UNLIKELY (pix + c &lt; x))
4708         continue;
4709 
4710       if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4711         Yn |= Yn &gt;&gt; 10;
4712         Un |= Un &gt;&gt; 10;
4713         Vn |= Vn &gt;&gt; 10;
4714       }
4715 
4716       d[doff + 0] = 0xffff;
4717       d[doff + 1] = Yn;
4718       d[doff + 2] = Un;
4719       d[doff + 3] = Vn;
4720 
4721       doff += 4;
4722     }
4723   }
4724 }
4725 
4726 static void
4727 pack_NV12_10LE32 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4728     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
4729     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
4730     gint y, gint width)
4731 {
4732   gint i;
4733   gint uv = GET_UV_420 (y, flags);
4734   guint32 *restrict dy = GET_PLANE_LINE (0, y);
4735   guint32 *restrict duv = GET_PLANE_LINE (1, uv);
4736   const guint16 *restrict s = src;
4737   gint num_words = (width + 2) / 3;
4738   guint32 UV = 0;
4739 
4740   /* FIXME unroll the 6 states ? */
4741 
4742   for (i = 0; i &lt; num_words; i++) {
4743     gint num_comps = MIN (3, width - i * 3);
4744     guint pix = i * 3;
4745     gsize soff = pix * 4;
4746     gint c;
4747     guint32 Y = 0;
4748 
4749     for (c = 0; c &lt; num_comps; c++) {
4750       Y |= s[soff + 1] &gt;&gt; 6 &lt;&lt; (10 * c);
4751 
4752       if (IS_CHROMA_LINE_420 (y, flags)) {
4753         switch ((pix + c) % 6) {
4754           case 0:
4755             UV = s[soff + 2] &gt;&gt; 6;
4756             UV |= s[soff + 3] &gt;&gt; 6 &lt;&lt; 10;
4757             break;
4758           case 2:
4759             UV |= s[soff + 2] &gt;&gt; 6 &lt;&lt; 20;
4760             GST_WRITE_UINT32_LE (duv + i, UV);
4761             UV = s[soff + 3] &gt;&gt; 6;
4762             break;
4763           case 4:
4764             UV |= s[soff + 2] &gt;&gt; 6 &lt;&lt; 10;
4765             UV |= s[soff + 3] &gt;&gt; 6 &lt;&lt; 20;
4766             GST_WRITE_UINT32_LE (duv + i, UV);
4767             break;
4768           default:
4769             /* keep value */
4770             break;
4771         }
4772       }
4773 
4774       soff += 4;
4775     }
4776 
4777     GST_WRITE_UINT32_LE (dy + i, Y);
4778 
4779     if (IS_CHROMA_LINE_420 (y, flags) &amp;&amp; num_comps &lt; 3)
4780       GST_WRITE_UINT32_LE (duv + i, UV);
4781 
4782   }
4783 }
4784 
4785 #define PACK_NV16_10LE32 GST_VIDEO_FORMAT_AYUV64, unpack_NV16_10LE32, 1, pack_NV16_10LE32
4786 static void
4787 unpack_NV16_10LE32 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4788     gpointer dest, const gpointer data[GST_VIDEO_MAX_PLANES],
4789     const gint stride[GST_VIDEO_MAX_PLANES], gint x, gint y, gint width)
4790 {
4791   gint i;
4792   const guint32 *restrict sy = GET_PLANE_LINE (0, y);
4793   const guint32 *restrict suv = GET_PLANE_LINE (1, y);
4794   guint16 *restrict d = dest;
4795   gint num_words = (width + 2) / 3;
4796   guint32 UV = 0;
4797   guint16 Un = 0, Vn = 0;
4798 
4799   /* Y data is packed into little endian 32bit words, with the 2 MSB being
4800    * padding. There is only 1 pattern.
4801    * -&gt; padding | Y1 | Y2 | Y3
4802    *
4803    * UV is packed the same way, though we end up with 2 patterns:
4804    * -&gt; U | V | U | padding
4805    * -&gt; V | U | V | padding
4806    */
4807 
4808   /* FIXME unroll the 6 states ? */
4809 
4810   for (i = 0; i &lt; num_words; i++) {
4811     gint num_comps = MIN (3, width - i * 3);
4812     guint pix = i * 3;
4813     gsize doff = pix * 4;
4814     gint c;
4815     guint32 Y;
4816 
4817     Y = GST_READ_UINT32_LE (sy + i);
4818 
4819     for (c = 0; c &lt; num_comps; c++) {
4820       guint16 Yn;
4821 
4822       /* For Y, we simply read 10 bit and shift it out */
4823       Yn = (Y &amp; 0x03ff) &lt;&lt; 6;
4824       Y &gt;&gt;= 10;
4825 
4826       /* Unpacking UV has been reduced to a cycle of 6 states. The following
4827        * code is a reduce version of:
4828        * 0: - Read first UV word (UVU)
4829        *      Unpack U and V
4830        * 1: - Resued U/V from 1 (sub-sampling)
4831        * 2: - Unpack remaining U value
4832        *    - Read following UV word (VUV)
4833        *    - Unpack V value
4834        * 3: - Reuse U/V from 2 (sub-sampling)
4835        * 4: - Unpack remaining U
4836        *    - Unpack remaining V
4837        * 5: - Reuse UV/V from 4 (sub-sampling)
4838        */
4839       switch ((pix + c) % 6) {
4840         case 0:
4841           UV = GST_READ_UINT32_LE (suv + i);
4842           /* fallthrough */
4843         case 4:
4844           Un = (UV &amp; 0x03ff) &lt;&lt; 6;
4845           UV &gt;&gt;= 10;
4846           Vn = (UV &amp; 0x03ff) &lt;&lt; 6;
4847           UV &gt;&gt;= 10;
4848           break;
4849         case 2:
4850           Un = (UV &amp; 0x03ff) &lt;&lt; 6;
4851           UV = GST_READ_UINT32_LE (suv + i + 1);
4852           Vn = (UV &amp; 0x03ff) &lt;&lt; 6;
4853           UV &gt;&gt;= 10;
4854           break;
4855         default:
4856           /* keep value */
4857           break;
4858       }
4859 
4860       if (G_UNLIKELY (pix + c &lt; x))
4861         continue;
4862 
4863       if (!(flags &amp; GST_VIDEO_PACK_FLAG_TRUNCATE_RANGE)) {
4864         Yn |= Yn &gt;&gt; 10;
4865         Un |= Un &gt;&gt; 10;
4866         Vn |= Vn &gt;&gt; 10;
4867       }
4868 
4869       d[doff + 0] = 0xffff;
4870       d[doff + 1] = Yn;
4871       d[doff + 2] = Un;
4872       d[doff + 3] = Vn;
4873 
4874       doff += 4;
4875     }
4876   }
4877 }
4878 
4879 static void
4880 pack_NV16_10LE32 (const GstVideoFormatInfo * info, GstVideoPackFlags flags,
4881     const gpointer src, gint sstride, gpointer data[GST_VIDEO_MAX_PLANES],
4882     const gint stride[GST_VIDEO_MAX_PLANES], GstVideoChromaSite chroma_site,
4883     gint y, gint width)
4884 {
4885   gint i;
4886   guint32 *restrict dy = GET_PLANE_LINE (0, y);
4887   guint32 *restrict duv = GET_PLANE_LINE (1, y);
4888   const guint16 *restrict s = src;
4889   gint num_words = (width + 2) / 3;
4890   guint32 UV = 0;
4891 
4892   /* FIXME unroll the 6 states ? */
4893 
4894   for (i = 0; i &lt; num_words; i++) {
4895     gint num_comps = MIN (3, width - i * 3);
4896     guint pix = i * 3;
4897     gsize soff = pix * 4;
4898     gint c;
4899     guint32 Y = 0;
4900 
4901     for (c = 0; c &lt; num_comps; c++) {
4902       Y |= s[soff + 1] &gt;&gt; 6 &lt;&lt; (10 * c);
4903 
4904       switch ((pix + c) % 6) {
4905         case 0:
4906           UV = s[soff + 2] &gt;&gt; 6;
4907           UV |= s[soff + 3] &gt;&gt; 6 &lt;&lt; 10;
4908           break;
4909         case 2:
4910           UV |= s[soff + 2] &gt;&gt; 6 &lt;&lt; 20;
4911           GST_WRITE_UINT32_LE (duv + i, UV);
4912           UV = s[soff + 3] &gt;&gt; 6;
4913           break;
4914         case 4:
4915           UV |= s[soff + 2] &gt;&gt; 6 &lt;&lt; 10;
4916           UV |= s[soff + 3] &gt;&gt; 6 &lt;&lt; 20;
4917           GST_WRITE_UINT32_LE (duv + i, UV);
4918           break;
4919         default:
4920           /* keep value */
4921           break;
4922       }
4923 
4924       soff += 4;
4925     }
4926 
4927     GST_WRITE_UINT32_LE (dy + i, Y);
4928 
4929     if (num_comps &lt; 3)
4930       GST_WRITE_UINT32_LE (duv + i, UV);
4931   }
4932 }
4933 
<a name="35" id="anc35"></a>






















































































































































































































































4934 
4935 typedef struct
4936 {
4937   guint32 fourcc;
4938   GstVideoFormatInfo info;
4939 } VideoFormat;
4940 
4941 /* depths: bits, n_components, shift, depth */
4942 #define DPTH0            0, 0, { 0, 0, 0, 0 }, { 0, 0, 0, 0 }
4943 #define DPTH8            8, 1, { 0, 0, 0, 0 }, { 8, 0, 0, 0 }
4944 #define DPTH8_32         8, 2, { 0, 0, 0, 0 }, { 8, 32, 0, 0 }
4945 #define DPTH888          8, 3, { 0, 0, 0, 0 }, { 8, 8, 8, 0 }
4946 #define DPTH8888         8, 4, { 0, 0, 0, 0 }, { 8, 8, 8, 8 }
4947 #define DPTH8880         8, 4, { 0, 0, 0, 0 }, { 8, 8, 8, 0 }
4948 #define DPTH10           10, 1, { 0, 0, 0, 0 }, { 10, 0, 0, 0 }
4949 #define DPTH10_10_10     10, 3, { 0, 0, 0, 0 }, { 10, 10, 10, 0 }
4950 #define DPTH10_10_10_10  10, 4, { 0, 0, 0, 0 }, { 10, 10, 10, 10 }
4951 #define DPTH10_10_10_HI  16, 3, { 6, 6, 6, 0 }, { 10, 10, 10, 0 }
<a name="36" id="anc36"></a>
4952 #define DPTH12_12_12     12, 3, { 0, 0, 0, 0 }, { 12, 12, 12, 0 }
4953 #define DPTH12_12_12_12  12, 4, { 0, 0, 0, 0 }, { 12, 12, 12, 12 }
4954 #define DPTH16           16, 1, { 0, 0, 0, 0 }, { 16, 0, 0, 0 }
4955 #define DPTH16_16_16     16, 3, { 0, 0, 0, 0 }, { 16, 16, 16, 0 }
4956 #define DPTH16_16_16_16  16, 4, { 0, 0, 0, 0 }, { 16, 16, 16, 16 }
4957 #define DPTH555          16, 3, { 10, 5, 0, 0 }, { 5, 5, 5, 0 }
4958 #define DPTH565          16, 3, { 11, 5, 0, 0 }, { 5, 6, 5, 0 }
4959 
4960 /* pixel strides */
4961 #define PSTR0             { 0, 0, 0, 0 }
4962 #define PSTR1             { 1, 0, 0, 0 }
4963 #define PSTR14            { 1, 4, 0, 0 }
4964 #define PSTR111           { 1, 1, 1, 0 }
4965 #define PSTR1111          { 1, 1, 1, 1 }
4966 #define PSTR122           { 1, 2, 2, 0 }
4967 #define PSTR2             { 2, 0, 0, 0 }
4968 #define PSTR222           { 2, 2, 2, 0 }
4969 #define PSTR2222          { 2, 2, 2, 2 }
4970 #define PSTR244           { 2, 4, 4, 0 }
4971 #define PSTR444           { 4, 4, 4, 0 }
4972 #define PSTR4444          { 4, 4, 4, 4 }
4973 #define PSTR333           { 3, 3, 3, 0 }
4974 #define PSTR488           { 4, 8, 8, 0 }
4975 #define PSTR8888          { 8, 8, 8, 8 }
4976 
4977 /* planes, in what plane do we find component N */
4978 #define PLANE_NA          0, { 0, 0, 0, 0 }
4979 #define PLANE0            1, { 0, 0, 0, 0 }
4980 #define PLANE01           2, { 0, 1, 0, 0 }
4981 #define PLANE011          2, { 0, 1, 1, 0 }
4982 #define PLANE012          3, { 0, 1, 2, 0 }
4983 #define PLANE0123         4, { 0, 1, 2, 3 }
4984 #define PLANE021          3, { 0, 2, 1, 0 }
4985 #define PLANE201          3, { 2, 0, 1, 0 }
4986 #define PLANE2013         4, { 2, 0, 1, 3 }
4987 
4988 /* offsets */
4989 #define OFFS0             { 0, 0, 0, 0 }
4990 #define OFFS013           { 0, 1, 3, 0 }
4991 #define OFFS102           { 1, 0, 2, 0 }
4992 #define OFFS1230          { 1, 2, 3, 0 }
4993 #define OFFS012           { 0, 1, 2, 0 }
4994 #define OFFS210           { 2, 1, 0, 0 }
4995 #define OFFS123           { 1, 2, 3, 0 }
4996 #define OFFS321           { 3, 2, 1, 0 }
4997 #define OFFS0123          { 0, 1, 2, 3 }
4998 #define OFFS2103          { 2, 1, 0, 3 }
4999 #define OFFS3210          { 3, 2, 1, 0 }
5000 #define OFFS031           { 0, 3, 1, 0 }
5001 #define OFFS204           { 2, 0, 4, 0 }
5002 #define OFFS001           { 0, 0, 1, 0 }
5003 #define OFFS010           { 0, 1, 0, 0 }
5004 #define OFFS104           { 1, 0, 4, 0 }
5005 #define OFFS2460          { 2, 4, 6, 0 }
5006 
5007 /* subsampling, w_sub, h_sub */
5008 #define SUB410            { 0, 2, 2, 0 }, { 0, 2, 2, 0 }
5009 #define SUB411            { 0, 2, 2, 0 }, { 0, 0, 0, 0 }
5010 #define SUB420            { 0, 1, 1, 0 }, { 0, 1, 1, 0 }
5011 #define SUB422            { 0, 1, 1, 0 }, { 0, 0, 0, 0 }
5012 #define SUB4              { 0, 0, 0, 0 }, { 0, 0, 0, 0 }
5013 #define SUB44             { 0, 0, 0, 0 }, { 0, 0, 0, 0 }
5014 #define SUB444            { 0, 0, 0, 0 }, { 0, 0, 0, 0 }
5015 #define SUB4444           { 0, 0, 0, 0 }, { 0, 0, 0, 0 }
5016 #define SUB4204           { 0, 1, 1, 0 }, { 0, 1, 1, 0 }
5017 #define SUB4224           { 0, 1, 1, 0 }, { 0, 0, 0, 0 }
5018 
5019 /* tile_mode, tile_width, tile_height */
5020 #define TILE_64x32(mode) GST_VIDEO_TILE_MODE_ ##mode, 6, 5
5021 
5022 #define MAKE_YUV_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack ) \
5023  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV, depth, pstride, plane, offs, sub, pack } }
5024 #define MAKE_YUV_LE_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack ) \
5025  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5026 #define MAKE_YUVA_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack) \
5027  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV | GST_VIDEO_FORMAT_FLAG_ALPHA, depth, pstride, plane, offs, sub, pack } }
5028 #define MAKE_YUVA_LE_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack ) \
5029  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV | GST_VIDEO_FORMAT_FLAG_ALPHA | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5030 #define MAKE_YUVA_PACK_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack) \
5031  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV | GST_VIDEO_FORMAT_FLAG_ALPHA | GST_VIDEO_FORMAT_FLAG_UNPACK, depth, pstride, plane, offs, sub, pack } }
5032 #define MAKE_YUVA_LE_PACK_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack) \
5033  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV | GST_VIDEO_FORMAT_FLAG_ALPHA | GST_VIDEO_FORMAT_FLAG_UNPACK | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5034 #define MAKE_YUV_C_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack) \
5035  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV | GST_VIDEO_FORMAT_FLAG_COMPLEX, depth, pstride, plane, offs, sub, pack } }
5036 #define MAKE_YUV_C_LE_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack) \
5037  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV | GST_VIDEO_FORMAT_FLAG_COMPLEX | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5038 #define MAKE_YUV_T_FORMAT(name, desc, fourcc, depth, pstride, plane, offs, sub, pack, tile) \
5039  { fourcc, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_YUV | GST_VIDEO_FORMAT_FLAG_COMPLEX | GST_VIDEO_FORMAT_FLAG_TILED, depth, pstride, plane, offs, sub, pack, tile } }
5040 
5041 #define MAKE_RGB_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5042  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_RGB, depth, pstride, plane, offs, sub, pack } }
5043 #define MAKE_RGB_LE_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5044  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_RGB | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5045 #define MAKE_RGBA_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5046  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_RGB | GST_VIDEO_FORMAT_FLAG_ALPHA, depth, pstride, plane, offs, sub, pack } }
5047 #define MAKE_RGBA_LE_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5048  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_RGB | GST_VIDEO_FORMAT_FLAG_ALPHA | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5049 #define MAKE_RGBAP_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5050  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_RGB | GST_VIDEO_FORMAT_FLAG_ALPHA | GST_VIDEO_FORMAT_FLAG_PALETTE, depth, pstride, plane, offs, sub, pack } }
5051 #define MAKE_RGBA_PACK_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5052  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_RGB | GST_VIDEO_FORMAT_FLAG_ALPHA | GST_VIDEO_FORMAT_FLAG_UNPACK, depth, pstride, plane, offs, sub, pack } }
5053 #define MAKE_RGBA_LE_PACK_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5054  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_RGB | GST_VIDEO_FORMAT_FLAG_ALPHA | GST_VIDEO_FORMAT_FLAG_UNPACK | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5055 
5056 #define MAKE_GRAY_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5057  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_GRAY, depth, pstride, plane, offs, sub, pack } }
5058 #define MAKE_GRAY_LE_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5059  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_GRAY | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5060 #define MAKE_GRAY_C_LE_FORMAT(name, desc, depth, pstride, plane, offs, sub, pack) \
5061  { 0x00000000, {GST_VIDEO_FORMAT_ ##name, G_STRINGIFY(name), desc, GST_VIDEO_FORMAT_FLAG_GRAY | GST_VIDEO_FORMAT_FLAG_COMPLEX | GST_VIDEO_FORMAT_FLAG_LE, depth, pstride, plane, offs, sub, pack } }
5062 
5063 static const VideoFormat formats[] = {
5064   {0x00000000, {GST_VIDEO_FORMAT_UNKNOWN, &quot;UNKNOWN&quot;, &quot;unknown video&quot;, 0, DPTH0,
5065           PSTR0, PLANE_NA, OFFS0}},
5066   {0x00000000, {GST_VIDEO_FORMAT_ENCODED, &quot;ENCODED&quot;, &quot;encoded video&quot;,
5067           GST_VIDEO_FORMAT_FLAG_COMPLEX, DPTH0, PSTR0, PLANE_NA, OFFS0}},
5068 
5069   MAKE_YUV_FORMAT (I420, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;I&#39;, &#39;4&#39;, &#39;2&#39;, &#39;0&#39;),
5070       DPTH888, PSTR111, PLANE012, OFFS0, SUB420, PACK_420),
5071   MAKE_YUV_FORMAT (YV12, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;V&#39;, &#39;1&#39;, &#39;2&#39;),
5072       DPTH888, PSTR111, PLANE021, OFFS0, SUB420, PACK_420),
5073   MAKE_YUV_FORMAT (YUY2, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;U&#39;, &#39;Y&#39;, &#39;2&#39;),
5074       DPTH888, PSTR244, PLANE0, OFFS013, SUB422, PACK_YUY2),
5075   MAKE_YUV_FORMAT (UYVY, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;U&#39;, &#39;Y&#39;, &#39;V&#39;, &#39;Y&#39;),
5076       DPTH888, PSTR244, PLANE0, OFFS102, SUB422, PACK_UYVY),
5077   MAKE_YUVA_PACK_FORMAT (AYUV, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;A&#39;, &#39;Y&#39;, &#39;U&#39;,
5078           &#39;V&#39;), DPTH8888, PSTR4444, PLANE0, OFFS1230, SUB4444, PACK_AYUV),
5079   MAKE_RGB_FORMAT (RGBx, &quot;raw video&quot;, DPTH888, PSTR444, PLANE0, OFFS012,
5080       SUB444, PACK_RGBA),
5081   MAKE_RGB_FORMAT (BGRx, &quot;raw video&quot;, DPTH888, PSTR444, PLANE0, OFFS210,
5082       SUB444, PACK_BGRA),
5083   MAKE_RGB_FORMAT (xRGB, &quot;raw video&quot;, DPTH888, PSTR444, PLANE0, OFFS123,
5084       SUB444, PACK_ARGB),
5085   MAKE_RGB_FORMAT (xBGR, &quot;raw video&quot;, DPTH888, PSTR444, PLANE0, OFFS321,
5086       SUB444, PACK_ABGR),
5087   MAKE_RGBA_FORMAT (RGBA, &quot;raw video&quot;, DPTH8888, PSTR4444, PLANE0, OFFS0123,
5088       SUB4444, PACK_RGBA),
5089   MAKE_RGBA_FORMAT (BGRA, &quot;raw video&quot;, DPTH8888, PSTR4444, PLANE0, OFFS2103,
5090       SUB4444, PACK_BGRA),
5091   MAKE_RGBA_PACK_FORMAT (ARGB, &quot;raw video&quot;, DPTH8888, PSTR4444, PLANE0,
5092       OFFS1230, SUB4444, PACK_ARGB),
5093   MAKE_RGBA_FORMAT (ABGR, &quot;raw video&quot;, DPTH8888, PSTR4444, PLANE0, OFFS3210,
5094       SUB4444, PACK_ABGR),
5095   MAKE_RGB_FORMAT (RGB, &quot;raw video&quot;, DPTH888, PSTR333, PLANE0, OFFS012, SUB444,
5096       PACK_RGB),
5097   MAKE_RGB_FORMAT (BGR, &quot;raw video&quot;, DPTH888, PSTR333, PLANE0, OFFS210, SUB444,
5098       PACK_BGR),
5099 
5100   MAKE_YUV_FORMAT (Y41B, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;1&#39;, &#39;B&#39;),
5101       DPTH888, PSTR111, PLANE012, OFFS0, SUB411, PACK_Y41B),
5102   MAKE_YUV_FORMAT (Y42B, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;2&#39;, &#39;B&#39;),
5103       DPTH888, PSTR111, PLANE012, OFFS0, SUB422, PACK_Y42B),
5104   MAKE_YUV_FORMAT (YVYU, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;V&#39;, &#39;Y&#39;, &#39;U&#39;),
5105       DPTH888, PSTR244, PLANE0, OFFS031, SUB422, PACK_YVYU),
5106   MAKE_YUV_FORMAT (Y444, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;),
5107       DPTH888, PSTR111, PLANE012, OFFS0, SUB444, PACK_Y444),
5108   MAKE_YUV_C_FORMAT (v210, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;v&#39;, &#39;2&#39;, &#39;1&#39;, &#39;0&#39;),
5109       DPTH10_10_10, PSTR0, PLANE0, OFFS0, SUB422, PACK_v210),
5110   MAKE_YUV_FORMAT (v216, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;v&#39;, &#39;2&#39;, &#39;1&#39;, &#39;6&#39;),
5111       DPTH16_16_16, PSTR488, PLANE0, OFFS204, SUB422, PACK_v216),
5112   MAKE_YUV_FORMAT (NV12, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;1&#39;, &#39;2&#39;),
5113       DPTH888, PSTR122, PLANE011, OFFS001, SUB420, PACK_NV12),
5114   MAKE_YUV_FORMAT (NV21, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;2&#39;, &#39;1&#39;),
5115       DPTH888, PSTR122, PLANE011, OFFS010, SUB420, PACK_NV21),
5116 
5117   MAKE_GRAY_FORMAT (GRAY8, &quot;raw video&quot;, DPTH8, PSTR1, PLANE0, OFFS0, SUB4,
5118       PACK_GRAY8),
5119   MAKE_GRAY_FORMAT (GRAY16_BE, &quot;raw video&quot;, DPTH16, PSTR2, PLANE0, OFFS0, SUB4,
5120       PACK_GRAY16_BE),
5121   MAKE_GRAY_LE_FORMAT (GRAY16_LE, &quot;raw video&quot;, DPTH16, PSTR2, PLANE0, OFFS0,
5122       SUB4, PACK_GRAY16_LE),
5123 
5124   MAKE_YUV_FORMAT (v308, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;v&#39;, &#39;3&#39;, &#39;0&#39;, &#39;8&#39;),
5125       DPTH888, PSTR333, PLANE0, OFFS012, SUB444, PACK_v308),
5126 
5127 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
5128   MAKE_RGB_LE_FORMAT (RGB16, &quot;raw video&quot;, DPTH565, PSTR222, PLANE0, OFFS0,
5129       SUB444, PACK_RGB16),
5130   MAKE_RGB_LE_FORMAT (BGR16, &quot;raw video&quot;, DPTH565, PSTR222, PLANE0, OFFS0,
5131       SUB444, PACK_BGR16),
5132   MAKE_RGB_LE_FORMAT (RGB15, &quot;raw video&quot;, DPTH555, PSTR222, PLANE0, OFFS0,
5133       SUB444, PACK_RGB15),
5134   MAKE_RGB_LE_FORMAT (BGR15, &quot;raw video&quot;, DPTH555, PSTR222, PLANE0, OFFS0,
5135       SUB444, PACK_BGR15),
5136 #else
5137   MAKE_RGB_FORMAT (RGB16, &quot;raw video&quot;, DPTH565, PSTR222, PLANE0, OFFS0, SUB444,
5138       PACK_RGB16),
5139   MAKE_RGB_FORMAT (BGR16, &quot;raw video&quot;, DPTH565, PSTR222, PLANE0, OFFS0, SUB444,
5140       PACK_BGR16),
5141   MAKE_RGB_FORMAT (RGB15, &quot;raw video&quot;, DPTH555, PSTR222, PLANE0, OFFS0, SUB444,
5142       PACK_RGB15),
5143   MAKE_RGB_FORMAT (BGR15, &quot;raw video&quot;, DPTH555, PSTR222, PLANE0, OFFS0, SUB444,
5144       PACK_BGR15),
5145 #endif
5146 
5147   MAKE_YUV_C_FORMAT (UYVP, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;U&#39;, &#39;Y&#39;, &#39;V&#39;, &#39;P&#39;),
5148       DPTH10_10_10, PSTR0, PLANE0, OFFS0, SUB422, PACK_UYVP),
5149   MAKE_YUVA_FORMAT (A420, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;A&#39;, &#39;4&#39;, &#39;2&#39;, &#39;0&#39;),
5150       DPTH8888, PSTR1111, PLANE0123, OFFS0, SUB4204, PACK_A420),
5151   MAKE_RGBAP_FORMAT (RGB8P, &quot;raw video&quot;, DPTH8_32, PSTR14, PLANE01,
5152       OFFS0, SUB44, PACK_RGB8P),
5153   MAKE_YUV_FORMAT (YUV9, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;U&#39;, &#39;V&#39;, &#39;9&#39;),
5154       DPTH888, PSTR111, PLANE012, OFFS0, SUB410, PACK_410),
5155   MAKE_YUV_FORMAT (YVU9, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;Y&#39;, &#39;V&#39;, &#39;U&#39;, &#39;9&#39;),
5156       DPTH888, PSTR111, PLANE021, OFFS0, SUB410, PACK_410),
5157   MAKE_YUV_FORMAT (IYU1, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;I&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;1&#39;),
5158       DPTH888, PSTR0, PLANE0, OFFS104, SUB411, PACK_IYU1),
5159 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
5160   MAKE_RGBA_LE_PACK_FORMAT (ARGB64, &quot;raw video&quot;, DPTH16_16_16_16, PSTR8888,
5161       PLANE0,
5162       OFFS2460, SUB444, PACK_ARGB64),
5163   MAKE_YUVA_LE_PACK_FORMAT (AYUV64, &quot;raw video&quot;, 0x00000000, DPTH16_16_16_16,
5164       PSTR8888, PLANE0, OFFS2460, SUB444, PACK_AYUV64),
5165 #else
5166   MAKE_RGBA_PACK_FORMAT (ARGB64, &quot;raw video&quot;, DPTH16_16_16_16, PSTR8888, PLANE0,
5167       OFFS2460, SUB444, PACK_ARGB64),
5168   MAKE_YUVA_PACK_FORMAT (AYUV64, &quot;raw video&quot;, 0x00000000, DPTH16_16_16_16,
5169       PSTR8888, PLANE0, OFFS2460, SUB444, PACK_AYUV64),
5170 #endif
5171   MAKE_RGB_FORMAT (r210, &quot;raw video&quot;, DPTH10_10_10, PSTR444, PLANE0, OFFS0,
5172       SUB444, PACK_r210),
5173   MAKE_YUV_FORMAT (I420_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10,
5174       PSTR222, PLANE012, OFFS0, SUB420, PACK_I420_10BE),
5175   MAKE_YUV_LE_FORMAT (I420_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10,
5176       PSTR222, PLANE012, OFFS0, SUB420, PACK_I420_10LE),
5177   MAKE_YUV_FORMAT (I422_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10,
5178       PSTR222, PLANE012, OFFS0, SUB422, PACK_I422_10BE),
5179   MAKE_YUV_LE_FORMAT (I422_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10,
5180       PSTR222, PLANE012, OFFS0, SUB422, PACK_I422_10LE),
5181   MAKE_YUV_FORMAT (Y444_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10,
5182       PSTR222, PLANE012, OFFS0, SUB444, PACK_Y444_10BE),
5183   MAKE_YUV_LE_FORMAT (Y444_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10,
5184       PSTR222, PLANE012, OFFS0, SUB444, PACK_Y444_10LE),
5185   MAKE_RGB_FORMAT (GBR, &quot;raw video&quot;, DPTH888, PSTR111, PLANE201, OFFS0, SUB444,
5186       PACK_GBR),
5187   MAKE_RGB_FORMAT (GBR_10BE, &quot;raw video&quot;, DPTH10_10_10, PSTR222, PLANE201,
5188       OFFS0, SUB444, PACK_GBR_10BE),
5189   MAKE_RGB_LE_FORMAT (GBR_10LE, &quot;raw video&quot;, DPTH10_10_10, PSTR222, PLANE201,
5190       OFFS0, SUB444, PACK_GBR_10LE),
5191   MAKE_YUV_FORMAT (NV16, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;1&#39;, &#39;6&#39;),
5192       DPTH888, PSTR122, PLANE011, OFFS001, SUB422, PACK_NV16),
5193   MAKE_YUV_FORMAT (NV24, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;2&#39;, &#39;4&#39;),
5194       DPTH888, PSTR122, PLANE011, OFFS001, SUB444, PACK_NV24),
5195   MAKE_YUV_T_FORMAT (NV12_64Z32, &quot;raw video&quot;,
5196       GST_MAKE_FOURCC (&#39;T&#39;, &#39;M&#39;, &#39;1&#39;, &#39;2&#39;), DPTH8880, PSTR122, PLANE011,
5197       OFFS001, SUB420, PACK_NV12_64Z32, TILE_64x32 (ZFLIPZ_2X2)),
5198   MAKE_YUVA_FORMAT (A420_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5199       PSTR2222, PLANE0123, OFFS0, SUB4204, PACK_A420_10BE),
5200   MAKE_YUVA_LE_FORMAT (A420_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5201       PSTR2222, PLANE0123, OFFS0, SUB4204, PACK_A420_10LE),
5202   MAKE_YUVA_FORMAT (A422_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5203       PSTR2222, PLANE0123, OFFS0, SUB4224, PACK_A422_10BE),
5204   MAKE_YUVA_LE_FORMAT (A422_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5205       PSTR2222, PLANE0123, OFFS0, SUB4224, PACK_A422_10LE),
5206   MAKE_YUVA_FORMAT (A444_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5207       PSTR2222, PLANE0123, OFFS0, SUB4444, PACK_A444_10BE),
5208   MAKE_YUVA_LE_FORMAT (A444_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_10,
5209       PSTR2222, PLANE0123, OFFS0, SUB4444, PACK_A444_10LE),
5210   MAKE_YUV_FORMAT (NV61, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;6&#39;, &#39;1&#39;),
5211       DPTH888, PSTR122, PLANE011, OFFS010, SUB422, PACK_NV61),
5212   MAKE_YUV_FORMAT (P010_10BE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_HI,
5213       PSTR244, PLANE011, OFFS001, SUB420, PACK_P010_10BE),
5214   MAKE_YUV_LE_FORMAT (P010_10LE, &quot;raw video&quot;, 0x00000000, DPTH10_10_10_HI,
5215       PSTR244, PLANE011, OFFS001, SUB420, PACK_P010_10LE),
5216   MAKE_YUV_FORMAT (IYU2, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;I&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;2&#39;),
5217       DPTH888, PSTR333, PLANE0, OFFS102, SUB444, PACK_IYU2),
5218   MAKE_YUV_FORMAT (VYUY, &quot;raw video&quot;, GST_MAKE_FOURCC (&#39;V&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;Y&#39;),
5219       DPTH888, PSTR244, PLANE0, OFFS102, SUB422, PACK_VYUY),
5220   MAKE_RGBA_FORMAT (GBRA, &quot;raw video&quot;, DPTH8888, PSTR1111, PLANE2013,
5221       OFFS0, SUB4444, PACK_GBRA),
<a name="37" id="anc37"></a><span class="line-modified">5222   MAKE_RGBA_FORMAT (GBRA_10BE, &quot;raw video&quot;, DPTH10_10_10_10, PSTR222, PLANE2013,</span>
<span class="line-modified">5223       OFFS0, SUB4444, PACK_GBRA_10BE),</span>
<span class="line-modified">5224   MAKE_RGBA_LE_FORMAT (GBRA_10LE, &quot;raw video&quot;, DPTH10_10_10_10, PSTR222,</span>
<span class="line-modified">5225       PLANE2013,</span>
<span class="line-removed">5226       OFFS0, SUB4444, PACK_GBRA_10LE),</span>
5227   MAKE_RGB_FORMAT (GBR_12BE, &quot;raw video&quot;, DPTH12_12_12, PSTR222, PLANE201,
5228       OFFS0, SUB444, PACK_GBR_12BE),
5229   MAKE_RGB_LE_FORMAT (GBR_12LE, &quot;raw video&quot;, DPTH12_12_12, PSTR222, PLANE201,
5230       OFFS0, SUB444, PACK_GBR_12LE),
<a name="38" id="anc38"></a><span class="line-modified">5231   MAKE_RGBA_FORMAT (GBRA_12BE, &quot;raw video&quot;, DPTH12_12_12_12, PSTR222, PLANE2013,</span>
<span class="line-modified">5232       OFFS0, SUB4444, PACK_GBRA_12BE),</span>
<span class="line-modified">5233   MAKE_RGBA_LE_PACK_FORMAT (GBRA_12LE, &quot;raw video&quot;, DPTH12_12_12_12, PSTR222,</span>
5234       PLANE2013, OFFS0, SUB4444, PACK_GBRA_12LE),
5235   MAKE_YUV_FORMAT (I420_12BE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5236       PSTR222, PLANE012, OFFS0, SUB420, PACK_I420_12BE),
5237   MAKE_YUV_LE_FORMAT (I420_12LE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5238       PSTR222, PLANE012, OFFS0, SUB420, PACK_I420_12LE),
5239   MAKE_YUV_FORMAT (I422_12BE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5240       PSTR222, PLANE012, OFFS0, SUB422, PACK_I422_12BE),
5241   MAKE_YUV_LE_FORMAT (I422_12LE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5242       PSTR222, PLANE012, OFFS0, SUB422, PACK_I422_12LE),
5243   MAKE_YUV_FORMAT (Y444_12BE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5244       PSTR222, PLANE012, OFFS0, SUB444, PACK_Y444_12BE),
5245   MAKE_YUV_LE_FORMAT (Y444_12LE, &quot;raw video&quot;, 0x00000000, DPTH12_12_12,
5246       PSTR222, PLANE012, OFFS0, SUB444, PACK_Y444_12LE),
5247   MAKE_GRAY_C_LE_FORMAT (GRAY10_LE32, &quot;raw video&quot;, DPTH10, PSTR0, PLANE0, OFFS0,
5248       SUB4, PACK_GRAY10_LE32),
5249   MAKE_YUV_C_LE_FORMAT (NV12_10LE32, &quot;raw video&quot;,
5250       GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;1&#39;, &#39;5&#39;), DPTH10_10_10, PSTR0, PLANE011,
5251       OFFS001, SUB420, PACK_NV12_10LE32),
5252   MAKE_YUV_C_LE_FORMAT (NV16_10LE32, &quot;raw video&quot;,
5253       GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;2&#39;, &#39;0&#39;), DPTH10_10_10, PSTR0, PLANE011,
5254       OFFS001, SUB422, PACK_NV16_10LE32),
<a name="39" id="anc39"></a>











5255 };
5256 
5257 static GstVideoFormat
5258 gst_video_format_from_rgb32_masks (int red_mask, int green_mask, int blue_mask)
5259 {
5260   if (red_mask == 0xff000000 &amp;&amp; green_mask == 0x00ff0000 &amp;&amp;
5261       blue_mask == 0x0000ff00) {
5262     return GST_VIDEO_FORMAT_RGBx;
5263   }
5264   if (red_mask == 0x0000ff00 &amp;&amp; green_mask == 0x00ff0000 &amp;&amp;
5265       blue_mask == 0xff000000) {
5266     return GST_VIDEO_FORMAT_BGRx;
5267   }
5268   if (red_mask == 0x00ff0000 &amp;&amp; green_mask == 0x0000ff00 &amp;&amp;
5269       blue_mask == 0x000000ff) {
5270     return GST_VIDEO_FORMAT_xRGB;
5271   }
5272   if (red_mask == 0x000000ff &amp;&amp; green_mask == 0x0000ff00 &amp;&amp;
5273       blue_mask == 0x00ff0000) {
5274     return GST_VIDEO_FORMAT_xBGR;
5275   }
5276 
5277   return GST_VIDEO_FORMAT_UNKNOWN;
5278 }
5279 
5280 static GstVideoFormat
5281 gst_video_format_from_rgba32_masks (int red_mask, int green_mask,
5282     int blue_mask, int alpha_mask)
5283 {
5284   if (red_mask == 0xff000000 &amp;&amp; green_mask == 0x00ff0000 &amp;&amp;
5285       blue_mask == 0x0000ff00 &amp;&amp; alpha_mask == 0x000000ff) {
5286     return GST_VIDEO_FORMAT_RGBA;
5287   }
5288   if (red_mask == 0x0000ff00 &amp;&amp; green_mask == 0x00ff0000 &amp;&amp;
5289       blue_mask == 0xff000000 &amp;&amp; alpha_mask == 0x000000ff) {
5290     return GST_VIDEO_FORMAT_BGRA;
5291   }
5292   if (red_mask == 0x00ff0000 &amp;&amp; green_mask == 0x0000ff00 &amp;&amp;
5293       blue_mask == 0x000000ff &amp;&amp; alpha_mask == 0xff000000) {
5294     return GST_VIDEO_FORMAT_ARGB;
5295   }
5296   if (red_mask == 0x000000ff &amp;&amp; green_mask == 0x0000ff00 &amp;&amp;
5297       blue_mask == 0x00ff0000 &amp;&amp; alpha_mask == 0xff000000) {
5298     return GST_VIDEO_FORMAT_ABGR;
5299   }
5300   return GST_VIDEO_FORMAT_UNKNOWN;
5301 }
5302 
5303 static GstVideoFormat
5304 gst_video_format_from_rgb24_masks (int red_mask, int green_mask, int blue_mask)
5305 {
5306   if (red_mask == 0xff0000 &amp;&amp; green_mask == 0x00ff00 &amp;&amp; blue_mask == 0x0000ff) {
5307     return GST_VIDEO_FORMAT_RGB;
5308   }
5309   if (red_mask == 0x0000ff &amp;&amp; green_mask == 0x00ff00 &amp;&amp; blue_mask == 0xff0000) {
5310     return GST_VIDEO_FORMAT_BGR;
5311   }
5312 
5313   return GST_VIDEO_FORMAT_UNKNOWN;
5314 }
5315 
5316 #define GST_VIDEO_COMP1_MASK_16_INT 0xf800
5317 #define GST_VIDEO_COMP2_MASK_16_INT 0x07e0
5318 #define GST_VIDEO_COMP3_MASK_16_INT 0x001f
5319 
5320 #define GST_VIDEO_COMP1_MASK_15_INT 0x7c00
5321 #define GST_VIDEO_COMP2_MASK_15_INT 0x03e0
5322 #define GST_VIDEO_COMP3_MASK_15_INT 0x001f
5323 
5324 static GstVideoFormat
5325 gst_video_format_from_rgb16_masks (int red_mask, int green_mask, int blue_mask)
5326 {
5327   if (red_mask == GST_VIDEO_COMP1_MASK_16_INT
5328       &amp;&amp; green_mask == GST_VIDEO_COMP2_MASK_16_INT
5329       &amp;&amp; blue_mask == GST_VIDEO_COMP3_MASK_16_INT) {
5330     return GST_VIDEO_FORMAT_RGB16;
5331   }
5332   if (red_mask == GST_VIDEO_COMP3_MASK_16_INT
5333       &amp;&amp; green_mask == GST_VIDEO_COMP2_MASK_16_INT
5334       &amp;&amp; blue_mask == GST_VIDEO_COMP1_MASK_16_INT) {
5335     return GST_VIDEO_FORMAT_BGR16;
5336   }
5337   if (red_mask == GST_VIDEO_COMP1_MASK_15_INT
5338       &amp;&amp; green_mask == GST_VIDEO_COMP2_MASK_15_INT
5339       &amp;&amp; blue_mask == GST_VIDEO_COMP3_MASK_15_INT) {
5340     return GST_VIDEO_FORMAT_RGB15;
5341   }
5342   if (red_mask == GST_VIDEO_COMP3_MASK_15_INT
5343       &amp;&amp; green_mask == GST_VIDEO_COMP2_MASK_15_INT
5344       &amp;&amp; blue_mask == GST_VIDEO_COMP1_MASK_15_INT) {
5345     return GST_VIDEO_FORMAT_BGR15;
5346   }
5347   return GST_VIDEO_FORMAT_UNKNOWN;
5348 }
5349 
5350 /**
5351  * gst_video_format_from_masks:
5352  * @depth: the amount of bits used for a pixel
5353  * @bpp: the amount of bits used to store a pixel. This value is bigger than
5354  *   @depth
5355  * @endianness: the endianness of the masks, #G_LITTLE_ENDIAN or #G_BIG_ENDIAN
5356  * @red_mask: the red mask
5357  * @green_mask: the green mask
5358  * @blue_mask: the blue mask
5359  * @alpha_mask: the alpha mask, or 0 if no alpha mask
5360  *
5361  * Find the #GstVideoFormat for the given parameters.
5362  *
5363  * Returns: a #GstVideoFormat or GST_VIDEO_FORMAT_UNKNOWN when the parameters to
5364  * not specify a known format.
5365  */
5366 GstVideoFormat
5367 gst_video_format_from_masks (gint depth, gint bpp, gint endianness,
5368     guint red_mask, guint green_mask, guint blue_mask, guint alpha_mask)
5369 {
5370   GstVideoFormat format;
5371 
5372   /* our caps system handles 24/32bpp RGB as big-endian. */
<a name="40" id="anc40"></a><span class="line-modified">5373   if ((bpp == 24 || bpp == 32) &amp;&amp; endianness == G_LITTLE_ENDIAN) {</span>

5374     red_mask = GUINT32_TO_BE (red_mask);
5375     green_mask = GUINT32_TO_BE (green_mask);
5376     blue_mask = GUINT32_TO_BE (blue_mask);
5377     alpha_mask = GUINT32_TO_BE (alpha_mask);
5378     endianness = G_BIG_ENDIAN;
5379     if (bpp == 24) {
5380       red_mask &gt;&gt;= 8;
5381       green_mask &gt;&gt;= 8;
5382       blue_mask &gt;&gt;= 8;
5383     }
5384   }
5385 
<a name="41" id="anc41"></a><span class="line-modified">5386   if (depth == 30 &amp;&amp; bpp == 32) {</span>



5387     format = GST_VIDEO_FORMAT_r210;
5388   } else if (depth == 24 &amp;&amp; bpp == 32) {
5389     format = gst_video_format_from_rgb32_masks (red_mask, green_mask,
5390         blue_mask);
5391   } else if (depth == 32 &amp;&amp; bpp == 32 &amp;&amp; alpha_mask) {
5392     format = gst_video_format_from_rgba32_masks (red_mask, green_mask,
5393         blue_mask, alpha_mask);
5394   } else if (depth == 24 &amp;&amp; bpp == 24) {
5395     format = gst_video_format_from_rgb24_masks (red_mask, green_mask,
5396         blue_mask);
5397   } else if ((depth == 15 || depth == 16) &amp;&amp; bpp == 16 &amp;&amp;
5398       endianness == G_BYTE_ORDER) {
5399     format = gst_video_format_from_rgb16_masks (red_mask, green_mask,
5400         blue_mask);
5401   } else if (depth == 8 &amp;&amp; bpp == 8) {
5402     format = GST_VIDEO_FORMAT_RGB8P;
5403   } else if (depth == 64 &amp;&amp; bpp == 64) {
5404     format = gst_video_format_from_rgba32_masks (red_mask, green_mask,
5405         blue_mask, alpha_mask);
5406     if (format == GST_VIDEO_FORMAT_ARGB) {
5407       format = GST_VIDEO_FORMAT_ARGB64;
5408     } else {
5409       format = GST_VIDEO_FORMAT_UNKNOWN;
5410     }
5411   } else {
5412     format = GST_VIDEO_FORMAT_UNKNOWN;
5413   }
5414   return format;
5415 }
5416 
5417 /**
5418  * gst_video_format_from_fourcc:
5419  * @fourcc: a FOURCC value representing raw YUV video
5420  *
5421  * Converts a FOURCC value into the corresponding #GstVideoFormat.
5422  * If the FOURCC cannot be represented by #GstVideoFormat,
5423  * #GST_VIDEO_FORMAT_UNKNOWN is returned.
5424  *
5425  * Returns: the #GstVideoFormat describing the FOURCC value
5426  */
5427 GstVideoFormat
5428 gst_video_format_from_fourcc (guint32 fourcc)
5429 {
5430   switch (fourcc) {
5431     case GST_MAKE_FOURCC (&#39;I&#39;, &#39;4&#39;, &#39;2&#39;, &#39;0&#39;):
5432       return GST_VIDEO_FORMAT_I420;
5433     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;V&#39;, &#39;1&#39;, &#39;2&#39;):
5434       return GST_VIDEO_FORMAT_YV12;
5435     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;U&#39;, &#39;Y&#39;, &#39;2&#39;):
5436       return GST_VIDEO_FORMAT_YUY2;
5437     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;V&#39;, &#39;Y&#39;, &#39;U&#39;):
5438       return GST_VIDEO_FORMAT_YVYU;
5439     case GST_MAKE_FOURCC (&#39;U&#39;, &#39;Y&#39;, &#39;V&#39;, &#39;Y&#39;):
5440       return GST_VIDEO_FORMAT_UYVY;
5441     case GST_MAKE_FOURCC (&#39;V&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;Y&#39;):
5442       return GST_VIDEO_FORMAT_VYUY;
5443     case GST_MAKE_FOURCC (&#39;A&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;V&#39;):
5444       return GST_VIDEO_FORMAT_AYUV;
5445     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;1&#39;, &#39;B&#39;):
5446       return GST_VIDEO_FORMAT_Y41B;
5447     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;2&#39;, &#39;B&#39;):
5448       return GST_VIDEO_FORMAT_Y42B;
5449     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;):
5450       return GST_VIDEO_FORMAT_Y444;
5451     case GST_MAKE_FOURCC (&#39;v&#39;, &#39;2&#39;, &#39;1&#39;, &#39;0&#39;):
5452       return GST_VIDEO_FORMAT_v210;
5453     case GST_MAKE_FOURCC (&#39;v&#39;, &#39;2&#39;, &#39;1&#39;, &#39;6&#39;):
5454       return GST_VIDEO_FORMAT_v216;
<a name="42" id="anc42"></a>

5455     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;1&#39;, &#39;2&#39;):
5456       return GST_VIDEO_FORMAT_NV12;
5457     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;2&#39;, &#39;1&#39;):
5458       return GST_VIDEO_FORMAT_NV21;
5459     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;1&#39;, &#39;6&#39;):
5460       return GST_VIDEO_FORMAT_NV16;
5461     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;6&#39;, &#39;1&#39;):
5462       return GST_VIDEO_FORMAT_NV61;
5463     case GST_MAKE_FOURCC (&#39;N&#39;, &#39;V&#39;, &#39;2&#39;, &#39;4&#39;):
5464       return GST_VIDEO_FORMAT_NV24;
5465     case GST_MAKE_FOURCC (&#39;v&#39;, &#39;3&#39;, &#39;0&#39;, &#39;8&#39;):
5466       return GST_VIDEO_FORMAT_v308;
5467     case GST_MAKE_FOURCC (&#39;I&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;2&#39;):
5468       return GST_VIDEO_FORMAT_IYU2;
5469     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;8&#39;, &#39;0&#39;, &#39;0&#39;):
5470     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;8&#39;, &#39; &#39;, &#39; &#39;):
5471     case GST_MAKE_FOURCC (&#39;G&#39;, &#39;R&#39;, &#39;E&#39;, &#39;Y&#39;):
5472       return GST_VIDEO_FORMAT_GRAY8;
5473     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;1&#39;, &#39;6&#39;, &#39; &#39;):
5474       return GST_VIDEO_FORMAT_GRAY16_LE;
5475     case GST_MAKE_FOURCC (&#39;U&#39;, &#39;Y&#39;, &#39;V&#39;, &#39;P&#39;):
5476       return GST_VIDEO_FORMAT_UYVP;
5477     case GST_MAKE_FOURCC (&#39;A&#39;, &#39;4&#39;, &#39;2&#39;, &#39;0&#39;):
5478       return GST_VIDEO_FORMAT_A420;
5479     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;U&#39;, &#39;V&#39;, &#39;9&#39;):
5480       return GST_VIDEO_FORMAT_YUV9;
5481     case GST_MAKE_FOURCC (&#39;Y&#39;, &#39;V&#39;, &#39;U&#39;, &#39;9&#39;):
5482       return GST_VIDEO_FORMAT_YVU9;
5483     case GST_MAKE_FOURCC (&#39;I&#39;, &#39;Y&#39;, &#39;U&#39;, &#39;1&#39;):
5484       return GST_VIDEO_FORMAT_IYU1;
5485     case GST_MAKE_FOURCC (&#39;A&#39;, &#39;Y&#39;, &#39;6&#39;, &#39;4&#39;):
5486       return GST_VIDEO_FORMAT_AYUV64;
5487     case GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;1&#39;, &#39;0&#39;):
5488       return GST_VIDEO_FORMAT_GRAY10_LE32;
5489     case GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;1&#39;, &#39;5&#39;):
5490       return GST_VIDEO_FORMAT_NV12_10LE32;
5491     case GST_MAKE_FOURCC (&#39;X&#39;, &#39;V&#39;, &#39;2&#39;, &#39;0&#39;):
5492       return GST_VIDEO_FORMAT_NV16_10LE32;
<a name="43" id="anc43"></a>








5493     default:
5494       return GST_VIDEO_FORMAT_UNKNOWN;
5495   }
5496 }
5497 
5498 /**
5499  * gst_video_format_from_string:
5500  * @format: a format string
5501  *
5502  * Convert the @format string to its #GstVideoFormat.
5503  *
5504  * Returns: the #GstVideoFormat for @format or GST_VIDEO_FORMAT_UNKNOWN when the
5505  * string is not a known format.
5506  */
5507 GstVideoFormat
5508 gst_video_format_from_string (const gchar * format)
5509 {
5510   guint i;
5511 
5512   g_return_val_if_fail (format != NULL, GST_VIDEO_FORMAT_UNKNOWN);
5513 
5514   for (i = 0; i &lt; G_N_ELEMENTS (formats); i++) {
5515     if (strcmp (GST_VIDEO_FORMAT_INFO_NAME (&amp;formats[i].info), format) == 0)
5516       return GST_VIDEO_FORMAT_INFO_FORMAT (&amp;formats[i].info);
5517   }
5518   return GST_VIDEO_FORMAT_UNKNOWN;
5519 }
5520 
5521 
5522 /**
5523  * gst_video_format_to_fourcc:
5524  * @format: a #GstVideoFormat video format
5525  *
5526  * Converts a #GstVideoFormat value into the corresponding FOURCC.  Only
5527  * a few YUV formats have corresponding FOURCC values.  If @format has
5528  * no corresponding FOURCC value, 0 is returned.
5529  *
5530  * Returns: the FOURCC corresponding to @format
5531  */
5532 guint32
5533 gst_video_format_to_fourcc (GstVideoFormat format)
5534 {
5535   g_return_val_if_fail (format != GST_VIDEO_FORMAT_UNKNOWN, 0);
5536 
5537   if ((gint) format &gt;= G_N_ELEMENTS (formats))
5538     return 0;
5539 
5540   return formats[format].fourcc;
5541 }
5542 
5543 /**
5544  * gst_video_format_to_string:
5545  * @format: a #GstVideoFormat video format
5546  *
5547  * Returns a string containing a descriptive name for
5548  * the #GstVideoFormat if there is one, or NULL otherwise.
5549  *
5550  * Returns: the name corresponding to @format
5551  */
5552 const gchar *
5553 gst_video_format_to_string (GstVideoFormat format)
5554 {
5555   g_return_val_if_fail (format != GST_VIDEO_FORMAT_UNKNOWN, NULL);
5556 
5557   if ((gint) format &gt;= G_N_ELEMENTS (formats))
5558     return NULL;
5559 
5560   return GST_VIDEO_FORMAT_INFO_NAME (&amp;formats[format].info);
5561 }
5562 
5563 /**
5564  * gst_video_format_get_info:
5565  * @format: a #GstVideoFormat
5566  *
5567  * Get the #GstVideoFormatInfo for @format
5568  *
5569  * Returns: The #GstVideoFormatInfo for @format.
5570  */
5571 const GstVideoFormatInfo *
5572 gst_video_format_get_info (GstVideoFormat format)
5573 {
5574   g_return_val_if_fail ((gint) format &lt; G_N_ELEMENTS (formats), NULL);
5575 
5576   return &amp;formats[format].info;
5577 }
5578 
5579 /**
5580  * gst_video_format_get_palette:
5581  * @format: a #GstVideoFormat
5582  * @size: (out): size of the palette in bytes
5583  *
5584  * Get the default palette of @format. This the palette used in the pack
5585  * function for paletted formats.
5586  *
5587  * Returns: (transfer none): the default palette of @format or %NULL when
5588  * @format does not have a palette.
5589  *
5590  * Since: 1.2
5591  */
5592 gconstpointer
5593 gst_video_format_get_palette (GstVideoFormat format, gsize * size)
5594 {
5595   g_return_val_if_fail ((gint) format &lt; G_N_ELEMENTS (formats), NULL);
5596   g_return_val_if_fail (size != NULL, NULL);
5597 
5598   switch (format) {
5599     case GST_VIDEO_FORMAT_RGB8P:
5600       *size = sizeof (std_palette_RGB8P);
5601       return std_palette_RGB8P;
5602     default:
5603       return NULL;
5604   }
5605 }
<a name="44" id="anc44"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="44" type="hidden" />
</body>
</html>