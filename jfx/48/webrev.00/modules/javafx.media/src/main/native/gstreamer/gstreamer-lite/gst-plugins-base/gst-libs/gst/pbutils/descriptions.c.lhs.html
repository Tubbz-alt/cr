<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/pbutils/descriptions.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer Plugins Base utils library source/sink/codec description support
   2  * Copyright (C) 2006 Tim-Philipp MÃ¼ller &lt;tim centricular net&gt;
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Library General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Library General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Library General Public
  15  * License along with this library; if not, write to the
  16  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  17  * Boston, MA 02110-1301, USA.
  18  */
  19 
  20 /**
  21  * SECTION:gstpbutilsdescriptions
  22  * @title: Descriptions
  23  * @short_description: Provides human-readable descriptions for caps/codecs
  24  * and encoder, decoder, URI source and URI sink elements
  25  *
  26  * The above functions provide human-readable strings for media formats
  27  * and decoder/demuxer/depayloader/encoder/muxer/payloader elements for use
  28  * in error dialogs or other messages shown to users.
  29  *
  30  * gst_pb_utils_add_codec_description_to_tag_list() is a utility function
  31  * for demuxer and decoder elements to add audio/video codec tags from a
  32  * given (fixed) #GstCaps.
  33  *
  34  */
  35 
  36 #ifdef HAVE_CONFIG_H
  37 # include &quot;config.h&quot;
  38 #endif
  39 
  40 #include &quot;gst/gst-i18n-plugin.h&quot;
  41 
  42 #include &lt;gst/audio/audio.h&gt;
  43 #include &lt;gst/video/video.h&gt;
  44 
  45 #include &quot;pbutils.h&quot;
  46 #include &quot;pbutils-private.h&quot;
  47 
  48 #include &lt;string.h&gt;
  49 
  50 typedef enum
  51 {
  52   FLAG_SYSTEMSTREAM = (1 &lt;&lt; 0), /* match record only if caps have systemstream=true   */
  53   FLAG_CONTAINER = (1 &lt;&lt; 1),    /* format is a container format (muxed)               */
  54   FLAG_AUDIO = (1 &lt;&lt; 2),        /* format is an audio format, or audio container/tag  */
  55   FLAG_VIDEO = (1 &lt;&lt; 3),        /* format is a video format, or video container/tag   */
  56   FLAG_IMAGE = (1 &lt;&lt; 4),        /* format is an image format, or image container/tag  */
  57   FLAG_SUB = (1 &lt;&lt; 5),          /* format is a subtitle format, or subtitle container */
  58   FLAG_TAG = (1 &lt;&lt; 6),          /* format is a tag/container                          */
  59   FLAG_GENERIC = (1 &lt;&lt; 7)       /* format is a generic container (e.g. multipart)     */
  60 } FormatFlags;
  61 
  62 typedef struct
  63 {
  64   const gchar *type;
  65   const gchar *desc;
  66   FormatFlags flags:24;
  67   gchar ext[5];                 /* file extension */
  68 } FormatInfo;
  69 
  70 #define AV_CONTAINER    (FLAG_CONTAINER | FLAG_AUDIO | FLAG_VIDEO)
  71 #define AVS_CONTAINER   (AV_CONTAINER | FLAG_SUB)
  72 #define AVI_CONTAINER   (AV_CONTAINER | FLAG_IMAGE)
  73 #define AVIS_CONTAINER  (AV_CONTAINER | FLAG_IMAGE | FLAG_SUB)
  74 #define AUDIO_CONTAINER (FLAG_CONTAINER | FLAG_AUDIO)
  75 #define VIDEO_CONTAINER (FLAG_CONTAINER | FLAG_VIDEO)
  76 #define AUDIO_TAG       (AUDIO_CONTAINER | FLAG_TAG)
  77 
  78 #ifndef GSTREAMER_LITE
  79 static const FormatInfo formats[] = {
  80   /* container/tag formats with static descriptions */
  81   /* FIXME: does anyone use oga in practice? */
  82   {&quot;audio/ogg&quot;, &quot;Ogg&quot;, AUDIO_CONTAINER, &quot;ogg&quot;},
  83   {&quot;audio/webm&quot;, &quot;WebM&quot;, AUDIO_CONTAINER, &quot;webm&quot;},
  84   {&quot;audio/x-matroska&quot;, &quot;Matroska&quot;, AUDIO_CONTAINER, &quot;mka&quot;},
  85   {&quot;application/gxf&quot;, &quot;General Exchange Format (GXF)&quot;, AVI_CONTAINER, &quot;gxf&quot;},
  86   {&quot;application/ogg&quot;, &quot;Ogg&quot;, AVIS_CONTAINER, &quot;ogg&quot;},
  87   {&quot;application/kate&quot;, &quot;Ogg&quot;, FLAG_CONTAINER | FLAG_SUB, &quot;ogg&quot;},
  88   {&quot;application/mxf&quot;, &quot;Material eXchange Format (MXF)&quot;, AVIS_CONTAINER, &quot;mxf&quot;},
  89   {&quot;application/vnd.rn-realmedia&quot;, &quot;Realmedia&quot;, AV_CONTAINER, &quot;rm&quot;},
  90   {&quot;application/x-id3&quot;, N_(&quot;ID3 tag&quot;), AUDIO_TAG, &quot;&quot;},
  91   {&quot;application/x-ape&quot;, N_(&quot;APE tag&quot;), AUDIO_TAG, &quot;&quot;},
  92   {&quot;application/x-apetag&quot;, N_(&quot;APE tag&quot;), AUDIO_TAG, &quot;&quot;},
  93   {&quot;application/x-icy&quot;, N_(&quot;ICY internet radio&quot;), AUDIO_TAG, &quot;&quot;},
  94   {&quot;application/x-3gp&quot;, &quot;3GP&quot;, AV_CONTAINER, &quot;3gp&quot;},
  95   {&quot;application/x-pn-realaudio&quot;, &quot;RealAudio&quot;, AUDIO_CONTAINER, &quot;ra&quot;},
  96   {&quot;application/x-yuv4mpeg&quot;, &quot;Y4M&quot;, VIDEO_CONTAINER, &quot;y4m&quot;},
  97   {&quot;multipart/x-mixed-replace&quot;, &quot;Multipart&quot;, FLAG_CONTAINER | FLAG_GENERIC, &quot;&quot;},
  98   {&quot;video/ogg&quot;, &quot;Ogg&quot;, AVIS_CONTAINER, &quot;ogv&quot;},
  99   {&quot;video/x-fli&quot;, &quot;FLI/FLC/FLX Animation&quot;, VIDEO_CONTAINER, &quot;fli&quot;},
 100   {&quot;video/x-flv&quot;, &quot;Flash&quot;, AV_CONTAINER, &quot;flv&quot;},
 101   {&quot;video/x-matroska&quot;, &quot;Matroska&quot;, AVIS_CONTAINER, &quot;mkv&quot;},
 102   /* FIXME: does anyone use .mk3d in practice, rather than .mkv? */
 103   {&quot;video/x-matroska-3d&quot;, &quot;Matroska&quot;, AVIS_CONTAINER, &quot;mk3d&quot;},
 104   {&quot;video/webm&quot;, &quot;WebM&quot;, AVS_CONTAINER, &quot;webm&quot;},
 105   {&quot;video/x-ms-asf&quot;, &quot;Advanced Streaming Format (ASF)&quot;, AVIS_CONTAINER, &quot;asf&quot;},
 106   {&quot;video/x-msvideo&quot;, &quot;Audio Video Interleave (AVI)&quot;, AVIS_CONTAINER, &quot;avi&quot;},
 107   {&quot;video/x-quicktime&quot;, &quot;Quicktime&quot;, AVIS_CONTAINER, &quot;mov&quot;},
 108   {&quot;video/quicktime&quot;, &quot;Quicktime&quot;, AVIS_CONTAINER, &quot;mov&quot;},
 109   {&quot;video/mj2&quot;, &quot;Motion JPEG 2000&quot;, AVIS_CONTAINER, &quot;mj2&quot;},
 110 
 111   /* audio formats with static descriptions */
 112   {&quot;audio/x-ac3&quot;, &quot;AC-3 (ATSC A/52)&quot;, FLAG_AUDIO, &quot;ac3&quot;},
 113   {&quot;audio/ac3&quot;, &quot;AC-3 (ATSC A/52)&quot;, FLAG_AUDIO, &quot;ac3&quot;},
 114   {&quot;audio/x-private-ac3&quot;, &quot;DVD AC-3 (ATSC A/52)&quot;, FLAG_AUDIO, &quot;ac3&quot;},
 115   {&quot;audio/x-private1-ac3&quot;, &quot;DVD AC-3 (ATSC A/52)&quot;, FLAG_AUDIO, &quot;ac3&quot;},
 116   {&quot;audio/x-alaw&quot;, &quot;A-Law&quot;, FLAG_AUDIO, &quot;&quot;},
 117   {&quot;audio/amr&quot;, &quot;Adaptive Multi Rate (AMR)&quot;, FLAG_AUDIO, &quot;amr&quot;},
 118   {&quot;audio/AMR&quot;, &quot;Adaptive Multi Rate (AMR)&quot;, FLAG_AUDIO, &quot;amr&quot;},
 119   {&quot;audio/AMR-WB&quot;, &quot;Adaptive Multi Rate WideBand (AMR-WB)&quot;, FLAG_AUDIO, &quot;amr&quot;},
 120   {&quot;audio/iLBC-sh&quot;, &quot;Internet Low Bitrate Codec (iLBC)&quot;, AUDIO_CONTAINER,
 121       &quot;ilbc&quot;},
 122   {&quot;audio/ms-gsm&quot;, &quot;MS GSM&quot;, FLAG_AUDIO, &quot;gsm&quot;},
 123   {&quot;audio/qcelp&quot;, &quot;QCELP&quot;, FLAG_AUDIO, &quot;&quot;},
 124   {&quot;audio/aiff&quot;, &quot;Audio Interchange File Format (AIFF)&quot;, AUDIO_CONTAINER,
 125       &quot;aiff&quot;},
 126   {&quot;audio/x-aiff&quot;, &quot;Audio Interchange File Format (AIFF)&quot;, AUDIO_CONTAINER,
 127       &quot;aiff&quot;},
 128   {&quot;audio/x-alac&quot;, N_(&quot;Apple Lossless Audio (ALAC)&quot;), FLAG_AUDIO, &quot;&quot;},
 129   {&quot;audio/x-amr-nb-sh&quot;, &quot;Adaptive Multi Rate NarrowBand (AMR-NB)&quot;,
 130       AUDIO_CONTAINER, &quot;amr&quot;},
 131   {&quot;audio/x-amr-wb-sh&quot;, &quot;Adaptive Multi Rate WideBand (AMR-WB)&quot;,
 132       AUDIO_CONTAINER, &quot;amr&quot;},
 133   {&quot;audio/x-au&quot;, &quot;Sun .au&quot;, AUDIO_CONTAINER, &quot;au&quot;},
 134   {&quot;audio/x-audible&quot;, &quot;Audible Audio&quot;, AUDIO_CONTAINER, &quot;aa&quot;},
 135   {&quot;audio/x-caf&quot;, &quot;Apple Core Audio Format&quot;, AUDIO_CONTAINER, &quot;caf&quot;},
 136   {&quot;audio/x-celt&quot;, &quot;Constrained Energy Lapped Transform (CELT)&quot;, FLAG_AUDIO,
 137       &quot;&quot;},
 138   {&quot;audio/x-cinepak&quot;, &quot;Cinepak Audio&quot;, FLAG_AUDIO, &quot;&quot;},
 139   {&quot;audio/x-dpcm&quot;, &quot;DPCM&quot;, FLAG_AUDIO, &quot;&quot;},
 140   {&quot;audio/x-dts&quot;, &quot;DTS&quot;, FLAG_AUDIO, &quot;dts&quot;},
 141   {&quot;audio/x-private1-dts&quot;, &quot;DTS&quot;, FLAG_AUDIO, &quot;dts&quot;},
 142   {&quot;audio/x-dv&quot;, &quot;DV Audio&quot;, FLAG_AUDIO, &quot;&quot;},
 143   {&quot;audio/x-eac3&quot;, &quot;E-AC-3 (ATSC A/52B)&quot;, FLAG_AUDIO, &quot;eac3&quot;},
 144   {&quot;audio/x-flac&quot;, N_(&quot;Free Lossless Audio Codec (FLAC)&quot;), FLAG_AUDIO, &quot;flac&quot;},
 145   {&quot;audio/x-gsm&quot;, &quot;GSM&quot;, FLAG_AUDIO, &quot;gsm&quot;},
 146   {&quot;audio/x-iec958&quot;, &quot;S/PDIF IEC958&quot;, 0, &quot;&quot;},   /* TODO: check description */
 147   {&quot;audio/x-iLBC&quot;, &quot;Internet Low Bitrate Codec (iLBC)&quot;, FLAG_AUDIO, &quot;ilbc&quot;},
 148   {&quot;audio/x-ircam&quot;, &quot;Berkeley/IRCAM/CARL&quot;, FLAG_AUDIO, &quot;&quot;},
 149   {&quot;audio/x-lpcm&quot;, &quot;LPCM&quot;, FLAG_AUDIO, &quot;&quot;},
 150   {&quot;audio/x-private1-lpcm&quot;, &quot;DVD LPCM&quot;, FLAG_AUDIO, &quot;&quot;},
 151   {&quot;audio/x-m4a&quot;, &quot;MPEG-4 AAC&quot;, FLAG_CONTAINER, &quot;m4a&quot;},
 152   {&quot;audio/x-mod&quot;, &quot;Module Music Format (MOD)&quot;, FLAG_AUDIO, &quot;mod&quot;},
 153   {&quot;audio/x-mulaw&quot;, &quot;Mu-Law&quot;, FLAG_AUDIO, &quot;&quot;},
 154   {&quot;audio/x-musepack&quot;, &quot;Musepack (MPC)&quot;, FLAG_AUDIO, &quot;mpc&quot;},
 155   {&quot;audio/x-nellymoser&quot;, &quot;Nellymoser Asao&quot;, FLAG_AUDIO, &quot;&quot;},
 156   {&quot;audio/x-nist&quot;, &quot;Sphere NIST&quot;, FLAG_AUDIO, &quot;&quot;},
 157   {&quot;audio/x-nsf&quot;, &quot;Nintendo NSF&quot;, FLAG_AUDIO, &quot;&quot;},
 158   {&quot;audio/x-opus&quot;, &quot;Opus&quot;, FLAG_AUDIO, &quot;&quot;},
 159   {&quot;audio/x-paris&quot;, &quot;Ensoniq PARIS&quot;, FLAG_AUDIO, &quot;&quot;},
 160   {&quot;audio/x-qdm&quot;, &quot;QDesign Music (QDM)&quot;, FLAG_AUDIO, &quot;&quot;},
 161   {&quot;audio/x-qdm2&quot;, &quot;QDesign Music (QDM) 2&quot;, FLAG_AUDIO, &quot;&quot;},
 162   {&quot;audio/x-ralf-mpeg4-generic&quot;, &quot;Real Audio Lossless (RALF)&quot;, FLAG_AUDIO, &quot;&quot;},
 163   {&quot;audio/x-rf64&quot;, &quot;Broadcast Wave Format&quot;, AUDIO_CONTAINER, &quot;rf64&quot;},
 164   {&quot;audio/x-sbc&quot;, &quot;Low Complexity Subband Coding&quot;, FLAG_AUDIO, &quot;sbc&quot;},
 165   {&quot;audio/x-sds&quot;, &quot;Midi Sample Dump Standard&quot;, FLAG_AUDIO, &quot;&quot;},
 166   {&quot;audio/x-shorten&quot;, &quot;Shorten Lossless&quot;, FLAG_AUDIO, &quot;shn&quot;},
 167   {&quot;audio/x-sid&quot;, &quot;Sid&quot;, FLAG_AUDIO, &quot;sid&quot;},
 168   {&quot;audio/x-sipro&quot;, &quot;Sipro/ACELP.NET Voice&quot;, FLAG_AUDIO, &quot;&quot;},
 169   {&quot;audio/x-siren&quot;, &quot;Siren&quot;, FLAG_AUDIO, &quot;&quot;},
 170   {&quot;audio/x-spc&quot;, &quot;SNES-SPC700 Sound File Data&quot;, FLAG_AUDIO, &quot;spc&quot;},
 171   {&quot;audio/x-speex&quot;, &quot;Speex&quot;, FLAG_AUDIO, &quot;&quot;},
 172   {&quot;audio/x-svx&quot;, &quot;Amiga IFF / SVX8 / SV16&quot;, FLAG_AUDIO, &quot;&quot;},
 173   {&quot;audio/x-true-hd&quot;, &quot;Dolby TrueHD&quot;, FLAG_AUDIO, &quot;&quot;},
 174   {&quot;audio/x-tta&quot;, N_(&quot;Lossless True Audio (TTA)&quot;), FLAG_AUDIO, &quot;tta&quot;},
 175   {&quot;audio/x-ttafile&quot;, N_(&quot;Lossless True Audio (TTA)&quot;), FLAG_AUDIO, &quot;tta&quot;},
 176   {&quot;audio/x-vnd.sony.atrac3&quot;, &quot;Sony ATRAC3&quot;, FLAG_AUDIO, &quot;&quot;},
 177   {&quot;audio/x-vorbis&quot;, &quot;Vorbis&quot;, FLAG_AUDIO, &quot;&quot;},
 178   {&quot;audio/x-voc&quot;, &quot;SoundBlaster VOC&quot;, FLAG_AUDIO, &quot;&quot;},
 179   {&quot;audio/x-w64&quot;, &quot;Sonic Foundry Wave64&quot;, AUDIO_CONTAINER, &quot;w64&quot;},
 180   {&quot;audio/x-wav&quot;, &quot;WAV&quot;, AUDIO_CONTAINER, &quot;wav&quot;},
 181   {&quot;audio/x-wavpack&quot;, &quot;Wavpack&quot;, FLAG_AUDIO, &quot;wp&quot;},
 182   {&quot;audio/x-wavpack-correction&quot;, &quot;Wavpack&quot;, 0, &quot;wpc&quot;},
 183   {&quot;audio/x-wms&quot;, N_(&quot;Windows Media Speech&quot;), FLAG_AUDIO, &quot;&quot;},
 184   {&quot;audio/x-voxware&quot;, &quot;Voxware&quot;, FLAG_AUDIO, &quot;&quot;},
 185   {&quot;audio/x-xi&quot;, &quot;Fasttracker 2 Extended Instrument&quot;, FLAG_AUDIO, &quot;xi&quot;},
 186 
 187 
 188   /* video formats with static descriptions */
 189   {&quot;video/sp5x&quot;, &quot;Sunplus JPEG 5.x&quot;, FLAG_VIDEO, &quot;&quot;},
 190   {&quot;video/vivo&quot;, &quot;Vivo&quot;, FLAG_VIDEO, &quot;&quot;},
 191   {&quot;video/x-4xm&quot;, &quot;4X Technologies Video&quot;, FLAG_VIDEO, &quot;&quot;},
 192   {&quot;video/x-apple-video&quot;, &quot;Apple video&quot;, FLAG_VIDEO, &quot;&quot;},
 193   {&quot;video/x-aasc&quot;, &quot;Autodesk Animator&quot;, FLAG_VIDEO, &quot;&quot;},
<a name="1" id="anc1"></a>
 194   {&quot;video/x-camtasia&quot;, &quot;TechSmith Camtasia&quot;, FLAG_VIDEO, &quot;&quot;},
 195   {&quot;video/x-cavs&quot;, &quot;Chinese AVS (CAVS)&quot;, FLAG_VIDEO, &quot;&quot;},
 196   {&quot;video/x-cdxa&quot;, &quot;RIFF/CDXA (VCD)&quot;, AV_CONTAINER, &quot;&quot;},
 197   {&quot;video/x-cinepak&quot;, &quot;Cinepak Video&quot;, FLAG_VIDEO, &quot;&quot;},
 198   {&quot;video/x-cirrus-logic-accupak&quot;, &quot;Cirrus Logipak AccuPak&quot;, FLAG_VIDEO, &quot;&quot;},
 199   {&quot;video/x-compressed-yuv&quot;, N_(&quot;CYUV Lossless&quot;), FLAG_VIDEO, &quot;&quot;},
 200   {&quot;video/x-dnxhd&quot;, &quot;Digital Nonlinear Extensible High Definition (DNxHD)&quot;,
 201       FLAG_VIDEO, &quot;&quot;},
 202   {&quot;subpicture/x-dvd&quot;, &quot;DVD subpicture&quot;, FLAG_VIDEO, &quot;&quot;},
 203   {&quot;video/x-ffv&quot;, N_(&quot;FFMpeg v1&quot;), FLAG_VIDEO, &quot;&quot;},
 204   {&quot;video/x-flash-screen&quot;, &quot;Flash Screen Video&quot;, FLAG_VIDEO, &quot;&quot;},
 205   {&quot;video/x-flash-video&quot;, &quot;Sorenson Spark Video&quot;, FLAG_VIDEO, &quot;&quot;},
 206   {&quot;video/x-h261&quot;, &quot;H.261&quot;, FLAG_VIDEO, &quot;&quot;},
 207   {&quot;video/x-huffyuv&quot;, &quot;Huffyuv&quot;, FLAG_VIDEO, &quot;&quot;},
 208   {&quot;video/x-intel-h263&quot;, &quot;Intel H.263&quot;, FLAG_VIDEO, &quot;&quot;},
 209   {&quot;video/x-jpeg&quot;, &quot;Motion JPEG&quot;, FLAG_VIDEO, &quot;&quot;},
 210   /* { &quot;video/x-jpeg-b&quot;, &quot;&quot;, 0 }, does this actually exist? */
 211   {&quot;video/x-loco&quot;, &quot;LOCO Lossless&quot;, FLAG_VIDEO, &quot;&quot;},
 212   {&quot;video/x-mimic&quot;, &quot;MIMIC&quot;, FLAG_VIDEO, &quot;&quot;},
 213   {&quot;video/x-mjpeg&quot;, &quot;Motion-JPEG&quot;, FLAG_VIDEO, &quot;&quot;},
 214   {&quot;video/x-mjpeg-b&quot;, &quot;Motion-JPEG format B&quot;, FLAG_VIDEO, &quot;&quot;},
 215   {&quot;video/mpegts&quot;, &quot;MPEG-2 Transport Stream&quot;, AVS_CONTAINER, &quot;ts&quot;},
 216   {&quot;video/x-mng&quot;, &quot;Multiple Image Network Graphics (MNG)&quot;, FLAG_VIDEO, &quot;&quot;},
 217   {&quot;video/x-mszh&quot;, N_(&quot;Lossless MSZH&quot;), FLAG_VIDEO, &quot;&quot;},
 218   {&quot;video/x-msvideocodec&quot;, &quot;Microsoft Video 1&quot;, FLAG_VIDEO, &quot;&quot;},
 219   {&quot;video/x-mve&quot;, &quot;Interplay MVE&quot;, AV_CONTAINER, &quot;mve&quot;},
 220   {&quot;video/x-nut&quot;, &quot;NUT&quot;, AV_CONTAINER, &quot;nut&quot;},
 221   {&quot;video/x-nuv&quot;, &quot;MythTV NuppelVideo (NUV)&quot;, AV_CONTAINER, &quot;nuv&quot;},
 222   {&quot;video/x-prores&quot;, &quot;Apple ProRes&quot;, FLAG_VIDEO, &quot;&quot;},
 223   {&quot;video/x-qdrw&quot;, &quot;Apple QuickDraw&quot;, FLAG_VIDEO, &quot;&quot;},
 224   {&quot;video/x-smc&quot;, &quot;Apple SMC&quot;, FLAG_VIDEO, &quot;&quot;},
 225   {&quot;video/x-smoke&quot;, &quot;Smoke&quot;, FLAG_VIDEO, &quot;&quot;},
 226   {&quot;video/x-tarkin&quot;, &quot;Tarkin&quot;, FLAG_VIDEO, &quot;&quot;},
 227   {&quot;video/x-theora&quot;, &quot;Theora&quot;, FLAG_VIDEO, &quot;&quot;},
 228   {&quot;video/x-rle&quot;, N_(&quot;Run-length encoding&quot;), FLAG_VIDEO, &quot;&quot;},
 229   {&quot;video/x-ultimotion&quot;, &quot;IBM UltiMotion&quot;, FLAG_VIDEO, &quot;&quot;},
 230   {&quot;video/x-vcd&quot;, &quot;VideoCD (VCD)&quot;, 0},
 231   {&quot;video/x-vmnc&quot;, &quot;VMWare NC&quot;, FLAG_VIDEO, &quot;&quot;},
 232   {&quot;video/x-vp3&quot;, &quot;On2 VP3&quot;, FLAG_VIDEO, &quot;&quot;},
 233   {&quot;video/x-vp5&quot;, &quot;On2 VP5&quot;, FLAG_VIDEO, &quot;&quot;},
 234   {&quot;video/x-vp6&quot;, &quot;On2 VP6&quot;, FLAG_VIDEO, &quot;&quot;},
 235   {&quot;video/x-vp6-flash&quot;, &quot;On2 VP6/Flash&quot;, FLAG_VIDEO, &quot;&quot;},
 236   {&quot;video/x-vp6-alpha&quot;, &quot;On2 VP6 with alpha&quot;, FLAG_VIDEO, &quot;&quot;},
 237   {&quot;video/x-vp7&quot;, &quot;On2 VP7&quot;, FLAG_VIDEO, &quot;&quot;},
 238   {&quot;video/x-vp8&quot;, &quot;VP8&quot;, FLAG_VIDEO, &quot;&quot;},
 239   {&quot;video/x-vp9&quot;, &quot;VP9&quot;, FLAG_VIDEO, &quot;&quot;},
 240   {&quot;video/x-zlib&quot;, &quot;Lossless zlib video&quot;, FLAG_VIDEO, &quot;&quot;},
 241   {&quot;video/x-zmbv&quot;, &quot;Zip Motion Block video&quot;, FLAG_VIDEO, &quot;&quot;},
 242 
 243   /* image formats with static descriptions */
 244   {&quot;image/bmp&quot;, &quot;BMP&quot;, FLAG_IMAGE, &quot;bmp&quot;},
 245   {&quot;image/x-bmp&quot;, &quot;BMP&quot;, FLAG_IMAGE, &quot;bmp&quot;},
 246   {&quot;image/x-MS-bmp&quot;, &quot;BMP&quot;, FLAG_IMAGE, &quot;bmp&quot;},
 247   {&quot;image/gif&quot;, &quot;GIF&quot;, FLAG_IMAGE, &quot;gif&quot;},
 248   {&quot;image/jpeg&quot;, &quot;JPEG&quot;, FLAG_IMAGE | FLAG_VIDEO, &quot;jpg&quot;},
 249   {&quot;image/jng&quot;, &quot;JPEG Network Graphics (JNG)&quot;, FLAG_IMAGE, &quot;&quot;},
 250   {&quot;image/png&quot;, &quot;PNG&quot;, FLAG_VIDEO | FLAG_IMAGE, &quot;png&quot;},
 251   {&quot;image/pbm&quot;, &quot;Portable BitMap (PBM)&quot;, FLAG_IMAGE, &quot;pbm&quot;},
 252   {&quot;image/ppm&quot;, &quot;Portable PixMap (PPM)&quot;, FLAG_IMAGE, &quot;ppm&quot;},
 253   {&quot;image/svg+xml&quot;, &quot;Scalable Vector Graphics (SVG)&quot;, FLAG_IMAGE, &quot;svg&quot;},
 254   {&quot;image/tiff&quot;, &quot;TIFF&quot;, FLAG_IMAGE, &quot;tiff&quot;},
 255   {&quot;image/x-cmu-raster&quot;, &quot;CMU Raster Format&quot;, FLAG_IMAGE, &quot;&quot;},
 256   {&quot;image/x-degas&quot;, &quot;DEGAS&quot;, FLAG_IMAGE, &quot;&quot;},
 257   {&quot;image/x-icon&quot;, &quot;ICO&quot;, FLAG_IMAGE, &quot;ico&quot;},
 258   {&quot;image/x-j2c&quot;, &quot;JPEG 2000&quot;, FLAG_VIDEO | FLAG_IMAGE, &quot;&quot;},
 259   {&quot;image/x-jpc&quot;, &quot;JPEG 2000&quot;, FLAG_VIDEO | FLAG_IMAGE, &quot;&quot;},
 260   {&quot;image/jp2&quot;, &quot;JPEG 2000&quot;, FLAG_VIDEO | FLAG_IMAGE, &quot;&quot;},
 261   {&quot;image/x-pcx&quot;, &quot;PCX&quot;, FLAG_IMAGE, &quot;&quot;},
 262   {&quot;image/x-xcf&quot;, &quot;XFC&quot;, FLAG_IMAGE, &quot;&quot;},
 263   {&quot;image/x-pixmap&quot;, &quot;XPM&quot;, FLAG_IMAGE, &quot;xpm&quot;},
 264   {&quot;image/x-portable-anymap&quot;, &quot;Portable AnyMap (PNM)&quot;, FLAG_IMAGE, &quot;pnm&quot;},
 265   {&quot;image/x-portable-graymap&quot;, &quot;Portable GrayMap (PGM)&quot;, FLAG_IMAGE, &quot;pgm&quot;},
 266   {&quot;image/x-xpixmap&quot;, &quot;XPM&quot;, FLAG_IMAGE, &quot;xpm&quot;},
 267   {&quot;image/x-quicktime&quot;, &quot;QuickTime Image Format (QTIF)&quot;,
 268       FLAG_IMAGE | FLAG_CONTAINER, &quot;.mov&quot;},
 269   {&quot;image/x-sun-raster&quot;, &quot;Sun Raster Format (RAS)&quot;, FLAG_IMAGE, &quot;&quot;},
 270   {&quot;image/x-tga&quot;, &quot;TGA&quot;, FLAG_IMAGE, &quot;tga&quot;},
 271   {&quot;image/vnd.wap.wbmp&quot;, &quot;Wireless Bitmap&quot;, FLAG_IMAGE, &quot;wbmp&quot;},
 272 
 273   /* subtitle formats with static descriptions */
 274   {&quot;text/x-raw&quot;, N_(&quot;Timed Text&quot;), FLAG_SUB, &quot;&quot;},
 275   {&quot;application/x-ssa&quot;, &quot;SubStation Alpha&quot;, FLAG_SUB, &quot;&quot;},
 276   {&quot;application/x-ass&quot;, &quot;Advanced SubStation Alpha&quot;, FLAG_SUB, &quot;&quot;},
 277   /* FIXME: add variant field to typefinder? */
 278   {&quot;application/x-subtitle&quot;, N_(&quot;Subtitle&quot;), FLAG_SUB, &quot;&quot;},
 279   {&quot;application/x-subtitle-mpl2&quot;, N_(&quot;MPL2 subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 280   {&quot;application/x-subtitle-dks&quot;, N_(&quot;DKS subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 281   {&quot;application/x-subtitle-qttext&quot;, N_(&quot;QTtext subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 282   {&quot;application/x-subtitle-sami&quot;, N_(&quot;Sami subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 283   {&quot;application/x-subtitle-tmplayer&quot;, N_(&quot;TMPlayer subtitle format&quot;), FLAG_SUB,
 284       &quot;&quot;},
 285   {&quot;application/x-teletext&quot;, &quot;Teletext&quot;, 0, &quot;&quot;},
 286   {&quot;application/x-kate&quot;, &quot;Kate&quot;, 0, &quot;&quot;},
<a name="2" id="anc2"></a>

 287   {&quot;subtitle/x-kate&quot;, N_(&quot;Kate subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 288   {&quot;application/x-subtitle-vtt&quot;, N_(&quot;WebVTT subtitle format&quot;), FLAG_SUB, &quot;&quot;},
 289   {&quot;subpicture/x-dvb&quot;, &quot;DVB subtitles&quot;, FLAG_SUB, &quot;&quot;},
 290   {&quot;subpicture/x-pgs&quot;, &quot;PGS subtitles&quot;, FLAG_SUB, &quot;&quot;},
 291   {&quot;subpicture/x-xsub&quot;, &quot;XSUB subtitles&quot;, FLAG_SUB, &quot;&quot;},
 292 
 293   /* non-audio/video/container formats */
 294   {&quot;hdv/aux-v&quot;, &quot;HDV AUX-V&quot;, 0, &quot;&quot;},
 295   {&quot;hdv/aux-a&quot;, &quot;HDV AUX-A&quot;, 0, &quot;&quot;},
 296 
 297   /* formats with dynamic descriptions */
 298   {&quot;audio/mpeg&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 299   {&quot;audio/x-adpcm&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 300   {&quot;audio/x-mace&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 301   {&quot;audio/x-pn-realaudio&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 302   {&quot;audio/x-raw&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 303   {&quot;audio/x-wma&quot;, NULL, FLAG_AUDIO, &quot;&quot;},
 304   {&quot;video/mpeg&quot;, NULL, AVS_CONTAINER | FLAG_SYSTEMSTREAM, &quot;mpg&quot;},
 305   {&quot;video/mpeg&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 306   {&quot;video/x-asus&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 307   {&quot;video/x-ati-vcr&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 308   {&quot;video/x-dirac&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 309   {&quot;video/x-divx&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 310   {&quot;video/x-dv&quot;, &quot;Digital Video (DV) System Stream&quot;,
 311       FLAG_CONTAINER | FLAG_SYSTEMSTREAM, &quot;dv&quot;},
 312   {&quot;video/x-dv&quot;, &quot;Digital Video (DV)&quot;, FLAG_VIDEO, &quot;&quot;},
 313   {&quot;video/x-h263&quot;, NULL, FLAG_VIDEO, &quot;h263&quot;},
 314   {&quot;video/x-h264&quot;, NULL, FLAG_VIDEO, &quot;h264&quot;},
 315   {&quot;video/x-h265&quot;, NULL, FLAG_VIDEO, &quot;h265&quot;},
 316   {&quot;video/x-indeo&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 317   {&quot;video/x-msmpeg&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 318   {&quot;video/x-pn-realvideo&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 319 #if 0
 320   /* do these exist? are they used anywhere? */
 321   {&quot;video/x-pn-multirate-realvideo&quot;, NULL, 0},
 322   {&quot;audio/x-pn-multirate-realaudio&quot;, NULL, 0},
 323   {&quot;audio/x-pn-multirate-realaudio-live&quot;, NULL, 0},
 324 #endif
 325   {&quot;video/x-truemotion&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 326   {&quot;video/x-raw&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 327   {&quot;video/x-svq&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 328   {&quot;video/x-wmv&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 329   {&quot;video/x-xan&quot;, NULL, FLAG_VIDEO, &quot;&quot;},
 330   {&quot;video/x-tscc&quot;, NULL, FLAG_VIDEO, &quot;&quot;}
 331 };
 332 #else // GSTREAMER_LITE
 333 static const FormatInfo formats[] = {
 334   /* container/tag formats with static descriptions */
 335   {&quot;application/x-id3&quot;, N_(&quot;ID3 tag&quot;), FLAG_CONTAINER},
 336   {&quot;video/x-flv&quot;, &quot;Flash&quot;, FLAG_CONTAINER},
 337 
 338   /* audio formats with static descriptions */
 339   {&quot;audio/aiff&quot;, &quot;Audio Interchange File Format (AIFF)&quot;, 0},
 340   {&quot;audio/x-aiff&quot;, &quot;Audio Interchange File Format (AIFF)&quot;, 0},
 341   {&quot;audio/x-wav&quot;, &quot;WAV&quot;, 0},
 342 
 343   /* video formats with static descriptions */
 344   {&quot;video/x-vp6&quot;, &quot;On2 VP6&quot;, 0},
 345 
 346   /* image formats with static descriptions */
 347 
 348   /* subtitle formats with static descriptions */
 349 
 350   /* non-audio/video/container formats */
 351 
 352   /* formats with dynamic descriptions */
 353   {&quot;audio/mpeg&quot;, NULL, 0},
 354   {&quot;audio/x-raw-int&quot;, NULL, 0},
 355   {&quot;audio/x-raw-float&quot;, NULL, 0}
 356 };
 357 #endif // GSTREAMER_LITE
 358 
 359 static const gchar *
 360 pbutils_desc_get_profile_name_from_nick (const gchar * map, gsize map_len,
 361     const gchar * nick)
 362 {
 363   const gchar *end = map + map_len;
 364   const gchar *p;
 365 
 366   p = map;
 367   while (*p != &#39;\0&#39; &amp;&amp; p &lt; end) {
 368     guint len = strlen (p);
 369 
 370     if (strcmp (p, nick) == 0)
 371       return p + len + 1;
 372     p += len + 1;
 373     p += strlen (p) + 1;
 374   }
 375   return NULL;
 376 }
 377 
 378 static const gchar *
 379 pbutils_desc_get_mpeg2v_profile_name_from_nick (const gchar * nick)
 380 {
 381   static const gchar map[] =
 382       &quot;simple\000Simple\000main\000Main\000high\000High\000&quot;;
 383 
 384   return pbutils_desc_get_profile_name_from_nick (map, sizeof (map), nick);
 385 }
 386 
 387 static const gchar *
 388 pbutils_desc_get_mpeg4v_profile_name_from_nick (const gchar * nick)
 389 {
 390   static const gchar map[] = &quot;simple\000Simple\000&quot;
 391       &quot;simple-scalable\000Simple Scalable\000&quot;
 392       &quot;core\000Core\000&quot;
 393       &quot;main\000Main\000&quot;
 394       &quot;n-bit\000N-bit\000&quot;
 395       &quot;scalable\000Scalable\000&quot;
 396       &quot;hybrid\000Hybrid\000&quot;
 397       &quot;advanced-real-time-simple\000Advanced Real-Time Simple\000&quot;
 398       &quot;core-scalable\000Core-Scalable\000&quot;
 399       &quot;advanced-coding-efficiency\000Advanced Coding Efficiency\000&quot;
 400       &quot;advanced-core\000Advanced Core\000&quot;
 401       &quot;advanced-scalable-texture\000Advanced Scalable Texture\000&quot;
 402       &quot;simple-face\000Simple Face Animation\000&quot;
 403       &quot;simple-fba\000Simple FBA\000&quot;
 404       &quot;simple-studio\000Simple Studio\000&quot;
 405       &quot;core-studio\000Core Studio\000&quot;
 406       &quot;advanced-simple\000Advanced Simple\000&quot;
 407       &quot;fine-granularity-scalable\000Fine Granularity Scalable\000&quot;
 408       &quot;basic-animated-texture\000Basic Animated Texture\000&quot;
 409       &quot;baseline\000Baseline Profile\000&quot;;
 410 
 411   return pbutils_desc_get_profile_name_from_nick (map, sizeof (map), nick);
 412 }
 413 
 414 static const gchar *
 415 pbutils_desc_get_h264_profile_name_from_nick (const gchar * nick)
 416 {
 417   static const gchar map[] = &quot;baseline\000Baseline\000&quot;
 418       &quot;constrained-baseline\000Constrained Baseline\000&quot;
 419       &quot;main\000Main\000&quot;
 420       &quot;extended\000Extended\000&quot;
 421       &quot;high\000High\000&quot;
 422       &quot;high-10-intra\000High 10 Intra\000&quot;
 423       &quot;high-10\000High 10\000&quot;
 424       &quot;high-4:2:2-intra\000High 4:2:2 Intra\000&quot;
 425       &quot;high-4:2:2\000High 4:2:2\000&quot;
 426       &quot;high-4:4:4-intra\000High 4:4:4 Intra\000&quot;
 427       &quot;high-4:4:4\000High 4:4:4\000&quot;
 428       &quot;cavlc-4:4:4-intra\000CAVLC 4:4:4 Intra\000&quot;
 429       &quot;multiview-high\000Multiview High\000&quot;
 430       &quot;stereo-high\000Stereo High\000&quot;
 431       &quot;scalable-constrained-baseline\000Scalable Constrained Baseline\000&quot;
 432       &quot;scalable-baseline\000Scalable Baseline\000&quot;
 433       &quot;scalable-high\000Scalable High\000&quot;;
 434 
 435   return pbutils_desc_get_profile_name_from_nick (map, sizeof (map), nick);
 436 }
 437 
 438 static const gchar *
 439 pbutils_desc_get_h265_profile_name_from_nick (const gchar * nick)
 440 {
 441   static const gchar map[] = &quot;main\000Main\000&quot;
 442       &quot;main-10\000Main 10\000&quot;
 443       &quot;main-12\000Main 12\000&quot;
 444       &quot;main-4:2:2-10\000Main 4:2:2 10\000&quot;
 445       &quot;main-4:2:2-12\000Main 4:2:2 12\000&quot;
 446       &quot;main-4:4:4\000Main 4:4:4\000&quot;
 447       &quot;main-4:4:4-10\000Main 4:4:4 10\000&quot;
 448       &quot;main-4:4:4-12\000Main 4:4:4 12\000&quot;
 449       &quot;main-4:4:4-16-intra\000Main 4:4:4 16 Intra\000&quot;
 450       &quot;main-still-picture\000Main Still Picture\000&quot;;
 451 
 452   return pbutils_desc_get_profile_name_from_nick (map, sizeof (map), nick);
 453 }
 454 
 455 /* returns static descriptions and dynamic ones (such as video/x-raw),
 456  * or NULL if caps aren&#39;t known at all */
 457 static gchar *
 458 format_info_get_desc (const FormatInfo * info, const GstCaps * caps)
 459 {
 460   const GstStructure *s;
 461 
 462   g_assert (info != NULL);
 463 
 464   gst_pb_utils_init_locale_text_domain ();
 465 
 466   if (info-&gt;desc != NULL)
 467     return g_strdup (_(info-&gt;desc));
 468 
 469   s = gst_caps_get_structure (caps, 0);
 470 
 471   if (strcmp (info-&gt;type, &quot;video/x-raw&quot;) == 0) {
 472     gchar *ret = NULL;
 473     const gchar *str = 0;
 474     GstVideoFormat format;
 475     const GstVideoFormatInfo *finfo;
 476 
 477     str = gst_structure_get_string (s, &quot;format&quot;);
 478     if (str == NULL)
 479       return g_strdup (_(&quot;Uncompressed video&quot;));
 480     format = gst_video_format_from_string (str);
 481     if (format == GST_VIDEO_FORMAT_UNKNOWN)
 482       return g_strdup (_(&quot;Uncompressed video&quot;));
 483 
 484     finfo = gst_video_format_get_info (format);
 485 
 486     if (GST_VIDEO_FORMAT_INFO_IS_GRAY (finfo)) {
 487       ret = g_strdup (_(&quot;Uncompressed gray&quot;));
 488     } else if (GST_VIDEO_FORMAT_INFO_IS_YUV (finfo)) {
 489       const gchar *subs;
 490       gint w_sub, h_sub, n_semi;
 491 
 492       w_sub = GST_VIDEO_FORMAT_INFO_W_SUB (finfo, 1);
 493       h_sub = GST_VIDEO_FORMAT_INFO_H_SUB (finfo, 1);
 494 
 495       if (w_sub == 1 &amp;&amp; h_sub == 1) {
 496         subs = &quot;4:4:4&quot;;
 497       } else if (w_sub == 2 &amp;&amp; h_sub == 1) {
 498         subs = &quot;4:2:2&quot;;
 499       } else if (w_sub == 2 &amp;&amp; h_sub == 2) {
 500         subs = &quot;4:2:0&quot;;
 501       } else if (w_sub == 4 &amp;&amp; h_sub == 1) {
 502         subs = &quot;4:1:1&quot;;
 503       } else {
 504         subs = &quot;&quot;;
<a name="3" id="anc3"></a><span class="line-modified"> 505     }</span>
 506 
 507       n_semi = GST_VIDEO_FORMAT_INFO_HAS_ALPHA (finfo) ? 3 : 2;
 508 
 509       if (GST_VIDEO_FORMAT_INFO_N_PLANES (finfo) == 1) {
 510         ret = g_strdup_printf (_(&quot;Uncompressed packed YUV %s&quot;), subs);
 511       } else if (GST_VIDEO_FORMAT_INFO_N_PLANES (finfo) == n_semi) {
 512         ret = g_strdup_printf (_(&quot;Uncompressed semi-planar YUV %s&quot;), subs);
<a name="4" id="anc4"></a><span class="line-modified"> 513     } else {</span>
 514         ret = g_strdup_printf (_(&quot;Uncompressed planar YUV %s&quot;), subs);
<a name="5" id="anc5"></a><span class="line-modified"> 515     }</span>
 516     } else if (GST_VIDEO_FORMAT_INFO_IS_RGB (finfo)) {
 517       gboolean alpha, palette;
 518       gint bits;
 519 
 520       alpha = GST_VIDEO_FORMAT_INFO_HAS_ALPHA (finfo);
 521       palette = GST_VIDEO_FORMAT_INFO_HAS_PALETTE (finfo);
 522       bits = GST_VIDEO_FORMAT_INFO_BITS (finfo);
 523 
 524       if (palette) {
 525         ret = g_strdup_printf (_(&quot;Uncompressed palettized %d-bit %s&quot;),
 526             bits, alpha ? &quot;RGBA&quot; : &quot;RGB&quot;);
 527       } else {
 528         ret = g_strdup_printf (_(&quot;Uncompressed %d-bit %s&quot;),
 529             bits, alpha ? &quot;RGBA&quot; : &quot;RGB&quot;);
 530       }
 531     } else {
 532       ret = g_strdup (_(&quot;Uncompressed video&quot;));
 533     }
 534     return ret;
 535   } else if (strcmp (info-&gt;type, &quot;video/x-h263&quot;) == 0) {
 536     const gchar *variant, *ret;
 537 
 538     variant = gst_structure_get_string (s, &quot;variant&quot;);
 539     if (variant == NULL)
 540       ret = &quot;H.263&quot;;
 541     else if (strcmp (variant, &quot;itu&quot;) == 0)
 542       ret = &quot;ITU H.26n&quot;;        /* why not ITU H.263? (tpm) */
 543     else if (strcmp (variant, &quot;lead&quot;) == 0)
 544       ret = &quot;Lead H.263&quot;;
 545     else if (strcmp (variant, &quot;microsoft&quot;) == 0)
 546       ret = &quot;Microsoft H.263&quot;;
 547     else if (strcmp (variant, &quot;vdolive&quot;) == 0)
 548       ret = &quot;VDOLive&quot;;
 549     else if (strcmp (variant, &quot;vivo&quot;) == 0)
 550       ret = &quot;Vivo H.263&quot;;
 551     else if (strcmp (variant, &quot;xirlink&quot;) == 0)
 552       ret = &quot;Xirlink H.263&quot;;
 553     else {
 554       GST_WARNING (&quot;Unknown H263 variant &#39;%s&#39;&quot;, variant);
 555       ret = &quot;H.263&quot;;
 556     }
 557     return g_strdup (ret);
 558   } else if (strcmp (info-&gt;type, &quot;video/x-h264&quot;) == 0) {
 559     const gchar *variant, *ret;
 560     const gchar *profile;
 561 
 562     variant = gst_structure_get_string (s, &quot;variant&quot;);
 563     if (variant == NULL)
 564       ret = &quot;H.264&quot;;
 565     else if (strcmp (variant, &quot;itu&quot;) == 0)
 566       ret = &quot;ITU H.264&quot;;
 567     else if (strcmp (variant, &quot;videosoft&quot;) == 0)
 568       ret = &quot;Videosoft H.264&quot;;
 569     else if (strcmp (variant, &quot;lead&quot;) == 0)
 570       ret = &quot;Lead H.264&quot;;
 571     else {
 572       GST_WARNING (&quot;Unknown H264 variant &#39;%s&#39;&quot;, variant);
 573       ret = &quot;H.264&quot;;
 574     }
 575     /* profile */
 576     profile = gst_structure_get_string (s, &quot;profile&quot;);
 577     if (profile != NULL)
 578       profile = pbutils_desc_get_h264_profile_name_from_nick (profile);
 579     if (profile == NULL)
<a name="6" id="anc6"></a><span class="line-modified"> 580     return g_strdup (ret);</span>
 581     return g_strdup_printf (&quot;%s (%s Profile)&quot;, ret, profile);
 582   } else if (strcmp (info-&gt;type, &quot;video/x-h265&quot;) == 0) {
 583     const gchar *profile = gst_structure_get_string (s, &quot;profile&quot;);
 584 
 585     if (profile != NULL)
 586       profile = pbutils_desc_get_h265_profile_name_from_nick (profile);
 587     if (profile != NULL)
 588       return g_strdup_printf (&quot;H.265 (%s Profile)&quot;, profile);
 589 
 590     return g_strdup (&quot;H.265&quot;);
 591   } else if (strcmp (info-&gt;type, &quot;video/x-dirac&quot;) == 0) {
 592     const gchar *profile = gst_structure_get_string (s, &quot;profile&quot;);
 593     if (profile == NULL)
 594       return g_strdup (&quot;Dirac&quot;);
 595     if (strcmp (profile, &quot;vc2-low-delay&quot;) == 0)
 596       return g_strdup_printf (&quot;Dirac (%s)&quot;, &quot;VC-2 Low Delay Profile&quot;);
 597     else if (strcmp (profile, &quot;vc2-simple&quot;) == 0)
 598       return g_strdup_printf (&quot;Dirac (%s)&quot;, &quot;VC-2 Simple Profile&quot;);
 599     else if (strcmp (profile, &quot;vc2-main&quot;) == 0)
 600       return g_strdup_printf (&quot;Dirac (%s)&quot;, &quot;VC-2 Main Profile&quot;);
 601     else
 602       return g_strdup (&quot;Dirac&quot;);
 603   } else if (strcmp (info-&gt;type, &quot;video/x-divx&quot;) == 0) {
 604     gint ver = 0;
 605 
 606     if (!gst_structure_get_int (s, &quot;divxversion&quot;, &amp;ver) || ver &lt;= 2) {
 607       GST_WARNING (&quot;Unexpected DivX version in %&quot; GST_PTR_FORMAT, caps);
 608       return g_strdup (&quot;DivX MPEG-4&quot;);
 609     }
 610     return g_strdup_printf (_(&quot;DivX MPEG-4 Version %d&quot;), ver);
 611   } else if (strcmp (info-&gt;type, &quot;video/x-msmpeg&quot;) == 0) {
 612     gint ver = 0;
 613 
 614     if (!gst_structure_get_int (s, &quot;msmpegversion&quot;, &amp;ver) ||
 615         ver &lt; 40 || ver &gt; 49) {
 616       GST_WARNING (&quot;Unexpected msmpegversion in %&quot; GST_PTR_FORMAT, caps);
 617       return g_strdup (&quot;Microsoft MPEG-4 4.x&quot;);
 618     }
 619     return g_strdup_printf (&quot;Microsoft MPEG-4 4.%d&quot;, ver % 10);
 620   } else if (strcmp (info-&gt;type, &quot;video/x-truemotion&quot;) == 0) {
 621     gint ver = 0;
 622 
 623     gst_structure_get_int (s, &quot;trueversion&quot;, &amp;ver);
 624     switch (ver) {
 625       case 1:
 626         return g_strdup_printf (&quot;Duck TrueMotion 1&quot;);
 627       case 2:
 628         return g_strdup_printf (&quot;TrueMotion 2.0&quot;);
 629       default:
 630         GST_WARNING (&quot;Unexpected trueversion in %&quot; GST_PTR_FORMAT, caps);
 631         break;
 632     }
 633     return g_strdup_printf (&quot;TrueMotion&quot;);
 634   } else if (strcmp (info-&gt;type, &quot;video/x-xan&quot;) == 0) {
 635     gint ver = 0;
 636 
 637     if (!gst_structure_get_int (s, &quot;wcversion&quot;, &amp;ver) || ver &lt; 1) {
 638       GST_WARNING (&quot;Unexpected wcversion in %&quot; GST_PTR_FORMAT, caps);
 639       return g_strdup (&quot;Xan Wing Commander&quot;);
 640     }
 641     return g_strdup_printf (&quot;Xan Wing Commander %u&quot;, ver);
 642   } else if (strcmp (info-&gt;type, &quot;video/x-indeo&quot;) == 0) {
 643     gint ver = 0;
 644 
 645     if (!gst_structure_get_int (s, &quot;indeoversion&quot;, &amp;ver) || ver &lt; 2) {
 646       GST_WARNING (&quot;Unexpected indeoversion in %&quot; GST_PTR_FORMAT, caps);
 647       return g_strdup (&quot;Intel Indeo&quot;);
 648     }
 649     return g_strdup_printf (&quot;Intel Indeo %u&quot;, ver);
 650   } else if (strcmp (info-&gt;type, &quot;audio/x-wma&quot;) == 0) {
 651     gint ver = 0;
 652 
 653     gst_structure_get_int (s, &quot;wmaversion&quot;, &amp;ver);
 654     switch (ver) {
 655       case 1:
 656       case 2:
 657       case 3:
 658         return g_strdup_printf (&quot;Windows Media Audio %d&quot;, ver + 6);
 659       default:
 660         break;
 661     }
 662     GST_WARNING (&quot;Unexpected wmaversion in %&quot; GST_PTR_FORMAT, caps);
 663     return g_strdup (&quot;Windows Media Audio&quot;);
 664   } else if (strcmp (info-&gt;type, &quot;video/x-wmv&quot;) == 0) {
 665     gint ver = 0;
 666     const gchar *str;
 667 
 668     gst_structure_get_int (s, &quot;wmvversion&quot;, &amp;ver);
 669     str = gst_structure_get_string (s, &quot;format&quot;);
 670 
 671     switch (ver) {
 672       case 1:
 673       case 2:
 674       case 3:
 675         if (str &amp;&amp; strncmp (str, &quot;MSS&quot;, 3)) {
 676           return g_strdup_printf (&quot;Windows Media Video %d Screen&quot;, ver + 6);
 677         } else {
 678           return g_strdup_printf (&quot;Windows Media Video %d&quot;, ver + 6);
 679         }
 680       default:
 681         break;
 682     }
 683     GST_WARNING (&quot;Unexpected wmvversion in %&quot; GST_PTR_FORMAT, caps);
 684     return g_strdup (&quot;Windows Media Video&quot;);
 685   } else if (strcmp (info-&gt;type, &quot;audio/x-mace&quot;) == 0) {
 686     gint ver = 0;
 687 
 688     gst_structure_get_int (s, &quot;maceversion&quot;, &amp;ver);
 689     if (ver == 3 || ver == 6) {
 690       return g_strdup_printf (&quot;MACE-%d&quot;, ver);
 691     } else {
 692       GST_WARNING (&quot;Unexpected maceversion in %&quot; GST_PTR_FORMAT, caps);
 693       return g_strdup (&quot;MACE&quot;);
 694     }
 695   } else if (strcmp (info-&gt;type, &quot;video/x-svq&quot;) == 0) {
 696     gint ver = 0;
 697 
 698     gst_structure_get_int (s, &quot;svqversion&quot;, &amp;ver);
 699     if (ver == 1 || ver == 3) {
 700       return g_strdup_printf (&quot;Sorensen Video %d&quot;, ver);
 701     } else {
 702       GST_WARNING (&quot;Unexpected svqversion in %&quot; GST_PTR_FORMAT, caps);
 703       return g_strdup (&quot;Sorensen Video&quot;);
 704     }
 705   } else if (strcmp (info-&gt;type, &quot;video/x-asus&quot;) == 0) {
 706     gint ver = 0;
 707 
 708     gst_structure_get_int (s, &quot;asusversion&quot;, &amp;ver);
 709     if (ver == 1 || ver == 2) {
 710       return g_strdup_printf (&quot;Asus Video %d&quot;, ver);
 711     } else {
 712       GST_WARNING (&quot;Unexpected asusversion in %&quot; GST_PTR_FORMAT, caps);
 713       return g_strdup (&quot;Asus Video&quot;);
 714     }
 715   } else if (strcmp (info-&gt;type, &quot;video/x-ati-vcr&quot;) == 0) {
 716     gint ver = 0;
 717 
 718     gst_structure_get_int (s, &quot;vcrversion&quot;, &amp;ver);
 719     if (ver == 1 || ver == 2) {
 720       return g_strdup_printf (&quot;ATI VCR %d&quot;, ver);
 721     } else {
 722       GST_WARNING (&quot;Unexpected acrversion in %&quot; GST_PTR_FORMAT, caps);
 723       return g_strdup (&quot;ATI VCR&quot;);
 724     }
 725   } else if (strcmp (info-&gt;type, &quot;audio/x-adpcm&quot;) == 0) {
 726     const GValue *layout_val;
 727 
 728     layout_val = gst_structure_get_value (s, &quot;layout&quot;);
 729     if (layout_val != NULL &amp;&amp; G_VALUE_HOLDS_STRING (layout_val)) {
 730       const gchar *layout;
 731 
 732       if ((layout = g_value_get_string (layout_val))) {
 733         gchar *layout_upper, *ret;
 734 
 735         if (strcmp (layout, &quot;swf&quot;) == 0)
 736           return g_strdup (&quot;Shockwave ADPCM&quot;);
 737         if (strcmp (layout, &quot;microsoft&quot;) == 0)
 738           return g_strdup (&quot;Microsoft ADPCM&quot;);
 739         if (strcmp (layout, &quot;quicktime&quot;) == 0)
 740           return g_strdup (&quot;Quicktime ADPCM&quot;);
 741         if (strcmp (layout, &quot;westwood&quot;) == 0)
 742           return g_strdup (&quot;Westwood ADPCM&quot;);
 743         if (strcmp (layout, &quot;yamaha&quot;) == 0)
 744           return g_strdup (&quot;Yamaha ADPCM&quot;);
 745         /* FIXME: other layouts: sbpro2, sbpro3, sbpro4, ct, g726, ea,
 746          * adx, xa, 4xm, smjpeg, dk4, dk3, dvi */
 747         layout_upper = g_ascii_strup (layout, -1);
 748         ret = g_strdup_printf (&quot;%s ADPCM&quot;, layout_upper);
 749         g_free (layout_upper);
 750         return ret;
 751       }
 752     }
 753     return g_strdup (&quot;ADPCM&quot;);
 754   } else if (strcmp (info-&gt;type, &quot;audio/mpeg&quot;) == 0) {
 755     gint ver = 0, layer = 0;
 756 
 757     gst_structure_get_int (s, &quot;mpegversion&quot;, &amp;ver);
 758 
 759     switch (ver) {
 760       case 1:
 761         gst_structure_get_int (s, &quot;layer&quot;, &amp;layer);
 762         switch (layer) {
 763           case 1:
 764           case 2:
 765           case 3:
 766             return g_strdup_printf (&quot;MPEG-1 Layer %d (MP%d)&quot;, layer, layer);
 767           default:
 768             break;
 769         }
 770         GST_WARNING (&quot;Unexpected MPEG-1 layer in %&quot; GST_PTR_FORMAT, caps);
 771         return g_strdup (&quot;MPEG-1 Audio&quot;);
 772       case 2:
 773         return g_strdup (&quot;MPEG-2 AAC&quot;);
 774       case 4:
 775         return g_strdup (&quot;MPEG-4 AAC&quot;);
 776       default:
 777         break;
 778     }
 779     GST_WARNING (&quot;Unexpected audio mpegversion in %&quot; GST_PTR_FORMAT, caps);
 780     return g_strdup (&quot;MPEG Audio&quot;);
 781   } else if (strcmp (info-&gt;type, &quot;audio/x-pn-realaudio&quot;) == 0) {
 782     gint ver = 0;
 783 
 784     gst_structure_get_int (s, &quot;raversion&quot;, &amp;ver);
 785     switch (ver) {
 786       case 1:
 787         return g_strdup (&quot;RealAudio 14k4bps&quot;);
 788       case 2:
 789         return g_strdup (&quot;RealAudio 28k8bps&quot;);
 790       case 8:
 791         return g_strdup (&quot;RealAudio G2 (Cook)&quot;);
 792       default:
 793         break;
 794     }
 795     GST_WARNING (&quot;Unexpected raversion in %&quot; GST_PTR_FORMAT, caps);
 796     return g_strdup (&quot;RealAudio&quot;);
 797   } else if (strcmp (info-&gt;type, &quot;video/x-pn-realvideo&quot;) == 0) {
 798     gint ver = 0;
 799 
 800     gst_structure_get_int (s, &quot;rmversion&quot;, &amp;ver);
 801     switch (ver) {
 802       case 1:
 803         return g_strdup (&quot;RealVideo 1.0&quot;);
 804       case 2:
 805         return g_strdup (&quot;RealVideo 2.0&quot;);
 806       case 3:
 807         return g_strdup (&quot;RealVideo 3.0&quot;);
 808       case 4:
 809         return g_strdup (&quot;RealVideo 4.0&quot;);
 810       default:
 811         break;
 812     }
 813     GST_WARNING (&quot;Unexpected rmversion in %&quot; GST_PTR_FORMAT, caps);
 814     return g_strdup (&quot;RealVideo&quot;);
 815   } else if (strcmp (info-&gt;type, &quot;video/mpeg&quot;) == 0) {
 816     gboolean sysstream;
 817     gint ver = 0;
 818 
 819     if (!gst_structure_get_boolean (s, &quot;systemstream&quot;, &amp;sysstream)) {
 820       GST_WARNING (&quot;Missing systemstream field in mpeg video caps &quot;
 821           &quot;%&quot; GST_PTR_FORMAT, caps);
 822       sysstream = FALSE;
 823     }
 824 
 825     if (gst_structure_get_int (s, &quot;mpegversion&quot;, &amp;ver) &amp;&amp; ver &gt; 0 &amp;&amp; ver &lt;= 4) {
 826       if (sysstream) {
 827         return g_strdup_printf (&quot;MPEG-%d System Stream&quot;, ver);
 828       } else {
 829         const gchar *profile = gst_structure_get_string (s, &quot;profile&quot;);
 830         if (profile != NULL) {
 831           if (ver == 4)
 832             profile = pbutils_desc_get_mpeg4v_profile_name_from_nick (profile);
 833           else if (ver == 2)
 834             profile = pbutils_desc_get_mpeg2v_profile_name_from_nick (profile);
 835           else
 836             profile = NULL;
 837         }
 838         if (profile != NULL)
 839           return g_strdup_printf (&quot;MPEG-%d Video (%s Profile)&quot;, ver, profile);
 840         else
<a name="7" id="anc7"></a><span class="line-modified"> 841         return g_strdup_printf (&quot;MPEG-%d Video&quot;, ver);</span>
 842       }
 843     }
 844     GST_WARNING (&quot;Missing mpegversion field in mpeg video caps &quot;
 845         &quot;%&quot; GST_PTR_FORMAT, caps);
 846     return g_strdup (&quot;MPEG Video&quot;);
 847   } else if (strcmp (info-&gt;type, &quot;audio/x-raw&quot;) == 0) {
 848     gint depth = 0;
 849     gboolean is_float;
 850     const gchar *str;
 851     GstAudioFormat format = GST_AUDIO_FORMAT_UNKNOWN;
 852     const GstAudioFormatInfo *finfo;
 853 
 854     str = gst_structure_get_string (s, &quot;format&quot;);
 855     if (str)
 856       format = gst_audio_format_from_string (str);
 857     if (format == GST_AUDIO_FORMAT_UNKNOWN)
 858       return g_strdup (_(&quot;Uncompressed audio&quot;));
 859 
 860     finfo = gst_audio_format_get_info (format);
 861     depth = GST_AUDIO_FORMAT_INFO_DEPTH (finfo);
 862     is_float = GST_AUDIO_FORMAT_INFO_IS_FLOAT (finfo);
 863 
 864     return g_strdup_printf (_(&quot;Raw %d-bit %s audio&quot;), depth,
 865         is_float ? &quot;floating-point&quot; : &quot;PCM&quot;);
 866   } else if (strcmp (info-&gt;type, &quot;video/x-tscc&quot;) == 0) {
 867     gint version;
 868     gst_structure_get_int (s, &quot;tsccversion&quot;, &amp;version);
 869     switch (version) {
 870       case 1:
 871         return g_strdup (&quot;TechSmith Screen Capture 1&quot;);
 872       case 2:
 873         return g_strdup (&quot;TechSmith Screen Capture 2&quot;);
 874       default:
 875         break;
<a name="8" id="anc8"></a><span class="line-modified"> 876   }</span>
 877     GST_WARNING (&quot;Unexpected version in %&quot; GST_PTR_FORMAT, caps);
 878     return g_strdup (&quot;TechSmith Screen Capture&quot;);
 879   }
 880   return NULL;
 881 }
 882 
 883 /* returns format info structure, will return NULL for dynamic media types! */
 884 static const FormatInfo *
 885 find_format_info (const GstCaps * caps)
 886 {
 887   const GstStructure *s;
 888   const gchar *media_type;
 889   guint i;
 890 
 891   s = gst_caps_get_structure (caps, 0);
 892   media_type = gst_structure_get_name (s);
 893 
 894   for (i = 0; i &lt; G_N_ELEMENTS (formats); ++i) {
 895     if (strcmp (media_type, formats[i].type) == 0) {
 896       gboolean is_sys = FALSE;
 897 
 898       if ((formats[i].flags &amp; FLAG_SYSTEMSTREAM) == 0)
 899         return &amp;formats[i];
 900 
 901       /* this record should only be matched if the systemstream field is set */
 902       if (gst_structure_get_boolean (s, &quot;systemstream&quot;, &amp;is_sys) &amp;&amp; is_sys)
 903         return &amp;formats[i];
 904     }
 905   }
 906 
 907   return NULL;
 908 }
 909 
 910 static gboolean
 911 caps_are_rtp_caps (const GstCaps * caps, const gchar * media, gchar ** format)
 912 {
 913   const GstStructure *s;
 914   const gchar *str;
 915 
 916   g_assert (media != NULL &amp;&amp; format != NULL);
 917 
 918   s = gst_caps_get_structure (caps, 0);
 919   if (!gst_structure_has_name (s, &quot;application/x-rtp&quot;))
 920     return FALSE;
 921   if (!gst_structure_has_field_typed (s, &quot;media&quot;, G_TYPE_STRING))
 922     return FALSE;
 923   str = gst_structure_get_string (s, &quot;media&quot;);
 924   if (str == NULL || !g_str_equal (str, media))
 925     return FALSE;
 926   str = gst_structure_get_string (s, &quot;encoding-name&quot;);
 927   if (str == NULL || *str == &#39;\0&#39;)
 928     return FALSE;
 929 
 930   if (strcmp (str, &quot;X-ASF-PF&quot;) == 0) {
 931     *format = g_strdup (&quot;Windows Media&quot;);
 932   } else if (g_str_has_prefix (str, &quot;X-&quot;)) {
 933     *format = g_strdup (str + 2);
 934   } else {
 935     *format = g_strdup (str);
 936   }
 937 
 938   return TRUE;
 939 }
 940 
 941 /**
 942  * gst_pb_utils_get_source_description:
 943  * @protocol: the protocol the source element needs to handle, e.g. &quot;http&quot;
 944  *
 945  * Returns a localised string describing a source element handling the protocol
 946  * specified in @protocol, for use in error dialogs or other messages to be
 947  * seen by the user. Should never return NULL unless @protocol is invalid.
 948  *
 949  * This function is mainly for internal use, applications would typically
 950  * use gst_missing_plugin_message_get_description() to get a description of
 951  * a missing feature from a missing-plugin message.
 952  *
 953  * Returns: a newly-allocated description string, or NULL on error. Free
 954  *          string with g_free() when not needed any longer.
 955  */
 956 gchar *
 957 gst_pb_utils_get_source_description (const gchar * protocol)
 958 {
 959   gchar *proto_uc, *ret;
 960 
 961   g_return_val_if_fail (protocol != NULL, NULL);
 962 
 963   gst_pb_utils_init_locale_text_domain ();
 964 
 965   if (strcmp (protocol, &quot;cdda&quot;) == 0)
 966     return g_strdup (_(&quot;Audio CD source&quot;));
 967 
 968   if (strcmp (protocol, &quot;dvd&quot;) == 0)
 969     return g_strdup (_(&quot;DVD source&quot;));
 970 
 971   if (strcmp (protocol, &quot;rtsp&quot;) == 0)
 972     return g_strdup (_(&quot;Real Time Streaming Protocol (RTSP) source&quot;));
 973 
 974   /* TODO: what about mmst, mmsu, mmsh? */
 975   if (strcmp (protocol, &quot;mms&quot;) == 0)
 976     return g_strdup (_(&quot;Microsoft Media Server (MMS) protocol source&quot;));
 977 
 978   /* make protocol uppercase */
 979   proto_uc = g_ascii_strup (protocol, -1);
 980 
 981   /* TODO: find out how to add a comment for translators to the source code
 982    * (and tell them to make the first letter uppercase below if they move
 983    * the protocol to the middle or end of the string) */
 984   ret = g_strdup_printf (_(&quot;%s protocol source&quot;), proto_uc);
 985 
 986   g_free (proto_uc);
 987 
 988   return ret;
 989 }
 990 
 991 /**
 992  * gst_pb_utils_get_sink_description:
 993  * @protocol: the protocol the sink element needs to handle, e.g. &quot;http&quot;
 994  *
 995  * Returns a localised string describing a sink element handling the protocol
 996  * specified in @protocol, for use in error dialogs or other messages to be
 997  * seen by the user. Should never return NULL unless @protocol is invalid.
 998  *
 999  * This function is mainly for internal use, applications would typically
1000  * use gst_missing_plugin_message_get_description() to get a description of
1001  * a missing feature from a missing-plugin message.
1002  *
1003  * Returns: a newly-allocated description string, or NULL on error. Free
1004  *          string with g_free() when not needed any longer.
1005  */
1006 gchar *
1007 gst_pb_utils_get_sink_description (const gchar * protocol)
1008 {
1009   gchar *proto_uc, *ret;
1010 
1011   g_return_val_if_fail (protocol != NULL, NULL);
1012 
1013   /* make protocol uppercase */
1014   proto_uc = g_ascii_strup (protocol, -1);
1015 
1016   /* TODO: find out how to add a comment for translators to the source code
1017    * (and tell them to make the first letter uppercase below if they move
1018    * the protocol to the middle or end of the string) */
1019   ret = g_strdup_printf (&quot;%s protocol sink&quot;, proto_uc);
1020 
1021   g_free (proto_uc);
1022 
1023   return ret;
1024 }
1025 
1026 /**
1027  * gst_pb_utils_get_decoder_description:
1028  * @caps: the (fixed) #GstCaps for which an decoder description is needed
1029  *
1030  * Returns a localised string describing an decoder for the format specified
1031  * in @caps, for use in error dialogs or other messages to be seen by the user.
1032  * Should never return NULL unless @factory_name or @caps are invalid.
1033  *
1034  * This function is mainly for internal use, applications would typically
1035  * use gst_missing_plugin_message_get_description() to get a description of
1036  * a missing feature from a missing-plugin message.
1037  *
1038  * Returns: a newly-allocated description string, or NULL on error. Free
1039  *          string with g_free() when not needed any longer.
1040  */
1041 gchar *
1042 gst_pb_utils_get_decoder_description (const GstCaps * caps)
1043 {
1044   gchar *str, *ret;
1045   GstCaps *tmp;
1046 
1047   g_return_val_if_fail (caps != NULL, NULL);
1048   g_return_val_if_fail (GST_IS_CAPS (caps), NULL);
1049 
1050   tmp = copy_and_clean_caps (caps);
1051 
1052   g_return_val_if_fail (gst_caps_is_fixed (tmp), NULL);
1053 
1054   gst_pb_utils_init_locale_text_domain ();
1055 
1056   /* special-case RTP caps */
1057   if (caps_are_rtp_caps (tmp, &quot;video&quot;, &amp;str)) {
1058     ret = g_strdup_printf (_(&quot;%s video RTP depayloader&quot;), str);
1059   } else if (caps_are_rtp_caps (tmp, &quot;audio&quot;, &amp;str)) {
1060     ret = g_strdup_printf (_(&quot;%s audio RTP depayloader&quot;), str);
1061   } else if (caps_are_rtp_caps (tmp, &quot;application&quot;, &amp;str)) {
1062     ret = g_strdup_printf (_(&quot;%s RTP depayloader&quot;), str);
1063   } else {
1064     const FormatInfo *info;
1065 
1066     str = gst_pb_utils_get_codec_description (tmp);
1067     info = find_format_info (tmp);
1068     if (info != NULL &amp;&amp; (info-&gt;flags &amp; FLAG_CONTAINER) != 0) {
1069       ret = g_strdup_printf (_(&quot;%s demuxer&quot;), str);
1070     } else {
1071       ret = g_strdup_printf (_(&quot;%s decoder&quot;), str);
1072     }
1073   }
1074 
1075   g_free (str);
1076   gst_caps_unref (tmp);
1077 
1078   return ret;
1079 }
1080 
1081 /**
1082  * gst_pb_utils_get_encoder_description:
1083  * @caps: the (fixed) #GstCaps for which an encoder description is needed
1084  *
1085  * Returns a localised string describing an encoder for the format specified
1086  * in @caps, for use in error dialogs or other messages to be seen by the user.
1087  * Should never return NULL unless @factory_name or @caps are invalid.
1088  *
1089  * This function is mainly for internal use, applications would typically
1090  * use gst_missing_plugin_message_get_description() to get a description of
1091  * a missing feature from a missing-plugin message.
1092  *
1093  * Returns: a newly-allocated description string, or NULL on error. Free
1094  *          string with g_free() when not needed any longer.
1095  */
1096 gchar *
1097 gst_pb_utils_get_encoder_description (const GstCaps * caps)
1098 {
1099   gchar *str, *ret;
1100   GstCaps *tmp;
1101 
1102   g_return_val_if_fail (caps != NULL, NULL);
1103   g_return_val_if_fail (GST_IS_CAPS (caps), NULL);
1104   tmp = copy_and_clean_caps (caps);
1105   g_return_val_if_fail (gst_caps_is_fixed (tmp), NULL);
1106   gst_pb_utils_init_locale_text_domain ();
1107 
1108   /* special-case RTP caps */
1109   if (caps_are_rtp_caps (tmp, &quot;video&quot;, &amp;str)) {
1110     ret = g_strdup_printf (_(&quot;%s video RTP payloader&quot;), str);
1111   } else if (caps_are_rtp_caps (tmp, &quot;audio&quot;, &amp;str)) {
1112     ret = g_strdup_printf (_(&quot;%s audio RTP payloader&quot;), str);
1113   } else if (caps_are_rtp_caps (tmp, &quot;application&quot;, &amp;str)) {
1114     ret = g_strdup_printf (_(&quot;%s RTP payloader&quot;), str);
1115   } else {
1116     const FormatInfo *info;
1117 
1118     str = gst_pb_utils_get_codec_description (tmp);
1119     info = find_format_info (tmp);
1120     if (info != NULL &amp;&amp; (info-&gt;flags &amp; FLAG_CONTAINER) != 0) {
1121       ret = g_strdup_printf (_(&quot;%s muxer&quot;), str);
1122     } else {
1123       ret = g_strdup_printf (_(&quot;%s encoder&quot;), str);
1124     }
1125   }
1126 
1127   g_free (str);
1128   gst_caps_unref (tmp);
1129 
1130   return ret;
1131 }
1132 
1133 /**
1134  * gst_pb_utils_get_element_description:
1135  * @factory_name: the name of the element, e.g. &quot;giosrc&quot;
1136  *
1137  * Returns a localised string describing the given element, for use in
1138  * error dialogs or other messages to be seen by the user. Should never
1139  * return NULL unless @factory_name is invalid.
1140  *
1141  * This function is mainly for internal use, applications would typically
1142  * use gst_missing_plugin_message_get_description() to get a description of
1143  * a missing feature from a missing-plugin message.
1144  *
1145  * Returns: a newly-allocated description string, or NULL on error. Free
1146  *          string with g_free() when not needed any longer.
1147  */
1148 gchar *
1149 gst_pb_utils_get_element_description (const gchar * factory_name)
1150 {
1151   gchar *ret;
1152 
1153   g_return_val_if_fail (factory_name != NULL, NULL);
1154 
1155   gst_pb_utils_init_locale_text_domain ();
1156 
1157   ret = g_strdup_printf (_(&quot;GStreamer element %s&quot;), factory_name);
1158   if (ret &amp;&amp; g_str_has_prefix (ret, factory_name))
1159     *ret = g_ascii_toupper (*ret);
1160 
1161   return ret;
1162 }
1163 
1164 /**
1165  * gst_pb_utils_add_codec_description_to_tag_list:
1166  * @taglist: a #GstTagList
1167  * @codec_tag: (allow-none): a GStreamer codec tag such as #GST_TAG_AUDIO_CODEC,
1168  *             #GST_TAG_VIDEO_CODEC or #GST_TAG_CODEC. If none is specified,
1169  *             the function will attempt to detect the appropriate category.
1170  * @caps: the (fixed) #GstCaps for which a codec tag should be added.
1171  *
1172  * Adds a codec tag describing the format specified by @caps to @taglist.
1173  *
1174  * Returns: TRUE if a codec tag was added, FALSE otherwise.
1175  */
1176 gboolean
1177 gst_pb_utils_add_codec_description_to_tag_list (GstTagList * taglist,
1178     const gchar * codec_tag, const GstCaps * caps)
1179 {
1180   const FormatInfo *info;
1181   gchar *desc;
1182 
1183   g_return_val_if_fail (taglist != NULL, FALSE);
1184   g_return_val_if_fail (GST_IS_TAG_LIST (taglist), FALSE);
1185   g_return_val_if_fail (codec_tag == NULL || (gst_tag_exists (codec_tag)
1186           &amp;&amp; gst_tag_get_type (codec_tag) == G_TYPE_STRING), FALSE);
1187   g_return_val_if_fail (caps != NULL, FALSE);
1188   g_return_val_if_fail (GST_IS_CAPS (caps), FALSE);
1189 
1190   info = find_format_info (caps);
1191   if (info == NULL)
1192     return FALSE;
1193 
1194   /* Attempt to find tag classification */
1195   if (codec_tag == NULL) {
1196     if (info-&gt;flags &amp; FLAG_CONTAINER)
1197       codec_tag = GST_TAG_CONTAINER_FORMAT;
1198     else if (info-&gt;flags &amp; FLAG_AUDIO)
1199       codec_tag = GST_TAG_AUDIO_CODEC;
1200     else if (info-&gt;flags &amp; FLAG_VIDEO)
1201       codec_tag = GST_TAG_VIDEO_CODEC;
1202     else if (info-&gt;flags &amp; FLAG_SUB)
1203       codec_tag = GST_TAG_SUBTITLE_CODEC;
1204     else
1205       codec_tag = GST_TAG_CODEC;
1206   }
1207 
1208   desc = format_info_get_desc (info, caps);
1209   gst_tag_list_add (taglist, GST_TAG_MERGE_REPLACE, codec_tag, desc, NULL);
1210   g_free (desc);
1211 
1212   return TRUE;
1213 }
1214 
1215 /**
1216  * gst_pb_utils_get_codec_description:
1217  * @caps: the (fixed) #GstCaps for which an format description is needed
1218  *
1219  * Returns a localised (as far as this is possible) string describing the
1220  * media format specified in @caps, for use in error dialogs or other messages
1221  * to be seen by the user. Should never return NULL unless @caps is invalid.
1222  *
1223  * Also see the convenience function
1224  * gst_pb_utils_add_codec_description_to_tag_list().
1225  *
1226  * Returns: a newly-allocated description string, or NULL on error. Free
1227  *          string with g_free() when not needed any longer.
1228  */
1229 gchar *
1230 gst_pb_utils_get_codec_description (const GstCaps * caps)
1231 {
1232   const FormatInfo *info;
1233   gchar *str, *comma;
1234   GstCaps *tmp;
1235 
1236   g_return_val_if_fail (caps != NULL, NULL);
1237   g_return_val_if_fail (GST_IS_CAPS (caps), NULL);
1238   tmp = copy_and_clean_caps (caps);
1239   g_return_val_if_fail (gst_caps_is_fixed (tmp), NULL);
1240 
1241   info = find_format_info (tmp);
1242 
1243   if (info) {
1244     str = format_info_get_desc (info, tmp);
1245   } else {
1246     str = gst_caps_to_string (tmp);
1247 
1248     /* cut off everything after the media type, if there is anything */
1249     if ((comma = strchr (str, &#39;,&#39;))) {
1250       *comma = &#39;\0&#39;;
1251       g_strchomp (str);
1252       /* we could do something more elaborate here, like taking into account
1253        * audio/, video/, image/ and application/ prefixes etc. */
1254     }
1255 
1256     GST_WARNING (&quot;No description available for media type: %s&quot;, str);
1257   }
1258   gst_caps_unref (tmp);
1259 
1260   return str;
1261 }
1262 
1263 /* internal helper functions for gst_encoding_profile_get_file_extension() */
1264 const gchar *pb_utils_get_file_extension_from_caps (const GstCaps * caps);
1265 gboolean pb_utils_is_tag (const GstCaps * caps);
1266 
1267 const gchar *
1268 pb_utils_get_file_extension_from_caps (const GstCaps * caps)
1269 {
1270   const FormatInfo *info;
1271   const gchar *ext = NULL;
1272   GstCaps *stripped_caps;
1273 
1274   g_assert (GST_IS_CAPS (caps));
1275 
1276   stripped_caps = copy_and_clean_caps (caps);
1277 
1278   g_assert (gst_caps_is_fixed (stripped_caps));
1279 
1280   info = find_format_info (stripped_caps);
1281 
1282   if (info &amp;&amp; info-&gt;ext[0] != &#39;\0&#39;) {
1283     ext = info-&gt;ext;
1284   } else if (info &amp;&amp; info-&gt;desc == NULL) {
1285     const GstStructure *s;
1286 
1287     s = gst_caps_get_structure (stripped_caps, 0);
1288 
1289     /* cases where we have to evaluate the caps more closely */
1290     if (strcmp (info-&gt;type, &quot;audio/mpeg&quot;) == 0) {
1291       int version = 0, layer = 3;
1292 
1293       if (gst_structure_get_int (s, &quot;mpegversion&quot;, &amp;version)) {
1294         if (version == 2 || version == 4) {
1295           ext = &quot;aac&quot;;
1296         } else if (version == 1) {
1297           gst_structure_get_int (s, &quot;layer&quot;, &amp;layer);
1298           if (layer == 1)
1299             ext = &quot;mp1&quot;;
1300           else if (layer == 2)
1301             ext = &quot;mp2&quot;;
1302           else
1303             ext = &quot;mp3&quot;;
1304         }
1305       }
1306     }
1307   }
1308 
1309   gst_caps_unref (stripped_caps);
1310   return ext;
1311 }
1312 
1313 gboolean
1314 pb_utils_is_tag (const GstCaps * caps)
1315 {
1316   const FormatInfo *info;
1317   GstCaps *stripped_caps;
1318   gboolean is_tag = FALSE;
1319 
1320   g_assert (GST_IS_CAPS (caps));
1321 
1322   stripped_caps = copy_and_clean_caps (caps);
1323 
1324   g_assert (gst_caps_is_fixed (stripped_caps));
1325 
1326   info = find_format_info (stripped_caps);
1327 
1328   if (info) {
1329     is_tag = (info-&gt;flags &amp; FLAG_TAG) != 0;
1330   }
1331   gst_caps_unref (stripped_caps);
1332 
1333   return is_tag;
1334 }
1335 
1336 #if 0
1337 void
1338 gst_pb_utils_list_all (void)
1339 {
1340   gint i;
1341 
1342   g_print (&quot;static const gchar *caps_strings[] = { &quot;);
1343 
1344   for (i = 0; i &lt; G_N_ELEMENTS (formats); ++i) {
1345     if (formats[i].desc != NULL)
1346       g_print (&quot;  \&quot;%s\&quot;, &quot;, formats[i].type);
1347   }
1348   g_print (&quot;\n#if 0\n&quot;);
1349   for (i = 0; i &lt; G_N_ELEMENTS (formats); ++i) {
1350     if (formats[i].desc == NULL)
1351       g_print (&quot;  \&quot;%s\&quot;, \n&quot;, formats[i].type);
1352   }
1353   g_print (&quot;\n#endif\n&quot;);
1354 }
1355 #endif
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>