diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmem.h b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmem.h
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmem.h
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmem.h
@@ -56,72 +56,73 @@
  * G_MEM_ALIGN:
  *
  * Indicates the number of bytes to which memory will be aligned on the
  * current platform.
  */
-#  define G_MEM_ALIGN   GLIB_SIZEOF_VOID_P
-#else   /* GLIB_SIZEOF_VOID_P <= GLIB_SIZEOF_LONG */
-#  define G_MEM_ALIGN   GLIB_SIZEOF_LONG
+#  define G_MEM_ALIGN GLIB_SIZEOF_VOID_P
+#else /* GLIB_SIZEOF_VOID_P <= GLIB_SIZEOF_LONG */
+#  define G_MEM_ALIGN GLIB_SIZEOF_LONG
 #endif  /* GLIB_SIZEOF_VOID_P <= GLIB_SIZEOF_LONG */
 
 
 /* Memory allocation functions
  */
 
 GLIB_AVAILABLE_IN_ALL
-void     g_free           (gpointer  mem);
+void   g_free           (gpointer  mem);
 
 GLIB_AVAILABLE_IN_2_34
 void     g_clear_pointer  (gpointer      *pp,
                            GDestroyNotify destroy);
 
 GLIB_AVAILABLE_IN_ALL
-gpointer g_malloc         (gsize     n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
+gpointer g_malloc         (gsize   n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
 GLIB_AVAILABLE_IN_ALL
-gpointer g_malloc0        (gsize     n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
+gpointer g_malloc0        (gsize   n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
 GLIB_AVAILABLE_IN_ALL
 gpointer g_realloc        (gpointer  mem,
-               gsize     n_bytes) G_GNUC_WARN_UNUSED_RESULT;
+         gsize   n_bytes) G_GNUC_WARN_UNUSED_RESULT;
 GLIB_AVAILABLE_IN_ALL
-gpointer g_try_malloc     (gsize     n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
+gpointer g_try_malloc     (gsize   n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
 GLIB_AVAILABLE_IN_ALL
-gpointer g_try_malloc0    (gsize     n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
+gpointer g_try_malloc0    (gsize   n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);
 GLIB_AVAILABLE_IN_ALL
 gpointer g_try_realloc    (gpointer  mem,
-               gsize     n_bytes) G_GNUC_WARN_UNUSED_RESULT;
+         gsize   n_bytes) G_GNUC_WARN_UNUSED_RESULT;
 
 GLIB_AVAILABLE_IN_ALL
-gpointer g_malloc_n       (gsize     n_blocks,
-               gsize     n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
+gpointer g_malloc_n       (gsize   n_blocks,
+         gsize   n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
 GLIB_AVAILABLE_IN_ALL
-gpointer g_malloc0_n      (gsize     n_blocks,
-               gsize     n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
+gpointer g_malloc0_n      (gsize   n_blocks,
+         gsize   n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
 GLIB_AVAILABLE_IN_ALL
 gpointer g_realloc_n      (gpointer  mem,
-               gsize     n_blocks,
-               gsize     n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;
+         gsize   n_blocks,
+         gsize   n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;
 GLIB_AVAILABLE_IN_ALL
-gpointer g_try_malloc_n   (gsize     n_blocks,
-               gsize     n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
+gpointer g_try_malloc_n   (gsize   n_blocks,
+         gsize   n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
 GLIB_AVAILABLE_IN_ALL
-gpointer g_try_malloc0_n  (gsize     n_blocks,
-               gsize     n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
+gpointer g_try_malloc0_n  (gsize   n_blocks,
+         gsize   n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);
 GLIB_AVAILABLE_IN_ALL
 gpointer g_try_realloc_n  (gpointer  mem,
-               gsize     n_blocks,
-               gsize     n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;
+         gsize   n_blocks,
+         gsize   n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;
 
 #if defined(g_has_typeof) && GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_58
 #define g_clear_pointer(pp, destroy)                                           \
   G_STMT_START {                                                               \
     G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));                       \
     __typeof__((pp)) _pp = (pp);                                               \
     __typeof__(*(pp)) _ptr = *_pp;                                             \
     *_pp = NULL;                                                               \
     if (_ptr)                                                                  \
       (destroy) (_ptr);                                                        \
-  } G_STMT_END
+  } G_STMT_END                                                                 \
+  GLIB_AVAILABLE_MACRO_IN_2_34
 #else /* __GNUC__ */
 #define g_clear_pointer(pp, destroy) \
   G_STMT_START {                                                               \
     G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));                       \
     /* Only one access, please; work around type aliasing */                   \
@@ -130,16 +131,17 @@
     /* This assignment is needed to avoid a gcc warning */                     \
     GDestroyNotify _destroy = (GDestroyNotify) (destroy);                      \
                                                                                \
     _pp.in = (char *) (pp);                                                    \
     _p = *_pp.out;                                                             \
-    if (_p)                                        \
-      {                                        \
+    if (_p)                        \
+      {                        \
         *_pp.out = NULL;                                                       \
         _destroy (_p);                                                         \
       }                                                                        \
-  } G_STMT_END
+  } G_STMT_END                                                                 \
+  GLIB_AVAILABLE_MACRO_IN_2_34
 #endif /* __GNUC__ */
 
 /**
  * g_steal_pointer:
  * @pp: (not nullable): a pointer to a pointer
@@ -220,37 +222,37 @@
 /* Optimise: avoid the call to the (slower) _n function if we can
  * determine at compile-time that no overflow happens.
  */
 #if defined (__GNUC__) && (__GNUC__ >= 2) && defined (__OPTIMIZE__)
 #  define _G_NEW(struct_type, n_structs, func) \
-    (struct_type *) (G_GNUC_EXTENSION ({            \
-      gsize __n = (gsize) (n_structs);          \
-      gsize __s = sizeof (struct_type);         \
-      gpointer __p;                     \
-      if (__s == 1)                     \
-        __p = g_##func (__n);               \
-      else if (__builtin_constant_p (__n) &&        \
-               (__s == 0 || __n <= G_MAXSIZE / __s))    \
-        __p = g_##func (__n * __s);             \
-      else                          \
-        __p = g_##func##_n (__n, __s);          \
-      __p;                          \
-    }))
+  (struct_type *) (G_GNUC_EXTENSION ({      \
+    gsize __n = (gsize) (n_structs);      \
+    gsize __s = sizeof (struct_type);     \
+    gpointer __p;           \
+    if (__s == 1)           \
+      __p = g_##func (__n);       \
+    else if (__builtin_constant_p (__n) &&    \
+             (__s == 0 || __n <= G_MAXSIZE / __s))  \
+      __p = g_##func (__n * __s);       \
+    else              \
+      __p = g_##func##_n (__n, __s);      \
+    __p;              \
+  }))
 #  define _G_RENEW(struct_type, mem, n_structs, func) \
-    (struct_type *) (G_GNUC_EXTENSION ({            \
-      gsize __n = (gsize) (n_structs);          \
-      gsize __s = sizeof (struct_type);         \
-      gpointer __p = (gpointer) (mem);          \
-      if (__s == 1)                     \
-        __p = g_##func (__p, __n);              \
-      else if (__builtin_constant_p (__n) &&        \
-               (__s == 0 || __n <= G_MAXSIZE / __s))    \
-        __p = g_##func (__p, __n * __s);            \
-      else                          \
-        __p = g_##func##_n (__p, __n, __s);         \
-      __p;                          \
-    }))
+  (struct_type *) (G_GNUC_EXTENSION ({      \
+    gsize __n = (gsize) (n_structs);      \
+    gsize __s = sizeof (struct_type);     \
+    gpointer __p = (gpointer) (mem);      \
+    if (__s == 1)           \
+      __p = g_##func (__p, __n);        \
+    else if (__builtin_constant_p (__n) &&    \
+             (__s == 0 || __n <= G_MAXSIZE / __s))  \
+      __p = g_##func (__p, __n * __s);      \
+    else              \
+      __p = g_##func##_n (__p, __n, __s);     \
+    __p;              \
+  }))
 
 #else
 
 /* Unoptimised version: always call the _n() function. */
 
@@ -275,11 +277,11 @@
  * it is normally unnecessary to cast it explicitly, and doing
  * so might hide memory allocation errors.
  *
  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
  */
-#define g_new(struct_type, n_structs)           _G_NEW (struct_type, n_structs, malloc)
+#define g_new(struct_type, n_structs)     _G_NEW (struct_type, n_structs, malloc)
 /**
  * g_new0:
  * @struct_type: the type of the elements to allocate.
  * @n_structs: the number of elements to allocate.
  *
@@ -292,11 +294,11 @@
  * it is normally unnecessary to cast it explicitly, and doing
  * so might hide memory allocation errors.
  *
  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type.
  */
-#define g_new0(struct_type, n_structs)          _G_NEW (struct_type, n_structs, malloc0)
+#define g_new0(struct_type, n_structs)      _G_NEW (struct_type, n_structs, malloc0)
 /**
  * g_renew:
  * @struct_type: the type of the elements to allocate
  * @mem: the currently allocated memory
  * @n_structs: the number of elements to allocate
@@ -306,11 +308,11 @@
  * the memory, which may have been moved.
  * Care is taken to avoid overflow when calculating the size of the allocated block.
  *
  * Returns: a pointer to the new allocated memory, cast to a pointer to @struct_type
  */
-#define g_renew(struct_type, mem, n_structs)        _G_RENEW (struct_type, mem, n_structs, realloc)
+#define g_renew(struct_type, mem, n_structs)    _G_RENEW (struct_type, mem, n_structs, realloc)
 /**
  * g_try_new:
  * @struct_type: the type of the elements to allocate
  * @n_structs: the number of elements to allocate
  *
@@ -320,11 +322,11 @@
  * The function returns %NULL when @n_structs is 0 of if an overflow occurs.
  *
  * Since: 2.8
  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
  */
-#define g_try_new(struct_type, n_structs)       _G_NEW (struct_type, n_structs, try_malloc)
+#define g_try_new(struct_type, n_structs)   _G_NEW (struct_type, n_structs, try_malloc)
 /**
  * g_try_new0:
  * @struct_type: the type of the elements to allocate
  * @n_structs: the number of elements to allocate
  *
@@ -335,11 +337,11 @@
  * The function returns %NULL when @n_structs is 0 or if an overflow occurs.
  *
  * Since: 2.8
  * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
  */
-#define g_try_new0(struct_type, n_structs)      _G_NEW (struct_type, n_structs, try_malloc0)
+#define g_try_new0(struct_type, n_structs)    _G_NEW (struct_type, n_structs, try_malloc0)
 /**
  * g_try_renew:
  * @struct_type: the type of the elements to allocate
  * @mem: the currently allocated memory
  * @n_structs: the number of elements to allocate
@@ -351,40 +353,40 @@
  * The function returns %NULL if an overflow occurs.
  *
  * Since: 2.8
  * Returns: a pointer to the new allocated memory, cast to a pointer to @struct_type
  */
-#define g_try_renew(struct_type, mem, n_structs)    _G_RENEW (struct_type, mem, n_structs, try_realloc)
+#define g_try_renew(struct_type, mem, n_structs)  _G_RENEW (struct_type, mem, n_structs, try_realloc)
 
 
 /* Memory allocation virtualization for debugging purposes
  * g_mem_set_vtable() has to be the very first GLib function called
  * if being used
  */
 struct _GMemVTable {
   gpointer (*malloc)      (gsize    n_bytes);
   gpointer (*realloc)     (gpointer mem,
-               gsize    n_bytes);
+         gsize    n_bytes);
   void     (*free)        (gpointer mem);
   /* optional; set to NULL if not used ! */
   gpointer (*calloc)      (gsize    n_blocks,
-               gsize    n_block_bytes);
+         gsize    n_block_bytes);
   gpointer (*try_malloc)  (gsize    n_bytes);
   gpointer (*try_realloc) (gpointer mem,
-               gsize    n_bytes);
+         gsize    n_bytes);
 };
 GLIB_DEPRECATED_IN_2_46
-void     g_mem_set_vtable (GMemVTable   *vtable);
+void   g_mem_set_vtable (GMemVTable *vtable);
 GLIB_DEPRECATED_IN_2_46
 gboolean g_mem_is_system_malloc (void);
 
 GLIB_VAR gboolean g_mem_gc_friendly;
 
 /* Memory profiler and checker, has to be enabled via g_mem_set_vtable()
  */
 GLIB_VAR GMemVTable *glib_mem_profiler_table;
 GLIB_DEPRECATED_IN_2_46
-void    g_mem_profile   (void);
+void  g_mem_profile (void);
 
 G_END_DECLS
 
 #endif /* __G_MEM_H__ */
