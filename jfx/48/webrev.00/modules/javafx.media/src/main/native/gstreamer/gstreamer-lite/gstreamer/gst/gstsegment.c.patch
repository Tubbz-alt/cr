diff a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstsegment.c b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstsegment.c
--- a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstsegment.c
+++ b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstsegment.c
@@ -390,11 +390,11 @@
  * Translate @position to the total stream time using the currently configured
  * segment. Compared to gst_segment_to_stream_time() this function can return
  * negative stream-time.
  *
  * This function is typically used by elements that need to synchronize buffers
- * against the clock or eachother.
+ * against the clock or each other.
  *
  * @position can be any value and the result of this function for values outside
  * of the segment is extrapolated.
  *
  * When 1 is returned, @position resulted in a positive stream-time returned
@@ -697,11 +697,11 @@
   }
 
   if (res == 1)
     return position;
 
-    return -1;
+  return -1;
 }
 
 /**
  * gst_segment_to_running_time_full:
  * @segment: a #GstSegment structure.
@@ -712,11 +712,11 @@
  * Translate @position to the total running time using the currently configured
  * segment. Compared to gst_segment_to_running_time() this function can return
  * negative running-time.
  *
  * This function is typically used by elements that need to synchronize buffers
- * against the clock or eachother.
+ * against the clock or each other.
  *
  * @position can be any value and the result of this function for values outside
  * of the segment is extrapolated.
  *
  * When 1 is returned, @position resulted in a positive running-time returned
@@ -749,22 +749,25 @@
   offset = segment->offset;
 
   if (G_LIKELY (segment->rate > 0.0)) {
     start = segment->start + offset;
 
-  /* bring to uncorrected position in segment */
+    /* bring to uncorrected position in segment */
     if (position < start) {
       /* negative value */
       result = start - position;
       res = -1;
     } else {
-  result = position - start;
+      result = position - start;
       res = 1;
     }
   } else {
     stop = segment->stop;
 
+    if (stop == -1 && segment->duration != -1)
+      stop = segment->start + segment->duration;
+
     /* cannot continue if no stop position set or invalid offset */
     g_return_val_if_fail (stop != -1, 0);
     g_return_val_if_fail (stop >= offset, 0);
 
     stop -= offset;
@@ -772,14 +775,14 @@
     /* bring to uncorrected position in segment */
     if (position > stop) {
       /* negative value */
       result = position - stop;
       res = -1;
-  } else {
+    } else {
       result = stop - position;
       res = 1;
-  }
+    }
   }
 
   if (running_time) {
     /* scale based on the rate, avoid division by and conversion to
      * float when not needed */
@@ -798,11 +801,11 @@
       res = 1;
     } else {
       /* negative and base is smaller, subtract base and remainder is
        * negative */
       *running_time = result - segment->base;
-}
+    }
   }
   return res;
 
 done:
   {
@@ -851,21 +854,21 @@
         ")", position, segment->start);
     return -1;
   }
   /* after the segment boundary */
   if (G_UNLIKELY (segment->stop != -1 && position > segment->stop)) {
-      GST_DEBUG ("position(%" G_GUINT64_FORMAT ") > stop(%" G_GUINT64_FORMAT
+    GST_DEBUG ("position(%" G_GUINT64_FORMAT ") > stop(%" G_GUINT64_FORMAT
         ")", position, segment->stop);
-      return -1;
-    }
+    return -1;
+  }
 
   if (gst_segment_to_running_time_full (segment, format, position,
           &result) == 1)
     return result;
 
-      return -1;
-    }
+  return -1;
+}
 
 /**
  * gst_segment_clip:
  * @segment: a #GstSegment structure.
  * @format: the format of the segment.
@@ -1038,14 +1041,14 @@
     if (G_LIKELY (running_time >= base)) {
       *position = running_time - base;
       /* move into the segment at the right rate */
       if (G_UNLIKELY (abs_rate != 1.0))
         *position = ceil (*position * abs_rate);
-    /* bring to corrected position in segment */
+      /* bring to corrected position in segment */
       *position += start + segment->offset;
       res = 1;
-  } else {
+    } else {
       *position = base - running_time;
       if (G_UNLIKELY (abs_rate != 1.0))
         *position = ceil (*position * abs_rate);
       if (start + segment->offset >= *position) {
         /* The TS is before the segment, but the result is >= 0 */
@@ -1054,12 +1057,12 @@
       } else {
         /* The TS is before the segment, and the result is < 0
          * so negate the return result */
         *position = *position - (start + segment->offset);
         res = -1;
-  }
-}
+      }
+    }
   } else {
     if (G_LIKELY (running_time >= base)) {
       *position = running_time - base;
       if (G_UNLIKELY (abs_rate != 1.0))
         *position = ceil (*position * abs_rate);
