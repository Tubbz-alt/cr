<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstinfo.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wtay@chello.be&gt;
   4  *                    2003 Benjamin Otte &lt;in7y118@public.uni-hamburg.de&gt;
   5  * Copyright (C) 2008-2009 Tim-Philipp MÃ¼ller &lt;tim centricular net&gt;
   6  *
   7  * gstinfo.c: debugging functions
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public
  20  * License along with this library; if not, write to the
  21  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 /**
  26  * SECTION:gstinfo
  27  * @title: GstInfo
  28  * @short_description: Debugging and logging facilities
  29  * @see_also: #gst-running for command line parameters
  30  * and environment variables that affect the debugging output.
  31  *
  32  * GStreamer&#39;s debugging subsystem is an easy way to get information about what
  33  * the application is doing.  It is not meant for programming errors. Use GLib
  34  * methods (g_warning and friends) for that.
  35  *
  36  * The debugging subsystem works only after GStreamer has been initialized
  37  * - for example by calling gst_init().
  38  *
  39  * The debugging subsystem is used to log informational messages while the
  40  * application runs.  Each messages has some properties attached to it. Among
  41  * these properties are the debugging category, the severity (called &quot;level&quot;
  42  * here) and an optional #GObject it belongs to. Each of these messages is sent
  43  * to all registered debugging handlers, which then handle the messages.
  44  * GStreamer attaches a default handler on startup, which outputs requested
  45  * messages to stderr.
  46  *
  47  * Messages are output by using shortcut macros like #GST_DEBUG,
  48  * #GST_CAT_ERROR_OBJECT or similar. These all expand to calling gst_debug_log()
  49  * with the right parameters.
  50  * The only thing a developer will probably want to do is define his own
  51  * categories. This is easily done with 3 lines. At the top of your code,
  52  * declare
  53  * the variables and set the default category.
  54  * |[&lt;!-- language=&quot;C&quot; --&gt;
  55  *   GST_DEBUG_CATEGORY_STATIC (my_category);  // define category (statically)
  56  *   #define GST_CAT_DEFAULT my_category       // set as default
  57  * ]|
  58  * After that you only need to initialize the category.
  59  * |[&lt;!-- language=&quot;C&quot; --&gt;
  60  *   GST_DEBUG_CATEGORY_INIT (my_category, &quot;my category&quot;,
  61  *                            0, &quot;This is my very own&quot;);
  62  * ]|
  63  * Initialization must be done before the category is used first.
  64  * Plugins do this
  65  * in their plugin_init function, libraries and applications should do that
  66  * during their initialization.
  67  *
  68  * The whole debugging subsystem can be disabled at build time with passing the
  69  * --disable-gst-debug switch to configure. If this is done, every function,
  70  * macro and even structs described in this file evaluate to default values or
  71  * nothing at all.
  72  * So don&#39;t take addresses of these functions or use other tricks.
  73  * If you must do that for some reason, there is still an option.
  74  * If the debugging
  75  * subsystem was compiled out, #GST_DISABLE_GST_DEBUG is defined in
  76  * &amp;lt;gst/gst.h&amp;gt;,
  77  * so you can check that before doing your trick.
  78  * Disabling the debugging subsystem will give you a slight (read: unnoticeable)
  79  * speed increase and will reduce the size of your compiled code. The GStreamer
  80  * library itself becomes around 10% smaller.
  81  *
  82  * Please note that there are naming conventions for the names of debugging
  83  * categories. These are explained at GST_DEBUG_CATEGORY_INIT().
  84  */
  85 
  86 #define GST_INFO_C
  87 #include &quot;gst_private.h&quot;
  88 #include &quot;gstinfo.h&quot;
  89 
  90 #undef gst_debug_remove_log_function
  91 #undef gst_debug_add_log_function
  92 
  93 #ifndef GST_DISABLE_GST_DEBUG
  94 #ifdef HAVE_DLFCN_H
  95 #  include &lt;dlfcn.h&gt;
  96 #endif
  97 #include &lt;stdio.h&gt;              /* fprintf */
  98 #include &lt;glib/gstdio.h&gt;
  99 #include &lt;errno.h&gt;
 100 #ifdef HAVE_UNISTD_H
 101 #  include &lt;unistd.h&gt;           /* getpid on UNIX */
 102 #endif
 103 #ifdef HAVE_PROCESS_H
 104 #  include &lt;process.h&gt;          /* getpid on win32 */
 105 #endif
 106 #include &lt;string.h&gt;             /* G_VA_COPY */
 107 #ifdef G_OS_WIN32
 108 #  define WIN32_LEAN_AND_MEAN   /* prevents from including too many things */
 109 #  include &lt;windows.h&gt;          /* GetStdHandle, windows console */
 110 #endif
 111 
 112 #include &quot;gst_private.h&quot;
 113 #include &quot;gstutils.h&quot;
 114 #include &quot;gstquark.h&quot;
 115 #include &quot;gstsegment.h&quot;
 116 #include &quot;gstvalue.h&quot;
 117 #include &quot;gstcapsfeatures.h&quot;
 118 
 119 #ifdef HAVE_VALGRIND_VALGRIND_H
 120 #  include &lt;valgrind/valgrind.h&gt;
 121 #endif
 122 #include &lt;glib/gprintf.h&gt;       /* g_sprintf */
 123 
 124 /* our own printf implementation with custom extensions to %p for caps etc. */
 125 #include &quot;printf/printf.h&quot;
 126 #include &quot;printf/printf-extension.h&quot;
 127 
 128 static char *gst_info_printf_pointer_extension_func (const char *format,
 129     void *ptr);
 130 #else /* GST_DISABLE_GST_DEBUG */
 131 
 132 #include &lt;glib/gprintf.h&gt;
 133 #endif /* !GST_DISABLE_GST_DEBUG */
 134 
 135 #ifdef HAVE_UNWIND
 136 /* No need for remote debugging so turn on the &#39;local only&#39; optimizations in
 137  * libunwind */
 138 #define UNW_LOCAL_ONLY
 139 
 140 #include &lt;libunwind.h&gt;
 141 #include &lt;stdio.h&gt;
 142 #include &lt;stdlib.h&gt;
 143 #include &lt;string.h&gt;
 144 #include &lt;stdarg.h&gt;
 145 #include &lt;unistd.h&gt;
 146 #include &lt;errno.h&gt;
 147 
 148 #ifdef HAVE_DW
 149 #include &lt;elfutils/libdwfl.h&gt;
 150 #endif /* HAVE_DW */
 151 #endif /* HAVE_UNWIND */
 152 
 153 #ifdef HAVE_BACKTRACE
 154 #include &lt;execinfo.h&gt;
 155 #define BT_BUF_SIZE 100
 156 #endif /* HAVE_BACKTRACE */
 157 
 158 #ifdef HAVE_DBGHELP
 159 #include &lt;Windows.h&gt;
 160 #include &lt;dbghelp.h&gt;
 161 #include &lt;tlhelp32.h&gt;
 162 #endif /* HAVE_DBGHELP */
 163 
 164 extern gboolean gst_is_initialized (void);
 165 
 166 #ifdef GSTREAMER_LITE
 167 // For some reason it is not defined if GST_DISABLE_GST_DEBUG and
 168 // GST_REMOVE_DISABLED is defined which we do for GSTREAMER_LITE
 169 #ifdef GST_REMOVE_DISABLED
 170 void
 171 _priv_gst_debug_cleanup (void)
 172 {
 173 }
 174 #endif // GST_REMOVE_DISABLED
 175 #endif // GSTREAMER_LITE
 176 
 177 /* we want these symbols exported even if debug is disabled, to maintain
 178  * ABI compatibility. Unless GST_REMOVE_DISABLED is defined. */
 179 #if !defined(GST_DISABLE_GST_DEBUG) || !defined(GST_REMOVE_DISABLED)
 180 
 181 /* disabled by default, as soon as some threshold is set &gt; NONE,
 182  * it becomes enabled. */
 183 gboolean _gst_debug_enabled = FALSE;
 184 GstDebugLevel _gst_debug_min = GST_LEVEL_NONE;
 185 
 186 GstDebugCategory *GST_CAT_DEFAULT = NULL;
 187 
 188 GstDebugCategory *GST_CAT_GST_INIT = NULL;
 189 GstDebugCategory *GST_CAT_MEMORY = NULL;
 190 GstDebugCategory *GST_CAT_PARENTAGE = NULL;
 191 GstDebugCategory *GST_CAT_STATES = NULL;
 192 GstDebugCategory *GST_CAT_SCHEDULING = NULL;
 193 
 194 GstDebugCategory *GST_CAT_BUFFER = NULL;
 195 GstDebugCategory *GST_CAT_BUFFER_LIST = NULL;
 196 GstDebugCategory *GST_CAT_BUS = NULL;
 197 GstDebugCategory *GST_CAT_CAPS = NULL;
 198 GstDebugCategory *GST_CAT_CLOCK = NULL;
 199 GstDebugCategory *GST_CAT_ELEMENT_PADS = NULL;
 200 GstDebugCategory *GST_CAT_PADS = NULL;
 201 GstDebugCategory *GST_CAT_PERFORMANCE = NULL;
 202 GstDebugCategory *GST_CAT_PIPELINE = NULL;
 203 GstDebugCategory *GST_CAT_PLUGIN_LOADING = NULL;
 204 GstDebugCategory *GST_CAT_PLUGIN_INFO = NULL;
 205 GstDebugCategory *GST_CAT_PROPERTIES = NULL;
 206 GstDebugCategory *GST_CAT_NEGOTIATION = NULL;
 207 GstDebugCategory *GST_CAT_REFCOUNTING = NULL;
 208 GstDebugCategory *GST_CAT_ERROR_SYSTEM = NULL;
 209 GstDebugCategory *GST_CAT_EVENT = NULL;
 210 GstDebugCategory *GST_CAT_MESSAGE = NULL;
 211 GstDebugCategory *GST_CAT_PARAMS = NULL;
 212 GstDebugCategory *GST_CAT_CALL_TRACE = NULL;
 213 GstDebugCategory *GST_CAT_SIGNAL = NULL;
 214 GstDebugCategory *GST_CAT_PROBE = NULL;
 215 GstDebugCategory *GST_CAT_REGISTRY = NULL;
 216 GstDebugCategory *GST_CAT_QOS = NULL;
 217 GstDebugCategory *_priv_GST_CAT_POLL = NULL;
 218 GstDebugCategory *GST_CAT_META = NULL;
 219 GstDebugCategory *GST_CAT_LOCKING = NULL;
 220 GstDebugCategory *GST_CAT_CONTEXT = NULL;
 221 GstDebugCategory *_priv_GST_CAT_PROTECTION = NULL;
 222 
 223 
 224 #endif /* !defined(GST_DISABLE_GST_DEBUG) || !defined(GST_REMOVE_DISABLED) */
 225 
 226 #ifndef GST_DISABLE_GST_DEBUG
 227 
 228 /* underscore is to prevent conflict with GST_CAT_DEBUG define */
 229 GST_DEBUG_CATEGORY_STATIC (_GST_CAT_DEBUG);
 230 
 231 #if 0
 232 #if defined __sgi__
 233 #include &lt;rld_interface.h&gt;
 234 typedef struct DL_INFO
 235 {
 236   const char *dli_fname;
 237   void *dli_fbase;
 238   const char *dli_sname;
 239   void *dli_saddr;
 240   int dli_version;
 241   int dli_reserved1;
 242   long dli_reserved[4];
 243 }
 244 Dl_info;
 245 
 246 #define _RLD_DLADDR             14
 247 int dladdr (void *address, Dl_info * dl);
 248 
 249 int
 250 dladdr (void *address, Dl_info * dl)
 251 {
 252   void *v;
 253 
 254   v = _rld_new_interface (_RLD_DLADDR, address, dl);
 255   return (int) v;
 256 }
 257 #endif /* __sgi__ */
 258 #endif
 259 
 260 static void gst_debug_reset_threshold (gpointer category, gpointer unused);
 261 static void gst_debug_reset_all_thresholds (void);
 262 
 263 struct _GstDebugMessage
 264 {
 265   gchar *message;
 266   const gchar *format;
 267   va_list arguments;
 268 };
 269 
 270 /* list of all name/level pairs from --gst-debug and GST_DEBUG */
 271 static GMutex __level_name_mutex;
 272 static GSList *__level_name = NULL;
 273 typedef struct
 274 {
 275   GPatternSpec *pat;
 276   GstDebugLevel level;
 277 }
 278 LevelNameEntry;
 279 
 280 /* list of all categories */
 281 static GMutex __cat_mutex;
 282 static GSList *__categories = NULL;
 283 
 284 static GstDebugCategory *_gst_debug_get_category_locked (const gchar * name);
 285 
 286 
 287 /* all registered debug handlers */
 288 typedef struct
 289 {
 290   GstLogFunction func;
 291   gpointer user_data;
 292   GDestroyNotify notify;
 293 }
 294 LogFuncEntry;
 295 static GMutex __log_func_mutex;
 296 static GSList *__log_functions = NULL;
 297 
 298 /* whether to add the default log function in gst_init() */
 299 static gboolean add_default_log_func = TRUE;
 300 
 301 #define PRETTY_TAGS_DEFAULT  TRUE
 302 static gboolean pretty_tags = PRETTY_TAGS_DEFAULT;
 303 
 304 static volatile gint G_GNUC_MAY_ALIAS __default_level = GST_LEVEL_DEFAULT;
 305 static volatile gint G_GNUC_MAY_ALIAS __use_color = GST_DEBUG_COLOR_MODE_ON;
 306 
 307 /* FIXME: export this? */
 308 gboolean
 309 _priv_gst_in_valgrind (void)
 310 {
 311   static enum
 312   {
 313     GST_VG_UNCHECKED,
 314     GST_VG_NO_VALGRIND,
 315     GST_VG_INSIDE
 316   }
 317   in_valgrind = GST_VG_UNCHECKED;
 318 
 319   if (in_valgrind == GST_VG_UNCHECKED) {
 320 #ifdef HAVE_VALGRIND_VALGRIND_H
 321     if (RUNNING_ON_VALGRIND) {
 322       GST_CAT_INFO (GST_CAT_GST_INIT, &quot;we&#39;re running inside valgrind&quot;);
 323       in_valgrind = GST_VG_INSIDE;
 324     } else {
 325       GST_CAT_LOG (GST_CAT_GST_INIT, &quot;not doing extra valgrind stuff&quot;);
 326       in_valgrind = GST_VG_NO_VALGRIND;
 327     }
 328 #else
 329     in_valgrind = GST_VG_NO_VALGRIND;
 330 #endif
 331     g_assert (in_valgrind == GST_VG_NO_VALGRIND ||
 332         in_valgrind == GST_VG_INSIDE);
 333   }
 334   return (in_valgrind == GST_VG_INSIDE);
 335 }
 336 
 337 static gchar *
 338 _replace_pattern_in_gst_debug_file_name (gchar * name, const char *token,
 339     guint val)
 340 {
 341   gchar *token_start;
 342   if ((token_start = strstr (name, token))) {
 343     gsize token_len = strlen (token);
 344     gchar *name_prefix = name;
 345     gchar *name_suffix = token_start + token_len;
 346     token_start[0] = &#39;\0&#39;;
 347     name = g_strdup_printf (&quot;%s%u%s&quot;, name_prefix, val, name_suffix);
 348     g_free (name_prefix);
 349   }
 350   return name;
 351 }
 352 
 353 static gchar *
 354 _priv_gst_debug_file_name (const gchar * env)
 355 {
 356   gchar *name;
 357 
 358   name = g_strdup (env);
 359   name = _replace_pattern_in_gst_debug_file_name (name, &quot;%p&quot;, getpid ());
 360   name = _replace_pattern_in_gst_debug_file_name (name, &quot;%r&quot;, g_random_int ());
 361 
 362   return name;
 363 }
 364 
 365 /* Initialize the debugging system */
 366 void
 367 _priv_gst_debug_init (void)
 368 {
 369   const gchar *env;
 370   FILE *log_file;
 371 
 372   if (add_default_log_func) {
 373     env = g_getenv (&quot;GST_DEBUG_FILE&quot;);
 374     if (env != NULL &amp;&amp; *env != &#39;\0&#39;) {
 375       if (strcmp (env, &quot;-&quot;) == 0) {
 376         log_file = stdout;
 377       } else {
 378         gchar *name = _priv_gst_debug_file_name (env);
 379         log_file = g_fopen (name, &quot;w&quot;);
 380         g_free (name);
 381         if (log_file == NULL) {
 382           g_printerr (&quot;Could not open log file &#39;%s&#39; for writing: %s\n&quot;, env,
 383               g_strerror (errno));
 384           log_file = stderr;
 385         }
 386       }
 387     } else {
 388       log_file = stderr;
 389     }
 390 
 391     gst_debug_add_log_function (gst_debug_log_default, log_file, NULL);
 392   }
 393 
 394   __gst_printf_pointer_extension_set_func
 395       (gst_info_printf_pointer_extension_func);
 396 
 397   /* do NOT use a single debug function before this line has been run */
 398   GST_CAT_DEFAULT = _gst_debug_category_new (&quot;default&quot;,
 399       GST_DEBUG_UNDERLINE, NULL);
 400   _GST_CAT_DEBUG = _gst_debug_category_new (&quot;GST_DEBUG&quot;,
 401       GST_DEBUG_BOLD | GST_DEBUG_FG_YELLOW, &quot;debugging subsystem&quot;);
 402 
 403   /* FIXME: add descriptions here */
 404   GST_CAT_GST_INIT = _gst_debug_category_new (&quot;GST_INIT&quot;,
 405       GST_DEBUG_BOLD | GST_DEBUG_FG_RED, NULL);
 406   GST_CAT_MEMORY = _gst_debug_category_new (&quot;GST_MEMORY&quot;,
 407       GST_DEBUG_BOLD | GST_DEBUG_FG_BLUE, &quot;memory&quot;);
 408   GST_CAT_PARENTAGE = _gst_debug_category_new (&quot;GST_PARENTAGE&quot;,
 409       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 410   GST_CAT_STATES = _gst_debug_category_new (&quot;GST_STATES&quot;,
 411       GST_DEBUG_BOLD | GST_DEBUG_FG_RED, NULL);
 412   GST_CAT_SCHEDULING = _gst_debug_category_new (&quot;GST_SCHEDULING&quot;,
 413       GST_DEBUG_BOLD | GST_DEBUG_FG_MAGENTA, NULL);
 414   GST_CAT_BUFFER = _gst_debug_category_new (&quot;GST_BUFFER&quot;,
 415       GST_DEBUG_BOLD | GST_DEBUG_BG_GREEN, NULL);
 416   GST_CAT_BUFFER_LIST = _gst_debug_category_new (&quot;GST_BUFFER_LIST&quot;,
 417       GST_DEBUG_BOLD | GST_DEBUG_BG_GREEN, NULL);
 418   GST_CAT_BUS = _gst_debug_category_new (&quot;GST_BUS&quot;, GST_DEBUG_BG_YELLOW, NULL);
 419   GST_CAT_CAPS = _gst_debug_category_new (&quot;GST_CAPS&quot;,
 420       GST_DEBUG_BOLD | GST_DEBUG_FG_BLUE, NULL);
 421   GST_CAT_CLOCK = _gst_debug_category_new (&quot;GST_CLOCK&quot;,
 422       GST_DEBUG_BOLD | GST_DEBUG_FG_YELLOW, NULL);
 423   GST_CAT_ELEMENT_PADS = _gst_debug_category_new (&quot;GST_ELEMENT_PADS&quot;,
 424       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 425   GST_CAT_PADS = _gst_debug_category_new (&quot;GST_PADS&quot;,
 426       GST_DEBUG_BOLD | GST_DEBUG_FG_RED | GST_DEBUG_BG_BLUE, NULL);
 427   GST_CAT_PERFORMANCE = _gst_debug_category_new (&quot;GST_PERFORMANCE&quot;,
 428       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 429   GST_CAT_PIPELINE = _gst_debug_category_new (&quot;GST_PIPELINE&quot;,
 430       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 431   GST_CAT_PLUGIN_LOADING = _gst_debug_category_new (&quot;GST_PLUGIN_LOADING&quot;,
 432       GST_DEBUG_BOLD | GST_DEBUG_FG_CYAN, NULL);
 433   GST_CAT_PLUGIN_INFO = _gst_debug_category_new (&quot;GST_PLUGIN_INFO&quot;,
 434       GST_DEBUG_BOLD | GST_DEBUG_FG_CYAN, NULL);
 435   GST_CAT_PROPERTIES = _gst_debug_category_new (&quot;GST_PROPERTIES&quot;,
 436       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_BLUE, NULL);
 437   GST_CAT_NEGOTIATION = _gst_debug_category_new (&quot;GST_NEGOTIATION&quot;,
 438       GST_DEBUG_BOLD | GST_DEBUG_FG_BLUE, NULL);
 439   GST_CAT_REFCOUNTING = _gst_debug_category_new (&quot;GST_REFCOUNTING&quot;,
 440       GST_DEBUG_BOLD | GST_DEBUG_FG_RED | GST_DEBUG_BG_BLUE, NULL);
 441   GST_CAT_ERROR_SYSTEM = _gst_debug_category_new (&quot;GST_ERROR_SYSTEM&quot;,
 442       GST_DEBUG_BOLD | GST_DEBUG_FG_RED | GST_DEBUG_BG_WHITE, NULL);
 443 
 444   GST_CAT_EVENT = _gst_debug_category_new (&quot;GST_EVENT&quot;,
 445       GST_DEBUG_BOLD | GST_DEBUG_FG_BLUE, NULL);
 446   GST_CAT_MESSAGE = _gst_debug_category_new (&quot;GST_MESSAGE&quot;,
 447       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 448   GST_CAT_PARAMS = _gst_debug_category_new (&quot;GST_PARAMS&quot;,
 449       GST_DEBUG_BOLD | GST_DEBUG_FG_BLACK | GST_DEBUG_BG_YELLOW, NULL);
 450   GST_CAT_CALL_TRACE = _gst_debug_category_new (&quot;GST_CALL_TRACE&quot;,
 451       GST_DEBUG_BOLD, NULL);
 452   GST_CAT_SIGNAL = _gst_debug_category_new (&quot;GST_SIGNAL&quot;,
 453       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
 454   GST_CAT_PROBE = _gst_debug_category_new (&quot;GST_PROBE&quot;,
 455       GST_DEBUG_BOLD | GST_DEBUG_FG_GREEN, &quot;pad probes&quot;);
 456   GST_CAT_REGISTRY = _gst_debug_category_new (&quot;GST_REGISTRY&quot;, 0, &quot;registry&quot;);
 457   GST_CAT_QOS = _gst_debug_category_new (&quot;GST_QOS&quot;, 0, &quot;QoS&quot;);
 458   _priv_GST_CAT_POLL = _gst_debug_category_new (&quot;GST_POLL&quot;, 0, &quot;poll&quot;);
 459   GST_CAT_META = _gst_debug_category_new (&quot;GST_META&quot;, 0, &quot;meta&quot;);
 460   GST_CAT_LOCKING = _gst_debug_category_new (&quot;GST_LOCKING&quot;, 0, &quot;locking&quot;);
 461   GST_CAT_CONTEXT = _gst_debug_category_new (&quot;GST_CONTEXT&quot;, 0, NULL);
 462   _priv_GST_CAT_PROTECTION =
 463       _gst_debug_category_new (&quot;GST_PROTECTION&quot;, 0, &quot;protection&quot;);
 464 
 465   /* print out the valgrind message if we&#39;re in valgrind */
 466   _priv_gst_in_valgrind ();
 467 
 468   env = g_getenv (&quot;GST_DEBUG_OPTIONS&quot;);
 469   if (env != NULL) {
 470     if (strstr (env, &quot;full_tags&quot;) || strstr (env, &quot;full-tags&quot;))
 471       pretty_tags = FALSE;
 472     else if (strstr (env, &quot;pretty_tags&quot;) || strstr (env, &quot;pretty-tags&quot;))
 473       pretty_tags = TRUE;
 474   }
 475 
 476   if (g_getenv (&quot;GST_DEBUG_NO_COLOR&quot;) != NULL)
 477     gst_debug_set_color_mode (GST_DEBUG_COLOR_MODE_OFF);
 478   env = g_getenv (&quot;GST_DEBUG_COLOR_MODE&quot;);
 479   if (env)
 480     gst_debug_set_color_mode_from_string (env);
 481 
 482   env = g_getenv (&quot;GST_DEBUG&quot;);
 483   if (env)
 484     gst_debug_set_threshold_from_string (env, FALSE);
 485 }
 486 
 487 /* we can&#39;t do this further above, because we initialize the GST_CAT_DEFAULT struct */
 488 #define GST_CAT_DEFAULT _GST_CAT_DEBUG
 489 
 490 /**
 491  * gst_debug_log:
 492  * @category: category to log
 493  * @level: level of the message is in
 494  * @file: the file that emitted the message, usually the __FILE__ identifier
 495  * @function: the function that emitted the message
 496  * @line: the line from that the message was emitted, usually __LINE__
 497  * @object: (transfer none) (allow-none): the object this message relates to,
 498  *     or %NULL if none
 499  * @format: a printf style format string
 500  * @...: optional arguments for the format
 501  *
 502  * Logs the given message using the currently registered debugging handlers.
 503  */
 504 void
 505 gst_debug_log (GstDebugCategory * category, GstDebugLevel level,
 506     const gchar * file, const gchar * function, gint line,
 507     GObject * object, const gchar * format, ...)
 508 {
 509   va_list var_args;
 510 
 511   va_start (var_args, format);
 512   gst_debug_log_valist (category, level, file, function, line, object, format,
 513       var_args);
 514   va_end (var_args);
 515 }
 516 
 517 /* based on g_basename(), which we can&#39;t use because it was deprecated */
 518 static inline const gchar *
 519 gst_path_basename (const gchar * file_name)
 520 {
 521   register const gchar *base;
 522 
 523   base = strrchr (file_name, G_DIR_SEPARATOR);
 524 
 525   {
 526     const gchar *q = strrchr (file_name, &#39;/&#39;);
 527     if (base == NULL || (q != NULL &amp;&amp; q &gt; base))
 528       base = q;
 529   }
 530 
 531   if (base)
 532     return base + 1;
 533 
 534   if (g_ascii_isalpha (file_name[0]) &amp;&amp; file_name[1] == &#39;:&#39;)
 535     return file_name + 2;
 536 
 537   return file_name;
 538 }
 539 
 540 /**
 541  * gst_debug_log_valist:
 542  * @category: category to log
 543  * @level: level of the message is in
 544  * @file: the file that emitted the message, usually the __FILE__ identifier
 545  * @function: the function that emitted the message
 546  * @line: the line from that the message was emitted, usually __LINE__
 547  * @object: (transfer none) (allow-none): the object this message relates to,
 548  *     or %NULL if none
 549  * @format: a printf style format string
 550  * @args: optional arguments for the format
 551  *
 552  * Logs the given message using the currently registered debugging handlers.
 553  */
 554 void
 555 gst_debug_log_valist (GstDebugCategory * category, GstDebugLevel level,
 556     const gchar * file, const gchar * function, gint line,
 557     GObject * object, const gchar * format, va_list args)
 558 {
 559   GstDebugMessage message;
 560   LogFuncEntry *entry;
 561   GSList *handler;
 562 
 563   g_return_if_fail (category != NULL);
 564 
 565   if (level &gt; gst_debug_category_get_threshold (category))
 566     return;
 567 
 568   g_return_if_fail (file != NULL);
 569   g_return_if_fail (function != NULL);
 570   g_return_if_fail (format != NULL);
 571 
 572   message.message = NULL;
 573   message.format = format;
 574   G_VA_COPY (message.arguments, args);
 575 
 576   handler = __log_functions;
 577   while (handler) {
 578     entry = handler-&gt;data;
 579     handler = g_slist_next (handler);
 580     entry-&gt;func (category, level, file, function, line, object, &amp;message,
 581         entry-&gt;user_data);
 582   }
 583   g_free (message.message);
 584   va_end (message.arguments);
 585 }
 586 
 587 /**
 588  * gst_debug_message_get:
 589  * @message: a debug message
 590  *
 591  * Gets the string representation of a #GstDebugMessage. This function is used
 592  * in debug handlers to extract the message.
 593  *
 594  * Returns: (nullable): the string representation of a #GstDebugMessage.
 595  */
 596 const gchar *
 597 gst_debug_message_get (GstDebugMessage * message)
 598 {
 599   if (message-&gt;message == NULL) {
 600     int len;
 601 
 602     len = __gst_vasprintf (&amp;message-&gt;message, message-&gt;format,
 603         message-&gt;arguments);
 604 
 605     if (len &lt; 0)
 606       message-&gt;message = NULL;
 607   }
 608   return message-&gt;message;
 609 }
 610 
 611 #define MAX_BUFFER_DUMP_STRING_LEN  100
 612 
 613 /* structure_to_pretty_string:
 614  * @str: a serialized #GstStructure
 615  *
 616  * If the serialized structure contains large buffers such as images the hex
 617  * representation of those buffers will be shortened so that the string remains
 618  * readable.
 619  *
 620  * Returns: the filtered string
 621  */
 622 static gchar *
 623 prettify_structure_string (gchar * str)
 624 {
 625   gchar *pos = str, *end;
 626 
 627   while ((pos = strstr (pos, &quot;(buffer)&quot;))) {
 628     guint count = 0;
 629 
 630     pos += strlen (&quot;(buffer)&quot;);
 631     for (end = pos; *end != &#39;\0&#39; &amp;&amp; *end != &#39;;&#39; &amp;&amp; *end != &#39; &#39;; ++end)
 632       ++count;
 633     if (count &gt; MAX_BUFFER_DUMP_STRING_LEN) {
 634       memcpy (pos + MAX_BUFFER_DUMP_STRING_LEN - 6, &quot;..&quot;, 2);
 635       memcpy (pos + MAX_BUFFER_DUMP_STRING_LEN - 4, pos + count - 4, 4);
 636       memmove (pos + MAX_BUFFER_DUMP_STRING_LEN, pos + count,
 637           strlen (pos + count) + 1);
 638       pos += MAX_BUFFER_DUMP_STRING_LEN;
 639     }
 640   }
 641 
 642   return str;
 643 }
 644 
 645 static inline gchar *
 646 gst_info_structure_to_string (const GstStructure * s)
 647 {
 648   if (G_LIKELY (s)) {
 649     gchar *str = gst_structure_to_string (s);
 650     if (G_UNLIKELY (pretty_tags &amp;&amp; s-&gt;name == GST_QUARK (TAGLIST)))
 651       return prettify_structure_string (str);
 652     else
 653       return str;
 654   }
 655   return NULL;
 656 }
 657 
 658 static inline gchar *
 659 gst_info_describe_buffer (GstBuffer * buffer)
 660 {
 661   const gchar *offset_str = &quot;none&quot;;
 662   const gchar *offset_end_str = &quot;none&quot;;
 663   gchar offset_buf[32], offset_end_buf[32];
 664 
 665   if (GST_BUFFER_OFFSET_IS_VALID (buffer)) {
 666     g_snprintf (offset_buf, sizeof (offset_buf), &quot;%&quot; G_GUINT64_FORMAT,
 667         GST_BUFFER_OFFSET (buffer));
 668     offset_str = offset_buf;
 669   }
 670   if (GST_BUFFER_OFFSET_END_IS_VALID (buffer)) {
 671     g_snprintf (offset_end_buf, sizeof (offset_end_buf), &quot;%&quot; G_GUINT64_FORMAT,
 672         GST_BUFFER_OFFSET_END (buffer));
 673     offset_end_str = offset_end_buf;
 674   }
 675 
 676   return g_strdup_printf (&quot;buffer: %p, pts %&quot; GST_TIME_FORMAT &quot;, dts %&quot;
 677       GST_TIME_FORMAT &quot;, dur %&quot; GST_TIME_FORMAT &quot;, size %&quot; G_GSIZE_FORMAT
 678       &quot;, offset %s, offset_end %s, flags 0x%x&quot;, buffer,
 679       GST_TIME_ARGS (GST_BUFFER_PTS (buffer)),
 680       GST_TIME_ARGS (GST_BUFFER_DTS (buffer)),
 681       GST_TIME_ARGS (GST_BUFFER_DURATION (buffer)),
 682       gst_buffer_get_size (buffer), offset_str, offset_end_str,
 683       GST_BUFFER_FLAGS (buffer));
 684 }
 685 
 686 static inline gchar *
 687 gst_info_describe_buffer_list (GstBufferList * list)
 688 {
 689   GstClockTime pts = GST_CLOCK_TIME_NONE;
 690   GstClockTime dts = GST_CLOCK_TIME_NONE;
 691   gsize total_size = 0;
 692   guint n, i;
 693 
 694   n = gst_buffer_list_length (list);
 695   for (i = 0; i &lt; n; ++i) {
 696     GstBuffer *buf = gst_buffer_list_get (list, i);
 697 
 698     if (i == 0) {
 699       pts = GST_BUFFER_PTS (buf);
 700       dts = GST_BUFFER_DTS (buf);
 701     }
 702 
 703     total_size += gst_buffer_get_size (buf);
 704   }
 705 
 706   return g_strdup_printf (&quot;bufferlist: %p, %u buffers, pts %&quot; GST_TIME_FORMAT
 707       &quot;, dts %&quot; GST_TIME_FORMAT &quot;, size %&quot; G_GSIZE_FORMAT, list, n,
 708       GST_TIME_ARGS (pts), GST_TIME_ARGS (dts), total_size);
 709 }
 710 
 711 static inline gchar *
 712 gst_info_describe_event (GstEvent * event)
 713 {
 714   gchar *s, *ret;
 715 
 716   s = gst_info_structure_to_string (gst_event_get_structure (event));
 717   ret = g_strdup_printf (&quot;%s event: %p, time %&quot; GST_TIME_FORMAT
 718       &quot;, seq-num %d, %s&quot;, GST_EVENT_TYPE_NAME (event), event,
 719       GST_TIME_ARGS (GST_EVENT_TIMESTAMP (event)), GST_EVENT_SEQNUM (event),
 720       (s ? s : &quot;(NULL)&quot;));
 721   g_free (s);
 722   return ret;
 723 }
 724 
 725 static inline gchar *
 726 gst_info_describe_message (GstMessage * message)
 727 {
 728   gchar *s, *ret;
 729 
 730   s = gst_info_structure_to_string (gst_message_get_structure (message));
 731   ret = g_strdup_printf (&quot;%s message: %p, time %&quot; GST_TIME_FORMAT
 732       &quot;, seq-num %d, element &#39;%s&#39;, %s&quot;, GST_MESSAGE_TYPE_NAME (message),
 733       message, GST_TIME_ARGS (GST_MESSAGE_TIMESTAMP (message)),
 734       GST_MESSAGE_SEQNUM (message),
 735       ((message-&gt;src) ? GST_ELEMENT_NAME (message-&gt;src) : &quot;(NULL)&quot;),
 736       (s ? s : &quot;(NULL)&quot;));
 737   g_free (s);
 738   return ret;
 739 }
 740 
 741 static inline gchar *
 742 gst_info_describe_query (GstQuery * query)
 743 {
 744   gchar *s, *ret;
 745 
 746   s = gst_info_structure_to_string (gst_query_get_structure (query));
 747   ret = g_strdup_printf (&quot;%s query: %p, %s&quot;, GST_QUERY_TYPE_NAME (query),
 748       query, (s ? s : &quot;(NULL)&quot;));
 749   g_free (s);
 750   return ret;
 751 }
 752 
 753 static inline gchar *
 754 gst_info_describe_stream (GstStream * stream)
 755 {
 756   gchar *ret, *caps_str = NULL, *tags_str = NULL;
 757   GstCaps *caps;
 758   GstTagList *tags;
 759 
 760   caps = gst_stream_get_caps (stream);
 761   if (caps) {
 762     caps_str = gst_caps_to_string (caps);
 763     gst_caps_unref (caps);
 764   }
 765 
 766   tags = gst_stream_get_tags (stream);
 767   if (tags) {
 768     tags_str = gst_tag_list_to_string (tags);
 769     gst_tag_list_unref (tags);
 770   }
 771 
 772   ret =
 773       g_strdup_printf (&quot;stream %s %p, ID %s, flags 0x%x, caps [%s], tags [%s]&quot;,
 774       gst_stream_type_get_name (gst_stream_get_stream_type (stream)), stream,
 775       gst_stream_get_stream_id (stream), gst_stream_get_stream_flags (stream),
 776       caps_str ? caps_str : &quot;&quot;, tags_str ? tags_str : &quot;&quot;);
 777 
 778   g_free (caps_str);
 779   g_free (tags_str);
 780 
 781   return ret;
 782 }
 783 
 784 static inline gchar *
 785 gst_info_describe_stream_collection (GstStreamCollection * collection)
 786 {
 787   gchar *ret;
 788   GString *streams_str;
 789   guint i;
 790 
 791   streams_str = g_string_new (&quot;&lt;&quot;);
 792   for (i = 0; i &lt; gst_stream_collection_get_size (collection); i++) {
 793     GstStream *stream = gst_stream_collection_get_stream (collection, i);
 794     gchar *s;
 795 
 796     s = gst_info_describe_stream (stream);
 797     g_string_append_printf (streams_str, &quot; %s,&quot;, s);
 798     g_free (s);
 799   }
 800   g_string_append (streams_str, &quot; &gt;&quot;);
 801 
 802   ret = g_strdup_printf (&quot;collection %p (%d streams) %s&quot;, collection,
 803       gst_stream_collection_get_size (collection), streams_str-&gt;str);
 804 
 805   g_string_free (streams_str, TRUE);
 806   return ret;
 807 }
 808 
 809 static gchar *
 810 gst_debug_print_object (gpointer ptr)
 811 {
 812   GObject *object = (GObject *) ptr;
 813 
 814 #ifdef unused
 815   /* This is a cute trick to detect unmapped memory, but is unportable,
 816    * slow, screws around with madvise, and not actually that useful. */
 817   {
 818     int ret;
 819 
 820     ret = madvise ((void *) ((unsigned long) ptr &amp; (~0xfff)), 4096, 0);
 821     if (ret == -1 &amp;&amp; errno == ENOMEM) {
 822       buffer = g_strdup_printf (&quot;%p (unmapped memory)&quot;, ptr);
 823     }
 824   }
 825 #endif
 826 
 827   /* nicely printed object */
 828   if (object == NULL) {
 829     return g_strdup (&quot;(NULL)&quot;);
 830   }
 831   if (GST_IS_CAPS (ptr)) {
 832     return gst_caps_to_string ((const GstCaps *) ptr);
 833   }
 834   if (GST_IS_STRUCTURE (ptr)) {
 835     return gst_info_structure_to_string ((const GstStructure *) ptr);
 836   }
 837   if (*(GType *) ptr == GST_TYPE_CAPS_FEATURES) {
 838     return gst_caps_features_to_string ((const GstCapsFeatures *) ptr);
 839   }
 840   if (GST_IS_TAG_LIST (ptr)) {
 841     gchar *str = gst_tag_list_to_string ((GstTagList *) ptr);
 842     if (G_UNLIKELY (pretty_tags))
 843       return prettify_structure_string (str);
 844     else
 845       return str;
 846   }
 847   if (*(GType *) ptr == GST_TYPE_DATE_TIME) {
 848     return __gst_date_time_serialize ((GstDateTime *) ptr, TRUE);
 849   }
 850   if (GST_IS_BUFFER (ptr)) {
 851     return gst_info_describe_buffer (GST_BUFFER_CAST (ptr));
 852   }
 853   if (GST_IS_BUFFER_LIST (ptr)) {
 854     return gst_info_describe_buffer_list (GST_BUFFER_LIST_CAST (ptr));
 855   }
 856 #ifdef USE_POISONING
 857   if (*(guint32 *) ptr == 0xffffffff) {
 858     return g_strdup_printf (&quot;&lt;poisoned@%p&gt;&quot;, ptr);
 859   }
 860 #endif
 861   if (GST_IS_MESSAGE (object)) {
 862     return gst_info_describe_message (GST_MESSAGE_CAST (object));
 863   }
 864   if (GST_IS_QUERY (object)) {
 865     return gst_info_describe_query (GST_QUERY_CAST (object));
 866   }
 867   if (GST_IS_EVENT (object)) {
 868     return gst_info_describe_event (GST_EVENT_CAST (object));
 869   }
 870   if (GST_IS_CONTEXT (object)) {
 871     GstContext *context = GST_CONTEXT_CAST (object);
 872     gchar *s, *ret;
 873     const gchar *type;
 874     const GstStructure *structure;
 875 
 876     type = gst_context_get_context_type (context);
 877     structure = gst_context_get_structure (context);
 878 
 879     s = gst_info_structure_to_string (structure);
 880 
 881     ret = g_strdup_printf (&quot;context &#39;%s&#39;=&#39;%s&#39;&quot;, type, s);
 882     g_free (s);
 883     return ret;
 884   }
 885   if (GST_IS_STREAM (object)) {
 886     return gst_info_describe_stream (GST_STREAM_CAST (object));
 887   }
 888   if (GST_IS_STREAM_COLLECTION (object)) {
 889     return
 890         gst_info_describe_stream_collection (GST_STREAM_COLLECTION_CAST
 891         (object));
 892   }
 893   if (GST_IS_PAD (object) &amp;&amp; GST_OBJECT_NAME (object)) {
 894     return g_strdup_printf (&quot;&lt;%s:%s&gt;&quot;, GST_DEBUG_PAD_NAME (object));
 895   }
 896   if (GST_IS_OBJECT (object) &amp;&amp; GST_OBJECT_NAME (object)) {
 897     return g_strdup_printf (&quot;&lt;%s&gt;&quot;, GST_OBJECT_NAME (object));
 898   }
 899   if (G_IS_OBJECT (object)) {
 900     return g_strdup_printf (&quot;&lt;%s@%p&gt;&quot;, G_OBJECT_TYPE_NAME (object), object);
 901   }
 902 
 903   return g_strdup_printf (&quot;%p&quot;, ptr);
 904 }
 905 
 906 static gchar *
 907 gst_debug_print_segment (gpointer ptr)
 908 {
 909   GstSegment *segment = (GstSegment *) ptr;
 910 
 911   /* nicely printed segment */
 912   if (segment == NULL) {
 913     return g_strdup (&quot;(NULL)&quot;);
 914   }
 915 
 916   switch (segment-&gt;format) {
 917     case GST_FORMAT_UNDEFINED:{
 918       return g_strdup_printf (&quot;UNDEFINED segment&quot;);
 919     }
 920     case GST_FORMAT_TIME:{
 921       return g_strdup_printf (&quot;time segment start=%&quot; GST_TIME_FORMAT
 922           &quot;, offset=%&quot; GST_TIME_FORMAT &quot;, stop=%&quot; GST_TIME_FORMAT
 923           &quot;, rate=%f, applied_rate=%f&quot; &quot;, flags=0x%02x, time=%&quot; GST_TIME_FORMAT
 924           &quot;, base=%&quot; GST_TIME_FORMAT &quot;, position %&quot; GST_TIME_FORMAT
 925           &quot;, duration %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (segment-&gt;start),
 926           GST_TIME_ARGS (segment-&gt;offset), GST_TIME_ARGS (segment-&gt;stop),
 927           segment-&gt;rate, segment-&gt;applied_rate, (guint) segment-&gt;flags,
 928           GST_TIME_ARGS (segment-&gt;time), GST_TIME_ARGS (segment-&gt;base),
 929           GST_TIME_ARGS (segment-&gt;position), GST_TIME_ARGS (segment-&gt;duration));
 930     }
 931     default:{
 932       const gchar *format_name;
 933 
 934       format_name = gst_format_get_name (segment-&gt;format);
 935       if (G_UNLIKELY (format_name == NULL))
 936         format_name = &quot;(UNKNOWN FORMAT)&quot;;
 937       return g_strdup_printf (&quot;%s segment start=%&quot; G_GINT64_FORMAT
 938           &quot;, offset=%&quot; G_GINT64_FORMAT &quot;, stop=%&quot; G_GINT64_FORMAT
 939           &quot;, rate=%f, applied_rate=%f&quot; &quot;, flags=0x%02x, time=%&quot; G_GINT64_FORMAT
 940           &quot;, base=%&quot; G_GINT64_FORMAT &quot;, position %&quot; G_GINT64_FORMAT
 941           &quot;, duration %&quot; G_GINT64_FORMAT, format_name, segment-&gt;start,
 942           segment-&gt;offset, segment-&gt;stop, segment-&gt;rate, segment-&gt;applied_rate,
 943           (guint) segment-&gt;flags, segment-&gt;time, segment-&gt;base,
 944           segment-&gt;position, segment-&gt;duration);
 945     }
 946   }
 947 }
 948 
 949 static char *
 950 gst_info_printf_pointer_extension_func (const char *format, void *ptr)
 951 {
 952   char *s = NULL;
 953 
 954   if (format[0] == &#39;p&#39; &amp;&amp; format[1] == &#39;\a&#39;) {
 955     switch (format[2]) {
 956       case &#39;A&#39;:                /* GST_PTR_FORMAT     */
 957         s = gst_debug_print_object (ptr);
 958         break;
 959       case &#39;B&#39;:                /* GST_SEGMENT_FORMAT */
 960         s = gst_debug_print_segment (ptr);
 961         break;
 962       case &#39;a&#39;:                /* GST_WRAPPED_PTR_FORMAT */
 963         s = priv_gst_string_take_and_wrap (gst_debug_print_object (ptr));
 964         break;
 965       default:
 966         /* must have been compiled against a newer version with an extension
 967          * we don&#39;t known about yet - just ignore and fallback to %p below */
 968         break;
 969     }
 970   }
 971   if (s == NULL)
 972     s = g_strdup_printf (&quot;%p&quot;, ptr);
 973 
 974   return s;
 975 }
 976 
 977 /**
 978  * gst_debug_construct_term_color:
 979  * @colorinfo: the color info
 980  *
 981  * Constructs a string that can be used for getting the desired color in color
 982  * terminals.
 983  * You need to free the string after use.
 984  *
 985  * Returns: (transfer full) (type gchar*): a string containing the color
 986  *     definition
 987  */
 988 gchar *
 989 gst_debug_construct_term_color (guint colorinfo)
 990 {
 991   GString *color;
 992 
 993   color = g_string_new (&quot;\033[00&quot;);
 994 
 995   if (colorinfo &amp; GST_DEBUG_BOLD) {
 996     g_string_append_len (color, &quot;;01&quot;, 3);
 997   }
 998   if (colorinfo &amp; GST_DEBUG_UNDERLINE) {
 999     g_string_append_len (color, &quot;;04&quot;, 3);
1000   }
1001   if (colorinfo &amp; GST_DEBUG_FG_MASK) {
1002     g_string_append_printf (color, &quot;;3%1d&quot;, colorinfo &amp; GST_DEBUG_FG_MASK);
1003   }
1004   if (colorinfo &amp; GST_DEBUG_BG_MASK) {
1005     g_string_append_printf (color, &quot;;4%1d&quot;,
1006         (colorinfo &amp; GST_DEBUG_BG_MASK) &gt;&gt; 4);
1007   }
1008   g_string_append_c (color, &#39;m&#39;);
1009 
1010   return g_string_free (color, FALSE);
1011 }
1012 
1013 /**
1014  * gst_debug_construct_win_color:
1015  * @colorinfo: the color info
1016  *
1017  * Constructs an integer that can be used for getting the desired color in
1018  * windows&#39; terminals (cmd.exe). As there is no mean to underline, we simply
1019  * ignore this attribute.
1020  *
1021  * This function returns 0 on non-windows machines.
1022  *
1023  * Returns: an integer containing the color definition
1024  */
1025 gint
1026 gst_debug_construct_win_color (guint colorinfo)
1027 {
1028   gint color = 0;
1029 #ifdef G_OS_WIN32
1030   static const guchar ansi_to_win_fg[8] = {
1031     0,                          /* black   */
1032     FOREGROUND_RED,             /* red     */
1033     FOREGROUND_GREEN,           /* green   */
1034     FOREGROUND_RED | FOREGROUND_GREEN,  /* yellow  */
1035     FOREGROUND_BLUE,            /* blue    */
1036     FOREGROUND_RED | FOREGROUND_BLUE,   /* magenta */
1037     FOREGROUND_GREEN | FOREGROUND_BLUE, /* cyan    */
1038     FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE /* white   */
1039   };
1040   static const guchar ansi_to_win_bg[8] = {
1041     0,
1042     BACKGROUND_RED,
1043     BACKGROUND_GREEN,
1044     BACKGROUND_RED | BACKGROUND_GREEN,
1045     BACKGROUND_BLUE,
1046     BACKGROUND_RED | BACKGROUND_BLUE,
1047     BACKGROUND_GREEN | FOREGROUND_BLUE,
1048     BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE
1049   };
1050 
1051   /* we draw black as white, as cmd.exe can only have black bg */
1052   if ((colorinfo &amp; (GST_DEBUG_FG_MASK | GST_DEBUG_BG_MASK)) == 0) {
1053     color = ansi_to_win_fg[7];
1054   }
1055   if (colorinfo &amp; GST_DEBUG_UNDERLINE) {
1056     color |= BACKGROUND_INTENSITY;
1057   }
1058   if (colorinfo &amp; GST_DEBUG_BOLD) {
1059     color |= FOREGROUND_INTENSITY;
1060   }
1061   if (colorinfo &amp; GST_DEBUG_FG_MASK) {
1062     color |= ansi_to_win_fg[colorinfo &amp; GST_DEBUG_FG_MASK];
1063   }
1064   if (colorinfo &amp; GST_DEBUG_BG_MASK) {
1065     color |= ansi_to_win_bg[(colorinfo &amp; GST_DEBUG_BG_MASK) &gt;&gt; 4];
1066   }
1067 #endif
1068   return color;
1069 }
1070 
1071 /* width of %p varies depending on actual value of pointer, which can make
1072  * output unevenly aligned if multiple threads are involved, hence the %14p
1073  * (should really be %18p, but %14p seems a good compromise between too many
1074  * white spaces and likely unalignment on my system) */
1075 #if defined (GLIB_SIZEOF_VOID_P) &amp;&amp; GLIB_SIZEOF_VOID_P == 8
1076 #define PTR_FMT &quot;%14p&quot;
1077 #else
1078 #define PTR_FMT &quot;%10p&quot;
1079 #endif
1080 #define PID_FMT &quot;%5d&quot;
1081 #define CAT_FMT &quot;%20s %s:%d:%s:%s&quot;
1082 
1083 #ifdef G_OS_WIN32
1084 static const guchar levelcolormap_w32[GST_LEVEL_COUNT] = {
1085   /* GST_LEVEL_NONE */
1086   FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
1087   /* GST_LEVEL_ERROR */
1088   FOREGROUND_RED | FOREGROUND_INTENSITY,
1089   /* GST_LEVEL_WARNING */
1090   FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY,
1091   /* GST_LEVEL_INFO */
1092   FOREGROUND_GREEN | FOREGROUND_INTENSITY,
1093   /* GST_LEVEL_DEBUG */
1094   FOREGROUND_GREEN | FOREGROUND_BLUE,
1095   /* GST_LEVEL_LOG */
1096   FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
1097   /* GST_LEVEL_FIXME */
1098   FOREGROUND_RED | FOREGROUND_GREEN,
1099   /* GST_LEVEL_TRACE */
1100   FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE,
1101   /* placeholder for log level 8 */
1102   0,
1103   /* GST_LEVEL_MEMDUMP */
1104   FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE
1105 };
1106 
1107 static const guchar available_colors[] = {
1108   FOREGROUND_RED, FOREGROUND_GREEN, FOREGROUND_RED | FOREGROUND_GREEN,
1109   FOREGROUND_BLUE, FOREGROUND_RED | FOREGROUND_BLUE,
1110   FOREGROUND_GREEN | FOREGROUND_BLUE,
1111 };
1112 #endif /* G_OS_WIN32 */
1113 static const gchar *levelcolormap[GST_LEVEL_COUNT] = {
1114   &quot;\033[37m&quot;,                   /* GST_LEVEL_NONE */
1115   &quot;\033[31;01m&quot;,                /* GST_LEVEL_ERROR */
1116   &quot;\033[33;01m&quot;,                /* GST_LEVEL_WARNING */
1117   &quot;\033[32;01m&quot;,                /* GST_LEVEL_INFO */
1118   &quot;\033[36m&quot;,                   /* GST_LEVEL_DEBUG */
1119   &quot;\033[37m&quot;,                   /* GST_LEVEL_LOG */
1120   &quot;\033[33;01m&quot;,                /* GST_LEVEL_FIXME */
1121   &quot;\033[37m&quot;,                   /* GST_LEVEL_TRACE */
1122   &quot;\033[37m&quot;,                   /* placeholder for log level 8 */
1123   &quot;\033[37m&quot;                    /* GST_LEVEL_MEMDUMP */
1124 };
1125 
1126 /**
1127  * gst_debug_log_default:
1128  * @category: category to log
1129  * @level: level of the message
1130  * @file: the file that emitted the message, usually the __FILE__ identifier
1131  * @function: the function that emitted the message
1132  * @line: the line from that the message was emitted, usually __LINE__
1133  * @message: the actual message
1134  * @object: (transfer none) (allow-none): the object this message relates to,
1135  *     or %NULL if none
1136  * @user_data: the FILE* to log to
1137  *
1138  * The default logging handler used by GStreamer. Logging functions get called
1139  * whenever a macro like GST_DEBUG or similar is used. By default this function
1140  * is setup to output the message and additional info to stderr (or the log file
1141  * specified via the GST_DEBUG_FILE environment variable) as received via
1142  * @user_data.
1143  *
1144  * You can add other handlers by using gst_debug_add_log_function().
1145  * And you can remove this handler by calling
1146  * gst_debug_remove_log_function(gst_debug_log_default);
1147  */
1148 void
1149 gst_debug_log_default (GstDebugCategory * category, GstDebugLevel level,
1150     const gchar * file, const gchar * function, gint line,
1151     GObject * object, GstDebugMessage * message, gpointer user_data)
1152 {
1153   gint pid;
1154   GstClockTime elapsed;
1155   gchar *obj = NULL;
1156   GstDebugColorMode color_mode;
1157   const gchar *message_str;
1158   FILE *log_file = user_data ? user_data : stderr;
1159   gchar c;
1160 
1161   /* Get message string first because printing it might call into our custom
1162    * printf format extension mechanism which in turn might log something, e.g.
1163    * from inside gst_structure_to_string() when something can&#39;t be serialised.
1164    * This means we either need to do this outside of any critical section or
1165    * use a recursive lock instead. As we always need the message string in all
1166    * code paths, we might just as well get it here first thing and outside of
1167    * the win_print_mutex critical section. */
1168   message_str = gst_debug_message_get (message);
1169 
1170   /* __FILE__ might be a file name or an absolute path or a
1171    * relative path, irrespective of the exact compiler used,
1172    * in which case we want to shorten it to the filename for
1173    * readability. */
1174   c = file[0];
1175   if (c == &#39;.&#39; || c == &#39;/&#39; || c == &#39;\\&#39; || (c != &#39;\0&#39; &amp;&amp; file[1] == &#39;:&#39;)) {
1176     file = gst_path_basename (file);
1177   }
1178 
1179   pid = getpid ();
1180   color_mode = gst_debug_get_color_mode ();
1181 
1182   if (object) {
1183     obj = gst_debug_print_object (object);
1184   } else {
1185     obj = (gchar *) &quot;&quot;;
1186   }
1187 
1188   elapsed = GST_CLOCK_DIFF (_priv_gst_start_time, gst_util_get_timestamp ());
1189 
1190   if (color_mode != GST_DEBUG_COLOR_MODE_OFF) {
1191 #ifdef G_OS_WIN32
1192     /* We take a lock to keep colors and content together.
1193      * Maybe there is a better way but for now this will do the right
1194      * thing. */
1195     static GMutex win_print_mutex;
1196     g_mutex_lock (&amp;win_print_mutex);
1197     if (color_mode == GST_DEBUG_COLOR_MODE_UNIX) {
1198 #endif
1199       /* colors, non-windows */
1200       gchar *color = NULL;
1201       const gchar *clear;
1202       gchar pidcolor[10];
1203       const gchar *levelcolor;
1204 
1205       color = gst_debug_construct_term_color (gst_debug_category_get_color
1206           (category));
1207       clear = &quot;\033[00m&quot;;
1208       g_sprintf (pidcolor, &quot;\033[3%1dm&quot;, pid % 6 + 31);
1209       levelcolor = levelcolormap[level];
1210 
1211 #define PRINT_FMT &quot; %s&quot;PID_FMT&quot;%s &quot;PTR_FMT&quot; %s%s%s %s&quot;CAT_FMT&quot;%s %s\n&quot;
1212       fprintf (log_file, &quot;%&quot; GST_TIME_FORMAT PRINT_FMT, GST_TIME_ARGS (elapsed),
1213           pidcolor, pid, clear, g_thread_self (), levelcolor,
1214           gst_debug_level_get_name (level), clear, color,
1215           gst_debug_category_get_name (category), file, line, function, obj,
1216           clear, message_str);
1217       fflush (log_file);
1218 #undef PRINT_FMT
1219       g_free (color);
1220 #ifdef G_OS_WIN32
1221     } else {
1222       /* colors, windows. */
1223       const gint clear = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
1224 #define SET_COLOR(c) G_STMT_START { \
1225   if (log_file == stderr) \
1226     SetConsoleTextAttribute (GetStdHandle (STD_ERROR_HANDLE), (c)); \
1227   } G_STMT_END
1228       /* timestamp */
1229       fprintf (log_file, &quot;%&quot; GST_TIME_FORMAT &quot; &quot;, GST_TIME_ARGS (elapsed));
1230       fflush (log_file);
1231       /* pid */
1232       SET_COLOR (available_colors[pid % G_N_ELEMENTS (available_colors)]);
1233       fprintf (log_file, PID_FMT, pid);
1234       fflush (log_file);
1235       /* thread */
1236       SET_COLOR (clear);
1237       fprintf (log_file, &quot; &quot; PTR_FMT &quot; &quot;, g_thread_self ());
1238       fflush (log_file);
1239       /* level */
1240       SET_COLOR (levelcolormap_w32[level]);
1241       fprintf (log_file, &quot;%s &quot;, gst_debug_level_get_name (level));
1242       fflush (log_file);
1243       /* category */
1244       SET_COLOR (gst_debug_construct_win_color (gst_debug_category_get_color
1245               (category)));
1246       fprintf (log_file, CAT_FMT, gst_debug_category_get_name (category),
1247           file, line, function, obj);
1248       fflush (log_file);
1249       /* message */
1250       SET_COLOR (clear);
1251       fprintf (log_file, &quot; %s\n&quot;, message_str);
1252       fflush (log_file);
1253     }
1254     g_mutex_unlock (&amp;win_print_mutex);
1255 #endif
1256   } else {
1257     /* no color, all platforms */
1258 #define PRINT_FMT &quot; &quot;PID_FMT&quot; &quot;PTR_FMT&quot; %s &quot;CAT_FMT&quot; %s\n&quot;
1259     fprintf (log_file, &quot;%&quot; GST_TIME_FORMAT PRINT_FMT, GST_TIME_ARGS (elapsed),
1260         pid, g_thread_self (), gst_debug_level_get_name (level),
1261         gst_debug_category_get_name (category), file, line, function, obj,
1262         message_str);
1263     fflush (log_file);
1264 #undef PRINT_FMT
1265   }
1266 
1267   if (object != NULL)
1268     g_free (obj);
1269 }
1270 
1271 /**
1272  * gst_debug_level_get_name:
1273  * @level: the level to get the name for
1274  *
1275  * Get the string representation of a debugging level
1276  *
1277  * Returns: the name
1278  */
1279 const gchar *
1280 gst_debug_level_get_name (GstDebugLevel level)
1281 {
1282   switch (level) {
1283     case GST_LEVEL_NONE:
1284       return &quot;&quot;;
1285     case GST_LEVEL_ERROR:
1286       return &quot;ERROR  &quot;;
1287     case GST_LEVEL_WARNING:
1288       return &quot;WARN   &quot;;
1289     case GST_LEVEL_INFO:
1290       return &quot;INFO   &quot;;
1291     case GST_LEVEL_DEBUG:
1292       return &quot;DEBUG  &quot;;
1293     case GST_LEVEL_LOG:
1294       return &quot;LOG    &quot;;
1295     case GST_LEVEL_FIXME:
1296       return &quot;FIXME  &quot;;
1297     case GST_LEVEL_TRACE:
1298       return &quot;TRACE  &quot;;
1299     case GST_LEVEL_MEMDUMP:
1300       return &quot;MEMDUMP&quot;;
1301     default:
1302       g_warning (&quot;invalid level specified for gst_debug_level_get_name&quot;);
1303       return &quot;&quot;;
1304   }
1305 }
1306 
1307 /**
1308  * gst_debug_add_log_function:
1309  * @func: the function to use
1310  * @user_data: user data
1311  * @notify: called when @user_data is not used anymore
1312  *
1313  * Adds the logging function to the list of logging functions.
1314  * Be sure to use #G_GNUC_NO_INSTRUMENT on that function, it is needed.
1315  */
1316 void
1317 gst_debug_add_log_function (GstLogFunction func, gpointer user_data,
1318     GDestroyNotify notify)
1319 {
1320   LogFuncEntry *entry;
1321   GSList *list;
1322 
1323   if (func == NULL)
1324     func = gst_debug_log_default;
1325 
1326   entry = g_slice_new (LogFuncEntry);
1327   entry-&gt;func = func;
1328   entry-&gt;user_data = user_data;
1329   entry-&gt;notify = notify;
1330   /* FIXME: we leak the old list here - other threads might access it right now
1331    * in gst_debug_logv. Another solution is to lock the mutex in gst_debug_logv,
1332    * but that is waaay costly.
1333    * It&#39;d probably be clever to use some kind of RCU here, but I don&#39;t know
1334    * anything about that.
1335    */
1336   g_mutex_lock (&amp;__log_func_mutex);
1337   list = g_slist_copy (__log_functions);
1338   __log_functions = g_slist_prepend (list, entry);
1339   g_mutex_unlock (&amp;__log_func_mutex);
1340 
1341   if (gst_is_initialized ())
1342     GST_DEBUG (&quot;prepended log function %p (user data %p) to log functions&quot;,
1343         func, user_data);
1344 }
1345 
1346 static gint
1347 gst_debug_compare_log_function_by_func (gconstpointer entry, gconstpointer func)
1348 {
1349   gpointer entryfunc = (gpointer) (((LogFuncEntry *) entry)-&gt;func);
1350 
1351   return (entryfunc &lt; func) ? -1 : (entryfunc &gt; func) ? 1 : 0;
1352 }
1353 
1354 static gint
1355 gst_debug_compare_log_function_by_data (gconstpointer entry, gconstpointer data)
1356 {
1357   gpointer entrydata = ((LogFuncEntry *) entry)-&gt;user_data;
1358 
1359   return (entrydata &lt; data) ? -1 : (entrydata &gt; data) ? 1 : 0;
1360 }
1361 
1362 static guint
1363 gst_debug_remove_with_compare_func (GCompareFunc func, gpointer data)
1364 {
1365   GSList *found;
1366   GSList *new, *cleanup = NULL;
1367   guint removals = 0;
1368 
1369   g_mutex_lock (&amp;__log_func_mutex);
1370   new = __log_functions;
1371   cleanup = NULL;
1372   while ((found = g_slist_find_custom (new, data, func))) {
1373     if (new == __log_functions) {
1374       /* make a copy when we have the first hit, so that we modify the copy and
1375        * make that the new list later */
1376       new = g_slist_copy (new);
1377       continue;
1378     }
1379     cleanup = g_slist_prepend (cleanup, found-&gt;data);
1380     new = g_slist_delete_link (new, found);
1381     removals++;
1382   }
1383   /* FIXME: We leak the old list here. See _add_log_function for why. */
1384   __log_functions = new;
1385   g_mutex_unlock (&amp;__log_func_mutex);
1386 
1387   while (cleanup) {
1388     LogFuncEntry *entry = cleanup-&gt;data;
1389 
1390     if (entry-&gt;notify)
1391       entry-&gt;notify (entry-&gt;user_data);
1392 
1393     g_slice_free (LogFuncEntry, entry);
1394     cleanup = g_slist_delete_link (cleanup, cleanup);
1395   }
1396   return removals;
1397 }
1398 
1399 /**
1400  * gst_debug_remove_log_function:
1401  * @func: (scope call) (allow-none): the log function to remove, or %NULL to
1402  *     remove the default log function
1403  *
1404  * Removes all registered instances of the given logging functions.
1405  *
1406  * Returns: How many instances of the function were removed
1407  */
1408 guint
1409 gst_debug_remove_log_function (GstLogFunction func)
1410 {
1411   guint removals;
1412 
1413   if (func == NULL)
1414     func = gst_debug_log_default;
1415 
1416   removals =
1417       gst_debug_remove_with_compare_func
1418       (gst_debug_compare_log_function_by_func, (gpointer) func);
1419 
1420   if (gst_is_initialized ()) {
1421     GST_DEBUG (&quot;removed log function %p %d times from log function list&quot;, func,
1422         removals);
1423   } else {
1424     /* If the default log function is removed before gst_init() was called,
1425      * set a flag so we don&#39;t add it in gst_init() later */
1426     if (func == gst_debug_log_default) {
1427       add_default_log_func = FALSE;
1428       ++removals;
1429     }
1430   }
1431 
1432   return removals;
1433 }
1434 
1435 /**
1436  * gst_debug_remove_log_function_by_data:
1437  * @data: user data of the log function to remove
1438  *
1439  * Removes all registered instances of log functions with the given user data.
1440  *
1441  * Returns: How many instances of the function were removed
1442  */
1443 guint
1444 gst_debug_remove_log_function_by_data (gpointer data)
1445 {
1446   guint removals;
1447 
1448   removals =
1449       gst_debug_remove_with_compare_func
1450       (gst_debug_compare_log_function_by_data, data);
1451 
1452   if (gst_is_initialized ())
1453     GST_DEBUG
1454         (&quot;removed %d log functions with user data %p from log function list&quot;,
1455         removals, data);
1456 
1457   return removals;
1458 }
1459 
1460 /**
1461  * gst_debug_set_colored:
1462  * @colored: Whether to use colored output or not
1463  *
1464  * Sets or unsets the use of coloured debugging output.
1465  * Same as gst_debug_set_color_mode () with the argument being
1466  * being GST_DEBUG_COLOR_MODE_ON or GST_DEBUG_COLOR_MODE_OFF.
1467  *
1468  * This function may be called before gst_init().
1469  */
1470 void
1471 gst_debug_set_colored (gboolean colored)
1472 {
1473   GstDebugColorMode new_mode;
1474   new_mode = colored ? GST_DEBUG_COLOR_MODE_ON : GST_DEBUG_COLOR_MODE_OFF;
1475   g_atomic_int_set (&amp;__use_color, (gint) new_mode);
1476 }
1477 
1478 /**
1479  * gst_debug_set_color_mode:
1480  * @mode: The coloring mode for debug output. See @GstDebugColorMode.
1481  *
1482  * Changes the coloring mode for debug output.
1483  *
1484  * This function may be called before gst_init().
1485  *
1486  * Since: 1.2
1487  */
1488 void
1489 gst_debug_set_color_mode (GstDebugColorMode mode)
1490 {
1491   g_atomic_int_set (&amp;__use_color, mode);
1492 }
1493 
1494 /**
1495  * gst_debug_set_color_mode_from_string:
1496  * @mode: The coloring mode for debug output. One of the following:
1497  * &quot;on&quot;, &quot;auto&quot;, &quot;off&quot;, &quot;disable&quot;, &quot;unix&quot;.
1498  *
1499  * Changes the coloring mode for debug output.
1500  *
1501  * This function may be called before gst_init().
1502  *
1503  * Since: 1.2
1504  */
1505 void
1506 gst_debug_set_color_mode_from_string (const gchar * mode)
1507 {
1508   if ((strcmp (mode, &quot;on&quot;) == 0) || (strcmp (mode, &quot;auto&quot;) == 0))
1509     gst_debug_set_color_mode (GST_DEBUG_COLOR_MODE_ON);
1510   else if ((strcmp (mode, &quot;off&quot;) == 0) || (strcmp (mode, &quot;disable&quot;) == 0))
1511     gst_debug_set_color_mode (GST_DEBUG_COLOR_MODE_OFF);
1512   else if (strcmp (mode, &quot;unix&quot;) == 0)
1513     gst_debug_set_color_mode (GST_DEBUG_COLOR_MODE_UNIX);
1514 }
1515 
1516 /**
1517  * gst_debug_is_colored:
1518  *
1519  * Checks if the debugging output should be colored.
1520  *
1521  * Returns: %TRUE, if the debug output should be colored.
1522  */
1523 gboolean
1524 gst_debug_is_colored (void)
1525 {
1526   GstDebugColorMode mode = g_atomic_int_get (&amp;__use_color);
1527   return (mode == GST_DEBUG_COLOR_MODE_UNIX || mode == GST_DEBUG_COLOR_MODE_ON);
1528 }
1529 
1530 /**
1531  * gst_debug_get_color_mode:
1532  *
1533  * Changes the coloring mode for debug output.
1534  *
1535  * Returns: see @GstDebugColorMode for possible values.
1536  *
1537  * Since: 1.2
1538  */
1539 GstDebugColorMode
1540 gst_debug_get_color_mode (void)
1541 {
1542   return g_atomic_int_get (&amp;__use_color);
1543 }
1544 
1545 /**
1546  * gst_debug_set_active:
1547  * @active: Whether to use debugging output or not
1548  *
1549  * If activated, debugging messages are sent to the debugging
1550  * handlers.
1551  * It makes sense to deactivate it for speed issues.
1552  * &gt; This function is not threadsafe. It makes sense to only call it
1553  * during initialization.
1554  */
1555 void
1556 gst_debug_set_active (gboolean active)
1557 {
1558   _gst_debug_enabled = active;
1559   if (active)
1560     _gst_debug_min = GST_LEVEL_COUNT;
1561   else
1562     _gst_debug_min = GST_LEVEL_NONE;
1563 }
1564 
1565 /**
1566  * gst_debug_is_active:
1567  *
1568  * Checks if debugging output is activated.
1569  *
1570  * Returns: %TRUE, if debugging is activated
1571  */
1572 gboolean
1573 gst_debug_is_active (void)
1574 {
1575   return _gst_debug_enabled;
1576 }
1577 
1578 /**
1579  * gst_debug_set_default_threshold:
1580  * @level: level to set
1581  *
1582  * Sets the default threshold to the given level and updates all categories to
1583  * use this threshold.
1584  *
1585  * This function may be called before gst_init().
1586  */
1587 void
1588 gst_debug_set_default_threshold (GstDebugLevel level)
1589 {
1590   g_atomic_int_set (&amp;__default_level, level);
1591   gst_debug_reset_all_thresholds ();
1592 }
1593 
1594 /**
1595  * gst_debug_get_default_threshold:
1596  *
1597  * Returns the default threshold that is used for new categories.
1598  *
1599  * Returns: the default threshold level
1600  */
1601 GstDebugLevel
1602 gst_debug_get_default_threshold (void)
1603 {
1604   return (GstDebugLevel) g_atomic_int_get (&amp;__default_level);
1605 }
1606 
1607 static gboolean
1608 gst_debug_apply_entry (GstDebugCategory * cat, LevelNameEntry * entry)
1609 {
1610   if (!g_pattern_match_string (entry-&gt;pat, cat-&gt;name))
1611     return FALSE;
1612 
1613   if (gst_is_initialized ())
1614     GST_LOG (&quot;category %s matches pattern %p - gets set to level %d&quot;,
1615         cat-&gt;name, entry-&gt;pat, entry-&gt;level);
1616 
1617   gst_debug_category_set_threshold (cat, entry-&gt;level);
1618   return TRUE;
1619 }
1620 
1621 static void
1622 gst_debug_reset_threshold (gpointer category, gpointer unused)
1623 {
1624   GstDebugCategory *cat = (GstDebugCategory *) category;
1625   GSList *walk;
1626 
1627   g_mutex_lock (&amp;__level_name_mutex);
1628 
1629   for (walk = __level_name; walk != NULL; walk = walk-&gt;next) {
1630     if (gst_debug_apply_entry (cat, walk-&gt;data))
1631       break;
1632   }
1633 
1634   g_mutex_unlock (&amp;__level_name_mutex);
1635 
1636   if (walk == NULL)
1637     gst_debug_category_set_threshold (cat, gst_debug_get_default_threshold ());
1638 }
1639 
1640 static void
1641 gst_debug_reset_all_thresholds (void)
1642 {
1643   g_mutex_lock (&amp;__cat_mutex);
1644   g_slist_foreach (__categories, gst_debug_reset_threshold, NULL);
1645   g_mutex_unlock (&amp;__cat_mutex);
1646 }
1647 
1648 static void
1649 for_each_threshold_by_entry (gpointer data, gpointer user_data)
1650 {
1651   GstDebugCategory *cat = (GstDebugCategory *) data;
1652   LevelNameEntry *entry = (LevelNameEntry *) user_data;
1653 
1654   gst_debug_apply_entry (cat, entry);
1655 }
1656 
1657 /**
1658  * gst_debug_set_threshold_for_name:
1659  * @name: name of the categories to set
1660  * @level: level to set them to
1661  *
1662  * Sets all categories which match the given glob style pattern to the given
1663  * level.
1664  */
1665 void
1666 gst_debug_set_threshold_for_name (const gchar * name, GstDebugLevel level)
1667 {
1668   GPatternSpec *pat;
1669   LevelNameEntry *entry;
1670 
1671   g_return_if_fail (name != NULL);
1672 
1673   pat = g_pattern_spec_new (name);
1674   entry = g_slice_new (LevelNameEntry);
1675   entry-&gt;pat = pat;
1676   entry-&gt;level = level;
1677   g_mutex_lock (&amp;__level_name_mutex);
1678   __level_name = g_slist_prepend (__level_name, entry);
1679   g_mutex_unlock (&amp;__level_name_mutex);
1680   g_mutex_lock (&amp;__cat_mutex);
1681   g_slist_foreach (__categories, for_each_threshold_by_entry, entry);
1682   g_mutex_unlock (&amp;__cat_mutex);
1683 }
1684 
1685 /**
1686  * gst_debug_unset_threshold_for_name:
1687  * @name: name of the categories to set
1688  *
1689  * Resets all categories with the given name back to the default level.
1690  */
1691 void
1692 gst_debug_unset_threshold_for_name (const gchar * name)
1693 {
1694   GSList *walk;
1695   GPatternSpec *pat;
1696 
1697   g_return_if_fail (name != NULL);
1698 
1699   pat = g_pattern_spec_new (name);
1700   g_mutex_lock (&amp;__level_name_mutex);
1701   walk = __level_name;
1702   /* improve this if you want, it&#39;s mighty slow */
1703   while (walk) {
1704     LevelNameEntry *entry = walk-&gt;data;
1705 
1706     if (g_pattern_spec_equal (entry-&gt;pat, pat)) {
1707       __level_name = g_slist_remove_link (__level_name, walk);
1708       g_pattern_spec_free (entry-&gt;pat);
1709       g_slice_free (LevelNameEntry, entry);
1710       g_slist_free_1 (walk);
1711       walk = __level_name;
1712     } else {
1713       walk = g_slist_next (walk);
1714     }
1715   }
1716   g_mutex_unlock (&amp;__level_name_mutex);
1717   g_pattern_spec_free (pat);
1718   gst_debug_reset_all_thresholds ();
1719 }
1720 
1721 GstDebugCategory *
1722 _gst_debug_category_new (const gchar * name, guint color,
1723     const gchar * description)
1724 {
1725   GstDebugCategory *cat, *catfound;
1726 
1727   g_return_val_if_fail (name != NULL, NULL);
1728 
1729   cat = g_slice_new (GstDebugCategory);
1730   cat-&gt;name = g_strdup (name);
1731   cat-&gt;color = color;
1732   if (description != NULL) {
1733     cat-&gt;description = g_strdup (description);
1734   } else {
1735     cat-&gt;description = g_strdup (&quot;no description&quot;);
1736   }
1737   g_atomic_int_set (&amp;cat-&gt;threshold, 0);
1738   gst_debug_reset_threshold (cat, NULL);
1739 
1740   /* add to category list */
1741   g_mutex_lock (&amp;__cat_mutex);
1742   catfound = _gst_debug_get_category_locked (name);
1743   if (catfound) {
1744     g_free ((gpointer) cat-&gt;name);
1745     g_free ((gpointer) cat-&gt;description);
1746     g_slice_free (GstDebugCategory, cat);
1747     cat = catfound;
1748   } else {
1749     __categories = g_slist_prepend (__categories, cat);
1750   }
1751   g_mutex_unlock (&amp;__cat_mutex);
1752 
1753   return cat;
1754 }
1755 
1756 /**
1757  * gst_debug_category_free:
1758  * @category: #GstDebugCategory to free.
1759  *
1760  * Removes and frees the category and all associated resources.
1761  */
1762 void
1763 gst_debug_category_free (GstDebugCategory * category)
1764 {
1765   if (category == NULL)
1766     return;
1767 
1768   /* remove from category list */
1769   g_mutex_lock (&amp;__cat_mutex);
1770   __categories = g_slist_remove (__categories, category);
1771   g_mutex_unlock (&amp;__cat_mutex);
1772 
1773   g_free ((gpointer) category-&gt;name);
1774   g_free ((gpointer) category-&gt;description);
1775   g_slice_free (GstDebugCategory, category);
1776 }
1777 
1778 /**
1779  * gst_debug_category_set_threshold:
1780  * @category: a #GstDebugCategory to set threshold of.
1781  * @level: the #GstDebugLevel threshold to set.
1782  *
1783  * Sets the threshold of the category to the given level. Debug information will
1784  * only be output if the threshold is lower or equal to the level of the
1785  * debugging message.
1786  * &gt; Do not use this function in production code, because other functions may
1787  * &gt; change the threshold of categories as side effect. It is however a nice
1788  * &gt; function to use when debugging (even from gdb).
1789  */
1790 void
1791 gst_debug_category_set_threshold (GstDebugCategory * category,
1792     GstDebugLevel level)
1793 {
1794   g_return_if_fail (category != NULL);
1795 
1796   if (level &gt; _gst_debug_min) {
1797     _gst_debug_enabled = TRUE;
1798     _gst_debug_min = level;
1799   }
1800 
1801   g_atomic_int_set (&amp;category-&gt;threshold, level);
1802 }
1803 
1804 /**
1805  * gst_debug_category_reset_threshold:
1806  * @category: a #GstDebugCategory to reset threshold of.
1807  *
1808  * Resets the threshold of the category to the default level. Debug information
1809  * will only be output if the threshold is lower or equal to the level of the
1810  * debugging message.
1811  * Use this function to set the threshold back to where it was after using
1812  * gst_debug_category_set_threshold().
1813  */
1814 void
1815 gst_debug_category_reset_threshold (GstDebugCategory * category)
1816 {
1817   gst_debug_reset_threshold (category, NULL);
1818 }
1819 
1820 /**
1821  * gst_debug_category_get_threshold:
1822  * @category: a #GstDebugCategory to get threshold of.
1823  *
1824  * Returns the threshold of a #GstDebugCategory.
1825  *
1826  * Returns: the #GstDebugLevel that is used as threshold.
1827  */
1828 GstDebugLevel
1829 gst_debug_category_get_threshold (GstDebugCategory * category)
1830 {
1831   return (GstDebugLevel) g_atomic_int_get (&amp;category-&gt;threshold);
1832 }
1833 
1834 /**
1835  * gst_debug_category_get_name:
1836  * @category: a #GstDebugCategory to get name of.
1837  *
1838  * Returns the name of a debug category.
1839  *
1840  * Returns: the name of the category.
1841  */
1842 const gchar *
1843 gst_debug_category_get_name (GstDebugCategory * category)
1844 {
1845   return category-&gt;name;
1846 }
1847 
1848 /**
1849  * gst_debug_category_get_color:
1850  * @category: a #GstDebugCategory to get the color of.
1851  *
1852  * Returns the color of a debug category used when printing output in this
1853  * category.
1854  *
1855  * Returns: the color of the category.
1856  */
1857 guint
1858 gst_debug_category_get_color (GstDebugCategory * category)
1859 {
1860   return category-&gt;color;
1861 }
1862 
1863 /**
1864  * gst_debug_category_get_description:
1865  * @category: a #GstDebugCategory to get the description of.
1866  *
1867  * Returns the description of a debug category.
1868  *
1869  * Returns: the description of the category.
1870  */
1871 const gchar *
1872 gst_debug_category_get_description (GstDebugCategory * category)
1873 {
1874   return category-&gt;description;
1875 }
1876 
1877 /**
1878  * gst_debug_get_all_categories:
1879  *
1880  * Returns a snapshot of a all categories that are currently in use . This list
1881  * may change anytime.
1882  * The caller has to free the list after use.
1883  *
1884  * Returns: (transfer container) (element-type Gst.DebugCategory): the list of
1885  *     debug categories
1886  */
1887 GSList *
1888 gst_debug_get_all_categories (void)
1889 {
1890   GSList *ret;
1891 
1892   g_mutex_lock (&amp;__cat_mutex);
1893   ret = g_slist_copy (__categories);
1894   g_mutex_unlock (&amp;__cat_mutex);
1895 
1896   return ret;
1897 }
1898 
1899 static GstDebugCategory *
1900 _gst_debug_get_category_locked (const gchar * name)
1901 {
1902   GstDebugCategory *ret = NULL;
1903   GSList *node;
1904 
1905   for (node = __categories; node; node = g_slist_next (node)) {
1906     ret = (GstDebugCategory *) node-&gt;data;
1907     if (!strcmp (name, ret-&gt;name)) {
1908       return ret;
1909     }
1910   }
1911   return NULL;
1912 }
1913 
1914 GstDebugCategory *
1915 _gst_debug_get_category (const gchar * name)
1916 {
1917   GstDebugCategory *ret;
1918 
1919   g_mutex_lock (&amp;__cat_mutex);
1920   ret = _gst_debug_get_category_locked (name);
1921   g_mutex_unlock (&amp;__cat_mutex);
1922 
1923   return ret;
1924 }
1925 
1926 static gboolean
1927 parse_debug_category (gchar * str, const gchar ** category)
1928 {
1929   if (!str)
1930     return FALSE;
1931 
1932   /* works in place */
1933   g_strstrip (str);
1934 
1935   if (str[0] != &#39;\0&#39;) {
1936     *category = str;
1937     return TRUE;
1938   }
1939 
1940   return FALSE;
1941 }
1942 
1943 static gboolean
1944 parse_debug_level (gchar * str, GstDebugLevel * level)
1945 {
1946   if (!str)
1947     return FALSE;
1948 
1949   /* works in place */
1950   g_strstrip (str);
1951 
1952   if (g_ascii_isdigit (str[0])) {
1953     unsigned long l;
1954     char *endptr;
1955     l = strtoul (str, &amp;endptr, 10);
1956     if (endptr &gt; str &amp;&amp; endptr[0] == 0) {
1957       *level = (GstDebugLevel) l;
1958     } else {
1959       return FALSE;
1960     }
1961   } else if (strcmp (str, &quot;ERROR&quot;) == 0) {
1962     *level = GST_LEVEL_ERROR;
1963   } else if (strncmp (str, &quot;WARN&quot;, 4) == 0) {
1964     *level = GST_LEVEL_WARNING;
1965   } else if (strcmp (str, &quot;FIXME&quot;) == 0) {
1966     *level = GST_LEVEL_FIXME;
1967   } else if (strcmp (str, &quot;INFO&quot;) == 0) {
1968     *level = GST_LEVEL_INFO;
1969   } else if (strcmp (str, &quot;DEBUG&quot;) == 0) {
1970     *level = GST_LEVEL_DEBUG;
1971   } else if (strcmp (str, &quot;LOG&quot;) == 0) {
1972     *level = GST_LEVEL_LOG;
1973   } else if (strcmp (str, &quot;TRACE&quot;) == 0) {
1974     *level = GST_LEVEL_TRACE;
1975   } else if (strcmp (str, &quot;MEMDUMP&quot;) == 0) {
1976     *level = GST_LEVEL_MEMDUMP;
1977   } else
1978     return FALSE;
1979 
1980   return TRUE;
1981 }
1982 
1983 /**
1984  * gst_debug_set_threshold_from_string:
1985  * @list: comma-separated list of &quot;category:level&quot; pairs to be used
1986  *     as debug logging levels
1987  * @reset: %TRUE to clear all previously-set debug levels before setting
1988  *     new thresholds
1989  * %FALSE if adding the threshold described by @list to the one already set.
1990  *
1991  * Sets the debug logging wanted in the same form as with the GST_DEBUG
1992  * environment variable. You can use wildcards such as &#39;*&#39;, but note that
1993  * the order matters when you use wild cards, e.g. &quot;foosrc:6,*src:3,*:2&quot; sets
1994  * everything to log level 2.
1995  *
1996  * Since: 1.2
1997  */
1998 void
1999 gst_debug_set_threshold_from_string (const gchar * list, gboolean reset)
2000 {
2001   gchar **split;
2002   gchar **walk;
2003 
2004   g_assert (list);
2005 
2006   if (reset)
2007     gst_debug_set_default_threshold (GST_LEVEL_DEFAULT);
2008 
2009   split = g_strsplit (list, &quot;,&quot;, 0);
2010 
2011   for (walk = split; *walk; walk++) {
2012     if (strchr (*walk, &#39;:&#39;)) {
2013       gchar **values = g_strsplit (*walk, &quot;:&quot;, 2);
2014 
2015       if (values[0] &amp;&amp; values[1]) {
2016         GstDebugLevel level;
2017         const gchar *category;
2018 
2019         if (parse_debug_category (values[0], &amp;category)
2020             &amp;&amp; parse_debug_level (values[1], &amp;level)) {
2021           gst_debug_set_threshold_for_name (category, level);
2022 
2023           /* bump min-level anyway to allow the category to be registered in the
2024            * future still */
2025           if (level &gt; _gst_debug_min) {
2026             _gst_debug_min = level;
2027           }
2028         }
2029       }
2030 
2031       g_strfreev (values);
2032     } else {
2033       GstDebugLevel level;
2034 
2035       if (parse_debug_level (*walk, &amp;level))
2036         gst_debug_set_default_threshold (level);
2037     }
2038   }
2039 
2040   g_strfreev (split);
2041 }
2042 
2043 /*** FUNCTION POINTERS ********************************************************/
2044 
2045 static GHashTable *__gst_function_pointers;     /* NULL */
2046 static GMutex __dbg_functions_mutex;
2047 
2048 /* This function MUST NOT return NULL */
2049 const gchar *
2050 _gst_debug_nameof_funcptr (GstDebugFuncPtr func)
2051 {
2052   gchar *ptrname;
2053 
2054 #ifdef HAVE_DLADDR
2055   Dl_info dl_info;
2056 #endif
2057 
2058   if (G_UNLIKELY (func == NULL))
2059     return &quot;(NULL)&quot;;
2060 
2061   g_mutex_lock (&amp;__dbg_functions_mutex);
2062   if (G_LIKELY (__gst_function_pointers)) {
2063     ptrname = g_hash_table_lookup (__gst_function_pointers, (gpointer) func);
2064     g_mutex_unlock (&amp;__dbg_functions_mutex);
2065     if (G_LIKELY (ptrname))
2066       return ptrname;
2067   } else {
2068     g_mutex_unlock (&amp;__dbg_functions_mutex);
2069   }
2070   /* we need to create an entry in the hash table for this one so we don&#39;t leak
2071    * the name */
2072 #ifdef HAVE_DLADDR
2073   if (dladdr ((gpointer) func, &amp;dl_info) &amp;&amp; dl_info.dli_sname) {
2074     const gchar *name = g_intern_string (dl_info.dli_sname);
2075 
2076     _gst_debug_register_funcptr (func, name);
2077     return name;
2078   } else
2079 #endif
2080   {
2081     gchar *name = g_strdup_printf (&quot;%p&quot;, (gpointer) func);
2082     const gchar *iname = g_intern_string (name);
2083 
2084     g_free (name);
2085 
2086     _gst_debug_register_funcptr (func, iname);
2087     return iname;
2088   }
2089 }
2090 
2091 void
2092 _gst_debug_register_funcptr (GstDebugFuncPtr func, const gchar * ptrname)
2093 {
2094   gpointer ptr = (gpointer) func;
2095 
2096   g_mutex_lock (&amp;__dbg_functions_mutex);
2097 
2098   if (!__gst_function_pointers)
2099     __gst_function_pointers = g_hash_table_new (g_direct_hash, g_direct_equal);
2100   if (!g_hash_table_lookup (__gst_function_pointers, ptr)) {
2101     g_hash_table_insert (__gst_function_pointers, ptr, (gpointer) ptrname);
2102   }
2103 
2104   g_mutex_unlock (&amp;__dbg_functions_mutex);
2105 }
2106 
2107 void
2108 _priv_gst_debug_cleanup (void)
2109 {
2110   g_mutex_lock (&amp;__dbg_functions_mutex);
2111 
2112   if (__gst_function_pointers) {
2113     g_hash_table_unref (__gst_function_pointers);
2114     __gst_function_pointers = NULL;
2115   }
2116 
2117   g_mutex_unlock (&amp;__dbg_functions_mutex);
2118 }
2119 
2120 static void
2121 gst_info_dump_mem_line (gchar * linebuf, gsize linebuf_size,
2122     const guint8 * mem, gsize mem_offset, gsize mem_size)
2123 {
2124   gchar hexstr[50], ascstr[18], digitstr[4];
2125 
2126   if (mem_size &gt; 16)
2127     mem_size = 16;
2128 
2129   hexstr[0] = &#39;\0&#39;;
2130   ascstr[0] = &#39;\0&#39;;
2131 
2132   if (mem != NULL) {
2133     guint i = 0;
2134 
2135     mem += mem_offset;
2136     while (i &lt; mem_size) {
2137       ascstr[i] = (g_ascii_isprint (mem[i])) ? mem[i] : &#39;.&#39;;
2138       g_snprintf (digitstr, sizeof (digitstr), &quot;%02x &quot;, mem[i]);
2139       g_strlcat (hexstr, digitstr, sizeof (hexstr));
2140       ++i;
2141     }
2142     ascstr[i] = &#39;\0&#39;;
2143   }
2144 
2145   g_snprintf (linebuf, linebuf_size, &quot;%08x: %-48.48s %-16.16s&quot;,
2146       (guint) mem_offset, hexstr, ascstr);
2147 }
2148 
2149 void
2150 _gst_debug_dump_mem (GstDebugCategory * cat, const gchar * file,
2151     const gchar * func, gint line, GObject * obj, const gchar * msg,
2152     const guint8 * data, guint length)
2153 {
2154   guint off = 0;
2155 
2156   gst_debug_log ((cat), GST_LEVEL_MEMDUMP, file, func, line, obj, &quot;--------&quot;
2157       &quot;-------------------------------------------------------------------&quot;);
2158 
2159   if (msg != NULL &amp;&amp; *msg != &#39;\0&#39;) {
2160     gst_debug_log ((cat), GST_LEVEL_MEMDUMP, file, func, line, obj, &quot;%s&quot;, msg);
2161   }
2162 
2163   while (off &lt; length) {
2164     gchar buf[128];
2165 
2166     /* gst_info_dump_mem_line will process 16 bytes at most */
2167     gst_info_dump_mem_line (buf, sizeof (buf), data, off, length - off);
2168     gst_debug_log (cat, GST_LEVEL_MEMDUMP, file, func, line, obj, &quot;%s&quot;, buf);
2169     off += 16;
2170   }
2171 
2172   gst_debug_log ((cat), GST_LEVEL_MEMDUMP, file, func, line, obj, &quot;--------&quot;
2173       &quot;-------------------------------------------------------------------&quot;);
2174 }
2175 
2176 #else /* !GST_DISABLE_GST_DEBUG */
2177 #ifndef GST_REMOVE_DISABLED
2178 
2179 GstDebugCategory *
2180 _gst_debug_category_new (const gchar * name, guint color,
2181     const gchar * description)
2182 {
2183   return NULL;
2184 }
2185 
2186 void
2187 _gst_debug_register_funcptr (GstDebugFuncPtr func, const gchar * ptrname)
2188 {
2189 }
2190 
2191 /* This function MUST NOT return NULL */
2192 const gchar *
2193 _gst_debug_nameof_funcptr (GstDebugFuncPtr func)
2194 {
2195   return &quot;(NULL)&quot;;
2196 }
2197 
2198 void
2199 _priv_gst_debug_cleanup (void)
2200 {
2201 }
2202 
2203 void
2204 gst_debug_log (GstDebugCategory * category, GstDebugLevel level,
2205     const gchar * file, const gchar * function, gint line,
2206     GObject * object, const gchar * format, ...)
2207 {
2208 }
2209 
2210 void
2211 gst_debug_log_valist (GstDebugCategory * category, GstDebugLevel level,
2212     const gchar * file, const gchar * function, gint line,
2213     GObject * object, const gchar * format, va_list args)
2214 {
2215 }
2216 
2217 const gchar *
2218 gst_debug_message_get (GstDebugMessage * message)
2219 {
2220   return &quot;&quot;;
2221 }
2222 
2223 void
2224 gst_debug_log_default (GstDebugCategory * category, GstDebugLevel level,
2225     const gchar * file, const gchar * function, gint line,
2226     GObject * object, GstDebugMessage * message, gpointer unused)
2227 {
2228 }
2229 
2230 const gchar *
2231 gst_debug_level_get_name (GstDebugLevel level)
2232 {
2233   return &quot;NONE&quot;;
2234 }
2235 
2236 void
2237 gst_debug_add_log_function (GstLogFunction func, gpointer user_data,
2238     GDestroyNotify notify)
2239 {
2240 }
2241 
2242 guint
2243 gst_debug_remove_log_function (GstLogFunction func)
2244 {
2245   return 0;
2246 }
2247 
2248 guint
2249 gst_debug_remove_log_function_by_data (gpointer data)
2250 {
2251   return 0;
2252 }
2253 
2254 void
2255 gst_debug_set_active (gboolean active)
2256 {
2257 }
2258 
2259 gboolean
2260 gst_debug_is_active (void)
2261 {
2262   return FALSE;
2263 }
2264 
2265 void
2266 gst_debug_set_colored (gboolean colored)
2267 {
2268 }
2269 
2270 void
2271 gst_debug_set_color_mode (GstDebugColorMode mode)
2272 {
2273 }
2274 
2275 void
2276 gst_debug_set_color_mode_from_string (const gchar * str)
2277 {
2278 }
2279 
2280 gboolean
2281 gst_debug_is_colored (void)
2282 {
2283   return FALSE;
2284 }
2285 
2286 GstDebugColorMode
2287 gst_debug_get_color_mode (void)
2288 {
2289   return GST_DEBUG_COLOR_MODE_OFF;
2290 }
2291 
2292 void
2293 gst_debug_set_threshold_from_string (const gchar * list, gboolean reset)
2294 {
2295 }
2296 
2297 void
2298 gst_debug_set_default_threshold (GstDebugLevel level)
2299 {
2300 }
2301 
2302 GstDebugLevel
2303 gst_debug_get_default_threshold (void)
2304 {
2305   return GST_LEVEL_NONE;
2306 }
2307 
2308 void
2309 gst_debug_set_threshold_for_name (const gchar * name, GstDebugLevel level)
2310 {
2311 }
2312 
2313 void
2314 gst_debug_unset_threshold_for_name (const gchar * name)
2315 {
2316 }
2317 
2318 void
2319 gst_debug_category_free (GstDebugCategory * category)
2320 {
2321 }
2322 
2323 void
2324 gst_debug_category_set_threshold (GstDebugCategory * category,
2325     GstDebugLevel level)
2326 {
2327 }
2328 
2329 void
2330 gst_debug_category_reset_threshold (GstDebugCategory * category)
2331 {
2332 }
2333 
2334 GstDebugLevel
2335 gst_debug_category_get_threshold (GstDebugCategory * category)
2336 {
2337   return GST_LEVEL_NONE;
2338 }
2339 
2340 const gchar *
2341 gst_debug_category_get_name (GstDebugCategory * category)
2342 {
2343   return &quot;&quot;;
2344 }
2345 
2346 guint
2347 gst_debug_category_get_color (GstDebugCategory * category)
2348 {
2349   return 0;
2350 }
2351 
2352 const gchar *
2353 gst_debug_category_get_description (GstDebugCategory * category)
2354 {
2355   return &quot;&quot;;
2356 }
2357 
2358 GSList *
2359 gst_debug_get_all_categories (void)
2360 {
2361   return NULL;
2362 }
2363 
2364 GstDebugCategory *
2365 _gst_debug_get_category (const gchar * name)
2366 {
2367   return NULL;
2368 }
2369 
2370 gchar *
2371 gst_debug_construct_term_color (guint colorinfo)
2372 {
2373   return g_strdup (&quot;00&quot;);
2374 }
2375 
2376 gint
2377 gst_debug_construct_win_color (guint colorinfo)
2378 {
2379   return 0;
2380 }
2381 
2382 gboolean
2383 _priv_gst_in_valgrind (void)
2384 {
2385   return FALSE;
2386 }
2387 
2388 void
2389 _gst_debug_dump_mem (GstDebugCategory * cat, const gchar * file,
2390     const gchar * func, gint line, GObject * obj, const gchar * msg,
2391     const guint8 * data, guint length)
2392 {
2393 }
2394 #endif /* GST_REMOVE_DISABLED */
2395 #endif /* GST_DISABLE_GST_DEBUG */
2396 
2397 /* Need this for _gst_element_error_printf even if GST_REMOVE_DISABLED is set:
2398  * fallback function that cleans up the format string and replaces all pointer
2399  * extension formats with plain %p. */
2400 #ifdef GST_DISABLE_GST_DEBUG
2401 int
2402 __gst_info_fallback_vasprintf (char **result, char const *format, va_list args)
2403 {
2404   gchar *clean_format, *c;
2405   gsize len;
2406 
2407   if (format == NULL)
2408     return -1;
2409 
2410   clean_format = g_strdup (format);
2411   c = clean_format;
2412   while ((c = strstr (c, &quot;%p\a&quot;))) {
2413     if (c[3] &lt; &#39;A&#39; || c[3] &gt; &#39;Z&#39;) {
2414       c += 3;
2415       continue;
2416     }
2417     len = strlen (c + 4);
2418     memmove (c + 2, c + 4, len + 1);
2419     c += 2;
2420   }
2421   while ((c = strstr (clean_format, &quot;%P&quot;)))     /* old GST_PTR_FORMAT */
2422     c[1] = &#39;p&#39;;
2423   while ((c = strstr (clean_format, &quot;%Q&quot;)))     /* old GST_SEGMENT_FORMAT */
2424     c[1] = &#39;p&#39;;
2425 
2426   len = g_vasprintf (result, clean_format, args);
2427 
2428   g_free (clean_format);
2429 
2430   if (*result == NULL)
2431     return -1;
2432 
2433   return len;
2434 }
2435 #endif
2436 
2437 /**
2438  * gst_info_vasprintf:
2439  * @result: (out): the resulting string
2440  * @format: a printf style format string
2441  * @args: the va_list of printf arguments for @format
2442  *
2443  * Allocates and fills a string large enough (including the terminating null
2444  * byte) to hold the specified printf style @format and @args.
2445  *
2446  * This function deals with the GStreamer specific printf specifiers
2447  * #GST_PTR_FORMAT and #GST_SEGMENT_FORMAT.  If you do not have these specifiers
2448  * in your @format string, you do not need to use this function and can use
2449  * alternatives such as g_vasprintf().
2450  *
2451  * Free @result with g_free().
2452  *
2453  * Returns: the length of the string allocated into @result or -1 on any error
2454  *
2455  * Since: 1.8
2456  */
2457 gint
2458 gst_info_vasprintf (gchar ** result, const gchar * format, va_list args)
2459 {
2460   /* This will fallback to __gst_info_fallback_vasprintf() via a #define in
2461    * gst_private.h if the debug system is disabled which will remove the gst
2462    * specific printf format specifiers */
2463   return __gst_vasprintf (result, format, args);
2464 }
2465 
2466 /**
2467  * gst_info_strdup_vprintf:
2468  * @format: a printf style format string
2469  * @args: the va_list of printf arguments for @format
2470  *
2471  * Allocates, fills and returns a null terminated string from the printf style
2472  * @format string and @args.
2473  *
2474  * See gst_info_vasprintf() for when this function is required.
2475  *
2476  * Free with g_free().
2477  *
2478  * Returns: (nullable): a newly allocated null terminated string or %NULL on any error
2479  *
2480  * Since: 1.8
2481  */
2482 gchar *
2483 gst_info_strdup_vprintf (const gchar * format, va_list args)
2484 {
2485   gchar *ret;
2486 
2487   if (gst_info_vasprintf (&amp;ret, format, args) &lt; 0)
2488     ret = NULL;
2489 
2490   return ret;
2491 }
2492 
2493 /**
2494  * gst_info_strdup_printf:
2495  * @format: a printf style format string
2496  * @...: the printf arguments for @format
2497  *
2498  * Allocates, fills and returns a 0-terminated string from the printf style
2499  * @format string and corresponding arguments.
2500  *
2501  * See gst_info_vasprintf() for when this function is required.
2502  *
2503  * Free with g_free().
2504  *
2505  * Returns: (nullable): a newly allocated null terminated string or %NULL on any error
2506  *
2507  * Since: 1.8
2508  */
2509 gchar *
2510 gst_info_strdup_printf (const gchar * format, ...)
2511 {
2512   gchar *ret;
2513   va_list args;
2514 
2515   va_start (args, format);
2516   ret = gst_info_strdup_vprintf (format, args);
2517   va_end (args);
2518 
2519   return ret;
2520 }
2521 
2522 /**
2523  * gst_print:
2524  * @format: a printf style format string
2525  * @...: the printf arguments for @format
2526  *
2527  * Outputs a formatted message via the GLib print handler. The default print
2528  * handler simply outputs the message to stdout.
2529  *
2530  * This function will not append a new-line character at the end, unlike
2531  * gst_println() which will.
2532  *
2533  * All strings must be in ASCII or UTF-8 encoding.
2534  *
2535  * This function differs from g_print() in that it supports all the additional
2536  * printf specifiers that are supported by GStreamer&#39;s debug logging system,
2537  * such as #GST_PTR_FORMAT and #GST_SEGMENT_FORMAT.
2538  *
2539  * This function is primarily for printing debug output.
2540  *
2541  * Since: 1.12
2542  */
2543 void
2544 gst_print (const gchar * format, ...)
2545 {
2546   va_list args;
2547   gchar *str;
2548 
2549   va_start (args, format);
2550   str = gst_info_strdup_vprintf (format, args);
2551   va_end (args);
2552 
2553   g_print (&quot;%s&quot;, str);
2554   g_free (str);
2555 }
2556 
2557 /**
2558  * gst_println:
2559  * @format: a printf style format string
2560  * @...: the printf arguments for @format
2561  *
2562  * Outputs a formatted message via the GLib print handler. The default print
2563  * handler simply outputs the message to stdout.
2564  *
2565  * This function will append a new-line character at the end, unlike
2566  * gst_print() which will not.
2567  *
2568  * All strings must be in ASCII or UTF-8 encoding.
2569  *
2570  * This function differs from g_print() in that it supports all the additional
2571  * printf specifiers that are supported by GStreamer&#39;s debug logging system,
2572  * such as #GST_PTR_FORMAT and #GST_SEGMENT_FORMAT.
2573  *
2574  * This function is primarily for printing debug output.
2575  *
2576  * Since: 1.12
2577  */
2578 void
2579 gst_println (const gchar * format, ...)
2580 {
2581   va_list args;
2582   gchar *str;
2583 
2584   va_start (args, format);
2585   str = gst_info_strdup_vprintf (format, args);
2586   va_end (args);
2587 
2588   g_print (&quot;%s\n&quot;, str);
2589   g_free (str);
2590 }
2591 
2592 /**
2593  * gst_printerr:
2594  * @format: a printf style format string
2595  * @...: the printf arguments for @format
2596  *
2597  * Outputs a formatted message via the GLib error message handler. The default
2598  * handler simply outputs the message to stderr.
2599  *
2600  * This function will not append a new-line character at the end, unlike
2601  * gst_printerrln() which will.
2602  *
2603  * All strings must be in ASCII or UTF-8 encoding.
2604  *
2605  * This function differs from g_printerr() in that it supports the additional
2606  * printf specifiers that are supported by GStreamer&#39;s debug logging system,
2607  * such as #GST_PTR_FORMAT and #GST_SEGMENT_FORMAT.
2608  *
2609  * This function is primarily for printing debug output.
2610  *
2611  * Since: 1.12
2612  */
2613 void
2614 gst_printerr (const gchar * format, ...)
2615 {
2616   va_list args;
2617   gchar *str;
2618 
2619   va_start (args, format);
2620   str = gst_info_strdup_vprintf (format, args);
2621   va_end (args);
2622 
2623   g_printerr (&quot;%s&quot;, str);
2624   g_free (str);
2625 }
2626 
2627 /**
2628  * gst_printerrln:
2629  * @format: a printf style format string
2630  * @...: the printf arguments for @format
2631  *
2632  * Outputs a formatted message via the GLib error message handler. The default
2633  * handler simply outputs the message to stderr.
2634  *
2635  * This function will append a new-line character at the end, unlike
2636  * gst_printerr() which will not.
2637  *
2638  * All strings must be in ASCII or UTF-8 encoding.
2639  *
2640  * This function differs from g_printerr() in that it supports the additional
2641  * printf specifiers that are supported by GStreamer&#39;s debug logging system,
2642  * such as #GST_PTR_FORMAT and #GST_SEGMENT_FORMAT.
2643  *
2644  * This function is primarily for printing debug output.
2645  *
2646  * Since: 1.12
2647  */
2648 void
2649 gst_printerrln (const gchar * format, ...)
2650 {
2651   va_list args;
2652   gchar *str;
2653 
2654   va_start (args, format);
2655   str = gst_info_strdup_vprintf (format, args);
2656   va_end (args);
2657 
2658   g_printerr (&quot;%s\n&quot;, str);
2659   g_free (str);
2660 }
2661 
2662 #ifdef HAVE_UNWIND
2663 #ifdef HAVE_DW
2664 static gboolean
2665 append_debug_info (GString * trace, Dwfl * dwfl, const void *ip)
2666 {
2667   Dwfl_Line *line;
2668   Dwarf_Addr addr;
2669   Dwfl_Module *module;
2670   const gchar *function_name;
2671 
2672   if (dwfl_linux_proc_report (dwfl, getpid ()) != 0)
2673     return FALSE;
2674 
2675   if (dwfl_report_end (dwfl, NULL, NULL))
2676     return FALSE;
2677 
2678   addr = (uintptr_t) ip;
2679   module = dwfl_addrmodule (dwfl, addr);
2680   function_name = dwfl_module_addrname (module, addr);
2681 
2682   g_string_append_printf (trace, &quot;%s (&quot;, function_name ? function_name : &quot;??&quot;);
2683 
2684   line = dwfl_getsrc (dwfl, addr);
2685   if (line != NULL) {
2686     gint nline;
2687     Dwarf_Addr addr;
2688     const gchar *filename = dwfl_lineinfo (line, &amp;addr,
2689         &amp;nline, NULL, NULL, NULL);
2690 
2691     g_string_append_printf (trace, &quot;%s:%d&quot;, strrchr (filename,
2692             G_DIR_SEPARATOR) + 1, nline);
2693   } else {
2694     const gchar *eflfile = NULL;
2695 
2696     dwfl_module_info (module, NULL, NULL, NULL, NULL, NULL, &amp;eflfile, NULL);
2697     g_string_append_printf (trace, &quot;%s:%p&quot;, eflfile ? eflfile : &quot;??&quot;, ip);
2698   }
2699 
2700   return TRUE;
2701 }
2702 #endif /* HAVE_DW */
2703 
2704 static gchar *
2705 generate_unwind_trace (GstStackTraceFlags flags)
2706 {
2707   gint unret;
2708   unw_context_t uc;
2709   unw_cursor_t cursor;
2710   gboolean use_libunwind = TRUE;
2711   GString *trace = g_string_new (NULL);
2712 
2713 #ifdef HAVE_DW
2714   Dwfl *dwfl = NULL;
2715   Dwfl_Callbacks callbacks = {
2716     .find_elf = dwfl_linux_proc_find_elf,
2717     .find_debuginfo = dwfl_standard_find_debuginfo,
2718   };
2719 
2720   if ((flags &amp; GST_STACK_TRACE_SHOW_FULL))
2721     dwfl = dwfl_begin (&amp;callbacks);
2722 #endif /* HAVE_DW */
2723 
2724   unret = unw_getcontext (&amp;uc);
2725   if (unret) {
2726     GST_DEBUG (&quot;Could not get libunwind context (%d)&quot;, unret);
2727 
2728     goto done;
2729   }
2730   unret = unw_init_local (&amp;cursor, &amp;uc);
2731   if (unret) {
2732     GST_DEBUG (&quot;Could not init libunwind context (%d)&quot;, unret);
2733 
2734     goto done;
2735   }
2736 
2737   while (unw_step (&amp;cursor) &gt; 0) {
2738 #ifdef HAVE_DW
2739     if (dwfl) {
2740       unw_word_t ip;
2741 
2742       unret = unw_get_reg (&amp;cursor, UNW_REG_IP, &amp;ip);
2743       if (unret) {
2744         GST_DEBUG (&quot;libunwind could read frame info (%d)&quot;, unret);
2745 
2746         goto done;
2747       }
2748 
2749       if (append_debug_info (trace, dwfl, (void *) (ip - 4))) {
2750         use_libunwind = FALSE;
2751         g_string_append (trace, &quot;)\n&quot;);
2752       }
2753     }
2754 #endif /* HAVE_DW */
2755 
2756     if (use_libunwind) {
2757       char name[32];
2758 
2759       unw_word_t offset = 0;
2760       unw_get_proc_name (&amp;cursor, name, sizeof (name), &amp;offset);
2761       g_string_append_printf (trace, &quot;%s (0x%&quot; G_GSIZE_FORMAT &quot;)\n&quot;, name,
2762           (gsize) offset);
2763     }
2764   }
2765 
2766 done:
2767 #ifdef HAVE_DW
2768   if (dwfl)
2769     dwfl_end (dwfl);
2770 #endif
2771 
2772   return g_string_free (trace, FALSE);
2773 }
2774 
2775 #endif /* HAVE_UNWIND */
2776 
2777 #ifdef HAVE_BACKTRACE
2778 static gchar *
2779 generate_backtrace_trace (void)
2780 {
2781   int j, nptrs;
2782   void *buffer[BT_BUF_SIZE];
2783   char **strings;
2784   GString *trace;
2785 
2786   trace = g_string_new (NULL);
2787   nptrs = backtrace (buffer, BT_BUF_SIZE);
2788 
2789   strings = backtrace_symbols (buffer, nptrs);
2790 
2791   if (!strings)
2792     return NULL;
2793 
2794   for (j = 0; j &lt; nptrs; j++)
2795     g_string_append_printf (trace, &quot;%s\n&quot;, strings[j]);
2796 
2797   free (strings);
2798 
2799   return g_string_free (trace, FALSE);
2800 }
2801 #else
2802 #define generate_backtrace_trace() NULL
2803 #endif /* HAVE_BACKTRACE */
2804 
2805 #ifdef HAVE_DBGHELP
2806 static void
2807 dbghelp_initialize_symbols (HANDLE process)
2808 {
2809   static gsize initialization_value = 0;
2810 
2811   if (g_once_init_enter (&amp;initialization_value)) {
2812     GST_INFO (&quot;Initializing Windows symbol handler&quot;);
2813     SymSetOptions (SYMOPT_LOAD_LINES);
2814     SymInitialize (process, NULL, TRUE);
2815     GST_INFO (&quot;Initialized Windows symbol handler&quot;);
2816 
2817     g_once_init_leave (&amp;initialization_value, 1);
2818   }
2819 }
2820 
2821 static gchar *
2822 generate_dbghelp_trace (void)
2823 {
2824   HANDLE process = GetCurrentProcess ();
2825   HANDLE thread = GetCurrentThread ();
2826   IMAGEHLP_MODULE64 module_info;
2827   DWORD machine;
2828   CONTEXT context;
2829   STACKFRAME64 frame = { 0 };
2830   PVOID save_context;
2831   GString *trace = g_string_new (NULL);
2832 
2833   dbghelp_initialize_symbols (process);
2834 
2835   memset (&amp;context, 0, sizeof (CONTEXT));
2836   context.ContextFlags = CONTEXT_FULL;
2837 
2838   RtlCaptureContext (&amp;context);
2839 
2840   frame.AddrPC.Mode = AddrModeFlat;
2841   frame.AddrStack.Mode = AddrModeFlat;
2842   frame.AddrFrame.Mode = AddrModeFlat;
2843 
2844 #if (defined _M_IX86)
2845   machine = IMAGE_FILE_MACHINE_I386;
2846   frame.AddrFrame.Offset = context.Ebp;
2847   frame.AddrPC.Offset = context.Eip;
2848   frame.AddrStack.Offset = context.Esp;
2849 #elif (defined _M_X64)
2850   machine = IMAGE_FILE_MACHINE_AMD64;
2851   frame.AddrFrame.Offset = context.Rbp;
2852   frame.AddrPC.Offset = context.Rip;
2853   frame.AddrStack.Offset = context.Rsp;
2854 #else
2855   goto done;
2856 #endif
2857 
2858   module_info.SizeOfStruct = sizeof (module_info);
2859   save_context = (machine == IMAGE_FILE_MACHINE_I386) ? NULL : &amp;context;
2860 
2861   while (TRUE) {
2862     char buffer[sizeof (SYMBOL_INFO) + MAX_SYM_NAME * sizeof (TCHAR)];
2863     PSYMBOL_INFO symbol = (PSYMBOL_INFO) buffer;
2864     IMAGEHLP_LINE64 line;
2865     DWORD displacement = 0;
2866 
2867     symbol-&gt;SizeOfStruct = sizeof (SYMBOL_INFO);
2868     symbol-&gt;MaxNameLen = MAX_SYM_NAME;
2869 
2870     line.SizeOfStruct = sizeof (line);
2871 
2872     if (!StackWalk64 (machine, process, thread, &amp;frame, save_context, 0,
2873             SymFunctionTableAccess64, SymGetModuleBase64, 0))
2874       break;
2875 
2876     if (SymFromAddr (process, frame.AddrPC.Offset, 0, symbol))
2877       g_string_append_printf (trace, &quot;%s &quot;, symbol-&gt;Name);
2878     else
2879       g_string_append (trace, &quot;?? &quot;);
2880 
2881     if (SymGetLineFromAddr64 (process, frame.AddrPC.Offset, &amp;displacement,
2882             &amp;line))
2883       g_string_append_printf (trace, &quot;(%s:%u)&quot;, line.FileName, line.LineNumber);
2884     else if (SymGetModuleInfo64 (process, frame.AddrPC.Offset, &amp;module_info))
2885       g_string_append_printf (trace, &quot;(%s)&quot;, module_info.ImageName);
2886     else
2887       g_string_append_printf (trace, &quot;(%s)&quot;, &quot;??&quot;);
2888 
2889     g_string_append (trace, &quot;\n&quot;);
2890   }
2891 
2892 done:
2893   return g_string_free (trace, FALSE);
2894 }
2895 #endif /* HAVE_DBGHELP */
2896 
2897 /**
2898  * gst_debug_get_stack_trace:
2899  * @flags: A set of #GstStackTraceFlags to determine how the stack
2900  * trace should look like. Pass 0 to retrieve a minimal backtrace.
2901  *
2902  * Returns: (nullable): a stack trace, if libunwind or glibc backtrace are
2903  * present, else %NULL.
2904  *
2905  * Since: 1.12
2906  */
2907 gchar *
2908 gst_debug_get_stack_trace (GstStackTraceFlags flags)
2909 {
2910   gchar *trace = NULL;
2911 #ifdef HAVE_BACKTRACE
2912   gboolean have_backtrace = TRUE;
2913 #else
2914   gboolean have_backtrace = FALSE;
2915 #endif
2916 
2917 #ifdef HAVE_UNWIND
2918   if ((flags &amp; GST_STACK_TRACE_SHOW_FULL) || !have_backtrace)
2919     trace = generate_unwind_trace (flags);
2920 #endif /* HAVE_UNWIND */
2921 
2922 #ifdef HAVE_DBGHELP
2923   trace = generate_dbghelp_trace ();
2924 #endif
2925 
2926   if (trace)
2927     return trace;
2928   else if (have_backtrace)
2929     return generate_backtrace_trace ();
2930 
2931   return NULL;
2932 }
2933 
2934 /**
2935  * gst_debug_print_stack_trace:
2936  *
2937  * If libunwind, glibc backtrace or DbgHelp are present
2938  * a stack trace is printed.
2939  */
2940 void
2941 gst_debug_print_stack_trace (void)
2942 {
2943   gchar *trace = gst_debug_get_stack_trace (GST_STACK_TRACE_SHOW_FULL);
2944 
2945   if (trace)
2946     g_print (&quot;%s\n&quot;, trace);
2947 
2948   g_free (trace);
2949 }
2950 
2951 #ifndef GST_DISABLE_GST_DEBUG
2952 typedef struct
2953 {
2954   guint max_size_per_thread;
2955   guint thread_timeout;
2956   GQueue threads;
2957   GHashTable *thread_index;
2958 } GstRingBufferLogger;
2959 
2960 typedef struct
2961 {
2962   GList *link;
2963   gint64 last_use;
2964   GThread *thread;
2965 
2966   GQueue log;
2967   gsize log_size;
2968 } GstRingBufferLog;
2969 
2970 G_LOCK_DEFINE_STATIC (ring_buffer_logger);
2971 static GstRingBufferLogger *ring_buffer_logger = NULL;
2972 
2973 static void
2974 gst_ring_buffer_logger_log (GstDebugCategory * category,
2975     GstDebugLevel level,
2976     const gchar * file,
2977     const gchar * function,
2978     gint line, GObject * object, GstDebugMessage * message, gpointer user_data)
2979 {
2980   GstRingBufferLogger *logger = user_data;
2981   gint pid;
2982   GThread *thread;
2983   GstClockTime elapsed;
2984   gchar *obj = NULL;
2985   gchar c;
2986   gchar *output;
2987   gsize output_len;
2988   GstRingBufferLog *log;
2989   gint64 now = g_get_monotonic_time ();
2990   const gchar *message_str = gst_debug_message_get (message);
2991 
2992   /* __FILE__ might be a file name or an absolute path or a
2993    * relative path, irrespective of the exact compiler used,
2994    * in which case we want to shorten it to the filename for
2995    * readability. */
2996   c = file[0];
2997   if (c == &#39;.&#39; || c == &#39;/&#39; || c == &#39;\\&#39; || (c != &#39;\0&#39; &amp;&amp; file[1] == &#39;:&#39;)) {
2998     file = gst_path_basename (file);
2999   }
3000 
3001   if (object) {
3002     obj = gst_debug_print_object (object);
3003   } else {
3004     obj = (gchar *) &quot;&quot;;
3005   }
3006 
3007   elapsed = GST_CLOCK_DIFF (_priv_gst_start_time, gst_util_get_timestamp ());
3008   pid = getpid ();
3009   thread = g_thread_self ();
3010 
3011   /* no color, all platforms */
3012 #define PRINT_FMT &quot; &quot;PID_FMT&quot; &quot;PTR_FMT&quot; %s &quot;CAT_FMT&quot; %s\n&quot;
3013   output =
3014       g_strdup_printf (&quot;%&quot; GST_TIME_FORMAT PRINT_FMT, GST_TIME_ARGS (elapsed),
3015       pid, thread, gst_debug_level_get_name (level),
3016       gst_debug_category_get_name (category), file, line, function, obj,
3017       message_str);
3018 #undef PRINT_FMT
3019 
3020   output_len = strlen (output);
3021 
3022   if (object != NULL)
3023     g_free (obj);
3024 
3025   G_LOCK (ring_buffer_logger);
3026 
3027   if (logger-&gt;thread_timeout &gt; 0) {
3028     gchar *buf;
3029 
3030     /* Remove all threads that saw no output since thread_timeout seconds.
3031      * By construction these are all at the tail of the queue, and the queue
3032      * is ordered by last use, so we just need to look at the tail.
3033      */
3034     while (logger-&gt;threads.tail) {
3035       log = logger-&gt;threads.tail-&gt;data;
3036       if (log-&gt;last_use + logger-&gt;thread_timeout * G_USEC_PER_SEC &gt;= now)
3037         break;
3038 
3039       g_hash_table_remove (logger-&gt;thread_index, log-&gt;thread);
3040       while ((buf = g_queue_pop_head (&amp;log-&gt;log)))
3041         g_free (buf);
3042       g_free (log);
3043       g_queue_pop_tail (&amp;logger-&gt;threads);
3044     }
3045   }
3046 
3047   /* Get logger for this thread, and put it back at the
3048    * head of the threads queue */
3049   log = g_hash_table_lookup (logger-&gt;thread_index, thread);
3050   if (!log) {
3051     log = g_new0 (GstRingBufferLog, 1);
3052     g_queue_init (&amp;log-&gt;log);
3053     log-&gt;log_size = 0;
3054     g_queue_push_head (&amp;logger-&gt;threads, log);
3055     log-&gt;link = logger-&gt;threads.head;
3056     log-&gt;thread = thread;
3057     g_hash_table_insert (logger-&gt;thread_index, thread, log);
3058   } else {
3059     g_queue_unlink (&amp;logger-&gt;threads, log-&gt;link);
3060     g_queue_push_head_link (&amp;logger-&gt;threads, log-&gt;link);
3061   }
3062   log-&gt;last_use = now;
3063 
3064   if (output_len &lt; logger-&gt;max_size_per_thread) {
3065     gchar *buf;
3066 
3067     /* While using a GQueue here is not the most efficient thing to do, we
3068      * have to allocate a string for every output anyway and could just store
3069      * that instead of copying it to an actual ringbuffer.
3070      * Better than GQueue would be GstQueueArray, but that one is in
3071      * libgstbase and we can&#39;t use it here. That one allocation will not make
3072      * much of a difference anymore, considering the number of allocations
3073      * needed to get to this point...
3074      */
3075     while (log-&gt;log_size + output_len &gt; logger-&gt;max_size_per_thread) {
3076       buf = g_queue_pop_head (&amp;log-&gt;log);
3077       log-&gt;log_size -= strlen (buf);
3078       g_free (buf);
3079     }
3080     g_queue_push_tail (&amp;log-&gt;log, output);
3081     log-&gt;log_size += output_len;
3082   } else {
3083     gchar *buf;
3084 
3085     /* Can&#39;t really write anything as the line is bigger than the maximum
3086      * allowed log size already, so just remove everything */
3087 
3088     while ((buf = g_queue_pop_head (&amp;log-&gt;log)))
3089       g_free (buf);
3090     g_free (output);
3091     log-&gt;log_size = 0;
3092   }
3093 
3094   G_UNLOCK (ring_buffer_logger);
3095 }
3096 
3097 /**
3098  * gst_debug_ring_buffer_logger_get_logs:
3099  *
3100  * Fetches the current logs per thread from the ring buffer logger. See
3101  * gst_debug_add_ring_buffer_logger() for details.
3102  *
3103  * Returns: (transfer full) (array zero-terminated): NULL-terminated array of
3104  * strings with the debug output per thread
3105  *
3106  * Since: 1.14
3107  */
3108 gchar **
3109 gst_debug_ring_buffer_logger_get_logs (void)
3110 {
3111   gchar **logs, **tmp;
3112   GList *l;
3113 
3114   g_return_val_if_fail (ring_buffer_logger != NULL, NULL);
3115 
3116   G_LOCK (ring_buffer_logger);
3117 
3118   tmp = logs = g_new0 (gchar *, ring_buffer_logger-&gt;threads.length + 1);
3119   for (l = ring_buffer_logger-&gt;threads.head; l; l = l-&gt;next) {
3120     GstRingBufferLog *log = l-&gt;data;
3121     GList *l;
3122     gchar *p;
3123     gsize len;
3124 
3125     *tmp = p = g_new0 (gchar, log-&gt;log_size + 1);
3126 
3127     for (l = log-&gt;log.head; l; l = l-&gt;next) {
3128       len = strlen (l-&gt;data);
3129       memcpy (p, l-&gt;data, len);
3130       p += len;
3131     }
3132 
3133     tmp++;
3134   }
3135 
3136   G_UNLOCK (ring_buffer_logger);
3137 
3138   return logs;
3139 }
3140 
3141 static void
3142 gst_ring_buffer_logger_free (GstRingBufferLogger * logger)
3143 {
3144   G_LOCK (ring_buffer_logger);
3145   if (ring_buffer_logger == logger) {
3146     GstRingBufferLog *log;
3147 
3148     while ((log = g_queue_pop_head (&amp;logger-&gt;threads))) {
3149       gchar *buf;
3150       while ((buf = g_queue_pop_head (&amp;log-&gt;log)))
3151         g_free (buf);
3152       g_free (log);
3153     }
3154 
3155     g_hash_table_unref (logger-&gt;thread_index);
3156 
3157     g_free (logger);
3158     ring_buffer_logger = NULL;
3159   }
3160   G_UNLOCK (ring_buffer_logger);
3161 }
3162 
3163 /**
3164  * gst_debug_add_ring_buffer_logger:
3165  * @max_size_per_thread: Maximum size of log per thread in bytes
3166  * @thread_timeout: Timeout for threads in seconds
3167  *
3168  * Adds a memory ringbuffer based debug logger that stores up to
3169  * @max_size_per_thread bytes of logs per thread and times out threads after
3170  * @thread_timeout seconds of inactivity.
3171  *
3172  * Logs can be fetched with gst_debug_ring_buffer_logger_get_logs() and the
3173  * logger can be removed again with gst_debug_remove_ring_buffer_logger().
3174  * Only one logger at a time is possible.
3175  *
3176  * Since: 1.14
3177  */
3178 void
3179 gst_debug_add_ring_buffer_logger (guint max_size_per_thread,
3180     guint thread_timeout)
3181 {
3182   GstRingBufferLogger *logger;
3183 
3184   G_LOCK (ring_buffer_logger);
3185 
3186   if (ring_buffer_logger) {
3187     g_warn_if_reached ();
3188     G_UNLOCK (ring_buffer_logger);
3189     return;
3190   }
3191 
3192   logger = ring_buffer_logger = g_new0 (GstRingBufferLogger, 1);
3193 
3194   logger-&gt;max_size_per_thread = max_size_per_thread;
3195   logger-&gt;thread_timeout = thread_timeout;
3196   logger-&gt;thread_index = g_hash_table_new (g_direct_hash, g_direct_equal);
3197   g_queue_init (&amp;logger-&gt;threads);
3198 
3199   gst_debug_add_log_function (gst_ring_buffer_logger_log, logger,
3200       (GDestroyNotify) gst_ring_buffer_logger_free);
3201   G_UNLOCK (ring_buffer_logger);
3202 }
3203 
3204 /**
3205  * gst_debug_remove_ring_buffer_logger:
3206  *
3207  * Removes any previously added ring buffer logger with
3208  * gst_debug_add_ring_buffer_logger().
3209  *
3210  * Since: 1.14
3211  */
3212 void
3213 gst_debug_remove_ring_buffer_logger (void)
3214 {
3215   gst_debug_remove_log_function (gst_ring_buffer_logger_log);
3216 }
3217 
3218 #else /* GST_DISABLE_GST_DEBUG */
3219 #ifndef GST_REMOVE_DISABLED
3220 
3221 gchar **
3222 gst_debug_ring_buffer_logger_get_logs (void)
3223 {
3224   return NULL;
3225 }
3226 
3227 void
3228 gst_debug_add_ring_buffer_logger (guint max_size_per_thread,
3229     guint thread_timeout)
3230 {
3231 }
3232 
3233 void
3234 gst_debug_remove_ring_buffer_logger (void)
3235 {
3236 }
3237 
3238 #endif /* GST_REMOVE_DISABLED */
3239 #endif /* GST_DISABLE_GST_DEBUG */
    </pre>
  </body>
</html>