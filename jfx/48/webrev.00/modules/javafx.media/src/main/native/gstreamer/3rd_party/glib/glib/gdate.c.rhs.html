<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gdate.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 #include &quot;glibconfig.h&quot;
  31 
<a name="1" id="anc1"></a><span class="line-modified">  32 #define DEBUG_MSG(x)  /* */</span>
  33 #ifdef G_ENABLE_DEBUG
  34 /* #define DEBUG_MSG(args)  g_message args ; */
  35 #endif
  36 
  37 #include &lt;time.h&gt;
  38 #include &lt;string.h&gt;
  39 #include &lt;stdlib.h&gt;
  40 #include &lt;locale.h&gt;
  41 
  42 #ifdef G_OS_WIN32
  43 #include &lt;windows.h&gt;
  44 #endif
  45 
  46 #include &quot;gdate.h&quot;
  47 
  48 #include &quot;gconvert.h&quot;
  49 #include &quot;gmem.h&quot;
  50 #include &quot;gstrfuncs.h&quot;
  51 #include &quot;gtestutils.h&quot;
  52 #include &quot;gthread.h&quot;
  53 #include &quot;gunicode.h&quot;
  54 
  55 #ifdef G_OS_WIN32
  56 #include &quot;garray.h&quot;
  57 #endif
  58 
  59 /**
  60  * SECTION:date
  61  * @title: Date and Time Functions
  62  * @short_description: calendrical calculations and miscellaneous time stuff
  63  *
  64  * The #GDate data structure represents a day between January 1, Year 1,
  65  * and sometime a few thousand years in the future (right now it will go
  66  * to the year 65535 or so, but g_date_set_parse() only parses up to the
  67  * year 8000 or so - just count on &quot;a few thousand&quot;). #GDate is meant to
  68  * represent everyday dates, not astronomical dates or historical dates
  69  * or ISO timestamps or the like. It extrapolates the current Gregorian
  70  * calendar forward and backward in time; there is no attempt to change
  71  * the calendar to match time periods or locations. #GDate does not store
  72  * time information; it represents a day.
  73  *
  74  * The #GDate implementation has several nice features; it is only a
  75  * 64-bit struct, so storing large numbers of dates is very efficient. It
  76  * can keep both a Julian and day-month-year representation of the date,
  77  * since some calculations are much easier with one representation or the
  78  * other. A Julian representation is simply a count of days since some
  79  * fixed day in the past; for #GDate the fixed day is January 1, 1 AD.
  80  * (&quot;Julian&quot; dates in the #GDate API aren&#39;t really Julian dates in the
  81  * technical sense; technically, Julian dates count from the start of the
  82  * Julian period, Jan 1, 4713 BC).
  83  *
  84  * #GDate is simple to use. First you need a &quot;blank&quot; date; you can get a
  85  * dynamically allocated date from g_date_new(), or you can declare an
  86  * automatic variable or array and initialize it to a sane state by
  87  * calling g_date_clear(). A cleared date is sane; it&#39;s safe to call
  88  * g_date_set_dmy() and the other mutator functions to initialize the
  89  * value of a cleared date. However, a cleared date is initially
  90  * invalid, meaning that it doesn&#39;t represent a day that exists.
  91  * It is undefined to call any of the date calculation routines on an
  92  * invalid date. If you obtain a date from a user or other
  93  * unpredictable source, you should check its validity with the
  94  * g_date_valid() predicate. g_date_valid() is also used to check for
  95  * errors with g_date_set_parse() and other functions that can
  96  * fail. Dates can be invalidated by calling g_date_clear() again.
  97  *
  98  * It is very important to use the API to access the #GDate
  99  * struct. Often only the day-month-year or only the Julian
 100  * representation is valid. Sometimes neither is valid. Use the API.
 101  *
 102  * GLib also features #GDateTime which represents a precise time.
 103  */
 104 
 105 /**
 106  * G_USEC_PER_SEC:
 107  *
 108  * Number of microseconds in one second (1 million).
 109  * This macro is provided for code readability.
 110  */
 111 
 112 /**
 113  * GTimeVal:
 114  * @tv_sec: seconds
 115  * @tv_usec: microseconds
 116  *
 117  * Represents a precise time, with seconds and microseconds.
 118  * Similar to the struct timeval returned by the gettimeofday()
 119  * UNIX system call.
 120  *
<a name="2" id="anc2"></a><span class="line-modified"> 121  * GLib is attempting to unify around the use of 64-bit integers to</span>
 122  * represent microsecond-precision time. As such, this type will be
 123  * removed from a future version of GLib. A consequence of using `glong` for
 124  * `tv_sec` is that on 32-bit systems `GTimeVal` is subject to the year 2038
 125  * problem.
<a name="3" id="anc3"></a><span class="line-added"> 126  *</span>
<span class="line-added"> 127  * Deprecated: 2.62: Use #GDateTime or #guint64 instead.</span>
 128  */
 129 
 130 /**
 131  * GDate:
 132  * @julian_days: the Julian representation of the date
 133  * @julian: this bit is set if @julian_days is valid
 134  * @dmy: this is set if @day, @month and @year are valid
 135  * @day: the day of the day-month-year representation of the date,
 136  *     as a number between 1 and 31
 137  * @month: the day of the day-month-year representation of the date,
 138  *     as a number between 1 and 12
 139  * @year: the day of the day-month-year representation of the date
 140  *
 141  * Represents a day between January 1, Year 1 and a few thousand years in
 142  * the future. None of its members should be accessed directly.
 143  *
 144  * If the #GDate-struct is obtained from g_date_new(), it will be safe
 145  * to mutate but invalid and thus not safe for calendrical computations.
 146  *
 147  * If it&#39;s declared on the stack, it will contain garbage so must be
 148  * initialized with g_date_clear(). g_date_clear() makes the date invalid
 149  * but sane. An invalid date doesn&#39;t represent a day, it&#39;s &quot;empty.&quot; A date
 150  * becomes valid after you set it to a Julian day or you set a day, month,
 151  * and year.
 152  */
 153 
 154 /**
 155  * GTime:
 156  *
<a name="4" id="anc4"></a><span class="line-modified"> 157  * Simply a replacement for `time_t`. It has been deprecated</span>
<span class="line-modified"> 158  * since it is not equivalent to `time_t` on 64-bit platforms</span>
<span class="line-modified"> 159  * with a 64-bit `time_t`. Unrelated to #GTimer.</span>
 160  *
 161  * Note that #GTime is defined to always be a 32-bit integer,
<a name="5" id="anc5"></a><span class="line-modified"> 162  * unlike `time_t` which may be 64-bit on some systems. Therefore,</span>
 163  * #GTime will overflow in the year 2038, and you cannot use the
 164  * address of a #GTime variable as argument to the UNIX time()
 165  * function.
 166  *
 167  * Instead, do the following:
 168  * |[&lt;!-- language=&quot;C&quot; --&gt;
 169  * time_t ttime;
 170  * GTime gtime;
 171  *
 172  * time (&amp;ttime);
 173  * gtime = (GTime)ttime;
 174  * ]|
<a name="6" id="anc6"></a><span class="line-added"> 175  *</span>
<span class="line-added"> 176  * Deprecated: 2.62: This is not [Y2038-safe](https://en.wikipedia.org/wiki/Year_2038_problem).</span>
<span class="line-added"> 177  *    Use #GDateTime or #time_t instead.</span>
 178  */
 179 
 180 /**
 181  * GDateDMY:
 182  * @G_DATE_DAY: a day
 183  * @G_DATE_MONTH: a month
 184  * @G_DATE_YEAR: a year
 185  *
 186  * This enumeration isn&#39;t used in the API, but may be useful if you need
 187  * to mark a number as a day, month, or year.
 188  */
 189 
 190 /**
 191  * GDateDay:
 192  *
 193  * Integer representing a day of the month; between 1 and 31.
 194  * #G_DATE_BAD_DAY represents an invalid day of the month.
 195  */
 196 
 197 /**
 198  * GDateMonth:
 199  * @G_DATE_BAD_MONTH: invalid value
 200  * @G_DATE_JANUARY: January
 201  * @G_DATE_FEBRUARY: February
 202  * @G_DATE_MARCH: March
 203  * @G_DATE_APRIL: April
 204  * @G_DATE_MAY: May
 205  * @G_DATE_JUNE: June
 206  * @G_DATE_JULY: July
 207  * @G_DATE_AUGUST: August
 208  * @G_DATE_SEPTEMBER: September
 209  * @G_DATE_OCTOBER: October
 210  * @G_DATE_NOVEMBER: November
 211  * @G_DATE_DECEMBER: December
 212  *
 213  * Enumeration representing a month; values are #G_DATE_JANUARY,
 214  * #G_DATE_FEBRUARY, etc. #G_DATE_BAD_MONTH is the invalid value.
 215  */
 216 
 217 /**
 218  * GDateYear:
 219  *
 220  * Integer representing a year; #G_DATE_BAD_YEAR is the invalid
 221  * value. The year must be 1 or higher; negative (BC) years are not
 222  * allowed. The year is represented with four digits.
 223  */
 224 
 225 /**
 226  * GDateWeekday:
 227  * @G_DATE_BAD_WEEKDAY: invalid value
 228  * @G_DATE_MONDAY: Monday
 229  * @G_DATE_TUESDAY: Tuesday
 230  * @G_DATE_WEDNESDAY: Wednesday
 231  * @G_DATE_THURSDAY: Thursday
 232  * @G_DATE_FRIDAY: Friday
 233  * @G_DATE_SATURDAY: Saturday
 234  * @G_DATE_SUNDAY: Sunday
 235  *
 236  * Enumeration representing a day of the week; #G_DATE_MONDAY,
 237  * #G_DATE_TUESDAY, etc. #G_DATE_BAD_WEEKDAY is an invalid weekday.
 238  */
 239 
 240 /**
 241  * G_DATE_BAD_DAY:
 242  *
 243  * Represents an invalid #GDateDay.
 244  */
 245 
 246 /**
 247  * G_DATE_BAD_JULIAN:
 248  *
 249  * Represents an invalid Julian day number.
 250  */
 251 
 252 /**
 253  * G_DATE_BAD_YEAR:
 254  *
 255  * Represents an invalid year.
 256  */
 257 
 258 /**
 259  * g_date_new:
 260  *
 261  * Allocates a #GDate and initializes
 262  * it to a sane state. The new date will
 263  * be cleared (as if you&#39;d called g_date_clear()) but invalid (it won&#39;t
 264  * represent an existing day). Free the return value with g_date_free().
 265  *
 266  * Returns: a newly-allocated #GDate
 267  */
 268 GDate*
 269 g_date_new (void)
 270 {
 271   GDate *d = g_new0 (GDate, 1); /* happily, 0 is the invalid flag for everything. */
 272 
 273   return d;
 274 }
 275 
 276 /**
 277  * g_date_new_dmy:
 278  * @day: day of the month
 279  * @month: month of the year
 280  * @year: year
 281  *
 282  * Like g_date_new(), but also sets the value of the date. Assuming the
 283  * day-month-year triplet you pass in represents an existing day, the
 284  * returned date will be valid.
 285  *
 286  * Returns: a newly-allocated #GDate initialized with @day, @month, and @year
 287  */
 288 GDate*
 289 g_date_new_dmy (GDateDay   day,
 290                 GDateMonth m,
 291                 GDateYear  y)
 292 {
 293   GDate *d;
 294   g_return_val_if_fail (g_date_valid_dmy (day, m, y), NULL);
 295 
 296   d = g_new (GDate, 1);
 297 
 298   d-&gt;julian = FALSE;
 299   d-&gt;dmy    = TRUE;
 300 
 301   d-&gt;month = m;
 302   d-&gt;day   = day;
 303   d-&gt;year  = y;
 304 
 305   g_assert (g_date_valid (d));
 306 
 307   return d;
 308 }
 309 
 310 /**
 311  * g_date_new_julian:
 312  * @julian_day: days since January 1, Year 1
 313  *
 314  * Like g_date_new(), but also sets the value of the date. Assuming the
 315  * Julian day number you pass in is valid (greater than 0, less than an
 316  * unreasonably large number), the returned date will be valid.
 317  *
 318  * Returns: a newly-allocated #GDate initialized with @julian_day
 319  */
 320 GDate*
 321 g_date_new_julian (guint32 julian_day)
 322 {
 323   GDate *d;
 324   g_return_val_if_fail (g_date_valid_julian (julian_day), NULL);
 325 
 326   d = g_new (GDate, 1);
 327 
 328   d-&gt;julian = TRUE;
 329   d-&gt;dmy    = FALSE;
 330 
 331   d-&gt;julian_days = julian_day;
 332 
 333   g_assert (g_date_valid (d));
 334 
 335   return d;
 336 }
 337 
 338 /**
 339  * g_date_free:
 340  * @date: a #GDate to free
 341  *
 342  * Frees a #GDate returned from g_date_new().
 343  */
 344 void
 345 g_date_free (GDate *date)
 346 {
 347   g_return_if_fail (date != NULL);
 348 
 349   g_free (date);
 350 }
 351 
 352 /**
 353  * g_date_copy:
 354  * @date: a #GDate to copy
 355  *
 356  * Copies a GDate to a newly-allocated GDate. If the input was invalid
 357  * (as determined by g_date_valid()), the invalid state will be copied
 358  * as is into the new object.
 359  *
 360  * Returns: (transfer full): a newly-allocated #GDate initialized from @date
 361  *
 362  * Since: 2.56
 363  */
 364 GDate *
 365 g_date_copy (const GDate *date)
 366 {
 367   GDate *res;
 368   g_return_val_if_fail (date != NULL, NULL);
 369 
 370   if (g_date_valid (date))
 371     res = g_date_new_julian (g_date_get_julian (date));
 372   else
 373     {
 374       res = g_date_new ();
 375       *res = *date;
 376     }
 377 
 378   return res;
 379 }
 380 
 381 /**
 382  * g_date_valid:
 383  * @date: a #GDate to check
 384  *
 385  * Returns %TRUE if the #GDate represents an existing day. The date must not
 386  * contain garbage; it should have been initialized with g_date_clear()
 387  * if it wasn&#39;t allocated by one of the g_date_new() variants.
 388  *
 389  * Returns: Whether the date is valid
 390  */
 391 gboolean
 392 g_date_valid (const GDate *d)
 393 {
 394   g_return_val_if_fail (d != NULL, FALSE);
 395 
 396   return (d-&gt;julian || d-&gt;dmy);
 397 }
 398 
 399 static const guint8 days_in_months[2][13] =
 400 {  /* error, jan feb mar apr may jun jul aug sep oct nov dec */
 401   {  0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
 402   {  0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 } /* leap year */
 403 };
 404 
 405 static const guint16 days_in_year[2][14] =
 406 {  /* 0, jan feb mar apr may  jun  jul  aug  sep  oct  nov  dec */
 407   {  0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
 408   {  0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 }
 409 };
 410 
 411 /**
 412  * g_date_valid_month:
 413  * @month: month
 414  *
 415  * Returns %TRUE if the month value is valid. The 12 #GDateMonth
 416  * enumeration values are the only valid months.
 417  *
 418  * Returns: %TRUE if the month is valid
 419  */
 420 gboolean
 421 g_date_valid_month (GDateMonth m)
 422 {
 423   return ( (m &gt; G_DATE_BAD_MONTH) &amp;&amp; (m &lt; 13) );
 424 }
 425 
 426 /**
 427  * g_date_valid_year:
 428  * @year: year
 429  *
 430  * Returns %TRUE if the year is valid. Any year greater than 0 is valid,
 431  * though there is a 16-bit limit to what #GDate will understand.
 432  *
 433  * Returns: %TRUE if the year is valid
 434  */
 435 gboolean
 436 g_date_valid_year (GDateYear y)
 437 {
 438   return ( y &gt; G_DATE_BAD_YEAR );
 439 }
 440 
 441 /**
 442  * g_date_valid_day:
 443  * @day: day to check
 444  *
 445  * Returns %TRUE if the day of the month is valid (a day is valid if it&#39;s
 446  * between 1 and 31 inclusive).
 447  *
 448  * Returns: %TRUE if the day is valid
 449  */
 450 
 451 gboolean
 452 g_date_valid_day (GDateDay d)
 453 {
 454   return ( (d &gt; G_DATE_BAD_DAY) &amp;&amp; (d &lt; 32) );
 455 }
 456 
 457 /**
 458  * g_date_valid_weekday:
 459  * @weekday: weekday
 460  *
 461  * Returns %TRUE if the weekday is valid. The seven #GDateWeekday enumeration
 462  * values are the only valid weekdays.
 463  *
 464  * Returns: %TRUE if the weekday is valid
 465  */
 466 gboolean
 467 g_date_valid_weekday (GDateWeekday w)
 468 {
 469   return ( (w &gt; G_DATE_BAD_WEEKDAY) &amp;&amp; (w &lt; 8) );
 470 }
 471 
 472 /**
 473  * g_date_valid_julian:
 474  * @julian_date: Julian day to check
 475  *
 476  * Returns %TRUE if the Julian day is valid. Anything greater than zero
 477  * is basically a valid Julian, though there is a 32-bit limit.
 478  *
 479  * Returns: %TRUE if the Julian day is valid
 480  */
 481 gboolean
 482 g_date_valid_julian (guint32 j)
 483 {
 484   return (j &gt; G_DATE_BAD_JULIAN);
 485 }
 486 
 487 /**
 488  * g_date_valid_dmy:
 489  * @day: day
 490  * @month: month
 491  * @year: year
 492  *
 493  * Returns %TRUE if the day-month-year triplet forms a valid, existing day
 494  * in the range of days #GDate understands (Year 1 or later, no more than
 495  * a few thousand years in the future).
 496  *
 497  * Returns: %TRUE if the date is a valid one
 498  */
 499 gboolean
 500 g_date_valid_dmy (GDateDay   d,
 501                   GDateMonth m,
<a name="7" id="anc7"></a><span class="line-modified"> 502       GDateYear  y)</span>
 503 {
 504   /* No need to check the upper bound of @y, because #GDateYear is 16 bits wide,
 505    * just like #GDate.year. */
 506   return ( (m &gt; G_DATE_BAD_MONTH) &amp;&amp;
 507            (m &lt; 13)               &amp;&amp;
 508            (d &gt; G_DATE_BAD_DAY)   &amp;&amp;
 509            (y &gt; G_DATE_BAD_YEAR)  &amp;&amp;   /* must check before using g_date_is_leap_year */
 510            (d &lt;=  (g_date_is_leap_year (y) ?
<a name="8" id="anc8"></a><span class="line-modified"> 511        days_in_months[1][m] : days_in_months[0][m])) );</span>
 512 }
 513 
 514 
 515 /* &quot;Julian days&quot; just means an absolute number of days, where Day 1 ==
 516  *   Jan 1, Year 1
 517  */
 518 static void
 519 g_date_update_julian (const GDate *const_d)
 520 {
 521   GDate *d = (GDate *) const_d;
 522   GDateYear year;
 523   gint idx;
 524 
 525   g_return_if_fail (d != NULL);
 526   g_return_if_fail (d-&gt;dmy != 0);
 527   g_return_if_fail (!d-&gt;julian);
 528   g_return_if_fail (g_date_valid_dmy (d-&gt;day, d-&gt;month, d-&gt;year));
 529 
 530   /* What we actually do is: multiply years * 365 days in the year,
 531    * add the number of years divided by 4, subtract the number of
 532    * years divided by 100 and add the number of years divided by 400,
 533    * which accounts for leap year stuff. Code from Steffen Beyer&#39;s
 534    * DateCalc.
 535    */
 536 
 537   year = d-&gt;year - 1; /* we know d-&gt;year &gt; 0 since it&#39;s valid */
 538 
 539   d-&gt;julian_days = year * 365U;
 540   d-&gt;julian_days += (year &gt;&gt;= 2); /* divide by 4 and add */
 541   d-&gt;julian_days -= (year /= 25); /* divides original # years by 100 */
 542   d-&gt;julian_days += year &gt;&gt; 2;    /* divides by 4, which divides original by 400 */
 543 
 544   idx = g_date_is_leap_year (d-&gt;year) ? 1 : 0;
 545 
 546   d-&gt;julian_days += days_in_year[idx][d-&gt;month] + d-&gt;day;
 547 
 548   g_return_if_fail (g_date_valid_julian (d-&gt;julian_days));
 549 
 550   d-&gt;julian = TRUE;
 551 }
 552 
 553 static void
 554 g_date_update_dmy (const GDate *const_d)
 555 {
 556   GDate *d = (GDate *) const_d;
 557   GDateYear y;
 558   GDateMonth m;
 559   GDateDay day;
 560 
 561   guint32 A, B, C, D, E, M;
 562 
 563   g_return_if_fail (d != NULL);
 564   g_return_if_fail (d-&gt;julian);
 565   g_return_if_fail (!d-&gt;dmy);
 566   g_return_if_fail (g_date_valid_julian (d-&gt;julian_days));
 567 
 568   /* Formula taken from the Calendar FAQ; the formula was for the
 569    *  Julian Period which starts on 1 January 4713 BC, so we add
 570    *  1,721,425 to the number of days before doing the formula.
 571    *
 572    * I&#39;m sure this can be simplified for our 1 January 1 AD period
 573    * start, but I can&#39;t figure out how to unpack the formula.
 574    */
 575 
 576   A = d-&gt;julian_days + 1721425 + 32045;
 577   B = ( 4 *(A + 36524) )/ 146097 - 1;
 578   C = A - (146097 * B)/4;
 579   D = ( 4 * (C + 365) ) / 1461 - 1;
 580   E = C - ((1461*D) / 4);
 581   M = (5 * (E - 1) + 2)/153;
 582 
 583   m = M + 3 - (12*(M/10));
 584   day = E - (153*M + 2)/5;
 585   y = 100 * B + D - 4800 + (M/10);
 586 
 587 #ifdef G_ENABLE_DEBUG
 588   if (!g_date_valid_dmy (day, m, y))
 589     g_warning (&quot;OOPS julian: %u  computed dmy: %u %u %u&quot;,
<a name="9" id="anc9"></a><span class="line-modified"> 590          d-&gt;julian_days, day, m, y);</span>
 591 #endif
 592 
 593   d-&gt;month = m;
 594   d-&gt;day   = day;
 595   d-&gt;year  = y;
 596 
 597   d-&gt;dmy = TRUE;
 598 }
 599 
 600 /**
 601  * g_date_get_weekday:
 602  * @date: a #GDate
 603  *
 604  * Returns the day of the week for a #GDate. The date must be valid.
 605  *
 606  * Returns: day of the week as a #GDateWeekday.
 607  */
 608 GDateWeekday
 609 g_date_get_weekday (const GDate *d)
 610 {
 611   g_return_val_if_fail (g_date_valid (d), G_DATE_BAD_WEEKDAY);
 612 
 613   if (!d-&gt;julian)
 614     g_date_update_julian (d);
 615 
 616   g_return_val_if_fail (d-&gt;julian, G_DATE_BAD_WEEKDAY);
 617 
 618   return ((d-&gt;julian_days - 1) % 7) + 1;
 619 }
 620 
 621 /**
 622  * g_date_get_month:
 623  * @date: a #GDate to get the month from
 624  *
 625  * Returns the month of the year. The date must be valid.
 626  *
 627  * Returns: month of the year as a #GDateMonth
 628  */
 629 GDateMonth
 630 g_date_get_month (const GDate *d)
 631 {
 632   g_return_val_if_fail (g_date_valid (d), G_DATE_BAD_MONTH);
 633 
 634   if (!d-&gt;dmy)
 635     g_date_update_dmy (d);
 636 
 637   g_return_val_if_fail (d-&gt;dmy, G_DATE_BAD_MONTH);
 638 
 639   return d-&gt;month;
 640 }
 641 
 642 /**
 643  * g_date_get_year:
 644  * @date: a #GDate
 645  *
 646  * Returns the year of a #GDate. The date must be valid.
 647  *
 648  * Returns: year in which the date falls
 649  */
 650 GDateYear
 651 g_date_get_year (const GDate *d)
 652 {
 653   g_return_val_if_fail (g_date_valid (d), G_DATE_BAD_YEAR);
 654 
 655   if (!d-&gt;dmy)
 656     g_date_update_dmy (d);
 657 
 658   g_return_val_if_fail (d-&gt;dmy, G_DATE_BAD_YEAR);
 659 
 660   return d-&gt;year;
 661 }
 662 
 663 /**
 664  * g_date_get_day:
 665  * @date: a #GDate to extract the day of the month from
 666  *
 667  * Returns the day of the month. The date must be valid.
 668  *
 669  * Returns: day of the month
 670  */
 671 GDateDay
 672 g_date_get_day (const GDate *d)
 673 {
 674   g_return_val_if_fail (g_date_valid (d), G_DATE_BAD_DAY);
 675 
 676   if (!d-&gt;dmy)
 677     g_date_update_dmy (d);
 678 
 679   g_return_val_if_fail (d-&gt;dmy, G_DATE_BAD_DAY);
 680 
 681   return d-&gt;day;
 682 }
 683 
 684 /**
 685  * g_date_get_julian:
 686  * @date: a #GDate to extract the Julian day from
 687  *
 688  * Returns the Julian day or &quot;serial number&quot; of the #GDate. The
 689  * Julian day is simply the number of days since January 1, Year 1; i.e.,
 690  * January 1, Year 1 is Julian day 1; January 2, Year 1 is Julian day 2,
 691  * etc. The date must be valid.
 692  *
 693  * Returns: Julian day
 694  */
 695 guint32
 696 g_date_get_julian (const GDate *d)
 697 {
 698   g_return_val_if_fail (g_date_valid (d), G_DATE_BAD_JULIAN);
 699 
 700   if (!d-&gt;julian)
 701     g_date_update_julian (d);
 702 
 703   g_return_val_if_fail (d-&gt;julian, G_DATE_BAD_JULIAN);
 704 
 705   return d-&gt;julian_days;
 706 }
 707 
 708 /**
 709  * g_date_get_day_of_year:
 710  * @date: a #GDate to extract day of year from
 711  *
 712  * Returns the day of the year, where Jan 1 is the first day of the
 713  * year. The date must be valid.
 714  *
 715  * Returns: day of the year
 716  */
 717 guint
 718 g_date_get_day_of_year (const GDate *d)
 719 {
 720   gint idx;
 721 
 722   g_return_val_if_fail (g_date_valid (d), 0);
 723 
 724   if (!d-&gt;dmy)
 725     g_date_update_dmy (d);
 726 
 727   g_return_val_if_fail (d-&gt;dmy, 0);
 728 
 729   idx = g_date_is_leap_year (d-&gt;year) ? 1 : 0;
 730 
 731   return (days_in_year[idx][d-&gt;month] + d-&gt;day);
 732 }
 733 
 734 /**
 735  * g_date_get_monday_week_of_year:
 736  * @date: a #GDate
 737  *
 738  * Returns the week of the year, where weeks are understood to start on
 739  * Monday. If the date is before the first Monday of the year, return 0.
 740  * The date must be valid.
 741  *
 742  * Returns: week of the year
 743  */
 744 guint
 745 g_date_get_monday_week_of_year (const GDate *d)
 746 {
 747   GDateWeekday wd;
 748   guint day;
 749   GDate first;
 750 
 751   g_return_val_if_fail (g_date_valid (d), 0);
 752 
 753   if (!d-&gt;dmy)
 754     g_date_update_dmy (d);
 755 
 756   g_return_val_if_fail (d-&gt;dmy, 0);
 757 
 758   g_date_clear (&amp;first, 1);
 759 
 760   g_date_set_dmy (&amp;first, 1, 1, d-&gt;year);
 761 
 762   wd = g_date_get_weekday (&amp;first) - 1; /* make Monday day 0 */
 763   day = g_date_get_day_of_year (d) - 1;
 764 
 765   return ((day + wd)/7U + (wd == 0 ? 1 : 0));
 766 }
 767 
 768 /**
 769  * g_date_get_sunday_week_of_year:
 770  * @date: a #GDate
 771  *
 772  * Returns the week of the year during which this date falls, if
 773  * weeks are understood to begin on Sunday. The date must be valid.
 774  * Can return 0 if the day is before the first Sunday of the year.
 775  *
 776  * Returns: week number
 777  */
 778 guint
 779 g_date_get_sunday_week_of_year (const GDate *d)
 780 {
 781   GDateWeekday wd;
 782   guint day;
 783   GDate first;
 784 
 785   g_return_val_if_fail (g_date_valid (d), 0);
 786 
 787   if (!d-&gt;dmy)
 788     g_date_update_dmy (d);
 789 
 790   g_return_val_if_fail (d-&gt;dmy, 0);
 791 
 792   g_date_clear (&amp;first, 1);
 793 
 794   g_date_set_dmy (&amp;first, 1, 1, d-&gt;year);
 795 
 796   wd = g_date_get_weekday (&amp;first);
 797   if (wd == 7) wd = 0; /* make Sunday day 0 */
 798   day = g_date_get_day_of_year (d) - 1;
 799 
 800   return ((day + wd)/7U + (wd == 0 ? 1 : 0));
 801 }
 802 
 803 /**
 804  * g_date_get_iso8601_week_of_year:
 805  * @date: a valid #GDate
 806  *
 807  * Returns the week of the year, where weeks are interpreted according
 808  * to ISO 8601.
 809  *
 810  * Returns: ISO 8601 week number of the year.
 811  *
 812  * Since: 2.6
 813  **/
 814 guint
 815 g_date_get_iso8601_week_of_year (const GDate *d)
 816 {
 817   guint j, d4, L, d1, w;
 818 
 819   g_return_val_if_fail (g_date_valid (d), 0);
 820 
 821   if (!d-&gt;julian)
 822     g_date_update_julian (d);
 823 
 824   g_return_val_if_fail (d-&gt;julian, 0);
 825 
 826   /* Formula taken from the Calendar FAQ; the formula was for the
 827    * Julian Period which starts on 1 January 4713 BC, so we add
 828    * 1,721,425 to the number of days before doing the formula.
 829    */
 830   j  = d-&gt;julian_days + 1721425;
 831   d4 = (j + 31741 - (j % 7)) % 146097 % 36524 % 1461;
 832   L  = d4 / 1460;
 833   d1 = ((d4 - L) % 365) + L;
 834   w  = d1 / 7 + 1;
 835 
 836   return w;
 837 }
 838 
 839 /**
 840  * g_date_days_between:
 841  * @date1: the first date
 842  * @date2: the second date
 843  *
 844  * Computes the number of days between two dates.
 845  * If @date2 is prior to @date1, the returned value is negative.
 846  * Both dates must be valid.
 847  *
 848  * Returns: the number of days between @date1 and @date2
 849  */
 850 gint
 851 g_date_days_between (const GDate *d1,
<a name="10" id="anc10"></a><span class="line-modified"> 852          const GDate *d2)</span>
 853 {
 854   g_return_val_if_fail (g_date_valid (d1), 0);
 855   g_return_val_if_fail (g_date_valid (d2), 0);
 856 
 857   return (gint)g_date_get_julian (d2) - (gint)g_date_get_julian (d1);
 858 }
 859 
 860 /**
 861  * g_date_clear:
 862  * @date: pointer to one or more dates to clear
 863  * @n_dates: number of dates to clear
 864  *
 865  * Initializes one or more #GDate structs to a sane but invalid
 866  * state. The cleared dates will not represent an existing date, but will
 867  * not contain garbage. Useful to init a date declared on the stack.
 868  * Validity can be tested with g_date_valid().
 869  */
 870 void
 871 g_date_clear (GDate *d, guint ndates)
 872 {
 873   g_return_if_fail (d != NULL);
 874   g_return_if_fail (ndates != 0);
 875 
 876   memset (d, 0x0, ndates*sizeof (GDate));
 877 }
 878 
 879 G_LOCK_DEFINE_STATIC (g_date_global);
 880 
 881 /* These are for the parser, output to the user should use *
 882  * g_date_strftime () - this creates more never-freed memory to annoy
 883  * all those memory debugger users. :-)
 884  */
 885 
 886 static gchar *long_month_names[13] =
 887 {
 888   NULL,
 889 };
 890 
 891 static gchar *long_month_names_alternative[13] =
 892 {
 893   NULL,
 894 };
 895 
 896 static gchar *short_month_names[13] =
 897 {
 898   NULL,
 899 };
 900 
 901 static gchar *short_month_names_alternative[13] =
 902 {
 903   NULL,
 904 };
 905 
 906 /* This tells us if we need to update the parse info */
 907 static gchar *current_locale = NULL;
 908 
 909 /* order of these in the current locale */
 910 static GDateDMY dmy_order[3] =
 911 {
 912    G_DATE_DAY, G_DATE_MONTH, G_DATE_YEAR
 913 };
 914 
 915 /* Where to chop two-digit years: i.e., for the 1930 default, numbers
 916  * 29 and below are counted as in the year 2000, numbers 30 and above
 917  * are counted as in the year 1900.
 918  */
 919 
 920 static const GDateYear twodigit_start_year = 1930;
 921 
 922 /* It is impossible to enter a year between 1 AD and 99 AD with this
 923  * in effect.
 924  */
 925 static gboolean using_twodigit_years = FALSE;
 926 
 927 /* Adjustment of locale era to AD, non-zero means using locale era
 928  */
 929 static gint locale_era_adjust = 0;
 930 
 931 struct _GDateParseTokens {
 932   gint num_ints;
 933   gint n[3];
 934   guint month;
 935 };
 936 
 937 typedef struct _GDateParseTokens GDateParseTokens;
 938 
 939 static inline gboolean
 940 update_month_match (gsize *longest,
 941                     const gchar *haystack,
 942                     const gchar *needle)
 943 {
 944   gsize length;
 945 
 946   if (needle == NULL)
 947     return FALSE;
 948 
 949   length = strlen (needle);
 950   if (*longest &gt;= length)
 951     return FALSE;
 952 
 953   if (strstr (haystack, needle) == NULL)
 954     return FALSE;
 955 
 956   *longest = length;
 957   return TRUE;
 958 }
 959 
 960 #define NUM_LEN 10
 961 
 962 /* HOLDS: g_date_global_lock */
 963 static void
 964 g_date_fill_parse_tokens (const gchar *str, GDateParseTokens *pt)
 965 {
 966   gchar num[4][NUM_LEN+1];
 967   gint i;
 968   const guchar *s;
 969 
 970   /* We count 4, but store 3; so we can give an error
 971    * if there are 4.
 972    */
 973   num[0][0] = num[1][0] = num[2][0] = num[3][0] = &#39;\0&#39;;
 974 
 975   s = (const guchar *) str;
 976   pt-&gt;num_ints = 0;
 977   while (*s &amp;&amp; pt-&gt;num_ints &lt; 4)
 978     {
 979 
 980       i = 0;
 981       while (*s &amp;&amp; g_ascii_isdigit (*s) &amp;&amp; i &lt; NUM_LEN)
 982         {
 983           num[pt-&gt;num_ints][i] = *s;
 984           ++s;
 985           ++i;
 986         }
 987 
 988       if (i &gt; 0)
 989         {
 990           num[pt-&gt;num_ints][i] = &#39;\0&#39;;
 991           ++(pt-&gt;num_ints);
 992         }
 993 
 994       if (*s == &#39;\0&#39;) break;
 995 
 996       ++s;
 997     }
 998 
 999   pt-&gt;n[0] = pt-&gt;num_ints &gt; 0 ? atoi (num[0]) : 0;
1000   pt-&gt;n[1] = pt-&gt;num_ints &gt; 1 ? atoi (num[1]) : 0;
1001   pt-&gt;n[2] = pt-&gt;num_ints &gt; 2 ? atoi (num[2]) : 0;
1002 
1003   pt-&gt;month = G_DATE_BAD_MONTH;
1004 
1005   if (pt-&gt;num_ints &lt; 3)
1006     {
1007       gsize longest = 0;
1008       gchar *casefold;
1009       gchar *normalized;
1010 
1011       casefold = g_utf8_casefold (str, -1);
1012       normalized = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
1013       g_free (casefold);
1014 
1015       for (i = 1; i &lt; 13; ++i)
1016         {
1017           /* Here month names may be in a genitive case if the language
1018            * grammatical rules require it.
1019            * Examples of how January may look in some languages:
1020            * Catalan: &quot;de gener&quot;, Croatian: &quot;gener&quot;, Polish: &quot;gener&quot;,
1021            * Upper Sorbian: &quot;januara&quot;.
1022            * Note that most of the languages can&#39;t or don&#39;t use the the
1023            * genitive case here so they use nominative everywhere.
1024            * For example, English always uses &quot;January&quot;.
1025            */
1026           if (update_month_match (&amp;longest, normalized, long_month_names[i]))
<a name="11" id="anc11"></a><span class="line-modified">1027             pt-&gt;month = i;</span>
1028 
1029           /* Here month names will be in a nominative case.
1030            * Examples of how January may look in some languages:
1031            * Catalan: &quot;gener&quot;, Croatian: &quot;gener&quot;, Polish: &quot;gener&quot;,
1032            * Upper Sorbian: &quot;Januar&quot;.
1033            */
1034           if (update_month_match (&amp;longest, normalized, long_month_names_alternative[i]))
<a name="12" id="anc12"></a><span class="line-modified">1035             pt-&gt;month = i;</span>
1036 
1037           /* Differences between abbreviated nominative and abbreviated
1038            * genitive month names are visible in very few languages but
1039            * let&#39;s handle them.
1040            */
1041           if (update_month_match (&amp;longest, normalized, short_month_names[i]))
<a name="13" id="anc13"></a><span class="line-modified">1042             pt-&gt;month = i;</span>
1043 
1044           if (update_month_match (&amp;longest, normalized, short_month_names_alternative[i]))
<a name="14" id="anc14"></a><span class="line-modified">1045             pt-&gt;month = i;</span>
<span class="line-modified">1046         }</span>
1047 
1048       g_free (normalized);
1049     }
1050 }
1051 
1052 /* HOLDS: g_date_global_lock */
1053 static void
1054 g_date_prepare_to_parse (const gchar      *str,
1055                          GDateParseTokens *pt)
1056 {
1057   const gchar *locale = setlocale (LC_TIME, NULL);
1058   gboolean recompute_localeinfo = FALSE;
1059   GDate d;
1060 
1061   g_return_if_fail (locale != NULL); /* should not happen */
1062 
1063   g_date_clear (&amp;d, 1);              /* clear for scratch use */
1064 
1065   if ( (current_locale == NULL) || (strcmp (locale, current_locale) != 0) )
1066     recompute_localeinfo = TRUE;  /* Uh, there used to be a reason for the temporary */
1067 
1068   if (recompute_localeinfo)
1069     {
1070       int i = 1;
1071       GDateParseTokens testpt;
1072       gchar buf[128];
1073 
1074       g_free (current_locale); /* still works if current_locale == NULL */
1075 
1076       current_locale = g_strdup (locale);
1077 
1078       short_month_names[0] = &quot;Error&quot;;
1079       long_month_names[0] = &quot;Error&quot;;
1080 
1081       while (i &lt; 13)
1082         {
<a name="15" id="anc15"></a><span class="line-modified">1083     gchar *casefold;</span>
1084 
1085           g_date_set_dmy (&amp;d, 1, i, 1976);
1086 
1087           g_return_if_fail (g_date_valid (&amp;d));
1088 
1089           g_date_strftime (buf, 127, &quot;%b&quot;, &amp;d);
1090 
<a name="16" id="anc16"></a><span class="line-modified">1091     casefold = g_utf8_casefold (buf, -1);</span>
1092           g_free (short_month_names[i]);
1093           short_month_names[i] = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
<a name="17" id="anc17"></a><span class="line-modified">1094     g_free (casefold);</span>
1095 
1096           g_date_strftime (buf, 127, &quot;%B&quot;, &amp;d);
<a name="18" id="anc18"></a><span class="line-modified">1097     casefold = g_utf8_casefold (buf, -1);</span>
1098           g_free (long_month_names[i]);
1099           long_month_names[i] = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
<a name="19" id="anc19"></a><span class="line-modified">1100     g_free (casefold);</span>
1101 
1102           g_date_strftime (buf, 127, &quot;%Ob&quot;, &amp;d);
1103           casefold = g_utf8_casefold (buf, -1);
1104           g_free (short_month_names_alternative[i]);
1105           short_month_names_alternative[i] = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
1106           g_free (casefold);
1107 
1108           g_date_strftime (buf, 127, &quot;%OB&quot;, &amp;d);
1109           casefold = g_utf8_casefold (buf, -1);
1110           g_free (long_month_names_alternative[i]);
1111           long_month_names_alternative[i] = g_utf8_normalize (casefold, -1, G_NORMALIZE_ALL);
1112           g_free (casefold);
1113 
1114           ++i;
1115         }
1116 
1117       /* Determine DMY order */
1118 
1119       /* had to pick a random day - don&#39;t change this, some strftimes
1120        * are broken on some days, and this one is good so far. */
1121       g_date_set_dmy (&amp;d, 4, 7, 1976);
1122 
1123       g_date_strftime (buf, 127, &quot;%x&quot;, &amp;d);
1124 
1125       g_date_fill_parse_tokens (buf, &amp;testpt);
1126 
1127       using_twodigit_years = FALSE;
1128       locale_era_adjust = 0;
1129       dmy_order[0] = G_DATE_DAY;
1130       dmy_order[1] = G_DATE_MONTH;
1131       dmy_order[2] = G_DATE_YEAR;
1132 
1133       i = 0;
1134       while (i &lt; testpt.num_ints)
1135         {
1136           switch (testpt.n[i])
1137             {
1138             case 7:
1139               dmy_order[i] = G_DATE_MONTH;
1140               break;
1141             case 4:
1142               dmy_order[i] = G_DATE_DAY;
1143               break;
1144             case 76:
1145               using_twodigit_years = TRUE; /* FALL THRU */
1146             case 1976:
1147               dmy_order[i] = G_DATE_YEAR;
1148               break;
1149             default:
1150               /* assume locale era */
1151               locale_era_adjust = 1976 - testpt.n[i];
1152               dmy_order[i] = G_DATE_YEAR;
1153               break;
1154             }
1155           ++i;
1156         }
1157 
1158 #if defined(G_ENABLE_DEBUG) &amp;&amp; 0
1159       DEBUG_MSG ((&quot;**GDate prepared a new set of locale-specific parse rules.&quot;));
1160       i = 1;
1161       while (i &lt; 13)
1162         {
1163           DEBUG_MSG ((&quot;  %s   %s&quot;, long_month_names[i], short_month_names[i]));
1164           ++i;
1165         }
1166       DEBUG_MSG ((&quot;Alternative month names:&quot;));
1167       i = 1;
1168       while (i &lt; 13)
1169         {
1170           DEBUG_MSG ((&quot;  %s   %s&quot;, long_month_names_alternative[i], short_month_names_alternative[i]));
1171           ++i;
1172         }
1173       if (using_twodigit_years)
1174         {
<a name="20" id="anc20"></a><span class="line-modified">1175     DEBUG_MSG ((&quot;**Using twodigit years with cutoff year: %u&quot;, twodigit_start_year));</span>
1176         }
1177       {
1178         gchar *strings[3];
1179         i = 0;
1180         while (i &lt; 3)
1181           {
1182             switch (dmy_order[i])
1183               {
1184               case G_DATE_MONTH:
1185                 strings[i] = &quot;Month&quot;;
1186                 break;
1187               case G_DATE_YEAR:
1188                 strings[i] = &quot;Year&quot;;
1189                 break;
1190               case G_DATE_DAY:
1191                 strings[i] = &quot;Day&quot;;
1192                 break;
1193               default:
1194                 strings[i] = NULL;
1195                 break;
1196               }
1197             ++i;
1198           }
1199         DEBUG_MSG ((&quot;**Order: %s, %s, %s&quot;, strings[0], strings[1], strings[2]));
1200         DEBUG_MSG ((&quot;**Sample date in this locale: &#39;%s&#39;&quot;, buf));
1201       }
1202 #endif
1203     }
1204 
1205   g_date_fill_parse_tokens (str, pt);
1206 }
1207 
1208 /**
1209  * g_date_set_parse:
1210  * @date: a #GDate to fill in
1211  * @str: string to parse
1212  *
1213  * Parses a user-inputted string @str, and try to figure out what date it
1214  * represents, taking the [current locale][setlocale] into account. If the
1215  * string is successfully parsed, the date will be valid after the call.
1216  * Otherwise, it will be invalid. You should check using g_date_valid()
1217  * to see whether the parsing succeeded.
1218  *
1219  * This function is not appropriate for file formats and the like; it
1220  * isn&#39;t very precise, and its exact behavior varies with the locale.
1221  * It&#39;s intended to be a heuristic routine that guesses what the user
1222  * means by a given string (and it does work pretty well in that
1223  * capacity).
1224  */
1225 void
1226 g_date_set_parse (GDate       *d,
1227                   const gchar *str)
1228 {
1229   GDateParseTokens pt;
1230   guint m = G_DATE_BAD_MONTH, day = G_DATE_BAD_DAY, y = G_DATE_BAD_YEAR;
1231 
1232   g_return_if_fail (d != NULL);
1233 
1234   /* set invalid */
1235   g_date_clear (d, 1);
1236 
1237   G_LOCK (g_date_global);
1238 
1239   g_date_prepare_to_parse (str, &amp;pt);
1240 
1241   DEBUG_MSG ((&quot;Found %d ints, &#39;%d&#39; &#39;%d&#39; &#39;%d&#39; and written out month %d&quot;,
<a name="21" id="anc21"></a><span class="line-modified">1242         pt.num_ints, pt.n[0], pt.n[1], pt.n[2], pt.month));</span>
1243 
1244 
1245   if (pt.num_ints == 4)
1246     {
1247       G_UNLOCK (g_date_global);
1248       return; /* presumably a typo; bail out. */
1249     }
1250 
1251   if (pt.num_ints &gt; 1)
1252     {
1253       int i = 0;
1254       int j = 0;
1255 
1256       g_assert (pt.num_ints &lt; 4); /* i.e., it is 2 or 3 */
1257 
1258       while (i &lt; pt.num_ints &amp;&amp; j &lt; 3)
1259         {
1260           switch (dmy_order[j])
1261             {
1262             case G_DATE_MONTH:
<a name="22" id="anc22"></a><span class="line-modified">1263       {</span>
<span class="line-modified">1264         if (pt.num_ints == 2 &amp;&amp; pt.month != G_DATE_BAD_MONTH)</span>
<span class="line-modified">1265     {</span>
<span class="line-modified">1266       m = pt.month;</span>
<span class="line-modified">1267       ++j;      /* skip months, but don&#39;t skip this number */</span>
<span class="line-modified">1268       continue;</span>
<span class="line-modified">1269     }</span>
<span class="line-modified">1270         else</span>
<span class="line-modified">1271     m = pt.n[i];</span>
<span class="line-modified">1272       }</span>
<span class="line-modified">1273       break;</span>
1274             case G_DATE_DAY:
<a name="23" id="anc23"></a><span class="line-modified">1275       {</span>
<span class="line-modified">1276         if (pt.num_ints == 2 &amp;&amp; pt.month == G_DATE_BAD_MONTH)</span>
<span class="line-modified">1277     {</span>
<span class="line-modified">1278       day = 1;</span>
<span class="line-modified">1279       ++j;      /* skip days, since we may have month/year */</span>
<span class="line-modified">1280       continue;</span>
<span class="line-modified">1281     }</span>
<span class="line-modified">1282         day = pt.n[i];</span>
<span class="line-modified">1283       }</span>
<span class="line-modified">1284       break;</span>
1285             case G_DATE_YEAR:
<a name="24" id="anc24"></a><span class="line-modified">1286       {</span>
<span class="line-modified">1287         y  = pt.n[i];</span>
1288 
<a name="25" id="anc25"></a><span class="line-modified">1289         if (locale_era_adjust != 0)</span>
<span class="line-modified">1290           {</span>
<span class="line-modified">1291       y += locale_era_adjust;</span>
<span class="line-modified">1292           }</span>
<span class="line-modified">1293         else if (using_twodigit_years &amp;&amp; y &lt; 100)</span>
<span class="line-modified">1294     {</span>
<span class="line-modified">1295       guint two     =  twodigit_start_year % 100;</span>
<span class="line-modified">1296       guint century = (twodigit_start_year / 100) * 100;</span>
1297 
<a name="26" id="anc26"></a><span class="line-modified">1298       if (y &lt; two)</span>
<span class="line-modified">1299         century += 100;</span>
1300 
<a name="27" id="anc27"></a><span class="line-modified">1301       y += century;</span>
<span class="line-modified">1302     }</span>
<span class="line-modified">1303       }</span>
<span class="line-modified">1304       break;</span>
1305             default:
1306               break;
1307             }
1308 
1309           ++i;
1310           ++j;
1311         }
1312 
1313 
1314       if (pt.num_ints == 3 &amp;&amp; !g_date_valid_dmy (day, m, y))
1315         {
1316           /* Try YYYY MM DD */
1317           y   = pt.n[0];
1318           m   = pt.n[1];
1319           day = pt.n[2];
1320 
1321           if (using_twodigit_years &amp;&amp; y &lt; 100)
1322             y = G_DATE_BAD_YEAR; /* avoids ambiguity */
1323         }
1324       else if (pt.num_ints == 2)
<a name="28" id="anc28"></a><span class="line-modified">1325   {</span>
<span class="line-modified">1326     if (m == G_DATE_BAD_MONTH &amp;&amp; pt.month != G_DATE_BAD_MONTH)</span>
<span class="line-modified">1327       m = pt.month;</span>
<span class="line-modified">1328   }</span>
1329     }
1330   else if (pt.num_ints == 1)
1331     {
1332       if (pt.month != G_DATE_BAD_MONTH)
1333         {
1334           /* Month name and year? */
1335           m    = pt.month;
1336           day  = 1;
1337           y = pt.n[0];
1338         }
1339       else
1340         {
1341           /* Try yyyymmdd and yymmdd */
1342 
1343           m   = (pt.n[0]/100) % 100;
1344           day = pt.n[0] % 100;
1345           y   = pt.n[0]/10000;
1346 
1347           /* FIXME move this into a separate function */
1348           if (using_twodigit_years &amp;&amp; y &lt; 100)
1349             {
1350               guint two     =  twodigit_start_year % 100;
1351               guint century = (twodigit_start_year / 100) * 100;
1352 
1353               if (y &lt; two)
1354                 century += 100;
1355 
1356               y += century;
1357             }
1358         }
1359     }
1360 
1361   /* See if we got anything valid out of all this. */
1362   /* y &lt; 8000 is to catch 19998 style typos; the library is OK up to 65535 or so */
1363   if (y &lt; 8000 &amp;&amp; g_date_valid_dmy (day, m, y))
1364     {
1365       d-&gt;month = m;
1366       d-&gt;day   = day;
1367       d-&gt;year  = y;
1368       d-&gt;dmy   = TRUE;
1369     }
1370 #ifdef G_ENABLE_DEBUG
1371   else
1372     {
1373       DEBUG_MSG ((&quot;Rejected DMY %u %u %u&quot;, day, m, y));
1374     }
1375 #endif
1376   G_UNLOCK (g_date_global);
1377 }
1378 
1379 /**
1380  * g_date_set_time_t:
1381  * @date: a #GDate
1382  * @timet: time_t value to set
1383  *
1384  * Sets the value of a date to the date corresponding to a time
1385  * specified as a time_t. The time to date conversion is done using
1386  * the user&#39;s current timezone.
1387  *
1388  * To set the value of a date to the current day, you could write:
1389  * |[&lt;!-- language=&quot;C&quot; --&gt;
1390  *  time_t now = time (NULL);
1391  *  if (now == (time_t) -1)
1392  *    // handle the error
1393  *  g_date_set_time_t (date, now);
1394  * ]|
1395  *
1396  * Since: 2.10
1397  */
1398 void
1399 g_date_set_time_t (GDate *date,
<a name="29" id="anc29"></a><span class="line-modified">1400        time_t timet)</span>
1401 {
1402   struct tm tm;
1403 
1404   g_return_if_fail (date != NULL);
1405 
1406 #ifdef HAVE_LOCALTIME_R
1407   localtime_r (&amp;timet, &amp;tm);
1408 #else
1409   {
1410     struct tm *ptm = localtime (&amp;timet);
1411 
1412     if (ptm == NULL)
1413       {
<a name="30" id="anc30"></a><span class="line-modified">1414   /* Happens at least in Microsoft&#39;s C library if you pass a</span>
<span class="line-modified">1415    * negative time_t. Use 2000-01-01 as default date.</span>
<span class="line-modified">1416    */</span>
1417 #ifndef G_DISABLE_CHECKS
<a name="31" id="anc31"></a><span class="line-modified">1418   g_return_if_fail_warning (G_LOG_DOMAIN, &quot;g_date_set_time&quot;, &quot;ptm != NULL&quot;);</span>
1419 #endif
1420 
<a name="32" id="anc32"></a><span class="line-modified">1421   tm.tm_mon = 0;</span>
<span class="line-modified">1422   tm.tm_mday = 1;</span>
<span class="line-modified">1423   tm.tm_year = 100;</span>
1424       }
1425     else
1426       memcpy ((void *) &amp;tm, (void *) ptm, sizeof(struct tm));
1427   }
1428 #endif
1429 
1430   date-&gt;julian = FALSE;
1431 
1432   date-&gt;month = tm.tm_mon + 1;
1433   date-&gt;day   = tm.tm_mday;
1434   date-&gt;year  = tm.tm_year + 1900;
1435 
1436   g_return_if_fail (g_date_valid_dmy (date-&gt;day, date-&gt;month, date-&gt;year));
1437 
1438   date-&gt;dmy    = TRUE;
1439 }
1440 
1441 
1442 /**
1443  * g_date_set_time:
1444  * @date: a #GDate.
1445  * @time_: #GTime value to set.
1446  *
1447  * Sets the value of a date from a #GTime value.
1448  * The time to date conversion is done using the user&#39;s current timezone.
1449  *
1450  * Deprecated: 2.10: Use g_date_set_time_t() instead.
1451  */
<a name="33" id="anc33"></a><span class="line-added">1452 G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
1453 void
1454 g_date_set_time (GDate *date,
<a name="34" id="anc34"></a><span class="line-modified">1455      GTime  time_)</span>
1456 {
1457   g_date_set_time_t (date, (time_t) time_);
1458 }
<a name="35" id="anc35"></a><span class="line-added">1459 G_GNUC_END_IGNORE_DEPRECATIONS</span>
1460 
1461 /**
1462  * g_date_set_time_val:
1463  * @date: a #GDate
1464  * @timeval: #GTimeVal value to set
1465  *
1466  * Sets the value of a date from a #GTimeVal value.  Note that the
1467  * @tv_usec member is ignored, because #GDate can&#39;t make use of the
1468  * additional precision.
1469  *
1470  * The time to date conversion is done using the user&#39;s current timezone.
1471  *
1472  * Since: 2.10
<a name="36" id="anc36"></a><span class="line-added">1473  * Deprecated: 2.62: #GTimeVal is not year-2038-safe. Use g_date_set_time_t()</span>
<span class="line-added">1474  *    instead.</span>
1475  */
<a name="37" id="anc37"></a><span class="line-added">1476 G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
1477 void
1478 g_date_set_time_val (GDate    *date,
<a name="38" id="anc38"></a><span class="line-modified">1479          GTimeVal *timeval)</span>
1480 {
1481   g_date_set_time_t (date, (time_t) timeval-&gt;tv_sec);
1482 }
<a name="39" id="anc39"></a><span class="line-added">1483 G_GNUC_END_IGNORE_DEPRECATIONS</span>
1484 
1485 /**
1486  * g_date_set_month:
1487  * @date: a #GDate
1488  * @month: month to set
1489  *
1490  * Sets the month of the year for a #GDate.  If the resulting
1491  * day-month-year triplet is invalid, the date will be invalid.
1492  */
1493 void
1494 g_date_set_month (GDate     *d,
1495                   GDateMonth m)
1496 {
1497   g_return_if_fail (d != NULL);
1498   g_return_if_fail (g_date_valid_month (m));
1499 
1500   if (d-&gt;julian &amp;&amp; !d-&gt;dmy) g_date_update_dmy(d);
1501   d-&gt;julian = FALSE;
1502 
1503   d-&gt;month = m;
1504 
1505   if (g_date_valid_dmy (d-&gt;day, d-&gt;month, d-&gt;year))
1506     d-&gt;dmy = TRUE;
1507   else
1508     d-&gt;dmy = FALSE;
1509 }
1510 
1511 /**
1512  * g_date_set_day:
1513  * @date: a #GDate
1514  * @day: day to set
1515  *
1516  * Sets the day of the month for a #GDate. If the resulting
1517  * day-month-year triplet is invalid, the date will be invalid.
1518  */
1519 void
1520 g_date_set_day (GDate    *d,
1521                 GDateDay  day)
1522 {
1523   g_return_if_fail (d != NULL);
1524   g_return_if_fail (g_date_valid_day (day));
1525 
1526   if (d-&gt;julian &amp;&amp; !d-&gt;dmy) g_date_update_dmy(d);
1527   d-&gt;julian = FALSE;
1528 
1529   d-&gt;day = day;
1530 
1531   if (g_date_valid_dmy (d-&gt;day, d-&gt;month, d-&gt;year))
1532     d-&gt;dmy = TRUE;
1533   else
1534     d-&gt;dmy = FALSE;
1535 }
1536 
1537 /**
1538  * g_date_set_year:
1539  * @date: a #GDate
1540  * @year: year to set
1541  *
1542  * Sets the year for a #GDate. If the resulting day-month-year
1543  * triplet is invalid, the date will be invalid.
1544  */
1545 void
1546 g_date_set_year (GDate     *d,
1547                  GDateYear  y)
1548 {
1549   g_return_if_fail (d != NULL);
1550   g_return_if_fail (g_date_valid_year (y));
1551 
1552   if (d-&gt;julian &amp;&amp; !d-&gt;dmy) g_date_update_dmy(d);
1553   d-&gt;julian = FALSE;
1554 
1555   d-&gt;year = y;
1556 
1557   if (g_date_valid_dmy (d-&gt;day, d-&gt;month, d-&gt;year))
1558     d-&gt;dmy = TRUE;
1559   else
1560     d-&gt;dmy = FALSE;
1561 }
1562 
1563 /**
1564  * g_date_set_dmy:
1565  * @date: a #GDate
1566  * @day: day
1567  * @month: month
1568  * @y: year
1569  *
1570  * Sets the value of a #GDate from a day, month, and year.
1571  * The day-month-year triplet must be valid; if you aren&#39;t
1572  * sure it is, call g_date_valid_dmy() to check before you
1573  * set it.
1574  */
1575 void
1576 g_date_set_dmy (GDate      *d,
1577                 GDateDay    day,
1578                 GDateMonth  m,
1579                 GDateYear   y)
1580 {
1581   g_return_if_fail (d != NULL);
1582   g_return_if_fail (g_date_valid_dmy (day, m, y));
1583 
1584   d-&gt;julian = FALSE;
1585 
1586   d-&gt;month = m;
1587   d-&gt;day   = day;
1588   d-&gt;year  = y;
1589 
1590   d-&gt;dmy = TRUE;
1591 }
1592 
1593 /**
1594  * g_date_set_julian:
1595  * @date: a #GDate
1596  * @julian_date: Julian day number (days since January 1, Year 1)
1597  *
1598  * Sets the value of a #GDate from a Julian day number.
1599  */
1600 void
1601 g_date_set_julian (GDate   *d,
1602                    guint32  j)
1603 {
1604   g_return_if_fail (d != NULL);
1605   g_return_if_fail (g_date_valid_julian (j));
1606 
1607   d-&gt;julian_days = j;
1608   d-&gt;julian = TRUE;
1609   d-&gt;dmy = FALSE;
1610 }
1611 
1612 /**
1613  * g_date_is_first_of_month:
1614  * @date: a #GDate to check
1615  *
1616  * Returns %TRUE if the date is on the first of a month.
1617  * The date must be valid.
1618  *
1619  * Returns: %TRUE if the date is the first of the month
1620  */
1621 gboolean
1622 g_date_is_first_of_month (const GDate *d)
1623 {
1624   g_return_val_if_fail (g_date_valid (d), FALSE);
1625 
1626   if (!d-&gt;dmy)
1627     g_date_update_dmy (d);
1628 
1629   g_return_val_if_fail (d-&gt;dmy, FALSE);
1630 
1631   if (d-&gt;day == 1) return TRUE;
1632   else return FALSE;
1633 }
1634 
1635 /**
1636  * g_date_is_last_of_month:
1637  * @date: a #GDate to check
1638  *
1639  * Returns %TRUE if the date is the last day of the month.
1640  * The date must be valid.
1641  *
1642  * Returns: %TRUE if the date is the last day of the month
1643  */
1644 gboolean
1645 g_date_is_last_of_month (const GDate *d)
1646 {
1647   gint idx;
1648 
1649   g_return_val_if_fail (g_date_valid (d), FALSE);
1650 
1651   if (!d-&gt;dmy)
1652     g_date_update_dmy (d);
1653 
1654   g_return_val_if_fail (d-&gt;dmy, FALSE);
1655 
1656   idx = g_date_is_leap_year (d-&gt;year) ? 1 : 0;
1657 
1658   if (d-&gt;day == days_in_months[idx][d-&gt;month]) return TRUE;
1659   else return FALSE;
1660 }
1661 
1662 /**
1663  * g_date_add_days:
1664  * @date: a #GDate to increment
1665  * @n_days: number of days to move the date forward
1666  *
1667  * Increments a date some number of days.
1668  * To move forward by weeks, add weeks*7 days.
1669  * The date must be valid.
1670  */
1671 void
1672 g_date_add_days (GDate *d,
1673                  guint  ndays)
1674 {
1675   g_return_if_fail (g_date_valid (d));
1676 
1677   if (!d-&gt;julian)
1678     g_date_update_julian (d);
1679 
1680   g_return_if_fail (d-&gt;julian);
1681   g_return_if_fail (ndays &lt;= G_MAXUINT32 - d-&gt;julian_days);
1682 
1683   d-&gt;julian_days += ndays;
1684   d-&gt;dmy = FALSE;
1685 }
1686 
1687 /**
1688  * g_date_subtract_days:
1689  * @date: a #GDate to decrement
1690  * @n_days: number of days to move
1691  *
1692  * Moves a date some number of days into the past.
1693  * To move by weeks, just move by weeks*7 days.
1694  * The date must be valid.
1695  */
1696 void
1697 g_date_subtract_days (GDate *d,
1698                       guint  ndays)
1699 {
1700   g_return_if_fail (g_date_valid (d));
1701 
1702   if (!d-&gt;julian)
1703     g_date_update_julian (d);
1704 
1705   g_return_if_fail (d-&gt;julian);
1706   g_return_if_fail (d-&gt;julian_days &gt; ndays);
1707 
1708   d-&gt;julian_days -= ndays;
1709   d-&gt;dmy = FALSE;
1710 }
1711 
1712 /**
1713  * g_date_add_months:
1714  * @date: a #GDate to increment
1715  * @n_months: number of months to move forward
1716  *
1717  * Increments a date by some number of months.
1718  * If the day of the month is greater than 28,
1719  * this routine may change the day of the month
1720  * (because the destination month may not have
1721  * the current day in it). The date must be valid.
1722  */
1723 void
1724 g_date_add_months (GDate *d,
1725                    guint  nmonths)
1726 {
1727   guint years, months;
1728   gint idx;
1729 
1730   g_return_if_fail (g_date_valid (d));
1731 
1732   if (!d-&gt;dmy)
1733     g_date_update_dmy (d);
1734 
1735   g_return_if_fail (d-&gt;dmy != 0);
1736   g_return_if_fail (nmonths &lt;= G_MAXUINT - (d-&gt;month - 1));
1737 
1738   nmonths += d-&gt;month - 1;
1739 
1740   years  = nmonths/12;
1741   months = nmonths%12;
1742 
<a name="40" id="anc40"></a><span class="line-modified">1743   g_return_if_fail (years &lt;= (guint) (G_MAXUINT16 - d-&gt;year));</span>
1744 
1745   d-&gt;month = months + 1;
1746   d-&gt;year  += years;
1747 
1748   idx = g_date_is_leap_year (d-&gt;year) ? 1 : 0;
1749 
1750   if (d-&gt;day &gt; days_in_months[idx][d-&gt;month])
1751     d-&gt;day = days_in_months[idx][d-&gt;month];
1752 
1753   d-&gt;julian = FALSE;
1754 
1755   g_return_if_fail (g_date_valid (d));
1756 }
1757 
1758 /**
1759  * g_date_subtract_months:
1760  * @date: a #GDate to decrement
1761  * @n_months: number of months to move
1762  *
1763  * Moves a date some number of months into the past.
1764  * If the current day of the month doesn&#39;t exist in
1765  * the destination month, the day of the month
1766  * may change. The date must be valid.
1767  */
1768 void
1769 g_date_subtract_months (GDate *d,
1770                         guint  nmonths)
1771 {
1772   guint years, months;
1773   gint idx;
1774 
1775   g_return_if_fail (g_date_valid (d));
1776 
1777   if (!d-&gt;dmy)
1778     g_date_update_dmy (d);
1779 
1780   g_return_if_fail (d-&gt;dmy != 0);
1781 
1782   years  = nmonths/12;
1783   months = nmonths%12;
1784 
1785   g_return_if_fail (d-&gt;year &gt; years);
1786 
1787   d-&gt;year  -= years;
1788 
1789   if (d-&gt;month &gt; months) d-&gt;month -= months;
1790   else
1791     {
1792       months -= d-&gt;month;
1793       d-&gt;month = 12 - months;
1794       d-&gt;year -= 1;
1795     }
1796 
1797   idx = g_date_is_leap_year (d-&gt;year) ? 1 : 0;
1798 
1799   if (d-&gt;day &gt; days_in_months[idx][d-&gt;month])
1800     d-&gt;day = days_in_months[idx][d-&gt;month];
1801 
1802   d-&gt;julian = FALSE;
1803 
1804   g_return_if_fail (g_date_valid (d));
1805 }
1806 
1807 /**
1808  * g_date_add_years:
1809  * @date: a #GDate to increment
1810  * @n_years: number of years to move forward
1811  *
1812  * Increments a date by some number of years.
1813  * If the date is February 29, and the destination
1814  * year is not a leap year, the date will be changed
1815  * to February 28. The date must be valid.
1816  */
1817 void
1818 g_date_add_years (GDate *d,
1819                   guint  nyears)
1820 {
1821   g_return_if_fail (g_date_valid (d));
1822 
1823   if (!d-&gt;dmy)
1824     g_date_update_dmy (d);
1825 
1826   g_return_if_fail (d-&gt;dmy != 0);
<a name="41" id="anc41"></a><span class="line-modified">1827   g_return_if_fail (nyears &lt;= (guint) (G_MAXUINT16 - d-&gt;year));</span>
1828 
1829   d-&gt;year += nyears;
1830 
1831   if (d-&gt;month == 2 &amp;&amp; d-&gt;day == 29)
1832     {
1833       if (!g_date_is_leap_year (d-&gt;year))
1834         d-&gt;day = 28;
1835     }
1836 
1837   d-&gt;julian = FALSE;
1838 }
1839 
1840 /**
1841  * g_date_subtract_years:
1842  * @date: a #GDate to decrement
1843  * @n_years: number of years to move
1844  *
1845  * Moves a date some number of years into the past.
1846  * If the current day doesn&#39;t exist in the destination
1847  * year (i.e. it&#39;s February 29 and you move to a non-leap-year)
1848  * then the day is changed to February 29. The date
1849  * must be valid.
1850  */
1851 void
1852 g_date_subtract_years (GDate *d,
1853                        guint  nyears)
1854 {
1855   g_return_if_fail (g_date_valid (d));
1856 
1857   if (!d-&gt;dmy)
1858     g_date_update_dmy (d);
1859 
1860   g_return_if_fail (d-&gt;dmy != 0);
1861   g_return_if_fail (d-&gt;year &gt; nyears);
1862 
1863   d-&gt;year -= nyears;
1864 
1865   if (d-&gt;month == 2 &amp;&amp; d-&gt;day == 29)
1866     {
1867       if (!g_date_is_leap_year (d-&gt;year))
1868         d-&gt;day = 28;
1869     }
1870 
1871   d-&gt;julian = FALSE;
1872 }
1873 
1874 /**
1875  * g_date_is_leap_year:
1876  * @year: year to check
1877  *
1878  * Returns %TRUE if the year is a leap year.
1879  *
1880  * For the purposes of this function, leap year is every year
1881  * divisible by 4 unless that year is divisible by 100. If it
1882  * is divisible by 100 it would be a leap year only if that year
1883  * is also divisible by 400.
1884  *
1885  * Returns: %TRUE if the year is a leap year
1886  */
1887 gboolean
1888 g_date_is_leap_year (GDateYear year)
1889 {
1890   g_return_val_if_fail (g_date_valid_year (year), FALSE);
1891 
1892   return ( (((year % 4) == 0) &amp;&amp; ((year % 100) != 0)) ||
1893            (year % 400) == 0 );
1894 }
1895 
1896 /**
1897  * g_date_get_days_in_month:
1898  * @month: month
1899  * @year: year
1900  *
1901  * Returns the number of days in a month, taking leap
1902  * years into account.
1903  *
1904  * Returns: number of days in @month during the @year
1905  */
1906 guint8
1907 g_date_get_days_in_month (GDateMonth month,
1908                           GDateYear  year)
1909 {
1910   gint idx;
1911 
1912   g_return_val_if_fail (g_date_valid_year (year), 0);
1913   g_return_val_if_fail (g_date_valid_month (month), 0);
1914 
1915   idx = g_date_is_leap_year (year) ? 1 : 0;
1916 
1917   return days_in_months[idx][month];
1918 }
1919 
1920 /**
1921  * g_date_get_monday_weeks_in_year:
1922  * @year: a year
1923  *
1924  * Returns the number of weeks in the year, where weeks
1925  * are taken to start on Monday. Will be 52 or 53. The
1926  * date must be valid. (Years always have 52 7-day periods,
1927  * plus 1 or 2 extra days depending on whether it&#39;s a leap
1928  * year. This function is basically telling you how many
1929  * Mondays are in the year, i.e. there are 53 Mondays if
1930  * one of the extra days happens to be a Monday.)
1931  *
1932  * Returns: number of Mondays in the year
1933  */
1934 guint8
1935 g_date_get_monday_weeks_in_year (GDateYear year)
1936 {
1937   GDate d;
1938 
1939   g_return_val_if_fail (g_date_valid_year (year), 0);
1940 
1941   g_date_clear (&amp;d, 1);
1942   g_date_set_dmy (&amp;d, 1, 1, year);
1943   if (g_date_get_weekday (&amp;d) == G_DATE_MONDAY) return 53;
1944   g_date_set_dmy (&amp;d, 31, 12, year);
1945   if (g_date_get_weekday (&amp;d) == G_DATE_MONDAY) return 53;
1946   if (g_date_is_leap_year (year))
1947     {
1948       g_date_set_dmy (&amp;d, 2, 1, year);
1949       if (g_date_get_weekday (&amp;d) == G_DATE_MONDAY) return 53;
1950       g_date_set_dmy (&amp;d, 30, 12, year);
1951       if (g_date_get_weekday (&amp;d) == G_DATE_MONDAY) return 53;
1952     }
1953   return 52;
1954 }
1955 
1956 /**
1957  * g_date_get_sunday_weeks_in_year:
1958  * @year: year to count weeks in
1959  *
1960  * Returns the number of weeks in the year, where weeks
1961  * are taken to start on Sunday. Will be 52 or 53. The
1962  * date must be valid. (Years always have 52 7-day periods,
1963  * plus 1 or 2 extra days depending on whether it&#39;s a leap
1964  * year. This function is basically telling you how many
1965  * Sundays are in the year, i.e. there are 53 Sundays if
1966  * one of the extra days happens to be a Sunday.)
1967  *
1968  * Returns: the number of weeks in @year
1969  */
1970 guint8
1971 g_date_get_sunday_weeks_in_year (GDateYear year)
1972 {
1973   GDate d;
1974 
1975   g_return_val_if_fail (g_date_valid_year (year), 0);
1976 
1977   g_date_clear (&amp;d, 1);
1978   g_date_set_dmy (&amp;d, 1, 1, year);
1979   if (g_date_get_weekday (&amp;d) == G_DATE_SUNDAY) return 53;
1980   g_date_set_dmy (&amp;d, 31, 12, year);
1981   if (g_date_get_weekday (&amp;d) == G_DATE_SUNDAY) return 53;
1982   if (g_date_is_leap_year (year))
1983     {
1984       g_date_set_dmy (&amp;d, 2, 1, year);
1985       if (g_date_get_weekday (&amp;d) == G_DATE_SUNDAY) return 53;
1986       g_date_set_dmy (&amp;d, 30, 12, year);
1987       if (g_date_get_weekday (&amp;d) == G_DATE_SUNDAY) return 53;
1988     }
1989   return 52;
1990 }
1991 
1992 /**
1993  * g_date_compare:
1994  * @lhs: first date to compare
1995  * @rhs: second date to compare
1996  *
1997  * qsort()-style comparison function for dates.
1998  * Both dates must be valid.
1999  *
2000  * Returns: 0 for equal, less than zero if @lhs is less than @rhs,
2001  *     greater than zero if @lhs is greater than @rhs
2002  */
2003 gint
2004 g_date_compare (const GDate *lhs,
2005                 const GDate *rhs)
2006 {
2007   g_return_val_if_fail (lhs != NULL, 0);
2008   g_return_val_if_fail (rhs != NULL, 0);
2009   g_return_val_if_fail (g_date_valid (lhs), 0);
2010   g_return_val_if_fail (g_date_valid (rhs), 0);
2011 
2012   /* Remember the self-comparison case! I think it works right now. */
2013 
2014   while (TRUE)
2015     {
2016       if (lhs-&gt;julian &amp;&amp; rhs-&gt;julian)
2017         {
2018           if (lhs-&gt;julian_days &lt; rhs-&gt;julian_days) return -1;
2019           else if (lhs-&gt;julian_days &gt; rhs-&gt;julian_days) return 1;
2020           else                                          return 0;
2021         }
2022       else if (lhs-&gt;dmy &amp;&amp; rhs-&gt;dmy)
2023         {
2024           if (lhs-&gt;year &lt; rhs-&gt;year)               return -1;
2025           else if (lhs-&gt;year &gt; rhs-&gt;year)               return 1;
2026           else
2027             {
2028               if (lhs-&gt;month &lt; rhs-&gt;month)         return -1;
2029               else if (lhs-&gt;month &gt; rhs-&gt;month)         return 1;
2030               else
2031                 {
2032                   if (lhs-&gt;day &lt; rhs-&gt;day)              return -1;
2033                   else if (lhs-&gt;day &gt; rhs-&gt;day)              return 1;
2034                   else                                       return 0;
2035                 }
2036 
2037             }
2038 
2039         }
2040       else
2041         {
2042           if (!lhs-&gt;julian) g_date_update_julian (lhs);
2043           if (!rhs-&gt;julian) g_date_update_julian (rhs);
2044           g_return_val_if_fail (lhs-&gt;julian, 0);
2045           g_return_val_if_fail (rhs-&gt;julian, 0);
2046         }
2047 
2048     }
2049   return 0; /* warnings */
2050 }
2051 
2052 /**
2053  * g_date_to_struct_tm:
2054  * @date: a #GDate to set the struct tm from
2055  * @tm: (not nullable): struct tm to fill
2056  *
2057  * Fills in the date-related bits of a struct tm using the @date value.
2058  * Initializes the non-date parts with something sane but meaningless.
2059  */
2060 void
2061 g_date_to_struct_tm (const GDate *d,
2062                      struct tm   *tm)
2063 {
2064   GDateWeekday day;
2065 
2066   g_return_if_fail (g_date_valid (d));
2067   g_return_if_fail (tm != NULL);
2068 
2069   if (!d-&gt;dmy)
2070     g_date_update_dmy (d);
2071 
2072   g_return_if_fail (d-&gt;dmy != 0);
2073 
2074   /* zero all the irrelevant fields to be sure they&#39;re valid */
2075 
2076   /* On Linux and maybe other systems, there are weird non-POSIX
2077    * fields on the end of struct tm that choke strftime if they
2078    * contain garbage.  So we need to 0 the entire struct, not just the
2079    * fields we know to exist.
2080    */
2081 
2082   memset (tm, 0x0, sizeof (struct tm));
2083 
2084   tm-&gt;tm_mday = d-&gt;day;
2085   tm-&gt;tm_mon  = d-&gt;month - 1; /* 0-11 goes in tm */
2086   tm-&gt;tm_year = ((int)d-&gt;year) - 1900; /* X/Open says tm_year can be negative */
2087 
2088   day = g_date_get_weekday (d);
2089   if (day == 7) day = 0; /* struct tm wants days since Sunday, so Sunday is 0 */
2090 
2091   tm-&gt;tm_wday = (int)day;
2092 
2093   tm-&gt;tm_yday = g_date_get_day_of_year (d) - 1; /* 0 to 365 */
2094   tm-&gt;tm_isdst = -1; /* -1 means &quot;information not available&quot; */
2095 }
2096 
2097 /**
2098  * g_date_clamp:
2099  * @date: a #GDate to clamp
2100  * @min_date: minimum accepted value for @date
2101  * @max_date: maximum accepted value for @date
2102  *
2103  * If @date is prior to @min_date, sets @date equal to @min_date.
2104  * If @date falls after @max_date, sets @date equal to @max_date.
2105  * Otherwise, @date is unchanged.
2106  * Either of @min_date and @max_date may be %NULL.
2107  * All non-%NULL dates must be valid.
2108  */
2109 void
2110 g_date_clamp (GDate       *date,
<a name="42" id="anc42"></a><span class="line-modified">2111         const GDate *min_date,</span>
<span class="line-modified">2112         const GDate *max_date)</span>
2113 {
2114   g_return_if_fail (g_date_valid (date));
2115 
2116   if (min_date != NULL)
2117     g_return_if_fail (g_date_valid (min_date));
2118 
2119   if (max_date != NULL)
2120     g_return_if_fail (g_date_valid (max_date));
2121 
2122   if (min_date != NULL &amp;&amp; max_date != NULL)
2123     g_return_if_fail (g_date_compare (min_date, max_date) &lt;= 0);
2124 
2125   if (min_date &amp;&amp; g_date_compare (date, min_date) &lt; 0)
2126     *date = *min_date;
2127 
2128   if (max_date &amp;&amp; g_date_compare (max_date, date) &lt; 0)
2129     *date = *max_date;
2130 }
2131 
2132 /**
2133  * g_date_order:
2134  * @date1: the first date
2135  * @date2: the second date
2136  *
2137  * Checks if @date1 is less than or equal to @date2,
2138  * and swap the values if this is not the case.
2139  */
2140 void
2141 g_date_order (GDate *date1,
2142               GDate *date2)
2143 {
2144   g_return_if_fail (g_date_valid (date1));
2145   g_return_if_fail (g_date_valid (date2));
2146 
2147   if (g_date_compare (date1, date2) &gt; 0)
2148     {
2149       GDate tmp = *date1;
2150       *date1 = *date2;
2151       *date2 = tmp;
2152     }
2153 }
2154 
2155 #ifdef G_OS_WIN32
2156 static void
2157 append_month_name (GArray     *result,
<a name="43" id="anc43"></a><span class="line-modified">2158        LCID        lcid,</span>
<span class="line-modified">2159        SYSTEMTIME *systemtime,</span>
<span class="line-modified">2160        gboolean    abbreviated,</span>
<span class="line-modified">2161        gboolean    alternative)</span>
2162 {
2163   int n;
2164   WORD base;
2165   LPCWSTR lpFormat;
2166 
2167   if (alternative)
2168     {
2169       base = abbreviated ? LOCALE_SABBREVMONTHNAME1 : LOCALE_SMONTHNAME1;
2170       n = GetLocaleInfoW (lcid, base + systemtime-&gt;wMonth - 1, NULL, 0);
2171       g_array_set_size (result, result-&gt;len + n);
2172       GetLocaleInfoW (lcid, base + systemtime-&gt;wMonth - 1,
<a name="44" id="anc44"></a><span class="line-modified">2173           ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
2174       g_array_set_size (result, result-&gt;len - 1);
2175     }
2176   else
2177     {
2178       /* According to MSDN, this is the correct method to obtain
2179        * the form of the month name used when formatting a full
2180        * date; it must be a genitive case in some languages.
2181        */
2182       lpFormat = abbreviated ? L&quot;ddMMM&quot; : L&quot;ddMMMM&quot;;
2183       n = GetDateFormatW (lcid, 0, systemtime, lpFormat, NULL, 0);
2184       g_array_set_size (result, result-&gt;len + n);
2185       GetDateFormatW (lcid, 0, systemtime, lpFormat,
<a name="45" id="anc45"></a><span class="line-modified">2186           ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
2187       /* We have obtained a day number as two digits and the month name.
2188        * Now let&#39;s get rid of those two digits: overwrite them with the
2189        * month name.
2190        */
2191       memmove (((wchar_t *) result-&gt;data) + result-&gt;len - n,
<a name="46" id="anc46"></a><span class="line-modified">2192          ((wchar_t *) result-&gt;data) + result-&gt;len - n + 2,</span>
<span class="line-modified">2193          (n - 2) * sizeof (wchar_t));</span>
2194       g_array_set_size (result, result-&gt;len - 3);
2195     }
2196 }
2197 
2198 static gsize
2199 win32_strftime_helper (const GDate     *d,
<a name="47" id="anc47"></a><span class="line-modified">2200            const gchar     *format,</span>
<span class="line-modified">2201            const struct tm *tm,</span>
<span class="line-modified">2202            gchar           *s,</span>
<span class="line-modified">2203            gsize          slen)</span>
2204 {
2205   SYSTEMTIME systemtime;
2206   TIME_ZONE_INFORMATION tzinfo;
2207   LCID lcid;
2208   int n, k;
2209   GArray *result;
2210   const gchar *p;
2211   gunichar c, modifier;
2212   const wchar_t digits[] = L&quot;0123456789&quot;;
2213   gchar *convbuf;
2214   glong convlen = 0;
2215   gsize retval;
2216 
2217   systemtime.wYear = tm-&gt;tm_year + 1900;
2218   systemtime.wMonth = tm-&gt;tm_mon + 1;
2219   systemtime.wDayOfWeek = tm-&gt;tm_wday;
2220   systemtime.wDay = tm-&gt;tm_mday;
2221   systemtime.wHour = tm-&gt;tm_hour;
2222   systemtime.wMinute = tm-&gt;tm_min;
2223   systemtime.wSecond = tm-&gt;tm_sec;
2224   systemtime.wMilliseconds = 0;
2225 
2226   lcid = GetThreadLocale ();
2227   result = g_array_sized_new (FALSE, FALSE, sizeof (wchar_t), MAX (128, strlen (format) * 2));
2228 
2229   p = format;
2230   while (*p)
2231     {
2232       c = g_utf8_get_char (p);
2233       if (c == &#39;%&#39;)
<a name="48" id="anc48"></a><span class="line-modified">2234   {</span>
<span class="line-modified">2235     p = g_utf8_next_char (p);</span>
<span class="line-modified">2236     if (!*p)</span>
<span class="line-modified">2237       {</span>
<span class="line-modified">2238         s[0] = &#39;\0&#39;;</span>
<span class="line-modified">2239         g_array_free (result, TRUE);</span>
2240 
<a name="49" id="anc49"></a><span class="line-modified">2241         return 0;</span>
<span class="line-modified">2242       }</span>
2243 
<a name="50" id="anc50"></a><span class="line-modified">2244     modifier = &#39;\0&#39;;</span>
<span class="line-modified">2245     c = g_utf8_get_char (p);</span>
<span class="line-modified">2246     if (c == &#39;E&#39; || c == &#39;O&#39;)</span>
<span class="line-modified">2247       {</span>
<span class="line-modified">2248         /* &quot;%OB&quot;, &quot;%Ob&quot;, and &quot;%Oh&quot; are supported, ignore other modified</span>
<span class="line-modified">2249          * conversion specifiers for now.</span>
<span class="line-modified">2250          */</span>
<span class="line-modified">2251         modifier = c;</span>
<span class="line-modified">2252         p = g_utf8_next_char (p);</span>
<span class="line-modified">2253         if (!*p)</span>
<span class="line-modified">2254     {</span>
<span class="line-modified">2255       s[0] = &#39;\0&#39;;</span>
<span class="line-modified">2256       g_array_free (result, TRUE);</span>
2257 
<a name="51" id="anc51"></a><span class="line-modified">2258       return 0;</span>
<span class="line-modified">2259     }</span>
2260 
<a name="52" id="anc52"></a><span class="line-modified">2261         c = g_utf8_get_char (p);</span>
<span class="line-modified">2262       }</span>
2263 
<a name="53" id="anc53"></a><span class="line-modified">2264     switch (c)</span>
<span class="line-modified">2265       {</span>
<span class="line-modified">2266       case &#39;a&#39;:</span>
<span class="line-modified">2267         if (systemtime.wDayOfWeek == 0)</span>
<span class="line-modified">2268     k = 6;</span>
<span class="line-modified">2269         else</span>
<span class="line-modified">2270     k = systemtime.wDayOfWeek - 1;</span>
<span class="line-modified">2271         n = GetLocaleInfoW (lcid, LOCALE_SABBREVDAYNAME1+k, NULL, 0);</span>
<span class="line-modified">2272         g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2273         GetLocaleInfoW (lcid, LOCALE_SABBREVDAYNAME1+k, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2274         g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-modified">2275         break;</span>
<span class="line-modified">2276       case &#39;A&#39;:</span>
<span class="line-modified">2277         if (systemtime.wDayOfWeek == 0)</span>
<span class="line-modified">2278     k = 6;</span>
<span class="line-modified">2279         else</span>
<span class="line-modified">2280     k = systemtime.wDayOfWeek - 1;</span>
<span class="line-modified">2281         n = GetLocaleInfoW (lcid, LOCALE_SDAYNAME1+k, NULL, 0);</span>
<span class="line-modified">2282         g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2283         GetLocaleInfoW (lcid, LOCALE_SDAYNAME1+k, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2284         g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-modified">2285         break;</span>
<span class="line-modified">2286       case &#39;b&#39;:</span>
<span class="line-modified">2287       case &#39;h&#39;:</span>
<span class="line-modified">2288         append_month_name (result, lcid, &amp;systemtime, TRUE,</span>
<span class="line-modified">2289          modifier == &#39;O&#39;);</span>
<span class="line-modified">2290         break;</span>
<span class="line-modified">2291       case &#39;B&#39;:</span>
<span class="line-modified">2292         append_month_name (result, lcid, &amp;systemtime, FALSE,</span>
<span class="line-modified">2293          modifier == &#39;O&#39;);</span>
<span class="line-modified">2294         break;</span>
<span class="line-modified">2295       case &#39;c&#39;:</span>
<span class="line-modified">2296         n = GetDateFormatW (lcid, 0, &amp;systemtime, NULL, NULL, 0);</span>
<span class="line-modified">2297         if (n &gt; 0)</span>
<span class="line-modified">2298     {</span>
<span class="line-modified">2299       g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2300       GetDateFormatW (lcid, 0, &amp;systemtime, NULL, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2301       g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-modified">2302     }</span>































2303         g_array_append_vals (result, L&quot; &quot;, 1);
<a name="54" id="anc54"></a><span class="line-modified">2304         n = GetTimeFormatW (lcid, 0, &amp;systemtime, NULL, NULL, 0);</span>
<span class="line-modified">2305         if (n &gt; 0)</span>
<span class="line-modified">2306     {</span>
<span class="line-modified">2307       g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2308       GetTimeFormatW (lcid, 0, &amp;systemtime, NULL, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2309       g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-modified">2310     }</span>
<span class="line-modified">2311         break;</span>
<span class="line-modified">2312       case &#39;C&#39;:</span>
<span class="line-modified">2313         g_array_append_vals (result, digits + systemtime.wYear/1000, 1);</span>
<span class="line-modified">2314         g_array_append_vals (result, digits + (systemtime.wYear/1000)%10, 1);</span>
<span class="line-added">2315         break;</span>
<span class="line-added">2316       case &#39;d&#39;:</span>
<span class="line-added">2317         g_array_append_vals (result, digits + systemtime.wDay/10, 1);</span>
<span class="line-added">2318         g_array_append_vals (result, digits + systemtime.wDay%10, 1);</span>
<span class="line-added">2319         break;</span>
<span class="line-added">2320       case &#39;D&#39;:</span>
<span class="line-added">2321         g_array_append_vals (result, digits + systemtime.wMonth/10, 1);</span>
<span class="line-added">2322         g_array_append_vals (result, digits + systemtime.wMonth%10, 1);</span>
<span class="line-added">2323         g_array_append_vals (result, L&quot;/&quot;, 1);</span>
<span class="line-added">2324         g_array_append_vals (result, digits + systemtime.wDay/10, 1);</span>
<span class="line-added">2325         g_array_append_vals (result, digits + systemtime.wDay%10, 1);</span>
<span class="line-added">2326         g_array_append_vals (result, L&quot;/&quot;, 1);</span>
<span class="line-added">2327         g_array_append_vals (result, digits + (systemtime.wYear/10)%10, 1);</span>
<span class="line-added">2328         g_array_append_vals (result, digits + systemtime.wYear%10, 1);</span>
<span class="line-added">2329         break;</span>
<span class="line-added">2330       case &#39;e&#39;:</span>
<span class="line-added">2331         if (systemtime.wDay &gt;= 10)</span>
<span class="line-added">2332     g_array_append_vals (result, digits + systemtime.wDay/10, 1);</span>
<span class="line-added">2333         else</span>
<span class="line-added">2334     g_array_append_vals (result, L&quot; &quot;, 1);</span>
<span class="line-added">2335         g_array_append_vals (result, digits + systemtime.wDay%10, 1);</span>
<span class="line-added">2336         break;</span>
<span class="line-added">2337 </span>
<span class="line-added">2338         /* A GDate has no time fields, so for now we can</span>
<span class="line-added">2339          * hardcode all time conversions into zeros (or 12 for</span>
<span class="line-added">2340          * %I). The alternative code snippets in the #else</span>
<span class="line-added">2341          * branches are here ready to be taken into use when</span>
<span class="line-added">2342          * needed by a g_strftime() or g_date_and_time_format()</span>
<span class="line-added">2343          * or whatever.</span>
<span class="line-added">2344          */</span>
<span class="line-added">2345       case &#39;H&#39;:</span>
2346 #if 1
<a name="55" id="anc55"></a><span class="line-modified">2347         g_array_append_vals (result, L&quot;00&quot;, 2);</span>
2348 #else
<a name="56" id="anc56"></a><span class="line-modified">2349         g_array_append_vals (result, digits + systemtime.wHour/10, 1);</span>
<span class="line-modified">2350         g_array_append_vals (result, digits + systemtime.wHour%10, 1);</span>
2351 #endif
<a name="57" id="anc57"></a><span class="line-modified">2352         break;</span>
<span class="line-modified">2353       case &#39;I&#39;:</span>
2354 #if 1
<a name="58" id="anc58"></a>


2355         g_array_append_vals (result, L&quot;12&quot;, 2);
<a name="59" id="anc59"></a><span class="line-modified">2356 #else</span>
<span class="line-modified">2357         if (systemtime.wHour == 0)</span>
<span class="line-modified">2358     g_array_append_vals (result, L&quot;12&quot;, 2);</span>
<span class="line-modified">2359         else</span>
<span class="line-modified">2360     {</span>
<span class="line-added">2361       g_array_append_vals (result, digits + (systemtime.wHour%12)/10, 1);</span>
<span class="line-added">2362       g_array_append_vals (result, digits + (systemtime.wHour%12)%10, 1);</span>
<span class="line-added">2363     }</span>
2364 #endif
<a name="60" id="anc60"></a><span class="line-modified">2365         break;</span>
<span class="line-modified">2366       case  &#39;j&#39;:</span>
<span class="line-modified">2367         g_array_append_vals (result, digits + (tm-&gt;tm_yday+1)/100, 1);</span>
<span class="line-modified">2368         g_array_append_vals (result, digits + ((tm-&gt;tm_yday+1)/10)%10, 1);</span>
<span class="line-modified">2369         g_array_append_vals (result, digits + (tm-&gt;tm_yday+1)%10, 1);</span>
<span class="line-modified">2370         break;</span>
<span class="line-modified">2371       case &#39;m&#39;:</span>
<span class="line-modified">2372         g_array_append_vals (result, digits + systemtime.wMonth/10, 1);</span>
<span class="line-modified">2373         g_array_append_vals (result, digits + systemtime.wMonth%10, 1);</span>
<span class="line-modified">2374         break;</span>
<span class="line-modified">2375       case &#39;M&#39;:</span>
2376 #if 1
<a name="61" id="anc61"></a><span class="line-modified">2377         g_array_append_vals (result, L&quot;00&quot;, 2);</span>
2378 #else
<a name="62" id="anc62"></a><span class="line-modified">2379         g_array_append_vals (result, digits + systemtime.wMinute/10, 1);</span>
<span class="line-modified">2380         g_array_append_vals (result, digits + systemtime.wMinute%10, 1);</span>
2381 #endif
<a name="63" id="anc63"></a><span class="line-modified">2382         break;</span>
<span class="line-modified">2383       case &#39;n&#39;:</span>
<span class="line-modified">2384         g_array_append_vals (result, L&quot;\n&quot;, 1);</span>
<span class="line-modified">2385         break;</span>
<span class="line-modified">2386       case &#39;p&#39;:</span>
<span class="line-modified">2387         n = GetTimeFormatW (lcid, 0, &amp;systemtime, L&quot;tt&quot;, NULL, 0);</span>
<span class="line-modified">2388         if (n &gt; 0)</span>
<span class="line-modified">2389     {</span>
<span class="line-modified">2390       g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2391       GetTimeFormatW (lcid, 0, &amp;systemtime, L&quot;tt&quot;, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2392       g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-modified">2393     }</span>
<span class="line-modified">2394         break;</span>
<span class="line-modified">2395       case &#39;r&#39;:</span>
<span class="line-modified">2396         /* This is a rather odd format. Hard to say what to do.</span>
<span class="line-modified">2397          * Let&#39;s always use the POSIX %I:%M:%S %p</span>
<span class="line-modified">2398          */</span>
2399 #if 1
<a name="64" id="anc64"></a><span class="line-modified">2400         g_array_append_vals (result, L&quot;12:00:00&quot;, 8);</span>
2401 #else
<a name="65" id="anc65"></a><span class="line-modified">2402         if (systemtime.wHour == 0)</span>
<span class="line-modified">2403     g_array_append_vals (result, L&quot;12&quot;, 2);</span>
<span class="line-modified">2404         else</span>
<span class="line-modified">2405     {</span>
<span class="line-modified">2406       g_array_append_vals (result, digits + (systemtime.wHour%12)/10, 1);</span>
<span class="line-modified">2407       g_array_append_vals (result, digits + (systemtime.wHour%12)%10, 1);</span>
<span class="line-modified">2408     }</span>
<span class="line-modified">2409         g_array_append_vals (result, L&quot;:&quot;, 1);</span>
<span class="line-modified">2410         g_array_append_vals (result, digits + systemtime.wMinute/10, 1);</span>
<span class="line-modified">2411         g_array_append_vals (result, digits + systemtime.wMinute%10, 1);</span>
<span class="line-modified">2412         g_array_append_vals (result, L&quot;:&quot;, 1);</span>
<span class="line-modified">2413         g_array_append_vals (result, digits + systemtime.wSecond/10, 1);</span>
<span class="line-modified">2414         g_array_append_vals (result, digits + systemtime.wSecond%10, 1);</span>
<span class="line-modified">2415         g_array_append_vals (result, L&quot; &quot;, 1);</span>
2416 #endif
<a name="66" id="anc66"></a><span class="line-modified">2417         n = GetTimeFormatW (lcid, 0, &amp;systemtime, L&quot;tt&quot;, NULL, 0);</span>
<span class="line-modified">2418         if (n &gt; 0)</span>
<span class="line-modified">2419     {</span>
<span class="line-modified">2420       g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2421       GetTimeFormatW (lcid, 0, &amp;systemtime, L&quot;tt&quot;, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2422       g_array_set_size (result, result-&gt;len - 1);</span>
<span class="line-modified">2423     }</span>
<span class="line-modified">2424         break;</span>
<span class="line-modified">2425       case &#39;R&#39;:</span>
2426 #if 1
<a name="67" id="anc67"></a><span class="line-modified">2427         g_array_append_vals (result, L&quot;00:00&quot;, 5);</span>
2428 #else
<a name="68" id="anc68"></a><span class="line-modified">2429         g_array_append_vals (result, digits + systemtime.wHour/10, 1);</span>
<span class="line-modified">2430         g_array_append_vals (result, digits + systemtime.wHour%10, 1);</span>
<span class="line-modified">2431         g_array_append_vals (result, L&quot;:&quot;, 1);</span>
<span class="line-modified">2432         g_array_append_vals (result, digits + systemtime.wMinute/10, 1);</span>
<span class="line-modified">2433         g_array_append_vals (result, digits + systemtime.wMinute%10, 1);</span>
2434 #endif
<a name="69" id="anc69"></a><span class="line-modified">2435         break;</span>
<span class="line-modified">2436       case &#39;S&#39;:</span>
2437 #if 1
<a name="70" id="anc70"></a><span class="line-modified">2438         g_array_append_vals (result, L&quot;00&quot;, 2);</span>
2439 #else
<a name="71" id="anc71"></a><span class="line-modified">2440         g_array_append_vals (result, digits + systemtime.wSecond/10, 1);</span>
<span class="line-modified">2441         g_array_append_vals (result, digits + systemtime.wSecond%10, 1);</span>
2442 #endif
<a name="72" id="anc72"></a><span class="line-modified">2443         break;</span>
<span class="line-modified">2444       case &#39;t&#39;:</span>
<span class="line-modified">2445         g_array_append_vals (result, L&quot;\t&quot;, 1);</span>
<span class="line-modified">2446         break;</span>
<span class="line-modified">2447       case &#39;T&#39;:</span>
2448 #if 1
<a name="73" id="anc73"></a><span class="line-modified">2449         g_array_append_vals (result, L&quot;00:00:00&quot;, 8);</span>
2450 #else
<a name="74" id="anc74"></a><span class="line-modified">2451         g_array_append_vals (result, digits + systemtime.wHour/10, 1);</span>
<span class="line-modified">2452         g_array_append_vals (result, digits + systemtime.wHour%10, 1);</span>
<span class="line-modified">2453         g_array_append_vals (result, L&quot;:&quot;, 1);</span>
<span class="line-modified">2454         g_array_append_vals (result, digits + systemtime.wMinute/10, 1);</span>
<span class="line-modified">2455         g_array_append_vals (result, digits + systemtime.wMinute%10, 1);</span>
<span class="line-modified">2456         g_array_append_vals (result, L&quot;:&quot;, 1);</span>
<span class="line-modified">2457         g_array_append_vals (result, digits + systemtime.wSecond/10, 1);</span>
<span class="line-modified">2458         g_array_append_vals (result, digits + systemtime.wSecond%10, 1);</span>
2459 #endif
<a name="75" id="anc75"></a><span class="line-modified">2460         break;</span>
<span class="line-modified">2461       case &#39;u&#39;:</span>
<span class="line-modified">2462         if (systemtime.wDayOfWeek == 0)</span>
<span class="line-modified">2463     g_array_append_vals (result, L&quot;7&quot;, 1);</span>
<span class="line-modified">2464         else</span>
<span class="line-added">2465     g_array_append_vals (result, digits + systemtime.wDayOfWeek, 1);</span>
<span class="line-added">2466         break;</span>
<span class="line-added">2467       case &#39;U&#39;:</span>
<span class="line-added">2468         n = g_date_get_sunday_week_of_year (d);</span>
<span class="line-added">2469         g_array_append_vals (result, digits + n/10, 1);</span>
<span class="line-added">2470         g_array_append_vals (result, digits + n%10, 1);</span>
<span class="line-added">2471         break;</span>
<span class="line-added">2472       case &#39;V&#39;:</span>
<span class="line-added">2473         n = g_date_get_iso8601_week_of_year (d);</span>
<span class="line-added">2474         g_array_append_vals (result, digits + n/10, 1);</span>
<span class="line-added">2475         g_array_append_vals (result, digits + n%10, 1);</span>
<span class="line-added">2476         break;</span>
<span class="line-added">2477       case &#39;w&#39;:</span>
2478         g_array_append_vals (result, digits + systemtime.wDayOfWeek, 1);
<a name="76" id="anc76"></a><span class="line-modified">2479         break;</span>
<span class="line-modified">2480       case &#39;W&#39;:</span>
<span class="line-modified">2481         n = g_date_get_monday_week_of_year (d);</span>
<span class="line-modified">2482         g_array_append_vals (result, digits + n/10, 1);</span>
<span class="line-modified">2483         g_array_append_vals (result, digits + n%10, 1);</span>
<span class="line-modified">2484         break;</span>
<span class="line-modified">2485       case &#39;x&#39;:</span>
<span class="line-modified">2486         n = GetDateFormatW (lcid, 0, &amp;systemtime, NULL, NULL, 0);</span>
<span class="line-modified">2487         if (n &gt; 0)</span>
<span class="line-modified">2488     {</span>
<span class="line-modified">2489       g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2490       GetDateFormatW (lcid, 0, &amp;systemtime, NULL, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-modified">2491       g_array_set_size (result, result-&gt;len - 1);</span>















































2492     }
<a name="77" id="anc77"></a><span class="line-modified">2493         break;</span>
<span class="line-added">2494       case &#39;X&#39;:</span>
<span class="line-added">2495         n = GetTimeFormatW (lcid, 0, &amp;systemtime, NULL, NULL, 0);</span>
<span class="line-added">2496         if (n &gt; 0)</span>
2497     {
<a name="78" id="anc78"></a><span class="line-modified">2498       g_array_set_size (result, result-&gt;len + n);</span>
<span class="line-modified">2499       GetTimeFormatW (lcid, 0, &amp;systemtime, NULL, ((wchar_t *) result-&gt;data) + result-&gt;len - n, n);</span>
<span class="line-added">2500       g_array_set_size (result, result-&gt;len - 1);</span>
2501     }
<a name="79" id="anc79"></a><span class="line-added">2502         break;</span>
<span class="line-added">2503       case &#39;y&#39;:</span>
<span class="line-added">2504         g_array_append_vals (result, digits + (systemtime.wYear/10)%10, 1);</span>
<span class="line-added">2505         g_array_append_vals (result, digits + systemtime.wYear%10, 1);</span>
<span class="line-added">2506         break;</span>
<span class="line-added">2507       case &#39;Y&#39;:</span>
<span class="line-added">2508         g_array_append_vals (result, digits + systemtime.wYear/1000, 1);</span>
<span class="line-added">2509         g_array_append_vals (result, digits + (systemtime.wYear/100)%10, 1);</span>
<span class="line-added">2510         g_array_append_vals (result, digits + (systemtime.wYear/10)%10, 1);</span>
<span class="line-added">2511         g_array_append_vals (result, digits + systemtime.wYear%10, 1);</span>
<span class="line-added">2512         break;</span>
<span class="line-added">2513       case &#39;Z&#39;:</span>
<span class="line-added">2514         n = GetTimeZoneInformation (&amp;tzinfo);</span>
<span class="line-added">2515         if (n == TIME_ZONE_ID_UNKNOWN)</span>
<span class="line-added">2516     ;</span>
<span class="line-added">2517         else if (n == TIME_ZONE_ID_STANDARD)</span>
<span class="line-added">2518     g_array_append_vals (result, tzinfo.StandardName, wcslen (tzinfo.StandardName));</span>
<span class="line-added">2519         else if (n == TIME_ZONE_ID_DAYLIGHT)</span>
<span class="line-added">2520     g_array_append_vals (result, tzinfo.DaylightName, wcslen (tzinfo.DaylightName));</span>
<span class="line-added">2521         break;</span>
<span class="line-added">2522       case &#39;%&#39;:</span>
<span class="line-added">2523         g_array_append_vals (result, L&quot;%&quot;, 1);</span>
<span class="line-added">2524         break;</span>
<span class="line-added">2525       }</span>
<span class="line-added">2526   }</span>
<span class="line-added">2527       else if (c &lt;= 0xFFFF)</span>
<span class="line-added">2528   {</span>
<span class="line-added">2529     wchar_t wc = c;</span>
<span class="line-added">2530     g_array_append_vals (result, &amp;wc, 1);</span>
<span class="line-added">2531   }</span>
2532       else
<a name="80" id="anc80"></a><span class="line-modified">2533   {</span>
<span class="line-modified">2534     glong nwc;</span>
<span class="line-modified">2535     wchar_t *ws;</span>
2536 
<a name="81" id="anc81"></a><span class="line-modified">2537     ws = g_ucs4_to_utf16 (&amp;c, 1, NULL, &amp;nwc, NULL);</span>
<span class="line-modified">2538     g_array_append_vals (result, ws, nwc);</span>
<span class="line-modified">2539     g_free (ws);</span>
<span class="line-modified">2540   }</span>
2541       p = g_utf8_next_char (p);
2542     }
2543 
2544   convbuf = g_utf16_to_utf8 ((wchar_t *) result-&gt;data, result-&gt;len, NULL, &amp;convlen, NULL);
2545   g_array_free (result, TRUE);
2546 
2547   if (!convbuf)
2548     {
2549       s[0] = &#39;\0&#39;;
2550       return 0;
2551     }
2552 
2553   if (slen &lt;= convlen)
2554     {
2555       /* Ensure only whole characters are copied into the buffer. */
2556       gchar *end = g_utf8_find_prev_char (convbuf, convbuf + slen);
2557       g_assert (end != NULL);
2558       convlen = end - convbuf;
2559 
2560       /* Return 0 because the buffer isn&#39;t large enough. */
2561       retval = 0;
2562     }
2563   else
2564     retval = convlen;
2565 
2566   memcpy (s, convbuf, convlen);
2567   s[convlen] = &#39;\0&#39;;
2568   g_free (convbuf);
2569 
2570   return retval;
2571 }
2572 
2573 #endif
2574 
2575 /**
2576  * g_date_strftime:
2577  * @s: destination buffer
2578  * @slen: buffer size
2579  * @format: format string
2580  * @date: valid #GDate
2581  *
2582  * Generates a printed representation of the date, in a
2583  * [locale][setlocale]-specific way.
2584  * Works just like the platform&#39;s C library strftime() function,
2585  * but only accepts date-related formats; time-related formats
2586  * give undefined results. Date must be valid. Unlike strftime()
2587  * (which uses the locale encoding), works on a UTF-8 format
2588  * string and stores a UTF-8 result.
2589  *
2590  * This function does not provide any conversion specifiers in
2591  * addition to those implemented by the platform&#39;s C library.
2592  * For example, don&#39;t expect that using g_date_strftime() would
2593  * make the \%F provided by the C99 strftime() work on Windows
2594  * where the C library only complies to C89.
2595  *
2596  * Returns: number of characters written to the buffer, or 0 the buffer was too small
2597  */
<a name="82" id="anc82"></a><span class="line-added">2598 #ifdef GSTREAMER_LITE</span>
<span class="line-added">2599 #ifndef G_OS_WIN32</span>
<span class="line-added">2600 #pragma GCC diagnostic push</span>
<span class="line-added">2601 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;</span>
<span class="line-added">2602 #endif // G_OS_WIN32</span>
<span class="line-added">2603 #else // GSTREAMER_LITE</span>
2604 #pragma GCC diagnostic push
2605 #pragma GCC diagnostic ignored &quot;-Wformat-nonliteral&quot;
<a name="83" id="anc83"></a><span class="line-added">2606 #endif // GSTREAMER_LITE</span>
2607 
2608 gsize
2609 g_date_strftime (gchar       *s,
2610                  gsize        slen,
2611                  const gchar *format,
2612                  const GDate *d)
2613 {
2614   struct tm tm;
2615 #ifndef G_OS_WIN32
2616   gsize locale_format_len = 0;
2617   gchar *locale_format;
2618   gsize tmplen;
2619   gchar *tmpbuf;
2620   gsize tmpbufsize;
2621   gsize convlen = 0;
2622   gchar *convbuf;
2623   GError *error = NULL;
2624   gsize retval;
2625 #endif
2626 
2627   g_return_val_if_fail (g_date_valid (d), 0);
2628   g_return_val_if_fail (slen &gt; 0, 0);
2629   g_return_val_if_fail (format != NULL, 0);
2630   g_return_val_if_fail (s != NULL, 0);
2631 
2632   g_date_to_struct_tm (d, &amp;tm);
2633 
2634 #ifdef G_OS_WIN32
2635   if (!g_utf8_validate (format, -1, NULL))
2636     {
2637       s[0] = &#39;\0&#39;;
2638       return 0;
2639     }
2640   return win32_strftime_helper (d, format, &amp;tm, s, slen);
2641 #else
2642 
2643   locale_format = g_locale_from_utf8 (format, -1, NULL, &amp;locale_format_len, &amp;error);
2644 
2645   if (error)
2646     {
2647       g_warning (G_STRLOC &quot;Error converting format to locale encoding: %s&quot;, error-&gt;message);
2648       g_error_free (error);
2649 
2650       s[0] = &#39;\0&#39;;
2651       return 0;
2652     }
2653 
2654   tmpbufsize = MAX (128, locale_format_len * 2);
2655   while (TRUE)
2656     {
2657       tmpbuf = g_malloc (tmpbufsize);
2658 #ifdef GSTREAMER_LITE
2659       if (tmpbuf == NULL)
2660           return 0;
2661 #endif // GSTREAMER_LITE
2662 
2663       /* Set the first byte to something other than &#39;\0&#39;, to be able to
2664        * recognize whether strftime actually failed or just returned &quot;&quot;.
2665        */
2666       tmpbuf[0] = &#39;\1&#39;;
2667       tmplen = strftime (tmpbuf, tmpbufsize, locale_format, &amp;tm);
2668 
2669       if (tmplen == 0 &amp;&amp; tmpbuf[0] != &#39;\0&#39;)
2670         {
2671           g_free (tmpbuf);
2672           tmpbufsize *= 2;
2673 
2674           if (tmpbufsize &gt; 65536)
2675             {
2676               g_warning (G_STRLOC &quot;Maximum buffer size for g_date_strftime exceeded: giving up&quot;);
2677               g_free (locale_format);
2678 
2679               s[0] = &#39;\0&#39;;
2680               return 0;
2681             }
2682         }
2683       else
2684         break;
2685     }
2686   g_free (locale_format);
2687 
2688   convbuf = g_locale_to_utf8 (tmpbuf, tmplen, NULL, &amp;convlen, &amp;error);
2689   g_free (tmpbuf);
2690 
2691   if (error)
2692     {
2693       g_warning (G_STRLOC &quot;Error converting results of strftime to UTF-8: %s&quot;, error-&gt;message);
2694       g_error_free (error);
2695 
2696       s[0] = &#39;\0&#39;;
2697       return 0;
2698     }
2699 
2700   if (slen &lt;= convlen)
2701     {
2702       /* Ensure only whole characters are copied into the buffer.
2703        */
2704       gchar *end = g_utf8_find_prev_char (convbuf, convbuf + slen);
2705       g_assert (end != NULL);
2706       convlen = end - convbuf;
2707 
2708       /* Return 0 because the buffer isn&#39;t large enough.
2709        */
2710       retval = 0;
2711     }
2712   else
2713     retval = convlen;
2714 
2715   memcpy (s, convbuf, convlen);
2716   s[convlen] = &#39;\0&#39;;
2717   g_free (convbuf);
2718 
2719   return retval;
2720 #endif
2721 }
2722 
<a name="84" id="anc84"></a><span class="line-added">2723 #ifdef GSTREAMER_LITE</span>
<span class="line-added">2724 #ifndef G_OS_WIN32</span>
2725 #pragma GCC diagnostic pop
<a name="85" id="anc85"></a><span class="line-added">2726 #endif // G_OS_WIN32</span>
<span class="line-added">2727 #else // GSTREAMER_LITE</span>
<span class="line-added">2728 #pragma GCC diagnostic pop</span>
<span class="line-added">2729 #endif // GSTREAMER_LITE</span>
<a name="86" id="anc86"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="86" type="hidden" />
</body>
</html>