<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/convertframe.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../tag/tag.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstvideodecoder.c.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/convertframe.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -16,10 +16,13 @@</span>
   * You should have received a copy of the GNU Library General Public
   * License along with this library; if not, write to the
   * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
   * Boston, MA 02110-1301, USA.
   */
<span class="udiff-line-added">+ #ifdef HAVE_CONFIG_H</span>
<span class="udiff-line-added">+ #include &quot;config.h&quot;</span>
<span class="udiff-line-added">+ #endif</span>
  
  #include &lt;string.h&gt;
  #include &quot;video.h&quot;
  
  static gboolean
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -315,11 +318,10 @@</span>
    g_return_val_if_fail (buf != NULL, NULL);
  
    from_caps = gst_sample_get_caps (sample);
    g_return_val_if_fail (from_caps != NULL, NULL);
  
<span class="udiff-line-removed">- </span>
    to_caps_copy = gst_caps_new_empty ();
    n = gst_caps_get_size (to_caps);
    for (i = 0; i &lt; n; i++) {
      GstStructure *s = gst_caps_get_structure (to_caps, i);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -336,11 +338,13 @@</span>
  
    /* now set the pipeline to the paused state, after we push the buffer into
     * appsrc, this should preroll the converted buffer in appsink */
    GST_DEBUG (&quot;running conversion pipeline to caps %&quot; GST_PTR_FORMAT,
        to_caps_copy);
<span class="udiff-line-modified-removed">-   gst_element_set_state (pipeline, GST_STATE_PAUSED);</span>
<span class="udiff-line-modified-added">+   if (gst_element_set_state (pipeline,</span>
<span class="udiff-line-added">+           GST_STATE_PAUSED) == GST_STATE_CHANGE_FAILURE)</span>
<span class="udiff-line-added">+     goto state_change_failed;</span>
  
    /* feed buffer in appsrc */
    GST_DEBUG (&quot;feeding buffer %p, size %&quot; G_GSIZE_FORMAT &quot;, caps %&quot;
        GST_PTR_FORMAT, buf, gst_buffer_get_size (buf), from_caps);
    g_signal_emit_by_name (src, &quot;push-buffer&quot;, buf, &amp;ret);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -399,10 +403,11 @@</span>
  
    return result;
  
    /* ERRORS */
  no_pipeline:
<span class="udiff-line-added">+ state_change_failed:</span>
    {
      gst_caps_unref (to_caps_copy);
  
      if (error)
        *error = err;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -413,103 +418,125 @@</span>
    }
  }
  
  typedef struct
  {
<span class="udiff-line-added">+   gint ref_count;</span>
    GMutex mutex;
    GstElement *pipeline;
    GstVideoConvertSampleCallback callback;
    gpointer user_data;
    GDestroyNotify destroy_notify;
    GMainContext *context;
    GstSample *sample;
<span class="udiff-line-removed">-   //GstBuffer *buffer;</span>
    GSource *timeout_source;
    gboolean finished;
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   /* Results */</span>
<span class="udiff-line-added">+   GstSample *converted_sample;</span>
<span class="udiff-line-added">+   GError *error;</span>
  } GstVideoConvertSampleContext;
  
<span class="udiff-line-modified-removed">- typedef struct</span>
<span class="udiff-line-modified-added">+ static GstVideoConvertSampleContext *</span>
<span class="udiff-line-added">+ gst_video_convert_frame_context_ref (GstVideoConvertSampleContext * ctx)</span>
  {
<span class="udiff-line-modified-removed">-   GstVideoConvertSampleCallback callback;</span>
<span class="udiff-line-removed">-   GstSample *sample;</span>
<span class="udiff-line-removed">-   //GstBuffer *buffer;</span>
<span class="udiff-line-removed">-   GError *error;</span>
<span class="udiff-line-removed">-   gpointer user_data;</span>
<span class="udiff-line-removed">-   GDestroyNotify destroy_notify;</span>
<span class="udiff-line-modified-added">+   g_atomic_int_inc (&amp;ctx-&gt;ref_count);</span>
  
<span class="udiff-line-modified-removed">-   GstVideoConvertSampleContext *context;</span>
<span class="udiff-line-modified-removed">- } GstVideoConvertSampleCallbackContext;</span>
<span class="udiff-line-modified-added">+   return ctx;</span>
<span class="udiff-line-modified-added">+ }</span>
  
  static void
<span class="udiff-line-modified-removed">- gst_video_convert_frame_context_free (GstVideoConvertSampleContext * ctx)</span>
<span class="udiff-line-modified-added">+ gst_video_convert_frame_context_unref (GstVideoConvertSampleContext * ctx)</span>
  {
<span class="udiff-line-modified-removed">-   /* Wait until all users of the mutex are done */</span>
<span class="udiff-line-modified-removed">-   g_mutex_lock (&amp;ctx-&gt;mutex);</span>
<span class="udiff-line-modified-removed">-   g_mutex_unlock (&amp;ctx-&gt;mutex);</span>
<span class="udiff-line-modified-added">+   if (!g_atomic_int_dec_and_test (&amp;ctx-&gt;ref_count))</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+ </span>
    g_mutex_clear (&amp;ctx-&gt;mutex);
    if (ctx-&gt;timeout_source)
      g_source_destroy (ctx-&gt;timeout_source);
<span class="udiff-line-removed">-   //if (ctx-&gt;buffer)</span>
<span class="udiff-line-removed">-   //  gst_buffer_unref (ctx-&gt;buffer);</span>
    if (ctx-&gt;sample)
      gst_sample_unref (ctx-&gt;sample);
<span class="udiff-line-added">+   if (ctx-&gt;converted_sample)</span>
<span class="udiff-line-added">+     gst_sample_unref (ctx-&gt;converted_sample);</span>
<span class="udiff-line-added">+   g_clear_error (&amp;ctx-&gt;error);</span>
    g_main_context_unref (ctx-&gt;context);
  
<span class="udiff-line-modified-removed">-   gst_element_set_state (ctx-&gt;pipeline, GST_STATE_NULL);</span>
<span class="udiff-line-modified-removed">-   gst_object_unref (ctx-&gt;pipeline);</span>
<span class="udiff-line-modified-added">+   /* The pipeline was already destroyed in finish() earlier and we</span>
<span class="udiff-line-modified-added">+    * must not end up here without finish() being called */</span>
<span class="udiff-line-added">+   g_warn_if_fail (ctx-&gt;pipeline == NULL);</span>
  
    g_slice_free (GstVideoConvertSampleContext, ctx);
  }
  
<span class="udiff-line-removed">- static void</span>
<span class="udiff-line-removed">-     gst_video_convert_frame_callback_context_free</span>
<span class="udiff-line-removed">-     (GstVideoConvertSampleCallbackContext * ctx)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-   if (ctx-&gt;context)</span>
<span class="udiff-line-removed">-     gst_video_convert_frame_context_free (ctx-&gt;context);</span>
<span class="udiff-line-removed">-   g_slice_free (GstVideoConvertSampleCallbackContext, ctx);</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  static gboolean
<span class="udiff-line-modified-removed">- convert_frame_dispatch_callback (GstVideoConvertSampleCallbackContext * ctx)</span>
<span class="udiff-line-modified-added">+ convert_frame_dispatch_callback (GstVideoConvertSampleContext * ctx)</span>
  {
<span class="udiff-line-modified-removed">-   ctx-&gt;callback (ctx-&gt;sample, ctx-&gt;error, ctx-&gt;user_data);</span>
<span class="udiff-line-modified-added">+   GstSample *sample;</span>
<span class="udiff-line-added">+   GError *error;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   g_return_val_if_fail (ctx-&gt;converted_sample != NULL</span>
<span class="udiff-line-added">+       || ctx-&gt;error != NULL, FALSE);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   sample = ctx-&gt;converted_sample;</span>
<span class="udiff-line-added">+   error = ctx-&gt;error;</span>
<span class="udiff-line-added">+   ctx-&gt;converted_sample = NULL;</span>
<span class="udiff-line-added">+   ctx-&gt;error = NULL;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   ctx-&gt;callback (sample, error, ctx-&gt;user_data);</span>
  
    if (ctx-&gt;destroy_notify)
      ctx-&gt;destroy_notify (ctx-&gt;user_data);
  
    return FALSE;
  }
  
<span class="udiff-line-added">+ static void</span>
<span class="udiff-line-added">+ convert_frame_stop_pipeline (GstElement * element, gpointer user_data)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+   gst_element_set_state (element, GST_STATE_NULL);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  static void
  convert_frame_finish (GstVideoConvertSampleContext * context,
      GstSample * sample, GError * error)
  {
    GSource *source;
<span class="udiff-line-modified-removed">-   GstVideoConvertSampleCallbackContext *ctx;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+   g_return_if_fail (!context-&gt;finished);</span>
<span class="udiff-line-added">+   g_return_if_fail (sample != NULL || error != NULL);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   context-&gt;finished = TRUE;</span>
<span class="udiff-line-added">+   context-&gt;converted_sample = sample;</span>
<span class="udiff-line-added">+   context-&gt;error = error;</span>
  
    if (context-&gt;timeout_source)
      g_source_destroy (context-&gt;timeout_source);
    context-&gt;timeout_source = NULL;
  
<span class="udiff-line-removed">-   ctx = g_slice_new (GstVideoConvertSampleCallbackContext);</span>
<span class="udiff-line-removed">-   ctx-&gt;callback = context-&gt;callback;</span>
<span class="udiff-line-removed">-   ctx-&gt;user_data = context-&gt;user_data;</span>
<span class="udiff-line-removed">-   ctx-&gt;destroy_notify = context-&gt;destroy_notify;</span>
<span class="udiff-line-removed">-   ctx-&gt;sample = sample;</span>
<span class="udiff-line-removed">-   //ctx-&gt;buffer = buffer;</span>
<span class="udiff-line-removed">-   ctx-&gt;error = error;</span>
<span class="udiff-line-removed">-   ctx-&gt;context = context;</span>
<span class="udiff-line-removed">- </span>
    source = g_timeout_source_new (0);
    g_source_set_callback (source,
<span class="udiff-line-modified-removed">-       (GSourceFunc) convert_frame_dispatch_callback, ctx,</span>
<span class="udiff-line-modified-removed">-       (GDestroyNotify) gst_video_convert_frame_callback_context_free);</span>
<span class="udiff-line-modified-added">+       (GSourceFunc) convert_frame_dispatch_callback,</span>
<span class="udiff-line-modified-added">+       gst_video_convert_frame_context_ref (context),</span>
<span class="udiff-line-added">+       (GDestroyNotify) gst_video_convert_frame_context_unref);</span>
    g_source_attach (source, context-&gt;context);
    g_source_unref (source);
  
<span class="udiff-line-modified-removed">-   context-&gt;finished = TRUE;</span>
<span class="udiff-line-modified-added">+   /* Asynchronously stop the pipeline here: this will set its</span>
<span class="udiff-line-added">+    * state to NULL and get rid of its last reference, which in turn</span>
<span class="udiff-line-added">+    * will get rid of all remaining references to our context and free</span>
<span class="udiff-line-added">+    * it too. We can&#39;t do this directly here as we might be called from</span>
<span class="udiff-line-added">+    * a streaming thread.</span>
<span class="udiff-line-added">+    *</span>
<span class="udiff-line-added">+    * We don&#39;t use the main loop here because the user might shut down it</span>
<span class="udiff-line-added">+    * immediately after getting the result of the conversion above.</span>
<span class="udiff-line-added">+    */</span>
<span class="udiff-line-added">+   if (context-&gt;pipeline) {</span>
<span class="udiff-line-added">+     gst_element_call_async (context-&gt;pipeline, convert_frame_stop_pipeline,</span>
<span class="udiff-line-added">+         NULL, NULL);</span>
<span class="udiff-line-added">+     gst_object_unref (context-&gt;pipeline);</span>
<span class="udiff-line-added">+     context-&gt;pipeline = NULL;</span>
<span class="udiff-line-added">+   }</span>
  }
  
  static gboolean
  convert_frame_timeout_callback (GstVideoConvertSampleContext * context)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -591,15 +618,15 @@</span>
          &quot;Could not push video frame: %s&quot;, gst_flow_get_name (ret));
  
      convert_frame_finish (context, NULL, error);
    }
  
<span class="udiff-line-removed">-   g_signal_handlers_disconnect_by_func (src, convert_frame_need_data_callback,</span>
<span class="udiff-line-removed">-       context);</span>
<span class="udiff-line-removed">- </span>
  done:
    g_mutex_unlock (&amp;context-&gt;mutex);
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   g_signal_handlers_disconnect_by_func (src, convert_frame_need_data_callback,</span>
<span class="udiff-line-added">+       context);</span>
  }
  
  static GstFlowReturn
  convert_frame_new_preroll_callback (GstElement * sink,
      GstVideoConvertSampleContext * context)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -618,16 +645,16 @@</span>
      error = g_error_new (GST_CORE_ERROR, GST_CORE_ERROR_FAILED,
          &quot;Could not get converted video sample&quot;);
    }
    convert_frame_finish (context, sample, error);
  
<span class="udiff-line-removed">-   g_signal_handlers_disconnect_by_func (sink, convert_frame_need_data_callback,</span>
<span class="udiff-line-removed">-       context);</span>
<span class="udiff-line-removed">- </span>
  done:
    g_mutex_unlock (&amp;context-&gt;mutex);
  
<span class="udiff-line-added">+   g_signal_handlers_disconnect_by_func (sink, convert_frame_need_data_callback,</span>
<span class="udiff-line-added">+       context);</span>
<span class="udiff-line-added">+ </span>
    return GST_FLOW_OK;
  }
  
  /**
   * gst_video_convert_sample_async:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -691,71 +718,89 @@</span>
      s = gst_structure_copy (s);
      gst_structure_remove_field (s, &quot;framerate&quot;);
      gst_caps_append_structure (to_caps_copy, s);
    }
  
<span class="udiff-line-modified-removed">-   pipeline =</span>
<span class="udiff-line-modified-removed">-       build_convert_frame_pipeline (&amp;src, &amp;sink, from_caps,</span>
<span class="udiff-line-modified-removed">-       gst_buffer_get_video_crop_meta (buf), to_caps_copy, &amp;error);</span>
<span class="udiff-line-removed">-   if (!pipeline)</span>
<span class="udiff-line-removed">-     goto no_pipeline;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-   bus = gst_element_get_bus (pipeline);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-modified-added">+   /* There&#39;s a reference cycle between the context and the pipeline, which is</span>
<span class="udiff-line-modified-added">+    * broken up once the finish() is called on the context. At latest when the</span>
<span class="udiff-line-modified-added">+    * timeout triggers the context will be freed */</span>
    ctx = g_slice_new0 (GstVideoConvertSampleContext);
<span class="udiff-line-added">+   ctx-&gt;ref_count = 1;</span>
    g_mutex_init (&amp;ctx-&gt;mutex);
<span class="udiff-line-removed">-   //ctx-&gt;buffer = gst_buffer_ref (buf);</span>
    ctx-&gt;sample = gst_sample_ref (sample);
    ctx-&gt;callback = callback;
    ctx-&gt;user_data = user_data;
    ctx-&gt;destroy_notify = destroy_notify;
    ctx-&gt;context = g_main_context_ref (context);
    ctx-&gt;finished = FALSE;
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+   pipeline =</span>
<span class="udiff-line-added">+       build_convert_frame_pipeline (&amp;src, &amp;sink, from_caps,</span>
<span class="udiff-line-added">+       gst_buffer_get_video_crop_meta (buf), to_caps_copy, &amp;error);</span>
<span class="udiff-line-added">+   if (!pipeline)</span>
<span class="udiff-line-added">+     goto no_pipeline;</span>
    ctx-&gt;pipeline = pipeline;
  
<span class="udiff-line-added">+   bus = gst_element_get_bus (pipeline);</span>
<span class="udiff-line-added">+ </span>
    if (timeout != GST_CLOCK_TIME_NONE) {
      ctx-&gt;timeout_source = g_timeout_source_new (timeout / GST_MSECOND);
      g_source_set_callback (ctx-&gt;timeout_source,
<span class="udiff-line-modified-removed">-         (GSourceFunc) convert_frame_timeout_callback, ctx, NULL);</span>
<span class="udiff-line-modified-added">+         (GSourceFunc) convert_frame_timeout_callback,</span>
<span class="udiff-line-added">+         gst_video_convert_frame_context_ref (ctx),</span>
<span class="udiff-line-added">+         (GDestroyNotify) gst_video_convert_frame_context_unref);</span>
      g_source_attach (ctx-&gt;timeout_source, context);
    }
  
<span class="udiff-line-modified-removed">-   g_signal_connect (src, &quot;need-data&quot;,</span>
<span class="udiff-line-modified-removed">-       G_CALLBACK (convert_frame_need_data_callback), ctx);</span>
<span class="udiff-line-modified-removed">-   g_signal_connect (sink, &quot;new-preroll&quot;,</span>
<span class="udiff-line-modified-removed">-       G_CALLBACK (convert_frame_new_preroll_callback), ctx);</span>
<span class="udiff-line-modified-added">+   g_signal_connect_data (src, &quot;need-data&quot;,</span>
<span class="udiff-line-modified-added">+       G_CALLBACK (convert_frame_need_data_callback),</span>
<span class="udiff-line-modified-added">+       gst_video_convert_frame_context_ref (ctx),</span>
<span class="udiff-line-modified-added">+       (GClosureNotify) gst_video_convert_frame_context_unref, 0);</span>
<span class="udiff-line-added">+   g_signal_connect_data (sink, &quot;new-preroll&quot;,</span>
<span class="udiff-line-added">+       G_CALLBACK (convert_frame_new_preroll_callback),</span>
<span class="udiff-line-added">+       gst_video_convert_frame_context_ref (ctx),</span>
<span class="udiff-line-added">+       (GClosureNotify) gst_video_convert_frame_context_unref, 0);</span>
  
    source = gst_bus_create_watch (bus);
    g_source_set_callback (source, (GSourceFunc) convert_frame_bus_callback,
<span class="udiff-line-modified-removed">-       ctx, NULL);</span>
<span class="udiff-line-modified-added">+       gst_video_convert_frame_context_ref (ctx),</span>
<span class="udiff-line-added">+       (GDestroyNotify) gst_video_convert_frame_context_unref);</span>
    g_source_attach (source, context);
    g_source_unref (source);
<span class="udiff-line-added">+   gst_object_unref (bus);</span>
  
<span class="udiff-line-modified-removed">-   gst_element_set_state (pipeline, GST_STATE_PLAYING);</span>
<span class="udiff-line-modified-added">+   if (gst_element_set_state (pipeline,</span>
<span class="udiff-line-added">+           GST_STATE_PAUSED) == GST_STATE_CHANGE_FAILURE)</span>
<span class="udiff-line-added">+     goto state_change_failed;</span>
  
<span class="udiff-line-removed">-   gst_object_unref (bus);</span>
    gst_caps_unref (to_caps_copy);
  
<span class="udiff-line-added">+   gst_video_convert_frame_context_unref (ctx);</span>
<span class="udiff-line-added">+ </span>
    return;
    /* ERRORS */
  no_pipeline:
    {
<span class="udiff-line-modified-removed">-     GstVideoConvertSampleCallbackContext *ctx;</span>
<span class="udiff-line-modified-removed">-     GSource *source;</span>
<span class="udiff-line-modified-added">+     gst_caps_unref (to_caps_copy);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     g_mutex_lock (&amp;ctx-&gt;mutex);</span>
<span class="udiff-line-added">+     convert_frame_finish (ctx, NULL, error);</span>
<span class="udiff-line-added">+     g_mutex_unlock (&amp;ctx-&gt;mutex);</span>
<span class="udiff-line-added">+     gst_video_convert_frame_context_unref (ctx);</span>
  
<span class="udiff-line-added">+     return;</span>
<span class="udiff-line-added">+   }</span>
<span class="udiff-line-added">+ state_change_failed:</span>
<span class="udiff-line-added">+   {</span>
      gst_caps_unref (to_caps_copy);
  
<span class="udiff-line-modified-removed">-     ctx = g_slice_new0 (GstVideoConvertSampleCallbackContext);</span>
<span class="udiff-line-modified-removed">-     ctx-&gt;callback = callback;</span>
<span class="udiff-line-modified-removed">-     ctx-&gt;user_data = user_data;</span>
<span class="udiff-line-modified-removed">-     ctx-&gt;destroy_notify = destroy_notify;</span>
<span class="udiff-line-modified-removed">-     ctx-&gt;sample = NULL;</span>
<span class="udiff-line-modified-removed">-     ctx-&gt;error = error;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-     source = g_timeout_source_new (0);</span>
<span class="udiff-line-modified-removed">-     g_source_set_callback (source,</span>
<span class="udiff-line-removed">-         (GSourceFunc) convert_frame_dispatch_callback, ctx,</span>
<span class="udiff-line-removed">-         (GDestroyNotify) gst_video_convert_frame_callback_context_free);</span>
<span class="udiff-line-removed">-     g_source_attach (source, context);</span>
<span class="udiff-line-removed">-     g_source_unref (source);</span>
<span class="udiff-line-modified-added">+     error = g_error_new (GST_CORE_ERROR, GST_CORE_ERROR_STATE_CHANGE,</span>
<span class="udiff-line-modified-added">+         &quot;failed to change state to PLAYING&quot;);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     g_mutex_lock (&amp;ctx-&gt;mutex);</span>
<span class="udiff-line-modified-added">+     convert_frame_finish (ctx, NULL, error);</span>
<span class="udiff-line-modified-added">+     g_mutex_unlock (&amp;ctx-&gt;mutex);</span>
<span class="udiff-line-modified-added">+     gst_video_convert_frame_context_unref (ctx);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     return;</span>
    }
  }
</pre>
<center><a href="../tag/tag.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstvideodecoder.c.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>