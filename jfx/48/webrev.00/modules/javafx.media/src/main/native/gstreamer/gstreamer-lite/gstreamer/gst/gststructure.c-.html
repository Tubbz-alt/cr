<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gststructure.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 2003 David A. Schleef &lt;ds@schleef.org&gt;
   3  *
   4  * gststructure.c: lists of { GQuark, GValue } tuples
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 /**
  23  * SECTION:gststructure
  24  * @title: GstStructure
  25  * @short_description: Generic structure containing fields of names and values
  26  * @see_also: #GstCaps, #GstMessage, #GstEvent, #GstQuery
  27  *
  28  * A #GstStructure is a collection of key/value pairs. The keys are expressed
  29  * as GQuarks and the values can be of any GType.
  30  *
  31  * In addition to the key/value pairs, a #GstStructure also has a name. The name
  32  * starts with a letter and can be filled by letters, numbers and any of &quot;/-_.:&quot;.
  33  *
  34  * #GstStructure is used by various GStreamer subsystems to store information
  35  * in a flexible and extensible way. A #GstStructure does not have a refcount
  36  * because it usually is part of a higher level object such as #GstCaps,
  37  * #GstMessage, #GstEvent, #GstQuery. It provides a means to enforce mutability
  38  * using the refcount of the parent with the gst_structure_set_parent_refcount()
  39  * method.
  40  *
  41  * A #GstStructure can be created with gst_structure_new_empty() or
  42  * gst_structure_new(), which both take a name and an optional set of
  43  * key/value pairs along with the types of the values.
  44  *
  45  * Field values can be changed with gst_structure_set_value() or
  46  * gst_structure_set().
  47  *
  48  * Field values can be retrieved with gst_structure_get_value() or the more
  49  * convenient gst_structure_get_*() functions.
  50  *
  51  * Fields can be removed with gst_structure_remove_field() or
  52  * gst_structure_remove_fields().
  53  *
  54  * Strings in structures must be ASCII or UTF-8 encoded. Other encodings are
  55  * not allowed. Strings may be %NULL however.
  56  *
  57  * Be aware that the current #GstCaps / #GstStructure serialization into string
  58  * has limited support for nested #GstCaps / #GstStructure fields. It can only
  59  * support one level of nesting. Using more levels will lead to unexpected
  60  * behavior when using serialization features, such as gst_caps_to_string() or
  61  * gst_value_serialize() and their counterparts.
  62  */
  63 
  64 #ifdef HAVE_CONFIG_H
  65 #include &quot;config.h&quot;
  66 #endif
  67 
  68 /* FIXME 2.0: suppress warnings for deprecated API such as GValueArray
  69  * with newer GLib versions (&gt;= 2.31.0) */
  70 #define GLIB_DISABLE_DEPRECATION_WARNINGS
  71 
  72 #include &lt;string.h&gt;
  73 
  74 #include &quot;gst_private.h&quot;
  75 #include &quot;gstquark.h&quot;
  76 #include &lt;gst/gst.h&gt;
  77 #include &lt;gobject/gvaluecollector.h&gt;
  78 
  79 GST_DEBUG_CATEGORY_STATIC (gst_structure_debug);
  80 #define GST_CAT_DEFAULT gst_structure_debug
  81 
  82 typedef struct _GstStructureField GstStructureField;
  83 
  84 struct _GstStructureField
  85 {
  86   GQuark name;
  87   GValue value;
  88 };
  89 
  90 typedef struct
  91 {
  92   GstStructure s;
  93 
  94   /* owned by parent structure, NULL if no parent */
  95   gint *parent_refcount;
  96 
  97   GArray *fields;
  98 } GstStructureImpl;
  99 
 100 #define GST_STRUCTURE_REFCOUNT(s) (((GstStructureImpl*)(s))-&gt;parent_refcount)
 101 #define GST_STRUCTURE_FIELDS(s) (((GstStructureImpl*)(s))-&gt;fields)
 102 
 103 #define GST_STRUCTURE_FIELD(structure, index) \
 104     &amp;g_array_index(GST_STRUCTURE_FIELDS(structure), GstStructureField, (index))
 105 
 106 #define IS_MUTABLE(structure) \
 107     (!GST_STRUCTURE_REFCOUNT(structure) || \
 108      g_atomic_int_get (GST_STRUCTURE_REFCOUNT(structure)) == 1)
 109 
 110 #define IS_TAGLIST(structure) \
 111     (structure-&gt;name == GST_QUARK (TAGLIST))
 112 
 113 static void gst_structure_set_field (GstStructure * structure,
 114     GstStructureField * field);
 115 static GstStructureField *gst_structure_get_field (const GstStructure *
 116     structure, const gchar * fieldname);
 117 static GstStructureField *gst_structure_id_get_field (const GstStructure *
 118     structure, GQuark field);
 119 static void gst_structure_transform_to_string (const GValue * src_value,
 120     GValue * dest_value);
 121 static GstStructure *gst_structure_copy_conditional (const GstStructure *
 122     structure);
 123 
 124 GType _gst_structure_type = 0;
 125 
 126 
 127 G_DEFINE_BOXED_TYPE (GstStructure, gst_structure,
 128     gst_structure_copy_conditional, gst_structure_free);
 129 
 130 void
 131 _priv_gst_structure_initialize (void)
 132 {
 133   _gst_structure_type = gst_structure_get_type ();
 134 
 135   g_value_register_transform_func (_gst_structure_type, G_TYPE_STRING,
 136       gst_structure_transform_to_string);
 137 
 138   GST_DEBUG_CATEGORY_INIT (gst_structure_debug, &quot;structure&quot;, 0,
 139       &quot;GstStructure debug&quot;);
 140 }
 141 
 142 static GstStructure *
 143 gst_structure_new_id_empty_with_size (GQuark quark, guint prealloc)
 144 {
 145   GstStructureImpl *structure;
 146 
 147   structure = g_slice_new (GstStructureImpl);
 148   ((GstStructure *) structure)-&gt;type = _gst_structure_type;
 149   ((GstStructure *) structure)-&gt;name = quark;
 150   GST_STRUCTURE_REFCOUNT (structure) = NULL;
 151   GST_STRUCTURE_FIELDS (structure) =
 152       g_array_sized_new (FALSE, FALSE, sizeof (GstStructureField), prealloc);
 153 
 154   GST_TRACE (&quot;created structure %p&quot;, structure);
 155 
 156   return GST_STRUCTURE_CAST (structure);
 157 }
 158 
 159 /**
 160  * gst_structure_new_id_empty:
 161  * @quark: name of new structure
 162  *
 163  * Creates a new, empty #GstStructure with the given name as a GQuark.
 164  *
 165  * Free-function: gst_structure_free
 166  *
 167  * Returns: (transfer full): a new, empty #GstStructure
 168  */
 169 GstStructure *
 170 gst_structure_new_id_empty (GQuark quark)
 171 {
 172   g_return_val_if_fail (quark != 0, NULL);
 173 
 174   return gst_structure_new_id_empty_with_size (quark, 0);
 175 }
 176 
 177 #ifndef G_DISABLE_CHECKS
 178 static gboolean
 179 gst_structure_validate_name (const gchar * name)
 180 {
 181   const gchar *s;
 182 
 183   g_return_val_if_fail (name != NULL, FALSE);
 184 
 185   if (G_UNLIKELY (!g_ascii_isalpha (*name))) {
 186     GST_WARNING (&quot;Invalid character &#39;%c&#39; at offset 0 in structure name: %s&quot;,
 187         *name, name);
 188     return FALSE;
 189   }
 190 
 191   /* FIXME: test name string more */
 192   s = &amp;name[1];
 193   while (*s &amp;&amp; (g_ascii_isalnum (*s) || strchr (&quot;/-_.:+&quot;, *s) != NULL))
 194     s++;
 195   if (G_UNLIKELY (*s != &#39;\0&#39;)) {
 196     GST_WARNING (&quot;Invalid character &#39;%c&#39; at offset %&quot; G_GUINTPTR_FORMAT &quot; in&quot;
 197         &quot; structure name: %s&quot;, *s, ((guintptr) s - (guintptr) name), name);
 198     return FALSE;
 199   }
 200 
 201 #ifndef GSTREAMER_LITE
 202   if (strncmp (name, &quot;video/x-raw-&quot;, 12) == 0) {
 203     g_warning (&quot;0.10-style raw video caps are being created. Should be &quot;
 204         &quot;video/x-raw,format=(string).. now.&quot;);
 205   } else if (strncmp (name, &quot;audio/x-raw-&quot;, 12) == 0) {
 206     g_warning (&quot;0.10-style raw audio caps are being created. Should be &quot;
 207         &quot;audio/x-raw,format=(string).. now.&quot;);
 208   }
 209 #endif // GSTREAMER_LITE
 210 
 211   return TRUE;
 212 }
 213 #endif
 214 
 215 /**
 216  * gst_structure_new_empty:
 217  * @name: name of new structure
 218  *
 219  * Creates a new, empty #GstStructure with the given @name.
 220  *
 221  * See gst_structure_set_name() for constraints on the @name parameter.
 222  *
 223  * Free-function: gst_structure_free
 224  *
 225  * Returns: (transfer full): a new, empty #GstStructure
 226  */
 227 GstStructure *
 228 gst_structure_new_empty (const gchar * name)
 229 {
 230   g_return_val_if_fail (gst_structure_validate_name (name), NULL);
 231 
 232   return gst_structure_new_id_empty_with_size (g_quark_from_string (name), 0);
 233 }
 234 
 235 /**
 236  * gst_structure_new:
 237  * @name: name of new structure
 238  * @firstfield: name of first field to set
 239  * @...: additional arguments
 240  *
 241  * Creates a new #GstStructure with the given name.  Parses the
 242  * list of variable arguments and sets fields to the values listed.
 243  * Variable arguments should be passed as field name, field type,
 244  * and value.  Last variable argument should be %NULL.
 245  *
 246  * Free-function: gst_structure_free
 247  *
 248  * Returns: (transfer full): a new #GstStructure
 249  */
 250 GstStructure *
 251 gst_structure_new (const gchar * name, const gchar * firstfield, ...)
 252 {
 253   GstStructure *structure;
 254   va_list varargs;
 255 
 256   va_start (varargs, firstfield);
 257   structure = gst_structure_new_valist (name, firstfield, varargs);
 258   va_end (varargs);
 259 
 260   return structure;
 261 }
 262 
 263 /**
 264  * gst_structure_new_valist:
 265  * @name: name of new structure
 266  * @firstfield: name of first field to set
 267  * @varargs: variable argument list
 268  *
 269  * Creates a new #GstStructure with the given @name.  Structure fields
 270  * are set according to the varargs in a manner similar to
 271  * gst_structure_new().
 272  *
 273  * See gst_structure_set_name() for constraints on the @name parameter.
 274  *
 275  * Free-function: gst_structure_free
 276  *
 277  * Returns: (transfer full): a new #GstStructure
 278  */
 279 GstStructure *
 280 gst_structure_new_valist (const gchar * name,
 281     const gchar * firstfield, va_list varargs)
 282 {
 283   GstStructure *structure;
 284 
 285   structure = gst_structure_new_empty (name);
 286 
 287   if (structure)
 288     gst_structure_set_valist (structure, firstfield, varargs);
 289 
 290   return structure;
 291 }
 292 
 293 /**
 294  * gst_structure_set_parent_refcount:
 295  * @structure: a #GstStructure
 296  * @refcount: (in): a pointer to the parent&#39;s refcount
 297  *
 298  * Sets the parent_refcount field of #GstStructure. This field is used to
 299  * determine whether a structure is mutable or not. This function should only be
 300  * called by code implementing parent objects of #GstStructure, as described in
 301  * the MT Refcounting section of the design documents.
 302  *
 303  * Returns: %TRUE if the parent refcount could be set.
 304  */
 305 gboolean
 306 gst_structure_set_parent_refcount (GstStructure * structure, gint * refcount)
 307 {
 308   g_return_val_if_fail (structure != NULL, FALSE);
 309 
 310   /* if we have a parent_refcount already, we can only clear
 311    * if with a NULL refcount */
 312   if (GST_STRUCTURE_REFCOUNT (structure)) {
 313     if (refcount != NULL) {
 314       g_return_val_if_fail (refcount == NULL, FALSE);
 315       return FALSE;
 316     }
 317   } else {
 318     if (refcount == NULL) {
 319       g_return_val_if_fail (refcount != NULL, FALSE);
 320       return FALSE;
 321     }
 322   }
 323 
 324   GST_STRUCTURE_REFCOUNT (structure) = refcount;
 325 
 326   return TRUE;
 327 }
 328 
 329 /**
 330  * gst_structure_copy:
 331  * @structure: a #GstStructure to duplicate
 332  *
 333  * Duplicates a #GstStructure and all its fields and values.
 334  *
 335  * Free-function: gst_structure_free
 336  *
 337  * Returns: (transfer full): a new #GstStructure.
 338  */
 339 GstStructure *
 340 gst_structure_copy (const GstStructure * structure)
 341 {
 342   GstStructure *new_structure;
 343   GstStructureField *field;
 344   guint i, len;
 345 
 346   g_return_val_if_fail (structure != NULL, NULL);
 347 
 348   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
 349   new_structure = gst_structure_new_id_empty_with_size (structure-&gt;name, len);
 350 
 351   for (i = 0; i &lt; len; i++) {
 352     GstStructureField new_field = { 0 };
 353 
 354     field = GST_STRUCTURE_FIELD (structure, i);
 355 
 356     new_field.name = field-&gt;name;
 357     gst_value_init_and_copy (&amp;new_field.value, &amp;field-&gt;value);
 358     g_array_append_val (GST_STRUCTURE_FIELDS (new_structure), new_field);
 359   }
 360   GST_CAT_TRACE (GST_CAT_PERFORMANCE, &quot;doing copy %p -&gt; %p&quot;,
 361       structure, new_structure);
 362 
 363   return new_structure;
 364 }
 365 
 366 /**
 367  * gst_structure_free:
 368  * @structure: (in) (transfer full): the #GstStructure to free
 369  *
 370  * Frees a #GstStructure and all its fields and values. The structure must not
 371  * have a parent when this function is called.
 372  */
 373 void
 374 gst_structure_free (GstStructure * structure)
 375 {
 376   GstStructureField *field;
 377   guint i, len;
 378 
 379   g_return_if_fail (structure != NULL);
 380   g_return_if_fail (GST_STRUCTURE_REFCOUNT (structure) == NULL);
 381 
 382   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
 383   for (i = 0; i &lt; len; i++) {
 384     field = GST_STRUCTURE_FIELD (structure, i);
 385 
 386     if (G_IS_VALUE (&amp;field-&gt;value)) {
 387       g_value_unset (&amp;field-&gt;value);
 388     }
 389   }
 390   g_array_free (GST_STRUCTURE_FIELDS (structure), TRUE);
 391 #ifdef USE_POISONING
 392   memset (structure, 0xff, sizeof (GstStructure));
 393 #endif
 394   GST_TRACE (&quot;free structure %p&quot;, structure);
 395 
 396   g_slice_free1 (sizeof (GstStructureImpl), structure);
 397 }
 398 
 399 /**
 400  * gst_structure_get_name:
 401  * @structure: a #GstStructure
 402  *
 403  * Get the name of @structure as a string.
 404  *
 405  * Returns: the name of the structure.
 406  */
 407 const gchar *
 408 gst_structure_get_name (const GstStructure * structure)
 409 {
 410   g_return_val_if_fail (structure != NULL, NULL);
 411 
 412   return g_quark_to_string (structure-&gt;name);
 413 }
 414 
 415 /**
 416  * gst_structure_has_name:
 417  * @structure: a #GstStructure
 418  * @name: structure name to check for
 419  *
 420  * Checks if the structure has the given name
 421  *
 422  * Returns: %TRUE if @name matches the name of the structure.
 423  */
 424 gboolean
 425 gst_structure_has_name (const GstStructure * structure, const gchar * name)
 426 {
 427   const gchar *structure_name;
 428 
 429   g_return_val_if_fail (structure != NULL, FALSE);
 430   g_return_val_if_fail (name != NULL, FALSE);
 431 
 432   /* getting the string is cheap and comparing short strings is too
 433    * should be faster than getting the quark for name and comparing the quarks
 434    */
 435   structure_name = g_quark_to_string (structure-&gt;name);
 436 
 437   return (structure_name &amp;&amp; strcmp (structure_name, name) == 0);
 438 }
 439 
 440 /**
 441  * gst_structure_get_name_id:
 442  * @structure: a #GstStructure
 443  *
 444  * Get the name of @structure as a GQuark.
 445  *
 446  * Returns: the quark representing the name of the structure.
 447  */
 448 GQuark
 449 gst_structure_get_name_id (const GstStructure * structure)
 450 {
 451   g_return_val_if_fail (structure != NULL, 0);
 452 
 453   return structure-&gt;name;
 454 }
 455 
 456 /**
 457  * gst_structure_set_name:
 458  * @structure: a #GstStructure
 459  * @name: the new name of the structure
 460  *
 461  * Sets the name of the structure to the given @name.  The string
 462  * provided is copied before being used. It must not be empty, start with a
 463  * letter and can be followed by letters, numbers and any of &quot;/-_.:&quot;.
 464  */
 465 void
 466 gst_structure_set_name (GstStructure * structure, const gchar * name)
 467 {
 468   g_return_if_fail (structure != NULL);
 469   g_return_if_fail (IS_MUTABLE (structure));
 470   g_return_if_fail (gst_structure_validate_name (name));
 471 
 472   structure-&gt;name = g_quark_from_string (name);
 473 }
 474 
 475 static inline void
 476 gst_structure_id_set_value_internal (GstStructure * structure, GQuark field,
 477     const GValue * value)
 478 {
 479   GstStructureField gsfield = { 0, {0,} };
 480 
 481   gsfield.name = field;
 482   gst_value_init_and_copy (&amp;gsfield.value, value);
 483 
 484   gst_structure_set_field (structure, &amp;gsfield);
 485 }
 486 
 487 /**
 488  * gst_structure_id_set_value:
 489  * @structure: a #GstStructure
 490  * @field: a #GQuark representing a field
 491  * @value: the new value of the field
 492  *
 493  * Sets the field with the given GQuark @field to @value.  If the field
 494  * does not exist, it is created.  If the field exists, the previous
 495  * value is replaced and freed.
 496  */
 497 void
 498 gst_structure_id_set_value (GstStructure * structure,
 499     GQuark field, const GValue * value)
 500 {
 501 
 502   g_return_if_fail (structure != NULL);
 503   g_return_if_fail (G_IS_VALUE (value));
 504   g_return_if_fail (IS_MUTABLE (structure));
 505 
 506   gst_structure_id_set_value_internal (structure, field, value);
 507 }
 508 
 509 /**
 510  * gst_structure_set_value:
 511  * @structure: a #GstStructure
 512  * @fieldname: the name of the field to set
 513  * @value: the new value of the field
 514  *
 515  * Sets the field with the given name @field to @value.  If the field
 516  * does not exist, it is created.  If the field exists, the previous
 517  * value is replaced and freed.
 518  */
 519 void
 520 gst_structure_set_value (GstStructure * structure,
 521     const gchar * fieldname, const GValue * value)
 522 {
 523   g_return_if_fail (structure != NULL);
 524   g_return_if_fail (fieldname != NULL);
 525   g_return_if_fail (G_IS_VALUE (value));
 526   g_return_if_fail (IS_MUTABLE (structure));
 527 
 528   gst_structure_id_set_value_internal (structure,
 529       g_quark_from_string (fieldname), value);
 530 }
 531 
 532 static inline void
 533 gst_structure_id_take_value_internal (GstStructure * structure, GQuark field,
 534     GValue * value)
 535 {
 536   GstStructureField gsfield = { 0, {0,} };
 537 
 538   gsfield.name = field;
 539   gsfield.value = *value;
 540 
 541   gst_structure_set_field (structure, &amp;gsfield);
 542 
 543   /* we took ownership */
 544 #ifdef USE_POISONING
 545   memset (value, 0, sizeof (GValue));
 546 #else
 547   value-&gt;g_type = G_TYPE_INVALID;
 548 #endif
 549 }
 550 
 551 /**
 552  * gst_structure_id_take_value:
 553  * @structure: a #GstStructure
 554  * @field: a #GQuark representing a field
 555  * @value: (transfer full): the new value of the field
 556  *
 557  * Sets the field with the given GQuark @field to @value.  If the field
 558  * does not exist, it is created.  If the field exists, the previous
 559  * value is replaced and freed.
 560  */
 561 void
 562 gst_structure_id_take_value (GstStructure * structure, GQuark field,
 563     GValue * value)
 564 {
 565   g_return_if_fail (structure != NULL);
 566   g_return_if_fail (G_IS_VALUE (value));
 567   g_return_if_fail (IS_MUTABLE (structure));
 568 
 569   gst_structure_id_take_value_internal (structure, field, value);
 570 }
 571 
 572 /**
 573  * gst_structure_take_value:
 574  * @structure: a #GstStructure
 575  * @fieldname: the name of the field to set
 576  * @value: (transfer full): the new value of the field
 577  *
 578  * Sets the field with the given name @field to @value.  If the field
 579  * does not exist, it is created.  If the field exists, the previous
 580  * value is replaced and freed. The function will take ownership of @value.
 581  */
 582 void
 583 gst_structure_take_value (GstStructure * structure, const gchar * fieldname,
 584     GValue * value)
 585 {
 586   g_return_if_fail (structure != NULL);
 587   g_return_if_fail (fieldname != NULL);
 588   g_return_if_fail (G_IS_VALUE (value));
 589   g_return_if_fail (IS_MUTABLE (structure));
 590 
 591   gst_structure_id_take_value_internal (structure,
 592       g_quark_from_string (fieldname), value);
 593 }
 594 
 595 static void
 596 gst_structure_set_valist_internal (GstStructure * structure,
 597     const gchar * fieldname, va_list varargs)
 598 {
 599   gchar *err = NULL;
 600   GType type;
 601 
 602   while (fieldname) {
 603     GstStructureField field = { 0 };
 604 
 605     field.name = g_quark_from_string (fieldname);
 606 
 607     type = va_arg (varargs, GType);
 608 
 609     G_VALUE_COLLECT_INIT (&amp;field.value, type, varargs, 0, &amp;err);
 610     if (G_UNLIKELY (err)) {
 611       g_critical (&quot;%s&quot;, err);
 612       return;
 613     }
 614     gst_structure_set_field (structure, &amp;field);
 615 
 616     fieldname = va_arg (varargs, gchar *);
 617   }
 618 }
 619 
 620 /**
 621  * gst_structure_set:
 622  * @structure: a #GstStructure
 623  * @fieldname: the name of the field to set
 624  * @...: variable arguments
 625  *
 626  * Parses the variable arguments and sets fields accordingly. Fields that
 627  * weren&#39;t already part of the structure are added as needed.
 628  * Variable arguments should be in the form field name, field type
 629  * (as a GType), value(s).  The last variable argument should be %NULL.
 630  */
 631 void
 632 gst_structure_set (GstStructure * structure, const gchar * field, ...)
 633 {
 634   va_list varargs;
 635 
 636   g_return_if_fail (structure != NULL);
 637   g_return_if_fail (IS_MUTABLE (structure) || field == NULL);
 638 
 639   va_start (varargs, field);
 640   gst_structure_set_valist_internal (structure, field, varargs);
 641   va_end (varargs);
 642 }
 643 
 644 /**
 645  * gst_structure_set_valist:
 646  * @structure: a #GstStructure
 647  * @fieldname: the name of the field to set
 648  * @varargs: variable arguments
 649  *
 650  * va_list form of gst_structure_set().
 651  */
 652 void
 653 gst_structure_set_valist (GstStructure * structure,
 654     const gchar * fieldname, va_list varargs)
 655 {
 656   g_return_if_fail (structure != NULL);
 657   g_return_if_fail (IS_MUTABLE (structure));
 658 
 659   gst_structure_set_valist_internal (structure, fieldname, varargs);
 660 }
 661 
 662 static void
 663 gst_structure_id_set_valist_internal (GstStructure * structure,
 664     GQuark fieldname, va_list varargs)
 665 {
 666   gchar *err = NULL;
 667   GType type;
 668 
 669   while (fieldname) {
 670     GstStructureField field = { 0 };
 671 
 672     field.name = fieldname;
 673     type = va_arg (varargs, GType);
 674 
 675     G_VALUE_COLLECT_INIT (&amp;field.value, type, varargs, 0, &amp;err);
 676     if (G_UNLIKELY (err)) {
 677       g_critical (&quot;%s&quot;, err);
 678       return;
 679     }
 680     gst_structure_set_field (structure, &amp;field);
 681 
 682     fieldname = va_arg (varargs, GQuark);
 683   }
 684 }
 685 
 686 /**
 687  * gst_structure_id_set:
 688  * @structure: a #GstStructure
 689  * @fieldname: the GQuark for the name of the field to set
 690  * @...: variable arguments
 691  *
 692  * Identical to gst_structure_set, except that field names are
 693  * passed using the GQuark for the field name. This allows more efficient
 694  * setting of the structure if the caller already knows the associated
 695  * quark values.
 696  * The last variable argument must be %NULL.
 697  */
 698 void
 699 gst_structure_id_set (GstStructure * structure, GQuark field, ...)
 700 {
 701   va_list varargs;
 702 
 703   g_return_if_fail (structure != NULL);
 704 
 705   va_start (varargs, field);
 706   gst_structure_id_set_valist_internal (structure, field, varargs);
 707   va_end (varargs);
 708 }
 709 
 710 /**
 711  * gst_structure_id_set_valist:
 712  * @structure: a #GstStructure
 713  * @fieldname: the name of the field to set
 714  * @varargs: variable arguments
 715  *
 716  * va_list form of gst_structure_id_set().
 717  */
 718 void
 719 gst_structure_id_set_valist (GstStructure * structure,
 720     GQuark fieldname, va_list varargs)
 721 {
 722   g_return_if_fail (structure != NULL);
 723   g_return_if_fail (IS_MUTABLE (structure));
 724 
 725   gst_structure_id_set_valist_internal (structure, fieldname, varargs);
 726 }
 727 
 728 /**
 729  * gst_structure_new_id:
 730  * @name_quark: name of new structure
 731  * @field_quark: the GQuark for the name of the field to set
 732  * @...: variable arguments
 733  *
 734  * Creates a new #GstStructure with the given name as a GQuark, followed by
 735  * fieldname quark, GType, argument(s) &quot;triplets&quot; in the same format as
 736  * gst_structure_id_set(). Basically a convenience wrapper around
 737  * gst_structure_new_id_empty() and gst_structure_id_set().
 738  *
 739  * The last variable argument must be %NULL (or 0).
 740  *
 741  * Free-function: gst_structure_free
 742  *
 743  * Returns: (transfer full): a new #GstStructure
 744  */
 745 GstStructure *
 746 gst_structure_new_id (GQuark name_quark, GQuark field_quark, ...)
 747 {
 748   GstStructure *s;
 749   va_list varargs;
 750 
 751   g_return_val_if_fail (name_quark != 0, NULL);
 752   g_return_val_if_fail (field_quark != 0, NULL);
 753 
 754   s = gst_structure_new_id_empty (name_quark);
 755 
 756   va_start (varargs, field_quark);
 757   gst_structure_id_set_valist_internal (s, field_quark, varargs);
 758   va_end (varargs);
 759 
 760   return s;
 761 }
 762 
 763 #if GST_VERSION_NANO == 1
 764 #define GIT_G_WARNING g_warning
 765 #else
 766 #define GIT_G_WARNING GST_WARNING
 767 #endif
 768 
 769 /* If the structure currently contains a field with the same name, it is
 770  * replaced with the provided field. Otherwise, the field is added to the
 771  * structure. The field&#39;s value is not deeply copied.
 772  */
 773 static void
 774 gst_structure_set_field (GstStructure * structure, GstStructureField * field)
 775 {
 776   GstStructureField *f;
 777   GType field_value_type;
 778   guint i, len;
 779 
 780   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
 781 
 782   field_value_type = G_VALUE_TYPE (&amp;field-&gt;value);
 783   if (field_value_type == G_TYPE_STRING) {
 784     const gchar *s;
 785 
 786     s = g_value_get_string (&amp;field-&gt;value);
 787     /* only check for NULL strings in taglists, as they are allowed in message
 788      * structs, e.g. error message debug strings */
 789     if (G_UNLIKELY (IS_TAGLIST (structure) &amp;&amp; (s == NULL || *s == &#39;\0&#39;))) {
 790       if (s == NULL) {
 791         GIT_G_WARNING (&quot;Trying to set NULL string on field &#39;%s&#39; on taglist. &quot;
 792             &quot;Please file a bug.&quot;, g_quark_to_string (field-&gt;name));
 793         g_value_unset (&amp;field-&gt;value);
 794         return;
 795       } else {
 796         /* empty strings never make sense */
 797         GIT_G_WARNING (&quot;Trying to set empty string on taglist field &#39;%s&#39;. &quot;
 798             &quot;Please file a bug.&quot;, g_quark_to_string (field-&gt;name));
 799         g_value_unset (&amp;field-&gt;value);
 800         return;
 801       }
 802     } else if (G_UNLIKELY (s != NULL &amp;&amp; !g_utf8_validate (s, -1, NULL))) {
 803       g_warning (&quot;Trying to set string on %s field &#39;%s&#39;, but string is not &quot;
 804           &quot;valid UTF-8. Please file a bug.&quot;,
 805           IS_TAGLIST (structure) ? &quot;taglist&quot; : &quot;structure&quot;,
 806           g_quark_to_string (field-&gt;name));
 807       g_value_unset (&amp;field-&gt;value);
 808       return;
 809     }
 810   } else if (G_UNLIKELY (field_value_type == G_TYPE_DATE)) {
 811     const GDate *d;
 812 
 813     d = g_value_get_boxed (&amp;field-&gt;value);
 814     /* only check for NULL GDates in taglists, as they might make sense
 815      * in other, generic structs */
 816     if (G_UNLIKELY ((IS_TAGLIST (structure) &amp;&amp; d == NULL))) {
 817       GIT_G_WARNING (&quot;Trying to set NULL GDate on field &#39;%s&#39; on taglist. &quot;
 818           &quot;Please file a bug.&quot;, g_quark_to_string (field-&gt;name));
 819       g_value_unset (&amp;field-&gt;value);
 820       return;
 821     } else if (G_UNLIKELY (d != NULL &amp;&amp; !g_date_valid (d))) {
 822       g_warning
 823           (&quot;Trying to set invalid GDate on %s field &#39;%s&#39;. Please file a bug.&quot;,
 824           IS_TAGLIST (structure) ? &quot;taglist&quot; : &quot;structure&quot;,
 825           g_quark_to_string (field-&gt;name));
 826       g_value_unset (&amp;field-&gt;value);
 827       return;
 828     }
 829   }
 830 
 831   for (i = 0; i &lt; len; i++) {
 832     f = GST_STRUCTURE_FIELD (structure, i);
 833 
 834     if (G_UNLIKELY (f-&gt;name == field-&gt;name)) {
 835       g_value_unset (&amp;f-&gt;value);
 836       memcpy (f, field, sizeof (GstStructureField));
 837       return;
 838     }
 839   }
 840 
 841   g_array_append_val (GST_STRUCTURE_FIELDS (structure), *field);
 842 }
 843 
 844 /* If there is no field with the given ID, NULL is returned.
 845  */
 846 static GstStructureField *
 847 gst_structure_id_get_field (const GstStructure * structure, GQuark field_id)
 848 {
 849   GstStructureField *field;
 850   guint i, len;
 851 
 852   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
 853 
 854   for (i = 0; i &lt; len; i++) {
 855     field = GST_STRUCTURE_FIELD (structure, i);
 856 
 857     if (G_UNLIKELY (field-&gt;name == field_id))
 858       return field;
 859   }
 860 
 861   return NULL;
 862 }
 863 
 864 /* If there is no field with the given ID, NULL is returned.
 865  */
 866 static GstStructureField *
 867 gst_structure_get_field (const GstStructure * structure,
 868     const gchar * fieldname)
 869 {
 870   g_return_val_if_fail (structure != NULL, NULL);
 871   g_return_val_if_fail (fieldname != NULL, NULL);
 872 
 873   return gst_structure_id_get_field (structure,
 874       g_quark_from_string (fieldname));
 875 }
 876 
 877 /**
 878  * gst_structure_get_value:
 879  * @structure: a #GstStructure
 880  * @fieldname: the name of the field to get
 881  *
 882  * Get the value of the field with name @fieldname.
 883  *
 884  * Returns: (nullable): the #GValue corresponding to the field with the given
 885  * name.
 886  */
 887 const GValue *
 888 gst_structure_get_value (const GstStructure * structure,
 889     const gchar * fieldname)
 890 {
 891   GstStructureField *field;
 892 
 893   g_return_val_if_fail (structure != NULL, NULL);
 894   g_return_val_if_fail (fieldname != NULL, NULL);
 895 
 896   field = gst_structure_get_field (structure, fieldname);
 897   if (field == NULL)
 898     return NULL;
 899 
 900   return &amp;field-&gt;value;
 901 }
 902 
 903 /**
 904  * gst_structure_id_get_value:
 905  * @structure: a #GstStructure
 906  * @field: the #GQuark of the field to get
 907  *
 908  * Get the value of the field with GQuark @field.
 909  *
 910  * Returns: (nullable): the #GValue corresponding to the field with the given
 911  * name identifier.
 912  */
 913 const GValue *
 914 gst_structure_id_get_value (const GstStructure * structure, GQuark field)
 915 {
 916   GstStructureField *gsfield;
 917 
 918   g_return_val_if_fail (structure != NULL, NULL);
 919 
 920   gsfield = gst_structure_id_get_field (structure, field);
 921   if (gsfield == NULL)
 922     return NULL;
 923 
 924   return &amp;gsfield-&gt;value;
 925 }
 926 
 927 /**
 928  * gst_structure_remove_field:
 929  * @structure: a #GstStructure
 930  * @fieldname: the name of the field to remove
 931  *
 932  * Removes the field with the given name.  If the field with the given
 933  * name does not exist, the structure is unchanged.
 934  */
 935 void
 936 gst_structure_remove_field (GstStructure * structure, const gchar * fieldname)
 937 {
 938   GstStructureField *field;
 939   GQuark id;
 940   guint i, len;
 941 
 942   g_return_if_fail (structure != NULL);
 943   g_return_if_fail (fieldname != NULL);
 944   g_return_if_fail (IS_MUTABLE (structure));
 945 
 946   id = g_quark_from_string (fieldname);
 947   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
 948 
 949   for (i = 0; i &lt; len; i++) {
 950     field = GST_STRUCTURE_FIELD (structure, i);
 951 
 952     if (field-&gt;name == id) {
 953       if (G_IS_VALUE (&amp;field-&gt;value)) {
 954         g_value_unset (&amp;field-&gt;value);
 955       }
 956       GST_STRUCTURE_FIELDS (structure) =
 957           g_array_remove_index (GST_STRUCTURE_FIELDS (structure), i);
 958       return;
 959     }
 960   }
 961 }
 962 
 963 /**
 964  * gst_structure_remove_fields:
 965  * @structure: a #GstStructure
 966  * @fieldname: the name of the field to remove
 967  * @...: %NULL-terminated list of more fieldnames to remove
 968  *
 969  * Removes the fields with the given names. If a field does not exist, the
 970  * argument is ignored.
 971  */
 972 void
 973 gst_structure_remove_fields (GstStructure * structure,
 974     const gchar * fieldname, ...)
 975 {
 976   va_list varargs;
 977 
 978   g_return_if_fail (structure != NULL);
 979   g_return_if_fail (fieldname != NULL);
 980   /* mutability checked in remove_field */
 981 
 982   va_start (varargs, fieldname);
 983   gst_structure_remove_fields_valist (structure, fieldname, varargs);
 984   va_end (varargs);
 985 }
 986 
 987 /**
 988  * gst_structure_remove_fields_valist:
 989  * @structure: a #GstStructure
 990  * @fieldname: the name of the field to remove
 991  * @varargs: %NULL-terminated list of more fieldnames to remove
 992  *
 993  * va_list form of gst_structure_remove_fields().
 994  */
 995 void
 996 gst_structure_remove_fields_valist (GstStructure * structure,
 997     const gchar * fieldname, va_list varargs)
 998 {
 999   gchar *field = (gchar *) fieldname;
1000 
1001   g_return_if_fail (structure != NULL);
1002   g_return_if_fail (fieldname != NULL);
1003   /* mutability checked in remove_field */
1004 
1005   while (field) {
1006     gst_structure_remove_field (structure, field);
1007     field = va_arg (varargs, char *);
1008   }
1009 }
1010 
1011 /**
1012  * gst_structure_remove_all_fields:
1013  * @structure: a #GstStructure
1014  *
1015  * Removes all fields in a GstStructure.
1016  */
1017 void
1018 gst_structure_remove_all_fields (GstStructure * structure)
1019 {
1020   GstStructureField *field;
1021   int i;
1022 
1023   g_return_if_fail (structure != NULL);
1024   g_return_if_fail (IS_MUTABLE (structure));
1025 
1026   for (i = GST_STRUCTURE_FIELDS (structure)-&gt;len - 1; i &gt;= 0; i--) {
1027     field = GST_STRUCTURE_FIELD (structure, i);
1028 
1029     if (G_IS_VALUE (&amp;field-&gt;value)) {
1030       g_value_unset (&amp;field-&gt;value);
1031     }
1032     GST_STRUCTURE_FIELDS (structure) =
1033         g_array_remove_index (GST_STRUCTURE_FIELDS (structure), i);
1034   }
1035 }
1036 
1037 /**
1038  * gst_structure_get_field_type:
1039  * @structure: a #GstStructure
1040  * @fieldname: the name of the field
1041  *
1042  * Finds the field with the given name, and returns the type of the
1043  * value it contains.  If the field is not found, G_TYPE_INVALID is
1044  * returned.
1045  *
1046  * Returns: the #GValue of the field
1047  */
1048 GType
1049 gst_structure_get_field_type (const GstStructure * structure,
1050     const gchar * fieldname)
1051 {
1052   GstStructureField *field;
1053 
1054   g_return_val_if_fail (structure != NULL, G_TYPE_INVALID);
1055   g_return_val_if_fail (fieldname != NULL, G_TYPE_INVALID);
1056 
1057   field = gst_structure_get_field (structure, fieldname);
1058   if (field == NULL)
1059     return G_TYPE_INVALID;
1060 
1061   return G_VALUE_TYPE (&amp;field-&gt;value);
1062 }
1063 
1064 /**
1065  * gst_structure_n_fields:
1066  * @structure: a #GstStructure
1067  *
1068  * Get the number of fields in the structure.
1069  *
1070  * Returns: the number of fields in the structure
1071  */
1072 gint
1073 gst_structure_n_fields (const GstStructure * structure)
1074 {
1075   g_return_val_if_fail (structure != NULL, 0);
1076 
1077   return GST_STRUCTURE_FIELDS (structure)-&gt;len;
1078 }
1079 
1080 /**
1081  * gst_structure_nth_field_name:
1082  * @structure: a #GstStructure
1083  * @index: the index to get the name of
1084  *
1085  * Get the name of the given field number, counting from 0 onwards.
1086  *
1087  * Returns: the name of the given field number
1088  */
1089 const gchar *
1090 gst_structure_nth_field_name (const GstStructure * structure, guint index)
1091 {
1092   GstStructureField *field;
1093 
1094   g_return_val_if_fail (structure != NULL, NULL);
1095   g_return_val_if_fail (index &lt; GST_STRUCTURE_FIELDS (structure)-&gt;len, NULL);
1096 
1097   field = GST_STRUCTURE_FIELD (structure, index);
1098 
1099   return g_quark_to_string (field-&gt;name);
1100 }
1101 
1102 /**
1103  * gst_structure_foreach:
1104  * @structure: a #GstStructure
1105  * @func: (scope call): a function to call for each field
1106  * @user_data: (closure): private data
1107  *
1108  * Calls the provided function once for each field in the #GstStructure. The
1109  * function must not modify the fields. Also see gst_structure_map_in_place()
1110  * and gst_structure_filter_and_map_in_place().
1111  *
1112  * Returns: %TRUE if the supplied function returns %TRUE For each of the fields,
1113  * %FALSE otherwise.
1114  */
1115 gboolean
1116 gst_structure_foreach (const GstStructure * structure,
1117     GstStructureForeachFunc func, gpointer user_data)
1118 {
1119   guint i, len;
1120   GstStructureField *field;
1121   gboolean ret;
1122 
1123   g_return_val_if_fail (structure != NULL, FALSE);
1124   g_return_val_if_fail (func != NULL, FALSE);
1125 
1126   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
1127 
1128   for (i = 0; i &lt; len; i++) {
1129     field = GST_STRUCTURE_FIELD (structure, i);
1130 
1131     ret = func (field-&gt;name, &amp;field-&gt;value, user_data);
1132     if (G_UNLIKELY (!ret))
1133       return FALSE;
1134   }
1135 
1136   return TRUE;
1137 }
1138 
1139 /**
1140  * gst_structure_map_in_place:
1141  * @structure: a #GstStructure
1142  * @func: (scope call): a function to call for each field
1143  * @user_data: (closure): private data
1144  *
1145  * Calls the provided function once for each field in the #GstStructure. In
1146  * contrast to gst_structure_foreach(), the function may modify but not delete the
1147  * fields. The structure must be mutable.
1148  *
1149  * Returns: %TRUE if the supplied function returns %TRUE For each of the fields,
1150  * %FALSE otherwise.
1151  */
1152 gboolean
1153 gst_structure_map_in_place (GstStructure * structure,
1154     GstStructureMapFunc func, gpointer user_data)
1155 {
1156   guint i, len;
1157   GstStructureField *field;
1158   gboolean ret;
1159 
1160   g_return_val_if_fail (structure != NULL, FALSE);
1161   g_return_val_if_fail (IS_MUTABLE (structure), FALSE);
1162   g_return_val_if_fail (func != NULL, FALSE);
1163   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
1164 
1165   for (i = 0; i &lt; len; i++) {
1166     field = GST_STRUCTURE_FIELD (structure, i);
1167 
1168     ret = func (field-&gt;name, &amp;field-&gt;value, user_data);
1169     if (!ret)
1170       return FALSE;
1171   }
1172 
1173   return TRUE;
1174 }
1175 
1176 /**
1177  * gst_structure_filter_and_map_in_place:
1178  * @structure: a #GstStructure
1179  * @func: (scope call): a function to call for each field
1180  * @user_data: (closure): private data
1181  *
1182  * Calls the provided function once for each field in the #GstStructure. In
1183  * contrast to gst_structure_foreach(), the function may modify the fields.
1184  * In contrast to gst_structure_map_in_place(), the field is removed from
1185  * the structure if %FALSE is returned from the function.
1186  * The structure must be mutable.
1187  *
1188  * Since: 1.6
1189  */
1190 void
1191 gst_structure_filter_and_map_in_place (GstStructure * structure,
1192     GstStructureFilterMapFunc func, gpointer user_data)
1193 {
1194   guint i, len;
1195   GstStructureField *field;
1196   gboolean ret;
1197 
1198   g_return_if_fail (structure != NULL);
1199   g_return_if_fail (IS_MUTABLE (structure));
1200   g_return_if_fail (func != NULL);
1201   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
1202 
1203   for (i = 0; i &lt; len;) {
1204     field = GST_STRUCTURE_FIELD (structure, i);
1205 
1206     ret = func (field-&gt;name, &amp;field-&gt;value, user_data);
1207 
1208     if (!ret) {
1209       if (G_IS_VALUE (&amp;field-&gt;value)) {
1210         g_value_unset (&amp;field-&gt;value);
1211       }
1212       GST_STRUCTURE_FIELDS (structure) =
1213           g_array_remove_index (GST_STRUCTURE_FIELDS (structure), i);
1214       len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
1215     } else {
1216       i++;
1217     }
1218   }
1219 }
1220 
1221 /**
1222  * gst_structure_id_has_field:
1223  * @structure: a #GstStructure
1224  * @field: #GQuark of the field name
1225  *
1226  * Check if @structure contains a field named @field.
1227  *
1228  * Returns: %TRUE if the structure contains a field with the given name
1229  */
1230 gboolean
1231 gst_structure_id_has_field (const GstStructure * structure, GQuark field)
1232 {
1233   GstStructureField *f;
1234 
1235   g_return_val_if_fail (structure != NULL, FALSE);
1236   g_return_val_if_fail (field != 0, FALSE);
1237 
1238   f = gst_structure_id_get_field (structure, field);
1239 
1240   return (f != NULL);
1241 }
1242 
1243 /**
1244  * gst_structure_has_field:
1245  * @structure: a #GstStructure
1246  * @fieldname: the name of a field
1247  *
1248  * Check if @structure contains a field named @fieldname.
1249  *
1250  * Returns: %TRUE if the structure contains a field with the given name
1251  */
1252 gboolean
1253 gst_structure_has_field (const GstStructure * structure,
1254     const gchar * fieldname)
1255 {
1256   g_return_val_if_fail (structure != NULL, FALSE);
1257   g_return_val_if_fail (fieldname != NULL, FALSE);
1258 
1259   return gst_structure_id_has_field (structure,
1260       g_quark_from_string (fieldname));
1261 }
1262 
1263 /**
1264  * gst_structure_id_has_field_typed:
1265  * @structure: a #GstStructure
1266  * @field: #GQuark of the field name
1267  * @type: the type of a value
1268  *
1269  * Check if @structure contains a field named @field and with GType @type.
1270  *
1271  * Returns: %TRUE if the structure contains a field with the given name and type
1272  */
1273 gboolean
1274 gst_structure_id_has_field_typed (const GstStructure * structure,
1275     GQuark field, GType type)
1276 {
1277   GstStructureField *f;
1278 
1279   g_return_val_if_fail (structure != NULL, FALSE);
1280   g_return_val_if_fail (field != 0, FALSE);
1281 
1282   f = gst_structure_id_get_field (structure, field);
1283   if (f == NULL)
1284     return FALSE;
1285 
1286   return (G_VALUE_TYPE (&amp;f-&gt;value) == type);
1287 }
1288 
1289 /**
1290  * gst_structure_has_field_typed:
1291  * @structure: a #GstStructure
1292  * @fieldname: the name of a field
1293  * @type: the type of a value
1294  *
1295  * Check if @structure contains a field named @fieldname and with GType @type.
1296  *
1297  * Returns: %TRUE if the structure contains a field with the given name and type
1298  */
1299 gboolean
1300 gst_structure_has_field_typed (const GstStructure * structure,
1301     const gchar * fieldname, GType type)
1302 {
1303   g_return_val_if_fail (structure != NULL, FALSE);
1304   g_return_val_if_fail (fieldname != NULL, FALSE);
1305 
1306   return gst_structure_id_has_field_typed (structure,
1307       g_quark_from_string (fieldname), type);
1308 }
1309 
1310 /* utility functions */
1311 
1312 /**
1313  * gst_structure_get_boolean:
1314  * @structure: a #GstStructure
1315  * @fieldname: the name of a field
1316  * @value: (out): a pointer to a #gboolean to set
1317  *
1318  * Sets the boolean pointed to by @value corresponding to the value of the
1319  * given field.  Caller is responsible for making sure the field exists
1320  * and has the correct type.
1321  *
1322  * Returns: %TRUE if the value could be set correctly. If there was no field
1323  * with @fieldname or the existing field did not contain a boolean, this
1324  * function returns %FALSE.
1325  */
1326 gboolean
1327 gst_structure_get_boolean (const GstStructure * structure,
1328     const gchar * fieldname, gboolean * value)
1329 {
1330   GstStructureField *field;
1331 
1332   g_return_val_if_fail (structure != NULL, FALSE);
1333   g_return_val_if_fail (fieldname != NULL, FALSE);
1334 
1335   field = gst_structure_get_field (structure, fieldname);
1336 
1337   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != G_TYPE_BOOLEAN)
1338     return FALSE;
1339 
1340   *value = gst_g_value_get_boolean_unchecked (&amp;field-&gt;value);
1341 
1342   return TRUE;
1343 }
1344 
1345 /**
1346  * gst_structure_get_int:
1347  * @structure: a #GstStructure
1348  * @fieldname: the name of a field
1349  * @value: (out): a pointer to an int to set
1350  *
1351  * Sets the int pointed to by @value corresponding to the value of the
1352  * given field.  Caller is responsible for making sure the field exists
1353  * and has the correct type.
1354  *
1355  * Returns: %TRUE if the value could be set correctly. If there was no field
1356  * with @fieldname or the existing field did not contain an int, this function
1357  * returns %FALSE.
1358  */
1359 gboolean
1360 gst_structure_get_int (const GstStructure * structure,
1361     const gchar * fieldname, gint * value)
1362 {
1363   GstStructureField *field;
1364 
1365   g_return_val_if_fail (structure != NULL, FALSE);
1366   g_return_val_if_fail (fieldname != NULL, FALSE);
1367   g_return_val_if_fail (value != NULL, FALSE);
1368 
1369   field = gst_structure_get_field (structure, fieldname);
1370 
1371   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != G_TYPE_INT)
1372     return FALSE;
1373 
1374   *value = gst_g_value_get_int_unchecked (&amp;field-&gt;value);
1375 
1376   return TRUE;
1377 }
1378 
1379 /**
1380  * gst_structure_get_uint:
1381  * @structure: a #GstStructure
1382  * @fieldname: the name of a field
1383  * @value: (out): a pointer to a uint to set
1384  *
1385  * Sets the uint pointed to by @value corresponding to the value of the
1386  * given field.  Caller is responsible for making sure the field exists
1387  * and has the correct type.
1388  *
1389  * Returns: %TRUE if the value could be set correctly. If there was no field
1390  * with @fieldname or the existing field did not contain a uint, this function
1391  * returns %FALSE.
1392  */
1393 gboolean
1394 gst_structure_get_uint (const GstStructure * structure,
1395     const gchar * fieldname, guint * value)
1396 {
1397   GstStructureField *field;
1398 
1399   g_return_val_if_fail (structure != NULL, FALSE);
1400   g_return_val_if_fail (fieldname != NULL, FALSE);
1401   g_return_val_if_fail (value != NULL, FALSE);
1402 
1403   field = gst_structure_get_field (structure, fieldname);
1404 
1405   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != G_TYPE_UINT)
1406     return FALSE;
1407 
1408   *value = gst_g_value_get_uint_unchecked (&amp;field-&gt;value);
1409 
1410   return TRUE;
1411 }
1412 
1413 /**
1414  * gst_structure_get_int64:
1415  * @structure: a #GstStructure
1416  * @fieldname: the name of a field
1417  * @value: (out): a pointer to a #gint64 to set
1418  *
1419  * Sets the #gint64 pointed to by @value corresponding to the value of the
1420  * given field. Caller is responsible for making sure the field exists
1421  * and has the correct type.
1422  *
1423  * Returns: %TRUE if the value could be set correctly. If there was no field
1424  * with @fieldname or the existing field did not contain a #gint64, this function
1425  * returns %FALSE.
1426  *
1427  * Since: 1.4
1428  */
1429 gboolean
1430 gst_structure_get_int64 (const GstStructure * structure,
1431     const gchar * fieldname, gint64 * value)
1432 {
1433   GstStructureField *field;
1434 
1435   g_return_val_if_fail (structure != NULL, FALSE);
1436   g_return_val_if_fail (fieldname != NULL, FALSE);
1437   g_return_val_if_fail (value != NULL, FALSE);
1438 
1439   field = gst_structure_get_field (structure, fieldname);
1440 
1441   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != G_TYPE_INT64)
1442     return FALSE;
1443 
1444   *value = gst_g_value_get_int64_unchecked (&amp;field-&gt;value);
1445 
1446   return TRUE;
1447 }
1448 
1449 /**
1450  * gst_structure_get_uint64:
1451  * @structure: a #GstStructure
1452  * @fieldname: the name of a field
1453  * @value: (out): a pointer to a #guint64 to set
1454  *
1455  * Sets the #guint64 pointed to by @value corresponding to the value of the
1456  * given field. Caller is responsible for making sure the field exists
1457  * and has the correct type.
1458  *
1459  * Returns: %TRUE if the value could be set correctly. If there was no field
1460  * with @fieldname or the existing field did not contain a #guint64, this function
1461  * returns %FALSE.
1462  *
1463  * Since: 1.4
1464  */
1465 gboolean
1466 gst_structure_get_uint64 (const GstStructure * structure,
1467     const gchar * fieldname, guint64 * value)
1468 {
1469   GstStructureField *field;
1470 
1471   g_return_val_if_fail (structure != NULL, FALSE);
1472   g_return_val_if_fail (fieldname != NULL, FALSE);
1473   g_return_val_if_fail (value != NULL, FALSE);
1474 
1475   field = gst_structure_get_field (structure, fieldname);
1476 
1477   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != G_TYPE_UINT64)
1478     return FALSE;
1479 
1480   *value = gst_g_value_get_uint64_unchecked (&amp;field-&gt;value);
1481 
1482   return TRUE;
1483 }
1484 
1485 /**
1486  * gst_structure_get_date:
1487  * @structure: a #GstStructure
1488  * @fieldname: the name of a field
1489  * @value: (out callee-allocates): a pointer to a #GDate to set
1490  *
1491  * Sets the date pointed to by @value corresponding to the date of the
1492  * given field.  Caller is responsible for making sure the field exists
1493  * and has the correct type.
1494  *
1495  * On success @value will point to a newly-allocated copy of the date which
1496  * should be freed with g_date_free() when no longer needed (note: this is
1497  * inconsistent with e.g. gst_structure_get_string() which doesn&#39;t return a
1498  * copy of the string).
1499  *
1500  * Returns: %TRUE if the value could be set correctly. If there was no field
1501  * with @fieldname or the existing field did not contain a data, this function
1502  * returns %FALSE.
1503  */
1504 gboolean
1505 gst_structure_get_date (const GstStructure * structure, const gchar * fieldname,
1506     GDate ** value)
1507 {
1508   GstStructureField *field;
1509 
1510   g_return_val_if_fail (structure != NULL, FALSE);
1511   g_return_val_if_fail (fieldname != NULL, FALSE);
1512   g_return_val_if_fail (value != NULL, FALSE);
1513 
1514   field = gst_structure_get_field (structure, fieldname);
1515 
1516   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != G_TYPE_DATE)
1517     return FALSE;
1518 
1519   /* FIXME: 2.0 g_value_dup_boxed() -&gt; g_value_get_boxed() */
1520   *value = g_value_dup_boxed (&amp;field-&gt;value);
1521 
1522   return TRUE;
1523 }
1524 
1525 /**
1526  * gst_structure_get_date_time:
1527  * @structure: a #GstStructure
1528  * @fieldname: the name of a field
1529  * @value: (out callee-allocates): a pointer to a #GstDateTime to set
1530  *
1531  * Sets the datetime pointed to by @value corresponding to the datetime of the
1532  * given field. Caller is responsible for making sure the field exists
1533  * and has the correct type.
1534  *
1535  * On success @value will point to a reference of the datetime which
1536  * should be unreffed with gst_date_time_unref() when no longer needed
1537  * (note: this is inconsistent with e.g. gst_structure_get_string()
1538  * which doesn&#39;t return a copy of the string).
1539  *
1540  * Returns: %TRUE if the value could be set correctly. If there was no field
1541  * with @fieldname or the existing field did not contain a data, this function
1542  * returns %FALSE.
1543  */
1544 gboolean
1545 gst_structure_get_date_time (const GstStructure * structure,
1546     const gchar * fieldname, GstDateTime ** value)
1547 {
1548   GstStructureField *field;
1549 
1550   g_return_val_if_fail (structure != NULL, FALSE);
1551   g_return_val_if_fail (fieldname != NULL, FALSE);
1552   g_return_val_if_fail (value != NULL, FALSE);
1553 
1554   field = gst_structure_get_field (structure, fieldname);
1555 
1556   if (field == NULL)
1557     return FALSE;
1558   if (!GST_VALUE_HOLDS_DATE_TIME (&amp;field-&gt;value))
1559     return FALSE;
1560 
1561   /* FIXME 2.0: g_value_dup_boxed() -&gt; g_value_get_boxed() */
1562   *value = g_value_dup_boxed (&amp;field-&gt;value);
1563 
1564   return TRUE;
1565 }
1566 
1567 /**
1568  * gst_structure_get_clock_time:
1569  * @structure: a #GstStructure
1570  * @fieldname: the name of a field
1571  * @value: (out): a pointer to a #GstClockTime to set
1572  *
1573  * Sets the clock time pointed to by @value corresponding to the clock time
1574  * of the given field.  Caller is responsible for making sure the field exists
1575  * and has the correct type.
1576  *
1577  * Returns: %TRUE if the value could be set correctly. If there was no field
1578  * with @fieldname or the existing field did not contain a #GstClockTime, this
1579  * function returns %FALSE.
1580  */
1581 gboolean
1582 gst_structure_get_clock_time (const GstStructure * structure,
1583     const gchar * fieldname, GstClockTime * value)
1584 {
1585   return gst_structure_get_uint64 (structure, fieldname, value);
1586 }
1587 
1588 /**
1589  * gst_structure_get_double:
1590  * @structure: a #GstStructure
1591  * @fieldname: the name of a field
1592  * @value: (out): a pointer to a gdouble to set
1593  *
1594  * Sets the double pointed to by @value corresponding to the value of the
1595  * given field.  Caller is responsible for making sure the field exists
1596  * and has the correct type.
1597  *
1598  * Returns: %TRUE if the value could be set correctly. If there was no field
1599  * with @fieldname or the existing field did not contain a double, this
1600  * function returns %FALSE.
1601  */
1602 gboolean
1603 gst_structure_get_double (const GstStructure * structure,
1604     const gchar * fieldname, gdouble * value)
1605 {
1606   GstStructureField *field;
1607 
1608   g_return_val_if_fail (structure != NULL, FALSE);
1609   g_return_val_if_fail (fieldname != NULL, FALSE);
1610   g_return_val_if_fail (value != NULL, FALSE);
1611 
1612   field = gst_structure_get_field (structure, fieldname);
1613 
1614   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != G_TYPE_DOUBLE)
1615     return FALSE;
1616 
1617   *value = gst_g_value_get_double_unchecked (&amp;field-&gt;value);
1618 
1619   return TRUE;
1620 }
1621 
1622 /**
1623  * gst_structure_get_string:
1624  * @structure: a #GstStructure
1625  * @fieldname: the name of a field
1626  *
1627  * Finds the field corresponding to @fieldname, and returns the string
1628  * contained in the field&#39;s value.  Caller is responsible for making
1629  * sure the field exists and has the correct type.
1630  *
1631  * The string should not be modified, and remains valid until the next
1632  * call to a gst_structure_*() function with the given structure.
1633  *
1634  * Returns: (nullable): a pointer to the string or %NULL when the
1635  * field did not exist or did not contain a string.
1636  */
1637 const gchar *
1638 gst_structure_get_string (const GstStructure * structure,
1639     const gchar * fieldname)
1640 {
1641   GstStructureField *field;
1642 
1643   g_return_val_if_fail (structure != NULL, NULL);
1644   g_return_val_if_fail (fieldname != NULL, NULL);
1645 
1646   field = gst_structure_get_field (structure, fieldname);
1647 
1648   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != G_TYPE_STRING)
1649     return NULL;
1650 
1651   return gst_g_value_get_string_unchecked (&amp;field-&gt;value);
1652 }
1653 
1654 /**
1655  * gst_structure_get_enum:
1656  * @structure: a #GstStructure
1657  * @fieldname: the name of a field
1658  * @enumtype: the enum type of a field
1659  * @value: (out): a pointer to an int to set
1660  *
1661  * Sets the int pointed to by @value corresponding to the value of the
1662  * given field.  Caller is responsible for making sure the field exists,
1663  * has the correct type and that the enumtype is correct.
1664  *
1665  * Returns: %TRUE if the value could be set correctly. If there was no field
1666  * with @fieldname or the existing field did not contain an enum of the given
1667  * type, this function returns %FALSE.
1668  */
1669 gboolean
1670 gst_structure_get_enum (const GstStructure * structure,
1671     const gchar * fieldname, GType enumtype, gint * value)
1672 {
1673   GstStructureField *field;
1674 
1675   g_return_val_if_fail (structure != NULL, FALSE);
1676   g_return_val_if_fail (fieldname != NULL, FALSE);
1677   g_return_val_if_fail (enumtype != G_TYPE_INVALID, FALSE);
1678   g_return_val_if_fail (value != NULL, FALSE);
1679 
1680   field = gst_structure_get_field (structure, fieldname);
1681 
1682   if (field == NULL)
1683     return FALSE;
1684   if (!G_TYPE_CHECK_VALUE_TYPE (&amp;field-&gt;value, enumtype))
1685     return FALSE;
1686 
1687   *value = g_value_get_enum (&amp;field-&gt;value);
1688 
1689   return TRUE;
1690 }
1691 
1692 /**
1693  * gst_structure_get_fraction:
1694  * @structure: a #GstStructure
1695  * @fieldname: the name of a field
1696  * @value_numerator: (out): a pointer to an int to set
1697  * @value_denominator: (out): a pointer to an int to set
1698  *
1699  * Sets the integers pointed to by @value_numerator and @value_denominator
1700  * corresponding to the value of the given field.  Caller is responsible
1701  * for making sure the field exists and has the correct type.
1702  *
1703  * Returns: %TRUE if the values could be set correctly. If there was no field
1704  * with @fieldname or the existing field did not contain a GstFraction, this
1705  * function returns %FALSE.
1706  */
1707 gboolean
1708 gst_structure_get_fraction (const GstStructure * structure,
1709     const gchar * fieldname, gint * value_numerator, gint * value_denominator)
1710 {
1711   GstStructureField *field;
1712 
1713   g_return_val_if_fail (structure != NULL, FALSE);
1714   g_return_val_if_fail (fieldname != NULL, FALSE);
1715   g_return_val_if_fail (value_numerator != NULL, FALSE);
1716   g_return_val_if_fail (value_denominator != NULL, FALSE);
1717 
1718   field = gst_structure_get_field (structure, fieldname);
1719 
1720   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != GST_TYPE_FRACTION)
1721     return FALSE;
1722 
1723   *value_numerator = gst_value_get_fraction_numerator (&amp;field-&gt;value);
1724   *value_denominator = gst_value_get_fraction_denominator (&amp;field-&gt;value);
1725 
1726   return TRUE;
1727 }
1728 
1729 /**
1730  * gst_structure_get_flagset:
1731  * @structure: a #GstStructure
1732  * @fieldname: the name of a field
1733  * @value_flags: (out) (allow-none): a pointer to a guint for the flags field
1734  * @value_mask: (out) (allow-none): a pointer to a guint for the mask field
1735  *
1736  * Read the GstFlagSet flags and mask out of the structure into the
1737  * provided pointers.
1738  *
1739  * Returns: %TRUE if the values could be set correctly. If there was no field
1740  * with @fieldname or the existing field did not contain a GstFlagSet, this
1741  * function returns %FALSE.
1742  *
1743  * Since: 1.6
1744  */
1745 gboolean
1746 gst_structure_get_flagset (const GstStructure * structure,
1747     const gchar * fieldname, guint * value_flags, guint * value_mask)
1748 {
1749   GstStructureField *field;
1750 
1751   g_return_val_if_fail (structure != NULL, FALSE);
1752   g_return_val_if_fail (fieldname != NULL, FALSE);
1753 
1754   field = gst_structure_get_field (structure, fieldname);
1755 
1756   if (field == NULL || !GST_VALUE_HOLDS_FLAG_SET (&amp;field-&gt;value))
1757     return FALSE;
1758 
1759   if (value_flags)
1760     *value_flags = gst_value_get_flagset_flags (&amp;field-&gt;value);
1761   if (value_mask)
1762     *value_mask = gst_value_get_flagset_mask (&amp;field-&gt;value);
1763 
1764   return TRUE;
1765     }
1766 
1767 static GType
1768 gst_structure_value_get_generic_type (const GValue * val)
1769 {
1770   if (G_VALUE_TYPE (val) == GST_TYPE_LIST
1771       || G_VALUE_TYPE (val) == GST_TYPE_ARRAY) {
1772     GArray *array = g_value_peek_pointer (val);
1773 
1774     if (array-&gt;len &gt; 0) {
1775       GValue *value = &amp;g_array_index (array, GValue, 0);
1776 
1777       return gst_structure_value_get_generic_type (value);
1778     } else {
1779       return G_TYPE_INT;
1780     }
1781   } else if (G_VALUE_TYPE (val) == GST_TYPE_INT_RANGE) {
1782     return G_TYPE_INT;
1783   } else if (G_VALUE_TYPE (val) == GST_TYPE_INT64_RANGE) {
1784     return G_TYPE_INT64;
1785   } else if (G_VALUE_TYPE (val) == GST_TYPE_DOUBLE_RANGE) {
1786     return G_TYPE_DOUBLE;
1787   } else if (G_VALUE_TYPE (val) == GST_TYPE_FRACTION_RANGE) {
1788     return GST_TYPE_FRACTION;
1789   }
1790   return G_VALUE_TYPE (val);
1791 }
1792 
1793 gboolean
1794 priv_gst_structure_append_to_gstring (const GstStructure * structure,
1795     GString * s)
1796 {
1797   GstStructureField *field;
1798   guint i, len;
1799 
1800   g_return_val_if_fail (s != NULL, FALSE);
1801 
1802   len = GST_STRUCTURE_FIELDS (structure)-&gt;len;
1803   for (i = 0; i &lt; len; i++) {
1804     char *t;
1805     GType type;
1806 
1807     field = GST_STRUCTURE_FIELD (structure, i);
1808 
1809     if (G_VALUE_TYPE (&amp;field-&gt;value) == GST_TYPE_ARRAY) {
1810       t = _priv_gst_value_serialize_any_list (&amp;field-&gt;value, &quot;&lt; &quot;, &quot; &gt;&quot;, FALSE);
1811     } else if (G_VALUE_TYPE (&amp;field-&gt;value) == GST_TYPE_LIST) {
1812       t = _priv_gst_value_serialize_any_list (&amp;field-&gt;value, &quot;{ &quot;, &quot; }&quot;, FALSE);
1813     } else {
1814     t = gst_value_serialize (&amp;field-&gt;value);
1815     }
1816 
1817     type = gst_structure_value_get_generic_type (&amp;field-&gt;value);
1818 
1819     g_string_append_len (s, &quot;, &quot;, 2);
1820     /* FIXME: do we need to escape fieldnames? */
1821     g_string_append (s, g_quark_to_string (field-&gt;name));
1822     g_string_append_len (s, &quot;=(&quot;, 2);
1823     g_string_append (s, _priv_gst_value_gtype_to_abbr (type));
1824     g_string_append_c (s, &#39;)&#39;);
1825     if (t) {
1826       g_string_append (s, t);
1827     g_free (t);
1828     } else {
1829       if (!G_TYPE_CHECK_VALUE_TYPE (&amp;field-&gt;value, G_TYPE_STRING) &amp;&amp;
1830           !(G_TYPE_CHECK_VALUE_TYPE (&amp;field-&gt;value, G_TYPE_POINTER) &amp;&amp;
1831               g_value_get_pointer (&amp;field-&gt;value) == NULL))
1832         GST_WARNING (&quot;No value transform to serialize field &#39;%s&#39; of type &#39;%s&#39;&quot;,
1833             g_quark_to_string (field-&gt;name),
1834             _priv_gst_value_gtype_to_abbr (type));
1835       /* TODO(ensonic): don&#39;t print NULL if field-&gt;value is not empty */
1836       g_string_append (s, &quot;NULL&quot;);
1837   }
1838   }
1839 
1840   g_string_append_c (s, &#39;;&#39;);
1841   return TRUE;
1842 }
1843 
1844 gboolean
1845 priv__gst_structure_append_template_to_gstring (GQuark field_id,
1846     const GValue * value, gpointer user_data)
1847 {
1848   GType type = gst_structure_value_get_generic_type (value);
1849   GString *s = (GString *) user_data;
1850 
1851   g_string_append_len (s, &quot;, &quot;, 2);
1852   /* FIXME: do we need to escape fieldnames? */
1853   g_string_append (s, g_quark_to_string (field_id));
1854   g_string_append_len (s, &quot;=(&quot;, 2);
1855   g_string_append (s, _priv_gst_value_gtype_to_abbr (type));
1856   g_string_append_c (s, &#39;)&#39;);
1857 
1858   //TODO(ensonic): table like GstStructureAbbreviation (or extend it)
1859   if (type == G_TYPE_INT) {
1860     g_string_append_len (s, &quot;%i&quot;, 2);
1861   } else if (type == G_TYPE_UINT) {
1862     g_string_append_len (s, &quot;%u&quot;, 2);
1863   } else if (type == G_TYPE_FLOAT) {
1864     g_string_append_len (s, &quot;%f&quot;, 2);
1865   } else if (type == G_TYPE_DOUBLE) {
1866     g_string_append_len (s, &quot;%lf&quot;, 3);
1867   } else if (type == G_TYPE_STRING) {
1868     g_string_append_len (s, &quot;%s&quot;, 2);
1869   } else if (type == G_TYPE_BOOLEAN) {
1870     /* we normally store this as a string, but can parse it also from an int */
1871     g_string_append_len (s, &quot;%i&quot;, 2);
1872   } else if (type == G_TYPE_INT64) {
1873     g_string_append (s, &quot;%&quot; G_GINT64_FORMAT);
1874   } else if (type == G_TYPE_UINT64) {
1875     g_string_append (s, &quot;%&quot; G_GUINT64_FORMAT);
1876   } else if (type == GST_TYPE_STRUCTURE) {
1877     g_string_append (s, &quot;%&quot; GST_WRAPPED_PTR_FORMAT);
1878   } else if (g_type_is_a (type, G_TYPE_ENUM)
1879       || g_type_is_a (type, G_TYPE_FLAGS)) {
1880     g_string_append_len (s, &quot;%i&quot;, 2);
1881   } else if (type == G_TYPE_GTYPE) {
1882     g_string_append_len (s, &quot;%s&quot;, 2);
1883   } else if (type == G_TYPE_POINTER) {
1884     g_string_append_len (s, &quot;%p&quot;, 2);
1885   } else {
1886     GST_WARNING (&quot;unhandled type: %s&quot;, g_type_name (type));
1887     g_string_append (s, &quot;%&quot; GST_WRAPPED_PTR_FORMAT);
1888   }
1889 
1890   return TRUE;
1891 }
1892 
1893 /**
1894  * gst_structure_to_string:
1895  * @structure: a #GstStructure
1896  *
1897  * Converts @structure to a human-readable string representation.
1898  *
1899  * For debugging purposes its easier to do something like this:
1900  * |[&lt;!-- language=&quot;C&quot; --&gt;
1901  * GST_LOG (&quot;structure is %&quot; GST_PTR_FORMAT, structure);
1902  * ]|
1903  * This prints the structure in human readable form.
1904  *
1905  * The current implementation of serialization will lead to unexpected results
1906  * when there are nested #GstCaps / #GstStructure deeper than one level.
1907  *
1908  * Free-function: g_free
1909  *
1910  * Returns: (transfer full): a pointer to string allocated by g_malloc().
1911  *     g_free() after usage.
1912  */
1913 gchar *
1914 gst_structure_to_string (const GstStructure * structure)
1915 {
1916   GString *s;
1917 
1918   /* NOTE:  This function is potentially called by the debug system,
1919    * so any calls to gst_log() (and GST_DEBUG(), GST_LOG(), etc.)
1920    * should be careful to avoid recursion.  This includes any functions
1921    * called by gst_structure_to_string.  In particular, calls should
1922    * not use the GST_PTR_FORMAT extension.  */
1923 
1924   g_return_val_if_fail (structure != NULL, NULL);
1925 
1926   /* we estimate a minimum size based on the number of fields in order to
1927    * avoid unnecessary reallocs within GString */
1928   s = g_string_sized_new (STRUCTURE_ESTIMATED_STRING_LEN (structure));
1929   g_string_append (s, g_quark_to_string (structure-&gt;name));
1930   priv_gst_structure_append_to_gstring (structure, s);
1931   return g_string_free (s, FALSE);
1932 }
1933 
1934 static gboolean
1935 gst_structure_parse_field (gchar * str,
1936     gchar ** after, GstStructureField * field)
1937 {
1938   gchar *name;
1939   gchar *name_end;
1940   gchar *s;
1941   gchar c;
1942 
1943   s = str;
1944 
1945   while (g_ascii_isspace (*s) || (s[0] == &#39;\\&#39; &amp;&amp; g_ascii_isspace (s[1])))
1946     s++;
1947   name = s;
1948   if (G_UNLIKELY (!_priv_gst_value_parse_simple_string (s, &amp;name_end))) {
1949     GST_WARNING (&quot;failed to parse simple string, str=%s&quot;, str);
1950     return FALSE;
1951   }
1952 
1953   s = name_end;
1954   while (g_ascii_isspace (*s) || (s[0] == &#39;\\&#39; &amp;&amp; g_ascii_isspace (s[1])))
1955     s++;
1956 
1957   if (G_UNLIKELY (*s != &#39;=&#39;)) {
1958     GST_WARNING (&quot;missing assignment operator in the field, str=%s&quot;, str);
1959     return FALSE;
1960   }
1961   s++;
1962 
1963   c = *name_end;
1964   *name_end = &#39;\0&#39;;
1965   field-&gt;name = g_quark_from_string (name);
1966   GST_DEBUG (&quot;trying field name &#39;%s&#39;&quot;, name);
1967   *name_end = c;
1968 
1969   if (G_UNLIKELY (!_priv_gst_value_parse_value (s, &amp;s, &amp;field-&gt;value,
1970               G_TYPE_INVALID))) {
1971     GST_WARNING (&quot;failed to parse value %s&quot;, str);
1972     return FALSE;
1973   }
1974 
1975   *after = s;
1976   return TRUE;
1977 }
1978 
1979 gboolean
1980 priv_gst_structure_parse_name (gchar * str, gchar ** start, gchar ** end,
1981     gchar ** next)
1982 {
1983   char *w;
1984   char *r;
1985 
1986   r = str;
1987 
1988   /* skip spaces (FIXME: _isspace treats tabs and newlines as space!) */
1989   while (*r &amp;&amp; (g_ascii_isspace (*r) || (r[0] == &#39;\\&#39;
1990               &amp;&amp; g_ascii_isspace (r[1]))))
1991     r++;
1992 
1993   *start = r;
1994 
1995   if (G_UNLIKELY (!_priv_gst_value_parse_string (r, &amp;w, &amp;r, TRUE))) {
1996     GST_WARNING (&quot;Failed to parse structure string &#39;%s&#39;&quot;, str);
1997     return FALSE;
1998   }
1999 
2000   *end = w;
2001   *next = r;
2002 
2003   return TRUE;
2004 }
2005 
2006 gboolean
2007 priv_gst_structure_parse_fields (gchar * str, gchar ** end,
2008     GstStructure * structure)
2009 {
2010   gchar *r;
2011   GstStructureField field;
2012 
2013   r = str;
2014 
2015   do {
2016     while (*r &amp;&amp; (g_ascii_isspace (*r) || (r[0] == &#39;\\&#39;
2017                 &amp;&amp; g_ascii_isspace (r[1]))))
2018       r++;
2019     if (*r == &#39;;&#39;) {
2020       /* end of structure, get the next char and finish */
2021       r++;
2022       break;
2023     }
2024     if (*r == &#39;\0&#39;) {
2025       /* accept \0 as end delimiter */
2026       break;
2027     }
2028     if (G_UNLIKELY (*r != &#39;,&#39;)) {
2029       GST_WARNING (&quot;Failed to find delimiter, r=%s&quot;, r);
2030       return FALSE;
2031     }
2032     r++;
2033     while (*r &amp;&amp; (g_ascii_isspace (*r) || (r[0] == &#39;\\&#39;
2034                 &amp;&amp; g_ascii_isspace (r[1]))))
2035       r++;
2036 
2037     memset (&amp;field, 0, sizeof (field));
2038     if (G_UNLIKELY (!gst_structure_parse_field (r, &amp;r, &amp;field))) {
2039       GST_WARNING (&quot;Failed to parse field, r=%s&quot;, r);
2040       return FALSE;
2041     }
2042     gst_structure_set_field (structure, &amp;field);
2043   } while (TRUE);
2044 
2045   *end = r;
2046 
2047   return TRUE;
2048 }
2049 
2050 /**
2051  * gst_structure_new_from_string:
2052  * @string: a string representation of a #GstStructure
2053  *
2054  * Creates a #GstStructure from a string representation.
2055  * If end is not %NULL, a pointer to the place inside the given string
2056  * where parsing ended will be returned.
2057  *
2058  * The current implementation of serialization will lead to unexpected results
2059  * when there are nested #GstCaps / #GstStructure deeper than one level.
2060  *
2061  * Free-function: gst_structure_free
2062  *
2063  * Returns: (transfer full) (nullable): a new #GstStructure or %NULL
2064  *     when the string could not be parsed. Free with
2065  *     gst_structure_free() after use.
2066  *
2067  * Since: 1.2
2068  */
2069 GstStructure *
2070 gst_structure_new_from_string (const gchar * string)
2071 {
2072   return gst_structure_from_string (string, NULL);
2073 }
2074 
2075 /**
2076  * gst_structure_from_string:
2077  * @string: a string representation of a #GstStructure.
2078  * @end: (out) (allow-none) (transfer none) (skip): pointer to store the end of the string in.
2079  *
2080  * Creates a #GstStructure from a string representation.
2081  * If end is not %NULL, a pointer to the place inside the given string
2082  * where parsing ended will be returned.
2083  *
2084  * Free-function: gst_structure_free
2085  *
2086  * Returns: (transfer full) (nullable): a new #GstStructure or %NULL
2087  *     when the string could not be parsed. Free with
2088  *     gst_structure_free() after use.
2089  */
2090 GstStructure *
2091 gst_structure_from_string (const gchar * string, gchar ** end)
2092 {
2093   char *name;
2094   char *copy;
2095   char *w;
2096   char *r;
2097   char save;
2098   GstStructure *structure = NULL;
2099 
2100   g_return_val_if_fail (string != NULL, NULL);
2101 
2102   copy = g_strdup (string);
2103   r = copy;
2104 
2105   if (!priv_gst_structure_parse_name (r, &amp;name, &amp;w, &amp;r))
2106     goto error;
2107 
2108   save = *w;
2109   *w = &#39;\0&#39;;
2110   structure = gst_structure_new_empty (name);
2111   *w = save;
2112 
2113   if (G_UNLIKELY (structure == NULL))
2114     goto error;
2115 
2116   if (!priv_gst_structure_parse_fields (r, &amp;r, structure))
2117     goto error;
2118 
2119   if (end)
2120     *end = (char *) string + (r - copy);
2121   else if (*r)
2122     g_warning (&quot;gst_structure_from_string did not consume whole string,&quot;
2123         &quot; but caller did not provide end pointer (\&quot;%s\&quot;)&quot;, string);
2124 
2125   g_free (copy);
2126   return structure;
2127 
2128 error:
2129   if (structure)
2130     gst_structure_free (structure);
2131   g_free (copy);
2132   return NULL;
2133 }
2134 
2135 static void
2136 gst_structure_transform_to_string (const GValue * src_value,
2137     GValue * dest_value)
2138 {
2139   g_return_if_fail (src_value != NULL);
2140   g_return_if_fail (dest_value != NULL);
2141 
2142   dest_value-&gt;data[0].v_pointer =
2143       gst_structure_to_string (src_value-&gt;data[0].v_pointer);
2144 }
2145 
2146 static GstStructure *
2147 gst_structure_copy_conditional (const GstStructure * structure)
2148 {
2149   if (structure)
2150     return gst_structure_copy (structure);
2151   return NULL;
2152 }
2153 
2154 /* fixate utility functions */
2155 
2156 /**
2157  * gst_structure_fixate_field_nearest_int:
2158  * @structure: a #GstStructure
2159  * @field_name: a field in @structure
2160  * @target: the target value of the fixation
2161  *
2162  * Fixates a #GstStructure by changing the given field to the nearest
2163  * integer to @target that is a subset of the existing field.
2164  *
2165  * Returns: %TRUE if the structure could be fixated
2166  */
2167 gboolean
2168 gst_structure_fixate_field_nearest_int (GstStructure * structure,
2169     const char *field_name, int target)
2170 {
2171   const GValue *value;
2172 
2173   g_return_val_if_fail (gst_structure_has_field (structure, field_name), FALSE);
2174   g_return_val_if_fail (IS_MUTABLE (structure), FALSE);
2175 
2176   value = gst_structure_get_value (structure, field_name);
2177 #ifdef GSTREAMER_LITE
2178   if (value == NULL) {
2179     return FALSE;
2180   }
2181 #endif // GSTREAMER_LITE
2182 
2183   if (G_VALUE_TYPE (value) == G_TYPE_INT) {
2184     /* already fixed */
2185     return FALSE;
2186   } else if (G_VALUE_TYPE (value) == GST_TYPE_INT_RANGE) {
2187     int x;
2188 
2189     x = gst_value_get_int_range_min (value);
2190     if (target &lt; x)
2191       target = x;
2192     x = gst_value_get_int_range_max (value);
2193     if (target &gt; x)
2194       target = x;
2195     gst_structure_set (structure, field_name, G_TYPE_INT, target, NULL);
2196     return TRUE;
2197   } else if (G_VALUE_TYPE (value) == GST_TYPE_LIST) {
2198     const GValue *list_value;
2199     int i, n;
2200     int best = 0;
2201     int best_index = -1;
2202 
2203     n = gst_value_list_get_size (value);
2204     for (i = 0; i &lt; n; i++) {
2205       list_value = gst_value_list_get_value (value, i);
2206       if (G_VALUE_TYPE (list_value) == G_TYPE_INT) {
2207         int x = gst_g_value_get_int_unchecked (list_value);
2208 
2209         if (best_index == -1 || (ABS (target - x) &lt; ABS (target - best))) {
2210           best_index = i;
2211           best = x;
2212         }
2213       }
2214     }
2215     if (best_index != -1) {
2216       gst_structure_set (structure, field_name, G_TYPE_INT, best, NULL);
2217       return TRUE;
2218     }
2219     return FALSE;
2220   }
2221 
2222   return FALSE;
2223 }
2224 
2225 /**
2226  * gst_structure_fixate_field_nearest_double:
2227  * @structure: a #GstStructure
2228  * @field_name: a field in @structure
2229  * @target: the target value of the fixation
2230  *
2231  * Fixates a #GstStructure by changing the given field to the nearest
2232  * double to @target that is a subset of the existing field.
2233  *
2234  * Returns: %TRUE if the structure could be fixated
2235  */
2236 gboolean
2237 gst_structure_fixate_field_nearest_double (GstStructure * structure,
2238     const char *field_name, double target)
2239 {
2240   const GValue *value;
2241 
2242   g_return_val_if_fail (gst_structure_has_field (structure, field_name), FALSE);
2243   g_return_val_if_fail (IS_MUTABLE (structure), FALSE);
2244 
2245   value = gst_structure_get_value (structure, field_name);
2246 #ifdef GSTREAMER_LITE
2247   if (value == NULL) {
2248     return FALSE;
2249   }
2250 #endif // GSTREAMER_LITE
2251 
2252   if (G_VALUE_TYPE (value) == G_TYPE_DOUBLE) {
2253     /* already fixed */
2254     return FALSE;
2255   } else if (G_VALUE_TYPE (value) == GST_TYPE_DOUBLE_RANGE) {
2256     double x;
2257 
2258     x = gst_value_get_double_range_min (value);
2259     if (target &lt; x)
2260       target = x;
2261     x = gst_value_get_double_range_max (value);
2262     if (target &gt; x)
2263       target = x;
2264     gst_structure_set (structure, field_name, G_TYPE_DOUBLE, target, NULL);
2265     return TRUE;
2266   } else if (G_VALUE_TYPE (value) == GST_TYPE_LIST) {
2267     const GValue *list_value;
2268     int i, n;
2269     double best = 0;
2270     int best_index = -1;
2271 
2272     n = gst_value_list_get_size (value);
2273     for (i = 0; i &lt; n; i++) {
2274       list_value = gst_value_list_get_value (value, i);
2275       if (G_VALUE_TYPE (list_value) == G_TYPE_DOUBLE) {
2276         double x = gst_g_value_get_double_unchecked (list_value);
2277 
2278         if (best_index == -1 || (ABS (target - x) &lt; ABS (target - best))) {
2279           best_index = i;
2280           best = x;
2281         }
2282       }
2283     }
2284     if (best_index != -1) {
2285       gst_structure_set (structure, field_name, G_TYPE_DOUBLE, best, NULL);
2286       return TRUE;
2287     }
2288     return FALSE;
2289   }
2290 
2291   return FALSE;
2292 
2293 }
2294 
2295 /**
2296  * gst_structure_fixate_field_boolean:
2297  * @structure: a #GstStructure
2298  * @field_name: a field in @structure
2299  * @target: the target value of the fixation
2300  *
2301  * Fixates a #GstStructure by changing the given @field_name field to the given
2302  * @target boolean if that field is not fixed yet.
2303  *
2304  * Returns: %TRUE if the structure could be fixated
2305  */
2306 gboolean
2307 gst_structure_fixate_field_boolean (GstStructure * structure,
2308     const char *field_name, gboolean target)
2309 {
2310   const GValue *value;
2311 
2312   g_return_val_if_fail (gst_structure_has_field (structure, field_name), FALSE);
2313   g_return_val_if_fail (IS_MUTABLE (structure), FALSE);
2314 
2315   value = gst_structure_get_value (structure, field_name);
2316 #ifdef GSTREAMER_LITE
2317   if (value == NULL) {
2318     return FALSE;
2319   }
2320 #endif // GSTREAMER_LITE
2321 
2322   if (G_VALUE_TYPE (value) == G_TYPE_BOOLEAN) {
2323     /* already fixed */
2324     return FALSE;
2325   } else if (G_VALUE_TYPE (value) == GST_TYPE_LIST) {
2326     const GValue *list_value;
2327     int i, n;
2328     int best = 0;
2329     int best_index = -1;
2330 
2331     n = gst_value_list_get_size (value);
2332     for (i = 0; i &lt; n; i++) {
2333       list_value = gst_value_list_get_value (value, i);
2334       if (G_VALUE_TYPE (list_value) == G_TYPE_BOOLEAN) {
2335         gboolean x = gst_g_value_get_boolean_unchecked (list_value);
2336 
2337         if (best_index == -1 || x == target) {
2338           best_index = i;
2339           best = x;
2340         }
2341       }
2342     }
2343     if (best_index != -1) {
2344       gst_structure_set (structure, field_name, G_TYPE_BOOLEAN, best, NULL);
2345       return TRUE;
2346     }
2347     return FALSE;
2348   }
2349 
2350   return FALSE;
2351 }
2352 
2353 /**
2354  * gst_structure_fixate_field_string:
2355  * @structure: a #GstStructure
2356  * @field_name: a field in @structure
2357  * @target: the target value of the fixation
2358  *
2359  * Fixates a #GstStructure by changing the given @field_name field to the given
2360  * @target string if that field is not fixed yet.
2361  *
2362  * Returns: %TRUE if the structure could be fixated
2363  */
2364 gboolean
2365 gst_structure_fixate_field_string (GstStructure * structure,
2366     const gchar * field_name, const gchar * target)
2367 {
2368   const GValue *value;
2369 
2370   g_return_val_if_fail (gst_structure_has_field (structure, field_name), FALSE);
2371   g_return_val_if_fail (IS_MUTABLE (structure), FALSE);
2372 
2373   value = gst_structure_get_value (structure, field_name);
2374 #ifdef GSTREAMER_LITE
2375   if (value == NULL) {
2376     return FALSE;
2377   }
2378 #endif // GSTREAMER_LITE
2379 
2380   if (G_VALUE_TYPE (value) == G_TYPE_STRING) {
2381     /* already fixed */
2382     return FALSE;
2383   } else if (G_VALUE_TYPE (value) == GST_TYPE_LIST) {
2384     const GValue *list_value;
2385     int i, n;
2386     const gchar *best = NULL;
2387     int best_index = -1;
2388 
2389     n = gst_value_list_get_size (value);
2390     for (i = 0; i &lt; n; i++) {
2391       list_value = gst_value_list_get_value (value, i);
2392       if (G_VALUE_TYPE (list_value) == G_TYPE_STRING) {
2393         const gchar *x = g_value_get_string (list_value);
2394 
2395         if (best_index == -1 || g_str_equal (x, target)) {
2396           best_index = i;
2397           best = x;
2398         }
2399       }
2400     }
2401     if (best_index != -1) {
2402       gst_structure_set (structure, field_name, G_TYPE_STRING, best, NULL);
2403       return TRUE;
2404     }
2405     return FALSE;
2406   }
2407 
2408   return FALSE;
2409 }
2410 
2411 /**
2412  * gst_structure_fixate_field_nearest_fraction:
2413  * @structure: a #GstStructure
2414  * @field_name: a field in @structure
2415  * @target_numerator: The numerator of the target value of the fixation
2416  * @target_denominator: The denominator of the target value of the fixation
2417  *
2418  * Fixates a #GstStructure by changing the given field to the nearest
2419  * fraction to @target_numerator/@target_denominator that is a subset
2420  * of the existing field.
2421  *
2422  * Returns: %TRUE if the structure could be fixated
2423  */
2424 gboolean
2425 gst_structure_fixate_field_nearest_fraction (GstStructure * structure,
2426     const char *field_name, const gint target_numerator,
2427     const gint target_denominator)
2428 {
2429   const GValue *value;
2430 
2431   g_return_val_if_fail (gst_structure_has_field (structure, field_name), FALSE);
2432   g_return_val_if_fail (IS_MUTABLE (structure), FALSE);
2433   g_return_val_if_fail (target_denominator != 0, FALSE);
2434 
2435   value = gst_structure_get_value (structure, field_name);
2436 #ifdef GSTREAMER_LITE
2437   if (value == NULL) {
2438     return FALSE;
2439   }
2440 #endif // GSTREAMER_LITE
2441 
2442   if (G_VALUE_TYPE (value) == GST_TYPE_FRACTION) {
2443     /* already fixed */
2444     return FALSE;
2445   } else if (G_VALUE_TYPE (value) == GST_TYPE_FRACTION_RANGE) {
2446     const GValue *x, *new_value;
2447     GValue target = { 0 };
2448     g_value_init (&amp;target, GST_TYPE_FRACTION);
2449     gst_value_set_fraction (&amp;target, target_numerator, target_denominator);
2450 
2451     new_value = &amp;target;
2452     x = gst_value_get_fraction_range_min (value);
2453     if (gst_value_compare (&amp;target, x) == GST_VALUE_LESS_THAN)
2454       new_value = x;
2455     x = gst_value_get_fraction_range_max (value);
2456     if (gst_value_compare (&amp;target, x) == GST_VALUE_GREATER_THAN)
2457       new_value = x;
2458 
2459     gst_structure_set_value (structure, field_name, new_value);
2460     g_value_unset (&amp;target);
2461     return TRUE;
2462   } else if (G_VALUE_TYPE (value) == GST_TYPE_LIST) {
2463     const GValue *list_value;
2464     int i, n;
2465     const GValue *best = NULL;
2466     gdouble target;
2467     gdouble cur_diff;
2468     gdouble best_diff = G_MAXDOUBLE;
2469 
2470     target = (gdouble) target_numerator / (gdouble) target_denominator;
2471 
2472     GST_DEBUG (&quot;target %g, best %g&quot;, target, best_diff);
2473 
2474     best = NULL;
2475 
2476     n = gst_value_list_get_size (value);
2477     for (i = 0; i &lt; n; i++) {
2478       list_value = gst_value_list_get_value (value, i);
2479       if (G_VALUE_TYPE (list_value) == GST_TYPE_FRACTION) {
2480         gint num, denom;
2481         gdouble list_double;
2482 
2483         num = gst_value_get_fraction_numerator (list_value);
2484         denom = gst_value_get_fraction_denominator (list_value);
2485 
2486         list_double = ((gdouble) num / (gdouble) denom);
2487         cur_diff = target - list_double;
2488 
2489         GST_DEBUG (&quot;curr diff %g, list %g&quot;, cur_diff, list_double);
2490 
2491         if (cur_diff &lt; 0)
2492           cur_diff = -cur_diff;
2493 
2494         if (!best || cur_diff &lt; best_diff) {
2495           GST_DEBUG (&quot;new best %g&quot;, list_double);
2496           best = list_value;
2497           best_diff = cur_diff;
2498         }
2499       }
2500     }
2501     if (best != NULL) {
2502       gst_structure_set_value (structure, field_name, best);
2503       return TRUE;
2504     }
2505   }
2506 
2507   return FALSE;
2508 }
2509 
2510 static gboolean
2511 default_fixate (GQuark field_id, const GValue * value, gpointer data)
2512 {
2513   GstStructure *s = data;
2514   GValue v = { 0 };
2515 
2516   if (gst_value_fixate (&amp;v, value)) {
2517     gst_structure_id_take_value (s, field_id, &amp;v);
2518   }
2519   return TRUE;
2520 }
2521 
2522 /**
2523  * gst_structure_fixate_field:
2524  * @structure: a #GstStructure
2525  * @field_name: a field in @structure
2526  *
2527  * Fixates a #GstStructure by changing the given field with its fixated value.
2528  *
2529  * Returns: %TRUE if the structure field could be fixated
2530  */
2531 gboolean
2532 gst_structure_fixate_field (GstStructure * structure, const char *field_name)
2533 {
2534   GstStructureField *field;
2535 
2536   g_return_val_if_fail (structure != NULL, FALSE);
2537   g_return_val_if_fail (IS_MUTABLE (structure), FALSE);
2538 
2539   if (!(field = gst_structure_get_field (structure, field_name)))
2540     return FALSE;
2541 
2542   return default_fixate (field-&gt;name, &amp;field-&gt;value, structure);
2543 }
2544 
2545 /* our very own version of G_VALUE_LCOPY that allows NULL return locations
2546  * (useful for message parsing functions where the return location is user
2547  * supplied and the user may pass %NULL if the value isn&#39;t of interest) */
2548 #define GST_VALUE_LCOPY(value, var_args, flags, __error, fieldname)           \
2549 G_STMT_START {                                                                \
2550   const GValue *_value = (value);                                             \
2551   guint _flags = (flags);                                                     \
2552   GType _value_type = G_VALUE_TYPE (_value);                                  \
2553   GTypeValueTable *_vtable = g_type_value_table_peek (_value_type);           \
2554   const gchar *_lcopy_format = _vtable-&gt;lcopy_format;                         \
2555   GTypeCValue _cvalues[G_VALUE_COLLECT_FORMAT_MAX_LENGTH] = { { 0, }, };      \
2556   guint _n_values = 0;                                                        \
2557                                                                               \
2558   while (*_lcopy_format != &#39;\0&#39;) {                                            \
2559     g_assert (*_lcopy_format == G_VALUE_COLLECT_POINTER);                     \
2560     _cvalues[_n_values++].v_pointer = va_arg ((var_args), gpointer);          \
2561     _lcopy_format++;                                                          \
2562   }                                                                           \
2563   if (_n_values == 2 &amp;&amp; !!_cvalues[0].v_pointer != !!_cvalues[1].v_pointer) { \
2564     *(__error) = g_strdup_printf (&quot;either all or none of the return &quot;         \
2565         &quot;locations for field &#39;%s&#39; need to be NULL&quot;, fieldname);               \
2566   } else if (_cvalues[0].v_pointer != NULL) {                                 \
2567     *(__error) = _vtable-&gt;lcopy_value (_value, _n_values, _cvalues, _flags);  \
2568   }                                                                           \
2569 } G_STMT_END
2570 
2571 /**
2572  * gst_structure_get_valist:
2573  * @structure: a #GstStructure
2574  * @first_fieldname: the name of the first field to read
2575  * @args: variable arguments
2576  *
2577  * Parses the variable arguments and reads fields from @structure accordingly.
2578  * valist-variant of gst_structure_get(). Look at the documentation of
2579  * gst_structure_get() for more details.
2580  *
2581  * Returns: %TRUE, or %FALSE if there was a problem reading any of the fields
2582  */
2583 gboolean
2584 gst_structure_get_valist (const GstStructure * structure,
2585     const char *first_fieldname, va_list args)
2586 {
2587   const char *field_name;
2588   GType expected_type = G_TYPE_INVALID;
2589 
2590   g_return_val_if_fail (GST_IS_STRUCTURE (structure), FALSE);
2591   g_return_val_if_fail (first_fieldname != NULL, FALSE);
2592 
2593   field_name = first_fieldname;
2594   while (field_name) {
2595     const GValue *val = NULL;
2596     gchar *err = NULL;
2597 
2598     expected_type = va_arg (args, GType);
2599 
2600     val = gst_structure_get_value (structure, field_name);
2601 
2602     if (val == NULL)
2603       goto no_such_field;
2604 
2605     if (G_VALUE_TYPE (val) != expected_type)
2606       goto wrong_type;
2607 
2608     GST_VALUE_LCOPY (val, args, 0, &amp;err, field_name);
2609     if (err) {
2610       g_warning (&quot;%s: %s&quot;, G_STRFUNC, err);
2611       g_free (err);
2612       return FALSE;
2613     }
2614 
2615     field_name = va_arg (args, const gchar *);
2616   }
2617 
2618   return TRUE;
2619 
2620 /* ERRORS */
2621 no_such_field:
2622   {
2623     GST_INFO (&quot;Expected field &#39;%s&#39; in structure: %&quot; GST_PTR_FORMAT,
2624         field_name, structure);
2625     return FALSE;
2626   }
2627 wrong_type:
2628   {
2629     GST_INFO (&quot;Expected field &#39;%s&#39; in structure to be of type &#39;%s&#39;, but &quot;
2630         &quot;field was of type &#39;%s&#39;: %&quot; GST_PTR_FORMAT, field_name,
2631         GST_STR_NULL (g_type_name (expected_type)),
2632         G_VALUE_TYPE_NAME (gst_structure_get_value (structure, field_name)),
2633         structure);
2634     return FALSE;
2635   }
2636 }
2637 
2638 /**
2639  * gst_structure_id_get_valist:
2640  * @structure: a #GstStructure
2641  * @first_field_id: the quark of the first field to read
2642  * @args: variable arguments
2643  *
2644  * Parses the variable arguments and reads fields from @structure accordingly.
2645  * valist-variant of gst_structure_id_get(). Look at the documentation of
2646  * gst_structure_id_get() for more details.
2647  *
2648  * Returns: %TRUE, or %FALSE if there was a problem reading any of the fields
2649  */
2650 gboolean
2651 gst_structure_id_get_valist (const GstStructure * structure,
2652     GQuark first_field_id, va_list args)
2653 {
2654   GQuark field_id;
2655   GType expected_type = G_TYPE_INVALID;
2656 
2657   g_return_val_if_fail (GST_IS_STRUCTURE (structure), FALSE);
2658   g_return_val_if_fail (first_field_id != 0, FALSE);
2659 
2660   field_id = first_field_id;
2661   while (field_id) {
2662     const GValue *val = NULL;
2663     gchar *err = NULL;
2664 
2665     expected_type = va_arg (args, GType);
2666 
2667     val = gst_structure_id_get_value (structure, field_id);
2668 
2669     if (val == NULL)
2670       goto no_such_field;
2671 
2672     if (G_VALUE_TYPE (val) != expected_type)
2673       goto wrong_type;
2674 
2675     GST_VALUE_LCOPY (val, args, 0, &amp;err, g_quark_to_string (field_id));
2676     if (err) {
2677       g_warning (&quot;%s: %s&quot;, G_STRFUNC, err);
2678       g_free (err);
2679       return FALSE;
2680     }
2681 
2682     field_id = va_arg (args, GQuark);
2683   }
2684 
2685   return TRUE;
2686 
2687 /* ERRORS */
2688 no_such_field:
2689   {
2690     GST_DEBUG (&quot;Expected field &#39;%s&#39; in structure: %&quot; GST_PTR_FORMAT,
2691         GST_STR_NULL (g_quark_to_string (field_id)), structure);
2692     return FALSE;
2693   }
2694 wrong_type:
2695   {
2696     GST_DEBUG (&quot;Expected field &#39;%s&#39; in structure to be of type &#39;%s&#39;, but &quot;
2697         &quot;field was of type &#39;%s&#39;: %&quot; GST_PTR_FORMAT,
2698         g_quark_to_string (field_id),
2699         GST_STR_NULL (g_type_name (expected_type)),
2700         G_VALUE_TYPE_NAME (gst_structure_id_get_value (structure, field_id)),
2701         structure);
2702     return FALSE;
2703   }
2704 }
2705 
2706 /**
2707  * gst_structure_get:
2708  * @structure: a #GstStructure
2709  * @first_fieldname: the name of the first field to read
2710  * @...: variable arguments
2711  *
2712  * Parses the variable arguments and reads fields from @structure accordingly.
2713  * Variable arguments should be in the form field name, field type
2714  * (as a GType), pointer(s) to a variable(s) to hold the return value(s).
2715  * The last variable argument should be %NULL.
2716  *
2717  * For refcounted (mini)objects you will receive a new reference which
2718  * you must release with a suitable _unref() when no longer needed. For
2719  * strings and boxed types you will receive a copy which you will need to
2720  * release with either g_free() or the suitable function for the boxed type.
2721  *
2722  * Returns: %FALSE if there was a problem reading any of the fields (e.g.
2723  *     because the field requested did not exist, or was of a type other
2724  *     than the type specified), otherwise %TRUE.
2725  */
2726 gboolean
2727 gst_structure_get (const GstStructure * structure, const char *first_fieldname,
2728     ...)
2729 {
2730   gboolean ret;
2731   va_list args;
2732 
2733   g_return_val_if_fail (GST_IS_STRUCTURE (structure), FALSE);
2734   g_return_val_if_fail (first_fieldname != NULL, FALSE);
2735 
2736   va_start (args, first_fieldname);
2737   ret = gst_structure_get_valist (structure, first_fieldname, args);
2738   va_end (args);
2739 
2740   return ret;
2741 }
2742 
2743 /**
2744  * gst_structure_id_get:
2745  * @structure: a #GstStructure
2746  * @first_field_id: the quark of the first field to read
2747  * @...: variable arguments
2748  *
2749  * Parses the variable arguments and reads fields from @structure accordingly.
2750  * Variable arguments should be in the form field id quark, field type
2751  * (as a GType), pointer(s) to a variable(s) to hold the return value(s).
2752  * The last variable argument should be %NULL (technically it should be a
2753  * 0 quark, but we require %NULL so compilers that support it can check for
2754  * the %NULL terminator and warn if it&#39;s not there).
2755  *
2756  * This function is just like gst_structure_get() only that it is slightly
2757  * more efficient since it saves the string-to-quark lookup in the global
2758  * quark hashtable.
2759  *
2760  * For refcounted (mini)objects you will receive a new reference which
2761  * you must release with a suitable _unref() when no longer needed. For
2762  * strings and boxed types you will receive a copy which you will need to
2763  * release with either g_free() or the suitable function for the boxed type.
2764  *
2765  * Returns: %FALSE if there was a problem reading any of the fields (e.g.
2766  *     because the field requested did not exist, or was of a type other
2767  *     than the type specified), otherwise %TRUE.
2768  */
2769 gboolean
2770 gst_structure_id_get (const GstStructure * structure, GQuark first_field_id,
2771     ...)
2772 {
2773   gboolean ret;
2774   va_list args;
2775 
2776   g_return_val_if_fail (GST_IS_STRUCTURE (structure), FALSE);
2777   g_return_val_if_fail (first_field_id != 0, FALSE);
2778 
2779   va_start (args, first_field_id);
2780   ret = gst_structure_id_get_valist (structure, first_field_id, args);
2781   va_end (args);
2782 
2783   return ret;
2784 }
2785 
2786 static gboolean
2787 gst_structure_is_equal_foreach (GQuark field_id, const GValue * val2,
2788     gpointer data)
2789 {
2790   const GstStructure *struct1 = (const GstStructure *) data;
2791   const GValue *val1 = gst_structure_id_get_value (struct1, field_id);
2792 
2793   if (G_UNLIKELY (val1 == NULL))
2794     return FALSE;
2795   if (gst_value_compare (val1, val2) == GST_VALUE_EQUAL) {
2796     return TRUE;
2797   }
2798 
2799   return FALSE;
2800 }
2801 
2802 /**
2803  * gst_structure_is_equal:
2804  * @structure1: a #GstStructure.
2805  * @structure2: a #GstStructure.
2806  *
2807  * Tests if the two #GstStructure are equal.
2808  *
2809  * Returns: %TRUE if the two structures have the same name and field.
2810  **/
2811 gboolean
2812 gst_structure_is_equal (const GstStructure * structure1,
2813     const GstStructure * structure2)
2814 {
2815   g_return_val_if_fail (GST_IS_STRUCTURE (structure1), FALSE);
2816   g_return_val_if_fail (GST_IS_STRUCTURE (structure2), FALSE);
2817 
2818   if (G_UNLIKELY (structure1 == structure2))
2819     return TRUE;
2820 
2821   if (structure1-&gt;name != structure2-&gt;name) {
2822     return FALSE;
2823   }
2824   if (GST_STRUCTURE_FIELDS (structure1)-&gt;len !=
2825       GST_STRUCTURE_FIELDS (structure2)-&gt;len) {
2826     return FALSE;
2827   }
2828 
2829   return gst_structure_foreach (structure1, gst_structure_is_equal_foreach,
2830       (gpointer) structure2);
2831 }
2832 
2833 
2834 typedef struct
2835 {
2836   GstStructure *dest;
2837   const GstStructure *intersect;
2838 }
2839 IntersectData;
2840 
2841 static gboolean
2842 gst_structure_intersect_field1 (GQuark id, const GValue * val1, gpointer data)
2843 {
2844   IntersectData *idata = (IntersectData *) data;
2845   const GValue *val2 = gst_structure_id_get_value (idata-&gt;intersect, id);
2846 
2847   if (G_UNLIKELY (val2 == NULL)) {
2848     gst_structure_id_set_value (idata-&gt;dest, id, val1);
2849   } else {
2850     GValue dest_value = { 0 };
2851     if (gst_value_intersect (&amp;dest_value, val1, val2)) {
2852       gst_structure_id_take_value (idata-&gt;dest, id, &amp;dest_value);
2853     } else {
2854       return FALSE;
2855     }
2856   }
2857   return TRUE;
2858 }
2859 
2860 static gboolean
2861 gst_structure_intersect_field2 (GQuark id, const GValue * val1, gpointer data)
2862 {
2863   IntersectData *idata = (IntersectData *) data;
2864   const GValue *val2 = gst_structure_id_get_value (idata-&gt;intersect, id);
2865 
2866   if (G_UNLIKELY (val2 == NULL)) {
2867     gst_structure_id_set_value (idata-&gt;dest, id, val1);
2868   }
2869   return TRUE;
2870 }
2871 
2872 /**
2873  * gst_structure_intersect:
2874  * @struct1: a #GstStructure
2875  * @struct2: a #GstStructure
2876  *
2877  * Intersects @struct1 and @struct2 and returns the intersection.
2878  *
2879  * Returns: (nullable): Intersection of @struct1 and @struct2
2880  */
2881 GstStructure *
2882 gst_structure_intersect (const GstStructure * struct1,
2883     const GstStructure * struct2)
2884 {
2885   IntersectData data;
2886 
2887   g_assert (struct1 != NULL);
2888   g_assert (struct2 != NULL);
2889 
2890   if (G_UNLIKELY (struct1-&gt;name != struct2-&gt;name))
2891     return NULL;
2892 
2893   /* copy fields from struct1 which we have not in struct2 to target
2894    * intersect if we have the field in both */
2895   data.dest = gst_structure_new_id_empty (struct1-&gt;name);
2896   data.intersect = struct2;
2897   if (G_UNLIKELY (!gst_structure_foreach ((GstStructure *) struct1,
2898               gst_structure_intersect_field1, &amp;data)))
2899     goto error;
2900 
2901   /* copy fields from struct2 which we have not in struct1 to target */
2902   data.intersect = struct1;
2903   if (G_UNLIKELY (!gst_structure_foreach ((GstStructure *) struct2,
2904               gst_structure_intersect_field2, &amp;data)))
2905     goto error;
2906 
2907   return data.dest;
2908 
2909 error:
2910   gst_structure_free (data.dest);
2911   return NULL;
2912 }
2913 
2914 static gboolean
2915 gst_caps_structure_can_intersect_field (GQuark id, const GValue * val1,
2916     gpointer data)
2917 {
2918   GstStructure *other = (GstStructure *) data;
2919   const GValue *val2 = gst_structure_id_get_value (other, id);
2920 
2921   if (G_LIKELY (val2)) {
2922     if (!gst_value_can_intersect (val1, val2)) {
2923       return FALSE;
2924     } else {
2925       gint eq = gst_value_compare (val1, val2);
2926 
2927       if (eq == GST_VALUE_UNORDERED) {
2928         /* we need to try interseting */
2929         if (!gst_value_intersect (NULL, val1, val2)) {
2930           return FALSE;
2931         }
2932       } else if (eq != GST_VALUE_EQUAL) {
2933         return FALSE;
2934       }
2935     }
2936   }
2937   return TRUE;
2938 }
2939 
2940 /**
2941  * gst_structure_can_intersect:
2942  * @struct1: a #GstStructure
2943  * @struct2: a #GstStructure
2944  *
2945  * Tries intersecting @struct1 and @struct2 and reports whether the result
2946  * would not be empty.
2947  *
2948  * Returns: %TRUE if intersection would not be empty
2949  */
2950 gboolean
2951 gst_structure_can_intersect (const GstStructure * struct1,
2952     const GstStructure * struct2)
2953 {
2954   g_return_val_if_fail (GST_IS_STRUCTURE (struct1), FALSE);
2955   g_return_val_if_fail (GST_IS_STRUCTURE (struct2), FALSE);
2956 
2957   if (G_UNLIKELY (struct1-&gt;name != struct2-&gt;name))
2958     return FALSE;
2959 
2960   /* tries to intersect if we have the field in both */
2961   return gst_structure_foreach ((GstStructure *) struct1,
2962       gst_caps_structure_can_intersect_field, (gpointer) struct2);
2963 }
2964 
2965 static gboolean
2966 gst_caps_structure_is_superset_field (GQuark field_id, const GValue * value,
2967     gpointer user_data)
2968 {
2969   GstStructure *subset = user_data;
2970   const GValue *other;
2971   int comparison;
2972 
2973   if (!(other = gst_structure_id_get_value (subset, field_id)))
2974     /* field is missing in the subset =&gt; no subset */
2975     return FALSE;
2976 
2977   comparison = gst_value_compare (value, other);
2978 
2979   /* equal values are subset */
2980   if (comparison == GST_VALUE_EQUAL)
2981     return TRUE;
2982 
2983   /* ordered, but unequal, values are not */
2984   if (comparison != GST_VALUE_UNORDERED)
2985     return FALSE;
2986 
2987   return gst_value_is_subset (other, value);
2988 }
2989 
2990 /**
2991  * gst_structure_is_subset:
2992  * @subset: a #GstStructure
2993  * @superset: a potentially greater #GstStructure
2994  *
2995  * Checks if @subset is a subset of @superset, i.e. has the same
2996  * structure name and for all fields that are existing in @superset,
2997  * @subset has a value that is a subset of the value in @superset.
2998  *
2999  * Returns: %TRUE if @subset is a subset of @superset
3000  */
3001 gboolean
3002 gst_structure_is_subset (const GstStructure * subset,
3003     const GstStructure * superset)
3004 {
3005   if ((superset-&gt;name != subset-&gt;name) ||
3006       (gst_structure_n_fields (superset) &gt; gst_structure_n_fields (subset)))
3007     return FALSE;
3008 
3009   return gst_structure_foreach ((GstStructure *) superset,
3010       gst_caps_structure_is_superset_field, (gpointer) subset);
3011 }
3012 
3013 
3014 /**
3015  * gst_structure_fixate:
3016  * @structure: a #GstStructure
3017  *
3018  * Fixate all values in @structure using gst_value_fixate().
3019  * @structure will be modified in-place and should be writable.
3020  */
3021 void
3022 gst_structure_fixate (GstStructure * structure)
3023 {
3024   g_return_if_fail (GST_IS_STRUCTURE (structure));
3025 
3026   gst_structure_foreach (structure, default_fixate, structure);
3027 }
3028 
3029 static gboolean
3030 _gst_structure_get_any_list (GstStructure * structure, GType type,
3031     const gchar * fieldname, GValueArray ** array)
3032 {
3033   GstStructureField *field;
3034   GValue val = G_VALUE_INIT;
3035 
3036   g_return_val_if_fail (structure != NULL, FALSE);
3037   g_return_val_if_fail (fieldname != NULL, FALSE);
3038   g_return_val_if_fail (array != NULL, FALSE);
3039 
3040   field = gst_structure_get_field (structure, fieldname);
3041 
3042   if (field == NULL || G_VALUE_TYPE (&amp;field-&gt;value) != type)
3043     return FALSE;
3044 
3045   g_value_init (&amp;val, G_TYPE_VALUE_ARRAY);
3046 
3047   if (g_value_transform (&amp;field-&gt;value, &amp;val)) {
3048     *array = g_value_get_boxed (&amp;val);
3049     return TRUE;
3050   }
3051 
3052   g_value_unset (&amp;val);
3053   return FALSE;
3054 }
3055 
3056 /**
3057  * gst_structure_get_array:
3058  * @structure: a #GstStructure
3059  * @fieldname: the name of a field
3060  * @array: (out): a pointer to a #GValueArray
3061  *
3062  * This is useful in language bindings where unknown #GValue types are not
3063  * supported. This function will convert the %GST_TYPE_ARRAY and
3064  * %GST_TYPE_LIST into a newly allocated #GValueArray and return it through
3065  * @array. Be aware that this is slower then getting the #GValue directly.
3066  *
3067  * Returns: %TRUE if the value could be set correctly. If there was no field
3068  * with @fieldname or the existing field did not contain an int, this function
3069  * returns %FALSE.
3070  */
3071 gboolean
3072 gst_structure_get_array (GstStructure * structure, const gchar * fieldname,
3073     GValueArray ** array)
3074 {
3075   return _gst_structure_get_any_list (structure, GST_TYPE_ARRAY, fieldname,
3076       array);
3077 }
3078 
3079 /**
3080  * gst_structure_get_list:
3081  * @structure: a #GstStructure
3082  * @fieldname: the name of a field
3083  * @array: (out): a pointer to a #GValueArray
3084  *
3085  * This is useful in language bindings where unknown #GValue types are not
3086  * supported. This function will convert the %GST_TYPE_ARRAY and
3087  * %GST_TYPE_LIST into a newly allocated GValueArray and return it through
3088  * @array. Be aware that this is slower then getting the #GValue directly.
3089  *
3090  * Returns: %TRUE if the value could be set correctly. If there was no field
3091  * with @fieldname or the existing field did not contain an int, this function
3092  * returns %FALSE.
3093  *
3094  * Since 1.12
3095  */
3096 gboolean
3097 gst_structure_get_list (GstStructure * structure, const gchar * fieldname,
3098     GValueArray ** array)
3099 {
3100   return _gst_structure_get_any_list (structure, GST_TYPE_LIST, fieldname,
3101       array);
3102 }
3103 
3104 static void
3105 _gst_structure_set_any_list (GstStructure * structure, GType type,
3106     const gchar * fieldname, const GValueArray * array)
3107 {
3108   GValue arval = G_VALUE_INIT;
3109   GValue value = G_VALUE_INIT;
3110 
3111   g_return_if_fail (structure != NULL);
3112   g_return_if_fail (fieldname != NULL);
3113   g_return_if_fail (array != NULL);
3114   g_return_if_fail (IS_MUTABLE (structure));
3115 
3116   g_value_init (&amp;value, type);
3117   g_value_init (&amp;arval, G_TYPE_VALUE_ARRAY);
3118   g_value_set_static_boxed (&amp;arval, array);
3119 
3120   if (g_value_transform (&amp;arval, &amp;value)) {
3121     gst_structure_id_set_value_internal (structure,
3122         g_quark_from_string (fieldname), &amp;value);
3123   } else {
3124     g_warning (&quot;Failed to convert a GValueArray&quot;);
3125   }
3126 
3127   g_value_unset (&amp;arval);
3128   g_value_unset (&amp;value);
3129 }
3130 
3131 /**
3132  * gst_structure_set_array:
3133  * @structure: a #GstStructure
3134  * @fieldname: the name of a field
3135  * @array: a pointer to a #GValueArray
3136  *
3137  * This is useful in language bindings where unknown GValue types are not
3138  * supported. This function will convert a @array to %GST_TYPE_ARRAY and set
3139  * the field specified by @fieldname.  Be aware that this is slower then using
3140  * %GST_TYPE_ARRAY in a #GValue directly.
3141  *
3142  * Since 1.12
3143  */
3144 void
3145 gst_structure_set_array (GstStructure * structure, const gchar * fieldname,
3146     const GValueArray * array)
3147 {
3148   _gst_structure_set_any_list (structure, GST_TYPE_ARRAY, fieldname, array);
3149 }
3150 
3151 /**
3152  * gst_structure_set_list:
3153  * @structure: a #GstStructure
3154  * @fieldname: the name of a field
3155  * @array: a pointer to a #GValueArray
3156  *
3157  * This is useful in language bindings where unknown GValue types are not
3158  * supported. This function will convert a @array to %GST_TYPE_ARRAY and set
3159  * the field specified by @fieldname. Be aware that this is slower then using
3160  * %GST_TYPE_ARRAY in a #GValue directly.
3161  *
3162  * Since 1.12
3163  */
3164 void
3165 gst_structure_set_list (GstStructure * structure, const gchar * fieldname,
3166     const GValueArray * array)
3167 {
3168   _gst_structure_set_any_list (structure, GST_TYPE_LIST, fieldname, array);
3169 }
    </pre>
  </body>
</html>