<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gtype.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gtype-private.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gtype.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gtype.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 37,11 ***</span>
  #ifdef G_OS_WIN32
  #include &lt;windows.h&gt;
  #endif
  
  #ifdef  G_ENABLE_DEBUG
<span class="line-modified">! #define IF_DEBUG(debug_type)    if (_g_type_debug_flags &amp; G_TYPE_DEBUG_ ## debug_type)</span>
  #endif
  
  /**
   * SECTION:gtype
   * @short_description: The GLib Runtime type identification and
<span class="line-new-header">--- 37,11 ---</span>
  #ifdef G_OS_WIN32
  #include &lt;windows.h&gt;
  #endif
  
  #ifdef  G_ENABLE_DEBUG
<span class="line-modified">! #define IF_DEBUG(debug_type)  if (_g_type_debug_flags &amp; G_TYPE_DEBUG_ ## debug_type)</span>
  #endif
  
  /**
   * SECTION:gtype
   * @short_description: The GLib Runtime type identification and
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,21 ***</span>
   *
   * LOCKING:
   * lock handling issues when calling static functions are indicated by
   * uppercase letter postfixes, all static functions have to have
   * one of the below postfixes:
<span class="line-modified">!  * - _I:    [Indifferent about locking]</span>
   *   function doesn&#39;t care about locks at all
<span class="line-modified">!  * - _U:    [Unlocked invocation]</span>
   *   no read or write lock has to be held across function invocation
   *   (locks may be acquired and released during invocation though)
<span class="line-modified">!  * - _L:    [Locked invocation]</span>
   *   a write lock or more than 0 read locks have to be held across
   *   function invocation
<span class="line-modified">!  * - _W:    [Write-locked invocation]</span>
   *   a write lock has to be held across function invocation
<span class="line-modified">!  * - _Wm:   [Write-locked invocation, mutatable]</span>
   *   like _W, but the write lock might be released and reacquired
   *   during invocation, watch your pointers
   * - _WmREC:    [Write-locked invocation, mutatable, recursive]
   *   like _Wm, but also acquires recursive mutex class_init_rec_mutex
   */
<span class="line-new-header">--- 98,21 ---</span>
   *
   * LOCKING:
   * lock handling issues when calling static functions are indicated by
   * uppercase letter postfixes, all static functions have to have
   * one of the below postfixes:
<span class="line-modified">!  * - _I:  [Indifferent about locking]</span>
   *   function doesn&#39;t care about locks at all
<span class="line-modified">!  * - _U:  [Unlocked invocation]</span>
   *   no read or write lock has to be held across function invocation
   *   (locks may be acquired and released during invocation though)
<span class="line-modified">!  * - _L:  [Locked invocation]</span>
   *   a write lock or more than 0 read locks have to be held across
   *   function invocation
<span class="line-modified">!  * - _W:  [Write-locked invocation]</span>
   *   a write lock has to be held across function invocation
<span class="line-modified">!  * - _Wm: [Write-locked invocation, mutatable]</span>
   *   like _W, but the write lock might be released and reacquired
   *   during invocation, watch your pointers
   * - _WmREC:    [Write-locked invocation, mutatable, recursive]
   *   like _Wm, but also acquires recursive mutex class_init_rec_mutex
   */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,16 ***</span>
  }G_STMT_END
  #define g_assert_type_system_initialized() \
    g_assert (static_quark_type_flags)
  
  #define TYPE_FUNDAMENTAL_FLAG_MASK (G_TYPE_FLAG_CLASSED | \
<span class="line-modified">!                     G_TYPE_FLAG_INSTANTIATABLE | \</span>
<span class="line-modified">!                     G_TYPE_FLAG_DERIVABLE | \</span>
<span class="line-modified">!                     G_TYPE_FLAG_DEEP_DERIVABLE)</span>
<span class="line-modified">! #define TYPE_FLAG_MASK         (G_TYPE_FLAG_ABSTRACT | G_TYPE_FLAG_VALUE_ABSTRACT)</span>
  #define SIZEOF_FUNDAMENTAL_INFO    ((gssize) MAX (MAX (sizeof (GTypeFundamentalInfo), \
<span class="line-modified">!                                sizeof (gpointer)), \</span>
                                                    sizeof (glong)))
  
  /* The 2*sizeof(size_t) alignment here is borrowed from
   * GNU libc, so it should be good most everywhere.
   * It is more conservative than is needed on some 64-bit
<span class="line-new-header">--- 138,16 ---</span>
  }G_STMT_END
  #define g_assert_type_system_initialized() \
    g_assert (static_quark_type_flags)
  
  #define TYPE_FUNDAMENTAL_FLAG_MASK (G_TYPE_FLAG_CLASSED | \
<span class="line-modified">!             G_TYPE_FLAG_INSTANTIATABLE | \</span>
<span class="line-modified">!             G_TYPE_FLAG_DERIVABLE | \</span>
<span class="line-modified">!             G_TYPE_FLAG_DEEP_DERIVABLE)</span>
<span class="line-modified">! #define TYPE_FLAG_MASK       (G_TYPE_FLAG_ABSTRACT | G_TYPE_FLAG_VALUE_ABSTRACT)</span>
  #define SIZEOF_FUNDAMENTAL_INFO    ((gssize) MAX (MAX (sizeof (GTypeFundamentalInfo), \
<span class="line-modified">!                    sizeof (gpointer)), \</span>
                                                    sizeof (glong)))
  
  /* The 2*sizeof(size_t) alignment here is borrowed from
   * GNU libc, so it should be good most everywhere.
   * It is more conservative than is needed on some 64-bit
</pre>
<hr />
<pre>
<span class="line-old-header">*** 173,34 ***</span>
  typedef struct _IFaceEntry      IFaceEntry;
  typedef struct _IFaceHolder IFaceHolder;
  
  
  /* --- prototypes --- */
<span class="line-modified">! static inline GTypeFundamentalInfo* type_node_fundamental_info_I    (TypeNode       *node);</span>
<span class="line-modified">! static        void          type_add_flags_W        (TypeNode       *node,</span>
<span class="line-modified">!                                      GTypeFlags      flags);</span>
<span class="line-modified">! static        void          type_data_make_W        (TypeNode       *node,</span>
<span class="line-modified">!                                      const GTypeInfo    *info,</span>
<span class="line-modified">!                                      const GTypeValueTable  *value_table);</span>
<span class="line-modified">! static inline void          type_data_ref_Wm        (TypeNode       *node);</span>
<span class="line-modified">! static inline void          type_data_unref_U               (TypeNode       *node,</span>
<span class="line-modified">!                                      gboolean        uncached);</span>
<span class="line-modified">! static void             type_data_last_unref_Wm     (TypeNode *              node,</span>
<span class="line-modified">!                                      gboolean        uncached);</span>
<span class="line-modified">! static inline gpointer          type_get_qdata_L        (TypeNode       *node,</span>
<span class="line-modified">!                                      GQuark          quark);</span>
<span class="line-modified">! static inline void          type_set_qdata_W        (TypeNode       *node,</span>
<span class="line-modified">!                                      GQuark          quark,</span>
<span class="line-modified">!                                      gpointer        data);</span>
<span class="line-modified">! static IFaceHolder*         type_iface_peek_holder_L    (TypeNode       *iface,</span>
<span class="line-modified">!                                      GType           instance_type);</span>
  static gboolean                         type_iface_vtable_base_init_Wm  (TypeNode               *iface,
                                                                           TypeNode               *node);
  static void                             type_iface_vtable_iface_init_Wm (TypeNode               *iface,
                                                                           TypeNode               *node);
<span class="line-modified">! static gboolean             type_node_is_a_L        (TypeNode       *node,</span>
<span class="line-modified">!                                      TypeNode       *iface_node);</span>
  
  
  /* --- enumeration --- */
  
  /* The InitState enumeration is used to track the progress of initializing
<span class="line-new-header">--- 173,34 ---</span>
  typedef struct _IFaceEntry      IFaceEntry;
  typedef struct _IFaceHolder IFaceHolder;
  
  
  /* --- prototypes --- */
<span class="line-modified">! static inline GTypeFundamentalInfo* type_node_fundamental_info_I  (TypeNode   *node);</span>
<span class="line-modified">! static        void      type_add_flags_W    (TypeNode   *node,</span>
<span class="line-modified">!                    GTypeFlags    flags);</span>
<span class="line-modified">! static        void      type_data_make_W    (TypeNode   *node,</span>
<span class="line-modified">!                    const GTypeInfo  *info,</span>
<span class="line-modified">!                    const GTypeValueTable  *value_table);</span>
<span class="line-modified">! static inline void      type_data_ref_Wm    (TypeNode   *node);</span>
<span class="line-modified">! static inline void      type_data_unref_U               (TypeNode   *node,</span>
<span class="line-modified">!                    gboolean    uncached);</span>
<span class="line-modified">! static void       type_data_last_unref_Wm   (TypeNode *              node,</span>
<span class="line-modified">!                    gboolean    uncached);</span>
<span class="line-modified">! static inline gpointer      type_get_qdata_L    (TypeNode   *node,</span>
<span class="line-modified">!                    GQuark      quark);</span>
<span class="line-modified">! static inline void      type_set_qdata_W    (TypeNode   *node,</span>
<span class="line-modified">!                    GQuark      quark,</span>
<span class="line-modified">!                    gpointer    data);</span>
<span class="line-modified">! static IFaceHolder*     type_iface_peek_holder_L  (TypeNode   *iface,</span>
<span class="line-modified">!                    GType       instance_type);</span>
  static gboolean                         type_iface_vtable_base_init_Wm  (TypeNode               *iface,
                                                                           TypeNode               *node);
  static void                             type_iface_vtable_iface_init_Wm (TypeNode               *iface,
                                                                           TypeNode               *node);
<span class="line-modified">! static gboolean       type_node_is_a_L    (TypeNode   *node,</span>
<span class="line-modified">!                    TypeNode   *iface_node);</span>
  
  
  /* --- enumeration --- */
  
  /* The InitState enumeration is used to track the progress of initializing
</pre>
<hr />
<pre>
<span class="line-old-header">*** 229,48 ***</span>
    guint        n_children; /* writable with lock */
    guint        n_supers : 8;
    guint        n_prerequisites : 9;
    guint        is_classed : 1;
    guint        is_instantiatable : 1;
<span class="line-modified">!   guint        mutatable_check_cache : 1;   /* combines some common path checks */</span>
    GType       *children; /* writable with lock */
    TypeData * volatile data;
    GQuark       qname;
    GData       *global_gdata;
    union {
<span class="line-modified">!     GAtomicArray iface_entries;     /* for !iface types */</span>
      GAtomicArray offsets;
    } _prot;
    GType       *prerequisites;
    GType        supers[1]; /* flexible array */
  };
  
<span class="line-modified">! #define SIZEOF_BASE_TYPE_NODE()         (G_STRUCT_OFFSET (TypeNode, supers))</span>
<span class="line-modified">! #define MAX_N_SUPERS                (255)</span>
<span class="line-modified">! #define MAX_N_CHILDREN              (G_MAXUINT)</span>
<span class="line-modified">! #define MAX_N_INTERFACES            (255) /* Limited by offsets being 8 bits */</span>
<span class="line-modified">! #define MAX_N_PREREQUISITES         (511)</span>
<span class="line-modified">! #define NODE_TYPE(node)             (node-&gt;supers[0])</span>
<span class="line-modified">! #define NODE_PARENT_TYPE(node)          (node-&gt;supers[1])</span>
<span class="line-modified">! #define NODE_FUNDAMENTAL_TYPE(node)     (node-&gt;supers[node-&gt;n_supers])</span>
<span class="line-modified">! #define NODE_NAME(node)             (g_quark_to_string (node-&gt;qname))</span>
  #define NODE_REFCOUNT(node)                     ((guint) g_atomic_int_get ((int *) &amp;(node)-&gt;ref_count))
<span class="line-modified">! #define NODE_IS_BOXED(node)         (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_BOXED)</span>
<span class="line-modified">! #define NODE_IS_IFACE(node)         (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_INTERFACE)</span>
<span class="line-modified">! #define CLASSED_NODE_IFACES_ENTRIES(node)   (&amp;(node)-&gt;_prot.iface_entries)</span>
  #define CLASSED_NODE_IFACES_ENTRIES_LOCKED(node)(G_ATOMIC_ARRAY_GET_LOCKED(CLASSED_NODE_IFACES_ENTRIES((node)), IFaceEntries))
<span class="line-modified">! #define IFACE_NODE_N_PREREQUISITES(node)    ((node)-&gt;n_prerequisites)</span>
<span class="line-modified">! #define IFACE_NODE_PREREQUISITES(node)      ((node)-&gt;prerequisites)</span>
<span class="line-modified">! #define iface_node_get_holders_L(node)      ((IFaceHolder*) type_get_qdata_L ((node), static_quark_iface_holder))</span>
  #define iface_node_set_holders_W(node, holders) (type_set_qdata_W ((node), static_quark_iface_holder, (holders)))
<span class="line-modified">! #define iface_node_get_dependants_array_L(n)    ((GType*) type_get_qdata_L ((n), static_quark_dependants_array))</span>
  #define iface_node_set_dependants_array_W(n,d)  (type_set_qdata_W ((n), static_quark_dependants_array, (d)))
<span class="line-modified">! #define TYPE_ID_MASK                ((GType) ((1 &lt;&lt; G_TYPE_FUNDAMENTAL_SHIFT) - 1))</span>
  
  #define NODE_IS_ANCESTOR(ancestor, node)                                                    \
          ((ancestor)-&gt;n_supers &lt;= (node)-&gt;n_supers &amp;&amp;                                        \
<span class="line-modified">!      (node)-&gt;supers[(node)-&gt;n_supers - (ancestor)-&gt;n_supers] == NODE_TYPE (ancestor))</span>
  
  struct _IFaceHolder
  {
    GType           instance_type;
    GInterfaceInfo *info;
<span class="line-new-header">--- 229,48 ---</span>
    guint        n_children; /* writable with lock */
    guint        n_supers : 8;
    guint        n_prerequisites : 9;
    guint        is_classed : 1;
    guint        is_instantiatable : 1;
<span class="line-modified">!   guint        mutatable_check_cache : 1; /* combines some common path checks */</span>
    GType       *children; /* writable with lock */
    TypeData * volatile data;
    GQuark       qname;
    GData       *global_gdata;
    union {
<span class="line-modified">!     GAtomicArray iface_entries;   /* for !iface types */</span>
      GAtomicArray offsets;
    } _prot;
    GType       *prerequisites;
    GType        supers[1]; /* flexible array */
  };
  
<span class="line-modified">! #define SIZEOF_BASE_TYPE_NODE()     (G_STRUCT_OFFSET (TypeNode, supers))</span>
<span class="line-modified">! #define MAX_N_SUPERS        (255)</span>
<span class="line-modified">! #define MAX_N_CHILDREN        (G_MAXUINT)</span>
<span class="line-modified">! #define MAX_N_INTERFACES      (255) /* Limited by offsets being 8 bits */</span>
<span class="line-modified">! #define MAX_N_PREREQUISITES     (511)</span>
<span class="line-modified">! #define NODE_TYPE(node)       (node-&gt;supers[0])</span>
<span class="line-modified">! #define NODE_PARENT_TYPE(node)      (node-&gt;supers[1])</span>
<span class="line-modified">! #define NODE_FUNDAMENTAL_TYPE(node)   (node-&gt;supers[node-&gt;n_supers])</span>
<span class="line-modified">! #define NODE_NAME(node)       (g_quark_to_string (node-&gt;qname))</span>
  #define NODE_REFCOUNT(node)                     ((guint) g_atomic_int_get ((int *) &amp;(node)-&gt;ref_count))
<span class="line-modified">! #define NODE_IS_BOXED(node)     (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_BOXED)</span>
<span class="line-modified">! #define NODE_IS_IFACE(node)     (NODE_FUNDAMENTAL_TYPE (node) == G_TYPE_INTERFACE)</span>
<span class="line-modified">! #define CLASSED_NODE_IFACES_ENTRIES(node) (&amp;(node)-&gt;_prot.iface_entries)</span>
  #define CLASSED_NODE_IFACES_ENTRIES_LOCKED(node)(G_ATOMIC_ARRAY_GET_LOCKED(CLASSED_NODE_IFACES_ENTRIES((node)), IFaceEntries))
<span class="line-modified">! #define IFACE_NODE_N_PREREQUISITES(node)  ((node)-&gt;n_prerequisites)</span>
<span class="line-modified">! #define IFACE_NODE_PREREQUISITES(node)    ((node)-&gt;prerequisites)</span>
<span class="line-modified">! #define iface_node_get_holders_L(node)    ((IFaceHolder*) type_get_qdata_L ((node), static_quark_iface_holder))</span>
  #define iface_node_set_holders_W(node, holders) (type_set_qdata_W ((node), static_quark_iface_holder, (holders)))
<span class="line-modified">! #define iface_node_get_dependants_array_L(n)  ((GType*) type_get_qdata_L ((n), static_quark_dependants_array))</span>
  #define iface_node_set_dependants_array_W(n,d)  (type_set_qdata_W ((n), static_quark_dependants_array, (d)))
<span class="line-modified">! #define TYPE_ID_MASK        ((GType) ((1 &lt;&lt; G_TYPE_FUNDAMENTAL_SHIFT) - 1))</span>
  
  #define NODE_IS_ANCESTOR(ancestor, node)                                                    \
          ((ancestor)-&gt;n_supers &lt;= (node)-&gt;n_supers &amp;&amp;                                        \
<span class="line-modified">!    (node)-&gt;supers[(node)-&gt;n_supers - (ancestor)-&gt;n_supers] == NODE_TYPE (ancestor))</span>
  
  struct _IFaceHolder
  {
    GType           instance_type;
    GInterfaceInfo *info;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 378,16 ***</span>
  static IFaceCheckFunc *static_iface_check_funcs = NULL;
  static GQuark          static_quark_type_flags = 0;
  static GQuark          static_quark_iface_holder = 0;
  static GQuark          static_quark_dependants_array = 0;
  static guint           type_registration_serial = 0;
  GTypeDebugFlags        _g_type_debug_flags = 0;
  
  /* --- type nodes --- */
  static GHashTable       *static_type_nodes_ht = NULL;
<span class="line-modified">! static TypeNode     *static_fundamental_type_nodes[(G_TYPE_FUNDAMENTAL_MAX &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT) + 1] = { NULL, };</span>
<span class="line-modified">! static GType         static_fundamental_next = G_TYPE_RESERVED_USER_FIRST;</span>
  
  static inline TypeNode*
  lookup_type_node_I (GType utype)
  {
    if (utype &gt; G_TYPE_FUNDAMENTAL_MAX)
<span class="line-new-header">--- 378,19 ---</span>
  static IFaceCheckFunc *static_iface_check_funcs = NULL;
  static GQuark          static_quark_type_flags = 0;
  static GQuark          static_quark_iface_holder = 0;
  static GQuark          static_quark_dependants_array = 0;
  static guint           type_registration_serial = 0;
<span class="line-added">+ </span>
<span class="line-added">+ G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
  GTypeDebugFlags        _g_type_debug_flags = 0;
<span class="line-added">+ G_GNUC_END_IGNORE_DEPRECATIONS</span>
  
  /* --- type nodes --- */
  static GHashTable       *static_type_nodes_ht = NULL;
<span class="line-modified">! static TypeNode   *static_fundamental_type_nodes[(G_TYPE_FUNDAMENTAL_MAX &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT) + 1] = { NULL, };</span>
<span class="line-modified">! static GType     static_fundamental_next = G_TYPE_RESERVED_USER_FIRST;</span>
  
  static inline TypeNode*
  lookup_type_node_I (GType utype)
  {
    if (utype &gt; G_TYPE_FUNDAMENTAL_MAX)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 415,28 ***</span>
    return (guint)g_atomic_int_get ((gint *)&amp;type_registration_serial);
  }
  
  static TypeNode*
  type_node_any_new_W (TypeNode             *pnode,
<span class="line-modified">!              GType                 ftype,</span>
<span class="line-modified">!              const gchar          *name,</span>
<span class="line-modified">!              GTypePlugin          *plugin,</span>
<span class="line-modified">!              GTypeFundamentalFlags type_flags)</span>
  {
    guint n_supers;
    GType type;
    TypeNode *node;
    guint i, node_size = 0;
  
    n_supers = pnode ? pnode-&gt;n_supers + 1 : 0;
  
    if (!pnode)
<span class="line-modified">!     node_size += SIZEOF_FUNDAMENTAL_INFO;         /* fundamental type info */</span>
<span class="line-modified">!   node_size += SIZEOF_BASE_TYPE_NODE ();          /* TypeNode structure */</span>
    node_size += (sizeof (GType) * (1 + n_supers + 1)); /* self + ancestors + (0) for -&gt;supers[] */
    node = g_malloc0 (node_size);
<span class="line-modified">!   if (!pnode)                         /* offset fundamental types */</span>
      {
        node = G_STRUCT_MEMBER_P (node, SIZEOF_FUNDAMENTAL_INFO);
        static_fundamental_type_nodes[ftype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT] = node;
        type = ftype;
      }
<span class="line-new-header">--- 418,28 ---</span>
    return (guint)g_atomic_int_get ((gint *)&amp;type_registration_serial);
  }
  
  static TypeNode*
  type_node_any_new_W (TypeNode             *pnode,
<span class="line-modified">!          GType                 ftype,</span>
<span class="line-modified">!          const gchar          *name,</span>
<span class="line-modified">!          GTypePlugin          *plugin,</span>
<span class="line-modified">!          GTypeFundamentalFlags type_flags)</span>
  {
    guint n_supers;
    GType type;
    TypeNode *node;
    guint i, node_size = 0;
  
    n_supers = pnode ? pnode-&gt;n_supers + 1 : 0;
  
    if (!pnode)
<span class="line-modified">!     node_size += SIZEOF_FUNDAMENTAL_INFO;       /* fundamental type info */</span>
<span class="line-modified">!   node_size += SIZEOF_BASE_TYPE_NODE ();        /* TypeNode structure */</span>
    node_size += (sizeof (GType) * (1 + n_supers + 1)); /* self + ancestors + (0) for -&gt;supers[] */
    node = g_malloc0 (node_size);
<span class="line-modified">!   if (!pnode)               /* offset fundamental types */</span>
      {
        node = G_STRUCT_MEMBER_P (node, SIZEOF_FUNDAMENTAL_INFO);
        static_fundamental_type_nodes[ftype &gt;&gt; G_TYPE_FUNDAMENTAL_SHIFT] = node;
        type = ftype;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 453,49 ***</span>
  
        node-&gt;is_classed = (type_flags &amp; G_TYPE_FLAG_CLASSED) != 0;
        node-&gt;is_instantiatable = (type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) != 0;
  
        if (NODE_IS_IFACE (node))
<span class="line-modified">!     {</span>
            IFACE_NODE_N_PREREQUISITES (node) = 0;
<span class="line-modified">!       IFACE_NODE_PREREQUISITES (node) = NULL;</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     _g_atomic_array_init (CLASSED_NODE_IFACES_ENTRIES (node));</span>
      }
    else
      {
        node-&gt;supers[0] = type;
        memcpy (node-&gt;supers + 1, pnode-&gt;supers, sizeof (GType) * (1 + pnode-&gt;n_supers + 1));
  
        node-&gt;is_classed = pnode-&gt;is_classed;
        node-&gt;is_instantiatable = pnode-&gt;is_instantiatable;
  
        if (NODE_IS_IFACE (node))
<span class="line-modified">!     {</span>
<span class="line-modified">!       IFACE_NODE_N_PREREQUISITES (node) = 0;</span>
<span class="line-modified">!       IFACE_NODE_PREREQUISITES (node) = NULL;</span>
<span class="line-modified">!     }</span>
        else
      {
<span class="line-modified">!       guint j;</span>
<span class="line-modified">!       IFaceEntries *entries;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (pnode),</span>
<span class="line-removed">-                       IFACE_ENTRIES_HEADER_SIZE,</span>
<span class="line-removed">-                       0);</span>
<span class="line-removed">-       if (entries)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (entries); j++)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           entries-&gt;entry[j].vtable = NULL;</span>
<span class="line-removed">-           entries-&gt;entry[j].init_state = UNINITIALIZED;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-           _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node),</span>
<span class="line-removed">-                       entries);</span>
<span class="line-removed">-         }</span>
      }
  
        i = pnode-&gt;n_children++;
        pnode-&gt;children = g_renew (GType, pnode-&gt;children, pnode-&gt;n_children);
        pnode-&gt;children[i] = type;
      }
<span class="line-new-header">--- 456,49 ---</span>
  
        node-&gt;is_classed = (type_flags &amp; G_TYPE_FLAG_CLASSED) != 0;
        node-&gt;is_instantiatable = (type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) != 0;
  
        if (NODE_IS_IFACE (node))
<span class="line-modified">!   {</span>
            IFACE_NODE_N_PREREQUISITES (node) = 0;
<span class="line-modified">!     IFACE_NODE_PREREQUISITES (node) = NULL;</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   _g_atomic_array_init (CLASSED_NODE_IFACES_ENTRIES (node));</span>
      }
    else
      {
        node-&gt;supers[0] = type;
        memcpy (node-&gt;supers + 1, pnode-&gt;supers, sizeof (GType) * (1 + pnode-&gt;n_supers + 1));
  
        node-&gt;is_classed = pnode-&gt;is_classed;
        node-&gt;is_instantiatable = pnode-&gt;is_instantiatable;
  
        if (NODE_IS_IFACE (node))
<span class="line-modified">!   {</span>
<span class="line-modified">!     IFACE_NODE_N_PREREQUISITES (node) = 0;</span>
<span class="line-modified">!     IFACE_NODE_PREREQUISITES (node) = NULL;</span>
<span class="line-modified">!   }</span>
        else
<span class="line-added">+   {</span>
<span class="line-added">+     guint j;</span>
<span class="line-added">+     IFaceEntries *entries;</span>
<span class="line-added">+ </span>
<span class="line-added">+     entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (pnode),</span>
<span class="line-added">+             IFACE_ENTRIES_HEADER_SIZE,</span>
<span class="line-added">+             0);</span>
<span class="line-added">+     if (entries)</span>
<span class="line-added">+       {</span>
<span class="line-added">+         for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (entries); j++)</span>
      {
<span class="line-modified">!       entries-&gt;entry[j].vtable = NULL;</span>
<span class="line-modified">!       entries-&gt;entry[j].init_state = UNINITIALIZED;</span>
      }
<span class="line-added">+         _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node),</span>
<span class="line-added">+               entries);</span>
<span class="line-added">+       }</span>
<span class="line-added">+   }</span>
  
        i = pnode-&gt;n_children++;
        pnode-&gt;children = g_renew (GType, pnode-&gt;children, pnode-&gt;n_children);
        pnode-&gt;children[i] = type;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 507,12 ***</span>
    node-&gt;children = NULL;
    node-&gt;data = NULL;
    node-&gt;qname = g_quark_from_string (name);
    node-&gt;global_gdata = NULL;
    g_hash_table_insert (static_type_nodes_ht,
<span class="line-modified">!                (gpointer) g_quark_to_string (node-&gt;qname),</span>
<span class="line-modified">!                (gpointer) type);</span>
  
    g_atomic_int_inc ((gint *)&amp;type_registration_serial);
  
    return node;
  }
<span class="line-new-header">--- 510,12 ---</span>
    node-&gt;children = NULL;
    node-&gt;data = NULL;
    node-&gt;qname = g_quark_from_string (name);
    node-&gt;global_gdata = NULL;
    g_hash_table_insert (static_type_nodes_ht,
<span class="line-modified">!            (gpointer) g_quark_to_string (node-&gt;qname),</span>
<span class="line-modified">!            (gpointer) type);</span>
  
    g_atomic_int_inc ((gint *)&amp;type_registration_serial);
  
    return node;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 528,12 ***</span>
    return node ? G_STRUCT_MEMBER_P (node, -SIZEOF_FUNDAMENTAL_INFO) : NULL;
  }
  
  static TypeNode*
  type_node_fundamental_new_W (GType                 ftype,
<span class="line-modified">!                  const gchar          *name,</span>
<span class="line-modified">!                  GTypeFundamentalFlags type_flags)</span>
  {
    GTypeFundamentalInfo *finfo;
    TypeNode *node;
  
    g_assert ((ftype &amp; TYPE_ID_MASK) == 0);
<span class="line-new-header">--- 531,12 ---</span>
    return node ? G_STRUCT_MEMBER_P (node, -SIZEOF_FUNDAMENTAL_INFO) : NULL;
  }
  
  static TypeNode*
  type_node_fundamental_new_W (GType                 ftype,
<span class="line-modified">!            const gchar          *name,</span>
<span class="line-modified">!            GTypeFundamentalFlags type_flags)</span>
  {
    GTypeFundamentalInfo *finfo;
    TypeNode *node;
  
    g_assert ((ftype &amp; TYPE_ID_MASK) == 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 552,12 ***</span>
    return node;
  }
  
  static TypeNode*
  type_node_new_W (TypeNode    *pnode,
<span class="line-modified">!          const gchar *name,</span>
<span class="line-modified">!          GTypePlugin *plugin)</span>
  
  {
    g_assert (pnode);
    g_assert (pnode-&gt;n_supers &lt; MAX_N_SUPERS);
    g_assert (pnode-&gt;n_children &lt; MAX_N_CHILDREN);
<span class="line-new-header">--- 555,12 ---</span>
    return node;
  }
  
  static TypeNode*
  type_node_new_W (TypeNode    *pnode,
<span class="line-modified">!      const gchar *name,</span>
<span class="line-modified">!      GTypePlugin *plugin)</span>
  
  {
    g_assert (pnode);
    g_assert (pnode-&gt;n_supers &lt; MAX_N_SUPERS);
    g_assert (pnode-&gt;n_children &lt; MAX_N_CHILDREN);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 565,11 ***</span>
    return type_node_any_new_W (pnode, NODE_FUNDAMENTAL_TYPE (pnode), name, plugin, 0);
  }
  
  static inline IFaceEntry*
  lookup_iface_entry_I (volatile IFaceEntries *entries,
<span class="line-modified">!               TypeNode *iface_node)</span>
  {
    guint8 *offsets;
    guint offset_index;
    IFaceEntry *check;
    int index;
<span class="line-new-header">--- 568,11 ---</span>
    return type_node_any_new_W (pnode, NODE_FUNDAMENTAL_TYPE (pnode), name, plugin, 0);
  }
  
  static inline IFaceEntry*
  lookup_iface_entry_I (volatile IFaceEntries *entries,
<span class="line-modified">!           TypeNode *iface_node)</span>
  {
    guint8 *offsets;
    guint offset_index;
    IFaceEntry *check;
    int index;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 583,101 ***</span>
  
       entry = NULL;
       offsets = transaction_data;
       offset_index = entries-&gt;offset_index;
       if (offsets != NULL &amp;&amp;
<span class="line-modified">!      offset_index &lt; G_ATOMIC_ARRAY_DATA_SIZE(offsets))</span>
<span class="line-removed">-        {</span>
<span class="line-removed">-      index = offsets[offset_index];</span>
<span class="line-removed">-      if (index &gt; 0)</span>
         {
<span class="line-modified">!          /* zero means unset, subtract one to get real index */</span>
<span class="line-modified">!          index -= 1;</span>
<span class="line-modified">! </span>
<span class="line-modified">!          if (index &lt; IFACE_ENTRIES_N_ENTRIES (entries))</span>
<span class="line-modified">!            {</span>
<span class="line-modified">!          check = (IFaceEntry *)&amp;entries-&gt;entry[index];</span>
<span class="line-modified">!          if (check-&gt;iface_type == NODE_TYPE (iface_node))</span>
<span class="line-modified">!            entry = check;</span>
<span class="line-modified">!            }</span>
<span class="line-modified">!        }</span>
         }
       );
  
   return entry;
  }
  
  static inline IFaceEntry*
  type_lookup_iface_entry_L (TypeNode *node,
<span class="line-modified">!                TypeNode *iface_node)</span>
  {
    if (!NODE_IS_IFACE (iface_node))
      return NULL;
  
    return lookup_iface_entry_I (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node),
<span class="line-modified">!                    iface_node);</span>
  }
  
  
  static inline gboolean
  type_lookup_iface_vtable_I (TypeNode *node,
<span class="line-modified">!                 TypeNode *iface_node,</span>
<span class="line-modified">!                 gpointer *vtable_ptr)</span>
  {
    IFaceEntry *entry;
    gboolean res;
  
    if (!NODE_IS_IFACE (iface_node))
      {
        if (vtable_ptr)
<span class="line-modified">!     *vtable_ptr = NULL;</span>
        return FALSE;
      }
  
    G_ATOMIC_ARRAY_DO_TRANSACTION
      (CLASSED_NODE_IFACES_ENTRIES (node), IFaceEntries,
  
       entry = lookup_iface_entry_I (transaction_data, iface_node);
       res = entry != NULL;
       if (vtable_ptr)
         {
<span class="line-modified">!      if (entry)</span>
<span class="line-modified">!        *vtable_ptr = entry-&gt;vtable;</span>
<span class="line-modified">!      else</span>
<span class="line-modified">!        *vtable_ptr = NULL;</span>
         }
       );
  
    return res;
  }
  
  static inline gboolean
  type_lookup_prerequisite_L (TypeNode *iface,
<span class="line-modified">!                 GType     prerequisite_type)</span>
  {
    if (NODE_IS_IFACE (iface) &amp;&amp; IFACE_NODE_N_PREREQUISITES (iface))
      {
        GType *prerequisites = IFACE_NODE_PREREQUISITES (iface) - 1;
        guint n_prerequisites = IFACE_NODE_N_PREREQUISITES (iface);
  
        do
<span class="line-modified">!     {</span>
<span class="line-modified">!       guint i;</span>
<span class="line-modified">!       GType *check;</span>
  
<span class="line-modified">!       i = (n_prerequisites + 1) &gt;&gt; 1;</span>
<span class="line-modified">!       check = prerequisites + i;</span>
<span class="line-modified">!       if (prerequisite_type == *check)</span>
<span class="line-modified">!         return TRUE;</span>
<span class="line-modified">!       else if (prerequisite_type &gt; *check)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           n_prerequisites -= i;</span>
<span class="line-modified">!           prerequisites = check;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       else /* if (prerequisite_type &lt; *check) */</span>
<span class="line-modified">!         n_prerequisites = i - 1;</span>
<span class="line-modified">!     }</span>
        while (n_prerequisites);
      }
    return FALSE;
  }
  
<span class="line-new-header">--- 586,101 ---</span>
  
       entry = NULL;
       offsets = transaction_data;
       offset_index = entries-&gt;offset_index;
       if (offsets != NULL &amp;&amp;
<span class="line-modified">!    offset_index &lt; G_ATOMIC_ARRAY_DATA_SIZE(offsets))</span>
         {
<span class="line-modified">!    index = offsets[offset_index];</span>
<span class="line-modified">!    if (index &gt; 0)</span>
<span class="line-modified">!      {</span>
<span class="line-modified">!        /* zero means unset, subtract one to get real index */</span>
<span class="line-modified">!        index -= 1;</span>
<span class="line-modified">! </span>
<span class="line-modified">!        if (index &lt; IFACE_ENTRIES_N_ENTRIES (entries))</span>
<span class="line-modified">!          {</span>
<span class="line-modified">!      check = (IFaceEntry *)&amp;entries-&gt;entry[index];</span>
<span class="line-modified">!      if (check-&gt;iface_type == NODE_TYPE (iface_node))</span>
<span class="line-added">+        entry = check;</span>
<span class="line-added">+          }</span>
<span class="line-added">+      }</span>
         }
       );
  
   return entry;
  }
  
  static inline IFaceEntry*
  type_lookup_iface_entry_L (TypeNode *node,
<span class="line-modified">!          TypeNode *iface_node)</span>
  {
    if (!NODE_IS_IFACE (iface_node))
      return NULL;
  
    return lookup_iface_entry_I (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node),
<span class="line-modified">!              iface_node);</span>
  }
  
  
  static inline gboolean
  type_lookup_iface_vtable_I (TypeNode *node,
<span class="line-modified">!           TypeNode *iface_node,</span>
<span class="line-modified">!           gpointer *vtable_ptr)</span>
  {
    IFaceEntry *entry;
    gboolean res;
  
    if (!NODE_IS_IFACE (iface_node))
      {
        if (vtable_ptr)
<span class="line-modified">!   *vtable_ptr = NULL;</span>
        return FALSE;
      }
  
    G_ATOMIC_ARRAY_DO_TRANSACTION
      (CLASSED_NODE_IFACES_ENTRIES (node), IFaceEntries,
  
       entry = lookup_iface_entry_I (transaction_data, iface_node);
       res = entry != NULL;
       if (vtable_ptr)
         {
<span class="line-modified">!    if (entry)</span>
<span class="line-modified">!      *vtable_ptr = entry-&gt;vtable;</span>
<span class="line-modified">!    else</span>
<span class="line-modified">!      *vtable_ptr = NULL;</span>
         }
       );
  
    return res;
  }
  
  static inline gboolean
  type_lookup_prerequisite_L (TypeNode *iface,
<span class="line-modified">!           GType     prerequisite_type)</span>
  {
    if (NODE_IS_IFACE (iface) &amp;&amp; IFACE_NODE_N_PREREQUISITES (iface))
      {
        GType *prerequisites = IFACE_NODE_PREREQUISITES (iface) - 1;
        guint n_prerequisites = IFACE_NODE_N_PREREQUISITES (iface);
  
        do
<span class="line-modified">!   {</span>
<span class="line-modified">!     guint i;</span>
<span class="line-modified">!     GType *check;</span>
  
<span class="line-modified">!     i = (n_prerequisites + 1) &gt;&gt; 1;</span>
<span class="line-modified">!     check = prerequisites + i;</span>
<span class="line-modified">!     if (prerequisite_type == *check)</span>
<span class="line-modified">!       return TRUE;</span>
<span class="line-modified">!     else if (prerequisite_type &gt; *check)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         n_prerequisites -= i;</span>
<span class="line-modified">!         prerequisites = check;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     else /* if (prerequisite_type &lt; *check) */</span>
<span class="line-modified">!       n_prerequisites = i - 1;</span>
<span class="line-modified">!   }</span>
        while (n_prerequisites);
      }
    return FALSE;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 696,38 ***</span>
  
  
  /* --- type consistency checks --- */
  static gboolean
  check_plugin_U (GTypePlugin *plugin,
<span class="line-modified">!         gboolean     need_complete_type_info,</span>
<span class="line-modified">!         gboolean     need_complete_interface_info,</span>
<span class="line-modified">!         const gchar *type_name)</span>
  {
    /* G_IS_TYPE_PLUGIN() and G_TYPE_PLUGIN_GET_CLASS() are external calls: _U
     */
    if (!plugin)
      {
        g_warning (&quot;plugin handle for type &#39;%s&#39; is NULL&quot;,
<span class="line-modified">!          type_name);</span>
        return FALSE;
      }
    if (!G_IS_TYPE_PLUGIN (plugin))
      {
        g_warning (&quot;plugin pointer (%p) for type &#39;%s&#39; is invalid&quot;,
<span class="line-modified">!          plugin, type_name);</span>
        return FALSE;
      }
    if (need_complete_type_info &amp;&amp; !G_TYPE_PLUGIN_GET_CLASS (plugin)-&gt;complete_type_info)
      {
        g_warning (&quot;plugin for type &#39;%s&#39; has no complete_type_info() implementation&quot;,
<span class="line-modified">!          type_name);</span>
        return FALSE;
      }
    if (need_complete_interface_info &amp;&amp; !G_TYPE_PLUGIN_GET_CLASS (plugin)-&gt;complete_interface_info)
      {
        g_warning (&quot;plugin for type &#39;%s&#39; has no complete_interface_info() implementation&quot;,
<span class="line-modified">!          type_name);</span>
        return FALSE;
      }
    return TRUE;
  }
  
<span class="line-new-header">--- 699,38 ---</span>
  
  
  /* --- type consistency checks --- */
  static gboolean
  check_plugin_U (GTypePlugin *plugin,
<span class="line-modified">!     gboolean     need_complete_type_info,</span>
<span class="line-modified">!     gboolean     need_complete_interface_info,</span>
<span class="line-modified">!     const gchar *type_name)</span>
  {
    /* G_IS_TYPE_PLUGIN() and G_TYPE_PLUGIN_GET_CLASS() are external calls: _U
     */
    if (!plugin)
      {
        g_warning (&quot;plugin handle for type &#39;%s&#39; is NULL&quot;,
<span class="line-modified">!      type_name);</span>
        return FALSE;
      }
    if (!G_IS_TYPE_PLUGIN (plugin))
      {
        g_warning (&quot;plugin pointer (%p) for type &#39;%s&#39; is invalid&quot;,
<span class="line-modified">!      plugin, type_name);</span>
        return FALSE;
      }
    if (need_complete_type_info &amp;&amp; !G_TYPE_PLUGIN_GET_CLASS (plugin)-&gt;complete_type_info)
      {
        g_warning (&quot;plugin for type &#39;%s&#39; has no complete_type_info() implementation&quot;,
<span class="line-modified">!      type_name);</span>
        return FALSE;
      }
    if (need_complete_interface_info &amp;&amp; !G_TYPE_PLUGIN_GET_CLASS (plugin)-&gt;complete_interface_info)
      {
        g_warning (&quot;plugin for type &#39;%s&#39; has no complete_interface_info() implementation&quot;,
<span class="line-modified">!      type_name);</span>
        return FALSE;
      }
    return TRUE;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 745,13 ***</span>
      }
    /* check the first letter */
    name_valid = (p[0] &gt;= &#39;A&#39; &amp;&amp; p[0] &lt;= &#39;Z&#39;) || (p[0] &gt;= &#39;a&#39; &amp;&amp; p[0] &lt;= &#39;z&#39;) || p[0] == &#39;_&#39;;
    for (p = type_name + 1; *p; p++)
      name_valid &amp;= ((p[0] &gt;= &#39;A&#39; &amp;&amp; p[0] &lt;= &#39;Z&#39;) ||
<span class="line-modified">!            (p[0] &gt;= &#39;a&#39; &amp;&amp; p[0] &lt;= &#39;z&#39;) ||</span>
<span class="line-modified">!            (p[0] &gt;= &#39;0&#39; &amp;&amp; p[0] &lt;= &#39;9&#39;) ||</span>
<span class="line-modified">!            strchr (extra_chars, p[0]));</span>
    if (!name_valid)
      {
        g_warning (&quot;type name &#39;%s&#39; contains invalid characters&quot;, type_name);
        return FALSE;
      }
<span class="line-new-header">--- 748,13 ---</span>
      }
    /* check the first letter */
    name_valid = (p[0] &gt;= &#39;A&#39; &amp;&amp; p[0] &lt;= &#39;Z&#39;) || (p[0] &gt;= &#39;a&#39; &amp;&amp; p[0] &lt;= &#39;z&#39;) || p[0] == &#39;_&#39;;
    for (p = type_name + 1; *p; p++)
      name_valid &amp;= ((p[0] &gt;= &#39;A&#39; &amp;&amp; p[0] &lt;= &#39;Z&#39;) ||
<span class="line-modified">!        (p[0] &gt;= &#39;a&#39; &amp;&amp; p[0] &lt;= &#39;z&#39;) ||</span>
<span class="line-modified">!        (p[0] &gt;= &#39;0&#39; &amp;&amp; p[0] &lt;= &#39;9&#39;) ||</span>
<span class="line-modified">!        strchr (extra_chars, p[0]));</span>
    if (!name_valid)
      {
        g_warning (&quot;type name &#39;%s&#39; contains invalid characters&quot;, type_name);
        return FALSE;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 764,39 ***</span>
    return TRUE;
  }
  
  static gboolean
  check_derivation_I (GType        parent_type,
<span class="line-modified">!             const gchar *type_name)</span>
  {
    TypeNode *pnode;
    GTypeFundamentalInfo* finfo;
  
    pnode = lookup_type_node_I (parent_type);
    if (!pnode)
      {
        g_warning (&quot;cannot derive type &#39;%s&#39; from invalid parent type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_name,</span>
<span class="line-modified">!          type_descriptive_name_I (parent_type));</span>
        return FALSE;
      }
    finfo = type_node_fundamental_info_I (pnode);
    /* ensure flat derivability */
    if (!(finfo-&gt;type_flags &amp; G_TYPE_FLAG_DERIVABLE))
      {
        g_warning (&quot;cannot derive &#39;%s&#39; from non-derivable parent type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_name,</span>
<span class="line-modified">!          NODE_NAME (pnode));</span>
        return FALSE;
      }
    /* ensure deep derivability */
    if (parent_type != NODE_FUNDAMENTAL_TYPE (pnode) &amp;&amp;
        !(finfo-&gt;type_flags &amp; G_TYPE_FLAG_DEEP_DERIVABLE))
      {
        g_warning (&quot;cannot derive &#39;%s&#39; from non-fundamental parent type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_name,</span>
<span class="line-modified">!          NODE_NAME (pnode));</span>
        return FALSE;
      }
  
    return TRUE;
  }
<span class="line-new-header">--- 767,39 ---</span>
    return TRUE;
  }
  
  static gboolean
  check_derivation_I (GType        parent_type,
<span class="line-modified">!         const gchar *type_name)</span>
  {
    TypeNode *pnode;
    GTypeFundamentalInfo* finfo;
  
    pnode = lookup_type_node_I (parent_type);
    if (!pnode)
      {
        g_warning (&quot;cannot derive type &#39;%s&#39; from invalid parent type &#39;%s&#39;&quot;,
<span class="line-modified">!      type_name,</span>
<span class="line-modified">!      type_descriptive_name_I (parent_type));</span>
        return FALSE;
      }
    finfo = type_node_fundamental_info_I (pnode);
    /* ensure flat derivability */
    if (!(finfo-&gt;type_flags &amp; G_TYPE_FLAG_DERIVABLE))
      {
        g_warning (&quot;cannot derive &#39;%s&#39; from non-derivable parent type &#39;%s&#39;&quot;,
<span class="line-modified">!      type_name,</span>
<span class="line-modified">!      NODE_NAME (pnode));</span>
        return FALSE;
      }
    /* ensure deep derivability */
    if (parent_type != NODE_FUNDAMENTAL_TYPE (pnode) &amp;&amp;
        !(finfo-&gt;type_flags &amp; G_TYPE_FLAG_DEEP_DERIVABLE))
      {
        g_warning (&quot;cannot derive &#39;%s&#39; from non-fundamental parent type &#39;%s&#39;&quot;,
<span class="line-modified">!      type_name,</span>
<span class="line-modified">!      NODE_NAME (pnode));</span>
        return FALSE;
      }
  
    return TRUE;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 804,86 ***</span>
  static gboolean
  check_collect_format_I (const gchar *collect_format)
  {
    const gchar *p = collect_format;
    gchar valid_format[] = { G_VALUE_COLLECT_INT, G_VALUE_COLLECT_LONG,
<span class="line-modified">!                G_VALUE_COLLECT_INT64, G_VALUE_COLLECT_DOUBLE,</span>
<span class="line-modified">!                G_VALUE_COLLECT_POINTER, 0 };</span>
  
    while (*p)
      if (!strchr (valid_format, *p++))
        return FALSE;
    return p - collect_format &lt;= G_VALUE_COLLECT_FORMAT_MAX_LENGTH;
  }
  
  static gboolean
  check_value_table_I (const gchar           *type_name,
<span class="line-modified">!              const GTypeValueTable *value_table)</span>
  {
    if (!value_table)
      return FALSE;
    else if (value_table-&gt;value_init == NULL)
      {
        if (value_table-&gt;value_free || value_table-&gt;value_copy ||
<span class="line-modified">!       value_table-&gt;value_peek_pointer ||</span>
<span class="line-modified">!       value_table-&gt;collect_format || value_table-&gt;collect_value ||</span>
<span class="line-modified">!       value_table-&gt;lcopy_format || value_table-&gt;lcopy_value)</span>
<span class="line-modified">!     g_warning (&quot;cannot handle uninitializable values of type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!            type_name);</span>
        return FALSE;
      }
    else /* value_table-&gt;value_init != NULL */
      {
        if (!value_table-&gt;value_free)
<span class="line-modified">!     {</span>
<span class="line-modified">!       /* +++ optional +++</span>
<span class="line-modified">!        * g_warning (&quot;missing &#39;value_free()&#39; for type &#39;%s&#39;&quot;, type_name);</span>
<span class="line-modified">!        * return FALSE;</span>
<span class="line-modified">!        */</span>
<span class="line-modified">!     }</span>
        if (!value_table-&gt;value_copy)
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;missing &#39;value_copy()&#39; for type &#39;%s&#39;&quot;, type_name);</span>
<span class="line-modified">!       return FALSE;</span>
<span class="line-modified">!     }</span>
        if ((value_table-&gt;collect_format || value_table-&gt;collect_value) &amp;&amp;
<span class="line-modified">!       (!value_table-&gt;collect_format || !value_table-&gt;collect_value))</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;one of &#39;collect_format&#39; and &#39;collect_value()&#39; is unspecified for type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!              type_name);</span>
<span class="line-modified">!       return FALSE;</span>
<span class="line-modified">!     }</span>
        if (value_table-&gt;collect_format &amp;&amp; !check_collect_format_I (value_table-&gt;collect_format))
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;the &#39;%s&#39; specification for type &#39;%s&#39; is too long or invalid&quot;,</span>
<span class="line-modified">!              &quot;collect_format&quot;,</span>
<span class="line-modified">!              type_name);</span>
<span class="line-modified">!       return FALSE;</span>
<span class="line-modified">!     }</span>
        if ((value_table-&gt;lcopy_format || value_table-&gt;lcopy_value) &amp;&amp;
<span class="line-modified">!       (!value_table-&gt;lcopy_format || !value_table-&gt;lcopy_value))</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;one of &#39;lcopy_format&#39; and &#39;lcopy_value()&#39; is unspecified for type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!              type_name);</span>
<span class="line-modified">!       return FALSE;</span>
<span class="line-modified">!     }</span>
        if (value_table-&gt;lcopy_format &amp;&amp; !check_collect_format_I (value_table-&gt;lcopy_format))
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;the &#39;%s&#39; specification for type &#39;%s&#39; is too long or invalid&quot;,</span>
<span class="line-modified">!              &quot;lcopy_format&quot;,</span>
<span class="line-modified">!              type_name);</span>
<span class="line-modified">!       return FALSE;</span>
<span class="line-modified">!     }</span>
      }
    return TRUE;
  }
  
  static gboolean
  check_type_info_I (TypeNode        *pnode,
<span class="line-modified">!            GType            ftype,</span>
<span class="line-modified">!            const gchar     *type_name,</span>
<span class="line-modified">!            const GTypeInfo *info)</span>
  {
    GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (lookup_type_node_I (ftype));
    gboolean is_interface = ftype == G_TYPE_INTERFACE;
  
    g_assert (ftype &lt;= G_TYPE_FUNDAMENTAL_MAX &amp;&amp; !(ftype &amp; TYPE_ID_MASK));
<span class="line-new-header">--- 807,86 ---</span>
  static gboolean
  check_collect_format_I (const gchar *collect_format)
  {
    const gchar *p = collect_format;
    gchar valid_format[] = { G_VALUE_COLLECT_INT, G_VALUE_COLLECT_LONG,
<span class="line-modified">!          G_VALUE_COLLECT_INT64, G_VALUE_COLLECT_DOUBLE,</span>
<span class="line-modified">!          G_VALUE_COLLECT_POINTER, 0 };</span>
  
    while (*p)
      if (!strchr (valid_format, *p++))
        return FALSE;
    return p - collect_format &lt;= G_VALUE_COLLECT_FORMAT_MAX_LENGTH;
  }
  
  static gboolean
  check_value_table_I (const gchar           *type_name,
<span class="line-modified">!          const GTypeValueTable *value_table)</span>
  {
    if (!value_table)
      return FALSE;
    else if (value_table-&gt;value_init == NULL)
      {
        if (value_table-&gt;value_free || value_table-&gt;value_copy ||
<span class="line-modified">!     value_table-&gt;value_peek_pointer ||</span>
<span class="line-modified">!     value_table-&gt;collect_format || value_table-&gt;collect_value ||</span>
<span class="line-modified">!     value_table-&gt;lcopy_format || value_table-&gt;lcopy_value)</span>
<span class="line-modified">!   g_warning (&quot;cannot handle uninitializable values of type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!        type_name);</span>
        return FALSE;
      }
    else /* value_table-&gt;value_init != NULL */
      {
        if (!value_table-&gt;value_free)
<span class="line-modified">!   {</span>
<span class="line-modified">!     /* +++ optional +++</span>
<span class="line-modified">!      * g_warning (&quot;missing &#39;value_free()&#39; for type &#39;%s&#39;&quot;, type_name);</span>
<span class="line-modified">!      * return FALSE;</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!   }</span>
        if (!value_table-&gt;value_copy)
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;missing &#39;value_copy()&#39; for type &#39;%s&#39;&quot;, type_name);</span>
<span class="line-modified">!     return FALSE;</span>
<span class="line-modified">!   }</span>
        if ((value_table-&gt;collect_format || value_table-&gt;collect_value) &amp;&amp;
<span class="line-modified">!     (!value_table-&gt;collect_format || !value_table-&gt;collect_value))</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;one of &#39;collect_format&#39; and &#39;collect_value()&#39; is unspecified for type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!          type_name);</span>
<span class="line-modified">!     return FALSE;</span>
<span class="line-modified">!   }</span>
        if (value_table-&gt;collect_format &amp;&amp; !check_collect_format_I (value_table-&gt;collect_format))
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;the &#39;%s&#39; specification for type &#39;%s&#39; is too long or invalid&quot;,</span>
<span class="line-modified">!          &quot;collect_format&quot;,</span>
<span class="line-modified">!          type_name);</span>
<span class="line-modified">!     return FALSE;</span>
<span class="line-modified">!   }</span>
        if ((value_table-&gt;lcopy_format || value_table-&gt;lcopy_value) &amp;&amp;
<span class="line-modified">!     (!value_table-&gt;lcopy_format || !value_table-&gt;lcopy_value))</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;one of &#39;lcopy_format&#39; and &#39;lcopy_value()&#39; is unspecified for type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!          type_name);</span>
<span class="line-modified">!     return FALSE;</span>
<span class="line-modified">!   }</span>
        if (value_table-&gt;lcopy_format &amp;&amp; !check_collect_format_I (value_table-&gt;lcopy_format))
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;the &#39;%s&#39; specification for type &#39;%s&#39; is too long or invalid&quot;,</span>
<span class="line-modified">!          &quot;lcopy_format&quot;,</span>
<span class="line-modified">!          type_name);</span>
<span class="line-modified">!     return FALSE;</span>
<span class="line-modified">!   }</span>
      }
    return TRUE;
  }
  
  static gboolean
  check_type_info_I (TypeNode        *pnode,
<span class="line-modified">!        GType            ftype,</span>
<span class="line-modified">!        const gchar     *type_name,</span>
<span class="line-modified">!        const GTypeInfo *info)</span>
  {
    GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (lookup_type_node_I (ftype));
    gboolean is_interface = ftype == G_TYPE_INTERFACE;
  
    g_assert (ftype &lt;= G_TYPE_FUNDAMENTAL_MAX &amp;&amp; !(ftype &amp; TYPE_ID_MASK));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 891,82 ***</span>
    /* check instance members */
    if (!(finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) &amp;&amp;
        (info-&gt;instance_size || info-&gt;n_preallocs || info-&gt;instance_init))
      {
        if (pnode)
<span class="line-modified">!     g_warning (&quot;cannot instantiate &#39;%s&#39;, derived from non-instantiatable parent type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!            type_name,</span>
<span class="line-modified">!            NODE_NAME (pnode));</span>
        else
<span class="line-modified">!     g_warning (&quot;cannot instantiate &#39;%s&#39; as non-instantiatable fundamental&quot;,</span>
<span class="line-modified">!            type_name);</span>
        return FALSE;
      }
    /* check class &amp; interface members */
    if (!((finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED) || is_interface) &amp;&amp;
        (info-&gt;class_init || info-&gt;class_finalize || info-&gt;class_data ||
         info-&gt;class_size || info-&gt;base_init || info-&gt;base_finalize))
      {
        if (pnode)
<span class="line-modified">!     g_warning (&quot;cannot create class for &#39;%s&#39;, derived from non-classed parent type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!            type_name,</span>
                     NODE_NAME (pnode));
        else
<span class="line-modified">!     g_warning (&quot;cannot create class for &#39;%s&#39; as non-classed fundamental&quot;,</span>
<span class="line-modified">!            type_name);</span>
        return FALSE;
      }
    /* check interface size */
    if (is_interface &amp;&amp; info-&gt;class_size &lt; sizeof (GTypeInterface))
      {
        g_warning (&quot;specified interface size for type &#39;%s&#39; is smaller than &#39;GTypeInterface&#39; size&quot;,
<span class="line-modified">!          type_name);</span>
        return FALSE;
      }
    /* check class size */
    if (finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED)
      {
        if (info-&gt;class_size &lt; sizeof (GTypeClass))
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;specified class size for type &#39;%s&#39; is smaller than &#39;GTypeClass&#39; size&quot;,</span>
<span class="line-modified">!              type_name);</span>
<span class="line-modified">!       return FALSE;</span>
<span class="line-modified">!     }</span>
        if (pnode &amp;&amp; info-&gt;class_size &lt; pnode-&gt;data-&gt;class.class_size)
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;specified class size for type &#39;%s&#39; is smaller &quot;</span>
<span class="line-modified">!              &quot;than the parent type&#39;s &#39;%s&#39; class size&quot;,</span>
<span class="line-modified">!              type_name,</span>
<span class="line-modified">!              NODE_NAME (pnode));</span>
<span class="line-modified">!       return FALSE;</span>
<span class="line-modified">!     }</span>
      }
    /* check instance size */
    if (finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE)
      {
        if (info-&gt;instance_size &lt; sizeof (GTypeInstance))
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;specified instance size for type &#39;%s&#39; is smaller than &#39;GTypeInstance&#39; size&quot;,</span>
<span class="line-modified">!              type_name);</span>
<span class="line-modified">!       return FALSE;</span>
<span class="line-modified">!     }</span>
        if (pnode &amp;&amp; info-&gt;instance_size &lt; pnode-&gt;data-&gt;instance.instance_size)
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;specified instance size for type &#39;%s&#39; is smaller &quot;</span>
<span class="line-modified">!              &quot;than the parent type&#39;s &#39;%s&#39; instance size&quot;,</span>
<span class="line-modified">!              type_name,</span>
<span class="line-modified">!              NODE_NAME (pnode));</span>
<span class="line-modified">!       return FALSE;</span>
<span class="line-modified">!     }</span>
      }
  
    return TRUE;
  }
  
  static TypeNode*
  find_conforming_child_type_L (TypeNode *pnode,
<span class="line-modified">!                   TypeNode *iface)</span>
  {
    TypeNode *node = NULL;
    guint i;
  
    if (type_lookup_iface_entry_L (pnode, iface))
<span class="line-new-header">--- 894,82 ---</span>
    /* check instance members */
    if (!(finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) &amp;&amp;
        (info-&gt;instance_size || info-&gt;n_preallocs || info-&gt;instance_init))
      {
        if (pnode)
<span class="line-modified">!   g_warning (&quot;cannot instantiate &#39;%s&#39;, derived from non-instantiatable parent type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!        type_name,</span>
<span class="line-modified">!        NODE_NAME (pnode));</span>
        else
<span class="line-modified">!   g_warning (&quot;cannot instantiate &#39;%s&#39; as non-instantiatable fundamental&quot;,</span>
<span class="line-modified">!        type_name);</span>
        return FALSE;
      }
    /* check class &amp; interface members */
    if (!((finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED) || is_interface) &amp;&amp;
        (info-&gt;class_init || info-&gt;class_finalize || info-&gt;class_data ||
         info-&gt;class_size || info-&gt;base_init || info-&gt;base_finalize))
      {
        if (pnode)
<span class="line-modified">!   g_warning (&quot;cannot create class for &#39;%s&#39;, derived from non-classed parent type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!        type_name,</span>
                     NODE_NAME (pnode));
        else
<span class="line-modified">!   g_warning (&quot;cannot create class for &#39;%s&#39; as non-classed fundamental&quot;,</span>
<span class="line-modified">!        type_name);</span>
        return FALSE;
      }
    /* check interface size */
    if (is_interface &amp;&amp; info-&gt;class_size &lt; sizeof (GTypeInterface))
      {
        g_warning (&quot;specified interface size for type &#39;%s&#39; is smaller than &#39;GTypeInterface&#39; size&quot;,
<span class="line-modified">!      type_name);</span>
        return FALSE;
      }
    /* check class size */
    if (finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED)
      {
        if (info-&gt;class_size &lt; sizeof (GTypeClass))
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;specified class size for type &#39;%s&#39; is smaller than &#39;GTypeClass&#39; size&quot;,</span>
<span class="line-modified">!          type_name);</span>
<span class="line-modified">!     return FALSE;</span>
<span class="line-modified">!   }</span>
        if (pnode &amp;&amp; info-&gt;class_size &lt; pnode-&gt;data-&gt;class.class_size)
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;specified class size for type &#39;%s&#39; is smaller &quot;</span>
<span class="line-modified">!          &quot;than the parent type&#39;s &#39;%s&#39; class size&quot;,</span>
<span class="line-modified">!          type_name,</span>
<span class="line-modified">!          NODE_NAME (pnode));</span>
<span class="line-modified">!     return FALSE;</span>
<span class="line-modified">!   }</span>
      }
    /* check instance size */
    if (finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE)
      {
        if (info-&gt;instance_size &lt; sizeof (GTypeInstance))
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;specified instance size for type &#39;%s&#39; is smaller than &#39;GTypeInstance&#39; size&quot;,</span>
<span class="line-modified">!          type_name);</span>
<span class="line-modified">!     return FALSE;</span>
<span class="line-modified">!   }</span>
        if (pnode &amp;&amp; info-&gt;instance_size &lt; pnode-&gt;data-&gt;instance.instance_size)
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;specified instance size for type &#39;%s&#39; is smaller &quot;</span>
<span class="line-modified">!          &quot;than the parent type&#39;s &#39;%s&#39; instance size&quot;,</span>
<span class="line-modified">!          type_name,</span>
<span class="line-modified">!          NODE_NAME (pnode));</span>
<span class="line-modified">!     return FALSE;</span>
<span class="line-modified">!   }</span>
      }
  
    return TRUE;
  }
  
  static TypeNode*
  find_conforming_child_type_L (TypeNode *pnode,
<span class="line-modified">!             TypeNode *iface)</span>
  {
    TypeNode *node = NULL;
    guint i;
  
    if (type_lookup_iface_entry_L (pnode, iface))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 978,11 ***</span>
    return node;
  }
  
  static gboolean
  check_add_interface_L (GType instance_type,
<span class="line-modified">!                GType iface_type)</span>
  {
    TypeNode *node = lookup_type_node_I (instance_type);
    TypeNode *iface = lookup_type_node_I (iface_type);
    IFaceEntry *entry;
    TypeNode *tnode;
<span class="line-new-header">--- 981,11 ---</span>
    return node;
  }
  
  static gboolean
  check_add_interface_L (GType instance_type,
<span class="line-modified">!            GType iface_type)</span>
  {
    TypeNode *node = lookup_type_node_I (instance_type);
    TypeNode *iface = lookup_type_node_I (iface_type);
    IFaceEntry *entry;
    TypeNode *tnode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 991,18 ***</span>
  
  
    if (!node || !node-&gt;is_instantiatable)
      {
        g_warning (&quot;cannot add interfaces to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (instance_type));</span>
        return FALSE;
      }
    if (!iface || !NODE_IS_IFACE (iface))
      {
        g_warning (&quot;cannot add invalid (non-interface) type &#39;%s&#39; to type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (iface_type),</span>
<span class="line-modified">!          NODE_NAME (node));</span>
        return FALSE;
      }
    if (node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class)
      {
        g_warning (&quot;attempting to add an interface (%s) to class (%s) after class_init&quot;,
<span class="line-new-header">--- 994,18 ---</span>
  
  
    if (!node || !node-&gt;is_instantiatable)
      {
        g_warning (&quot;cannot add interfaces to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">!      type_descriptive_name_I (instance_type));</span>
        return FALSE;
      }
    if (!iface || !NODE_IS_IFACE (iface))
      {
        g_warning (&quot;cannot add invalid (non-interface) type &#39;%s&#39; to type &#39;%s&#39;&quot;,
<span class="line-modified">!      type_descriptive_name_I (iface_type),</span>
<span class="line-modified">!      NODE_NAME (node));</span>
        return FALSE;
      }
    if (node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class)
      {
        g_warning (&quot;attempting to add an interface (%s) to class (%s) after class_init&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1012,13 ***</span>
    tnode = lookup_type_node_I (NODE_PARENT_TYPE (iface));
    if (NODE_PARENT_TYPE (tnode) &amp;&amp; !type_lookup_iface_entry_L (node, tnode))
      {
        /* 2001/7/31:timj: erk, i guess this warning is junk as interface derivation is flat */
        g_warning (&quot;cannot add sub-interface &#39;%s&#39; to type &#39;%s&#39; which does not conform to super-interface &#39;%s&#39;&quot;,
<span class="line-modified">!          NODE_NAME (iface),</span>
<span class="line-modified">!          NODE_NAME (node),</span>
<span class="line-modified">!          NODE_NAME (tnode));</span>
        return FALSE;
      }
    /* allow overriding of interface type introduced for parent type */
    entry = type_lookup_iface_entry_L (node, iface);
    if (entry &amp;&amp; entry-&gt;vtable == NULL &amp;&amp; !type_iface_peek_holder_L (iface, NODE_TYPE (node)))
<span class="line-new-header">--- 1015,13 ---</span>
    tnode = lookup_type_node_I (NODE_PARENT_TYPE (iface));
    if (NODE_PARENT_TYPE (tnode) &amp;&amp; !type_lookup_iface_entry_L (node, tnode))
      {
        /* 2001/7/31:timj: erk, i guess this warning is junk as interface derivation is flat */
        g_warning (&quot;cannot add sub-interface &#39;%s&#39; to type &#39;%s&#39; which does not conform to super-interface &#39;%s&#39;&quot;,
<span class="line-modified">!      NODE_NAME (iface),</span>
<span class="line-modified">!      NODE_NAME (node),</span>
<span class="line-modified">!      NODE_NAME (tnode));</span>
        return FALSE;
      }
    /* allow overriding of interface type introduced for parent type */
    entry = type_lookup_iface_entry_L (node, iface);
    if (entry &amp;&amp; entry-&gt;vtable == NULL &amp;&amp; !type_iface_peek_holder_L (iface, NODE_TYPE (node)))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1034,52 ***</span>
     */
    tnode = find_conforming_child_type_L (node, iface);  /* tnode is_a node */
    if (tnode)
      {
        g_warning (&quot;cannot add interface type &#39;%s&#39; to type &#39;%s&#39;, since type &#39;%s&#39; already conforms to interface&quot;,
<span class="line-modified">!          NODE_NAME (iface),</span>
<span class="line-modified">!          NODE_NAME (node),</span>
<span class="line-modified">!          NODE_NAME (tnode));</span>
        return FALSE;
      }
    prerequisites = IFACE_NODE_PREREQUISITES (iface);
    for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
      {
        tnode = lookup_type_node_I (prerequisites[i]);
        if (!type_node_is_a_L (node, tnode))
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;cannot add interface type &#39;%s&#39; to type &#39;%s&#39; which does not conform to prerequisite &#39;%s&#39;&quot;,</span>
<span class="line-modified">!              NODE_NAME (iface),</span>
<span class="line-modified">!              NODE_NAME (node),</span>
<span class="line-modified">!              NODE_NAME (tnode));</span>
<span class="line-modified">!       return FALSE;</span>
<span class="line-modified">!     }</span>
      }
    return TRUE;
  }
  
  static gboolean
  check_interface_info_I (TypeNode             *iface,
<span class="line-modified">!             GType                 instance_type,</span>
<span class="line-modified">!             const GInterfaceInfo *info)</span>
  {
    if ((info-&gt;interface_finalize || info-&gt;interface_data) &amp;&amp; !info-&gt;interface_init)
      {
        g_warning (&quot;interface type &#39;%s&#39; for type &#39;%s&#39; comes without initializer&quot;,
<span class="line-modified">!          NODE_NAME (iface),</span>
<span class="line-modified">!          type_descriptive_name_I (instance_type));</span>
        return FALSE;
      }
  
    return TRUE;
  }
  
  /* --- type info (type node data) --- */
  static void
  type_data_make_W (TypeNode              *node,
<span class="line-modified">!           const GTypeInfo       *info,</span>
<span class="line-modified">!           const GTypeValueTable *value_table)</span>
  {
    TypeData *data;
    GTypeValueTable *vtable = NULL;
    guint vtable_size = 0;
  
<span class="line-new-header">--- 1037,52 ---</span>
     */
    tnode = find_conforming_child_type_L (node, iface);  /* tnode is_a node */
    if (tnode)
      {
        g_warning (&quot;cannot add interface type &#39;%s&#39; to type &#39;%s&#39;, since type &#39;%s&#39; already conforms to interface&quot;,
<span class="line-modified">!      NODE_NAME (iface),</span>
<span class="line-modified">!      NODE_NAME (node),</span>
<span class="line-modified">!      NODE_NAME (tnode));</span>
        return FALSE;
      }
    prerequisites = IFACE_NODE_PREREQUISITES (iface);
    for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
      {
        tnode = lookup_type_node_I (prerequisites[i]);
        if (!type_node_is_a_L (node, tnode))
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;cannot add interface type &#39;%s&#39; to type &#39;%s&#39; which does not conform to prerequisite &#39;%s&#39;&quot;,</span>
<span class="line-modified">!          NODE_NAME (iface),</span>
<span class="line-modified">!          NODE_NAME (node),</span>
<span class="line-modified">!          NODE_NAME (tnode));</span>
<span class="line-modified">!     return FALSE;</span>
<span class="line-modified">!   }</span>
      }
    return TRUE;
  }
  
  static gboolean
  check_interface_info_I (TypeNode             *iface,
<span class="line-modified">!       GType                 instance_type,</span>
<span class="line-modified">!       const GInterfaceInfo *info)</span>
  {
    if ((info-&gt;interface_finalize || info-&gt;interface_data) &amp;&amp; !info-&gt;interface_init)
      {
        g_warning (&quot;interface type &#39;%s&#39; for type &#39;%s&#39; comes without initializer&quot;,
<span class="line-modified">!      NODE_NAME (iface),</span>
<span class="line-modified">!      type_descriptive_name_I (instance_type));</span>
        return FALSE;
      }
  
    return TRUE;
  }
  
  /* --- type info (type node data) --- */
  static void
  type_data_make_W (TypeNode              *node,
<span class="line-modified">!       const GTypeInfo       *info,</span>
<span class="line-modified">!       const GTypeValueTable *value_table)</span>
  {
    TypeData *data;
    GTypeValueTable *vtable = NULL;
    guint vtable_size = 0;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1088,26 ***</span>
    if (!value_table)
      {
        TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
  
        if (pnode)
<span class="line-modified">!     vtable = pnode-&gt;data-&gt;common.value_table;</span>
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       static const GTypeValueTable zero_vtable = { NULL, };</span>
  
<span class="line-modified">!       value_table = &amp;zero_vtable;</span>
<span class="line-modified">!     }</span>
      }
    if (value_table)
      {
        /* need to setup vtable_size since we have to allocate it with data in one chunk */
        vtable_size = sizeof (GTypeValueTable);
        if (value_table-&gt;collect_format)
<span class="line-modified">!     vtable_size += strlen (value_table-&gt;collect_format);</span>
        if (value_table-&gt;lcopy_format)
<span class="line-modified">!     vtable_size += strlen (value_table-&gt;lcopy_format);</span>
        vtable_size += 2;
      }
  
    if (node-&gt;is_instantiatable) /* careful, is_instantiatable is also is_classed */
      {
<span class="line-new-header">--- 1091,26 ---</span>
    if (!value_table)
      {
        TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
  
        if (pnode)
<span class="line-modified">!   vtable = pnode-&gt;data-&gt;common.value_table;</span>
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     static const GTypeValueTable zero_vtable = { NULL, };</span>
  
<span class="line-modified">!     value_table = &amp;zero_vtable;</span>
<span class="line-modified">!   }</span>
      }
    if (value_table)
      {
        /* need to setup vtable_size since we have to allocate it with data in one chunk */
        vtable_size = sizeof (GTypeValueTable);
        if (value_table-&gt;collect_format)
<span class="line-modified">!   vtable_size += strlen (value_table-&gt;collect_format);</span>
        if (value_table-&gt;lcopy_format)
<span class="line-modified">!   vtable_size += strlen (value_table-&gt;lcopy_format);</span>
        vtable_size += 2;
      }
  
    if (node-&gt;is_instantiatable) /* careful, is_instantiatable is also is_classed */
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1117,11 ***</span>
  #ifdef GSTREAMER_LITE
        if (data == NULL)
            return;
  #endif // GSTREAMER_LITE
        if (vtable_size)
<span class="line-modified">!     vtable = G_STRUCT_MEMBER_P (data, sizeof (InstanceData));</span>
        data-&gt;instance.class_size = info-&gt;class_size;
        data-&gt;instance.class_init_base = info-&gt;base_init;
        data-&gt;instance.class_finalize_base = info-&gt;base_finalize;
        data-&gt;instance.class_init = info-&gt;class_init;
        data-&gt;instance.class_finalize = info-&gt;class_finalize;
<span class="line-new-header">--- 1120,11 ---</span>
  #ifdef GSTREAMER_LITE
        if (data == NULL)
            return;
  #endif // GSTREAMER_LITE
        if (vtable_size)
<span class="line-modified">!   vtable = G_STRUCT_MEMBER_P (data, sizeof (InstanceData));</span>
        data-&gt;instance.class_size = info-&gt;class_size;
        data-&gt;instance.class_init_base = info-&gt;base_init;
        data-&gt;instance.class_finalize_base = info-&gt;base_finalize;
        data-&gt;instance.class_init = info-&gt;class_init;
        data-&gt;instance.class_finalize = info-&gt;class_finalize;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1143,11 ***</span>
      {
        TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
  
        data = g_malloc0 (sizeof (ClassData) + vtable_size);
        if (vtable_size)
<span class="line-modified">!     vtable = G_STRUCT_MEMBER_P (data, sizeof (ClassData));</span>
        data-&gt;class.class_size = info-&gt;class_size;
        data-&gt;class.class_init_base = info-&gt;base_init;
        data-&gt;class.class_finalize_base = info-&gt;base_finalize;
        data-&gt;class.class_init = info-&gt;class_init;
        data-&gt;class.class_finalize = info-&gt;class_finalize;
<span class="line-new-header">--- 1146,11 ---</span>
      {
        TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
  
        data = g_malloc0 (sizeof (ClassData) + vtable_size);
        if (vtable_size)
<span class="line-modified">!   vtable = G_STRUCT_MEMBER_P (data, sizeof (ClassData));</span>
        data-&gt;class.class_size = info-&gt;class_size;
        data-&gt;class.class_init_base = info-&gt;base_init;
        data-&gt;class.class_finalize_base = info-&gt;base_finalize;
        data-&gt;class.class_init = info-&gt;class_init;
        data-&gt;class.class_finalize = info-&gt;class_finalize;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1160,11 ***</span>
      }
    else if (NODE_IS_IFACE (node))
      {
        data = g_malloc0 (sizeof (IFaceData) + vtable_size);
        if (vtable_size)
<span class="line-modified">!     vtable = G_STRUCT_MEMBER_P (data, sizeof (IFaceData));</span>
        data-&gt;iface.vtable_size = info-&gt;class_size;
        data-&gt;iface.vtable_init_base = info-&gt;base_init;
        data-&gt;iface.vtable_finalize_base = info-&gt;base_finalize;
        data-&gt;iface.dflt_init = info-&gt;class_init;
        data-&gt;iface.dflt_finalize = info-&gt;class_finalize;
<span class="line-new-header">--- 1163,11 ---</span>
      }
    else if (NODE_IS_IFACE (node))
      {
        data = g_malloc0 (sizeof (IFaceData) + vtable_size);
        if (vtable_size)
<span class="line-modified">!   vtable = G_STRUCT_MEMBER_P (data, sizeof (IFaceData));</span>
        data-&gt;iface.vtable_size = info-&gt;class_size;
        data-&gt;iface.vtable_init_base = info-&gt;base_init;
        data-&gt;iface.vtable_finalize_base = info-&gt;base_finalize;
        data-&gt;iface.dflt_init = info-&gt;class_init;
        data-&gt;iface.dflt_finalize = info-&gt;class_finalize;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1173,17 ***</span>
      }
    else if (NODE_IS_BOXED (node))
      {
        data = g_malloc0 (sizeof (BoxedData) + vtable_size);
        if (vtable_size)
<span class="line-modified">!     vtable = G_STRUCT_MEMBER_P (data, sizeof (BoxedData));</span>
      }
    else
      {
        data = g_malloc0 (sizeof (CommonData) + vtable_size);
        if (vtable_size)
<span class="line-modified">!     vtable = G_STRUCT_MEMBER_P (data, sizeof (CommonData));</span>
      }
  
    node-&gt;data = data;
  
    if (vtable_size)
<span class="line-new-header">--- 1176,17 ---</span>
      }
    else if (NODE_IS_BOXED (node))
      {
        data = g_malloc0 (sizeof (BoxedData) + vtable_size);
        if (vtable_size)
<span class="line-modified">!   vtable = G_STRUCT_MEMBER_P (data, sizeof (BoxedData));</span>
      }
    else
      {
        data = g_malloc0 (sizeof (CommonData) + vtable_size);
        if (vtable_size)
<span class="line-modified">!   vtable = G_STRUCT_MEMBER_P (data, sizeof (CommonData));</span>
      }
  
    node-&gt;data = data;
  
    if (vtable_size)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1197,24 ***</span>
        *vtable = *value_table;
        p = G_STRUCT_MEMBER_P (vtable, sizeof (*vtable));
        p[0] = 0;
        vtable-&gt;collect_format = p;
        if (value_table-&gt;collect_format)
<span class="line-modified">!     {</span>
<span class="line-modified">!       strcat (p, value_table-&gt;collect_format);</span>
<span class="line-modified">!       p += strlen (value_table-&gt;collect_format);</span>
<span class="line-modified">!     }</span>
        p++;
        p[0] = 0;
        vtable-&gt;lcopy_format = p;
        if (value_table-&gt;lcopy_format)
<span class="line-modified">!     strcat  (p, value_table-&gt;lcopy_format);</span>
      }
    node-&gt;data-&gt;common.value_table = vtable;
    node-&gt;mutatable_check_cache = (node-&gt;data-&gt;common.value_table-&gt;value_init != NULL &amp;&amp;
<span class="line-modified">!                  !((G_TYPE_FLAG_VALUE_ABSTRACT | G_TYPE_FLAG_ABSTRACT) &amp;</span>
<span class="line-modified">!                    GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))));</span>
  
    g_assert (node-&gt;data-&gt;common.value_table != NULL); /* paranoid */
  
    g_atomic_int_set ((int *) &amp;node-&gt;ref_count, 1);
  }
<span class="line-new-header">--- 1200,24 ---</span>
        *vtable = *value_table;
        p = G_STRUCT_MEMBER_P (vtable, sizeof (*vtable));
        p[0] = 0;
        vtable-&gt;collect_format = p;
        if (value_table-&gt;collect_format)
<span class="line-modified">!   {</span>
<span class="line-modified">!     strcat (p, value_table-&gt;collect_format);</span>
<span class="line-modified">!     p += strlen (value_table-&gt;collect_format);</span>
<span class="line-modified">!   }</span>
        p++;
        p[0] = 0;
        vtable-&gt;lcopy_format = p;
        if (value_table-&gt;lcopy_format)
<span class="line-modified">!   strcat  (p, value_table-&gt;lcopy_format);</span>
      }
    node-&gt;data-&gt;common.value_table = vtable;
    node-&gt;mutatable_check_cache = (node-&gt;data-&gt;common.value_table-&gt;value_init != NULL &amp;&amp;
<span class="line-modified">!          !((G_TYPE_FLAG_VALUE_ABSTRACT | G_TYPE_FLAG_ABSTRACT) &amp;</span>
<span class="line-modified">!            GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))));</span>
  
    g_assert (node-&gt;data-&gt;common.value_table != NULL); /* paranoid */
  
    g_atomic_int_set ((int *) &amp;node-&gt;ref_count, 1);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1229,30 ***</span>
        GTypeValueTable tmp_value_table;
  
        g_assert (node-&gt;plugin != NULL);
  
        if (pnode)
<span class="line-modified">!     {</span>
<span class="line-modified">!       type_data_ref_Wm (pnode);</span>
<span class="line-modified">!       if (node-&gt;data)</span>
<span class="line-modified">!         INVALID_RECURSION (&quot;g_type_plugin_*&quot;, node-&gt;plugin, NODE_NAME (node));</span>
<span class="line-modified">!     }</span>
  
        memset (&amp;tmp_info, 0, sizeof (tmp_info));
        memset (&amp;tmp_value_table, 0, sizeof (tmp_value_table));
  
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_type_plugin_use (node-&gt;plugin);
        g_type_plugin_complete_type_info (node-&gt;plugin, NODE_TYPE (node), &amp;tmp_info, &amp;tmp_value_table);
        G_WRITE_LOCK (&amp;type_rw_lock);
        if (node-&gt;data)
<span class="line-modified">!     INVALID_RECURSION (&quot;g_type_plugin_*&quot;, node-&gt;plugin, NODE_NAME (node));</span>
  
        check_type_info_I (pnode, NODE_FUNDAMENTAL_TYPE (node), NODE_NAME (node), &amp;tmp_info);
        type_data_make_W (node, &amp;tmp_info,
<span class="line-modified">!             check_value_table_I (NODE_NAME (node),</span>
<span class="line-modified">!                          &amp;tmp_value_table) ? &amp;tmp_value_table : NULL);</span>
      }
    else
      {
        g_assert (NODE_REFCOUNT (node) &gt; 0);
  
<span class="line-new-header">--- 1232,30 ---</span>
        GTypeValueTable tmp_value_table;
  
        g_assert (node-&gt;plugin != NULL);
  
        if (pnode)
<span class="line-modified">!   {</span>
<span class="line-modified">!     type_data_ref_Wm (pnode);</span>
<span class="line-modified">!     if (node-&gt;data)</span>
<span class="line-modified">!       INVALID_RECURSION (&quot;g_type_plugin_*&quot;, node-&gt;plugin, NODE_NAME (node));</span>
<span class="line-modified">!   }</span>
  
        memset (&amp;tmp_info, 0, sizeof (tmp_info));
        memset (&amp;tmp_value_table, 0, sizeof (tmp_value_table));
  
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_type_plugin_use (node-&gt;plugin);
        g_type_plugin_complete_type_info (node-&gt;plugin, NODE_TYPE (node), &amp;tmp_info, &amp;tmp_value_table);
        G_WRITE_LOCK (&amp;type_rw_lock);
        if (node-&gt;data)
<span class="line-modified">!   INVALID_RECURSION (&quot;g_type_plugin_*&quot;, node-&gt;plugin, NODE_NAME (node));</span>
  
        check_type_info_I (pnode, NODE_FUNDAMENTAL_TYPE (node), NODE_NAME (node), &amp;tmp_info);
        type_data_make_W (node, &amp;tmp_info,
<span class="line-modified">!       check_value_table_I (NODE_NAME (node),</span>
<span class="line-modified">!                &amp;tmp_value_table) ? &amp;tmp_value_table : NULL);</span>
      }
    else
      {
        g_assert (NODE_REFCOUNT (node) &gt; 0);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1275,12 ***</span>
    return TRUE;
  }
  
  static gboolean
  iface_node_has_available_offset_L (TypeNode *iface_node,
<span class="line-modified">!                    int offset,</span>
<span class="line-modified">!                    int for_index)</span>
  {
    guint8 *offsets;
  
    offsets = G_ATOMIC_ARRAY_GET_LOCKED (&amp;iface_node-&gt;_prot.offsets, guint8);
    if (offsets == NULL)
<span class="line-new-header">--- 1278,12 ---</span>
    return TRUE;
  }
  
  static gboolean
  iface_node_has_available_offset_L (TypeNode *iface_node,
<span class="line-modified">!            int offset,</span>
<span class="line-modified">!            int for_index)</span>
  {
    guint8 *offsets;
  
    offsets = G_ATOMIC_ARRAY_GET_LOCKED (&amp;iface_node-&gt;_prot.offsets, guint8);
    if (offsets == NULL)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1309,27 ***</span>
    offset = -1;
    do
      {
        offset++;
        for (i = 0; i &lt; n_entries; i++)
<span class="line-modified">!     {</span>
<span class="line-modified">!       entry = &amp;entries-&gt;entry[i];</span>
<span class="line-modified">!       iface_node = lookup_type_node_I (entry-&gt;iface_type);</span>
  
<span class="line-modified">!       if (!iface_node_has_available_offset_L (iface_node, offset, i))</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     }</span>
      }
    while (i != n_entries);
  
    return offset;
  }
  
  static void
  iface_node_set_offset_L (TypeNode *iface_node,
<span class="line-modified">!              int offset,</span>
<span class="line-modified">!              int index)</span>
  {
    guint8 *offsets, *old_offsets;
    int new_size, old_size;
    int i;
  
<span class="line-new-header">--- 1312,27 ---</span>
    offset = -1;
    do
      {
        offset++;
        for (i = 0; i &lt; n_entries; i++)
<span class="line-modified">!   {</span>
<span class="line-modified">!     entry = &amp;entries-&gt;entry[i];</span>
<span class="line-modified">!     iface_node = lookup_type_node_I (entry-&gt;iface_type);</span>
  
<span class="line-modified">!     if (!iface_node_has_available_offset_L (iface_node, offset, i))</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!   }</span>
      }
    while (i != n_entries);
  
    return offset;
  }
  
  static void
  iface_node_set_offset_L (TypeNode *iface_node,
<span class="line-modified">!        int offset,</span>
<span class="line-modified">!        int index)</span>
  {
    guint8 *offsets, *old_offsets;
    int new_size, old_size;
    int i;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1338,17 ***</span>
      old_size = 0;
    else
      {
        old_size = G_ATOMIC_ARRAY_DATA_SIZE (old_offsets);
        if (offset &lt; old_size &amp;&amp;
<span class="line-modified">!       old_offsets[offset] == index + 1)</span>
<span class="line-modified">!     return; /* Already set to this index, return */</span>
      }
    new_size = MAX (old_size, offset + 1);
  
    offsets = _g_atomic_array_copy (&amp;iface_node-&gt;_prot.offsets,
<span class="line-modified">!                   0, new_size - old_size);</span>
  
    /* Mark new area as unused */
    for (i = old_size; i &lt; new_size; i++)
      offsets[i] = 0;
  
<span class="line-new-header">--- 1341,17 ---</span>
      old_size = 0;
    else
      {
        old_size = G_ATOMIC_ARRAY_DATA_SIZE (old_offsets);
        if (offset &lt; old_size &amp;&amp;
<span class="line-modified">!     old_offsets[offset] == index + 1)</span>
<span class="line-modified">!   return; /* Already set to this index, return */</span>
      }
    new_size = MAX (old_size, offset + 1);
  
    offsets = _g_atomic_array_copy (&amp;iface_node-&gt;_prot.offsets,
<span class="line-modified">!           0, new_size - old_size);</span>
  
    /* Mark new area as unused */
    for (i = old_size; i &lt; new_size; i++)
      offsets[i] = 0;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1357,11 ***</span>
    _g_atomic_array_update (&amp;iface_node-&gt;_prot.offsets, offsets);
  }
  
  static void
  type_node_add_iface_entry_W (TypeNode   *node,
<span class="line-modified">!                  GType       iface_type,</span>
                               IFaceEntry *parent_entry)
  {
    IFaceEntries *entries;
    IFaceEntry *entry;
    TypeNode *iface_node;
<span class="line-new-header">--- 1360,11 ---</span>
    _g_atomic_array_update (&amp;iface_node-&gt;_prot.offsets, offsets);
  }
  
  static void
  type_node_add_iface_entry_W (TypeNode   *node,
<span class="line-modified">!            GType       iface_type,</span>
                               IFaceEntry *parent_entry)
  {
    IFaceEntries *entries;
    IFaceEntry *entry;
    TypeNode *iface_node;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1376,38 ***</span>
        num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
  
        g_assert (num_entries &lt; MAX_N_INTERFACES);
  
        for (i = 0; i &lt; num_entries; i++)
<span class="line-modified">!     {</span>
<span class="line-modified">!       entry = &amp;entries-&gt;entry[i];</span>
<span class="line-modified">!       if (entry-&gt;iface_type == iface_type)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           /* this can happen in two cases:</span>
<span class="line-modified">!            * - our parent type already conformed to iface_type and node</span>
<span class="line-modified">!            *   got its own holder info. here, our children already have</span>
<span class="line-modified">!            *   entries and NULL vtables, since this will only work for</span>
<span class="line-modified">!            *   uninitialized classes.</span>
<span class="line-modified">!            * - an interface type is added to an ancestor after it was</span>
<span class="line-modified">!            *   added to a child type.</span>
<span class="line-modified">!            */</span>
<span class="line-modified">!           if (!parent_entry)</span>
<span class="line-modified">!         g_assert (entry-&gt;vtable == NULL &amp;&amp; entry-&gt;init_state == UNINITIALIZED);</span>
<span class="line-modified">!           else</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           /* sick, interface is added to ancestor *after* child type;</span>
<span class="line-modified">!            * nothing todo, the entry and our children were already setup correctly</span>
<span class="line-modified">!            */</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-           return;</span>
<span class="line-removed">-         }</span>
      }
      }
  
    entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (node),
<span class="line-modified">!                   IFACE_ENTRIES_HEADER_SIZE,</span>
<span class="line-modified">!                   sizeof (IFaceEntry));</span>
    num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
    i = num_entries - 1;
    if (i == 0)
      entries-&gt;offset_index = 0;
    entries-&gt;entry[i].iface_type = iface_type;
<span class="line-new-header">--- 1379,38 ---</span>
        num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
  
        g_assert (num_entries &lt; MAX_N_INTERFACES);
  
        for (i = 0; i &lt; num_entries; i++)
<span class="line-modified">!   {</span>
<span class="line-modified">!     entry = &amp;entries-&gt;entry[i];</span>
<span class="line-modified">!     if (entry-&gt;iface_type == iface_type)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         /* this can happen in two cases:</span>
<span class="line-modified">!          * - our parent type already conformed to iface_type and node</span>
<span class="line-modified">!          *   got its own holder info. here, our children already have</span>
<span class="line-modified">!          *   entries and NULL vtables, since this will only work for</span>
<span class="line-modified">!          *   uninitialized classes.</span>
<span class="line-modified">!          * - an interface type is added to an ancestor after it was</span>
<span class="line-modified">!          *   added to a child type.</span>
<span class="line-modified">!          */</span>
<span class="line-modified">!         if (!parent_entry)</span>
<span class="line-modified">!     g_assert (entry-&gt;vtable == NULL &amp;&amp; entry-&gt;init_state == UNINITIALIZED);</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       /* sick, interface is added to ancestor *after* child type;</span>
<span class="line-modified">!        * nothing todo, the entry and our children were already setup correctly</span>
<span class="line-modified">!        */</span>
      }
<span class="line-added">+         return;</span>
<span class="line-added">+       }</span>
<span class="line-added">+   }</span>
      }
  
    entries = _g_atomic_array_copy (CLASSED_NODE_IFACES_ENTRIES (node),
<span class="line-modified">!           IFACE_ENTRIES_HEADER_SIZE,</span>
<span class="line-modified">!           sizeof (IFaceEntry));</span>
    num_entries = IFACE_ENTRIES_N_ENTRIES (entries);
    i = num_entries - 1;
    if (i == 0)
      entries-&gt;offset_index = 0;
    entries-&gt;entry[i].iface_type = iface_type;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1425,28 ***</span>
  
    /* Update offsets in iface */
    iface_node = lookup_type_node_I (iface_type);
  
    if (iface_node_has_available_offset_L (iface_node,
<span class="line-modified">!                      entries-&gt;offset_index,</span>
<span class="line-modified">!                      i))</span>
      {
        iface_node_set_offset_L (iface_node,
<span class="line-modified">!                    entries-&gt;offset_index, i);</span>
      }
    else
     {
        entries-&gt;offset_index =
<span class="line-modified">!     find_free_iface_offset_L (entries);</span>
        for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (entries); j++)
<span class="line-modified">!     {</span>
<span class="line-modified">!       entry = &amp;entries-&gt;entry[j];</span>
<span class="line-modified">!       iface_node =</span>
<span class="line-modified">!         lookup_type_node_I (entry-&gt;iface_type);</span>
<span class="line-modified">!       iface_node_set_offset_L (iface_node,</span>
<span class="line-modified">!                    entries-&gt;offset_index, j);</span>
<span class="line-modified">!     }</span>
      }
  
    _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node), entries);
  
    if (parent_entry)
<span class="line-new-header">--- 1428,28 ---</span>
  
    /* Update offsets in iface */
    iface_node = lookup_type_node_I (iface_type);
  
    if (iface_node_has_available_offset_L (iface_node,
<span class="line-modified">!            entries-&gt;offset_index,</span>
<span class="line-modified">!            i))</span>
      {
        iface_node_set_offset_L (iface_node,
<span class="line-modified">!              entries-&gt;offset_index, i);</span>
      }
    else
     {
        entries-&gt;offset_index =
<span class="line-modified">!   find_free_iface_offset_L (entries);</span>
        for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (entries); j++)
<span class="line-modified">!   {</span>
<span class="line-modified">!     entry = &amp;entries-&gt;entry[j];</span>
<span class="line-modified">!     iface_node =</span>
<span class="line-modified">!       lookup_type_node_I (entry-&gt;iface_type);</span>
<span class="line-modified">!     iface_node_set_offset_L (iface_node,</span>
<span class="line-modified">!            entries-&gt;offset_index, j);</span>
<span class="line-modified">!   }</span>
      }
  
    _g_atomic_array_update (CLASSED_NODE_IFACES_ENTRIES (node), entries);
  
    if (parent_entry)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1497,30 ***</span>
      type_node_add_iface_entry_W (lookup_type_node_I (node-&gt;children[i]), NODE_TYPE (iface), entry);
  }
  
  static void
  type_iface_add_prerequisite_W (TypeNode *iface,
<span class="line-modified">!                    TypeNode *prerequisite_node)</span>
  {
    GType prerequisite_type = NODE_TYPE (prerequisite_node);
    GType *prerequisites, *dependants;
    guint n_dependants, i;
  
    g_assert (NODE_IS_IFACE (iface) &amp;&amp;
<span class="line-modified">!         IFACE_NODE_N_PREREQUISITES (iface) &lt; MAX_N_PREREQUISITES &amp;&amp;</span>
<span class="line-modified">!         (prerequisite_node-&gt;is_instantiatable || NODE_IS_IFACE (prerequisite_node)));</span>
  
    prerequisites = IFACE_NODE_PREREQUISITES (iface);
    for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
      if (prerequisites[i] == prerequisite_type)
<span class="line-modified">!       return;           /* we already have that prerequisiste */</span>
      else if (prerequisites[i] &gt; prerequisite_type)
        break;
    IFACE_NODE_N_PREREQUISITES (iface) += 1;
    IFACE_NODE_PREREQUISITES (iface) = g_renew (GType,
<span class="line-modified">!                           IFACE_NODE_PREREQUISITES (iface),</span>
<span class="line-modified">!                           IFACE_NODE_N_PREREQUISITES (iface));</span>
    prerequisites = IFACE_NODE_PREREQUISITES (iface);
    memmove (prerequisites + i + 1, prerequisites + i,
             sizeof (prerequisites[0]) * (IFACE_NODE_N_PREREQUISITES (iface) - i - 1));
    prerequisites[i] = prerequisite_type;
  
<span class="line-new-header">--- 1500,30 ---</span>
      type_node_add_iface_entry_W (lookup_type_node_I (node-&gt;children[i]), NODE_TYPE (iface), entry);
  }
  
  static void
  type_iface_add_prerequisite_W (TypeNode *iface,
<span class="line-modified">!              TypeNode *prerequisite_node)</span>
  {
    GType prerequisite_type = NODE_TYPE (prerequisite_node);
    GType *prerequisites, *dependants;
    guint n_dependants, i;
  
    g_assert (NODE_IS_IFACE (iface) &amp;&amp;
<span class="line-modified">!       IFACE_NODE_N_PREREQUISITES (iface) &lt; MAX_N_PREREQUISITES &amp;&amp;</span>
<span class="line-modified">!       (prerequisite_node-&gt;is_instantiatable || NODE_IS_IFACE (prerequisite_node)));</span>
  
    prerequisites = IFACE_NODE_PREREQUISITES (iface);
    for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
      if (prerequisites[i] == prerequisite_type)
<span class="line-modified">!       return;     /* we already have that prerequisiste */</span>
      else if (prerequisites[i] &gt; prerequisite_type)
        break;
    IFACE_NODE_N_PREREQUISITES (iface) += 1;
    IFACE_NODE_PREREQUISITES (iface) = g_renew (GType,
<span class="line-modified">!                 IFACE_NODE_PREREQUISITES (iface),</span>
<span class="line-modified">!                 IFACE_NODE_N_PREREQUISITES (iface));</span>
    prerequisites = IFACE_NODE_PREREQUISITES (iface);
    memmove (prerequisites + i + 1, prerequisites + i,
             sizeof (prerequisites[0]) * (IFACE_NODE_N_PREREQUISITES (iface) - i - 1));
    prerequisites[i] = prerequisite_type;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1554,11 ***</span>
   * interface derivation (which GType doesn&#39;t support). An interface can have
   * at most one instantiatable prerequisite type.
   */
  void
  g_type_interface_add_prerequisite (GType interface_type,
<span class="line-modified">!                    GType prerequisite_type)</span>
  {
    TypeNode *iface, *prerequisite_node;
    IFaceHolder *holders;
  
    g_return_if_fail (G_TYPE_IS_INTERFACE (interface_type));  /* G_TYPE_IS_INTERFACE() is an external call: _U */
<span class="line-new-header">--- 1557,11 ---</span>
   * interface derivation (which GType doesn&#39;t support). An interface can have
   * at most one instantiatable prerequisite type.
   */
  void
  g_type_interface_add_prerequisite (GType interface_type,
<span class="line-modified">!            GType prerequisite_type)</span>
  {
    TypeNode *iface, *prerequisite_node;
    IFaceHolder *holders;
  
    g_return_if_fail (G_TYPE_IS_INTERFACE (interface_type));  /* G_TYPE_IS_INTERFACE() is an external call: _U */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1568,66 ***</span>
    iface = lookup_type_node_I (interface_type);
    prerequisite_node = lookup_type_node_I (prerequisite_type);
    if (!iface || !prerequisite_node || !NODE_IS_IFACE (iface))
      {
        g_warning (&quot;interface type &#39;%s&#39; or prerequisite type &#39;%s&#39; invalid&quot;,
<span class="line-modified">!          type_descriptive_name_I (interface_type),</span>
<span class="line-modified">!          type_descriptive_name_I (prerequisite_type));</span>
        return;
      }
    G_WRITE_LOCK (&amp;type_rw_lock);
    holders = iface_node_get_holders_L (iface);
    if (holders)
      {
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_warning (&quot;unable to add prerequisite &#39;%s&#39; to interface &#39;%s&#39; which is already in use for &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (prerequisite_type),</span>
<span class="line-modified">!          type_descriptive_name_I (interface_type),</span>
<span class="line-modified">!          type_descriptive_name_I (holders-&gt;instance_type));</span>
        return;
      }
    if (prerequisite_node-&gt;is_instantiatable)
      {
        guint i;
  
        /* can have at most one publicly installable instantiatable prerequisite */
        for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
<span class="line-modified">!     {</span>
<span class="line-modified">!       TypeNode *prnode = lookup_type_node_I (IFACE_NODE_PREREQUISITES (iface)[i]);</span>
  
<span class="line-modified">!       if (prnode-&gt;is_instantiatable)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           G_WRITE_UNLOCK (&amp;type_rw_lock);</span>
<span class="line-modified">!           g_warning (&quot;adding prerequisite &#39;%s&#39; to interface &#39;%s&#39; conflicts with existing prerequisite &#39;%s&#39;&quot;,</span>
<span class="line-modified">!              type_descriptive_name_I (prerequisite_type),</span>
<span class="line-modified">!              type_descriptive_name_I (interface_type),</span>
<span class="line-modified">!              type_descriptive_name_I (NODE_TYPE (prnode)));</span>
<span class="line-modified">!           return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
  
        for (i = 0; i &lt; prerequisite_node-&gt;n_supers + 1; i++)
<span class="line-modified">!     type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisite_node-&gt;supers[i]));</span>
        G_WRITE_UNLOCK (&amp;type_rw_lock);
      }
    else if (NODE_IS_IFACE (prerequisite_node))
      {
        GType *prerequisites;
        guint i;
  
        prerequisites = IFACE_NODE_PREREQUISITES (prerequisite_node);
        for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (prerequisite_node); i++)
<span class="line-modified">!     type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisites[i]));</span>
        type_iface_add_prerequisite_W (iface, prerequisite_node);
        G_WRITE_UNLOCK (&amp;type_rw_lock);
      }
    else
      {
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_warning (&quot;prerequisite &#39;%s&#39; for interface &#39;%s&#39; is neither instantiatable nor interface&quot;,
<span class="line-modified">!          type_descriptive_name_I (prerequisite_type),</span>
<span class="line-modified">!          type_descriptive_name_I (interface_type));</span>
      }
  }
  
  /**
   * g_type_interface_prerequisites:
<span class="line-new-header">--- 1571,66 ---</span>
    iface = lookup_type_node_I (interface_type);
    prerequisite_node = lookup_type_node_I (prerequisite_type);
    if (!iface || !prerequisite_node || !NODE_IS_IFACE (iface))
      {
        g_warning (&quot;interface type &#39;%s&#39; or prerequisite type &#39;%s&#39; invalid&quot;,
<span class="line-modified">!      type_descriptive_name_I (interface_type),</span>
<span class="line-modified">!      type_descriptive_name_I (prerequisite_type));</span>
        return;
      }
    G_WRITE_LOCK (&amp;type_rw_lock);
    holders = iface_node_get_holders_L (iface);
    if (holders)
      {
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_warning (&quot;unable to add prerequisite &#39;%s&#39; to interface &#39;%s&#39; which is already in use for &#39;%s&#39;&quot;,
<span class="line-modified">!      type_descriptive_name_I (prerequisite_type),</span>
<span class="line-modified">!      type_descriptive_name_I (interface_type),</span>
<span class="line-modified">!      type_descriptive_name_I (holders-&gt;instance_type));</span>
        return;
      }
    if (prerequisite_node-&gt;is_instantiatable)
      {
        guint i;
  
        /* can have at most one publicly installable instantiatable prerequisite */
        for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
<span class="line-modified">!   {</span>
<span class="line-modified">!     TypeNode *prnode = lookup_type_node_I (IFACE_NODE_PREREQUISITES (iface)[i]);</span>
  
<span class="line-modified">!     if (prnode-&gt;is_instantiatable)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         G_WRITE_UNLOCK (&amp;type_rw_lock);</span>
<span class="line-modified">!         g_warning (&quot;adding prerequisite &#39;%s&#39; to interface &#39;%s&#39; conflicts with existing prerequisite &#39;%s&#39;&quot;,</span>
<span class="line-modified">!        type_descriptive_name_I (prerequisite_type),</span>
<span class="line-modified">!        type_descriptive_name_I (interface_type),</span>
<span class="line-modified">!        type_descriptive_name_I (NODE_TYPE (prnode)));</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!   }</span>
  
        for (i = 0; i &lt; prerequisite_node-&gt;n_supers + 1; i++)
<span class="line-modified">!   type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisite_node-&gt;supers[i]));</span>
        G_WRITE_UNLOCK (&amp;type_rw_lock);
      }
    else if (NODE_IS_IFACE (prerequisite_node))
      {
        GType *prerequisites;
        guint i;
  
        prerequisites = IFACE_NODE_PREREQUISITES (prerequisite_node);
        for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (prerequisite_node); i++)
<span class="line-modified">!   type_iface_add_prerequisite_W (iface, lookup_type_node_I (prerequisites[i]));</span>
        type_iface_add_prerequisite_W (iface, prerequisite_node);
        G_WRITE_UNLOCK (&amp;type_rw_lock);
      }
    else
      {
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_warning (&quot;prerequisite &#39;%s&#39; for interface &#39;%s&#39; is neither instantiatable nor interface&quot;,
<span class="line-modified">!      type_descriptive_name_I (prerequisite_type),</span>
<span class="line-modified">!      type_descriptive_name_I (interface_type));</span>
      }
  }
  
  /**
   * g_type_interface_prerequisites:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1643,11 ***</span>
   *     newly-allocated zero-terminated array of #GType containing
   *     the prerequisites of @interface_type
   */
  GType*
  g_type_interface_prerequisites (GType  interface_type,
<span class="line-modified">!                 guint *n_prerequisites)</span>
  {
    TypeNode *iface;
  
    g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);
  
<span class="line-new-header">--- 1646,11 ---</span>
   *     newly-allocated zero-terminated array of #GType containing
   *     the prerequisites of @interface_type
   */
  GType*
  g_type_interface_prerequisites (GType  interface_type,
<span class="line-modified">!         guint *n_prerequisites)</span>
  {
    TypeNode *iface;
  
    g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1659,43 ***</span>
        guint i, n = 0;
  
        G_READ_LOCK (&amp;type_rw_lock);
        types = g_new0 (GType, IFACE_NODE_N_PREREQUISITES (iface) + 1);
        for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
<span class="line-modified">!     {</span>
<span class="line-modified">!       GType prerequisite = IFACE_NODE_PREREQUISITES (iface)[i];</span>
<span class="line-modified">!       TypeNode *node = lookup_type_node_I (prerequisite);</span>
<span class="line-modified">!       if (node-&gt;is_instantiatable)</span>
              {
                if (!inode || type_node_is_a_L (node, inode))
<span class="line-modified">!             inode = node;</span>
              }
<span class="line-modified">!       else</span>
<span class="line-modified">!         types[n++] = NODE_TYPE (node);</span>
<span class="line-modified">!     }</span>
        if (inode)
<span class="line-modified">!     types[n++] = NODE_TYPE (inode);</span>
  
        if (n_prerequisites)
<span class="line-modified">!     *n_prerequisites = n;</span>
        G_READ_UNLOCK (&amp;type_rw_lock);
  
        return types;
      }
    else
      {
        if (n_prerequisites)
<span class="line-modified">!     *n_prerequisites = 0;</span>
  
        return NULL;
      }
  }
  
  
  static IFaceHolder*
  type_iface_peek_holder_L (TypeNode *iface,
<span class="line-modified">!               GType     instance_type)</span>
  {
    IFaceHolder *iholder;
  
    g_assert (NODE_IS_IFACE (iface));
  
<span class="line-new-header">--- 1662,43 ---</span>
        guint i, n = 0;
  
        G_READ_LOCK (&amp;type_rw_lock);
        types = g_new0 (GType, IFACE_NODE_N_PREREQUISITES (iface) + 1);
        for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (iface); i++)
<span class="line-modified">!   {</span>
<span class="line-modified">!     GType prerequisite = IFACE_NODE_PREREQUISITES (iface)[i];</span>
<span class="line-modified">!     TypeNode *node = lookup_type_node_I (prerequisite);</span>
<span class="line-modified">!     if (node-&gt;is_instantiatable)</span>
              {
                if (!inode || type_node_is_a_L (node, inode))
<span class="line-modified">!           inode = node;</span>
              }
<span class="line-modified">!     else</span>
<span class="line-modified">!       types[n++] = NODE_TYPE (node);</span>
<span class="line-modified">!   }</span>
        if (inode)
<span class="line-modified">!   types[n++] = NODE_TYPE (inode);</span>
  
        if (n_prerequisites)
<span class="line-modified">!   *n_prerequisites = n;</span>
        G_READ_UNLOCK (&amp;type_rw_lock);
  
        return types;
      }
    else
      {
        if (n_prerequisites)
<span class="line-modified">!   *n_prerequisites = 0;</span>
  
        return NULL;
      }
  }
  
  
  static IFaceHolder*
  type_iface_peek_holder_L (TypeNode *iface,
<span class="line-modified">!         GType     instance_type)</span>
  {
    IFaceHolder *iholder;
  
    g_assert (NODE_IS_IFACE (iface));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1705,12 ***</span>
    return iholder;
  }
  
  static IFaceHolder*
  type_iface_retrieve_holder_info_Wm (TypeNode *iface,
<span class="line-modified">!                     GType     instance_type,</span>
<span class="line-modified">!                     gboolean  need_info)</span>
  {
    IFaceHolder *iholder = type_iface_peek_holder_L (iface, instance_type);
  
    if (iholder &amp;&amp; !iholder-&gt;info &amp;&amp; need_info)
      {
<span class="line-new-header">--- 1708,12 ---</span>
    return iholder;
  }
  
  static IFaceHolder*
  type_iface_retrieve_holder_info_Wm (TypeNode *iface,
<span class="line-modified">!             GType     instance_type,</span>
<span class="line-modified">!             gboolean  need_info)</span>
  {
    IFaceHolder *iholder = type_iface_peek_holder_L (iface, instance_type);
  
    if (iholder &amp;&amp; !iholder-&gt;info &amp;&amp; need_info)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1718,11 ***</span>
  
        g_assert (iholder-&gt;plugin != NULL);
  
        type_data_ref_Wm (iface);
        if (iholder-&gt;info)
<span class="line-modified">!     INVALID_RECURSION (&quot;g_type_plugin_*&quot;, iface-&gt;plugin, NODE_NAME (iface));</span>
  
        memset (&amp;tmp_info, 0, sizeof (tmp_info));
  
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_type_plugin_use (iholder-&gt;plugin);
<span class="line-new-header">--- 1721,11 ---</span>
  
        g_assert (iholder-&gt;plugin != NULL);
  
        type_data_ref_Wm (iface);
        if (iholder-&gt;info)
<span class="line-modified">!   INVALID_RECURSION (&quot;g_type_plugin_*&quot;, iface-&gt;plugin, NODE_NAME (iface));</span>
  
        memset (&amp;tmp_info, 0, sizeof (tmp_info));
  
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_type_plugin_use (iholder-&gt;plugin);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1733,16 ***</span>
  
        check_interface_info_I (iface, instance_type, &amp;tmp_info);
        iholder-&gt;info = g_memdup (&amp;tmp_info, sizeof (tmp_info));
      }
  
<span class="line-modified">!   return iholder;   /* we don&#39;t modify write lock upon returning NULL */</span>
  }
  
  static void
  type_iface_blow_holder_info_Wm (TypeNode *iface,
<span class="line-modified">!                 GType     instance_type)</span>
  {
    IFaceHolder *iholder = iface_node_get_holders_L (iface);
  
    g_assert (NODE_IS_IFACE (iface));
  
<span class="line-new-header">--- 1736,16 ---</span>
  
        check_interface_info_I (iface, instance_type, &amp;tmp_info);
        iholder-&gt;info = g_memdup (&amp;tmp_info, sizeof (tmp_info));
      }
  
<span class="line-modified">!   return iholder; /* we don&#39;t modify write lock upon returning NULL */</span>
  }
  
  static void
  type_iface_blow_holder_info_Wm (TypeNode *iface,
<span class="line-modified">!         GType     instance_type)</span>
  {
    IFaceHolder *iholder = iface_node_get_holders_L (iface);
  
    g_assert (NODE_IS_IFACE (iface));
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1803,17 ***</span>
  
    node = lookup_type_node_I (type);
    if (!node || !node-&gt;is_instantiatable)
      {
        g_error (&quot;cannot create new instance of invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (type));</span>
      }
    /* G_TYPE_IS_ABSTRACT() is an external call: _U */
    if (!node-&gt;mutatable_check_cache &amp;&amp; G_TYPE_IS_ABSTRACT (type))
      {
        g_error (&quot;cannot create instance of abstract (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (type));</span>
      }
  
    class = g_type_class_ref (type);
  
    /* We allocate the &#39;private&#39; areas before the normal instance data, in
<span class="line-new-header">--- 1806,17 ---</span>
  
    node = lookup_type_node_I (type);
    if (!node || !node-&gt;is_instantiatable)
      {
        g_error (&quot;cannot create new instance of invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">!      type_descriptive_name_I (type));</span>
      }
    /* G_TYPE_IS_ABSTRACT() is an external call: _U */
    if (!node-&gt;mutatable_check_cache &amp;&amp; G_TYPE_IS_ABSTRACT (type))
      {
        g_error (&quot;cannot create instance of abstract (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">!      type_descriptive_name_I (type));</span>
      }
  
    class = g_type_class_ref (type);
  
    /* We allocate the &#39;private&#39; areas before the normal instance data, in
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1860,14 ***</span>
      {
        TypeNode *pnode;
  
        pnode = lookup_type_node_I (node-&gt;supers[i]);
        if (pnode-&gt;data-&gt;instance.instance_init)
<span class="line-modified">!     {</span>
<span class="line-modified">!       instance-&gt;g_class = pnode-&gt;data-&gt;instance.class;</span>
<span class="line-modified">!       pnode-&gt;data-&gt;instance.instance_init (instance, class);</span>
<span class="line-modified">!     }</span>
      }
  
    instance-&gt;g_class = class;
    if (node-&gt;data-&gt;instance.instance_init)
      node-&gt;data-&gt;instance.instance_init (instance, class);
<span class="line-new-header">--- 1863,14 ---</span>
      {
        TypeNode *pnode;
  
        pnode = lookup_type_node_I (node-&gt;supers[i]);
        if (pnode-&gt;data-&gt;instance.instance_init)
<span class="line-modified">!   {</span>
<span class="line-modified">!     instance-&gt;g_class = pnode-&gt;data-&gt;instance.class;</span>
<span class="line-modified">!     pnode-&gt;data-&gt;instance.instance_init (instance, class);</span>
<span class="line-modified">!   }</span>
      }
  
    instance-&gt;g_class = class;
    if (node-&gt;data-&gt;instance.instance_init)
      node-&gt;data-&gt;instance.instance_init (instance, class);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1908,18 ***</span>
    class = instance-&gt;g_class;
    node = lookup_type_node_I (class-&gt;g_type);
    if (!node || !node-&gt;is_instantiatable || !node-&gt;data || node-&gt;data-&gt;class.class != (gpointer) class)
      {
        g_warning (&quot;cannot free instance of invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (class-&gt;g_type));</span>
        return;
      }
    /* G_TYPE_IS_ABSTRACT() is an external call: _U */
    if (!node-&gt;mutatable_check_cache &amp;&amp; G_TYPE_IS_ABSTRACT (NODE_TYPE (node)))
      {
        g_warning (&quot;cannot free instance of abstract (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">!          NODE_NAME (node));</span>
        return;
      }
  
    instance-&gt;g_class = NULL;
    private_size = node-&gt;data-&gt;instance.private_size;
<span class="line-new-header">--- 1911,18 ---</span>
    class = instance-&gt;g_class;
    node = lookup_type_node_I (class-&gt;g_type);
    if (!node || !node-&gt;is_instantiatable || !node-&gt;data || node-&gt;data-&gt;class.class != (gpointer) class)
      {
        g_warning (&quot;cannot free instance of invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">!      type_descriptive_name_I (class-&gt;g_type));</span>
        return;
      }
    /* G_TYPE_IS_ABSTRACT() is an external call: _U */
    if (!node-&gt;mutatable_check_cache &amp;&amp; G_TYPE_IS_ABSTRACT (NODE_TYPE (node)))
      {
        g_warning (&quot;cannot free instance of abstract (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">!      NODE_NAME (node));</span>
        return;
      }
  
    instance-&gt;g_class = NULL;
    private_size = node-&gt;data-&gt;instance.private_size;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1998,21 ***</span>
   * be used. Note that the write lock is not modified upon a FALSE
   * return.
   */
  static gboolean
  type_iface_vtable_base_init_Wm (TypeNode *iface,
<span class="line-modified">!                 TypeNode *node)</span>
  {
    IFaceEntry *entry;
    IFaceHolder *iholder;
    GTypeInterface *vtable = NULL;
    TypeNode *pnode;
  
    /* type_iface_retrieve_holder_info_Wm() doesn&#39;t modify write lock for returning NULL */
    iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), TRUE);
    if (!iholder)
<span class="line-modified">!     return FALSE;   /* we don&#39;t modify write lock upon FALSE */</span>
  
    type_iface_ensure_dflt_vtable_Wm (iface);
  
    entry = type_lookup_iface_entry_L (node, iface);
  #ifdef GSTREAMER_LITE
<span class="line-new-header">--- 2001,21 ---</span>
   * be used. Note that the write lock is not modified upon a FALSE
   * return.
   */
  static gboolean
  type_iface_vtable_base_init_Wm (TypeNode *iface,
<span class="line-modified">!         TypeNode *node)</span>
  {
    IFaceEntry *entry;
    IFaceHolder *iholder;
    GTypeInterface *vtable = NULL;
    TypeNode *pnode;
  
    /* type_iface_retrieve_holder_info_Wm() doesn&#39;t modify write lock for returning NULL */
    iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), TRUE);
    if (!iholder)
<span class="line-modified">!     return FALSE; /* we don&#39;t modify write lock upon FALSE */</span>
  
    type_iface_ensure_dflt_vtable_Wm (iface);
  
    entry = type_lookup_iface_entry_L (node, iface);
  #ifdef GSTREAMER_LITE
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2023,16 ***</span>
    g_assert (iface-&gt;data &amp;&amp; entry &amp;&amp; entry-&gt;vtable == NULL &amp;&amp; iholder &amp;&amp; iholder-&gt;info);
  
    entry-&gt;init_state = IFACE_INIT;
  
    pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
<span class="line-modified">!   if (pnode)    /* want to copy over parent iface contents */</span>
      {
        IFaceEntry *pentry = type_lookup_iface_entry_L (pnode, iface);
  
        if (pentry)
<span class="line-modified">!     vtable = g_memdup (pentry-&gt;vtable, iface-&gt;data-&gt;iface.vtable_size);</span>
      }
    if (!vtable)
      vtable = g_memdup (iface-&gt;data-&gt;iface.dflt_vtable, iface-&gt;data-&gt;iface.vtable_size);
    entry-&gt;vtable = vtable;
    vtable-&gt;g_type = NODE_TYPE (iface);
<span class="line-new-header">--- 2026,16 ---</span>
    g_assert (iface-&gt;data &amp;&amp; entry &amp;&amp; entry-&gt;vtable == NULL &amp;&amp; iholder &amp;&amp; iholder-&gt;info);
  
    entry-&gt;init_state = IFACE_INIT;
  
    pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
<span class="line-modified">!   if (pnode)  /* want to copy over parent iface contents */</span>
      {
        IFaceEntry *pentry = type_lookup_iface_entry_L (pnode, iface);
  
        if (pentry)
<span class="line-modified">!   vtable = g_memdup (pentry-&gt;vtable, iface-&gt;data-&gt;iface.vtable_size);</span>
      }
    if (!vtable)
      vtable = g_memdup (iface-&gt;data-&gt;iface.dflt_vtable, iface-&gt;data-&gt;iface.vtable_size);
    entry-&gt;vtable = vtable;
    vtable-&gt;g_type = NODE_TYPE (iface);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2053,11 ***</span>
   * own interface holder info, i.e. types for which
   * g_type_add_interface*() was called and not children thereof.
   */
  static void
  type_iface_vtable_iface_init_Wm (TypeNode *iface,
<span class="line-modified">!                  TypeNode *node)</span>
  {
    IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
    IFaceHolder *iholder = type_iface_peek_holder_L (iface, NODE_TYPE (node));
    GTypeInterface *vtable = NULL;
    guint i;
<span class="line-new-header">--- 2056,11 ---</span>
   * own interface holder info, i.e. types for which
   * g_type_add_interface*() was called and not children thereof.
   */
  static void
  type_iface_vtable_iface_init_Wm (TypeNode *iface,
<span class="line-modified">!          TypeNode *node)</span>
  {
    IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
    IFaceHolder *iholder = type_iface_peek_holder_L (iface, NODE_TYPE (node));
    GTypeInterface *vtable = NULL;
    guint i;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2076,11 ***</span>
  
    if (iholder-&gt;info-&gt;interface_init)
      {
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        if (iholder-&gt;info-&gt;interface_init)
<span class="line-modified">!     iholder-&gt;info-&gt;interface_init (vtable, iholder-&gt;info-&gt;interface_data);</span>
        G_WRITE_LOCK (&amp;type_rw_lock);
      }
  
    for (i = 0; i &lt; static_n_iface_check_funcs; i++)
      {
<span class="line-new-header">--- 2079,11 ---</span>
  
    if (iholder-&gt;info-&gt;interface_init)
      {
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        if (iholder-&gt;info-&gt;interface_init)
<span class="line-modified">!   iholder-&gt;info-&gt;interface_init (vtable, iholder-&gt;info-&gt;interface_data);</span>
        G_WRITE_LOCK (&amp;type_rw_lock);
      }
  
    for (i = 0; i &lt; static_n_iface_check_funcs; i++)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2093,32 ***</span>
      }
  }
  
  static gboolean
  type_iface_vtable_finalize_Wm (TypeNode       *iface,
<span class="line-modified">!                    TypeNode       *node,</span>
<span class="line-modified">!                    GTypeInterface *vtable)</span>
  {
    IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
    IFaceHolder *iholder;
  
    /* type_iface_retrieve_holder_info_Wm() doesn&#39;t modify write lock for returning NULL */
    iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), FALSE);
    if (!iholder)
<span class="line-modified">!     return FALSE;   /* we don&#39;t modify write lock upon FALSE */</span>
  
    g_assert (entry &amp;&amp; entry-&gt;vtable == vtable &amp;&amp; iholder-&gt;info);
  
    entry-&gt;vtable = NULL;
    entry-&gt;init_state = UNINITIALIZED;
    if (iholder-&gt;info-&gt;interface_finalize || iface-&gt;data-&gt;iface.vtable_finalize_base)
      {
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        if (iholder-&gt;info-&gt;interface_finalize)
<span class="line-modified">!     iholder-&gt;info-&gt;interface_finalize (vtable, iholder-&gt;info-&gt;interface_data);</span>
        if (iface-&gt;data-&gt;iface.vtable_finalize_base)
<span class="line-modified">!     iface-&gt;data-&gt;iface.vtable_finalize_base (vtable);</span>
        G_WRITE_LOCK (&amp;type_rw_lock);
      }
    vtable-&gt;g_type = 0;
    vtable-&gt;g_instance_type = 0;
    g_free (vtable);
<span class="line-new-header">--- 2096,32 ---</span>
      }
  }
  
  static gboolean
  type_iface_vtable_finalize_Wm (TypeNode       *iface,
<span class="line-modified">!              TypeNode       *node,</span>
<span class="line-modified">!              GTypeInterface *vtable)</span>
  {
    IFaceEntry *entry = type_lookup_iface_entry_L (node, iface);
    IFaceHolder *iholder;
  
    /* type_iface_retrieve_holder_info_Wm() doesn&#39;t modify write lock for returning NULL */
    iholder = type_iface_retrieve_holder_info_Wm (iface, NODE_TYPE (node), FALSE);
    if (!iholder)
<span class="line-modified">!     return FALSE; /* we don&#39;t modify write lock upon FALSE */</span>
  
    g_assert (entry &amp;&amp; entry-&gt;vtable == vtable &amp;&amp; iholder-&gt;info);
  
    entry-&gt;vtable = NULL;
    entry-&gt;init_state = UNINITIALIZED;
    if (iholder-&gt;info-&gt;interface_finalize || iface-&gt;data-&gt;iface.vtable_finalize_base)
      {
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        if (iholder-&gt;info-&gt;interface_finalize)
<span class="line-modified">!   iholder-&gt;info-&gt;interface_finalize (vtable, iholder-&gt;info-&gt;interface_data);</span>
        if (iface-&gt;data-&gt;iface.vtable_finalize_base)
<span class="line-modified">!   iface-&gt;data-&gt;iface.vtable_finalize_base (vtable);</span>
        G_WRITE_LOCK (&amp;type_rw_lock);
      }
    vtable-&gt;g_type = 0;
    vtable-&gt;g_instance_type = 0;
    g_free (vtable);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2128,11 ***</span>
    return TRUE;  /* write lock modified */
  }
  
  static void
  type_class_init_Wm (TypeNode   *node,
<span class="line-modified">!             GTypeClass *pclass)</span>
  {
    GSList *slist, *init_slist = NULL;
    GTypeClass *class;
    IFaceEntries *entries;
    IFaceEntry *entry;
<span class="line-new-header">--- 2131,11 ---</span>
    return TRUE;  /* write lock modified */
  }
  
  static void
  type_class_init_Wm (TypeNode   *node,
<span class="line-modified">!         GTypeClass *pclass)</span>
  {
    GSList *slist, *init_slist = NULL;
    GTypeClass *class;
    IFaceEntries *entries;
    IFaceEntry *entry;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2141,13 ***</span>
  
    /* Accessing data-&gt;class will work for instantiable types
     * too because ClassData is a subset of InstanceData
     */
    g_assert (node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp;
<span class="line-modified">!         node-&gt;data-&gt;class.class_size &amp;&amp;</span>
<span class="line-modified">!         !node-&gt;data-&gt;class.class &amp;&amp;</span>
<span class="line-modified">!         node-&gt;data-&gt;class.init_state == UNINITIALIZED);</span>
    if (node-&gt;data-&gt;class.class_private_size)
      class = g_malloc0 (ALIGN_STRUCT (node-&gt;data-&gt;class.class_size) + node-&gt;data-&gt;class.class_private_size);
    else
      class = g_malloc0 (node-&gt;data-&gt;class.class_size);
    node-&gt;data-&gt;class.class = class;
<span class="line-new-header">--- 2144,13 ---</span>
  
    /* Accessing data-&gt;class will work for instantiable types
     * too because ClassData is a subset of InstanceData
     */
    g_assert (node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp;
<span class="line-modified">!       node-&gt;data-&gt;class.class_size &amp;&amp;</span>
<span class="line-modified">!       !node-&gt;data-&gt;class.class &amp;&amp;</span>
<span class="line-modified">!       node-&gt;data-&gt;class.init_state == UNINITIALIZED);</span>
    if (node-&gt;data-&gt;class.class_private_size)
      class = g_malloc0 (ALIGN_STRUCT (node-&gt;data-&gt;class.class_size) + node-&gt;data-&gt;class.class_private_size);
    else
      class = g_malloc0 (node-&gt;data-&gt;class.class_size);
    node-&gt;data-&gt;class.class = class;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2159,17 ***</span>
  
        memcpy (class, pclass, pnode-&gt;data-&gt;class.class_size);
        memcpy (G_STRUCT_MEMBER_P (class, ALIGN_STRUCT (node-&gt;data-&gt;class.class_size)), G_STRUCT_MEMBER_P (pclass, ALIGN_STRUCT (pnode-&gt;data-&gt;class.class_size)), pnode-&gt;data-&gt;class.class_private_size);
  
        if (node-&gt;is_instantiatable)
<span class="line-modified">!     {</span>
<span class="line-modified">!       /* We need to initialize the private_size here rather than in</span>
<span class="line-modified">!        * type_data_make_W() since the class init for the parent</span>
<span class="line-modified">!        * class may have changed pnode-&gt;data-&gt;instance.private_size.</span>
<span class="line-modified">!        */</span>
<span class="line-modified">!       node-&gt;data-&gt;instance.private_size = pnode-&gt;data-&gt;instance.private_size;</span>
<span class="line-modified">!     }</span>
      }
    class-&gt;g_type = NODE_TYPE (node);
  
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  
<span class="line-new-header">--- 2162,17 ---</span>
  
        memcpy (class, pclass, pnode-&gt;data-&gt;class.class_size);
        memcpy (G_STRUCT_MEMBER_P (class, ALIGN_STRUCT (node-&gt;data-&gt;class.class_size)), G_STRUCT_MEMBER_P (pclass, ALIGN_STRUCT (pnode-&gt;data-&gt;class.class_size)), pnode-&gt;data-&gt;class.class_private_size);
  
        if (node-&gt;is_instantiatable)
<span class="line-modified">!   {</span>
<span class="line-modified">!     /* We need to initialize the private_size here rather than in</span>
<span class="line-modified">!      * type_data_make_W() since the class init for the parent</span>
<span class="line-modified">!      * class may have changed pnode-&gt;data-&gt;instance.private_size.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     node-&gt;data-&gt;instance.private_size = pnode-&gt;data-&gt;instance.private_size;</span>
<span class="line-modified">!   }</span>
      }
    class-&gt;g_type = NODE_TYPE (node);
  
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2196,47 ***</span>
     */
    pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
  
    i = 0;
    while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL &amp;&amp;
<span class="line-modified">!       i &lt; IFACE_ENTRIES_N_ENTRIES (entries))</span>
      {
        entry = &amp;entries-&gt;entry[i];
        while (i &lt; IFACE_ENTRIES_N_ENTRIES (entries) &amp;&amp;
<span class="line-modified">!          entry-&gt;init_state == IFACE_INIT)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       entry++;</span>
<span class="line-modified">!       i++;</span>
<span class="line-modified">!     }</span>
  
        if (i == IFACE_ENTRIES_N_ENTRIES (entries))
<span class="line-modified">!     break;</span>
  
        if (!type_iface_vtable_base_init_Wm (lookup_type_node_I (entry-&gt;iface_type), node))
<span class="line-modified">!     {</span>
<span class="line-modified">!       guint j;</span>
<span class="line-modified">!       IFaceEntries *pentries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (pnode);</span>
  
<span class="line-modified">!       /* need to get this interface from parent, type_iface_vtable_base_init_Wm()</span>
<span class="line-modified">!        * doesn&#39;t modify write lock upon FALSE, so entry is still valid;</span>
<span class="line-modified">!        */</span>
<span class="line-modified">!       g_assert (pnode != NULL);</span>
  
<span class="line-modified">!       if (pentries)</span>
<span class="line-modified">!         for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (pentries); j++)</span>
<span class="line-modified">!           {</span>
<span class="line-modified">!         IFaceEntry *pentry = &amp;pentries-&gt;entry[j];</span>
  
<span class="line-modified">!         if (pentry-&gt;iface_type == entry-&gt;iface_type)</span>
<span class="line-modified">!           {</span>
<span class="line-modified">!             entry-&gt;vtable = pentry-&gt;vtable;</span>
<span class="line-modified">!             entry-&gt;init_state = INITIALIZED;</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!           }</span>
<span class="line-modified">!       g_assert (entry-&gt;vtable != NULL);</span>
<span class="line-modified">!     }</span>
  
        /* If the write lock was released, additional interface entries might
         * have been inserted into CLASSED_NODE_IFACES_ENTRIES (node); they&#39;ll
         * be base-initialized when inserted, so we don&#39;t have to worry that
         * we might miss them. Uninitialized entries can only be moved higher
<span class="line-new-header">--- 2199,47 ---</span>
     */
    pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
  
    i = 0;
    while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL &amp;&amp;
<span class="line-modified">!     i &lt; IFACE_ENTRIES_N_ENTRIES (entries))</span>
      {
        entry = &amp;entries-&gt;entry[i];
        while (i &lt; IFACE_ENTRIES_N_ENTRIES (entries) &amp;&amp;
<span class="line-modified">!        entry-&gt;init_state == IFACE_INIT)</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     entry++;</span>
<span class="line-modified">!     i++;</span>
<span class="line-modified">!   }</span>
  
        if (i == IFACE_ENTRIES_N_ENTRIES (entries))
<span class="line-modified">!   break;</span>
  
        if (!type_iface_vtable_base_init_Wm (lookup_type_node_I (entry-&gt;iface_type), node))
<span class="line-modified">!   {</span>
<span class="line-modified">!     guint j;</span>
<span class="line-modified">!     IFaceEntries *pentries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (pnode);</span>
  
<span class="line-modified">!     /* need to get this interface from parent, type_iface_vtable_base_init_Wm()</span>
<span class="line-modified">!      * doesn&#39;t modify write lock upon FALSE, so entry is still valid;</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     g_assert (pnode != NULL);</span>
  
<span class="line-modified">!     if (pentries)</span>
<span class="line-modified">!       for (j = 0; j &lt; IFACE_ENTRIES_N_ENTRIES (pentries); j++)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!     IFaceEntry *pentry = &amp;pentries-&gt;entry[j];</span>
  
<span class="line-modified">!     if (pentry-&gt;iface_type == entry-&gt;iface_type)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         entry-&gt;vtable = pentry-&gt;vtable;</span>
<span class="line-modified">!         entry-&gt;init_state = INITIALIZED;</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     g_assert (entry-&gt;vtable != NULL);</span>
<span class="line-modified">!   }</span>
  
        /* If the write lock was released, additional interface entries might
         * have been inserted into CLASSED_NODE_IFACES_ENTRIES (node); they&#39;ll
         * be base-initialized when inserted, so we don&#39;t have to worry that
         * we might miss them. Uninitialized entries can only be moved higher
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2265,18 ***</span>
    i = 0;
    while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL)
      {
        entry = &amp;entries-&gt;entry[i];
        while (i &lt; IFACE_ENTRIES_N_ENTRIES (entries) &amp;&amp;
<span class="line-modified">!          entry-&gt;init_state == INITIALIZED)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       entry++;</span>
<span class="line-modified">!       i++;</span>
<span class="line-modified">!     }</span>
  
        if (i == IFACE_ENTRIES_N_ENTRIES (entries))
<span class="line-modified">!     break;</span>
  
        type_iface_vtable_iface_init_Wm (lookup_type_node_I (entry-&gt;iface_type), node);
  
        /* As in the loop above, additional initialized entries might be inserted
         * if the write lock is released, but that&#39;s harmless because the entries
<span class="line-new-header">--- 2268,18 ---</span>
    i = 0;
    while ((entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node)) != NULL)
      {
        entry = &amp;entries-&gt;entry[i];
        while (i &lt; IFACE_ENTRIES_N_ENTRIES (entries) &amp;&amp;
<span class="line-modified">!        entry-&gt;init_state == INITIALIZED)</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     entry++;</span>
<span class="line-modified">!     i++;</span>
<span class="line-modified">!   }</span>
  
        if (i == IFACE_ENTRIES_N_ENTRIES (entries))
<span class="line-modified">!   break;</span>
  
        type_iface_vtable_iface_init_Wm (lookup_type_node_I (entry-&gt;iface_type), node);
  
        /* As in the loop above, additional initialized entries might be inserted
         * if the write lock is released, but that&#39;s harmless because the entries
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2300,11 ***</span>
    entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
    for (i = 0; entries != NULL &amp;&amp; i &lt; IFACE_ENTRIES_N_ENTRIES (entries); i++)
      {
        IFaceEntry *entry = &amp;entries-&gt;entry[i];
        if (entry-&gt;vtable)
<span class="line-modified">!     {</span>
            if (type_iface_vtable_finalize_Wm (lookup_type_node_I (entry-&gt;iface_type), node, entry-&gt;vtable))
              {
                /* refetch entries, IFACES_ENTRIES might be modified */
                goto reiterate;
              }
<span class="line-new-header">--- 2303,11 ---</span>
    entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
    for (i = 0; entries != NULL &amp;&amp; i &lt; IFACE_ENTRIES_N_ENTRIES (entries); i++)
      {
        IFaceEntry *entry = &amp;entries-&gt;entry[i];
        if (entry-&gt;vtable)
<span class="line-modified">!   {</span>
            if (type_iface_vtable_finalize_Wm (lookup_type_node_I (entry-&gt;iface_type), node, entry-&gt;vtable))
              {
                /* refetch entries, IFACES_ENTRIES might be modified */
                goto reiterate;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2314,17 ***</span>
                 * iface vtable came from parent
                 */
                entry-&gt;vtable = NULL;
                entry-&gt;init_state = UNINITIALIZED;
              }
<span class="line-modified">!     }</span>
      }
  }
  
  static void
  type_data_finalize_class_U (TypeNode  *node,
<span class="line-modified">!                 ClassData *cdata)</span>
  {
    GTypeClass *class = cdata-&gt;class;
    TypeNode *bnode;
  
    g_assert (cdata-&gt;class &amp;&amp; NODE_REFCOUNT (node) == 0);
<span class="line-new-header">--- 2317,17 ---</span>
                 * iface vtable came from parent
                 */
                entry-&gt;vtable = NULL;
                entry-&gt;init_state = UNINITIALIZED;
              }
<span class="line-modified">!   }</span>
      }
  }
  
  static void
  type_data_finalize_class_U (TypeNode  *node,
<span class="line-modified">!           ClassData *cdata)</span>
  {
    GTypeClass *class = cdata-&gt;class;
    TypeNode *bnode;
  
    g_assert (cdata-&gt;class &amp;&amp; NODE_REFCOUNT (node) == 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2343,18 ***</span>
    g_free (cdata-&gt;class);
  }
  
  static void
  type_data_last_unref_Wm (TypeNode *node,
<span class="line-modified">!              gboolean  uncached)</span>
  {
    g_return_if_fail (node != NULL &amp;&amp; node-&gt;plugin != NULL);
  
    if (!node-&gt;data || NODE_REFCOUNT (node) == 0)
      {
        g_warning (&quot;cannot drop last reference to unreferenced type &#39;%s&#39;&quot;,
<span class="line-modified">!          NODE_NAME (node));</span>
        return;
      }
  
    /* call class cache hooks */
    if (node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class &amp;&amp; static_n_class_cache_funcs &amp;&amp; !uncached)
<span class="line-new-header">--- 2346,18 ---</span>
    g_free (cdata-&gt;class);
  }
  
  static void
  type_data_last_unref_Wm (TypeNode *node,
<span class="line-modified">!        gboolean  uncached)</span>
  {
    g_return_if_fail (node != NULL &amp;&amp; node-&gt;plugin != NULL);
  
    if (!node-&gt;data || NODE_REFCOUNT (node) == 0)
      {
        g_warning (&quot;cannot drop last reference to unreferenced type &#39;%s&#39;&quot;,
<span class="line-modified">!      NODE_NAME (node));</span>
        return;
      }
  
    /* call class cache hooks */
    if (node-&gt;is_classed &amp;&amp; node-&gt;data &amp;&amp; node-&gt;data-&gt;class.class &amp;&amp; static_n_class_cache_funcs &amp;&amp; !uncached)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2362,23 ***</span>
        guint i;
  
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        G_READ_LOCK (&amp;type_rw_lock);
        for (i = 0; i &lt; static_n_class_cache_funcs; i++)
<span class="line-modified">!     {</span>
<span class="line-modified">!       GTypeClassCacheFunc cache_func = static_class_cache_funcs[i].cache_func;</span>
<span class="line-modified">!       gpointer cache_data = static_class_cache_funcs[i].cache_data;</span>
<span class="line-modified">!       gboolean need_break;</span>
  
<span class="line-modified">!       G_READ_UNLOCK (&amp;type_rw_lock);</span>
<span class="line-modified">!       need_break = cache_func (cache_data, node-&gt;data-&gt;class.class);</span>
<span class="line-modified">!       G_READ_LOCK (&amp;type_rw_lock);</span>
<span class="line-modified">!       if (!node-&gt;data || NODE_REFCOUNT (node) == 0)</span>
<span class="line-modified">!         INVALID_RECURSION (&quot;GType class cache function &quot;, cache_func, NODE_NAME (node));</span>
<span class="line-modified">!       if (need_break)</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     }</span>
        G_READ_UNLOCK (&amp;type_rw_lock);
        G_WRITE_LOCK (&amp;type_rw_lock);
      }
  
    /* may have been re-referenced meanwhile */
<span class="line-new-header">--- 2365,23 ---</span>
        guint i;
  
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        G_READ_LOCK (&amp;type_rw_lock);
        for (i = 0; i &lt; static_n_class_cache_funcs; i++)
<span class="line-modified">!   {</span>
<span class="line-modified">!     GTypeClassCacheFunc cache_func = static_class_cache_funcs[i].cache_func;</span>
<span class="line-modified">!     gpointer cache_data = static_class_cache_funcs[i].cache_data;</span>
<span class="line-modified">!     gboolean need_break;</span>
  
<span class="line-modified">!     G_READ_UNLOCK (&amp;type_rw_lock);</span>
<span class="line-modified">!     need_break = cache_func (cache_data, node-&gt;data-&gt;class.class);</span>
<span class="line-modified">!     G_READ_LOCK (&amp;type_rw_lock);</span>
<span class="line-modified">!     if (!node-&gt;data || NODE_REFCOUNT (node) == 0)</span>
<span class="line-modified">!       INVALID_RECURSION (&quot;GType class cache function &quot;, cache_func, NODE_NAME (node));</span>
<span class="line-modified">!     if (need_break)</span>
<span class="line-modified">!       break;</span>
<span class="line-modified">!   }</span>
        G_READ_UNLOCK (&amp;type_rw_lock);
        G_WRITE_LOCK (&amp;type_rw_lock);
      }
  
    /* may have been re-referenced meanwhile */
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2386,25 ***</span>
      {
        GType ptype = NODE_PARENT_TYPE (node);
        TypeData *tdata;
  
        if (node-&gt;is_instantiatable)
<span class="line-modified">!     {</span>
<span class="line-modified">!       /* destroy node-&gt;data-&gt;instance.mem_chunk */</span>
<span class="line-modified">!     }</span>
  
        tdata = node-&gt;data;
        if (node-&gt;is_classed &amp;&amp; tdata-&gt;class.class)
<span class="line-modified">!     {</span>
<span class="line-modified">!       if (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node) != NULL)</span>
<span class="line-modified">!         type_data_finalize_class_ifaces_Wm (node);</span>
<span class="line-modified">!       node-&gt;mutatable_check_cache = FALSE;</span>
<span class="line-modified">!       node-&gt;data = NULL;</span>
<span class="line-modified">!       G_WRITE_UNLOCK (&amp;type_rw_lock);</span>
<span class="line-modified">!       type_data_finalize_class_U (node, &amp;tdata-&gt;class);</span>
<span class="line-modified">!       G_WRITE_LOCK (&amp;type_rw_lock);</span>
<span class="line-modified">!     }</span>
        else if (NODE_IS_IFACE (node) &amp;&amp; tdata-&gt;iface.dflt_vtable)
          {
            node-&gt;mutatable_check_cache = FALSE;
            node-&gt;data = NULL;
            if (tdata-&gt;iface.dflt_finalize || tdata-&gt;iface.vtable_finalize_base)
<span class="line-new-header">--- 2389,25 ---</span>
      {
        GType ptype = NODE_PARENT_TYPE (node);
        TypeData *tdata;
  
        if (node-&gt;is_instantiatable)
<span class="line-modified">!   {</span>
<span class="line-modified">!     /* destroy node-&gt;data-&gt;instance.mem_chunk */</span>
<span class="line-modified">!   }</span>
  
        tdata = node-&gt;data;
        if (node-&gt;is_classed &amp;&amp; tdata-&gt;class.class)
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (CLASSED_NODE_IFACES_ENTRIES_LOCKED (node) != NULL)</span>
<span class="line-modified">!       type_data_finalize_class_ifaces_Wm (node);</span>
<span class="line-modified">!     node-&gt;mutatable_check_cache = FALSE;</span>
<span class="line-modified">!     node-&gt;data = NULL;</span>
<span class="line-modified">!     G_WRITE_UNLOCK (&amp;type_rw_lock);</span>
<span class="line-modified">!     type_data_finalize_class_U (node, &amp;tdata-&gt;class);</span>
<span class="line-modified">!     G_WRITE_LOCK (&amp;type_rw_lock);</span>
<span class="line-modified">!   }</span>
        else if (NODE_IS_IFACE (node) &amp;&amp; tdata-&gt;iface.dflt_vtable)
          {
            node-&gt;mutatable_check_cache = FALSE;
            node-&gt;data = NULL;
            if (tdata-&gt;iface.dflt_finalize || tdata-&gt;iface.vtable_finalize_base)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2430,11 ***</span>
        g_free (tdata);
  
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_type_plugin_unuse (node-&gt;plugin);
        if (ptype)
<span class="line-modified">!     type_data_unref_U (lookup_type_node_I (ptype), FALSE);</span>
        G_WRITE_LOCK (&amp;type_rw_lock);
      }
  }
  
  static inline void
<span class="line-new-header">--- 2433,11 ---</span>
        g_free (tdata);
  
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_type_plugin_unuse (node-&gt;plugin);
        if (ptype)
<span class="line-modified">!   type_data_unref_U (lookup_type_node_I (ptype), FALSE);</span>
        G_WRITE_LOCK (&amp;type_rw_lock);
      }
  }
  
  static inline void
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2447,15 ***</span>
      current = NODE_REFCOUNT (node);
  
      if (current &lt;= 1)
      {
        if (!node-&gt;plugin)
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;static type &#39;%s&#39; unreferenced too often&quot;,</span>
<span class="line-modified">!              NODE_NAME (node));</span>
<span class="line-modified">!       return;</span>
<span class="line-modified">!     }</span>
        else
          {
            /* This is the last reference of a type from a plugin.  We are
             * experimentally disabling support for unloading type
             * plugins, so don&#39;t allow the last ref to drop.
<span class="line-new-header">--- 2450,15 ---</span>
      current = NODE_REFCOUNT (node);
  
      if (current &lt;= 1)
      {
        if (!node-&gt;plugin)
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;static type &#39;%s&#39; unreferenced too often&quot;,</span>
<span class="line-modified">!          NODE_NAME (node));</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
        else
          {
            /* This is the last reference of a type from a plugin.  We are
             * experimentally disabling support for unloading type
             * plugins, so don&#39;t allow the last ref to drop.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2488,11 ***</span>
   * type, since all classes are routed through the same #GTypeClassCacheFunc
   * chain.
   */
  void
  g_type_add_class_cache_func (gpointer            cache_data,
<span class="line-modified">!                  GTypeClassCacheFunc cache_func)</span>
  {
    guint i;
  
    g_return_if_fail (cache_func != NULL);
  
<span class="line-new-header">--- 2491,11 ---</span>
   * type, since all classes are routed through the same #GTypeClassCacheFunc
   * chain.
   */
  void
  g_type_add_class_cache_func (gpointer            cache_data,
<span class="line-modified">!            GTypeClassCacheFunc cache_func)</span>
  {
    guint i;
  
    g_return_if_fail (cache_func != NULL);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2513,35 ***</span>
   * maintained by @cache_func has to be empty when calling
   * g_type_remove_class_cache_func() to avoid leaks.
   */
  void
  g_type_remove_class_cache_func (gpointer            cache_data,
<span class="line-modified">!                 GTypeClassCacheFunc cache_func)</span>
  {
    gboolean found_it = FALSE;
    guint i;
  
    g_return_if_fail (cache_func != NULL);
  
    G_WRITE_LOCK (&amp;type_rw_lock);
    for (i = 0; i &lt; static_n_class_cache_funcs; i++)
      if (static_class_cache_funcs[i].cache_data == cache_data &amp;&amp;
<span class="line-modified">!     static_class_cache_funcs[i].cache_func == cache_func)</span>
        {
<span class="line-modified">!     static_n_class_cache_funcs--;</span>
<span class="line-modified">!     memmove (static_class_cache_funcs + i,</span>
                   static_class_cache_funcs + i + 1,
                   sizeof (static_class_cache_funcs[0]) * (static_n_class_cache_funcs - i));
<span class="line-modified">!     static_class_cache_funcs = g_renew (ClassCacheFunc, static_class_cache_funcs, static_n_class_cache_funcs);</span>
<span class="line-modified">!     found_it = TRUE;</span>
<span class="line-modified">!     break;</span>
        }
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  
    if (!found_it)
      g_warning (G_STRLOC &quot;: cannot remove unregistered class cache func %p with data %p&quot;,
<span class="line-modified">!            cache_func, cache_data);</span>
  }
  
  
  /**
   * g_type_add_interface_check: (skip)
<span class="line-new-header">--- 2516,35 ---</span>
   * maintained by @cache_func has to be empty when calling
   * g_type_remove_class_cache_func() to avoid leaks.
   */
  void
  g_type_remove_class_cache_func (gpointer            cache_data,
<span class="line-modified">!         GTypeClassCacheFunc cache_func)</span>
  {
    gboolean found_it = FALSE;
    guint i;
  
    g_return_if_fail (cache_func != NULL);
  
    G_WRITE_LOCK (&amp;type_rw_lock);
    for (i = 0; i &lt; static_n_class_cache_funcs; i++)
      if (static_class_cache_funcs[i].cache_data == cache_data &amp;&amp;
<span class="line-modified">!   static_class_cache_funcs[i].cache_func == cache_func)</span>
        {
<span class="line-modified">!   static_n_class_cache_funcs--;</span>
<span class="line-modified">!   memmove (static_class_cache_funcs + i,</span>
                   static_class_cache_funcs + i + 1,
                   sizeof (static_class_cache_funcs[0]) * (static_n_class_cache_funcs - i));
<span class="line-modified">!   static_class_cache_funcs = g_renew (ClassCacheFunc, static_class_cache_funcs, static_n_class_cache_funcs);</span>
<span class="line-modified">!   found_it = TRUE;</span>
<span class="line-modified">!   break;</span>
        }
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  
    if (!found_it)
      g_warning (G_STRLOC &quot;: cannot remove unregistered class cache func %p with data %p&quot;,
<span class="line-modified">!          cache_func, cache_data);</span>
  }
  
  
  /**
   * g_type_add_interface_check: (skip)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2560,12 ***</span>
   * interfaces.
   *
   * Since: 2.4
   */
  void
<span class="line-modified">! g_type_add_interface_check (gpointer                check_data,</span>
<span class="line-modified">!                             GTypeInterfaceCheckFunc check_func)</span>
  {
    guint i;
  
    g_return_if_fail (check_func != NULL);
  
<span class="line-new-header">--- 2563,12 ---</span>
   * interfaces.
   *
   * Since: 2.4
   */
  void
<span class="line-modified">! g_type_add_interface_check (gpointer              check_data,</span>
<span class="line-modified">!           GTypeInterfaceCheckFunc check_func)</span>
  {
    guint i;
  
    g_return_if_fail (check_func != NULL);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2587,35 ***</span>
   *
   * Since: 2.4
   */
  void
  g_type_remove_interface_check (gpointer                check_data,
<span class="line-modified">!                                GTypeInterfaceCheckFunc check_func)</span>
  {
    gboolean found_it = FALSE;
    guint i;
  
    g_return_if_fail (check_func != NULL);
  
    G_WRITE_LOCK (&amp;type_rw_lock);
    for (i = 0; i &lt; static_n_iface_check_funcs; i++)
      if (static_iface_check_funcs[i].check_data == check_data &amp;&amp;
<span class="line-modified">!     static_iface_check_funcs[i].check_func == check_func)</span>
        {
<span class="line-modified">!     static_n_iface_check_funcs--;</span>
<span class="line-modified">!     memmove (static_iface_check_funcs + i,</span>
                   static_iface_check_funcs + i + 1,
                   sizeof (static_iface_check_funcs[0]) * (static_n_iface_check_funcs - i));
<span class="line-modified">!     static_iface_check_funcs = g_renew (IFaceCheckFunc, static_iface_check_funcs, static_n_iface_check_funcs);</span>
<span class="line-modified">!     found_it = TRUE;</span>
<span class="line-modified">!     break;</span>
        }
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  
    if (!found_it)
      g_warning (G_STRLOC &quot;: cannot remove unregistered class check func %p with data %p&quot;,
<span class="line-modified">!            check_func, check_data);</span>
  }
  
  /* --- type registration --- */
  /**
   * g_type_register_fundamental:
<span class="line-new-header">--- 2590,35 ---</span>
   *
   * Since: 2.4
   */
  void
  g_type_remove_interface_check (gpointer                check_data,
<span class="line-modified">!              GTypeInterfaceCheckFunc check_func)</span>
  {
    gboolean found_it = FALSE;
    guint i;
  
    g_return_if_fail (check_func != NULL);
  
    G_WRITE_LOCK (&amp;type_rw_lock);
    for (i = 0; i &lt; static_n_iface_check_funcs; i++)
      if (static_iface_check_funcs[i].check_data == check_data &amp;&amp;
<span class="line-modified">!   static_iface_check_funcs[i].check_func == check_func)</span>
        {
<span class="line-modified">!   static_n_iface_check_funcs--;</span>
<span class="line-modified">!   memmove (static_iface_check_funcs + i,</span>
                   static_iface_check_funcs + i + 1,
                   sizeof (static_iface_check_funcs[0]) * (static_n_iface_check_funcs - i));
<span class="line-modified">!   static_iface_check_funcs = g_renew (IFaceCheckFunc, static_iface_check_funcs, static_n_iface_check_funcs);</span>
<span class="line-modified">!   found_it = TRUE;</span>
<span class="line-modified">!   break;</span>
        }
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  
    if (!found_it)
      g_warning (G_STRLOC &quot;: cannot remove unregistered class check func %p with data %p&quot;,
<span class="line-modified">!          check_func, check_data);</span>
  }
  
  /* --- type registration --- */
  /**
   * g_type_register_fundamental:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2635,14 ***</span>
   *
   * Returns: the predefined type identifier
   */
  GType
  g_type_register_fundamental (GType                       type_id,
<span class="line-modified">!                              const gchar                *type_name,</span>
<span class="line-modified">!                              const GTypeInfo            *info,</span>
<span class="line-modified">!                              const GTypeFundamentalInfo *finfo,</span>
<span class="line-modified">!                  GTypeFlags          flags)</span>
  {
    TypeNode *node;
  
    g_assert_type_system_initialized ();
    g_return_val_if_fail (type_id &gt; 0, 0);
<span class="line-new-header">--- 2638,14 ---</span>
   *
   * Returns: the predefined type identifier
   */
  GType
  g_type_register_fundamental (GType                       type_id,
<span class="line-modified">!            const gchar                *type_name,</span>
<span class="line-modified">!            const GTypeInfo            *info,</span>
<span class="line-modified">!            const GTypeFundamentalInfo *finfo,</span>
<span class="line-modified">!            GTypeFlags      flags)</span>
  {
    TypeNode *node;
  
    g_assert_type_system_initialized ();
    g_return_val_if_fail (type_id &gt; 0, 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2654,36 ***</span>
      return 0;
    if ((type_id &amp; TYPE_ID_MASK) ||
        type_id &gt; G_TYPE_FUNDAMENTAL_MAX)
      {
        g_warning (&quot;attempt to register fundamental type &#39;%s&#39; with invalid type id (%&quot; G_GSIZE_FORMAT &quot;)&quot;,
<span class="line-modified">!          type_name,</span>
<span class="line-modified">!          type_id);</span>
        return 0;
      }
    if ((finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) &amp;&amp;
        !(finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED))
      {
        g_warning (&quot;cannot register instantiatable fundamental type &#39;%s&#39; as non-classed&quot;,
<span class="line-modified">!          type_name);</span>
        return 0;
      }
    if (lookup_type_node_I (type_id))
      {
        g_warning (&quot;cannot register existing fundamental type &#39;%s&#39; (as &#39;%s&#39;)&quot;,
<span class="line-modified">!          type_descriptive_name_I (type_id),</span>
<span class="line-modified">!          type_name);</span>
        return 0;
      }
  
    G_WRITE_LOCK (&amp;type_rw_lock);
    node = type_node_fundamental_new_W (type_id, type_name, finfo-&gt;type_flags);
    type_add_flags_W (node, flags);
  
    if (check_type_info_I (NULL, NODE_FUNDAMENTAL_TYPE (node), type_name, info))
      type_data_make_W (node, info,
<span class="line-modified">!               check_value_table_I (type_name, info-&gt;value_table) ? info-&gt;value_table : NULL);</span>
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  
    return NODE_TYPE (node);
  }
  
<span class="line-new-header">--- 2657,36 ---</span>
      return 0;
    if ((type_id &amp; TYPE_ID_MASK) ||
        type_id &gt; G_TYPE_FUNDAMENTAL_MAX)
      {
        g_warning (&quot;attempt to register fundamental type &#39;%s&#39; with invalid type id (%&quot; G_GSIZE_FORMAT &quot;)&quot;,
<span class="line-modified">!      type_name,</span>
<span class="line-modified">!      type_id);</span>
        return 0;
      }
    if ((finfo-&gt;type_flags &amp; G_TYPE_FLAG_INSTANTIATABLE) &amp;&amp;
        !(finfo-&gt;type_flags &amp; G_TYPE_FLAG_CLASSED))
      {
        g_warning (&quot;cannot register instantiatable fundamental type &#39;%s&#39; as non-classed&quot;,
<span class="line-modified">!      type_name);</span>
        return 0;
      }
    if (lookup_type_node_I (type_id))
      {
        g_warning (&quot;cannot register existing fundamental type &#39;%s&#39; (as &#39;%s&#39;)&quot;,
<span class="line-modified">!      type_descriptive_name_I (type_id),</span>
<span class="line-modified">!      type_name);</span>
        return 0;
      }
  
    G_WRITE_LOCK (&amp;type_rw_lock);
    node = type_node_fundamental_new_W (type_id, type_name, finfo-&gt;type_flags);
    type_add_flags_W (node, flags);
  
    if (check_type_info_I (NULL, NODE_FUNDAMENTAL_TYPE (node), type_name, info))
      type_data_make_W (node, info,
<span class="line-modified">!           check_value_table_I (type_name, info-&gt;value_table) ? info-&gt;value_table : NULL);</span>
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  
    return NODE_TYPE (node);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2706,16 ***</span>
   *
   * Returns: the new type identifier
   */
  GType
  g_type_register_static_simple (GType             parent_type,
<span class="line-modified">!                                const gchar      *type_name,</span>
<span class="line-modified">!                                guint             class_size,</span>
<span class="line-modified">!                                GClassInitFunc    class_init,</span>
<span class="line-modified">!                                guint             instance_size,</span>
<span class="line-modified">!                                GInstanceInitFunc instance_init,</span>
<span class="line-modified">!                    GTypeFlags    flags)</span>
  {
    GTypeInfo info;
  
    /* Instances are not allowed to be larger than this. If you have a big
     * fixed-length array or something, point to it instead.
<span class="line-new-header">--- 2709,16 ---</span>
   *
   * Returns: the new type identifier
   */
  GType
  g_type_register_static_simple (GType             parent_type,
<span class="line-modified">!              const gchar      *type_name,</span>
<span class="line-modified">!              guint             class_size,</span>
<span class="line-modified">!              GClassInitFunc    class_init,</span>
<span class="line-modified">!              guint             instance_size,</span>
<span class="line-modified">!              GInstanceInitFunc instance_init,</span>
<span class="line-modified">!              GTypeFlags  flags)</span>
  {
    GTypeInfo info;
  
    /* Instances are not allowed to be larger than this. If you have a big
     * fixed-length array or something, point to it instead.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2752,13 ***</span>
   *
   * Returns: the new type identifier
   */
  GType
  g_type_register_static (GType            parent_type,
<span class="line-modified">!                         const gchar     *type_name,</span>
<span class="line-modified">!                         const GTypeInfo *info,</span>
<span class="line-modified">!             GTypeFlags   flags)</span>
  {
    TypeNode *pnode, *node;
    GType type = 0;
  
    g_assert_type_system_initialized ();
<span class="line-new-header">--- 2755,13 ---</span>
   *
   * Returns: the new type identifier
   */
  GType
  g_type_register_static (GType            parent_type,
<span class="line-modified">!       const gchar     *type_name,</span>
<span class="line-modified">!       const GTypeInfo *info,</span>
<span class="line-modified">!       GTypeFlags   flags)</span>
  {
    TypeNode *pnode, *node;
    GType type = 0;
  
    g_assert_type_system_initialized ();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2770,11 ***</span>
        !check_derivation_I (parent_type, type_name))
      return 0;
    if (info-&gt;class_finalize)
      {
        g_warning (&quot;class finalizer specified for static type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_name);</span>
        return 0;
      }
  
    pnode = lookup_type_node_I (parent_type);
    G_WRITE_LOCK (&amp;type_rw_lock);
<span class="line-new-header">--- 2773,11 ---</span>
        !check_derivation_I (parent_type, type_name))
      return 0;
    if (info-&gt;class_finalize)
      {
        g_warning (&quot;class finalizer specified for static type &#39;%s&#39;&quot;,
<span class="line-modified">!      type_name);</span>
        return 0;
      }
  
    pnode = lookup_type_node_I (parent_type);
    G_WRITE_LOCK (&amp;type_rw_lock);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2783,11 ***</span>
      {
        node = type_node_new_W (pnode, type_name, NULL);
        type_add_flags_W (node, flags);
        type = NODE_TYPE (node);
        type_data_make_W (node, info,
<span class="line-modified">!             check_value_table_I (type_name, info-&gt;value_table) ? info-&gt;value_table : NULL);</span>
      }
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  
    return type;
  }
<span class="line-new-header">--- 2786,11 ---</span>
      {
        node = type_node_new_W (pnode, type_name, NULL);
        type_add_flags_W (node, flags);
        type = NODE_TYPE (node);
        type_data_make_W (node, info,
<span class="line-modified">!       check_value_table_I (type_name, info-&gt;value_table) ? info-&gt;value_table : NULL);</span>
      }
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  
    return type;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2807,13 ***</span>
   *
   * Returns: the new type identifier or #G_TYPE_INVALID if registration failed
   */
  GType
  g_type_register_dynamic (GType        parent_type,
<span class="line-modified">!              const gchar *type_name,</span>
<span class="line-modified">!              GTypePlugin *plugin,</span>
<span class="line-modified">!              GTypeFlags   flags)</span>
  {
    TypeNode *pnode, *node;
    GType type;
  
    g_assert_type_system_initialized ();
<span class="line-new-header">--- 2810,13 ---</span>
   *
   * Returns: the new type identifier or #G_TYPE_INVALID if registration failed
   */
  GType
  g_type_register_dynamic (GType        parent_type,
<span class="line-modified">!        const gchar *type_name,</span>
<span class="line-modified">!        GTypePlugin *plugin,</span>
<span class="line-modified">!        GTypeFlags   flags)</span>
  {
    TypeNode *pnode, *node;
    GType type;
  
    g_assert_type_system_initialized ();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2847,12 ***</span>
   * The information contained in the #GInterfaceInfo structure
   * pointed to by @info is used to manage the relationship.
   */
  void
  g_type_add_interface_static (GType                 instance_type,
<span class="line-modified">!                  GType                 interface_type,</span>
<span class="line-modified">!                  const GInterfaceInfo *info)</span>
  {
    /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
    g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
    g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
  
<span class="line-new-header">--- 2850,12 ---</span>
   * The information contained in the #GInterfaceInfo structure
   * pointed to by @info is used to manage the relationship.
   */
  void
  g_type_add_interface_static (GType                 instance_type,
<span class="line-modified">!            GType                 interface_type,</span>
<span class="line-modified">!            const GInterfaceInfo *info)</span>
  {
    /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
    g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
    g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2883,12 ***</span>
   * contained in the #GTypePlugin structure pointed to by @plugin
   * is used to manage the relationship.
   */
  void
  g_type_add_interface_dynamic (GType        instance_type,
<span class="line-modified">!                   GType        interface_type,</span>
<span class="line-modified">!                   GTypePlugin *plugin)</span>
  {
    TypeNode *node;
    /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
    g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
    g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
<span class="line-new-header">--- 2886,12 ---</span>
   * contained in the #GTypePlugin structure pointed to by @plugin
   * is used to manage the relationship.
   */
  void
  g_type_add_interface_dynamic (GType        instance_type,
<span class="line-modified">!             GType        interface_type,</span>
<span class="line-modified">!             GTypePlugin *plugin)</span>
  {
    TypeNode *node;
    /* G_TYPE_IS_INSTANTIATABLE() is an external call: _U */
    g_return_if_fail (G_TYPE_IS_INSTANTIATABLE (instance_type));
    g_return_if_fail (g_type_parent (interface_type) == G_TYPE_INTERFACE);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2933,11 ***</span>
    /* optimize for common code path */
    node = lookup_type_node_I (type);
    if (!node || !node-&gt;is_classed)
      {
        g_warning (&quot;cannot retrieve class for invalid (unclassed) type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (type));</span>
        return NULL;
      }
  
    if (G_LIKELY (type_data_ref_U (node)))
      {
<span class="line-new-header">--- 2936,11 ---</span>
    /* optimize for common code path */
    node = lookup_type_node_I (type);
    if (!node || !node-&gt;is_classed)
      {
        g_warning (&quot;cannot retrieve class for invalid (unclassed) type &#39;%s&#39;&quot;,
<span class="line-modified">!      type_descriptive_name_I (type));</span>
        return NULL;
      }
  
    if (G_LIKELY (type_data_ref_U (node)))
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2997,11 ***</span>
    node = lookup_type_node_I (class-&gt;g_type);
    if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node))
      type_data_unref_U (node, FALSE);
    else
      g_warning (&quot;cannot unreference class of invalid (unclassed) type &#39;%s&#39;&quot;,
<span class="line-modified">!            type_descriptive_name_I (class-&gt;g_type));</span>
  }
  
  /**
   * g_type_class_unref_uncached: (skip)
   * @g_class: (type GObject.TypeClass): a #GTypeClass structure to unref
<span class="line-new-header">--- 3000,11 ---</span>
    node = lookup_type_node_I (class-&gt;g_type);
    if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node))
      type_data_unref_U (node, FALSE);
    else
      g_warning (&quot;cannot unreference class of invalid (unclassed) type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (class-&gt;g_type));</span>
  }
  
  /**
   * g_type_class_unref_uncached: (skip)
   * @g_class: (type GObject.TypeClass): a #GTypeClass structure to unref
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3022,11 ***</span>
    node = lookup_type_node_I (class-&gt;g_type);
    if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node))
      type_data_unref_U (node, TRUE);
    else
      g_warning (&quot;cannot unreference class of invalid (unclassed) type &#39;%s&#39;&quot;,
<span class="line-modified">!            type_descriptive_name_I (class-&gt;g_type));</span>
  }
  
  /**
   * g_type_class_peek:
   * @type: type ID of a classed type
<span class="line-new-header">--- 3025,11 ---</span>
    node = lookup_type_node_I (class-&gt;g_type);
    if (node &amp;&amp; node-&gt;is_classed &amp;&amp; NODE_REFCOUNT (node))
      type_data_unref_U (node, TRUE);
    else
      g_warning (&quot;cannot unreference class of invalid (unclassed) type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (class-&gt;g_type));</span>
  }
  
  /**
   * g_type_class_peek:
   * @type: type ID of a classed type
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3142,11 ***</span>
   *     structure of @iface_type if implemented by @instance_class, %NULL
   *     otherwise
   */
  gpointer
  g_type_interface_peek (gpointer instance_class,
<span class="line-modified">!                GType    iface_type)</span>
  {
    TypeNode *node;
    TypeNode *iface;
    gpointer vtable = NULL;
    GTypeClass *class = instance_class;
<span class="line-new-header">--- 3145,11 ---</span>
   *     structure of @iface_type if implemented by @instance_class, %NULL
   *     otherwise
   */
  gpointer
  g_type_interface_peek (gpointer instance_class,
<span class="line-modified">!            GType    iface_type)</span>
  {
    TypeNode *node;
    TypeNode *iface;
    gpointer vtable = NULL;
    GTypeClass *class = instance_class;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3232,11 ***</span>
    if (!node || !NODE_IS_IFACE (node) ||
        (node-&gt;data &amp;&amp; NODE_REFCOUNT (node) == 0))
      {
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_warning (&quot;cannot retrieve default vtable for invalid or non-interface type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (g_type));</span>
        return NULL;
      }
  
    if (!node-&gt;data || !node-&gt;data-&gt;iface.dflt_vtable)
      {
<span class="line-new-header">--- 3235,11 ---</span>
    if (!node || !NODE_IS_IFACE (node) ||
        (node-&gt;data &amp;&amp; NODE_REFCOUNT (node) == 0))
      {
        G_WRITE_UNLOCK (&amp;type_rw_lock);
        g_warning (&quot;cannot retrieve default vtable for invalid or non-interface type &#39;%s&#39;&quot;,
<span class="line-modified">!      type_descriptive_name_I (g_type));</span>
        return NULL;
      }
  
    if (!node-&gt;data || !node-&gt;data-&gt;iface.dflt_vtable)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3286,11 ***</span>
  }
  
  /**
   * g_type_default_interface_unref:
   * @g_iface: (type GObject.TypeInterface): the default vtable
<span class="line-modified">!  *     structure for a interface, as returned by g_type_default_interface_ref()</span>
   *
   * Decrements the reference count for the type corresponding to the
   * interface default vtable @g_iface. If the type is dynamic, then
   * when no one is using the interface and all references have
   * been released, the finalize function for the interface&#39;s default
<span class="line-new-header">--- 3289,11 ---</span>
  }
  
  /**
   * g_type_default_interface_unref:
   * @g_iface: (type GObject.TypeInterface): the default vtable
<span class="line-modified">!  *     structure for an interface, as returned by g_type_default_interface_ref()</span>
   *
   * Decrements the reference count for the type corresponding to the
   * interface default vtable @g_iface. If the type is dynamic, then
   * when no one is using the interface and all references have
   * been released, the finalize function for the interface&#39;s default
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3309,11 ***</span>
    node = lookup_type_node_I (vtable-&gt;g_type);
    if (node &amp;&amp; NODE_IS_IFACE (node))
      type_data_unref_U (node, FALSE);
    else
      g_warning (&quot;cannot unreference invalid interface default vtable for &#39;%s&#39;&quot;,
<span class="line-modified">!            type_descriptive_name_I (vtable-&gt;g_type));</span>
  }
  
  /**
   * g_type_name:
   * @type: type to return name for
<span class="line-new-header">--- 3312,11 ---</span>
    node = lookup_type_node_I (vtable-&gt;g_type);
    if (node &amp;&amp; NODE_IS_IFACE (node))
      type_data_unref_U (node, FALSE);
    else
      g_warning (&quot;cannot unreference invalid interface default vtable for &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (vtable-&gt;g_type));</span>
  }
  
  /**
   * g_type_name:
   * @type: type to return name for
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3356,13 ***</span>
    return node ? node-&gt;qname : 0;
  }
  
  /**
   * g_type_from_name:
<span class="line-modified">!  * @name: type name to lookup</span>
   *
<span class="line-modified">!  * Lookup the type ID from a given type name, returning 0 if no type</span>
   * has been registered under this name (this is the preferred method
   * to find out by name whether a specific type has been registered
   * yet).
   *
   * Returns: corresponding type ID or 0
<span class="line-new-header">--- 3359,13 ---</span>
    return node ? node-&gt;qname : 0;
  }
  
  /**
   * g_type_from_name:
<span class="line-modified">!  * @name: type name to look up</span>
   *
<span class="line-modified">!  * Look up the type ID from a given type name, returning 0 if no type</span>
   * has been registered under this name (this is the preferred method
   * to find out by name whether a specific type has been registered
   * yet).
   *
   * Returns: corresponding type ID or 0
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3434,39 ***</span>
   *
   * Returns: immediate child of @root_type and anchestor of @leaf_type
   */
  GType
  g_type_next_base (GType type,
<span class="line-modified">!           GType base_type)</span>
  {
    GType atype = 0;
    TypeNode *node;
  
    node = lookup_type_node_I (type);
    if (node)
      {
        TypeNode *base_node = lookup_type_node_I (base_type);
  
        if (base_node &amp;&amp; base_node-&gt;n_supers &lt; node-&gt;n_supers)
<span class="line-modified">!     {</span>
<span class="line-modified">!       guint n = node-&gt;n_supers - base_node-&gt;n_supers;</span>
  
<span class="line-modified">!       if (node-&gt;supers[n] == base_type)</span>
<span class="line-modified">!         atype = node-&gt;supers[n - 1];</span>
<span class="line-modified">!     }</span>
      }
  
    return atype;
  }
  
  static inline gboolean
  type_node_check_conformities_UorL (TypeNode *node,
<span class="line-modified">!                    TypeNode *iface_node,</span>
<span class="line-modified">!                    /*        support_inheritance */</span>
<span class="line-modified">!                    gboolean  support_interfaces,</span>
<span class="line-modified">!                    gboolean  support_prerequisites,</span>
<span class="line-modified">!                    gboolean  have_lock)</span>
  {
    gboolean match;
  
    if (/* support_inheritance &amp;&amp; */
        NODE_IS_ANCESTOR (iface_node, node))
<span class="line-new-header">--- 3437,39 ---</span>
   *
   * Returns: immediate child of @root_type and anchestor of @leaf_type
   */
  GType
  g_type_next_base (GType type,
<span class="line-modified">!       GType base_type)</span>
  {
    GType atype = 0;
    TypeNode *node;
  
    node = lookup_type_node_I (type);
    if (node)
      {
        TypeNode *base_node = lookup_type_node_I (base_type);
  
        if (base_node &amp;&amp; base_node-&gt;n_supers &lt; node-&gt;n_supers)
<span class="line-modified">!   {</span>
<span class="line-modified">!     guint n = node-&gt;n_supers - base_node-&gt;n_supers;</span>
  
<span class="line-modified">!     if (node-&gt;supers[n] == base_type)</span>
<span class="line-modified">!       atype = node-&gt;supers[n - 1];</span>
<span class="line-modified">!   }</span>
      }
  
    return atype;
  }
  
  static inline gboolean
  type_node_check_conformities_UorL (TypeNode *node,
<span class="line-modified">!            TypeNode *iface_node,</span>
<span class="line-modified">!            /*        support_inheritance */</span>
<span class="line-modified">!            gboolean  support_interfaces,</span>
<span class="line-modified">!            gboolean  support_prerequisites,</span>
<span class="line-modified">!            gboolean  have_lock)</span>
  {
    gboolean match;
  
    if (/* support_inheritance &amp;&amp; */
        NODE_IS_ANCESTOR (iface_node, node))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3476,45 ***</span>
    support_prerequisites = support_prerequisites &amp;&amp; NODE_IS_IFACE (node);
    match = FALSE;
    if (support_interfaces)
      {
        if (have_lock)
<span class="line-modified">!     {</span>
<span class="line-modified">!       if (type_lookup_iface_entry_L (node, iface_node))</span>
<span class="line-modified">!         match = TRUE;</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       if (type_lookup_iface_vtable_I (node, iface_node, NULL))</span>
<span class="line-modified">!         match = TRUE;</span>
<span class="line-modified">!     }</span>
      }
    if (!match &amp;&amp;
        support_prerequisites)
      {
        if (!have_lock)
<span class="line-modified">!     G_READ_LOCK (&amp;type_rw_lock);</span>
        if (support_prerequisites &amp;&amp; type_lookup_prerequisite_L (node, NODE_TYPE (iface_node)))
<span class="line-modified">!     match = TRUE;</span>
        if (!have_lock)
<span class="line-modified">!     G_READ_UNLOCK (&amp;type_rw_lock);</span>
      }
    return match;
  }
  
  static gboolean
  type_node_is_a_L (TypeNode *node,
<span class="line-modified">!           TypeNode *iface_node)</span>
  {
    return type_node_check_conformities_UorL (node, iface_node, TRUE, TRUE, TRUE);
  }
  
  static inline gboolean
  type_node_conforms_to_U (TypeNode *node,
<span class="line-modified">!              TypeNode *iface_node,</span>
<span class="line-modified">!              gboolean  support_interfaces,</span>
<span class="line-modified">!              gboolean  support_prerequisites)</span>
  {
    return type_node_check_conformities_UorL (node, iface_node, support_interfaces, support_prerequisites, FALSE);
  }
  
  /**
<span class="line-new-header">--- 3479,45 ---</span>
    support_prerequisites = support_prerequisites &amp;&amp; NODE_IS_IFACE (node);
    match = FALSE;
    if (support_interfaces)
      {
        if (have_lock)
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (type_lookup_iface_entry_L (node, iface_node))</span>
<span class="line-modified">!       match = TRUE;</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (type_lookup_iface_vtable_I (node, iface_node, NULL))</span>
<span class="line-modified">!       match = TRUE;</span>
<span class="line-modified">!   }</span>
      }
    if (!match &amp;&amp;
        support_prerequisites)
      {
        if (!have_lock)
<span class="line-modified">!   G_READ_LOCK (&amp;type_rw_lock);</span>
        if (support_prerequisites &amp;&amp; type_lookup_prerequisite_L (node, NODE_TYPE (iface_node)))
<span class="line-modified">!   match = TRUE;</span>
        if (!have_lock)
<span class="line-modified">!   G_READ_UNLOCK (&amp;type_rw_lock);</span>
      }
    return match;
  }
  
  static gboolean
  type_node_is_a_L (TypeNode *node,
<span class="line-modified">!       TypeNode *iface_node)</span>
  {
    return type_node_check_conformities_UorL (node, iface_node, TRUE, TRUE, TRUE);
  }
  
  static inline gboolean
  type_node_conforms_to_U (TypeNode *node,
<span class="line-modified">!        TypeNode *iface_node,</span>
<span class="line-modified">!        gboolean  support_interfaces,</span>
<span class="line-modified">!        gboolean  support_prerequisites)</span>
  {
    return type_node_check_conformities_UorL (node, iface_node, support_interfaces, support_prerequisites, FALSE);
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3529,11 ***</span>
   *
   * Returns: %TRUE if @type is a @is_a_type
   */
  gboolean
  g_type_is_a (GType type,
<span class="line-modified">!          GType iface_type)</span>
  {
    TypeNode *node, *iface_node;
    gboolean is_a;
  
    if (type == iface_type)
<span class="line-new-header">--- 3532,11 ---</span>
   *
   * Returns: %TRUE if @type is a @is_a_type
   */
  gboolean
  g_type_is_a (GType type,
<span class="line-modified">!        GType iface_type)</span>
  {
    TypeNode *node, *iface_node;
    gboolean is_a;
  
    if (type == iface_type)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3558,11 ***</span>
   * Returns: (array length=n_children) (transfer full): Newly allocated
   *     and 0-terminated array of child types, free with g_free()
   */
  GType*
  g_type_children (GType  type,
<span class="line-modified">!          guint *n_children)</span>
  {
    TypeNode *node;
  
    node = lookup_type_node_I (type);
    if (node)
<span class="line-new-header">--- 3561,11 ---</span>
   * Returns: (array length=n_children) (transfer full): Newly allocated
   *     and 0-terminated array of child types, free with g_free()
   */
  GType*
  g_type_children (GType  type,
<span class="line-modified">!      guint *n_children)</span>
  {
    TypeNode *node;
  
    node = lookup_type_node_I (type);
    if (node)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3570,23 ***</span>
        GType *children;
  
        G_READ_LOCK (&amp;type_rw_lock);  /* -&gt;children is relocatable */
        children = g_new (GType, node-&gt;n_children + 1);
        if (node-&gt;n_children != 0)
<span class="line-modified">!       memcpy (children, node-&gt;children, sizeof (GType) * node-&gt;n_children);</span>
        children[node-&gt;n_children] = 0;
  
        if (n_children)
<span class="line-modified">!     *n_children = node-&gt;n_children;</span>
        G_READ_UNLOCK (&amp;type_rw_lock);
  
        return children;
      }
    else
      {
        if (n_children)
<span class="line-modified">!     *n_children = 0;</span>
  
        return NULL;
      }
  }
  
<span class="line-new-header">--- 3573,23 ---</span>
        GType *children;
  
        G_READ_LOCK (&amp;type_rw_lock);  /* -&gt;children is relocatable */
        children = g_new (GType, node-&gt;n_children + 1);
        if (node-&gt;n_children != 0)
<span class="line-modified">!         memcpy (children, node-&gt;children, sizeof (GType) * node-&gt;n_children);</span>
        children[node-&gt;n_children] = 0;
  
        if (n_children)
<span class="line-modified">!   *n_children = node-&gt;n_children;</span>
        G_READ_UNLOCK (&amp;type_rw_lock);
  
        return children;
      }
    else
      {
        if (n_children)
<span class="line-modified">!   *n_children = 0;</span>
  
        return NULL;
      }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3602,11 ***</span>
   * Returns: (array length=n_interfaces) (transfer full): Newly allocated
   *     and 0-terminated array of interface types, free with g_free()
   */
  GType*
  g_type_interfaces (GType  type,
<span class="line-modified">!            guint *n_interfaces)</span>
  {
    TypeNode *node;
  
    node = lookup_type_node_I (type);
    if (node &amp;&amp; node-&gt;is_instantiatable)
<span class="line-new-header">--- 3605,11 ---</span>
   * Returns: (array length=n_interfaces) (transfer full): Newly allocated
   *     and 0-terminated array of interface types, free with g_free()
   */
  GType*
  g_type_interfaces (GType  type,
<span class="line-modified">!        guint *n_interfaces)</span>
  {
    TypeNode *node;
  
    node = lookup_type_node_I (type);
    if (node &amp;&amp; node-&gt;is_instantiatable)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3616,32 ***</span>
        guint i;
  
        G_READ_LOCK (&amp;type_rw_lock);
        entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
        if (entries)
<span class="line-modified">!     {</span>
<span class="line-modified">!       ifaces = g_new (GType, IFACE_ENTRIES_N_ENTRIES (entries) + 1);</span>
<span class="line-modified">!       for (i = 0; i &lt; IFACE_ENTRIES_N_ENTRIES (entries); i++)</span>
<span class="line-modified">!         ifaces[i] = entries-&gt;entry[i].iface_type;</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       ifaces = g_new (GType, 1);</span>
<span class="line-modified">!       i = 0;</span>
<span class="line-modified">!     }</span>
        ifaces[i] = 0;
  
        if (n_interfaces)
<span class="line-modified">!     *n_interfaces = i;</span>
        G_READ_UNLOCK (&amp;type_rw_lock);
  
        return ifaces;
      }
    else
      {
        if (n_interfaces)
<span class="line-modified">!     *n_interfaces = 0;</span>
  
        return NULL;
      }
  }
  
<span class="line-new-header">--- 3619,32 ---</span>
        guint i;
  
        G_READ_LOCK (&amp;type_rw_lock);
        entries = CLASSED_NODE_IFACES_ENTRIES_LOCKED (node);
        if (entries)
<span class="line-modified">!   {</span>
<span class="line-modified">!     ifaces = g_new (GType, IFACE_ENTRIES_N_ENTRIES (entries) + 1);</span>
<span class="line-modified">!     for (i = 0; i &lt; IFACE_ENTRIES_N_ENTRIES (entries); i++)</span>
<span class="line-modified">!       ifaces[i] = entries-&gt;entry[i].iface_type;</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     ifaces = g_new (GType, 1);</span>
<span class="line-modified">!     i = 0;</span>
<span class="line-modified">!   }</span>
        ifaces[i] = 0;
  
        if (n_interfaces)
<span class="line-modified">!   *n_interfaces = i;</span>
        G_READ_UNLOCK (&amp;type_rw_lock);
  
        return ifaces;
      }
    else
      {
        if (n_interfaces)
<span class="line-modified">!   *n_interfaces = 0;</span>
  
        return NULL;
      }
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3657,36 ***</span>
    gpointer data;
  };
  
  static inline gpointer
  type_get_qdata_L (TypeNode *node,
<span class="line-modified">!           GQuark    quark)</span>
  {
    GData *gdata = node-&gt;global_gdata;
  
    if (quark &amp;&amp; gdata &amp;&amp; gdata-&gt;n_qdatas)
      {
        QData *qdatas = gdata-&gt;qdatas - 1;
        guint n_qdatas = gdata-&gt;n_qdatas;
  
        do
<span class="line-modified">!     {</span>
<span class="line-modified">!       guint i;</span>
<span class="line-modified">!       QData *check;</span>
<span class="line-modified">! </span>
<span class="line-modified">!       i = (n_qdatas + 1) / 2;</span>
<span class="line-modified">!       check = qdatas + i;</span>
<span class="line-modified">!       if (quark == check-&gt;quark)</span>
<span class="line-modified">!         return check-&gt;data;</span>
<span class="line-modified">!       else if (quark &gt; check-&gt;quark)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           n_qdatas -= i;</span>
<span class="line-modified">!           qdatas = check;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       else /* if (quark &lt; check-&gt;quark) */</span>
<span class="line-modified">!         n_qdatas = i - 1;</span>
<span class="line-modified">!     }</span>
        while (n_qdatas);
      }
    return NULL;
  }
  
<span class="line-new-header">--- 3660,36 ---</span>
    gpointer data;
  };
  
  static inline gpointer
  type_get_qdata_L (TypeNode *node,
<span class="line-modified">!       GQuark    quark)</span>
  {
    GData *gdata = node-&gt;global_gdata;
  
    if (quark &amp;&amp; gdata &amp;&amp; gdata-&gt;n_qdatas)
      {
        QData *qdatas = gdata-&gt;qdatas - 1;
        guint n_qdatas = gdata-&gt;n_qdatas;
  
        do
<span class="line-modified">!   {</span>
<span class="line-modified">!     guint i;</span>
<span class="line-modified">!     QData *check;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     i = (n_qdatas + 1) / 2;</span>
<span class="line-modified">!     check = qdatas + i;</span>
<span class="line-modified">!     if (quark == check-&gt;quark)</span>
<span class="line-modified">!       return check-&gt;data;</span>
<span class="line-modified">!     else if (quark &gt; check-&gt;quark)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         n_qdatas -= i;</span>
<span class="line-modified">!         qdatas = check;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     else /* if (quark &lt; check-&gt;quark) */</span>
<span class="line-modified">!       n_qdatas = i - 1;</span>
<span class="line-modified">!   }</span>
        while (n_qdatas);
      }
    return NULL;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3704,11 ***</span>
   *
   * Returns: (transfer none): the data, or %NULL if no data was found
   */
  gpointer
  g_type_get_qdata (GType  type,
<span class="line-modified">!           GQuark quark)</span>
  {
    TypeNode *node;
    gpointer data;
  
    node = lookup_type_node_I (type);
<span class="line-new-header">--- 3707,11 ---</span>
   *
   * Returns: (transfer none): the data, or %NULL if no data was found
   */
  gpointer
  g_type_get_qdata (GType  type,
<span class="line-modified">!       GQuark quark)</span>
  {
    TypeNode *node;
    gpointer data;
  
    node = lookup_type_node_I (type);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3726,12 ***</span>
    return data;
  }
  
  static inline void
  type_set_qdata_W (TypeNode *node,
<span class="line-modified">!           GQuark    quark,</span>
<span class="line-modified">!           gpointer  data)</span>
  {
    GData *gdata;
    QData *qdata;
    guint i;
  
<span class="line-new-header">--- 3729,12 ---</span>
    return data;
  }
  
  static inline void
  type_set_qdata_W (TypeNode *node,
<span class="line-modified">!       GQuark    quark,</span>
<span class="line-modified">!       gpointer  data)</span>
  {
    GData *gdata;
    QData *qdata;
    guint i;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3743,12 ***</span>
    /* try resetting old data */
    qdata = gdata-&gt;qdatas;
    for (i = 0; i &lt; gdata-&gt;n_qdatas; i++)
      if (qdata[i].quark == quark)
        {
<span class="line-modified">!     qdata[i].data = data;</span>
<span class="line-modified">!     return;</span>
        }
  
    /* add new entry */
    gdata-&gt;n_qdatas++;
    gdata-&gt;qdatas = g_renew (QData, gdata-&gt;qdatas, gdata-&gt;n_qdatas);
<span class="line-new-header">--- 3746,12 ---</span>
    /* try resetting old data */
    qdata = gdata-&gt;qdatas;
    for (i = 0; i &lt; gdata-&gt;n_qdatas; i++)
      if (qdata[i].quark == quark)
        {
<span class="line-modified">!   qdata[i].data = data;</span>
<span class="line-modified">!   return;</span>
        }
  
    /* add new entry */
    gdata-&gt;n_qdatas++;
    gdata-&gt;qdatas = g_renew (QData, gdata-&gt;qdatas, gdata-&gt;n_qdatas);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3769,12 ***</span>
   *
   * Attaches arbitrary data to a type.
   */
  void
  g_type_set_qdata (GType    type,
<span class="line-modified">!           GQuark   quark,</span>
<span class="line-modified">!           gpointer data)</span>
  {
    TypeNode *node;
  
    g_return_if_fail (quark != 0);
  
<span class="line-new-header">--- 3772,12 ---</span>
   *
   * Attaches arbitrary data to a type.
   */
  void
  g_type_set_qdata (GType    type,
<span class="line-modified">!       GQuark   quark,</span>
<span class="line-modified">!       gpointer data)</span>
  {
    TypeNode *node;
  
    g_return_if_fail (quark != 0);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3789,11 ***</span>
      g_return_if_fail (node != NULL);
  }
  
  static void
  type_add_flags_W (TypeNode  *node,
<span class="line-modified">!           GTypeFlags flags)</span>
  {
    guint dflags;
  
    g_return_if_fail ((flags &amp; ~TYPE_FLAG_MASK) == 0);
    g_return_if_fail (node != NULL);
<span class="line-new-header">--- 3792,11 ---</span>
      g_return_if_fail (node != NULL);
  }
  
  static void
  type_add_flags_W (TypeNode  *node,
<span class="line-modified">!       GTypeFlags flags)</span>
  {
    guint dflags;
  
    g_return_if_fail ((flags &amp; ~TYPE_FLAG_MASK) == 0);
    g_return_if_fail (node != NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3818,11 ***</span>
   * #GTypeQuery structure should be considered constant and have to be
   * left untouched.
   */
  void
  g_type_query (GType       type,
<span class="line-modified">!           GTypeQuery *query)</span>
  {
    TypeNode *node;
  
    g_return_if_fail (query != NULL);
  
<span class="line-new-header">--- 3821,11 ---</span>
   * #GTypeQuery structure should be considered constant and have to be
   * left untouched.
   */
  void
  g_type_query (GType       type,
<span class="line-modified">!         GTypeQuery *query)</span>
  {
    TypeNode *node;
  
    g_return_if_fail (query != NULL);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3831,17 ***</span>
    node = lookup_type_node_I (type);
    if (node &amp;&amp; node-&gt;is_classed &amp;&amp; !node-&gt;plugin)
      {
        /* type is classed and probably even instantiatable */
        G_READ_LOCK (&amp;type_rw_lock);
<span class="line-modified">!       if (node-&gt;data)   /* type is static or referenced */</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       query-&gt;type = NODE_TYPE (node);</span>
<span class="line-modified">!       query-&gt;type_name = NODE_NAME (node);</span>
<span class="line-modified">!       query-&gt;class_size = node-&gt;data-&gt;class.class_size;</span>
<span class="line-modified">!       query-&gt;instance_size = node-&gt;is_instantiatable ? node-&gt;data-&gt;instance.instance_size : 0;</span>
<span class="line-modified">!     }</span>
        G_READ_UNLOCK (&amp;type_rw_lock);
      }
  }
  
  /**
<span class="line-new-header">--- 3834,17 ---</span>
    node = lookup_type_node_I (type);
    if (node &amp;&amp; node-&gt;is_classed &amp;&amp; !node-&gt;plugin)
      {
        /* type is classed and probably even instantiatable */
        G_READ_LOCK (&amp;type_rw_lock);
<span class="line-modified">!       if (node-&gt;data) /* type is static or referenced */</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     query-&gt;type = NODE_TYPE (node);</span>
<span class="line-modified">!     query-&gt;type_name = NODE_NAME (node);</span>
<span class="line-modified">!     query-&gt;class_size = node-&gt;data-&gt;class.class_size;</span>
<span class="line-modified">!     query-&gt;instance_size = node-&gt;is_instantiatable ? node-&gt;data-&gt;instance.instance_size : 0;</span>
<span class="line-modified">!   }</span>
        G_READ_UNLOCK (&amp;type_rw_lock);
      }
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3874,11 ***</span>
  }
  
  /* --- implementation details --- */
  gboolean
  g_type_test_flags (GType type,
<span class="line-modified">!            guint flags)</span>
  {
    TypeNode *node;
    gboolean result = FALSE;
  
    node = lookup_type_node_I (type);
<span class="line-new-header">--- 3877,11 ---</span>
  }
  
  /* --- implementation details --- */
  gboolean
  g_type_test_flags (GType type,
<span class="line-modified">!        guint flags)</span>
  {
    TypeNode *node;
    gboolean result = FALSE;
  
    node = lookup_type_node_I (type);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3886,26 ***</span>
      {
        guint fflags = flags &amp; TYPE_FUNDAMENTAL_FLAG_MASK;
        guint tflags = flags &amp; TYPE_FLAG_MASK;
  
        if (fflags)
<span class="line-modified">!     {</span>
<span class="line-modified">!       GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (node);</span>
  
<span class="line-modified">!       fflags = (finfo-&gt;type_flags &amp; fflags) == fflags;</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     fflags = TRUE;</span>
  
        if (tflags)
<span class="line-modified">!     {</span>
<span class="line-modified">!       G_READ_LOCK (&amp;type_rw_lock);</span>
<span class="line-modified">!       tflags = (tflags &amp; GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))) == tflags;</span>
<span class="line-modified">!       G_READ_UNLOCK (&amp;type_rw_lock);</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     tflags = TRUE;</span>
  
        result = tflags &amp;&amp; fflags;
      }
  
    return result;
<span class="line-new-header">--- 3889,26 ---</span>
      {
        guint fflags = flags &amp; TYPE_FUNDAMENTAL_FLAG_MASK;
        guint tflags = flags &amp; TYPE_FLAG_MASK;
  
        if (fflags)
<span class="line-modified">!   {</span>
<span class="line-modified">!     GTypeFundamentalInfo *finfo = type_node_fundamental_info_I (node);</span>
  
<span class="line-modified">!     fflags = (finfo-&gt;type_flags &amp; fflags) == fflags;</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   fflags = TRUE;</span>
  
        if (tflags)
<span class="line-modified">!   {</span>
<span class="line-modified">!     G_READ_LOCK (&amp;type_rw_lock);</span>
<span class="line-modified">!     tflags = (tflags &amp; GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags))) == tflags;</span>
<span class="line-modified">!     G_READ_UNLOCK (&amp;type_rw_lock);</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   tflags = TRUE;</span>
  
        result = tflags &amp;&amp; fflags;
      }
  
    return result;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3943,16 ***</span>
   * Returns: (transfer none): the #GTypePlugin for the dynamic
   *     interface @interface_type of @instance_type
   */
  GTypePlugin*
  g_type_interface_get_plugin (GType instance_type,
<span class="line-modified">!                  GType interface_type)</span>
  {
    TypeNode *node;
    TypeNode *iface;
  
<span class="line-modified">!   g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);    /* G_TYPE_IS_INTERFACE() is an external call: _U */</span>
  
    node = lookup_type_node_I (instance_type);
    iface = lookup_type_node_I (interface_type);
    if (node &amp;&amp; iface)
      {
<span class="line-new-header">--- 3946,16 ---</span>
   * Returns: (transfer none): the #GTypePlugin for the dynamic
   *     interface @interface_type of @instance_type
   */
  GTypePlugin*
  g_type_interface_get_plugin (GType instance_type,
<span class="line-modified">!            GType interface_type)</span>
  {
    TypeNode *node;
    TypeNode *iface;
  
<span class="line-modified">!   g_return_val_if_fail (G_TYPE_IS_INTERFACE (interface_type), NULL);  /* G_TYPE_IS_INTERFACE() is an external call: _U */</span>
  
    node = lookup_type_node_I (instance_type);
    iface = lookup_type_node_I (interface_type);
    if (node &amp;&amp; iface)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3961,11 ***</span>
  
        G_READ_LOCK (&amp;type_rw_lock);
  
        iholder = iface_node_get_holders_L (iface);
        while (iholder &amp;&amp; iholder-&gt;instance_type != instance_type)
<span class="line-modified">!     iholder = iholder-&gt;next;</span>
        plugin = iholder ? iholder-&gt;plugin : NULL;
  
        G_READ_UNLOCK (&amp;type_rw_lock);
  
        return plugin;
<span class="line-new-header">--- 3964,11 ---</span>
  
        G_READ_LOCK (&amp;type_rw_lock);
  
        iholder = iface_node_get_holders_L (iface);
        while (iholder &amp;&amp; iholder-&gt;instance_type != instance_type)
<span class="line-modified">!   iholder = iholder-&gt;next;</span>
        plugin = iholder ? iholder-&gt;plugin : NULL;
  
        G_READ_UNLOCK (&amp;type_rw_lock);
  
        return plugin;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4019,11 ***</span>
    return node ? NODE_FUNDAMENTAL_TYPE (node) : 0;
  }
  
  gboolean
  g_type_check_instance_is_a (GTypeInstance *type_instance,
<span class="line-modified">!                 GType          iface_type)</span>
  {
    TypeNode *node, *iface;
    gboolean check;
  
    if (!type_instance || !type_instance-&gt;g_class)
<span class="line-new-header">--- 4022,11 ---</span>
    return node ? NODE_FUNDAMENTAL_TYPE (node) : 0;
  }
  
  gboolean
  g_type_check_instance_is_a (GTypeInstance *type_instance,
<span class="line-modified">!           GType          iface_type)</span>
  {
    TypeNode *node, *iface;
    gboolean check;
  
    if (!type_instance || !type_instance-&gt;g_class)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4047,11 ***</span>
    return node &amp;&amp; (NODE_FUNDAMENTAL_TYPE(node) == fundamental_type);
  }
  
  gboolean
  g_type_check_class_is_a (GTypeClass *type_class,
<span class="line-modified">!              GType       is_a_type)</span>
  {
    TypeNode *node, *iface;
    gboolean check;
  
    if (!type_class)
<span class="line-new-header">--- 4050,11 ---</span>
    return node &amp;&amp; (NODE_FUNDAMENTAL_TYPE(node) == fundamental_type);
  }
  
  gboolean
  g_type_check_class_is_a (GTypeClass *type_class,
<span class="line-modified">!        GType       is_a_type)</span>
  {
    TypeNode *node, *iface;
    gboolean check;
  
    if (!type_class)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4064,46 ***</span>
    return check;
  }
  
  GTypeInstance*
  g_type_check_instance_cast (GTypeInstance *type_instance,
<span class="line-modified">!                 GType          iface_type)</span>
  {
    if (type_instance)
      {
        if (type_instance-&gt;g_class)
<span class="line-modified">!     {</span>
<span class="line-modified">!       TypeNode *node, *iface;</span>
<span class="line-modified">!       gboolean is_instantiatable, check;</span>
<span class="line-modified">! </span>
<span class="line-modified">!       node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);</span>
<span class="line-modified">!       is_instantiatable = node &amp;&amp; node-&gt;is_instantiatable;</span>
<span class="line-modified">!       iface = lookup_type_node_I (iface_type);</span>
<span class="line-modified">!       check = is_instantiatable &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, TRUE, FALSE);</span>
<span class="line-modified">!       if (check)</span>
<span class="line-modified">!         return type_instance;</span>
<span class="line-modified">! </span>
<span class="line-modified">!       if (is_instantiatable)</span>
<span class="line-modified">!         g_warning (&quot;invalid cast from &#39;%s&#39; to &#39;%s&#39;&quot;,</span>
<span class="line-modified">!                type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type),</span>
<span class="line-removed">-                type_descriptive_name_I (iface_type));</span>
<span class="line-removed">-       else</span>
<span class="line-removed">-         g_warning (&quot;invalid uninstantiatable type &#39;%s&#39; in cast to &#39;%s&#39;&quot;,</span>
<span class="line-removed">-                type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type),</span>
<span class="line-removed">-                type_descriptive_name_I (iface_type));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-       else</span>
<span class="line-removed">-     g_warning (&quot;invalid unclassed pointer in cast to &#39;%s&#39;&quot;,</span>
             type_descriptive_name_I (iface_type));
      }
  
    return type_instance;
  }
  
  GTypeClass*
  g_type_check_class_cast (GTypeClass *type_class,
<span class="line-modified">!              GType       is_a_type)</span>
  {
    if (type_class)
      {
        TypeNode *node, *iface;
        gboolean is_classed, check;
<span class="line-new-header">--- 4067,46 ---</span>
    return check;
  }
  
  GTypeInstance*
  g_type_check_instance_cast (GTypeInstance *type_instance,
<span class="line-modified">!           GType          iface_type)</span>
  {
    if (type_instance)
      {
        if (type_instance-&gt;g_class)
<span class="line-modified">!   {</span>
<span class="line-modified">!     TypeNode *node, *iface;</span>
<span class="line-modified">!     gboolean is_instantiatable, check;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);</span>
<span class="line-modified">!     is_instantiatable = node &amp;&amp; node-&gt;is_instantiatable;</span>
<span class="line-modified">!     iface = lookup_type_node_I (iface_type);</span>
<span class="line-modified">!     check = is_instantiatable &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, TRUE, FALSE);</span>
<span class="line-modified">!     if (check)</span>
<span class="line-modified">!       return type_instance;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (is_instantiatable)</span>
<span class="line-modified">!       g_warning (&quot;invalid cast from &#39;%s&#39; to &#39;%s&#39;&quot;,</span>
<span class="line-modified">!            type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type),</span>
             type_descriptive_name_I (iface_type));
<span class="line-added">+     else</span>
<span class="line-added">+       g_warning (&quot;invalid uninstantiatable type &#39;%s&#39; in cast to &#39;%s&#39;&quot;,</span>
<span class="line-added">+            type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type),</span>
<span class="line-added">+            type_descriptive_name_I (iface_type));</span>
<span class="line-added">+   }</span>
<span class="line-added">+       else</span>
<span class="line-added">+   g_warning (&quot;invalid unclassed pointer in cast to &#39;%s&#39;&quot;,</span>
<span class="line-added">+        type_descriptive_name_I (iface_type));</span>
      }
  
    return type_instance;
  }
  
  GTypeClass*
  g_type_check_class_cast (GTypeClass *type_class,
<span class="line-modified">!        GType       is_a_type)</span>
  {
    if (type_class)
      {
        TypeNode *node, *iface;
        gboolean is_classed, check;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4111,24 ***</span>
        node = lookup_type_node_I (type_class-&gt;g_type);
        is_classed = node &amp;&amp; node-&gt;is_classed;
        iface = lookup_type_node_I (is_a_type);
        check = is_classed &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, FALSE, FALSE);
        if (check)
<span class="line-modified">!     return type_class;</span>
  
        if (is_classed)
<span class="line-modified">!     g_warning (&quot;invalid class cast from &#39;%s&#39; to &#39;%s&#39;&quot;,</span>
<span class="line-modified">!            type_descriptive_name_I (type_class-&gt;g_type),</span>
<span class="line-modified">!            type_descriptive_name_I (is_a_type));</span>
        else
<span class="line-modified">!     g_warning (&quot;invalid unclassed type &#39;%s&#39; in class cast to &#39;%s&#39;&quot;,</span>
<span class="line-modified">!            type_descriptive_name_I (type_class-&gt;g_type),</span>
<span class="line-modified">!            type_descriptive_name_I (is_a_type));</span>
      }
    else
      g_warning (&quot;invalid class cast from (NULL) pointer to &#39;%s&#39;&quot;,
<span class="line-modified">!            type_descriptive_name_I (is_a_type));</span>
    return type_class;
  }
  
  /**
   * g_type_check_instance:
<span class="line-new-header">--- 4114,24 ---</span>
        node = lookup_type_node_I (type_class-&gt;g_type);
        is_classed = node &amp;&amp; node-&gt;is_classed;
        iface = lookup_type_node_I (is_a_type);
        check = is_classed &amp;&amp; iface &amp;&amp; type_node_conforms_to_U (node, iface, FALSE, FALSE);
        if (check)
<span class="line-modified">!   return type_class;</span>
  
        if (is_classed)
<span class="line-modified">!   g_warning (&quot;invalid class cast from &#39;%s&#39; to &#39;%s&#39;&quot;,</span>
<span class="line-modified">!        type_descriptive_name_I (type_class-&gt;g_type),</span>
<span class="line-modified">!        type_descriptive_name_I (is_a_type));</span>
        else
<span class="line-modified">!   g_warning (&quot;invalid unclassed type &#39;%s&#39; in class cast to &#39;%s&#39;&quot;,</span>
<span class="line-modified">!        type_descriptive_name_I (type_class-&gt;g_type),</span>
<span class="line-modified">!        type_descriptive_name_I (is_a_type));</span>
      }
    else
      g_warning (&quot;invalid class cast from (NULL) pointer to &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (is_a_type));</span>
    return type_class;
  }
  
  /**
   * g_type_check_instance:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4146,21 ***</span>
     * conveniently elaborated on instance checks
     */
    if (type_instance)
      {
        if (type_instance-&gt;g_class)
<span class="line-modified">!     {</span>
<span class="line-modified">!       TypeNode *node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);</span>
  
<span class="line-modified">!       if (node &amp;&amp; node-&gt;is_instantiatable)</span>
<span class="line-modified">!         return TRUE;</span>
  
<span class="line-modified">!       g_warning (&quot;instance of invalid non-instantiatable type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!              type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type));</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     g_warning (&quot;instance with invalid (NULL) class pointer&quot;);</span>
      }
    else
      g_warning (&quot;invalid (NULL) pointer instance&quot;);
  
    return FALSE;
<span class="line-new-header">--- 4149,21 ---</span>
     * conveniently elaborated on instance checks
     */
    if (type_instance)
      {
        if (type_instance-&gt;g_class)
<span class="line-modified">!   {</span>
<span class="line-modified">!     TypeNode *node = lookup_type_node_I (type_instance-&gt;g_class-&gt;g_type);</span>
  
<span class="line-modified">!     if (node &amp;&amp; node-&gt;is_instantiatable)</span>
<span class="line-modified">!       return TRUE;</span>
  
<span class="line-modified">!     g_warning (&quot;instance of invalid non-instantiatable type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!          type_descriptive_name_I (type_instance-&gt;g_class-&gt;g_type));</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   g_warning (&quot;instance with invalid (NULL) class pointer&quot;);</span>
      }
    else
      g_warning (&quot;invalid (NULL) pointer instance&quot;);
  
    return FALSE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4180,29 ***</span>
    G_READ_LOCK (&amp;type_rw_lock);
   restart_check:
    if (node)
      {
        if (node-&gt;data &amp;&amp; NODE_REFCOUNT (node) &gt; 0 &amp;&amp;
<span class="line-modified">!       node-&gt;data-&gt;common.value_table-&gt;value_init)</span>
<span class="line-modified">!     tflags = GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags));</span>
        else if (NODE_IS_IFACE (node))
<span class="line-modified">!     {</span>
<span class="line-modified">!       guint i;</span>
  
<span class="line-modified">!       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (node); i++)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           GType prtype = IFACE_NODE_PREREQUISITES (node)[i];</span>
<span class="line-modified">!           TypeNode *prnode = lookup_type_node_I (prtype);</span>
  
<span class="line-modified">!           if (prnode-&gt;is_instantiatable)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           type = prtype;</span>
<span class="line-modified">!           node = lookup_type_node_I (type);</span>
<span class="line-modified">!           goto restart_check;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         }</span>
      }
      }
    G_READ_UNLOCK (&amp;type_rw_lock);
  
    return !(tflags &amp; G_TYPE_FLAG_VALUE_ABSTRACT);
  }
<span class="line-new-header">--- 4183,29 ---</span>
    G_READ_LOCK (&amp;type_rw_lock);
   restart_check:
    if (node)
      {
        if (node-&gt;data &amp;&amp; NODE_REFCOUNT (node) &gt; 0 &amp;&amp;
<span class="line-modified">!     node-&gt;data-&gt;common.value_table-&gt;value_init)</span>
<span class="line-modified">!   tflags = GPOINTER_TO_UINT (type_get_qdata_L (node, static_quark_type_flags));</span>
        else if (NODE_IS_IFACE (node))
<span class="line-modified">!   {</span>
<span class="line-modified">!     guint i;</span>
  
<span class="line-modified">!     for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (node); i++)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         GType prtype = IFACE_NODE_PREREQUISITES (node)[i];</span>
<span class="line-modified">!         TypeNode *prnode = lookup_type_node_I (prtype);</span>
  
<span class="line-modified">!         if (prnode-&gt;is_instantiatable)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       type = prtype;</span>
<span class="line-modified">!       node = lookup_type_node_I (type);</span>
<span class="line-modified">!       goto restart_check;</span>
      }
<span class="line-added">+       }</span>
<span class="line-added">+   }</span>
      }
    G_READ_UNLOCK (&amp;type_rw_lock);
  
    return !(tflags &amp; G_TYPE_FLAG_VALUE_ABSTRACT);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4219,11 ***</span>
    return value &amp;&amp; type_check_is_value_type_U (value-&gt;g_type);
  }
  
  gboolean
  g_type_check_value_holds (const GValue *value,
<span class="line-modified">!               GType         type)</span>
  {
    return value &amp;&amp; type_check_is_value_type_U (value-&gt;g_type) &amp;&amp; g_type_is_a (value-&gt;g_type, type);
  }
  
  /**
<span class="line-new-header">--- 4222,11 ---</span>
    return value &amp;&amp; type_check_is_value_type_U (value-&gt;g_type);
  }
  
  gboolean
  g_type_check_value_holds (const GValue *value,
<span class="line-modified">!         GType         type)</span>
  {
    return value &amp;&amp; type_check_is_value_type_U (value-&gt;g_type) &amp;&amp; g_type_is_a (value-&gt;g_type, type);
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4255,28 ***</span>
    has_refed_data = node &amp;&amp; node-&gt;data &amp;&amp; NODE_REFCOUNT (node) &gt; 0;
    has_table = has_refed_data &amp;&amp; node-&gt;data-&gt;common.value_table-&gt;value_init;
    if (has_refed_data)
      {
        if (has_table)
<span class="line-modified">!     vtable = node-&gt;data-&gt;common.value_table;</span>
        else if (NODE_IS_IFACE (node))
<span class="line-modified">!     {</span>
<span class="line-modified">!       guint i;</span>
  
<span class="line-modified">!       for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (node); i++)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           GType prtype = IFACE_NODE_PREREQUISITES (node)[i];</span>
<span class="line-modified">!           TypeNode *prnode = lookup_type_node_I (prtype);</span>
  
<span class="line-modified">!           if (prnode-&gt;is_instantiatable)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           type = prtype;</span>
<span class="line-modified">!           node = lookup_type_node_I (type);</span>
<span class="line-modified">!           goto restart_table_peek;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         }</span>
      }
      }
  
    G_READ_UNLOCK (&amp;type_rw_lock);
  
    if (vtable)
<span class="line-new-header">--- 4258,28 ---</span>
    has_refed_data = node &amp;&amp; node-&gt;data &amp;&amp; NODE_REFCOUNT (node) &gt; 0;
    has_table = has_refed_data &amp;&amp; node-&gt;data-&gt;common.value_table-&gt;value_init;
    if (has_refed_data)
      {
        if (has_table)
<span class="line-modified">!   vtable = node-&gt;data-&gt;common.value_table;</span>
        else if (NODE_IS_IFACE (node))
<span class="line-modified">!   {</span>
<span class="line-modified">!     guint i;</span>
  
<span class="line-modified">!     for (i = 0; i &lt; IFACE_NODE_N_PREREQUISITES (node); i++)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         GType prtype = IFACE_NODE_PREREQUISITES (node)[i];</span>
<span class="line-modified">!         TypeNode *prnode = lookup_type_node_I (prtype);</span>
  
<span class="line-modified">!         if (prnode-&gt;is_instantiatable)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       type = prtype;</span>
<span class="line-modified">!       node = lookup_type_node_I (type);</span>
<span class="line-modified">!       goto restart_table_peek;</span>
      }
<span class="line-added">+       }</span>
<span class="line-added">+   }</span>
      }
  
    G_READ_UNLOCK (&amp;type_rw_lock);
  
    if (vtable)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4284,11 ***</span>
  
    if (!node)
      g_warning (G_STRLOC &quot;: type id &#39;%&quot; G_GSIZE_FORMAT &quot;&#39; is invalid&quot;, type);
    if (!has_refed_data)
      g_warning (&quot;can&#39;t peek value table for type &#39;%s&#39; which is not currently referenced&quot;,
<span class="line-modified">!            type_descriptive_name_I (type));</span>
  
    return NULL;
  }
  
  const gchar *
<span class="line-new-header">--- 4287,11 ---</span>
  
    if (!node)
      g_warning (G_STRLOC &quot;: type id &#39;%&quot; G_GSIZE_FORMAT &quot;&#39; is invalid&quot;, type);
    if (!has_refed_data)
      g_warning (&quot;can&#39;t peek value table for type &#39;%s&#39; which is not currently referenced&quot;,
<span class="line-modified">!          type_descriptive_name_I (type));</span>
  
    return NULL;
  }
  
  const gchar *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4351,18 ***</span>
<span class="line-new-header">--- 4354,20 ---</span>
   * If you need to enable debugging features, use the GOBJECT_DEBUG
   * environment variable.
   *
   * Deprecated: 2.36: the type system is now initialised automatically
   */
<span class="line-added">+ G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
  void
  g_type_init_with_debug_flags (GTypeDebugFlags debug_flags)
  {
    g_assert_type_system_initialized ();
  
    if (debug_flags)
      g_message (&quot;g_type_init_with_debug_flags() is no longer supported.  Use the GOBJECT_DEBUG environment variable.&quot;);
  }
<span class="line-added">+ G_GNUC_END_IGNORE_DEPRECATIONS</span>
  
  /**
   * g_type_init:
   *
   * This function used to initialise the type system.  Since GLib 2.36,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4394,11 ***</span>
  gobject_init (void)
  {
    const gchar *env_string;
    GTypeInfo info;
    TypeNode *node;
<span class="line-modified">!   GType type;</span>
  
    /* Ensure GLib is initialized first, see
     * https://bugzilla.gnome.org/show_bug.cgi?id=756139
     */
    GLIB_PRIVATE_CALL (glib_init) ();
<span class="line-new-header">--- 4399,11 ---</span>
  gobject_init (void)
  {
    const gchar *env_string;
    GTypeInfo info;
    TypeNode *node;
<span class="line-modified">!   GType type G_GNUC_UNUSED  /* when compiling with G_DISABLE_ASSERT */;</span>
  
    /* Ensure GLib is initialized first, see
     * https://bugzilla.gnome.org/show_bug.cgi?id=756139
     */
    GLIB_PRIVATE_CALL (glib_init) ();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4601,33 ***</span>
   * Deprecated: 2.58: Use the G_ADD_PRIVATE() macro with the `G_DEFINE_*`
   *   family of macros to add instance private data to a type
   */
  void
  g_type_class_add_private (gpointer g_class,
<span class="line-modified">!               gsize    private_size)</span>
  {
    GType instance_type = ((GTypeClass *)g_class)-&gt;g_type;
    TypeNode *node = lookup_type_node_I (instance_type);
  
    g_return_if_fail (private_size &gt; 0);
    g_return_if_fail (private_size &lt;= 0xffff);
  
    if (!node || !node-&gt;is_instantiatable || !node-&gt;data || node-&gt;data-&gt;class.class != g_class)
      {
        g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (instance_type));</span>
        return;
      }
  
    if (NODE_PARENT_TYPE (node))
      {
        TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
        if (node-&gt;data-&gt;instance.private_size != pnode-&gt;data-&gt;instance.private_size)
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;g_type_class_add_private() called multiple times for the same type&quot;);</span>
<span class="line-modified">!       return;</span>
<span class="line-modified">!     }</span>
      }
  
    G_WRITE_LOCK (&amp;type_rw_lock);
  
    private_size = ALIGN_STRUCT (node-&gt;data-&gt;instance.private_size + private_size);
<span class="line-new-header">--- 4606,33 ---</span>
   * Deprecated: 2.58: Use the G_ADD_PRIVATE() macro with the `G_DEFINE_*`
   *   family of macros to add instance private data to a type
   */
  void
  g_type_class_add_private (gpointer g_class,
<span class="line-modified">!         gsize    private_size)</span>
  {
    GType instance_type = ((GTypeClass *)g_class)-&gt;g_type;
    TypeNode *node = lookup_type_node_I (instance_type);
  
    g_return_if_fail (private_size &gt; 0);
    g_return_if_fail (private_size &lt;= 0xffff);
  
    if (!node || !node-&gt;is_instantiatable || !node-&gt;data || node-&gt;data-&gt;class.class != g_class)
      {
        g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">!      type_descriptive_name_I (instance_type));</span>
        return;
      }
  
    if (NODE_PARENT_TYPE (node))
      {
        TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
        if (node-&gt;data-&gt;instance.private_size != pnode-&gt;data-&gt;instance.private_size)
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;g_type_class_add_private() called multiple times for the same type&quot;);</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
      }
  
    G_WRITE_LOCK (&amp;type_rw_lock);
  
    private_size = ALIGN_STRUCT (node-&gt;data-&gt;instance.private_size + private_size);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4648,11 ***</span>
    g_return_val_if_fail (private_size &lt;= 0xffff, 0);
  
    if (!node || !node-&gt;is_classed || !node-&gt;is_instantiatable || !node-&gt;data)
      {
        g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (class_gtype));</span>
        return 0;
      }
  
    if (node-&gt;plugin != NULL)
      {
<span class="line-new-header">--- 4653,11 ---</span>
    g_return_val_if_fail (private_size &lt;= 0xffff, 0);
  
    if (!node || !node-&gt;is_classed || !node-&gt;is_instantiatable || !node-&gt;data)
      {
        g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">!      type_descriptive_name_I (class_gtype));</span>
        return 0;
      }
  
    if (node-&gt;plugin != NULL)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4715,24 ***</span>
      return;
  
    if (!node || !node-&gt;is_classed || !node-&gt;is_instantiatable || !node-&gt;data)
      {
        g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (class_gtype));</span>
        *private_size_or_offset = 0;
        return;
      }
  
    if (NODE_PARENT_TYPE (node))
      {
        TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
        if (node-&gt;data-&gt;instance.private_size != pnode-&gt;data-&gt;instance.private_size)
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;g_type_add_instance_private() called multiple times for the same type&quot;);</span>
            *private_size_or_offset = 0;
<span class="line-modified">!       return;</span>
<span class="line-modified">!     }</span>
      }
  
    G_WRITE_LOCK (&amp;type_rw_lock);
  
    private_size = ALIGN_STRUCT (node-&gt;data-&gt;instance.private_size + *private_size_or_offset);
<span class="line-new-header">--- 4720,24 ---</span>
      return;
  
    if (!node || !node-&gt;is_classed || !node-&gt;is_instantiatable || !node-&gt;data)
      {
        g_warning (&quot;cannot add private field to invalid (non-instantiatable) type &#39;%s&#39;&quot;,
<span class="line-modified">!      type_descriptive_name_I (class_gtype));</span>
        *private_size_or_offset = 0;
        return;
      }
  
    if (NODE_PARENT_TYPE (node))
      {
        TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
        if (node-&gt;data-&gt;instance.private_size != pnode-&gt;data-&gt;instance.private_size)
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;g_type_add_instance_private() called multiple times for the same type&quot;);</span>
            *private_size_or_offset = 0;
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
      }
  
    G_WRITE_LOCK (&amp;type_rw_lock);
  
    private_size = ALIGN_STRUCT (node-&gt;data-&gt;instance.private_size + *private_size_or_offset);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4744,11 ***</span>
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  }
  
  gpointer
  g_type_instance_get_private (GTypeInstance *instance,
<span class="line-modified">!                  GType          private_type)</span>
  {
    TypeNode *node;
  
    g_return_val_if_fail (instance != NULL &amp;&amp; instance-&gt;g_class != NULL, NULL);
  
<span class="line-new-header">--- 4749,11 ---</span>
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  }
  
  gpointer
  g_type_instance_get_private (GTypeInstance *instance,
<span class="line-modified">!            GType          private_type)</span>
  {
    TypeNode *node;
  
    g_return_val_if_fail (instance != NULL &amp;&amp; instance-&gt;g_class != NULL, NULL);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4811,11 ***</span>
    return -(gint) node-&gt;data-&gt;instance.private_size;
  }
  
  /**
   * g_type_add_class_private:
<span class="line-modified">!  * @class_type: GType of an classed type</span>
   * @private_size: size of private structure
   *
   * Registers a private class structure for a classed type;
   * when the class is allocated, the private structures for
   * the class and all of its parent types are allocated
<span class="line-new-header">--- 4816,11 ---</span>
    return -(gint) node-&gt;data-&gt;instance.private_size;
  }
  
  /**
   * g_type_add_class_private:
<span class="line-modified">!  * @class_type: GType of a classed type</span>
   * @private_size: size of private structure
   *
   * Registers a private class structure for a classed type;
   * when the class is allocated, the private structures for
   * the class and all of its parent types are allocated
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4829,32 ***</span>
   *
   * Since: 2.24
   */
  void
  g_type_add_class_private (GType    class_type,
<span class="line-modified">!               gsize    private_size)</span>
  {
    TypeNode *node = lookup_type_node_I (class_type);
    gsize offset;
  
    g_return_if_fail (private_size &gt; 0);
  
    if (!node || !node-&gt;is_classed || !node-&gt;data)
      {
        g_warning (&quot;cannot add class private field to invalid type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (class_type));</span>
        return;
      }
  
    if (NODE_PARENT_TYPE (node))
      {
        TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
        if (node-&gt;data-&gt;class.class_private_size != pnode-&gt;data-&gt;class.class_private_size)
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;g_type_add_class_private() called multiple times for the same type&quot;);</span>
<span class="line-modified">!       return;</span>
<span class="line-modified">!     }</span>
      }
  
    G_WRITE_LOCK (&amp;type_rw_lock);
  
    offset = ALIGN_STRUCT (node-&gt;data-&gt;class.class_private_size);
<span class="line-new-header">--- 4834,32 ---</span>
   *
   * Since: 2.24
   */
  void
  g_type_add_class_private (GType    class_type,
<span class="line-modified">!         gsize    private_size)</span>
  {
    TypeNode *node = lookup_type_node_I (class_type);
    gsize offset;
  
    g_return_if_fail (private_size &gt; 0);
  
    if (!node || !node-&gt;is_classed || !node-&gt;data)
      {
        g_warning (&quot;cannot add class private field to invalid type &#39;%s&#39;&quot;,
<span class="line-modified">!      type_descriptive_name_I (class_type));</span>
        return;
      }
  
    if (NODE_PARENT_TYPE (node))
      {
        TypeNode *pnode = lookup_type_node_I (NODE_PARENT_TYPE (node));
        if (node-&gt;data-&gt;class.class_private_size != pnode-&gt;data-&gt;class.class_private_size)
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;g_type_add_class_private() called multiple times for the same type&quot;);</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
      }
  
    G_WRITE_LOCK (&amp;type_rw_lock);
  
    offset = ALIGN_STRUCT (node-&gt;data-&gt;class.class_private_size);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4863,11 ***</span>
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  }
  
  gpointer
  g_type_class_get_private (GTypeClass *klass,
<span class="line-modified">!               GType       private_type)</span>
  {
    TypeNode *class_node;
    TypeNode *private_node;
    TypeNode *parent_node;
    gsize offset;
<span class="line-new-header">--- 4868,11 ---</span>
    G_WRITE_UNLOCK (&amp;type_rw_lock);
  }
  
  gpointer
  g_type_class_get_private (GTypeClass *klass,
<span class="line-modified">!         GType       private_type)</span>
  {
    TypeNode *class_node;
    TypeNode *private_node;
    TypeNode *parent_node;
    gsize offset;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4876,19 ***</span>
  
    class_node = lookup_type_node_I (klass-&gt;g_type);
    if (G_UNLIKELY (!class_node || !class_node-&gt;is_classed))
      {
        g_warning (&quot;class of invalid type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (klass-&gt;g_type));</span>
        return NULL;
      }
  
    private_node = lookup_type_node_I (private_type);
    if (G_UNLIKELY (!private_node || !NODE_IS_ANCESTOR (private_node, class_node)))
      {
        g_warning (&quot;attempt to retrieve private data for invalid type &#39;%s&#39;&quot;,
<span class="line-modified">!          type_descriptive_name_I (private_type));</span>
        return NULL;
      }
  
    offset = ALIGN_STRUCT (class_node-&gt;data-&gt;class.class_size);
  
<span class="line-new-header">--- 4881,19 ---</span>
  
    class_node = lookup_type_node_I (klass-&gt;g_type);
    if (G_UNLIKELY (!class_node || !class_node-&gt;is_classed))
      {
        g_warning (&quot;class of invalid type &#39;%s&#39;&quot;,
<span class="line-modified">!      type_descriptive_name_I (klass-&gt;g_type));</span>
        return NULL;
      }
  
    private_node = lookup_type_node_I (private_type);
    if (G_UNLIKELY (!private_node || !NODE_IS_ANCESTOR (private_node, class_node)))
      {
        g_warning (&quot;attempt to retrieve private data for invalid type &#39;%s&#39;&quot;,
<span class="line-modified">!      type_descriptive_name_I (private_type));</span>
        return NULL;
      }
  
    offset = ALIGN_STRUCT (class_node-&gt;data-&gt;class.class_size);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4896,14 ***</span>
      {
        parent_node = lookup_type_node_I (NODE_PARENT_TYPE (private_node));
        g_assert (parent_node-&gt;data &amp;&amp; NODE_REFCOUNT (parent_node) &gt; 0);
  
        if (G_UNLIKELY (private_node-&gt;data-&gt;class.class_private_size == parent_node-&gt;data-&gt;class.class_private_size))
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;g_type_instance_get_class_private() requires a prior call to g_type_add_class_private()&quot;);</span>
<span class="line-modified">!       return NULL;</span>
<span class="line-modified">!     }</span>
  
        offset += ALIGN_STRUCT (parent_node-&gt;data-&gt;class.class_private_size);
      }
  
    return G_STRUCT_MEMBER_P (klass, offset);
<span class="line-new-header">--- 4901,14 ---</span>
      {
        parent_node = lookup_type_node_I (NODE_PARENT_TYPE (private_node));
        g_assert (parent_node-&gt;data &amp;&amp; NODE_REFCOUNT (parent_node) &gt; 0);
  
        if (G_UNLIKELY (private_node-&gt;data-&gt;class.class_private_size == parent_node-&gt;data-&gt;class.class_private_size))
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;g_type_instance_get_class_private() requires a prior call to g_type_add_class_private()&quot;);</span>
<span class="line-modified">!     return NULL;</span>
<span class="line-modified">!   }</span>
  
        offset += ALIGN_STRUCT (parent_node-&gt;data-&gt;class.class_private_size);
      }
  
    return G_STRUCT_MEMBER_P (klass, offset);
</pre>
<center><a href="gtype-private.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gtype.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>