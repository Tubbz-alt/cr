<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstghostpad.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /* GStreamer
  2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
  3  *                    2000 Wim Taymans &lt;wtay@chello.be&gt;
  4  *                    2005 Andy Wingo &lt;wingo@pobox.com&gt;
  5  *            2006 Edward Hervey &lt;bilboed@bilboed.com&gt;
  6  *
  7  * gstghostpad.c: Proxy pads
  8  *
  9  * This library is free software; you can redistribute it and/or
 10  * modify it under the terms of the GNU Library General Public
 11  * License as published by the Free Software Foundation; either
 12  * version 2 of the License, or (at your option) any later version.
 13  *
 14  * This library is distributed in the hope that it will be useful,
 15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 17  * Library General Public License for more details.
 18  *
 19  * You should have received a copy of the GNU Library General Public
 20  * License along with this library; if not, write to the
 21  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 22  * Boston, MA 02110-1301, USA.
 23  */
 24 
 25 /**
 26  * SECTION:gstghostpad
 27  * @title: GstGhostPad
 28  * @short_description: Pseudo link pads
 29  * @see_also: #GstPad
 30  *
 31  * GhostPads are useful when organizing pipelines with #GstBin like elements.
 32  * The idea here is to create hierarchical element graphs. The bin element
 33  * contains a sub-graph. Now one would like to treat the bin-element like any
 34  * other #GstElement. This is where GhostPads come into play. A GhostPad acts as
 35  * a proxy for another pad. Thus the bin can have sink and source ghost-pads
 36  * that are associated with sink and source pads of the child elements.
 37  *
 38  * If the target pad is known at creation time, gst_ghost_pad_new() is the
 39  * function to use to get a ghost-pad. Otherwise one can use gst_ghost_pad_new_no_target()
 40  * to create the ghost-pad and use gst_ghost_pad_set_target() to establish the
 41  * association later on.
 42  *
 43  * Note that GhostPads add overhead to the data processing of a pipeline.
 44  */
 45 
 46 #include &quot;gst_private.h&quot;
 47 #include &quot;gstinfo.h&quot;
 48 
 49 #include &quot;gstghostpad.h&quot;
 50 #include &quot;gst.h&quot;
 51 
 52 #define GST_CAT_DEFAULT GST_CAT_PADS
 53 
 54 #define GST_PROXY_PAD_CAST(obj)         ((GstProxyPad *)obj)
 55 #define GST_PROXY_PAD_PRIVATE(obj)      (GST_PROXY_PAD_CAST (obj)-&gt;priv)
 56 #define GST_PROXY_PAD_TARGET(pad)       (GST_PAD_PEER (GST_PROXY_PAD_INTERNAL (pad)))
 57 #define GST_PROXY_PAD_INTERNAL(pad)     (GST_PROXY_PAD_PRIVATE (pad)-&gt;internal)
 58 
 59 #define GST_PROXY_PAD_ACQUIRE_INTERNAL(pad, internal, retval)           \
 60   internal =                                                            \
 61       GST_PAD_CAST (gst_proxy_pad_get_internal (GST_PROXY_PAD_CAST (pad))); \
 62   if (internal == NULL)                                                 \
 63     return retval;
 64 
 65 #define GST_PROXY_PAD_RELEASE_INTERNAL(internal) gst_object_unref (internal);
 66 
 67 struct _GstProxyPadPrivate
 68 {
 69   GstPad *internal;
 70 };
 71 
 72 G_DEFINE_TYPE (GstProxyPad, gst_proxy_pad, GST_TYPE_PAD);
 73 
 74 static GstPad *gst_proxy_pad_get_target (GstPad * pad);
 75 
 76 /**
 77  * gst_proxy_pad_iterate_internal_links_default:
 78  * @pad: the #GstPad to get the internal links of.
 79  * @parent: (allow-none): the parent of @pad or %NULL
 80  *
 81  * Invoke the default iterate internal links function of the proxy pad.
 82  *
 83  * Returns: (nullable): a #GstIterator of #GstPad, or %NULL if @pad
 84  * has no parent. Unref each returned pad with gst_object_unref().
 85  */
 86 GstIterator *
 87 gst_proxy_pad_iterate_internal_links_default (GstPad * pad, GstObject * parent)
 88 {
 89   GstIterator *res = NULL;
 90   GstPad *internal;
 91   GValue v = { 0, };
 92 
 93   g_return_val_if_fail (GST_IS_PROXY_PAD (pad), NULL);
 94 
 95   GST_PROXY_PAD_ACQUIRE_INTERNAL (pad, internal, NULL);
 96 
 97   g_value_init (&amp;v, GST_TYPE_PAD);
 98   g_value_take_object (&amp;v, internal);
 99   res = gst_iterator_new_single (GST_TYPE_PAD, &amp;v);
100   g_value_unset (&amp;v);
101 
102   return res;
103 }
104 
105 /**
106  * gst_proxy_pad_chain_default:
107  * @pad: a sink #GstPad, returns GST_FLOW_ERROR if not.
108  * @parent: (allow-none): the parent of @pad or %NULL
109  * @buffer: (transfer full): the #GstBuffer to send, return GST_FLOW_ERROR
110  *     if not.
111  *
112  * Invoke the default chain function of the proxy pad.
113  *
114  * Returns: a #GstFlowReturn from the pad.
115  */
116 GstFlowReturn
117 gst_proxy_pad_chain_default (GstPad * pad, GstObject * parent,
118     GstBuffer * buffer)
119 {
120   GstFlowReturn res;
121   GstPad *internal;
122 
123   g_return_val_if_fail (GST_IS_PROXY_PAD (pad), GST_FLOW_ERROR);
124   g_return_val_if_fail (GST_IS_BUFFER (buffer), GST_FLOW_ERROR);
125 
126   GST_PROXY_PAD_ACQUIRE_INTERNAL (pad, internal, GST_FLOW_NOT_LINKED);
127   res = gst_pad_push (internal, buffer);
128   GST_PROXY_PAD_RELEASE_INTERNAL (internal);
129 
130   return res;
131 }
132 
133 /**
134  * gst_proxy_pad_chain_list_default:
135  * @pad: a sink #GstPad, returns GST_FLOW_ERROR if not.
136  * @parent: (allow-none): the parent of @pad or %NULL
137  * @list: (transfer full): the #GstBufferList to send, return GST_FLOW_ERROR
138  *     if not.
139  *
140  * Invoke the default chain list function of the proxy pad.
141  *
142  * Returns: a #GstFlowReturn from the pad.
143  */
144 GstFlowReturn
145 gst_proxy_pad_chain_list_default (GstPad * pad, GstObject * parent,
146     GstBufferList * list)
147 {
148   GstFlowReturn res;
149   GstPad *internal;
150 
151   g_return_val_if_fail (GST_IS_PROXY_PAD (pad), GST_FLOW_ERROR);
152   g_return_val_if_fail (GST_IS_BUFFER_LIST (list), GST_FLOW_ERROR);
153 
154   GST_PROXY_PAD_ACQUIRE_INTERNAL (pad, internal, GST_FLOW_NOT_LINKED);
155   res = gst_pad_push_list (internal, list);
156   GST_PROXY_PAD_RELEASE_INTERNAL (internal);
157 
158   return res;
159 }
160 
161 /**
162  * gst_proxy_pad_getrange_default:
163  * @pad: a src #GstPad, returns #GST_FLOW_ERROR if not.
164  * @parent: the parent of @pad
165  * @offset: The start offset of the buffer
166  * @size: The length of the buffer
167  * @buffer: (out callee-allocates): a pointer to hold the #GstBuffer,
168  *     returns #GST_FLOW_ERROR if %NULL.
169  *
170  * Invoke the default getrange function of the proxy pad.
171  *
172  * Returns: a #GstFlowReturn from the pad.
173  */
174 GstFlowReturn
175 gst_proxy_pad_getrange_default (GstPad * pad, GstObject * parent,
176     guint64 offset, guint size, GstBuffer ** buffer)
177 {
178   GstFlowReturn res;
179   GstPad *internal;
180 
181   g_return_val_if_fail (GST_IS_PROXY_PAD (pad), GST_FLOW_ERROR);
182   g_return_val_if_fail (buffer != NULL, GST_FLOW_ERROR);
183 
184   GST_PROXY_PAD_ACQUIRE_INTERNAL (pad, internal, GST_FLOW_NOT_LINKED);
185   res = gst_pad_pull_range (internal, offset, size, buffer);
186   GST_PROXY_PAD_RELEASE_INTERNAL (internal);
187 
188   return res;
189 }
190 
191 static GstPad *
192 gst_proxy_pad_get_target (GstPad * pad)
193 {
194   GstPad *target;
195 
196   GST_OBJECT_LOCK (pad);
197   target = gst_pad_get_peer (GST_PROXY_PAD_INTERNAL (pad));
198   GST_OBJECT_UNLOCK (pad);
199 
200   return target;
201 }
202 
203 /**
204  * gst_proxy_pad_get_internal:
205  * @pad: the #GstProxyPad
206  *
207  * Get the internal pad of @pad. Unref target pad after usage.
208  *
209  * The internal pad of a #GstGhostPad is the internally used
210  * pad of opposite direction, which is used to link to the target.
211  *
212  * Returns: (transfer full) (nullable): the target #GstProxyPad, can
213  * be %NULL.  Unref target pad after usage.
214  */
215 GstProxyPad *
216 gst_proxy_pad_get_internal (GstProxyPad * pad)
217 {
218   GstPad *internal;
219 
220   g_return_val_if_fail (GST_IS_PROXY_PAD (pad), NULL);
221 
222   GST_OBJECT_LOCK (pad);
223   internal = GST_PROXY_PAD_INTERNAL (pad);
224   if (internal)
225     gst_object_ref (internal);
226   GST_OBJECT_UNLOCK (pad);
227 
228   return GST_PROXY_PAD_CAST (internal);
229 }
230 
231 static void
232 gst_proxy_pad_class_init (GstProxyPadClass * klass)
233 {
234   g_type_class_add_private (klass, sizeof (GstProxyPadPrivate));
235 
236   /* Register common function pointer descriptions */
237   GST_DEBUG_REGISTER_FUNCPTR (gst_proxy_pad_iterate_internal_links_default);
238   GST_DEBUG_REGISTER_FUNCPTR (gst_proxy_pad_chain_default);
239   GST_DEBUG_REGISTER_FUNCPTR (gst_proxy_pad_chain_list_default);
240   GST_DEBUG_REGISTER_FUNCPTR (gst_proxy_pad_getrange_default);
241 }
242 
243 static void
244 gst_proxy_pad_init (GstProxyPad * ppad)
245 {
246   GstPad *pad = (GstPad *) ppad;
247 
248   GST_PROXY_PAD_PRIVATE (ppad) = G_TYPE_INSTANCE_GET_PRIVATE (ppad,
249       GST_TYPE_PROXY_PAD, GstProxyPadPrivate);
250 
251   gst_pad_set_iterate_internal_links_function (pad,
252       gst_proxy_pad_iterate_internal_links_default);
253 
254   GST_PAD_SET_PROXY_CAPS (pad);
255   GST_PAD_SET_PROXY_SCHEDULING (pad);
256   GST_PAD_SET_PROXY_ALLOCATION (pad);
257 }
258 
259 
260 /***********************************************************************
261  * Ghost pads, implemented as a pair of proxy pads (sort of)
262  */
263 
264 
265 #define GST_GHOST_PAD_PRIVATE(obj)  (GST_GHOST_PAD_CAST (obj)-&gt;priv)
266 
267 struct _GstGhostPadPrivate
268 {
269   /* with PROXY_LOCK */
270   gboolean constructed;
271 };
272 
273 G_DEFINE_TYPE (GstGhostPad, gst_ghost_pad, GST_TYPE_PROXY_PAD);
274 
275 static void gst_ghost_pad_dispose (GObject * object);
276 
277 static gboolean
278 gst_ghost_pad_internal_activate_push_default (GstPad * pad, GstObject * parent,
279     gboolean active)
280 {
281   gboolean ret;
282   GstPad *other;
283 
284   GST_LOG_OBJECT (pad, &quot;%sactivate push on %s:%s, we&#39;re ok&quot;,
285       (active ? &quot;&quot; : &quot;de&quot;), GST_DEBUG_PAD_NAME (pad));
286 
287   /* in both cases (SRC and SINK) we activate just the internal pad. The targets
288    * will be activated later (or already in case of a ghost sinkpad). */
289   GST_PROXY_PAD_ACQUIRE_INTERNAL (pad, other, FALSE);
290   ret = gst_pad_activate_mode (other, GST_PAD_MODE_PUSH, active);
291   GST_PROXY_PAD_RELEASE_INTERNAL (other);
292 
293   return ret;
294 }
295 
296 static gboolean
297 gst_ghost_pad_internal_activate_pull_default (GstPad * pad, GstObject * parent,
298     gboolean active)
299 {
300   gboolean ret;
301   GstPad *other;
302 
303   GST_LOG_OBJECT (pad, &quot;%sactivate pull on %s:%s&quot;, (active ? &quot;&quot; : &quot;de&quot;),
304       GST_DEBUG_PAD_NAME (pad));
305 
306   if (GST_PAD_DIRECTION (pad) == GST_PAD_SRC) {
307     /* we are activated in pull mode by our peer element, which is a sinkpad
308      * that wants to operate in pull mode. This activation has to propagate
309      * upstream through the pipeline. We call the internal activation function,
310      * which will trigger gst_ghost_pad_activate_pull_default, which propagates even
311      * further upstream */
312     GST_LOG_OBJECT (pad, &quot;pad is src, activate internal&quot;);
313     GST_PROXY_PAD_ACQUIRE_INTERNAL (pad, other, FALSE);
314     ret = gst_pad_activate_mode (other, GST_PAD_MODE_PULL, active);
315     GST_PROXY_PAD_RELEASE_INTERNAL (other);
316   } else if (G_LIKELY ((other = gst_pad_get_peer (pad)))) {
317     /* We are SINK, the ghostpad is SRC, we propagate the activation upstream
318      * since we hold a pointer to the upstream peer. */
319     GST_LOG_OBJECT (pad, &quot;activating peer&quot;);
320     ret = gst_pad_activate_mode (other, GST_PAD_MODE_PULL, active);
321     gst_object_unref (other);
322   } else if (active) {
323     /* this is failure, we can&#39;t activate pull if there is no peer */
324     GST_LOG_OBJECT (pad, &quot;not src and no peer, failing&quot;);
325     ret = FALSE;
326   } else {
327     GST_LOG_OBJECT (pad, &quot;deactivating pull, with no peer - allowing&quot;);
328     ret = TRUE;
329   }
330 
331   return ret;
332 }
333 
334 /**
335  * gst_ghost_pad_internal_activate_mode_default:
336  * @pad: the #GstPad to activate or deactivate.
337  * @parent: (allow-none): the parent of @pad or %NULL
338  * @mode: the requested activation mode
339  * @active: whether the pad should be active or not.
340  *
341  * Invoke the default activate mode function of a proxy pad that is
342  * owned by a ghost pad.
343  *
344  * Returns: %TRUE if the operation was successful.
345  */
346 gboolean
347 gst_ghost_pad_internal_activate_mode_default (GstPad * pad, GstObject * parent,
348     GstPadMode mode, gboolean active)
349 {
350   gboolean res;
351 
352   g_return_val_if_fail (GST_IS_PROXY_PAD (pad), FALSE);
353 
354   switch (mode) {
355     case GST_PAD_MODE_PULL:
356       res = gst_ghost_pad_internal_activate_pull_default (pad, parent, active);
357       break;
358     case GST_PAD_MODE_PUSH:
359       res = gst_ghost_pad_internal_activate_push_default (pad, parent, active);
360       break;
361     default:
362       GST_LOG_OBJECT (pad, &quot;unknown activation mode %d&quot;, mode);
363       res = FALSE;
364       break;
365   }
366   return res;
367 }
368 
369 static gboolean
370 gst_ghost_pad_activate_push_default (GstPad * pad, GstObject * parent,
371     gboolean active)
372 {
373   gboolean ret;
374   GstPad *other;
375 
376   g_return_val_if_fail (GST_IS_GHOST_PAD (pad), FALSE);
377 
378   GST_LOG_OBJECT (pad, &quot;%sactivate push on %s:%s, proxy internal&quot;,
379       (active ? &quot;&quot; : &quot;de&quot;), GST_DEBUG_PAD_NAME (pad));
380 
381   /* just activate the internal pad */
382   GST_PROXY_PAD_ACQUIRE_INTERNAL (pad, other, FALSE);
383   ret = gst_pad_activate_mode (other, GST_PAD_MODE_PUSH, active);
384   GST_PROXY_PAD_RELEASE_INTERNAL (other);
385 
386   return ret;
387 }
388 
389 static gboolean
390 gst_ghost_pad_activate_pull_default (GstPad * pad, GstObject * parent,
391     gboolean active)
392 {
393   gboolean ret;
394   GstPad *other;
395 
396   GST_LOG_OBJECT (pad, &quot;%sactivate pull on %s:%s&quot;, (active ? &quot;&quot; : &quot;de&quot;),
397       GST_DEBUG_PAD_NAME (pad));
398 
399   if (GST_PAD_DIRECTION (pad) == GST_PAD_SRC) {
400     /* the ghostpad is SRC and activated in pull mode by its peer, call the
401      * activation function of the internal pad to propagate the activation
402      * upstream */
403     GST_LOG_OBJECT (pad, &quot;pad is src, activate internal&quot;);
404     GST_PROXY_PAD_ACQUIRE_INTERNAL (pad, other, FALSE);
405     ret = gst_pad_activate_mode (other, GST_PAD_MODE_PULL, active);
406     GST_PROXY_PAD_RELEASE_INTERNAL (other);
407   } else if (G_LIKELY ((other = gst_pad_get_peer (pad)))) {
408     /* We are SINK and activated by the internal pad, propagate activation
409      * upstream because we hold a ref to the upstream peer */
410     GST_LOG_OBJECT (pad, &quot;activating peer&quot;);
411     ret = gst_pad_activate_mode (other, GST_PAD_MODE_PULL, active);
412     gst_object_unref (other);
413   } else if (active) {
414     /* this is failure, we can&#39;t activate pull if there is no peer */
415     GST_LOG_OBJECT (pad, &quot;not src and no peer, failing&quot;);
416     ret = FALSE;
417   } else {
418     GST_LOG_OBJECT (pad, &quot;deactivating pull, with no peer - allowing&quot;);
419     ret = TRUE;
420   }
421 
422   return ret;
423 }
424 
425 /**
426  * gst_ghost_pad_activate_mode_default:
427  * @pad: the #GstPad to activate or deactivate.
428  * @parent: (allow-none): the parent of @pad or %NULL
429  * @mode: the requested activation mode
430  * @active: whether the pad should be active or not.
431  *
432  * Invoke the default activate mode function of a ghost pad.
433  *
434  * Returns: %TRUE if the operation was successful.
435  */
436 gboolean
437 gst_ghost_pad_activate_mode_default (GstPad * pad, GstObject * parent,
438     GstPadMode mode, gboolean active)
439 {
440   gboolean res;
441 
442   g_return_val_if_fail (GST_IS_GHOST_PAD (pad), FALSE);
443 
444   switch (mode) {
445     case GST_PAD_MODE_PULL:
446       res = gst_ghost_pad_activate_pull_default (pad, parent, active);
447       break;
448     case GST_PAD_MODE_PUSH:
449       res = gst_ghost_pad_activate_push_default (pad, parent, active);
450       break;
451     default:
452       GST_LOG_OBJECT (pad, &quot;unknown activation mode %d&quot;, mode);
453       res = FALSE;
454       break;
455   }
456   return res;
457 }
458 
459 static void
460 gst_ghost_pad_class_init (GstGhostPadClass * klass)
461 {
462   GObjectClass *gobject_class = (GObjectClass *) klass;
463 
464   g_type_class_add_private (klass, sizeof (GstGhostPadPrivate));
465 
466   gobject_class-&gt;dispose = gst_ghost_pad_dispose;
467 
468   GST_DEBUG_REGISTER_FUNCPTR (gst_ghost_pad_activate_pull_default);
469   GST_DEBUG_REGISTER_FUNCPTR (gst_ghost_pad_activate_push_default);
470 }
471 
472 static void
473 gst_ghost_pad_init (GstGhostPad * pad)
474 {
475   GST_GHOST_PAD_PRIVATE (pad) = G_TYPE_INSTANCE_GET_PRIVATE (pad,
476       GST_TYPE_GHOST_PAD, GstGhostPadPrivate);
477 
478   gst_pad_set_activatemode_function (GST_PAD_CAST (pad),
479       gst_ghost_pad_activate_mode_default);
480 }
481 
482 static void
483 gst_ghost_pad_dispose (GObject * object)
484 {
485   GstPad *pad;
486   GstPad *internal;
487   GstPad *peer;
488 
489   pad = GST_PAD (object);
490 
491   GST_DEBUG_OBJECT (pad, &quot;dispose&quot;);
492 
493   gst_ghost_pad_set_target (GST_GHOST_PAD (pad), NULL);
494 
495   /* Unlink here so that gst_pad_dispose doesn&#39;t. That would lead to a call to
496    * gst_ghost_pad_unlink_default when the ghost pad is in an inconsistent state */
497   peer = gst_pad_get_peer (pad);
498   if (peer) {
499     if (GST_PAD_IS_SRC (pad))
500       gst_pad_unlink (pad, peer);
501     else
502       gst_pad_unlink (peer, pad);
503 
504     gst_object_unref (peer);
505   }
506 
507   GST_OBJECT_LOCK (pad);
508   internal = GST_PROXY_PAD_INTERNAL (pad);
509   if (internal) {
510   gst_pad_set_activatemode_function (internal, NULL);
511 
512     GST_PROXY_PAD_INTERNAL (pad) = NULL;
513     GST_PROXY_PAD_INTERNAL (internal) = NULL;
514 
515   /* disposes of the internal pad, since the ghostpad is the only possible object
516    * that has a refcount on the internal pad. */
517   gst_object_unparent (GST_OBJECT_CAST (internal));
518   }
519 
520   GST_OBJECT_UNLOCK (pad);
521 
522   G_OBJECT_CLASS (gst_ghost_pad_parent_class)-&gt;dispose (object);
523 }
524 
525 /**
526  * gst_ghost_pad_construct:
527  * @gpad: the newly allocated ghost pad
528  *
529  * Finish initialization of a newly allocated ghost pad.
530  *
531  * This function is most useful in language bindings and when subclassing
532  * #GstGhostPad; plugin and application developers normally will not call this
533  * function. Call this function directly after a call to g_object_new
534  * (GST_TYPE_GHOST_PAD, &quot;direction&quot;, @dir, ..., NULL).
535  *
536  * Returns: %TRUE if the construction succeeds, %FALSE otherwise.
537  */
538 gboolean
539 gst_ghost_pad_construct (GstGhostPad * gpad)
540 {
541   GstPadDirection dir, otherdir;
542   GstPadTemplate *templ;
543   GstPad *pad, *internal;
544 
545   g_return_val_if_fail (GST_IS_GHOST_PAD (gpad), FALSE);
546   g_return_val_if_fail (!GST_GHOST_PAD_PRIVATE (gpad)-&gt;constructed, FALSE);
547 
548   g_object_get (gpad, &quot;direction&quot;, &amp;dir, &quot;template&quot;, &amp;templ, NULL);
549 
550   g_return_val_if_fail (dir != GST_PAD_UNKNOWN, FALSE);
551 
552   pad = GST_PAD (gpad);
553 
554   /* Set directional padfunctions for ghostpad */
555   if (dir == GST_PAD_SINK) {
556     gst_pad_set_chain_function (pad, gst_proxy_pad_chain_default);
557     gst_pad_set_chain_list_function (pad, gst_proxy_pad_chain_list_default);
558   } else {
559     gst_pad_set_getrange_function (pad, gst_proxy_pad_getrange_default);
560   }
561 
562   /* INTERNAL PAD, it always exists and is child of the ghostpad */
563   otherdir = (dir == GST_PAD_SRC) ? GST_PAD_SINK : GST_PAD_SRC;
564   if (templ) {
565     internal =
566         g_object_new (GST_TYPE_PROXY_PAD, &quot;name&quot;, NULL,
567         &quot;direction&quot;, otherdir, &quot;template&quot;, templ, NULL);
568     /* release ref obtained via g_object_get */
569     gst_object_unref (templ);
570   } else {
571     internal =
572         g_object_new (GST_TYPE_PROXY_PAD, &quot;name&quot;, NULL,
573         &quot;direction&quot;, otherdir, NULL);
574   }
575   GST_PAD_UNSET_FLUSHING (internal);
576 
577   /* Set directional padfunctions for internal pad */
578   if (dir == GST_PAD_SRC) {
579     gst_pad_set_chain_function (internal, gst_proxy_pad_chain_default);
580     gst_pad_set_chain_list_function (internal,
581         gst_proxy_pad_chain_list_default);
582   } else {
583     gst_pad_set_getrange_function (internal, gst_proxy_pad_getrange_default);
584   }
585 
586   GST_OBJECT_LOCK (pad);
587 
588   /* now make the ghostpad a parent of the internal pad */
589   if (!gst_object_set_parent (GST_OBJECT_CAST (internal),
590           GST_OBJECT_CAST (pad)))
591     goto parent_failed;
592 
593   /* The ghostpad is the parent of the internal pad and is the only object that
594    * can have a refcount on the internal pad.
595    * At this point, the GstGhostPad has a refcount of 1, and the internal pad has
596    * a refcount of 1.
597    * When the refcount of the GstGhostPad drops to 0, the ghostpad will dispose
598    * its refcount on the internal pad in the dispose method by un-parenting it.
599    * This is why we don&#39;t take extra refcounts in the assignments below
600    */
601   GST_PROXY_PAD_INTERNAL (pad) = internal;
602   GST_PROXY_PAD_INTERNAL (internal) = pad;
603 
604   /* special activation functions for the internal pad */
605   gst_pad_set_activatemode_function (internal,
606       gst_ghost_pad_internal_activate_mode_default);
607 
608   GST_OBJECT_UNLOCK (pad);
609 
610   GST_GHOST_PAD_PRIVATE (gpad)-&gt;constructed = TRUE;
611   return TRUE;
612 
613   /* ERRORS */
614 parent_failed:
615   {
616     GST_WARNING_OBJECT (gpad, &quot;Could not set internal pad %s:%s&quot;,
617         GST_DEBUG_PAD_NAME (internal));
618     g_critical (&quot;Could not set internal pad %s:%s&quot;,
619         GST_DEBUG_PAD_NAME (internal));
620     GST_OBJECT_UNLOCK (pad);
621     return FALSE;
622   }
623 }
624 
625 static GstPad *
626 gst_ghost_pad_new_full (const gchar * name, GstPadDirection dir,
627     GstPadTemplate * templ)
628 {
629   GstGhostPad *ret;
630   g_return_val_if_fail (dir != GST_PAD_UNKNOWN, NULL);
631 
632   /* OBJECT CREATION */
633   if (templ) {
634     GType pad_type =
635         GST_PAD_TEMPLATE_GTYPE (templ) ==
636         G_TYPE_NONE ? GST_TYPE_GHOST_PAD : GST_PAD_TEMPLATE_GTYPE (templ);
637 
638     g_return_val_if_fail (g_type_is_a (pad_type, GST_TYPE_GHOST_PAD), NULL);
639 
640     ret = g_object_new (pad_type, &quot;name&quot;, name,
641         &quot;direction&quot;, dir, &quot;template&quot;, templ, NULL);
642   } else {
643     ret = g_object_new (GST_TYPE_GHOST_PAD, &quot;name&quot;, name,
644         &quot;direction&quot;, dir, NULL);
645   }
646 
647   if (!gst_ghost_pad_construct (ret))
648     goto construct_failed;
649 
650   return GST_PAD_CAST (ret);
651 
652 construct_failed:
653   /* already logged */
654   gst_object_unref (ret);
655   return NULL;
656 }
657 
658 /**
659  * gst_ghost_pad_new_no_target:
660  * @name: (allow-none): the name of the new pad, or %NULL to assign a default name.
661  * @dir: the direction of the ghostpad
662  *
663  * Create a new ghostpad without a target with the given direction.
664  * A target can be set on the ghostpad later with the
665  * gst_ghost_pad_set_target() function.
666  *
667  * The created ghostpad will not have a padtemplate.
668  *
669  * Returns: (transfer floating) (nullable): a new #GstPad, or %NULL in
670  * case of an error.
671  */
672 GstPad *
673 gst_ghost_pad_new_no_target (const gchar * name, GstPadDirection dir)
674 {
675   GstPad *ret;
676 
677   g_return_val_if_fail (dir != GST_PAD_UNKNOWN, NULL);
678 
679   GST_LOG (&quot;name:%s, direction:%d&quot;, GST_STR_NULL (name), dir);
680 
681   ret = gst_ghost_pad_new_full (name, dir, NULL);
682 
683   return ret;
684 }
685 
686 /**
687  * gst_ghost_pad_new:
688  * @name: (allow-none): the name of the new pad, or %NULL to assign a default name
689  * @target: (transfer none): the pad to ghost.
690  *
691  * Create a new ghostpad with @target as the target. The direction will be taken
692  * from the target pad. @target must be unlinked.
693  *
694  * Will ref the target.
695  *
696  * Returns: (transfer floating) (nullable): a new #GstPad, or %NULL in
697  * case of an error.
698  */
699 GstPad *
700 gst_ghost_pad_new (const gchar * name, GstPad * target)
701 {
702   GstPad *ret;
703 
704   g_return_val_if_fail (GST_IS_PAD (target), NULL);
705   g_return_val_if_fail (!gst_pad_is_linked (target), NULL);
706 
707   GST_LOG (&quot;name:%s, target:%s:%s&quot;, GST_STR_NULL (name),
708       GST_DEBUG_PAD_NAME (target));
709 
710   if ((ret = gst_ghost_pad_new_no_target (name, GST_PAD_DIRECTION (target))))
711     if (!gst_ghost_pad_set_target (GST_GHOST_PAD_CAST (ret), target))
712       goto set_target_failed;
713 
714   return ret;
715 
716   /* ERRORS */
717 set_target_failed:
718   {
719     GST_WARNING_OBJECT (ret, &quot;failed to set target %s:%s&quot;,
720         GST_DEBUG_PAD_NAME (target));
721     gst_object_unref (ret);
722     return NULL;
723   }
724 }
725 
726 /**
727  * gst_ghost_pad_new_from_template:
728  * @name: (allow-none): the name of the new pad, or %NULL to assign a default name.
729  * @target: (transfer none): the pad to ghost.
730  * @templ: (transfer none): the #GstPadTemplate to use on the ghostpad.
731  *
732  * Create a new ghostpad with @target as the target. The direction will be taken
733  * from the target pad. The template used on the ghostpad will be @template.
734  *
735  * Will ref the target.
736  *
737  * Returns: (transfer floating) (nullable): a new #GstPad, or %NULL in
738  * case of an error.
739  */
740 
741 GstPad *
742 gst_ghost_pad_new_from_template (const gchar * name, GstPad * target,
743     GstPadTemplate * templ)
744 {
745   GstPad *ret;
746 
747   g_return_val_if_fail (GST_IS_PAD (target), NULL);
748   g_return_val_if_fail (!gst_pad_is_linked (target), NULL);
749   g_return_val_if_fail (templ != NULL, NULL);
750   g_return_val_if_fail (GST_PAD_TEMPLATE_DIRECTION (templ) ==
751       GST_PAD_DIRECTION (target), NULL);
752 
753   GST_LOG (&quot;name:%s, target:%s:%s, templ:%p&quot;, GST_STR_NULL (name),
754       GST_DEBUG_PAD_NAME (target), templ);
755 
756   if ((ret = gst_ghost_pad_new_full (name, GST_PAD_DIRECTION (target), templ)))
757     if (!gst_ghost_pad_set_target (GST_GHOST_PAD_CAST (ret), target))
758       goto set_target_failed;
759 
760   return ret;
761 
762   /* ERRORS */
763 set_target_failed:
764   {
765     GST_WARNING_OBJECT (ret, &quot;failed to set target %s:%s&quot;,
766         GST_DEBUG_PAD_NAME (target));
767     gst_object_unref (ret);
768     return NULL;
769   }
770 }
771 
772 /**
773  * gst_ghost_pad_new_no_target_from_template:
774  * @name: (allow-none): the name of the new pad, or %NULL to assign a default name
775  * @templ: (transfer none): the #GstPadTemplate to create the ghostpad from.
776  *
777  * Create a new ghostpad based on @templ, without setting a target. The
778  * direction will be taken from the @templ.
779  *
780  * Returns: (transfer floating) (nullable): a new #GstPad, or %NULL in
781  * case of an error.
782  */
783 GstPad *
784 gst_ghost_pad_new_no_target_from_template (const gchar * name,
785     GstPadTemplate * templ)
786 {
787   GstPad *ret;
788 
789   g_return_val_if_fail (templ != NULL, NULL);
790 
791   ret =
792       gst_ghost_pad_new_full (name, GST_PAD_TEMPLATE_DIRECTION (templ), templ);
793 
794   return ret;
795 }
796 
797 /**
798  * gst_ghost_pad_get_target:
799  * @gpad: the #GstGhostPad
800  *
801  * Get the target pad of @gpad. Unref target pad after usage.
802  *
803  * Returns: (transfer full) (nullable): the target #GstPad, can be
804  * %NULL if the ghostpad has no target set. Unref target pad after
805  * usage.
806  */
807 GstPad *
808 gst_ghost_pad_get_target (GstGhostPad * gpad)
809 {
810   GstPad *ret;
811 
812   g_return_val_if_fail (GST_IS_GHOST_PAD (gpad), NULL);
813 
814   ret = gst_proxy_pad_get_target (GST_PAD_CAST (gpad));
815 
816   GST_DEBUG_OBJECT (gpad, &quot;get target %s:%s&quot;, GST_DEBUG_PAD_NAME (ret));
817 
818   return ret;
819 }
820 
821 /**
822  * gst_ghost_pad_set_target:
823  * @gpad: the #GstGhostPad
824  * @newtarget: (transfer none) (allow-none): the new pad target
825  *
826  * Set the new target of the ghostpad @gpad. Any existing target
827  * is unlinked and links to the new target are established. if @newtarget is
828  * %NULL the target will be cleared.
829  *
830  * Returns: %TRUE if the new target could be set. This function
831  *     can return %FALSE when the internal pads could not be linked.
832  */
833 gboolean
834 gst_ghost_pad_set_target (GstGhostPad * gpad, GstPad * newtarget)
835 {
836   GstPad *internal;
837   GstPad *oldtarget;
838   GstPadLinkReturn lret;
839 
840   g_return_val_if_fail (GST_IS_GHOST_PAD (gpad), FALSE);
841   g_return_val_if_fail (GST_PAD_CAST (gpad) != newtarget, FALSE);
842 
843   GST_OBJECT_LOCK (gpad);
844   internal = GST_PROXY_PAD_INTERNAL (gpad);
845 
846   if (newtarget == internal) {
847     GST_OBJECT_UNLOCK (gpad);
848     GST_WARNING_OBJECT (gpad, &quot;Target has already been set to %s:%s&quot;,
849         GST_DEBUG_PAD_NAME (newtarget));
850     return TRUE;
851   }
852 
853   if (newtarget)
854     GST_DEBUG_OBJECT (gpad, &quot;set target %s:%s&quot;, GST_DEBUG_PAD_NAME (newtarget));
855   else
856     GST_DEBUG_OBJECT (gpad, &quot;clearing target&quot;);
857 
858   /* clear old target */
859   if ((oldtarget = gst_pad_get_peer (internal))) {
860     GST_OBJECT_UNLOCK (gpad);
861 
862     /* unlink internal pad */
863     if (GST_PAD_IS_SRC (internal))
864       gst_pad_unlink (internal, oldtarget);
865     else
866       gst_pad_unlink (oldtarget, internal);
867 
868     gst_object_unref (oldtarget);
869   } else {
870     GST_OBJECT_UNLOCK (gpad);
871   }
872 
873   if (newtarget) {
874     /* and link to internal pad without any checks */
875     GST_DEBUG_OBJECT (gpad, &quot;connecting internal pad to target %&quot;
876         GST_PTR_FORMAT, newtarget);
877 
878     if (GST_PAD_IS_SRC (internal))
879       lret =
880           gst_pad_link_full (internal, newtarget, GST_PAD_LINK_CHECK_NOTHING);
881     else
882       lret =
883           gst_pad_link_full (newtarget, internal, GST_PAD_LINK_CHECK_NOTHING);
884 
885     if (lret != GST_PAD_LINK_OK)
886       goto link_failed;
887   }
888 
889   return TRUE;
890 
891   /* ERRORS */
892 link_failed:
893   {
894     GST_WARNING_OBJECT (gpad, &quot;could not link internal and target, reason:%s&quot;,
895         gst_pad_link_get_name (lret));
896     return FALSE;
897   }
898 }
    </pre>
  </body>
</html>