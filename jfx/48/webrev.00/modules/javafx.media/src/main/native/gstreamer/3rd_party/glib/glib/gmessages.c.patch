diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmessages.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmessages.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmessages.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmessages.c
@@ -44,11 +44,11 @@
  * They are not intended for normal control flow, only to give a
  * perhaps-helpful warning before giving up.
  *
  * Structured logging output is supported using g_log_structured(). This differs
  * from the traditional g_log() API in that log messages are handled as a
- * collection of key�value pairs representing individual pieces of information,
+ * collection of key-value pairs representing individual pieces of information,
  * rather than as a single string containing all the information in an arbitrary
  * format.
  *
  * The convenience macros g_info(), g_message(), g_debug(), g_warning() and g_error()
  * will use the traditional g_log() API unless you define the symbol
@@ -58,16 +58,16 @@
  * If %G_LOG_USE_STRUCTURED is defined, g_test_expect_message() will become
  * ineffective for the wrapper macros g_warning() and friends (see
  * [Testing for Messages][testing-for-messages]).
  *
  * The support for structured logging was motivated by the following needs (some
- * of which were supported previously; others weren�t):
+ * of which were supported previously; others weren't):
  *  * Support for multiple logging levels.
  *  * Structured log support with the ability to add `MESSAGE_ID`s (see
  *    g_log_structured()).
  *  * Moving the responsibility for filtering log messages from the program to
- *    the log viewer � instead of libraries and programs installing log handlers
+ *    the log viewer - instead of libraries and programs installing log handlers
  *    (with g_log_set_handler()) which filter messages before output, all log
  *    messages are outputted, and the log viewer program (such as `journalctl`)
  *    must filter them. This is based on the idea that bugs are sometimes hard
  *    to reproduce, so it is better to log everything possible and then use
  *    tools to analyse the logs than it is to not be able to reproduce a bug to
@@ -78,11 +78,11 @@
  *    all libraries and program code; rather than multiple log handlers with
  *    poorly defined interactions between them. This allows a program to easily
  *    change its logging policy by changing the writer function, for example to
  *    log to an additional location or to change what logging output fallbacks
  *    are used. The log writer functions provided by GLib are exposed publicly
- *    so they can be used from programs� log writers. This allows log writer
+ *    so they can be used from programs' log writers. This allows log writer
  *    policy and implementation to be kept separate.
  *  * If a library wants to add standard information to all of its log messages
  *    (such as library state) or to redact private data (such as passwords or
  *    network credentials), it should use a wrapper function around its
  *    g_log_structured() calls or implement that in the single log writer
@@ -107,11 +107,11 @@
  * ## Log Domains ## {#log-domains}
  *
  * Log domains may be used to broadly split up the origins of log messages.
  * Typically, there are one or a few log domains per application or library.
  * %G_LOG_DOMAIN should be used to define the default log domain for the current
- * compilation unit � it is typically defined at the top of a source file, or in
+ * compilation unit - it is typically defined at the top of a source file, or in
  * the preprocessor flags for a group of source files.
  *
  * Log domains must be unique, and it is recommended that they are the
  * application or library name, optionally followed by a hyphen and a sub-domain
  * name. For example, `bloatpad` or `bloatpad-io`.
@@ -155,12 +155,12 @@
  * they should be limited to asserting that the library aborts and prints a
  * suitable error message before aborting. This should be done with
  * g_test_trap_assert_stderr().
  *
  * If it is really necessary to test the structured log messages emitted by a
- * particular piece of code � and the code cannot be restructured to be more
- * suitable to more conventional unit testing � you should write a custom log
+ * particular piece of code - and the code cannot be restructured to be more
+ * suitable to more conventional unit testing - you should write a custom log
  * writer function (see g_log_set_writer_func()) which appends all log messages
  * to a queue. When you want to check the log messages, examine and clear the
  * queue, ignoring irrelevant log messages (for example, from log domains other
  * than the one under test).
  */
@@ -201,11 +201,11 @@
 #ifdef G_OS_UNIX
 #include <unistd.h>
 #endif
 
 #ifdef G_OS_WIN32
-#include <process.h>        /* For getpid() */
+#include <process.h>    /* For getpid() */
 #include <io.h>
 #  include <windows.h>
 
 #ifndef ENABLE_VIRTUAL_TERMINAL_PROCESSING
 #define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
@@ -491,23 +491,23 @@
 /* --- structures --- */
 typedef struct _GLogDomain  GLogDomain;
 typedef struct _GLogHandler GLogHandler;
 struct _GLogDomain
 {
-  gchar     *log_domain;
+  gchar   *log_domain;
   GLogLevelFlags fatal_mask;
-  GLogHandler   *handlers;
-  GLogDomain    *next;
+  GLogHandler *handlers;
+  GLogDomain  *next;
 };
 struct _GLogHandler
 {
-  guint      id;
+  guint    id;
   GLogLevelFlags log_level;
   GLogFunc   log_func;
   gpointer   data;
   GDestroyNotify destroy;
-  GLogHandler   *next;
+  GLogHandler *next;
 };
 
 
 /* --- variables --- */
 static GMutex         g_messages_lock;
@@ -567,12 +567,12 @@
 static gchar *fatal_msg_ptr = fatal_msg_buf;
 
 #undef write
 static inline int
 dowrite (int          fd,
-     const void  *buf,
-     unsigned int len)
+   const void  *buf,
+   unsigned int len)
 {
   if (win32_keep_fatal_message)
     {
       memcpy (fatal_msg_ptr, buf, len);
       fatal_msg_ptr += len;
@@ -588,11 +588,11 @@
 
 #endif
 
 static void
 write_string (FILE        *stream,
-          const gchar *string)
+        const gchar *string)
 {
   fputs (string, stream);
 }
 
 static void
@@ -614,11 +614,11 @@
 
   domain = g_log_domains;
   while (domain)
     {
       if (strcmp (domain->log_domain, log_domain) == 0)
-    return domain;
+  return domain;
       domain = domain->next;
     }
   return NULL;
 }
 
@@ -648,46 +648,46 @@
 
       last = NULL;
 
       work = g_log_domains;
       while (work)
-    {
-      if (work == domain)
-        {
-          if (last)
-        last->next = domain->next;
-          else
-        g_log_domains = domain->next;
-          g_free (domain->log_domain);
-          g_free (domain);
-          break;
-        }
-      last = work;
-      work = last->next;
-    }
+  {
+    if (work == domain)
+      {
+        if (last)
+    last->next = domain->next;
+        else
+    g_log_domains = domain->next;
+        g_free (domain->log_domain);
+        g_free (domain);
+        break;
+      }
+    last = work;
+    work = last->next;
+  }
     }
 }
 
 static GLogFunc
 g_log_domain_get_handler_L (GLogDomain  *domain,
-                            GLogLevelFlags log_level,
-                gpointer    *data)
+          GLogLevelFlags log_level,
+          gpointer  *data)
 {
   if (domain && log_level)
     {
       GLogHandler *handler;
 
       handler = domain->handlers;
       while (handler)
-    {
-      if ((handler->log_level & log_level) == log_level)
-        {
-          *data = handler->data;
-          return handler->log_func;
-        }
-      handler = handler->next;
-    }
+  {
+    if ((handler->log_level & log_level) == log_level)
+      {
+        *data = handler->data;
+        return handler->log_func;
+      }
+    handler = handler->next;
+  }
     }
 
   *data = default_log_data;
   return default_log_func;
 }
@@ -759,11 +759,11 @@
  *
  * Returns: the old fatal mask for the log domain
  */
 GLogLevelFlags
 g_log_set_fatal_mask (const gchar   *log_domain,
-              GLogLevelFlags fatal_mask)
+          GLogLevelFlags fatal_mask)
 {
   GLogLevelFlags old_flags;
   GLogDomain *domain;
 
   if (!log_domain)
@@ -918,11 +918,11 @@
  *
  * Since: 2.6
  */
 GLogFunc
 g_log_set_default_handler (GLogFunc log_func,
-               gpointer user_data)
+         gpointer user_data)
 {
   GLogFunc old_log_func;
 
   g_mutex_lock (&g_messages_lock);
   old_log_func = default_log_func;
@@ -983,11 +983,11 @@
  * This has no effect if structured logging is enabled; see
  * [Using Structured Logging][using-structured-logging].
  */
 void
 g_log_remove_handler (const gchar *log_domain,
-              guint    handler_id)
+          guint    handler_id)
 {
   GLogDomain *domain;
 
   g_return_if_fail (handler_id > 0);
 
@@ -1001,79 +1001,79 @@
       GLogHandler *work, *last;
 
       last = NULL;
       work = domain->handlers;
       while (work)
-    {
-      if (work->id == handler_id)
-        {
-          if (last)
-        last->next = work->next;
-          else
-        domain->handlers = work->next;
-          g_log_domain_check_free_L (domain);
-          g_mutex_unlock (&g_messages_lock);
+  {
+    if (work->id == handler_id)
+      {
+        if (last)
+    last->next = work->next;
+        else
+    domain->handlers = work->next;
+        g_log_domain_check_free_L (domain);
+        g_mutex_unlock (&g_messages_lock);
               if (work->destroy)
                 work->destroy (work->data);
-          g_free (work);
-          return;
-        }
-      last = work;
-      work = last->next;
-    }
+        g_free (work);
+        return;
+      }
+    last = work;
+    work = last->next;
+  }
     }
   g_mutex_unlock (&g_messages_lock);
   g_warning ("%s: could not find handler with id '%d' for domain \"%s\"",
-         G_STRLOC, handler_id, log_domain);
+       G_STRLOC, handler_id, log_domain);
 }
 
 #define CHAR_IS_SAFE(wc) (!((wc < 0x20 && wc != '\t' && wc != '\n' && wc != '\r') || \
-                (wc == 0x7f) || \
-                (wc >= 0x80 && wc < 0xa0)))
+          (wc == 0x7f) || \
+          (wc >= 0x80 && wc < 0xa0)))
 
 static gchar*
 strdup_convert (const gchar *string,
-        const gchar *charset)
+    const gchar *charset)
 {
   if (!g_utf8_validate (string, -1, NULL))
     {
       GString *gstring = g_string_new ("[Invalid UTF-8] ");
       guchar *p;
 
       for (p = (guchar *)string; *p; p++)
-    {
-      if (CHAR_IS_SAFE(*p) &&
-          !(*p == '\r' && *(p + 1) != '\n') &&
-          *p < 0x80)
-        g_string_append_c (gstring, *p);
-      else
-        g_string_append_printf (gstring, "\\x%02x", (guint)(guchar)*p);
-    }
+  {
+    if (CHAR_IS_SAFE(*p) &&
+        !(*p == '\r' && *(p + 1) != '\n') &&
+        *p < 0x80)
+      g_string_append_c (gstring, *p);
+    else
+      g_string_append_printf (gstring, "\\x%02x", (guint)(guchar)*p);
+  }
 
       return g_string_free (gstring, FALSE);
     }
   else
     {
       GError *err = NULL;
 
       gchar *result = g_convert_with_fallback (string, -1, charset, "UTF-8", "?", NULL, NULL, &err);
       if (result)
-    return result;
+  return result;
       else
-    {
-      /* Not thread-safe, but doesn't matter if we print the warning twice
-       */
-      static gboolean warned = FALSE;
-      if (!warned)
-        {
-          warned = TRUE;
-          _g_fprintf (stderr, "GLib: Cannot convert message: %s\n", err->message);
-        }
-      g_error_free (err);
-
-      return g_strdup (string);
-    }
+  {
+    /* Not thread-safe, but doesn't matter if we print the warning twice
+     */
+    static gboolean warned = FALSE;
+    if (!warned)
+      {
+        warned = TRUE;
+        _g_fprintf (stderr, "GLib: Cannot convert message: %s\n", err->message);
+      }
+    g_error_free (err);
+
+    return g_strdup (string);
+  }
     }
 }
 
 /* For a radix of 8 we need at most 3 output bytes for 1 input
  * byte. Additionally we might need up to 2 output bytes for the
@@ -1081,12 +1081,12 @@
  */
 #define FORMAT_UNSIGNED_BUFSIZE ((GLIB_SIZEOF_LONG * 3) + 3)
 
 static void
 format_unsigned (gchar  *buf,
-         gulong  num,
-         guint   radix)
+     gulong  num,
+     guint   radix)
 {
   gulong tmp;
   gchar c;
   gint i, n;
 
@@ -1135,23 +1135,23 @@
   while (num)
     {
       i--;
       c = (num % radix);
       if (c < 10)
-    buf[i] = c + '0';
+  buf[i] = c + '0';
       else
-    buf[i] = c + 'a' - 10;
+  buf[i] = c + 'a' - 10;
       num /= radix;
     }
 
   buf[n] = '\000';
 }
 
 /* string size big enough to hold level prefix */
 #define STRING_BUFFER_SIZE  (FORMAT_UNSIGNED_BUFSIZE + 32)
 
-#define ALERT_LEVELS        (G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING)
+#define ALERT_LEVELS    (G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING)
 
 /* these are emitted by the default log handler */
 #define DEFAULT_LEVELS (G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL | G_LOG_LEVEL_WARNING | G_LOG_LEVEL_MESSAGE)
 /* these are filtered by G_MESSAGES_DEBUG by the default log handler */
 #define INFO_LEVELS (G_LOG_LEVEL_INFO | G_LOG_LEVEL_DEBUG)
@@ -1195,16 +1195,16 @@
     case G_LOG_LEVEL_DEBUG:
       strcat (level_prefix, "DEBUG");
       break;
     default:
       if (log_level)
-    {
-      strcat (level_prefix, "LOG-");
-      format_unsigned (level_prefix + 4, log_level & G_LOG_LEVEL_MASK, 16);
-    }
+  {
+    strcat (level_prefix, "LOG-");
+    format_unsigned (level_prefix + 4, log_level & G_LOG_LEVEL_MASK, 16);
+  }
       else
-    strcat (level_prefix, "LOG");
+  strcat (level_prefix, "LOG");
       break;
     }
 
   strcat (level_prefix, color_reset (use_color));
 
@@ -1249,13 +1249,13 @@
  * If [structured logging is enabled][using-structured-logging] this will
  * output via the structured log writer function (see g_log_set_writer_func()).
  */
 void
 g_logv (const gchar   *log_domain,
-        GLogLevelFlags log_level,
-        const gchar   *format,
-    va_list        args)
+  GLogLevelFlags log_level,
+  const gchar   *format,
+  va_list        args)
 {
   gboolean was_fatal = (log_level & G_LOG_FLAG_FATAL) != 0;
   gboolean was_recursion = (log_level & G_LOG_FLAG_RECURSION) != 0;
   gchar buffer[1025], *msg, *msg_alloc = NULL;
   gint i;
@@ -1313,41 +1313,41 @@
     {
       GLogLevelFlags test_level;
 
       test_level = 1 << i;
       if (log_level & test_level)
-    {
-      GLogDomain *domain;
-      GLogFunc log_func;
-      GLogLevelFlags domain_fatal_mask;
-      gpointer data = NULL;
+  {
+    GLogDomain *domain;
+    GLogFunc log_func;
+    GLogLevelFlags domain_fatal_mask;
+    gpointer data = NULL;
           gboolean masquerade_fatal = FALSE;
           guint depth;
 
-      if (was_fatal)
-        test_level |= G_LOG_FLAG_FATAL;
-      if (was_recursion)
-        test_level |= G_LOG_FLAG_RECURSION;
+    if (was_fatal)
+      test_level |= G_LOG_FLAG_FATAL;
+    if (was_recursion)
+      test_level |= G_LOG_FLAG_RECURSION;
 
-      /* check recursion and lookup handler */
-      g_mutex_lock (&g_messages_lock);
+    /* check recursion and lookup handler */
+    g_mutex_lock (&g_messages_lock);
           depth = GPOINTER_TO_UINT (g_private_get (&g_log_depth));
-      domain = g_log_find_domain_L (log_domain ? log_domain : "");
-      if (depth)
-        test_level |= G_LOG_FLAG_RECURSION;
-      depth++;
-      domain_fatal_mask = domain ? domain->fatal_mask : G_LOG_FATAL_MASK;
-      if ((domain_fatal_mask | g_log_always_fatal) & test_level)
-        test_level |= G_LOG_FLAG_FATAL;
-      if (test_level & G_LOG_FLAG_RECURSION)
-        log_func = _g_log_fallback_handler;
-      else
-        log_func = g_log_domain_get_handler_L (domain, test_level, &data);
-      domain = NULL;
-      g_mutex_unlock (&g_messages_lock);
-
-      g_private_set (&g_log_depth, GUINT_TO_POINTER (depth));
+    domain = g_log_find_domain_L (log_domain ? log_domain : "");
+    if (depth)
+      test_level |= G_LOG_FLAG_RECURSION;
+    depth++;
+    domain_fatal_mask = domain ? domain->fatal_mask : G_LOG_FATAL_MASK;
+    if ((domain_fatal_mask | g_log_always_fatal) & test_level)
+      test_level |= G_LOG_FLAG_FATAL;
+    if (test_level & G_LOG_FLAG_RECURSION)
+      log_func = _g_log_fallback_handler;
+    else
+      log_func = g_log_domain_get_handler_L (domain, test_level, &data);
+    domain = NULL;
+    g_mutex_unlock (&g_messages_lock);
+
+    g_private_set (&g_log_depth, GUINT_TO_POINTER (depth));
 
           log_func (log_domain, test_level, msg, data);
 
           if ((test_level & G_LOG_FLAG_FATAL)
               && !(test_level & G_LOG_LEVEL_ERROR))
@@ -1356,26 +1356,28 @@
                 && !fatal_log_func (log_domain, test_level, msg, fatal_log_data);
             }
 
           if ((test_level & G_LOG_FLAG_FATAL) && !masquerade_fatal)
             {
-#ifdef G_OS_WIN32
+              /* MessageBox is allowed on UWP apps only when building against
+               * the debug CRT, which will set -D_DEBUG */
+#if defined(G_OS_WIN32) && (defined(_DEBUG) || !defined(G_WINAPI_ONLY_APP))
               if (win32_keep_fatal_message)
                 {
                   gchar *locale_msg = g_locale_from_utf8 (fatal_msg_buf, -1, NULL, NULL, NULL);
 
                   MessageBox (NULL, locale_msg, NULL,
                               MB_ICONERROR|MB_SETFOREGROUND);
                 }
-#endif /* !G_OS_WIN32 */
+#endif
 
-          _g_log_abort (!(test_level & G_LOG_FLAG_RECURSION));
-        }
+              _g_log_abort (!(test_level & G_LOG_FLAG_RECURSION));
+      }
 
-      depth--;
-      g_private_set (&g_log_depth, GUINT_TO_POINTER (depth));
-    }
+    depth--;
+    g_private_set (&g_log_depth, GUINT_TO_POINTER (depth));
+  }
     }
 
   g_free (msg_alloc);
 }
 
@@ -2163,35 +2165,28 @@
 {
 #if defined(__linux__) && !defined(__BIONIC__)
   /* FIXME: Use the new journal API for detecting whether we're writing to the
    * journal. See: https://github.com/systemd/systemd/issues/2473
    */
-  static gsize initialized;
-  static gboolean fd_is_journal = FALSE;
+  union {
+    struct sockaddr_storage storage;
+    struct sockaddr sa;
+    struct sockaddr_un un;
+  } addr;
+  socklen_t addr_len;
+  int err;
 
   if (output_fd < 0)
     return FALSE;
 
-  if (g_once_init_enter (&initialized))
-    {
-      union {
-        struct sockaddr_storage storage;
-        struct sockaddr sa;
-        struct sockaddr_un un;
-      } addr;
-      socklen_t addr_len = sizeof(addr);
-      int err = getpeername (output_fd, &addr.sa, &addr_len);
-      if (err == 0 && addr.storage.ss_family == AF_UNIX)
-        fd_is_journal = g_str_has_prefix (addr.un.sun_path, "/run/systemd/journal/");
-
-      g_once_init_leave (&initialized, TRUE);
-    }
+  addr_len = sizeof(addr);
+  err = getpeername (output_fd, &addr.sa, &addr_len);
+  if (err == 0 && addr.storage.ss_family == AF_UNIX)
+    return g_str_has_prefix (addr.un.sun_path, "/run/systemd/journal/");
+#endif
 
-  return fd_is_journal;
-#else
   return FALSE;
-#endif
 }
 
 static void escape_string (GString *string);
 
 /**
@@ -2296,11 +2291,11 @@
       const gchar *charset;
 
       msg = g_string_new (message);
       escape_string (msg);
 
-      if (g_get_charset (&charset))
+      if (g_get_console_charset (&charset))
         {
           /* charset is UTF-8 already */
           g_string_append (gstring, msg->str);
         }
       else
@@ -2618,10 +2613,13 @@
 g_log_writer_default (GLogLevelFlags   log_level,
                       const GLogField *fields,
                       gsize            n_fields,
                       gpointer         user_data)
 {
+  static gsize initialized = 0;
+  static gboolean stderr_is_journal = FALSE;
+
   g_return_val_if_fail (fields != NULL, G_LOG_WRITER_UNHANDLED);
   g_return_val_if_fail (n_fields > 0, G_LOG_WRITER_UNHANDLED);
 
   /* Disable debug message output unless specified in G_MESSAGES_DEBUG. */
   if (!(log_level & DEFAULT_LEVELS) && !(log_level >> G_LOG_LEVEL_USER_SHIFT))
@@ -2654,11 +2652,17 @@
    */
   if ((log_level & g_log_always_fatal) && !log_is_old_api (fields, n_fields))
     log_level |= G_LOG_FLAG_FATAL;
 
   /* Try logging to the systemd journal as first choice. */
-  if (g_log_writer_is_journald (fileno (stderr)) &&
+  if (g_once_init_enter (&initialized))
+    {
+      stderr_is_journal = g_log_writer_is_journald (fileno (stderr));
+      g_once_init_leave (&initialized, TRUE);
+    }
+
+  if (stderr_is_journal &&
       g_log_writer_journald (log_level, fields, n_fields, user_data) ==
       G_LOG_WRITER_HANDLED)
     goto handled;
 
   /* FIXME: Add support for the Windows log. */
@@ -2671,11 +2675,13 @@
 
 handled:
   /* Abort if the message was fatal. */
   if (log_level & G_LOG_FLAG_FATAL)
     {
-#ifdef G_OS_WIN32
+      /* MessageBox is allowed on UWP apps only when building against
+       * the debug CRT, which will set -D_DEBUG */
+#if defined(G_OS_WIN32) && (defined(_DEBUG) || !defined(G_WINAPI_ONLY_APP))
       if (!g_test_initialized ())
         {
           gchar *locale_msg = NULL;
 
           locale_msg = g_locale_from_utf8 (fatal_msg_buf, -1, NULL, NULL, NULL);
@@ -2748,33 +2754,39 @@
   return G_LOG_WRITER_HANDLED;
 }
 
 /**
  * g_return_if_fail_warning: (skip)
- * @log_domain: (nullable):
- * @pretty_function:
- * @expression: (nullable):
+ * @log_domain: (nullable): log domain
+ * @pretty_function: function containing the assertion
+ * @expression: (nullable): expression which failed
+ *
+ * Internal function used to print messages from the public g_return_if_fail()
+ * and g_return_val_if_fail() macros.
  */
 void
 g_return_if_fail_warning (const char *log_domain,
-              const char *pretty_function,
-              const char *expression)
+        const char *pretty_function,
+        const char *expression)
 {
   g_log (log_domain,
-     G_LOG_LEVEL_CRITICAL,
-     "%s: assertion '%s' failed",
-     pretty_function,
-     expression);
+   G_LOG_LEVEL_CRITICAL,
+   "%s: assertion '%s' failed",
+   pretty_function,
+   expression);
 }
 
 /**
  * g_warn_message: (skip)
- * @domain: (nullable):
- * @file:
- * @line:
- * @func:
- * @warnexpr: (nullable):
+ * @domain: (nullable): log domain
+ * @file: file containing the warning
+ * @line: line number of the warning
+ * @func: function containing the warning
+ * @warnexpr: (nullable): expression which failed
+ *
+ * Internal function used to print messages from the public g_warn_if_reached()
+ * and g_warn_if_fail() macros.
  */
 void
 g_warn_message (const char     *domain,
                 const char     *file,
                 int             line,
@@ -2795,30 +2807,30 @@
   g_free (s);
 }
 
 void
 g_assert_warning (const char *log_domain,
-          const char *file,
-          const int   line,
-          const char *pretty_function,
-          const char *expression)
+      const char *file,
+      const int   line,
+      const char *pretty_function,
+      const char *expression)
 {
   if (expression)
     g_log (log_domain,
-       G_LOG_LEVEL_ERROR,
-       "file %s: line %d (%s): assertion failed: (%s)",
-       file,
-       line,
-       pretty_function,
-       expression);
+     G_LOG_LEVEL_ERROR,
+     "file %s: line %d (%s): assertion failed: (%s)",
+     file,
+     line,
+     pretty_function,
+     expression);
   else
     g_log (log_domain,
-       G_LOG_LEVEL_ERROR,
-       "file %s: line %d (%s): should not be reached",
-       file,
-       line,
-       pretty_function);
+     G_LOG_LEVEL_ERROR,
+     "file %s: line %d (%s): should not be reached",
+     file,
+     line,
+     pretty_function);
   _g_log_abort (FALSE);
   g_abort ();
 }
 
 /**
@@ -2922,13 +2934,13 @@
  * Since: 2.34
  */
 
 void
 _g_log_fallback_handler (const gchar   *log_domain,
-             GLogLevelFlags log_level,
-             const gchar   *message,
-             gpointer       unused_data)
+       GLogLevelFlags log_level,
+       const gchar   *message,
+       gpointer       unused_data)
 {
   gchar level_prefix[STRING_BUFFER_SIZE];
 #ifndef G_OS_WIN32
   gchar pid_string[FORMAT_UNSIGNED_BUFSIZE];
 #endif
@@ -2980,55 +2992,55 @@
     {
       gboolean safe;
 
       wc = g_utf8_get_char_validated (p, -1);
       if (wc == (gunichar)-1 || wc == (gunichar)-2)
-    {
-      gchar *tmp;
-      guint pos;
+  {
+    gchar *tmp;
+    guint pos;
 
-      pos = p - string->str;
+    pos = p - string->str;
 
-      /* Emit invalid UTF-8 as hex escapes
+    /* Emit invalid UTF-8 as hex escapes
            */
-      tmp = g_strdup_printf ("\\x%02x", (guint)(guchar)*p);
-      g_string_erase (string, pos, 1);
-      g_string_insert (string, pos, tmp);
+    tmp = g_strdup_printf ("\\x%02x", (guint)(guchar)*p);
+    g_string_erase (string, pos, 1);
+    g_string_insert (string, pos, tmp);
 
-      p = string->str + (pos + 4); /* Skip over escape sequence */
+    p = string->str + (pos + 4); /* Skip over escape sequence */
 
-      g_free (tmp);
-      continue;
-    }
+    g_free (tmp);
+    continue;
+  }
       if (wc == '\r')
-    {
-      safe = *(p + 1) == '\n';
-    }
+  {
+    safe = *(p + 1) == '\n';
+  }
       else
-    {
-      safe = CHAR_IS_SAFE (wc);
-    }
+  {
+    safe = CHAR_IS_SAFE (wc);
+  }
 
       if (!safe)
-    {
-      gchar *tmp;
-      guint pos;
+  {
+    gchar *tmp;
+    guint pos;
 
-      pos = p - string->str;
+    pos = p - string->str;
 
-      /* Largest char we escape is 0x0a, so we don't have to worry
-       * about 8-digit \Uxxxxyyyy
-       */
-      tmp = g_strdup_printf ("\\u%04x", wc);
-      g_string_erase (string, pos, g_utf8_next_char (p) - p);
-      g_string_insert (string, pos, tmp);
-      g_free (tmp);
+    /* Largest char we escape is 0x0a, so we don't have to worry
+     * about 8-digit \Uxxxxyyyy
+     */
+    tmp = g_strdup_printf ("\\u%04x", wc);
+    g_string_erase (string, pos, g_utf8_next_char (p) - p);
+    g_string_insert (string, pos, tmp);
+    g_free (tmp);
 
-      p = string->str + (pos + 6); /* Skip over escape sequence */
-    }
+    p = string->str + (pos + 6); /* Skip over escape sequence */
+  }
       else
-    p = g_utf8_next_char (p);
+  p = g_utf8_next_char (p);
     }
 }
 
 /**
  * g_log_default_handler:
@@ -3064,13 +3076,13 @@
  * This has no effect if structured logging is enabled; see
  * [Using Structured Logging][using-structured-logging].
  */
 void
 g_log_default_handler (const gchar   *log_domain,
-                       GLogLevelFlags log_level,
-                       const gchar   *message,
-               gpointer       unused_data)
+           GLogLevelFlags log_level,
+           const gchar   *message,
+           gpointer       unused_data)
 {
   GLogField fields[4];
   int n_fields = 0;
 
   /* we can be called externally with recursion for whatever reason */
@@ -3107,11 +3119,11 @@
    * have already handled them. The fatal handling in the structured logging
    * API is more coarse-grained than in the old g_log() API, so we don't want
    * to use it here.
    */
   g_log_structured_array (log_level & ~G_LOG_FLAG_FATAL, fields, n_fields);
-    }
+}
 
 /**
  * g_set_print_handler:
  * @func: the new print handler
  *
@@ -3176,11 +3188,11 @@
     local_glib_print_func (string);
   else
     {
       const gchar *charset;
 
-      if (g_get_charset (&charset))
+      if (g_get_console_charset (&charset))
         fputs (string, stdout); /* charset is UTF-8 already */
       else
         {
           gchar *lstring = strdup_convert (string, charset);
 
@@ -3255,11 +3267,11 @@
     local_glib_printerr_func (string);
   else
     {
       const gchar *charset;
 
-      if (g_get_charset (&charset))
+      if (g_get_console_charset (&charset))
         fputs (string, stderr); /* charset is UTF-8 already */
       else
         {
           gchar *lstring = strdup_convert (string, charset);
 
