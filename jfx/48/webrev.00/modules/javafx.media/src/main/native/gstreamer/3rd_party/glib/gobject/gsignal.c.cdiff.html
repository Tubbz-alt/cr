<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gsignal.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gparamspecs.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gsignal.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gsignal.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 124,11 ***</span>
   * effective memory leaks of the user data if the signal handler is never
   * disconnected for some reason.
   */
  
  
<span class="line-modified">! #define REPORT_BUG      &quot;please report occurrence circumstances to gtk-devel-list@gnome.org&quot;</span>
  
  /* --- typedefs --- */
  typedef struct _SignalNode   SignalNode;
  typedef struct _SignalKey    SignalKey;
  typedef struct _Emission     Emission;
<span class="line-new-header">--- 124,11 ---</span>
   * effective memory leaks of the user data if the signal handler is never
   * disconnected for some reason.
   */
  
  
<span class="line-modified">! #define REPORT_BUG      &quot;please report occurrence circumstances to https://gitlab.gnome.org/GNOME/glib/issues/new&quot;</span>
  
  /* --- typedefs --- */
  typedef struct _SignalNode   SignalNode;
  typedef struct _SignalKey    SignalKey;
  typedef struct _Emission     Emission;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 143,66 ***</span>
    EMISSION_RESTART
  } EmissionState;
  
  
  /* --- prototypes --- */
<span class="line-modified">! static inline guint     signal_id_lookup    (GQuark       quark,</span>
<span class="line-modified">!                              GType        itype);</span>
<span class="line-modified">! static        void      signal_destroy_R    (SignalNode  *signal_node);</span>
<span class="line-modified">! static inline HandlerList*  handler_list_ensure (guint        signal_id,</span>
<span class="line-modified">!                              gpointer     instance);</span>
<span class="line-modified">! static inline HandlerList*  handler_list_lookup (guint        signal_id,</span>
<span class="line-modified">!                              gpointer     instance);</span>
<span class="line-modified">! static inline Handler*      handler_new     (guint            signal_id,</span>
<span class="line-modified">!                              gpointer         instance,</span>
<span class="line-modified">!                                                          gboolean     after);</span>
<span class="line-modified">! static        void      handler_insert      (guint        signal_id,</span>
<span class="line-modified">!                              gpointer     instance,</span>
<span class="line-modified">!                              Handler     *handler);</span>
<span class="line-modified">! static        Handler*      handler_lookup      (gpointer     instance,</span>
<span class="line-modified">!                              gulong       handler_id,</span>
<span class="line-modified">!                              GClosure        *closure,</span>
<span class="line-modified">!                              guint       *signal_id_p);</span>
<span class="line-modified">! static inline HandlerMatch* handler_match_prepend   (HandlerMatch    *list,</span>
<span class="line-modified">!                              Handler     *handler,</span>
<span class="line-modified">!                              guint        signal_id);</span>
<span class="line-modified">! static inline HandlerMatch* handler_match_free1_R   (HandlerMatch    *node,</span>
<span class="line-modified">!                              gpointer     instance);</span>
<span class="line-modified">! static        HandlerMatch* handlers_find       (gpointer     instance,</span>
<span class="line-modified">!                              GSignalMatchType mask,</span>
<span class="line-modified">!                              guint        signal_id,</span>
<span class="line-modified">!                              GQuark       detail,</span>
<span class="line-modified">!                              GClosure    *closure,</span>
<span class="line-modified">!                              gpointer     func,</span>
<span class="line-modified">!                              gpointer     data,</span>
<span class="line-modified">!                              gboolean     one_and_only);</span>
<span class="line-modified">! static inline void      handler_ref     (Handler     *handler);</span>
<span class="line-modified">! static inline void      handler_unref_R     (guint        signal_id,</span>
<span class="line-modified">!                              gpointer     instance,</span>
<span class="line-modified">!                              Handler     *handler);</span>
<span class="line-modified">! static gint         handler_lists_cmp   (gconstpointer    node1,</span>
<span class="line-modified">!                              gconstpointer    node2);</span>
<span class="line-modified">! static inline void      emission_push       (Emission    *emission);</span>
<span class="line-modified">! static inline void      emission_pop        (Emission    *emission);</span>
<span class="line-modified">! static inline Emission*     emission_find       (guint        signal_id,</span>
<span class="line-modified">!                              GQuark       detail,</span>
<span class="line-modified">!                              gpointer     instance);</span>
<span class="line-modified">! static gint         class_closures_cmp  (gconstpointer    node1,</span>
<span class="line-modified">!                              gconstpointer    node2);</span>
<span class="line-modified">! static gint         signal_key_cmp      (gconstpointer    node1,</span>
<span class="line-modified">!                              gconstpointer    node2);</span>
<span class="line-modified">! static        gboolean      signal_emit_unlocked_R  (SignalNode  *node,</span>
<span class="line-modified">!                              GQuark       detail,</span>
<span class="line-modified">!                              gpointer     instance,</span>
<span class="line-modified">!                              GValue      *return_value,</span>
<span class="line-modified">!                              const GValue    *instance_and_params);</span>
  static       void               add_invalid_closure_notify    (Handler         *handler,
<span class="line-modified">!                                    gpointer         instance);</span>
  static       void               remove_invalid_closure_notify (Handler         *handler,
<span class="line-modified">!                                    gpointer         instance);</span>
  static       void               invalid_closure_notify  (gpointer         data,
<span class="line-modified">!                              GClosure        *closure);</span>
  static const gchar *            type_debug_name         (GType            type);
  static void                     node_check_deprecated   (const SignalNode *node);
  static void                     node_update_single_va_closure (SignalNode *node);
  
  
<span class="line-new-header">--- 143,66 ---</span>
    EMISSION_RESTART
  } EmissionState;
  
  
  /* --- prototypes --- */
<span class="line-modified">! static inline guint   signal_id_lookup  (GQuark     quark,</span>
<span class="line-modified">!                GType      itype);</span>
<span class="line-modified">! static        void    signal_destroy_R  (SignalNode  *signal_node);</span>
<span class="line-modified">! static inline HandlerList*  handler_list_ensure (guint      signal_id,</span>
<span class="line-modified">!                gpointer   instance);</span>
<span class="line-modified">! static inline HandlerList*  handler_list_lookup (guint      signal_id,</span>
<span class="line-modified">!                gpointer   instance);</span>
<span class="line-modified">! static inline Handler*    handler_new   (guint            signal_id,</span>
<span class="line-modified">!                gpointer         instance,</span>
<span class="line-modified">!                                                          gboolean   after);</span>
<span class="line-modified">! static        void    handler_insert    (guint      signal_id,</span>
<span class="line-modified">!                gpointer   instance,</span>
<span class="line-modified">!                Handler   *handler);</span>
<span class="line-modified">! static        Handler*    handler_lookup    (gpointer   instance,</span>
<span class="line-modified">!                gulong     handler_id,</span>
<span class="line-modified">!                GClosure        *closure,</span>
<span class="line-modified">!                guint     *signal_id_p);</span>
<span class="line-modified">! static inline HandlerMatch* handler_match_prepend (HandlerMatch  *list,</span>
<span class="line-modified">!                Handler   *handler,</span>
<span class="line-modified">!                guint      signal_id);</span>
<span class="line-modified">! static inline HandlerMatch* handler_match_free1_R (HandlerMatch  *node,</span>
<span class="line-modified">!                gpointer   instance);</span>
<span class="line-modified">! static        HandlerMatch* handlers_find   (gpointer   instance,</span>
<span class="line-modified">!                GSignalMatchType mask,</span>
<span class="line-modified">!                guint      signal_id,</span>
<span class="line-modified">!                GQuark     detail,</span>
<span class="line-modified">!                GClosure  *closure,</span>
<span class="line-modified">!                gpointer   func,</span>
<span class="line-modified">!                gpointer   data,</span>
<span class="line-modified">!                gboolean   one_and_only);</span>
<span class="line-modified">! static inline void    handler_ref   (Handler   *handler);</span>
<span class="line-modified">! static inline void    handler_unref_R   (guint      signal_id,</span>
<span class="line-modified">!                gpointer   instance,</span>
<span class="line-modified">!                Handler   *handler);</span>
<span class="line-modified">! static gint     handler_lists_cmp (gconstpointer    node1,</span>
<span class="line-modified">!                gconstpointer    node2);</span>
<span class="line-modified">! static inline void    emission_push   (Emission  *emission);</span>
<span class="line-modified">! static inline void    emission_pop    (Emission  *emission);</span>
<span class="line-modified">! static inline Emission*   emission_find   (guint      signal_id,</span>
<span class="line-modified">!                GQuark     detail,</span>
<span class="line-modified">!                gpointer   instance);</span>
<span class="line-modified">! static gint     class_closures_cmp  (gconstpointer    node1,</span>
<span class="line-modified">!                gconstpointer    node2);</span>
<span class="line-modified">! static gint     signal_key_cmp    (gconstpointer    node1,</span>
<span class="line-modified">!                gconstpointer    node2);</span>
<span class="line-modified">! static        gboolean    signal_emit_unlocked_R  (SignalNode  *node,</span>
<span class="line-modified">!                GQuark     detail,</span>
<span class="line-modified">!                gpointer   instance,</span>
<span class="line-modified">!                GValue    *return_value,</span>
<span class="line-modified">!                const GValue  *instance_and_params);</span>
  static       void               add_invalid_closure_notify    (Handler         *handler,
<span class="line-modified">!                      gpointer         instance);</span>
  static       void               remove_invalid_closure_notify (Handler         *handler,
<span class="line-modified">!                      gpointer         instance);</span>
  static       void               invalid_closure_notify  (gpointer         data,
<span class="line-modified">!                GClosure        *closure);</span>
  static const gchar *            type_debug_name         (GType            type);
  static void                     node_check_deprecated   (const SignalNode *node);
  static void                     node_update_single_va_closure (SignalNode *node);
  
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 215,11 ***</span>
  typedef struct
  {
    GHook hook;
    GQuark detail;
  } SignalHook;
<span class="line-modified">! #define SIGNAL_HOOK(hook)   ((SignalHook*) (hook))</span>
  
  struct _SignalNode
  {
    /* permanent portion */
    guint              signal_id;
<span class="line-new-header">--- 215,11 ---</span>
  typedef struct
  {
    GHook hook;
    GQuark detail;
  } SignalHook;
<span class="line-modified">! #define SIGNAL_HOOK(hook) ((SignalHook*) (hook))</span>
  
  struct _SignalNode
  {
    /* permanent portion */
    guint              signal_id;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 230,22 ***</span>
    /* reinitializable portion */
    guint              flags : 9;
    guint              n_params : 8;
    guint              single_va_closure_is_valid : 1;
    guint              single_va_closure_is_after : 1;
<span class="line-modified">!   GType         *param_types; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */</span>
<span class="line-modified">!   GType          return_type; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */</span>
    GBSearchArray     *class_closure_bsa;
    SignalAccumulator *accumulator;
    GSignalCMarshaller c_marshaller;
    GSignalCVaMarshaller va_marshaller;
    GHookList         *emission_hooks;
  
    GClosure *single_va_closure;
  };
  
<span class="line-modified">! #define SINGLE_VA_CLOSURE_EMPTY_MAGIC GINT_TO_POINTER(1)    /* indicates single_va_closure is valid but empty */</span>
  
  struct _SignalKey
  {
    GType  itype;
    GQuark quark;
<span class="line-new-header">--- 230,22 ---</span>
    /* reinitializable portion */
    guint              flags : 9;
    guint              n_params : 8;
    guint              single_va_closure_is_valid : 1;
    guint              single_va_closure_is_after : 1;
<span class="line-modified">!   GType       *param_types; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */</span>
<span class="line-modified">!   GType        return_type; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */</span>
    GBSearchArray     *class_closure_bsa;
    SignalAccumulator *accumulator;
    GSignalCMarshaller c_marshaller;
    GSignalCVaMarshaller va_marshaller;
    GHookList         *emission_hooks;
  
    GClosure *single_va_closure;
  };
  
<span class="line-modified">! #define SINGLE_VA_CLOSURE_EMPTY_MAGIC GINT_TO_POINTER(1)  /* indicates single_va_closure is valid but empty */</span>
  
  struct _SignalKey
  {
    GType  itype;
    GQuark quark;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 256,11 ***</span>
  {
    Emission             *next;
    gpointer              instance;
    GSignalInvocationHint ihint;
    EmissionState         state;
<span class="line-modified">!   GType         chain_type;</span>
  };
  
  struct _HandlerList
  {
    guint    signal_id;
<span class="line-new-header">--- 256,11 ---</span>
  {
    Emission             *next;
    gpointer              instance;
    GSignalInvocationHint ihint;
    EmissionState         state;
<span class="line-modified">!   GType     chain_type;</span>
  };
  
  struct _HandlerList
  {
    guint    signal_id;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 272,11 ***</span>
  struct _Handler
  {
    gulong        sequential_number;
    Handler      *next;
    Handler      *prev;
<span class="line-modified">!   GQuark    detail;</span>
    guint         signal_id;
    guint         ref_count;
    guint         block_count : 16;
  #define HANDLER_MAX_BLOCK_COUNT (1 &lt;&lt; 16)
    guint         after : 1;
<span class="line-new-header">--- 272,11 ---</span>
  struct _Handler
  {
    gulong        sequential_number;
    Handler      *next;
    Handler      *prev;
<span class="line-modified">!   GQuark  detail;</span>
    guint         signal_id;
    guint         ref_count;
    guint         block_count : 16;
  #define HANDLER_MAX_BLOCK_COUNT (1 &lt;&lt; 16)
    guint         after : 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 319,12 ***</span>
  static Emission      *g_emissions = NULL;
  static gulong         g_handler_sequential_number = 1;
  static GHashTable    *g_handlers = NULL;
  
  G_LOCK_DEFINE_STATIC (g_signal_mutex);
<span class="line-modified">! #define SIGNAL_LOCK()       G_LOCK (g_signal_mutex)</span>
<span class="line-modified">! #define SIGNAL_UNLOCK()     G_UNLOCK (g_signal_mutex)</span>
  
  
  /* --- signal nodes --- */
  static guint          g_n_signal_nodes = 0;
  static SignalNode   **g_signal_nodes = NULL;
<span class="line-new-header">--- 319,12 ---</span>
  static Emission      *g_emissions = NULL;
  static gulong         g_handler_sequential_number = 1;
  static GHashTable    *g_handlers = NULL;
  
  G_LOCK_DEFINE_STATIC (g_signal_mutex);
<span class="line-modified">! #define SIGNAL_LOCK()   G_LOCK (g_signal_mutex)</span>
<span class="line-modified">! #define SIGNAL_UNLOCK()   G_UNLOCK (g_signal_mutex)</span>
  
  
  /* --- signal nodes --- */
  static guint          g_n_signal_nodes = 0;
  static SignalNode   **g_signal_nodes = NULL;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 340,11 ***</span>
  
  
  /* --- functions --- */
  static inline guint
  signal_id_lookup (GQuark quark,
<span class="line-modified">!           GType  itype)</span>
  {
    GType *ifaces, type = itype;
    SignalKey key;
    guint n_ifaces;
  
<span class="line-new-header">--- 340,11 ---</span>
  
  
  /* --- functions --- */
  static inline guint
  signal_id_lookup (GQuark quark,
<span class="line-modified">!       GType  itype)</span>
  {
    GType *ifaces, type = itype;
    SignalKey key;
    guint n_ifaces;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 357,11 ***</span>
  
        key.itype = type;
        signal_key = g_bsearch_array_lookup (g_signal_key_bsa, &amp;g_signal_key_bconfig, &amp;key);
  
        if (signal_key)
<span class="line-modified">!     return signal_key-&gt;signal_id;</span>
  
        type = g_type_parent (type);
      }
    while (type);
  
<span class="line-new-header">--- 357,11 ---</span>
  
        key.itype = type;
        signal_key = g_bsearch_array_lookup (g_signal_key_bsa, &amp;g_signal_key_bconfig, &amp;key);
  
        if (signal_key)
<span class="line-modified">!   return signal_key-&gt;signal_id;</span>
  
        type = g_type_parent (type);
      }
    while (type);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 373,23 ***</span>
  
        key.itype = ifaces[n_ifaces];
        signal_key = g_bsearch_array_lookup (g_signal_key_bsa, &amp;g_signal_key_bconfig, &amp;key);
  
        if (signal_key)
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_free (ifaces);</span>
<span class="line-modified">!       return signal_key-&gt;signal_id;</span>
<span class="line-modified">!     }</span>
      }
    g_free (ifaces);
  
    return 0;
  }
  
  static gint
  class_closures_cmp (gconstpointer node1,
<span class="line-modified">!             gconstpointer node2)</span>
  {
    const ClassClosure *c1 = node1, *c2 = node2;
  
    return G_BSEARCH_ARRAY_CMP (c1-&gt;instance_type, c2-&gt;instance_type);
  }
<span class="line-new-header">--- 373,23 ---</span>
  
        key.itype = ifaces[n_ifaces];
        signal_key = g_bsearch_array_lookup (g_signal_key_bsa, &amp;g_signal_key_bconfig, &amp;key);
  
        if (signal_key)
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_free (ifaces);</span>
<span class="line-modified">!     return signal_key-&gt;signal_id;</span>
<span class="line-modified">!   }</span>
      }
    g_free (ifaces);
  
    return 0;
  }
  
  static gint
  class_closures_cmp (gconstpointer node1,
<span class="line-modified">!         gconstpointer node2)</span>
  {
    const ClassClosure *c1 = node1, *c2 = node2;
  
    return G_BSEARCH_ARRAY_CMP (c1-&gt;instance_type, c2-&gt;instance_type);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 403,11 ***</span>
    return G_BSEARCH_ARRAY_CMP (hlist1-&gt;signal_id, hlist2-&gt;signal_id);
  }
  
  static inline HandlerList*
  handler_list_ensure (guint    signal_id,
<span class="line-modified">!              gpointer instance)</span>
  {
    GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
    HandlerList key;
  
    key.signal_id = signal_id;
<span class="line-new-header">--- 403,11 ---</span>
    return G_BSEARCH_ARRAY_CMP (hlist1-&gt;signal_id, hlist2-&gt;signal_id);
  }
  
  static inline HandlerList*
  handler_list_ensure (guint    signal_id,
<span class="line-modified">!          gpointer instance)</span>
  {
    GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
    HandlerList key;
  
    key.signal_id = signal_id;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 424,18 ***</span>
      {
        GBSearchArray *o = hlbsa;
  
        hlbsa = g_bsearch_array_insert (o, &amp;g_signal_hlbsa_bconfig, &amp;key);
        if (hlbsa != o)
<span class="line-modified">!     g_hash_table_insert (g_handler_list_bsa_ht, instance, hlbsa);</span>
      }
    return g_bsearch_array_lookup (hlbsa, &amp;g_signal_hlbsa_bconfig, &amp;key);
  }
  
  static inline HandlerList*
  handler_list_lookup (guint    signal_id,
<span class="line-modified">!              gpointer instance)</span>
  {
    GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
    HandlerList key;
  
    key.signal_id = signal_id;
<span class="line-new-header">--- 424,18 ---</span>
      {
        GBSearchArray *o = hlbsa;
  
        hlbsa = g_bsearch_array_insert (o, &amp;g_signal_hlbsa_bconfig, &amp;key);
        if (hlbsa != o)
<span class="line-modified">!   g_hash_table_insert (g_handler_list_bsa_ht, instance, hlbsa);</span>
      }
    return g_bsearch_array_lookup (hlbsa, &amp;g_signal_hlbsa_bconfig, &amp;key);
  }
  
  static inline HandlerList*
  handler_list_lookup (guint    signal_id,
<span class="line-modified">!          gpointer instance)</span>
  {
    GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
    HandlerList key;
  
    key.signal_id = signal_id;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 458,13 ***</span>
        (ha-&gt;instance  == hb-&gt;instance);
  }
  
  static Handler*
  handler_lookup (gpointer  instance,
<span class="line-modified">!         gulong    handler_id,</span>
<span class="line-modified">!         GClosure *closure,</span>
<span class="line-modified">!         guint    *signal_id_p)</span>
  {
    GBSearchArray *hlbsa;
  
    if (handler_id)
      {
<span class="line-new-header">--- 458,13 ---</span>
        (ha-&gt;instance  == hb-&gt;instance);
  }
  
  static Handler*
  handler_lookup (gpointer  instance,
<span class="line-modified">!     gulong    handler_id,</span>
<span class="line-modified">!     GClosure *closure,</span>
<span class="line-modified">!     guint    *signal_id_p)</span>
  {
    GBSearchArray *hlbsa;
  
    if (handler_id)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 500,12 ***</span>
    return NULL;
  }
  
  static inline HandlerMatch*
  handler_match_prepend (HandlerMatch *list,
<span class="line-modified">!                        Handler      *handler,</span>
<span class="line-modified">!                guint         signal_id)</span>
  {
    HandlerMatch *node;
  
    node = g_slice_new (HandlerMatch);
  #ifdef GSTREAMER_LITE
<span class="line-new-header">--- 500,12 ---</span>
    return NULL;
  }
  
  static inline HandlerMatch*
  handler_match_prepend (HandlerMatch *list,
<span class="line-modified">!            Handler      *handler,</span>
<span class="line-modified">!            guint       signal_id)</span>
  {
    HandlerMatch *node;
  
    node = g_slice_new (HandlerMatch);
  #ifdef GSTREAMER_LITE
</pre>
<hr />
<pre>
<span class="line-old-header">*** 520,11 ***</span>
  
    return node;
  }
  static inline HandlerMatch*
  handler_match_free1_R (HandlerMatch *node,
<span class="line-modified">!                gpointer      instance)</span>
  {
    HandlerMatch *next = node-&gt;next;
  
    handler_unref_R (node-&gt;signal_id, instance, node-&gt;handler);
    g_slice_free (HandlerMatch, node);
<span class="line-new-header">--- 520,11 ---</span>
  
    return node;
  }
  static inline HandlerMatch*
  handler_match_free1_R (HandlerMatch *node,
<span class="line-modified">!            gpointer      instance)</span>
  {
    HandlerMatch *next = node-&gt;next;
  
    handler_unref_R (node-&gt;signal_id, instance, node-&gt;handler);
    g_slice_free (HandlerMatch, node);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 532,48 ***</span>
    return next;
  }
  
  static HandlerMatch*
  handlers_find (gpointer         instance,
<span class="line-modified">!            GSignalMatchType mask,</span>
<span class="line-modified">!            guint            signal_id,</span>
<span class="line-modified">!            GQuark           detail,</span>
<span class="line-modified">!            GClosure        *closure,</span>
<span class="line-modified">!            gpointer         func,</span>
<span class="line-modified">!            gpointer         data,</span>
<span class="line-modified">!            gboolean         one_and_only)</span>
  {
    HandlerMatch *mlist = NULL;
  
    if (mask &amp; G_SIGNAL_MATCH_ID)
      {
        HandlerList *hlist = handler_list_lookup (signal_id, instance);
        Handler *handler;
        SignalNode *node = NULL;
  
        if (mask &amp; G_SIGNAL_MATCH_FUNC)
<span class="line-modified">!     {</span>
<span class="line-modified">!       node = LOOKUP_SIGNAL_NODE (signal_id);</span>
<span class="line-modified">!       if (!node || !node-&gt;c_marshaller)</span>
<span class="line-modified">!         return NULL;</span>
<span class="line-modified">!     }</span>
  
        mask = ~mask;
        for (handler = hlist ? hlist-&gt;handlers : NULL; handler; handler = handler-&gt;next)
          if (handler-&gt;sequential_number &amp;&amp;
<span class="line-modified">!         ((mask &amp; G_SIGNAL_MATCH_DETAIL) || handler-&gt;detail == detail) &amp;&amp;</span>
<span class="line-modified">!         ((mask &amp; G_SIGNAL_MATCH_CLOSURE) || handler-&gt;closure == closure) &amp;&amp;</span>
              ((mask &amp; G_SIGNAL_MATCH_DATA) || handler-&gt;closure-&gt;data == data) &amp;&amp;
<span class="line-modified">!         ((mask &amp; G_SIGNAL_MATCH_UNBLOCKED) || handler-&gt;block_count == 0) &amp;&amp;</span>
<span class="line-modified">!         ((mask &amp; G_SIGNAL_MATCH_FUNC) || (handler-&gt;closure-&gt;marshal == node-&gt;c_marshaller &amp;&amp;</span>
<span class="line-modified">!                           G_REAL_CLOSURE (handler-&gt;closure)-&gt;meta_marshal == NULL &amp;&amp;</span>
<span class="line-modified">!                           ((GCClosure*) handler-&gt;closure)-&gt;callback == func)))</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         mlist = handler_match_prepend (mlist, handler, signal_id);</span>
<span class="line-modified">!         if (one_and_only)</span>
<span class="line-modified">!           return mlist;</span>
<span class="line-modified">!       }</span>
      }
    else
      {
        GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
  
<span class="line-new-header">--- 532,48 ---</span>
    return next;
  }
  
  static HandlerMatch*
  handlers_find (gpointer         instance,
<span class="line-modified">!          GSignalMatchType mask,</span>
<span class="line-modified">!          guint            signal_id,</span>
<span class="line-modified">!          GQuark           detail,</span>
<span class="line-modified">!          GClosure        *closure,</span>
<span class="line-modified">!          gpointer         func,</span>
<span class="line-modified">!          gpointer         data,</span>
<span class="line-modified">!          gboolean         one_and_only)</span>
  {
    HandlerMatch *mlist = NULL;
  
    if (mask &amp; G_SIGNAL_MATCH_ID)
      {
        HandlerList *hlist = handler_list_lookup (signal_id, instance);
        Handler *handler;
        SignalNode *node = NULL;
  
        if (mask &amp; G_SIGNAL_MATCH_FUNC)
<span class="line-modified">!   {</span>
<span class="line-modified">!     node = LOOKUP_SIGNAL_NODE (signal_id);</span>
<span class="line-modified">!     if (!node || !node-&gt;c_marshaller)</span>
<span class="line-modified">!       return NULL;</span>
<span class="line-modified">!   }</span>
  
        mask = ~mask;
        for (handler = hlist ? hlist-&gt;handlers : NULL; handler; handler = handler-&gt;next)
          if (handler-&gt;sequential_number &amp;&amp;
<span class="line-modified">!       ((mask &amp; G_SIGNAL_MATCH_DETAIL) || handler-&gt;detail == detail) &amp;&amp;</span>
<span class="line-modified">!       ((mask &amp; G_SIGNAL_MATCH_CLOSURE) || handler-&gt;closure == closure) &amp;&amp;</span>
              ((mask &amp; G_SIGNAL_MATCH_DATA) || handler-&gt;closure-&gt;data == data) &amp;&amp;
<span class="line-modified">!       ((mask &amp; G_SIGNAL_MATCH_UNBLOCKED) || handler-&gt;block_count == 0) &amp;&amp;</span>
<span class="line-modified">!       ((mask &amp; G_SIGNAL_MATCH_FUNC) || (handler-&gt;closure-&gt;marshal == node-&gt;c_marshaller &amp;&amp;</span>
<span class="line-modified">!                 G_REAL_CLOSURE (handler-&gt;closure)-&gt;meta_marshal == NULL &amp;&amp;</span>
<span class="line-modified">!                 ((GCClosure*) handler-&gt;closure)-&gt;callback == func)))</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       mlist = handler_match_prepend (mlist, handler, signal_id);</span>
<span class="line-modified">!       if (one_and_only)</span>
<span class="line-modified">!         return mlist;</span>
<span class="line-modified">!     }</span>
      }
    else
      {
        GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 583,38 ***</span>
            guint i;
  
            for (i = 0; i &lt; hlbsa-&gt;n_nodes; i++)
              {
                HandlerList *hlist = g_bsearch_array_get_nth (hlbsa, &amp;g_signal_hlbsa_bconfig, i);
<span class="line-modified">!           SignalNode *node = NULL;</span>
                Handler *handler;
  
<span class="line-modified">!           if (!(mask &amp; G_SIGNAL_MATCH_FUNC))</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           node = LOOKUP_SIGNAL_NODE (hlist-&gt;signal_id);</span>
  #ifndef GSTREAMER_LITE
<span class="line-modified">!           if (!node-&gt;c_marshaller)</span>
  #else // GSTREAMER_LITE
            if (!node || !node-&gt;c_marshaller)
  #endif // GSTREAMER_LITE
<span class="line-modified">!             continue;</span>
<span class="line-modified">!         }</span>
  
                for (handler = hlist-&gt;handlers; handler; handler = handler-&gt;next)
<span class="line-modified">!         if (handler-&gt;sequential_number &amp;&amp;</span>
<span class="line-modified">!             ((mask &amp; G_SIGNAL_MATCH_DETAIL) || handler-&gt;detail == detail) &amp;&amp;</span>
                      ((mask &amp; G_SIGNAL_MATCH_CLOSURE) || handler-&gt;closure == closure) &amp;&amp;
                      ((mask &amp; G_SIGNAL_MATCH_DATA) || handler-&gt;closure-&gt;data == data) &amp;&amp;
<span class="line-modified">!             ((mask &amp; G_SIGNAL_MATCH_UNBLOCKED) || handler-&gt;block_count == 0) &amp;&amp;</span>
<span class="line-modified">!             ((mask &amp; G_SIGNAL_MATCH_FUNC) || (handler-&gt;closure-&gt;marshal == node-&gt;c_marshaller &amp;&amp;</span>
<span class="line-modified">!                               G_REAL_CLOSURE (handler-&gt;closure)-&gt;meta_marshal == NULL &amp;&amp;</span>
<span class="line-modified">!                               ((GCClosure*) handler-&gt;closure)-&gt;callback == func)))</span>
<span class="line-modified">!           {</span>
<span class="line-modified">!             mlist = handler_match_prepend (mlist, handler, hlist-&gt;signal_id);</span>
<span class="line-modified">!             if (one_and_only)</span>
<span class="line-modified">!               return mlist;</span>
<span class="line-modified">!           }</span>
              }
          }
      }
  
    return mlist;
<span class="line-new-header">--- 583,38 ---</span>
            guint i;
  
            for (i = 0; i &lt; hlbsa-&gt;n_nodes; i++)
              {
                HandlerList *hlist = g_bsearch_array_get_nth (hlbsa, &amp;g_signal_hlbsa_bconfig, i);
<span class="line-modified">!         SignalNode *node = NULL;</span>
                Handler *handler;
  
<span class="line-modified">!         if (!(mask &amp; G_SIGNAL_MATCH_FUNC))</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       node = LOOKUP_SIGNAL_NODE (hlist-&gt;signal_id);</span>
  #ifndef GSTREAMER_LITE
<span class="line-modified">!       if (!node-&gt;c_marshaller)</span>
  #else // GSTREAMER_LITE
            if (!node || !node-&gt;c_marshaller)
  #endif // GSTREAMER_LITE
<span class="line-modified">!         continue;</span>
<span class="line-modified">!     }</span>
  
                for (handler = hlist-&gt;handlers; handler; handler = handler-&gt;next)
<span class="line-modified">!     if (handler-&gt;sequential_number &amp;&amp;</span>
<span class="line-modified">!         ((mask &amp; G_SIGNAL_MATCH_DETAIL) || handler-&gt;detail == detail) &amp;&amp;</span>
                      ((mask &amp; G_SIGNAL_MATCH_CLOSURE) || handler-&gt;closure == closure) &amp;&amp;
                      ((mask &amp; G_SIGNAL_MATCH_DATA) || handler-&gt;closure-&gt;data == data) &amp;&amp;
<span class="line-modified">!         ((mask &amp; G_SIGNAL_MATCH_UNBLOCKED) || handler-&gt;block_count == 0) &amp;&amp;</span>
<span class="line-modified">!         ((mask &amp; G_SIGNAL_MATCH_FUNC) || (handler-&gt;closure-&gt;marshal == node-&gt;c_marshaller &amp;&amp;</span>
<span class="line-modified">!                   G_REAL_CLOSURE (handler-&gt;closure)-&gt;meta_marshal == NULL &amp;&amp;</span>
<span class="line-modified">!                   ((GCClosure*) handler-&gt;closure)-&gt;callback == func)))</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         mlist = handler_match_prepend (mlist, handler, hlist-&gt;signal_id);</span>
<span class="line-modified">!         if (one_and_only)</span>
<span class="line-modified">!           return mlist;</span>
<span class="line-modified">!       }</span>
              }
          }
      }
  
    return mlist;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 654,12 ***</span>
    handler-&gt;ref_count++;
  }
  
  static inline void
  handler_unref_R (guint    signal_id,
<span class="line-modified">!          gpointer instance,</span>
<span class="line-modified">!          Handler *handler)</span>
  {
    g_return_if_fail (handler-&gt;ref_count &gt; 0);
  
    handler-&gt;ref_count--;
  
<span class="line-new-header">--- 654,12 ---</span>
    handler-&gt;ref_count++;
  }
  
  static inline void
  handler_unref_R (guint    signal_id,
<span class="line-modified">!      gpointer instance,</span>
<span class="line-modified">!      Handler *handler)</span>
  {
    g_return_if_fail (handler-&gt;ref_count &gt; 0);
  
    handler-&gt;ref_count--;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 712,12 ***</span>
      }
  }
  
  static void
  handler_insert (guint    signal_id,
<span class="line-modified">!         gpointer instance,</span>
<span class="line-modified">!         Handler  *handler)</span>
  {
    HandlerList *hlist;
  
    g_assert (handler-&gt;prev == NULL &amp;&amp; handler-&gt;next == NULL); /* paranoid */
  
<span class="line-new-header">--- 712,12 ---</span>
      }
  }
  
  static void
  handler_insert (guint    signal_id,
<span class="line-modified">!     gpointer instance,</span>
<span class="line-modified">!     Handler  *handler)</span>
  {
    HandlerList *hlist;
  
    g_assert (handler-&gt;prev == NULL &amp;&amp; handler-&gt;next == NULL); /* paranoid */
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 771,28 ***</span>
        GSignalFlags run_type;
        ClassClosure * cc;
        GBSearchArray *bsa = node-&gt;class_closure_bsa;
  
        if (bsa == NULL || bsa-&gt;n_nodes == 0)
<span class="line-modified">!     closure = SINGLE_VA_CLOSURE_EMPTY_MAGIC;</span>
        else if (bsa-&gt;n_nodes == 1)
      {
<span class="line-modified">!       /* Look for default class closure (can&#39;t support non-default as it</span>
<span class="line-modified">!          chains up using GValues */</span>
<span class="line-removed">-       cc = g_bsearch_array_get_nth (bsa, &amp;g_class_closure_bconfig, 0);</span>
<span class="line-removed">-       if (cc-&gt;instance_type == 0)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           run_type = node-&gt;flags &amp; (G_SIGNAL_RUN_FIRST|G_SIGNAL_RUN_LAST|G_SIGNAL_RUN_CLEANUP);</span>
<span class="line-removed">-           /* Only support *one* of run-first or run-last, not multiple or cleanup */</span>
<span class="line-removed">-           if (run_type == G_SIGNAL_RUN_FIRST ||</span>
<span class="line-removed">-           run_type == G_SIGNAL_RUN_LAST)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           closure = cc-&gt;closure;</span>
<span class="line-removed">-           is_after = (run_type == G_SIGNAL_RUN_LAST);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         }</span>
      }
      }
  
    node-&gt;single_va_closure_is_valid = TRUE;
    node-&gt;single_va_closure = closure;
    node-&gt;single_va_closure_is_after = is_after;
<span class="line-new-header">--- 771,28 ---</span>
        GSignalFlags run_type;
        ClassClosure * cc;
        GBSearchArray *bsa = node-&gt;class_closure_bsa;
  
        if (bsa == NULL || bsa-&gt;n_nodes == 0)
<span class="line-modified">!   closure = SINGLE_VA_CLOSURE_EMPTY_MAGIC;</span>
        else if (bsa-&gt;n_nodes == 1)
<span class="line-added">+   {</span>
<span class="line-added">+     /* Look for default class closure (can&#39;t support non-default as it</span>
<span class="line-added">+        chains up using GValues */</span>
<span class="line-added">+     cc = g_bsearch_array_get_nth (bsa, &amp;g_class_closure_bconfig, 0);</span>
<span class="line-added">+     if (cc-&gt;instance_type == 0)</span>
<span class="line-added">+       {</span>
<span class="line-added">+         run_type = node-&gt;flags &amp; (G_SIGNAL_RUN_FIRST|G_SIGNAL_RUN_LAST|G_SIGNAL_RUN_CLEANUP);</span>
<span class="line-added">+         /* Only support *one* of run-first or run-last, not multiple or cleanup */</span>
<span class="line-added">+         if (run_type == G_SIGNAL_RUN_FIRST ||</span>
<span class="line-added">+       run_type == G_SIGNAL_RUN_LAST)</span>
      {
<span class="line-modified">!       closure = cc-&gt;closure;</span>
<span class="line-modified">!       is_after = (run_type == G_SIGNAL_RUN_LAST);</span>
      }
<span class="line-added">+       }</span>
<span class="line-added">+   }</span>
      }
  
    node-&gt;single_va_closure_is_valid = TRUE;
    node-&gt;single_va_closure = closure;
    node-&gt;single_va_closure_is_after = is_after;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 811,30 ***</span>
    Emission *node, *last = NULL;
  
    for (node = g_emissions; node; last = node, node = last-&gt;next)
      if (node == emission)
        {
<span class="line-modified">!     if (last)</span>
<span class="line-modified">!       last-&gt;next = node-&gt;next;</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       g_emissions = node-&gt;next;</span>
<span class="line-modified">!     return;</span>
        }
    g_assert_not_reached ();
  }
  
  static inline Emission*
  emission_find (guint     signal_id,
<span class="line-modified">!            GQuark    detail,</span>
<span class="line-modified">!            gpointer  instance)</span>
  {
    Emission *emission;
  
    for (emission = g_emissions; emission; emission = emission-&gt;next)
      if (emission-&gt;instance == instance &amp;&amp;
<span class="line-modified">!     emission-&gt;ihint.signal_id == signal_id &amp;&amp;</span>
<span class="line-modified">!     emission-&gt;ihint.detail == detail)</span>
        return emission;
    return NULL;
  }
  
  static inline Emission*
<span class="line-new-header">--- 811,30 ---</span>
    Emission *node, *last = NULL;
  
    for (node = g_emissions; node; last = node, node = last-&gt;next)
      if (node == emission)
        {
<span class="line-modified">!   if (last)</span>
<span class="line-modified">!     last-&gt;next = node-&gt;next;</span>
<span class="line-modified">!   else</span>
<span class="line-modified">!     g_emissions = node-&gt;next;</span>
<span class="line-modified">!   return;</span>
        }
    g_assert_not_reached ();
  }
  
  static inline Emission*
  emission_find (guint     signal_id,
<span class="line-modified">!          GQuark    detail,</span>
<span class="line-modified">!          gpointer  instance)</span>
  {
    Emission *emission;
  
    for (emission = g_emissions; emission; emission = emission-&gt;next)
      if (emission-&gt;instance == instance &amp;&amp;
<span class="line-modified">!   emission-&gt;ihint.signal_id == signal_id &amp;&amp;</span>
<span class="line-modified">!   emission-&gt;ihint.detail == detail)</span>
        return emission;
    return NULL;
  }
  
  static inline Emission*
</pre>
<hr />
<pre>
<span class="line-old-header">*** 845,11 ***</span>
    for (emission = g_emissions; emission; emission = emission-&gt;next)
      if (emission-&gt;instance == instance)
        return emission;
  
    return NULL;
<span class="line-modified">!       }</span>
  
  static gint
  signal_key_cmp (gconstpointer node1,
                  gconstpointer node2)
  {
<span class="line-new-header">--- 845,11 ---</span>
    for (emission = g_emissions; emission; emission = emission-&gt;next)
      if (emission-&gt;instance == instance)
        return emission;
  
    return NULL;
<span class="line-modified">! }</span>
  
  static gint
  signal_key_cmp (gconstpointer node1,
                  gconstpointer node2)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 895,11 ***</span>
            if (node-&gt;destroyed)
              g_warning (G_STRLOC &quot;: signal \&quot;%s\&quot; of type &#39;%s&#39; already destroyed&quot;,
                         node-&gt;name,
                         type_debug_name (node-&gt;itype));
            else
<span class="line-modified">!         signal_destroy_R (node);</span>
          }
      }
    SIGNAL_UNLOCK ();
  }
  
<span class="line-new-header">--- 895,11 ---</span>
            if (node-&gt;destroyed)
              g_warning (G_STRLOC &quot;: signal \&quot;%s\&quot; of type &#39;%s&#39; already destroyed&quot;,
                         node-&gt;name,
                         type_debug_name (node-&gt;itype));
            else
<span class="line-modified">!       signal_destroy_R (node);</span>
          }
      }
    SIGNAL_UNLOCK ();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 918,11 ***</span>
   * Prints a warning if used on a signal which isn&#39;t being emitted.
   */
  void
  g_signal_stop_emission (gpointer instance,
                          guint    signal_id,
<span class="line-modified">!             GQuark   detail)</span>
  {
    SignalNode *node;
  
    g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
    g_return_if_fail (signal_id &gt; 0);
<span class="line-new-header">--- 918,11 ---</span>
   * Prints a warning if used on a signal which isn&#39;t being emitted.
   */
  void
  g_signal_stop_emission (gpointer instance,
                          guint    signal_id,
<span class="line-modified">!       GQuark   detail)</span>
  {
    SignalNode *node;
  
    g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
    g_return_if_fail (signal_id &gt; 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 956,11 ***</span>
    SIGNAL_UNLOCK ();
  }
  
  static void
  signal_finalize_hook (GHookList *hook_list,
<span class="line-modified">!               GHook     *hook)</span>
  {
    GDestroyNotify destroy = hook-&gt;destroy;
  
    if (destroy)
      {
<span class="line-new-header">--- 956,11 ---</span>
    SIGNAL_UNLOCK ();
  }
  
  static void
  signal_finalize_hook (GHookList *hook_list,
<span class="line-modified">!           GHook     *hook)</span>
  {
    GDestroyNotify destroy = hook-&gt;destroy;
  
    if (destroy)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 985,14 ***</span>
   *
   * Returns: the hook id, for later use with g_signal_remove_emission_hook().
   */
  gulong
  g_signal_add_emission_hook (guint               signal_id,
<span class="line-modified">!                 GQuark              detail,</span>
<span class="line-modified">!                 GSignalEmissionHook hook_func,</span>
<span class="line-modified">!                 gpointer            hook_data,</span>
<span class="line-modified">!                 GDestroyNotify      data_destroy)</span>
  {
    static gulong seq_hook_id = 1;
    SignalNode *node;
    GHook *hook;
    SignalHook *signal_hook;
<span class="line-new-header">--- 985,14 ---</span>
   *
   * Returns: the hook id, for later use with g_signal_remove_emission_hook().
   */
  gulong
  g_signal_add_emission_hook (guint               signal_id,
<span class="line-modified">!           GQuark              detail,</span>
<span class="line-modified">!           GSignalEmissionHook hook_func,</span>
<span class="line-modified">!           gpointer            hook_data,</span>
<span class="line-modified">!           GDestroyNotify      data_destroy)</span>
  {
    static gulong seq_hook_id = 1;
    SignalNode *node;
    GHook *hook;
    SignalHook *signal_hook;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1053,11 ***</span>
   *
   * Deletes an emission hook.
   */
  void
  g_signal_remove_emission_hook (guint  signal_id,
<span class="line-modified">!                    gulong hook_id)</span>
  {
    SignalNode *node;
  
    g_return_if_fail (signal_id &gt; 0);
    g_return_if_fail (hook_id &gt; 0);
<span class="line-new-header">--- 1053,11 ---</span>
   *
   * Deletes an emission hook.
   */
  void
  g_signal_remove_emission_hook (guint  signal_id,
<span class="line-modified">!              gulong hook_id)</span>
  {
    SignalNode *node;
  
    g_return_if_fail (signal_id &gt; 0);
    g_return_if_fail (hook_id &gt; 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1078,46 ***</span>
    SIGNAL_UNLOCK ();
  }
  
  static inline guint
  signal_parse_name (const gchar *name,
<span class="line-modified">!            GType        itype,</span>
<span class="line-modified">!            GQuark      *detail_p,</span>
<span class="line-modified">!            gboolean     force_quark)</span>
  {
    const gchar *colon = strchr (name, &#39;:&#39;);
    guint signal_id;
  
    if (!colon)
      {
        signal_id = signal_id_lookup (g_quark_try_string (name), itype);
        if (signal_id &amp;&amp; detail_p)
<span class="line-modified">!     *detail_p = 0;</span>
      }
    else if (colon[1] == &#39;:&#39;)
      {
        gchar buffer[32];
        guint l = colon - name;
  
        if (l &lt; 32)
<span class="line-modified">!     {</span>
<span class="line-modified">!       memcpy (buffer, name, l);</span>
<span class="line-modified">!       buffer[l] = 0;</span>
<span class="line-modified">!       signal_id = signal_id_lookup (g_quark_try_string (buffer), itype);</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       gchar *signal = g_new (gchar, l + 1);</span>
  
<span class="line-modified">!       memcpy (signal, name, l);</span>
<span class="line-modified">!       signal[l] = 0;</span>
<span class="line-modified">!       signal_id = signal_id_lookup (g_quark_try_string (signal), itype);</span>
<span class="line-modified">!       g_free (signal);</span>
<span class="line-modified">!     }</span>
  
        if (signal_id &amp;&amp; detail_p)
<span class="line-modified">!     *detail_p = colon[2] ? (force_quark ? g_quark_from_string : g_quark_try_string) (colon + 2) : 0;</span>
      }
    else
      signal_id = 0;
    return signal_id;
  }
<span class="line-new-header">--- 1078,46 ---</span>
    SIGNAL_UNLOCK ();
  }
  
  static inline guint
  signal_parse_name (const gchar *name,
<span class="line-modified">!        GType        itype,</span>
<span class="line-modified">!        GQuark      *detail_p,</span>
<span class="line-modified">!        gboolean     force_quark)</span>
  {
    const gchar *colon = strchr (name, &#39;:&#39;);
    guint signal_id;
  
    if (!colon)
      {
        signal_id = signal_id_lookup (g_quark_try_string (name), itype);
        if (signal_id &amp;&amp; detail_p)
<span class="line-modified">!   *detail_p = 0;</span>
      }
    else if (colon[1] == &#39;:&#39;)
      {
        gchar buffer[32];
        guint l = colon - name;
  
        if (l &lt; 32)
<span class="line-modified">!   {</span>
<span class="line-modified">!     memcpy (buffer, name, l);</span>
<span class="line-modified">!     buffer[l] = 0;</span>
<span class="line-modified">!     signal_id = signal_id_lookup (g_quark_try_string (buffer), itype);</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     gchar *signal = g_new (gchar, l + 1);</span>
  
<span class="line-modified">!     memcpy (signal, name, l);</span>
<span class="line-modified">!     signal[l] = 0;</span>
<span class="line-modified">!     signal_id = signal_id_lookup (g_quark_try_string (signal), itype);</span>
<span class="line-modified">!     g_free (signal);</span>
<span class="line-modified">!   }</span>
  
        if (signal_id &amp;&amp; detail_p)
<span class="line-modified">!   *detail_p = colon[2] ? (force_quark ? g_quark_from_string : g_quark_try_string) (colon + 2) : 0;</span>
      }
    else
      signal_id = 0;
    return signal_id;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1135,14 ***</span>
   *
   * Returns: Whether the signal name could successfully be parsed and @signal_id_p and @detail_p contain valid return values.
   */
  gboolean
  g_signal_parse_name (const gchar *detailed_signal,
<span class="line-modified">!                      GType        itype,</span>
<span class="line-modified">!                      guint       *signal_id_p,</span>
<span class="line-modified">!                      GQuark      *detail_p,</span>
<span class="line-modified">!              gboolean     force_detail_quark)</span>
  {
    SignalNode *node;
    GQuark detail = 0;
    guint signal_id;
  
<span class="line-new-header">--- 1135,14 ---</span>
   *
   * Returns: Whether the signal name could successfully be parsed and @signal_id_p and @detail_p contain valid return values.
   */
  gboolean
  g_signal_parse_name (const gchar *detailed_signal,
<span class="line-modified">!          GType        itype,</span>
<span class="line-modified">!          guint       *signal_id_p,</span>
<span class="line-modified">!          GQuark      *detail_p,</span>
<span class="line-modified">!          gboolean   force_detail_quark)</span>
  {
    SignalNode *node;
    GQuark detail = 0;
    guint signal_id;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1176,11 ***</span>
   * This is just like g_signal_stop_emission() except it will look up the
   * signal id for you.
   */
  void
  g_signal_stop_emission_by_name (gpointer     instance,
<span class="line-modified">!                 const gchar *detailed_signal)</span>
  {
    guint signal_id;
    GQuark detail = 0;
    GType itype;
  
<span class="line-new-header">--- 1176,11 ---</span>
   * This is just like g_signal_stop_emission() except it will look up the
   * signal id for you.
   */
  void
  g_signal_stop_emission_by_name (gpointer     instance,
<span class="line-modified">!         const gchar *detailed_signal)</span>
  {
    guint signal_id;
    GQuark detail = 0;
    GType itype;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1193,30 ***</span>
    if (signal_id)
      {
        SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
  
        if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
<span class="line-modified">!     g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);</span>
        else if (!g_type_is_a (itype, node-&gt;itype))
          g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                     G_STRLOC, detailed_signal, instance, g_type_name (itype));
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       Emission *emission = emission_find (signal_id, detail, instance);</span>
  
<span class="line-modified">!       if (emission)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           if (emission-&gt;state == EMISSION_HOOK)</span>
<span class="line-modified">!         g_warning (G_STRLOC &quot;: emission of signal \&quot;%s\&quot; for instance &#39;%p&#39; cannot be stopped from emission hook&quot;,</span>
<span class="line-modified">!                node-&gt;name, instance);</span>
<span class="line-modified">!           else if (emission-&gt;state == EMISSION_RUN)</span>
<span class="line-modified">!         emission-&gt;state = EMISSION_STOP;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       else</span>
<span class="line-modified">!         g_warning (G_STRLOC &quot;: no emission of signal \&quot;%s\&quot; to stop for instance &#39;%p&#39;&quot;,</span>
<span class="line-modified">!                node-&gt;name, instance);</span>
<span class="line-modified">!     }</span>
      }
    else
      g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                 G_STRLOC, detailed_signal, instance, g_type_name (itype));
    SIGNAL_UNLOCK ();
<span class="line-new-header">--- 1193,30 ---</span>
    if (signal_id)
      {
        SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
  
        if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
<span class="line-modified">!   g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);</span>
        else if (!g_type_is_a (itype, node-&gt;itype))
          g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                     G_STRLOC, detailed_signal, instance, g_type_name (itype));
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     Emission *emission = emission_find (signal_id, detail, instance);</span>
  
<span class="line-modified">!     if (emission)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         if (emission-&gt;state == EMISSION_HOOK)</span>
<span class="line-modified">!     g_warning (G_STRLOC &quot;: emission of signal \&quot;%s\&quot; for instance &#39;%p&#39; cannot be stopped from emission hook&quot;,</span>
<span class="line-modified">!          node-&gt;name, instance);</span>
<span class="line-modified">!         else if (emission-&gt;state == EMISSION_RUN)</span>
<span class="line-modified">!     emission-&gt;state = EMISSION_STOP;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       g_warning (G_STRLOC &quot;: no emission of signal \&quot;%s\&quot; to stop for instance &#39;%p&#39;&quot;,</span>
<span class="line-modified">!            node-&gt;name, instance);</span>
<span class="line-modified">!   }</span>
      }
    else
      g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                 G_STRLOC, detailed_signal, instance, g_type_name (itype));
    SIGNAL_UNLOCK ();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1250,18 ***</span>
    SIGNAL_UNLOCK ();
    if (!signal_id)
      {
        /* give elaborate warnings */
        if (!g_type_name (itype))
<span class="line-modified">!     g_warning (G_STRLOC &quot;: unable to lookup signal \&quot;%s\&quot; for invalid type id &#39;%&quot;G_GSIZE_FORMAT&quot;&#39;&quot;,</span>
<span class="line-modified">!            name, itype);</span>
        else if (!G_TYPE_IS_INSTANTIATABLE (itype))
<span class="line-modified">!     g_warning (G_STRLOC &quot;: unable to lookup signal \&quot;%s\&quot; for non instantiatable type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!            name, g_type_name (itype));</span>
        else if (!g_type_class_peek (itype))
<span class="line-modified">!     g_warning (G_STRLOC &quot;: unable to lookup signal \&quot;%s\&quot; of unloaded type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!            name, g_type_name (itype));</span>
      }
  
    return signal_id;
  }
  
<span class="line-new-header">--- 1250,18 ---</span>
    SIGNAL_UNLOCK ();
    if (!signal_id)
      {
        /* give elaborate warnings */
        if (!g_type_name (itype))
<span class="line-modified">!   g_warning (G_STRLOC &quot;: unable to look up signal \&quot;%s\&quot; for invalid type id &#39;%&quot;G_GSIZE_FORMAT&quot;&#39;&quot;,</span>
<span class="line-modified">!        name, itype);</span>
        else if (!G_TYPE_IS_INSTANTIATABLE (itype))
<span class="line-modified">!   g_warning (G_STRLOC &quot;: unable to look up signal \&quot;%s\&quot; for non instantiatable type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!        name, g_type_name (itype));</span>
        else if (!g_type_class_peek (itype))
<span class="line-modified">!   g_warning (G_STRLOC &quot;: unable to look up signal \&quot;%s\&quot; of unloaded type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!        name, g_type_name (itype));</span>
      }
  
    return signal_id;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1276,11 ***</span>
   *
   * Returns: (array length=n_ids) (transfer full): Newly allocated array of signal IDs.
   */
  guint*
  g_signal_list_ids (GType  itype,
<span class="line-modified">!            guint *n_ids)</span>
  {
    SignalKey *keys;
    GArray *result;
    guint n_nodes;
    guint i;
<span class="line-new-header">--- 1276,11 ---</span>
   *
   * Returns: (array length=n_ids) (transfer full): Newly allocated array of signal IDs.
   */
  guint*
  g_signal_list_ids (GType  itype,
<span class="line-modified">!        guint *n_ids)</span>
  {
    SignalKey *keys;
    GArray *result;
    guint n_nodes;
    guint i;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1300,32 ***</span>
  #endif // GSTREAMER_LITE
  
    for (i = 0; i &lt; n_nodes; i++)
      if (keys[i].itype == itype)
        {
<span class="line-modified">!     const gchar *name = g_quark_to_string (keys[i].quark);</span>
  
<span class="line-modified">!     /* Signal names with &quot;_&quot; in them are aliases to the same</span>
<span class="line-modified">!      * name with &quot;-&quot; instead of &quot;_&quot;.</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     if (!strchr (name, &#39;_&#39;))</span>
<span class="line-modified">!       g_array_append_val (result, keys[i].signal_id);</span>
        }
    *n_ids = result-&gt;len;
    SIGNAL_UNLOCK ();
    if (!n_nodes)
      {
        /* give elaborate warnings */
        if (!g_type_name (itype))
<span class="line-modified">!     g_warning (G_STRLOC &quot;: unable to list signals for invalid type id &#39;%&quot;G_GSIZE_FORMAT&quot;&#39;&quot;,</span>
<span class="line-modified">!            itype);</span>
        else if (!G_TYPE_IS_INSTANTIATABLE (itype) &amp;&amp; !G_TYPE_IS_INTERFACE (itype))
<span class="line-modified">!     g_warning (G_STRLOC &quot;: unable to list signals of non instantiatable type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!            g_type_name (itype));</span>
        else if (!g_type_class_peek (itype) &amp;&amp; !G_TYPE_IS_INTERFACE (itype))
<span class="line-modified">!     g_warning (G_STRLOC &quot;: unable to list signals of unloaded type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!            g_type_name (itype));</span>
      }
  
    return (guint*) g_array_free (result, FALSE);
  }
  
<span class="line-new-header">--- 1300,32 ---</span>
  #endif // GSTREAMER_LITE
  
    for (i = 0; i &lt; n_nodes; i++)
      if (keys[i].itype == itype)
        {
<span class="line-modified">!   const gchar *name = g_quark_to_string (keys[i].quark);</span>
  
<span class="line-modified">!   /* Signal names with &quot;_&quot; in them are aliases to the same</span>
<span class="line-modified">!    * name with &quot;-&quot; instead of &quot;_&quot;.</span>
<span class="line-modified">!    */</span>
<span class="line-modified">!   if (!strchr (name, &#39;_&#39;))</span>
<span class="line-modified">!     g_array_append_val (result, keys[i].signal_id);</span>
        }
    *n_ids = result-&gt;len;
    SIGNAL_UNLOCK ();
    if (!n_nodes)
      {
        /* give elaborate warnings */
        if (!g_type_name (itype))
<span class="line-modified">!   g_warning (G_STRLOC &quot;: unable to list signals for invalid type id &#39;%&quot;G_GSIZE_FORMAT&quot;&#39;&quot;,</span>
<span class="line-modified">!        itype);</span>
        else if (!G_TYPE_IS_INSTANTIATABLE (itype) &amp;&amp; !G_TYPE_IS_INTERFACE (itype))
<span class="line-modified">!   g_warning (G_STRLOC &quot;: unable to list signals of non instantiatable type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!        g_type_name (itype));</span>
        else if (!g_type_class_peek (itype) &amp;&amp; !G_TYPE_IS_INTERFACE (itype))
<span class="line-modified">!   g_warning (G_STRLOC &quot;: unable to list signals of unloaded type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!        g_type_name (itype));</span>
      }
  
    return (guint*) g_array_free (result, FALSE);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1366,11 ***</span>
   * is 0. All members filled into the #GSignalQuery structure should
   * be considered constant and have to be left untouched.
   */
  void
  g_signal_query (guint         signal_id,
<span class="line-modified">!         GSignalQuery *query)</span>
  {
    SignalNode *node;
  
    g_return_if_fail (query != NULL);
  
<span class="line-new-header">--- 1366,11 ---</span>
   * is 0. All members filled into the #GSignalQuery structure should
   * be considered constant and have to be left untouched.
   */
  void
  g_signal_query (guint         signal_id,
<span class="line-modified">!     GSignalQuery *query)</span>
  {
    SignalNode *node;
  
    g_return_if_fail (query != NULL);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1423,37 ***</span>
   *
   * If 0 is used for @class_offset subclasses cannot override the class handler
   * in their class_init method by doing super_class-&gt;signal_handler = my_signal_handler.
   * Instead they will have to use g_signal_override_class_handler().
   *
<span class="line-modified">!  * If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as</span>
<span class="line-modified">!  * the marshaller for this signal.</span>
   *
   * Returns: the signal id
   */
  guint
<span class="line-modified">! g_signal_new (const gchar    *signal_name,</span>
<span class="line-modified">!           GType       itype,</span>
<span class="line-modified">!           GSignalFlags    signal_flags,</span>
<span class="line-modified">!               guint               class_offset,</span>
<span class="line-modified">!               GSignalAccumulator  accumulator,</span>
<span class="line-modified">!           gpointer        accu_data,</span>
<span class="line-modified">!               GSignalCMarshaller  c_marshaller,</span>
<span class="line-modified">!           GType       return_type,</span>
<span class="line-modified">!           guint       n_params,</span>
<span class="line-modified">!               ...)</span>
  {
    va_list args;
    guint signal_id;
  
    g_return_val_if_fail (signal_name != NULL, 0);
  
    va_start (args, n_params);
  
    signal_id = g_signal_new_valist (signal_name, itype, signal_flags,
                                     class_offset ? g_signal_type_cclosure_new (itype, class_offset) : NULL,
<span class="line-modified">!                    accumulator, accu_data, c_marshaller,</span>
                                     return_type, n_params, args);
  
    va_end (args);
  
    return signal_id;
<span class="line-new-header">--- 1423,43 ---</span>
   *
   * If 0 is used for @class_offset subclasses cannot override the class handler
   * in their class_init method by doing super_class-&gt;signal_handler = my_signal_handler.
   * Instead they will have to use g_signal_override_class_handler().
   *
<span class="line-modified">!  * If @c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as</span>
<span class="line-modified">!  * the marshaller for this signal. In some simple cases, g_signal_new()</span>
<span class="line-added">+  * will use a more optimized c_marshaller and va_marshaller for the signal</span>
<span class="line-added">+  * instead of g_cclosure_marshal_generic().</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * If @c_marshaller is non-%NULL, you need to also specify a va_marshaller</span>
<span class="line-added">+  * using g_signal_set_va_marshaller() or the generic va_marshaller will</span>
<span class="line-added">+  * be used.</span>
   *
   * Returns: the signal id
   */
  guint
<span class="line-modified">! g_signal_new (const gchar  *signal_name,</span>
<span class="line-modified">!         GType     itype,</span>
<span class="line-modified">!         GSignalFlags    signal_flags,</span>
<span class="line-modified">!         guint               class_offset,</span>
<span class="line-modified">!         GSignalAccumulator  accumulator,</span>
<span class="line-modified">!         gpointer      accu_data,</span>
<span class="line-modified">!         GSignalCMarshaller  c_marshaller,</span>
<span class="line-modified">!         GType     return_type,</span>
<span class="line-modified">!         guint     n_params,</span>
<span class="line-modified">!         ...)</span>
  {
    va_list args;
    guint signal_id;
  
    g_return_val_if_fail (signal_name != NULL, 0);
  
    va_start (args, n_params);
  
    signal_id = g_signal_new_valist (signal_name, itype, signal_flags,
                                     class_offset ? g_signal_type_cclosure_new (itype, class_offset) : NULL,
<span class="line-modified">!            accumulator, accu_data, c_marshaller,</span>
                                     return_type, n_params, args);
  
    va_end (args);
  
    return signal_id;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1529,11 ***</span>
    return signal_id;
  }
  
  static inline ClassClosure*
  signal_find_class_closure (SignalNode *node,
<span class="line-modified">!                GType       itype)</span>
  {
    GBSearchArray *bsa = node-&gt;class_closure_bsa;
    ClassClosure *cc;
  
    if (bsa)
<span class="line-new-header">--- 1535,11 ---</span>
    return signal_id;
  }
  
  static inline ClassClosure*
  signal_find_class_closure (SignalNode *node,
<span class="line-modified">!          GType       itype)</span>
  {
    GBSearchArray *bsa = node-&gt;class_closure_bsa;
    ClassClosure *cc;
  
    if (bsa)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1550,52 ***</span>
          }
  
        key.instance_type = itype;
        cc = g_bsearch_array_lookup (bsa, &amp;g_class_closure_bconfig, &amp;key);
        while (!cc &amp;&amp; key.instance_type)
<span class="line-modified">!     {</span>
<span class="line-modified">!       key.instance_type = g_type_parent (key.instance_type);</span>
<span class="line-modified">!       cc = g_bsearch_array_lookup (bsa, &amp;g_class_closure_bconfig, &amp;key);</span>
<span class="line-modified">!     }</span>
      }
    else
      cc = NULL;
    return cc;
  }
  
  static inline GClosure*
  signal_lookup_closure (SignalNode    *node,
<span class="line-modified">!                GTypeInstance *instance)</span>
  {
    ClassClosure *cc;
  
    cc = signal_find_class_closure (node, G_TYPE_FROM_INSTANCE (instance));
    return cc ? cc-&gt;closure : NULL;
  }
  
  static void
  signal_add_class_closure (SignalNode *node,
<span class="line-modified">!               GType       itype,</span>
<span class="line-modified">!               GClosure   *closure)</span>
  {
    ClassClosure key;
  
    node-&gt;single_va_closure_is_valid = FALSE;
  
    if (!node-&gt;class_closure_bsa)
      node-&gt;class_closure_bsa = g_bsearch_array_create (&amp;g_class_closure_bconfig);
    key.instance_type = itype;
    key.closure = g_closure_ref (closure);
    node-&gt;class_closure_bsa = g_bsearch_array_insert (node-&gt;class_closure_bsa,
<span class="line-modified">!                             &amp;g_class_closure_bconfig,</span>
<span class="line-modified">!                             &amp;key);</span>
    g_closure_sink (closure);
    if (node-&gt;c_marshaller &amp;&amp; closure &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (closure))
      {
        g_closure_set_marshal (closure, node-&gt;c_marshaller);
        if (node-&gt;va_marshaller)
<span class="line-modified">!     _g_closure_set_va_marshal (closure, node-&gt;va_marshaller);</span>
      }
  }
  
  /**
   * g_signal_newv:
<span class="line-new-header">--- 1556,52 ---</span>
          }
  
        key.instance_type = itype;
        cc = g_bsearch_array_lookup (bsa, &amp;g_class_closure_bconfig, &amp;key);
        while (!cc &amp;&amp; key.instance_type)
<span class="line-modified">!   {</span>
<span class="line-modified">!     key.instance_type = g_type_parent (key.instance_type);</span>
<span class="line-modified">!     cc = g_bsearch_array_lookup (bsa, &amp;g_class_closure_bconfig, &amp;key);</span>
<span class="line-modified">!   }</span>
      }
    else
      cc = NULL;
    return cc;
  }
  
  static inline GClosure*
  signal_lookup_closure (SignalNode    *node,
<span class="line-modified">!            GTypeInstance *instance)</span>
  {
    ClassClosure *cc;
  
    cc = signal_find_class_closure (node, G_TYPE_FROM_INSTANCE (instance));
    return cc ? cc-&gt;closure : NULL;
  }
  
  static void
  signal_add_class_closure (SignalNode *node,
<span class="line-modified">!         GType       itype,</span>
<span class="line-modified">!         GClosure   *closure)</span>
  {
    ClassClosure key;
  
    node-&gt;single_va_closure_is_valid = FALSE;
  
    if (!node-&gt;class_closure_bsa)
      node-&gt;class_closure_bsa = g_bsearch_array_create (&amp;g_class_closure_bconfig);
    key.instance_type = itype;
    key.closure = g_closure_ref (closure);
    node-&gt;class_closure_bsa = g_bsearch_array_insert (node-&gt;class_closure_bsa,
<span class="line-modified">!                 &amp;g_class_closure_bconfig,</span>
<span class="line-modified">!                 &amp;key);</span>
    g_closure_sink (closure);
    if (node-&gt;c_marshaller &amp;&amp; closure &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (closure))
      {
        g_closure_set_marshal (closure, node-&gt;c_marshaller);
        if (node-&gt;va_marshaller)
<span class="line-modified">!   _g_closure_set_va_marshal (closure, node-&gt;va_marshaller);</span>
      }
  }
  
  /**
   * g_signal_newv:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1631,15 ***</span>
  g_signal_newv (const gchar       *signal_name,
                 GType              itype,
                 GSignalFlags       signal_flags,
                 GClosure          *class_closure,
                 GSignalAccumulator accumulator,
<span class="line-modified">!            gpointer       accu_data,</span>
                 GSignalCMarshaller c_marshaller,
<span class="line-modified">!                GType          return_type,</span>
                 guint              n_params,
<span class="line-modified">!                GType         *param_types)</span>
  {
    gchar *name;
    guint signal_id, i;
    SignalNode *node;
    GSignalCMarshaller builtin_c_marshaller;
<span class="line-new-header">--- 1637,15 ---</span>
  g_signal_newv (const gchar       *signal_name,
                 GType              itype,
                 GSignalFlags       signal_flags,
                 GClosure          *class_closure,
                 GSignalAccumulator accumulator,
<span class="line-modified">!          gpointer     accu_data,</span>
                 GSignalCMarshaller c_marshaller,
<span class="line-modified">!                GType      return_type,</span>
                 guint              n_params,
<span class="line-modified">!                GType     *param_types)</span>
  {
    gchar *name;
    guint signal_id, i;
    SignalNode *node;
    GSignalCMarshaller builtin_c_marshaller;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1684,29 ***</span>
        return 0;
      }
    for (i = 0; i &lt; n_params; i++)
      if (!G_TYPE_IS_VALUE (param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
        {
<span class="line-modified">!     g_warning (G_STRLOC &quot;: parameter %d of type &#39;%s&#39; for signal \&quot;%s::%s\&quot; is not a value type&quot;,</span>
<span class="line-modified">!            i + 1, type_debug_name (param_types[i]), type_debug_name (itype), name);</span>
<span class="line-modified">!     g_free (name);</span>
<span class="line-modified">!     SIGNAL_UNLOCK ();</span>
<span class="line-modified">!     return 0;</span>
        }
    if (return_type != G_TYPE_NONE &amp;&amp; !G_TYPE_IS_VALUE (return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
      {
        g_warning (G_STRLOC &quot;: return value of type &#39;%s&#39; for signal \&quot;%s::%s\&quot; is not a value type&quot;,
<span class="line-modified">!          type_debug_name (return_type), type_debug_name (itype), name);</span>
        g_free (name);
        SIGNAL_UNLOCK ();
        return 0;
      }
    if (return_type != G_TYPE_NONE &amp;&amp;
        (signal_flags &amp; (G_SIGNAL_RUN_FIRST | G_SIGNAL_RUN_LAST | G_SIGNAL_RUN_CLEANUP)) == G_SIGNAL_RUN_FIRST)
      {
        g_warning (G_STRLOC &quot;: signal \&quot;%s::%s\&quot; has return type &#39;%s&#39; and is only G_SIGNAL_RUN_FIRST&quot;,
<span class="line-modified">!          type_debug_name (itype), name, type_debug_name (return_type));</span>
        g_free (name);
        SIGNAL_UNLOCK ();
        return 0;
      }
  
<span class="line-new-header">--- 1690,29 ---</span>
        return 0;
      }
    for (i = 0; i &lt; n_params; i++)
      if (!G_TYPE_IS_VALUE (param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
        {
<span class="line-modified">!   g_warning (G_STRLOC &quot;: parameter %d of type &#39;%s&#39; for signal \&quot;%s::%s\&quot; is not a value type&quot;,</span>
<span class="line-modified">!        i + 1, type_debug_name (param_types[i]), type_debug_name (itype), name);</span>
<span class="line-modified">!   g_free (name);</span>
<span class="line-modified">!   SIGNAL_UNLOCK ();</span>
<span class="line-modified">!   return 0;</span>
        }
    if (return_type != G_TYPE_NONE &amp;&amp; !G_TYPE_IS_VALUE (return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
      {
        g_warning (G_STRLOC &quot;: return value of type &#39;%s&#39; for signal \&quot;%s::%s\&quot; is not a value type&quot;,
<span class="line-modified">!      type_debug_name (return_type), type_debug_name (itype), name);</span>
        g_free (name);
        SIGNAL_UNLOCK ();
        return 0;
      }
    if (return_type != G_TYPE_NONE &amp;&amp;
        (signal_flags &amp; (G_SIGNAL_RUN_FIRST | G_SIGNAL_RUN_LAST | G_SIGNAL_RUN_CLEANUP)) == G_SIGNAL_RUN_FIRST)
      {
        g_warning (G_STRLOC &quot;: signal \&quot;%s::%s\&quot; has return type &#39;%s&#39; and is only G_SIGNAL_RUN_FIRST&quot;,
<span class="line-modified">!      type_debug_name (itype), name, type_debug_name (return_type));</span>
        g_free (name);
        SIGNAL_UNLOCK ();
        return 0;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1763,14 ***</span>
      }
    else if (n_params == 1 &amp;&amp; return_type == G_TYPE_NONE)
      {
  #define ADD_CHECK(__type__) \
        else if (g_type_is_a (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, G_TYPE_ ##__type__))         \
<span class="line-modified">!     {                                                                \</span>
<span class="line-modified">!       builtin_c_marshaller = g_cclosure_marshal_VOID__ ## __type__;  \</span>
<span class="line-modified">!       builtin_va_marshaller = g_cclosure_marshal_VOID__ ## __type__ ##v;     \</span>
<span class="line-modified">!     }</span>
  
        if (0) {}
        ADD_CHECK (BOOLEAN)
        ADD_CHECK (CHAR)
        ADD_CHECK (UCHAR)
<span class="line-new-header">--- 1769,14 ---</span>
      }
    else if (n_params == 1 &amp;&amp; return_type == G_TYPE_NONE)
      {
  #define ADD_CHECK(__type__) \
        else if (g_type_is_a (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, G_TYPE_ ##__type__))         \
<span class="line-modified">!   {                                                                \</span>
<span class="line-modified">!     builtin_c_marshaller = g_cclosure_marshal_VOID__ ## __type__;  \</span>
<span class="line-modified">!     builtin_va_marshaller = g_cclosure_marshal_VOID__ ## __type__ ##v;     \</span>
<span class="line-modified">!   }</span>
  
        if (0) {}
        ADD_CHECK (BOOLEAN)
        ADD_CHECK (CHAR)
        ADD_CHECK (UCHAR)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1796,14 ***</span>
          {
      c_marshaller = builtin_c_marshaller;
            va_marshaller = builtin_va_marshaller;
          }
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       c_marshaller = g_cclosure_marshal_generic;</span>
<span class="line-modified">!       va_marshaller = g_cclosure_marshal_generic_va;</span>
<span class="line-modified">!     }</span>
      }
    else
      va_marshaller = NULL;
  
    node-&gt;c_marshaller = c_marshaller;
<span class="line-new-header">--- 1802,14 ---</span>
          {
      c_marshaller = builtin_c_marshaller;
            va_marshaller = builtin_va_marshaller;
          }
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     c_marshaller = g_cclosure_marshal_generic;</span>
<span class="line-modified">!     va_marshaller = g_cclosure_marshal_generic_va;</span>
<span class="line-modified">!   }</span>
      }
    else
      va_marshaller = NULL;
  
    node-&gt;c_marshaller = c_marshaller;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1832,12 ***</span>
   *
   * Since: 2.32
   */
  void
  g_signal_set_va_marshaller (guint              signal_id,
<span class="line-modified">!                 GType              instance_type,</span>
<span class="line-modified">!                 GSignalCVaMarshaller va_marshaller)</span>
  {
    SignalNode *node;
  
    g_return_if_fail (signal_id &gt; 0);
    g_return_if_fail (va_marshaller != NULL);
<span class="line-new-header">--- 1838,12 ---</span>
   *
   * Since: 2.32
   */
  void
  g_signal_set_va_marshaller (guint              signal_id,
<span class="line-modified">!           GType              instance_type,</span>
<span class="line-modified">!           GSignalCVaMarshaller va_marshaller)</span>
  {
    SignalNode *node;
  
    g_return_if_fail (signal_id &gt; 0);
    g_return_if_fail (va_marshaller != NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1846,15 ***</span>
    node = LOOKUP_SIGNAL_NODE (signal_id);
    if (node)
      {
        node-&gt;va_marshaller = va_marshaller;
        if (node-&gt;class_closure_bsa)
<span class="line-modified">!     {</span>
<span class="line-modified">!       ClassClosure *cc = g_bsearch_array_get_nth (node-&gt;class_closure_bsa, &amp;g_class_closure_bconfig, 0);</span>
<span class="line-modified">!       if (cc-&gt;closure-&gt;marshal == node-&gt;c_marshaller)</span>
<span class="line-modified">!         _g_closure_set_va_marshal (cc-&gt;closure, va_marshaller);</span>
<span class="line-modified">!     }</span>
  
        node-&gt;single_va_closure_is_valid = FALSE;
      }
  
    SIGNAL_UNLOCK ();
<span class="line-new-header">--- 1852,15 ---</span>
    node = LOOKUP_SIGNAL_NODE (signal_id);
    if (node)
      {
        node-&gt;va_marshaller = va_marshaller;
        if (node-&gt;class_closure_bsa)
<span class="line-modified">!   {</span>
<span class="line-modified">!     ClassClosure *cc = g_bsearch_array_get_nth (node-&gt;class_closure_bsa, &amp;g_class_closure_bconfig, 0);</span>
<span class="line-modified">!     if (cc-&gt;closure-&gt;marshal == node-&gt;c_marshaller)</span>
<span class="line-modified">!       _g_closure_set_va_marshal (cc-&gt;closure, va_marshaller);</span>
<span class="line-modified">!   }</span>
  
        node-&gt;single_va_closure_is_valid = FALSE;
      }
  
    SIGNAL_UNLOCK ();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1892,11 ***</span>
  g_signal_new_valist (const gchar       *signal_name,
                       GType              itype,
                       GSignalFlags       signal_flags,
                       GClosure          *class_closure,
                       GSignalAccumulator accumulator,
<span class="line-modified">!              gpointer       accu_data,</span>
                       GSignalCMarshaller c_marshaller,
                       GType              return_type,
                       guint              n_params,
                       va_list            args)
  {
<span class="line-new-header">--- 1898,11 ---</span>
  g_signal_new_valist (const gchar       *signal_name,
                       GType              itype,
                       GSignalFlags       signal_flags,
                       GClosure          *class_closure,
                       GSignalAccumulator accumulator,
<span class="line-modified">!          gpointer   accu_data,</span>
                       GSignalCMarshaller c_marshaller,
                       GType              return_type,
                       guint              n_params,
                       va_list            args)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1907,18 ***</span>
    if (n_params &gt; 0)
      {
        param_types = g_new (GType, n_params);
  
        for (i = 0; i &lt; n_params; i++)
<span class="line-modified">!     param_types[i] = va_arg (args, GType);</span>
      }
    else
      param_types = NULL;
  
    signal_id = g_signal_newv (signal_name, itype, signal_flags,
<span class="line-modified">!                  class_closure, accumulator, accu_data, c_marshaller,</span>
<span class="line-modified">!                  return_type, n_params, param_types);</span>
    g_free (param_types);
  
    return signal_id;
  }
  
<span class="line-new-header">--- 1913,18 ---</span>
    if (n_params &gt; 0)
      {
        param_types = g_new (GType, n_params);
  
        for (i = 0; i &lt; n_params; i++)
<span class="line-modified">!   param_types[i] = va_arg (args, GType);</span>
      }
    else
      param_types = NULL;
  
    signal_id = g_signal_newv (signal_name, itype, signal_flags,
<span class="line-modified">!            class_closure, accumulator, accu_data, c_marshaller,</span>
<span class="line-modified">!            return_type, n_params, param_types);</span>
    g_free (param_types);
  
    return signal_id;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1959,15 ***</span>
    if (node.class_closure_bsa)
      {
        guint i;
  
        for (i = 0; i &lt; node.class_closure_bsa-&gt;n_nodes; i++)
<span class="line-modified">!     {</span>
<span class="line-modified">!       ClassClosure *cc = g_bsearch_array_get_nth (node.class_closure_bsa, &amp;g_class_closure_bconfig, i);</span>
  
<span class="line-modified">!       g_closure_unref (cc-&gt;closure);</span>
<span class="line-modified">!     }</span>
        g_bsearch_array_free (node.class_closure_bsa, &amp;g_class_closure_bconfig);
      }
    g_free (node.accumulator);
    if (node.emission_hooks)
      {
<span class="line-new-header">--- 1965,15 ---</span>
    if (node.class_closure_bsa)
      {
        guint i;
  
        for (i = 0; i &lt; node.class_closure_bsa-&gt;n_nodes; i++)
<span class="line-modified">!   {</span>
<span class="line-modified">!     ClassClosure *cc = g_bsearch_array_get_nth (node.class_closure_bsa, &amp;g_class_closure_bconfig, i);</span>
  
<span class="line-modified">!     g_closure_unref (cc-&gt;closure);</span>
<span class="line-modified">!   }</span>
        g_bsearch_array_free (node.class_closure_bsa, &amp;g_class_closure_bconfig);
      }
    g_free (node.accumulator);
    if (node.emission_hooks)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1992,12 ***</span>
   * g_signal_chain_from_overridden_handler() for how to chain up to the
   * parent class closure from inside the overridden one.
   */
  void
  g_signal_override_class_closure (guint     signal_id,
<span class="line-modified">!                  GType     instance_type,</span>
<span class="line-modified">!                  GClosure *class_closure)</span>
  {
    SignalNode *node;
  
    g_return_if_fail (signal_id &gt; 0);
    g_return_if_fail (class_closure != NULL);
<span class="line-new-header">--- 1998,12 ---</span>
   * g_signal_chain_from_overridden_handler() for how to chain up to the
   * parent class closure from inside the overridden one.
   */
  void
  g_signal_override_class_closure (guint     signal_id,
<span class="line-modified">!          GType     instance_type,</span>
<span class="line-modified">!          GClosure *class_closure)</span>
  {
    SignalNode *node;
  
    g_return_if_fail (signal_id &gt; 0);
    g_return_if_fail (class_closure != NULL);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2014,13 ***</span>
    else
      {
        ClassClosure *cc = signal_find_class_closure (node, instance_type);
  
        if (cc &amp;&amp; cc-&gt;instance_type == instance_type)
<span class="line-modified">!     g_warning (&quot;%s: type &#39;%s&#39; is already overridden for signal id &#39;%u&#39;&quot;, G_STRLOC, type_debug_name (instance_type), signal_id);</span>
        else
<span class="line-modified">!     signal_add_class_closure (node, instance_type, class_closure);</span>
      }
    SIGNAL_UNLOCK ();
  }
  
  /**
<span class="line-new-header">--- 2020,13 ---</span>
    else
      {
        ClassClosure *cc = signal_find_class_closure (node, instance_type);
  
        if (cc &amp;&amp; cc-&gt;instance_type == instance_type)
<span class="line-modified">!   g_warning (&quot;%s: type &#39;%s&#39; is already overridden for signal id &#39;%u&#39;&quot;, G_STRLOC, type_debug_name (instance_type), signal_id);</span>
        else
<span class="line-modified">!   signal_add_class_closure (node, instance_type, class_closure);</span>
      }
    SIGNAL_UNLOCK ();
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2041,12 ***</span>
   *
   * Since: 2.18
   */
  void
  g_signal_override_class_handler (const gchar *signal_name,
<span class="line-modified">!                  GType        instance_type,</span>
<span class="line-modified">!                  GCallback    class_handler)</span>
  {
    guint signal_id;
  
    g_return_if_fail (signal_name != NULL);
    g_return_if_fail (instance_type != G_TYPE_NONE);
<span class="line-new-header">--- 2047,12 ---</span>
   *
   * Since: 2.18
   */
  void
  g_signal_override_class_handler (const gchar *signal_name,
<span class="line-modified">!          GType        instance_type,</span>
<span class="line-modified">!          GCallback    class_handler)</span>
  {
    guint signal_id;
  
    g_return_if_fail (signal_name != NULL);
    g_return_if_fail (instance_type != G_TYPE_NONE);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2075,11 ***</span>
   * g_signal_override_class_closure() and
   * g_signal_override_class_handler().
   */
  void
  g_signal_chain_from_overridden (const GValue *instance_and_params,
<span class="line-modified">!                 GValue       *return_value)</span>
  {
    GType chain_type = 0, restore_type = 0;
    Emission *emission = NULL;
    GClosure *closure = NULL;
    guint n_params = 0;
<span class="line-new-header">--- 2081,11 ---</span>
   * g_signal_override_class_closure() and
   * g_signal_override_class_handler().
   */
  void
  g_signal_chain_from_overridden (const GValue *instance_and_params,
<span class="line-modified">!         GValue       *return_value)</span>
  {
    GType chain_type = 0, restore_type = 0;
    Emission *emission = NULL;
    GClosure *closure = NULL;
    guint n_params = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2098,39 ***</span>
        g_assert (node != NULL);  /* paranoid */
  
        /* we should probably do the same parameter checks as g_signal_emit() here.
         */
        if (emission-&gt;chain_type != G_TYPE_NONE)
<span class="line-modified">!     {</span>
<span class="line-modified">!       ClassClosure *cc = signal_find_class_closure (node, emission-&gt;chain_type);</span>
  
<span class="line-modified">!       g_assert (cc != NULL);    /* closure currently in call stack */</span>
  
<span class="line-modified">!       n_params = node-&gt;n_params;</span>
<span class="line-modified">!       restore_type = cc-&gt;instance_type;</span>
<span class="line-modified">!       cc = signal_find_class_closure (node, g_type_parent (cc-&gt;instance_type));</span>
<span class="line-modified">!       if (cc &amp;&amp; cc-&gt;instance_type != restore_type)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           closure = cc-&gt;closure;</span>
<span class="line-modified">!           chain_type = cc-&gt;instance_type;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     g_warning (&quot;%s: signal id &#39;%u&#39; cannot be chained from current emission stage for instance &#39;%p&#39;&quot;, G_STRLOC, node-&gt;signal_id, instance);</span>
      }
    else
      g_warning (&quot;%s: no signal is currently being emitted for instance &#39;%p&#39;&quot;, G_STRLOC, instance);
  
    if (closure)
      {
        emission-&gt;chain_type = chain_type;
        SIGNAL_UNLOCK ();
        g_closure_invoke (closure,
<span class="line-modified">!             return_value,</span>
<span class="line-modified">!             n_params + 1,</span>
<span class="line-modified">!             instance_and_params,</span>
<span class="line-modified">!             &amp;emission-&gt;ihint);</span>
        SIGNAL_LOCK ();
        emission-&gt;chain_type = restore_type;
      }
    SIGNAL_UNLOCK ();
  }
<span class="line-new-header">--- 2104,39 ---</span>
        g_assert (node != NULL);  /* paranoid */
  
        /* we should probably do the same parameter checks as g_signal_emit() here.
         */
        if (emission-&gt;chain_type != G_TYPE_NONE)
<span class="line-modified">!   {</span>
<span class="line-modified">!     ClassClosure *cc = signal_find_class_closure (node, emission-&gt;chain_type);</span>
  
<span class="line-modified">!     g_assert (cc != NULL);  /* closure currently in call stack */</span>
  
<span class="line-modified">!     n_params = node-&gt;n_params;</span>
<span class="line-modified">!     restore_type = cc-&gt;instance_type;</span>
<span class="line-modified">!     cc = signal_find_class_closure (node, g_type_parent (cc-&gt;instance_type));</span>
<span class="line-modified">!     if (cc &amp;&amp; cc-&gt;instance_type != restore_type)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         closure = cc-&gt;closure;</span>
<span class="line-modified">!         chain_type = cc-&gt;instance_type;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   g_warning (&quot;%s: signal id &#39;%u&#39; cannot be chained from current emission stage for instance &#39;%p&#39;&quot;, G_STRLOC, node-&gt;signal_id, instance);</span>
      }
    else
      g_warning (&quot;%s: no signal is currently being emitted for instance &#39;%p&#39;&quot;, G_STRLOC, instance);
  
    if (closure)
      {
        emission-&gt;chain_type = chain_type;
        SIGNAL_UNLOCK ();
        g_closure_invoke (closure,
<span class="line-modified">!       return_value,</span>
<span class="line-modified">!       n_params + 1,</span>
<span class="line-modified">!       instance_and_params,</span>
<span class="line-modified">!       &amp;emission-&gt;ihint);</span>
        SIGNAL_LOCK ();
        emission-&gt;chain_type = restore_type;
      }
    SIGNAL_UNLOCK ();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2171,26 ***</span>
        g_assert (node != NULL);  /* paranoid */
  
        /* we should probably do the same parameter checks as g_signal_emit() here.
         */
        if (emission-&gt;chain_type != G_TYPE_NONE)
<span class="line-modified">!     {</span>
<span class="line-modified">!       ClassClosure *cc = signal_find_class_closure (node, emission-&gt;chain_type);</span>
  
<span class="line-modified">!       g_assert (cc != NULL);    /* closure currently in call stack */</span>
  
<span class="line-modified">!       n_params = node-&gt;n_params;</span>
<span class="line-modified">!       restore_type = cc-&gt;instance_type;</span>
<span class="line-modified">!       cc = signal_find_class_closure (node, g_type_parent (cc-&gt;instance_type));</span>
<span class="line-modified">!       if (cc &amp;&amp; cc-&gt;instance_type != restore_type)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           closure = cc-&gt;closure;</span>
<span class="line-modified">!           chain_type = cc-&gt;instance_type;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
        else
<span class="line-modified">!     g_warning (&quot;%s: signal id &#39;%u&#39; cannot be chained from current emission stage for instance &#39;%p&#39;&quot;, G_STRLOC, node-&gt;signal_id, instance);</span>
      }
    else
      g_warning (&quot;%s: no signal is currently being emitted for instance &#39;%p&#39;&quot;, G_STRLOC, instance);
  
    if (closure)
<span class="line-new-header">--- 2177,26 ---</span>
        g_assert (node != NULL);  /* paranoid */
  
        /* we should probably do the same parameter checks as g_signal_emit() here.
         */
        if (emission-&gt;chain_type != G_TYPE_NONE)
<span class="line-modified">!   {</span>
<span class="line-modified">!     ClassClosure *cc = signal_find_class_closure (node, emission-&gt;chain_type);</span>
  
<span class="line-modified">!     g_assert (cc != NULL);  /* closure currently in call stack */</span>
  
<span class="line-modified">!     n_params = node-&gt;n_params;</span>
<span class="line-modified">!     restore_type = cc-&gt;instance_type;</span>
<span class="line-modified">!     cc = signal_find_class_closure (node, g_type_parent (cc-&gt;instance_type));</span>
<span class="line-modified">!     if (cc &amp;&amp; cc-&gt;instance_type != restore_type)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         closure = cc-&gt;closure;</span>
<span class="line-modified">!         chain_type = cc-&gt;instance_type;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!   }</span>
        else
<span class="line-modified">!   g_warning (&quot;%s: signal id &#39;%u&#39; cannot be chained from current emission stage for instance &#39;%p&#39;&quot;, G_STRLOC, node-&gt;signal_id, instance);</span>
      }
    else
      g_warning (&quot;%s: no signal is currently being emitted for instance &#39;%p&#39;&quot;, G_STRLOC, instance);
  
    if (closure)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2214,13 ***</span>
            GType ptype = node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
            gboolean static_scope = node-&gt;param_types[i] &amp; G_SIGNAL_TYPE_STATIC_SCOPE;
  
            SIGNAL_UNLOCK ();
            G_VALUE_COLLECT_INIT (param_values + i, ptype,
<span class="line-modified">!                 var_args,</span>
<span class="line-modified">!                 static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="line-modified">!                 &amp;error);</span>
            if (error)
              {
                g_warning (&quot;%s: %s&quot;, G_STRLOC, error);
                g_free (error);
  
<span class="line-new-header">--- 2220,13 ---</span>
            GType ptype = node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
            gboolean static_scope = node-&gt;param_types[i] &amp; G_SIGNAL_TYPE_STATIC_SCOPE;
  
            SIGNAL_UNLOCK ();
            G_VALUE_COLLECT_INIT (param_values + i, ptype,
<span class="line-modified">!         var_args,</span>
<span class="line-modified">!         static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="line-modified">!         &amp;error);</span>
            if (error)
              {
                g_warning (&quot;%s: %s&quot;, G_STRLOC, error);
                g_free (error);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2333,14 ***</span>
   *
   * Returns: the handler ID (always greater than 0 for successful connections)
   */
  gulong
  g_signal_connect_closure_by_id (gpointer  instance,
<span class="line-modified">!                 guint     signal_id,</span>
<span class="line-modified">!                 GQuark    detail,</span>
<span class="line-modified">!                 GClosure *closure,</span>
<span class="line-modified">!                 gboolean  after)</span>
  {
    SignalNode *node;
    gulong handler_seq_no = 0;
  
    g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
<span class="line-new-header">--- 2339,14 ---</span>
   *
   * Returns: the handler ID (always greater than 0 for successful connections)
   */
  gulong
  g_signal_connect_closure_by_id (gpointer  instance,
<span class="line-modified">!         guint     signal_id,</span>
<span class="line-modified">!         GQuark    detail,</span>
<span class="line-modified">!         GClosure *closure,</span>
<span class="line-modified">!         gboolean  after)</span>
  {
    SignalNode *node;
    gulong handler_seq_no = 0;
  
    g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2350,30 ***</span>
    SIGNAL_LOCK ();
    node = LOOKUP_SIGNAL_NODE (signal_id);
    if (node)
      {
        if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
<span class="line-modified">!     g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);</span>
        else if (!g_type_is_a (G_TYPE_FROM_INSTANCE (instance), node-&gt;itype))
<span class="line-modified">!     g_warning (&quot;%s: signal id &#39;%u&#39; is invalid for instance &#39;%p&#39;&quot;, G_STRLOC, signal_id, instance);</span>
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       Handler *handler = handler_new (signal_id, instance, after);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       handler_seq_no = handler-&gt;sequential_number;</span>
<span class="line-modified">!       handler-&gt;detail = detail;</span>
<span class="line-modified">!       handler-&gt;closure = g_closure_ref (closure);</span>
<span class="line-modified">!       g_closure_sink (closure);</span>
<span class="line-modified">!       add_invalid_closure_notify (handler, instance);</span>
<span class="line-modified">!       handler_insert (signal_id, instance, handler);</span>
<span class="line-modified">!       if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (closure))</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           g_closure_set_marshal (closure, node-&gt;c_marshaller);</span>
<span class="line-modified">!           if (node-&gt;va_marshaller)</span>
<span class="line-modified">!         _g_closure_set_va_marshal (closure, node-&gt;va_marshaller);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
      }
    else
      g_warning (&quot;%s: signal id &#39;%u&#39; is invalid for instance &#39;%p&#39;&quot;, G_STRLOC, signal_id, instance);
    SIGNAL_UNLOCK ();
  
<span class="line-new-header">--- 2356,30 ---</span>
    SIGNAL_LOCK ();
    node = LOOKUP_SIGNAL_NODE (signal_id);
    if (node)
      {
        if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
<span class="line-modified">!   g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);</span>
        else if (!g_type_is_a (G_TYPE_FROM_INSTANCE (instance), node-&gt;itype))
<span class="line-modified">!   g_warning (&quot;%s: signal id &#39;%u&#39; is invalid for instance &#39;%p&#39;&quot;, G_STRLOC, signal_id, instance);</span>
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     Handler *handler = handler_new (signal_id, instance, after);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     handler_seq_no = handler-&gt;sequential_number;</span>
<span class="line-modified">!     handler-&gt;detail = detail;</span>
<span class="line-modified">!     handler-&gt;closure = g_closure_ref (closure);</span>
<span class="line-modified">!     g_closure_sink (closure);</span>
<span class="line-modified">!     add_invalid_closure_notify (handler, instance);</span>
<span class="line-modified">!     handler_insert (signal_id, instance, handler);</span>
<span class="line-modified">!     if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (closure))</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         g_closure_set_marshal (closure, node-&gt;c_marshaller);</span>
<span class="line-modified">!         if (node-&gt;va_marshaller)</span>
<span class="line-modified">!     _g_closure_set_va_marshal (closure, node-&gt;va_marshaller);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!   }</span>
      }
    else
      g_warning (&quot;%s: signal id &#39;%u&#39; is invalid for instance &#39;%p&#39;&quot;, G_STRLOC, signal_id, instance);
    SIGNAL_UNLOCK ();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2392,13 ***</span>
   *
   * Returns: the handler ID (always greater than 0 for successful connections)
   */
  gulong
  g_signal_connect_closure (gpointer     instance,
<span class="line-modified">!               const gchar *detailed_signal,</span>
<span class="line-modified">!               GClosure    *closure,</span>
<span class="line-modified">!               gboolean     after)</span>
  {
    guint signal_id;
    gulong handler_seq_no = 0;
    GQuark detail = 0;
    GType itype;
<span class="line-new-header">--- 2398,13 ---</span>
   *
   * Returns: the handler ID (always greater than 0 for successful connections)
   */
  gulong
  g_signal_connect_closure (gpointer     instance,
<span class="line-modified">!         const gchar *detailed_signal,</span>
<span class="line-modified">!         GClosure    *closure,</span>
<span class="line-modified">!         gboolean     after)</span>
  {
    guint signal_id;
    gulong handler_seq_no = 0;
    GQuark detail = 0;
    GType itype;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2413,31 ***</span>
    if (signal_id)
      {
        SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
  
        if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
<span class="line-modified">!     g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);</span>
        else if (!g_type_is_a (itype, node-&gt;itype))
          g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                     G_STRLOC, detailed_signal, instance, g_type_name (itype));
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       Handler *handler = handler_new (signal_id, instance, after);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       handler_seq_no = handler-&gt;sequential_number;</span>
<span class="line-modified">!       handler-&gt;detail = detail;</span>
<span class="line-modified">!       handler-&gt;closure = g_closure_ref (closure);</span>
<span class="line-modified">!       g_closure_sink (closure);</span>
<span class="line-modified">!       add_invalid_closure_notify (handler, instance);</span>
<span class="line-modified">!       handler_insert (signal_id, instance, handler);</span>
<span class="line-modified">!       if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (handler-&gt;closure))</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           g_closure_set_marshal (handler-&gt;closure, node-&gt;c_marshaller);</span>
<span class="line-modified">!           if (node-&gt;va_marshaller)</span>
<span class="line-modified">!         _g_closure_set_va_marshal (handler-&gt;closure, node-&gt;va_marshaller);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
      }
    else
      g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                 G_STRLOC, detailed_signal, instance, g_type_name (itype));
    SIGNAL_UNLOCK ();
<span class="line-new-header">--- 2419,31 ---</span>
    if (signal_id)
      {
        SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
  
        if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
<span class="line-modified">!   g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);</span>
        else if (!g_type_is_a (itype, node-&gt;itype))
          g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                     G_STRLOC, detailed_signal, instance, g_type_name (itype));
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     Handler *handler = handler_new (signal_id, instance, after);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     handler_seq_no = handler-&gt;sequential_number;</span>
<span class="line-modified">!     handler-&gt;detail = detail;</span>
<span class="line-modified">!     handler-&gt;closure = g_closure_ref (closure);</span>
<span class="line-modified">!     g_closure_sink (closure);</span>
<span class="line-modified">!     add_invalid_closure_notify (handler, instance);</span>
<span class="line-modified">!     handler_insert (signal_id, instance, handler);</span>
<span class="line-modified">!     if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (handler-&gt;closure))</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         g_closure_set_marshal (handler-&gt;closure, node-&gt;c_marshaller);</span>
<span class="line-modified">!         if (node-&gt;va_marshaller)</span>
<span class="line-modified">!     _g_closure_set_va_marshal (handler-&gt;closure, node-&gt;va_marshaller);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!   }</span>
      }
    else
      g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                 G_STRLOC, detailed_signal, instance, g_type_name (itype));
    SIGNAL_UNLOCK ();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2485,15 ***</span>
   *
   * Returns: the handler ID (always greater than 0 for successful connections)
   */
  gulong
  g_signal_connect_data (gpointer       instance,
<span class="line-modified">!                const gchar   *detailed_signal,</span>
<span class="line-modified">!                GCallback      c_handler,</span>
<span class="line-modified">!                gpointer       data,</span>
<span class="line-modified">!                GClosureNotify destroy_data,</span>
<span class="line-modified">!                GConnectFlags  connect_flags)</span>
  {
    guint signal_id;
    gulong handler_seq_no = 0;
    GQuark detail = 0;
    GType itype;
<span class="line-new-header">--- 2491,15 ---</span>
   *
   * Returns: the handler ID (always greater than 0 for successful connections)
   */
  gulong
  g_signal_connect_data (gpointer       instance,
<span class="line-modified">!            const gchar   *detailed_signal,</span>
<span class="line-modified">!            GCallback      c_handler,</span>
<span class="line-modified">!            gpointer       data,</span>
<span class="line-modified">!            GClosureNotify destroy_data,</span>
<span class="line-modified">!            GConnectFlags  connect_flags)</span>
  {
    guint signal_id;
    gulong handler_seq_no = 0;
    GQuark detail = 0;
    GType itype;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2514,29 ***</span>
        SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
  
        node_check_deprecated (node);
  
        if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
<span class="line-modified">!     g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);</span>
        else if (!g_type_is_a (itype, node-&gt;itype))
          g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                     G_STRLOC, detailed_signal, instance, g_type_name (itype));
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       Handler *handler = handler_new (signal_id, instance, after);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       handler_seq_no = handler-&gt;sequential_number;</span>
<span class="line-modified">!       handler-&gt;detail = detail;</span>
<span class="line-modified">!       handler-&gt;closure = g_closure_ref ((swapped ? g_cclosure_new_swap : g_cclosure_new) (c_handler, data, destroy_data));</span>
<span class="line-modified">!       g_closure_sink (handler-&gt;closure);</span>
<span class="line-modified">!       handler_insert (signal_id, instance, handler);</span>
<span class="line-modified">!       if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (handler-&gt;closure))</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           g_closure_set_marshal (handler-&gt;closure, node-&gt;c_marshaller);</span>
<span class="line-modified">!           if (node-&gt;va_marshaller)</span>
<span class="line-modified">!         _g_closure_set_va_marshal (handler-&gt;closure, node-&gt;va_marshaller);</span>
<span class="line-modified">!         }</span>
          }
      }
    else
      g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                 G_STRLOC, detailed_signal, instance, g_type_name (itype));
<span class="line-new-header">--- 2520,29 ---</span>
        SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
  
        node_check_deprecated (node);
  
        if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
<span class="line-modified">!   g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);</span>
        else if (!g_type_is_a (itype, node-&gt;itype))
          g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                     G_STRLOC, detailed_signal, instance, g_type_name (itype));
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     Handler *handler = handler_new (signal_id, instance, after);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     handler_seq_no = handler-&gt;sequential_number;</span>
<span class="line-modified">!     handler-&gt;detail = detail;</span>
<span class="line-modified">!     handler-&gt;closure = g_closure_ref ((swapped ? g_cclosure_new_swap : g_cclosure_new) (c_handler, data, destroy_data));</span>
<span class="line-modified">!     g_closure_sink (handler-&gt;closure);</span>
<span class="line-modified">!     handler_insert (signal_id, instance, handler);</span>
<span class="line-modified">!     if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (handler-&gt;closure))</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         g_closure_set_marshal (handler-&gt;closure, node-&gt;c_marshaller);</span>
<span class="line-modified">!         if (node-&gt;va_marshaller)</span>
<span class="line-modified">!     _g_closure_set_va_marshal (handler-&gt;closure, node-&gt;va_marshaller);</span>
<span class="line-modified">!       }</span>
          }
      }
    else
      g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
                 G_STRLOC, detailed_signal, instance, g_type_name (itype));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2670,11 ***</span>
   *
   * Returns: whether @handler_id identifies a handler connected to @instance.
   */
  gboolean
  g_signal_handler_is_connected (gpointer instance,
<span class="line-modified">!                    gulong   handler_id)</span>
  {
    Handler *handler;
    gboolean connected;
  
    g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), FALSE);
<span class="line-new-header">--- 2676,11 ---</span>
   *
   * Returns: whether @handler_id identifies a handler connected to @instance.
   */
  gboolean
  g_signal_handler_is_connected (gpointer instance,
<span class="line-modified">!              gulong   handler_id)</span>
  {
    Handler *handler;
    gboolean connected;
  
    g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), FALSE);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2724,16 ***</span>
                tmp-&gt;block_count = 1;
                /* cruel unlink, this works because _all_ handlers vanish */
                tmp-&gt;next = NULL;
                tmp-&gt;prev = tmp;
                if (tmp-&gt;sequential_number)
<span class="line-modified">!         {</span>
                    g_hash_table_remove (g_handlers, tmp);
<span class="line-modified">!           remove_invalid_closure_notify (tmp, instance);</span>
<span class="line-modified">!           tmp-&gt;sequential_number = 0;</span>
<span class="line-modified">!           handler_unref_R (0, NULL, tmp);</span>
<span class="line-modified">!         }</span>
              }
          }
        g_bsearch_array_free (hlbsa, &amp;g_signal_hlbsa_bconfig);
      }
    SIGNAL_UNLOCK ();
<span class="line-new-header">--- 2730,16 ---</span>
                tmp-&gt;block_count = 1;
                /* cruel unlink, this works because _all_ handlers vanish */
                tmp-&gt;next = NULL;
                tmp-&gt;prev = tmp;
                if (tmp-&gt;sequential_number)
<span class="line-modified">!     {</span>
                    g_hash_table_remove (g_handlers, tmp);
<span class="line-modified">!       remove_invalid_closure_notify (tmp, instance);</span>
<span class="line-modified">!       tmp-&gt;sequential_number = 0;</span>
<span class="line-modified">!       handler_unref_R (0, NULL, tmp);</span>
<span class="line-modified">!     }</span>
              }
          }
        g_bsearch_array_free (hlbsa, &amp;g_signal_hlbsa_bconfig);
      }
    SIGNAL_UNLOCK ();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2760,11 ***</span>
   */
  gulong
  g_signal_handler_find (gpointer         instance,
                         GSignalMatchType mask,
                         guint            signal_id,
<span class="line-modified">!                GQuark       detail,</span>
                         GClosure        *closure,
                         gpointer         func,
                         gpointer         data)
  {
    gulong handler_seq_no = 0;
<span class="line-new-header">--- 2766,11 ---</span>
   */
  gulong
  g_signal_handler_find (gpointer         instance,
                         GSignalMatchType mask,
                         guint            signal_id,
<span class="line-modified">!            GQuark   detail,</span>
                         GClosure        *closure,
                         gpointer         func,
                         gpointer         data)
  {
    gulong handler_seq_no = 0;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2777,44 ***</span>
        HandlerMatch *mlist;
  
        SIGNAL_LOCK ();
        mlist = handlers_find (instance, mask, signal_id, detail, closure, func, data, TRUE);
        if (mlist)
<span class="line-modified">!     {</span>
<span class="line-modified">!       handler_seq_no = mlist-&gt;handler-&gt;sequential_number;</span>
<span class="line-modified">!       handler_match_free1_R (mlist, instance);</span>
<span class="line-modified">!     }</span>
        SIGNAL_UNLOCK ();
      }
  
    return handler_seq_no;
  }
  
  static guint
  signal_handlers_foreach_matched_R (gpointer         instance,
<span class="line-modified">!                                    GSignalMatchType mask,</span>
<span class="line-modified">!                                    guint            signal_id,</span>
<span class="line-modified">!                                    GQuark           detail,</span>
<span class="line-modified">!                                    GClosure        *closure,</span>
<span class="line-modified">!                                    gpointer         func,</span>
<span class="line-modified">!                                    gpointer         data,</span>
<span class="line-modified">!                    void       (*callback) (gpointer instance,</span>
<span class="line-modified">!                                    gulong   handler_seq_no))</span>
  {
    HandlerMatch *mlist;
    guint n_handlers = 0;
  
    mlist = handlers_find (instance, mask, signal_id, detail, closure, func, data, FALSE);
    while (mlist)
      {
        n_handlers++;
        if (mlist-&gt;handler-&gt;sequential_number)
<span class="line-modified">!     {</span>
<span class="line-modified">!       SIGNAL_UNLOCK ();</span>
<span class="line-modified">!       callback (instance, mlist-&gt;handler-&gt;sequential_number);</span>
<span class="line-modified">!       SIGNAL_LOCK ();</span>
<span class="line-modified">!     }</span>
        mlist = handler_match_free1_R (mlist, instance);
      }
  
    return n_handlers;
  }
<span class="line-new-header">--- 2783,44 ---</span>
        HandlerMatch *mlist;
  
        SIGNAL_LOCK ();
        mlist = handlers_find (instance, mask, signal_id, detail, closure, func, data, TRUE);
        if (mlist)
<span class="line-modified">!   {</span>
<span class="line-modified">!     handler_seq_no = mlist-&gt;handler-&gt;sequential_number;</span>
<span class="line-modified">!     handler_match_free1_R (mlist, instance);</span>
<span class="line-modified">!   }</span>
        SIGNAL_UNLOCK ();
      }
  
    return handler_seq_no;
  }
  
  static guint
  signal_handlers_foreach_matched_R (gpointer         instance,
<span class="line-modified">!            GSignalMatchType mask,</span>
<span class="line-modified">!            guint            signal_id,</span>
<span class="line-modified">!            GQuark           detail,</span>
<span class="line-modified">!            GClosure        *closure,</span>
<span class="line-modified">!            gpointer         func,</span>
<span class="line-modified">!            gpointer         data,</span>
<span class="line-modified">!            void     (*callback) (gpointer instance,</span>
<span class="line-modified">!                      gulong   handler_seq_no))</span>
  {
    HandlerMatch *mlist;
    guint n_handlers = 0;
  
    mlist = handlers_find (instance, mask, signal_id, detail, closure, func, data, FALSE);
    while (mlist)
      {
        n_handlers++;
        if (mlist-&gt;handler-&gt;sequential_number)
<span class="line-modified">!   {</span>
<span class="line-modified">!     SIGNAL_UNLOCK ();</span>
<span class="line-modified">!     callback (instance, mlist-&gt;handler-&gt;sequential_number);</span>
<span class="line-modified">!     SIGNAL_LOCK ();</span>
<span class="line-modified">!   }</span>
        mlist = handler_match_free1_R (mlist, instance);
      }
  
    return n_handlers;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2840,28 ***</span>
   *
   * Returns: The number of handlers that matched.
   */
  guint
  g_signal_handlers_block_matched (gpointer         instance,
<span class="line-modified">!                  GSignalMatchType mask,</span>
<span class="line-modified">!                  guint            signal_id,</span>
<span class="line-modified">!                  GQuark           detail,</span>
<span class="line-modified">!                  GClosure        *closure,</span>
<span class="line-modified">!                  gpointer         func,</span>
<span class="line-modified">!                  gpointer         data)</span>
  {
    guint n_handlers = 0;
  
    g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
    g_return_val_if_fail ((mask &amp; ~G_SIGNAL_MATCH_MASK) == 0, 0);
  
    if (mask &amp; (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
      {
        SIGNAL_LOCK ();
        n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
<span class="line-modified">!                               closure, func, data,</span>
<span class="line-modified">!                               g_signal_handler_block);</span>
        SIGNAL_UNLOCK ();
      }
  
    return n_handlers;
  }
<span class="line-new-header">--- 2846,28 ---</span>
   *
   * Returns: The number of handlers that matched.
   */
  guint
  g_signal_handlers_block_matched (gpointer         instance,
<span class="line-modified">!          GSignalMatchType mask,</span>
<span class="line-modified">!          guint            signal_id,</span>
<span class="line-modified">!          GQuark           detail,</span>
<span class="line-modified">!          GClosure        *closure,</span>
<span class="line-modified">!          gpointer         func,</span>
<span class="line-modified">!          gpointer         data)</span>
  {
    guint n_handlers = 0;
  
    g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
    g_return_val_if_fail ((mask &amp; ~G_SIGNAL_MATCH_MASK) == 0, 0);
  
    if (mask &amp; (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
      {
        SIGNAL_LOCK ();
        n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
<span class="line-modified">!                   closure, func, data,</span>
<span class="line-modified">!                   g_signal_handler_block);</span>
        SIGNAL_UNLOCK ();
      }
  
    return n_handlers;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2888,28 ***</span>
   *
   * Returns: The number of handlers that matched.
   */
  guint
  g_signal_handlers_unblock_matched (gpointer         instance,
<span class="line-modified">!                    GSignalMatchType mask,</span>
<span class="line-modified">!                    guint            signal_id,</span>
<span class="line-modified">!                    GQuark           detail,</span>
<span class="line-modified">!                    GClosure        *closure,</span>
<span class="line-modified">!                    gpointer         func,</span>
<span class="line-modified">!                    gpointer         data)</span>
  {
    guint n_handlers = 0;
  
    g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
    g_return_val_if_fail ((mask &amp; ~G_SIGNAL_MATCH_MASK) == 0, 0);
  
    if (mask &amp; (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
      {
        SIGNAL_LOCK ();
        n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
<span class="line-modified">!                               closure, func, data,</span>
<span class="line-modified">!                               g_signal_handler_unblock);</span>
        SIGNAL_UNLOCK ();
      }
  
    return n_handlers;
  }
<span class="line-new-header">--- 2894,28 ---</span>
   *
   * Returns: The number of handlers that matched.
   */
  guint
  g_signal_handlers_unblock_matched (gpointer         instance,
<span class="line-modified">!            GSignalMatchType mask,</span>
<span class="line-modified">!            guint            signal_id,</span>
<span class="line-modified">!            GQuark           detail,</span>
<span class="line-modified">!            GClosure        *closure,</span>
<span class="line-modified">!            gpointer         func,</span>
<span class="line-modified">!            gpointer         data)</span>
  {
    guint n_handlers = 0;
  
    g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
    g_return_val_if_fail ((mask &amp; ~G_SIGNAL_MATCH_MASK) == 0, 0);
  
    if (mask &amp; (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
      {
        SIGNAL_LOCK ();
        n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
<span class="line-modified">!                   closure, func, data,</span>
<span class="line-modified">!                   g_signal_handler_unblock);</span>
        SIGNAL_UNLOCK ();
      }
  
    return n_handlers;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2936,28 ***</span>
   *
   * Returns: The number of handlers that matched.
   */
  guint
  g_signal_handlers_disconnect_matched (gpointer         instance,
<span class="line-modified">!                       GSignalMatchType mask,</span>
<span class="line-modified">!                       guint            signal_id,</span>
<span class="line-modified">!                       GQuark           detail,</span>
<span class="line-modified">!                       GClosure        *closure,</span>
<span class="line-modified">!                       gpointer         func,</span>
<span class="line-modified">!                       gpointer         data)</span>
  {
    guint n_handlers = 0;
  
    g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
    g_return_val_if_fail ((mask &amp; ~G_SIGNAL_MATCH_MASK) == 0, 0);
  
    if (mask &amp; (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
      {
        SIGNAL_LOCK ();
        n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
<span class="line-modified">!                               closure, func, data,</span>
<span class="line-modified">!                               g_signal_handler_disconnect);</span>
        SIGNAL_UNLOCK ();
      }
  
    return n_handlers;
  }
<span class="line-new-header">--- 2942,28 ---</span>
   *
   * Returns: The number of handlers that matched.
   */
  guint
  g_signal_handlers_disconnect_matched (gpointer         instance,
<span class="line-modified">!               GSignalMatchType mask,</span>
<span class="line-modified">!               guint            signal_id,</span>
<span class="line-modified">!               GQuark           detail,</span>
<span class="line-modified">!               GClosure        *closure,</span>
<span class="line-modified">!               gpointer         func,</span>
<span class="line-modified">!               gpointer         data)</span>
  {
    guint n_handlers = 0;
  
    g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
    g_return_val_if_fail ((mask &amp; ~G_SIGNAL_MATCH_MASK) == 0, 0);
  
    if (mask &amp; (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
      {
        SIGNAL_LOCK ();
        n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
<span class="line-modified">!                   closure, func, data,</span>
<span class="line-modified">!                   g_signal_handler_disconnect);</span>
        SIGNAL_UNLOCK ();
      }
  
    return n_handlers;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2989,13 ***</span>
   * Returns: %TRUE if a handler is connected to the signal, %FALSE
   *          otherwise.
   */
  gboolean
  g_signal_has_handler_pending (gpointer instance,
<span class="line-modified">!                   guint    signal_id,</span>
<span class="line-modified">!                   GQuark   detail,</span>
<span class="line-modified">!                   gboolean may_be_blocked)</span>
  {
    HandlerMatch *mlist;
    gboolean has_pending;
    SignalNode *node;
  
<span class="line-new-header">--- 2995,13 ---</span>
   * Returns: %TRUE if a handler is connected to the signal, %FALSE
   *          otherwise.
   */
  gboolean
  g_signal_has_handler_pending (gpointer instance,
<span class="line-modified">!             guint    signal_id,</span>
<span class="line-modified">!             GQuark   detail,</span>
<span class="line-modified">!             gboolean may_be_blocked)</span>
  {
    HandlerMatch *mlist;
    gboolean has_pending;
    SignalNode *node;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3010,19 ***</span>
  #ifndef GSTREAMER_LITE
        if (!(node-&gt;flags &amp; G_SIGNAL_DETAILED))
  #else // GSTREAMER_LITE
        if (node == NULL || !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
  #endif // GSTREAMER_LITE
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);</span>
<span class="line-modified">!       SIGNAL_UNLOCK ();</span>
<span class="line-modified">!       return FALSE;</span>
<span class="line-modified">!     }</span>
      }
    mlist = handlers_find (instance,
<span class="line-modified">!              (G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | (may_be_blocked ? 0 : G_SIGNAL_MATCH_UNBLOCKED)),</span>
<span class="line-modified">!              signal_id, detail, NULL, NULL, NULL, TRUE);</span>
    if (mlist)
      {
        has_pending = TRUE;
        handler_match_free1_R (mlist, instance);
      }
<span class="line-new-header">--- 3016,19 ---</span>
  #ifndef GSTREAMER_LITE
        if (!(node-&gt;flags &amp; G_SIGNAL_DETAILED))
  #else // GSTREAMER_LITE
        if (node == NULL || !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
  #endif // GSTREAMER_LITE
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);</span>
<span class="line-modified">!     SIGNAL_UNLOCK ();</span>
<span class="line-modified">!     return FALSE;</span>
<span class="line-modified">!   }</span>
      }
    mlist = handlers_find (instance,
<span class="line-modified">!        (G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | (may_be_blocked ? 0 : G_SIGNAL_MATCH_UNBLOCKED)),</span>
<span class="line-modified">!        signal_id, detail, NULL, NULL, NULL, TRUE);</span>
    if (mlist)
      {
        has_pending = TRUE;
        handler_match_free1_R (mlist, instance);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3030,11 ***</span>
      {
        ClassClosure *class_closure = signal_find_class_closure (node, G_TYPE_FROM_INSTANCE (instance));
        if (class_closure != NULL &amp;&amp; class_closure-&gt;instance_type != 0)
          has_pending = TRUE;
        else
<span class="line-modified">!     has_pending = FALSE;</span>
      }
    SIGNAL_UNLOCK ();
  
    return has_pending;
  }
<span class="line-new-header">--- 3036,11 ---</span>
      {
        ClassClosure *class_closure = signal_find_class_closure (node, G_TYPE_FROM_INSTANCE (instance));
        if (class_closure != NULL &amp;&amp; class_closure-&gt;instance_type != 0)
          has_pending = TRUE;
        else
<span class="line-modified">!         has_pending = FALSE;</span>
      }
    SIGNAL_UNLOCK ();
  
    return has_pending;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3055,13 ***</span>
   * Note that g_signal_emitv() doesn&#39;t change @return_value if no handlers are
   * connected, in contrast to g_signal_emit() and g_signal_emit_valist().
   */
  void
  g_signal_emitv (const GValue *instance_and_params,
<span class="line-modified">!                 guint         signal_id,</span>
<span class="line-modified">!         GQuark        detail,</span>
<span class="line-modified">!                 GValue       *return_value)</span>
  {
    gpointer instance;
    SignalNode *node;
  #ifdef G_ENABLE_DEBUG
    const GValue *param_values;
<span class="line-new-header">--- 3061,13 ---</span>
   * Note that g_signal_emitv() doesn&#39;t change @return_value if no handlers are
   * connected, in contrast to g_signal_emit() and g_signal_emit_valist().
   */
  void
  g_signal_emitv (const GValue *instance_and_params,
<span class="line-modified">!     guint         signal_id,</span>
<span class="line-modified">!     GQuark        detail,</span>
<span class="line-modified">!     GValue       *return_value)</span>
  {
    gpointer instance;
    SignalNode *node;
  #ifdef G_ENABLE_DEBUG
    const GValue *param_values;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3093,40 ***</span>
        return;
      }
    for (i = 0; i &lt; node-&gt;n_params; i++)
      if (!G_TYPE_CHECK_VALUE_TYPE (param_values + i, node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
        {
<span class="line-modified">!     g_critical (&quot;%s: value for &#39;%s&#39; parameter %u for signal \&quot;%s\&quot; is of type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!             G_STRLOC,</span>
<span class="line-modified">!             type_debug_name (node-&gt;param_types[i]),</span>
<span class="line-modified">!             i,</span>
<span class="line-modified">!             node-&gt;name,</span>
<span class="line-modified">!             G_VALUE_TYPE_NAME (param_values + i));</span>
<span class="line-modified">!     SIGNAL_UNLOCK ();</span>
<span class="line-modified">!     return;</span>
        }
    if (node-&gt;return_type != G_TYPE_NONE)
      {
        if (!return_value)
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_critical (&quot;%s: return value &#39;%s&#39; for signal \&quot;%s\&quot; is (NULL)&quot;,</span>
<span class="line-modified">!               G_STRLOC,</span>
<span class="line-modified">!               type_debug_name (node-&gt;return_type),</span>
<span class="line-modified">!               node-&gt;name);</span>
<span class="line-modified">!       SIGNAL_UNLOCK ();</span>
<span class="line-modified">!       return;</span>
<span class="line-modified">!     }</span>
        else if (!node-&gt;accumulator &amp;&amp; !G_TYPE_CHECK_VALUE_TYPE (return_value, node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_critical (&quot;%s: return value &#39;%s&#39; for signal \&quot;%s\&quot; is of type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!               G_STRLOC,</span>
<span class="line-modified">!               type_debug_name (node-&gt;return_type),</span>
<span class="line-modified">!               node-&gt;name,</span>
<span class="line-modified">!               G_VALUE_TYPE_NAME (return_value));</span>
<span class="line-modified">!       SIGNAL_UNLOCK ();</span>
<span class="line-modified">!       return;</span>
<span class="line-modified">!     }</span>
      }
    else
      return_value = NULL;
  #endif  /* G_ENABLE_DEBUG */
  
<span class="line-new-header">--- 3099,40 ---</span>
        return;
      }
    for (i = 0; i &lt; node-&gt;n_params; i++)
      if (!G_TYPE_CHECK_VALUE_TYPE (param_values + i, node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
        {
<span class="line-modified">!   g_critical (&quot;%s: value for &#39;%s&#39; parameter %u for signal \&quot;%s\&quot; is of type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!         G_STRLOC,</span>
<span class="line-modified">!         type_debug_name (node-&gt;param_types[i]),</span>
<span class="line-modified">!         i,</span>
<span class="line-modified">!         node-&gt;name,</span>
<span class="line-modified">!         G_VALUE_TYPE_NAME (param_values + i));</span>
<span class="line-modified">!   SIGNAL_UNLOCK ();</span>
<span class="line-modified">!   return;</span>
        }
    if (node-&gt;return_type != G_TYPE_NONE)
      {
        if (!return_value)
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_critical (&quot;%s: return value &#39;%s&#39; for signal \&quot;%s\&quot; is (NULL)&quot;,</span>
<span class="line-modified">!           G_STRLOC,</span>
<span class="line-modified">!           type_debug_name (node-&gt;return_type),</span>
<span class="line-modified">!           node-&gt;name);</span>
<span class="line-modified">!     SIGNAL_UNLOCK ();</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
        else if (!node-&gt;accumulator &amp;&amp; !G_TYPE_CHECK_VALUE_TYPE (return_value, node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_critical (&quot;%s: return value &#39;%s&#39; for signal \&quot;%s\&quot; is of type &#39;%s&#39;&quot;,</span>
<span class="line-modified">!           G_STRLOC,</span>
<span class="line-modified">!           type_debug_name (node-&gt;return_type),</span>
<span class="line-modified">!           node-&gt;name,</span>
<span class="line-modified">!           G_VALUE_TYPE_NAME (return_value));</span>
<span class="line-modified">!     SIGNAL_UNLOCK ();</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
      }
    else
      return_value = NULL;
  #endif  /* G_ENABLE_DEBUG */
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3138,27 ***</span>
        (node-&gt;single_va_closure == SINGLE_VA_CLOSURE_EMPTY_MAGIC ||
         _g_closure_is_void (node-&gt;single_va_closure, instance)))
      {
        HandlerList* hlist = handler_list_lookup (node-&gt;signal_id, instance);
        if (hlist == NULL || hlist-&gt;handlers == NULL)
<span class="line-modified">!     {</span>
<span class="line-modified">!       /* nothing to do to emit this signal */</span>
<span class="line-modified">!       SIGNAL_UNLOCK ();</span>
<span class="line-modified">!       /* g_printerr (&quot;omitting emission of \&quot;%s\&quot;\n&quot;, node-&gt;name); */</span>
<span class="line-modified">!       return;</span>
<span class="line-modified">!     }</span>
      }
  
    SIGNAL_UNLOCK ();
    signal_emit_unlocked_R (node, detail, instance, return_value, instance_and_params);
  }
  
  static inline gboolean
  accumulate (GSignalInvocationHint *ihint,
<span class="line-modified">!             GValue                *return_accu,</span>
<span class="line-modified">!         GValue            *handler_return,</span>
<span class="line-modified">!             SignalAccumulator     *accumulator)</span>
  {
    gboolean continue_emission;
  
    if (!accumulator)
      return TRUE;
<span class="line-new-header">--- 3144,27 ---</span>
        (node-&gt;single_va_closure == SINGLE_VA_CLOSURE_EMPTY_MAGIC ||
         _g_closure_is_void (node-&gt;single_va_closure, instance)))
      {
        HandlerList* hlist = handler_list_lookup (node-&gt;signal_id, instance);
        if (hlist == NULL || hlist-&gt;handlers == NULL)
<span class="line-modified">!   {</span>
<span class="line-modified">!     /* nothing to do to emit this signal */</span>
<span class="line-modified">!     SIGNAL_UNLOCK ();</span>
<span class="line-modified">!     /* g_printerr (&quot;omitting emission of \&quot;%s\&quot;\n&quot;, node-&gt;name); */</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
      }
  
    SIGNAL_UNLOCK ();
    signal_emit_unlocked_R (node, detail, instance, return_value, instance_and_params);
  }
  
  static inline gboolean
  accumulate (GSignalInvocationHint *ihint,
<span class="line-modified">!       GValue                *return_accu,</span>
<span class="line-modified">!       GValue            *handler_return,</span>
<span class="line-modified">!       SignalAccumulator     *accumulator)</span>
  {
    gboolean continue_emission;
  
    if (!accumulator)
      return TRUE;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3184,13 ***</span>
   * Note that g_signal_emit_valist() resets the return value to the default
   * if no handlers are connected, in contrast to g_signal_emitv().
   */
  void
  g_signal_emit_valist (gpointer instance,
<span class="line-modified">!               guint    signal_id,</span>
<span class="line-modified">!               GQuark   detail,</span>
<span class="line-modified">!               va_list  var_args)</span>
  {
    GValue *instance_and_params;
    GType signal_return_type;
    GValue *param_values;
    SignalNode *node;
<span class="line-new-header">--- 3190,13 ---</span>
   * Note that g_signal_emit_valist() resets the return value to the default
   * if no handlers are connected, in contrast to g_signal_emitv().
   */
  void
  g_signal_emit_valist (gpointer instance,
<span class="line-modified">!           guint    signal_id,</span>
<span class="line-modified">!           GQuark   detail,</span>
<span class="line-modified">!           va_list  var_args)</span>
  {
    GValue *instance_and_params;
    GType signal_return_type;
    GValue *param_values;
    SignalNode *node;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3227,155 ***</span>
        GClosure *closure = NULL;
        gboolean fastpath = TRUE;
        GSignalFlags run_type = G_SIGNAL_RUN_FIRST;
  
        if (node-&gt;single_va_closure != SINGLE_VA_CLOSURE_EMPTY_MAGIC &amp;&amp;
<span class="line-modified">!       !_g_closure_is_void (node-&gt;single_va_closure, instance))</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       if (_g_closure_supports_invoke_va (node-&gt;single_va_closure))</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           closure = node-&gt;single_va_closure;</span>
<span class="line-modified">!           if (node-&gt;single_va_closure_is_after)</span>
<span class="line-modified">!         run_type = G_SIGNAL_RUN_LAST;</span>
<span class="line-modified">!           else</span>
<span class="line-modified">!         run_type = G_SIGNAL_RUN_FIRST;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       else</span>
<span class="line-modified">!         fastpath = FALSE;</span>
<span class="line-modified">!     }</span>
  
        for (l = hlist ? hlist-&gt;handlers : NULL; fastpath &amp;&amp; l != NULL; l = l-&gt;next)
      {
<span class="line-removed">-       if (!l-&gt;block_count &amp;&amp;</span>
<span class="line-removed">-           (!l-&gt;detail || l-&gt;detail == detail))</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           if (closure != NULL || !_g_closure_supports_invoke_va (l-&gt;closure))</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           fastpath = FALSE;</span>
<span class="line-removed">-           break;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-           else</span>
<span class="line-removed">-         {</span>
                    fastpath_handler = l;
<span class="line-modified">!           closure = l-&gt;closure;</span>
<span class="line-modified">!           if (l-&gt;after)</span>
<span class="line-modified">!             run_type = G_SIGNAL_RUN_LAST;</span>
<span class="line-modified">!           else</span>
<span class="line-modified">!             run_type = G_SIGNAL_RUN_FIRST;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         }</span>
      }
  
        if (fastpath &amp;&amp; closure == NULL &amp;&amp; node-&gt;return_type == G_TYPE_NONE)
<span class="line-modified">!     {</span>
<span class="line-modified">!       SIGNAL_UNLOCK ();</span>
<span class="line-modified">!       return;</span>
<span class="line-modified">!     }</span>
  
        /* Don&#39;t allow no-recurse emission as we might have to restart, which means
<span class="line-modified">!      we will run multiple handlers and thus must ref all arguments */</span>
        if (closure != NULL &amp;&amp; (node-&gt;flags &amp; (G_SIGNAL_NO_RECURSE)) != 0)
<span class="line-modified">!     fastpath = FALSE;</span>
  
        if (fastpath)
<span class="line-modified">!     {</span>
<span class="line-modified">!       SignalAccumulator *accumulator;</span>
<span class="line-modified">!       Emission emission;</span>
<span class="line-modified">!       GValue *return_accu, accu = G_VALUE_INIT;</span>
<span class="line-modified">!       guint signal_id;</span>
<span class="line-modified">!       GType instance_type = G_TYPE_FROM_INSTANCE (instance);</span>
<span class="line-modified">!       GValue emission_return = G_VALUE_INIT;</span>
            GType rtype = node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
<span class="line-modified">!       gboolean static_scope = node-&gt;return_type &amp; G_SIGNAL_TYPE_STATIC_SCOPE;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       signal_id = node-&gt;signal_id;</span>
<span class="line-removed">-       accumulator = node-&gt;accumulator;</span>
<span class="line-removed">-       if (rtype == G_TYPE_NONE)</span>
<span class="line-removed">-         return_accu = NULL;</span>
<span class="line-removed">-       else if (accumulator)</span>
<span class="line-removed">-         return_accu = &amp;accu;</span>
<span class="line-removed">-       else</span>
<span class="line-removed">-         return_accu = &amp;emission_return;</span>
  
<span class="line-modified">!       emission.instance = instance;</span>
<span class="line-modified">!       emission.ihint.signal_id = signal_id;</span>
<span class="line-modified">!       emission.ihint.detail = detail;</span>
<span class="line-modified">!       emission.ihint.run_type = run_type;</span>
<span class="line-modified">!       emission.state = EMISSION_RUN;</span>
<span class="line-modified">!       emission.chain_type = instance_type;</span>
<span class="line-modified">!       emission_push (&amp;emission);</span>
  
            if (fastpath_handler)
              handler_ref (fastpath_handler);
  
<span class="line-modified">!       SIGNAL_UNLOCK ();</span>
  
<span class="line-modified">!       TRACE(GOBJECT_SIGNAL_EMIT(signal_id, detail, instance, instance_type));</span>
  
<span class="line-modified">!       if (rtype != G_TYPE_NONE)</span>
<span class="line-modified">!         g_value_init (&amp;emission_return, rtype);</span>
  
<span class="line-modified">!       if (accumulator)</span>
<span class="line-modified">!         g_value_init (&amp;accu, rtype);</span>
  
<span class="line-modified">!       if (closure != NULL)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           g_object_ref (instance);</span>
<span class="line-modified">!           _g_closure_invoke_va (closure,</span>
<span class="line-modified">!                     return_accu,</span>
<span class="line-modified">!                     instance,</span>
<span class="line-modified">!                     var_args,</span>
<span class="line-modified">!                     node-&gt;n_params,</span>
<span class="line-modified">!                     node-&gt;param_types);</span>
<span class="line-modified">!           accumulate (&amp;emission.ihint, &amp;emission_return, &amp;accu, accumulator);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!       SIGNAL_LOCK ();</span>
  
<span class="line-modified">!       emission.chain_type = G_TYPE_NONE;</span>
<span class="line-modified">!       emission_pop (&amp;emission);</span>
  
            if (fastpath_handler)
              handler_unref_R (signal_id, instance, fastpath_handler);
  
<span class="line-modified">!       SIGNAL_UNLOCK ();</span>
  
<span class="line-modified">!       if (accumulator)</span>
<span class="line-modified">!         g_value_unset (&amp;accu);</span>
  
<span class="line-modified">!       if (rtype != G_TYPE_NONE)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           gchar *error = NULL;</span>
<span class="line-modified">!           for (i = 0; i &lt; node-&gt;n_params; i++)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           GType ptype = node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;</span>
<span class="line-modified">!           G_VALUE_COLLECT_SKIP (ptype, var_args);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!           G_VALUE_LCOPY (&amp;emission_return,</span>
<span class="line-modified">!                  var_args,</span>
<span class="line-modified">!                  static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="line-modified">!                  &amp;error);</span>
<span class="line-modified">!           if (!error)</span>
<span class="line-modified">!         g_value_unset (&amp;emission_return);</span>
<span class="line-modified">!           else</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           g_warning (&quot;%s: %s&quot;, G_STRLOC, error);</span>
<span class="line-modified">!           g_free (error);</span>
<span class="line-modified">!           /* we purposely leak the value here, it might not be</span>
<span class="line-modified">!            * in a sane state if an error condition occurred</span>
<span class="line-modified">!            */</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!       TRACE(GOBJECT_SIGNAL_EMIT_END(signal_id, detail, instance, instance_type));</span>
  
            if (closure != NULL)
              g_object_unref (instance);
  
<span class="line-modified">!       return;</span>
<span class="line-modified">!     }</span>
      }
    SIGNAL_UNLOCK ();
  
    n_params = node-&gt;n_params;
    signal_return_type = node-&gt;return_type;
<span class="line-new-header">--- 3233,155 ---</span>
        GClosure *closure = NULL;
        gboolean fastpath = TRUE;
        GSignalFlags run_type = G_SIGNAL_RUN_FIRST;
  
        if (node-&gt;single_va_closure != SINGLE_VA_CLOSURE_EMPTY_MAGIC &amp;&amp;
<span class="line-modified">!     !_g_closure_is_void (node-&gt;single_va_closure, instance))</span>
<span class="line-modified">!   {</span>
<span class="line-modified">!     if (_g_closure_supports_invoke_va (node-&gt;single_va_closure))</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         closure = node-&gt;single_va_closure;</span>
<span class="line-modified">!         if (node-&gt;single_va_closure_is_after)</span>
<span class="line-modified">!     run_type = G_SIGNAL_RUN_LAST;</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!     run_type = G_SIGNAL_RUN_FIRST;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       fastpath = FALSE;</span>
<span class="line-modified">!   }</span>
  
        for (l = hlist ? hlist-&gt;handlers : NULL; fastpath &amp;&amp; l != NULL; l = l-&gt;next)
<span class="line-added">+   {</span>
<span class="line-added">+     if (!l-&gt;block_count &amp;&amp;</span>
<span class="line-added">+         (!l-&gt;detail || l-&gt;detail == detail))</span>
<span class="line-added">+       {</span>
<span class="line-added">+         if (closure != NULL || !_g_closure_supports_invoke_va (l-&gt;closure))</span>
<span class="line-added">+     {</span>
<span class="line-added">+       fastpath = FALSE;</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+         else</span>
      {
                    fastpath_handler = l;
<span class="line-modified">!       closure = l-&gt;closure;</span>
<span class="line-modified">!       if (l-&gt;after)</span>
<span class="line-modified">!         run_type = G_SIGNAL_RUN_LAST;</span>
<span class="line-modified">!       else</span>
<span class="line-modified">!         run_type = G_SIGNAL_RUN_FIRST;</span>
      }
<span class="line-added">+       }</span>
<span class="line-added">+   }</span>
  
        if (fastpath &amp;&amp; closure == NULL &amp;&amp; node-&gt;return_type == G_TYPE_NONE)
<span class="line-modified">!   {</span>
<span class="line-modified">!     SIGNAL_UNLOCK ();</span>
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
  
        /* Don&#39;t allow no-recurse emission as we might have to restart, which means
<span class="line-modified">!    we will run multiple handlers and thus must ref all arguments */</span>
        if (closure != NULL &amp;&amp; (node-&gt;flags &amp; (G_SIGNAL_NO_RECURSE)) != 0)
<span class="line-modified">!   fastpath = FALSE;</span>
  
        if (fastpath)
<span class="line-modified">!   {</span>
<span class="line-modified">!     SignalAccumulator *accumulator;</span>
<span class="line-modified">!     Emission emission;</span>
<span class="line-modified">!     GValue *return_accu, accu = G_VALUE_INIT;</span>
<span class="line-modified">!     guint signal_id;</span>
<span class="line-modified">!     GType instance_type = G_TYPE_FROM_INSTANCE (instance);</span>
<span class="line-modified">!     GValue emission_return = G_VALUE_INIT;</span>
            GType rtype = node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
<span class="line-modified">!     gboolean static_scope = node-&gt;return_type &amp; G_SIGNAL_TYPE_STATIC_SCOPE;</span>
  
<span class="line-modified">!     signal_id = node-&gt;signal_id;</span>
<span class="line-modified">!     accumulator = node-&gt;accumulator;</span>
<span class="line-modified">!     if (rtype == G_TYPE_NONE)</span>
<span class="line-modified">!       return_accu = NULL;</span>
<span class="line-modified">!     else if (accumulator)</span>
<span class="line-modified">!       return_accu = &amp;accu;</span>
<span class="line-modified">!     else</span>
<span class="line-added">+       return_accu = &amp;emission_return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     emission.instance = instance;</span>
<span class="line-added">+     emission.ihint.signal_id = signal_id;</span>
<span class="line-added">+     emission.ihint.detail = detail;</span>
<span class="line-added">+     emission.ihint.run_type = run_type;</span>
<span class="line-added">+     emission.state = EMISSION_RUN;</span>
<span class="line-added">+     emission.chain_type = instance_type;</span>
<span class="line-added">+     emission_push (&amp;emission);</span>
  
            if (fastpath_handler)
              handler_ref (fastpath_handler);
  
<span class="line-modified">!     SIGNAL_UNLOCK ();</span>
  
<span class="line-modified">!     TRACE(GOBJECT_SIGNAL_EMIT(signal_id, detail, instance, instance_type));</span>
  
<span class="line-modified">!     if (rtype != G_TYPE_NONE)</span>
<span class="line-modified">!       g_value_init (&amp;emission_return, rtype);</span>
  
<span class="line-modified">!     if (accumulator)</span>
<span class="line-modified">!       g_value_init (&amp;accu, rtype);</span>
  
<span class="line-modified">!     if (closure != NULL)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         g_object_ref (instance);</span>
<span class="line-modified">!         _g_closure_invoke_va (closure,</span>
<span class="line-modified">!             return_accu,</span>
<span class="line-modified">!             instance,</span>
<span class="line-modified">!             var_args,</span>
<span class="line-modified">!             node-&gt;n_params,</span>
<span class="line-modified">!             node-&gt;param_types);</span>
<span class="line-modified">!         accumulate (&amp;emission.ihint, &amp;emission_return, &amp;accu, accumulator);</span>
<span class="line-modified">!       }</span>
  
<span class="line-modified">!     SIGNAL_LOCK ();</span>
  
<span class="line-modified">!     emission.chain_type = G_TYPE_NONE;</span>
<span class="line-modified">!     emission_pop (&amp;emission);</span>
  
            if (fastpath_handler)
              handler_unref_R (signal_id, instance, fastpath_handler);
  
<span class="line-modified">!     SIGNAL_UNLOCK ();</span>
  
<span class="line-modified">!     if (accumulator)</span>
<span class="line-modified">!       g_value_unset (&amp;accu);</span>
  
<span class="line-modified">!     if (rtype != G_TYPE_NONE)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         gchar *error = NULL;</span>
<span class="line-modified">!         for (i = 0; i &lt; node-&gt;n_params; i++)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       GType ptype = node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;</span>
<span class="line-modified">!       G_VALUE_COLLECT_SKIP (ptype, var_args);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!         G_VALUE_LCOPY (&amp;emission_return,</span>
<span class="line-modified">!            var_args,</span>
<span class="line-modified">!            static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="line-modified">!            &amp;error);</span>
<span class="line-modified">!         if (!error)</span>
<span class="line-modified">!     g_value_unset (&amp;emission_return);</span>
<span class="line-modified">!         else</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;%s: %s&quot;, G_STRLOC, error);</span>
<span class="line-modified">!       g_free (error);</span>
<span class="line-modified">!       /* we purposely leak the value here, it might not be</span>
<span class="line-modified">!        * in a sane state if an error condition occurred</span>
<span class="line-modified">!        */</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!       }</span>
  
<span class="line-modified">!     TRACE(GOBJECT_SIGNAL_EMIT_END(signal_id, detail, instance, instance_type));</span>
  
            if (closure != NULL)
              g_object_unref (instance);
  
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
      }
    SIGNAL_UNLOCK ();
  
    n_params = node-&gt;n_params;
    signal_return_type = node-&gt;return_type;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3388,26 ***</span>
        gchar *error;
        GType ptype = node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
        gboolean static_scope = node-&gt;param_types[i] &amp; G_SIGNAL_TYPE_STATIC_SCOPE;
  
        G_VALUE_COLLECT_INIT (param_values + i, ptype,
<span class="line-modified">!                 var_args,</span>
<span class="line-modified">!                 static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="line-modified">!                 &amp;error);</span>
        if (error)
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;%s: %s&quot;, G_STRLOC, error);</span>
<span class="line-modified">!       g_free (error);</span>
  
<span class="line-modified">!       /* we purposely leak the value here, it might not be</span>
<span class="line-modified">!        * in a sane state if an error condition occoured</span>
<span class="line-modified">!        */</span>
<span class="line-modified">!       while (i--)</span>
<span class="line-modified">!         g_value_unset (param_values + i);</span>
  
<span class="line-modified">!       return;</span>
<span class="line-modified">!     }</span>
      }
  
    instance_and_params-&gt;g_type = 0;
    g_value_init_from_instance (instance_and_params, instance);
    if (signal_return_type == G_TYPE_NONE)
<span class="line-new-header">--- 3394,26 ---</span>
        gchar *error;
        GType ptype = node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
        gboolean static_scope = node-&gt;param_types[i] &amp; G_SIGNAL_TYPE_STATIC_SCOPE;
  
        G_VALUE_COLLECT_INIT (param_values + i, ptype,
<span class="line-modified">!           var_args,</span>
<span class="line-modified">!           static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="line-modified">!           &amp;error);</span>
        if (error)
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;%s: %s&quot;, G_STRLOC, error);</span>
<span class="line-modified">!     g_free (error);</span>
  
<span class="line-modified">!     /* we purposely leak the value here, it might not be</span>
<span class="line-modified">!      * in a sane state if an error condition occoured</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!     while (i--)</span>
<span class="line-modified">!       g_value_unset (param_values + i);</span>
  
<span class="line-modified">!     return;</span>
<span class="line-modified">!   }</span>
      }
  
    instance_and_params-&gt;g_type = 0;
    g_value_init_from_instance (instance_and_params, instance);
    if (signal_return_type == G_TYPE_NONE)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3422,24 ***</span>
        g_value_init (&amp;return_value, rtype);
  
        signal_emit_unlocked_R (node, detail, instance, &amp;return_value, instance_and_params);
  
        G_VALUE_LCOPY (&amp;return_value,
<span class="line-modified">!              var_args,</span>
<span class="line-modified">!              static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="line-modified">!              &amp;error);</span>
        if (!error)
<span class="line-modified">!     g_value_unset (&amp;return_value);</span>
        else
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_warning (&quot;%s: %s&quot;, G_STRLOC, error);</span>
<span class="line-modified">!       g_free (error);</span>
  
<span class="line-modified">!       /* we purposely leak the value here, it might not be</span>
<span class="line-modified">!        * in a sane state if an error condition occurred</span>
<span class="line-modified">!        */</span>
<span class="line-modified">!     }</span>
      }
    for (i = 0; i &lt; n_params; i++)
      g_value_unset (param_values + i);
    g_value_unset (instance_and_params);
  }
<span class="line-new-header">--- 3428,24 ---</span>
        g_value_init (&amp;return_value, rtype);
  
        signal_emit_unlocked_R (node, detail, instance, &amp;return_value, instance_and_params);
  
        G_VALUE_LCOPY (&amp;return_value,
<span class="line-modified">!          var_args,</span>
<span class="line-modified">!          static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="line-modified">!          &amp;error);</span>
        if (!error)
<span class="line-modified">!   g_value_unset (&amp;return_value);</span>
        else
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_warning (&quot;%s: %s&quot;, G_STRLOC, error);</span>
<span class="line-modified">!     g_free (error);</span>
  
<span class="line-modified">!     /* we purposely leak the value here, it might not be</span>
<span class="line-modified">!      * in a sane state if an error condition occurred</span>
<span class="line-modified">!      */</span>
<span class="line-modified">!   }</span>
      }
    for (i = 0; i &lt; n_params; i++)
      g_value_unset (param_values + i);
    g_value_unset (instance_and_params);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3458,13 ***</span>
   * Note that g_signal_emit() resets the return value to the default
   * if no handlers are connected, in contrast to g_signal_emitv().
   */
  void
  g_signal_emit (gpointer instance,
<span class="line-modified">!            guint    signal_id,</span>
<span class="line-modified">!            GQuark   detail,</span>
<span class="line-modified">!            ...)</span>
  {
    va_list var_args;
  
    va_start (var_args, detail);
    g_signal_emit_valist (instance, signal_id, detail, var_args);
<span class="line-new-header">--- 3464,13 ---</span>
   * Note that g_signal_emit() resets the return value to the default
   * if no handlers are connected, in contrast to g_signal_emitv().
   */
  void
  g_signal_emit (gpointer instance,
<span class="line-modified">!          guint    signal_id,</span>
<span class="line-modified">!          GQuark   detail,</span>
<span class="line-modified">!          ...)</span>
  {
    va_list var_args;
  
    va_start (var_args, detail);
    g_signal_emit_valist (instance, signal_id, detail, var_args);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3484,12 ***</span>
   * Note that g_signal_emit_by_name() resets the return value to the default
   * if no handlers are connected, in contrast to g_signal_emitv().
   */
  void
  g_signal_emit_by_name (gpointer     instance,
<span class="line-modified">!                const gchar *detailed_signal,</span>
<span class="line-modified">!                ...)</span>
  {
    GQuark detail = 0;
    guint signal_id;
    GType itype;
  
<span class="line-new-header">--- 3490,12 ---</span>
   * Note that g_signal_emit_by_name() resets the return value to the default
   * if no handlers are connected, in contrast to g_signal_emitv().
   */
  void
  g_signal_emit_by_name (gpointer     instance,
<span class="line-modified">!            const gchar *detailed_signal,</span>
<span class="line-modified">!            ...)</span>
  {
    GQuark detail = 0;
    guint signal_id;
    GType itype;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3515,14 ***</span>
                 G_STRLOC, detailed_signal, instance, g_type_name (itype));
  }
  
  static gboolean
  signal_emit_unlocked_R (SignalNode   *node,
<span class="line-modified">!             GQuark        detail,</span>
<span class="line-modified">!                         gpointer      instance,</span>
<span class="line-modified">!             GValue       *emission_return,</span>
<span class="line-modified">!                         const GValue *instance_and_params)</span>
  {
    SignalAccumulator *accumulator;
    Emission emission;
    GClosure *class_closure;
    HandlerList *hlist;
<span class="line-new-header">--- 3521,14 ---</span>
                 G_STRLOC, detailed_signal, instance, g_type_name (itype));
  }
  
  static gboolean
  signal_emit_unlocked_R (SignalNode   *node,
<span class="line-modified">!       GQuark        detail,</span>
<span class="line-modified">!       gpointer      instance,</span>
<span class="line-modified">!       GValue       *emission_return,</span>
<span class="line-modified">!       const GValue *instance_and_params)</span>
  {
    SignalAccumulator *accumulator;
    Emission emission;
    GClosure *class_closure;
    HandlerList *hlist;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3540,15 ***</span>
    if (node-&gt;flags &amp; G_SIGNAL_NO_RECURSE)
      {
        Emission *node = emission_find (signal_id, detail, instance);
  
        if (node)
<span class="line-modified">!     {</span>
<span class="line-modified">!       node-&gt;state = EMISSION_RESTART;</span>
<span class="line-modified">!       SIGNAL_UNLOCK ();</span>
<span class="line-modified">!       return return_value_altered;</span>
<span class="line-modified">!     }</span>
      }
    accumulator = node-&gt;accumulator;
    if (accumulator)
      {
        SIGNAL_UNLOCK ();
<span class="line-new-header">--- 3546,15 ---</span>
    if (node-&gt;flags &amp; G_SIGNAL_NO_RECURSE)
      {
        Emission *node = emission_find (signal_id, detail, instance);
  
        if (node)
<span class="line-modified">!   {</span>
<span class="line-modified">!     node-&gt;state = EMISSION_RESTART;</span>
<span class="line-modified">!     SIGNAL_UNLOCK ();</span>
<span class="line-modified">!     return return_value_altered;</span>
<span class="line-modified">!   }</span>
      }
    accumulator = node-&gt;accumulator;
    if (accumulator)
      {
        SIGNAL_UNLOCK ();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3584,107 ***</span>
        emission.state = EMISSION_RUN;
  
        emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
        SIGNAL_UNLOCK ();
        g_closure_invoke (class_closure,
<span class="line-modified">!             return_accu,</span>
<span class="line-modified">!             node-&gt;n_params + 1,</span>
<span class="line-modified">!             instance_and_params,</span>
<span class="line-modified">!             &amp;emission.ihint);</span>
        if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;
<span class="line-modified">!       emission.state == EMISSION_RUN)</span>
<span class="line-modified">!     emission.state = EMISSION_STOP;</span>
        SIGNAL_LOCK ();
        emission.chain_type = G_TYPE_NONE;
        return_value_altered = TRUE;
  
        if (emission.state == EMISSION_STOP)
<span class="line-modified">!     goto EMIT_CLEANUP;</span>
        else if (emission.state == EMISSION_RESTART)
<span class="line-modified">!     goto EMIT_RESTART;</span>
      }
  
    if (node-&gt;emission_hooks)
      {
        gboolean need_destroy, was_in_call, may_recurse = TRUE;
        GHook *hook;
  
        emission.state = EMISSION_HOOK;
        hook = g_hook_first_valid (node-&gt;emission_hooks, may_recurse);
        while (hook)
<span class="line-modified">!     {</span>
<span class="line-modified">!       SignalHook *signal_hook = SIGNAL_HOOK (hook);</span>
  
<span class="line-modified">!       if (!signal_hook-&gt;detail || signal_hook-&gt;detail == detail)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           GSignalEmissionHook hook_func = (GSignalEmissionHook) hook-&gt;func;</span>
  
<span class="line-modified">!           was_in_call = G_HOOK_IN_CALL (hook);</span>
<span class="line-modified">!           hook-&gt;flags |= G_HOOK_FLAG_IN_CALL;</span>
                SIGNAL_UNLOCK ();
<span class="line-modified">!           need_destroy = !hook_func (&amp;emission.ihint, node-&gt;n_params + 1, instance_and_params, hook-&gt;data);</span>
<span class="line-modified">!           SIGNAL_LOCK ();</span>
<span class="line-modified">!           if (!was_in_call)</span>
<span class="line-modified">!         hook-&gt;flags &amp;= ~G_HOOK_FLAG_IN_CALL;</span>
<span class="line-modified">!           if (need_destroy)</span>
<span class="line-modified">!         g_hook_destroy_link (node-&gt;emission_hooks, hook);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       hook = g_hook_next_valid (node-&gt;emission_hooks, hook, may_recurse);</span>
<span class="line-modified">!     }</span>
  
        if (emission.state == EMISSION_RESTART)
<span class="line-modified">!     goto EMIT_RESTART;</span>
      }
  
    if (handler_list)
      {
        Handler *handler = handler_list;
  
        emission.state = EMISSION_RUN;
        handler_ref (handler);
        do
<span class="line-modified">!     {</span>
<span class="line-modified">!       Handler *tmp;</span>
  
<span class="line-modified">!       if (handler-&gt;after)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           handler_unref_R (signal_id, instance, handler_list);</span>
<span class="line-modified">!           handler_list = handler;</span>
<span class="line-modified">!           break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       else if (!handler-&gt;block_count &amp;&amp; (!handler-&gt;detail || handler-&gt;detail == detail) &amp;&amp;</span>
<span class="line-modified">!            handler-&gt;sequential_number &lt; max_sequential_handler_number)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           SIGNAL_UNLOCK ();</span>
<span class="line-modified">!           g_closure_invoke (handler-&gt;closure,</span>
<span class="line-modified">!                 return_accu,</span>
<span class="line-modified">!                 node-&gt;n_params + 1,</span>
<span class="line-modified">!                 instance_and_params,</span>
<span class="line-modified">!                 &amp;emission.ihint);</span>
<span class="line-modified">!           if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;</span>
<span class="line-modified">!           emission.state == EMISSION_RUN)</span>
<span class="line-modified">!         emission.state = EMISSION_STOP;</span>
<span class="line-modified">!           SIGNAL_LOCK ();</span>
<span class="line-modified">!           return_value_altered = TRUE;</span>
  
<span class="line-modified">!           tmp = emission.state == EMISSION_RUN ? handler-&gt;next : NULL;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       else</span>
<span class="line-modified">!         tmp = handler-&gt;next;</span>
  
<span class="line-modified">!       if (tmp)</span>
<span class="line-modified">!         handler_ref (tmp);</span>
<span class="line-modified">!       handler_unref_R (signal_id, instance, handler_list);</span>
<span class="line-modified">!       handler_list = handler;</span>
<span class="line-modified">!       handler = tmp;</span>
<span class="line-modified">!     }</span>
        while (handler);
  
        if (emission.state == EMISSION_STOP)
<span class="line-modified">!     goto EMIT_CLEANUP;</span>
        else if (emission.state == EMISSION_RESTART)
<span class="line-modified">!     goto EMIT_RESTART;</span>
      }
  
    emission.ihint.run_type = G_SIGNAL_RUN_LAST;
  
    if ((node-&gt;flags &amp; G_SIGNAL_RUN_LAST) &amp;&amp; class_closure)
<span class="line-new-header">--- 3590,107 ---</span>
        emission.state = EMISSION_RUN;
  
        emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
        SIGNAL_UNLOCK ();
        g_closure_invoke (class_closure,
<span class="line-modified">!       return_accu,</span>
<span class="line-modified">!       node-&gt;n_params + 1,</span>
<span class="line-modified">!       instance_and_params,</span>
<span class="line-modified">!       &amp;emission.ihint);</span>
        if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;
<span class="line-modified">!     emission.state == EMISSION_RUN)</span>
<span class="line-modified">!   emission.state = EMISSION_STOP;</span>
        SIGNAL_LOCK ();
        emission.chain_type = G_TYPE_NONE;
        return_value_altered = TRUE;
  
        if (emission.state == EMISSION_STOP)
<span class="line-modified">!   goto EMIT_CLEANUP;</span>
        else if (emission.state == EMISSION_RESTART)
<span class="line-modified">!   goto EMIT_RESTART;</span>
      }
  
    if (node-&gt;emission_hooks)
      {
        gboolean need_destroy, was_in_call, may_recurse = TRUE;
        GHook *hook;
  
        emission.state = EMISSION_HOOK;
        hook = g_hook_first_valid (node-&gt;emission_hooks, may_recurse);
        while (hook)
<span class="line-modified">!   {</span>
<span class="line-modified">!     SignalHook *signal_hook = SIGNAL_HOOK (hook);</span>
  
<span class="line-modified">!     if (!signal_hook-&gt;detail || signal_hook-&gt;detail == detail)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         GSignalEmissionHook hook_func = (GSignalEmissionHook) hook-&gt;func;</span>
  
<span class="line-modified">!         was_in_call = G_HOOK_IN_CALL (hook);</span>
<span class="line-modified">!         hook-&gt;flags |= G_HOOK_FLAG_IN_CALL;</span>
                SIGNAL_UNLOCK ();
<span class="line-modified">!         need_destroy = !hook_func (&amp;emission.ihint, node-&gt;n_params + 1, instance_and_params, hook-&gt;data);</span>
<span class="line-modified">!         SIGNAL_LOCK ();</span>
<span class="line-modified">!         if (!was_in_call)</span>
<span class="line-modified">!     hook-&gt;flags &amp;= ~G_HOOK_FLAG_IN_CALL;</span>
<span class="line-modified">!         if (need_destroy)</span>
<span class="line-modified">!     g_hook_destroy_link (node-&gt;emission_hooks, hook);</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     hook = g_hook_next_valid (node-&gt;emission_hooks, hook, may_recurse);</span>
<span class="line-modified">!   }</span>
  
        if (emission.state == EMISSION_RESTART)
<span class="line-modified">!   goto EMIT_RESTART;</span>
      }
  
    if (handler_list)
      {
        Handler *handler = handler_list;
  
        emission.state = EMISSION_RUN;
        handler_ref (handler);
        do
<span class="line-modified">!   {</span>
<span class="line-modified">!     Handler *tmp;</span>
  
<span class="line-modified">!     if (handler-&gt;after)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         handler_unref_R (signal_id, instance, handler_list);</span>
<span class="line-modified">!         handler_list = handler;</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     else if (!handler-&gt;block_count &amp;&amp; (!handler-&gt;detail || handler-&gt;detail == detail) &amp;&amp;</span>
<span class="line-modified">!        handler-&gt;sequential_number &lt; max_sequential_handler_number)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         SIGNAL_UNLOCK ();</span>
<span class="line-modified">!         g_closure_invoke (handler-&gt;closure,</span>
<span class="line-modified">!         return_accu,</span>
<span class="line-modified">!         node-&gt;n_params + 1,</span>
<span class="line-modified">!         instance_and_params,</span>
<span class="line-modified">!         &amp;emission.ihint);</span>
<span class="line-modified">!         if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;</span>
<span class="line-modified">!       emission.state == EMISSION_RUN)</span>
<span class="line-modified">!     emission.state = EMISSION_STOP;</span>
<span class="line-modified">!         SIGNAL_LOCK ();</span>
<span class="line-modified">!         return_value_altered = TRUE;</span>
  
<span class="line-modified">!         tmp = emission.state == EMISSION_RUN ? handler-&gt;next : NULL;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       tmp = handler-&gt;next;</span>
  
<span class="line-modified">!     if (tmp)</span>
<span class="line-modified">!       handler_ref (tmp);</span>
<span class="line-modified">!     handler_unref_R (signal_id, instance, handler_list);</span>
<span class="line-modified">!     handler_list = handler;</span>
<span class="line-modified">!     handler = tmp;</span>
<span class="line-modified">!   }</span>
        while (handler);
  
        if (emission.state == EMISSION_STOP)
<span class="line-modified">!   goto EMIT_CLEANUP;</span>
        else if (emission.state == EMISSION_RESTART)
<span class="line-modified">!   goto EMIT_RESTART;</span>
      }
  
    emission.ihint.run_type = G_SIGNAL_RUN_LAST;
  
    if ((node-&gt;flags &amp; G_SIGNAL_RUN_LAST) &amp;&amp; class_closure)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3692,68 ***</span>
        emission.state = EMISSION_RUN;
  
        emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
        SIGNAL_UNLOCK ();
        g_closure_invoke (class_closure,
<span class="line-modified">!             return_accu,</span>
<span class="line-modified">!             node-&gt;n_params + 1,</span>
<span class="line-modified">!             instance_and_params,</span>
<span class="line-modified">!             &amp;emission.ihint);</span>
        if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;
<span class="line-modified">!       emission.state == EMISSION_RUN)</span>
<span class="line-modified">!     emission.state = EMISSION_STOP;</span>
        SIGNAL_LOCK ();
        emission.chain_type = G_TYPE_NONE;
        return_value_altered = TRUE;
  
        if (emission.state == EMISSION_STOP)
<span class="line-modified">!     goto EMIT_CLEANUP;</span>
        else if (emission.state == EMISSION_RESTART)
<span class="line-modified">!     goto EMIT_RESTART;</span>
      }
  
    if (handler_list)
      {
        Handler *handler = handler_list;
  
        emission.state = EMISSION_RUN;
        handler_ref (handler);
        do
<span class="line-modified">!     {</span>
<span class="line-modified">!       Handler *tmp;</span>
  
<span class="line-modified">!       if (handler-&gt;after &amp;&amp; !handler-&gt;block_count &amp;&amp; (!handler-&gt;detail || handler-&gt;detail == detail) &amp;&amp;</span>
<span class="line-modified">!           handler-&gt;sequential_number &lt; max_sequential_handler_number)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           SIGNAL_UNLOCK ();</span>
<span class="line-modified">!           g_closure_invoke (handler-&gt;closure,</span>
<span class="line-modified">!                 return_accu,</span>
<span class="line-modified">!                 node-&gt;n_params + 1,</span>
<span class="line-modified">!                 instance_and_params,</span>
<span class="line-modified">!                 &amp;emission.ihint);</span>
<span class="line-modified">!           if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;</span>
<span class="line-modified">!           emission.state == EMISSION_RUN)</span>
<span class="line-modified">!         emission.state = EMISSION_STOP;</span>
<span class="line-modified">!           SIGNAL_LOCK ();</span>
<span class="line-modified">!           return_value_altered = TRUE;</span>
  
<span class="line-modified">!           tmp = emission.state == EMISSION_RUN ? handler-&gt;next : NULL;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!       else</span>
<span class="line-modified">!         tmp = handler-&gt;next;</span>
  
<span class="line-modified">!       if (tmp)</span>
<span class="line-modified">!         handler_ref (tmp);</span>
<span class="line-modified">!       handler_unref_R (signal_id, instance, handler);</span>
<span class="line-modified">!       handler = tmp;</span>
<span class="line-modified">!     }</span>
        while (handler);
  
        if (emission.state == EMISSION_STOP)
<span class="line-modified">!     goto EMIT_CLEANUP;</span>
        else if (emission.state == EMISSION_RESTART)
<span class="line-modified">!     goto EMIT_RESTART;</span>
      }
  
   EMIT_CLEANUP:
  
    emission.ihint.run_type = G_SIGNAL_RUN_CLEANUP;
<span class="line-new-header">--- 3698,68 ---</span>
        emission.state = EMISSION_RUN;
  
        emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
        SIGNAL_UNLOCK ();
        g_closure_invoke (class_closure,
<span class="line-modified">!       return_accu,</span>
<span class="line-modified">!       node-&gt;n_params + 1,</span>
<span class="line-modified">!       instance_and_params,</span>
<span class="line-modified">!       &amp;emission.ihint);</span>
        if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;
<span class="line-modified">!     emission.state == EMISSION_RUN)</span>
<span class="line-modified">!   emission.state = EMISSION_STOP;</span>
        SIGNAL_LOCK ();
        emission.chain_type = G_TYPE_NONE;
        return_value_altered = TRUE;
  
        if (emission.state == EMISSION_STOP)
<span class="line-modified">!   goto EMIT_CLEANUP;</span>
        else if (emission.state == EMISSION_RESTART)
<span class="line-modified">!   goto EMIT_RESTART;</span>
      }
  
    if (handler_list)
      {
        Handler *handler = handler_list;
  
        emission.state = EMISSION_RUN;
        handler_ref (handler);
        do
<span class="line-modified">!   {</span>
<span class="line-modified">!     Handler *tmp;</span>
  
<span class="line-modified">!     if (handler-&gt;after &amp;&amp; !handler-&gt;block_count &amp;&amp; (!handler-&gt;detail || handler-&gt;detail == detail) &amp;&amp;</span>
<span class="line-modified">!         handler-&gt;sequential_number &lt; max_sequential_handler_number)</span>
<span class="line-modified">!       {</span>
<span class="line-modified">!         SIGNAL_UNLOCK ();</span>
<span class="line-modified">!         g_closure_invoke (handler-&gt;closure,</span>
<span class="line-modified">!         return_accu,</span>
<span class="line-modified">!         node-&gt;n_params + 1,</span>
<span class="line-modified">!         instance_and_params,</span>
<span class="line-modified">!         &amp;emission.ihint);</span>
<span class="line-modified">!         if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;</span>
<span class="line-modified">!       emission.state == EMISSION_RUN)</span>
<span class="line-modified">!     emission.state = EMISSION_STOP;</span>
<span class="line-modified">!         SIGNAL_LOCK ();</span>
<span class="line-modified">!         return_value_altered = TRUE;</span>
  
<span class="line-modified">!         tmp = emission.state == EMISSION_RUN ? handler-&gt;next : NULL;</span>
<span class="line-modified">!       }</span>
<span class="line-modified">!     else</span>
<span class="line-modified">!       tmp = handler-&gt;next;</span>
  
<span class="line-modified">!     if (tmp)</span>
<span class="line-modified">!       handler_ref (tmp);</span>
<span class="line-modified">!     handler_unref_R (signal_id, instance, handler);</span>
<span class="line-modified">!     handler = tmp;</span>
<span class="line-modified">!   }</span>
        while (handler);
  
        if (emission.state == EMISSION_STOP)
<span class="line-modified">!   goto EMIT_CLEANUP;</span>
        else if (emission.state == EMISSION_RESTART)
<span class="line-modified">!   goto EMIT_RESTART;</span>
      }
  
   EMIT_CLEANUP:
  
    emission.ihint.run_type = G_SIGNAL_RUN_CLEANUP;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3765,26 ***</span>
        emission.state = EMISSION_STOP;
  
        emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
        SIGNAL_UNLOCK ();
        if (node-&gt;return_type != G_TYPE_NONE &amp;&amp; !accumulator)
<span class="line-modified">!     {</span>
<span class="line-modified">!       g_value_init (&amp;accu, node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE);</span>
<span class="line-modified">!       need_unset = TRUE;</span>
<span class="line-modified">!     }</span>
        g_closure_invoke (class_closure,
<span class="line-modified">!             node-&gt;return_type != G_TYPE_NONE ? &amp;accu : NULL,</span>
<span class="line-modified">!             node-&gt;n_params + 1,</span>
<span class="line-modified">!             instance_and_params,</span>
<span class="line-modified">!             &amp;emission.ihint);</span>
        if (need_unset)
<span class="line-modified">!     g_value_unset (&amp;accu);</span>
        SIGNAL_LOCK ();
        emission.chain_type = G_TYPE_NONE;
  
        if (emission.state == EMISSION_RESTART)
<span class="line-modified">!     goto EMIT_RESTART;</span>
      }
  
    if (handler_list)
      handler_unref_R (signal_id, instance, handler_list);
  
<span class="line-new-header">--- 3771,31 ---</span>
        emission.state = EMISSION_STOP;
  
        emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
        SIGNAL_UNLOCK ();
        if (node-&gt;return_type != G_TYPE_NONE &amp;&amp; !accumulator)
<span class="line-modified">!   {</span>
<span class="line-modified">!     g_value_init (&amp;accu, node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE);</span>
<span class="line-modified">!     need_unset = TRUE;</span>
<span class="line-modified">!   }</span>
        g_closure_invoke (class_closure,
<span class="line-modified">!       node-&gt;return_type != G_TYPE_NONE ? &amp;accu : NULL,</span>
<span class="line-modified">!       node-&gt;n_params + 1,</span>
<span class="line-modified">!       instance_and_params,</span>
<span class="line-modified">!       &amp;emission.ihint);</span>
<span class="line-added">+       if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;</span>
<span class="line-added">+           emission.state == EMISSION_RUN)</span>
<span class="line-added">+         emission.state = EMISSION_STOP;</span>
        if (need_unset)
<span class="line-modified">!   g_value_unset (&amp;accu);</span>
        SIGNAL_LOCK ();
<span class="line-added">+       return_value_altered = TRUE;</span>
<span class="line-added">+ </span>
        emission.chain_type = G_TYPE_NONE;
  
        if (emission.state == EMISSION_RESTART)
<span class="line-modified">!   goto EMIT_RESTART;</span>
      }
  
    if (handler_list)
      handler_unref_R (signal_id, instance, handler_list);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3798,30 ***</span>
    return return_value_altered;
  }
  
  static void
  add_invalid_closure_notify (Handler  *handler,
<span class="line-modified">!                 gpointer  instance)</span>
  {
    g_closure_add_invalidate_notifier (handler-&gt;closure, instance, invalid_closure_notify);
    handler-&gt;has_invalid_closure_notify = 1;
  }
  
  static void
  remove_invalid_closure_notify (Handler  *handler,
<span class="line-modified">!                    gpointer  instance)</span>
  {
    if (handler-&gt;has_invalid_closure_notify)
      {
        g_closure_remove_invalidate_notifier (handler-&gt;closure, instance, invalid_closure_notify);
        handler-&gt;has_invalid_closure_notify = 0;
      }
  }
  
  static void
  invalid_closure_notify (gpointer  instance,
<span class="line-modified">!                 GClosure *closure)</span>
  {
    Handler *handler;
    guint signal_id;
  
    SIGNAL_LOCK ();
<span class="line-new-header">--- 3809,30 ---</span>
    return return_value_altered;
  }
  
  static void
  add_invalid_closure_notify (Handler  *handler,
<span class="line-modified">!           gpointer  instance)</span>
  {
    g_closure_add_invalidate_notifier (handler-&gt;closure, instance, invalid_closure_notify);
    handler-&gt;has_invalid_closure_notify = 1;
  }
  
  static void
  remove_invalid_closure_notify (Handler  *handler,
<span class="line-modified">!              gpointer  instance)</span>
  {
    if (handler-&gt;has_invalid_closure_notify)
      {
        g_closure_remove_invalidate_notifier (handler-&gt;closure, instance, invalid_closure_notify);
        handler-&gt;has_invalid_closure_notify = 0;
      }
  }
  
  static void
  invalid_closure_notify (gpointer  instance,
<span class="line-modified">!             GClosure *closure)</span>
  {
    Handler *handler;
    guint signal_id;
  
    SIGNAL_LOCK ();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3873,13 ***</span>
   *
   * Returns: standard #GSignalAccumulator result
   */
  gboolean
  g_signal_accumulator_true_handled (GSignalInvocationHint *ihint,
<span class="line-modified">!                    GValue                *return_accu,</span>
<span class="line-modified">!                    const GValue          *handler_return,</span>
<span class="line-modified">!                    gpointer               dummy)</span>
  {
    gboolean continue_emission;
    gboolean signal_handled;
  
    signal_handled = g_value_get_boolean (handler_return);
<span class="line-new-header">--- 3884,13 ---</span>
   *
   * Returns: standard #GSignalAccumulator result
   */
  gboolean
  g_signal_accumulator_true_handled (GSignalInvocationHint *ihint,
<span class="line-modified">!            GValue                *return_accu,</span>
<span class="line-modified">!            const GValue          *handler_return,</span>
<span class="line-modified">!            gpointer               dummy)</span>
  {
    gboolean continue_emission;
    gboolean signal_handled;
  
    signal_handled = g_value_get_boolean (handler_return);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3918,5 ***</span>
<span class="line-new-header">--- 3929,35 ---</span>
                                   gpointer               dummy)
  {
    g_value_copy (handler_return, return_accu);
    return FALSE;
  }
<span class="line-added">+ </span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * g_clear_signal_handler:</span>
<span class="line-added">+  * @handler_id_ptr: A pointer to a handler ID (of type #gulong) of the handler to be disconnected.</span>
<span class="line-added">+  * @instance: (type GObject.Object): The instance to remove the signal handler from.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Disconnects a handler from @instance so it will not be called during</span>
<span class="line-added">+  * any future or currently ongoing emissions of the signal it has been</span>
<span class="line-added">+  * connected to. The @handler_id_ptr is then set to zero, which is never a valid handler ID value (see g_signal_connect()).</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * If the handler ID is 0 then this function does nothing.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * A macro is also included that allows this function to be used without</span>
<span class="line-added">+  * pointer casts.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 2.62</span>
<span class="line-added">+  */</span>
<span class="line-added">+ #undef g_clear_signal_handler</span>
<span class="line-added">+ void</span>
<span class="line-added">+ g_clear_signal_handler (gulong   *handler_id_ptr,</span>
<span class="line-added">+                         gpointer  instance)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   g_return_if_fail (handler_id_ptr != NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (*handler_id_ptr != 0)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       g_signal_handler_disconnect (instance, *handler_id_ptr);</span>
<span class="line-added">+       *handler_id_ptr = 0;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
</pre>
<center><a href="gparamspecs.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gsignal.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>