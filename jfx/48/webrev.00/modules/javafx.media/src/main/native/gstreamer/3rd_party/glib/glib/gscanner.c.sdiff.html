<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gscanner.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gregex.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gscanner.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gscanner.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 258  * @numbers_2_int: specifies if binary, octal and hexadecimal numbers
 259  *     are reported as #G_TOKEN_INT (the default is %TRUE).
 260  * @int_2_float: specifies if all numbers are reported as %G_TOKEN_FLOAT
 261  *     (the default is %FALSE).
 262  * @identifier_2_string: specifies if identifiers are reported as strings
 263  *     (the default is %FALSE).
 264  * @char_2_token: specifies if characters are reported by setting
 265  *     `token = ch` or as %G_TOKEN_CHAR (the default is %TRUE).
 266  * @symbol_2_token: specifies if symbols are reported by setting
 267  *     `token = v_symbol` or as %G_TOKEN_SYMBOL (the default is %FALSE).
 268  * @scope_0_fallback: specifies if a symbol is searched for in the
 269  *     default scope in addition to the current scope (the default is %FALSE).
 270  * @store_int64: use value.v_int64 rather than v_int
 271  *
 272  * Specifies the #GScanner parser configuration. Most settings can
 273  * be changed during the parsing phase and will affect the lexical
 274  * parsing of the next unpeeked token.
 275  */
 276 
 277 /* --- defines --- */
<span class="line-modified"> 278 #define to_lower(c)             ( \</span>
<span class="line-modified"> 279     (guchar) (                          \</span>
<span class="line-modified"> 280       ( (((guchar)(c))&gt;=&#39;A&#39; &amp;&amp; ((guchar)(c))&lt;=&#39;Z&#39;) * (&#39;a&#39;-&#39;A&#39;) ) |  \</span>
<span class="line-modified"> 281       ( (((guchar)(c))&gt;=192 &amp;&amp; ((guchar)(c))&lt;=214) * (224-192) ) |  \</span>
<span class="line-modified"> 282       ( (((guchar)(c))&gt;=216 &amp;&amp; ((guchar)(c))&lt;=222) * (248-216) ) |  \</span>
<span class="line-modified"> 283       ((guchar)(c))                         \</span>
<span class="line-modified"> 284     )                               \</span>
 285 )
<span class="line-modified"> 286 #define READ_BUFFER_SIZE    (4000)</span>
 287 
 288 
 289 /* --- typedefs --- */
<span class="line-modified"> 290 typedef struct  _GScannerKey    GScannerKey;</span>
 291 
 292 struct  _GScannerKey
 293 {
<span class="line-modified"> 294   guint      scope_id;</span>
<span class="line-modified"> 295   gchar     *symbol;</span>
 296   gpointer   value;
 297 };
 298 
 299 
 300 /* --- variables --- */
 301 static const GScannerConfig g_scanner_config_template =
 302 {
 303   (
 304    &quot; \t\r\n&quot;
<span class="line-modified"> 305    )            /* cset_skip_characters */,</span>
 306   (
 307    G_CSET_a_2_z
 308    &quot;_&quot;
 309    G_CSET_A_2_Z
<span class="line-modified"> 310    )            /* cset_identifier_first */,</span>
 311   (
 312    G_CSET_a_2_z
 313    &quot;_&quot;
 314    G_CSET_A_2_Z
 315    G_CSET_DIGITS
 316    G_CSET_LATINS
 317    G_CSET_LATINC
<span class="line-modified"> 318    )            /* cset_identifier_nth */,</span>
<span class="line-modified"> 319   ( &quot;#\n&quot; )     /* cpair_comment_single */,</span>
<span class="line-modified"> 320 </span>
<span class="line-modified"> 321   FALSE         /* case_sensitive */,</span>
<span class="line-modified"> 322 </span>
<span class="line-modified"> 323   TRUE          /* skip_comment_multi */,</span>
<span class="line-modified"> 324   TRUE          /* skip_comment_single */,</span>
<span class="line-modified"> 325   TRUE          /* scan_comment_multi */,</span>
<span class="line-modified"> 326   TRUE          /* scan_identifier */,</span>
<span class="line-modified"> 327   FALSE         /* scan_identifier_1char */,</span>
<span class="line-modified"> 328   FALSE         /* scan_identifier_NULL */,</span>
<span class="line-modified"> 329   TRUE          /* scan_symbols */,</span>
<span class="line-modified"> 330   FALSE         /* scan_binary */,</span>
<span class="line-modified"> 331   TRUE          /* scan_octal */,</span>
<span class="line-modified"> 332   TRUE          /* scan_float */,</span>
<span class="line-modified"> 333   TRUE          /* scan_hex */,</span>
<span class="line-modified"> 334   FALSE         /* scan_hex_dollar */,</span>
<span class="line-modified"> 335   TRUE          /* scan_string_sq */,</span>
<span class="line-modified"> 336   TRUE          /* scan_string_dq */,</span>
<span class="line-modified"> 337   TRUE          /* numbers_2_int */,</span>
<span class="line-modified"> 338   FALSE         /* int_2_float */,</span>
<span class="line-modified"> 339   FALSE         /* identifier_2_string */,</span>
<span class="line-modified"> 340   TRUE          /* char_2_token */,</span>
<span class="line-modified"> 341   FALSE         /* symbol_2_token */,</span>
<span class="line-modified"> 342   FALSE         /* scope_0_fallback */,</span>
<span class="line-modified"> 343   FALSE         /* store_int64 */,</span>

 344 };
 345 
 346 
 347 /* --- prototypes --- */
 348 static inline
<span class="line-modified"> 349 GScannerKey*    g_scanner_lookup_internal (GScanner *scanner,</span>
<span class="line-modified"> 350                        guint     scope_id,</span>
<span class="line-modified"> 351                        const gchar  *symbol);</span>
 352 static gboolean g_scanner_key_equal   (gconstpointer v1,
<span class="line-modified"> 353                        gconstpointer v2);</span>
<span class="line-modified"> 354 static guint    g_scanner_key_hash    (gconstpointer v);</span>
 355 static void g_scanner_get_token_ll    (GScanner *scanner,
<span class="line-modified"> 356                        GTokenType   *token_p,</span>
<span class="line-modified"> 357                        GTokenValue  *value_p,</span>
<span class="line-modified"> 358                        guint    *line_p,</span>
<span class="line-modified"> 359                        guint    *position_p);</span>
<span class="line-modified"> 360 static void g_scanner_get_token_i     (GScanner *scanner,</span>
<span class="line-modified"> 361                        GTokenType   *token_p,</span>
<span class="line-modified"> 362                        GTokenValue  *value_p,</span>
<span class="line-modified"> 363                        guint    *line_p,</span>
<span class="line-modified"> 364                        guint    *position_p);</span>
<span class="line-modified"> 365 </span>
<span class="line-modified"> 366 static guchar   g_scanner_peek_next_char  (GScanner *scanner);</span>
<span class="line-modified"> 367 static guchar   g_scanner_get_char    (GScanner *scanner,</span>
<span class="line-modified"> 368                        guint    *line_p,</span>
<span class="line-modified"> 369                        guint    *position_p);</span>
<span class="line-modified"> 370 static void g_scanner_msg_handler     (GScanner *scanner,</span>
<span class="line-modified"> 371                        gchar    *message,</span>
<span class="line-modified"> 372                        gboolean  is_error);</span>
 373 
 374 
 375 /* --- functions --- */
 376 static inline gint
<span class="line-modified"> 377 g_scanner_char_2_num (guchar    c,</span>
<span class="line-modified"> 378               guchar    base)</span>
 379 {
 380   if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;)
 381     c -= &#39;0&#39;;
 382   else if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;)
 383     c -= &#39;A&#39; - 10;
 384   else if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;)
 385     c -= &#39;a&#39; - 10;
 386   else
 387     return -1;
 388 
 389   if (c &lt; base)
 390     return c;
 391 
 392   return -1;
 393 }
 394 
 395 /**
 396  * g_scanner_new:
 397  * @config_templ: the initial scanner settings
 398  *
</pre>
<hr />
<pre>
 406  * Returns: the new #GScanner
 407  */
 408 GScanner *
 409 g_scanner_new (const GScannerConfig *config_templ)
 410 {
 411   GScanner *scanner;
 412 
 413   if (!config_templ)
 414     config_templ = &amp;g_scanner_config_template;
 415 
 416   scanner = g_new0 (GScanner, 1);
 417 
 418   scanner-&gt;user_data = NULL;
 419   scanner-&gt;max_parse_errors = 1;
 420   scanner-&gt;parse_errors = 0;
 421   scanner-&gt;input_name = NULL;
 422   g_datalist_init (&amp;scanner-&gt;qdata);
 423 
 424   scanner-&gt;config = g_new0 (GScannerConfig, 1);
 425 
<span class="line-modified"> 426   scanner-&gt;config-&gt;case_sensitive    = config_templ-&gt;case_sensitive;</span>
 427   scanner-&gt;config-&gt;cset_skip_characters  = config_templ-&gt;cset_skip_characters;
 428   if (!scanner-&gt;config-&gt;cset_skip_characters)
 429     scanner-&gt;config-&gt;cset_skip_characters = &quot;&quot;;
 430   scanner-&gt;config-&gt;cset_identifier_first = config_templ-&gt;cset_identifier_first;
 431   scanner-&gt;config-&gt;cset_identifier_nth   = config_templ-&gt;cset_identifier_nth;
 432   scanner-&gt;config-&gt;cpair_comment_single  = config_templ-&gt;cpair_comment_single;
<span class="line-modified"> 433   scanner-&gt;config-&gt;skip_comment_multi    = config_templ-&gt;skip_comment_multi;</span>
 434   scanner-&gt;config-&gt;skip_comment_single   = config_templ-&gt;skip_comment_single;
<span class="line-modified"> 435   scanner-&gt;config-&gt;scan_comment_multi    = config_templ-&gt;scan_comment_multi;</span>
 436   scanner-&gt;config-&gt;scan_identifier   = config_templ-&gt;scan_identifier;
 437   scanner-&gt;config-&gt;scan_identifier_1char = config_templ-&gt;scan_identifier_1char;
 438   scanner-&gt;config-&gt;scan_identifier_NULL  = config_templ-&gt;scan_identifier_NULL;
<span class="line-modified"> 439   scanner-&gt;config-&gt;scan_symbols      = config_templ-&gt;scan_symbols;</span>
<span class="line-modified"> 440   scanner-&gt;config-&gt;scan_binary       = config_templ-&gt;scan_binary;</span>
<span class="line-modified"> 441   scanner-&gt;config-&gt;scan_octal        = config_templ-&gt;scan_octal;</span>
<span class="line-modified"> 442   scanner-&gt;config-&gt;scan_float        = config_templ-&gt;scan_float;</span>
<span class="line-modified"> 443   scanner-&gt;config-&gt;scan_hex      = config_templ-&gt;scan_hex;</span>
 444   scanner-&gt;config-&gt;scan_hex_dollar   = config_templ-&gt;scan_hex_dollar;
<span class="line-modified"> 445   scanner-&gt;config-&gt;scan_string_sq    = config_templ-&gt;scan_string_sq;</span>
<span class="line-modified"> 446   scanner-&gt;config-&gt;scan_string_dq    = config_templ-&gt;scan_string_dq;</span>
<span class="line-modified"> 447   scanner-&gt;config-&gt;numbers_2_int     = config_templ-&gt;numbers_2_int;</span>
<span class="line-modified"> 448   scanner-&gt;config-&gt;int_2_float       = config_templ-&gt;int_2_float;</span>
 449   scanner-&gt;config-&gt;identifier_2_string   = config_templ-&gt;identifier_2_string;
<span class="line-modified"> 450   scanner-&gt;config-&gt;char_2_token      = config_templ-&gt;char_2_token;</span>
<span class="line-modified"> 451   scanner-&gt;config-&gt;symbol_2_token    = config_templ-&gt;symbol_2_token;</span>
 452   scanner-&gt;config-&gt;scope_0_fallback  = config_templ-&gt;scope_0_fallback;
<span class="line-modified"> 453   scanner-&gt;config-&gt;store_int64       = config_templ-&gt;store_int64;</span>
 454 
 455   scanner-&gt;token = G_TOKEN_NONE;
 456   scanner-&gt;value.v_int64 = 0;
 457   scanner-&gt;line = 1;
 458   scanner-&gt;position = 0;
 459 
 460   scanner-&gt;next_token = G_TOKEN_NONE;
 461   scanner-&gt;next_value.v_int64 = 0;
 462   scanner-&gt;next_line = 1;
 463   scanner-&gt;next_position = 0;
 464 
 465   scanner-&gt;symbol_table = g_hash_table_new (g_scanner_key_hash, g_scanner_key_equal);
 466   scanner-&gt;input_fd = -1;
 467   scanner-&gt;text = NULL;
 468   scanner-&gt;text_end = NULL;
 469   scanner-&gt;buffer = NULL;
 470   scanner-&gt;scope_id = 0;
 471 
 472   scanner-&gt;msg_handler = g_scanner_msg_handler;
 473 
 474   return scanner;
 475 }
 476 
 477 static inline void
 478 g_scanner_free_value (GTokenType     *token_p,
<span class="line-modified"> 479               GTokenValue     *value_p)</span>
 480 {
 481   switch (*token_p)
 482     {
 483     case G_TOKEN_STRING:
 484     case G_TOKEN_IDENTIFIER:
 485     case G_TOKEN_IDENTIFIER_NULL:
 486     case G_TOKEN_COMMENT_SINGLE:
 487     case G_TOKEN_COMMENT_MULTI:
 488       g_free (value_p-&gt;v_string);
 489       break;
 490 
 491     default:
 492       break;
 493     }
 494 
 495   *token_p = G_TOKEN_NONE;
 496 }
 497 
 498 static void
 499 g_scanner_destroy_symbol_table_entry (gpointer _key,
<span class="line-modified"> 500                       gpointer _value,</span>
<span class="line-modified"> 501                       gpointer _data)</span>
 502 {
 503   GScannerKey *key = _key;
 504 
 505   g_free (key-&gt;symbol);
 506   g_free (key);
 507 }
 508 
 509 /**
 510  * g_scanner_destroy:
 511  * @scanner: a #GScanner
 512  *
 513  * Frees all memory used by the #GScanner.
 514  */
 515 void
 516 g_scanner_destroy (GScanner *scanner)
 517 {
 518   g_return_if_fail (scanner != NULL);
 519 
 520   g_datalist_clear (&amp;scanner-&gt;qdata);
 521   g_hash_table_foreach (scanner-&gt;symbol_table,
<span class="line-modified"> 522             g_scanner_destroy_symbol_table_entry, NULL);</span>
 523   g_hash_table_destroy (scanner-&gt;symbol_table);
 524   g_scanner_free_value (&amp;scanner-&gt;token, &amp;scanner-&gt;value);
 525   g_scanner_free_value (&amp;scanner-&gt;next_token, &amp;scanner-&gt;next_value);
 526   g_free (scanner-&gt;config);
 527   g_free (scanner-&gt;buffer);
 528   g_free (scanner);
 529 }
 530 
 531 static void
<span class="line-modified"> 532 g_scanner_msg_handler (GScanner     *scanner,</span>
<span class="line-modified"> 533                gchar        *message,</span>
<span class="line-modified"> 534                gboolean     is_error)</span>
 535 {
 536   g_return_if_fail (scanner != NULL);
 537 
 538   _g_fprintf (stderr, &quot;%s:%d: &quot;,
<span class="line-modified"> 539           scanner-&gt;input_name ? scanner-&gt;input_name : &quot;&lt;memory&gt;&quot;,</span>
<span class="line-modified"> 540           scanner-&gt;line);</span>
 541   if (is_error)
 542     _g_fprintf (stderr, &quot;error: &quot;);
 543   _g_fprintf (stderr, &quot;%s\n&quot;, message);
 544 }
 545 
 546 /**
 547  * g_scanner_error:
 548  * @scanner: a #GScanner
 549  * @format: the message format. See the printf() documentation
 550  * @...: the parameters to insert into the format string
 551  *
 552  * Outputs an error message, via the #GScanner message handler.
 553  */
 554 void
<span class="line-modified"> 555 g_scanner_error (GScanner   *scanner,</span>
<span class="line-modified"> 556          const gchar    *format,</span>
<span class="line-modified"> 557                  ...)</span>
 558 {
 559   g_return_if_fail (scanner != NULL);
 560   g_return_if_fail (format != NULL);
 561 
 562   scanner-&gt;parse_errors++;
 563 
 564   if (scanner-&gt;msg_handler)
 565     {
 566       va_list args;
 567       gchar *string;
 568 
 569       va_start (args, format);
 570       string = g_strdup_vprintf (format, args);
 571       va_end (args);
 572 
 573       scanner-&gt;msg_handler (scanner, string, TRUE);
 574 
 575       g_free (string);
 576     }
 577 }
 578 
 579 /**
 580  * g_scanner_warn:
 581  * @scanner: a #GScanner
 582  * @format: the message format. See the printf() documentation
 583  * @...: the parameters to insert into the format string
 584  *
 585  * Outputs a warning message, via the #GScanner message handler.
 586  */
 587 void
 588 g_scanner_warn (GScanner       *scanner,
<span class="line-modified"> 589         const gchar    *format,</span>
<span class="line-modified"> 590         ...)</span>
 591 {
 592   g_return_if_fail (scanner != NULL);
 593   g_return_if_fail (format != NULL);
 594 
 595   if (scanner-&gt;msg_handler)
 596     {
 597       va_list args;
 598       gchar *string;
 599 
 600       va_start (args, format);
 601       string = g_strdup_vprintf (format, args);
 602       va_end (args);
 603 
 604       scanner-&gt;msg_handler (scanner, string, FALSE);
 605 
 606       g_free (string);
 607     }
 608 }
 609 
 610 static gboolean
 611 g_scanner_key_equal (gconstpointer v1,
<span class="line-modified"> 612              gconstpointer v2)</span>
 613 {
 614   const GScannerKey *key1 = v1;
 615   const GScannerKey *key2 = v2;
 616 
 617   return (key1-&gt;scope_id == key2-&gt;scope_id) &amp;&amp; (strcmp (key1-&gt;symbol, key2-&gt;symbol) == 0);
 618 }
 619 
 620 static guint
 621 g_scanner_key_hash (gconstpointer v)
 622 {
 623   const GScannerKey *key = v;
 624   gchar *c;
 625   guint h;
 626 
 627   h = key-&gt;scope_id;
 628   for (c = key-&gt;symbol; *c; c++)
 629     h = (h &lt;&lt; 5) - h + *c;
 630 
 631   return h;
 632 }
 633 
 634 static inline GScannerKey*
 635 g_scanner_lookup_internal (GScanner *scanner,
<span class="line-modified"> 636                guint     scope_id,</span>
<span class="line-modified"> 637                const gchar  *symbol)</span>
 638 {
<span class="line-modified"> 639   GScannerKey   *key_p;</span>
 640   GScannerKey key;
 641 
 642   key.scope_id = scope_id;
 643 
 644   if (!scanner-&gt;config-&gt;case_sensitive)
 645     {
 646       gchar *d;
 647       const gchar *c;
 648 
 649       key.symbol = g_new (gchar, strlen (symbol) + 1);
 650       for (d = key.symbol, c = symbol; *c; c++, d++)
<span class="line-modified"> 651     *d = to_lower (*c);</span>
 652       *d = 0;
 653       key_p = g_hash_table_lookup (scanner-&gt;symbol_table, &amp;key);
 654       g_free (key.symbol);
 655     }
 656   else
 657     {
 658       key.symbol = (gchar*) symbol;
 659       key_p = g_hash_table_lookup (scanner-&gt;symbol_table, &amp;key);
 660     }
 661 
 662   return key_p;
 663 }
 664 
 665 /**
 666  * g_scanner_add_symbol:
 667  * @scanner: a #GScanner
 668  * @symbol: the symbol to add
 669  * @value: the value of the symbol
 670  *
 671  * Adds a symbol to the default scope.
 672  *
 673  * Deprecated: 2.2: Use g_scanner_scope_add_symbol() instead.
 674  */
 675 
 676 /**
 677  * g_scanner_scope_add_symbol:
 678  * @scanner: a #GScanner
 679  * @scope_id: the scope id
 680  * @symbol: the symbol to add
 681  * @value: the value of the symbol
 682  *
 683  * Adds a symbol to the given scope.
 684  */
 685 void
<span class="line-modified"> 686 g_scanner_scope_add_symbol (GScanner    *scanner,</span>
<span class="line-modified"> 687                 guint    scope_id,</span>
<span class="line-modified"> 688                 const gchar *symbol,</span>
<span class="line-modified"> 689                 gpointer     value)</span>
 690 {
<span class="line-modified"> 691   GScannerKey   *key;</span>
 692 
 693   g_return_if_fail (scanner != NULL);
 694   g_return_if_fail (symbol != NULL);
 695 
 696   key = g_scanner_lookup_internal (scanner, scope_id, symbol);
 697 
 698   if (!key)
 699     {
 700       key = g_new (GScannerKey, 1);
 701       key-&gt;scope_id = scope_id;
 702       key-&gt;symbol = g_strdup (symbol);
 703       key-&gt;value = value;
 704       if (!scanner-&gt;config-&gt;case_sensitive)
<span class="line-modified"> 705     {</span>
<span class="line-modified"> 706       gchar *c;</span>
<span class="line-modified"> 707 </span>
<span class="line-modified"> 708       c = key-&gt;symbol;</span>
<span class="line-modified"> 709       while (*c != 0)</span>
<span class="line-modified"> 710         {</span>
<span class="line-modified"> 711           *c = to_lower (*c);</span>
<span class="line-modified"> 712           c++;</span>
<span class="line-modified"> 713         }</span>
<span class="line-modified"> 714     }</span>
 715       g_hash_table_add (scanner-&gt;symbol_table, key);
 716     }
 717   else
 718     key-&gt;value = value;
 719 }
 720 
 721 /**
 722  * g_scanner_remove_symbol:
 723  * @scanner: a #GScanner
 724  * @symbol: the symbol to remove
 725  *
 726  * Removes a symbol from the default scope.
 727  *
 728  * Deprecated: 2.2: Use g_scanner_scope_remove_symbol() instead.
 729  */
 730 
 731 /**
 732  * g_scanner_scope_remove_symbol:
 733  * @scanner: a #GScanner
 734  * @scope_id: the scope id
 735  * @symbol: the symbol to remove
 736  *
 737  * Removes a symbol from a scope.
 738  */
 739 void
 740 g_scanner_scope_remove_symbol (GScanner    *scanner,
<span class="line-modified"> 741                    guint        scope_id,</span>
<span class="line-modified"> 742                                const gchar *symbol)</span>
 743 {
<span class="line-modified"> 744   GScannerKey   *key;</span>
 745 
 746   g_return_if_fail (scanner != NULL);
 747   g_return_if_fail (symbol != NULL);
 748 
 749   key = g_scanner_lookup_internal (scanner, scope_id, symbol);
 750 
 751   if (key)
 752     {
 753       g_hash_table_remove (scanner-&gt;symbol_table, key);
 754       g_free (key-&gt;symbol);
 755       g_free (key);
 756     }
 757 }
 758 
 759 /**
 760  * g_scanner_freeze_symbol_table:
 761  * @scanner: a #GScanner
 762  *
 763  * There is no reason to use this macro, since it does nothing.
 764  *
</pre>
<hr />
<pre>
 770  * @scanner: a #GScanner
 771  *
 772  * There is no reason to use this macro, since it does nothing.
 773  *
 774  * Deprecated: 2.2: This macro does nothing.
 775  */
 776 
 777 /**
 778  * g_scanner_lookup_symbol:
 779  * @scanner: a #GScanner
 780  * @symbol: the symbol to look up
 781  *
 782  * Looks up a symbol in the current scope and return its value.
 783  * If the symbol is not bound in the current scope, %NULL is
 784  * returned.
 785  *
 786  * Returns: the value of @symbol in the current scope, or %NULL
 787  *     if @symbol is not bound in the current scope
 788  */
 789 gpointer
<span class="line-modified"> 790 g_scanner_lookup_symbol (GScanner   *scanner,</span>
<span class="line-modified"> 791              const gchar    *symbol)</span>
 792 {
<span class="line-modified"> 793   GScannerKey   *key;</span>
 794   guint scope_id;
 795 
 796   g_return_val_if_fail (scanner != NULL, NULL);
 797 
 798   if (!symbol)
 799     return NULL;
 800 
 801   scope_id = scanner-&gt;scope_id;
 802   key = g_scanner_lookup_internal (scanner, scope_id, symbol);
 803   if (!key &amp;&amp; scope_id &amp;&amp; scanner-&gt;config-&gt;scope_0_fallback)
 804     key = g_scanner_lookup_internal (scanner, 0, symbol);
 805 
 806   if (key)
 807     return key-&gt;value;
 808   else
 809     return NULL;
 810 }
 811 
 812 /**
 813  * g_scanner_scope_lookup_symbol:
 814  * @scanner: a #GScanner
 815  * @scope_id: the scope id
 816  * @symbol: the symbol to look up
 817  *
 818  * Looks up a symbol in a scope and return its value. If the
 819  * symbol is not bound in the scope, %NULL is returned.
 820  *
 821  * Returns: the value of @symbol in the given scope, or %NULL
 822  *     if @symbol is not bound in the given scope.
 823  *
 824  */
 825 gpointer
 826 g_scanner_scope_lookup_symbol (GScanner       *scanner,
<span class="line-modified"> 827                    guint           scope_id,</span>
<span class="line-modified"> 828                                const gchar    *symbol)</span>
 829 {
<span class="line-modified"> 830   GScannerKey   *key;</span>
 831 
 832   g_return_val_if_fail (scanner != NULL, NULL);
 833 
 834   if (!symbol)
 835     return NULL;
 836 
 837   key = g_scanner_lookup_internal (scanner, scope_id, symbol);
 838 
 839   if (key)
 840     return key-&gt;value;
 841   else
 842     return NULL;
 843 }
 844 
 845 /**
 846  * g_scanner_set_scope:
 847  * @scanner: a #GScanner
 848  * @scope_id: the new scope id
 849  *
 850  * Sets the current scope.
 851  *
 852  * Returns: the old scope id
 853  */
 854 guint
<span class="line-modified"> 855 g_scanner_set_scope (GScanner       *scanner,</span>
<span class="line-modified"> 856              guint       scope_id)</span>
 857 {
 858   guint old_scope_id;
 859 
 860   g_return_val_if_fail (scanner != NULL, 0);
 861 
 862   old_scope_id = scanner-&gt;scope_id;
 863   scanner-&gt;scope_id = scope_id;
 864 
 865   return old_scope_id;
 866 }
 867 
 868 static void
 869 g_scanner_foreach_internal (gpointer  _key,
<span class="line-modified"> 870                 gpointer  _value,</span>
<span class="line-modified"> 871                 gpointer  _user_data)</span>
 872 {
 873   GScannerKey *key;
 874   gpointer *d;
 875   GHFunc func;
 876   gpointer user_data;
 877   guint *scope_id;
 878 
 879   d = _user_data;
 880   func = (GHFunc) d[0];
 881   user_data = d[1];
 882   scope_id = d[2];
 883   key = _value;
 884 
 885   if (key-&gt;scope_id == *scope_id)
 886     func (key-&gt;symbol, key-&gt;value, user_data);
 887 }
 888 
 889 /**
 890  * g_scanner_foreach_symbol:
 891  * @scanner: a #GScanner
</pre>
<hr />
<pre>
 894  *
 895  * Calls a function for each symbol in the default scope.
 896  *
 897  * Deprecated: 2.2: Use g_scanner_scope_foreach_symbol() instead.
 898  */
 899 
 900 /**
 901  * g_scanner_scope_foreach_symbol:
 902  * @scanner: a #GScanner
 903  * @scope_id: the scope id
 904  * @func: the function to call for each symbol/value pair
 905  * @user_data: user data to pass to the function
 906  *
 907  * Calls the given function for each of the symbol/value pairs
 908  * in the given scope of the #GScanner. The function is passed
 909  * the symbol and value of each pair, and the given @user_data
 910  * parameter.
 911  */
 912 void
 913 g_scanner_scope_foreach_symbol (GScanner       *scanner,
<span class="line-modified"> 914                 guint       scope_id,</span>
<span class="line-modified"> 915                 GHFunc      func,</span>
<span class="line-modified"> 916                 gpointer    user_data)</span>
 917 {
 918   gpointer d[3];
 919 
 920   g_return_if_fail (scanner != NULL);
 921 
 922   d[0] = (gpointer) func;
 923   d[1] = user_data;
 924   d[2] = &amp;scope_id;
 925 
 926   g_hash_table_foreach (scanner-&gt;symbol_table, g_scanner_foreach_internal, d);
 927 }
 928 
 929 /**
 930  * g_scanner_peek_next_token:
 931  * @scanner: a #GScanner
 932  *
 933  * Parses the next token, without removing it from the input stream.
 934  * The token data is placed in the @next_token, @next_value, @next_line,
 935  * and @next_position fields of the #GScanner structure.
 936  *
 937  * Note that, while the token is not removed from the input stream
 938  * (i.e. the next call to g_scanner_get_next_token() will return the
 939  * same token), it will not be reevaluated. This can lead to surprising
 940  * results when changing scope or the scanner configuration after peeking
 941  * the next token. Getting the next token after switching the scope or
 942  * configuration will return whatever was peeked before, regardless of
 943  * any symbols that may have been added or removed in the new scope.
 944  *
 945  * Returns: the type of the token
 946  */
 947 GTokenType
 948 g_scanner_peek_next_token (GScanner *scanner)
 949 {
 950   g_return_val_if_fail (scanner != NULL, G_TOKEN_EOF);
 951 
 952   if (scanner-&gt;next_token == G_TOKEN_NONE)
 953     {
 954       scanner-&gt;next_line = scanner-&gt;line;
 955       scanner-&gt;next_position = scanner-&gt;position;
 956       g_scanner_get_token_i (scanner,
<span class="line-modified"> 957                  &amp;scanner-&gt;next_token,</span>
<span class="line-modified"> 958                  &amp;scanner-&gt;next_value,</span>
<span class="line-modified"> 959                  &amp;scanner-&gt;next_line,</span>
<span class="line-modified"> 960                  &amp;scanner-&gt;next_position);</span>
 961     }
 962 
 963   return scanner-&gt;next_token;
 964 }
 965 
 966 /**
 967  * g_scanner_get_next_token:
 968  * @scanner: a #GScanner
 969  *
 970  * Parses the next token just like g_scanner_peek_next_token()
 971  * and also removes it from the input stream. The token data is
 972  * placed in the @token, @value, @line, and @position fields of
 973  * the #GScanner structure.
 974  *
 975  * Returns: the type of the token
 976  */
 977 GTokenType
 978 g_scanner_get_next_token (GScanner  *scanner)
 979 {
 980   g_return_val_if_fail (scanner != NULL, G_TOKEN_EOF);
 981 
 982   if (scanner-&gt;next_token != G_TOKEN_NONE)
 983     {
 984       g_scanner_free_value (&amp;scanner-&gt;token, &amp;scanner-&gt;value);
 985 
 986       scanner-&gt;token = scanner-&gt;next_token;
 987       scanner-&gt;value = scanner-&gt;next_value;
 988       scanner-&gt;line = scanner-&gt;next_line;
 989       scanner-&gt;position = scanner-&gt;next_position;
 990       scanner-&gt;next_token = G_TOKEN_NONE;
 991     }
 992   else
 993     g_scanner_get_token_i (scanner,
<span class="line-modified"> 994                &amp;scanner-&gt;token,</span>
<span class="line-modified"> 995                &amp;scanner-&gt;value,</span>
<span class="line-modified"> 996                &amp;scanner-&gt;line,</span>
<span class="line-modified"> 997                &amp;scanner-&gt;position);</span>
 998 
 999   return scanner-&gt;token;
1000 }
1001 
1002 /**
1003  * g_scanner_cur_token:
1004  * @scanner: a #GScanner
1005  *
1006  * Gets the current token type. This is simply the @token
1007  * field in the #GScanner structure.
1008  *
1009  * Returns: the current token type
1010  */
1011 GTokenType
1012 g_scanner_cur_token (GScanner *scanner)
1013 {
1014   g_return_val_if_fail (scanner != NULL, G_TOKEN_EOF);
1015 
1016   return scanner-&gt;token;
1017 }
</pre>
<hr />
<pre>
1087  * Returns: %TRUE if the scanner has reached the end of
1088  *     the file or text buffer
1089  */
1090 gboolean
1091 g_scanner_eof (GScanner *scanner)
1092 {
1093   g_return_val_if_fail (scanner != NULL, TRUE);
1094 
1095   return scanner-&gt;token == G_TOKEN_EOF || scanner-&gt;token == G_TOKEN_ERROR;
1096 }
1097 
1098 /**
1099  * g_scanner_input_file:
1100  * @scanner: a #GScanner
1101  * @input_fd: a file descriptor
1102  *
1103  * Prepares to scan a file.
1104  */
1105 void
1106 g_scanner_input_file (GScanner *scanner,
<span class="line-modified">1107               gint  input_fd)</span>
1108 {
1109   g_return_if_fail (scanner != NULL);
1110   g_return_if_fail (input_fd &gt;= 0);
1111 
1112   if (scanner-&gt;input_fd &gt;= 0)
1113     g_scanner_sync_file_offset (scanner);
1114 
1115   scanner-&gt;token = G_TOKEN_NONE;
1116   scanner-&gt;value.v_int64 = 0;
1117   scanner-&gt;line = 1;
1118   scanner-&gt;position = 0;
1119   scanner-&gt;next_token = G_TOKEN_NONE;
1120 
1121   scanner-&gt;input_fd = input_fd;
1122   scanner-&gt;text = NULL;
1123   scanner-&gt;text_end = NULL;
1124 
1125   if (!scanner-&gt;buffer)
1126     scanner-&gt;buffer = g_new (gchar, READ_BUFFER_SIZE + 1);
1127 }
1128 
1129 /**
1130  * g_scanner_input_text:
1131  * @scanner: a #GScanner
1132  * @text: the text buffer to scan
1133  * @text_len: the length of the text buffer
1134  *
1135  * Prepares to scan a text buffer.
1136  */
1137 void
1138 g_scanner_input_text (GScanner    *scanner,
<span class="line-modified">1139                       const gchar *text,</span>
<span class="line-modified">1140               guint    text_len)</span>
1141 {
1142   g_return_if_fail (scanner != NULL);
1143   if (text_len)
1144     g_return_if_fail (text != NULL);
1145   else
1146     text = NULL;
1147 
1148   if (scanner-&gt;input_fd &gt;= 0)
1149     g_scanner_sync_file_offset (scanner);
1150 
1151   scanner-&gt;token = G_TOKEN_NONE;
1152   scanner-&gt;value.v_int64 = 0;
1153   scanner-&gt;line = 1;
1154   scanner-&gt;position = 0;
1155   scanner-&gt;next_token = G_TOKEN_NONE;
1156 
1157   scanner-&gt;input_fd = -1;
1158   scanner-&gt;text = text;
1159   scanner-&gt;text_end = text + text_len;
1160 
</pre>
<hr />
<pre>
1162     {
1163       g_free (scanner-&gt;buffer);
1164       scanner-&gt;buffer = NULL;
1165     }
1166 }
1167 
1168 static guchar
1169 g_scanner_peek_next_char (GScanner *scanner)
1170 {
1171   if (scanner-&gt;text &lt; scanner-&gt;text_end)
1172     {
1173       return *scanner-&gt;text;
1174     }
1175   else if (scanner-&gt;input_fd &gt;= 0)
1176     {
1177       gint count;
1178       gchar *buffer;
1179 
1180       buffer = scanner-&gt;buffer;
1181       do
<span class="line-modified">1182     {</span>
<span class="line-modified">1183       count = read (scanner-&gt;input_fd, buffer, READ_BUFFER_SIZE);</span>
<span class="line-modified">1184     }</span>
1185       while (count == -1 &amp;&amp; (errno == EINTR || errno == EAGAIN));
1186 
1187       if (count &lt; 1)
<span class="line-modified">1188     {</span>
<span class="line-modified">1189       scanner-&gt;input_fd = -1;</span>
1190 
<span class="line-modified">1191       return 0;</span>
<span class="line-modified">1192     }</span>
1193       else
<span class="line-modified">1194     {</span>
<span class="line-modified">1195       scanner-&gt;text = buffer;</span>
<span class="line-modified">1196       scanner-&gt;text_end = buffer + count;</span>
1197 
<span class="line-modified">1198       return *buffer;</span>
<span class="line-modified">1199     }</span>
1200     }
1201   else
1202     return 0;
1203 }
1204 
1205 /**
1206  * g_scanner_sync_file_offset:
1207  * @scanner: a #GScanner
1208  *
1209  * Rewinds the filedescriptor to the current buffer position
1210  * and blows the file read ahead buffer. This is useful for
1211  * third party uses of the scanners filedescriptor, which hooks
1212  * onto the current scanning position.
1213  */
1214 void
1215 g_scanner_sync_file_offset (GScanner *scanner)
1216 {
1217   g_return_if_fail (scanner != NULL);
1218 
1219   /* for file input, rewind the filedescriptor to the current
1220    * buffer position and blow the file read ahead buffer. useful
1221    * for third party uses of our file descriptor, which hooks
1222    * onto the current scanning position.
1223    */
1224 
1225   if (scanner-&gt;input_fd &gt;= 0 &amp;&amp; scanner-&gt;text_end &gt; scanner-&gt;text)
1226     {
1227       gint buffered;
1228 
1229       buffered = scanner-&gt;text_end - scanner-&gt;text;
1230       if (lseek (scanner-&gt;input_fd, - buffered, SEEK_CUR) &gt;= 0)
<span class="line-modified">1231     {</span>
<span class="line-modified">1232       /* we succeeded, blow our buffer&#39;s contents now */</span>
<span class="line-modified">1233       scanner-&gt;text = NULL;</span>
<span class="line-modified">1234       scanner-&gt;text_end = NULL;</span>
<span class="line-modified">1235     }</span>
1236       else
<span class="line-modified">1237     errno = 0;</span>
1238     }
1239 }
1240 
1241 static guchar
<span class="line-modified">1242 g_scanner_get_char (GScanner    *scanner,</span>
<span class="line-modified">1243             guint   *line_p,</span>
<span class="line-modified">1244             guint   *position_p)</span>
1245 {
1246   guchar fchar;
1247 
1248   if (scanner-&gt;text &lt; scanner-&gt;text_end)
1249     fchar = *(scanner-&gt;text++);
1250   else if (scanner-&gt;input_fd &gt;= 0)
1251     {
1252       gint count;
1253       gchar *buffer;
1254 
1255       buffer = scanner-&gt;buffer;
1256       do
<span class="line-modified">1257     {</span>
<span class="line-modified">1258       count = read (scanner-&gt;input_fd, buffer, READ_BUFFER_SIZE);</span>
<span class="line-modified">1259     }</span>
1260       while (count == -1 &amp;&amp; (errno == EINTR || errno == EAGAIN));
1261 
1262       if (count &lt; 1)
<span class="line-modified">1263     {</span>
<span class="line-modified">1264       scanner-&gt;input_fd = -1;</span>
<span class="line-modified">1265       fchar = 0;</span>
<span class="line-modified">1266     }</span>
1267       else
<span class="line-modified">1268     {</span>
<span class="line-modified">1269       scanner-&gt;text = buffer + 1;</span>
<span class="line-modified">1270       scanner-&gt;text_end = buffer + count;</span>
<span class="line-modified">1271       fchar = *buffer;</span>
<span class="line-modified">1272       if (!fchar)</span>
<span class="line-modified">1273         {</span>
<span class="line-modified">1274           g_scanner_sync_file_offset (scanner);</span>
<span class="line-modified">1275           scanner-&gt;text_end = scanner-&gt;text;</span>
<span class="line-modified">1276           scanner-&gt;input_fd = -1;</span>
<span class="line-modified">1277         }</span>
<span class="line-modified">1278     }</span>
1279     }
1280   else
1281     fchar = 0;
1282 
1283   if (fchar == &#39;\n&#39;)
1284     {
1285       (*position_p) = 0;
1286       (*line_p)++;
1287     }
1288   else if (fchar)
1289     {
1290       (*position_p)++;
1291     }
1292 
1293   return fchar;
1294 }
1295 
1296 /**
1297  * g_scanner_unexp_token:
1298  * @scanner: a #GScanner
</pre>
<hr />
<pre>
1304  * @symbol_spec: a string describing how the scanner&#39;s user refers
1305  *     to symbols (%NULL defaults to &quot;symbol&quot;). This is used if
1306  *     @expected_token is %G_TOKEN_SYMBOL or any token value greater
1307  *     than %G_TOKEN_LAST.
1308  * @symbol_name: the name of the symbol, if the scanner&#39;s current
1309  *     token is a symbol.
1310  * @message: a message string to output at the end of the
1311  *     warning/error, or %NULL.
1312  * @is_error: if %TRUE it is output as an error. If %FALSE it is
1313  *     output as a warning.
1314  *
1315  * Outputs a message through the scanner&#39;s msg_handler,
1316  * resulting from an unexpected token in the input stream.
1317  * Note that you should not call g_scanner_peek_next_token()
1318  * followed by g_scanner_unexp_token() without an intermediate
1319  * call to g_scanner_get_next_token(), as g_scanner_unexp_token()
1320  * evaluates the scanner&#39;s current token (not the peeked token)
1321  * to construct part of the message.
1322  */
1323 void
<span class="line-modified">1324 g_scanner_unexp_token (GScanner     *scanner,</span>
<span class="line-modified">1325                GTokenType    expected_token,</span>
<span class="line-modified">1326                const gchar  *identifier_spec,</span>
<span class="line-modified">1327                const gchar  *symbol_spec,</span>
<span class="line-modified">1328                const gchar  *symbol_name,</span>
<span class="line-modified">1329                const gchar  *message,</span>
<span class="line-modified">1330                gint      is_error)</span>
1331 {
1332   gchar *token_string;
1333   guint token_string_len;
1334   gchar *expected_string;
1335   guint expected_string_len;
1336   gchar *message_prefix;
1337   gboolean print_unexp;
<span class="line-modified">1338   void (*msg_handler)   (GScanner*, const gchar*, ...);</span>
1339 
1340   g_return_if_fail (scanner != NULL);
1341 
1342   if (is_error)
1343     msg_handler = g_scanner_error;
1344   else
1345     msg_handler = g_scanner_warn;
1346 
1347   if (!identifier_spec)
1348     identifier_spec = &quot;identifier&quot;;
1349   if (!symbol_spec)
1350     symbol_spec = &quot;symbol&quot;;
1351 
1352   token_string_len = 56;
1353   token_string = g_new (gchar, token_string_len + 1);
1354   expected_string_len = 64;
1355   expected_string = g_new (gchar, expected_string_len + 1);
1356   print_unexp = TRUE;
1357 
1358   switch (scanner-&gt;token)
1359     {
1360     case G_TOKEN_EOF:
1361       _g_snprintf (token_string, token_string_len, &quot;end of file&quot;);
1362       break;
1363 
1364     default:
1365       if (scanner-&gt;token &gt;= 1 &amp;&amp; scanner-&gt;token &lt;= 255)
<span class="line-modified">1366     {</span>
<span class="line-modified">1367       if ((scanner-&gt;token &gt;= &#39; &#39; &amp;&amp; scanner-&gt;token &lt;= &#39;~&#39;) ||</span>
<span class="line-modified">1368           strchr (scanner-&gt;config-&gt;cset_identifier_first, scanner-&gt;token) ||</span>
<span class="line-modified">1369           strchr (scanner-&gt;config-&gt;cset_identifier_nth, scanner-&gt;token))</span>
<span class="line-modified">1370         _g_snprintf (token_string, token_string_len, &quot;character &#39;%c&#39;&quot;, scanner-&gt;token);</span>
<span class="line-modified">1371       else</span>
<span class="line-modified">1372         _g_snprintf (token_string, token_string_len, &quot;character &#39;\\%o&#39;&quot;, scanner-&gt;token);</span>
<span class="line-modified">1373       break;</span>
<span class="line-modified">1374     }</span>
1375       else if (!scanner-&gt;config-&gt;symbol_2_token)
<span class="line-modified">1376     {</span>
<span class="line-modified">1377       _g_snprintf (token_string, token_string_len, &quot;(unknown) token &lt;%d&gt;&quot;, scanner-&gt;token);</span>
<span class="line-modified">1378       break;</span>
<span class="line-modified">1379     }</span>
1380       /* fall through */
1381     case G_TOKEN_SYMBOL:
1382       if (expected_token == G_TOKEN_SYMBOL ||
<span class="line-modified">1383       (scanner-&gt;config-&gt;symbol_2_token &amp;&amp;</span>
<span class="line-modified">1384        expected_token &gt; G_TOKEN_LAST))</span>
<span class="line-modified">1385     print_unexp = FALSE;</span>
1386       if (symbol_name)
<span class="line-modified">1387     _g_snprintf (token_string,</span>
<span class="line-modified">1388              token_string_len,</span>
<span class="line-modified">1389              &quot;%s%s &#39;%s&#39;&quot;,</span>
<span class="line-modified">1390              print_unexp ? &quot;&quot; : &quot;invalid &quot;,</span>
<span class="line-modified">1391              symbol_spec,</span>
<span class="line-modified">1392              symbol_name);</span>
1393       else
<span class="line-modified">1394     _g_snprintf (token_string,</span>
<span class="line-modified">1395              token_string_len,</span>
<span class="line-modified">1396              &quot;%s%s&quot;,</span>
<span class="line-modified">1397              print_unexp ? &quot;&quot; : &quot;invalid &quot;,</span>
<span class="line-modified">1398              symbol_spec);</span>
1399       break;
1400 
1401     case G_TOKEN_ERROR:
1402       print_unexp = FALSE;
1403       expected_token = G_TOKEN_NONE;
1404       switch (scanner-&gt;value.v_error)
<span class="line-modified">1405     {</span>
<span class="line-modified">1406     case G_ERR_UNEXP_EOF:</span>
<span class="line-modified">1407       _g_snprintf (token_string, token_string_len, &quot;scanner: unexpected end of file&quot;);</span>
<span class="line-modified">1408       break;</span>
1409 
<span class="line-modified">1410     case G_ERR_UNEXP_EOF_IN_STRING:</span>
<span class="line-modified">1411       _g_snprintf (token_string, token_string_len, &quot;scanner: unterminated string constant&quot;);</span>
<span class="line-modified">1412       break;</span>
1413 
<span class="line-modified">1414     case G_ERR_UNEXP_EOF_IN_COMMENT:</span>
<span class="line-modified">1415       _g_snprintf (token_string, token_string_len, &quot;scanner: unterminated comment&quot;);</span>
<span class="line-modified">1416       break;</span>
1417 
<span class="line-modified">1418     case G_ERR_NON_DIGIT_IN_CONST:</span>
<span class="line-modified">1419       _g_snprintf (token_string, token_string_len, &quot;scanner: non digit in constant&quot;);</span>
<span class="line-modified">1420       break;</span>
1421 
<span class="line-modified">1422     case G_ERR_FLOAT_RADIX:</span>
<span class="line-modified">1423       _g_snprintf (token_string, token_string_len, &quot;scanner: invalid radix for floating constant&quot;);</span>
<span class="line-modified">1424       break;</span>
1425 
<span class="line-modified">1426     case G_ERR_FLOAT_MALFORMED:</span>
<span class="line-modified">1427       _g_snprintf (token_string, token_string_len, &quot;scanner: malformed floating constant&quot;);</span>
<span class="line-modified">1428       break;</span>
1429 
<span class="line-modified">1430     case G_ERR_DIGIT_RADIX:</span>
<span class="line-modified">1431       _g_snprintf (token_string, token_string_len, &quot;scanner: digit is beyond radix&quot;);</span>
<span class="line-modified">1432       break;</span>
1433 
<span class="line-modified">1434     case G_ERR_UNKNOWN:</span>
<span class="line-modified">1435     default:</span>
<span class="line-modified">1436       _g_snprintf (token_string, token_string_len, &quot;scanner: unknown error&quot;);</span>
<span class="line-modified">1437       break;</span>
<span class="line-modified">1438     }</span>
1439       break;
1440 
1441     case G_TOKEN_CHAR:
1442       _g_snprintf (token_string, token_string_len, &quot;character &#39;%c&#39;&quot;, scanner-&gt;value.v_char);
1443       break;
1444 
1445     case G_TOKEN_IDENTIFIER:
1446     case G_TOKEN_IDENTIFIER_NULL:
1447       if (expected_token == G_TOKEN_IDENTIFIER ||
<span class="line-modified">1448       expected_token == G_TOKEN_IDENTIFIER_NULL)</span>
<span class="line-modified">1449     print_unexp = FALSE;</span>
1450       _g_snprintf (token_string,
<span class="line-modified">1451           token_string_len,</span>
<span class="line-modified">1452           &quot;%s%s &#39;%s&#39;&quot;,</span>
<span class="line-modified">1453           print_unexp ? &quot;&quot; : &quot;invalid &quot;,</span>
<span class="line-modified">1454           identifier_spec,</span>
<span class="line-modified">1455           scanner-&gt;token == G_TOKEN_IDENTIFIER ? scanner-&gt;value.v_string : &quot;null&quot;);</span>
1456       break;
1457 
1458     case G_TOKEN_BINARY:
1459     case G_TOKEN_OCTAL:
1460     case G_TOKEN_INT:
1461     case G_TOKEN_HEX:
1462       if (scanner-&gt;config-&gt;store_int64)
<span class="line-modified">1463     _g_snprintf (token_string, token_string_len, &quot;number &#39;%&quot; G_GUINT64_FORMAT &quot;&#39;&quot;, scanner-&gt;value.v_int64);</span>
1464       else
<span class="line-modified">1465     _g_snprintf (token_string, token_string_len, &quot;number &#39;%lu&#39;&quot;, scanner-&gt;value.v_int);</span>
1466       break;
1467 
1468     case G_TOKEN_FLOAT:
1469       _g_snprintf (token_string, token_string_len, &quot;number &#39;%.3f&#39;&quot;, scanner-&gt;value.v_float);
1470       break;
1471 
1472     case G_TOKEN_STRING:
1473       if (expected_token == G_TOKEN_STRING)
<span class="line-modified">1474     print_unexp = FALSE;</span>
1475       _g_snprintf (token_string,
<span class="line-modified">1476            token_string_len,</span>
<span class="line-modified">1477            &quot;%s%sstring constant \&quot;%s\&quot;&quot;,</span>
<span class="line-modified">1478            print_unexp ? &quot;&quot; : &quot;invalid &quot;,</span>
<span class="line-modified">1479            scanner-&gt;value.v_string[0] == 0 ? &quot;empty &quot; : &quot;&quot;,</span>
<span class="line-modified">1480            scanner-&gt;value.v_string);</span>
1481       token_string[token_string_len - 2] = &#39;&quot;&#39;;
1482       token_string[token_string_len - 1] = 0;
1483       break;
1484 
1485     case G_TOKEN_COMMENT_SINGLE:
1486     case G_TOKEN_COMMENT_MULTI:
1487       _g_snprintf (token_string, token_string_len, &quot;comment&quot;);
1488       break;
1489 
1490     case G_TOKEN_NONE:
1491       /* somehow the user&#39;s parsing code is screwed, there isn&#39;t much
1492        * we can do about it.
1493        * Note, a common case to trigger this is
1494        * g_scanner_peek_next_token(); g_scanner_unexp_token();
1495        * without an intermediate g_scanner_get_next_token().
1496        */
1497       g_assert_not_reached ();
1498       break;
1499     }
1500 
1501 
1502   switch (expected_token)
1503     {
1504       gboolean need_valid;
1505       gchar *tstring;
1506     case G_TOKEN_EOF:
1507       _g_snprintf (expected_string, expected_string_len, &quot;end of file&quot;);
1508       break;
1509     default:
1510       if (expected_token &gt;= 1 &amp;&amp; expected_token &lt;= 255)
<span class="line-modified">1511     {</span>
<span class="line-modified">1512       if ((expected_token &gt;= &#39; &#39; &amp;&amp; expected_token &lt;= &#39;~&#39;) ||</span>
<span class="line-modified">1513           strchr (scanner-&gt;config-&gt;cset_identifier_first, expected_token) ||</span>
<span class="line-modified">1514           strchr (scanner-&gt;config-&gt;cset_identifier_nth, expected_token))</span>
<span class="line-modified">1515         _g_snprintf (expected_string, expected_string_len, &quot;character &#39;%c&#39;&quot;, expected_token);</span>
<span class="line-modified">1516       else</span>
<span class="line-modified">1517         _g_snprintf (expected_string, expected_string_len, &quot;character &#39;\\%o&#39;&quot;, expected_token);</span>
<span class="line-modified">1518       break;</span>
<span class="line-modified">1519     }</span>
1520       else if (!scanner-&gt;config-&gt;symbol_2_token)
<span class="line-modified">1521     {</span>
<span class="line-modified">1522       _g_snprintf (expected_string, expected_string_len, &quot;(unknown) token &lt;%d&gt;&quot;, expected_token);</span>
<span class="line-modified">1523       break;</span>
<span class="line-modified">1524     }</span>
1525       /* fall through */
1526     case G_TOKEN_SYMBOL:
1527       need_valid = (scanner-&gt;token == G_TOKEN_SYMBOL ||
<span class="line-modified">1528             (scanner-&gt;config-&gt;symbol_2_token &amp;&amp;</span>
<span class="line-modified">1529              scanner-&gt;token &gt; G_TOKEN_LAST));</span>
1530       _g_snprintf (expected_string,
<span class="line-modified">1531            expected_string_len,</span>
<span class="line-modified">1532            &quot;%s%s&quot;,</span>
<span class="line-modified">1533            need_valid ? &quot;valid &quot; : &quot;&quot;,</span>
<span class="line-modified">1534            symbol_spec);</span>
<span class="line-modified">1535       /* FIXME: should we attempt to lookup the symbol_name for symbol_2_token? */</span>
1536       break;
1537     case G_TOKEN_CHAR:
1538       _g_snprintf (expected_string, expected_string_len, &quot;%scharacter&quot;,
<span class="line-modified">1539            scanner-&gt;token == G_TOKEN_CHAR ? &quot;valid &quot; : &quot;&quot;);</span>
1540       break;
1541     case G_TOKEN_BINARY:
1542       tstring = &quot;binary&quot;;
1543       _g_snprintf (expected_string, expected_string_len, &quot;%snumber (%s)&quot;,
<span class="line-modified">1544            scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);</span>
1545       break;
1546     case G_TOKEN_OCTAL:
1547       tstring = &quot;octal&quot;;
1548       _g_snprintf (expected_string, expected_string_len, &quot;%snumber (%s)&quot;,
<span class="line-modified">1549            scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);</span>
1550       break;
1551     case G_TOKEN_INT:
1552       tstring = &quot;integer&quot;;
1553       _g_snprintf (expected_string, expected_string_len, &quot;%snumber (%s)&quot;,
<span class="line-modified">1554            scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);</span>
1555       break;
1556     case G_TOKEN_HEX:
1557       tstring = &quot;hexadecimal&quot;;
1558       _g_snprintf (expected_string, expected_string_len, &quot;%snumber (%s)&quot;,
<span class="line-modified">1559            scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);</span>
1560       break;
1561     case G_TOKEN_FLOAT:
1562       tstring = &quot;float&quot;;
1563       _g_snprintf (expected_string, expected_string_len, &quot;%snumber (%s)&quot;,
<span class="line-modified">1564            scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);</span>
1565       break;
1566     case G_TOKEN_STRING:
1567       _g_snprintf (expected_string,
<span class="line-modified">1568            expected_string_len,</span>
<span class="line-modified">1569            &quot;%sstring constant&quot;,</span>
<span class="line-modified">1570            scanner-&gt;token == G_TOKEN_STRING ? &quot;valid &quot; : &quot;&quot;);</span>
1571       break;
1572     case G_TOKEN_IDENTIFIER:
1573     case G_TOKEN_IDENTIFIER_NULL:
1574       need_valid = (scanner-&gt;token == G_TOKEN_IDENTIFIER_NULL ||
<span class="line-modified">1575             scanner-&gt;token == G_TOKEN_IDENTIFIER);</span>
1576       _g_snprintf (expected_string,
<span class="line-modified">1577            expected_string_len,</span>
<span class="line-modified">1578            &quot;%s%s&quot;,</span>
<span class="line-modified">1579            need_valid ? &quot;valid &quot; : &quot;&quot;,</span>
<span class="line-modified">1580            identifier_spec);</span>
1581       break;
1582     case G_TOKEN_COMMENT_SINGLE:
1583       tstring = &quot;single-line&quot;;
1584       _g_snprintf (expected_string, expected_string_len, &quot;%scomment (%s)&quot;,
<span class="line-modified">1585            scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);</span>
1586       break;
1587     case G_TOKEN_COMMENT_MULTI:
1588       tstring = &quot;multi-line&quot;;
1589       _g_snprintf (expected_string, expected_string_len, &quot;%scomment (%s)&quot;,
<span class="line-modified">1590            scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);</span>
1591       break;
1592     case G_TOKEN_NONE:
1593     case G_TOKEN_ERROR:
1594       /* this is handled upon printout */
1595       break;
1596     }
1597 
1598   if (message &amp;&amp; message[0] != 0)
1599     message_prefix = &quot; - &quot;;
1600   else
1601     {
1602       message_prefix = &quot;&quot;;
1603       message = &quot;&quot;;
1604     }
1605   if (expected_token == G_TOKEN_ERROR)
1606     {
1607       msg_handler (scanner,
<span class="line-modified">1608            &quot;failure around %s%s%s&quot;,</span>
<span class="line-modified">1609            token_string,</span>
<span class="line-modified">1610            message_prefix,</span>
<span class="line-modified">1611            message);</span>
1612     }
1613   else if (expected_token == G_TOKEN_NONE)
1614     {
1615       if (print_unexp)
<span class="line-modified">1616     msg_handler (scanner,</span>
<span class="line-modified">1617              &quot;unexpected %s%s%s&quot;,</span>
<span class="line-modified">1618              token_string,</span>
<span class="line-modified">1619              message_prefix,</span>
<span class="line-modified">1620              message);</span>
1621       else
<span class="line-modified">1622     msg_handler (scanner,</span>
<span class="line-modified">1623              &quot;%s%s%s&quot;,</span>
<span class="line-modified">1624              token_string,</span>
<span class="line-modified">1625              message_prefix,</span>
<span class="line-modified">1626              message);</span>
1627     }
1628   else
1629     {
1630       if (print_unexp)
<span class="line-modified">1631     msg_handler (scanner,</span>
<span class="line-modified">1632              &quot;unexpected %s, expected %s%s%s&quot;,</span>
<span class="line-modified">1633              token_string,</span>
<span class="line-modified">1634              expected_string,</span>
<span class="line-modified">1635              message_prefix,</span>
<span class="line-modified">1636              message);</span>
1637       else
<span class="line-modified">1638     msg_handler (scanner,</span>
<span class="line-modified">1639              &quot;%s, expected %s%s%s&quot;,</span>
<span class="line-modified">1640              token_string,</span>
<span class="line-modified">1641              expected_string,</span>
<span class="line-modified">1642              message_prefix,</span>
<span class="line-modified">1643              message);</span>
1644     }
1645 
1646   g_free (token_string);
1647   g_free (expected_string);
1648 }
1649 
1650 static void
1651 g_scanner_get_token_i (GScanner *scanner,
<span class="line-modified">1652                GTokenType   *token_p,</span>
<span class="line-modified">1653                GTokenValue  *value_p,</span>
<span class="line-modified">1654                guint        *line_p,</span>
<span class="line-modified">1655                guint        *position_p)</span>
1656 {
1657   do
1658     {
1659       g_scanner_free_value (token_p, value_p);
1660       g_scanner_get_token_ll (scanner, token_p, value_p, line_p, position_p);
1661     }
1662   while (((*token_p &gt; 0 &amp;&amp; *token_p &lt; 256) &amp;&amp;
<span class="line-modified">1663       strchr (scanner-&gt;config-&gt;cset_skip_characters, *token_p)) ||</span>
<span class="line-modified">1664      (*token_p == G_TOKEN_CHAR &amp;&amp;</span>
<span class="line-modified">1665       strchr (scanner-&gt;config-&gt;cset_skip_characters, value_p-&gt;v_char)) ||</span>
<span class="line-modified">1666      (*token_p == G_TOKEN_COMMENT_MULTI &amp;&amp;</span>
<span class="line-modified">1667       scanner-&gt;config-&gt;skip_comment_multi) ||</span>
<span class="line-modified">1668      (*token_p == G_TOKEN_COMMENT_SINGLE &amp;&amp;</span>
<span class="line-modified">1669       scanner-&gt;config-&gt;skip_comment_single));</span>
1670 
1671   switch (*token_p)
1672     {
1673     case G_TOKEN_IDENTIFIER:
1674       if (scanner-&gt;config-&gt;identifier_2_string)
<span class="line-modified">1675     *token_p = G_TOKEN_STRING;</span>
1676       break;
1677 
1678     case G_TOKEN_SYMBOL:
1679       if (scanner-&gt;config-&gt;symbol_2_token)
<span class="line-modified">1680     *token_p = (GTokenType) value_p-&gt;v_symbol;</span>
1681       break;
1682 
1683     case G_TOKEN_BINARY:
1684     case G_TOKEN_OCTAL:
1685     case G_TOKEN_HEX:
1686       if (scanner-&gt;config-&gt;numbers_2_int)
<span class="line-modified">1687     *token_p = G_TOKEN_INT;</span>
1688       break;
1689 
1690     default:
1691       break;
1692     }
1693 
1694   if (*token_p == G_TOKEN_INT &amp;&amp;
1695       scanner-&gt;config-&gt;int_2_float)
1696     {
1697       *token_p = G_TOKEN_FLOAT;
1698       if (scanner-&gt;config-&gt;store_int64)
1699         {
1700           value_p-&gt;v_float = value_p-&gt;v_int64;
1701         }
1702       else
<span class="line-modified">1703     value_p-&gt;v_float = value_p-&gt;v_int;</span>
1704     }
1705 
1706   errno = 0;
1707 }
1708 
1709 static void
<span class="line-modified">1710 g_scanner_get_token_ll  (GScanner   *scanner,</span>
<span class="line-modified">1711              GTokenType *token_p,</span>
<span class="line-modified">1712              GTokenValue    *value_p,</span>
<span class="line-modified">1713              guint      *line_p,</span>
<span class="line-modified">1714              guint      *position_p)</span>
1715 {
1716   GScannerConfig *config;
<span class="line-modified">1717   GTokenType       token;</span>
1718   gboolean     in_comment_multi;
1719   gboolean     in_comment_single;
1720   gboolean     in_string_sq;
1721   gboolean     in_string_dq;
<span class="line-modified">1722   GString     *gstring;</span>
<span class="line-modified">1723   GTokenValue      value;</span>
<span class="line-modified">1724   guchar       ch;</span>
1725 
1726   config = scanner-&gt;config;
1727   (*value_p).v_int64 = 0;
1728 
1729   if ((scanner-&gt;text &gt;= scanner-&gt;text_end &amp;&amp; scanner-&gt;input_fd &lt; 0) ||
1730       scanner-&gt;token == G_TOKEN_EOF)
1731     {
1732       *token_p = G_TOKEN_EOF;
1733       return;
1734     }
1735 
1736   in_comment_multi = FALSE;
1737   in_comment_single = FALSE;
1738   in_string_sq = FALSE;
1739   in_string_dq = FALSE;
1740   gstring = NULL;
1741 
1742   do /* while (ch != 0) */
1743     {
1744       gboolean dotted_float = FALSE;
1745 
1746       ch = g_scanner_get_char (scanner, line_p, position_p);
1747 
1748       value.v_int64 = 0;
1749       token = G_TOKEN_NONE;
1750 
1751       /* this is *evil*, but needed ;(
1752        * we first check for identifier first character, because  it
1753        * might interfere with other key chars like slashes or numbers
1754        */
1755       if (config-&gt;scan_identifier &amp;&amp;
<span class="line-modified">1756       ch &amp;&amp; strchr (config-&gt;cset_identifier_first, ch))</span>
<span class="line-modified">1757     goto identifier_precedence;</span>
1758 
1759       switch (ch)
<span class="line-modified">1760     {</span>
<span class="line-modified">1761     case 0:</span>
<span class="line-modified">1762       token = G_TOKEN_EOF;</span>
<span class="line-modified">1763       (*position_p)++;</span>
<span class="line-modified">1764       /* ch = 0; */</span>
<span class="line-modified">1765       break;</span>
1766 
<span class="line-modified">1767     case &#39;/&#39;:</span>
<span class="line-modified">1768       if (!config-&gt;scan_comment_multi ||</span>
<span class="line-modified">1769           g_scanner_peek_next_char (scanner) != &#39;*&#39;)</span>
<span class="line-modified">1770         goto default_case;</span>








1771       g_scanner_get_char (scanner, line_p, position_p);
<span class="line-modified">1772       token = G_TOKEN_COMMENT_MULTI;</span>
<span class="line-removed">1773       in_comment_multi = TRUE;</span>
<span class="line-removed">1774       gstring = g_string_new (NULL);</span>
<span class="line-removed">1775       while ((ch = g_scanner_get_char (scanner, line_p, position_p)) != 0)</span>
<span class="line-removed">1776         {</span>
<span class="line-removed">1777           if (ch == &#39;*&#39; &amp;&amp; g_scanner_peek_next_char (scanner) == &#39;/&#39;)</span>
<span class="line-removed">1778         {</span>
<span class="line-removed">1779           g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-removed">1780           in_comment_multi = FALSE;</span>
<span class="line-removed">1781           break;</span>
<span class="line-removed">1782         }</span>
<span class="line-removed">1783           else</span>
<span class="line-removed">1784         gstring = g_string_append_c (gstring, ch);</span>
<span class="line-removed">1785         }</span>
<span class="line-removed">1786       ch = 0;</span>
1787       break;






1788 
<span class="line-modified">1789     case &#39;\&#39;&#39;:</span>
<span class="line-modified">1790       if (!config-&gt;scan_string_sq)</span>
<span class="line-modified">1791         goto default_case;</span>
<span class="line-modified">1792       token = G_TOKEN_STRING;</span>
<span class="line-modified">1793       in_string_sq = TRUE;</span>
<span class="line-modified">1794       gstring = g_string_new (NULL);</span>
<span class="line-modified">1795       while ((ch = g_scanner_get_char (scanner, line_p, position_p)) != 0)</span>
<span class="line-modified">1796         {</span>
<span class="line-modified">1797           if (ch == &#39;\&#39;&#39;)</span>
<span class="line-modified">1798         {</span>
<span class="line-modified">1799           in_string_sq = FALSE;</span>
<span class="line-removed">1800           break;</span>
<span class="line-removed">1801         }</span>
<span class="line-removed">1802           else</span>
<span class="line-removed">1803         gstring = g_string_append_c (gstring, ch);</span>
<span class="line-removed">1804         }</span>
<span class="line-removed">1805       ch = 0;</span>
1806       break;






1807 
<span class="line-modified">1808     case &#39;&quot;&#39;:</span>
<span class="line-modified">1809       if (!config-&gt;scan_string_dq)</span>
<span class="line-modified">1810         goto default_case;</span>
<span class="line-modified">1811       token = G_TOKEN_STRING;</span>
<span class="line-modified">1812       in_string_dq = TRUE;</span>
<span class="line-modified">1813       gstring = g_string_new (NULL);</span>
<span class="line-modified">1814       while ((ch = g_scanner_get_char (scanner, line_p, position_p)) != 0)</span>
<span class="line-modified">1815         {</span>
<span class="line-modified">1816           if (ch == &#39;&quot;&#39;)</span>
<span class="line-modified">1817         {</span>
<span class="line-modified">1818           in_string_dq = FALSE;</span>
<span class="line-removed">1819           break;</span>
<span class="line-removed">1820         }</span>
<span class="line-removed">1821           else</span>
<span class="line-removed">1822         {</span>
<span class="line-removed">1823           if (ch == &#39;\\&#39;)</span>
<span class="line-removed">1824             {</span>
<span class="line-removed">1825               ch = g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-removed">1826               switch (ch)</span>
<span class="line-removed">1827             {</span>
<span class="line-removed">1828               guint i;</span>
<span class="line-removed">1829               guint fchar;</span>
<span class="line-removed">1830 </span>
<span class="line-removed">1831             case 0:</span>
<span class="line-removed">1832               break;</span>
<span class="line-removed">1833 </span>
<span class="line-removed">1834             case &#39;\\&#39;:</span>
<span class="line-removed">1835               gstring = g_string_append_c (gstring, &#39;\\&#39;);</span>
<span class="line-removed">1836               break;</span>
<span class="line-removed">1837 </span>
<span class="line-removed">1838             case &#39;n&#39;:</span>
<span class="line-removed">1839               gstring = g_string_append_c (gstring, &#39;\n&#39;);</span>
<span class="line-removed">1840               break;</span>
<span class="line-removed">1841 </span>
<span class="line-removed">1842             case &#39;t&#39;:</span>
<span class="line-removed">1843               gstring = g_string_append_c (gstring, &#39;\t&#39;);</span>
<span class="line-removed">1844               break;</span>
<span class="line-removed">1845 </span>
<span class="line-removed">1846             case &#39;r&#39;:</span>
<span class="line-removed">1847               gstring = g_string_append_c (gstring, &#39;\r&#39;);</span>
<span class="line-removed">1848               break;</span>
<span class="line-removed">1849 </span>
<span class="line-removed">1850             case &#39;b&#39;:</span>
<span class="line-removed">1851               gstring = g_string_append_c (gstring, &#39;\b&#39;);</span>
<span class="line-removed">1852               break;</span>
<span class="line-removed">1853 </span>
<span class="line-removed">1854             case &#39;f&#39;:</span>
<span class="line-removed">1855               gstring = g_string_append_c (gstring, &#39;\f&#39;);</span>
<span class="line-removed">1856               break;</span>
<span class="line-removed">1857 </span>
<span class="line-removed">1858             case &#39;0&#39;:</span>
<span class="line-removed">1859             case &#39;1&#39;:</span>
<span class="line-removed">1860             case &#39;2&#39;:</span>
<span class="line-removed">1861             case &#39;3&#39;:</span>
<span class="line-removed">1862             case &#39;4&#39;:</span>
<span class="line-removed">1863             case &#39;5&#39;:</span>
<span class="line-removed">1864             case &#39;6&#39;:</span>
<span class="line-removed">1865             case &#39;7&#39;:</span>
<span class="line-removed">1866               i = ch - &#39;0&#39;;</span>
<span class="line-removed">1867               fchar = g_scanner_peek_next_char (scanner);</span>
<span class="line-removed">1868               if (fchar &gt;= &#39;0&#39; &amp;&amp; fchar &lt;= &#39;7&#39;)</span>
<span class="line-removed">1869                 {</span>
<span class="line-removed">1870                   ch = g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-removed">1871                   i = i * 8 + ch - &#39;0&#39;;</span>
<span class="line-removed">1872                   fchar = g_scanner_peek_next_char (scanner);</span>
<span class="line-removed">1873                   if (fchar &gt;= &#39;0&#39; &amp;&amp; fchar &lt;= &#39;7&#39;)</span>
<span class="line-removed">1874                 {</span>
<span class="line-removed">1875                   ch = g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-removed">1876                   i = i * 8 + ch - &#39;0&#39;;</span>
<span class="line-removed">1877                 }</span>
<span class="line-removed">1878                 }</span>
<span class="line-removed">1879               gstring = g_string_append_c (gstring, i);</span>
<span class="line-removed">1880               break;</span>
<span class="line-removed">1881 </span>
<span class="line-removed">1882             default:</span>
<span class="line-removed">1883               gstring = g_string_append_c (gstring, ch);</span>
<span class="line-removed">1884               break;</span>
<span class="line-removed">1885             }</span>
<span class="line-removed">1886             }</span>
<span class="line-removed">1887           else</span>
<span class="line-removed">1888             gstring = g_string_append_c (gstring, ch);</span>
<span class="line-removed">1889         }</span>
<span class="line-removed">1890         }</span>
<span class="line-removed">1891       ch = 0;</span>
1892       break;
<span class="line-modified">1893 </span>
<span class="line-modified">1894     case &#39;.&#39;:</span>
<span class="line-modified">1895       if (!config-&gt;scan_float)</span>
<span class="line-modified">1896         goto default_case;</span>
<span class="line-removed">1897       token = G_TOKEN_FLOAT;</span>
<span class="line-removed">1898       dotted_float = TRUE;</span>
<span class="line-removed">1899       ch = g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-removed">1900       goto number_parsing;</span>
<span class="line-removed">1901 </span>
<span class="line-removed">1902     case &#39;$&#39;:</span>
<span class="line-removed">1903       if (!config-&gt;scan_hex_dollar)</span>
<span class="line-removed">1904         goto default_case;</span>
<span class="line-removed">1905       token = G_TOKEN_HEX;</span>
<span class="line-removed">1906       ch = g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-removed">1907       goto number_parsing;</span>
<span class="line-removed">1908 </span>
<span class="line-removed">1909     case &#39;0&#39;:</span>
<span class="line-removed">1910       if (config-&gt;scan_octal)</span>
<span class="line-removed">1911         token = G_TOKEN_OCTAL;</span>
<span class="line-removed">1912       else</span>
<span class="line-removed">1913         token = G_TOKEN_INT;</span>
<span class="line-removed">1914       ch = g_scanner_peek_next_char (scanner);</span>
<span class="line-removed">1915       if (config-&gt;scan_hex &amp;&amp; (ch == &#39;x&#39; || ch == &#39;X&#39;))</span>
1916         {
<span class="line-removed">1917           token = G_TOKEN_HEX;</span>
<span class="line-removed">1918           g_scanner_get_char (scanner, line_p, position_p);</span>
1919           ch = g_scanner_get_char (scanner, line_p, position_p);
<span class="line-modified">1920           if (ch == 0)</span>
<span class="line-modified">1921         {</span>
<span class="line-modified">1922           token = G_TOKEN_ERROR;</span>
<span class="line-modified">1923           value.v_error = G_ERR_UNEXP_EOF;</span>
<span class="line-modified">1924           (*position_p)++;</span>
<span class="line-modified">1925           break;</span>
<span class="line-modified">1926         }</span>
<span class="line-modified">1927           if (g_scanner_char_2_num (ch, 16) &lt; 0)</span>
<span class="line-modified">1928         {</span>
<span class="line-modified">1929           token = G_TOKEN_ERROR;</span>
<span class="line-modified">1930           value.v_error = G_ERR_DIGIT_RADIX;</span>
<span class="line-modified">1931           ch = 0;</span>
<span class="line-modified">1932           break;</span>
<span class="line-modified">1933         }</span>
<span class="line-modified">1934         }</span>
<span class="line-modified">1935       else if (config-&gt;scan_binary &amp;&amp; (ch == &#39;b&#39; || ch == &#39;B&#39;))</span>
































1936         {
<span class="line-removed">1937           token = G_TOKEN_BINARY;</span>
<span class="line-removed">1938           g_scanner_get_char (scanner, line_p, position_p);</span>
1939           ch = g_scanner_get_char (scanner, line_p, position_p);
<span class="line-modified">1940           if (ch == 0)</span>
<span class="line-removed">1941         {</span>
<span class="line-removed">1942           token = G_TOKEN_ERROR;</span>
<span class="line-removed">1943           value.v_error = G_ERR_UNEXP_EOF;</span>
<span class="line-removed">1944           (*position_p)++;</span>
<span class="line-removed">1945           break;</span>
<span class="line-removed">1946         }</span>
<span class="line-removed">1947           if (g_scanner_char_2_num (ch, 10) &lt; 0)</span>
<span class="line-removed">1948         {</span>
<span class="line-removed">1949           token = G_TOKEN_ERROR;</span>
<span class="line-removed">1950           value.v_error = G_ERR_NON_DIGIT_IN_CONST;</span>
<span class="line-removed">1951           ch = 0;</span>
<span class="line-removed">1952           break;</span>
1953         }








1954         }
1955       else
<span class="line-modified">1956         ch = &#39;0&#39;;</span>
<span class="line-modified">1957       /* fall through */</span>
<span class="line-modified">1958     case &#39;1&#39;:</span>
<span class="line-modified">1959     case &#39;2&#39;:</span>
<span class="line-modified">1960     case &#39;3&#39;:</span>
<span class="line-modified">1961     case &#39;4&#39;:</span>
<span class="line-modified">1962     case &#39;5&#39;:</span>
<span class="line-modified">1963     case &#39;6&#39;:</span>
<span class="line-modified">1964     case &#39;7&#39;:</span>
<span class="line-modified">1965     case &#39;8&#39;:</span>
<span class="line-modified">1966     case &#39;9&#39;:</span>
<span class="line-modified">1967     number_parsing:</span>









































1968     {



























1969           gboolean in_number = TRUE;
<span class="line-modified">1970       gchar *endptr;</span>
1971 
<span class="line-modified">1972       if (token == G_TOKEN_NONE)</span>
<span class="line-modified">1973         token = G_TOKEN_INT;</span>
1974 
<span class="line-modified">1975       gstring = g_string_new (dotted_float ? &quot;0.&quot; : &quot;&quot;);</span>
<span class="line-modified">1976       gstring = g_string_append_c (gstring, ch);</span>
<span class="line-removed">1977 </span>
<span class="line-removed">1978       do /* while (in_number) */</span>
<span class="line-removed">1979         {</span>
<span class="line-removed">1980           gboolean is_E;</span>
1981 
<span class="line-modified">1982           is_E = token == G_TOKEN_FLOAT &amp;&amp; (ch == &#39;e&#39; || ch == &#39;E&#39;);</span>


1983 
<span class="line-modified">1984           ch = g_scanner_peek_next_char (scanner);</span>
1985 
<span class="line-modified">1986           if (g_scanner_char_2_num (ch, 36) &gt;= 0 ||</span>
<span class="line-removed">1987           (config-&gt;scan_float &amp;&amp; ch == &#39;.&#39;) ||</span>
<span class="line-removed">1988           (is_E &amp;&amp; (ch == &#39;+&#39; || ch == &#39;-&#39;)))</span>
<span class="line-removed">1989         {</span>
<span class="line-removed">1990           ch = g_scanner_get_char (scanner, line_p, position_p);</span>
1991 
<span class="line-modified">1992           switch (ch)</span>
<span class="line-modified">1993             {</span>
<span class="line-modified">1994             case &#39;.&#39;:</span>
<span class="line-modified">1995               if (token != G_TOKEN_INT &amp;&amp; token != G_TOKEN_OCTAL)</span>
<span class="line-modified">1996             {</span>
<span class="line-removed">1997               value.v_error = token == G_TOKEN_FLOAT ? G_ERR_FLOAT_MALFORMED : G_ERR_FLOAT_RADIX;</span>
<span class="line-removed">1998               token = G_TOKEN_ERROR;</span>
<span class="line-removed">1999               in_number = FALSE;</span>
<span class="line-removed">2000             }</span>
<span class="line-removed">2001               else</span>
<span class="line-removed">2002             {</span>
<span class="line-removed">2003               token = G_TOKEN_FLOAT;</span>
<span class="line-removed">2004               gstring = g_string_append_c (gstring, ch);</span>
<span class="line-removed">2005             }</span>
<span class="line-removed">2006               break;</span>
<span class="line-removed">2007 </span>
<span class="line-removed">2008             case &#39;0&#39;:</span>
<span class="line-removed">2009             case &#39;1&#39;:</span>
<span class="line-removed">2010             case &#39;2&#39;:</span>
<span class="line-removed">2011             case &#39;3&#39;:</span>
<span class="line-removed">2012             case &#39;4&#39;:</span>
<span class="line-removed">2013             case &#39;5&#39;:</span>
<span class="line-removed">2014             case &#39;6&#39;:</span>
<span class="line-removed">2015             case &#39;7&#39;:</span>
<span class="line-removed">2016             case &#39;8&#39;:</span>
<span class="line-removed">2017             case &#39;9&#39;:</span>
<span class="line-removed">2018               gstring = g_string_append_c (gstring, ch);</span>
<span class="line-removed">2019               break;</span>
<span class="line-removed">2020 </span>
<span class="line-removed">2021             case &#39;-&#39;:</span>
<span class="line-removed">2022             case &#39;+&#39;:</span>
<span class="line-removed">2023               if (token != G_TOKEN_FLOAT)</span>
<span class="line-removed">2024             {</span>
<span class="line-removed">2025               token = G_TOKEN_ERROR;</span>
<span class="line-removed">2026               value.v_error = G_ERR_NON_DIGIT_IN_CONST;</span>
<span class="line-removed">2027               in_number = FALSE;</span>
<span class="line-removed">2028             }</span>
<span class="line-removed">2029               else</span>
<span class="line-removed">2030             gstring = g_string_append_c (gstring, ch);</span>
<span class="line-removed">2031               break;</span>
<span class="line-removed">2032 </span>
<span class="line-removed">2033             case &#39;e&#39;:</span>
<span class="line-removed">2034             case &#39;E&#39;:</span>
<span class="line-removed">2035               if ((token != G_TOKEN_HEX &amp;&amp; !config-&gt;scan_float) ||</span>
<span class="line-removed">2036               (token != G_TOKEN_HEX &amp;&amp;</span>
<span class="line-removed">2037                token != G_TOKEN_OCTAL &amp;&amp;</span>
<span class="line-removed">2038                token != G_TOKEN_FLOAT &amp;&amp;</span>
<span class="line-removed">2039                token != G_TOKEN_INT))</span>
<span class="line-removed">2040             {</span>
<span class="line-removed">2041               token = G_TOKEN_ERROR;</span>
<span class="line-removed">2042               value.v_error = G_ERR_NON_DIGIT_IN_CONST;</span>
<span class="line-removed">2043               in_number = FALSE;</span>
<span class="line-removed">2044             }</span>
<span class="line-removed">2045               else</span>
<span class="line-removed">2046             {</span>
<span class="line-removed">2047               if (token != G_TOKEN_HEX)</span>
<span class="line-removed">2048                 token = G_TOKEN_FLOAT;</span>
<span class="line-removed">2049               gstring = g_string_append_c (gstring, ch);</span>
<span class="line-removed">2050             }</span>
<span class="line-removed">2051               break;</span>
<span class="line-removed">2052 </span>
<span class="line-removed">2053             default:</span>
<span class="line-removed">2054               if (token != G_TOKEN_HEX)</span>
<span class="line-removed">2055             {</span>
<span class="line-removed">2056               token = G_TOKEN_ERROR;</span>
<span class="line-removed">2057               value.v_error = G_ERR_NON_DIGIT_IN_CONST;</span>
<span class="line-removed">2058               in_number = FALSE;</span>
<span class="line-removed">2059             }</span>
<span class="line-removed">2060               else</span>
<span class="line-removed">2061             gstring = g_string_append_c (gstring, ch);</span>
<span class="line-removed">2062               break;</span>
<span class="line-removed">2063             }</span>
<span class="line-removed">2064         }</span>
<span class="line-removed">2065           else</span>
<span class="line-removed">2066         in_number = FALSE;</span>
<span class="line-removed">2067         }</span>
<span class="line-removed">2068       while (in_number);</span>
2069 
<span class="line-modified">2070       endptr = NULL;</span>
<span class="line-removed">2071       if (token == G_TOKEN_FLOAT)</span>
<span class="line-removed">2072         value.v_float = g_strtod (gstring-&gt;str, &amp;endptr);</span>
<span class="line-removed">2073       else</span>
<span class="line-removed">2074         {</span>
<span class="line-removed">2075           guint64 ui64 = 0;</span>
<span class="line-removed">2076           switch (token)</span>
2077         {
<span class="line-modified">2078         case G_TOKEN_BINARY:</span>
<span class="line-modified">2079           ui64 = g_ascii_strtoull (gstring-&gt;str, &amp;endptr, 2);</span>
<span class="line-modified">2080           break;</span>
<span class="line-modified">2081         case G_TOKEN_OCTAL:</span>
<span class="line-modified">2082           ui64 = g_ascii_strtoull (gstring-&gt;str, &amp;endptr, 8);</span>







2083           break;
<span class="line-modified">2084         case G_TOKEN_INT:</span>
<span class="line-modified">2085           ui64 = g_ascii_strtoull (gstring-&gt;str, &amp;endptr, 10);</span>










2086           break;
<span class="line-modified">2087         case G_TOKEN_HEX:</span>
<span class="line-modified">2088           ui64 = g_ascii_strtoull (gstring-&gt;str, &amp;endptr, 16);</span>









2089           break;
<span class="line-modified">2090         default: ;</span>
<span class="line-modified">2091         }</span>
<span class="line-modified">2092           if (scanner-&gt;config-&gt;store_int64)</span>
<span class="line-modified">2093         value.v_int64 = ui64;</span>









2094           else
<span class="line-modified">2095         value.v_int = ui64;</span>
<span class="line-modified">2096         }</span>
<span class="line-modified">2097       if (endptr &amp;&amp; *endptr)</span>
<span class="line-modified">2098         {</span>
<span class="line-modified">2099           token = G_TOKEN_ERROR;</span>
<span class="line-modified">2100           if (*endptr == &#39;e&#39; || *endptr == &#39;E&#39;)</span>





2101         value.v_error = G_ERR_NON_DIGIT_IN_CONST;


2102           else
<span class="line-modified">2103         value.v_error = G_ERR_DIGIT_RADIX;</span>

2104         }
<span class="line-modified">2105       g_string_free (gstring, TRUE);</span>
<span class="line-modified">2106       gstring = NULL;</span>
<span class="line-modified">2107       ch = 0;</span>
<span class="line-modified">2108     } /* number_parsing:... */</span>
<span class="line-modified">2109     break;</span>
<span class="line-modified">2110 </span>
<span class="line-modified">2111     default:</span>
<span class="line-modified">2112     default_case:</span>





2113     {
<span class="line-modified">2114       if (config-&gt;cpair_comment_single &amp;&amp;</span>
<span class="line-modified">2115           ch == config-&gt;cpair_comment_single[0])</span>
<span class="line-modified">2116         {</span>
<span class="line-modified">2117           token = G_TOKEN_COMMENT_SINGLE;</span>
<span class="line-modified">2118           in_comment_single = TRUE;</span>
<span class="line-modified">2119           gstring = g_string_new (NULL);</span>
<span class="line-modified">2120           ch = g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-modified">2121           while (ch != 0)</span>






































2122         {
<span class="line-modified">2123           if (ch == config-&gt;cpair_comment_single[1])</span>
<span class="line-modified">2124             {</span>
<span class="line-modified">2125               in_comment_single = FALSE;</span>
<span class="line-removed">2126               ch = 0;</span>
<span class="line-removed">2127               break;</span>
<span class="line-removed">2128             }</span>
<span class="line-removed">2129 </span>
<span class="line-removed">2130           gstring = g_string_append_c (gstring, ch);</span>
<span class="line-removed">2131           ch = g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-removed">2132         }</span>
<span class="line-removed">2133           /* ignore a missing newline at EOF for single line comments */</span>
<span class="line-removed">2134           if (in_comment_single &amp;&amp;</span>
<span class="line-removed">2135           config-&gt;cpair_comment_single[1] == &#39;\n&#39;)</span>
<span class="line-removed">2136         in_comment_single = FALSE;</span>
2137         }
<span class="line-removed">2138       else if (config-&gt;scan_identifier &amp;&amp; ch &amp;&amp;</span>
<span class="line-removed">2139            strchr (config-&gt;cset_identifier_first, ch))</span>
<span class="line-removed">2140         {</span>
<span class="line-removed">2141         identifier_precedence:</span>
2142 
<span class="line-modified">2143           if (config-&gt;cset_identifier_nth &amp;&amp; ch &amp;&amp;</span>
<span class="line-modified">2144           strchr (config-&gt;cset_identifier_nth,</span>
<span class="line-modified">2145               g_scanner_peek_next_char (scanner)))</span>


















2146         {
<span class="line-modified">2147           token = G_TOKEN_IDENTIFIER;</span>
<span class="line-removed">2148           gstring = g_string_new (NULL);</span>
2149           gstring = g_string_append_c (gstring, ch);
<span class="line-modified">2150           do</span>
<span class="line-removed">2151             {</span>
<span class="line-removed">2152               ch = g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-removed">2153               gstring = g_string_append_c (gstring, ch);</span>
<span class="line-removed">2154               ch = g_scanner_peek_next_char (scanner);</span>
<span class="line-removed">2155             }</span>
<span class="line-removed">2156           while (ch &amp;&amp; strchr (config-&gt;cset_identifier_nth, ch));</span>
<span class="line-removed">2157           ch = 0;</span>
<span class="line-removed">2158         }</span>
<span class="line-removed">2159           else if (config-&gt;scan_identifier_1char)</span>
<span class="line-removed">2160         {</span>
<span class="line-removed">2161           token = G_TOKEN_IDENTIFIER;</span>
<span class="line-removed">2162           value.v_identifier = g_new0 (gchar, 2);</span>
<span class="line-removed">2163           value.v_identifier[0] = ch;</span>
<span class="line-removed">2164           ch = 0;</span>
<span class="line-removed">2165         }</span>
<span class="line-removed">2166         }</span>
<span class="line-removed">2167       if (ch)</span>
<span class="line-removed">2168         {</span>
<span class="line-removed">2169           if (config-&gt;char_2_token)</span>
<span class="line-removed">2170         token = ch;</span>
<span class="line-removed">2171           else</span>
<span class="line-removed">2172         {</span>
<span class="line-removed">2173           token = G_TOKEN_CHAR;</span>
<span class="line-removed">2174           value.v_char = ch;</span>
<span class="line-removed">2175         }</span>
<span class="line-removed">2176           ch = 0;</span>
2177         }
<span class="line-modified">2178     } /* default_case:... */</span>
<span class="line-modified">2179     break;</span>

















2180     }





2181       g_assert (ch == 0 &amp;&amp; token != G_TOKEN_NONE); /* paranoid */
2182     }
2183   while (ch != 0);
2184 
2185   if (in_comment_multi || in_comment_single ||
2186       in_string_sq || in_string_dq)
2187     {
2188       token = G_TOKEN_ERROR;
2189       if (gstring)
<span class="line-modified">2190     {</span>
<span class="line-modified">2191       g_string_free (gstring, TRUE);</span>
<span class="line-modified">2192       gstring = NULL;</span>
<span class="line-modified">2193     }</span>
2194       (*position_p)++;
2195       if (in_comment_multi || in_comment_single)
<span class="line-modified">2196     value.v_error = G_ERR_UNEXP_EOF_IN_COMMENT;</span>
2197       else /* (in_string_sq || in_string_dq) */
<span class="line-modified">2198     value.v_error = G_ERR_UNEXP_EOF_IN_STRING;</span>
2199     }
2200 
2201   if (gstring)
2202     {
2203       value.v_string = g_string_free (gstring, FALSE);
2204       gstring = NULL;
2205     }
2206 
2207   if (token == G_TOKEN_IDENTIFIER)
2208     {
2209       if (config-&gt;scan_symbols)
<span class="line-modified">2210     {</span>
<span class="line-modified">2211       GScannerKey *key;</span>
<span class="line-modified">2212       guint scope_id;</span>
<span class="line-modified">2213 </span>
<span class="line-modified">2214       scope_id = scanner-&gt;scope_id;</span>
<span class="line-modified">2215       key = g_scanner_lookup_internal (scanner, scope_id, value.v_identifier);</span>
<span class="line-modified">2216       if (!key &amp;&amp; scope_id &amp;&amp; scanner-&gt;config-&gt;scope_0_fallback)</span>
<span class="line-modified">2217         key = g_scanner_lookup_internal (scanner, 0, value.v_identifier);</span>
<span class="line-modified">2218 </span>
<span class="line-modified">2219       if (key)</span>
<span class="line-modified">2220         {</span>
<span class="line-modified">2221           g_free (value.v_identifier);</span>
<span class="line-modified">2222           token = G_TOKEN_SYMBOL;</span>
<span class="line-modified">2223           value.v_symbol = key-&gt;value;</span>
<span class="line-modified">2224         }</span>
<span class="line-modified">2225     }</span>
2226 
2227       if (token == G_TOKEN_IDENTIFIER &amp;&amp;
<span class="line-modified">2228       config-&gt;scan_identifier_NULL &amp;&amp;</span>
<span class="line-modified">2229       strlen (value.v_identifier) == 4)</span>
<span class="line-modified">2230     {</span>
<span class="line-modified">2231       gchar *null_upper = &quot;NULL&quot;;</span>
<span class="line-modified">2232       gchar *null_lower = &quot;null&quot;;</span>
<span class="line-modified">2233 </span>
<span class="line-modified">2234       if (scanner-&gt;config-&gt;case_sensitive)</span>
<span class="line-modified">2235         {</span>
<span class="line-modified">2236           if (value.v_identifier[0] == null_upper[0] &amp;&amp;</span>
<span class="line-modified">2237           value.v_identifier[1] == null_upper[1] &amp;&amp;</span>
<span class="line-modified">2238           value.v_identifier[2] == null_upper[2] &amp;&amp;</span>
<span class="line-modified">2239           value.v_identifier[3] == null_upper[3])</span>
<span class="line-modified">2240         token = G_TOKEN_IDENTIFIER_NULL;</span>
<span class="line-modified">2241         }</span>
<span class="line-modified">2242       else</span>
<span class="line-modified">2243         {</span>
<span class="line-modified">2244           if ((value.v_identifier[0] == null_upper[0] ||</span>
<span class="line-modified">2245            value.v_identifier[0] == null_lower[0]) &amp;&amp;</span>
<span class="line-modified">2246           (value.v_identifier[1] == null_upper[1] ||</span>
<span class="line-modified">2247            value.v_identifier[1] == null_lower[1]) &amp;&amp;</span>
<span class="line-modified">2248           (value.v_identifier[2] == null_upper[2] ||</span>
<span class="line-modified">2249            value.v_identifier[2] == null_lower[2]) &amp;&amp;</span>
<span class="line-modified">2250           (value.v_identifier[3] == null_upper[3] ||</span>
<span class="line-modified">2251            value.v_identifier[3] == null_lower[3]))</span>
<span class="line-modified">2252         token = G_TOKEN_IDENTIFIER_NULL;</span>
<span class="line-modified">2253         }</span>
<span class="line-modified">2254     }</span>
2255     }
2256 
2257   *token_p = token;
2258   *value_p = value;
2259 }
</pre>
</td>
<td>
<hr />
<pre>
 258  * @numbers_2_int: specifies if binary, octal and hexadecimal numbers
 259  *     are reported as #G_TOKEN_INT (the default is %TRUE).
 260  * @int_2_float: specifies if all numbers are reported as %G_TOKEN_FLOAT
 261  *     (the default is %FALSE).
 262  * @identifier_2_string: specifies if identifiers are reported as strings
 263  *     (the default is %FALSE).
 264  * @char_2_token: specifies if characters are reported by setting
 265  *     `token = ch` or as %G_TOKEN_CHAR (the default is %TRUE).
 266  * @symbol_2_token: specifies if symbols are reported by setting
 267  *     `token = v_symbol` or as %G_TOKEN_SYMBOL (the default is %FALSE).
 268  * @scope_0_fallback: specifies if a symbol is searched for in the
 269  *     default scope in addition to the current scope (the default is %FALSE).
 270  * @store_int64: use value.v_int64 rather than v_int
 271  *
 272  * Specifies the #GScanner parser configuration. Most settings can
 273  * be changed during the parsing phase and will affect the lexical
 274  * parsing of the next unpeeked token.
 275  */
 276 
 277 /* --- defines --- */
<span class="line-modified"> 278 #define to_lower(c)       ( \</span>
<span class="line-modified"> 279   (guchar) (              \</span>
<span class="line-modified"> 280     ( (((guchar)(c))&gt;=&#39;A&#39; &amp;&amp; ((guchar)(c))&lt;=&#39;Z&#39;) * (&#39;a&#39;-&#39;A&#39;) ) |  \</span>
<span class="line-modified"> 281     ( (((guchar)(c))&gt;=192 &amp;&amp; ((guchar)(c))&lt;=214) * (224-192) ) |  \</span>
<span class="line-modified"> 282     ( (((guchar)(c))&gt;=216 &amp;&amp; ((guchar)(c))&lt;=222) * (248-216) ) |  \</span>
<span class="line-modified"> 283     ((guchar)(c))             \</span>
<span class="line-modified"> 284   )               \</span>
 285 )
<span class="line-modified"> 286 #define READ_BUFFER_SIZE  (4000)</span>
 287 
 288 
 289 /* --- typedefs --- */
<span class="line-modified"> 290 typedef struct  _GScannerKey  GScannerKey;</span>
 291 
 292 struct  _GScannerKey
 293 {
<span class="line-modified"> 294   guint    scope_id;</span>
<span class="line-modified"> 295   gchar   *symbol;</span>
 296   gpointer   value;
 297 };
 298 
 299 
 300 /* --- variables --- */
 301 static const GScannerConfig g_scanner_config_template =
 302 {
 303   (
 304    &quot; \t\r\n&quot;
<span class="line-modified"> 305    )      /* cset_skip_characters */,</span>
 306   (
 307    G_CSET_a_2_z
 308    &quot;_&quot;
 309    G_CSET_A_2_Z
<span class="line-modified"> 310    )      /* cset_identifier_first */,</span>
 311   (
 312    G_CSET_a_2_z
 313    &quot;_&quot;
 314    G_CSET_A_2_Z
 315    G_CSET_DIGITS
 316    G_CSET_LATINS
 317    G_CSET_LATINC
<span class="line-modified"> 318    )      /* cset_identifier_nth */,</span>
<span class="line-modified"> 319   ( &quot;#\n&quot; )   /* cpair_comment_single */,</span>
<span class="line-modified"> 320 </span>
<span class="line-modified"> 321   FALSE     /* case_sensitive */,</span>
<span class="line-modified"> 322 </span>
<span class="line-modified"> 323   TRUE      /* skip_comment_multi */,</span>
<span class="line-modified"> 324   TRUE      /* skip_comment_single */,</span>
<span class="line-modified"> 325   TRUE      /* scan_comment_multi */,</span>
<span class="line-modified"> 326   TRUE      /* scan_identifier */,</span>
<span class="line-modified"> 327   FALSE     /* scan_identifier_1char */,</span>
<span class="line-modified"> 328   FALSE     /* scan_identifier_NULL */,</span>
<span class="line-modified"> 329   TRUE      /* scan_symbols */,</span>
<span class="line-modified"> 330   FALSE     /* scan_binary */,</span>
<span class="line-modified"> 331   TRUE      /* scan_octal */,</span>
<span class="line-modified"> 332   TRUE      /* scan_float */,</span>
<span class="line-modified"> 333   TRUE      /* scan_hex */,</span>
<span class="line-modified"> 334   FALSE     /* scan_hex_dollar */,</span>
<span class="line-modified"> 335   TRUE      /* scan_string_sq */,</span>
<span class="line-modified"> 336   TRUE      /* scan_string_dq */,</span>
<span class="line-modified"> 337   TRUE      /* numbers_2_int */,</span>
<span class="line-modified"> 338   FALSE     /* int_2_float */,</span>
<span class="line-modified"> 339   FALSE     /* identifier_2_string */,</span>
<span class="line-modified"> 340   TRUE      /* char_2_token */,</span>
<span class="line-modified"> 341   FALSE     /* symbol_2_token */,</span>
<span class="line-modified"> 342   FALSE     /* scope_0_fallback */,</span>
<span class="line-modified"> 343   FALSE     /* store_int64 */,</span>
<span class="line-added"> 344   0         /* padding_dummy */</span>
 345 };
 346 
 347 
 348 /* --- prototypes --- */
 349 static inline
<span class="line-modified"> 350 GScannerKey*  g_scanner_lookup_internal (GScanner *scanner,</span>
<span class="line-modified"> 351              guint   scope_id,</span>
<span class="line-modified"> 352              const gchar  *symbol);</span>
 353 static gboolean g_scanner_key_equal   (gconstpointer v1,
<span class="line-modified"> 354              gconstpointer v2);</span>
<span class="line-modified"> 355 static guint  g_scanner_key_hash    (gconstpointer v);</span>
 356 static void g_scanner_get_token_ll    (GScanner *scanner,
<span class="line-modified"> 357              GTokenType *token_p,</span>
<span class="line-modified"> 358              GTokenValue  *value_p,</span>
<span class="line-modified"> 359              guint  *line_p,</span>
<span class="line-modified"> 360              guint  *position_p);</span>
<span class="line-modified"> 361 static void g_scanner_get_token_i   (GScanner *scanner,</span>
<span class="line-modified"> 362              GTokenType *token_p,</span>
<span class="line-modified"> 363              GTokenValue  *value_p,</span>
<span class="line-modified"> 364              guint  *line_p,</span>
<span class="line-modified"> 365              guint  *position_p);</span>
<span class="line-modified"> 366 </span>
<span class="line-modified"> 367 static guchar g_scanner_peek_next_char  (GScanner *scanner);</span>
<span class="line-modified"> 368 static guchar g_scanner_get_char    (GScanner *scanner,</span>
<span class="line-modified"> 369              guint  *line_p,</span>
<span class="line-modified"> 370              guint  *position_p);</span>
<span class="line-modified"> 371 static void g_scanner_msg_handler   (GScanner *scanner,</span>
<span class="line-modified"> 372              gchar  *message,</span>
<span class="line-modified"> 373              gboolean  is_error);</span>
 374 
 375 
 376 /* --- functions --- */
 377 static inline gint
<span class="line-modified"> 378 g_scanner_char_2_num (guchar  c,</span>
<span class="line-modified"> 379           guchar  base)</span>
 380 {
 381   if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;)
 382     c -= &#39;0&#39;;
 383   else if (c &gt;= &#39;A&#39; &amp;&amp; c &lt;= &#39;Z&#39;)
 384     c -= &#39;A&#39; - 10;
 385   else if (c &gt;= &#39;a&#39; &amp;&amp; c &lt;= &#39;z&#39;)
 386     c -= &#39;a&#39; - 10;
 387   else
 388     return -1;
 389 
 390   if (c &lt; base)
 391     return c;
 392 
 393   return -1;
 394 }
 395 
 396 /**
 397  * g_scanner_new:
 398  * @config_templ: the initial scanner settings
 399  *
</pre>
<hr />
<pre>
 407  * Returns: the new #GScanner
 408  */
 409 GScanner *
 410 g_scanner_new (const GScannerConfig *config_templ)
 411 {
 412   GScanner *scanner;
 413 
 414   if (!config_templ)
 415     config_templ = &amp;g_scanner_config_template;
 416 
 417   scanner = g_new0 (GScanner, 1);
 418 
 419   scanner-&gt;user_data = NULL;
 420   scanner-&gt;max_parse_errors = 1;
 421   scanner-&gt;parse_errors = 0;
 422   scanner-&gt;input_name = NULL;
 423   g_datalist_init (&amp;scanner-&gt;qdata);
 424 
 425   scanner-&gt;config = g_new0 (GScannerConfig, 1);
 426 
<span class="line-modified"> 427   scanner-&gt;config-&gt;case_sensitive  = config_templ-&gt;case_sensitive;</span>
 428   scanner-&gt;config-&gt;cset_skip_characters  = config_templ-&gt;cset_skip_characters;
 429   if (!scanner-&gt;config-&gt;cset_skip_characters)
 430     scanner-&gt;config-&gt;cset_skip_characters = &quot;&quot;;
 431   scanner-&gt;config-&gt;cset_identifier_first = config_templ-&gt;cset_identifier_first;
 432   scanner-&gt;config-&gt;cset_identifier_nth   = config_templ-&gt;cset_identifier_nth;
 433   scanner-&gt;config-&gt;cpair_comment_single  = config_templ-&gt;cpair_comment_single;
<span class="line-modified"> 434   scanner-&gt;config-&gt;skip_comment_multi  = config_templ-&gt;skip_comment_multi;</span>
 435   scanner-&gt;config-&gt;skip_comment_single   = config_templ-&gt;skip_comment_single;
<span class="line-modified"> 436   scanner-&gt;config-&gt;scan_comment_multi  = config_templ-&gt;scan_comment_multi;</span>
 437   scanner-&gt;config-&gt;scan_identifier   = config_templ-&gt;scan_identifier;
 438   scanner-&gt;config-&gt;scan_identifier_1char = config_templ-&gt;scan_identifier_1char;
 439   scanner-&gt;config-&gt;scan_identifier_NULL  = config_templ-&gt;scan_identifier_NULL;
<span class="line-modified"> 440   scanner-&gt;config-&gt;scan_symbols    = config_templ-&gt;scan_symbols;</span>
<span class="line-modified"> 441   scanner-&gt;config-&gt;scan_binary     = config_templ-&gt;scan_binary;</span>
<span class="line-modified"> 442   scanner-&gt;config-&gt;scan_octal    = config_templ-&gt;scan_octal;</span>
<span class="line-modified"> 443   scanner-&gt;config-&gt;scan_float    = config_templ-&gt;scan_float;</span>
<span class="line-modified"> 444   scanner-&gt;config-&gt;scan_hex    = config_templ-&gt;scan_hex;</span>
 445   scanner-&gt;config-&gt;scan_hex_dollar   = config_templ-&gt;scan_hex_dollar;
<span class="line-modified"> 446   scanner-&gt;config-&gt;scan_string_sq  = config_templ-&gt;scan_string_sq;</span>
<span class="line-modified"> 447   scanner-&gt;config-&gt;scan_string_dq  = config_templ-&gt;scan_string_dq;</span>
<span class="line-modified"> 448   scanner-&gt;config-&gt;numbers_2_int   = config_templ-&gt;numbers_2_int;</span>
<span class="line-modified"> 449   scanner-&gt;config-&gt;int_2_float     = config_templ-&gt;int_2_float;</span>
 450   scanner-&gt;config-&gt;identifier_2_string   = config_templ-&gt;identifier_2_string;
<span class="line-modified"> 451   scanner-&gt;config-&gt;char_2_token    = config_templ-&gt;char_2_token;</span>
<span class="line-modified"> 452   scanner-&gt;config-&gt;symbol_2_token  = config_templ-&gt;symbol_2_token;</span>
 453   scanner-&gt;config-&gt;scope_0_fallback  = config_templ-&gt;scope_0_fallback;
<span class="line-modified"> 454   scanner-&gt;config-&gt;store_int64     = config_templ-&gt;store_int64;</span>
 455 
 456   scanner-&gt;token = G_TOKEN_NONE;
 457   scanner-&gt;value.v_int64 = 0;
 458   scanner-&gt;line = 1;
 459   scanner-&gt;position = 0;
 460 
 461   scanner-&gt;next_token = G_TOKEN_NONE;
 462   scanner-&gt;next_value.v_int64 = 0;
 463   scanner-&gt;next_line = 1;
 464   scanner-&gt;next_position = 0;
 465 
 466   scanner-&gt;symbol_table = g_hash_table_new (g_scanner_key_hash, g_scanner_key_equal);
 467   scanner-&gt;input_fd = -1;
 468   scanner-&gt;text = NULL;
 469   scanner-&gt;text_end = NULL;
 470   scanner-&gt;buffer = NULL;
 471   scanner-&gt;scope_id = 0;
 472 
 473   scanner-&gt;msg_handler = g_scanner_msg_handler;
 474 
 475   return scanner;
 476 }
 477 
 478 static inline void
 479 g_scanner_free_value (GTokenType     *token_p,
<span class="line-modified"> 480           GTokenValue     *value_p)</span>
 481 {
 482   switch (*token_p)
 483     {
 484     case G_TOKEN_STRING:
 485     case G_TOKEN_IDENTIFIER:
 486     case G_TOKEN_IDENTIFIER_NULL:
 487     case G_TOKEN_COMMENT_SINGLE:
 488     case G_TOKEN_COMMENT_MULTI:
 489       g_free (value_p-&gt;v_string);
 490       break;
 491 
 492     default:
 493       break;
 494     }
 495 
 496   *token_p = G_TOKEN_NONE;
 497 }
 498 
 499 static void
 500 g_scanner_destroy_symbol_table_entry (gpointer _key,
<span class="line-modified"> 501               gpointer _value,</span>
<span class="line-modified"> 502               gpointer _data)</span>
 503 {
 504   GScannerKey *key = _key;
 505 
 506   g_free (key-&gt;symbol);
 507   g_free (key);
 508 }
 509 
 510 /**
 511  * g_scanner_destroy:
 512  * @scanner: a #GScanner
 513  *
 514  * Frees all memory used by the #GScanner.
 515  */
 516 void
 517 g_scanner_destroy (GScanner *scanner)
 518 {
 519   g_return_if_fail (scanner != NULL);
 520 
 521   g_datalist_clear (&amp;scanner-&gt;qdata);
 522   g_hash_table_foreach (scanner-&gt;symbol_table,
<span class="line-modified"> 523       g_scanner_destroy_symbol_table_entry, NULL);</span>
 524   g_hash_table_destroy (scanner-&gt;symbol_table);
 525   g_scanner_free_value (&amp;scanner-&gt;token, &amp;scanner-&gt;value);
 526   g_scanner_free_value (&amp;scanner-&gt;next_token, &amp;scanner-&gt;next_value);
 527   g_free (scanner-&gt;config);
 528   g_free (scanner-&gt;buffer);
 529   g_free (scanner);
 530 }
 531 
 532 static void
<span class="line-modified"> 533 g_scanner_msg_handler (GScanner   *scanner,</span>
<span class="line-modified"> 534            gchar    *message,</span>
<span class="line-modified"> 535            gboolean   is_error)</span>
 536 {
 537   g_return_if_fail (scanner != NULL);
 538 
 539   _g_fprintf (stderr, &quot;%s:%d: &quot;,
<span class="line-modified"> 540         scanner-&gt;input_name ? scanner-&gt;input_name : &quot;&lt;memory&gt;&quot;,</span>
<span class="line-modified"> 541         scanner-&gt;line);</span>
 542   if (is_error)
 543     _g_fprintf (stderr, &quot;error: &quot;);
 544   _g_fprintf (stderr, &quot;%s\n&quot;, message);
 545 }
 546 
 547 /**
 548  * g_scanner_error:
 549  * @scanner: a #GScanner
 550  * @format: the message format. See the printf() documentation
 551  * @...: the parameters to insert into the format string
 552  *
 553  * Outputs an error message, via the #GScanner message handler.
 554  */
 555 void
<span class="line-modified"> 556 g_scanner_error (GScanner *scanner,</span>
<span class="line-modified"> 557      const gchar  *format,</span>
<span class="line-modified"> 558      ...)</span>
 559 {
 560   g_return_if_fail (scanner != NULL);
 561   g_return_if_fail (format != NULL);
 562 
 563   scanner-&gt;parse_errors++;
 564 
 565   if (scanner-&gt;msg_handler)
 566     {
 567       va_list args;
 568       gchar *string;
 569 
 570       va_start (args, format);
 571       string = g_strdup_vprintf (format, args);
 572       va_end (args);
 573 
 574       scanner-&gt;msg_handler (scanner, string, TRUE);
 575 
 576       g_free (string);
 577     }
 578 }
 579 
 580 /**
 581  * g_scanner_warn:
 582  * @scanner: a #GScanner
 583  * @format: the message format. See the printf() documentation
 584  * @...: the parameters to insert into the format string
 585  *
 586  * Outputs a warning message, via the #GScanner message handler.
 587  */
 588 void
 589 g_scanner_warn (GScanner       *scanner,
<span class="line-modified"> 590     const gchar    *format,</span>
<span class="line-modified"> 591     ...)</span>
 592 {
 593   g_return_if_fail (scanner != NULL);
 594   g_return_if_fail (format != NULL);
 595 
 596   if (scanner-&gt;msg_handler)
 597     {
 598       va_list args;
 599       gchar *string;
 600 
 601       va_start (args, format);
 602       string = g_strdup_vprintf (format, args);
 603       va_end (args);
 604 
 605       scanner-&gt;msg_handler (scanner, string, FALSE);
 606 
 607       g_free (string);
 608     }
 609 }
 610 
 611 static gboolean
 612 g_scanner_key_equal (gconstpointer v1,
<span class="line-modified"> 613          gconstpointer v2)</span>
 614 {
 615   const GScannerKey *key1 = v1;
 616   const GScannerKey *key2 = v2;
 617 
 618   return (key1-&gt;scope_id == key2-&gt;scope_id) &amp;&amp; (strcmp (key1-&gt;symbol, key2-&gt;symbol) == 0);
 619 }
 620 
 621 static guint
 622 g_scanner_key_hash (gconstpointer v)
 623 {
 624   const GScannerKey *key = v;
 625   gchar *c;
 626   guint h;
 627 
 628   h = key-&gt;scope_id;
 629   for (c = key-&gt;symbol; *c; c++)
 630     h = (h &lt;&lt; 5) - h + *c;
 631 
 632   return h;
 633 }
 634 
 635 static inline GScannerKey*
 636 g_scanner_lookup_internal (GScanner *scanner,
<span class="line-modified"> 637          guint   scope_id,</span>
<span class="line-modified"> 638          const gchar  *symbol)</span>
 639 {
<span class="line-modified"> 640   GScannerKey *key_p;</span>
 641   GScannerKey key;
 642 
 643   key.scope_id = scope_id;
 644 
 645   if (!scanner-&gt;config-&gt;case_sensitive)
 646     {
 647       gchar *d;
 648       const gchar *c;
 649 
 650       key.symbol = g_new (gchar, strlen (symbol) + 1);
 651       for (d = key.symbol, c = symbol; *c; c++, d++)
<span class="line-modified"> 652   *d = to_lower (*c);</span>
 653       *d = 0;
 654       key_p = g_hash_table_lookup (scanner-&gt;symbol_table, &amp;key);
 655       g_free (key.symbol);
 656     }
 657   else
 658     {
 659       key.symbol = (gchar*) symbol;
 660       key_p = g_hash_table_lookup (scanner-&gt;symbol_table, &amp;key);
 661     }
 662 
 663   return key_p;
 664 }
 665 
 666 /**
 667  * g_scanner_add_symbol:
 668  * @scanner: a #GScanner
 669  * @symbol: the symbol to add
 670  * @value: the value of the symbol
 671  *
 672  * Adds a symbol to the default scope.
 673  *
 674  * Deprecated: 2.2: Use g_scanner_scope_add_symbol() instead.
 675  */
 676 
 677 /**
 678  * g_scanner_scope_add_symbol:
 679  * @scanner: a #GScanner
 680  * @scope_id: the scope id
 681  * @symbol: the symbol to add
 682  * @value: the value of the symbol
 683  *
 684  * Adds a symbol to the given scope.
 685  */
 686 void
<span class="line-modified"> 687 g_scanner_scope_add_symbol (GScanner  *scanner,</span>
<span class="line-modified"> 688           guint  scope_id,</span>
<span class="line-modified"> 689           const gchar *symbol,</span>
<span class="line-modified"> 690           gpointer   value)</span>
 691 {
<span class="line-modified"> 692   GScannerKey *key;</span>
 693 
 694   g_return_if_fail (scanner != NULL);
 695   g_return_if_fail (symbol != NULL);
 696 
 697   key = g_scanner_lookup_internal (scanner, scope_id, symbol);
 698 
 699   if (!key)
 700     {
 701       key = g_new (GScannerKey, 1);
 702       key-&gt;scope_id = scope_id;
 703       key-&gt;symbol = g_strdup (symbol);
 704       key-&gt;value = value;
 705       if (!scanner-&gt;config-&gt;case_sensitive)
<span class="line-modified"> 706   {</span>
<span class="line-modified"> 707     gchar *c;</span>
<span class="line-modified"> 708 </span>
<span class="line-modified"> 709     c = key-&gt;symbol;</span>
<span class="line-modified"> 710     while (*c != 0)</span>
<span class="line-modified"> 711       {</span>
<span class="line-modified"> 712         *c = to_lower (*c);</span>
<span class="line-modified"> 713         c++;</span>
<span class="line-modified"> 714       }</span>
<span class="line-modified"> 715   }</span>
 716       g_hash_table_add (scanner-&gt;symbol_table, key);
 717     }
 718   else
 719     key-&gt;value = value;
 720 }
 721 
 722 /**
 723  * g_scanner_remove_symbol:
 724  * @scanner: a #GScanner
 725  * @symbol: the symbol to remove
 726  *
 727  * Removes a symbol from the default scope.
 728  *
 729  * Deprecated: 2.2: Use g_scanner_scope_remove_symbol() instead.
 730  */
 731 
 732 /**
 733  * g_scanner_scope_remove_symbol:
 734  * @scanner: a #GScanner
 735  * @scope_id: the scope id
 736  * @symbol: the symbol to remove
 737  *
 738  * Removes a symbol from a scope.
 739  */
 740 void
 741 g_scanner_scope_remove_symbol (GScanner    *scanner,
<span class="line-modified"> 742              guint      scope_id,</span>
<span class="line-modified"> 743              const gchar *symbol)</span>
 744 {
<span class="line-modified"> 745   GScannerKey *key;</span>
 746 
 747   g_return_if_fail (scanner != NULL);
 748   g_return_if_fail (symbol != NULL);
 749 
 750   key = g_scanner_lookup_internal (scanner, scope_id, symbol);
 751 
 752   if (key)
 753     {
 754       g_hash_table_remove (scanner-&gt;symbol_table, key);
 755       g_free (key-&gt;symbol);
 756       g_free (key);
 757     }
 758 }
 759 
 760 /**
 761  * g_scanner_freeze_symbol_table:
 762  * @scanner: a #GScanner
 763  *
 764  * There is no reason to use this macro, since it does nothing.
 765  *
</pre>
<hr />
<pre>
 771  * @scanner: a #GScanner
 772  *
 773  * There is no reason to use this macro, since it does nothing.
 774  *
 775  * Deprecated: 2.2: This macro does nothing.
 776  */
 777 
 778 /**
 779  * g_scanner_lookup_symbol:
 780  * @scanner: a #GScanner
 781  * @symbol: the symbol to look up
 782  *
 783  * Looks up a symbol in the current scope and return its value.
 784  * If the symbol is not bound in the current scope, %NULL is
 785  * returned.
 786  *
 787  * Returns: the value of @symbol in the current scope, or %NULL
 788  *     if @symbol is not bound in the current scope
 789  */
 790 gpointer
<span class="line-modified"> 791 g_scanner_lookup_symbol (GScanner *scanner,</span>
<span class="line-modified"> 792        const gchar  *symbol)</span>
 793 {
<span class="line-modified"> 794   GScannerKey *key;</span>
 795   guint scope_id;
 796 
 797   g_return_val_if_fail (scanner != NULL, NULL);
 798 
 799   if (!symbol)
 800     return NULL;
 801 
 802   scope_id = scanner-&gt;scope_id;
 803   key = g_scanner_lookup_internal (scanner, scope_id, symbol);
 804   if (!key &amp;&amp; scope_id &amp;&amp; scanner-&gt;config-&gt;scope_0_fallback)
 805     key = g_scanner_lookup_internal (scanner, 0, symbol);
 806 
 807   if (key)
 808     return key-&gt;value;
 809   else
 810     return NULL;
 811 }
 812 
 813 /**
 814  * g_scanner_scope_lookup_symbol:
 815  * @scanner: a #GScanner
 816  * @scope_id: the scope id
 817  * @symbol: the symbol to look up
 818  *
 819  * Looks up a symbol in a scope and return its value. If the
 820  * symbol is not bound in the scope, %NULL is returned.
 821  *
 822  * Returns: the value of @symbol in the given scope, or %NULL
 823  *     if @symbol is not bound in the given scope.
 824  *
 825  */
 826 gpointer
 827 g_scanner_scope_lookup_symbol (GScanner       *scanner,
<span class="line-modified"> 828              guint         scope_id,</span>
<span class="line-modified"> 829              const gchar    *symbol)</span>
 830 {
<span class="line-modified"> 831   GScannerKey *key;</span>
 832 
 833   g_return_val_if_fail (scanner != NULL, NULL);
 834 
 835   if (!symbol)
 836     return NULL;
 837 
 838   key = g_scanner_lookup_internal (scanner, scope_id, symbol);
 839 
 840   if (key)
 841     return key-&gt;value;
 842   else
 843     return NULL;
 844 }
 845 
 846 /**
 847  * g_scanner_set_scope:
 848  * @scanner: a #GScanner
 849  * @scope_id: the new scope id
 850  *
 851  * Sets the current scope.
 852  *
 853  * Returns: the old scope id
 854  */
 855 guint
<span class="line-modified"> 856 g_scanner_set_scope (GScanner     *scanner,</span>
<span class="line-modified"> 857          guint       scope_id)</span>
 858 {
 859   guint old_scope_id;
 860 
 861   g_return_val_if_fail (scanner != NULL, 0);
 862 
 863   old_scope_id = scanner-&gt;scope_id;
 864   scanner-&gt;scope_id = scope_id;
 865 
 866   return old_scope_id;
 867 }
 868 
 869 static void
 870 g_scanner_foreach_internal (gpointer  _key,
<span class="line-modified"> 871           gpointer  _value,</span>
<span class="line-modified"> 872           gpointer  _user_data)</span>
 873 {
 874   GScannerKey *key;
 875   gpointer *d;
 876   GHFunc func;
 877   gpointer user_data;
 878   guint *scope_id;
 879 
 880   d = _user_data;
 881   func = (GHFunc) d[0];
 882   user_data = d[1];
 883   scope_id = d[2];
 884   key = _value;
 885 
 886   if (key-&gt;scope_id == *scope_id)
 887     func (key-&gt;symbol, key-&gt;value, user_data);
 888 }
 889 
 890 /**
 891  * g_scanner_foreach_symbol:
 892  * @scanner: a #GScanner
</pre>
<hr />
<pre>
 895  *
 896  * Calls a function for each symbol in the default scope.
 897  *
 898  * Deprecated: 2.2: Use g_scanner_scope_foreach_symbol() instead.
 899  */
 900 
 901 /**
 902  * g_scanner_scope_foreach_symbol:
 903  * @scanner: a #GScanner
 904  * @scope_id: the scope id
 905  * @func: the function to call for each symbol/value pair
 906  * @user_data: user data to pass to the function
 907  *
 908  * Calls the given function for each of the symbol/value pairs
 909  * in the given scope of the #GScanner. The function is passed
 910  * the symbol and value of each pair, and the given @user_data
 911  * parameter.
 912  */
 913 void
 914 g_scanner_scope_foreach_symbol (GScanner       *scanner,
<span class="line-modified"> 915         guint   scope_id,</span>
<span class="line-modified"> 916         GHFunc    func,</span>
<span class="line-modified"> 917         gpointer  user_data)</span>
 918 {
 919   gpointer d[3];
 920 
 921   g_return_if_fail (scanner != NULL);
 922 
 923   d[0] = (gpointer) func;
 924   d[1] = user_data;
 925   d[2] = &amp;scope_id;
 926 
 927   g_hash_table_foreach (scanner-&gt;symbol_table, g_scanner_foreach_internal, d);
 928 }
 929 
 930 /**
 931  * g_scanner_peek_next_token:
 932  * @scanner: a #GScanner
 933  *
 934  * Parses the next token, without removing it from the input stream.
 935  * The token data is placed in the @next_token, @next_value, @next_line,
 936  * and @next_position fields of the #GScanner structure.
 937  *
 938  * Note that, while the token is not removed from the input stream
 939  * (i.e. the next call to g_scanner_get_next_token() will return the
 940  * same token), it will not be reevaluated. This can lead to surprising
 941  * results when changing scope or the scanner configuration after peeking
 942  * the next token. Getting the next token after switching the scope or
 943  * configuration will return whatever was peeked before, regardless of
 944  * any symbols that may have been added or removed in the new scope.
 945  *
 946  * Returns: the type of the token
 947  */
 948 GTokenType
 949 g_scanner_peek_next_token (GScanner *scanner)
 950 {
 951   g_return_val_if_fail (scanner != NULL, G_TOKEN_EOF);
 952 
 953   if (scanner-&gt;next_token == G_TOKEN_NONE)
 954     {
 955       scanner-&gt;next_line = scanner-&gt;line;
 956       scanner-&gt;next_position = scanner-&gt;position;
 957       g_scanner_get_token_i (scanner,
<span class="line-modified"> 958            &amp;scanner-&gt;next_token,</span>
<span class="line-modified"> 959            &amp;scanner-&gt;next_value,</span>
<span class="line-modified"> 960            &amp;scanner-&gt;next_line,</span>
<span class="line-modified"> 961            &amp;scanner-&gt;next_position);</span>
 962     }
 963 
 964   return scanner-&gt;next_token;
 965 }
 966 
 967 /**
 968  * g_scanner_get_next_token:
 969  * @scanner: a #GScanner
 970  *
 971  * Parses the next token just like g_scanner_peek_next_token()
 972  * and also removes it from the input stream. The token data is
 973  * placed in the @token, @value, @line, and @position fields of
 974  * the #GScanner structure.
 975  *
 976  * Returns: the type of the token
 977  */
 978 GTokenType
 979 g_scanner_get_next_token (GScanner  *scanner)
 980 {
 981   g_return_val_if_fail (scanner != NULL, G_TOKEN_EOF);
 982 
 983   if (scanner-&gt;next_token != G_TOKEN_NONE)
 984     {
 985       g_scanner_free_value (&amp;scanner-&gt;token, &amp;scanner-&gt;value);
 986 
 987       scanner-&gt;token = scanner-&gt;next_token;
 988       scanner-&gt;value = scanner-&gt;next_value;
 989       scanner-&gt;line = scanner-&gt;next_line;
 990       scanner-&gt;position = scanner-&gt;next_position;
 991       scanner-&gt;next_token = G_TOKEN_NONE;
 992     }
 993   else
 994     g_scanner_get_token_i (scanner,
<span class="line-modified"> 995          &amp;scanner-&gt;token,</span>
<span class="line-modified"> 996          &amp;scanner-&gt;value,</span>
<span class="line-modified"> 997          &amp;scanner-&gt;line,</span>
<span class="line-modified"> 998          &amp;scanner-&gt;position);</span>
 999 
1000   return scanner-&gt;token;
1001 }
1002 
1003 /**
1004  * g_scanner_cur_token:
1005  * @scanner: a #GScanner
1006  *
1007  * Gets the current token type. This is simply the @token
1008  * field in the #GScanner structure.
1009  *
1010  * Returns: the current token type
1011  */
1012 GTokenType
1013 g_scanner_cur_token (GScanner *scanner)
1014 {
1015   g_return_val_if_fail (scanner != NULL, G_TOKEN_EOF);
1016 
1017   return scanner-&gt;token;
1018 }
</pre>
<hr />
<pre>
1088  * Returns: %TRUE if the scanner has reached the end of
1089  *     the file or text buffer
1090  */
1091 gboolean
1092 g_scanner_eof (GScanner *scanner)
1093 {
1094   g_return_val_if_fail (scanner != NULL, TRUE);
1095 
1096   return scanner-&gt;token == G_TOKEN_EOF || scanner-&gt;token == G_TOKEN_ERROR;
1097 }
1098 
1099 /**
1100  * g_scanner_input_file:
1101  * @scanner: a #GScanner
1102  * @input_fd: a file descriptor
1103  *
1104  * Prepares to scan a file.
1105  */
1106 void
1107 g_scanner_input_file (GScanner *scanner,
<span class="line-modified">1108           gint  input_fd)</span>
1109 {
1110   g_return_if_fail (scanner != NULL);
1111   g_return_if_fail (input_fd &gt;= 0);
1112 
1113   if (scanner-&gt;input_fd &gt;= 0)
1114     g_scanner_sync_file_offset (scanner);
1115 
1116   scanner-&gt;token = G_TOKEN_NONE;
1117   scanner-&gt;value.v_int64 = 0;
1118   scanner-&gt;line = 1;
1119   scanner-&gt;position = 0;
1120   scanner-&gt;next_token = G_TOKEN_NONE;
1121 
1122   scanner-&gt;input_fd = input_fd;
1123   scanner-&gt;text = NULL;
1124   scanner-&gt;text_end = NULL;
1125 
1126   if (!scanner-&gt;buffer)
1127     scanner-&gt;buffer = g_new (gchar, READ_BUFFER_SIZE + 1);
1128 }
1129 
1130 /**
1131  * g_scanner_input_text:
1132  * @scanner: a #GScanner
1133  * @text: the text buffer to scan
1134  * @text_len: the length of the text buffer
1135  *
1136  * Prepares to scan a text buffer.
1137  */
1138 void
1139 g_scanner_input_text (GScanner    *scanner,
<span class="line-modified">1140           const gchar *text,</span>
<span class="line-modified">1141           guint    text_len)</span>
1142 {
1143   g_return_if_fail (scanner != NULL);
1144   if (text_len)
1145     g_return_if_fail (text != NULL);
1146   else
1147     text = NULL;
1148 
1149   if (scanner-&gt;input_fd &gt;= 0)
1150     g_scanner_sync_file_offset (scanner);
1151 
1152   scanner-&gt;token = G_TOKEN_NONE;
1153   scanner-&gt;value.v_int64 = 0;
1154   scanner-&gt;line = 1;
1155   scanner-&gt;position = 0;
1156   scanner-&gt;next_token = G_TOKEN_NONE;
1157 
1158   scanner-&gt;input_fd = -1;
1159   scanner-&gt;text = text;
1160   scanner-&gt;text_end = text + text_len;
1161 
</pre>
<hr />
<pre>
1163     {
1164       g_free (scanner-&gt;buffer);
1165       scanner-&gt;buffer = NULL;
1166     }
1167 }
1168 
1169 static guchar
1170 g_scanner_peek_next_char (GScanner *scanner)
1171 {
1172   if (scanner-&gt;text &lt; scanner-&gt;text_end)
1173     {
1174       return *scanner-&gt;text;
1175     }
1176   else if (scanner-&gt;input_fd &gt;= 0)
1177     {
1178       gint count;
1179       gchar *buffer;
1180 
1181       buffer = scanner-&gt;buffer;
1182       do
<span class="line-modified">1183   {</span>
<span class="line-modified">1184     count = read (scanner-&gt;input_fd, buffer, READ_BUFFER_SIZE);</span>
<span class="line-modified">1185   }</span>
1186       while (count == -1 &amp;&amp; (errno == EINTR || errno == EAGAIN));
1187 
1188       if (count &lt; 1)
<span class="line-modified">1189   {</span>
<span class="line-modified">1190     scanner-&gt;input_fd = -1;</span>
1191 
<span class="line-modified">1192     return 0;</span>
<span class="line-modified">1193   }</span>
1194       else
<span class="line-modified">1195   {</span>
<span class="line-modified">1196     scanner-&gt;text = buffer;</span>
<span class="line-modified">1197     scanner-&gt;text_end = buffer + count;</span>
1198 
<span class="line-modified">1199     return *buffer;</span>
<span class="line-modified">1200   }</span>
1201     }
1202   else
1203     return 0;
1204 }
1205 
1206 /**
1207  * g_scanner_sync_file_offset:
1208  * @scanner: a #GScanner
1209  *
1210  * Rewinds the filedescriptor to the current buffer position
1211  * and blows the file read ahead buffer. This is useful for
1212  * third party uses of the scanners filedescriptor, which hooks
1213  * onto the current scanning position.
1214  */
1215 void
1216 g_scanner_sync_file_offset (GScanner *scanner)
1217 {
1218   g_return_if_fail (scanner != NULL);
1219 
1220   /* for file input, rewind the filedescriptor to the current
1221    * buffer position and blow the file read ahead buffer. useful
1222    * for third party uses of our file descriptor, which hooks
1223    * onto the current scanning position.
1224    */
1225 
1226   if (scanner-&gt;input_fd &gt;= 0 &amp;&amp; scanner-&gt;text_end &gt; scanner-&gt;text)
1227     {
1228       gint buffered;
1229 
1230       buffered = scanner-&gt;text_end - scanner-&gt;text;
1231       if (lseek (scanner-&gt;input_fd, - buffered, SEEK_CUR) &gt;= 0)
<span class="line-modified">1232   {</span>
<span class="line-modified">1233     /* we succeeded, blow our buffer&#39;s contents now */</span>
<span class="line-modified">1234     scanner-&gt;text = NULL;</span>
<span class="line-modified">1235     scanner-&gt;text_end = NULL;</span>
<span class="line-modified">1236   }</span>
1237       else
<span class="line-modified">1238   errno = 0;</span>
1239     }
1240 }
1241 
1242 static guchar
<span class="line-modified">1243 g_scanner_get_char (GScanner  *scanner,</span>
<span class="line-modified">1244         guint *line_p,</span>
<span class="line-modified">1245         guint *position_p)</span>
1246 {
1247   guchar fchar;
1248 
1249   if (scanner-&gt;text &lt; scanner-&gt;text_end)
1250     fchar = *(scanner-&gt;text++);
1251   else if (scanner-&gt;input_fd &gt;= 0)
1252     {
1253       gint count;
1254       gchar *buffer;
1255 
1256       buffer = scanner-&gt;buffer;
1257       do
<span class="line-modified">1258   {</span>
<span class="line-modified">1259     count = read (scanner-&gt;input_fd, buffer, READ_BUFFER_SIZE);</span>
<span class="line-modified">1260   }</span>
1261       while (count == -1 &amp;&amp; (errno == EINTR || errno == EAGAIN));
1262 
1263       if (count &lt; 1)
<span class="line-modified">1264   {</span>
<span class="line-modified">1265     scanner-&gt;input_fd = -1;</span>
<span class="line-modified">1266     fchar = 0;</span>
<span class="line-modified">1267   }</span>
1268       else
<span class="line-modified">1269   {</span>
<span class="line-modified">1270     scanner-&gt;text = buffer + 1;</span>
<span class="line-modified">1271     scanner-&gt;text_end = buffer + count;</span>
<span class="line-modified">1272     fchar = *buffer;</span>
<span class="line-modified">1273     if (!fchar)</span>
<span class="line-modified">1274       {</span>
<span class="line-modified">1275         g_scanner_sync_file_offset (scanner);</span>
<span class="line-modified">1276         scanner-&gt;text_end = scanner-&gt;text;</span>
<span class="line-modified">1277         scanner-&gt;input_fd = -1;</span>
<span class="line-modified">1278       }</span>
<span class="line-modified">1279   }</span>
1280     }
1281   else
1282     fchar = 0;
1283 
1284   if (fchar == &#39;\n&#39;)
1285     {
1286       (*position_p) = 0;
1287       (*line_p)++;
1288     }
1289   else if (fchar)
1290     {
1291       (*position_p)++;
1292     }
1293 
1294   return fchar;
1295 }
1296 
1297 /**
1298  * g_scanner_unexp_token:
1299  * @scanner: a #GScanner
</pre>
<hr />
<pre>
1305  * @symbol_spec: a string describing how the scanner&#39;s user refers
1306  *     to symbols (%NULL defaults to &quot;symbol&quot;). This is used if
1307  *     @expected_token is %G_TOKEN_SYMBOL or any token value greater
1308  *     than %G_TOKEN_LAST.
1309  * @symbol_name: the name of the symbol, if the scanner&#39;s current
1310  *     token is a symbol.
1311  * @message: a message string to output at the end of the
1312  *     warning/error, or %NULL.
1313  * @is_error: if %TRUE it is output as an error. If %FALSE it is
1314  *     output as a warning.
1315  *
1316  * Outputs a message through the scanner&#39;s msg_handler,
1317  * resulting from an unexpected token in the input stream.
1318  * Note that you should not call g_scanner_peek_next_token()
1319  * followed by g_scanner_unexp_token() without an intermediate
1320  * call to g_scanner_get_next_token(), as g_scanner_unexp_token()
1321  * evaluates the scanner&#39;s current token (not the peeked token)
1322  * to construct part of the message.
1323  */
1324 void
<span class="line-modified">1325 g_scanner_unexp_token (GScanner   *scanner,</span>
<span class="line-modified">1326            GTokenType  expected_token,</span>
<span class="line-modified">1327            const gchar  *identifier_spec,</span>
<span class="line-modified">1328            const gchar  *symbol_spec,</span>
<span class="line-modified">1329            const gchar  *symbol_name,</span>
<span class="line-modified">1330            const gchar  *message,</span>
<span class="line-modified">1331            gint    is_error)</span>
1332 {
1333   gchar *token_string;
1334   guint token_string_len;
1335   gchar *expected_string;
1336   guint expected_string_len;
1337   gchar *message_prefix;
1338   gboolean print_unexp;
<span class="line-modified">1339   void (*msg_handler) (GScanner*, const gchar*, ...);</span>
1340 
1341   g_return_if_fail (scanner != NULL);
1342 
1343   if (is_error)
1344     msg_handler = g_scanner_error;
1345   else
1346     msg_handler = g_scanner_warn;
1347 
1348   if (!identifier_spec)
1349     identifier_spec = &quot;identifier&quot;;
1350   if (!symbol_spec)
1351     symbol_spec = &quot;symbol&quot;;
1352 
1353   token_string_len = 56;
1354   token_string = g_new (gchar, token_string_len + 1);
1355   expected_string_len = 64;
1356   expected_string = g_new (gchar, expected_string_len + 1);
1357   print_unexp = TRUE;
1358 
1359   switch (scanner-&gt;token)
1360     {
1361     case G_TOKEN_EOF:
1362       _g_snprintf (token_string, token_string_len, &quot;end of file&quot;);
1363       break;
1364 
1365     default:
1366       if (scanner-&gt;token &gt;= 1 &amp;&amp; scanner-&gt;token &lt;= 255)
<span class="line-modified">1367   {</span>
<span class="line-modified">1368     if ((scanner-&gt;token &gt;= &#39; &#39; &amp;&amp; scanner-&gt;token &lt;= &#39;~&#39;) ||</span>
<span class="line-modified">1369         strchr (scanner-&gt;config-&gt;cset_identifier_first, scanner-&gt;token) ||</span>
<span class="line-modified">1370         strchr (scanner-&gt;config-&gt;cset_identifier_nth, scanner-&gt;token))</span>
<span class="line-modified">1371       _g_snprintf (token_string, token_string_len, &quot;character &#39;%c&#39;&quot;, scanner-&gt;token);</span>
<span class="line-modified">1372     else</span>
<span class="line-modified">1373       _g_snprintf (token_string, token_string_len, &quot;character &#39;\\%o&#39;&quot;, scanner-&gt;token);</span>
<span class="line-modified">1374     break;</span>
<span class="line-modified">1375   }</span>
1376       else if (!scanner-&gt;config-&gt;symbol_2_token)
<span class="line-modified">1377   {</span>
<span class="line-modified">1378     _g_snprintf (token_string, token_string_len, &quot;(unknown) token &lt;%d&gt;&quot;, scanner-&gt;token);</span>
<span class="line-modified">1379     break;</span>
<span class="line-modified">1380   }</span>
1381       /* fall through */
1382     case G_TOKEN_SYMBOL:
1383       if (expected_token == G_TOKEN_SYMBOL ||
<span class="line-modified">1384     (scanner-&gt;config-&gt;symbol_2_token &amp;&amp;</span>
<span class="line-modified">1385      expected_token &gt; G_TOKEN_LAST))</span>
<span class="line-modified">1386   print_unexp = FALSE;</span>
1387       if (symbol_name)
<span class="line-modified">1388   _g_snprintf (token_string,</span>
<span class="line-modified">1389          token_string_len,</span>
<span class="line-modified">1390          &quot;%s%s &#39;%s&#39;&quot;,</span>
<span class="line-modified">1391          print_unexp ? &quot;&quot; : &quot;invalid &quot;,</span>
<span class="line-modified">1392          symbol_spec,</span>
<span class="line-modified">1393          symbol_name);</span>
1394       else
<span class="line-modified">1395   _g_snprintf (token_string,</span>
<span class="line-modified">1396          token_string_len,</span>
<span class="line-modified">1397          &quot;%s%s&quot;,</span>
<span class="line-modified">1398          print_unexp ? &quot;&quot; : &quot;invalid &quot;,</span>
<span class="line-modified">1399          symbol_spec);</span>
1400       break;
1401 
1402     case G_TOKEN_ERROR:
1403       print_unexp = FALSE;
1404       expected_token = G_TOKEN_NONE;
1405       switch (scanner-&gt;value.v_error)
<span class="line-modified">1406   {</span>
<span class="line-modified">1407   case G_ERR_UNEXP_EOF:</span>
<span class="line-modified">1408     _g_snprintf (token_string, token_string_len, &quot;scanner: unexpected end of file&quot;);</span>
<span class="line-modified">1409     break;</span>
1410 
<span class="line-modified">1411   case G_ERR_UNEXP_EOF_IN_STRING:</span>
<span class="line-modified">1412     _g_snprintf (token_string, token_string_len, &quot;scanner: unterminated string constant&quot;);</span>
<span class="line-modified">1413     break;</span>
1414 
<span class="line-modified">1415   case G_ERR_UNEXP_EOF_IN_COMMENT:</span>
<span class="line-modified">1416     _g_snprintf (token_string, token_string_len, &quot;scanner: unterminated comment&quot;);</span>
<span class="line-modified">1417     break;</span>
1418 
<span class="line-modified">1419   case G_ERR_NON_DIGIT_IN_CONST:</span>
<span class="line-modified">1420     _g_snprintf (token_string, token_string_len, &quot;scanner: non digit in constant&quot;);</span>
<span class="line-modified">1421     break;</span>
1422 
<span class="line-modified">1423   case G_ERR_FLOAT_RADIX:</span>
<span class="line-modified">1424     _g_snprintf (token_string, token_string_len, &quot;scanner: invalid radix for floating constant&quot;);</span>
<span class="line-modified">1425     break;</span>
1426 
<span class="line-modified">1427   case G_ERR_FLOAT_MALFORMED:</span>
<span class="line-modified">1428     _g_snprintf (token_string, token_string_len, &quot;scanner: malformed floating constant&quot;);</span>
<span class="line-modified">1429     break;</span>
1430 
<span class="line-modified">1431   case G_ERR_DIGIT_RADIX:</span>
<span class="line-modified">1432     _g_snprintf (token_string, token_string_len, &quot;scanner: digit is beyond radix&quot;);</span>
<span class="line-modified">1433     break;</span>
1434 
<span class="line-modified">1435   case G_ERR_UNKNOWN:</span>
<span class="line-modified">1436   default:</span>
<span class="line-modified">1437     _g_snprintf (token_string, token_string_len, &quot;scanner: unknown error&quot;);</span>
<span class="line-modified">1438     break;</span>
<span class="line-modified">1439   }</span>
1440       break;
1441 
1442     case G_TOKEN_CHAR:
1443       _g_snprintf (token_string, token_string_len, &quot;character &#39;%c&#39;&quot;, scanner-&gt;value.v_char);
1444       break;
1445 
1446     case G_TOKEN_IDENTIFIER:
1447     case G_TOKEN_IDENTIFIER_NULL:
1448       if (expected_token == G_TOKEN_IDENTIFIER ||
<span class="line-modified">1449     expected_token == G_TOKEN_IDENTIFIER_NULL)</span>
<span class="line-modified">1450   print_unexp = FALSE;</span>
1451       _g_snprintf (token_string,
<span class="line-modified">1452       token_string_len,</span>
<span class="line-modified">1453       &quot;%s%s &#39;%s&#39;&quot;,</span>
<span class="line-modified">1454       print_unexp ? &quot;&quot; : &quot;invalid &quot;,</span>
<span class="line-modified">1455       identifier_spec,</span>
<span class="line-modified">1456       scanner-&gt;token == G_TOKEN_IDENTIFIER ? scanner-&gt;value.v_string : &quot;null&quot;);</span>
1457       break;
1458 
1459     case G_TOKEN_BINARY:
1460     case G_TOKEN_OCTAL:
1461     case G_TOKEN_INT:
1462     case G_TOKEN_HEX:
1463       if (scanner-&gt;config-&gt;store_int64)
<span class="line-modified">1464   _g_snprintf (token_string, token_string_len, &quot;number &#39;%&quot; G_GUINT64_FORMAT &quot;&#39;&quot;, scanner-&gt;value.v_int64);</span>
1465       else
<span class="line-modified">1466   _g_snprintf (token_string, token_string_len, &quot;number &#39;%lu&#39;&quot;, scanner-&gt;value.v_int);</span>
1467       break;
1468 
1469     case G_TOKEN_FLOAT:
1470       _g_snprintf (token_string, token_string_len, &quot;number &#39;%.3f&#39;&quot;, scanner-&gt;value.v_float);
1471       break;
1472 
1473     case G_TOKEN_STRING:
1474       if (expected_token == G_TOKEN_STRING)
<span class="line-modified">1475   print_unexp = FALSE;</span>
1476       _g_snprintf (token_string,
<span class="line-modified">1477        token_string_len,</span>
<span class="line-modified">1478        &quot;%s%sstring constant \&quot;%s\&quot;&quot;,</span>
<span class="line-modified">1479        print_unexp ? &quot;&quot; : &quot;invalid &quot;,</span>
<span class="line-modified">1480        scanner-&gt;value.v_string[0] == 0 ? &quot;empty &quot; : &quot;&quot;,</span>
<span class="line-modified">1481        scanner-&gt;value.v_string);</span>
1482       token_string[token_string_len - 2] = &#39;&quot;&#39;;
1483       token_string[token_string_len - 1] = 0;
1484       break;
1485 
1486     case G_TOKEN_COMMENT_SINGLE:
1487     case G_TOKEN_COMMENT_MULTI:
1488       _g_snprintf (token_string, token_string_len, &quot;comment&quot;);
1489       break;
1490 
1491     case G_TOKEN_NONE:
1492       /* somehow the user&#39;s parsing code is screwed, there isn&#39;t much
1493        * we can do about it.
1494        * Note, a common case to trigger this is
1495        * g_scanner_peek_next_token(); g_scanner_unexp_token();
1496        * without an intermediate g_scanner_get_next_token().
1497        */
1498       g_assert_not_reached ();
1499       break;
1500     }
1501 
1502 
1503   switch (expected_token)
1504     {
1505       gboolean need_valid;
1506       gchar *tstring;
1507     case G_TOKEN_EOF:
1508       _g_snprintf (expected_string, expected_string_len, &quot;end of file&quot;);
1509       break;
1510     default:
1511       if (expected_token &gt;= 1 &amp;&amp; expected_token &lt;= 255)
<span class="line-modified">1512   {</span>
<span class="line-modified">1513     if ((expected_token &gt;= &#39; &#39; &amp;&amp; expected_token &lt;= &#39;~&#39;) ||</span>
<span class="line-modified">1514         strchr (scanner-&gt;config-&gt;cset_identifier_first, expected_token) ||</span>
<span class="line-modified">1515         strchr (scanner-&gt;config-&gt;cset_identifier_nth, expected_token))</span>
<span class="line-modified">1516       _g_snprintf (expected_string, expected_string_len, &quot;character &#39;%c&#39;&quot;, expected_token);</span>
<span class="line-modified">1517     else</span>
<span class="line-modified">1518       _g_snprintf (expected_string, expected_string_len, &quot;character &#39;\\%o&#39;&quot;, expected_token);</span>
<span class="line-modified">1519     break;</span>
<span class="line-modified">1520   }</span>
1521       else if (!scanner-&gt;config-&gt;symbol_2_token)
<span class="line-modified">1522   {</span>
<span class="line-modified">1523     _g_snprintf (expected_string, expected_string_len, &quot;(unknown) token &lt;%d&gt;&quot;, expected_token);</span>
<span class="line-modified">1524     break;</span>
<span class="line-modified">1525   }</span>
1526       /* fall through */
1527     case G_TOKEN_SYMBOL:
1528       need_valid = (scanner-&gt;token == G_TOKEN_SYMBOL ||
<span class="line-modified">1529         (scanner-&gt;config-&gt;symbol_2_token &amp;&amp;</span>
<span class="line-modified">1530          scanner-&gt;token &gt; G_TOKEN_LAST));</span>
1531       _g_snprintf (expected_string,
<span class="line-modified">1532        expected_string_len,</span>
<span class="line-modified">1533        &quot;%s%s&quot;,</span>
<span class="line-modified">1534        need_valid ? &quot;valid &quot; : &quot;&quot;,</span>
<span class="line-modified">1535        symbol_spec);</span>
<span class="line-modified">1536       /* FIXME: should we attempt to look up the symbol_name for symbol_2_token? */</span>
1537       break;
1538     case G_TOKEN_CHAR:
1539       _g_snprintf (expected_string, expected_string_len, &quot;%scharacter&quot;,
<span class="line-modified">1540        scanner-&gt;token == G_TOKEN_CHAR ? &quot;valid &quot; : &quot;&quot;);</span>
1541       break;
1542     case G_TOKEN_BINARY:
1543       tstring = &quot;binary&quot;;
1544       _g_snprintf (expected_string, expected_string_len, &quot;%snumber (%s)&quot;,
<span class="line-modified">1545        scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);</span>
1546       break;
1547     case G_TOKEN_OCTAL:
1548       tstring = &quot;octal&quot;;
1549       _g_snprintf (expected_string, expected_string_len, &quot;%snumber (%s)&quot;,
<span class="line-modified">1550        scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);</span>
1551       break;
1552     case G_TOKEN_INT:
1553       tstring = &quot;integer&quot;;
1554       _g_snprintf (expected_string, expected_string_len, &quot;%snumber (%s)&quot;,
<span class="line-modified">1555        scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);</span>
1556       break;
1557     case G_TOKEN_HEX:
1558       tstring = &quot;hexadecimal&quot;;
1559       _g_snprintf (expected_string, expected_string_len, &quot;%snumber (%s)&quot;,
<span class="line-modified">1560        scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);</span>
1561       break;
1562     case G_TOKEN_FLOAT:
1563       tstring = &quot;float&quot;;
1564       _g_snprintf (expected_string, expected_string_len, &quot;%snumber (%s)&quot;,
<span class="line-modified">1565        scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);</span>
1566       break;
1567     case G_TOKEN_STRING:
1568       _g_snprintf (expected_string,
<span class="line-modified">1569        expected_string_len,</span>
<span class="line-modified">1570        &quot;%sstring constant&quot;,</span>
<span class="line-modified">1571        scanner-&gt;token == G_TOKEN_STRING ? &quot;valid &quot; : &quot;&quot;);</span>
1572       break;
1573     case G_TOKEN_IDENTIFIER:
1574     case G_TOKEN_IDENTIFIER_NULL:
1575       need_valid = (scanner-&gt;token == G_TOKEN_IDENTIFIER_NULL ||
<span class="line-modified">1576         scanner-&gt;token == G_TOKEN_IDENTIFIER);</span>
1577       _g_snprintf (expected_string,
<span class="line-modified">1578        expected_string_len,</span>
<span class="line-modified">1579        &quot;%s%s&quot;,</span>
<span class="line-modified">1580        need_valid ? &quot;valid &quot; : &quot;&quot;,</span>
<span class="line-modified">1581        identifier_spec);</span>
1582       break;
1583     case G_TOKEN_COMMENT_SINGLE:
1584       tstring = &quot;single-line&quot;;
1585       _g_snprintf (expected_string, expected_string_len, &quot;%scomment (%s)&quot;,
<span class="line-modified">1586        scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);</span>
1587       break;
1588     case G_TOKEN_COMMENT_MULTI:
1589       tstring = &quot;multi-line&quot;;
1590       _g_snprintf (expected_string, expected_string_len, &quot;%scomment (%s)&quot;,
<span class="line-modified">1591        scanner-&gt;token == expected_token ? &quot;valid &quot; : &quot;&quot;, tstring);</span>
1592       break;
1593     case G_TOKEN_NONE:
1594     case G_TOKEN_ERROR:
1595       /* this is handled upon printout */
1596       break;
1597     }
1598 
1599   if (message &amp;&amp; message[0] != 0)
1600     message_prefix = &quot; - &quot;;
1601   else
1602     {
1603       message_prefix = &quot;&quot;;
1604       message = &quot;&quot;;
1605     }
1606   if (expected_token == G_TOKEN_ERROR)
1607     {
1608       msg_handler (scanner,
<span class="line-modified">1609        &quot;failure around %s%s%s&quot;,</span>
<span class="line-modified">1610        token_string,</span>
<span class="line-modified">1611        message_prefix,</span>
<span class="line-modified">1612        message);</span>
1613     }
1614   else if (expected_token == G_TOKEN_NONE)
1615     {
1616       if (print_unexp)
<span class="line-modified">1617   msg_handler (scanner,</span>
<span class="line-modified">1618          &quot;unexpected %s%s%s&quot;,</span>
<span class="line-modified">1619          token_string,</span>
<span class="line-modified">1620          message_prefix,</span>
<span class="line-modified">1621          message);</span>
1622       else
<span class="line-modified">1623   msg_handler (scanner,</span>
<span class="line-modified">1624          &quot;%s%s%s&quot;,</span>
<span class="line-modified">1625          token_string,</span>
<span class="line-modified">1626          message_prefix,</span>
<span class="line-modified">1627          message);</span>
1628     }
1629   else
1630     {
1631       if (print_unexp)
<span class="line-modified">1632   msg_handler (scanner,</span>
<span class="line-modified">1633          &quot;unexpected %s, expected %s%s%s&quot;,</span>
<span class="line-modified">1634          token_string,</span>
<span class="line-modified">1635          expected_string,</span>
<span class="line-modified">1636          message_prefix,</span>
<span class="line-modified">1637          message);</span>
1638       else
<span class="line-modified">1639   msg_handler (scanner,</span>
<span class="line-modified">1640          &quot;%s, expected %s%s%s&quot;,</span>
<span class="line-modified">1641          token_string,</span>
<span class="line-modified">1642          expected_string,</span>
<span class="line-modified">1643          message_prefix,</span>
<span class="line-modified">1644          message);</span>
1645     }
1646 
1647   g_free (token_string);
1648   g_free (expected_string);
1649 }
1650 
1651 static void
1652 g_scanner_get_token_i (GScanner *scanner,
<span class="line-modified">1653            GTokenType *token_p,</span>
<span class="line-modified">1654            GTokenValue  *value_p,</span>
<span class="line-modified">1655            guint    *line_p,</span>
<span class="line-modified">1656            guint    *position_p)</span>
1657 {
1658   do
1659     {
1660       g_scanner_free_value (token_p, value_p);
1661       g_scanner_get_token_ll (scanner, token_p, value_p, line_p, position_p);
1662     }
1663   while (((*token_p &gt; 0 &amp;&amp; *token_p &lt; 256) &amp;&amp;
<span class="line-modified">1664     strchr (scanner-&gt;config-&gt;cset_skip_characters, *token_p)) ||</span>
<span class="line-modified">1665    (*token_p == G_TOKEN_CHAR &amp;&amp;</span>
<span class="line-modified">1666     strchr (scanner-&gt;config-&gt;cset_skip_characters, value_p-&gt;v_char)) ||</span>
<span class="line-modified">1667    (*token_p == G_TOKEN_COMMENT_MULTI &amp;&amp;</span>
<span class="line-modified">1668     scanner-&gt;config-&gt;skip_comment_multi) ||</span>
<span class="line-modified">1669    (*token_p == G_TOKEN_COMMENT_SINGLE &amp;&amp;</span>
<span class="line-modified">1670     scanner-&gt;config-&gt;skip_comment_single));</span>
1671 
1672   switch (*token_p)
1673     {
1674     case G_TOKEN_IDENTIFIER:
1675       if (scanner-&gt;config-&gt;identifier_2_string)
<span class="line-modified">1676   *token_p = G_TOKEN_STRING;</span>
1677       break;
1678 
1679     case G_TOKEN_SYMBOL:
1680       if (scanner-&gt;config-&gt;symbol_2_token)
<span class="line-modified">1681   *token_p = (GTokenType) value_p-&gt;v_symbol;</span>
1682       break;
1683 
1684     case G_TOKEN_BINARY:
1685     case G_TOKEN_OCTAL:
1686     case G_TOKEN_HEX:
1687       if (scanner-&gt;config-&gt;numbers_2_int)
<span class="line-modified">1688   *token_p = G_TOKEN_INT;</span>
1689       break;
1690 
1691     default:
1692       break;
1693     }
1694 
1695   if (*token_p == G_TOKEN_INT &amp;&amp;
1696       scanner-&gt;config-&gt;int_2_float)
1697     {
1698       *token_p = G_TOKEN_FLOAT;
1699       if (scanner-&gt;config-&gt;store_int64)
1700         {
1701           value_p-&gt;v_float = value_p-&gt;v_int64;
1702         }
1703       else
<span class="line-modified">1704   value_p-&gt;v_float = value_p-&gt;v_int;</span>
1705     }
1706 
1707   errno = 0;
1708 }
1709 
1710 static void
<span class="line-modified">1711 g_scanner_get_token_ll  (GScanner *scanner,</span>
<span class="line-modified">1712        GTokenType *token_p,</span>
<span class="line-modified">1713        GTokenValue  *value_p,</span>
<span class="line-modified">1714        guint    *line_p,</span>
<span class="line-modified">1715        guint    *position_p)</span>
1716 {
1717   GScannerConfig *config;
<span class="line-modified">1718   GTokenType     token;</span>
1719   gboolean     in_comment_multi;
1720   gboolean     in_comment_single;
1721   gboolean     in_string_sq;
1722   gboolean     in_string_dq;
<span class="line-modified">1723   GString   *gstring;</span>
<span class="line-modified">1724   GTokenValue    value;</span>
<span class="line-modified">1725   guchar     ch;</span>
1726 
1727   config = scanner-&gt;config;
1728   (*value_p).v_int64 = 0;
1729 
1730   if ((scanner-&gt;text &gt;= scanner-&gt;text_end &amp;&amp; scanner-&gt;input_fd &lt; 0) ||
1731       scanner-&gt;token == G_TOKEN_EOF)
1732     {
1733       *token_p = G_TOKEN_EOF;
1734       return;
1735     }
1736 
1737   in_comment_multi = FALSE;
1738   in_comment_single = FALSE;
1739   in_string_sq = FALSE;
1740   in_string_dq = FALSE;
1741   gstring = NULL;
1742 
1743   do /* while (ch != 0) */
1744     {
1745       gboolean dotted_float = FALSE;
1746 
1747       ch = g_scanner_get_char (scanner, line_p, position_p);
1748 
1749       value.v_int64 = 0;
1750       token = G_TOKEN_NONE;
1751 
1752       /* this is *evil*, but needed ;(
1753        * we first check for identifier first character, because  it
1754        * might interfere with other key chars like slashes or numbers
1755        */
1756       if (config-&gt;scan_identifier &amp;&amp;
<span class="line-modified">1757     ch &amp;&amp; strchr (config-&gt;cset_identifier_first, ch))</span>
<span class="line-modified">1758   goto identifier_precedence;</span>
1759 
1760       switch (ch)
<span class="line-modified">1761   {</span>
<span class="line-modified">1762   case 0:</span>
<span class="line-modified">1763     token = G_TOKEN_EOF;</span>
<span class="line-modified">1764     (*position_p)++;</span>
<span class="line-modified">1765     /* ch = 0; */</span>
<span class="line-modified">1766     break;</span>
1767 
<span class="line-modified">1768   case &#39;/&#39;:</span>
<span class="line-modified">1769     if (!config-&gt;scan_comment_multi ||</span>
<span class="line-modified">1770         g_scanner_peek_next_char (scanner) != &#39;*&#39;)</span>
<span class="line-modified">1771       goto default_case;</span>
<span class="line-added">1772     g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-added">1773     token = G_TOKEN_COMMENT_MULTI;</span>
<span class="line-added">1774     in_comment_multi = TRUE;</span>
<span class="line-added">1775     gstring = g_string_new (NULL);</span>
<span class="line-added">1776     while ((ch = g_scanner_get_char (scanner, line_p, position_p)) != 0)</span>
<span class="line-added">1777       {</span>
<span class="line-added">1778         if (ch == &#39;*&#39; &amp;&amp; g_scanner_peek_next_char (scanner) == &#39;/&#39;)</span>
<span class="line-added">1779     {</span>
1780       g_scanner_get_char (scanner, line_p, position_p);
<span class="line-modified">1781       in_comment_multi = FALSE;</span>














1782       break;
<span class="line-added">1783     }</span>
<span class="line-added">1784         else</span>
<span class="line-added">1785     gstring = g_string_append_c (gstring, ch);</span>
<span class="line-added">1786       }</span>
<span class="line-added">1787     ch = 0;</span>
<span class="line-added">1788     break;</span>
1789 
<span class="line-modified">1790   case &#39;\&#39;&#39;:</span>
<span class="line-modified">1791     if (!config-&gt;scan_string_sq)</span>
<span class="line-modified">1792       goto default_case;</span>
<span class="line-modified">1793     token = G_TOKEN_STRING;</span>
<span class="line-modified">1794     in_string_sq = TRUE;</span>
<span class="line-modified">1795     gstring = g_string_new (NULL);</span>
<span class="line-modified">1796     while ((ch = g_scanner_get_char (scanner, line_p, position_p)) != 0)</span>
<span class="line-modified">1797       {</span>
<span class="line-modified">1798         if (ch == &#39;\&#39;&#39;)</span>
<span class="line-modified">1799     {</span>
<span class="line-modified">1800       in_string_sq = FALSE;</span>






1801       break;
<span class="line-added">1802     }</span>
<span class="line-added">1803         else</span>
<span class="line-added">1804     gstring = g_string_append_c (gstring, ch);</span>
<span class="line-added">1805       }</span>
<span class="line-added">1806     ch = 0;</span>
<span class="line-added">1807     break;</span>
1808 
<span class="line-modified">1809   case &#39;&quot;&#39;:</span>
<span class="line-modified">1810     if (!config-&gt;scan_string_dq)</span>
<span class="line-modified">1811       goto default_case;</span>
<span class="line-modified">1812     token = G_TOKEN_STRING;</span>
<span class="line-modified">1813     in_string_dq = TRUE;</span>
<span class="line-modified">1814     gstring = g_string_new (NULL);</span>
<span class="line-modified">1815     while ((ch = g_scanner_get_char (scanner, line_p, position_p)) != 0)</span>
<span class="line-modified">1816       {</span>
<span class="line-modified">1817         if (ch == &#39;&quot;&#39;)</span>
<span class="line-modified">1818     {</span>
<span class="line-modified">1819       in_string_dq = FALSE;</span>









































































1820       break;
<span class="line-modified">1821     }</span>
<span class="line-modified">1822         else</span>
<span class="line-modified">1823     {</span>
<span class="line-modified">1824       if (ch == &#39;\\&#39;)</span>



















1825         {


1826           ch = g_scanner_get_char (scanner, line_p, position_p);
<span class="line-modified">1827           switch (ch)</span>
<span class="line-modified">1828       {</span>
<span class="line-modified">1829         guint i;</span>
<span class="line-modified">1830         guint fchar;</span>
<span class="line-modified">1831 </span>
<span class="line-modified">1832       case 0:</span>
<span class="line-modified">1833         break;</span>
<span class="line-modified">1834 </span>
<span class="line-modified">1835       case &#39;\\&#39;:</span>
<span class="line-modified">1836         gstring = g_string_append_c (gstring, &#39;\\&#39;);</span>
<span class="line-modified">1837         break;</span>
<span class="line-modified">1838 </span>
<span class="line-modified">1839       case &#39;n&#39;:</span>
<span class="line-modified">1840         gstring = g_string_append_c (gstring, &#39;\n&#39;);</span>
<span class="line-modified">1841         break;</span>
<span class="line-modified">1842 </span>
<span class="line-added">1843       case &#39;t&#39;:</span>
<span class="line-added">1844         gstring = g_string_append_c (gstring, &#39;\t&#39;);</span>
<span class="line-added">1845         break;</span>
<span class="line-added">1846 </span>
<span class="line-added">1847       case &#39;r&#39;:</span>
<span class="line-added">1848         gstring = g_string_append_c (gstring, &#39;\r&#39;);</span>
<span class="line-added">1849         break;</span>
<span class="line-added">1850 </span>
<span class="line-added">1851       case &#39;b&#39;:</span>
<span class="line-added">1852         gstring = g_string_append_c (gstring, &#39;\b&#39;);</span>
<span class="line-added">1853         break;</span>
<span class="line-added">1854 </span>
<span class="line-added">1855       case &#39;f&#39;:</span>
<span class="line-added">1856         gstring = g_string_append_c (gstring, &#39;\f&#39;);</span>
<span class="line-added">1857         break;</span>
<span class="line-added">1858 </span>
<span class="line-added">1859       case &#39;0&#39;:</span>
<span class="line-added">1860       case &#39;1&#39;:</span>
<span class="line-added">1861       case &#39;2&#39;:</span>
<span class="line-added">1862       case &#39;3&#39;:</span>
<span class="line-added">1863       case &#39;4&#39;:</span>
<span class="line-added">1864       case &#39;5&#39;:</span>
<span class="line-added">1865       case &#39;6&#39;:</span>
<span class="line-added">1866       case &#39;7&#39;:</span>
<span class="line-added">1867         i = ch - &#39;0&#39;;</span>
<span class="line-added">1868         fchar = g_scanner_peek_next_char (scanner);</span>
<span class="line-added">1869         if (fchar &gt;= &#39;0&#39; &amp;&amp; fchar &lt;= &#39;7&#39;)</span>
<span class="line-added">1870           {</span>
<span class="line-added">1871             ch = g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-added">1872             i = i * 8 + ch - &#39;0&#39;;</span>
<span class="line-added">1873             fchar = g_scanner_peek_next_char (scanner);</span>
<span class="line-added">1874             if (fchar &gt;= &#39;0&#39; &amp;&amp; fchar &lt;= &#39;7&#39;)</span>
1875         {


1876           ch = g_scanner_get_char (scanner, line_p, position_p);
<span class="line-modified">1877           i = i * 8 + ch - &#39;0&#39;;</span>












1878         }
<span class="line-added">1879           }</span>
<span class="line-added">1880         gstring = g_string_append_c (gstring, i);</span>
<span class="line-added">1881         break;</span>
<span class="line-added">1882 </span>
<span class="line-added">1883       default:</span>
<span class="line-added">1884         gstring = g_string_append_c (gstring, ch);</span>
<span class="line-added">1885         break;</span>
<span class="line-added">1886       }</span>
1887         }
1888       else
<span class="line-modified">1889         gstring = g_string_append_c (gstring, ch);</span>
<span class="line-modified">1890     }</span>
<span class="line-modified">1891       }</span>
<span class="line-modified">1892     ch = 0;</span>
<span class="line-modified">1893     break;</span>
<span class="line-modified">1894 </span>
<span class="line-modified">1895   case &#39;.&#39;:</span>
<span class="line-modified">1896     if (!config-&gt;scan_float)</span>
<span class="line-modified">1897       goto default_case;</span>
<span class="line-modified">1898     token = G_TOKEN_FLOAT;</span>
<span class="line-modified">1899     dotted_float = TRUE;</span>
<span class="line-modified">1900     ch = g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-added">1901     goto number_parsing;</span>
<span class="line-added">1902 </span>
<span class="line-added">1903   case &#39;$&#39;:</span>
<span class="line-added">1904     if (!config-&gt;scan_hex_dollar)</span>
<span class="line-added">1905       goto default_case;</span>
<span class="line-added">1906     token = G_TOKEN_HEX;</span>
<span class="line-added">1907     ch = g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-added">1908     goto number_parsing;</span>
<span class="line-added">1909 </span>
<span class="line-added">1910   case &#39;0&#39;:</span>
<span class="line-added">1911     if (config-&gt;scan_octal)</span>
<span class="line-added">1912       token = G_TOKEN_OCTAL;</span>
<span class="line-added">1913     else</span>
<span class="line-added">1914       token = G_TOKEN_INT;</span>
<span class="line-added">1915     ch = g_scanner_peek_next_char (scanner);</span>
<span class="line-added">1916     if (config-&gt;scan_hex &amp;&amp; (ch == &#39;x&#39; || ch == &#39;X&#39;))</span>
<span class="line-added">1917       {</span>
<span class="line-added">1918         token = G_TOKEN_HEX;</span>
<span class="line-added">1919         g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-added">1920         ch = g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-added">1921         if (ch == 0)</span>
<span class="line-added">1922     {</span>
<span class="line-added">1923       token = G_TOKEN_ERROR;</span>
<span class="line-added">1924       value.v_error = G_ERR_UNEXP_EOF;</span>
<span class="line-added">1925       (*position_p)++;</span>
<span class="line-added">1926       break;</span>
<span class="line-added">1927     }</span>
<span class="line-added">1928         if (g_scanner_char_2_num (ch, 16) &lt; 0)</span>
<span class="line-added">1929     {</span>
<span class="line-added">1930       token = G_TOKEN_ERROR;</span>
<span class="line-added">1931       value.v_error = G_ERR_DIGIT_RADIX;</span>
<span class="line-added">1932       ch = 0;</span>
<span class="line-added">1933       break;</span>
<span class="line-added">1934     }</span>
<span class="line-added">1935       }</span>
<span class="line-added">1936     else if (config-&gt;scan_binary &amp;&amp; (ch == &#39;b&#39; || ch == &#39;B&#39;))</span>
<span class="line-added">1937       {</span>
<span class="line-added">1938         token = G_TOKEN_BINARY;</span>
<span class="line-added">1939         g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-added">1940         ch = g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-added">1941         if (ch == 0)</span>
1942     {
<span class="line-added">1943       token = G_TOKEN_ERROR;</span>
<span class="line-added">1944       value.v_error = G_ERR_UNEXP_EOF;</span>
<span class="line-added">1945       (*position_p)++;</span>
<span class="line-added">1946       break;</span>
<span class="line-added">1947     }</span>
<span class="line-added">1948         if (g_scanner_char_2_num (ch, 10) &lt; 0)</span>
<span class="line-added">1949     {</span>
<span class="line-added">1950       token = G_TOKEN_ERROR;</span>
<span class="line-added">1951       value.v_error = G_ERR_NON_DIGIT_IN_CONST;</span>
<span class="line-added">1952       ch = 0;</span>
<span class="line-added">1953       break;</span>
<span class="line-added">1954     }</span>
<span class="line-added">1955       }</span>
<span class="line-added">1956     else</span>
<span class="line-added">1957       ch = &#39;0&#39;;</span>
<span class="line-added">1958     /* fall through */</span>
<span class="line-added">1959   case &#39;1&#39;:</span>
<span class="line-added">1960   case &#39;2&#39;:</span>
<span class="line-added">1961   case &#39;3&#39;:</span>
<span class="line-added">1962   case &#39;4&#39;:</span>
<span class="line-added">1963   case &#39;5&#39;:</span>
<span class="line-added">1964   case &#39;6&#39;:</span>
<span class="line-added">1965   case &#39;7&#39;:</span>
<span class="line-added">1966   case &#39;8&#39;:</span>
<span class="line-added">1967   case &#39;9&#39;:</span>
<span class="line-added">1968   number_parsing:</span>
<span class="line-added">1969   {</span>
1970           gboolean in_number = TRUE;
<span class="line-modified">1971     gchar *endptr;</span>
1972 
<span class="line-modified">1973     if (token == G_TOKEN_NONE)</span>
<span class="line-modified">1974       token = G_TOKEN_INT;</span>
1975 
<span class="line-modified">1976     gstring = g_string_new (dotted_float ? &quot;0.&quot; : &quot;&quot;);</span>
<span class="line-modified">1977     gstring = g_string_append_c (gstring, ch);</span>




1978 
<span class="line-modified">1979     do /* while (in_number) */</span>
<span class="line-added">1980       {</span>
<span class="line-added">1981         gboolean is_E;</span>
1982 
<span class="line-modified">1983         is_E = token == G_TOKEN_FLOAT &amp;&amp; (ch == &#39;e&#39; || ch == &#39;E&#39;);</span>
1984 
<span class="line-modified">1985         ch = g_scanner_peek_next_char (scanner);</span>




1986 
<span class="line-modified">1987         if (g_scanner_char_2_num (ch, 36) &gt;= 0 ||</span>
<span class="line-modified">1988       (config-&gt;scan_float &amp;&amp; ch == &#39;.&#39;) ||</span>
<span class="line-modified">1989       (is_E &amp;&amp; (ch == &#39;+&#39; || ch == &#39;-&#39;)))</span>
<span class="line-modified">1990     {</span>
<span class="line-modified">1991       ch = g_scanner_get_char (scanner, line_p, position_p);</span>








































































1992 
<span class="line-modified">1993       switch (ch)</span>






1994         {
<span class="line-modified">1995         case &#39;.&#39;:</span>
<span class="line-modified">1996           if (token != G_TOKEN_INT &amp;&amp; token != G_TOKEN_OCTAL)</span>
<span class="line-modified">1997       {</span>
<span class="line-modified">1998         value.v_error = token == G_TOKEN_FLOAT ? G_ERR_FLOAT_MALFORMED : G_ERR_FLOAT_RADIX;</span>
<span class="line-modified">1999         token = G_TOKEN_ERROR;</span>
<span class="line-added">2000         in_number = FALSE;</span>
<span class="line-added">2001       }</span>
<span class="line-added">2002           else</span>
<span class="line-added">2003       {</span>
<span class="line-added">2004         token = G_TOKEN_FLOAT;</span>
<span class="line-added">2005         gstring = g_string_append_c (gstring, ch);</span>
<span class="line-added">2006       }</span>
2007           break;
<span class="line-modified">2008 </span>
<span class="line-modified">2009         case &#39;0&#39;:</span>
<span class="line-added">2010         case &#39;1&#39;:</span>
<span class="line-added">2011         case &#39;2&#39;:</span>
<span class="line-added">2012         case &#39;3&#39;:</span>
<span class="line-added">2013         case &#39;4&#39;:</span>
<span class="line-added">2014         case &#39;5&#39;:</span>
<span class="line-added">2015         case &#39;6&#39;:</span>
<span class="line-added">2016         case &#39;7&#39;:</span>
<span class="line-added">2017         case &#39;8&#39;:</span>
<span class="line-added">2018         case &#39;9&#39;:</span>
<span class="line-added">2019           gstring = g_string_append_c (gstring, ch);</span>
2020           break;
<span class="line-modified">2021 </span>
<span class="line-modified">2022         case &#39;-&#39;:</span>
<span class="line-added">2023         case &#39;+&#39;:</span>
<span class="line-added">2024           if (token != G_TOKEN_FLOAT)</span>
<span class="line-added">2025       {</span>
<span class="line-added">2026         token = G_TOKEN_ERROR;</span>
<span class="line-added">2027         value.v_error = G_ERR_NON_DIGIT_IN_CONST;</span>
<span class="line-added">2028         in_number = FALSE;</span>
<span class="line-added">2029       }</span>
<span class="line-added">2030           else</span>
<span class="line-added">2031       gstring = g_string_append_c (gstring, ch);</span>
2032           break;
<span class="line-modified">2033 </span>
<span class="line-modified">2034         case &#39;e&#39;:</span>
<span class="line-modified">2035         case &#39;E&#39;:</span>
<span class="line-modified">2036           if ((token != G_TOKEN_HEX &amp;&amp; !config-&gt;scan_float) ||</span>
<span class="line-added">2037         (token != G_TOKEN_HEX &amp;&amp;</span>
<span class="line-added">2038          token != G_TOKEN_OCTAL &amp;&amp;</span>
<span class="line-added">2039          token != G_TOKEN_FLOAT &amp;&amp;</span>
<span class="line-added">2040          token != G_TOKEN_INT))</span>
<span class="line-added">2041       {</span>
<span class="line-added">2042         token = G_TOKEN_ERROR;</span>
<span class="line-added">2043         value.v_error = G_ERR_NON_DIGIT_IN_CONST;</span>
<span class="line-added">2044         in_number = FALSE;</span>
<span class="line-added">2045       }</span>
2046           else
<span class="line-modified">2047       {</span>
<span class="line-modified">2048         if (token != G_TOKEN_HEX)</span>
<span class="line-modified">2049           token = G_TOKEN_FLOAT;</span>
<span class="line-modified">2050         gstring = g_string_append_c (gstring, ch);</span>
<span class="line-modified">2051       }</span>
<span class="line-modified">2052           break;</span>
<span class="line-added">2053 </span>
<span class="line-added">2054         default:</span>
<span class="line-added">2055           if (token != G_TOKEN_HEX)</span>
<span class="line-added">2056       {</span>
<span class="line-added">2057         token = G_TOKEN_ERROR;</span>
2058         value.v_error = G_ERR_NON_DIGIT_IN_CONST;
<span class="line-added">2059         in_number = FALSE;</span>
<span class="line-added">2060       }</span>
2061           else
<span class="line-modified">2062       gstring = g_string_append_c (gstring, ch);</span>
<span class="line-added">2063           break;</span>
2064         }
<span class="line-modified">2065     }</span>
<span class="line-modified">2066         else</span>
<span class="line-modified">2067     in_number = FALSE;</span>
<span class="line-modified">2068       }</span>
<span class="line-modified">2069     while (in_number);</span>
<span class="line-modified">2070 </span>
<span class="line-modified">2071     endptr = NULL;</span>
<span class="line-modified">2072     if (token == G_TOKEN_FLOAT)</span>
<span class="line-added">2073       value.v_float = g_strtod (gstring-&gt;str, &amp;endptr);</span>
<span class="line-added">2074     else</span>
<span class="line-added">2075       {</span>
<span class="line-added">2076         guint64 ui64 = 0;</span>
<span class="line-added">2077         switch (token)</span>
2078     {
<span class="line-modified">2079     case G_TOKEN_BINARY:</span>
<span class="line-modified">2080       ui64 = g_ascii_strtoull (gstring-&gt;str, &amp;endptr, 2);</span>
<span class="line-modified">2081       break;</span>
<span class="line-modified">2082     case G_TOKEN_OCTAL:</span>
<span class="line-modified">2083       ui64 = g_ascii_strtoull (gstring-&gt;str, &amp;endptr, 8);</span>
<span class="line-modified">2084       break;</span>
<span class="line-modified">2085     case G_TOKEN_INT:</span>
<span class="line-modified">2086       ui64 = g_ascii_strtoull (gstring-&gt;str, &amp;endptr, 10);</span>
<span class="line-added">2087       break;</span>
<span class="line-added">2088     case G_TOKEN_HEX:</span>
<span class="line-added">2089       ui64 = g_ascii_strtoull (gstring-&gt;str, &amp;endptr, 16);</span>
<span class="line-added">2090       break;</span>
<span class="line-added">2091     default: ;</span>
<span class="line-added">2092     }</span>
<span class="line-added">2093         if (scanner-&gt;config-&gt;store_int64)</span>
<span class="line-added">2094     value.v_int64 = ui64;</span>
<span class="line-added">2095         else</span>
<span class="line-added">2096     value.v_int = ui64;</span>
<span class="line-added">2097       }</span>
<span class="line-added">2098     if (endptr &amp;&amp; *endptr)</span>
<span class="line-added">2099       {</span>
<span class="line-added">2100         token = G_TOKEN_ERROR;</span>
<span class="line-added">2101         if (*endptr == &#39;e&#39; || *endptr == &#39;E&#39;)</span>
<span class="line-added">2102     value.v_error = G_ERR_NON_DIGIT_IN_CONST;</span>
<span class="line-added">2103         else</span>
<span class="line-added">2104     value.v_error = G_ERR_DIGIT_RADIX;</span>
<span class="line-added">2105       }</span>
<span class="line-added">2106     g_string_free (gstring, TRUE);</span>
<span class="line-added">2107     gstring = NULL;</span>
<span class="line-added">2108     ch = 0;</span>
<span class="line-added">2109   } /* number_parsing:... */</span>
<span class="line-added">2110   break;</span>
<span class="line-added">2111 </span>
<span class="line-added">2112   default:</span>
<span class="line-added">2113   default_case:</span>
<span class="line-added">2114   {</span>
<span class="line-added">2115     if (config-&gt;cpair_comment_single &amp;&amp;</span>
<span class="line-added">2116         ch == config-&gt;cpair_comment_single[0])</span>
<span class="line-added">2117       {</span>
<span class="line-added">2118         token = G_TOKEN_COMMENT_SINGLE;</span>
<span class="line-added">2119         in_comment_single = TRUE;</span>
<span class="line-added">2120         gstring = g_string_new (NULL);</span>
<span class="line-added">2121         ch = g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-added">2122         while (ch != 0)</span>
<span class="line-added">2123     {</span>
<span class="line-added">2124       if (ch == config-&gt;cpair_comment_single[1])</span>
2125         {
<span class="line-modified">2126           in_comment_single = FALSE;</span>
<span class="line-modified">2127           ch = 0;</span>
<span class="line-modified">2128           break;</span>











2129         }




2130 
<span class="line-modified">2131       gstring = g_string_append_c (gstring, ch);</span>
<span class="line-modified">2132       ch = g_scanner_get_char (scanner, line_p, position_p);</span>
<span class="line-modified">2133     }</span>
<span class="line-added">2134         /* ignore a missing newline at EOF for single line comments */</span>
<span class="line-added">2135         if (in_comment_single &amp;&amp;</span>
<span class="line-added">2136       config-&gt;cpair_comment_single[1] == &#39;\n&#39;)</span>
<span class="line-added">2137     in_comment_single = FALSE;</span>
<span class="line-added">2138       }</span>
<span class="line-added">2139     else if (config-&gt;scan_identifier &amp;&amp; ch &amp;&amp;</span>
<span class="line-added">2140        strchr (config-&gt;cset_identifier_first, ch))</span>
<span class="line-added">2141       {</span>
<span class="line-added">2142       identifier_precedence:</span>
<span class="line-added">2143 </span>
<span class="line-added">2144         if (config-&gt;cset_identifier_nth &amp;&amp; ch &amp;&amp;</span>
<span class="line-added">2145       strchr (config-&gt;cset_identifier_nth,</span>
<span class="line-added">2146         g_scanner_peek_next_char (scanner)))</span>
<span class="line-added">2147     {</span>
<span class="line-added">2148       token = G_TOKEN_IDENTIFIER;</span>
<span class="line-added">2149       gstring = g_string_new (NULL);</span>
<span class="line-added">2150       gstring = g_string_append_c (gstring, ch);</span>
<span class="line-added">2151       do</span>
2152         {
<span class="line-modified">2153           ch = g_scanner_get_char (scanner, line_p, position_p);</span>

2154           gstring = g_string_append_c (gstring, ch);
<span class="line-modified">2155           ch = g_scanner_peek_next_char (scanner);</span>


























2156         }
<span class="line-modified">2157       while (ch &amp;&amp; strchr (config-&gt;cset_identifier_nth, ch));</span>
<span class="line-modified">2158       ch = 0;</span>
<span class="line-added">2159     }</span>
<span class="line-added">2160         else if (config-&gt;scan_identifier_1char)</span>
<span class="line-added">2161     {</span>
<span class="line-added">2162       token = G_TOKEN_IDENTIFIER;</span>
<span class="line-added">2163       value.v_identifier = g_new0 (gchar, 2);</span>
<span class="line-added">2164       value.v_identifier[0] = ch;</span>
<span class="line-added">2165       ch = 0;</span>
<span class="line-added">2166     }</span>
<span class="line-added">2167       }</span>
<span class="line-added">2168     if (ch)</span>
<span class="line-added">2169       {</span>
<span class="line-added">2170         if (config-&gt;char_2_token)</span>
<span class="line-added">2171     token = ch;</span>
<span class="line-added">2172         else</span>
<span class="line-added">2173     {</span>
<span class="line-added">2174       token = G_TOKEN_CHAR;</span>
<span class="line-added">2175       value.v_char = ch;</span>
2176     }
<span class="line-added">2177         ch = 0;</span>
<span class="line-added">2178       }</span>
<span class="line-added">2179   } /* default_case:... */</span>
<span class="line-added">2180   break;</span>
<span class="line-added">2181   }</span>
2182       g_assert (ch == 0 &amp;&amp; token != G_TOKEN_NONE); /* paranoid */
2183     }
2184   while (ch != 0);
2185 
2186   if (in_comment_multi || in_comment_single ||
2187       in_string_sq || in_string_dq)
2188     {
2189       token = G_TOKEN_ERROR;
2190       if (gstring)
<span class="line-modified">2191   {</span>
<span class="line-modified">2192     g_string_free (gstring, TRUE);</span>
<span class="line-modified">2193     gstring = NULL;</span>
<span class="line-modified">2194   }</span>
2195       (*position_p)++;
2196       if (in_comment_multi || in_comment_single)
<span class="line-modified">2197   value.v_error = G_ERR_UNEXP_EOF_IN_COMMENT;</span>
2198       else /* (in_string_sq || in_string_dq) */
<span class="line-modified">2199   value.v_error = G_ERR_UNEXP_EOF_IN_STRING;</span>
2200     }
2201 
2202   if (gstring)
2203     {
2204       value.v_string = g_string_free (gstring, FALSE);
2205       gstring = NULL;
2206     }
2207 
2208   if (token == G_TOKEN_IDENTIFIER)
2209     {
2210       if (config-&gt;scan_symbols)
<span class="line-modified">2211   {</span>
<span class="line-modified">2212     GScannerKey *key;</span>
<span class="line-modified">2213     guint scope_id;</span>
<span class="line-modified">2214 </span>
<span class="line-modified">2215     scope_id = scanner-&gt;scope_id;</span>
<span class="line-modified">2216     key = g_scanner_lookup_internal (scanner, scope_id, value.v_identifier);</span>
<span class="line-modified">2217     if (!key &amp;&amp; scope_id &amp;&amp; scanner-&gt;config-&gt;scope_0_fallback)</span>
<span class="line-modified">2218       key = g_scanner_lookup_internal (scanner, 0, value.v_identifier);</span>
<span class="line-modified">2219 </span>
<span class="line-modified">2220     if (key)</span>
<span class="line-modified">2221       {</span>
<span class="line-modified">2222         g_free (value.v_identifier);</span>
<span class="line-modified">2223         token = G_TOKEN_SYMBOL;</span>
<span class="line-modified">2224         value.v_symbol = key-&gt;value;</span>
<span class="line-modified">2225       }</span>
<span class="line-modified">2226   }</span>
2227 
2228       if (token == G_TOKEN_IDENTIFIER &amp;&amp;
<span class="line-modified">2229     config-&gt;scan_identifier_NULL &amp;&amp;</span>
<span class="line-modified">2230     strlen (value.v_identifier) == 4)</span>
<span class="line-modified">2231   {</span>
<span class="line-modified">2232     gchar *null_upper = &quot;NULL&quot;;</span>
<span class="line-modified">2233     gchar *null_lower = &quot;null&quot;;</span>
<span class="line-modified">2234 </span>
<span class="line-modified">2235     if (scanner-&gt;config-&gt;case_sensitive)</span>
<span class="line-modified">2236       {</span>
<span class="line-modified">2237         if (value.v_identifier[0] == null_upper[0] &amp;&amp;</span>
<span class="line-modified">2238       value.v_identifier[1] == null_upper[1] &amp;&amp;</span>
<span class="line-modified">2239       value.v_identifier[2] == null_upper[2] &amp;&amp;</span>
<span class="line-modified">2240       value.v_identifier[3] == null_upper[3])</span>
<span class="line-modified">2241     token = G_TOKEN_IDENTIFIER_NULL;</span>
<span class="line-modified">2242       }</span>
<span class="line-modified">2243     else</span>
<span class="line-modified">2244       {</span>
<span class="line-modified">2245         if ((value.v_identifier[0] == null_upper[0] ||</span>
<span class="line-modified">2246        value.v_identifier[0] == null_lower[0]) &amp;&amp;</span>
<span class="line-modified">2247       (value.v_identifier[1] == null_upper[1] ||</span>
<span class="line-modified">2248        value.v_identifier[1] == null_lower[1]) &amp;&amp;</span>
<span class="line-modified">2249       (value.v_identifier[2] == null_upper[2] ||</span>
<span class="line-modified">2250        value.v_identifier[2] == null_lower[2]) &amp;&amp;</span>
<span class="line-modified">2251       (value.v_identifier[3] == null_upper[3] ||</span>
<span class="line-modified">2252        value.v_identifier[3] == null_lower[3]))</span>
<span class="line-modified">2253     token = G_TOKEN_IDENTIFIER_NULL;</span>
<span class="line-modified">2254       }</span>
<span class="line-modified">2255   }</span>
2256     }
2257 
2258   *token_p = token;
2259   *value_p = value;
2260 }
</pre>
</td>
</tr>
</table>
<center><a href="gregex.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gscanner.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>