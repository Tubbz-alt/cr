<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/giochannel.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ghostutils.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="giochannel.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/giochannel.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  22  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  23  * file for a list of people on the GLib Team.  See the ChangeLog
  24  * files for a list of changes.  These files are distributed with
  25  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  26  */
  27 
  28 /*
  29  * MT safe
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 
  34 #include &lt;string.h&gt;
  35 #include &lt;errno.h&gt;
  36 
  37 #include &quot;giochannel.h&quot;
  38 
  39 #include &quot;gstrfuncs.h&quot;
  40 #include &quot;gtestutils.h&quot;
  41 #include &quot;glibintl.h&quot;
<span class="line-removed">  42 #include &quot;gunicodeprivate.h&quot;</span>
  43 
  44 
  45 /**
  46  * SECTION:iochannels
  47  * @title: IO Channels
  48  * @short_description: portable support for using files, pipes and sockets
  49  * @see_also: g_io_add_watch(), g_io_add_watch_full(), g_source_remove(),
  50  *     #GMainLoop
  51  *
  52  * The #GIOChannel data type aims to provide a portable method for
  53  * using file descriptors, pipes, and sockets, and integrating them
  54  * into the [main event loop][glib-The-Main-Event-Loop]. Currently,
  55  * full support is available on UNIX platforms, support for Windows
  56  * is only partially complete.
  57  *
  58  * To create a new #GIOChannel on UNIX systems use
  59  * g_io_channel_unix_new(). This works for plain file descriptors,
  60  * pipes and sockets. Alternatively, a channel can be created for a
  61  * file in a system independent manner using g_io_channel_new_file().
  62  *
</pre>
<hr />
<pre>
 136  * @G_IO_STATUS_EOF: End of file.
 137  * @G_IO_STATUS_AGAIN: Resource temporarily unavailable.
 138  *
 139  * Stati returned by most of the #GIOFuncs functions.
 140  **/
 141 
 142 /**
 143  * GIOError:
 144  * @G_IO_ERROR_NONE: no error
 145  * @G_IO_ERROR_AGAIN: an EAGAIN error occurred
 146  * @G_IO_ERROR_INVAL: an EINVAL error occurred
 147  * @G_IO_ERROR_UNKNOWN: another error occurred
 148  *
 149  * #GIOError is only used by the deprecated functions
 150  * g_io_channel_read(), g_io_channel_write(), and g_io_channel_seek().
 151  **/
 152 
 153 #define G_IO_NICE_BUF_SIZE  1024
 154 
 155 /* This needs to be as wide as the largest character in any possible encoding */
<span class="line-modified"> 156 #define MAX_CHAR_SIZE       10</span>
 157 
 158 /* Some simplifying macros, which reduce the need to worry whether the
 159  * buffers have been allocated. These also make USE_BUF () an lvalue,
 160  * which is used in g_io_channel_read_to_end ().
 161  */
<span class="line-modified"> 162 #define USE_BUF(channel)    ((channel)-&gt;encoding ? (channel)-&gt;encoded_read_buf \</span>
<span class="line-modified"> 163                  : (channel)-&gt;read_buf)</span>
<span class="line-modified"> 164 #define BUF_LEN(string)     ((string) ? (string)-&gt;len : 0)</span>
<span class="line-modified"> 165 </span>
<span class="line-modified"> 166 static GIOError     g_io_error_get_from_g_error (GIOStatus    status,</span>
<span class="line-modified"> 167                              GError      *err);</span>
<span class="line-modified"> 168 static void     g_io_channel_purge      (GIOChannel  *channel);</span>
<span class="line-modified"> 169 static GIOStatus    g_io_channel_fill_buffer    (GIOChannel  *channel,</span>
<span class="line-modified"> 170                              GError     **err);</span>
<span class="line-modified"> 171 static GIOStatus    g_io_channel_read_line_backend  (GIOChannel  *channel,</span>
<span class="line-modified"> 172                              gsize       *length,</span>
<span class="line-modified"> 173                              gsize       *terminator_pos,</span>
<span class="line-modified"> 174                              GError     **error);</span>
 175 
 176 /**
 177  * g_io_channel_init:
 178  * @channel: a #GIOChannel
 179  *
 180  * Initializes a #GIOChannel struct.
 181  *
 182  * This is called by each of the above functions when creating a
 183  * #GIOChannel, and so is not often needed by the application
 184  * programmer (unless you are creating a new type of #GIOChannel).
 185  */
 186 void
 187 g_io_channel_init (GIOChannel *channel)
 188 {
 189   channel-&gt;ref_count = 1;
 190   channel-&gt;encoding = g_strdup (&quot;UTF-8&quot;);
 191   channel-&gt;line_term = NULL;
 192   channel-&gt;line_term_len = 0;
 193   channel-&gt;buf_size = G_IO_NICE_BUF_SIZE;
 194   channel-&gt;read_cd = (GIConv) -1;
</pre>
<hr />
<pre>
 242       else
 243         g_io_channel_purge (channel);
 244       g_free (channel-&gt;encoding);
 245       if (channel-&gt;read_cd != (GIConv) -1)
 246         g_iconv_close (channel-&gt;read_cd);
 247       if (channel-&gt;write_cd != (GIConv) -1)
 248         g_iconv_close (channel-&gt;write_cd);
 249       g_free (channel-&gt;line_term);
 250       if (channel-&gt;read_buf)
 251         g_string_free (channel-&gt;read_buf, TRUE);
 252       if (channel-&gt;write_buf)
 253         g_string_free (channel-&gt;write_buf, TRUE);
 254       if (channel-&gt;encoded_read_buf)
 255         g_string_free (channel-&gt;encoded_read_buf, TRUE);
 256       channel-&gt;funcs-&gt;io_free (channel);
 257     }
 258 }
 259 
 260 static GIOError
 261 g_io_error_get_from_g_error (GIOStatus  status,
<span class="line-modified"> 262                  GError    *err)</span>
 263 {
 264   switch (status)
 265     {
 266       case G_IO_STATUS_NORMAL:
 267       case G_IO_STATUS_EOF:
 268         return G_IO_ERROR_NONE;
 269       case G_IO_STATUS_AGAIN:
 270         return G_IO_ERROR_AGAIN;
 271       case G_IO_STATUS_ERROR:
<span class="line-modified"> 272     g_return_val_if_fail (err != NULL, G_IO_ERROR_UNKNOWN);</span>
 273 
 274         if (err-&gt;domain != G_IO_CHANNEL_ERROR)
 275           return G_IO_ERROR_UNKNOWN;
 276         switch (err-&gt;code)
 277           {
 278             case G_IO_CHANNEL_ERROR_INVAL:
 279               return G_IO_ERROR_INVAL;
 280             default:
 281               return G_IO_ERROR_UNKNOWN;
 282           }
 283       default:
 284         g_assert_not_reached ();
 285     }
 286 }
 287 
 288 /**
 289  * g_io_channel_read:
 290  * @channel: a #GIOChannel
 291  * @buf: a buffer to read the data into (which should be at least
 292  *       count bytes long)
 293  * @count: the number of bytes to read from the #GIOChannel
 294  * @bytes_read: returns the number of bytes actually read
 295  *
 296  * Reads data from a #GIOChannel.
 297  *
 298  * Returns: %G_IO_ERROR_NONE if the operation was successful.
 299  *
 300  * Deprecated:2.2: Use g_io_channel_read_chars() instead.
 301  **/
 302 GIOError
 303 g_io_channel_read (GIOChannel *channel,
<span class="line-modified"> 304            gchar      *buf,</span>
<span class="line-modified"> 305            gsize       count,</span>
<span class="line-modified"> 306            gsize      *bytes_read)</span>
 307 {
 308   GError *err = NULL;
 309   GIOError error;
 310   GIOStatus status;
 311 
 312   g_return_val_if_fail (channel != NULL, G_IO_ERROR_UNKNOWN);
 313   g_return_val_if_fail (bytes_read != NULL, G_IO_ERROR_UNKNOWN);
 314 
 315   if (count == 0)
 316     {
 317       if (bytes_read)
 318         *bytes_read = 0;
 319       return G_IO_ERROR_NONE;
 320     }
 321 
 322   g_return_val_if_fail (buf != NULL, G_IO_ERROR_UNKNOWN);
 323 
 324   status = channel-&gt;funcs-&gt;io_read (channel, buf, count, bytes_read, &amp;err);
 325 
 326   error = g_io_error_get_from_g_error (status, err);
</pre>
<hr />
<pre>
 329     g_error_free (err);
 330 
 331   return error;
 332 }
 333 
 334 /**
 335  * g_io_channel_write:
 336  * @channel:  a #GIOChannel
 337  * @buf: the buffer containing the data to write
 338  * @count: the number of bytes to write
 339  * @bytes_written: the number of bytes actually written
 340  *
 341  * Writes data to a #GIOChannel.
 342  *
 343  * Returns:  %G_IO_ERROR_NONE if the operation was successful.
 344  *
 345  * Deprecated:2.2: Use g_io_channel_write_chars() instead.
 346  **/
 347 GIOError
 348 g_io_channel_write (GIOChannel  *channel,
<span class="line-modified"> 349             const gchar *buf,</span>
<span class="line-modified"> 350             gsize        count,</span>
<span class="line-modified"> 351             gsize       *bytes_written)</span>
 352 {
 353   GError *err = NULL;
 354   GIOError error;
 355   GIOStatus status;
 356 
 357   g_return_val_if_fail (channel != NULL, G_IO_ERROR_UNKNOWN);
 358   g_return_val_if_fail (bytes_written != NULL, G_IO_ERROR_UNKNOWN);
 359 
 360   status = channel-&gt;funcs-&gt;io_write (channel, buf, count, bytes_written, &amp;err);
 361 
 362   error = g_io_error_get_from_g_error (status, err);
 363 
 364   if (err)
 365     g_error_free (err);
 366 
 367   return error;
 368 }
 369 
 370 /**
 371  * g_io_channel_seek:
 372  * @channel: a #GIOChannel
 373  * @offset: an offset, in bytes, which is added to the position specified
 374  *          by @type
 375  * @type: the position in the file, which can be %G_SEEK_CUR (the current
 376  *        position), %G_SEEK_SET (the start of the file), or %G_SEEK_END
 377  *        (the end of the file)
 378  *
 379  * Sets the current position in the #GIOChannel, similar to the standard
 380  * library function fseek().
 381  *
 382  * Returns: %G_IO_ERROR_NONE if the operation was successful.
 383  *
 384  * Deprecated:2.2: Use g_io_channel_seek_position() instead.
 385  **/
 386 GIOError
 387 g_io_channel_seek (GIOChannel *channel,
<span class="line-modified"> 388            gint64      offset,</span>
<span class="line-modified"> 389            GSeekType   type)</span>
 390 {
 391   GError *err = NULL;
 392   GIOError error;
 393   GIOStatus status;
 394 
 395   g_return_val_if_fail (channel != NULL, G_IO_ERROR_UNKNOWN);
 396   g_return_val_if_fail (channel-&gt;is_seekable, G_IO_ERROR_UNKNOWN);
 397 
 398   switch (type)
 399     {
 400       case G_SEEK_CUR:
 401       case G_SEEK_SET:
 402       case G_SEEK_END:
 403         break;
 404       default:
 405         g_warning (&quot;g_io_channel_seek: unknown seek type&quot;);
 406         return G_IO_ERROR_UNKNOWN;
 407     }
 408 
 409   status = channel-&gt;funcs-&gt;io_seek (channel, offset, type, &amp;err);
</pre>
<hr />
<pre>
 466   channel-&gt;close_on_unref = FALSE; /* Because we already did */
 467   channel-&gt;is_readable = FALSE;
 468   channel-&gt;is_writeable = FALSE;
 469   channel-&gt;is_seekable = FALSE;
 470 }
 471 
 472 /**
 473  * g_io_channel_shutdown:
 474  * @channel: a #GIOChannel
 475  * @flush: if %TRUE, flush pending
 476  * @err: location to store a #GIOChannelError
 477  *
 478  * Close an IO channel. Any pending data to be written will be
 479  * flushed if @flush is %TRUE. The channel will not be freed until the
 480  * last reference is dropped using g_io_channel_unref().
 481  *
 482  * Returns: the status of the operation.
 483  **/
 484 GIOStatus
 485 g_io_channel_shutdown (GIOChannel  *channel,
<span class="line-modified"> 486                gboolean     flush,</span>
<span class="line-modified"> 487                GError     **err)</span>
 488 {
 489   GIOStatus status, result;
 490   GError *tmperr = NULL;
 491 
 492   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
 493   g_return_val_if_fail (err == NULL || *err == NULL, G_IO_STATUS_ERROR);
 494 
 495   if (channel-&gt;write_buf &amp;&amp; channel-&gt;write_buf-&gt;len &gt; 0)
 496     {
 497       if (flush)
 498         {
 499           GIOFlags flags;
 500 
 501           /* Set the channel to blocking, to avoid a busy loop
 502            */
 503           flags = g_io_channel_get_flags (channel);
 504           /* Ignore any errors here, they&#39;re irrelevant */
 505           g_io_channel_set_flags (channel, flags &amp; ~G_IO_FLAG_NONBLOCK, NULL);
 506 
 507           result = g_io_channel_flush (channel, &amp;tmperr);
</pre>
<hr />
<pre>
 592  * g_io_create_watch:
 593  * @channel: a #GIOChannel to watch
 594  * @condition: conditions to watch for
 595  *
 596  * Creates a #GSource that&#39;s dispatched when @condition is met for the
 597  * given @channel. For example, if condition is #G_IO_IN, the source will
 598  * be dispatched when there&#39;s data available for reading.
 599  *
 600  * g_io_add_watch() is a simpler interface to this same functionality, for
 601  * the case where you want to add the source to the default main loop context
 602  * at the default priority.
 603  *
 604  * On Windows, polling a #GSource created to watch a channel for a socket
 605  * puts the socket in non-blocking mode. This is a side-effect of the
 606  * implementation and unavoidable.
 607  *
 608  * Returns: a new #GSource
 609  */
 610 GSource *
 611 g_io_create_watch (GIOChannel   *channel,
<span class="line-modified"> 612            GIOCondition  condition)</span>
 613 {
 614   g_return_val_if_fail (channel != NULL, NULL);
 615 
 616   return channel-&gt;funcs-&gt;io_create_watch (channel, condition);
 617 }
 618 
 619 /**
 620  * g_io_add_watch_full: (rename-to g_io_add_watch)
 621  * @channel: a #GIOChannel
 622  * @priority: the priority of the #GIOChannel source
 623  * @condition: the condition to watch for
 624  * @func: the function to call when the condition is satisfied
 625  * @user_data: user data to pass to @func
 626  * @notify: the function to call when the source is removed
 627  *
 628  * Adds the #GIOChannel into the default main loop context
 629  * with the given priority.
 630  *
 631  * This internally creates a main loop source using g_io_create_watch()
 632  * and attaches it to the main loop context with g_source_attach().
 633  * You can do these steps manually if you need greater control.
 634  *
 635  * Returns: the event source id
 636  */
 637 guint
 638 g_io_add_watch_full (GIOChannel    *channel,
<span class="line-modified"> 639              gint           priority,</span>
<span class="line-modified"> 640              GIOCondition   condition,</span>
<span class="line-modified"> 641              GIOFunc        func,</span>
<span class="line-modified"> 642              gpointer       user_data,</span>
<span class="line-modified"> 643              GDestroyNotify notify)</span>
 644 {
 645   GSource *source;
 646   guint id;
 647 
 648   g_return_val_if_fail (channel != NULL, 0);
 649 
 650   source = g_io_create_watch (channel, condition);
 651 
 652   if (priority != G_PRIORITY_DEFAULT)
 653     g_source_set_priority (source, priority);
 654   g_source_set_callback (source, (GSourceFunc)func, user_data, notify);
 655 
 656   id = g_source_attach (source, NULL);
 657   g_source_unref (source);
 658 
 659   return id;
 660 }
 661 
 662 /**
 663  * g_io_add_watch:
</pre>
<hr />
<pre>
 682  * on a #GIOChannel is satisfied.
 683  *
 684  * Returns: the function should return %FALSE if the event source
 685  *          should be removed
 686  **/
 687 /**
 688  * GIOCondition:
 689  * @G_IO_IN: There is data to read.
 690  * @G_IO_OUT: Data can be written (without blocking).
 691  * @G_IO_PRI: There is urgent data to read.
 692  * @G_IO_ERR: Error condition.
 693  * @G_IO_HUP: Hung up (the connection has been broken, usually for
 694  *            pipes and sockets).
 695  * @G_IO_NVAL: Invalid request. The file descriptor is not open.
 696  *
 697  * A bitwise combination representing a condition to watch for on an
 698  * event source.
 699  **/
 700 guint
 701 g_io_add_watch (GIOChannel   *channel,
<span class="line-modified"> 702         GIOCondition  condition,</span>
<span class="line-modified"> 703         GIOFunc       func,</span>
<span class="line-modified"> 704         gpointer      user_data)</span>
 705 {
 706   return g_io_add_watch_full (channel, G_PRIORITY_DEFAULT, condition, func, user_data, NULL);
 707 }
 708 
 709 /**
 710  * g_io_channel_get_buffer_condition:
 711  * @channel: A #GIOChannel
 712  *
 713  * This function returns a #GIOCondition depending on whether there
 714  * is data to be read/space to write data in the internal buffers in
 715  * the #GIOChannel. Only the flags %G_IO_IN and %G_IO_OUT may be set.
 716  *
 717  * Returns: A #GIOCondition
 718  **/
 719 GIOCondition
 720 g_io_channel_get_buffer_condition (GIOChannel *channel)
 721 {
 722   GIOCondition condition = 0;
 723 
 724   if (channel-&gt;encoding)
</pre>
<hr />
<pre>
 865   return channel-&gt;buf_size;
 866 }
 867 
 868 /**
 869  * g_io_channel_set_line_term:
 870  * @channel: a #GIOChannel
 871  * @line_term: (nullable): The line termination string. Use %NULL for
 872  *             autodetect.  Autodetection breaks on &quot;\n&quot;, &quot;\r\n&quot;, &quot;\r&quot;, &quot;\0&quot;,
 873  *             and the Unicode paragraph separator. Autodetection should not be
 874  *             used for anything other than file-based channels.
 875  * @length: The length of the termination string. If -1 is passed, the
 876  *          string is assumed to be nul-terminated. This option allows
 877  *          termination strings with embedded nuls.
 878  *
 879  * This sets the string that #GIOChannel uses to determine
 880  * where in the file a line break occurs.
 881  **/
 882 void
 883 g_io_channel_set_line_term (GIOChannel  *channel,
 884                             const gchar *line_term,
<span class="line-modified"> 885                 gint         length)</span>
 886 {
 887   g_return_if_fail (channel != NULL);
 888   g_return_if_fail (line_term == NULL || length != 0); /* Disallow &quot;&quot; */
 889 
 890   if (line_term == NULL)
 891     length = 0;
 892   else if (length &lt; 0)
 893     length = strlen (line_term);
 894 
 895   g_free (channel-&gt;line_term);
 896   channel-&gt;line_term = line_term ? g_memdup (line_term, length) : NULL;
 897   channel-&gt;line_term_len = length;
 898 }
 899 
 900 /**
 901  * g_io_channel_get_line_term:
 902  * @channel: a #GIOChannel
 903  * @length: a location to return the length of the line terminator
 904  *
 905  * This returns the string that #GIOChannel uses to determine
 906  * where in the file a line break occurs. A value of %NULL
 907  * indicates autodetection.
 908  *
 909  * Returns: The line termination string. This value
 910  *   is owned by GLib and must not be freed.
 911  **/
 912 const gchar *
 913 g_io_channel_get_line_term (GIOChannel *channel,
<span class="line-modified"> 914                 gint       *length)</span>
 915 {
 916   g_return_val_if_fail (channel != NULL, NULL);
 917 
 918   if (length)
 919     *length = channel-&gt;line_term_len;
 920 
 921   return channel-&gt;line_term;
 922 }
 923 
 924 /**
 925  * g_io_channel_set_flags:
 926  * @channel: a #GIOChannel
 927  * @flags: the flags to set on the IO channel
 928  * @error: A location to return an error of type #GIOChannelError
 929  *
 930  * Sets the (writeable) flags in @channel to (@flags &amp; %G_IO_FLAG_SET_MASK).
 931  *
 932  * Returns: the status of the operation.
 933  **/
 934 /**
</pre>
<hr />
<pre>
 948  * @G_IO_FLAG_IS_SEEKABLE: indicates that the io channel is seekable,
 949  *     i.e. that g_io_channel_seek_position() can be used on it.
 950  *     This flag cannot be changed.
 951  * @G_IO_FLAG_MASK: the mask that specifies all the valid flags.
 952  * @G_IO_FLAG_GET_MASK: the mask of the flags that are returned from
 953  *     g_io_channel_get_flags()
 954  * @G_IO_FLAG_SET_MASK: the mask of the flags that the user can modify
 955  *     with g_io_channel_set_flags()
 956  *
 957  * Specifies properties of a #GIOChannel. Some of the flags can only be
 958  * read with g_io_channel_get_flags(), but not changed with
 959  * g_io_channel_set_flags().
 960  */
 961 GIOStatus
 962 g_io_channel_set_flags (GIOChannel  *channel,
 963                         GIOFlags     flags,
 964                         GError     **error)
 965 {
 966   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
 967   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<span class="line-modified"> 968             G_IO_STATUS_ERROR);</span>
 969 
 970   return (*channel-&gt;funcs-&gt;io_set_flags) (channel,
<span class="line-modified"> 971                       flags &amp; G_IO_FLAG_SET_MASK,</span>
<span class="line-modified"> 972                       error);</span>
 973 }
 974 
 975 /**
 976  * g_io_channel_get_flags:
 977  * @channel: a #GIOChannel
 978  *
 979  * Gets the current flags for a #GIOChannel, including read-only
 980  * flags such as %G_IO_FLAG_IS_READABLE.
 981  *
 982  * The values of the flags %G_IO_FLAG_IS_READABLE and %G_IO_FLAG_IS_WRITABLE
 983  * are cached for internal use by the channel when it is created.
 984  * If they should change at some later point (e.g. partial shutdown
 985  * of a socket with the UNIX shutdown() function), the user
 986  * should immediately call g_io_channel_get_flags() to update
 987  * the internal values of these flags.
 988  *
 989  * Returns: the flags which are set on the channel
 990  **/
 991 GIOFlags
 992 g_io_channel_get_flags (GIOChannel *channel)
</pre>
<hr />
<pre>
1007     flags |= G_IO_FLAG_IS_WRITABLE;
1008 
1009   return flags;
1010 }
1011 
1012 /**
1013  * g_io_channel_set_close_on_unref:
1014  * @channel: a #GIOChannel
1015  * @do_close: Whether to close the channel on the final unref of
1016  *            the GIOChannel data structure.
1017  *
1018  * Whether to close the channel on the final unref of the #GIOChannel
1019  * data structure. The default value of this is %TRUE for channels
1020  * created by g_io_channel_new_file (), and %FALSE for all other channels.
1021  *
1022  * Setting this flag to %TRUE for a channel you have already closed
1023  * can cause problems when the final reference to the #GIOChannel is dropped.
1024  **/
1025 void
1026 g_io_channel_set_close_on_unref (GIOChannel *channel,
<span class="line-modified">1027                                  gboolean    do_close)</span>
1028 {
1029   g_return_if_fail (channel != NULL);
1030 
1031   channel-&gt;close_on_unref = do_close;
1032 }
1033 
1034 /**
1035  * g_io_channel_get_close_on_unref:
1036  * @channel: a #GIOChannel.
1037  *
1038  * Returns whether the file/socket/whatever associated with @channel
1039  * will be closed when @channel receives its final unref and is
1040  * destroyed. The default value of this is %TRUE for channels created
1041  * by g_io_channel_new_file (), and %FALSE for all other channels.
1042  *
1043  * Returns: %TRUE if the channel will be closed, %FALSE otherwise.
1044  **/
1045 gboolean
1046 g_io_channel_get_close_on_unref (GIOChannel *channel)
1047 {
</pre>
<hr />
<pre>
1070  * @G_SEEK_SET: the start of the file.
1071  * @G_SEEK_END: the end of the file.
1072  *
1073  * An enumeration specifying the base position for a
1074  * g_io_channel_seek_position() operation.
1075  **/
1076 GIOStatus
1077 g_io_channel_seek_position (GIOChannel  *channel,
1078                             gint64       offset,
1079                             GSeekType    type,
1080                             GError     **error)
1081 {
1082   GIOStatus status;
1083 
1084   /* For files, only one of the read and write buffers can contain data.
1085    * For sockets, both can contain data.
1086    */
1087 
1088   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
1089   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<span class="line-modified">1090             G_IO_STATUS_ERROR);</span>
1091   g_return_val_if_fail (channel-&gt;is_seekable, G_IO_STATUS_ERROR);
1092 
1093   switch (type)
1094     {
1095       case G_SEEK_CUR: /* The user is seeking relative to the head of the buffer */
1096         if (channel-&gt;use_buffer)
1097           {
1098             if (channel-&gt;do_encode &amp;&amp; channel-&gt;encoded_read_buf
1099                 &amp;&amp; channel-&gt;encoded_read_buf-&gt;len &gt; 0)
1100               {
1101                 g_warning (&quot;Seek type G_SEEK_CUR not allowed for this&quot;
1102                   &quot; channel&#39;s encoding.&quot;);
1103                 return G_IO_STATUS_ERROR;
1104               }
1105           if (channel-&gt;read_buf)
1106             offset -= channel-&gt;read_buf-&gt;len;
1107           if (channel-&gt;encoded_read_buf)
1108             {
1109               g_assert (channel-&gt;encoded_read_buf-&gt;len == 0 || !channel-&gt;do_encode);
1110 
</pre>
<hr />
<pre>
1157           channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
1158         }
1159     }
1160 
1161   return status;
1162 }
1163 
1164 /**
1165  * g_io_channel_flush:
1166  * @channel: a #GIOChannel
1167  * @error: location to store an error of type #GIOChannelError
1168  *
1169  * Flushes the write buffer for the GIOChannel.
1170  *
1171  * Returns: the status of the operation: One of
1172  *   #G_IO_STATUS_NORMAL, #G_IO_STATUS_AGAIN, or
1173  *   #G_IO_STATUS_ERROR.
1174  **/
1175 GIOStatus
1176 g_io_channel_flush (GIOChannel  *channel,
<span class="line-modified">1177                     GError     **error)</span>
1178 {
1179   GIOStatus status;
1180   gsize this_time = 1, bytes_written = 0;
1181 
1182   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
1183   g_return_val_if_fail ((error == NULL) || (*error == NULL), G_IO_STATUS_ERROR);
1184 
1185   if (channel-&gt;write_buf == NULL || channel-&gt;write_buf-&gt;len == 0)
1186     return G_IO_STATUS_NORMAL;
1187 
1188   do
1189     {
1190       g_assert (this_time &gt; 0);
1191 
1192       status = channel-&gt;funcs-&gt;io_write (channel,
<span class="line-modified">1193                      channel-&gt;write_buf-&gt;str + bytes_written,</span>
<span class="line-modified">1194                      channel-&gt;write_buf-&gt;len - bytes_written,</span>
<span class="line-modified">1195                      &amp;this_time, error);</span>
1196       bytes_written += this_time;
1197     }
1198   while ((bytes_written &lt; channel-&gt;write_buf-&gt;len)
1199          &amp;&amp; (status == G_IO_STATUS_NORMAL));
1200 
1201   g_string_erase (channel-&gt;write_buf, 0, bytes_written);
1202 
1203   return status;
1204 }
1205 
1206 /**
1207  * g_io_channel_set_buffered:
1208  * @channel: a #GIOChannel
1209  * @buffered: whether to set the channel buffered or unbuffered
1210  *
1211  * The buffering state can only be set if the channel&#39;s encoding
1212  * is %NULL. For any other encoding, the channel must be buffered.
1213  *
1214  * A buffered channel can only be set unbuffered if the channel&#39;s
1215  * internal buffers have been flushed. Newly created channels or
</pre>
<hr />
<pre>
1290  *
1291  * - One of the (new API) read functions has just returned %G_IO_STATUS_EOF
1292  *   (or, in the case of g_io_channel_read_to_end(), %G_IO_STATUS_NORMAL).
1293  *
1294  * -  One of the functions g_io_channel_read_chars() or
1295  *    g_io_channel_read_unichar() has returned %G_IO_STATUS_AGAIN or
1296  *    %G_IO_STATUS_ERROR. This may be useful in the case of
1297  *    %G_CONVERT_ERROR_ILLEGAL_SEQUENCE.
1298  *    Returning one of these statuses from g_io_channel_read_line(),
1299  *    g_io_channel_read_line_string(), or g_io_channel_read_to_end()
1300  *    does not guarantee that the encoding can be changed.
1301  *
1302  * Channels which do not meet one of the above conditions cannot call
1303  * g_io_channel_seek_position() with an offset of %G_SEEK_CUR, and, if
1304  * they are &quot;seekable&quot;, cannot call g_io_channel_write_chars() after
1305  * calling one of the API &quot;read&quot; functions.
1306  *
1307  * Return Value: %G_IO_STATUS_NORMAL if the encoding was successfully set
1308  */
1309 GIOStatus
<span class="line-modified">1310 g_io_channel_set_encoding (GIOChannel   *channel,</span>
1311                            const gchar  *encoding,
<span class="line-modified">1312                            GError      **error)</span>
1313 {
1314   GIConv read_cd, write_cd;

1315   gboolean did_encode;

1316 
1317   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
1318   g_return_val_if_fail ((error == NULL) || (*error == NULL), G_IO_STATUS_ERROR);
1319 
1320   /* Make sure the encoded buffers are empty */
1321 
1322   g_return_val_if_fail (!channel-&gt;do_encode || !channel-&gt;encoded_read_buf ||
<span class="line-modified">1323             channel-&gt;encoded_read_buf-&gt;len == 0, G_IO_STATUS_ERROR);</span>
1324 
1325   if (!channel-&gt;use_buffer)
1326     {
1327       g_warning (&quot;Need to set the channel buffered before setting the encoding.&quot;);
1328       g_warning (&quot;Assuming this is what you meant and acting accordingly.&quot;);
1329 
1330       channel-&gt;use_buffer = TRUE;
1331     }
1332 
1333   if (channel-&gt;partial_write_buf[0] != &#39;\0&#39;)
1334     {
1335       g_warning (&quot;Partial character at end of write buffer not flushed.&quot;);
1336       channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
1337     }
1338 

1339   did_encode = channel-&gt;do_encode;

1340 
1341   if (!encoding || strcmp (encoding, &quot;UTF8&quot;) == 0 || strcmp (encoding, &quot;UTF-8&quot;) == 0)
1342     {
1343       channel-&gt;do_encode = FALSE;
1344       read_cd = write_cd = (GIConv) -1;
1345     }
1346   else
1347     {
1348       gint err = 0;
1349       const gchar *from_enc = NULL, *to_enc = NULL;
1350 
1351       if (channel-&gt;is_readable)
1352         {
1353           read_cd = g_iconv_open (&quot;UTF-8&quot;, encoding);
1354 
1355           if (read_cd == (GIConv) -1)
1356             {
1357               err = errno;
1358               from_enc = encoding;
1359               to_enc = &quot;UTF-8&quot;;
</pre>
<hr />
<pre>
1503       gchar *inbuf, *outbuf;
1504       int errval;
1505 
1506       g_assert (channel-&gt;encoded_read_buf);
1507 
1508 reencode:
1509 
1510       inbytes_left = channel-&gt;read_buf-&gt;len;
1511       outbytes_left = MAX (channel-&gt;read_buf-&gt;len,
1512                            channel-&gt;encoded_read_buf-&gt;allocated_len
1513                            - channel-&gt;encoded_read_buf-&gt;len - 1); /* 1 for NULL */
1514       outbytes_left = MAX (outbytes_left, 6);
1515 
1516       inbuf = channel-&gt;read_buf-&gt;str;
1517       g_string_set_size (channel-&gt;encoded_read_buf,
1518                          channel-&gt;encoded_read_buf-&gt;len + outbytes_left);
1519       outbuf = channel-&gt;encoded_read_buf-&gt;str + channel-&gt;encoded_read_buf-&gt;len
1520                - outbytes_left;
1521 
1522       errnum = g_iconv (channel-&gt;read_cd, &amp;inbuf, &amp;inbytes_left,
<span class="line-modified">1523             &amp;outbuf, &amp;outbytes_left);</span>
1524       errval = errno;
1525 
1526       g_assert (inbuf + inbytes_left == channel-&gt;read_buf-&gt;str
1527                 + channel-&gt;read_buf-&gt;len);
1528       g_assert (outbuf + outbytes_left == channel-&gt;encoded_read_buf-&gt;str
1529                 + channel-&gt;encoded_read_buf-&gt;len);
1530 
1531       g_string_erase (channel-&gt;read_buf, 0,
<span class="line-modified">1532               channel-&gt;read_buf-&gt;len - inbytes_left);</span>
1533       g_string_truncate (channel-&gt;encoded_read_buf,
<span class="line-modified">1534              channel-&gt;encoded_read_buf-&gt;len - outbytes_left);</span>
1535 
1536       if (errnum == (gsize) -1)
1537         {
1538           switch (errval)
1539             {
1540               case EINVAL:
1541                 if ((oldlen == channel-&gt;encoded_read_buf-&gt;len)
1542                   &amp;&amp; (status == G_IO_STATUS_EOF))
1543                   status = G_IO_STATUS_EOF;
1544                 else
1545                   status = G_IO_STATUS_NORMAL;
1546                 break;
1547               case E2BIG:
1548                 /* Buffer size at least 6, wrote at least on character */
1549                 g_assert (inbuf != channel-&gt;read_buf-&gt;str);
1550                 goto reencode;
1551               case EILSEQ:
1552                 if (oldlen &lt; channel-&gt;encoded_read_buf-&gt;len)
1553                   status = G_IO_STATUS_NORMAL;
1554                 else
</pre>
<hr />
<pre>
1627  * @str_return: (out): The line read from the #GIOChannel, including the
1628  *              line terminator. This data should be freed with g_free()
1629  *              when no longer needed. This is a nul-terminated string.
1630  *              If a @length of zero is returned, this will be %NULL instead.
1631  * @length: (out) (optional): location to store length of the read data, or %NULL
1632  * @terminator_pos: (out) (optional): location to store position of line terminator, or %NULL
1633  * @error: A location to return an error of type #GConvertError
1634  *         or #GIOChannelError
1635  *
1636  * Reads a line, including the terminating character(s),
1637  * from a #GIOChannel into a newly-allocated string.
1638  * @str_return will contain allocated memory if the return
1639  * is %G_IO_STATUS_NORMAL.
1640  *
1641  * Returns: the status of the operation.
1642  **/
1643 GIOStatus
1644 g_io_channel_read_line (GIOChannel  *channel,
1645                         gchar      **str_return,
1646                         gsize       *length,
<span class="line-modified">1647             gsize       *terminator_pos,</span>
<span class="line-modified">1648                 GError     **error)</span>
1649 {
1650   GIOStatus status;
1651   gsize got_length;
1652 
1653   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
1654   g_return_val_if_fail (str_return != NULL, G_IO_STATUS_ERROR);
1655   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<span class="line-modified">1656             G_IO_STATUS_ERROR);</span>
1657   g_return_val_if_fail (channel-&gt;is_readable, G_IO_STATUS_ERROR);
1658 
1659   status = g_io_channel_read_line_backend (channel, &amp;got_length, terminator_pos, error);
1660 
1661   if (length &amp;&amp; status != G_IO_STATUS_ERROR)
1662     *length = got_length;
1663 
1664   if (status == G_IO_STATUS_NORMAL)
1665     {
1666       g_assert (USE_BUF (channel));
1667       *str_return = g_strndup (USE_BUF (channel)-&gt;str, got_length);
1668       g_string_erase (USE_BUF (channel), 0, got_length);
1669     }
1670   else
1671     *str_return = NULL;
1672 
1673   return status;
1674 }
1675 
1676 /**
1677  * g_io_channel_read_line_string:
1678  * @channel: a #GIOChannel
1679  * @buffer: a #GString into which the line will be written.
1680  *          If @buffer already contains data, the old data will
1681  *          be overwritten.
1682  * @terminator_pos: (nullable): location to store position of line terminator, or %NULL
1683  * @error: a location to store an error of type #GConvertError
1684  *         or #GIOChannelError
1685  *
1686  * Reads a line from a #GIOChannel, using a #GString as a buffer.
1687  *
1688  * Returns: the status of the operation.
1689  **/
1690 GIOStatus
1691 g_io_channel_read_line_string (GIOChannel  *channel,
1692                                GString     *buffer,
<span class="line-modified">1693                                gsize       *terminator_pos,</span>
<span class="line-modified">1694                                GError     **error)</span>
1695 {
1696   gsize length;
1697   GIOStatus status;
1698 
1699   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
1700   g_return_val_if_fail (buffer != NULL, G_IO_STATUS_ERROR);
1701   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<span class="line-modified">1702             G_IO_STATUS_ERROR);</span>
1703   g_return_val_if_fail (channel-&gt;is_readable, G_IO_STATUS_ERROR);
1704 
1705   if (buffer-&gt;len &gt; 0)
1706     g_string_truncate (buffer, 0); /* clear out the buffer */
1707 
1708   status = g_io_channel_read_line_backend (channel, &amp;length, terminator_pos, error);
1709 
1710   if (status == G_IO_STATUS_NORMAL)
1711     {
1712       g_assert (USE_BUF (channel));
1713       g_string_append_len (buffer, USE_BUF (channel)-&gt;str, length);
1714       g_string_erase (USE_BUF (channel), 0, length);
1715     }
1716 
1717   return status;
1718 }
1719 
1720 
1721 static GIOStatus
1722 g_io_channel_read_line_backend (GIOChannel  *channel,
</pre>
<hr />
<pre>
1852 
1853       /* If encoding != NULL, valid UTF-8, didn&#39;t overshoot */
1854       g_assert (nextchar == lastchar);
1855 
1856       /* Check for EOF */
1857 
1858       if (status == G_IO_STATUS_EOF)
1859         {
1860           if (channel-&gt;encoding &amp;&amp; channel-&gt;read_buf-&gt;len &gt; 0)
1861             {
1862               g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_PARTIAL_INPUT,
1863                                    _(&quot;Channel terminates in a partial character&quot;));
1864               return G_IO_STATUS_ERROR;
1865             }
1866           line_length = use_buf-&gt;len;
1867           got_term_len = 0;
1868           break;
1869         }
1870 
1871       if (use_buf-&gt;len &gt; line_term_len - 1)
<span class="line-modified">1872     checked_to = use_buf-&gt;len - (line_term_len - 1);</span>
1873       else
<span class="line-modified">1874     checked_to = 0;</span>
1875     }
1876 
1877 done:
1878 
1879   if (terminator_pos)
1880     *terminator_pos = line_length;
1881 
1882   if (length)
1883     *length = line_length + got_term_len;
1884 
1885   return G_IO_STATUS_NORMAL;
1886 }
1887 
1888 /**
1889  * g_io_channel_read_to_end:
1890  * @channel: a #GIOChannel
1891  * @str_return:  (out) (array length=length) (element-type guint8): Location to
1892  *              store a pointer to a string holding the remaining data in the
1893  *              #GIOChannel. This data should be freed with g_free() when no
1894  *              longer needed. This data is terminated by an extra nul
</pre>
<hr />
<pre>
1941       return G_IO_STATUS_ERROR;
1942     }
1943 
1944   if (USE_BUF (channel) == NULL)
1945     {
1946       /* length is already set to zero */
1947       if (str_return)
1948         *str_return = g_strdup (&quot;&quot;);
1949     }
1950   else
1951     {
1952       if (length)
1953         *length = USE_BUF (channel)-&gt;len;
1954 
1955       if (str_return)
1956         *str_return = g_string_free (USE_BUF (channel), FALSE);
1957       else
1958         g_string_free (USE_BUF (channel), TRUE);
1959 
1960       if (channel-&gt;encoding)
<span class="line-modified">1961     channel-&gt;encoded_read_buf = NULL;</span>
1962       else
<span class="line-modified">1963     channel-&gt;read_buf = NULL;</span>
1964     }
1965 
1966   return G_IO_STATUS_NORMAL;
1967 }
1968 
1969 /**
1970  * g_io_channel_read_chars:
1971  * @channel: a #GIOChannel
1972  * @buf: (out caller-allocates) (array length=count) (element-type guint8):
1973  *     a buffer to read data into
1974  * @count: (in): the size of the buffer. Note that the buffer may not be
1975  *     complelely filled even if there is data in the buffer if the
1976  *     remaining data is not a complete character.
1977  * @bytes_read: (out) (optional): The number of bytes read. This may be
1978  *     zero even on success if count &lt; 6 and the channel&#39;s encoding
1979  *     is non-%NULL. This indicates that the next UTF-8 character is
1980  *     too wide for the buffer.
1981  * @error: a location to return an error of type #GConvertError
1982  *     or #GIOChannelError.
1983  *
</pre>
<hr />
<pre>
2083   if (bytes_read)
2084     *bytes_read = got_bytes;
2085 
2086   return G_IO_STATUS_NORMAL;
2087 }
2088 
2089 /**
2090  * g_io_channel_read_unichar:
2091  * @channel: a #GIOChannel
2092  * @thechar: (out): a location to return a character
2093  * @error: a location to return an error of type #GConvertError
2094  *         or #GIOChannelError
2095  *
2096  * Reads a Unicode character from @channel.
2097  * This function cannot be called on a channel with %NULL encoding.
2098  *
2099  * Returns: a #GIOStatus
2100  **/
2101 GIOStatus
2102 g_io_channel_read_unichar (GIOChannel  *channel,
<span class="line-modified">2103                gunichar    *thechar,</span>
<span class="line-modified">2104                GError     **error)</span>
2105 {
2106   GIOStatus status = G_IO_STATUS_NORMAL;
2107 
2108   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
2109   g_return_val_if_fail (channel-&gt;encoding != NULL, G_IO_STATUS_ERROR);
2110   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<span class="line-modified">2111             G_IO_STATUS_ERROR);</span>
2112   g_return_val_if_fail (channel-&gt;is_readable, G_IO_STATUS_ERROR);
2113 
2114   while (BUF_LEN (channel-&gt;encoded_read_buf) == 0 &amp;&amp; status == G_IO_STATUS_NORMAL)
2115     status = g_io_channel_fill_buffer (channel, error);
2116 
2117   /* Only return an error if we have no data */
2118 
2119   if (BUF_LEN (USE_BUF (channel)) == 0)
2120     {
2121       g_assert (status != G_IO_STATUS_NORMAL);
2122 
2123       if (status == G_IO_STATUS_EOF &amp;&amp; BUF_LEN (channel-&gt;read_buf) &gt; 0)
2124         {
2125           g_set_error_literal (error, G_CONVERT_ERROR,
2126                                G_CONVERT_ERROR_PARTIAL_INPUT,
2127                                _(&quot;Leftover unconverted data in read buffer&quot;));
2128           status = G_IO_STATUS_ERROR;
2129         }
2130 
2131       if (thechar)
</pre>
<hr />
<pre>
2157  *                 even if the return value is not %G_IO_STATUS_NORMAL.
2158  *                 If the return value is %G_IO_STATUS_NORMAL and the
2159  *                 channel is blocking, this will always be equal
2160  *                 to @count if @count &gt;= 0.
2161  * @error: a location to return an error of type #GConvertError
2162  *         or #GIOChannelError
2163  *
2164  * Replacement for g_io_channel_write() with the new API.
2165  *
2166  * On seekable channels with encodings other than %NULL or UTF-8, generic
2167  * mixing of reading and writing is not allowed. A call to g_io_channel_write_chars ()
2168  * may only be made on a channel from which data has been read in the
2169  * cases described in the documentation for g_io_channel_set_encoding ().
2170  *
2171  * Returns: the status of the operation.
2172  **/
2173 GIOStatus
2174 g_io_channel_write_chars (GIOChannel   *channel,
2175                           const gchar  *buf,
2176                           gssize        count,
<span class="line-modified">2177               gsize        *bytes_written,</span>
2178                           GError      **error)
2179 {

2180   GIOStatus status;
2181   gssize wrote_bytes = 0;
2182 
2183   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
2184   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<span class="line-modified">2185             G_IO_STATUS_ERROR);</span>
2186   g_return_val_if_fail (channel-&gt;is_writeable, G_IO_STATUS_ERROR);
2187 
2188   if ((count &lt; 0) &amp;&amp; buf)
2189     count = strlen (buf);

2190 
<span class="line-modified">2191   if (count == 0)</span>
2192     {
2193       if (bytes_written)
2194         *bytes_written = 0;
2195       return G_IO_STATUS_NORMAL;
2196     }
2197 
2198   g_return_val_if_fail (buf != NULL, G_IO_STATUS_ERROR);
<span class="line-modified">2199   g_return_val_if_fail (count &gt; 0, G_IO_STATUS_ERROR);</span>
2200 
2201   /* Raw write case */
2202 
2203   if (!channel-&gt;use_buffer)
2204     {
2205       gsize tmp_bytes;
2206 
2207       g_assert (!channel-&gt;write_buf || channel-&gt;write_buf-&gt;len == 0);
2208       g_assert (channel-&gt;partial_write_buf[0] == &#39;\0&#39;);
2209 
<span class="line-modified">2210       status = channel-&gt;funcs-&gt;io_write (channel, buf, count, &amp;tmp_bytes, error);</span>

2211 
2212       if (bytes_written)
<span class="line-modified">2213     *bytes_written = tmp_bytes;</span>
2214 
2215       return status;
2216     }
2217 
2218   /* General case */
2219 
2220   if (channel-&gt;is_seekable &amp;&amp; (( BUF_LEN (channel-&gt;read_buf) &gt; 0)
2221     || (BUF_LEN (channel-&gt;encoded_read_buf) &gt; 0)))
2222     {
2223       if (channel-&gt;do_encode &amp;&amp; BUF_LEN (channel-&gt;encoded_read_buf) &gt; 0)
2224         {
2225           g_warning (&quot;Mixed reading and writing not allowed on encoded files&quot;);
2226           return G_IO_STATUS_ERROR;
2227         }
2228       status = g_io_channel_seek_position (channel, 0, G_SEEK_CUR, error);
2229       if (status != G_IO_STATUS_NORMAL)
2230         {
2231           if (bytes_written)
2232             *bytes_written = 0;
2233           return status;
</pre>
<hr />
<pre>
2266           if (status != G_IO_STATUS_NORMAL)
2267             {
2268               if (status == G_IO_STATUS_AGAIN &amp;&amp; wrote_bytes &gt; 0)
2269                 status = G_IO_STATUS_NORMAL;
2270               if (bytes_written)
2271                 *bytes_written = wrote_bytes;
2272               return status;
2273             }
2274         }
2275 
2276       space_in_buf = MAX (channel-&gt;buf_size, channel-&gt;write_buf-&gt;allocated_len - 1)
2277                      - channel-&gt;write_buf-&gt;len; /* 1 for NULL */
2278 
2279       /* This is only true because g_io_channel_set_buffer_size ()
2280        * ensures that channel-&gt;buf_size &gt;= MAX_CHAR_SIZE.
2281        */
2282       g_assert (space_in_buf &gt;= MAX_CHAR_SIZE);
2283 
2284       if (!channel-&gt;encoding)
2285         {
<span class="line-modified">2286           gssize write_this = MIN (space_in_buf, count - wrote_bytes);</span>
2287 
2288           g_string_append_len (channel-&gt;write_buf, buf, write_this);
2289           buf += write_this;
2290           wrote_bytes += write_this;
2291         }
2292       else
2293         {
2294           const gchar *from_buf;
2295           gsize from_buf_len, from_buf_old_len, left_len;
2296           gsize err;
2297           gint errnum;
2298 
2299           if (channel-&gt;partial_write_buf[0] != &#39;\0&#39;)
2300             {
2301               g_assert (wrote_bytes == 0);
2302 
2303               from_buf = channel-&gt;partial_write_buf;
2304               from_buf_old_len = strlen (channel-&gt;partial_write_buf);
2305               g_assert (from_buf_old_len &gt; 0);
<span class="line-modified">2306               from_buf_len = MIN (6, from_buf_old_len + count);</span>
2307 
2308               memcpy (channel-&gt;partial_write_buf + from_buf_old_len, buf,
2309                       from_buf_len - from_buf_old_len);
2310             }
2311           else
2312             {
2313               from_buf = buf;
<span class="line-modified">2314               from_buf_len = count - wrote_bytes;</span>
2315               from_buf_old_len = 0;
2316             }
2317 
2318 reconvert:
2319 
2320           if (!channel-&gt;do_encode) /* UTF-8 encoding */
2321             {
2322               const gchar *badchar;
2323               gsize try_len = MIN (from_buf_len, space_in_buf);
2324 
2325               /* UTF-8, just validate, emulate g_iconv */
2326 
<span class="line-modified">2327               if (!_g_utf8_validate_len (from_buf, try_len, &amp;badchar))</span>
2328                 {
2329                   gunichar try_char;
2330                   gsize incomplete_len = from_buf + try_len - badchar;
2331 
2332                   left_len = from_buf + from_buf_len - badchar;
2333 
2334                   try_char = g_utf8_get_char_validated (badchar, incomplete_len);
2335 
2336                   switch (try_char)
2337                     {
2338                       case -2:
2339                         g_assert (incomplete_len &lt; 6);
2340                         if (try_len == from_buf_len)
2341                           {
2342                             errnum = EINVAL;
2343                             err = (gsize) -1;
2344                           }
2345                         else
2346                           {
2347                             errnum = 0;
</pre>
<hr />
<pre>
2373             }
2374           else
2375             {
2376                gchar *outbuf;
2377 
2378                left_len = from_buf_len;
2379                g_string_set_size (channel-&gt;write_buf, channel-&gt;write_buf-&gt;len
2380                                   + space_in_buf);
2381                outbuf = channel-&gt;write_buf-&gt;str + channel-&gt;write_buf-&gt;len
2382                         - space_in_buf;
2383                err = g_iconv (channel-&gt;write_cd, (gchar **) &amp;from_buf, &amp;left_len,
2384                               &amp;outbuf, &amp;space_in_buf);
2385                errnum = errno;
2386                g_string_truncate (channel-&gt;write_buf, channel-&gt;write_buf-&gt;len
2387                                   - space_in_buf);
2388             }
2389 
2390           if (err == (gsize) -1)
2391             {
2392               switch (errnum)
<span class="line-modified">2393             {</span>
2394                   case EINVAL:
2395                     g_assert (left_len &lt; 6);
2396 
2397                     if (from_buf_old_len == 0)
2398                       {
2399                         /* Not from partial_write_buf */
2400 
2401                         memcpy (channel-&gt;partial_write_buf, from_buf, left_len);
2402                         channel-&gt;partial_write_buf[left_len] = &#39;\0&#39;;
2403                         if (bytes_written)
<span class="line-modified">2404                           *bytes_written = count;</span>
2405                         return G_IO_STATUS_NORMAL;
2406                       }
2407 
2408                     /* Working in partial_write_buf */
2409 
2410                     if (left_len == from_buf_len)
2411                       {
2412                         /* Didn&#39;t convert anything, must still have
2413                          * less than a full character
2414                          */
2415 
<span class="line-modified">2416                         g_assert (count == from_buf_len - from_buf_old_len);</span>
2417 
2418                         channel-&gt;partial_write_buf[from_buf_len] = &#39;\0&#39;;
2419 
2420                         if (bytes_written)
<span class="line-modified">2421                           *bytes_written = count;</span>
2422 
2423                         return G_IO_STATUS_NORMAL;
2424                       }
2425 
2426                     g_assert (from_buf_len - left_len &gt;= from_buf_old_len);
2427 
2428                     /* We converted all the old data. This is fine */
2429 
2430                     break;
2431                   case E2BIG:
2432                     if (from_buf_len == left_len)
2433                       {
2434                         /* Nothing was written, add enough space for
2435                          * at least one character.
2436                          */
2437                         space_in_buf += MAX_CHAR_SIZE;
2438                         goto reconvert;
2439                       }
2440                     break;
2441                   case EILSEQ:
</pre>
<hr />
<pre>
2463                 }
2464             }
2465 
2466           g_assert (from_buf_len - left_len &gt;= from_buf_old_len);
2467 
2468           wrote_bytes += from_buf_len - left_len - from_buf_old_len;
2469 
2470           if (from_buf_old_len &gt; 0)
2471             {
2472               /* We were working in partial_write_buf */
2473 
2474               buf += from_buf_len - left_len - from_buf_old_len;
2475               channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
2476             }
2477           else
2478             buf = from_buf;
2479         }
2480     }
2481 
2482   if (bytes_written)
<span class="line-modified">2483     *bytes_written = count;</span>
2484 
2485   return G_IO_STATUS_NORMAL;
2486 }
2487 
2488 /**
2489  * g_io_channel_write_unichar:
2490  * @channel: a #GIOChannel
2491  * @thechar: a character
2492  * @error: location to return an error of type #GConvertError
2493  *         or #GIOChannelError
2494  *
2495  * Writes a Unicode character to @channel.
2496  * This function cannot be called on a channel with %NULL encoding.
2497  *
2498  * Returns: a #GIOStatus
2499  **/
2500 GIOStatus
2501 g_io_channel_write_unichar (GIOChannel  *channel,
<span class="line-modified">2502                 gunichar     thechar,</span>
<span class="line-modified">2503                 GError     **error)</span>
2504 {
2505   GIOStatus status;
2506   gchar static_buf[6];
2507   gsize char_len, wrote_len;
2508 
2509   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
2510   g_return_val_if_fail (channel-&gt;encoding != NULL, G_IO_STATUS_ERROR);
2511   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<span class="line-modified">2512             G_IO_STATUS_ERROR);</span>
2513   g_return_val_if_fail (channel-&gt;is_writeable, G_IO_STATUS_ERROR);
2514 
2515   char_len = g_unichar_to_utf8 (thechar, static_buf);
2516 
2517   if (channel-&gt;partial_write_buf[0] != &#39;\0&#39;)
2518     {
2519       g_warning (&quot;Partial character written before writing unichar.&quot;);
2520       channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
2521     }
2522 
2523   status = g_io_channel_write_chars (channel, static_buf,
2524                                      char_len, &amp;wrote_len, error);
2525 
2526   /* We validate UTF-8, so we can&#39;t get a partial write */
2527 
2528   g_assert (wrote_len == char_len || status != G_IO_STATUS_NORMAL);
2529 
2530   return status;
2531 }
2532 
</pre>
</td>
<td>
<hr />
<pre>
  22  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  23  * file for a list of people on the GLib Team.  See the ChangeLog
  24  * files for a list of changes.  These files are distributed with
  25  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  26  */
  27 
  28 /*
  29  * MT safe
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 
  34 #include &lt;string.h&gt;
  35 #include &lt;errno.h&gt;
  36 
  37 #include &quot;giochannel.h&quot;
  38 
  39 #include &quot;gstrfuncs.h&quot;
  40 #include &quot;gtestutils.h&quot;
  41 #include &quot;glibintl.h&quot;

  42 
  43 
  44 /**
  45  * SECTION:iochannels
  46  * @title: IO Channels
  47  * @short_description: portable support for using files, pipes and sockets
  48  * @see_also: g_io_add_watch(), g_io_add_watch_full(), g_source_remove(),
  49  *     #GMainLoop
  50  *
  51  * The #GIOChannel data type aims to provide a portable method for
  52  * using file descriptors, pipes, and sockets, and integrating them
  53  * into the [main event loop][glib-The-Main-Event-Loop]. Currently,
  54  * full support is available on UNIX platforms, support for Windows
  55  * is only partially complete.
  56  *
  57  * To create a new #GIOChannel on UNIX systems use
  58  * g_io_channel_unix_new(). This works for plain file descriptors,
  59  * pipes and sockets. Alternatively, a channel can be created for a
  60  * file in a system independent manner using g_io_channel_new_file().
  61  *
</pre>
<hr />
<pre>
 135  * @G_IO_STATUS_EOF: End of file.
 136  * @G_IO_STATUS_AGAIN: Resource temporarily unavailable.
 137  *
 138  * Stati returned by most of the #GIOFuncs functions.
 139  **/
 140 
 141 /**
 142  * GIOError:
 143  * @G_IO_ERROR_NONE: no error
 144  * @G_IO_ERROR_AGAIN: an EAGAIN error occurred
 145  * @G_IO_ERROR_INVAL: an EINVAL error occurred
 146  * @G_IO_ERROR_UNKNOWN: another error occurred
 147  *
 148  * #GIOError is only used by the deprecated functions
 149  * g_io_channel_read(), g_io_channel_write(), and g_io_channel_seek().
 150  **/
 151 
 152 #define G_IO_NICE_BUF_SIZE  1024
 153 
 154 /* This needs to be as wide as the largest character in any possible encoding */
<span class="line-modified"> 155 #define MAX_CHAR_SIZE   10</span>
 156 
 157 /* Some simplifying macros, which reduce the need to worry whether the
 158  * buffers have been allocated. These also make USE_BUF () an lvalue,
 159  * which is used in g_io_channel_read_to_end ().
 160  */
<span class="line-modified"> 161 #define USE_BUF(channel)  ((channel)-&gt;encoding ? (channel)-&gt;encoded_read_buf \</span>
<span class="line-modified"> 162          : (channel)-&gt;read_buf)</span>
<span class="line-modified"> 163 #define BUF_LEN(string)   ((string) ? (string)-&gt;len : 0)</span>
<span class="line-modified"> 164 </span>
<span class="line-modified"> 165 static GIOError   g_io_error_get_from_g_error (GIOStatus    status,</span>
<span class="line-modified"> 166                GError      *err);</span>
<span class="line-modified"> 167 static void   g_io_channel_purge    (GIOChannel  *channel);</span>
<span class="line-modified"> 168 static GIOStatus  g_io_channel_fill_buffer  (GIOChannel  *channel,</span>
<span class="line-modified"> 169                GError     **err);</span>
<span class="line-modified"> 170 static GIOStatus  g_io_channel_read_line_backend  (GIOChannel  *channel,</span>
<span class="line-modified"> 171                gsize       *length,</span>
<span class="line-modified"> 172                gsize       *terminator_pos,</span>
<span class="line-modified"> 173                GError     **error);</span>
 174 
 175 /**
 176  * g_io_channel_init:
 177  * @channel: a #GIOChannel
 178  *
 179  * Initializes a #GIOChannel struct.
 180  *
 181  * This is called by each of the above functions when creating a
 182  * #GIOChannel, and so is not often needed by the application
 183  * programmer (unless you are creating a new type of #GIOChannel).
 184  */
 185 void
 186 g_io_channel_init (GIOChannel *channel)
 187 {
 188   channel-&gt;ref_count = 1;
 189   channel-&gt;encoding = g_strdup (&quot;UTF-8&quot;);
 190   channel-&gt;line_term = NULL;
 191   channel-&gt;line_term_len = 0;
 192   channel-&gt;buf_size = G_IO_NICE_BUF_SIZE;
 193   channel-&gt;read_cd = (GIConv) -1;
</pre>
<hr />
<pre>
 241       else
 242         g_io_channel_purge (channel);
 243       g_free (channel-&gt;encoding);
 244       if (channel-&gt;read_cd != (GIConv) -1)
 245         g_iconv_close (channel-&gt;read_cd);
 246       if (channel-&gt;write_cd != (GIConv) -1)
 247         g_iconv_close (channel-&gt;write_cd);
 248       g_free (channel-&gt;line_term);
 249       if (channel-&gt;read_buf)
 250         g_string_free (channel-&gt;read_buf, TRUE);
 251       if (channel-&gt;write_buf)
 252         g_string_free (channel-&gt;write_buf, TRUE);
 253       if (channel-&gt;encoded_read_buf)
 254         g_string_free (channel-&gt;encoded_read_buf, TRUE);
 255       channel-&gt;funcs-&gt;io_free (channel);
 256     }
 257 }
 258 
 259 static GIOError
 260 g_io_error_get_from_g_error (GIOStatus  status,
<span class="line-modified"> 261            GError    *err)</span>
 262 {
 263   switch (status)
 264     {
 265       case G_IO_STATUS_NORMAL:
 266       case G_IO_STATUS_EOF:
 267         return G_IO_ERROR_NONE;
 268       case G_IO_STATUS_AGAIN:
 269         return G_IO_ERROR_AGAIN;
 270       case G_IO_STATUS_ERROR:
<span class="line-modified"> 271   g_return_val_if_fail (err != NULL, G_IO_ERROR_UNKNOWN);</span>
 272 
 273         if (err-&gt;domain != G_IO_CHANNEL_ERROR)
 274           return G_IO_ERROR_UNKNOWN;
 275         switch (err-&gt;code)
 276           {
 277             case G_IO_CHANNEL_ERROR_INVAL:
 278               return G_IO_ERROR_INVAL;
 279             default:
 280               return G_IO_ERROR_UNKNOWN;
 281           }
 282       default:
 283         g_assert_not_reached ();
 284     }
 285 }
 286 
 287 /**
 288  * g_io_channel_read:
 289  * @channel: a #GIOChannel
 290  * @buf: a buffer to read the data into (which should be at least
 291  *       count bytes long)
 292  * @count: the number of bytes to read from the #GIOChannel
 293  * @bytes_read: returns the number of bytes actually read
 294  *
 295  * Reads data from a #GIOChannel.
 296  *
 297  * Returns: %G_IO_ERROR_NONE if the operation was successful.
 298  *
 299  * Deprecated:2.2: Use g_io_channel_read_chars() instead.
 300  **/
 301 GIOError
 302 g_io_channel_read (GIOChannel *channel,
<span class="line-modified"> 303        gchar      *buf,</span>
<span class="line-modified"> 304        gsize       count,</span>
<span class="line-modified"> 305        gsize      *bytes_read)</span>
 306 {
 307   GError *err = NULL;
 308   GIOError error;
 309   GIOStatus status;
 310 
 311   g_return_val_if_fail (channel != NULL, G_IO_ERROR_UNKNOWN);
 312   g_return_val_if_fail (bytes_read != NULL, G_IO_ERROR_UNKNOWN);
 313 
 314   if (count == 0)
 315     {
 316       if (bytes_read)
 317         *bytes_read = 0;
 318       return G_IO_ERROR_NONE;
 319     }
 320 
 321   g_return_val_if_fail (buf != NULL, G_IO_ERROR_UNKNOWN);
 322 
 323   status = channel-&gt;funcs-&gt;io_read (channel, buf, count, bytes_read, &amp;err);
 324 
 325   error = g_io_error_get_from_g_error (status, err);
</pre>
<hr />
<pre>
 328     g_error_free (err);
 329 
 330   return error;
 331 }
 332 
 333 /**
 334  * g_io_channel_write:
 335  * @channel:  a #GIOChannel
 336  * @buf: the buffer containing the data to write
 337  * @count: the number of bytes to write
 338  * @bytes_written: the number of bytes actually written
 339  *
 340  * Writes data to a #GIOChannel.
 341  *
 342  * Returns:  %G_IO_ERROR_NONE if the operation was successful.
 343  *
 344  * Deprecated:2.2: Use g_io_channel_write_chars() instead.
 345  **/
 346 GIOError
 347 g_io_channel_write (GIOChannel  *channel,
<span class="line-modified"> 348         const gchar *buf,</span>
<span class="line-modified"> 349         gsize        count,</span>
<span class="line-modified"> 350         gsize       *bytes_written)</span>
 351 {
 352   GError *err = NULL;
 353   GIOError error;
 354   GIOStatus status;
 355 
 356   g_return_val_if_fail (channel != NULL, G_IO_ERROR_UNKNOWN);
 357   g_return_val_if_fail (bytes_written != NULL, G_IO_ERROR_UNKNOWN);
 358 
 359   status = channel-&gt;funcs-&gt;io_write (channel, buf, count, bytes_written, &amp;err);
 360 
 361   error = g_io_error_get_from_g_error (status, err);
 362 
 363   if (err)
 364     g_error_free (err);
 365 
 366   return error;
 367 }
 368 
 369 /**
 370  * g_io_channel_seek:
 371  * @channel: a #GIOChannel
 372  * @offset: an offset, in bytes, which is added to the position specified
 373  *          by @type
 374  * @type: the position in the file, which can be %G_SEEK_CUR (the current
 375  *        position), %G_SEEK_SET (the start of the file), or %G_SEEK_END
 376  *        (the end of the file)
 377  *
 378  * Sets the current position in the #GIOChannel, similar to the standard
 379  * library function fseek().
 380  *
 381  * Returns: %G_IO_ERROR_NONE if the operation was successful.
 382  *
 383  * Deprecated:2.2: Use g_io_channel_seek_position() instead.
 384  **/
 385 GIOError
 386 g_io_channel_seek (GIOChannel *channel,
<span class="line-modified"> 387        gint64      offset,</span>
<span class="line-modified"> 388        GSeekType   type)</span>
 389 {
 390   GError *err = NULL;
 391   GIOError error;
 392   GIOStatus status;
 393 
 394   g_return_val_if_fail (channel != NULL, G_IO_ERROR_UNKNOWN);
 395   g_return_val_if_fail (channel-&gt;is_seekable, G_IO_ERROR_UNKNOWN);
 396 
 397   switch (type)
 398     {
 399       case G_SEEK_CUR:
 400       case G_SEEK_SET:
 401       case G_SEEK_END:
 402         break;
 403       default:
 404         g_warning (&quot;g_io_channel_seek: unknown seek type&quot;);
 405         return G_IO_ERROR_UNKNOWN;
 406     }
 407 
 408   status = channel-&gt;funcs-&gt;io_seek (channel, offset, type, &amp;err);
</pre>
<hr />
<pre>
 465   channel-&gt;close_on_unref = FALSE; /* Because we already did */
 466   channel-&gt;is_readable = FALSE;
 467   channel-&gt;is_writeable = FALSE;
 468   channel-&gt;is_seekable = FALSE;
 469 }
 470 
 471 /**
 472  * g_io_channel_shutdown:
 473  * @channel: a #GIOChannel
 474  * @flush: if %TRUE, flush pending
 475  * @err: location to store a #GIOChannelError
 476  *
 477  * Close an IO channel. Any pending data to be written will be
 478  * flushed if @flush is %TRUE. The channel will not be freed until the
 479  * last reference is dropped using g_io_channel_unref().
 480  *
 481  * Returns: the status of the operation.
 482  **/
 483 GIOStatus
 484 g_io_channel_shutdown (GIOChannel  *channel,
<span class="line-modified"> 485            gboolean     flush,</span>
<span class="line-modified"> 486            GError     **err)</span>
 487 {
 488   GIOStatus status, result;
 489   GError *tmperr = NULL;
 490 
 491   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
 492   g_return_val_if_fail (err == NULL || *err == NULL, G_IO_STATUS_ERROR);
 493 
 494   if (channel-&gt;write_buf &amp;&amp; channel-&gt;write_buf-&gt;len &gt; 0)
 495     {
 496       if (flush)
 497         {
 498           GIOFlags flags;
 499 
 500           /* Set the channel to blocking, to avoid a busy loop
 501            */
 502           flags = g_io_channel_get_flags (channel);
 503           /* Ignore any errors here, they&#39;re irrelevant */
 504           g_io_channel_set_flags (channel, flags &amp; ~G_IO_FLAG_NONBLOCK, NULL);
 505 
 506           result = g_io_channel_flush (channel, &amp;tmperr);
</pre>
<hr />
<pre>
 591  * g_io_create_watch:
 592  * @channel: a #GIOChannel to watch
 593  * @condition: conditions to watch for
 594  *
 595  * Creates a #GSource that&#39;s dispatched when @condition is met for the
 596  * given @channel. For example, if condition is #G_IO_IN, the source will
 597  * be dispatched when there&#39;s data available for reading.
 598  *
 599  * g_io_add_watch() is a simpler interface to this same functionality, for
 600  * the case where you want to add the source to the default main loop context
 601  * at the default priority.
 602  *
 603  * On Windows, polling a #GSource created to watch a channel for a socket
 604  * puts the socket in non-blocking mode. This is a side-effect of the
 605  * implementation and unavoidable.
 606  *
 607  * Returns: a new #GSource
 608  */
 609 GSource *
 610 g_io_create_watch (GIOChannel   *channel,
<span class="line-modified"> 611        GIOCondition  condition)</span>
 612 {
 613   g_return_val_if_fail (channel != NULL, NULL);
 614 
 615   return channel-&gt;funcs-&gt;io_create_watch (channel, condition);
 616 }
 617 
 618 /**
 619  * g_io_add_watch_full: (rename-to g_io_add_watch)
 620  * @channel: a #GIOChannel
 621  * @priority: the priority of the #GIOChannel source
 622  * @condition: the condition to watch for
 623  * @func: the function to call when the condition is satisfied
 624  * @user_data: user data to pass to @func
 625  * @notify: the function to call when the source is removed
 626  *
 627  * Adds the #GIOChannel into the default main loop context
 628  * with the given priority.
 629  *
 630  * This internally creates a main loop source using g_io_create_watch()
 631  * and attaches it to the main loop context with g_source_attach().
 632  * You can do these steps manually if you need greater control.
 633  *
 634  * Returns: the event source id
 635  */
 636 guint
 637 g_io_add_watch_full (GIOChannel    *channel,
<span class="line-modified"> 638          gint           priority,</span>
<span class="line-modified"> 639          GIOCondition   condition,</span>
<span class="line-modified"> 640          GIOFunc        func,</span>
<span class="line-modified"> 641          gpointer       user_data,</span>
<span class="line-modified"> 642          GDestroyNotify notify)</span>
 643 {
 644   GSource *source;
 645   guint id;
 646 
 647   g_return_val_if_fail (channel != NULL, 0);
 648 
 649   source = g_io_create_watch (channel, condition);
 650 
 651   if (priority != G_PRIORITY_DEFAULT)
 652     g_source_set_priority (source, priority);
 653   g_source_set_callback (source, (GSourceFunc)func, user_data, notify);
 654 
 655   id = g_source_attach (source, NULL);
 656   g_source_unref (source);
 657 
 658   return id;
 659 }
 660 
 661 /**
 662  * g_io_add_watch:
</pre>
<hr />
<pre>
 681  * on a #GIOChannel is satisfied.
 682  *
 683  * Returns: the function should return %FALSE if the event source
 684  *          should be removed
 685  **/
 686 /**
 687  * GIOCondition:
 688  * @G_IO_IN: There is data to read.
 689  * @G_IO_OUT: Data can be written (without blocking).
 690  * @G_IO_PRI: There is urgent data to read.
 691  * @G_IO_ERR: Error condition.
 692  * @G_IO_HUP: Hung up (the connection has been broken, usually for
 693  *            pipes and sockets).
 694  * @G_IO_NVAL: Invalid request. The file descriptor is not open.
 695  *
 696  * A bitwise combination representing a condition to watch for on an
 697  * event source.
 698  **/
 699 guint
 700 g_io_add_watch (GIOChannel   *channel,
<span class="line-modified"> 701     GIOCondition  condition,</span>
<span class="line-modified"> 702     GIOFunc       func,</span>
<span class="line-modified"> 703     gpointer      user_data)</span>
 704 {
 705   return g_io_add_watch_full (channel, G_PRIORITY_DEFAULT, condition, func, user_data, NULL);
 706 }
 707 
 708 /**
 709  * g_io_channel_get_buffer_condition:
 710  * @channel: A #GIOChannel
 711  *
 712  * This function returns a #GIOCondition depending on whether there
 713  * is data to be read/space to write data in the internal buffers in
 714  * the #GIOChannel. Only the flags %G_IO_IN and %G_IO_OUT may be set.
 715  *
 716  * Returns: A #GIOCondition
 717  **/
 718 GIOCondition
 719 g_io_channel_get_buffer_condition (GIOChannel *channel)
 720 {
 721   GIOCondition condition = 0;
 722 
 723   if (channel-&gt;encoding)
</pre>
<hr />
<pre>
 864   return channel-&gt;buf_size;
 865 }
 866 
 867 /**
 868  * g_io_channel_set_line_term:
 869  * @channel: a #GIOChannel
 870  * @line_term: (nullable): The line termination string. Use %NULL for
 871  *             autodetect.  Autodetection breaks on &quot;\n&quot;, &quot;\r\n&quot;, &quot;\r&quot;, &quot;\0&quot;,
 872  *             and the Unicode paragraph separator. Autodetection should not be
 873  *             used for anything other than file-based channels.
 874  * @length: The length of the termination string. If -1 is passed, the
 875  *          string is assumed to be nul-terminated. This option allows
 876  *          termination strings with embedded nuls.
 877  *
 878  * This sets the string that #GIOChannel uses to determine
 879  * where in the file a line break occurs.
 880  **/
 881 void
 882 g_io_channel_set_line_term (GIOChannel  *channel,
 883                             const gchar *line_term,
<span class="line-modified"> 884           gint         length)</span>
 885 {
 886   g_return_if_fail (channel != NULL);
 887   g_return_if_fail (line_term == NULL || length != 0); /* Disallow &quot;&quot; */
 888 
 889   if (line_term == NULL)
 890     length = 0;
 891   else if (length &lt; 0)
 892     length = strlen (line_term);
 893 
 894   g_free (channel-&gt;line_term);
 895   channel-&gt;line_term = line_term ? g_memdup (line_term, length) : NULL;
 896   channel-&gt;line_term_len = length;
 897 }
 898 
 899 /**
 900  * g_io_channel_get_line_term:
 901  * @channel: a #GIOChannel
 902  * @length: a location to return the length of the line terminator
 903  *
 904  * This returns the string that #GIOChannel uses to determine
 905  * where in the file a line break occurs. A value of %NULL
 906  * indicates autodetection.
 907  *
 908  * Returns: The line termination string. This value
 909  *   is owned by GLib and must not be freed.
 910  **/
 911 const gchar *
 912 g_io_channel_get_line_term (GIOChannel *channel,
<span class="line-modified"> 913           gint       *length)</span>
 914 {
 915   g_return_val_if_fail (channel != NULL, NULL);
 916 
 917   if (length)
 918     *length = channel-&gt;line_term_len;
 919 
 920   return channel-&gt;line_term;
 921 }
 922 
 923 /**
 924  * g_io_channel_set_flags:
 925  * @channel: a #GIOChannel
 926  * @flags: the flags to set on the IO channel
 927  * @error: A location to return an error of type #GIOChannelError
 928  *
 929  * Sets the (writeable) flags in @channel to (@flags &amp; %G_IO_FLAG_SET_MASK).
 930  *
 931  * Returns: the status of the operation.
 932  **/
 933 /**
</pre>
<hr />
<pre>
 947  * @G_IO_FLAG_IS_SEEKABLE: indicates that the io channel is seekable,
 948  *     i.e. that g_io_channel_seek_position() can be used on it.
 949  *     This flag cannot be changed.
 950  * @G_IO_FLAG_MASK: the mask that specifies all the valid flags.
 951  * @G_IO_FLAG_GET_MASK: the mask of the flags that are returned from
 952  *     g_io_channel_get_flags()
 953  * @G_IO_FLAG_SET_MASK: the mask of the flags that the user can modify
 954  *     with g_io_channel_set_flags()
 955  *
 956  * Specifies properties of a #GIOChannel. Some of the flags can only be
 957  * read with g_io_channel_get_flags(), but not changed with
 958  * g_io_channel_set_flags().
 959  */
 960 GIOStatus
 961 g_io_channel_set_flags (GIOChannel  *channel,
 962                         GIOFlags     flags,
 963                         GError     **error)
 964 {
 965   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
 966   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<span class="line-modified"> 967       G_IO_STATUS_ERROR);</span>
 968 
 969   return (*channel-&gt;funcs-&gt;io_set_flags) (channel,
<span class="line-modified"> 970             flags &amp; G_IO_FLAG_SET_MASK,</span>
<span class="line-modified"> 971             error);</span>
 972 }
 973 
 974 /**
 975  * g_io_channel_get_flags:
 976  * @channel: a #GIOChannel
 977  *
 978  * Gets the current flags for a #GIOChannel, including read-only
 979  * flags such as %G_IO_FLAG_IS_READABLE.
 980  *
 981  * The values of the flags %G_IO_FLAG_IS_READABLE and %G_IO_FLAG_IS_WRITABLE
 982  * are cached for internal use by the channel when it is created.
 983  * If they should change at some later point (e.g. partial shutdown
 984  * of a socket with the UNIX shutdown() function), the user
 985  * should immediately call g_io_channel_get_flags() to update
 986  * the internal values of these flags.
 987  *
 988  * Returns: the flags which are set on the channel
 989  **/
 990 GIOFlags
 991 g_io_channel_get_flags (GIOChannel *channel)
</pre>
<hr />
<pre>
1006     flags |= G_IO_FLAG_IS_WRITABLE;
1007 
1008   return flags;
1009 }
1010 
1011 /**
1012  * g_io_channel_set_close_on_unref:
1013  * @channel: a #GIOChannel
1014  * @do_close: Whether to close the channel on the final unref of
1015  *            the GIOChannel data structure.
1016  *
1017  * Whether to close the channel on the final unref of the #GIOChannel
1018  * data structure. The default value of this is %TRUE for channels
1019  * created by g_io_channel_new_file (), and %FALSE for all other channels.
1020  *
1021  * Setting this flag to %TRUE for a channel you have already closed
1022  * can cause problems when the final reference to the #GIOChannel is dropped.
1023  **/
1024 void
1025 g_io_channel_set_close_on_unref (GIOChannel *channel,
<span class="line-modified">1026          gboolean    do_close)</span>
1027 {
1028   g_return_if_fail (channel != NULL);
1029 
1030   channel-&gt;close_on_unref = do_close;
1031 }
1032 
1033 /**
1034  * g_io_channel_get_close_on_unref:
1035  * @channel: a #GIOChannel.
1036  *
1037  * Returns whether the file/socket/whatever associated with @channel
1038  * will be closed when @channel receives its final unref and is
1039  * destroyed. The default value of this is %TRUE for channels created
1040  * by g_io_channel_new_file (), and %FALSE for all other channels.
1041  *
1042  * Returns: %TRUE if the channel will be closed, %FALSE otherwise.
1043  **/
1044 gboolean
1045 g_io_channel_get_close_on_unref (GIOChannel *channel)
1046 {
</pre>
<hr />
<pre>
1069  * @G_SEEK_SET: the start of the file.
1070  * @G_SEEK_END: the end of the file.
1071  *
1072  * An enumeration specifying the base position for a
1073  * g_io_channel_seek_position() operation.
1074  **/
1075 GIOStatus
1076 g_io_channel_seek_position (GIOChannel  *channel,
1077                             gint64       offset,
1078                             GSeekType    type,
1079                             GError     **error)
1080 {
1081   GIOStatus status;
1082 
1083   /* For files, only one of the read and write buffers can contain data.
1084    * For sockets, both can contain data.
1085    */
1086 
1087   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
1088   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<span class="line-modified">1089       G_IO_STATUS_ERROR);</span>
1090   g_return_val_if_fail (channel-&gt;is_seekable, G_IO_STATUS_ERROR);
1091 
1092   switch (type)
1093     {
1094       case G_SEEK_CUR: /* The user is seeking relative to the head of the buffer */
1095         if (channel-&gt;use_buffer)
1096           {
1097             if (channel-&gt;do_encode &amp;&amp; channel-&gt;encoded_read_buf
1098                 &amp;&amp; channel-&gt;encoded_read_buf-&gt;len &gt; 0)
1099               {
1100                 g_warning (&quot;Seek type G_SEEK_CUR not allowed for this&quot;
1101                   &quot; channel&#39;s encoding.&quot;);
1102                 return G_IO_STATUS_ERROR;
1103               }
1104           if (channel-&gt;read_buf)
1105             offset -= channel-&gt;read_buf-&gt;len;
1106           if (channel-&gt;encoded_read_buf)
1107             {
1108               g_assert (channel-&gt;encoded_read_buf-&gt;len == 0 || !channel-&gt;do_encode);
1109 
</pre>
<hr />
<pre>
1156           channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
1157         }
1158     }
1159 
1160   return status;
1161 }
1162 
1163 /**
1164  * g_io_channel_flush:
1165  * @channel: a #GIOChannel
1166  * @error: location to store an error of type #GIOChannelError
1167  *
1168  * Flushes the write buffer for the GIOChannel.
1169  *
1170  * Returns: the status of the operation: One of
1171  *   #G_IO_STATUS_NORMAL, #G_IO_STATUS_AGAIN, or
1172  *   #G_IO_STATUS_ERROR.
1173  **/
1174 GIOStatus
1175 g_io_channel_flush (GIOChannel  *channel,
<span class="line-modified">1176         GError     **error)</span>
1177 {
1178   GIOStatus status;
1179   gsize this_time = 1, bytes_written = 0;
1180 
1181   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
1182   g_return_val_if_fail ((error == NULL) || (*error == NULL), G_IO_STATUS_ERROR);
1183 
1184   if (channel-&gt;write_buf == NULL || channel-&gt;write_buf-&gt;len == 0)
1185     return G_IO_STATUS_NORMAL;
1186 
1187   do
1188     {
1189       g_assert (this_time &gt; 0);
1190 
1191       status = channel-&gt;funcs-&gt;io_write (channel,
<span class="line-modified">1192            channel-&gt;write_buf-&gt;str + bytes_written,</span>
<span class="line-modified">1193            channel-&gt;write_buf-&gt;len - bytes_written,</span>
<span class="line-modified">1194            &amp;this_time, error);</span>
1195       bytes_written += this_time;
1196     }
1197   while ((bytes_written &lt; channel-&gt;write_buf-&gt;len)
1198          &amp;&amp; (status == G_IO_STATUS_NORMAL));
1199 
1200   g_string_erase (channel-&gt;write_buf, 0, bytes_written);
1201 
1202   return status;
1203 }
1204 
1205 /**
1206  * g_io_channel_set_buffered:
1207  * @channel: a #GIOChannel
1208  * @buffered: whether to set the channel buffered or unbuffered
1209  *
1210  * The buffering state can only be set if the channel&#39;s encoding
1211  * is %NULL. For any other encoding, the channel must be buffered.
1212  *
1213  * A buffered channel can only be set unbuffered if the channel&#39;s
1214  * internal buffers have been flushed. Newly created channels or
</pre>
<hr />
<pre>
1289  *
1290  * - One of the (new API) read functions has just returned %G_IO_STATUS_EOF
1291  *   (or, in the case of g_io_channel_read_to_end(), %G_IO_STATUS_NORMAL).
1292  *
1293  * -  One of the functions g_io_channel_read_chars() or
1294  *    g_io_channel_read_unichar() has returned %G_IO_STATUS_AGAIN or
1295  *    %G_IO_STATUS_ERROR. This may be useful in the case of
1296  *    %G_CONVERT_ERROR_ILLEGAL_SEQUENCE.
1297  *    Returning one of these statuses from g_io_channel_read_line(),
1298  *    g_io_channel_read_line_string(), or g_io_channel_read_to_end()
1299  *    does not guarantee that the encoding can be changed.
1300  *
1301  * Channels which do not meet one of the above conditions cannot call
1302  * g_io_channel_seek_position() with an offset of %G_SEEK_CUR, and, if
1303  * they are &quot;seekable&quot;, cannot call g_io_channel_write_chars() after
1304  * calling one of the API &quot;read&quot; functions.
1305  *
1306  * Return Value: %G_IO_STATUS_NORMAL if the encoding was successfully set
1307  */
1308 GIOStatus
<span class="line-modified">1309 g_io_channel_set_encoding (GIOChannel *channel,</span>
1310                            const gchar  *encoding,
<span class="line-modified">1311          GError      **error)</span>
1312 {
1313   GIConv read_cd, write_cd;
<span class="line-added">1314 #ifndef G_DISABLE_ASSERT</span>
1315   gboolean did_encode;
<span class="line-added">1316 #endif</span>
1317 
1318   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
1319   g_return_val_if_fail ((error == NULL) || (*error == NULL), G_IO_STATUS_ERROR);
1320 
1321   /* Make sure the encoded buffers are empty */
1322 
1323   g_return_val_if_fail (!channel-&gt;do_encode || !channel-&gt;encoded_read_buf ||
<span class="line-modified">1324       channel-&gt;encoded_read_buf-&gt;len == 0, G_IO_STATUS_ERROR);</span>
1325 
1326   if (!channel-&gt;use_buffer)
1327     {
1328       g_warning (&quot;Need to set the channel buffered before setting the encoding.&quot;);
1329       g_warning (&quot;Assuming this is what you meant and acting accordingly.&quot;);
1330 
1331       channel-&gt;use_buffer = TRUE;
1332     }
1333 
1334   if (channel-&gt;partial_write_buf[0] != &#39;\0&#39;)
1335     {
1336       g_warning (&quot;Partial character at end of write buffer not flushed.&quot;);
1337       channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
1338     }
1339 
<span class="line-added">1340 #ifndef G_DISABLE_ASSERT</span>
1341   did_encode = channel-&gt;do_encode;
<span class="line-added">1342 #endif</span>
1343 
1344   if (!encoding || strcmp (encoding, &quot;UTF8&quot;) == 0 || strcmp (encoding, &quot;UTF-8&quot;) == 0)
1345     {
1346       channel-&gt;do_encode = FALSE;
1347       read_cd = write_cd = (GIConv) -1;
1348     }
1349   else
1350     {
1351       gint err = 0;
1352       const gchar *from_enc = NULL, *to_enc = NULL;
1353 
1354       if (channel-&gt;is_readable)
1355         {
1356           read_cd = g_iconv_open (&quot;UTF-8&quot;, encoding);
1357 
1358           if (read_cd == (GIConv) -1)
1359             {
1360               err = errno;
1361               from_enc = encoding;
1362               to_enc = &quot;UTF-8&quot;;
</pre>
<hr />
<pre>
1506       gchar *inbuf, *outbuf;
1507       int errval;
1508 
1509       g_assert (channel-&gt;encoded_read_buf);
1510 
1511 reencode:
1512 
1513       inbytes_left = channel-&gt;read_buf-&gt;len;
1514       outbytes_left = MAX (channel-&gt;read_buf-&gt;len,
1515                            channel-&gt;encoded_read_buf-&gt;allocated_len
1516                            - channel-&gt;encoded_read_buf-&gt;len - 1); /* 1 for NULL */
1517       outbytes_left = MAX (outbytes_left, 6);
1518 
1519       inbuf = channel-&gt;read_buf-&gt;str;
1520       g_string_set_size (channel-&gt;encoded_read_buf,
1521                          channel-&gt;encoded_read_buf-&gt;len + outbytes_left);
1522       outbuf = channel-&gt;encoded_read_buf-&gt;str + channel-&gt;encoded_read_buf-&gt;len
1523                - outbytes_left;
1524 
1525       errnum = g_iconv (channel-&gt;read_cd, &amp;inbuf, &amp;inbytes_left,
<span class="line-modified">1526       &amp;outbuf, &amp;outbytes_left);</span>
1527       errval = errno;
1528 
1529       g_assert (inbuf + inbytes_left == channel-&gt;read_buf-&gt;str
1530                 + channel-&gt;read_buf-&gt;len);
1531       g_assert (outbuf + outbytes_left == channel-&gt;encoded_read_buf-&gt;str
1532                 + channel-&gt;encoded_read_buf-&gt;len);
1533 
1534       g_string_erase (channel-&gt;read_buf, 0,
<span class="line-modified">1535           channel-&gt;read_buf-&gt;len - inbytes_left);</span>
1536       g_string_truncate (channel-&gt;encoded_read_buf,
<span class="line-modified">1537        channel-&gt;encoded_read_buf-&gt;len - outbytes_left);</span>
1538 
1539       if (errnum == (gsize) -1)
1540         {
1541           switch (errval)
1542             {
1543               case EINVAL:
1544                 if ((oldlen == channel-&gt;encoded_read_buf-&gt;len)
1545                   &amp;&amp; (status == G_IO_STATUS_EOF))
1546                   status = G_IO_STATUS_EOF;
1547                 else
1548                   status = G_IO_STATUS_NORMAL;
1549                 break;
1550               case E2BIG:
1551                 /* Buffer size at least 6, wrote at least on character */
1552                 g_assert (inbuf != channel-&gt;read_buf-&gt;str);
1553                 goto reencode;
1554               case EILSEQ:
1555                 if (oldlen &lt; channel-&gt;encoded_read_buf-&gt;len)
1556                   status = G_IO_STATUS_NORMAL;
1557                 else
</pre>
<hr />
<pre>
1630  * @str_return: (out): The line read from the #GIOChannel, including the
1631  *              line terminator. This data should be freed with g_free()
1632  *              when no longer needed. This is a nul-terminated string.
1633  *              If a @length of zero is returned, this will be %NULL instead.
1634  * @length: (out) (optional): location to store length of the read data, or %NULL
1635  * @terminator_pos: (out) (optional): location to store position of line terminator, or %NULL
1636  * @error: A location to return an error of type #GConvertError
1637  *         or #GIOChannelError
1638  *
1639  * Reads a line, including the terminating character(s),
1640  * from a #GIOChannel into a newly-allocated string.
1641  * @str_return will contain allocated memory if the return
1642  * is %G_IO_STATUS_NORMAL.
1643  *
1644  * Returns: the status of the operation.
1645  **/
1646 GIOStatus
1647 g_io_channel_read_line (GIOChannel  *channel,
1648                         gchar      **str_return,
1649                         gsize       *length,
<span class="line-modified">1650       gsize       *terminator_pos,</span>
<span class="line-modified">1651             GError     **error)</span>
1652 {
1653   GIOStatus status;
1654   gsize got_length;
1655 
1656   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
1657   g_return_val_if_fail (str_return != NULL, G_IO_STATUS_ERROR);
1658   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<span class="line-modified">1659       G_IO_STATUS_ERROR);</span>
1660   g_return_val_if_fail (channel-&gt;is_readable, G_IO_STATUS_ERROR);
1661 
1662   status = g_io_channel_read_line_backend (channel, &amp;got_length, terminator_pos, error);
1663 
1664   if (length &amp;&amp; status != G_IO_STATUS_ERROR)
1665     *length = got_length;
1666 
1667   if (status == G_IO_STATUS_NORMAL)
1668     {
1669       g_assert (USE_BUF (channel));
1670       *str_return = g_strndup (USE_BUF (channel)-&gt;str, got_length);
1671       g_string_erase (USE_BUF (channel), 0, got_length);
1672     }
1673   else
1674     *str_return = NULL;
1675 
1676   return status;
1677 }
1678 
1679 /**
1680  * g_io_channel_read_line_string:
1681  * @channel: a #GIOChannel
1682  * @buffer: a #GString into which the line will be written.
1683  *          If @buffer already contains data, the old data will
1684  *          be overwritten.
1685  * @terminator_pos: (nullable): location to store position of line terminator, or %NULL
1686  * @error: a location to store an error of type #GConvertError
1687  *         or #GIOChannelError
1688  *
1689  * Reads a line from a #GIOChannel, using a #GString as a buffer.
1690  *
1691  * Returns: the status of the operation.
1692  **/
1693 GIOStatus
1694 g_io_channel_read_line_string (GIOChannel  *channel,
1695                                GString     *buffer,
<span class="line-modified">1696              gsize       *terminator_pos,</span>
<span class="line-modified">1697                                GError   **error)</span>
1698 {
1699   gsize length;
1700   GIOStatus status;
1701 
1702   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
1703   g_return_val_if_fail (buffer != NULL, G_IO_STATUS_ERROR);
1704   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<span class="line-modified">1705       G_IO_STATUS_ERROR);</span>
1706   g_return_val_if_fail (channel-&gt;is_readable, G_IO_STATUS_ERROR);
1707 
1708   if (buffer-&gt;len &gt; 0)
1709     g_string_truncate (buffer, 0); /* clear out the buffer */
1710 
1711   status = g_io_channel_read_line_backend (channel, &amp;length, terminator_pos, error);
1712 
1713   if (status == G_IO_STATUS_NORMAL)
1714     {
1715       g_assert (USE_BUF (channel));
1716       g_string_append_len (buffer, USE_BUF (channel)-&gt;str, length);
1717       g_string_erase (USE_BUF (channel), 0, length);
1718     }
1719 
1720   return status;
1721 }
1722 
1723 
1724 static GIOStatus
1725 g_io_channel_read_line_backend (GIOChannel  *channel,
</pre>
<hr />
<pre>
1855 
1856       /* If encoding != NULL, valid UTF-8, didn&#39;t overshoot */
1857       g_assert (nextchar == lastchar);
1858 
1859       /* Check for EOF */
1860 
1861       if (status == G_IO_STATUS_EOF)
1862         {
1863           if (channel-&gt;encoding &amp;&amp; channel-&gt;read_buf-&gt;len &gt; 0)
1864             {
1865               g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_PARTIAL_INPUT,
1866                                    _(&quot;Channel terminates in a partial character&quot;));
1867               return G_IO_STATUS_ERROR;
1868             }
1869           line_length = use_buf-&gt;len;
1870           got_term_len = 0;
1871           break;
1872         }
1873 
1874       if (use_buf-&gt;len &gt; line_term_len - 1)
<span class="line-modified">1875   checked_to = use_buf-&gt;len - (line_term_len - 1);</span>
1876       else
<span class="line-modified">1877   checked_to = 0;</span>
1878     }
1879 
1880 done:
1881 
1882   if (terminator_pos)
1883     *terminator_pos = line_length;
1884 
1885   if (length)
1886     *length = line_length + got_term_len;
1887 
1888   return G_IO_STATUS_NORMAL;
1889 }
1890 
1891 /**
1892  * g_io_channel_read_to_end:
1893  * @channel: a #GIOChannel
1894  * @str_return:  (out) (array length=length) (element-type guint8): Location to
1895  *              store a pointer to a string holding the remaining data in the
1896  *              #GIOChannel. This data should be freed with g_free() when no
1897  *              longer needed. This data is terminated by an extra nul
</pre>
<hr />
<pre>
1944       return G_IO_STATUS_ERROR;
1945     }
1946 
1947   if (USE_BUF (channel) == NULL)
1948     {
1949       /* length is already set to zero */
1950       if (str_return)
1951         *str_return = g_strdup (&quot;&quot;);
1952     }
1953   else
1954     {
1955       if (length)
1956         *length = USE_BUF (channel)-&gt;len;
1957 
1958       if (str_return)
1959         *str_return = g_string_free (USE_BUF (channel), FALSE);
1960       else
1961         g_string_free (USE_BUF (channel), TRUE);
1962 
1963       if (channel-&gt;encoding)
<span class="line-modified">1964   channel-&gt;encoded_read_buf = NULL;</span>
1965       else
<span class="line-modified">1966   channel-&gt;read_buf = NULL;</span>
1967     }
1968 
1969   return G_IO_STATUS_NORMAL;
1970 }
1971 
1972 /**
1973  * g_io_channel_read_chars:
1974  * @channel: a #GIOChannel
1975  * @buf: (out caller-allocates) (array length=count) (element-type guint8):
1976  *     a buffer to read data into
1977  * @count: (in): the size of the buffer. Note that the buffer may not be
1978  *     complelely filled even if there is data in the buffer if the
1979  *     remaining data is not a complete character.
1980  * @bytes_read: (out) (optional): The number of bytes read. This may be
1981  *     zero even on success if count &lt; 6 and the channel&#39;s encoding
1982  *     is non-%NULL. This indicates that the next UTF-8 character is
1983  *     too wide for the buffer.
1984  * @error: a location to return an error of type #GConvertError
1985  *     or #GIOChannelError.
1986  *
</pre>
<hr />
<pre>
2086   if (bytes_read)
2087     *bytes_read = got_bytes;
2088 
2089   return G_IO_STATUS_NORMAL;
2090 }
2091 
2092 /**
2093  * g_io_channel_read_unichar:
2094  * @channel: a #GIOChannel
2095  * @thechar: (out): a location to return a character
2096  * @error: a location to return an error of type #GConvertError
2097  *         or #GIOChannelError
2098  *
2099  * Reads a Unicode character from @channel.
2100  * This function cannot be called on a channel with %NULL encoding.
2101  *
2102  * Returns: a #GIOStatus
2103  **/
2104 GIOStatus
2105 g_io_channel_read_unichar (GIOChannel  *channel,
<span class="line-modified">2106          gunichar    *thechar,</span>
<span class="line-modified">2107          GError     **error)</span>
2108 {
2109   GIOStatus status = G_IO_STATUS_NORMAL;
2110 
2111   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
2112   g_return_val_if_fail (channel-&gt;encoding != NULL, G_IO_STATUS_ERROR);
2113   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<span class="line-modified">2114       G_IO_STATUS_ERROR);</span>
2115   g_return_val_if_fail (channel-&gt;is_readable, G_IO_STATUS_ERROR);
2116 
2117   while (BUF_LEN (channel-&gt;encoded_read_buf) == 0 &amp;&amp; status == G_IO_STATUS_NORMAL)
2118     status = g_io_channel_fill_buffer (channel, error);
2119 
2120   /* Only return an error if we have no data */
2121 
2122   if (BUF_LEN (USE_BUF (channel)) == 0)
2123     {
2124       g_assert (status != G_IO_STATUS_NORMAL);
2125 
2126       if (status == G_IO_STATUS_EOF &amp;&amp; BUF_LEN (channel-&gt;read_buf) &gt; 0)
2127         {
2128           g_set_error_literal (error, G_CONVERT_ERROR,
2129                                G_CONVERT_ERROR_PARTIAL_INPUT,
2130                                _(&quot;Leftover unconverted data in read buffer&quot;));
2131           status = G_IO_STATUS_ERROR;
2132         }
2133 
2134       if (thechar)
</pre>
<hr />
<pre>
2160  *                 even if the return value is not %G_IO_STATUS_NORMAL.
2161  *                 If the return value is %G_IO_STATUS_NORMAL and the
2162  *                 channel is blocking, this will always be equal
2163  *                 to @count if @count &gt;= 0.
2164  * @error: a location to return an error of type #GConvertError
2165  *         or #GIOChannelError
2166  *
2167  * Replacement for g_io_channel_write() with the new API.
2168  *
2169  * On seekable channels with encodings other than %NULL or UTF-8, generic
2170  * mixing of reading and writing is not allowed. A call to g_io_channel_write_chars ()
2171  * may only be made on a channel from which data has been read in the
2172  * cases described in the documentation for g_io_channel_set_encoding ().
2173  *
2174  * Returns: the status of the operation.
2175  **/
2176 GIOStatus
2177 g_io_channel_write_chars (GIOChannel   *channel,
2178                           const gchar  *buf,
2179                           gssize        count,
<span class="line-modified">2180         gsize        *bytes_written,</span>
2181                           GError      **error)
2182 {
<span class="line-added">2183   gsize count_unsigned;</span>
2184   GIOStatus status;
2185   gssize wrote_bytes = 0;
2186 
2187   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
2188   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<span class="line-modified">2189       G_IO_STATUS_ERROR);</span>
2190   g_return_val_if_fail (channel-&gt;is_writeable, G_IO_STATUS_ERROR);
2191 
2192   if ((count &lt; 0) &amp;&amp; buf)
2193     count = strlen (buf);
<span class="line-added">2194   count_unsigned = count;</span>
2195 
<span class="line-modified">2196   if (count_unsigned == 0)</span>
2197     {
2198       if (bytes_written)
2199         *bytes_written = 0;
2200       return G_IO_STATUS_NORMAL;
2201     }
2202 
2203   g_return_val_if_fail (buf != NULL, G_IO_STATUS_ERROR);
<span class="line-modified">2204   g_return_val_if_fail (count_unsigned &gt; 0, G_IO_STATUS_ERROR);</span>
2205 
2206   /* Raw write case */
2207 
2208   if (!channel-&gt;use_buffer)
2209     {
2210       gsize tmp_bytes;
2211 
2212       g_assert (!channel-&gt;write_buf || channel-&gt;write_buf-&gt;len == 0);
2213       g_assert (channel-&gt;partial_write_buf[0] == &#39;\0&#39;);
2214 
<span class="line-modified">2215       status = channel-&gt;funcs-&gt;io_write (channel, buf, count_unsigned,</span>
<span class="line-added">2216                                          &amp;tmp_bytes, error);</span>
2217 
2218       if (bytes_written)
<span class="line-modified">2219   *bytes_written = tmp_bytes;</span>
2220 
2221       return status;
2222     }
2223 
2224   /* General case */
2225 
2226   if (channel-&gt;is_seekable &amp;&amp; (( BUF_LEN (channel-&gt;read_buf) &gt; 0)
2227     || (BUF_LEN (channel-&gt;encoded_read_buf) &gt; 0)))
2228     {
2229       if (channel-&gt;do_encode &amp;&amp; BUF_LEN (channel-&gt;encoded_read_buf) &gt; 0)
2230         {
2231           g_warning (&quot;Mixed reading and writing not allowed on encoded files&quot;);
2232           return G_IO_STATUS_ERROR;
2233         }
2234       status = g_io_channel_seek_position (channel, 0, G_SEEK_CUR, error);
2235       if (status != G_IO_STATUS_NORMAL)
2236         {
2237           if (bytes_written)
2238             *bytes_written = 0;
2239           return status;
</pre>
<hr />
<pre>
2272           if (status != G_IO_STATUS_NORMAL)
2273             {
2274               if (status == G_IO_STATUS_AGAIN &amp;&amp; wrote_bytes &gt; 0)
2275                 status = G_IO_STATUS_NORMAL;
2276               if (bytes_written)
2277                 *bytes_written = wrote_bytes;
2278               return status;
2279             }
2280         }
2281 
2282       space_in_buf = MAX (channel-&gt;buf_size, channel-&gt;write_buf-&gt;allocated_len - 1)
2283                      - channel-&gt;write_buf-&gt;len; /* 1 for NULL */
2284 
2285       /* This is only true because g_io_channel_set_buffer_size ()
2286        * ensures that channel-&gt;buf_size &gt;= MAX_CHAR_SIZE.
2287        */
2288       g_assert (space_in_buf &gt;= MAX_CHAR_SIZE);
2289 
2290       if (!channel-&gt;encoding)
2291         {
<span class="line-modified">2292           gssize write_this = MIN (space_in_buf, count_unsigned - wrote_bytes);</span>
2293 
2294           g_string_append_len (channel-&gt;write_buf, buf, write_this);
2295           buf += write_this;
2296           wrote_bytes += write_this;
2297         }
2298       else
2299         {
2300           const gchar *from_buf;
2301           gsize from_buf_len, from_buf_old_len, left_len;
2302           gsize err;
2303           gint errnum;
2304 
2305           if (channel-&gt;partial_write_buf[0] != &#39;\0&#39;)
2306             {
2307               g_assert (wrote_bytes == 0);
2308 
2309               from_buf = channel-&gt;partial_write_buf;
2310               from_buf_old_len = strlen (channel-&gt;partial_write_buf);
2311               g_assert (from_buf_old_len &gt; 0);
<span class="line-modified">2312               from_buf_len = MIN (6, from_buf_old_len + count_unsigned);</span>
2313 
2314               memcpy (channel-&gt;partial_write_buf + from_buf_old_len, buf,
2315                       from_buf_len - from_buf_old_len);
2316             }
2317           else
2318             {
2319               from_buf = buf;
<span class="line-modified">2320               from_buf_len = count_unsigned - wrote_bytes;</span>
2321               from_buf_old_len = 0;
2322             }
2323 
2324 reconvert:
2325 
2326           if (!channel-&gt;do_encode) /* UTF-8 encoding */
2327             {
2328               const gchar *badchar;
2329               gsize try_len = MIN (from_buf_len, space_in_buf);
2330 
2331               /* UTF-8, just validate, emulate g_iconv */
2332 
<span class="line-modified">2333               if (!g_utf8_validate_len (from_buf, try_len, &amp;badchar))</span>
2334                 {
2335                   gunichar try_char;
2336                   gsize incomplete_len = from_buf + try_len - badchar;
2337 
2338                   left_len = from_buf + from_buf_len - badchar;
2339 
2340                   try_char = g_utf8_get_char_validated (badchar, incomplete_len);
2341 
2342                   switch (try_char)
2343                     {
2344                       case -2:
2345                         g_assert (incomplete_len &lt; 6);
2346                         if (try_len == from_buf_len)
2347                           {
2348                             errnum = EINVAL;
2349                             err = (gsize) -1;
2350                           }
2351                         else
2352                           {
2353                             errnum = 0;
</pre>
<hr />
<pre>
2379             }
2380           else
2381             {
2382                gchar *outbuf;
2383 
2384                left_len = from_buf_len;
2385                g_string_set_size (channel-&gt;write_buf, channel-&gt;write_buf-&gt;len
2386                                   + space_in_buf);
2387                outbuf = channel-&gt;write_buf-&gt;str + channel-&gt;write_buf-&gt;len
2388                         - space_in_buf;
2389                err = g_iconv (channel-&gt;write_cd, (gchar **) &amp;from_buf, &amp;left_len,
2390                               &amp;outbuf, &amp;space_in_buf);
2391                errnum = errno;
2392                g_string_truncate (channel-&gt;write_buf, channel-&gt;write_buf-&gt;len
2393                                   - space_in_buf);
2394             }
2395 
2396           if (err == (gsize) -1)
2397             {
2398               switch (errnum)
<span class="line-modified">2399           {</span>
2400                   case EINVAL:
2401                     g_assert (left_len &lt; 6);
2402 
2403                     if (from_buf_old_len == 0)
2404                       {
2405                         /* Not from partial_write_buf */
2406 
2407                         memcpy (channel-&gt;partial_write_buf, from_buf, left_len);
2408                         channel-&gt;partial_write_buf[left_len] = &#39;\0&#39;;
2409                         if (bytes_written)
<span class="line-modified">2410                           *bytes_written = count_unsigned;</span>
2411                         return G_IO_STATUS_NORMAL;
2412                       }
2413 
2414                     /* Working in partial_write_buf */
2415 
2416                     if (left_len == from_buf_len)
2417                       {
2418                         /* Didn&#39;t convert anything, must still have
2419                          * less than a full character
2420                          */
2421 
<span class="line-modified">2422                         g_assert (count_unsigned == from_buf_len - from_buf_old_len);</span>
2423 
2424                         channel-&gt;partial_write_buf[from_buf_len] = &#39;\0&#39;;
2425 
2426                         if (bytes_written)
<span class="line-modified">2427                           *bytes_written = count_unsigned;</span>
2428 
2429                         return G_IO_STATUS_NORMAL;
2430                       }
2431 
2432                     g_assert (from_buf_len - left_len &gt;= from_buf_old_len);
2433 
2434                     /* We converted all the old data. This is fine */
2435 
2436                     break;
2437                   case E2BIG:
2438                     if (from_buf_len == left_len)
2439                       {
2440                         /* Nothing was written, add enough space for
2441                          * at least one character.
2442                          */
2443                         space_in_buf += MAX_CHAR_SIZE;
2444                         goto reconvert;
2445                       }
2446                     break;
2447                   case EILSEQ:
</pre>
<hr />
<pre>
2469                 }
2470             }
2471 
2472           g_assert (from_buf_len - left_len &gt;= from_buf_old_len);
2473 
2474           wrote_bytes += from_buf_len - left_len - from_buf_old_len;
2475 
2476           if (from_buf_old_len &gt; 0)
2477             {
2478               /* We were working in partial_write_buf */
2479 
2480               buf += from_buf_len - left_len - from_buf_old_len;
2481               channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
2482             }
2483           else
2484             buf = from_buf;
2485         }
2486     }
2487 
2488   if (bytes_written)
<span class="line-modified">2489     *bytes_written = count_unsigned;</span>
2490 
2491   return G_IO_STATUS_NORMAL;
2492 }
2493 
2494 /**
2495  * g_io_channel_write_unichar:
2496  * @channel: a #GIOChannel
2497  * @thechar: a character
2498  * @error: location to return an error of type #GConvertError
2499  *         or #GIOChannelError
2500  *
2501  * Writes a Unicode character to @channel.
2502  * This function cannot be called on a channel with %NULL encoding.
2503  *
2504  * Returns: a #GIOStatus
2505  **/
2506 GIOStatus
2507 g_io_channel_write_unichar (GIOChannel  *channel,
<span class="line-modified">2508           gunichar     thechar,</span>
<span class="line-modified">2509           GError     **error)</span>
2510 {
2511   GIOStatus status;
2512   gchar static_buf[6];
2513   gsize char_len, wrote_len;
2514 
2515   g_return_val_if_fail (channel != NULL, G_IO_STATUS_ERROR);
2516   g_return_val_if_fail (channel-&gt;encoding != NULL, G_IO_STATUS_ERROR);
2517   g_return_val_if_fail ((error == NULL) || (*error == NULL),
<span class="line-modified">2518       G_IO_STATUS_ERROR);</span>
2519   g_return_val_if_fail (channel-&gt;is_writeable, G_IO_STATUS_ERROR);
2520 
2521   char_len = g_unichar_to_utf8 (thechar, static_buf);
2522 
2523   if (channel-&gt;partial_write_buf[0] != &#39;\0&#39;)
2524     {
2525       g_warning (&quot;Partial character written before writing unichar.&quot;);
2526       channel-&gt;partial_write_buf[0] = &#39;\0&#39;;
2527     }
2528 
2529   status = g_io_channel_write_chars (channel, static_buf,
2530                                      char_len, &amp;wrote_len, error);
2531 
2532   /* We validate UTF-8, so we can&#39;t get a partial write */
2533 
2534   g_assert (wrote_len == char_len || status != G_IO_STATUS_NORMAL);
2535 
2536   return status;
2537 }
2538 
</pre>
</td>
</tr>
</table>
<center><a href="ghostutils.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="giochannel.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>