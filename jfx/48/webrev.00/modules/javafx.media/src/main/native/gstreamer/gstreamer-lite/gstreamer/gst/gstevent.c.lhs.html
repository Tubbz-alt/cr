<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstevent.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wim.taymans@chello.be&gt;
   4  *                    2005 Wim Taymans &lt;wim@fluendo.com&gt;
   5  *
   6  * gstevent.c: GstEvent subsystem
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public
  19  * License along with this library; if not, write to the
  20  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 /**
  25  * SECTION:gstevent
  26  * @title: GstEvent
  27  * @short_description: Structure describing events that are passed up and down
  28  *                     a pipeline
  29  * @see_also: #GstPad, #GstElement
  30  *
  31  * The event class provides factory methods to construct events for sending
  32  * and functions to query (parse) received events.
  33  *
  34  * Events are usually created with gst_event_new_*() which takes event-type
  35  * specific parameters as arguments.
  36  * To send an event application will usually use gst_element_send_event() and
  37  * elements will use gst_pad_send_event() or gst_pad_push_event().
  38  * The event should be unreffed with gst_event_unref() if it has not been sent.
  39  *
  40  * Events that have been received can be parsed with their respective
  41  * gst_event_parse_*() functions. It is valid to pass %NULL for unwanted details.
  42  *
  43  * Events are passed between elements in parallel to the data stream. Some events
  44  * are serialized with buffers, others are not. Some events only travel downstream,
  45  * others only upstream. Some events can travel both upstream and downstream.
  46  *
  47  * The events are used to signal special conditions in the datastream such as
  48  * EOS (end of stream) or the start of a new stream-segment.
  49  * Events are also used to flush the pipeline of any pending data.
  50  *
  51  * Most of the event API is used inside plugins. Applications usually only
  52  * construct and use seek events.
  53  * To do that gst_event_new_seek() is used to create a seek event. It takes
  54  * the needed parameters to specify seeking time and mode.
  55  * |[&lt;!-- language=&quot;C&quot; --&gt;
  56  *   GstEvent *event;
  57  *   gboolean result;
  58  *   ...
  59  *   // construct a seek event to play the media from second 2 to 5, flush
  60  *   // the pipeline to decrease latency.
  61  *   event = gst_event_new_seek (1.0,
  62  *      GST_FORMAT_TIME,
  63  *      GST_SEEK_FLAG_FLUSH,
  64  *      GST_SEEK_TYPE_SET, 2 * GST_SECOND,
  65  *      GST_SEEK_TYPE_SET, 5 * GST_SECOND);
  66  *   ...
  67  *   result = gst_element_send_event (pipeline, event);
  68  *   if (!result)
  69  *     g_warning (&quot;seek failed&quot;);
  70  *   ...
  71  * ]|
  72  */
  73 
  74 
  75 #include &quot;gst_private.h&quot;
  76 #include &lt;string.h&gt;             /* memcpy */
  77 
  78 #include &quot;gstinfo.h&quot;
  79 #include &quot;gstevent.h&quot;
  80 #include &quot;gstenumtypes.h&quot;
  81 #include &quot;gstutils.h&quot;
  82 #include &quot;gstquark.h&quot;
  83 #include &quot;gstvalue.h&quot;
  84 
  85 GType _gst_event_type = 0;
  86 
  87 typedef struct
  88 {
  89   GstEvent event;
  90 
  91   GstStructure *structure;
  92   gint64 running_time_offset;
  93 } GstEventImpl;
  94 
  95 #define GST_EVENT_STRUCTURE(e)  (((GstEventImpl *)(e))-&gt;structure)
  96 
  97 typedef struct
  98 {
  99   const gint type;
 100   const gchar *name;
 101   GQuark quark;
 102 } GstEventQuarks;
 103 
 104 static GstEventQuarks event_quarks[] = {
 105   {GST_EVENT_UNKNOWN, &quot;unknown&quot;, 0},
 106   {GST_EVENT_FLUSH_START, &quot;flush-start&quot;, 0},
 107   {GST_EVENT_FLUSH_STOP, &quot;flush-stop&quot;, 0},
 108   {GST_EVENT_SELECT_STREAMS, &quot;select-streams&quot;, 0},
 109   {GST_EVENT_STREAM_START, &quot;stream-start&quot;, 0},
 110   {GST_EVENT_STREAM_COLLECTION, &quot;stream-collection&quot;, 0},
 111   {GST_EVENT_CAPS, &quot;caps&quot;, 0},
 112   {GST_EVENT_SEGMENT, &quot;segment&quot;, 0},
 113   {GST_EVENT_TAG, &quot;tag&quot;, 0},
 114   {GST_EVENT_TOC, &quot;toc&quot;, 0},
 115   {GST_EVENT_PROTECTION, &quot;protection&quot;, 0},
 116   {GST_EVENT_BUFFERSIZE, &quot;buffersize&quot;, 0},
 117   {GST_EVENT_SINK_MESSAGE, &quot;sink-message&quot;, 0},
 118   {GST_EVENT_EOS, &quot;eos&quot;, 0},
 119   {GST_EVENT_SEGMENT_DONE, &quot;segment-done&quot;, 0},
 120   {GST_EVENT_GAP, &quot;gap&quot;, 0},
 121   {GST_EVENT_QOS, &quot;qos&quot;, 0},
 122   {GST_EVENT_SEEK, &quot;seek&quot;, 0},
 123   {GST_EVENT_NAVIGATION, &quot;navigation&quot;, 0},
 124   {GST_EVENT_LATENCY, &quot;latency&quot;, 0},
 125   {GST_EVENT_STEP, &quot;step&quot;, 0},
 126   {GST_EVENT_RECONFIGURE, &quot;reconfigure&quot;, 0},
 127   {GST_EVENT_TOC_SELECT, &quot;toc-select&quot;, 0},
 128   {GST_EVENT_CUSTOM_UPSTREAM, &quot;custom-upstream&quot;, 0},
 129   {GST_EVENT_CUSTOM_DOWNSTREAM, &quot;custom-downstream&quot;, 0},
 130   {GST_EVENT_CUSTOM_DOWNSTREAM_OOB, &quot;custom-downstream-oob&quot;, 0},
 131   {GST_EVENT_CUSTOM_DOWNSTREAM_STICKY, &quot;custom-downstream-sticky&quot;, 0},
 132   {GST_EVENT_CUSTOM_BOTH, &quot;custom-both&quot;, 0},
 133   {GST_EVENT_CUSTOM_BOTH_OOB, &quot;custom-both-oob&quot;, 0},
 134   {GST_EVENT_STREAM_GROUP_DONE, &quot;stream-group-done&quot;, 0},
 135 
 136   {0, NULL, 0}
 137 };
 138 
 139 GST_DEFINE_MINI_OBJECT_TYPE (GstEvent, gst_event);
 140 
 141 void
 142 _priv_gst_event_initialize (void)
 143 {
 144   gint i;
 145 
 146   _gst_event_type = gst_event_get_type ();
 147 
 148   g_type_class_ref (gst_seek_flags_get_type ());
 149   g_type_class_ref (gst_seek_type_get_type ());
 150 
 151   for (i = 0; event_quarks[i].name; i++) {
 152     event_quarks[i].quark = g_quark_from_static_string (event_quarks[i].name);
 153   }
 154 }
 155 
 156 /**
 157  * gst_event_type_get_name:
 158  * @type: the event type
 159  *
 160  * Get a printable name for the given event type. Do not modify or free.
 161  *
 162  * Returns: a reference to the static name of the event.
 163  */
 164 const gchar *
 165 gst_event_type_get_name (GstEventType type)
 166 {
 167   gint i;
 168 
 169   for (i = 0; event_quarks[i].name; i++) {
 170     if (type == event_quarks[i].type)
 171       return event_quarks[i].name;
 172   }
 173   return &quot;unknown&quot;;
 174 }
 175 
 176 /**
 177  * gst_event_type_to_quark:
 178  * @type: the event type
 179  *
 180  * Get the unique quark for the given event type.
 181  *
 182  * Returns: the quark associated with the event type
 183  */
 184 GQuark
 185 gst_event_type_to_quark (GstEventType type)
 186 {
 187   gint i;
 188 
 189   for (i = 0; event_quarks[i].name; i++) {
 190     if (type == event_quarks[i].type)
 191       return event_quarks[i].quark;
 192   }
 193   return 0;
 194 }
 195 
 196 /**
 197  * gst_event_type_get_flags:
 198  * @type: a #GstEventType
 199  *
 200  * Gets the #GstEventTypeFlags associated with @type.
 201  *
 202  * Returns: a #GstEventTypeFlags.
 203  */
 204 GstEventTypeFlags
 205 gst_event_type_get_flags (GstEventType type)
 206 {
 207   GstEventTypeFlags ret;
 208 
 209   ret = type &amp; ((1 &lt;&lt; GST_EVENT_NUM_SHIFT) - 1);
 210 
 211   return ret;
 212 }
 213 
 214 static void
 215 _gst_event_free (GstEvent * event)
 216 {
 217   GstStructure *s;
 218 
 219   g_return_if_fail (event != NULL);
 220   g_return_if_fail (GST_IS_EVENT (event));
 221 
 222   GST_CAT_LOG (GST_CAT_EVENT, &quot;freeing event %p type %s&quot;, event,
 223       GST_EVENT_TYPE_NAME (event));
 224 
 225   s = GST_EVENT_STRUCTURE (event);
 226 
 227   if (s) {
 228     gst_structure_set_parent_refcount (s, NULL);
 229     gst_structure_free (s);
 230   }
<a name="1" id="anc1"></a>


 231 
 232   g_slice_free1 (sizeof (GstEventImpl), event);
 233 }
 234 
 235 static void gst_event_init (GstEventImpl * event, GstEventType type);
 236 
 237 static GstEvent *
 238 _gst_event_copy (GstEvent * event)
 239 {
 240   GstEventImpl *copy;
 241   GstStructure *s;
 242 
 243   copy = g_slice_new0 (GstEventImpl);
 244 
 245   gst_event_init (copy, GST_EVENT_TYPE (event));
 246 
 247   GST_EVENT_TIMESTAMP (copy) = GST_EVENT_TIMESTAMP (event);
 248   GST_EVENT_SEQNUM (copy) = GST_EVENT_SEQNUM (event);
 249 
 250   s = GST_EVENT_STRUCTURE (event);
 251   if (s) {
 252     GST_EVENT_STRUCTURE (copy) = gst_structure_copy (s);
 253     gst_structure_set_parent_refcount (GST_EVENT_STRUCTURE (copy),
 254         &amp;copy-&gt;event.mini_object.refcount);
 255   } else {
 256     GST_EVENT_STRUCTURE (copy) = NULL;
 257   }
 258 
 259   ((GstEventImpl *) copy)-&gt;running_time_offset =
 260       ((GstEventImpl *) event)-&gt;running_time_offset;
 261 
 262   return GST_EVENT_CAST (copy);
 263 }
 264 
 265 static void
 266 gst_event_init (GstEventImpl * event, GstEventType type)
 267 {
 268   gst_mini_object_init (GST_MINI_OBJECT_CAST (event), 0, _gst_event_type,
 269       (GstMiniObjectCopyFunction) _gst_event_copy, NULL,
 270       (GstMiniObjectFreeFunction) _gst_event_free);
 271 
 272   GST_EVENT_TYPE (event) = type;
 273   GST_EVENT_TIMESTAMP (event) = GST_CLOCK_TIME_NONE;
 274   GST_EVENT_SEQNUM (event) = gst_util_seqnum_next ();
 275   event-&gt;running_time_offset = 0;
 276 }
 277 
 278 
 279 /**
 280  * gst_event_new_custom:
 281  * @type: The type of the new event
 282  * @structure: (transfer full): the structure for the event. The event will
 283  *     take ownership of the structure.
 284  *
 285  * Create a new custom-typed event. This can be used for anything not
 286  * handled by other event-specific functions to pass an event to another
 287  * element.
 288  *
 289  * Make sure to allocate an event type with the #GST_EVENT_MAKE_TYPE macro,
 290  * assigning a free number and filling in the correct direction and
 291  * serialization flags.
 292  *
 293  * New custom events can also be created by subclassing the event type if
 294  * needed.
 295  *
 296  * Returns: (transfer full) (nullable): the new custom event.
 297  */
 298 GstEvent *
 299 gst_event_new_custom (GstEventType type, GstStructure * structure)
 300 {
 301   GstEventImpl *event;
 302 
 303   event = g_slice_new0 (GstEventImpl);
 304 
 305   GST_CAT_DEBUG (GST_CAT_EVENT, &quot;creating new event %p %s %d&quot;, event,
 306       gst_event_type_get_name (type), type);
 307 
 308   if (structure) {
 309     /* structure must not have a parent */
 310     if (!gst_structure_set_parent_refcount (structure,
 311             &amp;event-&gt;event.mini_object.refcount))
 312       goto had_parent;
 313 
 314   }
 315   gst_event_init (event, type);
 316 
 317   GST_EVENT_STRUCTURE (event) = structure;
 318 
 319   return GST_EVENT_CAST (event);
 320 
 321   /* ERRORS */
 322 had_parent:
 323   {
 324     g_slice_free1 (sizeof (GstEventImpl), event);
 325     g_warning (&quot;structure is already owned by another object&quot;);
 326     return NULL;
 327   }
 328 }
 329 
 330 /**
 331  * gst_event_get_structure:
 332  * @event: The #GstEvent.
 333  *
 334  * Access the structure of the event.
 335  *
 336  * Returns: (transfer none) (nullable): The structure of the event. The
 337  * structure is still owned by the event, which means that you should not free
 338  * it and that the pointer becomes invalid when you free the event.
 339  *
 340  * MT safe.
 341  */
 342 const GstStructure *
 343 gst_event_get_structure (GstEvent * event)
 344 {
 345   g_return_val_if_fail (GST_IS_EVENT (event), NULL);
 346 
 347   return GST_EVENT_STRUCTURE (event);
 348 }
 349 
 350 /**
 351  * gst_event_writable_structure:
 352  * @event: The #GstEvent.
 353  *
 354  * Get a writable version of the structure.
 355  *
 356  * Returns: (transfer none): The structure of the event. The structure
 357  * is still owned by the event, which means that you should not free
 358  * it and that the pointer becomes invalid when you free the event.
 359  * This function checks if @event is writable and will never return
 360  * %NULL.
 361  *
 362  * MT safe.
 363  */
 364 GstStructure *
 365 gst_event_writable_structure (GstEvent * event)
 366 {
 367   GstStructure *structure;
 368 
 369   g_return_val_if_fail (GST_IS_EVENT (event), NULL);
 370   g_return_val_if_fail (gst_event_is_writable (event), NULL);
 371 
 372   structure = GST_EVENT_STRUCTURE (event);
 373 
 374   if (structure == NULL) {
 375     structure =
 376         gst_structure_new_id_empty (gst_event_type_to_quark (GST_EVENT_TYPE
 377             (event)));
 378     gst_structure_set_parent_refcount (structure, &amp;event-&gt;mini_object.refcount);
 379     GST_EVENT_STRUCTURE (event) = structure;
 380   }
 381   return structure;
 382 }
 383 
 384 /**
 385  * gst_event_has_name:
 386  * @event: The #GstEvent.
 387  * @name: name to check
 388  *
 389  * Checks if @event has the given @name. This function is usually used to
 390  * check the name of a custom event.
 391  *
 392  * Returns: %TRUE if @name matches the name of the event structure.
 393  */
 394 gboolean
 395 gst_event_has_name (GstEvent * event, const gchar * name)
 396 {
 397   g_return_val_if_fail (GST_IS_EVENT (event), FALSE);
 398 
 399   if (GST_EVENT_STRUCTURE (event) == NULL)
 400     return FALSE;
 401 
 402   return gst_structure_has_name (GST_EVENT_STRUCTURE (event), name);
 403 }
 404 
 405 /**
 406  * gst_event_get_seqnum:
 407  * @event: A #GstEvent.
 408  *
 409  * Retrieve the sequence number of a event.
 410  *
 411  * Events have ever-incrementing sequence numbers, which may also be set
 412  * explicitly via gst_event_set_seqnum(). Sequence numbers are typically used to
 413  * indicate that a event corresponds to some other set of events or messages,
 414  * for example an EOS event corresponding to a SEEK event. It is considered good
 415  * practice to make this correspondence when possible, though it is not
 416  * required.
 417  *
 418  * Note that events and messages share the same sequence number incrementor;
 419  * two events or messages will never have the same sequence number unless
 420  * that correspondence was made explicitly.
 421  *
 422  * Returns: The event&#39;s sequence number.
 423  *
 424  * MT safe.
 425  */
 426 guint32
 427 gst_event_get_seqnum (GstEvent * event)
 428 {
 429   g_return_val_if_fail (GST_IS_EVENT (event), -1);
 430 
 431   return GST_EVENT_SEQNUM (event);
 432 }
 433 
 434 /**
 435  * gst_event_set_seqnum:
 436  * @event: A #GstEvent.
 437  * @seqnum: A sequence number.
 438  *
 439  * Set the sequence number of a event.
 440  *
 441  * This function might be called by the creator of a event to indicate that the
 442  * event relates to other events or messages. See gst_event_get_seqnum() for
 443  * more information.
 444  *
 445  * MT safe.
 446  */
 447 void
 448 gst_event_set_seqnum (GstEvent * event, guint32 seqnum)
 449 {
 450   g_return_if_fail (GST_IS_EVENT (event));
<a name="2" id="anc2"></a>

 451 
 452   GST_EVENT_SEQNUM (event) = seqnum;
 453 }
 454 
 455 /**
 456  * gst_event_get_running_time_offset:
 457  * @event: A #GstEvent.
 458  *
 459  * Retrieve the accumulated running time offset of the event.
 460  *
 461  * Events passing through #GstPads that have a running time
 462  * offset set via gst_pad_set_offset() will get their offset
 463  * adjusted according to the pad&#39;s offset.
 464  *
 465  * If the event contains any information that related to the
 466  * running time, this information will need to be updated
 467  * before usage with this offset.
 468  *
 469  * Returns: The event&#39;s running time offset
 470  *
 471  * MT safe.
 472  *
 473  * Since: 1.4
 474  */
 475 gint64
 476 gst_event_get_running_time_offset (GstEvent * event)
 477 {
 478   g_return_val_if_fail (GST_IS_EVENT (event), 0);
 479 
 480   return ((GstEventImpl *) event)-&gt;running_time_offset;
 481 }
 482 
 483 /**
 484  * gst_event_set_running_time_offset:
 485  * @event: A #GstEvent.
 486  * @offset: A the new running time offset
 487  *
 488  * Set the running time offset of a event. See
 489  * gst_event_get_running_time_offset() for more information.
 490  *
 491  * MT safe.
 492  *
 493  * Since: 1.4
 494  */
 495 void
 496 gst_event_set_running_time_offset (GstEvent * event, gint64 offset)
 497 {
 498   g_return_if_fail (GST_IS_EVENT (event));
<a name="3" id="anc3"></a>
 499 
 500   ((GstEventImpl *) event)-&gt;running_time_offset = offset;
 501 }
 502 
 503 /**
 504  * gst_event_new_flush_start:
 505  *
 506  * Allocate a new flush start event. The flush start event can be sent
 507  * upstream and downstream and travels out-of-bounds with the dataflow.
 508  *
 509  * It marks pads as being flushing and will make them return
 510  * #GST_FLOW_FLUSHING when used for data flow with gst_pad_push(),
 511  * gst_pad_chain(), gst_pad_get_range() and gst_pad_pull_range().
 512  * Any event (except a #GST_EVENT_FLUSH_STOP) received
 513  * on a flushing pad will return %FALSE immediately.
 514  *
 515  * Elements should unlock any blocking functions and exit their streaming
 516  * functions as fast as possible when this event is received.
 517  *
 518  * This event is typically generated after a seek to flush out all queued data
 519  * in the pipeline so that the new media is played as soon as possible.
 520  *
 521  * Returns: (transfer full): a new flush start event.
 522  */
 523 GstEvent *
 524 gst_event_new_flush_start (void)
 525 {
 526   return gst_event_new_custom (GST_EVENT_FLUSH_START, NULL);
 527 }
 528 
 529 /**
 530  * gst_event_new_flush_stop:
 531  * @reset_time: if time should be reset
 532  *
 533  * Allocate a new flush stop event. The flush stop event can be sent
 534  * upstream and downstream and travels serialized with the dataflow.
 535  * It is typically sent after sending a FLUSH_START event to make the
 536  * pads accept data again.
 537  *
 538  * Elements can process this event synchronized with the dataflow since
 539  * the preceding FLUSH_START event stopped the dataflow.
 540  *
 541  * This event is typically generated to complete a seek and to resume
 542  * dataflow.
 543  *
 544  * Returns: (transfer full): a new flush stop event.
 545  */
 546 GstEvent *
 547 gst_event_new_flush_stop (gboolean reset_time)
 548 {
 549   GstEvent *event;
 550 
 551   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating flush stop %d&quot;, reset_time);
 552 
 553   event = gst_event_new_custom (GST_EVENT_FLUSH_STOP,
 554       gst_structure_new_id (GST_QUARK (EVENT_FLUSH_STOP),
 555           GST_QUARK (RESET_TIME), G_TYPE_BOOLEAN, reset_time, NULL));
 556 
 557   return event;
 558 }
 559 
 560 /**
 561  * gst_event_parse_flush_stop:
 562  * @event: The event to parse
 563  * @reset_time: (out): if time should be reset
 564  *
 565  * Parse the FLUSH_STOP event and retrieve the @reset_time member.
 566  */
 567 void
 568 gst_event_parse_flush_stop (GstEvent * event, gboolean * reset_time)
 569 {
 570   GstStructure *structure;
 571 
 572   g_return_if_fail (GST_IS_EVENT (event));
 573   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_FLUSH_STOP);
 574 
 575   structure = GST_EVENT_STRUCTURE (event);
 576   if (G_LIKELY (reset_time))
 577     *reset_time =
 578         g_value_get_boolean (gst_structure_id_get_value (structure,
 579             GST_QUARK (RESET_TIME)));
 580 }
 581 
 582 /**
 583  * gst_event_new_select_streams:
 584  * @streams: (element-type utf8) (transfer none): the list of streams to
 585  * activate
 586  *
 587  * Allocate a new select-streams event.
 588  *
 589  * The select-streams event requests the specified @streams to be activated.
 590  *
 591  * The list of @streams corresponds to the &quot;Stream ID&quot; of each stream to be
 592  * activated. Those ID can be obtained via the #GstStream objects present
 593  * in #GST_EVENT_STREAM_START, #GST_EVENT_STREAM_COLLECTION or
 594  * #GST_MESSAGE_STREAM_COLLECTION.
 595  *
 596  * Note: The list of @streams can not be empty.
 597  *
 598  * Returns: (transfer full): a new select-streams event or %NULL in case of
 599  * an error (like an empty streams list).
 600  *
 601  * Since: 1.10
 602  */
 603 GstEvent *
 604 gst_event_new_select_streams (GList * streams)
 605 {
 606   GstEvent *event;
 607   GValue val = G_VALUE_INIT;
 608   GstStructure *struc;
 609   GList *tmpl;
 610 
 611   g_return_val_if_fail (streams != NULL, NULL);
 612 
 613   GST_CAT_INFO (GST_CAT_EVENT, &quot;Creating new select-streams event&quot;);
 614   struc = gst_structure_new_id_empty (GST_QUARK (EVENT_SELECT_STREAMS));
 615   g_value_init (&amp;val, GST_TYPE_LIST);
 616   /* Fill struc with streams */
 617   for (tmpl = streams; tmpl; tmpl = tmpl-&gt;next) {
 618     GValue strval = G_VALUE_INIT;
 619     const gchar *str = (const gchar *) tmpl-&gt;data;
 620     g_value_init (&amp;strval, G_TYPE_STRING);
 621     g_value_set_string (&amp;strval, str);
 622     gst_value_list_append_and_take_value (&amp;val, &amp;strval);
 623   }
 624   gst_structure_id_take_value (struc, GST_QUARK (STREAMS), &amp;val);
 625   event = gst_event_new_custom (GST_EVENT_SELECT_STREAMS, struc);
 626 
 627   return event;
 628 }
 629 
 630 /**
 631  * gst_event_parse_select_streams:
 632  * @event: The event to parse
 633  * @streams: (out) (element-type utf8) (transfer full): the streams
 634  *
 635  * Parse the SELECT_STREAMS event and retrieve the contained streams.
 636  *
 637  * Since: 1.10
 638  */
 639 void
 640 gst_event_parse_select_streams (GstEvent * event, GList ** streams)
 641 {
 642   GstStructure *structure;
 643   GList *res = NULL;
 644 
 645   g_return_if_fail (GST_IS_EVENT (event));
 646   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_SELECT_STREAMS);
 647 
 648   structure = GST_EVENT_STRUCTURE (event);
 649   if (G_LIKELY (streams)) {
 650     const GValue *vlist =
 651         gst_structure_id_get_value (structure, GST_QUARK (STREAMS));
 652     guint i, sz = gst_value_list_get_size (vlist);
 653     for (i = 0; i &lt; sz; i++) {
 654       const GValue *strv = gst_value_list_get_value (vlist, i);
 655       res = g_list_append (res, g_value_dup_string (strv));
 656     }
 657     *streams = res;
 658   }
 659 }
 660 
 661 
 662 /**
 663  * gst_event_new_stream_group_done:
 664  * @group_id: the group id of the stream group which is ending
 665  *
 666  * Create a new Stream Group Done event. The stream-group-done event can
 667  * only travel downstream synchronized with the buffer flow. Elements
 668  * that receive the event on a pad should handle it mostly like EOS,
 669  * and emit any data or pending buffers that would depend on more data
 670  * arriving and unblock, since there won&#39;t be any more data.
 671  *
 672  * This event is followed by EOS at some point in the future, and is
 673  * generally used when switching pads - to unblock downstream so that
 674  * new pads can be exposed before sending EOS on the existing pads.
 675  *
 676  * Returns: (transfer full): the new stream-group-done event.
 677  *
 678  * Since: 1.10
 679  */
 680 GstEvent *
 681 gst_event_new_stream_group_done (guint group_id)
 682 {
 683   GstStructure *s;
 684 
 685   s = gst_structure_new_id (GST_QUARK (EVENT_STREAM_GROUP_DONE),
 686       GST_QUARK (GROUP_ID), G_TYPE_UINT, group_id, NULL);
 687 
 688   return gst_event_new_custom (GST_EVENT_STREAM_GROUP_DONE, s);
 689 }
 690 
 691 /**
 692  * gst_event_parse_stream_group_done:
 693  * @event: a stream-group-done event.
 694  * @group_id: (out): address of variable to store the group id into
 695  *
 696  * Parse a stream-group-done @event and store the result in the given
 697  * @group_id location.
 698  *
 699  * Since: 1.10
 700  */
 701 void
 702 gst_event_parse_stream_group_done (GstEvent * event, guint * group_id)
 703 {
 704   g_return_if_fail (event != NULL);
 705   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_GROUP_DONE);
 706 
 707   if (group_id) {
 708     gst_structure_id_get (GST_EVENT_STRUCTURE (event),
 709         GST_QUARK (GROUP_ID), G_TYPE_UINT, group_id, NULL);
 710   }
 711 }
 712 
 713 /**
 714  * gst_event_new_eos:
 715  *
 716  * Create a new EOS event. The eos event can only travel downstream
 717  * synchronized with the buffer flow. Elements that receive the EOS
 718  * event on a pad can return #GST_FLOW_EOS as a #GstFlowReturn
 719  * when data after the EOS event arrives.
 720  *
 721  * The EOS event will travel down to the sink elements in the pipeline
 722  * which will then post the #GST_MESSAGE_EOS on the bus after they have
 723  * finished playing any buffered data.
 724  *
 725  * When all sinks have posted an EOS message, an EOS message is
 726  * forwarded to the application.
 727  *
 728  * The EOS event itself will not cause any state transitions of the pipeline.
 729  *
 730  * Returns: (transfer full): the new EOS event.
 731  */
 732 GstEvent *
 733 gst_event_new_eos (void)
 734 {
 735   return gst_event_new_custom (GST_EVENT_EOS, NULL);
 736 }
 737 
 738 /**
 739  * gst_event_new_gap:
 740  * @timestamp: the start time (pts) of the gap
 741  * @duration: the duration of the gap
 742  *
 743  * Create a new GAP event. A gap event can be thought of as conceptually
 744  * equivalent to a buffer to signal that there is no data for a certain
 745  * amount of time. This is useful to signal a gap to downstream elements
 746  * which may wait for data, such as muxers or mixers or overlays, especially
 747  * for sparse streams such as subtitle streams.
 748  *
 749  * Returns: (transfer full): the new GAP event.
 750  */
 751 GstEvent *
 752 gst_event_new_gap (GstClockTime timestamp, GstClockTime duration)
 753 {
 754   GstEvent *event;
 755 
 756   g_return_val_if_fail (GST_CLOCK_TIME_IS_VALID (timestamp), NULL);
 757 
 758   GST_CAT_TRACE (GST_CAT_EVENT, &quot;creating gap %&quot; GST_TIME_FORMAT &quot; - &quot;
 759       &quot;%&quot; GST_TIME_FORMAT &quot; (duration: %&quot; GST_TIME_FORMAT &quot;)&quot;,
 760       GST_TIME_ARGS (timestamp), GST_TIME_ARGS (timestamp + duration),
 761       GST_TIME_ARGS (duration));
 762 
 763   event = gst_event_new_custom (GST_EVENT_GAP,
 764       gst_structure_new_id (GST_QUARK (EVENT_GAP),
 765           GST_QUARK (TIMESTAMP), GST_TYPE_CLOCK_TIME, timestamp,
 766           GST_QUARK (DURATION), GST_TYPE_CLOCK_TIME, duration, NULL));
 767 
 768   return event;
 769 }
 770 
 771 /**
 772  * gst_event_parse_gap:
 773  * @event: a #GstEvent of type #GST_EVENT_GAP
 774  * @timestamp: (out) (allow-none): location where to store the
 775  *     start time (pts) of the gap, or %NULL
 776  * @duration: (out) (allow-none): location where to store the duration of
 777  *     the gap, or %NULL
 778  *
 779  * Extract timestamp and duration from a new GAP event.
 780  */
 781 void
 782 gst_event_parse_gap (GstEvent * event, GstClockTime * timestamp,
 783     GstClockTime * duration)
 784 {
 785   GstStructure *structure;
 786 
 787   g_return_if_fail (GST_IS_EVENT (event));
 788   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_GAP);
 789 
 790   structure = GST_EVENT_STRUCTURE (event);
 791   gst_structure_id_get (structure,
 792       GST_QUARK (TIMESTAMP), GST_TYPE_CLOCK_TIME, timestamp,
 793       GST_QUARK (DURATION), GST_TYPE_CLOCK_TIME, duration, NULL);
 794 }
 795 
 796 /**
 797  * gst_event_new_caps:
 798  * @caps: (transfer none): a #GstCaps
 799  *
 800  * Create a new CAPS event for @caps. The caps event can only travel downstream
 801  * synchronized with the buffer flow and contains the format of the buffers
 802  * that will follow after the event.
 803  *
 804  * Returns: (transfer full) (nullable): the new CAPS event.
 805  */
 806 GstEvent *
 807 gst_event_new_caps (GstCaps * caps)
 808 {
 809   GstEvent *event;
 810 
 811   g_return_val_if_fail (caps != NULL, NULL);
 812   g_return_val_if_fail (gst_caps_is_fixed (caps), NULL);
 813 
 814   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating caps event %&quot; GST_PTR_FORMAT, caps);
 815 
 816   event = gst_event_new_custom (GST_EVENT_CAPS,
 817       gst_structure_new_id (GST_QUARK (EVENT_CAPS),
 818           GST_QUARK (CAPS), GST_TYPE_CAPS, caps, NULL));
 819 
 820   return event;
 821 }
 822 
 823 /**
 824  * gst_event_parse_caps:
 825  * @event: The event to parse
 826  * @caps: (out) (transfer none): A pointer to the caps
 827  *
 828  * Get the caps from @event. The caps remains valid as long as @event remains
 829  * valid.
 830  */
 831 void
 832 gst_event_parse_caps (GstEvent * event, GstCaps ** caps)
 833 {
 834   GstStructure *structure;
 835 
 836   g_return_if_fail (GST_IS_EVENT (event));
 837   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_CAPS);
 838 
 839   structure = GST_EVENT_STRUCTURE (event);
 840   if (G_LIKELY (caps))
 841     *caps =
 842         g_value_get_boxed (gst_structure_id_get_value (structure,
 843             GST_QUARK (CAPS)));
 844 }
 845 
 846 /**
 847  * gst_event_new_segment:
 848  * @segment: (transfer none): a #GstSegment
 849  *
 850  * Create a new SEGMENT event for @segment. The segment event can only travel
 851  * downstream synchronized with the buffer flow and contains timing information
 852  * and playback properties for the buffers that will follow.
 853  *
 854  * The segment event marks the range of buffers to be processed. All
 855  * data not within the segment range is not to be processed. This can be
 856  * used intelligently by plugins to apply more efficient methods of skipping
 857  * unneeded data. The valid range is expressed with the @start and @stop
 858  * values.
 859  *
 860  * The time value of the segment is used in conjunction with the start
 861  * value to convert the buffer timestamps into the stream time. This is
 862  * usually done in sinks to report the current stream_time.
 863  * @time represents the stream_time of a buffer carrying a timestamp of
 864  * @start. @time cannot be -1.
 865  *
 866  * @start cannot be -1, @stop can be -1. If there
 867  * is a valid @stop given, it must be greater or equal the @start, including
 868  * when the indicated playback @rate is &lt; 0.
 869  *
 870  * The @applied_rate value provides information about any rate adjustment that
 871  * has already been made to the timestamps and content on the buffers of the
 872  * stream. (@rate * @applied_rate) should always equal the rate that has been
 873  * requested for playback. For example, if an element has an input segment
 874  * with intended playback @rate of 2.0 and applied_rate of 1.0, it can adjust
 875  * incoming timestamps and buffer content by half and output a segment event
 876  * with @rate of 1.0 and @applied_rate of 2.0
 877  *
 878  * After a segment event, the buffer stream time is calculated with:
 879  *
 880  *   time + (TIMESTAMP(buf) - start) * ABS (rate * applied_rate)
 881  *
 882  * Returns: (transfer full) (nullable): the new SEGMENT event.
 883  */
 884 GstEvent *
 885 gst_event_new_segment (const GstSegment * segment)
 886 {
 887   GstEvent *event;
 888 
 889   g_return_val_if_fail (segment != NULL, NULL);
 890   g_return_val_if_fail (segment-&gt;rate != 0.0, NULL);
 891   g_return_val_if_fail (segment-&gt;applied_rate != 0.0, NULL);
 892   g_return_val_if_fail (segment-&gt;format != GST_FORMAT_UNDEFINED, NULL);
 893 
 894   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating segment event %&quot; GST_SEGMENT_FORMAT,
 895       segment);
 896 
 897   event = gst_event_new_custom (GST_EVENT_SEGMENT,
 898       gst_structure_new_id (GST_QUARK (EVENT_SEGMENT),
 899           GST_QUARK (SEGMENT), GST_TYPE_SEGMENT, segment, NULL));
 900 
 901   return event;
 902 }
 903 
 904 /**
 905  * gst_event_parse_segment:
 906  * @event: The event to parse
 907  * @segment: (out) (transfer none): a pointer to a #GstSegment
 908  *
 909  * Parses a segment @event and stores the result in the given @segment location.
 910  * @segment remains valid only until the @event is freed. Don&#39;t modify the segment
 911  * and make a copy if you want to modify it or store it for later use.
 912  */
 913 void
 914 gst_event_parse_segment (GstEvent * event, const GstSegment ** segment)
 915 {
 916   GstStructure *structure;
 917 
 918   g_return_if_fail (GST_IS_EVENT (event));
 919   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_SEGMENT);
 920 
 921   if (segment) {
 922     structure = GST_EVENT_STRUCTURE (event);
 923     *segment = g_value_get_boxed (gst_structure_id_get_value (structure,
 924             GST_QUARK (SEGMENT)));
 925   }
 926 }
 927 
 928 /**
 929  * gst_event_copy_segment:
 930  * @event: The event to parse
 931  * @segment: a pointer to a #GstSegment
 932  *
 933  * Parses a segment @event and copies the #GstSegment into the location
 934  * given by @segment.
 935  */
 936 void
 937 gst_event_copy_segment (GstEvent * event, GstSegment * segment)
 938 {
 939   const GstSegment *src;
 940 
 941   g_return_if_fail (GST_IS_EVENT (event));
 942   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_SEGMENT);
 943 
 944   if (segment) {
 945     gst_event_parse_segment (event, &amp;src);
 946     gst_segment_copy_into (src, segment);
 947   }
 948 }
 949 
 950 /**
 951  * gst_event_new_tag:
 952  * @taglist: (transfer full): metadata list. The event will take ownership
 953  *     of the taglist.
 954  *
 955  * Generates a metadata tag event from the given @taglist.
 956  *
 957  * The scope of the taglist specifies if the taglist applies to the
 958  * complete medium or only to this specific stream. As the tag event
 959  * is a sticky event, elements should merge tags received from
 960  * upstream with a given scope with their own tags with the same
 961  * scope and create a new tag event from it.
 962  *
 963  * Returns: (transfer full): a new #GstEvent
 964  */
 965 GstEvent *
 966 gst_event_new_tag (GstTagList * taglist)
 967 {
 968   GstStructure *s;
 969   GValue val = G_VALUE_INIT;
 970   const gchar *names[] = { &quot;GstTagList-stream&quot;, &quot;GstTagList-global&quot; };
 971 
 972   g_return_val_if_fail (taglist != NULL, NULL);
 973 
 974   s = gst_structure_new_empty (names[gst_tag_list_get_scope (taglist)]);
 975   g_value_init (&amp;val, GST_TYPE_TAG_LIST);
 976   g_value_take_boxed (&amp;val, taglist);
 977   gst_structure_id_take_value (s, GST_QUARK (TAGLIST), &amp;val);
 978   return gst_event_new_custom (GST_EVENT_TAG, s);
 979 }
 980 
 981 /**
 982  * gst_event_parse_tag:
 983  * @event: a tag event
 984  * @taglist: (out) (transfer none): pointer to metadata list
 985  *
 986  * Parses a tag @event and stores the results in the given @taglist location.
 987  * No reference to the taglist will be returned, it remains valid only until
 988  * the @event is freed. Don&#39;t modify or free the taglist, make a copy if you
 989  * want to modify it or store it for later use.
 990  */
 991 void
 992 gst_event_parse_tag (GstEvent * event, GstTagList ** taglist)
 993 {
 994   const GValue *val;
 995 
 996   g_return_if_fail (GST_IS_EVENT (event));
 997   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_TAG);
 998 
 999   val = gst_structure_id_get_value (GST_EVENT_STRUCTURE (event),
1000       GST_QUARK (TAGLIST));
1001 
1002   if (taglist)
1003     *taglist = (GstTagList *) g_value_get_boxed (val);
1004 }
1005 
1006 /* buffersize event */
1007 /**
1008  * gst_event_new_buffer_size:
1009  * @format: buffer format
1010  * @minsize: minimum buffer size
1011  * @maxsize: maximum buffer size
1012  * @async: thread behavior
1013  *
1014  * Create a new buffersize event. The event is sent downstream and notifies
1015  * elements that they should provide a buffer of the specified dimensions.
1016  *
1017  * When the @async flag is set, a thread boundary is preferred.
1018  *
1019  * Returns: (transfer full): a new #GstEvent
1020  */
1021 GstEvent *
1022 gst_event_new_buffer_size (GstFormat format, gint64 minsize,
1023     gint64 maxsize, gboolean async)
1024 {
1025   GstEvent *event;
1026   GstStructure *structure;
1027 
1028   GST_CAT_INFO (GST_CAT_EVENT,
1029       &quot;creating buffersize format %s, minsize %&quot; G_GINT64_FORMAT
1030       &quot;, maxsize %&quot; G_GINT64_FORMAT &quot;, async %d&quot;, gst_format_get_name (format),
1031       minsize, maxsize, async);
1032 
1033   structure = gst_structure_new_id (GST_QUARK (EVENT_BUFFER_SIZE),
1034       GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,
1035       GST_QUARK (MINSIZE), G_TYPE_INT64, minsize,
1036       GST_QUARK (MAXSIZE), G_TYPE_INT64, maxsize,
1037       GST_QUARK (ASYNC), G_TYPE_BOOLEAN, async, NULL);
1038   event = gst_event_new_custom (GST_EVENT_BUFFERSIZE, structure);
1039 
1040   return event;
1041 }
1042 
1043 /**
1044  * gst_event_parse_buffer_size:
1045  * @event: The event to query
1046  * @format: (out): A pointer to store the format in
1047  * @minsize: (out): A pointer to store the minsize in
1048  * @maxsize: (out): A pointer to store the maxsize in
1049  * @async: (out): A pointer to store the async-flag in
1050  *
1051  * Get the format, minsize, maxsize and async-flag in the buffersize event.
1052  */
1053 void
1054 gst_event_parse_buffer_size (GstEvent * event, GstFormat * format,
1055     gint64 * minsize, gint64 * maxsize, gboolean * async)
1056 {
1057   const GstStructure *structure;
1058 
1059   g_return_if_fail (GST_IS_EVENT (event));
1060   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_BUFFERSIZE);
1061 
1062   structure = GST_EVENT_STRUCTURE (event);
1063   if (format)
1064     *format = (GstFormat)
1065         g_value_get_enum (gst_structure_id_get_value (structure,
1066             GST_QUARK (FORMAT)));
1067   if (minsize)
1068     *minsize =
1069         g_value_get_int64 (gst_structure_id_get_value (structure,
1070             GST_QUARK (MINSIZE)));
1071   if (maxsize)
1072     *maxsize =
1073         g_value_get_int64 (gst_structure_id_get_value (structure,
1074             GST_QUARK (MAXSIZE)));
1075   if (async)
1076     *async =
1077         g_value_get_boolean (gst_structure_id_get_value (structure,
1078             GST_QUARK (ASYNC)));
1079 }
1080 
1081 /**
1082  * gst_event_new_qos:
1083  * @type: the QoS type
1084  * @proportion: the proportion of the qos message
1085  * @diff: The time difference of the last Clock sync
1086  * @timestamp: The timestamp of the buffer
1087  *
1088  * Allocate a new qos event with the given values.
1089  * The QOS event is generated in an element that wants an upstream
1090  * element to either reduce or increase its rate because of
1091  * high/low CPU load or other resource usage such as network performance or
1092  * throttling. Typically sinks generate these events for each buffer
1093  * they receive.
1094  *
1095  * @type indicates the reason for the QoS event. #GST_QOS_TYPE_OVERFLOW is
1096  * used when a buffer arrived in time or when the sink cannot keep up with
1097  * the upstream datarate. #GST_QOS_TYPE_UNDERFLOW is when the sink is not
1098  * receiving buffers fast enough and thus has to drop late buffers.
1099  * #GST_QOS_TYPE_THROTTLE is used when the datarate is artificially limited
1100  * by the application, for example to reduce power consumption.
1101  *
1102  * @proportion indicates the real-time performance of the streaming in the
1103  * element that generated the QoS event (usually the sink). The value is
1104  * generally computed based on more long term statistics about the streams
1105  * timestamps compared to the clock.
1106  * A value &lt; 1.0 indicates that the upstream element is producing data faster
1107  * than real-time. A value &gt; 1.0 indicates that the upstream element is not
1108  * producing data fast enough. 1.0 is the ideal @proportion value. The
1109  * proportion value can safely be used to lower or increase the quality of
1110  * the element.
1111  *
1112  * @diff is the difference against the clock in running time of the last
1113  * buffer that caused the element to generate the QOS event. A negative value
1114  * means that the buffer with @timestamp arrived in time. A positive value
1115  * indicates how late the buffer with @timestamp was. When throttling is
1116  * enabled, @diff will be set to the requested throttling interval.
1117  *
1118  * @timestamp is the timestamp of the last buffer that cause the element
1119  * to generate the QOS event. It is expressed in running time and thus an ever
1120  * increasing value.
1121  *
1122  * The upstream element can use the @diff and @timestamp values to decide
1123  * whether to process more buffers. For positive @diff, all buffers with
1124  * timestamp &lt;= @timestamp + @diff will certainly arrive late in the sink
1125  * as well. A (negative) @diff value so that @timestamp + @diff would yield a
1126  * result smaller than 0 is not allowed.
1127  *
1128  * The application can use general event probes to intercept the QoS
1129  * event and implement custom application specific QoS handling.
1130  *
1131  * Returns: (transfer full) (nullable): a new QOS event.
1132  */
1133 GstEvent *
1134 gst_event_new_qos (GstQOSType type, gdouble proportion,
1135     GstClockTimeDiff diff, GstClockTime timestamp)
1136 {
1137   GstEvent *event;
1138   GstStructure *structure;
1139 
1140   /* diff must be positive or timestamp + diff must be positive */
1141   g_return_val_if_fail (diff &gt;= 0 || -diff &lt;= timestamp, NULL);
1142 
1143   GST_CAT_LOG (GST_CAT_EVENT,
1144       &quot;creating qos type %d, proportion %lf, diff %&quot; G_GINT64_FORMAT
1145       &quot;, timestamp %&quot; GST_TIME_FORMAT, type, proportion,
1146       diff, GST_TIME_ARGS (timestamp));
1147 
1148   structure = gst_structure_new_id (GST_QUARK (EVENT_QOS),
1149       GST_QUARK (TYPE), GST_TYPE_QOS_TYPE, type,
1150       GST_QUARK (PROPORTION), G_TYPE_DOUBLE, proportion,
1151       GST_QUARK (DIFF), G_TYPE_INT64, diff,
1152       GST_QUARK (TIMESTAMP), G_TYPE_UINT64, timestamp, NULL);
1153   event = gst_event_new_custom (GST_EVENT_QOS, structure);
1154 
1155   return event;
1156 }
1157 
1158 /**
1159  * gst_event_parse_qos:
1160  * @event: The event to query
1161  * @type: (out): A pointer to store the QoS type in
1162  * @proportion: (out): A pointer to store the proportion in
1163  * @diff: (out): A pointer to store the diff in
1164  * @timestamp: (out): A pointer to store the timestamp in
1165  *
1166  * Get the type, proportion, diff and timestamp in the qos event. See
1167  * gst_event_new_qos() for more information about the different QoS values.
1168  *
1169  * @timestamp will be adjusted for any pad offsets of pads it was passing through.
1170  */
1171 void
1172 gst_event_parse_qos (GstEvent * event, GstQOSType * type,
1173     gdouble * proportion, GstClockTimeDiff * diff, GstClockTime * timestamp)
1174 {
1175   const GstStructure *structure;
1176 
1177   g_return_if_fail (GST_IS_EVENT (event));
1178   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_QOS);
1179 
1180   structure = GST_EVENT_STRUCTURE (event);
1181   if (type)
1182     *type = (GstQOSType)
1183         g_value_get_enum (gst_structure_id_get_value (structure,
1184             GST_QUARK (TYPE)));
1185   if (proportion)
1186     *proportion =
1187         g_value_get_double (gst_structure_id_get_value (structure,
1188             GST_QUARK (PROPORTION)));
1189   if (diff)
1190     *diff =
1191         g_value_get_int64 (gst_structure_id_get_value (structure,
1192             GST_QUARK (DIFF)));
1193   if (timestamp) {
1194     gint64 offset = gst_event_get_running_time_offset (event);
1195     GstClockTimeDiff diff_ =
1196         g_value_get_int64 (gst_structure_id_get_value (structure,
1197             GST_QUARK (DIFF)));
1198 
1199     *timestamp =
1200         g_value_get_uint64 (gst_structure_id_get_value (structure,
1201             GST_QUARK (TIMESTAMP)));
1202     /* Catch underflows */
1203     if (*timestamp &gt; -offset)
1204       *timestamp += offset;
1205     else
1206       *timestamp = 0;
1207 
1208     /* Make sure that timestamp + diff is always &gt;= 0. Because
1209      * of the running time offset this might not be true */
1210     if (diff_ &lt; 0 &amp;&amp; *timestamp &lt; -diff_)
1211       *timestamp = (GstClockTime) - diff_;
1212   }
1213 }
1214 
1215 /**
1216  * gst_event_new_seek:
1217  * @rate: The new playback rate
1218  * @format: The format of the seek values
1219  * @flags: The optional seek flags
1220  * @start_type: The type and flags for the new start position
1221  * @start: The value of the new start position
1222  * @stop_type: The type and flags for the new stop position
1223  * @stop: The value of the new stop position
1224  *
1225  * Allocate a new seek event with the given parameters.
1226  *
1227  * The seek event configures playback of the pipeline between @start to @stop
1228  * at the speed given in @rate, also called a playback segment.
1229  * The @start and @stop values are expressed in @format.
1230  *
1231  * A @rate of 1.0 means normal playback rate, 2.0 means double speed.
1232  * Negatives values means backwards playback. A value of 0.0 for the
1233  * rate is not allowed and should be accomplished instead by PAUSING the
1234  * pipeline.
1235  *
1236  * A pipeline has a default playback segment configured with a start
1237  * position of 0, a stop position of -1 and a rate of 1.0. The currently
1238  * configured playback segment can be queried with #GST_QUERY_SEGMENT.
1239  *
1240  * @start_type and @stop_type specify how to adjust the currently configured
1241  * start and stop fields in playback segment. Adjustments can be made relative
1242  * or absolute to the last configured values. A type of #GST_SEEK_TYPE_NONE
1243  * means that the position should not be updated.
1244  *
1245  * When the rate is positive and @start has been updated, playback will start
1246  * from the newly configured start position.
1247  *
1248  * For negative rates, playback will start from the newly configured stop
1249  * position (if any). If the stop position is updated, it must be different from
1250  * -1 (#GST_CLOCK_TIME_NONE) for negative rates.
1251  *
1252  * It is not possible to seek relative to the current playback position, to do
1253  * this, PAUSE the pipeline, query the current playback position with
1254  * #GST_QUERY_POSITION and update the playback segment current position with a
1255  * #GST_SEEK_TYPE_SET to the desired position.
1256  *
1257  * Returns: (transfer full) (nullable): a new seek event.
1258  */
1259 GstEvent *
1260 gst_event_new_seek (gdouble rate, GstFormat format, GstSeekFlags flags,
1261     GstSeekType start_type, gint64 start, GstSeekType stop_type, gint64 stop)
1262 {
1263   GstEvent *event;
1264   GstStructure *structure;
1265 
1266   g_return_val_if_fail (rate != 0.0, NULL);
1267 
<a name="4" id="anc4"></a>











1268   if (format == GST_FORMAT_TIME) {
1269     GST_CAT_INFO (GST_CAT_EVENT,
1270         &quot;creating seek rate %lf, format TIME, flags %d, &quot;
1271         &quot;start_type %d, start %&quot; GST_TIME_FORMAT &quot;, &quot;
1272         &quot;stop_type %d, stop %&quot; GST_TIME_FORMAT,
1273         rate, flags, start_type, GST_TIME_ARGS (start),
1274         stop_type, GST_TIME_ARGS (stop));
1275   } else {
1276     GST_CAT_INFO (GST_CAT_EVENT,
1277         &quot;creating seek rate %lf, format %s, flags %d, &quot;
1278         &quot;start_type %d, start %&quot; G_GINT64_FORMAT &quot;, &quot;
1279         &quot;stop_type %d, stop %&quot; G_GINT64_FORMAT,
1280         rate, gst_format_get_name (format), flags, start_type, start, stop_type,
1281         stop);
1282   }
1283 
1284   structure = gst_structure_new_id (GST_QUARK (EVENT_SEEK),
1285       GST_QUARK (RATE), G_TYPE_DOUBLE, rate,
1286       GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,
1287       GST_QUARK (FLAGS), GST_TYPE_SEEK_FLAGS, flags,
1288       GST_QUARK (CUR_TYPE), GST_TYPE_SEEK_TYPE, start_type,
1289       GST_QUARK (CUR), G_TYPE_INT64, start,
1290       GST_QUARK (STOP_TYPE), GST_TYPE_SEEK_TYPE, stop_type,
<a name="5" id="anc5"></a><span class="line-modified">1291       GST_QUARK (STOP), G_TYPE_INT64, stop, NULL);</span>


1292   event = gst_event_new_custom (GST_EVENT_SEEK, structure);
1293 
1294   return event;
1295 }
1296 
1297 /**
1298  * gst_event_parse_seek:
1299  * @event: a seek event
1300  * @rate: (out): result location for the rate
1301  * @format: (out): result location for the stream format
1302  * @flags:  (out): result location for the #GstSeekFlags
1303  * @start_type: (out): result location for the #GstSeekType of the start position
1304  * @start: (out): result location for the start position expressed in @format
1305  * @stop_type:  (out): result location for the #GstSeekType of the stop position
1306  * @stop: (out): result location for the stop position expressed in @format
1307  *
1308  * Parses a seek @event and stores the results in the given result locations.
1309  */
1310 void
1311 gst_event_parse_seek (GstEvent * event, gdouble * rate,
1312     GstFormat * format, GstSeekFlags * flags, GstSeekType * start_type,
1313     gint64 * start, GstSeekType * stop_type, gint64 * stop)
1314 {
1315   const GstStructure *structure;
1316 
1317   g_return_if_fail (GST_IS_EVENT (event));
1318   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_SEEK);
1319 
1320   structure = GST_EVENT_STRUCTURE (event);
1321   if (rate)
1322     *rate =
1323         g_value_get_double (gst_structure_id_get_value (structure,
1324             GST_QUARK (RATE)));
1325   if (format)
1326     *format = (GstFormat)
1327         g_value_get_enum (gst_structure_id_get_value (structure,
1328             GST_QUARK (FORMAT)));
1329   if (flags)
1330     *flags = (GstSeekFlags)
1331         g_value_get_flags (gst_structure_id_get_value (structure,
1332             GST_QUARK (FLAGS)));
1333   if (start_type)
1334     *start_type = (GstSeekType)
1335         g_value_get_enum (gst_structure_id_get_value (structure,
1336             GST_QUARK (CUR_TYPE)));
1337   if (start)
1338     *start =
1339         g_value_get_int64 (gst_structure_id_get_value (structure,
1340             GST_QUARK (CUR)));
1341   if (stop_type)
1342     *stop_type = (GstSeekType)
1343         g_value_get_enum (gst_structure_id_get_value (structure,
1344             GST_QUARK (STOP_TYPE)));
1345   if (stop)
1346     *stop =
1347         g_value_get_int64 (gst_structure_id_get_value (structure,
1348             GST_QUARK (STOP)));
1349 }
1350 
<a name="6" id="anc6"></a>









































1351 /**
1352  * gst_event_new_navigation:
1353  * @structure: (transfer full): description of the event. The event will take
1354  *     ownership of the structure.
1355  *
1356  * Create a new navigation event from the given description.
1357  *
1358  * Returns: (transfer full): a new #GstEvent
1359  */
1360 GstEvent *
1361 gst_event_new_navigation (GstStructure * structure)
1362 {
1363   g_return_val_if_fail (structure != NULL, NULL);
1364 
1365   return gst_event_new_custom (GST_EVENT_NAVIGATION, structure);
1366 }
1367 
1368 /**
1369  * gst_event_new_latency:
1370  * @latency: the new latency value
1371  *
1372  * Create a new latency event. The event is sent upstream from the sinks and
1373  * notifies elements that they should add an additional @latency to the
1374  * running time before synchronising against the clock.
1375  *
1376  * The latency is mostly used in live sinks and is always expressed in
1377  * the time format.
1378  *
1379  * Returns: (transfer full): a new #GstEvent
1380  */
1381 GstEvent *
1382 gst_event_new_latency (GstClockTime latency)
1383 {
1384   GstEvent *event;
1385   GstStructure *structure;
1386 
1387   GST_CAT_INFO (GST_CAT_EVENT,
1388       &quot;creating latency event %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (latency));
1389 
1390   structure = gst_structure_new_id (GST_QUARK (EVENT_LATENCY),
1391       GST_QUARK (LATENCY), G_TYPE_UINT64, latency, NULL);
1392   event = gst_event_new_custom (GST_EVENT_LATENCY, structure);
1393 
1394   return event;
1395 }
1396 
1397 /**
1398  * gst_event_parse_latency:
1399  * @event: The event to query
1400  * @latency: (out): A pointer to store the latency in.
1401  *
1402  * Get the latency in the latency event.
1403  */
1404 void
1405 gst_event_parse_latency (GstEvent * event, GstClockTime * latency)
1406 {
1407   g_return_if_fail (GST_IS_EVENT (event));
1408   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_LATENCY);
1409 
1410   if (latency)
1411     *latency =
1412         g_value_get_uint64 (gst_structure_id_get_value (GST_EVENT_STRUCTURE
1413             (event), GST_QUARK (LATENCY)));
1414 }
1415 
1416 /**
1417  * gst_event_new_step:
1418  * @format: the format of @amount
1419  * @amount: the amount of data to step
1420  * @rate: the step rate
1421  * @flush: flushing steps
1422  * @intermediate: intermediate steps
1423  *
1424  * Create a new step event. The purpose of the step event is to instruct a sink
1425  * to skip @amount (expressed in @format) of media. It can be used to implement
1426  * stepping through the video frame by frame or for doing fast trick modes.
1427  *
1428  * A rate of &lt;= 0.0 is not allowed. Pause the pipeline, for the effect of rate
1429  * = 0.0 or first reverse the direction of playback using a seek event to get
1430  * the same effect as rate &lt; 0.0.
1431  *
1432  * The @flush flag will clear any pending data in the pipeline before starting
1433  * the step operation.
1434  *
1435  * The @intermediate flag instructs the pipeline that this step operation is
1436  * part of a larger step operation.
1437  *
1438  * Returns: (transfer full) (nullable): a new #GstEvent
1439  */
1440 GstEvent *
1441 gst_event_new_step (GstFormat format, guint64 amount, gdouble rate,
1442     gboolean flush, gboolean intermediate)
1443 {
1444   GstEvent *event;
1445   GstStructure *structure;
1446 
1447   g_return_val_if_fail (rate &gt; 0.0, NULL);
1448 
1449   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating step event&quot;);
1450 
1451   structure = gst_structure_new_id (GST_QUARK (EVENT_STEP),
1452       GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,
1453       GST_QUARK (AMOUNT), G_TYPE_UINT64, amount,
1454       GST_QUARK (RATE), G_TYPE_DOUBLE, rate,
1455       GST_QUARK (FLUSH), G_TYPE_BOOLEAN, flush,
1456       GST_QUARK (INTERMEDIATE), G_TYPE_BOOLEAN, intermediate, NULL);
1457   event = gst_event_new_custom (GST_EVENT_STEP, structure);
1458 
1459   return event;
1460 }
1461 
1462 /**
1463  * gst_event_parse_step:
1464  * @event: The event to query
1465  * @format: (out) (allow-none): a pointer to store the format in
1466  * @amount: (out) (allow-none): a pointer to store the amount in
1467  * @rate: (out) (allow-none): a pointer to store the rate in
1468  * @flush: (out) (allow-none): a pointer to store the flush boolean in
1469  * @intermediate: (out) (allow-none): a pointer to store the intermediate
1470  *     boolean in
1471  *
1472  * Parse the step event.
1473  */
1474 void
1475 gst_event_parse_step (GstEvent * event, GstFormat * format, guint64 * amount,
1476     gdouble * rate, gboolean * flush, gboolean * intermediate)
1477 {
1478   const GstStructure *structure;
1479 
1480   g_return_if_fail (GST_IS_EVENT (event));
1481   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STEP);
1482 
1483   structure = GST_EVENT_STRUCTURE (event);
1484   if (format)
1485     *format =
1486         (GstFormat) g_value_get_enum (gst_structure_id_get_value (structure,
1487             GST_QUARK (FORMAT)));
1488   if (amount)
1489     *amount = g_value_get_uint64 (gst_structure_id_get_value (structure,
1490             GST_QUARK (AMOUNT)));
1491   if (rate)
1492     *rate = g_value_get_double (gst_structure_id_get_value (structure,
1493             GST_QUARK (RATE)));
1494   if (flush)
1495     *flush = g_value_get_boolean (gst_structure_id_get_value (structure,
1496             GST_QUARK (FLUSH)));
1497   if (intermediate)
1498     *intermediate = g_value_get_boolean (gst_structure_id_get_value (structure,
1499             GST_QUARK (INTERMEDIATE)));
1500 }
1501 
1502 /**
1503  * gst_event_new_reconfigure:
1504 
1505  * Create a new reconfigure event. The purpose of the reconfigure event is
1506  * to travel upstream and make elements renegotiate their caps or reconfigure
1507  * their buffer pools. This is useful when changing properties on elements
1508  * or changing the topology of the pipeline.
1509  *
1510  * Returns: (transfer full): a new #GstEvent
1511  */
1512 GstEvent *
1513 gst_event_new_reconfigure (void)
1514 {
1515   GstEvent *event;
1516 
1517   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating reconfigure event&quot;);
1518 
1519   event = gst_event_new_custom (GST_EVENT_RECONFIGURE, NULL);
1520 
1521   return event;
1522 }
1523 
1524 /**
1525  * gst_event_new_sink_message:
1526  * @name: a name for the event
1527  * @msg: (transfer none): the #GstMessage to be posted
1528  *
1529  * Create a new sink-message event. The purpose of the sink-message event is
1530  * to instruct a sink to post the message contained in the event synchronized
1531  * with the stream.
1532  *
1533  * @name is used to store multiple sticky events on one pad.
1534  *
1535  * Returns: (transfer full): a new #GstEvent
1536  */
1537 /* FIXME 2.0: take ownership of msg for consistency? */
1538 GstEvent *
1539 gst_event_new_sink_message (const gchar * name, GstMessage * msg)
1540 {
1541   GstEvent *event;
1542   GstStructure *structure;
1543 
1544   g_return_val_if_fail (msg != NULL, NULL);
1545 
1546   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating sink-message event&quot;);
1547 
1548   structure = gst_structure_new_id (g_quark_from_string (name),
1549       GST_QUARK (MESSAGE), GST_TYPE_MESSAGE, msg, NULL);
1550   event = gst_event_new_custom (GST_EVENT_SINK_MESSAGE, structure);
1551 
1552   return event;
1553 }
1554 
1555 /**
1556  * gst_event_parse_sink_message:
1557  * @event: The event to query
1558  * @msg: (out) (transfer full): a pointer to store the #GstMessage in.
1559  *
1560  * Parse the sink-message event. Unref @msg after usage.
1561  */
1562 void
1563 gst_event_parse_sink_message (GstEvent * event, GstMessage ** msg)
1564 {
1565   const GstStructure *structure;
1566 
1567   g_return_if_fail (GST_IS_EVENT (event));
1568   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_SINK_MESSAGE);
1569 
1570   structure = GST_EVENT_STRUCTURE (event);
1571   if (msg)
1572     *msg =
1573         GST_MESSAGE (g_value_dup_boxed (gst_structure_id_get_value
1574             (structure, GST_QUARK (MESSAGE))));
1575 }
1576 
1577 /**
1578  * gst_event_new_stream_start:
1579  * @stream_id: Identifier for this stream
1580  *
1581  * Create a new STREAM_START event. The stream start event can only
1582  * travel downstream synchronized with the buffer flow. It is expected
1583  * to be the first event that is sent for a new stream.
1584  *
1585  * Source elements, demuxers and other elements that create new streams
1586  * are supposed to send this event as the first event of a new stream. It
1587  * should not be sent after a flushing seek or in similar situations
1588  * and is used to mark the beginning of a new logical stream. Elements
1589  * combining multiple streams must ensure that this event is only forwarded
1590  * downstream once and not for every single input stream.
1591  *
1592  * The @stream_id should be a unique string that consists of the upstream
1593  * stream-id, / as separator and a unique stream-id for this specific
1594  * stream. A new stream-id should only be created for a stream if the upstream
1595  * stream is split into (potentially) multiple new streams, e.g. in a demuxer,
1596  * but not for every single element in the pipeline.
1597  * gst_pad_create_stream_id() or gst_pad_create_stream_id_printf() can be
1598  * used to create a stream-id.  There are no particular semantics for the
1599  * stream-id, though it should be deterministic (to support stream matching)
1600  * and it might be used to order streams (besides any information conveyed by
1601  * stream flags).
1602  *
1603  * Returns: (transfer full): the new STREAM_START event.
1604  */
1605 GstEvent *
1606 gst_event_new_stream_start (const gchar * stream_id)
1607 {
1608   GstStructure *s;
1609 
1610   g_return_val_if_fail (stream_id != NULL, NULL);
1611 
1612   s = gst_structure_new_id (GST_QUARK (EVENT_STREAM_START),
1613       GST_QUARK (STREAM_ID), G_TYPE_STRING, stream_id,
1614       GST_QUARK (FLAGS), GST_TYPE_STREAM_FLAGS, GST_STREAM_FLAG_NONE, NULL);
1615 
1616   return gst_event_new_custom (GST_EVENT_STREAM_START, s);
1617 }
1618 
1619 /**
1620  * gst_event_parse_stream_start:
1621  * @event: a stream-start event.
1622  * @stream_id: (out) (transfer none): pointer to store the stream-id
1623  *
1624  * Parse a stream-id @event and store the result in the given @stream_id
1625  * location. The string stored in @stream_id must not be modified and will
1626  * remain valid only until @event gets freed. Make a copy if you want to
1627  * modify it or store it for later use.
1628  */
1629 void
1630 gst_event_parse_stream_start (GstEvent * event, const gchar ** stream_id)
1631 {
1632   const GstStructure *structure;
1633   const GValue *val;
1634 
1635   g_return_if_fail (event != NULL);
1636   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START);
1637 
1638   structure = gst_event_get_structure (event);
1639   val = gst_structure_id_get_value (structure, GST_QUARK (STREAM_ID));
1640 
1641   if (stream_id)
1642     *stream_id = g_value_get_string (val);
1643 }
1644 
1645 /**
1646  * gst_event_set_stream:
1647  * @event: a stream-start event
1648  * @stream: (transfer none): the stream object to set
1649  *
1650  * Set the @stream on the stream-start @event
1651  *
1652  * Since: 1.10
1653  */
1654 void
1655 gst_event_set_stream (GstEvent * event, GstStream * stream)
1656 {
1657   g_return_if_fail (event != NULL);
1658   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START);
1659   g_return_if_fail (gst_event_is_writable (event));
1660 
1661   gst_structure_id_set (GST_EVENT_STRUCTURE (event),
1662       GST_QUARK (STREAM), GST_TYPE_STREAM, stream, NULL);
1663 }
1664 
1665 /**
1666  * gst_event_parse_stream:
1667  * @event: a stream-start event
<a name="7" id="anc7"></a><span class="line-modified">1668  * @stream: (out) (transfer full): adress of variable to store the stream</span>
1669  *
1670  * Parse a stream-start @event and extract the #GstStream from it.
1671  *
1672  * Since: 1.10
1673  */
1674 void
1675 gst_event_parse_stream (GstEvent * event, GstStream ** stream)
1676 {
1677   g_return_if_fail (event != NULL);
1678   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START);
1679 
1680   if (stream) {
1681     gst_structure_id_get (GST_EVENT_STRUCTURE (event),
1682         GST_QUARK (STREAM), GST_TYPE_STREAM, stream, NULL);
1683   }
1684 
1685 }
1686 
1687 /**
1688  * gst_event_set_stream_flags:
1689  * @event: a stream-start event
1690  * @flags: the stream flags to set
1691  *
1692  * Since: 1.2
1693  */
1694 void
1695 gst_event_set_stream_flags (GstEvent * event, GstStreamFlags flags)
1696 {
1697   g_return_if_fail (event != NULL);
1698   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START);
1699   g_return_if_fail (gst_event_is_writable (event));
1700 
1701   gst_structure_id_set (GST_EVENT_STRUCTURE (event),
1702       GST_QUARK (FLAGS), GST_TYPE_STREAM_FLAGS, flags, NULL);
1703 }
1704 
1705 /**
1706  * gst_event_parse_stream_flags:
1707  * @event: a stream-start event
1708  * @flags: (out): address of variable where to store the stream flags
1709  *
1710  * Since: 1.2
1711  */
1712 void
1713 gst_event_parse_stream_flags (GstEvent * event, GstStreamFlags * flags)
1714 {
1715   g_return_if_fail (event != NULL);
1716   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START);
1717 
1718   if (flags) {
1719     gst_structure_id_get (GST_EVENT_STRUCTURE (event),
1720         GST_QUARK (FLAGS), GST_TYPE_STREAM_FLAGS, flags, NULL);
1721   }
1722 }
1723 
1724 /**
1725  * gst_event_set_group_id:
1726  * @event: a stream-start event
1727  * @group_id: the group id to set
1728  *
1729  * All streams that have the same group id are supposed to be played
1730  * together, i.e. all streams inside a container file should have the
1731  * same group id but different stream ids. The group id should change
1732  * each time the stream is started, resulting in different group ids
1733  * each time a file is played for example.
1734  *
1735  * Use gst_util_group_id_next() to get a new group id.
1736  *
1737  * Since: 1.2
1738  */
1739 void
1740 gst_event_set_group_id (GstEvent * event, guint group_id)
1741 {
1742   g_return_if_fail (event != NULL);
1743   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START);
1744   g_return_if_fail (gst_event_is_writable (event));
1745 
1746   gst_structure_id_set (GST_EVENT_STRUCTURE (event),
1747       GST_QUARK (GROUP_ID), G_TYPE_UINT, group_id, NULL);
1748 }
1749 
1750 /**
1751  * gst_event_parse_group_id:
1752  * @event: a stream-start event
1753  * @group_id: (out): address of variable where to store the group id
1754  *
1755  * Returns: %TRUE if a group id was set on the event and could be parsed,
1756  *   %FALSE otherwise.
1757  *
1758  * Since: 1.2
1759  */
1760 gboolean
1761 gst_event_parse_group_id (GstEvent * event, guint * group_id)
1762 {
1763   g_return_val_if_fail (event != NULL, FALSE);
1764   g_return_val_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START,
1765       FALSE);
1766 
1767   if (group_id) {
1768     return gst_structure_id_get (GST_EVENT_STRUCTURE (event),
1769         GST_QUARK (GROUP_ID), G_TYPE_UINT, group_id, NULL);
1770   }
1771 
1772   return TRUE;
1773 }
1774 
1775 /**
1776  * gst_event_new_stream_collection:
1777  * @collection: Active collection for this data flow
1778  *
1779  * Create a new STREAM_COLLECTION event. The stream collection event can only
1780  * travel downstream synchronized with the buffer flow.
1781  *
1782  * Source elements, demuxers and other elements that manage collections
1783  * of streams and post #GstStreamCollection messages on the bus also send
1784  * this event downstream on each pad involved in the collection, so that
1785  * activation of a new collection can be tracked through the downstream
1786  * data flow.
1787  *
1788  * Returns: (transfer full): the new STREAM_COLLECTION event.
1789  *
1790  * Since: 1.10
1791  */
1792 GstEvent *
1793 gst_event_new_stream_collection (GstStreamCollection * collection)
1794 {
1795   GstStructure *s;
1796 
1797   g_return_val_if_fail (collection != NULL, NULL);
1798   g_return_val_if_fail (GST_IS_STREAM_COLLECTION (collection), NULL);
1799 
1800   s = gst_structure_new_id (GST_QUARK (EVENT_STREAM_COLLECTION),
1801       GST_QUARK (COLLECTION), GST_TYPE_STREAM_COLLECTION, collection, NULL);
1802 
1803   return gst_event_new_custom (GST_EVENT_STREAM_COLLECTION, s);
1804 }
1805 
1806 /**
1807  * gst_event_parse_stream_collection:
1808  * @event: a stream-collection event
1809  * @collection: (out): pointer to store the collection
1810  *
1811  * Retrieve new #GstStreamCollection from STREAM_COLLECTION event @event.
1812  *
1813  * Since: 1.10
1814  */
1815 void
1816 gst_event_parse_stream_collection (GstEvent * event,
1817     GstStreamCollection ** collection)
1818 {
1819   const GstStructure *structure;
1820 
1821   g_return_if_fail (event != NULL);
1822   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_COLLECTION);
1823 
1824   structure = gst_event_get_structure (event);
1825 
1826   if (collection) {
1827     gst_structure_id_get (structure,
1828         GST_QUARK (COLLECTION), GST_TYPE_STREAM_COLLECTION, collection, NULL);
1829   }
1830 }
1831 
1832 /**
1833  * gst_event_new_toc:
1834  * @toc: (transfer none): #GstToc structure.
1835  * @updated: whether @toc was updated or not.
1836  *
1837  * Generate a TOC event from the given @toc. The purpose of the TOC event is to
1838  * inform elements that some kind of the TOC was found.
1839  *
1840  * Returns: (transfer full): a new #GstEvent.
1841  */
1842 GstEvent *
1843 gst_event_new_toc (GstToc * toc, gboolean updated)
1844 {
1845   GstStructure *toc_struct;
1846   GQuark id;
1847 
1848   g_return_val_if_fail (toc != NULL, NULL);
1849 
1850   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating toc event&quot;);
1851 
1852   /* need different structure names so sticky_multi event stuff on pads
1853    * works, i.e. both TOC events are kept around */
1854   if (gst_toc_get_scope (toc) == GST_TOC_SCOPE_GLOBAL)
1855     id = GST_QUARK (EVENT_TOC_GLOBAL);
1856   else
1857     id = GST_QUARK (EVENT_TOC_CURRENT);
1858 
1859   toc_struct = gst_structure_new_id (id,
1860       GST_QUARK (TOC), GST_TYPE_TOC, toc,
1861       GST_QUARK (UPDATED), G_TYPE_BOOLEAN, updated, NULL);
1862 
1863   return gst_event_new_custom (GST_EVENT_TOC, toc_struct);
1864 }
1865 
1866 /**
1867  * gst_event_parse_toc:
1868  * @event: a TOC event.
1869  * @toc: (out) (transfer full): pointer to #GstToc structure.
1870  * @updated: (out): pointer to store TOC updated flag.
1871  *
1872  * Parse a TOC @event and store the results in the given @toc and @updated locations.
1873  */
1874 void
1875 gst_event_parse_toc (GstEvent * event, GstToc ** toc, gboolean * updated)
1876 {
1877   const GstStructure *structure;
1878 
1879   g_return_if_fail (event != NULL);
1880   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_TOC);
1881   g_return_if_fail (toc != NULL);
1882 
1883   structure = gst_event_get_structure (event);
1884 
1885   gst_structure_id_get (structure,
1886       GST_QUARK (TOC), GST_TYPE_TOC, toc,
1887       GST_QUARK (UPDATED), G_TYPE_BOOLEAN, updated, NULL);
1888 }
1889 
1890 /**
1891  * gst_event_new_toc_select:
1892  * @uid: UID in the TOC to start playback from.
1893  *
1894  * Generate a TOC select event with the given @uid. The purpose of the
1895  * TOC select event is to start playback based on the TOC&#39;s entry with the
1896  * given @uid.
1897  *
1898  * Returns: a new #GstEvent.
1899  */
1900 GstEvent *
1901 gst_event_new_toc_select (const gchar * uid)
1902 {
1903   GstStructure *structure;
1904 
1905   g_return_val_if_fail (uid != NULL, NULL);
1906 
1907   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating toc select event for UID: %s&quot;, uid);
1908 
1909   structure = gst_structure_new_id (GST_QUARK (EVENT_TOC_SELECT),
1910       GST_QUARK (UID), G_TYPE_STRING, uid, NULL);
1911 
1912   return gst_event_new_custom (GST_EVENT_TOC_SELECT, structure);
1913 }
1914 
1915 /**
1916  * gst_event_parse_toc_select:
1917  * @event: a TOC select event.
1918  * @uid: (out) (transfer full) (allow-none): storage for the selection UID.
1919  *
1920  * Parse a TOC select @event and store the results in the given @uid location.
1921  */
1922 void
1923 gst_event_parse_toc_select (GstEvent * event, gchar ** uid)
1924 {
1925   const GstStructure *structure;
1926   const GValue *val;
1927 
1928   g_return_if_fail (event != NULL);
1929   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_TOC_SELECT);
1930 
1931   structure = gst_event_get_structure (event);
1932   val = gst_structure_id_get_value (structure, GST_QUARK (UID));
1933 
1934   if (uid != NULL)
1935     *uid = g_strdup (g_value_get_string (val));
1936 
1937 }
1938 
1939 /**
1940  * gst_event_new_protection:
1941  * @system_id: (transfer none): a string holding a UUID that uniquely
1942  * identifies a protection system.
1943  * @data: (transfer none): a #GstBuffer holding protection system specific
1944  * information. The reference count of the buffer will be incremented by one.
1945  * @origin: a string indicating where the protection
1946  * information carried in the event was extracted from. The allowed values
1947  * of this string will depend upon the protection scheme.
1948  *
1949  * Creates a new event containing information specific to a particular
1950  * protection system (uniquely identified by @system_id), by which that
1951  * protection system can acquire key(s) to decrypt a protected stream.
1952  *
1953  * In order for a decryption element to decrypt media
1954  * protected using a specific system, it first needs all the
1955  * protection system specific information necessary to acquire the decryption
1956  * key(s) for that stream. The functions defined here enable this information
1957  * to be passed in events from elements that extract it
1958  * (e.g., ISOBMFF demuxers, MPEG DASH demuxers) to protection decrypter
1959  * elements that use it.
1960  *
1961  * Events containing protection system specific information are created using
1962  * #gst_event_new_protection, and they can be parsed by downstream elements
1963  * using #gst_event_parse_protection.
1964  *
1965  * In Common Encryption, protection system specific information may be located
1966  * within ISOBMFF files, both in movie (moov) boxes and movie fragment (moof)
1967  * boxes; it may also be contained in ContentProtection elements within MPEG
1968  * DASH MPDs. The events created by #gst_event_new_protection contain data
1969  * identifying from which of these locations the encapsulated protection system
1970  * specific information originated. This origin information is required as
1971  * some protection systems use different encodings depending upon where the
1972  * information originates.
1973  *
1974  * The events returned by gst_event_new_protection() are implemented
1975  * in such a way as to ensure that the most recently-pushed protection info
1976  * event of a particular @origin and @system_id will
1977  * be stuck to the output pad of the sending element.
1978  *
1979  * Returns: a #GST_EVENT_PROTECTION event, if successful; %NULL
1980  * if unsuccessful.
1981  *
1982  * Since: 1.6
1983  */
1984 GstEvent *
1985 gst_event_new_protection (const gchar * system_id,
1986     GstBuffer * data, const gchar * origin)
1987 {
1988   gchar *event_name;
1989   GstEvent *event;
1990   GstStructure *s;
1991 
1992   g_return_val_if_fail (system_id != NULL, NULL);
1993   g_return_val_if_fail (data != NULL, NULL);
1994 
1995   event_name =
1996       g_strconcat (&quot;GstProtectionEvent&quot;, origin ? &quot;-&quot; : &quot;&quot;,
1997       origin ? origin : &quot;&quot;, &quot;-&quot;, system_id, NULL);
1998 
1999   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating protection event %s&quot;, event_name);
2000 
2001   s = gst_structure_new (event_name, &quot;data&quot;, GST_TYPE_BUFFER, data,
2002       &quot;system_id&quot;, G_TYPE_STRING, system_id, NULL);
2003   if (origin)
2004     gst_structure_set (s, &quot;origin&quot;, G_TYPE_STRING, origin, NULL);
2005   event = gst_event_new_custom (GST_EVENT_PROTECTION, s);
2006 
2007   g_free (event_name);
2008   return event;
2009 }
2010 
2011 /**
2012  * gst_event_parse_protection:
2013  * @event: a #GST_EVENT_PROTECTION event.
2014  * @system_id: (out) (allow-none) (transfer none): pointer to store the UUID
2015  * string uniquely identifying a content protection system.
2016  * @data: (out) (allow-none) (transfer none): pointer to store a #GstBuffer
2017  * holding protection system specific information.
2018  * @origin: (out) (allow-none) (transfer none): pointer to store a value that
2019  * indicates where the protection information carried by @event was extracted
2020  * from.
2021  *
2022  * Parses an event containing protection system specific information and stores
2023  * the results in @system_id, @data and @origin. The data stored in @system_id,
2024  * @origin and @data are valid until @event is released.
2025  *
2026  * Since: 1.6
2027  */
2028 void
2029 gst_event_parse_protection (GstEvent * event, const gchar ** system_id,
2030     GstBuffer ** data, const gchar ** origin)
2031 {
2032   const GstStructure *s;
2033 
2034   g_return_if_fail (event != NULL);
2035   g_return_if_fail (GST_IS_EVENT (event));
2036   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_PROTECTION);
2037 
2038   s = gst_event_get_structure (event);
2039 
2040   if (origin)
2041     *origin = gst_structure_get_string (s, &quot;origin&quot;);
2042 
2043   if (system_id)
2044     *system_id = gst_structure_get_string (s, &quot;system_id&quot;);
2045 
2046   if (data) {
2047     const GValue *value = gst_structure_get_value (s, &quot;data&quot;);
2048     *data = gst_value_get_buffer (value);
2049   }
2050 }
2051 
2052 /**
2053  * gst_event_new_segment_done:
2054  * @format: The format of the position being done
2055  * @position: The position of the segment being done
2056  *
2057  * Create a new segment-done event. This event is sent by elements that
2058  * finish playback of a segment as a result of a segment seek.
2059  *
2060  * Returns: (transfer full): a new #GstEvent
2061  */
2062 GstEvent *
2063 gst_event_new_segment_done (GstFormat format, gint64 position)
2064 {
2065   GstEvent *event;
2066   GstStructure *structure;
2067 
2068   GST_CAT_INFO (GST_CAT_EVENT, &quot;creating segment-done event&quot;);
2069 
2070   structure = gst_structure_new_id (GST_QUARK (EVENT_SEGMENT_DONE),
2071       GST_QUARK (FORMAT), GST_TYPE_FORMAT, format,
2072       GST_QUARK (POSITION), G_TYPE_INT64, position, NULL);
2073 
2074   event = gst_event_new_custom (GST_EVENT_SEGMENT_DONE, structure);
2075 
2076   return event;
2077 }
2078 
2079 /**
2080  * gst_event_parse_segment_done:
2081  * @event: A valid #GstEvent of type GST_EVENT_SEGMENT_DONE.
2082  * @format: (out) (allow-none): Result location for the format, or %NULL
2083  * @position: (out) (allow-none): Result location for the position, or %NULL
2084  *
2085  * Extracts the position and format from the segment done message.
2086  *
2087  */
2088 void
2089 gst_event_parse_segment_done (GstEvent * event, GstFormat * format,
2090     gint64 * position)
2091 {
2092   const GstStructure *structure;
2093   const GValue *val;
2094 
2095   g_return_if_fail (event != NULL);
2096   g_return_if_fail (GST_EVENT_TYPE (event) == GST_EVENT_SEGMENT_DONE);
2097 
2098   structure = gst_event_get_structure (event);
2099 
2100   val = gst_structure_id_get_value (structure, GST_QUARK (FORMAT));
2101   if (format != NULL)
2102     *format = g_value_get_enum (val);
2103 
2104   val = gst_structure_id_get_value (structure, GST_QUARK (POSITION));
2105   if (position != NULL)
2106     *position = g_value_get_int64 (val);
2107 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>