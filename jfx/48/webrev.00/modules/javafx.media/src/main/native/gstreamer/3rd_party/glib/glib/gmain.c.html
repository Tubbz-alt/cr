<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmain.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * gmain.c: Main loop abstraction, timeouts, and idle functions
   5  * Copyright 1998 Owen Taylor
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Lesser General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2.1 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Lesser General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Lesser General Public
  18  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  19  */
  20 
  21 /*
  22  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  23  * file for a list of people on the GLib Team.  See the ChangeLog
  24  * files for a list of changes.  These files are distributed with
  25  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  26  */
  27 
  28 /*
  29  * MT safe
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 #include &quot;glibconfig.h&quot;
  34 #include &quot;glib_trace.h&quot;
  35 
  36 /* Uncomment the next line (and the corresponding line in gpoll.c) to
  37  * enable debugging printouts if the environment variable
  38  * G_MAIN_POLL_DEBUG is set to some value.
  39  */
  40 /* #define G_MAIN_POLL_DEBUG */
  41 
  42 #ifdef _WIN32
  43 /* Always enable debugging printout on Windows, as it is more often
  44  * needed there...
  45  */
  46 #define G_MAIN_POLL_DEBUG
  47 #endif
  48 
  49 #ifdef G_OS_UNIX
  50 #include &quot;glib-unix.h&quot;
  51 #include &lt;pthread.h&gt;
  52 #ifdef HAVE_EVENTFD
  53 #include &lt;sys/eventfd.h&gt;
  54 #endif
  55 #endif
  56 
  57 #include &lt;signal.h&gt;
  58 #include &lt;sys/types.h&gt;
  59 #include &lt;time.h&gt;
  60 #include &lt;stdlib.h&gt;
  61 #ifdef HAVE_SYS_TIME_H
  62 #include &lt;sys/time.h&gt;
  63 #endif /* HAVE_SYS_TIME_H */
  64 #ifdef G_OS_UNIX
  65 #include &lt;unistd.h&gt;
  66 #endif /* G_OS_UNIX */
  67 #include &lt;errno.h&gt;
  68 #include &lt;string.h&gt;
  69 
  70 #ifdef G_OS_WIN32
  71 #define STRICT
  72 #include &lt;windows.h&gt;
  73 #endif /* G_OS_WIN32 */
  74 
  75 #ifdef HAVE_MACH_MACH_TIME_H
  76 #include &lt;mach/mach_time.h&gt;
  77 #endif
  78 
  79 #include &quot;glib_trace.h&quot;
  80 
  81 #include &quot;gmain.h&quot;
  82 
  83 #include &quot;garray.h&quot;
  84 #include &quot;giochannel.h&quot;
  85 #include &quot;ghash.h&quot;
  86 #include &quot;ghook.h&quot;
  87 #include &quot;gqueue.h&quot;
  88 #include &quot;gstrfuncs.h&quot;
  89 #include &quot;gtestutils.h&quot;
  90 #include &quot;gthreadprivate.h&quot;
  91 
  92 #ifdef G_OS_WIN32
  93 #include &quot;gwin32.h&quot;
  94 #endif
  95 
  96 #ifdef  G_MAIN_POLL_DEBUG
  97 #include &quot;gtimer.h&quot;
  98 #endif
  99 
 100 #include &quot;gwakeup.h&quot;
 101 #include &quot;gmain-internal.h&quot;
 102 #include &quot;glib-init.h&quot;
 103 #include &quot;glib-private.h&quot;
 104 
 105 /**
 106  * SECTION:main
 107  * @title: The Main Event Loop
 108  * @short_description: manages all available sources of events
 109  *
 110  * The main event loop manages all the available sources of events for
 111  * GLib and GTK+ applications. These events can come from any number of
 112  * different types of sources such as file descriptors (plain files,
 113  * pipes or sockets) and timeouts. New types of event sources can also
 114  * be added using g_source_attach().
 115  *
 116  * To allow multiple independent sets of sources to be handled in
 117  * different threads, each source is associated with a #GMainContext.
 118  * A GMainContext can only be running in a single thread, but
 119  * sources can be added to it and removed from it from other threads.
 120  *
 121  * Each event source is assigned a priority. The default priority,
 122  * #G_PRIORITY_DEFAULT, is 0. Values less than 0 denote higher priorities.
 123  * Values greater than 0 denote lower priorities. Events from high priority
 124  * sources are always processed before events from lower priority sources.
 125  *
 126  * Idle functions can also be added, and assigned a priority. These will
 127  * be run whenever no events with a higher priority are ready to be processed.
 128  *
 129  * The #GMainLoop data type represents a main event loop. A GMainLoop is
 130  * created with g_main_loop_new(). After adding the initial event sources,
 131  * g_main_loop_run() is called. This continuously checks for new events from
 132  * each of the event sources and dispatches them. Finally, the processing of
 133  * an event from one of the sources leads to a call to g_main_loop_quit() to
 134  * exit the main loop, and g_main_loop_run() returns.
 135  *
 136  * It is possible to create new instances of #GMainLoop recursively.
 137  * This is often used in GTK+ applications when showing modal dialog
 138  * boxes. Note that event sources are associated with a particular
 139  * #GMainContext, and will be checked and dispatched for all main
 140  * loops associated with that GMainContext.
 141  *
 142  * GTK+ contains wrappers of some of these functions, e.g. gtk_main(),
 143  * gtk_main_quit() and gtk_events_pending().
 144  *
 145  * ## Creating new source types
 146  *
 147  * One of the unusual features of the #GMainLoop functionality
 148  * is that new types of event source can be created and used in
 149  * addition to the builtin type of event source. A new event source
 150  * type is used for handling GDK events. A new source type is created
 151  * by &quot;deriving&quot; from the #GSource structure. The derived type of
 152  * source is represented by a structure that has the #GSource structure
 153  * as a first element, and other elements specific to the new source
 154  * type. To create an instance of the new source type, call
 155  * g_source_new() passing in the size of the derived structure and
 156  * a table of functions. These #GSourceFuncs determine the behavior of
 157  * the new source type.
 158  *
 159  * New source types basically interact with the main context
 160  * in two ways. Their prepare function in #GSourceFuncs can set a timeout
 161  * to determine the maximum amount of time that the main loop will sleep
 162  * before checking the source again. In addition, or as well, the source
 163  * can add file descriptors to the set that the main context checks using
 164  * g_source_add_poll().
 165  *
 166  * ## Customizing the main loop iteration
 167  *
 168  * Single iterations of a #GMainContext can be run with
 169  * g_main_context_iteration(). In some cases, more detailed control
 170  * of exactly how the details of the main loop work is desired, for
 171  * instance, when integrating the #GMainLoop with an external main loop.
 172  * In such cases, you can call the component functions of
 173  * g_main_context_iteration() directly. These functions are
 174  * g_main_context_prepare(), g_main_context_query(),
 175  * g_main_context_check() and g_main_context_dispatch().
 176  *
 177  * ## State of a Main Context # {#mainloop-states}
 178  *
 179  * The operation of these functions can best be seen in terms
 180  * of a state diagram, as shown in this image.
 181  *
 182  * ![](mainloop-states.gif)
 183  *
 184  * On UNIX, the GLib mainloop is incompatible with fork(). Any program
 185  * using the mainloop must either exec() or exit() from the child
 186  * without returning to the mainloop.
 187  *
 188  * ## Memory management of sources # {#mainloop-memory-management}
 189  *
 190  * There are two options for memory management of the user data passed to a
 191  * #GSource to be passed to its callback on invocation. This data is provided
 192  * in calls to g_timeout_add(), g_timeout_add_full(), g_idle_add(), etc. and
 193  * more generally, using g_source_set_callback(). This data is typically an
 194  * object which &#39;owns&#39; the timeout or idle callback, such as a widget or a
 195  * network protocol implementation. In many cases, it is an error for the
 196  * callback to be invoked after this owning object has been destroyed, as that
 197  * results in use of freed memory.
 198  *
 199  * The first, and preferred, option is to store the source ID returned by
 200  * functions such as g_timeout_add() or g_source_attach(), and explicitly
 201  * remove that source from the main context using g_source_remove() when the
 202  * owning object is finalized. This ensures that the callback can only be
 203  * invoked while the object is still alive.
 204  *
 205  * The second option is to hold a strong reference to the object in the
 206  * callback, and to release it in the callback&#39;s #GDestroyNotify. This ensures
 207  * that the object is kept alive until after the source is finalized, which is
 208  * guaranteed to be after it is invoked for the final time. The #GDestroyNotify
 209  * is another callback passed to the &#39;full&#39; variants of #GSource functions (for
 210  * example, g_timeout_add_full()). It is called when the source is finalized,
 211  * and is designed for releasing references like this.
 212  *
 213  * One important caveat of this second approach is that it will keep the object
 214  * alive indefinitely if the main loop is stopped before the #GSource is
 215  * invoked, which may be undesirable.
 216  */
 217 
 218 /* Types */
 219 
 220 typedef struct _GTimeoutSource GTimeoutSource;
 221 typedef struct _GChildWatchSource GChildWatchSource;
 222 typedef struct _GUnixSignalWatchSource GUnixSignalWatchSource;
 223 typedef struct _GPollRec GPollRec;
 224 typedef struct _GSourceCallback GSourceCallback;
 225 
 226 typedef enum
 227 {
 228   G_SOURCE_READY = 1 &lt;&lt; G_HOOK_FLAG_USER_SHIFT,
 229   G_SOURCE_CAN_RECURSE = 1 &lt;&lt; (G_HOOK_FLAG_USER_SHIFT + 1),
 230   G_SOURCE_BLOCKED = 1 &lt;&lt; (G_HOOK_FLAG_USER_SHIFT + 2)
 231 } GSourceFlags;
 232 
 233 typedef struct _GSourceList GSourceList;
 234 
 235 struct _GSourceList
 236 {
 237   GSource *head, *tail;
 238   gint priority;
 239 };
 240 
 241 typedef struct _GMainWaiter GMainWaiter;
 242 
 243 struct _GMainWaiter
 244 {
 245   GCond *cond;
 246   GMutex *mutex;
 247 };
 248 
 249 typedef struct _GMainDispatch GMainDispatch;
 250 
 251 struct _GMainDispatch
 252 {
 253   gint depth;
 254   GSource *source;
 255 };
 256 
 257 #ifdef G_MAIN_POLL_DEBUG
 258 gboolean _g_main_poll_debug = FALSE;
 259 #endif
 260 
 261 struct _GMainContext
 262 {
 263   /* The following lock is used for both the list of sources
 264    * and the list of poll records
 265    */
 266   GMutex mutex;
 267   GCond cond;
 268   GThread *owner;
 269   guint owner_count;
 270   GSList *waiters;
 271 
 272   volatile gint ref_count;
 273 
 274   GHashTable *sources;              /* guint -&gt; GSource */
 275 
 276   GPtrArray *pending_dispatches;
 277   gint timeout;     /* Timeout for current iteration */
 278 
 279   guint next_id;
 280   GList *source_lists;
 281   gint in_check_or_prepare;
 282 
 283   GPollRec *poll_records;
 284   guint n_poll_records;
 285   GPollFD *cached_poll_array;
 286   guint cached_poll_array_size;
 287 
 288   GWakeup *wakeup;
 289 
 290   GPollFD wake_up_rec;
 291 
 292 /* Flag indicating whether the set of fd&#39;s changed during a poll */
 293   gboolean poll_changed;
 294 
 295   GPollFunc poll_func;
 296 
 297   gint64   time;
 298   gboolean time_is_fresh;
 299 };
 300 
 301 struct _GSourceCallback
 302 {
 303   volatile gint ref_count;
 304   GSourceFunc func;
 305   gpointer    data;
 306   GDestroyNotify notify;
 307 };
 308 
 309 struct _GMainLoop
 310 {
 311   GMainContext *context;
 312   gboolean is_running; /* (atomic) */
 313   volatile gint ref_count;
 314 };
 315 
 316 struct _GTimeoutSource
 317 {
 318   GSource     source;
 319   /* Measured in seconds if &#39;seconds&#39; is TRUE, or milliseconds otherwise. */
 320   guint       interval;
 321   gboolean    seconds;
 322 };
 323 
 324 struct _GChildWatchSource
 325 {
 326   GSource     source;
 327   GPid        pid;
 328   gint        child_status;
 329 #ifdef G_OS_WIN32
 330   GPollFD     poll;
 331 #else /* G_OS_WIN32 */
 332   gboolean    child_exited; /* (atomic) */
 333 #endif /* G_OS_WIN32 */
 334 };
 335 
 336 struct _GUnixSignalWatchSource
 337 {
 338   GSource     source;
 339   int         signum;
 340   gboolean    pending; /* (atomic) */
 341 };
 342 
 343 struct _GPollRec
 344 {
 345   GPollFD *fd;
 346   GPollRec *prev;
 347   GPollRec *next;
 348   gint priority;
 349 };
 350 
 351 struct _GSourcePrivate
 352 {
 353   GSList *child_sources;
 354   GSource *parent_source;
 355 
 356   gint64 ready_time;
 357 
 358   /* This is currently only used on UNIX, but we always declare it (and
 359    * let it remain empty on Windows) to avoid #ifdef all over the place.
 360    */
 361   GSList *fds;
 362 };
 363 
 364 typedef struct _GSourceIter
 365 {
 366   GMainContext *context;
 367   gboolean may_modify;
 368   GList *current_list;
 369   GSource *source;
 370 } GSourceIter;
 371 
 372 #define LOCK_CONTEXT(context) g_mutex_lock (&amp;context-&gt;mutex)
 373 #define UNLOCK_CONTEXT(context) g_mutex_unlock (&amp;context-&gt;mutex)
 374 #define G_THREAD_SELF g_thread_self ()
 375 
 376 #define SOURCE_DESTROYED(source) (((source)-&gt;flags &amp; G_HOOK_FLAG_ACTIVE) == 0)
 377 #define SOURCE_BLOCKED(source) (((source)-&gt;flags &amp; G_SOURCE_BLOCKED) != 0)
 378 
 379 /* Forward declarations */
 380 
 381 static void g_source_unref_internal             (GSource      *source,
 382              GMainContext *context,
 383              gboolean      have_lock);
 384 static void g_source_destroy_internal           (GSource      *source,
 385              GMainContext *context,
 386              gboolean      have_lock);
 387 static void g_source_set_priority_unlocked      (GSource      *source,
 388              GMainContext *context,
 389              gint          priority);
 390 static void g_child_source_remove_internal      (GSource      *child_source,
 391                                                  GMainContext *context);
 392 
 393 static void g_main_context_poll                 (GMainContext *context,
 394              gint          timeout,
 395              gint          priority,
 396              GPollFD      *fds,
 397              gint          n_fds);
 398 static void g_main_context_add_poll_unlocked    (GMainContext *context,
 399              gint          priority,
 400              GPollFD      *fd);
 401 static void g_main_context_remove_poll_unlocked (GMainContext *context,
 402              GPollFD      *fd);
 403 
 404 static void     g_source_iter_init  (GSourceIter   *iter,
 405              GMainContext  *context,
 406              gboolean       may_modify);
 407 static gboolean g_source_iter_next  (GSourceIter   *iter,
 408              GSource      **source);
 409 static void     g_source_iter_clear (GSourceIter   *iter);
 410 
 411 static gboolean g_timeout_dispatch (GSource     *source,
 412             GSourceFunc  callback,
 413             gpointer     user_data);
 414 static gboolean g_child_watch_prepare  (GSource     *source,
 415                 gint        *timeout);
 416 static gboolean g_child_watch_check    (GSource     *source);
 417 static gboolean g_child_watch_dispatch (GSource     *source,
 418           GSourceFunc  callback,
 419           gpointer     user_data);
 420 static void     g_child_watch_finalize (GSource     *source);
 421 #ifdef G_OS_UNIX
 422 static void g_unix_signal_handler (int signum);
 423 static gboolean g_unix_signal_watch_prepare  (GSource     *source,
 424                 gint        *timeout);
 425 static gboolean g_unix_signal_watch_check    (GSource     *source);
 426 static gboolean g_unix_signal_watch_dispatch (GSource     *source,
 427                 GSourceFunc  callback,
 428                 gpointer     user_data);
 429 static void     g_unix_signal_watch_finalize  (GSource     *source);
 430 #endif
 431 static gboolean g_idle_prepare     (GSource     *source,
 432             gint        *timeout);
 433 static gboolean g_idle_check       (GSource     *source);
 434 static gboolean g_idle_dispatch    (GSource     *source,
 435             GSourceFunc  callback,
 436             gpointer     user_data);
 437 
 438 static void block_source (GSource *source);
 439 
 440 static GMainContext *glib_worker_context;
 441 
 442 G_LOCK_DEFINE_STATIC (main_loop);
 443 static GMainContext *default_main_context;
 444 
 445 #ifndef G_OS_WIN32
 446 
 447 
 448 /* UNIX signals work by marking one of these variables then waking the
 449  * worker context to check on them and dispatch accordingly.
 450  */
 451 #ifdef HAVE_SIG_ATOMIC_T
 452 static volatile sig_atomic_t unix_signal_pending[NSIG];
 453 static volatile sig_atomic_t any_unix_signal_pending;
 454 #else
 455 static volatile int unix_signal_pending[NSIG];
 456 static volatile int any_unix_signal_pending;
 457 #endif
 458 
 459 /* Guards all the data below */
 460 G_LOCK_DEFINE_STATIC (unix_signal_lock);
 461 static guint unix_signal_refcount[NSIG];
 462 static GSList *unix_signal_watches;
 463 static GSList *unix_child_watches;
 464 
 465 GSourceFuncs g_unix_signal_funcs =
 466 {
 467   g_unix_signal_watch_prepare,
 468   g_unix_signal_watch_check,
 469   g_unix_signal_watch_dispatch,
 470   g_unix_signal_watch_finalize,
 471   NULL, NULL
 472 };
 473 #endif /* !G_OS_WIN32 */
 474 G_LOCK_DEFINE_STATIC (main_context_list);
 475 static GSList *main_context_list = NULL;
 476 
 477 GSourceFuncs g_timeout_funcs =
 478 {
 479   NULL, /* prepare */
 480   NULL, /* check */
 481   g_timeout_dispatch,
 482   NULL, NULL, NULL
 483 };
 484 
 485 GSourceFuncs g_child_watch_funcs =
 486 {
 487   g_child_watch_prepare,
 488   g_child_watch_check,
 489   g_child_watch_dispatch,
 490   g_child_watch_finalize,
 491   NULL, NULL
 492 };
 493 
 494 GSourceFuncs g_idle_funcs =
 495 {
 496   g_idle_prepare,
 497   g_idle_check,
 498   g_idle_dispatch,
 499   NULL, NULL, NULL
 500 };
 501 
 502 /**
 503  * g_main_context_ref:
 504  * @context: a #GMainContext
 505  *
 506  * Increases the reference count on a #GMainContext object by one.
 507  *
 508  * Returns: the @context that was passed in (since 2.6)
 509  **/
 510 GMainContext *
 511 g_main_context_ref (GMainContext *context)
 512 {
 513   g_return_val_if_fail (context != NULL, NULL);
 514   g_return_val_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0, NULL);
 515 
 516   g_atomic_int_inc (&amp;context-&gt;ref_count);
 517 
 518   return context;
 519 }
 520 
 521 static inline void
 522 poll_rec_list_free (GMainContext *context,
 523         GPollRec     *list)
 524 {
 525   g_slice_free_chain (GPollRec, list, next);
 526 }
 527 
 528 /**
 529  * g_main_context_unref:
 530  * @context: a #GMainContext
 531  *
 532  * Decreases the reference count on a #GMainContext object by one. If
 533  * the result is zero, free the context and free all associated memory.
 534  **/
 535 void
 536 g_main_context_unref (GMainContext *context)
 537 {
 538   GSourceIter iter;
 539   GSource *source;
 540   GList *sl_iter;
 541   GSourceList *list;
 542   guint i;
 543 
 544   g_return_if_fail (context != NULL);
 545   g_return_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0);
 546 
 547   if (!g_atomic_int_dec_and_test (&amp;context-&gt;ref_count))
 548     return;
 549 
 550   G_LOCK (main_context_list);
 551   main_context_list = g_slist_remove (main_context_list, context);
 552   G_UNLOCK (main_context_list);
 553 
 554   /* Free pending dispatches */
 555   for (i = 0; i &lt; context-&gt;pending_dispatches-&gt;len; i++)
 556     g_source_unref_internal (context-&gt;pending_dispatches-&gt;pdata[i], context, FALSE);
 557 
 558   /* g_source_iter_next() assumes the context is locked. */
 559   LOCK_CONTEXT (context);
 560   g_source_iter_init (&amp;iter, context, TRUE);
 561   while (g_source_iter_next (&amp;iter, &amp;source))
 562     {
 563       source-&gt;context = NULL;
 564       g_source_destroy_internal (source, context, TRUE);
 565     }
 566   UNLOCK_CONTEXT (context);
 567 
 568   for (sl_iter = context-&gt;source_lists; sl_iter; sl_iter = sl_iter-&gt;next)
 569     {
 570       list = sl_iter-&gt;data;
 571       g_slice_free (GSourceList, list);
 572     }
 573   g_list_free (context-&gt;source_lists);
 574 
 575   g_hash_table_destroy (context-&gt;sources);
 576 
 577   g_mutex_clear (&amp;context-&gt;mutex);
 578 
 579   g_ptr_array_free (context-&gt;pending_dispatches, TRUE);
 580   g_free (context-&gt;cached_poll_array);
 581 
 582   poll_rec_list_free (context, context-&gt;poll_records);
 583 
 584   g_wakeup_free (context-&gt;wakeup);
 585   g_cond_clear (&amp;context-&gt;cond);
 586 
 587   g_free (context);
 588 }
 589 
 590 /* Helper function used by mainloop/overflow test.
 591  */
 592 GMainContext *
 593 g_main_context_new_with_next_id (guint next_id)
 594 {
 595   GMainContext *ret = g_main_context_new ();
 596 
 597   ret-&gt;next_id = next_id;
 598 
 599   return ret;
 600 }
 601 
 602 /**
 603  * g_main_context_new:
 604  *
 605  * Creates a new #GMainContext structure.
 606  *
 607  * Returns: the new #GMainContext
 608  **/
 609 GMainContext *
 610 g_main_context_new (void)
 611 {
 612   static gsize initialised;
 613   GMainContext *context;
 614 
 615   if (g_once_init_enter (&amp;initialised))
 616     {
 617 #ifdef G_MAIN_POLL_DEBUG
 618       if (getenv (&quot;G_MAIN_POLL_DEBUG&quot;) != NULL)
 619         _g_main_poll_debug = TRUE;
 620 #endif
 621 
 622       g_once_init_leave (&amp;initialised, TRUE);
 623     }
 624 
 625   context = g_new0 (GMainContext, 1);
 626 
 627   TRACE (GLIB_MAIN_CONTEXT_NEW (context));
 628 
 629   g_mutex_init (&amp;context-&gt;mutex);
 630   g_cond_init (&amp;context-&gt;cond);
 631 
 632   context-&gt;sources = g_hash_table_new (NULL, NULL);
 633   context-&gt;owner = NULL;
 634   context-&gt;waiters = NULL;
 635 
 636   context-&gt;ref_count = 1;
 637 
 638   context-&gt;next_id = 1;
 639 
 640   context-&gt;source_lists = NULL;
 641 
 642   context-&gt;poll_func = g_poll;
 643 
 644   context-&gt;cached_poll_array = NULL;
 645   context-&gt;cached_poll_array_size = 0;
 646 
 647   context-&gt;pending_dispatches = g_ptr_array_new ();
 648 
 649   context-&gt;time_is_fresh = FALSE;
 650 
 651   context-&gt;wakeup = g_wakeup_new ();
 652   g_wakeup_get_pollfd (context-&gt;wakeup, &amp;context-&gt;wake_up_rec);
 653   g_main_context_add_poll_unlocked (context, 0, &amp;context-&gt;wake_up_rec);
 654 
 655   G_LOCK (main_context_list);
 656   main_context_list = g_slist_append (main_context_list, context);
 657 
 658 #ifdef G_MAIN_POLL_DEBUG
 659   if (_g_main_poll_debug)
 660     g_print (&quot;created context=%p\n&quot;, context);
 661 #endif
 662 
 663   G_UNLOCK (main_context_list);
 664 
 665   return context;
 666 }
 667 
 668 /**
 669  * g_main_context_default:
 670  *
 671  * Returns the global default main context. This is the main context
 672  * used for main loop functions when a main loop is not explicitly
 673  * specified, and corresponds to the &quot;main&quot; main loop. See also
 674  * g_main_context_get_thread_default().
 675  *
 676  * Returns: (transfer none): the global default main context.
 677  **/
 678 GMainContext *
 679 g_main_context_default (void)
 680 {
 681   /* Slow, but safe */
 682 
 683   G_LOCK (main_loop);
 684 
 685   if (!default_main_context)
 686     {
 687       default_main_context = g_main_context_new ();
 688 
 689       TRACE (GLIB_MAIN_CONTEXT_DEFAULT (default_main_context));
 690 
 691 #ifdef G_MAIN_POLL_DEBUG
 692       if (_g_main_poll_debug)
 693   g_print (&quot;default context=%p\n&quot;, default_main_context);
 694 #endif
 695     }
 696 
 697   G_UNLOCK (main_loop);
 698 
 699   return default_main_context;
 700 }
 701 
 702 static void
 703 free_context (gpointer data)
 704 {
 705   GMainContext *context = data;
 706 
 707   TRACE (GLIB_MAIN_CONTEXT_FREE (context));
 708 
 709   g_main_context_release (context);
 710   if (context)
 711     g_main_context_unref (context);
 712 }
 713 
 714 static void
 715 free_context_stack (gpointer data)
 716 {
 717   g_queue_free_full((GQueue *) data, (GDestroyNotify) free_context);
 718 }
 719 
 720 static GPrivate thread_context_stack = G_PRIVATE_INIT (free_context_stack);
 721 
 722 /**
 723  * g_main_context_push_thread_default:
 724  * @context: (nullable): a #GMainContext, or %NULL for the global default context
 725  *
 726  * Acquires @context and sets it as the thread-default context for the
 727  * current thread. This will cause certain asynchronous operations
 728  * (such as most [gio][gio]-based I/O) which are
 729  * started in this thread to run under @context and deliver their
 730  * results to its main loop, rather than running under the global
 731  * default context in the main thread. Note that calling this function
 732  * changes the context returned by g_main_context_get_thread_default(),
 733  * not the one returned by g_main_context_default(), so it does not affect
 734  * the context used by functions like g_idle_add().
 735  *
 736  * Normally you would call this function shortly after creating a new
 737  * thread, passing it a #GMainContext which will be run by a
 738  * #GMainLoop in that thread, to set a new default context for all
 739  * async operations in that thread. In this case you may not need to
 740  * ever call g_main_context_pop_thread_default(), assuming you want the
 741  * new #GMainContext to be the default for the whole lifecycle of the
 742  * thread.
 743  *
 744  * If you don&#39;t have control over how the new thread was created (e.g.
 745  * in the new thread isn&#39;t newly created, or if the thread life
 746  * cycle is managed by a #GThreadPool), it is always suggested to wrap
 747  * the logic that needs to use the new #GMainContext inside a
 748  * g_main_context_push_thread_default() / g_main_context_pop_thread_default()
 749  * pair, otherwise threads that are re-used will end up never explicitly
 750  * releasing the #GMainContext reference they hold.
 751  *
 752  * In some cases you may want to schedule a single operation in a
 753  * non-default context, or temporarily use a non-default context in
 754  * the main thread. In that case, you can wrap the call to the
 755  * asynchronous operation inside a
 756  * g_main_context_push_thread_default() /
 757  * g_main_context_pop_thread_default() pair, but it is up to you to
 758  * ensure that no other asynchronous operations accidentally get
 759  * started while the non-default context is active.
 760  *
 761  * Beware that libraries that predate this function may not correctly
 762  * handle being used from a thread with a thread-default context. Eg,
 763  * see g_file_supports_thread_contexts().
 764  *
 765  * Since: 2.22
 766  **/
 767 void
 768 g_main_context_push_thread_default (GMainContext *context)
 769 {
 770   GQueue *stack;
 771   gboolean acquired_context;
 772 
 773   acquired_context = g_main_context_acquire (context);
 774   g_return_if_fail (acquired_context);
 775 
 776   if (context == g_main_context_default ())
 777     context = NULL;
 778   else if (context)
 779     g_main_context_ref (context);
 780 
 781   stack = g_private_get (&amp;thread_context_stack);
 782   if (!stack)
 783     {
 784       stack = g_queue_new ();
 785       g_private_set (&amp;thread_context_stack, stack);
 786     }
 787 
 788   g_queue_push_head (stack, context);
 789 
 790   TRACE (GLIB_MAIN_CONTEXT_PUSH_THREAD_DEFAULT (context));
 791 }
 792 
 793 /**
 794  * g_main_context_pop_thread_default:
 795  * @context: (nullable): a #GMainContext object, or %NULL
 796  *
 797  * Pops @context off the thread-default context stack (verifying that
 798  * it was on the top of the stack).
 799  *
 800  * Since: 2.22
 801  **/
 802 void
 803 g_main_context_pop_thread_default (GMainContext *context)
 804 {
 805   GQueue *stack;
 806 
 807   if (context == g_main_context_default ())
 808     context = NULL;
 809 
 810   stack = g_private_get (&amp;thread_context_stack);
 811 
 812   g_return_if_fail (stack != NULL);
 813   g_return_if_fail (g_queue_peek_head (stack) == context);
 814 
 815   TRACE (GLIB_MAIN_CONTEXT_POP_THREAD_DEFAULT (context));
 816 
 817   g_queue_pop_head (stack);
 818 
 819   g_main_context_release (context);
 820   if (context)
 821     g_main_context_unref (context);
 822 }
 823 
 824 /**
 825  * g_main_context_get_thread_default:
 826  *
 827  * Gets the thread-default #GMainContext for this thread. Asynchronous
 828  * operations that want to be able to be run in contexts other than
 829  * the default one should call this method or
 830  * g_main_context_ref_thread_default() to get a #GMainContext to add
 831  * their #GSources to. (Note that even in single-threaded
 832  * programs applications may sometimes want to temporarily push a
 833  * non-default context, so it is not safe to assume that this will
 834  * always return %NULL if you are running in the default thread.)
 835  *
 836  * If you need to hold a reference on the context, use
 837  * g_main_context_ref_thread_default() instead.
 838  *
 839  * Returns: (transfer none): the thread-default #GMainContext, or
 840  * %NULL if the thread-default context is the global default context.
 841  *
 842  * Since: 2.22
 843  **/
 844 GMainContext *
 845 g_main_context_get_thread_default (void)
 846 {
 847   GQueue *stack;
 848 
 849   stack = g_private_get (&amp;thread_context_stack);
 850   if (stack)
 851     return g_queue_peek_head (stack);
 852   else
 853     return NULL;
 854 }
 855 
 856 /**
 857  * g_main_context_ref_thread_default:
 858  *
 859  * Gets the thread-default #GMainContext for this thread, as with
 860  * g_main_context_get_thread_default(), but also adds a reference to
 861  * it with g_main_context_ref(). In addition, unlike
 862  * g_main_context_get_thread_default(), if the thread-default context
 863  * is the global default context, this will return that #GMainContext
 864  * (with a ref added to it) rather than returning %NULL.
 865  *
 866  * Returns: (transfer full): the thread-default #GMainContext. Unref
 867  *     with g_main_context_unref() when you are done with it.
 868  *
 869  * Since: 2.32
 870  */
 871 GMainContext *
 872 g_main_context_ref_thread_default (void)
 873 {
 874   GMainContext *context;
 875 
 876   context = g_main_context_get_thread_default ();
 877   if (!context)
 878     context = g_main_context_default ();
 879   return g_main_context_ref (context);
 880 }
 881 
 882 /* Hooks for adding to the main loop */
 883 
 884 /**
 885  * g_source_new:
 886  * @source_funcs: structure containing functions that implement
 887  *                the sources behavior.
 888  * @struct_size: size of the #GSource structure to create.
 889  *
 890  * Creates a new #GSource structure. The size is specified to
 891  * allow creating structures derived from #GSource that contain
 892  * additional data. The size passed in must be at least
 893  * `sizeof (GSource)`.
 894  *
 895  * The source will not initially be associated with any #GMainContext
 896  * and must be added to one with g_source_attach() before it will be
 897  * executed.
 898  *
 899  * Returns: the newly-created #GSource.
 900  **/
 901 GSource *
 902 g_source_new (GSourceFuncs *source_funcs,
 903         guint         struct_size)
 904 {
 905   GSource *source;
 906 
 907   g_return_val_if_fail (source_funcs != NULL, NULL);
 908   g_return_val_if_fail (struct_size &gt;= sizeof (GSource), NULL);
 909 
 910   source = (GSource*) g_malloc0 (struct_size);
 911 #ifdef GSTREAMER_LITE
 912   if (source == NULL)
 913     return NULL;
 914 #endif // GSTREAMER_LITE
 915   source-&gt;priv = g_slice_new0 (GSourcePrivate);
 916 #ifdef GSTREAMER_LITE
 917   if (source-&gt;priv == NULL)
 918   {
 919     g_free(source);
 920     return NULL;
 921   }
 922 #endif // GSTREAMER_LITE
 923   source-&gt;source_funcs = source_funcs;
 924   source-&gt;ref_count = 1;
 925 
 926   source-&gt;priority = G_PRIORITY_DEFAULT;
 927 
 928   source-&gt;flags = G_HOOK_FLAG_ACTIVE;
 929 
 930   source-&gt;priv-&gt;ready_time = -1;
 931 
 932   /* NULL/0 initialization for all other fields */
 933 
 934   TRACE (GLIB_SOURCE_NEW (source, source_funcs-&gt;prepare, source_funcs-&gt;check,
 935                           source_funcs-&gt;dispatch, source_funcs-&gt;finalize,
 936                           struct_size));
 937 
 938   return source;
 939 }
 940 
 941 /* Holds context&#39;s lock */
 942 static void
 943 g_source_iter_init (GSourceIter  *iter,
 944         GMainContext *context,
 945         gboolean      may_modify)
 946 {
 947   iter-&gt;context = context;
 948   iter-&gt;current_list = NULL;
 949   iter-&gt;source = NULL;
 950   iter-&gt;may_modify = may_modify;
 951 }
 952 
 953 /* Holds context&#39;s lock */
 954 static gboolean
 955 g_source_iter_next (GSourceIter *iter, GSource **source)
 956 {
 957   GSource *next_source;
 958 
 959   if (iter-&gt;source)
 960     next_source = iter-&gt;source-&gt;next;
 961   else
 962     next_source = NULL;
 963 
 964   if (!next_source)
 965     {
 966       if (iter-&gt;current_list)
 967   iter-&gt;current_list = iter-&gt;current_list-&gt;next;
 968       else
 969   iter-&gt;current_list = iter-&gt;context-&gt;source_lists;
 970 
 971       if (iter-&gt;current_list)
 972   {
 973     GSourceList *source_list = iter-&gt;current_list-&gt;data;
 974 
 975     next_source = source_list-&gt;head;
 976   }
 977     }
 978 
 979   /* Note: unreffing iter-&gt;source could potentially cause its
 980    * GSourceList to be removed from source_lists (if iter-&gt;source is
 981    * the only source in its list, and it is destroyed), so we have to
 982    * keep it reffed until after we advance iter-&gt;current_list, above.
 983    */
 984 
 985   if (iter-&gt;source &amp;&amp; iter-&gt;may_modify)
 986     g_source_unref_internal (iter-&gt;source, iter-&gt;context, TRUE);
 987   iter-&gt;source = next_source;
 988   if (iter-&gt;source &amp;&amp; iter-&gt;may_modify)
 989     g_source_ref (iter-&gt;source);
 990 
 991   *source = iter-&gt;source;
 992   return *source != NULL;
 993 }
 994 
 995 /* Holds context&#39;s lock. Only necessary to call if you broke out of
 996  * the g_source_iter_next() loop early.
 997  */
 998 static void
 999 g_source_iter_clear (GSourceIter *iter)
1000 {
1001   if (iter-&gt;source &amp;&amp; iter-&gt;may_modify)
1002     {
1003       g_source_unref_internal (iter-&gt;source, iter-&gt;context, TRUE);
1004       iter-&gt;source = NULL;
1005     }
1006 }
1007 
1008 /* Holds context&#39;s lock
1009  */
1010 static GSourceList *
1011 find_source_list_for_priority (GMainContext *context,
1012              gint          priority,
1013              gboolean      create)
1014 {
1015   GList *iter, *last;
1016   GSourceList *source_list;
1017 
1018   last = NULL;
1019   for (iter = context-&gt;source_lists; iter != NULL; last = iter, iter = iter-&gt;next)
1020     {
1021       source_list = iter-&gt;data;
1022 
1023       if (source_list-&gt;priority == priority)
1024   return source_list;
1025 
1026       if (source_list-&gt;priority &gt; priority)
1027   {
1028     if (!create)
1029       return NULL;
1030 
1031     source_list = g_slice_new0 (GSourceList);
1032     source_list-&gt;priority = priority;
1033     context-&gt;source_lists = g_list_insert_before (context-&gt;source_lists,
1034               iter,
1035               source_list);
1036     return source_list;
1037   }
1038     }
1039 
1040   if (!create)
1041     return NULL;
1042 
1043   source_list = g_slice_new0 (GSourceList);
1044   source_list-&gt;priority = priority;
1045 
1046   if (!last)
1047     context-&gt;source_lists = g_list_append (NULL, source_list);
1048   else
1049     {
1050       /* This just appends source_list to the end of
1051        * context-&gt;source_lists without having to walk the list again.
1052        */
1053       last = g_list_append (last, source_list);
1054     }
1055   return source_list;
1056 }
1057 
1058 /* Holds context&#39;s lock
1059  */
1060 static void
1061 source_add_to_context (GSource      *source,
1062            GMainContext *context)
1063 {
1064   GSourceList *source_list;
1065   GSource *prev, *next;
1066 
1067   source_list = find_source_list_for_priority (context, source-&gt;priority, TRUE);
1068 
1069   if (source-&gt;priv-&gt;parent_source)
1070     {
1071       g_assert (source_list-&gt;head != NULL);
1072 
1073       /* Put the source immediately before its parent */
1074       prev = source-&gt;priv-&gt;parent_source-&gt;prev;
1075       next = source-&gt;priv-&gt;parent_source;
1076     }
1077   else
1078     {
1079       prev = source_list-&gt;tail;
1080       next = NULL;
1081     }
1082 
1083   source-&gt;next = next;
1084   if (next)
1085     next-&gt;prev = source;
1086   else
1087     source_list-&gt;tail = source;
1088 
1089   source-&gt;prev = prev;
1090   if (prev)
1091     prev-&gt;next = source;
1092   else
1093     source_list-&gt;head = source;
1094 }
1095 
1096 /* Holds context&#39;s lock
1097  */
1098 static void
1099 source_remove_from_context (GSource      *source,
1100           GMainContext *context)
1101 {
1102   GSourceList *source_list;
1103 
1104   source_list = find_source_list_for_priority (context, source-&gt;priority, FALSE);
1105   g_return_if_fail (source_list != NULL);
1106 #ifdef GSTREAMER_LITE
1107   if (source_list == NULL)
1108     return;
1109 #endif // GSTREAMER_LITE
1110 
1111   if (source-&gt;prev)
1112     source-&gt;prev-&gt;next = source-&gt;next;
1113   else
1114     source_list-&gt;head = source-&gt;next;
1115 
1116   if (source-&gt;next)
1117     source-&gt;next-&gt;prev = source-&gt;prev;
1118   else
1119     source_list-&gt;tail = source-&gt;prev;
1120 
1121   source-&gt;prev = NULL;
1122   source-&gt;next = NULL;
1123 
1124   if (source_list-&gt;head == NULL)
1125     {
1126       context-&gt;source_lists = g_list_remove (context-&gt;source_lists, source_list);
1127       g_slice_free (GSourceList, source_list);
1128     }
1129 }
1130 
1131 static guint
1132 g_source_attach_unlocked (GSource      *source,
1133                           GMainContext *context,
1134                           gboolean      do_wakeup)
1135 {
1136   GSList *tmp_list;
1137   guint id;
1138 
1139   /* The counter may have wrapped, so we must ensure that we do not
1140    * reuse the source id of an existing source.
1141    */
1142   do
1143     id = context-&gt;next_id++;
1144   while (id == 0 || g_hash_table_contains (context-&gt;sources, GUINT_TO_POINTER (id)));
1145 
1146   source-&gt;context = context;
1147   source-&gt;source_id = id;
1148   g_source_ref (source);
1149 
1150   g_hash_table_insert (context-&gt;sources, GUINT_TO_POINTER (id), source);
1151 
1152   source_add_to_context (source, context);
1153 
1154   if (!SOURCE_BLOCKED (source))
1155     {
1156       tmp_list = source-&gt;poll_fds;
1157       while (tmp_list)
1158         {
1159           g_main_context_add_poll_unlocked (context, source-&gt;priority, tmp_list-&gt;data);
1160           tmp_list = tmp_list-&gt;next;
1161         }
1162 
1163       for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
1164         g_main_context_add_poll_unlocked (context, source-&gt;priority, tmp_list-&gt;data);
1165     }
1166 
1167   tmp_list = source-&gt;priv-&gt;child_sources;
1168   while (tmp_list)
1169     {
1170       g_source_attach_unlocked (tmp_list-&gt;data, context, FALSE);
1171       tmp_list = tmp_list-&gt;next;
1172     }
1173 
1174   /* If another thread has acquired the context, wake it up since it
1175    * might be in poll() right now.
1176    */
1177   if (do_wakeup &amp;&amp; context-&gt;owner &amp;&amp; context-&gt;owner != G_THREAD_SELF)
1178     g_wakeup_signal (context-&gt;wakeup);
1179 
1180   return source-&gt;source_id;
1181 }
1182 
1183 /**
1184  * g_source_attach:
1185  * @source: a #GSource
1186  * @context: (nullable): a #GMainContext (if %NULL, the default context will be used)
1187  *
1188  * Adds a #GSource to a @context so that it will be executed within
1189  * that context. Remove it by calling g_source_destroy().
1190  *
1191  * Returns: the ID (greater than 0) for the source within the
1192  *   #GMainContext.
1193  **/
1194 guint
1195 g_source_attach (GSource      *source,
1196      GMainContext *context)
1197 {
1198   guint result = 0;
1199 
1200 #ifdef GSTREAMER_LITE
1201   if (source == NULL) {
1202     return 0;
1203   }
1204 #endif // GSTREAMER_LITE
1205 
1206   g_return_val_if_fail (source-&gt;context == NULL, 0);
1207   g_return_val_if_fail (!SOURCE_DESTROYED (source), 0);
1208 
1209   if (!context)
1210     context = g_main_context_default ();
1211 
1212   LOCK_CONTEXT (context);
1213 
1214   result = g_source_attach_unlocked (source, context, TRUE);
1215 
1216   TRACE (GLIB_MAIN_SOURCE_ATTACH (g_source_get_name (source), source, context,
1217                                   result));
1218 
1219   UNLOCK_CONTEXT (context);
1220 
1221   return result;
1222 }
1223 
1224 static void
1225 g_source_destroy_internal (GSource      *source,
1226          GMainContext *context,
1227          gboolean      have_lock)
1228 {
1229   TRACE (GLIB_MAIN_SOURCE_DESTROY (g_source_get_name (source), source,
1230                                    context));
1231 
1232   if (!have_lock)
1233     LOCK_CONTEXT (context);
1234 
1235   if (!SOURCE_DESTROYED (source))
1236     {
1237       GSList *tmp_list;
1238       gpointer old_cb_data;
1239       GSourceCallbackFuncs *old_cb_funcs;
1240 
1241       source-&gt;flags &amp;= ~G_HOOK_FLAG_ACTIVE;
1242 
1243       old_cb_data = source-&gt;callback_data;
1244       old_cb_funcs = source-&gt;callback_funcs;
1245 
1246       source-&gt;callback_data = NULL;
1247       source-&gt;callback_funcs = NULL;
1248 
1249       if (old_cb_funcs)
1250   {
1251     UNLOCK_CONTEXT (context);
1252     old_cb_funcs-&gt;unref (old_cb_data);
1253     LOCK_CONTEXT (context);
1254   }
1255 
1256       if (!SOURCE_BLOCKED (source))
1257   {
1258     tmp_list = source-&gt;poll_fds;
1259     while (tmp_list)
1260       {
1261         g_main_context_remove_poll_unlocked (context, tmp_list-&gt;data);
1262         tmp_list = tmp_list-&gt;next;
1263       }
1264 
1265           for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
1266             g_main_context_remove_poll_unlocked (context, tmp_list-&gt;data);
1267   }
1268 
1269       while (source-&gt;priv-&gt;child_sources)
1270         g_child_source_remove_internal (source-&gt;priv-&gt;child_sources-&gt;data, context);
1271 
1272       if (source-&gt;priv-&gt;parent_source)
1273         g_child_source_remove_internal (source, context);
1274 
1275       g_source_unref_internal (source, context, TRUE);
1276     }
1277 
1278   if (!have_lock)
1279     UNLOCK_CONTEXT (context);
1280 }
1281 
1282 /**
1283  * g_source_destroy:
1284  * @source: a #GSource
1285  *
1286  * Removes a source from its #GMainContext, if any, and mark it as
1287  * destroyed.  The source cannot be subsequently added to another
1288  * context. It is safe to call this on sources which have already been
1289  * removed from their context.
1290  *
1291  * This does not unref the #GSource: if you still hold a reference, use
1292  * g_source_unref() to drop it.
1293  */
1294 void
1295 g_source_destroy (GSource *source)
1296 {
1297   GMainContext *context;
1298 
1299   g_return_if_fail (source != NULL);
1300 
1301   context = source-&gt;context;
1302 
1303   if (context)
1304     g_source_destroy_internal (source, context, FALSE);
1305   else
1306     source-&gt;flags &amp;= ~G_HOOK_FLAG_ACTIVE;
1307 }
1308 
1309 /**
1310  * g_source_get_id:
1311  * @source: a #GSource
1312  *
1313  * Returns the numeric ID for a particular source. The ID of a source
1314  * is a positive integer which is unique within a particular main loop
1315  * context. The reverse
1316  * mapping from ID to source is done by g_main_context_find_source_by_id().
1317  *
1318  * You can only call this function while the source is associated to a
1319  * #GMainContext instance; calling this function before g_source_attach()
1320  * or after g_source_destroy() yields undefined behavior. The ID returned
1321  * is unique within the #GMainContext instance passed to g_source_attach().
1322  *
1323  * Returns: the ID (greater than 0) for the source
1324  **/
1325 guint
1326 g_source_get_id (GSource *source)
1327 {
1328   guint result;
1329 
1330   g_return_val_if_fail (source != NULL, 0);
1331   g_return_val_if_fail (source-&gt;context != NULL, 0);
1332 
1333   LOCK_CONTEXT (source-&gt;context);
1334   result = source-&gt;source_id;
1335   UNLOCK_CONTEXT (source-&gt;context);
1336 
1337   return result;
1338 }
1339 
1340 /**
1341  * g_source_get_context:
1342  * @source: a #GSource
1343  *
1344  * Gets the #GMainContext with which the source is associated.
1345  *
1346  * You can call this on a source that has been destroyed, provided
1347  * that the #GMainContext it was attached to still exists (in which
1348  * case it will return that #GMainContext). In particular, you can
1349  * always call this function on the source returned from
1350  * g_main_current_source(). But calling this function on a source
1351  * whose #GMainContext has been destroyed is an error.
1352  *
1353  * Returns: (transfer none) (nullable): the #GMainContext with which the
1354  *               source is associated, or %NULL if the context has not
1355  *               yet been added to a source.
1356  **/
1357 GMainContext *
1358 g_source_get_context (GSource *source)
1359 {
1360   g_return_val_if_fail (source-&gt;context != NULL || !SOURCE_DESTROYED (source), NULL);
1361 
1362   return source-&gt;context;
1363 }
1364 
1365 /**
1366  * g_source_add_poll:
1367  * @source:a #GSource
1368  * @fd: a #GPollFD structure holding information about a file
1369  *      descriptor to watch.
1370  *
1371  * Adds a file descriptor to the set of file descriptors polled for
1372  * this source. This is usually combined with g_source_new() to add an
1373  * event source. The event source&#39;s check function will typically test
1374  * the @revents field in the #GPollFD struct and return %TRUE if events need
1375  * to be processed.
1376  *
1377  * This API is only intended to be used by implementations of #GSource.
1378  * Do not call this API on a #GSource that you did not create.
1379  *
1380  * Using this API forces the linear scanning of event sources on each
1381  * main loop iteration.  Newly-written event sources should try to use
1382  * g_source_add_unix_fd() instead of this API.
1383  **/
1384 void
1385 g_source_add_poll (GSource *source,
1386        GPollFD *fd)
1387 {
1388   GMainContext *context;
1389 
1390   g_return_if_fail (source != NULL);
1391   g_return_if_fail (fd != NULL);
1392   g_return_if_fail (!SOURCE_DESTROYED (source));
1393 
1394 #ifdef GSTREAMER_LITE
1395   if (source == NULL)
1396     return;
1397 #endif // GSTREAMER_LITE
1398 
1399   context = source-&gt;context;
1400 
1401   if (context)
1402     LOCK_CONTEXT (context);
1403 
1404   source-&gt;poll_fds = g_slist_prepend (source-&gt;poll_fds, fd);
1405 
1406   if (context)
1407     {
1408       if (!SOURCE_BLOCKED (source))
1409   g_main_context_add_poll_unlocked (context, source-&gt;priority, fd);
1410       UNLOCK_CONTEXT (context);
1411     }
1412 }
1413 
1414 /**
1415  * g_source_remove_poll:
1416  * @source:a #GSource
1417  * @fd: a #GPollFD structure previously passed to g_source_add_poll().
1418  *
1419  * Removes a file descriptor from the set of file descriptors polled for
1420  * this source.
1421  *
1422  * This API is only intended to be used by implementations of #GSource.
1423  * Do not call this API on a #GSource that you did not create.
1424  **/
1425 void
1426 g_source_remove_poll (GSource *source,
1427           GPollFD *fd)
1428 {
1429   GMainContext *context;
1430 
1431   g_return_if_fail (source != NULL);
1432   g_return_if_fail (fd != NULL);
1433   g_return_if_fail (!SOURCE_DESTROYED (source));
1434 
1435   context = source-&gt;context;
1436 
1437   if (context)
1438     LOCK_CONTEXT (context);
1439 
1440   source-&gt;poll_fds = g_slist_remove (source-&gt;poll_fds, fd);
1441 
1442   if (context)
1443     {
1444       if (!SOURCE_BLOCKED (source))
1445   g_main_context_remove_poll_unlocked (context, fd);
1446       UNLOCK_CONTEXT (context);
1447     }
1448 }
1449 
1450 /**
1451  * g_source_add_child_source:
1452  * @source:a #GSource
1453  * @child_source: a second #GSource that @source should &quot;poll&quot;
1454  *
1455  * Adds @child_source to @source as a &quot;polled&quot; source; when @source is
1456  * added to a #GMainContext, @child_source will be automatically added
1457  * with the same priority, when @child_source is triggered, it will
1458  * cause @source to dispatch (in addition to calling its own
1459  * callback), and when @source is destroyed, it will destroy
1460  * @child_source as well. (@source will also still be dispatched if
1461  * its own prepare/check functions indicate that it is ready.)
1462  *
1463  * If you don&#39;t need @child_source to do anything on its own when it
1464  * triggers, you can call g_source_set_dummy_callback() on it to set a
1465  * callback that does nothing (except return %TRUE if appropriate).
1466  *
1467  * @source will hold a reference on @child_source while @child_source
1468  * is attached to it.
1469  *
1470  * This API is only intended to be used by implementations of #GSource.
1471  * Do not call this API on a #GSource that you did not create.
1472  *
1473  * Since: 2.28
1474  **/
1475 void
1476 g_source_add_child_source (GSource *source,
1477          GSource *child_source)
1478 {
1479   GMainContext *context;
1480 
1481   g_return_if_fail (source != NULL);
1482   g_return_if_fail (child_source != NULL);
1483   g_return_if_fail (!SOURCE_DESTROYED (source));
1484   g_return_if_fail (!SOURCE_DESTROYED (child_source));
1485   g_return_if_fail (child_source-&gt;context == NULL);
1486   g_return_if_fail (child_source-&gt;priv-&gt;parent_source == NULL);
1487 
1488   context = source-&gt;context;
1489 
1490   if (context)
1491     LOCK_CONTEXT (context);
1492 
1493   TRACE (GLIB_SOURCE_ADD_CHILD_SOURCE (source, child_source));
1494 
1495   source-&gt;priv-&gt;child_sources = g_slist_prepend (source-&gt;priv-&gt;child_sources,
1496              g_source_ref (child_source));
1497   child_source-&gt;priv-&gt;parent_source = source;
1498   g_source_set_priority_unlocked (child_source, NULL, source-&gt;priority);
1499   if (SOURCE_BLOCKED (source))
1500     block_source (child_source);
1501 
1502   if (context)
1503     {
1504       g_source_attach_unlocked (child_source, context, TRUE);
1505       UNLOCK_CONTEXT (context);
1506     }
1507 }
1508 
1509 static void
1510 g_child_source_remove_internal (GSource *child_source,
1511                                 GMainContext *context)
1512 {
1513   GSource *parent_source = child_source-&gt;priv-&gt;parent_source;
1514 
1515   parent_source-&gt;priv-&gt;child_sources =
1516     g_slist_remove (parent_source-&gt;priv-&gt;child_sources, child_source);
1517   child_source-&gt;priv-&gt;parent_source = NULL;
1518 
1519   g_source_destroy_internal (child_source, context, TRUE);
1520   g_source_unref_internal (child_source, context, TRUE);
1521 }
1522 
1523 /**
1524  * g_source_remove_child_source:
1525  * @source:a #GSource
1526  * @child_source: a #GSource previously passed to
1527  *     g_source_add_child_source().
1528  *
1529  * Detaches @child_source from @source and destroys it.
1530  *
1531  * This API is only intended to be used by implementations of #GSource.
1532  * Do not call this API on a #GSource that you did not create.
1533  *
1534  * Since: 2.28
1535  **/
1536 void
1537 g_source_remove_child_source (GSource *source,
1538             GSource *child_source)
1539 {
1540   GMainContext *context;
1541 
1542   g_return_if_fail (source != NULL);
1543   g_return_if_fail (child_source != NULL);
1544   g_return_if_fail (child_source-&gt;priv-&gt;parent_source == source);
1545   g_return_if_fail (!SOURCE_DESTROYED (source));
1546   g_return_if_fail (!SOURCE_DESTROYED (child_source));
1547 
1548   context = source-&gt;context;
1549 
1550   if (context)
1551     LOCK_CONTEXT (context);
1552 
1553   g_child_source_remove_internal (child_source, context);
1554 
1555   if (context)
1556     UNLOCK_CONTEXT (context);
1557 }
1558 
1559 static void
1560 g_source_callback_ref (gpointer cb_data)
1561 {
1562   GSourceCallback *callback = cb_data;
1563 
1564   g_atomic_int_inc (&amp;callback-&gt;ref_count);
1565 }
1566 
1567 static void
1568 g_source_callback_unref (gpointer cb_data)
1569 {
1570   GSourceCallback *callback = cb_data;
1571 
1572   if (g_atomic_int_dec_and_test (&amp;callback-&gt;ref_count))
1573     {
1574       if (callback-&gt;notify)
1575         callback-&gt;notify (callback-&gt;data);
1576       g_free (callback);
1577     }
1578 }
1579 
1580 static void
1581 g_source_callback_get (gpointer     cb_data,
1582            GSource     *source,
1583            GSourceFunc *func,
1584            gpointer    *data)
1585 {
1586   GSourceCallback *callback = cb_data;
1587 
1588   *func = callback-&gt;func;
1589   *data = callback-&gt;data;
1590 }
1591 
1592 static GSourceCallbackFuncs g_source_callback_funcs = {
1593   g_source_callback_ref,
1594   g_source_callback_unref,
1595   g_source_callback_get,
1596 };
1597 
1598 /**
1599  * g_source_set_callback_indirect:
1600  * @source: the source
1601  * @callback_data: pointer to callback data &quot;object&quot;
1602  * @callback_funcs: functions for reference counting @callback_data
1603  *                  and getting the callback and data
1604  *
1605  * Sets the callback function storing the data as a refcounted callback
1606  * &quot;object&quot;. This is used internally. Note that calling
1607  * g_source_set_callback_indirect() assumes
1608  * an initial reference count on @callback_data, and thus
1609  * @callback_funcs-&gt;unref will eventually be called once more
1610  * than @callback_funcs-&gt;ref.
1611  *
1612  * It is safe to call this function multiple times on a source which has already
1613  * been attached to a context. The changes will take effect for the next time
1614  * the source is dispatched after this call returns.
1615  **/
1616 void
1617 g_source_set_callback_indirect (GSource              *source,
1618         gpointer              callback_data,
1619         GSourceCallbackFuncs *callback_funcs)
1620 {
1621   GMainContext *context;
1622   gpointer old_cb_data;
1623   GSourceCallbackFuncs *old_cb_funcs;
1624 
1625   g_return_if_fail (source != NULL);
1626   g_return_if_fail (callback_funcs != NULL || callback_data == NULL);
1627 
1628   context = source-&gt;context;
1629 
1630   if (context)
1631     LOCK_CONTEXT (context);
1632 
1633   if (callback_funcs != &amp;g_source_callback_funcs)
1634     {
1635       TRACE (GLIB_SOURCE_SET_CALLBACK_INDIRECT (source, callback_data,
1636                                                 callback_funcs-&gt;ref,
1637                                                 callback_funcs-&gt;unref,
1638                                                 callback_funcs-&gt;get));
1639     }
1640 
1641   old_cb_data = source-&gt;callback_data;
1642   old_cb_funcs = source-&gt;callback_funcs;
1643 
1644   source-&gt;callback_data = callback_data;
1645   source-&gt;callback_funcs = callback_funcs;
1646 
1647   if (context)
1648     UNLOCK_CONTEXT (context);
1649 
1650   if (old_cb_funcs)
1651     old_cb_funcs-&gt;unref (old_cb_data);
1652 }
1653 
1654 /**
1655  * g_source_set_callback:
1656  * @source: the source
1657  * @func: a callback function
1658  * @data: the data to pass to callback function
1659  * @notify: (nullable): a function to call when @data is no longer in use, or %NULL.
1660  *
1661  * Sets the callback function for a source. The callback for a source is
1662  * called from the source&#39;s dispatch function.
1663  *
1664  * The exact type of @func depends on the type of source; ie. you
1665  * should not count on @func being called with @data as its first
1666  * parameter. Cast @func with G_SOURCE_FUNC() to avoid warnings about
1667  * incompatible function types.
1668  *
1669  * See [memory management of sources][mainloop-memory-management] for details
1670  * on how to handle memory management of @data.
1671  *
1672  * Typically, you won&#39;t use this function. Instead use functions specific
1673  * to the type of source you are using, such as g_idle_add() or g_timeout_add().
1674  *
1675  * It is safe to call this function multiple times on a source which has already
1676  * been attached to a context. The changes will take effect for the next time
1677  * the source is dispatched after this call returns.
1678  **/
1679 void
1680 g_source_set_callback (GSource        *source,
1681            GSourceFunc     func,
1682            gpointer        data,
1683            GDestroyNotify  notify)
1684 {
1685   GSourceCallback *new_callback;
1686 
1687   g_return_if_fail (source != NULL);
1688 #ifdef GSTREAMER_LITE
1689   if (source == NULL)
1690     return;
1691 #endif // GSTREAMER_LITE
1692 
1693   TRACE (GLIB_SOURCE_SET_CALLBACK (source, func, data, notify));
1694 
1695   new_callback = g_new (GSourceCallback, 1);
1696 
1697   new_callback-&gt;ref_count = 1;
1698   new_callback-&gt;func = func;
1699   new_callback-&gt;data = data;
1700   new_callback-&gt;notify = notify;
1701 
1702   g_source_set_callback_indirect (source, new_callback, &amp;g_source_callback_funcs);
1703 }
1704 
1705 
1706 /**
1707  * g_source_set_funcs:
1708  * @source: a #GSource
1709  * @funcs: the new #GSourceFuncs
1710  *
1711  * Sets the source functions (can be used to override
1712  * default implementations) of an unattached source.
1713  *
1714  * Since: 2.12
1715  */
1716 void
1717 g_source_set_funcs (GSource     *source,
1718              GSourceFuncs *funcs)
1719 {
1720   g_return_if_fail (source != NULL);
1721   g_return_if_fail (source-&gt;context == NULL);
1722   g_return_if_fail (g_atomic_int_get (&amp;source-&gt;ref_count) &gt; 0);
1723   g_return_if_fail (funcs != NULL);
1724 
1725   source-&gt;source_funcs = funcs;
1726 }
1727 
1728 static void
1729 g_source_set_priority_unlocked (GSource      *source,
1730         GMainContext *context,
1731         gint          priority)
1732 {
1733   GSList *tmp_list;
1734 
1735 #ifdef GSTREAMER_LITE
1736   if (source == NULL || source-&gt;priv == NULL || source-&gt;priv-&gt;parent_source == NULL)
1737     return;
1738 
1739   if (context == NULL)
1740     return;
1741 #endif // GSTREAMER_LITE
1742 
1743   g_return_if_fail (source-&gt;priv-&gt;parent_source == NULL ||
1744         source-&gt;priv-&gt;parent_source-&gt;priority == priority);
1745 
1746   TRACE (GLIB_SOURCE_SET_PRIORITY (source, context, priority));
1747 
1748   if (context)
1749     {
1750       /* Remove the source from the context&#39;s source and then
1751        * add it back after so it is sorted in the correct place
1752        */
1753       source_remove_from_context (source, source-&gt;context);
1754     }
1755 
1756   source-&gt;priority = priority;
1757 
1758   if (context)
1759     {
1760       source_add_to_context (source, source-&gt;context);
1761 
1762       if (!SOURCE_BLOCKED (source))
1763   {
1764     tmp_list = source-&gt;poll_fds;
1765     while (tmp_list)
1766       {
1767         g_main_context_remove_poll_unlocked (context, tmp_list-&gt;data);
1768         g_main_context_add_poll_unlocked (context, priority, tmp_list-&gt;data);
1769 
1770         tmp_list = tmp_list-&gt;next;
1771       }
1772 
1773           for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
1774             {
1775               g_main_context_remove_poll_unlocked (context, tmp_list-&gt;data);
1776               g_main_context_add_poll_unlocked (context, priority, tmp_list-&gt;data);
1777             }
1778   }
1779     }
1780 
1781   if (source-&gt;priv-&gt;child_sources)
1782     {
1783       tmp_list = source-&gt;priv-&gt;child_sources;
1784       while (tmp_list)
1785   {
1786     g_source_set_priority_unlocked (tmp_list-&gt;data, context, priority);
1787     tmp_list = tmp_list-&gt;next;
1788   }
1789     }
1790 }
1791 
1792 /**
1793  * g_source_set_priority:
1794  * @source: a #GSource
1795  * @priority: the new priority.
1796  *
1797  * Sets the priority of a source. While the main loop is being run, a
1798  * source will be dispatched if it is ready to be dispatched and no
1799  * sources at a higher (numerically smaller) priority are ready to be
1800  * dispatched.
1801  *
1802  * A child source always has the same priority as its parent.  It is not
1803  * permitted to change the priority of a source once it has been added
1804  * as a child of another source.
1805  **/
1806 void
1807 g_source_set_priority (GSource  *source,
1808            gint      priority)
1809 {
1810   GMainContext *context;
1811 
1812 #ifdef GSTREAMER_LITE
1813   if (source == NULL || source-&gt;priv == NULL || source-&gt;priv-&gt;parent_source == NULL)
1814     return;
1815 #endif // GSTREAMER_LITE
1816 
1817   g_return_if_fail (source != NULL);
1818   g_return_if_fail (source-&gt;priv-&gt;parent_source == NULL);
1819 
1820   context = source-&gt;context;
1821 
1822   if (context)
1823     LOCK_CONTEXT (context);
1824   g_source_set_priority_unlocked (source, context, priority);
1825   if (context)
1826     UNLOCK_CONTEXT (context);
1827 }
1828 
1829 /**
1830  * g_source_get_priority:
1831  * @source: a #GSource
1832  *
1833  * Gets the priority of a source.
1834  *
1835  * Returns: the priority of the source
1836  **/
1837 gint
1838 g_source_get_priority (GSource *source)
1839 {
1840   g_return_val_if_fail (source != NULL, 0);
1841 
1842   return source-&gt;priority;
1843 }
1844 
1845 /**
1846  * g_source_set_ready_time:
1847  * @source: a #GSource
1848  * @ready_time: the monotonic time at which the source will be ready,
1849  *              0 for &quot;immediately&quot;, -1 for &quot;never&quot;
1850  *
1851  * Sets a #GSource to be dispatched when the given monotonic time is
1852  * reached (or passed).  If the monotonic time is in the past (as it
1853  * always will be if @ready_time is 0) then the source will be
1854  * dispatched immediately.
1855  *
1856  * If @ready_time is -1 then the source is never woken up on the basis
1857  * of the passage of time.
1858  *
1859  * Dispatching the source does not reset the ready time.  You should do
1860  * so yourself, from the source dispatch function.
1861  *
1862  * Note that if you have a pair of sources where the ready time of one
1863  * suggests that it will be delivered first but the priority for the
1864  * other suggests that it would be delivered first, and the ready time
1865  * for both sources is reached during the same main context iteration,
1866  * then the order of dispatch is undefined.
1867  *
1868  * It is a no-op to call this function on a #GSource which has already been
1869  * destroyed with g_source_destroy().
1870  *
1871  * This API is only intended to be used by implementations of #GSource.
1872  * Do not call this API on a #GSource that you did not create.
1873  *
1874  * Since: 2.36
1875  **/
1876 void
1877 g_source_set_ready_time (GSource *source,
1878                          gint64   ready_time)
1879 {
1880   GMainContext *context;
1881 
1882   g_return_if_fail (source != NULL);
1883   /* We deliberately don&#39;t check for ref_count &gt; 0 here, because that
1884    * breaks cancellable_source_cancelled() in GCancellable: it has no
1885    * way to find out that the last-unref has happened until the
1886    * finalize() function is called, but that&#39;s too late, because the
1887    * ref_count already has already reached 0 before that time.
1888    * However, priv is only poisoned (set to NULL) after finalize(),
1889    * so we can use this as a simple guard against use-after-free.
1890    * See https://bugzilla.gnome.org/show_bug.cgi?id=791754 */
1891   g_return_if_fail (source-&gt;priv != NULL);
1892 
1893 #ifdef GSTREAMER_LITE
1894   if (source == NULL)
1895     return;
1896 #endif // GSTREAMER_LITE
1897 
1898   context = source-&gt;context;
1899 
1900   if (context)
1901     LOCK_CONTEXT (context);
1902 
1903   if (source-&gt;priv-&gt;ready_time == ready_time)
1904     {
1905       if (context)
1906         UNLOCK_CONTEXT (context);
1907 
1908       return;
1909     }
1910 
1911   source-&gt;priv-&gt;ready_time = ready_time;
1912 
1913   TRACE (GLIB_SOURCE_SET_READY_TIME (source, ready_time));
1914 
1915   if (context)
1916     {
1917       /* Quite likely that we need to change the timeout on the poll */
1918       if (!SOURCE_BLOCKED (source))
1919         g_wakeup_signal (context-&gt;wakeup);
1920       UNLOCK_CONTEXT (context);
1921     }
1922 }
1923 
1924 /**
1925  * g_source_get_ready_time:
1926  * @source: a #GSource
1927  *
1928  * Gets the &quot;ready time&quot; of @source, as set by
1929  * g_source_set_ready_time().
1930  *
1931  * Any time before the current monotonic time (including 0) is an
1932  * indication that the source will fire immediately.
1933  *
1934  * Returns: the monotonic ready time, -1 for &quot;never&quot;
1935  **/
1936 gint64
1937 g_source_get_ready_time (GSource *source)
1938 {
1939   g_return_val_if_fail (source != NULL, -1);
1940 
1941   return source-&gt;priv-&gt;ready_time;
1942 }
1943 
1944 /**
1945  * g_source_set_can_recurse:
1946  * @source: a #GSource
1947  * @can_recurse: whether recursion is allowed for this source
1948  *
1949  * Sets whether a source can be called recursively. If @can_recurse is
1950  * %TRUE, then while the source is being dispatched then this source
1951  * will be processed normally. Otherwise, all processing of this
1952  * source is blocked until the dispatch function returns.
1953  **/
1954 void
1955 g_source_set_can_recurse (GSource  *source,
1956         gboolean  can_recurse)
1957 {
1958   GMainContext *context;
1959 
1960   g_return_if_fail (source != NULL);
1961 
1962   context = source-&gt;context;
1963 
1964   if (context)
1965     LOCK_CONTEXT (context);
1966 
1967   if (can_recurse)
1968     source-&gt;flags |= G_SOURCE_CAN_RECURSE;
1969   else
1970     source-&gt;flags &amp;= ~G_SOURCE_CAN_RECURSE;
1971 
1972   if (context)
1973     UNLOCK_CONTEXT (context);
1974 }
1975 
1976 /**
1977  * g_source_get_can_recurse:
1978  * @source: a #GSource
1979  *
1980  * Checks whether a source is allowed to be called recursively.
1981  * see g_source_set_can_recurse().
1982  *
1983  * Returns: whether recursion is allowed.
1984  **/
1985 gboolean
1986 g_source_get_can_recurse (GSource  *source)
1987 {
1988   g_return_val_if_fail (source != NULL, FALSE);
1989 
1990   return (source-&gt;flags &amp; G_SOURCE_CAN_RECURSE) != 0;
1991 }
1992 
1993 
1994 /**
1995  * g_source_set_name:
1996  * @source: a #GSource
1997  * @name: debug name for the source
1998  *
1999  * Sets a name for the source, used in debugging and profiling.
2000  * The name defaults to #NULL.
2001  *
2002  * The source name should describe in a human-readable way
2003  * what the source does. For example, &quot;X11 event queue&quot;
2004  * or &quot;GTK+ repaint idle handler&quot; or whatever it is.
2005  *
2006  * It is permitted to call this function multiple times, but is not
2007  * recommended due to the potential performance impact.  For example,
2008  * one could change the name in the &quot;check&quot; function of a #GSourceFuncs
2009  * to include details like the event type in the source name.
2010  *
2011  * Use caution if changing the name while another thread may be
2012  * accessing it with g_source_get_name(); that function does not copy
2013  * the value, and changing the value will free it while the other thread
2014  * may be attempting to use it.
2015  *
2016  * Since: 2.26
2017  **/
2018 void
2019 g_source_set_name (GSource    *source,
2020                    const char *name)
2021 {
2022   GMainContext *context;
2023 
2024   g_return_if_fail (source != NULL);
2025 
2026   context = source-&gt;context;
2027 
2028   if (context)
2029     LOCK_CONTEXT (context);
2030 
2031   TRACE (GLIB_SOURCE_SET_NAME (source, name));
2032 
2033   /* setting back to NULL is allowed, just because it&#39;s
2034    * weird if get_name can return NULL but you can&#39;t
2035    * set that.
2036    */
2037 
2038   g_free (source-&gt;name);
2039   source-&gt;name = g_strdup (name);
2040 
2041   if (context)
2042     UNLOCK_CONTEXT (context);
2043 }
2044 
2045 /**
2046  * g_source_get_name:
2047  * @source: a #GSource
2048  *
2049  * Gets a name for the source, used in debugging and profiling.  The
2050  * name may be #NULL if it has never been set with g_source_set_name().
2051  *
2052  * Returns: the name of the source
2053  *
2054  * Since: 2.26
2055  **/
2056 const char *
2057 g_source_get_name (GSource *source)
2058 {
2059   g_return_val_if_fail (source != NULL, NULL);
2060 
2061   return source-&gt;name;
2062 }
2063 
2064 /**
2065  * g_source_set_name_by_id:
2066  * @tag: a #GSource ID
2067  * @name: debug name for the source
2068  *
2069  * Sets the name of a source using its ID.
2070  *
2071  * This is a convenience utility to set source names from the return
2072  * value of g_idle_add(), g_timeout_add(), etc.
2073  *
2074  * It is a programmer error to attempt to set the name of a non-existent
2075  * source.
2076  *
2077  * More specifically: source IDs can be reissued after a source has been
2078  * destroyed and therefore it is never valid to use this function with a
2079  * source ID which may have already been removed.  An example is when
2080  * scheduling an idle to run in another thread with g_idle_add(): the
2081  * idle may already have run and been removed by the time this function
2082  * is called on its (now invalid) source ID.  This source ID may have
2083  * been reissued, leading to the operation being performed against the
2084  * wrong source.
2085  *
2086  * Since: 2.26
2087  **/
2088 void
2089 g_source_set_name_by_id (guint           tag,
2090                          const char     *name)
2091 {
2092   GSource *source;
2093 
2094   g_return_if_fail (tag &gt; 0);
2095 
2096   source = g_main_context_find_source_by_id (NULL, tag);
2097   if (source == NULL)
2098     return;
2099 
2100   g_source_set_name (source, name);
2101 }
2102 
2103 
2104 /**
2105  * g_source_ref:
2106  * @source: a #GSource
2107  *
2108  * Increases the reference count on a source by one.
2109  *
2110  * Returns: @source
2111  **/
2112 GSource *
2113 g_source_ref (GSource *source)
2114 {
2115   g_return_val_if_fail (source != NULL, NULL);
2116 
2117   g_atomic_int_inc (&amp;source-&gt;ref_count);
2118 
2119   return source;
2120 }
2121 
2122 /* g_source_unref() but possible to call within context lock
2123  */
2124 static void
2125 g_source_unref_internal (GSource      *source,
2126        GMainContext *context,
2127        gboolean      have_lock)
2128 {
2129   gpointer old_cb_data = NULL;
2130   GSourceCallbackFuncs *old_cb_funcs = NULL;
2131 
2132   g_return_if_fail (source != NULL);
2133 
2134   if (!have_lock &amp;&amp; context)
2135     LOCK_CONTEXT (context);
2136 
2137   if (g_atomic_int_dec_and_test (&amp;source-&gt;ref_count))
2138     {
2139       TRACE (GLIB_SOURCE_BEFORE_FREE (source, context,
2140                                       source-&gt;source_funcs-&gt;finalize));
2141 
2142       old_cb_data = source-&gt;callback_data;
2143       old_cb_funcs = source-&gt;callback_funcs;
2144 
2145       source-&gt;callback_data = NULL;
2146       source-&gt;callback_funcs = NULL;
2147 
2148       if (context)
2149   {
2150     if (!SOURCE_DESTROYED (source))
2151       g_warning (G_STRLOC &quot;: ref_count == 0, but source was still attached to a context!&quot;);
2152     source_remove_from_context (source, context);
2153 
2154           g_hash_table_remove (context-&gt;sources, GUINT_TO_POINTER (source-&gt;source_id));
2155   }
2156 
2157       if (source-&gt;source_funcs-&gt;finalize)
2158   {
2159           /* Temporarily increase the ref count again so that GSource methods
2160            * can be called from finalize(). */
2161           g_atomic_int_inc (&amp;source-&gt;ref_count);
2162     if (context)
2163       UNLOCK_CONTEXT (context);
2164     source-&gt;source_funcs-&gt;finalize (source);
2165     if (context)
2166       LOCK_CONTEXT (context);
2167           g_atomic_int_add (&amp;source-&gt;ref_count, -1);
2168   }
2169 
2170       if (old_cb_funcs)
2171         {
2172           /* Temporarily increase the ref count again so that GSource methods
2173            * can be called from callback_funcs.unref(). */
2174           g_atomic_int_inc (&amp;source-&gt;ref_count);
2175           if (context)
2176             UNLOCK_CONTEXT (context);
2177 
2178           old_cb_funcs-&gt;unref (old_cb_data);
2179 
2180           if (context)
2181             LOCK_CONTEXT (context);
2182           g_atomic_int_add (&amp;source-&gt;ref_count, -1);
2183         }
2184 
2185       g_free (source-&gt;name);
2186       source-&gt;name = NULL;
2187 
2188       g_slist_free (source-&gt;poll_fds);
2189       source-&gt;poll_fds = NULL;
2190 
2191       g_slist_free_full (source-&gt;priv-&gt;fds, g_free);
2192 
2193       while (source-&gt;priv-&gt;child_sources)
2194         {
2195           GSource *child_source = source-&gt;priv-&gt;child_sources-&gt;data;
2196 
2197           source-&gt;priv-&gt;child_sources =
2198             g_slist_remove (source-&gt;priv-&gt;child_sources, child_source);
2199           child_source-&gt;priv-&gt;parent_source = NULL;
2200 
2201           g_source_unref_internal (child_source, context, have_lock);
2202         }
2203 
2204       g_slice_free (GSourcePrivate, source-&gt;priv);
2205       source-&gt;priv = NULL;
2206 
2207       g_free (source);
2208     }
2209 
2210   if (!have_lock &amp;&amp; context)
2211     UNLOCK_CONTEXT (context);
2212 }
2213 
2214 /**
2215  * g_source_unref:
2216  * @source: a #GSource
2217  *
2218  * Decreases the reference count of a source by one. If the
2219  * resulting reference count is zero the source and associated
2220  * memory will be destroyed.
2221  **/
2222 void
2223 g_source_unref (GSource *source)
2224 {
2225   g_return_if_fail (source != NULL);
2226 #ifdef GSTREAMER_LITE
2227   if (source == NULL)
2228     return;
2229 #endif // GSTREAMER_LITE
2230 
2231   g_source_unref_internal (source, source-&gt;context, FALSE);
2232 }
2233 
2234 /**
2235  * g_main_context_find_source_by_id:
2236  * @context: (nullable): a #GMainContext (if %NULL, the default context will be used)
2237  * @source_id: the source ID, as returned by g_source_get_id().
2238  *
2239  * Finds a #GSource given a pair of context and ID.
2240  *
2241  * It is a programmer error to attempt to look up a non-existent source.
2242  *
2243  * More specifically: source IDs can be reissued after a source has been
2244  * destroyed and therefore it is never valid to use this function with a
2245  * source ID which may have already been removed.  An example is when
2246  * scheduling an idle to run in another thread with g_idle_add(): the
2247  * idle may already have run and been removed by the time this function
2248  * is called on its (now invalid) source ID.  This source ID may have
2249  * been reissued, leading to the operation being performed against the
2250  * wrong source.
2251  *
2252  * Returns: (transfer none): the #GSource
2253  **/
2254 GSource *
2255 g_main_context_find_source_by_id (GMainContext *context,
2256                                   guint         source_id)
2257 {
2258   GSource *source;
2259 
2260   g_return_val_if_fail (source_id &gt; 0, NULL);
2261 
2262   if (context == NULL)
2263     context = g_main_context_default ();
2264 
2265   LOCK_CONTEXT (context);
2266   source = g_hash_table_lookup (context-&gt;sources, GUINT_TO_POINTER (source_id));
2267   UNLOCK_CONTEXT (context);
2268 
2269   if (source &amp;&amp; SOURCE_DESTROYED (source))
2270     source = NULL;
2271 
2272   return source;
2273 }
2274 
2275 /**
2276  * g_main_context_find_source_by_funcs_user_data:
2277  * @context: (nullable): a #GMainContext (if %NULL, the default context will be used).
2278  * @funcs: the @source_funcs passed to g_source_new().
2279  * @user_data: the user data from the callback.
2280  *
2281  * Finds a source with the given source functions and user data.  If
2282  * multiple sources exist with the same source function and user data,
2283  * the first one found will be returned.
2284  *
2285  * Returns: (transfer none): the source, if one was found, otherwise %NULL
2286  **/
2287 GSource *
2288 g_main_context_find_source_by_funcs_user_data (GMainContext *context,
2289                  GSourceFuncs *funcs,
2290                  gpointer      user_data)
2291 {
2292   GSourceIter iter;
2293   GSource *source;
2294 
2295   g_return_val_if_fail (funcs != NULL, NULL);
2296 
2297   if (context == NULL)
2298     context = g_main_context_default ();
2299 
2300   LOCK_CONTEXT (context);
2301 
2302   g_source_iter_init (&amp;iter, context, FALSE);
2303   while (g_source_iter_next (&amp;iter, &amp;source))
2304     {
2305       if (!SOURCE_DESTROYED (source) &amp;&amp;
2306     source-&gt;source_funcs == funcs &amp;&amp;
2307     source-&gt;callback_funcs)
2308   {
2309     GSourceFunc callback;
2310     gpointer callback_data;
2311 
2312     source-&gt;callback_funcs-&gt;get (source-&gt;callback_data, source, &amp;callback, &amp;callback_data);
2313 
2314     if (callback_data == user_data)
2315       break;
2316   }
2317     }
2318   g_source_iter_clear (&amp;iter);
2319 
2320   UNLOCK_CONTEXT (context);
2321 
2322   return source;
2323 }
2324 
2325 /**
2326  * g_main_context_find_source_by_user_data:
2327  * @context: a #GMainContext
2328  * @user_data: the user_data for the callback.
2329  *
2330  * Finds a source with the given user data for the callback.  If
2331  * multiple sources exist with the same user data, the first
2332  * one found will be returned.
2333  *
2334  * Returns: (transfer none): the source, if one was found, otherwise %NULL
2335  **/
2336 GSource *
2337 g_main_context_find_source_by_user_data (GMainContext *context,
2338            gpointer      user_data)
2339 {
2340   GSourceIter iter;
2341   GSource *source;
2342 
2343   if (context == NULL)
2344     context = g_main_context_default ();
2345 
2346   LOCK_CONTEXT (context);
2347 
2348   g_source_iter_init (&amp;iter, context, FALSE);
2349   while (g_source_iter_next (&amp;iter, &amp;source))
2350     {
2351       if (!SOURCE_DESTROYED (source) &amp;&amp;
2352     source-&gt;callback_funcs)
2353   {
2354     GSourceFunc callback;
2355     gpointer callback_data = NULL;
2356 
2357     source-&gt;callback_funcs-&gt;get (source-&gt;callback_data, source, &amp;callback, &amp;callback_data);
2358 
2359     if (callback_data == user_data)
2360       break;
2361   }
2362     }
2363   g_source_iter_clear (&amp;iter);
2364 
2365   UNLOCK_CONTEXT (context);
2366 
2367   return source;
2368 }
2369 
2370 /**
2371  * g_source_remove:
2372  * @tag: the ID of the source to remove.
2373  *
2374  * Removes the source with the given ID from the default main context. You must
2375  * use g_source_destroy() for sources added to a non-default main context.
2376  *
2377  * The ID of a #GSource is given by g_source_get_id(), or will be
2378  * returned by the functions g_source_attach(), g_idle_add(),
2379  * g_idle_add_full(), g_timeout_add(), g_timeout_add_full(),
2380  * g_child_watch_add(), g_child_watch_add_full(), g_io_add_watch(), and
2381  * g_io_add_watch_full().
2382  *
2383  * It is a programmer error to attempt to remove a non-existent source.
2384  *
2385  * More specifically: source IDs can be reissued after a source has been
2386  * destroyed and therefore it is never valid to use this function with a
2387  * source ID which may have already been removed.  An example is when
2388  * scheduling an idle to run in another thread with g_idle_add(): the
2389  * idle may already have run and been removed by the time this function
2390  * is called on its (now invalid) source ID.  This source ID may have
2391  * been reissued, leading to the operation being performed against the
2392  * wrong source.
2393  *
2394  * Returns: For historical reasons, this function always returns %TRUE
2395  **/
2396 gboolean
2397 g_source_remove (guint tag)
2398 {
2399   GSource *source;
2400 
2401   g_return_val_if_fail (tag &gt; 0, FALSE);
2402 
2403   source = g_main_context_find_source_by_id (NULL, tag);
2404   if (source)
2405     g_source_destroy (source);
2406   else
2407     g_critical (&quot;Source ID %u was not found when attempting to remove it&quot;, tag);
2408 
2409   return source != NULL;
2410 }
2411 
2412 /**
2413  * g_source_remove_by_user_data:
2414  * @user_data: the user_data for the callback.
2415  *
2416  * Removes a source from the default main loop context given the user
2417  * data for the callback. If multiple sources exist with the same user
2418  * data, only one will be destroyed.
2419  *
2420  * Returns: %TRUE if a source was found and removed.
2421  **/
2422 gboolean
2423 g_source_remove_by_user_data (gpointer user_data)
2424 {
2425   GSource *source;
2426 
2427   source = g_main_context_find_source_by_user_data (NULL, user_data);
2428   if (source)
2429     {
2430       g_source_destroy (source);
2431       return TRUE;
2432     }
2433   else
2434     return FALSE;
2435 }
2436 
2437 /**
2438  * g_source_remove_by_funcs_user_data:
2439  * @funcs: The @source_funcs passed to g_source_new()
2440  * @user_data: the user data for the callback
2441  *
2442  * Removes a source from the default main loop context given the
2443  * source functions and user data. If multiple sources exist with the
2444  * same source functions and user data, only one will be destroyed.
2445  *
2446  * Returns: %TRUE if a source was found and removed.
2447  **/
2448 gboolean
2449 g_source_remove_by_funcs_user_data (GSourceFuncs *funcs,
2450             gpointer      user_data)
2451 {
2452   GSource *source;
2453 
2454   g_return_val_if_fail (funcs != NULL, FALSE);
2455 
2456   source = g_main_context_find_source_by_funcs_user_data (NULL, funcs, user_data);
2457   if (source)
2458     {
2459       g_source_destroy (source);
2460       return TRUE;
2461     }
2462   else
2463     return FALSE;
2464 }
2465 
2466 /**
2467  * g_clear_handle_id: (skip)
2468  * @tag_ptr: (not nullable): a pointer to the handler ID
2469  * @clear_func: (not nullable): the function to call to clear the handler
2470  *
2471  * Clears a numeric handler, such as a #GSource ID.
2472  *
2473  * @tag_ptr must be a valid pointer to the variable holding the handler.
2474  *
2475  * If the ID is zero then this function does nothing.
2476  * Otherwise, clear_func() is called with the ID as a parameter, and the tag is
2477  * set to zero.
2478  *
2479  * A macro is also included that allows this function to be used without
2480  * pointer casts.
2481  *
2482  * Since: 2.56
2483  */
2484 #undef g_clear_handle_id
2485 void
2486 g_clear_handle_id (guint            *tag_ptr,
2487                    GClearHandleFunc  clear_func)
2488 {
2489   guint _handle_id;
2490 
2491   _handle_id = *tag_ptr;
2492   if (_handle_id &gt; 0)
2493     {
2494       *tag_ptr = 0;
2495       clear_func (_handle_id);
2496     }
2497 }
2498 
2499 #ifdef G_OS_UNIX
2500 /**
2501  * g_source_add_unix_fd:
2502  * @source: a #GSource
2503  * @fd: the fd to monitor
2504  * @events: an event mask
2505  *
2506  * Monitors @fd for the IO events in @events.
2507  *
2508  * The tag returned by this function can be used to remove or modify the
2509  * monitoring of the fd using g_source_remove_unix_fd() or
2510  * g_source_modify_unix_fd().
2511  *
2512  * It is not necessary to remove the fd before destroying the source; it
2513  * will be cleaned up automatically.
2514  *
2515  * This API is only intended to be used by implementations of #GSource.
2516  * Do not call this API on a #GSource that you did not create.
2517  *
2518  * As the name suggests, this function is not available on Windows.
2519  *
2520  * Returns: (not nullable): an opaque tag
2521  *
2522  * Since: 2.36
2523  **/
2524 gpointer
2525 g_source_add_unix_fd (GSource      *source,
2526                       gint          fd,
2527                       GIOCondition  events)
2528 {
2529   GMainContext *context;
2530   GPollFD *poll_fd;
2531 
2532   g_return_val_if_fail (source != NULL, NULL);
2533   g_return_val_if_fail (!SOURCE_DESTROYED (source), NULL);
2534 
2535   poll_fd = g_new (GPollFD, 1);
2536   poll_fd-&gt;fd = fd;
2537   poll_fd-&gt;events = events;
2538   poll_fd-&gt;revents = 0;
2539 
2540   context = source-&gt;context;
2541 
2542   if (context)
2543     LOCK_CONTEXT (context);
2544 
2545   source-&gt;priv-&gt;fds = g_slist_prepend (source-&gt;priv-&gt;fds, poll_fd);
2546 
2547   if (context)
2548     {
2549       if (!SOURCE_BLOCKED (source))
2550         g_main_context_add_poll_unlocked (context, source-&gt;priority, poll_fd);
2551       UNLOCK_CONTEXT (context);
2552     }
2553 
2554   return poll_fd;
2555 }
2556 
2557 /**
2558  * g_source_modify_unix_fd:
2559  * @source: a #GSource
2560  * @tag: (not nullable): the tag from g_source_add_unix_fd()
2561  * @new_events: the new event mask to watch
2562  *
2563  * Updates the event mask to watch for the fd identified by @tag.
2564  *
2565  * @tag is the tag returned from g_source_add_unix_fd().
2566  *
2567  * If you want to remove a fd, don&#39;t set its event mask to zero.
2568  * Instead, call g_source_remove_unix_fd().
2569  *
2570  * This API is only intended to be used by implementations of #GSource.
2571  * Do not call this API on a #GSource that you did not create.
2572  *
2573  * As the name suggests, this function is not available on Windows.
2574  *
2575  * Since: 2.36
2576  **/
2577 void
2578 g_source_modify_unix_fd (GSource      *source,
2579                          gpointer      tag,
2580                          GIOCondition  new_events)
2581 {
2582   GMainContext *context;
2583   GPollFD *poll_fd;
2584 
2585   g_return_if_fail (source != NULL);
2586   g_return_if_fail (g_slist_find (source-&gt;priv-&gt;fds, tag));
2587 
2588   context = source-&gt;context;
2589   poll_fd = tag;
2590 
2591   poll_fd-&gt;events = new_events;
2592 
2593   if (context)
2594     g_main_context_wakeup (context);
2595 }
2596 
2597 /**
2598  * g_source_remove_unix_fd:
2599  * @source: a #GSource
2600  * @tag: (not nullable): the tag from g_source_add_unix_fd()
2601  *
2602  * Reverses the effect of a previous call to g_source_add_unix_fd().
2603  *
2604  * You only need to call this if you want to remove an fd from being
2605  * watched while keeping the same source around.  In the normal case you
2606  * will just want to destroy the source.
2607  *
2608  * This API is only intended to be used by implementations of #GSource.
2609  * Do not call this API on a #GSource that you did not create.
2610  *
2611  * As the name suggests, this function is not available on Windows.
2612  *
2613  * Since: 2.36
2614  **/
2615 void
2616 g_source_remove_unix_fd (GSource  *source,
2617                          gpointer  tag)
2618 {
2619   GMainContext *context;
2620   GPollFD *poll_fd;
2621 
2622   g_return_if_fail (source != NULL);
2623   g_return_if_fail (g_slist_find (source-&gt;priv-&gt;fds, tag));
2624 
2625   context = source-&gt;context;
2626   poll_fd = tag;
2627 
2628   if (context)
2629     LOCK_CONTEXT (context);
2630 
2631   source-&gt;priv-&gt;fds = g_slist_remove (source-&gt;priv-&gt;fds, poll_fd);
2632 
2633   if (context)
2634     {
2635       if (!SOURCE_BLOCKED (source))
2636         g_main_context_remove_poll_unlocked (context, poll_fd);
2637 
2638       UNLOCK_CONTEXT (context);
2639     }
2640 
2641   g_free (poll_fd);
2642 }
2643 
2644 /**
2645  * g_source_query_unix_fd:
2646  * @source: a #GSource
2647  * @tag: (not nullable): the tag from g_source_add_unix_fd()
2648  *
2649  * Queries the events reported for the fd corresponding to @tag on
2650  * @source during the last poll.
2651  *
2652  * The return value of this function is only defined when the function
2653  * is called from the check or dispatch functions for @source.
2654  *
2655  * This API is only intended to be used by implementations of #GSource.
2656  * Do not call this API on a #GSource that you did not create.
2657  *
2658  * As the name suggests, this function is not available on Windows.
2659  *
2660  * Returns: the conditions reported on the fd
2661  *
2662  * Since: 2.36
2663  **/
2664 GIOCondition
2665 g_source_query_unix_fd (GSource  *source,
2666                         gpointer  tag)
2667 {
2668   GPollFD *poll_fd;
2669 
2670   g_return_val_if_fail (source != NULL, 0);
2671   g_return_val_if_fail (g_slist_find (source-&gt;priv-&gt;fds, tag), 0);
2672 
2673   poll_fd = tag;
2674 
2675   return poll_fd-&gt;revents;
2676 }
2677 #endif /* G_OS_UNIX */
2678 
2679 /**
2680  * g_get_current_time:
2681  * @result: #GTimeVal structure in which to store current time.
2682  *
2683  * Equivalent to the UNIX gettimeofday() function, but portable.
2684  *
2685  * You may find g_get_real_time() to be more convenient.
2686  *
2687  * Deprecated: 2.62: #GTimeVal is not year-2038-safe. Use g_get_real_time()
2688  *    instead.
2689  **/
2690 G_GNUC_BEGIN_IGNORE_DEPRECATIONS
2691 void
2692 g_get_current_time (GTimeVal *result)
2693 {
2694   gint64 tv;
2695 
2696   g_return_if_fail (result != NULL);
2697 
2698   tv = g_get_real_time ();
2699 
2700   result-&gt;tv_sec = tv / 1000000;
2701   result-&gt;tv_usec = tv % 1000000;
2702 }
2703 G_GNUC_END_IGNORE_DEPRECATIONS
2704 
2705 /**
2706  * g_get_real_time:
2707  *
2708  * Queries the system wall-clock time.
2709  *
2710  * This call is functionally equivalent to g_get_current_time() except
2711  * that the return value is often more convenient than dealing with a
2712  * #GTimeVal.
2713  *
2714  * You should only use this call if you are actually interested in the real
2715  * wall-clock time.  g_get_monotonic_time() is probably more useful for
2716  * measuring intervals.
2717  *
2718  * Returns: the number of microseconds since January 1, 1970 UTC.
2719  *
2720  * Since: 2.28
2721  **/
2722 gint64
2723 g_get_real_time (void)
2724 {
2725 #ifndef G_OS_WIN32
2726   struct timeval r;
2727 
2728   /* this is required on alpha, there the timeval structs are ints
2729    * not longs and a cast only would fail horribly */
2730   gettimeofday (&amp;r, NULL);
2731 
2732   return (((gint64) r.tv_sec) * 1000000) + r.tv_usec;
2733 #else
2734   FILETIME ft;
2735   guint64 time64;
2736 
2737   GetSystemTimeAsFileTime (&amp;ft);
2738   memmove (&amp;time64, &amp;ft, sizeof (FILETIME));
2739 
2740   /* Convert from 100s of nanoseconds since 1601-01-01
2741    * to Unix epoch. This is Y2038 safe.
2742    */
2743   time64 -= G_GINT64_CONSTANT (116444736000000000);
2744   time64 /= 10;
2745 
2746   return time64;
2747 #endif
2748 }
2749 
2750 /**
2751  * g_get_monotonic_time:
2752  *
2753  * Queries the system monotonic time.
2754  *
2755  * The monotonic clock will always increase and doesn&#39;t suffer
2756  * discontinuities when the user (or NTP) changes the system time.  It
2757  * may or may not continue to tick during times where the machine is
2758  * suspended.
2759  *
2760  * We try to use the clock that corresponds as closely as possible to
2761  * the passage of time as measured by system calls such as poll() but it
2762  * may not always be possible to do this.
2763  *
2764  * Returns: the monotonic time, in microseconds
2765  *
2766  * Since: 2.28
2767  **/
2768 #if defined (G_OS_WIN32)
2769 /* NOTE:
2770  * time_usec = ticks_since_boot * usec_per_sec / ticks_per_sec
2771  *
2772  * Doing (ticks_since_boot * usec_per_sec) before the division can overflow 64 bits
2773  * (ticks_since_boot  / ticks_per_sec) and then multiply would not be accurate enough.
2774  * So for now we calculate (usec_per_sec / ticks_per_sec) and use floating point
2775  */
2776 static gdouble g_monotonic_usec_per_tick = 0;
2777 
2778 void
2779 g_clock_win32_init (void)
2780 {
2781   LARGE_INTEGER freq;
2782 
2783   if (!QueryPerformanceFrequency (&amp;freq) || freq.QuadPart == 0)
2784     {
2785       /* The documentation says that this should never happen */
2786       g_assert_not_reached ();
2787       return;
2788     }
2789 
2790   g_monotonic_usec_per_tick = (gdouble)G_USEC_PER_SEC / freq.QuadPart;
2791 }
2792 
2793 gint64
2794 g_get_monotonic_time (void)
2795 {
2796   if (G_LIKELY (g_monotonic_usec_per_tick != 0))
2797     {
2798       LARGE_INTEGER ticks;
2799 
2800       if (QueryPerformanceCounter (&amp;ticks))
2801         return (gint64)(ticks.QuadPart * g_monotonic_usec_per_tick);
2802 
2803       g_warning (&quot;QueryPerformanceCounter Failed (%lu)&quot;, GetLastError ());
2804       g_monotonic_usec_per_tick = 0;
2805     }
2806 
2807   return 0;
2808 }
2809 #elif defined(HAVE_MACH_MACH_TIME_H) /* Mac OS */
2810 gint64
2811 g_get_monotonic_time (void)
2812 {
2813   static mach_timebase_info_data_t timebase_info;
2814 
2815   if (timebase_info.denom == 0)
2816     {
2817       /* This is a fraction that we must use to scale
2818        * mach_absolute_time() by in order to reach nanoseconds.
2819        *
2820        * We&#39;ve only ever observed this to be 1/1, but maybe it could be
2821        * 1000/1 if mach time is microseconds already, or 1/1000 if
2822        * picoseconds.  Try to deal nicely with that.
2823        */
2824       mach_timebase_info (&amp;timebase_info);
2825 
2826       /* We actually want microseconds... */
2827       if (timebase_info.numer % 1000 == 0)
2828         timebase_info.numer /= 1000;
2829       else
2830         timebase_info.denom *= 1000;
2831 
2832       /* We want to make the numer 1 to avoid having to multiply... */
2833       if (timebase_info.denom % timebase_info.numer == 0)
2834         {
2835           timebase_info.denom /= timebase_info.numer;
2836           timebase_info.numer = 1;
2837         }
2838       else
2839         {
2840           /* We could just multiply by timebase_info.numer below, but why
2841            * bother for a case that may never actually exist...
2842            *
2843            * Plus -- performing the multiplication would risk integer
2844            * overflow.  If we ever actually end up in this situation, we
2845            * should more carefully evaluate the correct course of action.
2846            */
2847           mach_timebase_info (&amp;timebase_info); /* Get a fresh copy for a better message */
2848           g_error (&quot;Got weird mach timebase info of %d/%d.  Please file a bug against GLib.&quot;,
2849                    timebase_info.numer, timebase_info.denom);
2850         }
2851     }
2852 
2853   return mach_absolute_time () / timebase_info.denom;
2854 }
2855 #else
2856 gint64
2857 g_get_monotonic_time (void)
2858 {
2859   struct timespec ts;
2860   gint result;
2861 
2862   result = clock_gettime (CLOCK_MONOTONIC, &amp;ts);
2863 
2864   if G_UNLIKELY (result != 0)
2865     g_error (&quot;GLib requires working CLOCK_MONOTONIC&quot;);
2866 
2867   return (((gint64) ts.tv_sec) * 1000000) + (ts.tv_nsec / 1000);
2868 }
2869 #endif
2870 
2871 static void
2872 g_main_dispatch_free (gpointer dispatch)
2873 {
2874   g_free (dispatch);
2875 }
2876 
2877 /* Running the main loop */
2878 
2879 static GMainDispatch *
2880 get_dispatch (void)
2881 {
2882   static GPrivate depth_private = G_PRIVATE_INIT (g_main_dispatch_free);
2883   GMainDispatch *dispatch;
2884 
2885   dispatch = g_private_get (&amp;depth_private);
2886 
2887   if (!dispatch)
2888     dispatch = g_private_set_alloc0 (&amp;depth_private, sizeof (GMainDispatch));
2889 
2890   return dispatch;
2891 }
2892 
2893 /**
2894  * g_main_depth:
2895  *
2896  * Returns the depth of the stack of calls to
2897  * g_main_context_dispatch() on any #GMainContext in the current thread.
2898  *  That is, when called from the toplevel, it gives 0. When
2899  * called from within a callback from g_main_context_iteration()
2900  * (or g_main_loop_run(), etc.) it returns 1. When called from within
2901  * a callback to a recursive call to g_main_context_iteration(),
2902  * it returns 2. And so forth.
2903  *
2904  * This function is useful in a situation like the following:
2905  * Imagine an extremely simple &quot;garbage collected&quot; system.
2906  *
2907  * |[&lt;!-- language=&quot;C&quot; --&gt;
2908  * static GList *free_list;
2909  *
2910  * gpointer
2911  * allocate_memory (gsize size)
2912  * {
2913  *   gpointer result = g_malloc (size);
2914  *   free_list = g_list_prepend (free_list, result);
2915  *   return result;
2916  * }
2917  *
2918  * void
2919  * free_allocated_memory (void)
2920  * {
2921  *   GList *l;
2922  *   for (l = free_list; l; l = l-&gt;next);
2923  *     g_free (l-&gt;data);
2924  *   g_list_free (free_list);
2925  *   free_list = NULL;
2926  *  }
2927  *
2928  * [...]
2929  *
2930  * while (TRUE);
2931  *  {
2932  *    g_main_context_iteration (NULL, TRUE);
2933  *    free_allocated_memory();
2934  *   }
2935  * ]|
2936  *
2937  * This works from an application, however, if you want to do the same
2938  * thing from a library, it gets more difficult, since you no longer
2939  * control the main loop. You might think you can simply use an idle
2940  * function to make the call to free_allocated_memory(), but that
2941  * doesn&#39;t work, since the idle function could be called from a
2942  * recursive callback. This can be fixed by using g_main_depth()
2943  *
2944  * |[&lt;!-- language=&quot;C&quot; --&gt;
2945  * gpointer
2946  * allocate_memory (gsize size)
2947  * {
2948  *   FreeListBlock *block = g_new (FreeListBlock, 1);
2949  *   block-&gt;mem = g_malloc (size);
2950  *   block-&gt;depth = g_main_depth ();
2951  *   free_list = g_list_prepend (free_list, block);
2952  *   return block-&gt;mem;
2953  * }
2954  *
2955  * void
2956  * free_allocated_memory (void)
2957  * {
2958  *   GList *l;
2959  *
2960  *   int depth = g_main_depth ();
2961  *   for (l = free_list; l; );
2962  *     {
2963  *       GList *next = l-&gt;next;
2964  *       FreeListBlock *block = l-&gt;data;
2965  *       if (block-&gt;depth &gt; depth)
2966  *         {
2967  *           g_free (block-&gt;mem);
2968  *           g_free (block);
2969  *           free_list = g_list_delete_link (free_list, l);
2970  *         }
2971  *
2972  *       l = next;
2973  *     }
2974  *   }
2975  * ]|
2976  *
2977  * There is a temptation to use g_main_depth() to solve
2978  * problems with reentrancy. For instance, while waiting for data
2979  * to be received from the network in response to a menu item,
2980  * the menu item might be selected again. It might seem that
2981  * one could make the menu item&#39;s callback return immediately
2982  * and do nothing if g_main_depth() returns a value greater than 1.
2983  * However, this should be avoided since the user then sees selecting
2984  * the menu item do nothing. Furthermore, you&#39;ll find yourself adding
2985  * these checks all over your code, since there are doubtless many,
2986  * many things that the user could do. Instead, you can use the
2987  * following techniques:
2988  *
2989  * 1. Use gtk_widget_set_sensitive() or modal dialogs to prevent
2990  *    the user from interacting with elements while the main
2991  *    loop is recursing.
2992  *
2993  * 2. Avoid main loop recursion in situations where you can&#39;t handle
2994  *    arbitrary  callbacks. Instead, structure your code so that you
2995  *    simply return to the main loop and then get called again when
2996  *    there is more work to do.
2997  *
2998  * Returns: The main loop recursion level in the current thread
2999  */
3000 int
3001 g_main_depth (void)
3002 {
3003   GMainDispatch *dispatch = get_dispatch ();
3004   return dispatch-&gt;depth;
3005 }
3006 
3007 /**
3008  * g_main_current_source:
3009  *
3010  * Returns the currently firing source for this thread.
3011  *
3012  * Returns: (transfer none): The currently firing source or %NULL.
3013  *
3014  * Since: 2.12
3015  */
3016 GSource *
3017 g_main_current_source (void)
3018 {
3019   GMainDispatch *dispatch = get_dispatch ();
3020   return dispatch-&gt;source;
3021 }
3022 
3023 /**
3024  * g_source_is_destroyed:
3025  * @source: a #GSource
3026  *
3027  * Returns whether @source has been destroyed.
3028  *
3029  * This is important when you operate upon your objects
3030  * from within idle handlers, but may have freed the object
3031  * before the dispatch of your idle handler.
3032  *
3033  * |[&lt;!-- language=&quot;C&quot; --&gt;
3034  * static gboolean
3035  * idle_callback (gpointer data)
3036  * {
3037  *   SomeWidget *self = data;
3038  *
3039  *   GDK_THREADS_ENTER ();
3040  *   // do stuff with self
3041  *   self-&gt;idle_id = 0;
3042  *   GDK_THREADS_LEAVE ();
3043  *
3044  *   return G_SOURCE_REMOVE;
3045  * }
3046  *
3047  * static void
3048  * some_widget_do_stuff_later (SomeWidget *self)
3049  * {
3050  *   self-&gt;idle_id = g_idle_add (idle_callback, self);
3051  * }
3052  *
3053  * static void
3054  * some_widget_finalize (GObject *object)
3055  * {
3056  *   SomeWidget *self = SOME_WIDGET (object);
3057  *
3058  *   if (self-&gt;idle_id)
3059  *     g_source_remove (self-&gt;idle_id);
3060  *
3061  *   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
3062  * }
3063  * ]|
3064  *
3065  * This will fail in a multi-threaded application if the
3066  * widget is destroyed before the idle handler fires due
3067  * to the use after free in the callback. A solution, to
3068  * this particular problem, is to check to if the source
3069  * has already been destroy within the callback.
3070  *
3071  * |[&lt;!-- language=&quot;C&quot; --&gt;
3072  * static gboolean
3073  * idle_callback (gpointer data)
3074  * {
3075  *   SomeWidget *self = data;
3076  *
3077  *   GDK_THREADS_ENTER ();
3078  *   if (!g_source_is_destroyed (g_main_current_source ()))
3079  *     {
3080  *       // do stuff with self
3081  *     }
3082  *   GDK_THREADS_LEAVE ();
3083  *
3084  *   return FALSE;
3085  * }
3086  * ]|
3087  *
3088  * Calls to this function from a thread other than the one acquired by the
3089  * #GMainContext the #GSource is attached to are typically redundant, as the
3090  * source could be destroyed immediately after this function returns. However,
3091  * once a source is destroyed it cannot be un-destroyed, so this function can be
3092  * used for opportunistic checks from any thread.
3093  *
3094  * Returns: %TRUE if the source has been destroyed
3095  *
3096  * Since: 2.12
3097  */
3098 gboolean
3099 g_source_is_destroyed (GSource *source)
3100 {
3101   return SOURCE_DESTROYED (source);
3102 }
3103 
3104 /* Temporarily remove all this source&#39;s file descriptors from the
3105  * poll(), so that if data comes available for one of the file descriptors
3106  * we don&#39;t continually spin in the poll()
3107  */
3108 /* HOLDS: source-&gt;context&#39;s lock */
3109 static void
3110 block_source (GSource *source)
3111 {
3112   GSList *tmp_list;
3113 
3114   g_return_if_fail (!SOURCE_BLOCKED (source));
3115 
3116   source-&gt;flags |= G_SOURCE_BLOCKED;
3117 
3118   if (source-&gt;context)
3119     {
3120       tmp_list = source-&gt;poll_fds;
3121       while (tmp_list)
3122         {
3123           g_main_context_remove_poll_unlocked (source-&gt;context, tmp_list-&gt;data);
3124           tmp_list = tmp_list-&gt;next;
3125         }
3126 
3127       for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
3128         g_main_context_remove_poll_unlocked (source-&gt;context, tmp_list-&gt;data);
3129     }
3130 
3131   if (source-&gt;priv &amp;&amp; source-&gt;priv-&gt;child_sources)
3132     {
3133       tmp_list = source-&gt;priv-&gt;child_sources;
3134       while (tmp_list)
3135   {
3136     block_source (tmp_list-&gt;data);
3137     tmp_list = tmp_list-&gt;next;
3138   }
3139     }
3140 }
3141 
3142 /* HOLDS: source-&gt;context&#39;s lock */
3143 static void
3144 unblock_source (GSource *source)
3145 {
3146   GSList *tmp_list;
3147 
3148   g_return_if_fail (SOURCE_BLOCKED (source)); /* Source already unblocked */
3149   g_return_if_fail (!SOURCE_DESTROYED (source));
3150 
3151   source-&gt;flags &amp;= ~G_SOURCE_BLOCKED;
3152 
3153   tmp_list = source-&gt;poll_fds;
3154   while (tmp_list)
3155     {
3156       g_main_context_add_poll_unlocked (source-&gt;context, source-&gt;priority, tmp_list-&gt;data);
3157       tmp_list = tmp_list-&gt;next;
3158     }
3159 
3160   for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
3161     g_main_context_add_poll_unlocked (source-&gt;context, source-&gt;priority, tmp_list-&gt;data);
3162 
3163   if (source-&gt;priv &amp;&amp; source-&gt;priv-&gt;child_sources)
3164     {
3165       tmp_list = source-&gt;priv-&gt;child_sources;
3166       while (tmp_list)
3167   {
3168     unblock_source (tmp_list-&gt;data);
3169     tmp_list = tmp_list-&gt;next;
3170   }
3171     }
3172 }
3173 
3174 /* HOLDS: context&#39;s lock */
3175 static void
3176 g_main_dispatch (GMainContext *context)
3177 {
3178   GMainDispatch *current = get_dispatch ();
3179   guint i;
3180 
3181   for (i = 0; i &lt; context-&gt;pending_dispatches-&gt;len; i++)
3182     {
3183       GSource *source = context-&gt;pending_dispatches-&gt;pdata[i];
3184 
3185       context-&gt;pending_dispatches-&gt;pdata[i] = NULL;
3186       g_assert (source);
3187 
3188       source-&gt;flags &amp;= ~G_SOURCE_READY;
3189 
3190       if (!SOURCE_DESTROYED (source))
3191   {
3192     gboolean was_in_call;
3193     gpointer user_data = NULL;
3194     GSourceFunc callback = NULL;
3195     GSourceCallbackFuncs *cb_funcs;
3196     gpointer cb_data;
3197     gboolean need_destroy;
3198 
3199     gboolean (*dispatch) (GSource *,
3200         GSourceFunc,
3201         gpointer);
3202           GSource *prev_source;
3203 
3204     dispatch = source-&gt;source_funcs-&gt;dispatch;
3205     cb_funcs = source-&gt;callback_funcs;
3206     cb_data = source-&gt;callback_data;
3207 
3208     if (cb_funcs)
3209       cb_funcs-&gt;ref (cb_data);
3210 
3211     if ((source-&gt;flags &amp; G_SOURCE_CAN_RECURSE) == 0)
3212       block_source (source);
3213 
3214     was_in_call = source-&gt;flags &amp; G_HOOK_FLAG_IN_CALL;
3215     source-&gt;flags |= G_HOOK_FLAG_IN_CALL;
3216 
3217     if (cb_funcs)
3218       cb_funcs-&gt;get (cb_data, source, &amp;callback, &amp;user_data);
3219 
3220     UNLOCK_CONTEXT (context);
3221 
3222           /* These operations are safe because &#39;current&#39; is thread-local
3223            * and not modified from anywhere but this function.
3224            */
3225           prev_source = current-&gt;source;
3226           current-&gt;source = source;
3227           current-&gt;depth++;
3228 
3229           TRACE (GLIB_MAIN_BEFORE_DISPATCH (g_source_get_name (source), source,
3230                                             dispatch, callback, user_data));
3231           need_destroy = !(* dispatch) (source, callback, user_data);
3232           TRACE (GLIB_MAIN_AFTER_DISPATCH (g_source_get_name (source), source,
3233                                            dispatch, need_destroy));
3234 
3235           current-&gt;source = prev_source;
3236           current-&gt;depth--;
3237 
3238     if (cb_funcs)
3239       cb_funcs-&gt;unref (cb_data);
3240 
3241     LOCK_CONTEXT (context);
3242 
3243     if (!was_in_call)
3244       source-&gt;flags &amp;= ~G_HOOK_FLAG_IN_CALL;
3245 
3246     if (SOURCE_BLOCKED (source) &amp;&amp; !SOURCE_DESTROYED (source))
3247       unblock_source (source);
3248 
3249     /* Note: this depends on the fact that we can&#39;t switch
3250      * sources from one main context to another
3251      */
3252     if (need_destroy &amp;&amp; !SOURCE_DESTROYED (source))
3253       {
3254         g_assert (source-&gt;context == context);
3255         g_source_destroy_internal (source, context, TRUE);
3256       }
3257   }
3258 
3259       g_source_unref_internal (source, context, TRUE);
3260     }
3261 
3262   g_ptr_array_set_size (context-&gt;pending_dispatches, 0);
3263 }
3264 
3265 /**
3266  * g_main_context_acquire:
3267  * @context: a #GMainContext
3268  *
3269  * Tries to become the owner of the specified context.
3270  * If some other thread is the owner of the context,
3271  * returns %FALSE immediately. Ownership is properly
3272  * recursive: the owner can require ownership again
3273  * and will release ownership when g_main_context_release()
3274  * is called as many times as g_main_context_acquire().
3275  *
3276  * You must be the owner of a context before you
3277  * can call g_main_context_prepare(), g_main_context_query(),
3278  * g_main_context_check(), g_main_context_dispatch().
3279  *
3280  * Returns: %TRUE if the operation succeeded, and
3281  *   this thread is now the owner of @context.
3282  **/
3283 gboolean
3284 g_main_context_acquire (GMainContext *context)
3285 {
3286   gboolean result = FALSE;
3287   GThread *self = G_THREAD_SELF;
3288 
3289   if (context == NULL)
3290     context = g_main_context_default ();
3291 
3292   LOCK_CONTEXT (context);
3293 
3294   if (!context-&gt;owner)
3295     {
3296       context-&gt;owner = self;
3297       g_assert (context-&gt;owner_count == 0);
3298       TRACE (GLIB_MAIN_CONTEXT_ACQUIRE (context, TRUE  /* success */));
3299     }
3300 
3301   if (context-&gt;owner == self)
3302     {
3303       context-&gt;owner_count++;
3304       result = TRUE;
3305     }
3306   else
3307     {
3308       TRACE (GLIB_MAIN_CONTEXT_ACQUIRE (context, FALSE  /* failure */));
3309     }
3310 
3311   UNLOCK_CONTEXT (context);
3312 
3313   return result;
3314 }
3315 
3316 /**
3317  * g_main_context_release:
3318  * @context: a #GMainContext
3319  *
3320  * Releases ownership of a context previously acquired by this thread
3321  * with g_main_context_acquire(). If the context was acquired multiple
3322  * times, the ownership will be released only when g_main_context_release()
3323  * is called as many times as it was acquired.
3324  **/
3325 void
3326 g_main_context_release (GMainContext *context)
3327 {
3328   if (context == NULL)
3329     context = g_main_context_default ();
3330 
3331   LOCK_CONTEXT (context);
3332 
3333   context-&gt;owner_count--;
3334   if (context-&gt;owner_count == 0)
3335     {
3336       TRACE (GLIB_MAIN_CONTEXT_RELEASE (context));
3337 
3338       context-&gt;owner = NULL;
3339 
3340       if (context-&gt;waiters)
3341   {
3342     GMainWaiter *waiter = context-&gt;waiters-&gt;data;
3343     gboolean loop_internal_waiter = (waiter-&gt;mutex == &amp;context-&gt;mutex);
3344     context-&gt;waiters = g_slist_delete_link (context-&gt;waiters,
3345               context-&gt;waiters);
3346     if (!loop_internal_waiter)
3347       g_mutex_lock (waiter-&gt;mutex);
3348 
3349     g_cond_signal (waiter-&gt;cond);
3350 
3351     if (!loop_internal_waiter)
3352       g_mutex_unlock (waiter-&gt;mutex);
3353   }
3354     }
3355 
3356   UNLOCK_CONTEXT (context);
3357 }
3358 
3359 static gboolean
3360 g_main_context_wait_internal (GMainContext *context,
3361                               GCond        *cond,
3362                               GMutex       *mutex)
3363 {
3364   gboolean result = FALSE;
3365   GThread *self = G_THREAD_SELF;
3366   gboolean loop_internal_waiter;
3367 
3368   if (context == NULL)
3369     context = g_main_context_default ();
3370 
3371   loop_internal_waiter = (mutex == &amp;context-&gt;mutex);
3372 
3373   if (!loop_internal_waiter)
3374     LOCK_CONTEXT (context);
3375 
3376   if (context-&gt;owner &amp;&amp; context-&gt;owner != self)
3377     {
3378       GMainWaiter waiter;
3379 
3380       waiter.cond = cond;
3381       waiter.mutex = mutex;
3382 
3383       context-&gt;waiters = g_slist_append (context-&gt;waiters, &amp;waiter);
3384 
3385       if (!loop_internal_waiter)
3386         UNLOCK_CONTEXT (context);
3387       g_cond_wait (cond, mutex);
3388       if (!loop_internal_waiter)
3389         LOCK_CONTEXT (context);
3390 
3391       context-&gt;waiters = g_slist_remove (context-&gt;waiters, &amp;waiter);
3392     }
3393 
3394   if (!context-&gt;owner)
3395     {
3396       context-&gt;owner = self;
3397       g_assert (context-&gt;owner_count == 0);
3398     }
3399 
3400   if (context-&gt;owner == self)
3401     {
3402       context-&gt;owner_count++;
3403       result = TRUE;
3404     }
3405 
3406   if (!loop_internal_waiter)
3407     UNLOCK_CONTEXT (context);
3408 
3409   return result;
3410 }
3411 
3412 /**
3413  * g_main_context_wait:
3414  * @context: a #GMainContext
3415  * @cond: a condition variable
3416  * @mutex: a mutex, currently held
3417  *
3418  * Tries to become the owner of the specified context,
3419  * as with g_main_context_acquire(). But if another thread
3420  * is the owner, atomically drop @mutex and wait on @cond until
3421  * that owner releases ownership or until @cond is signaled, then
3422  * try again (once) to become the owner.
3423  *
3424  * Returns: %TRUE if the operation succeeded, and
3425  *   this thread is now the owner of @context.
3426  * Deprecated: 2.58: Use g_main_context_is_owner() and separate locking instead.
3427  */
3428 gboolean
3429 g_main_context_wait (GMainContext *context,
3430                      GCond        *cond,
3431                      GMutex       *mutex)
3432 {
3433   if (context == NULL)
3434     context = g_main_context_default ();
3435 
3436   if (G_UNLIKELY (cond != &amp;context-&gt;cond || mutex != &amp;context-&gt;mutex))
3437     {
3438       static gboolean warned;
3439 
3440       if (!warned)
3441         {
3442           g_critical (&quot;WARNING!! g_main_context_wait() will be removed in a future release.  &quot;
3443                       &quot;If you see this message, please file a bug immediately.&quot;);
3444           warned = TRUE;
3445         }
3446     }
3447 
3448   return g_main_context_wait_internal (context, cond, mutex);
3449 }
3450 
3451 /**
3452  * g_main_context_prepare:
3453  * @context: a #GMainContext
3454  * @priority: (out) (optional): location to store priority of highest priority
3455  *            source already ready.
3456  *
3457  * Prepares to poll sources within a main loop. The resulting information
3458  * for polling is determined by calling g_main_context_query ().
3459  *
3460  * You must have successfully acquired the context with
3461  * g_main_context_acquire() before you may call this function.
3462  *
3463  * Returns: %TRUE if some source is ready to be dispatched
3464  *               prior to polling.
3465  **/
3466 gboolean
3467 g_main_context_prepare (GMainContext *context,
3468       gint         *priority)
3469 {
3470   guint i;
3471   gint n_ready = 0;
3472   gint current_priority = G_MAXINT;
3473   GSource *source;
3474   GSourceIter iter;
3475 
3476   if (context == NULL)
3477     context = g_main_context_default ();
3478 
3479   LOCK_CONTEXT (context);
3480 
3481   context-&gt;time_is_fresh = FALSE;
3482 
3483   if (context-&gt;in_check_or_prepare)
3484     {
3485       g_warning (&quot;g_main_context_prepare() called recursively from within a source&#39;s check() or &quot;
3486      &quot;prepare() member.&quot;);
3487       UNLOCK_CONTEXT (context);
3488       return FALSE;
3489     }
3490 
3491   TRACE (GLIB_MAIN_CONTEXT_BEFORE_PREPARE (context));
3492 
3493 #if 0
3494   /* If recursing, finish up current dispatch, before starting over */
3495   if (context-&gt;pending_dispatches)
3496     {
3497       if (dispatch)
3498   g_main_dispatch (context, &amp;current_time);
3499 
3500       UNLOCK_CONTEXT (context);
3501       return TRUE;
3502     }
3503 #endif
3504 
3505   /* If recursing, clear list of pending dispatches */
3506 
3507   for (i = 0; i &lt; context-&gt;pending_dispatches-&gt;len; i++)
3508     {
3509       if (context-&gt;pending_dispatches-&gt;pdata[i])
3510         g_source_unref_internal ((GSource *)context-&gt;pending_dispatches-&gt;pdata[i], context, TRUE);
3511     }
3512   g_ptr_array_set_size (context-&gt;pending_dispatches, 0);
3513 
3514   /* Prepare all sources */
3515 
3516   context-&gt;timeout = -1;
3517 
3518   g_source_iter_init (&amp;iter, context, TRUE);
3519   while (g_source_iter_next (&amp;iter, &amp;source))
3520     {
3521       gint source_timeout = -1;
3522 
3523       if (SOURCE_DESTROYED (source) || SOURCE_BLOCKED (source))
3524   continue;
3525       if ((n_ready &gt; 0) &amp;&amp; (source-&gt;priority &gt; current_priority))
3526   break;
3527 
3528       if (!(source-&gt;flags &amp; G_SOURCE_READY))
3529   {
3530     gboolean result;
3531     gboolean (* prepare) (GSource  *source,
3532                                 gint     *timeout);
3533 
3534           prepare = source-&gt;source_funcs-&gt;prepare;
3535 
3536           if (prepare)
3537             {
3538               context-&gt;in_check_or_prepare++;
3539               UNLOCK_CONTEXT (context);
3540 
3541               result = (* prepare) (source, &amp;source_timeout);
3542               TRACE (GLIB_MAIN_AFTER_PREPARE (source, prepare, source_timeout));
3543 
3544               LOCK_CONTEXT (context);
3545               context-&gt;in_check_or_prepare--;
3546             }
3547           else
3548             {
3549               source_timeout = -1;
3550               result = FALSE;
3551             }
3552 
3553           if (result == FALSE &amp;&amp; source-&gt;priv-&gt;ready_time != -1)
3554             {
3555               if (!context-&gt;time_is_fresh)
3556                 {
3557                   context-&gt;time = g_get_monotonic_time ();
3558                   context-&gt;time_is_fresh = TRUE;
3559                 }
3560 
3561               if (source-&gt;priv-&gt;ready_time &lt;= context-&gt;time)
3562                 {
3563                   source_timeout = 0;
3564                   result = TRUE;
3565                 }
3566               else
3567                 {
3568                   gint64 timeout;
3569 
3570                   /* rounding down will lead to spinning, so always round up */
3571                   timeout = (source-&gt;priv-&gt;ready_time - context-&gt;time + 999) / 1000;
3572 
3573                   if (source_timeout &lt; 0 || timeout &lt; source_timeout)
3574                     source_timeout = MIN (timeout, G_MAXINT);
3575                 }
3576             }
3577 
3578     if (result)
3579       {
3580         GSource *ready_source = source;
3581 
3582         while (ready_source)
3583     {
3584       ready_source-&gt;flags |= G_SOURCE_READY;
3585       ready_source = ready_source-&gt;priv-&gt;parent_source;
3586     }
3587       }
3588   }
3589 
3590       if (source-&gt;flags &amp; G_SOURCE_READY)
3591   {
3592     n_ready++;
3593     current_priority = source-&gt;priority;
3594     context-&gt;timeout = 0;
3595   }
3596 
3597       if (source_timeout &gt;= 0)
3598   {
3599     if (context-&gt;timeout &lt; 0)
3600       context-&gt;timeout = source_timeout;
3601     else
3602       context-&gt;timeout = MIN (context-&gt;timeout, source_timeout);
3603   }
3604     }
3605   g_source_iter_clear (&amp;iter);
3606 
3607   TRACE (GLIB_MAIN_CONTEXT_AFTER_PREPARE (context, current_priority, n_ready));
3608 
3609   UNLOCK_CONTEXT (context);
3610 
3611   if (priority)
3612     *priority = current_priority;
3613 
3614   return (n_ready &gt; 0);
3615 }
3616 
3617 /**
3618  * g_main_context_query:
3619  * @context: a #GMainContext
3620  * @max_priority: maximum priority source to check
3621  * @timeout_: (out): location to store timeout to be used in polling
3622  * @fds: (out caller-allocates) (array length=n_fds): location to
3623  *       store #GPollFD records that need to be polled.
3624  * @n_fds: (in): length of @fds.
3625  *
3626  * Determines information necessary to poll this main loop.
3627  *
3628  * You must have successfully acquired the context with
3629  * g_main_context_acquire() before you may call this function.
3630  *
3631  * Returns: the number of records actually stored in @fds,
3632  *   or, if more than @n_fds records need to be stored, the number
3633  *   of records that need to be stored.
3634  **/
3635 gint
3636 g_main_context_query (GMainContext *context,
3637           gint          max_priority,
3638           gint         *timeout,
3639           GPollFD      *fds,
3640           gint          n_fds)
3641 {
3642   gint n_poll;
3643   GPollRec *pollrec, *lastpollrec;
3644   gushort events;
3645 
3646   LOCK_CONTEXT (context);
3647 
3648   TRACE (GLIB_MAIN_CONTEXT_BEFORE_QUERY (context, max_priority));
3649 
3650   n_poll = 0;
3651   lastpollrec = NULL;
3652   for (pollrec = context-&gt;poll_records; pollrec; pollrec = pollrec-&gt;next)
3653     {
3654       if (pollrec-&gt;priority &gt; max_priority)
3655         continue;
3656 
3657       /* In direct contradiction to the Unix98 spec, IRIX runs into
3658        * difficulty if you pass in POLLERR, POLLHUP or POLLNVAL
3659        * flags in the events field of the pollfd while it should
3660        * just ignoring them. So we mask them out here.
3661        */
3662       events = pollrec-&gt;fd-&gt;events &amp; ~(G_IO_ERR|G_IO_HUP|G_IO_NVAL);
3663 
3664       if (lastpollrec &amp;&amp; pollrec-&gt;fd-&gt;fd == lastpollrec-&gt;fd-&gt;fd)
3665         {
3666           if (n_poll - 1 &lt; n_fds)
3667             fds[n_poll - 1].events |= events;
3668         }
3669       else
3670         {
3671           if (n_poll &lt; n_fds)
3672             {
3673               fds[n_poll].fd = pollrec-&gt;fd-&gt;fd;
3674               fds[n_poll].events = events;
3675               fds[n_poll].revents = 0;
3676             }
3677 
3678           n_poll++;
3679         }
3680 
3681       lastpollrec = pollrec;
3682     }
3683 
3684   context-&gt;poll_changed = FALSE;
3685 
3686   if (timeout)
3687     {
3688       *timeout = context-&gt;timeout;
3689       if (*timeout != 0)
3690         context-&gt;time_is_fresh = FALSE;
3691     }
3692 
3693   TRACE (GLIB_MAIN_CONTEXT_AFTER_QUERY (context, context-&gt;timeout,
3694                                         fds, n_poll));
3695 
3696   UNLOCK_CONTEXT (context);
3697 
3698   return n_poll;
3699 }
3700 
3701 /**
3702  * g_main_context_check:
3703  * @context: a #GMainContext
3704  * @max_priority: the maximum numerical priority of sources to check
3705  * @fds: (array length=n_fds): array of #GPollFD&#39;s that was passed to
3706  *       the last call to g_main_context_query()
3707  * @n_fds: return value of g_main_context_query()
3708  *
3709  * Passes the results of polling back to the main loop.
3710  *
3711  * You must have successfully acquired the context with
3712  * g_main_context_acquire() before you may call this function.
3713  *
3714  * Returns: %TRUE if some sources are ready to be dispatched.
3715  **/
3716 gboolean
3717 g_main_context_check (GMainContext *context,
3718           gint          max_priority,
3719           GPollFD      *fds,
3720           gint          n_fds)
3721 {
3722   GSource *source;
3723   GSourceIter iter;
3724   GPollRec *pollrec;
3725   gint n_ready = 0;
3726   gint i;
3727 
3728   LOCK_CONTEXT (context);
3729 
3730   if (context-&gt;in_check_or_prepare)
3731     {
3732       g_warning (&quot;g_main_context_check() called recursively from within a source&#39;s check() or &quot;
3733      &quot;prepare() member.&quot;);
3734       UNLOCK_CONTEXT (context);
3735       return FALSE;
3736     }
3737 
3738   TRACE (GLIB_MAIN_CONTEXT_BEFORE_CHECK (context, max_priority, fds, n_fds));
3739 
3740   for (i = 0; i &lt; n_fds; i++)
3741     {
3742       if (fds[i].fd == context-&gt;wake_up_rec.fd)
3743         {
3744           if (fds[i].revents)
3745             {
3746               TRACE (GLIB_MAIN_CONTEXT_WAKEUP_ACKNOWLEDGE (context));
3747               g_wakeup_acknowledge (context-&gt;wakeup);
3748             }
3749           break;
3750         }
3751     }
3752 
3753   /* If the set of poll file descriptors changed, bail out
3754    * and let the main loop rerun
3755    */
3756   if (context-&gt;poll_changed)
3757     {
3758       TRACE (GLIB_MAIN_CONTEXT_AFTER_CHECK (context, 0));
3759 
3760       UNLOCK_CONTEXT (context);
3761       return FALSE;
3762     }
3763 
3764   pollrec = context-&gt;poll_records;
3765   i = 0;
3766   while (pollrec &amp;&amp; i &lt; n_fds)
3767     {
3768       while (pollrec &amp;&amp; pollrec-&gt;fd-&gt;fd == fds[i].fd)
3769         {
3770           if (pollrec-&gt;priority &lt;= max_priority)
3771             {
3772               pollrec-&gt;fd-&gt;revents =
3773                 fds[i].revents &amp; (pollrec-&gt;fd-&gt;events | G_IO_ERR | G_IO_HUP | G_IO_NVAL);
3774             }
3775           pollrec = pollrec-&gt;next;
3776         }
3777 
3778       i++;
3779     }
3780 
3781   g_source_iter_init (&amp;iter, context, TRUE);
3782   while (g_source_iter_next (&amp;iter, &amp;source))
3783     {
3784       if (SOURCE_DESTROYED (source) || SOURCE_BLOCKED (source))
3785   continue;
3786       if ((n_ready &gt; 0) &amp;&amp; (source-&gt;priority &gt; max_priority))
3787   break;
3788 
3789       if (!(source-&gt;flags &amp; G_SOURCE_READY))
3790   {
3791           gboolean result;
3792           gboolean (* check) (GSource *source);
3793 
3794           check = source-&gt;source_funcs-&gt;check;
3795 
3796           if (check)
3797             {
3798               /* If the check function is set, call it. */
3799               context-&gt;in_check_or_prepare++;
3800               UNLOCK_CONTEXT (context);
3801 
3802               result = (* check) (source);
3803 
3804               TRACE (GLIB_MAIN_AFTER_CHECK (source, check, result));
3805 
3806               LOCK_CONTEXT (context);
3807               context-&gt;in_check_or_prepare--;
3808             }
3809           else
3810             result = FALSE;
3811 
3812           if (result == FALSE)
3813             {
3814               GSList *tmp_list;
3815 
3816               /* If not already explicitly flagged ready by -&gt;check()
3817                * (or if we have no check) then we can still be ready if
3818                * any of our fds poll as ready.
3819                */
3820               for (tmp_list = source-&gt;priv-&gt;fds; tmp_list; tmp_list = tmp_list-&gt;next)
3821                 {
3822                   GPollFD *pollfd = tmp_list-&gt;data;
3823 
3824                   if (pollfd-&gt;revents)
3825                     {
3826                       result = TRUE;
3827                       break;
3828                     }
3829                 }
3830             }
3831 
3832           if (result == FALSE &amp;&amp; source-&gt;priv-&gt;ready_time != -1)
3833             {
3834               if (!context-&gt;time_is_fresh)
3835                 {
3836                   context-&gt;time = g_get_monotonic_time ();
3837                   context-&gt;time_is_fresh = TRUE;
3838                 }
3839 
3840               if (source-&gt;priv-&gt;ready_time &lt;= context-&gt;time)
3841                 result = TRUE;
3842             }
3843 
3844     if (result)
3845       {
3846         GSource *ready_source = source;
3847 
3848         while (ready_source)
3849     {
3850       ready_source-&gt;flags |= G_SOURCE_READY;
3851       ready_source = ready_source-&gt;priv-&gt;parent_source;
3852     }
3853       }
3854   }
3855 
3856       if (source-&gt;flags &amp; G_SOURCE_READY)
3857   {
3858           g_source_ref (source);
3859     g_ptr_array_add (context-&gt;pending_dispatches, source);
3860 
3861     n_ready++;
3862 
3863           /* never dispatch sources with less priority than the first
3864            * one we choose to dispatch
3865            */
3866           max_priority = source-&gt;priority;
3867   }
3868     }
3869   g_source_iter_clear (&amp;iter);
3870 
3871   TRACE (GLIB_MAIN_CONTEXT_AFTER_CHECK (context, n_ready));
3872 
3873   UNLOCK_CONTEXT (context);
3874 
3875   return n_ready &gt; 0;
3876 }
3877 
3878 /**
3879  * g_main_context_dispatch:
3880  * @context: a #GMainContext
3881  *
3882  * Dispatches all pending sources.
3883  *
3884  * You must have successfully acquired the context with
3885  * g_main_context_acquire() before you may call this function.
3886  **/
3887 void
3888 g_main_context_dispatch (GMainContext *context)
3889 {
3890   LOCK_CONTEXT (context);
3891 
3892   TRACE (GLIB_MAIN_CONTEXT_BEFORE_DISPATCH (context));
3893 
3894   if (context-&gt;pending_dispatches-&gt;len &gt; 0)
3895     {
3896       g_main_dispatch (context);
3897     }
3898 
3899   TRACE (GLIB_MAIN_CONTEXT_AFTER_DISPATCH (context));
3900 
3901   UNLOCK_CONTEXT (context);
3902 }
3903 
3904 /* HOLDS context lock */
3905 static gboolean
3906 g_main_context_iterate (GMainContext *context,
3907       gboolean      block,
3908       gboolean      dispatch,
3909       GThread      *self)
3910 {
3911   gint max_priority;
3912   gint timeout;
3913   gboolean some_ready;
3914   gint nfds, allocated_nfds;
3915   GPollFD *fds = NULL;
3916 
3917   UNLOCK_CONTEXT (context);
3918 
3919   if (!g_main_context_acquire (context))
3920     {
3921       gboolean got_ownership;
3922 
3923       LOCK_CONTEXT (context);
3924 
3925       if (!block)
3926   return FALSE;
3927 
3928       got_ownership = g_main_context_wait_internal (context,
3929                                                     &amp;context-&gt;cond,
3930                                                     &amp;context-&gt;mutex);
3931 
3932       if (!got_ownership)
3933   return FALSE;
3934     }
3935   else
3936     LOCK_CONTEXT (context);
3937 
3938   if (!context-&gt;cached_poll_array)
3939     {
3940       context-&gt;cached_poll_array_size = context-&gt;n_poll_records;
3941       context-&gt;cached_poll_array = g_new (GPollFD, context-&gt;n_poll_records);
3942     }
3943 
3944   allocated_nfds = context-&gt;cached_poll_array_size;
3945   fds = context-&gt;cached_poll_array;
3946 
3947   UNLOCK_CONTEXT (context);
3948 
3949   g_main_context_prepare (context, &amp;max_priority);
3950 
3951   while ((nfds = g_main_context_query (context, max_priority, &amp;timeout, fds,
3952                allocated_nfds)) &gt; allocated_nfds)
3953     {
3954       LOCK_CONTEXT (context);
3955       g_free (fds);
3956       context-&gt;cached_poll_array_size = allocated_nfds = nfds;
3957       context-&gt;cached_poll_array = fds = g_new (GPollFD, nfds);
3958       UNLOCK_CONTEXT (context);
3959 #ifdef GSTREAMER_LITE
3960       if (fds == NULL) {
3961         return FALSE;
3962       }
3963 #endif // GSTREAMER_LITE
3964     }
3965 
3966   if (!block)
3967     timeout = 0;
3968 
3969   g_main_context_poll (context, timeout, max_priority, fds, nfds);
3970 
3971   some_ready = g_main_context_check (context, max_priority, fds, nfds);
3972 
3973   if (dispatch)
3974     g_main_context_dispatch (context);
3975 
3976   g_main_context_release (context);
3977 
3978   LOCK_CONTEXT (context);
3979 
3980   return some_ready;
3981 }
3982 
3983 /**
3984  * g_main_context_pending:
3985  * @context: (nullable): a #GMainContext (if %NULL, the default context will be used)
3986  *
3987  * Checks if any sources have pending events for the given context.
3988  *
3989  * Returns: %TRUE if events are pending.
3990  **/
3991 gboolean
3992 g_main_context_pending (GMainContext *context)
3993 {
3994   gboolean retval;
3995 
3996   if (!context)
3997     context = g_main_context_default();
3998 
3999   LOCK_CONTEXT (context);
4000   retval = g_main_context_iterate (context, FALSE, FALSE, G_THREAD_SELF);
4001   UNLOCK_CONTEXT (context);
4002 
4003   return retval;
4004 }
4005 
4006 /**
4007  * g_main_context_iteration:
4008  * @context: (nullable): a #GMainContext (if %NULL, the default context will be used)
4009  * @may_block: whether the call may block.
4010  *
4011  * Runs a single iteration for the given main loop. This involves
4012  * checking to see if any event sources are ready to be processed,
4013  * then if no events sources are ready and @may_block is %TRUE, waiting
4014  * for a source to become ready, then dispatching the highest priority
4015  * events sources that are ready. Otherwise, if @may_block is %FALSE
4016  * sources are not waited to become ready, only those highest priority
4017  * events sources will be dispatched (if any), that are ready at this
4018  * given moment without further waiting.
4019  *
4020  * Note that even when @may_block is %TRUE, it is still possible for
4021  * g_main_context_iteration() to return %FALSE, since the wait may
4022  * be interrupted for other reasons than an event source becoming ready.
4023  *
4024  * Returns: %TRUE if events were dispatched.
4025  **/
4026 gboolean
4027 g_main_context_iteration (GMainContext *context, gboolean may_block)
4028 {
4029   gboolean retval;
4030 
4031   if (!context)
4032     context = g_main_context_default();
4033 
4034   LOCK_CONTEXT (context);
4035   retval = g_main_context_iterate (context, may_block, TRUE, G_THREAD_SELF);
4036   UNLOCK_CONTEXT (context);
4037 
4038   return retval;
4039 }
4040 
4041 /**
4042  * g_main_loop_new:
4043  * @context: (nullable): a #GMainContext  (if %NULL, the default context will be used).
4044  * @is_running: set to %TRUE to indicate that the loop is running. This
4045  * is not very important since calling g_main_loop_run() will set this to
4046  * %TRUE anyway.
4047  *
4048  * Creates a new #GMainLoop structure.
4049  *
4050  * Returns: a new #GMainLoop.
4051  **/
4052 GMainLoop *
4053 g_main_loop_new (GMainContext *context,
4054      gboolean      is_running)
4055 {
4056   GMainLoop *loop;
4057 
4058   if (!context)
4059     context = g_main_context_default();
4060 
4061   g_main_context_ref (context);
4062 
4063   loop = g_new0 (GMainLoop, 1);
4064   loop-&gt;context = context;
4065   loop-&gt;is_running = is_running != FALSE;
4066   loop-&gt;ref_count = 1;
4067 
4068   TRACE (GLIB_MAIN_LOOP_NEW (loop, context));
4069 
4070   return loop;
4071 }
4072 
4073 /**
4074  * g_main_loop_ref:
4075  * @loop: a #GMainLoop
4076  *
4077  * Increases the reference count on a #GMainLoop object by one.
4078  *
4079  * Returns: @loop
4080  **/
4081 GMainLoop *
4082 g_main_loop_ref (GMainLoop *loop)
4083 {
4084   g_return_val_if_fail (loop != NULL, NULL);
4085   g_return_val_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0, NULL);
4086 
4087   g_atomic_int_inc (&amp;loop-&gt;ref_count);
4088 
4089   return loop;
4090 }
4091 
4092 /**
4093  * g_main_loop_unref:
4094  * @loop: a #GMainLoop
4095  *
4096  * Decreases the reference count on a #GMainLoop object by one. If
4097  * the result is zero, free the loop and free all associated memory.
4098  **/
4099 void
4100 g_main_loop_unref (GMainLoop *loop)
4101 {
4102   g_return_if_fail (loop != NULL);
4103   g_return_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0);
4104 
4105   if (!g_atomic_int_dec_and_test (&amp;loop-&gt;ref_count))
4106     return;
4107 
4108   g_main_context_unref (loop-&gt;context);
4109   g_free (loop);
4110 }
4111 
4112 /**
4113  * g_main_loop_run:
4114  * @loop: a #GMainLoop
4115  *
4116  * Runs a main loop until g_main_loop_quit() is called on the loop.
4117  * If this is called for the thread of the loop&#39;s #GMainContext,
4118  * it will process events from the loop, otherwise it will
4119  * simply wait.
4120  **/
4121 void
4122 g_main_loop_run (GMainLoop *loop)
4123 {
4124   GThread *self = G_THREAD_SELF;
4125 
4126   g_return_if_fail (loop != NULL);
4127   g_return_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0);
4128 
4129   if (!g_main_context_acquire (loop-&gt;context))
4130     {
4131       gboolean got_ownership = FALSE;
4132 
4133       /* Another thread owns this context */
4134       LOCK_CONTEXT (loop-&gt;context);
4135 
4136       g_atomic_int_inc (&amp;loop-&gt;ref_count);
4137       g_atomic_int_set (&amp;loop-&gt;is_running, TRUE);
4138 
4139       while (g_atomic_int_get (&amp;loop-&gt;is_running) &amp;&amp; !got_ownership)
4140         got_ownership = g_main_context_wait_internal (loop-&gt;context,
4141                                                       &amp;loop-&gt;context-&gt;cond,
4142                                                       &amp;loop-&gt;context-&gt;mutex);
4143 
4144       if (!g_atomic_int_get (&amp;loop-&gt;is_running))
4145   {
4146     UNLOCK_CONTEXT (loop-&gt;context);
4147     if (got_ownership)
4148       g_main_context_release (loop-&gt;context);
4149     g_main_loop_unref (loop);
4150     return;
4151   }
4152 
4153       g_assert (got_ownership);
4154     }
4155   else
4156     LOCK_CONTEXT (loop-&gt;context);
4157 
4158   if (loop-&gt;context-&gt;in_check_or_prepare)
4159     {
4160       g_warning (&quot;g_main_loop_run(): called recursively from within a source&#39;s &quot;
4161      &quot;check() or prepare() member, iteration not possible.&quot;);
4162       return;
4163     }
4164 
4165   g_atomic_int_inc (&amp;loop-&gt;ref_count);
4166   g_atomic_int_set (&amp;loop-&gt;is_running, TRUE);
4167   while (g_atomic_int_get (&amp;loop-&gt;is_running))
4168     g_main_context_iterate (loop-&gt;context, TRUE, TRUE, self);
4169 
4170   UNLOCK_CONTEXT (loop-&gt;context);
4171 
4172   g_main_context_release (loop-&gt;context);
4173 
4174   g_main_loop_unref (loop);
4175 }
4176 
4177 /**
4178  * g_main_loop_quit:
4179  * @loop: a #GMainLoop
4180  *
4181  * Stops a #GMainLoop from running. Any calls to g_main_loop_run()
4182  * for the loop will return.
4183  *
4184  * Note that sources that have already been dispatched when
4185  * g_main_loop_quit() is called will still be executed.
4186  **/
4187 void
4188 g_main_loop_quit (GMainLoop *loop)
4189 {
4190   g_return_if_fail (loop != NULL);
4191   g_return_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0);
4192 
4193   LOCK_CONTEXT (loop-&gt;context);
4194   g_atomic_int_set (&amp;loop-&gt;is_running, FALSE);
4195   g_wakeup_signal (loop-&gt;context-&gt;wakeup);
4196 
4197   g_cond_broadcast (&amp;loop-&gt;context-&gt;cond);
4198 
4199   UNLOCK_CONTEXT (loop-&gt;context);
4200 
4201   TRACE (GLIB_MAIN_LOOP_QUIT (loop));
4202 }
4203 
4204 /**
4205  * g_main_loop_is_running:
4206  * @loop: a #GMainLoop.
4207  *
4208  * Checks to see if the main loop is currently being run via g_main_loop_run().
4209  *
4210  * Returns: %TRUE if the mainloop is currently being run.
4211  **/
4212 gboolean
4213 g_main_loop_is_running (GMainLoop *loop)
4214 {
4215   g_return_val_if_fail (loop != NULL, FALSE);
4216   g_return_val_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0, FALSE);
4217 
4218   return g_atomic_int_get (&amp;loop-&gt;is_running);
4219 }
4220 
4221 /**
4222  * g_main_loop_get_context:
4223  * @loop: a #GMainLoop.
4224  *
4225  * Returns the #GMainContext of @loop.
4226  *
4227  * Returns: (transfer none): the #GMainContext of @loop
4228  **/
4229 GMainContext *
4230 g_main_loop_get_context (GMainLoop *loop)
4231 {
4232   g_return_val_if_fail (loop != NULL, NULL);
4233   g_return_val_if_fail (g_atomic_int_get (&amp;loop-&gt;ref_count) &gt; 0, NULL);
4234 
4235   return loop-&gt;context;
4236 }
4237 
4238 /* HOLDS: context&#39;s lock */
4239 static void
4240 g_main_context_poll (GMainContext *context,
4241          gint          timeout,
4242          gint          priority,
4243          GPollFD      *fds,
4244          gint          n_fds)
4245 {
4246 #ifdef  G_MAIN_POLL_DEBUG
4247   GTimer *poll_timer;
4248   GPollRec *pollrec;
4249   gint i;
4250 #endif
4251 
4252   GPollFunc poll_func;
4253 
4254   if (n_fds || timeout != 0)
4255     {
4256       int ret, errsv;
4257 
4258 #ifdef  G_MAIN_POLL_DEBUG
4259       poll_timer = NULL;
4260       if (_g_main_poll_debug)
4261   {
4262     g_print (&quot;polling context=%p n=%d timeout=%d\n&quot;,
4263        context, n_fds, timeout);
4264     poll_timer = g_timer_new ();
4265   }
4266 #endif
4267 
4268       LOCK_CONTEXT (context);
4269 
4270       poll_func = context-&gt;poll_func;
4271 
4272       UNLOCK_CONTEXT (context);
4273       ret = (*poll_func) (fds, n_fds, timeout);
4274       errsv = errno;
4275       if (ret &lt; 0 &amp;&amp; errsv != EINTR)
4276   {
4277 #ifndef G_OS_WIN32
4278     g_warning (&quot;poll(2) failed due to: %s.&quot;,
4279          g_strerror (errsv));
4280 #else
4281     /* If g_poll () returns -1, it has already called g_warning() */
4282 #endif
4283   }
4284 
4285 #ifdef  G_MAIN_POLL_DEBUG
4286       if (_g_main_poll_debug)
4287   {
4288     LOCK_CONTEXT (context);
4289 
4290     g_print (&quot;g_main_poll(%d) timeout: %d - elapsed %12.10f seconds&quot;,
4291        n_fds,
4292        timeout,
4293        g_timer_elapsed (poll_timer, NULL));
4294     g_timer_destroy (poll_timer);
4295     pollrec = context-&gt;poll_records;
4296 
4297     while (pollrec != NULL)
4298       {
4299         i = 0;
4300         while (i &lt; n_fds)
4301     {
4302       if (fds[i].fd == pollrec-&gt;fd-&gt;fd &amp;&amp;
4303           pollrec-&gt;fd-&gt;events &amp;&amp;
4304           fds[i].revents)
4305         {
4306           g_print (&quot; [&quot; G_POLLFD_FORMAT &quot; :&quot;, fds[i].fd);
4307           if (fds[i].revents &amp; G_IO_IN)
4308       g_print (&quot;i&quot;);
4309           if (fds[i].revents &amp; G_IO_OUT)
4310       g_print (&quot;o&quot;);
4311           if (fds[i].revents &amp; G_IO_PRI)
4312       g_print (&quot;p&quot;);
4313           if (fds[i].revents &amp; G_IO_ERR)
4314       g_print (&quot;e&quot;);
4315           if (fds[i].revents &amp; G_IO_HUP)
4316       g_print (&quot;h&quot;);
4317           if (fds[i].revents &amp; G_IO_NVAL)
4318       g_print (&quot;n&quot;);
4319           g_print (&quot;]&quot;);
4320         }
4321       i++;
4322     }
4323         pollrec = pollrec-&gt;next;
4324       }
4325     g_print (&quot;\n&quot;);
4326 
4327     UNLOCK_CONTEXT (context);
4328   }
4329 #endif
4330     } /* if (n_fds || timeout != 0) */
4331 }
4332 
4333 /**
4334  * g_main_context_add_poll:
4335  * @context: (nullable): a #GMainContext (or %NULL for the default context)
4336  * @fd: a #GPollFD structure holding information about a file
4337  *      descriptor to watch.
4338  * @priority: the priority for this file descriptor which should be
4339  *      the same as the priority used for g_source_attach() to ensure that the
4340  *      file descriptor is polled whenever the results may be needed.
4341  *
4342  * Adds a file descriptor to the set of file descriptors polled for
4343  * this context. This will very seldom be used directly. Instead
4344  * a typical event source will use g_source_add_unix_fd() instead.
4345  **/
4346 void
4347 g_main_context_add_poll (GMainContext *context,
4348        GPollFD      *fd,
4349        gint          priority)
4350 {
4351   if (!context)
4352     context = g_main_context_default ();
4353 
4354   g_return_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0);
4355   g_return_if_fail (fd);
4356 
4357   LOCK_CONTEXT (context);
4358   g_main_context_add_poll_unlocked (context, priority, fd);
4359   UNLOCK_CONTEXT (context);
4360 }
4361 
4362 /* HOLDS: main_loop_lock */
4363 static void
4364 g_main_context_add_poll_unlocked (GMainContext *context,
4365           gint          priority,
4366           GPollFD      *fd)
4367 {
4368   GPollRec *prevrec, *nextrec;
4369   GPollRec *newrec = g_slice_new (GPollRec);
4370 #ifdef GSTREAMER_LITE
4371   if (newrec == NULL) {
4372     return;
4373   }
4374 #endif // GSTREAMER_LITE
4375 
4376   /* This file descriptor may be checked before we ever poll */
4377   fd-&gt;revents = 0;
4378   newrec-&gt;fd = fd;
4379   newrec-&gt;priority = priority;
4380 
4381   prevrec = NULL;
4382   nextrec = context-&gt;poll_records;
4383   while (nextrec)
4384     {
4385       if (nextrec-&gt;fd-&gt;fd &gt; fd-&gt;fd)
4386         break;
4387       prevrec = nextrec;
4388       nextrec = nextrec-&gt;next;
4389     }
4390 
4391   if (prevrec)
4392     prevrec-&gt;next = newrec;
4393   else
4394     context-&gt;poll_records = newrec;
4395 
4396   newrec-&gt;prev = prevrec;
4397   newrec-&gt;next = nextrec;
4398 
4399   if (nextrec)
4400     nextrec-&gt;prev = newrec;
4401 
4402   context-&gt;n_poll_records++;
4403 
4404   context-&gt;poll_changed = TRUE;
4405 
4406   /* Now wake up the main loop if it is waiting in the poll() */
4407   g_wakeup_signal (context-&gt;wakeup);
4408 }
4409 
4410 /**
4411  * g_main_context_remove_poll:
4412  * @context:a #GMainContext
4413  * @fd: a #GPollFD descriptor previously added with g_main_context_add_poll()
4414  *
4415  * Removes file descriptor from the set of file descriptors to be
4416  * polled for a particular context.
4417  **/
4418 void
4419 g_main_context_remove_poll (GMainContext *context,
4420           GPollFD      *fd)
4421 {
4422   if (!context)
4423     context = g_main_context_default ();
4424 
4425   g_return_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0);
4426   g_return_if_fail (fd);
4427 
4428   LOCK_CONTEXT (context);
4429   g_main_context_remove_poll_unlocked (context, fd);
4430   UNLOCK_CONTEXT (context);
4431 }
4432 
4433 static void
4434 g_main_context_remove_poll_unlocked (GMainContext *context,
4435              GPollFD      *fd)
4436 {
4437   GPollRec *pollrec, *prevrec, *nextrec;
4438 
4439   prevrec = NULL;
4440   pollrec = context-&gt;poll_records;
4441 
4442   while (pollrec)
4443     {
4444       nextrec = pollrec-&gt;next;
4445       if (pollrec-&gt;fd == fd)
4446   {
4447     if (prevrec != NULL)
4448       prevrec-&gt;next = nextrec;
4449     else
4450       context-&gt;poll_records = nextrec;
4451 
4452     if (nextrec != NULL)
4453       nextrec-&gt;prev = prevrec;
4454 
4455     g_slice_free (GPollRec, pollrec);
4456 
4457     context-&gt;n_poll_records--;
4458     break;
4459   }
4460       prevrec = pollrec;
4461       pollrec = nextrec;
4462     }
4463 
4464   context-&gt;poll_changed = TRUE;
4465 
4466   /* Now wake up the main loop if it is waiting in the poll() */
4467   g_wakeup_signal (context-&gt;wakeup);
4468 }
4469 
4470 /**
4471  * g_source_get_current_time:
4472  * @source:  a #GSource
4473  * @timeval: #GTimeVal structure in which to store current time.
4474  *
4475  * This function ignores @source and is otherwise the same as
4476  * g_get_current_time().
4477  *
4478  * Deprecated: 2.28: use g_source_get_time() instead
4479  **/
4480 G_GNUC_BEGIN_IGNORE_DEPRECATIONS
4481 void
4482 g_source_get_current_time (GSource  *source,
4483          GTimeVal *timeval)
4484 {
4485   g_get_current_time (timeval);
4486 }
4487 G_GNUC_END_IGNORE_DEPRECATIONS
4488 
4489 /**
4490  * g_source_get_time:
4491  * @source: a #GSource
4492  *
4493  * Gets the time to be used when checking this source. The advantage of
4494  * calling this function over calling g_get_monotonic_time() directly is
4495  * that when checking multiple sources, GLib can cache a single value
4496  * instead of having to repeatedly get the system monotonic time.
4497  *
4498  * The time here is the system monotonic time, if available, or some
4499  * other reasonable alternative otherwise.  See g_get_monotonic_time().
4500  *
4501  * Returns: the monotonic time in microseconds
4502  *
4503  * Since: 2.28
4504  **/
4505 gint64
4506 g_source_get_time (GSource *source)
4507 {
4508   GMainContext *context;
4509   gint64 result;
4510 
4511   g_return_val_if_fail (source-&gt;context != NULL, 0);
4512 
4513   context = source-&gt;context;
4514 
4515   LOCK_CONTEXT (context);
4516 
4517   if (!context-&gt;time_is_fresh)
4518     {
4519       context-&gt;time = g_get_monotonic_time ();
4520       context-&gt;time_is_fresh = TRUE;
4521     }
4522 
4523   result = context-&gt;time;
4524 
4525   UNLOCK_CONTEXT (context);
4526 
4527   return result;
4528 }
4529 
4530 /**
4531  * g_main_context_set_poll_func:
4532  * @context: a #GMainContext
4533  * @func: the function to call to poll all file descriptors
4534  *
4535  * Sets the function to use to handle polling of file descriptors. It
4536  * will be used instead of the poll() system call
4537  * (or GLib&#39;s replacement function, which is used where
4538  * poll() isn&#39;t available).
4539  *
4540  * This function could possibly be used to integrate the GLib event
4541  * loop with an external event loop.
4542  **/
4543 void
4544 g_main_context_set_poll_func (GMainContext *context,
4545             GPollFunc     func)
4546 {
4547   if (!context)
4548     context = g_main_context_default ();
4549 
4550   g_return_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0);
4551 
4552   LOCK_CONTEXT (context);
4553 
4554   if (func)
4555     context-&gt;poll_func = func;
4556   else
4557     context-&gt;poll_func = g_poll;
4558 
4559   UNLOCK_CONTEXT (context);
4560 }
4561 
4562 /**
4563  * g_main_context_get_poll_func:
4564  * @context: a #GMainContext
4565  *
4566  * Gets the poll function set by g_main_context_set_poll_func().
4567  *
4568  * Returns: the poll function
4569  **/
4570 GPollFunc
4571 g_main_context_get_poll_func (GMainContext *context)
4572 {
4573   GPollFunc result;
4574 
4575   if (!context)
4576     context = g_main_context_default ();
4577 
4578   g_return_val_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0, NULL);
4579 
4580   LOCK_CONTEXT (context);
4581   result = context-&gt;poll_func;
4582   UNLOCK_CONTEXT (context);
4583 
4584   return result;
4585 }
4586 
4587 /**
4588  * g_main_context_wakeup:
4589  * @context: a #GMainContext
4590  *
4591  * If @context is currently blocking in g_main_context_iteration()
4592  * waiting for a source to become ready, cause it to stop blocking
4593  * and return.  Otherwise, cause the next invocation of
4594  * g_main_context_iteration() to return without blocking.
4595  *
4596  * This API is useful for low-level control over #GMainContext; for
4597  * example, integrating it with main loop implementations such as
4598  * #GMainLoop.
4599  *
4600  * Another related use for this function is when implementing a main
4601  * loop with a termination condition, computed from multiple threads:
4602  *
4603  * |[&lt;!-- language=&quot;C&quot; --&gt;
4604  *   #define NUM_TASKS 10
4605  *   static volatile gint tasks_remaining = NUM_TASKS;
4606  *   ...
4607  *
4608  *   while (g_atomic_int_get (&amp;tasks_remaining) != 0)
4609  *     g_main_context_iteration (NULL, TRUE);
4610  * ]|
4611  *
4612  * Then in a thread:
4613  * |[&lt;!-- language=&quot;C&quot; --&gt;
4614  *   perform_work();
4615  *
4616  *   if (g_atomic_int_dec_and_test (&amp;tasks_remaining))
4617  *     g_main_context_wakeup (NULL);
4618  * ]|
4619  **/
4620 void
4621 g_main_context_wakeup (GMainContext *context)
4622 {
4623   if (!context)
4624     context = g_main_context_default ();
4625 
4626   g_return_if_fail (g_atomic_int_get (&amp;context-&gt;ref_count) &gt; 0);
4627 
4628   TRACE (GLIB_MAIN_CONTEXT_WAKEUP (context));
4629 
4630   g_wakeup_signal (context-&gt;wakeup);
4631 }
4632 
4633 /**
4634  * g_main_context_is_owner:
4635  * @context: a #GMainContext
4636  *
4637  * Determines whether this thread holds the (recursive)
4638  * ownership of this #GMainContext. This is useful to
4639  * know before waiting on another thread that may be
4640  * blocking to get ownership of @context.
4641  *
4642  * Returns: %TRUE if current thread is owner of @context.
4643  *
4644  * Since: 2.10
4645  **/
4646 gboolean
4647 g_main_context_is_owner (GMainContext *context)
4648 {
4649   gboolean is_owner;
4650 
4651   if (!context)
4652     context = g_main_context_default ();
4653 
4654   LOCK_CONTEXT (context);
4655   is_owner = context-&gt;owner == G_THREAD_SELF;
4656   UNLOCK_CONTEXT (context);
4657 
4658   return is_owner;
4659 }
4660 
4661 /* Timeouts */
4662 
4663 static void
4664 g_timeout_set_expiration (GTimeoutSource *timeout_source,
4665                           gint64          current_time)
4666 {
4667   gint64 expiration;
4668 
4669   if (timeout_source-&gt;seconds)
4670     {
4671       gint64 remainder;
4672       static gint timer_perturb = -1;
4673 
4674       if (timer_perturb == -1)
4675         {
4676           /*
4677            * we want a per machine/session unique &#39;random&#39; value; try the dbus
4678            * address first, that has a UUID in it. If there is no dbus, use the
4679            * hostname for hashing.
4680            */
4681           const char *session_bus_address = g_getenv (&quot;DBUS_SESSION_BUS_ADDRESS&quot;);
4682           if (!session_bus_address)
4683             session_bus_address = g_getenv (&quot;HOSTNAME&quot;);
4684           if (session_bus_address)
4685             timer_perturb = ABS ((gint) g_str_hash (session_bus_address)) % 1000000;
4686           else
4687             timer_perturb = 0;
4688         }
4689 
4690       expiration = current_time + (guint64) timeout_source-&gt;interval * 1000 * 1000;
4691 
4692       /* We want the microseconds part of the timeout to land on the
4693        * &#39;timer_perturb&#39; mark, but we need to make sure we don&#39;t try to
4694        * set the timeout in the past.  We do this by ensuring that we
4695        * always only *increase* the expiration time by adding a full
4696        * second in the case that the microsecond portion decreases.
4697        */
4698       expiration -= timer_perturb;
4699 
4700       remainder = expiration % 1000000;
4701       if (remainder &gt;= 1000000/4)
4702         expiration += 1000000;
4703 
4704       expiration -= remainder;
4705       expiration += timer_perturb;
4706     }
4707   else
4708     {
4709       expiration = current_time + (guint64) timeout_source-&gt;interval * 1000;
4710     }
4711 
4712   g_source_set_ready_time ((GSource *) timeout_source, expiration);
4713 }
4714 
4715 static gboolean
4716 g_timeout_dispatch (GSource     *source,
4717                     GSourceFunc  callback,
4718                     gpointer     user_data)
4719 {
4720   GTimeoutSource *timeout_source = (GTimeoutSource *)source;
4721   gboolean again;
4722 
4723   if (!callback)
4724     {
4725       g_warning (&quot;Timeout source dispatched without callback. &quot;
4726                  &quot;You must call g_source_set_callback().&quot;);
4727       return FALSE;
4728     }
4729 
4730   again = callback (user_data);
4731 
4732   TRACE (GLIB_TIMEOUT_DISPATCH (source, source-&gt;context, callback, user_data, again));
4733 
4734   if (again)
4735     g_timeout_set_expiration (timeout_source, g_source_get_time (source));
4736 
4737   return again;
4738 }
4739 
4740 /**
4741  * g_timeout_source_new:
4742  * @interval: the timeout interval in milliseconds.
4743  *
4744  * Creates a new timeout source.
4745  *
4746  * The source will not initially be associated with any #GMainContext
4747  * and must be added to one with g_source_attach() before it will be
4748  * executed.
4749  *
4750  * The interval given is in terms of monotonic time, not wall clock
4751  * time.  See g_get_monotonic_time().
4752  *
4753  * Returns: the newly-created timeout source
4754  **/
4755 GSource *
4756 g_timeout_source_new (guint interval)
4757 {
4758   GSource *source = g_source_new (&amp;g_timeout_funcs, sizeof (GTimeoutSource));
4759   GTimeoutSource *timeout_source = (GTimeoutSource *)source;
4760 #ifdef GSTREAMER_LITE
4761   if (timeout_source == NULL)
4762       return NULL;
4763 #endif // GSTREAMER_LITE
4764 
4765   timeout_source-&gt;interval = interval;
4766   g_timeout_set_expiration (timeout_source, g_get_monotonic_time ());
4767 
4768   return source;
4769 }
4770 
4771 #ifndef GSTREAMER_LITE
4772 /**
4773  * g_timeout_source_new_seconds:
4774  * @interval: the timeout interval in seconds
4775  *
4776  * Creates a new timeout source.
4777  *
4778  * The source will not initially be associated with any #GMainContext
4779  * and must be added to one with g_source_attach() before it will be
4780  * executed.
4781  *
4782  * The scheduling granularity/accuracy of this timeout source will be
4783  * in seconds.
4784  *
4785  * The interval given is in terms of monotonic time, not wall clock time.
4786  * See g_get_monotonic_time().
4787  *
4788  * Returns: the newly-created timeout source
4789  *
4790  * Since: 2.14
4791  **/
4792 GSource *
4793 g_timeout_source_new_seconds (guint interval)
4794 {
4795   GSource *source = g_source_new (&amp;g_timeout_funcs, sizeof (GTimeoutSource));
4796   GTimeoutSource *timeout_source = (GTimeoutSource *)source;
4797 
4798   timeout_source-&gt;interval = interval;
4799   timeout_source-&gt;seconds = TRUE;
4800 
4801   g_timeout_set_expiration (timeout_source, g_get_monotonic_time ());
4802 
4803   return source;
4804 }
4805 #endif // GSTREAMER_LITE
4806 
4807 
4808 /**
4809  * g_timeout_add_full: (rename-to g_timeout_add)
4810  * @priority: the priority of the timeout source. Typically this will be in
4811  *            the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.
4812  * @interval: the time between calls to the function, in milliseconds
4813  *             (1/1000ths of a second)
4814  * @function: function to call
4815  * @data:     data to pass to @function
4816  * @notify: (nullable): function to call when the timeout is removed, or %NULL
4817  *
4818  * Sets a function to be called at regular intervals, with the given
4819  * priority.  The function is called repeatedly until it returns
4820  * %FALSE, at which point the timeout is automatically destroyed and
4821  * the function will not be called again.  The @notify function is
4822  * called when the timeout is destroyed.  The first call to the
4823  * function will be at the end of the first @interval.
4824  *
4825  * Note that timeout functions may be delayed, due to the processing of other
4826  * event sources. Thus they should not be relied on for precise timing.
4827  * After each call to the timeout function, the time of the next
4828  * timeout is recalculated based on the current time and the given interval
4829  * (it does not try to &#39;catch up&#39; time lost in delays).
4830  *
4831  * See [memory management of sources][mainloop-memory-management] for details
4832  * on how to handle the return value and memory management of @data.
4833  *
4834  * This internally creates a main loop source using g_timeout_source_new()
4835  * and attaches it to the global #GMainContext using g_source_attach(), so
4836  * the callback will be invoked in whichever thread is running that main
4837  * context. You can do these steps manually if you need greater control or to
4838  * use a custom main context.
4839  *
4840  * The interval given is in terms of monotonic time, not wall clock time.
4841  * See g_get_monotonic_time().
4842  *
4843  * Returns: the ID (greater than 0) of the event source.
4844  **/
4845 guint
4846 g_timeout_add_full (gint           priority,
4847         guint          interval,
4848         GSourceFunc    function,
4849         gpointer       data,
4850         GDestroyNotify notify)
4851 {
4852   GSource *source;
4853   guint id;
4854 
4855   g_return_val_if_fail (function != NULL, 0);
4856 
4857   source = g_timeout_source_new (interval);
4858 #ifdef GSTREAMER_LITE
4859   if (source == NULL)
4860       return 0;
4861 #endif // GSTREAMER_LITE
4862 
4863   if (priority != G_PRIORITY_DEFAULT)
4864     g_source_set_priority (source, priority);
4865 
4866   g_source_set_callback (source, function, data, notify);
4867   id = g_source_attach (source, NULL);
4868 
4869   TRACE (GLIB_TIMEOUT_ADD (source, g_main_context_default (), id, priority, interval, function, data));
4870 
4871   g_source_unref (source);
4872 
4873   return id;
4874 }
4875 
4876 /**
4877  * g_timeout_add:
4878  * @interval: the time between calls to the function, in milliseconds
4879  *             (1/1000ths of a second)
4880  * @function: function to call
4881  * @data:     data to pass to @function
4882  *
4883  * Sets a function to be called at regular intervals, with the default
4884  * priority, #G_PRIORITY_DEFAULT.  The function is called repeatedly
4885  * until it returns %FALSE, at which point the timeout is automatically
4886  * destroyed and the function will not be called again.  The first call
4887  * to the function will be at the end of the first @interval.
4888  *
4889  * Note that timeout functions may be delayed, due to the processing of other
4890  * event sources. Thus they should not be relied on for precise timing.
4891  * After each call to the timeout function, the time of the next
4892  * timeout is recalculated based on the current time and the given interval
4893  * (it does not try to &#39;catch up&#39; time lost in delays).
4894  *
4895  * See [memory management of sources][mainloop-memory-management] for details
4896  * on how to handle the return value and memory management of @data.
4897  *
4898  * If you want to have a timer in the &quot;seconds&quot; range and do not care
4899  * about the exact time of the first call of the timer, use the
4900  * g_timeout_add_seconds() function; this function allows for more
4901  * optimizations and more efficient system power usage.
4902  *
4903  * This internally creates a main loop source using g_timeout_source_new()
4904  * and attaches it to the global #GMainContext using g_source_attach(), so
4905  * the callback will be invoked in whichever thread is running that main
4906  * context. You can do these steps manually if you need greater control or to
4907  * use a custom main context.
4908  *
4909  * The interval given is in terms of monotonic time, not wall clock
4910  * time.  See g_get_monotonic_time().
4911  *
4912  * Returns: the ID (greater than 0) of the event source.
4913  **/
4914 guint
4915 g_timeout_add (guint32        interval,
4916          GSourceFunc    function,
4917          gpointer       data)
4918 {
4919   return g_timeout_add_full (G_PRIORITY_DEFAULT,
4920            interval, function, data, NULL);
4921 }
4922 
4923 #ifndef GSTREAMER_LITE
4924 /**
4925  * g_timeout_add_seconds_full: (rename-to g_timeout_add_seconds)
4926  * @priority: the priority of the timeout source. Typically this will be in
4927  *            the range between #G_PRIORITY_DEFAULT and #G_PRIORITY_HIGH.
4928  * @interval: the time between calls to the function, in seconds
4929  * @function: function to call
4930  * @data:     data to pass to @function
4931  * @notify: (nullable): function to call when the timeout is removed, or %NULL
4932  *
4933  * Sets a function to be called at regular intervals, with @priority.
4934  * The function is called repeatedly until it returns %FALSE, at which
4935  * point the timeout is automatically destroyed and the function will
4936  * not be called again.
4937  *
4938  * Unlike g_timeout_add(), this function operates at whole second granularity.
4939  * The initial starting point of the timer is determined by the implementation
4940  * and the implementation is expected to group multiple timers together so that
4941  * they fire all at the same time.
4942  * To allow this grouping, the @interval to the first timer is rounded
4943  * and can deviate up to one second from the specified interval.
4944  * Subsequent timer iterations will generally run at the specified interval.
4945  *
4946  * Note that timeout functions may be delayed, due to the processing of other
4947  * event sources. Thus they should not be relied on for precise timing.
4948  * After each call to the timeout function, the time of the next
4949  * timeout is recalculated based on the current time and the given @interval
4950  *
4951  * See [memory management of sources][mainloop-memory-management] for details
4952  * on how to handle the return value and memory management of @data.
4953  *
4954  * If you want timing more precise than whole seconds, use g_timeout_add()
4955  * instead.
4956  *
4957  * The grouping of timers to fire at the same time results in a more power
4958  * and CPU efficient behavior so if your timer is in multiples of seconds
4959  * and you don&#39;t require the first timer exactly one second from now, the
4960  * use of g_timeout_add_seconds() is preferred over g_timeout_add().
4961  *
4962  * This internally creates a main loop source using
4963  * g_timeout_source_new_seconds() and attaches it to the main loop context
4964  * using g_source_attach(). You can do these steps manually if you need
4965  * greater control.
4966  *
4967  * The interval given is in terms of monotonic time, not wall clock
4968  * time.  See g_get_monotonic_time().
4969  *
4970  * Returns: the ID (greater than 0) of the event source.
4971  *
4972  * Since: 2.14
4973  **/
4974 guint
4975 g_timeout_add_seconds_full (gint           priority,
4976                             guint32        interval,
4977                             GSourceFunc    function,
4978                             gpointer       data,
4979                             GDestroyNotify notify)
4980 {
4981   GSource *source;
4982   guint id;
4983 
4984   g_return_val_if_fail (function != NULL, 0);
4985 
4986   source = g_timeout_source_new_seconds (interval);
4987 
4988   if (priority != G_PRIORITY_DEFAULT)
4989     g_source_set_priority (source, priority);
4990 
4991   g_source_set_callback (source, function, data, notify);
4992   id = g_source_attach (source, NULL);
4993   g_source_unref (source);
4994 
4995   return id;
4996 }
4997 
4998 /**
4999  * g_timeout_add_seconds:
5000  * @interval: the time between calls to the function, in seconds
5001  * @function: function to call
5002  * @data: data to pass to @function
5003  *
5004  * Sets a function to be called at regular intervals with the default
5005  * priority, #G_PRIORITY_DEFAULT. The function is called repeatedly until
5006  * it returns %FALSE, at which point the timeout is automatically destroyed
5007  * and the function will not be called again.
5008  *
5009  * This internally creates a main loop source using
5010  * g_timeout_source_new_seconds() and attaches it to the main loop context
5011  * using g_source_attach(). You can do these steps manually if you need
5012  * greater control. Also see g_timeout_add_seconds_full().
5013  *
5014  * Note that the first call of the timer may not be precise for timeouts
5015  * of one second. If you need finer precision and have such a timeout,
5016  * you may want to use g_timeout_add() instead.
5017  *
5018  * See [memory management of sources][mainloop-memory-management] for details
5019  * on how to handle the return value and memory management of @data.
5020  *
5021  * The interval given is in terms of monotonic time, not wall clock
5022  * time.  See g_get_monotonic_time().
5023  *
5024  * Returns: the ID (greater than 0) of the event source.
5025  *
5026  * Since: 2.14
5027  **/
5028 guint
5029 g_timeout_add_seconds (guint       interval,
5030                        GSourceFunc function,
5031                        gpointer    data)
5032 {
5033   g_return_val_if_fail (function != NULL, 0);
5034 
5035   return g_timeout_add_seconds_full (G_PRIORITY_DEFAULT, interval, function, data, NULL);
5036 }
5037 #endif // GSTREAMER_LITE
5038 
5039 /* Child watch functions */
5040 
5041 #ifdef G_OS_WIN32
5042 
5043 static gboolean
5044 g_child_watch_prepare (GSource *source,
5045            gint    *timeout)
5046 {
5047   *timeout = -1;
5048   return FALSE;
5049 }
5050 
5051 static gboolean
5052 g_child_watch_check (GSource  *source)
5053 {
5054   GChildWatchSource *child_watch_source;
5055   gboolean child_exited;
5056 
5057   child_watch_source = (GChildWatchSource *) source;
5058 
5059   child_exited = child_watch_source-&gt;poll.revents &amp; G_IO_IN;
5060 
5061   if (child_exited)
5062     {
5063       DWORD child_status;
5064 
5065       /*
5066        * Note: We do _not_ check for the special value of STILL_ACTIVE
5067        * since we know that the process has exited and doing so runs into
5068        * problems if the child process &quot;happens to return STILL_ACTIVE(259)&quot;
5069        * as Microsoft&#39;s Platform SDK puts it.
5070        */
5071       if (!GetExitCodeProcess (child_watch_source-&gt;pid, &amp;child_status))
5072         {
5073     gchar *emsg = g_win32_error_message (GetLastError ());
5074     g_warning (G_STRLOC &quot;: GetExitCodeProcess() failed: %s&quot;, emsg);
5075     g_free (emsg);
5076 
5077     child_watch_source-&gt;child_status = -1;
5078   }
5079       else
5080   child_watch_source-&gt;child_status = child_status;
5081     }
5082 
5083   return child_exited;
5084 }
5085 
5086 static void
5087 g_child_watch_finalize (GSource *source)
5088 {
5089 }
5090 
5091 #else /* G_OS_WIN32 */
5092 
5093 static void
5094 wake_source (GSource *source)
5095 {
5096   GMainContext *context;
5097 
5098   /* This should be thread-safe:
5099    *
5100    *  - if the source is currently being added to a context, that
5101    *    context will be woken up anyway
5102    *
5103    *  - if the source is currently being destroyed, we simply need not
5104    *    to crash:
5105    *
5106    *    - the memory for the source will remain valid until after the
5107    *      source finalize function was called (which would remove the
5108    *      source from the global list which we are currently holding the
5109    *      lock for)
5110    *
5111    *    - the GMainContext will either be NULL or point to a live
5112    *      GMainContext
5113    *
5114    *    - the GMainContext will remain valid since we hold the
5115    *      main_context_list lock
5116    *
5117    *  Since we are holding a lot of locks here, don&#39;t try to enter any
5118    *  more GMainContext functions for fear of dealock -- just hit the
5119    *  GWakeup and run.  Even if that&#39;s safe now, it could easily become
5120    *  unsafe with some very minor changes in the future, and signal
5121    *  handling is not the most well-tested codepath.
5122    */
5123   G_LOCK(main_context_list);
5124   context = source-&gt;context;
5125   if (context)
5126     g_wakeup_signal (context-&gt;wakeup);
5127   G_UNLOCK(main_context_list);
5128 }
5129 
5130 static void
5131 dispatch_unix_signals_unlocked (void)
5132 {
5133   gboolean pending[NSIG];
5134   GSList *node;
5135   gint i;
5136 
5137   /* clear this first in case another one arrives while we&#39;re processing */
5138   any_unix_signal_pending = FALSE;
5139 
5140   /* We atomically test/clear the bit from the global array in case
5141    * other signals arrive while we are dispatching.
5142    *
5143    * We then can safely use our own array below without worrying about
5144    * races.
5145    */
5146   for (i = 0; i &lt; NSIG; i++)
5147     {
5148       /* Be very careful with (the volatile) unix_signal_pending.
5149        *
5150        * We must ensure that it&#39;s not possible that we clear it without
5151        * handling the signal.  We therefore must ensure that our pending
5152        * array has a field set (ie: we will do something about the
5153        * signal) before we clear the item in unix_signal_pending.
5154        *
5155        * Note specifically: we must check _our_ array.
5156        */
5157       pending[i] = unix_signal_pending[i];
5158       if (pending[i])
5159         unix_signal_pending[i] = FALSE;
5160     }
5161 
5162   /* handle GChildWatchSource instances */
5163   if (pending[SIGCHLD])
5164     {
5165       /* The only way we can do this is to scan all of the children.
5166        *
5167        * The docs promise that we will not reap children that we are not
5168        * explicitly watching, so that ties our hands from calling
5169        * waitpid(-1).  We also can&#39;t use siginfo&#39;s si_pid field since if
5170        * multiple SIGCHLD arrive at the same time, one of them can be
5171        * dropped (since a given UNIX signal can only be pending once).
5172        */
5173       for (node = unix_child_watches; node; node = node-&gt;next)
5174         {
5175           GChildWatchSource *source = node-&gt;data;
5176 
5177           if (!g_atomic_int_get (&amp;source-&gt;child_exited))
5178             {
5179               pid_t pid;
5180               do
5181                 {
5182                   g_assert (source-&gt;pid &gt; 0);
5183 
5184                   pid = waitpid (source-&gt;pid, &amp;source-&gt;child_status, WNOHANG);
5185                   if (pid &gt; 0)
5186                     {
5187                       g_atomic_int_set (&amp;source-&gt;child_exited, TRUE);
5188                       wake_source ((GSource *) source);
5189                     }
5190                   else if (pid == -1 &amp;&amp; errno == ECHILD)
5191                     {
5192                       g_warning (&quot;GChildWatchSource: Exit status of a child process was requested but ECHILD was received by waitpid(). See the documentation of g_child_watch_source_new() for possible causes.&quot;);
5193                       source-&gt;child_status = 0;
5194                       g_atomic_int_set (&amp;source-&gt;child_exited, TRUE);
5195                       wake_source ((GSource *) source);
5196                     }
5197                 }
5198               while (pid == -1 &amp;&amp; errno == EINTR);
5199             }
5200         }
5201     }
5202 
5203   /* handle GUnixSignalWatchSource instances */
5204   for (node = unix_signal_watches; node; node = node-&gt;next)
5205     {
5206       GUnixSignalWatchSource *source = node-&gt;data;
5207 
5208       if (pending[source-&gt;signum] &amp;&amp;
5209           g_atomic_int_compare_and_exchange (&amp;source-&gt;pending, FALSE, TRUE))
5210         {
5211           wake_source ((GSource *) source);
5212         }
5213     }
5214 
5215 }
5216 
5217 static void
5218 dispatch_unix_signals (void)
5219 {
5220   G_LOCK(unix_signal_lock);
5221   dispatch_unix_signals_unlocked ();
5222   G_UNLOCK(unix_signal_lock);
5223 }
5224 
5225 static gboolean
5226 g_child_watch_prepare (GSource *source,
5227            gint    *timeout)
5228 {
5229   GChildWatchSource *child_watch_source;
5230 
5231   child_watch_source = (GChildWatchSource *) source;
5232 
5233   return g_atomic_int_get (&amp;child_watch_source-&gt;child_exited);
5234 }
5235 
5236 static gboolean
5237 g_child_watch_check (GSource *source)
5238 {
5239   GChildWatchSource *child_watch_source;
5240 
5241   child_watch_source = (GChildWatchSource *) source;
5242 
5243   return g_atomic_int_get (&amp;child_watch_source-&gt;child_exited);
5244 }
5245 
5246 static gboolean
5247 g_unix_signal_watch_prepare (GSource *source,
5248            gint    *timeout)
5249 {
5250   GUnixSignalWatchSource *unix_signal_source;
5251 
5252   unix_signal_source = (GUnixSignalWatchSource *) source;
5253 
5254   return g_atomic_int_get (&amp;unix_signal_source-&gt;pending);
5255 }
5256 
5257 static gboolean
5258 g_unix_signal_watch_check (GSource  *source)
5259 {
5260   GUnixSignalWatchSource *unix_signal_source;
5261 
5262   unix_signal_source = (GUnixSignalWatchSource *) source;
5263 
5264   return g_atomic_int_get (&amp;unix_signal_source-&gt;pending);
5265 }
5266 
5267 static gboolean
5268 g_unix_signal_watch_dispatch (GSource    *source,
5269             GSourceFunc callback,
5270             gpointer    user_data)
5271 {
5272   GUnixSignalWatchSource *unix_signal_source;
5273   gboolean again;
5274 
5275   unix_signal_source = (GUnixSignalWatchSource *) source;
5276 
5277   if (!callback)
5278     {
5279       g_warning (&quot;Unix signal source dispatched without callback. &quot;
5280      &quot;You must call g_source_set_callback().&quot;);
5281       return FALSE;
5282     }
5283 
5284   g_atomic_int_set (&amp;unix_signal_source-&gt;pending, FALSE);
5285 
5286   again = (callback) (user_data);
5287 
5288   return again;
5289 }
5290 
5291 static void
5292 ref_unix_signal_handler_unlocked (int signum)
5293 {
5294   /* Ensure we have the worker context */
5295   g_get_worker_context ();
5296   unix_signal_refcount[signum]++;
5297   if (unix_signal_refcount[signum] == 1)
5298     {
5299       struct sigaction action;
5300       action.sa_handler = g_unix_signal_handler;
5301       sigemptyset (&amp;action.sa_mask);
5302 #ifdef SA_RESTART
5303       action.sa_flags = SA_RESTART | SA_NOCLDSTOP;
5304 #else
5305       action.sa_flags = SA_NOCLDSTOP;
5306 #endif
5307       sigaction (signum, &amp;action, NULL);
5308     }
5309 }
5310 
5311 static void
5312 unref_unix_signal_handler_unlocked (int signum)
5313 {
5314   unix_signal_refcount[signum]--;
5315   if (unix_signal_refcount[signum] == 0)
5316     {
5317       struct sigaction action;
5318       memset (&amp;action, 0, sizeof (action));
5319       action.sa_handler = SIG_DFL;
5320       sigemptyset (&amp;action.sa_mask);
5321       sigaction (signum, &amp;action, NULL);
5322     }
5323 }
5324 
5325 /* Return a const string to avoid allocations. We lose precision in the case the
5326  * @signum is unrecognised, but that&#39;ll do. */
5327 static const gchar *
5328 signum_to_string (int signum)
5329 {
5330   /* See &#39;man signal.h&#39; */
5331 #define SIGNAL(s) \
5332     case (s): \
5333       return (&quot;GUnixSignalSource: &quot; #s);
5334   switch (signum)
5335     {
5336     /* These signals are guaranteed to exist by POSIX. */
5337     SIGNAL (SIGABRT)
5338     SIGNAL (SIGFPE)
5339     SIGNAL (SIGILL)
5340     SIGNAL (SIGINT)
5341     SIGNAL (SIGSEGV)
5342     SIGNAL (SIGTERM)
5343     /* Frustratingly, these are not, and hence for brevity the list is
5344      * incomplete. */
5345 #ifdef SIGALRM
5346     SIGNAL (SIGALRM)
5347 #endif
5348 #ifdef SIGCHLD
5349     SIGNAL (SIGCHLD)
5350 #endif
5351 #ifdef SIGHUP
5352     SIGNAL (SIGHUP)
5353 #endif
5354 #ifdef SIGKILL
5355     SIGNAL (SIGKILL)
5356 #endif
5357 #ifdef SIGPIPE
5358     SIGNAL (SIGPIPE)
5359 #endif
5360 #ifdef SIGQUIT
5361     SIGNAL (SIGQUIT)
5362 #endif
5363 #ifdef SIGSTOP
5364     SIGNAL (SIGSTOP)
5365 #endif
5366 #ifdef SIGUSR1
5367     SIGNAL (SIGUSR1)
5368 #endif
5369 #ifdef SIGUSR2
5370     SIGNAL (SIGUSR2)
5371 #endif
5372 #ifdef SIGPOLL
5373     SIGNAL (SIGPOLL)
5374 #endif
5375 #ifdef SIGPROF
5376     SIGNAL (SIGPROF)
5377 #endif
5378 #ifdef SIGTRAP
5379     SIGNAL (SIGTRAP)
5380 #endif
5381     default:
5382       return &quot;GUnixSignalSource: Unrecognized signal&quot;;
5383     }
5384 #undef SIGNAL
5385 }
5386 
5387 GSource *
5388 _g_main_create_unix_signal_watch (int signum)
5389 {
5390   GSource *source;
5391   GUnixSignalWatchSource *unix_signal_source;
5392 
5393   source = g_source_new (&amp;g_unix_signal_funcs, sizeof (GUnixSignalWatchSource));
5394   unix_signal_source = (GUnixSignalWatchSource *) source;
5395 
5396   unix_signal_source-&gt;signum = signum;
5397   unix_signal_source-&gt;pending = FALSE;
5398 
5399   /* Set a default name on the source, just in case the caller does not. */
5400   g_source_set_name (source, signum_to_string (signum));
5401 
5402   G_LOCK (unix_signal_lock);
5403   ref_unix_signal_handler_unlocked (signum);
5404   unix_signal_watches = g_slist_prepend (unix_signal_watches, unix_signal_source);
5405   dispatch_unix_signals_unlocked ();
5406   G_UNLOCK (unix_signal_lock);
5407 
5408   return source;
5409 }
5410 
5411 static void
5412 g_unix_signal_watch_finalize (GSource    *source)
5413 {
5414   GUnixSignalWatchSource *unix_signal_source;
5415 
5416   unix_signal_source = (GUnixSignalWatchSource *) source;
5417 
5418   G_LOCK (unix_signal_lock);
5419   unref_unix_signal_handler_unlocked (unix_signal_source-&gt;signum);
5420   unix_signal_watches = g_slist_remove (unix_signal_watches, source);
5421   G_UNLOCK (unix_signal_lock);
5422 }
5423 
5424 static void
5425 g_child_watch_finalize (GSource *source)
5426 {
5427   G_LOCK (unix_signal_lock);
5428   unix_child_watches = g_slist_remove (unix_child_watches, source);
5429   unref_unix_signal_handler_unlocked (SIGCHLD);
5430   G_UNLOCK (unix_signal_lock);
5431 }
5432 
5433 #endif /* G_OS_WIN32 */
5434 
5435 static gboolean
5436 g_child_watch_dispatch (GSource    *source,
5437       GSourceFunc callback,
5438       gpointer    user_data)
5439 {
5440   GChildWatchSource *child_watch_source;
5441   GChildWatchFunc child_watch_callback = (GChildWatchFunc) callback;
5442 
5443   child_watch_source = (GChildWatchSource *) source;
5444 
5445   if (!callback)
5446     {
5447       g_warning (&quot;Child watch source dispatched without callback. &quot;
5448      &quot;You must call g_source_set_callback().&quot;);
5449       return FALSE;
5450     }
5451 
5452   (child_watch_callback) (child_watch_source-&gt;pid, child_watch_source-&gt;child_status, user_data);
5453 
5454   /* We never keep a child watch source around as the child is gone */
5455   return FALSE;
5456 }
5457 
5458 #ifndef G_OS_WIN32
5459 
5460 static void
5461 g_unix_signal_handler (int signum)
5462 {
5463   gint saved_errno = errno;
5464 
5465   unix_signal_pending[signum] = TRUE;
5466   any_unix_signal_pending = TRUE;
5467 
5468   g_wakeup_signal (glib_worker_context-&gt;wakeup);
5469 
5470   errno = saved_errno;
5471 }
5472 
5473 #endif /* !G_OS_WIN32 */
5474 
5475 /**
5476  * g_child_watch_source_new:
5477  * @pid: process to watch. On POSIX the positive pid of a child process. On
5478  * Windows a handle for a process (which doesn&#39;t have to be a child).
5479  *
5480  * Creates a new child_watch source.
5481  *
5482  * The source will not initially be associated with any #GMainContext
5483  * and must be added to one with g_source_attach() before it will be
5484  * executed.
5485  *
5486  * Note that child watch sources can only be used in conjunction with
5487  * `g_spawn...` when the %G_SPAWN_DO_NOT_REAP_CHILD flag is used.
5488  *
5489  * Note that on platforms where #GPid must be explicitly closed
5490  * (see g_spawn_close_pid()) @pid must not be closed while the
5491  * source is still active. Typically, you will want to call
5492  * g_spawn_close_pid() in the callback function for the source.
5493  *
5494  * On POSIX platforms, the following restrictions apply to this API
5495  * due to limitations in POSIX process interfaces:
5496  *
5497  * * @pid must be a child of this process
5498  * * @pid must be positive
5499  * * the application must not call `waitpid` with a non-positive
5500  *   first argument, for instance in another thread
5501  * * the application must not wait for @pid to exit by any other
5502  *   mechanism, including `waitpid(pid, ...)` or a second child-watch
5503  *   source for the same @pid
5504  * * the application must not ignore SIGCHILD
5505  *
5506  * If any of those conditions are not met, this and related APIs will
5507  * not work correctly. This can often be diagnosed via a GLib warning
5508  * stating that `ECHILD` was received by `waitpid`.
5509  *
5510  * Calling `waitpid` for specific processes other than @pid remains a
5511  * valid thing to do.
5512  *
5513  * Returns: the newly-created child watch source
5514  *
5515  * Since: 2.4
5516  **/
5517 GSource *
5518 g_child_watch_source_new (GPid pid)
5519 {
5520   GSource *source;
5521   GChildWatchSource *child_watch_source;
5522 
5523 #ifndef G_OS_WIN32
5524   g_return_val_if_fail (pid &gt; 0, NULL);
5525 #endif
5526 
5527   source = g_source_new (&amp;g_child_watch_funcs, sizeof (GChildWatchSource));
5528 #ifdef GSTREAMER_LITE
5529   if (source == NULL)
5530       return NULL;
5531 #endif // GSTREAMER_LITE
5532   child_watch_source = (GChildWatchSource *)source;
5533 
5534   /* Set a default name on the source, just in case the caller does not. */
5535   g_source_set_name (source, &quot;GChildWatchSource&quot;);
5536 
5537   child_watch_source-&gt;pid = pid;
5538 
5539 #ifdef G_OS_WIN32
5540   child_watch_source-&gt;poll.fd = (gintptr) pid;
5541   child_watch_source-&gt;poll.events = G_IO_IN;
5542 
5543   g_source_add_poll (source, &amp;child_watch_source-&gt;poll);
5544 #else /* G_OS_WIN32 */
5545   G_LOCK (unix_signal_lock);
5546   ref_unix_signal_handler_unlocked (SIGCHLD);
5547   unix_child_watches = g_slist_prepend (unix_child_watches, child_watch_source);
5548   if (waitpid (pid, &amp;child_watch_source-&gt;child_status, WNOHANG) &gt; 0)
5549     child_watch_source-&gt;child_exited = TRUE;
5550   G_UNLOCK (unix_signal_lock);
5551 #endif /* G_OS_WIN32 */
5552 
5553   return source;
5554 }
5555 
5556 /**
5557  * g_child_watch_add_full: (rename-to g_child_watch_add)
5558  * @priority: the priority of the idle source. Typically this will be in the
5559  *            range between #G_PRIORITY_DEFAULT_IDLE and #G_PRIORITY_HIGH_IDLE.
5560  * @pid:      process to watch. On POSIX the positive pid of a child process. On
5561  * Windows a handle for a process (which doesn&#39;t have to be a child).
5562  * @function: function to call
5563  * @data:     data to pass to @function
5564  * @notify: (nullable): function to call when the idle is removed, or %NULL
5565  *
5566  * Sets a function to be called when the child indicated by @pid
5567  * exits, at the priority @priority.
5568  *
5569  * If you obtain @pid from g_spawn_async() or g_spawn_async_with_pipes()
5570  * you will need to pass #G_SPAWN_DO_NOT_REAP_CHILD as flag to
5571  * the spawn function for the child watching to work.
5572  *
5573  * In many programs, you will want to call g_spawn_check_exit_status()
5574  * in the callback to determine whether or not the child exited
5575  * successfully.
5576  *
5577  * Also, note that on platforms where #GPid must be explicitly closed
5578  * (see g_spawn_close_pid()) @pid must not be closed while the source
5579  * is still active.  Typically, you should invoke g_spawn_close_pid()
5580  * in the callback function for the source.
5581  *
5582  * GLib supports only a single callback per process id.
5583  * On POSIX platforms, the same restrictions mentioned for
5584  * g_child_watch_source_new() apply to this function.
5585  *
5586  * This internally creates a main loop source using
5587  * g_child_watch_source_new() and attaches it to the main loop context
5588  * using g_source_attach(). You can do these steps manually if you
5589  * need greater control.
5590  *
5591  * Returns: the ID (greater than 0) of the event source.
5592  *
5593  * Since: 2.4
5594  **/
5595 guint
5596 g_child_watch_add_full (gint            priority,
5597       GPid            pid,
5598       GChildWatchFunc function,
5599       gpointer        data,
5600       GDestroyNotify  notify)
5601 {
5602   GSource *source;
5603   guint id;
5604 
5605   g_return_val_if_fail (function != NULL, 0);
5606 #ifndef G_OS_WIN32
5607   g_return_val_if_fail (pid &gt; 0, 0);
5608 #endif
5609 
5610   source = g_child_watch_source_new (pid);
5611 
5612   if (priority != G_PRIORITY_DEFAULT)
5613     g_source_set_priority (source, priority);
5614 
5615   g_source_set_callback (source, (GSourceFunc) function, data, notify);
5616   id = g_source_attach (source, NULL);
5617   g_source_unref (source);
5618 
5619   return id;
5620 }
5621 
5622 /**
5623  * g_child_watch_add:
5624  * @pid:      process id to watch. On POSIX the positive pid of a child
5625  * process. On Windows a handle for a process (which doesn&#39;t have to be
5626  * a child).
5627  * @function: function to call
5628  * @data:     data to pass to @function
5629  *
5630  * Sets a function to be called when the child indicated by @pid
5631  * exits, at a default priority, #G_PRIORITY_DEFAULT.
5632  *
5633  * If you obtain @pid from g_spawn_async() or g_spawn_async_with_pipes()
5634  * you will need to pass #G_SPAWN_DO_NOT_REAP_CHILD as flag to
5635  * the spawn function for the child watching to work.
5636  *
5637  * Note that on platforms where #GPid must be explicitly closed
5638  * (see g_spawn_close_pid()) @pid must not be closed while the
5639  * source is still active. Typically, you will want to call
5640  * g_spawn_close_pid() in the callback function for the source.
5641  *
5642  * GLib supports only a single callback per process id.
5643  * On POSIX platforms, the same restrictions mentioned for
5644  * g_child_watch_source_new() apply to this function.
5645  *
5646  * This internally creates a main loop source using
5647  * g_child_watch_source_new() and attaches it to the main loop context
5648  * using g_source_attach(). You can do these steps manually if you
5649  * need greater control.
5650  *
5651  * Returns: the ID (greater than 0) of the event source.
5652  *
5653  * Since: 2.4
5654  **/
5655 guint
5656 g_child_watch_add (GPid            pid,
5657        GChildWatchFunc function,
5658        gpointer        data)
5659 {
5660   return g_child_watch_add_full (G_PRIORITY_DEFAULT, pid, function, data, NULL);
5661 }
5662 
5663 
5664 /* Idle functions */
5665 
5666 static gboolean
5667 g_idle_prepare  (GSource  *source,
5668      gint     *timeout)
5669 {
5670   *timeout = 0;
5671 
5672   return TRUE;
5673 }
5674 
5675 static gboolean
5676 g_idle_check    (GSource  *source)
5677 {
5678   return TRUE;
5679 }
5680 
5681 static gboolean
5682 g_idle_dispatch (GSource    *source,
5683      GSourceFunc callback,
5684      gpointer    user_data)
5685 {
5686   gboolean again;
5687 
5688   if (!callback)
5689     {
5690       g_warning (&quot;Idle source dispatched without callback. &quot;
5691      &quot;You must call g_source_set_callback().&quot;);
5692       return FALSE;
5693     }
5694 
5695   again = callback (user_data);
5696 
5697   TRACE (GLIB_IDLE_DISPATCH (source, source-&gt;context, callback, user_data, again));
5698 
5699   return again;
5700 }
5701 
5702 /**
5703  * g_idle_source_new:
5704  *
5705  * Creates a new idle source.
5706  *
5707  * The source will not initially be associated with any #GMainContext
5708  * and must be added to one with g_source_attach() before it will be
5709  * executed. Note that the default priority for idle sources is
5710  * %G_PRIORITY_DEFAULT_IDLE, as compared to other sources which
5711  * have a default priority of %G_PRIORITY_DEFAULT.
5712  *
5713  * Returns: the newly-created idle source
5714  **/
5715 GSource *
5716 g_idle_source_new (void)
5717 {
5718   GSource *source;
5719 
5720   source = g_source_new (&amp;g_idle_funcs, sizeof (GSource));
5721   g_source_set_priority (source, G_PRIORITY_DEFAULT_IDLE);
5722 
5723   /* Set a default name on the source, just in case the caller does not. */
5724   g_source_set_name (source, &quot;GIdleSource&quot;);
5725 
5726   return source;
5727 }
5728 
5729 /**
5730  * g_idle_add_full: (rename-to g_idle_add)
5731  * @priority: the priority of the idle source. Typically this will be in the
5732  *            range between #G_PRIORITY_DEFAULT_IDLE and #G_PRIORITY_HIGH_IDLE.
5733  * @function: function to call
5734  * @data:     data to pass to @function
5735  * @notify: (nullable): function to call when the idle is removed, or %NULL
5736  *
5737  * Adds a function to be called whenever there are no higher priority
5738  * events pending.  If the function returns %FALSE it is automatically
5739  * removed from the list of event sources and will not be called again.
5740  *
5741  * See [memory management of sources][mainloop-memory-management] for details
5742  * on how to handle the return value and memory management of @data.
5743  *
5744  * This internally creates a main loop source using g_idle_source_new()
5745  * and attaches it to the global #GMainContext using g_source_attach(), so
5746  * the callback will be invoked in whichever thread is running that main
5747  * context. You can do these steps manually if you need greater control or to
5748  * use a custom main context.
5749  *
5750  * Returns: the ID (greater than 0) of the event source.
5751  **/
5752 guint
5753 g_idle_add_full (gint           priority,
5754      GSourceFunc    function,
5755      gpointer       data,
5756      GDestroyNotify notify)
5757 {
5758   GSource *source;
5759   guint id;
5760 
5761   g_return_val_if_fail (function != NULL, 0);
5762 
5763   source = g_idle_source_new ();
5764 
5765   if (priority != G_PRIORITY_DEFAULT_IDLE)
5766     g_source_set_priority (source, priority);
5767 
5768   g_source_set_callback (source, function, data, notify);
5769   id = g_source_attach (source, NULL);
5770 
5771   TRACE (GLIB_IDLE_ADD (source, g_main_context_default (), id, priority, function, data));
5772 
5773   g_source_unref (source);
5774 
5775   return id;
5776 }
5777 
5778 /**
5779  * g_idle_add:
5780  * @function: function to call
5781  * @data: data to pass to @function.
5782  *
5783  * Adds a function to be called whenever there are no higher priority
5784  * events pending to the default main loop. The function is given the
5785  * default idle priority, #G_PRIORITY_DEFAULT_IDLE.  If the function
5786  * returns %FALSE it is automatically removed from the list of event
5787  * sources and will not be called again.
5788  *
5789  * See [memory management of sources][mainloop-memory-management] for details
5790  * on how to handle the return value and memory management of @data.
5791  *
5792  * This internally creates a main loop source using g_idle_source_new()
5793  * and attaches it to the global #GMainContext using g_source_attach(), so
5794  * the callback will be invoked in whichever thread is running that main
5795  * context. You can do these steps manually if you need greater control or to
5796  * use a custom main context.
5797  *
5798  * Returns: the ID (greater than 0) of the event source.
5799  **/
5800 guint
5801 g_idle_add (GSourceFunc    function,
5802       gpointer       data)
5803 {
5804   return g_idle_add_full (G_PRIORITY_DEFAULT_IDLE, function, data, NULL);
5805 }
5806 
5807 /**
5808  * g_idle_remove_by_data:
5809  * @data: the data for the idle source&#39;s callback.
5810  *
5811  * Removes the idle function with the given data.
5812  *
5813  * Returns: %TRUE if an idle source was found and removed.
5814  **/
5815 gboolean
5816 g_idle_remove_by_data (gpointer data)
5817 {
5818   return g_source_remove_by_funcs_user_data (&amp;g_idle_funcs, data);
5819 }
5820 
5821 /**
5822  * g_main_context_invoke:
5823  * @context: (nullable): a #GMainContext, or %NULL
5824  * @function: function to call
5825  * @data: data to pass to @function
5826  *
5827  * Invokes a function in such a way that @context is owned during the
5828  * invocation of @function.
5829  *
5830  * If @context is %NULL then the global default main context - as
5831  * returned by g_main_context_default() - is used.
5832  *
5833  * If @context is owned by the current thread, @function is called
5834  * directly.  Otherwise, if @context is the thread-default main context
5835  * of the current thread and g_main_context_acquire() succeeds, then
5836  * @function is called and g_main_context_release() is called
5837  * afterwards.
5838  *
5839  * In any other case, an idle source is created to call @function and
5840  * that source is attached to @context (presumably to be run in another
5841  * thread).  The idle source is attached with #G_PRIORITY_DEFAULT
5842  * priority.  If you want a different priority, use
5843  * g_main_context_invoke_full().
5844  *
5845  * Note that, as with normal idle functions, @function should probably
5846  * return %FALSE.  If it returns %TRUE, it will be continuously run in a
5847  * loop (and may prevent this call from returning).
5848  *
5849  * Since: 2.28
5850  **/
5851 void
5852 g_main_context_invoke (GMainContext *context,
5853                        GSourceFunc   function,
5854                        gpointer      data)
5855 {
5856   g_main_context_invoke_full (context,
5857                               G_PRIORITY_DEFAULT,
5858                               function, data, NULL);
5859 }
5860 
5861 /**
5862  * g_main_context_invoke_full:
5863  * @context: (nullable): a #GMainContext, or %NULL
5864  * @priority: the priority at which to run @function
5865  * @function: function to call
5866  * @data: data to pass to @function
5867  * @notify: (nullable): a function to call when @data is no longer in use, or %NULL.
5868  *
5869  * Invokes a function in such a way that @context is owned during the
5870  * invocation of @function.
5871  *
5872  * This function is the same as g_main_context_invoke() except that it
5873  * lets you specify the priority in case @function ends up being
5874  * scheduled as an idle and also lets you give a #GDestroyNotify for @data.
5875  *
5876  * @notify should not assume that it is called from any particular
5877  * thread or with any particular context acquired.
5878  *
5879  * Since: 2.28
5880  **/
5881 void
5882 g_main_context_invoke_full (GMainContext   *context,
5883                             gint            priority,
5884                             GSourceFunc     function,
5885                             gpointer        data,
5886                             GDestroyNotify  notify)
5887 {
5888   g_return_if_fail (function != NULL);
5889 
5890   if (!context)
5891     context = g_main_context_default ();
5892 
5893   if (g_main_context_is_owner (context))
5894     {
5895       while (function (data));
5896       if (notify != NULL)
5897         notify (data);
5898     }
5899 
5900   else
5901     {
5902       GMainContext *thread_default;
5903 
5904       thread_default = g_main_context_get_thread_default ();
5905 
5906       if (!thread_default)
5907         thread_default = g_main_context_default ();
5908 
5909       if (thread_default == context &amp;&amp; g_main_context_acquire (context))
5910         {
5911           while (function (data));
5912 
5913           g_main_context_release (context);
5914 
5915           if (notify != NULL)
5916             notify (data);
5917         }
5918       else
5919         {
5920           GSource *source;
5921 
5922           source = g_idle_source_new ();
5923           g_source_set_priority (source, priority);
5924           g_source_set_callback (source, function, data, notify);
5925           g_source_attach (source, context);
5926           g_source_unref (source);
5927         }
5928     }
5929 }
5930 
5931 static gpointer
5932 glib_worker_main (gpointer data)
5933 {
5934   while (TRUE)
5935     {
5936       g_main_context_iteration (glib_worker_context, TRUE);
5937 
5938 #ifdef G_OS_UNIX
5939       if (any_unix_signal_pending)
5940         dispatch_unix_signals ();
5941 #endif
5942     }
5943 
5944   return NULL; /* worst GCC warning message ever... */
5945 }
5946 
5947 GMainContext *
5948 g_get_worker_context (void)
5949 {
5950   static gsize initialised;
5951 
5952   if (g_once_init_enter (&amp;initialised))
5953     {
5954       /* mask all signals in the worker thread */
5955 #ifdef G_OS_UNIX
5956       sigset_t prev_mask;
5957       sigset_t all;
5958 
5959       sigfillset (&amp;all);
5960       pthread_sigmask (SIG_SETMASK, &amp;all, &amp;prev_mask);
5961 #endif
5962       glib_worker_context = g_main_context_new ();
5963       g_thread_new (&quot;gmain&quot;, glib_worker_main, NULL);
5964 #ifdef G_OS_UNIX
5965       pthread_sigmask (SIG_SETMASK, &amp;prev_mask, NULL);
5966 #endif
5967       g_once_init_leave (&amp;initialised, TRUE);
5968     }
5969 
5970   return glib_worker_context;
5971 }
    </pre>
  </body>
</html>