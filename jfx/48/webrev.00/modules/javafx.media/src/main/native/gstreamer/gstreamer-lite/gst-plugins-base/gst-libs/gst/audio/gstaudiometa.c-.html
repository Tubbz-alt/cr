<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudiometa.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /* GStreamer
  2  * Copyright (C) &lt;2011&gt; Wim Taymans &lt;wim.taymans@gmail.com&gt;
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public
 15  * License along with this library; if not, write to the
 16  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 
 20 /**
 21  * SECTION:gstaudiometa
 22  * @title: GstAudioDownmixMeta
 23  * @short_description: Buffer metadata for audio downmix matrix handling
 24  *
 25  * #GstAudioDownmixMeta defines an audio downmix matrix to be send along with
 26  * audio buffers. These functions in this module help to create and attach the
 27  * meta as well as extracting it.
 28  */
 29 
 30 #include &lt;string.h&gt;
 31 
 32 #include &quot;gstaudiometa.h&quot;
 33 
 34 static gboolean
 35 gst_audio_downmix_meta_init (GstMeta * meta, gpointer params,
 36     GstBuffer * buffer)
 37 {
 38   GstAudioDownmixMeta *dmeta = (GstAudioDownmixMeta *) meta;
 39 
 40   dmeta-&gt;from_position = dmeta-&gt;to_position = NULL;
 41   dmeta-&gt;from_channels = dmeta-&gt;to_channels = 0;
 42   dmeta-&gt;matrix = NULL;
 43 
 44   return TRUE;
 45 }
 46 
 47 static void
 48 gst_audio_downmix_meta_free (GstMeta * meta, GstBuffer * buffer)
 49 {
 50   GstAudioDownmixMeta *dmeta = (GstAudioDownmixMeta *) meta;
 51 
 52   g_free (dmeta-&gt;from_position);
 53   if (dmeta-&gt;matrix) {
 54     g_free (*dmeta-&gt;matrix);
 55     g_free (dmeta-&gt;matrix);
 56   }
 57 }
 58 
 59 static gboolean
 60 gst_audio_downmix_meta_transform (GstBuffer * dest, GstMeta * meta,
 61     GstBuffer * buffer, GQuark type, gpointer data)
 62 {
 63   GstAudioDownmixMeta *smeta, *dmeta;
 64 
 65   smeta = (GstAudioDownmixMeta *) meta;
 66 
 67   if (GST_META_TRANSFORM_IS_COPY (type)) {
 68     dmeta = gst_buffer_add_audio_downmix_meta (dest, smeta-&gt;from_position,
 69       smeta-&gt;from_channels, smeta-&gt;to_position, smeta-&gt;to_channels,
 70       (const gfloat **) smeta-&gt;matrix);
 71     if (!dmeta)
 72       return FALSE;
 73   } else {
 74     /* return FALSE, if transform type is not supported */
 75     return FALSE;
 76   }
 77 
 78   return TRUE;
 79 }
 80 
 81 /**
 82  * gst_buffer_get_audio_downmix_meta_for_channels:
 83  * @buffer: a #GstBuffer
 84  * @to_position: (array length=to_channels): the channel positions of
 85  *   the destination
 86  * @to_channels: The number of channels of the destination
 87  *
 88  * Find the #GstAudioDownmixMeta on @buffer for the given destination
 89  * channel positions.
 90  *
 91  * Returns: (transfer none): the #GstAudioDownmixMeta on @buffer.
 92  */
 93 GstAudioDownmixMeta *
 94 gst_buffer_get_audio_downmix_meta_for_channels (GstBuffer * buffer,
 95     const GstAudioChannelPosition * to_position, gint to_channels)
 96 {
 97   gpointer state = NULL;
 98   GstMeta *meta;
 99   const GstMetaInfo *info = GST_AUDIO_DOWNMIX_META_INFO;
100 
101   while ((meta = gst_buffer_iterate_meta (buffer, &amp;state))) {
102     if (meta-&gt;info-&gt;api == info-&gt;api) {
103       GstAudioDownmixMeta *ameta = (GstAudioDownmixMeta *) meta;
104       if (ameta-&gt;to_channels == to_channels &amp;&amp;
105           memcmp (ameta-&gt;to_position, to_position,
106               sizeof (GstAudioChannelPosition) * to_channels) == 0)
107         return ameta;
108     }
109   }
110   return NULL;
111 }
112 
113 /**
114  * gst_buffer_add_audio_downmix_meta:
115  * @buffer: a #GstBuffer
116  * @from_position: (array length=from_channels): the channel positions
117  *   of the source
118  * @from_channels: The number of channels of the source
119  * @to_position: (array length=to_channels): the channel positions of
120  *   the destination
121  * @to_channels: The number of channels of the destination
122  * @matrix: The matrix coefficients.
123  *
124  * Attaches #GstAudioDownmixMeta metadata to @buffer with the given parameters.
125  *
126  * @matrix is an two-dimensional array of @to_channels times @from_channels
127  * coefficients, i.e. the i-th output channels is constructed by multiplicating
128  * the input channels with the coefficients in @matrix[i] and taking the sum
129  * of the results.
130  *
131  * Returns: (transfer none): the #GstAudioDownmixMeta on @buffer.
132  */
133 GstAudioDownmixMeta *
134 gst_buffer_add_audio_downmix_meta (GstBuffer * buffer,
135     const GstAudioChannelPosition * from_position, gint from_channels,
136     const GstAudioChannelPosition * to_position, gint to_channels,
137     const gfloat ** matrix)
138 {
139   GstAudioDownmixMeta *meta;
140   gint i;
141 
142   g_return_val_if_fail (from_position != NULL, NULL);
143   g_return_val_if_fail (from_channels &gt; 0, NULL);
144   g_return_val_if_fail (to_position != NULL, NULL);
145   g_return_val_if_fail (to_channels &gt; 0, NULL);
146   g_return_val_if_fail (matrix != NULL, NULL);
147 
148   meta =
149       (GstAudioDownmixMeta *) gst_buffer_add_meta (buffer,
150       GST_AUDIO_DOWNMIX_META_INFO, NULL);
151 
152   meta-&gt;from_channels = from_channels;
153   meta-&gt;to_channels = to_channels;
154 
155   meta-&gt;from_position =
156       g_new (GstAudioChannelPosition, meta-&gt;from_channels + meta-&gt;to_channels);
157   meta-&gt;to_position = meta-&gt;from_position + meta-&gt;from_channels;
158   memcpy (meta-&gt;from_position, from_position,
159       sizeof (GstAudioChannelPosition) * meta-&gt;from_channels);
160   memcpy (meta-&gt;to_position, to_position,
161       sizeof (GstAudioChannelPosition) * meta-&gt;to_channels);
162 
163   meta-&gt;matrix = g_new (gfloat *, meta-&gt;to_channels);
164   meta-&gt;matrix[0] = g_new (gfloat, meta-&gt;from_channels * meta-&gt;to_channels);
165   memcpy (meta-&gt;matrix[0], matrix[0], sizeof (gfloat) * meta-&gt;from_channels);
166   for (i = 1; i &lt; meta-&gt;to_channels; i++) {
167     meta-&gt;matrix[i] = meta-&gt;matrix[0] + i * meta-&gt;from_channels;
168     memcpy (meta-&gt;matrix[i], matrix[i], sizeof (gfloat) * meta-&gt;from_channels);
169   }
170 
171   return meta;
172 }
173 
174 GType
175 gst_audio_downmix_meta_api_get_type (void)
176 {
177   static volatile GType type;
178   static const gchar *tags[] =
179       { GST_META_TAG_AUDIO_STR, GST_META_TAG_AUDIO_CHANNELS_STR, NULL };
180 
181   if (g_once_init_enter (&amp;type)) {
182     GType _type = gst_meta_api_type_register (&quot;GstAudioDownmixMetaAPI&quot;, tags);
183     g_once_init_leave (&amp;type, _type);
184   }
185   return type;
186 }
187 
188 const GstMetaInfo *
189 gst_audio_downmix_meta_get_info (void)
190 {
191   static const GstMetaInfo *audio_downmix_meta_info = NULL;
192 
193   if (g_once_init_enter ((GstMetaInfo **) &amp; audio_downmix_meta_info)) {
194     const GstMetaInfo *meta =
195         gst_meta_register (GST_AUDIO_DOWNMIX_META_API_TYPE,
196         &quot;GstAudioDownmixMeta&quot;, sizeof (GstAudioDownmixMeta),
197         gst_audio_downmix_meta_init, gst_audio_downmix_meta_free,
198         gst_audio_downmix_meta_transform);
199     g_once_init_leave ((GstMetaInfo **) &amp; audio_downmix_meta_info,
200         (GstMetaInfo *) meta);
201   }
202   return audio_downmix_meta_info;
203 }
204 
205 static gboolean
206 gst_audio_clipping_meta_init (GstMeta * meta, gpointer params,
207     GstBuffer * buffer)
208 {
209   GstAudioClippingMeta *cmeta = (GstAudioClippingMeta *) meta;
210 
211   cmeta-&gt;format = GST_FORMAT_UNDEFINED;
212   cmeta-&gt;start = cmeta-&gt;end = 0;
213 
214   return TRUE;
215 }
216 
217 static gboolean
218 gst_audio_clipping_meta_transform (GstBuffer * dest, GstMeta * meta,
219     GstBuffer * buffer, GQuark type, gpointer data)
220 {
221   GstAudioClippingMeta *smeta, *dmeta;
222 
223   smeta = (GstAudioClippingMeta *) meta;
224 
225   if (GST_META_TRANSFORM_IS_COPY (type)) {
226     GstMetaTransformCopy *copy = data;
227 
228     if (copy-&gt;region)
229       return FALSE;
230 
231     dmeta =
232         gst_buffer_add_audio_clipping_meta (dest, smeta-&gt;format, smeta-&gt;start,
233         smeta-&gt;end);
234     if (!dmeta)
235       return FALSE;
236   } else {
237     /* TODO: Could implement an automatic transform for resampling */
238     /* return FALSE, if transform type is not supported */
239     return FALSE;
240   }
241 
242   return TRUE;
243 }
244 
245 /**
246  * gst_buffer_add_audio_clipping_meta:
247  * @buffer: a #GstBuffer
248  * @format: GstFormat of @start and @stop, GST_FORMAT_DEFAULT is samples
249  * @start: Amount of audio to clip from start of buffer
250  * @end: Amount of  to clip from end of buffer
251  *
252  * Attaches #GstAudioClippingMeta metadata to @buffer with the given parameters.
253  *
254  * Returns: (transfer none): the #GstAudioClippingMeta on @buffer.
255  *
256  * Since: 1.8
257  */
258 GstAudioClippingMeta *
259 gst_buffer_add_audio_clipping_meta (GstBuffer * buffer,
260     GstFormat format, guint64 start, guint64 end)
261 {
262   GstAudioClippingMeta *meta;
263 
264   g_return_val_if_fail (format != GST_FORMAT_UNDEFINED, NULL);
265 
266   meta =
267       (GstAudioClippingMeta *) gst_buffer_add_meta (buffer,
268       GST_AUDIO_CLIPPING_META_INFO, NULL);
269 
270   meta-&gt;format = format;
271   meta-&gt;start = start;
272   meta-&gt;end = end;
273 
274   return meta;
275 }
276 
277 GType
278 gst_audio_clipping_meta_api_get_type (void)
279 {
280   static volatile GType type;
281   static const gchar *tags[] =
282       { GST_META_TAG_AUDIO_STR, GST_META_TAG_AUDIO_RATE_STR, NULL };
283 
284   if (g_once_init_enter (&amp;type)) {
285     GType _type = gst_meta_api_type_register (&quot;GstAudioClippingMetaAPI&quot;, tags);
286     g_once_init_leave (&amp;type, _type);
287   }
288   return type;
289 }
290 
291 const GstMetaInfo *
292 gst_audio_clipping_meta_get_info (void)
293 {
294   static const GstMetaInfo *audio_clipping_meta_info = NULL;
295 
296   if (g_once_init_enter ((GstMetaInfo **) &amp; audio_clipping_meta_info)) {
297     const GstMetaInfo *meta =
298         gst_meta_register (GST_AUDIO_CLIPPING_META_API_TYPE,
299         &quot;GstAudioClippingMeta&quot;, sizeof (GstAudioClippingMeta),
300         gst_audio_clipping_meta_init, NULL,
301         gst_audio_clipping_meta_transform);
302     g_once_init_leave ((GstMetaInfo **) &amp; audio_clipping_meta_info,
303         (GstMetaInfo *) meta);
304   }
305   return audio_clipping_meta_info;
306 }
    </pre>
  </body>
</html>