<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gnulib/vasnprintf.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* vsprintf with automatic memory allocation.
   2    Copyright (C) 1999, 2002-2016 Free Software Foundation, Inc.
   3 
   4    This program is free software; you can redistribute it and/or modify
   5    it under the terms of the GNU Lesser General Public License as published by
   6    the Free Software Foundation; either version 2.1, or (at your option)
   7    any later version.
   8 
   9    This program is distributed in the hope that it will be useful,
  10    but WITHOUT ANY WARRANTY; without even the implied warranty of
  11    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12    GNU Lesser General Public License for more details.
  13 
  14    You should have received a copy of the GNU Lesser General Public License along
  15    with this program; if not, see &lt;http://www.gnu.org/licenses/&gt;.  */
  16 
  17 /* This file can be parametrized with the following macros:
  18      VASNPRINTF         The name of the function being defined.
  19      FCHAR_T            The element type of the format string.
  20      DCHAR_T            The element type of the destination (result) string.
  21      FCHAR_T_ONLY_ASCII Set to 1 to enable verification that all characters
  22                         in the format string are ASCII. MUST be set if
  23                         FCHAR_T and DCHAR_T are not the same type.
  24      DIRECTIVE          Structure denoting a format directive.
  25                         Depends on FCHAR_T.
  26      DIRECTIVES         Structure denoting the set of format directives of a
  27                         format string.  Depends on FCHAR_T.
  28      PRINTF_PARSE       Function that parses a format string.
  29                         Depends on FCHAR_T.
  30      DCHAR_CPY          memcpy like function for DCHAR_T[] arrays.
  31      DCHAR_SET          memset like function for DCHAR_T[] arrays.
  32      DCHAR_MBSNLEN      mbsnlen like function for DCHAR_T[] arrays.
  33      SNPRINTF           The system&#39;s snprintf (or similar) function.
  34                         This may be either snprintf or swprintf.
  35      TCHAR_T            The element type of the argument and result string
  36                         of the said SNPRINTF function.  This may be either
  37                         char or wchar_t.  The code exploits that
  38                         sizeof (TCHAR_T) | sizeof (DCHAR_T) and
  39                         alignof (TCHAR_T) &lt;= alignof (DCHAR_T).
  40      DCHAR_IS_TCHAR     Set to 1 if DCHAR_T and TCHAR_T are the same type.
  41      DCHAR_CONV_FROM_ENCODING A function to convert from char[] to DCHAR[].
  42      DCHAR_IS_UINT8_T   Set to 1 if DCHAR_T is uint8_t.
  43      DCHAR_IS_UINT16_T  Set to 1 if DCHAR_T is uint16_t.
  44      DCHAR_IS_UINT32_T  Set to 1 if DCHAR_T is uint32_t.  */
  45 
  46 #ifndef _WIN32
  47 /* Tell glibc&#39;s &lt;stdio.h&gt; to provide a prototype for snprintf().
  48    This must come before &lt;config.h&gt; because &lt;config.h&gt; may include
  49    &lt;features.h&gt;, and once &lt;features.h&gt; has been included, it&#39;s too late.  */
  50 #ifndef _GNU_SOURCE
  51 # define _GNU_SOURCE    1
  52 #endif
  53 #endif
  54 
  55 #ifndef VASNPRINTF
  56 # include &lt;config.h&gt;
  57 #endif
  58 /* galloca.h also defines alloca and HAVE_ALLOCA makes the code below use it */
  59 #include &quot;glib/galloca.h&quot;
  60 #define HAVE_ALLOCA 1
  61 
  62 #include &quot;g-gnulib.h&quot;
  63 
  64 /* Specification.  */
  65 #include &quot;vasnprintf.h&quot;
  66 
  67 #include &lt;locale.h&gt;     /* localeconv() */
  68 #include &lt;stdio.h&gt;      /* snprintf(), sprintf() */
  69 #include &lt;stdlib.h&gt;     /* abort(), malloc(), realloc(), free() */
  70 #include &lt;string.h&gt;     /* memcpy(), strlen() */
  71 #include &lt;errno.h&gt;      /* errno */
  72 #include &lt;limits.h&gt;     /* CHAR_BIT */
  73 #include &lt;float.h&gt;      /* DBL_MAX_EXP, LDBL_MAX_EXP */
  74 #  include &quot;printf-parse.h&quot;
  75 
  76 #include &quot;xsize.h&quot;
  77 
  78 #include &quot;verify.h&quot;
  79 
  80 #if (NEED_PRINTF_DOUBLE || NEED_PRINTF_LONG_DOUBLE) &amp;&amp; !defined IN_LIBINTL
  81 # include &lt;math.h&gt;
  82 # include &quot;float+.h&quot;
  83 #endif
  84 
  85 #if (NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE) &amp;&amp; !defined IN_LIBINTL
  86 # include &lt;math.h&gt;
  87 # include &quot;isnand-nolibm.h&quot;
  88 #endif
  89 
  90 #if (NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE) &amp;&amp; !defined IN_LIBINTL
  91 # include &lt;math.h&gt;
  92 # include &quot;isnanl-nolibm.h&quot;
  93 # include &quot;fpucw.h&quot;
  94 #endif
  95 
  96 #if (NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_DOUBLE) &amp;&amp; !defined IN_LIBINTL
  97 # include &lt;math.h&gt;
  98 # include &quot;isnand-nolibm.h&quot;
  99 # include &quot;printf-frexp.h&quot;
 100 #endif
 101 
 102 #if (NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_LONG_DOUBLE) &amp;&amp; !defined IN_LIBINTL
 103 # include &lt;math.h&gt;
 104 # include &quot;isnanl-nolibm.h&quot;
 105 # include &quot;printf-frexpl.h&quot;
 106 # include &quot;fpucw.h&quot;
 107 #endif
 108 
 109 /* Default parameters.  */
 110 #ifndef VASNPRINTF
 111 # if WIDE_CHAR_VERSION
 112 #  define VASNPRINTF vasnwprintf
 113 #  define FCHAR_T wchar_t
 114 #  define DCHAR_T wchar_t
 115 #  define TCHAR_T wchar_t
 116 #  define DCHAR_IS_TCHAR 1
 117 #  define DIRECTIVE wchar_t_directive
 118 #  define DIRECTIVES wchar_t_directives
 119 #  define PRINTF_PARSE wprintf_parse
 120 #  define DCHAR_CPY wmemcpy
 121 #  define DCHAR_SET wmemset
 122 # else
 123 #  define VASNPRINTF vasnprintf
 124 #  define FCHAR_T char
 125 #  define DCHAR_T char
 126 #  define TCHAR_T char
 127 #  define DCHAR_IS_TCHAR 1
 128 #  define DIRECTIVE char_directive
 129 #  define DIRECTIVES char_directives
 130 #  define PRINTF_PARSE printf_parse
 131 #  define DCHAR_CPY memcpy
 132 #  define DCHAR_SET memset
 133 # endif
 134 #endif
 135 #if WIDE_CHAR_VERSION
 136   /* TCHAR_T is wchar_t.  */
 137 # define USE_SNPRINTF 1
 138 # if HAVE_DECL__SNWPRINTF
 139    /* On Windows, the function swprintf() has a different signature than
 140       on Unix; we use the function _snwprintf() or - on mingw - snwprintf()
 141       instead.  The mingw function snwprintf() has fewer bugs than the
 142       MSVCRT function _snwprintf(), so prefer that.  */
 143 #  if defined __MINGW32__
 144 #   define SNPRINTF snwprintf
 145 #  else
 146 #   define SNPRINTF _snwprintf
 147 #  endif
 148 # else
 149    /* Unix.  */
 150 #  define SNPRINTF swprintf
 151 # endif
 152 #else
 153   /* TCHAR_T is char.  */
 154   /* Use snprintf if it exists under the name &#39;snprintf&#39; or &#39;_snprintf&#39;.
 155      But don&#39;t use it on BeOS, since BeOS snprintf produces no output if the
 156      size argument is &gt;= 0x3000000.
 157      Also don&#39;t use it on Linux libc5, since there snprintf with size = 1
 158      writes any output without bounds, like sprintf.  */
 159 # if (HAVE_DECL__SNPRINTF || HAVE_SNPRINTF) &amp;&amp; !defined __BEOS__ &amp;&amp; !(__GNU_LIBRARY__ == 1)
 160 #  define USE_SNPRINTF 1
 161 # else
 162 #  define USE_SNPRINTF 0
 163 # endif
 164 # if HAVE_DECL__SNPRINTF
 165    /* Windows.  The mingw function snprintf() has fewer bugs than the MSVCRT
 166       function _snprintf(), so prefer that.  */
 167 #  if defined __MINGW32__
 168 #   define SNPRINTF snprintf
 169     /* Here we need to call the native snprintf, not rpl_snprintf.  */
 170 #   undef snprintf
 171 #  else
 172 #   define SNPRINTF _snprintf
 173 #  endif
 174 # else
 175    /* Unix.  */
 176 #  define SNPRINTF snprintf
 177    /* Here we need to call the native snprintf, not rpl_snprintf.  */
 178 #  undef snprintf
 179 # endif
 180 #endif
 181 /* Here we need to call the native sprintf, not rpl_sprintf.  */
 182 #undef sprintf
 183 
 184 /* GCC &gt;= 4.0 with -Wall emits unjustified &quot;... may be used uninitialized&quot;
 185    warnings in this file.  Use -Dlint to suppress them.  */
 186 #ifdef lint
 187 # define IF_LINT(Code) Code
 188 #else
 189 # define IF_LINT(Code) /* empty */
 190 #endif
 191 
 192 /* Avoid some warnings from &quot;gcc -Wshadow&quot;.
 193    This file doesn&#39;t use the exp() and remainder() functions.  */
 194 #undef exp
 195 #define exp expo
 196 #undef remainder
 197 #define remainder rem
 198 
 199 #if (!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99) &amp;&amp; !WIDE_CHAR_VERSION
 200 # if (HAVE_STRNLEN &amp;&amp; !defined _AIX)
 201 #  define local_strnlen strnlen
 202 # else
 203 #  ifndef local_strnlen_defined
 204 #   define local_strnlen_defined 1
 205 static size_t
 206 local_strnlen (const char *string, size_t maxlen)
 207 {
 208   const char *end = memchr (string, &#39;\0&#39;, maxlen);
 209   return end ? (size_t) (end - string) : maxlen;
 210 }
 211 #  endif
 212 # endif
 213 #endif
 214 
 215 #if (((!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99) &amp;&amp; WIDE_CHAR_VERSION) || ((!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || (NEED_PRINTF_DIRECTIVE_LS &amp;&amp; !defined IN_LIBINTL)) &amp;&amp; !WIDE_CHAR_VERSION &amp;&amp; DCHAR_IS_TCHAR)) &amp;&amp; HAVE_WCHAR_T
 216 # if HAVE_WCSLEN
 217 #  define local_wcslen wcslen
 218 # else
 219    /* Solaris 2.5.1 has wcslen() in a separate library libw.so. To avoid
 220       a dependency towards this library, here is a local substitute.
 221       Define this substitute only once, even if this file is included
 222       twice in the same compilation unit.  */
 223 #  ifndef local_wcslen_defined
 224 #   define local_wcslen_defined 1
 225 static size_t
 226 local_wcslen (const wchar_t *s)
 227 {
 228   const wchar_t *ptr;
 229 
 230   for (ptr = s; *ptr != (wchar_t) 0; ptr++)
 231     ;
 232   return ptr - s;
 233 }
 234 #  endif
 235 # endif
 236 #endif
 237 
 238 #if (!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99) &amp;&amp; HAVE_WCHAR_T &amp;&amp; WIDE_CHAR_VERSION
 239 # if HAVE_WCSNLEN
 240 #  define local_wcsnlen wcsnlen
 241 # else
 242 #  ifndef local_wcsnlen_defined
 243 #   define local_wcsnlen_defined 1
 244 static size_t
 245 local_wcsnlen (const wchar_t *s, size_t maxlen)
 246 {
 247   const wchar_t *ptr;
 248 
 249   for (ptr = s; maxlen &gt; 0 &amp;&amp; *ptr != (wchar_t) 0; ptr++, maxlen--)
 250     ;
 251   return ptr - s;
 252 }
 253 #  endif
 254 # endif
 255 #endif
 256 
 257 #if (NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE || NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE) &amp;&amp; !defined IN_LIBINTL
 258 /* Determine the decimal-point character according to the current locale.  */
 259 # ifndef decimal_point_char_defined
 260 #  define decimal_point_char_defined 1
 261 static char
 262 decimal_point_char (void)
 263 {
 264   const char *point;
 265   /* Determine it in a multithread-safe way.  We know nl_langinfo is
 266      multithread-safe on glibc systems and Mac OS X systems, but is not required
 267      to be multithread-safe by POSIX.  sprintf(), however, is multithread-safe.
 268      localeconv() is rarely multithread-safe.  */
 269 #  if HAVE_NL_LANGINFO &amp;&amp; (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ &amp;&amp; defined __MACH__))
 270   point = nl_langinfo (RADIXCHAR);
 271 #  elif 1
 272   char pointbuf[5];
 273   sprintf (pointbuf, &quot;%#.0f&quot;, 1.0);
 274   point = &amp;pointbuf[1];
 275 #  else
 276   point = localeconv () -&gt; decimal_point;
 277 #  endif
 278   /* The decimal point is always a single byte: either &#39;.&#39; or &#39;,&#39;.  */
 279   return (point[0] != &#39;\0&#39; ? point[0] : &#39;.&#39;);
 280 }
 281 # endif
 282 #endif
 283 
 284 #if NEED_PRINTF_INFINITE_DOUBLE &amp;&amp; !NEED_PRINTF_DOUBLE &amp;&amp; !defined IN_LIBINTL
 285 
 286 /* Equivalent to !isfinite(x) || x == 0, but does not require libm.  */
 287 static int
 288 is_infinite_or_zero (double x)
 289 {
 290   return isnand (x) || x + x == x;
 291 }
 292 
 293 #endif
 294 
 295 #if NEED_PRINTF_INFINITE_LONG_DOUBLE &amp;&amp; !NEED_PRINTF_LONG_DOUBLE &amp;&amp; !defined IN_LIBINTL
 296 
 297 /* Equivalent to !isfinite(x) || x == 0, but does not require libm.  */
 298 static int
 299 is_infinite_or_zerol (long double x)
 300 {
 301   return isnanl (x) || x + x == x;
 302 }
 303 
 304 #endif
 305 
 306 #if (NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_DOUBLE) &amp;&amp; !defined IN_LIBINTL
 307 
 308 /* Converting &#39;long double&#39; to decimal without rare rounding bugs requires
 309    real bignums.  We use the naming conventions of GNU gmp, but vastly simpler
 310    (and slower) algorithms.  */
 311 
 312 typedef unsigned int mp_limb_t;
 313 # define GMP_LIMB_BITS 32
 314 verify (sizeof (mp_limb_t) * CHAR_BIT == GMP_LIMB_BITS);
 315 
 316 typedef unsigned long long mp_twolimb_t;
 317 # define GMP_TWOLIMB_BITS 64
 318 verify (sizeof (mp_twolimb_t) * CHAR_BIT == GMP_TWOLIMB_BITS);
 319 
 320 /* Representation of a bignum &gt;= 0.  */
 321 typedef struct
 322 {
 323   size_t nlimbs;
 324   mp_limb_t *limbs; /* Bits in little-endian order, allocated with malloc().  */
 325 } mpn_t;
 326 
 327 /* Compute the product of two bignums &gt;= 0.
 328    Return the allocated memory in case of success, NULL in case of memory
 329    allocation failure.  */
 330 static void *
 331 multiply (mpn_t src1, mpn_t src2, mpn_t *dest)
 332 {
 333   const mp_limb_t *p1;
 334   const mp_limb_t *p2;
 335   size_t len1;
 336   size_t len2;
 337 
 338   if (src1.nlimbs &lt;= src2.nlimbs)
 339     {
 340       len1 = src1.nlimbs;
 341       p1 = src1.limbs;
 342       len2 = src2.nlimbs;
 343       p2 = src2.limbs;
 344     }
 345   else
 346     {
 347       len1 = src2.nlimbs;
 348       p1 = src2.limbs;
 349       len2 = src1.nlimbs;
 350       p2 = src1.limbs;
 351     }
 352   /* Now 0 &lt;= len1 &lt;= len2.  */
 353   if (len1 == 0)
 354     {
 355       /* src1 or src2 is zero.  */
 356       dest-&gt;nlimbs = 0;
 357       dest-&gt;limbs = (mp_limb_t *) malloc (1);
 358     }
 359   else
 360     {
 361       /* Here 1 &lt;= len1 &lt;= len2.  */
 362       size_t dlen;
 363       mp_limb_t *dp;
 364       size_t k, i, j;
 365 
 366       dlen = len1 + len2;
 367       dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));
 368       if (dp == NULL)
 369         return NULL;
 370       for (k = len2; k &gt; 0; )
 371         dp[--k] = 0;
 372       for (i = 0; i &lt; len1; i++)
 373         {
 374           mp_limb_t digit1 = p1[i];
 375           mp_twolimb_t carry = 0;
 376           for (j = 0; j &lt; len2; j++)
 377             {
 378               mp_limb_t digit2 = p2[j];
 379               carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;
 380               carry += dp[i + j];
 381               dp[i + j] = (mp_limb_t) carry;
 382               carry = carry &gt;&gt; GMP_LIMB_BITS;
 383             }
 384           dp[i + len2] = (mp_limb_t) carry;
 385         }
 386       /* Normalise.  */
 387       while (dlen &gt; 0 &amp;&amp; dp[dlen - 1] == 0)
 388         dlen--;
 389       dest-&gt;nlimbs = dlen;
 390       dest-&gt;limbs = dp;
 391     }
 392   return dest-&gt;limbs;
 393 }
 394 
 395 /* Compute the quotient of a bignum a &gt;= 0 and a bignum b &gt; 0.
 396    a is written as  a = q * b + r  with 0 &lt;= r &lt; b.  q is the quotient, r
 397    the remainder.
 398    Finally, round-to-even is performed: If r &gt; b/2 or if r = b/2 and q is odd,
 399    q is incremented.
 400    Return the allocated memory in case of success, NULL in case of memory
 401    allocation failure.  */
 402 static void *
 403 divide (mpn_t a, mpn_t b, mpn_t *q)
 404 {
 405   /* Algorithm:
 406      First normalise a and b: a=[a[m-1],...,a[0]], b=[b[n-1],...,b[0]]
 407      with m&gt;=0 and n&gt;0 (in base beta = 2^GMP_LIMB_BITS).
 408      If m&lt;n, then q:=0 and r:=a.
 409      If m&gt;=n=1, perform a single-precision division:
 410        r:=0, j:=m,
 411        while j&gt;0 do
 412          {Here (q[m-1]*beta^(m-1)+...+q[j]*beta^j) * b[0] + r*beta^j =
 413                = a[m-1]*beta^(m-1)+...+a[j]*beta^j und 0&lt;=r&lt;b[0]&lt;beta}
 414          j:=j-1, r:=r*beta+a[j], q[j]:=floor(r/b[0]), r:=r-b[0]*q[j].
 415        Normalise [q[m-1],...,q[0]], yields q.
 416      If m&gt;=n&gt;1, perform a multiple-precision division:
 417        We have a/b &lt; beta^(m-n+1).
 418        s:=intDsize-1-(highest bit in b[n-1]), 0&lt;=s&lt;intDsize.
 419        Shift a and b left by s bits, copying them. r:=a.
 420        r=[r[m],...,r[0]], b=[b[n-1],...,b[0]] with b[n-1]&gt;=beta/2.
 421        For j=m-n,...,0: {Here 0 &lt;= r &lt; b*beta^(j+1).}
 422          Compute q* :
 423            q* := floor((r[j+n]*beta+r[j+n-1])/b[n-1]).
 424            In case of overflow (q* &gt;= beta) set q* := beta-1.
 425            Compute c2 := ((r[j+n]*beta+r[j+n-1]) - q* * b[n-1])*beta + r[j+n-2]
 426            and c3 := b[n-2] * q*.
 427            {We have 0 &lt;= c2 &lt; 2*beta^2, even 0 &lt;= c2 &lt; beta^2 if no overflow
 428             occurred.  Furthermore 0 &lt;= c3 &lt; beta^2.
 429             If there was overflow and
 430             r[j+n]*beta+r[j+n-1] - q* * b[n-1] &gt;= beta, i.e. c2 &gt;= beta^2,
 431             the next test can be skipped.}
 432            While c3 &gt; c2, {Here 0 &lt;= c2 &lt; c3 &lt; beta^2}
 433              Put q* := q* - 1, c2 := c2 + b[n-1]*beta, c3 := c3 - b[n-2].
 434            If q* &gt; 0:
 435              Put r := r - b * q* * beta^j. In detail:
 436                [r[n+j],...,r[j]] := [r[n+j],...,r[j]] - q* * [b[n-1],...,b[0]].
 437                hence: u:=0, for i:=0 to n-1 do
 438                               u := u + q* * b[i],
 439                               r[j+i]:=r[j+i]-(u mod beta) (+ beta, if carry),
 440                               u:=u div beta (+ 1, if carry in subtraction)
 441                       r[n+j]:=r[n+j]-u.
 442                {Since always u = (q* * [b[i-1],...,b[0]] div beta^i) + 1
 443                                &lt; q* + 1 &lt;= beta,
 444                 the carry u does not overflow.}
 445              If a negative carry occurs, put q* := q* - 1
 446                and [r[n+j],...,r[j]] := [r[n+j],...,r[j]] + [0,b[n-1],...,b[0]].
 447          Set q[j] := q*.
 448        Normalise [q[m-n],..,q[0]]; this yields the quotient q.
 449        Shift [r[n-1],...,r[0]] right by s bits and normalise; this yields the
 450        rest r.
 451        The room for q[j] can be allocated at the memory location of r[n+j].
 452      Finally, round-to-even:
 453        Shift r left by 1 bit.
 454        If r &gt; b or if r = b and q[0] is odd, q := q+1.
 455    */
 456   const mp_limb_t *a_ptr = a.limbs;
 457   size_t a_len = a.nlimbs;
 458   const mp_limb_t *b_ptr = b.limbs;
 459   size_t b_len = b.nlimbs;
 460   mp_limb_t *roomptr;
 461   mp_limb_t *tmp_roomptr = NULL;
 462   mp_limb_t *q_ptr;
 463   size_t q_len;
 464   mp_limb_t *r_ptr;
 465   size_t r_len;
 466 
 467   /* Allocate room for a_len+2 digits.
 468      (Need a_len+1 digits for the real division and 1 more digit for the
 469      final rounding of q.)  */
 470   roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));
 471   if (roomptr == NULL)
 472     return NULL;
 473 
 474   /* Normalise a.  */
 475   while (a_len &gt; 0 &amp;&amp; a_ptr[a_len - 1] == 0)
 476     a_len--;
 477 
 478   /* Normalise b.  */
 479   for (;;)
 480     {
 481       if (b_len == 0)
 482         /* Division by zero.  */
 483         abort ();
 484       if (b_ptr[b_len - 1] == 0)
 485         b_len--;
 486       else
 487         break;
 488     }
 489 
 490   /* Here m = a_len &gt;= 0 and n = b_len &gt; 0.  */
 491 
 492   if (a_len &lt; b_len)
 493     {
 494       /* m&lt;n: trivial case.  q=0, r := copy of a.  */
 495       r_ptr = roomptr;
 496       r_len = a_len;
 497       memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));
 498       q_ptr = roomptr + a_len;
 499       q_len = 0;
 500     }
 501   else if (b_len == 1)
 502     {
 503       /* n=1: single precision division.
 504          beta^(m-1) &lt;= a &lt; beta^m  ==&gt;  beta^(m-2) &lt;= a/b &lt; beta^m  */
 505       r_ptr = roomptr;
 506       q_ptr = roomptr + 1;
 507       {
 508         mp_limb_t den = b_ptr[0];
 509         mp_limb_t remainder = 0;
 510         const mp_limb_t *sourceptr = a_ptr + a_len;
 511         mp_limb_t *destptr = q_ptr + a_len;
 512         size_t count;
 513         for (count = a_len; count &gt; 0; count--)
 514           {
 515             mp_twolimb_t num =
 516               ((mp_twolimb_t) remainder &lt;&lt; GMP_LIMB_BITS) | *--sourceptr;
 517             *--destptr = num / den;
 518             remainder = num % den;
 519           }
 520         /* Normalise and store r.  */
 521         if (remainder &gt; 0)
 522           {
 523             r_ptr[0] = remainder;
 524             r_len = 1;
 525           }
 526         else
 527           r_len = 0;
 528         /* Normalise q.  */
 529         q_len = a_len;
 530         if (q_ptr[q_len - 1] == 0)
 531           q_len--;
 532       }
 533     }
 534   else
 535     {
 536       /* n&gt;1: multiple precision division.
 537          beta^(m-1) &lt;= a &lt; beta^m, beta^(n-1) &lt;= b &lt; beta^n  ==&gt;
 538          beta^(m-n-1) &lt;= a/b &lt; beta^(m-n+1).  */
 539       /* Determine s.  */
 540       size_t s;
 541       {
 542         mp_limb_t msd = b_ptr[b_len - 1]; /* = b[n-1], &gt; 0 */
 543         /* Determine s = GMP_LIMB_BITS - integer_length (msd).
 544            Code copied from gnulib&#39;s integer_length.c.  */
 545 # if __GNUC__ &gt; 3 || (__GNUC__ == 3 &amp;&amp; __GNUC_MINOR__ &gt;= 4)
 546         s = __builtin_clz (msd);
 547 # else
 548 #  if defined DBL_EXPBIT0_WORD &amp;&amp; defined DBL_EXPBIT0_BIT
 549         if (GMP_LIMB_BITS &lt;= DBL_MANT_BIT)
 550           {
 551             /* Use &#39;double&#39; operations.
 552                Assumes an IEEE 754 &#39;double&#39; implementation.  */
 553 #   define DBL_EXP_MASK ((DBL_MAX_EXP - DBL_MIN_EXP) | 7)
 554 #   define DBL_EXP_BIAS (DBL_EXP_MASK / 2 - 1)
 555 #   define NWORDS \
 556      ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))
 557             union { double value; unsigned int word[NWORDS]; } m;
 558 
 559             /* Use a single integer to floating-point conversion.  */
 560             m.value = msd;
 561 
 562             s = GMP_LIMB_BITS
 563                 - (((m.word[DBL_EXPBIT0_WORD] &gt;&gt; DBL_EXPBIT0_BIT) &amp; DBL_EXP_MASK)
 564                    - DBL_EXP_BIAS);
 565           }
 566         else
 567 #   undef NWORDS
 568 #  endif
 569           {
 570             s = 31;
 571             if (msd &gt;= 0x10000)
 572               {
 573                 msd = msd &gt;&gt; 16;
 574                 s -= 16;
 575               }
 576             if (msd &gt;= 0x100)
 577               {
 578                 msd = msd &gt;&gt; 8;
 579                 s -= 8;
 580               }
 581             if (msd &gt;= 0x10)
 582               {
 583                 msd = msd &gt;&gt; 4;
 584                 s -= 4;
 585               }
 586             if (msd &gt;= 0x4)
 587               {
 588                 msd = msd &gt;&gt; 2;
 589                 s -= 2;
 590               }
 591             if (msd &gt;= 0x2)
 592               {
 593                 msd = msd &gt;&gt; 1;
 594                 s -= 1;
 595               }
 596           }
 597 # endif
 598       }
 599       /* 0 &lt;= s &lt; GMP_LIMB_BITS.
 600          Copy b, shifting it left by s bits.  */
 601       if (s &gt; 0)
 602         {
 603           tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));
 604           if (tmp_roomptr == NULL)
 605             {
 606               free (roomptr);
 607               return NULL;
 608             }
 609           {
 610             const mp_limb_t *sourceptr = b_ptr;
 611             mp_limb_t *destptr = tmp_roomptr;
 612             mp_twolimb_t accu = 0;
 613             size_t count;
 614             for (count = b_len; count &gt; 0; count--)
 615               {
 616                 accu += (mp_twolimb_t) *sourceptr++ &lt;&lt; s;
 617                 *destptr++ = (mp_limb_t) accu;
 618                 accu = accu &gt;&gt; GMP_LIMB_BITS;
 619               }
 620             /* accu must be zero, since that was how s was determined.  */
 621             if (accu != 0)
 622               abort ();
 623           }
 624           b_ptr = tmp_roomptr;
 625         }
 626       /* Copy a, shifting it left by s bits, yields r.
 627          Memory layout:
 628          At the beginning: r = roomptr[0..a_len],
 629          at the end: r = roomptr[0..b_len-1], q = roomptr[b_len..a_len]  */
 630       r_ptr = roomptr;
 631       if (s == 0)
 632         {
 633           memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));
 634           r_ptr[a_len] = 0;
 635         }
 636       else
 637         {
 638           const mp_limb_t *sourceptr = a_ptr;
 639           mp_limb_t *destptr = r_ptr;
 640           mp_twolimb_t accu = 0;
 641           size_t count;
 642           for (count = a_len; count &gt; 0; count--)
 643             {
 644               accu += (mp_twolimb_t) *sourceptr++ &lt;&lt; s;
 645               *destptr++ = (mp_limb_t) accu;
 646               accu = accu &gt;&gt; GMP_LIMB_BITS;
 647             }
 648           *destptr++ = (mp_limb_t) accu;
 649         }
 650       q_ptr = roomptr + b_len;
 651       q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */
 652       {
 653         size_t j = a_len - b_len; /* m-n */
 654         mp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */
 655         mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */
 656         mp_twolimb_t b_msdd = /* b[n-1]*beta+b[n-2] */
 657           ((mp_twolimb_t) b_msd &lt;&lt; GMP_LIMB_BITS) | b_2msd;
 658         /* Division loop, traversed m-n+1 times.
 659            j counts down, b is unchanged, beta/2 &lt;= b[n-1] &lt; beta.  */
 660         for (;;)
 661           {
 662             mp_limb_t q_star;
 663             mp_limb_t c1;
 664             if (r_ptr[j + b_len] &lt; b_msd) /* r[j+n] &lt; b[n-1] ? */
 665               {
 666                 /* Divide r[j+n]*beta+r[j+n-1] by b[n-1], no overflow.  */
 667                 mp_twolimb_t num =
 668                   ((mp_twolimb_t) r_ptr[j + b_len] &lt;&lt; GMP_LIMB_BITS)
 669                   | r_ptr[j + b_len - 1];
 670                 q_star = num / b_msd;
 671                 c1 = num % b_msd;
 672               }
 673             else
 674               {
 675                 /* Overflow, hence r[j+n]*beta+r[j+n-1] &gt;= beta*b[n-1].  */
 676                 q_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */
 677                 /* Test whether r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] &gt;= beta
 678                    &lt;==&gt; r[j+n]*beta+r[j+n-1] + b[n-1] &gt;= beta*b[n-1]+beta
 679                    &lt;==&gt; b[n-1] &lt; floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta)
 680                         {&lt;= beta !}.
 681                    If yes, jump directly to the subtraction loop.
 682                    (Otherwise, r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] &lt; beta
 683                     &lt;==&gt; floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta) = b[n-1] ) */
 684                 if (r_ptr[j + b_len] &gt; b_msd
 685                     || (c1 = r_ptr[j + b_len - 1] + b_msd) &lt; b_msd)
 686                   /* r[j+n] &gt;= b[n-1]+1 or
 687                      r[j+n] = b[n-1] and the addition r[j+n-1]+b[n-1] gives a
 688                      carry.  */
 689                   goto subtract;
 690               }
 691             /* q_star = q*,
 692                c1 = (r[j+n]*beta+r[j+n-1]) - q* * b[n-1] (&gt;=0, &lt;beta).  */
 693             {
 694               mp_twolimb_t c2 = /* c1*beta+r[j+n-2] */
 695                 ((mp_twolimb_t) c1 &lt;&lt; GMP_LIMB_BITS) | r_ptr[j + b_len - 2];
 696               mp_twolimb_t c3 = /* b[n-2] * q* */
 697                 (mp_twolimb_t) b_2msd * (mp_twolimb_t) q_star;
 698               /* While c2 &lt; c3, increase c2 and decrease c3.
 699                  Consider c3-c2.  While it is &gt; 0, decrease it by
 700                  b[n-1]*beta+b[n-2].  Because of b[n-1]*beta+b[n-2] &gt;= beta^2/2
 701                  this can happen only twice.  */
 702               if (c3 &gt; c2)
 703                 {
 704                   q_star = q_star - 1; /* q* := q* - 1 */
 705                   if (c3 - c2 &gt; b_msdd)
 706                     q_star = q_star - 1; /* q* := q* - 1 */
 707                 }
 708             }
 709             if (q_star &gt; 0)
 710               subtract:
 711               {
 712                 /* Subtract r := r - b * q* * beta^j.  */
 713                 mp_limb_t cr;
 714                 {
 715                   const mp_limb_t *sourceptr = b_ptr;
 716                   mp_limb_t *destptr = r_ptr + j;
 717                   mp_twolimb_t carry = 0;
 718                   size_t count;
 719                   for (count = b_len; count &gt; 0; count--)
 720                     {
 721                       /* Here 0 &lt;= carry &lt;= q*.  */
 722                       carry =
 723                         carry
 724                         + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++
 725                         + (mp_limb_t) ~(*destptr);
 726                       /* Here 0 &lt;= carry &lt;= beta*q* + beta-1.  */
 727                       *destptr++ = ~(mp_limb_t) carry;
 728                       carry = carry &gt;&gt; GMP_LIMB_BITS; /* &lt;= q* */
 729                     }
 730                   cr = (mp_limb_t) carry;
 731                 }
 732                 /* Subtract cr from r_ptr[j + b_len], then forget about
 733                    r_ptr[j + b_len].  */
 734                 if (cr &gt; r_ptr[j + b_len])
 735                   {
 736                     /* Subtraction gave a carry.  */
 737                     q_star = q_star - 1; /* q* := q* - 1 */
 738                     /* Add b back.  */
 739                     {
 740                       const mp_limb_t *sourceptr = b_ptr;
 741                       mp_limb_t *destptr = r_ptr + j;
 742                       mp_limb_t carry = 0;
 743                       size_t count;
 744                       for (count = b_len; count &gt; 0; count--)
 745                         {
 746                           mp_limb_t source1 = *sourceptr++;
 747                           mp_limb_t source2 = *destptr;
 748                           *destptr++ = source1 + source2 + carry;
 749                           carry =
 750                             (carry
 751                              ? source1 &gt;= (mp_limb_t) ~source2
 752                              : source1 &gt; (mp_limb_t) ~source2);
 753                         }
 754                     }
 755                     /* Forget about the carry and about r[j+n].  */
 756                   }
 757               }
 758             /* q* is determined.  Store it as q[j].  */
 759             q_ptr[j] = q_star;
 760             if (j == 0)
 761               break;
 762             j--;
 763           }
 764       }
 765       r_len = b_len;
 766       /* Normalise q.  */
 767       if (q_ptr[q_len - 1] == 0)
 768         q_len--;
 769 # if 0 /* Not needed here, since we need r only to compare it with b/2, and
 770           b is shifted left by s bits.  */
 771       /* Shift r right by s bits.  */
 772       if (s &gt; 0)
 773         {
 774           mp_limb_t ptr = r_ptr + r_len;
 775           mp_twolimb_t accu = 0;
 776           size_t count;
 777           for (count = r_len; count &gt; 0; count--)
 778             {
 779               accu = (mp_twolimb_t) (mp_limb_t) accu &lt;&lt; GMP_LIMB_BITS;
 780               accu += (mp_twolimb_t) *--ptr &lt;&lt; (GMP_LIMB_BITS - s);
 781               *ptr = (mp_limb_t) (accu &gt;&gt; GMP_LIMB_BITS);
 782             }
 783         }
 784 # endif
 785       /* Normalise r.  */
 786       while (r_len &gt; 0 &amp;&amp; r_ptr[r_len - 1] == 0)
 787         r_len--;
 788     }
 789   /* Compare r &lt;&lt; 1 with b.  */
 790   if (r_len &gt; b_len)
 791     goto increment_q;
 792   {
 793     size_t i;
 794     for (i = b_len;;)
 795       {
 796         mp_limb_t r_i =
 797           (i &lt;= r_len &amp;&amp; i &gt; 0 ? r_ptr[i - 1] &gt;&gt; (GMP_LIMB_BITS - 1) : 0)
 798           | (i &lt; r_len ? r_ptr[i] &lt;&lt; 1 : 0);
 799         mp_limb_t b_i = (i &lt; b_len ? b_ptr[i] : 0);
 800         if (r_i &gt; b_i)
 801           goto increment_q;
 802         if (r_i &lt; b_i)
 803           goto keep_q;
 804         if (i == 0)
 805           break;
 806         i--;
 807       }
 808   }
 809   if (q_len &gt; 0 &amp;&amp; ((q_ptr[0] &amp; 1) != 0))
 810     /* q is odd.  */
 811     increment_q:
 812     {
 813       size_t i;
 814       for (i = 0; i &lt; q_len; i++)
 815         if (++(q_ptr[i]) != 0)
 816           goto keep_q;
 817       q_ptr[q_len++] = 1;
 818     }
 819   keep_q:
 820   if (tmp_roomptr != NULL)
 821     free (tmp_roomptr);
 822   q-&gt;limbs = q_ptr;
 823   q-&gt;nlimbs = q_len;
 824   return roomptr;
 825 }
 826 
 827 /* Convert a bignum a &gt;= 0, multiplied with 10^extra_zeroes, to decimal
 828    representation.
 829    Destroys the contents of a.
 830    Return the allocated memory - containing the decimal digits in low-to-high
 831    order, terminated with a NUL character - in case of success, NULL in case
 832    of memory allocation failure.  */
 833 static char *
 834 convert_to_decimal (mpn_t a, size_t extra_zeroes)
 835 {
 836   mp_limb_t *a_ptr = a.limbs;
 837   size_t a_len = a.nlimbs;
 838   /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */
 839   size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);
 840   char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));
 841   if (c_ptr != NULL)
 842     {
 843       char *d_ptr = c_ptr;
 844       for (; extra_zeroes &gt; 0; extra_zeroes--)
 845         *d_ptr++ = &#39;0&#39;;
 846       while (a_len &gt; 0)
 847         {
 848           /* Divide a by 10^9, in-place.  */
 849           mp_limb_t remainder = 0;
 850           mp_limb_t *ptr = a_ptr + a_len;
 851           size_t count;
 852           for (count = a_len; count &gt; 0; count--)
 853             {
 854               mp_twolimb_t num =
 855                 ((mp_twolimb_t) remainder &lt;&lt; GMP_LIMB_BITS) | *--ptr;
 856               *ptr = num / 1000000000;
 857               remainder = num % 1000000000;
 858             }
 859           /* Store the remainder as 9 decimal digits.  */
 860           for (count = 9; count &gt; 0; count--)
 861             {
 862               *d_ptr++ = &#39;0&#39; + (remainder % 10);
 863               remainder = remainder / 10;
 864             }
 865           /* Normalize a.  */
 866           if (a_ptr[a_len - 1] == 0)
 867             a_len--;
 868         }
 869       /* Remove leading zeroes.  */
 870       while (d_ptr &gt; c_ptr &amp;&amp; d_ptr[-1] == &#39;0&#39;)
 871         d_ptr--;
 872       /* But keep at least one zero.  */
 873       if (d_ptr == c_ptr)
 874         *d_ptr++ = &#39;0&#39;;
 875       /* Terminate the string.  */
 876       *d_ptr = &#39;\0&#39;;
 877     }
 878   return c_ptr;
 879 }
 880 
 881 # if NEED_PRINTF_LONG_DOUBLE
 882 
 883 /* Assuming x is finite and &gt;= 0:
 884    write x as x = 2^e * m, where m is a bignum.
 885    Return the allocated memory in case of success, NULL in case of memory
 886    allocation failure.  */
 887 static void *
 888 decode_long_double (long double x, int *ep, mpn_t *mp)
 889 {
 890   mpn_t m;
 891   int exp;
 892   long double y;
 893   size_t i;
 894 
 895   /* Allocate memory for result.  */
 896   m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;
 897   m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));
 898   if (m.limbs == NULL)
 899     return NULL;
 900   /* Split into exponential part and mantissa.  */
 901   y = frexpl (x, &amp;exp);
 902   if (!(y &gt;= 0.0L &amp;&amp; y &lt; 1.0L))
 903     abort ();
 904   /* x = 2^exp * y = 2^(exp - LDBL_MANT_BIT) * (y * 2^LDBL_MANT_BIT), and the
 905      latter is an integer.  */
 906   /* Convert the mantissa (y * 2^LDBL_MANT_BIT) to a sequence of limbs.
 907      I&#39;m not sure whether it&#39;s safe to cast a &#39;long double&#39; value between
 908      2^31 and 2^32 to &#39;unsigned int&#39;, therefore play safe and cast only
 909      &#39;long double&#39; values between 0 and 2^16 (to &#39;unsigned int&#39; or &#39;int&#39;,
 910      doesn&#39;t matter).  */
 911 #  if (LDBL_MANT_BIT % GMP_LIMB_BITS) != 0
 912 #   if (LDBL_MANT_BIT % GMP_LIMB_BITS) &gt; GMP_LIMB_BITS / 2
 913     {
 914       mp_limb_t hi, lo;
 915       y *= (mp_limb_t) 1 &lt;&lt; (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));
 916       hi = (int) y;
 917       y -= hi;
 918       if (!(y &gt;= 0.0L &amp;&amp; y &lt; 1.0L))
 919         abort ();
 920       y *= (mp_limb_t) 1 &lt;&lt; (GMP_LIMB_BITS / 2);
 921       lo = (int) y;
 922       y -= lo;
 923       if (!(y &gt;= 0.0L &amp;&amp; y &lt; 1.0L))
 924         abort ();
 925       m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi &lt;&lt; (GMP_LIMB_BITS / 2)) | lo;
 926     }
 927 #   else
 928     {
 929       mp_limb_t d;
 930       y *= (mp_limb_t) 1 &lt;&lt; (LDBL_MANT_BIT % GMP_LIMB_BITS);
 931       d = (int) y;
 932       y -= d;
 933       if (!(y &gt;= 0.0L &amp;&amp; y &lt; 1.0L))
 934         abort ();
 935       m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = d;
 936     }
 937 #   endif
 938 #  endif
 939   for (i = LDBL_MANT_BIT / GMP_LIMB_BITS; i &gt; 0; )
 940     {
 941       mp_limb_t hi, lo;
 942       y *= (mp_limb_t) 1 &lt;&lt; (GMP_LIMB_BITS / 2);
 943       hi = (int) y;
 944       y -= hi;
 945       if (!(y &gt;= 0.0L &amp;&amp; y &lt; 1.0L))
 946         abort ();
 947       y *= (mp_limb_t) 1 &lt;&lt; (GMP_LIMB_BITS / 2);
 948       lo = (int) y;
 949       y -= lo;
 950       if (!(y &gt;= 0.0L &amp;&amp; y &lt; 1.0L))
 951         abort ();
 952       m.limbs[--i] = (hi &lt;&lt; (GMP_LIMB_BITS / 2)) | lo;
 953     }
 954 #  if 0 /* On FreeBSD 6.1/x86, &#39;long double&#39; numbers sometimes have excess
 955            precision.  */
 956   if (!(y == 0.0L))
 957     abort ();
 958 #  endif
 959   /* Normalise.  */
 960   while (m.nlimbs &gt; 0 &amp;&amp; m.limbs[m.nlimbs - 1] == 0)
 961     m.nlimbs--;
 962   *mp = m;
 963   *ep = exp - LDBL_MANT_BIT;
 964   return m.limbs;
 965 }
 966 
 967 # endif
 968 
 969 # if NEED_PRINTF_DOUBLE
 970 
 971 /* Assuming x is finite and &gt;= 0:
 972    write x as x = 2^e * m, where m is a bignum.
 973    Return the allocated memory in case of success, NULL in case of memory
 974    allocation failure.  */
 975 static void *
 976 decode_double (double x, int *ep, mpn_t *mp)
 977 {
 978   mpn_t m;
 979   int exp;
 980   double y;
 981   size_t i;
 982 
 983   /* Allocate memory for result.  */
 984   m.nlimbs = (DBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;
 985   m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));
 986   if (m.limbs == NULL)
 987     return NULL;
 988   /* Split into exponential part and mantissa.  */
 989   y = frexp (x, &amp;exp);
 990   if (!(y &gt;= 0.0 &amp;&amp; y &lt; 1.0))
 991     abort ();
 992   /* x = 2^exp * y = 2^(exp - DBL_MANT_BIT) * (y * 2^DBL_MANT_BIT), and the
 993      latter is an integer.  */
 994   /* Convert the mantissa (y * 2^DBL_MANT_BIT) to a sequence of limbs.
 995      I&#39;m not sure whether it&#39;s safe to cast a &#39;double&#39; value between
 996      2^31 and 2^32 to &#39;unsigned int&#39;, therefore play safe and cast only
 997      &#39;double&#39; values between 0 and 2^16 (to &#39;unsigned int&#39; or &#39;int&#39;,
 998      doesn&#39;t matter).  */
 999 #  if (DBL_MANT_BIT % GMP_LIMB_BITS) != 0
1000 #   if (DBL_MANT_BIT % GMP_LIMB_BITS) &gt; GMP_LIMB_BITS / 2
1001     {
1002       mp_limb_t hi, lo;
1003       y *= (mp_limb_t) 1 &lt;&lt; (DBL_MANT_BIT % (GMP_LIMB_BITS / 2));
1004       hi = (int) y;
1005       y -= hi;
1006       if (!(y &gt;= 0.0 &amp;&amp; y &lt; 1.0))
1007         abort ();
1008       y *= (mp_limb_t) 1 &lt;&lt; (GMP_LIMB_BITS / 2);
1009       lo = (int) y;
1010       y -= lo;
1011       if (!(y &gt;= 0.0 &amp;&amp; y &lt; 1.0))
1012         abort ();
1013       m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi &lt;&lt; (GMP_LIMB_BITS / 2)) | lo;
1014     }
1015 #   else
1016     {
1017       mp_limb_t d;
1018       y *= (mp_limb_t) 1 &lt;&lt; (DBL_MANT_BIT % GMP_LIMB_BITS);
1019       d = (int) y;
1020       y -= d;
1021       if (!(y &gt;= 0.0 &amp;&amp; y &lt; 1.0))
1022         abort ();
1023       m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = d;
1024     }
1025 #   endif
1026 #  endif
1027   for (i = DBL_MANT_BIT / GMP_LIMB_BITS; i &gt; 0; )
1028     {
1029       mp_limb_t hi, lo;
1030       y *= (mp_limb_t) 1 &lt;&lt; (GMP_LIMB_BITS / 2);
1031       hi = (int) y;
1032       y -= hi;
1033       if (!(y &gt;= 0.0 &amp;&amp; y &lt; 1.0))
1034         abort ();
1035       y *= (mp_limb_t) 1 &lt;&lt; (GMP_LIMB_BITS / 2);
1036       lo = (int) y;
1037       y -= lo;
1038       if (!(y &gt;= 0.0 &amp;&amp; y &lt; 1.0))
1039         abort ();
1040       m.limbs[--i] = (hi &lt;&lt; (GMP_LIMB_BITS / 2)) | lo;
1041     }
1042   if (!(y == 0.0))
1043     abort ();
1044   /* Normalise.  */
1045   while (m.nlimbs &gt; 0 &amp;&amp; m.limbs[m.nlimbs - 1] == 0)
1046     m.nlimbs--;
1047   *mp = m;
1048   *ep = exp - DBL_MANT_BIT;
1049   return m.limbs;
1050 }
1051 
1052 # endif
1053 
1054 /* Assuming x = 2^e * m is finite and &gt;= 0, and n is an integer:
1055    Returns the decimal representation of round (x * 10^n).
1056    Return the allocated memory - containing the decimal digits in low-to-high
1057    order, terminated with a NUL character - in case of success, NULL in case
1058    of memory allocation failure.  */
1059 static char *
1060 scale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)
1061 {
1062   int s;
1063   size_t extra_zeroes;
1064   unsigned int abs_n;
1065   unsigned int abs_s;
1066   mp_limb_t *pow5_ptr;
1067   size_t pow5_len;
1068   unsigned int s_limbs;
1069   unsigned int s_bits;
1070   mpn_t pow5;
1071   mpn_t z;
1072   void *z_memory;
1073   char *digits;
1074 
1075   if (memory == NULL)
1076     return NULL;
1077   /* x = 2^e * m, hence
1078      y = round (2^e * 10^n * m) = round (2^(e+n) * 5^n * m)
1079        = round (2^s * 5^n * m).  */
1080   s = e + n;
1081   extra_zeroes = 0;
1082   /* Factor out a common power of 10 if possible.  */
1083   if (s &gt; 0 &amp;&amp; n &gt; 0)
1084     {
1085       extra_zeroes = (s &lt; n ? s : n);
1086       s -= extra_zeroes;
1087       n -= extra_zeroes;
1088     }
1089   /* Here y = round (2^s * 5^n * m) * 10^extra_zeroes.
1090      Before converting to decimal, we need to compute
1091      z = round (2^s * 5^n * m).  */
1092   /* Compute 5^|n|, possibly shifted by |s| bits if n and s have the same
1093      sign.  2.322 is slightly larger than log(5)/log(2).  */
1094   abs_n = (n &gt;= 0 ? n : -n);
1095   abs_s = (s &gt;= 0 ? s : -s);
1096   pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1
1097                                     + abs_s / GMP_LIMB_BITS + 1)
1098                                    * sizeof (mp_limb_t));
1099   if (pow5_ptr == NULL)
1100     {
1101       free (memory);
1102       return NULL;
1103     }
1104   /* Initialize with 1.  */
1105   pow5_ptr[0] = 1;
1106   pow5_len = 1;
1107   /* Multiply with 5^|n|.  */
1108   if (abs_n &gt; 0)
1109     {
1110       static mp_limb_t const small_pow5[13 + 1] =
1111         {
1112           1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625,
1113           48828125, 244140625, 1220703125
1114         };
1115       unsigned int n13;
1116       for (n13 = 0; n13 &lt;= abs_n; n13 += 13)
1117         {
1118           mp_limb_t digit1 = small_pow5[n13 + 13 &lt;= abs_n ? 13 : abs_n - n13];
1119           size_t j;
1120           mp_twolimb_t carry = 0;
1121           for (j = 0; j &lt; pow5_len; j++)
1122             {
1123               mp_limb_t digit2 = pow5_ptr[j];
1124               carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;
1125               pow5_ptr[j] = (mp_limb_t) carry;
1126               carry = carry &gt;&gt; GMP_LIMB_BITS;
1127             }
1128           if (carry &gt; 0)
1129             pow5_ptr[pow5_len++] = (mp_limb_t) carry;
1130         }
1131     }
1132   s_limbs = abs_s / GMP_LIMB_BITS;
1133   s_bits = abs_s % GMP_LIMB_BITS;
1134   if (n &gt;= 0 ? s &gt;= 0 : s &lt;= 0)
1135     {
1136       /* Multiply with 2^|s|.  */
1137       if (s_bits &gt; 0)
1138         {
1139           mp_limb_t *ptr = pow5_ptr;
1140           mp_twolimb_t accu = 0;
1141           size_t count;
1142           for (count = pow5_len; count &gt; 0; count--)
1143             {
1144               accu += (mp_twolimb_t) *ptr &lt;&lt; s_bits;
1145               *ptr++ = (mp_limb_t) accu;
1146               accu = accu &gt;&gt; GMP_LIMB_BITS;
1147             }
1148           if (accu &gt; 0)
1149             {
1150               *ptr = (mp_limb_t) accu;
1151               pow5_len++;
1152             }
1153         }
1154       if (s_limbs &gt; 0)
1155         {
1156           size_t count;
1157           for (count = pow5_len; count &gt; 0;)
1158             {
1159               count--;
1160               pow5_ptr[s_limbs + count] = pow5_ptr[count];
1161             }
1162           for (count = s_limbs; count &gt; 0;)
1163             {
1164               count--;
1165               pow5_ptr[count] = 0;
1166             }
1167           pow5_len += s_limbs;
1168         }
1169       pow5.limbs = pow5_ptr;
1170       pow5.nlimbs = pow5_len;
1171       if (n &gt;= 0)
1172         {
1173           /* Multiply m with pow5.  No division needed.  */
1174           z_memory = multiply (m, pow5, &amp;z);
1175         }
1176       else
1177         {
1178           /* Divide m by pow5 and round.  */
1179           z_memory = divide (m, pow5, &amp;z);
1180         }
1181     }
1182   else
1183     {
1184       pow5.limbs = pow5_ptr;
1185       pow5.nlimbs = pow5_len;
1186       if (n &gt;= 0)
1187         {
1188           /* n &gt;= 0, s &lt; 0.
1189              Multiply m with pow5, then divide by 2^|s|.  */
1190           mpn_t numerator;
1191           mpn_t denominator;
1192           void *tmp_memory;
1193           tmp_memory = multiply (m, pow5, &amp;numerator);
1194           if (tmp_memory == NULL)
1195             {
1196               free (pow5_ptr);
1197               free (memory);
1198               return NULL;
1199             }
1200           /* Construct 2^|s|.  */
1201           {
1202             mp_limb_t *ptr = pow5_ptr + pow5_len;
1203             size_t i;
1204             for (i = 0; i &lt; s_limbs; i++)
1205               ptr[i] = 0;
1206             ptr[s_limbs] = (mp_limb_t) 1 &lt;&lt; s_bits;
1207             denominator.limbs = ptr;
1208             denominator.nlimbs = s_limbs + 1;
1209           }
1210           z_memory = divide (numerator, denominator, &amp;z);
1211           free (tmp_memory);
1212         }
1213       else
1214         {
1215           /* n &lt; 0, s &gt; 0.
1216              Multiply m with 2^s, then divide by pow5.  */
1217           mpn_t numerator;
1218           mp_limb_t *num_ptr;
1219           num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)
1220                                           * sizeof (mp_limb_t));
1221           if (num_ptr == NULL)
1222             {
1223               free (pow5_ptr);
1224               free (memory);
1225               return NULL;
1226             }
1227           {
1228             mp_limb_t *destptr = num_ptr;
1229             {
1230               size_t i;
1231               for (i = 0; i &lt; s_limbs; i++)
1232                 *destptr++ = 0;
1233             }
1234             if (s_bits &gt; 0)
1235               {
1236                 const mp_limb_t *sourceptr = m.limbs;
1237                 mp_twolimb_t accu = 0;
1238                 size_t count;
1239                 for (count = m.nlimbs; count &gt; 0; count--)
1240                   {
1241                     accu += (mp_twolimb_t) *sourceptr++ &lt;&lt; s_bits;
1242                     *destptr++ = (mp_limb_t) accu;
1243                     accu = accu &gt;&gt; GMP_LIMB_BITS;
1244                   }
1245                 if (accu &gt; 0)
1246                   *destptr++ = (mp_limb_t) accu;
1247               }
1248             else
1249               {
1250                 const mp_limb_t *sourceptr = m.limbs;
1251                 size_t count;
1252                 for (count = m.nlimbs; count &gt; 0; count--)
1253                   *destptr++ = *sourceptr++;
1254               }
1255             numerator.limbs = num_ptr;
1256             numerator.nlimbs = destptr - num_ptr;
1257           }
1258           z_memory = divide (numerator, pow5, &amp;z);
1259           free (num_ptr);
1260         }
1261     }
1262   free (pow5_ptr);
1263   free (memory);
1264 
1265   /* Here y = round (x * 10^n) = z * 10^extra_zeroes.  */
1266 
1267   if (z_memory == NULL)
1268     return NULL;
1269   digits = convert_to_decimal (z, extra_zeroes);
1270   free (z_memory);
1271   return digits;
1272 }
1273 
1274 # if NEED_PRINTF_LONG_DOUBLE
1275 
1276 /* Assuming x is finite and &gt;= 0, and n is an integer:
1277    Returns the decimal representation of round (x * 10^n).
1278    Return the allocated memory - containing the decimal digits in low-to-high
1279    order, terminated with a NUL character - in case of success, NULL in case
1280    of memory allocation failure.  */
1281 static char *
1282 scale10_round_decimal_long_double (long double x, int n)
1283 {
1284   int e IF_LINT(= 0);
1285   mpn_t m;
1286   void *memory = decode_long_double (x, &amp;e, &amp;m);
1287   return scale10_round_decimal_decoded (e, m, memory, n);
1288 }
1289 
1290 # endif
1291 
1292 # if NEED_PRINTF_DOUBLE
1293 
1294 /* Assuming x is finite and &gt;= 0, and n is an integer:
1295    Returns the decimal representation of round (x * 10^n).
1296    Return the allocated memory - containing the decimal digits in low-to-high
1297    order, terminated with a NUL character - in case of success, NULL in case
1298    of memory allocation failure.  */
1299 static char *
1300 scale10_round_decimal_double (double x, int n)
1301 {
1302   int e IF_LINT(= 0);
1303   mpn_t m;
1304   void *memory = decode_double (x, &amp;e, &amp;m);
1305   return scale10_round_decimal_decoded (e, m, memory, n);
1306 }
1307 
1308 # endif
1309 
1310 # if NEED_PRINTF_LONG_DOUBLE
1311 
1312 /* Assuming x is finite and &gt; 0:
1313    Return an approximation for n with 10^n &lt;= x &lt; 10^(n+1).
1314    The approximation is usually the right n, but may be off by 1 sometimes.  */
1315 static int
1316 floorlog10l (long double x)
1317 {
1318   int exp;
1319   long double y;
1320   double z;
1321   double l;
1322 
1323   /* Split into exponential part and mantissa.  */
1324   y = frexpl (x, &amp;exp);
1325   if (!(y &gt;= 0.0L &amp;&amp; y &lt; 1.0L))
1326     abort ();
1327   if (y == 0.0L)
1328     return INT_MIN;
1329   if (y &lt; 0.5L)
1330     {
1331       while (y &lt; (1.0L / (1 &lt;&lt; (GMP_LIMB_BITS / 2)) / (1 &lt;&lt; (GMP_LIMB_BITS / 2))))
1332         {
1333           y *= 1.0L * (1 &lt;&lt; (GMP_LIMB_BITS / 2)) * (1 &lt;&lt; (GMP_LIMB_BITS / 2));
1334           exp -= GMP_LIMB_BITS;
1335         }
1336       if (y &lt; (1.0L / (1 &lt;&lt; 16)))
1337         {
1338           y *= 1.0L * (1 &lt;&lt; 16);
1339           exp -= 16;
1340         }
1341       if (y &lt; (1.0L / (1 &lt;&lt; 8)))
1342         {
1343           y *= 1.0L * (1 &lt;&lt; 8);
1344           exp -= 8;
1345         }
1346       if (y &lt; (1.0L / (1 &lt;&lt; 4)))
1347         {
1348           y *= 1.0L * (1 &lt;&lt; 4);
1349           exp -= 4;
1350         }
1351       if (y &lt; (1.0L / (1 &lt;&lt; 2)))
1352         {
1353           y *= 1.0L * (1 &lt;&lt; 2);
1354           exp -= 2;
1355         }
1356       if (y &lt; (1.0L / (1 &lt;&lt; 1)))
1357         {
1358           y *= 1.0L * (1 &lt;&lt; 1);
1359           exp -= 1;
1360         }
1361     }
1362   if (!(y &gt;= 0.5L &amp;&amp; y &lt; 1.0L))
1363     abort ();
1364   /* Compute an approximation for l = log2(x) = exp + log2(y).  */
1365   l = exp;
1366   z = y;
1367   if (z &lt; 0.70710678118654752444)
1368     {
1369       z *= 1.4142135623730950488;
1370       l -= 0.5;
1371     }
1372   if (z &lt; 0.8408964152537145431)
1373     {
1374       z *= 1.1892071150027210667;
1375       l -= 0.25;
1376     }
1377   if (z &lt; 0.91700404320467123175)
1378     {
1379       z *= 1.0905077326652576592;
1380       l -= 0.125;
1381     }
1382   if (z &lt; 0.9576032806985736469)
1383     {
1384       z *= 1.0442737824274138403;
1385       l -= 0.0625;
1386     }
1387   /* Now 0.95 &lt;= z &lt;= 1.01.  */
1388   z = 1 - z;
1389   /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)
1390      Four terms are enough to get an approximation with error &lt; 10^-7.  */
1391   l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));
1392   /* Finally multiply with log(2)/log(10), yields an approximation for
1393      log10(x).  */
1394   l *= 0.30102999566398119523;
1395   /* Round down to the next integer.  */
1396   return (int) l + (l &lt; 0 ? -1 : 0);
1397 }
1398 
1399 # endif
1400 
1401 # if NEED_PRINTF_DOUBLE
1402 
1403 /* Assuming x is finite and &gt; 0:
1404    Return an approximation for n with 10^n &lt;= x &lt; 10^(n+1).
1405    The approximation is usually the right n, but may be off by 1 sometimes.  */
1406 static int
1407 floorlog10 (double x)
1408 {
1409   int exp;
1410   double y;
1411   double z;
1412   double l;
1413 
1414   /* Split into exponential part and mantissa.  */
1415   y = frexp (x, &amp;exp);
1416   if (!(y &gt;= 0.0 &amp;&amp; y &lt; 1.0))
1417     abort ();
1418   if (y == 0.0)
1419     return INT_MIN;
1420   if (y &lt; 0.5)
1421     {
1422       while (y &lt; (1.0 / (1 &lt;&lt; (GMP_LIMB_BITS / 2)) / (1 &lt;&lt; (GMP_LIMB_BITS / 2))))
1423         {
1424           y *= 1.0 * (1 &lt;&lt; (GMP_LIMB_BITS / 2)) * (1 &lt;&lt; (GMP_LIMB_BITS / 2));
1425           exp -= GMP_LIMB_BITS;
1426         }
1427       if (y &lt; (1.0 / (1 &lt;&lt; 16)))
1428         {
1429           y *= 1.0 * (1 &lt;&lt; 16);
1430           exp -= 16;
1431         }
1432       if (y &lt; (1.0 / (1 &lt;&lt; 8)))
1433         {
1434           y *= 1.0 * (1 &lt;&lt; 8);
1435           exp -= 8;
1436         }
1437       if (y &lt; (1.0 / (1 &lt;&lt; 4)))
1438         {
1439           y *= 1.0 * (1 &lt;&lt; 4);
1440           exp -= 4;
1441         }
1442       if (y &lt; (1.0 / (1 &lt;&lt; 2)))
1443         {
1444           y *= 1.0 * (1 &lt;&lt; 2);
1445           exp -= 2;
1446         }
1447       if (y &lt; (1.0 / (1 &lt;&lt; 1)))
1448         {
1449           y *= 1.0 * (1 &lt;&lt; 1);
1450           exp -= 1;
1451         }
1452     }
1453   if (!(y &gt;= 0.5 &amp;&amp; y &lt; 1.0))
1454     abort ();
1455   /* Compute an approximation for l = log2(x) = exp + log2(y).  */
1456   l = exp;
1457   z = y;
1458   if (z &lt; 0.70710678118654752444)
1459     {
1460       z *= 1.4142135623730950488;
1461       l -= 0.5;
1462     }
1463   if (z &lt; 0.8408964152537145431)
1464     {
1465       z *= 1.1892071150027210667;
1466       l -= 0.25;
1467     }
1468   if (z &lt; 0.91700404320467123175)
1469     {
1470       z *= 1.0905077326652576592;
1471       l -= 0.125;
1472     }
1473   if (z &lt; 0.9576032806985736469)
1474     {
1475       z *= 1.0442737824274138403;
1476       l -= 0.0625;
1477     }
1478   /* Now 0.95 &lt;= z &lt;= 1.01.  */
1479   z = 1 - z;
1480   /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)
1481      Four terms are enough to get an approximation with error &lt; 10^-7.  */
1482   l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));
1483   /* Finally multiply with log(2)/log(10), yields an approximation for
1484      log10(x).  */
1485   l *= 0.30102999566398119523;
1486   /* Round down to the next integer.  */
1487   return (int) l + (l &lt; 0 ? -1 : 0);
1488 }
1489 
1490 # endif
1491 
1492 /* Tests whether a string of digits consists of exactly PRECISION zeroes and
1493    a single &#39;1&#39; digit.  */
1494 static int
1495 is_borderline (const char *digits, size_t precision)
1496 {
1497   for (; precision &gt; 0; precision--, digits++)
1498     if (*digits != &#39;0&#39;)
1499       return 0;
1500   if (*digits != &#39;1&#39;)
1501     return 0;
1502   digits++;
1503   return *digits == &#39;\0&#39;;
1504 }
1505 
1506 #endif
1507 
1508 #if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99
1509 
1510 /* Use a different function name, to make it possible that the &#39;wchar_t&#39;
1511    parametrization and the &#39;char&#39; parametrization get compiled in the same
1512    translation unit.  */
1513 # if WIDE_CHAR_VERSION
1514 #  define MAX_ROOM_NEEDED wmax_room_needed
1515 # else
1516 #  define MAX_ROOM_NEEDED max_room_needed
1517 # endif
1518 
1519 /* Returns the number of TCHAR_T units needed as temporary space for the result
1520    of sprintf or SNPRINTF of a single conversion directive.  */
1521 static size_t
1522 MAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,
1523                  arg_type type, int flags, size_t width, int has_precision,
1524                  size_t precision, int pad_ourselves)
1525 {
1526   size_t tmp_length;
1527 
1528   switch (conversion)
1529     {
1530     case &#39;d&#39;: case &#39;i&#39;: case &#39;u&#39;:
1531 # if HAVE_LONG_LONG
1532       if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)
1533         tmp_length =
1534           (unsigned int) (sizeof (unsigned long long) * CHAR_BIT
1535                           * 0.30103 /* binary -&gt; decimal */
1536                          )
1537           + 1; /* turn floor into ceil */
1538       else
1539 # endif
1540       if (type == TYPE_LONGINT || type == TYPE_ULONGINT)
1541         tmp_length =
1542           (unsigned int) (sizeof (unsigned long) * CHAR_BIT
1543                           * 0.30103 /* binary -&gt; decimal */
1544                          )
1545           + 1; /* turn floor into ceil */
1546       else
1547         tmp_length =
1548           (unsigned int) (sizeof (unsigned int) * CHAR_BIT
1549                           * 0.30103 /* binary -&gt; decimal */
1550                          )
1551           + 1; /* turn floor into ceil */
1552       if (tmp_length &lt; precision)
1553         tmp_length = precision;
1554       /* Multiply by 2, as an estimate for FLAG_GROUP.  */
1555       tmp_length = xsum (tmp_length, tmp_length);
1556       /* Add 1, to account for a leading sign.  */
1557       tmp_length = xsum (tmp_length, 1);
1558       break;
1559 
1560     case &#39;o&#39;:
1561 # if HAVE_LONG_LONG
1562       if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)
1563         tmp_length =
1564           (unsigned int) (sizeof (unsigned long long) * CHAR_BIT
1565                           * 0.333334 /* binary -&gt; octal */
1566                          )
1567           + 1; /* turn floor into ceil */
1568       else
1569 # endif
1570       if (type == TYPE_LONGINT || type == TYPE_ULONGINT)
1571         tmp_length =
1572           (unsigned int) (sizeof (unsigned long) * CHAR_BIT
1573                           * 0.333334 /* binary -&gt; octal */
1574                          )
1575           + 1; /* turn floor into ceil */
1576       else
1577         tmp_length =
1578           (unsigned int) (sizeof (unsigned int) * CHAR_BIT
1579                           * 0.333334 /* binary -&gt; octal */
1580                          )
1581           + 1; /* turn floor into ceil */
1582       if (tmp_length &lt; precision)
1583         tmp_length = precision;
1584       /* Add 1, to account for a leading sign.  */
1585       tmp_length = xsum (tmp_length, 1);
1586       break;
1587 
1588     case &#39;x&#39;: case &#39;X&#39;:
1589 # if HAVE_LONG_LONG
1590       if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)
1591         tmp_length =
1592           (unsigned int) (sizeof (unsigned long long) * CHAR_BIT
1593                           * 0.25 /* binary -&gt; hexadecimal */
1594                          )
1595           + 1; /* turn floor into ceil */
1596       else
1597 # endif
1598       if (type == TYPE_LONGINT || type == TYPE_ULONGINT)
1599         tmp_length =
1600           (unsigned int) (sizeof (unsigned long) * CHAR_BIT
1601                           * 0.25 /* binary -&gt; hexadecimal */
1602                          )
1603           + 1; /* turn floor into ceil */
1604       else
1605         tmp_length =
1606           (unsigned int) (sizeof (unsigned int) * CHAR_BIT
1607                           * 0.25 /* binary -&gt; hexadecimal */
1608                          )
1609           + 1; /* turn floor into ceil */
1610       if (tmp_length &lt; precision)
1611         tmp_length = precision;
1612       /* Add 2, to account for a leading sign or alternate form.  */
1613       tmp_length = xsum (tmp_length, 2);
1614       break;
1615 
1616     case &#39;f&#39;: case &#39;F&#39;:
1617       if (type == TYPE_LONGDOUBLE)
1618         tmp_length =
1619           (unsigned int) (LDBL_MAX_EXP
1620                           * 0.30103 /* binary -&gt; decimal */
1621                           * 2 /* estimate for FLAG_GROUP */
1622                          )
1623           + 1 /* turn floor into ceil */
1624           + 10; /* sign, decimal point etc. */
1625       else
1626         tmp_length =
1627           (unsigned int) (DBL_MAX_EXP
1628                           * 0.30103 /* binary -&gt; decimal */
1629                           * 2 /* estimate for FLAG_GROUP */
1630                          )
1631           + 1 /* turn floor into ceil */
1632           + 10; /* sign, decimal point etc. */
1633       tmp_length = xsum (tmp_length, precision);
1634       break;
1635 
1636     case &#39;e&#39;: case &#39;E&#39;: case &#39;g&#39;: case &#39;G&#39;:
1637       tmp_length =
1638         12; /* sign, decimal point, exponent etc. */
1639       tmp_length = xsum (tmp_length, precision);
1640       break;
1641 
1642     case &#39;a&#39;: case &#39;A&#39;:
1643       if (type == TYPE_LONGDOUBLE)
1644         tmp_length =
1645           (unsigned int) (LDBL_DIG
1646                           * 0.831 /* decimal -&gt; hexadecimal */
1647                          )
1648           + 1; /* turn floor into ceil */
1649       else
1650         tmp_length =
1651           (unsigned int) (DBL_DIG
1652                           * 0.831 /* decimal -&gt; hexadecimal */
1653                          )
1654           + 1; /* turn floor into ceil */
1655       if (tmp_length &lt; precision)
1656         tmp_length = precision;
1657       /* Account for sign, decimal point etc. */
1658       tmp_length = xsum (tmp_length, 12);
1659       break;
1660 
1661     case &#39;c&#39;:
1662 # if HAVE_WINT_T &amp;&amp; !WIDE_CHAR_VERSION
1663       if (type == TYPE_WIDE_CHAR)
1664         tmp_length = MB_CUR_MAX;
1665       else
1666 # endif
1667         tmp_length = 1;
1668       break;
1669 
1670     case &#39;s&#39;:
1671 # if HAVE_WCHAR_T
1672       if (type == TYPE_WIDE_STRING)
1673         {
1674 #  if WIDE_CHAR_VERSION
1675           /* ISO C says about %ls in fwprintf:
1676                &quot;If the precision is not specified or is greater than the size
1677                 of the array, the array shall contain a null wide character.&quot;
1678              So if there is a precision, we must not use wcslen.  */
1679           const wchar_t *arg = ap-&gt;arg[arg_index].a.a_wide_string;
1680 
1681           if (has_precision)
1682             tmp_length = local_wcsnlen (arg, precision);
1683           else
1684             tmp_length = local_wcslen (arg);
1685 #  else
1686           /* ISO C says about %ls in fprintf:
1687                &quot;If a precision is specified, no more than that many bytes are
1688                 written (including shift sequences, if any), and the array
1689                 shall contain a null wide character if, to equal the multibyte
1690                 character sequence length given by the precision, the function
1691                 would need to access a wide character one past the end of the
1692                 array.&quot;
1693              So if there is a precision, we must not use wcslen.  */
1694           /* This case has already been handled separately in VASNPRINTF.  */
1695           abort ();
1696 #  endif
1697         }
1698       else
1699 # endif
1700         {
1701 # if WIDE_CHAR_VERSION
1702           /* ISO C says about %s in fwprintf:
1703                &quot;If the precision is not specified or is greater than the size
1704                 of the converted array, the converted array shall contain a
1705                 null wide character.&quot;
1706              So if there is a precision, we must not use strlen.  */
1707           /* This case has already been handled separately in VASNPRINTF.  */
1708           abort ();
1709 # else
1710           /* ISO C says about %s in fprintf:
1711                &quot;If the precision is not specified or greater than the size of
1712                 the array, the array shall contain a null character.&quot;
1713              So if there is a precision, we must not use strlen.  */
1714           const char *arg = ap-&gt;arg[arg_index].a.a_string;
1715 
1716           if (has_precision)
1717             tmp_length = local_strnlen (arg, precision);
1718           else
1719             tmp_length = strlen (arg);
1720 # endif
1721         }
1722       break;
1723 
1724     case &#39;p&#39;:
1725       tmp_length =
1726         (unsigned int) (sizeof (void *) * CHAR_BIT
1727                         * 0.25 /* binary -&gt; hexadecimal */
1728                        )
1729           + 1 /* turn floor into ceil */
1730           + 2; /* account for leading 0x */
1731       break;
1732 
1733     default:
1734       abort ();
1735     }
1736 
1737   if (!pad_ourselves)
1738     {
1739 # if ENABLE_UNISTDIO
1740       /* Padding considers the number of characters, therefore the number of
1741          elements after padding may be
1742            &gt; max (tmp_length, width)
1743          but is certainly
1744            &lt;= tmp_length + width.  */
1745       tmp_length = xsum (tmp_length, width);
1746 # else
1747       /* Padding considers the number of elements, says POSIX.  */
1748       if (tmp_length &lt; width)
1749         tmp_length = width;
1750 # endif
1751     }
1752 
1753   tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */
1754 
1755   return tmp_length;
1756 }
1757 
1758 #endif
1759 
1760 DCHAR_T *
1761 VASNPRINTF (DCHAR_T *resultbuf, size_t *lengthp,
1762             const FCHAR_T *format, va_list args)
1763 {
1764   DIRECTIVES d;
1765   arguments a;
1766 
1767   if (PRINTF_PARSE (format, &amp;d, &amp;a) &lt; 0)
1768     /* errno is already set.  */
1769     return NULL;
1770 
1771 #define CLEANUP() \
1772   if (d.dir != d.direct_alloc_dir)                                      \
1773     free (d.dir);                                                       \
1774   if (a.arg != a.direct_alloc_arg)                                      \
1775     free (a.arg);
1776 
1777   if (PRINTF_FETCHARGS (args, &amp;a) &lt; 0)
1778     {
1779       CLEANUP ();
1780       errno = EINVAL;
1781       return NULL;
1782     }
1783 
1784   {
1785     size_t buf_neededlength;
1786     TCHAR_T *buf;
1787     TCHAR_T *buf_malloced;
1788     const FCHAR_T *cp;
1789     size_t i;
1790     DIRECTIVE *dp;
1791     /* Output string accumulator.  */
1792     DCHAR_T *result;
1793     size_t allocated;
1794     size_t length;
1795 
1796     /* Allocate a small buffer that will hold a directive passed to
1797        sprintf or snprintf.  */
1798     buf_neededlength =
1799       xsum4 (7, d.max_width_length, d.max_precision_length, 6);
1800 #if HAVE_ALLOCA
1801     if (buf_neededlength &lt; 4000 / sizeof (TCHAR_T))
1802       {
1803         buf = (TCHAR_T *) alloca (buf_neededlength * sizeof (TCHAR_T));
1804         buf_malloced = NULL;
1805       }
1806     else
1807 #endif
1808       {
1809         size_t buf_memsize = xtimes (buf_neededlength, sizeof (TCHAR_T));
1810         if (size_overflow_p (buf_memsize))
1811           goto out_of_memory_1;
1812         buf = (TCHAR_T *) malloc (buf_memsize);
1813         if (buf == NULL)
1814           goto out_of_memory_1;
1815         buf_malloced = buf;
1816       }
1817 
1818     if (resultbuf != NULL)
1819       {
1820         result = resultbuf;
1821         allocated = *lengthp;
1822       }
1823     else
1824       {
1825         result = NULL;
1826         allocated = 0;
1827       }
1828     length = 0;
1829     /* Invariants:
1830        result is either == resultbuf or == NULL or malloc-allocated.
1831        If length &gt; 0, then result != NULL.  */
1832 
1833     /* Ensures that allocated &gt;= needed.  Aborts through a jump to
1834        out_of_memory if needed is SIZE_MAX or otherwise too big.  */
1835 #define ENSURE_ALLOCATION(needed) \
1836     if ((needed) &gt; allocated)                                                \
1837       {                                                                      \
1838         size_t memory_size;                                                  \
1839         DCHAR_T *memory;                                                     \
1840                                                                              \
1841         allocated = (allocated &gt; 0 ? xtimes (allocated, 2) : 12);            \
1842         if ((needed) &gt; allocated)                                            \
1843           allocated = (needed);                                              \
1844         memory_size = xtimes (allocated, sizeof (DCHAR_T));                  \
1845         if (size_overflow_p (memory_size))                                   \
1846           goto out_of_memory;                                                \
1847         if (result == resultbuf || result == NULL)                           \
1848           memory = (DCHAR_T *) malloc (memory_size);                         \
1849         else                                                                 \
1850           memory = (DCHAR_T *) realloc (result, memory_size);                \
1851         if (memory == NULL)                                                  \
1852           goto out_of_memory;                                                \
1853         if (result == resultbuf &amp;&amp; length &gt; 0)                               \
1854           DCHAR_CPY (memory, result, length);                                \
1855         result = memory;                                                     \
1856       }
1857 
1858     for (cp = format, i = 0, dp = &amp;d.dir[0]; ; cp = dp-&gt;dir_end, i++, dp++)
1859       {
1860         if (cp != dp-&gt;dir_start)
1861           {
1862             size_t n = dp-&gt;dir_start - cp;
1863             size_t augmented_length = xsum (length, n);
1864 
1865             ENSURE_ALLOCATION (augmented_length);
1866             /* This copies a piece of FCHAR_T[] into a DCHAR_T[].  Here we
1867                need that the format string contains only ASCII characters
1868                if FCHAR_T and DCHAR_T are not the same type.  */
1869             if (sizeof (FCHAR_T) == sizeof (DCHAR_T))
1870               {
1871                 DCHAR_CPY (result + length, (const DCHAR_T *) cp, n);
1872                 length = augmented_length;
1873               }
1874             else
1875               {
1876                 do
1877                   result[length++] = *cp++;
1878                 while (--n &gt; 0);
1879               }
1880           }
1881         if (i == d.count)
1882           break;
1883 
1884         /* Execute a single directive.  */
1885         if (dp-&gt;conversion == &#39;%&#39;)
1886           {
1887             size_t augmented_length;
1888 
1889             if (!(dp-&gt;arg_index == ARG_NONE))
1890               abort ();
1891             augmented_length = xsum (length, 1);
1892             ENSURE_ALLOCATION (augmented_length);
1893             result[length] = &#39;%&#39;;
1894             length = augmented_length;
1895           }
1896         else
1897           {
1898             if (!(dp-&gt;arg_index != ARG_NONE))
1899               abort ();
1900 
1901             if (dp-&gt;conversion == &#39;n&#39;)
1902               {
1903                 switch (a.arg[dp-&gt;arg_index].type)
1904                   {
1905                   case TYPE_COUNT_SCHAR_POINTER:
1906                     *a.arg[dp-&gt;arg_index].a.a_count_schar_pointer = length;
1907                     break;
1908                   case TYPE_COUNT_SHORT_POINTER:
1909                     *a.arg[dp-&gt;arg_index].a.a_count_short_pointer = length;
1910                     break;
1911                   case TYPE_COUNT_INT_POINTER:
1912                     *a.arg[dp-&gt;arg_index].a.a_count_int_pointer = length;
1913                     break;
1914                   case TYPE_COUNT_LONGINT_POINTER:
1915                     *a.arg[dp-&gt;arg_index].a.a_count_longint_pointer = length;
1916                     break;
1917 #if HAVE_LONG_LONG
1918                   case TYPE_COUNT_LONGLONGINT_POINTER:
1919                     *a.arg[dp-&gt;arg_index].a.a_count_longlongint_pointer = length;
1920                     break;
1921 #endif
1922                   default:
1923                     abort ();
1924                   }
1925               }
1926 #if ENABLE_UNISTDIO
1927             /* The unistdio extensions.  */
1928             else if (dp-&gt;conversion == &#39;U&#39;)
1929               {
1930                 arg_type type = a.arg[dp-&gt;arg_index].type;
1931                 int flags = dp-&gt;flags;
1932                 int has_width;
1933                 size_t width;
1934                 int has_precision;
1935                 size_t precision;
1936 
1937                 has_width = 0;
1938                 width = 0;
1939                 if (dp-&gt;width_start != dp-&gt;width_end)
1940                   {
1941                     if (dp-&gt;width_arg_index != ARG_NONE)
1942                       {
1943                         int arg;
1944 
1945                         if (!(a.arg[dp-&gt;width_arg_index].type == TYPE_INT))
1946                           abort ();
1947                         arg = a.arg[dp-&gt;width_arg_index].a.a_int;
1948                         width = arg;
1949                         if (arg &lt; 0)
1950                           {
1951                             /* &quot;A negative field width is taken as a &#39;-&#39; flag
1952                                 followed by a positive field width.&quot;  */
1953                             flags |= FLAG_LEFT;
1954                             width = -width;
1955                           }
1956                       }
1957                     else
1958                       {
1959                         const FCHAR_T *digitp = dp-&gt;width_start;
1960 
1961                         do
1962                           width = xsum (xtimes (width, 10), *digitp++ - &#39;0&#39;);
1963                         while (digitp != dp-&gt;width_end);
1964                       }
1965                     has_width = 1;
1966                   }
1967 
1968                 has_precision = 0;
1969                 precision = 0;
1970                 if (dp-&gt;precision_start != dp-&gt;precision_end)
1971                   {
1972                     if (dp-&gt;precision_arg_index != ARG_NONE)
1973                       {
1974                         int arg;
1975 
1976                         if (!(a.arg[dp-&gt;precision_arg_index].type == TYPE_INT))
1977                           abort ();
1978                         arg = a.arg[dp-&gt;precision_arg_index].a.a_int;
1979                         /* &quot;A negative precision is taken as if the precision
1980                             were omitted.&quot;  */
1981                         if (arg &gt;= 0)
1982                           {
1983                             precision = arg;
1984                             has_precision = 1;
1985                           }
1986                       }
1987                     else
1988                       {
1989                         const FCHAR_T *digitp = dp-&gt;precision_start + 1;
1990 
1991                         precision = 0;
1992                         while (digitp != dp-&gt;precision_end)
1993                           precision = xsum (xtimes (precision, 10), *digitp++ - &#39;0&#39;);
1994                         has_precision = 1;
1995                       }
1996                   }
1997 
1998                 switch (type)
1999                   {
2000                   case TYPE_U8_STRING:
2001                     {
2002                       const uint8_t *arg = a.arg[dp-&gt;arg_index].a.a_u8_string;
2003                       const uint8_t *arg_end;
2004                       size_t characters;
2005 
2006                       if (has_precision)
2007                         {
2008                           /* Use only PRECISION characters, from the left.  */
2009                           arg_end = arg;
2010                           characters = 0;
2011                           for (; precision &gt; 0; precision--)
2012                             {
2013                               int count = u8_strmblen (arg_end);
2014                               if (count == 0)
2015                                 break;
2016                               if (count &lt; 0)
2017                                 {
2018                                   if (!(result == resultbuf || result == NULL))
2019                                     free (result);
2020                                   if (buf_malloced != NULL)
2021                                     free (buf_malloced);
2022                                   CLEANUP ();
2023                                   errno = EILSEQ;
2024                                   return NULL;
2025                                 }
2026                               arg_end += count;
2027                               characters++;
2028                             }
2029                         }
2030                       else if (has_width)
2031                         {
2032                           /* Use the entire string, and count the number of
2033                              characters.  */
2034                           arg_end = arg;
2035                           characters = 0;
2036                           for (;;)
2037                             {
2038                               int count = u8_strmblen (arg_end);
2039                               if (count == 0)
2040                                 break;
2041                               if (count &lt; 0)
2042                                 {
2043                                   if (!(result == resultbuf || result == NULL))
2044                                     free (result);
2045                                   if (buf_malloced != NULL)
2046                                     free (buf_malloced);
2047                                   CLEANUP ();
2048                                   errno = EILSEQ;
2049                                   return NULL;
2050                                 }
2051                               arg_end += count;
2052                               characters++;
2053                             }
2054                         }
2055                       else
2056                         {
2057                           /* Use the entire string.  */
2058                           arg_end = arg + u8_strlen (arg);
2059                           /* The number of characters doesn&#39;t matter.  */
2060                           characters = 0;
2061                         }
2062 
2063                       if (characters &lt; width &amp;&amp; !(dp-&gt;flags &amp; FLAG_LEFT))
2064                         {
2065                           size_t n = width - characters;
2066                           ENSURE_ALLOCATION (xsum (length, n));
2067                           DCHAR_SET (result + length, &#39; &#39;, n);
2068                           length += n;
2069                         }
2070 
2071 # if DCHAR_IS_UINT8_T
2072                       {
2073                         size_t n = arg_end - arg;
2074                         ENSURE_ALLOCATION (xsum (length, n));
2075                         DCHAR_CPY (result + length, arg, n);
2076                         length += n;
2077                       }
2078 # else
2079                       { /* Convert.  */
2080                         DCHAR_T *converted = result + length;
2081                         size_t converted_len = allocated - length;
2082 #  if DCHAR_IS_TCHAR
2083                         /* Convert from UTF-8 to locale encoding.  */
2084                         converted =
2085                           u8_conv_to_encoding (locale_charset (),
2086                                                iconveh_question_mark,
2087                                                arg, arg_end - arg, NULL,
2088                                                converted, &amp;converted_len);
2089 #  else
2090                         /* Convert from UTF-8 to UTF-16/UTF-32.  */
2091                         converted =
2092                           U8_TO_DCHAR (arg, arg_end - arg,
2093                                        converted, &amp;converted_len);
2094 #  endif
2095                         if (converted == NULL)
2096                           {
2097                             int saved_errno = errno;
2098                             if (!(result == resultbuf || result == NULL))
2099                               free (result);
2100                             if (buf_malloced != NULL)
2101                               free (buf_malloced);
2102                             CLEANUP ();
2103                             errno = saved_errno;
2104                             return NULL;
2105                           }
2106                         if (converted != result + length)
2107                           {
2108                             ENSURE_ALLOCATION (xsum (length, converted_len));
2109                             DCHAR_CPY (result + length, converted, converted_len);
2110                             free (converted);
2111                           }
2112                         length += converted_len;
2113                       }
2114 # endif
2115 
2116                       if (characters &lt; width &amp;&amp; (dp-&gt;flags &amp; FLAG_LEFT))
2117                         {
2118                           size_t n = width - characters;
2119                           ENSURE_ALLOCATION (xsum (length, n));
2120                           DCHAR_SET (result + length, &#39; &#39;, n);
2121                           length += n;
2122                         }
2123                     }
2124                     break;
2125 
2126                   case TYPE_U16_STRING:
2127                     {
2128                       const uint16_t *arg = a.arg[dp-&gt;arg_index].a.a_u16_string;
2129                       const uint16_t *arg_end;
2130                       size_t characters;
2131 
2132                       if (has_precision)
2133                         {
2134                           /* Use only PRECISION characters, from the left.  */
2135                           arg_end = arg;
2136                           characters = 0;
2137                           for (; precision &gt; 0; precision--)
2138                             {
2139                               int count = u16_strmblen (arg_end);
2140                               if (count == 0)
2141                                 break;
2142                               if (count &lt; 0)
2143                                 {
2144                                   if (!(result == resultbuf || result == NULL))
2145                                     free (result);
2146                                   if (buf_malloced != NULL)
2147                                     free (buf_malloced);
2148                                   CLEANUP ();
2149                                   errno = EILSEQ;
2150                                   return NULL;
2151                                 }
2152                               arg_end += count;
2153                               characters++;
2154                             }
2155                         }
2156                       else if (has_width)
2157                         {
2158                           /* Use the entire string, and count the number of
2159                              characters.  */
2160                           arg_end = arg;
2161                           characters = 0;
2162                           for (;;)
2163                             {
2164                               int count = u16_strmblen (arg_end);
2165                               if (count == 0)
2166                                 break;
2167                               if (count &lt; 0)
2168                                 {
2169                                   if (!(result == resultbuf || result == NULL))
2170                                     free (result);
2171                                   if (buf_malloced != NULL)
2172                                     free (buf_malloced);
2173                                   CLEANUP ();
2174                                   errno = EILSEQ;
2175                                   return NULL;
2176                                 }
2177                               arg_end += count;
2178                               characters++;
2179                             }
2180                         }
2181                       else
2182                         {
2183                           /* Use the entire string.  */
2184                           arg_end = arg + u16_strlen (arg);
2185                           /* The number of characters doesn&#39;t matter.  */
2186                           characters = 0;
2187                         }
2188 
2189                       if (characters &lt; width &amp;&amp; !(dp-&gt;flags &amp; FLAG_LEFT))
2190                         {
2191                           size_t n = width - characters;
2192                           ENSURE_ALLOCATION (xsum (length, n));
2193                           DCHAR_SET (result + length, &#39; &#39;, n);
2194                           length += n;
2195                         }
2196 
2197 # if DCHAR_IS_UINT16_T
2198                       {
2199                         size_t n = arg_end - arg;
2200                         ENSURE_ALLOCATION (xsum (length, n));
2201                         DCHAR_CPY (result + length, arg, n);
2202                         length += n;
2203                       }
2204 # else
2205                       { /* Convert.  */
2206                         DCHAR_T *converted = result + length;
2207                         size_t converted_len = allocated - length;
2208 #  if DCHAR_IS_TCHAR
2209                         /* Convert from UTF-16 to locale encoding.  */
2210                         converted =
2211                           u16_conv_to_encoding (locale_charset (),
2212                                                 iconveh_question_mark,
2213                                                 arg, arg_end - arg, NULL,
2214                                                 converted, &amp;converted_len);
2215 #  else
2216                         /* Convert from UTF-16 to UTF-8/UTF-32.  */
2217                         converted =
2218                           U16_TO_DCHAR (arg, arg_end - arg,
2219                                         converted, &amp;converted_len);
2220 #  endif
2221                         if (converted == NULL)
2222                           {
2223                             int saved_errno = errno;
2224                             if (!(result == resultbuf || result == NULL))
2225                               free (result);
2226                             if (buf_malloced != NULL)
2227                               free (buf_malloced);
2228                             CLEANUP ();
2229                             errno = saved_errno;
2230                             return NULL;
2231                           }
2232                         if (converted != result + length)
2233                           {
2234                             ENSURE_ALLOCATION (xsum (length, converted_len));
2235                             DCHAR_CPY (result + length, converted, converted_len);
2236                             free (converted);
2237                           }
2238                         length += converted_len;
2239                       }
2240 # endif
2241 
2242                       if (characters &lt; width &amp;&amp; (dp-&gt;flags &amp; FLAG_LEFT))
2243                         {
2244                           size_t n = width - characters;
2245                           ENSURE_ALLOCATION (xsum (length, n));
2246                           DCHAR_SET (result + length, &#39; &#39;, n);
2247                           length += n;
2248                         }
2249                     }
2250                     break;
2251 
2252                   case TYPE_U32_STRING:
2253                     {
2254                       const uint32_t *arg = a.arg[dp-&gt;arg_index].a.a_u32_string;
2255                       const uint32_t *arg_end;
2256                       size_t characters;
2257 
2258                       if (has_precision)
2259                         {
2260                           /* Use only PRECISION characters, from the left.  */
2261                           arg_end = arg;
2262                           characters = 0;
2263                           for (; precision &gt; 0; precision--)
2264                             {
2265                               int count = u32_strmblen (arg_end);
2266                               if (count == 0)
2267                                 break;
2268                               if (count &lt; 0)
2269                                 {
2270                                   if (!(result == resultbuf || result == NULL))
2271                                     free (result);
2272                                   if (buf_malloced != NULL)
2273                                     free (buf_malloced);
2274                                   CLEANUP ();
2275                                   errno = EILSEQ;
2276                                   return NULL;
2277                                 }
2278                               arg_end += count;
2279                               characters++;
2280                             }
2281                         }
2282                       else if (has_width)
2283                         {
2284                           /* Use the entire string, and count the number of
2285                              characters.  */
2286                           arg_end = arg;
2287                           characters = 0;
2288                           for (;;)
2289                             {
2290                               int count = u32_strmblen (arg_end);
2291                               if (count == 0)
2292                                 break;
2293                               if (count &lt; 0)
2294                                 {
2295                                   if (!(result == resultbuf || result == NULL))
2296                                     free (result);
2297                                   if (buf_malloced != NULL)
2298                                     free (buf_malloced);
2299                                   CLEANUP ();
2300                                   errno = EILSEQ;
2301                                   return NULL;
2302                                 }
2303                               arg_end += count;
2304                               characters++;
2305                             }
2306                         }
2307                       else
2308                         {
2309                           /* Use the entire string.  */
2310                           arg_end = arg + u32_strlen (arg);
2311                           /* The number of characters doesn&#39;t matter.  */
2312                           characters = 0;
2313                         }
2314 
2315                       if (characters &lt; width &amp;&amp; !(dp-&gt;flags &amp; FLAG_LEFT))
2316                         {
2317                           size_t n = width - characters;
2318                           ENSURE_ALLOCATION (xsum (length, n));
2319                           DCHAR_SET (result + length, &#39; &#39;, n);
2320                           length += n;
2321                         }
2322 
2323 # if DCHAR_IS_UINT32_T
2324                       {
2325                         size_t n = arg_end - arg;
2326                         ENSURE_ALLOCATION (xsum (length, n));
2327                         DCHAR_CPY (result + length, arg, n);
2328                         length += n;
2329                       }
2330 # else
2331                       { /* Convert.  */
2332                         DCHAR_T *converted = result + length;
2333                         size_t converted_len = allocated - length;
2334 #  if DCHAR_IS_TCHAR
2335                         /* Convert from UTF-32 to locale encoding.  */
2336                         converted =
2337                           u32_conv_to_encoding (locale_charset (),
2338                                                 iconveh_question_mark,
2339                                                 arg, arg_end - arg, NULL,
2340                                                 converted, &amp;converted_len);
2341 #  else
2342                         /* Convert from UTF-32 to UTF-8/UTF-16.  */
2343                         converted =
2344                           U32_TO_DCHAR (arg, arg_end - arg,
2345                                         converted, &amp;converted_len);
2346 #  endif
2347                         if (converted == NULL)
2348                           {
2349                             int saved_errno = errno;
2350                             if (!(result == resultbuf || result == NULL))
2351                               free (result);
2352                             if (buf_malloced != NULL)
2353                               free (buf_malloced);
2354                             CLEANUP ();
2355                             errno = saved_errno;
2356                             return NULL;
2357                           }
2358                         if (converted != result + length)
2359                           {
2360                             ENSURE_ALLOCATION (xsum (length, converted_len));
2361                             DCHAR_CPY (result + length, converted, converted_len);
2362                             free (converted);
2363                           }
2364                         length += converted_len;
2365                       }
2366 # endif
2367 
2368                       if (characters &lt; width &amp;&amp; (dp-&gt;flags &amp; FLAG_LEFT))
2369                         {
2370                           size_t n = width - characters;
2371                           ENSURE_ALLOCATION (xsum (length, n));
2372                           DCHAR_SET (result + length, &#39; &#39;, n);
2373                           length += n;
2374                         }
2375                     }
2376                     break;
2377 
2378                   default:
2379                     abort ();
2380                   }
2381               }
2382 #endif
2383 #if (!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || (NEED_PRINTF_DIRECTIVE_LS &amp;&amp; !defined IN_LIBINTL)) &amp;&amp; HAVE_WCHAR_T
2384             else if (dp-&gt;conversion == &#39;s&#39;
2385 # if WIDE_CHAR_VERSION
2386                      &amp;&amp; a.arg[dp-&gt;arg_index].type != TYPE_WIDE_STRING
2387 # else
2388                      &amp;&amp; a.arg[dp-&gt;arg_index].type == TYPE_WIDE_STRING
2389 # endif
2390                     )
2391               {
2392                 /* The normal handling of the &#39;s&#39; directive below requires
2393                    allocating a temporary buffer.  The determination of its
2394                    length (tmp_length), in the case when a precision is
2395                    specified, below requires a conversion between a char[]
2396                    string and a wchar_t[] wide string.  It could be done, but
2397                    we have no guarantee that the implementation of sprintf will
2398                    use the exactly same algorithm.  Without this guarantee, it
2399                    is possible to have buffer overrun bugs.  In order to avoid
2400                    such bugs, we implement the entire processing of the &#39;s&#39;
2401                    directive ourselves.  */
2402                 int flags = dp-&gt;flags;
2403                 int has_width;
2404                 size_t width;
2405                 int has_precision;
2406                 size_t precision;
2407 
2408                 has_width = 0;
2409                 width = 0;
2410                 if (dp-&gt;width_start != dp-&gt;width_end)
2411                   {
2412                     if (dp-&gt;width_arg_index != ARG_NONE)
2413                       {
2414                         int arg;
2415 
2416                         if (!(a.arg[dp-&gt;width_arg_index].type == TYPE_INT))
2417                           abort ();
2418                         arg = a.arg[dp-&gt;width_arg_index].a.a_int;
2419                         width = arg;
2420                         if (arg &lt; 0)
2421                           {
2422                             /* &quot;A negative field width is taken as a &#39;-&#39; flag
2423                                 followed by a positive field width.&quot;  */
2424                             flags |= FLAG_LEFT;
2425                             width = -width;
2426                           }
2427                       }
2428                     else
2429                       {
2430                         const FCHAR_T *digitp = dp-&gt;width_start;
2431 
2432                         do
2433                           width = xsum (xtimes (width, 10), *digitp++ - &#39;0&#39;);
2434                         while (digitp != dp-&gt;width_end);
2435                       }
2436                     has_width = 1;
2437                   }
2438 
2439                 has_precision = 0;
2440                 precision = 6;
2441                 if (dp-&gt;precision_start != dp-&gt;precision_end)
2442                   {
2443                     if (dp-&gt;precision_arg_index != ARG_NONE)
2444                       {
2445                         int arg;
2446 
2447                         if (!(a.arg[dp-&gt;precision_arg_index].type == TYPE_INT))
2448                           abort ();
2449                         arg = a.arg[dp-&gt;precision_arg_index].a.a_int;
2450                         /* &quot;A negative precision is taken as if the precision
2451                             were omitted.&quot;  */
2452                         if (arg &gt;= 0)
2453                           {
2454                             precision = arg;
2455                             has_precision = 1;
2456                           }
2457                       }
2458                     else
2459                       {
2460                         const FCHAR_T *digitp = dp-&gt;precision_start + 1;
2461 
2462                         precision = 0;
2463                         while (digitp != dp-&gt;precision_end)
2464                           precision = xsum (xtimes (precision, 10), *digitp++ - &#39;0&#39;);
2465                         has_precision = 1;
2466                       }
2467                   }
2468 
2469 # if WIDE_CHAR_VERSION
2470                 /* %s in vasnwprintf.  See the specification of fwprintf.  */
2471                 {
2472                   const char *arg = a.arg[dp-&gt;arg_index].a.a_string;
2473                   const char *arg_end;
2474                   size_t characters;
2475 
2476                   if (has_precision)
2477                     {
2478                       /* Use only as many bytes as needed to produce PRECISION
2479                          wide characters, from the left.  */
2480 #  if HAVE_MBRTOWC
2481                       mbstate_t state;
2482                       memset (&amp;state, &#39;\0&#39;, sizeof (mbstate_t));
2483 #  endif
2484                       arg_end = arg;
2485                       characters = 0;
2486                       for (; precision &gt; 0; precision--)
2487                         {
2488                           int count;
2489 #  if HAVE_MBRTOWC
2490                           count = mbrlen (arg_end, MB_CUR_MAX, &amp;state);
2491 #  else
2492                           count = mblen (arg_end, MB_CUR_MAX);
2493 #  endif
2494                           if (count == 0)
2495                             /* Found the terminating NUL.  */
2496                             break;
2497                           if (count &lt; 0)
2498                             {
2499                               /* Invalid or incomplete multibyte character.  */
2500                               if (!(result == resultbuf || result == NULL))
2501                                 free (result);
2502                               if (buf_malloced != NULL)
2503                                 free (buf_malloced);
2504                               CLEANUP ();
2505                               errno = EILSEQ;
2506                               return NULL;
2507                             }
2508                           arg_end += count;
2509                           characters++;
2510                         }
2511                     }
2512                   else if (has_width)
2513                     {
2514                       /* Use the entire string, and count the number of wide
2515                          characters.  */
2516 #  if HAVE_MBRTOWC
2517                       mbstate_t state;
2518                       memset (&amp;state, &#39;\0&#39;, sizeof (mbstate_t));
2519 #  endif
2520                       arg_end = arg;
2521                       characters = 0;
2522                       for (;;)
2523                         {
2524                           int count;
2525 #  if HAVE_MBRTOWC
2526                           count = mbrlen (arg_end, MB_CUR_MAX, &amp;state);
2527 #  else
2528                           count = mblen (arg_end, MB_CUR_MAX);
2529 #  endif
2530                           if (count == 0)
2531                             /* Found the terminating NUL.  */
2532                             break;
2533                           if (count &lt; 0)
2534                             {
2535                               /* Invalid or incomplete multibyte character.  */
2536                               if (!(result == resultbuf || result == NULL))
2537                                 free (result);
2538                               if (buf_malloced != NULL)
2539                                 free (buf_malloced);
2540                               CLEANUP ();
2541                               errno = EILSEQ;
2542                               return NULL;
2543                             }
2544                           arg_end += count;
2545                           characters++;
2546                         }
2547                     }
2548                   else
2549                     {
2550                       /* Use the entire string.  */
2551                       arg_end = arg + strlen (arg);
2552                       /* The number of characters doesn&#39;t matter.  */
2553                       characters = 0;
2554                     }
2555 
2556                   if (characters &lt; width &amp;&amp; !(dp-&gt;flags &amp; FLAG_LEFT))
2557                     {
2558                       size_t n = width - characters;
2559                       ENSURE_ALLOCATION (xsum (length, n));
2560                       DCHAR_SET (result + length, &#39; &#39;, n);
2561                       length += n;
2562                     }
2563 
2564                   if (has_precision || has_width)
2565                     {
2566                       /* We know the number of wide characters in advance.  */
2567                       size_t remaining;
2568 #  if HAVE_MBRTOWC
2569                       mbstate_t state;
2570                       memset (&amp;state, &#39;\0&#39;, sizeof (mbstate_t));
2571 #  endif
2572                       ENSURE_ALLOCATION (xsum (length, characters));
2573                       for (remaining = characters; remaining &gt; 0; remaining--)
2574                         {
2575                           wchar_t wc;
2576                           int count;
2577 #  if HAVE_MBRTOWC
2578                           count = mbrtowc (&amp;wc, arg, arg_end - arg, &amp;state);
2579 #  else
2580                           count = mbtowc (&amp;wc, arg, arg_end - arg);
2581 #  endif
2582                           if (count &lt;= 0)
2583                             /* mbrtowc not consistent with mbrlen, or mbtowc
2584                                not consistent with mblen.  */
2585                             abort ();
2586                           result[length++] = wc;
2587                           arg += count;
2588                         }
2589                       if (!(arg == arg_end))
2590                         abort ();
2591                     }
2592                   else
2593                     {
2594 #  if HAVE_MBRTOWC
2595                       mbstate_t state;
2596                       memset (&amp;state, &#39;\0&#39;, sizeof (mbstate_t));
2597 #  endif
2598                       while (arg &lt; arg_end)
2599                         {
2600                           wchar_t wc;
2601                           int count;
2602 #  if HAVE_MBRTOWC
2603                           count = mbrtowc (&amp;wc, arg, arg_end - arg, &amp;state);
2604 #  else
2605                           count = mbtowc (&amp;wc, arg, arg_end - arg);
2606 #  endif
2607                           if (count &lt;= 0)
2608                             /* mbrtowc not consistent with mbrlen, or mbtowc
2609                                not consistent with mblen.  */
2610                             abort ();
2611                           ENSURE_ALLOCATION (xsum (length, 1));
2612                           result[length++] = wc;
2613                           arg += count;
2614                         }
2615                     }
2616 
2617                   if (characters &lt; width &amp;&amp; (dp-&gt;flags &amp; FLAG_LEFT))
2618                     {
2619                       size_t n = width - characters;
2620                       ENSURE_ALLOCATION (xsum (length, n));
2621                       DCHAR_SET (result + length, &#39; &#39;, n);
2622                       length += n;
2623                     }
2624                 }
2625 # else
2626                 /* %ls in vasnprintf.  See the specification of fprintf.  */
2627                 {
2628                   const wchar_t *arg = a.arg[dp-&gt;arg_index].a.a_wide_string;
2629                   const wchar_t *arg_end;
2630                   size_t characters;
2631 #  if !DCHAR_IS_TCHAR
2632                   /* This code assumes that TCHAR_T is &#39;char&#39;.  */
2633                   verify (sizeof (TCHAR_T) == 1);
2634                   TCHAR_T *tmpsrc;
2635                   DCHAR_T *tmpdst;
2636                   size_t tmpdst_len;
2637 #  endif
2638                   size_t w;
2639 
2640                   if (has_precision)
2641                     {
2642                       /* Use only as many wide characters as needed to produce
2643                          at most PRECISION bytes, from the left.  */
2644 #  if HAVE_WCRTOMB &amp;&amp; !defined GNULIB_defined_mbstate_t
2645                       mbstate_t state;
2646                       memset (&amp;state, &#39;\0&#39;, sizeof (mbstate_t));
2647 #  endif
2648                       arg_end = arg;
2649                       characters = 0;
2650                       while (precision &gt; 0)
2651                         {
2652                           char cbuf[64]; /* Assume MB_CUR_MAX &lt;= 64.  */
2653                           int count;
2654 
2655                           if (*arg_end == 0)
2656                             /* Found the terminating null wide character.  */
2657                             break;
2658 #  if HAVE_WCRTOMB &amp;&amp; !defined GNULIB_defined_mbstate_t
2659                           count = wcrtomb (cbuf, *arg_end, &amp;state);
2660 #  else
2661                           count = wctomb (cbuf, *arg_end);
2662 #  endif
2663                           if (count &lt; 0)
2664                             {
2665                               /* Cannot convert.  */
2666                               if (!(result == resultbuf || result == NULL))
2667                                 free (result);
2668                               if (buf_malloced != NULL)
2669                                 free (buf_malloced);
2670                               CLEANUP ();
2671                               errno = EILSEQ;
2672                               return NULL;
2673                             }
2674                           if (precision &lt; count)
2675                             break;
2676                           arg_end++;
2677                           characters += count;
2678                           precision -= count;
2679                         }
2680                     }
2681 #  if DCHAR_IS_TCHAR
2682                   else if (has_width)
2683 #  else
2684                   else
2685 #  endif
2686                     {
2687                       /* Use the entire string, and count the number of
2688                          bytes.  */
2689 #  if HAVE_WCRTOMB &amp;&amp; !defined GNULIB_defined_mbstate_t
2690                       mbstate_t state;
2691                       memset (&amp;state, &#39;\0&#39;, sizeof (mbstate_t));
2692 #  endif
2693                       arg_end = arg;
2694                       characters = 0;
2695                       for (;;)
2696                         {
2697                           char cbuf[64]; /* Assume MB_CUR_MAX &lt;= 64.  */
2698                           int count;
2699 
2700                           if (*arg_end == 0)
2701                             /* Found the terminating null wide character.  */
2702                             break;
2703 #  if HAVE_WCRTOMB &amp;&amp; !defined GNULIB_defined_mbstate_t
2704                           count = wcrtomb (cbuf, *arg_end, &amp;state);
2705 #  else
2706                           count = wctomb (cbuf, *arg_end);
2707 #  endif
2708                           if (count &lt; 0)
2709                             {
2710                               /* Cannot convert.  */
2711                               if (!(result == resultbuf || result == NULL))
2712                                 free (result);
2713                               if (buf_malloced != NULL)
2714                                 free (buf_malloced);
2715                               CLEANUP ();
2716                               errno = EILSEQ;
2717                               return NULL;
2718                             }
2719                           arg_end++;
2720                           characters += count;
2721                         }
2722                     }
2723 #  if DCHAR_IS_TCHAR
2724                   else
2725                     {
2726                       /* Use the entire string.  */
2727                       arg_end = arg + local_wcslen (arg);
2728                       /* The number of bytes doesn&#39;t matter.  */
2729                       characters = 0;
2730                     }
2731 #  endif
2732 
2733 #  if !DCHAR_IS_TCHAR
2734                   /* Convert the string into a piece of temporary memory.  */
2735                   tmpsrc = (TCHAR_T *) malloc (characters * sizeof (TCHAR_T));
2736                   if (tmpsrc == NULL)
2737                     goto out_of_memory;
2738                   {
2739                     TCHAR_T *tmpptr = tmpsrc;
2740                     size_t remaining;
2741 #   if HAVE_WCRTOMB &amp;&amp; !defined GNULIB_defined_mbstate_t
2742                     mbstate_t state;
2743                     memset (&amp;state, &#39;\0&#39;, sizeof (mbstate_t));
2744 #   endif
2745                     for (remaining = characters; remaining &gt; 0; )
2746                       {
2747                         char cbuf[64]; /* Assume MB_CUR_MAX &lt;= 64.  */
2748                         int count;
2749 
2750                         if (*arg == 0)
2751                           abort ();
2752 #   if HAVE_WCRTOMB &amp;&amp; !defined GNULIB_defined_mbstate_t
2753                         count = wcrtomb (cbuf, *arg, &amp;state);
2754 #   else
2755                         count = wctomb (cbuf, *arg);
2756 #   endif
2757                         if (count &lt;= 0)
2758                           /* Inconsistency.  */
2759                           abort ();
2760                         memcpy (tmpptr, cbuf, count);
2761                         tmpptr += count;
2762                         arg++;
2763                         remaining -= count;
2764                       }
2765                     if (!(arg == arg_end))
2766                       abort ();
2767                   }
2768 
2769                   /* Convert from TCHAR_T[] to DCHAR_T[].  */
2770                   tmpdst =
2771                     DCHAR_CONV_FROM_ENCODING (locale_charset (),
2772                                               iconveh_question_mark,
2773                                               tmpsrc, characters,
2774                                               NULL,
2775                                               NULL, &amp;tmpdst_len);
2776                   if (tmpdst == NULL)
2777                     {
2778                       int saved_errno = errno;
2779                       free (tmpsrc);
2780                       if (!(result == resultbuf || result == NULL))
2781                         free (result);
2782                       if (buf_malloced != NULL)
2783                         free (buf_malloced);
2784                       CLEANUP ();
2785                       errno = saved_errno;
2786                       return NULL;
2787                     }
2788                   free (tmpsrc);
2789 #  endif
2790 
2791                   if (has_width)
2792                     {
2793 #  if ENABLE_UNISTDIO
2794                       /* Outside POSIX, it&#39;s preferable to compare the width
2795                          against the number of _characters_ of the converted
2796                          value.  */
2797                       w = DCHAR_MBSNLEN (result + length, characters);
2798 #  else
2799                       /* The width is compared against the number of _bytes_
2800                          of the converted value, says POSIX.  */
2801                       w = characters;
2802 #  endif
2803                     }
2804                   else
2805                     /* w doesn&#39;t matter.  */
2806                     w = 0;
2807 
2808                   if (w &lt; width &amp;&amp; !(dp-&gt;flags &amp; FLAG_LEFT))
2809                     {
2810                       size_t n = width - w;
2811                       ENSURE_ALLOCATION (xsum (length, n));
2812                       DCHAR_SET (result + length, &#39; &#39;, n);
2813                       length += n;
2814                     }
2815 
2816 #  if DCHAR_IS_TCHAR
2817                   if (has_precision || has_width)
2818                     {
2819                       /* We know the number of bytes in advance.  */
2820                       size_t remaining;
2821 #   if HAVE_WCRTOMB &amp;&amp; !defined GNULIB_defined_mbstate_t
2822                       mbstate_t state;
2823                       memset (&amp;state, &#39;\0&#39;, sizeof (mbstate_t));
2824 #   endif
2825                       ENSURE_ALLOCATION (xsum (length, characters));
2826                       for (remaining = characters; remaining &gt; 0; )
2827                         {
2828                           char cbuf[64]; /* Assume MB_CUR_MAX &lt;= 64.  */
2829                           int count;
2830 
2831                           if (*arg == 0)
2832                             abort ();
2833 #   if HAVE_WCRTOMB &amp;&amp; !defined GNULIB_defined_mbstate_t
2834                           count = wcrtomb (cbuf, *arg, &amp;state);
2835 #   else
2836                           count = wctomb (cbuf, *arg);
2837 #   endif
2838                           if (count &lt;= 0)
2839                             /* Inconsistency.  */
2840                             abort ();
2841                           memcpy (result + length, cbuf, count);
2842                           length += count;
2843                           arg++;
2844                           remaining -= count;
2845                         }
2846                       if (!(arg == arg_end))
2847                         abort ();
2848                     }
2849                   else
2850                     {
2851 #   if HAVE_WCRTOMB &amp;&amp; !defined GNULIB_defined_mbstate_t
2852                       mbstate_t state;
2853                       memset (&amp;state, &#39;\0&#39;, sizeof (mbstate_t));
2854 #   endif
2855                       while (arg &lt; arg_end)
2856                         {
2857                           char cbuf[64]; /* Assume MB_CUR_MAX &lt;= 64.  */
2858                           int count;
2859 
2860                           if (*arg == 0)
2861                             abort ();
2862 #   if HAVE_WCRTOMB &amp;&amp; !defined GNULIB_defined_mbstate_t
2863                           count = wcrtomb (cbuf, *arg, &amp;state);
2864 #   else
2865                           count = wctomb (cbuf, *arg);
2866 #   endif
2867                           if (count &lt;= 0)
2868                             {
2869                               /* Cannot convert.  */
2870                               if (!(result == resultbuf || result == NULL))
2871                                 free (result);
2872                               if (buf_malloced != NULL)
2873                                 free (buf_malloced);
2874                               CLEANUP ();
2875                               errno = EILSEQ;
2876                               return NULL;
2877                             }
2878                           ENSURE_ALLOCATION (xsum (length, count));
2879                           memcpy (result + length, cbuf, count);
2880                           length += count;
2881                           arg++;
2882                         }
2883                     }
2884 #  else
2885                   ENSURE_ALLOCATION (xsum (length, tmpdst_len));
2886                   DCHAR_CPY (result + length, tmpdst, tmpdst_len);
2887                   free (tmpdst);
2888                   length += tmpdst_len;
2889 #  endif
2890 
2891                   if (w &lt; width &amp;&amp; (dp-&gt;flags &amp; FLAG_LEFT))
2892                     {
2893                       size_t n = width - w;
2894                       ENSURE_ALLOCATION (xsum (length, n));
2895                       DCHAR_SET (result + length, &#39; &#39;, n);
2896                       length += n;
2897                     }
2898                 }
2899 # endif
2900               }
2901 #endif
2902 #if (NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_DOUBLE) &amp;&amp; !defined IN_LIBINTL
2903             else if ((dp-&gt;conversion == &#39;a&#39; || dp-&gt;conversion == &#39;A&#39;)
2904 # if !(NEED_PRINTF_DIRECTIVE_A || (NEED_PRINTF_LONG_DOUBLE &amp;&amp; NEED_PRINTF_DOUBLE))
2905                      &amp;&amp; (0
2906 #  if NEED_PRINTF_DOUBLE
2907                          || a.arg[dp-&gt;arg_index].type == TYPE_DOUBLE
2908 #  endif
2909 #  if NEED_PRINTF_LONG_DOUBLE
2910                          || a.arg[dp-&gt;arg_index].type == TYPE_LONGDOUBLE
2911 #  endif
2912                         )
2913 # endif
2914                     )
2915               {
2916                 arg_type type = a.arg[dp-&gt;arg_index].type;
2917                 int flags = dp-&gt;flags;
2918                 size_t width;
2919                 int has_precision;
2920                 size_t precision;
2921                 size_t tmp_length;
2922                 size_t count;
2923                 DCHAR_T tmpbuf[700];
2924                 DCHAR_T *tmp;
2925                 DCHAR_T *pad_ptr;
2926                 DCHAR_T *p;
2927 
2928                 width = 0;
2929                 if (dp-&gt;width_start != dp-&gt;width_end)
2930                   {
2931                     if (dp-&gt;width_arg_index != ARG_NONE)
2932                       {
2933                         int arg;
2934 
2935                         if (!(a.arg[dp-&gt;width_arg_index].type == TYPE_INT))
2936                           abort ();
2937                         arg = a.arg[dp-&gt;width_arg_index].a.a_int;
2938                         width = arg;
2939                         if (arg &lt; 0)
2940                           {
2941                             /* &quot;A negative field width is taken as a &#39;-&#39; flag
2942                                 followed by a positive field width.&quot;  */
2943                             flags |= FLAG_LEFT;
2944                             width = -width;
2945                           }
2946                       }
2947                     else
2948                       {
2949                         const FCHAR_T *digitp = dp-&gt;width_start;
2950 
2951                         do
2952                           width = xsum (xtimes (width, 10), *digitp++ - &#39;0&#39;);
2953                         while (digitp != dp-&gt;width_end);
2954                       }
2955                   }
2956 
2957                 has_precision = 0;
2958                 precision = 0;
2959                 if (dp-&gt;precision_start != dp-&gt;precision_end)
2960                   {
2961                     if (dp-&gt;precision_arg_index != ARG_NONE)
2962                       {
2963                         int arg;
2964 
2965                         if (!(a.arg[dp-&gt;precision_arg_index].type == TYPE_INT))
2966                           abort ();
2967                         arg = a.arg[dp-&gt;precision_arg_index].a.a_int;
2968                         /* &quot;A negative precision is taken as if the precision
2969                             were omitted.&quot;  */
2970                         if (arg &gt;= 0)
2971                           {
2972                             precision = arg;
2973                             has_precision = 1;
2974                           }
2975                       }
2976                     else
2977                       {
2978                         const FCHAR_T *digitp = dp-&gt;precision_start + 1;
2979 
2980                         precision = 0;
2981                         while (digitp != dp-&gt;precision_end)
2982                           precision = xsum (xtimes (precision, 10), *digitp++ - &#39;0&#39;);
2983                         has_precision = 1;
2984                       }
2985                   }
2986 
2987                 /* Allocate a temporary buffer of sufficient size.  */
2988                 if (type == TYPE_LONGDOUBLE)
2989                   tmp_length =
2990                     (unsigned int) ((LDBL_DIG + 1)
2991                                     * 0.831 /* decimal -&gt; hexadecimal */
2992                                    )
2993                     + 1; /* turn floor into ceil */
2994                 else
2995                   tmp_length =
2996                     (unsigned int) ((DBL_DIG + 1)
2997                                     * 0.831 /* decimal -&gt; hexadecimal */
2998                                    )
2999                     + 1; /* turn floor into ceil */
3000                 if (tmp_length &lt; precision)
3001                   tmp_length = precision;
3002                 /* Account for sign, decimal point etc. */
3003                 tmp_length = xsum (tmp_length, 12);
3004 
3005                 if (tmp_length &lt; width)
3006                   tmp_length = width;
3007 
3008                 tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */
3009 
3010                 if (tmp_length &lt;= sizeof (tmpbuf) / sizeof (DCHAR_T))
3011                   tmp = tmpbuf;
3012                 else
3013                   {
3014                     size_t tmp_memsize = xtimes (tmp_length, sizeof (DCHAR_T));
3015 
3016                     if (size_overflow_p (tmp_memsize))
3017                       /* Overflow, would lead to out of memory.  */
3018                       goto out_of_memory;
3019                     tmp = (DCHAR_T *) malloc (tmp_memsize);
3020                     if (tmp == NULL)
3021                       /* Out of memory.  */
3022                       goto out_of_memory;
3023                   }
3024 
3025                 pad_ptr = NULL;
3026                 p = tmp;
3027                 if (type == TYPE_LONGDOUBLE)
3028                   {
3029 # if NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_LONG_DOUBLE
3030                     long double arg = a.arg[dp-&gt;arg_index].a.a_longdouble;
3031 
3032                     if (isnanl (arg))
3033                       {
3034                         if (dp-&gt;conversion == &#39;A&#39;)
3035                           {
3036                             *p++ = &#39;N&#39;; *p++ = &#39;A&#39;; *p++ = &#39;N&#39;;
3037                           }
3038                         else
3039                           {
3040                             *p++ = &#39;n&#39;; *p++ = &#39;a&#39;; *p++ = &#39;n&#39;;
3041                           }
3042                       }
3043                     else
3044                       {
3045                         int sign = 0;
3046                         DECL_LONG_DOUBLE_ROUNDING
3047 
3048                         BEGIN_LONG_DOUBLE_ROUNDING ();
3049 
3050                         if (signbit (arg)) /* arg &lt; 0.0L or negative zero */
3051                           {
3052                             sign = -1;
3053                             arg = -arg;
3054                           }
3055 
3056                         if (sign &lt; 0)
3057                           *p++ = &#39;-&#39;;
3058                         else if (flags &amp; FLAG_SHOWSIGN)
3059                           *p++ = &#39;+&#39;;
3060                         else if (flags &amp; FLAG_SPACE)
3061                           *p++ = &#39; &#39;;
3062 
3063                         if (arg &gt; 0.0L &amp;&amp; arg + arg == arg)
3064                           {
3065                             if (dp-&gt;conversion == &#39;A&#39;)
3066                               {
3067                                 *p++ = &#39;I&#39;; *p++ = &#39;N&#39;; *p++ = &#39;F&#39;;
3068                               }
3069                             else
3070                               {
3071                                 *p++ = &#39;i&#39;; *p++ = &#39;n&#39;; *p++ = &#39;f&#39;;
3072                               }
3073                           }
3074                         else
3075                           {
3076                             int exponent;
3077                             long double mantissa;
3078 
3079                             if (arg &gt; 0.0L)
3080                               mantissa = printf_frexpl (arg, &amp;exponent);
3081                             else
3082                               {
3083                                 exponent = 0;
3084                                 mantissa = 0.0L;
3085                               }
3086 
3087                             if (has_precision
3088                                 &amp;&amp; precision &lt; (unsigned int) ((LDBL_DIG + 1) * 0.831) + 1)
3089                               {
3090                                 /* Round the mantissa.  */
3091                                 long double tail = mantissa;
3092                                 size_t q;
3093 
3094                                 for (q = precision; ; q--)
3095                                   {
3096                                     int digit = (int) tail;
3097                                     tail -= digit;
3098                                     if (q == 0)
3099                                       {
3100                                         if (digit &amp; 1 ? tail &gt;= 0.5L : tail &gt; 0.5L)
3101                                           tail = 1 - tail;
3102                                         else
3103                                           tail = - tail;
3104                                         break;
3105                                       }
3106                                     tail *= 16.0L;
3107                                   }
3108                                 if (tail != 0.0L)
3109                                   for (q = precision; q &gt; 0; q--)
3110                                     tail *= 0.0625L;
3111                                 mantissa += tail;
3112                               }
3113 
3114                             *p++ = &#39;0&#39;;
3115                             *p++ = dp-&gt;conversion - &#39;A&#39; + &#39;X&#39;;
3116                             pad_ptr = p;
3117                             {
3118                               int digit;
3119 
3120                               digit = (int) mantissa;
3121                               mantissa -= digit;
3122                               *p++ = &#39;0&#39; + digit;
3123                               if ((flags &amp; FLAG_ALT)
3124                                   || mantissa &gt; 0.0L || precision &gt; 0)
3125                                 {
3126                                   *p++ = decimal_point_char ();
3127                                   /* This loop terminates because we assume
3128                                      that FLT_RADIX is a power of 2.  */
3129                                   while (mantissa &gt; 0.0L)
3130                                     {
3131                                       mantissa *= 16.0L;
3132                                       digit = (int) mantissa;
3133                                       mantissa -= digit;
3134                                       *p++ = digit
3135                                              + (digit &lt; 10
3136                                                 ? &#39;0&#39;
3137                                                 : dp-&gt;conversion - 10);
3138                                       if (precision &gt; 0)
3139                                         precision--;
3140                                     }
3141                                   while (precision &gt; 0)
3142                                     {
3143                                       *p++ = &#39;0&#39;;
3144                                       precision--;
3145                                     }
3146                                 }
3147                               }
3148                               *p++ = dp-&gt;conversion - &#39;A&#39; + &#39;P&#39;;
3149 #  if WIDE_CHAR_VERSION
3150                               {
3151                                 static const wchar_t decimal_format[] =
3152                                   { &#39;%&#39;, &#39;+&#39;, &#39;d&#39;, &#39;\0&#39; };
3153                                 SNPRINTF (p, 6 + 1, decimal_format, exponent);
3154                               }
3155                               while (*p != &#39;\0&#39;)
3156                                 p++;
3157 #  else
3158                               if (sizeof (DCHAR_T) == 1)
3159                                 {
3160                                   sprintf ((char *) p, &quot;%+d&quot;, exponent);
3161                                   while (*p != &#39;\0&#39;)
3162                                     p++;
3163                                 }
3164                               else
3165                                 {
3166                                   char expbuf[6 + 1];
3167                                   const char *ep;
3168                                   sprintf (expbuf, &quot;%+d&quot;, exponent);
3169                                   for (ep = expbuf; (*p = *ep) != &#39;\0&#39;; ep++)
3170                                     p++;
3171                                 }
3172 #  endif
3173                           }
3174 
3175                         END_LONG_DOUBLE_ROUNDING ();
3176                       }
3177 # else
3178                     abort ();
3179 # endif
3180                   }
3181                 else
3182                   {
3183 # if NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_DOUBLE
3184                     double arg = a.arg[dp-&gt;arg_index].a.a_double;
3185 
3186                     if (isnand (arg))
3187                       {
3188                         if (dp-&gt;conversion == &#39;A&#39;)
3189                           {
3190                             *p++ = &#39;N&#39;; *p++ = &#39;A&#39;; *p++ = &#39;N&#39;;
3191                           }
3192                         else
3193                           {
3194                             *p++ = &#39;n&#39;; *p++ = &#39;a&#39;; *p++ = &#39;n&#39;;
3195                           }
3196                       }
3197                     else
3198                       {
3199                         int sign = 0;
3200 
3201                         if (signbit (arg)) /* arg &lt; 0.0 or negative zero */
3202                           {
3203                             sign = -1;
3204                             arg = -arg;
3205                           }
3206 
3207                         if (sign &lt; 0)
3208                           *p++ = &#39;-&#39;;
3209                         else if (flags &amp; FLAG_SHOWSIGN)
3210                           *p++ = &#39;+&#39;;
3211                         else if (flags &amp; FLAG_SPACE)
3212                           *p++ = &#39; &#39;;
3213 
3214                         if (arg &gt; 0.0 &amp;&amp; arg + arg == arg)
3215                           {
3216                             if (dp-&gt;conversion == &#39;A&#39;)
3217                               {
3218                                 *p++ = &#39;I&#39;; *p++ = &#39;N&#39;; *p++ = &#39;F&#39;;
3219                               }
3220                             else
3221                               {
3222                                 *p++ = &#39;i&#39;; *p++ = &#39;n&#39;; *p++ = &#39;f&#39;;
3223                               }
3224                           }
3225                         else
3226                           {
3227                             int exponent;
3228                             double mantissa;
3229 
3230                             if (arg &gt; 0.0)
3231                               mantissa = printf_frexp (arg, &amp;exponent);
3232                             else
3233                               {
3234                                 exponent = 0;
3235                                 mantissa = 0.0;
3236                               }
3237 
3238                             if (has_precision
3239                                 &amp;&amp; precision &lt; (unsigned int) ((DBL_DIG + 1) * 0.831) + 1)
3240                               {
3241                                 /* Round the mantissa.  */
3242                                 double tail = mantissa;
3243                                 size_t q;
3244 
3245                                 for (q = precision; ; q--)
3246                                   {
3247                                     int digit = (int) tail;
3248                                     tail -= digit;
3249                                     if (q == 0)
3250                                       {
3251                                         if (digit &amp; 1 ? tail &gt;= 0.5 : tail &gt; 0.5)
3252                                           tail = 1 - tail;
3253                                         else
3254                                           tail = - tail;
3255                                         break;
3256                                       }
3257                                     tail *= 16.0;
3258                                   }
3259                                 if (tail != 0.0)
3260                                   for (q = precision; q &gt; 0; q--)
3261                                     tail *= 0.0625;
3262                                 mantissa += tail;
3263                               }
3264 
3265                             *p++ = &#39;0&#39;;
3266                             *p++ = dp-&gt;conversion - &#39;A&#39; + &#39;X&#39;;
3267                             pad_ptr = p;
3268                             {
3269                               int digit;
3270 
3271                               digit = (int) mantissa;
3272                               mantissa -= digit;
3273                               *p++ = &#39;0&#39; + digit;
3274                               if ((flags &amp; FLAG_ALT)
3275                                   || mantissa &gt; 0.0 || precision &gt; 0)
3276                                 {
3277                                   *p++ = decimal_point_char ();
3278                                   /* This loop terminates because we assume
3279                                      that FLT_RADIX is a power of 2.  */
3280                                   while (mantissa &gt; 0.0)
3281                                     {
3282                                       mantissa *= 16.0;
3283                                       digit = (int) mantissa;
3284                                       mantissa -= digit;
3285                                       *p++ = digit
3286                                              + (digit &lt; 10
3287                                                 ? &#39;0&#39;
3288                                                 : dp-&gt;conversion - 10);
3289                                       if (precision &gt; 0)
3290                                         precision--;
3291                                     }
3292                                   while (precision &gt; 0)
3293                                     {
3294                                       *p++ = &#39;0&#39;;
3295                                       precision--;
3296                                     }
3297                                 }
3298                               }
3299                               *p++ = dp-&gt;conversion - &#39;A&#39; + &#39;P&#39;;
3300 #  if WIDE_CHAR_VERSION
3301                               {
3302                                 static const wchar_t decimal_format[] =
3303                                   { &#39;%&#39;, &#39;+&#39;, &#39;d&#39;, &#39;\0&#39; };
3304                                 SNPRINTF (p, 6 + 1, decimal_format, exponent);
3305                               }
3306                               while (*p != &#39;\0&#39;)
3307                                 p++;
3308 #  else
3309                               if (sizeof (DCHAR_T) == 1)
3310                                 {
3311                                   sprintf ((char *) p, &quot;%+d&quot;, exponent);
3312                                   while (*p != &#39;\0&#39;)
3313                                     p++;
3314                                 }
3315                               else
3316                                 {
3317                                   char expbuf[6 + 1];
3318                                   const char *ep;
3319                                   sprintf (expbuf, &quot;%+d&quot;, exponent);
3320                                   for (ep = expbuf; (*p = *ep) != &#39;\0&#39;; ep++)
3321                                     p++;
3322                                 }
3323 #  endif
3324                           }
3325                       }
3326 # else
3327                     abort ();
3328 # endif
3329                   }
3330 
3331                 /* The generated string now extends from tmp to p, with the
3332                    zero padding insertion point being at pad_ptr.  */
3333                 count = p - tmp;
3334 
3335                 if (count &lt; width)
3336                   {
3337                     size_t pad = width - count;
3338                     DCHAR_T *end = p + pad;
3339 
3340                     if (flags &amp; FLAG_LEFT)
3341                       {
3342                         /* Pad with spaces on the right.  */
3343                         for (; pad &gt; 0; pad--)
3344                           *p++ = &#39; &#39;;
3345                       }
3346                     else if ((flags &amp; FLAG_ZERO) &amp;&amp; pad_ptr != NULL)
3347                       {
3348                         /* Pad with zeroes.  */
3349                         DCHAR_T *q = end;
3350 
3351                         while (p &gt; pad_ptr)
3352                           *--q = *--p;
3353                         for (; pad &gt; 0; pad--)
3354                           *p++ = &#39;0&#39;;
3355                       }
3356                     else
3357                       {
3358                         /* Pad with spaces on the left.  */
3359                         DCHAR_T *q = end;
3360 
3361                         while (p &gt; tmp)
3362                           *--q = *--p;
3363                         for (; pad &gt; 0; pad--)
3364                           *p++ = &#39; &#39;;
3365                       }
3366 
3367                     p = end;
3368                   }
3369 
3370                 count = p - tmp;
3371 
3372                 if (count &gt;= tmp_length)
3373                   /* tmp_length was incorrectly calculated - fix the
3374                      code above!  */
3375                   abort ();
3376 
3377                 /* Make room for the result.  */
3378                 if (count &gt;= allocated - length)
3379                   {
3380                     size_t n = xsum (length, count);
3381 
3382                     ENSURE_ALLOCATION (n);
3383                   }
3384 
3385                 /* Append the result.  */
3386                 memcpy (result + length, tmp, count * sizeof (DCHAR_T));
3387                 if (tmp != tmpbuf)
3388                   free (tmp);
3389                 length += count;
3390               }
3391 #endif
3392 #if (NEED_PRINTF_INFINITE_DOUBLE || NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE || NEED_PRINTF_LONG_DOUBLE) &amp;&amp; !defined IN_LIBINTL
3393             else if ((dp-&gt;conversion == &#39;f&#39; || dp-&gt;conversion == &#39;F&#39;
3394                       || dp-&gt;conversion == &#39;e&#39; || dp-&gt;conversion == &#39;E&#39;
3395                       || dp-&gt;conversion == &#39;g&#39; || dp-&gt;conversion == &#39;G&#39;
3396                       || dp-&gt;conversion == &#39;a&#39; || dp-&gt;conversion == &#39;A&#39;)
3397                      &amp;&amp; (0
3398 # if NEED_PRINTF_DOUBLE
3399                          || a.arg[dp-&gt;arg_index].type == TYPE_DOUBLE
3400 # elif NEED_PRINTF_INFINITE_DOUBLE
3401                          || (a.arg[dp-&gt;arg_index].type == TYPE_DOUBLE
3402                              /* The systems (mingw) which produce wrong output
3403                                 for Inf, -Inf, and NaN also do so for -0.0.
3404                                 Therefore we treat this case here as well.  */
3405                              &amp;&amp; is_infinite_or_zero (a.arg[dp-&gt;arg_index].a.a_double))
3406 # endif
3407 # if NEED_PRINTF_LONG_DOUBLE
3408                          || a.arg[dp-&gt;arg_index].type == TYPE_LONGDOUBLE
3409 # elif NEED_PRINTF_INFINITE_LONG_DOUBLE
3410                          || (a.arg[dp-&gt;arg_index].type == TYPE_LONGDOUBLE
3411                              /* Some systems produce wrong output for Inf,
3412                                 -Inf, and NaN.  Some systems in this category
3413                                 (IRIX 5.3) also do so for -0.0.  Therefore we
3414                                 treat this case here as well.  */
3415                              &amp;&amp; is_infinite_or_zerol (a.arg[dp-&gt;arg_index].a.a_longdouble))
3416 # endif
3417                         ))
3418               {
3419 # if (NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE) &amp;&amp; (NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE)
3420                 arg_type type = a.arg[dp-&gt;arg_index].type;
3421 # endif
3422                 int flags = dp-&gt;flags;
3423                 size_t width;
3424                 size_t count;
3425                 int has_precision;
3426                 size_t precision;
3427                 size_t tmp_length;
3428                 DCHAR_T tmpbuf[700];
3429                 DCHAR_T *tmp;
3430                 DCHAR_T *pad_ptr;
3431                 DCHAR_T *p;
3432 
3433                 width = 0;
3434                 if (dp-&gt;width_start != dp-&gt;width_end)
3435                   {
3436                     if (dp-&gt;width_arg_index != ARG_NONE)
3437                       {
3438                         int arg;
3439 
3440                         if (!(a.arg[dp-&gt;width_arg_index].type == TYPE_INT))
3441                           abort ();
3442                         arg = a.arg[dp-&gt;width_arg_index].a.a_int;
3443                         width = arg;
3444                         if (arg &lt; 0)
3445                           {
3446                             /* &quot;A negative field width is taken as a &#39;-&#39; flag
3447                                 followed by a positive field width.&quot;  */
3448                             flags |= FLAG_LEFT;
3449                             width = -width;
3450                           }
3451                       }
3452                     else
3453                       {
3454                         const FCHAR_T *digitp = dp-&gt;width_start;
3455 
3456                         do
3457                           width = xsum (xtimes (width, 10), *digitp++ - &#39;0&#39;);
3458                         while (digitp != dp-&gt;width_end);
3459                       }
3460                   }
3461 
3462                 has_precision = 0;
3463                 precision = 0;
3464                 if (dp-&gt;precision_start != dp-&gt;precision_end)
3465                   {
3466                     if (dp-&gt;precision_arg_index != ARG_NONE)
3467                       {
3468                         int arg;
3469 
3470                         if (!(a.arg[dp-&gt;precision_arg_index].type == TYPE_INT))
3471                           abort ();
3472                         arg = a.arg[dp-&gt;precision_arg_index].a.a_int;
3473                         /* &quot;A negative precision is taken as if the precision
3474                             were omitted.&quot;  */
3475                         if (arg &gt;= 0)
3476                           {
3477                             precision = arg;
3478                             has_precision = 1;
3479                           }
3480                       }
3481                     else
3482                       {
3483                         const FCHAR_T *digitp = dp-&gt;precision_start + 1;
3484 
3485                         precision = 0;
3486                         while (digitp != dp-&gt;precision_end)
3487                           precision = xsum (xtimes (precision, 10), *digitp++ - &#39;0&#39;);
3488                         has_precision = 1;
3489                       }
3490                   }
3491 
3492                 /* POSIX specifies the default precision to be 6 for %f, %F,
3493                    %e, %E, but not for %g, %G.  Implementations appear to use
3494                    the same default precision also for %g, %G.  But for %a, %A,
3495                    the default precision is 0.  */
3496                 if (!has_precision)
3497                   if (!(dp-&gt;conversion == &#39;a&#39; || dp-&gt;conversion == &#39;A&#39;))
3498                     precision = 6;
3499 
3500                 /* Allocate a temporary buffer of sufficient size.  */
3501 # if NEED_PRINTF_DOUBLE &amp;&amp; NEED_PRINTF_LONG_DOUBLE
3502                 tmp_length = (type == TYPE_LONGDOUBLE ? LDBL_DIG + 1 : DBL_DIG + 1);
3503 # elif NEED_PRINTF_INFINITE_DOUBLE &amp;&amp; NEED_PRINTF_LONG_DOUBLE
3504                 tmp_length = (type == TYPE_LONGDOUBLE ? LDBL_DIG + 1 : 0);
3505 # elif NEED_PRINTF_LONG_DOUBLE
3506                 tmp_length = LDBL_DIG + 1;
3507 # elif NEED_PRINTF_DOUBLE
3508                 tmp_length = DBL_DIG + 1;
3509 # else
3510                 tmp_length = 0;
3511 # endif
3512                 if (tmp_length &lt; precision)
3513                   tmp_length = precision;
3514 # if NEED_PRINTF_LONG_DOUBLE
3515 #  if NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE
3516                 if (type == TYPE_LONGDOUBLE)
3517 #  endif
3518                   if (dp-&gt;conversion == &#39;f&#39; || dp-&gt;conversion == &#39;F&#39;)
3519                     {
3520                       long double arg = a.arg[dp-&gt;arg_index].a.a_longdouble;
3521                       if (!(isnanl (arg) || arg + arg == arg))
3522                         {
3523                           /* arg is finite and nonzero.  */
3524                           int exponent = floorlog10l (arg &lt; 0 ? -arg : arg);
3525                           if (exponent &gt;= 0 &amp;&amp; tmp_length &lt; exponent + precision)
3526                             tmp_length = exponent + precision;
3527                         }
3528                     }
3529 # endif
3530 # if NEED_PRINTF_DOUBLE
3531 #  if NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE
3532                 if (type == TYPE_DOUBLE)
3533 #  endif
3534                   if (dp-&gt;conversion == &#39;f&#39; || dp-&gt;conversion == &#39;F&#39;)
3535                     {
3536                       double arg = a.arg[dp-&gt;arg_index].a.a_double;
3537                       if (!(isnand (arg) || arg + arg == arg))
3538                         {
3539                           /* arg is finite and nonzero.  */
3540                           int exponent = floorlog10 (arg &lt; 0 ? -arg : arg);
3541                           if (exponent &gt;= 0 &amp;&amp; tmp_length &lt; exponent + precision)
3542                             tmp_length = exponent + precision;
3543                         }
3544                     }
3545 # endif
3546                 /* Account for sign, decimal point etc. */
3547                 tmp_length = xsum (tmp_length, 12);
3548 
3549                 if (tmp_length &lt; width)
3550                   tmp_length = width;
3551 
3552                 tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */
3553 
3554                 if (tmp_length &lt;= sizeof (tmpbuf) / sizeof (DCHAR_T))
3555                   tmp = tmpbuf;
3556                 else
3557                   {
3558                     size_t tmp_memsize = xtimes (tmp_length, sizeof (DCHAR_T));
3559 
3560                     if (size_overflow_p (tmp_memsize))
3561                       /* Overflow, would lead to out of memory.  */
3562                       goto out_of_memory;
3563                     tmp = (DCHAR_T *) malloc (tmp_memsize);
3564                     if (tmp == NULL)
3565                       /* Out of memory.  */
3566                       goto out_of_memory;
3567                   }
3568 
3569                 pad_ptr = NULL;
3570                 p = tmp;
3571 
3572 # if NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE
3573 #  if NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE
3574                 if (type == TYPE_LONGDOUBLE)
3575 #  endif
3576                   {
3577                     long double arg = a.arg[dp-&gt;arg_index].a.a_longdouble;
3578 
3579                     if (isnanl (arg))
3580                       {
3581                         if (dp-&gt;conversion &gt;= &#39;A&#39; &amp;&amp; dp-&gt;conversion &lt;= &#39;Z&#39;)
3582                           {
3583                             *p++ = &#39;N&#39;; *p++ = &#39;A&#39;; *p++ = &#39;N&#39;;
3584                           }
3585                         else
3586                           {
3587                             *p++ = &#39;n&#39;; *p++ = &#39;a&#39;; *p++ = &#39;n&#39;;
3588                           }
3589                       }
3590                     else
3591                       {
3592                         int sign = 0;
3593                         DECL_LONG_DOUBLE_ROUNDING
3594 
3595                         BEGIN_LONG_DOUBLE_ROUNDING ();
3596 
3597                         if (signbit (arg)) /* arg &lt; 0.0L or negative zero */
3598                           {
3599                             sign = -1;
3600                             arg = -arg;
3601                           }
3602 
3603                         if (sign &lt; 0)
3604                           *p++ = &#39;-&#39;;
3605                         else if (flags &amp; FLAG_SHOWSIGN)
3606                           *p++ = &#39;+&#39;;
3607                         else if (flags &amp; FLAG_SPACE)
3608                           *p++ = &#39; &#39;;
3609 
3610                         if (arg &gt; 0.0L &amp;&amp; arg + arg == arg)
3611                           {
3612                             if (dp-&gt;conversion &gt;= &#39;A&#39; &amp;&amp; dp-&gt;conversion &lt;= &#39;Z&#39;)
3613                               {
3614                                 *p++ = &#39;I&#39;; *p++ = &#39;N&#39;; *p++ = &#39;F&#39;;
3615                               }
3616                             else
3617                               {
3618                                 *p++ = &#39;i&#39;; *p++ = &#39;n&#39;; *p++ = &#39;f&#39;;
3619                               }
3620                           }
3621                         else
3622                           {
3623 #  if NEED_PRINTF_LONG_DOUBLE
3624                             pad_ptr = p;
3625 
3626                             if (dp-&gt;conversion == &#39;f&#39; || dp-&gt;conversion == &#39;F&#39;)
3627                               {
3628                                 char *digits;
3629                                 size_t ndigits;
3630 
3631                                 digits =
3632                                   scale10_round_decimal_long_double (arg, precision);
3633                                 if (digits == NULL)
3634                                   {
3635                                     END_LONG_DOUBLE_ROUNDING ();
3636                                     goto out_of_memory;
3637                                   }
3638                                 ndigits = strlen (digits);
3639 
3640                                 if (ndigits &gt; precision)
3641                                   do
3642                                     {
3643                                       --ndigits;
3644                                       *p++ = digits[ndigits];
3645                                     }
3646                                   while (ndigits &gt; precision);
3647                                 else
3648                                   *p++ = &#39;0&#39;;
3649                                 /* Here ndigits &lt;= precision.  */
3650                                 if ((flags &amp; FLAG_ALT) || precision &gt; 0)
3651                                   {
3652                                     *p++ = decimal_point_char ();
3653                                     for (; precision &gt; ndigits; precision--)
3654                                       *p++ = &#39;0&#39;;
3655                                     while (ndigits &gt; 0)
3656                                       {
3657                                         --ndigits;
3658                                         *p++ = digits[ndigits];
3659                                       }
3660                                   }
3661 
3662                                 free (digits);
3663                               }
3664                             else if (dp-&gt;conversion == &#39;e&#39; || dp-&gt;conversion == &#39;E&#39;)
3665                               {
3666                                 int exponent;
3667 
3668                                 if (arg == 0.0L)
3669                                   {
3670                                     exponent = 0;
3671                                     *p++ = &#39;0&#39;;
3672                                     if ((flags &amp; FLAG_ALT) || precision &gt; 0)
3673                                       {
3674                                         *p++ = decimal_point_char ();
3675                                         for (; precision &gt; 0; precision--)
3676                                           *p++ = &#39;0&#39;;
3677                                       }
3678                                   }
3679                                 else
3680                                   {
3681                                     /* arg &gt; 0.0L.  */
3682                                     int adjusted;
3683                                     char *digits;
3684                                     size_t ndigits;
3685 
3686                                     exponent = floorlog10l (arg);
3687                                     adjusted = 0;
3688                                     for (;;)
3689                                       {
3690                                         digits =
3691                                           scale10_round_decimal_long_double (arg,
3692                                                                              (int)precision - exponent);
3693                                         if (digits == NULL)
3694                                           {
3695                                             END_LONG_DOUBLE_ROUNDING ();
3696                                             goto out_of_memory;
3697                                           }
3698                                         ndigits = strlen (digits);
3699 
3700                                         if (ndigits == precision + 1)
3701                                           break;
3702                                         if (ndigits &lt; precision
3703                                             || ndigits &gt; precision + 2)
3704                                           /* The exponent was not guessed
3705                                              precisely enough.  */
3706                                           abort ();
3707                                         if (adjusted)
3708                                           /* None of two values of exponent is
3709                                              the right one.  Prevent an endless
3710                                              loop.  */
3711                                           abort ();
3712                                         free (digits);
3713                                         if (ndigits == precision)
3714                                           exponent -= 1;
3715                                         else
3716                                           exponent += 1;
3717                                         adjusted = 1;
3718                                       }
3719                                     /* Here ndigits = precision+1.  */
3720                                     if (is_borderline (digits, precision))
3721                                       {
3722                                         /* Maybe the exponent guess was too high
3723                                            and a smaller exponent can be reached
3724                                            by turning a 10...0 into 9...9x.  */
3725                                         char *digits2 =
3726                                           scale10_round_decimal_long_double (arg,
3727                                                                              (int)precision - exponent + 1);
3728                                         if (digits2 == NULL)
3729                                           {
3730                                             free (digits);
3731                                             END_LONG_DOUBLE_ROUNDING ();
3732                                             goto out_of_memory;
3733                                           }
3734                                         if (strlen (digits2) == precision + 1)
3735                                           {
3736                                             free (digits);
3737                                             digits = digits2;
3738                                             exponent -= 1;
3739                                           }
3740                                         else
3741                                           free (digits2);
3742                                       }
3743                                     /* Here ndigits = precision+1.  */
3744 
3745                                     *p++ = digits[--ndigits];
3746                                     if ((flags &amp; FLAG_ALT) || precision &gt; 0)
3747                                       {
3748                                         *p++ = decimal_point_char ();
3749                                         while (ndigits &gt; 0)
3750                                           {
3751                                             --ndigits;
3752                                             *p++ = digits[ndigits];
3753                                           }
3754                                       }
3755 
3756                                     free (digits);
3757                                   }
3758 
3759                                 *p++ = dp-&gt;conversion; /* &#39;e&#39; or &#39;E&#39; */
3760 #   if WIDE_CHAR_VERSION
3761                                 {
3762                                   static const wchar_t decimal_format[] =
3763                                     { &#39;%&#39;, &#39;+&#39;, &#39;.&#39;, &#39;2&#39;, &#39;d&#39;, &#39;\0&#39; };
3764                                   SNPRINTF (p, 6 + 1, decimal_format, exponent);
3765                                 }
3766                                 while (*p != &#39;\0&#39;)
3767                                   p++;
3768 #   else
3769                                 if (sizeof (DCHAR_T) == 1)
3770                                   {
3771                                     sprintf ((char *) p, &quot;%+.2d&quot;, exponent);
3772                                     while (*p != &#39;\0&#39;)
3773                                       p++;
3774                                   }
3775                                 else
3776                                   {
3777                                     char expbuf[6 + 1];
3778                                     const char *ep;
3779                                     sprintf (expbuf, &quot;%+.2d&quot;, exponent);
3780                                     for (ep = expbuf; (*p = *ep) != &#39;\0&#39;; ep++)
3781                                       p++;
3782                                   }
3783 #   endif
3784                               }
3785                             else if (dp-&gt;conversion == &#39;g&#39; || dp-&gt;conversion == &#39;G&#39;)
3786                               {
3787                                 if (precision == 0)
3788                                   precision = 1;
3789                                 /* precision &gt;= 1.  */
3790 
3791                                 if (arg == 0.0L)
3792                                   /* The exponent is 0, &gt;= -4, &lt; precision.
3793                                      Use fixed-point notation.  */
3794                                   {
3795                                     size_t ndigits = precision;
3796                                     /* Number of trailing zeroes that have to be
3797                                        dropped.  */
3798                                     size_t nzeroes =
3799                                       (flags &amp; FLAG_ALT ? 0 : precision - 1);
3800 
3801                                     --ndigits;
3802                                     *p++ = &#39;0&#39;;
3803                                     if ((flags &amp; FLAG_ALT) || ndigits &gt; nzeroes)
3804                                       {
3805                                         *p++ = decimal_point_char ();
3806                                         while (ndigits &gt; nzeroes)
3807                                           {
3808                                             --ndigits;
3809                                             *p++ = &#39;0&#39;;
3810                                           }
3811                                       }
3812                                   }
3813                                 else
3814                                   {
3815                                     /* arg &gt; 0.0L.  */
3816                                     int exponent;
3817                                     int adjusted;
3818                                     char *digits;
3819                                     size_t ndigits;
3820                                     size_t nzeroes;
3821 
3822                                     exponent = floorlog10l (arg);
3823                                     adjusted = 0;
3824                                     for (;;)
3825                                       {
3826                                         digits =
3827                                           scale10_round_decimal_long_double (arg,
3828                                                                              (int)(precision - 1) - exponent);
3829                                         if (digits == NULL)
3830                                           {
3831                                             END_LONG_DOUBLE_ROUNDING ();
3832                                             goto out_of_memory;
3833                                           }
3834                                         ndigits = strlen (digits);
3835 
3836                                         if (ndigits == precision)
3837                                           break;
3838                                         if (ndigits &lt; precision - 1
3839                                             || ndigits &gt; precision + 1)
3840                                           /* The exponent was not guessed
3841                                              precisely enough.  */
3842                                           abort ();
3843                                         if (adjusted)
3844                                           /* None of two values of exponent is
3845                                              the right one.  Prevent an endless
3846                                              loop.  */
3847                                           abort ();
3848                                         free (digits);
3849                                         if (ndigits &lt; precision)
3850                                           exponent -= 1;
3851                                         else
3852                                           exponent += 1;
3853                                         adjusted = 1;
3854                                       }
3855                                     /* Here ndigits = precision.  */
3856                                     if (is_borderline (digits, precision - 1))
3857                                       {
3858                                         /* Maybe the exponent guess was too high
3859                                            and a smaller exponent can be reached
3860                                            by turning a 10...0 into 9...9x.  */
3861                                         char *digits2 =
3862                                           scale10_round_decimal_long_double (arg,
3863                                                                              (int)(precision - 1) - exponent + 1);
3864                                         if (digits2 == NULL)
3865                                           {
3866                                             free (digits);
3867                                             END_LONG_DOUBLE_ROUNDING ();
3868                                             goto out_of_memory;
3869                                           }
3870                                         if (strlen (digits2) == precision)
3871                                           {
3872                                             free (digits);
3873                                             digits = digits2;
3874                                             exponent -= 1;
3875                                           }
3876                                         else
3877                                           free (digits2);
3878                                       }
3879                                     /* Here ndigits = precision.  */
3880 
3881                                     /* Determine the number of trailing zeroes
3882                                        that have to be dropped.  */
3883                                     nzeroes = 0;
3884                                     if ((flags &amp; FLAG_ALT) == 0)
3885                                       while (nzeroes &lt; ndigits
3886                                              &amp;&amp; digits[nzeroes] == &#39;0&#39;)
3887                                         nzeroes++;
3888 
3889                                     /* The exponent is now determined.  */
3890                                     if (exponent &gt;= -4
3891                                         &amp;&amp; exponent &lt; (long)precision)
3892                                       {
3893                                         /* Fixed-point notation:
3894                                            max(exponent,0)+1 digits, then the
3895                                            decimal point, then the remaining
3896                                            digits without trailing zeroes.  */
3897                                         if (exponent &gt;= 0)
3898                                           {
3899                                             size_t ecount = exponent + 1;
3900                                             /* Note: count &lt;= precision = ndigits.  */
3901                                             for (; ecount &gt; 0; ecount--)
3902                                               *p++ = digits[--ndigits];
3903                                             if ((flags &amp; FLAG_ALT) || ndigits &gt; nzeroes)
3904                                               {
3905                                                 *p++ = decimal_point_char ();
3906                                                 while (ndigits &gt; nzeroes)
3907                                                   {
3908                                                     --ndigits;
3909                                                     *p++ = digits[ndigits];
3910                                                   }
3911                                               }
3912                                           }
3913                                         else
3914                                           {
3915                                             size_t ecount = -exponent - 1;
3916                                             *p++ = &#39;0&#39;;
3917                                             *p++ = decimal_point_char ();
3918                                             for (; ecount &gt; 0; ecount--)
3919                                               *p++ = &#39;0&#39;;
3920                                             while (ndigits &gt; nzeroes)
3921                                               {
3922                                                 --ndigits;
3923                                                 *p++ = digits[ndigits];
3924                                               }
3925                                           }
3926                                       }
3927                                     else
3928                                       {
3929                                         /* Exponential notation.  */
3930                                         *p++ = digits[--ndigits];
3931                                         if ((flags &amp; FLAG_ALT) || ndigits &gt; nzeroes)
3932                                           {
3933                                             *p++ = decimal_point_char ();
3934                                             while (ndigits &gt; nzeroes)
3935                                               {
3936                                                 --ndigits;
3937                                                 *p++ = digits[ndigits];
3938                                               }
3939                                           }
3940                                         *p++ = dp-&gt;conversion - &#39;G&#39; + &#39;E&#39;; /* &#39;e&#39; or &#39;E&#39; */
3941 #   if WIDE_CHAR_VERSION
3942                                         {
3943                                           static const wchar_t decimal_format[] =
3944                                             { &#39;%&#39;, &#39;+&#39;, &#39;.&#39;, &#39;2&#39;, &#39;d&#39;, &#39;\0&#39; };
3945                                           SNPRINTF (p, 6 + 1, decimal_format, exponent);
3946                                         }
3947                                         while (*p != &#39;\0&#39;)
3948                                           p++;
3949 #   else
3950                                         if (sizeof (DCHAR_T) == 1)
3951                                           {
3952                                             sprintf ((char *) p, &quot;%+.2d&quot;, exponent);
3953                                             while (*p != &#39;\0&#39;)
3954                                               p++;
3955                                           }
3956                                         else
3957                                           {
3958                                             char expbuf[6 + 1];
3959                                             const char *ep;
3960                                             sprintf (expbuf, &quot;%+.2d&quot;, exponent);
3961                                             for (ep = expbuf; (*p = *ep) != &#39;\0&#39;; ep++)
3962                                               p++;
3963                                           }
3964 #   endif
3965                                       }
3966 
3967                                     free (digits);
3968                                   }
3969                               }
3970                             else
3971                               abort ();
3972 #  else
3973                             /* arg is finite.  */
3974                             if (!(arg == 0.0L))
3975                               abort ();
3976 
3977                             pad_ptr = p;
3978 
3979                             if (dp-&gt;conversion == &#39;f&#39; || dp-&gt;conversion == &#39;F&#39;)
3980                               {
3981                                 *p++ = &#39;0&#39;;
3982                                 if ((flags &amp; FLAG_ALT) || precision &gt; 0)
3983                                   {
3984                                     *p++ = decimal_point_char ();
3985                                     for (; precision &gt; 0; precision--)
3986                                       *p++ = &#39;0&#39;;
3987                                   }
3988                               }
3989                             else if (dp-&gt;conversion == &#39;e&#39; || dp-&gt;conversion == &#39;E&#39;)
3990                               {
3991                                 *p++ = &#39;0&#39;;
3992                                 if ((flags &amp; FLAG_ALT) || precision &gt; 0)
3993                                   {
3994                                     *p++ = decimal_point_char ();
3995                                     for (; precision &gt; 0; precision--)
3996                                       *p++ = &#39;0&#39;;
3997                                   }
3998                                 *p++ = dp-&gt;conversion; /* &#39;e&#39; or &#39;E&#39; */
3999                                 *p++ = &#39;+&#39;;
4000                                 *p++ = &#39;0&#39;;
4001                                 *p++ = &#39;0&#39;;
4002                               }
4003                             else if (dp-&gt;conversion == &#39;g&#39; || dp-&gt;conversion == &#39;G&#39;)
4004                               {
4005                                 *p++ = &#39;0&#39;;
4006                                 if (flags &amp; FLAG_ALT)
4007                                   {
4008                                     size_t ndigits =
4009                                       (precision &gt; 0 ? precision - 1 : 0);
4010                                     *p++ = decimal_point_char ();
4011                                     for (; ndigits &gt; 0; --ndigits)
4012                                       *p++ = &#39;0&#39;;
4013                                   }
4014                               }
4015                             else if (dp-&gt;conversion == &#39;a&#39; || dp-&gt;conversion == &#39;A&#39;)
4016                               {
4017                                 *p++ = &#39;0&#39;;
4018                                 *p++ = dp-&gt;conversion - &#39;A&#39; + &#39;X&#39;;
4019                                 pad_ptr = p;
4020                                 *p++ = &#39;0&#39;;
4021                                 if ((flags &amp; FLAG_ALT) || precision &gt; 0)
4022                                   {
4023                                     *p++ = decimal_point_char ();
4024                                     for (; precision &gt; 0; precision--)
4025                                       *p++ = &#39;0&#39;;
4026                                   }
4027                                 *p++ = dp-&gt;conversion - &#39;A&#39; + &#39;P&#39;;
4028                                 *p++ = &#39;+&#39;;
4029                                 *p++ = &#39;0&#39;;
4030                               }
4031                             else
4032                               abort ();
4033 #  endif
4034                           }
4035 
4036                         END_LONG_DOUBLE_ROUNDING ();
4037                       }
4038                   }
4039 #  if NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE
4040                 else
4041 #  endif
4042 # endif
4043 # if NEED_PRINTF_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE
4044                   {
4045                     double arg = a.arg[dp-&gt;arg_index].a.a_double;
4046 
4047                     if (isnand (arg))
4048                       {
4049                         if (dp-&gt;conversion &gt;= &#39;A&#39; &amp;&amp; dp-&gt;conversion &lt;= &#39;Z&#39;)
4050                           {
4051                             *p++ = &#39;N&#39;; *p++ = &#39;A&#39;; *p++ = &#39;N&#39;;
4052                           }
4053                         else
4054                           {
4055                             *p++ = &#39;n&#39;; *p++ = &#39;a&#39;; *p++ = &#39;n&#39;;
4056                           }
4057                       }
4058                     else
4059                       {
4060                         int sign = 0;
4061 
4062                         if (signbit (arg)) /* arg &lt; 0.0 or negative zero */
4063                           {
4064                             sign = -1;
4065                             arg = -arg;
4066                           }
4067 
4068                         if (sign &lt; 0)
4069                           *p++ = &#39;-&#39;;
4070                         else if (flags &amp; FLAG_SHOWSIGN)
4071                           *p++ = &#39;+&#39;;
4072                         else if (flags &amp; FLAG_SPACE)
4073                           *p++ = &#39; &#39;;
4074 
4075                         if (arg &gt; 0.0 &amp;&amp; arg + arg == arg)
4076                           {
4077                             if (dp-&gt;conversion &gt;= &#39;A&#39; &amp;&amp; dp-&gt;conversion &lt;= &#39;Z&#39;)
4078                               {
4079                                 *p++ = &#39;I&#39;; *p++ = &#39;N&#39;; *p++ = &#39;F&#39;;
4080                               }
4081                             else
4082                               {
4083                                 *p++ = &#39;i&#39;; *p++ = &#39;n&#39;; *p++ = &#39;f&#39;;
4084                               }
4085                           }
4086                         else
4087                           {
4088 #  if NEED_PRINTF_DOUBLE
4089                             pad_ptr = p;
4090 
4091                             if (dp-&gt;conversion == &#39;f&#39; || dp-&gt;conversion == &#39;F&#39;)
4092                               {
4093                                 char *digits;
4094                                 size_t ndigits;
4095 
4096                                 digits =
4097                                   scale10_round_decimal_double (arg, precision);
4098                                 if (digits == NULL)
4099                                   goto out_of_memory;
4100                                 ndigits = strlen (digits);
4101 
4102                                 if (ndigits &gt; precision)
4103                                   do
4104                                     {
4105                                       --ndigits;
4106                                       *p++ = digits[ndigits];
4107                                     }
4108                                   while (ndigits &gt; precision);
4109                                 else
4110                                   *p++ = &#39;0&#39;;
4111                                 /* Here ndigits &lt;= precision.  */
4112                                 if ((flags &amp; FLAG_ALT) || precision &gt; 0)
4113                                   {
4114                                     *p++ = decimal_point_char ();
4115                                     for (; precision &gt; ndigits; precision--)
4116                                       *p++ = &#39;0&#39;;
4117                                     while (ndigits &gt; 0)
4118                                       {
4119                                         --ndigits;
4120                                         *p++ = digits[ndigits];
4121                                       }
4122                                   }
4123 
4124                                 free (digits);
4125                               }
4126                             else if (dp-&gt;conversion == &#39;e&#39; || dp-&gt;conversion == &#39;E&#39;)
4127                               {
4128                                 int exponent;
4129 
4130                                 if (arg == 0.0)
4131                                   {
4132                                     exponent = 0;
4133                                     *p++ = &#39;0&#39;;
4134                                     if ((flags &amp; FLAG_ALT) || precision &gt; 0)
4135                                       {
4136                                         *p++ = decimal_point_char ();
4137                                         for (; precision &gt; 0; precision--)
4138                                           *p++ = &#39;0&#39;;
4139                                       }
4140                                   }
4141                                 else
4142                                   {
4143                                     /* arg &gt; 0.0.  */
4144                                     int adjusted;
4145                                     char *digits;
4146                                     size_t ndigits;
4147 
4148                                     exponent = floorlog10 (arg);
4149                                     adjusted = 0;
4150                                     for (;;)
4151                                       {
4152                                         digits =
4153                                           scale10_round_decimal_double (arg,
4154                                                                         (int)precision - exponent);
4155                                         if (digits == NULL)
4156                                           goto out_of_memory;
4157                                         ndigits = strlen (digits);
4158 
4159                                         if (ndigits == precision + 1)
4160                                           break;
4161                                         if (ndigits &lt; precision
4162                                             || ndigits &gt; precision + 2)
4163                                           /* The exponent was not guessed
4164                                              precisely enough.  */
4165                                           abort ();
4166                                         if (adjusted)
4167                                           /* None of two values of exponent is
4168                                              the right one.  Prevent an endless
4169                                              loop.  */
4170                                           abort ();
4171                                         free (digits);
4172                                         if (ndigits == precision)
4173                                           exponent -= 1;
4174                                         else
4175                                           exponent += 1;
4176                                         adjusted = 1;
4177                                       }
4178                                     /* Here ndigits = precision+1.  */
4179                                     if (is_borderline (digits, precision))
4180                                       {
4181                                         /* Maybe the exponent guess was too high
4182                                            and a smaller exponent can be reached
4183                                            by turning a 10...0 into 9...9x.  */
4184                                         char *digits2 =
4185                                           scale10_round_decimal_double (arg,
4186                                                                         (int)precision - exponent + 1);
4187                                         if (digits2 == NULL)
4188                                           {
4189                                             free (digits);
4190                                             goto out_of_memory;
4191                                           }
4192                                         if (strlen (digits2) == precision + 1)
4193                                           {
4194                                             free (digits);
4195                                             digits = digits2;
4196                                             exponent -= 1;
4197                                           }
4198                                         else
4199                                           free (digits2);
4200                                       }
4201                                     /* Here ndigits = precision+1.  */
4202 
4203                                     *p++ = digits[--ndigits];
4204                                     if ((flags &amp; FLAG_ALT) || precision &gt; 0)
4205                                       {
4206                                         *p++ = decimal_point_char ();
4207                                         while (ndigits &gt; 0)
4208                                           {
4209                                             --ndigits;
4210                                             *p++ = digits[ndigits];
4211                                           }
4212                                       }
4213 
4214                                     free (digits);
4215                                   }
4216 
4217                                 *p++ = dp-&gt;conversion; /* &#39;e&#39; or &#39;E&#39; */
4218 #   if WIDE_CHAR_VERSION
4219                                 {
4220                                   static const wchar_t decimal_format[] =
4221                                     /* Produce the same number of exponent digits
4222                                        as the native printf implementation.  */
4223 #    if (defined _WIN32 || defined __WIN32__) &amp;&amp; ! defined __CYGWIN__
4224                                     { &#39;%&#39;, &#39;+&#39;, &#39;.&#39;, &#39;3&#39;, &#39;d&#39;, &#39;\0&#39; };
4225 #    else
4226                                     { &#39;%&#39;, &#39;+&#39;, &#39;.&#39;, &#39;2&#39;, &#39;d&#39;, &#39;\0&#39; };
4227 #    endif
4228                                   SNPRINTF (p, 6 + 1, decimal_format, exponent);
4229                                 }
4230                                 while (*p != &#39;\0&#39;)
4231                                   p++;
4232 #   else
4233                                 {
4234                                   static const char decimal_format[] =
4235                                     /* Produce the same number of exponent digits
4236                                        as the native printf implementation.  */
4237 #    if (defined _WIN32 || defined __WIN32__) &amp;&amp; ! defined __CYGWIN__
4238                                     &quot;%+.3d&quot;;
4239 #    else
4240                                     &quot;%+.2d&quot;;
4241 #    endif
4242                                   if (sizeof (DCHAR_T) == 1)
4243                                     {
4244                                       sprintf ((char *) p, decimal_format, exponent);
4245                                       while (*p != &#39;\0&#39;)
4246                                         p++;
4247                                     }
4248                                   else
4249                                     {
4250                                       char expbuf[6 + 1];
4251                                       const char *ep;
4252                                       sprintf (expbuf, decimal_format, exponent);
4253                                       for (ep = expbuf; (*p = *ep) != &#39;\0&#39;; ep++)
4254                                         p++;
4255                                     }
4256                                 }
4257 #   endif
4258                               }
4259                             else if (dp-&gt;conversion == &#39;g&#39; || dp-&gt;conversion == &#39;G&#39;)
4260                               {
4261                                 if (precision == 0)
4262                                   precision = 1;
4263                                 /* precision &gt;= 1.  */
4264 
4265                                 if (arg == 0.0)
4266                                   /* The exponent is 0, &gt;= -4, &lt; precision.
4267                                      Use fixed-point notation.  */
4268                                   {
4269                                     size_t ndigits = precision;
4270                                     /* Number of trailing zeroes that have to be
4271                                        dropped.  */
4272                                     size_t nzeroes =
4273                                       (flags &amp; FLAG_ALT ? 0 : precision - 1);
4274 
4275                                     --ndigits;
4276                                     *p++ = &#39;0&#39;;
4277                                     if ((flags &amp; FLAG_ALT) || ndigits &gt; nzeroes)
4278                                       {
4279                                         *p++ = decimal_point_char ();
4280                                         while (ndigits &gt; nzeroes)
4281                                           {
4282                                             --ndigits;
4283                                             *p++ = &#39;0&#39;;
4284                                           }
4285                                       }
4286                                   }
4287                                 else
4288                                   {
4289                                     /* arg &gt; 0.0.  */
4290                                     int exponent;
4291                                     int adjusted;
4292                                     char *digits;
4293                                     size_t ndigits;
4294                                     size_t nzeroes;
4295 
4296                                     exponent = floorlog10 (arg);
4297                                     adjusted = 0;
4298                                     for (;;)
4299                                       {
4300                                         digits =
4301                                           scale10_round_decimal_double (arg,
4302                                                                         (int)(precision - 1) - exponent);
4303                                         if (digits == NULL)
4304                                           goto out_of_memory;
4305                                         ndigits = strlen (digits);
4306 
4307                                         if (ndigits == precision)
4308                                           break;
4309                                         if (ndigits &lt; precision - 1
4310                                             || ndigits &gt; precision + 1)
4311                                           /* The exponent was not guessed
4312                                              precisely enough.  */
4313                                           abort ();
4314                                         if (adjusted)
4315                                           /* None of two values of exponent is
4316                                              the right one.  Prevent an endless
4317                                              loop.  */
4318                                           abort ();
4319                                         free (digits);
4320                                         if (ndigits &lt; precision)
4321                                           exponent -= 1;
4322                                         else
4323                                           exponent += 1;
4324                                         adjusted = 1;
4325                                       }
4326                                     /* Here ndigits = precision.  */
4327                                     if (is_borderline (digits, precision - 1))
4328                                       {
4329                                         /* Maybe the exponent guess was too high
4330                                            and a smaller exponent can be reached
4331                                            by turning a 10...0 into 9...9x.  */
4332                                         char *digits2 =
4333                                           scale10_round_decimal_double (arg,
4334                                                                         (int)(precision - 1) - exponent + 1);
4335                                         if (digits2 == NULL)
4336                                           {
4337                                             free (digits);
4338                                             goto out_of_memory;
4339                                           }
4340                                         if (strlen (digits2) == precision)
4341                                           {
4342                                             free (digits);
4343                                             digits = digits2;
4344                                             exponent -= 1;
4345                                           }
4346                                         else
4347                                           free (digits2);
4348                                       }
4349                                     /* Here ndigits = precision.  */
4350 
4351                                     /* Determine the number of trailing zeroes
4352                                        that have to be dropped.  */
4353                                     nzeroes = 0;
4354                                     if ((flags &amp; FLAG_ALT) == 0)
4355                                       while (nzeroes &lt; ndigits
4356                                              &amp;&amp; digits[nzeroes] == &#39;0&#39;)
4357                                         nzeroes++;
4358 
4359                                     /* The exponent is now determined.  */
4360                                     if (exponent &gt;= -4
4361                                         &amp;&amp; exponent &lt; (long)precision)
4362                                       {
4363                                         /* Fixed-point notation:
4364                                            max(exponent,0)+1 digits, then the
4365                                            decimal point, then the remaining
4366                                            digits without trailing zeroes.  */
4367                                         if (exponent &gt;= 0)
4368                                           {
4369                                             size_t ecount = exponent + 1;
4370                                             /* Note: ecount &lt;= precision = ndigits.  */
4371                                             for (; ecount &gt; 0; ecount--)
4372                                               *p++ = digits[--ndigits];
4373                                             if ((flags &amp; FLAG_ALT) || ndigits &gt; nzeroes)
4374                                               {
4375                                                 *p++ = decimal_point_char ();
4376                                                 while (ndigits &gt; nzeroes)
4377                                                   {
4378                                                     --ndigits;
4379                                                     *p++ = digits[ndigits];
4380                                                   }
4381                                               }
4382                                           }
4383                                         else
4384                                           {
4385                                             size_t ecount = -exponent - 1;
4386                                             *p++ = &#39;0&#39;;
4387                                             *p++ = decimal_point_char ();
4388                                             for (; ecount &gt; 0; ecount--)
4389                                               *p++ = &#39;0&#39;;
4390                                             while (ndigits &gt; nzeroes)
4391                                               {
4392                                                 --ndigits;
4393                                                 *p++ = digits[ndigits];
4394                                               }
4395                                           }
4396                                       }
4397                                     else
4398                                       {
4399                                         /* Exponential notation.  */
4400                                         *p++ = digits[--ndigits];
4401                                         if ((flags &amp; FLAG_ALT) || ndigits &gt; nzeroes)
4402                                           {
4403                                             *p++ = decimal_point_char ();
4404                                             while (ndigits &gt; nzeroes)
4405                                               {
4406                                                 --ndigits;
4407                                                 *p++ = digits[ndigits];
4408                                               }
4409                                           }
4410                                         *p++ = dp-&gt;conversion - &#39;G&#39; + &#39;E&#39;; /* &#39;e&#39; or &#39;E&#39; */
4411 #   if WIDE_CHAR_VERSION
4412                                         {
4413                                           static const wchar_t decimal_format[] =
4414                                             /* Produce the same number of exponent digits
4415                                                as the native printf implementation.  */
4416 #    if (defined _WIN32 || defined __WIN32__) &amp;&amp; ! defined __CYGWIN__
4417                                             { &#39;%&#39;, &#39;+&#39;, &#39;.&#39;, &#39;3&#39;, &#39;d&#39;, &#39;\0&#39; };
4418 #    else
4419                                             { &#39;%&#39;, &#39;+&#39;, &#39;.&#39;, &#39;2&#39;, &#39;d&#39;, &#39;\0&#39; };
4420 #    endif
4421                                           SNPRINTF (p, 6 + 1, decimal_format, exponent);
4422                                         }
4423                                         while (*p != &#39;\0&#39;)
4424                                           p++;
4425 #   else
4426                                         {
4427                                           static const char decimal_format[] =
4428                                             /* Produce the same number of exponent digits
4429                                                as the native printf implementation.  */
4430 #    if (defined _WIN32 || defined __WIN32__) &amp;&amp; ! defined __CYGWIN__
4431                                             &quot;%+.3d&quot;;
4432 #    else
4433                                             &quot;%+.2d&quot;;
4434 #    endif
4435                                           if (sizeof (DCHAR_T) == 1)
4436                                             {
4437                                               sprintf ((char *) p, decimal_format, exponent);
4438                                               while (*p != &#39;\0&#39;)
4439                                                 p++;
4440                                             }
4441                                           else
4442                                             {
4443                                               char expbuf[6 + 1];
4444                                               const char *ep;
4445                                               sprintf (expbuf, decimal_format, exponent);
4446                                               for (ep = expbuf; (*p = *ep) != &#39;\0&#39;; ep++)
4447                                                 p++;
4448                                             }
4449                                         }
4450 #   endif
4451                                       }
4452 
4453                                     free (digits);
4454                                   }
4455                               }
4456                             else
4457                               abort ();
4458 #  else
4459                             /* arg is finite.  */
4460                             if (!(arg == 0.0))
4461                               abort ();
4462 
4463                             pad_ptr = p;
4464 
4465                             if (dp-&gt;conversion == &#39;f&#39; || dp-&gt;conversion == &#39;F&#39;)
4466                               {
4467                                 *p++ = &#39;0&#39;;
4468                                 if ((flags &amp; FLAG_ALT) || precision &gt; 0)
4469                                   {
4470                                     *p++ = decimal_point_char ();
4471                                     for (; precision &gt; 0; precision--)
4472                                       *p++ = &#39;0&#39;;
4473                                   }
4474                               }
4475                             else if (dp-&gt;conversion == &#39;e&#39; || dp-&gt;conversion == &#39;E&#39;)
4476                               {
4477                                 *p++ = &#39;0&#39;;
4478                                 if ((flags &amp; FLAG_ALT) || precision &gt; 0)
4479                                   {
4480                                     *p++ = decimal_point_char ();
4481                                     for (; precision &gt; 0; precision--)
4482                                       *p++ = &#39;0&#39;;
4483                                   }
4484                                 *p++ = dp-&gt;conversion; /* &#39;e&#39; or &#39;E&#39; */
4485                                 *p++ = &#39;+&#39;;
4486                                 /* Produce the same number of exponent digits as
4487                                    the native printf implementation.  */
4488 #   if (defined _WIN32 || defined __WIN32__) &amp;&amp; ! defined __CYGWIN__
4489                                 *p++ = &#39;0&#39;;
4490 #   endif
4491                                 *p++ = &#39;0&#39;;
4492                                 *p++ = &#39;0&#39;;
4493                               }
4494                             else if (dp-&gt;conversion == &#39;g&#39; || dp-&gt;conversion == &#39;G&#39;)
4495                               {
4496                                 *p++ = &#39;0&#39;;
4497                                 if (flags &amp; FLAG_ALT)
4498                                   {
4499                                     size_t ndigits =
4500                                       (precision &gt; 0 ? precision - 1 : 0);
4501                                     *p++ = decimal_point_char ();
4502                                     for (; ndigits &gt; 0; --ndigits)
4503                                       *p++ = &#39;0&#39;;
4504                                   }
4505                               }
4506                             else
4507                               abort ();
4508 #  endif
4509                           }
4510                       }
4511                   }
4512 # endif
4513 
4514                 /* The generated string now extends from tmp to p, with the
4515                    zero padding insertion point being at pad_ptr.  */
4516                 count = p - tmp;
4517 
4518                 if (count &lt; width)
4519                   {
4520                     size_t pad = width - count;
4521                     DCHAR_T *end = p + pad;
4522 
4523                     if (flags &amp; FLAG_LEFT)
4524                       {
4525                         /* Pad with spaces on the right.  */
4526                         for (; pad &gt; 0; pad--)
4527                           *p++ = &#39; &#39;;
4528                       }
4529                     else if ((flags &amp; FLAG_ZERO) &amp;&amp; pad_ptr != NULL)
4530                       {
4531                         /* Pad with zeroes.  */
4532                         DCHAR_T *q = end;
4533 
4534                         while (p &gt; pad_ptr)
4535                           *--q = *--p;
4536                         for (; pad &gt; 0; pad--)
4537                           *p++ = &#39;0&#39;;
4538                       }
4539                     else
4540                       {
4541                         /* Pad with spaces on the left.  */
4542                         DCHAR_T *q = end;
4543 
4544                         while (p &gt; tmp)
4545                           *--q = *--p;
4546                         for (; pad &gt; 0; pad--)
4547                           *p++ = &#39; &#39;;
4548                       }
4549 
4550                     p = end;
4551                   }
4552 
4553                 count = p - tmp;
4554 
4555                 if (count &gt;= tmp_length)
4556                   /* tmp_length was incorrectly calculated - fix the
4557                      code above!  */
4558                   abort ();
4559 
4560                 /* Make room for the result.  */
4561                 if (count &gt;= allocated - length)
4562                   {
4563                     size_t n = xsum (length, count);
4564 
4565                     ENSURE_ALLOCATION (n);
4566                   }
4567 
4568                 /* Append the result.  */
4569                 memcpy (result + length, tmp, count * sizeof (DCHAR_T));
4570                 if (tmp != tmpbuf)
4571                   free (tmp);
4572                 length += count;
4573               }
4574 #endif
4575             else
4576               {
4577                 arg_type type = a.arg[dp-&gt;arg_index].type;
4578                 int flags = dp-&gt;flags;
4579 #if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION
4580                 int has_width;
4581 #endif
4582 #if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION
4583                 size_t width;
4584 #endif
4585 #if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION
4586                 int has_precision;
4587                 size_t precision;
4588 #endif
4589 #if NEED_PRINTF_UNBOUNDED_PRECISION
4590                 int prec_ourselves;
4591 #else
4592 #               define prec_ourselves 0
4593 #endif
4594 #if NEED_PRINTF_FLAG_LEFTADJUST
4595 #               define pad_ourselves 1
4596 #elif !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION
4597                 int pad_ourselves;
4598 #else
4599 #               define pad_ourselves 0
4600 #endif
4601                 TCHAR_T *fbp;
4602                 unsigned int prefix_count;
4603                 int prefixes[2] IF_LINT (= { 0 });
4604                 int orig_errno;
4605 #if !USE_SNPRINTF
4606                 size_t tmp_length;
4607                 TCHAR_T tmpbuf[700];
4608                 TCHAR_T *tmp;
4609 #endif
4610 
4611 #if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION
4612                 has_width = 0;
4613 #endif
4614 #if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION
4615                 width = 0;
4616                 if (dp-&gt;width_start != dp-&gt;width_end)
4617                   {
4618                     if (dp-&gt;width_arg_index != ARG_NONE)
4619                       {
4620                         int arg;
4621 
4622                         if (!(a.arg[dp-&gt;width_arg_index].type == TYPE_INT))
4623                           abort ();
4624                         arg = a.arg[dp-&gt;width_arg_index].a.a_int;
4625                         width = arg;
4626                         if (arg &lt; 0)
4627                           {
4628                             /* &quot;A negative field width is taken as a &#39;-&#39; flag
4629                                 followed by a positive field width.&quot;  */
4630                             flags |= FLAG_LEFT;
4631                             width = -width;
4632                           }
4633                       }
4634                     else
4635                       {
4636                         const FCHAR_T *digitp = dp-&gt;width_start;
4637 
4638                         do
4639                           width = xsum (xtimes (width, 10), *digitp++ - &#39;0&#39;);
4640                         while (digitp != dp-&gt;width_end);
4641                       }
4642 #if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION
4643                     has_width = 1;
4644 #endif
4645                   }
4646 #endif
4647 
4648 #if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION
4649                 has_precision = 0;
4650                 precision = 6;
4651                 if (dp-&gt;precision_start != dp-&gt;precision_end)
4652                   {
4653                     if (dp-&gt;precision_arg_index != ARG_NONE)
4654                       {
4655                         int arg;
4656 
4657                         if (!(a.arg[dp-&gt;precision_arg_index].type == TYPE_INT))
4658                           abort ();
4659                         arg = a.arg[dp-&gt;precision_arg_index].a.a_int;
4660                         /* &quot;A negative precision is taken as if the precision
4661                             were omitted.&quot;  */
4662                         if (arg &gt;= 0)
4663                           {
4664                             precision = arg;
4665                             has_precision = 1;
4666                           }
4667                       }
4668                     else
4669                       {
4670                         const FCHAR_T *digitp = dp-&gt;precision_start + 1;
4671 
4672                         precision = 0;
4673                         while (digitp != dp-&gt;precision_end)
4674                           precision = xsum (xtimes (precision, 10), *digitp++ - &#39;0&#39;);
4675                         has_precision = 1;
4676                       }
4677                   }
4678 #endif
4679 
4680                 /* Decide whether to handle the precision ourselves.  */
4681 #if NEED_PRINTF_UNBOUNDED_PRECISION
4682                 switch (dp-&gt;conversion)
4683                   {
4684                   case &#39;d&#39;: case &#39;i&#39;: case &#39;u&#39;:
4685                   case &#39;o&#39;:
4686                   case &#39;x&#39;: case &#39;X&#39;: case &#39;p&#39;:
4687                     prec_ourselves = has_precision &amp;&amp; (precision &gt; 0);
4688                     break;
4689                   default:
4690                     prec_ourselves = 0;
4691                     break;
4692                   }
4693 #endif
4694 
4695                 /* Decide whether to perform the padding ourselves.  */
4696 #if !NEED_PRINTF_FLAG_LEFTADJUST &amp;&amp; (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)
4697                 switch (dp-&gt;conversion)
4698                   {
4699 # if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO
4700                   /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need
4701                      to perform the padding after this conversion.  Functions
4702                      with unistdio extensions perform the padding based on
4703                      character count rather than element count.  */
4704                   case &#39;c&#39;: case &#39;s&#39;:
4705 # endif
4706 # if NEED_PRINTF_FLAG_ZERO
4707                   case &#39;f&#39;: case &#39;F&#39;: case &#39;e&#39;: case &#39;E&#39;: case &#39;g&#39;: case &#39;G&#39;:
4708                   case &#39;a&#39;: case &#39;A&#39;:
4709 # endif
4710                     pad_ourselves = 1;
4711                     break;
4712                   default:
4713                     pad_ourselves = prec_ourselves;
4714                     break;
4715                   }
4716 #endif
4717 
4718 #if !USE_SNPRINTF
4719                 /* Allocate a temporary buffer of sufficient size for calling
4720                    sprintf.  */
4721                 tmp_length =
4722                   MAX_ROOM_NEEDED (&amp;a, dp-&gt;arg_index, dp-&gt;conversion, type,
4723                                    flags, width, has_precision, precision,
4724                                    pad_ourselves);
4725 
4726                 if (tmp_length &lt;= sizeof (tmpbuf) / sizeof (TCHAR_T))
4727                   tmp = tmpbuf;
4728                 else
4729                   {
4730                     size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));
4731 
4732                     if (size_overflow_p (tmp_memsize))
4733                       /* Overflow, would lead to out of memory.  */
4734                       goto out_of_memory;
4735                     tmp = (TCHAR_T *) malloc (tmp_memsize);
4736                     if (tmp == NULL)
4737                       /* Out of memory.  */
4738                       goto out_of_memory;
4739                   }
4740 #endif
4741 
4742                 /* Construct the format string for calling snprintf or
4743                    sprintf.  */
4744                 fbp = buf;
4745                 *fbp++ = &#39;%&#39;;
4746 #if NEED_PRINTF_FLAG_GROUPING
4747                 /* The underlying implementation doesn&#39;t support the &#39; flag.
4748                    Produce no grouping characters in this case; this is
4749                    acceptable because the grouping is locale dependent.  */
4750 #else
4751                 if (flags &amp; FLAG_GROUP)
4752                   *fbp++ = &#39;\&#39;&#39;;
4753 #endif
4754                 if (flags &amp; FLAG_LEFT)
4755                   *fbp++ = &#39;-&#39;;
4756                 if (flags &amp; FLAG_SHOWSIGN)
4757                   *fbp++ = &#39;+&#39;;
4758                 if (flags &amp; FLAG_SPACE)
4759                   *fbp++ = &#39; &#39;;
4760                 if (flags &amp; FLAG_ALT)
4761                   *fbp++ = &#39;#&#39;;
4762 #if __GLIBC__ &gt;= 2 &amp;&amp; !defined __UCLIBC__
4763                 if (flags &amp; FLAG_LOCALIZED)
4764                   *fbp++ = &#39;I&#39;;
4765 #endif
4766                 if (!pad_ourselves)
4767                   {
4768                     if (flags &amp; FLAG_ZERO)
4769                       *fbp++ = &#39;0&#39;;
4770                     if (dp-&gt;width_start != dp-&gt;width_end)
4771                       {
4772                         size_t n = dp-&gt;width_end - dp-&gt;width_start;
4773                         /* The width specification is known to consist only
4774                            of standard ASCII characters.  */
4775                         if (sizeof (FCHAR_T) == sizeof (TCHAR_T))
4776                           {
4777                             memcpy (fbp, dp-&gt;width_start, n * sizeof (TCHAR_T));
4778                             fbp += n;
4779                           }
4780                         else
4781                           {
4782                             const FCHAR_T *mp = dp-&gt;width_start;
4783                             do
4784                               *fbp++ = *mp++;
4785                             while (--n &gt; 0);
4786                           }
4787                       }
4788                   }
4789                 if (!prec_ourselves)
4790                   {
4791                     if (dp-&gt;precision_start != dp-&gt;precision_end)
4792                       {
4793                         size_t n = dp-&gt;precision_end - dp-&gt;precision_start;
4794                         /* The precision specification is known to consist only
4795                            of standard ASCII characters.  */
4796                         if (sizeof (FCHAR_T) == sizeof (TCHAR_T))
4797                           {
4798                             memcpy (fbp, dp-&gt;precision_start, n * sizeof (TCHAR_T));
4799                             fbp += n;
4800                           }
4801                         else
4802                           {
4803                             const FCHAR_T *mp = dp-&gt;precision_start;
4804                             do
4805                               *fbp++ = *mp++;
4806                             while (--n &gt; 0);
4807                           }
4808                       }
4809                   }
4810 
4811                 switch (type)
4812                   {
4813 #if HAVE_LONG_LONG
4814                   case TYPE_LONGLONGINT:
4815                   case TYPE_ULONGLONGINT:
4816 # if (defined _WIN32 || defined __WIN32__) &amp;&amp; ! defined __CYGWIN__
4817                     *fbp++ = &#39;I&#39;;
4818                     *fbp++ = &#39;6&#39;;
4819                     *fbp++ = &#39;4&#39;;
4820                     break;
4821 # else
4822                     *fbp++ = &#39;l&#39;;
4823                     /*FALLTHROUGH*/
4824 # endif
4825 #endif
4826                   case TYPE_LONGINT:
4827                   case TYPE_ULONGINT:
4828 #if HAVE_WINT_T
4829                   case TYPE_WIDE_CHAR:
4830 #endif
4831 #if HAVE_WCHAR_T
4832                   case TYPE_WIDE_STRING:
4833 #endif
4834                     *fbp++ = &#39;l&#39;;
4835                     break;
4836                   case TYPE_LONGDOUBLE:
4837                     *fbp++ = &#39;L&#39;;
4838                     break;
4839                   default:
4840                     break;
4841                   }
4842 #if NEED_PRINTF_DIRECTIVE_F
4843                 if (dp-&gt;conversion == &#39;F&#39;)
4844                   *fbp = &#39;f&#39;;
4845                 else
4846 #endif
4847                   *fbp = dp-&gt;conversion;
4848 #if USE_SNPRINTF
4849 # if !(((__GLIBC__ &gt; 2 || (__GLIBC__ == 2 &amp;&amp; __GLIBC_MINOR__ &gt;= 3)) &amp;&amp; !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) &amp;&amp; ! defined __CYGWIN__))
4850                 fbp[1] = &#39;%&#39;;
4851                 fbp[2] = &#39;n&#39;;
4852                 fbp[3] = &#39;\0&#39;;
4853 # else
4854                 /* On glibc2 systems from glibc &gt;= 2.3 - probably also older
4855                    ones - we know that snprintf&#39;s return value conforms to
4856                    ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and
4857                    gl_SNPRINTF_TRUNCATION_C99 pass.
4858                    Therefore we can avoid using %n in this situation.
4859                    On glibc2 systems from 2004-10-18 or newer, the use of %n
4860                    in format strings in writable memory may crash the program
4861                    (if compiled with _FORTIFY_SOURCE=2), so we should avoid it
4862                    in this situation.  */
4863                 /* On native Windows systems (such as mingw), we can avoid using
4864                    %n because:
4865                      - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,
4866                        snprintf does not write more than the specified number
4867                        of bytes. (snprintf (buf, 3, &quot;%d %d&quot;, 4567, 89) writes
4868                        &#39;4&#39;, &#39;5&#39;, &#39;6&#39; into buf, not &#39;4&#39;, &#39;5&#39;, &#39;\0&#39;.)
4869                      - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf
4870                        allows us to recognize the case of an insufficient
4871                        buffer size: it returns -1 in this case.
4872                    On native Windows systems (such as mingw) where the OS is
4873                    Windows Vista, the use of %n in format strings by default
4874                    crashes the program. See
4875                      &lt;http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html&gt; and
4876                      &lt;http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx&gt;
4877                    So we should avoid %n in this situation.  */
4878                 fbp[1] = &#39;\0&#39;;
4879 # endif
4880 #else
4881                 fbp[1] = &#39;\0&#39;;
4882 #endif
4883 
4884                 /* Construct the arguments for calling snprintf or sprintf.  */
4885                 prefix_count = 0;
4886                 if (!pad_ourselves &amp;&amp; dp-&gt;width_arg_index != ARG_NONE)
4887                   {
4888                     if (!(a.arg[dp-&gt;width_arg_index].type == TYPE_INT))
4889                       abort ();
4890                     prefixes[prefix_count++] = a.arg[dp-&gt;width_arg_index].a.a_int;
4891                   }
4892                 if (!prec_ourselves &amp;&amp; dp-&gt;precision_arg_index != ARG_NONE)
4893                   {
4894                     if (!(a.arg[dp-&gt;precision_arg_index].type == TYPE_INT))
4895                       abort ();
4896                     prefixes[prefix_count++] = a.arg[dp-&gt;precision_arg_index].a.a_int;
4897                   }
4898 
4899 #if USE_SNPRINTF
4900                 /* The SNPRINTF result is appended after result[0..length].
4901                    The latter is an array of DCHAR_T; SNPRINTF appends an
4902                    array of TCHAR_T to it.  This is possible because
4903                    sizeof (TCHAR_T) divides sizeof (DCHAR_T) and
4904                    alignof (TCHAR_T) &lt;= alignof (DCHAR_T).  */
4905 # define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))
4906                 /* Ensure that maxlen below will be &gt;= 2.  Needed on BeOS,
4907                    where an snprintf() with maxlen==1 acts like sprintf().  */
4908                 ENSURE_ALLOCATION (xsum (length,
4909                                          (2 + TCHARS_PER_DCHAR - 1)
4910                                          / TCHARS_PER_DCHAR));
4911                 /* Prepare checking whether snprintf returns the count
4912                    via %n.  */
4913                 *(TCHAR_T *) (result + length) = &#39;\0&#39;;
4914 #endif
4915 
4916                 orig_errno = errno;
4917 
4918                 for (;;)
4919                   {
4920                     int count = -1;
4921 
4922 #if USE_SNPRINTF
4923                     int retcount = 0;
4924                     size_t maxlen = allocated - length;
4925                     /* SNPRINTF can fail if its second argument is
4926                        &gt; INT_MAX.  */
4927                     if (maxlen &gt; INT_MAX / TCHARS_PER_DCHAR)
4928                       maxlen = INT_MAX / TCHARS_PER_DCHAR;
4929                     maxlen = maxlen * TCHARS_PER_DCHAR;
4930 # define SNPRINTF_BUF(arg) \
4931                     switch (prefix_count)                                   \
4932                       {                                                     \
4933                       case 0:                                               \
4934                         retcount = SNPRINTF ((TCHAR_T *) (result + length), \
4935                                              maxlen, buf,                   \
4936                                              arg, &amp;count);                  \
4937                         break;                                              \
4938                       case 1:                                               \
4939                         retcount = SNPRINTF ((TCHAR_T *) (result + length), \
4940                                              maxlen, buf,                   \
4941                                              prefixes[0], arg, &amp;count);     \
4942                         break;                                              \
4943                       case 2:                                               \
4944                         retcount = SNPRINTF ((TCHAR_T *) (result + length), \
4945                                              maxlen, buf,                   \
4946                                              prefixes[0], prefixes[1], arg, \
4947                                              &amp;count);                       \
4948                         break;                                              \
4949                       default:                                              \
4950                         abort ();                                           \
4951                       }
4952 #else
4953 # define SNPRINTF_BUF(arg) \
4954                     switch (prefix_count)                                   \
4955                       {                                                     \
4956                       case 0:                                               \
4957                         count = sprintf (tmp, buf, arg);                    \
4958                         break;                                              \
4959                       case 1:                                               \
4960                         count = sprintf (tmp, buf, prefixes[0], arg);       \
4961                         break;                                              \
4962                       case 2:                                               \
4963                         count = sprintf (tmp, buf, prefixes[0], prefixes[1],\
4964                                          arg);                              \
4965                         break;                                              \
4966                       default:                                              \
4967                         abort ();                                           \
4968                       }
4969 #endif
4970 
4971                     errno = 0;
4972                     switch (type)
4973                       {
4974                       case TYPE_SCHAR:
4975                         {
4976                           int arg = a.arg[dp-&gt;arg_index].a.a_schar;
4977                           SNPRINTF_BUF (arg);
4978                         }
4979                         break;
4980                       case TYPE_UCHAR:
4981                         {
4982                           unsigned int arg = a.arg[dp-&gt;arg_index].a.a_uchar;
4983                           SNPRINTF_BUF (arg);
4984                         }
4985                         break;
4986                       case TYPE_SHORT:
4987                         {
4988                           int arg = a.arg[dp-&gt;arg_index].a.a_short;
4989                           SNPRINTF_BUF (arg);
4990                         }
4991                         break;
4992                       case TYPE_USHORT:
4993                         {
4994                           unsigned int arg = a.arg[dp-&gt;arg_index].a.a_ushort;
4995                           SNPRINTF_BUF (arg);
4996                         }
4997                         break;
4998                       case TYPE_INT:
4999                         {
5000                           int arg = a.arg[dp-&gt;arg_index].a.a_int;
5001                           SNPRINTF_BUF (arg);
5002                         }
5003                         break;
5004                       case TYPE_UINT:
5005                         {
5006                           unsigned int arg = a.arg[dp-&gt;arg_index].a.a_uint;
5007                           SNPRINTF_BUF (arg);
5008                         }
5009                         break;
5010                       case TYPE_LONGINT:
5011                         {
5012                           long int arg = a.arg[dp-&gt;arg_index].a.a_longint;
5013                           SNPRINTF_BUF (arg);
5014                         }
5015                         break;
5016                       case TYPE_ULONGINT:
5017                         {
5018                           unsigned long int arg = a.arg[dp-&gt;arg_index].a.a_ulongint;
5019                           SNPRINTF_BUF (arg);
5020                         }
5021                         break;
5022 #if HAVE_LONG_LONG
5023                       case TYPE_LONGLONGINT:
5024                         {
5025                           long long int arg = a.arg[dp-&gt;arg_index].a.a_longlongint;
5026                           SNPRINTF_BUF (arg);
5027                         }
5028                         break;
5029                       case TYPE_ULONGLONGINT:
5030                         {
5031                           unsigned long long int arg = a.arg[dp-&gt;arg_index].a.a_ulonglongint;
5032                           SNPRINTF_BUF (arg);
5033                         }
5034                         break;
5035 #endif
5036                       case TYPE_DOUBLE:
5037                         {
5038                           double arg = a.arg[dp-&gt;arg_index].a.a_double;
5039                           SNPRINTF_BUF (arg);
5040                         }
5041                         break;
5042                       case TYPE_LONGDOUBLE:
5043                         {
5044                           long double arg = a.arg[dp-&gt;arg_index].a.a_longdouble;
5045                           SNPRINTF_BUF (arg);
5046                         }
5047                         break;
5048                       case TYPE_CHAR:
5049                         {
5050                           int arg = a.arg[dp-&gt;arg_index].a.a_char;
5051                           SNPRINTF_BUF (arg);
5052                         }
5053                         break;
5054 #if HAVE_WINT_T
5055                       case TYPE_WIDE_CHAR:
5056                         {
5057                           wint_t arg = a.arg[dp-&gt;arg_index].a.a_wide_char;
5058                           SNPRINTF_BUF (arg);
5059                         }
5060                         break;
5061 #endif
5062                       case TYPE_STRING:
5063                         {
5064                           const char *arg = a.arg[dp-&gt;arg_index].a.a_string;
5065                           SNPRINTF_BUF (arg);
5066                         }
5067                         break;
5068 #if HAVE_WCHAR_T
5069                       case TYPE_WIDE_STRING:
5070                         {
5071                           const wchar_t *arg = a.arg[dp-&gt;arg_index].a.a_wide_string;
5072                           SNPRINTF_BUF (arg);
5073                         }
5074                         break;
5075 #endif
5076                       case TYPE_POINTER:
5077                         {
5078                           void *arg = a.arg[dp-&gt;arg_index].a.a_pointer;
5079                           SNPRINTF_BUF (arg);
5080                         }
5081                         break;
5082                       default:
5083                         abort ();
5084                       }
5085 
5086 #if USE_SNPRINTF
5087                     /* Portability: Not all implementations of snprintf()
5088                        are ISO C 99 compliant.  Determine the number of
5089                        bytes that snprintf() has produced or would have
5090                        produced.  */
5091                     if (count &gt;= 0)
5092                       {
5093                         /* Verify that snprintf() has NUL-terminated its
5094                            result.  */
5095                         if (count &lt; maxlen
5096                             &amp;&amp; ((TCHAR_T *) (result + length)) [count] != &#39;\0&#39;)
5097                           abort ();
5098                         /* Portability hack.  */
5099                         if (retcount &gt; count)
5100                           count = retcount;
5101                       }
5102                     else
5103                       {
5104                         /* snprintf() doesn&#39;t understand the &#39;%n&#39;
5105                            directive.  */
5106                         if (fbp[1] != &#39;\0&#39;)
5107                           {
5108                             /* Don&#39;t use the &#39;%n&#39; directive; instead, look
5109                                at the snprintf() return value.  */
5110                             fbp[1] = &#39;\0&#39;;
5111                             continue;
5112                           }
5113                         else
5114                           {
5115                             /* Look at the snprintf() return value.  */
5116                             if (retcount &lt; 0)
5117                               {
5118 # if !HAVE_SNPRINTF_RETVAL_C99
5119                                 /* HP-UX 10.20 snprintf() is doubly deficient:
5120                                    It doesn&#39;t understand the &#39;%n&#39; directive,
5121                                    *and* it returns -1 (rather than the length
5122                                    that would have been required) when the
5123                                    buffer is too small.
5124                                    But a failure at this point can also come
5125                                    from other reasons than a too small buffer,
5126                                    such as an invalid wide string argument to
5127                                    the %ls directive, or possibly an invalid
5128                                    floating-point argument.  */
5129                                 size_t tmp_length =
5130                                   MAX_ROOM_NEEDED (&amp;a, dp-&gt;arg_index,
5131                                                    dp-&gt;conversion, type, flags,
5132                                                    width,
5133                                                    has_precision,
5134                                                    precision, pad_ourselves);
5135 
5136                                 if (maxlen &lt; tmp_length)
5137                                   {
5138                                     /* Make more room.  But try to do through
5139                                        this reallocation only once.  */
5140                                     size_t bigger_need =
5141                                       xsum (length,
5142                                             xsum (tmp_length,
5143                                                   TCHARS_PER_DCHAR - 1)
5144                                             / TCHARS_PER_DCHAR);
5145                                     /* And always grow proportionally.
5146                                        (There may be several arguments, each
5147                                        needing a little more room than the
5148                                        previous one.)  */
5149                                     size_t bigger_need2 =
5150                                       xsum (xtimes (allocated, 2), 12);
5151                                     if (bigger_need &lt; bigger_need2)
5152                                       bigger_need = bigger_need2;
5153                                     ENSURE_ALLOCATION (bigger_need);
5154                                     continue;
5155                                   }
5156 # endif
5157                               }
5158                             else
5159                               count = retcount;
5160                           }
5161                       }
5162 #endif
5163 
5164                     /* Attempt to handle failure.  */
5165                     if (count &lt; 0)
5166                       {
5167                         /* SNPRINTF or sprintf failed.  Save and use the errno
5168                            that it has set, if any.  */
5169                         int saved_errno = errno;
5170                         if (saved_errno == 0)
5171                           {
5172                             if (dp-&gt;conversion == &#39;c&#39; || dp-&gt;conversion == &#39;s&#39;)
5173                               saved_errno = EILSEQ;
5174                             else
5175                               saved_errno = EINVAL;
5176                           }
5177 
5178                         if (!(result == resultbuf || result == NULL))
5179                           free (result);
5180                         if (buf_malloced != NULL)
5181                           free (buf_malloced);
5182                         CLEANUP ();
5183 
5184                         errno = saved_errno;
5185                         return NULL;
5186                       }
5187 
5188 #if USE_SNPRINTF
5189                     /* Handle overflow of the allocated buffer.
5190                        If such an overflow occurs, a C99 compliant snprintf()
5191                        returns a count &gt;= maxlen.  However, a non-compliant
5192                        snprintf() function returns only count = maxlen - 1.  To
5193                        cover both cases, test whether count &gt;= maxlen - 1.  */
5194                     if ((unsigned int) count + 1 &gt;= maxlen)
5195                       {
5196                         /* If maxlen already has attained its allowed maximum,
5197                            allocating more memory will not increase maxlen.
5198                            Instead of looping, bail out.  */
5199                         if (maxlen == INT_MAX / TCHARS_PER_DCHAR)
5200                           goto overflow;
5201                         else
5202                           {
5203                             /* Need at least (count + 1) * sizeof (TCHAR_T)
5204                                bytes.  (The +1 is for the trailing NUL.)
5205                                But ask for (count + 2) * sizeof (TCHAR_T)
5206                                bytes, so that in the next round, we likely get
5207                                  maxlen &gt; (unsigned int) count + 1
5208                                and so we don&#39;t get here again.
5209                                And allocate proportionally, to avoid looping
5210                                eternally if snprintf() reports a too small
5211                                count.  */
5212                             size_t n =
5213                               xmax (xsum (length,
5214                                           ((unsigned int) count + 2
5215                                            + TCHARS_PER_DCHAR - 1)
5216                                           / TCHARS_PER_DCHAR),
5217                                     xtimes (allocated, 2));
5218 
5219                             ENSURE_ALLOCATION (n);
5220                             continue;
5221                           }
5222                       }
5223 #endif
5224 
5225 #if NEED_PRINTF_UNBOUNDED_PRECISION
5226                     if (prec_ourselves)
5227                       {
5228                         /* Handle the precision.  */
5229                         TCHAR_T *prec_ptr =
5230 # if USE_SNPRINTF
5231                           (TCHAR_T *) (result + length);
5232 # else
5233                           tmp;
5234 # endif
5235                         size_t prefix_count;
5236                         size_t move;
5237 
5238                         prefix_count = 0;
5239                         /* Put the additional zeroes after the sign.  */
5240                         if (count &gt;= 1
5241                             &amp;&amp; (*prec_ptr == &#39;-&#39; || *prec_ptr == &#39;+&#39;
5242                                 || *prec_ptr == &#39; &#39;))
5243                           prefix_count = 1;
5244                         /* Put the additional zeroes after the 0x prefix if
5245                            (flags &amp; FLAG_ALT) || (dp-&gt;conversion == &#39;p&#39;).  */
5246                         else if (count &gt;= 2
5247                                  &amp;&amp; prec_ptr[0] == &#39;0&#39;
5248                                  &amp;&amp; (prec_ptr[1] == &#39;x&#39; || prec_ptr[1] == &#39;X&#39;))
5249                           prefix_count = 2;
5250 
5251                         move = count - prefix_count;
5252                         if (precision &gt; move)
5253                           {
5254                             /* Insert zeroes.  */
5255                             size_t insert = precision - move;
5256                             TCHAR_T *prec_end;
5257 
5258 # if USE_SNPRINTF
5259                             size_t n =
5260                               xsum (length,
5261                                     (count + insert + TCHARS_PER_DCHAR - 1)
5262                                     / TCHARS_PER_DCHAR);
5263                             length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;
5264                             ENSURE_ALLOCATION (n);
5265                             length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;
5266                             prec_ptr = (TCHAR_T *) (result + length);
5267 # endif
5268 
5269                             prec_end = prec_ptr + count;
5270                             prec_ptr += prefix_count;
5271 
5272                             while (prec_end &gt; prec_ptr)
5273                               {
5274                                 prec_end--;
5275                                 prec_end[insert] = prec_end[0];
5276                               }
5277 
5278                             prec_end += insert;
5279                             do
5280                               *--prec_end = &#39;0&#39;;
5281                             while (prec_end &gt; prec_ptr);
5282 
5283                             count += insert;
5284                           }
5285                       }
5286 #endif
5287 
5288 #if !USE_SNPRINTF
5289                     if (count &gt;= tmp_length)
5290                       /* tmp_length was incorrectly calculated - fix the
5291                          code above!  */
5292                       abort ();
5293 #endif
5294 
5295 #if !DCHAR_IS_TCHAR
5296                     /* Convert from TCHAR_T[] to DCHAR_T[].  */
5297                     if (dp-&gt;conversion == &#39;c&#39; || dp-&gt;conversion == &#39;s&#39;)
5298                       {
5299                         /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING
5300                            TYPE_WIDE_STRING.
5301                            The result string is not certainly ASCII.  */
5302                         const TCHAR_T *tmpsrc;
5303                         DCHAR_T *tmpdst;
5304                         size_t tmpdst_len;
5305                         /* This code assumes that TCHAR_T is &#39;char&#39;.  */
5306                         verify (sizeof (TCHAR_T) == 1);
5307 # if USE_SNPRINTF
5308                         tmpsrc = (TCHAR_T *) (result + length);
5309 # else
5310                         tmpsrc = tmp;
5311 # endif
5312                         tmpdst =
5313                           DCHAR_CONV_FROM_ENCODING (locale_charset (),
5314                                                     iconveh_question_mark,
5315                                                     tmpsrc, count,
5316                                                     NULL,
5317                                                     NULL, &amp;tmpdst_len);
5318                         if (tmpdst == NULL)
5319                           {
5320                             int saved_errno = errno;
5321                             if (!(result == resultbuf || result == NULL))
5322                               free (result);
5323                             if (buf_malloced != NULL)
5324                               free (buf_malloced);
5325                             CLEANUP ();
5326                             errno = saved_errno;
5327                             return NULL;
5328                           }
5329                         ENSURE_ALLOCATION (xsum (length, tmpdst_len));
5330                         DCHAR_CPY (result + length, tmpdst, tmpdst_len);
5331                         free (tmpdst);
5332                         count = tmpdst_len;
5333                       }
5334                     else
5335                       {
5336                         /* The result string is ASCII.
5337                            Simple 1:1 conversion.  */
5338 # if USE_SNPRINTF
5339                         /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it&#39;s a
5340                            no-op conversion, in-place on the array starting
5341                            at (result + length).  */
5342                         if (sizeof (DCHAR_T) != sizeof (TCHAR_T))
5343 # endif
5344                           {
5345                             const TCHAR_T *tmpsrc;
5346                             DCHAR_T *tmpdst;
5347                             size_t n;
5348 
5349 # if USE_SNPRINTF
5350                             if (result == resultbuf)
5351                               {
5352                                 tmpsrc = (TCHAR_T *) (result + length);
5353                                 /* ENSURE_ALLOCATION will not move tmpsrc
5354                                    (because it&#39;s part of resultbuf).  */
5355                                 ENSURE_ALLOCATION (xsum (length, count));
5356                               }
5357                             else
5358                               {
5359                                 /* ENSURE_ALLOCATION will move the array
5360                                    (because it uses realloc().  */
5361                                 ENSURE_ALLOCATION (xsum (length, count));
5362                                 tmpsrc = (TCHAR_T *) (result + length);
5363                               }
5364 # else
5365                             tmpsrc = tmp;
5366                             ENSURE_ALLOCATION (xsum (length, count));
5367 # endif
5368                             tmpdst = result + length;
5369                             /* Copy backwards, because of overlapping.  */
5370                             tmpsrc += count;
5371                             tmpdst += count;
5372                             for (n = count; n &gt; 0; n--)
5373                               *--tmpdst = *--tmpsrc;
5374                           }
5375                       }
5376 #endif
5377 
5378 #if DCHAR_IS_TCHAR &amp;&amp; !USE_SNPRINTF
5379                     /* Make room for the result.  */
5380                     if (count &gt; allocated - length)
5381                       {
5382                         /* Need at least count elements.  But allocate
5383                            proportionally.  */
5384                         size_t n =
5385                           xmax (xsum (length, count), xtimes (allocated, 2));
5386 
5387                         ENSURE_ALLOCATION (n);
5388                       }
5389 #endif
5390 
5391                     /* Here count &lt;= allocated - length.  */
5392 
5393                     /* Perform padding.  */
5394 #if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION
5395                     if (pad_ourselves &amp;&amp; has_width)
5396                       {
5397                         size_t w;
5398 # if ENABLE_UNISTDIO
5399                         /* Outside POSIX, it&#39;s preferable to compare the width
5400                            against the number of _characters_ of the converted
5401                            value.  */
5402                         w = DCHAR_MBSNLEN (result + length, count);
5403 # else
5404                         /* The width is compared against the number of _bytes_
5405                            of the converted value, says POSIX.  */
5406                         w = count;
5407 # endif
5408                         if (w &lt; width)
5409                           {
5410                             size_t pad = width - w;
5411 
5412                             /* Make room for the result.  */
5413                             if (xsum (count, pad) &gt; allocated - length)
5414                               {
5415                                 /* Need at least count + pad elements.  But
5416                                    allocate proportionally.  */
5417                                 size_t n =
5418                                   xmax (xsum3 (length, count, pad),
5419                                         xtimes (allocated, 2));
5420 
5421 # if USE_SNPRINTF
5422                                 length += count;
5423                                 ENSURE_ALLOCATION (n);
5424                                 length -= count;
5425 # else
5426                                 ENSURE_ALLOCATION (n);
5427 # endif
5428                               }
5429                             /* Here count + pad &lt;= allocated - length.  */
5430 
5431                             {
5432 # if !DCHAR_IS_TCHAR || USE_SNPRINTF
5433                               DCHAR_T * const rp = result + length;
5434 # else
5435                               DCHAR_T * const rp = tmp;
5436 # endif
5437                               DCHAR_T *p = rp + count;
5438                               DCHAR_T *end = p + pad;
5439                               DCHAR_T *pad_ptr;
5440 # if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO
5441                               if (dp-&gt;conversion == &#39;c&#39;
5442                                   || dp-&gt;conversion == &#39;s&#39;)
5443                                 /* No zero-padding for string directives.  */
5444                                 pad_ptr = NULL;
5445                               else
5446 # endif
5447                                 {
5448                                   pad_ptr = (*rp == &#39;-&#39; ? rp + 1 : rp);
5449                                   /* No zero-padding of &quot;inf&quot; and &quot;nan&quot;.  */
5450                                   if ((*pad_ptr &gt;= &#39;A&#39; &amp;&amp; *pad_ptr &lt;= &#39;Z&#39;)
5451                                       || (*pad_ptr &gt;= &#39;a&#39; &amp;&amp; *pad_ptr &lt;= &#39;z&#39;))
5452                                     pad_ptr = NULL;
5453                                 }
5454                               /* The generated string now extends from rp to p,
5455                                  with the zero padding insertion point being at
5456                                  pad_ptr.  */
5457 
5458                               count = count + pad; /* = end - rp */
5459 
5460                               if (flags &amp; FLAG_LEFT)
5461                                 {
5462                                   /* Pad with spaces on the right.  */
5463                                   for (; pad &gt; 0; pad--)
5464                                     *p++ = &#39; &#39;;
5465                                 }
5466                               else if ((flags &amp; FLAG_ZERO) &amp;&amp; pad_ptr != NULL)
5467                                 {
5468                                   /* Pad with zeroes.  */
5469                                   DCHAR_T *q = end;
5470 
5471                                   while (p &gt; pad_ptr)
5472                                     *--q = *--p;
5473                                   for (; pad &gt; 0; pad--)
5474                                     *p++ = &#39;0&#39;;
5475                                 }
5476                               else
5477                                 {
5478                                   /* Pad with spaces on the left.  */
5479                                   DCHAR_T *q = end;
5480 
5481                                   while (p &gt; rp)
5482                                     *--q = *--p;
5483                                   for (; pad &gt; 0; pad--)
5484                                     *p++ = &#39; &#39;;
5485                                 }
5486                             }
5487                           }
5488                       }
5489 #endif
5490 
5491                     /* Here still count &lt;= allocated - length.  */
5492 
5493 #if !DCHAR_IS_TCHAR || USE_SNPRINTF
5494                     /* The snprintf() result did fit.  */
5495 #else
5496                     /* Append the sprintf() result.  */
5497                     memcpy (result + length, tmp, count * sizeof (DCHAR_T));
5498 #endif
5499 #if !USE_SNPRINTF
5500                     if (tmp != tmpbuf)
5501                       free (tmp);
5502 #endif
5503 
5504 #if NEED_PRINTF_DIRECTIVE_F
5505                     if (dp-&gt;conversion == &#39;F&#39;)
5506                       {
5507                         /* Convert the %f result to upper case for %F.  */
5508                         DCHAR_T *rp = result + length;
5509                         size_t rc;
5510                         for (rc = count; rc &gt; 0; rc--, rp++)
5511                           if (*rp &gt;= &#39;a&#39; &amp;&amp; *rp &lt;= &#39;z&#39;)
5512                             *rp = *rp - &#39;a&#39; + &#39;A&#39;;
5513                       }
5514 #endif
5515 
5516                     length += count;
5517                     break;
5518                   }
5519                 errno = orig_errno;
5520 #undef pad_ourselves
5521 #undef prec_ourselves
5522               }
5523           }
5524       }
5525 
5526     /* Add the final NUL.  */
5527     ENSURE_ALLOCATION (xsum (length, 1));
5528     result[length] = &#39;\0&#39;;
5529 
5530     if (result != resultbuf &amp;&amp; length + 1 &lt; allocated)
5531       {
5532         /* Shrink the allocated memory if possible.  */
5533         DCHAR_T *memory;
5534 
5535         memory = (DCHAR_T *) realloc (result, (length + 1) * sizeof (DCHAR_T));
5536         if (memory != NULL)
5537           result = memory;
5538       }
5539 
5540     if (buf_malloced != NULL)
5541       free (buf_malloced);
5542     CLEANUP ();
5543     *lengthp = length;
5544     /* Note that we can produce a big string of a length &gt; INT_MAX.  POSIX
5545        says that snprintf() fails with errno = EOVERFLOW in this case, but
5546        that&#39;s only because snprintf() returns an &#39;int&#39;.  This function does
5547        not have this limitation.  */
5548     return result;
5549 
5550 #if USE_SNPRINTF
5551   overflow:
5552     if (!(result == resultbuf || result == NULL))
5553       free (result);
5554     if (buf_malloced != NULL)
5555       free (buf_malloced);
5556     CLEANUP ();
5557     errno = EOVERFLOW;
5558     return NULL;
5559 #endif
5560 
5561   out_of_memory:
5562     if (!(result == resultbuf || result == NULL))
5563       free (result);
5564     if (buf_malloced != NULL)
5565       free (buf_malloced);
5566   out_of_memory_1:
5567     CLEANUP ();
5568     errno = ENOMEM;
5569     return NULL;
5570   }
5571 }
5572 
5573 #undef MAX_ROOM_NEEDED
5574 #undef TCHARS_PER_DCHAR
5575 #undef SNPRINTF
5576 #undef USE_SNPRINTF
5577 #undef DCHAR_SET
5578 #undef DCHAR_CPY
5579 #undef PRINTF_PARSE
5580 #undef DIRECTIVES
5581 #undef DIRECTIVE
5582 #undef DCHAR_IS_TCHAR
5583 #undef TCHAR_T
5584 #undef DCHAR_T
5585 #undef FCHAR_T
5586 #undef VASNPRINTF
    </pre>
  </body>
</html>