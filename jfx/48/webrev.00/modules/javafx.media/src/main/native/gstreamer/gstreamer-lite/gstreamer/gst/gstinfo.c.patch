diff a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstinfo.c b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstinfo.c
--- a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstinfo.c
+++ b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstinfo.c
@@ -153,12 +153,29 @@
 #ifdef HAVE_BACKTRACE
 #include <execinfo.h>
 #define BT_BUF_SIZE 100
 #endif /* HAVE_BACKTRACE */
 
+#ifdef HAVE_DBGHELP
+#include <Windows.h>
+#include <dbghelp.h>
+#include <tlhelp32.h>
+#endif /* HAVE_DBGHELP */
+
 extern gboolean gst_is_initialized (void);
 
+#ifdef GSTREAMER_LITE
+// For some reason it is not defined if GST_DISABLE_GST_DEBUG and
+// GST_REMOVE_DISABLED is defined which we do for GSTREAMER_LITE
+#ifdef GST_REMOVE_DISABLED
+void
+_priv_gst_debug_cleanup (void)
+{
+}
+#endif // GST_REMOVE_DISABLED
+#endif // GSTREAMER_LITE
+
 /* we want these symbols exported even if debug is disabled, to maintain
  * ABI compatibility. Unless GST_REMOVE_DISABLED is defined. */
 #if !defined(GST_DISABLE_GST_DEBUG) || !defined(GST_REMOVE_DISABLED)
 
 /* disabled by default, as soon as some threshold is set > NONE,
@@ -351,27 +368,27 @@
 {
   const gchar *env;
   FILE *log_file;
 
   if (add_default_log_func) {
-  env = g_getenv ("GST_DEBUG_FILE");
-  if (env != NULL && *env != '\0') {
-    if (strcmp (env, "-") == 0) {
-      log_file = stdout;
-    } else {
+    env = g_getenv ("GST_DEBUG_FILE");
+    if (env != NULL && *env != '\0') {
+      if (strcmp (env, "-") == 0) {
+        log_file = stdout;
+      } else {
         gchar *name = _priv_gst_debug_file_name (env);
         log_file = g_fopen (name, "w");
         g_free (name);
-      if (log_file == NULL) {
-        g_printerr ("Could not open log file '%s' for writing: %s\n", env,
-            g_strerror (errno));
-        log_file = stderr;
+        if (log_file == NULL) {
+          g_printerr ("Could not open log file '%s' for writing: %s\n", env,
+              g_strerror (errno));
+          log_file = stderr;
+        }
       }
+    } else {
+      log_file = stderr;
     }
-  } else {
-    log_file = stderr;
-  }
 
     gst_debug_add_log_function (gst_debug_log_default, log_file, NULL);
   }
 
   __gst_printf_pointer_extension_set_func
@@ -404,11 +421,11 @@
   GST_CAT_CLOCK = _gst_debug_category_new ("GST_CLOCK",
       GST_DEBUG_BOLD | GST_DEBUG_FG_YELLOW, NULL);
   GST_CAT_ELEMENT_PADS = _gst_debug_category_new ("GST_ELEMENT_PADS",
       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
   GST_CAT_PADS = _gst_debug_category_new ("GST_PADS",
-      GST_DEBUG_BOLD | GST_DEBUG_FG_RED | GST_DEBUG_BG_RED, NULL);
+      GST_DEBUG_BOLD | GST_DEBUG_FG_RED | GST_DEBUG_BG_BLUE, NULL);
   GST_CAT_PERFORMANCE = _gst_debug_category_new ("GST_PERFORMANCE",
       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
   GST_CAT_PIPELINE = _gst_debug_category_new ("GST_PIPELINE",
       GST_DEBUG_BOLD | GST_DEBUG_FG_WHITE | GST_DEBUG_BG_RED, NULL);
   GST_CAT_PLUGIN_LOADING = _gst_debug_category_new ("GST_PLUGIN_LOADING",
@@ -463,11 +480,11 @@
     gst_debug_set_color_mode_from_string (env);
 
   env = g_getenv ("GST_DEBUG");
   if (env)
     gst_debug_set_threshold_from_string (env, FALSE);
-  }
+}
 
 /* we can't do this further above, because we initialize the GST_CAT_DEFAULT struct */
 #define GST_CAT_DEFAULT _GST_CAT_DEBUG
 
 /**
@@ -1246,11 +1263,11 @@
     fflush (log_file);
 #undef PRINT_FMT
   }
 
   if (object != NULL)
-  g_free (obj);
+    g_free (obj);
 }
 
 /**
  * gst_debug_level_get_name:
  * @level: the level to get the name for
@@ -1585,34 +1602,41 @@
 gst_debug_get_default_threshold (void)
 {
   return (GstDebugLevel) g_atomic_int_get (&__default_level);
 }
 
+static gboolean
+gst_debug_apply_entry (GstDebugCategory * cat, LevelNameEntry * entry)
+{
+  if (!g_pattern_match_string (entry->pat, cat->name))
+    return FALSE;
+
+  if (gst_is_initialized ())
+    GST_LOG ("category %s matches pattern %p - gets set to level %d",
+        cat->name, entry->pat, entry->level);
+
+  gst_debug_category_set_threshold (cat, entry->level);
+  return TRUE;
+}
+
 static void
 gst_debug_reset_threshold (gpointer category, gpointer unused)
 {
   GstDebugCategory *cat = (GstDebugCategory *) category;
   GSList *walk;
 
   g_mutex_lock (&__level_name_mutex);
-  walk = __level_name;
-  while (walk) {
-    LevelNameEntry *entry = walk->data;
 
-    walk = g_slist_next (walk);
-    if (g_pattern_match_string (entry->pat, cat->name)) {
-      if (gst_is_initialized ())
-        GST_LOG ("category %s matches pattern %p - gets set to level %d",
-            cat->name, entry->pat, entry->level);
-      gst_debug_category_set_threshold (cat, entry->level);
-      goto exit;
-    }
+  for (walk = __level_name; walk != NULL; walk = walk->next) {
+    if (gst_debug_apply_entry (cat, walk->data))
+      break;
   }
-  gst_debug_category_set_threshold (cat, gst_debug_get_default_threshold ());
 
-exit:
   g_mutex_unlock (&__level_name_mutex);
+
+  if (walk == NULL)
+    gst_debug_category_set_threshold (cat, gst_debug_get_default_threshold ());
 }
 
 static void
 gst_debug_reset_all_thresholds (void)
 {
@@ -1625,16 +1649,11 @@
 for_each_threshold_by_entry (gpointer data, gpointer user_data)
 {
   GstDebugCategory *cat = (GstDebugCategory *) data;
   LevelNameEntry *entry = (LevelNameEntry *) user_data;
 
-  if (g_pattern_match_string (entry->pat, cat->name)) {
-    if (gst_is_initialized ())
-      GST_TRACE ("category %s matches pattern %p - gets set to level %d",
-          cat->name, entry->pat, entry->level);
-    gst_debug_category_set_threshold (cat, entry->level);
-  }
+  gst_debug_apply_entry (cat, entry);
 }
 
 /**
  * gst_debug_set_threshold_for_name:
  * @name: name of the categories to set
@@ -2003,11 +2022,11 @@
 
           /* bump min-level anyway to allow the category to be registered in the
            * future still */
           if (level > _gst_debug_min) {
             _gst_debug_min = level;
-      }
+          }
         }
       }
 
       g_strfreev (values);
     } else {
@@ -2050,21 +2069,24 @@
   }
   /* we need to create an entry in the hash table for this one so we don't leak
    * the name */
 #ifdef HAVE_DLADDR
   if (dladdr ((gpointer) func, &dl_info) && dl_info.dli_sname) {
-    gchar *name = g_strdup (dl_info.dli_sname);
+    const gchar *name = g_intern_string (dl_info.dli_sname);
 
     _gst_debug_register_funcptr (func, name);
     return name;
   } else
 #endif
   {
     gchar *name = g_strdup_printf ("%p", (gpointer) func);
+    const gchar *iname = g_intern_string (name);
 
-    _gst_debug_register_funcptr (func, name);
-    return name;
+    g_free (name);
+
+    _gst_debug_register_funcptr (func, iname);
+    return iname;
   }
 }
 
 void
 _gst_debug_register_funcptr (GstDebugFuncPtr func, const gchar * ptrname)
@@ -2073,12 +2095,26 @@
 
   g_mutex_lock (&__dbg_functions_mutex);
 
   if (!__gst_function_pointers)
     __gst_function_pointers = g_hash_table_new (g_direct_hash, g_direct_equal);
-  if (!g_hash_table_lookup (__gst_function_pointers, ptr))
+  if (!g_hash_table_lookup (__gst_function_pointers, ptr)) {
     g_hash_table_insert (__gst_function_pointers, ptr, (gpointer) ptrname);
+  }
+
+  g_mutex_unlock (&__dbg_functions_mutex);
+}
+
+void
+_priv_gst_debug_cleanup (void)
+{
+  g_mutex_lock (&__dbg_functions_mutex);
+
+  if (__gst_function_pointers) {
+    g_hash_table_unref (__gst_function_pointers);
+    __gst_function_pointers = NULL;
+  }
 
   g_mutex_unlock (&__dbg_functions_mutex);
 }
 
 static void
@@ -2157,10 +2193,15 @@
 _gst_debug_nameof_funcptr (GstDebugFuncPtr func)
 {
   return "(NULL)";
 }
 
+void
+_priv_gst_debug_cleanup (void)
+{
+}
+
 void
 gst_debug_log (GstDebugCategory * category, GstDebugLevel level,
     const gchar * file, const gchar * function, gint line,
     GObject * object, const gchar * format, ...)
 {
@@ -2614,11 +2655,11 @@
   str = gst_info_strdup_vprintf (format, args);
   va_end (args);
 
   g_printerr ("%s\n", str);
   g_free (str);
-  }
+}
 
 #ifdef HAVE_UNWIND
 #ifdef HAVE_DW
 static gboolean
 append_debug_info (GString * trace, Dwfl * dwfl, const void *ip)
@@ -2652,11 +2693,11 @@
   } else {
     const gchar *eflfile = NULL;
 
     dwfl_module_info (module, NULL, NULL, NULL, NULL, NULL, &eflfile, NULL);
     g_string_append_printf (trace, "%s:%p", eflfile ? eflfile : "??", ip);
-}
+  }
 
   return TRUE;
 }
 #endif /* HAVE_DW */
 
@@ -2759,10 +2800,102 @@
 }
 #else
 #define generate_backtrace_trace() NULL
 #endif /* HAVE_BACKTRACE */
 
+#ifdef HAVE_DBGHELP
+static void
+dbghelp_initialize_symbols (HANDLE process)
+{
+  static gsize initialization_value = 0;
+
+  if (g_once_init_enter (&initialization_value)) {
+    GST_INFO ("Initializing Windows symbol handler");
+    SymSetOptions (SYMOPT_LOAD_LINES);
+    SymInitialize (process, NULL, TRUE);
+    GST_INFO ("Initialized Windows symbol handler");
+
+    g_once_init_leave (&initialization_value, 1);
+  }
+}
+
+static gchar *
+generate_dbghelp_trace (void)
+{
+  HANDLE process = GetCurrentProcess ();
+  HANDLE thread = GetCurrentThread ();
+  IMAGEHLP_MODULE64 module_info;
+  DWORD machine;
+  CONTEXT context;
+  STACKFRAME64 frame = { 0 };
+  PVOID save_context;
+  GString *trace = g_string_new (NULL);
+
+  dbghelp_initialize_symbols (process);
+
+  memset (&context, 0, sizeof (CONTEXT));
+  context.ContextFlags = CONTEXT_FULL;
+
+  RtlCaptureContext (&context);
+
+  frame.AddrPC.Mode = AddrModeFlat;
+  frame.AddrStack.Mode = AddrModeFlat;
+  frame.AddrFrame.Mode = AddrModeFlat;
+
+#if (defined _M_IX86)
+  machine = IMAGE_FILE_MACHINE_I386;
+  frame.AddrFrame.Offset = context.Ebp;
+  frame.AddrPC.Offset = context.Eip;
+  frame.AddrStack.Offset = context.Esp;
+#elif (defined _M_X64)
+  machine = IMAGE_FILE_MACHINE_AMD64;
+  frame.AddrFrame.Offset = context.Rbp;
+  frame.AddrPC.Offset = context.Rip;
+  frame.AddrStack.Offset = context.Rsp;
+#else
+  goto done;
+#endif
+
+  module_info.SizeOfStruct = sizeof (module_info);
+  save_context = (machine == IMAGE_FILE_MACHINE_I386) ? NULL : &context;
+
+  while (TRUE) {
+    char buffer[sizeof (SYMBOL_INFO) + MAX_SYM_NAME * sizeof (TCHAR)];
+    PSYMBOL_INFO symbol = (PSYMBOL_INFO) buffer;
+    IMAGEHLP_LINE64 line;
+    DWORD displacement = 0;
+
+    symbol->SizeOfStruct = sizeof (SYMBOL_INFO);
+    symbol->MaxNameLen = MAX_SYM_NAME;
+
+    line.SizeOfStruct = sizeof (line);
+
+    if (!StackWalk64 (machine, process, thread, &frame, save_context, 0,
+            SymFunctionTableAccess64, SymGetModuleBase64, 0))
+      break;
+
+    if (SymFromAddr (process, frame.AddrPC.Offset, 0, symbol))
+      g_string_append_printf (trace, "%s ", symbol->Name);
+    else
+      g_string_append (trace, "?? ");
+
+    if (SymGetLineFromAddr64 (process, frame.AddrPC.Offset, &displacement,
+            &line))
+      g_string_append_printf (trace, "(%s:%u)", line.FileName, line.LineNumber);
+    else if (SymGetModuleInfo64 (process, frame.AddrPC.Offset, &module_info))
+      g_string_append_printf (trace, "(%s)", module_info.ImageName);
+    else
+      g_string_append_printf (trace, "(%s)", "??");
+
+    g_string_append (trace, "\n");
+  }
+
+done:
+  return g_string_free (trace, FALSE);
+}
+#endif /* HAVE_DBGHELP */
+
 /**
  * gst_debug_get_stack_trace:
  * @flags: A set of #GstStackTraceFlags to determine how the stack
  * trace should look like. Pass 0 to retrieve a minimal backtrace.
  *
@@ -2784,10 +2917,14 @@
 #ifdef HAVE_UNWIND
   if ((flags & GST_STACK_TRACE_SHOW_FULL) || !have_backtrace)
     trace = generate_unwind_trace (flags);
 #endif /* HAVE_UNWIND */
 
+#ifdef HAVE_DBGHELP
+  trace = generate_dbghelp_trace ();
+#endif
+
   if (trace)
     return trace;
   else if (have_backtrace)
     return generate_backtrace_trace ();
 
@@ -2795,11 +2932,11 @@
 }
 
 /**
  * gst_debug_print_stack_trace:
  *
- * If libunwind or glibc backtrace are present
+ * If libunwind, glibc backtrace or DbgHelp are present
  * a stack trace is printed.
  */
 void
 gst_debug_print_stack_trace (void)
 {
@@ -2850,33 +2987,67 @@
   gsize output_len;
   GstRingBufferLog *log;
   gint64 now = g_get_monotonic_time ();
   const gchar *message_str = gst_debug_message_get (message);
 
+  /* __FILE__ might be a file name or an absolute path or a
+   * relative path, irrespective of the exact compiler used,
+   * in which case we want to shorten it to the filename for
+   * readability. */
+  c = file[0];
+  if (c == '.' || c == '/' || c == '\\' || (c != '\0' && file[1] == ':')) {
+    file = gst_path_basename (file);
+  }
+
+  if (object) {
+    obj = gst_debug_print_object (object);
+  } else {
+    obj = (gchar *) "";
+  }
+
+  elapsed = GST_CLOCK_DIFF (_priv_gst_start_time, gst_util_get_timestamp ());
+  pid = getpid ();
+  thread = g_thread_self ();
+
+  /* no color, all platforms */
+#define PRINT_FMT " "PID_FMT" "PTR_FMT" %s "CAT_FMT" %s\n"
+  output =
+      g_strdup_printf ("%" GST_TIME_FORMAT PRINT_FMT, GST_TIME_ARGS (elapsed),
+      pid, thread, gst_debug_level_get_name (level),
+      gst_debug_category_get_name (category), file, line, function, obj,
+      message_str);
+#undef PRINT_FMT
+
+  output_len = strlen (output);
+
+  if (object != NULL)
+    g_free (obj);
+
   G_LOCK (ring_buffer_logger);
 
   if (logger->thread_timeout > 0) {
+    gchar *buf;
+
     /* Remove all threads that saw no output since thread_timeout seconds.
      * By construction these are all at the tail of the queue, and the queue
      * is ordered by last use, so we just need to look at the tail.
      */
     while (logger->threads.tail) {
       log = logger->threads.tail->data;
       if (log->last_use + logger->thread_timeout * G_USEC_PER_SEC >= now)
         break;
 
       g_hash_table_remove (logger->thread_index, log->thread);
-      while ((output = g_queue_pop_head (&log->log)))
-        g_free (output);
+      while ((buf = g_queue_pop_head (&log->log)))
+        g_free (buf);
       g_free (log);
       g_queue_pop_tail (&logger->threads);
     }
   }
 
   /* Get logger for this thread, and put it back at the
    * head of the threads queue */
-  thread = g_thread_self ();
   log = g_hash_table_lookup (logger->thread_index, thread);
   if (!log) {
     log = g_new0 (GstRingBufferLog, 1);
     g_queue_init (&log->log);
     log->log_size = 0;
@@ -2888,40 +3059,10 @@
     g_queue_unlink (&logger->threads, log->link);
     g_queue_push_head_link (&logger->threads, log->link);
   }
   log->last_use = now;
 
-  /* __FILE__ might be a file name or an absolute path or a
-   * relative path, irrespective of the exact compiler used,
-   * in which case we want to shorten it to the filename for
-   * readability. */
-  c = file[0];
-  if (c == '.' || c == '/' || c == '\\' || (c != '\0' && file[1] == ':')) {
-    file = gst_path_basename (file);
-  }
-
-  pid = getpid ();
-
-  if (object) {
-    obj = gst_debug_print_object (object);
-  } else {
-    obj = (gchar *) "";
-  }
-
-  elapsed = GST_CLOCK_DIFF (_priv_gst_start_time, gst_util_get_timestamp ());
-
-  /* no color, all platforms */
-#define PRINT_FMT " "PID_FMT" "PTR_FMT" %s "CAT_FMT" %s\n"
-  output =
-      g_strdup_printf ("%" GST_TIME_FORMAT PRINT_FMT, GST_TIME_ARGS (elapsed),
-      pid, thread, gst_debug_level_get_name (level),
-      gst_debug_category_get_name (category), file, line, function, obj,
-      message_str);
-#undef PRINT_FMT
-
-  output_len = strlen (output);
-
   if (output_len < logger->max_size_per_thread) {
     gchar *buf;
 
     /* While using a GQueue here is not the most efficient thing to do, we
      * have to allocate a string for every output anyway and could just store
@@ -2948,13 +3089,10 @@
       g_free (buf);
     g_free (output);
     log->log_size = 0;
   }
 
-  if (object != NULL)
-    g_free (obj);
-
   G_UNLOCK (ring_buffer_logger);
 }
 
 /**
  * gst_debug_ring_buffer_logger_get_logs:
