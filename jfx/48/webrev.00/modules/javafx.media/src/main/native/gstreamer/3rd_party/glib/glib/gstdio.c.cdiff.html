<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gstdio.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstdio-private.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstdio.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gstdio.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 17,11 ***</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;glibconfig.h&quot;
  
<span class="line-modified">! #define G_STDIO_NO_WRAP_ON_UNIX</span>
  
  #include &lt;sys/types.h&gt;
  #include &lt;sys/stat.h&gt;
  #include &lt;fcntl.h&gt;
  
<span class="line-new-header">--- 17,13 ---</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;glibconfig.h&quot;
  
<span class="line-modified">! /* Don&#39;t redefine (for example) g_open() to open(), since we actually want to</span>
<span class="line-added">+  * define g_open() in this file and export it as a symbol. See gstdio.h. */</span>
<span class="line-added">+ #define G_STDIO_WRAP_ON_UNIX</span>
  
  #include &lt;sys/types.h&gt;
  #include &lt;sys/stat.h&gt;
  #include &lt;fcntl.h&gt;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 34,10 ***</span>
<span class="line-new-header">--- 36,11 ---</span>
  #include &lt;errno.h&gt;
  #include &lt;wchar.h&gt;
  #include &lt;direct.h&gt;
  #include &lt;io.h&gt;
  #include &lt;sys/utime.h&gt;
<span class="line-added">+ #include &lt;stdlib.h&gt; /* for MB_CUR_MAX */</span>
  #else
  #include &lt;utime.h&gt;
  #include &lt;errno.h&gt;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 97,95 ***</span>
    switch (error_code)
      {
      case ERROR_ACCESS_DENIED:
        return EACCES;
        break;
<span class="line-modified">!     case ERROR_INVALID_HANDLE:</span>
<span class="line-modified">!       return EBADF;</span>
        break;
      case ERROR_INVALID_FUNCTION:
        return EFAULT;
        break;
<span class="line-modified">!     case ERROR_FILE_NOT_FOUND:</span>
<span class="line-modified">!       return ENOENT;</span>
        break;
<span class="line-modified">!     case ERROR_PATH_NOT_FOUND:</span>
<span class="line-modified">!       return ENOENT; /* or ELOOP, or ENAMETOOLONG */</span>
        break;
      case ERROR_NOT_ENOUGH_MEMORY:
      case ERROR_OUTOFMEMORY:
        return ENOMEM;
        break;
      default:
        return EIO;
        break;
      }
  }
  
  #include &quot;gstdio-private.c&quot;
  
  static int
  _g_win32_stat_utf16_no_trailing_slashes (const gunichar2    *filename,
<span class="line-removed">-                                          int                 fd,</span>
                                           GWin32PrivateStat  *buf,
                                           gboolean            for_symlink)
  {
<span class="line-removed">-   HANDLE file_handle;</span>
<span class="line-removed">-   gboolean succeeded_so_far;</span>
<span class="line-removed">-   DWORD error_code;</span>
    struct __stat64 statbuf;
    BY_HANDLE_FILE_INFORMATION handle_info;
    FILE_STANDARD_INFO std_info;
<span class="line-removed">-   WIN32_FIND_DATAW finddata;</span>
<span class="line-removed">-   DWORD immediate_attributes;</span>
    gboolean is_symlink = FALSE;
<span class="line-removed">-   gboolean is_directory;</span>
<span class="line-removed">-   DWORD open_flags;</span>
    wchar_t *filename_target = NULL;
<span class="line-modified">!   int result;</span>
  
<span class="line-modified">!   if (fd &lt; 0)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       immediate_attributes = GetFileAttributesW (filename);</span>
  
<span class="line-modified">!       if (immediate_attributes == INVALID_FILE_ATTRIBUTES)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           error_code = GetLastError ();</span>
<span class="line-modified">!           errno = w32_error_to_errno (error_code);</span>
  
<span class="line-modified">!           return -1;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!       is_symlink = (immediate_attributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;</span>
<span class="line-modified">!       is_directory = (immediate_attributes &amp; FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY;</span>
  
<span class="line-modified">!       open_flags = FILE_ATTRIBUTE_NORMAL;</span>
  
<span class="line-modified">!       if (for_symlink &amp;&amp; is_symlink)</span>
<span class="line-modified">!         open_flags |= FILE_FLAG_OPEN_REPARSE_POINT;</span>
  
<span class="line-modified">!       if (is_directory)</span>
<span class="line-modified">!         open_flags |= FILE_FLAG_BACKUP_SEMANTICS;</span>
  
<span class="line-modified">!       file_handle = CreateFileW (filename, FILE_READ_ATTRIBUTES,</span>
<span class="line-modified">!                                  FILE_SHARE_READ, NULL, OPEN_EXISTING,</span>
<span class="line-modified">!                                  open_flags,</span>
<span class="line-modified">!                                  NULL);</span>
  
<span class="line-modified">!       if (file_handle == INVALID_HANDLE_VALUE)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           error_code = GetLastError ();</span>
<span class="line-removed">-           errno = w32_error_to_errno (error_code);</span>
<span class="line-removed">-           return -1;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   else</span>
      {
<span class="line-modified">!       file_handle = (HANDLE) _get_osfhandle (fd);</span>
<span class="line-modified">! </span>
<span class="line-modified">!       if (file_handle == INVALID_HANDLE_VALUE)</span>
<span class="line-removed">-         return -1;</span>
      }
  
    succeeded_so_far = GetFileInformationByHandle (file_handle,
                                                   &amp;handle_info);
    error_code = GetLastError ();
<span class="line-new-header">--- 100,522 ---</span>
    switch (error_code)
      {
      case ERROR_ACCESS_DENIED:
        return EACCES;
        break;
<span class="line-modified">!     case ERROR_ALREADY_EXISTS:</span>
<span class="line-modified">!     case ERROR_FILE_EXISTS:</span>
<span class="line-added">+       return EEXIST;</span>
<span class="line-added">+     case ERROR_FILE_NOT_FOUND:</span>
<span class="line-added">+       return ENOENT;</span>
        break;
      case ERROR_INVALID_FUNCTION:
        return EFAULT;
        break;
<span class="line-modified">!     case ERROR_INVALID_HANDLE:</span>
<span class="line-modified">!       return EBADF;</span>
        break;
<span class="line-modified">!     case ERROR_INVALID_PARAMETER:</span>
<span class="line-modified">!       return EINVAL;</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case ERROR_LOCK_VIOLATION:</span>
<span class="line-added">+     case ERROR_SHARING_VIOLATION:</span>
<span class="line-added">+       return EACCES;</span>
        break;
      case ERROR_NOT_ENOUGH_MEMORY:
      case ERROR_OUTOFMEMORY:
        return ENOMEM;
        break;
<span class="line-added">+     case ERROR_NOT_SAME_DEVICE:</span>
<span class="line-added">+       return EXDEV;</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case ERROR_PATH_NOT_FOUND:</span>
<span class="line-added">+       return ENOENT; /* or ELOOP, or ENAMETOOLONG */</span>
<span class="line-added">+       break;</span>
      default:
        return EIO;
        break;
      }
  }
  
  #include &quot;gstdio-private.c&quot;
  
<span class="line-added">+ /* Windows implementation of fopen() does not accept modes such as</span>
<span class="line-added">+  * &quot;wb+&quot;. The &#39;b&#39; needs to be appended to &quot;w+&quot;, i.e. &quot;w+b&quot;. Note</span>
<span class="line-added">+  * that otherwise these 2 modes are supposed to be aliases, hence</span>
<span class="line-added">+  * swappable at will. TODO: Is this still true?</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static void</span>
<span class="line-added">+ _g_win32_fix_mode (wchar_t *mode)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   wchar_t *ptr;</span>
<span class="line-added">+   wchar_t temp;</span>
<span class="line-added">+ </span>
<span class="line-added">+   ptr = wcschr (mode, L&#39;+&#39;);</span>
<span class="line-added">+   if (ptr != NULL &amp;&amp; (ptr - mode) &gt; 1)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       temp = mode[1];</span>
<span class="line-added">+       mode[1] = *ptr;</span>
<span class="line-added">+       *ptr = temp;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* From</span>
<span class="line-added">+  * https://support.microsoft.com/en-ca/help/167296/how-to-convert-a-unix-time-t-to-a-win32-filetime-or-systemtime</span>
<span class="line-added">+  * FT = UT * 10000000 + 116444736000000000.</span>
<span class="line-added">+  * Therefore:</span>
<span class="line-added">+  * UT = (FT - 116444736000000000) / 10000000.</span>
<span class="line-added">+  * Converts FILETIME to unix epoch time in form</span>
<span class="line-added">+  * of a signed 64-bit integer (can be negative).</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static gint64</span>
<span class="line-added">+ _g_win32_filetime_to_unix_time (FILETIME *ft)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   gint64 result;</span>
<span class="line-added">+   /* 1 unit of FILETIME is 100ns */</span>
<span class="line-added">+   const gint64 hundreds_of_usec_per_sec = 10000000;</span>
<span class="line-added">+   /* The difference between January 1, 1601 UTC (FILETIME epoch) and UNIX epoch</span>
<span class="line-added">+    * in hundreds of nanoseconds.</span>
<span class="line-added">+    */</span>
<span class="line-added">+   const gint64 filetime_unix_epoch_offset = 116444736000000000;</span>
<span class="line-added">+ </span>
<span class="line-added">+   result = ((gint64) ft-&gt;dwLowDateTime) | (((gint64) ft-&gt;dwHighDateTime) &lt;&lt; 32);</span>
<span class="line-added">+   return (result - filetime_unix_epoch_offset) / hundreds_of_usec_per_sec;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #  ifdef _MSC_VER</span>
<span class="line-added">+ #    ifndef S_IXUSR</span>
<span class="line-added">+ #      define _S_IRUSR _S_IREAD</span>
<span class="line-added">+ #      define _S_IWUSR _S_IWRITE</span>
<span class="line-added">+ #      define _S_IXUSR _S_IEXEC</span>
<span class="line-added">+ #      define S_IRUSR _S_IRUSR</span>
<span class="line-added">+ #      define S_IWUSR _S_IWUSR</span>
<span class="line-added">+ #      define S_IXUSR _S_IXUSR</span>
<span class="line-added">+ #      define S_IRGRP (S_IRUSR &gt;&gt; 3)</span>
<span class="line-added">+ #      define S_IWGRP (S_IWUSR &gt;&gt; 3)</span>
<span class="line-added">+ #      define S_IXGRP (S_IXUSR &gt;&gt; 3)</span>
<span class="line-added">+ #      define S_IROTH (S_IRGRP &gt;&gt; 3)</span>
<span class="line-added">+ #      define S_IWOTH (S_IWGRP &gt;&gt; 3)</span>
<span class="line-added">+ #      define S_IXOTH (S_IXGRP &gt;&gt; 3)</span>
<span class="line-added">+ #    endif</span>
<span class="line-added">+ #    ifndef S_ISDIR</span>
<span class="line-added">+ #      define S_ISDIR(m) (((m) &amp; _S_IFMT) == _S_IFDIR)</span>
<span class="line-added">+ #    endif</span>
<span class="line-added">+ #  endif</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* Uses filename and BHFI to fill a stat64 structure.</span>
<span class="line-added">+  * Tries to reproduce the behaviour and quirks of MS C runtime stat().</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static int</span>
<span class="line-added">+ _g_win32_fill_statbuf_from_handle_info (const wchar_t              *filename,</span>
<span class="line-added">+                                         const wchar_t              *filename_target,</span>
<span class="line-added">+                                         BY_HANDLE_FILE_INFORMATION *handle_info,</span>
<span class="line-added">+                                         struct __stat64            *statbuf)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   wchar_t drive_letter_w = 0;</span>
<span class="line-added">+   size_t drive_letter_size = MB_CUR_MAX;</span>
<span class="line-added">+   char *drive_letter = _alloca (drive_letter_size);</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* If filename (target or link) is absolute,</span>
<span class="line-added">+    * then use the drive letter from it as-is.</span>
<span class="line-added">+    */</span>
<span class="line-added">+   if (filename_target != NULL &amp;&amp;</span>
<span class="line-added">+       filename_target[0] != L&#39;\0&#39; &amp;&amp;</span>
<span class="line-added">+       filename_target[1] == L&#39;:&#39;)</span>
<span class="line-added">+     drive_letter_w = filename_target[0];</span>
<span class="line-added">+   else if (filename[0] != L&#39;\0&#39; &amp;&amp;</span>
<span class="line-added">+            filename[1] == L&#39;:&#39;)</span>
<span class="line-added">+     drive_letter_w = filename[0];</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (drive_letter_w &gt; 0 &amp;&amp;</span>
<span class="line-added">+       iswalpha (drive_letter_w) &amp;&amp;</span>
<span class="line-added">+       iswascii (drive_letter_w) &amp;&amp;</span>
<span class="line-added">+       wctomb (drive_letter, drive_letter_w) == 1)</span>
<span class="line-added">+     statbuf-&gt;st_dev = toupper (drive_letter[0]) - &#39;A&#39;; /* 0 means A: drive */</span>
<span class="line-added">+   else</span>
<span class="line-added">+     /* Otherwise use the PWD drive.</span>
<span class="line-added">+      * Return value of 0 gives us 0 - 1 = -1,</span>
<span class="line-added">+      * which is the &quot;no idea&quot; value for st_dev.</span>
<span class="line-added">+      */</span>
<span class="line-added">+     statbuf-&gt;st_dev = _getdrive () - 1;</span>
<span class="line-added">+ </span>
<span class="line-added">+   statbuf-&gt;st_rdev = statbuf-&gt;st_dev;</span>
<span class="line-added">+   /* Theoretically, it&#39;s possible to set it for ext-FS. No idea how.</span>
<span class="line-added">+    * Meaningless for all filesystems that Windows normally uses.</span>
<span class="line-added">+    */</span>
<span class="line-added">+   statbuf-&gt;st_ino = 0;</span>
<span class="line-added">+   statbuf-&gt;st_mode = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if ((handle_info-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY)</span>
<span class="line-added">+     statbuf-&gt;st_mode |= S_IFDIR | S_IXUSR | S_IXGRP | S_IXOTH;</span>
<span class="line-added">+   else</span>
<span class="line-added">+     statbuf-&gt;st_mode |= S_IFREG;</span>
<span class="line-added">+   /* No idea what S_IFCHR means here. */</span>
<span class="line-added">+   /* S_IFIFO is not even mentioned in MSDN */</span>
<span class="line-added">+   /* S_IFBLK is also not mentioned */</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* The aim here is to reproduce MS stat() behaviour,</span>
<span class="line-added">+    * even if it&#39;s braindead.</span>
<span class="line-added">+    */</span>
<span class="line-added">+   statbuf-&gt;st_mode |= S_IRUSR | S_IRGRP | S_IROTH;</span>
<span class="line-added">+   if ((handle_info-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_READONLY) != FILE_ATTRIBUTE_READONLY)</span>
<span class="line-added">+     statbuf-&gt;st_mode |= S_IWUSR | S_IWGRP | S_IWOTH;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!S_ISDIR (statbuf-&gt;st_mode))</span>
<span class="line-added">+     {</span>
<span class="line-added">+       const wchar_t *name;</span>
<span class="line-added">+       const wchar_t *dot = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+       if (filename_target != NULL)</span>
<span class="line-added">+         name = filename_target;</span>
<span class="line-added">+       else</span>
<span class="line-added">+         name = filename;</span>
<span class="line-added">+ </span>
<span class="line-added">+       do</span>
<span class="line-added">+         {</span>
<span class="line-added">+           wchar_t *last_dot = wcschr (name, L&#39;.&#39;);</span>
<span class="line-added">+           if (last_dot == NULL)</span>
<span class="line-added">+             break;</span>
<span class="line-added">+           dot = last_dot;</span>
<span class="line-added">+           name = &amp;last_dot[1];</span>
<span class="line-added">+         }</span>
<span class="line-added">+       while (TRUE);</span>
<span class="line-added">+ </span>
<span class="line-added">+       if ((dot != NULL &amp;&amp;</span>
<span class="line-added">+           (wcsicmp (dot, L&quot;.exe&quot;) == 0 ||</span>
<span class="line-added">+            wcsicmp (dot, L&quot;.com&quot;) == 0 ||</span>
<span class="line-added">+            wcsicmp (dot, L&quot;.bat&quot;) == 0 ||</span>
<span class="line-added">+            wcsicmp (dot, L&quot;.cmd&quot;) == 0)))</span>
<span class="line-added">+         statbuf-&gt;st_mode |= S_IXUSR | S_IXGRP | S_IXOTH;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   statbuf-&gt;st_nlink = handle_info-&gt;nNumberOfLinks;</span>
<span class="line-added">+   statbuf-&gt;st_uid = statbuf-&gt;st_gid = 0;</span>
<span class="line-added">+   statbuf-&gt;st_size = (((guint64) handle_info-&gt;nFileSizeHigh) &lt;&lt; 32) | handle_info-&gt;nFileSizeLow;</span>
<span class="line-added">+   statbuf-&gt;st_ctime = _g_win32_filetime_to_unix_time (&amp;handle_info-&gt;ftCreationTime);</span>
<span class="line-added">+   statbuf-&gt;st_mtime = _g_win32_filetime_to_unix_time (&amp;handle_info-&gt;ftLastWriteTime);</span>
<span class="line-added">+   statbuf-&gt;st_atime = _g_win32_filetime_to_unix_time (&amp;handle_info-&gt;ftLastAccessTime);</span>
<span class="line-added">+ </span>
<span class="line-added">+   return 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* Fills our private stat-like structure using data from</span>
<span class="line-added">+  * a normal stat64 struct, BHFI, FSI and a reparse tag.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static void</span>
<span class="line-added">+ _g_win32_fill_privatestat (const struct __stat64            *statbuf,</span>
<span class="line-added">+                            const BY_HANDLE_FILE_INFORMATION *handle_info,</span>
<span class="line-added">+                            const FILE_STANDARD_INFO         *std_info,</span>
<span class="line-added">+                            DWORD                             reparse_tag,</span>
<span class="line-added">+                            GWin32PrivateStat                *buf)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   buf-&gt;st_dev = statbuf-&gt;st_dev;</span>
<span class="line-added">+   buf-&gt;st_mode = statbuf-&gt;st_mode;</span>
<span class="line-added">+   buf-&gt;volume_serial = handle_info-&gt;dwVolumeSerialNumber;</span>
<span class="line-added">+   buf-&gt;file_index = (((guint64) handle_info-&gt;nFileIndexHigh) &lt;&lt; 32) | handle_info-&gt;nFileIndexLow;</span>
<span class="line-added">+   buf-&gt;attributes = handle_info-&gt;dwFileAttributes;</span>
<span class="line-added">+   buf-&gt;st_nlink = handle_info-&gt;nNumberOfLinks;</span>
<span class="line-added">+   buf-&gt;st_size = (((guint64) handle_info-&gt;nFileSizeHigh) &lt;&lt; 32) | handle_info-&gt;nFileSizeLow;</span>
<span class="line-added">+   buf-&gt;allocated_size = std_info-&gt;AllocationSize.QuadPart;</span>
<span class="line-added">+ </span>
<span class="line-added">+   buf-&gt;reparse_tag = reparse_tag;</span>
<span class="line-added">+ </span>
<span class="line-added">+   buf-&gt;st_ctime = statbuf-&gt;st_ctime;</span>
<span class="line-added">+   buf-&gt;st_atime = statbuf-&gt;st_atime;</span>
<span class="line-added">+   buf-&gt;st_mtime = statbuf-&gt;st_mtime;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* Read the link data from a symlink/mountpoint represented</span>
<span class="line-added">+  * by the handle. Also reads reparse tag.</span>
<span class="line-added">+  * @reparse_tag receives the tag. Can be %NULL if @buf or @alloc_buf</span>
<span class="line-added">+  *              is non-NULL.</span>
<span class="line-added">+  * @buf receives the link data. Can be %NULL if reparse_tag is non-%NULL.</span>
<span class="line-added">+  *      Mutually-exclusive with @alloc_buf.</span>
<span class="line-added">+  * @buf_size is the size of the @buf, in bytes.</span>
<span class="line-added">+  * @alloc_buf points to a location where internally-allocated buffer</span>
<span class="line-added">+  *            pointer will be written. That buffer receives the</span>
<span class="line-added">+  *            link data. Mutually-exclusive with @buf.</span>
<span class="line-added">+  * @terminate ensures that the buffer is NUL-terminated if</span>
<span class="line-added">+  *            it isn&#39;t already. Note that this can erase useful</span>
<span class="line-added">+  *            data if @buf is provided and @buf_size is too small.</span>
<span class="line-added">+  *            Specifically, with @buf_size &lt;= 2 the buffer will</span>
<span class="line-added">+  *            receive an empty string, even if there is some</span>
<span class="line-added">+  *            data in the reparse point.</span>
<span class="line-added">+  * The contents of @buf or @alloc_buf are presented as-is - could</span>
<span class="line-added">+  * be non-NUL-terminated (unless @terminate is %TRUE) or even malformed.</span>
<span class="line-added">+  * Returns the number of bytes (!) placed into @buf or @alloc_buf,</span>
<span class="line-added">+  * including NUL-terminator (if any).</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Returned value of 0 means that there&#39;s no recognizable data in the</span>
<span class="line-added">+  * reparse point. @alloc_buf will not be allocated in that case,</span>
<span class="line-added">+  * and @buf will be left unmodified.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * If @buf and @alloc_buf are %NULL, returns 0 to indicate success.</span>
<span class="line-added">+  * Returns -1 to indicate an error, sets errno.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static int</span>
<span class="line-added">+ _g_win32_readlink_handle_raw (HANDLE      h,</span>
<span class="line-added">+                               DWORD      *reparse_tag,</span>
<span class="line-added">+                               gunichar2  *buf,</span>
<span class="line-added">+                               gsize       buf_size,</span>
<span class="line-added">+                               gunichar2 **alloc_buf,</span>
<span class="line-added">+                               gboolean    terminate)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   DWORD error_code;</span>
<span class="line-added">+   DWORD returned_bytes = 0;</span>
<span class="line-added">+   BYTE *data;</span>
<span class="line-added">+   gsize to_copy;</span>
<span class="line-added">+   /* This is 16k. It&#39;s impossible to make DeviceIoControl() tell us</span>
<span class="line-added">+    * the required size. NtFsControlFile() does have such a feature,</span>
<span class="line-added">+    * but for some reason it doesn&#39;t work with CreateFile()-returned handles.</span>
<span class="line-added">+    * The only alternative is to repeatedly call DeviceIoControl()</span>
<span class="line-added">+    * with bigger and bigger buffers, until it succeeds.</span>
<span class="line-added">+    * We choose to sacrifice stack space for speed.</span>
<span class="line-added">+    */</span>
<span class="line-added">+   BYTE max_buffer[sizeof (REPARSE_DATA_BUFFER) + MAXIMUM_REPARSE_DATA_BUFFER_SIZE] = {0,};</span>
<span class="line-added">+   DWORD max_buffer_size = sizeof (REPARSE_DATA_BUFFER) + MAXIMUM_REPARSE_DATA_BUFFER_SIZE;</span>
<span class="line-added">+   REPARSE_DATA_BUFFER *rep_buf;</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_return_val_if_fail ((buf != NULL || alloc_buf != NULL || reparse_tag != NULL) &amp;&amp;</span>
<span class="line-added">+                         (buf == NULL || alloc_buf == NULL),</span>
<span class="line-added">+                         -1);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!DeviceIoControl (h, FSCTL_GET_REPARSE_POINT, NULL, 0,</span>
<span class="line-added">+                         max_buffer,</span>
<span class="line-added">+                         max_buffer_size,</span>
<span class="line-added">+                         &amp;returned_bytes, NULL))</span>
<span class="line-added">+     {</span>
<span class="line-added">+       error_code = GetLastError ();</span>
<span class="line-added">+       errno = w32_error_to_errno (error_code);</span>
<span class="line-added">+       return -1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   rep_buf = (REPARSE_DATA_BUFFER *) max_buffer;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (reparse_tag != NULL)</span>
<span class="line-added">+     *reparse_tag = rep_buf-&gt;ReparseTag;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (buf == NULL &amp;&amp; alloc_buf == NULL)</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (rep_buf-&gt;ReparseTag == IO_REPARSE_TAG_SYMLINK)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       data = &amp;((BYTE *) rep_buf-&gt;SymbolicLinkReparseBuffer.PathBuffer)[rep_buf-&gt;SymbolicLinkReparseBuffer.SubstituteNameOffset];</span>
<span class="line-added">+ </span>
<span class="line-added">+       to_copy = rep_buf-&gt;SymbolicLinkReparseBuffer.SubstituteNameLength;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   else if (rep_buf-&gt;ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       data = &amp;((BYTE *) rep_buf-&gt;MountPointReparseBuffer.PathBuffer)[rep_buf-&gt;MountPointReparseBuffer.SubstituteNameOffset];</span>
<span class="line-added">+ </span>
<span class="line-added">+       to_copy = rep_buf-&gt;MountPointReparseBuffer.SubstituteNameLength;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   else</span>
<span class="line-added">+     to_copy = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+   return _g_win32_copy_and_maybe_terminate (data, to_copy, buf, buf_size, alloc_buf, terminate);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* Read the link data from a symlink/mountpoint represented</span>
<span class="line-added">+  * by the @filename.</span>
<span class="line-added">+  * @filename is the name of the file.</span>
<span class="line-added">+  * @reparse_tag receives the tag. Can be %NULL if @buf or @alloc_buf</span>
<span class="line-added">+  *              is non-%NULL.</span>
<span class="line-added">+  * @buf receives the link data. Mutually-exclusive with @alloc_buf.</span>
<span class="line-added">+  * @buf_size is the size of the @buf, in bytes.</span>
<span class="line-added">+  * @alloc_buf points to a location where internally-allocated buffer</span>
<span class="line-added">+  *            pointer will be written. That buffer receives the</span>
<span class="line-added">+  *            link data. Mutually-exclusive with @buf.</span>
<span class="line-added">+  * @terminate ensures that the buffer is NUL-terminated if</span>
<span class="line-added">+  *            it isn&#39;t already</span>
<span class="line-added">+  * The contents of @buf or @alloc_buf are presented as-is - could</span>
<span class="line-added">+  * be non-NUL-terminated (unless @terminate is TRUE) or even malformed.</span>
<span class="line-added">+  * Returns the number of bytes (!) placed into @buf or @alloc_buf.</span>
<span class="line-added">+  * Returned value of 0 means that there&#39;s no recognizable data in the</span>
<span class="line-added">+  * reparse point. @alloc_buf will not be allocated in that case,</span>
<span class="line-added">+  * and @buf will be left unmodified.</span>
<span class="line-added">+  * If @buf and @alloc_buf are %NULL, returns 0 to indicate success.</span>
<span class="line-added">+  * Returns -1 to indicate an error, sets errno.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static int</span>
<span class="line-added">+ _g_win32_readlink_utf16_raw (const gunichar2  *filename,</span>
<span class="line-added">+                              DWORD            *reparse_tag,</span>
<span class="line-added">+                              gunichar2        *buf,</span>
<span class="line-added">+                              gsize             buf_size,</span>
<span class="line-added">+                              gunichar2       **alloc_buf,</span>
<span class="line-added">+                              gboolean          terminate)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   HANDLE h;</span>
<span class="line-added">+   DWORD attributes;</span>
<span class="line-added">+   DWORD to_copy;</span>
<span class="line-added">+   DWORD error_code;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if ((attributes = GetFileAttributesW (filename)) == 0)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       error_code = GetLastError ();</span>
<span class="line-added">+       errno = w32_error_to_errno (error_code);</span>
<span class="line-added">+       return -1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if ((attributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == 0)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       errno = EINVAL;</span>
<span class="line-added">+       return -1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* To read symlink target we need to open the file as a reparse</span>
<span class="line-added">+    * point and use DeviceIoControl() on it.</span>
<span class="line-added">+    */</span>
<span class="line-added">+   h = CreateFileW (filename,</span>
<span class="line-added">+                    FILE_READ_EA,</span>
<span class="line-added">+                    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,</span>
<span class="line-added">+                    NULL, OPEN_EXISTING,</span>
<span class="line-added">+                    FILE_ATTRIBUTE_NORMAL</span>
<span class="line-added">+                    | FILE_FLAG_OPEN_REPARSE_POINT</span>
<span class="line-added">+                    | (attributes &amp; FILE_ATTRIBUTE_DIRECTORY ? FILE_FLAG_BACKUP_SEMANTICS : 0),</span>
<span class="line-added">+                    NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (h == INVALID_HANDLE_VALUE)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       error_code = GetLastError ();</span>
<span class="line-added">+       errno = w32_error_to_errno (error_code);</span>
<span class="line-added">+       return -1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   to_copy = _g_win32_readlink_handle_raw (h, reparse_tag, buf, buf_size, alloc_buf, terminate);</span>
<span class="line-added">+ </span>
<span class="line-added">+   CloseHandle (h);</span>
<span class="line-added">+ </span>
<span class="line-added">+   return to_copy;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* Read the link data from a symlink/mountpoint represented</span>
<span class="line-added">+  * by a UTF-16 filename or a file handle.</span>
<span class="line-added">+  * @filename is the name of the file. Mutually-exclusive with @file_handle.</span>
<span class="line-added">+  * @file_handle is the handle of the file. Mutually-exclusive with @filename.</span>
<span class="line-added">+  * @reparse_tag receives the tag. Can be %NULL if @buf or @alloc_buf</span>
<span class="line-added">+  *              is non-%NULL.</span>
<span class="line-added">+  * @buf receives the link data. Mutually-exclusive with @alloc_buf.</span>
<span class="line-added">+  * @buf_size is the size of the @buf, in bytes.</span>
<span class="line-added">+  * @alloc_buf points to a location where internally-allocated buffer</span>
<span class="line-added">+  *            pointer will be written. That buffer receives the</span>
<span class="line-added">+  *            link data. Mutually-exclusive with @buf.</span>
<span class="line-added">+  * @terminate ensures that the buffer is NUL-terminated if</span>
<span class="line-added">+  *            it isn&#39;t already</span>
<span class="line-added">+  * The contents of @buf or @alloc_buf are adjusted</span>
<span class="line-added">+  * (extended or nt object manager prefix is stripped),</span>
<span class="line-added">+  * but otherwise they are presented as-is - could be non-NUL-terminated</span>
<span class="line-added">+  * (unless @terminate is TRUE) or even malformed.</span>
<span class="line-added">+  * Returns the number of bytes (!) placed into @buf or @alloc_buf.</span>
<span class="line-added">+  * Returned value of 0 means that there&#39;s no recognizable data in the</span>
<span class="line-added">+  * reparse point. @alloc_buf will not be allocated in that case,</span>
<span class="line-added">+  * and @buf will be left unmodified.</span>
<span class="line-added">+  * Returns -1 to indicate an error, sets errno.</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static int</span>
<span class="line-added">+ _g_win32_readlink_utf16_handle (const gunichar2  *filename,</span>
<span class="line-added">+                                 HANDLE            file_handle,</span>
<span class="line-added">+                                 DWORD            *reparse_tag,</span>
<span class="line-added">+                                 gunichar2        *buf,</span>
<span class="line-added">+                                 gsize             buf_size,</span>
<span class="line-added">+                                 gunichar2       **alloc_buf,</span>
<span class="line-added">+                                 gboolean          terminate)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   int   result;</span>
<span class="line-added">+   gsize string_size;</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_return_val_if_fail ((buf != NULL || alloc_buf != NULL || reparse_tag != NULL) &amp;&amp;</span>
<span class="line-added">+                         (filename != NULL || file_handle != NULL) &amp;&amp;</span>
<span class="line-added">+                         (buf == NULL || alloc_buf == NULL) &amp;&amp;</span>
<span class="line-added">+                         (filename == NULL || file_handle == NULL),</span>
<span class="line-added">+                         -1);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (filename)</span>
<span class="line-added">+     result = _g_win32_readlink_utf16_raw (filename, reparse_tag, buf, buf_size, alloc_buf, terminate);</span>
<span class="line-added">+   else</span>
<span class="line-added">+     result = _g_win32_readlink_handle_raw (file_handle, reparse_tag, buf, buf_size, alloc_buf, terminate);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (result &lt;= 0)</span>
<span class="line-added">+     return result;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Ensure that output is a multiple of sizeof (gunichar2),</span>
<span class="line-added">+    * cutting any trailing partial gunichar2, if present.</span>
<span class="line-added">+    */</span>
<span class="line-added">+   result -= result % sizeof (gunichar2);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (result &lt;= 0)</span>
<span class="line-added">+     return result;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* DeviceIoControl () tends to return filenames as NT Object Manager</span>
<span class="line-added">+    * names , i.e. &quot;\\??\\C:\\foo\\bar&quot;.</span>
<span class="line-added">+    * Remove the leading 4-byte &quot;\\??\\&quot; prefix, as glib (as well as many W32 API</span>
<span class="line-added">+    * functions) is unprepared to deal with it. Unless it has no &#39;x:&#39; drive</span>
<span class="line-added">+    * letter part after the prefix, in which case we leave everything</span>
<span class="line-added">+    * as-is, because the path could be &quot;\\??\\Volume{GUID}&quot; - stripping</span>
<span class="line-added">+    * the prefix will allow it to be confused with relative links</span>
<span class="line-added">+    * targeting &quot;Volume{GUID}&quot;.</span>
<span class="line-added">+    */</span>
<span class="line-added">+   string_size = result / sizeof (gunichar2);</span>
<span class="line-added">+   _g_win32_strip_extended_ntobjm_prefix (buf ? buf : *alloc_buf, &amp;string_size);</span>
<span class="line-added">+ </span>
<span class="line-added">+   return string_size * sizeof (gunichar2);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* Works like stat() or lstat(), depending on the value of @for_symlink,</span>
<span class="line-added">+  * but accepts filename in UTF-16 and fills our custom stat structure.</span>
<span class="line-added">+  * The @filename must not have trailing slashes.</span>
<span class="line-added">+  */</span>
  static int
  _g_win32_stat_utf16_no_trailing_slashes (const gunichar2    *filename,
                                           GWin32PrivateStat  *buf,
                                           gboolean            for_symlink)
  {
    struct __stat64 statbuf;
    BY_HANDLE_FILE_INFORMATION handle_info;
    FILE_STANDARD_INFO std_info;
    gboolean is_symlink = FALSE;
    wchar_t *filename_target = NULL;
<span class="line-modified">!   DWORD immediate_attributes;</span>
<span class="line-added">+   DWORD open_flags;</span>
<span class="line-added">+   gboolean is_directory;</span>
<span class="line-added">+   DWORD reparse_tag = 0;</span>
<span class="line-added">+   DWORD error_code;</span>
<span class="line-added">+   BOOL succeeded_so_far;</span>
<span class="line-added">+   HANDLE file_handle;</span>
  
<span class="line-modified">!   immediate_attributes = GetFileAttributesW (filename);</span>
  
<span class="line-modified">!   if (immediate_attributes == INVALID_FILE_ATTRIBUTES)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       error_code = GetLastError ();</span>
<span class="line-modified">!       errno = w32_error_to_errno (error_code);</span>
  
<span class="line-modified">!       return -1;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!   is_symlink = (immediate_attributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;</span>
<span class="line-modified">!   is_directory = (immediate_attributes &amp; FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY;</span>
  
<span class="line-modified">!   open_flags = FILE_ATTRIBUTE_NORMAL;</span>
  
<span class="line-modified">!   if (for_symlink &amp;&amp; is_symlink)</span>
<span class="line-modified">!     open_flags |= FILE_FLAG_OPEN_REPARSE_POINT;</span>
  
<span class="line-modified">!   if (is_directory)</span>
<span class="line-modified">!     open_flags |= FILE_FLAG_BACKUP_SEMANTICS;</span>
  
<span class="line-modified">!   file_handle = CreateFileW (filename, FILE_READ_ATTRIBUTES | FILE_READ_EA,</span>
<span class="line-modified">!                              FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,</span>
<span class="line-modified">!                              NULL, OPEN_EXISTING,</span>
<span class="line-modified">!                              open_flags,</span>
<span class="line-added">+                              NULL);</span>
  
<span class="line-modified">!   if (file_handle == INVALID_HANDLE_VALUE)</span>
      {
<span class="line-modified">!       error_code = GetLastError ();</span>
<span class="line-modified">!       errno = w32_error_to_errno (error_code);</span>
<span class="line-modified">!       return -1;</span>
      }
  
    succeeded_so_far = GetFileInformationByHandle (file_handle,
                                                   &amp;handle_info);
    error_code = GetLastError ();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 199,178 ***</span>
        error_code = GetLastError ();
      }
  
    if (!succeeded_so_far)
      {
<span class="line-modified">!       if (fd &lt; 0)</span>
<span class="line-removed">-         CloseHandle (file_handle);</span>
        errno = w32_error_to_errno (error_code);
        return -1;
      }
  
    /* It&#39;s tempting to use GetFileInformationByHandleEx(FileAttributeTagInfo),
     * but it always reports that the ReparseTag is 0.
     */
<span class="line-modified">!   if (fd &lt; 0)</span>
      {
<span class="line-modified">!       memset (&amp;finddata, 0, sizeof (finddata));</span>
  
<span class="line-modified">!       if (handle_info.dwFileAttributes &amp; FILE_ATTRIBUTE_REPARSE_POINT)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           HANDLE tmp = FindFirstFileW (filename,</span>
<span class="line-removed">-                                        &amp;finddata);</span>
<span class="line-removed">- </span>
<span class="line-removed">-           if (tmp == INVALID_HANDLE_VALUE)</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-               error_code = GetLastError ();</span>
<span class="line-removed">-               errno = w32_error_to_errno (error_code);</span>
<span class="line-removed">-               CloseHandle (file_handle);</span>
<span class="line-removed">-               return -1;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-           FindClose (tmp);</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!       if (is_symlink &amp;&amp; !for_symlink)</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!           /* If filename is a symlink, _wstat64 obtains information about</span>
<span class="line-modified">!            * the symlink (except that st_size will be 0).</span>
<span class="line-modified">!            * To get information about the target we need to resolve</span>
<span class="line-modified">!            * the symlink first. And we need _wstat64() to get st_dev,</span>
<span class="line-modified">!            * it&#39;s a bother to try finding it ourselves.</span>
<span class="line-modified">!            */</span>
<span class="line-modified">!           DWORD filename_target_len;</span>
<span class="line-modified">!           DWORD new_len;</span>
<span class="line-removed">- </span>
<span class="line-removed">-           /* Just in case, give it a real memory location instead of NULL */</span>
<span class="line-removed">-           new_len = GetFinalPathNameByHandleW (file_handle,</span>
<span class="line-removed">-                                                (wchar_t *) &amp;filename_target_len,</span>
<span class="line-removed">-                                                0,</span>
<span class="line-removed">-                                                FILE_NAME_NORMALIZED);</span>
<span class="line-removed">- </span>
<span class="line-removed">- #define SANE_LIMIT 1024 * 10</span>
<span class="line-removed">-           if (new_len &gt;= SANE_LIMIT)</span>
<span class="line-removed">- #undef SANE_LIMIT</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-               new_len = 0;</span>
<span class="line-removed">-               error_code = ERROR_BUFFER_OVERFLOW;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">-           else if (new_len == 0)</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-               error_code = GetLastError ();</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-           if (new_len &gt; 0)</span>
<span class="line-removed">-             {</span>
<span class="line-removed">-               /* Pretend that new_len doesn&#39;t count the terminating NUL char,</span>
<span class="line-removed">-                * and ask for a bit more space than is needed, and allocate even more.</span>
<span class="line-removed">-                */</span>
<span class="line-removed">-               filename_target_len = new_len + 3;</span>
<span class="line-removed">-               filename_target = g_malloc ((filename_target_len + 1) * sizeof (wchar_t));</span>
<span class="line-removed">- </span>
<span class="line-removed">-               new_len = GetFinalPathNameByHandleW (file_handle,</span>
<span class="line-removed">-                                                    filename_target,</span>
<span class="line-removed">-                                                    filename_target_len,</span>
<span class="line-removed">-                                                    FILE_NAME_NORMALIZED);</span>
<span class="line-removed">- </span>
<span class="line-removed">-               /* filename_target_len is already larger than needed,</span>
<span class="line-removed">-                * new_len should be smaller than that, even if the size</span>
<span class="line-removed">-                * is off by 1 for some reason.</span>
<span class="line-removed">-                */</span>
<span class="line-removed">-               if (new_len &gt;= filename_target_len - 1)</span>
<span class="line-removed">-                 {</span>
<span class="line-removed">-                   new_len = 0;</span>
<span class="line-removed">-                   error_code = ERROR_BUFFER_OVERFLOW;</span>
<span class="line-removed">-                   g_clear_pointer (&amp;filename_target, g_free);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-               else if (new_len == 0)</span>
<span class="line-removed">-                 {</span>
<span class="line-removed">-                   g_clear_pointer (&amp;filename_target, g_free);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-               /* GetFinalPathNameByHandle() is documented to return extended paths,</span>
<span class="line-removed">-                * strip the extended prefix, if it is followed by a drive letter</span>
<span class="line-removed">-                * and a colon. Otherwise keep it (the path could be</span>
<span class="line-removed">-                * \\\\?\\Volume{GUID}\\ - it&#39;s only usable in extended form).</span>
<span class="line-removed">-                */</span>
<span class="line-removed">-               else if (new_len &gt; 0)</span>
<span class="line-removed">-                 {</span>
<span class="line-removed">-                   gsize len = new_len;</span>
<span class="line-removed">- </span>
<span class="line-removed">-                   /* Account for NUL-terminator maybe not being counted.</span>
<span class="line-removed">-                    * This is why we overallocated earlier.</span>
<span class="line-removed">-                    */</span>
<span class="line-removed">-                   if (filename_target[len] != L&#39;\0&#39;)</span>
<span class="line-removed">-                     {</span>
<span class="line-removed">-                       len++;</span>
<span class="line-removed">-                       filename_target[len] = L&#39;\0&#39;;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                   _g_win32_strip_extended_ntobjm_prefix (filename_target, &amp;len);</span>
<span class="line-removed">-                   new_len = len;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-           if (new_len == 0)</span>
<span class="line-removed">-             succeeded_so_far = FALSE;</span>
<span class="line-removed">-         }</span>
  
<span class="line-modified">!       CloseHandle (file_handle);</span>
<span class="line-modified">!     }</span>
<span class="line-removed">-   /* else if fd &gt;= 0 the file_handle was obtained via _get_osfhandle()</span>
<span class="line-removed">-    * and must not be closed, it is owned by fd.</span>
<span class="line-removed">-    */</span>
  
<span class="line-modified">!   if (!succeeded_so_far)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       errno = w32_error_to_errno (error_code);</span>
<span class="line-modified">!       return -1;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!   if (fd &lt; 0)</span>
<span class="line-removed">-     result = _wstat64 (filename_target != NULL ? filename_target : filename, &amp;statbuf);</span>
<span class="line-removed">-   else</span>
<span class="line-removed">-     result = _fstat64 (fd, &amp;statbuf);</span>
  
<span class="line-modified">!   if (result != 0)</span>
<span class="line-modified">!     {</span>
<span class="line-removed">-       int errsv = errno;</span>
  
<span class="line-modified">!       g_free (filename_target);</span>
<span class="line-modified">!       errno = errsv;</span>
  
        return -1;
      }
  
<span class="line-modified">!   g_free (filename_target);</span>
  
<span class="line-modified">!   buf-&gt;st_dev = statbuf.st_dev;</span>
<span class="line-modified">!   buf-&gt;st_mode = statbuf.st_mode;</span>
<span class="line-modified">!   buf-&gt;volume_serial = handle_info.dwVolumeSerialNumber;</span>
<span class="line-removed">-   buf-&gt;file_index = (((guint64) handle_info.nFileIndexHigh) &lt;&lt; 32) | handle_info.nFileIndexLow;</span>
<span class="line-removed">-   /* Note that immediate_attributes is for the symlink</span>
<span class="line-removed">-    * (if it&#39;s a symlink), while handle_info contains info</span>
<span class="line-removed">-    * about the symlink or the target, depending on the flags</span>
<span class="line-removed">-    * we used earlier.</span>
<span class="line-removed">-    */</span>
<span class="line-removed">-   buf-&gt;attributes = handle_info.dwFileAttributes;</span>
<span class="line-removed">-   buf-&gt;st_nlink = handle_info.nNumberOfLinks;</span>
<span class="line-removed">-   buf-&gt;st_size = (((guint64) handle_info.nFileSizeHigh) &lt;&lt; 32) | handle_info.nFileSizeLow;</span>
<span class="line-removed">-   buf-&gt;allocated_size = std_info.AllocationSize.QuadPart;</span>
  
<span class="line-modified">!   if (fd &lt; 0 &amp;&amp; buf-&gt;attributes &amp; FILE_ATTRIBUTE_REPARSE_POINT)</span>
<span class="line-modified">!     buf-&gt;reparse_tag = finddata.dwReserved0;</span>
<span class="line-removed">-   else</span>
<span class="line-removed">-     buf-&gt;reparse_tag = 0;</span>
  
<span class="line-modified">!   buf-&gt;st_ctime = statbuf.st_ctime;</span>
<span class="line-modified">!   buf-&gt;st_atime = statbuf.st_atime;</span>
<span class="line-modified">!   buf-&gt;st_mtime = statbuf.st_mtime;</span>
  
    return 0;
  }
  
  static int
  _g_win32_stat_utf8 (const gchar       *filename,
                      GWin32PrivateStat *buf,
                      gboolean           for_symlink)
  {
<span class="line-new-header">--- 629,108 ---</span>
        error_code = GetLastError ();
      }
  
    if (!succeeded_so_far)
      {
<span class="line-modified">!       CloseHandle (file_handle);</span>
        errno = w32_error_to_errno (error_code);
        return -1;
      }
  
    /* It&#39;s tempting to use GetFileInformationByHandleEx(FileAttributeTagInfo),
     * but it always reports that the ReparseTag is 0.
<span class="line-added">+    * We already have a handle open for symlink, use that.</span>
<span class="line-added">+    * For the target we have to specify a filename, and the function</span>
<span class="line-added">+    * will open another handle internally.</span>
     */
<span class="line-modified">!   if (is_symlink &amp;&amp;</span>
<span class="line-added">+       _g_win32_readlink_utf16_handle (for_symlink ? NULL : filename,</span>
<span class="line-added">+                                       for_symlink ? file_handle : NULL,</span>
<span class="line-added">+                                       &amp;reparse_tag,</span>
<span class="line-added">+                                       NULL, 0,</span>
<span class="line-added">+                                       for_symlink ? NULL : &amp;filename_target,</span>
<span class="line-added">+                                       TRUE) &lt; 0)</span>
      {
<span class="line-modified">!       CloseHandle (file_handle);</span>
<span class="line-added">+       return -1;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!   CloseHandle (file_handle);</span>
  
<span class="line-modified">!   _g_win32_fill_statbuf_from_handle_info (filename,</span>
<span class="line-modified">!                                           filename_target,</span>
<span class="line-modified">!                                           &amp;handle_info,</span>
<span class="line-modified">!                                           &amp;statbuf);</span>
<span class="line-modified">!   g_free (filename_target);</span>
<span class="line-modified">!   _g_win32_fill_privatestat (&amp;statbuf,</span>
<span class="line-modified">!                              &amp;handle_info,</span>
<span class="line-modified">!                              &amp;std_info,</span>
<span class="line-modified">!                              reparse_tag,</span>
<span class="line-modified">!                              buf);</span>
  
<span class="line-modified">!   return 0;</span>
<span class="line-modified">! }</span>
  
<span class="line-modified">! /* Works like fstat(), but fills our custom stat structure. */</span>
<span class="line-modified">! static int</span>
<span class="line-modified">! _g_win32_stat_fd (int                 fd,</span>
<span class="line-modified">!                   GWin32PrivateStat  *buf)</span>
<span class="line-modified">! {</span>
<span class="line-added">+   HANDLE file_handle;</span>
<span class="line-added">+   gboolean succeeded_so_far;</span>
<span class="line-added">+   DWORD error_code;</span>
<span class="line-added">+   struct __stat64 statbuf;</span>
<span class="line-added">+   BY_HANDLE_FILE_INFORMATION handle_info;</span>
<span class="line-added">+   FILE_STANDARD_INFO std_info;</span>
<span class="line-added">+   DWORD reparse_tag = 0;</span>
<span class="line-added">+   gboolean is_symlink = FALSE;</span>
  
<span class="line-modified">!   file_handle = (HANDLE) _get_osfhandle (fd);</span>
  
<span class="line-modified">!   if (file_handle == INVALID_HANDLE_VALUE)</span>
<span class="line-modified">!     return -1;</span>
  
<span class="line-modified">!   succeeded_so_far = GetFileInformationByHandle (file_handle,</span>
<span class="line-modified">!                                                  &amp;handle_info);</span>
<span class="line-added">+   error_code = GetLastError ();</span>
  
<span class="line-added">+   if (succeeded_so_far)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       succeeded_so_far = GetFileInformationByHandleEx (file_handle,</span>
<span class="line-added">+                                                        FileStandardInfo,</span>
<span class="line-added">+                                                        &amp;std_info,</span>
<span class="line-added">+                                                        sizeof (std_info));</span>
<span class="line-added">+       error_code = GetLastError ();</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (!succeeded_so_far)</span>
<span class="line-added">+     {</span>
<span class="line-added">+       errno = w32_error_to_errno (error_code);</span>
        return -1;
      }
  
<span class="line-modified">!   is_symlink = (handle_info.dwFileAttributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == FILE_ATTRIBUTE_REPARSE_POINT;</span>
  
<span class="line-modified">!   if (is_symlink &amp;&amp;</span>
<span class="line-modified">!       _g_win32_readlink_handle_raw (file_handle, &amp;reparse_tag, NULL, 0, NULL, FALSE) &lt; 0)</span>
<span class="line-modified">!     return -1;</span>
  
<span class="line-modified">!   if (_fstat64 (fd, &amp;statbuf) != 0)</span>
<span class="line-modified">!     return -1;</span>
  
<span class="line-modified">!   _g_win32_fill_privatestat (&amp;statbuf,</span>
<span class="line-modified">!                              &amp;handle_info,</span>
<span class="line-modified">!                              &amp;std_info,</span>
<span class="line-added">+                              reparse_tag,</span>
<span class="line-added">+                              buf);</span>
  
    return 0;
  }
  
<span class="line-added">+ /* Works like stat() or lstat(), depending on the value of @for_symlink,</span>
<span class="line-added">+  * but accepts filename in UTF-8 and fills our custom stat structure.</span>
<span class="line-added">+  */</span>
  static int
  _g_win32_stat_utf8 (const gchar       *filename,
                      GWin32PrivateStat *buf,
                      gboolean           for_symlink)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 399,234 ***</span>
      {
        errno = EINVAL;
        return -1;
      }
  
<span class="line-modified">!   result = _g_win32_stat_utf16_no_trailing_slashes (wfilename, -1, buf, for_symlink);</span>
  
    g_free (wfilename);
  
    return result;
  }
  
  int
  g_win32_stat_utf8 (const gchar       *filename,
                     GWin32PrivateStat *buf)
  {
    return _g_win32_stat_utf8 (filename, buf, FALSE);
  }
  
  int
  g_win32_lstat_utf8 (const gchar       *filename,
                      GWin32PrivateStat *buf)
  {
    return _g_win32_stat_utf8 (filename, buf, TRUE);
  }
  
  int
  g_win32_fstat (int                fd,
                 GWin32PrivateStat *buf)
  {
<span class="line-modified">!   return _g_win32_stat_utf16_no_trailing_slashes (NULL, fd, buf, FALSE);</span>
  }
  
<span class="line-modified">! static int</span>
<span class="line-modified">! _g_win32_readlink_utf16_raw (const gunichar2 *filename,</span>
<span class="line-modified">!                              gunichar2       *buf,</span>
<span class="line-modified">!                              gsize            buf_size)</span>
  {
<span class="line-modified">!   DWORD returned_bytes;</span>
<span class="line-modified">!   BYTE returned_data[MAXIMUM_REPARSE_DATA_BUFFER_SIZE]; /* This is 16k, by the way */</span>
<span class="line-modified">!   HANDLE h;</span>
<span class="line-modified">!   DWORD attributes;</span>
<span class="line-modified">!   REPARSE_DATA_BUFFER *rep_buf;</span>
<span class="line-removed">-   DWORD to_copy;</span>
<span class="line-removed">-   DWORD error_code;</span>
  
<span class="line-modified">!   if (buf_size &gt; G_MAXSIZE / sizeof (wchar_t))</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!       /* &quot;buf_size * sizeof (wchar_t)&quot; overflows */</span>
<span class="line-removed">-       errno = EFAULT;</span>
<span class="line-removed">-       return -1;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!   if ((attributes = GetFileAttributesW (filename)) == 0)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       error_code = GetLastError ();</span>
<span class="line-removed">-       errno = w32_error_to_errno (error_code);</span>
<span class="line-removed">-       return -1;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!   if ((attributes &amp; FILE_ATTRIBUTE_REPARSE_POINT) == 0)</span>
      {
        errno = EINVAL;
        return -1;
      }
  
<span class="line-modified">!   /* To read symlink target we need to open the file as a reparse</span>
<span class="line-modified">!    * point and use DeviceIoControl() on it.</span>
<span class="line-removed">-    */</span>
<span class="line-removed">-   h = CreateFileW (filename,</span>
<span class="line-removed">-                    FILE_READ_EA,</span>
<span class="line-removed">-                    FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,</span>
<span class="line-removed">-                    NULL, OPEN_EXISTING,</span>
<span class="line-removed">-                    FILE_ATTRIBUTE_NORMAL</span>
<span class="line-removed">-                    | FILE_FLAG_OPEN_REPARSE_POINT</span>
<span class="line-removed">-                    | (attributes &amp; FILE_ATTRIBUTE_DIRECTORY ? FILE_FLAG_BACKUP_SEMANTICS : 0),</span>
<span class="line-removed">-                    NULL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (h == INVALID_HANDLE_VALUE)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       error_code = GetLastError ();</span>
<span class="line-removed">-       errno = w32_error_to_errno (error_code);</span>
<span class="line-removed">-       return -1;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (!DeviceIoControl (h, FSCTL_GET_REPARSE_POINT, NULL, 0,</span>
<span class="line-removed">-                         returned_data, MAXIMUM_REPARSE_DATA_BUFFER_SIZE,</span>
<span class="line-removed">-                         &amp;returned_bytes, NULL))</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       error_code = GetLastError ();</span>
<span class="line-removed">-       errno = w32_error_to_errno (error_code);</span>
<span class="line-removed">-       CloseHandle (h);</span>
<span class="line-removed">-       return -1;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   rep_buf = (REPARSE_DATA_BUFFER *) returned_data;</span>
<span class="line-removed">-   to_copy = 0;</span>
  
<span class="line-modified">!   if (rep_buf-&gt;ReparseTag == IO_REPARSE_TAG_SYMLINK)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       to_copy = rep_buf-&gt;SymbolicLinkReparseBuffer.SubstituteNameLength;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (to_copy &gt; buf_size * sizeof (wchar_t))</span>
<span class="line-removed">-         to_copy = buf_size * sizeof (wchar_t);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       memcpy (buf,</span>
<span class="line-removed">-               &amp;((BYTE *) rep_buf-&gt;SymbolicLinkReparseBuffer.PathBuffer)[rep_buf-&gt;SymbolicLinkReparseBuffer.SubstituteNameOffset],</span>
<span class="line-removed">-               to_copy);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   else if (rep_buf-&gt;ReparseTag == IO_REPARSE_TAG_MOUNT_POINT)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       to_copy = rep_buf-&gt;MountPointReparseBuffer.SubstituteNameLength;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (to_copy &gt; buf_size * sizeof (wchar_t))</span>
<span class="line-removed">-         to_copy = buf_size * sizeof (wchar_t);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       memcpy (buf,</span>
<span class="line-removed">-               &amp;((BYTE *) rep_buf-&gt;MountPointReparseBuffer.PathBuffer)[rep_buf-&gt;MountPointReparseBuffer.SubstituteNameOffset],</span>
<span class="line-removed">-               to_copy);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   CloseHandle (h);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return to_copy;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static int</span>
<span class="line-removed">- _g_win32_readlink_utf16 (const gunichar2 *filename,</span>
<span class="line-removed">-                          gunichar2       *buf,</span>
<span class="line-removed">-                          gsize            buf_size)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   int   result = _g_win32_readlink_utf16_raw (filename, buf, buf_size);</span>
<span class="line-removed">-   gsize string_size;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (result &lt;= 0)</span>
<span class="line-removed">-     return result;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   /* Ensure that output is a multiple of sizeof (gunichar2),</span>
<span class="line-removed">-    * cutting any trailing partial gunichar2, if present.</span>
<span class="line-removed">-    */</span>
<span class="line-removed">-   result -= result % sizeof (gunichar2);</span>
  
    if (result &lt;= 0)
      return result;
  
<span class="line-modified">!   /* DeviceIoControl () tends to return filenames as NT Object Manager</span>
<span class="line-modified">!    * names , i.e. &quot;\\??\\C:\\foo\\bar&quot;.</span>
<span class="line-modified">!    * Remove the leading 4-byte \??\ prefix, as glib (as well as many W32 API</span>
<span class="line-modified">!    * functions) is unprepared to deal with it. Unless it has no &#39;x:&#39; drive</span>
<span class="line-modified">!    * letter part after the prefix, in which case we leave everything</span>
<span class="line-removed">-    * as-is, because the path could be &quot;\??\Volume{GUID}&quot; - stripping</span>
<span class="line-removed">-    * the prefix will allow it to be confused with relative links</span>
<span class="line-removed">-    * targeting &quot;Volume{GUID}&quot;.</span>
<span class="line-removed">-    */</span>
<span class="line-removed">-   string_size = result / sizeof (gunichar2);</span>
<span class="line-removed">-   _g_win32_strip_extended_ntobjm_prefix (buf, &amp;string_size);</span>
  
<span class="line-modified">!   return string_size * sizeof (gunichar2);</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! static gchar *</span>
<span class="line-removed">- _g_win32_get_mode_alias (const gchar *mode)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-   gchar *alias;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   alias = g_strdup (mode);</span>
<span class="line-removed">-   if (strlen (mode) &gt; 2 &amp;&amp; mode[2] == &#39;+&#39;)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-       /* Windows implementation of fopen() does not accept modes such as</span>
<span class="line-removed">-        * &quot;wb+&quot;. The &#39;b&#39; needs to be appended to &quot;w+&quot;, i.e. &quot;w+b&quot;. Note</span>
<span class="line-removed">-        * that otherwise these 2 modes are supposed to be aliases, hence</span>
<span class="line-removed">-        * swappable at will.</span>
<span class="line-removed">-        */</span>
<span class="line-removed">-       alias[1] = &#39;+&#39;;</span>
<span class="line-removed">-       alias[2] = mode[1];</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   return alias;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- int</span>
<span class="line-removed">- g_win32_readlink_utf8 (const gchar *filename,</span>
<span class="line-removed">-                        gchar       *buf,</span>
<span class="line-removed">-                        gsize        buf_size)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   wchar_t *wfilename;</span>
<span class="line-removed">-   int result;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (wfilename == NULL)</span>
      {
        errno = EINVAL;
        return -1;
      }
  
<span class="line-modified">!   result = _g_win32_readlink_utf16 (wfilename, (gunichar2 *) buf, buf_size);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   g_free (wfilename);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (result &gt; 0)</span>
      {
<span class="line-modified">!       glong tmp_len;</span>
<span class="line-modified">!       gchar *tmp = g_utf16_to_utf8 ((const gunichar2 *) buf,</span>
<span class="line-removed">-                                     result / sizeof (gunichar2),</span>
<span class="line-removed">-                                     NULL,</span>
<span class="line-removed">-                                     &amp;tmp_len,</span>
<span class="line-removed">-                                     NULL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (tmp == NULL)</span>
<span class="line-removed">-         {</span>
<span class="line-removed">-           errno = EINVAL;</span>
<span class="line-removed">-           return -1;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-       if (tmp_len &gt; buf_size - 1)</span>
<span class="line-removed">-         tmp_len = buf_size - 1;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       memcpy (buf, tmp, tmp_len);</span>
<span class="line-removed">-       /* readlink() doesn&#39;t NUL-terminate, but we do.</span>
<span class="line-removed">-        * To be compliant, however, we return the</span>
<span class="line-removed">-        * number of bytes without the NUL-terminator.</span>
<span class="line-removed">-        */</span>
<span class="line-removed">-       buf[tmp_len] = &#39;\0&#39;;</span>
<span class="line-removed">-       result = tmp_len;</span>
<span class="line-removed">-       g_free (tmp);</span>
      }
  
<span class="line-modified">!   return result;</span>
  }
  
  #endif
  
  /**
<span class="line-new-header">--- 759,139 ---</span>
      {
        errno = EINVAL;
        return -1;
      }
  
<span class="line-modified">!   result = _g_win32_stat_utf16_no_trailing_slashes (wfilename, buf, for_symlink);</span>
  
    g_free (wfilename);
  
    return result;
  }
  
<span class="line-added">+ /* Works like stat(), but accepts filename in UTF-8</span>
<span class="line-added">+  * and fills our custom stat structure.</span>
<span class="line-added">+  */</span>
  int
  g_win32_stat_utf8 (const gchar       *filename,
                     GWin32PrivateStat *buf)
  {
    return _g_win32_stat_utf8 (filename, buf, FALSE);
  }
  
<span class="line-added">+ /* Works like lstat(), but accepts filename in UTF-8</span>
<span class="line-added">+  * and fills our custom stat structure.</span>
<span class="line-added">+  */</span>
  int
  g_win32_lstat_utf8 (const gchar       *filename,
                      GWin32PrivateStat *buf)
  {
    return _g_win32_stat_utf8 (filename, buf, TRUE);
  }
  
<span class="line-added">+ /* Works like fstat(), but accepts filename in UTF-8</span>
<span class="line-added">+  * and fills our custom stat structure.</span>
<span class="line-added">+  */</span>
  int
  g_win32_fstat (int                fd,
                 GWin32PrivateStat *buf)
  {
<span class="line-modified">!   return _g_win32_stat_fd (fd, buf);</span>
  }
  
<span class="line-modified">! /**</span>
<span class="line-modified">!  * g_win32_readlink_utf8:</span>
<span class="line-modified">!  * @filename: (type filename): a pathname in UTF-8</span>
<span class="line-modified">!  * @buf: (array length=buf_size) : a buffer to receive the reparse point</span>
<span class="line-added">+  *                                 target path. Mutually-exclusive</span>
<span class="line-added">+  *                                 with @alloc_buf.</span>
<span class="line-added">+  * @buf_size: size of the @buf, in bytes</span>
<span class="line-added">+  * @alloc_buf: points to a location where internally-allocated buffer</span>
<span class="line-added">+  *             pointer will be written. That buffer receives the</span>
<span class="line-added">+  *             link data. Mutually-exclusive with @buf.</span>
<span class="line-added">+  * @terminate: ensures that the buffer is NUL-terminated if</span>
<span class="line-added">+  *             it isn&#39;t already. If %FALSE, the returned string</span>
<span class="line-added">+  *             might not be NUL-terminated (depends entirely on</span>
<span class="line-added">+  *             what the contents of the filesystem are).</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Tries to read the reparse point indicated by @filename, filling</span>
<span class="line-added">+  * @buf or @alloc_buf with the path that the reparse point redirects to.</span>
<span class="line-added">+  * The path will be UTF-8-encoded, and an extended path prefix</span>
<span class="line-added">+  * or a NT object manager prefix will be removed from it, if</span>
<span class="line-added">+  * possible, but otherwise the path is returned as-is. Specifically,</span>
<span class="line-added">+  * it could be a &quot;\\\\Volume{GUID}\\&quot; path. It also might use</span>
<span class="line-added">+  * backslashes as path separators.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Returns: -1 on error (sets errno), 0 if there&#39;s no (recognizable)</span>
<span class="line-added">+  * path in the reparse point (@alloc_buf will not be allocated in that case,</span>
<span class="line-added">+  * and @buf will be left unmodified),</span>
<span class="line-added">+  * or the number of bytes placed into @buf otherwise,</span>
<span class="line-added">+  * including NUL-terminator (if present or if @terminate is TRUE).</span>
<span class="line-added">+  * The buffer returned via @alloc_buf should be freed with g_free().</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 2.60</span>
<span class="line-added">+  */</span>
<span class="line-added">+ int</span>
<span class="line-added">+ g_win32_readlink_utf8 (const gchar  *filename,</span>
<span class="line-added">+                        gchar        *buf,</span>
<span class="line-added">+                        gsize         buf_size,</span>
<span class="line-added">+                        gchar       **alloc_buf,</span>
<span class="line-added">+                        gboolean      terminate)</span>
  {
<span class="line-modified">!   wchar_t *wfilename;</span>
<span class="line-modified">!   int result;</span>
<span class="line-modified">!   wchar_t *buf_utf16;</span>
<span class="line-modified">!   glong tmp_len;</span>
<span class="line-modified">!   gchar *tmp;</span>
  
<span class="line-modified">!   g_return_val_if_fail ((buf != NULL || alloc_buf != NULL) &amp;&amp;</span>
<span class="line-modified">!                         (buf == NULL || alloc_buf == NULL),</span>
<span class="line-modified">!                         -1);</span>
  
<span class="line-modified">!   wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);</span>
  
<span class="line-modified">!   if (wfilename == NULL)</span>
      {
        errno = EINVAL;
        return -1;
      }
  
<span class="line-modified">!   result = _g_win32_readlink_utf16_handle (wfilename, NULL, NULL,</span>
<span class="line-modified">!                                            NULL, 0, &amp;buf_utf16, terminate);</span>
  
<span class="line-modified">!   g_free (wfilename);</span>
  
    if (result &lt;= 0)
      return result;
  
<span class="line-modified">!   tmp = g_utf16_to_utf8 (buf_utf16,</span>
<span class="line-modified">!                          result / sizeof (gunichar2),</span>
<span class="line-modified">!                          NULL,</span>
<span class="line-modified">!                          &amp;tmp_len,</span>
<span class="line-modified">!                          NULL);</span>
  
<span class="line-modified">!   g_free (buf_utf16);</span>
  
<span class="line-modified">!   if (tmp == NULL)</span>
      {
        errno = EINVAL;
        return -1;
      }
  
<span class="line-modified">!   if (alloc_buf)</span>
      {
<span class="line-modified">!       *alloc_buf = tmp;</span>
<span class="line-modified">!       return tmp_len;</span>
      }
  
<span class="line-modified">!   if (tmp_len &gt; buf_size)</span>
<span class="line-added">+     tmp_len = buf_size;</span>
<span class="line-added">+ </span>
<span class="line-added">+   memcpy (buf, tmp, tmp_len);</span>
<span class="line-added">+   g_free (tmp);</span>
<span class="line-added">+ </span>
<span class="line-added">+   return tmp_len;</span>
  }
  
  #endif
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 654,11 ***</span>
   *
   * Since: 2.8
   */
  int
  g_access (const gchar *filename,
<span class="line-modified">!       int          mode)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
    int retval;
    int save_errno;
<span class="line-new-header">--- 919,11 ---</span>
   *
   * Since: 2.8
   */
  int
  g_access (const gchar *filename,
<span class="line-modified">!     int          mode)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
    int retval;
    int save_errno;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 706,11 ***</span>
   *
   * Since: 2.8
   */
  int
  g_chmod (const gchar *filename,
<span class="line-modified">!      int          mode)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
    int retval;
    int save_errno;
<span class="line-new-header">--- 971,11 ---</span>
   *
   * Since: 2.8
   */
  int
  g_chmod (const gchar *filename,
<span class="line-modified">!    int          mode)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
    int retval;
    int save_errno;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 764,12 ***</span>
   *
   * Since: 2.6
   */
  int
  g_open (const gchar *filename,
<span class="line-modified">!     int          flags,</span>
<span class="line-modified">!     int          mode)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
    int retval;
    int save_errno;
<span class="line-new-header">--- 1029,12 ---</span>
   *
   * Since: 2.6
   */
  int
  g_open (const gchar *filename,
<span class="line-modified">!   int          flags,</span>
<span class="line-modified">!   int          mode)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
    int retval;
    int save_errno;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 828,11 ***</span>
   *
   * Since: 2.8
   */
  int
  g_creat (const gchar *filename,
<span class="line-modified">!      int          mode)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
    int retval;
    int save_errno;
<span class="line-new-header">--- 1093,11 ---</span>
   *
   * Since: 2.8
   */
  int
  g_creat (const gchar *filename,
<span class="line-modified">!    int          mode)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
    int retval;
    int save_errno;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 872,11 ***</span>
   *
   * Since: 2.6
   */
  int
  g_rename (const gchar *oldfilename,
<span class="line-modified">!       const gchar *newfilename)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *woldfilename = g_utf8_to_utf16 (oldfilename, -1, NULL, NULL, NULL);
    wchar_t *wnewfilename;
    int retval;
<span class="line-new-header">--- 1137,11 ---</span>
   *
   * Since: 2.6
   */
  int
  g_rename (const gchar *oldfilename,
<span class="line-modified">!     const gchar *newfilename)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *woldfilename = g_utf8_to_utf16 (oldfilename, -1, NULL, NULL, NULL);
    wchar_t *wnewfilename;
    int retval;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 900,24 ***</span>
    if (MoveFileExW (woldfilename, wnewfilename, MOVEFILE_REPLACE_EXISTING))
      retval = 0;
    else
      {
        retval = -1;
<span class="line-modified">!       switch (GetLastError ())</span>
<span class="line-removed">-     {</span>
<span class="line-removed">- #define CASE(a,b) case ERROR_##a: save_errno = b; break</span>
<span class="line-removed">-       CASE (FILE_NOT_FOUND, ENOENT);</span>
<span class="line-removed">-       CASE (PATH_NOT_FOUND, ENOENT);</span>
<span class="line-removed">-       CASE (ACCESS_DENIED, EACCES);</span>
<span class="line-removed">-       CASE (NOT_SAME_DEVICE, EXDEV);</span>
<span class="line-removed">-       CASE (LOCK_VIOLATION, EACCES);</span>
<span class="line-removed">-       CASE (SHARING_VIOLATION, EACCES);</span>
<span class="line-removed">-       CASE (FILE_EXISTS, EEXIST);</span>
<span class="line-removed">-       CASE (ALREADY_EXISTS, EEXIST);</span>
<span class="line-removed">- #undef CASE</span>
<span class="line-removed">-     default: save_errno = EIO;</span>
<span class="line-removed">-     }</span>
      }
  
    g_free (woldfilename);
    g_free (wnewfilename);
  
<span class="line-new-header">--- 1165,11 ---</span>
    if (MoveFileExW (woldfilename, wnewfilename, MOVEFILE_REPLACE_EXISTING))
      retval = 0;
    else
      {
        retval = -1;
<span class="line-modified">!       save_errno = w32_error_to_errno (GetLastError ());</span>
      }
  
    g_free (woldfilename);
    g_free (wnewfilename);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 945,11 ***</span>
   *
   * Since: 2.6
   */
  int
  g_mkdir (const gchar *filename,
<span class="line-modified">!      int          mode)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
    int retval;
    int save_errno;
<span class="line-new-header">--- 1197,11 ---</span>
   *
   * Since: 2.6
   */
  int
  g_mkdir (const gchar *filename,
<span class="line-modified">!    int          mode)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
    int retval;
    int save_errno;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1053,11 ***</span>
   *
   * Since: 2.6
   */
  int
  g_stat (const gchar *filename,
<span class="line-modified">!     GStatBuf    *buf)</span>
  {
  #ifdef G_OS_WIN32
    GWin32PrivateStat w32_buf;
    int retval = g_win32_stat_utf8 (filename, &amp;w32_buf);
  
<span class="line-new-header">--- 1305,11 ---</span>
   *
   * Since: 2.6
   */
  int
  g_stat (const gchar *filename,
<span class="line-modified">!   GStatBuf    *buf)</span>
  {
  #ifdef G_OS_WIN32
    GWin32PrivateStat w32_buf;
    int retval = g_win32_stat_utf8 (filename, &amp;w32_buf);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1099,11 ***</span>
   *
   * Since: 2.6
   */
  int
  g_lstat (const gchar *filename,
<span class="line-modified">!      GStatBuf    *buf)</span>
  {
  #ifdef HAVE_LSTAT
    /* This can&#39;t be Win32, so don&#39;t do the widechar dance. */
    return lstat (filename, buf);
  #elif defined (G_OS_WIN32)
<span class="line-new-header">--- 1351,11 ---</span>
   *
   * Since: 2.6
   */
  int
  g_lstat (const gchar *filename,
<span class="line-modified">!    GStatBuf    *buf)</span>
  {
  #ifdef HAVE_LSTAT
    /* This can&#39;t be Win32, so don&#39;t do the widechar dance. */
    return lstat (filename, buf);
  #elif defined (G_OS_WIN32)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1293,36 ***</span>
   *
   * Since: 2.6
   */
  FILE *
  g_fopen (const gchar *filename,
<span class="line-modified">!      const gchar *mode)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
    wchar_t *wmode;
<span class="line-removed">-   gchar   *mode2;</span>
    FILE *retval;
    int save_errno;
  
    if (wfilename == NULL)
      {
        errno = EINVAL;
        return NULL;
      }
  
<span class="line-modified">!   mode2 = _g_win32_get_mode_alias (mode);</span>
<span class="line-removed">-   wmode = g_utf8_to_utf16 (mode2, -1, NULL, NULL, NULL);</span>
<span class="line-removed">-   g_free (mode2);</span>
  
    if (wmode == NULL)
      {
        g_free (wfilename);
        errno = EINVAL;
        return NULL;
      }
  
    retval = _wfopen (wfilename, wmode);
    save_errno = errno;
  
    g_free (wfilename);
    g_free (wmode);
<span class="line-new-header">--- 1545,34 ---</span>
   *
   * Since: 2.6
   */
  FILE *
  g_fopen (const gchar *filename,
<span class="line-modified">!    const gchar *mode)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
    wchar_t *wmode;
    FILE *retval;
    int save_errno;
  
    if (wfilename == NULL)
      {
        errno = EINVAL;
        return NULL;
      }
  
<span class="line-modified">!   wmode = g_utf8_to_utf16 (mode, -1, NULL, NULL, NULL);</span>
  
    if (wmode == NULL)
      {
        g_free (wfilename);
        errno = EINVAL;
        return NULL;
      }
  
<span class="line-added">+   _g_win32_fix_mode (wmode);</span>
    retval = _wfopen (wfilename, wmode);
    save_errno = errno;
  
    g_free (wfilename);
    g_free (wmode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1351,37 ***</span>
   *
   * Since: 2.6
   */
  FILE *
  g_freopen (const gchar *filename,
<span class="line-modified">!        const gchar *mode,</span>
<span class="line-modified">!        FILE        *stream)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
    wchar_t *wmode;
<span class="line-removed">-   gchar   *mode2;</span>
    FILE *retval;
    int save_errno;
  
    if (wfilename == NULL)
      {
        errno = EINVAL;
        return NULL;
      }
  
<span class="line-modified">!   mode2 = _g_win32_get_mode_alias (mode);</span>
<span class="line-removed">-   wmode = g_utf8_to_utf16 (mode2, -1, NULL, NULL, NULL);</span>
<span class="line-removed">-   g_free (mode2);</span>
  
    if (wmode == NULL)
      {
        g_free (wfilename);
        errno = EINVAL;
        return NULL;
      }
  
    retval = _wfreopen (wfilename, wmode, stream);
    save_errno = errno;
  
    g_free (wfilename);
    g_free (wmode);
<span class="line-new-header">--- 1601,35 ---</span>
   *
   * Since: 2.6
   */
  FILE *
  g_freopen (const gchar *filename,
<span class="line-modified">!      const gchar *mode,</span>
<span class="line-modified">!      FILE        *stream)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
    wchar_t *wmode;
    FILE *retval;
    int save_errno;
  
    if (wfilename == NULL)
      {
        errno = EINVAL;
        return NULL;
      }
  
<span class="line-modified">!   wmode = g_utf8_to_utf16 (mode, -1, NULL, NULL, NULL);</span>
  
    if (wmode == NULL)
      {
        g_free (wfilename);
        errno = EINVAL;
        return NULL;
      }
  
<span class="line-added">+   _g_win32_fix_mode (wmode);</span>
    retval = _wfreopen (wfilename, wmode, stream);
    save_errno = errno;
  
    g_free (wfilename);
    g_free (wmode);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1409,11 ***</span>
   *
   * Since: 2.18
   */
  int
  g_utime (const gchar    *filename,
<span class="line-modified">!      struct utimbuf *utb)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
    int retval;
    int save_errno;
<span class="line-new-header">--- 1657,11 ---</span>
   *
   * Since: 2.18
   */
  int
  g_utime (const gchar    *filename,
<span class="line-modified">!    struct utimbuf *utb)</span>
  {
  #ifdef G_OS_WIN32
    wchar_t *wfilename = g_utf8_to_utf16 (filename, -1, NULL, NULL, NULL);
    int retval;
    int save_errno;
</pre>
<center><a href="gstdio-private.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstdio.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>