<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gspawn.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* gspawn.c - Process launching
   2  *
   3  *  Copyright 2000 Red Hat, Inc.
   4  *  g_execvpe implementation based on GNU libc execvp:
   5  *   Copyright 1991, 92, 95, 96, 97, 98, 99 Free Software Foundation, Inc.
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Lesser General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2.1 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Lesser General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Lesser General Public License
  18  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  19  */
  20 
  21 #include &quot;config.h&quot;
  22 
  23 #include &lt;sys/time.h&gt;
  24 #include &lt;sys/types.h&gt;
  25 #include &lt;sys/wait.h&gt;
  26 #include &lt;unistd.h&gt;
  27 #include &lt;errno.h&gt;
  28 #include &lt;fcntl.h&gt;
  29 #include &lt;signal.h&gt;
  30 #include &lt;string.h&gt;
  31 #include &lt;stdlib.h&gt;   /* for fdwalk */
  32 #include &lt;dirent.h&gt;
  33 
  34 #ifdef HAVE_SPAWN_H
  35 #include &lt;spawn.h&gt;
  36 #endif /* HAVE_SPAWN_H */
  37 
  38 #ifdef HAVE_CRT_EXTERNS_H
  39 #include &lt;crt_externs.h&gt; /* for _NSGetEnviron */
  40 #endif
  41 
  42 #ifdef HAVE_SYS_SELECT_H
  43 #include &lt;sys/select.h&gt;
  44 #endif /* HAVE_SYS_SELECT_H */
  45 
  46 #ifdef HAVE_SYS_RESOURCE_H
  47 #include &lt;sys/resource.h&gt;
  48 #endif /* HAVE_SYS_RESOURCE_H */
  49 
  50 #ifdef __linux__
  51 #include &lt;sys/syscall.h&gt;  /* for syscall and SYS_getdents64 */
  52 #endif
  53 
  54 #include &quot;gspawn.h&quot;
  55 #include &quot;gspawn-private.h&quot;
  56 #include &quot;gthread.h&quot;
  57 #include &quot;glib/gstdio.h&quot;
  58 
  59 #include &quot;genviron.h&quot;
  60 #include &quot;gmem.h&quot;
  61 #include &quot;gshell.h&quot;
  62 #include &quot;gstring.h&quot;
  63 #include &quot;gstrfuncs.h&quot;
  64 #include &quot;gtestutils.h&quot;
  65 #include &quot;gutils.h&quot;
  66 #include &quot;glibintl.h&quot;
  67 #include &quot;glib-unix.h&quot;
  68 
  69 /* posix_spawn() is assumed the fastest way to spawn, but glibc&#39;s
  70  * implementation was buggy before glibc 2.24, so avoid it on old versions.
  71  */
  72 #ifdef HAVE_POSIX_SPAWN
  73 #ifdef __GLIBC__
  74 
  75 #if __GLIBC_PREREQ(2,24)
  76 #define POSIX_SPAWN_AVAILABLE
  77 #endif
  78 
  79 #else /* !__GLIBC__ */
  80 /* Assume that all non-glibc posix_spawn implementations are fine. */
  81 #define POSIX_SPAWN_AVAILABLE
  82 #endif /* __GLIBC__ */
  83 #endif /* HAVE_POSIX_SPAWN */
  84 
  85 #ifdef HAVE__NSGETENVIRON
  86 #define environ (*_NSGetEnviron())
  87 #else
  88 extern char **environ;
  89 #endif
  90 
  91 #ifndef O_CLOEXEC
  92 #define O_CLOEXEC 0
  93 #else
  94 #define HAVE_O_CLOEXEC 1
  95 #endif
  96 
  97 /**
  98  * SECTION:spawn
  99  * @Short_description: process launching
 100  * @Title: Spawning Processes
 101  *
 102  * GLib supports spawning of processes with an API that is more
 103  * convenient than the bare UNIX fork() and exec().
 104  *
 105  * The g_spawn family of functions has synchronous (g_spawn_sync())
 106  * and asynchronous variants (g_spawn_async(), g_spawn_async_with_pipes()),
 107  * as well as convenience variants that take a complete shell-like
 108  * commandline (g_spawn_command_line_sync(), g_spawn_command_line_async()).
 109  *
 110  * See #GSubprocess in GIO for a higher-level API that provides
 111  * stream interfaces for communication with child processes.
 112  *
 113  * An example of using g_spawn_async_with_pipes():
 114  * |[&lt;!-- language=&quot;C&quot; --&gt;
 115  * const gchar * const argv[] = { &quot;my-favourite-program&quot;, &quot;--args&quot;, NULL };
 116  * gint child_stdout, child_stderr;
 117  * GPid child_pid;
 118  * g_autoptr(GError) error = NULL;
 119  *
 120  * // Spawn child process.
 121  * g_spawn_async_with_pipes (NULL, argv, NULL, G_SPAWN_DO_NOT_REAP_CHILD, NULL,
 122  *                           NULL, &amp;child_pid, NULL, &amp;child_stdout,
 123  *                           &amp;child_stderr, &amp;error);
 124  * if (error != NULL)
 125  *   {
 126  *     g_error (&quot;Spawning child failed: %s&quot;, error-&gt;message);
 127  *     return;
 128  *   }
 129  *
 130  * // Add a child watch function which will be called when the child process
 131  * // exits.
 132  * g_child_watch_add (child_pid, child_watch_cb, NULL);
 133  *
 134  * // You could watch for output on @child_stdout and @child_stderr using
 135  * // #GUnixInputStream or #GIOChannel here.
 136  *
 137  * static void
 138  * child_watch_cb (GPid     pid,
 139  *                 gint     status,
 140  *                 gpointer user_data)
 141  * {
 142  *   g_message (&quot;Child %&quot; G_PID_FORMAT &quot; exited %s&quot;, pid,
 143  *              g_spawn_check_exit_status (status, NULL) ? &quot;normally&quot; : &quot;abnormally&quot;);
 144  *
 145  *   // Free any resources associated with the child here, such as I/O channels
 146  *   // on its stdout and stderr FDs. If you have no code to put in the
 147  *   // child_watch_cb() callback, you can remove it and the g_child_watch_add()
 148  *   // call, but you must also remove the G_SPAWN_DO_NOT_REAP_CHILD flag,
 149  *   // otherwise the child process will stay around as a zombie until this
 150  *   // process exits.
 151  *
 152  *   g_spawn_close_pid (pid);
 153  * }
 154  * ]|
 155  */
 156 
 157 
 158 
 159 static gint g_execute (const gchar  *file,
 160                        gchar **argv,
 161                        gchar **envp,
 162                        gboolean search_path,
 163                        gboolean search_path_from_envp);
 164 
 165 static gboolean fork_exec_with_pipes (gboolean              intermediate_child,
 166                                       const gchar          *working_directory,
 167                                       gchar               **argv,
 168                                       gchar               **envp,
 169                                       gboolean              close_descriptors,
 170                                       gboolean              search_path,
 171                                       gboolean              search_path_from_envp,
 172                                       gboolean              stdout_to_null,
 173                                       gboolean              stderr_to_null,
 174                                       gboolean              child_inherits_stdin,
 175                                       gboolean              file_and_argv_zero,
 176                                       gboolean              cloexec_pipes,
 177                                       GSpawnChildSetupFunc  child_setup,
 178                                       gpointer              user_data,
 179                                       GPid                 *child_pid,
 180                                       gint                 *standard_input,
 181                                       gint                 *standard_output,
 182                                       gint                 *standard_error,
 183                                       GError              **error);
 184 
 185 static gboolean fork_exec_with_fds (gboolean              intermediate_child,
 186                                     const gchar          *working_directory,
 187                                     gchar               **argv,
 188                                     gchar               **envp,
 189                                     gboolean              close_descriptors,
 190                                     gboolean              search_path,
 191                                     gboolean              search_path_from_envp,
 192                                     gboolean              stdout_to_null,
 193                                     gboolean              stderr_to_null,
 194                                     gboolean              child_inherits_stdin,
 195                                     gboolean              file_and_argv_zero,
 196                                     gboolean              cloexec_pipes,
 197                                     GSpawnChildSetupFunc  child_setup,
 198                                     gpointer              user_data,
 199                                     GPid                 *child_pid,
 200                                     gint                 *child_close_fds,
 201                                     gint                  stdin_fd,
 202                                     gint                  stdout_fd,
 203                                     gint                  stderr_fd,
 204                                     GError              **error);
 205 
 206 G_DEFINE_QUARK (g-exec-error-quark, g_spawn_error)
 207 G_DEFINE_QUARK (g-spawn-exit-error-quark, g_spawn_exit_error)
 208 
 209 /**
 210  * g_spawn_async:
 211  * @working_directory: (type filename) (nullable): child&#39;s current working
 212  *     directory, or %NULL to inherit parent&#39;s
 213  * @argv: (array zero-terminated=1) (element-type filename):
 214  *     child&#39;s argument vector
 215  * @envp: (array zero-terminated=1) (element-type filename) (nullable):
 216  *     child&#39;s environment, or %NULL to inherit parent&#39;s
 217  * @flags: flags from #GSpawnFlags
 218  * @child_setup: (scope async) (nullable): function to run in the child just before exec()
 219  * @user_data: (closure): user data for @child_setup
 220  * @child_pid: (out) (optional): return location for child process reference, or %NULL
 221  * @error: return location for error
 222  *
 223  * See g_spawn_async_with_pipes() for a full description; this function
 224  * simply calls the g_spawn_async_with_pipes() without any pipes.
 225  *
 226  * You should call g_spawn_close_pid() on the returned child process
 227  * reference when you don&#39;t need it any more.
 228  *
 229  * If you are writing a GTK+ application, and the program you are spawning is a
 230  * graphical application too, then to ensure that the spawned program opens its
 231  * windows on the right screen, you may want to use #GdkAppLaunchContext,
 232  * #GAppLaunchContext, or set the %DISPLAY environment variable.
 233  *
 234  * Note that the returned @child_pid on Windows is a handle to the child
 235  * process and not its identifier. Process handles and process identifiers
 236  * are different concepts on Windows.
 237  *
 238  * Returns: %TRUE on success, %FALSE if error is set
 239  **/
 240 gboolean
 241 g_spawn_async (const gchar          *working_directory,
 242                gchar               **argv,
 243                gchar               **envp,
 244                GSpawnFlags           flags,
 245                GSpawnChildSetupFunc  child_setup,
 246                gpointer              user_data,
 247                GPid                 *child_pid,
 248                GError              **error)
 249 {
 250   g_return_val_if_fail (argv != NULL, FALSE);
 251 
 252   return g_spawn_async_with_pipes (working_directory,
 253                                    argv, envp,
 254                                    flags,
 255                                    child_setup,
 256                                    user_data,
 257                                    child_pid,
 258                                    NULL, NULL, NULL,
 259                                    error);
 260 }
 261 
 262 /* Avoids a danger in threaded situations (calling close()
 263  * on a file descriptor twice, and another thread has
 264  * re-opened it since the first close)
 265  */
 266 static void
 267 close_and_invalidate (gint *fd)
 268 {
 269   if (*fd &lt; 0)
 270     return;
 271   else
 272     {
 273       (void) g_close (*fd, NULL);
 274       *fd = -1;
 275     }
 276 }
 277 
 278 /* Some versions of OS X define READ_OK in public headers */
 279 #undef READ_OK
 280 
 281 typedef enum
 282 {
 283   READ_FAILED = 0, /* FALSE */
 284   READ_OK,
 285   READ_EOF
 286 } ReadResult;
 287 
 288 static ReadResult
 289 read_data (GString *str,
 290            gint     fd,
 291            GError **error)
 292 {
 293   gssize bytes;
 294   gchar buf[4096];
 295 
 296  again:
 297   bytes = read (fd, buf, 4096);
 298 
 299   if (bytes == 0)
 300     return READ_EOF;
 301   else if (bytes &gt; 0)
 302     {
 303       g_string_append_len (str, buf, bytes);
 304       return READ_OK;
 305     }
 306   else if (errno == EINTR)
 307     goto again;
 308   else
 309     {
 310       int errsv = errno;
 311 
 312       g_set_error (error,
 313                    G_SPAWN_ERROR,
 314                    G_SPAWN_ERROR_READ,
 315                    _(&quot;Failed to read data from child process (%s)&quot;),
 316                    g_strerror (errsv));
 317 
 318       return READ_FAILED;
 319     }
 320 }
 321 
 322 /**
 323  * g_spawn_sync:
 324  * @working_directory: (type filename) (nullable): child&#39;s current working
 325  *     directory, or %NULL to inherit parent&#39;s
 326  * @argv: (array zero-terminated=1) (element-type filename):
 327  *     child&#39;s argument vector
 328  * @envp: (array zero-terminated=1) (element-type filename) (nullable):
 329  *     child&#39;s environment, or %NULL to inherit parent&#39;s
 330  * @flags: flags from #GSpawnFlags
 331  * @child_setup: (scope async) (nullable): function to run in the child just before exec()
 332  * @user_data: (closure): user data for @child_setup
 333  * @standard_output: (out) (array zero-terminated=1) (element-type guint8) (optional): return location for child output, or %NULL
 334  * @standard_error: (out) (array zero-terminated=1) (element-type guint8) (optional): return location for child error messages, or %NULL
 335  * @exit_status: (out) (optional): return location for child exit status, as returned by waitpid(), or %NULL
 336  * @error: return location for error, or %NULL
 337  *
 338  * Executes a child synchronously (waits for the child to exit before returning).
 339  * All output from the child is stored in @standard_output and @standard_error,
 340  * if those parameters are non-%NULL. Note that you must set the
 341  * %G_SPAWN_STDOUT_TO_DEV_NULL and %G_SPAWN_STDERR_TO_DEV_NULL flags when
 342  * passing %NULL for @standard_output and @standard_error.
 343  *
 344  * If @exit_status is non-%NULL, the platform-specific exit status of
 345  * the child is stored there; see the documentation of
 346  * g_spawn_check_exit_status() for how to use and interpret this.
 347  * Note that it is invalid to pass %G_SPAWN_DO_NOT_REAP_CHILD in
 348  * @flags, and on POSIX platforms, the same restrictions as for
 349  * g_child_watch_source_new() apply.
 350  *
 351  * If an error occurs, no data is returned in @standard_output,
 352  * @standard_error, or @exit_status.
 353  *
 354  * This function calls g_spawn_async_with_pipes() internally; see that
 355  * function for full details on the other parameters and details on
 356  * how these functions work on Windows.
 357  *
 358  * Returns: %TRUE on success, %FALSE if an error was set
 359  */
 360 gboolean
 361 g_spawn_sync (const gchar          *working_directory,
 362               gchar               **argv,
 363               gchar               **envp,
 364               GSpawnFlags           flags,
 365               GSpawnChildSetupFunc  child_setup,
 366               gpointer              user_data,
 367               gchar               **standard_output,
 368               gchar               **standard_error,
 369               gint                 *exit_status,
 370               GError              **error)
 371 {
 372   gint outpipe = -1;
 373   gint errpipe = -1;
 374   GPid pid;
 375   fd_set fds;
 376   gint ret;
 377   GString *outstr = NULL;
 378   GString *errstr = NULL;
 379   gboolean failed;
 380   gint status;
 381 
 382   g_return_val_if_fail (argv != NULL, FALSE);
 383   g_return_val_if_fail (!(flags &amp; G_SPAWN_DO_NOT_REAP_CHILD), FALSE);
 384   g_return_val_if_fail (standard_output == NULL ||
 385                         !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
 386   g_return_val_if_fail (standard_error == NULL ||
 387                         !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL), FALSE);
 388 
 389   /* Just to ensure segfaults if callers try to use
 390    * these when an error is reported.
 391    */
 392   if (standard_output)
 393     *standard_output = NULL;
 394 
 395   if (standard_error)
 396     *standard_error = NULL;
 397 
 398   if (!fork_exec_with_pipes (FALSE,
 399                              working_directory,
 400                              argv,
 401                              envp,
 402                              !(flags &amp; G_SPAWN_LEAVE_DESCRIPTORS_OPEN),
 403                              (flags &amp; G_SPAWN_SEARCH_PATH) != 0,
 404                              (flags &amp; G_SPAWN_SEARCH_PATH_FROM_ENVP) != 0,
 405                              (flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL) != 0,
 406                              (flags &amp; G_SPAWN_STDERR_TO_DEV_NULL) != 0,
 407                              (flags &amp; G_SPAWN_CHILD_INHERITS_STDIN) != 0,
 408                              (flags &amp; G_SPAWN_FILE_AND_ARGV_ZERO) != 0,
 409                              (flags &amp; G_SPAWN_CLOEXEC_PIPES) != 0,
 410                              child_setup,
 411                              user_data,
 412                              &amp;pid,
 413                              NULL,
 414                              standard_output ? &amp;outpipe : NULL,
 415                              standard_error ? &amp;errpipe : NULL,
 416                              error))
 417     return FALSE;
 418 
 419   /* Read data from child. */
 420 
 421   failed = FALSE;
 422 
 423   if (outpipe &gt;= 0)
 424     {
 425       outstr = g_string_new (NULL);
 426     }
 427 
 428   if (errpipe &gt;= 0)
 429     {
 430       errstr = g_string_new (NULL);
 431     }
 432 
 433   /* Read data until we get EOF on both pipes. */
 434   while (!failed &amp;&amp;
 435          (outpipe &gt;= 0 ||
 436           errpipe &gt;= 0))
 437     {
 438       ret = 0;
 439 
 440       FD_ZERO (&amp;fds);
 441       if (outpipe &gt;= 0)
 442         FD_SET (outpipe, &amp;fds);
 443       if (errpipe &gt;= 0)
 444         FD_SET (errpipe, &amp;fds);
 445 
 446       ret = select (MAX (outpipe, errpipe) + 1,
 447                     &amp;fds,
 448                     NULL, NULL,
 449                     NULL /* no timeout */);
 450 
 451       if (ret &lt; 0)
 452         {
 453           int errsv = errno;
 454 
<a name="1" id="anc1"></a><span class="line-modified"> 455     if (errno == EINTR)</span>
<span class="line-modified"> 456       continue;</span>
 457 
 458           failed = TRUE;
 459 
 460           g_set_error (error,
 461                        G_SPAWN_ERROR,
 462                        G_SPAWN_ERROR_READ,
 463                        _(&quot;Unexpected error in select() reading data from a child process (%s)&quot;),
 464                        g_strerror (errsv));
 465 
 466           break;
 467         }
 468 
 469       if (outpipe &gt;= 0 &amp;&amp; FD_ISSET (outpipe, &amp;fds))
 470         {
 471           switch (read_data (outstr, outpipe, error))
 472             {
 473             case READ_FAILED:
 474               failed = TRUE;
 475               break;
 476             case READ_EOF:
 477               close_and_invalidate (&amp;outpipe);
 478               outpipe = -1;
 479               break;
 480             default:
 481               break;
 482             }
 483 
 484           if (failed)
 485             break;
 486         }
 487 
 488       if (errpipe &gt;= 0 &amp;&amp; FD_ISSET (errpipe, &amp;fds))
 489         {
 490           switch (read_data (errstr, errpipe, error))
 491             {
 492             case READ_FAILED:
 493               failed = TRUE;
 494               break;
 495             case READ_EOF:
 496               close_and_invalidate (&amp;errpipe);
 497               errpipe = -1;
 498               break;
 499             default:
 500               break;
 501             }
 502 
 503           if (failed)
 504             break;
 505         }
 506     }
 507 
 508   /* These should only be open still if we had an error.  */
 509 
 510   if (outpipe &gt;= 0)
 511     close_and_invalidate (&amp;outpipe);
 512   if (errpipe &gt;= 0)
 513     close_and_invalidate (&amp;errpipe);
 514 
 515   /* Wait for child to exit, even if we have
 516    * an error pending.
 517    */
 518  again:
 519 
 520   ret = waitpid (pid, &amp;status, 0);
 521 
 522   if (ret &lt; 0)
 523     {
 524       if (errno == EINTR)
 525         goto again;
 526       else if (errno == ECHILD)
 527         {
 528           if (exit_status)
 529             {
 530               g_warning (&quot;In call to g_spawn_sync(), exit status of a child process was requested but ECHILD was received by waitpid(). See the documentation of g_child_watch_source_new() for possible causes.&quot;);
 531             }
 532           else
 533             {
 534               /* We don&#39;t need the exit status. */
 535             }
 536         }
 537       else
 538         {
 539           if (!failed) /* avoid error pileups */
 540             {
 541               int errsv = errno;
 542 
 543               failed = TRUE;
 544 
 545               g_set_error (error,
 546                            G_SPAWN_ERROR,
 547                            G_SPAWN_ERROR_READ,
 548                            _(&quot;Unexpected error in waitpid() (%s)&quot;),
 549                            g_strerror (errsv));
 550             }
 551         }
 552     }
 553 
 554   if (failed)
 555     {
 556       if (outstr)
 557         g_string_free (outstr, TRUE);
 558       if (errstr)
 559         g_string_free (errstr, TRUE);
 560 
 561       return FALSE;
 562     }
 563   else
 564     {
 565       if (exit_status)
 566         *exit_status = status;
 567 
 568       if (standard_output)
 569         *standard_output = g_string_free (outstr, FALSE);
 570 
 571       if (standard_error)
 572         *standard_error = g_string_free (errstr, FALSE);
 573 
 574       return TRUE;
 575     }
 576 }
 577 
 578 /**
 579  * g_spawn_async_with_pipes:
 580  * @working_directory: (type filename) (nullable): child&#39;s current working
 581  *     directory, or %NULL to inherit parent&#39;s, in the GLib file name encoding
 582  * @argv: (array zero-terminated=1) (element-type filename): child&#39;s argument
 583  *     vector, in the GLib file name encoding
 584  * @envp: (array zero-terminated=1) (element-type filename) (nullable):
 585  *     child&#39;s environment, or %NULL to inherit parent&#39;s, in the GLib file
 586  *     name encoding
 587  * @flags: flags from #GSpawnFlags
 588  * @child_setup: (scope async) (nullable): function to run in the child just before exec()
 589  * @user_data: (closure): user data for @child_setup
 590  * @child_pid: (out) (optional): return location for child process ID, or %NULL
 591  * @standard_input: (out) (optional): return location for file descriptor to write to child&#39;s stdin, or %NULL
 592  * @standard_output: (out) (optional): return location for file descriptor to read child&#39;s stdout, or %NULL
 593  * @standard_error: (out) (optional): return location for file descriptor to read child&#39;s stderr, or %NULL
 594  * @error: return location for error
 595  *
 596  * Executes a child program asynchronously (your program will not
 597  * block waiting for the child to exit). The child program is
 598  * specified by the only argument that must be provided, @argv.
 599  * @argv should be a %NULL-terminated array of strings, to be passed
 600  * as the argument vector for the child. The first string in @argv
 601  * is of course the name of the program to execute. By default, the
 602  * name of the program must be a full path. If @flags contains the
 603  * %G_SPAWN_SEARCH_PATH flag, the `PATH` environment variable is
 604  * used to search for the executable. If @flags contains the
 605  * %G_SPAWN_SEARCH_PATH_FROM_ENVP flag, the `PATH` variable from
 606  * @envp is used to search for the executable. If both the
 607  * %G_SPAWN_SEARCH_PATH and %G_SPAWN_SEARCH_PATH_FROM_ENVP flags
 608  * are set, the `PATH` variable from @envp takes precedence over
 609  * the environment variable.
 610  *
 611  * If the program name is not a full path and %G_SPAWN_SEARCH_PATH flag is not
 612  * used, then the program will be run from the current directory (or
 613  * @working_directory, if specified); this might be unexpected or even
 614  * dangerous in some cases when the current directory is world-writable.
 615  *
 616  * On Windows, note that all the string or string vector arguments to
 617  * this function and the other g_spawn*() functions are in UTF-8, the
 618  * GLib file name encoding. Unicode characters that are not part of
 619  * the system codepage passed in these arguments will be correctly
 620  * available in the spawned program only if it uses wide character API
 621  * to retrieve its command line. For C programs built with Microsoft&#39;s
 622  * tools it is enough to make the program have a wmain() instead of
 623  * main(). wmain() has a wide character argument vector as parameter.
 624  *
 625  * At least currently, mingw doesn&#39;t support wmain(), so if you use
 626  * mingw to develop the spawned program, it should call
 627  * g_win32_get_command_line() to get arguments in UTF-8.
 628  *
 629  * On Windows the low-level child process creation API CreateProcess()
 630  * doesn&#39;t use argument vectors, but a command line. The C runtime
 631  * library&#39;s spawn*() family of functions (which g_spawn_async_with_pipes()
 632  * eventually calls) paste the argument vector elements together into
 633  * a command line, and the C runtime startup code does a corresponding
 634  * reconstruction of an argument vector from the command line, to be
 635  * passed to main(). Complications arise when you have argument vector
<a name="2" id="anc2"></a><span class="line-modified"> 636  * elements that contain spaces or double quotes. The `spawn*()` functions</span>
 637  * don&#39;t do any quoting or escaping, but on the other hand the startup
 638  * code does do unquoting and unescaping in order to enable receiving
 639  * arguments with embedded spaces or double quotes. To work around this
 640  * asymmetry, g_spawn_async_with_pipes() will do quoting and escaping on
 641  * argument vector elements that need it before calling the C runtime
 642  * spawn() function.
 643  *
 644  * The returned @child_pid on Windows is a handle to the child
 645  * process, not its identifier. Process handles and process
 646  * identifiers are different concepts on Windows.
 647  *
 648  * @envp is a %NULL-terminated array of strings, where each string
 649  * has the form `KEY=VALUE`. This will become the child&#39;s environment.
 650  * If @envp is %NULL, the child inherits its parent&#39;s environment.
 651  *
 652  * @flags should be the bitwise OR of any flags you want to affect the
 653  * function&#39;s behaviour. The %G_SPAWN_DO_NOT_REAP_CHILD means that the
 654  * child will not automatically be reaped; you must use a child watch
 655  * (g_child_watch_add()) to be notified about the death of the child process,
 656  * otherwise it will stay around as a zombie process until this process exits.
 657  * Eventually you must call g_spawn_close_pid() on the @child_pid, in order to
 658  * free resources which may be associated with the child process. (On Unix,
 659  * using a child watch is equivalent to calling waitpid() or handling
 660  * the %SIGCHLD signal manually. On Windows, calling g_spawn_close_pid()
 661  * is equivalent to calling CloseHandle() on the process handle returned
 662  * in @child_pid). See g_child_watch_add().
 663  *
 664  * Open UNIX file descriptors marked as `FD_CLOEXEC` will be automatically
 665  * closed in the child process. %G_SPAWN_LEAVE_DESCRIPTORS_OPEN means that
 666  * other open file descriptors will be inherited by the child; otherwise all
 667  * descriptors except stdin/stdout/stderr will be closed before calling exec()
 668  * in the child. %G_SPAWN_SEARCH_PATH means that @argv[0] need not be an
 669  * absolute path, it will be looked for in the `PATH` environment
 670  * variable. %G_SPAWN_SEARCH_PATH_FROM_ENVP means need not be an
 671  * absolute path, it will be looked for in the `PATH` variable from
 672  * @envp. If both %G_SPAWN_SEARCH_PATH and %G_SPAWN_SEARCH_PATH_FROM_ENVP
 673  * are used, the value from @envp takes precedence over the environment.
 674  * %G_SPAWN_STDOUT_TO_DEV_NULL means that the child&#39;s standard output
 675  * will be discarded, instead of going to the same location as the parent&#39;s
 676  * standard output. If you use this flag, @standard_output must be %NULL.
 677  * %G_SPAWN_STDERR_TO_DEV_NULL means that the child&#39;s standard error
 678  * will be discarded, instead of going to the same location as the parent&#39;s
 679  * standard error. If you use this flag, @standard_error must be %NULL.
 680  * %G_SPAWN_CHILD_INHERITS_STDIN means that the child will inherit the parent&#39;s
 681  * standard input (by default, the child&#39;s standard input is attached to
 682  * `/dev/null`). If you use this flag, @standard_input must be %NULL.
 683  * %G_SPAWN_FILE_AND_ARGV_ZERO means that the first element of @argv is
 684  * the file to execute, while the remaining elements are the actual
 685  * argument vector to pass to the file. Normally g_spawn_async_with_pipes()
 686  * uses @argv[0] as the file to execute, and passes all of @argv to the child.
 687  *
 688  * @child_setup and @user_data are a function and user data. On POSIX
 689  * platforms, the function is called in the child after GLib has
 690  * performed all the setup it plans to perform (including creating
 691  * pipes, closing file descriptors, etc.) but before calling exec().
 692  * That is, @child_setup is called just before calling exec() in the
 693  * child. Obviously actions taken in this function will only affect
 694  * the child, not the parent.
 695  *
 696  * On Windows, there is no separate fork() and exec() functionality.
 697  * Child processes are created and run with a single API call,
 698  * CreateProcess(). There is no sensible thing @child_setup
 699  * could be used for on Windows so it is ignored and not called.
 700  *
 701  * If non-%NULL, @child_pid will on Unix be filled with the child&#39;s
 702  * process ID. You can use the process ID to send signals to the child,
 703  * or to use g_child_watch_add() (or waitpid()) if you specified the
 704  * %G_SPAWN_DO_NOT_REAP_CHILD flag. On Windows, @child_pid will be
 705  * filled with a handle to the child process only if you specified the
 706  * %G_SPAWN_DO_NOT_REAP_CHILD flag. You can then access the child
 707  * process using the Win32 API, for example wait for its termination
 708  * with the WaitFor*() functions, or examine its exit code with
 709  * GetExitCodeProcess(). You should close the handle with CloseHandle()
 710  * or g_spawn_close_pid() when you no longer need it.
 711  *
 712  * If non-%NULL, the @standard_input, @standard_output, @standard_error
 713  * locations will be filled with file descriptors for writing to the child&#39;s
 714  * standard input or reading from its standard output or standard error.
 715  * The caller of g_spawn_async_with_pipes() must close these file descriptors
 716  * when they are no longer in use. If these parameters are %NULL, the
 717  * corresponding pipe won&#39;t be created.
 718  *
 719  * If @standard_input is %NULL, the child&#39;s standard input is attached to
 720  * `/dev/null` unless %G_SPAWN_CHILD_INHERITS_STDIN is set.
 721  *
 722  * If @standard_error is NULL, the child&#39;s standard error goes to the same
 723  * location as the parent&#39;s standard error unless %G_SPAWN_STDERR_TO_DEV_NULL
 724  * is set.
 725  *
 726  * If @standard_output is NULL, the child&#39;s standard output goes to the same
 727  * location as the parent&#39;s standard output unless %G_SPAWN_STDOUT_TO_DEV_NULL
 728  * is set.
 729  *
 730  * @error can be %NULL to ignore errors, or non-%NULL to report errors.
 731  * If an error is set, the function returns %FALSE. Errors are reported
 732  * even if they occur in the child (for example if the executable in
 733  * @argv[0] is not found). Typically the `message` field of returned
 734  * errors should be displayed to users. Possible errors are those from
 735  * the #G_SPAWN_ERROR domain.
 736  *
 737  * If an error occurs, @child_pid, @standard_input, @standard_output,
 738  * and @standard_error will not be filled with valid values.
 739  *
 740  * If @child_pid is not %NULL and an error does not occur then the returned
 741  * process reference must be closed using g_spawn_close_pid().
 742  *
 743  * On modern UNIX platforms, GLib can use an efficient process launching
 744  * codepath driven internally by posix_spawn(). This has the advantage of
 745  * avoiding the fork-time performance costs of cloning the parent process
 746  * address space, and avoiding associated memory overcommit checks that are
 747  * not relevant in the context of immediately executing a distinct process.
 748  * This optimized codepath will be used provided that the following conditions
 749  * are met:
 750  *
 751  * 1. %G_SPAWN_DO_NOT_REAP_CHILD is set
 752  * 2. %G_SPAWN_LEAVE_DESCRIPTORS_OPEN is set
 753  * 3. %G_SPAWN_SEARCH_PATH_FROM_ENVP is not set
 754  * 4. @working_directory is %NULL
 755  * 5. @child_setup is %NULL
 756  * 6. The program is of a recognised binary format, or has a shebang. Otherwise, GLib will have to execute the program through the shell, which is not done using the optimized codepath.
 757  *
 758  * If you are writing a GTK+ application, and the program you are spawning is a
 759  * graphical application too, then to ensure that the spawned program opens its
 760  * windows on the right screen, you may want to use #GdkAppLaunchContext,
 761  * #GAppLaunchContext, or set the %DISPLAY environment variable.
 762  *
 763  * Returns: %TRUE on success, %FALSE if an error was set
 764  */
 765 gboolean
 766 g_spawn_async_with_pipes (const gchar          *working_directory,
 767                           gchar               **argv,
 768                           gchar               **envp,
 769                           GSpawnFlags           flags,
 770                           GSpawnChildSetupFunc  child_setup,
 771                           gpointer              user_data,
 772                           GPid                 *child_pid,
 773                           gint                 *standard_input,
 774                           gint                 *standard_output,
 775                           gint                 *standard_error,
 776                           GError              **error)
 777 {
 778   g_return_val_if_fail (argv != NULL, FALSE);
 779   g_return_val_if_fail (standard_output == NULL ||
 780                         !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
 781   g_return_val_if_fail (standard_error == NULL ||
 782                         !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL), FALSE);
 783   /* can&#39;t inherit stdin if we have an input pipe. */
 784   g_return_val_if_fail (standard_input == NULL ||
 785                         !(flags &amp; G_SPAWN_CHILD_INHERITS_STDIN), FALSE);
 786 
 787   return fork_exec_with_pipes (!(flags &amp; G_SPAWN_DO_NOT_REAP_CHILD),
 788                                working_directory,
 789                                argv,
 790                                envp,
 791                                !(flags &amp; G_SPAWN_LEAVE_DESCRIPTORS_OPEN),
 792                                (flags &amp; G_SPAWN_SEARCH_PATH) != 0,
 793                                (flags &amp; G_SPAWN_SEARCH_PATH_FROM_ENVP) != 0,
 794                                (flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL) != 0,
 795                                (flags &amp; G_SPAWN_STDERR_TO_DEV_NULL) != 0,
 796                                (flags &amp; G_SPAWN_CHILD_INHERITS_STDIN) != 0,
 797                                (flags &amp; G_SPAWN_FILE_AND_ARGV_ZERO) != 0,
 798                                (flags &amp; G_SPAWN_CLOEXEC_PIPES) != 0,
 799                                child_setup,
 800                                user_data,
 801                                child_pid,
 802                                standard_input,
 803                                standard_output,
 804                                standard_error,
 805                                error);
 806 }
 807 
 808 /**
 809  * g_spawn_async_with_fds:
 810  * @working_directory: (type filename) (nullable): child&#39;s current working directory, or %NULL to inherit parent&#39;s, in the GLib file name encoding
 811  * @argv: (array zero-terminated=1): child&#39;s argument vector, in the GLib file name encoding
 812  * @envp: (array zero-terminated=1) (nullable): child&#39;s environment, or %NULL to inherit parent&#39;s, in the GLib file name encoding
 813  * @flags: flags from #GSpawnFlags
 814  * @child_setup: (scope async) (nullable): function to run in the child just before exec()
 815  * @user_data: (closure): user data for @child_setup
 816  * @child_pid: (out) (optional): return location for child process ID, or %NULL
 817  * @stdin_fd: file descriptor to use for child&#39;s stdin, or -1
 818  * @stdout_fd: file descriptor to use for child&#39;s stdout, or -1
 819  * @stderr_fd: file descriptor to use for child&#39;s stderr, or -1
 820  * @error: return location for error
 821  *
 822  * Identical to g_spawn_async_with_pipes() but instead of
 823  * creating pipes for the stdin/stdout/stderr, you can pass existing
 824  * file descriptors into this function through the @stdin_fd,
 825  * @stdout_fd and @stderr_fd parameters. The following @flags
 826  * also have their behaviour slightly tweaked as a result:
 827  *
 828  * %G_SPAWN_STDOUT_TO_DEV_NULL means that the child&#39;s standard output
 829  * will be discarded, instead of going to the same location as the parent&#39;s
 830  * standard output. If you use this flag, @standard_output must be -1.
 831  * %G_SPAWN_STDERR_TO_DEV_NULL means that the child&#39;s standard error
 832  * will be discarded, instead of going to the same location as the parent&#39;s
 833  * standard error. If you use this flag, @standard_error must be -1.
 834  * %G_SPAWN_CHILD_INHERITS_STDIN means that the child will inherit the parent&#39;s
 835  * standard input (by default, the child&#39;s standard input is attached to
 836  * /dev/null). If you use this flag, @standard_input must be -1.
 837  *
 838  * It is valid to pass the same fd in multiple parameters (e.g. you can pass
 839  * a single fd for both stdout and stderr).
 840  *
 841  * Returns: %TRUE on success, %FALSE if an error was set
 842  *
 843  * Since: 2.58
 844  */
 845 gboolean
 846 g_spawn_async_with_fds (const gchar          *working_directory,
 847                         gchar               **argv,
 848                         gchar               **envp,
 849                         GSpawnFlags           flags,
 850                         GSpawnChildSetupFunc  child_setup,
 851                         gpointer              user_data,
 852                         GPid                 *child_pid,
 853                         gint                  stdin_fd,
 854                         gint                  stdout_fd,
 855                         gint                  stderr_fd,
 856                         GError              **error)
 857 {
 858   g_return_val_if_fail (argv != NULL, FALSE);
 859   g_return_val_if_fail (stdout_fd &lt; 0 ||
 860                         !(flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL), FALSE);
 861   g_return_val_if_fail (stderr_fd &lt; 0 ||
 862                         !(flags &amp; G_SPAWN_STDERR_TO_DEV_NULL), FALSE);
 863   /* can&#39;t inherit stdin if we have an input pipe. */
 864   g_return_val_if_fail (stdin_fd &lt; 0 ||
 865                         !(flags &amp; G_SPAWN_CHILD_INHERITS_STDIN), FALSE);
 866 
 867   return fork_exec_with_fds (!(flags &amp; G_SPAWN_DO_NOT_REAP_CHILD),
 868                                working_directory,
 869                                argv,
 870                                envp,
 871                                !(flags &amp; G_SPAWN_LEAVE_DESCRIPTORS_OPEN),
 872                                (flags &amp; G_SPAWN_SEARCH_PATH) != 0,
 873                                (flags &amp; G_SPAWN_SEARCH_PATH_FROM_ENVP) != 0,
 874                                (flags &amp; G_SPAWN_STDOUT_TO_DEV_NULL) != 0,
 875                                (flags &amp; G_SPAWN_STDERR_TO_DEV_NULL) != 0,
 876                                (flags &amp; G_SPAWN_CHILD_INHERITS_STDIN) != 0,
 877                                (flags &amp; G_SPAWN_FILE_AND_ARGV_ZERO) != 0,
 878                                (flags &amp; G_SPAWN_CLOEXEC_PIPES) != 0,
 879                                child_setup,
 880                                user_data,
 881                                child_pid,
 882                                NULL,
 883                                stdin_fd,
 884                                stdout_fd,
 885                                stderr_fd,
 886                                error);
 887 }
 888 
 889 /**
 890  * g_spawn_command_line_sync:
 891  * @command_line: (type filename): a command line
 892  * @standard_output: (out) (array zero-terminated=1) (element-type guint8) (optional): return location for child output
 893  * @standard_error: (out) (array zero-terminated=1) (element-type guint8) (optional): return location for child errors
 894  * @exit_status: (out) (optional): return location for child exit status, as returned by waitpid()
 895  * @error: return location for errors
 896  *
 897  * A simple version of g_spawn_sync() with little-used parameters
 898  * removed, taking a command line instead of an argument vector.  See
 899  * g_spawn_sync() for full details. @command_line will be parsed by
 900  * g_shell_parse_argv(). Unlike g_spawn_sync(), the %G_SPAWN_SEARCH_PATH flag
 901  * is enabled. Note that %G_SPAWN_SEARCH_PATH can have security
 902  * implications, so consider using g_spawn_sync() directly if
 903  * appropriate. Possible errors are those from g_spawn_sync() and those
 904  * from g_shell_parse_argv().
 905  *
 906  * If @exit_status is non-%NULL, the platform-specific exit status of
 907  * the child is stored there; see the documentation of
 908  * g_spawn_check_exit_status() for how to use and interpret this.
 909  *
 910  * On Windows, please note the implications of g_shell_parse_argv()
 911  * parsing @command_line. Parsing is done according to Unix shell rules, not
 912  * Windows command interpreter rules.
 913  * Space is a separator, and backslashes are
 914  * special. Thus you cannot simply pass a @command_line containing
 915  * canonical Windows paths, like &quot;c:\\program files\\app\\app.exe&quot;, as
 916  * the backslashes will be eaten, and the space will act as a
 917  * separator. You need to enclose such paths with single quotes, like
 918  * &quot;&#39;c:\\program files\\app\\app.exe&#39; &#39;e:\\folder\\argument.txt&#39;&quot;.
 919  *
 920  * Returns: %TRUE on success, %FALSE if an error was set
 921  **/
 922 gboolean
 923 g_spawn_command_line_sync (const gchar  *command_line,
 924                            gchar       **standard_output,
 925                            gchar       **standard_error,
 926                            gint         *exit_status,
 927                            GError      **error)
 928 {
 929   gboolean retval;
 930   gchar **argv = NULL;
 931 
 932   g_return_val_if_fail (command_line != NULL, FALSE);
 933 
 934   if (!g_shell_parse_argv (command_line,
 935                            NULL, &amp;argv,
 936                            error))
 937     return FALSE;
 938 
 939   retval = g_spawn_sync (NULL,
 940                          argv,
 941                          NULL,
 942                          G_SPAWN_SEARCH_PATH,
 943                          NULL,
 944                          NULL,
 945                          standard_output,
 946                          standard_error,
 947                          exit_status,
 948                          error);
 949   g_strfreev (argv);
 950 
 951   return retval;
 952 }
 953 
 954 /**
 955  * g_spawn_command_line_async:
 956  * @command_line: (type filename): a command line
 957  * @error: return location for errors
 958  *
 959  * A simple version of g_spawn_async() that parses a command line with
 960  * g_shell_parse_argv() and passes it to g_spawn_async(). Runs a
 961  * command line in the background. Unlike g_spawn_async(), the
 962  * %G_SPAWN_SEARCH_PATH flag is enabled, other flags are not. Note
 963  * that %G_SPAWN_SEARCH_PATH can have security implications, so
 964  * consider using g_spawn_async() directly if appropriate. Possible
 965  * errors are those from g_shell_parse_argv() and g_spawn_async().
 966  *
 967  * The same concerns on Windows apply as for g_spawn_command_line_sync().
 968  *
 969  * Returns: %TRUE on success, %FALSE if error is set
 970  **/
 971 gboolean
 972 g_spawn_command_line_async (const gchar *command_line,
 973                             GError     **error)
 974 {
 975   gboolean retval;
 976   gchar **argv = NULL;
 977 
 978   g_return_val_if_fail (command_line != NULL, FALSE);
 979 
 980   if (!g_shell_parse_argv (command_line,
 981                            NULL, &amp;argv,
 982                            error))
 983     return FALSE;
 984 
 985   retval = g_spawn_async (NULL,
 986                           argv,
 987                           NULL,
 988                           G_SPAWN_SEARCH_PATH,
 989                           NULL,
 990                           NULL,
 991                           NULL,
 992                           error);
 993   g_strfreev (argv);
 994 
 995   return retval;
 996 }
 997 
 998 /**
 999  * g_spawn_check_exit_status:
1000  * @exit_status: An exit code as returned from g_spawn_sync()
1001  * @error: a #GError
1002  *
1003  * Set @error if @exit_status indicates the child exited abnormally
1004  * (e.g. with a nonzero exit code, or via a fatal signal).
1005  *
1006  * The g_spawn_sync() and g_child_watch_add() family of APIs return an
1007  * exit status for subprocesses encoded in a platform-specific way.
1008  * On Unix, this is guaranteed to be in the same format waitpid() returns,
1009  * and on Windows it is guaranteed to be the result of GetExitCodeProcess().
1010  *
1011  * Prior to the introduction of this function in GLib 2.34, interpreting
1012  * @exit_status required use of platform-specific APIs, which is problematic
1013  * for software using GLib as a cross-platform layer.
1014  *
1015  * Additionally, many programs simply want to determine whether or not
1016  * the child exited successfully, and either propagate a #GError or
1017  * print a message to standard error. In that common case, this function
1018  * can be used. Note that the error message in @error will contain
1019  * human-readable information about the exit status.
1020  *
1021  * The @domain and @code of @error have special semantics in the case
1022  * where the process has an &quot;exit code&quot;, as opposed to being killed by
1023  * a signal. On Unix, this happens if WIFEXITED() would be true of
1024  * @exit_status. On Windows, it is always the case.
1025  *
1026  * The special semantics are that the actual exit code will be the
1027  * code set in @error, and the domain will be %G_SPAWN_EXIT_ERROR.
1028  * This allows you to differentiate between different exit codes.
1029  *
1030  * If the process was terminated by some means other than an exit
1031  * status, the domain will be %G_SPAWN_ERROR, and the code will be
1032  * %G_SPAWN_ERROR_FAILED.
1033  *
1034  * This function just offers convenience; you can of course also check
1035  * the available platform via a macro such as %G_OS_UNIX, and use
1036  * WIFEXITED() and WEXITSTATUS() on @exit_status directly. Do not attempt
1037  * to scan or parse the error message string; it may be translated and/or
1038  * change in future versions of GLib.
1039  *
1040  * Returns: %TRUE if child exited successfully, %FALSE otherwise (and
1041  *     @error will be set)
1042  *
1043  * Since: 2.34
1044  */
1045 gboolean
1046 g_spawn_check_exit_status (gint      exit_status,
<a name="3" id="anc3"></a><span class="line-modified">1047          GError  **error)</span>
1048 {
1049   gboolean ret = FALSE;
1050 
1051   if (WIFEXITED (exit_status))
1052     {
1053       if (WEXITSTATUS (exit_status) != 0)
<a name="4" id="anc4"></a><span class="line-modified">1054   {</span>
<span class="line-modified">1055     g_set_error (error, G_SPAWN_EXIT_ERROR, WEXITSTATUS (exit_status),</span>
<span class="line-modified">1056            _(&quot;Child process exited with code %ld&quot;),</span>
<span class="line-modified">1057            (long) WEXITSTATUS (exit_status));</span>
<span class="line-modified">1058     goto out;</span>
<span class="line-modified">1059   }</span>
1060     }
1061   else if (WIFSIGNALED (exit_status))
1062     {
1063       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<a name="5" id="anc5"></a><span class="line-modified">1064        _(&quot;Child process killed by signal %ld&quot;),</span>
<span class="line-modified">1065        (long) WTERMSIG (exit_status));</span>
1066       goto out;
1067     }
1068   else if (WIFSTOPPED (exit_status))
1069     {
1070       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<a name="6" id="anc6"></a><span class="line-modified">1071        _(&quot;Child process stopped by signal %ld&quot;),</span>
<span class="line-modified">1072        (long) WSTOPSIG (exit_status));</span>
1073       goto out;
1074     }
1075   else
1076     {
1077       g_set_error (error, G_SPAWN_ERROR, G_SPAWN_ERROR_FAILED,
<a name="7" id="anc7"></a><span class="line-modified">1078        _(&quot;Child process exited abnormally&quot;));</span>
1079       goto out;
1080     }
1081 
1082   ret = TRUE;
1083  out:
1084   return ret;
1085 }
1086 
1087 static gssize
1088 write_all (gint fd, gconstpointer vbuf, gsize to_write)
1089 {
1090   gchar *buf = (gchar *) vbuf;
1091 
1092   while (to_write &gt; 0)
1093     {
1094       gssize count = write (fd, buf, to_write);
1095       if (count &lt; 0)
1096         {
1097           if (errno != EINTR)
1098             return FALSE;
1099         }
1100       else
1101         {
1102           to_write -= count;
1103           buf += count;
1104         }
1105     }
1106 
1107   return TRUE;
1108 }
1109 
1110 G_GNUC_NORETURN
1111 static void
1112 write_err_and_exit (gint fd, gint msg)
1113 {
1114   gint en = errno;
1115 
1116   write_all (fd, &amp;msg, sizeof(msg));
1117   write_all (fd, &amp;en, sizeof(en));
1118 
1119   _exit (1);
1120 }
1121 
1122 static int
1123 set_cloexec (void *data, gint fd)
1124 {
1125   if (fd &gt;= GPOINTER_TO_INT (data))
1126     fcntl (fd, F_SETFD, FD_CLOEXEC);
1127 
1128   return 0;
1129 }
1130 
1131 #ifndef HAVE_FDWALK
1132 #ifdef __linux__
1133 struct linux_dirent64
1134 {
1135   guint64        d_ino;    /* 64-bit inode number */
1136   guint64        d_off;    /* 64-bit offset to next structure */
1137   unsigned short d_reclen; /* Size of this dirent */
1138   unsigned char  d_type;   /* File type */
1139   char           d_name[]; /* Filename (null-terminated) */
1140 };
1141 
1142 static gint
1143 filename_to_fd (const char *p)
1144 {
1145   char c;
1146   int fd = 0;
1147   const int cutoff = G_MAXINT / 10;
1148   const int cutlim = G_MAXINT % 10;
1149 
1150   if (*p == &#39;\0&#39;)
1151     return -1;
1152 
1153   while ((c = *p++) != &#39;\0&#39;)
1154     {
1155       if (!g_ascii_isdigit (c))
1156         return -1;
1157       c -= &#39;0&#39;;
1158 
1159       /* Check for overflow. */
1160       if (fd &gt; cutoff || (fd == cutoff &amp;&amp; c &gt; cutlim))
1161         return -1;
1162 
1163       fd = fd * 10 + c;
1164     }
1165 
1166   return fd;
1167 }
1168 #endif
1169 
1170 static int
1171 fdwalk (int (*cb)(void *data, int fd), void *data)
1172 {
1173   gint open_max;
1174   gint fd;
1175   gint res = 0;
1176 
1177 #ifdef HAVE_SYS_RESOURCE_H
1178   struct rlimit rl;
1179 #endif
1180 
1181 #ifdef __linux__
1182   /* Avoid use of opendir/closedir since these are not async-signal-safe. */
1183   int dir_fd = open (&quot;/proc/self/fd&quot;, O_RDONLY | O_DIRECTORY);
1184   if (dir_fd &gt;= 0)
1185     {
1186       char buf[4096];
1187       int pos, nread;
1188       struct linux_dirent64 *de;
1189 
1190       while ((nread = syscall (SYS_getdents64, dir_fd, buf, sizeof(buf))) &gt; 0)
1191         {
1192           for (pos = 0; pos &lt; nread; pos += de-&gt;d_reclen)
1193             {
1194               de = (struct linux_dirent64 *)(buf + pos);
1195 
1196               fd = filename_to_fd (de-&gt;d_name);
1197               if (fd &lt; 0 || fd == dir_fd)
<a name="8" id="anc8"></a><span class="line-modified">1198                   continue;</span>
1199 
<a name="9" id="anc9"></a><span class="line-modified">1200               if ((res = cb (data, fd)) != 0)</span>
<span class="line-modified">1201                   break;</span>
<span class="line-modified">1202             }</span>
1203         }
1204 
1205       close (dir_fd);
1206       return res;
<a name="10" id="anc10"></a><span class="line-modified">1207     }</span>
1208 
1209   /* If /proc is not mounted or not accessible we fall back to the old
1210    * rlimit trick */
1211 
1212 #endif
1213 
1214 #ifdef HAVE_SYS_RESOURCE_H
1215 
1216   if (getrlimit(RLIMIT_NOFILE, &amp;rl) == 0 &amp;&amp; rl.rlim_max != RLIM_INFINITY)
1217       open_max = rl.rlim_max;
1218   else
1219 #endif
1220       open_max = sysconf (_SC_OPEN_MAX);
1221 
1222   for (fd = 0; fd &lt; open_max; fd++)
1223       if ((res = cb (data, fd)) != 0)
1224           break;
1225 
1226   return res;
1227 }
1228 #endif
1229 
1230 static gint
1231 sane_dup2 (gint fd1, gint fd2)
1232 {
1233   gint ret;
1234 
1235  retry:
1236   ret = dup2 (fd1, fd2);
1237   if (ret &lt; 0 &amp;&amp; errno == EINTR)
1238     goto retry;
1239 
1240   return ret;
1241 }
1242 
1243 static gint
1244 sane_open (const char *path, gint mode)
1245 {
1246   gint ret;
1247 
1248  retry:
1249   ret = open (path, mode);
1250   if (ret &lt; 0 &amp;&amp; errno == EINTR)
1251     goto retry;
1252 
1253   return ret;
1254 }
1255 
1256 enum
1257 {
1258   CHILD_CHDIR_FAILED,
1259   CHILD_EXEC_FAILED,
1260   CHILD_DUP2_FAILED,
1261   CHILD_FORK_FAILED
1262 };
1263 
1264 static void
1265 do_exec (gint                  child_err_report_fd,
1266          gint                  stdin_fd,
1267          gint                  stdout_fd,
1268          gint                  stderr_fd,
1269          const gchar          *working_directory,
1270          gchar               **argv,
1271          gchar               **envp,
1272          gboolean              close_descriptors,
1273          gboolean              search_path,
1274          gboolean              search_path_from_envp,
1275          gboolean              stdout_to_null,
1276          gboolean              stderr_to_null,
1277          gboolean              child_inherits_stdin,
1278          gboolean              file_and_argv_zero,
1279          GSpawnChildSetupFunc  child_setup,
1280          gpointer              user_data)
1281 {
1282   if (working_directory &amp;&amp; chdir (working_directory) &lt; 0)
1283     write_err_and_exit (child_err_report_fd,
1284                         CHILD_CHDIR_FAILED);
1285 
1286   /* Close all file descriptors but stdin stdout and stderr as
1287    * soon as we exec. Note that this includes
1288    * child_err_report_fd, which keeps the parent from blocking
1289    * forever on the other end of that pipe.
1290    */
1291   if (close_descriptors)
1292     {
1293       fdwalk (set_cloexec, GINT_TO_POINTER(3));
1294     }
1295   else
1296     {
1297       /* We need to do child_err_report_fd anyway */
1298       set_cloexec (GINT_TO_POINTER(0), child_err_report_fd);
1299     }
1300 
1301   /* Redirect pipes as required */
1302 
1303   if (stdin_fd &gt;= 0)
1304     {
1305       /* dup2 can&#39;t actually fail here I don&#39;t think */
1306 
1307       if (sane_dup2 (stdin_fd, 0) &lt; 0)
1308         write_err_and_exit (child_err_report_fd,
1309                             CHILD_DUP2_FAILED);
1310 
1311       set_cloexec (GINT_TO_POINTER(0), stdin_fd);
1312     }
1313   else if (!child_inherits_stdin)
1314     {
1315       /* Keep process from blocking on a read of stdin */
1316       gint read_null = sane_open (&quot;/dev/null&quot;, O_RDONLY);
1317       g_assert (read_null != -1);
1318       sane_dup2 (read_null, 0);
1319       close_and_invalidate (&amp;read_null);
1320     }
1321 
1322   if (stdout_fd &gt;= 0)
1323     {
1324       /* dup2 can&#39;t actually fail here I don&#39;t think */
1325 
1326       if (sane_dup2 (stdout_fd, 1) &lt; 0)
1327         write_err_and_exit (child_err_report_fd,
1328                             CHILD_DUP2_FAILED);
1329 
1330       set_cloexec (GINT_TO_POINTER(0), stdout_fd);
1331     }
1332   else if (stdout_to_null)
1333     {
1334       gint write_null = sane_open (&quot;/dev/null&quot;, O_WRONLY);
1335       g_assert (write_null != -1);
1336       sane_dup2 (write_null, 1);
1337       close_and_invalidate (&amp;write_null);
1338     }
1339 
1340   if (stderr_fd &gt;= 0)
1341     {
1342       /* dup2 can&#39;t actually fail here I don&#39;t think */
1343 
1344       if (sane_dup2 (stderr_fd, 2) &lt; 0)
1345         write_err_and_exit (child_err_report_fd,
1346                             CHILD_DUP2_FAILED);
1347 
1348       set_cloexec (GINT_TO_POINTER(0), stderr_fd);
1349     }
1350   else if (stderr_to_null)
1351     {
1352       gint write_null = sane_open (&quot;/dev/null&quot;, O_WRONLY);
1353       sane_dup2 (write_null, 2);
1354       close_and_invalidate (&amp;write_null);
1355     }
1356 
1357   /* Call user function just before we exec */
1358   if (child_setup)
1359     {
1360       (* child_setup) (user_data);
1361     }
1362 
1363   g_execute (argv[0],
1364              file_and_argv_zero ? argv + 1 : argv,
1365              envp, search_path, search_path_from_envp);
1366 
1367   /* Exec failed */
1368   write_err_and_exit (child_err_report_fd,
1369                       CHILD_EXEC_FAILED);
1370 }
1371 
1372 static gboolean
1373 read_ints (int      fd,
1374            gint*    buf,
1375            gint     n_ints_in_buf,
1376            gint    *n_ints_read,
1377            GError **error)
1378 {
1379   gsize bytes = 0;
1380 
1381   while (TRUE)
1382     {
1383       gssize chunk;
1384 
1385       if (bytes &gt;= sizeof(gint)*2)
1386         break; /* give up, who knows what happened, should not be
1387                 * possible.
1388                 */
1389 
1390     again:
1391       chunk = read (fd,
1392                     ((gchar*)buf) + bytes,
1393                     sizeof(gint) * n_ints_in_buf - bytes);
1394       if (chunk &lt; 0 &amp;&amp; errno == EINTR)
1395         goto again;
1396 
1397       if (chunk &lt; 0)
1398         {
1399           int errsv = errno;
1400 
1401           /* Some weird shit happened, bail out */
1402           g_set_error (error,
1403                        G_SPAWN_ERROR,
1404                        G_SPAWN_ERROR_FAILED,
1405                        _(&quot;Failed to read from child pipe (%s)&quot;),
1406                        g_strerror (errsv));
1407 
1408           return FALSE;
1409         }
1410       else if (chunk == 0)
1411         break; /* EOF */
1412       else /* chunk &gt; 0 */
<a name="11" id="anc11"></a><span class="line-modified">1413   bytes += chunk;</span>
1414     }
1415 
1416   *n_ints_read = (gint)(bytes / sizeof(gint));
1417 
1418   return TRUE;
1419 }
1420 
1421 #ifdef POSIX_SPAWN_AVAILABLE
1422 static gboolean
1423 do_posix_spawn (gchar     **argv,
1424                 gchar     **envp,
1425                 gboolean    search_path,
1426                 gboolean    stdout_to_null,
1427                 gboolean    stderr_to_null,
1428                 gboolean    child_inherits_stdin,
1429                 gboolean    file_and_argv_zero,
1430                 GPid       *child_pid,
1431                 gint       *child_close_fds,
1432                 gint        stdin_fd,
1433                 gint        stdout_fd,
1434                 gint        stderr_fd)
1435 {
1436   pid_t pid;
1437   gchar **argv_pass;
1438   posix_spawnattr_t attr;
1439   posix_spawn_file_actions_t file_actions;
1440   gint parent_close_fds[3];
1441   gint num_parent_close_fds = 0;
1442   GSList *child_close = NULL;
1443   GSList *elem;
1444   sigset_t mask;
1445   int i, r;
1446 
1447   if (*argv[0] == &#39;\0&#39;)
1448     {
1449       /* We check the simple case first. */
1450       return ENOENT;
1451     }
1452 
1453   r = posix_spawnattr_init (&amp;attr);
1454   if (r != 0)
1455     return r;
1456 
1457   if (child_close_fds)
1458     {
1459       int i = -1;
1460       while (child_close_fds[++i] != -1)
1461         child_close = g_slist_prepend (child_close,
1462                                        GINT_TO_POINTER (child_close_fds[i]));
1463     }
1464 
1465   r = posix_spawnattr_setflags (&amp;attr, POSIX_SPAWN_SETSIGDEF);
1466   if (r != 0)
1467     goto out_free_spawnattr;
1468 
1469   /* Reset some signal handlers that we may use */
1470   sigemptyset (&amp;mask);
1471   sigaddset (&amp;mask, SIGCHLD);
1472   sigaddset (&amp;mask, SIGINT);
1473   sigaddset (&amp;mask, SIGTERM);
1474   sigaddset (&amp;mask, SIGHUP);
1475 
1476   r = posix_spawnattr_setsigdefault (&amp;attr, &amp;mask);
1477   if (r != 0)
1478     goto out_free_spawnattr;
1479 
1480   r = posix_spawn_file_actions_init (&amp;file_actions);
1481   if (r != 0)
1482     goto out_free_spawnattr;
1483 
1484   /* Redirect pipes as required */
1485 
1486   if (stdin_fd &gt;= 0)
1487     {
1488       r = posix_spawn_file_actions_adddup2 (&amp;file_actions, stdin_fd, 0);
1489       if (r != 0)
1490         goto out_close_fds;
1491 
1492       if (!g_slist_find (child_close, GINT_TO_POINTER (stdin_fd)))
1493         child_close = g_slist_prepend (child_close, GINT_TO_POINTER (stdin_fd));
1494     }
1495   else if (!child_inherits_stdin)
1496     {
1497       /* Keep process from blocking on a read of stdin */
1498       gint read_null = sane_open (&quot;/dev/null&quot;, O_RDONLY | O_CLOEXEC);
1499       g_assert (read_null != -1);
1500       parent_close_fds[num_parent_close_fds++] = read_null;
1501 
1502 #ifndef HAVE_O_CLOEXEC
1503       fcntl (read_null, F_SETFD, FD_CLOEXEC);
1504 #endif
1505 
1506       r = posix_spawn_file_actions_adddup2 (&amp;file_actions, read_null, 0);
1507       if (r != 0)
1508         goto out_close_fds;
1509     }
1510 
1511   if (stdout_fd &gt;= 0)
1512     {
1513       r = posix_spawn_file_actions_adddup2 (&amp;file_actions, stdout_fd, 1);
1514       if (r != 0)
1515         goto out_close_fds;
1516 
1517       if (!g_slist_find (child_close, GINT_TO_POINTER (stdout_fd)))
1518         child_close = g_slist_prepend (child_close, GINT_TO_POINTER (stdout_fd));
1519     }
1520   else if (stdout_to_null)
1521     {
1522       gint write_null = sane_open (&quot;/dev/null&quot;, O_WRONLY | O_CLOEXEC);
1523       g_assert (write_null != -1);
1524       parent_close_fds[num_parent_close_fds++] = write_null;
1525 
1526 #ifndef HAVE_O_CLOEXEC
1527       fcntl (write_null, F_SETFD, FD_CLOEXEC);
1528 #endif
1529 
1530       r = posix_spawn_file_actions_adddup2 (&amp;file_actions, write_null, 1);
1531       if (r != 0)
1532         goto out_close_fds;
1533     }
1534 
1535   if (stderr_fd &gt;= 0)
1536     {
1537       r = posix_spawn_file_actions_adddup2 (&amp;file_actions, stderr_fd, 2);
1538       if (r != 0)
1539         goto out_close_fds;
1540 
1541       if (!g_slist_find (child_close, GINT_TO_POINTER (stderr_fd)))
1542         child_close = g_slist_prepend (child_close, GINT_TO_POINTER (stderr_fd));
1543     }
1544   else if (stderr_to_null)
1545     {
1546       gint write_null = sane_open (&quot;/dev/null&quot;, O_WRONLY | O_CLOEXEC);
1547       g_assert (write_null != -1);
1548       parent_close_fds[num_parent_close_fds++] = write_null;
1549 
1550 #ifndef HAVE_O_CLOEXEC
1551       fcntl (write_null, F_SETFD, FD_CLOEXEC);
1552 #endif
1553 
1554       r = posix_spawn_file_actions_adddup2 (&amp;file_actions, write_null, 2);
1555       if (r != 0)
1556         goto out_close_fds;
1557     }
1558 
1559   /* Intentionally close the fds in the child as the last file action,
1560    * having been careful not to add the same fd to this list twice.
1561    *
1562    * This is important to allow (e.g.) for the same fd to be passed as stdout
1563    * and stderr (we must not close it before we have dupped it in both places,
1564    * and we must not attempt to close it twice).
1565    */
1566   for (elem = child_close; elem != NULL; elem = elem-&gt;next)
1567     {
1568       r = posix_spawn_file_actions_addclose (&amp;file_actions,
1569                                              GPOINTER_TO_INT (elem-&gt;data));
1570       if (r != 0)
1571         goto out_close_fds;
1572     }
1573 
1574   argv_pass = file_and_argv_zero ? argv + 1 : argv;
1575   if (envp == NULL)
1576     envp = environ;
1577 
1578   /* Don&#39;t search when it contains a slash. */
1579   if (!search_path || strchr (argv[0], &#39;/&#39;) != NULL)
1580     r = posix_spawn (&amp;pid, argv[0], &amp;file_actions, &amp;attr, argv_pass, envp);
1581   else
1582     r = posix_spawnp (&amp;pid, argv[0], &amp;file_actions, &amp;attr, argv_pass, envp);
1583 
1584   if (r == 0 &amp;&amp; child_pid != NULL)
1585     *child_pid = pid;
1586 
1587 out_close_fds:
1588   for (i = 0; i &lt; num_parent_close_fds; i++)
1589     close_and_invalidate (&amp;parent_close_fds [i]);
1590 
1591   posix_spawn_file_actions_destroy (&amp;file_actions);
1592 out_free_spawnattr:
1593   posix_spawnattr_destroy (&amp;attr);
1594   g_slist_free (child_close);
1595 
1596   return r;
1597 }
1598 #endif /* POSIX_SPAWN_AVAILABLE */
1599 
1600 static gboolean
1601 fork_exec_with_fds (gboolean              intermediate_child,
<a name="12" id="anc12"></a><span class="line-modified">1602                     const gchar          *working_directory,</span>
<span class="line-modified">1603                     gchar               **argv,</span>
<span class="line-modified">1604                     gchar               **envp,</span>
<span class="line-modified">1605                     gboolean              close_descriptors,</span>
<span class="line-modified">1606                     gboolean              search_path,</span>
<span class="line-modified">1607                     gboolean              search_path_from_envp,</span>
<span class="line-modified">1608                     gboolean              stdout_to_null,</span>
<span class="line-modified">1609                     gboolean              stderr_to_null,</span>
<span class="line-modified">1610                     gboolean              child_inherits_stdin,</span>
<span class="line-modified">1611                     gboolean              file_and_argv_zero,</span>
<span class="line-modified">1612                     gboolean              cloexec_pipes,</span>
<span class="line-modified">1613                     GSpawnChildSetupFunc  child_setup,</span>
<span class="line-modified">1614                     gpointer              user_data,</span>
<span class="line-modified">1615                     GPid                 *child_pid,</span>
<span class="line-modified">1616                     gint                 *child_close_fds,</span>
<span class="line-modified">1617                     gint                  stdin_fd,</span>
<span class="line-modified">1618                     gint                  stdout_fd,</span>
<span class="line-modified">1619                     gint                  stderr_fd,</span>
<span class="line-modified">1620                     GError              **error)</span>
1621 {
1622   GPid pid = -1;
1623   gint child_err_report_pipe[2] = { -1, -1 };
1624   gint child_pid_report_pipe[2] = { -1, -1 };
1625   guint pipe_flags = cloexec_pipes ? FD_CLOEXEC : 0;
1626   gint status;
1627 
1628 #ifdef POSIX_SPAWN_AVAILABLE
1629   if (!intermediate_child &amp;&amp; working_directory == NULL &amp;&amp; !close_descriptors &amp;&amp;
1630       !search_path_from_envp &amp;&amp; child_setup == NULL)
1631     {
1632       g_debug (&quot;Launching with posix_spawn&quot;);
1633       status = do_posix_spawn (argv,
1634                                envp,
1635                                search_path,
1636                                stdout_to_null,
1637                                stderr_to_null,
1638                                child_inherits_stdin,
1639                                file_and_argv_zero,
1640                                child_pid,
1641                                child_close_fds,
1642                                stdin_fd,
1643                                stdout_fd,
1644                                stderr_fd);
1645       if (status == 0)
1646         return TRUE;
1647 
1648       if (status != ENOEXEC)
1649         {
1650           g_set_error (error,
1651                        G_SPAWN_ERROR,
1652                        G_SPAWN_ERROR_FAILED,
<a name="13" id="anc13"></a><span class="line-modified">1653                        _(&quot;Failed to spawn child process &#39;%s&#39; (%s)&quot;),</span>
1654                        argv[0],
1655                        g_strerror (status));
1656           return FALSE;
1657        }
1658 
1659       /* posix_spawn is not intended to support script execution. It does in
1660        * some situations on some glibc versions, but that will be fixed.
1661        * So if it fails with ENOEXEC, we fall through to the regular
1662        * gspawn codepath so that script execution can be attempted,
1663        * per standard gspawn behaviour. */
1664       g_debug (&quot;posix_spawn failed (ENOEXEC), fall back to regular gspawn&quot;);
1665     }
1666   else
1667     {
1668       g_debug (&quot;posix_spawn avoided %s%s%s%s%s&quot;,
1669                !intermediate_child ? &quot;&quot; : &quot;(automatic reaping requested) &quot;,
1670                working_directory == NULL ? &quot;&quot; : &quot;(workdir specified) &quot;,
1671                !close_descriptors ? &quot;&quot; : &quot;(fd close requested) &quot;,
1672                !search_path_from_envp ? &quot;&quot; : &quot;(using envp for search path) &quot;,
1673                child_setup == NULL ? &quot;&quot; : &quot;(child_setup specified) &quot;);
1674     }
1675 #endif /* POSIX_SPAWN_AVAILABLE */
1676 
1677   if (!g_unix_open_pipe (child_err_report_pipe, pipe_flags, error))
1678     return FALSE;
1679 
1680   if (intermediate_child &amp;&amp; !g_unix_open_pipe (child_pid_report_pipe, pipe_flags, error))
1681     goto cleanup_and_fail;
1682 
1683   pid = fork ();
1684 
1685   if (pid &lt; 0)
1686     {
1687       int errsv = errno;
1688 
1689       g_set_error (error,
1690                    G_SPAWN_ERROR,
1691                    G_SPAWN_ERROR_FORK,
1692                    _(&quot;Failed to fork (%s)&quot;),
1693                    g_strerror (errsv));
1694 
1695       goto cleanup_and_fail;
1696     }
1697   else if (pid == 0)
1698     {
1699       /* Immediate child. This may or may not be the child that
1700        * actually execs the new process.
1701        */
1702 
1703       /* Reset some signal handlers that we may use */
1704       signal (SIGCHLD, SIG_DFL);
1705       signal (SIGINT, SIG_DFL);
1706       signal (SIGTERM, SIG_DFL);
1707       signal (SIGHUP, SIG_DFL);
1708 
1709       /* Be sure we crash if the parent exits
1710        * and we write to the err_report_pipe
1711        */
1712       signal (SIGPIPE, SIG_DFL);
1713 
1714       /* Close the parent&#39;s end of the pipes;
1715        * not needed in the close_descriptors case,
1716        * though
1717        */
1718       close_and_invalidate (&amp;child_err_report_pipe[0]);
1719       close_and_invalidate (&amp;child_pid_report_pipe[0]);
1720       if (child_close_fds != NULL)
1721         {
1722            int i = -1;
1723            while (child_close_fds[++i] != -1)
1724              close_and_invalidate (&amp;child_close_fds[i]);
1725         }
1726 
1727       if (intermediate_child)
1728         {
1729           /* We need to fork an intermediate child that launches the
1730            * final child. The purpose of the intermediate child
1731            * is to exit, so we can waitpid() it immediately.
1732            * Then the grandchild will not become a zombie.
1733            */
1734           GPid grandchild_pid;
1735 
1736           grandchild_pid = fork ();
1737 
1738           if (grandchild_pid &lt; 0)
1739             {
1740               /* report -1 as child PID */
1741               write_all (child_pid_report_pipe[1], &amp;grandchild_pid,
1742                          sizeof(grandchild_pid));
1743 
1744               write_err_and_exit (child_err_report_pipe[1],
1745                                   CHILD_FORK_FAILED);
1746             }
1747           else if (grandchild_pid == 0)
1748             {
1749               close_and_invalidate (&amp;child_pid_report_pipe[1]);
1750               do_exec (child_err_report_pipe[1],
1751                        stdin_fd,
1752                        stdout_fd,
1753                        stderr_fd,
1754                        working_directory,
1755                        argv,
1756                        envp,
1757                        close_descriptors,
1758                        search_path,
1759                        search_path_from_envp,
1760                        stdout_to_null,
1761                        stderr_to_null,
1762                        child_inherits_stdin,
1763                        file_and_argv_zero,
1764                        child_setup,
1765                        user_data);
1766             }
1767           else
1768             {
1769               write_all (child_pid_report_pipe[1], &amp;grandchild_pid, sizeof(grandchild_pid));
1770               close_and_invalidate (&amp;child_pid_report_pipe[1]);
1771 
1772               _exit (0);
1773             }
1774         }
1775       else
1776         {
1777           /* Just run the child.
1778            */
1779 
1780           do_exec (child_err_report_pipe[1],
1781                    stdin_fd,
1782                    stdout_fd,
1783                    stderr_fd,
1784                    working_directory,
1785                    argv,
1786                    envp,
1787                    close_descriptors,
1788                    search_path,
1789                    search_path_from_envp,
1790                    stdout_to_null,
1791                    stderr_to_null,
1792                    child_inherits_stdin,
1793                    file_and_argv_zero,
1794                    child_setup,
1795                    user_data);
1796         }
1797     }
1798   else
1799     {
1800       /* Parent */
1801 
1802       gint buf[2];
1803       gint n_ints = 0;
1804 
1805       /* Close the uncared-about ends of the pipes */
1806       close_and_invalidate (&amp;child_err_report_pipe[1]);
1807       close_and_invalidate (&amp;child_pid_report_pipe[1]);
1808 
1809       /* If we had an intermediate child, reap it */
1810       if (intermediate_child)
1811         {
1812         wait_again:
1813           if (waitpid (pid, &amp;status, 0) &lt; 0)
1814             {
1815               if (errno == EINTR)
1816                 goto wait_again;
1817               else if (errno == ECHILD)
1818                 ; /* do nothing, child already reaped */
1819               else
1820                 g_warning (&quot;waitpid() should not fail in &quot;
<a name="14" id="anc14"></a><span class="line-modified">1821          &quot;&#39;fork_exec_with_pipes&#39;&quot;);</span>
1822             }
1823         }
1824 
1825 
1826       if (!read_ints (child_err_report_pipe[0],
1827                       buf, 2, &amp;n_ints,
1828                       error))
1829         goto cleanup_and_fail;
1830 
1831       if (n_ints &gt;= 2)
1832         {
1833           /* Error from the child. */
1834 
1835           switch (buf[0])
1836             {
1837             case CHILD_CHDIR_FAILED:
1838               g_set_error (error,
1839                            G_SPAWN_ERROR,
1840                            G_SPAWN_ERROR_CHDIR,
1841                            _(&quot;Failed to change to directory &#39;%s&#39; (%s)&quot;),
1842                            working_directory,
1843                            g_strerror (buf[1]));
1844 
1845               break;
1846 
1847             case CHILD_EXEC_FAILED:
1848               g_set_error (error,
1849                            G_SPAWN_ERROR,
1850                            _g_spawn_exec_err_to_g_error (buf[1]),
<a name="15" id="anc15"></a><span class="line-modified">1851                            _(&quot;Failed to execute child process &#39;%s&#39; (%s)&quot;),</span>
1852                            argv[0],
1853                            g_strerror (buf[1]));
1854 
1855               break;
1856 
1857             case CHILD_DUP2_FAILED:
1858               g_set_error (error,
1859                            G_SPAWN_ERROR,
1860                            G_SPAWN_ERROR_FAILED,
1861                            _(&quot;Failed to redirect output or input of child process (%s)&quot;),
1862                            g_strerror (buf[1]));
1863 
1864               break;
1865 
1866             case CHILD_FORK_FAILED:
1867               g_set_error (error,
1868                            G_SPAWN_ERROR,
1869                            G_SPAWN_ERROR_FORK,
1870                            _(&quot;Failed to fork child process (%s)&quot;),
1871                            g_strerror (buf[1]));
1872               break;
1873 
1874             default:
1875               g_set_error (error,
1876                            G_SPAWN_ERROR,
1877                            G_SPAWN_ERROR_FAILED,
<a name="16" id="anc16"></a><span class="line-modified">1878                            _(&quot;Unknown error executing child process &#39;%s&#39;&quot;),</span>
1879                            argv[0]);
1880               break;
1881             }
1882 
1883           goto cleanup_and_fail;
1884         }
1885 
1886       /* Get child pid from intermediate child pipe. */
1887       if (intermediate_child)
1888         {
1889           n_ints = 0;
1890 
1891           if (!read_ints (child_pid_report_pipe[0],
1892                           buf, 1, &amp;n_ints, error))
1893             goto cleanup_and_fail;
1894 
1895           if (n_ints &lt; 1)
1896             {
1897               int errsv = errno;
1898 
1899               g_set_error (error,
1900                            G_SPAWN_ERROR,
1901                            G_SPAWN_ERROR_FAILED,
1902                            _(&quot;Failed to read enough data from child pid pipe (%s)&quot;),
1903                            g_strerror (errsv));
1904               goto cleanup_and_fail;
1905             }
1906           else
1907             {
1908               /* we have the child pid */
1909               pid = buf[0];
1910             }
1911         }
1912 
1913       /* Success against all odds! return the information */
1914       close_and_invalidate (&amp;child_err_report_pipe[0]);
1915       close_and_invalidate (&amp;child_pid_report_pipe[0]);
1916 
1917       if (child_pid)
1918         *child_pid = pid;
1919 
1920       return TRUE;
1921     }
1922 
1923  cleanup_and_fail:
1924 
1925   /* There was an error from the Child, reap the child to avoid it being
1926      a zombie.
1927    */
1928 
1929   if (pid &gt; 0)
1930   {
1931     wait_failed:
1932      if (waitpid (pid, NULL, 0) &lt; 0)
1933        {
1934           if (errno == EINTR)
1935             goto wait_failed;
1936           else if (errno == ECHILD)
1937             ; /* do nothing, child already reaped */
1938           else
1939             g_warning (&quot;waitpid() should not fail in &quot;
1940                        &quot;&#39;fork_exec_with_pipes&#39;&quot;);
1941        }
1942    }
1943 
1944   close_and_invalidate (&amp;child_err_report_pipe[0]);
1945   close_and_invalidate (&amp;child_err_report_pipe[1]);
1946   close_and_invalidate (&amp;child_pid_report_pipe[0]);
1947   close_and_invalidate (&amp;child_pid_report_pipe[1]);
1948 
1949   return FALSE;
1950 }
1951 
1952 static gboolean
1953 fork_exec_with_pipes (gboolean              intermediate_child,
1954                       const gchar          *working_directory,
1955                       gchar               **argv,
1956                       gchar               **envp,
1957                       gboolean              close_descriptors,
1958                       gboolean              search_path,
1959                       gboolean              search_path_from_envp,
1960                       gboolean              stdout_to_null,
1961                       gboolean              stderr_to_null,
1962                       gboolean              child_inherits_stdin,
1963                       gboolean              file_and_argv_zero,
1964                       gboolean              cloexec_pipes,
1965                       GSpawnChildSetupFunc  child_setup,
1966                       gpointer              user_data,
1967                       GPid                 *child_pid,
1968                       gint                 *standard_input,
1969                       gint                 *standard_output,
1970                       gint                 *standard_error,
1971                       GError              **error)
1972 {
1973   guint pipe_flags = cloexec_pipes ? FD_CLOEXEC : 0;
1974   gint stdin_pipe[2] = { -1, -1 };
1975   gint stdout_pipe[2] = { -1, -1 };
1976   gint stderr_pipe[2] = { -1, -1 };
1977   gint child_close_fds[4];
1978   gboolean ret;
1979 
1980   if (standard_input &amp;&amp; !g_unix_open_pipe (stdin_pipe, pipe_flags, error))
1981     goto cleanup_and_fail;
1982 
1983   if (standard_output &amp;&amp; !g_unix_open_pipe (stdout_pipe, pipe_flags, error))
1984     goto cleanup_and_fail;
1985 
1986   if (standard_error &amp;&amp; !g_unix_open_pipe (stderr_pipe, FD_CLOEXEC, error))
1987     goto cleanup_and_fail;
1988 
1989   child_close_fds[0] = stdin_pipe[1];
1990   child_close_fds[1] = stdout_pipe[0];
1991   child_close_fds[2] = stderr_pipe[0];
1992   child_close_fds[3] = -1;
1993 
1994   ret = fork_exec_with_fds (intermediate_child,
1995                             working_directory,
1996                             argv,
1997                             envp,
1998                             close_descriptors,
1999                             search_path,
2000                             search_path_from_envp,
2001                             stdout_to_null,
2002                             stderr_to_null,
2003                             child_inherits_stdin,
2004                             file_and_argv_zero,
2005                             pipe_flags,
2006                             child_setup,
2007                             user_data,
2008                             child_pid,
2009                             child_close_fds,
2010                             stdin_pipe[0],
2011                             stdout_pipe[1],
2012                             stderr_pipe[1],
2013                             error);
2014   if (!ret)
2015     goto cleanup_and_fail;
2016 
2017   /* Close the uncared-about ends of the pipes */
2018   close_and_invalidate (&amp;stdin_pipe[0]);
2019   close_and_invalidate (&amp;stdout_pipe[1]);
2020   close_and_invalidate (&amp;stderr_pipe[1]);
2021 
2022   if (standard_input)
2023     *standard_input = stdin_pipe[1];
2024 
2025   if (standard_output)
2026     *standard_output = stdout_pipe[0];
2027 
2028   if (standard_error)
2029     *standard_error = stderr_pipe[0];
2030 
2031   return TRUE;
2032 
2033 cleanup_and_fail:
2034   close_and_invalidate (&amp;stdin_pipe[0]);
2035   close_and_invalidate (&amp;stdin_pipe[1]);
2036   close_and_invalidate (&amp;stdout_pipe[0]);
2037   close_and_invalidate (&amp;stdout_pipe[1]);
2038   close_and_invalidate (&amp;stderr_pipe[0]);
2039   close_and_invalidate (&amp;stderr_pipe[1]);
2040 
2041   return FALSE;
2042 }
2043 
2044 /* Based on execvp from GNU C Library */
2045 
2046 static void
2047 script_execute (const gchar *file,
2048                 gchar      **argv,
2049                 gchar      **envp)
2050 {
2051   /* Count the arguments.  */
2052   int argc = 0;
2053   while (argv[argc])
2054     ++argc;
2055 
2056   /* Construct an argument list for the shell.  */
2057   {
2058     gchar **new_argv;
2059 
2060     new_argv = g_new0 (gchar*, argc + 2); /* /bin/sh and NULL */
2061 
2062     new_argv[0] = (char *) &quot;/bin/sh&quot;;
2063     new_argv[1] = (char *) file;
2064     while (argc &gt; 0)
2065       {
<a name="17" id="anc17"></a><span class="line-modified">2066   new_argv[argc + 1] = argv[argc];</span>
<span class="line-modified">2067   --argc;</span>
2068       }
2069 
2070     /* Execute the shell. */
2071     if (envp)
2072       execve (new_argv[0], new_argv, envp);
2073     else
2074       execv (new_argv[0], new_argv);
2075 
2076     g_free (new_argv);
2077   }
2078 }
2079 
2080 static gchar*
2081 my_strchrnul (const gchar *str, gchar c)
2082 {
2083   gchar *p = (gchar*) str;
2084   while (*p &amp;&amp; (*p != c))
2085     ++p;
2086 
2087   return p;
2088 }
2089 
2090 static gint
2091 g_execute (const gchar *file,
2092            gchar      **argv,
2093            gchar      **envp,
2094            gboolean     search_path,
2095            gboolean     search_path_from_envp)
2096 {
2097   if (*file == &#39;\0&#39;)
2098     {
2099       /* We check the simple case first. */
2100       errno = ENOENT;
2101       return -1;
2102     }
2103 
2104   if (!(search_path || search_path_from_envp) || strchr (file, &#39;/&#39;) != NULL)
2105     {
2106       /* Don&#39;t search when it contains a slash. */
2107       if (envp)
2108         execve (file, argv, envp);
2109       else
2110         execv (file, argv);
2111 
2112       if (errno == ENOEXEC)
<a name="18" id="anc18"></a><span class="line-modified">2113   script_execute (file, argv, envp);</span>
2114     }
2115   else
2116     {
2117       gboolean got_eacces = 0;
2118       const gchar *path, *p;
2119       gchar *name, *freeme;
2120       gsize len;
2121       gsize pathlen;
2122 
2123       path = NULL;
2124       if (search_path_from_envp)
2125         path = g_environ_getenv (envp, &quot;PATH&quot;);
2126       if (search_path &amp;&amp; path == NULL)
2127         path = g_getenv (&quot;PATH&quot;);
2128 
2129       if (path == NULL)
<a name="19" id="anc19"></a><span class="line-modified">2130   {</span>
<span class="line-modified">2131     /* There is no &#39;PATH&#39; in the environment.  The default</span>
<span class="line-modified">2132      * search path in libc is the current directory followed by</span>
<span class="line-modified">2133      * the path &#39;confstr&#39; returns for &#39;_CS_PATH&#39;.</span>
2134            */
2135 
2136           /* In GLib we put . last, for security, and don&#39;t use the
2137            * unportable confstr(); UNIX98 does not actually specify
2138            * what to search if PATH is unset. POSIX may, dunno.
2139            */
2140 
2141           path = &quot;/bin:/usr/bin:.&quot;;
<a name="20" id="anc20"></a><span class="line-modified">2142   }</span>
2143 
2144       len = strlen (file) + 1;
2145       pathlen = strlen (path);
2146       freeme = name = g_malloc (pathlen + len + 1);
2147 
2148       /* Copy the file name at the top, including &#39;\0&#39;  */
2149       memcpy (name + pathlen + 1, file, len);
2150       name = name + pathlen;
2151       /* And add the slash before the filename  */
2152       *name = &#39;/&#39;;
2153 
2154       p = path;
2155       do
<a name="21" id="anc21"></a><span class="line-modified">2156   {</span>
<span class="line-modified">2157     char *startp;</span>
2158 
<a name="22" id="anc22"></a><span class="line-modified">2159     path = p;</span>
<span class="line-modified">2160     p = my_strchrnul (path, &#39;:&#39;);</span>
2161 
<a name="23" id="anc23"></a><span class="line-modified">2162     if (p == path)</span>
<span class="line-modified">2163       /* Two adjacent colons, or a colon at the beginning or the end</span>
2164              * of &#39;PATH&#39; means to search the current directory.
2165              */
<a name="24" id="anc24"></a><span class="line-modified">2166       startp = name + 1;</span>
<span class="line-modified">2167     else</span>
<span class="line-modified">2168       startp = memcpy (name - (p - path), path, p - path);</span>
2169 
<a name="25" id="anc25"></a><span class="line-modified">2170     /* Try to execute this name.  If it works, execv will not return.  */</span>
2171           if (envp)
2172             execve (startp, argv, envp);
2173           else
2174             execv (startp, argv);
2175 
<a name="26" id="anc26"></a><span class="line-modified">2176     if (errno == ENOEXEC)</span>
<span class="line-modified">2177       script_execute (startp, argv, envp);</span>
2178 
<a name="27" id="anc27"></a><span class="line-modified">2179     switch (errno)</span>
<span class="line-modified">2180       {</span>
<span class="line-modified">2181       case EACCES:</span>
<span class="line-modified">2182         /* Record the we got a &#39;Permission denied&#39; error.  If we end</span>
2183                * up finding no executable we can use, we want to diagnose
2184                * that we did find one but were denied access.
2185                */
<a name="28" id="anc28"></a><span class="line-modified">2186         got_eacces = TRUE;</span>
2187 
2188               /* FALL THRU */
2189 
<a name="29" id="anc29"></a><span class="line-modified">2190       case ENOENT:</span>
2191 #ifdef ESTALE
<a name="30" id="anc30"></a><span class="line-modified">2192       case ESTALE:</span>
2193 #endif
2194 #ifdef ENOTDIR
<a name="31" id="anc31"></a><span class="line-modified">2195       case ENOTDIR:</span>
2196 #endif
<a name="32" id="anc32"></a><span class="line-modified">2197         /* Those errors indicate the file is missing or not executable</span>
2198                * by us, in which case we want to just try the next path
2199                * directory.
2200                */
<a name="33" id="anc33"></a><span class="line-modified">2201         break;</span>
2202 
<a name="34" id="anc34"></a><span class="line-modified">2203       case ENODEV:</span>
<span class="line-modified">2204       case ETIMEDOUT:</span>
<span class="line-modified">2205         /* Some strange filesystems like AFS return even</span>
<span class="line-modified">2206          * stranger error numbers.  They cannot reasonably mean anything</span>
<span class="line-modified">2207          * else so ignore those, too.</span>
<span class="line-modified">2208          */</span>
<span class="line-modified">2209         break;</span>
2210 
<a name="35" id="anc35"></a><span class="line-modified">2211       default:</span>
<span class="line-modified">2212         /* Some other error means we found an executable file, but</span>
2213                * something went wrong executing it; return the error to our
2214                * caller.
2215                */
2216               g_free (freeme);
<a name="36" id="anc36"></a><span class="line-modified">2217         return -1;</span>
<span class="line-modified">2218       }</span>
<span class="line-modified">2219   }</span>
2220       while (*p++ != &#39;\0&#39;);
2221 
2222       /* We tried every element and none of them worked.  */
2223       if (got_eacces)
<a name="37" id="anc37"></a><span class="line-modified">2224   /* At least one failure was due to permissions, so report that</span>
2225          * error.
2226          */
2227         errno = EACCES;
2228 
2229       g_free (freeme);
2230     }
2231 
2232   /* Return the error from the last attempt (probably ENOENT).  */
2233   return -1;
2234 }
2235 
2236 /**
2237  * g_spawn_close_pid:
2238  * @pid: The process reference to close
2239  *
2240  * On some platforms, notably Windows, the #GPid type represents a resource
2241  * which must be closed to prevent resource leaking. g_spawn_close_pid()
2242  * is provided for this purpose. It should be used on all platforms, even
2243  * though it doesn&#39;t do anything under UNIX.
2244  **/
2245 void
2246 g_spawn_close_pid (GPid pid)
2247 {
2248 }
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>