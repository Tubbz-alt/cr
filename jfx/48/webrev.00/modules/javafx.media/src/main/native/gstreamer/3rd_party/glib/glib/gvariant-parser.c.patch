diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant-parser.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant-parser.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant-parser.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant-parser.c
@@ -1,7 +1,7 @@
 /*
- * Copyright ï¿½ 2009, 2010 Codethink Limited
+ * Copyright (C) 2009, 2010 Codethink Limited
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
  * License as published by the Free Software Foundation; either
  * version 2.1 of the License, or (at your option) any later version.
@@ -208,14 +208,11 @@
           if (end != stream->end && *end)
             end++;
           break;
         }
 
-      else
-        {
-          /* ??? */
-        }
+      G_GNUC_FALLTHROUGH;
 
     case 'a': /* 'b' */ case 'c': case 'd': case 'e': case 'f':
     case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':
     case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':
     case 's': case 't': case 'u': case 'v': case 'w': case 'x':
@@ -363,11 +360,11 @@
 
 static void
 token_stream_assert (TokenStream *stream,
                      const gchar *token)
 {
-  gboolean correct_token;
+  gboolean correct_token G_GNUC_UNUSED  /* when compiling with G_DISABLE_ASSERT */;
 
   correct_token = token_stream_consume (stream, token);
   g_assert (correct_token);
 }
 
@@ -419,10 +416,12 @@
       *(*out)++ = *(*in)++;
     }
   while (brackets);
 }
 
+/* Returns the most general pattern that is subpattern of left and subpattern
+ * of right, or NULL if there is no such pattern. */
 static gchar *
 pattern_coalesce (const gchar *left,
                   const gchar *right)
 {
   gchar *result;
@@ -459,11 +458,11 @@
           else if (**one == 'M' && **the_other == 'm')
             {
               *out++ = *(*the_other)++;
             }
 
-          else if (**one == 'M' && **the_other != 'm')
+          else if (**one == 'M' && **the_other != 'm' && **the_other != '*')
             {
               (*one)++;
             }
 
           else if (**one == 'N' && strchr ("ynqiuxthd", **the_other))
@@ -672,10 +671,13 @@
                        GError **error)
 {
   gchar *pattern;
   gint i;
 
+  /* Find the pattern which applies to all children in the array, by l-folding a
+   * coalesce operation.
+   */
   pattern = ast_get_pattern (array[0], error);
 
   if (pattern == NULL)
     return NULL;
 
@@ -706,12 +708,22 @@
           while (TRUE)
             {
               gchar *tmp2;
               gchar *m;
 
-              /* if 'j' reaches 'i' then we failed to find the pair */
-              g_assert (j < i);
+              /* if 'j' reaches 'i' then we didn't find the pair that failed
+               * to coalesce. This shouldn't happen (see above), but just in
+               * case report an error:
+               */
+              if (j >= i)
+                {
+                  ast_set_error (array[i], error, NULL,
+                                 G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE,
+                                 "unable to find a common type");
+                  g_free (tmp);
+                  return NULL;
+                }
 
               tmp2 = ast_get_pattern (array[j], NULL);
               g_assert (tmp2 != NULL);
 
               m = pattern_coalesce (tmp, tmp2);
@@ -1529,36 +1541,50 @@
 
   g_free (string->string);
   g_slice_free (String, string);
 }
 
+/* Accepts exactly @length hexadecimal digits. No leading sign or `0x`/`0X` prefix allowed.
+ * No leading/trailing space allowed. */
 static gboolean
 unicode_unescape (const gchar  *src,
                   gint         *src_ofs,
                   gchar        *dest,
                   gint         *dest_ofs,
-                  gint          length,
+                  gsize         length,
                   SourceRef    *ref,
                   GError      **error)
 {
   gchar buffer[9];
-  guint64 value;
+  guint64 value = 0;
   gchar *end;
+  gsize n_valid_chars;
 
   (*src_ofs)++;
 
   g_assert (length < sizeof (buffer));
   strncpy (buffer, src + *src_ofs, length);
   buffer[length] = '\0';
 
-  value = g_ascii_strtoull (buffer, &end, 0x10);
+  for (n_valid_chars = 0; n_valid_chars < length; n_valid_chars++)
+    if (!g_ascii_isxdigit (buffer[n_valid_chars]))
+      break;
+
+  if (n_valid_chars == length)
+    value = g_ascii_strtoull (buffer, &end, 0x10);
 
   if (value == 0 || end != buffer + length)
     {
-      parser_set_error (error, ref, NULL,
+      SourceRef escape_ref;
+
+      escape_ref = *ref;
+      escape_ref.start += *src_ofs;
+      escape_ref.end = escape_ref.start + n_valid_chars;
+
+      parser_set_error (error, &escape_ref, NULL,
                         G_VARIANT_PARSE_ERROR_INVALID_CHARACTER,
-                        "invalid %d-character unicode escape", length);
+                        "invalid %" G_GSIZE_FORMAT "-character unicode escape", length);
       return FALSE;
     }
 
   g_assert (value <= G_MAXUINT32);
 
@@ -1644,10 +1670,12 @@
           case 't': str[j++] = '\t'; i++; continue;
           case 'v': str[j++] = '\v'; i++; continue;
           case '\n': i++; continue;
           }
 
+        G_GNUC_FALLTHROUGH;
+
       default:
         str[j++] = token[i++];
       }
   str[j++] = '\0';
   g_free (token);
@@ -1771,10 +1799,12 @@
           case 't': str[j++] = '\t'; i++; continue;
           case 'v': str[j++] = '\v'; i++; continue;
           case '\n': i++; continue;
           }
 
+        G_GNUC_FALLTHROUGH;
+
       default:
         str[j++] = token[i++];
       }
   str[j++] = '\0';
   g_free (token);
@@ -1904,41 +1934,53 @@
       return g_variant_new_byte (abs_val);
 
     case 'n':
       if (abs_val - negative > G_MAXINT16)
         return number_overflow (ast, type, error);
-      return g_variant_new_int16 (negative ? -abs_val : abs_val);
+      if (negative && abs_val > G_MAXINT16)
+        return g_variant_new_int16 (G_MININT16);
+      return g_variant_new_int16 (negative ?
+                                  -((gint16) abs_val) : ((gint16) abs_val));
 
     case 'q':
       if (negative || abs_val > G_MAXUINT16)
         return number_overflow (ast, type, error);
       return g_variant_new_uint16 (abs_val);
 
     case 'i':
       if (abs_val - negative > G_MAXINT32)
         return number_overflow (ast, type, error);
-      return g_variant_new_int32 (negative ? -abs_val : abs_val);
+      if (negative && abs_val > G_MAXINT32)
+        return g_variant_new_int32 (G_MININT32);
+      return g_variant_new_int32 (negative ?
+                                  -((gint32) abs_val) : ((gint32) abs_val));
 
     case 'u':
       if (negative || abs_val > G_MAXUINT32)
         return number_overflow (ast, type, error);
       return g_variant_new_uint32 (abs_val);
 
     case 'x':
       if (abs_val - negative > G_MAXINT64)
         return number_overflow (ast, type, error);
-      return g_variant_new_int64 (negative ? -abs_val : abs_val);
+      if (negative && abs_val > G_MAXINT64)
+        return g_variant_new_int64 (G_MININT64);
+      return g_variant_new_int64 (negative ?
+                                  -((gint64) abs_val) : ((gint64) abs_val));
 
     case 't':
       if (negative)
         return number_overflow (ast, type, error);
       return g_variant_new_uint64 (abs_val);
 
     case 'h':
       if (abs_val - negative > G_MAXINT32)
         return number_overflow (ast, type, error);
-      return g_variant_new_handle (negative ? -abs_val : abs_val);
+      if (negative && abs_val > G_MAXINT32)
+        return g_variant_new_handle (G_MININT32);
+      return g_variant_new_handle (negative ?
+                                   -((gint32) abs_val) : ((gint32) abs_val));
 
     default:
       return ast_type_error (ast, type, error);
     }
 }
@@ -2590,11 +2632,11 @@
 }
 
 static gboolean
 parse_num (const gchar *num,
            const gchar *limit,
-           gint        *result)
+           guint       *result)
 {
   gchar *endptr;
   gint64 bignum;
 
   bignum = g_ascii_strtoll (num, &endptr, 10);
@@ -2603,11 +2645,11 @@
     return FALSE;
 
   if (bignum < 0 || bignum > G_MAXINT)
     return FALSE;
 
-  *result = bignum;
+  *result = (guint) bignum;
 
   return TRUE;
 }
 
 static void
@@ -2759,29 +2801,29 @@
   err = g_string_new (colon + 1);
   g_string_append (err, ":\n");
 
   if (dash == NULL || colon < dash)
     {
-      gint point;
+      guint point;
 
       /* we have a single point */
       if (!parse_num (error->message, colon, &point))
         goto out;
 
       if (point >= strlen (source_str))
         /* the error is at the end of the input */
         add_last_line (err, source_str);
       else
-        /* otherwise just treat it as a error at a thin range */
+        /* otherwise just treat it as an error at a thin range */
         add_lines_from_range (err, source_str, source_str + point, source_str + point + 1, NULL, NULL);
     }
   else
     {
       /* We have one or two ranges... */
       if (comma && comma < colon)
         {
-          gint start1, end1, start2, end2;
+          guint start1, end1, start2, end2;
           const gchar *dash2;
 
           /* Two ranges */
           dash2 = strchr (comma, '-');
 
@@ -2793,11 +2835,11 @@
                                 source_str + start1, source_str + end1,
                                 source_str + start2, source_str + end2);
         }
       else
         {
-          gint start, end;
+          guint start, end;
 
           /* One range */
           if (!parse_num (error->message, dash, &start) || !parse_num (dash + 1, colon, &end))
             goto out;
 
