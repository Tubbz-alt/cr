<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/video-frame.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="video-format.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="video-frame.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/video/video-frame.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 58  * Use @info and @buffer to fill in the values of @frame with the video frame
 59  * information of frame @id.
 60  *
 61  * When @id is -1, the default frame is mapped. When @id != -1, this function
 62  * will return %FALSE when there is no GstVideoMeta with that id.
 63  *
 64  * All video planes of @buffer will be mapped and the pointers will be set in
 65  * @frame-&gt;data.
 66  *
 67  * Returns: %TRUE on success.
 68  */
 69 gboolean
 70 gst_video_frame_map_id (GstVideoFrame * frame, GstVideoInfo * info,
 71     GstBuffer * buffer, gint id, GstMapFlags flags)
 72 {
 73   GstVideoMeta *meta;
 74   gint i;
 75 
 76   g_return_val_if_fail (frame != NULL, FALSE);
 77   g_return_val_if_fail (info != NULL, FALSE);

 78   g_return_val_if_fail (GST_IS_BUFFER (buffer), FALSE);
 79 
 80   if (id == -1)
 81     meta = gst_buffer_get_video_meta (buffer);
 82   else
 83     meta = gst_buffer_get_video_meta_id (buffer, id);
 84 
 85   /* copy the info */
 86   frame-&gt;info = *info;
 87 
 88   if (meta) {
 89     /* All these values must be consistent */
 90     g_return_val_if_fail (info-&gt;finfo-&gt;format == meta-&gt;format, FALSE);
 91     g_return_val_if_fail (info-&gt;width &lt;= meta-&gt;width, FALSE);
 92     g_return_val_if_fail (info-&gt;height &lt;= meta-&gt;height, FALSE);
 93     g_return_val_if_fail (info-&gt;finfo-&gt;n_planes == meta-&gt;n_planes, FALSE);
 94 
 95     frame-&gt;info.finfo = gst_video_format_get_info (meta-&gt;format);
 96     frame-&gt;info.width = meta-&gt;width;
 97     frame-&gt;info.height = meta-&gt;height;
</pre>
<hr />
<pre>
120     if (frame-&gt;map[0].size &lt; info-&gt;size)
121       goto invalid_size;
122 
123     /* set up pointers */
124     for (i = 0; i &lt; info-&gt;finfo-&gt;n_planes; i++) {
125       frame-&gt;data[i] = frame-&gt;map[0].data + info-&gt;offset[i];
126     }
127   }
128   frame-&gt;buffer = buffer;
129   if ((flags &amp; GST_VIDEO_FRAME_MAP_FLAG_NO_REF) == 0)
130     gst_buffer_ref (frame-&gt;buffer);
131 
132   frame-&gt;meta = meta;
133 
134   /* buffer flags enhance the frame flags */
135   if (GST_VIDEO_INFO_IS_INTERLACED (info)) {
136     if (GST_VIDEO_INFO_INTERLACE_MODE (info) == GST_VIDEO_INTERLACE_MODE_MIXED) {
137       if (GST_BUFFER_FLAG_IS_SET (buffer, GST_VIDEO_BUFFER_FLAG_INTERLACED)) {
138         frame-&gt;flags |= GST_VIDEO_FRAME_FLAG_INTERLACED;
139       }
<span class="line-modified">140     } else</span>
141       frame-&gt;flags |= GST_VIDEO_FRAME_FLAG_INTERLACED;

142 
<span class="line-modified">143     if (GST_BUFFER_FLAG_IS_SET (buffer, GST_VIDEO_BUFFER_FLAG_TFF))</span>

144       frame-&gt;flags |= GST_VIDEO_FRAME_FLAG_TFF;
<span class="line-modified">145     if (GST_BUFFER_FLAG_IS_SET (buffer, GST_VIDEO_BUFFER_FLAG_RFF))</span>
<span class="line-modified">146       frame-&gt;flags |= GST_VIDEO_FRAME_FLAG_RFF;</span>
<span class="line-modified">147     if (GST_BUFFER_FLAG_IS_SET (buffer, GST_VIDEO_BUFFER_FLAG_ONEFIELD))</span>
<span class="line-modified">148       frame-&gt;flags |= GST_VIDEO_FRAME_FLAG_ONEFIELD;</span>




149   }
150   return TRUE;
151 
152   /* ERRORS */
153 no_metadata:
154   {
155     GST_ERROR (&quot;no GstVideoMeta for id %d&quot;, id);
156     memset (frame, 0, sizeof (GstVideoFrame));
157     return FALSE;
158   }
159 frame_map_failed:
160   {
161     GST_ERROR (&quot;failed to map video frame plane %d&quot;, i);
162     while (--i &gt;= 0)
163       gst_video_meta_unmap (meta, i, &amp;frame-&gt;map[i]);
164     memset (frame, 0, sizeof (GstVideoFrame));
165     return FALSE;
166   }
167 map_failed:
168   {
</pre>
</td>
<td>
<hr />
<pre>
 58  * Use @info and @buffer to fill in the values of @frame with the video frame
 59  * information of frame @id.
 60  *
 61  * When @id is -1, the default frame is mapped. When @id != -1, this function
 62  * will return %FALSE when there is no GstVideoMeta with that id.
 63  *
 64  * All video planes of @buffer will be mapped and the pointers will be set in
 65  * @frame-&gt;data.
 66  *
 67  * Returns: %TRUE on success.
 68  */
 69 gboolean
 70 gst_video_frame_map_id (GstVideoFrame * frame, GstVideoInfo * info,
 71     GstBuffer * buffer, gint id, GstMapFlags flags)
 72 {
 73   GstVideoMeta *meta;
 74   gint i;
 75 
 76   g_return_val_if_fail (frame != NULL, FALSE);
 77   g_return_val_if_fail (info != NULL, FALSE);
<span class="line-added"> 78   g_return_val_if_fail (info-&gt;finfo != NULL, FALSE);</span>
 79   g_return_val_if_fail (GST_IS_BUFFER (buffer), FALSE);
 80 
 81   if (id == -1)
 82     meta = gst_buffer_get_video_meta (buffer);
 83   else
 84     meta = gst_buffer_get_video_meta_id (buffer, id);
 85 
 86   /* copy the info */
 87   frame-&gt;info = *info;
 88 
 89   if (meta) {
 90     /* All these values must be consistent */
 91     g_return_val_if_fail (info-&gt;finfo-&gt;format == meta-&gt;format, FALSE);
 92     g_return_val_if_fail (info-&gt;width &lt;= meta-&gt;width, FALSE);
 93     g_return_val_if_fail (info-&gt;height &lt;= meta-&gt;height, FALSE);
 94     g_return_val_if_fail (info-&gt;finfo-&gt;n_planes == meta-&gt;n_planes, FALSE);
 95 
 96     frame-&gt;info.finfo = gst_video_format_get_info (meta-&gt;format);
 97     frame-&gt;info.width = meta-&gt;width;
 98     frame-&gt;info.height = meta-&gt;height;
</pre>
<hr />
<pre>
121     if (frame-&gt;map[0].size &lt; info-&gt;size)
122       goto invalid_size;
123 
124     /* set up pointers */
125     for (i = 0; i &lt; info-&gt;finfo-&gt;n_planes; i++) {
126       frame-&gt;data[i] = frame-&gt;map[0].data + info-&gt;offset[i];
127     }
128   }
129   frame-&gt;buffer = buffer;
130   if ((flags &amp; GST_VIDEO_FRAME_MAP_FLAG_NO_REF) == 0)
131     gst_buffer_ref (frame-&gt;buffer);
132 
133   frame-&gt;meta = meta;
134 
135   /* buffer flags enhance the frame flags */
136   if (GST_VIDEO_INFO_IS_INTERLACED (info)) {
137     if (GST_VIDEO_INFO_INTERLACE_MODE (info) == GST_VIDEO_INTERLACE_MODE_MIXED) {
138       if (GST_BUFFER_FLAG_IS_SET (buffer, GST_VIDEO_BUFFER_FLAG_INTERLACED)) {
139         frame-&gt;flags |= GST_VIDEO_FRAME_FLAG_INTERLACED;
140       }
<span class="line-modified">141     } else {</span>
142       frame-&gt;flags |= GST_VIDEO_FRAME_FLAG_INTERLACED;
<span class="line-added">143     }</span>
144 
<span class="line-modified">145     if (GST_VIDEO_INFO_FIELD_ORDER (info) ==</span>
<span class="line-added">146         GST_VIDEO_FIELD_ORDER_TOP_FIELD_FIRST) {</span>
147       frame-&gt;flags |= GST_VIDEO_FRAME_FLAG_TFF;
<span class="line-modified">148     } else {</span>
<span class="line-modified">149       if (GST_BUFFER_FLAG_IS_SET (buffer, GST_VIDEO_BUFFER_FLAG_TFF))</span>
<span class="line-modified">150         frame-&gt;flags |= GST_VIDEO_FRAME_FLAG_TFF;</span>
<span class="line-modified">151       if (GST_BUFFER_FLAG_IS_SET (buffer, GST_VIDEO_BUFFER_FLAG_RFF))</span>
<span class="line-added">152         frame-&gt;flags |= GST_VIDEO_FRAME_FLAG_RFF;</span>
<span class="line-added">153       if (GST_BUFFER_FLAG_IS_SET (buffer, GST_VIDEO_BUFFER_FLAG_ONEFIELD))</span>
<span class="line-added">154         frame-&gt;flags |= GST_VIDEO_FRAME_FLAG_ONEFIELD;</span>
<span class="line-added">155     }</span>
156   }
157   return TRUE;
158 
159   /* ERRORS */
160 no_metadata:
161   {
162     GST_ERROR (&quot;no GstVideoMeta for id %d&quot;, id);
163     memset (frame, 0, sizeof (GstVideoFrame));
164     return FALSE;
165   }
166 frame_map_failed:
167   {
168     GST_ERROR (&quot;failed to map video frame plane %d&quot;, i);
169     while (--i &gt;= 0)
170       gst_video_meta_unmap (meta, i, &amp;frame-&gt;map[i]);
171     memset (frame, 0, sizeof (GstVideoFrame));
172     return FALSE;
173   }
174 map_failed:
175   {
</pre>
</td>
</tr>
</table>
<center><a href="video-format.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="video-frame.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>