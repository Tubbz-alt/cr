<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstbuffer.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstbin.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstbuffer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstbuffer.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  96  * needed.
  97  *
  98  * Arbitrary extra metadata can be set on a buffer with gst_buffer_add_meta().
  99  * Metadata can be retrieved with gst_buffer_get_meta(). See also #GstMeta
 100  *
 101  * An element should either unref the buffer or push it out on a src pad
 102  * using gst_pad_push() (see #GstPad).
 103  *
 104  * Buffers are usually freed by unreffing them with gst_buffer_unref(). When
 105  * the refcount drops to 0, any memory and metadata pointed to by the buffer is
 106  * unreffed as well. Buffers allocated from a #GstBufferPool will be returned to
 107  * the pool when the refcount drops to 0.
 108  *
 109  * The #GstParentBufferMeta is a meta which can be attached to a #GstBuffer
 110  * to hold a reference to another buffer that is only released when the child
 111  * #GstBuffer is released.
 112  *
 113  * Typically, #GstParentBufferMeta is used when the child buffer is directly
 114  * using the #GstMemory of the parent buffer, and wants to prevent the parent
 115  * buffer from being returned to a buffer pool until the #GstMemory is available
<span class="line-modified"> 116  * for re-use. (Since 1.6)</span>
 117  *
 118  */
 119 #include &quot;gst_private.h&quot;
 120 
 121 #ifdef HAVE_UNISTD_H
 122 #include &lt;unistd.h&gt;
 123 #endif
 124 #ifdef HAVE_STDLIB_H
 125 #include &lt;stdlib.h&gt;
 126 #endif
 127 
 128 #include &quot;gstbuffer.h&quot;
 129 #include &quot;gstbufferpool.h&quot;
 130 #include &quot;gstinfo.h&quot;
 131 #include &quot;gstutils.h&quot;
 132 #include &quot;gstversion.h&quot;
 133 
 134 GType _gst_buffer_type = 0;
 135 
<span class="line-modified"> 136 typedef struct _GstMetaItem GstMetaItem;</span>
<span class="line-modified"> 137 </span>
<span class="line-modified"> 138 struct _GstMetaItem</span>
<span class="line-removed"> 139 {</span>
<span class="line-removed"> 140   GstMetaItem *next;</span>
<span class="line-removed"> 141   GstMeta meta;</span>
<span class="line-removed"> 142 };</span>
<span class="line-removed"> 143 #define ITEM_SIZE(info) ((info)-&gt;size + sizeof (GstMetaItem))</span>
 144 
 145 #define GST_BUFFER_MEM_MAX         16
 146 
 147 #define GST_BUFFER_SLICE_SIZE(b)   (((GstBufferImpl *)(b))-&gt;slice_size)
 148 #define GST_BUFFER_MEM_LEN(b)      (((GstBufferImpl *)(b))-&gt;len)
 149 #define GST_BUFFER_MEM_ARRAY(b)    (((GstBufferImpl *)(b))-&gt;mem)
 150 #define GST_BUFFER_MEM_PTR(b,i)    (((GstBufferImpl *)(b))-&gt;mem[i])
 151 #define GST_BUFFER_BUFMEM(b)       (((GstBufferImpl *)(b))-&gt;bufmem)
 152 #define GST_BUFFER_META(b)         (((GstBufferImpl *)(b))-&gt;item)

 153 
 154 typedef struct
 155 {
 156   GstBuffer buffer;
 157 
 158   gsize slice_size;
 159 
 160   /* the memory blocks */
 161   guint len;
 162   GstMemory *mem[GST_BUFFER_MEM_MAX];
 163 
 164   /* memory of the buffer when allocated from 1 chunk */
 165   GstMemory *bufmem;
 166 
 167   /* FIXME, make metadata allocation more efficient by using part of the
 168    * GstBufferImpl */
 169   GstMetaItem *item;

 170 } GstBufferImpl;
 171 
































 172 
 173 static gboolean
 174 _is_span (GstMemory ** mem, gsize len, gsize * poffset, GstMemory ** parent)
 175 {
 176   GstMemory *mcur, *mprv;
 177   gboolean have_offset = FALSE;
 178   gsize i;
 179 
 180   mcur = mprv = NULL;
 181 
 182   for (i = 0; i &lt; len; i++) {
 183     if (mcur)
 184       mprv = mcur;
 185     mcur = mem[i];
 186 
 187     if (mprv &amp;&amp; mcur) {
 188       gsize poffs;
 189 
 190       /* check if memory is contiguous */
 191       if (!gst_memory_is_span (mprv, mcur, &amp;poffs))
</pre>
<hr />
<pre>
 271   return result;
 272 }
 273 
 274 static void
 275 _replace_memory (GstBuffer * buffer, guint len, guint idx, guint length,
 276     GstMemory * mem)
 277 {
 278   gsize end, i;
 279 
 280   end = idx + length;
 281 
 282   GST_CAT_LOG (GST_CAT_BUFFER,
 283       &quot;buffer %p replace %u-%&quot; G_GSIZE_FORMAT &quot; with memory %p&quot;, buffer, idx,
 284       end, mem);
 285 
 286   /* unref old memory */
 287   for (i = idx; i &lt; end; i++) {
 288     GstMemory *old = GST_BUFFER_MEM_PTR (buffer, i);
 289 
 290     gst_memory_unlock (old, GST_LOCK_FLAG_EXCLUSIVE);


 291     gst_memory_unref (old);
 292   }
 293 
 294   if (mem != NULL) {
 295     /* replace with single memory */


 296     gst_memory_lock (mem, GST_LOCK_FLAG_EXCLUSIVE);
 297     GST_BUFFER_MEM_PTR (buffer, idx) = mem;
 298     idx++;
 299     length--;
 300   }
 301 
 302   if (end &lt; len) {
 303     memmove (&amp;GST_BUFFER_MEM_PTR (buffer, idx),
 304         &amp;GST_BUFFER_MEM_PTR (buffer, end), (len - end) * sizeof (gpointer));
 305   }
 306   GST_BUFFER_MEM_LEN (buffer) = len - length;
 307   GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
 308 }
 309 
 310 /**
 311  * gst_buffer_get_flags:
 312  * @buffer: a #GstBuffer
 313  *
 314  * Get the #GstBufferFlags flags set on this buffer.
 315  *
</pre>
<hr />
<pre>
 418     /* FIXME, there is room for improvement here: We could only try to merge
 419      * 2 buffers to make some room. If we can&#39;t efficiently merge 2 buffers we
 420      * could try to only merge the two smallest buffers to avoid memcpy, etc. */
 421     GST_CAT_DEBUG (GST_CAT_PERFORMANCE, &quot;memory array overflow in buffer %p&quot;,
 422         buffer);
 423     _replace_memory (buffer, len, 0, len, _get_merged_memory (buffer, 0, len));
 424     /* we now have 1 single spanned buffer */
 425     len = 1;
 426   }
 427 
 428   if (idx == -1)
 429     idx = len;
 430 
 431   for (i = len; i &gt; idx; i--) {
 432     /* move buffers to insert, FIXME, we need to insert first and then merge */
 433     GST_BUFFER_MEM_PTR (buffer, i) = GST_BUFFER_MEM_PTR (buffer, i - 1);
 434   }
 435   /* and insert the new buffer */
 436   GST_BUFFER_MEM_PTR (buffer, idx) = mem;
 437   GST_BUFFER_MEM_LEN (buffer) = len + 1;


 438 
 439   GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
 440 }
 441 
 442 GST_DEFINE_MINI_OBJECT_TYPE (GstBuffer, gst_buffer);
 443 
 444 void
 445 _priv_gst_buffer_initialize (void)
 446 {
 447   _gst_buffer_type = gst_buffer_get_type ();





 448 }
 449 
 450 /**
 451  * gst_buffer_get_max_memory:
 452  *
 453  * Get the maximum amount of memory blocks that a buffer can hold. This is a
 454  * compile time constant that can be queried with the function.
 455  *
 456  * When more memory blocks are added, existing memory blocks will be merged
 457  * together to make room for the new block.
 458  *
 459  * Returns: the maximum amount of memory blocks that a buffer can hold.
 460  *
 461  * Since: 1.2
 462  */
 463 guint
 464 gst_buffer_get_max_memory (void)
 465 {
 466   return GST_BUFFER_MEM_MAX;
 467 }
</pre>
<hr />
<pre>
 556     for (i = 0; i &lt; len &amp;&amp; left &gt; 0; i++) {
 557       GstMemory *mem = GST_BUFFER_MEM_PTR (src, i);
 558 
 559       bsize = gst_memory_get_sizes (mem, NULL, NULL);
 560 
 561       if (bsize &lt;= skip) {
 562         /* don&#39;t copy buffer */
 563         skip -= bsize;
 564       } else {
 565         GstMemory *newmem = NULL;
 566         gsize tocopy;
 567 
 568         tocopy = MIN (bsize - skip, left);
 569 
 570         if (tocopy &lt; bsize &amp;&amp; !deep &amp;&amp; !GST_MEMORY_IS_NO_SHARE (mem)) {
 571           /* we need to clip something */
 572           newmem = gst_memory_share (mem, skip, tocopy);
 573           if (newmem) {
 574             gst_memory_lock (newmem, GST_LOCK_FLAG_EXCLUSIVE);
 575             skip = 0;
<span class="line-modified"> 576         }</span>
 577         }
 578 
 579         if (deep || GST_MEMORY_IS_NO_SHARE (mem) || (!newmem &amp;&amp; tocopy &lt; bsize)) {
 580           /* deep copy or we&#39;re not allowed to share this memory
 581            * between buffers, always copy then */
 582           newmem = gst_memory_copy (mem, skip, tocopy);
 583           if (newmem) {
 584             gst_memory_lock (newmem, GST_LOCK_FLAG_EXCLUSIVE);
<span class="line-modified"> 585           skip = 0;</span>
 586           }
 587         } else if (!newmem) {
 588           newmem = _memory_get_exclusive_reference (mem);
 589         }
 590 
 591         if (!newmem) {
 592           gst_buffer_remove_memory_range (dest, dest_len, -1);
 593           return FALSE;
 594         }
 595 
 596         _memory_add (dest, -1, newmem);
 597         left -= tocopy;
 598       }
 599     }
 600     if (flags &amp; GST_BUFFER_COPY_MERGE) {
 601       GstMemory *mem;
 602 
 603       len = GST_BUFFER_MEM_LEN (dest);
 604       mem = _get_merged_memory (dest, 0, len);
 605       if (!mem) {
</pre>
<hr />
<pre>
 623        * structure has changed and the memory meta becomes meaningless.
 624        */
 625       if ((region || !(flags &amp; GST_BUFFER_COPY_MEMORY)
 626               || (flags &amp; GST_BUFFER_COPY_MERGE))
 627           &amp;&amp; gst_meta_api_type_has_tag (info-&gt;api, _gst_meta_tag_memory)) {
 628         GST_CAT_DEBUG (GST_CAT_BUFFER,
 629             &quot;don&#39;t copy memory meta %p of API type %s&quot;, meta,
 630             g_type_name (info-&gt;api));
 631       } else if (info-&gt;transform_func) {
 632         GstMetaTransformCopy copy_data;
 633 
 634         copy_data.region = region;
 635         copy_data.offset = offset;
 636         copy_data.size = size;
 637 
 638         if (!info-&gt;transform_func (dest, meta, src,
 639                 _gst_meta_transform_copy, &amp;copy_data)) {
 640           GST_CAT_ERROR (GST_CAT_BUFFER,
 641               &quot;failed to copy meta %p of API type %s&quot;, meta,
 642               g_type_name (info-&gt;api));

 643       }
 644     }
 645   }
<span class="line-removed"> 646   }</span>
 647 
 648   return TRUE;
 649 }
 650 
 651 static GstBuffer *
 652 gst_buffer_copy_with_flags (const GstBuffer * buffer, GstBufferCopyFlags flags)
 653 {
 654   GstBuffer *copy;
 655 
 656   g_return_val_if_fail (buffer != NULL, NULL);
 657 
 658   /* create a fresh new buffer */
 659   copy = gst_buffer_new ();
 660 
 661   /* copy what the &#39;flags&#39; want from our parent */
 662   /* FIXME why we can&#39;t pass const to gst_buffer_copy_into() ? */
 663   if (!gst_buffer_copy_into (copy, (GstBuffer *) buffer, flags, 0, -1))
 664     gst_buffer_replace (&amp;copy, NULL);
 665 
 666   if (copy)
</pre>
<hr />
<pre>
 729     GstMeta *meta = &amp;walk-&gt;meta;
 730     const GstMetaInfo *info = meta-&gt;info;
 731 
 732     /* call free_func if any */
 733     if (info-&gt;free_func)
 734       info-&gt;free_func (meta, buffer);
 735 
 736     next = walk-&gt;next;
 737     /* and free the slice */
 738     g_slice_free1 (ITEM_SIZE (info), walk);
 739   }
 740 
 741   /* get the size, when unreffing the memory, we could also unref the buffer
 742    * itself */
 743   msize = GST_BUFFER_SLICE_SIZE (buffer);
 744 
 745   /* free our memory */
 746   len = GST_BUFFER_MEM_LEN (buffer);
 747   for (i = 0; i &lt; len; i++) {
 748     gst_memory_unlock (GST_BUFFER_MEM_PTR (buffer, i), GST_LOCK_FLAG_EXCLUSIVE);


 749     gst_memory_unref (GST_BUFFER_MEM_PTR (buffer, i));
 750   }
 751 
 752   /* we set msize to 0 when the buffer is part of the memory block */
 753   if (msize) {
 754 #ifdef USE_POISONING
 755     memset (buffer, 0xff, msize);
 756 #endif
 757     g_slice_free1 (msize, buffer);
 758   } else {
 759     gst_memory_unref (GST_BUFFER_BUFMEM (buffer));
 760   }
 761 }
 762 
 763 static void
 764 gst_buffer_init (GstBufferImpl * buffer, gsize size)
 765 {
 766   gst_mini_object_init (GST_MINI_OBJECT_CAST (buffer), 0, _gst_buffer_type,
 767       (GstMiniObjectCopyFunction) _gst_buffer_copy,
 768       (GstMiniObjectDisposeFunction) _gst_buffer_dispose,
</pre>
<hr />
<pre>
 950 }
 951 
 952 /**
 953  * gst_buffer_new_wrapped:
 954  * @data: (array length=size) (element-type guint8) (transfer full): data to wrap
 955  * @size: allocated size of @data
 956  *
 957  * Creates a new buffer that wraps the given @data. The memory will be freed
 958  * with g_free and will be marked writable.
 959  *
 960  * MT safe.
 961  *
 962  * Returns: (transfer full): a new #GstBuffer
 963  */
 964 GstBuffer *
 965 gst_buffer_new_wrapped (gpointer data, gsize size)
 966 {
 967   return gst_buffer_new_wrapped_full (0, data, size, 0, size, data, g_free);
 968 }
 969 



























 970 /**
 971  * gst_buffer_n_memory:
 972  * @buffer: a #GstBuffer.
 973  *
 974  * Get the amount of memory blocks that this buffer has. This amount is never
 975  * larger than what gst_buffer_get_max_memory() returns.
 976  *
 977  * Returns: the number of memory blocks this buffer is made of.
 978  */
 979 guint
 980 gst_buffer_n_memory (GstBuffer * buffer)
 981 {
 982   g_return_val_if_fail (GST_IS_BUFFER (buffer), 0);
 983 
 984   return GST_BUFFER_MEM_LEN (buffer);
 985 }
 986 
 987 /**
 988  * gst_buffer_prepend_memory:
 989  * @buffer: a #GstBuffer.
</pre>
<hr />
<pre>
1043       (idx &gt;= 0 &amp;&amp; idx &lt;= GST_BUFFER_MEM_LEN (buffer)));
1044 
1045   tmp = _memory_get_exclusive_reference (mem);
1046   g_return_if_fail (tmp != NULL);
1047   gst_memory_unref (mem);
1048   _memory_add (buffer, idx, tmp);
1049 }
1050 
1051 static GstMemory *
1052 _get_mapped (GstBuffer * buffer, guint idx, GstMapInfo * info,
1053     GstMapFlags flags)
1054 {
1055   GstMemory *mem, *mapped;
1056 
1057   mem = gst_memory_ref (GST_BUFFER_MEM_PTR (buffer, idx));
1058 
1059   mapped = gst_memory_make_mapped (mem, info, flags);
1060 
1061   if (mapped != mem) {
1062     /* memory changed, lock new memory */


1063     gst_memory_lock (mapped, GST_LOCK_FLAG_EXCLUSIVE);
1064     GST_BUFFER_MEM_PTR (buffer, idx) = mapped;
1065     /* unlock old memory */
1066     gst_memory_unlock (mem, GST_LOCK_FLAG_EXCLUSIVE);


1067     GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
1068   }
1069   gst_memory_unref (mem);
1070 
1071   return mapped;
1072 }
1073 
1074 /**
1075  * gst_buffer_peek_memory:
1076  * @buffer: a #GstBuffer.
1077  * @idx: an index
1078  *
1079  * Get the memory block at @idx in @buffer. The memory block stays valid until
1080  * the memory block in @buffer is removed, replaced or merged, typically with
1081  * any call that modifies the memory in @buffer.
1082  *
1083  * Returns: (transfer none) (nullable): the #GstMemory at @idx.
1084  */
1085 GstMemory *
1086 gst_buffer_peek_memory (GstBuffer * buffer, guint idx)
</pre>
<hr />
<pre>
1660     }
1661     /* clip other buffers */
1662     else
1663       left = MIN (bsize - offset, size);
1664 
1665     if (offset != 0 || left != bsize) {
1666       if (gst_memory_is_writable (mem)) {
1667         gst_memory_resize (mem, offset, left);
1668       } else {
1669         GstMemory *newmem = NULL;
1670 
1671         if (!GST_MEMORY_IS_NO_SHARE (mem))
1672           newmem = gst_memory_share (mem, offset, left);
1673 
1674         if (!newmem)
1675           newmem = gst_memory_copy (mem, offset, left);
1676 
1677         if (newmem == NULL)
1678           return FALSE;
1679 


1680         gst_memory_lock (newmem, GST_LOCK_FLAG_EXCLUSIVE);
1681         GST_BUFFER_MEM_PTR (buffer, i) = newmem;
1682         gst_memory_unlock (mem, GST_LOCK_FLAG_EXCLUSIVE);


1683         gst_memory_unref (mem);
1684 
1685         GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
1686       }
1687     }
1688 
1689     offset = noffs;
1690     size -= left;
1691   }
1692 
1693   return TRUE;
1694 }
1695 
1696 /**
1697  * gst_buffer_map:
1698  * @buffer: a #GstBuffer.
1699  * @info: (out): info about the mapping
1700  * @flags: flags for the mapping
1701  *
1702  * This function fills @info with the #GstMapInfo of all merged memory
</pre>
<hr />
<pre>
2122  */
2123 GstBuffer *
2124 gst_buffer_append_region (GstBuffer * buf1, GstBuffer * buf2, gssize offset,
2125     gssize size)
2126 {
2127   gsize i, len;
2128 
2129   g_return_val_if_fail (GST_IS_BUFFER (buf1), NULL);
2130   g_return_val_if_fail (GST_IS_BUFFER (buf2), NULL);
2131 
2132   buf1 = gst_buffer_make_writable (buf1);
2133   buf2 = gst_buffer_make_writable (buf2);
2134 
2135   gst_buffer_resize (buf2, offset, size);
2136 
2137   len = GST_BUFFER_MEM_LEN (buf2);
2138   for (i = 0; i &lt; len; i++) {
2139     GstMemory *mem;
2140 
2141     mem = GST_BUFFER_MEM_PTR (buf2, i);


2142     GST_BUFFER_MEM_PTR (buf2, i) = NULL;
2143     _memory_add (buf1, -1, mem);
2144   }
2145 
2146   GST_BUFFER_MEM_LEN (buf2) = 0;
2147   GST_BUFFER_FLAG_SET (buf2, GST_BUFFER_FLAG_TAG_MEMORY);
2148   gst_buffer_unref (buf2);
2149 
2150   return buf1;
2151 }
2152 
2153 /**
2154  * gst_buffer_get_meta:
2155  * @buffer: a #GstBuffer
2156  * @api: the #GType of an API
2157  *
2158  * Get the metadata for @api on buffer. When there is no such metadata, %NULL is
2159  * returned. If multiple metadata with the given @api are attached to this
2160  * buffer only the first one is returned.  To handle multiple metadata with a
2161  * given API use gst_buffer_iterate_meta() or gst_buffer_foreach_meta() instead
</pre>
<hr />
<pre>
2220 gst_buffer_add_meta (GstBuffer * buffer, const GstMetaInfo * info,
2221     gpointer params)
2222 {
2223   GstMetaItem *item;
2224   GstMeta *result = NULL;
2225   gsize size;
2226 
2227   g_return_val_if_fail (buffer != NULL, NULL);
2228   g_return_val_if_fail (info != NULL, NULL);
2229   g_return_val_if_fail (gst_buffer_is_writable (buffer), NULL);
2230 
2231   /* create a new slice */
2232   size = ITEM_SIZE (info);
2233   /* We warn in gst_meta_register() about metas without
2234    * init function but let&#39;s play safe here and prevent
2235    * uninitialized memory
2236    */
2237   if (!info-&gt;init_func)
2238     item = g_slice_alloc0 (size);
2239   else
<span class="line-modified">2240   item = g_slice_alloc (size);</span>
2241   result = &amp;item-&gt;meta;
2242   result-&gt;info = info;
2243   result-&gt;flags = GST_META_FLAG_NONE;
2244   GST_CAT_DEBUG (GST_CAT_BUFFER,
2245       &quot;alloc metadata %p (%s) of size %&quot; G_GSIZE_FORMAT, result,
2246       g_type_name (info-&gt;type), info-&gt;size);
2247 
2248   /* call the init_func when needed */
2249   if (info-&gt;init_func)
2250     if (!info-&gt;init_func (result, params, buffer))
2251       goto init_failed;
2252 
<span class="line-modified">2253   /* and add to the list of metadata */</span>
<span class="line-modified">2254   item-&gt;next = GST_BUFFER_META (buffer);</span>
<span class="line-modified">2255   GST_BUFFER_META (buffer) = item;</span>







2256 
2257   return result;
2258 
2259 init_failed:
2260   {
2261     g_slice_free1 (size, item);
2262     return NULL;
2263   }
2264 }
2265 
2266 /**
2267  * gst_buffer_remove_meta:
2268  * @buffer: a #GstBuffer
2269  * @meta: a #GstMeta
2270  *
2271  * Remove the metadata for @meta on @buffer.
2272  *
2273  * Returns: %TRUE if the metadata existed and was removed, %FALSE if no such
2274  * metadata was on @buffer.
2275  */
2276 gboolean
2277 gst_buffer_remove_meta (GstBuffer * buffer, GstMeta * meta)
2278 {
2279   GstMetaItem *walk, *prev;
2280 
2281   g_return_val_if_fail (buffer != NULL, FALSE);
2282   g_return_val_if_fail (meta != NULL, FALSE);
2283   g_return_val_if_fail (gst_buffer_is_writable (buffer), FALSE);
2284   g_return_val_if_fail (!GST_META_FLAG_IS_SET (meta, GST_META_FLAG_LOCKED),
2285       FALSE);
2286 
2287   /* find the metadata and delete */
2288   prev = GST_BUFFER_META (buffer);
2289   for (walk = prev; walk; walk = walk-&gt;next) {
2290     GstMeta *m = &amp;walk-&gt;meta;
2291     if (m == meta) {
2292       const GstMetaInfo *info = meta-&gt;info;
2293 
2294       /* remove from list */







2295       if (GST_BUFFER_META (buffer) == walk)
2296         GST_BUFFER_META (buffer) = walk-&gt;next;
2297       else
2298         prev-&gt;next = walk-&gt;next;

2299       /* call free_func if any */
2300       if (info-&gt;free_func)
2301         info-&gt;free_func (m, buffer);
2302 
2303       /* and free the slice */
2304       g_slice_free1 (ITEM_SIZE (info), walk);
2305       break;
2306     }
2307     prev = walk;
2308   }
2309   return walk != NULL;
2310 }
2311 
2312 /**
2313  * gst_buffer_iterate_meta: (skip)
2314  * @buffer: a #GstBuffer
2315  * @state: (out caller-allocates): an opaque state pointer
2316  *
2317  * Retrieve the next #GstMeta after @current. If @state points
2318  * to %NULL, the first metadata is returned.
</pre>
<hr />
<pre>
2414   /* find the metadata and delete */
2415   prev = GST_BUFFER_META (buffer);
2416   for (walk = prev; walk; walk = next) {
2417     GstMeta *m, *new;
2418 
2419     m = new = &amp;walk-&gt;meta;
2420     next = walk-&gt;next;
2421 
2422     res = func (buffer, &amp;new, user_data);
2423 
2424     if (new == NULL) {
2425       const GstMetaInfo *info = m-&gt;info;
2426 
2427       GST_CAT_DEBUG (GST_CAT_BUFFER, &quot;remove metadata %p (%s)&quot;, m,
2428           g_type_name (info-&gt;type));
2429 
2430       g_return_val_if_fail (gst_buffer_is_writable (buffer), FALSE);
2431       g_return_val_if_fail (!GST_META_FLAG_IS_SET (m, GST_META_FLAG_LOCKED),
2432           FALSE);
2433 







2434       /* remove from list */
2435       if (GST_BUFFER_META (buffer) == walk)
<span class="line-modified">2436         GST_BUFFER_META (buffer) = next;</span>
2437       else
2438         prev-&gt;next = next;
2439 
<span class="line-removed">2440       prev = next;</span>
<span class="line-removed">2441 </span>
2442       /* call free_func if any */
2443       if (info-&gt;free_func)
2444         info-&gt;free_func (m, buffer);
2445 
2446       /* and free the slice */
2447       g_slice_free1 (ITEM_SIZE (info), walk);
2448     } else {
2449       prev = walk;
2450     }
2451     if (!res)
2452       break;
2453   }
2454   return res;
2455 }
2456 
2457 /**
2458  * gst_buffer_extract_dup:
2459  * @buffer: a #GstBuffer
2460  * @offset: the offset to extract
2461  * @size: the size to extract
</pre>
<hr />
<pre>
2466  * Extracts a copy of at most @size bytes the data at @offset into
2467  * newly-allocated memory. @dest must be freed using g_free() when done.
2468  *
2469  * Since: 1.0.10
2470  */
2471 
2472 void
2473 gst_buffer_extract_dup (GstBuffer * buffer, gsize offset, gsize size,
2474     gpointer * dest, gsize * dest_size)
2475 {
2476   gsize real_size, alloc_size;
2477 
2478   real_size = gst_buffer_get_size (buffer);
2479 
2480   alloc_size = MIN (real_size - offset, size);
2481   if (alloc_size == 0) {
2482     *dest = NULL;
2483     *dest_size = 0;
2484   } else {
2485     *dest = g_malloc (alloc_size);
<span class="line-modified">2486   *dest_size = gst_buffer_extract (buffer, offset, *dest, size);</span>
<span class="line-modified">2487 }</span>
2488 }
2489 
2490 GST_DEBUG_CATEGORY_STATIC (gst_parent_buffer_meta_debug);
2491 
2492 /**
2493  * gst_buffer_add_parent_buffer_meta:
2494  * @buffer: (transfer none): a #GstBuffer
2495  * @ref: (transfer none): a #GstBuffer to ref
2496  *
2497  * Add a #GstParentBufferMeta to @buffer that holds a reference on
2498  * @ref until the buffer is freed.
2499  *
2500  * Returns: (transfer none) (nullable): The #GstParentBufferMeta that was added to the buffer
2501  *
2502  * Since: 1.6
2503  */
2504 GstParentBufferMeta *
2505 gst_buffer_add_parent_buffer_meta (GstBuffer * buffer, GstBuffer * ref)
2506 {
2507   GstParentBufferMeta *meta;
</pre>
</td>
<td>
<hr />
<pre>
  96  * needed.
  97  *
  98  * Arbitrary extra metadata can be set on a buffer with gst_buffer_add_meta().
  99  * Metadata can be retrieved with gst_buffer_get_meta(). See also #GstMeta
 100  *
 101  * An element should either unref the buffer or push it out on a src pad
 102  * using gst_pad_push() (see #GstPad).
 103  *
 104  * Buffers are usually freed by unreffing them with gst_buffer_unref(). When
 105  * the refcount drops to 0, any memory and metadata pointed to by the buffer is
 106  * unreffed as well. Buffers allocated from a #GstBufferPool will be returned to
 107  * the pool when the refcount drops to 0.
 108  *
 109  * The #GstParentBufferMeta is a meta which can be attached to a #GstBuffer
 110  * to hold a reference to another buffer that is only released when the child
 111  * #GstBuffer is released.
 112  *
 113  * Typically, #GstParentBufferMeta is used when the child buffer is directly
 114  * using the #GstMemory of the parent buffer, and wants to prevent the parent
 115  * buffer from being returned to a buffer pool until the #GstMemory is available
<span class="line-modified"> 116  * for re-use. (Since: 1.6)</span>
 117  *
 118  */
 119 #include &quot;gst_private.h&quot;
 120 
 121 #ifdef HAVE_UNISTD_H
 122 #include &lt;unistd.h&gt;
 123 #endif
 124 #ifdef HAVE_STDLIB_H
 125 #include &lt;stdlib.h&gt;
 126 #endif
 127 
 128 #include &quot;gstbuffer.h&quot;
 129 #include &quot;gstbufferpool.h&quot;
 130 #include &quot;gstinfo.h&quot;
 131 #include &quot;gstutils.h&quot;
 132 #include &quot;gstversion.h&quot;
 133 
 134 GType _gst_buffer_type = 0;
 135 
<span class="line-modified"> 136 /* info-&gt;size will be sizeof(FooMeta) which contains a GstMeta at the beginning</span>
<span class="line-modified"> 137  * too, and then there is again a GstMeta in GstMetaItem, so subtract one. */</span>
<span class="line-modified"> 138 #define ITEM_SIZE(info) ((info)-&gt;size + sizeof (GstMetaItem) - sizeof (GstMeta))</span>





 139 
 140 #define GST_BUFFER_MEM_MAX         16
 141 
 142 #define GST_BUFFER_SLICE_SIZE(b)   (((GstBufferImpl *)(b))-&gt;slice_size)
 143 #define GST_BUFFER_MEM_LEN(b)      (((GstBufferImpl *)(b))-&gt;len)
 144 #define GST_BUFFER_MEM_ARRAY(b)    (((GstBufferImpl *)(b))-&gt;mem)
 145 #define GST_BUFFER_MEM_PTR(b,i)    (((GstBufferImpl *)(b))-&gt;mem[i])
 146 #define GST_BUFFER_BUFMEM(b)       (((GstBufferImpl *)(b))-&gt;bufmem)
 147 #define GST_BUFFER_META(b)         (((GstBufferImpl *)(b))-&gt;item)
<span class="line-added"> 148 #define GST_BUFFER_TAIL_META(b)    (((GstBufferImpl *)(b))-&gt;tail_item)</span>
 149 
 150 typedef struct
 151 {
 152   GstBuffer buffer;
 153 
 154   gsize slice_size;
 155 
 156   /* the memory blocks */
 157   guint len;
 158   GstMemory *mem[GST_BUFFER_MEM_MAX];
 159 
 160   /* memory of the buffer when allocated from 1 chunk */
 161   GstMemory *bufmem;
 162 
 163   /* FIXME, make metadata allocation more efficient by using part of the
 164    * GstBufferImpl */
 165   GstMetaItem *item;
<span class="line-added"> 166   GstMetaItem *tail_item;</span>
 167 } GstBufferImpl;
 168 
<span class="line-added"> 169 static gint64 meta_seq;         /* 0 *//* ATOMIC */</span>
<span class="line-added"> 170 </span>
<span class="line-added"> 171 /* TODO: use GLib&#39;s once https://gitlab.gnome.org/GNOME/glib/issues/1076 lands */</span>
<span class="line-added"> 172 #if defined(__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8)</span>
<span class="line-added"> 173 static inline gint64</span>
<span class="line-added"> 174 gst_atomic_int64_inc (volatile gint64 * atomic)</span>
<span class="line-added"> 175 {</span>
<span class="line-added"> 176   return __sync_fetch_and_add (atomic, 1);</span>
<span class="line-added"> 177 }</span>
<span class="line-added"> 178 #elif defined (G_PLATFORM_WIN32)</span>
<span class="line-added"> 179 #include &lt;windows.h&gt;</span>
<span class="line-added"> 180 static inline gint64</span>
<span class="line-added"> 181 gst_atomic_int64_inc (volatile gint64 * atomic)</span>
<span class="line-added"> 182 {</span>
<span class="line-added"> 183   return InterlockedExchangeAdd64 (atomic, 1);</span>
<span class="line-added"> 184 }</span>
<span class="line-added"> 185 #else</span>
<span class="line-added"> 186 #warning No 64-bit atomic int defined for this platform/toolchain!</span>
<span class="line-added"> 187 #define NO_64BIT_ATOMIC_INT_FOR_PLATFORM</span>
<span class="line-added"> 188 G_LOCK_DEFINE_STATIC (meta_seq);</span>
<span class="line-added"> 189 static inline gint64</span>
<span class="line-added"> 190 gst_atomic_int64_inc (volatile gint64 * atomic)</span>
<span class="line-added"> 191 {</span>
<span class="line-added"> 192   gint64 ret;</span>
<span class="line-added"> 193 </span>
<span class="line-added"> 194   G_LOCK (meta_seq);</span>
<span class="line-added"> 195   ret = *atomic++;</span>
<span class="line-added"> 196   G_UNLOCK (meta_seq);</span>
<span class="line-added"> 197 </span>
<span class="line-added"> 198   return ret;</span>
<span class="line-added"> 199 }</span>
<span class="line-added"> 200 #endif</span>
 201 
 202 static gboolean
 203 _is_span (GstMemory ** mem, gsize len, gsize * poffset, GstMemory ** parent)
 204 {
 205   GstMemory *mcur, *mprv;
 206   gboolean have_offset = FALSE;
 207   gsize i;
 208 
 209   mcur = mprv = NULL;
 210 
 211   for (i = 0; i &lt; len; i++) {
 212     if (mcur)
 213       mprv = mcur;
 214     mcur = mem[i];
 215 
 216     if (mprv &amp;&amp; mcur) {
 217       gsize poffs;
 218 
 219       /* check if memory is contiguous */
 220       if (!gst_memory_is_span (mprv, mcur, &amp;poffs))
</pre>
<hr />
<pre>
 300   return result;
 301 }
 302 
 303 static void
 304 _replace_memory (GstBuffer * buffer, guint len, guint idx, guint length,
 305     GstMemory * mem)
 306 {
 307   gsize end, i;
 308 
 309   end = idx + length;
 310 
 311   GST_CAT_LOG (GST_CAT_BUFFER,
 312       &quot;buffer %p replace %u-%&quot; G_GSIZE_FORMAT &quot; with memory %p&quot;, buffer, idx,
 313       end, mem);
 314 
 315   /* unref old memory */
 316   for (i = idx; i &lt; end; i++) {
 317     GstMemory *old = GST_BUFFER_MEM_PTR (buffer, i);
 318 
 319     gst_memory_unlock (old, GST_LOCK_FLAG_EXCLUSIVE);
<span class="line-added"> 320     gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (old),</span>
<span class="line-added"> 321         GST_MINI_OBJECT_CAST (buffer));</span>
 322     gst_memory_unref (old);
 323   }
 324 
 325   if (mem != NULL) {
 326     /* replace with single memory */
<span class="line-added"> 327     gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (mem),</span>
<span class="line-added"> 328         GST_MINI_OBJECT_CAST (buffer));</span>
 329     gst_memory_lock (mem, GST_LOCK_FLAG_EXCLUSIVE);
 330     GST_BUFFER_MEM_PTR (buffer, idx) = mem;
 331     idx++;
 332     length--;
 333   }
 334 
 335   if (end &lt; len) {
 336     memmove (&amp;GST_BUFFER_MEM_PTR (buffer, idx),
 337         &amp;GST_BUFFER_MEM_PTR (buffer, end), (len - end) * sizeof (gpointer));
 338   }
 339   GST_BUFFER_MEM_LEN (buffer) = len - length;
 340   GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
 341 }
 342 
 343 /**
 344  * gst_buffer_get_flags:
 345  * @buffer: a #GstBuffer
 346  *
 347  * Get the #GstBufferFlags flags set on this buffer.
 348  *
</pre>
<hr />
<pre>
 451     /* FIXME, there is room for improvement here: We could only try to merge
 452      * 2 buffers to make some room. If we can&#39;t efficiently merge 2 buffers we
 453      * could try to only merge the two smallest buffers to avoid memcpy, etc. */
 454     GST_CAT_DEBUG (GST_CAT_PERFORMANCE, &quot;memory array overflow in buffer %p&quot;,
 455         buffer);
 456     _replace_memory (buffer, len, 0, len, _get_merged_memory (buffer, 0, len));
 457     /* we now have 1 single spanned buffer */
 458     len = 1;
 459   }
 460 
 461   if (idx == -1)
 462     idx = len;
 463 
 464   for (i = len; i &gt; idx; i--) {
 465     /* move buffers to insert, FIXME, we need to insert first and then merge */
 466     GST_BUFFER_MEM_PTR (buffer, i) = GST_BUFFER_MEM_PTR (buffer, i - 1);
 467   }
 468   /* and insert the new buffer */
 469   GST_BUFFER_MEM_PTR (buffer, idx) = mem;
 470   GST_BUFFER_MEM_LEN (buffer) = len + 1;
<span class="line-added"> 471   gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (mem),</span>
<span class="line-added"> 472       GST_MINI_OBJECT_CAST (buffer));</span>
 473 
 474   GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
 475 }
 476 
 477 GST_DEFINE_MINI_OBJECT_TYPE (GstBuffer, gst_buffer);
 478 
 479 void
 480 _priv_gst_buffer_initialize (void)
 481 {
 482   _gst_buffer_type = gst_buffer_get_type ();
<span class="line-added"> 483 </span>
<span class="line-added"> 484 #ifdef NO_64BIT_ATOMIC_INT_FOR_PLATFORM</span>
<span class="line-added"> 485   GST_CAT_WARNING (GST_CAT_PERFORMANCE,</span>
<span class="line-added"> 486       &quot;No 64-bit atomic int defined for this platform/toolchain!&quot;);</span>
<span class="line-added"> 487 #endif</span>
 488 }
 489 
 490 /**
 491  * gst_buffer_get_max_memory:
 492  *
 493  * Get the maximum amount of memory blocks that a buffer can hold. This is a
 494  * compile time constant that can be queried with the function.
 495  *
 496  * When more memory blocks are added, existing memory blocks will be merged
 497  * together to make room for the new block.
 498  *
 499  * Returns: the maximum amount of memory blocks that a buffer can hold.
 500  *
 501  * Since: 1.2
 502  */
 503 guint
 504 gst_buffer_get_max_memory (void)
 505 {
 506   return GST_BUFFER_MEM_MAX;
 507 }
</pre>
<hr />
<pre>
 596     for (i = 0; i &lt; len &amp;&amp; left &gt; 0; i++) {
 597       GstMemory *mem = GST_BUFFER_MEM_PTR (src, i);
 598 
 599       bsize = gst_memory_get_sizes (mem, NULL, NULL);
 600 
 601       if (bsize &lt;= skip) {
 602         /* don&#39;t copy buffer */
 603         skip -= bsize;
 604       } else {
 605         GstMemory *newmem = NULL;
 606         gsize tocopy;
 607 
 608         tocopy = MIN (bsize - skip, left);
 609 
 610         if (tocopy &lt; bsize &amp;&amp; !deep &amp;&amp; !GST_MEMORY_IS_NO_SHARE (mem)) {
 611           /* we need to clip something */
 612           newmem = gst_memory_share (mem, skip, tocopy);
 613           if (newmem) {
 614             gst_memory_lock (newmem, GST_LOCK_FLAG_EXCLUSIVE);
 615             skip = 0;
<span class="line-modified"> 616           }</span>
 617         }
 618 
 619         if (deep || GST_MEMORY_IS_NO_SHARE (mem) || (!newmem &amp;&amp; tocopy &lt; bsize)) {
 620           /* deep copy or we&#39;re not allowed to share this memory
 621            * between buffers, always copy then */
 622           newmem = gst_memory_copy (mem, skip, tocopy);
 623           if (newmem) {
 624             gst_memory_lock (newmem, GST_LOCK_FLAG_EXCLUSIVE);
<span class="line-modified"> 625             skip = 0;</span>
 626           }
 627         } else if (!newmem) {
 628           newmem = _memory_get_exclusive_reference (mem);
 629         }
 630 
 631         if (!newmem) {
 632           gst_buffer_remove_memory_range (dest, dest_len, -1);
 633           return FALSE;
 634         }
 635 
 636         _memory_add (dest, -1, newmem);
 637         left -= tocopy;
 638       }
 639     }
 640     if (flags &amp; GST_BUFFER_COPY_MERGE) {
 641       GstMemory *mem;
 642 
 643       len = GST_BUFFER_MEM_LEN (dest);
 644       mem = _get_merged_memory (dest, 0, len);
 645       if (!mem) {
</pre>
<hr />
<pre>
 663        * structure has changed and the memory meta becomes meaningless.
 664        */
 665       if ((region || !(flags &amp; GST_BUFFER_COPY_MEMORY)
 666               || (flags &amp; GST_BUFFER_COPY_MERGE))
 667           &amp;&amp; gst_meta_api_type_has_tag (info-&gt;api, _gst_meta_tag_memory)) {
 668         GST_CAT_DEBUG (GST_CAT_BUFFER,
 669             &quot;don&#39;t copy memory meta %p of API type %s&quot;, meta,
 670             g_type_name (info-&gt;api));
 671       } else if (info-&gt;transform_func) {
 672         GstMetaTransformCopy copy_data;
 673 
 674         copy_data.region = region;
 675         copy_data.offset = offset;
 676         copy_data.size = size;
 677 
 678         if (!info-&gt;transform_func (dest, meta, src,
 679                 _gst_meta_transform_copy, &amp;copy_data)) {
 680           GST_CAT_ERROR (GST_CAT_BUFFER,
 681               &quot;failed to copy meta %p of API type %s&quot;, meta,
 682               g_type_name (info-&gt;api));
<span class="line-added"> 683         }</span>
 684       }
 685     }
 686   }

 687 
 688   return TRUE;
 689 }
 690 
 691 static GstBuffer *
 692 gst_buffer_copy_with_flags (const GstBuffer * buffer, GstBufferCopyFlags flags)
 693 {
 694   GstBuffer *copy;
 695 
 696   g_return_val_if_fail (buffer != NULL, NULL);
 697 
 698   /* create a fresh new buffer */
 699   copy = gst_buffer_new ();
 700 
 701   /* copy what the &#39;flags&#39; want from our parent */
 702   /* FIXME why we can&#39;t pass const to gst_buffer_copy_into() ? */
 703   if (!gst_buffer_copy_into (copy, (GstBuffer *) buffer, flags, 0, -1))
 704     gst_buffer_replace (&amp;copy, NULL);
 705 
 706   if (copy)
</pre>
<hr />
<pre>
 769     GstMeta *meta = &amp;walk-&gt;meta;
 770     const GstMetaInfo *info = meta-&gt;info;
 771 
 772     /* call free_func if any */
 773     if (info-&gt;free_func)
 774       info-&gt;free_func (meta, buffer);
 775 
 776     next = walk-&gt;next;
 777     /* and free the slice */
 778     g_slice_free1 (ITEM_SIZE (info), walk);
 779   }
 780 
 781   /* get the size, when unreffing the memory, we could also unref the buffer
 782    * itself */
 783   msize = GST_BUFFER_SLICE_SIZE (buffer);
 784 
 785   /* free our memory */
 786   len = GST_BUFFER_MEM_LEN (buffer);
 787   for (i = 0; i &lt; len; i++) {
 788     gst_memory_unlock (GST_BUFFER_MEM_PTR (buffer, i), GST_LOCK_FLAG_EXCLUSIVE);
<span class="line-added"> 789     gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (GST_BUFFER_MEM_PTR</span>
<span class="line-added"> 790             (buffer, i)), GST_MINI_OBJECT_CAST (buffer));</span>
 791     gst_memory_unref (GST_BUFFER_MEM_PTR (buffer, i));
 792   }
 793 
 794   /* we set msize to 0 when the buffer is part of the memory block */
 795   if (msize) {
 796 #ifdef USE_POISONING
 797     memset (buffer, 0xff, msize);
 798 #endif
 799     g_slice_free1 (msize, buffer);
 800   } else {
 801     gst_memory_unref (GST_BUFFER_BUFMEM (buffer));
 802   }
 803 }
 804 
 805 static void
 806 gst_buffer_init (GstBufferImpl * buffer, gsize size)
 807 {
 808   gst_mini_object_init (GST_MINI_OBJECT_CAST (buffer), 0, _gst_buffer_type,
 809       (GstMiniObjectCopyFunction) _gst_buffer_copy,
 810       (GstMiniObjectDisposeFunction) _gst_buffer_dispose,
</pre>
<hr />
<pre>
 992 }
 993 
 994 /**
 995  * gst_buffer_new_wrapped:
 996  * @data: (array length=size) (element-type guint8) (transfer full): data to wrap
 997  * @size: allocated size of @data
 998  *
 999  * Creates a new buffer that wraps the given @data. The memory will be freed
1000  * with g_free and will be marked writable.
1001  *
1002  * MT safe.
1003  *
1004  * Returns: (transfer full): a new #GstBuffer
1005  */
1006 GstBuffer *
1007 gst_buffer_new_wrapped (gpointer data, gsize size)
1008 {
1009   return gst_buffer_new_wrapped_full (0, data, size, 0, size, data, g_free);
1010 }
1011 
<span class="line-added">1012 /**</span>
<span class="line-added">1013  * gst_buffer_new_wrapped_bytes:</span>
<span class="line-added">1014  * @bytes: (transfer none): a #GBytes to wrap</span>
<span class="line-added">1015  *</span>
<span class="line-added">1016  * Creates a new #GstBuffer that wraps the given @bytes. The data inside</span>
<span class="line-added">1017  * @bytes cannot be %NULL and the resulting buffer will be marked as read only.</span>
<span class="line-added">1018  *</span>
<span class="line-added">1019  * MT safe.</span>
<span class="line-added">1020  *</span>
<span class="line-added">1021  * Returns: (transfer full): a new #GstBuffer wrapping @bytes</span>
<span class="line-added">1022  *</span>
<span class="line-added">1023  * Since: 1.16</span>
<span class="line-added">1024  */</span>
<span class="line-added">1025 GstBuffer *</span>
<span class="line-added">1026 gst_buffer_new_wrapped_bytes (GBytes * bytes)</span>
<span class="line-added">1027 {</span>
<span class="line-added">1028   guint8 *bytes_data;</span>
<span class="line-added">1029   gsize size;</span>
<span class="line-added">1030 </span>
<span class="line-added">1031   g_return_val_if_fail (bytes != NULL, NULL);</span>
<span class="line-added">1032   bytes_data = (guint8 *) g_bytes_get_data (bytes, &amp;size);</span>
<span class="line-added">1033   g_return_val_if_fail (bytes_data != NULL, NULL);</span>
<span class="line-added">1034 </span>
<span class="line-added">1035   return gst_buffer_new_wrapped_full (GST_MEMORY_FLAG_READONLY, bytes_data,</span>
<span class="line-added">1036       size, 0, size, g_bytes_ref (bytes), (GDestroyNotify) g_bytes_unref);</span>
<span class="line-added">1037 }</span>
<span class="line-added">1038 </span>
1039 /**
1040  * gst_buffer_n_memory:
1041  * @buffer: a #GstBuffer.
1042  *
1043  * Get the amount of memory blocks that this buffer has. This amount is never
1044  * larger than what gst_buffer_get_max_memory() returns.
1045  *
1046  * Returns: the number of memory blocks this buffer is made of.
1047  */
1048 guint
1049 gst_buffer_n_memory (GstBuffer * buffer)
1050 {
1051   g_return_val_if_fail (GST_IS_BUFFER (buffer), 0);
1052 
1053   return GST_BUFFER_MEM_LEN (buffer);
1054 }
1055 
1056 /**
1057  * gst_buffer_prepend_memory:
1058  * @buffer: a #GstBuffer.
</pre>
<hr />
<pre>
1112       (idx &gt;= 0 &amp;&amp; idx &lt;= GST_BUFFER_MEM_LEN (buffer)));
1113 
1114   tmp = _memory_get_exclusive_reference (mem);
1115   g_return_if_fail (tmp != NULL);
1116   gst_memory_unref (mem);
1117   _memory_add (buffer, idx, tmp);
1118 }
1119 
1120 static GstMemory *
1121 _get_mapped (GstBuffer * buffer, guint idx, GstMapInfo * info,
1122     GstMapFlags flags)
1123 {
1124   GstMemory *mem, *mapped;
1125 
1126   mem = gst_memory_ref (GST_BUFFER_MEM_PTR (buffer, idx));
1127 
1128   mapped = gst_memory_make_mapped (mem, info, flags);
1129 
1130   if (mapped != mem) {
1131     /* memory changed, lock new memory */
<span class="line-added">1132     gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (mapped),</span>
<span class="line-added">1133         GST_MINI_OBJECT_CAST (buffer));</span>
1134     gst_memory_lock (mapped, GST_LOCK_FLAG_EXCLUSIVE);
1135     GST_BUFFER_MEM_PTR (buffer, idx) = mapped;
1136     /* unlock old memory */
1137     gst_memory_unlock (mem, GST_LOCK_FLAG_EXCLUSIVE);
<span class="line-added">1138     gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (mem),</span>
<span class="line-added">1139         GST_MINI_OBJECT_CAST (buffer));</span>
1140     GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
1141   }
1142   gst_memory_unref (mem);
1143 
1144   return mapped;
1145 }
1146 
1147 /**
1148  * gst_buffer_peek_memory:
1149  * @buffer: a #GstBuffer.
1150  * @idx: an index
1151  *
1152  * Get the memory block at @idx in @buffer. The memory block stays valid until
1153  * the memory block in @buffer is removed, replaced or merged, typically with
1154  * any call that modifies the memory in @buffer.
1155  *
1156  * Returns: (transfer none) (nullable): the #GstMemory at @idx.
1157  */
1158 GstMemory *
1159 gst_buffer_peek_memory (GstBuffer * buffer, guint idx)
</pre>
<hr />
<pre>
1733     }
1734     /* clip other buffers */
1735     else
1736       left = MIN (bsize - offset, size);
1737 
1738     if (offset != 0 || left != bsize) {
1739       if (gst_memory_is_writable (mem)) {
1740         gst_memory_resize (mem, offset, left);
1741       } else {
1742         GstMemory *newmem = NULL;
1743 
1744         if (!GST_MEMORY_IS_NO_SHARE (mem))
1745           newmem = gst_memory_share (mem, offset, left);
1746 
1747         if (!newmem)
1748           newmem = gst_memory_copy (mem, offset, left);
1749 
1750         if (newmem == NULL)
1751           return FALSE;
1752 
<span class="line-added">1753         gst_mini_object_add_parent (GST_MINI_OBJECT_CAST (newmem),</span>
<span class="line-added">1754             GST_MINI_OBJECT_CAST (buffer));</span>
1755         gst_memory_lock (newmem, GST_LOCK_FLAG_EXCLUSIVE);
1756         GST_BUFFER_MEM_PTR (buffer, i) = newmem;
1757         gst_memory_unlock (mem, GST_LOCK_FLAG_EXCLUSIVE);
<span class="line-added">1758         gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (mem),</span>
<span class="line-added">1759             GST_MINI_OBJECT_CAST (buffer));</span>
1760         gst_memory_unref (mem);
1761 
1762         GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_TAG_MEMORY);
1763       }
1764     }
1765 
1766     offset = noffs;
1767     size -= left;
1768   }
1769 
1770   return TRUE;
1771 }
1772 
1773 /**
1774  * gst_buffer_map:
1775  * @buffer: a #GstBuffer.
1776  * @info: (out): info about the mapping
1777  * @flags: flags for the mapping
1778  *
1779  * This function fills @info with the #GstMapInfo of all merged memory
</pre>
<hr />
<pre>
2199  */
2200 GstBuffer *
2201 gst_buffer_append_region (GstBuffer * buf1, GstBuffer * buf2, gssize offset,
2202     gssize size)
2203 {
2204   gsize i, len;
2205 
2206   g_return_val_if_fail (GST_IS_BUFFER (buf1), NULL);
2207   g_return_val_if_fail (GST_IS_BUFFER (buf2), NULL);
2208 
2209   buf1 = gst_buffer_make_writable (buf1);
2210   buf2 = gst_buffer_make_writable (buf2);
2211 
2212   gst_buffer_resize (buf2, offset, size);
2213 
2214   len = GST_BUFFER_MEM_LEN (buf2);
2215   for (i = 0; i &lt; len; i++) {
2216     GstMemory *mem;
2217 
2218     mem = GST_BUFFER_MEM_PTR (buf2, i);
<span class="line-added">2219     gst_mini_object_remove_parent (GST_MINI_OBJECT_CAST (mem),</span>
<span class="line-added">2220         GST_MINI_OBJECT_CAST (buf2));</span>
2221     GST_BUFFER_MEM_PTR (buf2, i) = NULL;
2222     _memory_add (buf1, -1, mem);
2223   }
2224 
2225   GST_BUFFER_MEM_LEN (buf2) = 0;
2226   GST_BUFFER_FLAG_SET (buf2, GST_BUFFER_FLAG_TAG_MEMORY);
2227   gst_buffer_unref (buf2);
2228 
2229   return buf1;
2230 }
2231 
2232 /**
2233  * gst_buffer_get_meta:
2234  * @buffer: a #GstBuffer
2235  * @api: the #GType of an API
2236  *
2237  * Get the metadata for @api on buffer. When there is no such metadata, %NULL is
2238  * returned. If multiple metadata with the given @api are attached to this
2239  * buffer only the first one is returned.  To handle multiple metadata with a
2240  * given API use gst_buffer_iterate_meta() or gst_buffer_foreach_meta() instead
</pre>
<hr />
<pre>
2299 gst_buffer_add_meta (GstBuffer * buffer, const GstMetaInfo * info,
2300     gpointer params)
2301 {
2302   GstMetaItem *item;
2303   GstMeta *result = NULL;
2304   gsize size;
2305 
2306   g_return_val_if_fail (buffer != NULL, NULL);
2307   g_return_val_if_fail (info != NULL, NULL);
2308   g_return_val_if_fail (gst_buffer_is_writable (buffer), NULL);
2309 
2310   /* create a new slice */
2311   size = ITEM_SIZE (info);
2312   /* We warn in gst_meta_register() about metas without
2313    * init function but let&#39;s play safe here and prevent
2314    * uninitialized memory
2315    */
2316   if (!info-&gt;init_func)
2317     item = g_slice_alloc0 (size);
2318   else
<span class="line-modified">2319     item = g_slice_alloc (size);</span>
2320   result = &amp;item-&gt;meta;
2321   result-&gt;info = info;
2322   result-&gt;flags = GST_META_FLAG_NONE;
2323   GST_CAT_DEBUG (GST_CAT_BUFFER,
2324       &quot;alloc metadata %p (%s) of size %&quot; G_GSIZE_FORMAT, result,
2325       g_type_name (info-&gt;type), info-&gt;size);
2326 
2327   /* call the init_func when needed */
2328   if (info-&gt;init_func)
2329     if (!info-&gt;init_func (result, params, buffer))
2330       goto init_failed;
2331 
<span class="line-modified">2332   item-&gt;seq_num = gst_atomic_int64_inc (&amp;meta_seq);</span>
<span class="line-modified">2333   item-&gt;next = NULL;</span>
<span class="line-modified">2334 </span>
<span class="line-added">2335   if (!GST_BUFFER_META (buffer)) {</span>
<span class="line-added">2336     GST_BUFFER_META (buffer) = item;</span>
<span class="line-added">2337     GST_BUFFER_TAIL_META (buffer) = item;</span>
<span class="line-added">2338   } else {</span>
<span class="line-added">2339     GST_BUFFER_TAIL_META (buffer)-&gt;next = item;</span>
<span class="line-added">2340     GST_BUFFER_TAIL_META (buffer) = item;</span>
<span class="line-added">2341   }</span>
2342 
2343   return result;
2344 
2345 init_failed:
2346   {
2347     g_slice_free1 (size, item);
2348     return NULL;
2349   }
2350 }
2351 
2352 /**
2353  * gst_buffer_remove_meta:
2354  * @buffer: a #GstBuffer
2355  * @meta: a #GstMeta
2356  *
2357  * Remove the metadata for @meta on @buffer.
2358  *
2359  * Returns: %TRUE if the metadata existed and was removed, %FALSE if no such
2360  * metadata was on @buffer.
2361  */
2362 gboolean
2363 gst_buffer_remove_meta (GstBuffer * buffer, GstMeta * meta)
2364 {
2365   GstMetaItem *walk, *prev;
2366 
2367   g_return_val_if_fail (buffer != NULL, FALSE);
2368   g_return_val_if_fail (meta != NULL, FALSE);
2369   g_return_val_if_fail (gst_buffer_is_writable (buffer), FALSE);
2370   g_return_val_if_fail (!GST_META_FLAG_IS_SET (meta, GST_META_FLAG_LOCKED),
2371       FALSE);
2372 
2373   /* find the metadata and delete */
2374   prev = GST_BUFFER_META (buffer);
2375   for (walk = prev; walk; walk = walk-&gt;next) {
2376     GstMeta *m = &amp;walk-&gt;meta;
2377     if (m == meta) {
2378       const GstMetaInfo *info = meta-&gt;info;
2379 
2380       /* remove from list */
<span class="line-added">2381       if (GST_BUFFER_TAIL_META (buffer) == walk) {</span>
<span class="line-added">2382         if (prev != walk)</span>
<span class="line-added">2383           GST_BUFFER_TAIL_META (buffer) = prev;</span>
<span class="line-added">2384         else</span>
<span class="line-added">2385           GST_BUFFER_TAIL_META (buffer) = NULL;</span>
<span class="line-added">2386       }</span>
<span class="line-added">2387 </span>
2388       if (GST_BUFFER_META (buffer) == walk)
2389         GST_BUFFER_META (buffer) = walk-&gt;next;
2390       else
2391         prev-&gt;next = walk-&gt;next;
<span class="line-added">2392 </span>
2393       /* call free_func if any */
2394       if (info-&gt;free_func)
2395         info-&gt;free_func (m, buffer);
2396 
2397       /* and free the slice */
2398       g_slice_free1 (ITEM_SIZE (info), walk);
2399       break;
2400     }
2401     prev = walk;
2402   }
2403   return walk != NULL;
2404 }
2405 
2406 /**
2407  * gst_buffer_iterate_meta: (skip)
2408  * @buffer: a #GstBuffer
2409  * @state: (out caller-allocates): an opaque state pointer
2410  *
2411  * Retrieve the next #GstMeta after @current. If @state points
2412  * to %NULL, the first metadata is returned.
</pre>
<hr />
<pre>
2508   /* find the metadata and delete */
2509   prev = GST_BUFFER_META (buffer);
2510   for (walk = prev; walk; walk = next) {
2511     GstMeta *m, *new;
2512 
2513     m = new = &amp;walk-&gt;meta;
2514     next = walk-&gt;next;
2515 
2516     res = func (buffer, &amp;new, user_data);
2517 
2518     if (new == NULL) {
2519       const GstMetaInfo *info = m-&gt;info;
2520 
2521       GST_CAT_DEBUG (GST_CAT_BUFFER, &quot;remove metadata %p (%s)&quot;, m,
2522           g_type_name (info-&gt;type));
2523 
2524       g_return_val_if_fail (gst_buffer_is_writable (buffer), FALSE);
2525       g_return_val_if_fail (!GST_META_FLAG_IS_SET (m, GST_META_FLAG_LOCKED),
2526           FALSE);
2527 
<span class="line-added">2528       if (GST_BUFFER_TAIL_META (buffer) == walk) {</span>
<span class="line-added">2529         if (prev != walk)</span>
<span class="line-added">2530           GST_BUFFER_TAIL_META (buffer) = prev;</span>
<span class="line-added">2531         else</span>
<span class="line-added">2532           GST_BUFFER_TAIL_META (buffer) = NULL;</span>
<span class="line-added">2533       }</span>
<span class="line-added">2534 </span>
2535       /* remove from list */
2536       if (GST_BUFFER_META (buffer) == walk)
<span class="line-modified">2537         prev = GST_BUFFER_META (buffer) = next;</span>
2538       else
2539         prev-&gt;next = next;
2540 


2541       /* call free_func if any */
2542       if (info-&gt;free_func)
2543         info-&gt;free_func (m, buffer);
2544 
2545       /* and free the slice */
2546       g_slice_free1 (ITEM_SIZE (info), walk);
2547     } else {
2548       prev = walk;
2549     }
2550     if (!res)
2551       break;
2552   }
2553   return res;
2554 }
2555 
2556 /**
2557  * gst_buffer_extract_dup:
2558  * @buffer: a #GstBuffer
2559  * @offset: the offset to extract
2560  * @size: the size to extract
</pre>
<hr />
<pre>
2565  * Extracts a copy of at most @size bytes the data at @offset into
2566  * newly-allocated memory. @dest must be freed using g_free() when done.
2567  *
2568  * Since: 1.0.10
2569  */
2570 
2571 void
2572 gst_buffer_extract_dup (GstBuffer * buffer, gsize offset, gsize size,
2573     gpointer * dest, gsize * dest_size)
2574 {
2575   gsize real_size, alloc_size;
2576 
2577   real_size = gst_buffer_get_size (buffer);
2578 
2579   alloc_size = MIN (real_size - offset, size);
2580   if (alloc_size == 0) {
2581     *dest = NULL;
2582     *dest_size = 0;
2583   } else {
2584     *dest = g_malloc (alloc_size);
<span class="line-modified">2585     *dest_size = gst_buffer_extract (buffer, offset, *dest, size);</span>
<span class="line-modified">2586   }</span>
2587 }
2588 
2589 GST_DEBUG_CATEGORY_STATIC (gst_parent_buffer_meta_debug);
2590 
2591 /**
2592  * gst_buffer_add_parent_buffer_meta:
2593  * @buffer: (transfer none): a #GstBuffer
2594  * @ref: (transfer none): a #GstBuffer to ref
2595  *
2596  * Add a #GstParentBufferMeta to @buffer that holds a reference on
2597  * @ref until the buffer is freed.
2598  *
2599  * Returns: (transfer none) (nullable): The #GstParentBufferMeta that was added to the buffer
2600  *
2601  * Since: 1.6
2602  */
2603 GstParentBufferMeta *
2604 gst_buffer_add_parent_buffer_meta (GstBuffer * buffer, GstBuffer * ref)
2605 {
2606   GstParentBufferMeta *meta;
</pre>
</td>
</tr>
</table>
<center><a href="gstbin.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstbuffer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>