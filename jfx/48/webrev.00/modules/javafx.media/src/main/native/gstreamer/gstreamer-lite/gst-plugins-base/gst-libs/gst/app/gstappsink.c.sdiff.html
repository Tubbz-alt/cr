<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/app/gstappsink.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="app-prelude.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstappsrc.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/app/gstappsink.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  90   gboolean wait_on_eos;
  91   GstAppSinkWaitStatus wait_status;
  92 
  93   GCond cond;
  94   GMutex mutex;
  95   GstQueueArray *queue;
  96   GstBuffer *preroll_buffer;
  97   GstCaps *preroll_caps;
  98   GstCaps *last_caps;
  99   GstSegment preroll_segment;
 100   GstSegment last_segment;
 101   gboolean flushing;
 102   gboolean unlock;
 103   gboolean started;
 104   gboolean is_eos;
 105   gboolean buffer_lists_supported;
 106 
 107   GstAppSinkCallbacks callbacks;
 108   gpointer user_data;
 109   GDestroyNotify notify;


 110 };
 111 
 112 GST_DEBUG_CATEGORY_STATIC (app_sink_debug);
 113 #define GST_CAT_DEFAULT app_sink_debug
 114 
 115 enum
 116 {
 117   /* signals */
 118   SIGNAL_EOS,
 119   SIGNAL_NEW_PREROLL,
 120   SIGNAL_NEW_SAMPLE,
 121 
 122   /* actions */
 123   SIGNAL_PULL_PREROLL,
 124   SIGNAL_PULL_SAMPLE,
 125   SIGNAL_TRY_PULL_PREROLL,
 126   SIGNAL_TRY_PULL_SAMPLE,
 127 
 128   LAST_SIGNAL
 129 };
 130 
<span class="line-modified"> 131 #define DEFAULT_PROP_EOS        TRUE</span>
<span class="line-modified"> 132 #define DEFAULT_PROP_EMIT_SIGNALS   FALSE</span>
<span class="line-modified"> 133 #define DEFAULT_PROP_MAX_BUFFERS    0</span>
<span class="line-modified"> 134 #define DEFAULT_PROP_DROP       FALSE</span>
<span class="line-modified"> 135 #define DEFAULT_PROP_WAIT_ON_EOS    TRUE</span>
<span class="line-modified"> 136 #define DEFAULT_PROP_BUFFER_LIST    FALSE</span>
 137 
 138 enum
 139 {
 140   PROP_0,
 141   PROP_CAPS,
 142   PROP_EOS,
 143   PROP_EMIT_SIGNALS,
 144   PROP_MAX_BUFFERS,
 145   PROP_DROP,
 146   PROP_WAIT_ON_EOS,
 147   PROP_BUFFER_LIST,
 148   PROP_LAST
 149 };
 150 
 151 static GstStaticPadTemplate gst_app_sink_template =
 152 GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,
 153     GST_PAD_SINK,
 154     GST_PAD_ALWAYS,
 155     GST_STATIC_CAPS_ANY);
 156 
</pre>
<hr />
<pre>
 169 static gboolean gst_app_sink_unlock_stop (GstBaseSink * bsink);
 170 static gboolean gst_app_sink_start (GstBaseSink * psink);
 171 static gboolean gst_app_sink_stop (GstBaseSink * psink);
 172 static gboolean gst_app_sink_event (GstBaseSink * sink, GstEvent * event);
 173 static gboolean gst_app_sink_query (GstBaseSink * bsink, GstQuery * query);
 174 static GstFlowReturn gst_app_sink_preroll (GstBaseSink * psink,
 175     GstBuffer * buffer);
 176 static GstFlowReturn gst_app_sink_render_common (GstBaseSink * psink,
 177     GstMiniObject * data, gboolean is_list);
 178 static GstFlowReturn gst_app_sink_render (GstBaseSink * psink,
 179     GstBuffer * buffer);
 180 static GstFlowReturn gst_app_sink_render_list (GstBaseSink * psink,
 181     GstBufferList * list);
 182 static gboolean gst_app_sink_setcaps (GstBaseSink * sink, GstCaps * caps);
 183 static GstCaps *gst_app_sink_getcaps (GstBaseSink * psink, GstCaps * filter);
 184 
 185 static guint gst_app_sink_signals[LAST_SIGNAL] = { 0 };
 186 
 187 #define gst_app_sink_parent_class parent_class
 188 G_DEFINE_TYPE_WITH_CODE (GstAppSink, gst_app_sink, GST_TYPE_BASE_SINK,

 189     G_IMPLEMENT_INTERFACE (GST_TYPE_URI_HANDLER,
 190         gst_app_sink_uri_handler_init));
 191 
 192 static void
 193 gst_app_sink_class_init (GstAppSinkClass * klass)
 194 {
 195   GObjectClass *gobject_class = (GObjectClass *) klass;
 196   GstElementClass *element_class = (GstElementClass *) klass;
 197   GstBaseSinkClass *basesink_class = (GstBaseSinkClass *) klass;
 198 
 199   GST_DEBUG_CATEGORY_INIT (app_sink_debug, &quot;appsink&quot;, 0, &quot;appsink element&quot;);
 200 
 201   gobject_class-&gt;dispose = gst_app_sink_dispose;
 202   gobject_class-&gt;finalize = gst_app_sink_finalize;
 203 
 204   gobject_class-&gt;set_property = gst_app_sink_set_property;
 205   gobject_class-&gt;get_property = gst_app_sink_get_property;
 206 
 207   g_object_class_install_property (gobject_class, PROP_CAPS,
 208       g_param_spec_boxed (&quot;caps&quot;, &quot;Caps&quot;,
</pre>
<hr />
<pre>
 267    * @appsink: the appsink element that emitted the signal
 268    *
 269    * Signal that a new preroll sample is available.
 270    *
 271    * This signal is emitted from the streaming thread and only when the
 272    * &quot;emit-signals&quot; property is %TRUE.
 273    *
 274    * The new preroll sample can be retrieved with the &quot;pull-preroll&quot; action
 275    * signal or gst_app_sink_pull_preroll() either from this signal callback
 276    * or from any other thread.
 277    *
 278    * Note that this signal is only emitted when the &quot;emit-signals&quot; property is
 279    * set to %TRUE, which it is not by default for performance reasons.
 280    */
 281   gst_app_sink_signals[SIGNAL_NEW_PREROLL] =
 282       g_signal_new (&quot;new-preroll&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 283       G_STRUCT_OFFSET (GstAppSinkClass, new_preroll),
 284       NULL, NULL, NULL, GST_TYPE_FLOW_RETURN, 0, G_TYPE_NONE);
 285   /**
 286    * GstAppSink::new-sample:
<span class="line-modified"> 287    * @appsink: the appsink element that emited the signal</span>
 288    *
 289    * Signal that a new sample is available.
 290    *
 291    * This signal is emitted from the streaming thread and only when the
 292    * &quot;emit-signals&quot; property is %TRUE.
 293    *
 294    * The new sample can be retrieved with the &quot;pull-sample&quot; action
 295    * signal or gst_app_sink_pull_sample() either from this signal callback
 296    * or from any other thread.
 297    *
 298    * Note that this signal is only emitted when the &quot;emit-signals&quot; property is
 299    * set to %TRUE, which it is not by default for performance reasons.
 300    */
 301   gst_app_sink_signals[SIGNAL_NEW_SAMPLE] =
 302       g_signal_new (&quot;new-sample&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 303       G_STRUCT_OFFSET (GstAppSinkClass, new_sample),
 304       NULL, NULL, NULL, GST_TYPE_FLOW_RETURN, 0, G_TYPE_NONE);
 305 
 306   /**
 307    * GstAppSink::pull-preroll:
</pre>
<hr />
<pre>
 428 
 429   gst_element_class_add_static_pad_template (element_class,
 430       &amp;gst_app_sink_template);
 431 
 432   basesink_class-&gt;unlock = gst_app_sink_unlock_start;
 433   basesink_class-&gt;unlock_stop = gst_app_sink_unlock_stop;
 434   basesink_class-&gt;start = gst_app_sink_start;
 435   basesink_class-&gt;stop = gst_app_sink_stop;
 436   basesink_class-&gt;event = gst_app_sink_event;
 437   basesink_class-&gt;preroll = gst_app_sink_preroll;
 438   basesink_class-&gt;render = gst_app_sink_render;
 439   basesink_class-&gt;render_list = gst_app_sink_render_list;
 440   basesink_class-&gt;get_caps = gst_app_sink_getcaps;
 441   basesink_class-&gt;set_caps = gst_app_sink_setcaps;
 442   basesink_class-&gt;query = gst_app_sink_query;
 443 
 444   klass-&gt;pull_preroll = gst_app_sink_pull_preroll;
 445   klass-&gt;pull_sample = gst_app_sink_pull_sample;
 446   klass-&gt;try_pull_preroll = gst_app_sink_try_pull_preroll;
 447   klass-&gt;try_pull_sample = gst_app_sink_try_pull_sample;
<span class="line-removed"> 448 </span>
<span class="line-removed"> 449   g_type_class_add_private (klass, sizeof (GstAppSinkPrivate));</span>
 450 }
 451 
 452 static void
 453 gst_app_sink_init (GstAppSink * appsink)
 454 {
 455   GstAppSinkPrivate *priv;
 456 
<span class="line-modified"> 457   priv = appsink-&gt;priv =</span>
<span class="line-removed"> 458       G_TYPE_INSTANCE_GET_PRIVATE (appsink, GST_TYPE_APP_SINK,</span>
<span class="line-removed"> 459       GstAppSinkPrivate);</span>
 460 
 461   g_mutex_init (&amp;priv-&gt;mutex);
 462   g_cond_init (&amp;priv-&gt;cond);
 463   priv-&gt;queue = gst_queue_array_new (16);

 464 
 465   priv-&gt;emit_signals = DEFAULT_PROP_EMIT_SIGNALS;
 466   priv-&gt;max_buffers = DEFAULT_PROP_MAX_BUFFERS;
 467   priv-&gt;drop = DEFAULT_PROP_DROP;
 468   priv-&gt;wait_on_eos = DEFAULT_PROP_WAIT_ON_EOS;
 469   priv-&gt;buffer_lists_supported = DEFAULT_PROP_BUFFER_LIST;
 470   priv-&gt;wait_status = NOONE_WAITING;
 471 }
 472 
 473 static void
 474 gst_app_sink_dispose (GObject * obj)
 475 {
 476   GstAppSink *appsink = GST_APP_SINK_CAST (obj);
 477   GstAppSinkPrivate *priv = appsink-&gt;priv;
 478   GstMiniObject *queue_obj;
 479 
 480   GST_OBJECT_LOCK (appsink);
 481   if (priv-&gt;caps) {
 482     gst_caps_unref (priv-&gt;caps);
 483     priv-&gt;caps = NULL;
 484   }
 485   if (priv-&gt;notify) {
 486     priv-&gt;notify (priv-&gt;user_data);
 487   }
 488   priv-&gt;user_data = NULL;
 489   priv-&gt;notify = NULL;
 490 
 491   GST_OBJECT_UNLOCK (appsink);
 492 
 493   g_mutex_lock (&amp;priv-&gt;mutex);
 494   while ((queue_obj = gst_queue_array_pop_head (priv-&gt;queue)))
 495     gst_mini_object_unref (queue_obj);
 496   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
 497   gst_caps_replace (&amp;priv-&gt;preroll_caps, NULL);
 498   gst_caps_replace (&amp;priv-&gt;last_caps, NULL);




 499   g_mutex_unlock (&amp;priv-&gt;mutex);
 500 
 501   G_OBJECT_CLASS (parent_class)-&gt;dispose (obj);
 502 }
 503 
 504 static void
 505 gst_app_sink_finalize (GObject * obj)
 506 {
 507   GstAppSink *appsink = GST_APP_SINK_CAST (obj);
 508   GstAppSinkPrivate *priv = appsink-&gt;priv;
 509 
 510   g_mutex_clear (&amp;priv-&gt;mutex);
 511   g_cond_clear (&amp;priv-&gt;cond);
 512   gst_queue_array_free (priv-&gt;queue);
 513 
 514   G_OBJECT_CLASS (parent_class)-&gt;finalize (obj);
 515 }
 516 
 517 static void
 518 gst_app_sink_set_property (GObject * object, guint prop_id,
</pre>
<hr />
<pre>
 649   while ((obj = gst_queue_array_pop_head (priv-&gt;queue)))
 650     gst_mini_object_unref (obj);
 651 #endif // GSTREAMER_LITE
 652   priv-&gt;num_buffers = 0;
 653   g_cond_signal (&amp;priv-&gt;cond);
 654 }
 655 
 656 static gboolean
 657 gst_app_sink_start (GstBaseSink * psink)
 658 {
 659   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
 660   GstAppSinkPrivate *priv = appsink-&gt;priv;
 661 
 662   g_mutex_lock (&amp;priv-&gt;mutex);
 663   GST_DEBUG_OBJECT (appsink, &quot;starting&quot;);
 664   priv-&gt;wait_status = NOONE_WAITING;
 665   priv-&gt;flushing = FALSE;
 666   priv-&gt;started = TRUE;
 667   gst_segment_init (&amp;priv-&gt;preroll_segment, GST_FORMAT_TIME);
 668   gst_segment_init (&amp;priv-&gt;last_segment, GST_FORMAT_TIME);





 669   g_mutex_unlock (&amp;priv-&gt;mutex);
 670 
 671   return TRUE;
 672 }
 673 
 674 static gboolean
 675 gst_app_sink_stop (GstBaseSink * psink)
 676 {
 677   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
 678   GstAppSinkPrivate *priv = appsink-&gt;priv;
 679 
 680   g_mutex_lock (&amp;priv-&gt;mutex);
 681   GST_DEBUG_OBJECT (appsink, &quot;stopping&quot;);
 682   priv-&gt;flushing = TRUE;
 683   priv-&gt;started = FALSE;
 684   priv-&gt;wait_status = NOONE_WAITING;
 685   gst_app_sink_flush_unlocked (appsink);
 686   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
 687   gst_caps_replace (&amp;priv-&gt;preroll_caps, NULL);
 688   gst_caps_replace (&amp;priv-&gt;last_caps, NULL);
 689   gst_segment_init (&amp;priv-&gt;preroll_segment, GST_FORMAT_UNDEFINED);
 690   gst_segment_init (&amp;priv-&gt;last_segment, GST_FORMAT_UNDEFINED);
 691   g_mutex_unlock (&amp;priv-&gt;mutex);
 692 
 693   return TRUE;
 694 }
 695 
 696 static gboolean
 697 gst_app_sink_setcaps (GstBaseSink * sink, GstCaps * caps)
 698 {
 699   GstAppSink *appsink = GST_APP_SINK_CAST (sink);
 700   GstAppSinkPrivate *priv = appsink-&gt;priv;
 701 
 702   g_mutex_lock (&amp;priv-&gt;mutex);
 703   GST_DEBUG_OBJECT (appsink, &quot;receiving CAPS&quot;);
 704   gst_queue_array_push_tail (priv-&gt;queue, gst_event_new_caps (caps));
 705   if (!priv-&gt;preroll_buffer)
<span class="line-modified"> 706   gst_caps_replace (&amp;priv-&gt;preroll_caps, caps);</span>
 707   g_mutex_unlock (&amp;priv-&gt;mutex);
 708 
 709   return TRUE;
 710 }
 711 
 712 static gboolean
 713 gst_app_sink_event (GstBaseSink * sink, GstEvent * event)
 714 {
 715   GstAppSink *appsink = GST_APP_SINK_CAST (sink);
 716   GstAppSinkPrivate *priv = appsink-&gt;priv;
 717 
 718   switch (event-&gt;type) {
 719     case GST_EVENT_SEGMENT:
 720       g_mutex_lock (&amp;priv-&gt;mutex);
 721       GST_DEBUG_OBJECT (appsink, &quot;receiving SEGMENT&quot;);
 722       gst_queue_array_push_tail (priv-&gt;queue, gst_event_ref (event));
 723       if (!priv-&gt;preroll_buffer)
 724         gst_event_copy_segment (event, &amp;priv-&gt;preroll_segment);
 725       g_mutex_unlock (&amp;priv-&gt;mutex);
 726       break;
</pre>
<hr />
<pre>
 745           if (gst_base_sink_wait_preroll (sink) != GST_FLOW_OK) {
 746             /* Directly go out of here */
 747             gst_event_unref (event);
 748             return FALSE;
 749           }
 750 
 751           /* we are allowed to continue now */
 752           g_mutex_lock (&amp;priv-&gt;mutex);
 753           continue;
 754         }
 755 
 756         priv-&gt;wait_status |= STREAM_WAITING;
 757         g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);
 758         priv-&gt;wait_status &amp;= ~STREAM_WAITING;
 759       }
 760       if (priv-&gt;flushing)
 761         emit = FALSE;
 762       g_mutex_unlock (&amp;priv-&gt;mutex);
 763 
 764       if (emit) {
<span class="line-modified"> 765       /* emit EOS now */</span>
<span class="line-modified"> 766       if (priv-&gt;callbacks.eos)</span>
<span class="line-modified"> 767         priv-&gt;callbacks.eos (appsink, priv-&gt;user_data);</span>
<span class="line-modified"> 768       else</span>
<span class="line-modified"> 769         g_signal_emit (appsink, gst_app_sink_signals[SIGNAL_EOS], 0);</span>
 770       }
 771 
 772       break;
 773     }
 774     case GST_EVENT_FLUSH_START:
 775       /* we don&#39;t have to do anything here, the base class will call unlock
 776        * which will make sure we exit the _render method */
 777       GST_DEBUG_OBJECT (appsink, &quot;received FLUSH_START&quot;);
 778       break;
 779     case GST_EVENT_FLUSH_STOP:
 780       g_mutex_lock (&amp;priv-&gt;mutex);
 781       GST_DEBUG_OBJECT (appsink, &quot;received FLUSH_STOP&quot;);
 782       gst_app_sink_flush_unlocked (appsink);
 783       g_mutex_unlock (&amp;priv-&gt;mutex);
 784       break;
 785     default:
 786       break;
 787   }
 788   return GST_BASE_SINK_CLASS (parent_class)-&gt;event (sink, event);
 789 }
 790 
 791 static GstFlowReturn
 792 gst_app_sink_preroll (GstBaseSink * psink, GstBuffer * buffer)
 793 {
 794   GstFlowReturn res;
 795   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
 796   GstAppSinkPrivate *priv = appsink-&gt;priv;
 797   gboolean emit;
 798 
 799   g_mutex_lock (&amp;priv-&gt;mutex);
 800   if (priv-&gt;flushing)
 801     goto flushing;
 802 
 803   GST_DEBUG_OBJECT (appsink, &quot;setting preroll buffer %p&quot;, buffer);
 804   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, buffer);
 805 
 806   if ((priv-&gt;wait_status &amp; APP_WAITING))
<span class="line-modified"> 807   g_cond_signal (&amp;priv-&gt;cond);</span>
 808 
 809   emit = priv-&gt;emit_signals;
 810   g_mutex_unlock (&amp;priv-&gt;mutex);
 811 
 812   if (priv-&gt;callbacks.new_preroll) {
 813     res = priv-&gt;callbacks.new_preroll (appsink, priv-&gt;user_data);
 814   } else {
 815     res = GST_FLOW_OK;
 816     if (emit)
 817       g_signal_emit (appsink, gst_app_sink_signals[SIGNAL_NEW_PREROLL], 0,
 818           &amp;res);
 819   }
 820 
 821   return res;
 822 
 823 flushing:
 824   {
 825     GST_DEBUG_OBJECT (appsink, &quot;we are flushing&quot;);
 826     g_mutex_unlock (&amp;priv-&gt;mutex);
 827     return GST_FLOW_FLUSHING;
</pre>
<hr />
<pre>
 835   GstMiniObject *obj;
 836 
 837   do {
 838     obj = gst_queue_array_pop_head (priv-&gt;queue);
 839 
 840     if (GST_IS_BUFFER (obj) || GST_IS_BUFFER_LIST (obj)) {
 841       GST_DEBUG_OBJECT (appsink, &quot;dequeued buffer/list %p&quot;, obj);
 842       priv-&gt;num_buffers--;
 843       break;
 844     } else if (GST_IS_EVENT (obj)) {
 845       GstEvent *event = GST_EVENT_CAST (obj);
 846 
 847       switch (GST_EVENT_TYPE (obj)) {
 848         case GST_EVENT_CAPS:
 849         {
 850           GstCaps *caps;
 851 
 852           gst_event_parse_caps (event, &amp;caps);
 853           GST_DEBUG_OBJECT (appsink, &quot;activating caps %&quot; GST_PTR_FORMAT, caps);
 854           gst_caps_replace (&amp;priv-&gt;last_caps, caps);


 855           break;
 856         }
 857         case GST_EVENT_SEGMENT:
 858           gst_event_copy_segment (event, &amp;priv-&gt;last_segment);


 859           GST_DEBUG_OBJECT (appsink, &quot;activated segment %&quot; GST_SEGMENT_FORMAT,
 860               &amp;priv-&gt;last_segment);
 861           break;
 862         default:
 863           break;
 864       }
 865       gst_mini_object_unref (obj);
 866     }
 867   } while (TRUE);
 868 
 869   return obj;
 870 }
 871 
 872 static GstFlowReturn
 873 gst_app_sink_render_common (GstBaseSink * psink, GstMiniObject * data,
 874     gboolean is_list)
 875 {
 876   GstFlowReturn ret;
 877   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
 878   GstAppSinkPrivate *priv = appsink-&gt;priv;
 879   gboolean emit;
 880 
 881 restart:
 882   g_mutex_lock (&amp;priv-&gt;mutex);
 883   if (priv-&gt;flushing)
 884     goto flushing;
 885 
 886   /* queue holding caps event might have been FLUSHed,
 887    * but caps state still present in pad caps */
 888   if (G_UNLIKELY (!priv-&gt;last_caps &amp;&amp;
 889           gst_pad_has_current_caps (GST_BASE_SINK_PAD (psink)))) {
 890     priv-&gt;last_caps = gst_pad_get_current_caps (GST_BASE_SINK_PAD (psink));

 891     GST_DEBUG_OBJECT (appsink, &quot;activating pad caps %&quot; GST_PTR_FORMAT,
 892         priv-&gt;last_caps);
 893   }
 894 
 895   GST_DEBUG_OBJECT (appsink, &quot;pushing render buffer/list %p on queue (%d)&quot;,
 896       data, priv-&gt;num_buffers);
 897 
 898   while (priv-&gt;max_buffers &gt; 0 &amp;&amp; priv-&gt;num_buffers &gt;= priv-&gt;max_buffers) {
 899     if (priv-&gt;drop) {
 900       GstMiniObject *old;
 901 
 902       /* we need to drop the oldest buffer/list and try again */
 903       if ((old = dequeue_buffer (appsink))) {
 904         GST_DEBUG_OBJECT (appsink, &quot;dropping old buffer/list %p&quot;, old);
 905         gst_mini_object_unref (old);
 906       }
 907     } else {
 908       GST_DEBUG_OBJECT (appsink, &quot;waiting for free space, length %d &gt;= %d&quot;,
 909           priv-&gt;num_buffers, priv-&gt;max_buffers);
 910 
</pre>
<hr />
<pre>
 915           goto stopping;
 916 
 917         /* we are allowed to continue now */
 918         goto restart;
 919       }
 920 
 921       /* wait for a buffer to be removed or flush */
 922       priv-&gt;wait_status |= STREAM_WAITING;
 923       g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);
 924       priv-&gt;wait_status &amp;= ~STREAM_WAITING;
 925 
 926       if (priv-&gt;flushing)
 927         goto flushing;
 928     }
 929   }
 930   /* we need to ref the buffer/list when pushing it in the queue */
 931   gst_queue_array_push_tail (priv-&gt;queue, gst_mini_object_ref (data));
 932   priv-&gt;num_buffers++;
 933 
 934   if ((priv-&gt;wait_status &amp; APP_WAITING))
<span class="line-modified"> 935   g_cond_signal (&amp;priv-&gt;cond);</span>
 936 
 937   emit = priv-&gt;emit_signals;
 938   g_mutex_unlock (&amp;priv-&gt;mutex);
 939 
 940   if (priv-&gt;callbacks.new_sample) {
 941     ret = priv-&gt;callbacks.new_sample (appsink, priv-&gt;user_data);
 942   } else {
 943     ret = GST_FLOW_OK;
 944     if (emit)
 945       g_signal_emit (appsink, gst_app_sink_signals[SIGNAL_NEW_SAMPLE], 0, &amp;ret);
 946   }
 947   return ret;
 948 
 949 flushing:
 950   {
 951     GST_DEBUG_OBJECT (appsink, &quot;we are flushing&quot;);
 952     g_mutex_unlock (&amp;priv-&gt;mutex);
 953     return GST_FLOW_FLUSHING;
 954   }
 955 stopping:
</pre>
<hr />
<pre>
1549   g_mutex_lock (&amp;priv-&gt;mutex);
1550 
1551   while (TRUE) {
1552     GST_DEBUG_OBJECT (appsink, &quot;trying to grab a buffer&quot;);
1553     if (!priv-&gt;started)
1554       goto not_started;
1555 
1556     if (priv-&gt;preroll_buffer != NULL)
1557       break;
1558 
1559     if (priv-&gt;is_eos)
1560       goto eos;
1561 
1562     /* nothing to return, wait */
1563     GST_DEBUG_OBJECT (appsink, &quot;waiting for the preroll buffer&quot;);
1564     priv-&gt;wait_status |= APP_WAITING;
1565     if (timeout_valid) {
1566       if (!g_cond_wait_until (&amp;priv-&gt;cond, &amp;priv-&gt;mutex, end_time))
1567         goto expired;
1568     } else {
<span class="line-modified">1569     g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);</span>
<span class="line-modified">1570   }</span>
1571     priv-&gt;wait_status &amp;= ~APP_WAITING;
1572   }
1573   sample =
1574       gst_sample_new (priv-&gt;preroll_buffer, priv-&gt;preroll_caps,
1575       &amp;priv-&gt;preroll_segment, NULL);
1576   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
1577   GST_DEBUG_OBJECT (appsink, &quot;we have the preroll sample %p&quot;, sample);
1578   g_mutex_unlock (&amp;priv-&gt;mutex);
1579 
1580   return sample;
1581 
1582   /* special conditions */
1583 expired:
1584   {
1585     GST_DEBUG_OBJECT (appsink, &quot;timeout expired, return NULL&quot;);
1586     priv-&gt;wait_status &amp;= ~APP_WAITING;
1587     g_mutex_unlock (&amp;priv-&gt;mutex);
1588     return NULL;
1589   }
1590 eos:
</pre>
<hr />
<pre>
1647   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
1648 
1649   while (TRUE) {
1650     GST_DEBUG_OBJECT (appsink, &quot;trying to grab a buffer&quot;);
1651     if (!priv-&gt;started)
1652       goto not_started;
1653 
1654     if (priv-&gt;num_buffers &gt; 0)
1655       break;
1656 
1657     if (priv-&gt;is_eos)
1658       goto eos;
1659 
1660     /* nothing to return, wait */
1661     GST_DEBUG_OBJECT (appsink, &quot;waiting for a buffer&quot;);
1662     priv-&gt;wait_status |= APP_WAITING;
1663     if (timeout_valid) {
1664       if (!g_cond_wait_until (&amp;priv-&gt;cond, &amp;priv-&gt;mutex, end_time))
1665         goto expired;
1666     } else {
<span class="line-modified">1667     g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);</span>
<span class="line-modified">1668   }</span>
1669     priv-&gt;wait_status &amp;= ~APP_WAITING;
1670   }
1671 
1672   obj = dequeue_buffer (appsink);
1673   if (GST_IS_BUFFER (obj)) {
1674     GST_DEBUG_OBJECT (appsink, &quot;we have a buffer %p&quot;, obj);
<span class="line-modified">1675     sample = gst_sample_new (GST_BUFFER_CAST (obj), priv-&gt;last_caps,</span>
<span class="line-modified">1676         &amp;priv-&gt;last_segment, NULL);</span>


1677   } else {
1678     GST_DEBUG_OBJECT (appsink, &quot;we have a list %p&quot;, obj);
<span class="line-modified">1679     sample = gst_sample_new (NULL, priv-&gt;last_caps, &amp;priv-&gt;last_segment, NULL);</span>
<span class="line-modified">1680     gst_sample_set_buffer_list (sample, GST_BUFFER_LIST_CAST (obj));</span>


1681   }
1682   gst_mini_object_unref (obj);
1683 
1684   if ((priv-&gt;wait_status &amp; STREAM_WAITING))
<span class="line-modified">1685   g_cond_signal (&amp;priv-&gt;cond);</span>
1686 
1687   g_mutex_unlock (&amp;priv-&gt;mutex);
1688 
1689   return sample;
1690 
1691   /* special conditions */
1692 expired:
1693   {
1694     GST_DEBUG_OBJECT (appsink, &quot;timeout expired, return NULL&quot;);
1695     priv-&gt;wait_status &amp;= ~APP_WAITING;
1696     g_mutex_unlock (&amp;priv-&gt;mutex);
1697     return NULL;
1698   }
1699 eos:
1700   {
1701     GST_DEBUG_OBJECT (appsink, &quot;we are EOS, return NULL&quot;);
1702     g_mutex_unlock (&amp;priv-&gt;mutex);
1703     return NULL;
1704   }
1705 not_started:
</pre>
</td>
<td>
<hr />
<pre>
  90   gboolean wait_on_eos;
  91   GstAppSinkWaitStatus wait_status;
  92 
  93   GCond cond;
  94   GMutex mutex;
  95   GstQueueArray *queue;
  96   GstBuffer *preroll_buffer;
  97   GstCaps *preroll_caps;
  98   GstCaps *last_caps;
  99   GstSegment preroll_segment;
 100   GstSegment last_segment;
 101   gboolean flushing;
 102   gboolean unlock;
 103   gboolean started;
 104   gboolean is_eos;
 105   gboolean buffer_lists_supported;
 106 
 107   GstAppSinkCallbacks callbacks;
 108   gpointer user_data;
 109   GDestroyNotify notify;
<span class="line-added"> 110 </span>
<span class="line-added"> 111   GstSample *sample;</span>
 112 };
 113 
 114 GST_DEBUG_CATEGORY_STATIC (app_sink_debug);
 115 #define GST_CAT_DEFAULT app_sink_debug
 116 
 117 enum
 118 {
 119   /* signals */
 120   SIGNAL_EOS,
 121   SIGNAL_NEW_PREROLL,
 122   SIGNAL_NEW_SAMPLE,
 123 
 124   /* actions */
 125   SIGNAL_PULL_PREROLL,
 126   SIGNAL_PULL_SAMPLE,
 127   SIGNAL_TRY_PULL_PREROLL,
 128   SIGNAL_TRY_PULL_SAMPLE,
 129 
 130   LAST_SIGNAL
 131 };
 132 
<span class="line-modified"> 133 #define DEFAULT_PROP_EOS    TRUE</span>
<span class="line-modified"> 134 #define DEFAULT_PROP_EMIT_SIGNALS FALSE</span>
<span class="line-modified"> 135 #define DEFAULT_PROP_MAX_BUFFERS  0</span>
<span class="line-modified"> 136 #define DEFAULT_PROP_DROP   FALSE</span>
<span class="line-modified"> 137 #define DEFAULT_PROP_WAIT_ON_EOS  TRUE</span>
<span class="line-modified"> 138 #define DEFAULT_PROP_BUFFER_LIST  FALSE</span>
 139 
 140 enum
 141 {
 142   PROP_0,
 143   PROP_CAPS,
 144   PROP_EOS,
 145   PROP_EMIT_SIGNALS,
 146   PROP_MAX_BUFFERS,
 147   PROP_DROP,
 148   PROP_WAIT_ON_EOS,
 149   PROP_BUFFER_LIST,
 150   PROP_LAST
 151 };
 152 
 153 static GstStaticPadTemplate gst_app_sink_template =
 154 GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,
 155     GST_PAD_SINK,
 156     GST_PAD_ALWAYS,
 157     GST_STATIC_CAPS_ANY);
 158 
</pre>
<hr />
<pre>
 171 static gboolean gst_app_sink_unlock_stop (GstBaseSink * bsink);
 172 static gboolean gst_app_sink_start (GstBaseSink * psink);
 173 static gboolean gst_app_sink_stop (GstBaseSink * psink);
 174 static gboolean gst_app_sink_event (GstBaseSink * sink, GstEvent * event);
 175 static gboolean gst_app_sink_query (GstBaseSink * bsink, GstQuery * query);
 176 static GstFlowReturn gst_app_sink_preroll (GstBaseSink * psink,
 177     GstBuffer * buffer);
 178 static GstFlowReturn gst_app_sink_render_common (GstBaseSink * psink,
 179     GstMiniObject * data, gboolean is_list);
 180 static GstFlowReturn gst_app_sink_render (GstBaseSink * psink,
 181     GstBuffer * buffer);
 182 static GstFlowReturn gst_app_sink_render_list (GstBaseSink * psink,
 183     GstBufferList * list);
 184 static gboolean gst_app_sink_setcaps (GstBaseSink * sink, GstCaps * caps);
 185 static GstCaps *gst_app_sink_getcaps (GstBaseSink * psink, GstCaps * filter);
 186 
 187 static guint gst_app_sink_signals[LAST_SIGNAL] = { 0 };
 188 
 189 #define gst_app_sink_parent_class parent_class
 190 G_DEFINE_TYPE_WITH_CODE (GstAppSink, gst_app_sink, GST_TYPE_BASE_SINK,
<span class="line-added"> 191     G_ADD_PRIVATE (GstAppSink)</span>
 192     G_IMPLEMENT_INTERFACE (GST_TYPE_URI_HANDLER,
 193         gst_app_sink_uri_handler_init));
 194 
 195 static void
 196 gst_app_sink_class_init (GstAppSinkClass * klass)
 197 {
 198   GObjectClass *gobject_class = (GObjectClass *) klass;
 199   GstElementClass *element_class = (GstElementClass *) klass;
 200   GstBaseSinkClass *basesink_class = (GstBaseSinkClass *) klass;
 201 
 202   GST_DEBUG_CATEGORY_INIT (app_sink_debug, &quot;appsink&quot;, 0, &quot;appsink element&quot;);
 203 
 204   gobject_class-&gt;dispose = gst_app_sink_dispose;
 205   gobject_class-&gt;finalize = gst_app_sink_finalize;
 206 
 207   gobject_class-&gt;set_property = gst_app_sink_set_property;
 208   gobject_class-&gt;get_property = gst_app_sink_get_property;
 209 
 210   g_object_class_install_property (gobject_class, PROP_CAPS,
 211       g_param_spec_boxed (&quot;caps&quot;, &quot;Caps&quot;,
</pre>
<hr />
<pre>
 270    * @appsink: the appsink element that emitted the signal
 271    *
 272    * Signal that a new preroll sample is available.
 273    *
 274    * This signal is emitted from the streaming thread and only when the
 275    * &quot;emit-signals&quot; property is %TRUE.
 276    *
 277    * The new preroll sample can be retrieved with the &quot;pull-preroll&quot; action
 278    * signal or gst_app_sink_pull_preroll() either from this signal callback
 279    * or from any other thread.
 280    *
 281    * Note that this signal is only emitted when the &quot;emit-signals&quot; property is
 282    * set to %TRUE, which it is not by default for performance reasons.
 283    */
 284   gst_app_sink_signals[SIGNAL_NEW_PREROLL] =
 285       g_signal_new (&quot;new-preroll&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 286       G_STRUCT_OFFSET (GstAppSinkClass, new_preroll),
 287       NULL, NULL, NULL, GST_TYPE_FLOW_RETURN, 0, G_TYPE_NONE);
 288   /**
 289    * GstAppSink::new-sample:
<span class="line-modified"> 290    * @appsink: the appsink element that emitted the signal</span>
 291    *
 292    * Signal that a new sample is available.
 293    *
 294    * This signal is emitted from the streaming thread and only when the
 295    * &quot;emit-signals&quot; property is %TRUE.
 296    *
 297    * The new sample can be retrieved with the &quot;pull-sample&quot; action
 298    * signal or gst_app_sink_pull_sample() either from this signal callback
 299    * or from any other thread.
 300    *
 301    * Note that this signal is only emitted when the &quot;emit-signals&quot; property is
 302    * set to %TRUE, which it is not by default for performance reasons.
 303    */
 304   gst_app_sink_signals[SIGNAL_NEW_SAMPLE] =
 305       g_signal_new (&quot;new-sample&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 306       G_STRUCT_OFFSET (GstAppSinkClass, new_sample),
 307       NULL, NULL, NULL, GST_TYPE_FLOW_RETURN, 0, G_TYPE_NONE);
 308 
 309   /**
 310    * GstAppSink::pull-preroll:
</pre>
<hr />
<pre>
 431 
 432   gst_element_class_add_static_pad_template (element_class,
 433       &amp;gst_app_sink_template);
 434 
 435   basesink_class-&gt;unlock = gst_app_sink_unlock_start;
 436   basesink_class-&gt;unlock_stop = gst_app_sink_unlock_stop;
 437   basesink_class-&gt;start = gst_app_sink_start;
 438   basesink_class-&gt;stop = gst_app_sink_stop;
 439   basesink_class-&gt;event = gst_app_sink_event;
 440   basesink_class-&gt;preroll = gst_app_sink_preroll;
 441   basesink_class-&gt;render = gst_app_sink_render;
 442   basesink_class-&gt;render_list = gst_app_sink_render_list;
 443   basesink_class-&gt;get_caps = gst_app_sink_getcaps;
 444   basesink_class-&gt;set_caps = gst_app_sink_setcaps;
 445   basesink_class-&gt;query = gst_app_sink_query;
 446 
 447   klass-&gt;pull_preroll = gst_app_sink_pull_preroll;
 448   klass-&gt;pull_sample = gst_app_sink_pull_sample;
 449   klass-&gt;try_pull_preroll = gst_app_sink_try_pull_preroll;
 450   klass-&gt;try_pull_sample = gst_app_sink_try_pull_sample;


 451 }
 452 
 453 static void
 454 gst_app_sink_init (GstAppSink * appsink)
 455 {
 456   GstAppSinkPrivate *priv;
 457 
<span class="line-modified"> 458   priv = appsink-&gt;priv = gst_app_sink_get_instance_private (appsink);</span>


 459 
 460   g_mutex_init (&amp;priv-&gt;mutex);
 461   g_cond_init (&amp;priv-&gt;cond);
 462   priv-&gt;queue = gst_queue_array_new (16);
<span class="line-added"> 463   priv-&gt;sample = gst_sample_new (NULL, NULL, NULL, NULL);</span>
 464 
 465   priv-&gt;emit_signals = DEFAULT_PROP_EMIT_SIGNALS;
 466   priv-&gt;max_buffers = DEFAULT_PROP_MAX_BUFFERS;
 467   priv-&gt;drop = DEFAULT_PROP_DROP;
 468   priv-&gt;wait_on_eos = DEFAULT_PROP_WAIT_ON_EOS;
 469   priv-&gt;buffer_lists_supported = DEFAULT_PROP_BUFFER_LIST;
 470   priv-&gt;wait_status = NOONE_WAITING;
 471 }
 472 
 473 static void
 474 gst_app_sink_dispose (GObject * obj)
 475 {
 476   GstAppSink *appsink = GST_APP_SINK_CAST (obj);
 477   GstAppSinkPrivate *priv = appsink-&gt;priv;
 478   GstMiniObject *queue_obj;
 479 
 480   GST_OBJECT_LOCK (appsink);
 481   if (priv-&gt;caps) {
 482     gst_caps_unref (priv-&gt;caps);
 483     priv-&gt;caps = NULL;
 484   }
 485   if (priv-&gt;notify) {
 486     priv-&gt;notify (priv-&gt;user_data);
 487   }
 488   priv-&gt;user_data = NULL;
 489   priv-&gt;notify = NULL;
 490 
 491   GST_OBJECT_UNLOCK (appsink);
 492 
 493   g_mutex_lock (&amp;priv-&gt;mutex);
 494   while ((queue_obj = gst_queue_array_pop_head (priv-&gt;queue)))
 495     gst_mini_object_unref (queue_obj);
 496   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
 497   gst_caps_replace (&amp;priv-&gt;preroll_caps, NULL);
 498   gst_caps_replace (&amp;priv-&gt;last_caps, NULL);
<span class="line-added"> 499   if (priv-&gt;sample) {</span>
<span class="line-added"> 500     gst_sample_unref (priv-&gt;sample);</span>
<span class="line-added"> 501     priv-&gt;sample = NULL;</span>
<span class="line-added"> 502   }</span>
 503   g_mutex_unlock (&amp;priv-&gt;mutex);
 504 
 505   G_OBJECT_CLASS (parent_class)-&gt;dispose (obj);
 506 }
 507 
 508 static void
 509 gst_app_sink_finalize (GObject * obj)
 510 {
 511   GstAppSink *appsink = GST_APP_SINK_CAST (obj);
 512   GstAppSinkPrivate *priv = appsink-&gt;priv;
 513 
 514   g_mutex_clear (&amp;priv-&gt;mutex);
 515   g_cond_clear (&amp;priv-&gt;cond);
 516   gst_queue_array_free (priv-&gt;queue);
 517 
 518   G_OBJECT_CLASS (parent_class)-&gt;finalize (obj);
 519 }
 520 
 521 static void
 522 gst_app_sink_set_property (GObject * object, guint prop_id,
</pre>
<hr />
<pre>
 653   while ((obj = gst_queue_array_pop_head (priv-&gt;queue)))
 654     gst_mini_object_unref (obj);
 655 #endif // GSTREAMER_LITE
 656   priv-&gt;num_buffers = 0;
 657   g_cond_signal (&amp;priv-&gt;cond);
 658 }
 659 
 660 static gboolean
 661 gst_app_sink_start (GstBaseSink * psink)
 662 {
 663   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
 664   GstAppSinkPrivate *priv = appsink-&gt;priv;
 665 
 666   g_mutex_lock (&amp;priv-&gt;mutex);
 667   GST_DEBUG_OBJECT (appsink, &quot;starting&quot;);
 668   priv-&gt;wait_status = NOONE_WAITING;
 669   priv-&gt;flushing = FALSE;
 670   priv-&gt;started = TRUE;
 671   gst_segment_init (&amp;priv-&gt;preroll_segment, GST_FORMAT_TIME);
 672   gst_segment_init (&amp;priv-&gt;last_segment, GST_FORMAT_TIME);
<span class="line-added"> 673   priv-&gt;sample = gst_sample_make_writable (priv-&gt;sample);</span>
<span class="line-added"> 674   gst_sample_set_buffer (priv-&gt;sample, NULL);</span>
<span class="line-added"> 675   gst_sample_set_buffer_list (priv-&gt;sample, NULL);</span>
<span class="line-added"> 676   gst_sample_set_caps (priv-&gt;sample, NULL);</span>
<span class="line-added"> 677   gst_sample_set_segment (priv-&gt;sample, NULL);</span>
 678   g_mutex_unlock (&amp;priv-&gt;mutex);
 679 
 680   return TRUE;
 681 }
 682 
 683 static gboolean
 684 gst_app_sink_stop (GstBaseSink * psink)
 685 {
 686   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
 687   GstAppSinkPrivate *priv = appsink-&gt;priv;
 688 
 689   g_mutex_lock (&amp;priv-&gt;mutex);
 690   GST_DEBUG_OBJECT (appsink, &quot;stopping&quot;);
 691   priv-&gt;flushing = TRUE;
 692   priv-&gt;started = FALSE;
 693   priv-&gt;wait_status = NOONE_WAITING;
 694   gst_app_sink_flush_unlocked (appsink);
 695   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
 696   gst_caps_replace (&amp;priv-&gt;preroll_caps, NULL);
 697   gst_caps_replace (&amp;priv-&gt;last_caps, NULL);
 698   gst_segment_init (&amp;priv-&gt;preroll_segment, GST_FORMAT_UNDEFINED);
 699   gst_segment_init (&amp;priv-&gt;last_segment, GST_FORMAT_UNDEFINED);
 700   g_mutex_unlock (&amp;priv-&gt;mutex);
 701 
 702   return TRUE;
 703 }
 704 
 705 static gboolean
 706 gst_app_sink_setcaps (GstBaseSink * sink, GstCaps * caps)
 707 {
 708   GstAppSink *appsink = GST_APP_SINK_CAST (sink);
 709   GstAppSinkPrivate *priv = appsink-&gt;priv;
 710 
 711   g_mutex_lock (&amp;priv-&gt;mutex);
 712   GST_DEBUG_OBJECT (appsink, &quot;receiving CAPS&quot;);
 713   gst_queue_array_push_tail (priv-&gt;queue, gst_event_new_caps (caps));
 714   if (!priv-&gt;preroll_buffer)
<span class="line-modified"> 715     gst_caps_replace (&amp;priv-&gt;preroll_caps, caps);</span>
 716   g_mutex_unlock (&amp;priv-&gt;mutex);
 717 
 718   return TRUE;
 719 }
 720 
 721 static gboolean
 722 gst_app_sink_event (GstBaseSink * sink, GstEvent * event)
 723 {
 724   GstAppSink *appsink = GST_APP_SINK_CAST (sink);
 725   GstAppSinkPrivate *priv = appsink-&gt;priv;
 726 
 727   switch (event-&gt;type) {
 728     case GST_EVENT_SEGMENT:
 729       g_mutex_lock (&amp;priv-&gt;mutex);
 730       GST_DEBUG_OBJECT (appsink, &quot;receiving SEGMENT&quot;);
 731       gst_queue_array_push_tail (priv-&gt;queue, gst_event_ref (event));
 732       if (!priv-&gt;preroll_buffer)
 733         gst_event_copy_segment (event, &amp;priv-&gt;preroll_segment);
 734       g_mutex_unlock (&amp;priv-&gt;mutex);
 735       break;
</pre>
<hr />
<pre>
 754           if (gst_base_sink_wait_preroll (sink) != GST_FLOW_OK) {
 755             /* Directly go out of here */
 756             gst_event_unref (event);
 757             return FALSE;
 758           }
 759 
 760           /* we are allowed to continue now */
 761           g_mutex_lock (&amp;priv-&gt;mutex);
 762           continue;
 763         }
 764 
 765         priv-&gt;wait_status |= STREAM_WAITING;
 766         g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);
 767         priv-&gt;wait_status &amp;= ~STREAM_WAITING;
 768       }
 769       if (priv-&gt;flushing)
 770         emit = FALSE;
 771       g_mutex_unlock (&amp;priv-&gt;mutex);
 772 
 773       if (emit) {
<span class="line-modified"> 774         /* emit EOS now */</span>
<span class="line-modified"> 775         if (priv-&gt;callbacks.eos)</span>
<span class="line-modified"> 776           priv-&gt;callbacks.eos (appsink, priv-&gt;user_data);</span>
<span class="line-modified"> 777         else</span>
<span class="line-modified"> 778           g_signal_emit (appsink, gst_app_sink_signals[SIGNAL_EOS], 0);</span>
 779       }
 780 
 781       break;
 782     }
 783     case GST_EVENT_FLUSH_START:
 784       /* we don&#39;t have to do anything here, the base class will call unlock
 785        * which will make sure we exit the _render method */
 786       GST_DEBUG_OBJECT (appsink, &quot;received FLUSH_START&quot;);
 787       break;
 788     case GST_EVENT_FLUSH_STOP:
 789       g_mutex_lock (&amp;priv-&gt;mutex);
 790       GST_DEBUG_OBJECT (appsink, &quot;received FLUSH_STOP&quot;);
 791       gst_app_sink_flush_unlocked (appsink);
 792       g_mutex_unlock (&amp;priv-&gt;mutex);
 793       break;
 794     default:
 795       break;
 796   }
 797   return GST_BASE_SINK_CLASS (parent_class)-&gt;event (sink, event);
 798 }
 799 
 800 static GstFlowReturn
 801 gst_app_sink_preroll (GstBaseSink * psink, GstBuffer * buffer)
 802 {
 803   GstFlowReturn res;
 804   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
 805   GstAppSinkPrivate *priv = appsink-&gt;priv;
 806   gboolean emit;
 807 
 808   g_mutex_lock (&amp;priv-&gt;mutex);
 809   if (priv-&gt;flushing)
 810     goto flushing;
 811 
 812   GST_DEBUG_OBJECT (appsink, &quot;setting preroll buffer %p&quot;, buffer);
 813   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, buffer);
 814 
 815   if ((priv-&gt;wait_status &amp; APP_WAITING))
<span class="line-modified"> 816     g_cond_signal (&amp;priv-&gt;cond);</span>
 817 
 818   emit = priv-&gt;emit_signals;
 819   g_mutex_unlock (&amp;priv-&gt;mutex);
 820 
 821   if (priv-&gt;callbacks.new_preroll) {
 822     res = priv-&gt;callbacks.new_preroll (appsink, priv-&gt;user_data);
 823   } else {
 824     res = GST_FLOW_OK;
 825     if (emit)
 826       g_signal_emit (appsink, gst_app_sink_signals[SIGNAL_NEW_PREROLL], 0,
 827           &amp;res);
 828   }
 829 
 830   return res;
 831 
 832 flushing:
 833   {
 834     GST_DEBUG_OBJECT (appsink, &quot;we are flushing&quot;);
 835     g_mutex_unlock (&amp;priv-&gt;mutex);
 836     return GST_FLOW_FLUSHING;
</pre>
<hr />
<pre>
 844   GstMiniObject *obj;
 845 
 846   do {
 847     obj = gst_queue_array_pop_head (priv-&gt;queue);
 848 
 849     if (GST_IS_BUFFER (obj) || GST_IS_BUFFER_LIST (obj)) {
 850       GST_DEBUG_OBJECT (appsink, &quot;dequeued buffer/list %p&quot;, obj);
 851       priv-&gt;num_buffers--;
 852       break;
 853     } else if (GST_IS_EVENT (obj)) {
 854       GstEvent *event = GST_EVENT_CAST (obj);
 855 
 856       switch (GST_EVENT_TYPE (obj)) {
 857         case GST_EVENT_CAPS:
 858         {
 859           GstCaps *caps;
 860 
 861           gst_event_parse_caps (event, &amp;caps);
 862           GST_DEBUG_OBJECT (appsink, &quot;activating caps %&quot; GST_PTR_FORMAT, caps);
 863           gst_caps_replace (&amp;priv-&gt;last_caps, caps);
<span class="line-added"> 864           priv-&gt;sample = gst_sample_make_writable (priv-&gt;sample);</span>
<span class="line-added"> 865           gst_sample_set_caps (priv-&gt;sample, priv-&gt;last_caps);</span>
 866           break;
 867         }
 868         case GST_EVENT_SEGMENT:
 869           gst_event_copy_segment (event, &amp;priv-&gt;last_segment);
<span class="line-added"> 870           priv-&gt;sample = gst_sample_make_writable (priv-&gt;sample);</span>
<span class="line-added"> 871           gst_sample_set_segment (priv-&gt;sample, &amp;priv-&gt;last_segment);</span>
 872           GST_DEBUG_OBJECT (appsink, &quot;activated segment %&quot; GST_SEGMENT_FORMAT,
 873               &amp;priv-&gt;last_segment);
 874           break;
 875         default:
 876           break;
 877       }
 878       gst_mini_object_unref (obj);
 879     }
 880   } while (TRUE);
 881 
 882   return obj;
 883 }
 884 
 885 static GstFlowReturn
 886 gst_app_sink_render_common (GstBaseSink * psink, GstMiniObject * data,
 887     gboolean is_list)
 888 {
 889   GstFlowReturn ret;
 890   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
 891   GstAppSinkPrivate *priv = appsink-&gt;priv;
 892   gboolean emit;
 893 
 894 restart:
 895   g_mutex_lock (&amp;priv-&gt;mutex);
 896   if (priv-&gt;flushing)
 897     goto flushing;
 898 
 899   /* queue holding caps event might have been FLUSHed,
 900    * but caps state still present in pad caps */
 901   if (G_UNLIKELY (!priv-&gt;last_caps &amp;&amp;
 902           gst_pad_has_current_caps (GST_BASE_SINK_PAD (psink)))) {
 903     priv-&gt;last_caps = gst_pad_get_current_caps (GST_BASE_SINK_PAD (psink));
<span class="line-added"> 904     gst_sample_set_caps (priv-&gt;sample, priv-&gt;last_caps);</span>
 905     GST_DEBUG_OBJECT (appsink, &quot;activating pad caps %&quot; GST_PTR_FORMAT,
 906         priv-&gt;last_caps);
 907   }
 908 
 909   GST_DEBUG_OBJECT (appsink, &quot;pushing render buffer/list %p on queue (%d)&quot;,
 910       data, priv-&gt;num_buffers);
 911 
 912   while (priv-&gt;max_buffers &gt; 0 &amp;&amp; priv-&gt;num_buffers &gt;= priv-&gt;max_buffers) {
 913     if (priv-&gt;drop) {
 914       GstMiniObject *old;
 915 
 916       /* we need to drop the oldest buffer/list and try again */
 917       if ((old = dequeue_buffer (appsink))) {
 918         GST_DEBUG_OBJECT (appsink, &quot;dropping old buffer/list %p&quot;, old);
 919         gst_mini_object_unref (old);
 920       }
 921     } else {
 922       GST_DEBUG_OBJECT (appsink, &quot;waiting for free space, length %d &gt;= %d&quot;,
 923           priv-&gt;num_buffers, priv-&gt;max_buffers);
 924 
</pre>
<hr />
<pre>
 929           goto stopping;
 930 
 931         /* we are allowed to continue now */
 932         goto restart;
 933       }
 934 
 935       /* wait for a buffer to be removed or flush */
 936       priv-&gt;wait_status |= STREAM_WAITING;
 937       g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);
 938       priv-&gt;wait_status &amp;= ~STREAM_WAITING;
 939 
 940       if (priv-&gt;flushing)
 941         goto flushing;
 942     }
 943   }
 944   /* we need to ref the buffer/list when pushing it in the queue */
 945   gst_queue_array_push_tail (priv-&gt;queue, gst_mini_object_ref (data));
 946   priv-&gt;num_buffers++;
 947 
 948   if ((priv-&gt;wait_status &amp; APP_WAITING))
<span class="line-modified"> 949     g_cond_signal (&amp;priv-&gt;cond);</span>
 950 
 951   emit = priv-&gt;emit_signals;
 952   g_mutex_unlock (&amp;priv-&gt;mutex);
 953 
 954   if (priv-&gt;callbacks.new_sample) {
 955     ret = priv-&gt;callbacks.new_sample (appsink, priv-&gt;user_data);
 956   } else {
 957     ret = GST_FLOW_OK;
 958     if (emit)
 959       g_signal_emit (appsink, gst_app_sink_signals[SIGNAL_NEW_SAMPLE], 0, &amp;ret);
 960   }
 961   return ret;
 962 
 963 flushing:
 964   {
 965     GST_DEBUG_OBJECT (appsink, &quot;we are flushing&quot;);
 966     g_mutex_unlock (&amp;priv-&gt;mutex);
 967     return GST_FLOW_FLUSHING;
 968   }
 969 stopping:
</pre>
<hr />
<pre>
1563   g_mutex_lock (&amp;priv-&gt;mutex);
1564 
1565   while (TRUE) {
1566     GST_DEBUG_OBJECT (appsink, &quot;trying to grab a buffer&quot;);
1567     if (!priv-&gt;started)
1568       goto not_started;
1569 
1570     if (priv-&gt;preroll_buffer != NULL)
1571       break;
1572 
1573     if (priv-&gt;is_eos)
1574       goto eos;
1575 
1576     /* nothing to return, wait */
1577     GST_DEBUG_OBJECT (appsink, &quot;waiting for the preroll buffer&quot;);
1578     priv-&gt;wait_status |= APP_WAITING;
1579     if (timeout_valid) {
1580       if (!g_cond_wait_until (&amp;priv-&gt;cond, &amp;priv-&gt;mutex, end_time))
1581         goto expired;
1582     } else {
<span class="line-modified">1583       g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);</span>
<span class="line-modified">1584     }</span>
1585     priv-&gt;wait_status &amp;= ~APP_WAITING;
1586   }
1587   sample =
1588       gst_sample_new (priv-&gt;preroll_buffer, priv-&gt;preroll_caps,
1589       &amp;priv-&gt;preroll_segment, NULL);
1590   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
1591   GST_DEBUG_OBJECT (appsink, &quot;we have the preroll sample %p&quot;, sample);
1592   g_mutex_unlock (&amp;priv-&gt;mutex);
1593 
1594   return sample;
1595 
1596   /* special conditions */
1597 expired:
1598   {
1599     GST_DEBUG_OBJECT (appsink, &quot;timeout expired, return NULL&quot;);
1600     priv-&gt;wait_status &amp;= ~APP_WAITING;
1601     g_mutex_unlock (&amp;priv-&gt;mutex);
1602     return NULL;
1603   }
1604 eos:
</pre>
<hr />
<pre>
1661   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
1662 
1663   while (TRUE) {
1664     GST_DEBUG_OBJECT (appsink, &quot;trying to grab a buffer&quot;);
1665     if (!priv-&gt;started)
1666       goto not_started;
1667 
1668     if (priv-&gt;num_buffers &gt; 0)
1669       break;
1670 
1671     if (priv-&gt;is_eos)
1672       goto eos;
1673 
1674     /* nothing to return, wait */
1675     GST_DEBUG_OBJECT (appsink, &quot;waiting for a buffer&quot;);
1676     priv-&gt;wait_status |= APP_WAITING;
1677     if (timeout_valid) {
1678       if (!g_cond_wait_until (&amp;priv-&gt;cond, &amp;priv-&gt;mutex, end_time))
1679         goto expired;
1680     } else {
<span class="line-modified">1681       g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);</span>
<span class="line-modified">1682     }</span>
1683     priv-&gt;wait_status &amp;= ~APP_WAITING;
1684   }
1685 
1686   obj = dequeue_buffer (appsink);
1687   if (GST_IS_BUFFER (obj)) {
1688     GST_DEBUG_OBJECT (appsink, &quot;we have a buffer %p&quot;, obj);
<span class="line-modified">1689     priv-&gt;sample = gst_sample_make_writable (priv-&gt;sample);</span>
<span class="line-modified">1690     gst_sample_set_buffer_list (priv-&gt;sample, NULL);</span>
<span class="line-added">1691     gst_sample_set_buffer (priv-&gt;sample, GST_BUFFER_CAST (obj));</span>
<span class="line-added">1692     sample = gst_sample_ref (priv-&gt;sample);</span>
1693   } else {
1694     GST_DEBUG_OBJECT (appsink, &quot;we have a list %p&quot;, obj);
<span class="line-modified">1695     priv-&gt;sample = gst_sample_make_writable (priv-&gt;sample);</span>
<span class="line-modified">1696     gst_sample_set_buffer (priv-&gt;sample, NULL);</span>
<span class="line-added">1697     gst_sample_set_buffer_list (priv-&gt;sample, GST_BUFFER_LIST_CAST (obj));</span>
<span class="line-added">1698     sample = gst_sample_ref (priv-&gt;sample);</span>
1699   }
1700   gst_mini_object_unref (obj);
1701 
1702   if ((priv-&gt;wait_status &amp; STREAM_WAITING))
<span class="line-modified">1703     g_cond_signal (&amp;priv-&gt;cond);</span>
1704 
1705   g_mutex_unlock (&amp;priv-&gt;mutex);
1706 
1707   return sample;
1708 
1709   /* special conditions */
1710 expired:
1711   {
1712     GST_DEBUG_OBJECT (appsink, &quot;timeout expired, return NULL&quot;);
1713     priv-&gt;wait_status &amp;= ~APP_WAITING;
1714     g_mutex_unlock (&amp;priv-&gt;mutex);
1715     return NULL;
1716   }
1717 eos:
1718   {
1719     GST_DEBUG_OBJECT (appsink, &quot;we are EOS, return NULL&quot;);
1720     g_mutex_unlock (&amp;priv-&gt;mutex);
1721     return NULL;
1722   }
1723 not_started:
</pre>
</td>
</tr>
</table>
<center><a href="app-prelude.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstappsrc.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>