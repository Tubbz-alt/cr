<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/plugins/elements/gstqueue.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wtay@chello.be&gt;
   4  *                    2003 Colin Walters &lt;cwalters@gnome.org&gt;
   5  *                    2005 Wim Taymans &lt;wim@fluendo.com&gt;
   6  *
   7  * gstqueue.c:
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Library General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Library General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Library General Public
  20  * License along with this library; if not, write to the
  21  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  22  * Boston, MA 02110-1301, USA.
  23  */
  24 
  25 /**
  26  * SECTION:element-queue
  27  * @title: queue
  28  *
  29  * Data is queued until one of the limits specified by the
  30  * #GstQueue:max-size-buffers, #GstQueue:max-size-bytes and/or
  31  * #GstQueue:max-size-time properties has been reached. Any attempt to push
  32  * more buffers into the queue will block the pushing thread until more space
  33  * becomes available.
  34  *
  35  * The queue will create a new thread on the source pad to decouple the
  36  * processing on sink and source pad.
  37  *
  38  * You can query how many buffers are queued by reading the
  39  * #GstQueue:current-level-buffers property. You can track changes
  40  * by connecting to the notify::current-level-buffers signal (which
  41  * like all signals will be emitted from the streaming thread). The same
  42  * applies to the #GstQueue:current-level-time and
  43  * #GstQueue:current-level-bytes properties.
  44  *
  45  * The default queue size limits are 200 buffers, 10MB of data, or
  46  * one second worth of data, whichever is reached first.
  47  *
  48  * As said earlier, the queue blocks by default when one of the specified
  49  * maximums (bytes, time, buffers) has been reached. You can set the
  50  * #GstQueue:leaky property to specify that instead of blocking it should
  51  * leak (drop) new or old buffers.
  52  *
  53  * The #GstQueue::underrun signal is emitted when the queue has less data than
  54  * the specified minimum thresholds require (by default: when the queue is
  55  * empty). The #GstQueue::overrun signal is emitted when the queue is filled
  56  * up. Both signals are emitted from the context of the streaming thread.
  57  */
  58 
  59 #include &quot;gst/gst_private.h&quot;
  60 
  61 #include &lt;gst/gst.h&gt;
  62 #include &quot;gstqueue.h&quot;
  63 
  64 #include &quot;../../gst/gst-i18n-lib.h&quot;
  65 #include &quot;../../gst/glib-compat-private.h&quot;
  66 
  67 static GstStaticPadTemplate sinktemplate = GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,
  68     GST_PAD_SINK,
  69     GST_PAD_ALWAYS,
  70     GST_STATIC_CAPS_ANY);
  71 
  72 static GstStaticPadTemplate srctemplate = GST_STATIC_PAD_TEMPLATE (&quot;src&quot;,
  73     GST_PAD_SRC,
  74     GST_PAD_ALWAYS,
  75     GST_STATIC_CAPS_ANY);
  76 
  77 GST_DEBUG_CATEGORY_STATIC (queue_debug);
  78 #define GST_CAT_DEFAULT (queue_debug)
  79 GST_DEBUG_CATEGORY_STATIC (queue_dataflow);
  80 
  81 #define STATUS(queue, pad, msg) \
  82   GST_CAT_LOG_OBJECT (queue_dataflow, queue, \
  83                       &quot;(%s:%s) &quot; msg &quot;: %u of %u-%u buffers, %u of %u-%u &quot; \
  84                       &quot;bytes, %&quot; G_GUINT64_FORMAT &quot; of %&quot; G_GUINT64_FORMAT \
  85                       &quot;-%&quot; G_GUINT64_FORMAT &quot; ns, %u items&quot;, \
  86                       GST_DEBUG_PAD_NAME (pad), \
  87                       queue-&gt;cur_level.buffers, \
  88                       queue-&gt;min_threshold.buffers, \
  89                       queue-&gt;max_size.buffers, \
  90                       queue-&gt;cur_level.bytes, \
  91                       queue-&gt;min_threshold.bytes, \
  92                       queue-&gt;max_size.bytes, \
  93                       queue-&gt;cur_level.time, \
  94                       queue-&gt;min_threshold.time, \
  95                       queue-&gt;max_size.time, \
  96                       gst_queue_array_get_length (queue-&gt;queue))
  97 
  98 /* Queue signals and args */
  99 enum
 100 {
 101   SIGNAL_UNDERRUN,
 102   SIGNAL_RUNNING,
 103   SIGNAL_OVERRUN,
 104   SIGNAL_PUSHING,
 105   LAST_SIGNAL
 106 };
 107 
 108 enum
 109 {
 110   PROP_0,
 111   /* FIXME: don&#39;t we have another way of doing this
 112    * &quot;Gstreamer format&quot; (frame/byte/time) queries? */
 113   PROP_CUR_LEVEL_BUFFERS,
 114   PROP_CUR_LEVEL_BYTES,
 115   PROP_CUR_LEVEL_TIME,
 116   PROP_MAX_SIZE_BUFFERS,
 117   PROP_MAX_SIZE_BYTES,
 118   PROP_MAX_SIZE_TIME,
 119   PROP_MIN_THRESHOLD_BUFFERS,
 120   PROP_MIN_THRESHOLD_BYTES,
 121   PROP_MIN_THRESHOLD_TIME,
 122   PROP_LEAKY,
 123   PROP_SILENT,
 124   PROP_FLUSH_ON_EOS
 125 };
 126 
 127 /* default property values */
 128 #define DEFAULT_MAX_SIZE_BUFFERS  200   /* 200 buffers */
 129 #define DEFAULT_MAX_SIZE_BYTES    (10 * 1024 * 1024)    /* 10 MB       */
 130 #define DEFAULT_MAX_SIZE_TIME     GST_SECOND    /* 1 second    */
 131 
 132 #define GST_QUEUE_MUTEX_LOCK(q) G_STMT_START {                          \
 133   g_mutex_lock (&amp;q-&gt;qlock);                                              \
 134 } G_STMT_END
 135 
 136 #define GST_QUEUE_MUTEX_LOCK_CHECK(q,label) G_STMT_START {              \
 137   GST_QUEUE_MUTEX_LOCK (q);                                             \
 138   if (q-&gt;srcresult != GST_FLOW_OK)                                      \
 139     goto label;                                                         \
 140 } G_STMT_END
 141 
 142 #define GST_QUEUE_MUTEX_UNLOCK(q) G_STMT_START {                        \
 143   g_mutex_unlock (&amp;q-&gt;qlock);                                            \
 144 } G_STMT_END
 145 
 146 #define GST_QUEUE_WAIT_DEL_CHECK(q, label) G_STMT_START {               \
 147   STATUS (q, q-&gt;sinkpad, &quot;wait for DEL&quot;);                               \
 148   q-&gt;waiting_del = TRUE;                                                \
 149   g_cond_wait (&amp;q-&gt;item_del, &amp;q-&gt;qlock);                                  \
 150   q-&gt;waiting_del = FALSE;                                               \
 151   if (q-&gt;srcresult != GST_FLOW_OK) {                                    \
 152     STATUS (q, q-&gt;srcpad, &quot;received DEL wakeup&quot;);                       \
 153     goto label;                                                         \
 154   }                                                                     \
 155   STATUS (q, q-&gt;sinkpad, &quot;received DEL&quot;);                               \
 156 } G_STMT_END
 157 
 158 #define GST_QUEUE_WAIT_ADD_CHECK(q, label) G_STMT_START {               \
 159   STATUS (q, q-&gt;srcpad, &quot;wait for ADD&quot;);                                \
 160   q-&gt;waiting_add = TRUE;                                                \
 161   g_cond_wait (&amp;q-&gt;item_add, &amp;q-&gt;qlock);                                  \
 162   q-&gt;waiting_add = FALSE;                                               \
 163   if (q-&gt;srcresult != GST_FLOW_OK) {                                    \
 164     STATUS (q, q-&gt;srcpad, &quot;received ADD wakeup&quot;);                       \
 165     goto label;                                                         \
 166   }                                                                     \
 167   STATUS (q, q-&gt;srcpad, &quot;received ADD&quot;);                                \
 168 } G_STMT_END
 169 
 170 #define GST_QUEUE_SIGNAL_DEL(q) G_STMT_START {                          \
 171   if (q-&gt;waiting_del) {                                                 \
 172     STATUS (q, q-&gt;srcpad, &quot;signal DEL&quot;);                                \
 173     g_cond_signal (&amp;q-&gt;item_del);                                        \
 174   }                                                                     \
 175 } G_STMT_END
 176 
 177 #define GST_QUEUE_SIGNAL_ADD(q) G_STMT_START {                          \
 178   if (q-&gt;waiting_add) {                                                 \
 179     STATUS (q, q-&gt;sinkpad, &quot;signal ADD&quot;);                               \
 180     g_cond_signal (&amp;q-&gt;item_add);                                        \
 181   }                                                                     \
 182 } G_STMT_END
 183 
 184 #define _do_init \
 185     GST_DEBUG_CATEGORY_INIT (queue_debug, &quot;queue&quot;, 0, &quot;queue element&quot;); \
 186     GST_DEBUG_CATEGORY_INIT (queue_dataflow, &quot;queue_dataflow&quot;, 0, \
 187         &quot;dataflow inside the queue element&quot;);
 188 #define gst_queue_parent_class parent_class
 189 G_DEFINE_TYPE_WITH_CODE (GstQueue, gst_queue, GST_TYPE_ELEMENT, _do_init);
 190 
 191 static void gst_queue_finalize (GObject * object);
 192 static void gst_queue_set_property (GObject * object,
 193     guint prop_id, const GValue * value, GParamSpec * pspec);
 194 static void gst_queue_get_property (GObject * object,
 195     guint prop_id, GValue * value, GParamSpec * pspec);
 196 
 197 static GstFlowReturn gst_queue_chain (GstPad * pad, GstObject * parent,
 198     GstBuffer * buffer);
 199 static GstFlowReturn gst_queue_chain_list (GstPad * pad, GstObject * parent,
 200     GstBufferList * buffer_list);
 201 static GstFlowReturn gst_queue_push_one (GstQueue * queue);
 202 static void gst_queue_loop (GstPad * pad);
 203 
 204 static GstFlowReturn gst_queue_handle_sink_event (GstPad * pad,
 205     GstObject * parent, GstEvent * event);
 206 static gboolean gst_queue_handle_sink_query (GstPad * pad, GstObject * parent,
 207     GstQuery * query);
 208 
 209 static gboolean gst_queue_handle_src_event (GstPad * pad, GstObject * parent,
 210     GstEvent * event);
 211 static gboolean gst_queue_handle_src_query (GstPad * pad, GstObject * parent,
 212     GstQuery * query);
 213 
 214 static void gst_queue_locked_flush (GstQueue * queue, gboolean full);
 215 
 216 static gboolean gst_queue_src_activate_mode (GstPad * pad, GstObject * parent,
 217     GstPadMode mode, gboolean active);
 218 static gboolean gst_queue_sink_activate_mode (GstPad * pad, GstObject * parent,
 219     GstPadMode mode, gboolean active);
 220 
 221 static gboolean gst_queue_is_empty (GstQueue * queue);
 222 static gboolean gst_queue_is_filled (GstQueue * queue);
 223 
 224 #ifdef GSTREAMER_LITE
 225 static GstStateChangeReturn gst_queue_change_state (GstElement *element, GstStateChange transition);
 226 #endif
 227 
 228 typedef struct
 229 {
 230   GstMiniObject *item;
 231   gsize size;
 232   gboolean is_query;
 233 } GstQueueItem;
 234 
 235 #define GST_TYPE_QUEUE_LEAKY (queue_leaky_get_type ())
 236 
 237 static GType
 238 queue_leaky_get_type (void)
 239 {
 240   static GType queue_leaky_type = 0;
 241   static const GEnumValue queue_leaky[] = {
 242     {GST_QUEUE_NO_LEAK, &quot;Not Leaky&quot;, &quot;no&quot;},
 243     {GST_QUEUE_LEAK_UPSTREAM, &quot;Leaky on upstream (new buffers)&quot;, &quot;upstream&quot;},
 244     {GST_QUEUE_LEAK_DOWNSTREAM, &quot;Leaky on downstream (old buffers)&quot;,
 245         &quot;downstream&quot;},
 246     {0, NULL, NULL},
 247   };
 248 
 249   if (!queue_leaky_type) {
 250     queue_leaky_type = g_enum_register_static (&quot;GstQueueLeaky&quot;, queue_leaky);
 251   }
 252   return queue_leaky_type;
 253 }
 254 
 255 static guint gst_queue_signals[LAST_SIGNAL] = { 0 };
 256 
 257 static void
 258 gst_queue_class_init (GstQueueClass * klass)
 259 {
 260   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 261   GstElementClass *gstelement_class = GST_ELEMENT_CLASS (klass);
 262 
 263   gobject_class-&gt;set_property = gst_queue_set_property;
 264   gobject_class-&gt;get_property = gst_queue_get_property;
 265 
 266   /* signals */
 267   /**
 268    * GstQueue::underrun:
 269    * @queue: the queue instance
 270    *
 271    * Reports that the buffer became empty (underrun).
 272    * A buffer is empty if the total amount of data inside it (num-buffers, time,
 273    * size) is lower than the boundary values which can be set through the
 274    * GObject properties.
 275    */
 276   gst_queue_signals[SIGNAL_UNDERRUN] =
 277       g_signal_new (&quot;underrun&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_FIRST,
 278       G_STRUCT_OFFSET (GstQueueClass, underrun), NULL, NULL,
 279       g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
 280   /**
 281    * GstQueue::running:
 282    * @queue: the queue instance
 283    *
 284    * Reports that enough (min-threshold) data is in the queue. Use this signal
 285    * together with the underrun signal to pause the pipeline on underrun and
 286    * wait for the queue to fill-up before resume playback.
 287    */
 288   gst_queue_signals[SIGNAL_RUNNING] =
 289       g_signal_new (&quot;running&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_FIRST,
 290       G_STRUCT_OFFSET (GstQueueClass, running), NULL, NULL,
 291       g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
 292   /**
 293    * GstQueue::overrun:
 294    * @queue: the queue instance
 295    *
 296    * Reports that the buffer became full (overrun).
 297    * A buffer is full if the total amount of data inside it (num-buffers, time,
 298    * size) is higher than the boundary values which can be set through the
 299    * GObject properties.
 300    */
 301   gst_queue_signals[SIGNAL_OVERRUN] =
 302       g_signal_new (&quot;overrun&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_FIRST,
 303       G_STRUCT_OFFSET (GstQueueClass, overrun), NULL, NULL,
 304       g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
 305   /**
 306    * GstQueue::pushing:
 307    * @queue: the queue instance
 308    *
 309    * Reports when the queue has enough data to start pushing data again on the
 310    * source pad.
 311    */
 312   gst_queue_signals[SIGNAL_PUSHING] =
 313       g_signal_new (&quot;pushing&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_FIRST,
 314       G_STRUCT_OFFSET (GstQueueClass, pushing), NULL, NULL,
 315       g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
 316 
 317   /* properties */
 318   g_object_class_install_property (gobject_class, PROP_CUR_LEVEL_BYTES,
 319       g_param_spec_uint (&quot;current-level-bytes&quot;, &quot;Current level (kB)&quot;,
 320           &quot;Current amount of data in the queue (bytes)&quot;,
 321           0, G_MAXUINT, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 322   g_object_class_install_property (gobject_class, PROP_CUR_LEVEL_BUFFERS,
 323       g_param_spec_uint (&quot;current-level-buffers&quot;, &quot;Current level (buffers)&quot;,
 324           &quot;Current number of buffers in the queue&quot;,
 325           0, G_MAXUINT, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 326   g_object_class_install_property (gobject_class, PROP_CUR_LEVEL_TIME,
 327       g_param_spec_uint64 (&quot;current-level-time&quot;, &quot;Current level (ns)&quot;,
 328           &quot;Current amount of data in the queue (in ns)&quot;,
 329           0, G_MAXUINT64, 0, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 330 
 331   g_object_class_install_property (gobject_class, PROP_MAX_SIZE_BYTES,
 332       g_param_spec_uint (&quot;max-size-bytes&quot;, &quot;Max. size (kB)&quot;,
 333           &quot;Max. amount of data in the queue (bytes, 0=disable)&quot;,
 334           0, G_MAXUINT, DEFAULT_MAX_SIZE_BYTES,
 335           G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |
 336           G_PARAM_STATIC_STRINGS));
 337   g_object_class_install_property (gobject_class, PROP_MAX_SIZE_BUFFERS,
 338       g_param_spec_uint (&quot;max-size-buffers&quot;, &quot;Max. size (buffers)&quot;,
 339           &quot;Max. number of buffers in the queue (0=disable)&quot;, 0, G_MAXUINT,
 340           DEFAULT_MAX_SIZE_BUFFERS,
 341           G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |
 342           G_PARAM_STATIC_STRINGS));
 343   g_object_class_install_property (gobject_class, PROP_MAX_SIZE_TIME,
 344       g_param_spec_uint64 (&quot;max-size-time&quot;, &quot;Max. size (ns)&quot;,
 345           &quot;Max. amount of data in the queue (in ns, 0=disable)&quot;, 0, G_MAXUINT64,
 346           DEFAULT_MAX_SIZE_TIME,
 347           G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |
 348           G_PARAM_STATIC_STRINGS));
 349 
 350   g_object_class_install_property (gobject_class, PROP_MIN_THRESHOLD_BYTES,
 351       g_param_spec_uint (&quot;min-threshold-bytes&quot;, &quot;Min. threshold (kB)&quot;,
 352           &quot;Min. amount of data in the queue to allow reading (bytes, 0=disable)&quot;,
 353           0, G_MAXUINT, 0,
 354           G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |
 355           G_PARAM_STATIC_STRINGS));
 356   g_object_class_install_property (gobject_class, PROP_MIN_THRESHOLD_BUFFERS,
 357       g_param_spec_uint (&quot;min-threshold-buffers&quot;, &quot;Min. threshold (buffers)&quot;,
 358           &quot;Min. number of buffers in the queue to allow reading (0=disable)&quot;, 0,
 359           G_MAXUINT, 0,
 360           G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |
 361           G_PARAM_STATIC_STRINGS));
 362   g_object_class_install_property (gobject_class, PROP_MIN_THRESHOLD_TIME,
 363       g_param_spec_uint64 (&quot;min-threshold-time&quot;, &quot;Min. threshold (ns)&quot;,
 364           &quot;Min. amount of data in the queue to allow reading (in ns, 0=disable)&quot;,
 365           0, G_MAXUINT64, 0,
 366           G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |
 367           G_PARAM_STATIC_STRINGS));
 368 
 369   g_object_class_install_property (gobject_class, PROP_LEAKY,
 370       g_param_spec_enum (&quot;leaky&quot;, &quot;Leaky&quot;,
 371           &quot;Where the queue leaks, if at all&quot;,
 372           GST_TYPE_QUEUE_LEAKY, GST_QUEUE_NO_LEAK,
 373           G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |
 374           G_PARAM_STATIC_STRINGS));
 375 
 376   /**
 377    * GstQueue:silent
 378    *
 379    * Don&#39;t emit queue signals. Makes queues more lightweight if no signals are
 380    * needed.
 381    */
 382   g_object_class_install_property (gobject_class, PROP_SILENT,
 383       g_param_spec_boolean (&quot;silent&quot;, &quot;Silent&quot;,
 384           &quot;Don&#39;t emit queue signals&quot;, FALSE,
 385           G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |
 386           G_PARAM_STATIC_STRINGS));
 387 
 388   /**
 389    * GstQueue:flush-on-eos
 390    *
 391    * Discard all data in the queue when an EOS event is received, and pass
 392    * on the EOS event as soon as possible (instead of waiting until all
 393    * buffers in the queue have been processed, which is the default behaviour).
 394    *
 395    * Flushing the queue on EOS might be useful when capturing and encoding
 396    * from a live source, to finish up the recording quickly in cases when
 397    * the encoder is slow. Note that this might mean some data from the end of
 398    * the recording data might be lost though (never more than the configured
 399    * max. sizes though).
 400    *
 401    * Since: 1.2
 402    */
 403   g_object_class_install_property (gobject_class, PROP_FLUSH_ON_EOS,
 404       g_param_spec_boolean (&quot;flush-on-eos&quot;, &quot;Flush on EOS&quot;,
 405           &quot;Discard all data in the queue when an EOS event is received&quot;, FALSE,
 406           G_PARAM_READWRITE | GST_PARAM_MUTABLE_PLAYING |
 407           G_PARAM_STATIC_STRINGS));
 408 
 409   gobject_class-&gt;finalize = gst_queue_finalize;
 410 
 411 #ifdef GSTREAMER_LITE
 412   GST_ELEMENT_CLASS (klass)-&gt;change_state = GST_DEBUG_FUNCPTR(gst_queue_change_state);
 413 #endif
 414 
 415   gst_element_class_set_static_metadata (gstelement_class,
 416       &quot;Queue&quot;,
 417       &quot;Generic&quot;, &quot;Simple data queue&quot;, &quot;Erik Walthinsen &lt;omega@cse.ogi.edu&gt;&quot;);
 418   gst_element_class_add_static_pad_template (gstelement_class, &amp;srctemplate);
 419   gst_element_class_add_static_pad_template (gstelement_class, &amp;sinktemplate);
 420 
 421   /* Registering debug symbols for function pointers */
 422   GST_DEBUG_REGISTER_FUNCPTR (gst_queue_src_activate_mode);
 423   GST_DEBUG_REGISTER_FUNCPTR (gst_queue_handle_sink_event);
 424   GST_DEBUG_REGISTER_FUNCPTR (gst_queue_handle_sink_query);
 425   GST_DEBUG_REGISTER_FUNCPTR (gst_queue_handle_src_event);
 426   GST_DEBUG_REGISTER_FUNCPTR (gst_queue_handle_src_query);
 427   GST_DEBUG_REGISTER_FUNCPTR (gst_queue_chain);
 428   GST_DEBUG_REGISTER_FUNCPTR (gst_queue_chain_list);
 429 }
 430 
 431 static void
 432 gst_queue_init (GstQueue * queue)
 433 {
 434   queue-&gt;sinkpad = gst_pad_new_from_static_template (&amp;sinktemplate, &quot;sink&quot;);
 435 
 436   gst_pad_set_chain_function (queue-&gt;sinkpad, gst_queue_chain);
 437   gst_pad_set_chain_list_function (queue-&gt;sinkpad, gst_queue_chain_list);
 438   gst_pad_set_activatemode_function (queue-&gt;sinkpad,
 439       gst_queue_sink_activate_mode);
 440   gst_pad_set_event_full_function (queue-&gt;sinkpad, gst_queue_handle_sink_event);
 441   gst_pad_set_query_function (queue-&gt;sinkpad, gst_queue_handle_sink_query);
 442   GST_PAD_SET_PROXY_CAPS (queue-&gt;sinkpad);
 443   gst_element_add_pad (GST_ELEMENT (queue), queue-&gt;sinkpad);
 444 
 445   queue-&gt;srcpad = gst_pad_new_from_static_template (&amp;srctemplate, &quot;src&quot;);
 446 
 447   gst_pad_set_activatemode_function (queue-&gt;srcpad,
 448       gst_queue_src_activate_mode);
 449   gst_pad_set_event_function (queue-&gt;srcpad, gst_queue_handle_src_event);
 450   gst_pad_set_query_function (queue-&gt;srcpad, gst_queue_handle_src_query);
 451   GST_PAD_SET_PROXY_CAPS (queue-&gt;srcpad);
 452   gst_element_add_pad (GST_ELEMENT (queue), queue-&gt;srcpad);
 453 
 454   GST_QUEUE_CLEAR_LEVEL (queue-&gt;cur_level);
 455   queue-&gt;max_size.buffers = DEFAULT_MAX_SIZE_BUFFERS;
 456   queue-&gt;max_size.bytes = DEFAULT_MAX_SIZE_BYTES;
 457   queue-&gt;max_size.time = DEFAULT_MAX_SIZE_TIME;
 458   GST_QUEUE_CLEAR_LEVEL (queue-&gt;min_threshold);
 459   GST_QUEUE_CLEAR_LEVEL (queue-&gt;orig_min_threshold);
 460   gst_segment_init (&amp;queue-&gt;sink_segment, GST_FORMAT_TIME);
 461   gst_segment_init (&amp;queue-&gt;src_segment, GST_FORMAT_TIME);
 462   queue-&gt;head_needs_discont = queue-&gt;tail_needs_discont = FALSE;
 463 
 464   queue-&gt;leaky = GST_QUEUE_NO_LEAK;
 465   queue-&gt;srcresult = GST_FLOW_FLUSHING;
 466 
 467   g_mutex_init (&amp;queue-&gt;qlock);
 468   g_cond_init (&amp;queue-&gt;item_add);
 469   g_cond_init (&amp;queue-&gt;item_del);
 470   g_cond_init (&amp;queue-&gt;query_handled);
 471 
 472   queue-&gt;queue =
 473       gst_queue_array_new_for_struct (sizeof (GstQueueItem),
 474       DEFAULT_MAX_SIZE_BUFFERS * 3 / 2);
 475 
 476   queue-&gt;sinktime = GST_CLOCK_STIME_NONE;
 477   queue-&gt;srctime = GST_CLOCK_STIME_NONE;
 478 
 479   queue-&gt;sink_tainted = TRUE;
 480   queue-&gt;src_tainted = TRUE;
 481 
 482   queue-&gt;newseg_applied_to_src = FALSE;
 483 
 484   GST_DEBUG_OBJECT (queue,
 485       &quot;initialized queue&#39;s not_empty &amp; not_full conditions&quot;);
 486 }
 487 
 488 /* called only once, as opposed to dispose */
 489 static void
 490 gst_queue_finalize (GObject * object)
 491 {
 492   GstQueue *queue = GST_QUEUE (object);
 493   GstQueueItem *qitem;
 494 
 495   GST_DEBUG_OBJECT (queue, &quot;finalizing queue&quot;);
 496 
 497   while ((qitem = gst_queue_array_pop_head_struct (queue-&gt;queue))) {
 498     /* FIXME: if it&#39;s a query, shouldn&#39;t we unref that too? */
 499     if (!qitem-&gt;is_query)
 500       gst_mini_object_unref (qitem-&gt;item);
 501   }
 502   gst_queue_array_free (queue-&gt;queue);
 503 
 504   g_mutex_clear (&amp;queue-&gt;qlock);
 505   g_cond_clear (&amp;queue-&gt;item_add);
 506   g_cond_clear (&amp;queue-&gt;item_del);
 507   g_cond_clear (&amp;queue-&gt;query_handled);
 508 
 509   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 510 }
 511 
 512 /* Convenience function */
 513 static inline GstClockTimeDiff
 514 my_segment_to_running_time (GstSegment * segment, GstClockTime val)
 515 {
 516   GstClockTimeDiff res = GST_CLOCK_STIME_NONE;
 517 
 518   if (GST_CLOCK_TIME_IS_VALID (val)) {
 519     gboolean sign =
 520         gst_segment_to_running_time_full (segment, GST_FORMAT_TIME, val, &amp;val);
 521     if (sign &gt; 0)
 522       res = val;
 523     else if (sign &lt; 0)
 524       res = -val;
 525   }
 526   return res;
 527 }
 528 
 529 /* calculate the diff between running time on the sink and src of the queue.
 530  * This is the total amount of time in the queue. */
 531 static void
 532 update_time_level (GstQueue * queue)
 533 {
 534   gint64 sink_time, src_time;
 535 
 536   if (queue-&gt;sink_tainted) {
 537     GST_LOG_OBJECT (queue, &quot;update sink time&quot;);
 538     queue-&gt;sinktime =
 539         my_segment_to_running_time (&amp;queue-&gt;sink_segment,
 540         queue-&gt;sink_segment.position);
 541     queue-&gt;sink_tainted = FALSE;
 542   }
 543   sink_time = queue-&gt;sinktime;
 544 
 545   if (queue-&gt;src_tainted) {
 546     GST_LOG_OBJECT (queue, &quot;update src time&quot;);
 547     queue-&gt;srctime =
 548         my_segment_to_running_time (&amp;queue-&gt;src_segment,
 549         queue-&gt;src_segment.position);
 550     queue-&gt;src_tainted = FALSE;
 551   }
 552   src_time = queue-&gt;srctime;
 553 
 554   GST_LOG_OBJECT (queue, &quot;sink %&quot; GST_STIME_FORMAT &quot;, src %&quot; GST_STIME_FORMAT,
 555       GST_STIME_ARGS (sink_time), GST_STIME_ARGS (src_time));
 556 
 557   if (GST_CLOCK_STIME_IS_VALID (src_time)
 558       &amp;&amp; GST_CLOCK_STIME_IS_VALID (sink_time) &amp;&amp; sink_time &gt;= src_time)
 559     queue-&gt;cur_level.time = sink_time - src_time;
 560   else
 561     queue-&gt;cur_level.time = 0;
 562 }
 563 
 564 /* take a SEGMENT event and apply the values to segment, updating the time
 565  * level of queue. */
 566 static void
 567 apply_segment (GstQueue * queue, GstEvent * event, GstSegment * segment,
 568     gboolean sink)
 569 {
 570   gst_event_copy_segment (event, segment);
 571 
 572   /* now configure the values, we use these to track timestamps on the
 573    * sinkpad. */
 574   if (segment-&gt;format != GST_FORMAT_TIME) {
 575     /* non-time format, pretent the current time segment is closed with a
 576      * 0 start and unknown stop time. */
 577     segment-&gt;format = GST_FORMAT_TIME;
 578     segment-&gt;start = 0;
 579     segment-&gt;stop = -1;
 580     segment-&gt;time = 0;
 581   }
 582   if (sink)
 583     queue-&gt;sink_tainted = TRUE;
 584   else
 585     queue-&gt;src_tainted = TRUE;
 586 
 587   GST_DEBUG_OBJECT (queue, &quot;configured SEGMENT %&quot; GST_SEGMENT_FORMAT, segment);
 588 
 589   /* segment can update the time level of the queue */
 590   update_time_level (queue);
 591 }
 592 
 593 static void
 594 apply_gap (GstQueue * queue, GstEvent * event,
 595     GstSegment * segment, gboolean is_sink)
 596 {
 597   GstClockTime timestamp;
 598   GstClockTime duration;
 599 
 600   gst_event_parse_gap (event, &amp;timestamp, &amp;duration);
 601 
 602   if (GST_CLOCK_TIME_IS_VALID (timestamp)) {
 603 
 604     if (GST_CLOCK_TIME_IS_VALID (duration)) {
 605       timestamp += duration;
 606     }
 607 
 608     segment-&gt;position = timestamp;
 609 
 610     if (is_sink)
 611       queue-&gt;sink_tainted = TRUE;
 612     else
 613       queue-&gt;src_tainted = TRUE;
 614 
 615     /* calc diff with other end */
 616     update_time_level (queue);
 617   }
 618 }
 619 
 620 
 621 /* take a buffer and update segment, updating the time level of the queue. */
 622 static void
 623 apply_buffer (GstQueue * queue, GstBuffer * buffer, GstSegment * segment,
 624     gboolean sink)
 625 {
 626   GstClockTime duration, timestamp;
 627 
 628   timestamp = GST_BUFFER_DTS_OR_PTS (buffer);
 629   duration = GST_BUFFER_DURATION (buffer);
 630 
 631   /* if no timestamp is set, assume it&#39;s continuous with the previous
 632    * time */
 633   if (timestamp == GST_CLOCK_TIME_NONE)
 634     timestamp = segment-&gt;position;
 635 
 636   /* add duration */
 637   if (duration != GST_CLOCK_TIME_NONE)
 638     timestamp += duration;
 639 
 640   GST_LOG_OBJECT (queue, &quot;%s position updated to %&quot; GST_TIME_FORMAT,
 641       segment == &amp;queue-&gt;sink_segment ? &quot;sink&quot; : &quot;src&quot;,
 642       GST_TIME_ARGS (timestamp));
 643 
 644   segment-&gt;position = timestamp;
 645   if (sink)
 646     queue-&gt;sink_tainted = TRUE;
 647   else
 648     queue-&gt;src_tainted = TRUE;
 649 
 650 
 651   /* calc diff with other end */
 652   update_time_level (queue);
 653 }
 654 
 655 static gboolean
 656 buffer_list_apply_time (GstBuffer ** buf, guint idx, gpointer user_data)
 657 {
 658   GstClockTime *timestamp = user_data;
 659   GstClockTime btime;
 660 
 661   GST_TRACE (&quot;buffer %u has pts %&quot; GST_TIME_FORMAT &quot; dts %&quot; GST_TIME_FORMAT
 662       &quot; duration %&quot; GST_TIME_FORMAT, idx, GST_TIME_ARGS (GST_BUFFER_DTS (*buf)),
 663       GST_TIME_ARGS (GST_BUFFER_PTS (*buf)),
 664       GST_TIME_ARGS (GST_BUFFER_DURATION (*buf)));
 665 
 666   btime = GST_BUFFER_DTS_OR_PTS (*buf);
 667   if (GST_CLOCK_TIME_IS_VALID (btime))
 668     *timestamp = btime;
 669 
 670   if (GST_BUFFER_DURATION_IS_VALID (*buf))
 671     *timestamp += GST_BUFFER_DURATION (*buf);
 672 
 673   GST_TRACE (&quot;ts now %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (*timestamp));
 674 
 675   return TRUE;
 676 }
 677 
 678 /* take a buffer list and update segment, updating the time level of the queue */
 679 static void
 680 apply_buffer_list (GstQueue * queue, GstBufferList * buffer_list,
 681     GstSegment * segment, gboolean sink)
 682 {
 683   GstClockTime timestamp;
 684 
 685   /* if no timestamp is set, assume it&#39;s continuous with the previous time */
 686   timestamp = segment-&gt;position;
 687 
 688   gst_buffer_list_foreach (buffer_list, buffer_list_apply_time, &amp;timestamp);
 689 
 690   GST_DEBUG_OBJECT (queue, &quot;position updated to %&quot; GST_TIME_FORMAT,
 691       GST_TIME_ARGS (timestamp));
 692 
 693   segment-&gt;position = timestamp;
 694 
 695   if (sink)
 696     queue-&gt;sink_tainted = TRUE;
 697   else
 698     queue-&gt;src_tainted = TRUE;
 699 
 700   /* calc diff with other end */
 701   update_time_level (queue);
 702 }
 703 
 704 static void
 705 gst_queue_locked_flush (GstQueue * queue, gboolean full)
 706 {
 707   GstQueueItem *qitem;
 708 
 709   while ((qitem = gst_queue_array_pop_head_struct (queue-&gt;queue))) {
 710     /* Then lose another reference because we are supposed to destroy that
 711        data when flushing */
 712     if (!full &amp;&amp; !qitem-&gt;is_query &amp;&amp; GST_IS_EVENT (qitem-&gt;item)
 713         &amp;&amp; GST_EVENT_IS_STICKY (qitem-&gt;item)
 714         &amp;&amp; GST_EVENT_TYPE (qitem-&gt;item) != GST_EVENT_SEGMENT
 715         &amp;&amp; GST_EVENT_TYPE (qitem-&gt;item) != GST_EVENT_EOS) {
 716       gst_pad_store_sticky_event (queue-&gt;srcpad, GST_EVENT_CAST (qitem-&gt;item));
 717     }
 718     if (!qitem-&gt;is_query)
 719       gst_mini_object_unref (qitem-&gt;item);
 720     memset (qitem, 0, sizeof (GstQueueItem));
 721   }
 722   queue-&gt;last_query = FALSE;
 723   g_cond_signal (&amp;queue-&gt;query_handled);
 724   GST_QUEUE_CLEAR_LEVEL (queue-&gt;cur_level);
 725   queue-&gt;min_threshold.buffers = queue-&gt;orig_min_threshold.buffers;
 726   queue-&gt;min_threshold.bytes = queue-&gt;orig_min_threshold.bytes;
 727   queue-&gt;min_threshold.time = queue-&gt;orig_min_threshold.time;
 728   gst_segment_init (&amp;queue-&gt;sink_segment, GST_FORMAT_TIME);
 729   gst_segment_init (&amp;queue-&gt;src_segment, GST_FORMAT_TIME);
 730   queue-&gt;head_needs_discont = queue-&gt;tail_needs_discont = FALSE;
 731 
 732   queue-&gt;sinktime = queue-&gt;srctime = GST_CLOCK_STIME_NONE;
 733   queue-&gt;sink_tainted = queue-&gt;src_tainted = TRUE;
 734 
 735   /* we deleted a lot of something */
 736   GST_QUEUE_SIGNAL_DEL (queue);
 737 }
 738 
 739 /* enqueue an item an update the level stats, with QUEUE_LOCK */
 740 static inline void
 741 gst_queue_locked_enqueue_buffer (GstQueue * queue, gpointer item)
 742 {
 743   GstQueueItem qitem;
 744   GstBuffer *buffer = GST_BUFFER_CAST (item);
 745   gsize bsize = gst_buffer_get_size (buffer);
 746 
 747   /* add buffer to the statistics */
 748   queue-&gt;cur_level.buffers++;
 749   queue-&gt;cur_level.bytes += bsize;
 750   apply_buffer (queue, buffer, &amp;queue-&gt;sink_segment, TRUE);
 751 
 752   qitem.item = item;
 753   qitem.is_query = FALSE;
 754   qitem.size = bsize;
 755   gst_queue_array_push_tail_struct (queue-&gt;queue, &amp;qitem);
 756   GST_QUEUE_SIGNAL_ADD (queue);
 757 }
 758 
 759 static inline void
 760 gst_queue_locked_enqueue_buffer_list (GstQueue * queue, gpointer item)
 761 {
 762   GstQueueItem qitem;
 763   GstBufferList *buffer_list = GST_BUFFER_LIST_CAST (item);
 764   gsize bsize;
 765 
 766   bsize = gst_buffer_list_calculate_size (buffer_list);
 767 
 768   /* add buffer to the statistics */
 769   queue-&gt;cur_level.buffers += gst_buffer_list_length (buffer_list);
 770   queue-&gt;cur_level.bytes += bsize;
 771   apply_buffer_list (queue, buffer_list, &amp;queue-&gt;sink_segment, TRUE);
 772 
 773   qitem.item = item;
 774   qitem.is_query = FALSE;
 775   qitem.size = bsize;
 776   gst_queue_array_push_tail_struct (queue-&gt;queue, &amp;qitem);
 777   GST_QUEUE_SIGNAL_ADD (queue);
 778 }
 779 
 780 static inline void
 781 gst_queue_locked_enqueue_event (GstQueue * queue, gpointer item)
 782 {
 783   GstQueueItem qitem;
 784   GstEvent *event = GST_EVENT_CAST (item);
 785 
 786   switch (GST_EVENT_TYPE (event)) {
 787     case GST_EVENT_EOS:
 788       GST_CAT_LOG_OBJECT (queue_dataflow, queue, &quot;got EOS from upstream&quot;);
 789       /* Zero the thresholds, this makes sure the queue is completely
 790        * filled and we can read all data from the queue. */
 791       if (queue-&gt;flush_on_eos)
 792         gst_queue_locked_flush (queue, FALSE);
 793       else
 794         GST_QUEUE_CLEAR_LEVEL (queue-&gt;min_threshold);
 795       /* mark the queue as EOS. This prevents us from accepting more data. */
 796       queue-&gt;eos = TRUE;
 797       break;
 798     case GST_EVENT_SEGMENT:
 799       apply_segment (queue, event, &amp;queue-&gt;sink_segment, TRUE);
 800       /* if the queue is empty, apply sink segment on the source */
 801       if (gst_queue_array_is_empty (queue-&gt;queue)) {
 802         GST_CAT_LOG_OBJECT (queue_dataflow, queue, &quot;Apply segment on srcpad&quot;);
 803         apply_segment (queue, event, &amp;queue-&gt;src_segment, FALSE);
 804         queue-&gt;newseg_applied_to_src = TRUE;
 805       }
 806       /* a new segment allows us to accept more buffers if we got EOS
 807        * from downstream */
 808       queue-&gt;unexpected = FALSE;
 809       break;
 810     case GST_EVENT_GAP:
 811       apply_gap (queue, event, &amp;queue-&gt;sink_segment, TRUE);
 812       break;
 813     default:
 814       break;
 815   }
 816 
 817   qitem.item = item;
 818   qitem.is_query = FALSE;
 819   qitem.size = 0;
 820   gst_queue_array_push_tail_struct (queue-&gt;queue, &amp;qitem);
 821   GST_QUEUE_SIGNAL_ADD (queue);
 822 }
 823 
 824 /* dequeue an item from the queue and update level stats, with QUEUE_LOCK */
 825 static GstMiniObject *
 826 gst_queue_locked_dequeue (GstQueue * queue)
 827 {
 828   GstQueueItem *qitem;
 829   GstMiniObject *item;
 830   gsize bufsize;
 831 
 832   qitem = gst_queue_array_pop_head_struct (queue-&gt;queue);
 833   if (qitem == NULL)
 834     goto no_item;
 835 
 836   item = qitem-&gt;item;
 837   bufsize = qitem-&gt;size;
 838 
 839   if (GST_IS_BUFFER (item)) {
 840     GstBuffer *buffer = GST_BUFFER_CAST (item);
 841 
 842     GST_CAT_LOG_OBJECT (queue_dataflow, queue,
 843         &quot;retrieved buffer %p from queue&quot;, buffer);
 844 
 845     queue-&gt;cur_level.buffers--;
 846     queue-&gt;cur_level.bytes -= bufsize;
 847     apply_buffer (queue, buffer, &amp;queue-&gt;src_segment, FALSE);
 848 
 849     /* if the queue is empty now, update the other side */
 850     if (queue-&gt;cur_level.buffers == 0)
 851       queue-&gt;cur_level.time = 0;
 852   } else if (GST_IS_BUFFER_LIST (item)) {
 853     GstBufferList *buffer_list = GST_BUFFER_LIST_CAST (item);
 854 
 855     GST_CAT_LOG_OBJECT (queue_dataflow, queue,
 856         &quot;retrieved buffer list %p from queue&quot;, buffer_list);
 857 
 858     queue-&gt;cur_level.buffers -= gst_buffer_list_length (buffer_list);
 859     queue-&gt;cur_level.bytes -= bufsize;
 860     apply_buffer_list (queue, buffer_list, &amp;queue-&gt;src_segment, FALSE);
 861 
 862     /* if the queue is empty now, update the other side */
 863     if (queue-&gt;cur_level.buffers == 0)
 864       queue-&gt;cur_level.time = 0;
 865   } else if (GST_IS_EVENT (item)) {
 866     GstEvent *event = GST_EVENT_CAST (item);
 867 
 868     GST_CAT_LOG_OBJECT (queue_dataflow, queue,
 869         &quot;retrieved event %p from queue&quot;, event);
 870 
 871     switch (GST_EVENT_TYPE (event)) {
 872       case GST_EVENT_EOS:
 873         /* queue is empty now that we dequeued the EOS */
 874         GST_QUEUE_CLEAR_LEVEL (queue-&gt;cur_level);
 875         break;
 876       case GST_EVENT_SEGMENT:
 877         /* apply newsegment if it has not already been applied */
 878         if (G_LIKELY (!queue-&gt;newseg_applied_to_src)) {
 879           apply_segment (queue, event, &amp;queue-&gt;src_segment, FALSE);
 880         } else {
 881           queue-&gt;newseg_applied_to_src = FALSE;
 882         }
 883         break;
 884       case GST_EVENT_GAP:
 885         apply_gap (queue, event, &amp;queue-&gt;src_segment, FALSE);
 886         break;
 887       default:
 888         break;
 889     }
 890   } else if (GST_IS_QUERY (item)) {
 891     GstQuery *query = GST_QUERY_CAST (item);
 892 
 893     GST_CAT_LOG_OBJECT (queue_dataflow, queue,
 894         &quot;retrieved query %p from queue&quot;, query);
 895   } else {
 896     g_warning
 897         (&quot;Unexpected item %p dequeued from queue %s (refcounting problem?)&quot;,
 898         item, GST_OBJECT_NAME (queue));
 899     item = NULL;
 900   }
 901   GST_QUEUE_SIGNAL_DEL (queue);
 902 
 903   return item;
 904 
 905   /* ERRORS */
 906 no_item:
 907   {
 908     GST_CAT_DEBUG_OBJECT (queue_dataflow, queue, &quot;the queue is empty&quot;);
 909     return NULL;
 910   }
 911 }
 912 
 913 static GstFlowReturn
 914 gst_queue_handle_sink_event (GstPad * pad, GstObject * parent, GstEvent * event)
 915 {
 916   gboolean ret = TRUE;
 917   GstQueue *queue;
 918 
 919   queue = GST_QUEUE (parent);
 920 
 921   GST_CAT_LOG_OBJECT (queue_dataflow, queue, &quot;Received event &#39;%s&#39;&quot;,
 922       GST_EVENT_TYPE_NAME (event));
 923 
 924   switch (GST_EVENT_TYPE (event)) {
 925     case GST_EVENT_FLUSH_START:
 926       /* forward event */
 927       ret = gst_pad_push_event (queue-&gt;srcpad, event);
 928 
 929       /* now unblock the chain function */
 930       GST_QUEUE_MUTEX_LOCK (queue);
 931       queue-&gt;srcresult = GST_FLOW_FLUSHING;
 932       /* unblock the loop and chain functions */
 933       GST_QUEUE_SIGNAL_ADD (queue);
 934       GST_QUEUE_SIGNAL_DEL (queue);
 935       GST_QUEUE_MUTEX_UNLOCK (queue);
 936 
 937       /* make sure it pauses, this should happen since we sent
 938        * flush_start downstream. */
 939 #ifdef GSTREAMER_LITE
 940       // Pause task on pad only if it is linked
 941       if (gst_pad_is_linked (queue-&gt;srcpad)) {
<a name="1" id="anc1"></a><span class="line-modified"> 942         gst_pad_pause_task (queue-&gt;srcpad);</span>
 943       }
 944 #else // GSTREAMER_LITE
 945       gst_pad_pause_task (queue-&gt;srcpad);
 946 #endif // GSTREAMER_LITE
 947       GST_CAT_LOG_OBJECT (queue_dataflow, queue, &quot;loop stopped&quot;);
 948 
 949       /* unblock query handler after the streaming thread is shut down.
 950        * Otherwise downstream might have a query that is already unreffed
 951        * upstream */
 952       GST_QUEUE_MUTEX_LOCK (queue);
 953       queue-&gt;last_query = FALSE;
 954       g_cond_signal (&amp;queue-&gt;query_handled);
 955       GST_QUEUE_MUTEX_UNLOCK (queue);
 956       break;
 957     case GST_EVENT_FLUSH_STOP:
 958       /* forward event */
 959       ret = gst_pad_push_event (queue-&gt;srcpad, event);
 960 
 961       GST_QUEUE_MUTEX_LOCK (queue);
 962       gst_queue_locked_flush (queue, FALSE);
 963       queue-&gt;srcresult = GST_FLOW_OK;
 964       queue-&gt;eos = FALSE;
 965       queue-&gt;unexpected = FALSE;
 966       if (gst_pad_is_active (queue-&gt;srcpad)) {
 967         gst_pad_start_task (queue-&gt;srcpad, (GstTaskFunction) gst_queue_loop,
 968             queue-&gt;srcpad, NULL);
 969       } else {
 970         GST_INFO_OBJECT (queue-&gt;srcpad, &quot;not re-starting task on srcpad, &quot;
 971             &quot;pad not active any longer&quot;);
 972       }
 973       GST_QUEUE_MUTEX_UNLOCK (queue);
 974 
 975       STATUS (queue, pad, &quot;after flush&quot;);
 976       break;
 977     default:
 978       if (GST_EVENT_IS_SERIALIZED (event)) {
 979         /* serialized events go in the queue */
 980         GST_QUEUE_MUTEX_LOCK (queue);
 981 
 982         /* STREAM_START and SEGMENT reset the EOS status of a
 983          * pad. Change the cached sinkpad flow result accordingly */
 984         if (queue-&gt;srcresult == GST_FLOW_EOS
 985             &amp;&amp; (GST_EVENT_TYPE (event) == GST_EVENT_STREAM_START
 986                 || GST_EVENT_TYPE (event) == GST_EVENT_SEGMENT))
 987           queue-&gt;srcresult = GST_FLOW_OK;
 988 
 989         if (queue-&gt;srcresult != GST_FLOW_OK) {
 990           /* Errors in sticky event pushing are no problem and ignored here
 991            * as they will cause more meaningful errors during data flow.
 992            * For EOS events, that are not followed by data flow, we still
 993            * return FALSE here though and report an error.
 994            */
 995           if (!GST_EVENT_IS_STICKY (event)) {
 996             GST_QUEUE_MUTEX_UNLOCK (queue);
 997             goto out_flow_error;
 998           } else if (GST_EVENT_TYPE (event) == GST_EVENT_EOS) {
 999             if (queue-&gt;srcresult == GST_FLOW_NOT_LINKED
1000                 || queue-&gt;srcresult &lt; GST_FLOW_EOS) {
1001               GST_QUEUE_MUTEX_UNLOCK (queue);
1002               GST_ELEMENT_FLOW_ERROR (queue, queue-&gt;srcresult);
1003             } else {
1004               GST_QUEUE_MUTEX_UNLOCK (queue);
1005             }
1006             goto out_flow_error;
1007           }
1008         }
1009 
1010         /* refuse more events on EOS unless they unset the EOS status */
1011         if (queue-&gt;eos) {
1012           switch (GST_EVENT_TYPE (event)) {
1013             case GST_EVENT_STREAM_START:
1014             case GST_EVENT_SEGMENT:
1015               /* Restart the loop */
1016               if (GST_PAD_MODE (queue-&gt;srcpad) == GST_PAD_MODE_PUSH) {
1017                 queue-&gt;srcresult = GST_FLOW_OK;
1018                 queue-&gt;eos = FALSE;
1019                 queue-&gt;unexpected = FALSE;
1020                 gst_pad_start_task (queue-&gt;srcpad,
1021                     (GstTaskFunction) gst_queue_loop, queue-&gt;srcpad, NULL);
1022               } else {
1023                 queue-&gt;eos = FALSE;
1024                 queue-&gt;unexpected = FALSE;
1025               }
1026 
1027               break;
1028             default:
<a name="2" id="anc2"></a><span class="line-modified">1029               goto out_eos;</span>
1030           }
1031         }
1032 
1033         gst_queue_locked_enqueue_event (queue, event);
1034         GST_QUEUE_MUTEX_UNLOCK (queue);
1035       } else {
1036         /* non-serialized events are forwarded downstream immediately */
1037         ret = gst_pad_push_event (queue-&gt;srcpad, event);
1038       }
1039       break;
1040   }
1041   if (ret == FALSE) {
1042     GST_ERROR_OBJECT (queue, &quot;Failed to push event&quot;);
1043     return GST_FLOW_ERROR;
1044   }
1045   return GST_FLOW_OK;
1046 
1047   /* ERRORS */
1048 out_eos:
1049   {
1050     GST_CAT_LOG_OBJECT (queue_dataflow, queue, &quot;refusing event, we are EOS&quot;);
1051     GST_QUEUE_MUTEX_UNLOCK (queue);
1052     gst_event_unref (event);
1053     return GST_FLOW_EOS;
1054   }
1055 out_flow_error:
1056   {
1057     GST_CAT_LOG_OBJECT (queue_dataflow, queue,
1058         &quot;refusing event, we have a downstream flow error: %s&quot;,
1059         gst_flow_get_name (queue-&gt;srcresult));
1060     gst_event_unref (event);
1061     return queue-&gt;srcresult;
1062   }
1063 }
1064 
1065 static gboolean
1066 gst_queue_handle_sink_query (GstPad * pad, GstObject * parent, GstQuery * query)
1067 {
1068   GstQueue *queue = GST_QUEUE_CAST (parent);
1069   gboolean res;
1070 
1071   switch (GST_QUERY_TYPE (query)) {
1072     default:
1073       if (G_UNLIKELY (GST_QUERY_IS_SERIALIZED (query))) {
1074         GstQueueItem qitem;
1075 
1076         GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1077         GST_LOG_OBJECT (queue, &quot;queuing query %p (%s)&quot;, query,
1078             GST_QUERY_TYPE_NAME (query));
1079         qitem.item = GST_MINI_OBJECT_CAST (query);
1080         qitem.is_query = TRUE;
1081         qitem.size = 0;
1082         gst_queue_array_push_tail_struct (queue-&gt;queue, &amp;qitem);
1083         GST_QUEUE_SIGNAL_ADD (queue);
1084         while (queue-&gt;srcresult == GST_FLOW_OK &amp;&amp;
1085             queue-&gt;last_handled_query != query)
<a name="3" id="anc3"></a><span class="line-modified">1086           g_cond_wait (&amp;queue-&gt;query_handled, &amp;queue-&gt;qlock);</span>
1087         queue-&gt;last_handled_query = NULL;
1088         if (queue-&gt;srcresult != GST_FLOW_OK)
1089           goto out_flushing;
1090         res = queue-&gt;last_query;
1091         GST_QUEUE_MUTEX_UNLOCK (queue);
1092       } else {
1093         res = gst_pad_query_default (pad, parent, query);
1094       }
1095       break;
1096   }
1097   return res;
1098 
1099   /* ERRORS */
1100 out_flushing:
1101   {
1102     GST_DEBUG_OBJECT (queue, &quot;we are flushing&quot;);
1103     GST_QUEUE_MUTEX_UNLOCK (queue);
1104     return FALSE;
1105   }
1106 }
1107 
1108 static gboolean
1109 gst_queue_is_empty (GstQueue * queue)
1110 {
1111   GstQueueItem *tail;
1112 
1113   tail = gst_queue_array_peek_tail_struct (queue-&gt;queue);
1114 
1115   if (tail == NULL)
1116     return TRUE;
1117 
1118   /* Only consider the queue empty if the minimum thresholds
1119    * are not reached and data is at the queue tail. Otherwise
1120    * we would block forever on serialized queries.
1121    */
1122   if (!GST_IS_BUFFER (tail-&gt;item) &amp;&amp; !GST_IS_BUFFER_LIST (tail-&gt;item))
1123     return FALSE;
1124 
1125   /* It is possible that a max size is reached before all min thresholds are.
1126    * Therefore, only consider it empty if it is not filled. */
1127   return ((queue-&gt;min_threshold.buffers &gt; 0 &amp;&amp;
1128           queue-&gt;cur_level.buffers &lt; queue-&gt;min_threshold.buffers) ||
1129       (queue-&gt;min_threshold.bytes &gt; 0 &amp;&amp;
1130           queue-&gt;cur_level.bytes &lt; queue-&gt;min_threshold.bytes) ||
1131       (queue-&gt;min_threshold.time &gt; 0 &amp;&amp;
1132           queue-&gt;cur_level.time &lt; queue-&gt;min_threshold.time)) &amp;&amp;
1133       !gst_queue_is_filled (queue);
1134 }
1135 
1136 static gboolean
1137 gst_queue_is_filled (GstQueue * queue)
1138 {
1139   return (((queue-&gt;max_size.buffers &gt; 0 &amp;&amp;
1140               queue-&gt;cur_level.buffers &gt;= queue-&gt;max_size.buffers) ||
1141           (queue-&gt;max_size.bytes &gt; 0 &amp;&amp;
1142               queue-&gt;cur_level.bytes &gt;= queue-&gt;max_size.bytes) ||
1143           (queue-&gt;max_size.time &gt; 0 &amp;&amp;
1144               queue-&gt;cur_level.time &gt;= queue-&gt;max_size.time)));
1145 }
1146 
1147 static void
1148 gst_queue_leak_downstream (GstQueue * queue)
1149 {
1150   /* for as long as the queue is filled, dequeue an item and discard it */
1151   while (gst_queue_is_filled (queue)) {
1152     GstMiniObject *leak;
1153 
1154     leak = gst_queue_locked_dequeue (queue);
1155     /* there is nothing to dequeue and the queue is still filled.. This should
1156      * not happen */
1157     g_assert (leak != NULL);
1158 
1159     GST_CAT_DEBUG_OBJECT (queue_dataflow, queue,
1160         &quot;queue is full, leaking item %p on downstream end&quot;, leak);
1161     if (GST_IS_EVENT (leak) &amp;&amp; GST_EVENT_IS_STICKY (leak)) {
1162       GST_CAT_DEBUG_OBJECT (queue_dataflow, queue,
1163           &quot;Storing sticky event %s on srcpad&quot;, GST_EVENT_TYPE_NAME (leak));
1164       gst_pad_store_sticky_event (queue-&gt;srcpad, GST_EVENT_CAST (leak));
1165     }
1166 
1167     if (!GST_IS_QUERY (leak))
1168       gst_mini_object_unref (leak);
1169 
1170     /* last buffer needs to get a DISCONT flag */
1171     queue-&gt;head_needs_discont = TRUE;
1172   }
1173 }
1174 
1175 static gboolean
1176 discont_first_buffer (GstBuffer ** buffer, guint i, gpointer user_data)
1177 {
1178   GstQueue *queue = user_data;
1179   GstBuffer *subbuffer = gst_buffer_make_writable (*buffer);
1180 
1181   if (subbuffer) {
1182     *buffer = subbuffer;
1183     GST_BUFFER_FLAG_SET (*buffer, GST_BUFFER_FLAG_DISCONT);
1184   } else {
1185     GST_DEBUG_OBJECT (queue, &quot;Could not mark buffer as DISCONT&quot;);
1186   }
1187 
1188   return FALSE;
1189 }
1190 
1191 static GstFlowReturn
1192 gst_queue_chain_buffer_or_list (GstPad * pad, GstObject * parent,
1193     GstMiniObject * obj, gboolean is_list)
1194 {
1195   GstQueue *queue;
1196 
1197   queue = GST_QUEUE_CAST (parent);
1198 
1199   /* we have to lock the queue since we span threads */
1200   GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1201   /* when we received EOS, we refuse any more data */
1202   if (queue-&gt;eos)
1203     goto out_eos;
1204   if (queue-&gt;unexpected)
1205     goto out_unexpected;
1206 
1207   if (!is_list) {
1208     GstClockTime duration, timestamp;
1209     GstBuffer *buffer = GST_BUFFER_CAST (obj);
1210 
1211     timestamp = GST_BUFFER_DTS_OR_PTS (buffer);
<a name="4" id="anc4"></a><span class="line-modified">1212     duration = GST_BUFFER_DURATION (buffer);</span>
1213 
<a name="5" id="anc5"></a><span class="line-modified">1214     GST_CAT_LOG_OBJECT (queue_dataflow, queue, &quot;received buffer %p of size %&quot;</span>
<span class="line-modified">1215         G_GSIZE_FORMAT &quot;, time %&quot; GST_TIME_FORMAT &quot;, duration %&quot;</span>
<span class="line-modified">1216         GST_TIME_FORMAT, buffer, gst_buffer_get_size (buffer),</span>
<span class="line-modified">1217         GST_TIME_ARGS (timestamp), GST_TIME_ARGS (duration));</span>
1218   } else {
1219     GST_CAT_LOG_OBJECT (queue_dataflow, queue,
1220         &quot;received buffer list %p with %u buffers&quot;, obj,
1221         gst_buffer_list_length (GST_BUFFER_LIST_CAST (obj)));
1222   }
1223 
1224   /* We make space available if we&#39;re &quot;full&quot; according to whatever
1225    * the user defined as &quot;full&quot;. Note that this only applies to buffers.
1226    * We always handle events and they don&#39;t count in our statistics. */
1227   while (gst_queue_is_filled (queue)) {
1228     if (!queue-&gt;silent) {
1229       GST_QUEUE_MUTEX_UNLOCK (queue);
1230       g_signal_emit (queue, gst_queue_signals[SIGNAL_OVERRUN], 0);
1231       GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1232       /* we recheck, the signal could have changed the thresholds */
1233       if (!gst_queue_is_filled (queue))
1234         break;
1235     }
1236 
1237     /* how are we going to make space for this buffer? */
1238     switch (queue-&gt;leaky) {
1239       case GST_QUEUE_LEAK_UPSTREAM:
1240         /* next buffer needs to get a DISCONT flag */
1241         queue-&gt;tail_needs_discont = TRUE;
1242         /* leak current buffer */
1243         GST_CAT_DEBUG_OBJECT (queue_dataflow, queue,
1244             &quot;queue is full, leaking buffer on upstream end&quot;);
1245         /* now we can clean up and exit right away */
1246         goto out_unref;
1247       case GST_QUEUE_LEAK_DOWNSTREAM:
1248         gst_queue_leak_downstream (queue);
1249         break;
1250       default:
1251         g_warning (&quot;Unknown leaky type, using default&quot;);
1252         /* fall-through */
1253       case GST_QUEUE_NO_LEAK:
1254       {
1255         GST_CAT_DEBUG_OBJECT (queue_dataflow, queue,
1256             &quot;queue is full, waiting for free space&quot;);
1257 
1258         /* don&#39;t leak. Instead, wait for space to be available */
1259         do {
1260           /* for as long as the queue is filled, wait till an item was deleted. */
1261           GST_QUEUE_WAIT_DEL_CHECK (queue, out_flushing);
1262         } while (gst_queue_is_filled (queue));
1263 
1264         GST_CAT_DEBUG_OBJECT (queue_dataflow, queue, &quot;queue is not full&quot;);
1265 
1266         if (!queue-&gt;silent) {
1267           GST_QUEUE_MUTEX_UNLOCK (queue);
1268           g_signal_emit (queue, gst_queue_signals[SIGNAL_RUNNING], 0);
1269           GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1270         }
1271         break;
1272       }
1273     }
1274   }
1275 
1276   if (queue-&gt;tail_needs_discont) {
1277     if (!is_list) {
1278       GstBuffer *buffer = GST_BUFFER_CAST (obj);
<a name="6" id="anc6"></a><span class="line-modified">1279       GstBuffer *subbuffer = gst_buffer_make_writable (buffer);</span>
1280 
<a name="7" id="anc7"></a><span class="line-modified">1281       if (subbuffer) {</span>
<span class="line-modified">1282         buffer = subbuffer;</span>
<span class="line-modified">1283         GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);</span>
<span class="line-modified">1284       } else {</span>
<span class="line-modified">1285         GST_DEBUG_OBJECT (queue, &quot;Could not mark buffer as DISCONT&quot;);</span>
<span class="line-modified">1286       }</span>
1287 
1288       obj = GST_MINI_OBJECT_CAST (buffer);
1289     } else {
1290       GstBufferList *buffer_list = GST_BUFFER_LIST_CAST (obj);
1291 
1292       buffer_list = gst_buffer_list_make_writable (buffer_list);
1293       gst_buffer_list_foreach (buffer_list, discont_first_buffer, queue);
1294       obj = GST_MINI_OBJECT_CAST (buffer_list);
1295     }
1296     queue-&gt;tail_needs_discont = FALSE;
1297   }
1298 
1299   /* put buffer in queue now */
1300   if (is_list)
1301     gst_queue_locked_enqueue_buffer_list (queue, obj);
1302   else
1303     gst_queue_locked_enqueue_buffer (queue, obj);
1304   GST_QUEUE_MUTEX_UNLOCK (queue);
1305 
1306   return GST_FLOW_OK;
1307 
1308   /* special conditions */
1309 out_unref:
1310   {
1311     GST_QUEUE_MUTEX_UNLOCK (queue);
1312 
1313     gst_mini_object_unref (obj);
1314 
1315     return GST_FLOW_OK;
1316   }
1317 out_flushing:
1318   {
1319     GstFlowReturn ret = queue-&gt;srcresult;
1320 
1321     GST_CAT_LOG_OBJECT (queue_dataflow, queue,
1322         &quot;exit because task paused, reason: %s&quot;, gst_flow_get_name (ret));
1323     GST_QUEUE_MUTEX_UNLOCK (queue);
1324     gst_mini_object_unref (obj);
1325 
1326     return ret;
1327   }
1328 out_eos:
1329   {
1330     GST_CAT_LOG_OBJECT (queue_dataflow, queue, &quot;exit because we received EOS&quot;);
1331     GST_QUEUE_MUTEX_UNLOCK (queue);
1332 
1333     gst_mini_object_unref (obj);
1334 
1335     return GST_FLOW_EOS;
1336   }
1337 out_unexpected:
1338   {
1339     GST_CAT_LOG_OBJECT (queue_dataflow, queue, &quot;exit because we received EOS&quot;);
1340     GST_QUEUE_MUTEX_UNLOCK (queue);
1341 
1342     gst_mini_object_unref (obj);
1343 
1344     return GST_FLOW_EOS;
1345   }
1346 }
1347 
1348 static GstFlowReturn
1349 gst_queue_chain_list (GstPad * pad, GstObject * parent,
1350     GstBufferList * buffer_list)
1351 {
1352   return gst_queue_chain_buffer_or_list (pad, parent,
1353       GST_MINI_OBJECT_CAST (buffer_list), TRUE);
1354 }
1355 
1356 static GstFlowReturn
1357 gst_queue_chain (GstPad * pad, GstObject * parent, GstBuffer * buffer)
1358 {
1359   return gst_queue_chain_buffer_or_list (pad, parent,
1360       GST_MINI_OBJECT_CAST (buffer), FALSE);
1361 }
1362 
1363 /* dequeue an item from the queue an push it downstream. This functions returns
1364  * the result of the push. */
1365 static GstFlowReturn
1366 gst_queue_push_one (GstQueue * queue)
1367 {
1368   GstFlowReturn result = queue-&gt;srcresult;
1369   GstMiniObject *data;
1370   gboolean is_list;
1371 
1372   data = gst_queue_locked_dequeue (queue);
1373   if (data == NULL)
1374     goto no_item;
1375 
1376 next:
1377   is_list = GST_IS_BUFFER_LIST (data);
1378 
1379   if (GST_IS_BUFFER (data) || is_list) {
1380     if (!is_list) {
<a name="8" id="anc8"></a><span class="line-modified">1381       GstBuffer *buffer;</span>
1382 
<a name="9" id="anc9"></a><span class="line-modified">1383       buffer = GST_BUFFER_CAST (data);</span>
1384 
<a name="10" id="anc10"></a><span class="line-modified">1385       if (queue-&gt;head_needs_discont) {</span>
<span class="line-modified">1386         GstBuffer *subbuffer = gst_buffer_make_writable (buffer);</span>
1387 
<a name="11" id="anc11"></a><span class="line-modified">1388         if (subbuffer) {</span>
<span class="line-modified">1389           buffer = subbuffer;</span>
<span class="line-modified">1390           GST_BUFFER_FLAG_SET (buffer, GST_BUFFER_FLAG_DISCONT);</span>
<span class="line-modified">1391         } else {</span>
<span class="line-modified">1392           GST_DEBUG_OBJECT (queue, &quot;Could not mark buffer as DISCONT&quot;);</span>
<span class="line-added">1393         }</span>
<span class="line-added">1394         queue-&gt;head_needs_discont = FALSE;</span>
1395       }
<a name="12" id="anc12"></a>

1396 
<a name="13" id="anc13"></a><span class="line-modified">1397       GST_QUEUE_MUTEX_UNLOCK (queue);</span>
<span class="line-modified">1398       result = gst_pad_push (queue-&gt;srcpad, buffer);</span>
1399     } else {
1400       GstBufferList *buffer_list;
1401 
1402       buffer_list = GST_BUFFER_LIST_CAST (data);
1403 
1404       if (queue-&gt;head_needs_discont) {
1405         buffer_list = gst_buffer_list_make_writable (buffer_list);
1406         gst_buffer_list_foreach (buffer_list, discont_first_buffer, queue);
1407         queue-&gt;head_needs_discont = FALSE;
1408       }
1409 
1410       GST_QUEUE_MUTEX_UNLOCK (queue);
1411       result = gst_pad_push_list (queue-&gt;srcpad, buffer_list);
1412     }
1413 
1414     /* need to check for srcresult here as well */
1415     GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1416 
1417     if (result == GST_FLOW_EOS) {
1418       GST_CAT_LOG_OBJECT (queue_dataflow, queue, &quot;got EOS from downstream&quot;);
1419       /* stop pushing buffers, we dequeue all items until we see an item that we
1420        * can push again, which is EOS or SEGMENT. If there is nothing in the
1421        * queue we can push, we set a flag to make the sinkpad refuse more
1422        * buffers with an EOS return value. */
1423       while ((data = gst_queue_locked_dequeue (queue))) {
1424         if (GST_IS_BUFFER (data)) {
1425           GST_CAT_LOG_OBJECT (queue_dataflow, queue,
1426               &quot;dropping EOS buffer %p&quot;, data);
1427           gst_buffer_unref (GST_BUFFER_CAST (data));
1428         } else if (GST_IS_BUFFER_LIST (data)) {
1429           GST_CAT_LOG_OBJECT (queue_dataflow, queue,
1430               &quot;dropping EOS buffer list %p&quot;, data);
1431           gst_buffer_list_unref (GST_BUFFER_LIST_CAST (data));
1432         } else if (GST_IS_EVENT (data)) {
1433           GstEvent *event = GST_EVENT_CAST (data);
1434           GstEventType type = GST_EVENT_TYPE (event);
1435 
1436           if (type == GST_EVENT_EOS || type == GST_EVENT_SEGMENT
1437               || type == GST_EVENT_STREAM_START) {
1438             /* we found a pushable item in the queue, push it out */
1439             GST_CAT_LOG_OBJECT (queue_dataflow, queue,
1440                 &quot;pushing pushable event %s after EOS&quot;,
1441                 GST_EVENT_TYPE_NAME (event));
1442             goto next;
1443           }
1444           GST_CAT_LOG_OBJECT (queue_dataflow, queue,
1445               &quot;dropping EOS event %p&quot;, event);
1446           gst_event_unref (event);
1447         } else if (GST_IS_QUERY (data)) {
1448           GstQuery *query = GST_QUERY_CAST (data);
1449 
1450           GST_CAT_LOG_OBJECT (queue_dataflow, queue,
1451               &quot;dropping query %p because of EOS&quot;, query);
1452           queue-&gt;last_query = FALSE;
1453           g_cond_signal (&amp;queue-&gt;query_handled);
1454         }
1455       }
1456       /* no more items in the queue. Set the unexpected flag so that upstream
1457        * make us refuse any more buffers on the sinkpad. Since we will still
1458        * accept EOS and SEGMENT we return _FLOW_OK to the caller so that the
1459        * task function does not shut down. */
1460       queue-&gt;unexpected = TRUE;
1461       result = GST_FLOW_OK;
1462     }
1463   } else if (GST_IS_EVENT (data)) {
1464     GstEvent *event = GST_EVENT_CAST (data);
1465     GstEventType type = GST_EVENT_TYPE (event);
1466 
1467     GST_QUEUE_MUTEX_UNLOCK (queue);
1468 
1469     gst_pad_push_event (queue-&gt;srcpad, event);
1470 
1471     GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1472     /* if we&#39;re EOS, return EOS so that the task pauses. */
1473     if (type == GST_EVENT_EOS) {
1474       GST_CAT_LOG_OBJECT (queue_dataflow, queue,
1475           &quot;pushed EOS event %p, return EOS&quot;, event);
1476       result = GST_FLOW_EOS;
1477     }
1478   } else if (GST_IS_QUERY (data)) {
1479     GstQuery *query = GST_QUERY_CAST (data);
1480     gboolean ret;
1481 
1482     GST_QUEUE_MUTEX_UNLOCK (queue);
1483     ret = gst_pad_peer_query (queue-&gt;srcpad, query);
1484     GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing_query);
1485     queue-&gt;last_query = ret;
1486     queue-&gt;last_handled_query = query;
1487     g_cond_signal (&amp;queue-&gt;query_handled);
1488     GST_CAT_LOG_OBJECT (queue_dataflow, queue,
1489         &quot;did query %p, return %d&quot;, query, queue-&gt;last_query);
1490   }
1491   return result;
1492 
1493   /* ERRORS */
1494 no_item:
1495   {
1496     GST_CAT_ERROR_OBJECT (queue_dataflow, queue,
1497         &quot;exit because we have no item in the queue&quot;);
1498     return GST_FLOW_ERROR;
1499   }
1500 out_flushing:
1501   {
1502     GstFlowReturn ret = queue-&gt;srcresult;
1503     GST_CAT_LOG_OBJECT (queue_dataflow, queue,
1504         &quot;exit because task paused, reason: %s&quot;, gst_flow_get_name (ret));
1505     return ret;
1506   }
1507 out_flushing_query:
1508   {
1509     GstFlowReturn ret = queue-&gt;srcresult;
1510     queue-&gt;last_query = FALSE;
1511     g_cond_signal (&amp;queue-&gt;query_handled);
1512     GST_CAT_LOG_OBJECT (queue_dataflow, queue,
1513         &quot;exit because task paused, reason: %s&quot;, gst_flow_get_name (ret));
1514     return ret;
1515   }
1516 }
1517 
1518 static void
1519 gst_queue_loop (GstPad * pad)
1520 {
1521   GstQueue *queue;
1522   GstFlowReturn ret;
1523 
1524   queue = (GstQueue *) GST_PAD_PARENT (pad);
1525 #ifdef GSTREAMER_LITE
1526   if (queue == NULL) {
1527     return;
1528   }
1529 #endif // GSTREAMER_LITE
1530 
1531   /* have to lock for thread-safety */
1532   GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1533 
1534   while (gst_queue_is_empty (queue)) {
1535     GST_CAT_DEBUG_OBJECT (queue_dataflow, queue, &quot;queue is empty&quot;);
1536     if (!queue-&gt;silent) {
1537       GST_QUEUE_MUTEX_UNLOCK (queue);
1538       g_signal_emit (queue, gst_queue_signals[SIGNAL_UNDERRUN], 0);
1539       GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1540     }
1541 
1542     /* we recheck, the signal could have changed the thresholds */
1543     while (gst_queue_is_empty (queue)) {
1544       GST_QUEUE_WAIT_ADD_CHECK (queue, out_flushing);
1545     }
1546 
1547     GST_CAT_DEBUG_OBJECT (queue_dataflow, queue, &quot;queue is not empty&quot;);
1548     if (!queue-&gt;silent) {
1549       GST_QUEUE_MUTEX_UNLOCK (queue);
1550       g_signal_emit (queue, gst_queue_signals[SIGNAL_RUNNING], 0);
1551       g_signal_emit (queue, gst_queue_signals[SIGNAL_PUSHING], 0);
1552       GST_QUEUE_MUTEX_LOCK_CHECK (queue, out_flushing);
1553     }
1554   }
1555 
1556   ret = gst_queue_push_one (queue);
1557   queue-&gt;srcresult = ret;
1558   if (ret != GST_FLOW_OK)
1559     goto out_flushing;
1560 
1561   GST_QUEUE_MUTEX_UNLOCK (queue);
1562 
1563   return;
1564 
1565   /* ERRORS */
1566 out_flushing:
1567   {
1568     gboolean eos = queue-&gt;eos;
1569     GstFlowReturn ret = queue-&gt;srcresult;
1570 
1571 #ifdef GSTREAMER_LITE
<a name="14" id="anc14"></a><span class="line-modified">1572     // Pause task on pad only if it is linked</span>
<span class="line-modified">1573     if (gst_pad_is_linked (queue-&gt;srcpad)) {</span>



1574       gst_pad_pause_task (queue-&gt;srcpad);
<a name="15" id="anc15"></a><span class="line-added">1575     }</span>
<span class="line-added">1576 #else // GSTREAMER_LITE</span>
<span class="line-added">1577     gst_pad_pause_task (queue-&gt;srcpad);</span>
1578 #endif // GSTREAMER_LITE
1579 
1580     GST_CAT_LOG_OBJECT (queue_dataflow, queue,
1581         &quot;pause task, reason:  %s&quot;, gst_flow_get_name (ret));
1582     if (ret == GST_FLOW_FLUSHING) {
1583       gst_queue_locked_flush (queue, FALSE);
1584     } else {
1585       GST_QUEUE_SIGNAL_DEL (queue);
1586       queue-&gt;last_query = FALSE;
1587       g_cond_signal (&amp;queue-&gt;query_handled);
1588     }
1589     GST_QUEUE_MUTEX_UNLOCK (queue);
1590     /* let app know about us giving up if upstream is not expected to do so */
1591     /* EOS is already taken care of elsewhere */
1592     if (eos &amp;&amp; (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS)) {
1593       GST_ELEMENT_FLOW_ERROR (queue, ret);
1594       gst_pad_push_event (queue-&gt;srcpad, gst_event_new_eos ());
1595     }
1596     return;
1597   }
1598 }
1599 
1600 static gboolean
1601 gst_queue_handle_src_event (GstPad * pad, GstObject * parent, GstEvent * event)
1602 {
1603   gboolean res = TRUE;
1604   GstQueue *queue = GST_QUEUE (parent);
1605 
1606 #ifndef GST_DISABLE_GST_DEBUG
1607   GST_CAT_DEBUG_OBJECT (queue_dataflow, queue, &quot;got event %p (%d)&quot;,
1608       event, GST_EVENT_TYPE (event));
1609 #endif
1610 
1611   switch (GST_EVENT_TYPE (event)) {
1612     case GST_EVENT_RECONFIGURE:
1613       GST_QUEUE_MUTEX_LOCK (queue);
1614       if (queue-&gt;srcresult == GST_FLOW_NOT_LINKED) {
1615         /* when we got not linked, assume downstream is linked again now and we
1616          * can try to start pushing again */
1617         queue-&gt;srcresult = GST_FLOW_OK;
1618         gst_pad_start_task (pad, (GstTaskFunction) gst_queue_loop, pad, NULL);
1619       }
1620       GST_QUEUE_MUTEX_UNLOCK (queue);
1621 
1622       res = gst_pad_push_event (queue-&gt;sinkpad, event);
1623       break;
1624     default:
1625       res = gst_pad_event_default (pad, parent, event);
1626       break;
1627   }
1628 
1629 
1630   return res;
1631 }
1632 
1633 static gboolean
1634 gst_queue_handle_src_query (GstPad * pad, GstObject * parent, GstQuery * query)
1635 {
1636   GstQueue *queue = GST_QUEUE (parent);
1637   gboolean res;
1638 
1639   switch (GST_QUERY_TYPE (query)) {
1640     case GST_QUERY_SCHEDULING:{
1641       gst_query_add_scheduling_mode (query, GST_PAD_MODE_PUSH);
1642       res = TRUE;
1643       break;
1644     }
1645     default:
1646       res = gst_pad_query_default (pad, parent, query);
1647       break;
1648   }
1649 
1650   if (!res)
1651     return FALSE;
1652 
1653   /* Adjust peer response for data contained in queue */
1654   switch (GST_QUERY_TYPE (query)) {
1655     case GST_QUERY_POSITION:
1656     {
1657       gint64 peer_pos;
1658       GstFormat format;
1659 
1660       /* get peer position */
1661       gst_query_parse_position (query, &amp;format, &amp;peer_pos);
1662 
1663       /* FIXME: this code assumes that there&#39;s no discont in the queue */
1664       switch (format) {
1665         case GST_FORMAT_BYTES:
1666           peer_pos -= queue-&gt;cur_level.bytes;
1667           if (peer_pos &lt; 0)     /* Clamp result to 0 */
1668             peer_pos = 0;
1669           break;
1670         case GST_FORMAT_TIME:
1671           peer_pos -= queue-&gt;cur_level.time;
1672           if (peer_pos &lt; 0)     /* Clamp result to 0 */
1673             peer_pos = 0;
1674           break;
1675         default:
1676           GST_DEBUG_OBJECT (queue, &quot;Can&#39;t adjust query in %s format, don&#39;t &quot;
1677               &quot;know how to adjust value&quot;, gst_format_get_name (format));
1678           return TRUE;
1679       }
1680       /* set updated position */
1681       gst_query_set_position (query, format, peer_pos);
1682       break;
1683     }
1684     case GST_QUERY_LATENCY:
1685     {
1686       gboolean live;
1687       GstClockTime min, max;
1688 
1689       gst_query_parse_latency (query, &amp;live, &amp;min, &amp;max);
1690 
1691       /* we can delay up to the limit of the queue in time. If we have no time
1692        * limit, the best thing we can do is to return an infinite delay. In
1693        * reality a better estimate would be the byte/buffer rate but that is not
1694        * possible right now. */
1695       /* TODO: Use CONVERT query? */
1696       if (queue-&gt;max_size.time &gt; 0 &amp;&amp; max != -1
1697           &amp;&amp; queue-&gt;leaky == GST_QUEUE_NO_LEAK)
1698         max += queue-&gt;max_size.time;
1699       else if (queue-&gt;max_size.time &gt; 0 &amp;&amp; queue-&gt;leaky != GST_QUEUE_NO_LEAK)
1700         max = MIN (queue-&gt;max_size.time, max);
1701       else
1702         max = -1;
1703 
1704       /* adjust for min-threshold */
1705       if (queue-&gt;min_threshold.time &gt; 0)
1706         min += queue-&gt;min_threshold.time;
1707 
1708       gst_query_set_latency (query, live, min, max);
1709       break;
1710     }
1711     default:
1712       /* peer handled other queries */
1713       break;
1714   }
1715 
1716   return TRUE;
1717 }
1718 
1719 static gboolean
1720 gst_queue_sink_activate_mode (GstPad * pad, GstObject * parent, GstPadMode mode,
1721     gboolean active)
1722 {
1723   gboolean result;
1724   GstQueue *queue;
1725 
1726   queue = GST_QUEUE (parent);
1727 
1728   switch (mode) {
1729     case GST_PAD_MODE_PUSH:
1730       if (active) {
1731         GST_QUEUE_MUTEX_LOCK (queue);
1732         queue-&gt;srcresult = GST_FLOW_OK;
1733         queue-&gt;eos = FALSE;
1734         queue-&gt;unexpected = FALSE;
1735         GST_QUEUE_MUTEX_UNLOCK (queue);
1736       } else {
1737         /* step 1, unblock chain function */
1738         GST_QUEUE_MUTEX_LOCK (queue);
1739         queue-&gt;srcresult = GST_FLOW_FLUSHING;
1740         /* the item del signal will unblock */
1741         GST_QUEUE_SIGNAL_DEL (queue);
1742         GST_QUEUE_MUTEX_UNLOCK (queue);
1743 
1744         /* step 2, wait until streaming thread stopped and flush queue */
1745         GST_PAD_STREAM_LOCK (pad);
1746         GST_QUEUE_MUTEX_LOCK (queue);
1747         gst_queue_locked_flush (queue, TRUE);
1748         GST_QUEUE_MUTEX_UNLOCK (queue);
1749         GST_PAD_STREAM_UNLOCK (pad);
1750       }
1751       result = TRUE;
1752       break;
1753     default:
1754       result = FALSE;
1755       break;
1756   }
1757   return result;
1758 }
1759 
1760 static gboolean
1761 gst_queue_src_activate_mode (GstPad * pad, GstObject * parent, GstPadMode mode,
1762     gboolean active)
1763 {
1764   gboolean result;
1765   GstQueue *queue;
1766 
1767   queue = GST_QUEUE (parent);
1768 
1769   switch (mode) {
1770     case GST_PAD_MODE_PUSH:
1771       if (active) {
1772         GST_QUEUE_MUTEX_LOCK (queue);
1773         queue-&gt;srcresult = GST_FLOW_OK;
1774         queue-&gt;eos = FALSE;
1775         queue-&gt;unexpected = FALSE;
1776         result =
1777             gst_pad_start_task (pad, (GstTaskFunction) gst_queue_loop, pad,
1778             NULL);
1779         GST_QUEUE_MUTEX_UNLOCK (queue);
1780       } else {
1781         /* step 1, unblock loop function */
1782         GST_QUEUE_MUTEX_LOCK (queue);
1783         queue-&gt;srcresult = GST_FLOW_FLUSHING;
1784         /* the item add signal will unblock */
1785         g_cond_signal (&amp;queue-&gt;item_add);
1786         GST_QUEUE_MUTEX_UNLOCK (queue);
1787 
1788         /* step 2, make sure streaming finishes */
1789         result = gst_pad_stop_task (pad);
1790 
1791         GST_QUEUE_MUTEX_LOCK (queue);
1792         gst_queue_locked_flush (queue, FALSE);
1793         GST_QUEUE_MUTEX_UNLOCK (queue);
1794       }
1795       break;
1796     default:
1797       result = FALSE;
1798       break;
1799   }
1800   return result;
1801 }
1802 
1803 static void
1804 queue_capacity_change (GstQueue * queue)
1805 {
1806   if (queue-&gt;leaky == GST_QUEUE_LEAK_DOWNSTREAM) {
1807     gst_queue_leak_downstream (queue);
1808   }
1809 
1810   /* changing the capacity of the queue must wake up
1811    * the _chain function, it might have more room now
1812    * to store the buffer/event in the queue */
1813   GST_QUEUE_SIGNAL_DEL (queue);
1814 }
1815 
1816 /* Changing the minimum required fill level must
1817  * wake up the _loop function as it might now
1818  * be able to preceed.
1819  */
1820 #define QUEUE_THRESHOLD_CHANGE(q)\
1821   GST_QUEUE_SIGNAL_ADD (q);
1822 
1823 static void
1824 gst_queue_set_property (GObject * object,
1825     guint prop_id, const GValue * value, GParamSpec * pspec)
1826 {
1827   GstQueue *queue = GST_QUEUE (object);
1828 
1829   /* someone could change levels here, and since this
1830    * affects the get/put funcs, we need to lock for safety. */
1831   GST_QUEUE_MUTEX_LOCK (queue);
1832 
1833   switch (prop_id) {
1834     case PROP_MAX_SIZE_BYTES:
1835       queue-&gt;max_size.bytes = g_value_get_uint (value);
1836       queue_capacity_change (queue);
1837       break;
1838     case PROP_MAX_SIZE_BUFFERS:
1839       queue-&gt;max_size.buffers = g_value_get_uint (value);
1840       queue_capacity_change (queue);
1841       break;
1842     case PROP_MAX_SIZE_TIME:
1843       queue-&gt;max_size.time = g_value_get_uint64 (value);
1844       queue_capacity_change (queue);
1845       break;
1846     case PROP_MIN_THRESHOLD_BYTES:
1847       queue-&gt;min_threshold.bytes = g_value_get_uint (value);
1848       queue-&gt;orig_min_threshold.bytes = queue-&gt;min_threshold.bytes;
1849       QUEUE_THRESHOLD_CHANGE (queue);
1850       break;
1851     case PROP_MIN_THRESHOLD_BUFFERS:
1852       queue-&gt;min_threshold.buffers = g_value_get_uint (value);
1853       queue-&gt;orig_min_threshold.buffers = queue-&gt;min_threshold.buffers;
1854       QUEUE_THRESHOLD_CHANGE (queue);
1855       break;
1856     case PROP_MIN_THRESHOLD_TIME:
1857       queue-&gt;min_threshold.time = g_value_get_uint64 (value);
1858       queue-&gt;orig_min_threshold.time = queue-&gt;min_threshold.time;
1859       QUEUE_THRESHOLD_CHANGE (queue);
1860       break;
1861     case PROP_LEAKY:
1862       queue-&gt;leaky = g_value_get_enum (value);
1863       break;
1864     case PROP_SILENT:
1865       queue-&gt;silent = g_value_get_boolean (value);
1866       break;
1867     case PROP_FLUSH_ON_EOS:
1868       queue-&gt;flush_on_eos = g_value_get_boolean (value);
1869       break;
1870     default:
1871       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
1872       break;
1873   }
1874 
1875   GST_QUEUE_MUTEX_UNLOCK (queue);
1876 }
1877 
1878 static void
1879 gst_queue_get_property (GObject * object,
1880     guint prop_id, GValue * value, GParamSpec * pspec)
1881 {
1882   GstQueue *queue = GST_QUEUE (object);
1883 
1884   GST_QUEUE_MUTEX_LOCK (queue);
1885 
1886   switch (prop_id) {
1887     case PROP_CUR_LEVEL_BYTES:
1888       g_value_set_uint (value, queue-&gt;cur_level.bytes);
1889       break;
1890     case PROP_CUR_LEVEL_BUFFERS:
1891       g_value_set_uint (value, queue-&gt;cur_level.buffers);
1892       break;
1893     case PROP_CUR_LEVEL_TIME:
1894       g_value_set_uint64 (value, queue-&gt;cur_level.time);
1895       break;
1896     case PROP_MAX_SIZE_BYTES:
1897       g_value_set_uint (value, queue-&gt;max_size.bytes);
1898       break;
1899     case PROP_MAX_SIZE_BUFFERS:
1900       g_value_set_uint (value, queue-&gt;max_size.buffers);
1901       break;
1902     case PROP_MAX_SIZE_TIME:
1903       g_value_set_uint64 (value, queue-&gt;max_size.time);
1904       break;
1905     case PROP_MIN_THRESHOLD_BYTES:
1906       g_value_set_uint (value, queue-&gt;min_threshold.bytes);
1907       break;
1908     case PROP_MIN_THRESHOLD_BUFFERS:
1909       g_value_set_uint (value, queue-&gt;min_threshold.buffers);
1910       break;
1911     case PROP_MIN_THRESHOLD_TIME:
1912       g_value_set_uint64 (value, queue-&gt;min_threshold.time);
1913       break;
1914     case PROP_LEAKY:
1915       g_value_set_enum (value, queue-&gt;leaky);
1916       break;
1917     case PROP_SILENT:
1918       g_value_set_boolean (value, queue-&gt;silent);
1919       break;
1920     case PROP_FLUSH_ON_EOS:
1921       g_value_set_boolean (value, queue-&gt;flush_on_eos);
1922       break;
1923     default:
1924       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
1925       break;
1926   }
1927 
1928   GST_QUEUE_MUTEX_UNLOCK (queue);
1929 }
1930 
1931 #ifdef GSTREAMER_LITE
1932 static GstStateChangeReturn gst_queue_change_state (GstElement *element, GstStateChange transition)
1933 {
1934     GstQueue *queue = GST_QUEUE(element);
1935 
1936     switch (transition)
1937     {
1938         case GST_STATE_CHANGE_PAUSED_TO_READY:
1939             GST_QUEUE_MUTEX_LOCK (queue);
1940             queue-&gt;srcresult = GST_FLOW_FLUSHING; // make sure we stop _loop task
1941             g_cond_signal (&amp;queue-&gt;item_add);
1942             GST_QUEUE_MUTEX_UNLOCK (queue);
1943             break;
1944         default:
1945             break;
1946     }
1947 
1948     GstStateChangeReturn ret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
1949 
1950     if (ret == GST_STATE_CHANGE_FAILURE)
1951         return ret;
1952 
1953     switch (transition)
1954     {
1955         case GST_STATE_CHANGE_READY_TO_NULL:
1956             GST_QUEUE_MUTEX_LOCK (queue);
1957             queue-&gt;srcresult = GST_FLOW_FLUSHING; // make sure we stop _loop task
1958             g_cond_signal (&amp;queue-&gt;item_add);
1959             GST_QUEUE_MUTEX_UNLOCK (queue);
1960             break;
1961         default:
1962             break;
1963     }
1964     return ret;
1965 }
1966 #endif
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>