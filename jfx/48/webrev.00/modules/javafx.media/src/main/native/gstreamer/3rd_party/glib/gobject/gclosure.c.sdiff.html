<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gclosure.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gboxed.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gclosure.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gclosure.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  69  * g_signal_connect_closure(), but it usually more convenient to let
  70  * GObject create a closure automatically by using one of the
  71  * g_signal_connect_*() functions which take a callback function/user
  72  * data pair.
  73  *
  74  * Using closures has a number of important advantages over a simple
  75  * callback function/data pointer combination:
  76  *
  77  * - Closures allow the callee to get the types of the callback parameters,
  78  *   which means that language bindings don&#39;t have to write individual glue
  79  *   for each callback type.
  80  *
  81  * - The reference counting of #GClosure makes it easy to handle reentrancy
  82  *   right; if a callback is removed while it is being invoked, the closure
  83  *   and its parameters won&#39;t be freed until the invocation finishes.
  84  *
  85  * - g_closure_invalidate() and invalidation notifiers allow callbacks to be
  86  *   automatically removed when the objects they point to go away.
  87  */
  88 
<span class="line-modified">  89 #define CLOSURE_MAX_REF_COUNT       ((1 &lt;&lt; 15) - 1)</span>
<span class="line-modified">  90 #define CLOSURE_MAX_N_GUARDS        ((1 &lt;&lt; 1) - 1)</span>
<span class="line-modified">  91 #define CLOSURE_MAX_N_FNOTIFIERS    ((1 &lt;&lt; 2) - 1)</span>
<span class="line-modified">  92 #define CLOSURE_MAX_N_INOTIFIERS    ((1 &lt;&lt; 8) - 1)</span>
<span class="line-modified">  93 #define CLOSURE_N_MFUNCS(cl)        (((cl)-&gt;n_guards &lt;&lt; 1L))</span>
  94 /* same as G_CLOSURE_N_NOTIFIERS() (keep in sync) */
<span class="line-modified">  95 #define CLOSURE_N_NOTIFIERS(cl)     (CLOSURE_N_MFUNCS (cl) + \</span>
  96                                          (cl)-&gt;n_fnotifiers + \
  97                                          (cl)-&gt;n_inotifiers)
  98 
  99 typedef union {
 100   GClosure closure;
 101   volatile gint vint;
 102 } ClosureInt;
 103 
 104 #define CHANGE_FIELD(_closure, _field, _OP, _value, _must_set, _SET_OLD, _SET_NEW)      \
 105 G_STMT_START {                                                                          \
<span class="line-modified"> 106   ClosureInt *cunion = (ClosureInt*) _closure;                                      \</span>
<span class="line-modified"> 107   gint new_int, old_int, success;                                                   \</span>
<span class="line-modified"> 108   do                                                                            \</span>
<span class="line-modified"> 109     {                                                                           \</span>
<span class="line-modified"> 110       ClosureInt tmp;                                                           \</span>
<span class="line-modified"> 111       tmp.vint = old_int = cunion-&gt;vint;                                        \</span>
 112       _SET_OLD tmp.closure._field;                                                      \
<span class="line-modified"> 113       tmp.closure._field _OP _value;                                            \</span>
 114       _SET_NEW tmp.closure._field;                                                      \
<span class="line-modified"> 115       new_int = tmp.vint;                                                       \</span>
 116       success = g_atomic_int_compare_and_exchange (&amp;cunion-&gt;vint, old_int, new_int);    \
<span class="line-modified"> 117     }                                                                           \</span>
 118   while (!success &amp;&amp; _must_set);                                                        \
 119 } G_STMT_END
 120 
 121 #define SWAP(_closure, _field, _value, _oldv)   CHANGE_FIELD (_closure, _field, =, _value, TRUE, *(_oldv) =,     (void) )
 122 #define SET(_closure, _field, _value)           CHANGE_FIELD (_closure, _field, =, _value, TRUE,     (void),     (void) )
 123 #define INC(_closure, _field)                   CHANGE_FIELD (_closure, _field, +=,     1, TRUE,     (void),     (void) )
 124 #define INC_ASSIGN(_closure, _field, _newv)     CHANGE_FIELD (_closure, _field, +=,     1, TRUE,     (void), *(_newv) = )
 125 #define DEC(_closure, _field)                   CHANGE_FIELD (_closure, _field, -=,     1, TRUE,     (void),     (void) )
 126 #define DEC_ASSIGN(_closure, _field, _newv)     CHANGE_FIELD (_closure, _field, -=,     1, TRUE,     (void), *(_newv) = )
 127 
 128 #if 0   /* for non-thread-safe closures */
 129 #define SWAP(cl,f,v,o)     (void) (*(o) = cl-&gt;f, cl-&gt;f = v)
 130 #define SET(cl,f,v)        (void) (cl-&gt;f = v)
 131 #define INC(cl,f)          (void) (cl-&gt;f += 1)
 132 #define INC_ASSIGN(cl,f,n) (void) (cl-&gt;f += 1, *(n) = cl-&gt;f)
 133 #define DEC(cl,f)          (void) (cl-&gt;f -= 1)
 134 #define DEC_ASSIGN(cl,f,n) (void) (cl-&gt;f -= 1, *(n) = cl-&gt;f)
 135 #endif
 136 
 137 enum {
</pre>
<hr />
<pre>
 173  * MyClosure *my_closure_new (gpointer data)
 174  * {
 175  *   GClosure *closure;
 176  *   MyClosure *my_closure;
 177  *
 178  *   closure = g_closure_new_simple (sizeof (MyClosure), data);
 179  *   my_closure = (MyClosure *) closure;
 180  *
 181  *   // initialize extra data here
 182  *
 183  *   g_closure_add_finalize_notifier (closure, notify_data,
 184  *                                    my_closure_finalize);
 185  *   return my_closure;
 186  * }
 187  * ]|
 188  *
 189  * Returns: (transfer none): a floating reference to a new #GClosure
 190  */
 191 GClosure*
 192 g_closure_new_simple (guint           sizeof_closure,
<span class="line-modified"> 193               gpointer        data)</span>
 194 {
 195   GClosure *closure;
 196   gint private_size;
 197   gchar *allocated;
 198 
 199   g_return_val_if_fail (sizeof_closure &gt;= sizeof (GClosure), NULL);
 200 
 201   private_size = sizeof (GRealClosure) - sizeof (GClosure);
 202 
 203 #ifdef ENABLE_VALGRIND
 204   /* See comments in gtype.c about what&#39;s going on here... */
 205   if (RUNNING_ON_VALGRIND)
 206     {
 207       private_size += sizeof (gpointer);
 208 
 209       allocated = g_malloc0 (private_size + sizeof_closure + sizeof (gpointer));
 210 #ifdef GSTREAMER_LITE
 211       if (allocated == NULL)
 212         return NULL;
 213 #endif // GSTREAMER_LITE
</pre>
<hr />
<pre>
 219     }
 220   else
 221 #endif
 222     allocated = g_malloc0 (private_size + sizeof_closure);
 223 #ifdef GSTREAMER_LITE
 224     if (allocated == NULL)
 225       return NULL;
 226 #endif // GSTREAMER_LITE
 227 
 228   closure = (GClosure *) (allocated + private_size);
 229 
 230   SET (closure, ref_count, 1);
 231   SET (closure, floating, TRUE);
 232   closure-&gt;data = data;
 233 
 234   return closure;
 235 }
 236 
 237 static inline void
 238 closure_invoke_notifiers (GClosure *closure,
<span class="line-modified"> 239               guint     notify_type)</span>
 240 {
 241   /* notifier layout:
 242    *     n_guards    n_guards     n_fnotif.  n_inotifiers
 243    * -&gt;[[pre_guards][post_guards][fnotifiers][inotifiers]]
 244    *
 245    * CLOSURE_N_MFUNCS(cl)    = n_guards + n_guards;
 246    * CLOSURE_N_NOTIFIERS(cl) = CLOSURE_N_MFUNCS(cl) + n_fnotifiers + n_inotifiers
 247    *
 248    * constrains/catches:
 249    * - closure-&gt;notifiers may be reloacted during callback
 250    * - closure-&gt;n_fnotifiers and closure-&gt;n_inotifiers may change during callback
 251    * - i.e. callbacks can be removed/added during invocation
 252    * - must prepare for callback removal during FNOTIFY and INOTIFY (done via -&gt;marshal= &amp; -&gt;data=)
 253    * - must distinguish (-&gt;marshal= &amp; -&gt;data=) for INOTIFY vs. FNOTIFY (via -&gt;in_inotify)
 254    * + closure-&gt;n_guards is const during PRE_NOTIFY &amp; POST_NOTIFY
 255    * + none of the callbacks can cause recursion
 256    * + closure-&gt;n_inotifiers is const 0 during FNOTIFY
 257    */
 258   switch (notify_type)
 259     {
 260       GClosureNotifyData *ndata;
 261       guint i, offs;
 262     case FNOTIFY:
 263       while (closure-&gt;n_fnotifiers)
<span class="line-modified"> 264     {</span>
 265           guint n;
<span class="line-modified"> 266       DEC_ASSIGN (closure, n_fnotifiers, &amp;n);</span>
 267 
<span class="line-modified"> 268       ndata = closure-&gt;notifiers + CLOSURE_N_MFUNCS (closure) + n;</span>
<span class="line-modified"> 269       closure-&gt;marshal = (GClosureMarshal) ndata-&gt;notify;</span>
<span class="line-modified"> 270       closure-&gt;data = ndata-&gt;data;</span>
<span class="line-modified"> 271       ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified"> 272     }</span>
 273       closure-&gt;marshal = NULL;
 274       closure-&gt;data = NULL;
 275       break;
 276     case INOTIFY:
 277       SET (closure, in_inotify, TRUE);
 278       while (closure-&gt;n_inotifiers)
<span class="line-modified"> 279     {</span>
 280           guint n;
 281           DEC_ASSIGN (closure, n_inotifiers, &amp;n);
 282 
<span class="line-modified"> 283       ndata = closure-&gt;notifiers + CLOSURE_N_MFUNCS (closure) + closure-&gt;n_fnotifiers + n;</span>
<span class="line-modified"> 284       closure-&gt;marshal = (GClosureMarshal) ndata-&gt;notify;</span>
<span class="line-modified"> 285       closure-&gt;data = ndata-&gt;data;</span>
<span class="line-modified"> 286       ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified"> 287     }</span>
 288       closure-&gt;marshal = NULL;
 289       closure-&gt;data = NULL;
 290       SET (closure, in_inotify, FALSE);
 291       break;
 292     case PRE_NOTIFY:
 293       i = closure-&gt;n_guards;
 294       offs = 0;
 295       while (i--)
<span class="line-modified"> 296     {</span>
<span class="line-modified"> 297       ndata = closure-&gt;notifiers + offs + i;</span>
<span class="line-modified"> 298       ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified"> 299     }</span>
 300       break;
 301     case POST_NOTIFY:
 302       i = closure-&gt;n_guards;
 303       offs = i;
 304       while (i--)
<span class="line-modified"> 305     {</span>
<span class="line-modified"> 306       ndata = closure-&gt;notifiers + offs + i;</span>
<span class="line-modified"> 307       ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified"> 308     }</span>
 309       break;
 310     }
 311 }
 312 
 313 static void
 314 g_closure_set_meta_va_marshal (GClosure       *closure,
<span class="line-modified"> 315                    GVaClosureMarshal va_meta_marshal)</span>
 316 {
 317   GRealClosure *real_closure;
 318 
 319   g_return_if_fail (closure != NULL);
 320   g_return_if_fail (va_meta_marshal != NULL);
 321   g_return_if_fail (closure-&gt;is_invalid == FALSE);
 322   g_return_if_fail (closure-&gt;in_marshal == FALSE);
 323 
 324   real_closure = G_REAL_CLOSURE (closure);
 325 
 326   g_return_if_fail (real_closure-&gt;meta_marshal != NULL);
 327 
 328   real_closure-&gt;va_meta_marshal = va_meta_marshal;
 329 }
 330 
 331 /**
 332  * g_closure_set_meta_marshal: (skip)
 333  * @closure: a #GClosure
 334  * @marshal_data: (closure meta_marshal): context-dependent data to pass
 335  *  to @meta_marshal
 336  * @meta_marshal: a #GClosureMarshal function
 337  *
 338  * Sets the meta marshaller of @closure.  A meta marshaller wraps
 339  * @closure-&gt;marshal and modifies the way it is called in some
 340  * fashion. The most common use of this facility is for C callbacks.
 341  * The same marshallers (generated by [glib-genmarshal][glib-genmarshal]),
 342  * are used everywhere, but the way that we get the callback function
 343  * differs. In most cases we want to use @closure-&gt;callback, but in
 344  * other cases we want to use some different technique to retrieve the
 345  * callback function.
 346  *
 347  * For example, class closures for signals (see
 348  * g_signal_type_cclosure_new()) retrieve the callback function from a
 349  * fixed offset in the class structure.  The meta marshaller retrieves
 350  * the right callback and passes it to the marshaller as the
 351  * @marshal_data argument.
 352  */
 353 void
 354 g_closure_set_meta_marshal (GClosure       *closure,
<span class="line-modified"> 355                 gpointer        marshal_data,</span>
<span class="line-modified"> 356                 GClosureMarshal meta_marshal)</span>
 357 {
 358   GRealClosure *real_closure;
 359 
 360   g_return_if_fail (closure != NULL);
 361   g_return_if_fail (meta_marshal != NULL);
 362   g_return_if_fail (closure-&gt;is_invalid == FALSE);
 363   g_return_if_fail (closure-&gt;in_marshal == FALSE);
 364 
 365   real_closure = G_REAL_CLOSURE (closure);
 366 
 367   g_return_if_fail (real_closure-&gt;meta_marshal == NULL);
 368 
 369   real_closure-&gt;meta_marshal = meta_marshal;
 370   real_closure-&gt;meta_marshal_data = marshal_data;
 371 }
 372 
 373 /**
 374  * g_closure_add_marshal_guards: (skip)
 375  * @closure: a #GClosure
 376  * @pre_marshal_data: (closure pre_marshal_notify): data to pass
 377  *  to @pre_marshal_notify
 378  * @pre_marshal_notify: a function to call before the closure callback
 379  * @post_marshal_data: (closure post_marshal_notify): data to pass
 380  *  to @post_marshal_notify
 381  * @post_marshal_notify: a function to call after the closure callback
 382  *
 383  * Adds a pair of notifiers which get invoked before and after the
 384  * closure callback, respectively. This is typically used to protect
 385  * the extra arguments for the duration of the callback. See
 386  * g_object_watch_closure() for an example of marshal guards.
 387  */
 388 void
 389 g_closure_add_marshal_guards (GClosure      *closure,
<span class="line-modified"> 390                   gpointer       pre_marshal_data,</span>
<span class="line-modified"> 391                   GClosureNotify pre_marshal_notify,</span>
<span class="line-modified"> 392                   gpointer       post_marshal_data,</span>
<span class="line-modified"> 393                   GClosureNotify post_marshal_notify)</span>
 394 {
 395   guint i;
 396 
 397   g_return_if_fail (closure != NULL);
 398   g_return_if_fail (pre_marshal_notify != NULL);
 399   g_return_if_fail (post_marshal_notify != NULL);
 400   g_return_if_fail (closure-&gt;is_invalid == FALSE);
 401   g_return_if_fail (closure-&gt;in_marshal == FALSE);
 402   g_return_if_fail (closure-&gt;n_guards &lt; CLOSURE_MAX_N_GUARDS);
 403 
 404   closure-&gt;notifiers = g_renew (GClosureNotifyData, closure-&gt;notifiers, CLOSURE_N_NOTIFIERS (closure) + 2);
 405   if (closure-&gt;n_inotifiers)
 406     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified"> 407             closure-&gt;n_fnotifiers +</span>
<span class="line-modified"> 408             closure-&gt;n_inotifiers + 1)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified"> 409                                       closure-&gt;n_fnotifiers + 0)];</span>
 410   if (closure-&gt;n_inotifiers &gt; 1)
 411     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified"> 412             closure-&gt;n_fnotifiers +</span>
<span class="line-modified"> 413             closure-&gt;n_inotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified"> 414                                       closure-&gt;n_fnotifiers + 1)];</span>
 415   if (closure-&gt;n_fnotifiers)
 416     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified"> 417             closure-&gt;n_fnotifiers + 1)] = closure-&gt;notifiers[CLOSURE_N_MFUNCS (closure) + 0];</span>
 418   if (closure-&gt;n_fnotifiers &gt; 1)
 419     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified"> 420             closure-&gt;n_fnotifiers)] = closure-&gt;notifiers[CLOSURE_N_MFUNCS (closure) + 1];</span>
 421   if (closure-&gt;n_guards)
 422     closure-&gt;notifiers[(closure-&gt;n_guards +
<span class="line-modified"> 423             closure-&gt;n_guards + 1)] = closure-&gt;notifiers[closure-&gt;n_guards];</span>
 424   i = closure-&gt;n_guards;
 425   closure-&gt;notifiers[i].data = pre_marshal_data;
 426   closure-&gt;notifiers[i].notify = pre_marshal_notify;
 427   closure-&gt;notifiers[i + 1].data = post_marshal_data;
 428   closure-&gt;notifiers[i + 1].notify = post_marshal_notify;
 429   INC (closure, n_guards);
 430 }
 431 
 432 /**
 433  * g_closure_add_finalize_notifier: (skip)
 434  * @closure: a #GClosure
 435  * @notify_data: (closure notify_func): data to pass to @notify_func
 436  * @notify_func: the callback function to register
 437  *
 438  * Registers a finalization notifier which will be called when the
 439  * reference count of @closure goes down to 0. Multiple finalization
 440  * notifiers on a single closure are invoked in unspecified order. If
 441  * a single call to g_closure_unref() results in the closure being
 442  * both invalidated and finalized, then the invalidate notifiers will
 443  * be run before the finalize notifiers.
 444  */
 445 void
 446 g_closure_add_finalize_notifier (GClosure      *closure,
<span class="line-modified"> 447                  gpointer       notify_data,</span>
<span class="line-modified"> 448                  GClosureNotify notify_func)</span>
 449 {
 450   guint i;
 451 
 452   g_return_if_fail (closure != NULL);
 453   g_return_if_fail (notify_func != NULL);
 454   g_return_if_fail (closure-&gt;n_fnotifiers &lt; CLOSURE_MAX_N_FNOTIFIERS);
 455 
 456   closure-&gt;notifiers = g_renew (GClosureNotifyData, closure-&gt;notifiers, CLOSURE_N_NOTIFIERS (closure) + 1);
 457   if (closure-&gt;n_inotifiers)
 458     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified"> 459             closure-&gt;n_fnotifiers +</span>
<span class="line-modified"> 460             closure-&gt;n_inotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified"> 461                                       closure-&gt;n_fnotifiers + 0)];</span>
 462   i = CLOSURE_N_MFUNCS (closure) + closure-&gt;n_fnotifiers;
 463   closure-&gt;notifiers[i].data = notify_data;
 464   closure-&gt;notifiers[i].notify = notify_func;
 465   INC (closure, n_fnotifiers);
 466 }
 467 
 468 /**
 469  * g_closure_add_invalidate_notifier: (skip)
 470  * @closure: a #GClosure
 471  * @notify_data: (closure notify_func): data to pass to @notify_func
 472  * @notify_func: the callback function to register
 473  *
 474  * Registers an invalidation notifier which will be called when the
 475  * @closure is invalidated with g_closure_invalidate(). Invalidation
 476  * notifiers are invoked before finalization notifiers, in an
 477  * unspecified order.
 478  */
 479 void
 480 g_closure_add_invalidate_notifier (GClosure      *closure,
<span class="line-modified"> 481                    gpointer       notify_data,</span>
<span class="line-modified"> 482                    GClosureNotify notify_func)</span>
 483 {
 484   guint i;
 485 
 486   g_return_if_fail (closure != NULL);
 487   g_return_if_fail (notify_func != NULL);
 488   g_return_if_fail (closure-&gt;is_invalid == FALSE);
 489   g_return_if_fail (closure-&gt;n_inotifiers &lt; CLOSURE_MAX_N_INOTIFIERS);
 490 
 491   closure-&gt;notifiers = g_renew (GClosureNotifyData, closure-&gt;notifiers, CLOSURE_N_NOTIFIERS (closure) + 1);
 492   i = CLOSURE_N_MFUNCS (closure) + closure-&gt;n_fnotifiers + closure-&gt;n_inotifiers;
 493   closure-&gt;notifiers[i].data = notify_data;
 494   closure-&gt;notifiers[i].notify = notify_func;
 495   INC (closure, n_inotifiers);
 496 }
 497 
 498 static inline gboolean
 499 closure_try_remove_inotify (GClosure       *closure,
<span class="line-modified"> 500                 gpointer       notify_data,</span>
<span class="line-modified"> 501                 GClosureNotify notify_func)</span>
 502 {
 503   GClosureNotifyData *ndata, *nlast;
 504 
 505   nlast = closure-&gt;notifiers + CLOSURE_N_NOTIFIERS (closure) - 1;
 506   for (ndata = nlast + 1 - closure-&gt;n_inotifiers; ndata &lt;= nlast; ndata++)
 507     if (ndata-&gt;notify == notify_func &amp;&amp; ndata-&gt;data == notify_data)
 508       {
<span class="line-modified"> 509     DEC (closure, n_inotifiers);</span>
<span class="line-modified"> 510     if (ndata &lt; nlast)</span>
<span class="line-modified"> 511       *ndata = *nlast;</span>
 512 
<span class="line-modified"> 513     return TRUE;</span>
 514       }
 515   return FALSE;
 516 }
 517 
 518 static inline gboolean
 519 closure_try_remove_fnotify (GClosure       *closure,
<span class="line-modified"> 520                 gpointer       notify_data,</span>
<span class="line-modified"> 521                 GClosureNotify notify_func)</span>
 522 {
 523   GClosureNotifyData *ndata, *nlast;
 524 
 525   nlast = closure-&gt;notifiers + CLOSURE_N_NOTIFIERS (closure) - closure-&gt;n_inotifiers - 1;
 526   for (ndata = nlast + 1 - closure-&gt;n_fnotifiers; ndata &lt;= nlast; ndata++)
 527     if (ndata-&gt;notify == notify_func &amp;&amp; ndata-&gt;data == notify_data)
 528       {
<span class="line-modified"> 529     DEC (closure, n_fnotifiers);</span>
<span class="line-modified"> 530     if (ndata &lt; nlast)</span>
<span class="line-modified"> 531       *ndata = *nlast;</span>
<span class="line-modified"> 532     if (closure-&gt;n_inotifiers)</span>
<span class="line-modified"> 533       closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified"> 534                   closure-&gt;n_fnotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified"> 535                                         closure-&gt;n_fnotifiers +</span>
<span class="line-modified"> 536                                         closure-&gt;n_inotifiers)];</span>
<span class="line-modified"> 537     return TRUE;</span>
 538       }
 539   return FALSE;
 540 }
 541 
 542 /**
 543  * g_closure_ref:
 544  * @closure: #GClosure to increment the reference count on
 545  *
 546  * Increments the reference count on a closure to force it staying
 547  * alive while the caller holds a pointer to it.
 548  *
 549  * Returns: (transfer none): The @closure passed in, for convenience
 550  */
 551 GClosure*
 552 g_closure_ref (GClosure *closure)
 553 {
 554   guint new_ref_count;
 555   g_return_val_if_fail (closure != NULL, NULL);
 556   g_return_val_if_fail (closure-&gt;ref_count &gt; 0, NULL);
 557   g_return_val_if_fail (closure-&gt;ref_count &lt; CLOSURE_MAX_REF_COUNT, NULL);
 558 
 559   INC_ASSIGN (closure, ref_count, &amp;new_ref_count);
 560   g_return_val_if_fail (new_ref_count &gt; 1, NULL);
 561 
 562   return closure;
 563 }
 564 
 565 /**
 566  * g_closure_invalidate:
<span class="line-modified"> 567  * @closure: GClosure to invalidate</span>
 568  *
 569  * Sets a flag on the closure to indicate that its calling
 570  * environment has become invalid, and thus causes any future
 571  * invocations of g_closure_invoke() on this @closure to be
 572  * ignored. Also, invalidation notifiers installed on the closure will
 573  * be called at this point. Note that unless you are holding a
 574  * reference to the closure yourself, the invalidation notifiers may
 575  * unref the closure and cause it to be destroyed, so if you need to
 576  * access the closure after calling g_closure_invalidate(), make sure
 577  * that you&#39;ve previously called g_closure_ref().
 578  *
 579  * Note that g_closure_invalidate() will also be called when the
 580  * reference count of a closure drops to zero (unless it has already
 581  * been invalidated before).
 582  */
 583 void
 584 g_closure_invalidate (GClosure *closure)
 585 {
 586   g_return_if_fail (closure != NULL);
 587 
</pre>
<hr />
<pre>
 726       SWAP (closure, floating, FALSE, &amp;was_floating);
 727       /* unref floating flag only once */
 728       if (was_floating)
 729         g_closure_unref (closure);
 730     }
 731 }
 732 
 733 /**
 734  * g_closure_remove_invalidate_notifier: (skip)
 735  * @closure: a #GClosure
 736  * @notify_data: data which was passed to g_closure_add_invalidate_notifier()
 737  *               when registering @notify_func
 738  * @notify_func: the callback function to remove
 739  *
 740  * Removes an invalidation notifier.
 741  *
 742  * Notice that notifiers are automatically removed after they are run.
 743  */
 744 void
 745 g_closure_remove_invalidate_notifier (GClosure      *closure,
<span class="line-modified"> 746                       gpointer       notify_data,</span>
<span class="line-modified"> 747                       GClosureNotify notify_func)</span>
 748 {
 749   g_return_if_fail (closure != NULL);
 750   g_return_if_fail (notify_func != NULL);
 751 
 752   if (closure-&gt;is_invalid &amp;&amp; closure-&gt;in_inotify &amp;&amp; /* account removal of notify_func() while it&#39;s called */
 753       ((gpointer) closure-&gt;marshal) == ((gpointer) notify_func) &amp;&amp;
 754       closure-&gt;data == notify_data)
 755     closure-&gt;marshal = NULL;
 756   else if (!closure_try_remove_inotify (closure, notify_data, notify_func))
 757     g_warning (G_STRLOC &quot;: unable to remove uninstalled invalidation notifier: %p (%p)&quot;,
<span class="line-modified"> 758            notify_func, notify_data);</span>
 759 }
 760 
 761 /**
 762  * g_closure_remove_finalize_notifier: (skip)
 763  * @closure: a #GClosure
 764  * @notify_data: data which was passed to g_closure_add_finalize_notifier()
 765  *  when registering @notify_func
 766  * @notify_func: the callback function to remove
 767  *
 768  * Removes a finalization notifier.
 769  *
 770  * Notice that notifiers are automatically removed after they are run.
 771  */
 772 void
 773 g_closure_remove_finalize_notifier (GClosure      *closure,
<span class="line-modified"> 774                     gpointer       notify_data,</span>
<span class="line-modified"> 775                     GClosureNotify notify_func)</span>
 776 {
 777   g_return_if_fail (closure != NULL);
 778   g_return_if_fail (notify_func != NULL);
 779 
 780   if (closure-&gt;is_invalid &amp;&amp; !closure-&gt;in_inotify &amp;&amp; /* account removal of notify_func() while it&#39;s called */
 781       ((gpointer) closure-&gt;marshal) == ((gpointer) notify_func) &amp;&amp;
 782       closure-&gt;data == notify_data)
 783     closure-&gt;marshal = NULL;
 784   else if (!closure_try_remove_fnotify (closure, notify_data, notify_func))
 785     g_warning (G_STRLOC &quot;: unable to remove uninstalled finalization notifier: %p (%p)&quot;,
 786                notify_func, notify_data);
 787 }
 788 
 789 /**
 790  * g_closure_invoke:
 791  * @closure: a #GClosure
 792  * @return_value: (optional) (out): a #GValue to store the return
 793  *                value. May be %NULL if the callback of @closure
 794  *                doesn&#39;t return a value.
 795  * @n_param_values: the length of the @param_values array
 796  * @param_values: (array length=n_param_values): an array of
 797  *                #GValues holding the arguments on which to
 798  *                invoke the callback of @closure
 799  * @invocation_hint: (nullable): a context-dependent invocation hint
 800  *
 801  * Invokes the closure, i.e. executes the callback represented by the @closure.
 802  */
 803 void
 804 g_closure_invoke (GClosure       *closure,
<span class="line-modified"> 805           GValue /*out*/ *return_value,</span>
<span class="line-modified"> 806           guint           n_param_values,</span>
<span class="line-modified"> 807           const GValue   *param_values,</span>
<span class="line-modified"> 808           gpointer        invocation_hint)</span>
 809 {
 810   GRealClosure *real_closure;
 811 
 812   g_return_if_fail (closure != NULL);
 813 
 814   real_closure = G_REAL_CLOSURE (closure);
 815 
 816   g_closure_ref (closure);      /* preserve floating flag */
 817   if (!closure-&gt;is_invalid)
 818     {
 819       GClosureMarshal marshal;
 820       gpointer marshal_data;
 821       gboolean in_marshal = closure-&gt;in_marshal;
 822 
 823       g_return_if_fail (closure-&gt;marshal || real_closure-&gt;meta_marshal);
 824 
 825       SET (closure, in_marshal, TRUE);
 826       if (real_closure-&gt;meta_marshal)
<span class="line-modified"> 827     {</span>
<span class="line-modified"> 828       marshal_data = real_closure-&gt;meta_marshal_data;</span>
<span class="line-modified"> 829       marshal = real_closure-&gt;meta_marshal;</span>
<span class="line-modified"> 830     }</span>
 831       else
<span class="line-modified"> 832     {</span>
<span class="line-modified"> 833       marshal_data = NULL;</span>
<span class="line-modified"> 834       marshal = closure-&gt;marshal;</span>
<span class="line-modified"> 835     }</span>
 836       if (!in_marshal)
<span class="line-modified"> 837     closure_invoke_notifiers (closure, PRE_NOTIFY);</span>
 838       marshal (closure,
<span class="line-modified"> 839            return_value,</span>
<span class="line-modified"> 840            n_param_values, param_values,</span>
<span class="line-modified"> 841            invocation_hint,</span>
<span class="line-modified"> 842            marshal_data);</span>
 843       if (!in_marshal)
<span class="line-modified"> 844     closure_invoke_notifiers (closure, POST_NOTIFY);</span>
 845       SET (closure, in_marshal, in_marshal);
 846     }
 847   g_closure_unref (closure);
 848 }
 849 
 850 gboolean
 851 _g_closure_supports_invoke_va (GClosure       *closure)
 852 {
 853   GRealClosure *real_closure;
 854 
 855   g_return_val_if_fail (closure != NULL, FALSE);
 856 
 857   real_closure = G_REAL_CLOSURE (closure);
 858 
 859   return
 860     real_closure-&gt;va_marshal != NULL &amp;&amp;
 861     (real_closure-&gt;meta_marshal == NULL ||
 862      real_closure-&gt;va_meta_marshal != NULL);
 863 }
 864 
 865 void
 866 _g_closure_invoke_va (GClosure       *closure,
<span class="line-modified"> 867               GValue /*out*/ *return_value,</span>
<span class="line-modified"> 868               gpointer        instance,</span>
<span class="line-modified"> 869               va_list         args,</span>
<span class="line-modified"> 870               int             n_params,</span>
<span class="line-modified"> 871               GType          *param_types)</span>
 872 {
 873   GRealClosure *real_closure;
 874 
 875   g_return_if_fail (closure != NULL);
 876 
 877   real_closure = G_REAL_CLOSURE (closure);
 878 
 879   g_closure_ref (closure);      /* preserve floating flag */
 880   if (!closure-&gt;is_invalid)
 881     {
 882       GVaClosureMarshal marshal;
 883       gpointer marshal_data;
 884       gboolean in_marshal = closure-&gt;in_marshal;
 885 
 886       g_return_if_fail (closure-&gt;marshal || real_closure-&gt;meta_marshal);
 887 
 888       SET (closure, in_marshal, TRUE);
 889       if (real_closure-&gt;va_meta_marshal)
<span class="line-modified"> 890     {</span>
<span class="line-modified"> 891       marshal_data = real_closure-&gt;meta_marshal_data;</span>
<span class="line-modified"> 892       marshal = real_closure-&gt;va_meta_marshal;</span>
<span class="line-modified"> 893     }</span>
 894       else
<span class="line-modified"> 895     {</span>
<span class="line-modified"> 896       marshal_data = NULL;</span>
<span class="line-modified"> 897       marshal = real_closure-&gt;va_marshal;</span>
<span class="line-modified"> 898     }</span>
 899       if (!in_marshal)
<span class="line-modified"> 900     closure_invoke_notifiers (closure, PRE_NOTIFY);</span>
 901       marshal (closure,
<span class="line-modified"> 902            return_value,</span>
<span class="line-modified"> 903            instance, args,</span>
<span class="line-modified"> 904            marshal_data,</span>
<span class="line-modified"> 905            n_params, param_types);</span>
 906       if (!in_marshal)
<span class="line-modified"> 907     closure_invoke_notifiers (closure, POST_NOTIFY);</span>
 908       SET (closure, in_marshal, in_marshal);
 909     }
 910   g_closure_unref (closure);
 911 }
 912 
 913 
 914 /**
 915  * g_closure_set_marshal: (skip)
 916  * @closure: a #GClosure
 917  * @marshal: a #GClosureMarshal function
 918  *
 919  * Sets the marshaller of @closure. The `marshal_data`
 920  * of @marshal provides a way for a meta marshaller to provide additional
 921  * information to the marshaller. (See g_closure_set_meta_marshal().) For
 922  * GObject&#39;s C predefined marshallers (the g_cclosure_marshal_*()
 923  * functions), what it provides is a callback function to use instead of
 924  * @closure-&gt;callback.
 925  */
 926 void
 927 g_closure_set_marshal (GClosure       *closure,
<span class="line-modified"> 928                GClosureMarshal marshal)</span>
 929 {
 930   g_return_if_fail (closure != NULL);
 931   g_return_if_fail (marshal != NULL);
 932 
 933   if (closure-&gt;marshal &amp;&amp; closure-&gt;marshal != marshal)
 934     g_warning (&quot;attempt to override closure-&gt;marshal (%p) with new marshal (%p)&quot;,
<span class="line-modified"> 935            closure-&gt;marshal, marshal);</span>
 936   else
 937     closure-&gt;marshal = marshal;
 938 }
 939 
 940 void
 941 _g_closure_set_va_marshal (GClosure       *closure,
<span class="line-modified"> 942                GVaClosureMarshal marshal)</span>
 943 {
 944   GRealClosure *real_closure;
 945 
 946   g_return_if_fail (closure != NULL);
 947   g_return_if_fail (marshal != NULL);
 948 
 949   real_closure = G_REAL_CLOSURE (closure);
 950 
 951   if (real_closure-&gt;va_marshal &amp;&amp; real_closure-&gt;va_marshal != marshal)
 952     g_warning (&quot;attempt to override closure-&gt;va_marshal (%p) with new marshal (%p)&quot;,
<span class="line-modified"> 953            real_closure-&gt;va_marshal, marshal);</span>
 954   else
 955     real_closure-&gt;va_marshal = marshal;
 956 }
 957 
 958 /**
 959  * g_cclosure_new: (skip)
 960  * @callback_func: the function to invoke
 961  * @user_data: (closure callback_func): user data to pass to @callback_func
 962  * @destroy_data: destroy notify to be called when @user_data is no longer used
 963  *
 964  * Creates a new closure which invokes @callback_func with @user_data as
 965  * the last parameter.
 966  *


 967  * Returns: (transfer none): a floating reference to a new #GCClosure
 968  */
 969 GClosure*
 970 g_cclosure_new (GCallback      callback_func,
<span class="line-modified"> 971         gpointer       user_data,</span>
<span class="line-modified"> 972         GClosureNotify destroy_data)</span>
 973 {
 974   GClosure *closure;
 975 
 976   g_return_val_if_fail (callback_func != NULL, NULL);
 977 
 978   closure = g_closure_new_simple (sizeof (GCClosure), user_data);
 979 #ifdef GSTREAMER_LITE
 980   if (closure == NULL)
 981     return NULL;
 982 #endif // GSTREAMER_LITE
 983   if (destroy_data)
 984     g_closure_add_finalize_notifier (closure, user_data, destroy_data);
 985   ((GCClosure*) closure)-&gt;callback = (gpointer) callback_func;
 986 
 987   return closure;
 988 }
 989 
 990 /**
 991  * g_cclosure_new_swap: (skip)
 992  * @callback_func: the function to invoke
 993  * @user_data: (closure callback_func): user data to pass to @callback_func
 994  * @destroy_data: destroy notify to be called when @user_data is no longer used
 995  *
 996  * Creates a new closure which invokes @callback_func with @user_data as
 997  * the first parameter.
 998  *


 999  * Returns: (transfer none): a floating reference to a new #GCClosure
1000  */
1001 GClosure*
1002 g_cclosure_new_swap (GCallback      callback_func,
<span class="line-modified">1003              gpointer       user_data,</span>
<span class="line-modified">1004              GClosureNotify destroy_data)</span>
1005 {
1006   GClosure *closure;
1007 
1008   g_return_val_if_fail (callback_func != NULL, NULL);
1009 
1010   closure = g_closure_new_simple (sizeof (GCClosure), user_data);
1011 #ifdef GSTREAMER_LITE
1012   if (closure == NULL)
1013     return NULL;
1014 #endif // GSTREAMER_LITE
1015   if (destroy_data)
1016     g_closure_add_finalize_notifier (closure, user_data, destroy_data);
1017   ((GCClosure*) closure)-&gt;callback = (gpointer) callback_func;
1018   SET (closure, derivative_flag, TRUE);
1019 
1020   return closure;
1021 }
1022 
1023 static void
1024 g_type_class_meta_marshal (GClosure       *closure,
<span class="line-modified">1025                GValue /*out*/ *return_value,</span>
<span class="line-modified">1026                guint           n_param_values,</span>
<span class="line-modified">1027                const GValue   *param_values,</span>
<span class="line-modified">1028                gpointer        invocation_hint,</span>
<span class="line-modified">1029                gpointer        marshal_data)</span>
1030 {
1031   GTypeClass *class;
1032   gpointer callback;
1033   /* GType itype = (GType) closure-&gt;data; */
1034   guint offset = GPOINTER_TO_UINT (marshal_data);
1035 
1036   class = G_TYPE_INSTANCE_GET_CLASS (g_value_peek_pointer (param_values + 0), itype, GTypeClass);
1037   callback = G_STRUCT_MEMBER (gpointer, class, offset);
1038   if (callback)
1039     closure-&gt;marshal (closure,
<span class="line-modified">1040               return_value,</span>
<span class="line-modified">1041               n_param_values, param_values,</span>
<span class="line-modified">1042               invocation_hint,</span>
<span class="line-modified">1043               callback);</span>
1044 }
1045 
1046 static void
1047 g_type_class_meta_marshalv (GClosure *closure,
<span class="line-modified">1048                 GValue   *return_value,</span>
<span class="line-modified">1049                 gpointer  instance,</span>
<span class="line-modified">1050                 va_list   args,</span>
<span class="line-modified">1051                 gpointer  marshal_data,</span>
<span class="line-modified">1052                 int       n_params,</span>
<span class="line-modified">1053                 GType    *param_types)</span>
1054 {
1055   GRealClosure *real_closure;
1056   GTypeClass *class;
1057   gpointer callback;
1058   /* GType itype = (GType) closure-&gt;data; */
1059   guint offset = GPOINTER_TO_UINT (marshal_data);
1060 
1061   real_closure = G_REAL_CLOSURE (closure);
1062 
1063   class = G_TYPE_INSTANCE_GET_CLASS (instance, itype, GTypeClass);
1064   callback = G_STRUCT_MEMBER (gpointer, class, offset);
1065   if (callback)
1066     real_closure-&gt;va_marshal (closure,
<span class="line-modified">1067                   return_value,</span>
<span class="line-modified">1068                   instance, args,</span>
<span class="line-modified">1069                   callback,</span>
<span class="line-modified">1070                   n_params,</span>
<span class="line-modified">1071                   param_types);</span>
1072 }
1073 
1074 static void
1075 g_type_iface_meta_marshal (GClosure       *closure,
<span class="line-modified">1076                GValue /*out*/ *return_value,</span>
<span class="line-modified">1077                guint           n_param_values,</span>
<span class="line-modified">1078                const GValue   *param_values,</span>
<span class="line-modified">1079                gpointer        invocation_hint,</span>
<span class="line-modified">1080                gpointer        marshal_data)</span>
1081 {
1082   GTypeClass *class;
1083   gpointer callback;
1084   GType itype = (GType) closure-&gt;data;
1085   guint offset = GPOINTER_TO_UINT (marshal_data);
1086 
1087   class = G_TYPE_INSTANCE_GET_INTERFACE (g_value_peek_pointer (param_values + 0), itype, GTypeClass);
1088   callback = G_STRUCT_MEMBER (gpointer, class, offset);
1089   if (callback)
1090     closure-&gt;marshal (closure,
<span class="line-modified">1091               return_value,</span>
<span class="line-modified">1092               n_param_values, param_values,</span>
<span class="line-modified">1093               invocation_hint,</span>
<span class="line-modified">1094               callback);</span>
1095 }
1096 
1097 gboolean
1098 _g_closure_is_void (GClosure *closure,
<span class="line-modified">1099             gpointer instance)</span>
1100 {
1101   GRealClosure *real_closure;
1102   GTypeClass *class;
1103   gpointer callback;
1104   GType itype;
1105   guint offset;
1106 
1107   if (closure-&gt;is_invalid)
1108     return TRUE;
1109 
1110   real_closure = G_REAL_CLOSURE (closure);
1111 
1112   if (real_closure-&gt;meta_marshal == g_type_iface_meta_marshal)
1113     {
1114       itype = (GType) closure-&gt;data;
1115       offset = GPOINTER_TO_UINT (real_closure-&gt;meta_marshal_data);
1116 
1117       class = G_TYPE_INSTANCE_GET_INTERFACE (instance, itype, GTypeClass);
1118       callback = G_STRUCT_MEMBER (gpointer, class, offset);
1119       return callback == NULL;
1120     }
1121   else if (real_closure-&gt;meta_marshal == g_type_class_meta_marshal)
1122     {
1123       offset = GPOINTER_TO_UINT (real_closure-&gt;meta_marshal_data);
1124 
1125       class = G_TYPE_INSTANCE_GET_CLASS (instance, itype, GTypeClass);
1126       callback = G_STRUCT_MEMBER (gpointer, class, offset);
1127       return callback == NULL;
1128     }
1129 
1130   return FALSE;
1131 }
1132 
1133 static void
1134 g_type_iface_meta_marshalv (GClosure *closure,
<span class="line-modified">1135                 GValue   *return_value,</span>
<span class="line-modified">1136                 gpointer  instance,</span>
<span class="line-modified">1137                 va_list   args,</span>
<span class="line-modified">1138                 gpointer  marshal_data,</span>
<span class="line-modified">1139                 int       n_params,</span>
<span class="line-modified">1140                 GType    *param_types)</span>
1141 {
1142   GRealClosure *real_closure;
1143   GTypeClass *class;
1144   gpointer callback;
1145   GType itype = (GType) closure-&gt;data;
1146   guint offset = GPOINTER_TO_UINT (marshal_data);
1147 
1148   real_closure = G_REAL_CLOSURE (closure);
1149 
1150   class = G_TYPE_INSTANCE_GET_INTERFACE (instance, itype, GTypeClass);
1151   callback = G_STRUCT_MEMBER (gpointer, class, offset);
1152   if (callback)
1153     real_closure-&gt;va_marshal (closure,
<span class="line-modified">1154                   return_value,</span>
<span class="line-modified">1155                   instance, args,</span>
<span class="line-modified">1156                   callback,</span>
<span class="line-modified">1157                   n_params,</span>
<span class="line-modified">1158                   param_types);</span>
1159 }
1160 
1161 /**
1162  * g_signal_type_cclosure_new:
1163  * @itype: the #GType identifier of an interface or classed type
1164  * @struct_offset: the offset of the member function of @itype&#39;s class
1165  *  structure which is to be invoked by the new closure
1166  *
1167  * Creates a new closure which invokes the function found at the offset
1168  * @struct_offset in the class structure of the interface or classed type
1169  * identified by @itype.
1170  *
1171  * Returns: (transfer none): a floating reference to a new #GCClosure
1172  */
1173 GClosure*
1174 g_signal_type_cclosure_new (GType    itype,
<span class="line-modified">1175                 guint    struct_offset)</span>
1176 {
1177   GClosure *closure;
1178 
1179   g_return_val_if_fail (G_TYPE_IS_CLASSED (itype) || G_TYPE_IS_INTERFACE (itype), NULL);
1180   g_return_val_if_fail (struct_offset &gt;= sizeof (GTypeClass), NULL);
1181 
1182   closure = g_closure_new_simple (sizeof (GClosure), (gpointer) itype);
1183   if (G_TYPE_IS_INTERFACE (itype))
1184     {
1185       g_closure_set_meta_marshal (closure, GUINT_TO_POINTER (struct_offset), g_type_iface_meta_marshal);
1186       g_closure_set_meta_va_marshal (closure, g_type_iface_meta_marshalv);
1187     }
1188   else
1189     {
1190       g_closure_set_meta_marshal (closure, GUINT_TO_POINTER (struct_offset), g_type_class_meta_marshal);
1191       g_closure_set_meta_va_marshal (closure, g_type_class_meta_marshalv);
1192     }
1193   return closure;
1194 }
1195 
</pre>
<hr />
<pre>
1353     default:
1354       g_warning (&quot;value_from_ffi_type: Unsupported fundamental type: %s&quot;,
1355                 g_type_name (g_type_fundamental (G_VALUE_TYPE (gvalue))));
1356     }
1357 }
1358 
1359 typedef union {
1360   gpointer _gpointer;
1361   float _float;
1362   double _double;
1363   gint _gint;
1364   guint _guint;
1365   glong _glong;
1366   gulong _gulong;
1367   gint64 _gint64;
1368   guint64 _guint64;
1369 } va_arg_storage;
1370 
1371 static ffi_type *
1372 va_to_ffi_type (GType gtype,
<span class="line-modified">1373         va_list *va,</span>
<span class="line-modified">1374         va_arg_storage *storage)</span>
1375 {
1376   ffi_type *rettype = NULL;
1377   GType type = g_type_fundamental (gtype);
1378   g_assert (type != G_TYPE_INVALID);
1379 
1380   switch (type)
1381     {
1382     case G_TYPE_BOOLEAN:
1383     case G_TYPE_CHAR:
1384     case G_TYPE_INT:
1385     case G_TYPE_ENUM:
1386       rettype = &amp;ffi_type_sint;
1387       storage-&gt;_gint = va_arg (*va, gint);
1388       break;
1389     case G_TYPE_UCHAR:
1390     case G_TYPE_UINT:
1391     case G_TYPE_FLAGS:
1392       rettype = &amp;ffi_type_uint;
1393       storage-&gt;_guint = va_arg (*va, guint);
1394       break;
</pre>
<hr />
<pre>
1541  * @return_value: (nullable): a #GValue to store the return
1542  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
1543  *  value.
1544  * @instance: (type GObject.TypeInstance): the instance on which the closure is
1545  *  invoked.
1546  * @args_list: va_list of arguments to be passed to the closure.
1547  * @marshal_data: (nullable): additional data specified when
1548  *  registering the marshaller, see g_closure_set_marshal() and
1549  *  g_closure_set_meta_marshal()
1550  * @n_params: the length of the @param_types array
1551  * @param_types: (array length=n_params): the #GType of each argument from
1552  *  @args_list.
1553  *
1554  * A generic #GVaClosureMarshal function implemented via
1555  * [libffi](http://sourceware.org/libffi/).
1556  *
1557  * Since: 2.30
1558  */
1559 void
1560 g_cclosure_marshal_generic_va (GClosure *closure,
<span class="line-modified">1561                    GValue   *return_value,</span>
<span class="line-modified">1562                    gpointer  instance,</span>
<span class="line-modified">1563                    va_list   args_list,</span>
<span class="line-modified">1564                    gpointer  marshal_data,</span>
<span class="line-modified">1565                    int       n_params,</span>
<span class="line-modified">1566                    GType    *param_types)</span>
1567 {
1568   ffi_type *rtype;
1569   void *rvalue;
1570   int n_args;
1571   ffi_type **atypes;
1572   void **args;
1573   va_arg_storage *storage;
1574   int i;
1575   ffi_cif cif;
1576   GCClosure *cc = (GCClosure*) closure;
1577   gint *enum_tmpval;
1578   gboolean tmpval_used = FALSE;
1579   va_list args_copy;
1580 
1581   enum_tmpval = g_alloca (sizeof (gint));
1582   if (return_value &amp;&amp; G_VALUE_TYPE (return_value))
1583     {
1584       rtype = value_to_ffi_type (return_value, &amp;rvalue, enum_tmpval, &amp;tmpval_used);
1585     }
1586   else
</pre>
<hr />
<pre>
1602       atypes[0] = &amp;ffi_type_pointer;
1603       args[0] = &amp;closure-&gt;data;
1604     }
1605   else
1606     {
1607       atypes[0] = &amp;ffi_type_pointer;
1608       args[0] = &amp;instance;
1609       atypes[n_args-1] = &amp;ffi_type_pointer;
1610       args[n_args-1] = &amp;closure-&gt;data;
1611     }
1612 
1613   G_VA_COPY (args_copy, args_list);
1614 
1615   /* Box non-primitive arguments */
1616   for (i = 0; i &lt; n_params; i++)
1617     {
1618       GType type = param_types[i]  &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
1619       GType fundamental = G_TYPE_FUNDAMENTAL (type);
1620 
1621       atypes[i+1] = va_to_ffi_type (type,
<span class="line-modified">1622                     &amp;args_copy,</span>
<span class="line-modified">1623                     &amp;storage[i]);</span>
1624       args[i+1] = &amp;storage[i];
1625 
1626       if ((param_types[i]  &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0)
<span class="line-modified">1627     {</span>
<span class="line-modified">1628       if (fundamental == G_TYPE_STRING &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1629         storage[i]._gpointer = g_strdup (storage[i]._gpointer);</span>
<span class="line-modified">1630       else if (fundamental == G_TYPE_PARAM &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1631         storage[i]._gpointer = g_param_spec_ref (storage[i]._gpointer);</span>
<span class="line-modified">1632       else if (fundamental == G_TYPE_BOXED &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1633         storage[i]._gpointer = g_boxed_copy (type, storage[i]._gpointer);</span>
<span class="line-modified">1634       else if (fundamental == G_TYPE_VARIANT &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1635         storage[i]._gpointer = g_variant_ref_sink (storage[i]._gpointer);</span>
<span class="line-modified">1636     }</span>
1637       if (fundamental == G_TYPE_OBJECT &amp;&amp; storage[i]._gpointer != NULL)
<span class="line-modified">1638     storage[i]._gpointer = g_object_ref (storage[i]._gpointer);</span>
1639     }
1640 
1641   va_end (args_copy);
1642 
1643   if (ffi_prep_cif (&amp;cif, FFI_DEFAULT_ABI, n_args, rtype, atypes) != FFI_OK)
1644     return;
1645 
1646   ffi_call (&amp;cif, marshal_data ? marshal_data : cc-&gt;callback, rvalue, args);
1647 
1648   /* Unbox non-primitive arguments */
1649   for (i = 0; i &lt; n_params; i++)
1650     {
1651       GType type = param_types[i]  &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
1652       GType fundamental = G_TYPE_FUNDAMENTAL (type);
1653 
1654       if ((param_types[i]  &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0)
<span class="line-modified">1655     {</span>
<span class="line-modified">1656       if (fundamental == G_TYPE_STRING &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1657         g_free (storage[i]._gpointer);</span>
<span class="line-modified">1658       else if (fundamental == G_TYPE_PARAM &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1659         g_param_spec_unref (storage[i]._gpointer);</span>
<span class="line-modified">1660       else if (fundamental == G_TYPE_BOXED &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1661         g_boxed_free (type, storage[i]._gpointer);</span>
<span class="line-modified">1662       else if (fundamental == G_TYPE_VARIANT &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1663         g_variant_unref (storage[i]._gpointer);</span>
<span class="line-modified">1664     }</span>
1665       if (fundamental == G_TYPE_OBJECT &amp;&amp; storage[i]._gpointer != NULL)
<span class="line-modified">1666     g_object_unref (storage[i]._gpointer);</span>
1667     }
1668 
1669   if (return_value &amp;&amp; G_VALUE_TYPE (return_value))
1670     value_from_ffi_type (return_value, rvalue);
1671 }
1672 
1673 /**
1674  * g_cclosure_marshal_VOID__VOID:
1675  * @closure: the #GClosure to which the marshaller belongs
1676  * @return_value: ignored
1677  * @n_param_values: 1
1678  * @param_values: a #GValue array holding only the instance
1679  * @invocation_hint: the invocation hint given as the last argument
1680  *  to g_closure_invoke()
1681  * @marshal_data: additional data specified when registering the marshaller
1682  *
1683  * A marshaller for a #GCClosure with a callback of type
1684  * `void (*callback) (gpointer instance, gpointer user_data)`.
1685  */
1686 
</pre>
</td>
<td>
<hr />
<pre>
  69  * g_signal_connect_closure(), but it usually more convenient to let
  70  * GObject create a closure automatically by using one of the
  71  * g_signal_connect_*() functions which take a callback function/user
  72  * data pair.
  73  *
  74  * Using closures has a number of important advantages over a simple
  75  * callback function/data pointer combination:
  76  *
  77  * - Closures allow the callee to get the types of the callback parameters,
  78  *   which means that language bindings don&#39;t have to write individual glue
  79  *   for each callback type.
  80  *
  81  * - The reference counting of #GClosure makes it easy to handle reentrancy
  82  *   right; if a callback is removed while it is being invoked, the closure
  83  *   and its parameters won&#39;t be freed until the invocation finishes.
  84  *
  85  * - g_closure_invalidate() and invalidation notifiers allow callbacks to be
  86  *   automatically removed when the objects they point to go away.
  87  */
  88 
<span class="line-modified">  89 #define CLOSURE_MAX_REF_COUNT   ((1 &lt;&lt; 15) - 1)</span>
<span class="line-modified">  90 #define CLOSURE_MAX_N_GUARDS    ((1 &lt;&lt; 1) - 1)</span>
<span class="line-modified">  91 #define CLOSURE_MAX_N_FNOTIFIERS  ((1 &lt;&lt; 2) - 1)</span>
<span class="line-modified">  92 #define CLOSURE_MAX_N_INOTIFIERS  ((1 &lt;&lt; 8) - 1)</span>
<span class="line-modified">  93 #define CLOSURE_N_MFUNCS(cl)    (((cl)-&gt;n_guards &lt;&lt; 1L))</span>
  94 /* same as G_CLOSURE_N_NOTIFIERS() (keep in sync) */
<span class="line-modified">  95 #define CLOSURE_N_NOTIFIERS(cl)   (CLOSURE_N_MFUNCS (cl) + \</span>
  96                                          (cl)-&gt;n_fnotifiers + \
  97                                          (cl)-&gt;n_inotifiers)
  98 
  99 typedef union {
 100   GClosure closure;
 101   volatile gint vint;
 102 } ClosureInt;
 103 
 104 #define CHANGE_FIELD(_closure, _field, _OP, _value, _must_set, _SET_OLD, _SET_NEW)      \
 105 G_STMT_START {                                                                          \
<span class="line-modified"> 106   ClosureInt *cunion = (ClosureInt*) _closure;                                    \</span>
<span class="line-modified"> 107   gint new_int, old_int, success;                                                 \</span>
<span class="line-modified"> 108   do                                                                        \</span>
<span class="line-modified"> 109     {                                                                       \</span>
<span class="line-modified"> 110       ClosureInt tmp;                                                       \</span>
<span class="line-modified"> 111       tmp.vint = old_int = cunion-&gt;vint;                                    \</span>
 112       _SET_OLD tmp.closure._field;                                                      \
<span class="line-modified"> 113       tmp.closure._field _OP _value;                                          \</span>
 114       _SET_NEW tmp.closure._field;                                                      \
<span class="line-modified"> 115       new_int = tmp.vint;                                                   \</span>
 116       success = g_atomic_int_compare_and_exchange (&amp;cunion-&gt;vint, old_int, new_int);    \
<span class="line-modified"> 117     }                                                                       \</span>
 118   while (!success &amp;&amp; _must_set);                                                        \
 119 } G_STMT_END
 120 
 121 #define SWAP(_closure, _field, _value, _oldv)   CHANGE_FIELD (_closure, _field, =, _value, TRUE, *(_oldv) =,     (void) )
 122 #define SET(_closure, _field, _value)           CHANGE_FIELD (_closure, _field, =, _value, TRUE,     (void),     (void) )
 123 #define INC(_closure, _field)                   CHANGE_FIELD (_closure, _field, +=,     1, TRUE,     (void),     (void) )
 124 #define INC_ASSIGN(_closure, _field, _newv)     CHANGE_FIELD (_closure, _field, +=,     1, TRUE,     (void), *(_newv) = )
 125 #define DEC(_closure, _field)                   CHANGE_FIELD (_closure, _field, -=,     1, TRUE,     (void),     (void) )
 126 #define DEC_ASSIGN(_closure, _field, _newv)     CHANGE_FIELD (_closure, _field, -=,     1, TRUE,     (void), *(_newv) = )
 127 
 128 #if 0   /* for non-thread-safe closures */
 129 #define SWAP(cl,f,v,o)     (void) (*(o) = cl-&gt;f, cl-&gt;f = v)
 130 #define SET(cl,f,v)        (void) (cl-&gt;f = v)
 131 #define INC(cl,f)          (void) (cl-&gt;f += 1)
 132 #define INC_ASSIGN(cl,f,n) (void) (cl-&gt;f += 1, *(n) = cl-&gt;f)
 133 #define DEC(cl,f)          (void) (cl-&gt;f -= 1)
 134 #define DEC_ASSIGN(cl,f,n) (void) (cl-&gt;f -= 1, *(n) = cl-&gt;f)
 135 #endif
 136 
 137 enum {
</pre>
<hr />
<pre>
 173  * MyClosure *my_closure_new (gpointer data)
 174  * {
 175  *   GClosure *closure;
 176  *   MyClosure *my_closure;
 177  *
 178  *   closure = g_closure_new_simple (sizeof (MyClosure), data);
 179  *   my_closure = (MyClosure *) closure;
 180  *
 181  *   // initialize extra data here
 182  *
 183  *   g_closure_add_finalize_notifier (closure, notify_data,
 184  *                                    my_closure_finalize);
 185  *   return my_closure;
 186  * }
 187  * ]|
 188  *
 189  * Returns: (transfer none): a floating reference to a new #GClosure
 190  */
 191 GClosure*
 192 g_closure_new_simple (guint           sizeof_closure,
<span class="line-modified"> 193           gpointer        data)</span>
 194 {
 195   GClosure *closure;
 196   gint private_size;
 197   gchar *allocated;
 198 
 199   g_return_val_if_fail (sizeof_closure &gt;= sizeof (GClosure), NULL);
 200 
 201   private_size = sizeof (GRealClosure) - sizeof (GClosure);
 202 
 203 #ifdef ENABLE_VALGRIND
 204   /* See comments in gtype.c about what&#39;s going on here... */
 205   if (RUNNING_ON_VALGRIND)
 206     {
 207       private_size += sizeof (gpointer);
 208 
 209       allocated = g_malloc0 (private_size + sizeof_closure + sizeof (gpointer));
 210 #ifdef GSTREAMER_LITE
 211       if (allocated == NULL)
 212         return NULL;
 213 #endif // GSTREAMER_LITE
</pre>
<hr />
<pre>
 219     }
 220   else
 221 #endif
 222     allocated = g_malloc0 (private_size + sizeof_closure);
 223 #ifdef GSTREAMER_LITE
 224     if (allocated == NULL)
 225       return NULL;
 226 #endif // GSTREAMER_LITE
 227 
 228   closure = (GClosure *) (allocated + private_size);
 229 
 230   SET (closure, ref_count, 1);
 231   SET (closure, floating, TRUE);
 232   closure-&gt;data = data;
 233 
 234   return closure;
 235 }
 236 
 237 static inline void
 238 closure_invoke_notifiers (GClosure *closure,
<span class="line-modified"> 239         guint     notify_type)</span>
 240 {
 241   /* notifier layout:
 242    *     n_guards    n_guards     n_fnotif.  n_inotifiers
 243    * -&gt;[[pre_guards][post_guards][fnotifiers][inotifiers]]
 244    *
 245    * CLOSURE_N_MFUNCS(cl)    = n_guards + n_guards;
 246    * CLOSURE_N_NOTIFIERS(cl) = CLOSURE_N_MFUNCS(cl) + n_fnotifiers + n_inotifiers
 247    *
 248    * constrains/catches:
 249    * - closure-&gt;notifiers may be reloacted during callback
 250    * - closure-&gt;n_fnotifiers and closure-&gt;n_inotifiers may change during callback
 251    * - i.e. callbacks can be removed/added during invocation
 252    * - must prepare for callback removal during FNOTIFY and INOTIFY (done via -&gt;marshal= &amp; -&gt;data=)
 253    * - must distinguish (-&gt;marshal= &amp; -&gt;data=) for INOTIFY vs. FNOTIFY (via -&gt;in_inotify)
 254    * + closure-&gt;n_guards is const during PRE_NOTIFY &amp; POST_NOTIFY
 255    * + none of the callbacks can cause recursion
 256    * + closure-&gt;n_inotifiers is const 0 during FNOTIFY
 257    */
 258   switch (notify_type)
 259     {
 260       GClosureNotifyData *ndata;
 261       guint i, offs;
 262     case FNOTIFY:
 263       while (closure-&gt;n_fnotifiers)
<span class="line-modified"> 264   {</span>
 265           guint n;
<span class="line-modified"> 266     DEC_ASSIGN (closure, n_fnotifiers, &amp;n);</span>
 267 
<span class="line-modified"> 268     ndata = closure-&gt;notifiers + CLOSURE_N_MFUNCS (closure) + n;</span>
<span class="line-modified"> 269     closure-&gt;marshal = (GClosureMarshal) ndata-&gt;notify;</span>
<span class="line-modified"> 270     closure-&gt;data = ndata-&gt;data;</span>
<span class="line-modified"> 271     ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified"> 272   }</span>
 273       closure-&gt;marshal = NULL;
 274       closure-&gt;data = NULL;
 275       break;
 276     case INOTIFY:
 277       SET (closure, in_inotify, TRUE);
 278       while (closure-&gt;n_inotifiers)
<span class="line-modified"> 279   {</span>
 280           guint n;
 281           DEC_ASSIGN (closure, n_inotifiers, &amp;n);
 282 
<span class="line-modified"> 283     ndata = closure-&gt;notifiers + CLOSURE_N_MFUNCS (closure) + closure-&gt;n_fnotifiers + n;</span>
<span class="line-modified"> 284     closure-&gt;marshal = (GClosureMarshal) ndata-&gt;notify;</span>
<span class="line-modified"> 285     closure-&gt;data = ndata-&gt;data;</span>
<span class="line-modified"> 286     ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified"> 287   }</span>
 288       closure-&gt;marshal = NULL;
 289       closure-&gt;data = NULL;
 290       SET (closure, in_inotify, FALSE);
 291       break;
 292     case PRE_NOTIFY:
 293       i = closure-&gt;n_guards;
 294       offs = 0;
 295       while (i--)
<span class="line-modified"> 296   {</span>
<span class="line-modified"> 297     ndata = closure-&gt;notifiers + offs + i;</span>
<span class="line-modified"> 298     ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified"> 299   }</span>
 300       break;
 301     case POST_NOTIFY:
 302       i = closure-&gt;n_guards;
 303       offs = i;
 304       while (i--)
<span class="line-modified"> 305   {</span>
<span class="line-modified"> 306     ndata = closure-&gt;notifiers + offs + i;</span>
<span class="line-modified"> 307     ndata-&gt;notify (ndata-&gt;data, closure);</span>
<span class="line-modified"> 308   }</span>
 309       break;
 310     }
 311 }
 312 
 313 static void
 314 g_closure_set_meta_va_marshal (GClosure       *closure,
<span class="line-modified"> 315              GVaClosureMarshal va_meta_marshal)</span>
 316 {
 317   GRealClosure *real_closure;
 318 
 319   g_return_if_fail (closure != NULL);
 320   g_return_if_fail (va_meta_marshal != NULL);
 321   g_return_if_fail (closure-&gt;is_invalid == FALSE);
 322   g_return_if_fail (closure-&gt;in_marshal == FALSE);
 323 
 324   real_closure = G_REAL_CLOSURE (closure);
 325 
 326   g_return_if_fail (real_closure-&gt;meta_marshal != NULL);
 327 
 328   real_closure-&gt;va_meta_marshal = va_meta_marshal;
 329 }
 330 
 331 /**
 332  * g_closure_set_meta_marshal: (skip)
 333  * @closure: a #GClosure
 334  * @marshal_data: (closure meta_marshal): context-dependent data to pass
 335  *  to @meta_marshal
 336  * @meta_marshal: a #GClosureMarshal function
 337  *
 338  * Sets the meta marshaller of @closure.  A meta marshaller wraps
 339  * @closure-&gt;marshal and modifies the way it is called in some
 340  * fashion. The most common use of this facility is for C callbacks.
 341  * The same marshallers (generated by [glib-genmarshal][glib-genmarshal]),
 342  * are used everywhere, but the way that we get the callback function
 343  * differs. In most cases we want to use @closure-&gt;callback, but in
 344  * other cases we want to use some different technique to retrieve the
 345  * callback function.
 346  *
 347  * For example, class closures for signals (see
 348  * g_signal_type_cclosure_new()) retrieve the callback function from a
 349  * fixed offset in the class structure.  The meta marshaller retrieves
 350  * the right callback and passes it to the marshaller as the
 351  * @marshal_data argument.
 352  */
 353 void
 354 g_closure_set_meta_marshal (GClosure       *closure,
<span class="line-modified"> 355           gpointer        marshal_data,</span>
<span class="line-modified"> 356           GClosureMarshal meta_marshal)</span>
 357 {
 358   GRealClosure *real_closure;
 359 
 360   g_return_if_fail (closure != NULL);
 361   g_return_if_fail (meta_marshal != NULL);
 362   g_return_if_fail (closure-&gt;is_invalid == FALSE);
 363   g_return_if_fail (closure-&gt;in_marshal == FALSE);
 364 
 365   real_closure = G_REAL_CLOSURE (closure);
 366 
 367   g_return_if_fail (real_closure-&gt;meta_marshal == NULL);
 368 
 369   real_closure-&gt;meta_marshal = meta_marshal;
 370   real_closure-&gt;meta_marshal_data = marshal_data;
 371 }
 372 
 373 /**
 374  * g_closure_add_marshal_guards: (skip)
 375  * @closure: a #GClosure
 376  * @pre_marshal_data: (closure pre_marshal_notify): data to pass
 377  *  to @pre_marshal_notify
 378  * @pre_marshal_notify: a function to call before the closure callback
 379  * @post_marshal_data: (closure post_marshal_notify): data to pass
 380  *  to @post_marshal_notify
 381  * @post_marshal_notify: a function to call after the closure callback
 382  *
 383  * Adds a pair of notifiers which get invoked before and after the
 384  * closure callback, respectively. This is typically used to protect
 385  * the extra arguments for the duration of the callback. See
 386  * g_object_watch_closure() for an example of marshal guards.
 387  */
 388 void
 389 g_closure_add_marshal_guards (GClosure      *closure,
<span class="line-modified"> 390             gpointer       pre_marshal_data,</span>
<span class="line-modified"> 391             GClosureNotify pre_marshal_notify,</span>
<span class="line-modified"> 392             gpointer       post_marshal_data,</span>
<span class="line-modified"> 393             GClosureNotify post_marshal_notify)</span>
 394 {
 395   guint i;
 396 
 397   g_return_if_fail (closure != NULL);
 398   g_return_if_fail (pre_marshal_notify != NULL);
 399   g_return_if_fail (post_marshal_notify != NULL);
 400   g_return_if_fail (closure-&gt;is_invalid == FALSE);
 401   g_return_if_fail (closure-&gt;in_marshal == FALSE);
 402   g_return_if_fail (closure-&gt;n_guards &lt; CLOSURE_MAX_N_GUARDS);
 403 
 404   closure-&gt;notifiers = g_renew (GClosureNotifyData, closure-&gt;notifiers, CLOSURE_N_NOTIFIERS (closure) + 2);
 405   if (closure-&gt;n_inotifiers)
 406     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified"> 407       closure-&gt;n_fnotifiers +</span>
<span class="line-modified"> 408       closure-&gt;n_inotifiers + 1)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified"> 409                     closure-&gt;n_fnotifiers + 0)];</span>
 410   if (closure-&gt;n_inotifiers &gt; 1)
 411     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified"> 412       closure-&gt;n_fnotifiers +</span>
<span class="line-modified"> 413       closure-&gt;n_inotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified"> 414                       closure-&gt;n_fnotifiers + 1)];</span>
 415   if (closure-&gt;n_fnotifiers)
 416     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified"> 417       closure-&gt;n_fnotifiers + 1)] = closure-&gt;notifiers[CLOSURE_N_MFUNCS (closure) + 0];</span>
 418   if (closure-&gt;n_fnotifiers &gt; 1)
 419     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified"> 420       closure-&gt;n_fnotifiers)] = closure-&gt;notifiers[CLOSURE_N_MFUNCS (closure) + 1];</span>
 421   if (closure-&gt;n_guards)
 422     closure-&gt;notifiers[(closure-&gt;n_guards +
<span class="line-modified"> 423       closure-&gt;n_guards + 1)] = closure-&gt;notifiers[closure-&gt;n_guards];</span>
 424   i = closure-&gt;n_guards;
 425   closure-&gt;notifiers[i].data = pre_marshal_data;
 426   closure-&gt;notifiers[i].notify = pre_marshal_notify;
 427   closure-&gt;notifiers[i + 1].data = post_marshal_data;
 428   closure-&gt;notifiers[i + 1].notify = post_marshal_notify;
 429   INC (closure, n_guards);
 430 }
 431 
 432 /**
 433  * g_closure_add_finalize_notifier: (skip)
 434  * @closure: a #GClosure
 435  * @notify_data: (closure notify_func): data to pass to @notify_func
 436  * @notify_func: the callback function to register
 437  *
 438  * Registers a finalization notifier which will be called when the
 439  * reference count of @closure goes down to 0. Multiple finalization
 440  * notifiers on a single closure are invoked in unspecified order. If
 441  * a single call to g_closure_unref() results in the closure being
 442  * both invalidated and finalized, then the invalidate notifiers will
 443  * be run before the finalize notifiers.
 444  */
 445 void
 446 g_closure_add_finalize_notifier (GClosure      *closure,
<span class="line-modified"> 447          gpointer       notify_data,</span>
<span class="line-modified"> 448          GClosureNotify notify_func)</span>
 449 {
 450   guint i;
 451 
 452   g_return_if_fail (closure != NULL);
 453   g_return_if_fail (notify_func != NULL);
 454   g_return_if_fail (closure-&gt;n_fnotifiers &lt; CLOSURE_MAX_N_FNOTIFIERS);
 455 
 456   closure-&gt;notifiers = g_renew (GClosureNotifyData, closure-&gt;notifiers, CLOSURE_N_NOTIFIERS (closure) + 1);
 457   if (closure-&gt;n_inotifiers)
 458     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +
<span class="line-modified"> 459       closure-&gt;n_fnotifiers +</span>
<span class="line-modified"> 460       closure-&gt;n_inotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified"> 461                       closure-&gt;n_fnotifiers + 0)];</span>
 462   i = CLOSURE_N_MFUNCS (closure) + closure-&gt;n_fnotifiers;
 463   closure-&gt;notifiers[i].data = notify_data;
 464   closure-&gt;notifiers[i].notify = notify_func;
 465   INC (closure, n_fnotifiers);
 466 }
 467 
 468 /**
 469  * g_closure_add_invalidate_notifier: (skip)
 470  * @closure: a #GClosure
 471  * @notify_data: (closure notify_func): data to pass to @notify_func
 472  * @notify_func: the callback function to register
 473  *
 474  * Registers an invalidation notifier which will be called when the
 475  * @closure is invalidated with g_closure_invalidate(). Invalidation
 476  * notifiers are invoked before finalization notifiers, in an
 477  * unspecified order.
 478  */
 479 void
 480 g_closure_add_invalidate_notifier (GClosure      *closure,
<span class="line-modified"> 481            gpointer       notify_data,</span>
<span class="line-modified"> 482            GClosureNotify notify_func)</span>
 483 {
 484   guint i;
 485 
 486   g_return_if_fail (closure != NULL);
 487   g_return_if_fail (notify_func != NULL);
 488   g_return_if_fail (closure-&gt;is_invalid == FALSE);
 489   g_return_if_fail (closure-&gt;n_inotifiers &lt; CLOSURE_MAX_N_INOTIFIERS);
 490 
 491   closure-&gt;notifiers = g_renew (GClosureNotifyData, closure-&gt;notifiers, CLOSURE_N_NOTIFIERS (closure) + 1);
 492   i = CLOSURE_N_MFUNCS (closure) + closure-&gt;n_fnotifiers + closure-&gt;n_inotifiers;
 493   closure-&gt;notifiers[i].data = notify_data;
 494   closure-&gt;notifiers[i].notify = notify_func;
 495   INC (closure, n_inotifiers);
 496 }
 497 
 498 static inline gboolean
 499 closure_try_remove_inotify (GClosure       *closure,
<span class="line-modified"> 500           gpointer       notify_data,</span>
<span class="line-modified"> 501           GClosureNotify notify_func)</span>
 502 {
 503   GClosureNotifyData *ndata, *nlast;
 504 
 505   nlast = closure-&gt;notifiers + CLOSURE_N_NOTIFIERS (closure) - 1;
 506   for (ndata = nlast + 1 - closure-&gt;n_inotifiers; ndata &lt;= nlast; ndata++)
 507     if (ndata-&gt;notify == notify_func &amp;&amp; ndata-&gt;data == notify_data)
 508       {
<span class="line-modified"> 509   DEC (closure, n_inotifiers);</span>
<span class="line-modified"> 510   if (ndata &lt; nlast)</span>
<span class="line-modified"> 511     *ndata = *nlast;</span>
 512 
<span class="line-modified"> 513   return TRUE;</span>
 514       }
 515   return FALSE;
 516 }
 517 
 518 static inline gboolean
 519 closure_try_remove_fnotify (GClosure       *closure,
<span class="line-modified"> 520           gpointer       notify_data,</span>
<span class="line-modified"> 521           GClosureNotify notify_func)</span>
 522 {
 523   GClosureNotifyData *ndata, *nlast;
 524 
 525   nlast = closure-&gt;notifiers + CLOSURE_N_NOTIFIERS (closure) - closure-&gt;n_inotifiers - 1;
 526   for (ndata = nlast + 1 - closure-&gt;n_fnotifiers; ndata &lt;= nlast; ndata++)
 527     if (ndata-&gt;notify == notify_func &amp;&amp; ndata-&gt;data == notify_data)
 528       {
<span class="line-modified"> 529   DEC (closure, n_fnotifiers);</span>
<span class="line-modified"> 530   if (ndata &lt; nlast)</span>
<span class="line-modified"> 531     *ndata = *nlast;</span>
<span class="line-modified"> 532   if (closure-&gt;n_inotifiers)</span>
<span class="line-modified"> 533     closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified"> 534             closure-&gt;n_fnotifiers)] = closure-&gt;notifiers[(CLOSURE_N_MFUNCS (closure) +</span>
<span class="line-modified"> 535                       closure-&gt;n_fnotifiers +</span>
<span class="line-modified"> 536                       closure-&gt;n_inotifiers)];</span>
<span class="line-modified"> 537   return TRUE;</span>
 538       }
 539   return FALSE;
 540 }
 541 
 542 /**
 543  * g_closure_ref:
 544  * @closure: #GClosure to increment the reference count on
 545  *
 546  * Increments the reference count on a closure to force it staying
 547  * alive while the caller holds a pointer to it.
 548  *
 549  * Returns: (transfer none): The @closure passed in, for convenience
 550  */
 551 GClosure*
 552 g_closure_ref (GClosure *closure)
 553 {
 554   guint new_ref_count;
 555   g_return_val_if_fail (closure != NULL, NULL);
 556   g_return_val_if_fail (closure-&gt;ref_count &gt; 0, NULL);
 557   g_return_val_if_fail (closure-&gt;ref_count &lt; CLOSURE_MAX_REF_COUNT, NULL);
 558 
 559   INC_ASSIGN (closure, ref_count, &amp;new_ref_count);
 560   g_return_val_if_fail (new_ref_count &gt; 1, NULL);
 561 
 562   return closure;
 563 }
 564 
 565 /**
 566  * g_closure_invalidate:
<span class="line-modified"> 567  * @closure: #GClosure to invalidate</span>
 568  *
 569  * Sets a flag on the closure to indicate that its calling
 570  * environment has become invalid, and thus causes any future
 571  * invocations of g_closure_invoke() on this @closure to be
 572  * ignored. Also, invalidation notifiers installed on the closure will
 573  * be called at this point. Note that unless you are holding a
 574  * reference to the closure yourself, the invalidation notifiers may
 575  * unref the closure and cause it to be destroyed, so if you need to
 576  * access the closure after calling g_closure_invalidate(), make sure
 577  * that you&#39;ve previously called g_closure_ref().
 578  *
 579  * Note that g_closure_invalidate() will also be called when the
 580  * reference count of a closure drops to zero (unless it has already
 581  * been invalidated before).
 582  */
 583 void
 584 g_closure_invalidate (GClosure *closure)
 585 {
 586   g_return_if_fail (closure != NULL);
 587 
</pre>
<hr />
<pre>
 726       SWAP (closure, floating, FALSE, &amp;was_floating);
 727       /* unref floating flag only once */
 728       if (was_floating)
 729         g_closure_unref (closure);
 730     }
 731 }
 732 
 733 /**
 734  * g_closure_remove_invalidate_notifier: (skip)
 735  * @closure: a #GClosure
 736  * @notify_data: data which was passed to g_closure_add_invalidate_notifier()
 737  *               when registering @notify_func
 738  * @notify_func: the callback function to remove
 739  *
 740  * Removes an invalidation notifier.
 741  *
 742  * Notice that notifiers are automatically removed after they are run.
 743  */
 744 void
 745 g_closure_remove_invalidate_notifier (GClosure      *closure,
<span class="line-modified"> 746               gpointer       notify_data,</span>
<span class="line-modified"> 747               GClosureNotify notify_func)</span>
 748 {
 749   g_return_if_fail (closure != NULL);
 750   g_return_if_fail (notify_func != NULL);
 751 
 752   if (closure-&gt;is_invalid &amp;&amp; closure-&gt;in_inotify &amp;&amp; /* account removal of notify_func() while it&#39;s called */
 753       ((gpointer) closure-&gt;marshal) == ((gpointer) notify_func) &amp;&amp;
 754       closure-&gt;data == notify_data)
 755     closure-&gt;marshal = NULL;
 756   else if (!closure_try_remove_inotify (closure, notify_data, notify_func))
 757     g_warning (G_STRLOC &quot;: unable to remove uninstalled invalidation notifier: %p (%p)&quot;,
<span class="line-modified"> 758          notify_func, notify_data);</span>
 759 }
 760 
 761 /**
 762  * g_closure_remove_finalize_notifier: (skip)
 763  * @closure: a #GClosure
 764  * @notify_data: data which was passed to g_closure_add_finalize_notifier()
 765  *  when registering @notify_func
 766  * @notify_func: the callback function to remove
 767  *
 768  * Removes a finalization notifier.
 769  *
 770  * Notice that notifiers are automatically removed after they are run.
 771  */
 772 void
 773 g_closure_remove_finalize_notifier (GClosure      *closure,
<span class="line-modified"> 774             gpointer       notify_data,</span>
<span class="line-modified"> 775             GClosureNotify notify_func)</span>
 776 {
 777   g_return_if_fail (closure != NULL);
 778   g_return_if_fail (notify_func != NULL);
 779 
 780   if (closure-&gt;is_invalid &amp;&amp; !closure-&gt;in_inotify &amp;&amp; /* account removal of notify_func() while it&#39;s called */
 781       ((gpointer) closure-&gt;marshal) == ((gpointer) notify_func) &amp;&amp;
 782       closure-&gt;data == notify_data)
 783     closure-&gt;marshal = NULL;
 784   else if (!closure_try_remove_fnotify (closure, notify_data, notify_func))
 785     g_warning (G_STRLOC &quot;: unable to remove uninstalled finalization notifier: %p (%p)&quot;,
 786                notify_func, notify_data);
 787 }
 788 
 789 /**
 790  * g_closure_invoke:
 791  * @closure: a #GClosure
 792  * @return_value: (optional) (out): a #GValue to store the return
 793  *                value. May be %NULL if the callback of @closure
 794  *                doesn&#39;t return a value.
 795  * @n_param_values: the length of the @param_values array
 796  * @param_values: (array length=n_param_values): an array of
 797  *                #GValues holding the arguments on which to
 798  *                invoke the callback of @closure
 799  * @invocation_hint: (nullable): a context-dependent invocation hint
 800  *
 801  * Invokes the closure, i.e. executes the callback represented by the @closure.
 802  */
 803 void
 804 g_closure_invoke (GClosure       *closure,
<span class="line-modified"> 805       GValue /*out*/ *return_value,</span>
<span class="line-modified"> 806       guint           n_param_values,</span>
<span class="line-modified"> 807       const GValue   *param_values,</span>
<span class="line-modified"> 808       gpointer        invocation_hint)</span>
 809 {
 810   GRealClosure *real_closure;
 811 
 812   g_return_if_fail (closure != NULL);
 813 
 814   real_closure = G_REAL_CLOSURE (closure);
 815 
 816   g_closure_ref (closure);      /* preserve floating flag */
 817   if (!closure-&gt;is_invalid)
 818     {
 819       GClosureMarshal marshal;
 820       gpointer marshal_data;
 821       gboolean in_marshal = closure-&gt;in_marshal;
 822 
 823       g_return_if_fail (closure-&gt;marshal || real_closure-&gt;meta_marshal);
 824 
 825       SET (closure, in_marshal, TRUE);
 826       if (real_closure-&gt;meta_marshal)
<span class="line-modified"> 827   {</span>
<span class="line-modified"> 828     marshal_data = real_closure-&gt;meta_marshal_data;</span>
<span class="line-modified"> 829     marshal = real_closure-&gt;meta_marshal;</span>
<span class="line-modified"> 830   }</span>
 831       else
<span class="line-modified"> 832   {</span>
<span class="line-modified"> 833     marshal_data = NULL;</span>
<span class="line-modified"> 834     marshal = closure-&gt;marshal;</span>
<span class="line-modified"> 835   }</span>
 836       if (!in_marshal)
<span class="line-modified"> 837   closure_invoke_notifiers (closure, PRE_NOTIFY);</span>
 838       marshal (closure,
<span class="line-modified"> 839          return_value,</span>
<span class="line-modified"> 840          n_param_values, param_values,</span>
<span class="line-modified"> 841          invocation_hint,</span>
<span class="line-modified"> 842          marshal_data);</span>
 843       if (!in_marshal)
<span class="line-modified"> 844   closure_invoke_notifiers (closure, POST_NOTIFY);</span>
 845       SET (closure, in_marshal, in_marshal);
 846     }
 847   g_closure_unref (closure);
 848 }
 849 
 850 gboolean
 851 _g_closure_supports_invoke_va (GClosure       *closure)
 852 {
 853   GRealClosure *real_closure;
 854 
 855   g_return_val_if_fail (closure != NULL, FALSE);
 856 
 857   real_closure = G_REAL_CLOSURE (closure);
 858 
 859   return
 860     real_closure-&gt;va_marshal != NULL &amp;&amp;
 861     (real_closure-&gt;meta_marshal == NULL ||
 862      real_closure-&gt;va_meta_marshal != NULL);
 863 }
 864 
 865 void
 866 _g_closure_invoke_va (GClosure       *closure,
<span class="line-modified"> 867           GValue /*out*/ *return_value,</span>
<span class="line-modified"> 868           gpointer        instance,</span>
<span class="line-modified"> 869           va_list         args,</span>
<span class="line-modified"> 870           int             n_params,</span>
<span class="line-modified"> 871           GType          *param_types)</span>
 872 {
 873   GRealClosure *real_closure;
 874 
 875   g_return_if_fail (closure != NULL);
 876 
 877   real_closure = G_REAL_CLOSURE (closure);
 878 
 879   g_closure_ref (closure);      /* preserve floating flag */
 880   if (!closure-&gt;is_invalid)
 881     {
 882       GVaClosureMarshal marshal;
 883       gpointer marshal_data;
 884       gboolean in_marshal = closure-&gt;in_marshal;
 885 
 886       g_return_if_fail (closure-&gt;marshal || real_closure-&gt;meta_marshal);
 887 
 888       SET (closure, in_marshal, TRUE);
 889       if (real_closure-&gt;va_meta_marshal)
<span class="line-modified"> 890   {</span>
<span class="line-modified"> 891     marshal_data = real_closure-&gt;meta_marshal_data;</span>
<span class="line-modified"> 892     marshal = real_closure-&gt;va_meta_marshal;</span>
<span class="line-modified"> 893   }</span>
 894       else
<span class="line-modified"> 895   {</span>
<span class="line-modified"> 896     marshal_data = NULL;</span>
<span class="line-modified"> 897     marshal = real_closure-&gt;va_marshal;</span>
<span class="line-modified"> 898   }</span>
 899       if (!in_marshal)
<span class="line-modified"> 900   closure_invoke_notifiers (closure, PRE_NOTIFY);</span>
 901       marshal (closure,
<span class="line-modified"> 902          return_value,</span>
<span class="line-modified"> 903          instance, args,</span>
<span class="line-modified"> 904          marshal_data,</span>
<span class="line-modified"> 905          n_params, param_types);</span>
 906       if (!in_marshal)
<span class="line-modified"> 907   closure_invoke_notifiers (closure, POST_NOTIFY);</span>
 908       SET (closure, in_marshal, in_marshal);
 909     }
 910   g_closure_unref (closure);
 911 }
 912 
 913 
 914 /**
 915  * g_closure_set_marshal: (skip)
 916  * @closure: a #GClosure
 917  * @marshal: a #GClosureMarshal function
 918  *
 919  * Sets the marshaller of @closure. The `marshal_data`
 920  * of @marshal provides a way for a meta marshaller to provide additional
 921  * information to the marshaller. (See g_closure_set_meta_marshal().) For
 922  * GObject&#39;s C predefined marshallers (the g_cclosure_marshal_*()
 923  * functions), what it provides is a callback function to use instead of
 924  * @closure-&gt;callback.
 925  */
 926 void
 927 g_closure_set_marshal (GClosure       *closure,
<span class="line-modified"> 928            GClosureMarshal marshal)</span>
 929 {
 930   g_return_if_fail (closure != NULL);
 931   g_return_if_fail (marshal != NULL);
 932 
 933   if (closure-&gt;marshal &amp;&amp; closure-&gt;marshal != marshal)
 934     g_warning (&quot;attempt to override closure-&gt;marshal (%p) with new marshal (%p)&quot;,
<span class="line-modified"> 935          closure-&gt;marshal, marshal);</span>
 936   else
 937     closure-&gt;marshal = marshal;
 938 }
 939 
 940 void
 941 _g_closure_set_va_marshal (GClosure       *closure,
<span class="line-modified"> 942          GVaClosureMarshal marshal)</span>
 943 {
 944   GRealClosure *real_closure;
 945 
 946   g_return_if_fail (closure != NULL);
 947   g_return_if_fail (marshal != NULL);
 948 
 949   real_closure = G_REAL_CLOSURE (closure);
 950 
 951   if (real_closure-&gt;va_marshal &amp;&amp; real_closure-&gt;va_marshal != marshal)
 952     g_warning (&quot;attempt to override closure-&gt;va_marshal (%p) with new marshal (%p)&quot;,
<span class="line-modified"> 953          real_closure-&gt;va_marshal, marshal);</span>
 954   else
 955     real_closure-&gt;va_marshal = marshal;
 956 }
 957 
 958 /**
 959  * g_cclosure_new: (skip)
 960  * @callback_func: the function to invoke
 961  * @user_data: (closure callback_func): user data to pass to @callback_func
 962  * @destroy_data: destroy notify to be called when @user_data is no longer used
 963  *
 964  * Creates a new closure which invokes @callback_func with @user_data as
 965  * the last parameter.
 966  *
<span class="line-added"> 967  * @destroy_data will be called as a finalize notifier on the #GClosure.</span>
<span class="line-added"> 968  *</span>
 969  * Returns: (transfer none): a floating reference to a new #GCClosure
 970  */
 971 GClosure*
 972 g_cclosure_new (GCallback      callback_func,
<span class="line-modified"> 973     gpointer       user_data,</span>
<span class="line-modified"> 974     GClosureNotify destroy_data)</span>
 975 {
 976   GClosure *closure;
 977 
 978   g_return_val_if_fail (callback_func != NULL, NULL);
 979 
 980   closure = g_closure_new_simple (sizeof (GCClosure), user_data);
 981 #ifdef GSTREAMER_LITE
 982   if (closure == NULL)
 983     return NULL;
 984 #endif // GSTREAMER_LITE
 985   if (destroy_data)
 986     g_closure_add_finalize_notifier (closure, user_data, destroy_data);
 987   ((GCClosure*) closure)-&gt;callback = (gpointer) callback_func;
 988 
 989   return closure;
 990 }
 991 
 992 /**
 993  * g_cclosure_new_swap: (skip)
 994  * @callback_func: the function to invoke
 995  * @user_data: (closure callback_func): user data to pass to @callback_func
 996  * @destroy_data: destroy notify to be called when @user_data is no longer used
 997  *
 998  * Creates a new closure which invokes @callback_func with @user_data as
 999  * the first parameter.
1000  *
<span class="line-added">1001  * @destroy_data will be called as a finalize notifier on the #GClosure.</span>
<span class="line-added">1002  *</span>
1003  * Returns: (transfer none): a floating reference to a new #GCClosure
1004  */
1005 GClosure*
1006 g_cclosure_new_swap (GCallback      callback_func,
<span class="line-modified">1007          gpointer       user_data,</span>
<span class="line-modified">1008          GClosureNotify destroy_data)</span>
1009 {
1010   GClosure *closure;
1011 
1012   g_return_val_if_fail (callback_func != NULL, NULL);
1013 
1014   closure = g_closure_new_simple (sizeof (GCClosure), user_data);
1015 #ifdef GSTREAMER_LITE
1016   if (closure == NULL)
1017     return NULL;
1018 #endif // GSTREAMER_LITE
1019   if (destroy_data)
1020     g_closure_add_finalize_notifier (closure, user_data, destroy_data);
1021   ((GCClosure*) closure)-&gt;callback = (gpointer) callback_func;
1022   SET (closure, derivative_flag, TRUE);
1023 
1024   return closure;
1025 }
1026 
1027 static void
1028 g_type_class_meta_marshal (GClosure       *closure,
<span class="line-modified">1029          GValue /*out*/ *return_value,</span>
<span class="line-modified">1030          guint           n_param_values,</span>
<span class="line-modified">1031          const GValue   *param_values,</span>
<span class="line-modified">1032          gpointer        invocation_hint,</span>
<span class="line-modified">1033          gpointer        marshal_data)</span>
1034 {
1035   GTypeClass *class;
1036   gpointer callback;
1037   /* GType itype = (GType) closure-&gt;data; */
1038   guint offset = GPOINTER_TO_UINT (marshal_data);
1039 
1040   class = G_TYPE_INSTANCE_GET_CLASS (g_value_peek_pointer (param_values + 0), itype, GTypeClass);
1041   callback = G_STRUCT_MEMBER (gpointer, class, offset);
1042   if (callback)
1043     closure-&gt;marshal (closure,
<span class="line-modified">1044           return_value,</span>
<span class="line-modified">1045           n_param_values, param_values,</span>
<span class="line-modified">1046           invocation_hint,</span>
<span class="line-modified">1047           callback);</span>
1048 }
1049 
1050 static void
1051 g_type_class_meta_marshalv (GClosure *closure,
<span class="line-modified">1052           GValue   *return_value,</span>
<span class="line-modified">1053           gpointer  instance,</span>
<span class="line-modified">1054           va_list   args,</span>
<span class="line-modified">1055           gpointer  marshal_data,</span>
<span class="line-modified">1056           int       n_params,</span>
<span class="line-modified">1057           GType    *param_types)</span>
1058 {
1059   GRealClosure *real_closure;
1060   GTypeClass *class;
1061   gpointer callback;
1062   /* GType itype = (GType) closure-&gt;data; */
1063   guint offset = GPOINTER_TO_UINT (marshal_data);
1064 
1065   real_closure = G_REAL_CLOSURE (closure);
1066 
1067   class = G_TYPE_INSTANCE_GET_CLASS (instance, itype, GTypeClass);
1068   callback = G_STRUCT_MEMBER (gpointer, class, offset);
1069   if (callback)
1070     real_closure-&gt;va_marshal (closure,
<span class="line-modified">1071             return_value,</span>
<span class="line-modified">1072             instance, args,</span>
<span class="line-modified">1073             callback,</span>
<span class="line-modified">1074             n_params,</span>
<span class="line-modified">1075             param_types);</span>
1076 }
1077 
1078 static void
1079 g_type_iface_meta_marshal (GClosure       *closure,
<span class="line-modified">1080          GValue /*out*/ *return_value,</span>
<span class="line-modified">1081          guint           n_param_values,</span>
<span class="line-modified">1082          const GValue   *param_values,</span>
<span class="line-modified">1083          gpointer        invocation_hint,</span>
<span class="line-modified">1084          gpointer        marshal_data)</span>
1085 {
1086   GTypeClass *class;
1087   gpointer callback;
1088   GType itype = (GType) closure-&gt;data;
1089   guint offset = GPOINTER_TO_UINT (marshal_data);
1090 
1091   class = G_TYPE_INSTANCE_GET_INTERFACE (g_value_peek_pointer (param_values + 0), itype, GTypeClass);
1092   callback = G_STRUCT_MEMBER (gpointer, class, offset);
1093   if (callback)
1094     closure-&gt;marshal (closure,
<span class="line-modified">1095           return_value,</span>
<span class="line-modified">1096           n_param_values, param_values,</span>
<span class="line-modified">1097           invocation_hint,</span>
<span class="line-modified">1098           callback);</span>
1099 }
1100 
1101 gboolean
1102 _g_closure_is_void (GClosure *closure,
<span class="line-modified">1103         gpointer instance)</span>
1104 {
1105   GRealClosure *real_closure;
1106   GTypeClass *class;
1107   gpointer callback;
1108   GType itype;
1109   guint offset;
1110 
1111   if (closure-&gt;is_invalid)
1112     return TRUE;
1113 
1114   real_closure = G_REAL_CLOSURE (closure);
1115 
1116   if (real_closure-&gt;meta_marshal == g_type_iface_meta_marshal)
1117     {
1118       itype = (GType) closure-&gt;data;
1119       offset = GPOINTER_TO_UINT (real_closure-&gt;meta_marshal_data);
1120 
1121       class = G_TYPE_INSTANCE_GET_INTERFACE (instance, itype, GTypeClass);
1122       callback = G_STRUCT_MEMBER (gpointer, class, offset);
1123       return callback == NULL;
1124     }
1125   else if (real_closure-&gt;meta_marshal == g_type_class_meta_marshal)
1126     {
1127       offset = GPOINTER_TO_UINT (real_closure-&gt;meta_marshal_data);
1128 
1129       class = G_TYPE_INSTANCE_GET_CLASS (instance, itype, GTypeClass);
1130       callback = G_STRUCT_MEMBER (gpointer, class, offset);
1131       return callback == NULL;
1132     }
1133 
1134   return FALSE;
1135 }
1136 
1137 static void
1138 g_type_iface_meta_marshalv (GClosure *closure,
<span class="line-modified">1139           GValue   *return_value,</span>
<span class="line-modified">1140           gpointer  instance,</span>
<span class="line-modified">1141           va_list   args,</span>
<span class="line-modified">1142           gpointer  marshal_data,</span>
<span class="line-modified">1143           int       n_params,</span>
<span class="line-modified">1144           GType    *param_types)</span>
1145 {
1146   GRealClosure *real_closure;
1147   GTypeClass *class;
1148   gpointer callback;
1149   GType itype = (GType) closure-&gt;data;
1150   guint offset = GPOINTER_TO_UINT (marshal_data);
1151 
1152   real_closure = G_REAL_CLOSURE (closure);
1153 
1154   class = G_TYPE_INSTANCE_GET_INTERFACE (instance, itype, GTypeClass);
1155   callback = G_STRUCT_MEMBER (gpointer, class, offset);
1156   if (callback)
1157     real_closure-&gt;va_marshal (closure,
<span class="line-modified">1158             return_value,</span>
<span class="line-modified">1159             instance, args,</span>
<span class="line-modified">1160             callback,</span>
<span class="line-modified">1161             n_params,</span>
<span class="line-modified">1162             param_types);</span>
1163 }
1164 
1165 /**
1166  * g_signal_type_cclosure_new:
1167  * @itype: the #GType identifier of an interface or classed type
1168  * @struct_offset: the offset of the member function of @itype&#39;s class
1169  *  structure which is to be invoked by the new closure
1170  *
1171  * Creates a new closure which invokes the function found at the offset
1172  * @struct_offset in the class structure of the interface or classed type
1173  * identified by @itype.
1174  *
1175  * Returns: (transfer none): a floating reference to a new #GCClosure
1176  */
1177 GClosure*
1178 g_signal_type_cclosure_new (GType    itype,
<span class="line-modified">1179           guint    struct_offset)</span>
1180 {
1181   GClosure *closure;
1182 
1183   g_return_val_if_fail (G_TYPE_IS_CLASSED (itype) || G_TYPE_IS_INTERFACE (itype), NULL);
1184   g_return_val_if_fail (struct_offset &gt;= sizeof (GTypeClass), NULL);
1185 
1186   closure = g_closure_new_simple (sizeof (GClosure), (gpointer) itype);
1187   if (G_TYPE_IS_INTERFACE (itype))
1188     {
1189       g_closure_set_meta_marshal (closure, GUINT_TO_POINTER (struct_offset), g_type_iface_meta_marshal);
1190       g_closure_set_meta_va_marshal (closure, g_type_iface_meta_marshalv);
1191     }
1192   else
1193     {
1194       g_closure_set_meta_marshal (closure, GUINT_TO_POINTER (struct_offset), g_type_class_meta_marshal);
1195       g_closure_set_meta_va_marshal (closure, g_type_class_meta_marshalv);
1196     }
1197   return closure;
1198 }
1199 
</pre>
<hr />
<pre>
1357     default:
1358       g_warning (&quot;value_from_ffi_type: Unsupported fundamental type: %s&quot;,
1359                 g_type_name (g_type_fundamental (G_VALUE_TYPE (gvalue))));
1360     }
1361 }
1362 
1363 typedef union {
1364   gpointer _gpointer;
1365   float _float;
1366   double _double;
1367   gint _gint;
1368   guint _guint;
1369   glong _glong;
1370   gulong _gulong;
1371   gint64 _gint64;
1372   guint64 _guint64;
1373 } va_arg_storage;
1374 
1375 static ffi_type *
1376 va_to_ffi_type (GType gtype,
<span class="line-modified">1377     va_list *va,</span>
<span class="line-modified">1378     va_arg_storage *storage)</span>
1379 {
1380   ffi_type *rettype = NULL;
1381   GType type = g_type_fundamental (gtype);
1382   g_assert (type != G_TYPE_INVALID);
1383 
1384   switch (type)
1385     {
1386     case G_TYPE_BOOLEAN:
1387     case G_TYPE_CHAR:
1388     case G_TYPE_INT:
1389     case G_TYPE_ENUM:
1390       rettype = &amp;ffi_type_sint;
1391       storage-&gt;_gint = va_arg (*va, gint);
1392       break;
1393     case G_TYPE_UCHAR:
1394     case G_TYPE_UINT:
1395     case G_TYPE_FLAGS:
1396       rettype = &amp;ffi_type_uint;
1397       storage-&gt;_guint = va_arg (*va, guint);
1398       break;
</pre>
<hr />
<pre>
1545  * @return_value: (nullable): a #GValue to store the return
1546  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
1547  *  value.
1548  * @instance: (type GObject.TypeInstance): the instance on which the closure is
1549  *  invoked.
1550  * @args_list: va_list of arguments to be passed to the closure.
1551  * @marshal_data: (nullable): additional data specified when
1552  *  registering the marshaller, see g_closure_set_marshal() and
1553  *  g_closure_set_meta_marshal()
1554  * @n_params: the length of the @param_types array
1555  * @param_types: (array length=n_params): the #GType of each argument from
1556  *  @args_list.
1557  *
1558  * A generic #GVaClosureMarshal function implemented via
1559  * [libffi](http://sourceware.org/libffi/).
1560  *
1561  * Since: 2.30
1562  */
1563 void
1564 g_cclosure_marshal_generic_va (GClosure *closure,
<span class="line-modified">1565              GValue   *return_value,</span>
<span class="line-modified">1566              gpointer  instance,</span>
<span class="line-modified">1567              va_list   args_list,</span>
<span class="line-modified">1568              gpointer  marshal_data,</span>
<span class="line-modified">1569              int       n_params,</span>
<span class="line-modified">1570              GType    *param_types)</span>
1571 {
1572   ffi_type *rtype;
1573   void *rvalue;
1574   int n_args;
1575   ffi_type **atypes;
1576   void **args;
1577   va_arg_storage *storage;
1578   int i;
1579   ffi_cif cif;
1580   GCClosure *cc = (GCClosure*) closure;
1581   gint *enum_tmpval;
1582   gboolean tmpval_used = FALSE;
1583   va_list args_copy;
1584 
1585   enum_tmpval = g_alloca (sizeof (gint));
1586   if (return_value &amp;&amp; G_VALUE_TYPE (return_value))
1587     {
1588       rtype = value_to_ffi_type (return_value, &amp;rvalue, enum_tmpval, &amp;tmpval_used);
1589     }
1590   else
</pre>
<hr />
<pre>
1606       atypes[0] = &amp;ffi_type_pointer;
1607       args[0] = &amp;closure-&gt;data;
1608     }
1609   else
1610     {
1611       atypes[0] = &amp;ffi_type_pointer;
1612       args[0] = &amp;instance;
1613       atypes[n_args-1] = &amp;ffi_type_pointer;
1614       args[n_args-1] = &amp;closure-&gt;data;
1615     }
1616 
1617   G_VA_COPY (args_copy, args_list);
1618 
1619   /* Box non-primitive arguments */
1620   for (i = 0; i &lt; n_params; i++)
1621     {
1622       GType type = param_types[i]  &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
1623       GType fundamental = G_TYPE_FUNDAMENTAL (type);
1624 
1625       atypes[i+1] = va_to_ffi_type (type,
<span class="line-modified">1626             &amp;args_copy,</span>
<span class="line-modified">1627             &amp;storage[i]);</span>
1628       args[i+1] = &amp;storage[i];
1629 
1630       if ((param_types[i]  &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0)
<span class="line-modified">1631   {</span>
<span class="line-modified">1632     if (fundamental == G_TYPE_STRING &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1633       storage[i]._gpointer = g_strdup (storage[i]._gpointer);</span>
<span class="line-modified">1634     else if (fundamental == G_TYPE_PARAM &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1635       storage[i]._gpointer = g_param_spec_ref (storage[i]._gpointer);</span>
<span class="line-modified">1636     else if (fundamental == G_TYPE_BOXED &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1637       storage[i]._gpointer = g_boxed_copy (type, storage[i]._gpointer);</span>
<span class="line-modified">1638     else if (fundamental == G_TYPE_VARIANT &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1639       storage[i]._gpointer = g_variant_ref_sink (storage[i]._gpointer);</span>
<span class="line-modified">1640   }</span>
1641       if (fundamental == G_TYPE_OBJECT &amp;&amp; storage[i]._gpointer != NULL)
<span class="line-modified">1642   storage[i]._gpointer = g_object_ref (storage[i]._gpointer);</span>
1643     }
1644 
1645   va_end (args_copy);
1646 
1647   if (ffi_prep_cif (&amp;cif, FFI_DEFAULT_ABI, n_args, rtype, atypes) != FFI_OK)
1648     return;
1649 
1650   ffi_call (&amp;cif, marshal_data ? marshal_data : cc-&gt;callback, rvalue, args);
1651 
1652   /* Unbox non-primitive arguments */
1653   for (i = 0; i &lt; n_params; i++)
1654     {
1655       GType type = param_types[i]  &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
1656       GType fundamental = G_TYPE_FUNDAMENTAL (type);
1657 
1658       if ((param_types[i]  &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0)
<span class="line-modified">1659   {</span>
<span class="line-modified">1660     if (fundamental == G_TYPE_STRING &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1661       g_free (storage[i]._gpointer);</span>
<span class="line-modified">1662     else if (fundamental == G_TYPE_PARAM &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1663       g_param_spec_unref (storage[i]._gpointer);</span>
<span class="line-modified">1664     else if (fundamental == G_TYPE_BOXED &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1665       g_boxed_free (type, storage[i]._gpointer);</span>
<span class="line-modified">1666     else if (fundamental == G_TYPE_VARIANT &amp;&amp; storage[i]._gpointer != NULL)</span>
<span class="line-modified">1667       g_variant_unref (storage[i]._gpointer);</span>
<span class="line-modified">1668   }</span>
1669       if (fundamental == G_TYPE_OBJECT &amp;&amp; storage[i]._gpointer != NULL)
<span class="line-modified">1670   g_object_unref (storage[i]._gpointer);</span>
1671     }
1672 
1673   if (return_value &amp;&amp; G_VALUE_TYPE (return_value))
1674     value_from_ffi_type (return_value, rvalue);
1675 }
1676 
1677 /**
1678  * g_cclosure_marshal_VOID__VOID:
1679  * @closure: the #GClosure to which the marshaller belongs
1680  * @return_value: ignored
1681  * @n_param_values: 1
1682  * @param_values: a #GValue array holding only the instance
1683  * @invocation_hint: the invocation hint given as the last argument
1684  *  to g_closure_invoke()
1685  * @marshal_data: additional data specified when registering the marshaller
1686  *
1687  * A marshaller for a #GCClosure with a callback of type
1688  * `void (*callback) (gpointer instance, gpointer user_data)`.
1689  */
1690 
</pre>
</td>
</tr>
</table>
<center><a href="gboxed.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gclosure.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>