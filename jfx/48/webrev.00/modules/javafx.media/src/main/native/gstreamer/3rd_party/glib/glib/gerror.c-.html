<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gerror.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /* GLIB - Library of useful routines for C programming
  2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Lesser General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2.1 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Lesser General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Lesser General Public
 15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 16  */
 17 
 18 /*
 19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
 20  * file for a list of people on the GLib Team.  See the ChangeLog
 21  * files for a list of changes.  These files are distributed with
 22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
 23  */
 24 
 25 /**
 26  * SECTION:error_reporting
 27  * @Title: Error Reporting
 28  * @Short_description: a system for reporting errors
 29  *
 30  * GLib provides a standard method of reporting errors from a called
 31  * function to the calling code. (This is the same problem solved by
 32  * exceptions in other languages.) It&#39;s important to understand that
 33  * this method is both a data type (the #GError struct) and a [set of
 34  * rules][gerror-rules]. If you use #GError incorrectly, then your code will not
 35  * properly interoperate with other code that uses #GError, and users
 36  * of your API will probably get confused. In most cases, [using #GError is
 37  * preferred over numeric error codes][gerror-comparison], but there are
 38  * situations where numeric error codes are useful for performance.
 39  *
 40  * First and foremost: #GError should only be used to report recoverable
 41  * runtime errors, never to report programming errors. If the programmer
 42  * has screwed up, then you should use g_warning(), g_return_if_fail(),
 43  * g_assert(), g_error(), or some similar facility. (Incidentally,
 44  * remember that the g_error() function should only be used for
 45  * programming errors, it should not be used to print any error
 46  * reportable via #GError.)
 47  *
 48  * Examples of recoverable runtime errors are &quot;file not found&quot; or
 49  * &quot;failed to parse input.&quot; Examples of programming errors are &quot;NULL
 50  * passed to strcmp()&quot; or &quot;attempted to free the same pointer twice.&quot;
 51  * These two kinds of errors are fundamentally different: runtime errors
 52  * should be handled or reported to the user, programming errors should
 53  * be eliminated by fixing the bug in the program. This is why most
 54  * functions in GLib and GTK+ do not use the #GError facility.
 55  *
 56  * Functions that can fail take a return location for a #GError as their
 57  * last argument. On error, a new #GError instance will be allocated and
 58  * returned to the caller via this argument. For example:
 59  * |[&lt;!-- language=&quot;C&quot; --&gt;
 60  * gboolean g_file_get_contents (const gchar  *filename,
 61  *                               gchar       **contents,
 62  *                               gsize        *length,
 63  *                               GError      **error);
 64  * ]|
 65  * If you pass a non-%NULL value for the `error` argument, it should
 66  * point to a location where an error can be placed. For example:
 67  * |[&lt;!-- language=&quot;C&quot; --&gt;
 68  * gchar *contents;
 69  * GError *err = NULL;
 70  *
 71  * g_file_get_contents (&quot;foo.txt&quot;, &amp;contents, NULL, &amp;err);
 72  * g_assert ((contents == NULL &amp;&amp; err != NULL) || (contents != NULL &amp;&amp; err == NULL));
 73  * if (err != NULL)
 74  *   {
 75  *     // Report error to user, and free error
 76  *     g_assert (contents == NULL);
 77  *     fprintf (stderr, &quot;Unable to read file: %s\n&quot;, err-&gt;message);
 78  *     g_error_free (err);
 79  *   }
 80  * else
 81  *   {
 82  *     // Use file contents
 83  *     g_assert (contents != NULL);
 84  *   }
 85  * ]|
 86  * Note that `err != NULL` in this example is a reliable indicator
 87  * of whether g_file_get_contents() failed. Additionally,
 88  * g_file_get_contents() returns a boolean which
 89  * indicates whether it was successful.
 90  *
 91  * Because g_file_get_contents() returns %FALSE on failure, if you
 92  * are only interested in whether it failed and don&#39;t need to display
 93  * an error message, you can pass %NULL for the @error argument:
 94  * |[&lt;!-- language=&quot;C&quot; --&gt;
 95  * if (g_file_get_contents (&quot;foo.txt&quot;, &amp;contents, NULL, NULL)) // ignore errors
 96  *   // no error occurred
 97  *   ;
 98  * else
 99  *   // error
100  *   ;
101  * ]|
102  *
103  * The #GError object contains three fields: @domain indicates the module
104  * the error-reporting function is located in, @code indicates the specific
105  * error that occurred, and @message is a user-readable error message with
106  * as many details as possible. Several functions are provided to deal
107  * with an error received from a called function: g_error_matches()
108  * returns %TRUE if the error matches a given domain and code,
109  * g_propagate_error() copies an error into an error location (so the
110  * calling function will receive it), and g_clear_error() clears an
111  * error location by freeing the error and resetting the location to
112  * %NULL. To display an error to the user, simply display the @message,
113  * perhaps along with additional context known only to the calling
114  * function (the file being opened, or whatever - though in the
115  * g_file_get_contents() case, the @message already contains a filename).
116  *
117  * When implementing a function that can report errors, the basic
118  * tool is g_set_error(). Typically, if a fatal error occurs you
119  * want to g_set_error(), then return immediately. g_set_error()
120  * does nothing if the error location passed to it is %NULL.
121  * Here&#39;s an example:
122  * |[&lt;!-- language=&quot;C&quot; --&gt;
123  * gint
124  * foo_open_file (GError **error)
125  * {
126  *   gint fd;
127  *   int saved_errno;
128  *
129  *   fd = open (&quot;file.txt&quot;, O_RDONLY);
130  *   saved_errno = errno;
131  *
132  *   if (fd &lt; 0)
133  *     {
134  *       g_set_error (error,
135  *                    FOO_ERROR,                 // error domain
136  *                    FOO_ERROR_BLAH,            // error code
137  *                    &quot;Failed to open file: %s&quot;, // error message format string
138  *                    g_strerror (saved_errno));
139  *       return -1;
140  *     }
141  *   else
142  *     return fd;
143  * }
144  * ]|
145  *
146  * Things are somewhat more complicated if you yourself call another
147  * function that can report a #GError. If the sub-function indicates
148  * fatal errors in some way other than reporting a #GError, such as
149  * by returning %TRUE on success, you can simply do the following:
150  * |[&lt;!-- language=&quot;C&quot; --&gt;
151  * gboolean
152  * my_function_that_can_fail (GError **err)
153  * {
154  *   g_return_val_if_fail (err == NULL || *err == NULL, FALSE);
155  *
156  *   if (!sub_function_that_can_fail (err))
157  *     {
158  *       // assert that error was set by the sub-function
159  *       g_assert (err == NULL || *err != NULL);
160  *       return FALSE;
161  *     }
162  *
163  *   // otherwise continue, no error occurred
164  *   g_assert (err == NULL || *err == NULL);
165  * }
166  * ]|
167  *
168  * If the sub-function does not indicate errors other than by
169  * reporting a #GError (or if its return value does not reliably indicate
170  * errors) you need to create a temporary #GError
171  * since the passed-in one may be %NULL. g_propagate_error() is
172  * intended for use in this case.
173  * |[&lt;!-- language=&quot;C&quot; --&gt;
174  * gboolean
175  * my_function_that_can_fail (GError **err)
176  * {
177  *   GError *tmp_error;
178  *
179  *   g_return_val_if_fail (err == NULL || *err == NULL, FALSE);
180  *
181  *   tmp_error = NULL;
182  *   sub_function_that_can_fail (&amp;tmp_error);
183  *
184  *   if (tmp_error != NULL)
185  *     {
186  *       // store tmp_error in err, if err != NULL,
187  *       // otherwise call g_error_free() on tmp_error
188  *       g_propagate_error (err, tmp_error);
189  *       return FALSE;
190  *     }
191  *
192  *   // otherwise continue, no error occurred
193  * }
194  * ]|
195  *
196  * Error pileups are always a bug. For example, this code is incorrect:
197  * |[&lt;!-- language=&quot;C&quot; --&gt;
198  * gboolean
199  * my_function_that_can_fail (GError **err)
200  * {
201  *   GError *tmp_error;
202  *
203  *   g_return_val_if_fail (err == NULL || *err == NULL, FALSE);
204  *
205  *   tmp_error = NULL;
206  *   sub_function_that_can_fail (&amp;tmp_error);
207  *   other_function_that_can_fail (&amp;tmp_error);
208  *
209  *   if (tmp_error != NULL)
210  *     {
211  *       g_propagate_error (err, tmp_error);
212  *       return FALSE;
213  *     }
214  * }
215  * ]|
216  * @tmp_error should be checked immediately after sub_function_that_can_fail(),
217  * and either cleared or propagated upward. The rule is: after each error,
218  * you must either handle the error, or return it to the calling function.
219  *
220  * Note that passing %NULL for the error location is the equivalent
221  * of handling an error by always doing nothing about it. So the
222  * following code is fine, assuming errors in sub_function_that_can_fail()
223  * are not fatal to my_function_that_can_fail():
224  * |[&lt;!-- language=&quot;C&quot; --&gt;
225  * gboolean
226  * my_function_that_can_fail (GError **err)
227  * {
228  *   GError *tmp_error;
229  *
230  *   g_return_val_if_fail (err == NULL || *err == NULL, FALSE);
231  *
232  *   sub_function_that_can_fail (NULL); // ignore errors
233  *
234  *   tmp_error = NULL;
235  *   other_function_that_can_fail (&amp;tmp_error);
236  *
237  *   if (tmp_error != NULL)
238  *     {
239  *       g_propagate_error (err, tmp_error);
240  *       return FALSE;
241  *     }
242  * }
243  * ]|
244  *
245  * Note that passing %NULL for the error location ignores errors;
246  * it&#39;s equivalent to
247  * `try { sub_function_that_can_fail (); } catch (...) {}`
248  * in C++. It does not mean to leave errors unhandled; it means
249  * to handle them by doing nothing.
250  *
251  * Error domains and codes are conventionally named as follows:
252  *
253  * - The error domain is called &lt;NAMESPACE&gt;_&lt;MODULE&gt;_ERROR,
254  *   for example %G_SPAWN_ERROR or %G_THREAD_ERROR:
255  *   |[&lt;!-- language=&quot;C&quot; --&gt;
256  *   #define G_SPAWN_ERROR g_spawn_error_quark ()
257  *
258  *   GQuark
259  *   g_spawn_error_quark (void)
260  *   {
261  *       return g_quark_from_static_string (&quot;g-spawn-error-quark&quot;);
262  *   }
263  *   ]|
264  *
265  * - The quark function for the error domain is called
266  *   &lt;namespace&gt;_&lt;module&gt;_error_quark,
267  *   for example g_spawn_error_quark() or g_thread_error_quark().
268  *
269  * - The error codes are in an enumeration called
270  *   &lt;Namespace&gt;&lt;Module&gt;Error;
271  *   for example, #GThreadError or #GSpawnError.
272  *
273  * - Members of the error code enumeration are called
274  *   &lt;NAMESPACE&gt;_&lt;MODULE&gt;_ERROR_&lt;CODE&gt;,
275  *   for example %G_SPAWN_ERROR_FORK or %G_THREAD_ERROR_AGAIN.
276  *
277  * - If there&#39;s a &quot;generic&quot; or &quot;unknown&quot; error code for unrecoverable
278  *   errors it doesn&#39;t make sense to distinguish with specific codes,
279  *   it should be called &lt;NAMESPACE&gt;_&lt;MODULE&gt;_ERROR_FAILED,
280  *   for example %G_SPAWN_ERROR_FAILED. In the case of error code
281  *   enumerations that may be extended in future releases, you should
282  *   generally not handle this error code explicitly, but should
283  *   instead treat any unrecognized error code as equivalent to
284  *   FAILED.
285  *
286  * ## Comparison of #GError and traditional error handling # {#gerror-comparison}
287  *
288  * #GError has several advantages over traditional numeric error codes:
289  * importantly, tools like
290  * [gobject-introspection](https://developer.gnome.org/gi/stable/) understand
291  * #GErrors and convert them to exceptions in bindings; the message includes
292  * more information than just a code; and use of a domain helps prevent
293  * misinterpretation of error codes.
294  *
295  * #GError has disadvantages though: it requires a memory allocation, and
296  * formatting the error message string has a performance overhead. This makes it
297  * unsuitable for use in retry loops where errors are a common case, rather than
298  * being unusual. For example, using %G_IO_ERROR_WOULD_BLOCK means hitting these
299  * overheads in the normal control flow. String formatting overhead can be
300  * eliminated by using g_set_error_literal() in some cases.
301  *
302  * These performance issues can be compounded if a function wraps the #GErrors
303  * returned by the functions it calls: this multiplies the number of allocations
304  * and string formatting operations. This can be partially mitigated by using
305  * g_prefix_error().
306  *
307  * ## Rules for use of #GError # {#gerror-rules}
308  *
309  * Summary of rules for use of #GError:
310  *
311  * - Do not report programming errors via #GError.
312  *
313  * - The last argument of a function that returns an error should
314  *   be a location where a #GError can be placed (i.e. &quot;#GError** error&quot;).
315  *   If #GError is used with varargs, the #GError** should be the last
316  *   argument before the &quot;...&quot;.
317  *
318  * - The caller may pass %NULL for the #GError** if they are not interested
319  *   in details of the exact error that occurred.
320  *
321  * - If %NULL is passed for the #GError** argument, then errors should
322  *   not be returned to the caller, but your function should still
323  *   abort and return if an error occurs. That is, control flow should
324  *   not be affected by whether the caller wants to get a #GError.
325  *
326  * - If a #GError is reported, then your function by definition had a
327  *   fatal failure and did not complete whatever it was supposed to do.
328  *   If the failure was not fatal, then you handled it and you should not
329  *   report it. If it was fatal, then you must report it and discontinue
330  *   whatever you were doing immediately.
331  *
332  * - If a #GError is reported, out parameters are not guaranteed to
333  *   be set to any defined value.
334  *
335  * - A #GError* must be initialized to %NULL before passing its address
336  *   to a function that can report errors.
337  *
338  * - &quot;Piling up&quot; errors is always a bug. That is, if you assign a
339  *   new #GError to a #GError* that is non-%NULL, thus overwriting
340  *   the previous error, it indicates that you should have aborted
341  *   the operation instead of continuing. If you were able to continue,
342  *   you should have cleared the previous error with g_clear_error().
343  *   g_set_error() will complain if you pile up errors.
344  *
345  * - By convention, if you return a boolean value indicating success
346  *   then %TRUE means success and %FALSE means failure. Avoid creating
347  *   functions which have a boolean return value and a GError parameter,
348  *   but where the boolean does something other than signal whether the
349  *   GError is set.  Among other problems, it requires C callers to allocate
350  *   a temporary error.  Instead, provide a &quot;gboolean *&quot; out parameter.
351  *   There are functions in GLib itself such as g_key_file_has_key() that
352  *   are deprecated because of this. If %FALSE is returned, the error must
353  *   be set to a non-%NULL value.  One exception to this is that in situations
354  *   that are already considered to be undefined behaviour (such as when a
355  *   g_return_val_if_fail() check fails), the error need not be set.
356  *   Instead of checking separately whether the error is set, callers
357  *   should ensure that they do not provoke undefined behaviour, then
358  *   assume that the error will be set on failure.
359  *
360  * - A %NULL return value is also frequently used to mean that an error
361  *   occurred. You should make clear in your documentation whether %NULL
362  *   is a valid return value in non-error cases; if %NULL is a valid value,
363  *   then users must check whether an error was returned to see if the
364  *   function succeeded.
365  *
366  * - When implementing a function that can report errors, you may want
367  *   to add a check at the top of your function that the error return
368  *   location is either %NULL or contains a %NULL error (e.g.
369  *   `g_return_if_fail (error == NULL || *error == NULL);`).
370  */
371 
372 #include &quot;config.h&quot;
373 
374 #include &quot;gerror.h&quot;
375 
376 #include &quot;gslice.h&quot;
377 #include &quot;gstrfuncs.h&quot;
378 #include &quot;gtestutils.h&quot;
379 
380 /**
381  * g_error_new_valist:
382  * @domain: error domain
383  * @code: error code
384  * @format: printf()-style format for error message
385  * @args: #va_list of parameters for the message format
386  *
387  * Creates a new #GError with the given @domain and @code,
388  * and a message formatted with @format.
389  *
390  * Returns: a new #GError
391  *
392  * Since: 2.22
393  */
394 GError*
395 g_error_new_valist (GQuark       domain,
396                     gint         code,
397                     const gchar *format,
398                     va_list      args)
399 {
400   GError *error;
401 
402   /* Historically, GError allowed this (although it was never meant to work),
403    * and it has significant use in the wild, which g_return_val_if_fail
404    * would break. It should maybe g_return_val_if_fail in GLib 4.
405    * (GNOME#660371, GNOME#560482)
406    */
407   g_warn_if_fail (domain != 0);
408   g_warn_if_fail (format != NULL);
409 
410   error = g_slice_new (GError);
411 #ifdef GSTREAMER_LITE
412   if (error == NULL) {
413     return NULL;
414   }
415 #endif // GSTREAMER_LITE
416 
417   error-&gt;domain = domain;
418   error-&gt;code = code;
419   error-&gt;message = g_strdup_vprintf (format, args);
420 
421   return error;
422 }
423 
424 /**
425  * g_error_new:
426  * @domain: error domain
427  * @code: error code
428  * @format: printf()-style format for error message
429  * @...: parameters for message format
430  *
431  * Creates a new #GError with the given @domain and @code,
432  * and a message formatted with @format.
433  *
434  * Returns: a new #GError
435  */
436 GError*
437 g_error_new (GQuark       domain,
438              gint         code,
439              const gchar *format,
440              ...)
441 {
442   GError* error;
443   va_list args;
444 
445   g_return_val_if_fail (format != NULL, NULL);
446   g_return_val_if_fail (domain != 0, NULL);
447 
448   va_start (args, format);
449   error = g_error_new_valist (domain, code, format, args);
450   va_end (args);
451 
452   return error;
453 }
454 
455 /**
456  * g_error_new_literal:
457  * @domain: error domain
458  * @code: error code
459  * @message: error message
460  *
461  * Creates a new #GError; unlike g_error_new(), @message is
462  * not a printf()-style format string. Use this function if
463  * @message contains text you don&#39;t have control over,
464  * that could include printf() escape sequences.
465  *
466  * Returns: a new #GError
467  **/
468 GError*
469 g_error_new_literal (GQuark         domain,
470                      gint           code,
471                      const gchar   *message)
472 {
473   GError* err;
474 
475   g_return_val_if_fail (message != NULL, NULL);
476   g_return_val_if_fail (domain != 0, NULL);
477 
478   err = g_slice_new (GError);
479 #ifdef GSTREAMER_LITE
480   if (err == NULL) {
481     return NULL;
482   }
483 #endif // GSTREAMER_LITE
484 
485   err-&gt;domain = domain;
486   err-&gt;code = code;
487   err-&gt;message = g_strdup (message);
488 
489   return err;
490 }
491 
492 /**
493  * g_error_free:
494  * @error: a #GError
495  *
496  * Frees a #GError and associated resources.
497  */
498 void
499 g_error_free (GError *error)
500 {
501   g_return_if_fail (error != NULL);
502 
503   g_free (error-&gt;message);
504 
505   g_slice_free (GError, error);
506 }
507 
508 /**
509  * g_error_copy:
510  * @error: a #GError
511  *
512  * Makes a copy of @error.
513  *
514  * Returns: a new #GError
515  */
516 GError*
517 g_error_copy (const GError *error)
518 {
519   GError *copy;
520 
521   g_return_val_if_fail (error != NULL, NULL);
522   /* See g_error_new_valist for why these don&#39;t return */
523   g_warn_if_fail (error-&gt;domain != 0);
524   g_warn_if_fail (error-&gt;message != NULL);
525 
526   copy = g_slice_new (GError);
527 #ifdef GSTREAMER_LITE
528   if (copy == NULL) {
529     return NULL;
530   }
531 #endif // GSTREAMER_LITE
532 
533   *copy = *error;
534 
535   copy-&gt;message = g_strdup (error-&gt;message);
536 
537   return copy;
538 }
539 
540 /**
541  * g_error_matches:
542  * @error: (nullable): a #GError
543  * @domain: an error domain
544  * @code: an error code
545  *
546  * Returns %TRUE if @error matches @domain and @code, %FALSE
547  * otherwise. In particular, when @error is %NULL, %FALSE will
548  * be returned.
549  *
550  * If @domain contains a `FAILED` (or otherwise generic) error code,
551  * you should generally not check for it explicitly, but should
552  * instead treat any not-explicitly-recognized error code as being
553  * equivalent to the `FAILED` code. This way, if the domain is
554  * extended in the future to provide a more specific error code for
555  * a certain case, your code will still work.
556  *
557  * Returns: whether @error has @domain and @code
558  */
559 gboolean
560 g_error_matches (const GError *error,
561                  GQuark        domain,
562                  gint          code)
563 {
564   return error &amp;&amp;
565     error-&gt;domain == domain &amp;&amp;
566     error-&gt;code == code;
567 }
568 
569 #define ERROR_OVERWRITTEN_WARNING &quot;GError set over the top of a previous GError or uninitialized memory.\n&quot; \
570                &quot;This indicates a bug in someone&#39;s code. You must ensure an error is NULL before it&#39;s set.\n&quot; \
571                &quot;The overwriting error message was: %s&quot;
572 
573 /**
574  * g_set_error:
575  * @err: (out callee-allocates) (optional): a return location for a #GError
576  * @domain: error domain
577  * @code: error code
578  * @format: printf()-style format
579  * @...: args for @format
580  *
581  * Does nothing if @err is %NULL; if @err is non-%NULL, then *@err
582  * must be %NULL. A new #GError is created and assigned to *@err.
583  */
584 void
585 g_set_error (GError      **err,
586              GQuark        domain,
587              gint          code,
588              const gchar  *format,
589              ...)
590 {
591   GError *new;
592 
593   va_list args;
594 
595   if (err == NULL)
596     return;
597 
598   va_start (args, format);
599   new = g_error_new_valist (domain, code, format, args);
600   va_end (args);
601 
602   if (*err == NULL)
603     *err = new;
604   else
605     {
606       g_warning (ERROR_OVERWRITTEN_WARNING, new-&gt;message);
607       g_error_free (new);
608     }
609 }
610 
611 /**
612  * g_set_error_literal:
613  * @err: (out callee-allocates) (optional): a return location for a #GError
614  * @domain: error domain
615  * @code: error code
616  * @message: error message
617  *
618  * Does nothing if @err is %NULL; if @err is non-%NULL, then *@err
619  * must be %NULL. A new #GError is created and assigned to *@err.
620  * Unlike g_set_error(), @message is not a printf()-style format string.
621  * Use this function if @message contains text you don&#39;t have control over,
622  * that could include printf() escape sequences.
623  *
624  * Since: 2.18
625  */
626 void
627 g_set_error_literal (GError      **err,
628                      GQuark        domain,
629                      gint          code,
630                      const gchar  *message)
631 {
632   if (err == NULL)
633     return;
634 
635   if (*err == NULL)
636     *err = g_error_new_literal (domain, code, message);
637   else
638     g_warning (ERROR_OVERWRITTEN_WARNING, message);
639 }
640 
641 /**
642  * g_propagate_error:
643  * @dest: (out callee-allocates) (optional) (nullable): error return location
644  * @src: (transfer full): error to move into the return location
645  *
646  * If @dest is %NULL, free @src; otherwise, moves @src into *@dest.
647  * The error variable @dest points to must be %NULL.
648  *
649  * @src must be non-%NULL.
650  *
651  * Note that @src is no longer valid after this call. If you want
652  * to keep using the same GError*, you need to set it to %NULL
653  * after calling this function on it.
654  */
655 void
656 g_propagate_error (GError **dest,
657            GError  *src)
658 {
659   g_return_if_fail (src != NULL);
660 
661   if (dest == NULL)
662     {
663       if (src)
664         g_error_free (src);
665       return;
666     }
667   else
668     {
669       if (*dest != NULL)
670         {
671           g_warning (ERROR_OVERWRITTEN_WARNING, src-&gt;message);
672           g_error_free (src);
673         }
674       else
675         *dest = src;
676     }
677 }
678 
679 /**
680  * g_clear_error:
681  * @err: a #GError return location
682  *
683  * If @err or *@err is %NULL, does nothing. Otherwise,
684  * calls g_error_free() on *@err and sets *@err to %NULL.
685  */
686 void
687 g_clear_error (GError **err)
688 {
689   if (err &amp;&amp; *err)
690     {
691       g_error_free (*err);
692       *err = NULL;
693     }
694 }
695 
696 G_GNUC_PRINTF(2, 0)
697 static void
698 g_error_add_prefix (gchar       **string,
699                     const gchar  *format,
700                     va_list       ap)
701 {
702   gchar *oldstring;
703   gchar *prefix;
704 
705   prefix = g_strdup_vprintf (format, ap);
706   oldstring = *string;
707   *string = g_strconcat (prefix, oldstring, NULL);
708   g_free (oldstring);
709   g_free (prefix);
710 }
711 
712 /**
713  * g_prefix_error:
714  * @err: (inout) (optional) (nullable): a return location for a #GError
715  * @format: printf()-style format string
716  * @...: arguments to @format
717  *
718  * Formats a string according to @format and prefix it to an existing
719  * error message. If @err is %NULL (ie: no error variable) then do
720  * nothing.
721  *
722  * If *@err is %NULL (ie: an error variable is present but there is no
723  * error condition) then also do nothing.
724  *
725  * Since: 2.16
726  */
727 void
728 g_prefix_error (GError      **err,
729                 const gchar  *format,
730                 ...)
731 {
732   if (err &amp;&amp; *err)
733     {
734       va_list ap;
735 
736       va_start (ap, format);
737       g_error_add_prefix (&amp;(*err)-&gt;message, format, ap);
738       va_end (ap);
739     }
740 }
741 
742 /**
743  * g_propagate_prefixed_error:
744  * @dest: error return location
745  * @src: error to move into the return location
746  * @format: printf()-style format string
747  * @...: arguments to @format
748  *
749  * If @dest is %NULL, free @src; otherwise, moves @src into *@dest.
750  * *@dest must be %NULL. After the move, add a prefix as with
751  * g_prefix_error().
752  *
753  * Since: 2.16
754  **/
755 void
756 g_propagate_prefixed_error (GError      **dest,
757                             GError       *src,
758                             const gchar  *format,
759                             ...)
760 {
761   g_propagate_error (dest, src);
762 
763   if (dest &amp;&amp; *dest)
764     {
765       va_list ap;
766 
767       va_start (ap, format);
768       g_error_add_prefix (&amp;(*dest)-&gt;message, format, ap);
769       va_end (ap);
770     }
771 }
    </pre>
  </body>
</html>