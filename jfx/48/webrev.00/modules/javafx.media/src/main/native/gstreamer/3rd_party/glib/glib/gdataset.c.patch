diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gdataset.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gdataset.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gdataset.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gdataset.c
@@ -136,11 +136,11 @@
  **/
 
 #define G_DATALIST_FLAGS_MASK_INTERNAL 0x7
 
 /* datalist pointer accesses have to be carried out atomically */
-#define G_DATALIST_GET_POINTER(datalist)                        \
+#define G_DATALIST_GET_POINTER(datalist)            \
   ((GData*) ((gsize) g_atomic_pointer_get (datalist) & ~(gsize) G_DATALIST_FLAGS_MASK_INTERNAL))
 
 #define G_DATALIST_SET_POINTER(datalist, pointer)       G_STMT_START {                  \
   gpointer _oldv, _newv;                                                                \
   do {                                                                                  \
@@ -170,19 +170,19 @@
   GData        *datalist;
 };
 
 
 /* --- prototypes --- */
-static inline GDataset* g_dataset_lookup        (gconstpointer    dataset_location);
-static inline void  g_datalist_clear_i      (GData      **datalist);
-static void     g_dataset_destroy_internal  (GDataset    *dataset);
-static inline gpointer  g_data_set_internal     (GData      **datalist,
-                             GQuark       key_id,
-                             gpointer         data,
-                             GDestroyNotify   destroy_func,
-                             GDataset    *dataset);
-static void     g_data_initialize       (void);
+static inline GDataset* g_dataset_lookup    (gconstpointer    dataset_location);
+static inline void  g_datalist_clear_i    (GData    **datalist);
+static void   g_dataset_destroy_internal  (GDataset  *dataset);
+static inline gpointer  g_data_set_internal   (GData      **datalist,
+               GQuark       key_id,
+               gpointer         data,
+               GDestroyNotify   destroy_func,
+               GDataset  *dataset);
+static void   g_data_initialize   (void);
 
 /* Locking model:
  * Each standalone GDataList is protected by a bitlock in the datalist pointer,
  * which protects that modification of the non-flags part of the datalist pointer
  * and the contents of the datalist.
@@ -195,11 +195,11 @@
 
 /* --- variables --- */
 G_LOCK_DEFINE_STATIC (g_dataset_global);
 static GHashTable   *g_dataset_location_ht = NULL;
 static GDataset     *g_dataset_cached = NULL; /* should this be
-                         thread specific? */
+             thread specific? */
 
 /* --- functions --- */
 
 #define DATALIST_LOCK_BIT 2
 
@@ -220,11 +220,11 @@
  */
 static void
 g_datalist_clear_i (GData **datalist)
 {
   GData *data;
-  gint i;
+  guint i;
 
   data = G_DATALIST_GET_POINTER (datalist);
   G_DATALIST_SET_POINTER (datalist, NULL);
 
   if (data)
@@ -252,11 +252,11 @@
  **/
 void
 g_datalist_clear (GData **datalist)
 {
   GData *data;
-  gint i;
+  guint i;
 
   g_return_if_fail (datalist != NULL);
 
   g_datalist_lock (datalist);
 
@@ -301,17 +301,17 @@
 
   dataset_location = dataset->location;
   while (dataset)
     {
       if (G_DATALIST_GET_POINTER(&dataset->datalist) == NULL)
-    {
-      if (dataset == g_dataset_cached)
-        g_dataset_cached = NULL;
-      g_hash_table_remove (g_dataset_location_ht, dataset_location);
-      g_slice_free (GDataset, dataset);
-      break;
-    }
+  {
+    if (dataset == g_dataset_cached)
+      g_dataset_cached = NULL;
+    g_hash_table_remove (g_dataset_location_ht, dataset_location);
+    g_slice_free (GDataset, dataset);
+    break;
+  }
 
       g_datalist_clear_i (&dataset->datalist);
       dataset = g_dataset_lookup (dataset_location);
     }
 }
@@ -333,22 +333,22 @@
     {
       GDataset *dataset;
 
       dataset = g_dataset_lookup (dataset_location);
       if (dataset)
-    g_dataset_destroy_internal (dataset);
+  g_dataset_destroy_internal (dataset);
     }
   G_UNLOCK (g_dataset_global);
 }
 
 /* HOLDS: g_dataset_global_lock if dataset != null */
 static inline gpointer
 g_data_set_internal (GData    **datalist,
-                     GQuark         key_id,
-                     gpointer       new_data,
-                     GDestroyNotify new_destroy_func,
-             GDataset      *dataset)
+         GQuark         key_id,
+         gpointer       new_data,
+         GDestroyNotify new_destroy_func,
+         GDataset    *dataset)
 {
   GData *d, *old_d;
   GDataElt old, *data, *data_last, *data_end;
 
   g_datalist_lock (datalist);
@@ -356,124 +356,124 @@
   d = G_DATALIST_GET_POINTER (datalist);
 
   if (new_data == NULL) /* remove */
     {
       if (d)
+  {
+    data = d->data;
+    data_last = data + d->len - 1;
+    while (data <= data_last)
+      {
+        if (data->key == key_id)
     {
-      data = d->data;
-      data_last = data + d->len - 1;
-      while (data <= data_last)
-        {
-          if (data->key == key_id)
-        {
-          old = *data;
-          if (data != data_last)
-            *data = *data_last;
-          d->len--;
+      old = *data;
+      if (data != data_last)
+        *data = *data_last;
+      d->len--;
 
-          /* We don't bother to shrink, but if all data are now gone
-           * we at least free the memory
+      /* We don't bother to shrink, but if all data are now gone
+       * we at least free the memory
                    */
-          if (d->len == 0)
-            {
-              G_DATALIST_SET_POINTER (datalist, NULL);
-              g_free (d);
-              /* datalist may be situated in dataset, so must not be
-               * unlocked after we free it
-               */
-              g_datalist_unlock (datalist);
-
-              /* the dataset destruction *must* be done
-               * prior to invocation of the data destroy function
-               */
-              if (dataset)
-            g_dataset_destroy_internal (dataset);
-            }
-          else
-            {
-              g_datalist_unlock (datalist);
-            }
-
-          /* We found and removed an old value
-           * the GData struct *must* already be unlinked
-           * when invoking the destroy function.
-           * we use (new_data==NULL && new_destroy_func!=NULL) as
-           * a special hint combination to "steal"
-           * data without destroy notification
+      if (d->len == 0)
+        {
+          G_DATALIST_SET_POINTER (datalist, NULL);
+          g_free (d);
+          /* datalist may be situated in dataset, so must not be
+           * unlocked after we free it
            */
-          if (old.destroy && !new_destroy_func)
-            {
-              if (dataset)
-            G_UNLOCK (g_dataset_global);
-              old.destroy (old.data);
-              if (dataset)
-            G_LOCK (g_dataset_global);
-              old.data = NULL;
-            }
+          g_datalist_unlock (datalist);
 
-          return old.data;
+          /* the dataset destruction *must* be done
+           * prior to invocation of the data destroy function
+           */
+          if (dataset)
+      g_dataset_destroy_internal (dataset);
         }
-          data++;
+      else
+        {
+          g_datalist_unlock (datalist);
         }
+
+      /* We found and removed an old value
+       * the GData struct *must* already be unlinked
+       * when invoking the destroy function.
+       * we use (new_data==NULL && new_destroy_func!=NULL) as
+       * a special hint combination to "steal"
+       * data without destroy notification
+       */
+      if (old.destroy && !new_destroy_func)
+        {
+          if (dataset)
+      G_UNLOCK (g_dataset_global);
+          old.destroy (old.data);
+          if (dataset)
+      G_LOCK (g_dataset_global);
+          old.data = NULL;
+        }
+
+      return old.data;
     }
+        data++;
+      }
+  }
     }
   else
     {
       old.data = NULL;
       if (d)
+  {
+    data = d->data;
+    data_end = data + d->len;
+    while (data < data_end)
+      {
+        if (data->key == key_id)
     {
-      data = d->data;
-      data_end = data + d->len;
-      while (data < data_end)
-        {
-          if (data->key == key_id)
+      if (!data->destroy)
         {
-          if (!data->destroy)
-            {
-              data->data = new_data;
-              data->destroy = new_destroy_func;
-              g_datalist_unlock (datalist);
-            }
-          else
-            {
-              old = *data;
-              data->data = new_data;
-              data->destroy = new_destroy_func;
-
-              g_datalist_unlock (datalist);
-
-              /* We found and replaced an old value
-               * the GData struct *must* already be unlinked
-               * when invoking the destroy function.
-               */
-              if (dataset)
-            G_UNLOCK (g_dataset_global);
-              old.destroy (old.data);
-              if (dataset)
-            G_LOCK (g_dataset_global);
-            }
-          return NULL;
+          data->data = new_data;
+          data->destroy = new_destroy_func;
+          g_datalist_unlock (datalist);
         }
-          data++;
+      else
+        {
+          old = *data;
+          data->data = new_data;
+          data->destroy = new_destroy_func;
+
+          g_datalist_unlock (datalist);
+
+          /* We found and replaced an old value
+           * the GData struct *must* already be unlinked
+           * when invoking the destroy function.
+           */
+          if (dataset)
+      G_UNLOCK (g_dataset_global);
+          old.destroy (old.data);
+          if (dataset)
+      G_LOCK (g_dataset_global);
         }
+      return NULL;
     }
+        data++;
+      }
+  }
 
       /* The key was not found, insert it */
       old_d = d;
       if (d == NULL)
-    {
-      d = g_malloc (sizeof (GData));
-      d->len = 0;
-      d->alloc = 1;
-    }
+  {
+    d = g_malloc (sizeof (GData));
+    d->len = 0;
+    d->alloc = 1;
+  }
       else if (d->len == d->alloc)
-    {
-      d->alloc = d->alloc * 2;
-      d = g_realloc (d, sizeof (GData) + (d->alloc - 1) * sizeof (GDataElt));
-    }
+  {
+    d->alloc = d->alloc * 2;
+    d = g_realloc (d, sizeof (GData) + (d->alloc - 1) * sizeof (GDataElt));
+  }
       if (old_d != d)
-    G_DATALIST_SET_POINTER (datalist, d);
+  G_DATALIST_SET_POINTER (datalist, d);
 
       d->data[d->len].key = key_id;
       d->data[d->len].data = new_data;
       d->data[d->len].destroy = new_destroy_func;
       d->len++;
@@ -546,25 +546,25 @@
  * Removes a data element corresponding to a string. Its destroy
  * function is called if it has been set.
  **/
 void
 g_dataset_id_set_data_full (gconstpointer  dataset_location,
-                GQuark         key_id,
-                gpointer       data,
-                GDestroyNotify destroy_func)
+          GQuark         key_id,
+          gpointer       data,
+          GDestroyNotify destroy_func)
 {
   GDataset *dataset;
 
   g_return_if_fail (dataset_location != NULL);
   if (!data)
     g_return_if_fail (destroy_func == NULL);
   if (!key_id)
     {
       if (data)
-    g_return_if_fail (key_id > 0);
+  g_return_if_fail (key_id > 0);
       else
-    return;
+  return;
     }
 
   G_LOCK (g_dataset_global);
   if (!g_dataset_location_ht)
     g_data_initialize ();
@@ -580,12 +580,12 @@
       }
 #endif // GSTREAMER_LITE
       dataset->location = dataset_location;
       g_datalist_init (&dataset->datalist);
       g_hash_table_insert (g_dataset_location_ht,
-               (gpointer) dataset->location,
-               dataset);
+         (gpointer) dataset->location,
+         dataset);
     }
 
   g_data_set_internal (&dataset->datalist, key_id, data, destroy_func, dataset);
   G_UNLOCK (g_dataset_global);
 }
@@ -656,23 +656,23 @@
  * Removes an element using its string identifier. The data element's
  * destroy function is called if it has been set.
  **/
 void
 g_datalist_id_set_data_full (GData    **datalist,
-                             GQuark         key_id,
-                             gpointer       data,
-                             GDestroyNotify destroy_func)
+           GQuark         key_id,
+           gpointer       data,
+           GDestroyNotify destroy_func)
 {
   g_return_if_fail (datalist != NULL);
   if (!data)
     g_return_if_fail (destroy_func == NULL);
   if (!key_id)
     {
       if (data)
-    g_return_if_fail (key_id > 0);
+  g_return_if_fail (key_id > 0);
       else
-    return;
+  return;
     }
 
   g_data_set_internal (datalist, key_id, data, destroy_func, NULL);
 }
 
@@ -694,11 +694,11 @@
  *
  * Removes an element, without calling its destroy notifier.
  **/
 gpointer
 g_dataset_id_remove_no_notify (gconstpointer  dataset_location,
-                   GQuark         key_id)
+             GQuark         key_id)
 {
   gpointer ret_data = NULL;
 
   g_return_val_if_fail (dataset_location != NULL, NULL);
 
@@ -707,11 +707,11 @@
     {
       GDataset *dataset;
 
       dataset = g_dataset_lookup (dataset_location);
       if (dataset)
-    ret_data = g_data_set_internal (&dataset->datalist, key_id, NULL, (GDestroyNotify) 42, dataset);
+  ret_data = g_data_set_internal (&dataset->datalist, key_id, NULL, (GDestroyNotify) 42, dataset);
     }
   G_UNLOCK (g_dataset_global);
 
   return ret_data;
 }
@@ -733,12 +733,12 @@
  * @k: the string identifying the data element.
  *
  * Removes an element, without calling its destroy notifier.
  **/
 gpointer
-g_datalist_id_remove_no_notify (GData   **datalist,
-                                GQuark    key_id)
+g_datalist_id_remove_no_notify (GData **datalist,
+        GQuark    key_id)
 {
   gpointer ret_data = NULL;
 
   g_return_val_if_fail (datalist != NULL, NULL);
 
@@ -768,11 +768,11 @@
  * Returns: (transfer none) (nullable): the data element corresponding to
  *          the string, or %NULL if it is not found.
  **/
 gpointer
 g_dataset_id_get_data (gconstpointer  dataset_location,
-                       GQuark         key_id)
+           GQuark         key_id)
 {
   gpointer retval = NULL;
 
   g_return_val_if_fail (dataset_location != NULL, NULL);
 
@@ -781,11 +781,11 @@
     {
       GDataset *dataset;
 
       dataset = g_dataset_lookup (dataset_location);
       if (dataset)
-    retval = g_datalist_id_get_data (&dataset->datalist, key_id);
+  retval = g_datalist_id_get_data (&dataset->datalist, key_id);
     }
   G_UNLOCK (g_dataset_global);
 
   return retval;
 }
@@ -800,11 +800,11 @@
  * Returns: (transfer none) (nullable): the data element, or %NULL if
  *          it is not found.
  */
 gpointer
 g_datalist_id_get_data (GData  **datalist,
-                        GQuark   key_id)
+      GQuark   key_id)
 {
   return g_datalist_id_dup_data (datalist, key_id, NULL, NULL);
 }
 
 /**
@@ -982,11 +982,11 @@
       GData *old_d;
 
       /* insert newval */
       old_d = d;
       if (d == NULL)
-    {
+  {
           d = g_malloc (sizeof (GData));
           d->len = 0;
           d->alloc = 1;
         }
       else if (d->len == d->alloc)
@@ -1019,11 +1019,11 @@
  * Returns: (transfer none) (nullable): the data element, or %NULL if it
  *          is not found.
  **/
 gpointer
 g_datalist_get_data (GData   **datalist,
-                     const gchar *key)
+         const gchar *key)
 {
   gpointer res = NULL;
   GData *d;
   GDataElt *data, *data_end;
 
@@ -1035,18 +1035,18 @@
   if (d)
     {
       data = d->data;
       data_end = data + d->len;
       while (data < data_end)
-    {
-      if (g_strcmp0 (g_quark_to_string (data->key), key) == 0)
-        {
-          res = data->data;
-          break;
-        }
-      data++;
-    }
+  {
+    if (g_strcmp0 (g_quark_to_string (data->key), key) == 0)
+      {
+        res = data->data;
+        break;
+      }
+    data++;
+  }
     }
 
   g_datalist_unlock (datalist);
 
   return res;
@@ -1078,12 +1078,12 @@
  * reflect changes made during the g_dataset_foreach() call, other
  * than skipping over elements that are removed.
  **/
 void
 g_dataset_foreach (gconstpointer    dataset_location,
-           GDataForeachFunc func,
-           gpointer         user_data)
+       GDataForeachFunc func,
+       gpointer         user_data)
 {
   GDataset *dataset;
 
   g_return_if_fail (dataset_location != NULL);
   g_return_if_fail (func != NULL);
@@ -1092,11 +1092,11 @@
   if (g_dataset_location_ht)
     {
       dataset = g_dataset_lookup (dataset_location);
       G_UNLOCK (g_dataset_global);
       if (dataset)
-    g_datalist_foreach (&dataset->datalist, func, user_data);
+  g_datalist_foreach (&dataset->datalist, func, user_data);
     }
   else
     {
       G_UNLOCK (g_dataset_global);
     }
@@ -1118,16 +1118,16 @@
  * @func can make changes to @datalist, but the iteration will not
  * reflect changes made during the g_datalist_foreach() call, other
  * than skipping over elements that are removed.
  **/
 void
-g_datalist_foreach (GData      **datalist,
-                    GDataForeachFunc func,
-                    gpointer         user_data)
+g_datalist_foreach (GData    **datalist,
+        GDataForeachFunc func,
+        gpointer         user_data)
 {
   GData *d;
-  int i, j, len;
+  guint i, j, len;
   GQuark *keys;
 
   g_return_if_fail (datalist != NULL);
   g_return_if_fail (func != NULL);
 
@@ -1143,22 +1143,22 @@
     keys[i] = d->data[i].key;
 
   for (i = 0; i < len; i++)
     {
       /* A previous callback might have removed a later item, so always check that
-     it still exists before calling */
+   it still exists before calling */
       d = G_DATALIST_GET_POINTER (datalist);
 
       if (d == NULL)
-    break;
+  break;
       for (j = 0; j < d->len; j++)
-    {
-      if (d->data[j].key == keys[i]) {
-        func (d->data[i].key, d->data[i].data, user_data);
-        break;
-      }
+  {
+    if (d->data[j].key == keys[i]) {
+      func (d->data[i].key, d->data[i].data, user_data);
+      break;
     }
+  }
     }
   g_free (keys);
 }
 
 /**
@@ -1194,11 +1194,11 @@
  *
  * Since: 2.8
  **/
 void
 g_datalist_set_flags (GData **datalist,
-                      guint   flags)
+          guint   flags)
 {
   g_return_if_fail (datalist != NULL);
   g_return_if_fail ((flags & ~G_DATALIST_FLAGS_MASK) == 0);
 
   g_atomic_pointer_or (datalist, (gsize)flags);
@@ -1217,11 +1217,11 @@
  *
  * Since: 2.8
  **/
 void
 g_datalist_unset_flags (GData **datalist,
-                        guint   flags)
+      guint   flags)
 {
   g_return_if_fail (datalist != NULL);
   g_return_if_fail ((flags & ~G_DATALIST_FLAGS_MASK) == 0);
 
   g_atomic_pointer_and (datalist, ~(gsize)flags);
