<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/app/gstappsink.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GStreamer
   2  * Copyright (C) 2007 David Schleef &lt;ds@schleef.org&gt;
   3  *           (C) 2008 Wim Taymans &lt;wim.taymans@gmail.com&gt;
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Library General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Library General Public
  16  * License along with this library; if not, write to the
  17  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  18  * Boston, MA 02110-1301, USA.
  19  */
  20 /**
  21  * SECTION:gstappsink
  22  * @title: GstAppSink
  23  * @short_description: Easy way for applications to extract samples from a
  24  *     pipeline
  25  * @see_also: #GstSample, #GstBaseSink, appsrc
  26  *
  27  * Appsink is a sink plugin that supports many different methods for making
  28  * the application get a handle on the GStreamer data in a pipeline. Unlike
  29  * most GStreamer elements, Appsink provides external API functions.
  30  *
  31  * appsink can be used by linking to the gstappsink.h header file to access the
  32  * methods or by using the appsink action signals and properties.
  33  *
  34  * The normal way of retrieving samples from appsink is by using the
  35  * gst_app_sink_pull_sample() and gst_app_sink_pull_preroll() methods.
  36  * These methods block until a sample becomes available in the sink or when the
  37  * sink is shut down or reaches EOS. There are also timed variants of these
  38  * methods, gst_app_sink_try_pull_sample() and gst_app_sink_try_pull_preroll(),
  39  * which accept a timeout parameter to limit the amount of time to wait.
  40  *
  41  * Appsink will internally use a queue to collect buffers from the streaming
  42  * thread. If the application is not pulling samples fast enough, this queue
  43  * will consume a lot of memory over time. The &quot;max-buffers&quot; property can be
  44  * used to limit the queue size. The &quot;drop&quot; property controls whether the
  45  * streaming thread blocks or if older buffers are dropped when the maximum
  46  * queue size is reached. Note that blocking the streaming thread can negatively
  47  * affect real-time performance and should be avoided.
  48  *
  49  * If a blocking behaviour is not desirable, setting the &quot;emit-signals&quot; property
  50  * to %TRUE will make appsink emit the &quot;new-sample&quot; and &quot;new-preroll&quot; signals
  51  * when a sample can be pulled without blocking.
  52  *
  53  * The &quot;caps&quot; property on appsink can be used to control the formats that
  54  * appsink can receive. This property can contain non-fixed caps, the format of
  55  * the pulled samples can be obtained by getting the sample caps.
  56  *
  57  * If one of the pull-preroll or pull-sample methods return %NULL, the appsink
  58  * is stopped or in the EOS state. You can check for the EOS state with the
  59  * &quot;eos&quot; property or with the gst_app_sink_is_eos() method.
  60  *
  61  * The eos signal can also be used to be informed when the EOS state is reached
  62  * to avoid polling.
  63  */
  64 
  65 #ifdef HAVE_CONFIG_H
  66 #include &quot;config.h&quot;
  67 #endif
  68 
  69 #include &lt;gst/gst.h&gt;
  70 #include &lt;gst/base/base.h&gt;
  71 
  72 #include &lt;string.h&gt;
  73 
  74 #include &quot;gstappsink.h&quot;
  75 
  76 typedef enum
  77 {
  78   NOONE_WAITING = 0,
  79   STREAM_WAITING = 1 &lt;&lt; 0,      /* streaming thread is waiting for application thread */
  80   APP_WAITING = 1 &lt;&lt; 1,         /* application thread is waiting for streaming thread */
  81 } GstAppSinkWaitStatus;
  82 
  83 struct _GstAppSinkPrivate
  84 {
  85   GstCaps *caps;
  86   gboolean emit_signals;
  87   guint num_buffers;
  88   guint max_buffers;
  89   gboolean drop;
  90   gboolean wait_on_eos;
  91   GstAppSinkWaitStatus wait_status;
  92 
  93   GCond cond;
  94   GMutex mutex;
  95   GstQueueArray *queue;
  96   GstBuffer *preroll_buffer;
  97   GstCaps *preroll_caps;
  98   GstCaps *last_caps;
  99   GstSegment preroll_segment;
 100   GstSegment last_segment;
 101   gboolean flushing;
 102   gboolean unlock;
 103   gboolean started;
 104   gboolean is_eos;
 105   gboolean buffer_lists_supported;
 106 
 107   GstAppSinkCallbacks callbacks;
 108   gpointer user_data;
 109   GDestroyNotify notify;
 110 };
 111 
 112 GST_DEBUG_CATEGORY_STATIC (app_sink_debug);
 113 #define GST_CAT_DEFAULT app_sink_debug
 114 
 115 enum
 116 {
 117   /* signals */
 118   SIGNAL_EOS,
 119   SIGNAL_NEW_PREROLL,
 120   SIGNAL_NEW_SAMPLE,
 121 
 122   /* actions */
 123   SIGNAL_PULL_PREROLL,
 124   SIGNAL_PULL_SAMPLE,
 125   SIGNAL_TRY_PULL_PREROLL,
 126   SIGNAL_TRY_PULL_SAMPLE,
 127 
 128   LAST_SIGNAL
 129 };
 130 
 131 #define DEFAULT_PROP_EOS        TRUE
 132 #define DEFAULT_PROP_EMIT_SIGNALS   FALSE
 133 #define DEFAULT_PROP_MAX_BUFFERS    0
 134 #define DEFAULT_PROP_DROP       FALSE
 135 #define DEFAULT_PROP_WAIT_ON_EOS    TRUE
 136 #define DEFAULT_PROP_BUFFER_LIST    FALSE
 137 
 138 enum
 139 {
 140   PROP_0,
 141   PROP_CAPS,
 142   PROP_EOS,
 143   PROP_EMIT_SIGNALS,
 144   PROP_MAX_BUFFERS,
 145   PROP_DROP,
 146   PROP_WAIT_ON_EOS,
 147   PROP_BUFFER_LIST,
 148   PROP_LAST
 149 };
 150 
 151 static GstStaticPadTemplate gst_app_sink_template =
 152 GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,
 153     GST_PAD_SINK,
 154     GST_PAD_ALWAYS,
 155     GST_STATIC_CAPS_ANY);
 156 
 157 static void gst_app_sink_uri_handler_init (gpointer g_iface,
 158     gpointer iface_data);
 159 
 160 static void gst_app_sink_dispose (GObject * object);
 161 static void gst_app_sink_finalize (GObject * object);
 162 
 163 static void gst_app_sink_set_property (GObject * object, guint prop_id,
 164     const GValue * value, GParamSpec * pspec);
 165 static void gst_app_sink_get_property (GObject * object, guint prop_id,
 166     GValue * value, GParamSpec * pspec);
 167 
 168 static gboolean gst_app_sink_unlock_start (GstBaseSink * bsink);
 169 static gboolean gst_app_sink_unlock_stop (GstBaseSink * bsink);
 170 static gboolean gst_app_sink_start (GstBaseSink * psink);
 171 static gboolean gst_app_sink_stop (GstBaseSink * psink);
 172 static gboolean gst_app_sink_event (GstBaseSink * sink, GstEvent * event);
 173 static gboolean gst_app_sink_query (GstBaseSink * bsink, GstQuery * query);
 174 static GstFlowReturn gst_app_sink_preroll (GstBaseSink * psink,
 175     GstBuffer * buffer);
 176 static GstFlowReturn gst_app_sink_render_common (GstBaseSink * psink,
 177     GstMiniObject * data, gboolean is_list);
 178 static GstFlowReturn gst_app_sink_render (GstBaseSink * psink,
 179     GstBuffer * buffer);
 180 static GstFlowReturn gst_app_sink_render_list (GstBaseSink * psink,
 181     GstBufferList * list);
 182 static gboolean gst_app_sink_setcaps (GstBaseSink * sink, GstCaps * caps);
 183 static GstCaps *gst_app_sink_getcaps (GstBaseSink * psink, GstCaps * filter);
 184 
 185 static guint gst_app_sink_signals[LAST_SIGNAL] = { 0 };
 186 
 187 #define gst_app_sink_parent_class parent_class
 188 G_DEFINE_TYPE_WITH_CODE (GstAppSink, gst_app_sink, GST_TYPE_BASE_SINK,
 189     G_IMPLEMENT_INTERFACE (GST_TYPE_URI_HANDLER,
 190         gst_app_sink_uri_handler_init));
 191 
 192 static void
 193 gst_app_sink_class_init (GstAppSinkClass * klass)
 194 {
 195   GObjectClass *gobject_class = (GObjectClass *) klass;
 196   GstElementClass *element_class = (GstElementClass *) klass;
 197   GstBaseSinkClass *basesink_class = (GstBaseSinkClass *) klass;
 198 
 199   GST_DEBUG_CATEGORY_INIT (app_sink_debug, &quot;appsink&quot;, 0, &quot;appsink element&quot;);
 200 
 201   gobject_class-&gt;dispose = gst_app_sink_dispose;
 202   gobject_class-&gt;finalize = gst_app_sink_finalize;
 203 
 204   gobject_class-&gt;set_property = gst_app_sink_set_property;
 205   gobject_class-&gt;get_property = gst_app_sink_get_property;
 206 
 207   g_object_class_install_property (gobject_class, PROP_CAPS,
 208       g_param_spec_boxed (&quot;caps&quot;, &quot;Caps&quot;,
 209           &quot;The allowed caps for the sink pad&quot;, GST_TYPE_CAPS,
 210           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 211 
 212   g_object_class_install_property (gobject_class, PROP_EOS,
 213       g_param_spec_boolean (&quot;eos&quot;, &quot;EOS&quot;,
 214           &quot;Check if the sink is EOS or not started&quot;, DEFAULT_PROP_EOS,
 215           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 216 
 217   g_object_class_install_property (gobject_class, PROP_EMIT_SIGNALS,
 218       g_param_spec_boolean (&quot;emit-signals&quot;, &quot;Emit signals&quot;,
 219           &quot;Emit new-preroll and new-sample signals&quot;,
 220           DEFAULT_PROP_EMIT_SIGNALS,
 221           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 222 
 223   g_object_class_install_property (gobject_class, PROP_MAX_BUFFERS,
 224       g_param_spec_uint (&quot;max-buffers&quot;, &quot;Max Buffers&quot;,
 225           &quot;The maximum number of buffers to queue internally (0 = unlimited)&quot;,
 226           0, G_MAXUINT, DEFAULT_PROP_MAX_BUFFERS,
 227           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 228 
 229   g_object_class_install_property (gobject_class, PROP_DROP,
 230       g_param_spec_boolean (&quot;drop&quot;, &quot;Drop&quot;,
 231           &quot;Drop old buffers when the buffer queue is filled&quot;, DEFAULT_PROP_DROP,
 232           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 233 
 234   g_object_class_install_property (gobject_class, PROP_BUFFER_LIST,
 235       g_param_spec_boolean (&quot;buffer-list&quot;, &quot;Buffer List&quot;,
 236           &quot;Use buffer lists&quot;, DEFAULT_PROP_BUFFER_LIST,
 237           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 238   /**
 239    * GstAppSink::wait-on-eos:
 240    *
 241    * Wait for all buffers to be processed after receiving an EOS.
 242    *
 243    * In cases where it is uncertain if an @appsink will have a consumer for its buffers
 244    * when it receives an EOS, set to %FALSE to ensure that the @appsink will not hang.
 245    *
 246    * Since: 1.8
 247    */
 248   g_object_class_install_property (gobject_class, PROP_WAIT_ON_EOS,
 249       g_param_spec_boolean (&quot;wait-on-eos&quot;, &quot;Wait on EOS&quot;,
 250           &quot;Wait for all buffers to be processed after receiving an EOS&quot;,
 251           DEFAULT_PROP_WAIT_ON_EOS,
 252           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 253 
 254   /**
 255    * GstAppSink::eos:
 256    * @appsink: the appsink element that emitted the signal
 257    *
 258    * Signal that the end-of-stream has been reached. This signal is emitted from
 259    * the streaming thread.
 260    */
 261   gst_app_sink_signals[SIGNAL_EOS] =
 262       g_signal_new (&quot;eos&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 263       G_STRUCT_OFFSET (GstAppSinkClass, eos),
 264       NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0, G_TYPE_NONE);
 265   /**
 266    * GstAppSink::new-preroll:
 267    * @appsink: the appsink element that emitted the signal
 268    *
 269    * Signal that a new preroll sample is available.
 270    *
 271    * This signal is emitted from the streaming thread and only when the
 272    * &quot;emit-signals&quot; property is %TRUE.
 273    *
 274    * The new preroll sample can be retrieved with the &quot;pull-preroll&quot; action
 275    * signal or gst_app_sink_pull_preroll() either from this signal callback
 276    * or from any other thread.
 277    *
 278    * Note that this signal is only emitted when the &quot;emit-signals&quot; property is
 279    * set to %TRUE, which it is not by default for performance reasons.
 280    */
 281   gst_app_sink_signals[SIGNAL_NEW_PREROLL] =
 282       g_signal_new (&quot;new-preroll&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 283       G_STRUCT_OFFSET (GstAppSinkClass, new_preroll),
 284       NULL, NULL, NULL, GST_TYPE_FLOW_RETURN, 0, G_TYPE_NONE);
 285   /**
 286    * GstAppSink::new-sample:
 287    * @appsink: the appsink element that emited the signal
 288    *
 289    * Signal that a new sample is available.
 290    *
 291    * This signal is emitted from the streaming thread and only when the
 292    * &quot;emit-signals&quot; property is %TRUE.
 293    *
 294    * The new sample can be retrieved with the &quot;pull-sample&quot; action
 295    * signal or gst_app_sink_pull_sample() either from this signal callback
 296    * or from any other thread.
 297    *
 298    * Note that this signal is only emitted when the &quot;emit-signals&quot; property is
 299    * set to %TRUE, which it is not by default for performance reasons.
 300    */
 301   gst_app_sink_signals[SIGNAL_NEW_SAMPLE] =
 302       g_signal_new (&quot;new-sample&quot;, G_TYPE_FROM_CLASS (klass), G_SIGNAL_RUN_LAST,
 303       G_STRUCT_OFFSET (GstAppSinkClass, new_sample),
 304       NULL, NULL, NULL, GST_TYPE_FLOW_RETURN, 0, G_TYPE_NONE);
 305 
 306   /**
 307    * GstAppSink::pull-preroll:
 308    * @appsink: the appsink element to emit this signal on
 309    *
 310    * Get the last preroll sample in @appsink. This was the sample that caused the
 311    * appsink to preroll in the PAUSED state.
 312    *
 313    * This function is typically used when dealing with a pipeline in the PAUSED
 314    * state. Calling this function after doing a seek will give the sample right
 315    * after the seek position.
 316    *
 317    * Calling this function will clear the internal reference to the preroll
 318    * buffer.
 319    *
 320    * Note that the preroll sample will also be returned as the first sample
 321    * when calling gst_app_sink_pull_sample() or the &quot;pull-sample&quot; action signal.
 322    *
 323    * If an EOS event was received before any buffers, this function returns
 324    * %NULL. Use gst_app_sink_is_eos () to check for the EOS condition.
 325    *
 326    * This function blocks until a preroll sample or EOS is received or the appsink
 327    * element is set to the READY/NULL state.
 328    *
 329    * Returns: a #GstSample or NULL when the appsink is stopped or EOS.
 330    */
 331   gst_app_sink_signals[SIGNAL_PULL_PREROLL] =
 332       g_signal_new (&quot;pull-preroll&quot;, G_TYPE_FROM_CLASS (klass),
 333       G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION, G_STRUCT_OFFSET (GstAppSinkClass,
 334           pull_preroll), NULL, NULL, NULL, GST_TYPE_SAMPLE, 0, G_TYPE_NONE);
 335   /**
 336    * GstAppSink::pull-sample:
 337    * @appsink: the appsink element to emit this signal on
 338    *
 339    * This function blocks until a sample or EOS becomes available or the appsink
 340    * element is set to the READY/NULL state.
 341    *
 342    * This function will only return samples when the appsink is in the PLAYING
 343    * state. All rendered samples will be put in a queue so that the application
 344    * can pull samples at its own rate.
 345    *
 346    * Note that when the application does not pull samples fast enough, the
 347    * queued samples could consume a lot of memory, especially when dealing with
 348    * raw video frames. It&#39;s possible to control the behaviour of the queue with
 349    * the &quot;drop&quot; and &quot;max-buffers&quot; properties.
 350    *
 351    * If an EOS event was received before any buffers, this function returns
 352    * %NULL. Use gst_app_sink_is_eos () to check for the EOS condition.
 353    *
 354    * Returns: a #GstSample or NULL when the appsink is stopped or EOS.
 355    */
 356   gst_app_sink_signals[SIGNAL_PULL_SAMPLE] =
 357       g_signal_new (&quot;pull-sample&quot;, G_TYPE_FROM_CLASS (klass),
 358       G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION, G_STRUCT_OFFSET (GstAppSinkClass,
 359           pull_sample), NULL, NULL, NULL, GST_TYPE_SAMPLE, 0, G_TYPE_NONE);
 360   /**
 361    * GstAppSink::try-pull-preroll:
 362    * @appsink: the appsink element to emit this signal on
 363    * @timeout: the maximum amount of time to wait for the preroll sample
 364    *
 365    * Get the last preroll sample in @appsink. This was the sample that caused the
 366    * appsink to preroll in the PAUSED state.
 367    *
 368    * This function is typically used when dealing with a pipeline in the PAUSED
 369    * state. Calling this function after doing a seek will give the sample right
 370    * after the seek position.
 371    *
 372    * Calling this function will clear the internal reference to the preroll
 373    * buffer.
 374    *
 375    * Note that the preroll sample will also be returned as the first sample
 376    * when calling gst_app_sink_pull_sample() or the &quot;pull-sample&quot; action signal.
 377    *
 378    * If an EOS event was received before any buffers or the timeout expires,
 379    * this function returns %NULL. Use gst_app_sink_is_eos () to check for the EOS
 380    * condition.
 381    *
 382    * This function blocks until a preroll sample or EOS is received, the appsink
 383    * element is set to the READY/NULL state, or the timeout expires.
 384    *
 385    * Returns: a #GstSample or NULL when the appsink is stopped or EOS or the timeout expires.
 386    *
 387    * Since: 1.10
 388    */
 389   gst_app_sink_signals[SIGNAL_TRY_PULL_PREROLL] =
 390       g_signal_new (&quot;try-pull-preroll&quot;, G_TYPE_FROM_CLASS (klass),
 391       G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
 392       G_STRUCT_OFFSET (GstAppSinkClass, try_pull_preroll), NULL, NULL, NULL,
 393       GST_TYPE_SAMPLE, 1, GST_TYPE_CLOCK_TIME);
 394   /**
 395    * GstAppSink::try-pull-sample:
 396    * @appsink: the appsink element to emit this signal on
 397    * @timeout: the maximum amount of time to wait for a sample
 398    *
 399    * This function blocks until a sample or EOS becomes available or the appsink
 400    * element is set to the READY/NULL state or the timeout expires.
 401    *
 402    * This function will only return samples when the appsink is in the PLAYING
 403    * state. All rendered samples will be put in a queue so that the application
 404    * can pull samples at its own rate.
 405    *
 406    * Note that when the application does not pull samples fast enough, the
 407    * queued samples could consume a lot of memory, especially when dealing with
 408    * raw video frames. It&#39;s possible to control the behaviour of the queue with
 409    * the &quot;drop&quot; and &quot;max-buffers&quot; properties.
 410    *
 411    * If an EOS event was received before any buffers or the timeout expires,
 412    * this function returns %NULL. Use gst_app_sink_is_eos () to check
 413    * for the EOS condition.
 414    *
 415    * Returns: a #GstSample or NULL when the appsink is stopped or EOS or the timeout expires.
 416    *
 417    * Since: 1.10
 418    */
 419   gst_app_sink_signals[SIGNAL_TRY_PULL_SAMPLE] =
 420       g_signal_new (&quot;try-pull-sample&quot;, G_TYPE_FROM_CLASS (klass),
 421       G_SIGNAL_RUN_LAST | G_SIGNAL_ACTION,
 422       G_STRUCT_OFFSET (GstAppSinkClass, try_pull_sample), NULL, NULL, NULL,
 423       GST_TYPE_SAMPLE, 1, GST_TYPE_CLOCK_TIME);
 424 
 425   gst_element_class_set_static_metadata (element_class, &quot;AppSink&quot;,
 426       &quot;Generic/Sink&quot;, &quot;Allow the application to get access to raw buffer&quot;,
 427       &quot;David Schleef &lt;ds@schleef.org&gt;, Wim Taymans &lt;wim.taymans@gmail.com&gt;&quot;);
 428 
 429   gst_element_class_add_static_pad_template (element_class,
 430       &amp;gst_app_sink_template);
 431 
 432   basesink_class-&gt;unlock = gst_app_sink_unlock_start;
 433   basesink_class-&gt;unlock_stop = gst_app_sink_unlock_stop;
 434   basesink_class-&gt;start = gst_app_sink_start;
 435   basesink_class-&gt;stop = gst_app_sink_stop;
 436   basesink_class-&gt;event = gst_app_sink_event;
 437   basesink_class-&gt;preroll = gst_app_sink_preroll;
 438   basesink_class-&gt;render = gst_app_sink_render;
 439   basesink_class-&gt;render_list = gst_app_sink_render_list;
 440   basesink_class-&gt;get_caps = gst_app_sink_getcaps;
 441   basesink_class-&gt;set_caps = gst_app_sink_setcaps;
 442   basesink_class-&gt;query = gst_app_sink_query;
 443 
 444   klass-&gt;pull_preroll = gst_app_sink_pull_preroll;
 445   klass-&gt;pull_sample = gst_app_sink_pull_sample;
 446   klass-&gt;try_pull_preroll = gst_app_sink_try_pull_preroll;
 447   klass-&gt;try_pull_sample = gst_app_sink_try_pull_sample;
 448 
 449   g_type_class_add_private (klass, sizeof (GstAppSinkPrivate));
 450 }
 451 
 452 static void
 453 gst_app_sink_init (GstAppSink * appsink)
 454 {
 455   GstAppSinkPrivate *priv;
 456 
 457   priv = appsink-&gt;priv =
 458       G_TYPE_INSTANCE_GET_PRIVATE (appsink, GST_TYPE_APP_SINK,
 459       GstAppSinkPrivate);
 460 
 461   g_mutex_init (&amp;priv-&gt;mutex);
 462   g_cond_init (&amp;priv-&gt;cond);
 463   priv-&gt;queue = gst_queue_array_new (16);
 464 
 465   priv-&gt;emit_signals = DEFAULT_PROP_EMIT_SIGNALS;
 466   priv-&gt;max_buffers = DEFAULT_PROP_MAX_BUFFERS;
 467   priv-&gt;drop = DEFAULT_PROP_DROP;
 468   priv-&gt;wait_on_eos = DEFAULT_PROP_WAIT_ON_EOS;
 469   priv-&gt;buffer_lists_supported = DEFAULT_PROP_BUFFER_LIST;
 470   priv-&gt;wait_status = NOONE_WAITING;
 471 }
 472 
 473 static void
 474 gst_app_sink_dispose (GObject * obj)
 475 {
 476   GstAppSink *appsink = GST_APP_SINK_CAST (obj);
 477   GstAppSinkPrivate *priv = appsink-&gt;priv;
 478   GstMiniObject *queue_obj;
 479 
 480   GST_OBJECT_LOCK (appsink);
 481   if (priv-&gt;caps) {
 482     gst_caps_unref (priv-&gt;caps);
 483     priv-&gt;caps = NULL;
 484   }
 485   if (priv-&gt;notify) {
 486     priv-&gt;notify (priv-&gt;user_data);
 487   }
 488   priv-&gt;user_data = NULL;
 489   priv-&gt;notify = NULL;
 490 
 491   GST_OBJECT_UNLOCK (appsink);
 492 
 493   g_mutex_lock (&amp;priv-&gt;mutex);
 494   while ((queue_obj = gst_queue_array_pop_head (priv-&gt;queue)))
 495     gst_mini_object_unref (queue_obj);
 496   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
 497   gst_caps_replace (&amp;priv-&gt;preroll_caps, NULL);
 498   gst_caps_replace (&amp;priv-&gt;last_caps, NULL);
 499   g_mutex_unlock (&amp;priv-&gt;mutex);
 500 
 501   G_OBJECT_CLASS (parent_class)-&gt;dispose (obj);
 502 }
 503 
 504 static void
 505 gst_app_sink_finalize (GObject * obj)
 506 {
 507   GstAppSink *appsink = GST_APP_SINK_CAST (obj);
 508   GstAppSinkPrivate *priv = appsink-&gt;priv;
 509 
 510   g_mutex_clear (&amp;priv-&gt;mutex);
 511   g_cond_clear (&amp;priv-&gt;cond);
 512   gst_queue_array_free (priv-&gt;queue);
 513 
 514   G_OBJECT_CLASS (parent_class)-&gt;finalize (obj);
 515 }
 516 
 517 static void
 518 gst_app_sink_set_property (GObject * object, guint prop_id,
 519     const GValue * value, GParamSpec * pspec)
 520 {
 521   GstAppSink *appsink = GST_APP_SINK_CAST (object);
 522 
 523   switch (prop_id) {
 524     case PROP_CAPS:
 525       gst_app_sink_set_caps (appsink, gst_value_get_caps (value));
 526       break;
 527     case PROP_EMIT_SIGNALS:
 528       gst_app_sink_set_emit_signals (appsink, g_value_get_boolean (value));
 529       break;
 530     case PROP_MAX_BUFFERS:
 531       gst_app_sink_set_max_buffers (appsink, g_value_get_uint (value));
 532       break;
 533     case PROP_DROP:
 534       gst_app_sink_set_drop (appsink, g_value_get_boolean (value));
 535       break;
 536     case PROP_BUFFER_LIST:
 537       gst_app_sink_set_buffer_list_support (appsink,
 538           g_value_get_boolean (value));
 539       break;
 540     case PROP_WAIT_ON_EOS:
 541       gst_app_sink_set_wait_on_eos (appsink, g_value_get_boolean (value));
 542       break;
 543     default:
 544       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 545       break;
 546   }
 547 }
 548 
 549 static void
 550 gst_app_sink_get_property (GObject * object, guint prop_id, GValue * value,
 551     GParamSpec * pspec)
 552 {
 553   GstAppSink *appsink = GST_APP_SINK_CAST (object);
 554 
 555   switch (prop_id) {
 556     case PROP_CAPS:
 557     {
 558       GstCaps *caps;
 559 
 560       caps = gst_app_sink_get_caps (appsink);
 561       gst_value_set_caps (value, caps);
 562       if (caps)
 563         gst_caps_unref (caps);
 564       break;
 565     }
 566     case PROP_EOS:
 567       g_value_set_boolean (value, gst_app_sink_is_eos (appsink));
 568       break;
 569     case PROP_EMIT_SIGNALS:
 570       g_value_set_boolean (value, gst_app_sink_get_emit_signals (appsink));
 571       break;
 572     case PROP_MAX_BUFFERS:
 573       g_value_set_uint (value, gst_app_sink_get_max_buffers (appsink));
 574       break;
 575     case PROP_DROP:
 576       g_value_set_boolean (value, gst_app_sink_get_drop (appsink));
 577       break;
 578     case PROP_BUFFER_LIST:
 579       g_value_set_boolean (value,
 580           gst_app_sink_get_buffer_list_support (appsink));
 581       break;
 582     case PROP_WAIT_ON_EOS:
 583       g_value_set_boolean (value, gst_app_sink_get_wait_on_eos (appsink));
 584       break;
 585     default:
 586       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 587       break;
 588   }
 589 }
 590 
 591 static gboolean
 592 gst_app_sink_unlock_start (GstBaseSink * bsink)
 593 {
 594   GstAppSink *appsink = GST_APP_SINK_CAST (bsink);
 595   GstAppSinkPrivate *priv = appsink-&gt;priv;
 596 
 597   g_mutex_lock (&amp;priv-&gt;mutex);
 598   GST_DEBUG_OBJECT (appsink, &quot;unlock start&quot;);
 599   priv-&gt;unlock = TRUE;
 600   g_cond_signal (&amp;priv-&gt;cond);
 601   g_mutex_unlock (&amp;priv-&gt;mutex);
 602 
 603   return TRUE;
 604 }
 605 
 606 static gboolean
 607 gst_app_sink_unlock_stop (GstBaseSink * bsink)
 608 {
 609   GstAppSink *appsink = GST_APP_SINK_CAST (bsink);
 610   GstAppSinkPrivate *priv = appsink-&gt;priv;
 611 
 612   g_mutex_lock (&amp;priv-&gt;mutex);
 613   GST_DEBUG_OBJECT (appsink, &quot;unlock stop&quot;);
 614   priv-&gt;unlock = FALSE;
 615   g_cond_signal (&amp;priv-&gt;cond);
 616   g_mutex_unlock (&amp;priv-&gt;mutex);
 617 
 618   return TRUE;
 619 }
 620 
 621 static void
 622 gst_app_sink_flush_unlocked (GstAppSink * appsink)
 623 {
 624   GstMiniObject *obj;
 625   GstAppSinkPrivate *priv = appsink-&gt;priv;
 626 
 627   GST_DEBUG_OBJECT (appsink, &quot;flush stop appsink&quot;);
 628   priv-&gt;is_eos = FALSE;
 629   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
 630 #ifdef GSTREAMER_LITE
 631   // Update last_caps if we have event pending.
 632   // We can get in situation when preroll_caps and last_caps does not match
 633   // and it will break HLS playback after seek. This happens when we received
 634   // caps event (preroll_caps is updated and event stored in queue (see gst_app_sink_setcaps()))
 635   // and then flush (during seek). After, seek is done first preroll buffer will be
 636   // send with preroll_caps and all sequential buffers will be send with last_caps.
 637   while ((obj = gst_queue_array_pop_head (priv-&gt;queue))) {
 638     if (GST_IS_EVENT (obj)) {
 639       if (GST_EVENT_TYPE (obj) == GST_EVENT_CAPS) {
 640         GstCaps *caps = NULL;
 641         GstEvent *event = GST_EVENT_CAST (obj);
 642         gst_event_parse_caps (event, &amp;caps);
 643         gst_caps_replace (&amp;priv-&gt;last_caps, caps);
 644       }
 645     }
 646     gst_mini_object_unref (obj);
 647   }
 648 #else // GSTREAMER_LITE
 649   while ((obj = gst_queue_array_pop_head (priv-&gt;queue)))
 650     gst_mini_object_unref (obj);
 651 #endif // GSTREAMER_LITE
 652   priv-&gt;num_buffers = 0;
 653   g_cond_signal (&amp;priv-&gt;cond);
 654 }
 655 
 656 static gboolean
 657 gst_app_sink_start (GstBaseSink * psink)
 658 {
 659   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
 660   GstAppSinkPrivate *priv = appsink-&gt;priv;
 661 
 662   g_mutex_lock (&amp;priv-&gt;mutex);
 663   GST_DEBUG_OBJECT (appsink, &quot;starting&quot;);
 664   priv-&gt;wait_status = NOONE_WAITING;
 665   priv-&gt;flushing = FALSE;
 666   priv-&gt;started = TRUE;
 667   gst_segment_init (&amp;priv-&gt;preroll_segment, GST_FORMAT_TIME);
 668   gst_segment_init (&amp;priv-&gt;last_segment, GST_FORMAT_TIME);
 669   g_mutex_unlock (&amp;priv-&gt;mutex);
 670 
 671   return TRUE;
 672 }
 673 
 674 static gboolean
 675 gst_app_sink_stop (GstBaseSink * psink)
 676 {
 677   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
 678   GstAppSinkPrivate *priv = appsink-&gt;priv;
 679 
 680   g_mutex_lock (&amp;priv-&gt;mutex);
 681   GST_DEBUG_OBJECT (appsink, &quot;stopping&quot;);
 682   priv-&gt;flushing = TRUE;
 683   priv-&gt;started = FALSE;
 684   priv-&gt;wait_status = NOONE_WAITING;
 685   gst_app_sink_flush_unlocked (appsink);
 686   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
 687   gst_caps_replace (&amp;priv-&gt;preroll_caps, NULL);
 688   gst_caps_replace (&amp;priv-&gt;last_caps, NULL);
 689   gst_segment_init (&amp;priv-&gt;preroll_segment, GST_FORMAT_UNDEFINED);
 690   gst_segment_init (&amp;priv-&gt;last_segment, GST_FORMAT_UNDEFINED);
 691   g_mutex_unlock (&amp;priv-&gt;mutex);
 692 
 693   return TRUE;
 694 }
 695 
 696 static gboolean
 697 gst_app_sink_setcaps (GstBaseSink * sink, GstCaps * caps)
 698 {
 699   GstAppSink *appsink = GST_APP_SINK_CAST (sink);
 700   GstAppSinkPrivate *priv = appsink-&gt;priv;
 701 
 702   g_mutex_lock (&amp;priv-&gt;mutex);
 703   GST_DEBUG_OBJECT (appsink, &quot;receiving CAPS&quot;);
 704   gst_queue_array_push_tail (priv-&gt;queue, gst_event_new_caps (caps));
 705   if (!priv-&gt;preroll_buffer)
 706   gst_caps_replace (&amp;priv-&gt;preroll_caps, caps);
 707   g_mutex_unlock (&amp;priv-&gt;mutex);
 708 
 709   return TRUE;
 710 }
 711 
 712 static gboolean
 713 gst_app_sink_event (GstBaseSink * sink, GstEvent * event)
 714 {
 715   GstAppSink *appsink = GST_APP_SINK_CAST (sink);
 716   GstAppSinkPrivate *priv = appsink-&gt;priv;
 717 
 718   switch (event-&gt;type) {
 719     case GST_EVENT_SEGMENT:
 720       g_mutex_lock (&amp;priv-&gt;mutex);
 721       GST_DEBUG_OBJECT (appsink, &quot;receiving SEGMENT&quot;);
 722       gst_queue_array_push_tail (priv-&gt;queue, gst_event_ref (event));
 723       if (!priv-&gt;preroll_buffer)
 724         gst_event_copy_segment (event, &amp;priv-&gt;preroll_segment);
 725       g_mutex_unlock (&amp;priv-&gt;mutex);
 726       break;
 727     case GST_EVENT_EOS:{
 728       gboolean emit = TRUE;
 729 
 730       g_mutex_lock (&amp;priv-&gt;mutex);
 731       GST_DEBUG_OBJECT (appsink, &quot;receiving EOS&quot;);
 732       priv-&gt;is_eos = TRUE;
 733       g_cond_signal (&amp;priv-&gt;cond);
 734       g_mutex_unlock (&amp;priv-&gt;mutex);
 735 
 736       g_mutex_lock (&amp;priv-&gt;mutex);
 737       /* wait until all buffers are consumed or we&#39;re flushing.
 738        * Otherwise we might signal EOS before all buffers are
 739        * consumed, which is a bit confusing for the application
 740        */
 741       while (priv-&gt;num_buffers &gt; 0 &amp;&amp; !priv-&gt;flushing &amp;&amp; priv-&gt;wait_on_eos) {
 742         if (priv-&gt;unlock) {
 743           /* we are asked to unlock, call the wait_preroll method */
 744           g_mutex_unlock (&amp;priv-&gt;mutex);
 745           if (gst_base_sink_wait_preroll (sink) != GST_FLOW_OK) {
 746             /* Directly go out of here */
 747             gst_event_unref (event);
 748             return FALSE;
 749           }
 750 
 751           /* we are allowed to continue now */
 752           g_mutex_lock (&amp;priv-&gt;mutex);
 753           continue;
 754         }
 755 
 756         priv-&gt;wait_status |= STREAM_WAITING;
 757         g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);
 758         priv-&gt;wait_status &amp;= ~STREAM_WAITING;
 759       }
 760       if (priv-&gt;flushing)
 761         emit = FALSE;
 762       g_mutex_unlock (&amp;priv-&gt;mutex);
 763 
 764       if (emit) {
 765       /* emit EOS now */
 766       if (priv-&gt;callbacks.eos)
 767         priv-&gt;callbacks.eos (appsink, priv-&gt;user_data);
 768       else
 769         g_signal_emit (appsink, gst_app_sink_signals[SIGNAL_EOS], 0);
 770       }
 771 
 772       break;
 773     }
 774     case GST_EVENT_FLUSH_START:
 775       /* we don&#39;t have to do anything here, the base class will call unlock
 776        * which will make sure we exit the _render method */
 777       GST_DEBUG_OBJECT (appsink, &quot;received FLUSH_START&quot;);
 778       break;
 779     case GST_EVENT_FLUSH_STOP:
 780       g_mutex_lock (&amp;priv-&gt;mutex);
 781       GST_DEBUG_OBJECT (appsink, &quot;received FLUSH_STOP&quot;);
 782       gst_app_sink_flush_unlocked (appsink);
 783       g_mutex_unlock (&amp;priv-&gt;mutex);
 784       break;
 785     default:
 786       break;
 787   }
 788   return GST_BASE_SINK_CLASS (parent_class)-&gt;event (sink, event);
 789 }
 790 
 791 static GstFlowReturn
 792 gst_app_sink_preroll (GstBaseSink * psink, GstBuffer * buffer)
 793 {
 794   GstFlowReturn res;
 795   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
 796   GstAppSinkPrivate *priv = appsink-&gt;priv;
 797   gboolean emit;
 798 
 799   g_mutex_lock (&amp;priv-&gt;mutex);
 800   if (priv-&gt;flushing)
 801     goto flushing;
 802 
 803   GST_DEBUG_OBJECT (appsink, &quot;setting preroll buffer %p&quot;, buffer);
 804   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, buffer);
 805 
 806   if ((priv-&gt;wait_status &amp; APP_WAITING))
 807   g_cond_signal (&amp;priv-&gt;cond);
 808 
 809   emit = priv-&gt;emit_signals;
 810   g_mutex_unlock (&amp;priv-&gt;mutex);
 811 
 812   if (priv-&gt;callbacks.new_preroll) {
 813     res = priv-&gt;callbacks.new_preroll (appsink, priv-&gt;user_data);
 814   } else {
 815     res = GST_FLOW_OK;
 816     if (emit)
 817       g_signal_emit (appsink, gst_app_sink_signals[SIGNAL_NEW_PREROLL], 0,
 818           &amp;res);
 819   }
 820 
 821   return res;
 822 
 823 flushing:
 824   {
 825     GST_DEBUG_OBJECT (appsink, &quot;we are flushing&quot;);
 826     g_mutex_unlock (&amp;priv-&gt;mutex);
 827     return GST_FLOW_FLUSHING;
 828   }
 829 }
 830 
 831 static GstMiniObject *
 832 dequeue_buffer (GstAppSink * appsink)
 833 {
 834   GstAppSinkPrivate *priv = appsink-&gt;priv;
 835   GstMiniObject *obj;
 836 
 837   do {
 838     obj = gst_queue_array_pop_head (priv-&gt;queue);
 839 
 840     if (GST_IS_BUFFER (obj) || GST_IS_BUFFER_LIST (obj)) {
 841       GST_DEBUG_OBJECT (appsink, &quot;dequeued buffer/list %p&quot;, obj);
 842       priv-&gt;num_buffers--;
 843       break;
 844     } else if (GST_IS_EVENT (obj)) {
 845       GstEvent *event = GST_EVENT_CAST (obj);
 846 
 847       switch (GST_EVENT_TYPE (obj)) {
 848         case GST_EVENT_CAPS:
 849         {
 850           GstCaps *caps;
 851 
 852           gst_event_parse_caps (event, &amp;caps);
 853           GST_DEBUG_OBJECT (appsink, &quot;activating caps %&quot; GST_PTR_FORMAT, caps);
 854           gst_caps_replace (&amp;priv-&gt;last_caps, caps);
 855           break;
 856         }
 857         case GST_EVENT_SEGMENT:
 858           gst_event_copy_segment (event, &amp;priv-&gt;last_segment);
 859           GST_DEBUG_OBJECT (appsink, &quot;activated segment %&quot; GST_SEGMENT_FORMAT,
 860               &amp;priv-&gt;last_segment);
 861           break;
 862         default:
 863           break;
 864       }
 865       gst_mini_object_unref (obj);
 866     }
 867   } while (TRUE);
 868 
 869   return obj;
 870 }
 871 
 872 static GstFlowReturn
 873 gst_app_sink_render_common (GstBaseSink * psink, GstMiniObject * data,
 874     gboolean is_list)
 875 {
 876   GstFlowReturn ret;
 877   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
 878   GstAppSinkPrivate *priv = appsink-&gt;priv;
 879   gboolean emit;
 880 
 881 restart:
 882   g_mutex_lock (&amp;priv-&gt;mutex);
 883   if (priv-&gt;flushing)
 884     goto flushing;
 885 
 886   /* queue holding caps event might have been FLUSHed,
 887    * but caps state still present in pad caps */
 888   if (G_UNLIKELY (!priv-&gt;last_caps &amp;&amp;
 889           gst_pad_has_current_caps (GST_BASE_SINK_PAD (psink)))) {
 890     priv-&gt;last_caps = gst_pad_get_current_caps (GST_BASE_SINK_PAD (psink));
 891     GST_DEBUG_OBJECT (appsink, &quot;activating pad caps %&quot; GST_PTR_FORMAT,
 892         priv-&gt;last_caps);
 893   }
 894 
 895   GST_DEBUG_OBJECT (appsink, &quot;pushing render buffer/list %p on queue (%d)&quot;,
 896       data, priv-&gt;num_buffers);
 897 
 898   while (priv-&gt;max_buffers &gt; 0 &amp;&amp; priv-&gt;num_buffers &gt;= priv-&gt;max_buffers) {
 899     if (priv-&gt;drop) {
 900       GstMiniObject *old;
 901 
 902       /* we need to drop the oldest buffer/list and try again */
 903       if ((old = dequeue_buffer (appsink))) {
 904         GST_DEBUG_OBJECT (appsink, &quot;dropping old buffer/list %p&quot;, old);
 905         gst_mini_object_unref (old);
 906       }
 907     } else {
 908       GST_DEBUG_OBJECT (appsink, &quot;waiting for free space, length %d &gt;= %d&quot;,
 909           priv-&gt;num_buffers, priv-&gt;max_buffers);
 910 
 911       if (priv-&gt;unlock) {
 912         /* we are asked to unlock, call the wait_preroll method */
 913         g_mutex_unlock (&amp;priv-&gt;mutex);
 914         if ((ret = gst_base_sink_wait_preroll (psink)) != GST_FLOW_OK)
 915           goto stopping;
 916 
 917         /* we are allowed to continue now */
 918         goto restart;
 919       }
 920 
 921       /* wait for a buffer to be removed or flush */
 922       priv-&gt;wait_status |= STREAM_WAITING;
 923       g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);
 924       priv-&gt;wait_status &amp;= ~STREAM_WAITING;
 925 
 926       if (priv-&gt;flushing)
 927         goto flushing;
 928     }
 929   }
 930   /* we need to ref the buffer/list when pushing it in the queue */
 931   gst_queue_array_push_tail (priv-&gt;queue, gst_mini_object_ref (data));
 932   priv-&gt;num_buffers++;
 933 
 934   if ((priv-&gt;wait_status &amp; APP_WAITING))
 935   g_cond_signal (&amp;priv-&gt;cond);
 936 
 937   emit = priv-&gt;emit_signals;
 938   g_mutex_unlock (&amp;priv-&gt;mutex);
 939 
 940   if (priv-&gt;callbacks.new_sample) {
 941     ret = priv-&gt;callbacks.new_sample (appsink, priv-&gt;user_data);
 942   } else {
 943     ret = GST_FLOW_OK;
 944     if (emit)
 945       g_signal_emit (appsink, gst_app_sink_signals[SIGNAL_NEW_SAMPLE], 0, &amp;ret);
 946   }
 947   return ret;
 948 
 949 flushing:
 950   {
 951     GST_DEBUG_OBJECT (appsink, &quot;we are flushing&quot;);
 952     g_mutex_unlock (&amp;priv-&gt;mutex);
 953     return GST_FLOW_FLUSHING;
 954   }
 955 stopping:
 956   {
 957     GST_DEBUG_OBJECT (appsink, &quot;we are stopping&quot;);
 958     return ret;
 959   }
 960 }
 961 
 962 static GstFlowReturn
 963 gst_app_sink_render (GstBaseSink * psink, GstBuffer * buffer)
 964 {
 965   return gst_app_sink_render_common (psink, GST_MINI_OBJECT_CAST (buffer),
 966       FALSE);
 967 }
 968 
 969 static GstFlowReturn
 970 gst_app_sink_render_list (GstBaseSink * sink, GstBufferList * list)
 971 {
 972   GstFlowReturn flow;
 973   GstAppSink *appsink;
 974   GstBuffer *buffer;
 975   guint i, len;
 976 
 977   appsink = GST_APP_SINK_CAST (sink);
 978 
 979   if (appsink-&gt;priv-&gt;buffer_lists_supported)
 980     return gst_app_sink_render_common (sink, GST_MINI_OBJECT_CAST (list), TRUE);
 981 
 982   /* The application doesn&#39;t support buffer lists, extract individual buffers
 983    * then and push them one-by-one */
 984   GST_INFO_OBJECT (sink, &quot;chaining each group in list as a merged buffer&quot;);
 985 
 986   len = gst_buffer_list_length (list);
 987 
 988   flow = GST_FLOW_OK;
 989   for (i = 0; i &lt; len; i++) {
 990     buffer = gst_buffer_list_get (list, i);
 991     flow = gst_app_sink_render (sink, buffer);
 992     if (flow != GST_FLOW_OK)
 993       break;
 994   }
 995 
 996   return flow;
 997 }
 998 
 999 static GstCaps *
1000 gst_app_sink_getcaps (GstBaseSink * psink, GstCaps * filter)
1001 {
1002   GstCaps *caps;
1003   GstAppSink *appsink = GST_APP_SINK_CAST (psink);
1004   GstAppSinkPrivate *priv = appsink-&gt;priv;
1005 
1006   GST_OBJECT_LOCK (appsink);
1007   if ((caps = priv-&gt;caps)) {
1008     if (filter)
1009       caps = gst_caps_intersect_full (filter, caps, GST_CAPS_INTERSECT_FIRST);
1010     else
1011       gst_caps_ref (caps);
1012   }
1013   GST_DEBUG_OBJECT (appsink, &quot;got caps %&quot; GST_PTR_FORMAT, caps);
1014   GST_OBJECT_UNLOCK (appsink);
1015 
1016   return caps;
1017 }
1018 
1019 static gboolean
1020 gst_app_sink_query (GstBaseSink * bsink, GstQuery * query)
1021 {
1022   GstAppSink *appsink = GST_APP_SINK_CAST (bsink);
1023   GstAppSinkPrivate *priv = appsink-&gt;priv;
1024   gboolean ret;
1025 
1026   switch (GST_QUERY_TYPE (query)) {
1027     case GST_QUERY_DRAIN:
1028     {
1029       g_mutex_lock (&amp;priv-&gt;mutex);
1030       GST_DEBUG_OBJECT (appsink, &quot;waiting buffers to be consumed&quot;);
1031       while (priv-&gt;num_buffers &gt; 0 || priv-&gt;preroll_buffer) {
1032         if (priv-&gt;unlock) {
1033           /* we are asked to unlock, call the wait_preroll method */
1034           g_mutex_unlock (&amp;priv-&gt;mutex);
1035           if (gst_base_sink_wait_preroll (bsink) != GST_FLOW_OK) {
1036             /* Directly go out of here */
1037             return FALSE;
1038           }
1039 
1040           /* we are allowed to continue now */
1041           g_mutex_lock (&amp;priv-&gt;mutex);
1042           continue;
1043         }
1044 
1045         priv-&gt;wait_status |= STREAM_WAITING;
1046         g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);
1047         priv-&gt;wait_status &amp;= ~STREAM_WAITING;
1048 
1049         if (priv-&gt;flushing)
1050           break;
1051       }
1052       g_mutex_unlock (&amp;priv-&gt;mutex);
1053       ret = GST_BASE_SINK_CLASS (parent_class)-&gt;query (bsink, query);
1054       break;
1055     }
1056     case GST_QUERY_SEEKING:{
1057       GstFormat fmt;
1058 
1059       /* we don&#39;t supporting seeking */
1060       gst_query_parse_seeking (query, &amp;fmt, NULL, NULL, NULL);
1061       gst_query_set_seeking (query, fmt, FALSE, 0, -1);
1062       ret = TRUE;
1063       break;
1064     }
1065 
1066     default:
1067       ret = GST_BASE_SINK_CLASS (parent_class)-&gt;query (bsink, query);
1068       break;
1069   }
1070 
1071   return ret;
1072 }
1073 
1074 /* external API */
1075 
1076 /**
1077  * gst_app_sink_set_caps:
1078  * @appsink: a #GstAppSink
1079  * @caps: caps to set
1080  *
1081  * Set the capabilities on the appsink element.  This function takes
1082  * a copy of the caps structure. After calling this method, the sink will only
1083  * accept caps that match @caps. If @caps is non-fixed, or incomplete,
1084  * you must check the caps on the samples to get the actual used caps.
1085  */
1086 void
1087 gst_app_sink_set_caps (GstAppSink * appsink, const GstCaps * caps)
1088 {
1089   GstCaps *old;
1090   GstAppSinkPrivate *priv;
1091 
1092   g_return_if_fail (GST_IS_APP_SINK (appsink));
1093 
1094   priv = appsink-&gt;priv;
1095 
1096   GST_OBJECT_LOCK (appsink);
1097   GST_DEBUG_OBJECT (appsink, &quot;setting caps to %&quot; GST_PTR_FORMAT, caps);
1098   if ((old = priv-&gt;caps) != caps) {
1099     if (caps)
1100       priv-&gt;caps = gst_caps_copy (caps);
1101     else
1102       priv-&gt;caps = NULL;
1103     if (old)
1104       gst_caps_unref (old);
1105   }
1106   GST_OBJECT_UNLOCK (appsink);
1107 }
1108 
1109 /**
1110  * gst_app_sink_get_caps:
1111  * @appsink: a #GstAppSink
1112  *
1113  * Get the configured caps on @appsink.
1114  *
1115  * Returns: the #GstCaps accepted by the sink. gst_caps_unref() after usage.
1116  */
1117 GstCaps *
1118 gst_app_sink_get_caps (GstAppSink * appsink)
1119 {
1120   GstCaps *caps;
1121   GstAppSinkPrivate *priv;
1122 
1123   g_return_val_if_fail (GST_IS_APP_SINK (appsink), NULL);
1124 
1125   priv = appsink-&gt;priv;
1126 
1127   GST_OBJECT_LOCK (appsink);
1128   if ((caps = priv-&gt;caps))
1129     gst_caps_ref (caps);
1130   GST_DEBUG_OBJECT (appsink, &quot;getting caps of %&quot; GST_PTR_FORMAT, caps);
1131   GST_OBJECT_UNLOCK (appsink);
1132 
1133   return caps;
1134 }
1135 
1136 /**
1137  * gst_app_sink_is_eos:
1138  * @appsink: a #GstAppSink
1139  *
1140  * Check if @appsink is EOS, which is when no more samples can be pulled because
1141  * an EOS event was received.
1142  *
1143  * This function also returns %TRUE when the appsink is not in the PAUSED or
1144  * PLAYING state.
1145  *
1146  * Returns: %TRUE if no more samples can be pulled and the appsink is EOS.
1147  */
1148 gboolean
1149 gst_app_sink_is_eos (GstAppSink * appsink)
1150 {
1151   gboolean ret;
1152   GstAppSinkPrivate *priv;
1153 
1154   g_return_val_if_fail (GST_IS_APP_SINK (appsink), FALSE);
1155 
1156   priv = appsink-&gt;priv;
1157 
1158   g_mutex_lock (&amp;priv-&gt;mutex);
1159   if (!priv-&gt;started)
1160     goto not_started;
1161 
1162   if (priv-&gt;is_eos &amp;&amp; priv-&gt;num_buffers == 0) {
1163     GST_DEBUG_OBJECT (appsink, &quot;we are EOS and the queue is empty&quot;);
1164     ret = TRUE;
1165   } else {
1166     GST_DEBUG_OBJECT (appsink, &quot;we are not yet EOS&quot;);
1167     ret = FALSE;
1168   }
1169   g_mutex_unlock (&amp;priv-&gt;mutex);
1170 
1171   return ret;
1172 
1173 not_started:
1174   {
1175     GST_DEBUG_OBJECT (appsink, &quot;we are stopped, return TRUE&quot;);
1176     g_mutex_unlock (&amp;priv-&gt;mutex);
1177     return TRUE;
1178   }
1179 }
1180 
1181 /**
1182  * gst_app_sink_set_emit_signals:
1183  * @appsink: a #GstAppSink
1184  * @emit: the new state
1185  *
1186  * Make appsink emit the &quot;new-preroll&quot; and &quot;new-sample&quot; signals. This option is
1187  * by default disabled because signal emission is expensive and unneeded when
1188  * the application prefers to operate in pull mode.
1189  */
1190 void
1191 gst_app_sink_set_emit_signals (GstAppSink * appsink, gboolean emit)
1192 {
1193   GstAppSinkPrivate *priv;
1194 
1195   g_return_if_fail (GST_IS_APP_SINK (appsink));
1196 
1197   priv = appsink-&gt;priv;
1198 
1199   g_mutex_lock (&amp;priv-&gt;mutex);
1200   priv-&gt;emit_signals = emit;
1201   g_mutex_unlock (&amp;priv-&gt;mutex);
1202 }
1203 
1204 /**
1205  * gst_app_sink_get_emit_signals:
1206  * @appsink: a #GstAppSink
1207  *
1208  * Check if appsink will emit the &quot;new-preroll&quot; and &quot;new-sample&quot; signals.
1209  *
1210  * Returns: %TRUE if @appsink is emiting the &quot;new-preroll&quot; and &quot;new-sample&quot;
1211  * signals.
1212  */
1213 gboolean
1214 gst_app_sink_get_emit_signals (GstAppSink * appsink)
1215 {
1216   gboolean result;
1217   GstAppSinkPrivate *priv;
1218 
1219   g_return_val_if_fail (GST_IS_APP_SINK (appsink), FALSE);
1220 
1221   priv = appsink-&gt;priv;
1222 
1223   g_mutex_lock (&amp;priv-&gt;mutex);
1224   result = priv-&gt;emit_signals;
1225   g_mutex_unlock (&amp;priv-&gt;mutex);
1226 
1227   return result;
1228 }
1229 
1230 /**
1231  * gst_app_sink_set_max_buffers:
1232  * @appsink: a #GstAppSink
1233  * @max: the maximum number of buffers to queue
1234  *
1235  * Set the maximum amount of buffers that can be queued in @appsink. After this
1236  * amount of buffers are queued in appsink, any more buffers will block upstream
1237  * elements until a sample is pulled from @appsink.
1238  */
1239 void
1240 gst_app_sink_set_max_buffers (GstAppSink * appsink, guint max)
1241 {
1242   GstAppSinkPrivate *priv;
1243 
1244   g_return_if_fail (GST_IS_APP_SINK (appsink));
1245 
1246   priv = appsink-&gt;priv;
1247 
1248   g_mutex_lock (&amp;priv-&gt;mutex);
1249   if (max != priv-&gt;max_buffers) {
1250     priv-&gt;max_buffers = max;
1251     /* signal the change */
1252     g_cond_signal (&amp;priv-&gt;cond);
1253   }
1254   g_mutex_unlock (&amp;priv-&gt;mutex);
1255 }
1256 
1257 /**
1258  * gst_app_sink_get_max_buffers:
1259  * @appsink: a #GstAppSink
1260  *
1261  * Get the maximum amount of buffers that can be queued in @appsink.
1262  *
1263  * Returns: The maximum amount of buffers that can be queued.
1264  */
1265 guint
1266 gst_app_sink_get_max_buffers (GstAppSink * appsink)
1267 {
1268   guint result;
1269   GstAppSinkPrivate *priv;
1270 
1271   g_return_val_if_fail (GST_IS_APP_SINK (appsink), 0);
1272 
1273   priv = appsink-&gt;priv;
1274 
1275   g_mutex_lock (&amp;priv-&gt;mutex);
1276   result = priv-&gt;max_buffers;
1277   g_mutex_unlock (&amp;priv-&gt;mutex);
1278 
1279   return result;
1280 }
1281 
1282 /**
1283  * gst_app_sink_set_drop:
1284  * @appsink: a #GstAppSink
1285  * @drop: the new state
1286  *
1287  * Instruct @appsink to drop old buffers when the maximum amount of queued
1288  * buffers is reached.
1289  */
1290 void
1291 gst_app_sink_set_drop (GstAppSink * appsink, gboolean drop)
1292 {
1293   GstAppSinkPrivate *priv;
1294 
1295   g_return_if_fail (GST_IS_APP_SINK (appsink));
1296 
1297   priv = appsink-&gt;priv;
1298 
1299   g_mutex_lock (&amp;priv-&gt;mutex);
1300   if (priv-&gt;drop != drop) {
1301     priv-&gt;drop = drop;
1302     /* signal the change */
1303     g_cond_signal (&amp;priv-&gt;cond);
1304   }
1305   g_mutex_unlock (&amp;priv-&gt;mutex);
1306 }
1307 
1308 /**
1309  * gst_app_sink_get_drop:
1310  * @appsink: a #GstAppSink
1311  *
1312  * Check if @appsink will drop old buffers when the maximum amount of queued
1313  * buffers is reached.
1314  *
1315  * Returns: %TRUE if @appsink is dropping old buffers when the queue is
1316  * filled.
1317  */
1318 gboolean
1319 gst_app_sink_get_drop (GstAppSink * appsink)
1320 {
1321   gboolean result;
1322   GstAppSinkPrivate *priv;
1323 
1324   g_return_val_if_fail (GST_IS_APP_SINK (appsink), FALSE);
1325 
1326   priv = appsink-&gt;priv;
1327 
1328   g_mutex_lock (&amp;priv-&gt;mutex);
1329   result = priv-&gt;drop;
1330   g_mutex_unlock (&amp;priv-&gt;mutex);
1331 
1332   return result;
1333 }
1334 
1335 /**
1336  * gst_app_sink_set_buffer_list_support:
1337  * @appsink: a #GstAppSink
1338  * @enable_lists: enable or disable buffer list support
1339  *
1340  * Instruct @appsink to enable or disable buffer list support.
1341  *
1342  * For backwards-compatibility reasons applications need to opt in
1343  * to indicate that they will be able to handle buffer lists.
1344  *
1345  * Since: 1.12
1346  */
1347 void
1348 gst_app_sink_set_buffer_list_support (GstAppSink * appsink,
1349     gboolean enable_lists)
1350 {
1351   GstAppSinkPrivate *priv;
1352 
1353   g_return_if_fail (GST_IS_APP_SINK (appsink));
1354 
1355   priv = appsink-&gt;priv;
1356 
1357   g_mutex_lock (&amp;priv-&gt;mutex);
1358   if (priv-&gt;buffer_lists_supported != enable_lists) {
1359     priv-&gt;buffer_lists_supported = enable_lists;
1360   }
1361   g_mutex_unlock (&amp;priv-&gt;mutex);
1362 }
1363 
1364 /**
1365  * gst_app_sink_get_buffer_list_support:
1366  * @appsink: a #GstAppSink
1367  *
1368  * Check if @appsink supports buffer lists.
1369  *
1370  * Returns: %TRUE if @appsink supports buffer lists.
1371  *
1372  * Since: 1.12
1373  */
1374 gboolean
1375 gst_app_sink_get_buffer_list_support (GstAppSink * appsink)
1376 {
1377   gboolean result;
1378   GstAppSinkPrivate *priv;
1379 
1380   g_return_val_if_fail (GST_IS_APP_SINK (appsink), FALSE);
1381 
1382   priv = appsink-&gt;priv;
1383 
1384   g_mutex_lock (&amp;priv-&gt;mutex);
1385   result = priv-&gt;buffer_lists_supported;
1386   g_mutex_unlock (&amp;priv-&gt;mutex);
1387 
1388   return result;
1389 }
1390 
1391 /**
1392  * gst_app_sink_set_wait_on_eos:
1393  * @appsink: a #GstAppSink
1394  * @wait: the new state
1395  *
1396  * Instruct @appsink to wait for all buffers to be consumed when an EOS is received.
1397  *
1398  */
1399 void
1400 gst_app_sink_set_wait_on_eos (GstAppSink * appsink, gboolean wait)
1401 {
1402   GstAppSinkPrivate *priv;
1403 
1404   g_return_if_fail (GST_IS_APP_SINK (appsink));
1405 
1406   priv = appsink-&gt;priv;
1407 
1408   g_mutex_lock (&amp;priv-&gt;mutex);
1409   if (priv-&gt;wait_on_eos != wait) {
1410     priv-&gt;wait_on_eos = wait;
1411     /* signal the change */
1412     g_cond_signal (&amp;priv-&gt;cond);
1413   }
1414   g_mutex_unlock (&amp;priv-&gt;mutex);
1415 }
1416 
1417 /**
1418  * gst_app_sink_get_wait_on_eos:
1419  * @appsink: a #GstAppSink
1420  *
1421  * Check if @appsink will wait for all buffers to be consumed when an EOS is
1422  * received.
1423  *
1424  * Returns: %TRUE if @appsink will wait for all buffers to be consumed when an
1425  * EOS is received.
1426  */
1427 gboolean
1428 gst_app_sink_get_wait_on_eos (GstAppSink * appsink)
1429 {
1430   gboolean result;
1431   GstAppSinkPrivate *priv;
1432 
1433   g_return_val_if_fail (GST_IS_APP_SINK (appsink), FALSE);
1434 
1435   priv = appsink-&gt;priv;
1436 
1437   g_mutex_lock (&amp;priv-&gt;mutex);
1438   result = priv-&gt;wait_on_eos;
1439   g_mutex_unlock (&amp;priv-&gt;mutex);
1440 
1441   return result;
1442 }
1443 
1444 /**
1445  * gst_app_sink_pull_preroll:
1446  * @appsink: a #GstAppSink
1447  *
1448  * Get the last preroll sample in @appsink. This was the sample that caused the
1449  * appsink to preroll in the PAUSED state.
1450  *
1451  * This function is typically used when dealing with a pipeline in the PAUSED
1452  * state. Calling this function after doing a seek will give the sample right
1453  * after the seek position.
1454  *
1455  * Calling this function will clear the internal reference to the preroll
1456  * buffer.
1457  *
1458  * Note that the preroll sample will also be returned as the first sample
1459  * when calling gst_app_sink_pull_sample().
1460  *
1461  * If an EOS event was received before any buffers, this function returns
1462  * %NULL. Use gst_app_sink_is_eos () to check for the EOS condition.
1463  *
1464  * This function blocks until a preroll sample or EOS is received or the appsink
1465  * element is set to the READY/NULL state.
1466  *
1467  * Returns: (transfer full): a #GstSample or NULL when the appsink is stopped or EOS.
1468  *          Call gst_sample_unref() after usage.
1469  */
1470 GstSample *
1471 gst_app_sink_pull_preroll (GstAppSink * appsink)
1472 {
1473   return gst_app_sink_try_pull_preroll (appsink, GST_CLOCK_TIME_NONE);
1474 }
1475 
1476 /**
1477  * gst_app_sink_pull_sample:
1478  * @appsink: a #GstAppSink
1479  *
1480  * This function blocks until a sample or EOS becomes available or the appsink
1481  * element is set to the READY/NULL state.
1482  *
1483  * This function will only return samples when the appsink is in the PLAYING
1484  * state. All rendered buffers will be put in a queue so that the application
1485  * can pull samples at its own rate. Note that when the application does not
1486  * pull samples fast enough, the queued buffers could consume a lot of memory,
1487  * especially when dealing with raw video frames.
1488  *
1489  * If an EOS event was received before any buffers, this function returns
1490  * %NULL. Use gst_app_sink_is_eos () to check for the EOS condition.
1491  *
1492  * Returns: (transfer full): a #GstSample or NULL when the appsink is stopped or EOS.
1493  *          Call gst_sample_unref() after usage.
1494  */
1495 GstSample *
1496 gst_app_sink_pull_sample (GstAppSink * appsink)
1497 {
1498   return gst_app_sink_try_pull_sample (appsink, GST_CLOCK_TIME_NONE);
1499 }
1500 
1501 /**
1502  * gst_app_sink_try_pull_preroll:
1503  * @appsink: a #GstAppSink
1504  * @timeout: the maximum amount of time to wait for the preroll sample
1505  *
1506  * Get the last preroll sample in @appsink. This was the sample that caused the
1507  * appsink to preroll in the PAUSED state.
1508  *
1509  * This function is typically used when dealing with a pipeline in the PAUSED
1510  * state. Calling this function after doing a seek will give the sample right
1511  * after the seek position.
1512  *
1513  * Calling this function will clear the internal reference to the preroll
1514  * buffer.
1515  *
1516  * Note that the preroll sample will also be returned as the first sample
1517  * when calling gst_app_sink_pull_sample().
1518  *
1519  * If an EOS event was received before any buffers or the timeout expires,
1520  * this function returns %NULL. Use gst_app_sink_is_eos () to check for the EOS
1521  * condition.
1522  *
1523  * This function blocks until a preroll sample or EOS is received, the appsink
1524  * element is set to the READY/NULL state, or the timeout expires.
1525  *
1526  * Returns: (transfer full): a #GstSample or NULL when the appsink is stopped or EOS or the timeout expires.
1527  *          Call gst_sample_unref() after usage.
1528  *
1529  * Since: 1.10
1530  */
1531 GstSample *
1532 gst_app_sink_try_pull_preroll (GstAppSink * appsink, GstClockTime timeout)
1533 {
1534   GstAppSinkPrivate *priv;
1535   GstSample *sample = NULL;
1536   gboolean timeout_valid;
1537   gint64 end_time;
1538 
1539   g_return_val_if_fail (GST_IS_APP_SINK (appsink), NULL);
1540 
1541   priv = appsink-&gt;priv;
1542 
1543   timeout_valid = GST_CLOCK_TIME_IS_VALID (timeout);
1544 
1545   if (timeout_valid)
1546     end_time =
1547         g_get_monotonic_time () + timeout / (GST_SECOND / G_TIME_SPAN_SECOND);
1548 
1549   g_mutex_lock (&amp;priv-&gt;mutex);
1550 
1551   while (TRUE) {
1552     GST_DEBUG_OBJECT (appsink, &quot;trying to grab a buffer&quot;);
1553     if (!priv-&gt;started)
1554       goto not_started;
1555 
1556     if (priv-&gt;preroll_buffer != NULL)
1557       break;
1558 
1559     if (priv-&gt;is_eos)
1560       goto eos;
1561 
1562     /* nothing to return, wait */
1563     GST_DEBUG_OBJECT (appsink, &quot;waiting for the preroll buffer&quot;);
1564     priv-&gt;wait_status |= APP_WAITING;
1565     if (timeout_valid) {
1566       if (!g_cond_wait_until (&amp;priv-&gt;cond, &amp;priv-&gt;mutex, end_time))
1567         goto expired;
1568     } else {
1569     g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);
1570   }
1571     priv-&gt;wait_status &amp;= ~APP_WAITING;
1572   }
1573   sample =
1574       gst_sample_new (priv-&gt;preroll_buffer, priv-&gt;preroll_caps,
1575       &amp;priv-&gt;preroll_segment, NULL);
1576   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
1577   GST_DEBUG_OBJECT (appsink, &quot;we have the preroll sample %p&quot;, sample);
1578   g_mutex_unlock (&amp;priv-&gt;mutex);
1579 
1580   return sample;
1581 
1582   /* special conditions */
1583 expired:
1584   {
1585     GST_DEBUG_OBJECT (appsink, &quot;timeout expired, return NULL&quot;);
1586     priv-&gt;wait_status &amp;= ~APP_WAITING;
1587     g_mutex_unlock (&amp;priv-&gt;mutex);
1588     return NULL;
1589   }
1590 eos:
1591   {
1592     GST_DEBUG_OBJECT (appsink, &quot;we are EOS, return NULL&quot;);
1593     g_mutex_unlock (&amp;priv-&gt;mutex);
1594     return NULL;
1595   }
1596 not_started:
1597   {
1598     GST_DEBUG_OBJECT (appsink, &quot;we are stopped, return NULL&quot;);
1599     g_mutex_unlock (&amp;priv-&gt;mutex);
1600     return NULL;
1601   }
1602 }
1603 
1604 /**
1605  * gst_app_sink_try_pull_sample:
1606  * @appsink: a #GstAppSink
1607  * @timeout: the maximum amount of time to wait for a sample
1608  *
1609  * This function blocks until a sample or EOS becomes available or the appsink
1610  * element is set to the READY/NULL state or the timeout expires.
1611  *
1612  * This function will only return samples when the appsink is in the PLAYING
1613  * state. All rendered buffers will be put in a queue so that the application
1614  * can pull samples at its own rate. Note that when the application does not
1615  * pull samples fast enough, the queued buffers could consume a lot of memory,
1616  * especially when dealing with raw video frames.
1617  *
1618  * If an EOS event was received before any buffers or the timeout expires,
1619  * this function returns %NULL. Use gst_app_sink_is_eos () to check for the EOS
1620  * condition.
1621  *
1622  * Returns: (transfer full): a #GstSample or NULL when the appsink is stopped or EOS or the timeout expires.
1623  * Call gst_sample_unref() after usage.
1624  *
1625  * Since: 1.10
1626  */
1627 GstSample *
1628 gst_app_sink_try_pull_sample (GstAppSink * appsink, GstClockTime timeout)
1629 {
1630   GstAppSinkPrivate *priv;
1631   GstSample *sample = NULL;
1632   GstMiniObject *obj;
1633   gboolean timeout_valid;
1634   gint64 end_time;
1635 
1636   g_return_val_if_fail (GST_IS_APP_SINK (appsink), NULL);
1637 
1638   timeout_valid = GST_CLOCK_TIME_IS_VALID (timeout);
1639 
1640   if (timeout_valid)
1641     end_time =
1642         g_get_monotonic_time () + timeout / (GST_SECOND / G_TIME_SPAN_SECOND);
1643 
1644   priv = appsink-&gt;priv;
1645 
1646   g_mutex_lock (&amp;priv-&gt;mutex);
1647   gst_buffer_replace (&amp;priv-&gt;preroll_buffer, NULL);
1648 
1649   while (TRUE) {
1650     GST_DEBUG_OBJECT (appsink, &quot;trying to grab a buffer&quot;);
1651     if (!priv-&gt;started)
1652       goto not_started;
1653 
1654     if (priv-&gt;num_buffers &gt; 0)
1655       break;
1656 
1657     if (priv-&gt;is_eos)
1658       goto eos;
1659 
1660     /* nothing to return, wait */
1661     GST_DEBUG_OBJECT (appsink, &quot;waiting for a buffer&quot;);
1662     priv-&gt;wait_status |= APP_WAITING;
1663     if (timeout_valid) {
1664       if (!g_cond_wait_until (&amp;priv-&gt;cond, &amp;priv-&gt;mutex, end_time))
1665         goto expired;
1666     } else {
1667     g_cond_wait (&amp;priv-&gt;cond, &amp;priv-&gt;mutex);
1668   }
1669     priv-&gt;wait_status &amp;= ~APP_WAITING;
1670   }
1671 
1672   obj = dequeue_buffer (appsink);
1673   if (GST_IS_BUFFER (obj)) {
1674     GST_DEBUG_OBJECT (appsink, &quot;we have a buffer %p&quot;, obj);
1675     sample = gst_sample_new (GST_BUFFER_CAST (obj), priv-&gt;last_caps,
1676         &amp;priv-&gt;last_segment, NULL);
1677   } else {
1678     GST_DEBUG_OBJECT (appsink, &quot;we have a list %p&quot;, obj);
1679     sample = gst_sample_new (NULL, priv-&gt;last_caps, &amp;priv-&gt;last_segment, NULL);
1680     gst_sample_set_buffer_list (sample, GST_BUFFER_LIST_CAST (obj));
1681   }
1682   gst_mini_object_unref (obj);
1683 
1684   if ((priv-&gt;wait_status &amp; STREAM_WAITING))
1685   g_cond_signal (&amp;priv-&gt;cond);
1686 
1687   g_mutex_unlock (&amp;priv-&gt;mutex);
1688 
1689   return sample;
1690 
1691   /* special conditions */
1692 expired:
1693   {
1694     GST_DEBUG_OBJECT (appsink, &quot;timeout expired, return NULL&quot;);
1695     priv-&gt;wait_status &amp;= ~APP_WAITING;
1696     g_mutex_unlock (&amp;priv-&gt;mutex);
1697     return NULL;
1698   }
1699 eos:
1700   {
1701     GST_DEBUG_OBJECT (appsink, &quot;we are EOS, return NULL&quot;);
1702     g_mutex_unlock (&amp;priv-&gt;mutex);
1703     return NULL;
1704   }
1705 not_started:
1706   {
1707     GST_DEBUG_OBJECT (appsink, &quot;we are stopped, return NULL&quot;);
1708     g_mutex_unlock (&amp;priv-&gt;mutex);
1709     return NULL;
1710   }
1711 }
1712 
1713 /**
1714  * gst_app_sink_set_callbacks: (skip)
1715  * @appsink: a #GstAppSink
1716  * @callbacks: the callbacks
1717  * @user_data: a user_data argument for the callbacks
1718  * @notify: a destroy notify function
1719  *
1720  * Set callbacks which will be executed for each new preroll, new sample and eos.
1721  * This is an alternative to using the signals, it has lower overhead and is thus
1722  * less expensive, but also less flexible.
1723  *
1724  * If callbacks are installed, no signals will be emitted for performance
1725  * reasons.
1726  */
1727 void
1728 gst_app_sink_set_callbacks (GstAppSink * appsink,
1729     GstAppSinkCallbacks * callbacks, gpointer user_data, GDestroyNotify notify)
1730 {
1731   GDestroyNotify old_notify;
1732   GstAppSinkPrivate *priv;
1733 
1734   g_return_if_fail (GST_IS_APP_SINK (appsink));
1735   g_return_if_fail (callbacks != NULL);
1736 
1737   priv = appsink-&gt;priv;
1738 
1739   GST_OBJECT_LOCK (appsink);
1740   old_notify = priv-&gt;notify;
1741 
1742   if (old_notify) {
1743     gpointer old_data;
1744 
1745     old_data = priv-&gt;user_data;
1746 
1747     priv-&gt;user_data = NULL;
1748     priv-&gt;notify = NULL;
1749     GST_OBJECT_UNLOCK (appsink);
1750 
1751     old_notify (old_data);
1752 
1753     GST_OBJECT_LOCK (appsink);
1754   }
1755   priv-&gt;callbacks = *callbacks;
1756   priv-&gt;user_data = user_data;
1757   priv-&gt;notify = notify;
1758   GST_OBJECT_UNLOCK (appsink);
1759 }
1760 
1761 /*** GSTURIHANDLER INTERFACE *************************************************/
1762 
1763 static GstURIType
1764 gst_app_sink_uri_get_type (GType type)
1765 {
1766   return GST_URI_SINK;
1767 }
1768 
1769 static const gchar *const *
1770 gst_app_sink_uri_get_protocols (GType type)
1771 {
1772   static const gchar *protocols[] = { &quot;appsink&quot;, NULL };
1773 
1774   return protocols;
1775 }
1776 
1777 static gchar *
1778 gst_app_sink_uri_get_uri (GstURIHandler * handler)
1779 {
1780   return g_strdup (&quot;appsink&quot;);
1781 }
1782 
1783 static gboolean
1784 gst_app_sink_uri_set_uri (GstURIHandler * handler, const gchar * uri,
1785     GError ** error)
1786 {
1787   /* GstURIHandler checks the protocol for us */
1788   return TRUE;
1789 }
1790 
1791 static void
1792 gst_app_sink_uri_handler_init (gpointer g_iface, gpointer iface_data)
1793 {
1794   GstURIHandlerInterface *iface = (GstURIHandlerInterface *) g_iface;
1795 
1796   iface-&gt;get_type = gst_app_sink_uri_get_type;
1797   iface-&gt;get_protocols = gst_app_sink_uri_get_protocols;
1798   iface-&gt;get_uri = gst_app_sink_uri_get_uri;
1799   iface-&gt;set_uri = gst_app_sink_uri_set_uri;
1800 
1801 }
    </pre>
  </body>
</html>