<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/garray.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #include &lt;string.h&gt;
  32 #include &lt;stdlib.h&gt;
  33 
  34 #include &quot;garray.h&quot;
  35 
  36 #include &quot;gbytes.h&quot;
  37 #include &quot;ghash.h&quot;
  38 #include &quot;gslice.h&quot;
  39 #include &quot;gmem.h&quot;
  40 #include &quot;gtestutils.h&quot;
  41 #include &quot;gthread.h&quot;
  42 #include &quot;gmessages.h&quot;
  43 #include &quot;gqsort.h&quot;
  44 #include &quot;grefcount.h&quot;
  45 
  46 /**
  47  * SECTION:arrays
  48  * @title: Arrays
  49  * @short_description: arrays of arbitrary elements which grow
  50  *     automatically as elements are added
  51  *
  52  * Arrays are similar to standard C arrays, except that they grow
  53  * automatically as elements are added.
  54  *
  55  * Array elements can be of any size (though all elements of one array
  56  * are the same size), and the array can be automatically cleared to
  57  * &#39;0&#39;s and zero-terminated.
  58  *
  59  * To create a new array use g_array_new().
  60  *
  61  * To add elements to an array, use g_array_append_val(),
  62  * g_array_append_vals(), g_array_prepend_val(), and
  63  * g_array_prepend_vals().
  64  *
  65  * To access an element of an array, use g_array_index().
  66  *
  67  * To set the size of an array, use g_array_set_size().
  68  *
  69  * To free an array, use g_array_free().
  70  *
  71  * Here is an example that stores integers in a #GArray:
  72  * |[&lt;!-- language=&quot;C&quot; --&gt;
  73  *   GArray *garray;
  74  *   gint i;
  75  *   // We create a new array to store gint values.
  76  *   // We don&#39;t want it zero-terminated or cleared to 0&#39;s.
  77  *   garray = g_array_new (FALSE, FALSE, sizeof (gint));
  78  *   for (i = 0; i &lt; 10000; i++)
  79  *     g_array_append_val (garray, i);
  80  *   for (i = 0; i &lt; 10000; i++)
  81  *     if (g_array_index (garray, gint, i) != i)
  82  *       g_print (&quot;ERROR: got %d instead of %d\n&quot;,
  83  *                g_array_index (garray, gint, i), i);
  84  *   g_array_free (garray, TRUE);
  85  * ]|
  86  */
  87 
  88 #define MIN_ARRAY_SIZE  16
  89 
  90 typedef struct _GRealArray  GRealArray;
  91 
  92 /**
  93  * GArray:
  94  * @data: a pointer to the element data. The data may be moved as
  95  *     elements are added to the #GArray.
  96  * @len: the number of elements in the #GArray not including the
  97  *     possible terminating zero element.
  98  *
  99  * Contains the public fields of a GArray.
 100  */
 101 struct _GRealArray
 102 {
 103   guint8 *data;
 104   guint   len;
 105   guint   alloc;
 106   guint   elt_size;
 107   guint   zero_terminated : 1;
 108   guint   clear : 1;
 109   gatomicrefcount ref_count;
 110   GDestroyNotify clear_func;
 111 };
 112 
 113 /**
 114  * g_array_index:
 115  * @a: a #GArray
 116  * @t: the type of the elements
 117  * @i: the index of the element to return
 118  *
 119  * Returns the element of a #GArray at the given index. The return
 120  * value is cast to the given type.
 121  *
 122  * This example gets a pointer to an element in a #GArray:
 123  * |[&lt;!-- language=&quot;C&quot; --&gt;
 124  *   EDayViewEvent *event;
 125  *   // This gets a pointer to the 4th element in the array of
 126  *   // EDayViewEvent structs.
 127  *   event = &amp;g_array_index (events, EDayViewEvent, 3);
 128  * ]|
 129  *
 130  * Returns: the element of the #GArray at the index given by @i
 131  */
 132 
 133 #define g_array_elt_len(array,i) ((array)-&gt;elt_size * (i))
 134 #define g_array_elt_pos(array,i) ((array)-&gt;data + g_array_elt_len((array),(i)))
 135 #define g_array_elt_zero(array, pos, len)                               \
 136   (memset (g_array_elt_pos ((array), pos), 0,  g_array_elt_len ((array), len)))
 137 #define g_array_zero_terminate(array) G_STMT_START{                     \
 138   if ((array)-&gt;zero_terminated)                                         \
 139     g_array_elt_zero ((array), (array)-&gt;len, 1);                        \
 140 }G_STMT_END
 141 
 142 static guint g_nearest_pow        (guint       num) G_GNUC_CONST;
 143 static void  g_array_maybe_expand (GRealArray *array,
 144                                    guint       len);
 145 
 146 /**
 147  * g_array_new:
 148  * @zero_terminated: %TRUE if the array should have an extra element at
 149  *     the end which is set to 0
 150  * @clear_: %TRUE if #GArray elements should be automatically cleared
 151  *     to 0 when they are allocated
 152  * @element_size: the size of each element in bytes
 153  *
 154  * Creates a new #GArray with a reference count of 1.
 155  *
 156  * Returns: the new #GArray
 157  */
 158 GArray*
 159 g_array_new (gboolean zero_terminated,
 160              gboolean clear,
 161              guint    elt_size)
 162 {
 163   g_return_val_if_fail (elt_size &gt; 0, NULL);
 164 
 165   return g_array_sized_new (zero_terminated, clear, elt_size, 0);
 166 }
 167 
 168 /**
 169  * g_array_sized_new:
 170  * @zero_terminated: %TRUE if the array should have an extra element at
 171  *     the end with all bits cleared
 172  * @clear_: %TRUE if all bits in the array should be cleared to 0 on
 173  *     allocation
 174  * @element_size: size of each element in the array
 175  * @reserved_size: number of elements preallocated
 176  *
 177  * Creates a new #GArray with @reserved_size elements preallocated and
 178  * a reference count of 1. This avoids frequent reallocation, if you
 179  * are going to add many elements to the array. Note however that the
 180  * size of the array is still 0.
 181  *
 182  * Returns: the new #GArray
 183  */
 184 GArray*
 185 g_array_sized_new (gboolean zero_terminated,
 186                    gboolean clear,
 187                    guint    elt_size,
 188                    guint    reserved_size)
 189 {
 190   GRealArray *array;
 191 
 192   g_return_val_if_fail (elt_size &gt; 0, NULL);
 193 
 194   array = g_slice_new (GRealArray);
 195 #ifdef GSTREAMER_LITE
 196   if (array == NULL) {
 197     return NULL;
 198   }
 199 #endif // GSTREAMER_LITE
 200 
 201   array-&gt;data            = NULL;
 202   array-&gt;len             = 0;
 203   array-&gt;alloc           = 0;
 204   array-&gt;zero_terminated = (zero_terminated ? 1 : 0);
 205   array-&gt;clear           = (clear ? 1 : 0);
 206   array-&gt;elt_size        = elt_size;
 207   array-&gt;clear_func      = NULL;
 208 
 209   g_atomic_ref_count_init (&amp;array-&gt;ref_count);
 210 
 211   if (array-&gt;zero_terminated || reserved_size != 0)
 212     {
 213       g_array_maybe_expand (array, reserved_size);
 214       g_array_zero_terminate(array);
 215     }
 216 
 217   return (GArray*) array;
 218 }
 219 
 220 /**
 221  * g_array_set_clear_func:
 222  * @array: A #GArray
 223  * @clear_func: a function to clear an element of @array
 224  *
 225  * Sets a function to clear an element of @array.
 226  *
 227  * The @clear_func will be called when an element in the array
 228  * data segment is removed and when the array is freed and data
 229  * segment is deallocated as well. @clear_func will be passed a
 230  * pointer to the element to clear, rather than the element itself.
 231  *
 232  * Note that in contrast with other uses of #GDestroyNotify
 233  * functions, @clear_func is expected to clear the contents of
 234  * the array element it is given, but not free the element itself.
 235  *
 236  * Since: 2.32
 237  */
 238 void
 239 g_array_set_clear_func (GArray         *array,
 240                         GDestroyNotify  clear_func)
 241 {
 242   GRealArray *rarray = (GRealArray *) array;
 243 
 244   g_return_if_fail (array != NULL);
 245 
 246   rarray-&gt;clear_func = clear_func;
 247 }
 248 
 249 /**
 250  * g_array_ref:
 251  * @array: A #GArray
 252  *
 253  * Atomically increments the reference count of @array by one.
 254  * This function is thread-safe and may be called from any thread.
 255  *
 256  * Returns: The passed in #GArray
 257  *
 258  * Since: 2.22
 259  */
 260 GArray *
 261 g_array_ref (GArray *array)
 262 {
 263   GRealArray *rarray = (GRealArray*) array;
 264   g_return_val_if_fail (array, NULL);
 265 
 266   g_atomic_ref_count_inc (&amp;rarray-&gt;ref_count);
 267 
 268   return array;
 269 }
 270 
 271 typedef enum
 272 {
 273   FREE_SEGMENT = 1 &lt;&lt; 0,
 274   PRESERVE_WRAPPER = 1 &lt;&lt; 1
 275 } ArrayFreeFlags;
 276 
 277 static gchar *array_free (GRealArray *, ArrayFreeFlags);
 278 
 279 /**
 280  * g_array_unref:
 281  * @array: A #GArray
 282  *
 283  * Atomically decrements the reference count of @array by one. If the
 284  * reference count drops to 0, all memory allocated by the array is
 285  * released. This function is thread-safe and may be called from any
 286  * thread.
 287  *
 288  * Since: 2.22
 289  */
 290 void
 291 g_array_unref (GArray *array)
 292 {
 293   GRealArray *rarray = (GRealArray*) array;
 294   g_return_if_fail (array);
 295 
 296   if (g_atomic_ref_count_dec (&amp;rarray-&gt;ref_count))
 297     array_free (rarray, FREE_SEGMENT);
 298 }
 299 
 300 /**
 301  * g_array_get_element_size:
 302  * @array: A #GArray
 303  *
 304  * Gets the size of the elements in @array.
 305  *
 306  * Returns: Size of each element, in bytes
 307  *
 308  * Since: 2.22
 309  */
 310 guint
 311 g_array_get_element_size (GArray *array)
 312 {
 313   GRealArray *rarray = (GRealArray*) array;
 314 
 315   g_return_val_if_fail (array, 0);
 316 
 317   return rarray-&gt;elt_size;
 318 }
 319 
 320 /**
 321  * g_array_free:
 322  * @array: a #GArray
 323  * @free_segment: if %TRUE the actual element data is freed as well
 324  *
 325  * Frees the memory allocated for the #GArray. If @free_segment is
<a name="1" id="anc1"></a><span class="line-modified"> 326  * %TRUE it frees the memory block holding the elements as well. Pass</span>

 327  * %FALSE if you want to free the #GArray wrapper but preserve the
<a name="2" id="anc2"></a><span class="line-modified"> 328  * underlying array for use elsewhere. If the reference count of</span>
<span class="line-modified"> 329  * @array is greater than one, the #GArray wrapper is preserved but</span>
<span class="line-modified"> 330  * the size of  @array will be set to zero.</span>
 331  *
<a name="3" id="anc3"></a><span class="line-modified"> 332  * If array contents point to dynamically-allocated memory, they should</span>
<span class="line-modified"> 333  * be freed separately if @free_seg is %TRUE and no @clear_func</span>
<span class="line-added"> 334  * function has been set for @array.</span>
 335  *
 336  * This function is not thread-safe. If using a #GArray from multiple
 337  * threads, use only the atomic g_array_ref() and g_array_unref()
 338  * functions.
 339  *
 340  * Returns: the element data if @free_segment is %FALSE, otherwise
 341  *     %NULL. The element data should be freed using g_free().
 342  */
 343 gchar*
 344 g_array_free (GArray   *farray,
 345               gboolean  free_segment)
 346 {
 347   GRealArray *array = (GRealArray*) farray;
 348   ArrayFreeFlags flags;
 349 
 350   g_return_val_if_fail (array, NULL);
 351 
 352   flags = (free_segment ? FREE_SEGMENT : 0);
 353 
 354   /* if others are holding a reference, preserve the wrapper but do free/return the data */
 355   if (!g_atomic_ref_count_dec (&amp;array-&gt;ref_count))
 356     flags |= PRESERVE_WRAPPER;
 357 
 358   return array_free (array, flags);
 359 }
 360 
 361 static gchar *
 362 array_free (GRealArray     *array,
 363             ArrayFreeFlags  flags)
 364 {
 365   gchar *segment;
 366 
 367   if (flags &amp; FREE_SEGMENT)
 368     {
 369       if (array-&gt;clear_func != NULL)
 370         {
 371           guint i;
 372 
 373           for (i = 0; i &lt; array-&gt;len; i++)
 374             array-&gt;clear_func (g_array_elt_pos (array, i));
 375         }
 376 
 377       g_free (array-&gt;data);
 378       segment = NULL;
 379     }
 380   else
 381     segment = (gchar*) array-&gt;data;
 382 
 383   if (flags &amp; PRESERVE_WRAPPER)
 384     {
 385       array-&gt;data            = NULL;
 386       array-&gt;len             = 0;
 387       array-&gt;alloc           = 0;
 388     }
 389   else
 390     {
 391       g_slice_free1 (sizeof (GRealArray), array);
 392     }
 393 
 394   return segment;
 395 }
 396 
 397 /**
 398  * g_array_append_vals:
 399  * @array: a #GArray
 400  * @data: (not nullable): a pointer to the elements to append to the end of the array
 401  * @len: the number of elements to append
 402  *
 403  * Adds @len elements onto the end of the array.
 404  *
 405  * Returns: the #GArray
 406  */
 407 /**
 408  * g_array_append_val:
 409  * @a: a #GArray
 410  * @v: the value to append to the #GArray
 411  *
 412  * Adds the value on to the end of the array. The array will grow in
 413  * size automatically if necessary.
 414  *
 415  * g_array_append_val() is a macro which uses a reference to the value
 416  * parameter @v. This means that you cannot use it with literal values
 417  * such as &quot;27&quot;. You must use variables.
 418  *
 419  * Returns: the #GArray
 420  */
 421 GArray*
 422 g_array_append_vals (GArray       *farray,
 423                      gconstpointer data,
 424                      guint         len)
 425 {
 426   GRealArray *array = (GRealArray*) farray;
 427 
 428   g_return_val_if_fail (array, NULL);
 429 
 430   if (len == 0)
 431     return farray;
 432 
 433   g_array_maybe_expand (array, len);
 434 
 435   memcpy (g_array_elt_pos (array, array-&gt;len), data,
 436           g_array_elt_len (array, len));
 437 
 438   array-&gt;len += len;
 439 
 440   g_array_zero_terminate (array);
 441 
 442   return farray;
 443 }
 444 
 445 /**
 446  * g_array_prepend_vals:
 447  * @array: a #GArray
 448  * @data: (nullable): a pointer to the elements to prepend to the start of the array
 449  * @len: the number of elements to prepend, which may be zero
 450  *
 451  * Adds @len elements onto the start of the array.
 452  *
 453  * @data may be %NULL if (and only if) @len is zero. If @len is zero, this
 454  * function is a no-op.
 455  *
 456  * This operation is slower than g_array_append_vals() since the
 457  * existing elements in the array have to be moved to make space for
 458  * the new elements.
 459  *
 460  * Returns: the #GArray
 461  */
 462 /**
 463  * g_array_prepend_val:
 464  * @a: a #GArray
 465  * @v: the value to prepend to the #GArray
 466  *
 467  * Adds the value on to the start of the array. The array will grow in
 468  * size automatically if necessary.
 469  *
 470  * This operation is slower than g_array_append_val() since the
 471  * existing elements in the array have to be moved to make space for
 472  * the new element.
 473  *
 474  * g_array_prepend_val() is a macro which uses a reference to the value
 475  * parameter @v. This means that you cannot use it with literal values
 476  * such as &quot;27&quot;. You must use variables.
 477  *
 478  * Returns: the #GArray
 479  */
 480 GArray*
 481 g_array_prepend_vals (GArray        *farray,
 482                       gconstpointer  data,
 483                       guint          len)
 484 {
 485   GRealArray *array = (GRealArray*) farray;
 486 
 487   g_return_val_if_fail (array, NULL);
 488 
 489   if (len == 0)
 490     return farray;
 491 
 492   g_array_maybe_expand (array, len);
 493 
 494   memmove (g_array_elt_pos (array, len), g_array_elt_pos (array, 0),
 495            g_array_elt_len (array, array-&gt;len));
 496 
 497   memcpy (g_array_elt_pos (array, 0), data, g_array_elt_len (array, len));
 498 
 499   array-&gt;len += len;
 500 
 501   g_array_zero_terminate (array);
 502 
 503   return farray;
 504 }
 505 
 506 /**
 507  * g_array_insert_vals:
 508  * @array: a #GArray
 509  * @index_: the index to place the elements at
 510  * @data: (nullable): a pointer to the elements to insert
 511  * @len: the number of elements to insert
 512  *
 513  * Inserts @len elements into a #GArray at the given index.
 514  *
<a name="4" id="anc4"></a><span class="line-modified"> 515  * If @index_ is greater than the array&#39;s current length, the array is expanded.</span>
 516  * The elements between the old end of the array and the newly inserted elements
 517  * will be initialised to zero if the array was configured to clear elements;
 518  * otherwise their values will be undefined.
 519  *
 520  * @data may be %NULL if (and only if) @len is zero. If @len is zero, this
 521  * function is a no-op.
 522  *
 523  * Returns: the #GArray
 524  */
 525 /**
 526  * g_array_insert_val:
 527  * @a: a #GArray
 528  * @i: the index to place the element at
 529  * @v: the value to insert into the array
 530  *
 531  * Inserts an element into an array at the given index.
 532  *
 533  * g_array_insert_val() is a macro which uses a reference to the value
 534  * parameter @v. This means that you cannot use it with literal values
 535  * such as &quot;27&quot;. You must use variables.
 536  *
 537  * Returns: the #GArray
 538  */
 539 GArray*
 540 g_array_insert_vals (GArray        *farray,
 541                      guint          index_,
 542                      gconstpointer  data,
 543                      guint          len)
 544 {
 545   GRealArray *array = (GRealArray*) farray;
 546 
 547   g_return_val_if_fail (array, NULL);
 548 
 549   if (len == 0)
 550     return farray;
 551 
 552   /* Is the index off the end of the array, and hence do we need to over-allocate
 553    * and clear some elements? */
 554   if (index_ &gt;= array-&gt;len)
 555     {
 556       g_array_maybe_expand (array, index_ - array-&gt;len + len);
 557       return g_array_append_vals (g_array_set_size (farray, index_), data, len);
 558     }
 559 
 560   g_array_maybe_expand (array, len);
 561 
 562   memmove (g_array_elt_pos (array, len + index_),
 563            g_array_elt_pos (array, index_),
 564            g_array_elt_len (array, array-&gt;len - index_));
 565 
 566   memcpy (g_array_elt_pos (array, index_), data, g_array_elt_len (array, len));
 567 
 568   array-&gt;len += len;
 569 
 570   g_array_zero_terminate (array);
 571 
 572   return farray;
 573 }
 574 
 575 /**
 576  * g_array_set_size:
 577  * @array: a #GArray
 578  * @length: the new size of the #GArray
 579  *
 580  * Sets the size of the array, expanding it if necessary. If the array
 581  * was created with @clear_ set to %TRUE, the new elements are set to 0.
 582  *
 583  * Returns: the #GArray
 584  */
 585 GArray*
 586 g_array_set_size (GArray *farray,
 587                   guint   length)
 588 {
 589   GRealArray *array = (GRealArray*) farray;
 590 
 591   g_return_val_if_fail (array, NULL);
 592 
 593   if (length &gt; array-&gt;len)
 594     {
 595       g_array_maybe_expand (array, length - array-&gt;len);
 596 
 597       if (array-&gt;clear)
 598         g_array_elt_zero (array, array-&gt;len, length - array-&gt;len);
 599     }
 600   else if (length &lt; array-&gt;len)
 601     g_array_remove_range (farray, length, array-&gt;len - length);
 602 
 603   array-&gt;len = length;
 604 
 605   g_array_zero_terminate (array);
 606 
 607   return farray;
 608 }
 609 
 610 /**
 611  * g_array_remove_index:
 612  * @array: a #GArray
 613  * @index_: the index of the element to remove
 614  *
 615  * Removes the element at the given index from a #GArray. The following
 616  * elements are moved down one place.
 617  *
 618  * Returns: the #GArray
 619  */
 620 GArray*
 621 g_array_remove_index (GArray *farray,
 622                       guint   index_)
 623 {
 624   GRealArray* array = (GRealArray*) farray;
 625 
 626   g_return_val_if_fail (array, NULL);
 627 
 628   g_return_val_if_fail (index_ &lt; array-&gt;len, NULL);
 629 
 630   if (array-&gt;clear_func != NULL)
 631     array-&gt;clear_func (g_array_elt_pos (array, index_));
 632 
 633   if (index_ != array-&gt;len - 1)
 634     memmove (g_array_elt_pos (array, index_),
 635              g_array_elt_pos (array, index_ + 1),
 636              g_array_elt_len (array, array-&gt;len - index_ - 1));
 637 
 638   array-&gt;len -= 1;
 639 
 640   if (G_UNLIKELY (g_mem_gc_friendly))
 641     g_array_elt_zero (array, array-&gt;len, 1);
 642   else
 643     g_array_zero_terminate (array);
 644 
 645   return farray;
 646 }
 647 
 648 /**
 649  * g_array_remove_index_fast:
 650  * @array: a @GArray
 651  * @index_: the index of the element to remove
 652  *
 653  * Removes the element at the given index from a #GArray. The last
 654  * element in the array is used to fill in the space, so this function
 655  * does not preserve the order of the #GArray. But it is faster than
 656  * g_array_remove_index().
 657  *
 658  * Returns: the #GArray
 659  */
 660 GArray*
 661 g_array_remove_index_fast (GArray *farray,
 662                            guint   index_)
 663 {
 664   GRealArray* array = (GRealArray*) farray;
 665 
 666   g_return_val_if_fail (array, NULL);
 667 
 668   g_return_val_if_fail (index_ &lt; array-&gt;len, NULL);
 669 
 670   if (array-&gt;clear_func != NULL)
 671     array-&gt;clear_func (g_array_elt_pos (array, index_));
 672 
 673   if (index_ != array-&gt;len - 1)
 674     memcpy (g_array_elt_pos (array, index_),
 675             g_array_elt_pos (array, array-&gt;len - 1),
 676             g_array_elt_len (array, 1));
 677 
 678   array-&gt;len -= 1;
 679 
 680   if (G_UNLIKELY (g_mem_gc_friendly))
 681     g_array_elt_zero (array, array-&gt;len, 1);
 682   else
 683     g_array_zero_terminate (array);
 684 
 685   return farray;
 686 }
 687 
 688 /**
 689  * g_array_remove_range:
 690  * @array: a @GArray
 691  * @index_: the index of the first element to remove
 692  * @length: the number of elements to remove
 693  *
 694  * Removes the given number of elements starting at the given index
 695  * from a #GArray.  The following elements are moved to close the gap.
 696  *
 697  * Returns: the #GArray
 698  *
 699  * Since: 2.4
 700  */
 701 GArray*
 702 g_array_remove_range (GArray *farray,
 703                       guint   index_,
 704                       guint   length)
 705 {
 706   GRealArray *array = (GRealArray*) farray;
 707 
 708   g_return_val_if_fail (array, NULL);
 709   g_return_val_if_fail (index_ &lt;= array-&gt;len, NULL);
 710   g_return_val_if_fail (index_ + length &lt;= array-&gt;len, NULL);
 711 
 712   if (array-&gt;clear_func != NULL)
 713     {
 714       guint i;
 715 
 716       for (i = 0; i &lt; length; i++)
 717         array-&gt;clear_func (g_array_elt_pos (array, index_ + i));
 718     }
 719 
 720   if (index_ + length != array-&gt;len)
 721     memmove (g_array_elt_pos (array, index_),
 722              g_array_elt_pos (array, index_ + length),
 723              (array-&gt;len - (index_ + length)) * array-&gt;elt_size);
 724 
 725   array-&gt;len -= length;
 726   if (G_UNLIKELY (g_mem_gc_friendly))
 727     g_array_elt_zero (array, array-&gt;len, length);
 728   else
 729     g_array_zero_terminate (array);
 730 
 731   return farray;
 732 }
 733 
 734 /**
 735  * g_array_sort:
 736  * @array: a #GArray
 737  * @compare_func: comparison function
 738  *
 739  * Sorts a #GArray using @compare_func which should be a qsort()-style
 740  * comparison function (returns less than zero for first arg is less
 741  * than second arg, zero for equal, greater zero if first arg is
 742  * greater than second arg).
 743  *
 744  * This is guaranteed to be a stable sort since version 2.32.
 745  */
 746 void
 747 g_array_sort (GArray       *farray,
 748               GCompareFunc  compare_func)
 749 {
 750   GRealArray *array = (GRealArray*) farray;
 751 
 752   g_return_if_fail (array != NULL);
 753 
 754   /* Don&#39;t use qsort as we want a guaranteed stable sort */
 755   g_qsort_with_data (array-&gt;data,
 756                      array-&gt;len,
 757                      array-&gt;elt_size,
 758                      (GCompareDataFunc)compare_func,
 759                      NULL);
 760 }
 761 
 762 /**
 763  * g_array_sort_with_data:
 764  * @array: a #GArray
 765  * @compare_func: comparison function
 766  * @user_data: data to pass to @compare_func
 767  *
 768  * Like g_array_sort(), but the comparison function receives an extra
 769  * user data argument.
 770  *
 771  * This is guaranteed to be a stable sort since version 2.32.
 772  *
 773  * There used to be a comment here about making the sort stable by
 774  * using the addresses of the elements in the comparison function.
 775  * This did not actually work, so any such code should be removed.
 776  */
 777 void
 778 g_array_sort_with_data (GArray           *farray,
 779                         GCompareDataFunc  compare_func,
 780                         gpointer          user_data)
 781 {
 782   GRealArray *array = (GRealArray*) farray;
 783 
 784   g_return_if_fail (array != NULL);
 785 
 786   g_qsort_with_data (array-&gt;data,
 787                      array-&gt;len,
 788                      array-&gt;elt_size,
 789                      compare_func,
 790                      user_data);
 791 }
 792 
<a name="5" id="anc5"></a><span class="line-added"> 793 /**</span>
<span class="line-added"> 794  * g_array_binary_search:</span>
<span class="line-added"> 795  * @array: a #GArray.</span>
<span class="line-added"> 796  * @target: a pointer to the item to look up.</span>
<span class="line-added"> 797  * @compare_func: A #GCompareFunc used to locate @target.</span>
<span class="line-added"> 798  * @out_match_index: (optional) (out caller-allocates): return location</span>
<span class="line-added"> 799  *    for the index of the element, if found.</span>
<span class="line-added"> 800  *</span>
<span class="line-added"> 801  * Checks whether @target exists in @array by performing a binary</span>
<span class="line-added"> 802  * search based on the given comparison function @compare_func which</span>
<span class="line-added"> 803  * get pointers to items as arguments. If the element is found, %TRUE</span>
<span class="line-added"> 804  * is returned and the element&#39;s index is returned in @out_match_index</span>
<span class="line-added"> 805  * (if non-%NULL). Otherwise, %FALSE is returned and @out_match_index</span>
<span class="line-added"> 806  * is undefined. If @target exists multiple times in @array, the index</span>
<span class="line-added"> 807  * of the first instance is returned. This search is using a binary</span>
<span class="line-added"> 808  * search, so the @array must absolutely be sorted to return a correct</span>
<span class="line-added"> 809  * result (if not, the function may produce false-negative).</span>
<span class="line-added"> 810  *</span>
<span class="line-added"> 811  * This example defines a comparison function and search an element in a #GArray:</span>
<span class="line-added"> 812  * |[&lt;!-- language=&quot;C&quot; --&gt;</span>
<span class="line-added"> 813  * static gint*</span>
<span class="line-added"> 814  * cmpint (gconstpointer a, gconstpointer b)</span>
<span class="line-added"> 815  * {</span>
<span class="line-added"> 816  *   const gint *_a = a;</span>
<span class="line-added"> 817  *   const gint *_b = b;</span>
<span class="line-added"> 818  *</span>
<span class="line-added"> 819  *   return *_a - *_b;</span>
<span class="line-added"> 820  * }</span>
<span class="line-added"> 821  * ...</span>
<span class="line-added"> 822  * gint i = 424242;</span>
<span class="line-added"> 823  * guint matched_index;</span>
<span class="line-added"> 824  * gboolean result = g_array_binary_search (garray, &amp;i, cmpint, &amp;matched_index);</span>
<span class="line-added"> 825  * ...</span>
<span class="line-added"> 826  * ]|</span>
<span class="line-added"> 827  *</span>
<span class="line-added"> 828  * Returns: %TRUE if @target is one of the elements of @array, %FALSE otherwise.</span>
<span class="line-added"> 829  *</span>
<span class="line-added"> 830  * Since: 2.62</span>
<span class="line-added"> 831  */</span>
<span class="line-added"> 832 gboolean</span>
<span class="line-added"> 833 g_array_binary_search (GArray        *array,</span>
<span class="line-added"> 834                        gconstpointer  target,</span>
<span class="line-added"> 835                        GCompareFunc   compare_func,</span>
<span class="line-added"> 836                        guint         *out_match_index)</span>
<span class="line-added"> 837 {</span>
<span class="line-added"> 838   gboolean result = FALSE;</span>
<span class="line-added"> 839   GRealArray *_array = (GRealArray *) array;</span>
<span class="line-added"> 840   guint left, middle, right;</span>
<span class="line-added"> 841   gint val;</span>
<span class="line-added"> 842 </span>
<span class="line-added"> 843   g_return_val_if_fail (_array != NULL, FALSE);</span>
<span class="line-added"> 844   g_return_val_if_fail (compare_func != NULL, FALSE);</span>
<span class="line-added"> 845 </span>
<span class="line-added"> 846   if (G_LIKELY(_array-&gt;len))</span>
<span class="line-added"> 847     {</span>
<span class="line-added"> 848       left = 0;</span>
<span class="line-added"> 849       right = _array-&gt;len - 1;</span>
<span class="line-added"> 850 </span>
<span class="line-added"> 851       while (left &lt;= right)</span>
<span class="line-added"> 852         {</span>
<span class="line-added"> 853           middle = left + (right - left) / 2;</span>
<span class="line-added"> 854 </span>
<span class="line-added"> 855           val = compare_func (_array-&gt;data + (_array-&gt;elt_size * middle), target);</span>
<span class="line-added"> 856           if (val == 0)</span>
<span class="line-added"> 857             {</span>
<span class="line-added"> 858               result = TRUE;</span>
<span class="line-added"> 859               break;</span>
<span class="line-added"> 860             }</span>
<span class="line-added"> 861           else if (val &lt; 0)</span>
<span class="line-added"> 862             left = middle + 1;</span>
<span class="line-added"> 863           else if (/* val &gt; 0 &amp;&amp; */ middle &gt; 0)</span>
<span class="line-added"> 864             right = middle - 1;</span>
<span class="line-added"> 865           else</span>
<span class="line-added"> 866             break;  /* element not found */</span>
<span class="line-added"> 867         }</span>
<span class="line-added"> 868     }</span>
<span class="line-added"> 869 </span>
<span class="line-added"> 870   if (result &amp;&amp; out_match_index != NULL)</span>
<span class="line-added"> 871     *out_match_index = middle;</span>
<span class="line-added"> 872 </span>
<span class="line-added"> 873   return result;</span>
<span class="line-added"> 874 }</span>
<span class="line-added"> 875 </span>
 876 /* Returns the smallest power of 2 greater than n, or n if
 877  * such power does not fit in a guint
 878  */
 879 static guint
 880 g_nearest_pow (guint num)
 881 {
<a name="6" id="anc6"></a><span class="line-modified"> 882   guint n = num - 1;</span>
<span class="line-added"> 883 </span>
<span class="line-added"> 884   g_assert (num &gt; 0);</span>
 885 
<a name="7" id="anc7"></a><span class="line-modified"> 886   n |= n &gt;&gt; 1;</span>
<span class="line-modified"> 887   n |= n &gt;&gt; 2;</span>
<span class="line-added"> 888   n |= n &gt;&gt; 4;</span>
<span class="line-added"> 889   n |= n &gt;&gt; 8;</span>
<span class="line-added"> 890   n |= n &gt;&gt; 16;</span>
<span class="line-added"> 891 #if SIZEOF_INT == 8</span>
<span class="line-added"> 892   n |= n &gt;&gt; 32;</span>
<span class="line-added"> 893 #endif</span>
 894 
<a name="8" id="anc8"></a><span class="line-modified"> 895   return n + 1;</span>
 896 }
 897 
 898 static void
 899 g_array_maybe_expand (GRealArray *array,
 900                       guint       len)
 901 {
 902   guint want_alloc;
 903 
 904   /* Detect potential overflow */
 905   if G_UNLIKELY ((G_MAXUINT - array-&gt;len) &lt; len)
 906     g_error (&quot;adding %u to array would overflow&quot;, len);
 907 
 908   want_alloc = g_array_elt_len (array, array-&gt;len + len +
<a name="9" id="anc9"></a><span class="line-modified"> 909                                 array-&gt;zero_terminated);</span>
 910 
 911   if (want_alloc &gt; array-&gt;alloc)
 912     {
 913       want_alloc = g_nearest_pow (want_alloc);
 914       want_alloc = MAX (want_alloc, MIN_ARRAY_SIZE);
 915 
 916       array-&gt;data = g_realloc (array-&gt;data, want_alloc);
 917 
 918       if (G_UNLIKELY (g_mem_gc_friendly))
 919         memset (array-&gt;data + array-&gt;alloc, 0, want_alloc - array-&gt;alloc);
 920 
 921       array-&gt;alloc = want_alloc;
 922     }
 923 }
 924 
 925 /**
 926  * SECTION:arrays_pointer
 927  * @title: Pointer Arrays
 928  * @short_description: arrays of pointers to any type of data, which
 929  *     grow automatically as new elements are added
 930  *
 931  * Pointer Arrays are similar to Arrays but are used only for storing
 932  * pointers.
 933  *
 934  * If you remove elements from the array, elements at the end of the
 935  * array are moved into the space previously occupied by the removed
 936  * element. This means that you should not rely on the index of particular
 937  * elements remaining the same. You should also be careful when deleting
 938  * elements while iterating over the array.
 939  *
 940  * To create a pointer array, use g_ptr_array_new().
 941  *
 942  * To add elements to a pointer array, use g_ptr_array_add().
 943  *
 944  * To remove elements from a pointer array, use g_ptr_array_remove(),
 945  * g_ptr_array_remove_index() or g_ptr_array_remove_index_fast().
 946  *
 947  * To access an element of a pointer array, use g_ptr_array_index().
 948  *
 949  * To set the size of a pointer array, use g_ptr_array_set_size().
 950  *
 951  * To free a pointer array, use g_ptr_array_free().
 952  *
 953  * An example using a #GPtrArray:
 954  * |[&lt;!-- language=&quot;C&quot; --&gt;
 955  *   GPtrArray *array;
 956  *   gchar *string1 = &quot;one&quot;;
 957  *   gchar *string2 = &quot;two&quot;;
 958  *   gchar *string3 = &quot;three&quot;;
 959  *
 960  *   array = g_ptr_array_new ();
 961  *   g_ptr_array_add (array, (gpointer) string1);
 962  *   g_ptr_array_add (array, (gpointer) string2);
 963  *   g_ptr_array_add (array, (gpointer) string3);
 964  *
 965  *   if (g_ptr_array_index (array, 0) != (gpointer) string1)
 966  *     g_print (&quot;ERROR: got %p instead of %p\n&quot;,
 967  *              g_ptr_array_index (array, 0), string1);
 968  *
 969  *   g_ptr_array_free (array, TRUE);
 970  * ]|
 971  */
 972 
 973 typedef struct _GRealPtrArray  GRealPtrArray;
 974 
 975 /**
 976  * GPtrArray:
 977  * @pdata: points to the array of pointers, which may be moved when the
 978  *     array grows
 979  * @len: number of pointers in the array
 980  *
 981  * Contains the public fields of a pointer array.
 982  */
 983 struct _GRealPtrArray
 984 {
 985   gpointer       *pdata;
 986   guint           len;
 987   guint           alloc;
 988   gatomicrefcount ref_count;
 989   GDestroyNotify  element_free_func;
 990 };
 991 
 992 /**
 993  * g_ptr_array_index:
 994  * @array: a #GPtrArray
 995  * @index_: the index of the pointer to return
 996  *
 997  * Returns the pointer at the given index of the pointer array.
 998  *
 999  * This does not perform bounds checking on the given @index_,
1000  * so you are responsible for checking it against the array length.
1001  *
1002  * Returns: the pointer at the given index
1003  */
1004 
1005 static void g_ptr_array_maybe_expand (GRealPtrArray *array,
<a name="10" id="anc10"></a><span class="line-modified">1006                                       guint          len);</span>
1007 
1008 /**
1009  * g_ptr_array_new:
1010  *
1011  * Creates a new #GPtrArray with a reference count of 1.
1012  *
1013  * Returns: the new #GPtrArray
1014  */
1015 GPtrArray*
1016 g_ptr_array_new (void)
1017 {
1018   return g_ptr_array_sized_new (0);
1019 }
1020 
<a name="11" id="anc11"></a><span class="line-added">1021 /**</span>
<span class="line-added">1022  * g_ptr_array_copy:</span>
<span class="line-added">1023  * @array: #GPtrArray to duplicate</span>
<span class="line-added">1024  * @func: (nullable): a copy function used to copy every element in the array</span>
<span class="line-added">1025  * @user_data: user data passed to the copy function @func, or %NULL</span>
<span class="line-added">1026  *</span>
<span class="line-added">1027  * Makes a full (deep) copy of a #GPtrArray.</span>
<span class="line-added">1028  *</span>
<span class="line-added">1029  * @func, as a #GCopyFunc, takes two arguments, the data to be copied</span>
<span class="line-added">1030  * and a @user_data pointer. On common processor architectures, it&#39;s safe to</span>
<span class="line-added">1031  * pass %NULL as @user_data if the copy function takes only one argument. You</span>
<span class="line-added">1032  * may get compiler warnings from this though if compiling with GCC&#39;s</span>
<span class="line-added">1033  * `-Wcast-function-type` warning.</span>
<span class="line-added">1034  *</span>
<span class="line-added">1035  * If @func is %NULL, then only the pointers (and not what they are</span>
<span class="line-added">1036  * pointing to) are copied to the new #GPtrArray.</span>
<span class="line-added">1037  *</span>
<span class="line-added">1038  * The copy of @array will have the same #GDestroyNotify for its elements as</span>
<span class="line-added">1039  * @array.</span>
<span class="line-added">1040  *</span>
<span class="line-added">1041  * Returns: (transfer full): a deep copy of the initial #GPtrArray.</span>
<span class="line-added">1042  *</span>
<span class="line-added">1043  * Since: 2.62</span>
<span class="line-added">1044  **/</span>
<span class="line-added">1045 GPtrArray *</span>
<span class="line-added">1046 g_ptr_array_copy (GPtrArray *array,</span>
<span class="line-added">1047                   GCopyFunc  func,</span>
<span class="line-added">1048                   gpointer   user_data)</span>
<span class="line-added">1049 {</span>
<span class="line-added">1050   gsize i;</span>
<span class="line-added">1051   GPtrArray *new_array;</span>
<span class="line-added">1052 </span>
<span class="line-added">1053   g_return_val_if_fail (array != NULL, NULL);</span>
<span class="line-added">1054 </span>
<span class="line-added">1055   new_array = g_ptr_array_sized_new (array-&gt;len);</span>
<span class="line-added">1056   g_ptr_array_set_free_func (new_array, ((GRealPtrArray *) array)-&gt;element_free_func);</span>
<span class="line-added">1057 </span>
<span class="line-added">1058   if (func != NULL)</span>
<span class="line-added">1059     {</span>
<span class="line-added">1060       for (i = 0; i &lt; array-&gt;len; i++)</span>
<span class="line-added">1061         new_array-&gt;pdata[i] = func (array-&gt;pdata[i], user_data);</span>
<span class="line-added">1062     }</span>
<span class="line-added">1063   else</span>
<span class="line-added">1064     {</span>
<span class="line-added">1065       memcpy (new_array-&gt;pdata, array-&gt;pdata,</span>
<span class="line-added">1066               array-&gt;len * sizeof (*array-&gt;pdata));</span>
<span class="line-added">1067     }</span>
<span class="line-added">1068 </span>
<span class="line-added">1069   new_array-&gt;len = array-&gt;len;</span>
<span class="line-added">1070 </span>
<span class="line-added">1071   return new_array;</span>
<span class="line-added">1072 }</span>
<span class="line-added">1073 </span>
1074 /**
1075  * g_ptr_array_sized_new:
1076  * @reserved_size: number of pointers preallocated
1077  *
1078  * Creates a new #GPtrArray with @reserved_size pointers preallocated
1079  * and a reference count of 1. This avoids frequent reallocation, if
1080  * you are going to add many pointers to the array. Note however that
1081  * the size of the array is still 0.
1082  *
1083  * Returns: the new #GPtrArray
1084  */
1085 GPtrArray*
1086 g_ptr_array_sized_new (guint reserved_size)
1087 {
1088   GRealPtrArray *array;
1089 
1090   array = g_slice_new (GRealPtrArray);
1091 #ifdef GSTREAMER_LITE
1092   if (array == NULL) {
1093     return NULL;
1094   }
1095 #endif // GSTREAMER_LITE
1096 
1097   array-&gt;pdata = NULL;
1098   array-&gt;len = 0;
1099   array-&gt;alloc = 0;
1100   array-&gt;element_free_func = NULL;
1101 
1102   g_atomic_ref_count_init (&amp;array-&gt;ref_count);
1103 
1104   if (reserved_size != 0)
1105     g_ptr_array_maybe_expand (array, reserved_size);
1106 
1107   return (GPtrArray*) array;
1108 }
1109 
<a name="12" id="anc12"></a><span class="line-added">1110 /**</span>
<span class="line-added">1111  * g_array_copy:</span>
<span class="line-added">1112  * @array: A #GArray.</span>
<span class="line-added">1113  *</span>
<span class="line-added">1114  * Create a shallow copy of a #GArray. If the array elements consist of</span>
<span class="line-added">1115  * pointers to data, the pointers are copied but the actual data is not.</span>
<span class="line-added">1116  *</span>
<span class="line-added">1117  * Returns: (transfer container): A copy of @array.</span>
<span class="line-added">1118  *</span>
<span class="line-added">1119  * Since: 2.62</span>
<span class="line-added">1120  **/</span>
<span class="line-added">1121 GArray *</span>
<span class="line-added">1122 g_array_copy (GArray *array)</span>
<span class="line-added">1123 {</span>
<span class="line-added">1124   GRealArray *rarray = (GRealArray *) array;</span>
<span class="line-added">1125   GRealArray *new_rarray;</span>
<span class="line-added">1126 </span>
<span class="line-added">1127   g_return_val_if_fail (rarray != NULL, NULL);</span>
<span class="line-added">1128 </span>
<span class="line-added">1129   new_rarray =</span>
<span class="line-added">1130     (GRealArray *) g_array_sized_new (rarray-&gt;zero_terminated, rarray-&gt;clear,</span>
<span class="line-added">1131                                       rarray-&gt;elt_size, rarray-&gt;len);</span>
<span class="line-added">1132   new_rarray-&gt;len = rarray-&gt;len;</span>
<span class="line-added">1133   memcpy (new_rarray-&gt;data, rarray-&gt;data, rarray-&gt;alloc);</span>
<span class="line-added">1134 </span>
<span class="line-added">1135   return (GArray *) new_rarray;</span>
<span class="line-added">1136 }</span>
<span class="line-added">1137 </span>
1138 /**
1139  * g_ptr_array_new_with_free_func:
1140  * @element_free_func: (nullable): A function to free elements with
1141  *     destroy @array or %NULL
1142  *
1143  * Creates a new #GPtrArray with a reference count of 1 and use
1144  * @element_free_func for freeing each element when the array is destroyed
1145  * either via g_ptr_array_unref(), when g_ptr_array_free() is called with
1146  * @free_segment set to %TRUE or when removing elements.
1147  *
1148  * Returns: A new #GPtrArray
1149  *
1150  * Since: 2.22
1151  */
1152 GPtrArray*
1153 g_ptr_array_new_with_free_func (GDestroyNotify element_free_func)
1154 {
1155   GPtrArray *array;
1156 
1157   array = g_ptr_array_new ();
1158   g_ptr_array_set_free_func (array, element_free_func);
1159 
1160   return array;
1161 }
1162 
1163 /**
1164  * g_ptr_array_new_full:
1165  * @reserved_size: number of pointers preallocated
1166  * @element_free_func: (nullable): A function to free elements with
1167  *     destroy @array or %NULL
1168  *
1169  * Creates a new #GPtrArray with @reserved_size pointers preallocated
1170  * and a reference count of 1. This avoids frequent reallocation, if
1171  * you are going to add many pointers to the array. Note however that
1172  * the size of the array is still 0. It also set @element_free_func
1173  * for freeing each element when the array is destroyed either via
1174  * g_ptr_array_unref(), when g_ptr_array_free() is called with
1175  * @free_segment set to %TRUE or when removing elements.
1176  *
1177  * Returns: A new #GPtrArray
1178  *
1179  * Since: 2.30
1180  */
1181 GPtrArray*
1182 g_ptr_array_new_full (guint          reserved_size,
1183                       GDestroyNotify element_free_func)
1184 {
1185   GPtrArray *array;
1186 
1187   array = g_ptr_array_sized_new (reserved_size);
1188   g_ptr_array_set_free_func (array, element_free_func);
1189 
1190   return array;
1191 }
1192 
1193 /**
1194  * g_ptr_array_set_free_func:
1195  * @array: A #GPtrArray
1196  * @element_free_func: (nullable): A function to free elements with
1197  *     destroy @array or %NULL
1198  *
1199  * Sets a function for freeing each element when @array is destroyed
1200  * either via g_ptr_array_unref(), when g_ptr_array_free() is called
1201  * with @free_segment set to %TRUE or when removing elements.
1202  *
1203  * Since: 2.22
1204  */
1205 void
1206 g_ptr_array_set_free_func (GPtrArray      *array,
1207                            GDestroyNotify  element_free_func)
1208 {
1209   GRealPtrArray *rarray = (GRealPtrArray *)array;
1210 
1211   g_return_if_fail (array);
1212 #ifdef GSTREAMER_LITE
1213   if (array == NULL)
1214     return;
1215 #endif // GSTREAMER_LITE
1216 
1217   rarray-&gt;element_free_func = element_free_func;
1218 }
1219 
1220 /**
1221  * g_ptr_array_ref:
1222  * @array: a #GPtrArray
1223  *
1224  * Atomically increments the reference count of @array by one.
1225  * This function is thread-safe and may be called from any thread.
1226  *
1227  * Returns: The passed in #GPtrArray
1228  *
1229  * Since: 2.22
1230  */
1231 GPtrArray*
1232 g_ptr_array_ref (GPtrArray *array)
1233 {
1234   GRealPtrArray *rarray = (GRealPtrArray *)array;
1235 
1236   g_return_val_if_fail (array, NULL);
1237 
1238   g_atomic_ref_count_inc (&amp;rarray-&gt;ref_count);
1239 
1240   return array;
1241 }
1242 
1243 static gpointer *ptr_array_free (GPtrArray *, ArrayFreeFlags);
1244 
1245 /**
1246  * g_ptr_array_unref:
1247  * @array: A #GPtrArray
1248  *
1249  * Atomically decrements the reference count of @array by one. If the
1250  * reference count drops to 0, the effect is the same as calling
1251  * g_ptr_array_free() with @free_segment set to %TRUE. This function
1252  * is thread-safe and may be called from any thread.
1253  *
1254  * Since: 2.22
1255  */
1256 void
1257 g_ptr_array_unref (GPtrArray *array)
1258 {
1259   GRealPtrArray *rarray = (GRealPtrArray *)array;
1260 
1261   g_return_if_fail (array);
1262 
1263   if (g_atomic_ref_count_dec (&amp;rarray-&gt;ref_count))
1264     ptr_array_free (array, FREE_SEGMENT);
1265 }
1266 
1267 /**
1268  * g_ptr_array_free:
1269  * @array: a #GPtrArray
1270  * @free_seg: if %TRUE the actual pointer array is freed as well
1271  *
1272  * Frees the memory allocated for the #GPtrArray. If @free_seg is %TRUE
1273  * it frees the memory block holding the elements as well. Pass %FALSE
1274  * if you want to free the #GPtrArray wrapper but preserve the
1275  * underlying array for use elsewhere. If the reference count of @array
1276  * is greater than one, the #GPtrArray wrapper is preserved but the
1277  * size of @array will be set to zero.
1278  *
1279  * If array contents point to dynamically-allocated memory, they should
1280  * be freed separately if @free_seg is %TRUE and no #GDestroyNotify
1281  * function has been set for @array.
1282  *
1283  * This function is not thread-safe. If using a #GPtrArray from multiple
1284  * threads, use only the atomic g_ptr_array_ref() and g_ptr_array_unref()
1285  * functions.
1286  *
1287  * Returns: the pointer array if @free_seg is %FALSE, otherwise %NULL.
1288  *     The pointer array should be freed using g_free().
1289  */
1290 gpointer*
1291 g_ptr_array_free (GPtrArray *array,
1292                   gboolean   free_segment)
1293 {
1294   GRealPtrArray *rarray = (GRealPtrArray *)array;
1295   ArrayFreeFlags flags;
1296 
1297   g_return_val_if_fail (rarray, NULL);
1298 
1299   flags = (free_segment ? FREE_SEGMENT : 0);
1300 
1301   /* if others are holding a reference, preserve the wrapper but
1302    * do free/return the data
1303    */
1304   if (!g_atomic_ref_count_dec (&amp;rarray-&gt;ref_count))
1305     flags |= PRESERVE_WRAPPER;
1306 
1307   return ptr_array_free (array, flags);
1308 }
1309 
1310 static gpointer *
1311 ptr_array_free (GPtrArray      *array,
1312                 ArrayFreeFlags  flags)
1313 {
1314   GRealPtrArray *rarray = (GRealPtrArray *)array;
1315   gpointer *segment;
1316 
1317   if (flags &amp; FREE_SEGMENT)
1318     {
1319       /* Data here is stolen and freed manually. It is an
1320        * error to attempt to access the array data (including
1321        * mutating the array bounds) during destruction).
1322        *
1323        * https://bugzilla.gnome.org/show_bug.cgi?id=769064
1324        */
1325       gpointer *stolen_pdata = g_steal_pointer (&amp;rarray-&gt;pdata);
1326       if (rarray-&gt;element_free_func != NULL)
1327         {
1328           gsize i;
1329           for (i = 0; i &lt; rarray-&gt;len; ++i)
1330             rarray-&gt;element_free_func (stolen_pdata[i]);
1331         }
1332 
1333       g_free (stolen_pdata);
1334       segment = NULL;
1335     }
1336   else
1337     segment = rarray-&gt;pdata;
1338 
1339   if (flags &amp; PRESERVE_WRAPPER)
1340     {
1341       rarray-&gt;pdata = NULL;
1342       rarray-&gt;len = 0;
1343       rarray-&gt;alloc = 0;
1344     }
1345   else
1346     {
1347       g_slice_free1 (sizeof (GRealPtrArray), rarray);
1348     }
1349 
1350   return segment;
1351 }
1352 
1353 static void
1354 g_ptr_array_maybe_expand (GRealPtrArray *array,
<a name="13" id="anc13"></a><span class="line-modified">1355                           guint          len)</span>
1356 {
1357   /* Detect potential overflow */
1358   if G_UNLIKELY ((G_MAXUINT - array-&gt;len) &lt; len)
1359     g_error (&quot;adding %u to array would overflow&quot;, len);
1360 
1361   if ((array-&gt;len + len) &gt; array-&gt;alloc)
1362     {
1363       guint old_alloc = array-&gt;alloc;
1364       array-&gt;alloc = g_nearest_pow (array-&gt;len + len);
1365       array-&gt;alloc = MAX (array-&gt;alloc, MIN_ARRAY_SIZE);
1366       array-&gt;pdata = g_realloc (array-&gt;pdata, sizeof (gpointer) * array-&gt;alloc);
1367       if (G_UNLIKELY (g_mem_gc_friendly))
1368         for ( ; old_alloc &lt; array-&gt;alloc; old_alloc++)
1369           array-&gt;pdata [old_alloc] = NULL;
1370     }
1371 }
1372 
1373 /**
1374  * g_ptr_array_set_size:
1375  * @array: a #GPtrArray
1376  * @length: the new length of the pointer array
1377  *
1378  * Sets the size of the array. When making the array larger,
1379  * newly-added elements will be set to %NULL. When making it smaller,
1380  * if @array has a non-%NULL #GDestroyNotify function then it will be
1381  * called for the removed elements.
1382  */
1383 void
1384 g_ptr_array_set_size  (GPtrArray *array,
1385                        gint       length)
1386 {
1387   GRealPtrArray *rarray = (GRealPtrArray *)array;
1388   guint length_unsigned;
1389 
1390   g_return_if_fail (rarray);
1391   g_return_if_fail (rarray-&gt;len == 0 || (rarray-&gt;len != 0 &amp;&amp; rarray-&gt;pdata != NULL));
1392   g_return_if_fail (length &gt;= 0);
1393 
1394   length_unsigned = (guint) length;
1395 
1396   if (length_unsigned &gt; rarray-&gt;len)
1397     {
1398       guint i;
1399       g_ptr_array_maybe_expand (rarray, (length_unsigned - rarray-&gt;len));
1400       /* This is not
1401        *     memset (array-&gt;pdata + array-&gt;len, 0,
1402        *            sizeof (gpointer) * (length_unsigned - array-&gt;len));
1403        * to make it really portable. Remember (void*)NULL needn&#39;t be
1404        * bitwise zero. It of course is silly not to use memset (..,0,..).
1405        */
1406       for (i = rarray-&gt;len; i &lt; length_unsigned; i++)
1407         rarray-&gt;pdata[i] = NULL;
1408     }
1409   else if (length_unsigned &lt; rarray-&gt;len)
1410     g_ptr_array_remove_range (array, length_unsigned, rarray-&gt;len - length_unsigned);
1411 
1412   rarray-&gt;len = length_unsigned;
1413 }
1414 
1415 static gpointer
1416 ptr_array_remove_index (GPtrArray *array,
1417                         guint      index_,
1418                         gboolean   fast,
1419                         gboolean   free_element)
1420 {
1421   GRealPtrArray *rarray = (GRealPtrArray *) array;
1422   gpointer result;
1423 
1424   g_return_val_if_fail (rarray, NULL);
1425   g_return_val_if_fail (rarray-&gt;len == 0 || (rarray-&gt;len != 0 &amp;&amp; rarray-&gt;pdata != NULL), NULL);
1426 
1427   g_return_val_if_fail (index_ &lt; rarray-&gt;len, NULL);
1428 
1429   result = rarray-&gt;pdata[index_];
1430 
1431   if (rarray-&gt;element_free_func != NULL &amp;&amp; free_element)
1432     rarray-&gt;element_free_func (rarray-&gt;pdata[index_]);
1433 
1434   if (index_ != rarray-&gt;len - 1 &amp;&amp; !fast)
1435     memmove (rarray-&gt;pdata + index_, rarray-&gt;pdata + index_ + 1,
1436              sizeof (gpointer) * (rarray-&gt;len - index_ - 1));
1437   else if (index_ != rarray-&gt;len - 1)
1438     rarray-&gt;pdata[index_] = rarray-&gt;pdata[rarray-&gt;len - 1];
1439 
1440   rarray-&gt;len -= 1;
1441 
1442   if (G_UNLIKELY (g_mem_gc_friendly))
1443     rarray-&gt;pdata[rarray-&gt;len] = NULL;
1444 
1445   return result;
1446 }
1447 
1448 /**
1449  * g_ptr_array_remove_index:
1450  * @array: a #GPtrArray
1451  * @index_: the index of the pointer to remove
1452  *
1453  * Removes the pointer at the given index from the pointer array.
1454  * The following elements are moved down one place. If @array has
1455  * a non-%NULL #GDestroyNotify function it is called for the removed
1456  * element. If so, the return value from this function will potentially point
1457  * to freed memory (depending on the #GDestroyNotify implementation).
1458  *
1459  * Returns: (nullable): the pointer which was removed
1460  */
1461 gpointer
1462 g_ptr_array_remove_index (GPtrArray *array,
1463                           guint      index_)
1464 {
1465   return ptr_array_remove_index (array, index_, FALSE, TRUE);
1466 }
1467 
1468 /**
1469  * g_ptr_array_remove_index_fast:
1470  * @array: a #GPtrArray
1471  * @index_: the index of the pointer to remove
1472  *
1473  * Removes the pointer at the given index from the pointer array.
1474  * The last element in the array is used to fill in the space, so
1475  * this function does not preserve the order of the array. But it
1476  * is faster than g_ptr_array_remove_index(). If @array has a non-%NULL
1477  * #GDestroyNotify function it is called for the removed element. If so, the
1478  * return value from this function will potentially point to freed memory
1479  * (depending on the #GDestroyNotify implementation).
1480  *
1481  * Returns: (nullable): the pointer which was removed
1482  */
1483 gpointer
1484 g_ptr_array_remove_index_fast (GPtrArray *array,
1485                                guint      index_)
1486 {
1487   return ptr_array_remove_index (array, index_, TRUE, TRUE);
1488 }
1489 
1490 /**
1491  * g_ptr_array_steal_index:
1492  * @array: a #GPtrArray
1493  * @index_: the index of the pointer to steal
1494  *
1495  * Removes the pointer at the given index from the pointer array.
1496  * The following elements are moved down one place. The #GDestroyNotify for
1497  * @array is *not* called on the removed element; ownership is transferred to
1498  * the caller of this function.
1499  *
1500  * Returns: (transfer full) (nullable): the pointer which was removed
1501  * Since: 2.58
1502  */
1503 gpointer
1504 g_ptr_array_steal_index (GPtrArray *array,
1505                          guint      index_)
1506 {
1507   return ptr_array_remove_index (array, index_, FALSE, FALSE);
1508 }
1509 
1510 /**
1511  * g_ptr_array_steal_index_fast:
1512  * @array: a #GPtrArray
1513  * @index_: the index of the pointer to steal
1514  *
1515  * Removes the pointer at the given index from the pointer array.
1516  * The last element in the array is used to fill in the space, so
1517  * this function does not preserve the order of the array. But it
1518  * is faster than g_ptr_array_steal_index(). The #GDestroyNotify for @array is
1519  * *not* called on the removed element; ownership is transferred to the caller
1520  * of this function.
1521  *
1522  * Returns: (transfer full) (nullable): the pointer which was removed
1523  * Since: 2.58
1524  */
1525 gpointer
1526 g_ptr_array_steal_index_fast (GPtrArray *array,
1527                               guint      index_)
1528 {
1529   return ptr_array_remove_index (array, index_, TRUE, FALSE);
1530 }
1531 
1532 /**
1533  * g_ptr_array_remove_range:
1534  * @array: a @GPtrArray
1535  * @index_: the index of the first pointer to remove
1536  * @length: the number of pointers to remove
1537  *
1538  * Removes the given number of pointers starting at the given index
1539  * from a #GPtrArray. The following elements are moved to close the
1540  * gap. If @array has a non-%NULL #GDestroyNotify function it is
1541  * called for the removed elements.
1542  *
1543  * Returns: the @array
1544  *
1545  * Since: 2.4
1546  */
1547 GPtrArray*
1548 g_ptr_array_remove_range (GPtrArray *array,
1549                           guint      index_,
1550                           guint      length)
1551 {
1552   GRealPtrArray *rarray = (GRealPtrArray *)array;
1553   guint n;
1554 
1555   g_return_val_if_fail (rarray != NULL, NULL);
1556   g_return_val_if_fail (rarray-&gt;len == 0 || (rarray-&gt;len != 0 &amp;&amp; rarray-&gt;pdata != NULL), NULL);
1557   g_return_val_if_fail (index_ &lt;= rarray-&gt;len, NULL);
1558   g_return_val_if_fail (index_ + length &lt;= rarray-&gt;len, NULL);
1559 
1560   if (rarray-&gt;element_free_func != NULL)
1561     {
1562       for (n = index_; n &lt; index_ + length; n++)
1563         rarray-&gt;element_free_func (rarray-&gt;pdata[n]);
1564     }
1565 
1566   if (index_ + length != rarray-&gt;len)
1567     {
1568       memmove (&amp;rarray-&gt;pdata[index_],
1569                &amp;rarray-&gt;pdata[index_ + length],
1570                (rarray-&gt;len - (index_ + length)) * sizeof (gpointer));
1571     }
1572 
1573   rarray-&gt;len -= length;
1574   if (G_UNLIKELY (g_mem_gc_friendly))
1575     {
1576       guint i;
1577       for (i = 0; i &lt; length; i++)
1578         rarray-&gt;pdata[rarray-&gt;len + i] = NULL;
1579     }
1580 
1581   return array;
1582 }
1583 
1584 /**
1585  * g_ptr_array_remove:
1586  * @array: a #GPtrArray
1587  * @data: the pointer to remove
1588  *
1589  * Removes the first occurrence of the given pointer from the pointer
1590  * array. The following elements are moved down one place. If @array
1591  * has a non-%NULL #GDestroyNotify function it is called for the
1592  * removed element.
1593  *
1594  * It returns %TRUE if the pointer was removed, or %FALSE if the
1595  * pointer was not found.
1596  *
1597  * Returns: %TRUE if the pointer is removed, %FALSE if the pointer
1598  *     is not found in the array
1599  */
1600 gboolean
1601 g_ptr_array_remove (GPtrArray *array,
1602                     gpointer   data)
1603 {
1604   guint i;
1605 
1606   g_return_val_if_fail (array, FALSE);
1607   g_return_val_if_fail (array-&gt;len == 0 || (array-&gt;len != 0 &amp;&amp; array-&gt;pdata != NULL), FALSE);
1608 
1609   for (i = 0; i &lt; array-&gt;len; i += 1)
1610     {
1611       if (array-&gt;pdata[i] == data)
1612         {
1613           g_ptr_array_remove_index (array, i);
1614           return TRUE;
1615         }
1616     }
1617 
1618   return FALSE;
1619 }
1620 
1621 /**
1622  * g_ptr_array_remove_fast:
1623  * @array: a #GPtrArray
1624  * @data: the pointer to remove
1625  *
1626  * Removes the first occurrence of the given pointer from the pointer
1627  * array. The last element in the array is used to fill in the space,
1628  * so this function does not preserve the order of the array. But it
1629  * is faster than g_ptr_array_remove(). If @array has a non-%NULL
1630  * #GDestroyNotify function it is called for the removed element.
1631  *
1632  * It returns %TRUE if the pointer was removed, or %FALSE if the
1633  * pointer was not found.
1634  *
1635  * Returns: %TRUE if the pointer was found in the array
1636  */
1637 gboolean
1638 g_ptr_array_remove_fast (GPtrArray *array,
1639                          gpointer   data)
1640 {
1641   GRealPtrArray *rarray = (GRealPtrArray *)array;
1642   guint i;
1643 
1644   g_return_val_if_fail (rarray, FALSE);
1645   g_return_val_if_fail (rarray-&gt;len == 0 || (rarray-&gt;len != 0 &amp;&amp; rarray-&gt;pdata != NULL), FALSE);
1646 
1647   for (i = 0; i &lt; rarray-&gt;len; i += 1)
1648     {
1649       if (rarray-&gt;pdata[i] == data)
1650         {
1651           g_ptr_array_remove_index_fast (array, i);
1652           return TRUE;
1653         }
1654     }
1655 
1656   return FALSE;
1657 }
1658 
1659 /**
1660  * g_ptr_array_add:
1661  * @array: a #GPtrArray
1662  * @data: the pointer to add
1663  *
1664  * Adds a pointer to the end of the pointer array. The array will grow
1665  * in size automatically if necessary.
1666  */
1667 void
1668 g_ptr_array_add (GPtrArray *array,
1669                  gpointer   data)
1670 {
1671   GRealPtrArray *rarray = (GRealPtrArray *)array;
1672 
1673   g_return_if_fail (rarray);
1674   g_return_if_fail (rarray-&gt;len == 0 || (rarray-&gt;len != 0 &amp;&amp; rarray-&gt;pdata != NULL));
1675 
1676   g_ptr_array_maybe_expand (rarray, 1);
1677 
1678   rarray-&gt;pdata[rarray-&gt;len++] = data;
1679 }
1680 
<a name="14" id="anc14"></a><span class="line-added">1681 /**</span>
<span class="line-added">1682  * g_ptr_array_extend:</span>
<span class="line-added">1683  * @array_to_extend: a #GPtrArray.</span>
<span class="line-added">1684  * @array: (transfer none): a #GPtrArray to add to the end of @array_to_extend.</span>
<span class="line-added">1685  * @func: (nullable): a copy function used to copy every element in the array</span>
<span class="line-added">1686  * @user_data: user data passed to the copy function @func, or %NULL</span>
<span class="line-added">1687  *</span>
<span class="line-added">1688  * Adds all pointers of @array to the end of the array @array_to_extend.</span>
<span class="line-added">1689  * The array will grow in size automatically if needed. @array_to_extend is</span>
<span class="line-added">1690  * modified in-place.</span>
<span class="line-added">1691  *</span>
<span class="line-added">1692  * @func, as a #GCopyFunc, takes two arguments, the data to be copied</span>
<span class="line-added">1693  * and a @user_data pointer. On common processor architectures, it&#39;s safe to</span>
<span class="line-added">1694  * pass %NULL as @user_data if the copy function takes only one argument. You</span>
<span class="line-added">1695  * may get compiler warnings from this though if compiling with GCC&#39;s</span>
<span class="line-added">1696  * `-Wcast-function-type` warning.</span>
<span class="line-added">1697  *</span>
<span class="line-added">1698  * If @func is %NULL, then only the pointers (and not what they are</span>
<span class="line-added">1699  * pointing to) are copied to the new #GPtrArray.</span>
<span class="line-added">1700  *</span>
<span class="line-added">1701  * Since: 2.62</span>
<span class="line-added">1702  **/</span>
<span class="line-added">1703 void</span>
<span class="line-added">1704 g_ptr_array_extend (GPtrArray  *array_to_extend,</span>
<span class="line-added">1705                     GPtrArray  *array,</span>
<span class="line-added">1706                     GCopyFunc   func,</span>
<span class="line-added">1707                     gpointer    user_data)</span>
<span class="line-added">1708 {</span>
<span class="line-added">1709   GRealPtrArray *rarray_to_extend = (GRealPtrArray *) array_to_extend;</span>
<span class="line-added">1710   gsize i;</span>
<span class="line-added">1711 </span>
<span class="line-added">1712   g_return_if_fail (array_to_extend != NULL);</span>
<span class="line-added">1713   g_return_if_fail (array != NULL);</span>
<span class="line-added">1714 </span>
<span class="line-added">1715   g_ptr_array_maybe_expand (rarray_to_extend, array-&gt;len);</span>
<span class="line-added">1716 </span>
<span class="line-added">1717   if (func != NULL)</span>
<span class="line-added">1718     {</span>
<span class="line-added">1719       for (i = 0; i &lt; array-&gt;len; i++)</span>
<span class="line-added">1720         rarray_to_extend-&gt;pdata[i + rarray_to_extend-&gt;len] =</span>
<span class="line-added">1721           func (array-&gt;pdata[i], user_data);</span>
<span class="line-added">1722     }</span>
<span class="line-added">1723   else</span>
<span class="line-added">1724     {</span>
<span class="line-added">1725       memcpy (rarray_to_extend-&gt;pdata + rarray_to_extend-&gt;len, array-&gt;pdata,</span>
<span class="line-added">1726               array-&gt;len * sizeof (*array-&gt;pdata));</span>
<span class="line-added">1727     }</span>
<span class="line-added">1728 </span>
<span class="line-added">1729   rarray_to_extend-&gt;len += array-&gt;len;</span>
<span class="line-added">1730 }</span>
<span class="line-added">1731 </span>
<span class="line-added">1732 /**</span>
<span class="line-added">1733  * g_ptr_array_extend_and_steal:</span>
<span class="line-added">1734  * @array_to_extend: (transfer none): a #GPtrArray.</span>
<span class="line-added">1735  * @array: (transfer container): a #GPtrArray to add to the end of</span>
<span class="line-added">1736  *     @array_to_extend.</span>
<span class="line-added">1737  *</span>
<span class="line-added">1738  * Adds all the pointers in @array to the end of @array_to_extend, transferring</span>
<span class="line-added">1739  * ownership of each element from @array to @array_to_extend and modifying</span>
<span class="line-added">1740  * @array_to_extend in-place. @array is then freed.</span>
<span class="line-added">1741  *</span>
<span class="line-added">1742  * As with g_ptr_array_free(), @array will be destroyed if its reference count</span>
<span class="line-added">1743  * is 1. If its reference count is higher, it will be decremented and the</span>
<span class="line-added">1744  * length of @array set to zero.</span>
<span class="line-added">1745  *</span>
<span class="line-added">1746  * Since: 2.62</span>
<span class="line-added">1747  **/</span>
<span class="line-added">1748 void</span>
<span class="line-added">1749 g_ptr_array_extend_and_steal (GPtrArray  *array_to_extend,</span>
<span class="line-added">1750                               GPtrArray  *array)</span>
<span class="line-added">1751 {</span>
<span class="line-added">1752   gpointer *pdata;</span>
<span class="line-added">1753 </span>
<span class="line-added">1754   g_ptr_array_extend (array_to_extend, array, NULL, NULL);</span>
<span class="line-added">1755 </span>
<span class="line-added">1756   /* Get rid of @array without triggering the GDestroyNotify attached</span>
<span class="line-added">1757    * to the elements moved from @array to @array_to_extend. */</span>
<span class="line-added">1758   pdata = g_steal_pointer (&amp;array-&gt;pdata);</span>
<span class="line-added">1759   array-&gt;len = 0;</span>
<span class="line-added">1760   g_ptr_array_unref (array);</span>
<span class="line-added">1761   g_free (pdata);</span>
<span class="line-added">1762 }</span>
<span class="line-added">1763 </span>
1764 /**
1765  * g_ptr_array_insert:
1766  * @array: a #GPtrArray
1767  * @index_: the index to place the new element at, or -1 to append
1768  * @data: the pointer to add.
1769  *
1770  * Inserts an element into the pointer array at the given index. The
1771  * array will grow in size automatically if necessary.
1772  *
1773  * Since: 2.40
1774  */
1775 void
1776 g_ptr_array_insert (GPtrArray *array,
1777                     gint       index_,
1778                     gpointer   data)
1779 {
1780   GRealPtrArray *rarray = (GRealPtrArray *)array;
1781 
1782   g_return_if_fail (rarray);
1783   g_return_if_fail (index_ &gt;= -1);
1784   g_return_if_fail (index_ &lt;= (gint)rarray-&gt;len);
1785 
1786   g_ptr_array_maybe_expand (rarray, 1);
1787 
1788   if (index_ &lt; 0)
1789     index_ = rarray-&gt;len;
1790 
<a name="15" id="anc15"></a><span class="line-modified">1791   if ((guint) index_ &lt; rarray-&gt;len)</span>
1792     memmove (&amp;(rarray-&gt;pdata[index_ + 1]),
1793              &amp;(rarray-&gt;pdata[index_]),
1794              (rarray-&gt;len - index_) * sizeof (gpointer));
1795 
1796   rarray-&gt;len++;
1797   rarray-&gt;pdata[index_] = data;
1798 }
1799 
1800 /**
1801  * g_ptr_array_sort:
1802  * @array: a #GPtrArray
1803  * @compare_func: comparison function
1804  *
1805  * Sorts the array, using @compare_func which should be a qsort()-style
1806  * comparison function (returns less than zero for first arg is less
1807  * than second arg, zero for equal, greater than zero if irst arg is
1808  * greater than second arg).
1809  *
1810  * Note that the comparison function for g_ptr_array_sort() doesn&#39;t
1811  * take the pointers from the array as arguments, it takes pointers to
1812  * the pointers in the array.
1813  *
1814  * This is guaranteed to be a stable sort since version 2.32.
1815  */
1816 void
1817 g_ptr_array_sort (GPtrArray    *array,
1818                   GCompareFunc  compare_func)
1819 {
1820   g_return_if_fail (array != NULL);
1821 
1822   /* Don&#39;t use qsort as we want a guaranteed stable sort */
1823   g_qsort_with_data (array-&gt;pdata,
1824                      array-&gt;len,
1825                      sizeof (gpointer),
1826                      (GCompareDataFunc)compare_func,
1827                      NULL);
1828 }
1829 
1830 /**
1831  * g_ptr_array_sort_with_data:
1832  * @array: a #GPtrArray
1833  * @compare_func: comparison function
1834  * @user_data: data to pass to @compare_func
1835  *
1836  * Like g_ptr_array_sort(), but the comparison function has an extra
1837  * user data argument.
1838  *
1839  * Note that the comparison function for g_ptr_array_sort_with_data()
1840  * doesn&#39;t take the pointers from the array as arguments, it takes
1841  * pointers to the pointers in the array.
1842  *
1843  * This is guaranteed to be a stable sort since version 2.32.
1844  */
1845 void
1846 g_ptr_array_sort_with_data (GPtrArray        *array,
1847                             GCompareDataFunc  compare_func,
1848                             gpointer          user_data)
1849 {
1850   g_return_if_fail (array != NULL);
1851 
1852   g_qsort_with_data (array-&gt;pdata,
1853                      array-&gt;len,
1854                      sizeof (gpointer),
1855                      compare_func,
1856                      user_data);
1857 }
1858 
1859 /**
1860  * g_ptr_array_foreach:
1861  * @array: a #GPtrArray
1862  * @func: the function to call for each array element
1863  * @user_data: user data to pass to the function
1864  *
1865  * Calls a function for each element of a #GPtrArray. @func must not
1866  * add elements to or remove elements from the array.
1867  *
1868  * Since: 2.4
1869  */
1870 void
1871 g_ptr_array_foreach (GPtrArray *array,
1872                      GFunc      func,
1873                      gpointer   user_data)
1874 {
1875   guint i;
1876 
1877   g_return_if_fail (array);
1878 
1879   for (i = 0; i &lt; array-&gt;len; i++)
1880     (*func) (array-&gt;pdata[i], user_data);
1881 }
1882 
1883 /**
1884  * g_ptr_array_find: (skip)
1885  * @haystack: pointer array to be searched
1886  * @needle: pointer to look for
1887  * @index_: (optional) (out caller-allocates): return location for the index of
1888  *    the element, if found
1889  *
1890  * Checks whether @needle exists in @haystack. If the element is found, %TRUE is
1891  * returned and the element&#39;s index is returned in @index_ (if non-%NULL).
1892  * Otherwise, %FALSE is returned and @index_ is undefined. If @needle exists
1893  * multiple times in @haystack, the index of the first instance is returned.
1894  *
1895  * This does pointer comparisons only. If you want to use more complex equality
1896  * checks, such as string comparisons, use g_ptr_array_find_with_equal_func().
1897  *
1898  * Returns: %TRUE if @needle is one of the elements of @haystack
1899  * Since: 2.54
1900  */
1901 gboolean
1902 g_ptr_array_find (GPtrArray     *haystack,
1903                   gconstpointer  needle,
1904                   guint         *index_)
1905 {
1906   return g_ptr_array_find_with_equal_func (haystack, needle, NULL, index_);
1907 }
1908 
1909 /**
1910  * g_ptr_array_find_with_equal_func: (skip)
1911  * @haystack: pointer array to be searched
1912  * @needle: pointer to look for
1913  * @equal_func: (nullable): the function to call for each element, which should
1914  *    return %TRUE when the desired element is found; or %NULL to use pointer
1915  *    equality
1916  * @index_: (optional) (out caller-allocates): return location for the index of
1917  *    the element, if found
1918  *
1919  * Checks whether @needle exists in @haystack, using the given @equal_func.
1920  * If the element is found, %TRUE is returned and the element&#39;s index is
1921  * returned in @index_ (if non-%NULL). Otherwise, %FALSE is returned and @index_
1922  * is undefined. If @needle exists multiple times in @haystack, the index of
1923  * the first instance is returned.
1924  *
1925  * @equal_func is called with the element from the array as its first parameter,
1926  * and @needle as its second parameter. If @equal_func is %NULL, pointer
1927  * equality is used.
1928  *
1929  * Returns: %TRUE if @needle is one of the elements of @haystack
1930  * Since: 2.54
1931  */
1932 gboolean
1933 g_ptr_array_find_with_equal_func (GPtrArray     *haystack,
1934                                   gconstpointer  needle,
1935                                   GEqualFunc     equal_func,
1936                                   guint         *index_)
1937 {
1938   guint i;
1939 
1940   g_return_val_if_fail (haystack != NULL, FALSE);
1941 
1942   if (equal_func == NULL)
1943     equal_func = g_direct_equal;
1944 
1945   for (i = 0; i &lt; haystack-&gt;len; i++)
1946     {
1947       if (equal_func (g_ptr_array_index (haystack, i), needle))
1948         {
1949           if (index_ != NULL)
1950             *index_ = i;
1951           return TRUE;
1952         }
1953     }
1954 
1955   return FALSE;
1956 }
1957 
1958 /**
1959  * SECTION:arrays_byte
1960  * @title: Byte Arrays
1961  * @short_description: arrays of bytes
1962  *
1963  * #GByteArray is a mutable array of bytes based on #GArray, to provide arrays
1964  * of bytes which grow automatically as elements are added.
1965  *
1966  * To create a new #GByteArray use g_byte_array_new(). To add elements to a
1967  * #GByteArray, use g_byte_array_append(), and g_byte_array_prepend().
1968  *
1969  * To set the size of a #GByteArray, use g_byte_array_set_size().
1970  *
1971  * To free a #GByteArray, use g_byte_array_free().
1972  *
1973  * An example for using a #GByteArray:
1974  * |[&lt;!-- language=&quot;C&quot; --&gt;
1975  *   GByteArray *gbarray;
1976  *   gint i;
1977  *
1978  *   gbarray = g_byte_array_new ();
1979  *   for (i = 0; i &lt; 10000; i++)
1980  *     g_byte_array_append (gbarray, (guint8*) &quot;abcd&quot;, 4);
1981  *
1982  *   for (i = 0; i &lt; 10000; i++)
1983  *     {
1984  *       g_assert (gbarray-&gt;data[4*i] == &#39;a&#39;);
1985  *       g_assert (gbarray-&gt;data[4*i+1] == &#39;b&#39;);
1986  *       g_assert (gbarray-&gt;data[4*i+2] == &#39;c&#39;);
1987  *       g_assert (gbarray-&gt;data[4*i+3] == &#39;d&#39;);
1988  *     }
1989  *
1990  *   g_byte_array_free (gbarray, TRUE);
1991  * ]|
1992  *
1993  * See #GBytes if you are interested in an immutable object representing a
1994  * sequence of bytes.
1995  */
1996 
1997 /**
1998  * GByteArray:
1999  * @data: a pointer to the element data. The data may be moved as
2000  *     elements are added to the #GByteArray
2001  * @len: the number of elements in the #GByteArray
2002  *
2003  * Contains the public fields of a GByteArray.
2004  */
2005 
2006 /**
2007  * g_byte_array_new:
2008  *
2009  * Creates a new #GByteArray with a reference count of 1.
2010  *
2011  * Returns: (transfer full): the new #GByteArray
2012  */
2013 GByteArray*
2014 g_byte_array_new (void)
2015 {
2016   return (GByteArray *)g_array_sized_new (FALSE, FALSE, 1, 0);
2017 }
2018 
2019 /**
2020  * g_byte_array_new_take:
2021  * @data: (transfer full) (array length=len): byte data for the array
2022  * @len: length of @data
2023  *
2024  * Create byte array containing the data. The data will be owned by the array
2025  * and will be freed with g_free(), i.e. it could be allocated using g_strdup().
2026  *
2027  * Since: 2.32
2028  *
2029  * Returns: (transfer full): a new #GByteArray
2030  */
2031 GByteArray*
2032 g_byte_array_new_take (guint8 *data,
2033                        gsize   len)
2034 {
2035   GByteArray *array;
2036   GRealArray *real;
2037 
2038   array = g_byte_array_new ();
2039 #ifdef GSTREAMER_LITE
2040   if (array == NULL)
2041     return NULL;
2042 #endif // GSTREAMER_LITE
2043   real = (GRealArray *)array;
2044   g_assert (real-&gt;data == NULL);
2045   g_assert (real-&gt;len == 0);
2046 
2047   real-&gt;data = data;
2048   real-&gt;len = len;
2049   real-&gt;alloc = len;
2050 
2051   return array;
2052 }
2053 
2054 /**
2055  * g_byte_array_sized_new:
2056  * @reserved_size: number of bytes preallocated
2057  *
2058  * Creates a new #GByteArray with @reserved_size bytes preallocated.
2059  * This avoids frequent reallocation, if you are going to add many
2060  * bytes to the array. Note however that the size of the array is still
2061  * 0.
2062  *
2063  * Returns: the new #GByteArray
2064  */
2065 GByteArray*
2066 g_byte_array_sized_new (guint reserved_size)
2067 {
2068   return (GByteArray *)g_array_sized_new (FALSE, FALSE, 1, reserved_size);
2069 }
2070 
2071 /**
2072  * g_byte_array_free:
2073  * @array: a #GByteArray
2074  * @free_segment: if %TRUE the actual byte data is freed as well
2075  *
2076  * Frees the memory allocated by the #GByteArray. If @free_segment is
2077  * %TRUE it frees the actual byte data. If the reference count of
2078  * @array is greater than one, the #GByteArray wrapper is preserved but
2079  * the size of @array will be set to zero.
2080  *
2081  * Returns: the element data if @free_segment is %FALSE, otherwise
2082  *          %NULL.  The element data should be freed using g_free().
2083  */
2084 guint8*
2085 g_byte_array_free (GByteArray *array,
2086                    gboolean    free_segment)
2087 {
2088   return (guint8 *)g_array_free ((GArray *)array, free_segment);
2089 }
2090 
2091 /**
2092  * g_byte_array_free_to_bytes:
2093  * @array: (transfer full): a #GByteArray
2094  *
2095  * Transfers the data from the #GByteArray into a new immutable #GBytes.
2096  *
2097  * The #GByteArray is freed unless the reference count of @array is greater
2098  * than one, the #GByteArray wrapper is preserved but the size of @array
2099  * will be set to zero.
2100  *
2101  * This is identical to using g_bytes_new_take() and g_byte_array_free()
2102  * together.
2103  *
2104  * Since: 2.32
2105  *
2106  * Returns: (transfer full): a new immutable #GBytes representing same
2107  *     byte data that was in the array
2108  */
2109 GBytes*
2110 g_byte_array_free_to_bytes (GByteArray *array)
2111 {
2112   gsize length;
2113 
2114   g_return_val_if_fail (array != NULL, NULL);
2115 
2116   length = array-&gt;len;
2117   return g_bytes_new_take (g_byte_array_free (array, FALSE), length);
2118 }
2119 
2120 /**
2121  * g_byte_array_ref:
2122  * @array: A #GByteArray
2123  *
2124  * Atomically increments the reference count of @array by one.
2125  * This function is thread-safe and may be called from any thread.
2126  *
2127  * Returns: The passed in #GByteArray
2128  *
2129  * Since: 2.22
2130  */
2131 GByteArray*
2132 g_byte_array_ref (GByteArray *array)
2133 {
2134   return (GByteArray *)g_array_ref ((GArray *)array);
2135 }
2136 
2137 /**
2138  * g_byte_array_unref:
2139  * @array: A #GByteArray
2140  *
2141  * Atomically decrements the reference count of @array by one. If the
2142  * reference count drops to 0, all memory allocated by the array is
2143  * released. This function is thread-safe and may be called from any
2144  * thread.
2145  *
2146  * Since: 2.22
2147  */
2148 void
2149 g_byte_array_unref (GByteArray *array)
2150 {
2151   g_array_unref ((GArray *)array);
2152 }
2153 
2154 /**
2155  * g_byte_array_append:
2156  * @array: a #GByteArray
2157  * @data: the byte data to be added
2158  * @len: the number of bytes to add
2159  *
2160  * Adds the given bytes to the end of the #GByteArray.
2161  * The array will grow in size automatically if necessary.
2162  *
2163  * Returns: the #GByteArray
2164  */
2165 GByteArray*
2166 g_byte_array_append (GByteArray   *array,
2167                      const guint8 *data,
2168                      guint         len)
2169 {
2170   g_array_append_vals ((GArray *)array, (guint8 *)data, len);
2171 
2172   return array;
2173 }
2174 
2175 /**
2176  * g_byte_array_prepend:
2177  * @array: a #GByteArray
2178  * @data: the byte data to be added
2179  * @len: the number of bytes to add
2180  *
2181  * Adds the given data to the start of the #GByteArray.
2182  * The array will grow in size automatically if necessary.
2183  *
2184  * Returns: the #GByteArray
2185  */
2186 GByteArray*
2187 g_byte_array_prepend (GByteArray   *array,
2188                       const guint8 *data,
2189                       guint         len)
2190 {
2191   g_array_prepend_vals ((GArray *)array, (guint8 *)data, len);
2192 
2193   return array;
2194 }
2195 
2196 /**
2197  * g_byte_array_set_size:
2198  * @array: a #GByteArray
2199  * @length: the new size of the #GByteArray
2200  *
2201  * Sets the size of the #GByteArray, expanding it if necessary.
2202  *
2203  * Returns: the #GByteArray
2204  */
2205 GByteArray*
2206 g_byte_array_set_size (GByteArray *array,
2207                        guint       length)
2208 {
2209   g_array_set_size ((GArray *)array, length);
2210 
2211   return array;
2212 }
2213 
2214 /**
2215  * g_byte_array_remove_index:
2216  * @array: a #GByteArray
2217  * @index_: the index of the byte to remove
2218  *
2219  * Removes the byte at the given index from a #GByteArray.
2220  * The following bytes are moved down one place.
2221  *
2222  * Returns: the #GByteArray
2223  **/
2224 GByteArray*
2225 g_byte_array_remove_index (GByteArray *array,
2226                            guint       index_)
2227 {
2228   g_array_remove_index ((GArray *)array, index_);
2229 
2230   return array;
2231 }
2232 
2233 /**
2234  * g_byte_array_remove_index_fast:
2235  * @array: a #GByteArray
2236  * @index_: the index of the byte to remove
2237  *
2238  * Removes the byte at the given index from a #GByteArray. The last
2239  * element in the array is used to fill in the space, so this function
2240  * does not preserve the order of the #GByteArray. But it is faster
2241  * than g_byte_array_remove_index().
2242  *
2243  * Returns: the #GByteArray
2244  */
2245 GByteArray*
2246 g_byte_array_remove_index_fast (GByteArray *array,
2247                                 guint       index_)
2248 {
2249   g_array_remove_index_fast ((GArray *)array, index_);
2250 
2251   return array;
2252 }
2253 
2254 /**
2255  * g_byte_array_remove_range:
2256  * @array: a @GByteArray
2257  * @index_: the index of the first byte to remove
2258  * @length: the number of bytes to remove
2259  *
2260  * Removes the given number of bytes starting at the given index from a
2261  * #GByteArray.  The following elements are moved to close the gap.
2262  *
2263  * Returns: the #GByteArray
2264  *
2265  * Since: 2.4
2266  */
2267 GByteArray*
2268 g_byte_array_remove_range (GByteArray *array,
2269                            guint       index_,
2270                            guint       length)
2271 {
2272   g_return_val_if_fail (array, NULL);
2273   g_return_val_if_fail (index_ &lt;= array-&gt;len, NULL);
2274   g_return_val_if_fail (index_ + length &lt;= array-&gt;len, NULL);
2275 
2276   return (GByteArray *)g_array_remove_range ((GArray *)array, index_, length);
2277 }
2278 
2279 /**
2280  * g_byte_array_sort:
2281  * @array: a #GByteArray
2282  * @compare_func: comparison function
2283  *
2284  * Sorts a byte array, using @compare_func which should be a
2285  * qsort()-style comparison function (returns less than zero for first
2286  * arg is less than second arg, zero for equal, greater than zero if
2287  * first arg is greater than second arg).
2288  *
2289  * If two array elements compare equal, their order in the sorted array
2290  * is undefined. If you want equal elements to keep their order (i.e.
2291  * you want a stable sort) you can write a comparison function that,
2292  * if two elements would otherwise compare equal, compares them by
2293  * their addresses.
2294  */
2295 void
2296 g_byte_array_sort (GByteArray   *array,
2297                    GCompareFunc  compare_func)
2298 {
2299   g_array_sort ((GArray *)array, compare_func);
2300 }
2301 
2302 /**
2303  * g_byte_array_sort_with_data:
2304  * @array: a #GByteArray
2305  * @compare_func: comparison function
2306  * @user_data: data to pass to @compare_func
2307  *
2308  * Like g_byte_array_sort(), but the comparison function takes an extra
2309  * user data argument.
2310  */
2311 void
2312 g_byte_array_sort_with_data (GByteArray       *array,
2313                              GCompareDataFunc  compare_func,
2314                              gpointer          user_data)
2315 {
2316   g_array_sort_with_data ((GArray *)array, compare_func, user_data);
2317 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>