<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmem.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gmarkup.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmem.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmem.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 82 /* --- functions --- */
 83 /**
 84  * g_malloc:
 85  * @n_bytes: the number of bytes to allocate
 86  *
 87  * Allocates @n_bytes bytes of memory.
 88  * If @n_bytes is 0 it returns %NULL.
 89  *
 90  * Returns: a pointer to the allocated memory
 91  */
 92 gpointer
 93 g_malloc (gsize n_bytes)
 94 {
 95   if (G_LIKELY (n_bytes))
 96     {
 97       gpointer mem;
 98 
 99       mem = malloc (n_bytes);
100       TRACE (GLIB_MEM_ALLOC((void*) mem, (unsigned int) n_bytes, 0, 0));
101       if (mem)
<span class="line-modified">102     return mem;</span>
103 
104       g_error (&quot;%s: failed to allocate %&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
105                G_STRLOC, n_bytes);
106     }
107 
108   TRACE(GLIB_MEM_ALLOC((void*) NULL, (int) n_bytes, 0, 0));
109 
110   return NULL;
111 }
112 
113 /**
114  * g_malloc0:
115  * @n_bytes: the number of bytes to allocate
116  *
117  * Allocates @n_bytes bytes of memory, initialized to 0&#39;s.
118  * If @n_bytes is 0 it returns %NULL.
119  *
120  * Returns: a pointer to the allocated memory
121  */
122 gpointer
123 g_malloc0 (gsize n_bytes)
124 {
125   if (G_LIKELY (n_bytes))
126     {
127       gpointer mem;
128 
129       mem = calloc (1, n_bytes);
130       TRACE (GLIB_MEM_ALLOC((void*) mem, (unsigned int) n_bytes, 1, 0));
131       if (mem)
<span class="line-modified">132     return mem;</span>
133 
134       g_error (&quot;%s: failed to allocate %&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
135                G_STRLOC, n_bytes);
136     }
137 
138   TRACE(GLIB_MEM_ALLOC((void*) NULL, (int) n_bytes, 1, 0));
139 
140   return NULL;
141 }
142 
143 /**
144  * g_realloc:
145  * @mem: (nullable): the memory to reallocate
146  * @n_bytes: new size of the memory in bytes
147  *
148  * Reallocates the memory pointed to by @mem, so that it now has space for
149  * @n_bytes bytes of memory. It returns the new address of the memory, which may
150  * have been moved. @mem may be %NULL, in which case it&#39;s considered to
151  * have zero-length. @n_bytes may be 0, in which case %NULL will be returned
152  * and @mem will be freed unless it is %NULL.
153  *
154  * Returns: the new address of the allocated memory
155  */
156 gpointer
157 g_realloc (gpointer mem,
<span class="line-modified">158        gsize    n_bytes)</span>
159 {
160   gpointer newmem;
161 
162   if (G_LIKELY (n_bytes))
163     {
164       newmem = realloc (mem, n_bytes);
165       TRACE (GLIB_MEM_REALLOC((void*) newmem, (void*)mem, (unsigned int) n_bytes, 0));
166       if (newmem)
<span class="line-modified">167     return newmem;</span>
168 
169       g_error (&quot;%s: failed to allocate %&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
170                G_STRLOC, n_bytes);
171     }
172 
<span class="line-modified">173   if (mem)</span>
<span class="line-removed">174     free (mem);</span>
175 
176   TRACE (GLIB_MEM_REALLOC((void*) NULL, (void*)mem, 0, 0));
177 
178   return NULL;
179 }
180 
181 /**
182  * g_free:
183  * @mem: (nullable): the memory to free
184  *
185  * Frees the memory pointed to by @mem.
186  *
187  * If @mem is %NULL it simply returns, so there is no need to check @mem
188  * against %NULL before calling this function.
189  */
190 void
191 g_free (gpointer mem)
192 {
<span class="line-modified">193   if (G_LIKELY (mem))</span>
<span class="line-removed">194     free (mem);</span>
195   TRACE(GLIB_MEM_FREE((void*) mem));
196 }
197 
198 /**
199  * g_clear_pointer: (skip)
200  * @pp: (not nullable): a pointer to a variable, struct member etc. holding a
201  *    pointer
202  * @destroy: a function to which a gpointer can be passed, to destroy *@pp
203  *
204  * Clears a reference to a variable.
205  *
206  * @pp must not be %NULL.
207  *
208  * If the reference is %NULL then this function does nothing.
209  * Otherwise, the variable is destroyed using @destroy and the
210  * pointer is set to %NULL.
211  *
212  * A macro is also included that allows this function to be used without
213  * pointer casts. This will mask any warnings about incompatible function types
214  * or calling conventions, so you must ensure that your @destroy function is
</pre>
<hr />
<pre>
278     mem = NULL;
279 
280   return mem;
281 }
282 
283 /**
284  * g_try_realloc:
285  * @mem: (nullable): previously-allocated memory, or %NULL.
286  * @n_bytes: number of bytes to allocate.
287  *
288  * Attempts to realloc @mem to a new size, @n_bytes, and returns %NULL
289  * on failure. Contrast with g_realloc(), which aborts the program
290  * on failure.
291  *
292  * If @mem is %NULL, behaves the same as g_try_malloc().
293  *
294  * Returns: the allocated memory, or %NULL.
295  */
296 gpointer
297 g_try_realloc (gpointer mem,
<span class="line-modified">298            gsize    n_bytes)</span>
299 {
300   gpointer newmem;
301 
302   if (G_LIKELY (n_bytes))
303     newmem = realloc (mem, n_bytes);
304   else
305     {
306       newmem = NULL;
<span class="line-modified">307       if (mem)</span>
<span class="line-removed">308     free (mem);</span>
309     }
310 
311   TRACE (GLIB_MEM_REALLOC((void*) newmem, (void*)mem, (unsigned int) n_bytes, 1));
312 
313   return newmem;
314 }
315 
316 
317 #define SIZE_OVERFLOWS(a,b) (G_UNLIKELY ((b) &gt; 0 &amp;&amp; (a) &gt; G_MAXSIZE / (b)))
318 
319 /**
320  * g_malloc_n:
321  * @n_blocks: the number of blocks to allocate
322  * @n_block_bytes: the size of each block in bytes
323  *
324  * This function is similar to g_malloc(), allocating (@n_blocks * @n_block_bytes) bytes,
325  * but care is taken to detect possible overflow during multiplication.
326  *
327  * Since: 2.24
328  * Returns: a pointer to the allocated memory
329  */
330 gpointer
331 g_malloc_n (gsize n_blocks,
<span class="line-modified">332         gsize n_block_bytes)</span>
333 {
334   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
335     {
336       g_error (&quot;%s: overflow allocating %&quot;G_GSIZE_FORMAT&quot;*%&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
337                G_STRLOC, n_blocks, n_block_bytes);
338     }
339 
340   return g_malloc (n_blocks * n_block_bytes);
341 }
342 
343 /**
344  * g_malloc0_n:
345  * @n_blocks: the number of blocks to allocate
346  * @n_block_bytes: the size of each block in bytes
347  *
348  * This function is similar to g_malloc0(), allocating (@n_blocks * @n_block_bytes) bytes,
349  * but care is taken to detect possible overflow during multiplication.
350  *
351  * Since: 2.24
352  * Returns: a pointer to the allocated memory
353  */
354 gpointer
355 g_malloc0_n (gsize n_blocks,
<span class="line-modified">356          gsize n_block_bytes)</span>
357 {
358   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
359     {
360       g_error (&quot;%s: overflow allocating %&quot;G_GSIZE_FORMAT&quot;*%&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
361                G_STRLOC, n_blocks, n_block_bytes);
362     }
363 
364   return g_malloc0 (n_blocks * n_block_bytes);
365 }
366 
367 /**
368  * g_realloc_n:
369  * @mem: (nullable): the memory to reallocate
370  * @n_blocks: the number of blocks to allocate
371  * @n_block_bytes: the size of each block in bytes
372  *
373  * This function is similar to g_realloc(), allocating (@n_blocks * @n_block_bytes) bytes,
374  * but care is taken to detect possible overflow during multiplication.
375  *
376  * Since: 2.24
377  * Returns: the new address of the allocated memory
378  */
379 gpointer
380 g_realloc_n (gpointer mem,
<span class="line-modified">381          gsize    n_blocks,</span>
<span class="line-modified">382          gsize    n_block_bytes)</span>
383 {
384   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
385     {
386       g_error (&quot;%s: overflow allocating %&quot;G_GSIZE_FORMAT&quot;*%&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
387                G_STRLOC, n_blocks, n_block_bytes);
388     }
389 
390   return g_realloc (mem, n_blocks * n_block_bytes);
391 }
392 
393 /**
394  * g_try_malloc_n:
395  * @n_blocks: the number of blocks to allocate
396  * @n_block_bytes: the size of each block in bytes
397  *
398  * This function is similar to g_try_malloc(), allocating (@n_blocks * @n_block_bytes) bytes,
399  * but care is taken to detect possible overflow during multiplication.
400  *
401  * Since: 2.24
402  * Returns: the allocated memory, or %NULL.
403  */
404 gpointer
405 g_try_malloc_n (gsize n_blocks,
<span class="line-modified">406         gsize n_block_bytes)</span>
407 {
408   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
409     return NULL;
410 
411   return g_try_malloc (n_blocks * n_block_bytes);
412 }
413 
414 /**
415  * g_try_malloc0_n:
416  * @n_blocks: the number of blocks to allocate
417  * @n_block_bytes: the size of each block in bytes
418  *
419  * This function is similar to g_try_malloc0(), allocating (@n_blocks * @n_block_bytes) bytes,
420  * but care is taken to detect possible overflow during multiplication.
421  *
422  * Since: 2.24
423  * Returns: the allocated memory, or %NULL
424  */
425 gpointer
426 g_try_malloc0_n (gsize n_blocks,
<span class="line-modified">427          gsize n_block_bytes)</span>
428 {
429   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
430     return NULL;
431 
432   return g_try_malloc0 (n_blocks * n_block_bytes);
433 }
434 
435 /**
436  * g_try_realloc_n:
437  * @mem: (nullable): previously-allocated memory, or %NULL.
438  * @n_blocks: the number of blocks to allocate
439  * @n_block_bytes: the size of each block in bytes
440  *
441  * This function is similar to g_try_realloc(), allocating (@n_blocks * @n_block_bytes) bytes,
442  * but care is taken to detect possible overflow during multiplication.
443  *
444  * Since: 2.24
445  * Returns: the allocated memory, or %NULL.
446  */
447 gpointer
448 g_try_realloc_n (gpointer mem,
<span class="line-modified">449          gsize    n_blocks,</span>
<span class="line-modified">450          gsize    n_block_bytes)</span>
451 {
452   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
453     return NULL;
454 
455   return g_try_realloc (mem, n_blocks * n_block_bytes);
456 }
457 
458 /**
459  * g_mem_is_system_malloc:
460  *
461  * Checks whether the allocator used by g_malloc() is the system&#39;s
462  * malloc implementation. If it returns %TRUE memory allocated with
463  * malloc() can be used interchangeable with memory allocated using g_malloc().
464  * This function is useful for avoiding an extra copy of allocated memory returned
465  * by a non-GLib-based API.
466  *
467  * Returns: if %TRUE, malloc() and g_malloc() can be mixed.
468  *
469  * Deprecated: 2.46: GLib always uses the system malloc, so this function always
470  * returns %TRUE.
</pre>
<hr />
<pre>
474 {
475   return TRUE;
476 }
477 
478 /**
479  * g_mem_set_vtable:
480  * @vtable: table of memory allocation routines.
481  *
482  * This function used to let you override the memory allocation function.
483  * However, its use was incompatible with the use of global constructors
484  * in GLib and GIO, because those use the GLib allocators before main is
485  * reached. Therefore this function is now deprecated and is just a stub.
486  *
487  * Deprecated: 2.46: This function now does nothing. Use other memory
488  * profiling tools instead
489  */
490 void
491 g_mem_set_vtable (GMemVTable *vtable)
492 {
493   g_warning (G_STRLOC &quot;: custom memory allocation vtable not supported&quot;);
<span class="line-modified">494     }</span>
495 
496 
497 /**
498  * glib_mem_profiler_table:
499  *
500  * Used to be a #GMemVTable containing profiling variants of the memory
501  * allocation functions, but this variable shouldn&#39;t be modified anymore.
502  *
503  * Deprecated: 2.46: Use other memory profiling tools instead
504  */
505 GMemVTable *glib_mem_profiler_table = &amp;glib_mem_vtable;
506 
507 /**
508  * g_mem_profile:
509  *
510  * GLib used to support some tools for memory profiling, but this
511  * no longer works. There are many other useful tools for memory
512  * profiling these days which can be used instead.
513  *
514  * Deprecated: 2.46: Use other memory profiling tools instead
515  */
516 void
517 g_mem_profile (void)
518 {
519   g_warning (G_STRLOC &quot;: memory profiling not supported&quot;);
<span class="line-modified">520     }</span>
</pre>
</td>
<td>
<hr />
<pre>
 82 /* --- functions --- */
 83 /**
 84  * g_malloc:
 85  * @n_bytes: the number of bytes to allocate
 86  *
 87  * Allocates @n_bytes bytes of memory.
 88  * If @n_bytes is 0 it returns %NULL.
 89  *
 90  * Returns: a pointer to the allocated memory
 91  */
 92 gpointer
 93 g_malloc (gsize n_bytes)
 94 {
 95   if (G_LIKELY (n_bytes))
 96     {
 97       gpointer mem;
 98 
 99       mem = malloc (n_bytes);
100       TRACE (GLIB_MEM_ALLOC((void*) mem, (unsigned int) n_bytes, 0, 0));
101       if (mem)
<span class="line-modified">102   return mem;</span>
103 
104       g_error (&quot;%s: failed to allocate %&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
105                G_STRLOC, n_bytes);
106     }
107 
108   TRACE(GLIB_MEM_ALLOC((void*) NULL, (int) n_bytes, 0, 0));
109 
110   return NULL;
111 }
112 
113 /**
114  * g_malloc0:
115  * @n_bytes: the number of bytes to allocate
116  *
117  * Allocates @n_bytes bytes of memory, initialized to 0&#39;s.
118  * If @n_bytes is 0 it returns %NULL.
119  *
120  * Returns: a pointer to the allocated memory
121  */
122 gpointer
123 g_malloc0 (gsize n_bytes)
124 {
125   if (G_LIKELY (n_bytes))
126     {
127       gpointer mem;
128 
129       mem = calloc (1, n_bytes);
130       TRACE (GLIB_MEM_ALLOC((void*) mem, (unsigned int) n_bytes, 1, 0));
131       if (mem)
<span class="line-modified">132   return mem;</span>
133 
134       g_error (&quot;%s: failed to allocate %&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
135                G_STRLOC, n_bytes);
136     }
137 
138   TRACE(GLIB_MEM_ALLOC((void*) NULL, (int) n_bytes, 1, 0));
139 
140   return NULL;
141 }
142 
143 /**
144  * g_realloc:
145  * @mem: (nullable): the memory to reallocate
146  * @n_bytes: new size of the memory in bytes
147  *
148  * Reallocates the memory pointed to by @mem, so that it now has space for
149  * @n_bytes bytes of memory. It returns the new address of the memory, which may
150  * have been moved. @mem may be %NULL, in which case it&#39;s considered to
151  * have zero-length. @n_bytes may be 0, in which case %NULL will be returned
152  * and @mem will be freed unless it is %NULL.
153  *
154  * Returns: the new address of the allocated memory
155  */
156 gpointer
157 g_realloc (gpointer mem,
<span class="line-modified">158      gsize    n_bytes)</span>
159 {
160   gpointer newmem;
161 
162   if (G_LIKELY (n_bytes))
163     {
164       newmem = realloc (mem, n_bytes);
165       TRACE (GLIB_MEM_REALLOC((void*) newmem, (void*)mem, (unsigned int) n_bytes, 0));
166       if (newmem)
<span class="line-modified">167   return newmem;</span>
168 
169       g_error (&quot;%s: failed to allocate %&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
170                G_STRLOC, n_bytes);
171     }
172 
<span class="line-modified">173   free (mem);</span>

174 
175   TRACE (GLIB_MEM_REALLOC((void*) NULL, (void*)mem, 0, 0));
176 
177   return NULL;
178 }
179 
180 /**
181  * g_free:
182  * @mem: (nullable): the memory to free
183  *
184  * Frees the memory pointed to by @mem.
185  *
186  * If @mem is %NULL it simply returns, so there is no need to check @mem
187  * against %NULL before calling this function.
188  */
189 void
190 g_free (gpointer mem)
191 {
<span class="line-modified">192   free (mem);</span>

193   TRACE(GLIB_MEM_FREE((void*) mem));
194 }
195 
196 /**
197  * g_clear_pointer: (skip)
198  * @pp: (not nullable): a pointer to a variable, struct member etc. holding a
199  *    pointer
200  * @destroy: a function to which a gpointer can be passed, to destroy *@pp
201  *
202  * Clears a reference to a variable.
203  *
204  * @pp must not be %NULL.
205  *
206  * If the reference is %NULL then this function does nothing.
207  * Otherwise, the variable is destroyed using @destroy and the
208  * pointer is set to %NULL.
209  *
210  * A macro is also included that allows this function to be used without
211  * pointer casts. This will mask any warnings about incompatible function types
212  * or calling conventions, so you must ensure that your @destroy function is
</pre>
<hr />
<pre>
276     mem = NULL;
277 
278   return mem;
279 }
280 
281 /**
282  * g_try_realloc:
283  * @mem: (nullable): previously-allocated memory, or %NULL.
284  * @n_bytes: number of bytes to allocate.
285  *
286  * Attempts to realloc @mem to a new size, @n_bytes, and returns %NULL
287  * on failure. Contrast with g_realloc(), which aborts the program
288  * on failure.
289  *
290  * If @mem is %NULL, behaves the same as g_try_malloc().
291  *
292  * Returns: the allocated memory, or %NULL.
293  */
294 gpointer
295 g_try_realloc (gpointer mem,
<span class="line-modified">296          gsize    n_bytes)</span>
297 {
298   gpointer newmem;
299 
300   if (G_LIKELY (n_bytes))
301     newmem = realloc (mem, n_bytes);
302   else
303     {
304       newmem = NULL;
<span class="line-modified">305       free (mem);</span>

306     }
307 
308   TRACE (GLIB_MEM_REALLOC((void*) newmem, (void*)mem, (unsigned int) n_bytes, 1));
309 
310   return newmem;
311 }
312 
313 
314 #define SIZE_OVERFLOWS(a,b) (G_UNLIKELY ((b) &gt; 0 &amp;&amp; (a) &gt; G_MAXSIZE / (b)))
315 
316 /**
317  * g_malloc_n:
318  * @n_blocks: the number of blocks to allocate
319  * @n_block_bytes: the size of each block in bytes
320  *
321  * This function is similar to g_malloc(), allocating (@n_blocks * @n_block_bytes) bytes,
322  * but care is taken to detect possible overflow during multiplication.
323  *
324  * Since: 2.24
325  * Returns: a pointer to the allocated memory
326  */
327 gpointer
328 g_malloc_n (gsize n_blocks,
<span class="line-modified">329       gsize n_block_bytes)</span>
330 {
331   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
332     {
333       g_error (&quot;%s: overflow allocating %&quot;G_GSIZE_FORMAT&quot;*%&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
334                G_STRLOC, n_blocks, n_block_bytes);
335     }
336 
337   return g_malloc (n_blocks * n_block_bytes);
338 }
339 
340 /**
341  * g_malloc0_n:
342  * @n_blocks: the number of blocks to allocate
343  * @n_block_bytes: the size of each block in bytes
344  *
345  * This function is similar to g_malloc0(), allocating (@n_blocks * @n_block_bytes) bytes,
346  * but care is taken to detect possible overflow during multiplication.
347  *
348  * Since: 2.24
349  * Returns: a pointer to the allocated memory
350  */
351 gpointer
352 g_malloc0_n (gsize n_blocks,
<span class="line-modified">353        gsize n_block_bytes)</span>
354 {
355   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
356     {
357       g_error (&quot;%s: overflow allocating %&quot;G_GSIZE_FORMAT&quot;*%&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
358                G_STRLOC, n_blocks, n_block_bytes);
359     }
360 
361   return g_malloc0 (n_blocks * n_block_bytes);
362 }
363 
364 /**
365  * g_realloc_n:
366  * @mem: (nullable): the memory to reallocate
367  * @n_blocks: the number of blocks to allocate
368  * @n_block_bytes: the size of each block in bytes
369  *
370  * This function is similar to g_realloc(), allocating (@n_blocks * @n_block_bytes) bytes,
371  * but care is taken to detect possible overflow during multiplication.
372  *
373  * Since: 2.24
374  * Returns: the new address of the allocated memory
375  */
376 gpointer
377 g_realloc_n (gpointer mem,
<span class="line-modified">378        gsize    n_blocks,</span>
<span class="line-modified">379        gsize    n_block_bytes)</span>
380 {
381   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
382     {
383       g_error (&quot;%s: overflow allocating %&quot;G_GSIZE_FORMAT&quot;*%&quot;G_GSIZE_FORMAT&quot; bytes&quot;,
384                G_STRLOC, n_blocks, n_block_bytes);
385     }
386 
387   return g_realloc (mem, n_blocks * n_block_bytes);
388 }
389 
390 /**
391  * g_try_malloc_n:
392  * @n_blocks: the number of blocks to allocate
393  * @n_block_bytes: the size of each block in bytes
394  *
395  * This function is similar to g_try_malloc(), allocating (@n_blocks * @n_block_bytes) bytes,
396  * but care is taken to detect possible overflow during multiplication.
397  *
398  * Since: 2.24
399  * Returns: the allocated memory, or %NULL.
400  */
401 gpointer
402 g_try_malloc_n (gsize n_blocks,
<span class="line-modified">403     gsize n_block_bytes)</span>
404 {
405   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
406     return NULL;
407 
408   return g_try_malloc (n_blocks * n_block_bytes);
409 }
410 
411 /**
412  * g_try_malloc0_n:
413  * @n_blocks: the number of blocks to allocate
414  * @n_block_bytes: the size of each block in bytes
415  *
416  * This function is similar to g_try_malloc0(), allocating (@n_blocks * @n_block_bytes) bytes,
417  * but care is taken to detect possible overflow during multiplication.
418  *
419  * Since: 2.24
420  * Returns: the allocated memory, or %NULL
421  */
422 gpointer
423 g_try_malloc0_n (gsize n_blocks,
<span class="line-modified">424      gsize n_block_bytes)</span>
425 {
426   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
427     return NULL;
428 
429   return g_try_malloc0 (n_blocks * n_block_bytes);
430 }
431 
432 /**
433  * g_try_realloc_n:
434  * @mem: (nullable): previously-allocated memory, or %NULL.
435  * @n_blocks: the number of blocks to allocate
436  * @n_block_bytes: the size of each block in bytes
437  *
438  * This function is similar to g_try_realloc(), allocating (@n_blocks * @n_block_bytes) bytes,
439  * but care is taken to detect possible overflow during multiplication.
440  *
441  * Since: 2.24
442  * Returns: the allocated memory, or %NULL.
443  */
444 gpointer
445 g_try_realloc_n (gpointer mem,
<span class="line-modified">446      gsize    n_blocks,</span>
<span class="line-modified">447      gsize    n_block_bytes)</span>
448 {
449   if (SIZE_OVERFLOWS (n_blocks, n_block_bytes))
450     return NULL;
451 
452   return g_try_realloc (mem, n_blocks * n_block_bytes);
453 }
454 
455 /**
456  * g_mem_is_system_malloc:
457  *
458  * Checks whether the allocator used by g_malloc() is the system&#39;s
459  * malloc implementation. If it returns %TRUE memory allocated with
460  * malloc() can be used interchangeable with memory allocated using g_malloc().
461  * This function is useful for avoiding an extra copy of allocated memory returned
462  * by a non-GLib-based API.
463  *
464  * Returns: if %TRUE, malloc() and g_malloc() can be mixed.
465  *
466  * Deprecated: 2.46: GLib always uses the system malloc, so this function always
467  * returns %TRUE.
</pre>
<hr />
<pre>
471 {
472   return TRUE;
473 }
474 
475 /**
476  * g_mem_set_vtable:
477  * @vtable: table of memory allocation routines.
478  *
479  * This function used to let you override the memory allocation function.
480  * However, its use was incompatible with the use of global constructors
481  * in GLib and GIO, because those use the GLib allocators before main is
482  * reached. Therefore this function is now deprecated and is just a stub.
483  *
484  * Deprecated: 2.46: This function now does nothing. Use other memory
485  * profiling tools instead
486  */
487 void
488 g_mem_set_vtable (GMemVTable *vtable)
489 {
490   g_warning (G_STRLOC &quot;: custom memory allocation vtable not supported&quot;);
<span class="line-modified">491 }</span>
492 
493 
494 /**
495  * glib_mem_profiler_table:
496  *
497  * Used to be a #GMemVTable containing profiling variants of the memory
498  * allocation functions, but this variable shouldn&#39;t be modified anymore.
499  *
500  * Deprecated: 2.46: Use other memory profiling tools instead
501  */
502 GMemVTable *glib_mem_profiler_table = &amp;glib_mem_vtable;
503 
504 /**
505  * g_mem_profile:
506  *
507  * GLib used to support some tools for memory profiling, but this
508  * no longer works. There are many other useful tools for memory
509  * profiling these days which can be used instead.
510  *
511  * Deprecated: 2.46: Use other memory profiling tools instead
512  */
513 void
514 g_mem_profile (void)
515 {
516   g_warning (G_STRLOC &quot;: memory profiling not supported&quot;);
<span class="line-modified">517 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="gmarkup.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmem.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>