<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gmarshal.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 
   2 #include &quot;config.h&quot;
   3 
   4 #include &quot;gobject.h&quot;
   5 #include &quot;genums.h&quot;
   6 #include &quot;gboxed.h&quot;
   7 #include &quot;gvaluetypes.h&quot;
   8 
   9 /**
  10  * g_cclosure_marshal_VOID__VOID:
  11  * @closure: A #GClosure.
  12  * @return_value: A #GValue to store the return value. May be %NULL
  13  *   if the callback of closure doesn&#39;t return a value.
  14  * @n_param_values: The length of the @param_values array.
  15  * @param_values: An array of #GValues holding the arguments
  16  *   on which to invoke the callback of closure.
  17  * @invocation_hint: The invocation hint given as the last argument to
  18  *   g_closure_invoke().
  19  * @marshal_data: Additional data specified when registering the
  20  *   marshaller, see g_closure_set_marshal() and
  21  *   g_closure_set_meta_marshal()
  22  *
  23  * A #GClosureMarshal function for use with signals with no arguments.
  24  */
  25 /**
  26  * g_cclosure_marshal_VOID__BOOLEAN:
  27  * @closure: A #GClosure.
  28  * @return_value: A #GValue to store the return value. May be %NULL
  29  *   if the callback of closure doesn&#39;t return a value.
  30  * @n_param_values: The length of the @param_values array.
  31  * @param_values: An array of #GValues holding the arguments
  32  *   on which to invoke the callback of closure.
  33  * @invocation_hint: The invocation hint given as the last argument to
  34  *   g_closure_invoke().
  35  * @marshal_data: Additional data specified when registering the
  36  *   marshaller, see g_closure_set_marshal() and
  37  *   g_closure_set_meta_marshal()
  38  *
  39  * A #GClosureMarshal function for use with signals with a single
  40  * boolean argument.
  41  */
  42 /**
  43  * g_cclosure_marshal_VOID__CHAR:
  44  * @closure: A #GClosure.
  45  * @return_value: A #GValue to store the return value. May be %NULL
  46  *   if the callback of closure doesn&#39;t return a value.
  47  * @n_param_values: The length of the @param_values array.
  48  * @param_values: An array of #GValues holding the arguments
  49  *   on which to invoke the callback of closure.
  50  * @invocation_hint: The invocation hint given as the last argument to
  51  *   g_closure_invoke().
  52  * @marshal_data: Additional data specified when registering the
  53  *   marshaller, see g_closure_set_marshal() and
  54  *   g_closure_set_meta_marshal()
  55  *
  56  * A #GClosureMarshal function for use with signals with a single
  57  * character argument.
  58  */
  59 /**
  60  * g_cclosure_marshal_VOID__UCHAR:
  61  * @closure: A #GClosure.
  62  * @return_value: A #GValue to store the return value. May be %NULL
  63  *   if the callback of closure doesn&#39;t return a value.
  64  * @n_param_values: The length of the @param_values array.
  65  * @param_values: An array of #GValues holding the arguments
  66  *   on which to invoke the callback of closure.
  67  * @invocation_hint: The invocation hint given as the last argument to
  68  *   g_closure_invoke().
  69  * @marshal_data: Additional data specified when registering the
  70  *   marshaller, see g_closure_set_marshal() and
  71  *   g_closure_set_meta_marshal()
  72  *
  73  * A #GClosureMarshal function for use with signals with a single
  74  * unsigned character argument.
  75  */
  76 /**
  77  * g_cclosure_marshal_VOID__INT:
  78  * @closure: A #GClosure.
  79  * @return_value: A #GValue to store the return value. May be %NULL
  80  *   if the callback of closure doesn&#39;t return a value.
  81  * @n_param_values: The length of the @param_values array.
  82  * @param_values: An array of #GValues holding the arguments
  83  *   on which to invoke the callback of closure.
  84  * @invocation_hint: The invocation hint given as the last argument to
  85  *   g_closure_invoke().
  86  * @marshal_data: Additional data specified when registering the
  87  *   marshaller, see g_closure_set_marshal() and
  88  *   g_closure_set_meta_marshal()
  89  *
  90  * A #GClosureMarshal function for use with signals with a single
  91  * integer argument.
  92  */
  93 /**
  94  * g_cclosure_marshal_VOID__UINT:
  95  * @closure: A #GClosure.
  96  * @return_value: A #GValue to store the return value. May be %NULL
  97  *   if the callback of closure doesn&#39;t return a value.
  98  * @n_param_values: The length of the @param_values array.
  99  * @param_values: An array of #GValues holding the arguments
 100  *   on which to invoke the callback of closure.
 101  * @invocation_hint: The invocation hint given as the last argument to
 102  *   g_closure_invoke().
 103  * @marshal_data: Additional data specified when registering the
 104  *   marshaller, see g_closure_set_marshal() and
 105  *   g_closure_set_meta_marshal()
 106  *
 107  * A #GClosureMarshal function for use with signals with with a single
 108  * unsigned integer argument.
 109  */
 110 /**
 111  * g_cclosure_marshal_VOID__LONG:
 112  * @closure: A #GClosure.
 113  * @return_value: A #GValue to store the return value. May be %NULL
 114  *   if the callback of closure doesn&#39;t return a value.
 115  * @n_param_values: The length of the @param_values array.
 116  * @param_values: An array of #GValues holding the arguments
 117  *   on which to invoke the callback of closure.
 118  * @invocation_hint: The invocation hint given as the last argument to
 119  *   g_closure_invoke().
 120  * @marshal_data: Additional data specified when registering the
 121  *   marshaller, see g_closure_set_marshal() and
 122  *   g_closure_set_meta_marshal()
 123  *
 124  * A #GClosureMarshal function for use with signals with with a single
 125  * long integer argument.
 126  */
 127 /**
 128  * g_cclosure_marshal_VOID__ULONG:
 129  * @closure: A #GClosure.
 130  * @return_value: A #GValue to store the return value. May be %NULL
 131  *   if the callback of closure doesn&#39;t return a value.
 132  * @n_param_values: The length of the @param_values array.
 133  * @param_values: An array of #GValues holding the arguments
 134  *   on which to invoke the callback of closure.
 135  * @invocation_hint: The invocation hint given as the last argument to
 136  *   g_closure_invoke().
 137  * @marshal_data: Additional data specified when registering the
 138  *   marshaller, see g_closure_set_marshal() and
 139  *   g_closure_set_meta_marshal()
 140  *
 141  * A #GClosureMarshal function for use with signals with a single
 142  * unsigned long integer argument.
 143  */
 144 /**
 145  * g_cclosure_marshal_VOID__ENUM:
 146  * @closure: A #GClosure.
 147  * @return_value: A #GValue to store the return value. May be %NULL
 148  *   if the callback of closure doesn&#39;t return a value.
 149  * @n_param_values: The length of the @param_values array.
 150  * @param_values: An array of #GValues holding the arguments
 151  *   on which to invoke the callback of closure.
 152  * @invocation_hint: The invocation hint given as the last argument to
 153  *   g_closure_invoke().
 154  * @marshal_data: Additional data specified when registering the
 155  *   marshaller, see g_closure_set_marshal() and
 156  *   g_closure_set_meta_marshal()
 157  *
 158  * A #GClosureMarshal function for use with signals with a single
 159  * argument with an enumerated type.
 160  */
 161 /**
 162  * g_cclosure_marshal_VOID__FLAGS:
 163  * @closure: A #GClosure.
 164  * @return_value: A #GValue to store the return value. May be %NULL
 165  *   if the callback of closure doesn&#39;t return a value.
 166  * @n_param_values: The length of the @param_values array.
 167  * @param_values: An array of #GValues holding the arguments
 168  *   on which to invoke the callback of closure.
 169  * @invocation_hint: The invocation hint given as the last argument to
 170  *   g_closure_invoke().
 171  * @marshal_data: Additional data specified when registering the
 172  *   marshaller, see g_closure_set_marshal() and
 173  *   g_closure_set_meta_marshal()
 174  *
 175  * A #GClosureMarshal function for use with signals with a single
 176  * argument with a flags types.
 177  */
 178 /**
 179  * g_cclosure_marshal_VOID__FLOAT:
 180  * @closure: A #GClosure.
 181  * @return_value: A #GValue to store the return value. May be %NULL
 182  *   if the callback of closure doesn&#39;t return a value.
 183  * @n_param_values: The length of the @param_values array.
 184  * @param_values: An array of #GValues holding the arguments
 185  *   on which to invoke the callback of closure.
 186  * @invocation_hint: The invocation hint given as the last argument to
 187  *   g_closure_invoke().
 188  * @marshal_data: Additional data specified when registering the
 189  *   marshaller, see g_closure_set_marshal() and
 190  *   g_closure_set_meta_marshal()
 191  *
 192  * A #GClosureMarshal function for use with signals with one
 193  * single-precision floating point argument.
 194  */
 195 /**
 196  * g_cclosure_marshal_VOID__DOUBLE:
 197  * @closure: A #GClosure.
 198  * @return_value: A #GValue to store the return value. May be %NULL
 199  *   if the callback of closure doesn&#39;t return a value.
 200  * @n_param_values: The length of the @param_values array.
 201  * @param_values: An array of #GValues holding the arguments
 202  *   on which to invoke the callback of closure.
 203  * @invocation_hint: The invocation hint given as the last argument to
 204  *   g_closure_invoke().
 205  * @marshal_data: Additional data specified when registering the
 206  *   marshaller, see g_closure_set_marshal() and
 207  *   g_closure_set_meta_marshal()
 208  *
 209  * A #GClosureMarshal function for use with signals with one
 210  * double-precision floating point argument.
 211  */
 212 /**
 213  * g_cclosure_marshal_VOID__STRING:
 214  * @closure: A #GClosure.
 215  * @return_value: A #GValue to store the return value. May be %NULL
 216  *   if the callback of closure doesn&#39;t return a value.
 217  * @n_param_values: The length of the @param_values array.
 218  * @param_values: An array of #GValues holding the arguments
 219  *   on which to invoke the callback of closure.
 220  * @invocation_hint: The invocation hint given as the last argument to
 221  *   g_closure_invoke().
 222  * @marshal_data: Additional data specified when registering the
 223  *   marshaller, see g_closure_set_marshal() and
 224  *   g_closure_set_meta_marshal()
 225  *
 226  * A #GClosureMarshal function for use with signals with a single string
 227  * argument.
 228  */
 229 /**
 230  * g_cclosure_marshal_VOID__PARAM:
 231  * @closure: A #GClosure.
 232  * @return_value: A #GValue to store the return value. May be %NULL
 233  *   if the callback of closure doesn&#39;t return a value.
 234  * @n_param_values: The length of the @param_values array.
 235  * @param_values: An array of #GValues holding the arguments
 236  *   on which to invoke the callback of closure.
 237  * @invocation_hint: The invocation hint given as the last argument to
 238  *   g_closure_invoke().
 239  * @marshal_data: Additional data specified when registering the
 240  *   marshaller, see g_closure_set_marshal() and
 241  *   g_closure_set_meta_marshal()
 242  *
 243  * A #GClosureMarshal function for use with signals with a single
 244  * argument of type #GParamSpec.
 245  */
 246 /**
 247  * g_cclosure_marshal_VOID__BOXED:
 248  * @closure: A #GClosure.
 249  * @return_value: A #GValue to store the return value. May be %NULL
 250  *   if the callback of closure doesn&#39;t return a value.
 251  * @n_param_values: The length of the @param_values array.
 252  * @param_values: An array of #GValues holding the arguments
 253  *   on which to invoke the callback of closure.
 254  * @invocation_hint: The invocation hint given as the last argument to
 255  *   g_closure_invoke().
 256  * @marshal_data: Additional data specified when registering the
 257  *   marshaller, see g_closure_set_marshal() and
 258  *   g_closure_set_meta_marshal()
 259  *
 260  * A #GClosureMarshal function for use with signals with a single
 261  * argument which is any boxed pointer type.
 262  */
 263 /**
 264  * g_cclosure_marshal_VOID__POINTER:
 265  * @closure: A #GClosure.
 266  * @return_value: A #GValue to store the return value. May be %NULL
 267  *   if the callback of closure doesn&#39;t return a value.
 268  * @n_param_values: The length of the @param_values array.
 269  * @param_values: An array of #GValues holding the arguments
 270  *   on which to invoke the callback of closure.
 271  * @invocation_hint: The invocation hint given as the last argument to
 272  *   g_closure_invoke().
 273  * @marshal_data: Additional data specified when registering the
 274  *   marshaller, see g_closure_set_marshal() and
 275  *   g_closure_set_meta_marshal()
 276  *
 277  * A #GClosureMarshal function for use with signals with a single raw
 278  * pointer argument type.
 279  *
 280  * If it is possible, it is better to use one of the more specific
 281  * functions such as g_cclosure_marshal_VOID__OBJECT() or
 282  * g_cclosure_marshal_VOID__OBJECT().
 283  */
 284 /**
 285  * g_cclosure_marshal_VOID__OBJECT:
 286  * @closure: A #GClosure.
 287  * @return_value: A #GValue to store the return value. May be %NULL
 288  *   if the callback of closure doesn&#39;t return a value.
 289  * @n_param_values: The length of the @param_values array.
 290  * @param_values: An array of #GValues holding the arguments
 291  *   on which to invoke the callback of closure.
 292  * @invocation_hint: The invocation hint given as the last argument to
 293  *   g_closure_invoke().
 294  * @marshal_data: Additional data specified when registering the
 295  *   marshaller, see g_closure_set_marshal() and
 296  *   g_closure_set_meta_marshal()
 297  *
 298  * A #GClosureMarshal function for use with signals with a single
 299  * #GObject argument.
 300  */
 301 /**
 302  * g_cclosure_marshal_VOID__VARIANT:
 303  * @closure: A #GClosure.
 304  * @return_value: A #GValue to store the return value. May be %NULL
 305  *   if the callback of closure doesn&#39;t return a value.
 306  * @n_param_values: The length of the @param_values array.
 307  * @param_values: An array of #GValues holding the arguments
 308  *   on which to invoke the callback of closure.
 309  * @invocation_hint: The invocation hint given as the last argument to
 310  *   g_closure_invoke().
 311  * @marshal_data: Additional data specified when registering the
 312  *   marshaller, see g_closure_set_marshal() and
 313  *   g_closure_set_meta_marshal()
 314  *
 315  * A #GClosureMarshal function for use with signals with a single
 316  * #GVariant argument.
 317  */
 318 /**
 319  * g_cclosure_marshal_STRING__OBJECT_POINTER:
 320  * @closure: A #GClosure.
 321  * @return_value: A #GValue to store the return value. May be %NULL
 322  *   if the callback of closure doesn&#39;t return a value.
 323  * @n_param_values: The length of the @param_values array.
 324  * @param_values: An array of #GValues holding the arguments
 325  *   on which to invoke the callback of closure.
 326  * @invocation_hint: The invocation hint given as the last argument to
 327  *   g_closure_invoke().
 328  * @marshal_data: Additional data specified when registering the
 329  *   marshaller, see g_closure_set_marshal() and
 330  *   g_closure_set_meta_marshal()
 331  *
 332  * A #GClosureMarshal function for use with signals with handlers that
 333  * take a #GObject and a pointer and produce a string.  It is highly
 334  * unlikely that your signal handler fits this description.
 335  */
 336 /**
 337  * g_cclosure_marshal_VOID__UINT_POINTER:
 338  * @closure: A #GClosure.
 339  * @return_value: A #GValue to store the return value. May be %NULL
 340  *   if the callback of closure doesn&#39;t return a value.
 341  * @n_param_values: The length of the @param_values array.
 342  * @param_values: An array of #GValues holding the arguments
 343  *   on which to invoke the callback of closure.
 344  * @invocation_hint: The invocation hint given as the last argument to
 345  *   g_closure_invoke().
 346  * @marshal_data: Additional data specified when registering the
 347  *   marshaller, see g_closure_set_marshal() and
 348  *   g_closure_set_meta_marshal()
 349  *
 350  * A #GClosureMarshal function for use with signals with a unsigned int
 351  * and a pointer as arguments.
 352  */
 353 /**
 354  * g_cclosure_marshal_BOOLEAN__FLAGS:
 355  * @closure: A #GClosure.
 356  * @return_value: A #GValue to store the return value. May be %NULL
 357  *   if the callback of closure doesn&#39;t return a value.
 358  * @n_param_values: The length of the @param_values array.
 359  * @param_values: An array of #GValues holding the arguments
 360  *   on which to invoke the callback of closure.
 361  * @invocation_hint: The invocation hint given as the last argument to
 362  *   g_closure_invoke().
 363  * @marshal_data: Additional data specified when registering the
 364  *   marshaller, see g_closure_set_marshal() and
 365  *   g_closure_set_meta_marshal()
 366  *
 367  * A #GClosureMarshal function for use with signals with handlers that
 368  * take a flags type as an argument and return a boolean.  If you have
 369  * such a signal, you will probably also need to use an accumulator,
 370  * such as g_signal_accumulator_true_handled().
 371  */
 372 /**
 373  * g_cclosure_marshal_BOOL__FLAGS:
 374  * @closure: A #GClosure.
 375  * @return_value: A #GValue to store the return value. May be %NULL
 376  *   if the callback of closure doesn&#39;t return a value.
 377  * @n_param_values: The length of the @param_values array.
 378  * @param_values: An array of #GValues holding the arguments
 379  *   on which to invoke the callback of closure.
 380  * @invocation_hint: The invocation hint given as the last argument to
 381  *   g_closure_invoke().
 382  * @marshal_data: Additional data specified when registering the
 383  *   marshaller, see g_closure_set_marshal() and
 384  *   g_closure_set_meta_marshal()
 385  *
 386  * An old alias for g_cclosure_marshal_BOOLEAN__FLAGS().
 387  */
 388 /**
 389  * g_cclosure_marshal_BOOLEAN__BOXED_BOXED:
 390  * @closure: A #GClosure.
 391  * @return_value: A #GValue to store the return value. May be %NULL
 392  *   if the callback of closure doesn&#39;t return a value.
 393  * @n_param_values: The length of the @param_values array.
 394  * @param_values: An array of #GValues holding the arguments
 395  *   on which to invoke the callback of closure.
 396  * @invocation_hint: The invocation hint given as the last argument to
 397  *   g_closure_invoke().
 398  * @marshal_data: Additional data specified when registering the
 399  *   marshaller, see g_closure_set_marshal() and
 400  *   g_closure_set_meta_marshal()
 401  *
 402  * A #GClosureMarshal function for use with signals with handlers that
 403  * take two boxed pointers as arguments and return a boolean.  If you
 404  * have such a signal, you will probably also need to use an
 405  * accumulator, such as g_signal_accumulator_true_handled().
 406  */
 407 /**
 408  * g_cclosure_marshal_BOOL__BOXED_BOXED:
 409  * @closure: A #GClosure.
 410  * @return_value: A #GValue to store the return value. May be %NULL
 411  *   if the callback of closure doesn&#39;t return a value.
 412  * @n_param_values: The length of the @param_values array.
 413  * @param_values: An array of #GValues holding the arguments
 414  *   on which to invoke the callback of closure.
 415  * @invocation_hint: The invocation hint given as the last argument to
 416  *   g_closure_invoke().
 417  * @marshal_data: Additional data specified when registering the
 418  *   marshaller, see g_closure_set_marshal() and
 419  *   g_closure_set_meta_marshal()
 420  *
 421  * An old alias for g_cclosure_marshal_BOOLEAN__BOXED_BOXED().
 422  */
 423 /**
 424  * g_cclosure_marshal_VOID__VOIDv:
 425  * @closure: the #GClosure to which the marshaller belongs
 426  * @return_value: (nullable): a #GValue to store the return
 427  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 428  *  value.
 429  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 430  * @args: va_list of arguments to be passed to the closure.
 431  * @marshal_data: (nullable): additional data specified when
 432  *  registering the marshaller, see g_closure_set_marshal() and
 433  *  g_closure_set_meta_marshal()
 434  * @n_params: the length of the @param_types array
 435  * @param_types: (array length=n_params): the #GType of each argument from
 436  *  @args.
 437  *
 438  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__VOID().
 439  */
 440 
 441 /**
 442  * g_cclosure_marshal_VOID__BOOLEANv:
 443  * @closure: the #GClosure to which the marshaller belongs
 444  * @return_value: (nullable): a #GValue to store the return
 445  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 446  *  value.
 447  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 448  * @args: va_list of arguments to be passed to the closure.
 449  * @marshal_data: (nullable): additional data specified when
 450  *  registering the marshaller, see g_closure_set_marshal() and
 451  *  g_closure_set_meta_marshal()
 452  * @n_params: the length of the @param_types array
 453  * @param_types: (array length=n_params): the #GType of each argument from
 454  *  @args.
 455  *
 456  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__BOOLEAN().
 457  */
 458 /**
 459  * g_cclosure_marshal_VOID__CHARv:
 460  * @closure: the #GClosure to which the marshaller belongs
 461  * @return_value: (nullable): a #GValue to store the return
 462  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 463  *  value.
 464  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 465  * @args: va_list of arguments to be passed to the closure.
 466  * @marshal_data: (nullable): additional data specified when
 467  *  registering the marshaller, see g_closure_set_marshal() and
 468  *  g_closure_set_meta_marshal()
 469  * @n_params: the length of the @param_types array
 470  * @param_types: (array length=n_params): the #GType of each argument from
 471  *  @args.
 472  *
 473  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__CHAR().
 474  */
 475 /**
 476  * g_cclosure_marshal_VOID__UCHARv:
 477  * @closure: the #GClosure to which the marshaller belongs
 478  * @return_value: (nullable): a #GValue to store the return
 479  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 480  *  value.
 481  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 482  * @args: va_list of arguments to be passed to the closure.
 483  * @marshal_data: (nullable): additional data specified when
 484  *  registering the marshaller, see g_closure_set_marshal() and
 485  *  g_closure_set_meta_marshal()
 486  * @n_params: the length of the @param_types array
 487  * @param_types: (array length=n_params): the #GType of each argument from
 488  *  @args.
 489  *
 490  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UCHAR().
 491  */
 492 /**
 493  * g_cclosure_marshal_VOID__INTv:
 494  * @closure: the #GClosure to which the marshaller belongs
 495  * @return_value: (nullable): a #GValue to store the return
 496  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 497  *  value.
 498  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 499  * @args: va_list of arguments to be passed to the closure.
 500  * @marshal_data: (nullable): additional data specified when
 501  *  registering the marshaller, see g_closure_set_marshal() and
 502  *  g_closure_set_meta_marshal()
 503  * @n_params: the length of the @param_types array
 504  * @param_types: (array length=n_params): the #GType of each argument from
 505  *  @args.
 506  *
 507  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__INT().
 508  */
 509 /**
 510  * g_cclosure_marshal_VOID__UINTv:
 511  * @closure: the #GClosure to which the marshaller belongs
 512  * @return_value: (nullable): a #GValue to store the return
 513  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 514  *  value.
 515  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 516  * @args: va_list of arguments to be passed to the closure.
 517  * @marshal_data: (nullable): additional data specified when
 518  *  registering the marshaller, see g_closure_set_marshal() and
 519  *  g_closure_set_meta_marshal()
 520  * @n_params: the length of the @param_types array
 521  * @param_types: (array length=n_params): the #GType of each argument from
 522  *  @args.
 523  *
 524  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UINT().
 525  */
 526 /**
 527  * g_cclosure_marshal_VOID__LONGv:
 528  * @closure: the #GClosure to which the marshaller belongs
 529  * @return_value: (nullable): a #GValue to store the return
 530  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 531  *  value.
 532  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 533  * @args: va_list of arguments to be passed to the closure.
 534  * @marshal_data: (nullable): additional data specified when
 535  *  registering the marshaller, see g_closure_set_marshal() and
 536  *  g_closure_set_meta_marshal()
 537  * @n_params: the length of the @param_types array
 538  * @param_types: (array length=n_params): the #GType of each argument from
 539  *  @args.
 540  *
 541  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__LONG().
 542  */
 543 /**
 544  * g_cclosure_marshal_VOID__ULONGv:
 545  * @closure: the #GClosure to which the marshaller belongs
 546  * @return_value: (nullable): a #GValue to store the return
 547  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 548  *  value.
 549  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 550  * @args: va_list of arguments to be passed to the closure.
 551  * @marshal_data: (nullable): additional data specified when
 552  *  registering the marshaller, see g_closure_set_marshal() and
 553  *  g_closure_set_meta_marshal()
 554  * @n_params: the length of the @param_types array
 555  * @param_types: (array length=n_params): the #GType of each argument from
 556  *  @args.
 557  *
 558  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__ULONG().
 559  */
 560 /**
 561  * g_cclosure_marshal_VOID__ENUMv:
 562  * @closure: the #GClosure to which the marshaller belongs
 563  * @return_value: (nullable): a #GValue to store the return
 564  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 565  *  value.
 566  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 567  * @args: va_list of arguments to be passed to the closure.
 568  * @marshal_data: (nullable): additional data specified when
 569  *  registering the marshaller, see g_closure_set_marshal() and
 570  *  g_closure_set_meta_marshal()
 571  * @n_params: the length of the @param_types array
 572  * @param_types: (array length=n_params): the #GType of each argument from
 573  *  @args.
 574  *
 575  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__ENUM().
 576  */
 577 /**
 578  * g_cclosure_marshal_VOID__FLAGSv:
 579  * @closure: the #GClosure to which the marshaller belongs
 580  * @return_value: (nullable): a #GValue to store the return
 581  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 582  *  value.
 583  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 584  * @args: va_list of arguments to be passed to the closure.
 585  * @marshal_data: (nullable): additional data specified when
 586  *  registering the marshaller, see g_closure_set_marshal() and
 587  *  g_closure_set_meta_marshal()
 588  * @n_params: the length of the @param_types array
 589  * @param_types: (array length=n_params): the #GType of each argument from
 590  *  @args.
 591  *
 592  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__FLAGS().
 593  */
 594 /**
 595  * g_cclosure_marshal_VOID__FLOATv:
 596  * @closure: the #GClosure to which the marshaller belongs
 597  * @return_value: (nullable): a #GValue to store the return
 598  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 599  *  value.
 600  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 601  * @args: va_list of arguments to be passed to the closure.
 602  * @marshal_data: (nullable): additional data specified when
 603  *  registering the marshaller, see g_closure_set_marshal() and
 604  *  g_closure_set_meta_marshal()
 605  * @n_params: the length of the @param_types array
 606  * @param_types: (array length=n_params): the #GType of each argument from
 607  *  @args.
 608  *
 609  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__FLOAT().
 610  */
 611 /**
 612  * g_cclosure_marshal_VOID__DOUBLEv:
 613  * @closure: the #GClosure to which the marshaller belongs
 614  * @return_value: (nullable): a #GValue to store the return
 615  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 616  *  value.
 617  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 618  * @args: va_list of arguments to be passed to the closure.
 619  * @marshal_data: (nullable): additional data specified when
 620  *  registering the marshaller, see g_closure_set_marshal() and
 621  *  g_closure_set_meta_marshal()
 622  * @n_params: the length of the @param_types array
 623  * @param_types: (array length=n_params): the #GType of each argument from
 624  *  @args.
 625  *
 626  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__DOUBLE().
 627  */
 628 /**
 629  * g_cclosure_marshal_VOID__STRINGv:
 630  * @closure: the #GClosure to which the marshaller belongs
 631  * @return_value: (nullable): a #GValue to store the return
 632  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 633  *  value.
 634  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 635  * @args: va_list of arguments to be passed to the closure.
 636  * @marshal_data: (nullable): additional data specified when
 637  *  registering the marshaller, see g_closure_set_marshal() and
 638  *  g_closure_set_meta_marshal()
 639  * @n_params: the length of the @param_types array
 640  * @param_types: (array length=n_params): the #GType of each argument from
 641  *  @args.
 642  *
 643  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__STRING().
 644  */
 645 /**
 646  * g_cclosure_marshal_VOID__PARAMv:
 647  * @closure: the #GClosure to which the marshaller belongs
 648  * @return_value: (nullable): a #GValue to store the return
 649  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 650  *  value.
 651  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 652  * @args: va_list of arguments to be passed to the closure.
 653  * @marshal_data: (nullable): additional data specified when
 654  *  registering the marshaller, see g_closure_set_marshal() and
 655  *  g_closure_set_meta_marshal()
 656  * @n_params: the length of the @param_types array
 657  * @param_types: (array length=n_params): the #GType of each argument from
 658  *  @args.
 659  *
 660  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__PARAM().
 661  */
 662 /**
 663  * g_cclosure_marshal_VOID__BOXEDv:
 664  * @closure: the #GClosure to which the marshaller belongs
 665  * @return_value: (nullable): a #GValue to store the return
 666  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 667  *  value.
 668  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 669  * @args: va_list of arguments to be passed to the closure.
 670  * @marshal_data: (nullable): additional data specified when
 671  *  registering the marshaller, see g_closure_set_marshal() and
 672  *  g_closure_set_meta_marshal()
 673  * @n_params: the length of the @param_types array
 674  * @param_types: (array length=n_params): the #GType of each argument from
 675  *  @args.
 676  *
 677  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__BOXED().
 678  */
 679 /**
 680  * g_cclosure_marshal_VOID__POINTERv:
 681  * @closure: the #GClosure to which the marshaller belongs
 682  * @return_value: (nullable): a #GValue to store the return
 683  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 684  *  value.
 685  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 686  * @args: va_list of arguments to be passed to the closure.
 687  * @marshal_data: (nullable): additional data specified when
 688  *  registering the marshaller, see g_closure_set_marshal() and
 689  *  g_closure_set_meta_marshal()
 690  * @n_params: the length of the @param_types array
 691  * @param_types: (array length=n_params): the #GType of each argument from
 692  *  @args.
 693  *
 694  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__POINTER().
 695  */
 696 /**
 697  * g_cclosure_marshal_VOID__OBJECTv:
 698  * @closure: the #GClosure to which the marshaller belongs
 699  * @return_value: (nullable): a #GValue to store the return
 700  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 701  *  value.
 702  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 703  * @args: va_list of arguments to be passed to the closure.
 704  * @marshal_data: (nullable): additional data specified when
 705  *  registering the marshaller, see g_closure_set_marshal() and
 706  *  g_closure_set_meta_marshal()
 707  * @n_params: the length of the @param_types array
 708  * @param_types: (array length=n_params): the #GType of each argument from
 709  *  @args.
 710  *
 711  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__OBJECT().
 712  */
 713 /**
 714  * g_cclosure_marshal_VOID__VARIANTv:
 715  * @closure: the #GClosure to which the marshaller belongs
 716  * @return_value: (nullable): a #GValue to store the return
 717  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 718  *  value.
 719  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 720  * @args: va_list of arguments to be passed to the closure.
 721  * @marshal_data: (nullable): additional data specified when
 722  *  registering the marshaller, see g_closure_set_marshal() and
 723  *  g_closure_set_meta_marshal()
 724  * @n_params: the length of the @param_types array
 725  * @param_types: (array length=n_params): the #GType of each argument from
 726  *  @args.
 727  *
 728  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__VARIANT().
 729  */
 730 /**
 731  * g_cclosure_marshal_STRING__OBJECT_POINTERv:
 732  * @closure: the #GClosure to which the marshaller belongs
 733  * @return_value: (nullable): a #GValue to store the return
 734  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 735  *  value.
 736  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 737  * @args: va_list of arguments to be passed to the closure.
 738  * @marshal_data: (nullable): additional data specified when
 739  *  registering the marshaller, see g_closure_set_marshal() and
 740  *  g_closure_set_meta_marshal()
 741  * @n_params: the length of the @param_types array
 742  * @param_types: (array length=n_params): the #GType of each argument from
 743  *  @args.
 744  *
 745  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_STRING__OBJECT_POINTER().
 746  */
 747 /**
 748  * g_cclosure_marshal_VOID__UINT_POINTERv:
 749  * @closure: the #GClosure to which the marshaller belongs
 750  * @return_value: (nullable): a #GValue to store the return
 751  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 752  *  value.
 753  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 754  * @args: va_list of arguments to be passed to the closure.
 755  * @marshal_data: (nullable): additional data specified when
 756  *  registering the marshaller, see g_closure_set_marshal() and
 757  *  g_closure_set_meta_marshal()
 758  * @n_params: the length of the @param_types array
 759  * @param_types: (array length=n_params): the #GType of each argument from
 760  *  @args.
 761  *
 762  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_VOID__UINT_POINTER().
 763  */
 764 /**
 765  * g_cclosure_marshal_BOOLEAN__FLAGSv:
 766  * @closure: the #GClosure to which the marshaller belongs
 767  * @return_value: (nullable): a #GValue to store the return
 768  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 769  *  value.
 770  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 771  * @args: va_list of arguments to be passed to the closure.
 772  * @marshal_data: (nullable): additional data specified when
 773  *  registering the marshaller, see g_closure_set_marshal() and
 774  *  g_closure_set_meta_marshal()
 775  * @n_params: the length of the @param_types array
 776  * @param_types: (array length=n_params): the #GType of each argument from
 777  *  @args.
 778  *
 779  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_BOOLEAN__FLAGS().
 780  */
 781 /**
 782  * g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv:
 783  * @closure: the #GClosure to which the marshaller belongs
 784  * @return_value: (nullable): a #GValue to store the return
 785  *  value. May be %NULL if the callback of @closure doesn&#39;t return a
 786  *  value.
 787  * @instance: (type GObject.TypeInstance): the instance on which the closure is invoked.
 788  * @args: va_list of arguments to be passed to the closure.
 789  * @marshal_data: (nullable): additional data specified when
 790  *  registering the marshaller, see g_closure_set_marshal() and
 791  *  g_closure_set_meta_marshal()
 792  * @n_params: the length of the @param_types array
 793  * @param_types: (array length=n_params): the #GType of each argument from
 794  *  @args.
 795  *
 796  * The #GVaClosureMarshal equivalent to g_cclosure_marshal_BOOLEAN__BOXED_BOXED().
 797  */
 798 
 799 #ifdef G_ENABLE_DEBUG
 800 #define g_marshal_value_peek_boolean(v)  g_value_get_boolean (v)
 801 #define g_marshal_value_peek_char(v)     g_value_get_schar (v)
 802 #define g_marshal_value_peek_uchar(v)    g_value_get_uchar (v)
 803 #define g_marshal_value_peek_int(v)      g_value_get_int (v)
 804 #define g_marshal_value_peek_uint(v)     g_value_get_uint (v)
 805 #define g_marshal_value_peek_long(v)     g_value_get_long (v)
 806 #define g_marshal_value_peek_ulong(v)    g_value_get_ulong (v)
 807 #define g_marshal_value_peek_int64(v)    g_value_get_int64 (v)
 808 #define g_marshal_value_peek_uint64(v)   g_value_get_uint64 (v)
 809 #define g_marshal_value_peek_enum(v)     g_value_get_enum (v)
 810 #define g_marshal_value_peek_flags(v)    g_value_get_flags (v)
 811 #define g_marshal_value_peek_float(v)    g_value_get_float (v)
 812 #define g_marshal_value_peek_double(v)   g_value_get_double (v)
 813 #define g_marshal_value_peek_string(v)   (char*) g_value_get_string (v)
 814 #define g_marshal_value_peek_param(v)    g_value_get_param (v)
 815 #define g_marshal_value_peek_boxed(v)    g_value_get_boxed (v)
 816 #define g_marshal_value_peek_pointer(v)  g_value_get_pointer (v)
 817 #define g_marshal_value_peek_object(v)   g_value_get_object (v)
 818 #define g_marshal_value_peek_variant(v)  g_value_get_variant (v)
 819 #else /* !G_ENABLE_DEBUG */
 820 /* WARNING: This code accesses GValues directly, which is UNSUPPORTED API.
 821  *          Do not access GValues directly in your code. Instead, use the
 822  *          g_value_get_*() functions
 823  */
 824 #define g_marshal_value_peek_boolean(v)  (v)-&gt;data[0].v_int
 825 #define g_marshal_value_peek_char(v)     (v)-&gt;data[0].v_int
 826 #define g_marshal_value_peek_uchar(v)    (v)-&gt;data[0].v_uint
 827 #define g_marshal_value_peek_int(v)      (v)-&gt;data[0].v_int
 828 #define g_marshal_value_peek_uint(v)     (v)-&gt;data[0].v_uint
 829 #define g_marshal_value_peek_long(v)     (v)-&gt;data[0].v_long
 830 #define g_marshal_value_peek_ulong(v)    (v)-&gt;data[0].v_ulong
 831 #define g_marshal_value_peek_int64(v)    (v)-&gt;data[0].v_int64
 832 #define g_marshal_value_peek_uint64(v)   (v)-&gt;data[0].v_uint64
 833 #define g_marshal_value_peek_enum(v)     (v)-&gt;data[0].v_long
 834 #define g_marshal_value_peek_flags(v)    (v)-&gt;data[0].v_ulong
 835 #define g_marshal_value_peek_float(v)    (v)-&gt;data[0].v_float
 836 #define g_marshal_value_peek_double(v)   (v)-&gt;data[0].v_double
 837 #define g_marshal_value_peek_string(v)   (v)-&gt;data[0].v_pointer
 838 #define g_marshal_value_peek_param(v)    (v)-&gt;data[0].v_pointer
 839 #define g_marshal_value_peek_boxed(v)    (v)-&gt;data[0].v_pointer
 840 #define g_marshal_value_peek_pointer(v)  (v)-&gt;data[0].v_pointer
 841 #define g_marshal_value_peek_object(v)   (v)-&gt;data[0].v_pointer
 842 #define g_marshal_value_peek_variant(v)  (v)-&gt;data[0].v_pointer
 843 #endif /* !G_ENABLE_DEBUG */
 844 
 845 
 846 /* VOID:VOID (./gmarshal.list:6) */
 847 void
 848 g_cclosure_marshal_VOID__VOID (GClosure     *closure,
 849                                GValue       *return_value G_GNUC_UNUSED,
 850                                guint         n_param_values,
 851                                const GValue *param_values,
 852                                gpointer      invocation_hint G_GNUC_UNUSED,
 853                                gpointer      marshal_data)
 854 {
 855   typedef void (*GMarshalFunc_VOID__VOID) (gpointer     data1,
 856                                            gpointer     data2);
 857   GMarshalFunc_VOID__VOID callback;
 858   GCClosure *cc = (GCClosure*) closure;
 859   gpointer data1, data2;
 860 
 861   g_return_if_fail (n_param_values == 1);
 862 
 863   if (G_CCLOSURE_SWAP_DATA (closure))
 864     {
 865       data1 = closure-&gt;data;
 866       data2 = g_value_peek_pointer (param_values + 0);
 867     }
 868   else
 869     {
 870       data1 = g_value_peek_pointer (param_values + 0);
 871       data2 = closure-&gt;data;
 872     }
 873   callback = (GMarshalFunc_VOID__VOID) (marshal_data ? marshal_data : cc-&gt;callback);
 874 
 875   callback (data1,
 876             data2);
 877 }
 878 void
 879 g_cclosure_marshal_VOID__VOIDv (GClosure     *closure,
 880                                 GValue       *return_value,
 881                                 gpointer      instance,
 882                                 va_list       args,
 883                                 gpointer      marshal_data,
 884                                 int           n_params,
 885                                 GType        *param_types)
 886 {
 887   typedef void (*GMarshalFunc_VOID__VOID) (gpointer     instance,
 888                                            gpointer     data);
 889   GCClosure *cc = (GCClosure*) closure;
 890   gpointer data1, data2;
 891   GMarshalFunc_VOID__VOID callback;
 892 
 893   if (G_CCLOSURE_SWAP_DATA (closure))
 894     {
 895       data1 = closure-&gt;data;
 896       data2 = instance;
 897     }
 898   else
 899     {
 900       data1 = instance;
 901       data2 = closure-&gt;data;
 902     }
 903   callback = (GMarshalFunc_VOID__VOID) (marshal_data ? marshal_data : cc-&gt;callback);
 904 
 905   callback (data1,
 906             data2);
 907 }
 908 
 909 
 910 /* VOID:BOOLEAN (./gmarshal.list:7) */
 911 void
 912 g_cclosure_marshal_VOID__BOOLEAN (GClosure     *closure,
 913                                   GValue       *return_value G_GNUC_UNUSED,
 914                                   guint         n_param_values,
 915                                   const GValue *param_values,
 916                                   gpointer      invocation_hint G_GNUC_UNUSED,
 917                                   gpointer      marshal_data)
 918 {
 919   typedef void (*GMarshalFunc_VOID__BOOLEAN) (gpointer     data1,
 920                                               gboolean     arg_1,
 921                                               gpointer     data2);
 922   GMarshalFunc_VOID__BOOLEAN callback;
 923   GCClosure *cc = (GCClosure*) closure;
 924   gpointer data1, data2;
 925 
 926   g_return_if_fail (n_param_values == 2);
 927 
 928   if (G_CCLOSURE_SWAP_DATA (closure))
 929     {
 930       data1 = closure-&gt;data;
 931       data2 = g_value_peek_pointer (param_values + 0);
 932     }
 933   else
 934     {
 935       data1 = g_value_peek_pointer (param_values + 0);
 936       data2 = closure-&gt;data;
 937     }
 938   callback = (GMarshalFunc_VOID__BOOLEAN) (marshal_data ? marshal_data : cc-&gt;callback);
 939 
 940   callback (data1,
 941             g_marshal_value_peek_boolean (param_values + 1),
 942             data2);
 943 }
 944 void
 945 g_cclosure_marshal_VOID__BOOLEANv (GClosure     *closure,
 946                                    GValue       *return_value,
 947                                    gpointer      instance,
 948                                    va_list       args,
 949                                    gpointer      marshal_data,
 950                                    int           n_params,
 951                                    GType        *param_types)
 952 {
 953   typedef void (*GMarshalFunc_VOID__BOOLEAN) (gpointer     instance,
 954                                               gboolean     arg_0,
 955                                               gpointer     data);
 956   GCClosure *cc = (GCClosure*) closure;
 957   gpointer data1, data2;
 958   GMarshalFunc_VOID__BOOLEAN callback;
 959   gboolean arg0;
 960   va_list args_copy;
 961 
 962   G_VA_COPY (args_copy, args);
 963   arg0 = (gboolean) va_arg (args_copy, gboolean);
 964   va_end (args_copy);
 965 
 966   if (G_CCLOSURE_SWAP_DATA (closure))
 967     {
 968       data1 = closure-&gt;data;
 969       data2 = instance;
 970     }
 971   else
 972     {
 973       data1 = instance;
 974       data2 = closure-&gt;data;
 975     }
 976   callback = (GMarshalFunc_VOID__BOOLEAN) (marshal_data ? marshal_data : cc-&gt;callback);
 977 
 978   callback (data1,
 979             arg0,
 980             data2);
 981 }
 982 
 983 
 984 /* VOID:CHAR (./gmarshal.list:8) */
 985 void
 986 g_cclosure_marshal_VOID__CHAR (GClosure     *closure,
 987                                GValue       *return_value G_GNUC_UNUSED,
 988                                guint         n_param_values,
 989                                const GValue *param_values,
 990                                gpointer      invocation_hint G_GNUC_UNUSED,
 991                                gpointer      marshal_data)
 992 {
 993   typedef void (*GMarshalFunc_VOID__CHAR) (gpointer     data1,
 994                                            gchar        arg_1,
 995                                            gpointer     data2);
 996   GMarshalFunc_VOID__CHAR callback;
 997   GCClosure *cc = (GCClosure*) closure;
 998   gpointer data1, data2;
 999 
1000   g_return_if_fail (n_param_values == 2);
1001 
1002   if (G_CCLOSURE_SWAP_DATA (closure))
1003     {
1004       data1 = closure-&gt;data;
1005       data2 = g_value_peek_pointer (param_values + 0);
1006     }
1007   else
1008     {
1009       data1 = g_value_peek_pointer (param_values + 0);
1010       data2 = closure-&gt;data;
1011     }
1012   callback = (GMarshalFunc_VOID__CHAR) (marshal_data ? marshal_data : cc-&gt;callback);
1013 
1014   callback (data1,
1015             g_marshal_value_peek_char (param_values + 1),
1016             data2);
1017 }
1018 void
1019 g_cclosure_marshal_VOID__CHARv (GClosure     *closure,
1020                                 GValue       *return_value,
1021                                 gpointer      instance,
1022                                 va_list       args,
1023                                 gpointer      marshal_data,
1024                                 int           n_params,
1025                                 GType        *param_types)
1026 {
1027   typedef void (*GMarshalFunc_VOID__CHAR) (gpointer     instance,
1028                                            gchar        arg_0,
1029                                            gpointer     data);
1030   GCClosure *cc = (GCClosure*) closure;
1031   gpointer data1, data2;
1032   GMarshalFunc_VOID__CHAR callback;
1033   gchar arg0;
1034   va_list args_copy;
1035 
1036   G_VA_COPY (args_copy, args);
1037   arg0 = (gchar) va_arg (args_copy, gint);
1038   va_end (args_copy);
1039 
1040   if (G_CCLOSURE_SWAP_DATA (closure))
1041     {
1042       data1 = closure-&gt;data;
1043       data2 = instance;
1044     }
1045   else
1046     {
1047       data1 = instance;
1048       data2 = closure-&gt;data;
1049     }
1050   callback = (GMarshalFunc_VOID__CHAR) (marshal_data ? marshal_data : cc-&gt;callback);
1051 
1052   callback (data1,
1053             arg0,
1054             data2);
1055 }
1056 
1057 
1058 /* VOID:UCHAR (./gmarshal.list:9) */
1059 void
1060 g_cclosure_marshal_VOID__UCHAR (GClosure     *closure,
1061                                 GValue       *return_value G_GNUC_UNUSED,
1062                                 guint         n_param_values,
1063                                 const GValue *param_values,
1064                                 gpointer      invocation_hint G_GNUC_UNUSED,
1065                                 gpointer      marshal_data)
1066 {
1067   typedef void (*GMarshalFunc_VOID__UCHAR) (gpointer     data1,
1068                                             guchar       arg_1,
1069                                             gpointer     data2);
1070   GMarshalFunc_VOID__UCHAR callback;
1071   GCClosure *cc = (GCClosure*) closure;
1072   gpointer data1, data2;
1073 
1074   g_return_if_fail (n_param_values == 2);
1075 
1076   if (G_CCLOSURE_SWAP_DATA (closure))
1077     {
1078       data1 = closure-&gt;data;
1079       data2 = g_value_peek_pointer (param_values + 0);
1080     }
1081   else
1082     {
1083       data1 = g_value_peek_pointer (param_values + 0);
1084       data2 = closure-&gt;data;
1085     }
1086   callback = (GMarshalFunc_VOID__UCHAR) (marshal_data ? marshal_data : cc-&gt;callback);
1087 
1088   callback (data1,
1089             g_marshal_value_peek_uchar (param_values + 1),
1090             data2);
1091 }
1092 void
1093 g_cclosure_marshal_VOID__UCHARv (GClosure     *closure,
1094                                  GValue       *return_value,
1095                                  gpointer      instance,
1096                                  va_list       args,
1097                                  gpointer      marshal_data,
1098                                  int           n_params,
1099                                  GType        *param_types)
1100 {
1101   typedef void (*GMarshalFunc_VOID__UCHAR) (gpointer     instance,
1102                                             guchar       arg_0,
1103                                             gpointer     data);
1104   GCClosure *cc = (GCClosure*) closure;
1105   gpointer data1, data2;
1106   GMarshalFunc_VOID__UCHAR callback;
1107   guchar arg0;
1108   va_list args_copy;
1109 
1110   G_VA_COPY (args_copy, args);
1111   arg0 = (guchar) va_arg (args_copy, guint);
1112   va_end (args_copy);
1113 
1114   if (G_CCLOSURE_SWAP_DATA (closure))
1115     {
1116       data1 = closure-&gt;data;
1117       data2 = instance;
1118     }
1119   else
1120     {
1121       data1 = instance;
1122       data2 = closure-&gt;data;
1123     }
1124   callback = (GMarshalFunc_VOID__UCHAR) (marshal_data ? marshal_data : cc-&gt;callback);
1125 
1126   callback (data1,
1127             arg0,
1128             data2);
1129 }
1130 
1131 
1132 /* VOID:INT (./gmarshal.list:10) */
1133 void
1134 g_cclosure_marshal_VOID__INT (GClosure     *closure,
1135                               GValue       *return_value G_GNUC_UNUSED,
1136                               guint         n_param_values,
1137                               const GValue *param_values,
1138                               gpointer      invocation_hint G_GNUC_UNUSED,
1139                               gpointer      marshal_data)
1140 {
1141   typedef void (*GMarshalFunc_VOID__INT) (gpointer     data1,
1142                                           gint         arg_1,
1143                                           gpointer     data2);
1144   GMarshalFunc_VOID__INT callback;
1145   GCClosure *cc = (GCClosure*) closure;
1146   gpointer data1, data2;
1147 
1148   g_return_if_fail (n_param_values == 2);
1149 
1150   if (G_CCLOSURE_SWAP_DATA (closure))
1151     {
1152       data1 = closure-&gt;data;
1153       data2 = g_value_peek_pointer (param_values + 0);
1154     }
1155   else
1156     {
1157       data1 = g_value_peek_pointer (param_values + 0);
1158       data2 = closure-&gt;data;
1159     }
1160   callback = (GMarshalFunc_VOID__INT) (marshal_data ? marshal_data : cc-&gt;callback);
1161 
1162   callback (data1,
1163             g_marshal_value_peek_int (param_values + 1),
1164             data2);
1165 }
1166 void
1167 g_cclosure_marshal_VOID__INTv (GClosure     *closure,
1168                                GValue       *return_value,
1169                                gpointer      instance,
1170                                va_list       args,
1171                                gpointer      marshal_data,
1172                                int           n_params,
1173                                GType        *param_types)
1174 {
1175   typedef void (*GMarshalFunc_VOID__INT) (gpointer     instance,
1176                                           gint         arg_0,
1177                                           gpointer     data);
1178   GCClosure *cc = (GCClosure*) closure;
1179   gpointer data1, data2;
1180   GMarshalFunc_VOID__INT callback;
1181   gint arg0;
1182   va_list args_copy;
1183 
1184  G_VA_COPY (args_copy, args);
1185   arg0 = (gint) va_arg (args_copy, gint);
1186   va_end (args_copy);
1187 
1188   if (G_CCLOSURE_SWAP_DATA (closure))
1189     {
1190       data1 = closure-&gt;data;
1191       data2 = instance;
1192     }
1193   else
1194     {
1195       data1 = instance;
1196       data2 = closure-&gt;data;
1197     }
1198   callback = (GMarshalFunc_VOID__INT) (marshal_data ? marshal_data : cc-&gt;callback);
1199 
1200   callback (data1,
1201             arg0,
1202             data2);
1203 }
1204 
1205 
1206 /* VOID:UINT (./gmarshal.list:11) */
1207 void
1208 g_cclosure_marshal_VOID__UINT (GClosure     *closure,
1209                                GValue       *return_value G_GNUC_UNUSED,
1210                                guint         n_param_values,
1211                                const GValue *param_values,
1212                                gpointer      invocation_hint G_GNUC_UNUSED,
1213                                gpointer      marshal_data)
1214 {
1215   typedef void (*GMarshalFunc_VOID__UINT) (gpointer     data1,
1216                                            guint        arg_1,
1217                                            gpointer     data2);
1218   GMarshalFunc_VOID__UINT callback;
1219   GCClosure *cc = (GCClosure*) closure;
1220   gpointer data1, data2;
1221 
1222   g_return_if_fail (n_param_values == 2);
1223 
1224   if (G_CCLOSURE_SWAP_DATA (closure))
1225     {
1226       data1 = closure-&gt;data;
1227       data2 = g_value_peek_pointer (param_values + 0);
1228     }
1229   else
1230     {
1231       data1 = g_value_peek_pointer (param_values + 0);
1232       data2 = closure-&gt;data;
1233     }
1234   callback = (GMarshalFunc_VOID__UINT) (marshal_data ? marshal_data : cc-&gt;callback);
1235 
1236   callback (data1,
1237             g_marshal_value_peek_uint (param_values + 1),
1238             data2);
1239 }
1240 void
1241 g_cclosure_marshal_VOID__UINTv (GClosure     *closure,
1242                                 GValue       *return_value,
1243                                 gpointer      instance,
1244                                 va_list       args,
1245                                 gpointer      marshal_data,
1246                                 int           n_params,
1247                                 GType        *param_types)
1248 {
1249   typedef void (*GMarshalFunc_VOID__UINT) (gpointer     instance,
1250                                            guint        arg_0,
1251                                            gpointer     data);
1252   GCClosure *cc = (GCClosure*) closure;
1253   gpointer data1, data2;
1254   GMarshalFunc_VOID__UINT callback;
1255   guint arg0;
1256   va_list args_copy;
1257 
1258   G_VA_COPY (args_copy, args);
1259   arg0 = (guint) va_arg (args_copy, guint);
1260   va_end (args_copy);
1261 
1262   if (G_CCLOSURE_SWAP_DATA (closure))
1263     {
1264       data1 = closure-&gt;data;
1265       data2 = instance;
1266     }
1267   else
1268     {
1269       data1 = instance;
1270       data2 = closure-&gt;data;
1271     }
1272   callback = (GMarshalFunc_VOID__UINT) (marshal_data ? marshal_data : cc-&gt;callback);
1273 
1274   callback (data1,
1275             arg0,
1276             data2);
1277 }
1278 
1279 
1280 /* VOID:LONG (./gmarshal.list:12) */
1281 void
1282 g_cclosure_marshal_VOID__LONG (GClosure     *closure,
1283                                GValue       *return_value G_GNUC_UNUSED,
1284                                guint         n_param_values,
1285                                const GValue *param_values,
1286                                gpointer      invocation_hint G_GNUC_UNUSED,
1287                                gpointer      marshal_data)
1288 {
1289   typedef void (*GMarshalFunc_VOID__LONG) (gpointer     data1,
1290                                            glong        arg_1,
1291                                            gpointer     data2);
1292   GMarshalFunc_VOID__LONG callback;
1293   GCClosure *cc = (GCClosure*) closure;
1294   gpointer data1, data2;
1295 
1296   g_return_if_fail (n_param_values == 2);
1297 
1298   if (G_CCLOSURE_SWAP_DATA (closure))
1299     {
1300       data1 = closure-&gt;data;
1301       data2 = g_value_peek_pointer (param_values + 0);
1302     }
1303   else
1304     {
1305       data1 = g_value_peek_pointer (param_values + 0);
1306       data2 = closure-&gt;data;
1307     }
1308   callback = (GMarshalFunc_VOID__LONG) (marshal_data ? marshal_data : cc-&gt;callback);
1309 
1310   callback (data1,
1311             g_marshal_value_peek_long (param_values + 1),
1312             data2);
1313 }
1314 void
1315 g_cclosure_marshal_VOID__LONGv (GClosure     *closure,
1316                                 GValue       *return_value,
1317                                 gpointer      instance,
1318                                 va_list       args,
1319                                 gpointer      marshal_data,
1320                                 int           n_params,
1321                                 GType        *param_types)
1322 {
1323   typedef void (*GMarshalFunc_VOID__LONG) (gpointer     instance,
1324                                            glong        arg_0,
1325                                            gpointer     data);
1326   GCClosure *cc = (GCClosure*) closure;
1327   gpointer data1, data2;
1328   GMarshalFunc_VOID__LONG callback;
1329   glong arg0;
1330   va_list args_copy;
1331 
1332   G_VA_COPY (args_copy, args);
1333   arg0 = (glong) va_arg (args_copy, glong);
1334   va_end (args_copy);
1335 
1336   if (G_CCLOSURE_SWAP_DATA (closure))
1337     {
1338       data1 = closure-&gt;data;
1339       data2 = instance;
1340     }
1341   else
1342     {
1343       data1 = instance;
1344       data2 = closure-&gt;data;
1345     }
1346   callback = (GMarshalFunc_VOID__LONG) (marshal_data ? marshal_data : cc-&gt;callback);
1347 
1348   callback (data1,
1349             arg0,
1350             data2);
1351 }
1352 
1353 
1354 /* VOID:ULONG (./gmarshal.list:13) */
1355 void
1356 g_cclosure_marshal_VOID__ULONG (GClosure     *closure,
1357                                 GValue       *return_value G_GNUC_UNUSED,
1358                                 guint         n_param_values,
1359                                 const GValue *param_values,
1360                                 gpointer      invocation_hint G_GNUC_UNUSED,
1361                                 gpointer      marshal_data)
1362 {
1363   typedef void (*GMarshalFunc_VOID__ULONG) (gpointer     data1,
1364                                             gulong       arg_1,
1365                                             gpointer     data2);
1366   GMarshalFunc_VOID__ULONG callback;
1367   GCClosure *cc = (GCClosure*) closure;
1368   gpointer data1, data2;
1369 
1370   g_return_if_fail (n_param_values == 2);
1371 
1372   if (G_CCLOSURE_SWAP_DATA (closure))
1373     {
1374       data1 = closure-&gt;data;
1375       data2 = g_value_peek_pointer (param_values + 0);
1376     }
1377   else
1378     {
1379       data1 = g_value_peek_pointer (param_values + 0);
1380       data2 = closure-&gt;data;
1381     }
1382   callback = (GMarshalFunc_VOID__ULONG) (marshal_data ? marshal_data : cc-&gt;callback);
1383 
1384   callback (data1,
1385             g_marshal_value_peek_ulong (param_values + 1),
1386             data2);
1387 }
1388 void
1389 g_cclosure_marshal_VOID__ULONGv (GClosure     *closure,
1390                                  GValue       *return_value,
1391                                  gpointer      instance,
1392                                  va_list       args,
1393                                  gpointer      marshal_data,
1394                                  int           n_params,
1395                                  GType        *param_types)
1396 {
1397   typedef void (*GMarshalFunc_VOID__ULONG) (gpointer     instance,
1398                                             gulong       arg_0,
1399                                             gpointer     data);
1400   GCClosure *cc = (GCClosure*) closure;
1401   gpointer data1, data2;
1402   GMarshalFunc_VOID__ULONG callback;
1403   gulong arg0;
1404   va_list args_copy;
1405 
1406   G_VA_COPY (args_copy, args);
1407   arg0 = (gulong) va_arg (args_copy, gulong);
1408   va_end (args_copy);
1409 
1410   if (G_CCLOSURE_SWAP_DATA (closure))
1411     {
1412       data1 = closure-&gt;data;
1413       data2 = instance;
1414     }
1415   else
1416     {
1417       data1 = instance;
1418       data2 = closure-&gt;data;
1419     }
1420   callback = (GMarshalFunc_VOID__ULONG) (marshal_data ? marshal_data : cc-&gt;callback);
1421 
1422   callback (data1,
1423             arg0,
1424             data2);
1425 }
1426 
1427 
1428 /* VOID:ENUM (./gmarshal.list:14) */
1429 void
1430 g_cclosure_marshal_VOID__ENUM (GClosure     *closure,
1431                                GValue       *return_value G_GNUC_UNUSED,
1432                                guint         n_param_values,
1433                                const GValue *param_values,
1434                                gpointer      invocation_hint G_GNUC_UNUSED,
1435                                gpointer      marshal_data)
1436 {
1437   typedef void (*GMarshalFunc_VOID__ENUM) (gpointer     data1,
1438                                            gint         arg_1,
1439                                            gpointer     data2);
1440   GMarshalFunc_VOID__ENUM callback;
1441   GCClosure *cc = (GCClosure*) closure;
1442   gpointer data1, data2;
1443 
1444   g_return_if_fail (n_param_values == 2);
1445 
1446   if (G_CCLOSURE_SWAP_DATA (closure))
1447     {
1448       data1 = closure-&gt;data;
1449       data2 = g_value_peek_pointer (param_values + 0);
1450     }
1451   else
1452     {
1453       data1 = g_value_peek_pointer (param_values + 0);
1454       data2 = closure-&gt;data;
1455     }
1456   callback = (GMarshalFunc_VOID__ENUM) (marshal_data ? marshal_data : cc-&gt;callback);
1457 
1458   callback (data1,
1459             g_marshal_value_peek_enum (param_values + 1),
1460             data2);
1461 }
1462 void
1463 g_cclosure_marshal_VOID__ENUMv (GClosure     *closure,
1464                                 GValue       *return_value,
1465                                 gpointer      instance,
1466                                 va_list       args,
1467                                 gpointer      marshal_data,
1468                                 int           n_params,
1469                                 GType        *param_types)
1470 {
1471   typedef void (*GMarshalFunc_VOID__ENUM) (gpointer     instance,
1472                                            gint         arg_0,
1473                                            gpointer     data);
1474   GCClosure *cc = (GCClosure*) closure;
1475   gpointer data1, data2;
1476   GMarshalFunc_VOID__ENUM callback;
1477   gint arg0;
1478   va_list args_copy;
1479 
1480   G_VA_COPY (args_copy, args);
1481   arg0 = (gint) va_arg (args_copy, gint);
1482   va_end (args_copy);
1483 
1484   if (G_CCLOSURE_SWAP_DATA (closure))
1485     {
1486       data1 = closure-&gt;data;
1487       data2 = instance;
1488     }
1489   else
1490     {
1491       data1 = instance;
1492       data2 = closure-&gt;data;
1493     }
1494   callback = (GMarshalFunc_VOID__ENUM) (marshal_data ? marshal_data : cc-&gt;callback);
1495 
1496   callback (data1,
1497             arg0,
1498             data2);
1499 }
1500 
1501 
1502 /* VOID:FLAGS (./gmarshal.list:15) */
1503 void
1504 g_cclosure_marshal_VOID__FLAGS (GClosure     *closure,
1505                                 GValue       *return_value G_GNUC_UNUSED,
1506                                 guint         n_param_values,
1507                                 const GValue *param_values,
1508                                 gpointer      invocation_hint G_GNUC_UNUSED,
1509                                 gpointer      marshal_data)
1510 {
1511   typedef void (*GMarshalFunc_VOID__FLAGS) (gpointer     data1,
1512                                             guint        arg_1,
1513                                             gpointer     data2);
1514   GMarshalFunc_VOID__FLAGS callback;
1515   GCClosure *cc = (GCClosure*) closure;
1516   gpointer data1, data2;
1517 
1518   g_return_if_fail (n_param_values == 2);
1519 
1520   if (G_CCLOSURE_SWAP_DATA (closure))
1521     {
1522       data1 = closure-&gt;data;
1523       data2 = g_value_peek_pointer (param_values + 0);
1524     }
1525   else
1526     {
1527       data1 = g_value_peek_pointer (param_values + 0);
1528       data2 = closure-&gt;data;
1529     }
1530   callback = (GMarshalFunc_VOID__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
1531 
1532   callback (data1,
1533             g_marshal_value_peek_flags (param_values + 1),
1534             data2);
1535 }
1536 void
1537 g_cclosure_marshal_VOID__FLAGSv (GClosure     *closure,
1538                                  GValue       *return_value,
1539                                  gpointer      instance,
1540                                  va_list       args,
1541                                  gpointer      marshal_data,
1542                                  int           n_params,
1543                                  GType        *param_types)
1544 {
1545   typedef void (*GMarshalFunc_VOID__FLAGS) (gpointer     instance,
1546                                             guint        arg_0,
1547                                             gpointer     data);
1548   GCClosure *cc = (GCClosure*) closure;
1549   gpointer data1, data2;
1550   GMarshalFunc_VOID__FLAGS callback;
1551   guint arg0;
1552   va_list args_copy;
1553 
1554   G_VA_COPY (args_copy, args);
1555   arg0 = (guint) va_arg (args_copy, guint);
1556   va_end (args_copy);
1557 
1558   if (G_CCLOSURE_SWAP_DATA (closure))
1559     {
1560       data1 = closure-&gt;data;
1561       data2 = instance;
1562     }
1563   else
1564     {
1565       data1 = instance;
1566       data2 = closure-&gt;data;
1567     }
1568   callback = (GMarshalFunc_VOID__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
1569 
1570   callback (data1,
1571             arg0,
1572             data2);
1573 }
1574 
1575 
1576 /* VOID:FLOAT (./gmarshal.list:16) */
1577 void
1578 g_cclosure_marshal_VOID__FLOAT (GClosure     *closure,
1579                                 GValue       *return_value G_GNUC_UNUSED,
1580                                 guint         n_param_values,
1581                                 const GValue *param_values,
1582                                 gpointer      invocation_hint G_GNUC_UNUSED,
1583                                 gpointer      marshal_data)
1584 {
1585   typedef void (*GMarshalFunc_VOID__FLOAT) (gpointer     data1,
1586                                             gfloat       arg_1,
1587                                             gpointer     data2);
1588   GMarshalFunc_VOID__FLOAT callback;
1589   GCClosure *cc = (GCClosure*) closure;
1590   gpointer data1, data2;
1591 
1592   g_return_if_fail (n_param_values == 2);
1593 
1594   if (G_CCLOSURE_SWAP_DATA (closure))
1595     {
1596       data1 = closure-&gt;data;
1597       data2 = g_value_peek_pointer (param_values + 0);
1598     }
1599   else
1600     {
1601       data1 = g_value_peek_pointer (param_values + 0);
1602       data2 = closure-&gt;data;
1603     }
1604   callback = (GMarshalFunc_VOID__FLOAT) (marshal_data ? marshal_data : cc-&gt;callback);
1605 
1606   callback (data1,
1607             g_marshal_value_peek_float (param_values + 1),
1608             data2);
1609 }
1610 void
1611 g_cclosure_marshal_VOID__FLOATv (GClosure     *closure,
1612                                  GValue       *return_value,
1613                                  gpointer      instance,
1614                                  va_list       args,
1615                                  gpointer      marshal_data,
1616                                  int           n_params,
1617                                  GType        *param_types)
1618 {
1619   typedef void (*GMarshalFunc_VOID__FLOAT) (gpointer     instance,
1620                                             gfloat       arg_0,
1621                                             gpointer     data);
1622   GCClosure *cc = (GCClosure*) closure;
1623   gpointer data1, data2;
1624   GMarshalFunc_VOID__FLOAT callback;
1625   gfloat arg0;
1626   va_list args_copy;
1627 
1628   G_VA_COPY (args_copy, args);
1629   arg0 = (gfloat) va_arg (args_copy, gdouble);
1630   va_end (args_copy);
1631 
1632   if (G_CCLOSURE_SWAP_DATA (closure))
1633     {
1634       data1 = closure-&gt;data;
1635       data2 = instance;
1636     }
1637   else
1638     {
1639       data1 = instance;
1640       data2 = closure-&gt;data;
1641     }
1642   callback = (GMarshalFunc_VOID__FLOAT) (marshal_data ? marshal_data : cc-&gt;callback);
1643 
1644   callback (data1,
1645             arg0,
1646             data2);
1647 }
1648 
1649 
1650 /* VOID:DOUBLE (./gmarshal.list:17) */
1651 void
1652 g_cclosure_marshal_VOID__DOUBLE (GClosure     *closure,
1653                                  GValue       *return_value G_GNUC_UNUSED,
1654                                  guint         n_param_values,
1655                                  const GValue *param_values,
1656                                  gpointer      invocation_hint G_GNUC_UNUSED,
1657                                  gpointer      marshal_data)
1658 {
1659   typedef void (*GMarshalFunc_VOID__DOUBLE) (gpointer     data1,
1660                                              gdouble      arg_1,
1661                                              gpointer     data2);
1662   GMarshalFunc_VOID__DOUBLE callback;
1663   GCClosure *cc = (GCClosure*) closure;
1664   gpointer data1, data2;
1665 
1666   g_return_if_fail (n_param_values == 2);
1667 
1668   if (G_CCLOSURE_SWAP_DATA (closure))
1669     {
1670       data1 = closure-&gt;data;
1671       data2 = g_value_peek_pointer (param_values + 0);
1672     }
1673   else
1674     {
1675       data1 = g_value_peek_pointer (param_values + 0);
1676       data2 = closure-&gt;data;
1677     }
1678   callback = (GMarshalFunc_VOID__DOUBLE) (marshal_data ? marshal_data : cc-&gt;callback);
1679 
1680   callback (data1,
1681             g_marshal_value_peek_double (param_values + 1),
1682             data2);
1683 }
1684 void
1685 g_cclosure_marshal_VOID__DOUBLEv (GClosure     *closure,
1686                                   GValue       *return_value,
1687                                   gpointer      instance,
1688                                   va_list       args,
1689                                   gpointer      marshal_data,
1690                                   int           n_params,
1691                                   GType        *param_types)
1692 {
1693   typedef void (*GMarshalFunc_VOID__DOUBLE) (gpointer     instance,
1694                                              gdouble      arg_0,
1695                                              gpointer     data);
1696   GCClosure *cc = (GCClosure*) closure;
1697   gpointer data1, data2;
1698   GMarshalFunc_VOID__DOUBLE callback;
1699   gdouble arg0;
1700   va_list args_copy;
1701 
1702   G_VA_COPY (args_copy, args);
1703   arg0 = (gdouble) va_arg (args_copy, gdouble);
1704   va_end (args_copy);
1705 
1706   if (G_CCLOSURE_SWAP_DATA (closure))
1707     {
1708       data1 = closure-&gt;data;
1709       data2 = instance;
1710     }
1711   else
1712     {
1713       data1 = instance;
1714       data2 = closure-&gt;data;
1715     }
1716   callback = (GMarshalFunc_VOID__DOUBLE) (marshal_data ? marshal_data : cc-&gt;callback);
1717 
1718   callback (data1,
1719             arg0,
1720             data2);
1721 }
1722 
1723 
1724 /* VOID:STRING (./gmarshal.list:18) */
1725 void
1726 g_cclosure_marshal_VOID__STRING (GClosure     *closure,
1727                                  GValue       *return_value G_GNUC_UNUSED,
1728                                  guint         n_param_values,
1729                                  const GValue *param_values,
1730                                  gpointer      invocation_hint G_GNUC_UNUSED,
1731                                  gpointer      marshal_data)
1732 {
1733   typedef void (*GMarshalFunc_VOID__STRING) (gpointer     data1,
1734                                              gpointer     arg_1,
1735                                              gpointer     data2);
1736   GMarshalFunc_VOID__STRING callback;
1737   GCClosure *cc = (GCClosure*) closure;
1738   gpointer data1, data2;
1739 
1740   g_return_if_fail (n_param_values == 2);
1741 
1742   if (G_CCLOSURE_SWAP_DATA (closure))
1743     {
1744       data1 = closure-&gt;data;
1745       data2 = g_value_peek_pointer (param_values + 0);
1746     }
1747   else
1748     {
1749       data1 = g_value_peek_pointer (param_values + 0);
1750       data2 = closure-&gt;data;
1751     }
1752   callback = (GMarshalFunc_VOID__STRING) (marshal_data ? marshal_data : cc-&gt;callback);
1753 
1754   callback (data1,
1755             g_marshal_value_peek_string (param_values + 1),
1756             data2);
1757 }
1758 void
1759 g_cclosure_marshal_VOID__STRINGv (GClosure     *closure,
1760                                   GValue       *return_value,
1761                                   gpointer      instance,
1762                                   va_list       args,
1763                                   gpointer      marshal_data,
1764                                   int           n_params,
1765                                   GType        *param_types)
1766 {
1767   typedef void (*GMarshalFunc_VOID__STRING) (gpointer     instance,
1768                                              gpointer     arg_0,
1769                                              gpointer     data);
1770   GCClosure *cc = (GCClosure*) closure;
1771   gpointer data1, data2;
1772   GMarshalFunc_VOID__STRING callback;
1773   gpointer arg0;
1774   va_list args_copy;
1775 
1776   G_VA_COPY (args_copy, args);
1777   arg0 = (gpointer) va_arg (args_copy, gpointer);
1778   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1779     arg0 = g_strdup (arg0);
1780   va_end (args_copy);
1781 
1782   if (G_CCLOSURE_SWAP_DATA (closure))
1783     {
1784       data1 = closure-&gt;data;
1785       data2 = instance;
1786     }
1787   else
1788     {
1789       data1 = instance;
1790       data2 = closure-&gt;data;
1791     }
1792   callback = (GMarshalFunc_VOID__STRING) (marshal_data ? marshal_data : cc-&gt;callback);
1793 
1794   callback (data1,
1795             arg0,
1796             data2);
1797   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1798     g_free (arg0);
1799 }
1800 
1801 
1802 /* VOID:PARAM (./gmarshal.list:19) */
1803 void
1804 g_cclosure_marshal_VOID__PARAM (GClosure     *closure,
1805                                 GValue       *return_value G_GNUC_UNUSED,
1806                                 guint         n_param_values,
1807                                 const GValue *param_values,
1808                                 gpointer      invocation_hint G_GNUC_UNUSED,
1809                                 gpointer      marshal_data)
1810 {
1811   typedef void (*GMarshalFunc_VOID__PARAM) (gpointer     data1,
1812                                             gpointer     arg_1,
1813                                             gpointer     data2);
1814   GMarshalFunc_VOID__PARAM callback;
1815   GCClosure *cc = (GCClosure*) closure;
1816   gpointer data1, data2;
1817 
1818   g_return_if_fail (n_param_values == 2);
1819 
1820   if (G_CCLOSURE_SWAP_DATA (closure))
1821     {
1822       data1 = closure-&gt;data;
1823       data2 = g_value_peek_pointer (param_values + 0);
1824     }
1825   else
1826     {
1827       data1 = g_value_peek_pointer (param_values + 0);
1828       data2 = closure-&gt;data;
1829     }
1830   callback = (GMarshalFunc_VOID__PARAM) (marshal_data ? marshal_data : cc-&gt;callback);
1831 
1832   callback (data1,
1833             g_marshal_value_peek_param (param_values + 1),
1834             data2);
1835 }
1836 void
1837 g_cclosure_marshal_VOID__PARAMv (GClosure     *closure,
1838                                  GValue       *return_value,
1839                                  gpointer      instance,
1840                                  va_list       args,
1841                                  gpointer      marshal_data,
1842                                  int           n_params,
1843                                  GType        *param_types)
1844 {
1845   typedef void (*GMarshalFunc_VOID__PARAM) (gpointer     instance,
1846                                             gpointer     arg_0,
1847                                             gpointer     data);
1848   GCClosure *cc = (GCClosure*) closure;
1849   gpointer data1, data2;
1850   GMarshalFunc_VOID__PARAM callback;
1851   gpointer arg0;
1852   va_list args_copy;
1853 
1854   G_VA_COPY (args_copy, args);
1855   arg0 = (gpointer) va_arg (args_copy, gpointer);
1856   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1857     arg0 = g_param_spec_ref (arg0);
1858   va_end (args_copy);
1859 
1860   if (G_CCLOSURE_SWAP_DATA (closure))
1861     {
1862       data1 = closure-&gt;data;
1863       data2 = instance;
1864     }
1865   else
1866     {
1867       data1 = instance;
1868       data2 = closure-&gt;data;
1869     }
1870   callback = (GMarshalFunc_VOID__PARAM) (marshal_data ? marshal_data : cc-&gt;callback);
1871 
1872   callback (data1,
1873             arg0,
1874             data2);
1875   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1876     g_param_spec_unref (arg0);
1877 }
1878 
1879 
1880 /* VOID:BOXED (./gmarshal.list:20) */
1881 void
1882 g_cclosure_marshal_VOID__BOXED (GClosure     *closure,
1883                                 GValue       *return_value G_GNUC_UNUSED,
1884                                 guint         n_param_values,
1885                                 const GValue *param_values,
1886                                 gpointer      invocation_hint G_GNUC_UNUSED,
1887                                 gpointer      marshal_data)
1888 {
1889   typedef void (*GMarshalFunc_VOID__BOXED) (gpointer     data1,
1890                                             gpointer     arg_1,
1891                                             gpointer     data2);
1892   GMarshalFunc_VOID__BOXED callback;
1893   GCClosure *cc = (GCClosure*) closure;
1894   gpointer data1, data2;
1895 
1896   g_return_if_fail (n_param_values == 2);
1897 
1898   if (G_CCLOSURE_SWAP_DATA (closure))
1899     {
1900       data1 = closure-&gt;data;
1901       data2 = g_value_peek_pointer (param_values + 0);
1902     }
1903   else
1904     {
1905       data1 = g_value_peek_pointer (param_values + 0);
1906       data2 = closure-&gt;data;
1907     }
1908   callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
1909 
1910   callback (data1,
1911             g_marshal_value_peek_boxed (param_values + 1),
1912             data2);
1913 }
1914 void
1915 g_cclosure_marshal_VOID__BOXEDv (GClosure     *closure,
1916                                  GValue       *return_value,
1917                                  gpointer      instance,
1918                                  va_list       args,
1919                                  gpointer      marshal_data,
1920                                  int           n_params,
1921                                  GType        *param_types)
1922 {
1923   typedef void (*GMarshalFunc_VOID__BOXED) (gpointer     instance,
1924                                             gpointer     arg_0,
1925                                             gpointer     data);
1926   GCClosure *cc = (GCClosure*) closure;
1927   gpointer data1, data2;
1928   GMarshalFunc_VOID__BOXED callback;
1929   gpointer arg0;
1930   va_list args_copy;
1931 
1932   G_VA_COPY (args_copy, args);
1933   arg0 = (gpointer) va_arg (args_copy, gpointer);
1934   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1935     arg0 = g_boxed_copy (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
1936   va_end (args_copy);
1937 
1938   if (G_CCLOSURE_SWAP_DATA (closure))
1939     {
1940       data1 = closure-&gt;data;
1941       data2 = instance;
1942     }
1943   else
1944     {
1945       data1 = instance;
1946       data2 = closure-&gt;data;
1947     }
1948   callback = (GMarshalFunc_VOID__BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
1949 
1950   callback (data1,
1951             arg0,
1952             data2);
1953   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
1954     g_boxed_free (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
1955 }
1956 
1957 
1958 /* VOID:POINTER (./gmarshal.list:21) */
1959 void
1960 g_cclosure_marshal_VOID__POINTER (GClosure     *closure,
1961                                   GValue       *return_value G_GNUC_UNUSED,
1962                                   guint         n_param_values,
1963                                   const GValue *param_values,
1964                                   gpointer      invocation_hint G_GNUC_UNUSED,
1965                                   gpointer      marshal_data)
1966 {
1967   typedef void (*GMarshalFunc_VOID__POINTER) (gpointer     data1,
1968                                               gpointer     arg_1,
1969                                               gpointer     data2);
1970   GMarshalFunc_VOID__POINTER callback;
1971   GCClosure *cc = (GCClosure*) closure;
1972   gpointer data1, data2;
1973 
1974   g_return_if_fail (n_param_values == 2);
1975 
1976   if (G_CCLOSURE_SWAP_DATA (closure))
1977     {
1978       data1 = closure-&gt;data;
1979       data2 = g_value_peek_pointer (param_values + 0);
1980     }
1981   else
1982     {
1983       data1 = g_value_peek_pointer (param_values + 0);
1984       data2 = closure-&gt;data;
1985     }
1986   callback = (GMarshalFunc_VOID__POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
1987 
1988   callback (data1,
1989             g_marshal_value_peek_pointer (param_values + 1),
1990             data2);
1991 }
1992 void
1993 g_cclosure_marshal_VOID__POINTERv (GClosure     *closure,
1994                                    GValue       *return_value,
1995                                    gpointer      instance,
1996                                    va_list       args,
1997                                    gpointer      marshal_data,
1998                                    int           n_params,
1999                                    GType        *param_types)
2000 {
2001   typedef void (*GMarshalFunc_VOID__POINTER) (gpointer     instance,
2002                                               gpointer     arg_0,
2003                                               gpointer     data);
2004   GCClosure *cc = (GCClosure*) closure;
2005   gpointer data1, data2;
2006   GMarshalFunc_VOID__POINTER callback;
2007   gpointer arg0;
2008   va_list args_copy;
2009 
2010   G_VA_COPY (args_copy, args);
2011   arg0 = (gpointer) va_arg (args_copy, gpointer);
2012   va_end (args_copy);
2013 
2014   if (G_CCLOSURE_SWAP_DATA (closure))
2015     {
2016       data1 = closure-&gt;data;
2017       data2 = instance;
2018     }
2019   else
2020     {
2021       data1 = instance;
2022       data2 = closure-&gt;data;
2023     }
2024   callback = (GMarshalFunc_VOID__POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2025 
2026   callback (data1,
2027             arg0,
2028             data2);
2029 }
2030 
2031 
2032 /* VOID:OBJECT (./gmarshal.list:22) */
2033 void
2034 g_cclosure_marshal_VOID__OBJECT (GClosure     *closure,
2035                                  GValue       *return_value G_GNUC_UNUSED,
2036                                  guint         n_param_values,
2037                                  const GValue *param_values,
2038                                  gpointer      invocation_hint G_GNUC_UNUSED,
2039                                  gpointer      marshal_data)
2040 {
2041   typedef void (*GMarshalFunc_VOID__OBJECT) (gpointer     data1,
2042                                              gpointer     arg_1,
2043                                              gpointer     data2);
2044   GMarshalFunc_VOID__OBJECT callback;
2045   GCClosure *cc = (GCClosure*) closure;
2046   gpointer data1, data2;
2047 
2048   g_return_if_fail (n_param_values == 2);
2049 
2050   if (G_CCLOSURE_SWAP_DATA (closure))
2051     {
2052       data1 = closure-&gt;data;
2053       data2 = g_value_peek_pointer (param_values + 0);
2054     }
2055   else
2056     {
2057       data1 = g_value_peek_pointer (param_values + 0);
2058       data2 = closure-&gt;data;
2059     }
2060   callback = (GMarshalFunc_VOID__OBJECT) (marshal_data ? marshal_data : cc-&gt;callback);
2061 
2062   callback (data1,
2063             g_marshal_value_peek_object (param_values + 1),
2064             data2);
2065 }
2066 void
2067 g_cclosure_marshal_VOID__OBJECTv (GClosure     *closure,
2068                                   GValue       *return_value,
2069                                   gpointer      instance,
2070                                   va_list       args,
2071                                   gpointer      marshal_data,
2072                                   int           n_params,
2073                                   GType        *param_types)
2074 {
2075   typedef void (*GMarshalFunc_VOID__OBJECT) (gpointer     instance,
2076                                              gpointer     arg_0,
2077                                              gpointer     data);
2078   GCClosure *cc = (GCClosure*) closure;
2079   gpointer data1, data2;
2080   GMarshalFunc_VOID__OBJECT callback;
2081   gpointer arg0;
2082   va_list args_copy;
2083 
2084   G_VA_COPY (args_copy, args);
2085   arg0 = (gpointer) va_arg (args_copy, gpointer);
2086   if (arg0 != NULL)
2087     arg0 = g_object_ref (arg0);
2088   va_end (args_copy);
2089 
2090   if (G_CCLOSURE_SWAP_DATA (closure))
2091     {
2092       data1 = closure-&gt;data;
2093       data2 = instance;
2094     }
2095   else
2096     {
2097       data1 = instance;
2098       data2 = closure-&gt;data;
2099     }
2100   callback = (GMarshalFunc_VOID__OBJECT) (marshal_data ? marshal_data : cc-&gt;callback);
2101 
2102   callback (data1,
2103             arg0,
2104             data2);
2105   if (arg0 != NULL)
2106     g_object_unref (arg0);
2107 }
2108 
2109 
2110 /* VOID:VARIANT (./gmarshal.list:23) */
2111 void
2112 g_cclosure_marshal_VOID__VARIANT (GClosure     *closure,
2113                                   GValue       *return_value G_GNUC_UNUSED,
2114                                   guint         n_param_values,
2115                                   const GValue *param_values,
2116                                   gpointer      invocation_hint G_GNUC_UNUSED,
2117                                   gpointer      marshal_data)
2118 {
2119   typedef void (*GMarshalFunc_VOID__VARIANT) (gpointer     data1,
2120                                               gpointer     arg_1,
2121                                               gpointer     data2);
2122   GMarshalFunc_VOID__VARIANT callback;
2123   GCClosure *cc = (GCClosure*) closure;
2124   gpointer data1, data2;
2125 
2126   g_return_if_fail (n_param_values == 2);
2127 
2128   if (G_CCLOSURE_SWAP_DATA (closure))
2129     {
2130       data1 = closure-&gt;data;
2131       data2 = g_value_peek_pointer (param_values + 0);
2132     }
2133   else
2134     {
2135       data1 = g_value_peek_pointer (param_values + 0);
2136       data2 = closure-&gt;data;
2137     }
2138   callback = (GMarshalFunc_VOID__VARIANT) (marshal_data ? marshal_data : cc-&gt;callback);
2139 
2140   callback (data1,
2141             g_marshal_value_peek_variant (param_values + 1),
2142             data2);
2143 }
2144 void
2145 g_cclosure_marshal_VOID__VARIANTv (GClosure     *closure,
2146                                    GValue       *return_value,
2147                                    gpointer      instance,
2148                                    va_list       args,
2149                                    gpointer      marshal_data,
2150                                    int           n_params,
2151                                    GType        *param_types)
2152 {
2153   typedef void (*GMarshalFunc_VOID__VARIANT) (gpointer     instance,
2154                                               gpointer     arg_0,
2155                                               gpointer     data);
2156   GCClosure *cc = (GCClosure*) closure;
2157   gpointer data1, data2;
2158   GMarshalFunc_VOID__VARIANT callback;
2159   gpointer arg0;
2160   va_list args_copy;
2161 
2162   G_VA_COPY (args_copy, args);
2163   arg0 = (gpointer) va_arg (args_copy, gpointer);
2164   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2165     arg0 = g_variant_ref_sink (arg0);
2166   va_end (args_copy);
2167 
2168   if (G_CCLOSURE_SWAP_DATA (closure))
2169     {
2170       data1 = closure-&gt;data;
2171       data2 = instance;
2172     }
2173   else
2174     {
2175       data1 = instance;
2176       data2 = closure-&gt;data;
2177     }
2178   callback = (GMarshalFunc_VOID__VARIANT) (marshal_data ? marshal_data : cc-&gt;callback);
2179 
2180   callback (data1,
2181             arg0,
2182             data2);
2183   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2184     g_variant_unref (arg0);
2185 }
2186 
2187 
2188 /* VOID:UINT,POINTER (./gmarshal.list:26) */
2189 void
2190 g_cclosure_marshal_VOID__UINT_POINTER (GClosure     *closure,
2191                                        GValue       *return_value G_GNUC_UNUSED,
2192                                        guint         n_param_values,
2193                                        const GValue *param_values,
2194                                        gpointer      invocation_hint G_GNUC_UNUSED,
2195                                        gpointer      marshal_data)
2196 {
2197   typedef void (*GMarshalFunc_VOID__UINT_POINTER) (gpointer     data1,
2198                                                    guint        arg_1,
2199                                                    gpointer     arg_2,
2200                                                    gpointer     data2);
2201   GMarshalFunc_VOID__UINT_POINTER callback;
2202   GCClosure *cc = (GCClosure*) closure;
2203   gpointer data1, data2;
2204 
2205   g_return_if_fail (n_param_values == 3);
2206 
2207   if (G_CCLOSURE_SWAP_DATA (closure))
2208     {
2209       data1 = closure-&gt;data;
2210       data2 = g_value_peek_pointer (param_values + 0);
2211     }
2212   else
2213     {
2214       data1 = g_value_peek_pointer (param_values + 0);
2215       data2 = closure-&gt;data;
2216     }
2217   callback = (GMarshalFunc_VOID__UINT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2218 
2219   callback (data1,
2220             g_marshal_value_peek_uint (param_values + 1),
2221             g_marshal_value_peek_pointer (param_values + 2),
2222             data2);
2223 }
2224 void
2225 g_cclosure_marshal_VOID__UINT_POINTERv (GClosure     *closure,
2226                                         GValue       *return_value,
2227                                         gpointer      instance,
2228                                         va_list       args,
2229                                         gpointer      marshal_data,
2230                                         int           n_params,
2231                                         GType        *param_types)
2232 {
2233   typedef void (*GMarshalFunc_VOID__UINT_POINTER) (gpointer     instance,
2234                                                    guint        arg_0,
2235                                                    gpointer     arg_1,
2236                                                    gpointer     data);
2237   GCClosure *cc = (GCClosure*) closure;
2238   gpointer data1, data2;
2239   GMarshalFunc_VOID__UINT_POINTER callback;
2240   guint arg0;
2241   gpointer arg1;
2242   va_list args_copy;
2243 
2244   G_VA_COPY (args_copy, args);
2245   arg0 = (guint) va_arg (args_copy, guint);
2246   arg1 = (gpointer) va_arg (args_copy, gpointer);
2247   va_end (args_copy);
2248 
2249   if (G_CCLOSURE_SWAP_DATA (closure))
2250     {
2251       data1 = closure-&gt;data;
2252       data2 = instance;
2253     }
2254   else
2255     {
2256       data1 = instance;
2257       data2 = closure-&gt;data;
2258     }
2259   callback = (GMarshalFunc_VOID__UINT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2260 
2261   callback (data1,
2262             arg0,
2263             arg1,
2264             data2);
2265 }
2266 
2267 
2268 /* BOOL:FLAGS (./gmarshal.list:27) */
2269 void
2270 g_cclosure_marshal_BOOLEAN__FLAGS (GClosure     *closure,
2271                                    GValue       *return_value G_GNUC_UNUSED,
2272                                    guint         n_param_values,
2273                                    const GValue *param_values,
2274                                    gpointer      invocation_hint G_GNUC_UNUSED,
2275                                    gpointer      marshal_data)
2276 {
2277   typedef gboolean (*GMarshalFunc_BOOLEAN__FLAGS) (gpointer     data1,
2278                                                    guint        arg_1,
2279                                                    gpointer     data2);
2280   GMarshalFunc_BOOLEAN__FLAGS callback;
2281   GCClosure *cc = (GCClosure*) closure;
2282   gpointer data1, data2;
2283   gboolean v_return;
2284 
2285   g_return_if_fail (return_value != NULL);
2286   g_return_if_fail (n_param_values == 2);
2287 
2288   if (G_CCLOSURE_SWAP_DATA (closure))
2289     {
2290       data1 = closure-&gt;data;
2291       data2 = g_value_peek_pointer (param_values + 0);
2292     }
2293   else
2294     {
2295       data1 = g_value_peek_pointer (param_values + 0);
2296       data2 = closure-&gt;data;
2297     }
2298   callback = (GMarshalFunc_BOOLEAN__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
2299 
2300   v_return = callback (data1,
2301                        g_marshal_value_peek_flags (param_values + 1),
2302                        data2);
2303 
2304   g_value_set_boolean (return_value, v_return);
2305 }
2306 void
2307 g_cclosure_marshal_BOOLEAN__FLAGSv (GClosure     *closure,
2308                                     GValue       *return_value,
2309                                     gpointer      instance,
2310                                     va_list       args,
2311                                     gpointer      marshal_data,
2312                                     int           n_params,
2313                                     GType        *param_types)
2314 {
2315   typedef gboolean (*GMarshalFunc_BOOLEAN__FLAGS) (gpointer     instance,
2316                                                    guint        arg_0,
2317                                                    gpointer     data);
2318   GCClosure *cc = (GCClosure*) closure;
2319   gpointer data1, data2;
2320   GMarshalFunc_BOOLEAN__FLAGS callback;
2321   guint arg0;
2322   va_list args_copy;
2323   gboolean v_return;
2324 
2325   g_return_if_fail (return_value != NULL);
2326 
2327   G_VA_COPY (args_copy, args);
2328   arg0 = (guint) va_arg (args_copy, guint);
2329   va_end (args_copy);
2330 
2331   if (G_CCLOSURE_SWAP_DATA (closure))
2332     {
2333       data1 = closure-&gt;data;
2334       data2 = instance;
2335     }
2336   else
2337     {
2338       data1 = instance;
2339       data2 = closure-&gt;data;
2340     }
2341   callback = (GMarshalFunc_BOOLEAN__FLAGS) (marshal_data ? marshal_data : cc-&gt;callback);
2342 
2343   v_return = callback (data1,
2344                        arg0,
2345                        data2);
2346 
2347   g_value_set_boolean (return_value, v_return);
2348 }
2349 
2350 
2351 /* STRING:OBJECT,POINTER (./gmarshal.list:28) */
2352 void
2353 g_cclosure_marshal_STRING__OBJECT_POINTER (GClosure     *closure,
2354                                            GValue       *return_value G_GNUC_UNUSED,
2355                                            guint         n_param_values,
2356                                            const GValue *param_values,
2357                                            gpointer      invocation_hint G_GNUC_UNUSED,
2358                                            gpointer      marshal_data)
2359 {
2360   typedef gchar* (*GMarshalFunc_STRING__OBJECT_POINTER) (gpointer     data1,
2361                                                          gpointer     arg_1,
2362                                                          gpointer     arg_2,
2363                                                          gpointer     data2);
2364   GMarshalFunc_STRING__OBJECT_POINTER callback;
2365   GCClosure *cc = (GCClosure*) closure;
2366   gpointer data1, data2;
2367   gchar* v_return;
2368 
2369   g_return_if_fail (return_value != NULL);
2370   g_return_if_fail (n_param_values == 3);
2371 
2372   if (G_CCLOSURE_SWAP_DATA (closure))
2373     {
2374       data1 = closure-&gt;data;
2375       data2 = g_value_peek_pointer (param_values + 0);
2376     }
2377   else
2378     {
2379       data1 = g_value_peek_pointer (param_values + 0);
2380       data2 = closure-&gt;data;
2381     }
2382   callback = (GMarshalFunc_STRING__OBJECT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2383 
2384   v_return = callback (data1,
2385                        g_marshal_value_peek_object (param_values + 1),
2386                        g_marshal_value_peek_pointer (param_values + 2),
2387                        data2);
2388 
2389   g_value_take_string (return_value, v_return);
2390 }
2391 void
2392 g_cclosure_marshal_STRING__OBJECT_POINTERv (GClosure     *closure,
2393                                             GValue       *return_value,
2394                                             gpointer      instance,
2395                                             va_list       args,
2396                                             gpointer      marshal_data,
2397                                             int           n_params,
2398                                             GType        *param_types)
2399 {
2400   typedef gchar* (*GMarshalFunc_STRING__OBJECT_POINTER) (gpointer     instance,
2401                                                          gpointer     arg_0,
2402                                                          gpointer     arg_1,
2403                                                          gpointer     data);
2404   GCClosure *cc = (GCClosure*) closure;
2405   gpointer data1, data2;
2406   GMarshalFunc_STRING__OBJECT_POINTER callback;
2407   gpointer arg0;
2408   gpointer arg1;
2409   va_list args_copy;
2410   gchar* v_return;
2411 
2412   g_return_if_fail (return_value != NULL);
2413 
2414   G_VA_COPY (args_copy, args);
2415   arg0 = (gpointer) va_arg (args_copy, gpointer);
2416   if (arg0 != NULL)
2417     arg0 = g_object_ref (arg0);
2418   arg1 = (gpointer) va_arg (args_copy, gpointer);
2419   va_end (args_copy);
2420 
2421   if (G_CCLOSURE_SWAP_DATA (closure))
2422     {
2423       data1 = closure-&gt;data;
2424       data2 = instance;
2425     }
2426   else
2427     {
2428       data1 = instance;
2429       data2 = closure-&gt;data;
2430     }
2431   callback = (GMarshalFunc_STRING__OBJECT_POINTER) (marshal_data ? marshal_data : cc-&gt;callback);
2432 
2433   v_return = callback (data1,
2434                        arg0,
2435                        arg1,
2436                        data2);
2437   if (arg0 != NULL)
2438     g_object_unref (arg0);
2439 
2440   g_value_take_string (return_value, v_return);
2441 }
2442 
2443 
2444 /* BOOL:BOXED,BOXED (./gmarshal.list:29) */
2445 void
2446 g_cclosure_marshal_BOOLEAN__BOXED_BOXED (GClosure     *closure,
2447                                          GValue       *return_value G_GNUC_UNUSED,
2448                                          guint         n_param_values,
2449                                          const GValue *param_values,
2450                                          gpointer      invocation_hint G_GNUC_UNUSED,
2451                                          gpointer      marshal_data)
2452 {
2453   typedef gboolean (*GMarshalFunc_BOOLEAN__BOXED_BOXED) (gpointer     data1,
2454                                                          gpointer     arg_1,
2455                                                          gpointer     arg_2,
2456                                                          gpointer     data2);
2457   GMarshalFunc_BOOLEAN__BOXED_BOXED callback;
2458   GCClosure *cc = (GCClosure*) closure;
2459   gpointer data1, data2;
2460   gboolean v_return;
2461 
2462   g_return_if_fail (return_value != NULL);
2463   g_return_if_fail (n_param_values == 3);
2464 
2465   if (G_CCLOSURE_SWAP_DATA (closure))
2466     {
2467       data1 = closure-&gt;data;
2468       data2 = g_value_peek_pointer (param_values + 0);
2469     }
2470   else
2471     {
2472       data1 = g_value_peek_pointer (param_values + 0);
2473       data2 = closure-&gt;data;
2474     }
2475   callback = (GMarshalFunc_BOOLEAN__BOXED_BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
2476 
2477   v_return = callback (data1,
2478                        g_marshal_value_peek_boxed (param_values + 1),
2479                        g_marshal_value_peek_boxed (param_values + 2),
2480                        data2);
2481 
2482   g_value_set_boolean (return_value, v_return);
2483 }
2484 void
2485 g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv (GClosure     *closure,
2486                                           GValue       *return_value,
2487                                           gpointer      instance,
2488                                           va_list       args,
2489                                           gpointer      marshal_data,
2490                                           int           n_params,
2491                                           GType        *param_types)
2492 {
2493   typedef gboolean (*GMarshalFunc_BOOLEAN__BOXED_BOXED) (gpointer     instance,
2494                                                          gpointer     arg_0,
2495                                                          gpointer     arg_1,
2496                                                          gpointer     data);
2497   GCClosure *cc = (GCClosure*) closure;
2498   gpointer data1, data2;
2499   GMarshalFunc_BOOLEAN__BOXED_BOXED callback;
2500   gpointer arg0;
2501   gpointer arg1;
2502   va_list args_copy;
2503   gboolean v_return;
2504 
2505   g_return_if_fail (return_value != NULL);
2506 
2507   G_VA_COPY (args_copy, args);
2508   arg0 = (gpointer) va_arg (args_copy, gpointer);
2509   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2510     arg0 = g_boxed_copy (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
2511   arg1 = (gpointer) va_arg (args_copy, gpointer);
2512   if ((param_types[1] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg1 != NULL)
2513     arg1 = g_boxed_copy (param_types[1] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
2514   va_end (args_copy);
2515 
2516   if (G_CCLOSURE_SWAP_DATA (closure))
2517     {
2518       data1 = closure-&gt;data;
2519       data2 = instance;
2520     }
2521   else
2522     {
2523       data1 = instance;
2524       data2 = closure-&gt;data;
2525     }
2526   callback = (GMarshalFunc_BOOLEAN__BOXED_BOXED) (marshal_data ? marshal_data : cc-&gt;callback);
2527 
2528   v_return = callback (data1,
2529                        arg0,
2530                        arg1,
2531                        data2);
2532   if ((param_types[0] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg0 != NULL)
2533     g_boxed_free (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg0);
2534   if ((param_types[1] &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0 &amp;&amp; arg1 != NULL)
2535     g_boxed_free (param_types[1] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, arg1);
2536 
2537   g_value_set_boolean (return_value, v_return);
2538 }
2539 
2540 
    </pre>
  </body>
</html>