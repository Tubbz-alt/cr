<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmappedfile.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gmain.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmappedfile.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmappedfile.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 90 
 91 static void
 92 g_mapped_file_destroy (GMappedFile *file)
 93 {
 94   if (file-&gt;length)
 95     {
 96 #ifdef HAVE_MMAP
 97       munmap (file-&gt;contents, file-&gt;length);
 98 #endif
 99 #ifdef G_OS_WIN32
100       UnmapViewOfFile (file-&gt;contents);
101       CloseHandle (file-&gt;mapping);
102 #endif
103     }
104 
105   g_slice_free (GMappedFile, file);
106 }
107 
108 static GMappedFile*
109 mapped_file_new_from_fd (int           fd,
<span class="line-modified">110              gboolean      writable,</span>
111                          const gchar  *filename,
112                          GError      **error)
113 {
114   GMappedFile *file;
115   struct stat st;
116 
117   file = g_slice_new0 (GMappedFile);
118   file-&gt;ref_count = 1;
119   file-&gt;free_func = g_mapped_file_destroy;
120 
121   if (fstat (fd, &amp;st) == -1)
122     {
123       int save_errno = errno;
124       gchar *display_filename = filename ? g_filename_display_name (filename) : NULL;
125 
126       g_set_error (error,
127                    G_FILE_ERROR,
128                    g_file_error_from_errno (save_errno),
129                    _(&quot;Failed to get attributes of file &#39;%s%s%s%s&#39;: fstat() failed: %s&quot;),
<span class="line-modified">130            display_filename ? display_filename : &quot;fd&quot;,</span>
<span class="line-modified">131            display_filename ? &quot;&#39; &quot; : &quot;&quot;,</span>
<span class="line-modified">132            display_filename ? display_filename : &quot;&quot;,</span>
<span class="line-modified">133            display_filename ? &quot;&#39;&quot; : &quot;&quot;,</span>
<span class="line-modified">134            g_strerror (save_errno));</span>
135       g_free (display_filename);
136       goto out;
137     }
138 
139   /* mmap() on size 0 will fail with EINVAL, so we avoid calling mmap()
140    * in that case -- but only if we have a regular file; we still want
141    * attempts to mmap a character device to fail, for example.
142    */
143   if (st.st_size == 0 &amp;&amp; S_ISREG (st.st_mode))
144     {
145       file-&gt;length = 0;
146       file-&gt;contents = NULL;
147       return file;
148     }
149 
150   file-&gt;contents = MAP_FAILED;
151 
152 #ifdef HAVE_MMAP
<span class="line-modified">153   if (st.st_size &gt; G_MAXSIZE)</span>
154     {
155       errno = EINVAL;
156     }
157   else
158     {
159       file-&gt;length = (gsize) st.st_size;
160       file-&gt;contents = (gchar *) mmap (NULL,  file-&gt;length,
<span class="line-modified">161                        writable ? PROT_READ|PROT_WRITE : PROT_READ,</span>
<span class="line-modified">162                        MAP_PRIVATE, fd, 0);</span>
163     }
164 #endif
165 #ifdef G_OS_WIN32
166   file-&gt;length = st.st_size;
167   file-&gt;mapping = CreateFileMapping ((HANDLE) _get_osfhandle (fd), NULL,
<span class="line-modified">168                      writable ? PAGE_WRITECOPY : PAGE_READONLY,</span>
<span class="line-modified">169                      0, 0,</span>
<span class="line-modified">170                      NULL);</span>
171   if (file-&gt;mapping != NULL)
172     {
173       file-&gt;contents = MapViewOfFile (file-&gt;mapping,
<span class="line-modified">174                       writable ? FILE_MAP_COPY : FILE_MAP_READ,</span>
<span class="line-modified">175                       0, 0,</span>
<span class="line-modified">176                       0);</span>
177       if (file-&gt;contents == NULL)
<span class="line-modified">178     {</span>
<span class="line-modified">179       file-&gt;contents = MAP_FAILED;</span>
<span class="line-modified">180       CloseHandle (file-&gt;mapping);</span>
<span class="line-modified">181       file-&gt;mapping = NULL;</span>
<span class="line-modified">182     }</span>
183     }
184 #endif
185 
186 
187   if (file-&gt;contents == MAP_FAILED)
188     {
189       int save_errno = errno;
190       gchar *display_filename = filename ? g_filename_display_name (filename) : NULL;
191 
192       g_set_error (error,
<span class="line-modified">193            G_FILE_ERROR,</span>
<span class="line-modified">194            g_file_error_from_errno (save_errno),</span>
<span class="line-modified">195            _(&quot;Failed to map %s%s%s%s: mmap() failed: %s&quot;),</span>
<span class="line-modified">196            display_filename ? display_filename : &quot;fd&quot;,</span>
<span class="line-modified">197            display_filename ? &quot;&#39; &quot; : &quot;&quot;,</span>
<span class="line-modified">198            display_filename ? display_filename : &quot;&quot;,</span>
<span class="line-modified">199            display_filename ? &quot;&#39;&quot; : &quot;&quot;,</span>
<span class="line-modified">200            g_strerror (save_errno));</span>
201       g_free (display_filename);
202       goto out;
203     }
204 
205   return file;
206 
207  out:
208   g_slice_free (GMappedFile, file);
209 
210   return NULL;
211 }
212 
213 /**
214  * g_mapped_file_new:
215  * @filename: (type filename): The path of the file to load, in the GLib
216  *     filename encoding
217  * @writable: whether the mapping should be writable
218  * @error: return location for a #GError, or %NULL
219  *
220  * Maps a file into memory. On UNIX, this is using the mmap() function.
</pre>
<hr />
<pre>
224  * are not visible to other processes mapping the same file, and are not
225  * written back to the file.
226  *
227  * Note that modifications of the underlying file might affect the contents
228  * of the #GMappedFile. Therefore, mapping should only be used if the file
229  * will not be modified, or if all modifications of the file are done
230  * atomically (e.g. using g_file_set_contents()).
231  *
232  * If @filename is the name of an empty, regular file, the function
233  * will successfully return an empty #GMappedFile. In other cases of
234  * size 0 (e.g. device files such as /dev/null), @error will be set
235  * to the #GFileError value #G_FILE_ERROR_INVAL.
236  *
237  * Returns: a newly allocated #GMappedFile which must be unref&#39;d
238  *    with g_mapped_file_unref(), or %NULL if the mapping failed.
239  *
240  * Since: 2.8
241  */
242 GMappedFile *
243 g_mapped_file_new (const gchar  *filename,
<span class="line-modified">244            gboolean      writable,</span>
<span class="line-modified">245            GError      **error)</span>
246 {
247   GMappedFile *file;
248   int fd;
249 
250   g_return_val_if_fail (filename != NULL, NULL);
251   g_return_val_if_fail (!error || *error == NULL, NULL);
252 
253   fd = g_open (filename, (writable ? O_RDWR : O_RDONLY) | _O_BINARY, 0);
254   if (fd == -1)
255     {
256       int save_errno = errno;
257       gchar *display_filename = g_filename_display_name (filename);
258 
259       g_set_error (error,
260                    G_FILE_ERROR,
261                    g_file_error_from_errno (save_errno),
262                    _(&quot;Failed to open file &#39;%s&#39;: open() failed: %s&quot;),
263                    display_filename,
<span class="line-modified">264            g_strerror (save_errno));</span>
265       g_free (display_filename);
266       return NULL;
267     }
268 
269   file = mapped_file_new_from_fd (fd, writable, filename, error);
270 
271   close (fd);
272 
273   return file;
274 }
275 
276 
277 /**
278  * g_mapped_file_new_from_fd:
279  * @fd: The file descriptor of the file to load
280  * @writable: whether the mapping should be writable
281  * @error: return location for a #GError, or %NULL
282  *
283  * Maps a file into memory. On UNIX, this is using the mmap() function.
284  *
285  * If @writable is %TRUE, the mapped buffer may be modified, otherwise
286  * it is an error to modify the mapped buffer. Modifications to the buffer
287  * are not visible to other processes mapping the same file, and are not
288  * written back to the file.
289  *
290  * Note that modifications of the underlying file might affect the contents
291  * of the #GMappedFile. Therefore, mapping should only be used if the file
292  * will not be modified, or if all modifications of the file are done
293  * atomically (e.g. using g_file_set_contents()).
294  *
295  * Returns: a newly allocated #GMappedFile which must be unref&#39;d
296  *    with g_mapped_file_unref(), or %NULL if the mapping failed.
297  *
298  * Since: 2.32
299  */
300 GMappedFile *
301 g_mapped_file_new_from_fd (gint          fd,
<span class="line-modified">302                gboolean      writable,</span>
<span class="line-modified">303                GError      **error)</span>
304 {
305   return mapped_file_new_from_fd (fd, writable, NULL, error);
306 }
307 
308 /**
309  * g_mapped_file_get_length:
310  * @file: a #GMappedFile
311  *
312  * Returns the length of the contents of a #GMappedFile.
313  *
314  * Returns: the length of the contents of @file.
315  *
316  * Since: 2.8
317  */
318 gsize
319 g_mapped_file_get_length (GMappedFile *file)
320 {
321   g_return_val_if_fail (file != NULL, 0);
322 
323   return file-&gt;length;
</pre>
<hr />
<pre>
405 
406 /**
407  * g_mapped_file_get_bytes:
408  * @file: a #GMappedFile
409  *
410  * Creates a new #GBytes which references the data mapped from @file.
411  * The mapped contents of the file must not be modified after creating this
412  * bytes object, because a #GBytes should be immutable.
413  *
414  * Returns: (transfer full): A newly allocated #GBytes referencing data
415  *     from @file
416  *
417  * Since: 2.34
418  **/
419 GBytes *
420 g_mapped_file_get_bytes (GMappedFile *file)
421 {
422   g_return_val_if_fail (file != NULL, NULL);
423 
424   return g_bytes_new_with_free_func (file-&gt;contents,
<span class="line-modified">425                      file-&gt;length,</span>
<span class="line-modified">426                      (GDestroyNotify) g_mapped_file_unref,</span>
<span class="line-modified">427                      g_mapped_file_ref (file));</span>
428 }
</pre>
</td>
<td>
<hr />
<pre>
 90 
 91 static void
 92 g_mapped_file_destroy (GMappedFile *file)
 93 {
 94   if (file-&gt;length)
 95     {
 96 #ifdef HAVE_MMAP
 97       munmap (file-&gt;contents, file-&gt;length);
 98 #endif
 99 #ifdef G_OS_WIN32
100       UnmapViewOfFile (file-&gt;contents);
101       CloseHandle (file-&gt;mapping);
102 #endif
103     }
104 
105   g_slice_free (GMappedFile, file);
106 }
107 
108 static GMappedFile*
109 mapped_file_new_from_fd (int           fd,
<span class="line-modified">110        gboolean      writable,</span>
111                          const gchar  *filename,
112                          GError      **error)
113 {
114   GMappedFile *file;
115   struct stat st;
116 
117   file = g_slice_new0 (GMappedFile);
118   file-&gt;ref_count = 1;
119   file-&gt;free_func = g_mapped_file_destroy;
120 
121   if (fstat (fd, &amp;st) == -1)
122     {
123       int save_errno = errno;
124       gchar *display_filename = filename ? g_filename_display_name (filename) : NULL;
125 
126       g_set_error (error,
127                    G_FILE_ERROR,
128                    g_file_error_from_errno (save_errno),
129                    _(&quot;Failed to get attributes of file &#39;%s%s%s%s&#39;: fstat() failed: %s&quot;),
<span class="line-modified">130        display_filename ? display_filename : &quot;fd&quot;,</span>
<span class="line-modified">131        display_filename ? &quot;&#39; &quot; : &quot;&quot;,</span>
<span class="line-modified">132        display_filename ? display_filename : &quot;&quot;,</span>
<span class="line-modified">133        display_filename ? &quot;&#39;&quot; : &quot;&quot;,</span>
<span class="line-modified">134        g_strerror (save_errno));</span>
135       g_free (display_filename);
136       goto out;
137     }
138 
139   /* mmap() on size 0 will fail with EINVAL, so we avoid calling mmap()
140    * in that case -- but only if we have a regular file; we still want
141    * attempts to mmap a character device to fail, for example.
142    */
143   if (st.st_size == 0 &amp;&amp; S_ISREG (st.st_mode))
144     {
145       file-&gt;length = 0;
146       file-&gt;contents = NULL;
147       return file;
148     }
149 
150   file-&gt;contents = MAP_FAILED;
151 
152 #ifdef HAVE_MMAP
<span class="line-modified">153   if (sizeof (st.st_size) &gt; sizeof (gsize) &amp;&amp; st.st_size &gt; (off_t) G_MAXSIZE)</span>
154     {
155       errno = EINVAL;
156     }
157   else
158     {
159       file-&gt;length = (gsize) st.st_size;
160       file-&gt;contents = (gchar *) mmap (NULL,  file-&gt;length,
<span class="line-modified">161                writable ? PROT_READ|PROT_WRITE : PROT_READ,</span>
<span class="line-modified">162                MAP_PRIVATE, fd, 0);</span>
163     }
164 #endif
165 #ifdef G_OS_WIN32
166   file-&gt;length = st.st_size;
167   file-&gt;mapping = CreateFileMapping ((HANDLE) _get_osfhandle (fd), NULL,
<span class="line-modified">168              writable ? PAGE_WRITECOPY : PAGE_READONLY,</span>
<span class="line-modified">169              0, 0,</span>
<span class="line-modified">170              NULL);</span>
171   if (file-&gt;mapping != NULL)
172     {
173       file-&gt;contents = MapViewOfFile (file-&gt;mapping,
<span class="line-modified">174               writable ? FILE_MAP_COPY : FILE_MAP_READ,</span>
<span class="line-modified">175               0, 0,</span>
<span class="line-modified">176               0);</span>
177       if (file-&gt;contents == NULL)
<span class="line-modified">178   {</span>
<span class="line-modified">179     file-&gt;contents = MAP_FAILED;</span>
<span class="line-modified">180     CloseHandle (file-&gt;mapping);</span>
<span class="line-modified">181     file-&gt;mapping = NULL;</span>
<span class="line-modified">182   }</span>
183     }
184 #endif
185 
186 
187   if (file-&gt;contents == MAP_FAILED)
188     {
189       int save_errno = errno;
190       gchar *display_filename = filename ? g_filename_display_name (filename) : NULL;
191 
192       g_set_error (error,
<span class="line-modified">193        G_FILE_ERROR,</span>
<span class="line-modified">194        g_file_error_from_errno (save_errno),</span>
<span class="line-modified">195        _(&quot;Failed to map %s%s%s%s: mmap() failed: %s&quot;),</span>
<span class="line-modified">196        display_filename ? display_filename : &quot;fd&quot;,</span>
<span class="line-modified">197        display_filename ? &quot;&#39; &quot; : &quot;&quot;,</span>
<span class="line-modified">198        display_filename ? display_filename : &quot;&quot;,</span>
<span class="line-modified">199        display_filename ? &quot;&#39;&quot; : &quot;&quot;,</span>
<span class="line-modified">200        g_strerror (save_errno));</span>
201       g_free (display_filename);
202       goto out;
203     }
204 
205   return file;
206 
207  out:
208   g_slice_free (GMappedFile, file);
209 
210   return NULL;
211 }
212 
213 /**
214  * g_mapped_file_new:
215  * @filename: (type filename): The path of the file to load, in the GLib
216  *     filename encoding
217  * @writable: whether the mapping should be writable
218  * @error: return location for a #GError, or %NULL
219  *
220  * Maps a file into memory. On UNIX, this is using the mmap() function.
</pre>
<hr />
<pre>
224  * are not visible to other processes mapping the same file, and are not
225  * written back to the file.
226  *
227  * Note that modifications of the underlying file might affect the contents
228  * of the #GMappedFile. Therefore, mapping should only be used if the file
229  * will not be modified, or if all modifications of the file are done
230  * atomically (e.g. using g_file_set_contents()).
231  *
232  * If @filename is the name of an empty, regular file, the function
233  * will successfully return an empty #GMappedFile. In other cases of
234  * size 0 (e.g. device files such as /dev/null), @error will be set
235  * to the #GFileError value #G_FILE_ERROR_INVAL.
236  *
237  * Returns: a newly allocated #GMappedFile which must be unref&#39;d
238  *    with g_mapped_file_unref(), or %NULL if the mapping failed.
239  *
240  * Since: 2.8
241  */
242 GMappedFile *
243 g_mapped_file_new (const gchar  *filename,
<span class="line-modified">244        gboolean      writable,</span>
<span class="line-modified">245        GError      **error)</span>
246 {
247   GMappedFile *file;
248   int fd;
249 
250   g_return_val_if_fail (filename != NULL, NULL);
251   g_return_val_if_fail (!error || *error == NULL, NULL);
252 
253   fd = g_open (filename, (writable ? O_RDWR : O_RDONLY) | _O_BINARY, 0);
254   if (fd == -1)
255     {
256       int save_errno = errno;
257       gchar *display_filename = g_filename_display_name (filename);
258 
259       g_set_error (error,
260                    G_FILE_ERROR,
261                    g_file_error_from_errno (save_errno),
262                    _(&quot;Failed to open file &#39;%s&#39;: open() failed: %s&quot;),
263                    display_filename,
<span class="line-modified">264        g_strerror (save_errno));</span>
265       g_free (display_filename);
266       return NULL;
267     }
268 
269   file = mapped_file_new_from_fd (fd, writable, filename, error);
270 
271   close (fd);
272 
273   return file;
274 }
275 
276 
277 /**
278  * g_mapped_file_new_from_fd:
279  * @fd: The file descriptor of the file to load
280  * @writable: whether the mapping should be writable
281  * @error: return location for a #GError, or %NULL
282  *
283  * Maps a file into memory. On UNIX, this is using the mmap() function.
284  *
285  * If @writable is %TRUE, the mapped buffer may be modified, otherwise
286  * it is an error to modify the mapped buffer. Modifications to the buffer
287  * are not visible to other processes mapping the same file, and are not
288  * written back to the file.
289  *
290  * Note that modifications of the underlying file might affect the contents
291  * of the #GMappedFile. Therefore, mapping should only be used if the file
292  * will not be modified, or if all modifications of the file are done
293  * atomically (e.g. using g_file_set_contents()).
294  *
295  * Returns: a newly allocated #GMappedFile which must be unref&#39;d
296  *    with g_mapped_file_unref(), or %NULL if the mapping failed.
297  *
298  * Since: 2.32
299  */
300 GMappedFile *
301 g_mapped_file_new_from_fd (gint          fd,
<span class="line-modified">302          gboolean      writable,</span>
<span class="line-modified">303          GError      **error)</span>
304 {
305   return mapped_file_new_from_fd (fd, writable, NULL, error);
306 }
307 
308 /**
309  * g_mapped_file_get_length:
310  * @file: a #GMappedFile
311  *
312  * Returns the length of the contents of a #GMappedFile.
313  *
314  * Returns: the length of the contents of @file.
315  *
316  * Since: 2.8
317  */
318 gsize
319 g_mapped_file_get_length (GMappedFile *file)
320 {
321   g_return_val_if_fail (file != NULL, 0);
322 
323   return file-&gt;length;
</pre>
<hr />
<pre>
405 
406 /**
407  * g_mapped_file_get_bytes:
408  * @file: a #GMappedFile
409  *
410  * Creates a new #GBytes which references the data mapped from @file.
411  * The mapped contents of the file must not be modified after creating this
412  * bytes object, because a #GBytes should be immutable.
413  *
414  * Returns: (transfer full): A newly allocated #GBytes referencing data
415  *     from @file
416  *
417  * Since: 2.34
418  **/
419 GBytes *
420 g_mapped_file_get_bytes (GMappedFile *file)
421 {
422   g_return_val_if_fail (file != NULL, NULL);
423 
424   return g_bytes_new_with_free_func (file-&gt;contents,
<span class="line-modified">425              file-&gt;length,</span>
<span class="line-modified">426              (GDestroyNotify) g_mapped_file_unref,</span>
<span class="line-modified">427              g_mapped_file_ref (file));</span>
428 }
</pre>
</td>
</tr>
</table>
<center><a href="gmain.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmappedfile.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>