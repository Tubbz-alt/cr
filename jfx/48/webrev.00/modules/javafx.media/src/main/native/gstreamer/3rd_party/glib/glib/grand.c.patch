diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/grand.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/grand.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/grand.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/grand.c
@@ -47,10 +47,11 @@
 #include "genviron.h"
 #include "gmain.h"
 #include "gmem.h"
 #include "gtestutils.h"
 #include "gthread.h"
+#include "gtimer.h"
 
 #ifdef G_OS_UNIX
 #include <unistd.h>
 #endif
 
@@ -142,20 +143,20 @@
 
   if (g_once_init_enter (&initialized))
     {
       const gchar *version_string = g_getenv ("G_RANDOM_VERSION");
       if (!version_string || version_string[0] == '\000' ||
-      strcmp (version_string, "2.2") == 0)
-    random_version = 22;
+    strcmp (version_string, "2.2") == 0)
+  random_version = 22;
       else if (strcmp (version_string, "2.0") == 0)
-    random_version = 20;
+  random_version = 20;
       else
-    {
-      g_warning ("Unknown G_RANDOM_VERSION \"%s\". Using version 2.2.",
-             version_string);
-      random_version = 22;
-    }
+  {
+    g_warning ("Unknown G_RANDOM_VERSION \"%s\". Using version 2.2.",
+         version_string);
+    random_version = 22;
+  }
       g_once_init_leave (&initialized, TRUE);
     }
 
   return random_version;
 }
@@ -218,48 +219,47 @@
 g_rand_new (void)
 {
   guint32 seed[4];
 #ifdef G_OS_UNIX
   static gboolean dev_urandom_exists = TRUE;
-  GTimeVal now;
 
   if (dev_urandom_exists)
     {
       FILE* dev_urandom;
 
       do
-    {
-      dev_urandom = fopen("/dev/urandom", "rb");
-    }
+  {
+    dev_urandom = fopen("/dev/urandom", "rb");
+  }
       while G_UNLIKELY (dev_urandom == NULL && errno == EINTR);
 
       if (dev_urandom)
-    {
-      int r;
+  {
+    int r;
 
-      setvbuf (dev_urandom, NULL, _IONBF, 0);
-      do
-        {
-          errno = 0;
-          r = fread (seed, sizeof (seed), 1, dev_urandom);
-        }
-      while G_UNLIKELY (errno == EINTR);
+    setvbuf (dev_urandom, NULL, _IONBF, 0);
+    do
+      {
+        errno = 0;
+        r = fread (seed, sizeof (seed), 1, dev_urandom);
+      }
+    while G_UNLIKELY (errno == EINTR);
 
-      if (r != 1)
-        dev_urandom_exists = FALSE;
+    if (r != 1)
+      dev_urandom_exists = FALSE;
 
-      fclose (dev_urandom);
-    }
+    fclose (dev_urandom);
+  }
       else
-    dev_urandom_exists = FALSE;
+  dev_urandom_exists = FALSE;
     }
 
   if (!dev_urandom_exists)
     {
-      g_get_current_time (&now);
-      seed[0] = now.tv_sec;
-      seed[1] = now.tv_usec;
+      gint64 now_us = g_get_real_time ();
+      seed[0] = now_us / G_USEC_PER_SEC;
+      seed[1] = now_us % G_USEC_PER_SEC;
       seed[2] = getpid ();
       seed[3] = getppid ();
     }
 #else /* G_OS_WIN32 */
   /* rand_s() is only available since Visual Studio 2005 and
@@ -345,26 +345,26 @@
       /* the generator Line 25 of Table 1 in          */
       /* [KNUTH 1981, The Art of Computer Programming */
       /*    Vol. 2 (2nd Ed.), pp102]                  */
 
       if (seed == 0) /* This would make the PRNG produce only zeros */
-    seed = 0x6b842128; /* Just set it to another number */
+  seed = 0x6b842128; /* Just set it to another number */
 
       rand->mt[0]= seed;
       for (rand->mti=1; rand->mti<N; rand->mti++)
-    rand->mt[rand->mti] = (69069 * rand->mt[rand->mti-1]);
+  rand->mt[rand->mti] = (69069 * rand->mt[rand->mti-1]);
 
       break;
     case 22:
       /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
       /* In the previous version (see above), MSBs of the    */
       /* seed affect only MSBs of the array mt[].            */
 
       rand->mt[0]= seed;
       for (rand->mti=1; rand->mti<N; rand->mti++)
-    rand->mt[rand->mti] = 1812433253UL *
-      (rand->mt[rand->mti-1] ^ (rand->mt[rand->mti-1] >> 30)) + rand->mti;
+  rand->mt[rand->mti] = 1812433253UL *
+    (rand->mt[rand->mti-1] ^ (rand->mt[rand->mti-1] >> 30)) + rand->mti;
       break;
     default:
       g_assert_not_reached ();
     }
 }
@@ -398,45 +398,45 @@
   i=1; j=0;
   k = (N>seed_length ? N : seed_length);
   for (; k; k--)
     {
       rand->mt[i] = (rand->mt[i] ^
-             ((rand->mt[i-1] ^ (rand->mt[i-1] >> 30)) * 1664525UL))
-          + seed[j] + j; /* non linear */
+         ((rand->mt[i-1] ^ (rand->mt[i-1] >> 30)) * 1664525UL))
+        + seed[j] + j; /* non linear */
       rand->mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
       i++; j++;
       if (i>=N)
         {
-      rand->mt[0] = rand->mt[N-1];
-      i=1;
-    }
+    rand->mt[0] = rand->mt[N-1];
+    i=1;
+  }
       if (j>=seed_length)
-    j=0;
+  j=0;
     }
   for (k=N-1; k; k--)
     {
       rand->mt[i] = (rand->mt[i] ^
-             ((rand->mt[i-1] ^ (rand->mt[i-1] >> 30)) * 1566083941UL))
-          - i; /* non linear */
+         ((rand->mt[i-1] ^ (rand->mt[i-1] >> 30)) * 1566083941UL))
+        - i; /* non linear */
       rand->mt[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
       i++;
       if (i>=N)
         {
-      rand->mt[0] = rand->mt[N-1];
-      i=1;
-    }
+    rand->mt[0] = rand->mt[N-1];
+    i=1;
+  }
     }
 
   rand->mt[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
 }
 
 /**
  * g_rand_boolean:
  * @rand_: a #GRand
  *
  * Returns a random #gboolean from @rand_.
- * This corresponds to a unbiased coin toss.
+ * This corresponds to an unbiased coin toss.
  *
  * Returns: a random #gboolean
  */
 /**
  * g_rand_int:
@@ -509,63 +509,63 @@
 
   switch (get_random_version ())
     {
     case 20:
       if (dist <= 0x10000L) /* 2^16 */
-    {
-      /* This method, which only calls g_rand_int once is only good
-       * for (end - begin) <= 2^16, because we only have 32 bits set
-       * from the one call to g_rand_int ().
-       *
-       * We are using (trans + trans * trans), because g_rand_int only
-       * covers [0..2^32-1] and thus g_rand_int * trans only covers
-       * [0..1-2^-32], but the biggest double < 1 is 1-2^-52.
-       */
-
-      gdouble double_rand = g_rand_int (rand) *
-        (G_RAND_DOUBLE_TRANSFORM +
-         G_RAND_DOUBLE_TRANSFORM * G_RAND_DOUBLE_TRANSFORM);
-
-      random = (gint32) (double_rand * dist);
-    }
+  {
+    /* This method, which only calls g_rand_int once is only good
+     * for (end - begin) <= 2^16, because we only have 32 bits set
+     * from the one call to g_rand_int ().
+     *
+     * We are using (trans + trans * trans), because g_rand_int only
+     * covers [0..2^32-1] and thus g_rand_int * trans only covers
+     * [0..1-2^-32], but the biggest double < 1 is 1-2^-52.
+     */
+
+    gdouble double_rand = g_rand_int (rand) *
+      (G_RAND_DOUBLE_TRANSFORM +
+       G_RAND_DOUBLE_TRANSFORM * G_RAND_DOUBLE_TRANSFORM);
+
+    random = (gint32) (double_rand * dist);
+  }
       else
-    {
-      /* Now we use g_rand_double_range (), which will set 52 bits
-       * for us, so that it is safe to round and still get a decent
-       * distribution
+  {
+    /* Now we use g_rand_double_range (), which will set 52 bits
+     * for us, so that it is safe to round and still get a decent
+     * distribution
            */
-      random = (gint32) g_rand_double_range (rand, 0, dist);
-    }
+    random = (gint32) g_rand_double_range (rand, 0, dist);
+  }
       break;
     case 22:
       if (dist == 0)
-    random = 0;
+  random = 0;
       else
-    {
-      /* maxvalue is set to the predecessor of the greatest
-       * multiple of dist less or equal 2^32.
-       */
-      guint32 maxvalue;
-      if (dist <= 0x80000000u) /* 2^31 */
-        {
-          /* maxvalue = 2^32 - 1 - (2^32 % dist) */
-          guint32 leftover = (0x80000000u % dist) * 2;
-          if (leftover >= dist) leftover -= dist;
-          maxvalue = 0xffffffffu - leftover;
-        }
-      else
-        maxvalue = dist - 1;
-
-      do
-        random = g_rand_int (rand);
-      while (random > maxvalue);
-
-      random %= dist;
-    }
+  {
+    /* maxvalue is set to the predecessor of the greatest
+     * multiple of dist less or equal 2^32.
+     */
+    guint32 maxvalue;
+    if (dist <= 0x80000000u) /* 2^31 */
+      {
+        /* maxvalue = 2^32 - 1 - (2^32 % dist) */
+        guint32 leftover = (0x80000000u % dist) * 2;
+        if (leftover >= dist) leftover -= dist;
+        maxvalue = 0xffffffffu - leftover;
+      }
+    else
+      maxvalue = dist - 1;
+
+    do
+      random = g_rand_int (rand);
+    while (random > maxvalue);
+
+    random %= dist;
+  }
       break;
     default:
-      random = 0;       /* Quiet GCC */
+      random = 0;   /* Quiet GCC */
       g_assert_not_reached ();
     }
 
   return begin + random;
 }
@@ -632,11 +632,11 @@
 
 /**
  * g_random_boolean:
  *
  * Returns a random #gboolean.
- * This corresponds to a unbiased coin toss.
+ * This corresponds to an unbiased coin toss.
  *
  * Returns: a random #gboolean
  */
 /**
  * g_random_int:
