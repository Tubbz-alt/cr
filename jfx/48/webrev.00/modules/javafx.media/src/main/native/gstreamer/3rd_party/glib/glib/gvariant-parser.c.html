<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant-parser.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2009, 2010 Codethink Limited
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  *
  17  * Author: Ryan Lortie &lt;desrt@desrt.ca&gt;
  18  */
  19 
  20 #include &quot;config.h&quot;
  21 
  22 #include &lt;stdlib.h&gt;
  23 #include &lt;string.h&gt;
  24 #include &lt;errno.h&gt;
  25 
  26 #include &quot;gerror.h&quot;
  27 #include &quot;gquark.h&quot;
  28 #include &quot;gstring.h&quot;
  29 #include &quot;gstrfuncs.h&quot;
  30 #include &quot;gtestutils.h&quot;
  31 #include &quot;gvariant.h&quot;
  32 #include &quot;gvarianttype.h&quot;
  33 #include &quot;gslice.h&quot;
  34 #include &quot;gthread.h&quot;
  35 
  36 /*
  37  * two-pass algorithm
  38  * designed by ryan lortie and william hua
  39  * designed in itb-229 and at ghazi&#39;s, 2009.
  40  */
  41 
  42 /**
  43  * G_VARIANT_PARSE_ERROR:
  44  *
  45  * Error domain for GVariant text format parsing.  Specific error codes
  46  * are not currently defined for this domain.  See #GError for
  47  * information on error domains.
  48  **/
  49 /**
  50  * GVariantParseError:
  51  * @G_VARIANT_PARSE_ERROR_FAILED: generic error (unused)
  52  * @G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED: a non-basic #GVariantType was given where a basic type was expected
  53  * @G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE: cannot infer the #GVariantType
  54  * @G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED: an indefinite #GVariantType was given where a definite type was expected
  55  * @G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END: extra data after parsing finished
  56  * @G_VARIANT_PARSE_ERROR_INVALID_CHARACTER: invalid character in number or unicode escape
  57  * @G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING: not a valid #GVariant format string
  58  * @G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH: not a valid object path
  59  * @G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE: not a valid type signature
  60  * @G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING: not a valid #GVariant type string
  61  * @G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE: could not find a common type for array entries
  62  * @G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE: the numerical value is out of range of the given type
  63  * @G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG: the numerical value is out of range for any type
  64  * @G_VARIANT_PARSE_ERROR_TYPE_ERROR: cannot parse as variant of the specified type
  65  * @G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN: an unexpected token was encountered
  66  * @G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD: an unknown keyword was encountered
  67  * @G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT: unterminated string constant
  68  * @G_VARIANT_PARSE_ERROR_VALUE_EXPECTED: no value given
  69  *
  70  * Error codes returned by parsing text-format GVariants.
  71  **/
  72 G_DEFINE_QUARK (g-variant-parse-error-quark, g_variant_parse_error)
  73 
  74 /**
  75  * g_variant_parser_get_error_quark:
  76  *
  77  * Same as g_variant_error_quark().
  78  *
  79  * Deprecated: Use g_variant_parse_error_quark() instead.
  80  */
  81 GQuark
  82 g_variant_parser_get_error_quark (void)
  83 {
  84   return g_variant_parse_error_quark ();
  85 }
  86 
  87 typedef struct
  88 {
  89   gint start, end;
  90 } SourceRef;
  91 
  92 G_GNUC_PRINTF(5, 0)
  93 static void
  94 parser_set_error_va (GError      **error,
  95                      SourceRef    *location,
  96                      SourceRef    *other,
  97                      gint          code,
  98                      const gchar  *format,
  99                      va_list       ap)
 100 {
 101   GString *msg = g_string_new (NULL);
 102 
 103   if (location-&gt;start == location-&gt;end)
 104     g_string_append_printf (msg, &quot;%d&quot;, location-&gt;start);
 105   else
 106     g_string_append_printf (msg, &quot;%d-%d&quot;, location-&gt;start, location-&gt;end);
 107 
 108   if (other != NULL)
 109     {
 110       g_assert (other-&gt;start != other-&gt;end);
 111       g_string_append_printf (msg, &quot;,%d-%d&quot;, other-&gt;start, other-&gt;end);
 112     }
 113   g_string_append_c (msg, &#39;:&#39;);
 114 
 115   g_string_append_vprintf (msg, format, ap);
 116   g_set_error_literal (error, G_VARIANT_PARSE_ERROR, code, msg-&gt;str);
 117   g_string_free (msg, TRUE);
 118 }
 119 
 120 G_GNUC_PRINTF(5, 6)
 121 static void
 122 parser_set_error (GError      **error,
 123                   SourceRef    *location,
 124                   SourceRef    *other,
 125                   gint          code,
 126                   const gchar  *format,
 127                   ...)
 128 {
 129   va_list ap;
 130 
 131   va_start (ap, format);
 132   parser_set_error_va (error, location, other, code, format, ap);
 133   va_end (ap);
 134 }
 135 
 136 typedef struct
 137 {
 138   const gchar *start;
 139   const gchar *stream;
 140   const gchar *end;
 141 
 142   const gchar *this;
 143 } TokenStream;
 144 
 145 
 146 G_GNUC_PRINTF(5, 6)
 147 static void
 148 token_stream_set_error (TokenStream  *stream,
 149                         GError      **error,
 150                         gboolean      this_token,
 151                         gint          code,
 152                         const gchar  *format,
 153                         ...)
 154 {
 155   SourceRef ref;
 156   va_list ap;
 157 
 158   ref.start = stream-&gt;this - stream-&gt;start;
 159 
 160   if (this_token)
 161     ref.end = stream-&gt;stream - stream-&gt;start;
 162   else
 163     ref.end = ref.start;
 164 
 165   va_start (ap, format);
 166   parser_set_error_va (error, &amp;ref, NULL, code, format, ap);
 167   va_end (ap);
 168 }
 169 
 170 static gboolean
 171 token_stream_prepare (TokenStream *stream)
 172 {
 173   gint brackets = 0;
 174   const gchar *end;
 175 
 176   if (stream-&gt;this != NULL)
 177     return TRUE;
 178 
 179   while (stream-&gt;stream != stream-&gt;end &amp;&amp; g_ascii_isspace (*stream-&gt;stream))
 180     stream-&gt;stream++;
 181 
 182   if (stream-&gt;stream == stream-&gt;end || *stream-&gt;stream == &#39;\0&#39;)
 183     {
 184       stream-&gt;this = stream-&gt;stream;
 185       return FALSE;
 186     }
 187 
 188   switch (stream-&gt;stream[0])
 189     {
 190     case &#39;-&#39;: case &#39;+&#39;: case &#39;.&#39;: case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;:
 191     case &#39;3&#39;: case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;: case &#39;8&#39;:
 192     case &#39;9&#39;:
 193       for (end = stream-&gt;stream; end != stream-&gt;end; end++)
 194         if (!g_ascii_isalnum (*end) &amp;&amp;
 195             *end != &#39;-&#39; &amp;&amp; *end != &#39;+&#39; &amp;&amp; *end != &#39;.&#39;)
 196           break;
 197       break;
 198 
 199     case &#39;b&#39;:
 200       if (stream-&gt;stream + 1 != stream-&gt;end &amp;&amp;
 201           (stream-&gt;stream[1] == &#39;\&#39;&#39; || stream-&gt;stream[1] == &#39;&quot;&#39;))
 202         {
 203           for (end = stream-&gt;stream + 2; end != stream-&gt;end; end++)
 204             if (*end == stream-&gt;stream[1] || *end == &#39;\0&#39; ||
 205                 (*end == &#39;\\&#39; &amp;&amp; (++end == stream-&gt;end || *end == &#39;\0&#39;)))
 206               break;
 207 
 208           if (end != stream-&gt;end &amp;&amp; *end)
 209             end++;
 210           break;
 211         }
 212 
 213       G_GNUC_FALLTHROUGH;
 214 
 215     case &#39;a&#39;: /* &#39;b&#39; */ case &#39;c&#39;: case &#39;d&#39;: case &#39;e&#39;: case &#39;f&#39;:
 216     case &#39;g&#39;: case &#39;h&#39;: case &#39;i&#39;: case &#39;j&#39;: case &#39;k&#39;: case &#39;l&#39;:
 217     case &#39;m&#39;: case &#39;n&#39;: case &#39;o&#39;: case &#39;p&#39;: case &#39;q&#39;: case &#39;r&#39;:
 218     case &#39;s&#39;: case &#39;t&#39;: case &#39;u&#39;: case &#39;v&#39;: case &#39;w&#39;: case &#39;x&#39;:
 219     case &#39;y&#39;: case &#39;z&#39;:
 220       for (end = stream-&gt;stream; end != stream-&gt;end; end++)
 221         if (!g_ascii_isalnum (*end))
 222           break;
 223       break;
 224 
 225     case &#39;\&#39;&#39;: case &#39;&quot;&#39;:
 226       for (end = stream-&gt;stream + 1; end != stream-&gt;end; end++)
 227         if (*end == stream-&gt;stream[0] || *end == &#39;\0&#39; ||
 228             (*end == &#39;\\&#39; &amp;&amp; (++end == stream-&gt;end || *end == &#39;\0&#39;)))
 229           break;
 230 
 231       if (end != stream-&gt;end &amp;&amp; *end)
 232         end++;
 233       break;
 234 
 235     case &#39;@&#39;: case &#39;%&#39;:
 236       /* stop at the first space, comma, colon or unmatched bracket.
 237        * deals nicely with cases like (%i, %i) or {%i: %i}.
 238        * Also: ] and &gt; are never in format strings.
 239        */
 240       for (end = stream-&gt;stream + 1;
 241            end != stream-&gt;end &amp;&amp; *end != &#39;\0&#39; &amp;&amp; *end != &#39;,&#39; &amp;&amp;
 242            *end != &#39;:&#39; &amp;&amp; *end != &#39;&gt;&#39; &amp;&amp; *end != &#39;]&#39; &amp;&amp; !g_ascii_isspace (*end);
 243            end++)
 244 
 245         if (*end == &#39;(&#39; || *end == &#39;{&#39;)
 246           brackets++;
 247 
 248         else if ((*end == &#39;)&#39; || *end == &#39;}&#39;) &amp;&amp; !brackets--)
 249           break;
 250 
 251       break;
 252 
 253     default:
 254       end = stream-&gt;stream + 1;
 255       break;
 256     }
 257 
 258   stream-&gt;this = stream-&gt;stream;
 259   stream-&gt;stream = end;
 260 
 261   /* We must have at least one byte in a token. */
 262   g_assert (stream-&gt;stream - stream-&gt;this &gt;= 1);
 263 
 264   return TRUE;
 265 }
 266 
 267 static void
 268 token_stream_next (TokenStream *stream)
 269 {
 270   stream-&gt;this = NULL;
 271 }
 272 
 273 static gboolean
 274 token_stream_peek (TokenStream *stream,
 275                    gchar        first_char)
 276 {
 277   if (!token_stream_prepare (stream))
 278     return FALSE;
 279 
 280   return stream-&gt;stream - stream-&gt;this &gt;= 1 &amp;&amp;
 281          stream-&gt;this[0] == first_char;
 282 }
 283 
 284 static gboolean
 285 token_stream_peek2 (TokenStream *stream,
 286                     gchar        first_char,
 287                     gchar        second_char)
 288 {
 289   if (!token_stream_prepare (stream))
 290     return FALSE;
 291 
 292   return stream-&gt;stream - stream-&gt;this &gt;= 2 &amp;&amp;
 293          stream-&gt;this[0] == first_char &amp;&amp;
 294          stream-&gt;this[1] == second_char;
 295 }
 296 
 297 static gboolean
 298 token_stream_is_keyword (TokenStream *stream)
 299 {
 300   if (!token_stream_prepare (stream))
 301     return FALSE;
 302 
 303   return stream-&gt;stream - stream-&gt;this &gt;= 2 &amp;&amp;
 304          g_ascii_isalpha (stream-&gt;this[0]) &amp;&amp;
 305          g_ascii_isalpha (stream-&gt;this[1]);
 306 }
 307 
 308 static gboolean
 309 token_stream_is_numeric (TokenStream *stream)
 310 {
 311   if (!token_stream_prepare (stream))
 312     return FALSE;
 313 
 314   return (stream-&gt;stream - stream-&gt;this &gt;= 1 &amp;&amp;
 315           (g_ascii_isdigit (stream-&gt;this[0]) ||
 316            stream-&gt;this[0] == &#39;-&#39; ||
 317            stream-&gt;this[0] == &#39;+&#39; ||
 318            stream-&gt;this[0] == &#39;.&#39;));
 319 }
 320 
 321 static gboolean
 322 token_stream_peek_string (TokenStream *stream,
 323                           const gchar *token)
 324 {
 325   gint length = strlen (token);
 326 
 327   return token_stream_prepare (stream) &amp;&amp;
 328          stream-&gt;stream - stream-&gt;this == length &amp;&amp;
 329          memcmp (stream-&gt;this, token, length) == 0;
 330 }
 331 
 332 static gboolean
 333 token_stream_consume (TokenStream *stream,
 334                       const gchar *token)
 335 {
 336   if (!token_stream_peek_string (stream, token))
 337     return FALSE;
 338 
 339   token_stream_next (stream);
 340   return TRUE;
 341 }
 342 
 343 static gboolean
 344 token_stream_require (TokenStream  *stream,
 345                       const gchar  *token,
 346                       const gchar  *purpose,
 347                       GError      **error)
 348 {
 349 
 350   if (!token_stream_consume (stream, token))
 351     {
 352       token_stream_set_error (stream, error, FALSE,
 353                               G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN,
 354                               &quot;expected &#39;%s&#39;%s&quot;, token, purpose);
 355       return FALSE;
 356     }
 357 
 358   return TRUE;
 359 }
 360 
 361 static void
 362 token_stream_assert (TokenStream *stream,
 363                      const gchar *token)
 364 {
 365   gboolean correct_token G_GNUC_UNUSED  /* when compiling with G_DISABLE_ASSERT */;
 366 
 367   correct_token = token_stream_consume (stream, token);
 368   g_assert (correct_token);
 369 }
 370 
 371 static gchar *
 372 token_stream_get (TokenStream *stream)
 373 {
 374   gchar *result;
 375 
 376   if (!token_stream_prepare (stream))
 377     return NULL;
 378 
 379   result = g_strndup (stream-&gt;this, stream-&gt;stream - stream-&gt;this);
 380 
 381   return result;
 382 }
 383 
 384 static void
 385 token_stream_start_ref (TokenStream *stream,
 386                         SourceRef   *ref)
 387 {
 388   token_stream_prepare (stream);
 389   ref-&gt;start = stream-&gt;this - stream-&gt;start;
 390 }
 391 
 392 static void
 393 token_stream_end_ref (TokenStream *stream,
 394                       SourceRef   *ref)
 395 {
 396   ref-&gt;end = stream-&gt;stream - stream-&gt;start;
 397 }
 398 
 399 static void
 400 pattern_copy (gchar       **out,
 401               const gchar **in)
 402 {
 403   gint brackets = 0;
 404 
 405   while (**in == &#39;a&#39; || **in == &#39;m&#39; || **in == &#39;M&#39;)
 406     *(*out)++ = *(*in)++;
 407 
 408   do
 409     {
 410       if (**in == &#39;(&#39; || **in == &#39;{&#39;)
 411         brackets++;
 412 
 413       else if (**in == &#39;)&#39; || **in == &#39;}&#39;)
 414         brackets--;
 415 
 416       *(*out)++ = *(*in)++;
 417     }
 418   while (brackets);
 419 }
 420 
 421 /* Returns the most general pattern that is subpattern of left and subpattern
 422  * of right, or NULL if there is no such pattern. */
 423 static gchar *
 424 pattern_coalesce (const gchar *left,
 425                   const gchar *right)
 426 {
 427   gchar *result;
 428   gchar *out;
 429 
 430   /* the length of the output is loosely bound by the sum of the input
 431    * lengths, not simply the greater of the two lengths.
 432    *
 433    *   (*(iii)) + ((iii)*) ((iii)(iii))
 434    *
 435    *      8     +    8    =  12
 436    */
 437   out = result = g_malloc (strlen (left) + strlen (right));
 438 
 439   while (*left &amp;&amp; *right)
 440     {
 441       if (*left == *right)
 442         {
 443           *out++ = *left++;
 444           right++;
 445         }
 446 
 447       else
 448         {
 449           const gchar **one = &amp;left, **the_other = &amp;right;
 450 
 451          again:
 452           if (**one == &#39;*&#39; &amp;&amp; **the_other != &#39;)&#39;)
 453             {
 454               pattern_copy (&amp;out, the_other);
 455               (*one)++;
 456             }
 457 
 458           else if (**one == &#39;M&#39; &amp;&amp; **the_other == &#39;m&#39;)
 459             {
 460               *out++ = *(*the_other)++;
 461             }
 462 
 463           else if (**one == &#39;M&#39; &amp;&amp; **the_other != &#39;m&#39; &amp;&amp; **the_other != &#39;*&#39;)
 464             {
 465               (*one)++;
 466             }
 467 
 468           else if (**one == &#39;N&#39; &amp;&amp; strchr (&quot;ynqiuxthd&quot;, **the_other))
 469             {
 470               *out++ = *(*the_other)++;
 471               (*one)++;
 472             }
 473 
 474           else if (**one == &#39;S&#39; &amp;&amp; strchr (&quot;sog&quot;, **the_other))
 475             {
 476               *out++ = *(*the_other)++;
 477               (*one)++;
 478             }
 479 
 480           else if (one == &amp;left)
 481             {
 482               one = &amp;right, the_other = &amp;left;
 483               goto again;
 484             }
 485 
 486           else
 487             break;
 488         }
 489     }
 490 
 491   if (*left || *right)
 492     {
 493       g_free (result);
 494       result = NULL;
 495     }
 496   else
 497     *out++ = &#39;\0&#39;;
 498 
 499   return result;
 500 }
 501 
 502 typedef struct _AST AST;
 503 typedef gchar *    (*get_pattern_func)    (AST                 *ast,
 504                                            GError             **error);
 505 typedef GVariant * (*get_value_func)      (AST                 *ast,
 506                                            const GVariantType  *type,
 507                                            GError             **error);
 508 typedef GVariant * (*get_base_value_func) (AST                 *ast,
 509                                            const GVariantType  *type,
 510                                            GError             **error);
 511 typedef void       (*free_func)           (AST                 *ast);
 512 
 513 typedef struct
 514 {
 515   gchar *    (* get_pattern)    (AST                 *ast,
 516                                  GError             **error);
 517   GVariant * (* get_value)      (AST                 *ast,
 518                                  const GVariantType  *type,
 519                                  GError             **error);
 520   GVariant * (* get_base_value) (AST                 *ast,
 521                                  const GVariantType  *type,
 522                                  GError             **error);
 523   void       (* free)           (AST                 *ast);
 524 } ASTClass;
 525 
 526 struct _AST
 527 {
 528   const ASTClass *class;
 529   SourceRef source_ref;
 530 };
 531 
 532 static gchar *
 533 ast_get_pattern (AST     *ast,
 534                  GError **error)
 535 {
 536   return ast-&gt;class-&gt;get_pattern (ast, error);
 537 }
 538 
 539 static GVariant *
 540 ast_get_value (AST                 *ast,
 541                const GVariantType  *type,
 542                GError             **error)
 543 {
 544   return ast-&gt;class-&gt;get_value (ast, type, error);
 545 }
 546 
 547 static void
 548 ast_free (AST *ast)
 549 {
 550   ast-&gt;class-&gt;free (ast);
 551 }
 552 
 553 G_GNUC_PRINTF(5, 6)
 554 static void
 555 ast_set_error (AST          *ast,
 556                GError      **error,
 557                AST          *other_ast,
 558                gint          code,
 559                const gchar  *format,
 560                ...)
 561 {
 562   va_list ap;
 563 
 564   va_start (ap, format);
 565   parser_set_error_va (error, &amp;ast-&gt;source_ref,
 566                        other_ast ? &amp; other_ast-&gt;source_ref : NULL,
 567                        code,
 568                        format, ap);
 569   va_end (ap);
 570 }
 571 
 572 static GVariant *
 573 ast_type_error (AST                 *ast,
 574                 const GVariantType  *type,
 575                 GError             **error)
 576 {
 577   gchar *typestr;
 578 
 579   typestr = g_variant_type_dup_string (type);
 580   ast_set_error (ast, error, NULL,
 581                  G_VARIANT_PARSE_ERROR_TYPE_ERROR,
 582                  &quot;can not parse as value of type &#39;%s&#39;&quot;,
 583                  typestr);
 584   g_free (typestr);
 585 
 586   return NULL;
 587 }
 588 
 589 static GVariant *
 590 ast_resolve (AST     *ast,
 591              GError **error)
 592 {
 593   GVariant *value;
 594   gchar *pattern;
 595   gint i, j = 0;
 596 
 597   pattern = ast_get_pattern (ast, error);
 598 
 599   if (pattern == NULL)
 600     return NULL;
 601 
 602   /* choose reasonable defaults
 603    *
 604    *   1) favour non-maybe values where possible
 605    *   2) default type for strings is &#39;s&#39;
 606    *   3) default type for integers is &#39;i&#39;
 607    */
 608   for (i = 0; pattern[i]; i++)
 609     switch (pattern[i])
 610       {
 611       case &#39;*&#39;:
 612         ast_set_error (ast, error, NULL,
 613                        G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE,
 614                        &quot;unable to infer type&quot;);
 615         g_free (pattern);
 616         return NULL;
 617 
 618       case &#39;M&#39;:
 619         break;
 620 
 621       case &#39;S&#39;:
 622         pattern[j++] = &#39;s&#39;;
 623         break;
 624 
 625       case &#39;N&#39;:
 626         pattern[j++] = &#39;i&#39;;
 627         break;
 628 
 629       default:
 630         pattern[j++] = pattern[i];
 631         break;
 632       }
 633   pattern[j++] = &#39;\0&#39;;
 634 
 635   value = ast_get_value (ast, G_VARIANT_TYPE (pattern), error);
 636   g_free (pattern);
 637 
 638   return value;
 639 }
 640 
 641 
 642 static AST *parse (TokenStream  *stream,
 643                    va_list      *app,
 644                    GError      **error);
 645 
 646 static void
 647 ast_array_append (AST  ***array,
 648                   gint   *n_items,
 649                   AST    *ast)
 650 {
 651   if ((*n_items &amp; (*n_items - 1)) == 0)
 652     *array = g_renew (AST *, *array, *n_items ? 2 ** n_items : 1);
 653 
 654   (*array)[(*n_items)++] = ast;
 655 }
 656 
 657 static void
 658 ast_array_free (AST  **array,
 659                 gint   n_items)
 660 {
 661   gint i;
 662 
 663   for (i = 0; i &lt; n_items; i++)
 664     ast_free (array[i]);
 665   g_free (array);
 666 }
 667 
 668 static gchar *
 669 ast_array_get_pattern (AST    **array,
 670                        gint     n_items,
 671                        GError **error)
 672 {
 673   gchar *pattern;
 674   gint i;
 675 
 676   /* Find the pattern which applies to all children in the array, by l-folding a
 677    * coalesce operation.
 678    */
 679   pattern = ast_get_pattern (array[0], error);
 680 
 681   if (pattern == NULL)
 682     return NULL;
 683 
 684   for (i = 1; i &lt; n_items; i++)
 685     {
 686       gchar *tmp, *merged;
 687 
 688       tmp = ast_get_pattern (array[i], error);
 689 
 690       if (tmp == NULL)
 691         {
 692           g_free (pattern);
 693           return NULL;
 694         }
 695 
 696       merged = pattern_coalesce (pattern, tmp);
 697       g_free (pattern);
 698       pattern = merged;
 699 
 700       if (merged == NULL)
 701         /* set coalescence implies pairwise coalescence (i think).
 702          * we should therefore be able to trace the failure to a single
 703          * pair of values.
 704          */
 705         {
 706           int j = 0;
 707 
 708           while (TRUE)
 709             {
 710               gchar *tmp2;
 711               gchar *m;
 712 
 713               /* if &#39;j&#39; reaches &#39;i&#39; then we didn&#39;t find the pair that failed
 714                * to coalesce. This shouldn&#39;t happen (see above), but just in
 715                * case report an error:
 716                */
 717               if (j &gt;= i)
 718                 {
 719                   ast_set_error (array[i], error, NULL,
 720                                  G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE,
 721                                  &quot;unable to find a common type&quot;);
 722                   g_free (tmp);
 723                   return NULL;
 724                 }
 725 
 726               tmp2 = ast_get_pattern (array[j], NULL);
 727               g_assert (tmp2 != NULL);
 728 
 729               m = pattern_coalesce (tmp, tmp2);
 730               g_free (tmp2);
 731               g_free (m);
 732 
 733               if (m == NULL)
 734                 {
 735                   /* we found a conflict between &#39;i&#39; and &#39;j&#39;.
 736                    *
 737                    * report the error.  note: &#39;j&#39; is first.
 738                    */
 739                   ast_set_error (array[j], error, array[i],
 740                                  G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE,
 741                                  &quot;unable to find a common type&quot;);
 742                   g_free (tmp);
 743                   return NULL;
 744                 }
 745 
 746               j++;
 747             }
 748 
 749         }
 750 
 751       g_free (tmp);
 752     }
 753 
 754   return pattern;
 755 }
 756 
 757 typedef struct
 758 {
 759   AST ast;
 760 
 761   AST *child;
 762 } Maybe;
 763 
 764 static gchar *
 765 maybe_get_pattern (AST     *ast,
 766                    GError **error)
 767 {
 768   Maybe *maybe = (Maybe *) ast;
 769 
 770   if (maybe-&gt;child != NULL)
 771     {
 772       gchar *child_pattern;
 773       gchar *pattern;
 774 
 775       child_pattern = ast_get_pattern (maybe-&gt;child, error);
 776 
 777       if (child_pattern == NULL)
 778         return NULL;
 779 
 780       pattern = g_strdup_printf (&quot;m%s&quot;, child_pattern);
 781       g_free (child_pattern);
 782 
 783       return pattern;
 784     }
 785 
 786   return g_strdup (&quot;m*&quot;);
 787 }
 788 
 789 static GVariant *
 790 maybe_get_value (AST                 *ast,
 791                  const GVariantType  *type,
 792                  GError             **error)
 793 {
 794   Maybe *maybe = (Maybe *) ast;
 795   GVariant *value;
 796 
 797   if (!g_variant_type_is_maybe (type))
 798     return ast_type_error (ast, type, error);
 799 
 800   type = g_variant_type_element (type);
 801 
 802   if (maybe-&gt;child)
 803     {
 804       value = ast_get_value (maybe-&gt;child, type, error);
 805 
 806       if (value == NULL)
 807         return NULL;
 808     }
 809   else
 810     value = NULL;
 811 
 812   return g_variant_new_maybe (type, value);
 813 }
 814 
 815 static void
 816 maybe_free (AST *ast)
 817 {
 818   Maybe *maybe = (Maybe *) ast;
 819 
 820   if (maybe-&gt;child != NULL)
 821     ast_free (maybe-&gt;child);
 822 
 823   g_slice_free (Maybe, maybe);
 824 }
 825 
 826 static AST *
 827 maybe_parse (TokenStream  *stream,
 828              va_list      *app,
 829              GError      **error)
 830 {
 831   static const ASTClass maybe_class = {
 832     maybe_get_pattern,
 833     maybe_get_value, NULL,
 834     maybe_free
 835   };
 836   AST *child = NULL;
 837   Maybe *maybe;
 838 
 839   if (token_stream_consume (stream, &quot;just&quot;))
 840     {
 841       child = parse (stream, app, error);
 842       if (child == NULL)
 843         return NULL;
 844     }
 845 
 846   else if (!token_stream_consume (stream, &quot;nothing&quot;))
 847     {
 848       token_stream_set_error (stream, error, TRUE,
 849                               G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD,
 850                               &quot;unknown keyword&quot;);
 851       return NULL;
 852     }
 853 
 854   maybe = g_slice_new (Maybe);
 855   maybe-&gt;ast.class = &amp;maybe_class;
 856   maybe-&gt;child = child;
 857 
 858   return (AST *) maybe;
 859 }
 860 
 861 static GVariant *
 862 maybe_wrapper (AST                 *ast,
 863                const GVariantType  *type,
 864                GError             **error)
 865 {
 866   const GVariantType *t;
 867   GVariant *value;
 868   int depth;
 869 
 870   for (depth = 0, t = type;
 871        g_variant_type_is_maybe (t);
 872        depth++, t = g_variant_type_element (t));
 873 
 874   value = ast-&gt;class-&gt;get_base_value (ast, t, error);
 875 
 876   if (value == NULL)
 877     return NULL;
 878 
 879   while (depth--)
 880     value = g_variant_new_maybe (NULL, value);
 881 
 882   return value;
 883 }
 884 
 885 typedef struct
 886 {
 887   AST ast;
 888 
 889   AST **children;
 890   gint n_children;
 891 } Array;
 892 
 893 static gchar *
 894 array_get_pattern (AST     *ast,
 895                    GError **error)
 896 {
 897   Array *array = (Array *) ast;
 898   gchar *pattern;
 899   gchar *result;
 900 
 901   if (array-&gt;n_children == 0)
 902     return g_strdup (&quot;Ma*&quot;);
 903 
 904   pattern = ast_array_get_pattern (array-&gt;children, array-&gt;n_children, error);
 905 
 906   if (pattern == NULL)
 907     return NULL;
 908 
 909   result = g_strdup_printf (&quot;Ma%s&quot;, pattern);
 910   g_free (pattern);
 911 
 912   return result;
 913 }
 914 
 915 static GVariant *
 916 array_get_value (AST                 *ast,
 917                  const GVariantType  *type,
 918                  GError             **error)
 919 {
 920   Array *array = (Array *) ast;
 921   const GVariantType *childtype;
 922   GVariantBuilder builder;
 923   gint i;
 924 
 925   if (!g_variant_type_is_array (type))
 926     return ast_type_error (ast, type, error);
 927 
 928   g_variant_builder_init (&amp;builder, type);
 929   childtype = g_variant_type_element (type);
 930 
 931   for (i = 0; i &lt; array-&gt;n_children; i++)
 932     {
 933       GVariant *child;
 934 
 935       if (!(child = ast_get_value (array-&gt;children[i], childtype, error)))
 936         {
 937           g_variant_builder_clear (&amp;builder);
 938           return NULL;
 939         }
 940 
 941       g_variant_builder_add_value (&amp;builder, child);
 942     }
 943 
 944   return g_variant_builder_end (&amp;builder);
 945 }
 946 
 947 static void
 948 array_free (AST *ast)
 949 {
 950   Array *array = (Array *) ast;
 951 
 952   ast_array_free (array-&gt;children, array-&gt;n_children);
 953   g_slice_free (Array, array);
 954 }
 955 
 956 static AST *
 957 array_parse (TokenStream  *stream,
 958              va_list      *app,
 959              GError      **error)
 960 {
 961   static const ASTClass array_class = {
 962     array_get_pattern,
 963     maybe_wrapper, array_get_value,
 964     array_free
 965   };
 966   gboolean need_comma = FALSE;
 967   Array *array;
 968 
 969   array = g_slice_new (Array);
 970   array-&gt;ast.class = &amp;array_class;
 971   array-&gt;children = NULL;
 972   array-&gt;n_children = 0;
 973 
 974   token_stream_assert (stream, &quot;[&quot;);
 975   while (!token_stream_consume (stream, &quot;]&quot;))
 976     {
 977       AST *child;
 978 
 979       if (need_comma &amp;&amp;
 980           !token_stream_require (stream, &quot;,&quot;,
 981                                  &quot; or &#39;]&#39; to follow array element&quot;,
 982                                  error))
 983         goto error;
 984 
 985       child = parse (stream, app, error);
 986 
 987       if (!child)
 988         goto error;
 989 
 990       ast_array_append (&amp;array-&gt;children, &amp;array-&gt;n_children, child);
 991       need_comma = TRUE;
 992     }
 993 
 994   return (AST *) array;
 995 
 996  error:
 997   ast_array_free (array-&gt;children, array-&gt;n_children);
 998   g_slice_free (Array, array);
 999 
1000   return NULL;
1001 }
1002 
1003 typedef struct
1004 {
1005   AST ast;
1006 
1007   AST **children;
1008   gint n_children;
1009 } Tuple;
1010 
1011 static gchar *
1012 tuple_get_pattern (AST     *ast,
1013                    GError **error)
1014 {
1015   Tuple *tuple = (Tuple *) ast;
1016   gchar *result = NULL;
1017   gchar **parts;
1018   gint i;
1019 
1020   parts = g_new (gchar *, tuple-&gt;n_children + 4);
1021   parts[tuple-&gt;n_children + 1] = (gchar *) &quot;)&quot;;
1022   parts[tuple-&gt;n_children + 2] = NULL;
1023   parts[0] = (gchar *) &quot;M(&quot;;
1024 
1025   for (i = 0; i &lt; tuple-&gt;n_children; i++)
1026     if (!(parts[i + 1] = ast_get_pattern (tuple-&gt;children[i], error)))
1027       break;
1028 
1029   if (i == tuple-&gt;n_children)
1030     result = g_strjoinv (&quot;&quot;, parts);
1031 
1032   /* parts[0] should not be freed */
1033   while (i)
1034     g_free (parts[i--]);
1035   g_free (parts);
1036 
1037   return result;
1038 }
1039 
1040 static GVariant *
1041 tuple_get_value (AST                 *ast,
1042                  const GVariantType  *type,
1043                  GError             **error)
1044 {
1045   Tuple *tuple = (Tuple *) ast;
1046   const GVariantType *childtype;
1047   GVariantBuilder builder;
1048   gint i;
1049 
1050   if (!g_variant_type_is_tuple (type))
1051     return ast_type_error (ast, type, error);
1052 
1053   g_variant_builder_init (&amp;builder, type);
1054   childtype = g_variant_type_first (type);
1055 
1056   for (i = 0; i &lt; tuple-&gt;n_children; i++)
1057     {
1058       GVariant *child;
1059 
1060       if (childtype == NULL)
1061         {
1062           g_variant_builder_clear (&amp;builder);
1063           return ast_type_error (ast, type, error);
1064         }
1065 
1066       if (!(child = ast_get_value (tuple-&gt;children[i], childtype, error)))
1067         {
1068           g_variant_builder_clear (&amp;builder);
1069           return FALSE;
1070         }
1071 
1072       g_variant_builder_add_value (&amp;builder, child);
1073       childtype = g_variant_type_next (childtype);
1074     }
1075 
1076   if (childtype != NULL)
1077     {
1078       g_variant_builder_clear (&amp;builder);
1079       return ast_type_error (ast, type, error);
1080     }
1081 
1082   return g_variant_builder_end (&amp;builder);
1083 }
1084 
1085 static void
1086 tuple_free (AST *ast)
1087 {
1088   Tuple *tuple = (Tuple *) ast;
1089 
1090   ast_array_free (tuple-&gt;children, tuple-&gt;n_children);
1091   g_slice_free (Tuple, tuple);
1092 }
1093 
1094 static AST *
1095 tuple_parse (TokenStream  *stream,
1096              va_list      *app,
1097              GError      **error)
1098 {
1099   static const ASTClass tuple_class = {
1100     tuple_get_pattern,
1101     maybe_wrapper, tuple_get_value,
1102     tuple_free
1103   };
1104   gboolean need_comma = FALSE;
1105   gboolean first = TRUE;
1106   Tuple *tuple;
1107 
1108   tuple = g_slice_new (Tuple);
1109   tuple-&gt;ast.class = &amp;tuple_class;
1110   tuple-&gt;children = NULL;
1111   tuple-&gt;n_children = 0;
1112 
1113   token_stream_assert (stream, &quot;(&quot;);
1114   while (!token_stream_consume (stream, &quot;)&quot;))
1115     {
1116       AST *child;
1117 
1118       if (need_comma &amp;&amp;
1119           !token_stream_require (stream, &quot;,&quot;,
1120                                  &quot; or &#39;)&#39; to follow tuple element&quot;,
1121                                  error))
1122         goto error;
1123 
1124       child = parse (stream, app, error);
1125 
1126       if (!child)
1127         goto error;
1128 
1129       ast_array_append (&amp;tuple-&gt;children, &amp;tuple-&gt;n_children, child);
1130 
1131       /* the first time, we absolutely require a comma, so grab it here
1132        * and leave need_comma = FALSE so that the code above doesn&#39;t
1133        * require a second comma.
1134        *
1135        * the second and remaining times, we set need_comma = TRUE.
1136        */
1137       if (first)
1138         {
1139           if (!token_stream_require (stream, &quot;,&quot;,
1140                                      &quot; after first tuple element&quot;, error))
1141             goto error;
1142 
1143           first = FALSE;
1144         }
1145       else
1146         need_comma = TRUE;
1147     }
1148 
1149   return (AST *) tuple;
1150 
1151  error:
1152   ast_array_free (tuple-&gt;children, tuple-&gt;n_children);
1153   g_slice_free (Tuple, tuple);
1154 
1155   return NULL;
1156 }
1157 
1158 typedef struct
1159 {
1160   AST ast;
1161 
1162   AST *value;
1163 } Variant;
1164 
1165 static gchar *
1166 variant_get_pattern (AST     *ast,
1167                      GError **error)
1168 {
1169   return g_strdup (&quot;Mv&quot;);
1170 }
1171 
1172 static GVariant *
1173 variant_get_value (AST                 *ast,
1174                    const GVariantType  *type,
1175                    GError             **error)
1176 {
1177   Variant *variant = (Variant *) ast;
1178   GVariant *child;
1179 
1180   if (!g_variant_type_equal (type, G_VARIANT_TYPE_VARIANT))
1181     return ast_type_error (ast, type, error);
1182 
1183   child = ast_resolve (variant-&gt;value, error);
1184 
1185   if (child == NULL)
1186     return NULL;
1187 
1188   return g_variant_new_variant (child);
1189 }
1190 
1191 static void
1192 variant_free (AST *ast)
1193 {
1194   Variant *variant = (Variant *) ast;
1195 
1196   ast_free (variant-&gt;value);
1197   g_slice_free (Variant, variant);
1198 }
1199 
1200 static AST *
1201 variant_parse (TokenStream  *stream,
1202                va_list      *app,
1203                GError      **error)
1204 {
1205   static const ASTClass variant_class = {
1206     variant_get_pattern,
1207     maybe_wrapper, variant_get_value,
1208     variant_free
1209   };
1210   Variant *variant;
1211   AST *value;
1212 
1213   token_stream_assert (stream, &quot;&lt;&quot;);
1214   value = parse (stream, app, error);
1215 
1216   if (!value)
1217     return NULL;
1218 
1219   if (!token_stream_require (stream, &quot;&gt;&quot;, &quot; to follow variant value&quot;, error))
1220     {
1221       ast_free (value);
1222       return NULL;
1223     }
1224 
1225   variant = g_slice_new (Variant);
1226   variant-&gt;ast.class = &amp;variant_class;
1227   variant-&gt;value = value;
1228 
1229   return (AST *) variant;
1230 }
1231 
1232 typedef struct
1233 {
1234   AST ast;
1235 
1236   AST **keys;
1237   AST **values;
1238   gint n_children;
1239 } Dictionary;
1240 
1241 static gchar *
1242 dictionary_get_pattern (AST     *ast,
1243                         GError **error)
1244 {
1245   Dictionary *dict = (Dictionary *) ast;
1246   gchar *value_pattern;
1247   gchar *key_pattern;
1248   gchar key_char;
1249   gchar *result;
1250 
1251   if (dict-&gt;n_children == 0)
1252     return g_strdup (&quot;Ma{**}&quot;);
1253 
1254   key_pattern = ast_array_get_pattern (dict-&gt;keys,
1255                                        abs (dict-&gt;n_children),
1256                                        error);
1257 
1258   if (key_pattern == NULL)
1259     return NULL;
1260 
1261   /* we can not have maybe keys */
1262   if (key_pattern[0] == &#39;M&#39;)
1263     key_char = key_pattern[1];
1264   else
1265     key_char = key_pattern[0];
1266 
1267   g_free (key_pattern);
1268 
1269   /* the basic types,
1270    * plus undetermined number type and undetermined string type.
1271    */
1272   if (!strchr (&quot;bynqiuxthdsogNS&quot;, key_char))
1273     {
1274       ast_set_error (ast, error, NULL,
1275                      G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED,
1276                      &quot;dictionary keys must have basic types&quot;);
1277       return NULL;
1278     }
1279 
1280   value_pattern = ast_get_pattern (dict-&gt;values[0], error);
1281 
1282   if (value_pattern == NULL)
1283     return NULL;
1284 
1285   result = g_strdup_printf (&quot;M%s{%c%s}&quot;,
1286                             dict-&gt;n_children &gt; 0 ? &quot;a&quot; : &quot;&quot;,
1287                             key_char, value_pattern);
1288   g_free (value_pattern);
1289 
1290   return result;
1291 }
1292 
1293 static GVariant *
1294 dictionary_get_value (AST                 *ast,
1295                       const GVariantType  *type,
1296                       GError             **error)
1297 {
1298   Dictionary *dict = (Dictionary *) ast;
1299 
1300   if (dict-&gt;n_children == -1)
1301     {
1302       const GVariantType *subtype;
1303       GVariantBuilder builder;
1304       GVariant *subvalue;
1305 
1306       if (!g_variant_type_is_dict_entry (type))
1307         return ast_type_error (ast, type, error);
1308 
1309       g_variant_builder_init (&amp;builder, type);
1310 
1311       subtype = g_variant_type_key (type);
1312       if (!(subvalue = ast_get_value (dict-&gt;keys[0], subtype, error)))
1313         {
1314           g_variant_builder_clear (&amp;builder);
1315           return NULL;
1316         }
1317       g_variant_builder_add_value (&amp;builder, subvalue);
1318 
1319       subtype = g_variant_type_value (type);
1320       if (!(subvalue = ast_get_value (dict-&gt;values[0], subtype, error)))
1321         {
1322           g_variant_builder_clear (&amp;builder);
1323           return NULL;
1324         }
1325       g_variant_builder_add_value (&amp;builder, subvalue);
1326 
1327       return g_variant_builder_end (&amp;builder);
1328     }
1329   else
1330     {
1331       const GVariantType *entry, *key, *val;
1332       GVariantBuilder builder;
1333       gint i;
1334 
1335       if (!g_variant_type_is_subtype_of (type, G_VARIANT_TYPE_DICTIONARY))
1336         return ast_type_error (ast, type, error);
1337 
1338       entry = g_variant_type_element (type);
1339       key = g_variant_type_key (entry);
1340       val = g_variant_type_value (entry);
1341 
1342       g_variant_builder_init (&amp;builder, type);
1343 
1344       for (i = 0; i &lt; dict-&gt;n_children; i++)
1345         {
1346           GVariant *subvalue;
1347 
1348           g_variant_builder_open (&amp;builder, entry);
1349 
1350           if (!(subvalue = ast_get_value (dict-&gt;keys[i], key, error)))
1351             {
1352               g_variant_builder_clear (&amp;builder);
1353               return NULL;
1354             }
1355           g_variant_builder_add_value (&amp;builder, subvalue);
1356 
1357           if (!(subvalue = ast_get_value (dict-&gt;values[i], val, error)))
1358             {
1359               g_variant_builder_clear (&amp;builder);
1360               return NULL;
1361             }
1362           g_variant_builder_add_value (&amp;builder, subvalue);
1363           g_variant_builder_close (&amp;builder);
1364         }
1365 
1366       return g_variant_builder_end (&amp;builder);
1367     }
1368 }
1369 
1370 static void
1371 dictionary_free (AST *ast)
1372 {
1373   Dictionary *dict = (Dictionary *) ast;
1374   gint n_children;
1375 
1376   if (dict-&gt;n_children &gt; -1)
1377     n_children = dict-&gt;n_children;
1378   else
1379     n_children = 1;
1380 
1381   ast_array_free (dict-&gt;keys, n_children);
1382   ast_array_free (dict-&gt;values, n_children);
1383   g_slice_free (Dictionary, dict);
1384 }
1385 
1386 static AST *
1387 dictionary_parse (TokenStream  *stream,
1388                   va_list      *app,
1389                   GError      **error)
1390 {
1391   static const ASTClass dictionary_class = {
1392     dictionary_get_pattern,
1393     maybe_wrapper, dictionary_get_value,
1394     dictionary_free
1395   };
1396   gint n_keys, n_values;
1397   gboolean only_one;
1398   Dictionary *dict;
1399   AST *first;
1400 
1401   dict = g_slice_new (Dictionary);
1402   dict-&gt;ast.class = &amp;dictionary_class;
1403   dict-&gt;keys = NULL;
1404   dict-&gt;values = NULL;
1405   n_keys = n_values = 0;
1406 
1407   token_stream_assert (stream, &quot;{&quot;);
1408 
1409   if (token_stream_consume (stream, &quot;}&quot;))
1410     {
1411       dict-&gt;n_children = 0;
1412       return (AST *) dict;
1413     }
1414 
1415   if ((first = parse (stream, app, error)) == NULL)
1416     goto error;
1417 
1418   ast_array_append (&amp;dict-&gt;keys, &amp;n_keys, first);
1419 
1420   only_one = token_stream_consume (stream, &quot;,&quot;);
1421   if (!only_one &amp;&amp;
1422       !token_stream_require (stream, &quot;:&quot;,
1423                              &quot; or &#39;,&#39; to follow dictionary entry key&quot;,
1424                              error))
1425     goto error;
1426 
1427   if ((first = parse (stream, app, error)) == NULL)
1428     goto error;
1429 
1430   ast_array_append (&amp;dict-&gt;values, &amp;n_values, first);
1431 
1432   if (only_one)
1433     {
1434       if (!token_stream_require (stream, &quot;}&quot;, &quot; at end of dictionary entry&quot;,
1435                                  error))
1436         goto error;
1437 
1438       g_assert (n_keys == 1 &amp;&amp; n_values == 1);
1439       dict-&gt;n_children = -1;
1440 
1441       return (AST *) dict;
1442     }
1443 
1444   while (!token_stream_consume (stream, &quot;}&quot;))
1445     {
1446       AST *child;
1447 
1448       if (!token_stream_require (stream, &quot;,&quot;,
1449                                  &quot; or &#39;}&#39; to follow dictionary entry&quot;, error))
1450         goto error;
1451 
1452       child = parse (stream, app, error);
1453 
1454       if (!child)
1455         goto error;
1456 
1457       ast_array_append (&amp;dict-&gt;keys, &amp;n_keys, child);
1458 
1459       if (!token_stream_require (stream, &quot;:&quot;,
1460                                  &quot; to follow dictionary entry key&quot;, error))
1461         goto error;
1462 
1463       child = parse (stream, app, error);
1464 
1465       if (!child)
1466         goto error;
1467 
1468       ast_array_append (&amp;dict-&gt;values, &amp;n_values, child);
1469     }
1470 
1471   g_assert (n_keys == n_values);
1472   dict-&gt;n_children = n_keys;
1473 
1474   return (AST *) dict;
1475 
1476  error:
1477   ast_array_free (dict-&gt;keys, n_keys);
1478   ast_array_free (dict-&gt;values, n_values);
1479   g_slice_free (Dictionary, dict);
1480 
1481   return NULL;
1482 }
1483 
1484 typedef struct
1485 {
1486   AST ast;
1487   gchar *string;
1488 } String;
1489 
1490 static gchar *
1491 string_get_pattern (AST     *ast,
1492                     GError **error)
1493 {
1494   return g_strdup (&quot;MS&quot;);
1495 }
1496 
1497 static GVariant *
1498 string_get_value (AST                 *ast,
1499                   const GVariantType  *type,
1500                   GError             **error)
1501 {
1502   String *string = (String *) ast;
1503 
1504   if (g_variant_type_equal (type, G_VARIANT_TYPE_STRING))
1505     return g_variant_new_string (string-&gt;string);
1506 
1507   else if (g_variant_type_equal (type, G_VARIANT_TYPE_OBJECT_PATH))
1508     {
1509       if (!g_variant_is_object_path (string-&gt;string))
1510         {
1511           ast_set_error (ast, error, NULL,
1512                          G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH,
1513                          &quot;not a valid object path&quot;);
1514           return NULL;
1515         }
1516 
1517       return g_variant_new_object_path (string-&gt;string);
1518     }
1519 
1520   else if (g_variant_type_equal (type, G_VARIANT_TYPE_SIGNATURE))
1521     {
1522       if (!g_variant_is_signature (string-&gt;string))
1523         {
1524           ast_set_error (ast, error, NULL,
1525                          G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE,
1526                          &quot;not a valid signature&quot;);
1527           return NULL;
1528         }
1529 
1530       return g_variant_new_signature (string-&gt;string);
1531     }
1532 
1533   else
1534     return ast_type_error (ast, type, error);
1535 }
1536 
1537 static void
1538 string_free (AST *ast)
1539 {
1540   String *string = (String *) ast;
1541 
1542   g_free (string-&gt;string);
1543   g_slice_free (String, string);
1544 }
1545 
1546 /* Accepts exactly @length hexadecimal digits. No leading sign or `0x`/`0X` prefix allowed.
1547  * No leading/trailing space allowed. */
1548 static gboolean
1549 unicode_unescape (const gchar  *src,
1550                   gint         *src_ofs,
1551                   gchar        *dest,
1552                   gint         *dest_ofs,
1553                   gsize         length,
1554                   SourceRef    *ref,
1555                   GError      **error)
1556 {
1557   gchar buffer[9];
1558   guint64 value = 0;
1559   gchar *end;
1560   gsize n_valid_chars;
1561 
1562   (*src_ofs)++;
1563 
1564   g_assert (length &lt; sizeof (buffer));
1565   strncpy (buffer, src + *src_ofs, length);
1566   buffer[length] = &#39;\0&#39;;
1567 
1568   for (n_valid_chars = 0; n_valid_chars &lt; length; n_valid_chars++)
1569     if (!g_ascii_isxdigit (buffer[n_valid_chars]))
1570       break;
1571 
1572   if (n_valid_chars == length)
1573     value = g_ascii_strtoull (buffer, &amp;end, 0x10);
1574 
1575   if (value == 0 || end != buffer + length)
1576     {
1577       SourceRef escape_ref;
1578 
1579       escape_ref = *ref;
1580       escape_ref.start += *src_ofs;
1581       escape_ref.end = escape_ref.start + n_valid_chars;
1582 
1583       parser_set_error (error, &amp;escape_ref, NULL,
1584                         G_VARIANT_PARSE_ERROR_INVALID_CHARACTER,
1585                         &quot;invalid %&quot; G_GSIZE_FORMAT &quot;-character unicode escape&quot;, length);
1586       return FALSE;
1587     }
1588 
1589   g_assert (value &lt;= G_MAXUINT32);
1590 
1591   *dest_ofs += g_unichar_to_utf8 (value, dest + *dest_ofs);
1592   *src_ofs += length;
1593 
1594   return TRUE;
1595 }
1596 
1597 static AST *
1598 string_parse (TokenStream  *stream,
1599               va_list      *app,
1600               GError      **error)
1601 {
1602   static const ASTClass string_class = {
1603     string_get_pattern,
1604     maybe_wrapper, string_get_value,
1605     string_free
1606   };
1607   String *string;
1608   SourceRef ref;
1609   gchar *token;
1610   gsize length;
1611   gchar quote;
1612   gchar *str;
1613   gint i, j;
1614 
1615   token_stream_start_ref (stream, &amp;ref);
1616   token = token_stream_get (stream);
1617   token_stream_end_ref (stream, &amp;ref);
1618   length = strlen (token);
1619   quote = token[0];
1620 
1621   str = g_malloc (length);
1622   g_assert (quote == &#39;&quot;&#39; || quote == &#39;\&#39;&#39;);
1623   j = 0;
1624   i = 1;
1625   while (token[i] != quote)
1626     switch (token[i])
1627       {
1628       case &#39;\0&#39;:
1629         parser_set_error (error, &amp;ref, NULL,
1630                           G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT,
1631                           &quot;unterminated string constant&quot;);
1632         g_free (token);
1633         g_free (str);
1634         return NULL;
1635 
1636       case &#39;\\&#39;:
1637         switch (token[++i])
1638           {
1639           case &#39;\0&#39;:
1640             parser_set_error (error, &amp;ref, NULL,
1641                               G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT,
1642                               &quot;unterminated string constant&quot;);
1643             g_free (token);
1644             g_free (str);
1645             return NULL;
1646 
1647           case &#39;u&#39;:
1648             if (!unicode_unescape (token, &amp;i, str, &amp;j, 4, &amp;ref, error))
1649               {
1650                 g_free (token);
1651                 g_free (str);
1652                 return NULL;
1653               }
1654             continue;
1655 
1656           case &#39;U&#39;:
1657             if (!unicode_unescape (token, &amp;i, str, &amp;j, 8, &amp;ref, error))
1658               {
1659                 g_free (token);
1660                 g_free (str);
1661                 return NULL;
1662               }
1663             continue;
1664 
1665           case &#39;a&#39;: str[j++] = &#39;\a&#39;; i++; continue;
1666           case &#39;b&#39;: str[j++] = &#39;\b&#39;; i++; continue;
1667           case &#39;f&#39;: str[j++] = &#39;\f&#39;; i++; continue;
1668           case &#39;n&#39;: str[j++] = &#39;\n&#39;; i++; continue;
1669           case &#39;r&#39;: str[j++] = &#39;\r&#39;; i++; continue;
1670           case &#39;t&#39;: str[j++] = &#39;\t&#39;; i++; continue;
1671           case &#39;v&#39;: str[j++] = &#39;\v&#39;; i++; continue;
1672           case &#39;\n&#39;: i++; continue;
1673           }
1674 
1675         G_GNUC_FALLTHROUGH;
1676 
1677       default:
1678         str[j++] = token[i++];
1679       }
1680   str[j++] = &#39;\0&#39;;
1681   g_free (token);
1682 
1683   string = g_slice_new (String);
1684   string-&gt;ast.class = &amp;string_class;
1685   string-&gt;string = str;
1686 
1687   token_stream_next (stream);
1688 
1689   return (AST *) string;
1690 }
1691 
1692 typedef struct
1693 {
1694   AST ast;
1695   gchar *string;
1696 } ByteString;
1697 
1698 static gchar *
1699 bytestring_get_pattern (AST     *ast,
1700                         GError **error)
1701 {
1702   return g_strdup (&quot;May&quot;);
1703 }
1704 
1705 static GVariant *
1706 bytestring_get_value (AST                 *ast,
1707                       const GVariantType  *type,
1708                       GError             **error)
1709 {
1710   ByteString *string = (ByteString *) ast;
1711 
1712   if (!g_variant_type_equal (type, G_VARIANT_TYPE_BYTESTRING))
1713     return ast_type_error (ast, type, error);
1714 
1715   return g_variant_new_bytestring (string-&gt;string);
1716 }
1717 
1718 static void
1719 bytestring_free (AST *ast)
1720 {
1721   ByteString *string = (ByteString *) ast;
1722 
1723   g_free (string-&gt;string);
1724   g_slice_free (ByteString, string);
1725 }
1726 
1727 static AST *
1728 bytestring_parse (TokenStream  *stream,
1729                   va_list      *app,
1730                   GError      **error)
1731 {
1732   static const ASTClass bytestring_class = {
1733     bytestring_get_pattern,
1734     maybe_wrapper, bytestring_get_value,
1735     bytestring_free
1736   };
1737   ByteString *string;
1738   SourceRef ref;
1739   gchar *token;
1740   gsize length;
1741   gchar quote;
1742   gchar *str;
1743   gint i, j;
1744 
1745   token_stream_start_ref (stream, &amp;ref);
1746   token = token_stream_get (stream);
1747   token_stream_end_ref (stream, &amp;ref);
1748   g_assert (token[0] == &#39;b&#39;);
1749   length = strlen (token);
1750   quote = token[1];
1751 
1752   str = g_malloc (length);
1753   g_assert (quote == &#39;&quot;&#39; || quote == &#39;\&#39;&#39;);
1754   j = 0;
1755   i = 2;
1756   while (token[i] != quote)
1757     switch (token[i])
1758       {
1759       case &#39;\0&#39;:
1760         parser_set_error (error, &amp;ref, NULL,
1761                           G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT,
1762                           &quot;unterminated string constant&quot;);
1763         g_free (str);
1764         g_free (token);
1765         return NULL;
1766 
1767       case &#39;\\&#39;:
1768         switch (token[++i])
1769           {
1770           case &#39;\0&#39;:
1771             parser_set_error (error, &amp;ref, NULL,
1772                               G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT,
1773                               &quot;unterminated string constant&quot;);
1774             g_free (str);
1775             g_free (token);
1776             return NULL;
1777 
1778           case &#39;0&#39;: case &#39;1&#39;: case &#39;2&#39;: case &#39;3&#39;:
1779           case &#39;4&#39;: case &#39;5&#39;: case &#39;6&#39;: case &#39;7&#39;:
1780             {
1781               /* up to 3 characters */
1782               guchar val = token[i++] - &#39;0&#39;;
1783 
1784               if (&#39;0&#39; &lt;= token[i] &amp;&amp; token[i] &lt; &#39;8&#39;)
1785                 val = (val &lt;&lt; 3) | (token[i++] - &#39;0&#39;);
1786 
1787               if (&#39;0&#39; &lt;= token[i] &amp;&amp; token[i] &lt; &#39;8&#39;)
1788                 val = (val &lt;&lt; 3) | (token[i++] - &#39;0&#39;);
1789 
1790               str[j++] = val;
1791             }
1792             continue;
1793 
1794           case &#39;a&#39;: str[j++] = &#39;\a&#39;; i++; continue;
1795           case &#39;b&#39;: str[j++] = &#39;\b&#39;; i++; continue;
1796           case &#39;f&#39;: str[j++] = &#39;\f&#39;; i++; continue;
1797           case &#39;n&#39;: str[j++] = &#39;\n&#39;; i++; continue;
1798           case &#39;r&#39;: str[j++] = &#39;\r&#39;; i++; continue;
1799           case &#39;t&#39;: str[j++] = &#39;\t&#39;; i++; continue;
1800           case &#39;v&#39;: str[j++] = &#39;\v&#39;; i++; continue;
1801           case &#39;\n&#39;: i++; continue;
1802           }
1803 
1804         G_GNUC_FALLTHROUGH;
1805 
1806       default:
1807         str[j++] = token[i++];
1808       }
1809   str[j++] = &#39;\0&#39;;
1810   g_free (token);
1811 
1812   string = g_slice_new (ByteString);
1813   string-&gt;ast.class = &amp;bytestring_class;
1814   string-&gt;string = str;
1815 
1816   token_stream_next (stream);
1817 
1818   return (AST *) string;
1819 }
1820 
1821 typedef struct
1822 {
1823   AST ast;
1824 
1825   gchar *token;
1826 } Number;
1827 
1828 static gchar *
1829 number_get_pattern (AST     *ast,
1830                     GError **error)
1831 {
1832   Number *number = (Number *) ast;
1833 
1834   if (strchr (number-&gt;token, &#39;.&#39;) ||
1835       (!g_str_has_prefix (number-&gt;token, &quot;0x&quot;) &amp;&amp; strchr (number-&gt;token, &#39;e&#39;)) ||
1836       strstr (number-&gt;token, &quot;inf&quot;) ||
1837       strstr (number-&gt;token, &quot;nan&quot;))
1838     return g_strdup (&quot;Md&quot;);
1839 
1840   return g_strdup (&quot;MN&quot;);
1841 }
1842 
1843 static GVariant *
1844 number_overflow (AST                 *ast,
1845                  const GVariantType  *type,
1846                  GError             **error)
1847 {
1848   ast_set_error (ast, error, NULL,
1849                  G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE,
1850                  &quot;number out of range for type &#39;%c&#39;&quot;,
1851                  g_variant_type_peek_string (type)[0]);
1852   return NULL;
1853 }
1854 
1855 static GVariant *
1856 number_get_value (AST                 *ast,
1857                   const GVariantType  *type,
1858                   GError             **error)
1859 {
1860   Number *number = (Number *) ast;
1861   const gchar *token;
1862   gboolean negative;
1863   gboolean floating;
1864   guint64 abs_val;
1865   gdouble dbl_val;
1866   gchar *end;
1867 
1868   token = number-&gt;token;
1869 
1870   if (g_variant_type_equal (type, G_VARIANT_TYPE_DOUBLE))
1871     {
1872       floating = TRUE;
1873 
1874       errno = 0;
1875       dbl_val = g_ascii_strtod (token, &amp;end);
1876       if (dbl_val != 0.0 &amp;&amp; errno == ERANGE)
1877         {
1878           ast_set_error (ast, error, NULL,
1879                          G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG,
1880                          &quot;number too big for any type&quot;);
1881           return NULL;
1882         }
1883 
1884       /* silence uninitialised warnings... */
1885       negative = FALSE;
1886       abs_val = 0;
1887     }
1888   else
1889     {
1890       floating = FALSE;
1891       negative = token[0] == &#39;-&#39;;
1892       if (token[0] == &#39;-&#39;)
1893         token++;
1894 
1895       errno = 0;
1896       abs_val = g_ascii_strtoull (token, &amp;end, 0);
1897       if (abs_val == G_MAXUINT64 &amp;&amp; errno == ERANGE)
1898         {
1899           ast_set_error (ast, error, NULL,
1900                          G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG,
1901                          &quot;integer too big for any type&quot;);
1902           return NULL;
1903         }
1904 
1905       if (abs_val == 0)
1906         negative = FALSE;
1907 
1908       /* silence uninitialised warning... */
1909       dbl_val = 0.0;
1910     }
1911 
1912   if (*end != &#39;\0&#39;)
1913     {
1914       SourceRef ref;
1915 
1916       ref = ast-&gt;source_ref;
1917       ref.start += end - number-&gt;token;
1918       ref.end = ref.start + 1;
1919 
1920       parser_set_error (error, &amp;ref, NULL,
1921                         G_VARIANT_PARSE_ERROR_INVALID_CHARACTER,
1922                         &quot;invalid character in number&quot;);
1923       return NULL;
1924      }
1925 
1926   if (floating)
1927     return g_variant_new_double (dbl_val);
1928 
1929   switch (*g_variant_type_peek_string (type))
1930     {
1931     case &#39;y&#39;:
1932       if (negative || abs_val &gt; G_MAXUINT8)
1933         return number_overflow (ast, type, error);
1934       return g_variant_new_byte (abs_val);
1935 
1936     case &#39;n&#39;:
1937       if (abs_val - negative &gt; G_MAXINT16)
1938         return number_overflow (ast, type, error);
1939       if (negative &amp;&amp; abs_val &gt; G_MAXINT16)
1940         return g_variant_new_int16 (G_MININT16);
1941       return g_variant_new_int16 (negative ?
1942                                   -((gint16) abs_val) : ((gint16) abs_val));
1943 
1944     case &#39;q&#39;:
1945       if (negative || abs_val &gt; G_MAXUINT16)
1946         return number_overflow (ast, type, error);
1947       return g_variant_new_uint16 (abs_val);
1948 
1949     case &#39;i&#39;:
1950       if (abs_val - negative &gt; G_MAXINT32)
1951         return number_overflow (ast, type, error);
1952       if (negative &amp;&amp; abs_val &gt; G_MAXINT32)
1953         return g_variant_new_int32 (G_MININT32);
1954       return g_variant_new_int32 (negative ?
1955                                   -((gint32) abs_val) : ((gint32) abs_val));
1956 
1957     case &#39;u&#39;:
1958       if (negative || abs_val &gt; G_MAXUINT32)
1959         return number_overflow (ast, type, error);
1960       return g_variant_new_uint32 (abs_val);
1961 
1962     case &#39;x&#39;:
1963       if (abs_val - negative &gt; G_MAXINT64)
1964         return number_overflow (ast, type, error);
1965       if (negative &amp;&amp; abs_val &gt; G_MAXINT64)
1966         return g_variant_new_int64 (G_MININT64);
1967       return g_variant_new_int64 (negative ?
1968                                   -((gint64) abs_val) : ((gint64) abs_val));
1969 
1970     case &#39;t&#39;:
1971       if (negative)
1972         return number_overflow (ast, type, error);
1973       return g_variant_new_uint64 (abs_val);
1974 
1975     case &#39;h&#39;:
1976       if (abs_val - negative &gt; G_MAXINT32)
1977         return number_overflow (ast, type, error);
1978       if (negative &amp;&amp; abs_val &gt; G_MAXINT32)
1979         return g_variant_new_handle (G_MININT32);
1980       return g_variant_new_handle (negative ?
1981                                    -((gint32) abs_val) : ((gint32) abs_val));
1982 
1983     default:
1984       return ast_type_error (ast, type, error);
1985     }
1986 }
1987 
1988 static void
1989 number_free (AST *ast)
1990 {
1991   Number *number = (Number *) ast;
1992 
1993   g_free (number-&gt;token);
1994   g_slice_free (Number, number);
1995 }
1996 
1997 static AST *
1998 number_parse (TokenStream  *stream,
1999               va_list      *app,
2000               GError      **error)
2001 {
2002   static const ASTClass number_class = {
2003     number_get_pattern,
2004     maybe_wrapper, number_get_value,
2005     number_free
2006   };
2007   Number *number;
2008 
2009   number = g_slice_new (Number);
2010   number-&gt;ast.class = &amp;number_class;
2011   number-&gt;token = token_stream_get (stream);
2012   token_stream_next (stream);
2013 
2014   return (AST *) number;
2015 }
2016 
2017 typedef struct
2018 {
2019   AST ast;
2020   gboolean value;
2021 } Boolean;
2022 
2023 static gchar *
2024 boolean_get_pattern (AST     *ast,
2025                      GError **error)
2026 {
2027   return g_strdup (&quot;Mb&quot;);
2028 }
2029 
2030 static GVariant *
2031 boolean_get_value (AST                 *ast,
2032                    const GVariantType  *type,
2033                    GError             **error)
2034 {
2035   Boolean *boolean = (Boolean *) ast;
2036 
2037   if (!g_variant_type_equal (type, G_VARIANT_TYPE_BOOLEAN))
2038     return ast_type_error (ast, type, error);
2039 
2040   return g_variant_new_boolean (boolean-&gt;value);
2041 }
2042 
2043 static void
2044 boolean_free (AST *ast)
2045 {
2046   Boolean *boolean = (Boolean *) ast;
2047 
2048   g_slice_free (Boolean, boolean);
2049 }
2050 
2051 static AST *
2052 boolean_new (gboolean value)
2053 {
2054   static const ASTClass boolean_class = {
2055     boolean_get_pattern,
2056     maybe_wrapper, boolean_get_value,
2057     boolean_free
2058   };
2059   Boolean *boolean;
2060 
2061   boolean = g_slice_new (Boolean);
2062   boolean-&gt;ast.class = &amp;boolean_class;
2063   boolean-&gt;value = value;
2064 
2065   return (AST *) boolean;
2066 }
2067 
2068 typedef struct
2069 {
2070   AST ast;
2071 
2072   GVariant *value;
2073 } Positional;
2074 
2075 static gchar *
2076 positional_get_pattern (AST     *ast,
2077                         GError **error)
2078 {
2079   Positional *positional = (Positional *) ast;
2080 
2081   return g_strdup (g_variant_get_type_string (positional-&gt;value));
2082 }
2083 
2084 static GVariant *
2085 positional_get_value (AST                 *ast,
2086                       const GVariantType  *type,
2087                       GError             **error)
2088 {
2089   Positional *positional = (Positional *) ast;
2090   GVariant *value;
2091 
2092   g_assert (positional-&gt;value != NULL);
2093 
2094   if G_UNLIKELY (!g_variant_is_of_type (positional-&gt;value, type))
2095     return ast_type_error (ast, type, error);
2096 
2097   /* NOTE: if _get is called more than once then
2098    * things get messed up with respect to floating refs.
2099    *
2100    * fortunately, this function should only ever get called once.
2101    */
2102   g_assert (positional-&gt;value != NULL);
2103   value = positional-&gt;value;
2104   positional-&gt;value = NULL;
2105 
2106   return value;
2107 }
2108 
2109 static void
2110 positional_free (AST *ast)
2111 {
2112   Positional *positional = (Positional *) ast;
2113 
2114   /* if positional-&gt;value is set, just leave it.
2115    * memory management doesn&#39;t matter in case of programmer error.
2116    */
2117   g_slice_free (Positional, positional);
2118 }
2119 
2120 static AST *
2121 positional_parse (TokenStream  *stream,
2122                   va_list      *app,
2123                   GError      **error)
2124 {
2125   static const ASTClass positional_class = {
2126     positional_get_pattern,
2127     positional_get_value, NULL,
2128     positional_free
2129   };
2130   Positional *positional;
2131   const gchar *endptr;
2132   gchar *token;
2133 
2134   token = token_stream_get (stream);
2135   g_assert (token[0] == &#39;%&#39;);
2136 
2137   positional = g_slice_new (Positional);
2138   positional-&gt;ast.class = &amp;positional_class;
2139   positional-&gt;value = g_variant_new_va (token + 1, &amp;endptr, app);
2140 
2141   if (*endptr || positional-&gt;value == NULL)
2142     {
2143       token_stream_set_error (stream, error, TRUE,
2144                               G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING,
2145                               &quot;invalid GVariant format string&quot;);
2146       /* memory management doesn&#39;t matter in case of programmer error. */
2147       return NULL;
2148     }
2149 
2150   token_stream_next (stream);
2151   g_free (token);
2152 
2153   return (AST *) positional;
2154 }
2155 
2156 typedef struct
2157 {
2158   AST ast;
2159 
2160   GVariantType *type;
2161   AST *child;
2162 } TypeDecl;
2163 
2164 static gchar *
2165 typedecl_get_pattern (AST     *ast,
2166                       GError **error)
2167 {
2168   TypeDecl *decl = (TypeDecl *) ast;
2169 
2170   return g_variant_type_dup_string (decl-&gt;type);
2171 }
2172 
2173 static GVariant *
2174 typedecl_get_value (AST                 *ast,
2175                     const GVariantType  *type,
2176                     GError             **error)
2177 {
2178   TypeDecl *decl = (TypeDecl *) ast;
2179 
2180   return ast_get_value (decl-&gt;child, type, error);
2181 }
2182 
2183 static void
2184 typedecl_free (AST *ast)
2185 {
2186   TypeDecl *decl = (TypeDecl *) ast;
2187 
2188   ast_free (decl-&gt;child);
2189   g_variant_type_free (decl-&gt;type);
2190   g_slice_free (TypeDecl, decl);
2191 }
2192 
2193 static AST *
2194 typedecl_parse (TokenStream  *stream,
2195                 va_list      *app,
2196                 GError      **error)
2197 {
2198   static const ASTClass typedecl_class = {
2199     typedecl_get_pattern,
2200     typedecl_get_value, NULL,
2201     typedecl_free
2202   };
2203   GVariantType *type;
2204   TypeDecl *decl;
2205   AST *child;
2206 
2207   if (token_stream_peek (stream, &#39;@&#39;))
2208     {
2209       gchar *token;
2210 
2211       token = token_stream_get (stream);
2212 
2213       if (!g_variant_type_string_is_valid (token + 1))
2214         {
2215           token_stream_set_error (stream, error, TRUE,
2216                                   G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING,
2217                                   &quot;invalid type declaration&quot;);
2218           g_free (token);
2219 
2220           return NULL;
2221         }
2222 
2223       type = g_variant_type_new (token + 1);
2224 
2225       if (!g_variant_type_is_definite (type))
2226         {
2227           token_stream_set_error (stream, error, TRUE,
2228                                   G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED,
2229                                   &quot;type declarations must be definite&quot;);
2230           g_variant_type_free (type);
2231           g_free (token);
2232 
2233           return NULL;
2234         }
2235 
2236       token_stream_next (stream);
2237       g_free (token);
2238     }
2239   else
2240     {
2241       if (token_stream_consume (stream, &quot;boolean&quot;))
2242         type = g_variant_type_copy (G_VARIANT_TYPE_BOOLEAN);
2243 
2244       else if (token_stream_consume (stream, &quot;byte&quot;))
2245         type = g_variant_type_copy (G_VARIANT_TYPE_BYTE);
2246 
2247       else if (token_stream_consume (stream, &quot;int16&quot;))
2248         type = g_variant_type_copy (G_VARIANT_TYPE_INT16);
2249 
2250       else if (token_stream_consume (stream, &quot;uint16&quot;))
2251         type = g_variant_type_copy (G_VARIANT_TYPE_UINT16);
2252 
2253       else if (token_stream_consume (stream, &quot;int32&quot;))
2254         type = g_variant_type_copy (G_VARIANT_TYPE_INT32);
2255 
2256       else if (token_stream_consume (stream, &quot;handle&quot;))
2257         type = g_variant_type_copy (G_VARIANT_TYPE_HANDLE);
2258 
2259       else if (token_stream_consume (stream, &quot;uint32&quot;))
2260         type = g_variant_type_copy (G_VARIANT_TYPE_UINT32);
2261 
2262       else if (token_stream_consume (stream, &quot;int64&quot;))
2263         type = g_variant_type_copy (G_VARIANT_TYPE_INT64);
2264 
2265       else if (token_stream_consume (stream, &quot;uint64&quot;))
2266         type = g_variant_type_copy (G_VARIANT_TYPE_UINT64);
2267 
2268       else if (token_stream_consume (stream, &quot;double&quot;))
2269         type = g_variant_type_copy (G_VARIANT_TYPE_DOUBLE);
2270 
2271       else if (token_stream_consume (stream, &quot;string&quot;))
2272         type = g_variant_type_copy (G_VARIANT_TYPE_STRING);
2273 
2274       else if (token_stream_consume (stream, &quot;objectpath&quot;))
2275         type = g_variant_type_copy (G_VARIANT_TYPE_OBJECT_PATH);
2276 
2277       else if (token_stream_consume (stream, &quot;signature&quot;))
2278         type = g_variant_type_copy (G_VARIANT_TYPE_SIGNATURE);
2279 
2280       else
2281         {
2282           token_stream_set_error (stream, error, TRUE,
2283                                   G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD,
2284                                   &quot;unknown keyword&quot;);
2285           return NULL;
2286         }
2287     }
2288 
2289   if ((child = parse (stream, app, error)) == NULL)
2290     {
2291       g_variant_type_free (type);
2292       return NULL;
2293     }
2294 
2295   decl = g_slice_new (TypeDecl);
2296   decl-&gt;ast.class = &amp;typedecl_class;
2297   decl-&gt;type = type;
2298   decl-&gt;child = child;
2299 
2300   return (AST *) decl;
2301 }
2302 
2303 static AST *
2304 parse (TokenStream  *stream,
2305        va_list      *app,
2306        GError      **error)
2307 {
2308   SourceRef source_ref;
2309   AST *result;
2310 
2311   token_stream_prepare (stream);
2312   token_stream_start_ref (stream, &amp;source_ref);
2313 
2314   if (token_stream_peek (stream, &#39;[&#39;))
2315     result = array_parse (stream, app, error);
2316 
2317   else if (token_stream_peek (stream, &#39;(&#39;))
2318     result = tuple_parse (stream, app, error);
2319 
2320   else if (token_stream_peek (stream, &#39;&lt;&#39;))
2321     result = variant_parse (stream, app, error);
2322 
2323   else if (token_stream_peek (stream, &#39;{&#39;))
2324     result = dictionary_parse (stream, app, error);
2325 
2326   else if (app &amp;&amp; token_stream_peek (stream, &#39;%&#39;))
2327     result = positional_parse (stream, app, error);
2328 
2329   else if (token_stream_consume (stream, &quot;true&quot;))
2330     result = boolean_new (TRUE);
2331 
2332   else if (token_stream_consume (stream, &quot;false&quot;))
2333     result = boolean_new (FALSE);
2334 
2335   else if (token_stream_is_numeric (stream) ||
2336            token_stream_peek_string (stream, &quot;inf&quot;) ||
2337            token_stream_peek_string (stream, &quot;nan&quot;))
2338     result = number_parse (stream, app, error);
2339 
2340   else if (token_stream_peek (stream, &#39;n&#39;) ||
2341            token_stream_peek (stream, &#39;j&#39;))
2342     result = maybe_parse (stream, app, error);
2343 
2344   else if (token_stream_peek (stream, &#39;@&#39;) ||
2345            token_stream_is_keyword (stream))
2346     result = typedecl_parse (stream, app, error);
2347 
2348   else if (token_stream_peek (stream, &#39;\&#39;&#39;) ||
2349            token_stream_peek (stream, &#39;&quot;&#39;))
2350     result = string_parse (stream, app, error);
2351 
2352   else if (token_stream_peek2 (stream, &#39;b&#39;, &#39;\&#39;&#39;) ||
2353            token_stream_peek2 (stream, &#39;b&#39;, &#39;&quot;&#39;))
2354     result = bytestring_parse (stream, app, error);
2355 
2356   else
2357     {
2358       token_stream_set_error (stream, error, FALSE,
2359                               G_VARIANT_PARSE_ERROR_VALUE_EXPECTED,
2360                               &quot;expected value&quot;);
2361       return NULL;
2362     }
2363 
2364   if (result != NULL)
2365     {
2366       token_stream_end_ref (stream, &amp;source_ref);
2367       result-&gt;source_ref = source_ref;
2368     }
2369 
2370   return result;
2371 }
2372 
2373 /**
2374  * g_variant_parse:
2375  * @type: (nullable): a #GVariantType, or %NULL
2376  * @text: a string containing a GVariant in text form
2377  * @limit: (nullable): a pointer to the end of @text, or %NULL
2378  * @endptr: (nullable): a location to store the end pointer, or %NULL
2379  * @error: (nullable): a pointer to a %NULL #GError pointer, or %NULL
2380  *
2381  * Parses a #GVariant from a text representation.
2382  *
2383  * A single #GVariant is parsed from the content of @text.
2384  *
2385  * The format is described [here][gvariant-text].
2386  *
2387  * The memory at @limit will never be accessed and the parser behaves as
2388  * if the character at @limit is the nul terminator.  This has the
2389  * effect of bounding @text.
2390  *
2391  * If @endptr is non-%NULL then @text is permitted to contain data
2392  * following the value that this function parses and @endptr will be
2393  * updated to point to the first character past the end of the text
2394  * parsed by this function.  If @endptr is %NULL and there is extra data
2395  * then an error is returned.
2396  *
2397  * If @type is non-%NULL then the value will be parsed to have that
2398  * type.  This may result in additional parse errors (in the case that
2399  * the parsed value doesn&#39;t fit the type) but may also result in fewer
2400  * errors (in the case that the type would have been ambiguous, such as
2401  * with empty arrays).
2402  *
2403  * In the event that the parsing is successful, the resulting #GVariant
2404  * is returned. It is never floating, and must be freed with
2405  * g_variant_unref().
2406  *
2407  * In case of any error, %NULL will be returned.  If @error is non-%NULL
2408  * then it will be set to reflect the error that occurred.
2409  *
2410  * Officially, the language understood by the parser is &quot;any string
2411  * produced by g_variant_print()&quot;.
2412  *
2413  * Returns: a non-floating reference to a #GVariant, or %NULL
2414  **/
2415 GVariant *
2416 g_variant_parse (const GVariantType  *type,
2417                  const gchar         *text,
2418                  const gchar         *limit,
2419                  const gchar        **endptr,
2420                  GError             **error)
2421 {
2422   TokenStream stream = { 0, };
2423   GVariant *result = NULL;
2424   AST *ast;
2425 
2426   g_return_val_if_fail (text != NULL, NULL);
2427   g_return_val_if_fail (text == limit || text != NULL, NULL);
2428 
2429   stream.start = text;
2430   stream.stream = text;
2431   stream.end = limit;
2432 
2433   if ((ast = parse (&amp;stream, NULL, error)))
2434     {
2435       if (type == NULL)
2436         result = ast_resolve (ast, error);
2437       else
2438         result = ast_get_value (ast, type, error);
2439 
2440       if (result != NULL)
2441         {
2442           g_variant_ref_sink (result);
2443 
2444           if (endptr == NULL)
2445             {
2446               while (stream.stream != limit &amp;&amp;
2447                      g_ascii_isspace (*stream.stream))
2448                 stream.stream++;
2449 
2450               if (stream.stream != limit &amp;&amp; *stream.stream != &#39;\0&#39;)
2451                 {
2452                   SourceRef ref = { stream.stream - text,
2453                                     stream.stream - text };
2454 
2455                   parser_set_error (error, &amp;ref, NULL,
2456                                     G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END,
2457                                     &quot;expected end of input&quot;);
2458                   g_variant_unref (result);
2459 
2460                   result = NULL;
2461                 }
2462             }
2463           else
2464             *endptr = stream.stream;
2465         }
2466 
2467       ast_free (ast);
2468     }
2469 
2470   return result;
2471 }
2472 
2473 /**
2474  * g_variant_new_parsed_va:
2475  * @format: a text format #GVariant
2476  * @app: a pointer to a #va_list
2477  *
2478  * Parses @format and returns the result.
2479  *
2480  * This is the version of g_variant_new_parsed() intended to be used
2481  * from libraries.
2482  *
2483  * The return value will be floating if it was a newly created GVariant
2484  * instance.  In the case that @format simply specified the collection
2485  * of a #GVariant pointer (eg: @format was &quot;%*&quot;) then the collected
2486  * #GVariant pointer will be returned unmodified, without adding any
2487  * additional references.
2488  *
2489  * Note that the arguments in @app must be of the correct width for their types
2490  * specified in @format when collected into the #va_list. See
2491  * the [GVariant varargs documentation][gvariant-varargs].
2492  *
2493  * In order to behave correctly in all cases it is necessary for the
2494  * calling function to g_variant_ref_sink() the return result before
2495  * returning control to the user that originally provided the pointer.
2496  * At this point, the caller will have their own full reference to the
2497  * result.  This can also be done by adding the result to a container,
2498  * or by passing it to another g_variant_new() call.
2499  *
2500  * Returns: a new, usually floating, #GVariant
2501  **/
2502 GVariant *
2503 g_variant_new_parsed_va (const gchar *format,
2504                          va_list     *app)
2505 {
2506   TokenStream stream = { 0, };
2507   GVariant *result = NULL;
2508   GError *error = NULL;
2509   AST *ast;
2510 
2511   g_return_val_if_fail (format != NULL, NULL);
2512   g_return_val_if_fail (app != NULL, NULL);
2513 
2514   stream.start = format;
2515   stream.stream = format;
2516   stream.end = NULL;
2517 
2518   if ((ast = parse (&amp;stream, app, &amp;error)))
2519     {
2520       result = ast_resolve (ast, &amp;error);
2521       ast_free (ast);
2522     }
2523 
2524   if (result == NULL)
2525     g_error (&quot;g_variant_new_parsed: %s&quot;, error-&gt;message);
2526 
2527   if (*stream.stream)
2528     g_error (&quot;g_variant_new_parsed: trailing text after value&quot;);
2529 
2530   return result;
2531 }
2532 
2533 /**
2534  * g_variant_new_parsed:
2535  * @format: a text format #GVariant
2536  * @...: arguments as per @format
2537  *
2538  * Parses @format and returns the result.
2539  *
2540  * @format must be a text format #GVariant with one extension: at any
2541  * point that a value may appear in the text, a &#39;%&#39; character followed
2542  * by a GVariant format string (as per g_variant_new()) may appear.  In
2543  * that case, the same arguments are collected from the argument list as
2544  * g_variant_new() would have collected.
2545  *
2546  * Note that the arguments must be of the correct width for their types
2547  * specified in @format. This can be achieved by casting them. See
2548  * the [GVariant varargs documentation][gvariant-varargs].
2549  *
2550  * Consider this simple example:
2551  * |[&lt;!-- language=&quot;C&quot; --&gt;
2552  *  g_variant_new_parsed (&quot;[(&#39;one&#39;, 1), (&#39;two&#39;, %i), (%s, 3)]&quot;, 2, &quot;three&quot;);
2553  * ]|
2554  *
2555  * In the example, the variable argument parameters are collected and
2556  * filled in as if they were part of the original string to produce the
2557  * result of
2558  * |[&lt;!-- language=&quot;C&quot; --&gt;
2559  * [(&#39;one&#39;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, 3)]
2560  * ]|
2561  *
2562  * This function is intended only to be used with @format as a string
2563  * literal.  Any parse error is fatal to the calling process.  If you
2564  * want to parse data from untrusted sources, use g_variant_parse().
2565  *
2566  * You may not use this function to return, unmodified, a single
2567  * #GVariant pointer from the argument list.  ie: @format may not solely
2568  * be anything along the lines of &quot;%*&quot;, &quot;%?&quot;, &quot;\%r&quot;, or anything starting
2569  * with &quot;%@&quot;.
2570  *
2571  * Returns: a new floating #GVariant instance
2572  **/
2573 GVariant *
2574 g_variant_new_parsed (const gchar *format,
2575                       ...)
2576 {
2577   GVariant *result;
2578   va_list ap;
2579 
2580   va_start (ap, format);
2581   result = g_variant_new_parsed_va (format, &amp;ap);
2582   va_end (ap);
2583 
2584   return result;
2585 }
2586 
2587 /**
2588  * g_variant_builder_add_parsed:
2589  * @builder: a #GVariantBuilder
2590  * @format: a text format #GVariant
2591  * @...: arguments as per @format
2592  *
2593  * Adds to a #GVariantBuilder.
2594  *
2595  * This call is a convenience wrapper that is exactly equivalent to
2596  * calling g_variant_new_parsed() followed by
2597  * g_variant_builder_add_value().
2598  *
2599  * Note that the arguments must be of the correct width for their types
2600  * specified in @format_string. This can be achieved by casting them. See
2601  * the [GVariant varargs documentation][gvariant-varargs].
2602  *
2603  * This function might be used as follows:
2604  *
2605  * |[&lt;!-- language=&quot;C&quot; --&gt;
2606  * GVariant *
2607  * make_pointless_dictionary (void)
2608  * {
2609  *   GVariantBuilder builder;
2610  *   int i;
2611  *
2612  *   g_variant_builder_init (&amp;builder, G_VARIANT_TYPE_ARRAY);
2613  *   g_variant_builder_add_parsed (&amp;builder, &quot;{&#39;width&#39;, &lt;%i&gt;}&quot;, 600);
2614  *   g_variant_builder_add_parsed (&amp;builder, &quot;{&#39;title&#39;, &lt;%s&gt;}&quot;, &quot;foo&quot;);
2615  *   g_variant_builder_add_parsed (&amp;builder, &quot;{&#39;transparency&#39;, &lt;0.5&gt;}&quot;);
2616  *   return g_variant_builder_end (&amp;builder);
2617  * }
2618  * ]|
2619  *
2620  * Since: 2.26
2621  */
2622 void
2623 g_variant_builder_add_parsed (GVariantBuilder *builder,
2624                               const gchar     *format,
2625                               ...)
2626 {
2627   va_list ap;
2628 
2629   va_start (ap, format);
2630   g_variant_builder_add_value (builder, g_variant_new_parsed_va (format, &amp;ap));
2631   va_end (ap);
2632 }
2633 
2634 static gboolean
2635 parse_num (const gchar *num,
2636            const gchar *limit,
2637            guint       *result)
2638 {
2639   gchar *endptr;
2640   gint64 bignum;
2641 
2642   bignum = g_ascii_strtoll (num, &amp;endptr, 10);
2643 
2644   if (endptr != limit)
2645     return FALSE;
2646 
2647   if (bignum &lt; 0 || bignum &gt; G_MAXINT)
2648     return FALSE;
2649 
2650   *result = (guint) bignum;
2651 
2652   return TRUE;
2653 }
2654 
2655 static void
2656 add_last_line (GString     *err,
2657                const gchar *str)
2658 {
2659   const gchar *last_nl;
2660   gchar *chomped;
2661   gint i;
2662 
2663   /* This is an error at the end of input.  If we have a file
2664    * with newlines, that&#39;s probably the empty string after the
2665    * last newline, which is not the most useful thing to show.
2666    *
2667    * Instead, show the last line of non-whitespace that we have
2668    * and put the pointer at the end of it.
2669    */
2670   chomped = g_strchomp (g_strdup (str));
2671   last_nl = strrchr (chomped, &#39;\n&#39;);
2672   if (last_nl == NULL)
2673     last_nl = chomped;
2674   else
2675     last_nl++;
2676 
2677   /* Print the last line like so:
2678    *
2679    *   [1, 2, 3,
2680    *            ^
2681    */
2682   g_string_append (err, &quot;  &quot;);
2683   if (last_nl[0])
2684     g_string_append (err, last_nl);
2685   else
2686     g_string_append (err, &quot;(empty input)&quot;);
2687   g_string_append (err, &quot;\n  &quot;);
2688   for (i = 0; last_nl[i]; i++)
2689     g_string_append_c (err, &#39; &#39;);
2690   g_string_append (err, &quot;^\n&quot;);
2691   g_free (chomped);
2692 }
2693 
2694 static void
2695 add_lines_from_range (GString     *err,
2696                       const gchar *str,
2697                       const gchar *start1,
2698                       const gchar *end1,
2699                       const gchar *start2,
2700                       const gchar *end2)
2701 {
2702   while (str &lt; end1 || str &lt; end2)
2703     {
2704       const gchar *nl;
2705 
2706       nl = str + strcspn (str, &quot;\n&quot;);
2707 
2708       if ((start1 &lt; nl &amp;&amp; str &lt; end1) || (start2 &lt; nl &amp;&amp; str &lt; end2))
2709         {
2710           const gchar *s;
2711 
2712           /* We&#39;re going to print this line */
2713           g_string_append (err, &quot;  &quot;);
2714           g_string_append_len (err, str, nl - str);
2715           g_string_append (err, &quot;\n  &quot;);
2716 
2717           /* And add underlines... */
2718           for (s = str; s &lt; nl; s++)
2719             {
2720               if ((start1 &lt;= s &amp;&amp; s &lt; end1) || (start2 &lt;= s &amp;&amp; s &lt; end2))
2721                 g_string_append_c (err, &#39;^&#39;);
2722               else
2723                 g_string_append_c (err, &#39; &#39;);
2724             }
2725           g_string_append_c (err, &#39;\n&#39;);
2726         }
2727 
2728       if (!*nl)
2729         break;
2730 
2731       str = nl + 1;
2732     }
2733 }
2734 
2735 /**
2736  * g_variant_parse_error_print_context:
2737  * @error: a #GError from the #GVariantParseError domain
2738  * @source_str: the string that was given to the parser
2739  *
2740  * Pretty-prints a message showing the context of a #GVariant parse
2741  * error within the string for which parsing was attempted.
2742  *
2743  * The resulting string is suitable for output to the console or other
2744  * monospace media where newlines are treated in the usual way.
2745  *
2746  * The message will typically look something like one of the following:
2747  *
2748  * |[
2749  * unterminated string constant:
2750  *   (1, 2, 3, &#39;abc
2751  *             ^^^^
2752  * ]|
2753  *
2754  * or
2755  *
2756  * |[
2757  * unable to find a common type:
2758  *   [1, 2, 3, &#39;str&#39;]
2759  *    ^        ^^^^^
2760  * ]|
2761  *
2762  * The format of the message may change in a future version.
2763  *
2764  * @error must have come from a failed attempt to g_variant_parse() and
2765  * @source_str must be exactly the same string that caused the error.
2766  * If @source_str was not nul-terminated when you passed it to
2767  * g_variant_parse() then you must add nul termination before using this
2768  * function.
2769  *
2770  * Returns: (transfer full): the printed message
2771  *
2772  * Since: 2.40
2773  **/
2774 gchar *
2775 g_variant_parse_error_print_context (GError      *error,
2776                                      const gchar *source_str)
2777 {
2778   const gchar *colon, *dash, *comma;
2779   gboolean success = FALSE;
2780   GString *err;
2781 
2782   g_return_val_if_fail (error-&gt;domain == G_VARIANT_PARSE_ERROR, FALSE);
2783 
2784   /* We can only have a limited number of possible types of ranges
2785    * emitted from the parser:
2786    *
2787    *  - a:          -- usually errors from the tokeniser (eof, invalid char, etc.)
2788    *  - a-b:        -- usually errors from handling one single token
2789    *  - a-b,c-d:    -- errors involving two tokens (ie: type inferencing)
2790    *
2791    * We never see, for example &quot;a,c&quot;.
2792    */
2793 
2794   colon = strchr (error-&gt;message, &#39;:&#39;);
2795   dash = strchr (error-&gt;message, &#39;-&#39;);
2796   comma = strchr (error-&gt;message, &#39;,&#39;);
2797 
2798   if (!colon)
2799     return NULL;
2800 
2801   err = g_string_new (colon + 1);
2802   g_string_append (err, &quot;:\n&quot;);
2803 
2804   if (dash == NULL || colon &lt; dash)
2805     {
2806       guint point;
2807 
2808       /* we have a single point */
2809       if (!parse_num (error-&gt;message, colon, &amp;point))
2810         goto out;
2811 
2812       if (point &gt;= strlen (source_str))
2813         /* the error is at the end of the input */
2814         add_last_line (err, source_str);
2815       else
2816         /* otherwise just treat it as an error at a thin range */
2817         add_lines_from_range (err, source_str, source_str + point, source_str + point + 1, NULL, NULL);
2818     }
2819   else
2820     {
2821       /* We have one or two ranges... */
2822       if (comma &amp;&amp; comma &lt; colon)
2823         {
2824           guint start1, end1, start2, end2;
2825           const gchar *dash2;
2826 
2827           /* Two ranges */
2828           dash2 = strchr (comma, &#39;-&#39;);
2829 
2830           if (!parse_num (error-&gt;message, dash, &amp;start1) || !parse_num (dash + 1, comma, &amp;end1) ||
2831               !parse_num (comma + 1, dash2, &amp;start2) || !parse_num (dash2 + 1, colon, &amp;end2))
2832             goto out;
2833 
2834           add_lines_from_range (err, source_str,
2835                                 source_str + start1, source_str + end1,
2836                                 source_str + start2, source_str + end2);
2837         }
2838       else
2839         {
2840           guint start, end;
2841 
2842           /* One range */
2843           if (!parse_num (error-&gt;message, dash, &amp;start) || !parse_num (dash + 1, colon, &amp;end))
2844             goto out;
2845 
2846           add_lines_from_range (err, source_str, source_str + start, source_str + end, NULL, NULL);
2847         }
2848     }
2849 
2850   success = TRUE;
2851 
2852 out:
2853   return g_string_free (err, !success);
2854 }
    </pre>
  </body>
</html>