<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gvariant-serialiser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvariant.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gvariant.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright � 2007, 2008 Ryan Lortie</span>
<span class="line-modified">   3  * Copyright � 2010 Codethink Limited</span>
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public
  16  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  *
  18  * Author: Ryan Lortie &lt;desrt@desrt.ca&gt;
  19  */
  20 
  21 /* Prologue {{{1 */
  22 
  23 #include &quot;config.h&quot;
</pre>
<hr />
<pre>
 209  * maybe types.  The other is used for container types where there
 210  * are multiple element types: tuples and dictionary entries.
 211  *
 212  * Array type info structures are 6 * sizeof (void *), plus the
 213  * memory required to store the type string itself.  This means that
 214  * on 32-bit systems, the cache entry for &quot;a{sv}&quot; would require 30
 215  * bytes of memory (plus malloc overhead).
 216  *
 217  * Tuple type info structures are 6 * sizeof (void *), plus 4 *
 218  * sizeof (void *) for each item in the tuple, plus the memory
 219  * required to store the type string itself.  A 2-item tuple, for
 220  * example, would have a type information structure that consumed
 221  * writable memory in the size of 14 * sizeof (void *) (plus type
 222  * string)  This means that on 32-bit systems, the cache entry for
 223  * &quot;{sv}&quot; would require 61 bytes of memory (plus malloc overhead).
 224  *
 225  * This means that in total, for our &quot;a{sv}&quot; example, 91 bytes of
 226  * type information would be allocated.
 227  *
 228  * The type information cache, additionally, uses a #GHashTable to
<span class="line-modified"> 229  * store and lookup the cached items and stores a pointer to this</span>
 230  * hash table in static storage.  The hash table is freed when there
 231  * are zero items in the type cache.
 232  *
 233  * Although these sizes may seem large it is important to remember
 234  * that a program will probably only have a very small number of
 235  * different types of values in it and that only one type information
 236  * structure is required for many different values of the same type.
 237  *
 238  * ## Buffer Management Memory
 239  *
 240  * #GVariant uses an internal buffer management structure to deal
 241  * with the various different possible sources of serialised data
 242  * that it uses.  The buffer is responsible for ensuring that the
 243  * correct call is made when the data is no longer in use by
 244  * #GVariant.  This may involve a g_free() or a g_slice_free() or
 245  * even g_mapped_file_unref().
 246  *
 247  * One buffer management structure is used for each chunk of
 248  * serialised data.  The size of the buffer management structure
 249  * is 4 * (void *).  On 32-bit systems, that&#39;s 16 bytes.
</pre>
<hr />
<pre>
 290  * sure a (GVariant *) has the required type.
 291  */
 292 #define TYPE_CHECK(value, TYPE, val) \
 293   if G_UNLIKELY (!g_variant_is_of_type (value, TYPE)) {           \
 294     g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC,            \
 295                               &quot;g_variant_is_of_type (&quot; #value     \
 296                               &quot;, &quot; #TYPE &quot;)&quot;);                    \
 297     return val;                                                   \
 298   }
 299 
 300 /* Numeric Type Constructor/Getters {{{1 */
 301 /* &lt; private &gt;
 302  * g_variant_new_from_trusted:
 303  * @type: the #GVariantType
 304  * @data: the data to use
 305  * @size: the size of @data
 306  *
 307  * Constructs a new trusted #GVariant instance from the provided data.
 308  * This is used to implement g_variant_new_* for all the basic types.
 309  *





 310  * Returns: a new floating #GVariant
 311  */
 312 static GVariant *
 313 g_variant_new_from_trusted (const GVariantType *type,
 314                             gconstpointer       data,
 315                             gsize               size)
 316 {
 317   GVariant *value;
 318   GBytes *bytes;
 319 
 320   bytes = g_bytes_new (data, size);
 321   value = g_variant_new_from_bytes (type, bytes, TRUE);
 322   g_bytes_unref (bytes);
 323 
 324   return value;
 325 }
 326 
 327 /**
 328  * g_variant_new_boolean:
 329  * @value: a #gboolean value
</pre>
<hr />
<pre>
 404  * other than %G_VARIANT_TYPE_BYTE.
 405  *
 406  * Returns: a #guint8
 407  *
 408  * Since: 2.24
 409  **/
 410 NUMERIC_TYPE (BYTE, byte, guint8)
 411 
 412 /**
 413  * g_variant_new_int16:
 414  * @value: a #gint16 value
 415  *
 416  * Creates a new int16 #GVariant instance.
 417  *
 418  * Returns: (transfer none): a floating reference to a new int16 #GVariant instance
 419  *
 420  * Since: 2.24
 421  **/
 422 /**
 423  * g_variant_get_int16:
<span class="line-modified"> 424  * @value: a int16 #GVariant instance</span>
 425  *
 426  * Returns the 16-bit signed integer value of @value.
 427  *
 428  * It is an error to call this function with a @value of any type
 429  * other than %G_VARIANT_TYPE_INT16.
 430  *
 431  * Returns: a #gint16
 432  *
 433  * Since: 2.24
 434  **/
 435 NUMERIC_TYPE (INT16, int16, gint16)
 436 
 437 /**
 438  * g_variant_new_uint16:
 439  * @value: a #guint16 value
 440  *
 441  * Creates a new uint16 #GVariant instance.
 442  *
 443  * Returns: (transfer none): a floating reference to a new uint16 #GVariant instance
 444  *
</pre>
<hr />
<pre>
 454  * other than %G_VARIANT_TYPE_UINT16.
 455  *
 456  * Returns: a #guint16
 457  *
 458  * Since: 2.24
 459  **/
 460 NUMERIC_TYPE (UINT16, uint16, guint16)
 461 
 462 /**
 463  * g_variant_new_int32:
 464  * @value: a #gint32 value
 465  *
 466  * Creates a new int32 #GVariant instance.
 467  *
 468  * Returns: (transfer none): a floating reference to a new int32 #GVariant instance
 469  *
 470  * Since: 2.24
 471  **/
 472 /**
 473  * g_variant_get_int32:
<span class="line-modified"> 474  * @value: a int32 #GVariant instance</span>
 475  *
 476  * Returns the 32-bit signed integer value of @value.
 477  *
 478  * It is an error to call this function with a @value of any type
 479  * other than %G_VARIANT_TYPE_INT32.
 480  *
 481  * Returns: a #gint32
 482  *
 483  * Since: 2.24
 484  **/
 485 NUMERIC_TYPE (INT32, int32, gint32)
 486 
 487 /**
 488  * g_variant_new_uint32:
 489  * @value: a #guint32 value
 490  *
 491  * Creates a new uint32 #GVariant instance.
 492  *
 493  * Returns: (transfer none): a floating reference to a new uint32 #GVariant instance
 494  *
</pre>
<hr />
<pre>
 504  * other than %G_VARIANT_TYPE_UINT32.
 505  *
 506  * Returns: a #guint32
 507  *
 508  * Since: 2.24
 509  **/
 510 NUMERIC_TYPE (UINT32, uint32, guint32)
 511 
 512 /**
 513  * g_variant_new_int64:
 514  * @value: a #gint64 value
 515  *
 516  * Creates a new int64 #GVariant instance.
 517  *
 518  * Returns: (transfer none): a floating reference to a new int64 #GVariant instance
 519  *
 520  * Since: 2.24
 521  **/
 522 /**
 523  * g_variant_get_int64:
<span class="line-modified"> 524  * @value: a int64 #GVariant instance</span>
 525  *
 526  * Returns the 64-bit signed integer value of @value.
 527  *
 528  * It is an error to call this function with a @value of any type
 529  * other than %G_VARIANT_TYPE_INT64.
 530  *
 531  * Returns: a #gint64
 532  *
 533  * Since: 2.24
 534  **/
 535 NUMERIC_TYPE (INT64, int64, gint64)
 536 
 537 /**
 538  * g_variant_new_uint64:
 539  * @value: a #guint64 value
 540  *
 541  * Creates a new uint64 #GVariant instance.
 542  *
 543  * Returns: (transfer none): a floating reference to a new uint64 #GVariant instance
 544  *
</pre>
<hr />
<pre>
 920   gboolean trusted;
 921 
 922   g_return_val_if_fail (key != NULL &amp;&amp; value != NULL, NULL);
 923   g_return_val_if_fail (!g_variant_is_container (key), NULL);
 924 
 925   children = g_new (GVariant *, 2);
 926   children[0] = g_variant_ref_sink (key);
 927   children[1] = g_variant_ref_sink (value);
 928   trusted = g_variant_is_trusted (key) &amp;&amp; g_variant_is_trusted (value);
 929 
 930   dict_type = g_variant_make_dict_entry_type (key, value);
 931   value = g_variant_new_from_children (dict_type, children, 2, trusted);
 932   g_variant_type_free (dict_type);
 933 
 934   return value;
 935 }
 936 
 937 /**
 938  * g_variant_lookup: (skip)
 939  * @dictionary: a dictionary #GVariant
<span class="line-modified"> 940  * @key: the key to lookup in the dictionary</span>
 941  * @format_string: a GVariant format string
 942  * @...: the arguments to unpack the value into
 943  *
 944  * Looks up a value in a dictionary #GVariant.
 945  *
 946  * This function is a wrapper around g_variant_lookup_value() and
 947  * g_variant_get().  In the case that %NULL would have been returned,
 948  * this function returns %FALSE.  Otherwise, it unpacks the returned
 949  * value and returns %TRUE.
 950  *
 951  * @format_string determines the C types that are used for unpacking
 952  * the values and also determines if the values are copied or borrowed,
 953  * see the section on
 954  * [GVariant format strings][gvariant-format-strings-pointers].
 955  *
 956  * This function is currently implemented with a linear scan.  If you
 957  * plan to do many lookups then #GVariantDict may be more efficient.
 958  *
 959  * Returns: %TRUE if a value was unpacked
 960  *
</pre>
<hr />
<pre>
 978 
 979   if (value)
 980     {
 981       va_list ap;
 982 
 983       va_start (ap, format_string);
 984       g_variant_get_va (value, format_string, NULL, &amp;ap);
 985       g_variant_unref (value);
 986       va_end (ap);
 987 
 988       return TRUE;
 989     }
 990 
 991   else
 992     return FALSE;
 993 }
 994 
 995 /**
 996  * g_variant_lookup_value:
 997  * @dictionary: a dictionary #GVariant
<span class="line-modified"> 998  * @key: the key to lookup in the dictionary</span>
 999  * @expected_type: (nullable): a #GVariantType, or %NULL
1000  *
1001  * Looks up a value in a dictionary #GVariant.
1002  *
1003  * This function works with dictionaries of the type a{s*} (and equally
1004  * well with type a{o*}, but we only further discuss the string case
1005  * for sake of clarity).
1006  *
1007  * In the event that @dictionary has the type a{sv}, the @expected_type
1008  * string specifies what type of value is expected to be inside of the
1009  * variant. If the value inside the variant has a different type then
1010  * %NULL is returned. In the event that @dictionary has a value type other
<span class="line-modified">1011  * than v then @expected_type must directly match the key type and it is</span>
1012  * used to unpack the value directly or an error occurs.
1013  *
1014  * In either case, if @key is not found in @dictionary, %NULL is returned.
1015  *
1016  * If the key is found and the value has the correct type, it is
1017  * returned.  If @expected_type was specified then any non-%NULL return
1018  * value will have this type.
1019  *
1020  * This function is currently implemented with a linear scan.  If you
1021  * plan to do many lookups then #GVariantDict may be more efficient.
1022  *
1023  * Returns: (transfer full): the value of the dictionary key, or %NULL
1024  *
1025  * Since: 2.28
1026  */
1027 GVariant *
1028 g_variant_lookup_value (GVariant           *dictionary,
1029                         const gchar        *key,
1030                         const GVariantType *expected_type)
1031 {
</pre>
<hr />
<pre>
1530 
1531 /**
1532  * g_variant_new_strv:
1533  * @strv: (array length=length) (element-type utf8): an array of strings
1534  * @length: the length of @strv, or -1
1535  *
1536  * Constructs an array of strings #GVariant from the given array of
1537  * strings.
1538  *
1539  * If @length is -1 then @strv is %NULL-terminated.
1540  *
1541  * Returns: (transfer none): a new floating #GVariant instance
1542  *
1543  * Since: 2.24
1544  **/
1545 GVariant *
1546 g_variant_new_strv (const gchar * const *strv,
1547                     gssize               length)
1548 {
1549   GVariant **strings;
<span class="line-modified">1550   gsize i;</span>
1551 
1552   g_return_val_if_fail (length == 0 || strv != NULL, NULL);
1553 
1554   if (length &lt; 0)
1555     length = g_strv_length ((gchar **) strv);

1556 
<span class="line-modified">1557   strings = g_new (GVariant *, length);</span>
<span class="line-modified">1558   for (i = 0; i &lt; length; i++)</span>
1559     strings[i] = g_variant_ref_sink (g_variant_new_string (strv[i]));
1560 
1561   return g_variant_new_from_children (G_VARIANT_TYPE_STRING_ARRAY,
<span class="line-modified">1562                                       strings, length, TRUE);</span>
1563 }
1564 
1565 /**
1566  * g_variant_get_strv:
1567  * @value: an array of strings #GVariant
1568  * @length: (out) (optional): the length of the result, or %NULL
1569  *
1570  * Gets the contents of an array of strings #GVariant.  This call
1571  * makes a shallow copy; the return result should be released with
1572  * g_free(), but the individual strings must not be modified.
1573  *
1574  * If @length is non-%NULL then the number of elements in the result
1575  * is stored there.  In any case, the resulting array will be
1576  * %NULL-terminated.
1577  *
1578  * For an empty array, @length will be set to 0 and a pointer to a
1579  * %NULL pointer will be returned.
1580  *
1581  * Returns: (array length=length zero-terminated=1) (transfer container): an array of constant strings
1582  *
</pre>
<hr />
<pre>
1666  * @strv: (array length=length) (element-type utf8): an array of strings
1667  * @length: the length of @strv, or -1
1668  *
1669  * Constructs an array of object paths #GVariant from the given array of
1670  * strings.
1671  *
1672  * Each string must be a valid #GVariant object path; see
1673  * g_variant_is_object_path().
1674  *
1675  * If @length is -1 then @strv is %NULL-terminated.
1676  *
1677  * Returns: (transfer none): a new floating #GVariant instance
1678  *
1679  * Since: 2.30
1680  **/
1681 GVariant *
1682 g_variant_new_objv (const gchar * const *strv,
1683                     gssize               length)
1684 {
1685   GVariant **strings;
<span class="line-modified">1686   gsize i;</span>
1687 
1688   g_return_val_if_fail (length == 0 || strv != NULL, NULL);
1689 
1690   if (length &lt; 0)
1691     length = g_strv_length ((gchar **) strv);

1692 
<span class="line-modified">1693   strings = g_new (GVariant *, length);</span>
<span class="line-modified">1694   for (i = 0; i &lt; length; i++)</span>
1695     strings[i] = g_variant_ref_sink (g_variant_new_object_path (strv[i]));
1696 
1697   return g_variant_new_from_children (G_VARIANT_TYPE_OBJECT_PATH_ARRAY,
<span class="line-modified">1698                                       strings, length, TRUE);</span>
1699 }
1700 
1701 /**
1702  * g_variant_get_objv:
1703  * @value: an array of object paths #GVariant
1704  * @length: (out) (optional): the length of the result, or %NULL
1705  *
1706  * Gets the contents of an array of object paths #GVariant.  This call
1707  * makes a shallow copy; the return result should be released with
1708  * g_free(), but the individual strings must not be modified.
1709  *
1710  * If @length is non-%NULL then the number of elements in the result
1711  * is stored there.  In any case, the resulting array will be
1712  * %NULL-terminated.
1713  *
1714  * For an empty array, @length will be set to 0 and a pointer to a
1715  * %NULL pointer will be returned.
1716  *
1717  * Returns: (array length=length zero-terminated=1) (transfer container): an array of constant strings
1718  *
</pre>
<hr />
<pre>
1906 
1907 /**
1908  * g_variant_new_bytestring_array:
1909  * @strv: (array length=length): an array of strings
1910  * @length: the length of @strv, or -1
1911  *
1912  * Constructs an array of bytestring #GVariant from the given array of
1913  * strings.
1914  *
1915  * If @length is -1 then @strv is %NULL-terminated.
1916  *
1917  * Returns: (transfer none): a new floating #GVariant instance
1918  *
1919  * Since: 2.26
1920  **/
1921 GVariant *
1922 g_variant_new_bytestring_array (const gchar * const *strv,
1923                                 gssize               length)
1924 {
1925   GVariant **strings;
<span class="line-modified">1926   gsize i;</span>
1927 
1928   g_return_val_if_fail (length == 0 || strv != NULL, NULL);
1929 
1930   if (length &lt; 0)
1931     length = g_strv_length ((gchar **) strv);

1932 
<span class="line-modified">1933   strings = g_new (GVariant *, length);</span>
<span class="line-modified">1934   for (i = 0; i &lt; length; i++)</span>
1935     strings[i] = g_variant_ref_sink (g_variant_new_bytestring (strv[i]));
1936 
1937   return g_variant_new_from_children (G_VARIANT_TYPE_BYTESTRING_ARRAY,
<span class="line-modified">1938                                       strings, length, TRUE);</span>
1939 }
1940 
1941 /**
1942  * g_variant_get_bytestring_array:
1943  * @value: an array of array of bytes #GVariant (&#39;aay&#39;)
1944  * @length: (out) (optional): the length of the result, or %NULL
1945  *
1946  * Gets the contents of an array of array of bytes #GVariant.  This call
1947  * makes a shallow copy; the return result should be released with
1948  * g_free(), but the individual strings must not be modified.
1949  *
1950  * If @length is non-%NULL then the number of elements in the result is
1951  * stored there.  In any case, the resulting array will be
1952  * %NULL-terminated.
1953  *
1954  * For an empty array, @length will be set to 0 and a pointer to a
1955  * %NULL pointer will be returned.
1956  *
1957  * Returns: (array length=length) (transfer container): an array of constant strings
1958  *
</pre>
<hr />
<pre>
2262               break;
2263 
2264           /* first nul byte is the last byte -&gt; it&#39;s a byte string. */
2265           if (i == size - 1)
2266             {
2267               gchar *escaped = g_strescape (str, NULL);
2268 
2269               /* use double quotes only if a &#39; is in the string */
2270               if (strchr (str, &#39;\&#39;&#39;))
2271                 g_string_append_printf (string, &quot;b\&quot;%s\&quot;&quot;, escaped);
2272               else
2273                 g_string_append_printf (string, &quot;b&#39;%s&#39;&quot;, escaped);
2274 
2275               g_free (escaped);
2276               break;
2277             }
2278 
2279           else
2280             {
2281               /* fall through and handle normally... */
<span class="line-modified">2282         }</span>
2283         }
2284 
2285       /*
2286        * if the first two characters are &#39;a{&#39; then it&#39;s an array of
2287        * dictionary entries (ie: a dictionary) so we print that
2288        * differently.
2289        */
2290       if (g_variant_get_type_string (value)[1] == &#39;{&#39;)
2291         /* dictionary */
2292         {
2293           const gchar *comma = &quot;&quot;;
2294           gsize n, i;
2295 
2296           if ((n = g_variant_n_children (value)) == 0)
2297             {
2298               if (type_annotate)
2299                 g_string_append_printf (string, &quot;@%s &quot;,
2300                                         g_variant_get_type_string (value));
2301               g_string_append (string, &quot;{}&quot;);
2302               break;
</pre>
<hr />
<pre>
3940                      GVariant     *from_asv)
3941 {
3942   GVariantIter iter;
3943   gchar *key;
3944   GVariant *value;
3945 
3946   GVSD(dict)-&gt;values = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify) g_variant_unref);
3947   GVSD(dict)-&gt;magic = GVSD_MAGIC;
3948 
3949   if (from_asv)
3950     {
3951       g_variant_iter_init (&amp;iter, from_asv);
3952       while (g_variant_iter_next (&amp;iter, &quot;{sv}&quot;, &amp;key, &amp;value))
3953         g_hash_table_insert (GVSD(dict)-&gt;values, key, value);
3954     }
3955 }
3956 
3957 /**
3958  * g_variant_dict_lookup:
3959  * @dict: a #GVariantDict
<span class="line-modified">3960  * @key: the key to lookup in the dictionary</span>
3961  * @format_string: a GVariant format string
3962  * @...: the arguments to unpack the value into
3963  *
3964  * Looks up a value in a #GVariantDict.
3965  *
3966  * This function is a wrapper around g_variant_dict_lookup_value() and
3967  * g_variant_get().  In the case that %NULL would have been returned,
3968  * this function returns %FALSE.  Otherwise, it unpacks the returned
3969  * value and returns %TRUE.
3970  *
3971  * @format_string determines the C types that are used for unpacking the
3972  * values and also determines if the values are copied or borrowed, see the
3973  * section on [GVariant format strings][gvariant-format-strings-pointers].
3974  *
3975  * Returns: %TRUE if a value was unpacked
3976  *
3977  * Since: 2.40
3978  **/
3979 gboolean
3980 g_variant_dict_lookup (GVariantDict *dict,
</pre>
<hr />
<pre>
3987 
3988   g_return_val_if_fail (ensure_valid_dict (dict), FALSE);
3989   g_return_val_if_fail (key != NULL, FALSE);
3990   g_return_val_if_fail (format_string != NULL, FALSE);
3991 
3992   value = g_hash_table_lookup (GVSD(dict)-&gt;values, key);
3993 
3994   if (value == NULL || !g_variant_check_format_string (value, format_string, FALSE))
3995     return FALSE;
3996 
3997   va_start (ap, format_string);
3998   g_variant_get_va (value, format_string, NULL, &amp;ap);
3999   va_end (ap);
4000 
4001   return TRUE;
4002 }
4003 
4004 /**
4005  * g_variant_dict_lookup_value:
4006  * @dict: a #GVariantDict
<span class="line-modified">4007  * @key: the key to lookup in the dictionary</span>
4008  * @expected_type: (nullable): a #GVariantType, or %NULL
4009  *
4010  * Looks up a value in a #GVariantDict.
4011  *
4012  * If @key is not found in @dictionary, %NULL is returned.
4013  *
4014  * The @expected_type string specifies what type of value is expected.
4015  * If the value associated with @key has a different type then %NULL is
4016  * returned.
4017  *
4018  * If the key is found and the value has the correct type, it is
4019  * returned.  If @expected_type was specified then any non-%NULL return
4020  * value will have this type.
4021  *
4022  * Returns: (transfer full): the value of the dictionary key, or %NULL
4023  *
4024  * Since: 2.40
4025  **/
4026 GVariant *
4027 g_variant_dict_lookup_value (GVariantDict       *dict,
4028                              const gchar        *key,
4029                              const GVariantType *expected_type)
4030 {
4031   GVariant *result;
4032 
4033   g_return_val_if_fail (ensure_valid_dict (dict), NULL);
4034   g_return_val_if_fail (key != NULL, NULL);
4035 
4036   result = g_hash_table_lookup (GVSD(dict)-&gt;values, key);
4037 
4038   if (result &amp;&amp; (!expected_type || g_variant_is_of_type (result, expected_type)))
4039     return g_variant_ref (result);
4040 
4041   return NULL;
4042 }
4043 
4044 /**
4045  * g_variant_dict_contains:
4046  * @dict: a #GVariantDict
<span class="line-modified">4047  * @key: the key to lookup in the dictionary</span>
4048  *
4049  * Checks if @key exists in @dict.
4050  *
4051  * Returns: %TRUE if @key is in @dict
4052  *
4053  * Since: 2.40
4054  **/
4055 gboolean
4056 g_variant_dict_contains (GVariantDict *dict,
4057                          const gchar  *key)
4058 {
4059   g_return_val_if_fail (ensure_valid_dict (dict), FALSE);
4060   g_return_val_if_fail (key != NULL, FALSE);
4061 
4062   return g_hash_table_contains (GVSD(dict)-&gt;values, key);
4063 }
4064 
4065 /**
4066  * g_variant_dict_insert:
4067  * @dict: a #GVariantDict
</pre>
<hr />
<pre>
4316           return FALSE;
4317 
4318       next_char(); /* consume &#39;)&#39; */
4319       break;
4320 
4321     case &#39;{&#39;:
4322       c = next_char();
4323 
4324       if (c == &#39;&amp;&#39;)
4325         {
4326           c = next_char ();
4327 
4328           if (c != &#39;s&#39; &amp;&amp; c != &#39;o&#39; &amp;&amp; c != &#39;g&#39;)
4329             return FALSE;
4330         }
4331       else
4332         {
4333           if (c == &#39;@&#39;)
4334             c = next_char ();
4335 
<span class="line-modified">4336           /* ISO/IEC 9899:1999 (C99) �7.21.5.2:</span>
4337            *    The terminating null character is considered to be
4338            *    part of the string.
4339            */
4340           if (c != &#39;\0&#39; &amp;&amp; strchr (&quot;bynqiuxthdsog?&quot;, c) == NULL)
4341             return FALSE;
4342         }
4343 
4344       if (!g_variant_format_string_scan (string, limit, &amp;string))
4345         return FALSE;
4346 
4347       if (next_char() != &#39;}&#39;)
4348         return FALSE;
4349 
4350       break;
4351 
4352     case &#39;^&#39;:
4353       if ((c = next_char()) == &#39;a&#39;)
4354         {
4355           if ((c = next_char()) == &#39;&amp;&#39;)
4356             {
</pre>
<hr />
<pre>
4668          str[0] == &#39;r&#39; || str[0] == &#39;v&#39; || str[0] == &#39;&amp;&#39;;
4669 }
4670 
4671 /* Single non-null pointer (&quot;nnp&quot;) {{{2 */
4672 static void
4673 g_variant_valist_free_nnp (const gchar *str,
4674                            gpointer     ptr)
4675 {
4676   switch (*str)
4677     {
4678     case &#39;a&#39;:
4679       g_variant_iter_free (ptr);
4680       break;
4681 
4682     case &#39;^&#39;:
4683       if (g_str_has_suffix (str, &quot;y&quot;))
4684         {
4685           if (str[2] != &#39;a&#39;) /* &#39;^a&amp;ay&#39;, &#39;^ay&#39; */
4686             g_free (ptr);
4687           else if (str[1] == &#39;a&#39;) /* &#39;^aay&#39; */
<span class="line-modified">4688         g_strfreev (ptr);</span>
4689           break; /* &#39;^&amp;ay&#39; */
4690         }
4691       else if (str[2] != &#39;&amp;&#39;) /* &#39;^as&#39;, &#39;^ao&#39; */
4692         g_strfreev (ptr);
4693       else                      /* &#39;^a&amp;s&#39;, &#39;^a&amp;o&#39; */
4694         g_free (ptr);
4695       break;
4696 
4697     case &#39;s&#39;:
4698     case &#39;o&#39;:
4699     case &#39;g&#39;:
4700       g_free (ptr);
4701       break;
4702 
4703     case &#39;@&#39;:
4704     case &#39;*&#39;:
4705     case &#39;?&#39;:
4706     case &#39;v&#39;:
4707       g_variant_unref (ptr);
4708       break;
</pre>
<hr />
<pre>
5992  * @data is not modified by this function and must remain valid with an
5993  * unchanging value until such a time as @notify is called with
5994  * @user_data.  If the contents of @data change before that time then
5995  * the result is undefined.
5996  *
5997  * If @data is trusted to be serialised data in normal form then
5998  * @trusted should be %TRUE.  This applies to serialised data created
5999  * within this process or read from a trusted location on the disk (such
6000  * as a file installed in /usr/lib alongside your application).  You
6001  * should set trusted to %FALSE if @data is read from the network, a
6002  * file in the user&#39;s home directory, etc.
6003  *
6004  * If @data was not stored in this machine&#39;s native endianness, any multi-byte
6005  * numeric values in the returned variant will also be in non-native
6006  * endianness. g_variant_byteswap() can be used to recover the original values.
6007  *
6008  * @notify will be called with @user_data when @data is no longer
6009  * needed.  The exact time of this call is unspecified and might even be
6010  * before this function returns.
6011  *





6012  * Returns: (transfer none): a new floating #GVariant of type @type
6013  *
6014  * Since: 2.24
6015  **/
6016 GVariant *
6017 g_variant_new_from_data (const GVariantType *type,
6018                          gconstpointer       data,
6019                          gsize               size,
6020                          gboolean            trusted,
6021                          GDestroyNotify      notify,
6022                          gpointer            user_data)
6023 {
6024   GVariant *value;
6025   GBytes *bytes;
6026 
6027   g_return_val_if_fail (g_variant_type_is_definite (type), NULL);
6028   g_return_val_if_fail (data != NULL || size == 0, NULL);
6029 
6030   if (notify)
6031     bytes = g_bytes_new_with_free_func (data, size, notify, user_data);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2007, 2008 Ryan Lortie</span>
<span class="line-modified">   3  * Copyright (C) 2010 Codethink Limited</span>
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Lesser General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2.1 of the License, or (at your option) any later version.
   9  *
  10  * This library is distributed in the hope that it will be useful,
  11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  13  * Lesser General Public License for more details.
  14  *
  15  * You should have received a copy of the GNU Lesser General Public
  16  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  17  *
  18  * Author: Ryan Lortie &lt;desrt@desrt.ca&gt;
  19  */
  20 
  21 /* Prologue {{{1 */
  22 
  23 #include &quot;config.h&quot;
</pre>
<hr />
<pre>
 209  * maybe types.  The other is used for container types where there
 210  * are multiple element types: tuples and dictionary entries.
 211  *
 212  * Array type info structures are 6 * sizeof (void *), plus the
 213  * memory required to store the type string itself.  This means that
 214  * on 32-bit systems, the cache entry for &quot;a{sv}&quot; would require 30
 215  * bytes of memory (plus malloc overhead).
 216  *
 217  * Tuple type info structures are 6 * sizeof (void *), plus 4 *
 218  * sizeof (void *) for each item in the tuple, plus the memory
 219  * required to store the type string itself.  A 2-item tuple, for
 220  * example, would have a type information structure that consumed
 221  * writable memory in the size of 14 * sizeof (void *) (plus type
 222  * string)  This means that on 32-bit systems, the cache entry for
 223  * &quot;{sv}&quot; would require 61 bytes of memory (plus malloc overhead).
 224  *
 225  * This means that in total, for our &quot;a{sv}&quot; example, 91 bytes of
 226  * type information would be allocated.
 227  *
 228  * The type information cache, additionally, uses a #GHashTable to
<span class="line-modified"> 229  * store and look up the cached items and stores a pointer to this</span>
 230  * hash table in static storage.  The hash table is freed when there
 231  * are zero items in the type cache.
 232  *
 233  * Although these sizes may seem large it is important to remember
 234  * that a program will probably only have a very small number of
 235  * different types of values in it and that only one type information
 236  * structure is required for many different values of the same type.
 237  *
 238  * ## Buffer Management Memory
 239  *
 240  * #GVariant uses an internal buffer management structure to deal
 241  * with the various different possible sources of serialised data
 242  * that it uses.  The buffer is responsible for ensuring that the
 243  * correct call is made when the data is no longer in use by
 244  * #GVariant.  This may involve a g_free() or a g_slice_free() or
 245  * even g_mapped_file_unref().
 246  *
 247  * One buffer management structure is used for each chunk of
 248  * serialised data.  The size of the buffer management structure
 249  * is 4 * (void *).  On 32-bit systems, that&#39;s 16 bytes.
</pre>
<hr />
<pre>
 290  * sure a (GVariant *) has the required type.
 291  */
 292 #define TYPE_CHECK(value, TYPE, val) \
 293   if G_UNLIKELY (!g_variant_is_of_type (value, TYPE)) {           \
 294     g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC,            \
 295                               &quot;g_variant_is_of_type (&quot; #value     \
 296                               &quot;, &quot; #TYPE &quot;)&quot;);                    \
 297     return val;                                                   \
 298   }
 299 
 300 /* Numeric Type Constructor/Getters {{{1 */
 301 /* &lt; private &gt;
 302  * g_variant_new_from_trusted:
 303  * @type: the #GVariantType
 304  * @data: the data to use
 305  * @size: the size of @data
 306  *
 307  * Constructs a new trusted #GVariant instance from the provided data.
 308  * This is used to implement g_variant_new_* for all the basic types.
 309  *
<span class="line-added"> 310  * Note: @data must be backed by memory that is aligned appropriately for the</span>
<span class="line-added"> 311  * @type being loaded. Otherwise this function will internally create a copy of</span>
<span class="line-added"> 312  * the memory (since GLib 2.60) or (in older versions) fail and exit the</span>
<span class="line-added"> 313  * process.</span>
<span class="line-added"> 314  *</span>
 315  * Returns: a new floating #GVariant
 316  */
 317 static GVariant *
 318 g_variant_new_from_trusted (const GVariantType *type,
 319                             gconstpointer       data,
 320                             gsize               size)
 321 {
 322   GVariant *value;
 323   GBytes *bytes;
 324 
 325   bytes = g_bytes_new (data, size);
 326   value = g_variant_new_from_bytes (type, bytes, TRUE);
 327   g_bytes_unref (bytes);
 328 
 329   return value;
 330 }
 331 
 332 /**
 333  * g_variant_new_boolean:
 334  * @value: a #gboolean value
</pre>
<hr />
<pre>
 409  * other than %G_VARIANT_TYPE_BYTE.
 410  *
 411  * Returns: a #guint8
 412  *
 413  * Since: 2.24
 414  **/
 415 NUMERIC_TYPE (BYTE, byte, guint8)
 416 
 417 /**
 418  * g_variant_new_int16:
 419  * @value: a #gint16 value
 420  *
 421  * Creates a new int16 #GVariant instance.
 422  *
 423  * Returns: (transfer none): a floating reference to a new int16 #GVariant instance
 424  *
 425  * Since: 2.24
 426  **/
 427 /**
 428  * g_variant_get_int16:
<span class="line-modified"> 429  * @value: an int16 #GVariant instance</span>
 430  *
 431  * Returns the 16-bit signed integer value of @value.
 432  *
 433  * It is an error to call this function with a @value of any type
 434  * other than %G_VARIANT_TYPE_INT16.
 435  *
 436  * Returns: a #gint16
 437  *
 438  * Since: 2.24
 439  **/
 440 NUMERIC_TYPE (INT16, int16, gint16)
 441 
 442 /**
 443  * g_variant_new_uint16:
 444  * @value: a #guint16 value
 445  *
 446  * Creates a new uint16 #GVariant instance.
 447  *
 448  * Returns: (transfer none): a floating reference to a new uint16 #GVariant instance
 449  *
</pre>
<hr />
<pre>
 459  * other than %G_VARIANT_TYPE_UINT16.
 460  *
 461  * Returns: a #guint16
 462  *
 463  * Since: 2.24
 464  **/
 465 NUMERIC_TYPE (UINT16, uint16, guint16)
 466 
 467 /**
 468  * g_variant_new_int32:
 469  * @value: a #gint32 value
 470  *
 471  * Creates a new int32 #GVariant instance.
 472  *
 473  * Returns: (transfer none): a floating reference to a new int32 #GVariant instance
 474  *
 475  * Since: 2.24
 476  **/
 477 /**
 478  * g_variant_get_int32:
<span class="line-modified"> 479  * @value: an int32 #GVariant instance</span>
 480  *
 481  * Returns the 32-bit signed integer value of @value.
 482  *
 483  * It is an error to call this function with a @value of any type
 484  * other than %G_VARIANT_TYPE_INT32.
 485  *
 486  * Returns: a #gint32
 487  *
 488  * Since: 2.24
 489  **/
 490 NUMERIC_TYPE (INT32, int32, gint32)
 491 
 492 /**
 493  * g_variant_new_uint32:
 494  * @value: a #guint32 value
 495  *
 496  * Creates a new uint32 #GVariant instance.
 497  *
 498  * Returns: (transfer none): a floating reference to a new uint32 #GVariant instance
 499  *
</pre>
<hr />
<pre>
 509  * other than %G_VARIANT_TYPE_UINT32.
 510  *
 511  * Returns: a #guint32
 512  *
 513  * Since: 2.24
 514  **/
 515 NUMERIC_TYPE (UINT32, uint32, guint32)
 516 
 517 /**
 518  * g_variant_new_int64:
 519  * @value: a #gint64 value
 520  *
 521  * Creates a new int64 #GVariant instance.
 522  *
 523  * Returns: (transfer none): a floating reference to a new int64 #GVariant instance
 524  *
 525  * Since: 2.24
 526  **/
 527 /**
 528  * g_variant_get_int64:
<span class="line-modified"> 529  * @value: an int64 #GVariant instance</span>
 530  *
 531  * Returns the 64-bit signed integer value of @value.
 532  *
 533  * It is an error to call this function with a @value of any type
 534  * other than %G_VARIANT_TYPE_INT64.
 535  *
 536  * Returns: a #gint64
 537  *
 538  * Since: 2.24
 539  **/
 540 NUMERIC_TYPE (INT64, int64, gint64)
 541 
 542 /**
 543  * g_variant_new_uint64:
 544  * @value: a #guint64 value
 545  *
 546  * Creates a new uint64 #GVariant instance.
 547  *
 548  * Returns: (transfer none): a floating reference to a new uint64 #GVariant instance
 549  *
</pre>
<hr />
<pre>
 925   gboolean trusted;
 926 
 927   g_return_val_if_fail (key != NULL &amp;&amp; value != NULL, NULL);
 928   g_return_val_if_fail (!g_variant_is_container (key), NULL);
 929 
 930   children = g_new (GVariant *, 2);
 931   children[0] = g_variant_ref_sink (key);
 932   children[1] = g_variant_ref_sink (value);
 933   trusted = g_variant_is_trusted (key) &amp;&amp; g_variant_is_trusted (value);
 934 
 935   dict_type = g_variant_make_dict_entry_type (key, value);
 936   value = g_variant_new_from_children (dict_type, children, 2, trusted);
 937   g_variant_type_free (dict_type);
 938 
 939   return value;
 940 }
 941 
 942 /**
 943  * g_variant_lookup: (skip)
 944  * @dictionary: a dictionary #GVariant
<span class="line-modified"> 945  * @key: the key to look up in the dictionary</span>
 946  * @format_string: a GVariant format string
 947  * @...: the arguments to unpack the value into
 948  *
 949  * Looks up a value in a dictionary #GVariant.
 950  *
 951  * This function is a wrapper around g_variant_lookup_value() and
 952  * g_variant_get().  In the case that %NULL would have been returned,
 953  * this function returns %FALSE.  Otherwise, it unpacks the returned
 954  * value and returns %TRUE.
 955  *
 956  * @format_string determines the C types that are used for unpacking
 957  * the values and also determines if the values are copied or borrowed,
 958  * see the section on
 959  * [GVariant format strings][gvariant-format-strings-pointers].
 960  *
 961  * This function is currently implemented with a linear scan.  If you
 962  * plan to do many lookups then #GVariantDict may be more efficient.
 963  *
 964  * Returns: %TRUE if a value was unpacked
 965  *
</pre>
<hr />
<pre>
 983 
 984   if (value)
 985     {
 986       va_list ap;
 987 
 988       va_start (ap, format_string);
 989       g_variant_get_va (value, format_string, NULL, &amp;ap);
 990       g_variant_unref (value);
 991       va_end (ap);
 992 
 993       return TRUE;
 994     }
 995 
 996   else
 997     return FALSE;
 998 }
 999 
1000 /**
1001  * g_variant_lookup_value:
1002  * @dictionary: a dictionary #GVariant
<span class="line-modified">1003  * @key: the key to look up in the dictionary</span>
1004  * @expected_type: (nullable): a #GVariantType, or %NULL
1005  *
1006  * Looks up a value in a dictionary #GVariant.
1007  *
1008  * This function works with dictionaries of the type a{s*} (and equally
1009  * well with type a{o*}, but we only further discuss the string case
1010  * for sake of clarity).
1011  *
1012  * In the event that @dictionary has the type a{sv}, the @expected_type
1013  * string specifies what type of value is expected to be inside of the
1014  * variant. If the value inside the variant has a different type then
1015  * %NULL is returned. In the event that @dictionary has a value type other
<span class="line-modified">1016  * than v then @expected_type must directly match the value type and it is</span>
1017  * used to unpack the value directly or an error occurs.
1018  *
1019  * In either case, if @key is not found in @dictionary, %NULL is returned.
1020  *
1021  * If the key is found and the value has the correct type, it is
1022  * returned.  If @expected_type was specified then any non-%NULL return
1023  * value will have this type.
1024  *
1025  * This function is currently implemented with a linear scan.  If you
1026  * plan to do many lookups then #GVariantDict may be more efficient.
1027  *
1028  * Returns: (transfer full): the value of the dictionary key, or %NULL
1029  *
1030  * Since: 2.28
1031  */
1032 GVariant *
1033 g_variant_lookup_value (GVariant           *dictionary,
1034                         const gchar        *key,
1035                         const GVariantType *expected_type)
1036 {
</pre>
<hr />
<pre>
1535 
1536 /**
1537  * g_variant_new_strv:
1538  * @strv: (array length=length) (element-type utf8): an array of strings
1539  * @length: the length of @strv, or -1
1540  *
1541  * Constructs an array of strings #GVariant from the given array of
1542  * strings.
1543  *
1544  * If @length is -1 then @strv is %NULL-terminated.
1545  *
1546  * Returns: (transfer none): a new floating #GVariant instance
1547  *
1548  * Since: 2.24
1549  **/
1550 GVariant *
1551 g_variant_new_strv (const gchar * const *strv,
1552                     gssize               length)
1553 {
1554   GVariant **strings;
<span class="line-modified">1555   gsize i, length_unsigned;</span>
1556 
1557   g_return_val_if_fail (length == 0 || strv != NULL, NULL);
1558 
1559   if (length &lt; 0)
1560     length = g_strv_length ((gchar **) strv);
<span class="line-added">1561   length_unsigned = length;</span>
1562 
<span class="line-modified">1563   strings = g_new (GVariant *, length_unsigned);</span>
<span class="line-modified">1564   for (i = 0; i &lt; length_unsigned; i++)</span>
1565     strings[i] = g_variant_ref_sink (g_variant_new_string (strv[i]));
1566 
1567   return g_variant_new_from_children (G_VARIANT_TYPE_STRING_ARRAY,
<span class="line-modified">1568                                       strings, length_unsigned, TRUE);</span>
1569 }
1570 
1571 /**
1572  * g_variant_get_strv:
1573  * @value: an array of strings #GVariant
1574  * @length: (out) (optional): the length of the result, or %NULL
1575  *
1576  * Gets the contents of an array of strings #GVariant.  This call
1577  * makes a shallow copy; the return result should be released with
1578  * g_free(), but the individual strings must not be modified.
1579  *
1580  * If @length is non-%NULL then the number of elements in the result
1581  * is stored there.  In any case, the resulting array will be
1582  * %NULL-terminated.
1583  *
1584  * For an empty array, @length will be set to 0 and a pointer to a
1585  * %NULL pointer will be returned.
1586  *
1587  * Returns: (array length=length zero-terminated=1) (transfer container): an array of constant strings
1588  *
</pre>
<hr />
<pre>
1672  * @strv: (array length=length) (element-type utf8): an array of strings
1673  * @length: the length of @strv, or -1
1674  *
1675  * Constructs an array of object paths #GVariant from the given array of
1676  * strings.
1677  *
1678  * Each string must be a valid #GVariant object path; see
1679  * g_variant_is_object_path().
1680  *
1681  * If @length is -1 then @strv is %NULL-terminated.
1682  *
1683  * Returns: (transfer none): a new floating #GVariant instance
1684  *
1685  * Since: 2.30
1686  **/
1687 GVariant *
1688 g_variant_new_objv (const gchar * const *strv,
1689                     gssize               length)
1690 {
1691   GVariant **strings;
<span class="line-modified">1692   gsize i, length_unsigned;</span>
1693 
1694   g_return_val_if_fail (length == 0 || strv != NULL, NULL);
1695 
1696   if (length &lt; 0)
1697     length = g_strv_length ((gchar **) strv);
<span class="line-added">1698   length_unsigned = length;</span>
1699 
<span class="line-modified">1700   strings = g_new (GVariant *, length_unsigned);</span>
<span class="line-modified">1701   for (i = 0; i &lt; length_unsigned; i++)</span>
1702     strings[i] = g_variant_ref_sink (g_variant_new_object_path (strv[i]));
1703 
1704   return g_variant_new_from_children (G_VARIANT_TYPE_OBJECT_PATH_ARRAY,
<span class="line-modified">1705                                       strings, length_unsigned, TRUE);</span>
1706 }
1707 
1708 /**
1709  * g_variant_get_objv:
1710  * @value: an array of object paths #GVariant
1711  * @length: (out) (optional): the length of the result, or %NULL
1712  *
1713  * Gets the contents of an array of object paths #GVariant.  This call
1714  * makes a shallow copy; the return result should be released with
1715  * g_free(), but the individual strings must not be modified.
1716  *
1717  * If @length is non-%NULL then the number of elements in the result
1718  * is stored there.  In any case, the resulting array will be
1719  * %NULL-terminated.
1720  *
1721  * For an empty array, @length will be set to 0 and a pointer to a
1722  * %NULL pointer will be returned.
1723  *
1724  * Returns: (array length=length zero-terminated=1) (transfer container): an array of constant strings
1725  *
</pre>
<hr />
<pre>
1913 
1914 /**
1915  * g_variant_new_bytestring_array:
1916  * @strv: (array length=length): an array of strings
1917  * @length: the length of @strv, or -1
1918  *
1919  * Constructs an array of bytestring #GVariant from the given array of
1920  * strings.
1921  *
1922  * If @length is -1 then @strv is %NULL-terminated.
1923  *
1924  * Returns: (transfer none): a new floating #GVariant instance
1925  *
1926  * Since: 2.26
1927  **/
1928 GVariant *
1929 g_variant_new_bytestring_array (const gchar * const *strv,
1930                                 gssize               length)
1931 {
1932   GVariant **strings;
<span class="line-modified">1933   gsize i, length_unsigned;</span>
1934 
1935   g_return_val_if_fail (length == 0 || strv != NULL, NULL);
1936 
1937   if (length &lt; 0)
1938     length = g_strv_length ((gchar **) strv);
<span class="line-added">1939   length_unsigned = length;</span>
1940 
<span class="line-modified">1941   strings = g_new (GVariant *, length_unsigned);</span>
<span class="line-modified">1942   for (i = 0; i &lt; length_unsigned; i++)</span>
1943     strings[i] = g_variant_ref_sink (g_variant_new_bytestring (strv[i]));
1944 
1945   return g_variant_new_from_children (G_VARIANT_TYPE_BYTESTRING_ARRAY,
<span class="line-modified">1946                                       strings, length_unsigned, TRUE);</span>
1947 }
1948 
1949 /**
1950  * g_variant_get_bytestring_array:
1951  * @value: an array of array of bytes #GVariant (&#39;aay&#39;)
1952  * @length: (out) (optional): the length of the result, or %NULL
1953  *
1954  * Gets the contents of an array of array of bytes #GVariant.  This call
1955  * makes a shallow copy; the return result should be released with
1956  * g_free(), but the individual strings must not be modified.
1957  *
1958  * If @length is non-%NULL then the number of elements in the result is
1959  * stored there.  In any case, the resulting array will be
1960  * %NULL-terminated.
1961  *
1962  * For an empty array, @length will be set to 0 and a pointer to a
1963  * %NULL pointer will be returned.
1964  *
1965  * Returns: (array length=length) (transfer container): an array of constant strings
1966  *
</pre>
<hr />
<pre>
2270               break;
2271 
2272           /* first nul byte is the last byte -&gt; it&#39;s a byte string. */
2273           if (i == size - 1)
2274             {
2275               gchar *escaped = g_strescape (str, NULL);
2276 
2277               /* use double quotes only if a &#39; is in the string */
2278               if (strchr (str, &#39;\&#39;&#39;))
2279                 g_string_append_printf (string, &quot;b\&quot;%s\&quot;&quot;, escaped);
2280               else
2281                 g_string_append_printf (string, &quot;b&#39;%s&#39;&quot;, escaped);
2282 
2283               g_free (escaped);
2284               break;
2285             }
2286 
2287           else
2288             {
2289               /* fall through and handle normally... */
<span class="line-modified">2290             }</span>
2291         }
2292 
2293       /*
2294        * if the first two characters are &#39;a{&#39; then it&#39;s an array of
2295        * dictionary entries (ie: a dictionary) so we print that
2296        * differently.
2297        */
2298       if (g_variant_get_type_string (value)[1] == &#39;{&#39;)
2299         /* dictionary */
2300         {
2301           const gchar *comma = &quot;&quot;;
2302           gsize n, i;
2303 
2304           if ((n = g_variant_n_children (value)) == 0)
2305             {
2306               if (type_annotate)
2307                 g_string_append_printf (string, &quot;@%s &quot;,
2308                                         g_variant_get_type_string (value));
2309               g_string_append (string, &quot;{}&quot;);
2310               break;
</pre>
<hr />
<pre>
3948                      GVariant     *from_asv)
3949 {
3950   GVariantIter iter;
3951   gchar *key;
3952   GVariant *value;
3953 
3954   GVSD(dict)-&gt;values = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, (GDestroyNotify) g_variant_unref);
3955   GVSD(dict)-&gt;magic = GVSD_MAGIC;
3956 
3957   if (from_asv)
3958     {
3959       g_variant_iter_init (&amp;iter, from_asv);
3960       while (g_variant_iter_next (&amp;iter, &quot;{sv}&quot;, &amp;key, &amp;value))
3961         g_hash_table_insert (GVSD(dict)-&gt;values, key, value);
3962     }
3963 }
3964 
3965 /**
3966  * g_variant_dict_lookup:
3967  * @dict: a #GVariantDict
<span class="line-modified">3968  * @key: the key to look up in the dictionary</span>
3969  * @format_string: a GVariant format string
3970  * @...: the arguments to unpack the value into
3971  *
3972  * Looks up a value in a #GVariantDict.
3973  *
3974  * This function is a wrapper around g_variant_dict_lookup_value() and
3975  * g_variant_get().  In the case that %NULL would have been returned,
3976  * this function returns %FALSE.  Otherwise, it unpacks the returned
3977  * value and returns %TRUE.
3978  *
3979  * @format_string determines the C types that are used for unpacking the
3980  * values and also determines if the values are copied or borrowed, see the
3981  * section on [GVariant format strings][gvariant-format-strings-pointers].
3982  *
3983  * Returns: %TRUE if a value was unpacked
3984  *
3985  * Since: 2.40
3986  **/
3987 gboolean
3988 g_variant_dict_lookup (GVariantDict *dict,
</pre>
<hr />
<pre>
3995 
3996   g_return_val_if_fail (ensure_valid_dict (dict), FALSE);
3997   g_return_val_if_fail (key != NULL, FALSE);
3998   g_return_val_if_fail (format_string != NULL, FALSE);
3999 
4000   value = g_hash_table_lookup (GVSD(dict)-&gt;values, key);
4001 
4002   if (value == NULL || !g_variant_check_format_string (value, format_string, FALSE))
4003     return FALSE;
4004 
4005   va_start (ap, format_string);
4006   g_variant_get_va (value, format_string, NULL, &amp;ap);
4007   va_end (ap);
4008 
4009   return TRUE;
4010 }
4011 
4012 /**
4013  * g_variant_dict_lookup_value:
4014  * @dict: a #GVariantDict
<span class="line-modified">4015  * @key: the key to look up in the dictionary</span>
4016  * @expected_type: (nullable): a #GVariantType, or %NULL
4017  *
4018  * Looks up a value in a #GVariantDict.
4019  *
4020  * If @key is not found in @dictionary, %NULL is returned.
4021  *
4022  * The @expected_type string specifies what type of value is expected.
4023  * If the value associated with @key has a different type then %NULL is
4024  * returned.
4025  *
4026  * If the key is found and the value has the correct type, it is
4027  * returned.  If @expected_type was specified then any non-%NULL return
4028  * value will have this type.
4029  *
4030  * Returns: (transfer full): the value of the dictionary key, or %NULL
4031  *
4032  * Since: 2.40
4033  **/
4034 GVariant *
4035 g_variant_dict_lookup_value (GVariantDict       *dict,
4036                              const gchar        *key,
4037                              const GVariantType *expected_type)
4038 {
4039   GVariant *result;
4040 
4041   g_return_val_if_fail (ensure_valid_dict (dict), NULL);
4042   g_return_val_if_fail (key != NULL, NULL);
4043 
4044   result = g_hash_table_lookup (GVSD(dict)-&gt;values, key);
4045 
4046   if (result &amp;&amp; (!expected_type || g_variant_is_of_type (result, expected_type)))
4047     return g_variant_ref (result);
4048 
4049   return NULL;
4050 }
4051 
4052 /**
4053  * g_variant_dict_contains:
4054  * @dict: a #GVariantDict
<span class="line-modified">4055  * @key: the key to look up in the dictionary</span>
4056  *
4057  * Checks if @key exists in @dict.
4058  *
4059  * Returns: %TRUE if @key is in @dict
4060  *
4061  * Since: 2.40
4062  **/
4063 gboolean
4064 g_variant_dict_contains (GVariantDict *dict,
4065                          const gchar  *key)
4066 {
4067   g_return_val_if_fail (ensure_valid_dict (dict), FALSE);
4068   g_return_val_if_fail (key != NULL, FALSE);
4069 
4070   return g_hash_table_contains (GVSD(dict)-&gt;values, key);
4071 }
4072 
4073 /**
4074  * g_variant_dict_insert:
4075  * @dict: a #GVariantDict
</pre>
<hr />
<pre>
4324           return FALSE;
4325 
4326       next_char(); /* consume &#39;)&#39; */
4327       break;
4328 
4329     case &#39;{&#39;:
4330       c = next_char();
4331 
4332       if (c == &#39;&amp;&#39;)
4333         {
4334           c = next_char ();
4335 
4336           if (c != &#39;s&#39; &amp;&amp; c != &#39;o&#39; &amp;&amp; c != &#39;g&#39;)
4337             return FALSE;
4338         }
4339       else
4340         {
4341           if (c == &#39;@&#39;)
4342             c = next_char ();
4343 
<span class="line-modified">4344           /* ISO/IEC 9899:1999 (C99) 7.21.5.2:</span>
4345            *    The terminating null character is considered to be
4346            *    part of the string.
4347            */
4348           if (c != &#39;\0&#39; &amp;&amp; strchr (&quot;bynqiuxthdsog?&quot;, c) == NULL)
4349             return FALSE;
4350         }
4351 
4352       if (!g_variant_format_string_scan (string, limit, &amp;string))
4353         return FALSE;
4354 
4355       if (next_char() != &#39;}&#39;)
4356         return FALSE;
4357 
4358       break;
4359 
4360     case &#39;^&#39;:
4361       if ((c = next_char()) == &#39;a&#39;)
4362         {
4363           if ((c = next_char()) == &#39;&amp;&#39;)
4364             {
</pre>
<hr />
<pre>
4676          str[0] == &#39;r&#39; || str[0] == &#39;v&#39; || str[0] == &#39;&amp;&#39;;
4677 }
4678 
4679 /* Single non-null pointer (&quot;nnp&quot;) {{{2 */
4680 static void
4681 g_variant_valist_free_nnp (const gchar *str,
4682                            gpointer     ptr)
4683 {
4684   switch (*str)
4685     {
4686     case &#39;a&#39;:
4687       g_variant_iter_free (ptr);
4688       break;
4689 
4690     case &#39;^&#39;:
4691       if (g_str_has_suffix (str, &quot;y&quot;))
4692         {
4693           if (str[2] != &#39;a&#39;) /* &#39;^a&amp;ay&#39;, &#39;^ay&#39; */
4694             g_free (ptr);
4695           else if (str[1] == &#39;a&#39;) /* &#39;^aay&#39; */
<span class="line-modified">4696             g_strfreev (ptr);</span>
4697           break; /* &#39;^&amp;ay&#39; */
4698         }
4699       else if (str[2] != &#39;&amp;&#39;) /* &#39;^as&#39;, &#39;^ao&#39; */
4700         g_strfreev (ptr);
4701       else                      /* &#39;^a&amp;s&#39;, &#39;^a&amp;o&#39; */
4702         g_free (ptr);
4703       break;
4704 
4705     case &#39;s&#39;:
4706     case &#39;o&#39;:
4707     case &#39;g&#39;:
4708       g_free (ptr);
4709       break;
4710 
4711     case &#39;@&#39;:
4712     case &#39;*&#39;:
4713     case &#39;?&#39;:
4714     case &#39;v&#39;:
4715       g_variant_unref (ptr);
4716       break;
</pre>
<hr />
<pre>
6000  * @data is not modified by this function and must remain valid with an
6001  * unchanging value until such a time as @notify is called with
6002  * @user_data.  If the contents of @data change before that time then
6003  * the result is undefined.
6004  *
6005  * If @data is trusted to be serialised data in normal form then
6006  * @trusted should be %TRUE.  This applies to serialised data created
6007  * within this process or read from a trusted location on the disk (such
6008  * as a file installed in /usr/lib alongside your application).  You
6009  * should set trusted to %FALSE if @data is read from the network, a
6010  * file in the user&#39;s home directory, etc.
6011  *
6012  * If @data was not stored in this machine&#39;s native endianness, any multi-byte
6013  * numeric values in the returned variant will also be in non-native
6014  * endianness. g_variant_byteswap() can be used to recover the original values.
6015  *
6016  * @notify will be called with @user_data when @data is no longer
6017  * needed.  The exact time of this call is unspecified and might even be
6018  * before this function returns.
6019  *
<span class="line-added">6020  * Note: @data must be backed by memory that is aligned appropriately for the</span>
<span class="line-added">6021  * @type being loaded. Otherwise this function will internally create a copy of</span>
<span class="line-added">6022  * the memory (since GLib 2.60) or (in older versions) fail and exit the</span>
<span class="line-added">6023  * process.</span>
<span class="line-added">6024  *</span>
6025  * Returns: (transfer none): a new floating #GVariant of type @type
6026  *
6027  * Since: 2.24
6028  **/
6029 GVariant *
6030 g_variant_new_from_data (const GVariantType *type,
6031                          gconstpointer       data,
6032                          gsize               size,
6033                          gboolean            trusted,
6034                          GDestroyNotify      notify,
6035                          gpointer            user_data)
6036 {
6037   GVariant *value;
6038   GBytes *bytes;
6039 
6040   g_return_val_if_fail (g_variant_type_is_definite (type), NULL);
6041   g_return_val_if_fail (data != NULL || size == 0, NULL);
6042 
6043   if (notify)
6044     bytes = g_bytes_new_with_free_func (data, size, notify, user_data);
</pre>
</td>
</tr>
</table>
<center><a href="gvariant-serialiser.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gvariant.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>