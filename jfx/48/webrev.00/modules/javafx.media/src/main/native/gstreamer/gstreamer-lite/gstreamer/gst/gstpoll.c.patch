diff a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstpoll.c b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstpoll.c
--- a/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstpoll.c
+++ b/modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstpoll.c
@@ -35,11 +35,11 @@
  * later calling gst_poll_set_controllable()).
  *
  * New file descriptors are added to the set using gst_poll_add_fd(), and
  * removed using gst_poll_remove_fd(). Controlling which file descriptors
  * should be waited for to become readable and/or writable are done using
- * gst_poll_fd_ctl_read() and gst_poll_fd_ctl_write().
+ * gst_poll_fd_ctl_read(), gst_poll_fd_ctl_write() and gst_poll_fd_ctl_pri().
  *
  * Use gst_poll_wait() to wait for the file descriptors to actually become
  * readable and/or writable, or to timeout if no file descriptor is available
  * in time. The wait can be controlled by calling gst_poll_restart() and
  * gst_poll_set_flushing().
@@ -309,15 +309,15 @@
   g_mutex_lock (&set->lock);
 
   if (set->control_pending > 0) {
     /* release, only if this was the last pending. */
     if (set->control_pending == 1) {
-    GST_LOG ("%p: release", set);
+      GST_LOG ("%p: release", set);
       result = release_event (set);
     } else {
       result = TRUE;
-  }
+    }
 
     if (result) {
       set->control_pending--;
     }
   } else {
@@ -1019,13 +1019,13 @@
   if (idx >= 0) {
 #ifndef G_OS_WIN32
     struct pollfd *pfd = &g_array_index (set->fds, struct pollfd, idx);
 
     if (active)
-      pfd->events |= (POLLIN | POLLPRI);
+      pfd->events |= POLLIN;
     else
-      pfd->events &= ~(POLLIN | POLLPRI);
+      pfd->events &= ~POLLIN;
 #else
     gst_poll_update_winsock_event_mask (set, idx, FD_READ | FD_ACCEPT, active);
 #endif
     MARK_REBUILD (set);
   } else {
@@ -1062,10 +1062,63 @@
   g_mutex_unlock (&set->lock);
 
   return ret;
 }
 
+/**
+ * gst_poll_fd_ctl_pri:
+ * @set: a file descriptor set.
+ * @fd: a file descriptor.
+ * @active: a new status.
+ *
+ * Control whether the descriptor @fd in @set will be monitored for
+ * exceptional conditions (POLLPRI).
+ *
+ * Not implemented on Windows (will just return %FALSE there).
+ *
+ * Returns: %TRUE if the descriptor was successfully updated.
+ *
+ * Since: 1.16
+ */
+gboolean
+gst_poll_fd_ctl_pri (GstPoll * set, GstPollFD * fd, gboolean active)
+{
+#ifdef G_OS_WIN32
+  return FALSE;
+#else
+  gint idx;
+
+  g_return_val_if_fail (set != NULL, FALSE);
+  g_return_val_if_fail (fd != NULL, FALSE);
+  g_return_val_if_fail (fd->fd >= 0, FALSE);
+
+  GST_DEBUG ("%p: fd (fd:%d, idx:%d), active : %d", set,
+      fd->fd, fd->idx, active);
+
+  g_mutex_lock (&set->lock);
+
+  idx = find_index (set->fds, fd);
+  if (idx >= 0) {
+    struct pollfd *pfd = &g_array_index (set->fds, struct pollfd, idx);
+
+    if (active)
+      pfd->events |= POLLPRI;
+    else
+      pfd->events &= ~POLLPRI;
+
+    GST_LOG ("%p: pfd->events now %d (POLLPRI:%d)", set, pfd->events, POLLOUT);
+    MARK_REBUILD (set);
+  } else {
+    GST_WARNING ("%p: couldn't find fd !", set);
+  }
+
+  g_mutex_unlock (&set->lock);
+
+  return idx >= 0;
+#endif
+}
+
 /**
  * gst_poll_fd_ignored:
  * @set: a file descriptor set.
  * @fd: a file descriptor.
  *
@@ -1199,11 +1252,11 @@
   idx = find_index (set->active_fds, fd);
   if (idx >= 0) {
 #ifndef G_OS_WIN32
     struct pollfd *pfd = &g_array_index (set->active_fds, struct pollfd, idx);
 
-    res = (pfd->revents & (POLLIN | POLLPRI)) != 0;
+    res = (pfd->revents & POLLIN) != 0;
 #else
     WinsockFd *wfd = &g_array_index (set->active_fds, WinsockFd, idx);
 
     res = (wfd->events.lNetworkEvents & (FD_READ | FD_ACCEPT)) != 0;
 #endif
@@ -1282,10 +1335,54 @@
   GST_DEBUG ("%p: fd (fd:%d, idx:%d) %d", set, fd->fd, fd->idx, res);
 
   return res;
 }
 
+/**
+ * gst_poll_fd_has_pri:
+ * @set: a file descriptor set.
+ * @fd: a file descriptor.
+ *
+ * Check if @fd in @set has an exceptional condition (POLLPRI).
+ *
+ * Not implemented on Windows (will just return %FALSE there).
+ *
+ * Returns: %TRUE if the descriptor has an exceptional condition.
+ *
+ * Since: 1.16
+ */
+gboolean
+gst_poll_fd_has_pri (const GstPoll * set, GstPollFD * fd)
+{
+#ifdef G_OS_WIN32
+  return FALSE;
+#else
+  gboolean res = FALSE;
+  gint idx;
+
+  g_return_val_if_fail (set != NULL, FALSE);
+  g_return_val_if_fail (fd != NULL, FALSE);
+  g_return_val_if_fail (fd->fd >= 0, FALSE);
+
+  g_mutex_lock (&((GstPoll *) set)->lock);
+
+  idx = find_index (set->active_fds, fd);
+  if (idx >= 0) {
+    struct pollfd *pfd = &g_array_index (set->active_fds, struct pollfd, idx);
+
+    res = (pfd->revents & POLLPRI) != 0;
+  } else {
+    GST_WARNING ("%p: couldn't find fd !", set);
+  }
+  g_mutex_unlock (&((GstPoll *) set)->lock);
+
+  GST_DEBUG ("%p: fd (fd:%d, idx:%d) %d", set, fd->fd, fd->idx, res);
+
+  return res;
+#endif
+}
+
 /**
  * gst_poll_wait:
  * @set: a #GstPoll.
  * @timeout: a timeout in nanoseconds.
  *
