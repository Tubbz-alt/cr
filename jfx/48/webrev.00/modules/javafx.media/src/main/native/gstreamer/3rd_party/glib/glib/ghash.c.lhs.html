<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/ghash.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General Public
  15  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  */
  17 
  18 /*
  19  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  20  * file for a list of people on the GLib Team.  See the ChangeLog
  21  * files for a list of changes.  These files are distributed with
  22  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  23  */
  24 
  25 /*
  26  * MT safe
  27  */
  28 
  29 #include &quot;config.h&quot;
  30 
  31 #include &lt;string.h&gt;  /* memset */
  32 
  33 #include &quot;ghash.h&quot;
<a name="1" id="anc1"></a><span class="line-modified">  34 </span>
  35 #include &quot;glib-private.h&quot;
  36 #include &quot;gstrfuncs.h&quot;
  37 #include &quot;gatomic.h&quot;
  38 #include &quot;gtestutils.h&quot;
  39 #include &quot;gslice.h&quot;
  40 #include &quot;grefcount.h&quot;
<a name="2" id="anc2"></a>





















  41 
  42 /**
  43  * SECTION:hash_tables
  44  * @title: Hash Tables
  45  * @short_description: associations between keys and values so that
  46  *     given a key the value can be found quickly
  47  *
  48  * A #GHashTable provides associations between keys and values which is
  49  * optimized so that given a key, the associated value can be found
  50  * very quickly.
  51  *
  52  * Note that neither keys nor values are copied when inserted into the
  53  * #GHashTable, so they must exist for the lifetime of the #GHashTable.
  54  * This means that the use of static strings is OK, but temporary
  55  * strings (i.e. those created in buffers and those returned by GTK+
  56  * widgets) should be copied with g_strdup() before being inserted.
  57  *
  58  * If keys or values are dynamically allocated, you must be careful to
  59  * ensure that they are freed when they are removed from the
  60  * #GHashTable, and also when they are overwritten by new insertions
  61  * into the #GHashTable. It is also not advisable to mix static strings
  62  * and dynamically-allocated strings in a #GHashTable, because it then
  63  * becomes difficult to determine whether the string should be freed.
  64  *
  65  * To create a #GHashTable, use g_hash_table_new().
  66  *
  67  * To insert a key and value into a #GHashTable, use
  68  * g_hash_table_insert().
  69  *
<a name="3" id="anc3"></a><span class="line-modified">  70  * To lookup a value corresponding to a given key, use</span>
  71  * g_hash_table_lookup() and g_hash_table_lookup_extended().
  72  *
  73  * g_hash_table_lookup_extended() can also be used to simply
  74  * check if a key is present in the hash table.
  75  *
  76  * To remove a key and value, use g_hash_table_remove().
  77  *
  78  * To call a function for each key and value pair use
<a name="4" id="anc4"></a><span class="line-modified">  79  * g_hash_table_foreach() or use a iterator to iterate over the</span>
  80  * key/value pairs in the hash table, see #GHashTableIter.
  81  *
  82  * To destroy a #GHashTable use g_hash_table_destroy().
  83  *
  84  * A common use-case for hash tables is to store information about a
  85  * set of keys, without associating any particular value with each
  86  * key. GHashTable optimizes one way of doing so: If you store only
  87  * key-value pairs where key == value, then GHashTable does not
  88  * allocate memory to store the values, which can be a considerable
  89  * space saving, if your set is large. The functions
  90  * g_hash_table_add() and g_hash_table_contains() are designed to be
  91  * used when using #GHashTable this way.
  92  *
  93  * #GHashTable is not designed to be statically initialised with keys and
  94  * values known at compile time. To build a static hash table, use a tool such
  95  * as [gperf](https://www.gnu.org/software/gperf/).
  96  */
  97 
  98 /**
  99  * GHashTable:
 100  *
 101  * The #GHashTable struct is an opaque data structure to represent a
 102  * [Hash Table][glib-Hash-Tables]. It should only be accessed via the
 103  * following functions.
 104  */
 105 
 106 /**
 107  * GHashFunc:
 108  * @key: a key
 109  *
 110  * Specifies the type of the hash function which is passed to
 111  * g_hash_table_new() when a #GHashTable is created.
 112  *
 113  * The function is passed a key and should return a #guint hash value.
 114  * The functions g_direct_hash(), g_int_hash() and g_str_hash() provide
 115  * hash functions which can be used when the key is a #gpointer, #gint*,
 116  * and #gchar* respectively.
 117  *
 118  * g_direct_hash() is also the appropriate hash function for keys
 119  * of the form `GINT_TO_POINTER (n)` (or similar macros).
 120  *
 121  * A good hash functions should produce
 122  * hash values that are evenly distributed over a fairly large range.
 123  * The modulus is taken with the hash table size (a prime number) to
 124  * find the &#39;bucket&#39; to place each key into. The function should also
 125  * be very fast, since it is called for each key lookup.
 126  *
 127  * Note that the hash functions provided by GLib have these qualities,
 128  * but are not particularly robust against manufactured keys that
 129  * cause hash collisions. Therefore, you should consider choosing
 130  * a more secure hash function when using a GHashTable with keys
 131  * that originate in untrusted data (such as HTTP requests).
 132  * Using g_str_hash() in that situation might make your application
 133  * vulerable to
 134  * [Algorithmic Complexity Attacks](https://lwn.net/Articles/474912/).
 135  *
 136  * The key to choosing a good hash is unpredictability.  Even
 137  * cryptographic hashes are very easy to find collisions for when the
 138  * remainder is taken modulo a somewhat predictable prime number.  There
 139  * must be an element of randomness that an attacker is unable to guess.
 140  *
 141  * Returns: the hash value corresponding to the key
 142  */
 143 
 144 /**
 145  * GHFunc:
 146  * @key: a key
 147  * @value: the value corresponding to the key
 148  * @user_data: user data passed to g_hash_table_foreach()
 149  *
 150  * Specifies the type of the function passed to g_hash_table_foreach().
 151  * It is called with each key/value pair, together with the @user_data
 152  * parameter which is passed to g_hash_table_foreach().
 153  */
 154 
 155 /**
 156  * GHRFunc:
 157  * @key: a key
 158  * @value: the value associated with the key
 159  * @user_data: user data passed to g_hash_table_remove()
 160  *
 161  * Specifies the type of the function passed to
 162  * g_hash_table_foreach_remove(). It is called with each key/value
 163  * pair, together with the @user_data parameter passed to
 164  * g_hash_table_foreach_remove(). It should return %TRUE if the
 165  * key/value pair should be removed from the #GHashTable.
 166  *
 167  * Returns: %TRUE if the key/value pair should be removed from the
 168  *     #GHashTable
 169  */
 170 
 171 /**
 172  * GEqualFunc:
 173  * @a: a value
 174  * @b: a value to compare with
 175  *
 176  * Specifies the type of a function used to test two values for
 177  * equality. The function should return %TRUE if both values are equal
 178  * and %FALSE otherwise.
 179  *
 180  * Returns: %TRUE if @a = @b; %FALSE otherwise
 181  */
 182 
 183 /**
 184  * GHashTableIter:
 185  *
 186  * A GHashTableIter structure represents an iterator that can be used
 187  * to iterate over the elements of a #GHashTable. GHashTableIter
 188  * structures are typically allocated on the stack and then initialized
 189  * with g_hash_table_iter_init().
 190  */
 191 
 192 /**
 193  * g_hash_table_freeze:
 194  * @hash_table: a #GHashTable
 195  *
 196  * This function is deprecated and will be removed in the next major
 197  * release of GLib. It does nothing.
 198  */
 199 
 200 /**
 201  * g_hash_table_thaw:
 202  * @hash_table: a #GHashTable
 203  *
 204  * This function is deprecated and will be removed in the next major
 205  * release of GLib. It does nothing.
 206  */
 207 
 208 #define HASH_TABLE_MIN_SHIFT 3  /* 1 &lt;&lt; 3 == 8 buckets */
 209 
 210 #define UNUSED_HASH_VALUE 0
 211 #define TOMBSTONE_HASH_VALUE 1
 212 #define HASH_IS_UNUSED(h_) ((h_) == UNUSED_HASH_VALUE)
 213 #define HASH_IS_TOMBSTONE(h_) ((h_) == TOMBSTONE_HASH_VALUE)
 214 #define HASH_IS_REAL(h_) ((h_) &gt;= 2)
 215 
<a name="5" id="anc5"></a>











 216 struct _GHashTable
 217 {
<a name="6" id="anc6"></a><span class="line-modified"> 218   gint             size;</span>
 219   gint             mod;
 220   guint            mask;
 221   gint             nnodes;
 222   gint             noccupied;  /* nnodes + tombstones */
 223 
<a name="7" id="anc7"></a><span class="line-modified"> 224   gpointer        *keys;</span>



 225   guint           *hashes;
<a name="8" id="anc8"></a><span class="line-modified"> 226   gpointer        *values;</span>
 227 
 228   GHashFunc        hash_func;
 229   GEqualFunc       key_equal_func;
 230   gatomicrefcount  ref_count;
 231 #ifndef G_DISABLE_ASSERT
 232   /*
 233    * Tracks the structure of the hash table, not its contents: is only
 234    * incremented when a node is added or removed (is not incremented
 235    * when the key or data of a node is modified).
 236    */
 237   int              version;
 238 #endif
 239   GDestroyNotify   key_destroy_func;
 240   GDestroyNotify   value_destroy_func;
 241 };
 242 
 243 typedef struct
 244 {
 245   GHashTable  *hash_table;
 246   gpointer     dummy1;
 247   gpointer     dummy2;
<a name="9" id="anc9"></a><span class="line-modified"> 248   int          position;</span>
 249   gboolean     dummy3;
<a name="10" id="anc10"></a><span class="line-modified"> 250   int          version;</span>
 251 } RealIter;
 252 
 253 G_STATIC_ASSERT (sizeof (GHashTableIter) == sizeof (RealIter));
<a name="11" id="anc11"></a><span class="line-modified"> 254 G_STATIC_ASSERT (_g_alignof (GHashTableIter) &gt;= _g_alignof (RealIter));</span>
 255 
 256 /* Each table size has an associated prime modulo (the first prime
 257  * lower than the table size) used to find the initial bucket. Probing
 258  * then works modulo 2^n. The prime modulo is necessary to get a
 259  * good distribution with poor hash functions.
 260  */
 261 static const gint prime_mod [] =
 262 {
 263   1,          /* For 1 &lt;&lt; 0 */
 264   2,
 265   3,
 266   7,
 267   13,
 268   31,
 269   61,
 270   127,
 271   251,
 272   509,
 273   1021,
 274   2039,
 275   4093,
 276   8191,
 277   16381,
 278   32749,
 279   65521,      /* For 1 &lt;&lt; 16 */
 280   131071,
 281   262139,
 282   524287,
 283   1048573,
 284   2097143,
 285   4194301,
 286   8388593,
 287   16777213,
 288   33554393,
 289   67108859,
 290   134217689,
 291   268435399,
 292   536870909,
 293   1073741789,
 294   2147483647  /* For 1 &lt;&lt; 31 */
 295 };
 296 
 297 static void
 298 g_hash_table_set_shift (GHashTable *hash_table, gint shift)
 299 {
<a name="12" id="anc12"></a><span class="line-removed"> 300   gint i;</span>
<span class="line-removed"> 301   guint mask = 0;</span>
<span class="line-removed"> 302 </span>
 303   hash_table-&gt;size = 1 &lt;&lt; shift;
 304   hash_table-&gt;mod  = prime_mod [shift];
 305 
<a name="13" id="anc13"></a><span class="line-modified"> 306   for (i = 0; i &lt; shift; i++)</span>
<span class="line-modified"> 307     {</span>
<span class="line-modified"> 308       mask &lt;&lt;= 1;</span>
<span class="line-removed"> 309       mask |= 1;</span>
<span class="line-removed"> 310     }</span>
 311 
<a name="14" id="anc14"></a><span class="line-modified"> 312   hash_table-&gt;mask = mask;</span>

 313 }
 314 
 315 static gint
 316 g_hash_table_find_closest_shift (gint n)
 317 {
 318   gint i;
 319 
 320   for (i = 0; n; i++)
 321     n &gt;&gt;= 1;
 322 
 323   return i;
 324 }
 325 
 326 static void
 327 g_hash_table_set_shift_from_size (GHashTable *hash_table, gint size)
 328 {
 329   gint shift;
 330 
 331   shift = g_hash_table_find_closest_shift (size);
 332   shift = MAX (shift, HASH_TABLE_MIN_SHIFT);
 333 
 334   g_hash_table_set_shift (hash_table, shift);
 335 }
 336 
<a name="15" id="anc15"></a>




























































 337 /*
 338  * g_hash_table_lookup_node:
 339  * @hash_table: our #GHashTable
<a name="16" id="anc16"></a><span class="line-modified"> 340  * @key: the key to lookup against</span>
 341  * @hash_return: key hash return location
 342  *
 343  * Performs a lookup in the hash table, preserving extra information
 344  * usually needed for insertion.
 345  *
 346  * This function first computes the hash value of the key using the
 347  * user&#39;s hash function.
 348  *
 349  * If an entry in the table matching @key is found then this function
 350  * returns the index of that entry in the table, and if not, the
 351  * index of an unused node (empty or tombstone) where the key can be
 352  * inserted.
 353  *
 354  * The computed hash value is returned in the variable pointed to
 355  * by @hash_return. This is to save insertions from having to compute
 356  * the hash record again for the new record.
 357  *
 358  * Returns: index of the described node
 359  */
 360 static inline guint
 361 g_hash_table_lookup_node (GHashTable    *hash_table,
 362                           gconstpointer  key,
 363                           guint         *hash_return)
 364 {
 365   guint node_index;
 366   guint node_hash;
 367   guint hash_value;
 368   guint first_tombstone = 0;
 369   gboolean have_tombstone = FALSE;
 370   guint step = 0;
 371 
 372   /* If this happens, then the application is probably doing too much work
 373    * from a destroy notifier. The alternative would be to crash any second
 374    * (as keys, etc. will be NULL).
 375    * Applications need to either use g_hash_table_destroy, or ensure the hash
 376    * table is empty prior to removing the last reference using g_hash_table_unref(). */
 377   g_assert (!g_atomic_ref_count_compare (&amp;hash_table-&gt;ref_count, 0));
 378 
 379   hash_value = hash_table-&gt;hash_func (key);
 380   if (G_UNLIKELY (!HASH_IS_REAL (hash_value)))
 381     hash_value = 2;
 382 
 383   *hash_return = hash_value;
 384 
<a name="17" id="anc17"></a><span class="line-modified"> 385   node_index = hash_value % hash_table-&gt;mod;</span>
 386   node_hash = hash_table-&gt;hashes[node_index];
 387 
 388   while (!HASH_IS_UNUSED (node_hash))
 389     {
 390       /* We first check if our full hash values
 391        * are equal so we can avoid calling the full-blown
 392        * key equality function in most cases.
 393        */
 394       if (node_hash == hash_value)
 395         {
<a name="18" id="anc18"></a><span class="line-modified"> 396           gpointer node_key = hash_table-&gt;keys[node_index];</span>
 397 
 398           if (hash_table-&gt;key_equal_func)
 399             {
 400               if (hash_table-&gt;key_equal_func (node_key, key))
 401                 return node_index;
 402             }
 403           else if (node_key == key)
 404             {
 405               return node_index;
 406             }
 407         }
 408       else if (HASH_IS_TOMBSTONE (node_hash) &amp;&amp; !have_tombstone)
 409         {
 410           first_tombstone = node_index;
 411           have_tombstone = TRUE;
 412         }
 413 
 414       step++;
 415       node_index += step;
 416       node_index &amp;= hash_table-&gt;mask;
 417       node_hash = hash_table-&gt;hashes[node_index];
 418     }
 419 
 420   if (have_tombstone)
 421     return first_tombstone;
 422 
 423   return node_index;
 424 }
 425 
 426 /*
 427  * g_hash_table_remove_node:
 428  * @hash_table: our #GHashTable
 429  * @node: pointer to node to remove
 430  * @notify: %TRUE if the destroy notify handlers are to be called
 431  *
 432  * Removes a node from the hash table and updates the node count.
 433  * The node is replaced by a tombstone. No table resize is performed.
 434  *
 435  * If @notify is %TRUE then the destroy notify functions are called
 436  * for the key and value of the hash node.
 437  */
 438 static void
 439 g_hash_table_remove_node (GHashTable   *hash_table,
 440                           gint          i,
 441                           gboolean      notify)
 442 {
 443   gpointer key;
 444   gpointer value;
 445 
<a name="19" id="anc19"></a><span class="line-modified"> 446   key = hash_table-&gt;keys[i];</span>
<span class="line-modified"> 447   value = hash_table-&gt;values[i];</span>
 448 
 449   /* Erect tombstone */
 450   hash_table-&gt;hashes[i] = TOMBSTONE_HASH_VALUE;
 451 
 452   /* Be GC friendly */
<a name="20" id="anc20"></a><span class="line-modified"> 453   hash_table-&gt;keys[i] = NULL;</span>
<span class="line-modified"> 454   hash_table-&gt;values[i] = NULL;</span>
 455 
 456   hash_table-&gt;nnodes--;
 457 
 458   if (notify &amp;&amp; hash_table-&gt;key_destroy_func)
 459     hash_table-&gt;key_destroy_func (key);
 460 
 461   if (notify &amp;&amp; hash_table-&gt;value_destroy_func)
 462     hash_table-&gt;value_destroy_func (value);
 463 
 464 }
 465 
<a name="21" id="anc21"></a>



































 466 /*
 467  * g_hash_table_remove_all_nodes:
 468  * @hash_table: our #GHashTable
 469  * @notify: %TRUE if the destroy notify handlers are to be called
 470  *
<a name="22" id="anc22"></a><span class="line-modified"> 471  * Removes all nodes from the table.  Since this may be a precursor to</span>
<span class="line-removed"> 472  * freeing the table entirely, no resize is performed.</span>
 473  *
 474  * If @notify is %TRUE then the destroy notify functions are called
 475  * for the key and value of the hash node.
<a name="23" id="anc23"></a>







 476  */
 477 static void
 478 g_hash_table_remove_all_nodes (GHashTable *hash_table,
 479                                gboolean    notify,
 480                                gboolean    destruction)
 481 {
 482   int i;
 483   gpointer key;
 484   gpointer value;
 485   gint old_size;
 486   gpointer *old_keys;
 487   gpointer *old_values;
 488   guint    *old_hashes;
<a name="24" id="anc24"></a>

 489 
 490   /* If the hash table is already empty, there is nothing to be done. */
 491   if (hash_table-&gt;nnodes == 0)
 492     return;
 493 
 494   hash_table-&gt;nnodes = 0;
 495   hash_table-&gt;noccupied = 0;
 496 
<a name="25" id="anc25"></a>
 497   if (!notify ||
 498       (hash_table-&gt;key_destroy_func == NULL &amp;&amp;
 499        hash_table-&gt;value_destroy_func == NULL))
 500     {
 501       if (!destruction)
 502         {
<a name="26" id="anc26"></a><span class="line-modified"> 503       memset (hash_table-&gt;hashes, 0, hash_table-&gt;size * sizeof (guint));</span>
<span class="line-modified"> 504       memset (hash_table-&gt;keys, 0, hash_table-&gt;size * sizeof (gpointer));</span>
<span class="line-modified"> 505       memset (hash_table-&gt;values, 0, hash_table-&gt;size * sizeof (gpointer));</span>






 506         }
 507 
 508       return;
 509     }
 510 
<a name="27" id="anc27"></a><span class="line-modified"> 511   /* Keep the old storage space around to iterate over it. */</span>



















 512   old_size = hash_table-&gt;size;
<a name="28" id="anc28"></a><span class="line-modified"> 513   old_keys   = hash_table-&gt;keys;</span>
<span class="line-modified"> 514   old_values = hash_table-&gt;values;</span>
<span class="line-modified"> 515   old_hashes = hash_table-&gt;hashes;</span>
<span class="line-modified"> 516 </span>
<span class="line-modified"> 517   /* Now create a new storage space; If the table is destroyed we can use the</span>
<span class="line-modified"> 518    * shortcut of not creating a new storage. This saves the allocation at the</span>
<span class="line-removed"> 519    * cost of not allowing any recursive access.</span>
<span class="line-removed"> 520    * However, the application doesn&#39;t own any reference anymore, so access</span>
<span class="line-removed"> 521    * is not allowed. If accesses are done, then either an assert or crash</span>
<span class="line-removed"> 522    * *will* happen. */</span>
<span class="line-removed"> 523   g_hash_table_set_shift (hash_table, HASH_TABLE_MIN_SHIFT);</span>
 524   if (!destruction)
<a name="29" id="anc29"></a><span class="line-modified"> 525     {</span>
<span class="line-modified"> 526       hash_table-&gt;keys   = g_new0 (gpointer, hash_table-&gt;size);</span>
<span class="line-removed"> 527       hash_table-&gt;values = hash_table-&gt;keys;</span>
<span class="line-removed"> 528       hash_table-&gt;hashes = g_new0 (guint, hash_table-&gt;size);</span>
<span class="line-removed"> 529     }</span>
 530   else
<a name="30" id="anc30"></a><span class="line-modified"> 531         {</span>
<span class="line-modified"> 532       hash_table-&gt;keys   = NULL;</span>
<span class="line-removed"> 533       hash_table-&gt;values = NULL;</span>
<span class="line-removed"> 534       hash_table-&gt;hashes = NULL;</span>
<span class="line-removed"> 535     }</span>
 536 
<a name="31" id="anc31"></a>
 537   for (i = 0; i &lt; old_size; i++)
 538     {
 539       if (HASH_IS_REAL (old_hashes[i]))
 540         {
<a name="32" id="anc32"></a><span class="line-modified"> 541           key = old_keys[i];</span>
<span class="line-modified"> 542           value = old_values[i];</span>
 543 
 544           old_hashes[i] = UNUSED_HASH_VALUE;
<a name="33" id="anc33"></a><span class="line-modified"> 545           old_keys[i] = NULL;</span>
<span class="line-modified"> 546           old_values[i] = NULL;</span>

 547 
 548           if (hash_table-&gt;key_destroy_func != NULL)
 549             hash_table-&gt;key_destroy_func (key);
 550 
 551           if (hash_table-&gt;value_destroy_func != NULL)
 552             hash_table-&gt;value_destroy_func (value);
 553         }
<a name="34" id="anc34"></a><span class="line-modified"> 554         }</span>
 555 
 556   /* Destroy old storage space. */
 557   if (old_keys != old_values)
 558     g_free (old_values);
 559 
 560   g_free (old_keys);
 561   g_free (old_hashes);
<a name="35" id="anc35"></a><span class="line-modified"> 562     }</span>























































































































 563 
 564 /*
 565  * g_hash_table_resize:
 566  * @hash_table: our #GHashTable
 567  *
 568  * Resizes the hash table to the optimal size based on the number of
 569  * nodes currently held. If you call this function then a resize will
 570  * occur, even if one does not need to occur.
 571  * Use g_hash_table_maybe_resize() instead.
 572  *
 573  * This function may &quot;resize&quot; the hash table to its current size, with
 574  * the side effect of cleaning up tombstones and otherwise optimizing
 575  * the probe sequences.
 576  */
 577 static void
 578 g_hash_table_resize (GHashTable *hash_table)
 579 {
<a name="36" id="anc36"></a><span class="line-modified"> 580   gpointer *new_keys;</span>
<span class="line-modified"> 581   gpointer *new_values;</span>
<span class="line-modified"> 582   guint *new_hashes;</span>
<span class="line-removed"> 583   gint old_size;</span>
<span class="line-removed"> 584   gint i;</span>
 585 
 586   old_size = hash_table-&gt;size;
<a name="37" id="anc37"></a><span class="line-modified"> 587   g_hash_table_set_shift_from_size (hash_table, hash_table-&gt;nnodes * 2);</span>
<span class="line-removed"> 588 </span>
<span class="line-removed"> 589   new_keys = g_new0 (gpointer, hash_table-&gt;size);</span>
<span class="line-removed"> 590   if (hash_table-&gt;keys == hash_table-&gt;values)</span>
<span class="line-removed"> 591     new_values = new_keys;</span>
<span class="line-removed"> 592   else</span>
<span class="line-removed"> 593     new_values = g_new0 (gpointer, hash_table-&gt;size);</span>
<span class="line-removed"> 594   new_hashes = g_new0 (guint, hash_table-&gt;size);</span>
<span class="line-removed"> 595 </span>
<span class="line-removed"> 596   for (i = 0; i &lt; old_size; i++)</span>
<span class="line-removed"> 597     {</span>
<span class="line-removed"> 598       guint node_hash = hash_table-&gt;hashes[i];</span>
<span class="line-removed"> 599       guint hash_val;</span>
<span class="line-removed"> 600       guint step = 0;</span>
 601 
<a name="38" id="anc38"></a><span class="line-modified"> 602       if (!HASH_IS_REAL (node_hash))</span>
<span class="line-modified"> 603         continue;</span>








 604 
<a name="39" id="anc39"></a><span class="line-modified"> 605       hash_val = node_hash % hash_table-&gt;mod;</span>
 606 
<a name="40" id="anc40"></a><span class="line-modified"> 607       while (!HASH_IS_UNUSED (new_hashes[hash_val]))</span>
<span class="line-modified"> 608         {</span>
<span class="line-modified"> 609           step++;</span>
<span class="line-modified"> 610           hash_val += step;</span>
<span class="line-removed"> 611           hash_val &amp;= hash_table-&gt;mask;</span>
<span class="line-removed"> 612         }</span>
 613 
<a name="41" id="anc41"></a><span class="line-modified"> 614       new_hashes[hash_val] = hash_table-&gt;hashes[i];</span>
<span class="line-modified"> 615       new_keys[hash_val] = hash_table-&gt;keys[i];</span>
<span class="line-modified"> 616       new_values[hash_val] = hash_table-&gt;values[i];</span>


 617     }
 618 
<a name="42" id="anc42"></a><span class="line-modified"> 619   if (hash_table-&gt;keys != hash_table-&gt;values)</span>
<span class="line-modified"> 620     g_free (hash_table-&gt;values);</span>


 621 
<a name="43" id="anc43"></a><span class="line-modified"> 622   g_free (hash_table-&gt;keys);</span>
<span class="line-removed"> 623   g_free (hash_table-&gt;hashes);</span>
 624 
<a name="44" id="anc44"></a><span class="line-modified"> 625   hash_table-&gt;keys = new_keys;</span>
<span class="line-modified"> 626   hash_table-&gt;values = new_values;</span>
<span class="line-removed"> 627   hash_table-&gt;hashes = new_hashes;</span>
 628 
 629   hash_table-&gt;noccupied = hash_table-&gt;nnodes;
 630 }
 631 
 632 /*
 633  * g_hash_table_maybe_resize:
 634  * @hash_table: our #GHashTable
 635  *
 636  * Resizes the hash table, if needed.
 637  *
 638  * Essentially, calls g_hash_table_resize() if the table has strayed
 639  * too far from its ideal size for its number of nodes.
 640  */
 641 static inline void
 642 g_hash_table_maybe_resize (GHashTable *hash_table)
 643 {
 644   gint noccupied = hash_table-&gt;noccupied;
 645   gint size = hash_table-&gt;size;
 646 
 647   if ((size &gt; hash_table-&gt;nnodes * 4 &amp;&amp; size &gt; 1 &lt;&lt; HASH_TABLE_MIN_SHIFT) ||
 648       (size &lt;= noccupied + (noccupied / 16)))
 649     g_hash_table_resize (hash_table);
 650 }
 651 
<a name="45" id="anc45"></a>























































































 652 /**
 653  * g_hash_table_new:
 654  * @hash_func: a function to create a hash value from a key
 655  * @key_equal_func: a function to check two keys for equality
 656  *
 657  * Creates a new #GHashTable with a reference count of 1.
 658  *
 659  * Hash values returned by @hash_func are used to determine where keys
 660  * are stored within the #GHashTable data structure. The g_direct_hash(),
 661  * g_int_hash(), g_int64_hash(), g_double_hash() and g_str_hash()
 662  * functions are provided for some common types of keys.
 663  * If @hash_func is %NULL, g_direct_hash() is used.
 664  *
 665  * @key_equal_func is used when looking up keys in the #GHashTable.
 666  * The g_direct_equal(), g_int_equal(), g_int64_equal(), g_double_equal()
 667  * and g_str_equal() functions are provided for the most common types
 668  * of keys. If @key_equal_func is %NULL, keys are compared directly in
 669  * a similar fashion to g_direct_equal(), but without the overhead of
 670  * a function call. @key_equal_func is called with the key from the hash table
 671  * as its first parameter, and the user-provided key to check against as
 672  * its second.
 673  *
 674  * Returns: a new #GHashTable
 675  */
 676 GHashTable *
 677 g_hash_table_new (GHashFunc  hash_func,
 678                   GEqualFunc key_equal_func)
 679 {
 680   return g_hash_table_new_full (hash_func, key_equal_func, NULL, NULL);
 681 }
 682 
 683 
 684 /**
 685  * g_hash_table_new_full:
 686  * @hash_func: a function to create a hash value from a key
 687  * @key_equal_func: a function to check two keys for equality
 688  * @key_destroy_func: (nullable): a function to free the memory allocated for the key
 689  *     used when removing the entry from the #GHashTable, or %NULL
 690  *     if you don&#39;t want to supply such a function.
 691  * @value_destroy_func: (nullable): a function to free the memory allocated for the
 692  *     value used when removing the entry from the #GHashTable, or %NULL
 693  *     if you don&#39;t want to supply such a function.
 694  *
 695  * Creates a new #GHashTable like g_hash_table_new() with a reference
 696  * count of 1 and allows to specify functions to free the memory
 697  * allocated for the key and value that get called when removing the
 698  * entry from the #GHashTable.
 699  *
 700  * Since version 2.42 it is permissible for destroy notify functions to
 701  * recursively remove further items from the hash table. This is only
 702  * permissible if the application still holds a reference to the hash table.
 703  * This means that you may need to ensure that the hash table is empty by
 704  * calling g_hash_table_remove_all() before releasing the last reference using
 705  * g_hash_table_unref().
 706  *
 707  * Returns: a new #GHashTable
 708  */
 709 GHashTable *
 710 g_hash_table_new_full (GHashFunc      hash_func,
 711                        GEqualFunc     key_equal_func,
 712                        GDestroyNotify key_destroy_func,
 713                        GDestroyNotify value_destroy_func)
 714 {
 715   GHashTable *hash_table;
 716 
 717   hash_table = g_slice_new (GHashTable);
 718 #ifdef GSTREAMER_LITE
 719   if (hash_table == NULL) {
 720     return NULL;
 721   }
 722 #endif // GSTREAMER_LITE
<a name="46" id="anc46"></a><span class="line-removed"> 723   g_hash_table_set_shift (hash_table, HASH_TABLE_MIN_SHIFT);</span>
 724   g_atomic_ref_count_init (&amp;hash_table-&gt;ref_count);
 725   hash_table-&gt;nnodes             = 0;
 726   hash_table-&gt;noccupied          = 0;
 727   hash_table-&gt;hash_func          = hash_func ? hash_func : g_direct_hash;
 728   hash_table-&gt;key_equal_func     = key_equal_func;
 729 #ifndef G_DISABLE_ASSERT
 730   hash_table-&gt;version            = 0;
 731 #endif
 732   hash_table-&gt;key_destroy_func   = key_destroy_func;
 733   hash_table-&gt;value_destroy_func = value_destroy_func;
<a name="47" id="anc47"></a><span class="line-modified"> 734   hash_table-&gt;keys               = g_new0 (gpointer, hash_table-&gt;size);</span>
<span class="line-modified"> 735   hash_table-&gt;values             = hash_table-&gt;keys;</span>
<span class="line-removed"> 736   hash_table-&gt;hashes             = g_new0 (guint, hash_table-&gt;size);</span>
 737 
 738   return hash_table;
 739 }
 740 
 741 /**
 742  * g_hash_table_iter_init:
 743  * @iter: an uninitialized #GHashTableIter
 744  * @hash_table: a #GHashTable
 745  *
 746  * Initializes a key/value pair iterator and associates it with
 747  * @hash_table. Modifying the hash table after calling this function
 748  * invalidates the returned iterator.
 749  * |[&lt;!-- language=&quot;C&quot; --&gt;
 750  * GHashTableIter iter;
 751  * gpointer key, value;
 752  *
 753  * g_hash_table_iter_init (&amp;iter, hash_table);
 754  * while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
 755  *   {
 756  *     // do something with key and value
 757  *   }
 758  * ]|
 759  *
 760  * Since: 2.16
 761  */
 762 void
 763 g_hash_table_iter_init (GHashTableIter *iter,
 764                         GHashTable     *hash_table)
 765 {
 766   RealIter *ri = (RealIter *) iter;
 767 
 768   g_return_if_fail (iter != NULL);
 769   g_return_if_fail (hash_table != NULL);
 770 
 771   ri-&gt;hash_table = hash_table;
 772   ri-&gt;position = -1;
 773 #ifndef G_DISABLE_ASSERT
 774   ri-&gt;version = hash_table-&gt;version;
 775 #endif
 776 }
 777 
 778 /**
 779  * g_hash_table_iter_next:
 780  * @iter: an initialized #GHashTableIter
 781  * @key: (out) (optional): a location to store the key
 782  * @value: (out) (optional) (nullable): a location to store the value
 783  *
 784  * Advances @iter and retrieves the key and/or value that are now
 785  * pointed to as a result of this advancement. If %FALSE is returned,
 786  * @key and @value are not set, and the iterator becomes invalid.
 787  *
 788  * Returns: %FALSE if the end of the #GHashTable has been reached.
 789  *
 790  * Since: 2.16
 791  */
 792 gboolean
 793 g_hash_table_iter_next (GHashTableIter *iter,
 794                         gpointer       *key,
 795                         gpointer       *value)
 796 {
 797   RealIter *ri = (RealIter *) iter;
 798   gint position;
 799 
 800   g_return_val_if_fail (iter != NULL, FALSE);
 801 #ifndef G_DISABLE_ASSERT
 802   g_return_val_if_fail (ri-&gt;version == ri-&gt;hash_table-&gt;version, FALSE);
 803 #endif
<a name="48" id="anc48"></a><span class="line-modified"> 804   g_return_val_if_fail (ri-&gt;position &lt; ri-&gt;hash_table-&gt;size, FALSE);</span>
 805 
 806   position = ri-&gt;position;
 807 
 808   do
 809     {
 810       position++;
<a name="49" id="anc49"></a><span class="line-modified"> 811       if (position &gt;= ri-&gt;hash_table-&gt;size)</span>
 812         {
 813           ri-&gt;position = position;
 814           return FALSE;
 815         }
 816     }
 817   while (!HASH_IS_REAL (ri-&gt;hash_table-&gt;hashes[position]));
 818 
 819   if (key != NULL)
<a name="50" id="anc50"></a><span class="line-modified"> 820     *key = ri-&gt;hash_table-&gt;keys[position];</span>
 821   if (value != NULL)
<a name="51" id="anc51"></a><span class="line-modified"> 822     *value = ri-&gt;hash_table-&gt;values[position];</span>
 823 
 824   ri-&gt;position = position;
 825   return TRUE;
 826 }
 827 
 828 /**
 829  * g_hash_table_iter_get_hash_table:
 830  * @iter: an initialized #GHashTableIter
 831  *
 832  * Returns the #GHashTable associated with @iter.
 833  *
 834  * Returns: the #GHashTable associated with @iter.
 835  *
 836  * Since: 2.16
 837  */
 838 GHashTable *
 839 g_hash_table_iter_get_hash_table (GHashTableIter *iter)
 840 {
 841   g_return_val_if_fail (iter != NULL, NULL);
 842 
 843   return ((RealIter *) iter)-&gt;hash_table;
 844 }
 845 
 846 static void
 847 iter_remove_or_steal (RealIter *ri, gboolean notify)
 848 {
 849   g_return_if_fail (ri != NULL);
 850 #ifndef G_DISABLE_ASSERT
 851   g_return_if_fail (ri-&gt;version == ri-&gt;hash_table-&gt;version);
 852 #endif
 853   g_return_if_fail (ri-&gt;position &gt;= 0);
<a name="52" id="anc52"></a><span class="line-modified"> 854   g_return_if_fail (ri-&gt;position &lt; ri-&gt;hash_table-&gt;size);</span>
 855 
 856   g_hash_table_remove_node (ri-&gt;hash_table, ri-&gt;position, notify);
 857 
 858 #ifndef G_DISABLE_ASSERT
 859   ri-&gt;version++;
 860   ri-&gt;hash_table-&gt;version++;
 861 #endif
 862 }
 863 
 864 /**
 865  * g_hash_table_iter_remove:
 866  * @iter: an initialized #GHashTableIter
 867  *
 868  * Removes the key/value pair currently pointed to by the iterator
 869  * from its associated #GHashTable. Can only be called after
 870  * g_hash_table_iter_next() returned %TRUE, and cannot be called
 871  * more than once for the same key/value pair.
 872  *
 873  * If the #GHashTable was created using g_hash_table_new_full(),
 874  * the key and value are freed using the supplied destroy functions,
 875  * otherwise you have to make sure that any dynamically allocated
 876  * values are freed yourself.
 877  *
 878  * It is safe to continue iterating the #GHashTable afterward:
 879  * |[&lt;!-- language=&quot;C&quot; --&gt;
 880  * while (g_hash_table_iter_next (&amp;iter, &amp;key, &amp;value))
 881  *   {
 882  *     if (condition)
 883  *       g_hash_table_iter_remove (&amp;iter);
 884  *   }
 885  * ]|
 886  *
 887  * Since: 2.16
 888  */
 889 void
 890 g_hash_table_iter_remove (GHashTableIter *iter)
 891 {
 892   iter_remove_or_steal ((RealIter *) iter, TRUE);
 893 }
 894 
 895 /*
 896  * g_hash_table_insert_node:
 897  * @hash_table: our #GHashTable
 898  * @node_index: pointer to node to insert/replace
 899  * @key_hash: key hash
 900  * @key: (nullable): key to replace with, or %NULL
 901  * @value: value to replace with
 902  * @keep_new_key: whether to replace the key in the node with @key
 903  * @reusing_key: whether @key was taken out of the existing node
 904  *
 905  * Inserts a value at @node_index in the hash table and updates it.
 906  *
 907  * If @key has been taken out of the existing node (ie it is not
 908  * passed in via a g_hash_table_insert/replace) call, then @reusing_key
 909  * should be %TRUE.
 910  *
 911  * Returns: %TRUE if the key did not exist yet
 912  */
 913 static gboolean
 914 g_hash_table_insert_node (GHashTable *hash_table,
 915                           guint       node_index,
 916                           guint       key_hash,
 917                           gpointer    new_key,
 918                           gpointer    new_value,
 919                           gboolean    keep_new_key,
 920                           gboolean    reusing_key)
 921 {
 922   gboolean already_exists;
 923   guint old_hash;
 924   gpointer key_to_free = NULL;
<a name="53" id="anc53"></a>
 925   gpointer value_to_free = NULL;
 926 
 927   old_hash = hash_table-&gt;hashes[node_index];
 928   already_exists = HASH_IS_REAL (old_hash);
 929 
 930   /* Proceed in three steps.  First, deal with the key because it is the
 931    * most complicated.  Then consider if we need to split the table in
 932    * two (because writing the value will result in the set invariant
 933    * becoming broken).  Then deal with the value.
 934    *
 935    * There are three cases for the key:
 936    *
 937    *  - entry already exists in table, reusing key:
 938    *    free the just-passed-in new_key and use the existing value
 939    *
 940    *  - entry already exists in table, not reusing key:
 941    *    free the entry in the table, use the new key
 942    *
 943    *  - entry not already in table:
 944    *    use the new key, free nothing
 945    *
 946    * We update the hash at the same time...
 947    */
 948   if (already_exists)
 949     {
 950       /* Note: we must record the old value before writing the new key
 951        * because we might change the value in the event that the two
 952        * arrays are shared.
 953        */
<a name="54" id="anc54"></a><span class="line-modified"> 954       value_to_free = hash_table-&gt;values[node_index];</span>
 955 
 956       if (keep_new_key)
 957         {
<a name="55" id="anc55"></a><span class="line-modified"> 958           key_to_free = hash_table-&gt;keys[node_index];</span>
<span class="line-modified"> 959           hash_table-&gt;keys[node_index] = new_key;</span>
 960         }
 961       else
<a name="56" id="anc56"></a><span class="line-modified"> 962         key_to_free = new_key;</span>



 963     }
 964   else
 965     {
 966       hash_table-&gt;hashes[node_index] = key_hash;
<a name="57" id="anc57"></a><span class="line-modified"> 967       hash_table-&gt;keys[node_index] = new_key;</span>
 968     }
 969 
<a name="58" id="anc58"></a><span class="line-modified"> 970   /* Step two: check if the value that we are about to write to the</span>
<span class="line-modified"> 971    * table is the same as the key in the same position.  If it&#39;s not,</span>
<span class="line-modified"> 972    * split the table.</span>
<span class="line-removed"> 973    */</span>
<span class="line-removed"> 974   if (G_UNLIKELY (hash_table-&gt;keys == hash_table-&gt;values &amp;&amp; hash_table-&gt;keys[node_index] != new_value))</span>
<span class="line-removed"> 975     hash_table-&gt;values = g_memdup (hash_table-&gt;keys, sizeof (gpointer) * hash_table-&gt;size);</span>
 976 
 977   /* Step 3: Actually do the write */
<a name="59" id="anc59"></a><span class="line-modified"> 978   hash_table-&gt;values[node_index] = new_value;</span>
 979 
 980   /* Now, the bookkeeping... */
 981   if (!already_exists)
 982     {
 983       hash_table-&gt;nnodes++;
 984 
 985       if (HASH_IS_UNUSED (old_hash))
 986         {
 987           /* We replaced an empty node, and not a tombstone */
 988           hash_table-&gt;noccupied++;
 989           g_hash_table_maybe_resize (hash_table);
 990         }
 991 
 992 #ifndef G_DISABLE_ASSERT
 993       hash_table-&gt;version++;
 994 #endif
 995     }
 996 
 997   if (already_exists)
 998     {
 999       if (hash_table-&gt;key_destroy_func &amp;&amp; !reusing_key)
1000         (* hash_table-&gt;key_destroy_func) (key_to_free);
1001       if (hash_table-&gt;value_destroy_func)
1002         (* hash_table-&gt;value_destroy_func) (value_to_free);
1003     }
1004 
1005   return !already_exists;
1006 }
1007 
1008 /**
1009  * g_hash_table_iter_replace:
1010  * @iter: an initialized #GHashTableIter
1011  * @value: the value to replace with
1012  *
1013  * Replaces the value currently pointed to by the iterator
1014  * from its associated #GHashTable. Can only be called after
1015  * g_hash_table_iter_next() returned %TRUE.
1016  *
1017  * If you supplied a @value_destroy_func when creating the
1018  * #GHashTable, the old value is freed using that function.
1019  *
1020  * Since: 2.30
1021  */
1022 void
1023 g_hash_table_iter_replace (GHashTableIter *iter,
1024                            gpointer        value)
1025 {
1026   RealIter *ri;
1027   guint node_hash;
1028   gpointer key;
1029 
1030   ri = (RealIter *) iter;
1031 
1032   g_return_if_fail (ri != NULL);
1033 #ifndef G_DISABLE_ASSERT
1034   g_return_if_fail (ri-&gt;version == ri-&gt;hash_table-&gt;version);
1035 #endif
1036   g_return_if_fail (ri-&gt;position &gt;= 0);
<a name="60" id="anc60"></a><span class="line-modified">1037   g_return_if_fail (ri-&gt;position &lt; ri-&gt;hash_table-&gt;size);</span>
1038 
1039   node_hash = ri-&gt;hash_table-&gt;hashes[ri-&gt;position];
<a name="61" id="anc61"></a><span class="line-modified">1040   key = ri-&gt;hash_table-&gt;keys[ri-&gt;position];</span>

1041 
1042   g_hash_table_insert_node (ri-&gt;hash_table, ri-&gt;position, node_hash, key, value, TRUE, TRUE);
1043 
1044 #ifndef G_DISABLE_ASSERT
1045   ri-&gt;version++;
1046   ri-&gt;hash_table-&gt;version++;
1047 #endif
1048 }
1049 
1050 /**
1051  * g_hash_table_iter_steal:
1052  * @iter: an initialized #GHashTableIter
1053  *
1054  * Removes the key/value pair currently pointed to by the
1055  * iterator from its associated #GHashTable, without calling
1056  * the key and value destroy functions. Can only be called
1057  * after g_hash_table_iter_next() returned %TRUE, and cannot
1058  * be called more than once for the same key/value pair.
1059  *
1060  * Since: 2.16
1061  */
1062 void
1063 g_hash_table_iter_steal (GHashTableIter *iter)
1064 {
1065   iter_remove_or_steal ((RealIter *) iter, FALSE);
1066 }
1067 
1068 
1069 /**
1070  * g_hash_table_ref:
1071  * @hash_table: a valid #GHashTable
1072  *
1073  * Atomically increments the reference count of @hash_table by one.
1074  * This function is MT-safe and may be called from any thread.
1075  *
1076  * Returns: the passed in #GHashTable
1077  *
1078  * Since: 2.10
1079  */
1080 GHashTable *
1081 g_hash_table_ref (GHashTable *hash_table)
1082 {
1083   g_return_val_if_fail (hash_table != NULL, NULL);
1084 
1085   g_atomic_ref_count_inc (&amp;hash_table-&gt;ref_count);
1086 
1087   return hash_table;
1088 }
1089 
1090 /**
1091  * g_hash_table_unref:
1092  * @hash_table: a valid #GHashTable
1093  *
1094  * Atomically decrements the reference count of @hash_table by one.
1095  * If the reference count drops to 0, all keys and values will be
1096  * destroyed, and all memory allocated by the hash table is released.
1097  * This function is MT-safe and may be called from any thread.
1098  *
1099  * Since: 2.10
1100  */
1101 void
1102 g_hash_table_unref (GHashTable *hash_table)
1103 {
1104   g_return_if_fail (hash_table != NULL);
1105 
1106   if (g_atomic_ref_count_dec (&amp;hash_table-&gt;ref_count))
1107     {
1108       g_hash_table_remove_all_nodes (hash_table, TRUE, TRUE);
1109       if (hash_table-&gt;keys != hash_table-&gt;values)
1110         g_free (hash_table-&gt;values);
1111       g_free (hash_table-&gt;keys);
1112       g_free (hash_table-&gt;hashes);
1113       g_slice_free (GHashTable, hash_table);
1114     }
1115 }
1116 
1117 /**
1118  * g_hash_table_destroy:
1119  * @hash_table: a #GHashTable
1120  *
1121  * Destroys all keys and values in the #GHashTable and decrements its
1122  * reference count by 1. If keys and/or values are dynamically allocated,
1123  * you should either free them first or create the #GHashTable with destroy
1124  * notifiers using g_hash_table_new_full(). In the latter case the destroy
1125  * functions you supplied will be called on all keys and values during the
1126  * destruction phase.
1127  */
1128 void
1129 g_hash_table_destroy (GHashTable *hash_table)
1130 {
1131   g_return_if_fail (hash_table != NULL);
1132 
1133   g_hash_table_remove_all (hash_table);
1134   g_hash_table_unref (hash_table);
1135 }
1136 
1137 /**
1138  * g_hash_table_lookup:
1139  * @hash_table: a #GHashTable
1140  * @key: the key to look up
1141  *
1142  * Looks up a key in a #GHashTable. Note that this function cannot
1143  * distinguish between a key that is not present and one which is present
1144  * and has the value %NULL. If you need this distinction, use
1145  * g_hash_table_lookup_extended().
1146  *
1147  * Returns: (nullable): the associated value, or %NULL if the key is not found
1148  */
1149 gpointer
1150 g_hash_table_lookup (GHashTable    *hash_table,
1151                      gconstpointer  key)
1152 {
1153   guint node_index;
1154   guint node_hash;
1155 
1156   g_return_val_if_fail (hash_table != NULL, NULL);
1157 
1158   node_index = g_hash_table_lookup_node (hash_table, key, &amp;node_hash);
1159 
1160   return HASH_IS_REAL (hash_table-&gt;hashes[node_index])
<a name="62" id="anc62"></a><span class="line-modified">1161     ? hash_table-&gt;values[node_index]</span>
1162     : NULL;
1163 }
1164 
1165 /**
1166  * g_hash_table_lookup_extended:
1167  * @hash_table: a #GHashTable
1168  * @lookup_key: the key to look up
1169  * @orig_key: (out) (optional): return location for the original key
1170  * @value: (out) (optional) (nullable): return location for the value associated
1171  * with the key
1172  *
1173  * Looks up a key in the #GHashTable, returning the original key and the
1174  * associated value and a #gboolean which is %TRUE if the key was found. This
1175  * is useful if you need to free the memory allocated for the original key,
1176  * for example before calling g_hash_table_remove().
1177  *
1178  * You can actually pass %NULL for @lookup_key to test
1179  * whether the %NULL key exists, provided the hash and equal functions
1180  * of @hash_table are %NULL-safe.
1181  *
1182  * Returns: %TRUE if the key was found in the #GHashTable
1183  */
1184 gboolean
1185 g_hash_table_lookup_extended (GHashTable    *hash_table,
1186                               gconstpointer  lookup_key,
1187                               gpointer      *orig_key,
1188                               gpointer      *value)
1189 {
1190   guint node_index;
1191   guint node_hash;
1192 
1193   g_return_val_if_fail (hash_table != NULL, FALSE);
1194 
1195   node_index = g_hash_table_lookup_node (hash_table, lookup_key, &amp;node_hash);
1196 
1197   if (!HASH_IS_REAL (hash_table-&gt;hashes[node_index]))
<a name="63" id="anc63"></a><span class="line-modified">1198     return FALSE;</span>







1199 
1200   if (orig_key)
<a name="64" id="anc64"></a><span class="line-modified">1201     *orig_key = hash_table-&gt;keys[node_index];</span>
1202 
1203   if (value)
<a name="65" id="anc65"></a><span class="line-modified">1204     *value = hash_table-&gt;values[node_index];</span>
1205 
1206   return TRUE;
1207 }
1208 
1209 /*
1210  * g_hash_table_insert_internal:
1211  * @hash_table: our #GHashTable
1212  * @key: the key to insert
1213  * @value: the value to insert
1214  * @keep_new_key: if %TRUE and this key already exists in the table
1215  *   then call the destroy notify function on the old key.  If %FALSE
1216  *   then call the destroy notify function on the new key.
1217  *
1218  * Implements the common logic for the g_hash_table_insert() and
1219  * g_hash_table_replace() functions.
1220  *
1221  * Do a lookup of @key. If it is found, replace it with the new
1222  * @value (and perhaps the new @key). If it is not found, create
1223  * a new node.
1224  *
1225  * Returns: %TRUE if the key did not exist yet
1226  */
1227 static gboolean
1228 g_hash_table_insert_internal (GHashTable *hash_table,
1229                               gpointer    key,
1230                               gpointer    value,
1231                               gboolean    keep_new_key)
1232 {
1233   guint key_hash;
1234   guint node_index;
1235 
1236   g_return_val_if_fail (hash_table != NULL, FALSE);
1237 
1238   node_index = g_hash_table_lookup_node (hash_table, key, &amp;key_hash);
1239 
1240   return g_hash_table_insert_node (hash_table, node_index, key_hash, key, value, keep_new_key, FALSE);
1241 }
1242 
1243 /**
1244  * g_hash_table_insert:
1245  * @hash_table: a #GHashTable
1246  * @key: a key to insert
1247  * @value: the value to associate with the key
1248  *
1249  * Inserts a new key and value into a #GHashTable.
1250  *
1251  * If the key already exists in the #GHashTable its current
1252  * value is replaced with the new value. If you supplied a
1253  * @value_destroy_func when creating the #GHashTable, the old
1254  * value is freed using that function. If you supplied a
1255  * @key_destroy_func when creating the #GHashTable, the passed
1256  * key is freed using that function.
1257  *
1258  * Starting from GLib 2.40, this function returns a boolean value to
1259  * indicate whether the newly added value was already in the hash table
1260  * or not.
1261  *
1262  * Returns: %TRUE if the key did not exist yet
1263  */
1264 gboolean
1265 g_hash_table_insert (GHashTable *hash_table,
1266                      gpointer    key,
1267                      gpointer    value)
1268 {
1269   return g_hash_table_insert_internal (hash_table, key, value, FALSE);
1270 }
1271 
1272 /**
1273  * g_hash_table_replace:
1274  * @hash_table: a #GHashTable
1275  * @key: a key to insert
1276  * @value: the value to associate with the key
1277  *
1278  * Inserts a new key and value into a #GHashTable similar to
1279  * g_hash_table_insert(). The difference is that if the key
1280  * already exists in the #GHashTable, it gets replaced by the
1281  * new key. If you supplied a @value_destroy_func when creating
1282  * the #GHashTable, the old value is freed using that function.
1283  * If you supplied a @key_destroy_func when creating the
1284  * #GHashTable, the old key is freed using that function.
1285  *
1286  * Starting from GLib 2.40, this function returns a boolean value to
1287  * indicate whether the newly added value was already in the hash table
1288  * or not.
1289  *
1290  * Returns: %TRUE if the key did not exist yet
1291  */
1292 gboolean
1293 g_hash_table_replace (GHashTable *hash_table,
1294                       gpointer    key,
1295                       gpointer    value)
1296 {
1297   return g_hash_table_insert_internal (hash_table, key, value, TRUE);
1298 }
1299 
1300 /**
1301  * g_hash_table_add:
1302  * @hash_table: a #GHashTable
1303  * @key: a key to insert
1304  *
1305  * This is a convenience function for using a #GHashTable as a set.  It
1306  * is equivalent to calling g_hash_table_replace() with @key as both the
1307  * key and the value.
1308  *
1309  * When a hash table only ever contains keys that have themselves as the
1310  * corresponding value it is able to be stored more efficiently.  See
1311  * the discussion in the section description.
1312  *
1313  * Starting from GLib 2.40, this function returns a boolean value to
1314  * indicate whether the newly added value was already in the hash table
1315  * or not.
1316  *
1317  * Returns: %TRUE if the key did not exist yet
1318  *
1319  * Since: 2.32
1320  */
1321 gboolean
1322 g_hash_table_add (GHashTable *hash_table,
1323                   gpointer    key)
1324 {
1325   return g_hash_table_insert_internal (hash_table, key, key, TRUE);
1326 }
1327 
1328 /**
1329  * g_hash_table_contains:
1330  * @hash_table: a #GHashTable
1331  * @key: a key to check
1332  *
1333  * Checks if @key is in @hash_table.
1334  *
1335  * Returns: %TRUE if @key is in @hash_table, %FALSE otherwise.
1336  *
1337  * Since: 2.32
1338  **/
1339 gboolean
1340 g_hash_table_contains (GHashTable    *hash_table,
1341                        gconstpointer  key)
1342 {
1343   guint node_index;
1344   guint node_hash;
1345 
1346   g_return_val_if_fail (hash_table != NULL, FALSE);
1347 
1348   node_index = g_hash_table_lookup_node (hash_table, key, &amp;node_hash);
1349 
1350   return HASH_IS_REAL (hash_table-&gt;hashes[node_index]);
1351 }
1352 
1353 /*
1354  * g_hash_table_remove_internal:
1355  * @hash_table: our #GHashTable
1356  * @key: the key to remove
1357  * @notify: %TRUE if the destroy notify handlers are to be called
1358  * Returns: %TRUE if a node was found and removed, else %FALSE
1359  *
1360  * Implements the common logic for the g_hash_table_remove() and
1361  * g_hash_table_steal() functions.
1362  *
1363  * Do a lookup of @key and remove it if it is found, calling the
1364  * destroy notify handlers only if @notify is %TRUE.
1365  */
1366 static gboolean
1367 g_hash_table_remove_internal (GHashTable    *hash_table,
1368                               gconstpointer  key,
1369                               gboolean       notify)
1370 {
1371   guint node_index;
1372   guint node_hash;
1373 
1374   g_return_val_if_fail (hash_table != NULL, FALSE);
1375 
1376   node_index = g_hash_table_lookup_node (hash_table, key, &amp;node_hash);
1377 
1378   if (!HASH_IS_REAL (hash_table-&gt;hashes[node_index]))
1379     return FALSE;
1380 
1381   g_hash_table_remove_node (hash_table, node_index, notify);
1382   g_hash_table_maybe_resize (hash_table);
1383 
1384 #ifndef G_DISABLE_ASSERT
1385   hash_table-&gt;version++;
1386 #endif
1387 
1388   return TRUE;
1389 }
1390 
1391 /**
1392  * g_hash_table_remove:
1393  * @hash_table: a #GHashTable
1394  * @key: the key to remove
1395  *
1396  * Removes a key and its associated value from a #GHashTable.
1397  *
1398  * If the #GHashTable was created using g_hash_table_new_full(), the
1399  * key and value are freed using the supplied destroy functions, otherwise
1400  * you have to make sure that any dynamically allocated values are freed
1401  * yourself.
1402  *
1403  * Returns: %TRUE if the key was found and removed from the #GHashTable
1404  */
1405 gboolean
1406 g_hash_table_remove (GHashTable    *hash_table,
1407                      gconstpointer  key)
1408 {
1409   return g_hash_table_remove_internal (hash_table, key, TRUE);
1410 }
1411 
1412 /**
1413  * g_hash_table_steal:
1414  * @hash_table: a #GHashTable
1415  * @key: the key to remove
1416  *
1417  * Removes a key and its associated value from a #GHashTable without
1418  * calling the key and value destroy functions.
1419  *
1420  * Returns: %TRUE if the key was found and removed from the #GHashTable
1421  */
1422 gboolean
1423 g_hash_table_steal (GHashTable    *hash_table,
1424                     gconstpointer  key)
1425 {
1426   return g_hash_table_remove_internal (hash_table, key, FALSE);
1427 }
1428 
1429 /**
1430  * g_hash_table_steal_extended:
1431  * @hash_table: a #GHashTable
1432  * @lookup_key: the key to look up
1433  * @stolen_key: (out) (optional) (transfer full): return location for the
1434  *    original key
1435  * @stolen_value: (out) (optional) (nullable) (transfer full): return location
1436  *    for the value associated with the key
1437  *
1438  * Looks up a key in the #GHashTable, stealing the original key and the
1439  * associated value and returning %TRUE if the key was found. If the key was
1440  * not found, %FALSE is returned.
1441  *
1442  * If found, the stolen key and value are removed from the hash table without
1443  * calling the key and value destroy functions, and ownership is transferred to
1444  * the caller of this method; as with g_hash_table_steal().
1445  *
1446  * You can pass %NULL for @lookup_key, provided the hash and equal functions
1447  * of @hash_table are %NULL-safe.
1448  *
1449  * Returns: %TRUE if the key was found in the #GHashTable
1450  * Since: 2.58
1451  */
1452 gboolean
1453 g_hash_table_steal_extended (GHashTable    *hash_table,
1454                              gconstpointer  lookup_key,
1455                              gpointer      *stolen_key,
1456                              gpointer      *stolen_value)
1457 {
1458   guint node_index;
1459   guint node_hash;
1460 
1461   g_return_val_if_fail (hash_table != NULL, FALSE);
1462 
1463   node_index = g_hash_table_lookup_node (hash_table, lookup_key, &amp;node_hash);
1464 
1465   if (!HASH_IS_REAL (hash_table-&gt;hashes[node_index]))
1466     {
1467       if (stolen_key != NULL)
1468         *stolen_key = NULL;
1469       if (stolen_value != NULL)
1470         *stolen_value = NULL;
1471       return FALSE;
1472     }
1473 
1474   if (stolen_key != NULL)
<a name="66" id="anc66"></a><span class="line-modified">1475     *stolen_key = g_steal_pointer (&amp;hash_table-&gt;keys[node_index]);</span>



1476 
1477   if (stolen_value != NULL)
<a name="67" id="anc67"></a><span class="line-modified">1478     *stolen_value = g_steal_pointer (&amp;hash_table-&gt;values[node_index]);</span>



1479 
1480   g_hash_table_remove_node (hash_table, node_index, FALSE);
1481   g_hash_table_maybe_resize (hash_table);
1482 
1483 #ifndef G_DISABLE_ASSERT
1484   hash_table-&gt;version++;
1485 #endif
1486 
1487   return TRUE;
1488 }
1489 
1490 /**
1491  * g_hash_table_remove_all:
1492  * @hash_table: a #GHashTable
1493  *
1494  * Removes all keys and their associated values from a #GHashTable.
1495  *
1496  * If the #GHashTable was created using g_hash_table_new_full(),
1497  * the keys and values are freed using the supplied destroy functions,
1498  * otherwise you have to make sure that any dynamically allocated
1499  * values are freed yourself.
1500  *
1501  * Since: 2.12
1502  */
1503 void
1504 g_hash_table_remove_all (GHashTable *hash_table)
1505 {
1506   g_return_if_fail (hash_table != NULL);
1507 
1508 #ifndef G_DISABLE_ASSERT
1509   if (hash_table-&gt;nnodes != 0)
1510     hash_table-&gt;version++;
1511 #endif
1512 
1513   g_hash_table_remove_all_nodes (hash_table, TRUE, FALSE);
1514   g_hash_table_maybe_resize (hash_table);
1515 }
1516 
1517 /**
1518  * g_hash_table_steal_all:
1519  * @hash_table: a #GHashTable
1520  *
1521  * Removes all keys and their associated values from a #GHashTable
1522  * without calling the key and value destroy functions.
1523  *
1524  * Since: 2.12
1525  */
1526 void
1527 g_hash_table_steal_all (GHashTable *hash_table)
1528 {
1529   g_return_if_fail (hash_table != NULL);
1530 
1531 #ifndef G_DISABLE_ASSERT
1532   if (hash_table-&gt;nnodes != 0)
1533     hash_table-&gt;version++;
1534 #endif
1535 
1536   g_hash_table_remove_all_nodes (hash_table, FALSE, FALSE);
1537   g_hash_table_maybe_resize (hash_table);
1538 }
1539 
1540 /*
1541  * g_hash_table_foreach_remove_or_steal:
1542  * @hash_table: a #GHashTable
1543  * @func: the user&#39;s callback function
1544  * @user_data: data for @func
1545  * @notify: %TRUE if the destroy notify handlers are to be called
1546  *
1547  * Implements the common logic for g_hash_table_foreach_remove()
1548  * and g_hash_table_foreach_steal().
1549  *
1550  * Iterates over every node in the table, calling @func with the key
1551  * and value of the node (and @user_data). If @func returns %TRUE the
1552  * node is removed from the table.
1553  *
1554  * If @notify is true then the destroy notify handlers will be called
1555  * for each removed node.
1556  */
1557 static guint
1558 g_hash_table_foreach_remove_or_steal (GHashTable *hash_table,
1559                                       GHRFunc     func,
1560                                       gpointer    user_data,
1561                                       gboolean    notify)
1562 {
1563   guint deleted = 0;
<a name="68" id="anc68"></a><span class="line-modified">1564   gint i;</span>
1565 #ifndef G_DISABLE_ASSERT
1566   gint version = hash_table-&gt;version;
1567 #endif
1568 
1569   for (i = 0; i &lt; hash_table-&gt;size; i++)
1570     {
1571       guint node_hash = hash_table-&gt;hashes[i];
<a name="69" id="anc69"></a><span class="line-modified">1572       gpointer node_key = hash_table-&gt;keys[i];</span>
<span class="line-modified">1573       gpointer node_value = hash_table-&gt;values[i];</span>
1574 
1575       if (HASH_IS_REAL (node_hash) &amp;&amp;
1576           (* func) (node_key, node_value, user_data))
1577         {
1578           g_hash_table_remove_node (hash_table, i, notify);
1579           deleted++;
1580         }
1581 
1582 #ifndef G_DISABLE_ASSERT
1583       g_return_val_if_fail (version == hash_table-&gt;version, 0);
1584 #endif
1585     }
1586 
1587   g_hash_table_maybe_resize (hash_table);
1588 
1589 #ifndef G_DISABLE_ASSERT
1590   if (deleted &gt; 0)
1591     hash_table-&gt;version++;
1592 #endif
1593 
1594   return deleted;
1595 }
1596 
1597 /**
1598  * g_hash_table_foreach_remove:
1599  * @hash_table: a #GHashTable
1600  * @func: the function to call for each key/value pair
1601  * @user_data: user data to pass to the function
1602  *
1603  * Calls the given function for each key/value pair in the
1604  * #GHashTable. If the function returns %TRUE, then the key/value
1605  * pair is removed from the #GHashTable. If you supplied key or
1606  * value destroy functions when creating the #GHashTable, they are
1607  * used to free the memory allocated for the removed keys and values.
1608  *
1609  * See #GHashTableIter for an alternative way to loop over the
1610  * key/value pairs in the hash table.
1611  *
1612  * Returns: the number of key/value pairs removed
1613  */
1614 guint
1615 g_hash_table_foreach_remove (GHashTable *hash_table,
1616                              GHRFunc     func,
1617                              gpointer    user_data)
1618 {
1619   g_return_val_if_fail (hash_table != NULL, 0);
1620   g_return_val_if_fail (func != NULL, 0);
1621 
1622   return g_hash_table_foreach_remove_or_steal (hash_table, func, user_data, TRUE);
1623 }
1624 
1625 /**
1626  * g_hash_table_foreach_steal:
1627  * @hash_table: a #GHashTable
1628  * @func: the function to call for each key/value pair
1629  * @user_data: user data to pass to the function
1630  *
1631  * Calls the given function for each key/value pair in the
1632  * #GHashTable. If the function returns %TRUE, then the key/value
1633  * pair is removed from the #GHashTable, but no key or value
1634  * destroy functions are called.
1635  *
1636  * See #GHashTableIter for an alternative way to loop over the
1637  * key/value pairs in the hash table.
1638  *
1639  * Returns: the number of key/value pairs removed.
1640  */
1641 guint
1642 g_hash_table_foreach_steal (GHashTable *hash_table,
1643                             GHRFunc     func,
1644                             gpointer    user_data)
1645 {
1646   g_return_val_if_fail (hash_table != NULL, 0);
1647   g_return_val_if_fail (func != NULL, 0);
1648 
1649   return g_hash_table_foreach_remove_or_steal (hash_table, func, user_data, FALSE);
1650 }
1651 
1652 /**
1653  * g_hash_table_foreach:
1654  * @hash_table: a #GHashTable
1655  * @func: the function to call for each key/value pair
1656  * @user_data: user data to pass to the function
1657  *
1658  * Calls the given function for each of the key/value pairs in the
1659  * #GHashTable.  The function is passed the key and value of each
1660  * pair, and the given @user_data parameter.  The hash table may not
1661  * be modified while iterating over it (you can&#39;t add/remove
1662  * items). To remove all items matching a predicate, use
1663  * g_hash_table_foreach_remove().
1664  *
1665  * See g_hash_table_find() for performance caveats for linear
1666  * order searches in contrast to g_hash_table_lookup().
1667  */
1668 void
1669 g_hash_table_foreach (GHashTable *hash_table,
1670                       GHFunc      func,
1671                       gpointer    user_data)
1672 {
<a name="70" id="anc70"></a><span class="line-modified">1673   gint i;</span>
1674 #ifndef G_DISABLE_ASSERT
1675   gint version;
1676 #endif
1677 
1678   g_return_if_fail (hash_table != NULL);
1679   g_return_if_fail (func != NULL);
1680 
1681 #ifndef G_DISABLE_ASSERT
1682   version = hash_table-&gt;version;
1683 #endif
1684 
1685   for (i = 0; i &lt; hash_table-&gt;size; i++)
1686     {
1687       guint node_hash = hash_table-&gt;hashes[i];
<a name="71" id="anc71"></a><span class="line-modified">1688       gpointer node_key = hash_table-&gt;keys[i];</span>
<span class="line-modified">1689       gpointer node_value = hash_table-&gt;values[i];</span>
1690 
1691       if (HASH_IS_REAL (node_hash))
1692         (* func) (node_key, node_value, user_data);
1693 
1694 #ifndef G_DISABLE_ASSERT
1695       g_return_if_fail (version == hash_table-&gt;version);
1696 #endif
1697     }
1698 }
1699 
1700 /**
1701  * g_hash_table_find:
1702  * @hash_table: a #GHashTable
1703  * @predicate: function to test the key/value pairs for a certain property
1704  * @user_data: user data to pass to the function
1705  *
1706  * Calls the given function for key/value pairs in the #GHashTable
1707  * until @predicate returns %TRUE. The function is passed the key
1708  * and value of each pair, and the given @user_data parameter. The
1709  * hash table may not be modified while iterating over it (you can&#39;t
1710  * add/remove items).
1711  *
1712  * Note, that hash tables are really only optimized for forward
1713  * lookups, i.e. g_hash_table_lookup(). So code that frequently issues
1714  * g_hash_table_find() or g_hash_table_foreach() (e.g. in the order of
1715  * once per every entry in a hash table) should probably be reworked
1716  * to use additional or different data structures for reverse lookups
1717  * (keep in mind that an O(n) find/foreach operation issued for all n
1718  * values in a hash table ends up needing O(n*n) operations).
1719  *
1720  * Returns: (nullable): The value of the first key/value pair is returned,
1721  *     for which @predicate evaluates to %TRUE. If no pair with the
1722  *     requested property is found, %NULL is returned.
1723  *
1724  * Since: 2.4
1725  */
1726 gpointer
1727 g_hash_table_find (GHashTable *hash_table,
1728                    GHRFunc     predicate,
1729                    gpointer    user_data)
1730 {
<a name="72" id="anc72"></a><span class="line-modified">1731   gint i;</span>
1732 #ifndef G_DISABLE_ASSERT
1733   gint version;
1734 #endif
1735   gboolean match;
1736 
1737   g_return_val_if_fail (hash_table != NULL, NULL);
1738   g_return_val_if_fail (predicate != NULL, NULL);
1739 
1740 #ifndef G_DISABLE_ASSERT
1741   version = hash_table-&gt;version;
1742 #endif
1743 
1744   match = FALSE;
1745 
1746   for (i = 0; i &lt; hash_table-&gt;size; i++)
1747     {
1748       guint node_hash = hash_table-&gt;hashes[i];
<a name="73" id="anc73"></a><span class="line-modified">1749       gpointer node_key = hash_table-&gt;keys[i];</span>
<span class="line-modified">1750       gpointer node_value = hash_table-&gt;values[i];</span>
1751 
1752       if (HASH_IS_REAL (node_hash))
1753         match = predicate (node_key, node_value, user_data);
1754 
1755 #ifndef G_DISABLE_ASSERT
1756       g_return_val_if_fail (version == hash_table-&gt;version, NULL);
1757 #endif
1758 
1759       if (match)
1760         return node_value;
1761     }
1762 
1763   return NULL;
1764 }
1765 
1766 /**
1767  * g_hash_table_size:
1768  * @hash_table: a #GHashTable
1769  *
1770  * Returns the number of elements contained in the #GHashTable.
1771  *
1772  * Returns: the number of key/value pairs in the #GHashTable.
1773  */
1774 guint
1775 g_hash_table_size (GHashTable *hash_table)
1776 {
1777   g_return_val_if_fail (hash_table != NULL, 0);
1778 
1779   return hash_table-&gt;nnodes;
1780 }
1781 
1782 /**
1783  * g_hash_table_get_keys:
1784  * @hash_table: a #GHashTable
1785  *
1786  * Retrieves every key inside @hash_table. The returned data is valid
1787  * until changes to the hash release those keys.
1788  *
1789  * This iterates over every entry in the hash table to build its return value.
1790  * To iterate over the entries in a #GHashTable more efficiently, use a
1791  * #GHashTableIter.
1792  *
1793  * Returns: (transfer container): a #GList containing all the keys
1794  *     inside the hash table. The content of the list is owned by the
1795  *     hash table and should not be modified or freed. Use g_list_free()
1796  *     when done using the list.
1797  *
1798  * Since: 2.14
1799  */
1800 GList *
1801 g_hash_table_get_keys (GHashTable *hash_table)
1802 {
<a name="74" id="anc74"></a><span class="line-modified">1803   gint i;</span>
1804   GList *retval;
1805 
1806   g_return_val_if_fail (hash_table != NULL, NULL);
1807 
1808   retval = NULL;
1809   for (i = 0; i &lt; hash_table-&gt;size; i++)
1810     {
1811       if (HASH_IS_REAL (hash_table-&gt;hashes[i]))
<a name="75" id="anc75"></a><span class="line-modified">1812         retval = g_list_prepend (retval, hash_table-&gt;keys[i]);</span>
1813     }
1814 
1815   return retval;
1816 }
1817 
1818 /**
1819  * g_hash_table_get_keys_as_array:
1820  * @hash_table: a #GHashTable
1821  * @length: (out): the length of the returned array
1822  *
1823  * Retrieves every key inside @hash_table, as an array.
1824  *
1825  * The returned array is %NULL-terminated but may contain %NULL as a
1826  * key.  Use @length to determine the true length if it&#39;s possible that
1827  * %NULL was used as the value for a key.
1828  *
1829  * Note: in the common case of a string-keyed #GHashTable, the return
1830  * value of this function can be conveniently cast to (const gchar **).
1831  *
1832  * This iterates over every entry in the hash table to build its return value.
1833  * To iterate over the entries in a #GHashTable more efficiently, use a
1834  * #GHashTableIter.
1835  *
1836  * You should always free the return result with g_free().  In the
1837  * above-mentioned case of a string-keyed hash table, it may be
1838  * appropriate to use g_strfreev() if you call g_hash_table_steal_all()
1839  * first to transfer ownership of the keys.
1840  *
1841  * Returns: (array length=length) (transfer container): a
1842  *   %NULL-terminated array containing each key from the table.
1843  *
1844  * Since: 2.40
1845  **/
1846 gpointer *
1847 g_hash_table_get_keys_as_array (GHashTable *hash_table,
1848                                 guint      *length)
1849 {
1850   gpointer *result;
<a name="76" id="anc76"></a><span class="line-modified">1851   guint i, j = 0;</span>
1852 
1853   result = g_new (gpointer, hash_table-&gt;nnodes + 1);
1854   for (i = 0; i &lt; hash_table-&gt;size; i++)
1855     {
1856       if (HASH_IS_REAL (hash_table-&gt;hashes[i]))
<a name="77" id="anc77"></a><span class="line-modified">1857         result[j++] = hash_table-&gt;keys[i];</span>
1858     }
1859   g_assert_cmpint (j, ==, hash_table-&gt;nnodes);
1860   result[j] = NULL;
1861 
1862   if (length)
1863     *length = j;
1864 
1865   return result;
1866 }
1867 
1868 /**
1869  * g_hash_table_get_values:
1870  * @hash_table: a #GHashTable
1871  *
1872  * Retrieves every value inside @hash_table. The returned data
1873  * is valid until @hash_table is modified.
1874  *
1875  * This iterates over every entry in the hash table to build its return value.
1876  * To iterate over the entries in a #GHashTable more efficiently, use a
1877  * #GHashTableIter.
1878  *
1879  * Returns: (transfer container): a #GList containing all the values
1880  *     inside the hash table. The content of the list is owned by the
1881  *     hash table and should not be modified or freed. Use g_list_free()
1882  *     when done using the list.
1883  *
1884  * Since: 2.14
1885  */
1886 GList *
1887 g_hash_table_get_values (GHashTable *hash_table)
1888 {
<a name="78" id="anc78"></a><span class="line-modified">1889   gint i;</span>
1890   GList *retval;
1891 
1892   g_return_val_if_fail (hash_table != NULL, NULL);
1893 
1894   retval = NULL;
1895   for (i = 0; i &lt; hash_table-&gt;size; i++)
1896     {
1897       if (HASH_IS_REAL (hash_table-&gt;hashes[i]))
<a name="79" id="anc79"></a><span class="line-modified">1898         retval = g_list_prepend (retval, hash_table-&gt;values[i]);</span>
1899     }
1900 
1901   return retval;
1902 }
1903 
1904 /* Hash functions.
1905  */
1906 
1907 /**
1908  * g_str_equal:
1909  * @v1: (not nullable): a key
1910  * @v2: (not nullable): a key to compare with @v1
1911  *
1912  * Compares two strings for byte-by-byte equality and returns %TRUE
1913  * if they are equal. It can be passed to g_hash_table_new() as the
1914  * @key_equal_func parameter, when using non-%NULL strings as keys in a
1915  * #GHashTable.
1916  *
1917  * This function is typically used for hash table comparisons, but can be used
1918  * for general purpose comparisons of non-%NULL strings. For a %NULL-safe string
1919  * comparison function, see g_strcmp0().
1920  *
1921  * Returns: %TRUE if the two keys match
1922  */
1923 gboolean
1924 g_str_equal (gconstpointer v1,
1925              gconstpointer v2)
1926 {
1927   const gchar *string1 = v1;
1928   const gchar *string2 = v2;
1929 
1930   return strcmp (string1, string2) == 0;
1931 }
1932 
1933 /**
1934  * g_str_hash:
1935  * @v: (not nullable): a string key
1936  *
1937  * Converts a string to a hash value.
1938  *
1939  * This function implements the widely used &quot;djb&quot; hash apparently
1940  * posted by Daniel Bernstein to comp.lang.c some time ago.  The 32
1941  * bit unsigned hash value starts at 5381 and for each byte &#39;c&#39; in
1942  * the string, is updated: `hash = hash * 33 + c`. This function
1943  * uses the signed value of each byte.
1944  *
1945  * It can be passed to g_hash_table_new() as the @hash_func parameter,
1946  * when using non-%NULL strings as keys in a #GHashTable.
1947  *
1948  * Note that this function may not be a perfect fit for all use cases.
1949  * For example, it produces some hash collisions with strings as short
1950  * as 2.
1951  *
1952  * Returns: a hash value corresponding to the key
1953  */
1954 guint
1955 g_str_hash (gconstpointer v)
1956 {
1957   const signed char *p;
1958   guint32 h = 5381;
1959 
1960   for (p = v; *p != &#39;\0&#39;; p++)
1961     h = (h &lt;&lt; 5) + h + *p;
1962 
1963   return h;
1964 }
1965 
1966 /**
1967  * g_direct_hash:
1968  * @v: (nullable): a #gpointer key
1969  *
1970  * Converts a gpointer to a hash value.
1971  * It can be passed to g_hash_table_new() as the @hash_func parameter,
1972  * when using opaque pointers compared by pointer value as keys in a
1973  * #GHashTable.
1974  *
1975  * This hash function is also appropriate for keys that are integers
1976  * stored in pointers, such as `GINT_TO_POINTER (n)`.
1977  *
1978  * Returns: a hash value corresponding to the key.
1979  */
1980 guint
1981 g_direct_hash (gconstpointer v)
1982 {
1983   return GPOINTER_TO_UINT (v);
1984 }
1985 
1986 /**
1987  * g_direct_equal:
1988  * @v1: (nullable): a key
1989  * @v2: (nullable): a key to compare with @v1
1990  *
1991  * Compares two #gpointer arguments and returns %TRUE if they are equal.
1992  * It can be passed to g_hash_table_new() as the @key_equal_func
1993  * parameter, when using opaque pointers compared by pointer value as
1994  * keys in a #GHashTable.
1995  *
1996  * This equality function is also appropriate for keys that are integers
1997  * stored in pointers, such as `GINT_TO_POINTER (n)`.
1998  *
1999  * Returns: %TRUE if the two keys match.
2000  */
2001 gboolean
2002 g_direct_equal (gconstpointer v1,
2003                 gconstpointer v2)
2004 {
2005   return v1 == v2;
2006 }
2007 
2008 /**
2009  * g_int_equal:
2010  * @v1: (not nullable): a pointer to a #gint key
2011  * @v2: (not nullable): a pointer to a #gint key to compare with @v1
2012  *
2013  * Compares the two #gint values being pointed to and returns
2014  * %TRUE if they are equal.
2015  * It can be passed to g_hash_table_new() as the @key_equal_func
2016  * parameter, when using non-%NULL pointers to integers as keys in a
2017  * #GHashTable.
2018  *
2019  * Note that this function acts on pointers to #gint, not on #gint
2020  * directly: if your hash table&#39;s keys are of the form
2021  * `GINT_TO_POINTER (n)`, use g_direct_equal() instead.
2022  *
2023  * Returns: %TRUE if the two keys match.
2024  */
2025 gboolean
2026 g_int_equal (gconstpointer v1,
2027              gconstpointer v2)
2028 {
2029   return *((const gint*) v1) == *((const gint*) v2);
2030 }
2031 
2032 /**
2033  * g_int_hash:
2034  * @v: (not nullable): a pointer to a #gint key
2035  *
2036  * Converts a pointer to a #gint to a hash value.
2037  * It can be passed to g_hash_table_new() as the @hash_func parameter,
2038  * when using non-%NULL pointers to integer values as keys in a #GHashTable.
2039  *
2040  * Note that this function acts on pointers to #gint, not on #gint
2041  * directly: if your hash table&#39;s keys are of the form
2042  * `GINT_TO_POINTER (n)`, use g_direct_hash() instead.
2043  *
2044  * Returns: a hash value corresponding to the key.
2045  */
2046 guint
2047 g_int_hash (gconstpointer v)
2048 {
2049   return *(const gint*) v;
2050 }
2051 
2052 /**
2053  * g_int64_equal:
2054  * @v1: (not nullable): a pointer to a #gint64 key
2055  * @v2: (not nullable): a pointer to a #gint64 key to compare with @v1
2056  *
2057  * Compares the two #gint64 values being pointed to and returns
2058  * %TRUE if they are equal.
2059  * It can be passed to g_hash_table_new() as the @key_equal_func
2060  * parameter, when using non-%NULL pointers to 64-bit integers as keys in a
2061  * #GHashTable.
2062  *
2063  * Returns: %TRUE if the two keys match.
2064  *
2065  * Since: 2.22
2066  */
2067 gboolean
2068 g_int64_equal (gconstpointer v1,
2069                gconstpointer v2)
2070 {
2071   return *((const gint64*) v1) == *((const gint64*) v2);
2072 }
2073 
2074 /**
2075  * g_int64_hash:
2076  * @v: (not nullable): a pointer to a #gint64 key
2077  *
2078  * Converts a pointer to a #gint64 to a hash value.
2079  *
2080  * It can be passed to g_hash_table_new() as the @hash_func parameter,
2081  * when using non-%NULL pointers to 64-bit integer values as keys in a
2082  * #GHashTable.
2083  *
2084  * Returns: a hash value corresponding to the key.
2085  *
2086  * Since: 2.22
2087  */
2088 guint
2089 g_int64_hash (gconstpointer v)
2090 {
2091   return (guint) *(const gint64*) v;
2092 }
2093 
2094 /**
2095  * g_double_equal:
2096  * @v1: (not nullable): a pointer to a #gdouble key
2097  * @v2: (not nullable): a pointer to a #gdouble key to compare with @v1
2098  *
2099  * Compares the two #gdouble values being pointed to and returns
2100  * %TRUE if they are equal.
2101  * It can be passed to g_hash_table_new() as the @key_equal_func
2102  * parameter, when using non-%NULL pointers to doubles as keys in a
2103  * #GHashTable.
2104  *
2105  * Returns: %TRUE if the two keys match.
2106  *
2107  * Since: 2.22
2108  */
2109 gboolean
2110 g_double_equal (gconstpointer v1,
2111                 gconstpointer v2)
2112 {
2113   return *((const gdouble*) v1) == *((const gdouble*) v2);
2114 }
2115 
2116 /**
2117  * g_double_hash:
2118  * @v: (not nullable): a pointer to a #gdouble key
2119  *
2120  * Converts a pointer to a #gdouble to a hash value.
2121  * It can be passed to g_hash_table_new() as the @hash_func parameter,
2122  * It can be passed to g_hash_table_new() as the @hash_func parameter,
2123  * when using non-%NULL pointers to doubles as keys in a #GHashTable.
2124  *
2125  * Returns: a hash value corresponding to the key.
2126  *
2127  * Since: 2.22
2128  */
2129 guint
2130 g_double_hash (gconstpointer v)
2131 {
2132   return (guint) *(const gdouble*) v;
2133 }
<a name="80" id="anc80"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="80" type="hidden" />
</body>
</html>