diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gcharset.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gcharset.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gcharset.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gcharset.c
@@ -25,18 +25,23 @@
 #include "genviron.h"
 #include "ghash.h"
 #include "gmessages.h"
 #include "gstrfuncs.h"
 #include "gthread.h"
+#include "gthreadprivate.h"
 #ifdef G_OS_WIN32
 #include "gwin32.h"
 #endif
 
 #include "libcharset/libcharset.h"
 
 #include <string.h>
 #include <stdio.h>
+#ifdef G_OS_WIN32
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#endif
 
 G_LOCK_DEFINE_STATIC (aliases);
 
 static GHashTable *
 get_alias_hash (void)
@@ -185,20 +190,17 @@
   static GPrivate cache_private = G_PRIVATE_INIT (charset_cache_free);
   GCharsetCache *cache = g_private_get (&cache_private);
   const gchar *raw;
 
   if (!cache)
-    {
-      cache = g_new0 (GCharsetCache, 1);
-      g_private_set (&cache_private, cache);
-    }
+    cache = g_private_set_alloc0 (&cache_private, sizeof (GCharsetCache));
 
   G_LOCK (aliases);
   raw = _g_locale_charset_raw ();
   G_UNLOCK (aliases);
 
-  if (!(cache->raw && strcmp (cache->raw, raw) == 0))
+  if (cache->raw == NULL || strcmp (cache->raw, raw) != 0)
     {
       const gchar *new_charset;
 
       g_free (cache->raw);
       g_free (cache->charset);
@@ -229,10 +231,117 @@
   g_get_charset (&charset);
 
   return g_strdup (charset);
 }
 
+/**
+ * g_get_console_charset:
+ * @charset: (out) (optional) (transfer none): return location for character set
+ *   name, or %NULL.
+ *
+ * Obtains the character set used by the console attached to the process,
+ * which is suitable for printing output to the terminal.
+ *
+ * Usually this matches the result returned by g_get_charset(), but in
+ * environments where the locale's character set does not match the encoding
+ * of the console this function tries to guess a more suitable value instead.
+ *
+ * On Windows the character set returned by this function is the
+ * output code page used by the console associated with the calling process.
+ * If the codepage can't be determined (for example because there is no
+ * console attached) UTF-8 is assumed.
+ *
+ * The return value is %TRUE if the locale's encoding is UTF-8, in that
+ * case you can perhaps avoid calling g_convert().
+ *
+ * The string returned in @charset is not allocated, and should not be
+ * freed.
+ *
+ * Returns: %TRUE if the returned charset is UTF-8
+ *
+ * Since: 2.62
+ */
+gboolean
+g_get_console_charset (const char **charset)
+{
+#ifdef G_OS_WIN32
+  static GPrivate cache_private = G_PRIVATE_INIT (charset_cache_free);
+  GCharsetCache *cache = g_private_get (&cache_private);
+  const gchar *locale;
+  unsigned int cp;
+  char buf[2 + 20 + 1]; /* "CP" + G_MAXUINT64 (to be safe) in decimal form (20 bytes) + "\0" */
+  const gchar *raw = NULL;
+
+  if (!cache)
+    cache = g_private_set_alloc0 (&cache_private, sizeof (GCharsetCache));
+
+  /* first try to query $LANG (works for Cygwin/MSYS/MSYS2 and others using mintty) */
+  locale = g_getenv ("LANG");
+  if (locale != NULL && locale[0] != '\0')
+    {
+      /* If the locale name contains an encoding after the dot, return it.  */
+      const char *dot = strchr (locale, '.');
+
+      if (dot != NULL)
+        {
+          const char *modifier;
+
+          dot++;
+          /* Look for the possible @... trailer and remove it, if any.  */
+          modifier = strchr (dot, '@');
+          if (modifier == NULL)
+            raw = dot;
+          else if (modifier - dot < sizeof (buf))
+            {
+              memcpy (buf, dot, modifier - dot);
+              buf[modifier - dot] = '\0';
+              raw = buf;
+            }
+        }
+    }
+  /* next try querying console codepage using native win32 API */
+  if (raw == NULL)
+    {
+      cp = GetConsoleOutputCP ();
+      if (cp)
+        {
+          sprintf (buf, "CP%u", cp);
+          raw = buf;
+        }
+      else if (GetLastError () != ERROR_INVALID_HANDLE)
+        {
+          gchar *emsg = g_win32_error_message (GetLastError ());
+          g_warning ("Failed to determine console output code page: %s. "
+                     "Falling back to UTF-8", emsg);
+          g_free (emsg);
+        }
+    }
+  /* fall-back to UTF-8 if the rest failed (it's a sane and universal default) */
+  if (raw == NULL)
+    raw = "UTF-8";
+
+  if (cache->raw == NULL || strcmp (cache->raw, raw) != 0)
+    {
+      const gchar *new_charset;
+
+      g_free (cache->raw);
+      g_free (cache->charset);
+      cache->raw = g_strdup (raw);
+      cache->is_utf8 = g_utf8_get_charset_internal (raw, &new_charset);
+      cache->charset = g_strdup (new_charset);
+    }
+
+  if (charset)
+    *charset = cache->charset;
+
+  return cache->is_utf8;
+#else
+  /* assume the locale settings match the console encoding on non-Windows OSs */
+  return g_get_charset (charset);
+#endif
+}
+
 #ifndef G_OS_WIN32
 
 /* read an alias file for the locales */
 static void
 read_aliases (const gchar *file,
@@ -574,19 +683,20 @@
  * @category_name, and `LANG` to find the list of locales specified by the
  * user.
  *
  * g_get_language_names() returns g_get_language_names_with_category("LC_MESSAGES").
  *
- * Returns: (array zero-terminated=1) (transfer none): a %NULL-terminated array of strings owned by GLib
- *    that must not be modified or freed.
+ * Returns: (array zero-terminated=1) (transfer none): a %NULL-terminated array of strings owned by
+ *    the thread g_get_language_names_with_category was called from.
+ *    It must not be modified or freed. It must be copied if planned to be used in another thread.
  *
  * Since: 2.58
  */
 const gchar * const *
 g_get_language_names_with_category (const gchar *category_name)
 {
-  static GPrivate cache_private = G_PRIVATE_INIT ((void (*)(gpointer)) g_hash_table_remove_all);
+  static GPrivate cache_private = G_PRIVATE_INIT ((void (*)(gpointer)) g_hash_table_unref);
   GHashTable *cache = g_private_get (&cache_private);
   const gchar *languages;
   GLanguageNamesCache *name_cache;
 
   g_return_val_if_fail (category_name != NULL, NULL);
