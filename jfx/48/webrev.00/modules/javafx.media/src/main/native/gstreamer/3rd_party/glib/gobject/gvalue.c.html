<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gvalue.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /* GObject - GLib Type, Object, Parameter and Signal Library
  2  * Copyright (C) 1997-1999, 2000-2001 Tim Janik and Red Hat, Inc.
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Lesser General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2.1 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Lesser General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Lesser General
 15  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 16  */
 17 
 18 /*
 19  * FIXME: MT-safety
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 
 24 #include &lt;string.h&gt;
 25 
 26 #include &quot;gvalue.h&quot;
 27 #include &quot;gvaluecollector.h&quot;
 28 #include &quot;gbsearcharray.h&quot;
 29 #include &quot;gtype-private.h&quot;
 30 
 31 
 32 /**
 33  * SECTION:generic_values
 34  * @short_description: A polymorphic type that can hold values of any
 35  *     other type
 36  * @see_also: The fundamental types which all support #GValue
 37  *     operations and thus can be used as a type initializer for
 38  *     g_value_init() are defined by a separate interface.  See the
 39  *     [standard values API][gobject-Standard-Parameter-and-Value-Types]
 40  *     for details
 41  * @title: Generic values
 42  *
 43  * The #GValue structure is basically a variable container that consists
 44  * of a type identifier and a specific value of that type.
 45  * The type identifier within a #GValue structure always determines the
 46  * type of the associated value.
 47  * To create an undefined #GValue structure, simply create a zero-filled
 48  * #GValue structure. To initialize the #GValue, use the g_value_init()
 49  * function. A #GValue cannot be used until it is initialized.
 50  * The basic type operations (such as freeing and copying) are determined
 51  * by the #GTypeValueTable associated with the type ID stored in the #GValue.
 52  * Other #GValue operations (such as converting values between types) are
 53  * provided by this interface.
 54  *
 55  * The code in the example program below demonstrates #GValue&#39;s
 56  * features.
 57  *
 58  * |[&lt;!-- language=&quot;C&quot; --&gt;
 59  * #include &lt;glib-object.h&gt;
 60  *
 61  * static void
 62  * int2string (const GValue *src_value,
 63  *             GValue       *dest_value)
 64  * {
 65  *   if (g_value_get_int (src_value) == 42)
 66  *     g_value_set_static_string (dest_value, &quot;An important number&quot;);
 67  *   else
 68  *     g_value_set_static_string (dest_value, &quot;What&#39;s that?&quot;);
 69  * }
 70  *
 71  * int
 72  * main (int   argc,
 73  *       char *argv[])
 74  * {
 75  *   // GValues must be initialized
 76  *   GValue a = G_VALUE_INIT;
 77  *   GValue b = G_VALUE_INIT;
 78  *   const gchar *message;
 79  *
 80  *   // The GValue starts empty
 81  *   g_assert (!G_VALUE_HOLDS_STRING (&amp;a));
 82  *
 83  *   // Put a string in it
 84  *   g_value_init (&amp;a, G_TYPE_STRING);
 85  *   g_assert (G_VALUE_HOLDS_STRING (&amp;a));
 86  *   g_value_set_static_string (&amp;a, &quot;Hello, world!&quot;);
 87  *   g_printf (&quot;%s\n&quot;, g_value_get_string (&amp;a));
 88  *
 89  *   // Reset it to its pristine state
 90  *   g_value_unset (&amp;a);
 91  *
 92  *   // It can then be reused for another type
 93  *   g_value_init (&amp;a, G_TYPE_INT);
 94  *   g_value_set_int (&amp;a, 42);
 95  *
 96  *   // Attempt to transform it into a GValue of type STRING
 97  *   g_value_init (&amp;b, G_TYPE_STRING);
 98  *
 99  *   // An INT is transformable to a STRING
100  *   g_assert (g_value_type_transformable (G_TYPE_INT, G_TYPE_STRING));
101  *
102  *   g_value_transform (&amp;a, &amp;b);
103  *   g_printf (&quot;%s\n&quot;, g_value_get_string (&amp;b));
104  *
105  *   // Attempt to transform it again using a custom transform function
106  *   g_value_register_transform_func (G_TYPE_INT, G_TYPE_STRING, int2string);
107  *   g_value_transform (&amp;a, &amp;b);
108  *   g_printf (&quot;%s\n&quot;, g_value_get_string (&amp;b));
109  *   return 0;
110  * }
111  * ]|
112  */
113 
114 
115 /* --- typedefs &amp; structures --- */
116 typedef struct {
117   GType src_type;
118   GType dest_type;
119   GValueTransform func;
120 } TransformEntry;
121 
122 
123 /* --- prototypes --- */
124 static gint transform_entries_cmp (gconstpointer bsearch_node1,
125            gconstpointer bsearch_node2);
126 
127 
128 /* --- variables --- */
129 static GBSearchArray *transform_array = NULL;
130 static GBSearchConfig transform_bconfig = {
131   sizeof (TransformEntry),
132   transform_entries_cmp,
133   G_BSEARCH_ARRAY_ALIGN_POWER2,
134 };
135 
136 
137 /* --- functions --- */
138 void
139 _g_value_c_init (void)
140 {
141   transform_array = g_bsearch_array_create (&amp;transform_bconfig);
142 }
143 
144 static inline void    /* keep this function in sync with gvaluecollector.h and gboxed.c */
145 value_meminit (GValue *value,
146          GType   value_type)
147 {
148   value-&gt;g_type = value_type;
149   memset (value-&gt;data, 0, sizeof (value-&gt;data));
150 }
151 
152 /**
153  * g_value_init:
154  * @value: A zero-filled (uninitialized) #GValue structure.
155  * @g_type: Type the #GValue should hold values of.
156  *
157  * Initializes @value with the default value of @type.
158  *
159  * Returns: (transfer none): the #GValue structure that has been passed in
160  */
161 GValue*
162 g_value_init (GValue *value,
163         GType   g_type)
164 {
165   GTypeValueTable *value_table;
166   /* g_return_val_if_fail (G_TYPE_IS_VALUE (g_type), NULL); be more elaborate below */
167   g_return_val_if_fail (value != NULL, NULL);
168   /* g_return_val_if_fail (G_VALUE_TYPE (value) == 0, NULL);  be more elaborate below */
169 
170   value_table = g_type_value_table_peek (g_type);
171 
172   if (value_table &amp;&amp; G_VALUE_TYPE (value) == 0)
173     {
174       /* setup and init */
175       value_meminit (value, g_type);
176       value_table-&gt;value_init (value);
177     }
178   else if (G_VALUE_TYPE (value))
179     g_warning (&quot;%s: cannot initialize GValue with type &#39;%s&#39;, the value has already been initialized as &#39;%s&#39;&quot;,
180          G_STRLOC,
181          g_type_name (g_type),
182          g_type_name (G_VALUE_TYPE (value)));
183   else /* !G_TYPE_IS_VALUE (g_type) */
184     g_warning (&quot;%s: cannot initialize GValue with type &#39;%s&#39;, %s&quot;,
185                G_STRLOC,
186                g_type_name (g_type),
187                value_table ? &quot;this type is abstract with regards to GValue use, use a more specific (derived) type&quot; : &quot;this type has no GTypeValueTable implementation&quot;);
188   return value;
189 }
190 
191 /**
192  * g_value_copy:
193  * @src_value: An initialized #GValue structure.
194  * @dest_value: An initialized #GValue structure of the same type as @src_value.
195  *
196  * Copies the value of @src_value into @dest_value.
197  */
198 void
199 g_value_copy (const GValue *src_value,
200         GValue       *dest_value)
201 {
202   g_return_if_fail (src_value);
203   g_return_if_fail (dest_value);
204   g_return_if_fail (g_value_type_compatible (G_VALUE_TYPE (src_value), G_VALUE_TYPE (dest_value)));
205 
206   if (src_value != dest_value)
207     {
208       GType dest_type = G_VALUE_TYPE (dest_value);
209       GTypeValueTable *value_table = g_type_value_table_peek (dest_type);
210 
211       g_return_if_fail (value_table);
212 
213       /* make sure dest_value&#39;s value is free()d */
214       if (value_table-&gt;value_free)
215   value_table-&gt;value_free (dest_value);
216 
217       /* setup and copy */
218       value_meminit (dest_value, dest_type);
219       value_table-&gt;value_copy (src_value, dest_value);
220     }
221 }
222 
223 /**
224  * g_value_reset:
225  * @value: An initialized #GValue structure.
226  *
227  * Clears the current value in @value and resets it to the default value
228  * (as if the value had just been initialized).
229  *
230  * Returns: the #GValue structure that has been passed in
231  */
232 GValue*
233 g_value_reset (GValue *value)
234 {
235   GTypeValueTable *value_table;
236   GType g_type;
237 
238   g_return_val_if_fail (value, NULL);
239   g_type = G_VALUE_TYPE (value);
240 
241   value_table = g_type_value_table_peek (g_type);
242   g_return_val_if_fail (value_table, NULL);
243 
244   /* make sure value&#39;s value is free()d */
245   if (value_table-&gt;value_free)
246     value_table-&gt;value_free (value);
247 
248   /* setup and init */
249   value_meminit (value, g_type);
250   value_table-&gt;value_init (value);
251 
252   return value;
253 }
254 
255 /**
256  * g_value_unset:
257  * @value: An initialized #GValue structure.
258  *
259  * Clears the current value in @value (if any) and &quot;unsets&quot; the type,
260  * this releases all resources associated with this GValue. An unset
261  * value is the same as an uninitialized (zero-filled) #GValue
262  * structure.
263  */
264 void
265 g_value_unset (GValue *value)
266 {
267   GTypeValueTable *value_table;
268 
269   if (value-&gt;g_type == 0)
270     return;
271 
272   g_return_if_fail (value);
273 
274   value_table = g_type_value_table_peek (G_VALUE_TYPE (value));
275   g_return_if_fail (value_table);
276 
277   if (value_table-&gt;value_free)
278     value_table-&gt;value_free (value);
279   memset (value, 0, sizeof (*value));
280 }
281 
282 /**
283  * g_value_fits_pointer:
284  * @value: An initialized #GValue structure.
285  *
286  * Determines if @value will fit inside the size of a pointer value.
287  * This is an internal function introduced mainly for C marshallers.
288  *
289  * Returns: %TRUE if @value will fit inside a pointer value.
290  */
291 gboolean
292 g_value_fits_pointer (const GValue *value)
293 {
294   GTypeValueTable *value_table;
295 
296   g_return_val_if_fail (value, FALSE);
297 
298   value_table = g_type_value_table_peek (G_VALUE_TYPE (value));
299   g_return_val_if_fail (value_table, FALSE);
300 
301   return value_table-&gt;value_peek_pointer != NULL;
302 }
303 
304 /**
305  * g_value_peek_pointer:
306  * @value: An initialized #GValue structure
307  *
308  * Returns the value contents as pointer. This function asserts that
309  * g_value_fits_pointer() returned %TRUE for the passed in value.
310  * This is an internal function introduced mainly for C marshallers.
311  *
312  * Returns: (transfer none): the value contents as pointer
313  */
314 gpointer
315 g_value_peek_pointer (const GValue *value)
316 {
317   GTypeValueTable *value_table;
318 
319   g_return_val_if_fail (value, NULL);
320 
321   value_table = g_type_value_table_peek (G_VALUE_TYPE (value));
322   g_return_val_if_fail (value_table, NULL);
323 
324   if (!value_table-&gt;value_peek_pointer)
325     {
326       g_return_val_if_fail (g_value_fits_pointer (value) == TRUE, NULL);
327       return NULL;
328     }
329 
330   return value_table-&gt;value_peek_pointer (value);
331 }
332 
333 /**
334  * g_value_set_instance:
335  * @value: An initialized #GValue structure.
336  * @instance: (nullable): the instance
337  *
338  * Sets @value from an instantiatable type via the
339  * value_table&#39;s collect_value() function.
340  */
341 void
342 g_value_set_instance (GValue  *value,
343           gpointer instance)
344 {
345   GType g_type;
346   GTypeValueTable *value_table;
347   GTypeCValue cvalue;
348   gchar *error_msg;
349 
350   g_return_if_fail (value);
351   g_type = G_VALUE_TYPE (value);
352   value_table = g_type_value_table_peek (g_type);
353   g_return_if_fail (value_table);
354 
355   if (instance)
356     {
357       g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
358       g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (instance), G_VALUE_TYPE (value)));
359     }
360 
361   g_return_if_fail (strcmp (value_table-&gt;collect_format, &quot;p&quot;) == 0);
362 
363   memset (&amp;cvalue, 0, sizeof (cvalue));
364   cvalue.v_pointer = instance;
365 
366   /* make sure value&#39;s value is free()d */
367   if (value_table-&gt;value_free)
368     value_table-&gt;value_free (value);
369 
370   /* setup and collect */
371   value_meminit (value, g_type);
372   error_msg = value_table-&gt;collect_value (value, 1, &amp;cvalue, 0);
373   if (error_msg)
374     {
375       g_warning (&quot;%s: %s&quot;, G_STRLOC, error_msg);
376       g_free (error_msg);
377 
378       /* we purposely leak the value here, it might not be
379        * in a sane state if an error condition occoured
380        */
381       value_meminit (value, g_type);
382       value_table-&gt;value_init (value);
383     }
384 }
385 
386 /**
387  * g_value_init_from_instance:
388  * @value: An uninitialized #GValue structure.
389  * @instance: (type GObject.TypeInstance): the instance
390  *
391  * Initializes and sets @value from an instantiatable type via the
392  * value_table&#39;s collect_value() function.
393  *
394  * Note: The @value will be initialised with the exact type of
395  * @instance.  If you wish to set the @value&#39;s type to a different GType
396  * (such as a parent class GType), you need to manually call
397  * g_value_init() and g_value_set_instance().
398  *
399  * Since: 2.42
400  */
401 void
402 g_value_init_from_instance (GValue  *value,
403                             gpointer instance)
404 {
405   g_return_if_fail (value != NULL &amp;&amp; G_VALUE_TYPE(value) == 0);
406 
407   if (G_IS_OBJECT (instance))
408     {
409       /* Fast-path.
410        * If G_IS_OBJECT() succeeds we know:
411        * * that instance is present and valid
412        * * that it is a GObject, and therefore we can directly
413        *   use the collect implementation (g_object_ref) */
414       value_meminit (value, G_TYPE_FROM_INSTANCE (instance));
415       value-&gt;data[0].v_pointer = g_object_ref (instance);
416     }
417   else
418     {
419       GType g_type;
420       GTypeValueTable *value_table;
421       GTypeCValue cvalue;
422       gchar *error_msg;
423 
424       g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
425 
426       g_type = G_TYPE_FROM_INSTANCE (instance);
427       value_table = g_type_value_table_peek (g_type);
428       g_return_if_fail (strcmp (value_table-&gt;collect_format, &quot;p&quot;) == 0);
429 
430       memset (&amp;cvalue, 0, sizeof (cvalue));
431       cvalue.v_pointer = instance;
432 
433       /* setup and collect */
434       value_meminit (value, g_type);
435       value_table-&gt;value_init (value);
436       error_msg = value_table-&gt;collect_value (value, 1, &amp;cvalue, 0);
437       if (error_msg)
438         {
439           g_warning (&quot;%s: %s&quot;, G_STRLOC, error_msg);
440           g_free (error_msg);
441 
442           /* we purposely leak the value here, it might not be
443            * in a sane state if an error condition occoured
444            */
445           value_meminit (value, g_type);
446           value_table-&gt;value_init (value);
447         }
448     }
449 }
450 
451 static GValueTransform
452 transform_func_lookup (GType src_type,
453            GType dest_type)
454 {
455   TransformEntry entry;
456 
457   entry.src_type = src_type;
458   do
459     {
460       entry.dest_type = dest_type;
461       do
462   {
463     TransformEntry *e;
464 
465     e = g_bsearch_array_lookup (transform_array, &amp;transform_bconfig, &amp;entry);
466     if (e)
467       {
468         /* need to check that there hasn&#39;t been a change in value handling */
469         if (g_type_value_table_peek (entry.dest_type) == g_type_value_table_peek (dest_type) &amp;&amp;
470       g_type_value_table_peek (entry.src_type) == g_type_value_table_peek (src_type))
471     return e-&gt;func;
472       }
473     entry.dest_type = g_type_parent (entry.dest_type);
474   }
475       while (entry.dest_type);
476 
477       entry.src_type = g_type_parent (entry.src_type);
478     }
479   while (entry.src_type);
480 
481   return NULL;
482 }
483 
484 static gint
485 transform_entries_cmp (gconstpointer bsearch_node1,
486            gconstpointer bsearch_node2)
487 {
488   const TransformEntry *e1 = bsearch_node1;
489   const TransformEntry *e2 = bsearch_node2;
490   gint cmp = G_BSEARCH_ARRAY_CMP (e1-&gt;src_type, e2-&gt;src_type);
491 
492   if (cmp)
493     return cmp;
494   else
495     return G_BSEARCH_ARRAY_CMP (e1-&gt;dest_type, e2-&gt;dest_type);
496 }
497 
498 /**
499  * g_value_register_transform_func: (skip)
500  * @src_type: Source type.
501  * @dest_type: Target type.
502  * @transform_func: a function which transforms values of type @src_type
503  *  into value of type @dest_type
504  *
505  * Registers a value transformation function for use in g_value_transform().
506  * A previously registered transformation function for @src_type and @dest_type
507  * will be replaced.
508  */
509 void
510 g_value_register_transform_func (GType           src_type,
511          GType           dest_type,
512          GValueTransform transform_func)
513 {
514   TransformEntry entry;
515 
516   /* these checks won&#39;t pass for dynamic types.
517    * g_return_if_fail (G_TYPE_HAS_VALUE_TABLE (src_type));
518    * g_return_if_fail (G_TYPE_HAS_VALUE_TABLE (dest_type));
519    */
520   g_return_if_fail (transform_func != NULL);
521 
522   entry.src_type = src_type;
523   entry.dest_type = dest_type;
524 
525 #if 0 /* let transform function replacement be a valid operation */
526   if (g_bsearch_array_lookup (transform_array, &amp;transform_bconfig, &amp;entry))
527     g_warning (&quot;reregistering value transformation function (%p) for &#39;%s&#39; to &#39;%s&#39;&quot;,
528          transform_func,
529          g_type_name (src_type),
530          g_type_name (dest_type));
531 #endif
532 
533   entry.func = transform_func;
534   transform_array = g_bsearch_array_replace (transform_array, &amp;transform_bconfig, &amp;entry);
535 }
536 
537 /**
538  * g_value_type_transformable:
539  * @src_type: Source type.
540  * @dest_type: Target type.
541  *
542  * Check whether g_value_transform() is able to transform values
543  * of type @src_type into values of type @dest_type. Note that for
544  * the types to be transformable, they must be compatible or a
545  * transformation function must be registered.
546  *
547  * Returns: %TRUE if the transformation is possible, %FALSE otherwise.
548  */
549 gboolean
550 g_value_type_transformable (GType src_type,
551           GType dest_type)
552 {
553   g_return_val_if_fail (src_type, FALSE);
554   g_return_val_if_fail (dest_type, FALSE);
555 
556   return (g_value_type_compatible (src_type, dest_type) ||
557     transform_func_lookup (src_type, dest_type) != NULL);
558 }
559 
560 /**
561  * g_value_type_compatible:
562  * @src_type: source type to be copied.
563  * @dest_type: destination type for copying.
564  *
565  * Returns whether a #GValue of type @src_type can be copied into
566  * a #GValue of type @dest_type.
567  *
568  * Returns: %TRUE if g_value_copy() is possible with @src_type and @dest_type.
569  */
570 gboolean
571 g_value_type_compatible (GType src_type,
572        GType dest_type)
573 {
574   g_return_val_if_fail (src_type, FALSE);
575   g_return_val_if_fail (dest_type, FALSE);
576 
577   /* Fast path */
578   if (src_type == dest_type)
579     return TRUE;
580 
581   return (g_type_is_a (src_type, dest_type) &amp;&amp;
582     g_type_value_table_peek (dest_type) == g_type_value_table_peek (src_type));
583 }
584 
585 /**
586  * g_value_transform:
587  * @src_value: Source value.
588  * @dest_value: Target value.
589  *
590  * Tries to cast the contents of @src_value into a type appropriate
591  * to store in @dest_value, e.g. to transform a %G_TYPE_INT value
592  * into a %G_TYPE_FLOAT value. Performing transformations between
593  * value types might incur precision lossage. Especially
594  * transformations into strings might reveal seemingly arbitrary
595  * results and shouldn&#39;t be relied upon for production code (such
596  * as rcfile value or object property serialization).
597  *
598  * Returns: Whether a transformation rule was found and could be applied.
599  *  Upon failing transformations, @dest_value is left untouched.
600  */
601 gboolean
602 g_value_transform (const GValue *src_value,
603        GValue       *dest_value)
604 {
605   GType dest_type;
606 
607   g_return_val_if_fail (src_value, FALSE);
608   g_return_val_if_fail (dest_value, FALSE);
609 
610   dest_type = G_VALUE_TYPE (dest_value);
611   if (g_value_type_compatible (G_VALUE_TYPE (src_value), dest_type))
612     {
613       g_value_copy (src_value, dest_value);
614 
615       return TRUE;
616     }
617   else
618     {
619       GValueTransform transform = transform_func_lookup (G_VALUE_TYPE (src_value), dest_type);
620 
621       if (transform)
622   {
623     g_value_unset (dest_value);
624 
625     /* setup and transform */
626     value_meminit (dest_value, dest_type);
627     transform (src_value, dest_value);
628 
629     return TRUE;
630   }
631     }
632   return FALSE;
633 }
    </pre>
  </body>
</html>