<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst/audioconvert/gstaudioconvert.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../gst-libs/gst/video/videooverlay.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../typefind/gsttypefindfunctions.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst/audioconvert/gstaudioconvert.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 121 /* type functions */
 122 static void gst_audio_convert_dispose (GObject * obj);
 123 
 124 /* gstreamer functions */
 125 static gboolean gst_audio_convert_get_unit_size (GstBaseTransform * base,
 126     GstCaps * caps, gsize * size);
 127 static GstCaps *gst_audio_convert_transform_caps (GstBaseTransform * base,
 128     GstPadDirection direction, GstCaps * caps, GstCaps * filter);
 129 static GstCaps *gst_audio_convert_fixate_caps (GstBaseTransform * base,
 130     GstPadDirection direction, GstCaps * caps, GstCaps * othercaps);
 131 static gboolean gst_audio_convert_set_caps (GstBaseTransform * base,
 132     GstCaps * incaps, GstCaps * outcaps);
 133 static GstFlowReturn gst_audio_convert_transform (GstBaseTransform * base,
 134     GstBuffer * inbuf, GstBuffer * outbuf);
 135 static GstFlowReturn gst_audio_convert_transform_ip (GstBaseTransform * base,
 136     GstBuffer * buf);
 137 static gboolean gst_audio_convert_transform_meta (GstBaseTransform * trans,
 138     GstBuffer * outbuf, GstMeta * meta, GstBuffer * inbuf);
 139 static GstFlowReturn gst_audio_convert_submit_input_buffer (GstBaseTransform *
 140     base, gboolean is_discont, GstBuffer * input);


 141 static void gst_audio_convert_set_property (GObject * object, guint prop_id,
 142     const GValue * value, GParamSpec * pspec);
 143 static void gst_audio_convert_get_property (GObject * object, guint prop_id,
 144     GValue * value, GParamSpec * pspec);
 145 
 146 /* AudioConvert signals and args */
 147 enum
 148 {
 149   /* FILL ME */
 150   LAST_SIGNAL
 151 };
 152 
 153 enum
 154 {
 155   PROP_0,
 156   PROP_DITHERING,
 157   PROP_NOISE_SHAPING,
 158   PROP_MIX_MATRIX,
 159 };
 160 
 161 #define DEBUG_INIT \
 162   GST_DEBUG_CATEGORY_INIT (audio_convert_debug, &quot;audioconvert&quot;, 0, &quot;audio conversion element&quot;); \
 163   GST_DEBUG_CATEGORY_GET (GST_CAT_PERFORMANCE, &quot;GST_PERFORMANCE&quot;);
 164 #define gst_audio_convert_parent_class parent_class
 165 G_DEFINE_TYPE_WITH_CODE (GstAudioConvert, gst_audio_convert,
 166     GST_TYPE_BASE_TRANSFORM, DEBUG_INIT);
 167 
 168 /*** GSTREAMER PROTOTYPES *****************************************************/
 169 
 170 #define STATIC_CAPS \
 171 GST_STATIC_CAPS (GST_AUDIO_CAPS_MAKE (GST_AUDIO_FORMATS_ALL) \
<span class="line-modified"> 172     &quot;, layout = (string) interleaved&quot;)</span>
 173 
 174 static GstStaticPadTemplate gst_audio_convert_src_template =
 175 GST_STATIC_PAD_TEMPLATE (&quot;src&quot;,
 176     GST_PAD_SRC,
 177     GST_PAD_ALWAYS,
 178     STATIC_CAPS);
 179 
 180 static GstStaticPadTemplate gst_audio_convert_sink_template =
 181 GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,
 182     GST_PAD_SINK,
 183     GST_PAD_ALWAYS,
 184     STATIC_CAPS);
 185 
 186 
 187 /*** TYPE FUNCTIONS ***********************************************************/
 188 static void
 189 gst_audio_convert_class_init (GstAudioConvertClass * klass)
 190 {
 191   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 192   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
</pre>
<hr />
<pre>
 226   gst_element_class_set_static_metadata (element_class, &quot;Audio converter&quot;,
 227       &quot;Filter/Converter/Audio&quot;, &quot;Convert audio to different formats&quot;,
 228       &quot;Benjamin Otte &lt;otte@gnome.org&gt;&quot;);
 229 
 230   basetransform_class-&gt;get_unit_size =
 231       GST_DEBUG_FUNCPTR (gst_audio_convert_get_unit_size);
 232   basetransform_class-&gt;transform_caps =
 233       GST_DEBUG_FUNCPTR (gst_audio_convert_transform_caps);
 234   basetransform_class-&gt;fixate_caps =
 235       GST_DEBUG_FUNCPTR (gst_audio_convert_fixate_caps);
 236   basetransform_class-&gt;set_caps =
 237       GST_DEBUG_FUNCPTR (gst_audio_convert_set_caps);
 238   basetransform_class-&gt;transform =
 239       GST_DEBUG_FUNCPTR (gst_audio_convert_transform);
 240   basetransform_class-&gt;transform_ip =
 241       GST_DEBUG_FUNCPTR (gst_audio_convert_transform_ip);
 242   basetransform_class-&gt;transform_meta =
 243       GST_DEBUG_FUNCPTR (gst_audio_convert_transform_meta);
 244   basetransform_class-&gt;submit_input_buffer =
 245       GST_DEBUG_FUNCPTR (gst_audio_convert_submit_input_buffer);


 246 
<span class="line-removed"> 247   basetransform_class-&gt;passthrough_on_same_caps = TRUE;</span>
 248   basetransform_class-&gt;transform_ip_on_passthrough = FALSE;
 249 }
 250 
 251 static void
 252 gst_audio_convert_init (GstAudioConvert * this)
 253 {
 254   this-&gt;dither = GST_AUDIO_DITHER_TPDF;
 255   this-&gt;ns = GST_AUDIO_NOISE_SHAPING_NONE;
 256   g_value_init (&amp;this-&gt;mix_matrix, GST_TYPE_ARRAY);
 257 
 258   gst_base_transform_set_gap_aware (GST_BASE_TRANSFORM (this), TRUE);
 259 }
 260 
 261 static void
 262 gst_audio_convert_dispose (GObject * obj)
 263 {
 264   GstAudioConvert *this = GST_AUDIO_CONVERT (obj);
 265 
 266   if (this-&gt;convert) {
 267     gst_audio_converter_free (this-&gt;convert);
</pre>
<hr />
<pre>
 290   *size = info.bpf;
 291   GST_INFO_OBJECT (base, &quot;unit_size = %&quot; G_GSIZE_FORMAT, *size);
 292 
 293   return TRUE;
 294 
 295 parse_error:
 296   {
 297     GST_INFO_OBJECT (base, &quot;failed to parse caps to get unit_size&quot;);
 298     return FALSE;
 299   }
 300 }
 301 
 302 static gboolean
 303 remove_format_from_structure (GstCapsFeatures * features,
 304     GstStructure * structure, gpointer user_data G_GNUC_UNUSED)
 305 {
 306   gst_structure_remove_field (structure, &quot;format&quot;);
 307   return TRUE;
 308 }
 309 








 310 static gboolean
 311 remove_channels_from_structure (GstCapsFeatures * features, GstStructure * s,
 312     gpointer user_data)
 313 {
 314   guint64 mask;
 315   gint channels;
 316   GstAudioConvert *this = GST_AUDIO_CONVERT (user_data);
 317 
 318   /* Only remove the channels and channel-mask for non-NONE layouts,
 319    * or if a mix matrix was manually specified */
 320   if (this-&gt;mix_matrix_was_set ||
 321       !gst_structure_get (s, &quot;channel-mask&quot;, GST_TYPE_BITMASK, &amp;mask, NULL) ||
 322       (mask != 0 || (gst_structure_get_int (s, &quot;channels&quot;, &amp;channels)
 323               &amp;&amp; channels == 1))) {
 324     gst_structure_remove_fields (s, &quot;channel-mask&quot;, &quot;channels&quot;, NULL);
 325   }
 326 
 327   return TRUE;
<span class="line-modified"> 328     }</span>
 329 
 330 static gboolean
 331 add_other_channels_to_structure (GstCapsFeatures * features, GstStructure * s,
 332     gpointer user_data)
 333 {
 334   gint other_channels = GPOINTER_TO_INT (user_data);
 335 
 336   gst_structure_set (s, &quot;channels&quot;, G_TYPE_INT, other_channels, NULL);
 337 
 338   return TRUE;
 339 }
 340 
 341 /* The caps can be transformed into any other caps with format info removed.
 342  * However, we should prefer passthrough, so if passthrough is possible,
 343  * put it first in the list. */
 344 static GstCaps *
 345 gst_audio_convert_transform_caps (GstBaseTransform * btrans,
 346     GstPadDirection direction, GstCaps * caps, GstCaps * filter)
 347 {
 348   GstCaps *tmp, *tmp2;
 349   GstCaps *result;
 350   GstAudioConvert *this = GST_AUDIO_CONVERT (btrans);
 351 
 352   tmp = gst_caps_copy (caps);
 353 
 354   gst_caps_map_in_place (tmp, remove_format_from_structure, NULL);

 355   gst_caps_map_in_place (tmp, remove_channels_from_structure, btrans);
 356 
 357   /* We can infer the required input / output channels based on the
 358    * matrix dimensions */
 359   if (gst_value_array_get_size (&amp;this-&gt;mix_matrix)) {
 360     gint other_channels;
 361 
 362     if (direction == GST_PAD_SRC) {
 363       const GValue *first_row =
 364           gst_value_array_get_value (&amp;this-&gt;mix_matrix, 0);
 365       other_channels = gst_value_array_get_size (first_row);
 366     } else {
 367       other_channels = gst_value_array_get_size (&amp;this-&gt;mix_matrix);
 368     }
 369 
 370     gst_caps_map_in_place (tmp, add_other_channels_to_structure,
 371         GINT_TO_POINTER (other_channels));
 372   }
 373 
 374   if (filter) {
</pre>
<hr />
<pre>
 672 /* try to keep as many of the structure members the same by fixating the
 673  * possible ranges; this way we convert the least amount of things as possible
 674  */
 675 static GstCaps *
 676 gst_audio_convert_fixate_caps (GstBaseTransform * base,
 677     GstPadDirection direction, GstCaps * caps, GstCaps * othercaps)
 678 {
 679   GstStructure *ins, *outs;
 680   GstCaps *result;
 681 
 682   GST_DEBUG_OBJECT (base, &quot;trying to fixate othercaps %&quot; GST_PTR_FORMAT
 683       &quot; based on caps %&quot; GST_PTR_FORMAT, othercaps, caps);
 684 
 685   result = gst_caps_intersect (othercaps, caps);
 686   if (gst_caps_is_empty (result)) {
 687     GstCaps *removed = gst_caps_copy (caps);
 688 
 689     if (result)
 690       gst_caps_unref (result);
 691     gst_caps_map_in_place (removed, remove_format_from_structure, NULL);

 692     result = gst_caps_intersect (othercaps, removed);
 693     gst_caps_unref (removed);
 694     if (gst_caps_is_empty (result)) {
 695       if (result)
 696         gst_caps_unref (result);
 697       result = othercaps;
 698     } else {
 699       gst_caps_unref (othercaps);
 700     }
 701   } else {
 702     gst_caps_unref (othercaps);
 703   }
 704 
 705   GST_DEBUG_OBJECT (base, &quot;now fixating %&quot; GST_PTR_FORMAT, result);
 706 
 707   /* fixate remaining fields */
 708   result = gst_caps_make_writable (result);
 709 
 710   ins = gst_caps_get_structure (caps, 0);
 711   outs = gst_caps_get_structure (result, 0);
</pre>
<hr />
<pre>
 745     goto invalid_out;
 746 
 747   config = gst_structure_new (&quot;GstAudioConverterConfig&quot;,
 748       GST_AUDIO_CONVERTER_OPT_DITHER_METHOD, GST_TYPE_AUDIO_DITHER_METHOD,
 749       this-&gt;dither,
 750       GST_AUDIO_CONVERTER_OPT_NOISE_SHAPING_METHOD,
 751       GST_TYPE_AUDIO_NOISE_SHAPING_METHOD, this-&gt;ns, NULL);
 752 
 753   if (this-&gt;mix_matrix_was_set)
 754     gst_structure_set_value (config, GST_AUDIO_CONVERTER_OPT_MIX_MATRIX,
 755         &amp;this-&gt;mix_matrix);
 756 
 757   this-&gt;convert = gst_audio_converter_new (0, &amp;in_info, &amp;out_info, config);
 758 
 759   if (this-&gt;convert == NULL)
 760     goto no_converter;
 761 
 762   in_place = gst_audio_converter_supports_inplace (this-&gt;convert);
 763   gst_base_transform_set_in_place (base, in_place);
 764 



 765   this-&gt;in_info = in_info;
 766   this-&gt;out_info = out_info;
 767 
 768   return TRUE;
 769 
 770   /* ERRORS */
 771 invalid_in:
 772   {
 773     GST_ERROR_OBJECT (base, &quot;invalid input caps&quot;);
 774     return FALSE;
 775   }
 776 invalid_out:
 777   {
 778     GST_ERROR_OBJECT (base, &quot;invalid output caps&quot;);
 779     return FALSE;
 780   }
 781 no_converter:
 782   {
 783     GST_ERROR_OBJECT (base, &quot;could not make converter&quot;);
 784     return FALSE;
 785   }
 786 }
 787 
 788 /* if called through gst_audio_convert_transform_ip() inbuf == outbuf */
 789 static GstFlowReturn
 790 gst_audio_convert_transform (GstBaseTransform * base, GstBuffer * inbuf,
 791     GstBuffer * outbuf)
 792 {
 793   GstFlowReturn ret;
 794   GstAudioConvert *this = GST_AUDIO_CONVERT (base);
<span class="line-modified"> 795   GstMapInfo srcmap = { NULL, }, dstmap;</span>
<span class="line-removed"> 796   gint insize, outsize;</span>
 797   gboolean inbuf_writable;
 798   GstAudioConverterFlags flags;
<span class="line-removed"> 799   gsize samples;</span>
<span class="line-removed"> 800 </span>
<span class="line-removed"> 801   /* get amount of samples to convert. */</span>
<span class="line-removed"> 802   samples = gst_buffer_get_size (inbuf) / this-&gt;in_info.bpf;</span>
<span class="line-removed"> 803 </span>
<span class="line-removed"> 804   /* get in/output sizes, to see if the buffers we got are of correct</span>
<span class="line-removed"> 805    * sizes */</span>
<span class="line-removed"> 806   insize = samples * this-&gt;in_info.bpf;</span>
<span class="line-removed"> 807   outsize = samples * this-&gt;out_info.bpf;</span>
 808 
<span class="line-modified"> 809   if (insize == 0 || outsize == 0)</span>

 810     return GST_FLOW_OK;
 811 
<span class="line-removed"> 812   gst_buffer_resize (outbuf, 0, outsize);</span>
<span class="line-removed"> 813 </span>
<span class="line-removed"> 814   /* get src and dst data */</span>
 815   if (inbuf != outbuf) {
<span class="line-modified"> 816   inbuf_writable = gst_buffer_is_writable (inbuf)</span>
<span class="line-modified"> 817       &amp;&amp; gst_buffer_n_memory (inbuf) == 1</span>
<span class="line-modified"> 818       &amp;&amp; gst_memory_is_writable (gst_buffer_peek_memory (inbuf, 0));</span>
 819 
<span class="line-modified"> 820     if (!gst_buffer_map (inbuf, &amp;srcmap,</span>
 821             inbuf_writable ? GST_MAP_READWRITE : GST_MAP_READ))
 822       goto inmap_error;
 823   } else {
 824     inbuf_writable = TRUE;
 825   }
<span class="line-removed"> 826   if (!gst_buffer_map (outbuf, &amp;dstmap, GST_MAP_WRITE))</span>
<span class="line-removed"> 827     goto outmap_error;</span>
 828 
<span class="line-modified"> 829   /* check in and outsize */</span>
<span class="line-modified"> 830   if (inbuf != outbuf) {</span>
<span class="line-removed"> 831   if (srcmap.size &lt; insize)</span>
<span class="line-removed"> 832     goto wrong_size;</span>
<span class="line-removed"> 833   }</span>
<span class="line-removed"> 834   if (dstmap.size &lt; outsize)</span>
<span class="line-removed"> 835     goto wrong_size;</span>
 836 
 837   /* and convert the samples */
 838   flags = 0;
 839   if (inbuf_writable)
 840     flags |= GST_AUDIO_CONVERTER_FLAG_IN_WRITABLE;
 841 
 842   if (!GST_BUFFER_FLAG_IS_SET (inbuf, GST_BUFFER_FLAG_GAP)) {
<span class="line-removed"> 843     gpointer in[1] = { srcmap.data };</span>
<span class="line-removed"> 844     gpointer out[1] = { dstmap.data };</span>
<span class="line-removed"> 845 </span>
 846     if (!gst_audio_converter_samples (this-&gt;convert, flags,
<span class="line-modified"> 847             inbuf != outbuf ? in : out, samples, out, samples))</span>

 848       goto convert_error;
 849   } else {
 850     /* Create silence buffer */
<span class="line-modified"> 851     gst_audio_format_fill_silence (this-&gt;out_info.finfo, dstmap.data, outsize);</span>




 852   }
 853   ret = GST_FLOW_OK;
 854 
 855 done:
<span class="line-modified"> 856   gst_buffer_unmap (outbuf, &amp;dstmap);</span>
 857   if (inbuf != outbuf)
<span class="line-modified"> 858   gst_buffer_unmap (inbuf, &amp;srcmap);</span>
 859 
 860   return ret;
 861 
 862   /* ERRORS */
<span class="line-removed"> 863 wrong_size:</span>
<span class="line-removed"> 864   {</span>
<span class="line-removed"> 865     GST_ELEMENT_ERROR (this, STREAM, FORMAT,</span>
<span class="line-removed"> 866         (NULL),</span>
<span class="line-removed"> 867         (&quot;input/output buffers are of wrong size in: %&quot; G_GSIZE_FORMAT &quot; &lt; %d&quot;</span>
<span class="line-removed"> 868             &quot; or out: %&quot; G_GSIZE_FORMAT &quot; &lt; %d&quot;,</span>
<span class="line-removed"> 869             srcmap.size, insize, dstmap.size, outsize));</span>
<span class="line-removed"> 870     ret = GST_FLOW_ERROR;</span>
<span class="line-removed"> 871     goto done;</span>
<span class="line-removed"> 872   }</span>
 873 convert_error:
 874   {
 875     GST_ELEMENT_ERROR (this, STREAM, FORMAT,
 876         (NULL), (&quot;error while converting&quot;));
 877     ret = GST_FLOW_ERROR;
 878     goto done;
 879   }
 880 inmap_error:
 881   {
 882     GST_ELEMENT_ERROR (this, STREAM, FORMAT,
 883         (NULL), (&quot;failed to map input buffer&quot;));
 884     return GST_FLOW_ERROR;
<span class="line-modified"> 885 }</span>
 886 outmap_error:
 887   {
 888     GST_ELEMENT_ERROR (this, STREAM, FORMAT,
 889         (NULL), (&quot;failed to map output buffer&quot;));
 890     if (inbuf != outbuf)
<span class="line-modified"> 891       gst_buffer_unmap (inbuf, &amp;srcmap);</span>
 892     return GST_FLOW_ERROR;
 893   }
 894 }
 895 
 896 static GstFlowReturn
 897 gst_audio_convert_transform_ip (GstBaseTransform * base, GstBuffer * buf)
 898 {
 899   return gst_audio_convert_transform (base, buf, buf);
 900 }
 901 
 902 static gboolean
 903 gst_audio_convert_transform_meta (GstBaseTransform * trans, GstBuffer * outbuf,
 904     GstMeta * meta, GstBuffer * inbuf)
 905 {
 906   const GstMetaInfo *info = meta-&gt;info;
 907   const gchar *const *tags;
 908 
 909   tags = gst_meta_api_type_get_tags (info-&gt;api);
 910 
 911   if (!tags || (g_strv_length ((gchar **) tags) == 1
</pre>
<hr />
<pre>
 918 
 919 static GstFlowReturn
 920 gst_audio_convert_submit_input_buffer (GstBaseTransform * base,
 921     gboolean is_discont, GstBuffer * input)
 922 {
 923   GstAudioConvert *this = GST_AUDIO_CONVERT (base);
 924 
 925   if (base-&gt;segment.format == GST_FORMAT_TIME) {
 926     input =
 927         gst_audio_buffer_clip (input, &amp;base-&gt;segment, this-&gt;in_info.rate,
 928         this-&gt;in_info.bpf);
 929 
 930     if (!input)
 931       return GST_FLOW_OK;
 932   }
 933 
 934   return GST_BASE_TRANSFORM_CLASS (parent_class)-&gt;submit_input_buffer (base,
 935       is_discont, input);
 936 }
 937 





































 938 static void
 939 gst_audio_convert_set_property (GObject * object, guint prop_id,
 940     const GValue * value, GParamSpec * pspec)
 941 {
 942   GstAudioConvert *this = GST_AUDIO_CONVERT (object);
 943 
 944   switch (prop_id) {
 945     case PROP_DITHERING:
 946       this-&gt;dither = g_value_get_enum (value);
 947       break;
 948     case PROP_NOISE_SHAPING:
 949       this-&gt;ns = g_value_get_enum (value);
 950       break;
 951     case PROP_MIX_MATRIX:
 952       if (!gst_value_array_get_size (value)) {
 953         g_value_copy (value, &amp;this-&gt;mix_matrix);
 954         this-&gt;mix_matrix_was_set = TRUE;
 955       } else {
 956         const GValue *first_row = gst_value_array_get_value (value, 0);
 957 
</pre>
</td>
<td>
<hr />
<pre>
 121 /* type functions */
 122 static void gst_audio_convert_dispose (GObject * obj);
 123 
 124 /* gstreamer functions */
 125 static gboolean gst_audio_convert_get_unit_size (GstBaseTransform * base,
 126     GstCaps * caps, gsize * size);
 127 static GstCaps *gst_audio_convert_transform_caps (GstBaseTransform * base,
 128     GstPadDirection direction, GstCaps * caps, GstCaps * filter);
 129 static GstCaps *gst_audio_convert_fixate_caps (GstBaseTransform * base,
 130     GstPadDirection direction, GstCaps * caps, GstCaps * othercaps);
 131 static gboolean gst_audio_convert_set_caps (GstBaseTransform * base,
 132     GstCaps * incaps, GstCaps * outcaps);
 133 static GstFlowReturn gst_audio_convert_transform (GstBaseTransform * base,
 134     GstBuffer * inbuf, GstBuffer * outbuf);
 135 static GstFlowReturn gst_audio_convert_transform_ip (GstBaseTransform * base,
 136     GstBuffer * buf);
 137 static gboolean gst_audio_convert_transform_meta (GstBaseTransform * trans,
 138     GstBuffer * outbuf, GstMeta * meta, GstBuffer * inbuf);
 139 static GstFlowReturn gst_audio_convert_submit_input_buffer (GstBaseTransform *
 140     base, gboolean is_discont, GstBuffer * input);
<span class="line-added"> 141 static GstFlowReturn gst_audio_convert_prepare_output_buffer (GstBaseTransform *</span>
<span class="line-added"> 142     base, GstBuffer * inbuf, GstBuffer ** outbuf);</span>
 143 static void gst_audio_convert_set_property (GObject * object, guint prop_id,
 144     const GValue * value, GParamSpec * pspec);
 145 static void gst_audio_convert_get_property (GObject * object, guint prop_id,
 146     GValue * value, GParamSpec * pspec);
 147 
 148 /* AudioConvert signals and args */
 149 enum
 150 {
 151   /* FILL ME */
 152   LAST_SIGNAL
 153 };
 154 
 155 enum
 156 {
 157   PROP_0,
 158   PROP_DITHERING,
 159   PROP_NOISE_SHAPING,
 160   PROP_MIX_MATRIX,
 161 };
 162 
 163 #define DEBUG_INIT \
 164   GST_DEBUG_CATEGORY_INIT (audio_convert_debug, &quot;audioconvert&quot;, 0, &quot;audio conversion element&quot;); \
 165   GST_DEBUG_CATEGORY_GET (GST_CAT_PERFORMANCE, &quot;GST_PERFORMANCE&quot;);
 166 #define gst_audio_convert_parent_class parent_class
 167 G_DEFINE_TYPE_WITH_CODE (GstAudioConvert, gst_audio_convert,
 168     GST_TYPE_BASE_TRANSFORM, DEBUG_INIT);
 169 
 170 /*** GSTREAMER PROTOTYPES *****************************************************/
 171 
 172 #define STATIC_CAPS \
 173 GST_STATIC_CAPS (GST_AUDIO_CAPS_MAKE (GST_AUDIO_FORMATS_ALL) \
<span class="line-modified"> 174     &quot;, layout = (string) { interleaved, non-interleaved }&quot;)</span>
 175 
 176 static GstStaticPadTemplate gst_audio_convert_src_template =
 177 GST_STATIC_PAD_TEMPLATE (&quot;src&quot;,
 178     GST_PAD_SRC,
 179     GST_PAD_ALWAYS,
 180     STATIC_CAPS);
 181 
 182 static GstStaticPadTemplate gst_audio_convert_sink_template =
 183 GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,
 184     GST_PAD_SINK,
 185     GST_PAD_ALWAYS,
 186     STATIC_CAPS);
 187 
 188 
 189 /*** TYPE FUNCTIONS ***********************************************************/
 190 static void
 191 gst_audio_convert_class_init (GstAudioConvertClass * klass)
 192 {
 193   GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
 194   GstElementClass *element_class = GST_ELEMENT_CLASS (klass);
</pre>
<hr />
<pre>
 228   gst_element_class_set_static_metadata (element_class, &quot;Audio converter&quot;,
 229       &quot;Filter/Converter/Audio&quot;, &quot;Convert audio to different formats&quot;,
 230       &quot;Benjamin Otte &lt;otte@gnome.org&gt;&quot;);
 231 
 232   basetransform_class-&gt;get_unit_size =
 233       GST_DEBUG_FUNCPTR (gst_audio_convert_get_unit_size);
 234   basetransform_class-&gt;transform_caps =
 235       GST_DEBUG_FUNCPTR (gst_audio_convert_transform_caps);
 236   basetransform_class-&gt;fixate_caps =
 237       GST_DEBUG_FUNCPTR (gst_audio_convert_fixate_caps);
 238   basetransform_class-&gt;set_caps =
 239       GST_DEBUG_FUNCPTR (gst_audio_convert_set_caps);
 240   basetransform_class-&gt;transform =
 241       GST_DEBUG_FUNCPTR (gst_audio_convert_transform);
 242   basetransform_class-&gt;transform_ip =
 243       GST_DEBUG_FUNCPTR (gst_audio_convert_transform_ip);
 244   basetransform_class-&gt;transform_meta =
 245       GST_DEBUG_FUNCPTR (gst_audio_convert_transform_meta);
 246   basetransform_class-&gt;submit_input_buffer =
 247       GST_DEBUG_FUNCPTR (gst_audio_convert_submit_input_buffer);
<span class="line-added"> 248   basetransform_class-&gt;prepare_output_buffer =</span>
<span class="line-added"> 249       GST_DEBUG_FUNCPTR (gst_audio_convert_prepare_output_buffer);</span>
 250 

 251   basetransform_class-&gt;transform_ip_on_passthrough = FALSE;
 252 }
 253 
 254 static void
 255 gst_audio_convert_init (GstAudioConvert * this)
 256 {
 257   this-&gt;dither = GST_AUDIO_DITHER_TPDF;
 258   this-&gt;ns = GST_AUDIO_NOISE_SHAPING_NONE;
 259   g_value_init (&amp;this-&gt;mix_matrix, GST_TYPE_ARRAY);
 260 
 261   gst_base_transform_set_gap_aware (GST_BASE_TRANSFORM (this), TRUE);
 262 }
 263 
 264 static void
 265 gst_audio_convert_dispose (GObject * obj)
 266 {
 267   GstAudioConvert *this = GST_AUDIO_CONVERT (obj);
 268 
 269   if (this-&gt;convert) {
 270     gst_audio_converter_free (this-&gt;convert);
</pre>
<hr />
<pre>
 293   *size = info.bpf;
 294   GST_INFO_OBJECT (base, &quot;unit_size = %&quot; G_GSIZE_FORMAT, *size);
 295 
 296   return TRUE;
 297 
 298 parse_error:
 299   {
 300     GST_INFO_OBJECT (base, &quot;failed to parse caps to get unit_size&quot;);
 301     return FALSE;
 302   }
 303 }
 304 
 305 static gboolean
 306 remove_format_from_structure (GstCapsFeatures * features,
 307     GstStructure * structure, gpointer user_data G_GNUC_UNUSED)
 308 {
 309   gst_structure_remove_field (structure, &quot;format&quot;);
 310   return TRUE;
 311 }
 312 
<span class="line-added"> 313 static gboolean</span>
<span class="line-added"> 314 remove_layout_from_structure (GstCapsFeatures * features,</span>
<span class="line-added"> 315     GstStructure * structure, gpointer user_data G_GNUC_UNUSED)</span>
<span class="line-added"> 316 {</span>
<span class="line-added"> 317   gst_structure_remove_field (structure, &quot;layout&quot;);</span>
<span class="line-added"> 318   return TRUE;</span>
<span class="line-added"> 319 }</span>
<span class="line-added"> 320 </span>
 321 static gboolean
 322 remove_channels_from_structure (GstCapsFeatures * features, GstStructure * s,
 323     gpointer user_data)
 324 {
 325   guint64 mask;
 326   gint channels;
 327   GstAudioConvert *this = GST_AUDIO_CONVERT (user_data);
 328 
 329   /* Only remove the channels and channel-mask for non-NONE layouts,
 330    * or if a mix matrix was manually specified */
 331   if (this-&gt;mix_matrix_was_set ||
 332       !gst_structure_get (s, &quot;channel-mask&quot;, GST_TYPE_BITMASK, &amp;mask, NULL) ||
 333       (mask != 0 || (gst_structure_get_int (s, &quot;channels&quot;, &amp;channels)
 334               &amp;&amp; channels == 1))) {
 335     gst_structure_remove_fields (s, &quot;channel-mask&quot;, &quot;channels&quot;, NULL);
 336   }
 337 
 338   return TRUE;
<span class="line-modified"> 339 }</span>
 340 
 341 static gboolean
 342 add_other_channels_to_structure (GstCapsFeatures * features, GstStructure * s,
 343     gpointer user_data)
 344 {
 345   gint other_channels = GPOINTER_TO_INT (user_data);
 346 
 347   gst_structure_set (s, &quot;channels&quot;, G_TYPE_INT, other_channels, NULL);
 348 
 349   return TRUE;
 350 }
 351 
 352 /* The caps can be transformed into any other caps with format info removed.
 353  * However, we should prefer passthrough, so if passthrough is possible,
 354  * put it first in the list. */
 355 static GstCaps *
 356 gst_audio_convert_transform_caps (GstBaseTransform * btrans,
 357     GstPadDirection direction, GstCaps * caps, GstCaps * filter)
 358 {
 359   GstCaps *tmp, *tmp2;
 360   GstCaps *result;
 361   GstAudioConvert *this = GST_AUDIO_CONVERT (btrans);
 362 
 363   tmp = gst_caps_copy (caps);
 364 
 365   gst_caps_map_in_place (tmp, remove_format_from_structure, NULL);
<span class="line-added"> 366   gst_caps_map_in_place (tmp, remove_layout_from_structure, NULL);</span>
 367   gst_caps_map_in_place (tmp, remove_channels_from_structure, btrans);
 368 
 369   /* We can infer the required input / output channels based on the
 370    * matrix dimensions */
 371   if (gst_value_array_get_size (&amp;this-&gt;mix_matrix)) {
 372     gint other_channels;
 373 
 374     if (direction == GST_PAD_SRC) {
 375       const GValue *first_row =
 376           gst_value_array_get_value (&amp;this-&gt;mix_matrix, 0);
 377       other_channels = gst_value_array_get_size (first_row);
 378     } else {
 379       other_channels = gst_value_array_get_size (&amp;this-&gt;mix_matrix);
 380     }
 381 
 382     gst_caps_map_in_place (tmp, add_other_channels_to_structure,
 383         GINT_TO_POINTER (other_channels));
 384   }
 385 
 386   if (filter) {
</pre>
<hr />
<pre>
 684 /* try to keep as many of the structure members the same by fixating the
 685  * possible ranges; this way we convert the least amount of things as possible
 686  */
 687 static GstCaps *
 688 gst_audio_convert_fixate_caps (GstBaseTransform * base,
 689     GstPadDirection direction, GstCaps * caps, GstCaps * othercaps)
 690 {
 691   GstStructure *ins, *outs;
 692   GstCaps *result;
 693 
 694   GST_DEBUG_OBJECT (base, &quot;trying to fixate othercaps %&quot; GST_PTR_FORMAT
 695       &quot; based on caps %&quot; GST_PTR_FORMAT, othercaps, caps);
 696 
 697   result = gst_caps_intersect (othercaps, caps);
 698   if (gst_caps_is_empty (result)) {
 699     GstCaps *removed = gst_caps_copy (caps);
 700 
 701     if (result)
 702       gst_caps_unref (result);
 703     gst_caps_map_in_place (removed, remove_format_from_structure, NULL);
<span class="line-added"> 704     gst_caps_map_in_place (removed, remove_layout_from_structure, NULL);</span>
 705     result = gst_caps_intersect (othercaps, removed);
 706     gst_caps_unref (removed);
 707     if (gst_caps_is_empty (result)) {
 708       if (result)
 709         gst_caps_unref (result);
 710       result = othercaps;
 711     } else {
 712       gst_caps_unref (othercaps);
 713     }
 714   } else {
 715     gst_caps_unref (othercaps);
 716   }
 717 
 718   GST_DEBUG_OBJECT (base, &quot;now fixating %&quot; GST_PTR_FORMAT, result);
 719 
 720   /* fixate remaining fields */
 721   result = gst_caps_make_writable (result);
 722 
 723   ins = gst_caps_get_structure (caps, 0);
 724   outs = gst_caps_get_structure (result, 0);
</pre>
<hr />
<pre>
 758     goto invalid_out;
 759 
 760   config = gst_structure_new (&quot;GstAudioConverterConfig&quot;,
 761       GST_AUDIO_CONVERTER_OPT_DITHER_METHOD, GST_TYPE_AUDIO_DITHER_METHOD,
 762       this-&gt;dither,
 763       GST_AUDIO_CONVERTER_OPT_NOISE_SHAPING_METHOD,
 764       GST_TYPE_AUDIO_NOISE_SHAPING_METHOD, this-&gt;ns, NULL);
 765 
 766   if (this-&gt;mix_matrix_was_set)
 767     gst_structure_set_value (config, GST_AUDIO_CONVERTER_OPT_MIX_MATRIX,
 768         &amp;this-&gt;mix_matrix);
 769 
 770   this-&gt;convert = gst_audio_converter_new (0, &amp;in_info, &amp;out_info, config);
 771 
 772   if (this-&gt;convert == NULL)
 773     goto no_converter;
 774 
 775   in_place = gst_audio_converter_supports_inplace (this-&gt;convert);
 776   gst_base_transform_set_in_place (base, in_place);
 777 
<span class="line-added"> 778   gst_base_transform_set_passthrough (base,</span>
<span class="line-added"> 779       gst_audio_converter_is_passthrough (this-&gt;convert));</span>
<span class="line-added"> 780 </span>
 781   this-&gt;in_info = in_info;
 782   this-&gt;out_info = out_info;
 783 
 784   return TRUE;
 785 
 786   /* ERRORS */
 787 invalid_in:
 788   {
 789     GST_ERROR_OBJECT (base, &quot;invalid input caps&quot;);
 790     return FALSE;
 791   }
 792 invalid_out:
 793   {
 794     GST_ERROR_OBJECT (base, &quot;invalid output caps&quot;);
 795     return FALSE;
 796   }
 797 no_converter:
 798   {
 799     GST_ERROR_OBJECT (base, &quot;could not make converter&quot;);
 800     return FALSE;
 801   }
 802 }
 803 
 804 /* if called through gst_audio_convert_transform_ip() inbuf == outbuf */
 805 static GstFlowReturn
 806 gst_audio_convert_transform (GstBaseTransform * base, GstBuffer * inbuf,
 807     GstBuffer * outbuf)
 808 {
 809   GstFlowReturn ret;
 810   GstAudioConvert *this = GST_AUDIO_CONVERT (base);
<span class="line-modified"> 811   GstAudioBuffer srcabuf, dstabuf;</span>

 812   gboolean inbuf_writable;
 813   GstAudioConverterFlags flags;









 814 
<span class="line-modified"> 815   /* https://bugzilla.gnome.org/show_bug.cgi?id=396835 */</span>
<span class="line-added"> 816   if (gst_buffer_get_size (inbuf) == 0)</span>
 817     return GST_FLOW_OK;
 818 



 819   if (inbuf != outbuf) {
<span class="line-modified"> 820     inbuf_writable = gst_buffer_is_writable (inbuf)</span>
<span class="line-modified"> 821         &amp;&amp; gst_buffer_n_memory (inbuf) == 1</span>
<span class="line-modified"> 822         &amp;&amp; gst_memory_is_writable (gst_buffer_peek_memory (inbuf, 0));</span>
 823 
<span class="line-modified"> 824     if (!gst_audio_buffer_map (&amp;srcabuf, &amp;this-&gt;in_info, inbuf,</span>
 825             inbuf_writable ? GST_MAP_READWRITE : GST_MAP_READ))
 826       goto inmap_error;
 827   } else {
 828     inbuf_writable = TRUE;
 829   }


 830 
<span class="line-modified"> 831   if (!gst_audio_buffer_map (&amp;dstabuf, &amp;this-&gt;out_info, outbuf, GST_MAP_WRITE))</span>
<span class="line-modified"> 832     goto outmap_error;</span>





 833 
 834   /* and convert the samples */
 835   flags = 0;
 836   if (inbuf_writable)
 837     flags |= GST_AUDIO_CONVERTER_FLAG_IN_WRITABLE;
 838 
 839   if (!GST_BUFFER_FLAG_IS_SET (inbuf, GST_BUFFER_FLAG_GAP)) {



 840     if (!gst_audio_converter_samples (this-&gt;convert, flags,
<span class="line-modified"> 841             inbuf != outbuf ? srcabuf.planes : dstabuf.planes,</span>
<span class="line-added"> 842             dstabuf.n_samples, dstabuf.planes, dstabuf.n_samples))</span>
 843       goto convert_error;
 844   } else {
 845     /* Create silence buffer */
<span class="line-modified"> 846     gint i;</span>
<span class="line-added"> 847     for (i = 0; i &lt; dstabuf.n_planes; i++) {</span>
<span class="line-added"> 848       gst_audio_format_fill_silence (this-&gt;out_info.finfo, dstabuf.planes[i],</span>
<span class="line-added"> 849           GST_AUDIO_BUFFER_PLANE_SIZE (&amp;dstabuf));</span>
<span class="line-added"> 850     }</span>
 851   }
 852   ret = GST_FLOW_OK;
 853 
 854 done:
<span class="line-modified"> 855   gst_audio_buffer_unmap (&amp;dstabuf);</span>
 856   if (inbuf != outbuf)
<span class="line-modified"> 857     gst_audio_buffer_unmap (&amp;srcabuf);</span>
 858 
 859   return ret;
 860 
 861   /* ERRORS */










 862 convert_error:
 863   {
 864     GST_ELEMENT_ERROR (this, STREAM, FORMAT,
 865         (NULL), (&quot;error while converting&quot;));
 866     ret = GST_FLOW_ERROR;
 867     goto done;
 868   }
 869 inmap_error:
 870   {
 871     GST_ELEMENT_ERROR (this, STREAM, FORMAT,
 872         (NULL), (&quot;failed to map input buffer&quot;));
 873     return GST_FLOW_ERROR;
<span class="line-modified"> 874   }</span>
 875 outmap_error:
 876   {
 877     GST_ELEMENT_ERROR (this, STREAM, FORMAT,
 878         (NULL), (&quot;failed to map output buffer&quot;));
 879     if (inbuf != outbuf)
<span class="line-modified"> 880       gst_audio_buffer_unmap (&amp;srcabuf);</span>
 881     return GST_FLOW_ERROR;
 882   }
 883 }
 884 
 885 static GstFlowReturn
 886 gst_audio_convert_transform_ip (GstBaseTransform * base, GstBuffer * buf)
 887 {
 888   return gst_audio_convert_transform (base, buf, buf);
 889 }
 890 
 891 static gboolean
 892 gst_audio_convert_transform_meta (GstBaseTransform * trans, GstBuffer * outbuf,
 893     GstMeta * meta, GstBuffer * inbuf)
 894 {
 895   const GstMetaInfo *info = meta-&gt;info;
 896   const gchar *const *tags;
 897 
 898   tags = gst_meta_api_type_get_tags (info-&gt;api);
 899 
 900   if (!tags || (g_strv_length ((gchar **) tags) == 1
</pre>
<hr />
<pre>
 907 
 908 static GstFlowReturn
 909 gst_audio_convert_submit_input_buffer (GstBaseTransform * base,
 910     gboolean is_discont, GstBuffer * input)
 911 {
 912   GstAudioConvert *this = GST_AUDIO_CONVERT (base);
 913 
 914   if (base-&gt;segment.format == GST_FORMAT_TIME) {
 915     input =
 916         gst_audio_buffer_clip (input, &amp;base-&gt;segment, this-&gt;in_info.rate,
 917         this-&gt;in_info.bpf);
 918 
 919     if (!input)
 920       return GST_FLOW_OK;
 921   }
 922 
 923   return GST_BASE_TRANSFORM_CLASS (parent_class)-&gt;submit_input_buffer (base,
 924       is_discont, input);
 925 }
 926 
<span class="line-added"> 927 static GstFlowReturn</span>
<span class="line-added"> 928 gst_audio_convert_prepare_output_buffer (GstBaseTransform * base,</span>
<span class="line-added"> 929     GstBuffer * inbuf, GstBuffer ** outbuf)</span>
<span class="line-added"> 930 {</span>
<span class="line-added"> 931   GstAudioConvert *this = GST_AUDIO_CONVERT (base);</span>
<span class="line-added"> 932   GstAudioMeta *meta;</span>
<span class="line-added"> 933   GstFlowReturn ret;</span>
<span class="line-added"> 934 </span>
<span class="line-added"> 935   ret = GST_BASE_TRANSFORM_CLASS (parent_class)-&gt;prepare_output_buffer (base,</span>
<span class="line-added"> 936       inbuf, outbuf);</span>
<span class="line-added"> 937 </span>
<span class="line-added"> 938   if (ret != GST_FLOW_OK)</span>
<span class="line-added"> 939     return ret;</span>
<span class="line-added"> 940 </span>
<span class="line-added"> 941   meta = gst_buffer_get_audio_meta (inbuf);</span>
<span class="line-added"> 942 </span>
<span class="line-added"> 943   if (inbuf != *outbuf) {</span>
<span class="line-added"> 944     gsize samples = meta ?</span>
<span class="line-added"> 945         meta-&gt;samples : (gst_buffer_get_size (inbuf) / this-&gt;in_info.bpf);</span>
<span class="line-added"> 946 </span>
<span class="line-added"> 947     /* ensure that the output buffer is not bigger than what we need */</span>
<span class="line-added"> 948     gst_buffer_resize (*outbuf, 0, samples * this-&gt;out_info.bpf);</span>
<span class="line-added"> 949 </span>
<span class="line-added"> 950     /* add the audio meta on the output buffer if it&#39;s planar */</span>
<span class="line-added"> 951     if (this-&gt;out_info.layout == GST_AUDIO_LAYOUT_NON_INTERLEAVED) {</span>
<span class="line-added"> 952       gst_buffer_add_audio_meta (*outbuf, &amp;this-&gt;out_info, samples, NULL);</span>
<span class="line-added"> 953     }</span>
<span class="line-added"> 954   } else {</span>
<span class="line-added"> 955     /* if the input buffer came with a GstAudioMeta,</span>
<span class="line-added"> 956      * update it to reflect the properties of the output format */</span>
<span class="line-added"> 957     if (meta)</span>
<span class="line-added"> 958       meta-&gt;info = this-&gt;out_info;</span>
<span class="line-added"> 959   }</span>
<span class="line-added"> 960 </span>
<span class="line-added"> 961   return ret;</span>
<span class="line-added"> 962 }</span>
<span class="line-added"> 963 </span>
 964 static void
 965 gst_audio_convert_set_property (GObject * object, guint prop_id,
 966     const GValue * value, GParamSpec * pspec)
 967 {
 968   GstAudioConvert *this = GST_AUDIO_CONVERT (object);
 969 
 970   switch (prop_id) {
 971     case PROP_DITHERING:
 972       this-&gt;dither = g_value_get_enum (value);
 973       break;
 974     case PROP_NOISE_SHAPING:
 975       this-&gt;ns = g_value_get_enum (value);
 976       break;
 977     case PROP_MIX_MATRIX:
 978       if (!gst_value_array_get_size (value)) {
 979         g_value_copy (value, &amp;this-&gt;mix_matrix);
 980         this-&gt;mix_matrix_was_set = TRUE;
 981       } else {
 982         const GValue *first_row = gst_value_array_get_value (value, 0);
 983 
</pre>
</td>
</tr>
</table>
<center><a href="../../gst-libs/gst/video/videooverlay.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../typefind/gsttypefindfunctions.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>