<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/plugins/elements/gsttypefindelement.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 2003 Benjamin Otte &lt;in7y118@public.uni-hamburg.de&gt;
   3  *
   4  * gsttypefindelement.c: element that detects type of stream
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 /**
  22  * SECTION:element-typefind
  23  * @title: typefind
  24  *
  25  * Determines the media-type of a stream. It applies typefind functions in the
  26  * order of their rank. Once the type has been detected it sets its src pad caps
  27  * to the found media type.
  28  *
  29  * Whenever a type is found the #GstTypeFindElement::have-type signal is
  30  * emitted, either from the streaming thread or the application thread
  31  * (the latter may happen when typefinding is done pull-based from the
  32  * state change function).
  33  *
  34  * Plugins can register custom typefinders by using #GstTypeFindFactory.
  35  */
  36 
  37 /* FIXME: need a better solution for non-seekable streams */
  38 
  39 /* way of operation:
  40  * 1) get a list of all typefind functions sorted best to worst
  41  * 2) if all elements have been called with all requested data goto 8
  42  * 3) call all functions once with all available data
  43  * 4) if a function returns a value &gt;= PROP_MAXIMUM goto 8 (never implemented))
  44  * 5) all functions with a result &gt; PROP_MINIMUM or functions that did not get
  45  *    all requested data (where peek returned NULL) stay in list
  46  * 6) seek to requested offset of best function that still has open data
  47  *    requests
  48  * 7) goto 2
  49  * 8) take best available result and use its caps
  50  *
  51  * The element has two scheduling modes:
  52  *
  53  * 1) chain based, it will collect buffers and run the typefind function on
  54  *    the buffer until something is found.
  55  * 2) getrange based, it will proxy the getrange function to the sinkpad. It
  56  *    is assumed that the peer element is happy with whatever format we
  57  *    eventually read.
  58  *
  59  * By default it tries to do pull based typefinding (this avoids joining
  60  * received buffers and holding them back in store.)
  61  *
  62  * When the element has no connected srcpad, and the sinkpad can operate in
  63  * getrange based mode, the element starts its own task to figure out the
  64  * type of the stream.
  65  *
  66  * Most of the actual implementation is in libs/gst/base/gsttypefindhelper.c.
  67  */
  68 
  69 #ifdef HAVE_CONFIG_H
  70 #  include &quot;config.h&quot;
  71 #endif
  72 
  73 #include &quot;gst/gst_private.h&quot;
  74 
  75 #include &quot;gsttypefindelement.h&quot;
  76 #include &quot;gst/gst-i18n-lib.h&quot;
  77 #include &quot;gst/base/gsttypefindhelper.h&quot;
  78 
  79 #include &lt;gst/gsttypefind.h&gt;
  80 #include &lt;gst/gstutils.h&gt;
  81 #include &lt;gst/gsterror.h&gt;
  82 
  83 GST_DEBUG_CATEGORY_STATIC (gst_type_find_element_debug);
  84 #define GST_CAT_DEFAULT gst_type_find_element_debug
  85 
  86 /* generic templates */
  87 static GstStaticPadTemplate type_find_element_sink_template =
  88 GST_STATIC_PAD_TEMPLATE (&quot;sink&quot;,
  89     GST_PAD_SINK,
  90     GST_PAD_ALWAYS,
  91     GST_STATIC_CAPS_ANY);
  92 
  93 static GstStaticPadTemplate type_find_element_src_template =
  94 GST_STATIC_PAD_TEMPLATE (&quot;src&quot;,
  95     GST_PAD_SRC,
  96     GST_PAD_ALWAYS,
  97     GST_STATIC_CAPS_ANY);
  98 
  99 /* Require at least 2kB of data before we attempt typefinding in chain-mode.
 100  * 128kB is massive overkill for the maximum, but doesn&#39;t do any harm */
 101 #define TYPE_FIND_MIN_SIZE   (2*1024)
 102 #define TYPE_FIND_MAX_SIZE (128*1024)
 103 
 104 /* TypeFind signals and args */
 105 enum
 106 {
 107   HAVE_TYPE,
 108   LAST_SIGNAL
 109 };
 110 enum
 111 {
 112   PROP_0,
 113   PROP_CAPS,
 114   PROP_MINIMUM,
 115   PROP_FORCE_CAPS,
 116   PROP_LAST
 117 };
 118 enum
 119 {
 120   MODE_NORMAL,                  /* act as identity */
 121   MODE_TYPEFIND,                /* do typefinding  */
 122   MODE_ERROR                    /* had fatal error */
 123 };
 124 
 125 
 126 #define _do_init \
 127     GST_DEBUG_CATEGORY_INIT (gst_type_find_element_debug, &quot;typefind&quot;,           \
 128         GST_DEBUG_BG_YELLOW | GST_DEBUG_FG_GREEN, &quot;type finding element&quot;);
 129 #define gst_type_find_element_parent_class parent_class
 130 G_DEFINE_TYPE_WITH_CODE (GstTypeFindElement, gst_type_find_element,
 131     GST_TYPE_ELEMENT, _do_init);
 132 
 133 static void gst_type_find_element_dispose (GObject * object);
 134 static void gst_type_find_element_set_property (GObject * object,
 135     guint prop_id, const GValue * value, GParamSpec * pspec);
 136 static void gst_type_find_element_get_property (GObject * object,
 137     guint prop_id, GValue * value, GParamSpec * pspec);
 138 
 139 static gboolean gst_type_find_element_src_event (GstPad * pad,
 140     GstObject * parent, GstEvent * event);
 141 static gboolean gst_type_find_handle_src_query (GstPad * pad,
 142     GstObject * parent, GstQuery * query);
 143 
 144 static gboolean gst_type_find_element_sink_event (GstPad * pad,
 145     GstObject * parent, GstEvent * event);
 146 static gboolean gst_type_find_element_setcaps (GstTypeFindElement * typefind,
 147     GstCaps * caps);
 148 static GstFlowReturn gst_type_find_element_chain (GstPad * sinkpad,
 149     GstObject * parent, GstBuffer * buffer);
 150 static GstFlowReturn gst_type_find_element_getrange (GstPad * srcpad,
 151     GstObject * parent, guint64 offset, guint length, GstBuffer ** buffer);
 152 
 153 static GstStateChangeReturn
 154 gst_type_find_element_change_state (GstElement * element,
 155     GstStateChange transition);
 156 static gboolean gst_type_find_element_activate_sink (GstPad * pad,
 157     GstObject * parent);
 158 static gboolean gst_type_find_element_activate_sink_mode (GstPad * pad,
 159     GstObject * parent, GstPadMode mode, gboolean active);
 160 static gboolean gst_type_find_element_activate_src_mode (GstPad * pad,
 161     GstObject * parent, GstPadMode mode, gboolean active);
 162 static GstFlowReturn
 163 gst_type_find_element_chain_do_typefinding (GstTypeFindElement * typefind,
 164     gboolean check_avail, gboolean at_eos);
 165 static void gst_type_find_element_send_cached_events (GstTypeFindElement *
 166     typefind);
 167 
 168 static void gst_type_find_element_loop (GstPad * pad);
 169 
 170 static guint gst_type_find_element_signals[LAST_SIGNAL] = { 0 };
 171 
 172 static void
 173 gst_type_find_element_have_type (GstTypeFindElement * typefind,
 174     guint probability, GstCaps * caps)
 175 {
 176   GstEvent *event;
 177 
 178   g_assert (caps != NULL);
 179 
 180   GST_INFO_OBJECT (typefind, &quot;found caps %&quot; GST_PTR_FORMAT &quot;, probability=%u&quot;,
 181       caps, probability);
 182 
 183   /* Do nothing if downstream is pulling from us */
 184   if (GST_PAD_MODE (typefind-&gt;src) == GST_PAD_MODE_PULL)
 185     return;
 186 
 187   GST_OBJECT_LOCK (typefind);
 188 
 189   /* Now actually send the CAPS event downstream.
 190    *
 191    * Try to directly send the CAPS event downstream that we created in
 192    * gst_type_find_element_emit_have_type() if it is still there, instead
 193    * of creating a new one. No need to create an equivalent one, replacing
 194    * it in the sticky event list and possibly causing renegotiation
 195    */
 196   event = gst_pad_get_sticky_event (typefind-&gt;src, GST_EVENT_CAPS, 0);
 197   if (event) {
 198     GstCaps *event_caps;
 199 
 200     gst_event_parse_caps (event, &amp;event_caps);
 201     if (caps != event_caps) {
 202       gst_event_unref (event);
 203       event = gst_event_new_caps (caps);
 204     }
 205   } else {
 206     event = gst_event_new_caps (caps);
 207   }
 208 
 209   GST_OBJECT_UNLOCK (typefind);
 210 
 211   gst_pad_push_event (typefind-&gt;src, event);
 212 }
 213 
 214 static void
 215 gst_type_find_element_emit_have_type (GstTypeFindElement * typefind,
 216     guint probability, GstCaps * caps)
 217 {
 218   GstEvent *event;
 219 
<a name="1" id="anc1"></a><span class="line-modified"> 220   /* Update caps field immediately so that caps queries and properties can be</span>
 221    * honored in all &quot;have-type&quot; signal handlers.
 222    */
 223   GST_OBJECT_LOCK (typefind);
<a name="2" id="anc2"></a><span class="line-modified"> 224   gst_caps_replace (&amp;typefind-&gt;caps, caps);</span>


 225   GST_OBJECT_UNLOCK (typefind);
 226 
 227   /* Only store the caps event at this point. We give signal handlers
 228    * the chance to look at the caps before they are sent downstream.
 229    * They are only forwarded downstream later in the default signal
 230    * handler after all application signal handlers
 231    */
 232   event = gst_event_new_caps (caps);
 233   gst_pad_store_sticky_event (typefind-&gt;src, event);
 234   gst_event_unref (event);
 235 
 236   g_signal_emit (typefind, gst_type_find_element_signals[HAVE_TYPE], 0,
 237       probability, caps);
 238 }
 239 
 240 static void
 241 gst_type_find_element_class_init (GstTypeFindElementClass * typefind_class)
 242 {
 243   GObjectClass *gobject_class = G_OBJECT_CLASS (typefind_class);
 244   GstElementClass *gstelement_class = GST_ELEMENT_CLASS (typefind_class);
 245 
 246   gobject_class-&gt;set_property = gst_type_find_element_set_property;
 247   gobject_class-&gt;get_property = gst_type_find_element_get_property;
 248   gobject_class-&gt;dispose = gst_type_find_element_dispose;
 249 
 250   g_object_class_install_property (gobject_class, PROP_CAPS,
 251       g_param_spec_boxed (&quot;caps&quot;, _(&quot;caps&quot;),
 252           _(&quot;detected capabilities in stream&quot;), GST_TYPE_CAPS,
 253           G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 254   g_object_class_install_property (gobject_class, PROP_MINIMUM,
 255       g_param_spec_uint (&quot;minimum&quot;, _(&quot;minimum&quot;),
 256           &quot;minimum probability required to accept caps&quot;, GST_TYPE_FIND_MINIMUM,
 257           GST_TYPE_FIND_MAXIMUM, GST_TYPE_FIND_MINIMUM,
 258           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 259   g_object_class_install_property (gobject_class, PROP_FORCE_CAPS,
 260       g_param_spec_boxed (&quot;force-caps&quot;, _(&quot;force caps&quot;),
 261           _(&quot;force caps without doing a typefind&quot;), GST_TYPE_CAPS,
 262           G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 263   /**
 264    * GstTypeFindElement::have-type:
 265    * @typefind: the typefind instance
 266    * @probability: the probability of the type found
 267    * @caps: the caps of the type found
 268    *
 269    * This signal gets emitted when the type and its probability has
 270    * been found.
 271    */
 272   gst_type_find_element_signals[HAVE_TYPE] = g_signal_new (&quot;have-type&quot;,
 273       G_TYPE_FROM_CLASS (typefind_class), G_SIGNAL_RUN_LAST,
 274       G_STRUCT_OFFSET (GstTypeFindElementClass, have_type), NULL, NULL,
 275       g_cclosure_marshal_generic, G_TYPE_NONE, 2,
 276       G_TYPE_UINT, GST_TYPE_CAPS | G_SIGNAL_TYPE_STATIC_SCOPE);
 277 
 278   typefind_class-&gt;have_type =
 279       GST_DEBUG_FUNCPTR (gst_type_find_element_have_type);
 280 
 281   gst_element_class_set_static_metadata (gstelement_class,
 282       &quot;TypeFind&quot;,
 283       &quot;Generic&quot;,
 284       &quot;Finds the media type of a stream&quot;,
 285       &quot;Benjamin Otte &lt;in7y118@public.uni-hamburg.de&gt;&quot;);
 286   gst_element_class_add_static_pad_template (gstelement_class,
 287       &amp;type_find_element_src_template);
 288   gst_element_class_add_static_pad_template (gstelement_class,
 289       &amp;type_find_element_sink_template);
 290 
 291   gstelement_class-&gt;change_state =
 292       GST_DEBUG_FUNCPTR (gst_type_find_element_change_state);
 293 }
 294 
 295 static void
 296 gst_type_find_element_init (GstTypeFindElement * typefind)
 297 {
 298   /* sinkpad */
 299   typefind-&gt;sink =
 300       gst_pad_new_from_static_template (&amp;type_find_element_sink_template,
 301       &quot;sink&quot;);
 302 
 303   gst_pad_set_activate_function (typefind-&gt;sink,
 304       GST_DEBUG_FUNCPTR (gst_type_find_element_activate_sink));
 305   gst_pad_set_activatemode_function (typefind-&gt;sink,
 306       GST_DEBUG_FUNCPTR (gst_type_find_element_activate_sink_mode));
 307   gst_pad_set_chain_function (typefind-&gt;sink,
 308       GST_DEBUG_FUNCPTR (gst_type_find_element_chain));
 309   gst_pad_set_event_function (typefind-&gt;sink,
 310       GST_DEBUG_FUNCPTR (gst_type_find_element_sink_event));
 311   GST_PAD_SET_PROXY_ALLOCATION (typefind-&gt;sink);
 312   gst_element_add_pad (GST_ELEMENT (typefind), typefind-&gt;sink);
 313 
 314   /* srcpad */
 315   typefind-&gt;src =
 316       gst_pad_new_from_static_template (&amp;type_find_element_src_template, &quot;src&quot;);
 317 
 318   gst_pad_set_activatemode_function (typefind-&gt;src,
 319       GST_DEBUG_FUNCPTR (gst_type_find_element_activate_src_mode));
 320   gst_pad_set_getrange_function (typefind-&gt;src,
 321       GST_DEBUG_FUNCPTR (gst_type_find_element_getrange));
 322   gst_pad_set_event_function (typefind-&gt;src,
 323       GST_DEBUG_FUNCPTR (gst_type_find_element_src_event));
 324   gst_pad_set_query_function (typefind-&gt;src,
 325       GST_DEBUG_FUNCPTR (gst_type_find_handle_src_query));
 326   gst_pad_use_fixed_caps (typefind-&gt;src);
 327   gst_element_add_pad (GST_ELEMENT (typefind), typefind-&gt;src);
 328 
 329   typefind-&gt;mode = MODE_TYPEFIND;
 330   typefind-&gt;caps = NULL;
 331   typefind-&gt;min_probability = 1;
 332 
 333   typefind-&gt;adapter = gst_adapter_new ();
 334 }
 335 
 336 static void
 337 gst_type_find_element_dispose (GObject * object)
 338 {
 339   GstTypeFindElement *typefind = GST_TYPE_FIND_ELEMENT (object);
 340 
<a name="3" id="anc3"></a><span class="line-modified"> 341   gst_clear_object (&amp;typefind-&gt;adapter);</span>
<span class="line-modified"> 342   gst_clear_caps (&amp;typefind-&gt;force_caps);</span>







 343 
 344   G_OBJECT_CLASS (parent_class)-&gt;dispose (object);
 345 }
 346 
 347 static void
 348 gst_type_find_element_set_property (GObject * object, guint prop_id,
 349     const GValue * value, GParamSpec * pspec)
 350 {
 351   GstTypeFindElement *typefind;
 352 
 353   typefind = GST_TYPE_FIND_ELEMENT (object);
 354 
 355   switch (prop_id) {
 356     case PROP_MINIMUM:
 357       typefind-&gt;min_probability = g_value_get_uint (value);
 358       break;
 359     case PROP_FORCE_CAPS:
 360       GST_OBJECT_LOCK (typefind);
<a name="4" id="anc4"></a><span class="line-modified"> 361       gst_caps_take (&amp;typefind-&gt;force_caps, g_value_dup_boxed (value));</span>


 362       GST_OBJECT_UNLOCK (typefind);
 363       break;
 364     default:
 365       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 366       break;
 367   }
 368 }
 369 
 370 static void
 371 gst_type_find_element_get_property (GObject * object, guint prop_id,
 372     GValue * value, GParamSpec * pspec)
 373 {
 374   GstTypeFindElement *typefind;
 375 
 376   typefind = GST_TYPE_FIND_ELEMENT (object);
 377 
 378   switch (prop_id) {
 379     case PROP_CAPS:
 380       GST_OBJECT_LOCK (typefind);
 381       g_value_set_boxed (value, typefind-&gt;caps);
 382       GST_OBJECT_UNLOCK (typefind);
 383       break;
 384     case PROP_MINIMUM:
 385       g_value_set_uint (value, typefind-&gt;min_probability);
 386       break;
 387     case PROP_FORCE_CAPS:
 388       GST_OBJECT_LOCK (typefind);
 389       g_value_set_boxed (value, typefind-&gt;force_caps);
 390       GST_OBJECT_UNLOCK (typefind);
 391       break;
 392     default:
 393       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 394       break;
 395   }
 396 }
 397 
 398 static gboolean
 399 gst_type_find_handle_src_query (GstPad * pad, GstObject * parent,
 400     GstQuery * query)
 401 {
 402   GstTypeFindElement *typefind;
 403   gboolean res = FALSE;
 404 
 405   typefind = GST_TYPE_FIND_ELEMENT (parent);
 406   GST_DEBUG_OBJECT (typefind, &quot;Handling src query %s&quot;,
 407       GST_QUERY_TYPE_NAME (query));
 408 
 409   switch (GST_QUERY_TYPE (query)) {
 410     case GST_QUERY_SCHEDULING:
 411       /* FIXME, filter out the scheduling modes that we understand */
 412       res = gst_pad_peer_query (typefind-&gt;sink, query);
 413       break;
 414     case GST_QUERY_CAPS:
 415     {
 416       GST_DEBUG_OBJECT (typefind,
 417           &quot;Got caps query, our caps are %&quot; GST_PTR_FORMAT, typefind-&gt;caps);
 418 
 419       /* We can hijack caps query if we typefind already */
 420       if (typefind-&gt;caps) {
 421         gst_query_set_caps_result (query, typefind-&gt;caps);
 422         res = TRUE;
 423       } else {
 424         res = gst_pad_peer_query (typefind-&gt;sink, query);
 425       }
 426       break;
 427     }
 428     case GST_QUERY_POSITION:
 429     {
 430       gint64 peer_pos;
 431       GstFormat format;
 432 
 433       if (!(res = gst_pad_peer_query (typefind-&gt;sink, query)))
 434         goto out;
 435 
 436       gst_query_parse_position (query, &amp;format, &amp;peer_pos);
 437 
 438       GST_OBJECT_LOCK (typefind);
 439       /* FIXME: this code assumes that there&#39;s no discont in the queue */
 440       switch (format) {
 441         case GST_FORMAT_BYTES:
 442           peer_pos -= gst_adapter_available (typefind-&gt;adapter);
 443           if (peer_pos &lt; 0)     /* Clamp result to 0 */
 444             peer_pos = 0;
 445           break;
 446         default:
 447           /* FIXME */
 448           break;
 449       }
 450       GST_OBJECT_UNLOCK (typefind);
 451       gst_query_set_position (query, format, peer_pos);
 452       break;
 453     }
 454     default:
 455       res = gst_pad_query_default (pad, parent, query);
 456       break;
 457   }
 458 out:
 459   return res;
 460 }
 461 
 462 static gboolean
 463 gst_type_find_element_seek (GstTypeFindElement * typefind, GstEvent * event)
 464 {
 465   GstSeekFlags flags;
 466   GstSeekType start_type, stop_type;
 467   GstFormat format;
 468   gboolean flush;
 469   gdouble rate;
 470   gint64 start, stop;
 471   GstSegment seeksegment = { 0, };
 472 
 473   gst_event_parse_seek (event, &amp;rate, &amp;format, &amp;flags, &amp;start_type, &amp;start,
 474       &amp;stop_type, &amp;stop);
 475 
 476   /* we can only seek on bytes */
 477   if (format != GST_FORMAT_BYTES) {
 478     GST_DEBUG_OBJECT (typefind, &quot;Can only seek on BYTES&quot;);
 479     return FALSE;
 480   }
 481 
 482   /* copy segment, we need this because we still need the old
 483    * segment when we close the current segment. */
 484   memcpy (&amp;seeksegment, &amp;typefind-&gt;segment, sizeof (GstSegment));
 485 
 486   GST_DEBUG_OBJECT (typefind, &quot;configuring seek&quot;);
 487   gst_segment_do_seek (&amp;seeksegment, rate, format, flags,
 488       start_type, start, stop_type, stop, NULL);
 489 
 490   flush = ! !(flags &amp; GST_SEEK_FLAG_FLUSH);
 491 
 492   GST_DEBUG_OBJECT (typefind, &quot;New segment %&quot; GST_SEGMENT_FORMAT, &amp;seeksegment);
 493 
 494   if (flush) {
 495     GST_DEBUG_OBJECT (typefind, &quot;Starting flush&quot;);
 496     gst_pad_push_event (typefind-&gt;sink, gst_event_new_flush_start ());
 497     gst_pad_push_event (typefind-&gt;src, gst_event_new_flush_start ());
 498   } else {
 499     GST_DEBUG_OBJECT (typefind, &quot;Non-flushing seek, pausing task&quot;);
 500     gst_pad_pause_task (typefind-&gt;sink);
 501   }
 502 
 503   /* now grab the stream lock so that streaming cannot continue, for
 504    * non flushing seeks when the element is in PAUSED this could block
 505    * forever. */
 506   GST_DEBUG_OBJECT (typefind, &quot;Waiting for streaming to stop&quot;);
 507   GST_PAD_STREAM_LOCK (typefind-&gt;sink);
 508 
 509   if (flush) {
 510     GST_DEBUG_OBJECT (typefind, &quot;Stopping flush&quot;);
 511     gst_pad_push_event (typefind-&gt;sink, gst_event_new_flush_stop (TRUE));
 512     gst_pad_push_event (typefind-&gt;src, gst_event_new_flush_stop (TRUE));
 513   }
 514 
 515   /* now update the real segment info */
 516   GST_DEBUG_OBJECT (typefind, &quot;Committing new seek segment&quot;);
 517   memcpy (&amp;typefind-&gt;segment, &amp;seeksegment, sizeof (GstSegment));
 518   typefind-&gt;offset = typefind-&gt;segment.start;
 519 
 520   /* notify start of new segment */
 521   if (typefind-&gt;segment.flags &amp; GST_SEGMENT_FLAG_SEGMENT) {
 522     GstMessage *msg;
 523 
 524     msg = gst_message_new_segment_start (GST_OBJECT (typefind),
 525         GST_FORMAT_BYTES, typefind-&gt;segment.start);
 526     gst_element_post_message (GST_ELEMENT (typefind), msg);
 527   }
 528 
 529   typefind-&gt;need_segment = TRUE;
 530 
 531   /* restart our task since it might have been stopped when we did the
 532    * flush. */
 533   gst_pad_start_task (typefind-&gt;sink,
 534       (GstTaskFunction) gst_type_find_element_loop, typefind-&gt;sink, NULL);
 535 
 536   /* streaming can continue now */
 537   GST_PAD_STREAM_UNLOCK (typefind-&gt;sink);
 538 
 539   return TRUE;
 540 }
 541 
 542 static gboolean
 543 gst_type_find_element_src_event (GstPad * pad, GstObject * parent,
 544     GstEvent * event)
 545 {
 546   GstTypeFindElement *typefind = GST_TYPE_FIND_ELEMENT (parent);
 547   gboolean result;
 548 
<a name="5" id="anc5"></a><span class="line-added"> 549   /* Always forward RECONFIGURE events upstream */</span>
<span class="line-added"> 550   if (GST_EVENT_TYPE (event) == GST_EVENT_RECONFIGURE) {</span>
<span class="line-added"> 551     return gst_pad_push_event (typefind-&gt;sink, event);</span>
<span class="line-added"> 552   }</span>
<span class="line-added"> 553 </span>
 554   if (typefind-&gt;mode != MODE_NORMAL) {
 555     /* need to do more? */
 556     GST_LOG_OBJECT (typefind, &quot;Still typefinding. Not passing event upstream&quot;);
 557     gst_event_unref (event);
 558     return FALSE;
 559   }
 560 
 561   /* Only handle seeks here if driving the pipeline */
 562   if (typefind-&gt;segment.format != GST_FORMAT_UNDEFINED &amp;&amp;
 563       GST_EVENT_TYPE (event) == GST_EVENT_SEEK) {
 564     result = gst_type_find_element_seek (typefind, event);
 565     gst_event_unref (event);
 566     return result;
 567   } else {
 568     return gst_pad_push_event (typefind-&gt;sink, event);
 569   }
 570 }
 571 
 572 static void
 573 start_typefinding (GstTypeFindElement * typefind)
 574 {
 575   GST_DEBUG_OBJECT (typefind, &quot;starting typefinding&quot;);
 576 
 577   GST_OBJECT_LOCK (typefind);
 578   if (typefind-&gt;caps)
 579     gst_caps_replace (&amp;typefind-&gt;caps, NULL);
 580   typefind-&gt;initial_offset = GST_BUFFER_OFFSET_NONE;
 581   GST_OBJECT_UNLOCK (typefind);
 582 
 583   typefind-&gt;mode = MODE_TYPEFIND;
 584 }
 585 
 586 static void
 587 stop_typefinding (GstTypeFindElement * typefind)
 588 {
 589   GstState state;
 590   gboolean push_cached_buffers;
 591   gsize avail;
 592   GstBuffer *buffer;
 593   GstClockTime pts, dts;
 594 
 595   gst_element_get_state (GST_ELEMENT (typefind), &amp;state, NULL, 0);
 596 
 597   push_cached_buffers = (state &gt;= GST_STATE_PAUSED &amp;&amp; typefind-&gt;caps);
 598 
 599   GST_DEBUG_OBJECT (typefind, &quot;stopping typefinding%s&quot;,
 600       push_cached_buffers ? &quot; and pushing cached events and buffers&quot; : &quot;&quot;);
 601 
 602   typefind-&gt;mode = MODE_NORMAL;
 603   if (push_cached_buffers)
 604     gst_type_find_element_send_cached_events (typefind);
 605 
 606   GST_OBJECT_LOCK (typefind);
 607   avail = gst_adapter_available (typefind-&gt;adapter);
 608   if (avail == 0)
 609     goto no_data;
 610 
 611   pts = gst_adapter_prev_pts (typefind-&gt;adapter, NULL);
 612   dts = gst_adapter_prev_dts (typefind-&gt;adapter, NULL);
 613   buffer = gst_adapter_take_buffer (typefind-&gt;adapter, avail);
 614   GST_BUFFER_PTS (buffer) = pts;
 615   GST_BUFFER_DTS (buffer) = dts;
 616   GST_BUFFER_OFFSET (buffer) = typefind-&gt;initial_offset;
 617   GST_OBJECT_UNLOCK (typefind);
 618 
 619   if (!push_cached_buffers) {
 620     gst_buffer_unref (buffer);
 621   } else {
 622     GstPad *peer = gst_pad_get_peer (typefind-&gt;src);
 623 
 624     /* make sure the user gets a meaningful error message in this case,
 625      * which is not a core bug or bug of any kind (as the default error
 626      * message emitted by gstpad.c otherwise would make you think) */
 627     if (peer &amp;&amp; GST_PAD_CHAINFUNC (peer) == NULL) {
 628       GST_DEBUG_OBJECT (typefind, &quot;upstream only supports push mode, while &quot;
 629           &quot;downstream element only works in pull mode, erroring out&quot;);
 630       GST_ELEMENT_ERROR (typefind, STREAM, FAILED,
 631           (&quot;%s cannot work in push mode. The operation is not supported &quot;
 632               &quot;with this source element or protocol.&quot;,
 633               G_OBJECT_TYPE_NAME (GST_PAD_PARENT (peer))),
 634           (&quot;Downstream pad %s:%s has no chainfunction, and the upstream &quot;
 635               &quot;element does not support pull mode&quot;, GST_DEBUG_PAD_NAME (peer)));
 636       typefind-&gt;mode = MODE_ERROR;      /* make the chain function error out */
 637       gst_buffer_unref (buffer);
 638     } else {
 639       gst_pad_push (typefind-&gt;src, buffer);
 640     }
 641     if (peer)
 642       gst_object_unref (peer);
 643   }
 644   return;
 645 
 646   /* ERRORS */
 647 no_data:
 648   {
 649     GST_DEBUG_OBJECT (typefind, &quot;we have no data to typefind&quot;);
 650     GST_OBJECT_UNLOCK (typefind);
 651     return;
 652   }
 653 }
 654 
 655 static gboolean
 656 gst_type_find_element_sink_event (GstPad * pad, GstObject * parent,
 657     GstEvent * event)
 658 {
 659   gboolean res = FALSE;
 660   GstTypeFindElement *typefind = GST_TYPE_FIND_ELEMENT (parent);
 661 
 662   GST_DEBUG_OBJECT (typefind, &quot;got %s event in mode %d&quot;,
 663       GST_EVENT_TYPE_NAME (event), typefind-&gt;mode);
 664 
 665   switch (typefind-&gt;mode) {
 666     case MODE_TYPEFIND:
 667       switch (GST_EVENT_TYPE (event)) {
 668         case GST_EVENT_CAPS:
 669         {
 670           GstCaps *caps;
 671 
 672           /* Parse and push out our caps and data */
 673           gst_event_parse_caps (event, &amp;caps);
 674           res = gst_type_find_element_setcaps (typefind, caps);
 675 
 676           gst_event_unref (event);
 677           break;
 678         }
 679         case GST_EVENT_GAP:
 680         {
 681           GST_FIXME_OBJECT (typefind,
 682               &quot;GAP events during typefinding not handled properly&quot;);
 683 
 684           /* FIXME: These would need to be inserted in the stream at
 685            * the right position between buffers, but we combine all
 686            * buffers with a GstAdapter. Drop the GAP event for now,
 687            * which will only cause an implicit GAP between buffers.
 688            */
 689           gst_event_unref (event);
 690           res = TRUE;
 691           break;
 692         }
 693         case GST_EVENT_EOS:
 694         {
 695           GST_INFO_OBJECT (typefind, &quot;Got EOS and no type found yet&quot;);
 696           gst_type_find_element_chain_do_typefinding (typefind, FALSE, TRUE);
 697 
 698           res = gst_pad_push_event (typefind-&gt;src, event);
 699           break;
 700         }
 701         case GST_EVENT_FLUSH_STOP:{
 702           GList *l;
 703 
 704           GST_OBJECT_LOCK (typefind);
 705 
 706           for (l = typefind-&gt;cached_events; l; l = l-&gt;next) {
 707             if (GST_EVENT_IS_STICKY (l-&gt;data) &amp;&amp;
 708                 GST_EVENT_TYPE (l-&gt;data) != GST_EVENT_SEGMENT &amp;&amp;
 709                 GST_EVENT_TYPE (l-&gt;data) != GST_EVENT_EOS) {
 710               gst_pad_store_sticky_event (typefind-&gt;src, l-&gt;data);
 711             }
 712             gst_event_unref (l-&gt;data);
 713           }
 714 
 715           g_list_free (typefind-&gt;cached_events);
 716           typefind-&gt;cached_events = NULL;
 717           gst_adapter_clear (typefind-&gt;adapter);
 718           GST_OBJECT_UNLOCK (typefind);
 719           /* fall through */
 720         }
 721         case GST_EVENT_FLUSH_START:
 722           res = gst_pad_push_event (typefind-&gt;src, event);
 723           break;
 724         default:
 725           /* Forward events that would happen before the caps event
 726            * directly instead of storing them. There&#39;s no reason not
 727            * to send them directly and we should only store events
 728            * for later sending that would need to come after the caps
 729            * event */
 730           if (GST_EVENT_TYPE (event) &lt; GST_EVENT_CAPS) {
 731             res = gst_pad_push_event (typefind-&gt;src, event);
 732           } else {
 733             GST_DEBUG_OBJECT (typefind, &quot;Saving %s event to send later&quot;,
 734                 GST_EVENT_TYPE_NAME (event));
 735             GST_OBJECT_LOCK (typefind);
 736             typefind-&gt;cached_events =
 737                 g_list_append (typefind-&gt;cached_events, event);
 738             GST_OBJECT_UNLOCK (typefind);
 739             res = TRUE;
 740           }
 741           break;
 742       }
 743       break;
 744     case MODE_NORMAL:
 745       res = gst_pad_push_event (typefind-&gt;src, event);
 746       break;
 747     case MODE_ERROR:
 748       break;
 749     default:
 750       g_assert_not_reached ();
 751   }
 752   return res;
 753 }
 754 
 755 static void
 756 gst_type_find_element_send_cached_events (GstTypeFindElement * typefind)
 757 {
 758   GList *l, *cached_events;
 759 
 760   GST_OBJECT_LOCK (typefind);
 761   cached_events = typefind-&gt;cached_events;
 762   typefind-&gt;cached_events = NULL;
 763   GST_OBJECT_UNLOCK (typefind);
 764 
 765   for (l = cached_events; l != NULL; l = l-&gt;next) {
 766     GstEvent *event = GST_EVENT (l-&gt;data);
 767 
 768     GST_DEBUG_OBJECT (typefind, &quot;sending cached %s event&quot;,
 769         GST_EVENT_TYPE_NAME (event));
 770     gst_pad_push_event (typefind-&gt;src, event);
 771   }
 772   g_list_free (cached_events);
 773 }
 774 
 775 static gboolean
 776 gst_type_find_element_setcaps (GstTypeFindElement * typefind, GstCaps * caps)
 777 {
 778   /* don&#39;t operate on ANY caps */
 779   if (gst_caps_is_any (caps))
 780     return TRUE;
 781 
 782   /* Set to MODE_NORMAL before emitting have-type, in case it triggers a seek */
 783   typefind-&gt;mode = MODE_NORMAL;
 784   gst_type_find_element_emit_have_type (typefind, GST_TYPE_FIND_MAXIMUM, caps);
 785 
 786   /* Shortcircuit typefinding if we get caps */
 787   GST_DEBUG_OBJECT (typefind, &quot;Skipping typefinding, using caps from &quot;
 788       &quot;upstream: %&quot; GST_PTR_FORMAT, caps);
 789 
 790   stop_typefinding (typefind);
 791 
 792   return TRUE;
 793 }
 794 
 795 static gchar *
 796 gst_type_find_get_extension (GstTypeFindElement * typefind, GstPad * pad)
 797 {
 798   GstQuery *query;
 799   gchar *uri, *result;
 800   size_t len;
 801   gint find;
 802 
 803   query = gst_query_new_uri ();
 804 
 805   /* try getting the caps with an uri query and from the extension */
 806   if (!gst_pad_peer_query (pad, query))
 807     goto peer_query_failed;
 808 
 809   gst_query_parse_uri (query, &amp;uri);
 810   if (uri == NULL)
 811     goto no_uri;
 812 
 813   GST_DEBUG_OBJECT (typefind, &quot;finding extension of %s&quot;, uri);
 814 
 815   /* find the extension on the uri, this is everything after a &#39;.&#39; */
 816   len = strlen (uri);
 817   find = len - 1;
 818 
 819   while (find &gt;= 0) {
 820     if (uri[find] == &#39;.&#39;)
 821       break;
 822     find--;
 823   }
 824   if (find &lt; 0)
 825     goto no_extension;
 826 
 827   result = g_strdup (&amp;uri[find + 1]);
 828 
 829   GST_DEBUG_OBJECT (typefind, &quot;found extension %s&quot;, result);
 830   gst_query_unref (query);
 831   g_free (uri);
 832 
 833   return result;
 834 
 835   /* ERRORS */
 836 peer_query_failed:
 837   {
<a name="6" id="anc6"></a><span class="line-modified"> 838     GST_INFO_OBJECT (typefind, &quot;failed to query peer uri&quot;);</span>
 839     gst_query_unref (query);
 840     return NULL;
 841   }
 842 no_uri:
 843   {
<a name="7" id="anc7"></a><span class="line-modified"> 844     GST_INFO_OBJECT (typefind, &quot;could not parse the peer uri&quot;);</span>
 845     gst_query_unref (query);
 846     return NULL;
 847   }
 848 no_extension:
 849   {
<a name="8" id="anc8"></a><span class="line-modified"> 850     GST_INFO_OBJECT (typefind, &quot;could not find uri extension in %s&quot;, uri);</span>
 851     gst_query_unref (query);
 852     g_free (uri);
 853     return NULL;
 854   }
 855 }
 856 
 857 static GstCaps *
 858 gst_type_find_guess_by_extension (GstTypeFindElement * typefind, GstPad * pad,
 859     GstTypeFindProbability * probability)
 860 {
 861   gchar *ext;
 862   GstCaps *caps;
 863 
 864   ext = gst_type_find_get_extension (typefind, pad);
 865   if (!ext)
 866     return NULL;
 867 
 868   caps = gst_type_find_helper_for_extension (GST_OBJECT_CAST (typefind), ext);
 869   if (caps)
 870     *probability = GST_TYPE_FIND_MAXIMUM;
 871 
 872   g_free (ext);
 873 
 874   return caps;
 875 }
 876 
 877 static GstFlowReturn
 878 gst_type_find_element_chain (GstPad * pad, GstObject * parent,
 879     GstBuffer * buffer)
 880 {
 881   GstTypeFindElement *typefind;
 882   GstFlowReturn res = GST_FLOW_OK;
 883 
 884   typefind = GST_TYPE_FIND_ELEMENT (parent);
 885 
 886   GST_LOG_OBJECT (typefind, &quot;handling buffer in mode %d&quot;, typefind-&gt;mode);
 887 
 888   switch (typefind-&gt;mode) {
 889     case MODE_ERROR:
 890       /* we should already have called GST_ELEMENT_ERROR */
 891       return GST_FLOW_ERROR;
 892     case MODE_NORMAL:
 893       /* don&#39;t take object lock as typefind-&gt;caps should not change anymore */
 894       return gst_pad_push (typefind-&gt;src, buffer);
 895     case MODE_TYPEFIND:
 896     {
 897       GST_OBJECT_LOCK (typefind);
 898       if (typefind-&gt;initial_offset == GST_BUFFER_OFFSET_NONE)
 899         typefind-&gt;initial_offset = GST_BUFFER_OFFSET (buffer);
 900       gst_adapter_push (typefind-&gt;adapter, buffer);
 901       GST_OBJECT_UNLOCK (typefind);
 902 
 903       res = gst_type_find_element_chain_do_typefinding (typefind, TRUE, FALSE);
 904 
 905       if (typefind-&gt;mode == MODE_ERROR)
 906         res = GST_FLOW_ERROR;
 907 
 908       break;
 909     }
 910     default:
 911       g_assert_not_reached ();
 912       return GST_FLOW_ERROR;
 913   }
 914 
 915   return res;
 916 }
 917 
 918 static GstFlowReturn
 919 gst_type_find_element_chain_do_typefinding (GstTypeFindElement * typefind,
 920     gboolean check_avail, gboolean at_eos)
 921 {
 922   GstTypeFindProbability probability;
 923   GstCaps *caps = NULL;
 924   gsize avail;
 925   const guint8 *data;
 926   gboolean have_min, have_max;
<a name="9" id="anc9"></a><span class="line-added"> 927   gchar *ext;</span>
 928 
 929   GST_OBJECT_LOCK (typefind);
 930   if (typefind-&gt;force_caps) {
 931     caps = gst_caps_ref (typefind-&gt;force_caps);
 932     probability = GST_TYPE_FIND_MAXIMUM;
 933   }
 934 
 935   if (!caps) {
 936     avail = gst_adapter_available (typefind-&gt;adapter);
 937 
 938     if (check_avail) {
 939       have_min = avail &gt;= TYPE_FIND_MIN_SIZE;
 940       have_max = avail &gt;= TYPE_FIND_MAX_SIZE;
 941     } else {
 942       have_min = avail &gt; 0;
 943       have_max = TRUE;
 944     }
 945 
 946     if (!have_min)
 947       goto not_enough_data;
 948 
<a name="10" id="anc10"></a><span class="line-added"> 949     ext = gst_type_find_get_extension (typefind, typefind-&gt;sink);</span>
 950     /* map all available data */
 951     data = gst_adapter_map (typefind-&gt;adapter, avail);
<a name="11" id="anc11"></a><span class="line-modified"> 952     caps = gst_type_find_helper_for_data_with_extension (GST_OBJECT (typefind),</span>
<span class="line-modified"> 953         data, avail, ext, &amp;probability);</span>
 954     gst_adapter_unmap (typefind-&gt;adapter);
<a name="12" id="anc12"></a><span class="line-added"> 955     g_free (ext);</span>
 956 
 957     if (caps == NULL &amp;&amp; have_max)
 958       goto no_type_found;
 959     else if (caps == NULL)
 960       goto wait_for_data;
 961 
 962     /* found a type */
 963     if (probability &lt; typefind-&gt;min_probability)
 964       goto low_probability;
 965   }
 966 
 967   GST_OBJECT_UNLOCK (typefind);
 968 
<a name="13" id="anc13"></a><span class="line-modified"> 969   /* probability is good enough too, so let&#39;s make it known ... emitting this</span>
 970    * signal calls our object handler which sets the caps. */
 971   /* Set to MODE_NORMAL before emitting have-type, in case it triggers a seek */
 972   typefind-&gt;mode = MODE_NORMAL;
 973   gst_type_find_element_emit_have_type (typefind, probability, caps);
 974 
 975   /* .. and send out the accumulated data */
 976   stop_typefinding (typefind);
 977   gst_caps_unref (caps);
 978 
 979   return GST_FLOW_OK;
 980 
 981 not_enough_data:
 982   {
 983     GST_OBJECT_UNLOCK (typefind);
 984 
 985     if (at_eos) {
 986       GST_ELEMENT_ERROR (typefind, STREAM, TYPE_NOT_FOUND,
 987           (_(&quot;Stream doesn&#39;t contain enough data.&quot;)),
 988           (&quot;Can&#39;t typefind stream&quot;));
 989       return GST_FLOW_ERROR;
 990     } else {
<a name="14" id="anc14"></a><span class="line-modified"> 991       GST_DEBUG_OBJECT (typefind, &quot;not enough data for typefinding yet &quot;</span>
<span class="line-modified"> 992           &quot;(%&quot; G_GSIZE_FORMAT &quot; bytes)&quot;, avail);</span>
<span class="line-modified"> 993       return GST_FLOW_OK;</span>
<span class="line-modified"> 994     }</span>
 995   }
 996 no_type_found:
 997   {
 998     GST_OBJECT_UNLOCK (typefind);
 999     GST_ELEMENT_ERROR (typefind, STREAM, TYPE_NOT_FOUND, (NULL), (NULL));
1000     stop_typefinding (typefind);
1001     return GST_FLOW_ERROR;
1002   }
1003 wait_for_data:
1004   {
1005     GST_OBJECT_UNLOCK (typefind);
1006 
1007     if (at_eos) {
1008       GST_ELEMENT_ERROR (typefind, STREAM, TYPE_NOT_FOUND,
1009           (_(&quot;Stream doesn&#39;t contain enough data.&quot;)),
1010           (&quot;Can&#39;t typefind stream&quot;));
1011       return GST_FLOW_ERROR;
1012     } else {
<a name="15" id="anc15"></a><span class="line-modified">1013       GST_DEBUG_OBJECT (typefind,</span>
<span class="line-modified">1014           &quot;no caps found with %&quot; G_GSIZE_FORMAT &quot; bytes of data, &quot;</span>
<span class="line-modified">1015           &quot;waiting for more data&quot;, avail);</span>
<span class="line-modified">1016       return GST_FLOW_OK;</span>
<span class="line-modified">1017     }</span>
1018   }
1019 low_probability:
1020   {
1021     GST_DEBUG_OBJECT (typefind, &quot;found caps %&quot; GST_PTR_FORMAT &quot;, but &quot;
1022         &quot;probability is %u which is lower than the required minimum of %u&quot;,
1023         caps, probability, typefind-&gt;min_probability);
1024 
1025     gst_caps_unref (caps);
1026 
1027     if (have_max)
1028       goto no_type_found;
1029 
1030     GST_OBJECT_UNLOCK (typefind);
1031     GST_DEBUG_OBJECT (typefind, &quot;waiting for more data to try again&quot;);
1032     return GST_FLOW_OK;
1033   }
1034 }
1035 
1036 static GstFlowReturn
1037 gst_type_find_element_getrange (GstPad * srcpad, GstObject * parent,
1038     guint64 offset, guint length, GstBuffer ** buffer)
1039 {
1040   GstTypeFindElement *typefind;
1041   GstFlowReturn ret;
1042 
1043   typefind = GST_TYPE_FIND_ELEMENT (parent);
1044 
1045   ret = gst_pad_pull_range (typefind-&gt;sink, offset, length, buffer);
1046 
1047   return ret;
1048 }
1049 
1050 static gboolean
1051 gst_type_find_element_activate_src_mode (GstPad * pad, GstObject * parent,
1052     GstPadMode mode, gboolean active)
1053 {
1054   gboolean res;
1055   GstTypeFindElement *typefind;
1056 
1057   typefind = GST_TYPE_FIND_ELEMENT (parent);
1058 
1059   switch (mode) {
1060     case GST_PAD_MODE_PULL:
1061       /* make sure our task stops pushing, we can&#39;t call _stop here because this
1062        * activation might happen from the streaming thread. */
1063       gst_pad_pause_task (typefind-&gt;sink);
1064       res = gst_pad_activate_mode (typefind-&gt;sink, mode, active);
1065       break;
1066     default:
1067       res = TRUE;
1068       break;
1069   }
1070   return res;
1071 }
1072 
1073 static void
1074 gst_type_find_element_loop (GstPad * pad)
1075 {
1076   GstTypeFindElement *typefind;
1077   GstFlowReturn ret = GST_FLOW_OK;
1078 
1079   typefind = GST_TYPE_FIND_ELEMENT (GST_PAD_PARENT (pad));
1080 
1081   if (typefind-&gt;need_stream_start) {
1082     gchar *stream_id;
1083     GstEvent *event;
1084 
1085     stream_id = gst_pad_create_stream_id (typefind-&gt;src,
1086         GST_ELEMENT_CAST (typefind), NULL);
1087 
1088     GST_DEBUG_OBJECT (typefind, &quot;Pushing STREAM_START&quot;);
1089     event = gst_event_new_stream_start (stream_id);
1090     gst_event_set_group_id (event, gst_util_group_id_next ());
1091     gst_pad_push_event (typefind-&gt;src, event);
1092 
1093     typefind-&gt;need_stream_start = FALSE;
1094     g_free (stream_id);
1095   }
1096 
1097   if (typefind-&gt;mode == MODE_TYPEFIND) {
1098     GstPad *peer = NULL;
1099     GstCaps *found_caps = NULL;
1100     GstTypeFindProbability probability = GST_TYPE_FIND_NONE;
1101 
1102     GST_DEBUG_OBJECT (typefind, &quot;find type in pull mode&quot;);
1103 
1104     GST_OBJECT_LOCK (typefind);
1105     if (typefind-&gt;force_caps) {
1106       found_caps = gst_caps_ref (typefind-&gt;force_caps);
1107       probability = GST_TYPE_FIND_MAXIMUM;
1108     }
1109     GST_OBJECT_UNLOCK (typefind);
1110 
1111     if (!found_caps) {
1112       peer = gst_pad_get_peer (pad);
1113       if (peer) {
1114         gint64 size;
1115         gchar *ext;
1116 
1117         if (!gst_pad_query_duration (peer, GST_FORMAT_BYTES, &amp;size)) {
1118           GST_WARNING_OBJECT (typefind, &quot;Could not query upstream length!&quot;);
1119           gst_object_unref (peer);
1120 
1121           ret = GST_FLOW_ERROR;
1122           goto pause;
1123         }
1124 
1125         /* the size if 0, we cannot continue */
1126         if (size == 0) {
1127           /* keep message in sync with message in sink event handler */
1128           GST_ELEMENT_ERROR (typefind, STREAM, TYPE_NOT_FOUND,
1129               (_(&quot;Stream contains no data.&quot;)), (&quot;Can&#39;t typefind empty stream&quot;));
1130           gst_object_unref (peer);
1131           ret = GST_FLOW_ERROR;
1132           goto pause;
1133         }
1134         ext = gst_type_find_get_extension (typefind, pad);
1135 
1136         ret =
1137             gst_type_find_helper_get_range_full (GST_OBJECT_CAST (peer),
1138             GST_OBJECT_PARENT (peer),
1139             (GstTypeFindHelperGetRangeFunction) (GST_PAD_GETRANGEFUNC (peer)),
1140             (guint64) size, ext, &amp;found_caps, &amp;probability);
1141         g_free (ext);
1142 
1143         GST_DEBUG (&quot;Found caps %&quot; GST_PTR_FORMAT, found_caps);
1144 
1145         gst_object_unref (peer);
1146 
1147         if (ret != GST_FLOW_OK)
1148           goto pause;
1149       }
1150     }
1151 
1152     if (!found_caps || probability &lt; typefind-&gt;min_probability) {
1153       GST_DEBUG (&quot;Trying to guess using extension&quot;);
1154       gst_caps_replace (&amp;found_caps, NULL);
1155       found_caps =
1156           gst_type_find_guess_by_extension (typefind, pad, &amp;probability);
1157     }
1158 
1159     if (!found_caps || probability &lt; typefind-&gt;min_probability) {
1160       GST_ELEMENT_ERROR (typefind, STREAM, TYPE_NOT_FOUND, (NULL), (NULL));
1161       gst_caps_replace (&amp;found_caps, NULL);
1162       ret = GST_FLOW_ERROR;
1163       goto pause;
1164     }
1165 
<a name="16" id="anc16"></a><span class="line-modified">1166     GST_DEBUG (&quot;Emitting found caps %&quot; GST_PTR_FORMAT, found_caps);</span>
1167     /* Set to MODE_NORMAL before emitting have-type, in case it triggers a seek */
1168     typefind-&gt;mode = MODE_NORMAL;
1169     gst_type_find_element_emit_have_type (typefind, probability, found_caps);
1170     gst_caps_unref (found_caps);
1171   } else if (typefind-&gt;mode == MODE_NORMAL) {
1172     GstBuffer *outbuf = NULL;
1173 
1174     if (typefind-&gt;need_segment) {
1175       typefind-&gt;need_segment = FALSE;
1176       gst_pad_push_event (typefind-&gt;src,
1177           gst_event_new_segment (&amp;typefind-&gt;segment));
1178     }
1179 
1180     /* Pull 4k blocks and send downstream */
1181     ret = gst_pad_pull_range (typefind-&gt;sink, typefind-&gt;offset, 4096, &amp;outbuf);
1182     if (ret != GST_FLOW_OK)
1183       goto pause;
1184 
1185     typefind-&gt;offset += gst_buffer_get_size (outbuf);
1186 
1187     ret = gst_pad_push (typefind-&gt;src, outbuf);
1188     if (ret != GST_FLOW_OK)
1189       goto pause;
1190   } else {
1191     /* Error out */
1192     ret = GST_FLOW_ERROR;
1193     goto pause;
1194   }
1195 
1196   return;
1197 
1198 pause:
1199   {
1200     const gchar *reason = gst_flow_get_name (ret);
1201     gboolean push_eos = FALSE;
1202 
1203     GST_LOG_OBJECT (typefind, &quot;pausing task, reason %s&quot;, reason);
1204     gst_pad_pause_task (typefind-&gt;sink);
1205 
1206     if (ret == GST_FLOW_EOS) {
1207       /* perform EOS logic */
1208 
1209       if (typefind-&gt;segment.flags &amp; GST_SEGMENT_FLAG_SEGMENT) {
1210         gint64 stop;
1211 
1212         /* for segment playback we need to post when (in stream time)
1213          * we stopped, this is either stop (when set) or the duration. */
1214         if ((stop = typefind-&gt;segment.stop) == -1)
1215           stop = typefind-&gt;offset;
1216 
1217         GST_LOG_OBJECT (typefind, &quot;Sending segment done, at end of segment&quot;);
1218         gst_element_post_message (GST_ELEMENT (typefind),
1219             gst_message_new_segment_done (GST_OBJECT (typefind),
1220                 GST_FORMAT_BYTES, stop));
1221         gst_pad_push_event (typefind-&gt;src,
1222             gst_event_new_segment_done (GST_FORMAT_BYTES, stop));
1223       } else {
1224         push_eos = TRUE;
1225       }
1226     } else if (ret == GST_FLOW_NOT_LINKED || ret &lt; GST_FLOW_EOS) {
1227       /* for fatal errors we post an error message */
1228       GST_ELEMENT_FLOW_ERROR (typefind, ret);
1229       push_eos = TRUE;
1230     }
1231     if (push_eos) {
1232       /* send EOS, and prevent hanging if no streams yet */
1233       GST_LOG_OBJECT (typefind, &quot;Sending EOS, at end of stream&quot;);
1234       gst_pad_push_event (typefind-&gt;src, gst_event_new_eos ());
1235     }
1236     return;
1237   }
1238 }
1239 
1240 static gboolean
1241 gst_type_find_element_activate_sink_mode (GstPad * pad, GstObject * parent,
1242     GstPadMode mode, gboolean active)
1243 {
1244   gboolean res;
1245   GstTypeFindElement *typefind;
1246 
1247   typefind = GST_TYPE_FIND_ELEMENT (parent);
1248 
1249   switch (mode) {
1250     case GST_PAD_MODE_PULL:
1251       if (active) {
1252         gst_segment_init (&amp;typefind-&gt;segment, GST_FORMAT_BYTES);
1253         typefind-&gt;need_segment = TRUE;
1254         typefind-&gt;need_stream_start = TRUE;
1255         typefind-&gt;offset = 0;
1256         res = TRUE;
1257       } else {
1258         res = gst_pad_stop_task (pad);
1259         gst_segment_init (&amp;typefind-&gt;segment, GST_FORMAT_UNDEFINED);
1260       }
1261       break;
1262     case GST_PAD_MODE_PUSH:
1263       if (active) {
1264         gst_segment_init (&amp;typefind-&gt;segment, GST_FORMAT_UNDEFINED);
1265         start_typefinding (typefind);
1266       } else {
1267         stop_typefinding (typefind);
1268         gst_segment_init (&amp;typefind-&gt;segment, GST_FORMAT_UNDEFINED);
1269       }
1270       res = TRUE;
1271       break;
1272     default:
1273       res = FALSE;
1274       break;
1275   }
1276   return res;
1277 }
1278 
1279 static gboolean
1280 gst_type_find_element_activate_sink (GstPad * pad, GstObject * parent)
1281 {
1282   GstQuery *query;
1283   gboolean pull_mode;
1284 
1285   query = gst_query_new_scheduling ();
1286 
1287   if (!gst_pad_peer_query (pad, query)) {
1288     gst_query_unref (query);
1289     goto typefind_push;
1290   }
1291 
1292   pull_mode = gst_query_has_scheduling_mode_with_flags (query,
1293       GST_PAD_MODE_PULL, GST_SCHEDULING_FLAG_SEEKABLE);
1294 
1295   gst_query_unref (query);
1296 
1297   if (!pull_mode)
1298     goto typefind_push;
1299 
1300   if (!gst_pad_activate_mode (pad, GST_PAD_MODE_PULL, TRUE))
1301     goto typefind_push;
1302 
1303   /* only start our task if we ourselves decide to start in pull mode */
1304   return gst_pad_start_task (pad, (GstTaskFunction) gst_type_find_element_loop,
1305       pad, NULL);
1306 
1307 typefind_push:
1308   {
1309     return gst_pad_activate_mode (pad, GST_PAD_MODE_PUSH, TRUE);
1310   }
1311 }
1312 
1313 static GstStateChangeReturn
1314 gst_type_find_element_change_state (GstElement * element,
1315     GstStateChange transition)
1316 {
1317   GstStateChangeReturn ret;
1318   GstTypeFindElement *typefind;
1319 
1320   typefind = GST_TYPE_FIND_ELEMENT (element);
1321 
1322 
1323   ret = GST_ELEMENT_CLASS (parent_class)-&gt;change_state (element, transition);
1324 
1325   switch (transition) {
1326     case GST_STATE_CHANGE_PAUSED_TO_READY:
1327     case GST_STATE_CHANGE_READY_TO_NULL:
1328       GST_OBJECT_LOCK (typefind);
1329       gst_caps_replace (&amp;typefind-&gt;caps, NULL);
1330 
1331       g_list_foreach (typefind-&gt;cached_events,
1332           (GFunc) gst_mini_object_unref, NULL);
1333       g_list_free (typefind-&gt;cached_events);
1334       typefind-&gt;cached_events = NULL;
1335       typefind-&gt;mode = MODE_TYPEFIND;
1336       GST_OBJECT_UNLOCK (typefind);
1337       break;
1338     default:
1339       break;
1340   }
1341 
1342   return ret;
1343 }
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>