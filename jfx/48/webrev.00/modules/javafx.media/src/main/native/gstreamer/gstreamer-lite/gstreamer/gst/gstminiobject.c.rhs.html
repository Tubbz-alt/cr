<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstminiobject.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 2005 David Schleef &lt;ds@schleef.org&gt;
   3  *
   4  * gstminiobject.h: Header for GstMiniObject
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 /**
  22  * SECTION:gstminiobject
  23  * @title: GstMiniObject
  24  * @short_description: Lightweight base class for the GStreamer object hierarchy
  25  *
  26  * #GstMiniObject is a simple structure that can be used to implement refcounted
  27  * types.
  28  *
  29  * Subclasses will include #GstMiniObject as the first member in their structure
  30  * and then call gst_mini_object_init() to initialize the #GstMiniObject fields.
  31  *
  32  * gst_mini_object_ref() and gst_mini_object_unref() increment and decrement the
  33  * refcount respectively. When the refcount of a mini-object reaches 0, the
  34  * dispose function is called first and when this returns %TRUE, the free
  35  * function of the miniobject is called.
  36  *
  37  * A copy can be made with gst_mini_object_copy().
  38  *
  39  * gst_mini_object_is_writable() will return %TRUE when the refcount of the
<a name="1" id="anc1"></a><span class="line-modified">  40  * object is exactly 1 and there is no parent or a single parent exists and is</span>
<span class="line-modified">  41  * writable itself, meaning the current caller has the only reference to the</span>
<span class="line-modified">  42  * object. gst_mini_object_make_writable() will return a writable version of</span>
<span class="line-added">  43  * the object, which might be a new copy when the refcount was not 1.</span>
  44  *
  45  * Opaque data can be associated with a #GstMiniObject with
  46  * gst_mini_object_set_qdata() and gst_mini_object_get_qdata(). The data is
  47  * meant to be specific to the particular object and is not automatically copied
  48  * with gst_mini_object_copy() or similar methods.
  49  *
  50  * A weak reference can be added and remove with gst_mini_object_weak_ref()
  51  * and gst_mini_object_weak_unref() respectively.
  52  */
  53 #ifdef HAVE_CONFIG_H
  54 #include &quot;config.h&quot;
  55 #endif
  56 
  57 #include &quot;gst/gst_private.h&quot;
  58 #include &quot;gst/gstminiobject.h&quot;
  59 #include &quot;gst/gstinfo.h&quot;
  60 #include &lt;gobject/gvaluecollector.h&gt;
  61 
  62 /* Mutex used for weak referencing */
  63 G_LOCK_DEFINE_STATIC (qdata_mutex);
  64 static GQuark weak_ref_quark;
  65 
  66 #define SHARE_ONE (1 &lt;&lt; 16)
  67 #define SHARE_TWO (2 &lt;&lt; 16)
  68 #define SHARE_MASK (~(SHARE_ONE - 1))
  69 #define IS_SHARED(state) (state &gt;= SHARE_TWO)
  70 #define LOCK_ONE (GST_LOCK_FLAG_LAST)
  71 #define FLAG_MASK (GST_LOCK_FLAG_LAST - 1)
  72 #define LOCK_MASK ((SHARE_ONE - 1) - FLAG_MASK)
  73 #define LOCK_FLAG_MASK (SHARE_ONE - 1)
  74 
<a name="2" id="anc2"></a><span class="line-added">  75 /* For backwards compatibility reasons we use the</span>
<span class="line-added">  76  * guint and gpointer in the GstMiniObject struct in</span>
<span class="line-added">  77  * a rather complicated way to store the parent(s) and qdata.</span>
<span class="line-added">  78  * Originally the were just the number of qdatas and the qdata.</span>
<span class="line-added">  79  *</span>
<span class="line-added">  80  * The guint is used as an atomic state integer with the following</span>
<span class="line-added">  81  * states:</span>
<span class="line-added">  82  * - Locked: 0, basically a spinlock</span>
<span class="line-added">  83  * - No parent, no qdata: 1 (pointer is NULL)</span>
<span class="line-added">  84  * - One parent: 2 (pointer contains the parent)</span>
<span class="line-added">  85  * - Multiple parents or qdata: 3 (pointer contains a PrivData struct)</span>
<span class="line-added">  86  *</span>
<span class="line-added">  87  * Unless we&#39;re in state 3, we always have to move to Locking state</span>
<span class="line-added">  88  * atomically and release that again later to the target state whenever</span>
<span class="line-added">  89  * accessing the pointer. When we&#39;re in state 3, we will never move to lower</span>
<span class="line-added">  90  * states again</span>
<span class="line-added">  91  *</span>
<span class="line-added">  92  * FIXME 2.0: We should store this directly inside the struct, possibly</span>
<span class="line-added">  93  * keeping space directly allocated for a couple of parents</span>
<span class="line-added">  94  */</span>
<span class="line-added">  95 </span>
<span class="line-added">  96 enum</span>
<span class="line-added">  97 {</span>
<span class="line-added">  98   PRIV_DATA_STATE_LOCKED = 0,</span>
<span class="line-added">  99   PRIV_DATA_STATE_NO_PARENT = 1,</span>
<span class="line-added"> 100   PRIV_DATA_STATE_ONE_PARENT = 2,</span>
<span class="line-added"> 101   PRIV_DATA_STATE_PARENTS_OR_QDATA = 3,</span>
<span class="line-added"> 102 };</span>
<span class="line-added"> 103 </span>
 104 typedef struct
 105 {
 106   GQuark quark;
 107   GstMiniObjectNotify notify;
 108   gpointer data;
 109   GDestroyNotify destroy;
 110 } GstQData;
 111 
<a name="3" id="anc3"></a><span class="line-modified"> 112 typedef struct</span>
<span class="line-added"> 113 {</span>
<span class="line-added"> 114   /* Atomic spinlock: 1 if locked, 0 otherwise */</span>
<span class="line-added"> 115   gint parent_lock;</span>
<span class="line-added"> 116   guint n_parents, n_parents_len;</span>
<span class="line-added"> 117   GstMiniObject **parents;</span>
<span class="line-added"> 118 </span>
<span class="line-added"> 119   guint n_qdata, n_qdata_len;</span>
<span class="line-added"> 120   GstQData *qdata;</span>
<span class="line-added"> 121 } PrivData;</span>
<span class="line-added"> 122 </span>
<span class="line-added"> 123 #define QDATA(q,i)          (q-&gt;qdata)[(i)]</span>
 124 #define QDATA_QUARK(o,i)    (QDATA(o,i).quark)
 125 #define QDATA_NOTIFY(o,i)   (QDATA(o,i).notify)
 126 #define QDATA_DATA(o,i)     (QDATA(o,i).data)
 127 #define QDATA_DESTROY(o,i)  (QDATA(o,i).destroy)
 128 
 129 void
 130 _priv_gst_mini_object_initialize (void)
 131 {
 132   weak_ref_quark = g_quark_from_static_string (&quot;GstMiniObjectWeakRefQuark&quot;);
 133 }
 134 
 135 /**
 136  * gst_mini_object_init: (skip)
 137  * @mini_object: a #GstMiniObject
 138  * @flags: initial #GstMiniObjectFlags
 139  * @type: the #GType of the mini-object to create
 140  * @copy_func: (allow-none): the copy function, or %NULL
 141  * @dispose_func: (allow-none): the dispose function, or %NULL
 142  * @free_func: (allow-none): the free function or %NULL
 143  *
 144  * Initializes a mini-object with the desired type and copy/dispose/free
 145  * functions.
 146  */
 147 void
 148 gst_mini_object_init (GstMiniObject * mini_object, guint flags, GType type,
 149     GstMiniObjectCopyFunction copy_func,
 150     GstMiniObjectDisposeFunction dispose_func,
 151     GstMiniObjectFreeFunction free_func)
 152 {
 153   mini_object-&gt;type = type;
 154   mini_object-&gt;refcount = 1;
 155   mini_object-&gt;lockstate = 0;
 156   mini_object-&gt;flags = flags;
 157 
 158   mini_object-&gt;copy = copy_func;
 159   mini_object-&gt;dispose = dispose_func;
 160   mini_object-&gt;free = free_func;
 161 
<a name="4" id="anc4"></a><span class="line-modified"> 162   g_atomic_int_set ((gint *) &amp; mini_object-&gt;priv_uint,</span>
<span class="line-modified"> 163       PRIV_DATA_STATE_NO_PARENT);</span>
<span class="line-added"> 164   mini_object-&gt;priv_pointer = NULL;</span>
 165 
 166   GST_TRACER_MINI_OBJECT_CREATED (mini_object);
 167 }
 168 
 169 /**
 170  * gst_mini_object_copy: (skip)
 171  * @mini_object: the mini-object to copy
 172  *
 173  * Creates a copy of the mini-object.
 174  *
 175  * MT safe
 176  *
 177  * Returns: (transfer full) (nullable): the new mini-object if copying is
 178  * possible, %NULL otherwise.
 179  */
 180 GstMiniObject *
 181 gst_mini_object_copy (const GstMiniObject * mini_object)
 182 {
 183   GstMiniObject *copy;
 184 
 185   g_return_val_if_fail (mini_object != NULL, NULL);
 186 
 187   if (mini_object-&gt;copy)
 188     copy = mini_object-&gt;copy (mini_object);
 189   else
 190     copy = NULL;
 191 
 192   return copy;
 193 }
 194 
 195 /**
 196  * gst_mini_object_lock:
 197  * @object: the mini-object to lock
 198  * @flags: #GstLockFlags
 199  *
 200  * Lock the mini-object with the specified access mode in @flags.
 201  *
 202  * Returns: %TRUE if @object could be locked.
 203  */
 204 gboolean
 205 gst_mini_object_lock (GstMiniObject * object, GstLockFlags flags)
 206 {
 207   gint access_mode, state, newstate;
 208 
 209   g_return_val_if_fail (object != NULL, FALSE);
 210   g_return_val_if_fail (GST_MINI_OBJECT_IS_LOCKABLE (object), FALSE);
 211 
 212   if (G_UNLIKELY (object-&gt;flags &amp; GST_MINI_OBJECT_FLAG_LOCK_READONLY &amp;&amp;
 213           flags &amp; GST_LOCK_FLAG_WRITE))
 214     return FALSE;
 215 
 216   do {
 217     access_mode = flags &amp; FLAG_MASK;
 218     newstate = state = g_atomic_int_get (&amp;object-&gt;lockstate);
 219 
 220     GST_CAT_TRACE (GST_CAT_LOCKING, &quot;lock %p: state %08x, access_mode %d&quot;,
 221         object, state, access_mode);
 222 
 223     if (access_mode &amp; GST_LOCK_FLAG_EXCLUSIVE) {
 224       /* shared ref */
 225       newstate += SHARE_ONE;
 226       access_mode &amp;= ~GST_LOCK_FLAG_EXCLUSIVE;
 227     }
 228 
<a name="5" id="anc5"></a><span class="line-modified"> 229     /* shared counter &gt; 1 and write access is not allowed */</span>
 230     if (((state &amp; GST_LOCK_FLAG_WRITE) != 0
 231             || (access_mode &amp; GST_LOCK_FLAG_WRITE) != 0)
 232         &amp;&amp; IS_SHARED (newstate))
<a name="6" id="anc6"></a><span class="line-modified"> 233       goto lock_failed;</span>
 234 
 235     if (access_mode) {
 236       if ((state &amp; LOCK_FLAG_MASK) == 0) {
 237         /* nothing mapped, set access_mode */
 238         newstate |= access_mode;
 239       } else {
 240         /* access_mode must match */
 241         if ((state &amp; access_mode) != access_mode)
 242           goto lock_failed;
 243       }
 244       /* increase refcount */
 245       newstate += LOCK_ONE;
 246     }
 247   } while (!g_atomic_int_compare_and_exchange (&amp;object-&gt;lockstate, state,
 248           newstate));
 249 
 250   return TRUE;
 251 
 252 lock_failed:
 253   {
 254     GST_CAT_DEBUG (GST_CAT_LOCKING,
 255         &quot;lock failed %p: state %08x, access_mode %d&quot;, object, state,
 256         access_mode);
 257     return FALSE;
 258   }
 259 }
 260 
 261 /**
 262  * gst_mini_object_unlock:
 263  * @object: the mini-object to unlock
 264  * @flags: #GstLockFlags
 265  *
 266  * Unlock the mini-object with the specified access mode in @flags.
 267  */
 268 void
 269 gst_mini_object_unlock (GstMiniObject * object, GstLockFlags flags)
 270 {
 271   gint access_mode, state, newstate;
 272 
 273   g_return_if_fail (object != NULL);
 274   g_return_if_fail (GST_MINI_OBJECT_IS_LOCKABLE (object));
 275 
 276   do {
 277     access_mode = flags &amp; FLAG_MASK;
 278     newstate = state = g_atomic_int_get (&amp;object-&gt;lockstate);
 279 
 280     GST_CAT_TRACE (GST_CAT_LOCKING, &quot;unlock %p: state %08x, access_mode %d&quot;,
 281         object, state, access_mode);
 282 
 283     if (access_mode &amp; GST_LOCK_FLAG_EXCLUSIVE) {
 284       /* shared counter */
 285       g_return_if_fail (state &gt;= SHARE_ONE);
 286       newstate -= SHARE_ONE;
 287       access_mode &amp;= ~GST_LOCK_FLAG_EXCLUSIVE;
 288     }
 289 
 290     if (access_mode) {
 291       g_return_if_fail ((state &amp; access_mode) == access_mode);
 292       /* decrease the refcount */
 293       newstate -= LOCK_ONE;
 294       /* last refcount, unset access_mode */
 295       if ((newstate &amp; LOCK_FLAG_MASK) == access_mode)
 296         newstate &amp;= ~LOCK_FLAG_MASK;
 297     }
 298   } while (!g_atomic_int_compare_and_exchange (&amp;object-&gt;lockstate, state,
 299           newstate));
 300 }
 301 
<a name="7" id="anc7"></a><span class="line-added"> 302 /* Locks the priv pointer and sets the priv uint to PRIV_DATA_STATE_LOCKED,</span>
<span class="line-added"> 303  * unless the full struct was already stored in the priv pointer.</span>
<span class="line-added"> 304  *</span>
<span class="line-added"> 305  * Returns the previous state of the priv uint</span>
<span class="line-added"> 306  */</span>
<span class="line-added"> 307 static guint</span>
<span class="line-added"> 308 lock_priv_pointer (GstMiniObject * object)</span>
<span class="line-added"> 309 {</span>
<span class="line-added"> 310   gint priv_state = g_atomic_int_get ((gint *) &amp; object-&gt;priv_uint);</span>
<span class="line-added"> 311 </span>
<span class="line-added"> 312   if (priv_state != PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added"> 313     /* As long as the struct was not allocated yet and either someone else</span>
<span class="line-added"> 314      * locked it or our priv_state is out of date, try to lock it */</span>
<span class="line-added"> 315     while (priv_state != PRIV_DATA_STATE_PARENTS_OR_QDATA &amp;&amp;</span>
<span class="line-added"> 316         (priv_state == PRIV_DATA_STATE_LOCKED ||</span>
<span class="line-added"> 317             !g_atomic_int_compare_and_exchange ((gint *) &amp; object-&gt;priv_uint,</span>
<span class="line-added"> 318                 priv_state, PRIV_DATA_STATE_LOCKED)))</span>
<span class="line-added"> 319       priv_state = g_atomic_int_get ((gint *) &amp; object-&gt;priv_uint);</span>
<span class="line-added"> 320 </span>
<span class="line-added"> 321     /* Note that if we got the full struct, we did not store</span>
<span class="line-added"> 322      * PRIV_DATA_STATE_LOCKED and did not actually lock the priv pointer */</span>
<span class="line-added"> 323   }</span>
<span class="line-added"> 324 </span>
<span class="line-added"> 325   return priv_state;</span>
<span class="line-added"> 326 }</span>
<span class="line-added"> 327 </span>
 328 /**
 329  * gst_mini_object_is_writable:
 330  * @mini_object: the mini-object to check
 331  *
 332  * If @mini_object has the LOCKABLE flag set, check if the current EXCLUSIVE
 333  * lock on @object is the only one, this means that changes to the object will
 334  * not be visible to any other object.
 335  *
 336  * If the LOCKABLE flag is not set, check if the refcount of @mini_object is
 337  * exactly 1, meaning that no other reference exists to the object and that the
 338  * object is therefore writable.
 339  *
 340  * Modification of a mini-object should only be done after verifying that it
 341  * is writable.
 342  *
 343  * Returns: %TRUE if the object is writable.
 344  */
 345 gboolean
 346 gst_mini_object_is_writable (const GstMiniObject * mini_object)
 347 {
 348   gboolean result;
<a name="8" id="anc8"></a><span class="line-added"> 349   gint priv_state;</span>
 350 
 351   g_return_val_if_fail (mini_object != NULL, FALSE);
 352 
<a name="9" id="anc9"></a><span class="line-added"> 353   /* Let&#39;s first check our own writability. If this already fails there&#39;s</span>
<span class="line-added"> 354    * no point in checking anything else */</span>
 355   if (GST_MINI_OBJECT_IS_LOCKABLE (mini_object)) {
 356     result = !IS_SHARED (g_atomic_int_get (&amp;mini_object-&gt;lockstate));
 357   } else {
 358     result = (GST_MINI_OBJECT_REFCOUNT_VALUE (mini_object) == 1);
 359   }
<a name="10" id="anc10"></a><span class="line-added"> 360   if (!result)</span>
<span class="line-added"> 361     return result;</span>
<span class="line-added"> 362 </span>
<span class="line-added"> 363   /* We are writable ourselves, but are there parents and are they all</span>
<span class="line-added"> 364    * writable too? */</span>
<span class="line-added"> 365   priv_state = lock_priv_pointer (GST_MINI_OBJECT_CAST (mini_object));</span>
<span class="line-added"> 366 </span>
<span class="line-added"> 367   /* Now we either have to check the full struct and all the</span>
<span class="line-added"> 368    * parents in there, or if there is exactly one parent we</span>
<span class="line-added"> 369    * can check that one */</span>
<span class="line-added"> 370   if (priv_state == PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added"> 371     PrivData *priv_data = mini_object-&gt;priv_pointer;</span>
<span class="line-added"> 372 </span>
<span class="line-added"> 373     /* Lock parents */</span>
<span class="line-added"> 374     while (!g_atomic_int_compare_and_exchange (&amp;priv_data-&gt;parent_lock, 0, 1));</span>
<span class="line-added"> 375 </span>
<span class="line-added"> 376     /* If we have one parent, we&#39;re only writable if that parent is writable.</span>
<span class="line-added"> 377      * Otherwise if we have multiple parents we are not writable, and if</span>
<span class="line-added"> 378      * we have no parent, we are writable */</span>
<span class="line-added"> 379     if (priv_data-&gt;n_parents == 1)</span>
<span class="line-added"> 380       result = gst_mini_object_is_writable (priv_data-&gt;parents[0]);</span>
<span class="line-added"> 381     else if (priv_data-&gt;n_parents == 0)</span>
<span class="line-added"> 382       result = TRUE;</span>
<span class="line-added"> 383     else</span>
<span class="line-added"> 384       result = FALSE;</span>
<span class="line-added"> 385 </span>
<span class="line-added"> 386     /* Unlock again */</span>
<span class="line-added"> 387     g_atomic_int_set (&amp;priv_data-&gt;parent_lock, 0);</span>
<span class="line-added"> 388   } else {</span>
<span class="line-added"> 389     if (priv_state == PRIV_DATA_STATE_ONE_PARENT) {</span>
<span class="line-added"> 390       result = gst_mini_object_is_writable (mini_object-&gt;priv_pointer);</span>
<span class="line-added"> 391     } else {</span>
<span class="line-added"> 392       g_assert (priv_state == PRIV_DATA_STATE_NO_PARENT);</span>
<span class="line-added"> 393       result = TRUE;</span>
<span class="line-added"> 394     }</span>
<span class="line-added"> 395 </span>
<span class="line-added"> 396     /* Unlock again */</span>
<span class="line-added"> 397     g_atomic_int_set ((gint *) &amp; mini_object-&gt;priv_uint, priv_state);</span>
<span class="line-added"> 398   }</span>
<span class="line-added"> 399 </span>
 400   return result;
 401 }
 402 
 403 /**
 404  * gst_mini_object_make_writable: (skip)
 405  * @mini_object: (transfer full): the mini-object to make writable
 406  *
 407  * Checks if a mini-object is writable.  If not, a writable copy is made and
 408  * returned.  This gives away the reference to the original mini object,
 409  * and returns a reference to the new object.
 410  *
 411  * MT safe
 412  *
 413  * Returns: (transfer full): a mini-object (possibly the same pointer) that
 414  *     is writable.
 415  */
 416 GstMiniObject *
 417 gst_mini_object_make_writable (GstMiniObject * mini_object)
 418 {
 419   GstMiniObject *ret;
 420 
 421   g_return_val_if_fail (mini_object != NULL, NULL);
 422 
 423   if (gst_mini_object_is_writable (mini_object)) {
 424     ret = mini_object;
 425   } else {
 426     ret = gst_mini_object_copy (mini_object);
 427     GST_CAT_DEBUG (GST_CAT_PERFORMANCE, &quot;copy %s miniobject %p -&gt; %p&quot;,
 428         g_type_name (GST_MINI_OBJECT_TYPE (mini_object)), mini_object, ret);
 429     gst_mini_object_unref (mini_object);
 430   }
 431 
 432   return ret;
 433 }
 434 
 435 /**
 436  * gst_mini_object_ref: (skip)
 437  * @mini_object: the mini-object
 438  *
 439  * Increase the reference count of the mini-object.
 440  *
 441  * Note that the refcount affects the writability
 442  * of @mini-object, see gst_mini_object_is_writable(). It is
 443  * important to note that keeping additional references to
 444  * GstMiniObject instances can potentially increase the number
 445  * of memcpy operations in a pipeline, especially if the miniobject
 446  * is a #GstBuffer.
 447  *
 448  * Returns: (transfer full): the mini-object.
 449  */
 450 GstMiniObject *
 451 gst_mini_object_ref (GstMiniObject * mini_object)
 452 {
 453   gint old_refcount, new_refcount;
 454 
 455   g_return_val_if_fail (mini_object != NULL, NULL);
 456   /* we can&#39;t assert that the refcount &gt; 0 since the _free functions
<a name="11" id="anc11"></a><span class="line-modified"> 457    * increments the refcount from 0 to 1 again to allow resurrecting</span>
 458    * the object
 459    g_return_val_if_fail (mini_object-&gt;refcount &gt; 0, NULL);
 460    */
 461 
 462   old_refcount = g_atomic_int_add (&amp;mini_object-&gt;refcount, 1);
 463   new_refcount = old_refcount + 1;
 464 
 465   GST_CAT_TRACE (GST_CAT_REFCOUNTING, &quot;%p ref %d-&gt;%d&quot;, mini_object,
 466       old_refcount, new_refcount);
 467 
 468   GST_TRACER_MINI_OBJECT_REFFED (mini_object, new_refcount);
 469 
 470   return mini_object;
 471 }
 472 
<a name="12" id="anc12"></a><span class="line-added"> 473 /* Called with global qdata lock */</span>
 474 static gint
 475 find_notify (GstMiniObject * object, GQuark quark, gboolean match_notify,
 476     GstMiniObjectNotify notify, gpointer data)
 477 {
 478   guint i;
<a name="13" id="anc13"></a><span class="line-added"> 479   gint priv_state = g_atomic_int_get ((gint *) &amp; object-&gt;priv_uint);</span>
<span class="line-added"> 480   PrivData *priv_data;</span>
 481 
<a name="14" id="anc14"></a><span class="line-modified"> 482   if (priv_state != PRIV_DATA_STATE_PARENTS_OR_QDATA)</span>
<span class="line-modified"> 483     return -1;</span>
<span class="line-added"> 484 </span>
<span class="line-added"> 485   priv_data = object-&gt;priv_pointer;</span>
<span class="line-added"> 486 </span>
<span class="line-added"> 487   for (i = 0; i &lt; priv_data-&gt;n_qdata; i++) {</span>
<span class="line-added"> 488     if (QDATA_QUARK (priv_data, i) == quark) {</span>
 489       /* check if we need to match the callback too */
<a name="15" id="anc15"></a><span class="line-modified"> 490       if (!match_notify || (QDATA_NOTIFY (priv_data, i) == notify &amp;&amp;</span>
<span class="line-modified"> 491               QDATA_DATA (priv_data, i) == data))</span>
 492         return i;
 493     }
 494   }
 495   return -1;
 496 }
 497 
 498 static void
 499 remove_notify (GstMiniObject * object, gint index)
 500 {
<a name="16" id="anc16"></a><span class="line-added"> 501   gint priv_state = g_atomic_int_get ((gint *) &amp; object-&gt;priv_uint);</span>
<span class="line-added"> 502   PrivData *priv_data;</span>
<span class="line-added"> 503 </span>
<span class="line-added"> 504   g_assert (priv_state == PRIV_DATA_STATE_PARENTS_OR_QDATA);</span>
<span class="line-added"> 505   priv_data = object-&gt;priv_pointer;</span>
<span class="line-added"> 506 </span>
 507   /* remove item */
<a name="17" id="anc17"></a><span class="line-modified"> 508   priv_data-&gt;n_qdata--;</span>
<span class="line-added"> 509   if (priv_data-&gt;n_qdata == 0) {</span>
 510     /* we don&#39;t shrink but free when everything is gone */
<a name="18" id="anc18"></a><span class="line-modified"> 511     g_free (priv_data-&gt;qdata);</span>
<span class="line-modified"> 512     priv_data-&gt;qdata = NULL;</span>
<span class="line-modified"> 513     priv_data-&gt;n_qdata_len = 0;</span>
<span class="line-modified"> 514   } else if (index != priv_data-&gt;n_qdata) {</span>
<span class="line-added"> 515     QDATA (priv_data, index) = QDATA (priv_data, priv_data-&gt;n_qdata);</span>
<span class="line-added"> 516   }</span>
<span class="line-added"> 517 }</span>
<span class="line-added"> 518 </span>
<span class="line-added"> 519 /* Make sure we allocate the PrivData of this object if not happened yet */</span>
<span class="line-added"> 520 static void</span>
<span class="line-added"> 521 ensure_priv_data (GstMiniObject * object)</span>
<span class="line-added"> 522 {</span>
<span class="line-added"> 523   gint priv_state;</span>
<span class="line-added"> 524   PrivData *priv_data;</span>
<span class="line-added"> 525   GstMiniObject *parent = NULL;</span>
<span class="line-added"> 526 </span>
<span class="line-added"> 527   GST_CAT_DEBUG (GST_CAT_PERFORMANCE,</span>
<span class="line-added"> 528       &quot;allocating private data %s miniobject %p&quot;,</span>
<span class="line-added"> 529       g_type_name (GST_MINI_OBJECT_TYPE (object)), object);</span>
<span class="line-added"> 530 </span>
<span class="line-added"> 531   priv_state = lock_priv_pointer (object);</span>
<span class="line-added"> 532   if (priv_state == PRIV_DATA_STATE_PARENTS_OR_QDATA)</span>
<span class="line-added"> 533     return;</span>
<span class="line-added"> 534 </span>
<span class="line-added"> 535   /* Now we&#39;re either locked, or someone has already allocated the struct</span>
<span class="line-added"> 536    * before us and we can just go ahead</span>
<span class="line-added"> 537    *</span>
<span class="line-added"> 538    * Note: if someone else allocated it in the meantime, we don&#39;t have to</span>
<span class="line-added"> 539    * unlock as we didn&#39;t lock! */</span>
<span class="line-added"> 540   if (priv_state != PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added"> 541     if (priv_state == PRIV_DATA_STATE_ONE_PARENT)</span>
<span class="line-added"> 542       parent = object-&gt;priv_pointer;</span>
<span class="line-added"> 543 </span>
<span class="line-added"> 544     object-&gt;priv_pointer = priv_data = g_new0 (PrivData, 1);</span>
<span class="line-added"> 545 </span>
<span class="line-added"> 546     if (parent) {</span>
<span class="line-added"> 547       priv_data-&gt;parents = g_new (GstMiniObject *, 16);</span>
<span class="line-added"> 548       priv_data-&gt;n_parents_len = 16;</span>
<span class="line-added"> 549       priv_data-&gt;n_parents = 1;</span>
<span class="line-added"> 550       priv_data-&gt;parents[0] = parent;</span>
<span class="line-added"> 551     }</span>
<span class="line-added"> 552 </span>
<span class="line-added"> 553     /* Unlock */</span>
<span class="line-added"> 554     g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint,</span>
<span class="line-added"> 555         PRIV_DATA_STATE_PARENTS_OR_QDATA);</span>
<span class="line-added"> 556   }</span>
 557 }
 558 
 559 static void
 560 set_notify (GstMiniObject * object, gint index, GQuark quark,
 561     GstMiniObjectNotify notify, gpointer data, GDestroyNotify destroy)
 562 {
<a name="19" id="anc19"></a><span class="line-added"> 563   PrivData *priv_data;</span>
<span class="line-added"> 564 </span>
<span class="line-added"> 565   ensure_priv_data (object);</span>
<span class="line-added"> 566   priv_data = object-&gt;priv_pointer;</span>
<span class="line-added"> 567 </span>
 568   if (index == -1) {
 569     /* add item */
<a name="20" id="anc20"></a><span class="line-modified"> 570     index = priv_data-&gt;n_qdata++;</span>
<span class="line-modified"> 571     if (index &gt;= priv_data-&gt;n_qdata_len) {</span>
<span class="line-modified"> 572       priv_data-&gt;n_qdata_len *= 2;</span>
<span class="line-added"> 573       if (priv_data-&gt;n_qdata_len == 0)</span>
<span class="line-added"> 574         priv_data-&gt;n_qdata_len = 16;</span>
<span class="line-added"> 575 </span>
<span class="line-added"> 576       priv_data-&gt;qdata =</span>
<span class="line-added"> 577           g_realloc (priv_data-&gt;qdata,</span>
<span class="line-added"> 578           sizeof (GstQData) * priv_data-&gt;n_qdata_len);</span>
<span class="line-added"> 579     }</span>
 580   }
<a name="21" id="anc21"></a><span class="line-modified"> 581 </span>
<span class="line-modified"> 582   QDATA_QUARK (priv_data, index) = quark;</span>
<span class="line-modified"> 583   QDATA_NOTIFY (priv_data, index) = notify;</span>
<span class="line-modified"> 584   QDATA_DATA (priv_data, index) = data;</span>
<span class="line-added"> 585   QDATA_DESTROY (priv_data, index) = destroy;</span>
 586 }
 587 
 588 static void
<a name="22" id="anc22"></a><span class="line-modified"> 589 free_priv_data (GstMiniObject * obj)</span>
 590 {
 591   guint i;
<a name="23" id="anc23"></a><span class="line-added"> 592   gint priv_state = g_atomic_int_get ((gint *) &amp; obj-&gt;priv_uint);</span>
<span class="line-added"> 593   PrivData *priv_data;</span>
<span class="line-added"> 594 </span>
<span class="line-added"> 595   if (priv_state != PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added"> 596     if (priv_state == PRIV_DATA_STATE_LOCKED) {</span>
<span class="line-added"> 597       g_warning</span>
<span class="line-added"> 598           (&quot;%s: object finalizing but has locked private data (object:%p)&quot;,</span>
<span class="line-added"> 599           G_STRFUNC, obj);</span>
<span class="line-added"> 600     } else if (priv_state == PRIV_DATA_STATE_ONE_PARENT) {</span>
<span class="line-added"> 601       g_warning</span>
<span class="line-added"> 602           (&quot;%s: object finalizing but still has parent (object:%p, parent:%p)&quot;,</span>
<span class="line-added"> 603           G_STRFUNC, obj, obj-&gt;priv_pointer);</span>
<span class="line-added"> 604     }</span>
 605 
<a name="24" id="anc24"></a><span class="line-modified"> 606     return;</span>




 607   }
<a name="25" id="anc25"></a><span class="line-added"> 608 </span>
<span class="line-added"> 609   priv_data = obj-&gt;priv_pointer;</span>
<span class="line-added"> 610 </span>
<span class="line-added"> 611   for (i = 0; i &lt; priv_data-&gt;n_qdata; i++) {</span>
<span class="line-added"> 612     if (QDATA_QUARK (priv_data, i) == weak_ref_quark)</span>
<span class="line-added"> 613       QDATA_NOTIFY (priv_data, i) (QDATA_DATA (priv_data, i), obj);</span>
<span class="line-added"> 614     if (QDATA_DESTROY (priv_data, i))</span>
<span class="line-added"> 615       QDATA_DESTROY (priv_data, i) (QDATA_DATA (priv_data, i));</span>
<span class="line-added"> 616   }</span>
<span class="line-added"> 617   g_free (priv_data-&gt;qdata);</span>
<span class="line-added"> 618 </span>
<span class="line-added"> 619   if (priv_data-&gt;n_parents)</span>
<span class="line-added"> 620     g_warning (&quot;%s: object finalizing but still has %d parents (object:%p)&quot;,</span>
<span class="line-added"> 621         G_STRFUNC, priv_data-&gt;n_parents, obj);</span>
<span class="line-added"> 622   g_free (priv_data-&gt;parents);</span>
<span class="line-added"> 623 </span>
<span class="line-added"> 624   g_free (priv_data);</span>
 625 }
 626 
 627 /**
 628  * gst_mini_object_unref: (skip)
 629  * @mini_object: the mini-object
 630  *
 631  * Decreases the reference count of the mini-object, possibly freeing
 632  * the mini-object.
 633  */
 634 void
 635 gst_mini_object_unref (GstMiniObject * mini_object)
 636 {
 637   gint old_refcount, new_refcount;
 638 
 639   g_return_if_fail (mini_object != NULL);
 640   g_return_if_fail (GST_MINI_OBJECT_REFCOUNT_VALUE (mini_object) &gt; 0);
 641 
 642   old_refcount = g_atomic_int_add (&amp;mini_object-&gt;refcount, -1);
 643   new_refcount = old_refcount - 1;
 644 
 645   g_return_if_fail (old_refcount &gt; 0);
 646 
 647   GST_CAT_TRACE (GST_CAT_REFCOUNTING, &quot;%p unref %d-&gt;%d&quot;,
 648       mini_object, old_refcount, new_refcount);
 649 
 650   GST_TRACER_MINI_OBJECT_UNREFFED (mini_object, new_refcount);
 651 
 652   if (new_refcount == 0) {
 653     gboolean do_free;
 654 
 655     if (mini_object-&gt;dispose)
 656       do_free = mini_object-&gt;dispose (mini_object);
 657     else
 658       do_free = TRUE;
 659 
 660     /* if the subclass recycled the object (and returned FALSE) we don&#39;t
 661      * want to free the instance anymore */
 662     if (G_LIKELY (do_free)) {
 663       /* there should be no outstanding locks */
 664       g_return_if_fail ((g_atomic_int_get (&amp;mini_object-&gt;lockstate) &amp; LOCK_MASK)
 665           &lt; 4);
 666 
<a name="26" id="anc26"></a><span class="line-modified"> 667       free_priv_data (mini_object);</span>
<span class="line-modified"> 668 </span>


 669       GST_TRACER_MINI_OBJECT_DESTROYED (mini_object);
 670       if (mini_object-&gt;free)
 671         mini_object-&gt;free (mini_object);
 672     }
 673   }
 674 }
 675 
<a name="27" id="anc27"></a><span class="line-added"> 676 /**</span>
<span class="line-added"> 677  * gst_clear_mini_object: (skip)</span>
<span class="line-added"> 678  * @object_ptr: a pointer to a #GstMiniObject reference</span>
<span class="line-added"> 679  *</span>
<span class="line-added"> 680  * Clears a reference to a #GstMiniObject.</span>
<span class="line-added"> 681  *</span>
<span class="line-added"> 682  * @object_ptr must not be %NULL.</span>
<span class="line-added"> 683  *</span>
<span class="line-added"> 684  * If the reference is %NULL then this function does nothing.</span>
<span class="line-added"> 685  * Otherwise, the reference count of the object is decreased using</span>
<span class="line-added"> 686  * gst_mini_object_unref() and the pointer is set to %NULL.</span>
<span class="line-added"> 687  *</span>
<span class="line-added"> 688  * A macro is also included that allows this function to be used without</span>
<span class="line-added"> 689  * pointer casts.</span>
<span class="line-added"> 690  *</span>
<span class="line-added"> 691  * Since: 1.16</span>
<span class="line-added"> 692  **/</span>
<span class="line-added"> 693 #undef gst_clear_mini_object</span>
<span class="line-added"> 694 void</span>
<span class="line-added"> 695 gst_clear_mini_object (GstMiniObject ** object_ptr)</span>
<span class="line-added"> 696 {</span>
<span class="line-added"> 697   g_clear_pointer (object_ptr, gst_mini_object_unref);</span>
<span class="line-added"> 698 }</span>
<span class="line-added"> 699 </span>
 700 /**
 701  * gst_mini_object_replace:
 702  * @olddata: (inout) (transfer full) (nullable): pointer to a pointer to a
 703  *     mini-object to be replaced
 704  * @newdata: (allow-none): pointer to new mini-object
 705  *
 706  * Atomically modifies a pointer to point to a new mini-object.
 707  * The reference count of @olddata is decreased and the reference count of
 708  * @newdata is increased.
 709  *
 710  * Either @newdata and the value pointed to by @olddata may be %NULL.
 711  *
 712  * Returns: %TRUE if @newdata was different from @olddata
 713  */
 714 gboolean
 715 gst_mini_object_replace (GstMiniObject ** olddata, GstMiniObject * newdata)
 716 {
 717   GstMiniObject *olddata_val;
 718 
 719   g_return_val_if_fail (olddata != NULL, FALSE);
 720 
 721   GST_CAT_TRACE (GST_CAT_REFCOUNTING, &quot;replace %p (%d) with %p (%d)&quot;,
 722       *olddata, *olddata ? (*olddata)-&gt;refcount : 0,
 723       newdata, newdata ? newdata-&gt;refcount : 0);
 724 
 725   olddata_val = g_atomic_pointer_get ((gpointer *) olddata);
 726 
 727   if (G_UNLIKELY (olddata_val == newdata))
 728     return FALSE;
 729 
 730   if (newdata)
 731     gst_mini_object_ref (newdata);
 732 
 733   while (G_UNLIKELY (!g_atomic_pointer_compare_and_exchange ((gpointer *)
 734               olddata, olddata_val, newdata))) {
 735     olddata_val = g_atomic_pointer_get ((gpointer *) olddata);
 736     if (G_UNLIKELY (olddata_val == newdata))
 737       break;
 738   }
 739 
 740   if (olddata_val)
 741     gst_mini_object_unref (olddata_val);
 742 
 743   return olddata_val != newdata;
 744 }
 745 
 746 /**
 747  * gst_mini_object_steal: (skip)
 748  * @olddata: (inout) (transfer full): pointer to a pointer to a mini-object to
 749  *     be stolen
 750  *
 751  * Replace the current #GstMiniObject pointer to by @olddata with %NULL and
 752  * return the old value.
 753  *
 754  * Returns: (nullable): the #GstMiniObject at @oldata
 755  */
 756 GstMiniObject *
 757 gst_mini_object_steal (GstMiniObject ** olddata)
 758 {
 759   GstMiniObject *olddata_val;
 760 
 761   g_return_val_if_fail (olddata != NULL, NULL);
 762 
 763   GST_CAT_TRACE (GST_CAT_REFCOUNTING, &quot;steal %p (%d)&quot;,
 764       *olddata, *olddata ? (*olddata)-&gt;refcount : 0);
 765 
 766   do {
 767     olddata_val = g_atomic_pointer_get ((gpointer *) olddata);
 768     if (olddata_val == NULL)
 769       break;
 770   } while (G_UNLIKELY (!g_atomic_pointer_compare_and_exchange ((gpointer *)
 771               olddata, olddata_val, NULL)));
 772 
 773   return olddata_val;
 774 }
 775 
 776 /**
 777  * gst_mini_object_take:
 778  * @olddata: (inout) (transfer full): pointer to a pointer to a mini-object to
 779  *     be replaced
 780  * @newdata: pointer to new mini-object
 781  *
 782  * Modifies a pointer to point to a new mini-object. The modification
 783  * is done atomically. This version is similar to gst_mini_object_replace()
 784  * except that it does not increase the refcount of @newdata and thus
 785  * takes ownership of @newdata.
 786  *
 787  * Either @newdata and the value pointed to by @olddata may be %NULL.
 788  *
 789  * Returns: %TRUE if @newdata was different from @olddata
 790  */
 791 gboolean
 792 gst_mini_object_take (GstMiniObject ** olddata, GstMiniObject * newdata)
 793 {
 794   GstMiniObject *olddata_val;
 795 
 796   g_return_val_if_fail (olddata != NULL, FALSE);
 797 
 798   GST_CAT_TRACE (GST_CAT_REFCOUNTING, &quot;take %p (%d) with %p (%d)&quot;,
 799       *olddata, *olddata ? (*olddata)-&gt;refcount : 0,
 800       newdata, newdata ? newdata-&gt;refcount : 0);
 801 
 802   do {
 803     olddata_val = g_atomic_pointer_get ((gpointer *) olddata);
 804     if (G_UNLIKELY (olddata_val == newdata))
 805       break;
 806   } while (G_UNLIKELY (!g_atomic_pointer_compare_and_exchange ((gpointer *)
 807               olddata, olddata_val, newdata)));
 808 
 809   if (olddata_val)
 810     gst_mini_object_unref (olddata_val);
 811 
 812   return olddata_val != newdata;
 813 }
 814 
 815 /**
 816  * gst_mini_object_weak_ref: (skip)
 817  * @object: #GstMiniObject to reference weakly
 818  * @notify: callback to invoke before the mini object is freed
 819  * @data: extra data to pass to notify
 820  *
 821  * Adds a weak reference callback to a mini object. Weak references are
 822  * used for notification when a mini object is finalized. They are called
 823  * &quot;weak references&quot; because they allow you to safely hold a pointer
 824  * to the mini object without calling gst_mini_object_ref()
 825  * (gst_mini_object_ref() adds a strong reference, that is, forces the object
 826  * to stay alive).
 827  */
 828 void
 829 gst_mini_object_weak_ref (GstMiniObject * object,
 830     GstMiniObjectNotify notify, gpointer data)
 831 {
 832   g_return_if_fail (object != NULL);
 833   g_return_if_fail (notify != NULL);
 834   g_return_if_fail (GST_MINI_OBJECT_REFCOUNT_VALUE (object) &gt;= 1);
 835 
 836   G_LOCK (qdata_mutex);
 837   set_notify (object, -1, weak_ref_quark, notify, data, NULL);
 838   G_UNLOCK (qdata_mutex);
 839 }
 840 
 841 /**
 842  * gst_mini_object_weak_unref: (skip)
 843  * @object: #GstMiniObject to remove a weak reference from
 844  * @notify: callback to search for
 845  * @data: data to search for
 846  *
 847  * Removes a weak reference callback from a mini object.
 848  */
 849 void
 850 gst_mini_object_weak_unref (GstMiniObject * object,
 851     GstMiniObjectNotify notify, gpointer data)
 852 {
 853   gint i;
 854 
 855   g_return_if_fail (object != NULL);
 856   g_return_if_fail (notify != NULL);
 857 
 858   G_LOCK (qdata_mutex);
 859   if ((i = find_notify (object, weak_ref_quark, TRUE, notify, data)) != -1) {
 860     remove_notify (object, i);
 861   } else {
 862     g_warning (&quot;%s: couldn&#39;t find weak ref %p (object:%p data:%p)&quot;, G_STRFUNC,
 863         notify, object, data);
 864   }
 865   G_UNLOCK (qdata_mutex);
 866 }
 867 
 868 /**
 869  * gst_mini_object_set_qdata:
 870  * @object: a #GstMiniObject
 871  * @quark: A #GQuark, naming the user data pointer
 872  * @data: An opaque user data pointer
 873  * @destroy: Function to invoke with @data as argument, when @data
 874  *           needs to be freed
 875  *
 876  * This sets an opaque, named pointer on a miniobject.
 877  * The name is specified through a #GQuark (retrieved e.g. via
 878  * g_quark_from_static_string()), and the pointer
 879  * can be gotten back from the @object with gst_mini_object_get_qdata()
 880  * until the @object is disposed.
 881  * Setting a previously set user data pointer, overrides (frees)
 882  * the old pointer set, using %NULL as pointer essentially
 883  * removes the data stored.
 884  *
 885  * @destroy may be specified which is called with @data as argument
 886  * when the @object is disposed, or the data is being overwritten by
 887  * a call to gst_mini_object_set_qdata() with the same @quark.
 888  */
 889 void
 890 gst_mini_object_set_qdata (GstMiniObject * object, GQuark quark,
 891     gpointer data, GDestroyNotify destroy)
 892 {
 893   gint i;
 894   gpointer old_data = NULL;
 895   GDestroyNotify old_notify = NULL;
 896 
 897   g_return_if_fail (object != NULL);
 898   g_return_if_fail (quark &gt; 0);
 899 
 900   G_LOCK (qdata_mutex);
 901   if ((i = find_notify (object, quark, FALSE, NULL, NULL)) != -1) {
<a name="28" id="anc28"></a><span class="line-added"> 902     PrivData *priv_data = object-&gt;priv_pointer;</span>
 903 
<a name="29" id="anc29"></a><span class="line-modified"> 904     old_data = QDATA_DATA (priv_data, i);</span>
<span class="line-modified"> 905     old_notify = QDATA_DESTROY (priv_data, i);</span>
 906 
 907     if (data == NULL)
 908       remove_notify (object, i);
 909   }
 910   if (data != NULL)
 911     set_notify (object, i, quark, NULL, data, destroy);
 912   G_UNLOCK (qdata_mutex);
 913 
 914   if (old_notify)
 915     old_notify (old_data);
 916 }
 917 
 918 /**
 919  * gst_mini_object_get_qdata:
 920  * @object: The GstMiniObject to get a stored user data pointer from
 921  * @quark: A #GQuark, naming the user data pointer
 922  *
 923  * This function gets back user data pointers stored via
 924  * gst_mini_object_set_qdata().
 925  *
 926  * Returns: (transfer none) (nullable): The user data pointer set, or
 927  * %NULL
 928  */
 929 gpointer
 930 gst_mini_object_get_qdata (GstMiniObject * object, GQuark quark)
 931 {
 932   guint i;
 933   gpointer result;
 934 
 935   g_return_val_if_fail (object != NULL, NULL);
 936   g_return_val_if_fail (quark &gt; 0, NULL);
 937 
 938   G_LOCK (qdata_mutex);
<a name="30" id="anc30"></a><span class="line-modified"> 939   if ((i = find_notify (object, quark, FALSE, NULL, NULL)) != -1) {</span>
<span class="line-modified"> 940     PrivData *priv_data = object-&gt;priv_pointer;</span>
<span class="line-modified"> 941     result = QDATA_DATA (priv_data, i);</span>
<span class="line-added"> 942   } else {</span>
 943     result = NULL;
<a name="31" id="anc31"></a><span class="line-added"> 944   }</span>
 945   G_UNLOCK (qdata_mutex);
 946 
 947   return result;
 948 }
 949 
 950 /**
 951  * gst_mini_object_steal_qdata:
 952  * @object: The GstMiniObject to get a stored user data pointer from
 953  * @quark: A #GQuark, naming the user data pointer
 954  *
 955  * This function gets back user data pointers stored via gst_mini_object_set_qdata()
 956  * and removes the data from @object without invoking its destroy() function (if
 957  * any was set).
 958  *
 959  * Returns: (transfer full) (nullable): The user data pointer set, or
 960  * %NULL
 961  */
 962 gpointer
 963 gst_mini_object_steal_qdata (GstMiniObject * object, GQuark quark)
 964 {
 965   guint i;
 966   gpointer result;
 967 
 968   g_return_val_if_fail (object != NULL, NULL);
 969   g_return_val_if_fail (quark &gt; 0, NULL);
 970 
 971   G_LOCK (qdata_mutex);
 972   if ((i = find_notify (object, quark, FALSE, NULL, NULL)) != -1) {
<a name="32" id="anc32"></a><span class="line-modified"> 973     PrivData *priv_data = object-&gt;priv_pointer;</span>
<span class="line-added"> 974     result = QDATA_DATA (priv_data, i);</span>
 975     remove_notify (object, i);
 976   } else {
 977     result = NULL;
 978   }
 979   G_UNLOCK (qdata_mutex);
 980 
 981   return result;
 982 }
<a name="33" id="anc33"></a><span class="line-added"> 983 </span>
<span class="line-added"> 984 /**</span>
<span class="line-added"> 985  * gst_mini_object_add_parent:</span>
<span class="line-added"> 986  * @object: a #GstMiniObject</span>
<span class="line-added"> 987  * @parent: a parent #GstMiniObject</span>
<span class="line-added"> 988  *</span>
<span class="line-added"> 989  * This adds @parent as a parent for @object. Having one ore more parents affects the</span>
<span class="line-added"> 990  * writability of @object: if a @parent is not writable, @object is also not</span>
<span class="line-added"> 991  * writable, regardless of its refcount. @object is only writable if all</span>
<span class="line-added"> 992  * the parents are writable and its own refcount is exactly 1.</span>
<span class="line-added"> 993  *</span>
<span class="line-added"> 994  * Note: This function does not take ownership of @parent and also does not</span>
<span class="line-added"> 995  * take an additional reference. It is the responsibility of the caller to</span>
<span class="line-added"> 996  * remove the parent again at a later time.</span>
<span class="line-added"> 997  *</span>
<span class="line-added"> 998  * Since: 1.16</span>
<span class="line-added"> 999  */</span>
<span class="line-added">1000 void</span>
<span class="line-added">1001 gst_mini_object_add_parent (GstMiniObject * object, GstMiniObject * parent)</span>
<span class="line-added">1002 {</span>
<span class="line-added">1003   gint priv_state;</span>
<span class="line-added">1004 </span>
<span class="line-added">1005   g_return_if_fail (object != NULL);</span>
<span class="line-added">1006 </span>
<span class="line-added">1007   GST_CAT_TRACE (GST_CAT_REFCOUNTING, &quot;adding parent %p to object %p&quot;, parent,</span>
<span class="line-added">1008       object);</span>
<span class="line-added">1009 </span>
<span class="line-added">1010   priv_state = lock_priv_pointer (object);</span>
<span class="line-added">1011   /* If we already had one parent, we need to allocate the full struct now */</span>
<span class="line-added">1012   if (priv_state == PRIV_DATA_STATE_ONE_PARENT) {</span>
<span class="line-added">1013     /* Unlock again */</span>
<span class="line-added">1014     g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint, priv_state);</span>
<span class="line-added">1015 </span>
<span class="line-added">1016     ensure_priv_data (object);</span>
<span class="line-added">1017     priv_state = PRIV_DATA_STATE_PARENTS_OR_QDATA;</span>
<span class="line-added">1018   }</span>
<span class="line-added">1019 </span>
<span class="line-added">1020   /* Now we either have to add the new parent to the full struct, or add</span>
<span class="line-added">1021    * our one and only parent to the pointer field */</span>
<span class="line-added">1022   if (priv_state == PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added">1023     PrivData *priv_data = object-&gt;priv_pointer;</span>
<span class="line-added">1024 </span>
<span class="line-added">1025     /* Lock parents */</span>
<span class="line-added">1026     while (!g_atomic_int_compare_and_exchange (&amp;priv_data-&gt;parent_lock, 0, 1));</span>
<span class="line-added">1027 </span>
<span class="line-added">1028     if (priv_data-&gt;n_parents &gt;= priv_data-&gt;n_parents_len) {</span>
<span class="line-added">1029       priv_data-&gt;n_parents_len *= 2;</span>
<span class="line-added">1030       if (priv_data-&gt;n_parents_len == 0)</span>
<span class="line-added">1031         priv_data-&gt;n_parents_len = 16;</span>
<span class="line-added">1032 </span>
<span class="line-added">1033       priv_data-&gt;parents =</span>
<span class="line-added">1034           g_realloc (priv_data-&gt;parents,</span>
<span class="line-added">1035           priv_data-&gt;n_parents_len * sizeof (GstMiniObject *));</span>
<span class="line-added">1036     }</span>
<span class="line-added">1037     priv_data-&gt;parents[priv_data-&gt;n_parents] = parent;</span>
<span class="line-added">1038     priv_data-&gt;n_parents++;</span>
<span class="line-added">1039 </span>
<span class="line-added">1040     /* Unlock again */</span>
<span class="line-added">1041     g_atomic_int_set (&amp;priv_data-&gt;parent_lock, 0);</span>
<span class="line-added">1042   } else if (priv_state == PRIV_DATA_STATE_NO_PARENT) {</span>
<span class="line-added">1043     object-&gt;priv_pointer = parent;</span>
<span class="line-added">1044 </span>
<span class="line-added">1045     /* Unlock again */</span>
<span class="line-added">1046     g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint, PRIV_DATA_STATE_ONE_PARENT);</span>
<span class="line-added">1047   } else {</span>
<span class="line-added">1048     g_assert_not_reached ();</span>
<span class="line-added">1049   }</span>
<span class="line-added">1050 }</span>
<span class="line-added">1051 </span>
<span class="line-added">1052 /**</span>
<span class="line-added">1053  * gst_mini_object_remove_parent:</span>
<span class="line-added">1054  * @object: a #GstMiniObject</span>
<span class="line-added">1055  * @parent: a parent #GstMiniObject</span>
<span class="line-added">1056  *</span>
<span class="line-added">1057  * This removes @parent as a parent for @object. See</span>
<span class="line-added">1058  * gst_mini_object_add_parent().</span>
<span class="line-added">1059  *</span>
<span class="line-added">1060  * Since: 1.16</span>
<span class="line-added">1061  */</span>
<span class="line-added">1062 void</span>
<span class="line-added">1063 gst_mini_object_remove_parent (GstMiniObject * object, GstMiniObject * parent)</span>
<span class="line-added">1064 {</span>
<span class="line-added">1065   gint priv_state;</span>
<span class="line-added">1066 </span>
<span class="line-added">1067   g_return_if_fail (object != NULL);</span>
<span class="line-added">1068 </span>
<span class="line-added">1069   GST_CAT_TRACE (GST_CAT_REFCOUNTING, &quot;removing parent %p from object %p&quot;,</span>
<span class="line-added">1070       parent, object);</span>
<span class="line-added">1071 </span>
<span class="line-added">1072   priv_state = lock_priv_pointer (object);</span>
<span class="line-added">1073 </span>
<span class="line-added">1074   /* Now we either have to add the new parent to the full struct, or add</span>
<span class="line-added">1075    * our one and only parent to the pointer field */</span>
<span class="line-added">1076   if (priv_state == PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added">1077     PrivData *priv_data = object-&gt;priv_pointer;</span>
<span class="line-added">1078     guint i;</span>
<span class="line-added">1079 </span>
<span class="line-added">1080     /* Lock parents */</span>
<span class="line-added">1081     while (!g_atomic_int_compare_and_exchange (&amp;priv_data-&gt;parent_lock, 0, 1));</span>
<span class="line-added">1082 </span>
<span class="line-added">1083     for (i = 0; i &lt; priv_data-&gt;n_parents; i++)</span>
<span class="line-added">1084       if (parent == priv_data-&gt;parents[i])</span>
<span class="line-added">1085         break;</span>
<span class="line-added">1086 </span>
<span class="line-added">1087     if (i != priv_data-&gt;n_parents) {</span>
<span class="line-added">1088       priv_data-&gt;n_parents--;</span>
<span class="line-added">1089       if (priv_data-&gt;n_parents != i)</span>
<span class="line-added">1090         priv_data-&gt;parents[i] = priv_data-&gt;parents[priv_data-&gt;n_parents];</span>
<span class="line-added">1091     } else {</span>
<span class="line-added">1092       g_warning (&quot;%s: couldn&#39;t find parent %p (object:%p)&quot;, G_STRFUNC,</span>
<span class="line-added">1093           object, parent);</span>
<span class="line-added">1094     }</span>
<span class="line-added">1095 </span>
<span class="line-added">1096     /* Unlock again */</span>
<span class="line-added">1097     g_atomic_int_set (&amp;priv_data-&gt;parent_lock, 0);</span>
<span class="line-added">1098   } else if (priv_state == PRIV_DATA_STATE_ONE_PARENT) {</span>
<span class="line-added">1099     if (object-&gt;priv_pointer != parent) {</span>
<span class="line-added">1100       g_warning (&quot;%s: couldn&#39;t find parent %p (object:%p)&quot;, G_STRFUNC,</span>
<span class="line-added">1101           object, parent);</span>
<span class="line-added">1102       /* Unlock again */</span>
<span class="line-added">1103       g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint, priv_state);</span>
<span class="line-added">1104     } else {</span>
<span class="line-added">1105       object-&gt;priv_pointer = NULL;</span>
<span class="line-added">1106       /* Unlock again */</span>
<span class="line-added">1107       g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint,</span>
<span class="line-added">1108           PRIV_DATA_STATE_NO_PARENT);</span>
<span class="line-added">1109     }</span>
<span class="line-added">1110   } else {</span>
<span class="line-added">1111     /* Unlock again */</span>
<span class="line-added">1112     g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint, PRIV_DATA_STATE_NO_PARENT);</span>
<span class="line-added">1113   }</span>
<span class="line-added">1114 }</span>
<a name="34" id="anc34"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="34" type="hidden" />
</body>
</html>