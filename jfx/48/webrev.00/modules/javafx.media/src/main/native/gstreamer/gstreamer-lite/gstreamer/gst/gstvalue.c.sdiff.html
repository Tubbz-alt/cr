<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstvalue.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstutils.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstvalue.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstvalue.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 204 {
 205   guint i;
 206   GArray *array = value-&gt;data[0].v_pointer;
 207   GString *s;
 208   GValue *v;
 209   gchar *s_val;
 210   guint alen = array-&gt;len;
 211 
 212   /* estimate minimum string length to minimise re-allocs in GString */
 213   s = g_string_sized_new (2 + (6 * alen) + 2);
 214   g_string_append (s, begin);
 215   for (i = 0; i &lt; alen; i++) {
 216     v = &amp;g_array_index (array, GValue, i);
 217     s_val = gst_value_serialize (v);
 218     if (s_val != NULL) {
 219       if (print_type) {
 220         g_string_append_c (s, &#39;(&#39;);
 221         g_string_append (s, _priv_gst_value_gtype_to_abbr (G_VALUE_TYPE (v)));
 222         g_string_append_c (s, &#39;)&#39;);
 223       }
<span class="line-modified"> 224     g_string_append (s, s_val);</span>
<span class="line-modified"> 225     g_free (s_val);</span>
<span class="line-modified"> 226     if (i &lt; alen - 1) {</span>
<span class="line-modified"> 227       g_string_append_len (s, &quot;, &quot;, 2);</span>
<span class="line-modified"> 228     }</span>
 229     } else {
 230       GST_WARNING (&quot;Could not serialize list/array value of type &#39;%s&#39;&quot;,
 231           G_VALUE_TYPE_NAME (v));
<span class="line-modified"> 232   }</span>
 233   }
 234   g_string_append (s, end);
 235   return g_string_free (s, FALSE);
 236 }
 237 
 238 static void
 239 gst_value_transform_any_list_string (const GValue * src_value,
 240     GValue * dest_value, const gchar * begin, const gchar * end)
 241 {
 242   GValue *list_value;
 243   GArray *array;
 244   GString *s;
 245   guint i;
 246   gchar *list_s;
 247   guint alen;
 248 
 249   array = src_value-&gt;data[0].v_pointer;
 250   alen = array-&gt;len;
 251 
 252   /* estimate minimum string length to minimise re-allocs in GString */
</pre>
<hr />
<pre>
1268  * gst_value_get_int_range_step:
1269  * @value: a GValue initialized to GST_TYPE_INT_RANGE
1270  *
1271  * Gets the step of the range specified by @value.
1272  *
1273  * Returns: the step of the range
1274  */
1275 gint
1276 gst_value_get_int_range_step (const GValue * value)
1277 {
1278   g_return_val_if_fail (GST_VALUE_HOLDS_INT_RANGE (value), 0);
1279 
1280   return INT_RANGE_STEP (value);
1281 }
1282 
1283 static void
1284 gst_value_transform_int_range_string (const GValue * src_value,
1285     GValue * dest_value)
1286 {
1287   if (INT_RANGE_STEP (src_value) == 1)
<span class="line-modified">1288   dest_value-&gt;data[0].v_pointer = g_strdup_printf (&quot;[%d,%d]&quot;,</span>
1289         INT_RANGE_MIN (src_value), INT_RANGE_MAX (src_value));
1290   else
1291     dest_value-&gt;data[0].v_pointer = g_strdup_printf (&quot;[%d,%d,%d]&quot;,
1292         INT_RANGE_MIN (src_value) * INT_RANGE_STEP (src_value),
1293         INT_RANGE_MAX (src_value) * INT_RANGE_STEP (src_value),
1294         INT_RANGE_STEP (src_value));
1295 }
1296 
1297 static gint
1298 gst_value_compare_int_range (const GValue * value1, const GValue * value2)
1299 {
1300   /* calculate the number of values in each range */
1301   gint n1 = INT_RANGE_MAX (value1) - INT_RANGE_MIN (value1) + 1;
1302   gint n2 = INT_RANGE_MAX (value2) - INT_RANGE_MIN (value2) + 1;
1303 
1304   /* they must be equal */
1305   if (n1 != n2)
1306     return GST_VALUE_UNORDERED;
1307 
1308   /* if empty, equal */
1309   if (n1 == 0)
1310     return GST_VALUE_EQUAL;
1311 
1312   /* if more than one value, then it is only equal if the step is equal
1313      and bounds lie on the same value */
1314   if (n1 &gt; 1) {
1315     if (INT_RANGE_STEP (value1) == INT_RANGE_STEP (value2) &amp;&amp;
1316         INT_RANGE_MIN (value1) == INT_RANGE_MIN (value2) &amp;&amp;
1317         INT_RANGE_MAX (value1) == INT_RANGE_MAX (value2)) {
1318       return GST_VALUE_EQUAL;
1319     }
<span class="line-modified">1320   return GST_VALUE_UNORDERED;</span>
1321   } else {
1322     /* if just one, only if the value is equal */
1323     if (INT_RANGE_MIN (value1) == INT_RANGE_MIN (value2))
1324       return GST_VALUE_EQUAL;
1325     return GST_VALUE_UNORDERED;
1326   }
1327 }
1328 
1329 static gchar *
1330 gst_value_serialize_int_range (const GValue * value)
1331 {
1332   if (INT_RANGE_STEP (value) == 1)
1333     return g_strdup_printf (&quot;[ %d, %d ]&quot;, INT_RANGE_MIN (value),
1334         INT_RANGE_MAX (value));
1335   else
1336     return g_strdup_printf (&quot;[ %d, %d, %d ]&quot;,
1337         INT_RANGE_MIN (value) * INT_RANGE_STEP (value),
1338         INT_RANGE_MAX (value) * INT_RANGE_STEP (value), INT_RANGE_STEP (value));
1339 }
1340 
</pre>
<hr />
<pre>
1520  * gst_value_get_int64_range_step:
1521  * @value: a GValue initialized to GST_TYPE_INT64_RANGE
1522  *
1523  * Gets the step of the range specified by @value.
1524  *
1525  * Returns: the step of the range
1526  */
1527 gint64
1528 gst_value_get_int64_range_step (const GValue * value)
1529 {
1530   g_return_val_if_fail (GST_VALUE_HOLDS_INT64_RANGE (value), 0);
1531 
1532   return INT64_RANGE_STEP (value);
1533 }
1534 
1535 static void
1536 gst_value_transform_int64_range_string (const GValue * src_value,
1537     GValue * dest_value)
1538 {
1539   if (INT64_RANGE_STEP (src_value) == 1)
<span class="line-modified">1540   dest_value-&gt;data[0].v_pointer =</span>
<span class="line-modified">1541       g_strdup_printf (&quot;(gint64)[%&quot; G_GINT64_FORMAT &quot;,%&quot; G_GINT64_FORMAT &quot;]&quot;,</span>
1542         INT64_RANGE_MIN (src_value), INT64_RANGE_MAX (src_value));
1543   else
1544     dest_value-&gt;data[0].v_pointer =
1545         g_strdup_printf (&quot;(gint64)[%&quot; G_GINT64_FORMAT &quot;,%&quot; G_GINT64_FORMAT
1546         &quot;,%&quot; G_GINT64_FORMAT &quot;]&quot;,
1547         INT64_RANGE_MIN (src_value) * INT64_RANGE_STEP (src_value),
1548         INT64_RANGE_MAX (src_value) * INT64_RANGE_STEP (src_value),
1549         INT64_RANGE_STEP (src_value));
1550 }
1551 
1552 static gint
1553 gst_value_compare_int64_range (const GValue * value1, const GValue * value2)
1554 {
1555   /* calculate the number of values in each range */
1556   gint64 n1 = INT64_RANGE_MAX (value1) - INT64_RANGE_MIN (value1) + 1;
1557   gint64 n2 = INT64_RANGE_MAX (value2) - INT64_RANGE_MIN (value2) + 1;
1558 
1559   /* they must be equal */
1560   if (n1 != n2)
1561     return GST_VALUE_UNORDERED;
1562 
1563   /* if empty, equal */
1564   if (n1 == 0)
1565     return GST_VALUE_EQUAL;
1566 
1567   /* if more than one value, then it is only equal if the step is equal
1568      and bounds lie on the same value */
1569   if (n1 &gt; 1) {
1570     if (INT64_RANGE_STEP (value1) == INT64_RANGE_STEP (value2) &amp;&amp;
1571         INT64_RANGE_MIN (value1) == INT64_RANGE_MIN (value2) &amp;&amp;
1572         INT64_RANGE_MAX (value1) == INT64_RANGE_MAX (value2)) {
1573       return GST_VALUE_EQUAL;
1574     }
<span class="line-modified">1575   return GST_VALUE_UNORDERED;</span>
1576   } else {
1577     /* if just one, only if the value is equal */
1578     if (INT64_RANGE_MIN (value1) == INT64_RANGE_MIN (value2))
1579       return GST_VALUE_EQUAL;
1580     return GST_VALUE_UNORDERED;
1581   }
1582 }
1583 
1584 static gchar *
1585 gst_value_serialize_int64_range (const GValue * value)
1586 {
1587   if (INT64_RANGE_STEP (value) == 1)
<span class="line-modified">1588   return g_strdup_printf (&quot;[ %&quot; G_GINT64_FORMAT &quot;, %&quot; G_GINT64_FORMAT &quot; ]&quot;,</span>
1589         INT64_RANGE_MIN (value), INT64_RANGE_MAX (value));
1590   else
1591     return g_strdup_printf (&quot;[ %&quot; G_GINT64_FORMAT &quot;, %&quot; G_GINT64_FORMAT &quot;, %&quot;
1592         G_GINT64_FORMAT &quot; ]&quot;,
1593         INT64_RANGE_MIN (value) * INT64_RANGE_STEP (value),
1594         INT64_RANGE_MAX (value) * INT64_RANGE_STEP (value),
1595         INT64_RANGE_STEP (value));
1596 }
1597 
1598 static gboolean
1599 gst_value_deserialize_int64_range (GValue * dest, const gchar * s)
1600 {
1601   g_warning (&quot;unimplemented&quot;);
1602   return FALSE;
1603 }
1604 
1605 /****************
1606  * double range *
1607  ****************/
1608 
</pre>
<hr />
<pre>
2090   GstCaps *caps2 = GST_CAPS (gst_value_get_caps (value2));
2091 
2092   if (gst_caps_is_equal (caps1, caps2))
2093     return GST_VALUE_EQUAL;
2094   return GST_VALUE_UNORDERED;
2095 }
2096 
2097 static gchar *
2098 gst_value_serialize_caps (const GValue * value)
2099 {
2100   GstCaps *caps = g_value_get_boxed (value);
2101   return priv_gst_string_take_and_wrap (gst_caps_to_string (caps));
2102 }
2103 
2104 static gboolean
2105 gst_value_deserialize_caps (GValue * dest, const gchar * s)
2106 {
2107   GstCaps *caps;
2108 
2109   if (*s != &#39;&quot;&#39;) {
<span class="line-modified">2110   caps = gst_caps_from_string (s);</span>
2111   } else {
2112     gchar *str = gst_string_unwrap (s);
2113 
2114     if (G_UNLIKELY (!str))
2115       return FALSE;
2116 
2117     caps = gst_caps_from_string (str);
2118     g_free (str);
2119   }
2120 
2121   if (caps) {
2122     g_value_take_boxed (dest, caps);
2123     return TRUE;
2124   }
2125   return FALSE;
2126 }
2127 
2128 /********************************************
2129  * Serialization/deserialization of GValues *
2130  ********************************************/
</pre>
<hr />
<pre>
2895 static gint
2896 compare_buffer (GstBuffer * buf1, GstBuffer * buf2)
2897 {
2898   gsize size1, size2;
2899   GstMapInfo info1, info2;
2900   gint result, mret;
2901 
2902   if (buf1 == buf2)
2903     return GST_VALUE_EQUAL;
2904 
2905   size1 = gst_buffer_get_size (buf1);
2906   size2 = gst_buffer_get_size (buf2);
2907 
2908   if (size1 != size2)
2909     return GST_VALUE_UNORDERED;
2910 
2911   if (size1 == 0)
2912     return GST_VALUE_EQUAL;
2913 
2914   if (!gst_buffer_map (buf1, &amp;info1, GST_MAP_READ))
<span class="line-modified">2915   return GST_VALUE_UNORDERED;</span>
2916 
2917   if (!gst_buffer_map (buf2, &amp;info2, GST_MAP_READ)) {
2918     gst_buffer_unmap (buf1, &amp;info1);
2919     return GST_VALUE_UNORDERED;
2920   }
2921 
2922   mret = memcmp (info1.data, info2.data, info1.size);
2923   if (mret == 0)
2924     result = GST_VALUE_EQUAL;
2925   else if (mret &lt; 0)
2926     result = GST_VALUE_LESS_THAN;
2927   else
2928     result = GST_VALUE_GREATER_THAN;
2929 
2930   gst_buffer_unmap (buf1, &amp;info1);
2931   gst_buffer_unmap (buf2, &amp;info2);
2932 
2933   return result;
2934 }
2935 
</pre>
<hr />
<pre>
3788         en = g_enum_get_value (klass, i);
3789       }
3790     }
3791   }
3792   g_type_class_unref (klass);
3793 
3794   /* might be one of the custom formats registered later */
3795   if (G_UNLIKELY (en == NULL &amp;&amp; G_VALUE_TYPE (dest) == GST_TYPE_FORMAT)) {
3796     GValue res = { 0, };
3797     const GstFormatDefinition *format_def;
3798     GstIterator *iter;
3799     gboolean found;
3800 
3801     iter = gst_format_iterate_definitions ();
3802 
3803     found = gst_iterator_find_custom (iter,
3804         (GCompareFunc) gst_value_deserialize_enum_iter_cmp, &amp;res, (gpointer) s);
3805 
3806     if (found) {
3807       format_def = g_value_get_pointer (&amp;res);
<span class="line-modified">3808     g_return_val_if_fail (format_def != NULL, FALSE);</span>
<span class="line-modified">3809     g_value_set_enum (dest, (gint) format_def-&gt;value);</span>
3810       g_value_unset (&amp;res);
3811     }
3812     gst_iterator_free (iter);
3813     return found;
3814   }
3815 
3816   /* enum name/nick not found */
3817   if (en == NULL)
3818     return FALSE;
3819 
3820   g_value_set_enum (dest, en-&gt;value);
3821   return TRUE;
3822 }
3823 
3824 /********
3825  * flags *
3826  ********/
3827 
3828 /* we just compare the value here */
3829 static gint
</pre>
<hr />
<pre>
3850 }
3851 
3852 /* the different flags are serialized separated with a + */
3853 static gchar *
3854 gst_value_serialize_gflags (const GValue * value)
3855 {
3856   guint flags;
3857   GFlagsValue *fl;
3858   GFlagsClass *klass = (GFlagsClass *) g_type_class_ref (G_VALUE_TYPE (value));
3859   gchar *result, *tmp;
3860   gboolean first = TRUE;
3861 
3862   g_return_val_if_fail (klass, NULL);
3863 
3864   flags = g_value_get_flags (value);
3865 
3866   /* if no flags are set, try to serialize to the _NONE string */
3867   if (!flags) {
3868     fl = g_flags_get_first_value (klass, flags);
3869     if (fl)
<span class="line-modified">3870     return g_strdup (fl-&gt;value_name);</span>
3871     else
3872       return g_strdup (&quot;0&quot;);
3873   }
3874 
3875   /* some flags are set, so serialize one by one */
3876   result = g_strdup (&quot;&quot;);
3877   while (flags) {
3878     fl = g_flags_get_first_value (klass, flags);
3879     if (fl != NULL) {
3880       tmp = g_strconcat (result, (first ? &quot;&quot; : &quot;+&quot;), fl-&gt;value_name, NULL);
3881       g_free (result);
3882       result = tmp;
3883       first = FALSE;
3884 
3885       /* clear flag */
3886       flags &amp;= ~fl-&gt;value;
3887     }
3888   }
3889   g_type_class_unref (klass);
3890 
</pre>
<hr />
<pre>
3904   guint mask = 0;
3905   guint val;
3906 
3907   g_return_val_if_fail (klass, FALSE);
3908 
3909   /* split into parts delimited with + or / and
3910    * compose the set of flags and mask. */
3911   pos = s;
3912 
3913   if (*pos == &#39;\0&#39;)
3914     goto done;                  /* Empty string, nothing to do */
3915 
3916   /* As a special case if the first char isn&#39;t a delimiter, assume
3917    * it&#39;s a &#39;+&#39; - for GFlags strings, which don&#39;t start with a
3918    * delimiter, while GFlagSet always will */
3919   if (*pos == &#39;/&#39; || *pos == &#39;+&#39;) {
3920     delimiter = *pos;
3921     pos++;
3922   } else {
3923     delimiter = &#39;+&#39;;
<span class="line-modified">3924         }</span>
3925 
3926   do {
3927     /* Find the next delimiter */
3928     next = pos;
3929     while (*next != &#39;\0&#39; &amp;&amp; *next != &#39;+&#39; &amp;&amp; *next != &#39;/&#39;)
3930       next++;
3931     cur_str = g_strndup (pos, next - pos);
3932 
3933     if ((fl = g_flags_get_value_by_name (klass, cur_str)))
3934       val = fl-&gt;value;
3935     else if ((fl = g_flags_get_value_by_nick (klass, cur_str)))
3936       val = fl-&gt;value;
3937     else {
3938       val = strtoul (cur_str, &amp;endptr, 0);
3939       /* direct numeric value */
3940       if (endptr == NULL || *endptr != &#39;\0&#39;) {
3941         g_free (cur_str);
3942         return FALSE;           /* Invalid numeric or string we can&#39;t convert */
3943       }
3944     }
</pre>
<hr />
<pre>
3946 
3947     if (val) {
3948       mask |= val;
3949       if (delimiter == &#39;+&#39;)
3950         flags |= val;
3951     }
3952 
3953     /* Advance to the next delimiter */
3954     pos = next;
3955     delimiter = *pos;
3956     pos++;
3957   } while (delimiter != &#39;\0&#39;);
3958 
3959 done:
3960   if (out_flags)
3961     *out_flags = flags;
3962   if (out_mask)
3963     *out_mask = mask;
3964 
3965   return TRUE;
<span class="line-modified">3966   }</span>
3967 
3968 
3969 static gboolean
3970 gst_value_deserialize_gflags (GValue * dest, const gchar * s)
3971 {
3972   GFlagsClass *klass = (GFlagsClass *) g_type_class_ref (G_VALUE_TYPE (dest));
3973   gboolean res = FALSE;
3974   guint flags = 0;
3975 
3976   if (gst_value_gflags_str_to_flags (klass, s, &amp;flags, NULL)) {
<span class="line-modified">3977   g_value_set_flags (dest, flags);</span>
3978     res = TRUE;
3979   }
3980 
3981   g_type_class_unref (klass);
3982 
3983   return res;
3984 }
3985 
3986 /*********
3987  * gtype *
3988  *********/
3989 
3990 static gint
3991 gst_value_compare_gtype (const GValue * value1, const GValue * value2)
3992 {
3993   if (value1-&gt;data[0].v_pointer == value2-&gt;data[0].v_pointer)
3994     return GST_VALUE_EQUAL;
3995   return GST_VALUE_UNORDERED;
3996 }
3997 
</pre>
<hr />
<pre>
4176     }
4177   }
4178   return FALSE;
4179 }
4180 
4181 /*********
4182  * union *
4183  *********/
4184 
4185 static gboolean
4186 gst_value_union_int_int_range (GValue * dest, const GValue * src1,
4187     const GValue * src2)
4188 {
4189   gint v = src1-&gt;data[0].v_int;
4190 
4191   /* check if it&#39;s already in the range */
4192   if (INT_RANGE_MIN (src2) * INT_RANGE_STEP (src2) &lt;= v &amp;&amp;
4193       INT_RANGE_MAX (src2) * INT_RANGE_STEP (src2) &gt;= v &amp;&amp;
4194       v % INT_RANGE_STEP (src2) == 0) {
4195     if (dest)
<span class="line-modified">4196     gst_value_init_and_copy (dest, src2);</span>
4197     return TRUE;
4198   }
4199 
4200   /* check if it extends the range */
4201   if (v == (INT_RANGE_MIN (src2) - 1) * INT_RANGE_STEP (src2)) {
4202     if (dest) {
4203       guint64 new_min = INT_RANGE_MIN (src2) - 1;
4204       guint64 new_max = INT_RANGE_MAX (src2);
4205 
4206       gst_value_init_and_copy (dest, src2);
4207       dest-&gt;data[0].v_uint64 = (new_min &lt;&lt; 32) | (new_max);
4208     }
4209     return TRUE;
4210   }
4211   if (v == (INT_RANGE_MAX (src2) + 1) * INT_RANGE_STEP (src2)) {
4212     if (dest) {
4213       guint64 new_min = INT_RANGE_MIN (src2);
4214       guint64 new_max = INT_RANGE_MAX (src2) + 1;
4215 
4216       gst_value_init_and_copy (dest, src2);
</pre>
<hr />
<pre>
4238     if (dest)
4239       gst_value_init_and_copy (dest, src2);
4240     return TRUE;
4241   }
4242   if (gst_value_is_subset_int_range_int_range (src2, src1)) {
4243     if (dest)
4244       gst_value_init_and_copy (dest, src1);
4245     return TRUE;
4246   }
4247 
4248   /* 2 - same step and not disjoint */
4249   if (INT_RANGE_STEP (src1) == INT_RANGE_STEP (src2)) {
4250     if ((INT_RANGE_MIN (src1) &lt;= INT_RANGE_MAX (src2) + 1 &amp;&amp;
4251             INT_RANGE_MAX (src1) &gt;= INT_RANGE_MIN (src2) - 1) ||
4252         (INT_RANGE_MIN (src2) &lt;= INT_RANGE_MAX (src1) + 1 &amp;&amp;
4253             INT_RANGE_MAX (src2) &gt;= INT_RANGE_MIN (src1) - 1)) {
4254       if (dest) {
4255         gint step = INT_RANGE_STEP (src1);
4256         gint min = step * MIN (INT_RANGE_MIN (src1), INT_RANGE_MIN (src2));
4257         gint max = step * MAX (INT_RANGE_MAX (src1), INT_RANGE_MAX (src2));
<span class="line-modified">4258     g_value_init (dest, GST_TYPE_INT_RANGE);</span>
4259         gst_value_set_int_range_step (dest, min, max, step);
4260       }
<span class="line-modified">4261     return TRUE;</span>
<span class="line-modified">4262   }</span>
4263   }
4264 
4265   /* 3 - single value matches next or previous */
4266   if (INT_RANGE_STEP (src1) != INT_RANGE_STEP (src2)) {
4267     gint n1 = INT_RANGE_MAX (src1) - INT_RANGE_MIN (src1) + 1;
4268     gint n2 = INT_RANGE_MAX (src2) - INT_RANGE_MIN (src2) + 1;
4269     if (n1 == 1 || n2 == 1) {
4270       const GValue *range_value = NULL;
4271       gint scalar = 0;
4272       if (n1 == 1) {
4273         range_value = src2;
4274         scalar = INT_RANGE_MIN (src1) * INT_RANGE_STEP (src1);
4275       } else if (n2 == 1) {
4276         range_value = src1;
4277         scalar = INT_RANGE_MIN (src2) * INT_RANGE_STEP (src2);
4278       }
4279 
4280       if (scalar ==
4281           (INT_RANGE_MIN (range_value) - 1) * INT_RANGE_STEP (range_value)) {
4282         if (dest) {
</pre>
<hr />
<pre>
4415     gst_value_set_structure (dest, result);
4416   }
4417 
4418 out:
4419   gst_structure_free (result);
4420   return ret;
4421 }
4422 
4423 /****************
4424  * intersection *
4425  ****************/
4426 
4427 static gboolean
4428 gst_value_intersect_int_int_range (GValue * dest, const GValue * src1,
4429     const GValue * src2)
4430 {
4431   if (INT_RANGE_MIN (src2) * INT_RANGE_STEP (src2) &lt;= src1-&gt;data[0].v_int &amp;&amp;
4432       INT_RANGE_MAX (src2) * INT_RANGE_STEP (src2) &gt;= src1-&gt;data[0].v_int &amp;&amp;
4433       src1-&gt;data[0].v_int % INT_RANGE_STEP (src2) == 0) {
4434     if (dest)
<span class="line-modified">4435     gst_value_init_and_copy (dest, src1);</span>
4436     return TRUE;
4437   }
4438 
4439   return FALSE;
4440 }
4441 
4442 static gboolean
4443 gst_value_intersect_int_range_int_range (GValue * dest, const GValue * src1,
4444     const GValue * src2)
4445 {
4446   gint min;
4447   gint max;
4448   gint step;
4449 
4450   step =
4451       INT_RANGE_STEP (src1) /
4452       gst_util_greatest_common_divisor (INT_RANGE_STEP (src1),
4453       INT_RANGE_STEP (src2));
4454   if (G_MAXINT32 / INT_RANGE_STEP (src2) &lt; step)
4455     return FALSE;
4456   step *= INT_RANGE_STEP (src2);
4457 
4458   min =
4459       MAX (INT_RANGE_MIN (src1) * INT_RANGE_STEP (src1),
4460       INT_RANGE_MIN (src2) * INT_RANGE_STEP (src2));
4461   min = (min + step - 1) / step * step;
4462   max =
4463       MIN (INT_RANGE_MAX (src1) * INT_RANGE_STEP (src1),
4464       INT_RANGE_MAX (src2) * INT_RANGE_STEP (src2));
4465   max = max / step * step;
4466 
4467   if (min &lt; max) {
4468     if (dest) {
<span class="line-modified">4469     g_value_init (dest, GST_TYPE_INT_RANGE);</span>
4470       gst_value_set_int_range_step (dest, min, max, step);
4471     }
4472     return TRUE;
4473   }
4474   if (min == max) {
4475     if (dest) {
<span class="line-modified">4476     g_value_init (dest, G_TYPE_INT);</span>
<span class="line-modified">4477     g_value_set_int (dest, min);</span>
4478     }
4479     return TRUE;
4480   }
4481 
4482   return FALSE;
4483 }
4484 
4485 #define INT64_RANGE_MIN_VAL(v) (INT64_RANGE_MIN (v) * INT64_RANGE_STEP (v))
4486 #define INT64_RANGE_MAX_VAL(v) (INT64_RANGE_MAX (v) * INT64_RANGE_STEP (v))
4487 
4488 static gboolean
4489 gst_value_intersect_int64_int64_range (GValue * dest, const GValue * src1,
4490     const GValue * src2)
4491 {
4492   if (INT64_RANGE_MIN_VAL (src2) &lt;= src1-&gt;data[0].v_int64 &amp;&amp;
4493       INT64_RANGE_MAX_VAL (src2) &gt;= src1-&gt;data[0].v_int64 &amp;&amp;
4494       src1-&gt;data[0].v_int64 % INT64_RANGE_STEP (src2) == 0) {
4495     if (dest)
<span class="line-modified">4496     gst_value_init_and_copy (dest, src1);</span>
4497     return TRUE;
4498   }
4499 
4500   return FALSE;
4501 }
4502 
4503 static gboolean
4504 gst_value_intersect_int64_range_int64_range (GValue * dest, const GValue * src1,
4505     const GValue * src2)
4506 {
4507   gint64 min;
4508   gint64 max;
4509   gint64 step;
4510 
4511   step =
4512       INT64_RANGE_STEP (src1) /
4513       gst_util_greatest_common_divisor_int64 (INT64_RANGE_STEP (src1),
4514       INT64_RANGE_STEP (src2));
4515   if (G_MAXINT64 / INT64_RANGE_STEP (src2) &lt; step)
4516     return FALSE;
4517   step *= INT64_RANGE_STEP (src2);
4518 
4519   min =
4520       MAX (INT64_RANGE_MIN (src1) * INT64_RANGE_STEP (src1),
4521       INT64_RANGE_MIN (src2) * INT64_RANGE_STEP (src2));
4522   min = (min + step - 1) / step * step;
4523   max =
4524       MIN (INT64_RANGE_MAX (src1) * INT64_RANGE_STEP (src1),
4525       INT64_RANGE_MAX (src2) * INT64_RANGE_STEP (src2));
4526   max = max / step * step;
4527 
4528   if (min &lt; max) {
4529     if (dest) {
<span class="line-modified">4530     g_value_init (dest, GST_TYPE_INT64_RANGE);</span>
4531       gst_value_set_int64_range_step (dest, min, max, step);
4532     }
4533     return TRUE;
4534   }
4535   if (min == max) {
4536     if (dest) {
<span class="line-modified">4537     g_value_init (dest, G_TYPE_INT64);</span>
<span class="line-modified">4538     g_value_set_int64 (dest, min);</span>
4539     }
4540     return TRUE;
4541   }
4542 
4543   return FALSE;
4544 }
4545 
4546 static gboolean
4547 gst_value_intersect_double_double_range (GValue * dest, const GValue * src1,
4548     const GValue * src2)
4549 {
4550   if (src2-&gt;data[0].v_double &lt;= src1-&gt;data[0].v_double &amp;&amp;
4551       src2-&gt;data[1].v_double &gt;= src1-&gt;data[0].v_double) {
4552     if (dest)
<span class="line-modified">4553     gst_value_init_and_copy (dest, src1);</span>
4554     return TRUE;
4555   }
4556 
4557   return FALSE;
4558 }
4559 
4560 static gboolean
4561 gst_value_intersect_double_range_double_range (GValue * dest,
4562     const GValue * src1, const GValue * src2)
4563 {
4564   gdouble min;
4565   gdouble max;
4566 
4567   min = MAX (src1-&gt;data[0].v_double, src2-&gt;data[0].v_double);
4568   max = MIN (src1-&gt;data[1].v_double, src2-&gt;data[1].v_double);
4569 
4570   if (min &lt; max) {
4571     if (dest) {
<span class="line-modified">4572     g_value_init (dest, GST_TYPE_DOUBLE_RANGE);</span>
<span class="line-modified">4573     gst_value_set_double_range (dest, min, max);</span>
4574     }
4575     return TRUE;
4576   }
4577   if (min == max) {
4578     if (dest) {
<span class="line-modified">4579     g_value_init (dest, G_TYPE_DOUBLE);</span>
<span class="line-modified">4580     g_value_set_int (dest, (int) min);</span>
4581     }
4582     return TRUE;
4583   }
4584 
4585   return FALSE;
4586 }
4587 
4588 static gboolean
4589 gst_value_intersect_list (GValue * dest, const GValue * value1,
4590     const GValue * value2)
4591 {
4592   guint i, size;
4593   GValue intersection = { 0, };
4594   gboolean ret = FALSE;
4595 
4596   size = VALUE_LIST_SIZE (value1);
4597   for (i = 0; i &lt; size; i++) {
4598     const GValue *cur = VALUE_LIST_GET_VALUE (value1, i);
4599 
4600     /* quicker version when we don&#39;t need the resulting set */
</pre>
<hr />
<pre>
4602       if (gst_value_intersect (NULL, cur, value2)) {
4603         ret = TRUE;
4604         break;
4605       }
4606       continue;
4607     }
4608 
4609     if (gst_value_intersect (&amp;intersection, cur, value2)) {
4610       /* append value */
4611       if (!ret) {
4612         gst_value_move (dest, &amp;intersection);
4613         ret = TRUE;
4614       } else if (GST_VALUE_HOLDS_LIST (dest)) {
4615         _gst_value_list_append_and_take_value (dest, &amp;intersection);
4616       } else {
4617         GValue temp;
4618 
4619         gst_value_move (&amp;temp, dest);
4620         gst_value_list_merge (dest, &amp;temp, &amp;intersection);
4621         g_value_unset (&amp;temp);
<span class="line-modified">4622       g_value_unset (&amp;intersection);</span>

4623     }
4624   }
<span class="line-removed">4625   }</span>
4626 
4627   return ret;
4628 }
4629 
4630 static gboolean
4631 gst_value_intersect_array (GValue * dest, const GValue * src1,
4632     const GValue * src2)
4633 {
4634   guint size;
4635   guint n;
4636   GValue val = { 0 };
4637 
4638   /* only works on similar-sized arrays */
4639   size = gst_value_array_get_size (src1);
4640   if (size != gst_value_array_get_size (src2))
4641     return FALSE;
4642 
4643   /* quicker value when we don&#39;t need the resulting set */
4644   if (!dest) {
4645     for (n = 0; n &lt; size; n++) {
</pre>
<hr />
<pre>
4668 static gboolean
4669 gst_value_intersect_fraction_fraction_range (GValue * dest, const GValue * src1,
4670     const GValue * src2)
4671 {
4672   gint res1, res2;
4673   GValue *vals;
4674   GstValueCompareFunc compare;
4675 
4676   vals = src2-&gt;data[0].v_pointer;
4677 
4678   if (vals == NULL)
4679     return FALSE;
4680 
4681   if ((compare = gst_value_get_compare_func (src1))) {
4682     res1 = gst_value_compare_with_func (&amp;vals[0], src1, compare);
4683     res2 = gst_value_compare_with_func (&amp;vals[1], src1, compare);
4684 
4685     if ((res1 == GST_VALUE_EQUAL || res1 == GST_VALUE_LESS_THAN) &amp;&amp;
4686         (res2 == GST_VALUE_EQUAL || res2 == GST_VALUE_GREATER_THAN)) {
4687       if (dest)
<span class="line-modified">4688       gst_value_init_and_copy (dest, src1);</span>
4689       return TRUE;
4690     }
4691   }
4692 
4693   return FALSE;
4694 }
4695 
4696 static gboolean
4697 gst_value_intersect_fraction_range_fraction_range (GValue * dest,
4698     const GValue * src1, const GValue * src2)
4699 {
4700   GValue *min;
4701   GValue *max;
4702   gint res;
4703   GValue *vals1, *vals2;
4704   GstValueCompareFunc compare;
4705 
4706   vals1 = src1-&gt;data[0].v_pointer;
4707   vals2 = src2-&gt;data[0].v_pointer;
4708   g_return_val_if_fail (vals1 != NULL &amp;&amp; vals2 != NULL, FALSE);
</pre>
<hr />
<pre>
4711     /* min = MAX (src1.start, src2.start) */
4712     res = gst_value_compare_with_func (&amp;vals1[0], &amp;vals2[0], compare);
4713     g_return_val_if_fail (res != GST_VALUE_UNORDERED, FALSE);
4714     if (res == GST_VALUE_LESS_THAN)
4715       min = &amp;vals2[0];          /* Take the max of the 2 */
4716     else
4717       min = &amp;vals1[0];
4718 
4719     /* max = MIN (src1.end, src2.end) */
4720     res = gst_value_compare_with_func (&amp;vals1[1], &amp;vals2[1], compare);
4721     g_return_val_if_fail (res != GST_VALUE_UNORDERED, FALSE);
4722     if (res == GST_VALUE_GREATER_THAN)
4723       max = &amp;vals2[1];          /* Take the min of the 2 */
4724     else
4725       max = &amp;vals1[1];
4726 
4727     res = gst_value_compare_with_func (min, max, compare);
4728     g_return_val_if_fail (res != GST_VALUE_UNORDERED, FALSE);
4729     if (res == GST_VALUE_LESS_THAN) {
4730       if (dest) {
<span class="line-modified">4731       g_value_init (dest, GST_TYPE_FRACTION_RANGE);</span>
<span class="line-modified">4732       vals1 = dest-&gt;data[0].v_pointer;</span>
<span class="line-modified">4733       g_value_copy (min, &amp;vals1[0]);</span>
<span class="line-modified">4734       g_value_copy (max, &amp;vals1[1]);</span>
4735       }
4736       return TRUE;
4737     }
4738     if (res == GST_VALUE_EQUAL) {
4739       if (dest)
<span class="line-modified">4740       gst_value_init_and_copy (dest, min);</span>
4741       return TRUE;
4742     }
4743   }
4744 
4745   return FALSE;
4746 }
4747 
4748 /* Two flagsets intersect if the masked bits in both
4749  * flagsets are exactly equal */
4750 static gboolean
4751 gst_value_intersect_flagset_flagset (GValue * dest,
4752     const GValue * src1, const GValue * src2)
4753 {
4754   guint f1, f2;
4755   guint m1, m2;
4756   GType type1, type2, flagset_type;
4757 
4758   g_return_val_if_fail (GST_VALUE_HOLDS_FLAG_SET (src1), FALSE);
4759   g_return_val_if_fail (GST_VALUE_HOLDS_FLAG_SET (src2), FALSE);
4760 
</pre>
<hr />
<pre>
4826  * subtraction *
4827  ***************/
4828 
4829 static gboolean
4830 gst_value_subtract_int_int_range (GValue * dest, const GValue * minuend,
4831     const GValue * subtrahend)
4832 {
4833   gint min = gst_value_get_int_range_min (subtrahend);
4834   gint max = gst_value_get_int_range_max (subtrahend);
4835   gint step = gst_value_get_int_range_step (subtrahend);
4836   gint val = g_value_get_int (minuend);
4837 
4838   if (step == 0)
4839     return FALSE;
4840 
4841   /* subtracting a range from an int only works if the int is not in the
4842    * range */
4843   if (val &lt; min || val &gt; max || val % step) {
4844     /* and the result is the int */
4845     if (dest)
<span class="line-modified">4846     gst_value_init_and_copy (dest, minuend);</span>
4847     return TRUE;
4848   }
4849   return FALSE;
4850 }
4851 
4852 /* creates a new int range based on input values.
4853  */
4854 static gboolean
4855 gst_value_create_new_range (GValue * dest, gint min1, gint max1, gint min2,
4856     gint max2, gint step)
4857 {
4858   GValue v1 = { 0, };
4859   GValue v2 = { 0, };
4860   GValue *pv1, *pv2;            /* yeah, hungarian! */
4861 
4862   g_return_val_if_fail (step &gt; 0, FALSE);
4863   g_return_val_if_fail (min1 % step == 0, FALSE);
4864   g_return_val_if_fail (max1 % step == 0, FALSE);
4865   g_return_val_if_fail (min2 % step == 0, FALSE);
4866   g_return_val_if_fail (max2 % step == 0, FALSE);
</pre>
<hr />
<pre>
4902   return TRUE;
4903 }
4904 
4905 static gboolean
4906 gst_value_subtract_int_range_int (GValue * dest, const GValue * minuend,
4907     const GValue * subtrahend)
4908 {
4909   gint min = gst_value_get_int_range_min (minuend);
4910   gint max = gst_value_get_int_range_max (minuend);
4911   gint step = gst_value_get_int_range_step (minuend);
4912   gint val = g_value_get_int (subtrahend);
4913 
4914   g_return_val_if_fail (min &lt; max, FALSE);
4915 
4916   if (step == 0)
4917     return FALSE;
4918 
4919   /* value is outside of the range, return range unchanged */
4920   if (val &lt; min || val &gt; max || val % step) {
4921     if (dest)
<span class="line-modified">4922     gst_value_init_and_copy (dest, minuend);</span>
4923     return TRUE;
4924   } else {
4925     /* max must be MAXINT too as val &lt;= max */
4926     if (val &gt;= G_MAXINT - step + 1) {
4927       max -= step;
4928       val -= step;
4929     }
4930     /* min must be MININT too as val &gt;= max */
4931     if (val &lt;= G_MININT + step - 1) {
4932       min += step;
4933       val += step;
4934     }
4935     if (dest)
4936       gst_value_create_new_range (dest, min, val - step, val + step, max, step);
4937   }
4938   return TRUE;
4939 }
4940 
4941 static gboolean
4942 gst_value_subtract_int_range_int_range (GValue * dest, const GValue * minuend,
</pre>
<hr />
<pre>
4973         MAX (max2 + step, min1), max1, step);
4974   }
4975 }
4976 
4977 static gboolean
4978 gst_value_subtract_int64_int64_range (GValue * dest, const GValue * minuend,
4979     const GValue * subtrahend)
4980 {
4981   gint64 min = gst_value_get_int64_range_min (subtrahend);
4982   gint64 max = gst_value_get_int64_range_max (subtrahend);
4983   gint64 step = gst_value_get_int64_range_step (subtrahend);
4984   gint64 val = g_value_get_int64 (minuend);
4985 
4986   if (step == 0)
4987     return FALSE;
4988   /* subtracting a range from an int64 only works if the int64 is not in the
4989    * range */
4990   if (val &lt; min || val &gt; max || val % step) {
4991     /* and the result is the int64 */
4992     if (dest)
<span class="line-modified">4993     gst_value_init_and_copy (dest, minuend);</span>
4994     return TRUE;
4995   }
4996   return FALSE;
4997 }
4998 
4999 /* creates a new int64 range based on input values.
5000  */
5001 static gboolean
5002 gst_value_create_new_int64_range (GValue * dest, gint64 min1, gint64 max1,
5003     gint64 min2, gint64 max2, gint64 step)
5004 {
5005   GValue v1 = { 0, };
5006   GValue v2 = { 0, };
5007   GValue *pv1, *pv2;            /* yeah, hungarian! */
5008 
5009   g_return_val_if_fail (step &gt; 0, FALSE);
5010   g_return_val_if_fail (min1 % step == 0, FALSE);
5011   g_return_val_if_fail (max1 % step == 0, FALSE);
5012   g_return_val_if_fail (min2 % step == 0, FALSE);
5013   g_return_val_if_fail (max2 % step == 0, FALSE);
</pre>
<hr />
<pre>
5049   return TRUE;
5050 }
5051 
5052 static gboolean
5053 gst_value_subtract_int64_range_int64 (GValue * dest, const GValue * minuend,
5054     const GValue * subtrahend)
5055 {
5056   gint64 min = gst_value_get_int64_range_min (minuend);
5057   gint64 max = gst_value_get_int64_range_max (minuend);
5058   gint64 step = gst_value_get_int64_range_step (minuend);
5059   gint64 val = g_value_get_int64 (subtrahend);
5060 
5061   g_return_val_if_fail (min &lt; max, FALSE);
5062 
5063   if (step == 0)
5064     return FALSE;
5065 
5066   /* value is outside of the range, return range unchanged */
5067   if (val &lt; min || val &gt; max || val % step) {
5068     if (dest)
<span class="line-modified">5069     gst_value_init_and_copy (dest, minuend);</span>
5070     return TRUE;
5071   } else {
5072     /* max must be MAXINT64 too as val &lt;= max */
5073     if (val &gt;= G_MAXINT64 - step + 1) {
5074       max -= step;
5075       val -= step;
5076     }
5077     /* min must be MININT64 too as val &gt;= max */
5078     if (val &lt;= G_MININT64 + step - 1) {
5079       min += step;
5080       val += step;
5081     }
5082     if (dest)
5083       gst_value_create_new_int64_range (dest, min, val - step, val + step, max,
5084           step);
5085   }
5086   return TRUE;
5087 }
5088 
5089 static gboolean
</pre>
<hr />
<pre>
5116             max1), step, 0, step);
5117   } else if (min2 &lt;= min1) {
5118     return gst_value_create_new_int64_range (dest, MAX (max2 + step, min1),
5119         max1, step, 0, step);
5120   } else {
5121     return gst_value_create_new_int64_range (dest, min1, MIN (min2 - step,
5122             max1), MAX (max2 + step, min1), max1, step);
5123   }
5124 }
5125 
5126 static gboolean
5127 gst_value_subtract_double_double_range (GValue * dest, const GValue * minuend,
5128     const GValue * subtrahend)
5129 {
5130   gdouble min = gst_value_get_double_range_min (subtrahend);
5131   gdouble max = gst_value_get_double_range_max (subtrahend);
5132   gdouble val = g_value_get_double (minuend);
5133 
5134   if (val &lt; min || val &gt; max) {
5135     if (dest)
<span class="line-modified">5136     gst_value_init_and_copy (dest, minuend);</span>
5137     return TRUE;
5138   }
5139   return FALSE;
5140 }
5141 
5142 static gboolean
5143 gst_value_subtract_double_range_double (GValue * dest, const GValue * minuend,
5144     const GValue * subtrahend)
5145 {
5146   /* since we don&#39;t have open ranges, we cannot create a hole in
5147    * a double range. We return the original range */
5148   if (dest)
<span class="line-modified">5149   gst_value_init_and_copy (dest, minuend);</span>
5150   return TRUE;
5151 }
5152 
5153 static gboolean
5154 gst_value_subtract_double_range_double_range (GValue * dest,
5155     const GValue * minuend, const GValue * subtrahend)
5156 {
5157   /* since we don&#39;t have open ranges, we have to approximate */
5158   /* done like with ints */
5159   gdouble min1 = gst_value_get_double_range_min (minuend);
5160   gdouble max2 = gst_value_get_double_range_max (minuend);
5161   gdouble max1 = MIN (gst_value_get_double_range_min (subtrahend), max2);
5162   gdouble min2 = MAX (gst_value_get_double_range_max (subtrahend), min1);
5163   GValue v1 = { 0, };
5164   GValue v2 = { 0, };
5165   GValue *pv1, *pv2;            /* yeah, hungarian! */
5166 
5167   if (min1 &lt; max1 &amp;&amp; min2 &lt; max2) {
5168     pv1 = &amp;v1;
5169     pv2 = &amp;v2;
</pre>
<hr />
<pre>
5244 
5245   gst_value_init_and_copy (result, minuend);
5246   size = VALUE_LIST_SIZE (subtrahend);
5247   for (i = 0; i &lt; size; i++) {
5248     const GValue *cur = VALUE_LIST_GET_VALUE (subtrahend, i);
5249 
5250     if (gst_value_subtract (subtraction, result, cur)) {
5251       GValue *temp = result;
5252 
5253       result = subtraction;
5254       subtraction = temp;
5255       g_value_unset (subtraction);
5256     } else {
5257       g_value_unset (result);
5258       return FALSE;
5259     }
5260   }
5261   if (dest) {
5262     gst_value_move (dest, result);
5263   } else {
<span class="line-modified">5264   g_value_unset (result);</span>
5265   }
5266   return TRUE;
5267 }
5268 
5269 static gboolean
5270 gst_value_subtract_fraction_fraction_range (GValue * dest,
5271     const GValue * minuend, const GValue * subtrahend)
5272 {
5273   const GValue *min = gst_value_get_fraction_range_min (subtrahend);
5274   const GValue *max = gst_value_get_fraction_range_max (subtrahend);
5275   GstValueCompareFunc compare;
5276 
5277   if ((compare = gst_value_get_compare_func (minuend))) {
5278     /* subtracting a range from an fraction only works if the fraction
5279      * is not in the range */
5280     if (gst_value_compare_with_func (minuend, min, compare) ==
5281         GST_VALUE_LESS_THAN ||
5282         gst_value_compare_with_func (minuend, max, compare) ==
5283         GST_VALUE_GREATER_THAN) {
5284       /* and the result is the value */
5285       if (dest)
<span class="line-modified">5286       gst_value_init_and_copy (dest, minuend);</span>
5287       return TRUE;
5288     }
5289   }
5290   return FALSE;
5291 }
5292 
5293 static gboolean
5294 gst_value_subtract_fraction_range_fraction (GValue * dest,
5295     const GValue * minuend, const GValue * subtrahend)
5296 {
5297   /* since we don&#39;t have open ranges, we cannot create a hole in
5298    * a range. We return the original range */
5299   if (dest)
<span class="line-modified">5300   gst_value_init_and_copy (dest, minuend);</span>
5301   return TRUE;
5302 }
5303 
5304 static gboolean
5305 gst_value_subtract_fraction_range_fraction_range (GValue * dest,
5306     const GValue * minuend, const GValue * subtrahend)
5307 {
5308   /* since we don&#39;t have open ranges, we have to approximate */
5309   /* done like with ints and doubles. Creates a list of 2 fraction ranges */
5310   const GValue *min1 = gst_value_get_fraction_range_min (minuend);
5311   const GValue *max2 = gst_value_get_fraction_range_max (minuend);
5312   const GValue *max1 = gst_value_get_fraction_range_min (subtrahend);
5313   const GValue *min2 = gst_value_get_fraction_range_max (subtrahend);
5314   gint cmp1, cmp2;
5315   GValue v1 = { 0, };
5316   GValue v2 = { 0, };
5317   GValue *pv1, *pv2;            /* yeah, hungarian! */
5318   GstValueCompareFunc compare;
5319 
5320   g_return_val_if_fail (min1 != NULL &amp;&amp; max1 != NULL, FALSE);
</pre>
<hr />
<pre>
5484     const gint64 rstep = gst_value_get_int64_range_step (value);
5485     GST_DEBUG (&quot;List/range of int64s&quot;);
5486     if (rstep == 0)
5487       return FALSE;
5488     if (list_size != rmax / rstep - rmin / rstep + 1)
5489       return FALSE;
5490     for (n = 0; n &lt; list_size; ++n) {
5491       gint64 v = g_value_get_int64 (VALUE_LIST_GET_VALUE (list, n));
5492       if (v &lt; rmin || v &gt; rmax || v % rstep)
5493         return FALSE;
5494     }
5495     return TRUE;
5496   }
5497 #undef CHECK_TYPES
5498 
5499   /* other combinations don&#39;t make sense for equality */
5500   return FALSE;
5501 }
5502 
5503 /* &quot;Pure&quot; variant of gst_value_compare which is guaranteed to
<span class="line-modified">5504  * not have list arguments and therefore does basic comparisions</span>
5505  */
5506 static inline gint
5507 _gst_value_compare_nolist (const GValue * value1, const GValue * value2)
5508 {
5509   GstValueCompareFunc compare;
5510 
5511   if (G_VALUE_TYPE (value1) != G_VALUE_TYPE (value2))
5512     return GST_VALUE_UNORDERED;
5513 
5514   compare = gst_value_get_compare_func (value1);
5515   if (compare) {
5516     return compare (value1, value2);
5517   }
5518 
5519   g_critical (&quot;unable to compare values of type %s\n&quot;,
5520       g_type_name (G_VALUE_TYPE (value1)));
5521   return GST_VALUE_UNORDERED;
5522 }
5523 
5524 /**
</pre>
<hr />
<pre>
5540   gboolean value1_is_list;
5541   gboolean value2_is_list;
5542 
5543   g_return_val_if_fail (G_IS_VALUE (value1), GST_VALUE_LESS_THAN);
5544   g_return_val_if_fail (G_IS_VALUE (value2), GST_VALUE_GREATER_THAN);
5545 
5546   value1_is_list = G_VALUE_TYPE (value1) == GST_TYPE_LIST;
5547   value2_is_list = G_VALUE_TYPE (value2) == GST_TYPE_LIST;
5548 
5549   /* Special cases: lists and scalar values (&quot;{ 1 }&quot; and &quot;1&quot; are equal),
5550      as well as lists and ranges (&quot;{ 1, 2 }&quot; and &quot;[ 1, 2 ]&quot; are equal) */
5551   if (value1_is_list &amp;&amp; !value2_is_list) {
5552     gint i, n, ret;
5553 
5554     if (gst_value_list_equals_range (value1, value2)) {
5555       return GST_VALUE_EQUAL;
5556     }
5557 
5558     n = gst_value_list_get_size (value1);
5559     if (n == 0)
<span class="line-modified">5560     return GST_VALUE_UNORDERED;</span>
5561 
5562     for (i = 0; i &lt; n; i++) {
5563       const GValue *elt;
5564 
5565       elt = gst_value_list_get_value (value1, i);
5566       ret = gst_value_compare (elt, value2);
5567       if (ret != GST_VALUE_EQUAL &amp;&amp; n == 1)
5568         return ret;
5569       else if (ret != GST_VALUE_EQUAL)
5570         return GST_VALUE_UNORDERED;
<span class="line-modified">5571   }</span>
5572 
5573     return GST_VALUE_EQUAL;
5574   } else if (value2_is_list &amp;&amp; !value1_is_list) {
5575     gint i, n, ret;
5576 
5577     if (gst_value_list_equals_range (value2, value1)) {
5578       return GST_VALUE_EQUAL;
5579     }
5580 
5581     n = gst_value_list_get_size (value2);
5582     if (n == 0)
<span class="line-modified">5583   return GST_VALUE_UNORDERED;</span>
5584 
5585     for (i = 0; i &lt; n; i++) {
5586       const GValue *elt;
5587 
5588       elt = gst_value_list_get_value (value2, i);
5589       ret = gst_value_compare (elt, value1);
5590       if (ret != GST_VALUE_EQUAL &amp;&amp; n == 1)
5591         return ret;
5592       else if (ret != GST_VALUE_EQUAL)
5593         return GST_VALUE_UNORDERED;
5594     }
5595 
5596     return GST_VALUE_EQUAL;
5597   }
5598 
5599   /* And now handle the generic case */
5600   return _gst_value_compare_nolist (value1, value2);
5601 }
5602 
5603 /*
</pre>
<hr />
<pre>
5680 gst_value_union (GValue * dest, const GValue * value1, const GValue * value2)
5681 {
5682   const GstValueUnionInfo *union_info;
5683   guint i, len;
5684   GType type1, type2;
5685 
5686   g_return_val_if_fail (dest != NULL, FALSE);
5687   g_return_val_if_fail (G_IS_VALUE (value1), FALSE);
5688   g_return_val_if_fail (G_IS_VALUE (value2), FALSE);
5689   g_return_val_if_fail (gst_value_list_or_array_are_compatible (value1, value2),
5690       FALSE);
5691 
5692   len = gst_value_union_funcs-&gt;len;
5693   type1 = G_VALUE_TYPE (value1);
5694   type2 = G_VALUE_TYPE (value2);
5695 
5696   for (i = 0; i &lt; len; i++) {
5697     union_info = &amp;g_array_index (gst_value_union_funcs, GstValueUnionInfo, i);
5698     if (union_info-&gt;type1 == type1 &amp;&amp; union_info-&gt;type2 == type2) {
5699       return union_info-&gt;func (dest, value1, value2);
<span class="line-modified">5700       }</span>
5701     if (union_info-&gt;type1 == type2 &amp;&amp; union_info-&gt;type2 == type1) {
5702       return union_info-&gt;func (dest, value2, value1);
5703     }
<span class="line-modified">5704       }</span>
5705 
5706   gst_value_list_concat (dest, value1, value2);
5707   return TRUE;
5708 }
5709 
5710 /* gst_value_register_union_func: (skip)
5711  * @type1: a type to union
5712  * @type2: another type to union
5713  * @func: a function that implements creating a union between the two types
5714  *
5715  * Registers a union function that can create a union between #GValue items
5716  * of the type @type1 and @type2.
5717  *
5718  * Union functions should be registered at startup before any pipelines are
5719  * started, as gst_value_register_union_func() is not thread-safe and cannot
5720  * be used at the same time as gst_value_union() or gst_value_can_union().
5721  */
5722 static void
5723 gst_value_register_union_func (GType type1, GType type2, GstValueUnionFunc func)
5724 {
</pre>
<hr />
<pre>
5814     const GValue * value2)
5815 {
5816   GstValueIntersectInfo *intersect_info;
5817   guint i, len;
5818   GType type1, type2;
5819 
5820   g_return_val_if_fail (G_IS_VALUE (value1), FALSE);
5821   g_return_val_if_fail (G_IS_VALUE (value2), FALSE);
5822 
5823   type1 = G_VALUE_TYPE (value1);
5824   type2 = G_VALUE_TYPE (value2);
5825 
5826   /* special cases first */
5827   if (type1 == GST_TYPE_LIST)
5828     return gst_value_intersect_list (dest, value1, value2);
5829   if (type2 == GST_TYPE_LIST)
5830     return gst_value_intersect_list (dest, value2, value1);
5831 
5832   if (_gst_value_compare_nolist (value1, value2) == GST_VALUE_EQUAL) {
5833     if (dest)
<span class="line-modified">5834     gst_value_init_and_copy (dest, value1);</span>
5835     return TRUE;
5836   }
5837 
5838   len = gst_value_intersect_funcs-&gt;len;
5839   for (i = 0; i &lt; len; i++) {
5840     intersect_info = &amp;g_array_index (gst_value_intersect_funcs,
5841         GstValueIntersectInfo, i);
5842     if (intersect_info-&gt;type1 == type1 &amp;&amp; intersect_info-&gt;type2 == type2) {
5843       return intersect_info-&gt;func (dest, value1, value2);
5844     }
5845     if (intersect_info-&gt;type1 == type2 &amp;&amp; intersect_info-&gt;type2 == type1) {
5846       return intersect_info-&gt;func (dest, value2, value1);
5847     }
5848   }
5849 
5850   /* Failed to find a direct intersection, check if these are
5851    * GstFlagSet sub-types. */
5852   if (G_UNLIKELY (GST_VALUE_HOLDS_FLAG_SET (value1) &amp;&amp;
5853           GST_VALUE_HOLDS_FLAG_SET (value2))) {
5854     return gst_value_intersect_flagset_flagset (dest, value1, value2);
</pre>
<hr />
<pre>
5915 
5916   mtype = G_VALUE_TYPE (minuend);
5917   stype = G_VALUE_TYPE (subtrahend);
5918 
5919   /* special cases first */
5920   if (mtype == GST_TYPE_LIST)
5921     return gst_value_subtract_from_list (dest, minuend, subtrahend);
5922   if (stype == GST_TYPE_LIST)
5923     return gst_value_subtract_list (dest, minuend, subtrahend);
5924 
5925   len = gst_value_subtract_funcs-&gt;len;
5926   for (i = 0; i &lt; len; i++) {
5927     info = &amp;g_array_index (gst_value_subtract_funcs, GstValueSubtractInfo, i);
5928     if (info-&gt;minuend == mtype &amp;&amp; info-&gt;subtrahend == stype) {
5929       return info-&gt;func (dest, minuend, subtrahend);
5930     }
5931   }
5932 
5933   if (_gst_value_compare_nolist (minuend, subtrahend) != GST_VALUE_EQUAL) {
5934     if (dest)
<span class="line-modified">5935     gst_value_init_and_copy (dest, minuend);</span>
5936     return TRUE;
5937   }
5938 
5939   return FALSE;
5940 }
5941 
5942 #if 0
5943 gboolean
5944 gst_value_subtract (GValue * dest, const GValue * minuend,
5945     const GValue * subtrahend)
5946 {
5947   gboolean ret = gst_value_subtract2 (dest, minuend, subtrahend);
5948 
5949   g_printerr (&quot;\&quot;%s\&quot;  -  \&quot;%s\&quot;  =  \&quot;%s\&quot;\n&quot;, gst_value_serialize (minuend),
5950       gst_value_serialize (subtrahend),
5951       ret ? gst_value_serialize (dest) : &quot;---&quot;);
5952   return ret;
5953 }
5954 #endif
5955 
</pre>
<hr />
<pre>
6768   GstDateTime *date = (GstDateTime *) g_value_get_boxed (val);
6769 
6770   if (date == NULL)
6771     return g_strdup (&quot;null&quot;);
6772 
6773   return __gst_date_time_serialize (date, TRUE);
6774 }
6775 
6776 static gboolean
6777 gst_value_deserialize_date_time (GValue * dest, const gchar * s)
6778 {
6779   GstDateTime *datetime;
6780 
6781   if (!s || strcmp (s, &quot;null&quot;) == 0) {
6782     return FALSE;
6783   }
6784 
6785   datetime = gst_date_time_new_from_iso8601_string (s);
6786   if (datetime != NULL) {
6787     g_value_take_boxed (dest, datetime);
<span class="line-modified">6788   return TRUE;</span>
6789   }
6790   GST_WARNING (&quot;Failed to deserialize date time string &#39;%s&#39;&quot;, s);
6791   return FALSE;
6792 }
6793 
6794 static void
6795 gst_value_transform_date_string (const GValue * src_value, GValue * dest_value)
6796 {
6797   dest_value-&gt;data[0].v_pointer = gst_value_serialize_date (src_value);
6798 }
6799 
6800 static void
6801 gst_value_transform_string_date (const GValue * src_value, GValue * dest_value)
6802 {
6803   gst_value_deserialize_date (dest_value, src_value-&gt;data[0].v_pointer);
6804 }
6805 
6806 
6807 /************
6808  * bitmask *
</pre>
<hr />
<pre>
7433   NULL,
7434   (char *) &quot;ii&quot;,
7435   gst_value_collect_fraction, (char *) &quot;pp&quot;, gst_value_lcopy_fraction
7436 };
7437 
7438 FUNC_VALUE_GET_TYPE (fraction, &quot;GstFraction&quot;);
7439 
7440 static const GTypeValueTable _gst_bitmask_value_table = {
7441   gst_value_init_bitmask,
7442   NULL,
7443   gst_value_copy_bitmask,
7444   NULL,
7445   (char *) &quot;q&quot;,
7446   gst_value_collect_bitmask, (char *) &quot;p&quot;, gst_value_lcopy_bitmask
7447 };
7448 
7449 FUNC_VALUE_GET_TYPE (bitmask, &quot;GstBitmask&quot;);
7450 
7451 static const GTypeValueTable _gst_flagset_value_table = {
7452   gst_value_init_flagset,
<span class="line-modified">7453       NULL,</span>
7454   gst_value_copy_flagset,
<span class="line-modified">7455       NULL,</span>
7456   (char *) &quot;ii&quot;,
7457   gst_value_collect_flagset, (char *) &quot;pp&quot;, gst_value_lcopy_flagset
<span class="line-modified">7458     };</span>
7459 
7460 FUNC_VALUE_GET_TYPE_CLASSED (flagset, &quot;GstFlagSet&quot;,
7461     sizeof (GstFlagSetClass), G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_DERIVABLE);
7462 
7463 GType
7464 gst_g_thread_get_type (void)
<span class="line-modified">7465   {</span>
7466   return G_TYPE_THREAD;
<span class="line-modified">7467   }</span>
7468 
7469 #define SERIAL_VTABLE(t,c,s,d) { t, c, s, d }
7470 
7471 #define REGISTER_SERIALIZATION_CONST(_gtype, _type)                     \
7472 G_STMT_START {                                                          \
7473   static const GstValueTable gst_value =                                \
7474     SERIAL_VTABLE (_gtype, gst_value_compare_ ## _type,                 \
7475     gst_value_serialize_ ## _type, gst_value_deserialize_ ## _type);    \
7476   gst_value_register (&amp;gst_value);                                      \
7477 } G_STMT_END
7478 
7479 #define REGISTER_SERIALIZATION(_gtype, _type)                           \
7480 G_STMT_START {                                                          \
7481   static GstValueTable gst_value =                                      \
7482     SERIAL_VTABLE (0, gst_value_compare_ ## _type,                      \
7483     gst_value_serialize_ ## _type, gst_value_deserialize_ ## _type);    \
7484   gst_value.type = _gtype;                                              \
7485   gst_value_register (&amp;gst_value);                                      \
7486 } G_STMT_END
7487 
</pre>
<hr />
<pre>
7496 
7497 #define REGISTER_SERIALIZATION_COMPARE_ONLY(_gtype, _type)              \
7498 G_STMT_START {                                                          \
7499   static GstValueTable gst_value =                                      \
7500     SERIAL_VTABLE (0, gst_value_compare_ ## _type,                      \
7501         NULL, NULL);                                                    \
7502   gst_value.type = _gtype;                                              \
7503   gst_value_register (&amp;gst_value);                                      \
7504 } G_STMT_END
7505 
7506 /* These initial sizes are used for the tables
7507  * below, and save a couple of reallocs at startup */
7508 
7509 static const gint GST_VALUE_TABLE_DEFAULT_SIZE = 40;
7510 static const gint GST_VALUE_UNION_TABLE_DEFAULT_SIZE = 8;
7511 static const gint GST_VALUE_INTERSECT_TABLE_DEFAULT_SIZE = 16;
7512 static const gint GST_VALUE_SUBTRACT_TABLE_DEFAULT_SIZE = 16;
7513 
7514 void
7515 _priv_gst_value_initialize (void)
<span class="line-modified">7516   {</span>
7517   gst_value_table =
7518       g_array_sized_new (FALSE, FALSE, sizeof (GstValueTable),
7519       GST_VALUE_TABLE_DEFAULT_SIZE);
7520   gst_value_hash = g_hash_table_new (NULL, NULL);
7521   gst_value_union_funcs = g_array_sized_new (FALSE, FALSE,
7522       sizeof (GstValueUnionInfo), GST_VALUE_UNION_TABLE_DEFAULT_SIZE);
7523   gst_value_intersect_funcs = g_array_sized_new (FALSE, FALSE,
7524       sizeof (GstValueIntersectInfo), GST_VALUE_INTERSECT_TABLE_DEFAULT_SIZE);
7525   gst_value_subtract_funcs = g_array_sized_new (FALSE, FALSE,
7526       sizeof (GstValueSubtractInfo), GST_VALUE_SUBTRACT_TABLE_DEFAULT_SIZE);
7527 
7528   REGISTER_SERIALIZATION (gst_int_range_get_type (), int_range);
7529   REGISTER_SERIALIZATION (gst_int64_range_get_type (), int64_range);
7530   REGISTER_SERIALIZATION (gst_double_range_get_type (), double_range);
7531   REGISTER_SERIALIZATION (gst_fraction_range_get_type (), fraction_range);
7532   REGISTER_SERIALIZATION (gst_value_list_get_type (), value_list);
7533   REGISTER_SERIALIZATION (gst_value_array_get_type (), value_array);
7534   REGISTER_SERIALIZATION (g_value_array_get_type (), g_value_array);
7535   REGISTER_SERIALIZATION (gst_buffer_get_type (), buffer);
7536   REGISTER_SERIALIZATION (gst_sample_get_type (), sample);
</pre>
</td>
<td>
<hr />
<pre>
 204 {
 205   guint i;
 206   GArray *array = value-&gt;data[0].v_pointer;
 207   GString *s;
 208   GValue *v;
 209   gchar *s_val;
 210   guint alen = array-&gt;len;
 211 
 212   /* estimate minimum string length to minimise re-allocs in GString */
 213   s = g_string_sized_new (2 + (6 * alen) + 2);
 214   g_string_append (s, begin);
 215   for (i = 0; i &lt; alen; i++) {
 216     v = &amp;g_array_index (array, GValue, i);
 217     s_val = gst_value_serialize (v);
 218     if (s_val != NULL) {
 219       if (print_type) {
 220         g_string_append_c (s, &#39;(&#39;);
 221         g_string_append (s, _priv_gst_value_gtype_to_abbr (G_VALUE_TYPE (v)));
 222         g_string_append_c (s, &#39;)&#39;);
 223       }
<span class="line-modified"> 224       g_string_append (s, s_val);</span>
<span class="line-modified"> 225       g_free (s_val);</span>
<span class="line-modified"> 226       if (i &lt; alen - 1) {</span>
<span class="line-modified"> 227         g_string_append_len (s, &quot;, &quot;, 2);</span>
<span class="line-modified"> 228       }</span>
 229     } else {
 230       GST_WARNING (&quot;Could not serialize list/array value of type &#39;%s&#39;&quot;,
 231           G_VALUE_TYPE_NAME (v));
<span class="line-modified"> 232     }</span>
 233   }
 234   g_string_append (s, end);
 235   return g_string_free (s, FALSE);
 236 }
 237 
 238 static void
 239 gst_value_transform_any_list_string (const GValue * src_value,
 240     GValue * dest_value, const gchar * begin, const gchar * end)
 241 {
 242   GValue *list_value;
 243   GArray *array;
 244   GString *s;
 245   guint i;
 246   gchar *list_s;
 247   guint alen;
 248 
 249   array = src_value-&gt;data[0].v_pointer;
 250   alen = array-&gt;len;
 251 
 252   /* estimate minimum string length to minimise re-allocs in GString */
</pre>
<hr />
<pre>
1268  * gst_value_get_int_range_step:
1269  * @value: a GValue initialized to GST_TYPE_INT_RANGE
1270  *
1271  * Gets the step of the range specified by @value.
1272  *
1273  * Returns: the step of the range
1274  */
1275 gint
1276 gst_value_get_int_range_step (const GValue * value)
1277 {
1278   g_return_val_if_fail (GST_VALUE_HOLDS_INT_RANGE (value), 0);
1279 
1280   return INT_RANGE_STEP (value);
1281 }
1282 
1283 static void
1284 gst_value_transform_int_range_string (const GValue * src_value,
1285     GValue * dest_value)
1286 {
1287   if (INT_RANGE_STEP (src_value) == 1)
<span class="line-modified">1288     dest_value-&gt;data[0].v_pointer = g_strdup_printf (&quot;[%d,%d]&quot;,</span>
1289         INT_RANGE_MIN (src_value), INT_RANGE_MAX (src_value));
1290   else
1291     dest_value-&gt;data[0].v_pointer = g_strdup_printf (&quot;[%d,%d,%d]&quot;,
1292         INT_RANGE_MIN (src_value) * INT_RANGE_STEP (src_value),
1293         INT_RANGE_MAX (src_value) * INT_RANGE_STEP (src_value),
1294         INT_RANGE_STEP (src_value));
1295 }
1296 
1297 static gint
1298 gst_value_compare_int_range (const GValue * value1, const GValue * value2)
1299 {
1300   /* calculate the number of values in each range */
1301   gint n1 = INT_RANGE_MAX (value1) - INT_RANGE_MIN (value1) + 1;
1302   gint n2 = INT_RANGE_MAX (value2) - INT_RANGE_MIN (value2) + 1;
1303 
1304   /* they must be equal */
1305   if (n1 != n2)
1306     return GST_VALUE_UNORDERED;
1307 
1308   /* if empty, equal */
1309   if (n1 == 0)
1310     return GST_VALUE_EQUAL;
1311 
1312   /* if more than one value, then it is only equal if the step is equal
1313      and bounds lie on the same value */
1314   if (n1 &gt; 1) {
1315     if (INT_RANGE_STEP (value1) == INT_RANGE_STEP (value2) &amp;&amp;
1316         INT_RANGE_MIN (value1) == INT_RANGE_MIN (value2) &amp;&amp;
1317         INT_RANGE_MAX (value1) == INT_RANGE_MAX (value2)) {
1318       return GST_VALUE_EQUAL;
1319     }
<span class="line-modified">1320     return GST_VALUE_UNORDERED;</span>
1321   } else {
1322     /* if just one, only if the value is equal */
1323     if (INT_RANGE_MIN (value1) == INT_RANGE_MIN (value2))
1324       return GST_VALUE_EQUAL;
1325     return GST_VALUE_UNORDERED;
1326   }
1327 }
1328 
1329 static gchar *
1330 gst_value_serialize_int_range (const GValue * value)
1331 {
1332   if (INT_RANGE_STEP (value) == 1)
1333     return g_strdup_printf (&quot;[ %d, %d ]&quot;, INT_RANGE_MIN (value),
1334         INT_RANGE_MAX (value));
1335   else
1336     return g_strdup_printf (&quot;[ %d, %d, %d ]&quot;,
1337         INT_RANGE_MIN (value) * INT_RANGE_STEP (value),
1338         INT_RANGE_MAX (value) * INT_RANGE_STEP (value), INT_RANGE_STEP (value));
1339 }
1340 
</pre>
<hr />
<pre>
1520  * gst_value_get_int64_range_step:
1521  * @value: a GValue initialized to GST_TYPE_INT64_RANGE
1522  *
1523  * Gets the step of the range specified by @value.
1524  *
1525  * Returns: the step of the range
1526  */
1527 gint64
1528 gst_value_get_int64_range_step (const GValue * value)
1529 {
1530   g_return_val_if_fail (GST_VALUE_HOLDS_INT64_RANGE (value), 0);
1531 
1532   return INT64_RANGE_STEP (value);
1533 }
1534 
1535 static void
1536 gst_value_transform_int64_range_string (const GValue * src_value,
1537     GValue * dest_value)
1538 {
1539   if (INT64_RANGE_STEP (src_value) == 1)
<span class="line-modified">1540     dest_value-&gt;data[0].v_pointer =</span>
<span class="line-modified">1541         g_strdup_printf (&quot;(gint64)[%&quot; G_GINT64_FORMAT &quot;,%&quot; G_GINT64_FORMAT &quot;]&quot;,</span>
1542         INT64_RANGE_MIN (src_value), INT64_RANGE_MAX (src_value));
1543   else
1544     dest_value-&gt;data[0].v_pointer =
1545         g_strdup_printf (&quot;(gint64)[%&quot; G_GINT64_FORMAT &quot;,%&quot; G_GINT64_FORMAT
1546         &quot;,%&quot; G_GINT64_FORMAT &quot;]&quot;,
1547         INT64_RANGE_MIN (src_value) * INT64_RANGE_STEP (src_value),
1548         INT64_RANGE_MAX (src_value) * INT64_RANGE_STEP (src_value),
1549         INT64_RANGE_STEP (src_value));
1550 }
1551 
1552 static gint
1553 gst_value_compare_int64_range (const GValue * value1, const GValue * value2)
1554 {
1555   /* calculate the number of values in each range */
1556   gint64 n1 = INT64_RANGE_MAX (value1) - INT64_RANGE_MIN (value1) + 1;
1557   gint64 n2 = INT64_RANGE_MAX (value2) - INT64_RANGE_MIN (value2) + 1;
1558 
1559   /* they must be equal */
1560   if (n1 != n2)
1561     return GST_VALUE_UNORDERED;
1562 
1563   /* if empty, equal */
1564   if (n1 == 0)
1565     return GST_VALUE_EQUAL;
1566 
1567   /* if more than one value, then it is only equal if the step is equal
1568      and bounds lie on the same value */
1569   if (n1 &gt; 1) {
1570     if (INT64_RANGE_STEP (value1) == INT64_RANGE_STEP (value2) &amp;&amp;
1571         INT64_RANGE_MIN (value1) == INT64_RANGE_MIN (value2) &amp;&amp;
1572         INT64_RANGE_MAX (value1) == INT64_RANGE_MAX (value2)) {
1573       return GST_VALUE_EQUAL;
1574     }
<span class="line-modified">1575     return GST_VALUE_UNORDERED;</span>
1576   } else {
1577     /* if just one, only if the value is equal */
1578     if (INT64_RANGE_MIN (value1) == INT64_RANGE_MIN (value2))
1579       return GST_VALUE_EQUAL;
1580     return GST_VALUE_UNORDERED;
1581   }
1582 }
1583 
1584 static gchar *
1585 gst_value_serialize_int64_range (const GValue * value)
1586 {
1587   if (INT64_RANGE_STEP (value) == 1)
<span class="line-modified">1588     return g_strdup_printf (&quot;[ %&quot; G_GINT64_FORMAT &quot;, %&quot; G_GINT64_FORMAT &quot; ]&quot;,</span>
1589         INT64_RANGE_MIN (value), INT64_RANGE_MAX (value));
1590   else
1591     return g_strdup_printf (&quot;[ %&quot; G_GINT64_FORMAT &quot;, %&quot; G_GINT64_FORMAT &quot;, %&quot;
1592         G_GINT64_FORMAT &quot; ]&quot;,
1593         INT64_RANGE_MIN (value) * INT64_RANGE_STEP (value),
1594         INT64_RANGE_MAX (value) * INT64_RANGE_STEP (value),
1595         INT64_RANGE_STEP (value));
1596 }
1597 
1598 static gboolean
1599 gst_value_deserialize_int64_range (GValue * dest, const gchar * s)
1600 {
1601   g_warning (&quot;unimplemented&quot;);
1602   return FALSE;
1603 }
1604 
1605 /****************
1606  * double range *
1607  ****************/
1608 
</pre>
<hr />
<pre>
2090   GstCaps *caps2 = GST_CAPS (gst_value_get_caps (value2));
2091 
2092   if (gst_caps_is_equal (caps1, caps2))
2093     return GST_VALUE_EQUAL;
2094   return GST_VALUE_UNORDERED;
2095 }
2096 
2097 static gchar *
2098 gst_value_serialize_caps (const GValue * value)
2099 {
2100   GstCaps *caps = g_value_get_boxed (value);
2101   return priv_gst_string_take_and_wrap (gst_caps_to_string (caps));
2102 }
2103 
2104 static gboolean
2105 gst_value_deserialize_caps (GValue * dest, const gchar * s)
2106 {
2107   GstCaps *caps;
2108 
2109   if (*s != &#39;&quot;&#39;) {
<span class="line-modified">2110     caps = gst_caps_from_string (s);</span>
2111   } else {
2112     gchar *str = gst_string_unwrap (s);
2113 
2114     if (G_UNLIKELY (!str))
2115       return FALSE;
2116 
2117     caps = gst_caps_from_string (str);
2118     g_free (str);
2119   }
2120 
2121   if (caps) {
2122     g_value_take_boxed (dest, caps);
2123     return TRUE;
2124   }
2125   return FALSE;
2126 }
2127 
2128 /********************************************
2129  * Serialization/deserialization of GValues *
2130  ********************************************/
</pre>
<hr />
<pre>
2895 static gint
2896 compare_buffer (GstBuffer * buf1, GstBuffer * buf2)
2897 {
2898   gsize size1, size2;
2899   GstMapInfo info1, info2;
2900   gint result, mret;
2901 
2902   if (buf1 == buf2)
2903     return GST_VALUE_EQUAL;
2904 
2905   size1 = gst_buffer_get_size (buf1);
2906   size2 = gst_buffer_get_size (buf2);
2907 
2908   if (size1 != size2)
2909     return GST_VALUE_UNORDERED;
2910 
2911   if (size1 == 0)
2912     return GST_VALUE_EQUAL;
2913 
2914   if (!gst_buffer_map (buf1, &amp;info1, GST_MAP_READ))
<span class="line-modified">2915     return GST_VALUE_UNORDERED;</span>
2916 
2917   if (!gst_buffer_map (buf2, &amp;info2, GST_MAP_READ)) {
2918     gst_buffer_unmap (buf1, &amp;info1);
2919     return GST_VALUE_UNORDERED;
2920   }
2921 
2922   mret = memcmp (info1.data, info2.data, info1.size);
2923   if (mret == 0)
2924     result = GST_VALUE_EQUAL;
2925   else if (mret &lt; 0)
2926     result = GST_VALUE_LESS_THAN;
2927   else
2928     result = GST_VALUE_GREATER_THAN;
2929 
2930   gst_buffer_unmap (buf1, &amp;info1);
2931   gst_buffer_unmap (buf2, &amp;info2);
2932 
2933   return result;
2934 }
2935 
</pre>
<hr />
<pre>
3788         en = g_enum_get_value (klass, i);
3789       }
3790     }
3791   }
3792   g_type_class_unref (klass);
3793 
3794   /* might be one of the custom formats registered later */
3795   if (G_UNLIKELY (en == NULL &amp;&amp; G_VALUE_TYPE (dest) == GST_TYPE_FORMAT)) {
3796     GValue res = { 0, };
3797     const GstFormatDefinition *format_def;
3798     GstIterator *iter;
3799     gboolean found;
3800 
3801     iter = gst_format_iterate_definitions ();
3802 
3803     found = gst_iterator_find_custom (iter,
3804         (GCompareFunc) gst_value_deserialize_enum_iter_cmp, &amp;res, (gpointer) s);
3805 
3806     if (found) {
3807       format_def = g_value_get_pointer (&amp;res);
<span class="line-modified">3808       g_return_val_if_fail (format_def != NULL, FALSE);</span>
<span class="line-modified">3809       g_value_set_enum (dest, (gint) format_def-&gt;value);</span>
3810       g_value_unset (&amp;res);
3811     }
3812     gst_iterator_free (iter);
3813     return found;
3814   }
3815 
3816   /* enum name/nick not found */
3817   if (en == NULL)
3818     return FALSE;
3819 
3820   g_value_set_enum (dest, en-&gt;value);
3821   return TRUE;
3822 }
3823 
3824 /********
3825  * flags *
3826  ********/
3827 
3828 /* we just compare the value here */
3829 static gint
</pre>
<hr />
<pre>
3850 }
3851 
3852 /* the different flags are serialized separated with a + */
3853 static gchar *
3854 gst_value_serialize_gflags (const GValue * value)
3855 {
3856   guint flags;
3857   GFlagsValue *fl;
3858   GFlagsClass *klass = (GFlagsClass *) g_type_class_ref (G_VALUE_TYPE (value));
3859   gchar *result, *tmp;
3860   gboolean first = TRUE;
3861 
3862   g_return_val_if_fail (klass, NULL);
3863 
3864   flags = g_value_get_flags (value);
3865 
3866   /* if no flags are set, try to serialize to the _NONE string */
3867   if (!flags) {
3868     fl = g_flags_get_first_value (klass, flags);
3869     if (fl)
<span class="line-modified">3870       return g_strdup (fl-&gt;value_name);</span>
3871     else
3872       return g_strdup (&quot;0&quot;);
3873   }
3874 
3875   /* some flags are set, so serialize one by one */
3876   result = g_strdup (&quot;&quot;);
3877   while (flags) {
3878     fl = g_flags_get_first_value (klass, flags);
3879     if (fl != NULL) {
3880       tmp = g_strconcat (result, (first ? &quot;&quot; : &quot;+&quot;), fl-&gt;value_name, NULL);
3881       g_free (result);
3882       result = tmp;
3883       first = FALSE;
3884 
3885       /* clear flag */
3886       flags &amp;= ~fl-&gt;value;
3887     }
3888   }
3889   g_type_class_unref (klass);
3890 
</pre>
<hr />
<pre>
3904   guint mask = 0;
3905   guint val;
3906 
3907   g_return_val_if_fail (klass, FALSE);
3908 
3909   /* split into parts delimited with + or / and
3910    * compose the set of flags and mask. */
3911   pos = s;
3912 
3913   if (*pos == &#39;\0&#39;)
3914     goto done;                  /* Empty string, nothing to do */
3915 
3916   /* As a special case if the first char isn&#39;t a delimiter, assume
3917    * it&#39;s a &#39;+&#39; - for GFlags strings, which don&#39;t start with a
3918    * delimiter, while GFlagSet always will */
3919   if (*pos == &#39;/&#39; || *pos == &#39;+&#39;) {
3920     delimiter = *pos;
3921     pos++;
3922   } else {
3923     delimiter = &#39;+&#39;;
<span class="line-modified">3924   }</span>
3925 
3926   do {
3927     /* Find the next delimiter */
3928     next = pos;
3929     while (*next != &#39;\0&#39; &amp;&amp; *next != &#39;+&#39; &amp;&amp; *next != &#39;/&#39;)
3930       next++;
3931     cur_str = g_strndup (pos, next - pos);
3932 
3933     if ((fl = g_flags_get_value_by_name (klass, cur_str)))
3934       val = fl-&gt;value;
3935     else if ((fl = g_flags_get_value_by_nick (klass, cur_str)))
3936       val = fl-&gt;value;
3937     else {
3938       val = strtoul (cur_str, &amp;endptr, 0);
3939       /* direct numeric value */
3940       if (endptr == NULL || *endptr != &#39;\0&#39;) {
3941         g_free (cur_str);
3942         return FALSE;           /* Invalid numeric or string we can&#39;t convert */
3943       }
3944     }
</pre>
<hr />
<pre>
3946 
3947     if (val) {
3948       mask |= val;
3949       if (delimiter == &#39;+&#39;)
3950         flags |= val;
3951     }
3952 
3953     /* Advance to the next delimiter */
3954     pos = next;
3955     delimiter = *pos;
3956     pos++;
3957   } while (delimiter != &#39;\0&#39;);
3958 
3959 done:
3960   if (out_flags)
3961     *out_flags = flags;
3962   if (out_mask)
3963     *out_mask = mask;
3964 
3965   return TRUE;
<span class="line-modified">3966 }</span>
3967 
3968 
3969 static gboolean
3970 gst_value_deserialize_gflags (GValue * dest, const gchar * s)
3971 {
3972   GFlagsClass *klass = (GFlagsClass *) g_type_class_ref (G_VALUE_TYPE (dest));
3973   gboolean res = FALSE;
3974   guint flags = 0;
3975 
3976   if (gst_value_gflags_str_to_flags (klass, s, &amp;flags, NULL)) {
<span class="line-modified">3977     g_value_set_flags (dest, flags);</span>
3978     res = TRUE;
3979   }
3980 
3981   g_type_class_unref (klass);
3982 
3983   return res;
3984 }
3985 
3986 /*********
3987  * gtype *
3988  *********/
3989 
3990 static gint
3991 gst_value_compare_gtype (const GValue * value1, const GValue * value2)
3992 {
3993   if (value1-&gt;data[0].v_pointer == value2-&gt;data[0].v_pointer)
3994     return GST_VALUE_EQUAL;
3995   return GST_VALUE_UNORDERED;
3996 }
3997 
</pre>
<hr />
<pre>
4176     }
4177   }
4178   return FALSE;
4179 }
4180 
4181 /*********
4182  * union *
4183  *********/
4184 
4185 static gboolean
4186 gst_value_union_int_int_range (GValue * dest, const GValue * src1,
4187     const GValue * src2)
4188 {
4189   gint v = src1-&gt;data[0].v_int;
4190 
4191   /* check if it&#39;s already in the range */
4192   if (INT_RANGE_MIN (src2) * INT_RANGE_STEP (src2) &lt;= v &amp;&amp;
4193       INT_RANGE_MAX (src2) * INT_RANGE_STEP (src2) &gt;= v &amp;&amp;
4194       v % INT_RANGE_STEP (src2) == 0) {
4195     if (dest)
<span class="line-modified">4196       gst_value_init_and_copy (dest, src2);</span>
4197     return TRUE;
4198   }
4199 
4200   /* check if it extends the range */
4201   if (v == (INT_RANGE_MIN (src2) - 1) * INT_RANGE_STEP (src2)) {
4202     if (dest) {
4203       guint64 new_min = INT_RANGE_MIN (src2) - 1;
4204       guint64 new_max = INT_RANGE_MAX (src2);
4205 
4206       gst_value_init_and_copy (dest, src2);
4207       dest-&gt;data[0].v_uint64 = (new_min &lt;&lt; 32) | (new_max);
4208     }
4209     return TRUE;
4210   }
4211   if (v == (INT_RANGE_MAX (src2) + 1) * INT_RANGE_STEP (src2)) {
4212     if (dest) {
4213       guint64 new_min = INT_RANGE_MIN (src2);
4214       guint64 new_max = INT_RANGE_MAX (src2) + 1;
4215 
4216       gst_value_init_and_copy (dest, src2);
</pre>
<hr />
<pre>
4238     if (dest)
4239       gst_value_init_and_copy (dest, src2);
4240     return TRUE;
4241   }
4242   if (gst_value_is_subset_int_range_int_range (src2, src1)) {
4243     if (dest)
4244       gst_value_init_and_copy (dest, src1);
4245     return TRUE;
4246   }
4247 
4248   /* 2 - same step and not disjoint */
4249   if (INT_RANGE_STEP (src1) == INT_RANGE_STEP (src2)) {
4250     if ((INT_RANGE_MIN (src1) &lt;= INT_RANGE_MAX (src2) + 1 &amp;&amp;
4251             INT_RANGE_MAX (src1) &gt;= INT_RANGE_MIN (src2) - 1) ||
4252         (INT_RANGE_MIN (src2) &lt;= INT_RANGE_MAX (src1) + 1 &amp;&amp;
4253             INT_RANGE_MAX (src2) &gt;= INT_RANGE_MIN (src1) - 1)) {
4254       if (dest) {
4255         gint step = INT_RANGE_STEP (src1);
4256         gint min = step * MIN (INT_RANGE_MIN (src1), INT_RANGE_MIN (src2));
4257         gint max = step * MAX (INT_RANGE_MAX (src1), INT_RANGE_MAX (src2));
<span class="line-modified">4258         g_value_init (dest, GST_TYPE_INT_RANGE);</span>
4259         gst_value_set_int_range_step (dest, min, max, step);
4260       }
<span class="line-modified">4261       return TRUE;</span>
<span class="line-modified">4262     }</span>
4263   }
4264 
4265   /* 3 - single value matches next or previous */
4266   if (INT_RANGE_STEP (src1) != INT_RANGE_STEP (src2)) {
4267     gint n1 = INT_RANGE_MAX (src1) - INT_RANGE_MIN (src1) + 1;
4268     gint n2 = INT_RANGE_MAX (src2) - INT_RANGE_MIN (src2) + 1;
4269     if (n1 == 1 || n2 == 1) {
4270       const GValue *range_value = NULL;
4271       gint scalar = 0;
4272       if (n1 == 1) {
4273         range_value = src2;
4274         scalar = INT_RANGE_MIN (src1) * INT_RANGE_STEP (src1);
4275       } else if (n2 == 1) {
4276         range_value = src1;
4277         scalar = INT_RANGE_MIN (src2) * INT_RANGE_STEP (src2);
4278       }
4279 
4280       if (scalar ==
4281           (INT_RANGE_MIN (range_value) - 1) * INT_RANGE_STEP (range_value)) {
4282         if (dest) {
</pre>
<hr />
<pre>
4415     gst_value_set_structure (dest, result);
4416   }
4417 
4418 out:
4419   gst_structure_free (result);
4420   return ret;
4421 }
4422 
4423 /****************
4424  * intersection *
4425  ****************/
4426 
4427 static gboolean
4428 gst_value_intersect_int_int_range (GValue * dest, const GValue * src1,
4429     const GValue * src2)
4430 {
4431   if (INT_RANGE_MIN (src2) * INT_RANGE_STEP (src2) &lt;= src1-&gt;data[0].v_int &amp;&amp;
4432       INT_RANGE_MAX (src2) * INT_RANGE_STEP (src2) &gt;= src1-&gt;data[0].v_int &amp;&amp;
4433       src1-&gt;data[0].v_int % INT_RANGE_STEP (src2) == 0) {
4434     if (dest)
<span class="line-modified">4435       gst_value_init_and_copy (dest, src1);</span>
4436     return TRUE;
4437   }
4438 
4439   return FALSE;
4440 }
4441 
4442 static gboolean
4443 gst_value_intersect_int_range_int_range (GValue * dest, const GValue * src1,
4444     const GValue * src2)
4445 {
4446   gint min;
4447   gint max;
4448   gint step;
4449 
4450   step =
4451       INT_RANGE_STEP (src1) /
4452       gst_util_greatest_common_divisor (INT_RANGE_STEP (src1),
4453       INT_RANGE_STEP (src2));
4454   if (G_MAXINT32 / INT_RANGE_STEP (src2) &lt; step)
4455     return FALSE;
4456   step *= INT_RANGE_STEP (src2);
4457 
4458   min =
4459       MAX (INT_RANGE_MIN (src1) * INT_RANGE_STEP (src1),
4460       INT_RANGE_MIN (src2) * INT_RANGE_STEP (src2));
4461   min = (min + step - 1) / step * step;
4462   max =
4463       MIN (INT_RANGE_MAX (src1) * INT_RANGE_STEP (src1),
4464       INT_RANGE_MAX (src2) * INT_RANGE_STEP (src2));
4465   max = max / step * step;
4466 
4467   if (min &lt; max) {
4468     if (dest) {
<span class="line-modified">4469       g_value_init (dest, GST_TYPE_INT_RANGE);</span>
4470       gst_value_set_int_range_step (dest, min, max, step);
4471     }
4472     return TRUE;
4473   }
4474   if (min == max) {
4475     if (dest) {
<span class="line-modified">4476       g_value_init (dest, G_TYPE_INT);</span>
<span class="line-modified">4477       g_value_set_int (dest, min);</span>
4478     }
4479     return TRUE;
4480   }
4481 
4482   return FALSE;
4483 }
4484 
4485 #define INT64_RANGE_MIN_VAL(v) (INT64_RANGE_MIN (v) * INT64_RANGE_STEP (v))
4486 #define INT64_RANGE_MAX_VAL(v) (INT64_RANGE_MAX (v) * INT64_RANGE_STEP (v))
4487 
4488 static gboolean
4489 gst_value_intersect_int64_int64_range (GValue * dest, const GValue * src1,
4490     const GValue * src2)
4491 {
4492   if (INT64_RANGE_MIN_VAL (src2) &lt;= src1-&gt;data[0].v_int64 &amp;&amp;
4493       INT64_RANGE_MAX_VAL (src2) &gt;= src1-&gt;data[0].v_int64 &amp;&amp;
4494       src1-&gt;data[0].v_int64 % INT64_RANGE_STEP (src2) == 0) {
4495     if (dest)
<span class="line-modified">4496       gst_value_init_and_copy (dest, src1);</span>
4497     return TRUE;
4498   }
4499 
4500   return FALSE;
4501 }
4502 
4503 static gboolean
4504 gst_value_intersect_int64_range_int64_range (GValue * dest, const GValue * src1,
4505     const GValue * src2)
4506 {
4507   gint64 min;
4508   gint64 max;
4509   gint64 step;
4510 
4511   step =
4512       INT64_RANGE_STEP (src1) /
4513       gst_util_greatest_common_divisor_int64 (INT64_RANGE_STEP (src1),
4514       INT64_RANGE_STEP (src2));
4515   if (G_MAXINT64 / INT64_RANGE_STEP (src2) &lt; step)
4516     return FALSE;
4517   step *= INT64_RANGE_STEP (src2);
4518 
4519   min =
4520       MAX (INT64_RANGE_MIN (src1) * INT64_RANGE_STEP (src1),
4521       INT64_RANGE_MIN (src2) * INT64_RANGE_STEP (src2));
4522   min = (min + step - 1) / step * step;
4523   max =
4524       MIN (INT64_RANGE_MAX (src1) * INT64_RANGE_STEP (src1),
4525       INT64_RANGE_MAX (src2) * INT64_RANGE_STEP (src2));
4526   max = max / step * step;
4527 
4528   if (min &lt; max) {
4529     if (dest) {
<span class="line-modified">4530       g_value_init (dest, GST_TYPE_INT64_RANGE);</span>
4531       gst_value_set_int64_range_step (dest, min, max, step);
4532     }
4533     return TRUE;
4534   }
4535   if (min == max) {
4536     if (dest) {
<span class="line-modified">4537       g_value_init (dest, G_TYPE_INT64);</span>
<span class="line-modified">4538       g_value_set_int64 (dest, min);</span>
4539     }
4540     return TRUE;
4541   }
4542 
4543   return FALSE;
4544 }
4545 
4546 static gboolean
4547 gst_value_intersect_double_double_range (GValue * dest, const GValue * src1,
4548     const GValue * src2)
4549 {
4550   if (src2-&gt;data[0].v_double &lt;= src1-&gt;data[0].v_double &amp;&amp;
4551       src2-&gt;data[1].v_double &gt;= src1-&gt;data[0].v_double) {
4552     if (dest)
<span class="line-modified">4553       gst_value_init_and_copy (dest, src1);</span>
4554     return TRUE;
4555   }
4556 
4557   return FALSE;
4558 }
4559 
4560 static gboolean
4561 gst_value_intersect_double_range_double_range (GValue * dest,
4562     const GValue * src1, const GValue * src2)
4563 {
4564   gdouble min;
4565   gdouble max;
4566 
4567   min = MAX (src1-&gt;data[0].v_double, src2-&gt;data[0].v_double);
4568   max = MIN (src1-&gt;data[1].v_double, src2-&gt;data[1].v_double);
4569 
4570   if (min &lt; max) {
4571     if (dest) {
<span class="line-modified">4572       g_value_init (dest, GST_TYPE_DOUBLE_RANGE);</span>
<span class="line-modified">4573       gst_value_set_double_range (dest, min, max);</span>
4574     }
4575     return TRUE;
4576   }
4577   if (min == max) {
4578     if (dest) {
<span class="line-modified">4579       g_value_init (dest, G_TYPE_DOUBLE);</span>
<span class="line-modified">4580       g_value_set_int (dest, (int) min);</span>
4581     }
4582     return TRUE;
4583   }
4584 
4585   return FALSE;
4586 }
4587 
4588 static gboolean
4589 gst_value_intersect_list (GValue * dest, const GValue * value1,
4590     const GValue * value2)
4591 {
4592   guint i, size;
4593   GValue intersection = { 0, };
4594   gboolean ret = FALSE;
4595 
4596   size = VALUE_LIST_SIZE (value1);
4597   for (i = 0; i &lt; size; i++) {
4598     const GValue *cur = VALUE_LIST_GET_VALUE (value1, i);
4599 
4600     /* quicker version when we don&#39;t need the resulting set */
</pre>
<hr />
<pre>
4602       if (gst_value_intersect (NULL, cur, value2)) {
4603         ret = TRUE;
4604         break;
4605       }
4606       continue;
4607     }
4608 
4609     if (gst_value_intersect (&amp;intersection, cur, value2)) {
4610       /* append value */
4611       if (!ret) {
4612         gst_value_move (dest, &amp;intersection);
4613         ret = TRUE;
4614       } else if (GST_VALUE_HOLDS_LIST (dest)) {
4615         _gst_value_list_append_and_take_value (dest, &amp;intersection);
4616       } else {
4617         GValue temp;
4618 
4619         gst_value_move (&amp;temp, dest);
4620         gst_value_list_merge (dest, &amp;temp, &amp;intersection);
4621         g_value_unset (&amp;temp);
<span class="line-modified">4622         g_value_unset (&amp;intersection);</span>
<span class="line-added">4623       }</span>
4624     }
4625   }

4626 
4627   return ret;
4628 }
4629 
4630 static gboolean
4631 gst_value_intersect_array (GValue * dest, const GValue * src1,
4632     const GValue * src2)
4633 {
4634   guint size;
4635   guint n;
4636   GValue val = { 0 };
4637 
4638   /* only works on similar-sized arrays */
4639   size = gst_value_array_get_size (src1);
4640   if (size != gst_value_array_get_size (src2))
4641     return FALSE;
4642 
4643   /* quicker value when we don&#39;t need the resulting set */
4644   if (!dest) {
4645     for (n = 0; n &lt; size; n++) {
</pre>
<hr />
<pre>
4668 static gboolean
4669 gst_value_intersect_fraction_fraction_range (GValue * dest, const GValue * src1,
4670     const GValue * src2)
4671 {
4672   gint res1, res2;
4673   GValue *vals;
4674   GstValueCompareFunc compare;
4675 
4676   vals = src2-&gt;data[0].v_pointer;
4677 
4678   if (vals == NULL)
4679     return FALSE;
4680 
4681   if ((compare = gst_value_get_compare_func (src1))) {
4682     res1 = gst_value_compare_with_func (&amp;vals[0], src1, compare);
4683     res2 = gst_value_compare_with_func (&amp;vals[1], src1, compare);
4684 
4685     if ((res1 == GST_VALUE_EQUAL || res1 == GST_VALUE_LESS_THAN) &amp;&amp;
4686         (res2 == GST_VALUE_EQUAL || res2 == GST_VALUE_GREATER_THAN)) {
4687       if (dest)
<span class="line-modified">4688         gst_value_init_and_copy (dest, src1);</span>
4689       return TRUE;
4690     }
4691   }
4692 
4693   return FALSE;
4694 }
4695 
4696 static gboolean
4697 gst_value_intersect_fraction_range_fraction_range (GValue * dest,
4698     const GValue * src1, const GValue * src2)
4699 {
4700   GValue *min;
4701   GValue *max;
4702   gint res;
4703   GValue *vals1, *vals2;
4704   GstValueCompareFunc compare;
4705 
4706   vals1 = src1-&gt;data[0].v_pointer;
4707   vals2 = src2-&gt;data[0].v_pointer;
4708   g_return_val_if_fail (vals1 != NULL &amp;&amp; vals2 != NULL, FALSE);
</pre>
<hr />
<pre>
4711     /* min = MAX (src1.start, src2.start) */
4712     res = gst_value_compare_with_func (&amp;vals1[0], &amp;vals2[0], compare);
4713     g_return_val_if_fail (res != GST_VALUE_UNORDERED, FALSE);
4714     if (res == GST_VALUE_LESS_THAN)
4715       min = &amp;vals2[0];          /* Take the max of the 2 */
4716     else
4717       min = &amp;vals1[0];
4718 
4719     /* max = MIN (src1.end, src2.end) */
4720     res = gst_value_compare_with_func (&amp;vals1[1], &amp;vals2[1], compare);
4721     g_return_val_if_fail (res != GST_VALUE_UNORDERED, FALSE);
4722     if (res == GST_VALUE_GREATER_THAN)
4723       max = &amp;vals2[1];          /* Take the min of the 2 */
4724     else
4725       max = &amp;vals1[1];
4726 
4727     res = gst_value_compare_with_func (min, max, compare);
4728     g_return_val_if_fail (res != GST_VALUE_UNORDERED, FALSE);
4729     if (res == GST_VALUE_LESS_THAN) {
4730       if (dest) {
<span class="line-modified">4731         g_value_init (dest, GST_TYPE_FRACTION_RANGE);</span>
<span class="line-modified">4732         vals1 = dest-&gt;data[0].v_pointer;</span>
<span class="line-modified">4733         g_value_copy (min, &amp;vals1[0]);</span>
<span class="line-modified">4734         g_value_copy (max, &amp;vals1[1]);</span>
4735       }
4736       return TRUE;
4737     }
4738     if (res == GST_VALUE_EQUAL) {
4739       if (dest)
<span class="line-modified">4740         gst_value_init_and_copy (dest, min);</span>
4741       return TRUE;
4742     }
4743   }
4744 
4745   return FALSE;
4746 }
4747 
4748 /* Two flagsets intersect if the masked bits in both
4749  * flagsets are exactly equal */
4750 static gboolean
4751 gst_value_intersect_flagset_flagset (GValue * dest,
4752     const GValue * src1, const GValue * src2)
4753 {
4754   guint f1, f2;
4755   guint m1, m2;
4756   GType type1, type2, flagset_type;
4757 
4758   g_return_val_if_fail (GST_VALUE_HOLDS_FLAG_SET (src1), FALSE);
4759   g_return_val_if_fail (GST_VALUE_HOLDS_FLAG_SET (src2), FALSE);
4760 
</pre>
<hr />
<pre>
4826  * subtraction *
4827  ***************/
4828 
4829 static gboolean
4830 gst_value_subtract_int_int_range (GValue * dest, const GValue * minuend,
4831     const GValue * subtrahend)
4832 {
4833   gint min = gst_value_get_int_range_min (subtrahend);
4834   gint max = gst_value_get_int_range_max (subtrahend);
4835   gint step = gst_value_get_int_range_step (subtrahend);
4836   gint val = g_value_get_int (minuend);
4837 
4838   if (step == 0)
4839     return FALSE;
4840 
4841   /* subtracting a range from an int only works if the int is not in the
4842    * range */
4843   if (val &lt; min || val &gt; max || val % step) {
4844     /* and the result is the int */
4845     if (dest)
<span class="line-modified">4846       gst_value_init_and_copy (dest, minuend);</span>
4847     return TRUE;
4848   }
4849   return FALSE;
4850 }
4851 
4852 /* creates a new int range based on input values.
4853  */
4854 static gboolean
4855 gst_value_create_new_range (GValue * dest, gint min1, gint max1, gint min2,
4856     gint max2, gint step)
4857 {
4858   GValue v1 = { 0, };
4859   GValue v2 = { 0, };
4860   GValue *pv1, *pv2;            /* yeah, hungarian! */
4861 
4862   g_return_val_if_fail (step &gt; 0, FALSE);
4863   g_return_val_if_fail (min1 % step == 0, FALSE);
4864   g_return_val_if_fail (max1 % step == 0, FALSE);
4865   g_return_val_if_fail (min2 % step == 0, FALSE);
4866   g_return_val_if_fail (max2 % step == 0, FALSE);
</pre>
<hr />
<pre>
4902   return TRUE;
4903 }
4904 
4905 static gboolean
4906 gst_value_subtract_int_range_int (GValue * dest, const GValue * minuend,
4907     const GValue * subtrahend)
4908 {
4909   gint min = gst_value_get_int_range_min (minuend);
4910   gint max = gst_value_get_int_range_max (minuend);
4911   gint step = gst_value_get_int_range_step (minuend);
4912   gint val = g_value_get_int (subtrahend);
4913 
4914   g_return_val_if_fail (min &lt; max, FALSE);
4915 
4916   if (step == 0)
4917     return FALSE;
4918 
4919   /* value is outside of the range, return range unchanged */
4920   if (val &lt; min || val &gt; max || val % step) {
4921     if (dest)
<span class="line-modified">4922       gst_value_init_and_copy (dest, minuend);</span>
4923     return TRUE;
4924   } else {
4925     /* max must be MAXINT too as val &lt;= max */
4926     if (val &gt;= G_MAXINT - step + 1) {
4927       max -= step;
4928       val -= step;
4929     }
4930     /* min must be MININT too as val &gt;= max */
4931     if (val &lt;= G_MININT + step - 1) {
4932       min += step;
4933       val += step;
4934     }
4935     if (dest)
4936       gst_value_create_new_range (dest, min, val - step, val + step, max, step);
4937   }
4938   return TRUE;
4939 }
4940 
4941 static gboolean
4942 gst_value_subtract_int_range_int_range (GValue * dest, const GValue * minuend,
</pre>
<hr />
<pre>
4973         MAX (max2 + step, min1), max1, step);
4974   }
4975 }
4976 
4977 static gboolean
4978 gst_value_subtract_int64_int64_range (GValue * dest, const GValue * minuend,
4979     const GValue * subtrahend)
4980 {
4981   gint64 min = gst_value_get_int64_range_min (subtrahend);
4982   gint64 max = gst_value_get_int64_range_max (subtrahend);
4983   gint64 step = gst_value_get_int64_range_step (subtrahend);
4984   gint64 val = g_value_get_int64 (minuend);
4985 
4986   if (step == 0)
4987     return FALSE;
4988   /* subtracting a range from an int64 only works if the int64 is not in the
4989    * range */
4990   if (val &lt; min || val &gt; max || val % step) {
4991     /* and the result is the int64 */
4992     if (dest)
<span class="line-modified">4993       gst_value_init_and_copy (dest, minuend);</span>
4994     return TRUE;
4995   }
4996   return FALSE;
4997 }
4998 
4999 /* creates a new int64 range based on input values.
5000  */
5001 static gboolean
5002 gst_value_create_new_int64_range (GValue * dest, gint64 min1, gint64 max1,
5003     gint64 min2, gint64 max2, gint64 step)
5004 {
5005   GValue v1 = { 0, };
5006   GValue v2 = { 0, };
5007   GValue *pv1, *pv2;            /* yeah, hungarian! */
5008 
5009   g_return_val_if_fail (step &gt; 0, FALSE);
5010   g_return_val_if_fail (min1 % step == 0, FALSE);
5011   g_return_val_if_fail (max1 % step == 0, FALSE);
5012   g_return_val_if_fail (min2 % step == 0, FALSE);
5013   g_return_val_if_fail (max2 % step == 0, FALSE);
</pre>
<hr />
<pre>
5049   return TRUE;
5050 }
5051 
5052 static gboolean
5053 gst_value_subtract_int64_range_int64 (GValue * dest, const GValue * minuend,
5054     const GValue * subtrahend)
5055 {
5056   gint64 min = gst_value_get_int64_range_min (minuend);
5057   gint64 max = gst_value_get_int64_range_max (minuend);
5058   gint64 step = gst_value_get_int64_range_step (minuend);
5059   gint64 val = g_value_get_int64 (subtrahend);
5060 
5061   g_return_val_if_fail (min &lt; max, FALSE);
5062 
5063   if (step == 0)
5064     return FALSE;
5065 
5066   /* value is outside of the range, return range unchanged */
5067   if (val &lt; min || val &gt; max || val % step) {
5068     if (dest)
<span class="line-modified">5069       gst_value_init_and_copy (dest, minuend);</span>
5070     return TRUE;
5071   } else {
5072     /* max must be MAXINT64 too as val &lt;= max */
5073     if (val &gt;= G_MAXINT64 - step + 1) {
5074       max -= step;
5075       val -= step;
5076     }
5077     /* min must be MININT64 too as val &gt;= max */
5078     if (val &lt;= G_MININT64 + step - 1) {
5079       min += step;
5080       val += step;
5081     }
5082     if (dest)
5083       gst_value_create_new_int64_range (dest, min, val - step, val + step, max,
5084           step);
5085   }
5086   return TRUE;
5087 }
5088 
5089 static gboolean
</pre>
<hr />
<pre>
5116             max1), step, 0, step);
5117   } else if (min2 &lt;= min1) {
5118     return gst_value_create_new_int64_range (dest, MAX (max2 + step, min1),
5119         max1, step, 0, step);
5120   } else {
5121     return gst_value_create_new_int64_range (dest, min1, MIN (min2 - step,
5122             max1), MAX (max2 + step, min1), max1, step);
5123   }
5124 }
5125 
5126 static gboolean
5127 gst_value_subtract_double_double_range (GValue * dest, const GValue * minuend,
5128     const GValue * subtrahend)
5129 {
5130   gdouble min = gst_value_get_double_range_min (subtrahend);
5131   gdouble max = gst_value_get_double_range_max (subtrahend);
5132   gdouble val = g_value_get_double (minuend);
5133 
5134   if (val &lt; min || val &gt; max) {
5135     if (dest)
<span class="line-modified">5136       gst_value_init_and_copy (dest, minuend);</span>
5137     return TRUE;
5138   }
5139   return FALSE;
5140 }
5141 
5142 static gboolean
5143 gst_value_subtract_double_range_double (GValue * dest, const GValue * minuend,
5144     const GValue * subtrahend)
5145 {
5146   /* since we don&#39;t have open ranges, we cannot create a hole in
5147    * a double range. We return the original range */
5148   if (dest)
<span class="line-modified">5149     gst_value_init_and_copy (dest, minuend);</span>
5150   return TRUE;
5151 }
5152 
5153 static gboolean
5154 gst_value_subtract_double_range_double_range (GValue * dest,
5155     const GValue * minuend, const GValue * subtrahend)
5156 {
5157   /* since we don&#39;t have open ranges, we have to approximate */
5158   /* done like with ints */
5159   gdouble min1 = gst_value_get_double_range_min (minuend);
5160   gdouble max2 = gst_value_get_double_range_max (minuend);
5161   gdouble max1 = MIN (gst_value_get_double_range_min (subtrahend), max2);
5162   gdouble min2 = MAX (gst_value_get_double_range_max (subtrahend), min1);
5163   GValue v1 = { 0, };
5164   GValue v2 = { 0, };
5165   GValue *pv1, *pv2;            /* yeah, hungarian! */
5166 
5167   if (min1 &lt; max1 &amp;&amp; min2 &lt; max2) {
5168     pv1 = &amp;v1;
5169     pv2 = &amp;v2;
</pre>
<hr />
<pre>
5244 
5245   gst_value_init_and_copy (result, minuend);
5246   size = VALUE_LIST_SIZE (subtrahend);
5247   for (i = 0; i &lt; size; i++) {
5248     const GValue *cur = VALUE_LIST_GET_VALUE (subtrahend, i);
5249 
5250     if (gst_value_subtract (subtraction, result, cur)) {
5251       GValue *temp = result;
5252 
5253       result = subtraction;
5254       subtraction = temp;
5255       g_value_unset (subtraction);
5256     } else {
5257       g_value_unset (result);
5258       return FALSE;
5259     }
5260   }
5261   if (dest) {
5262     gst_value_move (dest, result);
5263   } else {
<span class="line-modified">5264     g_value_unset (result);</span>
5265   }
5266   return TRUE;
5267 }
5268 
5269 static gboolean
5270 gst_value_subtract_fraction_fraction_range (GValue * dest,
5271     const GValue * minuend, const GValue * subtrahend)
5272 {
5273   const GValue *min = gst_value_get_fraction_range_min (subtrahend);
5274   const GValue *max = gst_value_get_fraction_range_max (subtrahend);
5275   GstValueCompareFunc compare;
5276 
5277   if ((compare = gst_value_get_compare_func (minuend))) {
5278     /* subtracting a range from an fraction only works if the fraction
5279      * is not in the range */
5280     if (gst_value_compare_with_func (minuend, min, compare) ==
5281         GST_VALUE_LESS_THAN ||
5282         gst_value_compare_with_func (minuend, max, compare) ==
5283         GST_VALUE_GREATER_THAN) {
5284       /* and the result is the value */
5285       if (dest)
<span class="line-modified">5286         gst_value_init_and_copy (dest, minuend);</span>
5287       return TRUE;
5288     }
5289   }
5290   return FALSE;
5291 }
5292 
5293 static gboolean
5294 gst_value_subtract_fraction_range_fraction (GValue * dest,
5295     const GValue * minuend, const GValue * subtrahend)
5296 {
5297   /* since we don&#39;t have open ranges, we cannot create a hole in
5298    * a range. We return the original range */
5299   if (dest)
<span class="line-modified">5300     gst_value_init_and_copy (dest, minuend);</span>
5301   return TRUE;
5302 }
5303 
5304 static gboolean
5305 gst_value_subtract_fraction_range_fraction_range (GValue * dest,
5306     const GValue * minuend, const GValue * subtrahend)
5307 {
5308   /* since we don&#39;t have open ranges, we have to approximate */
5309   /* done like with ints and doubles. Creates a list of 2 fraction ranges */
5310   const GValue *min1 = gst_value_get_fraction_range_min (minuend);
5311   const GValue *max2 = gst_value_get_fraction_range_max (minuend);
5312   const GValue *max1 = gst_value_get_fraction_range_min (subtrahend);
5313   const GValue *min2 = gst_value_get_fraction_range_max (subtrahend);
5314   gint cmp1, cmp2;
5315   GValue v1 = { 0, };
5316   GValue v2 = { 0, };
5317   GValue *pv1, *pv2;            /* yeah, hungarian! */
5318   GstValueCompareFunc compare;
5319 
5320   g_return_val_if_fail (min1 != NULL &amp;&amp; max1 != NULL, FALSE);
</pre>
<hr />
<pre>
5484     const gint64 rstep = gst_value_get_int64_range_step (value);
5485     GST_DEBUG (&quot;List/range of int64s&quot;);
5486     if (rstep == 0)
5487       return FALSE;
5488     if (list_size != rmax / rstep - rmin / rstep + 1)
5489       return FALSE;
5490     for (n = 0; n &lt; list_size; ++n) {
5491       gint64 v = g_value_get_int64 (VALUE_LIST_GET_VALUE (list, n));
5492       if (v &lt; rmin || v &gt; rmax || v % rstep)
5493         return FALSE;
5494     }
5495     return TRUE;
5496   }
5497 #undef CHECK_TYPES
5498 
5499   /* other combinations don&#39;t make sense for equality */
5500   return FALSE;
5501 }
5502 
5503 /* &quot;Pure&quot; variant of gst_value_compare which is guaranteed to
<span class="line-modified">5504  * not have list arguments and therefore does basic comparisons</span>
5505  */
5506 static inline gint
5507 _gst_value_compare_nolist (const GValue * value1, const GValue * value2)
5508 {
5509   GstValueCompareFunc compare;
5510 
5511   if (G_VALUE_TYPE (value1) != G_VALUE_TYPE (value2))
5512     return GST_VALUE_UNORDERED;
5513 
5514   compare = gst_value_get_compare_func (value1);
5515   if (compare) {
5516     return compare (value1, value2);
5517   }
5518 
5519   g_critical (&quot;unable to compare values of type %s\n&quot;,
5520       g_type_name (G_VALUE_TYPE (value1)));
5521   return GST_VALUE_UNORDERED;
5522 }
5523 
5524 /**
</pre>
<hr />
<pre>
5540   gboolean value1_is_list;
5541   gboolean value2_is_list;
5542 
5543   g_return_val_if_fail (G_IS_VALUE (value1), GST_VALUE_LESS_THAN);
5544   g_return_val_if_fail (G_IS_VALUE (value2), GST_VALUE_GREATER_THAN);
5545 
5546   value1_is_list = G_VALUE_TYPE (value1) == GST_TYPE_LIST;
5547   value2_is_list = G_VALUE_TYPE (value2) == GST_TYPE_LIST;
5548 
5549   /* Special cases: lists and scalar values (&quot;{ 1 }&quot; and &quot;1&quot; are equal),
5550      as well as lists and ranges (&quot;{ 1, 2 }&quot; and &quot;[ 1, 2 ]&quot; are equal) */
5551   if (value1_is_list &amp;&amp; !value2_is_list) {
5552     gint i, n, ret;
5553 
5554     if (gst_value_list_equals_range (value1, value2)) {
5555       return GST_VALUE_EQUAL;
5556     }
5557 
5558     n = gst_value_list_get_size (value1);
5559     if (n == 0)
<span class="line-modified">5560       return GST_VALUE_UNORDERED;</span>
5561 
5562     for (i = 0; i &lt; n; i++) {
5563       const GValue *elt;
5564 
5565       elt = gst_value_list_get_value (value1, i);
5566       ret = gst_value_compare (elt, value2);
5567       if (ret != GST_VALUE_EQUAL &amp;&amp; n == 1)
5568         return ret;
5569       else if (ret != GST_VALUE_EQUAL)
5570         return GST_VALUE_UNORDERED;
<span class="line-modified">5571     }</span>
5572 
5573     return GST_VALUE_EQUAL;
5574   } else if (value2_is_list &amp;&amp; !value1_is_list) {
5575     gint i, n, ret;
5576 
5577     if (gst_value_list_equals_range (value2, value1)) {
5578       return GST_VALUE_EQUAL;
5579     }
5580 
5581     n = gst_value_list_get_size (value2);
5582     if (n == 0)
<span class="line-modified">5583       return GST_VALUE_UNORDERED;</span>
5584 
5585     for (i = 0; i &lt; n; i++) {
5586       const GValue *elt;
5587 
5588       elt = gst_value_list_get_value (value2, i);
5589       ret = gst_value_compare (elt, value1);
5590       if (ret != GST_VALUE_EQUAL &amp;&amp; n == 1)
5591         return ret;
5592       else if (ret != GST_VALUE_EQUAL)
5593         return GST_VALUE_UNORDERED;
5594     }
5595 
5596     return GST_VALUE_EQUAL;
5597   }
5598 
5599   /* And now handle the generic case */
5600   return _gst_value_compare_nolist (value1, value2);
5601 }
5602 
5603 /*
</pre>
<hr />
<pre>
5680 gst_value_union (GValue * dest, const GValue * value1, const GValue * value2)
5681 {
5682   const GstValueUnionInfo *union_info;
5683   guint i, len;
5684   GType type1, type2;
5685 
5686   g_return_val_if_fail (dest != NULL, FALSE);
5687   g_return_val_if_fail (G_IS_VALUE (value1), FALSE);
5688   g_return_val_if_fail (G_IS_VALUE (value2), FALSE);
5689   g_return_val_if_fail (gst_value_list_or_array_are_compatible (value1, value2),
5690       FALSE);
5691 
5692   len = gst_value_union_funcs-&gt;len;
5693   type1 = G_VALUE_TYPE (value1);
5694   type2 = G_VALUE_TYPE (value2);
5695 
5696   for (i = 0; i &lt; len; i++) {
5697     union_info = &amp;g_array_index (gst_value_union_funcs, GstValueUnionInfo, i);
5698     if (union_info-&gt;type1 == type1 &amp;&amp; union_info-&gt;type2 == type2) {
5699       return union_info-&gt;func (dest, value1, value2);
<span class="line-modified">5700     }</span>
5701     if (union_info-&gt;type1 == type2 &amp;&amp; union_info-&gt;type2 == type1) {
5702       return union_info-&gt;func (dest, value2, value1);
5703     }
<span class="line-modified">5704   }</span>
5705 
5706   gst_value_list_concat (dest, value1, value2);
5707   return TRUE;
5708 }
5709 
5710 /* gst_value_register_union_func: (skip)
5711  * @type1: a type to union
5712  * @type2: another type to union
5713  * @func: a function that implements creating a union between the two types
5714  *
5715  * Registers a union function that can create a union between #GValue items
5716  * of the type @type1 and @type2.
5717  *
5718  * Union functions should be registered at startup before any pipelines are
5719  * started, as gst_value_register_union_func() is not thread-safe and cannot
5720  * be used at the same time as gst_value_union() or gst_value_can_union().
5721  */
5722 static void
5723 gst_value_register_union_func (GType type1, GType type2, GstValueUnionFunc func)
5724 {
</pre>
<hr />
<pre>
5814     const GValue * value2)
5815 {
5816   GstValueIntersectInfo *intersect_info;
5817   guint i, len;
5818   GType type1, type2;
5819 
5820   g_return_val_if_fail (G_IS_VALUE (value1), FALSE);
5821   g_return_val_if_fail (G_IS_VALUE (value2), FALSE);
5822 
5823   type1 = G_VALUE_TYPE (value1);
5824   type2 = G_VALUE_TYPE (value2);
5825 
5826   /* special cases first */
5827   if (type1 == GST_TYPE_LIST)
5828     return gst_value_intersect_list (dest, value1, value2);
5829   if (type2 == GST_TYPE_LIST)
5830     return gst_value_intersect_list (dest, value2, value1);
5831 
5832   if (_gst_value_compare_nolist (value1, value2) == GST_VALUE_EQUAL) {
5833     if (dest)
<span class="line-modified">5834       gst_value_init_and_copy (dest, value1);</span>
5835     return TRUE;
5836   }
5837 
5838   len = gst_value_intersect_funcs-&gt;len;
5839   for (i = 0; i &lt; len; i++) {
5840     intersect_info = &amp;g_array_index (gst_value_intersect_funcs,
5841         GstValueIntersectInfo, i);
5842     if (intersect_info-&gt;type1 == type1 &amp;&amp; intersect_info-&gt;type2 == type2) {
5843       return intersect_info-&gt;func (dest, value1, value2);
5844     }
5845     if (intersect_info-&gt;type1 == type2 &amp;&amp; intersect_info-&gt;type2 == type1) {
5846       return intersect_info-&gt;func (dest, value2, value1);
5847     }
5848   }
5849 
5850   /* Failed to find a direct intersection, check if these are
5851    * GstFlagSet sub-types. */
5852   if (G_UNLIKELY (GST_VALUE_HOLDS_FLAG_SET (value1) &amp;&amp;
5853           GST_VALUE_HOLDS_FLAG_SET (value2))) {
5854     return gst_value_intersect_flagset_flagset (dest, value1, value2);
</pre>
<hr />
<pre>
5915 
5916   mtype = G_VALUE_TYPE (minuend);
5917   stype = G_VALUE_TYPE (subtrahend);
5918 
5919   /* special cases first */
5920   if (mtype == GST_TYPE_LIST)
5921     return gst_value_subtract_from_list (dest, minuend, subtrahend);
5922   if (stype == GST_TYPE_LIST)
5923     return gst_value_subtract_list (dest, minuend, subtrahend);
5924 
5925   len = gst_value_subtract_funcs-&gt;len;
5926   for (i = 0; i &lt; len; i++) {
5927     info = &amp;g_array_index (gst_value_subtract_funcs, GstValueSubtractInfo, i);
5928     if (info-&gt;minuend == mtype &amp;&amp; info-&gt;subtrahend == stype) {
5929       return info-&gt;func (dest, minuend, subtrahend);
5930     }
5931   }
5932 
5933   if (_gst_value_compare_nolist (minuend, subtrahend) != GST_VALUE_EQUAL) {
5934     if (dest)
<span class="line-modified">5935       gst_value_init_and_copy (dest, minuend);</span>
5936     return TRUE;
5937   }
5938 
5939   return FALSE;
5940 }
5941 
5942 #if 0
5943 gboolean
5944 gst_value_subtract (GValue * dest, const GValue * minuend,
5945     const GValue * subtrahend)
5946 {
5947   gboolean ret = gst_value_subtract2 (dest, minuend, subtrahend);
5948 
5949   g_printerr (&quot;\&quot;%s\&quot;  -  \&quot;%s\&quot;  =  \&quot;%s\&quot;\n&quot;, gst_value_serialize (minuend),
5950       gst_value_serialize (subtrahend),
5951       ret ? gst_value_serialize (dest) : &quot;---&quot;);
5952   return ret;
5953 }
5954 #endif
5955 
</pre>
<hr />
<pre>
6768   GstDateTime *date = (GstDateTime *) g_value_get_boxed (val);
6769 
6770   if (date == NULL)
6771     return g_strdup (&quot;null&quot;);
6772 
6773   return __gst_date_time_serialize (date, TRUE);
6774 }
6775 
6776 static gboolean
6777 gst_value_deserialize_date_time (GValue * dest, const gchar * s)
6778 {
6779   GstDateTime *datetime;
6780 
6781   if (!s || strcmp (s, &quot;null&quot;) == 0) {
6782     return FALSE;
6783   }
6784 
6785   datetime = gst_date_time_new_from_iso8601_string (s);
6786   if (datetime != NULL) {
6787     g_value_take_boxed (dest, datetime);
<span class="line-modified">6788     return TRUE;</span>
6789   }
6790   GST_WARNING (&quot;Failed to deserialize date time string &#39;%s&#39;&quot;, s);
6791   return FALSE;
6792 }
6793 
6794 static void
6795 gst_value_transform_date_string (const GValue * src_value, GValue * dest_value)
6796 {
6797   dest_value-&gt;data[0].v_pointer = gst_value_serialize_date (src_value);
6798 }
6799 
6800 static void
6801 gst_value_transform_string_date (const GValue * src_value, GValue * dest_value)
6802 {
6803   gst_value_deserialize_date (dest_value, src_value-&gt;data[0].v_pointer);
6804 }
6805 
6806 
6807 /************
6808  * bitmask *
</pre>
<hr />
<pre>
7433   NULL,
7434   (char *) &quot;ii&quot;,
7435   gst_value_collect_fraction, (char *) &quot;pp&quot;, gst_value_lcopy_fraction
7436 };
7437 
7438 FUNC_VALUE_GET_TYPE (fraction, &quot;GstFraction&quot;);
7439 
7440 static const GTypeValueTable _gst_bitmask_value_table = {
7441   gst_value_init_bitmask,
7442   NULL,
7443   gst_value_copy_bitmask,
7444   NULL,
7445   (char *) &quot;q&quot;,
7446   gst_value_collect_bitmask, (char *) &quot;p&quot;, gst_value_lcopy_bitmask
7447 };
7448 
7449 FUNC_VALUE_GET_TYPE (bitmask, &quot;GstBitmask&quot;);
7450 
7451 static const GTypeValueTable _gst_flagset_value_table = {
7452   gst_value_init_flagset,
<span class="line-modified">7453   NULL,</span>
7454   gst_value_copy_flagset,
<span class="line-modified">7455   NULL,</span>
7456   (char *) &quot;ii&quot;,
7457   gst_value_collect_flagset, (char *) &quot;pp&quot;, gst_value_lcopy_flagset
<span class="line-modified">7458 };</span>
7459 
7460 FUNC_VALUE_GET_TYPE_CLASSED (flagset, &quot;GstFlagSet&quot;,
7461     sizeof (GstFlagSetClass), G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_DERIVABLE);
7462 
7463 GType
7464 gst_g_thread_get_type (void)
<span class="line-modified">7465 {</span>
7466   return G_TYPE_THREAD;
<span class="line-modified">7467 }</span>
7468 
7469 #define SERIAL_VTABLE(t,c,s,d) { t, c, s, d }
7470 
7471 #define REGISTER_SERIALIZATION_CONST(_gtype, _type)                     \
7472 G_STMT_START {                                                          \
7473   static const GstValueTable gst_value =                                \
7474     SERIAL_VTABLE (_gtype, gst_value_compare_ ## _type,                 \
7475     gst_value_serialize_ ## _type, gst_value_deserialize_ ## _type);    \
7476   gst_value_register (&amp;gst_value);                                      \
7477 } G_STMT_END
7478 
7479 #define REGISTER_SERIALIZATION(_gtype, _type)                           \
7480 G_STMT_START {                                                          \
7481   static GstValueTable gst_value =                                      \
7482     SERIAL_VTABLE (0, gst_value_compare_ ## _type,                      \
7483     gst_value_serialize_ ## _type, gst_value_deserialize_ ## _type);    \
7484   gst_value.type = _gtype;                                              \
7485   gst_value_register (&amp;gst_value);                                      \
7486 } G_STMT_END
7487 
</pre>
<hr />
<pre>
7496 
7497 #define REGISTER_SERIALIZATION_COMPARE_ONLY(_gtype, _type)              \
7498 G_STMT_START {                                                          \
7499   static GstValueTable gst_value =                                      \
7500     SERIAL_VTABLE (0, gst_value_compare_ ## _type,                      \
7501         NULL, NULL);                                                    \
7502   gst_value.type = _gtype;                                              \
7503   gst_value_register (&amp;gst_value);                                      \
7504 } G_STMT_END
7505 
7506 /* These initial sizes are used for the tables
7507  * below, and save a couple of reallocs at startup */
7508 
7509 static const gint GST_VALUE_TABLE_DEFAULT_SIZE = 40;
7510 static const gint GST_VALUE_UNION_TABLE_DEFAULT_SIZE = 8;
7511 static const gint GST_VALUE_INTERSECT_TABLE_DEFAULT_SIZE = 16;
7512 static const gint GST_VALUE_SUBTRACT_TABLE_DEFAULT_SIZE = 16;
7513 
7514 void
7515 _priv_gst_value_initialize (void)
<span class="line-modified">7516 {</span>
7517   gst_value_table =
7518       g_array_sized_new (FALSE, FALSE, sizeof (GstValueTable),
7519       GST_VALUE_TABLE_DEFAULT_SIZE);
7520   gst_value_hash = g_hash_table_new (NULL, NULL);
7521   gst_value_union_funcs = g_array_sized_new (FALSE, FALSE,
7522       sizeof (GstValueUnionInfo), GST_VALUE_UNION_TABLE_DEFAULT_SIZE);
7523   gst_value_intersect_funcs = g_array_sized_new (FALSE, FALSE,
7524       sizeof (GstValueIntersectInfo), GST_VALUE_INTERSECT_TABLE_DEFAULT_SIZE);
7525   gst_value_subtract_funcs = g_array_sized_new (FALSE, FALSE,
7526       sizeof (GstValueSubtractInfo), GST_VALUE_SUBTRACT_TABLE_DEFAULT_SIZE);
7527 
7528   REGISTER_SERIALIZATION (gst_int_range_get_type (), int_range);
7529   REGISTER_SERIALIZATION (gst_int64_range_get_type (), int64_range);
7530   REGISTER_SERIALIZATION (gst_double_range_get_type (), double_range);
7531   REGISTER_SERIALIZATION (gst_fraction_range_get_type (), fraction_range);
7532   REGISTER_SERIALIZATION (gst_value_list_get_type (), value_list);
7533   REGISTER_SERIALIZATION (gst_value_array_get_type (), value_array);
7534   REGISTER_SERIALIZATION (g_value_array_get_type (), g_value_array);
7535   REGISTER_SERIALIZATION (gst_buffer_get_type (), buffer);
7536   REGISTER_SERIALIZATION (gst_sample_get_type (), sample);
</pre>
</td>
</tr>
</table>
<center><a href="gstutils.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstvalue.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>