<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmem.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gmem.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmessages.c.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gmem.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 56,72 ***</span>
   * G_MEM_ALIGN:
   *
   * Indicates the number of bytes to which memory will be aligned on the
   * current platform.
   */
<span class="line-modified">! #  define G_MEM_ALIGN   GLIB_SIZEOF_VOID_P</span>
<span class="line-modified">! #else   /* GLIB_SIZEOF_VOID_P &lt;= GLIB_SIZEOF_LONG */</span>
<span class="line-modified">! #  define G_MEM_ALIGN   GLIB_SIZEOF_LONG</span>
  #endif  /* GLIB_SIZEOF_VOID_P &lt;= GLIB_SIZEOF_LONG */
  
  
  /* Memory allocation functions
   */
  
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! void     g_free           (gpointer  mem);</span>
  
  GLIB_AVAILABLE_IN_2_34
  void     g_clear_pointer  (gpointer      *pp,
                             GDestroyNotify destroy);
  
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gpointer g_malloc         (gsize     n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gpointer g_malloc0        (gsize     n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
  GLIB_AVAILABLE_IN_ALL
  gpointer g_realloc        (gpointer  mem,
<span class="line-modified">!                gsize     n_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gpointer g_try_malloc     (gsize     n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gpointer g_try_malloc0    (gsize     n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
  GLIB_AVAILABLE_IN_ALL
  gpointer g_try_realloc    (gpointer  mem,
<span class="line-modified">!                gsize     n_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
  
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gpointer g_malloc_n       (gsize     n_blocks,</span>
<span class="line-modified">!                gsize     n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gpointer g_malloc0_n      (gsize     n_blocks,</span>
<span class="line-modified">!                gsize     n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
  GLIB_AVAILABLE_IN_ALL
  gpointer g_realloc_n      (gpointer  mem,
<span class="line-modified">!                gsize     n_blocks,</span>
<span class="line-modified">!                gsize     n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gpointer g_try_malloc_n   (gsize     n_blocks,</span>
<span class="line-modified">!                gsize     n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gpointer g_try_malloc0_n  (gsize     n_blocks,</span>
<span class="line-modified">!                gsize     n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
  GLIB_AVAILABLE_IN_ALL
  gpointer g_try_realloc_n  (gpointer  mem,
<span class="line-modified">!                gsize     n_blocks,</span>
<span class="line-modified">!                gsize     n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
  
  #if defined(g_has_typeof) &amp;&amp; GLIB_VERSION_MAX_ALLOWED &gt;= GLIB_VERSION_2_58
  #define g_clear_pointer(pp, destroy)                                           \
    G_STMT_START {                                                               \
      G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));                       \
      __typeof__((pp)) _pp = (pp);                                               \
      __typeof__(*(pp)) _ptr = *_pp;                                             \
      *_pp = NULL;                                                               \
      if (_ptr)                                                                  \
        (destroy) (_ptr);                                                        \
<span class="line-modified">!   } G_STMT_END</span>
  #else /* __GNUC__ */
  #define g_clear_pointer(pp, destroy) \
    G_STMT_START {                                                               \
      G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));                       \
      /* Only one access, please; work around type aliasing */                   \
<span class="line-new-header">--- 56,73 ---</span>
   * G_MEM_ALIGN:
   *
   * Indicates the number of bytes to which memory will be aligned on the
   * current platform.
   */
<span class="line-modified">! #  define G_MEM_ALIGN GLIB_SIZEOF_VOID_P</span>
<span class="line-modified">! #else /* GLIB_SIZEOF_VOID_P &lt;= GLIB_SIZEOF_LONG */</span>
<span class="line-modified">! #  define G_MEM_ALIGN GLIB_SIZEOF_LONG</span>
  #endif  /* GLIB_SIZEOF_VOID_P &lt;= GLIB_SIZEOF_LONG */
  
  
  /* Memory allocation functions
   */
  
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! void   g_free           (gpointer  mem);</span>
  
  GLIB_AVAILABLE_IN_2_34
  void     g_clear_pointer  (gpointer      *pp,
                             GDestroyNotify destroy);
  
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gpointer g_malloc         (gsize   n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gpointer g_malloc0        (gsize   n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
  GLIB_AVAILABLE_IN_ALL
  gpointer g_realloc        (gpointer  mem,
<span class="line-modified">!          gsize   n_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gpointer g_try_malloc     (gsize   n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gpointer g_try_malloc0    (gsize   n_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE(1);</span>
  GLIB_AVAILABLE_IN_ALL
  gpointer g_try_realloc    (gpointer  mem,
<span class="line-modified">!          gsize   n_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
  
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gpointer g_malloc_n       (gsize   n_blocks,</span>
<span class="line-modified">!          gsize   n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gpointer g_malloc0_n      (gsize   n_blocks,</span>
<span class="line-modified">!          gsize   n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
  GLIB_AVAILABLE_IN_ALL
  gpointer g_realloc_n      (gpointer  mem,
<span class="line-modified">!          gsize   n_blocks,</span>
<span class="line-modified">!          gsize   n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gpointer g_try_malloc_n   (gsize   n_blocks,</span>
<span class="line-modified">!          gsize   n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
  GLIB_AVAILABLE_IN_ALL
<span class="line-modified">! gpointer g_try_malloc0_n  (gsize   n_blocks,</span>
<span class="line-modified">!          gsize   n_block_bytes) G_GNUC_MALLOC G_GNUC_ALLOC_SIZE2(1,2);</span>
  GLIB_AVAILABLE_IN_ALL
  gpointer g_try_realloc_n  (gpointer  mem,
<span class="line-modified">!          gsize   n_blocks,</span>
<span class="line-modified">!          gsize   n_block_bytes) G_GNUC_WARN_UNUSED_RESULT;</span>
  
  #if defined(g_has_typeof) &amp;&amp; GLIB_VERSION_MAX_ALLOWED &gt;= GLIB_VERSION_2_58
  #define g_clear_pointer(pp, destroy)                                           \
    G_STMT_START {                                                               \
      G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));                       \
      __typeof__((pp)) _pp = (pp);                                               \
      __typeof__(*(pp)) _ptr = *_pp;                                             \
      *_pp = NULL;                                                               \
      if (_ptr)                                                                  \
        (destroy) (_ptr);                                                        \
<span class="line-modified">!   } G_STMT_END                                                                 \</span>
<span class="line-added">+   GLIB_AVAILABLE_MACRO_IN_2_34</span>
  #else /* __GNUC__ */
  #define g_clear_pointer(pp, destroy) \
    G_STMT_START {                                                               \
      G_STATIC_ASSERT (sizeof *(pp) == sizeof (gpointer));                       \
      /* Only one access, please; work around type aliasing */                   \
</pre>
<hr />
<pre>
<span class="line-old-header">*** 130,16 ***</span>
      /* This assignment is needed to avoid a gcc warning */                     \
      GDestroyNotify _destroy = (GDestroyNotify) (destroy);                      \
                                                                                 \
      _pp.in = (char *) (pp);                                                    \
      _p = *_pp.out;                                                             \
<span class="line-modified">!     if (_p)                                        \</span>
<span class="line-modified">!       {                                        \</span>
          *_pp.out = NULL;                                                       \
          _destroy (_p);                                                         \
        }                                                                        \
<span class="line-modified">!   } G_STMT_END</span>
  #endif /* __GNUC__ */
  
  /**
   * g_steal_pointer:
   * @pp: (not nullable): a pointer to a pointer
<span class="line-new-header">--- 131,17 ---</span>
      /* This assignment is needed to avoid a gcc warning */                     \
      GDestroyNotify _destroy = (GDestroyNotify) (destroy);                      \
                                                                                 \
      _pp.in = (char *) (pp);                                                    \
      _p = *_pp.out;                                                             \
<span class="line-modified">!     if (_p)                        \</span>
<span class="line-modified">!       {                        \</span>
          *_pp.out = NULL;                                                       \
          _destroy (_p);                                                         \
        }                                                                        \
<span class="line-modified">!   } G_STMT_END                                                                 \</span>
<span class="line-added">+   GLIB_AVAILABLE_MACRO_IN_2_34</span>
  #endif /* __GNUC__ */
  
  /**
   * g_steal_pointer:
   * @pp: (not nullable): a pointer to a pointer
</pre>
<hr />
<pre>
<span class="line-old-header">*** 220,37 ***</span>
  /* Optimise: avoid the call to the (slower) _n function if we can
   * determine at compile-time that no overflow happens.
   */
  #if defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 2) &amp;&amp; defined (__OPTIMIZE__)
  #  define _G_NEW(struct_type, n_structs, func) \
<span class="line-modified">!     (struct_type *) (G_GNUC_EXTENSION ({            \</span>
<span class="line-modified">!       gsize __n = (gsize) (n_structs);          \</span>
<span class="line-modified">!       gsize __s = sizeof (struct_type);         \</span>
<span class="line-modified">!       gpointer __p;                     \</span>
<span class="line-modified">!       if (__s == 1)                     \</span>
<span class="line-modified">!         __p = g_##func (__n);               \</span>
<span class="line-modified">!       else if (__builtin_constant_p (__n) &amp;&amp;        \</span>
<span class="line-modified">!                (__s == 0 || __n &lt;= G_MAXSIZE / __s))    \</span>
<span class="line-modified">!         __p = g_##func (__n * __s);             \</span>
<span class="line-modified">!       else                          \</span>
<span class="line-modified">!         __p = g_##func##_n (__n, __s);          \</span>
<span class="line-modified">!       __p;                          \</span>
<span class="line-modified">!     }))</span>
  #  define _G_RENEW(struct_type, mem, n_structs, func) \
<span class="line-modified">!     (struct_type *) (G_GNUC_EXTENSION ({            \</span>
<span class="line-modified">!       gsize __n = (gsize) (n_structs);          \</span>
<span class="line-modified">!       gsize __s = sizeof (struct_type);         \</span>
<span class="line-modified">!       gpointer __p = (gpointer) (mem);          \</span>
<span class="line-modified">!       if (__s == 1)                     \</span>
<span class="line-modified">!         __p = g_##func (__p, __n);              \</span>
<span class="line-modified">!       else if (__builtin_constant_p (__n) &amp;&amp;        \</span>
<span class="line-modified">!                (__s == 0 || __n &lt;= G_MAXSIZE / __s))    \</span>
<span class="line-modified">!         __p = g_##func (__p, __n * __s);            \</span>
<span class="line-modified">!       else                          \</span>
<span class="line-modified">!         __p = g_##func##_n (__p, __n, __s);         \</span>
<span class="line-modified">!       __p;                          \</span>
<span class="line-modified">!     }))</span>
  
  #else
  
  /* Unoptimised version: always call the _n() function. */
  
<span class="line-new-header">--- 222,37 ---</span>
  /* Optimise: avoid the call to the (slower) _n function if we can
   * determine at compile-time that no overflow happens.
   */
  #if defined (__GNUC__) &amp;&amp; (__GNUC__ &gt;= 2) &amp;&amp; defined (__OPTIMIZE__)
  #  define _G_NEW(struct_type, n_structs, func) \
<span class="line-modified">!   (struct_type *) (G_GNUC_EXTENSION ({      \</span>
<span class="line-modified">!     gsize __n = (gsize) (n_structs);      \</span>
<span class="line-modified">!     gsize __s = sizeof (struct_type);     \</span>
<span class="line-modified">!     gpointer __p;           \</span>
<span class="line-modified">!     if (__s == 1)           \</span>
<span class="line-modified">!       __p = g_##func (__n);       \</span>
<span class="line-modified">!     else if (__builtin_constant_p (__n) &amp;&amp;    \</span>
<span class="line-modified">!              (__s == 0 || __n &lt;= G_MAXSIZE / __s))  \</span>
<span class="line-modified">!       __p = g_##func (__n * __s);       \</span>
<span class="line-modified">!     else              \</span>
<span class="line-modified">!       __p = g_##func##_n (__n, __s);      \</span>
<span class="line-modified">!     __p;              \</span>
<span class="line-modified">!   }))</span>
  #  define _G_RENEW(struct_type, mem, n_structs, func) \
<span class="line-modified">!   (struct_type *) (G_GNUC_EXTENSION ({      \</span>
<span class="line-modified">!     gsize __n = (gsize) (n_structs);      \</span>
<span class="line-modified">!     gsize __s = sizeof (struct_type);     \</span>
<span class="line-modified">!     gpointer __p = (gpointer) (mem);      \</span>
<span class="line-modified">!     if (__s == 1)           \</span>
<span class="line-modified">!       __p = g_##func (__p, __n);        \</span>
<span class="line-modified">!     else if (__builtin_constant_p (__n) &amp;&amp;    \</span>
<span class="line-modified">!              (__s == 0 || __n &lt;= G_MAXSIZE / __s))  \</span>
<span class="line-modified">!       __p = g_##func (__p, __n * __s);      \</span>
<span class="line-modified">!     else              \</span>
<span class="line-modified">!       __p = g_##func##_n (__p, __n, __s);     \</span>
<span class="line-modified">!     __p;              \</span>
<span class="line-modified">!   }))</span>
  
  #else
  
  /* Unoptimised version: always call the _n() function. */
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 275,11 ***</span>
   * it is normally unnecessary to cast it explicitly, and doing
   * so might hide memory allocation errors.
   *
   * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
   */
<span class="line-modified">! #define g_new(struct_type, n_structs)           _G_NEW (struct_type, n_structs, malloc)</span>
  /**
   * g_new0:
   * @struct_type: the type of the elements to allocate.
   * @n_structs: the number of elements to allocate.
   *
<span class="line-new-header">--- 277,11 ---</span>
   * it is normally unnecessary to cast it explicitly, and doing
   * so might hide memory allocation errors.
   *
   * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
   */
<span class="line-modified">! #define g_new(struct_type, n_structs)     _G_NEW (struct_type, n_structs, malloc)</span>
  /**
   * g_new0:
   * @struct_type: the type of the elements to allocate.
   * @n_structs: the number of elements to allocate.
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 292,11 ***</span>
   * it is normally unnecessary to cast it explicitly, and doing
   * so might hide memory allocation errors.
   *
   * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type.
   */
<span class="line-modified">! #define g_new0(struct_type, n_structs)          _G_NEW (struct_type, n_structs, malloc0)</span>
  /**
   * g_renew:
   * @struct_type: the type of the elements to allocate
   * @mem: the currently allocated memory
   * @n_structs: the number of elements to allocate
<span class="line-new-header">--- 294,11 ---</span>
   * it is normally unnecessary to cast it explicitly, and doing
   * so might hide memory allocation errors.
   *
   * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type.
   */
<span class="line-modified">! #define g_new0(struct_type, n_structs)      _G_NEW (struct_type, n_structs, malloc0)</span>
  /**
   * g_renew:
   * @struct_type: the type of the elements to allocate
   * @mem: the currently allocated memory
   * @n_structs: the number of elements to allocate
</pre>
<hr />
<pre>
<span class="line-old-header">*** 306,11 ***</span>
   * the memory, which may have been moved.
   * Care is taken to avoid overflow when calculating the size of the allocated block.
   *
   * Returns: a pointer to the new allocated memory, cast to a pointer to @struct_type
   */
<span class="line-modified">! #define g_renew(struct_type, mem, n_structs)        _G_RENEW (struct_type, mem, n_structs, realloc)</span>
  /**
   * g_try_new:
   * @struct_type: the type of the elements to allocate
   * @n_structs: the number of elements to allocate
   *
<span class="line-new-header">--- 308,11 ---</span>
   * the memory, which may have been moved.
   * Care is taken to avoid overflow when calculating the size of the allocated block.
   *
   * Returns: a pointer to the new allocated memory, cast to a pointer to @struct_type
   */
<span class="line-modified">! #define g_renew(struct_type, mem, n_structs)    _G_RENEW (struct_type, mem, n_structs, realloc)</span>
  /**
   * g_try_new:
   * @struct_type: the type of the elements to allocate
   * @n_structs: the number of elements to allocate
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 320,11 ***</span>
   * The function returns %NULL when @n_structs is 0 of if an overflow occurs.
   *
   * Since: 2.8
   * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
   */
<span class="line-modified">! #define g_try_new(struct_type, n_structs)       _G_NEW (struct_type, n_structs, try_malloc)</span>
  /**
   * g_try_new0:
   * @struct_type: the type of the elements to allocate
   * @n_structs: the number of elements to allocate
   *
<span class="line-new-header">--- 322,11 ---</span>
   * The function returns %NULL when @n_structs is 0 of if an overflow occurs.
   *
   * Since: 2.8
   * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
   */
<span class="line-modified">! #define g_try_new(struct_type, n_structs)   _G_NEW (struct_type, n_structs, try_malloc)</span>
  /**
   * g_try_new0:
   * @struct_type: the type of the elements to allocate
   * @n_structs: the number of elements to allocate
   *
</pre>
<hr />
<pre>
<span class="line-old-header">*** 335,11 ***</span>
   * The function returns %NULL when @n_structs is 0 or if an overflow occurs.
   *
   * Since: 2.8
   * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
   */
<span class="line-modified">! #define g_try_new0(struct_type, n_structs)      _G_NEW (struct_type, n_structs, try_malloc0)</span>
  /**
   * g_try_renew:
   * @struct_type: the type of the elements to allocate
   * @mem: the currently allocated memory
   * @n_structs: the number of elements to allocate
<span class="line-new-header">--- 337,11 ---</span>
   * The function returns %NULL when @n_structs is 0 or if an overflow occurs.
   *
   * Since: 2.8
   * Returns: a pointer to the allocated memory, cast to a pointer to @struct_type
   */
<span class="line-modified">! #define g_try_new0(struct_type, n_structs)    _G_NEW (struct_type, n_structs, try_malloc0)</span>
  /**
   * g_try_renew:
   * @struct_type: the type of the elements to allocate
   * @mem: the currently allocated memory
   * @n_structs: the number of elements to allocate
</pre>
<hr />
<pre>
<span class="line-old-header">*** 351,40 ***</span>
   * The function returns %NULL if an overflow occurs.
   *
   * Since: 2.8
   * Returns: a pointer to the new allocated memory, cast to a pointer to @struct_type
   */
<span class="line-modified">! #define g_try_renew(struct_type, mem, n_structs)    _G_RENEW (struct_type, mem, n_structs, try_realloc)</span>
  
  
  /* Memory allocation virtualization for debugging purposes
   * g_mem_set_vtable() has to be the very first GLib function called
   * if being used
   */
  struct _GMemVTable {
    gpointer (*malloc)      (gsize    n_bytes);
    gpointer (*realloc)     (gpointer mem,
<span class="line-modified">!                gsize    n_bytes);</span>
    void     (*free)        (gpointer mem);
    /* optional; set to NULL if not used ! */
    gpointer (*calloc)      (gsize    n_blocks,
<span class="line-modified">!                gsize    n_block_bytes);</span>
    gpointer (*try_malloc)  (gsize    n_bytes);
    gpointer (*try_realloc) (gpointer mem,
<span class="line-modified">!                gsize    n_bytes);</span>
  };
  GLIB_DEPRECATED_IN_2_46
<span class="line-modified">! void     g_mem_set_vtable (GMemVTable   *vtable);</span>
  GLIB_DEPRECATED_IN_2_46
  gboolean g_mem_is_system_malloc (void);
  
  GLIB_VAR gboolean g_mem_gc_friendly;
  
  /* Memory profiler and checker, has to be enabled via g_mem_set_vtable()
   */
  GLIB_VAR GMemVTable *glib_mem_profiler_table;
  GLIB_DEPRECATED_IN_2_46
<span class="line-modified">! void    g_mem_profile   (void);</span>
  
  G_END_DECLS
  
  #endif /* __G_MEM_H__ */
<span class="line-new-header">--- 353,40 ---</span>
   * The function returns %NULL if an overflow occurs.
   *
   * Since: 2.8
   * Returns: a pointer to the new allocated memory, cast to a pointer to @struct_type
   */
<span class="line-modified">! #define g_try_renew(struct_type, mem, n_structs)  _G_RENEW (struct_type, mem, n_structs, try_realloc)</span>
  
  
  /* Memory allocation virtualization for debugging purposes
   * g_mem_set_vtable() has to be the very first GLib function called
   * if being used
   */
  struct _GMemVTable {
    gpointer (*malloc)      (gsize    n_bytes);
    gpointer (*realloc)     (gpointer mem,
<span class="line-modified">!          gsize    n_bytes);</span>
    void     (*free)        (gpointer mem);
    /* optional; set to NULL if not used ! */
    gpointer (*calloc)      (gsize    n_blocks,
<span class="line-modified">!          gsize    n_block_bytes);</span>
    gpointer (*try_malloc)  (gsize    n_bytes);
    gpointer (*try_realloc) (gpointer mem,
<span class="line-modified">!          gsize    n_bytes);</span>
  };
  GLIB_DEPRECATED_IN_2_46
<span class="line-modified">! void   g_mem_set_vtable (GMemVTable *vtable);</span>
  GLIB_DEPRECATED_IN_2_46
  gboolean g_mem_is_system_malloc (void);
  
  GLIB_VAR gboolean g_mem_gc_friendly;
  
  /* Memory profiler and checker, has to be enabled via g_mem_set_vtable()
   */
  GLIB_VAR GMemVTable *glib_mem_profiler_table;
  GLIB_DEPRECATED_IN_2_46
<span class="line-modified">! void  g_mem_profile (void);</span>
  
  G_END_DECLS
  
  #endif /* __G_MEM_H__ */
</pre>
<center><a href="gmem.c.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gmessages.c.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>