<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstregistry.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wtay@chello.be&gt;
   4  *                    2005 David A. Schleef &lt;ds@schleef.org&gt;
   5  *
   6  * gstregistry.c: handle registry
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public
  19  * License along with this library; if not, write to the
  20  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 /**
  25  * SECTION:gstregistry
  26  * @title: GstRegistry
  27  * @short_description: Abstract base class for management of #GstPlugin objects
  28  * @see_also: #GstPlugin, #GstPluginFeature
  29  *
  30  * One registry holds the metadata of a set of plugins.
  31  *
  32  * &lt;emphasis role=&quot;bold&quot;&gt;Design:&lt;/emphasis&gt;
  33  *
  34  * The #GstRegistry object is a list of plugins and some functions for dealing
  35  * with them. Each #GstPlugin is matched 1-1 with a file on disk, and may or may
  36  * not be loaded at a given time.
  37  *
  38  * The primary source, at all times, of plugin information is each plugin file
  39  * itself. Thus, if an application wants information about a particular plugin,
  40  * or wants to search for a feature that satisfies given criteria, the primary
  41  * means of doing so is to load every plugin and look at the resulting
  42  * information that is gathered in the default registry. Clearly, this is a time
  43  * consuming process, so we cache information in the registry file. The format
  44  * and location of the cache file is internal to gstreamer.
  45  *
  46  * On startup, plugins are searched for in the plugin search path. The following
  47  * locations are checked in this order:
  48  *
  49  * * location from --gst-plugin-path commandline option.
  50  * * the GST_PLUGIN_PATH environment variable.
  51  * * the GST_PLUGIN_SYSTEM_PATH environment variable.
  52  * * default locations (if GST_PLUGIN_SYSTEM_PATH is not set).
  53  *   Those default locations are:
  54  *   `$XDG_DATA_HOME/gstreamer-$GST_API_VERSION/plugins/`
  55  *   and `$prefix/libs/gstreamer-$GST_API_VERSION/`.
  56  *   [$XDG_DATA_HOME](http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html) defaults to
  57  *   `$HOME/.local/share`.
  58  *
  59  * The registry cache file is loaded from
  60  * `$XDG_CACHE_HOME/gstreamer-$GST_API_VERSION/registry-$ARCH.bin`
  61  * (where $XDG_CACHE_HOME defaults to `$HOME/.cache`) or the file listed in the `GST_REGISTRY`
  62  * env var. One reason to change the registry location is for testing.
  63  *
  64  * For each plugin that is found in the plugin search path, there could be 3
  65  * possibilities for cached information:
  66  *
  67  *   * the cache may not contain information about a given file.
  68  *   * the cache may have stale information.
  69  *   * the cache may have current information.
  70  *
  71  * In the first two cases, the plugin is loaded and the cache updated. In
  72  * addition to these cases, the cache may have entries for plugins that are not
  73  * relevant to the current process. These are marked as not available to the
  74  * current process. If the cache is updated for whatever reason, it is marked
  75  * dirty.
  76  *
  77  * A dirty cache is written out at the end of initialization. Each entry is
  78  * checked to make sure the information is minimally valid. If not, the entry is
  79  * simply dropped.
  80  *
  81  * ## Implementation notes:
  82  *
  83  * The &quot;cache&quot; and &quot;registry&quot; are different concepts and can represent
  84  * different sets of plugins. For various reasons, at init time, the cache is
  85  * stored in the default registry, and plugins not relevant to the current
  86  * process are marked with the %GST_PLUGIN_FLAG_CACHED bit. These plugins are
  87  * removed at the end of initialization.
  88  */
  89 
  90 #ifdef HAVE_CONFIG_H
  91 #include &quot;config.h&quot;
  92 #endif
  93 #include &quot;gstconfig.h&quot;
  94 #include &quot;gst_private.h&quot;
  95 #include &lt;glib.h&gt;
  96 #include &lt;sys/types.h&gt;
  97 #include &lt;sys/stat.h&gt;
  98 #ifdef HAVE_UNISTD_H
  99 #include &lt;unistd.h&gt;
 100 #endif
 101 #include &lt;errno.h&gt;
 102 #include &lt;stdio.h&gt;
 103 #include &lt;string.h&gt;
 104 
 105 /* For g_stat () */
 106 #include &lt;glib/gstdio.h&gt;
 107 
 108 #include &quot;gstinfo.h&quot;
 109 #include &quot;gsterror.h&quot;
 110 #include &quot;gstregistry.h&quot;
 111 #ifndef GSTREAMER_LITE
 112 #include &quot;gstdeviceproviderfactory.h&quot;
 113 #endif // GSTREAMER_LITE
 114 
 115 #include &quot;gstpluginloader.h&quot;
 116 
 117 #include &quot;gst-i18n-lib.h&quot;
 118 
 119 #include &quot;gst.h&quot;
 120 #include &quot;glib-compat-private.h&quot;
 121 
 122 #ifdef GSTREAMER_LITE
 123 #define LIBGSTREAMER_LIB_NAME &quot;gstreamer-lite&quot;
 124 #endif // GSTREAMER_LITE
 125 
 126 
 127 #ifdef G_OS_WIN32
 128 #include &lt;windows.h&gt;
 129 extern HMODULE _priv_gst_dll_handle;
 130 #endif
 131 
 132 #if defined(GSTREAMER_LITE) &amp;&amp; defined(HAVE_OSX)
 133 #include &lt;mach-o/dyld.h&gt;
 134 #include &lt;mach-o/ldsyms.h&gt; //defines _mh_dylib_header see man page for ld
 135 #endif // GSTREAMER_LITE
 136 
 137 #if defined (GSTREAMER_LITE) &amp;&amp; defined(LINUX)
 138 #include &lt;link.h&gt;
 139 #include &lt;dlfcn.h&gt;
 140 
 141 // For libav (libavcodec.so)
 142 static const int AVCODEC_LIBAV_EXPLICIT_VERSIONS[] = { 54, 56 };
 143 // For ffmpeg (libavcodec-ffmpeg.so)
 144 static const int AVCODEC_FFMPEG_EXPLICIT_VERSIONS[] = { 56 };
 145 // For libav or ffmpeg (libavcodec.so)
 146 static const int AVCODEC_EXPLICIT_VERSIONS[] = { 57, 58 };
 147 
 148 /*
 149  * Callback passed to dl_iterate_phdr(): finds the path of
 150  * LIBGSTREAMER_LIB_NAME and returns it in data which is actually
 151  * a char**.
 152  */
 153 static int dl_callback (struct dl_phdr_info *info, size_t size, void *data)
 154 {
 155     int result = 0;
 156 
 157     if (NULL != info)
 158     {
 159         if (NULL != strstr (info-&gt;dlpi_name, LIBGSTREAMER_LIB_NAME))
 160         {
 161             if (NULL != data)
 162             {
 163                 char** name = (char**)data;
 164                 *name = (char*)info-&gt;dlpi_name;
 165             }
 166 
 167             result = 1;
 168         }
 169     }
 170 
 171     return result;
 172 }
 173 #endif // GSTREAMER_LITE &amp;&amp; LINUX
 174 
 175 #define GST_CAT_DEFAULT GST_CAT_REGISTRY
 176 
 177 struct _GstRegistryPrivate
 178 {
 179   GList *plugins;
 180   GList *features;
 181 
 182   guint n_plugins;
 183 #if 0
 184   GList *paths;
 185 #endif
 186 
 187   int cache_file;
 188 
 189   /* hash to speedup _lookup_feature_locked() */
 190   GHashTable *feature_hash;
 191   /* hash to speedup _lookup */
 192   GHashTable *basename_hash;
 193 
 194   /* updated whenever the feature list changes */
 195   guint32 cookie;
 196   /* speedup for searching features */
 197   GList *element_factory_list;
 198   guint32 efl_cookie;
 199   GList *typefind_factory_list;
 200   guint32 tfl_cookie;
 201   GList *device_provider_factory_list;
 202   guint32 dmfl_cookie;
 203 };
 204 
 205 /* the one instance of the default registry and the mutex protecting the
 206  * variable. */
 207 static GMutex _gst_registry_mutex;
 208 static GstRegistry *_gst_registry_default = NULL;
 209 
 210 /* defaults */
 211 #ifndef GSTREAMER_LITE
 212 #define DEFAULT_FORK TRUE
 213 #else // GSTREAMER_LITE
 214 // For GSTREAMER_LITE do not use fork for registry since it may break things, because
 215 // we do not use file to store registry and registry is kept in memory.
 216 #define DEFAULT_FORK FALSE
 217 #define LIBGSTREAMER_LIB_NAME &quot;gstreamer-lite&quot;
 218 #endif // GSTREAMER_LITE
 219 
 220 /* control the behaviour of registry rebuild */
 221 static gboolean _gst_enable_registry_fork = DEFAULT_FORK;
 222 /* List of plugins that need preloading/reloading after scanning registry */
 223 extern GSList *_priv_gst_preload_plugins;
 224 
 225 #ifndef GST_DISABLE_REGISTRY
 226 /* Set to TRUE to disable registry, behaves similar to GST_DISABLE_REGISTRY */
 227 gboolean _priv_gst_disable_registry = FALSE;
 228 /*set to TRUE when registry needn&#39;t to be updated */
 229 gboolean _priv_gst_disable_registry_update = FALSE;
 230 extern GList *_priv_gst_plugin_paths;
 231 
 232 /* Set to TRUE when the registry cache should be disabled */
 233 gboolean _gst_disable_registry_cache = FALSE;
 234 
 235 static gboolean __registry_reuse_plugin_scanner = TRUE;
 236 #endif
 237 
 238 /* Element signals and args */
 239 enum
 240 {
 241   PLUGIN_ADDED,
 242   FEATURE_ADDED,
 243   LAST_SIGNAL
 244 };
 245 
 246 #ifdef GSTREAMER_LITE
 247 gchar *gstlite_plugins_list[] =
 248 {
 249 #ifdef LINUX
 250 
 251     &quot;libfxplugins&quot;,
 252     &quot;libavplugin&quot;,
 253 #elif defined (G_OS_WIN32)
 254     &quot;fxplugins&quot;,
 255 #elif defined (HAVE_OSX)
 256     &quot;libfxplugins&quot;,
 257 #endif
 258     NULL
 259 };
 260 #endif // GSTREAMER_LITE
 261 
 262 static void gst_registry_finalize (GObject * object);
 263 
 264 static guint gst_registry_signals[LAST_SIGNAL] = { 0 };
 265 
 266 static GstPluginFeature *gst_registry_lookup_feature_locked (GstRegistry *
 267     registry, const char *name);
 268 static GstPlugin *gst_registry_lookup_bn_locked (GstRegistry * registry,
 269     const char *basename);
 270 
 271 #define gst_registry_parent_class parent_class
<a name="1" id="anc1"></a><span class="line-modified"> 272 G_DEFINE_TYPE (GstRegistry, gst_registry, GST_TYPE_OBJECT);</span>
 273 
 274 static void
 275 gst_registry_class_init (GstRegistryClass * klass)
 276 {
 277   GObjectClass *gobject_class;
 278 
 279   gobject_class = (GObjectClass *) klass;
 280 
<a name="2" id="anc2"></a><span class="line-removed"> 281   g_type_class_add_private (klass, sizeof (GstRegistryPrivate));</span>
<span class="line-removed"> 282 </span>
 283   /**
 284    * GstRegistry::plugin-added:
 285    * @registry: the registry that emitted the signal
 286    * @plugin: the plugin that has been added
 287    *
 288    * Signals that a plugin has been added to the registry (possibly
 289    * replacing a previously-added one by the same name)
 290    */
 291   gst_registry_signals[PLUGIN_ADDED] =
 292       g_signal_new (&quot;plugin-added&quot;, G_TYPE_FROM_CLASS (klass),
 293       G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_generic,
 294       G_TYPE_NONE, 1, GST_TYPE_PLUGIN);
 295 
 296   /**
 297    * GstRegistry::feature-added:
 298    * @registry: the registry that emitted the signal
 299    * @feature: the feature that has been added
 300    *
 301    * Signals that a feature has been added to the registry (possibly
 302    * replacing a previously-added one by the same name)
 303    */
 304   gst_registry_signals[FEATURE_ADDED] =
 305       g_signal_new (&quot;feature-added&quot;, G_TYPE_FROM_CLASS (klass),
 306       G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_generic,
 307       G_TYPE_NONE, 1, GST_TYPE_PLUGIN_FEATURE);
 308 
 309   gobject_class-&gt;finalize = gst_registry_finalize;
 310 }
 311 
 312 static void
 313 gst_registry_init (GstRegistry * registry)
 314 {
<a name="3" id="anc3"></a><span class="line-modified"> 315   registry-&gt;priv =</span>
<span class="line-removed"> 316       G_TYPE_INSTANCE_GET_PRIVATE (registry, GST_TYPE_REGISTRY,</span>
<span class="line-removed"> 317       GstRegistryPrivate);</span>
 318   registry-&gt;priv-&gt;feature_hash = g_hash_table_new (g_str_hash, g_str_equal);
 319   registry-&gt;priv-&gt;basename_hash = g_hash_table_new (g_str_hash, g_str_equal);
 320 }
 321 
 322 static void
 323 gst_registry_finalize (GObject * object)
 324 {
 325   GstRegistry *registry = GST_REGISTRY (object);
 326   GList *plugins, *p;
 327   GList *features, *f;
 328 
 329   plugins = registry-&gt;priv-&gt;plugins;
 330   registry-&gt;priv-&gt;plugins = NULL;
 331   registry-&gt;priv-&gt;n_plugins = 0;
 332 
 333   GST_DEBUG_OBJECT (registry, &quot;registry finalize&quot;);
 334   p = plugins;
 335   while (p) {
 336     GstPlugin *plugin = p-&gt;data;
 337 
 338     if (plugin) {
 339       GST_LOG_OBJECT (registry, &quot;removing plugin %s&quot;,
 340           gst_plugin_get_name (plugin));
 341       gst_object_unref (plugin);
 342     }
 343     p = g_list_next (p);
 344   }
 345   g_list_free (plugins);
 346 
 347   features = registry-&gt;priv-&gt;features;
 348   registry-&gt;priv-&gt;features = NULL;
 349 
 350   f = features;
 351   while (f) {
 352     GstPluginFeature *feature = f-&gt;data;
 353 
 354     if (feature) {
 355       GST_LOG_OBJECT (registry, &quot;removing feature %p (%s)&quot;, feature,
 356           GST_OBJECT_NAME (feature));
 357       gst_object_unparent (GST_OBJECT_CAST (feature));
 358     }
 359     f = g_list_next (f);
 360   }
 361   g_list_free (features);
 362 
 363   g_hash_table_destroy (registry-&gt;priv-&gt;feature_hash);
 364   registry-&gt;priv-&gt;feature_hash = NULL;
 365   g_hash_table_destroy (registry-&gt;priv-&gt;basename_hash);
 366   registry-&gt;priv-&gt;basename_hash = NULL;
 367 
 368   if (registry-&gt;priv-&gt;element_factory_list) {
 369     GST_DEBUG_OBJECT (registry, &quot;Cleaning up cached element factory list&quot;);
 370     gst_plugin_feature_list_free (registry-&gt;priv-&gt;element_factory_list);
 371   }
 372 
 373   if (registry-&gt;priv-&gt;typefind_factory_list) {
 374     GST_DEBUG_OBJECT (registry, &quot;Cleaning up cached typefind factory list&quot;);
 375     gst_plugin_feature_list_free (registry-&gt;priv-&gt;typefind_factory_list);
 376   }
 377 
 378   if (registry-&gt;priv-&gt;device_provider_factory_list) {
 379     GST_DEBUG_OBJECT (registry,
 380         &quot;Cleaning up cached device provider factory list&quot;);
 381     gst_plugin_feature_list_free (registry-&gt;priv-&gt;device_provider_factory_list);
 382   }
 383 
 384   G_OBJECT_CLASS (parent_class)-&gt;finalize (object);
 385 }
 386 
 387 /**
 388  * gst_registry_get:
 389  *
 390  * Retrieves the singleton plugin registry. The caller does not own a
 391  * reference on the registry, as it is alive as long as GStreamer is
 392  * initialized.
 393  *
 394  * Returns: (transfer none): the #GstRegistry.
 395  */
 396 GstRegistry *
 397 gst_registry_get (void)
 398 {
 399   GstRegistry *registry;
 400 
 401   g_mutex_lock (&amp;_gst_registry_mutex);
 402   if (G_UNLIKELY (!_gst_registry_default)) {
 403     _gst_registry_default = g_object_new (GST_TYPE_REGISTRY, NULL);
 404     gst_object_ref_sink (GST_OBJECT_CAST (_gst_registry_default));
 405   }
 406   registry = _gst_registry_default;
 407   g_mutex_unlock (&amp;_gst_registry_mutex);
 408 
 409   return registry;
 410 }
 411 
 412 #if 0
 413 /**
 414  * gst_registry_add_path:
 415  * @registry: the registry to add the path to
 416  * @path: the path to add to the registry
 417  *
 418  * Add the given path to the registry. The syntax of the
 419  * path is specific to the registry. If the path has already been
 420  * added, do nothing.
 421  */
 422 void
 423 gst_registry_add_path (GstRegistry * registry, const gchar * path)
 424 {
 425   g_return_if_fail (GST_IS_REGISTRY (registry));
 426   g_return_if_fail (path != NULL);
 427 
 428   if (strlen (path) == 0)
 429     goto empty_path;
 430 
 431   GST_OBJECT_LOCK (registry);
 432   if (g_list_find_custom (registry-&gt;priv-&gt;paths, path, (GCompareFunc) strcmp))
 433     goto was_added;
 434 
 435   GST_INFO (&quot;Adding plugin path: \&quot;%s\&quot;&quot;, path);
 436   registry-&gt;priv-&gt;paths =
 437       g_list_append (registry-&gt;priv-&gt;paths, g_strdup (path));
 438   GST_OBJECT_UNLOCK (registry);
 439 
 440   return;
 441 
 442 empty_path:
 443   {
 444     GST_INFO (&quot;Ignoring empty plugin path&quot;);
 445     return;
 446   }
 447 was_added:
 448   {
 449     g_warning (&quot;path %s already added to registry&quot;, path);
 450     GST_OBJECT_UNLOCK (registry);
 451     return;
 452   }
 453 }
 454 
 455 /**
 456  * gst_registry_get_path_list:
 457  * @registry: the registry to get the pathlist of
 458  *
 459  * Get the list of paths for the given registry.
 460  *
 461  * Returns: (transfer container) (element-type char*): A #GList of paths as
 462  *     strings. g_list_free after use.
 463  *
 464  * MT safe.
 465  */
 466 GList *
 467 gst_registry_get_path_list (GstRegistry * registry)
 468 {
 469   GList *list;
 470 
 471   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
 472 
 473   GST_OBJECT_LOCK (registry);
 474   /* We don&#39;t need to copy the strings, because they won&#39;t be deleted
 475    * as long as the GstRegistry is around */
 476   list = g_list_copy (registry-&gt;priv-&gt;paths);
 477   GST_OBJECT_UNLOCK (registry);
 478 
 479   return list;
 480 }
 481 #endif
 482 
 483 /**
 484  * gst_registry_add_plugin:
 485  * @registry: the registry to add the plugin to
 486  * @plugin: (transfer floating): the plugin to add
 487  *
 488  * Add the plugin to the registry. The plugin-added signal will be emitted.
 489  *
 490  * @plugin&#39;s reference count will be incremented, and any floating
 491  * reference will be removed (see gst_object_ref_sink())
 492  *
 493  * Returns: %TRUE on success.
 494  *
 495  * MT safe.
 496  */
 497 gboolean
 498 gst_registry_add_plugin (GstRegistry * registry, GstPlugin * plugin)
 499 {
 500   GstPlugin *existing_plugin;
 501 
 502   g_return_val_if_fail (GST_IS_REGISTRY (registry), FALSE);
 503   g_return_val_if_fail (GST_IS_PLUGIN (plugin), FALSE);
 504 
 505   GST_OBJECT_LOCK (registry);
 506   if (G_LIKELY (plugin-&gt;basename)) {
 507     /* we have a basename, see if we find the plugin */
 508     existing_plugin =
 509         gst_registry_lookup_bn_locked (registry, plugin-&gt;basename);
 510     if (existing_plugin) {
 511       GST_DEBUG_OBJECT (registry,
 512           &quot;Replacing existing plugin \&quot;%s\&quot; %p with new plugin %p for filename \&quot;%s\&quot;&quot;,
 513           GST_STR_NULL (existing_plugin-&gt;filename), existing_plugin, plugin,
 514           GST_STR_NULL (plugin-&gt;filename));
 515       /* If the new plugin is blacklisted and the existing one isn&#39;t cached, do not
 516        * accept if it&#39;s from a different location than the existing one */
 517       if (GST_OBJECT_FLAG_IS_SET (plugin, GST_PLUGIN_FLAG_BLACKLISTED) &amp;&amp;
 518           strcmp (plugin-&gt;filename, existing_plugin-&gt;filename)) {
 519         GST_WARNING_OBJECT (registry,
 520             &quot;Not replacing plugin because new one (%s) is blacklisted but for a different location than existing one (%s)&quot;,
 521             plugin-&gt;filename, existing_plugin-&gt;filename);
 522         /* Keep reference counting consistent */
 523         gst_object_ref_sink (plugin);
 524         gst_object_unref (plugin);
 525         GST_OBJECT_UNLOCK (registry);
 526         return FALSE;
 527       }
 528       registry-&gt;priv-&gt;plugins =
 529           g_list_remove (registry-&gt;priv-&gt;plugins, existing_plugin);
 530       --registry-&gt;priv-&gt;n_plugins;
 531       if (G_LIKELY (existing_plugin-&gt;basename))
 532         g_hash_table_remove (registry-&gt;priv-&gt;basename_hash,
 533             existing_plugin-&gt;basename);
 534       gst_object_unref (existing_plugin);
 535     }
 536   }
 537 
 538   GST_DEBUG_OBJECT (registry, &quot;adding plugin %p for filename \&quot;%s\&quot;&quot;,
 539       plugin, GST_STR_NULL (plugin-&gt;filename));
 540 
 541   registry-&gt;priv-&gt;plugins = g_list_prepend (registry-&gt;priv-&gt;plugins, plugin);
 542   ++registry-&gt;priv-&gt;n_plugins;
 543 
 544   if (G_LIKELY (plugin-&gt;basename))
 545     g_hash_table_replace (registry-&gt;priv-&gt;basename_hash, plugin-&gt;basename,
 546         plugin);
 547 
 548   gst_object_ref_sink (plugin);
 549   GST_OBJECT_UNLOCK (registry);
 550 
 551   GST_LOG_OBJECT (registry, &quot;emitting plugin-added for filename \&quot;%s\&quot;&quot;,
 552       GST_STR_NULL (plugin-&gt;filename));
 553   g_signal_emit (registry, gst_registry_signals[PLUGIN_ADDED], 0, plugin);
 554 
 555   return TRUE;
 556 }
 557 
 558 static void
 559 gst_registry_remove_features_for_plugin_unlocked (GstRegistry * registry,
 560     GstPlugin * plugin)
 561 {
 562   GList *f;
 563 
 564   g_return_if_fail (GST_IS_REGISTRY (registry));
 565   g_return_if_fail (GST_IS_PLUGIN (plugin));
 566 
 567   /* Remove all features for this plugin */
 568   f = registry-&gt;priv-&gt;features;
 569   while (f != NULL) {
 570     GList *next = g_list_next (f);
 571     GstPluginFeature *feature = f-&gt;data;
 572 
 573     if (G_UNLIKELY (feature &amp;&amp; feature-&gt;plugin == plugin)) {
 574       GST_DEBUG_OBJECT (registry, &quot;removing feature %p (%s) for plugin %p (%s)&quot;,
 575           feature, gst_plugin_feature_get_name (feature), plugin,
 576           plugin-&gt;desc.name);
 577 
 578       registry-&gt;priv-&gt;features =
 579           g_list_delete_link (registry-&gt;priv-&gt;features, f);
 580       g_hash_table_remove (registry-&gt;priv-&gt;feature_hash,
 581           GST_OBJECT_NAME (feature));
 582       gst_object_unparent (GST_OBJECT_CAST (feature));
 583     }
 584     f = next;
 585   }
 586   registry-&gt;priv-&gt;cookie++;
 587 }
 588 
 589 /**
 590  * gst_registry_remove_plugin:
 591  * @registry: the registry to remove the plugin from
 592  * @plugin: (transfer none): the plugin to remove
 593  *
 594  * Remove the plugin from the registry.
 595  *
 596  * MT safe.
 597  */
 598 void
 599 gst_registry_remove_plugin (GstRegistry * registry, GstPlugin * plugin)
 600 {
 601   g_return_if_fail (GST_IS_REGISTRY (registry));
 602   g_return_if_fail (GST_IS_PLUGIN (plugin));
 603 
 604   GST_DEBUG_OBJECT (registry, &quot;removing plugin %p (%s)&quot;,
 605       plugin, gst_plugin_get_name (plugin));
 606 
 607   GST_OBJECT_LOCK (registry);
 608   registry-&gt;priv-&gt;plugins = g_list_remove (registry-&gt;priv-&gt;plugins, plugin);
 609   --registry-&gt;priv-&gt;n_plugins;
 610   if (G_LIKELY (plugin-&gt;basename))
 611     g_hash_table_remove (registry-&gt;priv-&gt;basename_hash, plugin-&gt;basename);
 612   gst_registry_remove_features_for_plugin_unlocked (registry, plugin);
 613   GST_OBJECT_UNLOCK (registry);
 614   gst_object_unref (plugin);
 615 }
 616 
 617 /**
 618  * gst_registry_add_feature:
 619  * @registry: the registry to add the plugin to
 620  * @feature: (transfer floating): the feature to add
 621  *
 622  * Add the feature to the registry. The feature-added signal will be emitted.
 623  *
 624  * @feature&#39;s reference count will be incremented, and any floating
 625  * reference will be removed (see gst_object_ref_sink())
 626  *
 627  * Returns: %TRUE on success.
 628  *
 629  * MT safe.
 630  */
 631 gboolean
 632 gst_registry_add_feature (GstRegistry * registry, GstPluginFeature * feature)
 633 {
 634   GstPluginFeature *existing_feature;
 635 
 636   g_return_val_if_fail (GST_IS_REGISTRY (registry), FALSE);
 637   g_return_val_if_fail (GST_IS_PLUGIN_FEATURE (feature), FALSE);
 638   g_return_val_if_fail (GST_OBJECT_NAME (feature) != NULL, FALSE);
 639   g_return_val_if_fail (feature-&gt;plugin_name != NULL, FALSE);
 640 
 641   GST_OBJECT_LOCK (registry);
 642   existing_feature = gst_registry_lookup_feature_locked (registry,
 643       GST_OBJECT_NAME (feature));
 644   if (G_UNLIKELY (existing_feature)) {
 645     GST_DEBUG_OBJECT (registry, &quot;replacing existing feature %p (%s)&quot;,
 646         existing_feature, GST_OBJECT_NAME (feature));
 647     /* Remove the existing feature from the list now, before we insert the new
 648      * one, but don&#39;t unref yet because the hash is still storing a reference to
 649      * it. */
 650     registry-&gt;priv-&gt;features =
 651         g_list_remove (registry-&gt;priv-&gt;features, existing_feature);
 652   }
 653 
 654   GST_DEBUG_OBJECT (registry, &quot;adding feature %p (%s)&quot;, feature,
 655       GST_OBJECT_NAME (feature));
 656 
 657   registry-&gt;priv-&gt;features = g_list_prepend (registry-&gt;priv-&gt;features, feature);
 658   g_hash_table_replace (registry-&gt;priv-&gt;feature_hash, GST_OBJECT_NAME (feature),
 659       feature);
 660 
 661   if (G_UNLIKELY (existing_feature)) {
 662     /* We unref now. No need to remove the feature name from the hash table, it
 663      * got replaced by the new feature */
 664     gst_object_unparent (GST_OBJECT_CAST (existing_feature));
 665   }
 666 
 667   gst_object_set_parent (GST_OBJECT_CAST (feature), GST_OBJECT_CAST (registry));
 668 
 669   registry-&gt;priv-&gt;cookie++;
 670   GST_OBJECT_UNLOCK (registry);
 671 
 672   GST_LOG_OBJECT (registry, &quot;emitting feature-added for %s&quot;,
 673       GST_OBJECT_NAME (feature));
 674   g_signal_emit (registry, gst_registry_signals[FEATURE_ADDED], 0, feature);
 675 
 676   return TRUE;
 677 }
 678 
 679 /**
 680  * gst_registry_remove_feature:
 681  * @registry: the registry to remove the feature from
 682  * @feature: (transfer none): the feature to remove
 683  *
 684  * Remove the feature from the registry.
 685  *
 686  * MT safe.
 687  */
 688 void
 689 gst_registry_remove_feature (GstRegistry * registry, GstPluginFeature * feature)
 690 {
 691   g_return_if_fail (GST_IS_REGISTRY (registry));
 692   g_return_if_fail (GST_IS_PLUGIN_FEATURE (feature));
 693 
 694   GST_DEBUG_OBJECT (registry, &quot;removing feature %p (%s)&quot;,
 695       feature, gst_plugin_feature_get_name (feature));
 696 
 697   GST_OBJECT_LOCK (registry);
 698   registry-&gt;priv-&gt;features = g_list_remove (registry-&gt;priv-&gt;features, feature);
 699   g_hash_table_remove (registry-&gt;priv-&gt;feature_hash, GST_OBJECT_NAME (feature));
 700   registry-&gt;priv-&gt;cookie++;
 701   GST_OBJECT_UNLOCK (registry);
 702 
 703   gst_object_unparent ((GstObject *) feature);
 704 }
 705 
 706 /**
 707  * gst_registry_plugin_filter:
 708  * @registry: registry to query
 709  * @filter: (scope call): the filter to use
 710  * @first: only return first match
 711  * @user_data: (closure): user data passed to the filter function
 712  *
 713  * Runs a filter against all plugins in the registry and returns a #GList with
 714  * the results. If the first flag is set, only the first match is
 715  * returned (as a list with a single object).
 716  * Every plugin is reffed; use gst_plugin_list_free() after use, which
 717  * will unref again.
 718  *
 719  * Returns: (transfer full) (element-type Gst.Plugin): a #GList of #GstPlugin.
 720  *     Use gst_plugin_list_free() after usage.
 721  *
 722  * MT safe.
 723  */
 724 GList *
 725 gst_registry_plugin_filter (GstRegistry * registry,
 726     GstPluginFilter filter, gboolean first, gpointer user_data)
 727 {
 728   GstPlugin **plugins;
 729   GList *walk, *list = NULL;
 730   guint n_plugins, i;
 731 
 732   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
 733 
 734   GST_OBJECT_LOCK (registry);
 735   n_plugins = registry-&gt;priv-&gt;n_plugins;
 736   plugins = g_newa (GstPlugin *, n_plugins + 1);
 737   for (walk = registry-&gt;priv-&gt;plugins, i = 0; walk != NULL; walk = walk-&gt;next)
 738     plugins[i++] = gst_object_ref (walk-&gt;data);
 739   GST_OBJECT_UNLOCK (registry);
 740 
 741   for (i = 0; i &lt; n_plugins; ++i) {
 742     if (filter == NULL || filter (plugins[i], user_data)) {
 743       list = g_list_prepend (list, gst_object_ref (plugins[i]));
 744 
<a name="4" id="anc4"></a><span class="line-modified"> 745         if (first)</span>
<span class="line-modified"> 746           break;</span>
<span class="line-removed"> 747   }</span>
 748     }
<a name="5" id="anc5"></a>
 749 
 750   for (i = 0; i &lt; n_plugins; ++i)
 751     gst_object_unref (plugins[i]);
 752 
 753   return list;
 754 }
 755 
 756 typedef struct
 757 {
 758   const gchar *name;
 759   GType type;
 760 } GstTypeNameData;
 761 
 762 static gboolean
 763 gst_plugin_feature_type_name_filter (GstPluginFeature * feature,
 764     GstTypeNameData * data)
 765 {
 766   g_assert (GST_IS_PLUGIN_FEATURE (feature));
 767 
 768   return ((data-&gt;type == 0 || data-&gt;type == G_OBJECT_TYPE (feature)) &amp;&amp;
 769       (data-&gt;name == NULL || !strcmp (data-&gt;name, GST_OBJECT_NAME (feature))));
 770 }
 771 
 772 /* returns TRUE if the list was changed
 773  *
 774  * Must be called with the object lock taken */
 775 static gboolean
 776 gst_registry_get_feature_list_or_create (GstRegistry * registry,
 777     GList ** previous, guint32 * cookie, GType type)
 778 {
 779   gboolean res = FALSE;
 780   GstRegistryPrivate *priv = registry-&gt;priv;
 781 
 782   if (G_UNLIKELY (!*previous || priv-&gt;cookie != *cookie)) {
 783     GstTypeNameData data;
 784     const GList *walk;
 785 
 786     if (*previous) {
 787       gst_plugin_feature_list_free (*previous);
 788       *previous = NULL;
 789     }
 790 
 791     data.type = type;
 792     data.name = NULL;
 793 
 794     for (walk = registry-&gt;priv-&gt;features; walk != NULL; walk = walk-&gt;next) {
 795       GstPluginFeature *feature = walk-&gt;data;
 796 
 797       if (gst_plugin_feature_type_name_filter (feature, &amp;data)) {
 798         *previous = g_list_prepend (*previous, gst_object_ref (feature));
 799       }
 800     }
 801 
 802     *cookie = priv-&gt;cookie;
 803     res = TRUE;
 804   }
 805 
 806   return res;
 807 }
 808 
 809 static gint
 810 type_find_factory_rank_cmp (const GstPluginFeature * fac1,
 811     const GstPluginFeature * fac2)
 812 {
 813   if (G_LIKELY (fac1-&gt;rank != fac2-&gt;rank))
 814     return fac2-&gt;rank - fac1-&gt;rank;
 815 
 816   /* to make the order in which things happen more deterministic,
 817    * sort by name when the ranks are the same. */
 818   return strcmp (GST_OBJECT_NAME (fac1), GST_OBJECT_NAME (fac2));
 819 }
 820 
 821 static GList *
 822 gst_registry_get_element_factory_list (GstRegistry * registry)
 823 {
 824   GList *list;
 825 
 826   GST_OBJECT_LOCK (registry);
 827 
 828   gst_registry_get_feature_list_or_create (registry,
 829       &amp;registry-&gt;priv-&gt;element_factory_list, &amp;registry-&gt;priv-&gt;efl_cookie,
 830       GST_TYPE_ELEMENT_FACTORY);
 831 
 832   /* Return reffed copy */
 833   list = gst_plugin_feature_list_copy (registry-&gt;priv-&gt;element_factory_list);
 834 
 835   GST_OBJECT_UNLOCK (registry);
 836 
 837   return list;
 838 }
 839 
 840 static GList *
 841 gst_registry_get_typefind_factory_list (GstRegistry * registry)
 842 {
 843   GList *list;
 844 
 845   GST_OBJECT_LOCK (registry);
 846 
 847   if (G_UNLIKELY (gst_registry_get_feature_list_or_create (registry,
 848               &amp;registry-&gt;priv-&gt;typefind_factory_list,
 849               &amp;registry-&gt;priv-&gt;tfl_cookie, GST_TYPE_TYPE_FIND_FACTORY)))
 850     registry-&gt;priv-&gt;typefind_factory_list =
 851         g_list_sort (registry-&gt;priv-&gt;typefind_factory_list,
 852         (GCompareFunc) type_find_factory_rank_cmp);
 853 
 854   /* Return reffed copy */
 855   list = gst_plugin_feature_list_copy (registry-&gt;priv-&gt;typefind_factory_list);
 856 
 857   GST_OBJECT_UNLOCK (registry);
 858 
 859   return list;
 860 }
 861 
 862 #ifndef GSTREAMER_LITE
 863 static GList *
 864 gst_registry_get_device_provider_factory_list (GstRegistry * registry)
 865 {
 866   GList *list;
 867 
 868   GST_OBJECT_LOCK (registry);
 869 
 870   gst_registry_get_feature_list_or_create (registry,
 871       &amp;registry-&gt;priv-&gt;device_provider_factory_list,
 872       &amp;registry-&gt;priv-&gt;dmfl_cookie, GST_TYPE_DEVICE_PROVIDER_FACTORY);
 873 
 874   /* Return reffed copy */
 875   list =
 876       gst_plugin_feature_list_copy (registry-&gt;
 877       priv-&gt;device_provider_factory_list);
 878 
 879   GST_OBJECT_UNLOCK (registry);
 880 
 881   return list;
 882 }
 883 #endif // GSTREAMER_LITE
 884 
 885 /**
 886  * gst_registry_feature_filter:
 887  * @registry: registry to query
 888  * @filter: (scope call): the filter to use
 889  * @first: only return first match
 890  * @user_data: (closure): user data passed to the filter function
 891  *
 892  * Runs a filter against all features of the plugins in the registry
 893  * and returns a GList with the results.
 894  * If the first flag is set, only the first match is
 895  * returned (as a list with a single object).
 896  *
 897  * Returns: (transfer full) (element-type Gst.PluginFeature): a #GList of
 898  *     #GstPluginFeature. Use gst_plugin_feature_list_free() after usage.
 899  *
 900  * MT safe.
 901  */
 902 GList *
 903 gst_registry_feature_filter (GstRegistry * registry,
 904     GstPluginFeatureFilter filter, gboolean first, gpointer user_data)
 905 {
 906   GstPluginFeature **features;
 907   GList *walk, *list = NULL;
 908   guint n_features, i;
 909 
 910   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
 911 
 912   GST_OBJECT_LOCK (registry);
 913   n_features = g_hash_table_size (registry-&gt;priv-&gt;feature_hash);
 914   features = g_newa (GstPluginFeature *, n_features + 1);
 915   for (walk = registry-&gt;priv-&gt;features, i = 0; walk != NULL; walk = walk-&gt;next)
 916     features[i++] = gst_object_ref (walk-&gt;data);
 917   GST_OBJECT_UNLOCK (registry);
 918 
 919   for (i = 0; i &lt; n_features; ++i) {
 920     if (filter == NULL || filter (features[i], user_data)) {
 921       list = g_list_prepend (list, gst_object_ref (features[i]));
 922 
<a name="6" id="anc6"></a><span class="line-modified"> 923         if (first)</span>
<span class="line-modified"> 924           break;</span>
<span class="line-removed"> 925   }</span>
 926     }
<a name="7" id="anc7"></a>
 927 
 928   for (i = 0; i &lt; n_features; ++i)
 929     gst_object_unref (features[i]);
 930 
 931   return list;
 932 }
 933 
 934 static gboolean
 935 gst_registry_plugin_name_filter (GstPlugin * plugin, const gchar * name)
 936 {
 937   return (plugin-&gt;desc.name &amp;&amp; !strcmp (plugin-&gt;desc.name, name));
 938 }
 939 
 940 /**
 941  * gst_registry_find_plugin:
 942  * @registry: the registry to search
 943  * @name: the plugin name to find
 944  *
 945  * Find the plugin with the given name in the registry.
 946  * The plugin will be reffed; caller is responsible for unreffing.
 947  *
 948  * Returns: (transfer full) (nullable): the plugin with the given name
 949  *     or %NULL if the plugin was not found. gst_object_unref() after
 950  *     usage.
 951  *
 952  * MT safe.
 953  */
 954 GstPlugin *
 955 gst_registry_find_plugin (GstRegistry * registry, const gchar * name)
 956 {
 957   GList *walk;
 958   GstPlugin *result = NULL;
 959 
 960   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
 961   g_return_val_if_fail (name != NULL, NULL);
 962 
 963   walk = gst_registry_plugin_filter (registry,
 964       (GstPluginFilter) gst_registry_plugin_name_filter, TRUE, (gpointer) name);
 965   if (walk) {
 966     result = GST_PLUGIN_CAST (walk-&gt;data);
 967 
 968     gst_object_ref (result);
 969     gst_plugin_list_free (walk);
 970   }
 971 
 972   return result;
 973 }
 974 
 975 /**
 976  * gst_registry_find_feature:
 977  * @registry: the registry to search
 978  * @name: the pluginfeature name to find
 979  * @type: the pluginfeature type to find
 980  *
 981  * Find the pluginfeature with the given name and type in the registry.
 982  *
 983  * Returns: (transfer full) (nullable): the pluginfeature with the
 984  *     given name and type or %NULL if the plugin was not
 985  *     found. gst_object_unref() after usage.
 986  *
 987  * MT safe.
 988  */
 989 GstPluginFeature *
 990 gst_registry_find_feature (GstRegistry * registry, const gchar * name,
 991     GType type)
 992 {
 993   GstPluginFeature *feature = NULL;
 994 
 995   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
 996   g_return_val_if_fail (name != NULL, NULL);
 997   g_return_val_if_fail (g_type_is_a (type, GST_TYPE_PLUGIN_FEATURE), NULL);
 998 
 999   feature = gst_registry_lookup_feature (registry, name);
1000   if (feature &amp;&amp; !g_type_is_a (G_TYPE_FROM_INSTANCE (feature), type)) {
1001     gst_object_unref (feature);
1002     feature = NULL;
1003   }
1004 
1005   return feature;
1006 }
1007 
1008 /**
1009  * gst_registry_get_feature_list:
1010  * @registry: a #GstRegistry
1011  * @type: a #GType.
1012  *
1013  * Retrieves a #GList of #GstPluginFeature of @type.
1014  *
1015  * Returns: (transfer full) (element-type Gst.PluginFeature): a #GList of
1016  *     #GstPluginFeature of @type. Use gst_plugin_feature_list_free() after use
1017  *
1018  * MT safe.
1019  */
1020 GList *
1021 gst_registry_get_feature_list (GstRegistry * registry, GType type)
1022 {
1023   GstTypeNameData data;
1024 
1025   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
1026   g_return_val_if_fail (g_type_is_a (type, GST_TYPE_PLUGIN_FEATURE), NULL);
1027 
1028   /* Speed up */
1029   if (type == GST_TYPE_ELEMENT_FACTORY)
1030     return gst_registry_get_element_factory_list (registry);
1031   else if (type == GST_TYPE_TYPE_FIND_FACTORY)
1032     return gst_registry_get_typefind_factory_list (registry);
1033 #ifndef GSTREAMER_LITE
1034   else if (type == GST_TYPE_DEVICE_PROVIDER_FACTORY)
1035     return gst_registry_get_device_provider_factory_list (registry);
1036 #endif // GSTREAMER_LITE
1037 
1038   data.type = type;
1039   data.name = NULL;
1040 
1041   return gst_registry_feature_filter (registry,
1042       (GstPluginFeatureFilter) gst_plugin_feature_type_name_filter,
1043       FALSE, &amp;data);
1044 }
1045 
1046 /**
1047  * gst_registry_get_plugin_list:
1048  * @registry: the registry to search
1049  *
1050  * Get a copy of all plugins registered in the given registry. The refcount
1051  * of each element in the list in incremented.
1052  *
1053  * Returns: (transfer full) (element-type Gst.Plugin): a #GList of #GstPlugin.
1054  *     Use gst_plugin_list_free() after usage.
1055  *
1056  * MT safe.
1057  */
1058 GList *
1059 gst_registry_get_plugin_list (GstRegistry * registry)
1060 {
1061   GList *list;
1062   GList *g;
1063 
1064   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
1065 
1066   GST_OBJECT_LOCK (registry);
1067   list = g_list_copy (registry-&gt;priv-&gt;plugins);
1068   for (g = list; g; g = g-&gt;next) {
1069     gst_object_ref (GST_PLUGIN_CAST (g-&gt;data));
1070   }
1071   GST_OBJECT_UNLOCK (registry);
1072 
1073   return list;
1074 }
1075 
1076 static GstPluginFeature *
1077 gst_registry_lookup_feature_locked (GstRegistry * registry, const char *name)
1078 {
1079   return g_hash_table_lookup (registry-&gt;priv-&gt;feature_hash, name);
1080 }
1081 
1082 /**
1083  * gst_registry_lookup_feature:
1084  * @registry: a #GstRegistry
1085  * @name: a #GstPluginFeature name
1086  *
1087  * Find a #GstPluginFeature with @name in @registry.
1088  *
1089  * Returns: (transfer full): a #GstPluginFeature with its refcount incremented,
1090  *     use gst_object_unref() after usage.
1091  *
1092  * MT safe.
1093  */
1094 GstPluginFeature *
1095 gst_registry_lookup_feature (GstRegistry * registry, const char *name)
1096 {
1097   GstPluginFeature *feature;
1098 
1099   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
1100   g_return_val_if_fail (name != NULL, NULL);
1101 
1102   GST_OBJECT_LOCK (registry);
1103   feature = gst_registry_lookup_feature_locked (registry, name);
1104   if (feature)
1105     gst_object_ref (feature);
1106   GST_OBJECT_UNLOCK (registry);
1107 
1108   return feature;
1109 }
1110 
1111 static GstPlugin *
1112 gst_registry_lookup_bn_locked (GstRegistry * registry, const char *basename)
1113 {
1114   return g_hash_table_lookup (registry-&gt;priv-&gt;basename_hash, basename);
1115 }
1116 
1117 static GstPlugin *
1118 gst_registry_lookup_bn (GstRegistry * registry, const char *basename)
1119 {
1120   GstPlugin *plugin;
1121 
1122   GST_OBJECT_LOCK (registry);
1123   plugin = gst_registry_lookup_bn_locked (registry, basename);
1124   if (plugin)
1125     gst_object_ref (plugin);
1126   GST_OBJECT_UNLOCK (registry);
1127 
1128   return plugin;
1129 }
1130 
1131 /**
1132  * gst_registry_lookup:
1133  * @registry: the registry to look up in
1134  * @filename: the name of the file to look up
1135  *
1136  * Look up a plugin in the given registry with the given filename.
1137  * If found, plugin is reffed.
1138  *
1139  * Returns: (transfer full) (nullable): the #GstPlugin if found, or
1140  *     %NULL if not.  gst_object_unref() after usage.
1141  */
1142 GstPlugin *
1143 gst_registry_lookup (GstRegistry * registry, const char *filename)
1144 {
1145   GstPlugin *plugin;
1146   gchar *basename;
1147 
1148   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
1149   g_return_val_if_fail (filename != NULL, NULL);
1150 
1151   basename = g_path_get_basename (filename);
1152   if (G_UNLIKELY (basename == NULL))
1153     return NULL;
1154 
1155   plugin = gst_registry_lookup_bn (registry, basename);
1156 
1157   g_free (basename);
1158 
1159   return plugin;
1160 }
1161 
1162 typedef enum
1163 {
1164   REGISTRY_SCAN_HELPER_NOT_STARTED = 0,
1165   REGISTRY_SCAN_HELPER_DISABLED,
1166   REGISTRY_SCAN_HELPER_RUNNING
1167 } GstRegistryScanHelperState;
1168 
1169 typedef struct
1170 {
1171   GstRegistry *registry;
1172   GstRegistryScanHelperState helper_state;
1173   GstPluginLoader *helper;
1174   gboolean changed;
1175 } GstRegistryScanContext;
1176 
1177 static void
1178 init_scan_context (GstRegistryScanContext * context, GstRegistry * registry)
1179 {
1180   gboolean do_fork;
1181 
1182   context-&gt;registry = registry;
1183 
1184   /* see if forking is enabled and set up the scan helper state accordingly */
1185   do_fork = _gst_enable_registry_fork;
1186   if (do_fork) {
1187     const gchar *fork_env;
1188 
1189     /* forking enabled, see if it is disabled with an env var */
1190     if ((fork_env = g_getenv (&quot;GST_REGISTRY_FORK&quot;))) {
1191       /* fork enabled for any value different from &quot;no&quot; */
1192       do_fork = strcmp (fork_env, &quot;no&quot;) != 0;
1193     }
1194   }
1195 
1196   if (do_fork)
1197     context-&gt;helper_state = REGISTRY_SCAN_HELPER_NOT_STARTED;
1198   else
1199     context-&gt;helper_state = REGISTRY_SCAN_HELPER_DISABLED;
1200 
1201   context-&gt;helper = NULL;
1202   context-&gt;changed = FALSE;
1203 }
1204 
1205 static void
1206 clear_scan_context (GstRegistryScanContext * context)
1207 {
1208   if (context-&gt;helper) {
1209     context-&gt;changed |= _priv_gst_plugin_loader_funcs.destroy (context-&gt;helper);
1210     context-&gt;helper = NULL;
1211   }
1212 }
1213 
1214 static gboolean
1215 gst_registry_scan_plugin_file (GstRegistryScanContext * context,
1216     const gchar * filename, off_t file_size, time_t file_mtime)
1217 {
1218   gboolean changed = FALSE;
1219   GstPlugin *newplugin = NULL;
1220 
1221 #ifdef G_OS_WIN32
1222   /* Disable external plugin loader on Windows until it is ported properly. */
1223   context-&gt;helper_state = REGISTRY_SCAN_HELPER_DISABLED;
1224 #endif
1225 
1226 
1227   /* Have a plugin to load - see if the scan-helper needs starting */
1228   if (context-&gt;helper_state == REGISTRY_SCAN_HELPER_NOT_STARTED) {
1229     GST_DEBUG (&quot;Starting plugin scanner for file %s&quot;, filename);
1230     context-&gt;helper = _priv_gst_plugin_loader_funcs.create (context-&gt;registry);
1231     if (context-&gt;helper != NULL)
1232       context-&gt;helper_state = REGISTRY_SCAN_HELPER_RUNNING;
1233     else {
1234       GST_WARNING (&quot;Failed starting plugin scanner. Scanning in-process&quot;);
1235       context-&gt;helper_state = REGISTRY_SCAN_HELPER_DISABLED;
1236     }
1237   }
1238 
1239   if (context-&gt;helper_state == REGISTRY_SCAN_HELPER_RUNNING) {
1240     GST_DEBUG (&quot;Using scan-helper to load plugin %s&quot;, filename);
1241     if (!_priv_gst_plugin_loader_funcs.load (context-&gt;helper,
1242             filename, file_size, file_mtime)) {
1243       g_warning (&quot;External plugin loader failed. This most likely means that &quot;
1244           &quot;the plugin loader helper binary was not found or could not be run. &quot;
1245           &quot;You might need to set the GST_PLUGIN_SCANNER environment variable &quot;
1246           &quot;if your setup is unusual. This should normally not be required &quot;
1247           &quot;though.&quot;);
1248       context-&gt;helper_state = REGISTRY_SCAN_HELPER_DISABLED;
1249     }
1250   }
1251 
1252   /* Check if the helper is disabled (or just got disabled above) */
1253   if (context-&gt;helper_state == REGISTRY_SCAN_HELPER_DISABLED) {
1254     /* Load plugin the old fashioned way... */
1255 
1256     /* We don&#39;t use a GError here because a failure to load some shared
1257      * objects as plugins is normal (particularly in the uninstalled case)
1258      */
1259     newplugin = _priv_gst_plugin_load_file_for_registry (filename,
1260         context-&gt;registry, NULL);
1261   }
1262 
1263   if (newplugin) {
1264     GST_DEBUG_OBJECT (context-&gt;registry, &quot;marking new plugin %p as registered&quot;,
1265         newplugin);
1266     newplugin-&gt;registered = TRUE;
1267     gst_object_unref (newplugin);
1268     changed = TRUE;
1269   }
1270 #ifndef GST_DISABLE_REGISTRY
1271   if (!__registry_reuse_plugin_scanner) {
1272     clear_scan_context (context);
1273     context-&gt;helper_state = REGISTRY_SCAN_HELPER_NOT_STARTED;
1274   }
1275 #endif
1276 
1277   return changed;
1278 }
1279 
1280 #ifndef GSTREAMER_LITE
1281 static gboolean
1282 is_blacklisted_hidden_directory (const gchar * dirent)
1283 {
1284   if (G_LIKELY (dirent[0] != &#39;.&#39;))
1285     return FALSE;
1286 
1287   /* skip the .debug directory, these contain elf files that are not
1288    * useful or worse, can crash dlopen () */
1289   if (strcmp (dirent, &quot;.debug&quot;) == 0)
1290     return TRUE;
1291 
1292   /* can also skip .git and .deps dirs, those won&#39;t contain useful files.
1293    * This speeds up scanning a bit in uninstalled setups. */
1294   if (strcmp (dirent, &quot;.git&quot;) == 0 || strcmp (dirent, &quot;.deps&quot;) == 0)
1295     return TRUE;
1296 
1297   return FALSE;
1298 }
1299 #endif
1300 
1301 #ifdef GSTREAMER_LITE
1302 // Only for Linux 32-bit
1303 #if defined(LINUX) &amp;&amp; !defined(__x86_64__)
1304 gpointer load_plugin(gpointer data)
1305 {
1306   return dlopen((gchar*)data, RTLD_GLOBAL|RTLD_NOW);
1307 }
1308 
1309 gboolean preload_plugin_on_thread(int version, gchar *filename)
1310 {
1311   void *handle = NULL;
1312 
1313   if (version != 57) // Only needed for 57
1314     return TRUE;
1315 
1316   if (filename == NULL)
1317     return FALSE;
1318 
1319   GThread *thread = g_thread_new(NULL, load_plugin, filename);
1320   if (thread != NULL) {
1321     handle = g_thread_join(thread);
1322     if (handle != NULL) {
1323       return TRUE;
1324     }
1325   }
1326 
1327   return FALSE;
1328 }
1329 #endif
1330 #endif // GSTREAMER_LITE
1331 
1332 static gboolean
1333 gst_registry_scan_path_level (GstRegistryScanContext * context,
1334     const gchar * path, int level)
1335 {
1336 #ifndef GSTREAMER_LITE
1337   GDir *dir;
1338   const gchar *dirent;
1339 #endif // GSTREAMER_LITE
1340   gchar *filename;
1341   GstPlugin *plugin;
1342   gboolean changed = FALSE;
1343 #ifdef GSTREAMER_LITE
1344   gint gstlite_plugins_list_index = 0;
1345   struct stat file_status;
1346   gchar *filename_partial;
1347 #ifdef LINUX
1348   void *avcHandle = NULL;
1349   gboolean isAVCFFMPEG = FALSE;
1350 #endif // LINUX
1351 #endif // GSTREAMER_LITE
1352 
1353 #ifndef GSTREAMER_LITE
1354   dir = g_dir_open (path, 0, NULL);
1355   if (!dir)
1356     return FALSE;
1357 
1358   while ((dirent = g_dir_read_name (dir))) {
1359     GStatBuf file_status;
1360 
1361     filename = g_build_filename (path, dirent, NULL);
1362     if (g_stat (filename, &amp;file_status) &lt; 0) {
1363       /* Plugin will be removed from cache after the scan completes if it
1364        * is still marked &#39;cached&#39; */
1365       g_free (filename);
1366       continue;
1367     }
1368 
1369     if (file_status.st_mode &amp; S_IFDIR) {
1370       if (G_UNLIKELY (is_blacklisted_hidden_directory (dirent))) {
1371         GST_TRACE_OBJECT (context-&gt;registry, &quot;ignoring %s directory&quot;, dirent);
1372         g_free (filename);
1373         continue;
1374       }
1375       /* FIXME 2.0: Don&#39;t recurse into directories, this behaviour
1376        * is inconsistent with other PATH environment variables
1377        */
1378       if (level &gt; 0) {
1379         GST_LOG_OBJECT (context-&gt;registry, &quot;recursing into directory %s&quot;,
1380             filename);
1381         changed |= gst_registry_scan_path_level (context, filename, level - 1);
1382       } else {
1383         GST_LOG_OBJECT (context-&gt;registry, &quot;not recursing into directory %s, &quot;
1384             &quot;recursion level too deep&quot;, filename);
1385       }
1386       g_free (filename);
1387       continue;
1388     }
1389     if (!(file_status.st_mode &amp; S_IFREG)) {
1390       GST_TRACE_OBJECT (context-&gt;registry, &quot;%s is not a regular file, ignoring&quot;,
1391           filename);
1392       g_free (filename);
1393       continue;
1394     }
1395     if (!g_str_has_suffix (dirent, &quot;.&quot; G_MODULE_SUFFIX)
1396 #ifdef GST_EXTRA_MODULE_SUFFIX
1397         &amp;&amp; !g_str_has_suffix (dirent, GST_EXTRA_MODULE_SUFFIX)
1398 #endif
1399         ) {
1400       GST_TRACE_OBJECT (context-&gt;registry,
1401           &quot;extension is not recognized as module file, ignoring file %s&quot;,
1402           filename);
1403       g_free (filename);
1404       continue;
1405     }
1406 #else // GSTREAMER_LITE
1407 
1408   for (gstlite_plugins_list_index = 0; gstlite_plugins_list[gstlite_plugins_list_index] != NULL; gstlite_plugins_list_index++) {
1409     filename_partial = g_build_filename (path, gstlite_plugins_list[gstlite_plugins_list_index], NULL);
1410 #ifdef LINUX
1411     if (g_str_has_suffix(filename_partial, &quot;libavplugin&quot;)) { // Check libav version and load correspondent module.
1412       int plugin_version = 0;
1413       // Look for libavcodec and check its version to figure out if it is
1414       // libav or ffmpeg. Starting from 57 and up
1415       int vi = (sizeof(AVCODEC_EXPLICIT_VERSIONS)/sizeof(AVCODEC_EXPLICIT_VERSIONS[0]));
1416       while(!avcHandle &amp;&amp; --vi &gt;= 0) {
1417         int version = AVCODEC_EXPLICIT_VERSIONS[vi];
1418         gchar* libname = g_strdup_printf(&quot;libavcodec.so.%d&quot;, version);
1419         avcHandle = dlopen(libname, RTLD_NOW);
1420         g_free(libname);
1421       }
1422 
1423       // Check if it is libav or ffmpeg
1424       if (avcHandle) {
1425         unsigned int (*av_version)(void);
1426         av_version = dlsym(avcHandle, &quot;avcodec_version&quot;);
1427         if (av_version != NULL) {
1428           unsigned int version = (*av_version)();
1429           unsigned int micro = version &amp; 0xFF;
1430           if (micro &gt;= 100)
1431             isAVCFFMPEG = TRUE;
1432           plugin_version = AVCODEC_EXPLICIT_VERSIONS[vi];
1433         } else { // Something wrong
1434           dlclose(avcHandle);
1435           avcHandle = NULL;
1436         }
1437       }
1438 
1439       // Look for libavcodec-ffmpeg. For 56 only
1440       if (avcHandle == NULL) {
1441         vi = (sizeof(AVCODEC_FFMPEG_EXPLICIT_VERSIONS)/sizeof(AVCODEC_FFMPEG_EXPLICIT_VERSIONS[0]));
1442         while(!avcHandle &amp;&amp; --vi &gt;= 0) {
1443           int version = AVCODEC_FFMPEG_EXPLICIT_VERSIONS[vi];
1444           gchar* libname = g_strdup_printf(&quot;libavcodec-ffmpeg.so.%d&quot;, version);
1445           avcHandle = dlopen(libname, RTLD_NOW);
1446           g_free(libname);
1447         }
1448 
1449         if (avcHandle) {
1450           plugin_version = AVCODEC_FFMPEG_EXPLICIT_VERSIONS[vi];
1451           isAVCFFMPEG = TRUE;
1452         }
1453       }
1454 
1455       // Looks for libav 56 and below
1456       if (avcHandle == NULL) {
1457         vi = (sizeof(AVCODEC_LIBAV_EXPLICIT_VERSIONS)/sizeof(AVCODEC_LIBAV_EXPLICIT_VERSIONS[0]));
1458         while(!avcHandle &amp;&amp; --vi &gt;= 0) {
1459           int version = AVCODEC_LIBAV_EXPLICIT_VERSIONS[vi];
1460           gchar* libname = g_strdup_printf(&quot;libavcodec.so.%d&quot;, version);
1461           avcHandle = dlopen(libname, RTLD_NOW);
1462           g_free(libname);
1463         }
1464 
1465         if (avcHandle) {
1466           plugin_version = AVCODEC_LIBAV_EXPLICIT_VERSIONS[vi];
1467         }
1468       }
1469 
1470       if (avcHandle) {
1471         dlclose(avcHandle);
1472         avcHandle = NULL;
1473 
1474         // Try simple name first. OpenJDK build may contain the latest bits.
1475         filename = g_strdup_printf(&quot;%s%s&quot;, filename_partial, GST_EXTRA_MODULE_SUFFIX);
1476         if (g_stat (filename, &amp;file_status) &lt; 0) { // Not available, create a versioned filename
1477           g_free(filename);
1478           if (isAVCFFMPEG)
1479             filename = g_strdup_printf(&quot;%s-ffmpeg-%d%s&quot;, filename_partial, plugin_version, GST_EXTRA_MODULE_SUFFIX);
1480           else
1481             filename = g_strdup_printf(&quot;%s-%d%s&quot;, filename_partial, plugin_version, GST_EXTRA_MODULE_SUFFIX);
1482         }
1483 #if defined(LINUX) &amp;&amp; !defined(__x86_64__)
1484         if (!preload_plugin_on_thread(plugin_version, filename)) {
1485           g_free(filename_partial);
1486           filename_partial = NULL;
1487           g_free(filename);
1488           filename = NULL;
1489           continue; // If we fail preload do not load such plugin.
1490         }
1491 #endif
1492       } else {
1493         g_free(filename_partial);
1494         continue; // No libavcodec.so installed.
1495       }
1496     } else {
1497       filename = g_strconcat(filename_partial, GST_EXTRA_MODULE_SUFFIX, NULL);
1498     }
1499 #else
1500     filename = g_strconcat(filename_partial, GST_EXTRA_MODULE_SUFFIX, NULL);
1501 #endif
1502     g_free(filename_partial);
1503 
1504     if (g_stat (filename, &amp;file_status) &lt; 0) {
1505       /* Plugin will be removed from cache after the scan completes if it
1506        * is still marked &#39;cached&#39; */
1507       g_free (filename);
1508       continue;
1509     }
1510 #endif // GSTREAMER_LITE
1511 
1512     GST_LOG_OBJECT (context-&gt;registry, &quot;file %s looks like a possible module&quot;,
1513         filename);
1514 
1515 #ifndef GSTREAMER_LITE
1516     /* try to avoid unnecessary plugin-move pain */
1517     if (g_str_has_prefix (dirent, &quot;libgstvalve&quot;) ||
1518         g_str_has_prefix (dirent, &quot;libgstselector&quot;)) {
1519       GST_WARNING_OBJECT (context-&gt;registry, &quot;ignoring old plugin %s which &quot;
1520           &quot;has been merged into the corelements plugin&quot;, filename);
1521       /* Plugin will be removed from cache after the scan completes if it
1522        * is still marked &#39;cached&#39; */
1523       g_free (filename);
1524       continue;
1525     }
1526 
1527     /* plug-ins are considered unique by basename; if the given name
1528      * was already seen by the registry, we ignore it */
1529     plugin = gst_registry_lookup_bn (context-&gt;registry, dirent);
1530 #else // GSTREAMER_LITE
1531     plugin = gst_registry_lookup (context-&gt;registry, filename);
1532 #endif // GSTREAMER_LITE
1533     if (plugin) {
1534       gboolean env_vars_changed, deps_changed = FALSE;
1535 
1536       if (plugin-&gt;registered) {
1537         GST_DEBUG_OBJECT (context-&gt;registry,
1538             &quot;plugin already registered from path \&quot;%s\&quot;&quot;,
1539             GST_STR_NULL (plugin-&gt;filename));
1540         g_free (filename);
1541         gst_object_unref (plugin);
1542         continue;
1543       }
1544 
1545       env_vars_changed = _priv_plugin_deps_env_vars_changed (plugin);
1546 
1547       /* If a file with a certain basename is seen on a different path,
1548        * update the plugin to ensure the registry cache will reflect up
1549        * to date information */
1550 
1551       if (plugin-&gt;file_mtime == file_status.st_mtime &amp;&amp;
1552           plugin-&gt;file_size == file_status.st_size &amp;&amp; !env_vars_changed &amp;&amp;
1553           !(deps_changed = _priv_plugin_deps_files_changed (plugin)) &amp;&amp;
1554           !strcmp (plugin-&gt;filename, filename)) {
1555         GST_LOG_OBJECT (context-&gt;registry, &quot;file %s cached&quot;, filename);
1556         GST_OBJECT_FLAG_UNSET (plugin, GST_PLUGIN_FLAG_CACHED);
1557         GST_LOG_OBJECT (context-&gt;registry,
1558             &quot;marking plugin %p as registered as %s&quot;, plugin, filename);
1559         plugin-&gt;registered = TRUE;
1560       } else {
1561         GST_INFO_OBJECT (context-&gt;registry, &quot;cached info for %s is stale&quot;,
1562             filename);
1563         GST_DEBUG_OBJECT (context-&gt;registry, &quot;mtime %&quot; G_GINT64_FORMAT &quot; != %&quot;
1564             G_GINT64_FORMAT &quot; or size %&quot; G_GINT64_FORMAT &quot; != %&quot;
1565             G_GINT64_FORMAT &quot; or external dependency env_vars changed: %d or&quot;
1566             &quot; external dependencies changed: %d or old path %s != new path %s&quot;,
1567             (gint64) plugin-&gt;file_mtime, (gint64) file_status.st_mtime,
1568             (gint64) plugin-&gt;file_size, (gint64) file_status.st_size,
1569             env_vars_changed, deps_changed, plugin-&gt;filename, filename);
1570         gst_registry_remove_plugin (context-&gt;registry, plugin);
1571         changed |= gst_registry_scan_plugin_file (context, filename,
1572             file_status.st_size, file_status.st_mtime);
1573       }
1574       gst_object_unref (plugin);
1575 
1576     } else {
1577       GST_DEBUG_OBJECT (context-&gt;registry, &quot;file %s not yet in registry&quot;,
1578           filename);
1579       changed |= gst_registry_scan_plugin_file (context, filename,
1580           file_status.st_size, file_status.st_mtime);
1581     }
1582 
1583     g_free (filename);
1584   }
1585 
1586 #ifndef GSTREAMER_LITE
1587   g_dir_close (dir);
1588 #endif // GSTREAMER_LITE
1589 
1590   return changed;
1591 }
1592 
1593 static gboolean
1594 gst_registry_scan_path_internal (GstRegistryScanContext * context,
1595     const gchar * path)
1596 {
1597   gboolean changed;
1598 
1599   GST_DEBUG_OBJECT (context-&gt;registry, &quot;scanning path %s&quot;, path);
1600 #ifndef GSTREAMER_LITE
1601   changed = gst_registry_scan_path_level (context, path, 10);
1602 #else // GSTREAMER_LITE
1603   changed = gst_registry_scan_path_level (context, path, 0);
1604 #endif // GSTREAMER_LITE
1605 
1606   GST_DEBUG_OBJECT (context-&gt;registry, &quot;registry changed in path %s: %d&quot;, path,
1607       changed);
1608   return changed;
1609 }
1610 
1611 /**
1612  * gst_registry_scan_path:
1613  * @registry: the registry to add found plugins to
1614  * @path: (type filename): the path to scan
1615  *
1616  * Scan the given path for plugins to add to the registry. The syntax of the
1617  * path is specific to the registry.
1618  *
1619  * Returns: %TRUE if registry changed
1620  */
1621 gboolean
1622 gst_registry_scan_path (GstRegistry * registry, const gchar * path)
1623 {
1624   GstRegistryScanContext context;
1625   gboolean result;
1626 
1627   g_return_val_if_fail (GST_IS_REGISTRY (registry), FALSE);
1628   g_return_val_if_fail (path != NULL, FALSE);
1629 
1630   init_scan_context (&amp;context, registry);
1631 
1632   result = gst_registry_scan_path_internal (&amp;context, path);
1633 
1634   clear_scan_context (&amp;context);
1635   result |= context.changed;
1636 
1637   return result;
1638 }
1639 
1640 static gboolean
1641 _gst_plugin_feature_filter_plugin_name (GstPluginFeature * feature,
1642     gpointer user_data)
1643 {
1644   return (strcmp (feature-&gt;plugin_name, (gchar *) user_data) == 0);
1645 }
1646 
1647 /**
1648  * gst_registry_get_feature_list_by_plugin:
1649  * @registry: a #GstRegistry.
1650  * @name: a plugin name.
1651  *
1652  * Retrieves a #GList of features of the plugin with name @name.
1653  *
1654  * Returns: (transfer full) (element-type Gst.PluginFeature): a #GList of
1655  *     #GstPluginFeature. Use gst_plugin_feature_list_free() after usage.
1656  */
1657 GList *
1658 gst_registry_get_feature_list_by_plugin (GstRegistry * registry,
1659     const gchar * name)
1660 {
1661   g_return_val_if_fail (GST_IS_REGISTRY (registry), NULL);
1662   g_return_val_if_fail (name != NULL, NULL);
1663 
1664   return gst_registry_feature_filter (registry,
1665       _gst_plugin_feature_filter_plugin_name, FALSE, (gpointer) name);
1666 }
1667 
1668 /* Unref and delete the default registry */
1669 void
1670 _priv_gst_registry_cleanup (void)
1671 {
1672   GstRegistry *registry;
1673 
1674   g_mutex_lock (&amp;_gst_registry_mutex);
1675   if ((registry = _gst_registry_default) != NULL) {
1676     _gst_registry_default = NULL;
1677   }
1678   g_mutex_unlock (&amp;_gst_registry_mutex);
1679 
1680   /* unref outside of the lock because we can. */
1681   if (registry)
1682     gst_object_unref (registry);
1683 }
1684 
1685 /**
1686  * gst_registry_check_feature_version:
1687  * @registry: a #GstRegistry
1688  * @feature_name: the name of the feature (e.g. &quot;oggdemux&quot;)
1689  * @min_major: the minimum major version number
1690  * @min_minor: the minimum minor version number
1691  * @min_micro: the minimum micro version number
1692  *
1693  * Checks whether a plugin feature by the given name exists in
1694  * @registry and whether its version is at least the
1695  * version required.
1696  *
1697  * Returns: %TRUE if the feature could be found and the version is
1698  * the same as the required version or newer, and %FALSE otherwise.
1699  */
1700 gboolean
1701 gst_registry_check_feature_version (GstRegistry * registry,
1702     const gchar * feature_name, guint min_major, guint min_minor,
1703     guint min_micro)
1704 {
1705   GstPluginFeature *feature;
1706   gboolean ret = FALSE;
1707 
1708   g_return_val_if_fail (feature_name != NULL, FALSE);
1709 
1710   GST_DEBUG (&quot;Looking up plugin feature &#39;%s&#39;&quot;, feature_name);
1711 
1712   feature = gst_registry_lookup_feature (registry, feature_name);
1713   if (feature) {
1714     ret = gst_plugin_feature_check_version (feature, min_major, min_minor,
1715         min_micro);
1716     gst_object_unref (feature);
1717   } else {
1718     GST_DEBUG (&quot;Could not find plugin feature &#39;%s&#39;&quot;, feature_name);
1719   }
1720 
1721   return ret;
1722 }
1723 
1724 static void
1725 load_plugin_func (gpointer data, gpointer user_data)
1726 {
1727   GstPlugin *plugin;
1728   const gchar *filename;
1729   GError *err = NULL;
1730 
1731   filename = (const gchar *) data;
1732   GST_DEBUG (&quot;Pre-loading plugin %s&quot;, filename);
1733 
1734   plugin = gst_plugin_load_file (filename, &amp;err);
1735 
1736   if (plugin) {
1737     GST_INFO (&quot;Loaded plugin: \&quot;%s\&quot;&quot;, filename);
1738 
1739     gst_registry_add_plugin (gst_registry_get (), plugin);
1740   } else {
1741     if (err) {
1742       /* Report error to user, and free error */
1743       GST_ERROR (&quot;Failed to load plugin: %s&quot;, err-&gt;message);
1744       g_error_free (err);
1745     } else {
1746       GST_WARNING (&quot;Failed to load plugin: \&quot;%s\&quot;&quot;, filename);
1747     }
1748   }
1749 }
1750 
1751 #ifndef GST_DISABLE_REGISTRY
1752 /* Unref all plugins marked &#39;cached&#39;, to clear old plugins that no
1753  * longer exist. Returns %TRUE if any plugins were removed */
1754 static gboolean
1755 gst_registry_remove_cache_plugins (GstRegistry * registry)
1756 {
1757   GList *g;
1758   GList *g_next;
1759   GstPlugin *plugin;
1760   gboolean changed = FALSE;
1761 
1762   g_return_val_if_fail (GST_IS_REGISTRY (registry), FALSE);
1763 
1764   GST_OBJECT_LOCK (registry);
1765 
1766   GST_DEBUG_OBJECT (registry, &quot;removing cached plugins&quot;);
1767   g = registry-&gt;priv-&gt;plugins;
1768   while (g) {
1769     g_next = g-&gt;next;
1770     plugin = g-&gt;data;
1771     if (GST_OBJECT_FLAG_IS_SET (plugin, GST_PLUGIN_FLAG_CACHED)) {
1772       GST_DEBUG_OBJECT (registry, &quot;removing cached plugin \&quot;%s\&quot;&quot;,
1773           GST_STR_NULL (plugin-&gt;filename));
1774       registry-&gt;priv-&gt;plugins = g_list_delete_link (registry-&gt;priv-&gt;plugins, g);
1775       --registry-&gt;priv-&gt;n_plugins;
1776       if (G_LIKELY (plugin-&gt;basename))
1777         g_hash_table_remove (registry-&gt;priv-&gt;basename_hash, plugin-&gt;basename);
1778       gst_registry_remove_features_for_plugin_unlocked (registry, plugin);
1779       gst_object_unref (plugin);
1780       changed = TRUE;
1781     }
1782     g = g_next;
1783   }
1784 
1785   GST_OBJECT_UNLOCK (registry);
1786 
1787   return changed;
1788 }
1789 
1790 typedef enum
1791 {
1792   REGISTRY_SCAN_AND_UPDATE_FAILURE = 0,
1793   REGISTRY_SCAN_AND_UPDATE_SUCCESS_NOT_CHANGED,
1794   REGISTRY_SCAN_AND_UPDATE_SUCCESS_UPDATED
1795 } GstRegistryScanAndUpdateResult;
1796 
1797 /*
1798  * scan_and_update_registry:
1799  * @default_registry: the #GstRegistry
1800  * @registry_file: registry filename
1801  * @write_changes: write registry if it has changed?
1802  *
1803  * Scans for registry changes and eventually updates the registry cache.
1804  *
1805  * Return: %REGISTRY_SCAN_AND_UPDATE_FAILURE if the registry could not scanned
1806  *         or updated, %REGISTRY_SCAN_AND_UPDATE_SUCCESS_NOT_CHANGED if the
1807  *         registry is clean and %REGISTRY_SCAN_AND_UPDATE_SUCCESS_UPDATED if
1808  *         it has been updated and the cache needs to be re-read.
1809  */
1810 static GstRegistryScanAndUpdateResult
1811 scan_and_update_registry (GstRegistry * default_registry,
1812     const gchar * registry_file, gboolean write_changes, GError ** error)
1813 {
1814   const gchar *plugin_path;
1815   gboolean changed = FALSE;
1816   GList *l;
1817   GstRegistryScanContext context;
1818 
1819   GST_INFO (&quot;Validating plugins from registry cache: %s&quot;, registry_file);
1820 
1821 #ifdef GSTREAMER_LITE
1822 #ifdef G_OS_WIN32
1823   {
1824     HMODULE hmodule = NULL;
1825     char *dir = NULL;
1826     gchar *p = NULL;
1827     wchar_t wc_fn[MAX_PATH];
1828 
1829     hmodule = GetModuleHandle(LIBGSTREAMER_LIB_NAME);
1830     if (hmodule)
1831     {
1832       if (GetModuleFileNameW(hmodule, wc_fn, MAX_PATH))
1833       {
1834         dir = g_utf16_to_utf8(wc_fn, -1, NULL, NULL, NULL);
1835         if (dir)
1836         {
1837           if ((p = strrchr (dir, G_DIR_SEPARATOR)) != NULL)
1838             *p = &#39;\0&#39;;
1839 
1840           changed |= gst_registry_scan_path (default_registry, dir);
1841 
1842           g_free(dir);
1843         }
1844       }
1845     }
1846   }
1847 #elif defined(HAVE_OSX)
1848   {
1849     const void* pHeader = (void*) &amp;_mh_dylib_header;
1850     const char* pImageName = 0;
1851     gchar*      pBasePath = NULL;
1852     int         iCount = _dyld_image_count();
1853     int         i;
1854 
1855     for(i = 1; i &lt; iCount; i++)
1856     {
1857         if (((void*)_dyld_get_image_header(i)) == pHeader)
1858             pImageName = _dyld_get_image_name(i);//contains absolute path to dylib
1859     }
1860 
1861     if (NULL != pImageName)
1862     {
1863         pBasePath = g_path_get_dirname((const gchar*) pImageName);
1864         changed |= gst_registry_scan_path (default_registry, pBasePath);
1865     }
1866   }
1867 #elif defined (LINUX)
1868   {
1869     // Get base path of Gstreamer-lite lib.
1870     gchar *base_path = NULL;
1871     if (dl_iterate_phdr (dl_callback, &amp;base_path))
1872     {
1873       base_path = g_path_get_dirname((const gchar*) base_path);
1874     }
1875 
1876     if (base_path != NULL)
1877     {
1878       changed |= gst_registry_scan_path (default_registry, base_path);
1879     }
1880     else
1881     {
1882       GST_ERROR (&quot;Could not locate %s&quot;, LIBGSTREAMER_LIB_NAME);
1883     }
1884   }
1885 #else // other platforms ...
1886   {
1887     // Scan current path
1888     gchar *current_path = g_get_current_dir();
1889     if (current_path != NULL)
1890     {
1891       changed |= gst_registry_scan_path (default_registry, current_path);
1892       g_free(current_path);
1893     }
1894     else
1895     {
1896       GST_ERROR (&quot;g_get_current_dir() returned NULL&quot;);
1897     }
1898   }
1899 #endif // other platforms
1900 #endif // GSTREAMER_LITE
1901 
1902 #ifndef GSTREAMER_LITE
1903   init_scan_context (&amp;context, default_registry);
1904 
1905   /* It sounds tempting to just compare the mtime of directories with the mtime
1906    * of the registry cache, but it does not work. It would not catch updated
1907    * plugins, which might bring more or less features.
1908    */
1909 
1910   /* scan paths specified via --gst-plugin-path */
1911   GST_DEBUG (&quot;scanning paths added via --gst-plugin-path&quot;);
1912   for (l = _priv_gst_plugin_paths; l != NULL; l = l-&gt;next) {
1913     GST_INFO (&quot;Scanning plugin path: \&quot;%s\&quot;&quot;, (gchar *) l-&gt;data);
1914     changed |= gst_registry_scan_path_internal (&amp;context, (gchar *) l-&gt;data);
1915   }
1916   /* keep plugin_paths around in case a re-scan is forced later on */
1917 
1918   /* GST_PLUGIN_PATH specifies a list of directories to scan for
1919    * additional plugins.  These take precedence over the system plugins */
1920   plugin_path = g_getenv (&quot;GST_PLUGIN_PATH_1_0&quot;);
1921   if (plugin_path == NULL)
<a name="8" id="anc8"></a><span class="line-modified">1922   plugin_path = g_getenv (&quot;GST_PLUGIN_PATH&quot;);</span>
1923   if (plugin_path) {
1924     char **list;
1925     int i;
1926 
1927     GST_DEBUG (&quot;GST_PLUGIN_PATH set to %s&quot;, plugin_path);
1928     list = g_strsplit (plugin_path, G_SEARCHPATH_SEPARATOR_S, 0);
1929     for (i = 0; list[i]; i++) {
1930       changed |= gst_registry_scan_path_internal (&amp;context, list[i]);
1931     }
1932     g_strfreev (list);
1933   } else {
1934     GST_DEBUG (&quot;GST_PLUGIN_PATH not set&quot;);
1935   }
1936 
1937   /* GST_PLUGIN_SYSTEM_PATH specifies a list of plugins that are always
1938    * loaded by default.  If not set, this defaults to the system-installed
1939    * path, and the plugins installed in the user&#39;s home directory */
1940   plugin_path = g_getenv (&quot;GST_PLUGIN_SYSTEM_PATH_1_0&quot;);
1941   if (plugin_path == NULL)
<a name="9" id="anc9"></a><span class="line-modified">1942   plugin_path = g_getenv (&quot;GST_PLUGIN_SYSTEM_PATH&quot;);</span>
1943   if (plugin_path == NULL) {
1944     char *home_plugins;
1945 
1946     GST_DEBUG (&quot;GST_PLUGIN_SYSTEM_PATH not set&quot;);
1947 
1948     /* plugins in the user&#39;s home directory take precedence over
1949      * system-installed ones */
1950     home_plugins = g_build_filename (g_get_user_data_dir (),
1951         &quot;gstreamer-&quot; GST_API_VERSION, &quot;plugins&quot;, NULL);
1952 
1953     GST_DEBUG (&quot;scanning home plugins %s&quot;, home_plugins);
1954     changed |= gst_registry_scan_path_internal (&amp;context, home_plugins);
1955     g_free (home_plugins);
1956 
1957     /* add the main (installed) library path */
1958 
1959 #ifdef G_OS_WIN32
1960     {
1961       char *base_dir;
1962       char *dir;
1963 
1964       base_dir =
1965           g_win32_get_package_installation_directory_of_module
1966           (_priv_gst_dll_handle);
1967 
<a name="10" id="anc10"></a><span class="line-modified">1968       dir = g_build_filename (base_dir,</span>
<span class="line-modified">1969 #ifdef _DEBUG</span>
<span class="line-removed">1970           &quot;debug&quot;</span>
<span class="line-removed">1971 #endif</span>
<span class="line-removed">1972           &quot;lib&quot;, &quot;gstreamer-&quot; GST_API_VERSION, NULL);</span>
1973       GST_DEBUG (&quot;scanning DLL dir %s&quot;, dir);
1974 
1975       changed |= gst_registry_scan_path_internal (&amp;context, dir);
1976 
1977       g_free (dir);
1978       g_free (base_dir);
1979     }
1980 #else
1981     GST_DEBUG (&quot;scanning main plugins %s&quot;, PLUGINDIR);
1982     changed |= gst_registry_scan_path_internal (&amp;context, PLUGINDIR);
1983 #endif
1984   } else {
1985     gchar **list;
1986     gint i;
1987 
1988     GST_DEBUG (&quot;GST_PLUGIN_SYSTEM_PATH set to %s&quot;, plugin_path);
1989     list = g_strsplit (plugin_path, G_SEARCHPATH_SEPARATOR_S, 0);
1990     for (i = 0; list[i]; i++) {
1991       changed |= gst_registry_scan_path_internal (&amp;context, list[i]);
1992     }
1993     g_strfreev (list);
1994   }
1995 
1996 
1997   clear_scan_context (&amp;context);
1998 
1999   changed |= context.changed;
2000 #endif // GSTREAMER_LITE
2001 
2002   /* Remove cached plugins so stale info is cleared. */
2003   changed |= gst_registry_remove_cache_plugins (default_registry);
2004 
2005   if (!changed) {
2006     GST_INFO (&quot;Registry cache has not changed&quot;);
2007     return REGISTRY_SCAN_AND_UPDATE_SUCCESS_NOT_CHANGED;
2008   }
2009 
2010   if (!write_changes) {
2011     GST_INFO (&quot;Registry cache changed, but writing is disabled. Not writing.&quot;);
2012     return REGISTRY_SCAN_AND_UPDATE_FAILURE;
2013   }
2014 
2015 #ifndef GSTREAMER_LITE
2016   GST_INFO (&quot;Registry cache changed. Writing new registry cache&quot;);
2017   if (!priv_gst_registry_binary_write_cache (default_registry,
2018           default_registry-&gt;priv-&gt;plugins, registry_file)) {
2019     g_set_error (error, GST_CORE_ERROR, GST_CORE_ERROR_FAILED,
2020         _(&quot;Error writing registry cache to %s: %s&quot;),
2021         registry_file, g_strerror (errno));
2022     return REGISTRY_SCAN_AND_UPDATE_FAILURE;
2023   }
2024 #endif // GSTREAMER_LITE
2025 
2026   GST_INFO (&quot;Registry cache written successfully&quot;);
2027   return REGISTRY_SCAN_AND_UPDATE_SUCCESS_UPDATED;
2028 }
2029 
2030 static gboolean
2031 ensure_current_registry (GError ** error)
2032 {
2033   gchar *registry_file;
2034   GstRegistry *default_registry;
2035   gboolean ret = TRUE;
2036   gboolean do_update = TRUE;
2037   gboolean have_cache = TRUE;
2038 
2039   default_registry = gst_registry_get ();
2040 
2041   registry_file = g_strdup (g_getenv (&quot;GST_REGISTRY_1_0&quot;));
2042   if (registry_file == NULL)
<a name="11" id="anc11"></a><span class="line-modified">2043   registry_file = g_strdup (g_getenv (&quot;GST_REGISTRY&quot;));</span>
2044   if (registry_file == NULL) {
2045     registry_file = g_build_filename (g_get_user_cache_dir (),
2046         &quot;gstreamer-&quot; GST_API_VERSION, &quot;registry.&quot; TARGET_CPU &quot;.bin&quot;, NULL);
2047   }
2048 
2049   if (!_gst_disable_registry_cache) {
2050     GST_INFO (&quot;reading registry cache: %s&quot;, registry_file);
2051 #ifndef GSTREAMER_LITE
2052     have_cache = priv_gst_registry_binary_read_cache (default_registry,
2053         registry_file);
2054 #else // GSTREAMER_LITE
2055     have_cache = FALSE;
2056 #endif // GSTREAMER_LITE
2057     /* Only ever read the registry cache once, then disable it for
2058      * subsequent updates during the program lifetime */
2059     _gst_disable_registry_cache = TRUE;
2060   }
2061 
2062   if (have_cache) {
2063     do_update = !_priv_gst_disable_registry_update;
2064     if (do_update) {
2065       const gchar *update_env;
2066 
2067       if ((update_env = g_getenv (&quot;GST_REGISTRY_UPDATE&quot;))) {
2068         /* do update for any value different from &quot;no&quot; */
2069         do_update = (strcmp (update_env, &quot;no&quot;) != 0);
2070       }
2071     }
2072   }
2073 
2074   if (do_update) {
2075     const gchar *reuse_env;
2076 
2077     if ((reuse_env = g_getenv (&quot;GST_REGISTRY_REUSE_PLUGIN_SCANNER&quot;))) {
2078       /* do reuse for any value different from &quot;no&quot; */
2079       __registry_reuse_plugin_scanner = (strcmp (reuse_env, &quot;no&quot;) != 0);
2080     }
2081     /* now check registry */
2082     GST_DEBUG (&quot;Updating registry cache&quot;);
2083     scan_and_update_registry (default_registry, registry_file, TRUE, error);
2084   } else {
2085     GST_DEBUG (&quot;Not updating registry cache (disabled)&quot;);
2086   }
2087 
2088   g_free (registry_file);
2089   GST_INFO (&quot;registry reading and updating done, result = %d&quot;, ret);
2090 
2091   return ret;
2092 }
2093 #endif /* GST_DISABLE_REGISTRY */
2094 
2095 /**
2096  * gst_registry_fork_is_enabled:
2097  *
2098  * By default GStreamer will perform scanning and rebuilding of the
2099  * registry file using a helper child process.
2100  *
2101  * Applications might want to disable this behaviour with the
2102  * gst_registry_fork_set_enabled() function, in which case new plugins
2103  * are scanned (and loaded) into the application process.
2104  *
2105  * Returns: %TRUE if GStreamer will use the child helper process when
2106  * rebuilding the registry.
2107  */
2108 gboolean
2109 gst_registry_fork_is_enabled (void)
2110 {
2111   return _gst_enable_registry_fork;
2112 }
2113 
2114 /**
2115  * gst_registry_fork_set_enabled:
2116  * @enabled: whether rebuilding the registry can use a temporary child helper process.
2117  *
2118  * Applications might want to disable/enable spawning of a child helper process
2119  * when rebuilding the registry. See gst_registry_fork_is_enabled() for more
2120  * information.
2121  */
2122 void
2123 gst_registry_fork_set_enabled (gboolean enabled)
2124 {
2125   _gst_enable_registry_fork = enabled;
2126 }
2127 
2128 /**
2129  * gst_update_registry:
2130  *
2131  * Forces GStreamer to re-scan its plugin paths and update the default
2132  * plugin registry.
2133  *
2134  * Applications will almost never need to call this function, it is only
2135  * useful if the application knows new plugins have been installed (or old
2136  * ones removed) since the start of the application (or, to be precise, the
2137  * first call to gst_init()) and the application wants to make use of any
2138  * newly-installed plugins without restarting the application.
2139  *
2140  * Applications should assume that the registry update is neither atomic nor
2141  * thread-safe and should therefore not have any dynamic pipelines running
2142  * (including the playbin and decodebin elements) and should also not create
2143  * any elements or access the GStreamer registry while the update is in
2144  * progress.
2145  *
2146  * Note that this function may block for a significant amount of time.
2147  *
2148  * Returns: %TRUE if the registry has been updated successfully (does not
2149  *          imply that there were changes), otherwise %FALSE.
2150  */
2151 gboolean
2152 gst_update_registry (void)
2153 {
2154   gboolean res;
2155 
2156 #ifndef GST_DISABLE_REGISTRY
2157   if (!_priv_gst_disable_registry) {
<a name="12" id="anc12"></a><span class="line-modified">2158   GError *err = NULL;</span>
2159 
<a name="13" id="anc13"></a><span class="line-modified">2160   res = ensure_current_registry (&amp;err);</span>
<span class="line-modified">2161   if (err) {</span>
<span class="line-modified">2162     GST_WARNING (&quot;registry update failed: %s&quot;, err-&gt;message);</span>
<span class="line-modified">2163     g_error_free (err);</span>
<span class="line-modified">2164   } else {</span>
<span class="line-modified">2165     GST_LOG (&quot;registry update succeeded&quot;);</span>
<span class="line-modified">2166   }</span>
2167   } else {
2168     GST_INFO (&quot;registry update disabled by environment&quot;);
2169     res = TRUE;
2170   }
2171 
2172 #else
2173   GST_WARNING (&quot;registry update failed: %s&quot;, &quot;registry disabled&quot;);
2174   res = TRUE;
2175 #endif /* GST_DISABLE_REGISTRY */
2176 
2177   if (_priv_gst_preload_plugins) {
2178     GST_DEBUG (&quot;Preloading indicated plugins...&quot;);
2179     g_slist_foreach (_priv_gst_preload_plugins, load_plugin_func, NULL);
2180   }
2181 
2182   return res;
2183 }
2184 
2185 /**
2186  * gst_registry_get_feature_list_cookie:
2187  * @registry: the registry
2188  *
2189  * Returns the registry&#39;s feature list cookie. This changes
2190  * every time a feature is added or removed from the registry.
2191  *
2192  * Returns: the feature list cookie.
2193  */
2194 guint32
2195 gst_registry_get_feature_list_cookie (GstRegistry * registry)
2196 {
2197   g_return_val_if_fail (GST_IS_REGISTRY (registry), 0);
2198 
2199   return registry-&gt;priv-&gt;cookie;
2200 }
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>