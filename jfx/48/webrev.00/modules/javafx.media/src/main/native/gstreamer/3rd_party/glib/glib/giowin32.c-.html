<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/giowin32.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /* GLIB - Library of useful routines for C programming
   2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
   3  *
   4  * giowin32.c: IO Channels for Win32.
   5  * Copyright 1998 Owen Taylor and Tor Lillqvist
   6  * Copyright 1999-2000 Tor Lillqvist and Craig Setera
   7  * Copyright 2001-2003 Andrew Lanoix
   8  *
   9  * This library is free software; you can redistribute it and/or
  10  * modify it under the terms of the GNU Lesser General Public
  11  * License as published by the Free Software Foundation; either
  12  * version 2.1 of the License, or (at your option) any later version.
  13  *
  14  * This library is distributed in the hope that it will be useful,
  15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  * Lesser General Public License for more details.
  18  *
  19  * You should have received a copy of the GNU Lesser General Public
  20  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  21  */
  22 
  23 /*
  24  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
  25  * file for a list of people on the GLib Team.  See the ChangeLog
  26  * files for a list of changes.  These files are distributed with
  27  * GLib at ftp://ftp.gtk.org/pub/gtk/.
  28  */
  29 
  30 /*
  31  * Bugs that are related to the code in this file:
  32  *
  33  * Bug 137968 - Sometimes a GIOFunc on Win32 is called with zero condition
  34  * http://bugzilla.gnome.org/show_bug.cgi?id=137968
  35  *
  36  * Bug 324234 - Using g_io_add_watch_full() to wait for connect() to return on a non-blocking socket returns prematurely
  37  * http://bugzilla.gnome.org/show_bug.cgi?id=324234
  38  *
  39  * Bug 331214 - g_io_channel async socket io stalls
  40  * http://bugzilla.gnome.org/show_bug.cgi?id=331214
  41  *
  42  * Bug 338943 - Multiple watches on the same socket
  43  * http://bugzilla.gnome.org/show_bug.cgi?id=338943
  44  *
  45  * Bug 357674 - 2 serious bugs in giowin32.c making glib iochannels useless
  46  * http://bugzilla.gnome.org/show_bug.cgi?id=357674
  47  *
  48  * Bug 425156 - GIOChannel deadlocks on a win32 socket
  49  * http://bugzilla.gnome.org/show_bug.cgi?id=425156
  50  *
  51  * Bug 468910 - giofunc condition=0
  52  * http://bugzilla.gnome.org/show_bug.cgi?id=468910
  53  *
  54  * Bug 500246 - Bug fixes for giowin32
  55  * http://bugzilla.gnome.org/show_bug.cgi?id=500246
  56  *
  57  * Bug 548278 - Async GETs connections are always terminated unexpectedly on windows
  58  * http://bugzilla.gnome.org/show_bug.cgi?id=548278
  59  *
  60  * Bug 548536 - giowin32 problem when adding and removing watches
  61  * http://bugzilla.gnome.org/show_bug.cgi?id=548536
  62  *
  63  * When fixing bugs related to the code in this file, either the above
  64  * bugs or others, make sure that the test programs attached to the
  65  * above bugs continue to work.
  66  */
  67 
  68 #include &quot;config.h&quot;
  69 
  70 #include &quot;glib.h&quot;
  71 
  72 #include &lt;stdlib.h&gt;
  73 #include &lt;winsock2.h&gt;
  74 #include &lt;windows.h&gt;
  75 #include &lt;conio.h&gt;
  76 #include &lt;fcntl.h&gt;
  77 #include &lt;io.h&gt;
  78 #include &lt;process.h&gt;
  79 #include &lt;errno.h&gt;
  80 #include &lt;sys/stat.h&gt;
  81 
  82 #include &quot;gstdio.h&quot;
  83 #include &quot;glibintl.h&quot;
  84 
  85 
  86 typedef struct _GIOWin32Channel GIOWin32Channel;
  87 typedef struct _GIOWin32Watch GIOWin32Watch;
  88 
  89 #define BUFFER_SIZE 4096
  90 
  91 typedef enum {
  92   G_IO_WIN32_WINDOWS_MESSAGES,  /* Windows messages */
  93 
  94   G_IO_WIN32_FILE_DESC,     /* Unix-like file descriptors from
  95                                  * _open() or _pipe(), except for
  96                                  * console IO. Separate thread to read
  97                                  * or write.
  98                                  */
  99 
 100   G_IO_WIN32_CONSOLE,       /* Console IO (usually stdin, stdout, stderr) */
 101 
 102   G_IO_WIN32_SOCKET     /* Sockets. No separate thread. */
 103 } GIOWin32ChannelType;
 104 
 105 struct _GIOWin32Channel {
 106   GIOChannel channel;
 107   gint fd;          /* Either a Unix-like file handle as provided
 108                                  * by the Microsoft C runtime, or a SOCKET
 109                                  * as provided by WinSock.
 110                                  */
 111   GIOWin32ChannelType type;
 112 
 113   gboolean debug;
 114 
 115   /* Field used by G_IO_WIN32_WINDOWS_MESSAGES channels */
 116   HWND hwnd;            /* Handle of window, or NULL */
 117 
 118   /* Fields used by G_IO_WIN32_FILE_DESC channels. */
 119   CRITICAL_SECTION mutex;
 120 
 121   int direction;        /* 0 means we read from it,
 122                                  * 1 means we write to it.
 123                                  */
 124 
 125   gboolean running;     /* Is reader or writer thread
 126                                  * running. FALSE if EOF has been
 127                                  * reached by the reader thread.
 128                                  */
 129 
 130   gboolean needs_close;     /* If the channel has been closed while
 131                                  * the reader thread was still running.
 132                                  */
 133 
 134   guint thread_id;      /* If non-NULL the channel has or has
 135                                  * had a reader or writer thread.
 136                                  */
 137   HANDLE data_avail_event;
 138 
 139   gushort revents;
 140 
 141   /* Data is kept in a circular buffer. To be able to distinguish between
 142    * empty and full buffers, we cannot fill it completely, but have to
 143    * leave a one character gap.
 144    *
 145    * Data available is between indexes rdp and wrp-1 (modulo BUFFER_SIZE).
 146    *
 147    * Empty:    wrp == rdp
 148    * Full:     (wrp + 1) % BUFFER_SIZE == rdp
 149    * Partial:  otherwise
 150    */
 151   guchar *buffer;       /* (Circular) buffer */
 152   gint wrp, rdp;        /* Buffer indices for writing and reading */
 153   HANDLE space_avail_event;
 154 
 155   /* Fields used by G_IO_WIN32_SOCKET channels */
 156   int event_mask;
 157   int last_events;
 158   HANDLE event;
 159   gboolean write_would_have_blocked;
 160   gboolean ever_writable;
 161 };
 162 
 163 struct _GIOWin32Watch {
 164   GSource       source;
 165   GPollFD       pollfd;
 166   GIOChannel   *channel;
 167   GIOCondition  condition;
 168 };
 169 
 170 static void
 171 g_win32_print_access_mode (int flags)
 172 {
 173   g_print (&quot;%s%s%s%s%s%s%s%s%s%s&quot;,
 174        ((flags &amp; 0x3) == _O_RDWR ? &quot;O_RDWR&quot; :
 175         ((flags &amp; 0x3) == _O_RDONLY ? &quot;O_RDONLY&quot; :
 176          ((flags &amp; 0x3) == _O_WRONLY ? &quot;O_WRONLY&quot; : &quot;0&quot;))),
 177        (flags &amp; _O_APPEND ? &quot;|O_APPEND&quot; : &quot;&quot;),
 178        (flags &amp; _O_RANDOM ? &quot;|O_RANDOM&quot; : &quot;&quot;),
 179        (flags &amp; _O_SEQUENTIAL ? &quot;|O_SEQUENTIAL&quot; : &quot;&quot;),
 180        (flags &amp; _O_TEMPORARY ? &quot;|O_TEMPORARY&quot; : &quot;&quot;),
 181        (flags &amp; _O_CREAT ? &quot;|O_CREAT&quot; : &quot;&quot;),
 182        (flags &amp; _O_TRUNC ? &quot;|O_TRUNC&quot; : &quot;&quot;),
 183        (flags &amp; _O_EXCL ? &quot;|O_EXCL&quot; : &quot;&quot;),
 184        (flags &amp; _O_TEXT ? &quot;|O_TEXT&quot; : &quot;&quot;),
 185        (flags &amp; _O_BINARY ? &quot;|O_BINARY&quot; : &quot;&quot;));
 186 }
 187 
 188 static void
 189 g_win32_print_gioflags (GIOFlags flags)
 190 {
 191   char *bar = &quot;&quot;;
 192 
 193   if (flags &amp; G_IO_FLAG_APPEND)
 194     bar = &quot;|&quot;, g_print (&quot;APPEND&quot;);
 195   if (flags &amp; G_IO_FLAG_NONBLOCK)
 196     g_print (&quot;%sNONBLOCK&quot;, bar), bar = &quot;|&quot;;
 197   if (flags &amp; G_IO_FLAG_IS_READABLE)
 198     g_print (&quot;%sREADABLE&quot;, bar), bar = &quot;|&quot;;
 199   if (flags &amp; G_IO_FLAG_IS_WRITABLE)
 200     g_print (&quot;%sWRITABLE&quot;, bar), bar = &quot;|&quot;;
 201   if (flags &amp; G_IO_FLAG_IS_SEEKABLE)
 202     g_print (&quot;%sSEEKABLE&quot;, bar), bar = &quot;|&quot;;
 203 }
 204 
 205 static const char *
 206 event_mask_to_string (int mask)
 207 {
 208   char buf[100];
 209   int checked_bits = 0;
 210   char *bufp = buf;
 211 
 212   if (mask == 0)
 213     return &quot;&quot;;
 214 
 215 #define BIT(n) checked_bits |= FD_##n; if (mask &amp; FD_##n) bufp += sprintf (bufp, &quot;%s&quot; #n, (bufp&gt;buf ? &quot;|&quot; : &quot;&quot;))
 216 
 217   BIT (READ);
 218   BIT (WRITE);
 219   BIT (OOB);
 220   BIT (ACCEPT);
 221   BIT (CONNECT);
 222   BIT (CLOSE);
 223   BIT (QOS);
 224   BIT (GROUP_QOS);
 225   BIT (ROUTING_INTERFACE_CHANGE);
 226   BIT (ADDRESS_LIST_CHANGE);
 227 
 228 #undef BIT
 229 
 230   if ((mask &amp; ~checked_bits) != 0)
 231       bufp += sprintf (bufp, &quot;|%#x&quot;, mask &amp; ~checked_bits);
 232 
 233   return g_quark_to_string (g_quark_from_string (buf));
 234 }
 235 
 236 static const char *
 237 condition_to_string (GIOCondition condition)
 238 {
 239   char buf[100];
 240   int checked_bits = 0;
 241   char *bufp = buf;
 242 
 243   if (condition == 0)
 244     return &quot;&quot;;
 245 
 246 #define BIT(n) checked_bits |= G_IO_##n; if (condition &amp; G_IO_##n) bufp += sprintf (bufp, &quot;%s&quot; #n, (bufp&gt;buf ? &quot;|&quot; : &quot;&quot;))
 247 
 248   BIT (IN);
 249   BIT (OUT);
 250   BIT (PRI);
 251   BIT (ERR);
 252   BIT (HUP);
 253   BIT (NVAL);
 254 
 255 #undef BIT
 256 
 257   if ((condition &amp; ~checked_bits) != 0)
 258       bufp += sprintf (bufp, &quot;|%#x&quot;, condition &amp; ~checked_bits);
 259 
 260   return g_quark_to_string (g_quark_from_string (buf));
 261 }
 262 
 263 static gboolean
 264 g_io_win32_get_debug_flag (void)
 265 {
 266   return (getenv (&quot;G_IO_WIN32_DEBUG&quot;) != NULL);
 267 }
 268 
 269 static void
 270 g_io_channel_win32_init (GIOWin32Channel *channel)
 271 {
 272   channel-&gt;debug = g_io_win32_get_debug_flag ();
 273 
 274   InitializeCriticalSection (&amp;channel-&gt;mutex);
 275   channel-&gt;running = FALSE;
 276   channel-&gt;needs_close = FALSE;
 277   channel-&gt;thread_id = 0;
 278   channel-&gt;data_avail_event = NULL;
 279   channel-&gt;revents = 0;
 280   channel-&gt;buffer = NULL;
 281   channel-&gt;space_avail_event = NULL;
 282 
 283   channel-&gt;event_mask = 0;
 284   channel-&gt;last_events = 0;
 285   channel-&gt;event = NULL;
 286   channel-&gt;write_would_have_blocked = FALSE;
 287   channel-&gt;ever_writable = FALSE;
 288 }
 289 
 290 static void
 291 create_events (GIOWin32Channel *channel)
 292 {
 293   SECURITY_ATTRIBUTES sec_attrs;
 294 
 295   sec_attrs.nLength = sizeof (SECURITY_ATTRIBUTES);
 296   sec_attrs.lpSecurityDescriptor = NULL;
 297   sec_attrs.bInheritHandle = FALSE;
 298 
 299   /* The data available event is manual reset, the space available event
 300    * is automatic reset.
 301    */
 302   if (!(channel-&gt;data_avail_event = CreateEvent (&amp;sec_attrs, TRUE, FALSE, NULL))
 303       || !(channel-&gt;space_avail_event = CreateEvent (&amp;sec_attrs, FALSE, FALSE, NULL)))
 304     {
 305       gchar *emsg = g_win32_error_message (GetLastError ());
 306 
 307       g_error (&quot;Error creating event: %s&quot;, emsg);
 308       g_free (emsg);
 309     }
 310 }
 311 
 312 static unsigned __stdcall
 313 read_thread (void *parameter)
 314 {
 315   GIOWin32Channel *channel = parameter;
 316   guchar *buffer;
 317   gint nbytes;
 318 
 319   g_io_channel_ref ((GIOChannel *)channel);
 320 
 321   if (channel-&gt;debug)
 322     g_print (&quot;read_thread %#x: start fd=%d, data_avail=%p space_avail=%p\n&quot;,
 323          channel-&gt;thread_id,
 324          channel-&gt;fd,
 325          channel-&gt;data_avail_event,
 326          channel-&gt;space_avail_event);
 327 
 328   channel-&gt;direction = 0;
 329   channel-&gt;buffer = g_malloc (BUFFER_SIZE);
 330   channel-&gt;rdp = channel-&gt;wrp = 0;
 331   channel-&gt;running = TRUE;
 332 
 333   SetEvent (channel-&gt;space_avail_event);
 334 
 335   EnterCriticalSection (&amp;channel-&gt;mutex);
 336   while (channel-&gt;running)
 337     {
 338       if (channel-&gt;debug)
 339     g_print (&quot;read_thread %#x: rdp=%d, wrp=%d\n&quot;,
 340          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);
 341       if ((channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)
 342     {
 343       /* Buffer is full */
 344       if (channel-&gt;debug)
 345         g_print (&quot;read_thread %#x: resetting space_avail\n&quot;,
 346              channel-&gt;thread_id);
 347       ResetEvent (channel-&gt;space_avail_event);
 348       if (channel-&gt;debug)
 349         g_print (&quot;read_thread %#x: waiting for space\n&quot;,
 350              channel-&gt;thread_id);
 351       LeaveCriticalSection (&amp;channel-&gt;mutex);
 352       WaitForSingleObject (channel-&gt;space_avail_event, INFINITE);
 353       EnterCriticalSection (&amp;channel-&gt;mutex);
 354       if (channel-&gt;debug)
 355         g_print (&quot;read_thread %#x: rdp=%d, wrp=%d\n&quot;,
 356              channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);
 357     }
 358 
 359       buffer = channel-&gt;buffer + channel-&gt;wrp;
 360 
 361       /* Always leave at least one byte unused gap to be able to
 362        * distinguish between the full and empty condition...
 363        */
 364       nbytes = MIN ((channel-&gt;rdp + BUFFER_SIZE - channel-&gt;wrp - 1) % BUFFER_SIZE,
 365             BUFFER_SIZE - channel-&gt;wrp);
 366 
 367       if (channel-&gt;debug)
 368     g_print (&quot;read_thread %#x: calling read() for %d bytes\n&quot;,
 369          channel-&gt;thread_id, nbytes);
 370 
 371       LeaveCriticalSection (&amp;channel-&gt;mutex);
 372 
 373       nbytes = read (channel-&gt;fd, buffer, nbytes);
 374 
 375       EnterCriticalSection (&amp;channel-&gt;mutex);
 376 
 377       channel-&gt;revents = G_IO_IN;
 378       if (nbytes == 0)
 379     channel-&gt;revents |= G_IO_HUP;
 380       else if (nbytes &lt; 0)
 381     channel-&gt;revents |= G_IO_ERR;
 382 
 383       if (channel-&gt;debug)
 384     g_print (&quot;read_thread %#x: read() returned %d, rdp=%d, wrp=%d\n&quot;,
 385          channel-&gt;thread_id, nbytes, channel-&gt;rdp, channel-&gt;wrp);
 386 
 387       if (nbytes &lt;= 0)
 388     break;
 389 
 390       channel-&gt;wrp = (channel-&gt;wrp + nbytes) % BUFFER_SIZE;
 391       if (channel-&gt;debug)
 392     g_print (&quot;read_thread %#x: rdp=%d, wrp=%d, setting data_avail\n&quot;,
 393          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);
 394       SetEvent (channel-&gt;data_avail_event);
 395     }
 396 
 397   channel-&gt;running = FALSE;
 398   if (channel-&gt;needs_close)
 399     {
 400       if (channel-&gt;debug)
 401     g_print (&quot;read_thread %#x: channel fd %d needs closing\n&quot;,
 402          channel-&gt;thread_id, channel-&gt;fd);
 403       close (channel-&gt;fd);
 404       channel-&gt;fd = -1;
 405     }
 406 
 407   if (channel-&gt;debug)
 408     g_print (&quot;read_thread %#x: EOF, rdp=%d, wrp=%d, setting data_avail\n&quot;,
 409          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);
 410   SetEvent (channel-&gt;data_avail_event);
 411   LeaveCriticalSection (&amp;channel-&gt;mutex);
 412 
 413   g_io_channel_unref ((GIOChannel *)channel);
 414 
 415   /* No need to call _endthreadex(), the actual thread starter routine
 416    * in MSVCRT (see crt/src/threadex.c:_threadstartex) calls
 417    * _endthreadex() for us.
 418    */
 419 
 420   return 0;
 421 }
 422 
 423 static unsigned __stdcall
 424 write_thread (void *parameter)
 425 {
 426   GIOWin32Channel *channel = parameter;
 427   guchar *buffer;
 428   gint nbytes;
 429 
 430   g_io_channel_ref ((GIOChannel *)channel);
 431 
 432   if (channel-&gt;debug)
 433     g_print (&quot;write_thread %#x: start fd=%d, data_avail=%p space_avail=%p\n&quot;,
 434          channel-&gt;thread_id,
 435          channel-&gt;fd,
 436          channel-&gt;data_avail_event,
 437          channel-&gt;space_avail_event);
 438 
 439   channel-&gt;direction = 1;
 440   channel-&gt;buffer = g_malloc (BUFFER_SIZE);
 441   channel-&gt;rdp = channel-&gt;wrp = 0;
 442   channel-&gt;running = TRUE;
 443 
 444   SetEvent (channel-&gt;space_avail_event);
 445 
 446   /* We use the same event objects as for a reader thread, but with
 447    * reversed meaning. So, space_avail is used if data is available
 448    * for writing, and data_avail is used if space is available in the
 449    * write buffer.
 450    */
 451 
 452   EnterCriticalSection (&amp;channel-&gt;mutex);
 453   while (channel-&gt;running || channel-&gt;rdp != channel-&gt;wrp)
 454     {
 455       if (channel-&gt;debug)
 456     g_print (&quot;write_thread %#x: rdp=%d, wrp=%d\n&quot;,
 457          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);
 458       if (channel-&gt;wrp == channel-&gt;rdp)
 459     {
 460       /* Buffer is empty. */
 461       if (channel-&gt;debug)
 462         g_print (&quot;write_thread %#x: resetting space_avail\n&quot;,
 463              channel-&gt;thread_id);
 464       ResetEvent (channel-&gt;space_avail_event);
 465       if (channel-&gt;debug)
 466         g_print (&quot;write_thread %#x: waiting for data\n&quot;,
 467              channel-&gt;thread_id);
 468       channel-&gt;revents = G_IO_OUT;
 469       SetEvent (channel-&gt;data_avail_event);
 470       LeaveCriticalSection (&amp;channel-&gt;mutex);
 471       WaitForSingleObject (channel-&gt;space_avail_event, INFINITE);
 472 
 473       EnterCriticalSection (&amp;channel-&gt;mutex);
 474       if (channel-&gt;rdp == channel-&gt;wrp)
 475         break;
 476 
 477       if (channel-&gt;debug)
 478         g_print (&quot;write_thread %#x: rdp=%d, wrp=%d\n&quot;,
 479              channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);
 480     }
 481 
 482       buffer = channel-&gt;buffer + channel-&gt;rdp;
 483       if (channel-&gt;rdp &lt; channel-&gt;wrp)
 484     nbytes = channel-&gt;wrp - channel-&gt;rdp;
 485       else
 486     nbytes = BUFFER_SIZE - channel-&gt;rdp;
 487 
 488       if (channel-&gt;debug)
 489     g_print (&quot;write_thread %#x: calling write() for %d bytes\n&quot;,
 490          channel-&gt;thread_id, nbytes);
 491 
 492       LeaveCriticalSection (&amp;channel-&gt;mutex);
 493       nbytes = write (channel-&gt;fd, buffer, nbytes);
 494       EnterCriticalSection (&amp;channel-&gt;mutex);
 495 
 496       if (channel-&gt;debug)
 497     g_print (&quot;write_thread %#x: write(%i) returned %d, rdp=%d, wrp=%d\n&quot;,
 498          channel-&gt;thread_id, channel-&gt;fd, nbytes, channel-&gt;rdp, channel-&gt;wrp);
 499 
 500       channel-&gt;revents = 0;
 501       if (nbytes &gt; 0)
 502     channel-&gt;revents |= G_IO_OUT;
 503       else if (nbytes &lt;= 0)
 504     channel-&gt;revents |= G_IO_ERR;
 505 
 506       channel-&gt;rdp = (channel-&gt;rdp + nbytes) % BUFFER_SIZE;
 507 
 508       if (nbytes &lt;= 0)
 509     break;
 510 
 511       if (channel-&gt;debug)
 512     g_print (&quot;write_thread: setting data_avail for thread %#x\n&quot;,
 513          channel-&gt;thread_id);
 514       SetEvent (channel-&gt;data_avail_event);
 515     }
 516 
 517   channel-&gt;running = FALSE;
 518   if (channel-&gt;needs_close)
 519     {
 520       if (channel-&gt;debug)
 521     g_print (&quot;write_thread %#x: channel fd %d needs closing\n&quot;,
 522          channel-&gt;thread_id, channel-&gt;fd);
 523       close (channel-&gt;fd);
 524       channel-&gt;fd = -1;
 525     }
 526 
 527   LeaveCriticalSection (&amp;channel-&gt;mutex);
 528 
 529   g_io_channel_unref ((GIOChannel *)channel);
 530 
 531   return 0;
 532 }
 533 
 534 static void
 535 create_thread (GIOWin32Channel     *channel,
 536            GIOCondition         condition,
 537            unsigned (__stdcall *thread) (void *parameter))
 538 {
 539   HANDLE thread_handle;
 540   int errsv;
 541 
 542   thread_handle = (HANDLE) _beginthreadex (NULL, 0, thread, channel, 0,
 543                        &amp;channel-&gt;thread_id);
 544   errsv = errno;
 545   if (thread_handle == 0)
 546     g_warning (&quot;Error creating thread: %s.&quot;,
 547            g_strerror (errsv));
 548   else if (!CloseHandle (thread_handle))
 549     {
 550       gchar *emsg = g_win32_error_message (GetLastError ());
 551 
 552       g_warning (&quot;Error closing thread handle: %s.&quot;, emsg);
 553       g_free (emsg);
 554     }
 555 
 556   WaitForSingleObject (channel-&gt;space_avail_event, INFINITE);
 557 }
 558 
 559 static GIOStatus
 560 buffer_read (GIOWin32Channel *channel,
 561          gchar           *dest,
 562          gsize            count,
 563          gsize           *bytes_read,
 564          GError         **err)
 565 {
 566   guint nbytes;
 567   guint left = count;
 568 
 569   EnterCriticalSection (&amp;channel-&gt;mutex);
 570   if (channel-&gt;debug)
 571     g_print (&quot;reading from thread %#x %&quot; G_GSIZE_FORMAT &quot; bytes, rdp=%d, wrp=%d\n&quot;,
 572          channel-&gt;thread_id, count, channel-&gt;rdp, channel-&gt;wrp);
 573 
 574   if (channel-&gt;wrp == channel-&gt;rdp)
 575     {
 576       LeaveCriticalSection (&amp;channel-&gt;mutex);
 577       if (channel-&gt;debug)
 578     g_print (&quot;waiting for data from thread %#x\n&quot;, channel-&gt;thread_id);
 579       WaitForSingleObject (channel-&gt;data_avail_event, INFINITE);
 580       if (channel-&gt;debug)
 581     g_print (&quot;done waiting for data from thread %#x\n&quot;, channel-&gt;thread_id);
 582       EnterCriticalSection (&amp;channel-&gt;mutex);
 583       if (channel-&gt;wrp == channel-&gt;rdp &amp;&amp; !channel-&gt;running)
 584     {
 585       if (channel-&gt;debug)
 586         g_print (&quot;wrp==rdp, !running\n&quot;);
 587       LeaveCriticalSection (&amp;channel-&gt;mutex);
 588           *bytes_read = 0;
 589       return G_IO_STATUS_EOF;
 590     }
 591     }
 592 
 593   if (channel-&gt;rdp &lt; channel-&gt;wrp)
 594     nbytes = channel-&gt;wrp - channel-&gt;rdp;
 595   else
 596     nbytes = BUFFER_SIZE - channel-&gt;rdp;
 597   LeaveCriticalSection (&amp;channel-&gt;mutex);
 598   nbytes = MIN (left, nbytes);
 599   if (channel-&gt;debug)
 600     g_print (&quot;moving %d bytes from thread %#x\n&quot;,
 601          nbytes, channel-&gt;thread_id);
 602   memcpy (dest, channel-&gt;buffer + channel-&gt;rdp, nbytes);
 603   dest += nbytes;
 604   left -= nbytes;
 605   EnterCriticalSection (&amp;channel-&gt;mutex);
 606   channel-&gt;rdp = (channel-&gt;rdp + nbytes) % BUFFER_SIZE;
 607   if (channel-&gt;debug)
 608     g_print (&quot;setting space_avail for thread %#x\n&quot;, channel-&gt;thread_id);
 609   SetEvent (channel-&gt;space_avail_event);
 610   if (channel-&gt;debug)
 611     g_print (&quot;for thread %#x: rdp=%d, wrp=%d\n&quot;,
 612          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);
 613   if (channel-&gt;running &amp;&amp; channel-&gt;wrp == channel-&gt;rdp)
 614     {
 615       if (channel-&gt;debug)
 616     g_print (&quot;resetting data_avail of thread %#x\n&quot;,
 617          channel-&gt;thread_id);
 618       ResetEvent (channel-&gt;data_avail_event);
 619     };
 620   LeaveCriticalSection (&amp;channel-&gt;mutex);
 621 
 622   /* We have no way to indicate any errors form the actual
 623    * read() or recv() call in the reader thread. Should we have?
 624    */
 625   *bytes_read = count - left;
 626   return (*bytes_read &gt; 0) ? G_IO_STATUS_NORMAL : G_IO_STATUS_EOF;
 627 }
 628 
 629 
 630 static GIOStatus
 631 buffer_write (GIOWin32Channel *channel,
 632           const gchar     *dest,
 633           gsize            count,
 634           gsize           *bytes_written,
 635           GError         **err)
 636 {
 637   guint nbytes;
 638   guint left = count;
 639 
 640   EnterCriticalSection (&amp;channel-&gt;mutex);
 641   if (channel-&gt;debug)
 642     g_print (&quot;buffer_write: writing to thread %#x %&quot; G_GSIZE_FORMAT &quot; bytes, rdp=%d, wrp=%d\n&quot;,
 643          channel-&gt;thread_id, count, channel-&gt;rdp, channel-&gt;wrp);
 644 
 645   if ((channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)
 646     {
 647       /* Buffer is full */
 648       if (channel-&gt;debug)
 649     g_print (&quot;buffer_write: tid %#x: resetting data_avail\n&quot;,
 650          channel-&gt;thread_id);
 651       ResetEvent (channel-&gt;data_avail_event);
 652       if (channel-&gt;debug)
 653     g_print (&quot;buffer_write: tid %#x: waiting for space\n&quot;,
 654          channel-&gt;thread_id);
 655       LeaveCriticalSection (&amp;channel-&gt;mutex);
 656       WaitForSingleObject (channel-&gt;data_avail_event, INFINITE);
 657       EnterCriticalSection (&amp;channel-&gt;mutex);
 658       if (channel-&gt;debug)
 659     g_print (&quot;buffer_write: tid %#x: rdp=%d, wrp=%d\n&quot;,
 660          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);
 661     }
 662 
 663   nbytes = MIN ((channel-&gt;rdp + BUFFER_SIZE - channel-&gt;wrp - 1) % BUFFER_SIZE,
 664         BUFFER_SIZE - channel-&gt;wrp);
 665 
 666   LeaveCriticalSection (&amp;channel-&gt;mutex);
 667   nbytes = MIN (left, nbytes);
 668   if (channel-&gt;debug)
 669     g_print (&quot;buffer_write: tid %#x: writing %d bytes\n&quot;,
 670          channel-&gt;thread_id, nbytes);
 671   memcpy (channel-&gt;buffer + channel-&gt;wrp, dest, nbytes);
 672   dest += nbytes;
 673   left -= nbytes;
 674   EnterCriticalSection (&amp;channel-&gt;mutex);
 675 
 676   channel-&gt;wrp = (channel-&gt;wrp + nbytes) % BUFFER_SIZE;
 677   if (channel-&gt;debug)
 678     g_print (&quot;buffer_write: tid %#x: rdp=%d, wrp=%d, setting space_avail\n&quot;,
 679          channel-&gt;thread_id, channel-&gt;rdp, channel-&gt;wrp);
 680   SetEvent (channel-&gt;space_avail_event);
 681 
 682   if ((channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)
 683     {
 684       /* Buffer is full */
 685       if (channel-&gt;debug)
 686     g_print (&quot;buffer_write: tid %#x: resetting data_avail\n&quot;,
 687          channel-&gt;thread_id);
 688       ResetEvent (channel-&gt;data_avail_event);
 689     }
 690 
 691   LeaveCriticalSection (&amp;channel-&gt;mutex);
 692 
 693   /* We have no way to indicate any errors form the actual
 694    * write() call in the writer thread. Should we have?
 695    */
 696   *bytes_written = count - left;
 697   return (*bytes_written &gt; 0) ? G_IO_STATUS_NORMAL : G_IO_STATUS_EOF;
 698 }
 699 
 700 
 701 static gboolean
 702 g_io_win32_prepare (GSource *source,
 703             gint    *timeout)
 704 {
 705   GIOWin32Watch *watch = (GIOWin32Watch *)source;
 706   GIOCondition buffer_condition = g_io_channel_get_buffer_condition (watch-&gt;channel);
 707   GIOWin32Channel *channel = (GIOWin32Channel *)watch-&gt;channel;
 708   int event_mask;
 709 
 710   *timeout = -1;
 711 
 712   if (channel-&gt;debug)
 713     g_print (&quot;g_io_win32_prepare: source=%p channel=%p&quot;, source, channel);
 714 
 715   switch (channel-&gt;type)
 716     {
 717     case G_IO_WIN32_WINDOWS_MESSAGES:
 718       if (channel-&gt;debug)
 719     g_print (&quot; MSG&quot;);
 720       break;
 721 
 722     case G_IO_WIN32_CONSOLE:
 723       if (channel-&gt;debug)
 724     g_print (&quot; CON&quot;);
 725       break;
 726 
 727     case G_IO_WIN32_FILE_DESC:
 728       if (channel-&gt;debug)
 729     g_print (&quot; FD thread=%#x buffer_condition:{%s}&quot;
 730          &quot;\n  watch-&gt;pollfd.events:{%s} watch-&gt;pollfd.revents:{%s} channel-&gt;revents:{%s}&quot;,
 731          channel-&gt;thread_id, condition_to_string (buffer_condition),
 732          condition_to_string (watch-&gt;pollfd.events),
 733          condition_to_string (watch-&gt;pollfd.revents),
 734          condition_to_string (channel-&gt;revents));
 735 
 736       EnterCriticalSection (&amp;channel-&gt;mutex);
 737       if (channel-&gt;running)
 738     {
 739       if (channel-&gt;direction == 0 &amp;&amp; channel-&gt;wrp == channel-&gt;rdp)
 740         {
 741           if (channel-&gt;debug)
 742         g_print (&quot;\n  setting revents=0&quot;);
 743           channel-&gt;revents = 0;
 744         }
 745     }
 746       else
 747     {
 748       if (channel-&gt;direction == 1
 749           &amp;&amp; (channel-&gt;wrp + 1) % BUFFER_SIZE == channel-&gt;rdp)
 750         {
 751           if (channel-&gt;debug)
 752         g_print (&quot;\n setting revents=0&quot;);
 753           channel-&gt;revents = 0;
 754         }
 755     }
 756       LeaveCriticalSection (&amp;channel-&gt;mutex);
 757       break;
 758 
 759     case G_IO_WIN32_SOCKET:
 760       if (channel-&gt;debug)
 761     g_print (&quot; SOCK&quot;);
 762       event_mask = 0;
 763       if (watch-&gt;condition &amp; G_IO_IN)
 764     event_mask |= (FD_READ | FD_ACCEPT);
 765       if (watch-&gt;condition &amp; G_IO_OUT)
 766     event_mask |= (FD_WRITE | FD_CONNECT);
 767       event_mask |= FD_CLOSE;
 768 
 769       if (channel-&gt;event_mask != event_mask)
 770     {
 771       if (channel-&gt;debug)
 772         g_print (&quot;\n  WSAEventSelect(%d,%p,{%s})&quot;,
 773              channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd,
 774              event_mask_to_string (event_mask));
 775       if (WSAEventSelect (channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd,
 776                   event_mask) == SOCKET_ERROR)
 777         if (channel-&gt;debug)
 778           {
 779         gchar *emsg = g_win32_error_message (WSAGetLastError ());
 780 
 781         g_print (&quot; failed: %s&quot;, emsg);
 782         g_free (emsg);
 783           }
 784       channel-&gt;event_mask = event_mask;
 785 
 786       if (channel-&gt;debug)
 787         g_print (&quot;\n  setting last_events=0&quot;);
 788       channel-&gt;last_events = 0;
 789 
 790       if ((event_mask &amp; FD_WRITE) &amp;&amp;
 791           channel-&gt;ever_writable &amp;&amp;
 792           !channel-&gt;write_would_have_blocked)
 793         {
 794           if (channel-&gt;debug)
 795         g_print (&quot; WSASetEvent(%p)&quot;, (WSAEVENT) watch-&gt;pollfd.fd);
 796           WSASetEvent ((WSAEVENT) watch-&gt;pollfd.fd);
 797         }
 798     }
 799       break;
 800 
 801     default:
 802       g_assert_not_reached ();
 803       g_abort ();
 804     }
 805   if (channel-&gt;debug)
 806     g_print (&quot;\n&quot;);
 807 
 808   return ((watch-&gt;condition &amp; buffer_condition) == watch-&gt;condition);
 809 }
 810 
 811 static gboolean
 812 g_io_win32_check (GSource *source)
 813 {
 814   MSG msg;
 815   GIOWin32Watch *watch = (GIOWin32Watch *)source;
 816   GIOWin32Channel *channel = (GIOWin32Channel *)watch-&gt;channel;
 817   GIOCondition buffer_condition = g_io_channel_get_buffer_condition (watch-&gt;channel);
 818   WSANETWORKEVENTS events;
 819 
 820   if (channel-&gt;debug)
 821     g_print (&quot;g_io_win32_check: source=%p channel=%p&quot;, source, channel);
 822 
 823   switch (channel-&gt;type)
 824     {
 825     case G_IO_WIN32_WINDOWS_MESSAGES:
 826       if (channel-&gt;debug)
 827     g_print (&quot; MSG\n&quot;);
 828       return (PeekMessage (&amp;msg, channel-&gt;hwnd, 0, 0, PM_NOREMOVE));
 829 
 830     case G_IO_WIN32_FILE_DESC:
 831       if (channel-&gt;debug)
 832     g_print (&quot; FD thread=%#x buffer_condition=%s\n&quot;
 833          &quot;  watch-&gt;pollfd.events={%s} watch-&gt;pollfd.revents={%s} channel-&gt;revents={%s}\n&quot;,
 834          channel-&gt;thread_id, condition_to_string (buffer_condition),
 835          condition_to_string (watch-&gt;pollfd.events),
 836          condition_to_string (watch-&gt;pollfd.revents),
 837          condition_to_string (channel-&gt;revents));
 838 
 839       watch-&gt;pollfd.revents = (watch-&gt;pollfd.events &amp; channel-&gt;revents);
 840 
 841       return ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition);
 842 
 843     case G_IO_WIN32_CONSOLE:
 844       if (channel-&gt;debug)
 845     g_print (&quot; CON\n&quot;);
 846       if (watch-&gt;channel-&gt;is_writeable)
 847     return TRUE;
 848       else if (watch-&gt;channel-&gt;is_readable)
 849         {
 850       INPUT_RECORD buffer;
 851       DWORD n;
 852       if (PeekConsoleInput ((HANDLE) watch-&gt;pollfd.fd, &amp;buffer, 1, &amp;n) &amp;&amp;
 853           n == 1)
 854         {
 855           /* _kbhit() does quite complex processing to find out
 856            * whether at least one of the key events pending corresponds
 857            * to a &quot;real&quot; character that can be read.
 858            */
 859           if (_kbhit ())
 860         return TRUE;
 861 
 862           /* Discard all other kinds of events */
 863           ReadConsoleInput ((HANDLE) watch-&gt;pollfd.fd, &amp;buffer, 1, &amp;n);
 864         }
 865         }
 866       return FALSE;
 867 
 868     case G_IO_WIN32_SOCKET:
 869       if (channel-&gt;debug)
 870     g_print (&quot; SOCK&quot;);
 871       if (channel-&gt;last_events &amp; FD_WRITE)
 872     {
 873       if (channel-&gt;debug)
 874         g_print (&quot; sock=%d event=%p last_events has FD_WRITE&quot;,
 875              channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd);
 876     }
 877       else
 878     {
 879       WSAEnumNetworkEvents (channel-&gt;fd, 0, &amp;events);
 880 
 881       if (channel-&gt;debug)
 882         g_print (&quot;\n  revents={%s} condition={%s}&quot;
 883              &quot;\n  WSAEnumNetworkEvents(%d,0) sets events={%s}&quot;,
 884              condition_to_string (watch-&gt;pollfd.revents),
 885              condition_to_string (watch-&gt;condition),
 886              channel-&gt;fd,
 887              event_mask_to_string (events.lNetworkEvents));
 888 
 889       if (watch-&gt;pollfd.revents != 0 &amp;&amp;
 890           events.lNetworkEvents == 0 &amp;&amp;
 891           !(channel-&gt;event_mask &amp; FD_WRITE))
 892         {
 893           channel-&gt;event_mask = 0;
 894           if (channel-&gt;debug)
 895         g_print (&quot;\n  WSAEventSelect(%d,%p,{})&quot;,
 896              channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd);
 897           WSAEventSelect (channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd, 0);
 898           if (channel-&gt;debug)
 899         g_print (&quot;  ResetEvent(%p)&quot;,
 900              (HANDLE) watch-&gt;pollfd.fd);
 901           ResetEvent ((HANDLE) watch-&gt;pollfd.fd);
 902         }
 903       else if (events.lNetworkEvents &amp; FD_WRITE)
 904         channel-&gt;ever_writable = TRUE;
 905       channel-&gt;last_events = events.lNetworkEvents;
 906     }
 907 
 908       watch-&gt;pollfd.revents = 0;
 909       if (channel-&gt;last_events &amp; (FD_READ | FD_ACCEPT))
 910     watch-&gt;pollfd.revents |= G_IO_IN;
 911 
 912       if (channel-&gt;last_events &amp; FD_WRITE)
 913     watch-&gt;pollfd.revents |= G_IO_OUT;
 914       else
 915     {
 916       /* We have called WSAEnumNetworkEvents() above but it didn&#39;t
 917        * set FD_WRITE.
 918        */
 919       if (events.lNetworkEvents &amp; FD_CONNECT)
 920         {
 921           if (events.iErrorCode[FD_CONNECT_BIT] == 0)
 922         watch-&gt;pollfd.revents |= G_IO_OUT;
 923           else
 924         watch-&gt;pollfd.revents |= (G_IO_HUP | G_IO_ERR);
 925         }
 926       if (watch-&gt;pollfd.revents == 0 &amp;&amp; (channel-&gt;last_events &amp; (FD_CLOSE)))
 927         watch-&gt;pollfd.revents |= G_IO_HUP;
 928     }
 929 
 930       /* Regardless of WSAEnumNetworkEvents() result, if watching for
 931        * writability, and if we have ever got a FD_WRITE event, and
 932        * unless last write would have blocked, set G_IO_OUT. But never
 933        * set both G_IO_OUT and G_IO_HUP.
 934        */
 935       if (!(watch-&gt;pollfd.revents &amp; G_IO_HUP) &amp;&amp;
 936       channel-&gt;ever_writable &amp;&amp;
 937       !channel-&gt;write_would_have_blocked &amp;&amp;
 938       (channel-&gt;event_mask &amp; FD_WRITE))
 939     watch-&gt;pollfd.revents |= G_IO_OUT;
 940 
 941       if (channel-&gt;debug)
 942     g_print (&quot;\n  revents={%s} retval={%s}\n&quot;,
 943          condition_to_string (watch-&gt;pollfd.revents),
 944          condition_to_string ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition));
 945 
 946       return ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition);
 947 
 948     default:
 949       g_assert_not_reached ();
 950       g_abort ();
 951     }
 952 }
 953 
 954 static gboolean
 955 g_io_win32_dispatch (GSource     *source,
 956              GSourceFunc  callback,
 957              gpointer     user_data)
 958 {
 959   GIOFunc func = (GIOFunc)callback;
 960   GIOWin32Watch *watch = (GIOWin32Watch *)source;
 961   GIOWin32Channel *channel = (GIOWin32Channel *)watch-&gt;channel;
 962   GIOCondition buffer_condition = g_io_channel_get_buffer_condition (watch-&gt;channel);
 963 
 964   if (!func)
 965     {
 966       g_warning (&quot;IO Watch dispatched without callback. &quot;
 967          &quot;You must call g_source_connect().&quot;);
 968       return FALSE;
 969     }
 970 
 971   if (channel-&gt;debug)
 972     g_print (&quot;g_io_win32_dispatch: pollfd.revents=%s condition=%s result=%s\n&quot;,
 973          condition_to_string (watch-&gt;pollfd.revents),
 974          condition_to_string (watch-&gt;condition),
 975          condition_to_string ((watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition));
 976 
 977   return (*func) (watch-&gt;channel,
 978           (watch-&gt;pollfd.revents | buffer_condition) &amp; watch-&gt;condition,
 979           user_data);
 980 }
 981 
 982 static void
 983 g_io_win32_finalize (GSource *source)
 984 {
 985   GIOWin32Watch *watch = (GIOWin32Watch *)source;
 986   GIOWin32Channel *channel = (GIOWin32Channel *)watch-&gt;channel;
 987 
 988   if (channel-&gt;debug)
 989     g_print (&quot;g_io_win32_finalize: source=%p channel=%p&quot;, source, channel);
 990 
 991   switch (channel-&gt;type)
 992     {
 993     case G_IO_WIN32_WINDOWS_MESSAGES:
 994       if (channel-&gt;debug)
 995     g_print (&quot; MSG&quot;);
 996       break;
 997 
 998     case G_IO_WIN32_CONSOLE:
 999       if (channel-&gt;debug)
1000     g_print (&quot; CON&quot;);
1001       break;
1002 
1003     case G_IO_WIN32_FILE_DESC:
1004       if (channel-&gt;debug)
1005     g_print (&quot; FD thread=%#x&quot;, channel-&gt;thread_id);
1006       break;
1007 
1008     case G_IO_WIN32_SOCKET:
1009       if (channel-&gt;debug)
1010     g_print (&quot; SOCK sock=%d&quot;, channel-&gt;fd);
1011       break;
1012 
1013     default:
1014       g_assert_not_reached ();
1015       g_abort ();
1016     }
1017   if (channel-&gt;debug)
1018     g_print (&quot;\n&quot;);
1019   g_io_channel_unref (watch-&gt;channel);
1020 }
1021 
1022 GSourceFuncs g_io_watch_funcs = {
1023   g_io_win32_prepare,
1024   g_io_win32_check,
1025   g_io_win32_dispatch,
1026   g_io_win32_finalize
1027 };
1028 
1029 static GIOStatus
1030 g_io_win32_msg_read (GIOChannel *channel,
1031              gchar      *buf,
1032              gsize       count,
1033              gsize      *bytes_read,
1034              GError    **err)
1035 {
1036   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1037   MSG msg;               /* In case of alignment problems */
1038 
1039   *bytes_read = 0;
1040 
1041   if (count &lt; sizeof (MSG))
1042     {
1043       g_set_error_literal (err, G_IO_CHANNEL_ERROR, G_IO_CHANNEL_ERROR_INVAL,
1044                            &quot;Incorrect message size&quot;); /* Informative enough error message? */
1045       return G_IO_STATUS_ERROR;
1046     }
1047 
1048   if (win32_channel-&gt;debug)
1049     g_print (&quot;g_io_win32_msg_read: channel=%p hwnd=%p\n&quot;,
1050          channel, win32_channel-&gt;hwnd);
1051   if (!PeekMessage (&amp;msg, win32_channel-&gt;hwnd, 0, 0, PM_REMOVE))
1052     return G_IO_STATUS_AGAIN;
1053 
1054   memmove (buf, &amp;msg, sizeof (MSG));
1055   *bytes_read = sizeof (MSG);
1056 
1057   return G_IO_STATUS_NORMAL;
1058 }
1059 
1060 static GIOStatus
1061 g_io_win32_msg_write (GIOChannel  *channel,
1062               const gchar *buf,
1063               gsize        count,
1064               gsize       *bytes_written,
1065               GError     **err)
1066 {
1067   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1068   MSG msg;
1069 
1070   *bytes_written = 0;
1071 
1072   if (count != sizeof (MSG))
1073     {
1074       g_set_error_literal (err, G_IO_CHANNEL_ERROR, G_IO_CHANNEL_ERROR_INVAL,
1075                            &quot;Incorrect message size&quot;); /* Informative enough error message? */
1076       return G_IO_STATUS_ERROR;
1077     }
1078 
1079   /* In case of alignment problems */
1080   memmove (&amp;msg, buf, sizeof (MSG));
1081   if (!PostMessage (win32_channel-&gt;hwnd, msg.message, msg.wParam, msg.lParam))
1082     {
1083       gchar *emsg = g_win32_error_message (GetLastError ());
1084 
1085       g_set_error_literal (err, G_IO_CHANNEL_ERROR, G_IO_CHANNEL_ERROR_FAILED, emsg);
1086       g_free (emsg);
1087 
1088       return G_IO_STATUS_ERROR;
1089     }
1090 
1091   *bytes_written = sizeof (MSG);
1092 
1093   return G_IO_STATUS_NORMAL;
1094 }
1095 
1096 static GIOStatus
1097 g_io_win32_msg_close (GIOChannel *channel,
1098               GError    **err)
1099 {
1100   /* Nothing to be done. Or should we set hwnd to some invalid value? */
1101 
1102   return G_IO_STATUS_NORMAL;
1103 }
1104 
1105 static void
1106 g_io_win32_free (GIOChannel *channel)
1107 {
1108   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1109 
1110   if (win32_channel-&gt;debug)
1111     g_print (&quot;g_io_win32_free channel=%p fd=%d\n&quot;, channel, win32_channel-&gt;fd);
1112 
1113   DeleteCriticalSection (&amp;win32_channel-&gt;mutex);
1114 
1115   if (win32_channel-&gt;data_avail_event)
1116     if (!CloseHandle (win32_channel-&gt;data_avail_event))
1117       if (win32_channel-&gt;debug)
1118     {
1119       gchar *emsg = g_win32_error_message (GetLastError ());
1120 
1121       g_print (&quot;  CloseHandle(%p) failed: %s\n&quot;,
1122            win32_channel-&gt;data_avail_event, emsg);
1123       g_free (emsg);
1124     }
1125 
1126   g_free (win32_channel-&gt;buffer);
1127 
1128   if (win32_channel-&gt;space_avail_event)
1129     if (!CloseHandle (win32_channel-&gt;space_avail_event))
1130       if (win32_channel-&gt;debug)
1131     {
1132       gchar *emsg = g_win32_error_message (GetLastError ());
1133 
1134       g_print (&quot;  CloseHandle(%p) failed: %s\n&quot;,
1135            win32_channel-&gt;space_avail_event, emsg);
1136       g_free (emsg);
1137     }
1138 
1139   if (win32_channel-&gt;type == G_IO_WIN32_SOCKET &amp;&amp;
1140       win32_channel-&gt;fd != -1)
1141     if (WSAEventSelect (win32_channel-&gt;fd, NULL, 0) == SOCKET_ERROR)
1142       if (win32_channel-&gt;debug)
1143     {
1144       gchar *emsg = g_win32_error_message (WSAGetLastError ());
1145 
1146       g_print (&quot;  WSAEventSelect(%d,NULL,{}) failed: %s\n&quot;,
1147            win32_channel-&gt;fd, emsg);
1148       g_free (emsg);
1149     }
1150 
1151   if (win32_channel-&gt;event)
1152     if (!WSACloseEvent (win32_channel-&gt;event))
1153       if (win32_channel-&gt;debug)
1154     {
1155       gchar *emsg = g_win32_error_message (WSAGetLastError ());
1156 
1157       g_print (&quot;  WSACloseEvent(%p) failed: %s\n&quot;,
1158            win32_channel-&gt;event, emsg);
1159       g_free (emsg);
1160     }
1161 
1162   g_free (win32_channel);
1163 }
1164 
1165 static GSource *
1166 g_io_win32_msg_create_watch (GIOChannel   *channel,
1167                  GIOCondition  condition)
1168 {
1169   GIOWin32Watch *watch;
1170   GSource *source;
1171 
1172   source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
1173   g_source_set_name (source, &quot;GIOChannel (Win32)&quot;);
1174   watch = (GIOWin32Watch *)source;
1175 
1176   watch-&gt;channel = channel;
1177   g_io_channel_ref (channel);
1178 
1179   watch-&gt;condition = condition;
1180 
1181   watch-&gt;pollfd.fd = (gintptr) G_WIN32_MSG_HANDLE;
1182   watch-&gt;pollfd.events = condition;
1183 
1184   g_source_add_poll (source, &amp;watch-&gt;pollfd);
1185 
1186   return source;
1187 }
1188 
1189 static GIOStatus
1190 g_io_win32_fd_and_console_read (GIOChannel *channel,
1191                 gchar      *buf,
1192                 gsize       count,
1193                 gsize      *bytes_read,
1194                 GError    **err)
1195 {
1196   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1197   gint result;
1198   int errsv;
1199 
1200   if (win32_channel-&gt;debug)
1201     g_print (&quot;g_io_win32_fd_read: fd=%d count=%&quot; G_GSIZE_FORMAT &quot;\n&quot;,
1202          win32_channel-&gt;fd, count);
1203 
1204   if (win32_channel-&gt;thread_id)
1205     {
1206       return buffer_read (win32_channel, buf, count, bytes_read, err);
1207     }
1208 
1209   result = read (win32_channel-&gt;fd, buf, count);
1210   errsv = errno;
1211 
1212   if (win32_channel-&gt;debug)
1213     g_print (&quot;g_io_win32_fd_read: read() =&gt; %d\n&quot;, result);
1214 
1215   if (result &lt; 0)
1216     {
1217       *bytes_read = 0;
1218 
1219       switch (errsv)
1220         {
1221 #ifdef EAGAIN
1222     case EAGAIN:
1223       return G_IO_STATUS_AGAIN;
1224 #endif
1225     default:
1226       g_set_error_literal (err, G_IO_CHANNEL_ERROR,
1227                                g_io_channel_error_from_errno (errsv),
1228                                g_strerror (errsv));
1229       return G_IO_STATUS_ERROR;
1230         }
1231     }
1232 
1233   *bytes_read = result;
1234 
1235   return (result &gt; 0) ? G_IO_STATUS_NORMAL : G_IO_STATUS_EOF;
1236 }
1237 
1238 static GIOStatus
1239 g_io_win32_fd_and_console_write (GIOChannel  *channel,
1240                  const gchar *buf,
1241                  gsize        count,
1242                  gsize       *bytes_written,
1243                  GError     **err)
1244 {
1245   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1246   gint result;
1247   int errsv;
1248 
1249   if (win32_channel-&gt;thread_id)
1250     {
1251       return buffer_write (win32_channel, buf, count, bytes_written, err);
1252     }
1253 
1254   result = write (win32_channel-&gt;fd, buf, count);
1255   errsv = errno;
1256 
1257   if (win32_channel-&gt;debug)
1258     g_print (&quot;g_io_win32_fd_write: fd=%d count=%&quot; G_GSIZE_FORMAT &quot; =&gt; %d\n&quot;,
1259          win32_channel-&gt;fd, count, result);
1260 
1261   if (result &lt; 0)
1262     {
1263       *bytes_written = 0;
1264 
1265       switch (errsv)
1266         {
1267 #ifdef EAGAIN
1268     case EAGAIN:
1269       return G_IO_STATUS_AGAIN;
1270 #endif
1271     default:
1272       g_set_error_literal (err, G_IO_CHANNEL_ERROR,
1273                                g_io_channel_error_from_errno (errsv),
1274                                g_strerror (errsv));
1275       return G_IO_STATUS_ERROR;
1276         }
1277     }
1278 
1279   *bytes_written = result;
1280 
1281   return G_IO_STATUS_NORMAL;
1282 }
1283 
1284 static GIOStatus
1285 g_io_win32_fd_seek (GIOChannel *channel,
1286             gint64      offset,
1287             GSeekType   type,
1288             GError    **err)
1289 {
1290   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1291   int whence, errsv;
1292   off_t tmp_offset;
1293   off_t result;
1294 
1295   switch (type)
1296     {
1297     case G_SEEK_SET:
1298       whence = SEEK_SET;
1299       break;
1300     case G_SEEK_CUR:
1301       whence = SEEK_CUR;
1302       break;
1303     case G_SEEK_END:
1304       whence = SEEK_END;
1305       break;
1306     default:
1307       whence = -1; /* Keep the compiler quiet */
1308       g_assert_not_reached ();
1309       g_abort ();
1310     }
1311 
1312   tmp_offset = offset;
1313   if (tmp_offset != offset)
1314     {
1315       g_set_error_literal (err, G_IO_CHANNEL_ERROR,
1316                            g_io_channel_error_from_errno (EINVAL),
1317                            g_strerror (EINVAL));
1318       return G_IO_STATUS_ERROR;
1319     }
1320 
1321   result = lseek (win32_channel-&gt;fd, tmp_offset, whence);
1322   errsv = errno;
1323 
1324   if (result &lt; 0)
1325     {
1326       g_set_error_literal (err, G_IO_CHANNEL_ERROR,
1327                            g_io_channel_error_from_errno (errsv),
1328                            g_strerror (errsv));
1329       return G_IO_STATUS_ERROR;
1330     }
1331 
1332   return G_IO_STATUS_NORMAL;
1333 }
1334 
1335 static GIOStatus
1336 g_io_win32_fd_close (GIOChannel *channel,
1337                  GError    **err)
1338 {
1339   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1340 
1341   if (win32_channel-&gt;debug)
1342     g_print (&quot;g_io_win32_fd_close: thread=%#x: fd=%d\n&quot;,
1343          win32_channel-&gt;thread_id,
1344          win32_channel-&gt;fd);
1345   EnterCriticalSection (&amp;win32_channel-&gt;mutex);
1346   if (win32_channel-&gt;running)
1347     {
1348       if (win32_channel-&gt;debug)
1349     g_print (&quot;thread %#x: running, marking fd %d for later close\n&quot;,
1350          win32_channel-&gt;thread_id, win32_channel-&gt;fd);
1351       win32_channel-&gt;running = FALSE;
1352       win32_channel-&gt;needs_close = TRUE;
1353       if (win32_channel-&gt;direction == 0)
1354     SetEvent (win32_channel-&gt;data_avail_event);
1355       else
1356     SetEvent (win32_channel-&gt;space_avail_event);
1357     }
1358   else
1359     {
1360       if (win32_channel-&gt;debug)
1361     g_print (&quot;closing fd %d\n&quot;, win32_channel-&gt;fd);
1362       close (win32_channel-&gt;fd);
1363       if (win32_channel-&gt;debug)
1364     g_print (&quot;closed fd %d, setting to -1\n&quot;,
1365          win32_channel-&gt;fd);
1366       win32_channel-&gt;fd = -1;
1367     }
1368   LeaveCriticalSection (&amp;win32_channel-&gt;mutex);
1369 
1370   /* FIXME error detection? */
1371 
1372   return G_IO_STATUS_NORMAL;
1373 }
1374 
1375 static GSource *
1376 g_io_win32_fd_create_watch (GIOChannel    *channel,
1377                 GIOCondition   condition)
1378 {
1379   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1380   GSource *source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
1381   GIOWin32Watch *watch = (GIOWin32Watch *)source;
1382 
1383   watch-&gt;channel = channel;
1384   g_io_channel_ref (channel);
1385 
1386   watch-&gt;condition = condition;
1387 
1388   if (win32_channel-&gt;data_avail_event == NULL)
1389     create_events (win32_channel);
1390 
1391   watch-&gt;pollfd.fd = (gintptr) win32_channel-&gt;data_avail_event;
1392   watch-&gt;pollfd.events = condition;
1393 
1394   if (win32_channel-&gt;debug)
1395     g_print (&quot;g_io_win32_fd_create_watch: channel=%p fd=%d condition={%s} event=%p\n&quot;,
1396          channel, win32_channel-&gt;fd,
1397          condition_to_string (condition), (HANDLE) watch-&gt;pollfd.fd);
1398 
1399   EnterCriticalSection (&amp;win32_channel-&gt;mutex);
1400   if (win32_channel-&gt;thread_id == 0)
1401     {
1402       if (condition &amp; G_IO_IN)
1403     create_thread (win32_channel, condition, read_thread);
1404       else if (condition &amp; G_IO_OUT)
1405     create_thread (win32_channel, condition, write_thread);
1406     }
1407 
1408   g_source_add_poll (source, &amp;watch-&gt;pollfd);
1409   LeaveCriticalSection (&amp;win32_channel-&gt;mutex);
1410 
1411   return source;
1412 }
1413 
1414 static GIOStatus
1415 g_io_win32_console_close (GIOChannel *channel,
1416                   GError    **err)
1417 {
1418   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1419 
1420   if (close (win32_channel-&gt;fd) &lt; 0)
1421     {
1422       int errsv = errno;
1423       g_set_error_literal (err, G_IO_CHANNEL_ERROR,
1424                            g_io_channel_error_from_errno (errsv),
1425                            g_strerror (errsv));
1426       return G_IO_STATUS_ERROR;
1427     }
1428 
1429   return G_IO_STATUS_NORMAL;
1430 }
1431 
1432 static GSource *
1433 g_io_win32_console_create_watch (GIOChannel    *channel,
1434                  GIOCondition   condition)
1435 {
1436   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1437   GSource *source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
1438   GIOWin32Watch *watch = (GIOWin32Watch *)source;
1439 
1440   watch-&gt;channel = channel;
1441   g_io_channel_ref (channel);
1442 
1443   watch-&gt;condition = condition;
1444 
1445   watch-&gt;pollfd.fd = _get_osfhandle (win32_channel-&gt;fd);
1446   watch-&gt;pollfd.events = condition;
1447 
1448   g_source_add_poll (source, &amp;watch-&gt;pollfd);
1449 
1450   return source;
1451 }
1452 
1453 static GIOStatus
1454 g_io_win32_sock_read (GIOChannel *channel,
1455               gchar      *buf,
1456               gsize       count,
1457               gsize      *bytes_read,
1458               GError    **err)
1459 {
1460   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1461   gint result;
1462   GIOChannelError error;
1463   int winsock_error;
1464 
1465   if (win32_channel-&gt;debug)
1466     g_print (&quot;g_io_win32_sock_read: channel=%p sock=%d count=%&quot; G_GSIZE_FORMAT,
1467          channel, win32_channel-&gt;fd, count);
1468 
1469   result = recv (win32_channel-&gt;fd, buf, count, 0);
1470   if (result == SOCKET_ERROR)
1471     winsock_error = WSAGetLastError ();
1472 
1473   if (win32_channel-&gt;debug)
1474     g_print (&quot; recv=%d&quot;, result);
1475 
1476   if (result == SOCKET_ERROR)
1477     {
1478       gchar *emsg = g_win32_error_message (winsock_error);
1479 
1480       if (win32_channel-&gt;debug)
1481     g_print (&quot; %s\n&quot;, emsg);
1482 
1483       *bytes_read = 0;
1484 
1485       switch (winsock_error)
1486     {
1487     case WSAEINVAL:
1488           error = G_IO_CHANNEL_ERROR_INVAL;
1489           break;
1490     case WSAEWOULDBLOCK:
1491       g_free (emsg);
1492           return G_IO_STATUS_AGAIN;
1493     default:
1494       error = G_IO_CHANNEL_ERROR_FAILED;
1495           break;
1496     }
1497       g_set_error_literal (err, G_IO_CHANNEL_ERROR, error, emsg);
1498       g_free (emsg);
1499 
1500       return G_IO_STATUS_ERROR;
1501     }
1502   else
1503     {
1504       if (win32_channel-&gt;debug)
1505     g_print (&quot;\n&quot;);
1506       *bytes_read = result;
1507       if (result == 0)
1508     return G_IO_STATUS_EOF;
1509       else
1510     return G_IO_STATUS_NORMAL;
1511     }
1512 }
1513 
1514 static GIOStatus
1515 g_io_win32_sock_write (GIOChannel  *channel,
1516                const gchar *buf,
1517                gsize        count,
1518                gsize       *bytes_written,
1519                GError     **err)
1520 {
1521   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1522   gint result;
1523   GIOChannelError error;
1524   int winsock_error;
1525 
1526   if (win32_channel-&gt;debug)
1527     g_print (&quot;g_io_win32_sock_write: channel=%p sock=%d count=%&quot; G_GSIZE_FORMAT,
1528          channel, win32_channel-&gt;fd, count);
1529 
1530   result = send (win32_channel-&gt;fd, buf, count, 0);
1531   if (result == SOCKET_ERROR)
1532     winsock_error = WSAGetLastError ();
1533 
1534   if (win32_channel-&gt;debug)
1535     g_print (&quot; send=%d&quot;, result);
1536 
1537   if (result == SOCKET_ERROR)
1538     {
1539       gchar *emsg = g_win32_error_message (winsock_error);
1540 
1541       if (win32_channel-&gt;debug)
1542     g_print (&quot; %s\n&quot;, emsg);
1543 
1544       *bytes_written = 0;
1545 
1546       switch (winsock_error)
1547     {
1548     case WSAEINVAL:
1549       error = G_IO_CHANNEL_ERROR_INVAL;
1550           break;
1551     case WSAEWOULDBLOCK:
1552       win32_channel-&gt;write_would_have_blocked = TRUE;
1553       win32_channel-&gt;last_events = 0;
1554       g_free (emsg);
1555           return G_IO_STATUS_AGAIN;
1556     default:
1557       error = G_IO_CHANNEL_ERROR_FAILED;
1558           break;
1559     }
1560       g_set_error_literal (err, G_IO_CHANNEL_ERROR, error, emsg);
1561       g_free (emsg);
1562 
1563       return G_IO_STATUS_ERROR;
1564     }
1565   else
1566     {
1567       if (win32_channel-&gt;debug)
1568     g_print (&quot;\n&quot;);
1569       *bytes_written = result;
1570       win32_channel-&gt;write_would_have_blocked = FALSE;
1571 
1572       return G_IO_STATUS_NORMAL;
1573     }
1574 }
1575 
1576 static GIOStatus
1577 g_io_win32_sock_close (GIOChannel *channel,
1578                GError    **err)
1579 {
1580   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1581 
1582   if (win32_channel-&gt;fd != -1)
1583     {
1584       if (win32_channel-&gt;debug)
1585     g_print (&quot;g_io_win32_sock_close: channel=%p sock=%d\n&quot;,
1586          channel, win32_channel-&gt;fd);
1587 
1588       closesocket (win32_channel-&gt;fd);
1589       win32_channel-&gt;fd = -1;
1590     }
1591 
1592   /* FIXME error detection? */
1593 
1594   return G_IO_STATUS_NORMAL;
1595 }
1596 
1597 static GSource *
1598 g_io_win32_sock_create_watch (GIOChannel    *channel,
1599                   GIOCondition   condition)
1600 {
1601   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1602   GSource *source = g_source_new (&amp;g_io_watch_funcs, sizeof (GIOWin32Watch));
1603   GIOWin32Watch *watch = (GIOWin32Watch *)source;
1604 
1605   watch-&gt;channel = channel;
1606   g_io_channel_ref (channel);
1607 
1608   watch-&gt;condition = condition;
1609 
1610   if (win32_channel-&gt;event == 0)
1611     win32_channel-&gt;event = WSACreateEvent ();
1612 
1613   watch-&gt;pollfd.fd = (gintptr) win32_channel-&gt;event;
1614   watch-&gt;pollfd.events = condition;
1615 
1616   if (win32_channel-&gt;debug)
1617     g_print (&quot;g_io_win32_sock_create_watch: channel=%p sock=%d event=%p condition={%s}\n&quot;,
1618          channel, win32_channel-&gt;fd, (HANDLE) watch-&gt;pollfd.fd,
1619          condition_to_string (watch-&gt;condition));
1620 
1621   g_source_add_poll (source, &amp;watch-&gt;pollfd);
1622 
1623   return source;
1624 }
1625 
1626 GIOChannel *
1627 g_io_channel_new_file (const gchar  *filename,
1628                        const gchar  *mode,
1629                        GError      **error)
1630 {
1631   int fid, flags, pmode;
1632   GIOChannel *channel;
1633 
1634   enum { /* Cheesy hack */
1635     MODE_R = 1 &lt;&lt; 0,
1636     MODE_W = 1 &lt;&lt; 1,
1637     MODE_A = 1 &lt;&lt; 2,
1638     MODE_PLUS = 1 &lt;&lt; 3,
1639   };
1640   int mode_num, errsv;
1641 
1642   g_return_val_if_fail (filename != NULL, NULL);
1643   g_return_val_if_fail (mode != NULL, NULL);
1644   g_return_val_if_fail ((error == NULL) || (*error == NULL), NULL);
1645 
1646   switch (mode[0])
1647     {
1648       case &#39;r&#39;:
1649         mode_num = MODE_R;
1650         break;
1651       case &#39;w&#39;:
1652         mode_num = MODE_W;
1653         break;
1654       case &#39;a&#39;:
1655         mode_num = MODE_A;
1656         break;
1657       default:
1658         g_warning (&quot;Invalid GIOFileMode %s.&quot;, mode);
1659         return NULL;
1660     }
1661 
1662   switch (mode[1])
1663     {
1664       case &#39;\0&#39;:
1665         break;
1666       case &#39;+&#39;:
1667         if (mode[2] == &#39;\0&#39;)
1668           {
1669             mode_num |= MODE_PLUS;
1670             break;
1671           }
1672         /* Fall through */
1673       default:
1674         g_warning (&quot;Invalid GIOFileMode %s.&quot;, mode);
1675         return NULL;
1676     }
1677 
1678   switch (mode_num)
1679     {
1680       case MODE_R:
1681         flags = O_RDONLY;
1682         pmode = _S_IREAD;
1683         break;
1684       case MODE_W:
1685         flags = O_WRONLY | O_TRUNC | O_CREAT;
1686         pmode = _S_IWRITE;
1687         break;
1688       case MODE_A:
1689         flags = O_WRONLY | O_APPEND | O_CREAT;
1690         pmode = _S_IWRITE;
1691         break;
1692       case MODE_R | MODE_PLUS:
1693         flags = O_RDWR;
1694         pmode = _S_IREAD | _S_IWRITE;
1695         break;
1696       case MODE_W | MODE_PLUS:
1697         flags = O_RDWR | O_TRUNC | O_CREAT;
1698         pmode = _S_IREAD | _S_IWRITE;
1699         break;
1700       case MODE_A | MODE_PLUS:
1701         flags = O_RDWR | O_APPEND | O_CREAT;
1702         pmode = _S_IREAD | _S_IWRITE;
1703         break;
1704       default:
1705         g_assert_not_reached ();
1706         g_abort ();
1707     }
1708 
1709   /* always open &#39;untranslated&#39; */
1710   fid = g_open (filename, flags | _O_BINARY, pmode);
1711   errsv = errno;
1712 
1713   if (g_io_win32_get_debug_flag ())
1714     {
1715       g_print (&quot;g_io_channel_win32_new_file: open(\&quot;%s\&quot;,&quot;, filename);
1716       g_win32_print_access_mode (flags|_O_BINARY);
1717       g_print (&quot;,%#o)=%d\n&quot;, pmode, fid);
1718     }
1719 
1720   if (fid &lt; 0)
1721     {
1722       g_set_error_literal (error, G_FILE_ERROR,
1723                            g_file_error_from_errno (errsv),
1724                            g_strerror (errsv));
1725       return (GIOChannel *)NULL;
1726     }
1727 
1728   channel = g_io_channel_win32_new_fd (fid);
1729 #ifdef GSTREAMER_LITE
1730   if (channel == NULL) {
1731     return NULL;
1732   }
1733 #endif // GSTREAMER_LITE
1734 
1735   /* XXX: move this to g_io_channel_win32_new_fd () */
1736   channel-&gt;close_on_unref = TRUE;
1737   channel-&gt;is_seekable = TRUE;
1738 
1739   /* g_io_channel_win32_new_fd sets is_readable and is_writeable to
1740    * correspond to actual readability/writeability. Set to FALSE those
1741    * that mode doesn&#39;t allow
1742    */
1743   switch (mode_num)
1744     {
1745       case MODE_R:
1746         channel-&gt;is_writeable = FALSE;
1747         break;
1748       case MODE_W:
1749       case MODE_A:
1750         channel-&gt;is_readable = FALSE;
1751         break;
1752       case MODE_R | MODE_PLUS:
1753       case MODE_W | MODE_PLUS:
1754       case MODE_A | MODE_PLUS:
1755         break;
1756       default:
1757         g_assert_not_reached ();
1758         g_abort ();
1759     }
1760 
1761   return channel;
1762 }
1763 
1764 static GIOStatus
1765 g_io_win32_unimpl_set_flags (GIOChannel *channel,
1766                  GIOFlags    flags,
1767                  GError    **err)
1768 {
1769   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1770 
1771   if (win32_channel-&gt;debug)
1772     {
1773       g_print (&quot;g_io_win32_unimpl_set_flags: &quot;);
1774       g_win32_print_gioflags (flags);
1775       g_print (&quot;\n&quot;);
1776     }
1777 
1778   g_set_error_literal (err, G_IO_CHANNEL_ERROR,
1779                        G_IO_CHANNEL_ERROR_FAILED,
1780                        &quot;Not implemented on Win32&quot;);
1781 
1782   return G_IO_STATUS_ERROR;
1783 }
1784 
1785 static GIOFlags
1786 g_io_win32_fd_get_flags_internal (GIOChannel      *channel,
1787                   struct _stati64 *st)
1788 {
1789   GIOWin32Channel *win32_channel = (GIOWin32Channel *) channel;
1790   gchar c;
1791   DWORD count;
1792 
1793   if (st-&gt;st_mode &amp; _S_IFIFO)
1794     {
1795       channel-&gt;is_readable =
1796     (PeekNamedPipe ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL, NULL) != 0) || GetLastError () == ERROR_BROKEN_PIPE;
1797       channel-&gt;is_writeable =
1798     (WriteFile ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL) != 0);
1799       channel-&gt;is_seekable  = FALSE;
1800     }
1801   else
1802     {
1803       channel-&gt;is_readable =
1804     (ReadFile ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL) != 0);
1805       channel-&gt;is_writeable =
1806     (WriteFile ((HANDLE) _get_osfhandle (win32_channel-&gt;fd), &amp;c, 0, &amp;count, NULL) != 0);
1807       channel-&gt;is_seekable = TRUE;
1808     }
1809 
1810   /* XXX: G_IO_FLAG_APPEND */
1811   /* XXX: G_IO_FLAG_NONBLOCK */
1812 
1813   return 0;
1814 }
1815 
1816 static GIOFlags
1817 g_io_win32_fd_get_flags (GIOChannel *channel)
1818 {
1819   struct _stati64 st;
1820   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1821 
1822   g_return_val_if_fail (win32_channel != NULL, 0);
1823   g_return_val_if_fail (win32_channel-&gt;type == G_IO_WIN32_FILE_DESC, 0);
1824 
1825   if (0 == _fstati64 (win32_channel-&gt;fd, &amp;st))
1826     return g_io_win32_fd_get_flags_internal (channel, &amp;st);
1827   else
1828     return 0;
1829 }
1830 
1831 static GIOFlags
1832 g_io_win32_console_get_flags_internal (GIOChannel  *channel)
1833 {
1834   GIOWin32Channel *win32_channel = (GIOWin32Channel *) channel;
1835   HANDLE handle = (HANDLE) _get_osfhandle (win32_channel-&gt;fd);
1836   gchar c;
1837   DWORD count;
1838   INPUT_RECORD record;
1839 
1840   channel-&gt;is_readable = PeekConsoleInput (handle, &amp;record, 1, &amp;count);
1841   channel-&gt;is_writeable = WriteFile (handle, &amp;c, 0, &amp;count, NULL);
1842   channel-&gt;is_seekable = FALSE;
1843 
1844   return 0;
1845 }
1846 
1847 static GIOFlags
1848 g_io_win32_console_get_flags (GIOChannel *channel)
1849 {
1850   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1851 
1852   g_return_val_if_fail (win32_channel != NULL, 0);
1853   g_return_val_if_fail (win32_channel-&gt;type == G_IO_WIN32_CONSOLE, 0);
1854 
1855   return g_io_win32_console_get_flags_internal (channel);
1856 }
1857 
1858 static GIOFlags
1859 g_io_win32_msg_get_flags (GIOChannel *channel)
1860 {
1861   return 0;
1862 }
1863 
1864 static GIOStatus
1865 g_io_win32_sock_set_flags (GIOChannel *channel,
1866                GIOFlags    flags,
1867                GError    **err)
1868 {
1869   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
1870   u_long arg;
1871 
1872   if (win32_channel-&gt;debug)
1873     {
1874       g_print (&quot;g_io_win32_sock_set_flags: &quot;);
1875       g_win32_print_gioflags (flags);
1876       g_print (&quot;\n&quot;);
1877     }
1878 
1879   if (flags &amp; G_IO_FLAG_NONBLOCK)
1880     {
1881       arg = 1;
1882       if (ioctlsocket (win32_channel-&gt;fd, FIONBIO, &amp;arg) == SOCKET_ERROR)
1883     {
1884       gchar *emsg = g_win32_error_message (WSAGetLastError ());
1885 
1886       g_set_error_literal (err, G_IO_CHANNEL_ERROR,
1887                    G_IO_CHANNEL_ERROR_FAILED,
1888                    emsg);
1889       g_free (emsg);
1890 
1891       return G_IO_STATUS_ERROR;
1892     }
1893     }
1894   else
1895     {
1896       arg = 0;
1897       if (ioctlsocket (win32_channel-&gt;fd, FIONBIO, &amp;arg) == SOCKET_ERROR)
1898     {
1899       gchar *emsg = g_win32_error_message (WSAGetLastError ());
1900 
1901       g_set_error_literal (err, G_IO_CHANNEL_ERROR,
1902                    G_IO_CHANNEL_ERROR_FAILED,
1903                    emsg);
1904       g_free (emsg);
1905 
1906       return G_IO_STATUS_ERROR;
1907     }
1908     }
1909 
1910   return G_IO_STATUS_NORMAL;
1911 }
1912 
1913 static GIOFlags
1914 g_io_win32_sock_get_flags (GIOChannel *channel)
1915 {
1916   /* Could we do something here? */
1917   return 0;
1918 }
1919 
1920 static GIOFuncs win32_channel_msg_funcs = {
1921   g_io_win32_msg_read,
1922   g_io_win32_msg_write,
1923   NULL,
1924   g_io_win32_msg_close,
1925   g_io_win32_msg_create_watch,
1926   g_io_win32_free,
1927   g_io_win32_unimpl_set_flags,
1928   g_io_win32_msg_get_flags,
1929 };
1930 
1931 static GIOFuncs win32_channel_fd_funcs = {
1932   g_io_win32_fd_and_console_read,
1933   g_io_win32_fd_and_console_write,
1934   g_io_win32_fd_seek,
1935   g_io_win32_fd_close,
1936   g_io_win32_fd_create_watch,
1937   g_io_win32_free,
1938   g_io_win32_unimpl_set_flags,
1939   g_io_win32_fd_get_flags,
1940 };
1941 
1942 static GIOFuncs win32_channel_console_funcs = {
1943   g_io_win32_fd_and_console_read,
1944   g_io_win32_fd_and_console_write,
1945   NULL,
1946   g_io_win32_console_close,
1947   g_io_win32_console_create_watch,
1948   g_io_win32_free,
1949   g_io_win32_unimpl_set_flags,
1950   g_io_win32_console_get_flags,
1951 };
1952 
1953 static GIOFuncs win32_channel_sock_funcs = {
1954   g_io_win32_sock_read,
1955   g_io_win32_sock_write,
1956   NULL,
1957   g_io_win32_sock_close,
1958   g_io_win32_sock_create_watch,
1959   g_io_win32_free,
1960   g_io_win32_sock_set_flags,
1961   g_io_win32_sock_get_flags,
1962 };
1963 
1964 /**
1965  * g_io_channel_win32_new_messages:
1966  * @hwnd: a window handle.
1967  *
1968  * Creates a new #GIOChannel given a window handle on Windows.
1969  *
1970  * This function creates a #GIOChannel that can be used to poll for
1971  * Windows messages for the window in question.
1972  *
1973  * Returns: a new #GIOChannel.
1974  **/
1975 GIOChannel *
1976 #if GLIB_SIZEOF_VOID_P == 8
1977 g_io_channel_win32_new_messages (gsize hwnd)
1978 #else
1979 g_io_channel_win32_new_messages (guint hwnd)
1980 #endif
1981 {
1982   GIOWin32Channel *win32_channel = g_new (GIOWin32Channel, 1);
1983   GIOChannel *channel = (GIOChannel *)win32_channel;
1984 
1985   g_io_channel_init (channel);
1986   g_io_channel_win32_init (win32_channel);
1987   if (win32_channel-&gt;debug)
1988     g_print (&quot;g_io_channel_win32_new_messages: channel=%p hwnd=%p\n&quot;,
1989          channel, (HWND) hwnd);
1990   channel-&gt;funcs = &amp;win32_channel_msg_funcs;
1991   win32_channel-&gt;type = G_IO_WIN32_WINDOWS_MESSAGES;
1992   win32_channel-&gt;hwnd = (HWND) hwnd;
1993 
1994   /* XXX: check this. */
1995   channel-&gt;is_readable = IsWindow (win32_channel-&gt;hwnd);
1996   channel-&gt;is_writeable = IsWindow (win32_channel-&gt;hwnd);
1997 
1998   channel-&gt;is_seekable = FALSE;
1999 
2000   return channel;
2001 }
2002 
2003 static GIOChannel *
2004 g_io_channel_win32_new_fd_internal (gint             fd,
2005                     struct _stati64 *st)
2006 {
2007   GIOWin32Channel *win32_channel;
2008   GIOChannel *channel;
2009 
2010   win32_channel = g_new (GIOWin32Channel, 1);
2011   channel = (GIOChannel *)win32_channel;
2012 
2013   g_io_channel_init (channel);
2014   g_io_channel_win32_init (win32_channel);
2015 
2016   win32_channel-&gt;fd = fd;
2017 
2018   if (win32_channel-&gt;debug)
2019     g_print (&quot;g_io_channel_win32_new_fd: channel=%p fd=%u\n&quot;,
2020          channel, fd);
2021 
2022   if (st-&gt;st_mode &amp; _S_IFCHR) /* console */
2023     {
2024       channel-&gt;funcs = &amp;win32_channel_console_funcs;
2025       win32_channel-&gt;type = G_IO_WIN32_CONSOLE;
2026       g_io_win32_console_get_flags_internal (channel);
2027     }
2028   else
2029     {
2030       channel-&gt;funcs = &amp;win32_channel_fd_funcs;
2031       win32_channel-&gt;type = G_IO_WIN32_FILE_DESC;
2032       g_io_win32_fd_get_flags_internal (channel, st);
2033     }
2034 
2035   return channel;
2036 }
2037 
2038 /**
2039  * g_io_channel_win32_new_fd:
2040  * @fd: a C library file descriptor.
2041  *
2042  * Creates a new #GIOChannel given a file descriptor on Windows. This
2043  * works for file descriptors from the C runtime.
2044  *
2045  * This function works for file descriptors as returned by the open(),
2046  * creat(), pipe() and fileno() calls in the Microsoft C runtime. In
2047  * order to meaningfully use this function your code should use the
2048  * same C runtime as GLib uses, which is msvcrt.dll. Note that in
2049  * current Microsoft compilers it is near impossible to convince it to
2050  * build code that would use msvcrt.dll. The last Microsoft compiler
2051  * version that supported using msvcrt.dll as the C runtime was version 6.
2052  * The GNU compiler and toolchain for Windows, also known as Mingw,
2053  * fully supports msvcrt.dll.
2054  *
2055  * If you have created a #GIOChannel for a file descriptor and started
2056  * watching (polling) it, you shouldn&#39;t call read() on the file
2057  * descriptor. This is because adding polling for a file descriptor is
2058  * implemented in GLib on Windows by starting a thread that sits
2059  * blocked in a read() from the file descriptor most of the time. All
2060  * reads from the file descriptor should be done by this internal GLib
2061  * thread. Your code should call only g_io_channel_read().
2062  *
2063  * This function is available only in GLib on Windows.
2064  *
2065  * Returns: a new #GIOChannel.
2066  **/
2067 GIOChannel *
2068 g_io_channel_win32_new_fd (gint fd)
2069 {
2070   struct _stati64 st;
2071 
2072   if (_fstati64 (fd, &amp;st) == -1)
2073     {
2074       g_warning (&quot;g_io_channel_win32_new_fd: %d isn&#39;t an open file descriptor in the C library GLib uses.&quot;, fd);
2075       return NULL;
2076     }
2077 
2078   return g_io_channel_win32_new_fd_internal (fd, &amp;st);
2079 }
2080 
2081 gint
2082 g_io_channel_win32_get_fd (GIOChannel *channel)
2083 {
2084   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
2085 
2086   return win32_channel-&gt;fd;
2087 }
2088 
2089 /**
2090  * g_io_channel_win32_new_socket:
2091  * @socket: a Winsock socket
2092  *
2093  * Creates a new #GIOChannel given a socket on Windows.
2094  *
2095  * This function works for sockets created by Winsock. It&#39;s available
2096  * only in GLib on Windows.
2097  *
2098  * Polling a #GSource created to watch a channel for a socket puts the
2099  * socket in non-blocking mode. This is a side-effect of the
2100  * implementation and unavoidable.
2101  *
2102  * Returns: a new #GIOChannel
2103  **/
2104 GIOChannel *
2105 g_io_channel_win32_new_socket (int socket)
2106 {
2107   GIOWin32Channel *win32_channel = g_new (GIOWin32Channel, 1);
2108   GIOChannel *channel = (GIOChannel *)win32_channel;
2109 
2110   g_io_channel_init (channel);
2111   g_io_channel_win32_init (win32_channel);
2112   if (win32_channel-&gt;debug)
2113     g_print (&quot;g_io_channel_win32_new_socket: channel=%p sock=%d\n&quot;,
2114          channel, socket);
2115   channel-&gt;funcs = &amp;win32_channel_sock_funcs;
2116   win32_channel-&gt;type = G_IO_WIN32_SOCKET;
2117   win32_channel-&gt;fd = socket;
2118 
2119   channel-&gt;is_readable = TRUE;
2120   channel-&gt;is_writeable = TRUE;
2121   channel-&gt;is_seekable = FALSE;
2122 
2123   return channel;
2124 }
2125 
2126 GIOChannel *
2127 g_io_channel_unix_new (gint fd)
2128 {
2129   gboolean is_fd, is_socket;
2130   struct _stati64 st;
2131   int optval, optlen;
2132 
2133   is_fd = (_fstati64 (fd, &amp;st) == 0);
2134 
2135   optlen = sizeof (optval);
2136   is_socket = (getsockopt (fd, SOL_SOCKET, SO_TYPE, (char *) &amp;optval, &amp;optlen) != SOCKET_ERROR);
2137 
2138   if (is_fd &amp;&amp; is_socket)
2139     g_warning (&quot;g_io_channel_unix_new: %d is both a file descriptor and a socket. File descriptor interpretation assumed. To avoid ambiguity, call either g_io_channel_win32_new_fd() or g_io_channel_win32_new_socket() instead.&quot;, fd);
2140 
2141   if (is_fd)
2142     return g_io_channel_win32_new_fd_internal (fd, &amp;st);
2143 
2144   if (is_socket)
2145     return g_io_channel_win32_new_socket(fd);
2146 
2147   g_warning (&quot;g_io_channel_unix_new: %d is neither a file descriptor or a socket.&quot;, fd);
2148 
2149   return NULL;
2150 }
2151 
2152 gint
2153 g_io_channel_unix_get_fd (GIOChannel *channel)
2154 {
2155   return g_io_channel_win32_get_fd (channel);
2156 }
2157 
2158 void
2159 g_io_channel_win32_set_debug (GIOChannel *channel,
2160                   gboolean    flag)
2161 {
2162   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
2163 
2164   win32_channel-&gt;debug = flag;
2165 }
2166 
2167 gint
2168 g_io_channel_win32_poll (GPollFD *fds,
2169              gint     n_fds,
2170              gint     timeout)
2171 {
2172   g_return_val_if_fail (n_fds &gt;= 0, 0);
2173 
2174   return g_poll (fds, n_fds, timeout);
2175 }
2176 
2177 void
2178 g_io_channel_win32_make_pollfd (GIOChannel   *channel,
2179                 GIOCondition  condition,
2180                 GPollFD      *fd)
2181 {
2182   GIOWin32Channel *win32_channel = (GIOWin32Channel *)channel;
2183 
2184   switch (win32_channel-&gt;type)
2185     {
2186     case G_IO_WIN32_FILE_DESC:
2187       if (win32_channel-&gt;data_avail_event == NULL)
2188     create_events (win32_channel);
2189 
2190       fd-&gt;fd = (gintptr) win32_channel-&gt;data_avail_event;
2191 
2192       if (win32_channel-&gt;thread_id == 0)
2193     {
2194       /* Is it meaningful for a file descriptor to be polled for
2195        * both IN and OUT? For what kind of file descriptor would
2196        * that be? Doesn&#39;t seem to make sense, in practise the file
2197        * descriptors handled here are always read or write ends of
2198        * pipes surely, and thus unidirectional.
2199        */
2200       if (condition &amp; G_IO_IN)
2201         create_thread (win32_channel, condition, read_thread);
2202       else if (condition &amp; G_IO_OUT)
2203         create_thread (win32_channel, condition, write_thread);
2204     }
2205       break;
2206 
2207     case G_IO_WIN32_CONSOLE:
2208       fd-&gt;fd = _get_osfhandle (win32_channel-&gt;fd);
2209       break;
2210 
2211     case G_IO_WIN32_SOCKET:
2212       fd-&gt;fd = (gintptr) WSACreateEvent ();
2213       break;
2214 
2215     case G_IO_WIN32_WINDOWS_MESSAGES:
2216       fd-&gt;fd = G_WIN32_MSG_HANDLE;
2217       break;
2218 
2219     default:
2220       g_assert_not_reached ();
2221       g_abort ();
2222     }
2223 
2224   fd-&gt;events = condition;
2225 }
2226 
2227 #ifndef _WIN64
2228 
2229 /* Binary compatibility */
2230 GIOChannel *
2231 g_io_channel_win32_new_stream_socket (int socket)
2232 {
2233   return g_io_channel_win32_new_socket (socket);
2234 }
2235 
2236 #endif
2237 
2238 #ifdef G_OS_WIN32
2239 
2240 /* Binary compatibility versions. Not for newly compiled code. */
2241 
2242 _GLIB_EXTERN GIOChannel *g_io_channel_new_file_utf8 (const gchar  *filename,
2243                                                      const gchar  *mode,
2244                                                      GError      **error);
2245 
2246 GIOChannel *
2247 g_io_channel_new_file_utf8 (const gchar  *filename,
2248                             const gchar  *mode,
2249                             GError      **error)
2250 {
2251   return g_io_channel_new_file (filename, mode, error);
2252 }
2253 
2254 #endif
    </pre>
  </body>
</html>