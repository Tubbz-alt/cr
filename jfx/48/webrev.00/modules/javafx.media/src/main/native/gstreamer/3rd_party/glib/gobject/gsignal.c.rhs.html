<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gsignal.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GObject - GLib Type, Object, Parameter and Signal Library
   2  * Copyright (C) 2000-2001 Red Hat, Inc.
   3  *
   4  * This library is free software; you can redistribute it and/or
   5  * modify it under the terms of the GNU Lesser General Public
   6  * License as published by the Free Software Foundation; either
   7  * version 2.1 of the License, or (at your option) any later version.
   8  *
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Lesser General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Lesser General
  15  * Public License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  16  *
  17  * this code is based on the original GtkSignal implementation
  18  * for the Gtk+ library by Peter Mattis &lt;petm@xcf.berkeley.edu&gt;
  19  */
  20 
  21 /*
  22  * MT safe
  23  */
  24 
  25 #include &quot;config.h&quot;
  26 
  27 #include &lt;string.h&gt;
  28 #include &lt;signal.h&gt;
  29 
  30 #include &quot;gsignal.h&quot;
  31 #include &quot;gtype-private.h&quot;
  32 #include &quot;gbsearcharray.h&quot;
  33 #include &quot;gvaluecollector.h&quot;
  34 #include &quot;gvaluetypes.h&quot;
  35 #include &quot;gobject.h&quot;
  36 #include &quot;genums.h&quot;
  37 #include &quot;gobject_trace.h&quot;
  38 
  39 
  40 /**
  41  * SECTION:signals
  42  * @short_description: A means for customization of object behaviour
  43  *     and a general purpose notification mechanism
  44  * @title: Signals
  45  *
  46  * The basic concept of the signal system is that of the emission
  47  * of a signal. Signals are introduced per-type and are identified
  48  * through strings. Signals introduced for a parent type are available
  49  * in derived types as well, so basically they are a per-type facility
  50  * that is inherited.
  51  *
  52  * A signal emission mainly involves invocation of a certain set of
  53  * callbacks in precisely defined manner. There are two main categories
  54  * of such callbacks, per-object ones and user provided ones.
  55  * (Although signals can deal with any kind of instantiatable type, I&#39;m
  56  * referring to those types as &quot;object types&quot; in the following, simply
  57  * because that is the context most users will encounter signals in.)
  58  * The per-object callbacks are most often referred to as &quot;object method
  59  * handler&quot; or &quot;default (signal) handler&quot;, while user provided callbacks are
  60  * usually just called &quot;signal handler&quot;.
  61  *
  62  * The object method handler is provided at signal creation time (this most
  63  * frequently happens at the end of an object class&#39; creation), while user
  64  * provided handlers are frequently connected and disconnected to/from a
  65  * certain signal on certain object instances.
  66  *
  67  * A signal emission consists of five stages, unless prematurely stopped:
  68  *
  69  * 1. Invocation of the object method handler for %G_SIGNAL_RUN_FIRST signals
  70  *
  71  * 2. Invocation of normal user-provided signal handlers (where the @after
  72  *    flag is not set)
  73  *
  74  * 3. Invocation of the object method handler for %G_SIGNAL_RUN_LAST signals
  75  *
  76  * 4. Invocation of user provided signal handlers (where the @after flag is set)
  77  *
  78  * 5. Invocation of the object method handler for %G_SIGNAL_RUN_CLEANUP signals
  79  *
  80  * The user-provided signal handlers are called in the order they were
  81  * connected in.
  82  *
  83  * All handlers may prematurely stop a signal emission, and any number of
  84  * handlers may be connected, disconnected, blocked or unblocked during
  85  * a signal emission.
  86  *
  87  * There are certain criteria for skipping user handlers in stages 2 and 4
  88  * of a signal emission.
  89  *
  90  * First, user handlers may be blocked. Blocked handlers are omitted during
  91  * callback invocation, to return from the blocked state, a handler has to
  92  * get unblocked exactly the same amount of times it has been blocked before.
  93  *
  94  * Second, upon emission of a %G_SIGNAL_DETAILED signal, an additional
  95  * @detail argument passed in to g_signal_emit() has to match the detail
  96  * argument of the signal handler currently subject to invocation.
  97  * Specification of no detail argument for signal handlers (omission of the
  98  * detail part of the signal specification upon connection) serves as a
  99  * wildcard and matches any detail argument passed in to emission.
 100  *
 101  * ## Memory management of signal handlers # {#signal-memory-management}
 102  *
 103  * If you are connecting handlers to signals and using a #GObject instance as
 104  * your signal handler user data, you should remember to pair calls to
 105  * g_signal_connect() with calls to g_signal_handler_disconnect() or
 106  * g_signal_handlers_disconnect_by_func(). While signal handlers are
 107  * automatically disconnected when the object emitting the signal is finalised,
 108  * they are not automatically disconnected when the signal handler user data is
 109  * destroyed. If this user data is a #GObject instance, using it from a
 110  * signal handler after it has been finalised is an error.
 111  *
 112  * There are two strategies for managing such user data. The first is to
 113  * disconnect the signal handler (using g_signal_handler_disconnect() or
 114  * g_signal_handlers_disconnect_by_func()) when the user data (object) is
 115  * finalised; this has to be implemented manually. For non-threaded programs,
 116  * g_signal_connect_object() can be used to implement this automatically.
 117  * Currently, however, it is unsafe to use in threaded programs.
 118  *
 119  * The second is to hold a strong reference on the user data until after the
 120  * signal is disconnected for other reasons. This can be implemented
 121  * automatically using g_signal_connect_data().
 122  *
 123  * The first approach is recommended, as the second approach can result in
 124  * effective memory leaks of the user data if the signal handler is never
 125  * disconnected for some reason.
 126  */
 127 
 128 
<a name="1" id="anc1"></a><span class="line-modified"> 129 #define REPORT_BUG      &quot;please report occurrence circumstances to https://gitlab.gnome.org/GNOME/glib/issues/new&quot;</span>
 130 
 131 /* --- typedefs --- */
 132 typedef struct _SignalNode   SignalNode;
 133 typedef struct _SignalKey    SignalKey;
 134 typedef struct _Emission     Emission;
 135 typedef struct _Handler      Handler;
 136 typedef struct _HandlerList  HandlerList;
 137 typedef struct _HandlerMatch HandlerMatch;
 138 typedef enum
 139 {
 140   EMISSION_STOP,
 141   EMISSION_RUN,
 142   EMISSION_HOOK,
 143   EMISSION_RESTART
 144 } EmissionState;
 145 
 146 
 147 /* --- prototypes --- */
<a name="2" id="anc2"></a><span class="line-modified"> 148 static inline guint   signal_id_lookup  (GQuark     quark,</span>
<span class="line-modified"> 149                GType      itype);</span>
<span class="line-modified"> 150 static        void    signal_destroy_R  (SignalNode  *signal_node);</span>
<span class="line-modified"> 151 static inline HandlerList*  handler_list_ensure (guint      signal_id,</span>
<span class="line-modified"> 152                gpointer   instance);</span>
<span class="line-modified"> 153 static inline HandlerList*  handler_list_lookup (guint      signal_id,</span>
<span class="line-modified"> 154                gpointer   instance);</span>
<span class="line-modified"> 155 static inline Handler*    handler_new   (guint            signal_id,</span>
<span class="line-modified"> 156                gpointer         instance,</span>
<span class="line-modified"> 157                                                          gboolean   after);</span>
<span class="line-modified"> 158 static        void    handler_insert    (guint      signal_id,</span>
<span class="line-modified"> 159                gpointer   instance,</span>
<span class="line-modified"> 160                Handler   *handler);</span>
<span class="line-modified"> 161 static        Handler*    handler_lookup    (gpointer   instance,</span>
<span class="line-modified"> 162                gulong     handler_id,</span>
<span class="line-modified"> 163                GClosure        *closure,</span>
<span class="line-modified"> 164                guint     *signal_id_p);</span>
<span class="line-modified"> 165 static inline HandlerMatch* handler_match_prepend (HandlerMatch  *list,</span>
<span class="line-modified"> 166                Handler   *handler,</span>
<span class="line-modified"> 167                guint      signal_id);</span>
<span class="line-modified"> 168 static inline HandlerMatch* handler_match_free1_R (HandlerMatch  *node,</span>
<span class="line-modified"> 169                gpointer   instance);</span>
<span class="line-modified"> 170 static        HandlerMatch* handlers_find   (gpointer   instance,</span>
<span class="line-modified"> 171                GSignalMatchType mask,</span>
<span class="line-modified"> 172                guint      signal_id,</span>
<span class="line-modified"> 173                GQuark     detail,</span>
<span class="line-modified"> 174                GClosure  *closure,</span>
<span class="line-modified"> 175                gpointer   func,</span>
<span class="line-modified"> 176                gpointer   data,</span>
<span class="line-modified"> 177                gboolean   one_and_only);</span>
<span class="line-modified"> 178 static inline void    handler_ref   (Handler   *handler);</span>
<span class="line-modified"> 179 static inline void    handler_unref_R   (guint      signal_id,</span>
<span class="line-modified"> 180                gpointer   instance,</span>
<span class="line-modified"> 181                Handler   *handler);</span>
<span class="line-modified"> 182 static gint     handler_lists_cmp (gconstpointer    node1,</span>
<span class="line-modified"> 183                gconstpointer    node2);</span>
<span class="line-modified"> 184 static inline void    emission_push   (Emission  *emission);</span>
<span class="line-modified"> 185 static inline void    emission_pop    (Emission  *emission);</span>
<span class="line-modified"> 186 static inline Emission*   emission_find   (guint      signal_id,</span>
<span class="line-modified"> 187                GQuark     detail,</span>
<span class="line-modified"> 188                gpointer   instance);</span>
<span class="line-modified"> 189 static gint     class_closures_cmp  (gconstpointer    node1,</span>
<span class="line-modified"> 190                gconstpointer    node2);</span>
<span class="line-modified"> 191 static gint     signal_key_cmp    (gconstpointer    node1,</span>
<span class="line-modified"> 192                gconstpointer    node2);</span>
<span class="line-modified"> 193 static        gboolean    signal_emit_unlocked_R  (SignalNode  *node,</span>
<span class="line-modified"> 194                GQuark     detail,</span>
<span class="line-modified"> 195                gpointer   instance,</span>
<span class="line-modified"> 196                GValue    *return_value,</span>
<span class="line-modified"> 197                const GValue  *instance_and_params);</span>
 198 static       void               add_invalid_closure_notify    (Handler         *handler,
<a name="3" id="anc3"></a><span class="line-modified"> 199                      gpointer         instance);</span>
 200 static       void               remove_invalid_closure_notify (Handler         *handler,
<a name="4" id="anc4"></a><span class="line-modified"> 201                      gpointer         instance);</span>
 202 static       void               invalid_closure_notify  (gpointer         data,
<a name="5" id="anc5"></a><span class="line-modified"> 203                GClosure        *closure);</span>
 204 static const gchar *            type_debug_name         (GType            type);
 205 static void                     node_check_deprecated   (const SignalNode *node);
 206 static void                     node_update_single_va_closure (SignalNode *node);
 207 
 208 
 209 /* --- structures --- */
 210 typedef struct
 211 {
 212   GSignalAccumulator func;
 213   gpointer           data;
 214 } SignalAccumulator;
 215 typedef struct
 216 {
 217   GHook hook;
 218   GQuark detail;
 219 } SignalHook;
<a name="6" id="anc6"></a><span class="line-modified"> 220 #define SIGNAL_HOOK(hook) ((SignalHook*) (hook))</span>
 221 
 222 struct _SignalNode
 223 {
 224   /* permanent portion */
 225   guint              signal_id;
 226   GType              itype;
 227   const gchar       *name;
 228   guint              destroyed : 1;
 229 
 230   /* reinitializable portion */
 231   guint              flags : 9;
 232   guint              n_params : 8;
 233   guint              single_va_closure_is_valid : 1;
 234   guint              single_va_closure_is_after : 1;
<a name="7" id="anc7"></a><span class="line-modified"> 235   GType       *param_types; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */</span>
<span class="line-modified"> 236   GType        return_type; /* mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag */</span>
 237   GBSearchArray     *class_closure_bsa;
 238   SignalAccumulator *accumulator;
 239   GSignalCMarshaller c_marshaller;
 240   GSignalCVaMarshaller va_marshaller;
 241   GHookList         *emission_hooks;
 242 
 243   GClosure *single_va_closure;
 244 };
 245 
<a name="8" id="anc8"></a><span class="line-modified"> 246 #define SINGLE_VA_CLOSURE_EMPTY_MAGIC GINT_TO_POINTER(1)  /* indicates single_va_closure is valid but empty */</span>
 247 
 248 struct _SignalKey
 249 {
 250   GType  itype;
 251   GQuark quark;
 252   guint  signal_id;
 253 };
 254 
 255 struct _Emission
 256 {
 257   Emission             *next;
 258   gpointer              instance;
 259   GSignalInvocationHint ihint;
 260   EmissionState         state;
<a name="9" id="anc9"></a><span class="line-modified"> 261   GType     chain_type;</span>
 262 };
 263 
 264 struct _HandlerList
 265 {
 266   guint    signal_id;
 267   Handler *handlers;
 268   Handler *tail_before;  /* normal signal handlers are appended here  */
 269   Handler *tail_after;   /* CONNECT_AFTER handlers are appended here  */
 270 };
 271 
 272 struct _Handler
 273 {
 274   gulong        sequential_number;
 275   Handler      *next;
 276   Handler      *prev;
<a name="10" id="anc10"></a><span class="line-modified"> 277   GQuark  detail;</span>
 278   guint         signal_id;
 279   guint         ref_count;
 280   guint         block_count : 16;
 281 #define HANDLER_MAX_BLOCK_COUNT (1 &lt;&lt; 16)
 282   guint         after : 1;
 283   guint         has_invalid_closure_notify : 1;
 284   GClosure     *closure;
 285   gpointer      instance;
 286 };
 287 struct _HandlerMatch
 288 {
 289   Handler      *handler;
 290   HandlerMatch *next;
 291   guint         signal_id;
 292 };
 293 
 294 typedef struct
 295 {
 296   GType     instance_type; /* 0 for default closure */
 297   GClosure *closure;
 298 } ClassClosure;
 299 
 300 
 301 /* --- variables --- */
 302 static GBSearchArray *g_signal_key_bsa = NULL;
 303 static const GBSearchConfig g_signal_key_bconfig = {
 304   sizeof (SignalKey),
 305   signal_key_cmp,
 306   G_BSEARCH_ARRAY_ALIGN_POWER2,
 307 };
 308 static GBSearchConfig g_signal_hlbsa_bconfig = {
 309   sizeof (HandlerList),
 310   handler_lists_cmp,
 311   0,
 312 };
 313 static GBSearchConfig g_class_closure_bconfig = {
 314   sizeof (ClassClosure),
 315   class_closures_cmp,
 316   0,
 317 };
 318 static GHashTable    *g_handler_list_bsa_ht = NULL;
 319 static Emission      *g_emissions = NULL;
 320 static gulong         g_handler_sequential_number = 1;
 321 static GHashTable    *g_handlers = NULL;
 322 
 323 G_LOCK_DEFINE_STATIC (g_signal_mutex);
<a name="11" id="anc11"></a><span class="line-modified"> 324 #define SIGNAL_LOCK()   G_LOCK (g_signal_mutex)</span>
<span class="line-modified"> 325 #define SIGNAL_UNLOCK()   G_UNLOCK (g_signal_mutex)</span>
 326 
 327 
 328 /* --- signal nodes --- */
 329 static guint          g_n_signal_nodes = 0;
 330 static SignalNode   **g_signal_nodes = NULL;
 331 
 332 static inline SignalNode*
 333 LOOKUP_SIGNAL_NODE (guint signal_id)
 334 {
 335   if (signal_id &lt; g_n_signal_nodes)
 336     return g_signal_nodes[signal_id];
 337   else
 338     return NULL;
 339 }
 340 
 341 
 342 /* --- functions --- */
 343 static inline guint
 344 signal_id_lookup (GQuark quark,
<a name="12" id="anc12"></a><span class="line-modified"> 345       GType  itype)</span>
 346 {
 347   GType *ifaces, type = itype;
 348   SignalKey key;
 349   guint n_ifaces;
 350 
 351   key.quark = quark;
 352 
 353   /* try looking up signals for this type and its ancestors */
 354   do
 355     {
 356       SignalKey *signal_key;
 357 
 358       key.itype = type;
 359       signal_key = g_bsearch_array_lookup (g_signal_key_bsa, &amp;g_signal_key_bconfig, &amp;key);
 360 
 361       if (signal_key)
<a name="13" id="anc13"></a><span class="line-modified"> 362   return signal_key-&gt;signal_id;</span>
 363 
 364       type = g_type_parent (type);
 365     }
 366   while (type);
 367 
 368   /* no luck, try interfaces it exports */
 369   ifaces = g_type_interfaces (itype, &amp;n_ifaces);
 370   while (n_ifaces--)
 371     {
 372       SignalKey *signal_key;
 373 
 374       key.itype = ifaces[n_ifaces];
 375       signal_key = g_bsearch_array_lookup (g_signal_key_bsa, &amp;g_signal_key_bconfig, &amp;key);
 376 
 377       if (signal_key)
<a name="14" id="anc14"></a><span class="line-modified"> 378   {</span>
<span class="line-modified"> 379     g_free (ifaces);</span>
<span class="line-modified"> 380     return signal_key-&gt;signal_id;</span>
<span class="line-modified"> 381   }</span>
 382     }
 383   g_free (ifaces);
 384 
 385   return 0;
 386 }
 387 
 388 static gint
 389 class_closures_cmp (gconstpointer node1,
<a name="15" id="anc15"></a><span class="line-modified"> 390         gconstpointer node2)</span>
 391 {
 392   const ClassClosure *c1 = node1, *c2 = node2;
 393 
 394   return G_BSEARCH_ARRAY_CMP (c1-&gt;instance_type, c2-&gt;instance_type);
 395 }
 396 
 397 static gint
 398 handler_lists_cmp (gconstpointer node1,
 399                    gconstpointer node2)
 400 {
 401   const HandlerList *hlist1 = node1, *hlist2 = node2;
 402 
 403   return G_BSEARCH_ARRAY_CMP (hlist1-&gt;signal_id, hlist2-&gt;signal_id);
 404 }
 405 
 406 static inline HandlerList*
 407 handler_list_ensure (guint    signal_id,
<a name="16" id="anc16"></a><span class="line-modified"> 408          gpointer instance)</span>
 409 {
 410   GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
 411   HandlerList key;
 412 
 413   key.signal_id = signal_id;
 414   key.handlers    = NULL;
 415   key.tail_before = NULL;
 416   key.tail_after  = NULL;
 417   if (!hlbsa)
 418     {
 419       hlbsa = g_bsearch_array_create (&amp;g_signal_hlbsa_bconfig);
 420       hlbsa = g_bsearch_array_insert (hlbsa, &amp;g_signal_hlbsa_bconfig, &amp;key);
 421       g_hash_table_insert (g_handler_list_bsa_ht, instance, hlbsa);
 422     }
 423   else
 424     {
 425       GBSearchArray *o = hlbsa;
 426 
 427       hlbsa = g_bsearch_array_insert (o, &amp;g_signal_hlbsa_bconfig, &amp;key);
 428       if (hlbsa != o)
<a name="17" id="anc17"></a><span class="line-modified"> 429   g_hash_table_insert (g_handler_list_bsa_ht, instance, hlbsa);</span>
 430     }
 431   return g_bsearch_array_lookup (hlbsa, &amp;g_signal_hlbsa_bconfig, &amp;key);
 432 }
 433 
 434 static inline HandlerList*
 435 handler_list_lookup (guint    signal_id,
<a name="18" id="anc18"></a><span class="line-modified"> 436          gpointer instance)</span>
 437 {
 438   GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
 439   HandlerList key;
 440 
 441   key.signal_id = signal_id;
 442 
 443   return hlbsa ? g_bsearch_array_lookup (hlbsa, &amp;g_signal_hlbsa_bconfig, &amp;key) : NULL;
 444 }
 445 
 446 static guint
 447 handler_hash (gconstpointer key)
 448 {
 449   return (guint)((Handler*)key)-&gt;sequential_number;
 450 }
 451 
 452 static gboolean
 453 handler_equal (gconstpointer a, gconstpointer b)
 454 {
 455   Handler *ha = (Handler *)a;
 456   Handler *hb = (Handler *)b;
 457   return (ha-&gt;sequential_number == hb-&gt;sequential_number) &amp;&amp;
 458       (ha-&gt;instance  == hb-&gt;instance);
 459 }
 460 
 461 static Handler*
 462 handler_lookup (gpointer  instance,
<a name="19" id="anc19"></a><span class="line-modified"> 463     gulong    handler_id,</span>
<span class="line-modified"> 464     GClosure *closure,</span>
<span class="line-modified"> 465     guint    *signal_id_p)</span>
 466 {
 467   GBSearchArray *hlbsa;
 468 
 469   if (handler_id)
 470     {
 471       Handler key;
 472       key.sequential_number = handler_id;
 473       key.instance = instance;
 474       return g_hash_table_lookup (g_handlers, &amp;key);
 475 
 476     }
 477 
 478   hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
 479 
 480   if (hlbsa)
 481     {
 482       guint i;
 483 
 484       for (i = 0; i &lt; hlbsa-&gt;n_nodes; i++)
 485         {
 486           HandlerList *hlist = g_bsearch_array_get_nth (hlbsa, &amp;g_signal_hlbsa_bconfig, i);
 487           Handler *handler;
 488 
 489           for (handler = hlist-&gt;handlers; handler; handler = handler-&gt;next)
 490             if (closure ? (handler-&gt;closure == closure) : (handler-&gt;sequential_number == handler_id))
 491               {
 492                 if (signal_id_p)
 493                   *signal_id_p = hlist-&gt;signal_id;
 494 
 495                 return handler;
 496               }
 497         }
 498     }
 499 
 500   return NULL;
 501 }
 502 
 503 static inline HandlerMatch*
 504 handler_match_prepend (HandlerMatch *list,
<a name="20" id="anc20"></a><span class="line-modified"> 505            Handler      *handler,</span>
<span class="line-modified"> 506            guint       signal_id)</span>
 507 {
 508   HandlerMatch *node;
 509 
 510   node = g_slice_new (HandlerMatch);
 511 #ifdef GSTREAMER_LITE
 512   if (node == NULL) {
 513     return NULL;
 514   }
 515 #endif // GSTREAMER_LITE
 516   node-&gt;handler = handler;
 517   node-&gt;next = list;
 518   node-&gt;signal_id = signal_id;
 519   handler_ref (handler);
 520 
 521   return node;
 522 }
 523 static inline HandlerMatch*
 524 handler_match_free1_R (HandlerMatch *node,
<a name="21" id="anc21"></a><span class="line-modified"> 525            gpointer      instance)</span>
 526 {
 527   HandlerMatch *next = node-&gt;next;
 528 
 529   handler_unref_R (node-&gt;signal_id, instance, node-&gt;handler);
 530   g_slice_free (HandlerMatch, node);
 531 
 532   return next;
 533 }
 534 
 535 static HandlerMatch*
 536 handlers_find (gpointer         instance,
<a name="22" id="anc22"></a><span class="line-modified"> 537          GSignalMatchType mask,</span>
<span class="line-modified"> 538          guint            signal_id,</span>
<span class="line-modified"> 539          GQuark           detail,</span>
<span class="line-modified"> 540          GClosure        *closure,</span>
<span class="line-modified"> 541          gpointer         func,</span>
<span class="line-modified"> 542          gpointer         data,</span>
<span class="line-modified"> 543          gboolean         one_and_only)</span>
 544 {
 545   HandlerMatch *mlist = NULL;
 546 
 547   if (mask &amp; G_SIGNAL_MATCH_ID)
 548     {
 549       HandlerList *hlist = handler_list_lookup (signal_id, instance);
 550       Handler *handler;
 551       SignalNode *node = NULL;
 552 
 553       if (mask &amp; G_SIGNAL_MATCH_FUNC)
<a name="23" id="anc23"></a><span class="line-modified"> 554   {</span>
<span class="line-modified"> 555     node = LOOKUP_SIGNAL_NODE (signal_id);</span>
<span class="line-modified"> 556     if (!node || !node-&gt;c_marshaller)</span>
<span class="line-modified"> 557       return NULL;</span>
<span class="line-modified"> 558   }</span>
 559 
 560       mask = ~mask;
 561       for (handler = hlist ? hlist-&gt;handlers : NULL; handler; handler = handler-&gt;next)
 562         if (handler-&gt;sequential_number &amp;&amp;
<a name="24" id="anc24"></a><span class="line-modified"> 563       ((mask &amp; G_SIGNAL_MATCH_DETAIL) || handler-&gt;detail == detail) &amp;&amp;</span>
<span class="line-modified"> 564       ((mask &amp; G_SIGNAL_MATCH_CLOSURE) || handler-&gt;closure == closure) &amp;&amp;</span>
 565             ((mask &amp; G_SIGNAL_MATCH_DATA) || handler-&gt;closure-&gt;data == data) &amp;&amp;
<a name="25" id="anc25"></a><span class="line-modified"> 566       ((mask &amp; G_SIGNAL_MATCH_UNBLOCKED) || handler-&gt;block_count == 0) &amp;&amp;</span>
<span class="line-modified"> 567       ((mask &amp; G_SIGNAL_MATCH_FUNC) || (handler-&gt;closure-&gt;marshal == node-&gt;c_marshaller &amp;&amp;</span>
<span class="line-modified"> 568                 G_REAL_CLOSURE (handler-&gt;closure)-&gt;meta_marshal == NULL &amp;&amp;</span>
<span class="line-modified"> 569                 ((GCClosure*) handler-&gt;closure)-&gt;callback == func)))</span>
<span class="line-modified"> 570     {</span>
<span class="line-modified"> 571       mlist = handler_match_prepend (mlist, handler, signal_id);</span>
<span class="line-modified"> 572       if (one_and_only)</span>
<span class="line-modified"> 573         return mlist;</span>
<span class="line-modified"> 574     }</span>
 575     }
 576   else
 577     {
 578       GBSearchArray *hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
 579 
 580       mask = ~mask;
 581       if (hlbsa)
 582         {
 583           guint i;
 584 
 585           for (i = 0; i &lt; hlbsa-&gt;n_nodes; i++)
 586             {
 587               HandlerList *hlist = g_bsearch_array_get_nth (hlbsa, &amp;g_signal_hlbsa_bconfig, i);
<a name="26" id="anc26"></a><span class="line-modified"> 588         SignalNode *node = NULL;</span>
 589               Handler *handler;
 590 
<a name="27" id="anc27"></a><span class="line-modified"> 591         if (!(mask &amp; G_SIGNAL_MATCH_FUNC))</span>
<span class="line-modified"> 592     {</span>
<span class="line-modified"> 593       node = LOOKUP_SIGNAL_NODE (hlist-&gt;signal_id);</span>
 594 #ifndef GSTREAMER_LITE
<a name="28" id="anc28"></a><span class="line-modified"> 595       if (!node-&gt;c_marshaller)</span>
 596 #else // GSTREAMER_LITE
 597           if (!node || !node-&gt;c_marshaller)
 598 #endif // GSTREAMER_LITE
<a name="29" id="anc29"></a><span class="line-modified"> 599         continue;</span>
<span class="line-modified"> 600     }</span>
 601 
 602               for (handler = hlist-&gt;handlers; handler; handler = handler-&gt;next)
<a name="30" id="anc30"></a><span class="line-modified"> 603     if (handler-&gt;sequential_number &amp;&amp;</span>
<span class="line-modified"> 604         ((mask &amp; G_SIGNAL_MATCH_DETAIL) || handler-&gt;detail == detail) &amp;&amp;</span>
 605                     ((mask &amp; G_SIGNAL_MATCH_CLOSURE) || handler-&gt;closure == closure) &amp;&amp;
 606                     ((mask &amp; G_SIGNAL_MATCH_DATA) || handler-&gt;closure-&gt;data == data) &amp;&amp;
<a name="31" id="anc31"></a><span class="line-modified"> 607         ((mask &amp; G_SIGNAL_MATCH_UNBLOCKED) || handler-&gt;block_count == 0) &amp;&amp;</span>
<span class="line-modified"> 608         ((mask &amp; G_SIGNAL_MATCH_FUNC) || (handler-&gt;closure-&gt;marshal == node-&gt;c_marshaller &amp;&amp;</span>
<span class="line-modified"> 609                   G_REAL_CLOSURE (handler-&gt;closure)-&gt;meta_marshal == NULL &amp;&amp;</span>
<span class="line-modified"> 610                   ((GCClosure*) handler-&gt;closure)-&gt;callback == func)))</span>
<span class="line-modified"> 611       {</span>
<span class="line-modified"> 612         mlist = handler_match_prepend (mlist, handler, hlist-&gt;signal_id);</span>
<span class="line-modified"> 613         if (one_and_only)</span>
<span class="line-modified"> 614           return mlist;</span>
<span class="line-modified"> 615       }</span>
 616             }
 617         }
 618     }
 619 
 620   return mlist;
 621 }
 622 
 623 static inline Handler*
 624 handler_new (guint signal_id, gpointer instance, gboolean after)
 625 {
 626   Handler *handler = g_slice_new (Handler);
 627 #ifndef G_DISABLE_CHECKS
 628   if (g_handler_sequential_number &lt; 1)
 629     g_error (G_STRLOC &quot;: handler id overflow, %s&quot;, REPORT_BUG);
 630 #endif
 631 
 632   handler-&gt;sequential_number = g_handler_sequential_number++;
 633   handler-&gt;prev = NULL;
 634   handler-&gt;next = NULL;
 635   handler-&gt;detail = 0;
 636   handler-&gt;signal_id = signal_id;
 637   handler-&gt;instance = instance;
 638   handler-&gt;ref_count = 1;
 639   handler-&gt;block_count = 0;
 640   handler-&gt;after = after != FALSE;
 641   handler-&gt;closure = NULL;
 642   handler-&gt;has_invalid_closure_notify = 0;
 643 
 644   g_hash_table_add (g_handlers, handler);
 645 
 646   return handler;
 647 }
 648 
 649 static inline void
 650 handler_ref (Handler *handler)
 651 {
 652   g_return_if_fail (handler-&gt;ref_count &gt; 0);
 653 
 654   handler-&gt;ref_count++;
 655 }
 656 
 657 static inline void
 658 handler_unref_R (guint    signal_id,
<a name="32" id="anc32"></a><span class="line-modified"> 659      gpointer instance,</span>
<span class="line-modified"> 660      Handler *handler)</span>
 661 {
 662   g_return_if_fail (handler-&gt;ref_count &gt; 0);
 663 
 664   handler-&gt;ref_count--;
 665 
 666   if (G_UNLIKELY (handler-&gt;ref_count == 0))
 667     {
 668       HandlerList *hlist = NULL;
 669 
 670       if (handler-&gt;next)
 671         handler-&gt;next-&gt;prev = handler-&gt;prev;
 672       if (handler-&gt;prev)    /* watch out for g_signal_handlers_destroy()! */
 673         handler-&gt;prev-&gt;next = handler-&gt;next;
 674       else
 675         {
 676           hlist = handler_list_lookup (signal_id, instance);
 677           g_assert (hlist != NULL);
 678           hlist-&gt;handlers = handler-&gt;next;
 679         }
 680 
 681       if (instance)
 682         {
 683           /*  check if we are removing the handler pointed to by tail_before  */
 684           if (!handler-&gt;after &amp;&amp; (!handler-&gt;next || handler-&gt;next-&gt;after))
 685             {
 686               if (!hlist)
 687                 hlist = handler_list_lookup (signal_id, instance);
 688               if (hlist)
 689                 {
 690                   g_assert (hlist-&gt;tail_before == handler); /* paranoid */
 691                   hlist-&gt;tail_before = handler-&gt;prev;
 692                 }
 693             }
 694 
 695           /*  check if we are removing the handler pointed to by tail_after  */
 696           if (!handler-&gt;next)
 697             {
 698               if (!hlist)
 699                 hlist = handler_list_lookup (signal_id, instance);
 700               if (hlist)
 701                 {
 702                   g_assert (hlist-&gt;tail_after == handler); /* paranoid */
 703                   hlist-&gt;tail_after = handler-&gt;prev;
 704                 }
 705             }
 706         }
 707 
 708       SIGNAL_UNLOCK ();
 709       g_closure_unref (handler-&gt;closure);
 710       SIGNAL_LOCK ();
 711       g_slice_free (Handler, handler);
 712     }
 713 }
 714 
 715 static void
 716 handler_insert (guint    signal_id,
<a name="33" id="anc33"></a><span class="line-modified"> 717     gpointer instance,</span>
<span class="line-modified"> 718     Handler  *handler)</span>
 719 {
 720   HandlerList *hlist;
 721 
 722   g_assert (handler-&gt;prev == NULL &amp;&amp; handler-&gt;next == NULL); /* paranoid */
 723 
 724   hlist = handler_list_ensure (signal_id, instance);
 725   if (!hlist-&gt;handlers)
 726     {
 727       hlist-&gt;handlers = handler;
 728       if (!handler-&gt;after)
 729         hlist-&gt;tail_before = handler;
 730     }
 731   else if (handler-&gt;after)
 732     {
 733       handler-&gt;prev = hlist-&gt;tail_after;
 734       hlist-&gt;tail_after-&gt;next = handler;
 735     }
 736   else
 737     {
 738       if (hlist-&gt;tail_before)
 739         {
 740           handler-&gt;next = hlist-&gt;tail_before-&gt;next;
 741           if (handler-&gt;next)
 742             handler-&gt;next-&gt;prev = handler;
 743           handler-&gt;prev = hlist-&gt;tail_before;
 744           hlist-&gt;tail_before-&gt;next = handler;
 745         }
 746       else /* insert !after handler into a list of only after handlers */
 747         {
 748           handler-&gt;next = hlist-&gt;handlers;
 749           if (handler-&gt;next)
 750             handler-&gt;next-&gt;prev = handler;
 751           hlist-&gt;handlers = handler;
 752         }
 753       hlist-&gt;tail_before = handler;
 754     }
 755 
 756   if (!handler-&gt;next)
 757     hlist-&gt;tail_after = handler;
 758 }
 759 
 760 static void
 761 node_update_single_va_closure (SignalNode *node)
 762 {
 763   GClosure *closure = NULL;
 764   gboolean is_after = FALSE;
 765 
 766   /* Fast path single-handler without boxing the arguments in GValues */
 767   if (G_TYPE_IS_OBJECT (node-&gt;itype) &amp;&amp;
 768       (node-&gt;flags &amp; (G_SIGNAL_MUST_COLLECT)) == 0 &amp;&amp;
 769       (node-&gt;emission_hooks == NULL || node-&gt;emission_hooks-&gt;hooks == NULL))
 770     {
 771       GSignalFlags run_type;
 772       ClassClosure * cc;
 773       GBSearchArray *bsa = node-&gt;class_closure_bsa;
 774 
 775       if (bsa == NULL || bsa-&gt;n_nodes == 0)
<a name="34" id="anc34"></a><span class="line-modified"> 776   closure = SINGLE_VA_CLOSURE_EMPTY_MAGIC;</span>
 777       else if (bsa-&gt;n_nodes == 1)
<a name="35" id="anc35"></a><span class="line-added"> 778   {</span>
<span class="line-added"> 779     /* Look for default class closure (can&#39;t support non-default as it</span>
<span class="line-added"> 780        chains up using GValues */</span>
<span class="line-added"> 781     cc = g_bsearch_array_get_nth (bsa, &amp;g_class_closure_bconfig, 0);</span>
<span class="line-added"> 782     if (cc-&gt;instance_type == 0)</span>
<span class="line-added"> 783       {</span>
<span class="line-added"> 784         run_type = node-&gt;flags &amp; (G_SIGNAL_RUN_FIRST|G_SIGNAL_RUN_LAST|G_SIGNAL_RUN_CLEANUP);</span>
<span class="line-added"> 785         /* Only support *one* of run-first or run-last, not multiple or cleanup */</span>
<span class="line-added"> 786         if (run_type == G_SIGNAL_RUN_FIRST ||</span>
<span class="line-added"> 787       run_type == G_SIGNAL_RUN_LAST)</span>
 788     {
<a name="36" id="anc36"></a><span class="line-modified"> 789       closure = cc-&gt;closure;</span>
<span class="line-modified"> 790       is_after = (run_type == G_SIGNAL_RUN_LAST);</span>












 791     }
<a name="37" id="anc37"></a><span class="line-added"> 792       }</span>
<span class="line-added"> 793   }</span>
 794     }
 795 
 796   node-&gt;single_va_closure_is_valid = TRUE;
 797   node-&gt;single_va_closure = closure;
 798   node-&gt;single_va_closure_is_after = is_after;
 799 }
 800 
 801 static inline void
 802 emission_push (Emission  *emission)
 803 {
 804   emission-&gt;next = g_emissions;
 805   g_emissions = emission;
 806 }
 807 
 808 static inline void
 809 emission_pop (Emission  *emission)
 810 {
 811   Emission *node, *last = NULL;
 812 
 813   for (node = g_emissions; node; last = node, node = last-&gt;next)
 814     if (node == emission)
 815       {
<a name="38" id="anc38"></a><span class="line-modified"> 816   if (last)</span>
<span class="line-modified"> 817     last-&gt;next = node-&gt;next;</span>
<span class="line-modified"> 818   else</span>
<span class="line-modified"> 819     g_emissions = node-&gt;next;</span>
<span class="line-modified"> 820   return;</span>
 821       }
 822   g_assert_not_reached ();
 823 }
 824 
 825 static inline Emission*
 826 emission_find (guint     signal_id,
<a name="39" id="anc39"></a><span class="line-modified"> 827          GQuark    detail,</span>
<span class="line-modified"> 828          gpointer  instance)</span>
 829 {
 830   Emission *emission;
 831 
 832   for (emission = g_emissions; emission; emission = emission-&gt;next)
 833     if (emission-&gt;instance == instance &amp;&amp;
<a name="40" id="anc40"></a><span class="line-modified"> 834   emission-&gt;ihint.signal_id == signal_id &amp;&amp;</span>
<span class="line-modified"> 835   emission-&gt;ihint.detail == detail)</span>
 836       return emission;
 837   return NULL;
 838 }
 839 
 840 static inline Emission*
 841 emission_find_innermost (gpointer instance)
 842 {
 843   Emission *emission;
 844 
 845   for (emission = g_emissions; emission; emission = emission-&gt;next)
 846     if (emission-&gt;instance == instance)
 847       return emission;
 848 
 849   return NULL;
<a name="41" id="anc41"></a><span class="line-modified"> 850 }</span>
 851 
 852 static gint
 853 signal_key_cmp (gconstpointer node1,
 854                 gconstpointer node2)
 855 {
 856   const SignalKey *key1 = node1, *key2 = node2;
 857 
 858   if (key1-&gt;itype == key2-&gt;itype)
 859     return G_BSEARCH_ARRAY_CMP (key1-&gt;quark, key2-&gt;quark);
 860   else
 861     return G_BSEARCH_ARRAY_CMP (key1-&gt;itype, key2-&gt;itype);
 862 }
 863 
 864 void
 865 _g_signal_init (void)
 866 {
 867   SIGNAL_LOCK ();
 868   if (!g_n_signal_nodes)
 869     {
 870       /* setup handler list binary searchable array hash table (in german, that&#39;d be one word ;) */
 871       g_handler_list_bsa_ht = g_hash_table_new (g_direct_hash, NULL);
 872       g_signal_key_bsa = g_bsearch_array_create (&amp;g_signal_key_bconfig);
 873 
 874       /* invalid (0) signal_id */
 875       g_n_signal_nodes = 1;
 876       g_signal_nodes = g_renew (SignalNode*, g_signal_nodes, g_n_signal_nodes);
 877       g_signal_nodes[0] = NULL;
 878       g_handlers = g_hash_table_new (handler_hash, handler_equal);
 879     }
 880   SIGNAL_UNLOCK ();
 881 }
 882 
 883 void
 884 _g_signals_destroy (GType itype)
 885 {
 886   guint i;
 887 
 888   SIGNAL_LOCK ();
 889   for (i = 1; i &lt; g_n_signal_nodes; i++)
 890     {
 891       SignalNode *node = g_signal_nodes[i];
 892 
 893       if (node-&gt;itype == itype)
 894         {
 895           if (node-&gt;destroyed)
 896             g_warning (G_STRLOC &quot;: signal \&quot;%s\&quot; of type &#39;%s&#39; already destroyed&quot;,
 897                        node-&gt;name,
 898                        type_debug_name (node-&gt;itype));
 899           else
<a name="42" id="anc42"></a><span class="line-modified"> 900       signal_destroy_R (node);</span>
 901         }
 902     }
 903   SIGNAL_UNLOCK ();
 904 }
 905 
 906 /**
 907  * g_signal_stop_emission:
 908  * @instance: (type GObject.Object): the object whose signal handlers you wish to stop.
 909  * @signal_id: the signal identifier, as returned by g_signal_lookup().
 910  * @detail: the detail which the signal was emitted with.
 911  *
 912  * Stops a signal&#39;s current emission.
 913  *
 914  * This will prevent the default method from running, if the signal was
 915  * %G_SIGNAL_RUN_LAST and you connected normally (i.e. without the &quot;after&quot;
 916  * flag).
 917  *
 918  * Prints a warning if used on a signal which isn&#39;t being emitted.
 919  */
 920 void
 921 g_signal_stop_emission (gpointer instance,
 922                         guint    signal_id,
<a name="43" id="anc43"></a><span class="line-modified"> 923       GQuark   detail)</span>
 924 {
 925   SignalNode *node;
 926 
 927   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
 928   g_return_if_fail (signal_id &gt; 0);
 929 
 930   SIGNAL_LOCK ();
 931   node = LOOKUP_SIGNAL_NODE (signal_id);
 932   if (node &amp;&amp; detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
 933     {
 934       g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);
 935       SIGNAL_UNLOCK ();
 936       return;
 937     }
 938   if (node &amp;&amp; g_type_is_a (G_TYPE_FROM_INSTANCE (instance), node-&gt;itype))
 939     {
 940       Emission *emission = emission_find (signal_id, detail, instance);
 941 
 942       if (emission)
 943         {
 944           if (emission-&gt;state == EMISSION_HOOK)
 945             g_warning (G_STRLOC &quot;: emission of signal \&quot;%s\&quot; for instance &#39;%p&#39; cannot be stopped from emission hook&quot;,
 946                        node-&gt;name, instance);
 947           else if (emission-&gt;state == EMISSION_RUN)
 948             emission-&gt;state = EMISSION_STOP;
 949         }
 950       else
 951         g_warning (G_STRLOC &quot;: no emission of signal \&quot;%s\&quot; to stop for instance &#39;%p&#39;&quot;,
 952                    node-&gt;name, instance);
 953     }
 954   else
 955     g_warning (&quot;%s: signal id &#39;%u&#39; is invalid for instance &#39;%p&#39;&quot;, G_STRLOC, signal_id, instance);
 956   SIGNAL_UNLOCK ();
 957 }
 958 
 959 static void
 960 signal_finalize_hook (GHookList *hook_list,
<a name="44" id="anc44"></a><span class="line-modified"> 961           GHook     *hook)</span>
 962 {
 963   GDestroyNotify destroy = hook-&gt;destroy;
 964 
 965   if (destroy)
 966     {
 967       hook-&gt;destroy = NULL;
 968       SIGNAL_UNLOCK ();
 969       destroy (hook-&gt;data);
 970       SIGNAL_LOCK ();
 971     }
 972 }
 973 
 974 /**
 975  * g_signal_add_emission_hook:
 976  * @signal_id: the signal identifier, as returned by g_signal_lookup().
 977  * @detail: the detail on which to call the hook.
 978  * @hook_func: a #GSignalEmissionHook function.
 979  * @hook_data: user data for @hook_func.
 980  * @data_destroy: a #GDestroyNotify for @hook_data.
 981  *
 982  * Adds an emission hook for a signal, which will get called for any emission
 983  * of that signal, independent of the instance. This is possible only
 984  * for signals which don&#39;t have #G_SIGNAL_NO_HOOKS flag set.
 985  *
 986  * Returns: the hook id, for later use with g_signal_remove_emission_hook().
 987  */
 988 gulong
 989 g_signal_add_emission_hook (guint               signal_id,
<a name="45" id="anc45"></a><span class="line-modified"> 990           GQuark              detail,</span>
<span class="line-modified"> 991           GSignalEmissionHook hook_func,</span>
<span class="line-modified"> 992           gpointer            hook_data,</span>
<span class="line-modified"> 993           GDestroyNotify      data_destroy)</span>
 994 {
 995   static gulong seq_hook_id = 1;
 996   SignalNode *node;
 997   GHook *hook;
 998   SignalHook *signal_hook;
 999 
1000   g_return_val_if_fail (signal_id &gt; 0, 0);
1001   g_return_val_if_fail (hook_func != NULL, 0);
1002 
1003   SIGNAL_LOCK ();
1004   node = LOOKUP_SIGNAL_NODE (signal_id);
1005   if (!node || node-&gt;destroyed)
1006     {
1007       g_warning (&quot;%s: invalid signal id &#39;%u&#39;&quot;, G_STRLOC, signal_id);
1008       SIGNAL_UNLOCK ();
1009       return 0;
1010     }
1011   if (node-&gt;flags &amp; G_SIGNAL_NO_HOOKS)
1012     {
1013       g_warning (&quot;%s: signal id &#39;%u&#39; does not support emission hooks (G_SIGNAL_NO_HOOKS flag set)&quot;, G_STRLOC, signal_id);
1014       SIGNAL_UNLOCK ();
1015       return 0;
1016     }
1017   if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
1018     {
1019       g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);
1020       SIGNAL_UNLOCK ();
1021       return 0;
1022     }
1023     node-&gt;single_va_closure_is_valid = FALSE;
1024   if (!node-&gt;emission_hooks)
1025     {
1026       node-&gt;emission_hooks = g_new (GHookList, 1);
1027       g_hook_list_init (node-&gt;emission_hooks, sizeof (SignalHook));
1028       node-&gt;emission_hooks-&gt;finalize_hook = signal_finalize_hook;
1029     }
1030 
1031   node_check_deprecated (node);
1032 
1033   hook = g_hook_alloc (node-&gt;emission_hooks);
1034   hook-&gt;data = hook_data;
1035   hook-&gt;func = (gpointer) hook_func;
1036   hook-&gt;destroy = data_destroy;
1037   signal_hook = SIGNAL_HOOK (hook);
1038   signal_hook-&gt;detail = detail;
1039   node-&gt;emission_hooks-&gt;seq_id = seq_hook_id;
1040   g_hook_append (node-&gt;emission_hooks, hook);
1041   seq_hook_id = node-&gt;emission_hooks-&gt;seq_id;
1042 
1043   SIGNAL_UNLOCK ();
1044 
1045   return hook-&gt;hook_id;
1046 }
1047 
1048 /**
1049  * g_signal_remove_emission_hook:
1050  * @signal_id: the id of the signal
1051  * @hook_id: the id of the emission hook, as returned by
1052  *  g_signal_add_emission_hook()
1053  *
1054  * Deletes an emission hook.
1055  */
1056 void
1057 g_signal_remove_emission_hook (guint  signal_id,
<a name="46" id="anc46"></a><span class="line-modified">1058              gulong hook_id)</span>
1059 {
1060   SignalNode *node;
1061 
1062   g_return_if_fail (signal_id &gt; 0);
1063   g_return_if_fail (hook_id &gt; 0);
1064 
1065   SIGNAL_LOCK ();
1066   node = LOOKUP_SIGNAL_NODE (signal_id);
1067   if (!node || node-&gt;destroyed)
1068     {
1069       g_warning (&quot;%s: invalid signal id &#39;%u&#39;&quot;, G_STRLOC, signal_id);
1070       goto out;
1071     }
1072   else if (!node-&gt;emission_hooks || !g_hook_destroy (node-&gt;emission_hooks, hook_id))
1073     g_warning (&quot;%s: signal \&quot;%s\&quot; had no hook (%lu) to remove&quot;, G_STRLOC, node-&gt;name, hook_id);
1074 
1075   node-&gt;single_va_closure_is_valid = FALSE;
1076 
1077  out:
1078   SIGNAL_UNLOCK ();
1079 }
1080 
1081 static inline guint
1082 signal_parse_name (const gchar *name,
<a name="47" id="anc47"></a><span class="line-modified">1083        GType        itype,</span>
<span class="line-modified">1084        GQuark      *detail_p,</span>
<span class="line-modified">1085        gboolean     force_quark)</span>
1086 {
1087   const gchar *colon = strchr (name, &#39;:&#39;);
1088   guint signal_id;
1089 
1090   if (!colon)
1091     {
1092       signal_id = signal_id_lookup (g_quark_try_string (name), itype);
1093       if (signal_id &amp;&amp; detail_p)
<a name="48" id="anc48"></a><span class="line-modified">1094   *detail_p = 0;</span>
1095     }
1096   else if (colon[1] == &#39;:&#39;)
1097     {
1098       gchar buffer[32];
1099       guint l = colon - name;
1100 
1101       if (l &lt; 32)
<a name="49" id="anc49"></a><span class="line-modified">1102   {</span>
<span class="line-modified">1103     memcpy (buffer, name, l);</span>
<span class="line-modified">1104     buffer[l] = 0;</span>
<span class="line-modified">1105     signal_id = signal_id_lookup (g_quark_try_string (buffer), itype);</span>
<span class="line-modified">1106   }</span>
1107       else
<a name="50" id="anc50"></a><span class="line-modified">1108   {</span>
<span class="line-modified">1109     gchar *signal = g_new (gchar, l + 1);</span>
1110 
<a name="51" id="anc51"></a><span class="line-modified">1111     memcpy (signal, name, l);</span>
<span class="line-modified">1112     signal[l] = 0;</span>
<span class="line-modified">1113     signal_id = signal_id_lookup (g_quark_try_string (signal), itype);</span>
<span class="line-modified">1114     g_free (signal);</span>
<span class="line-modified">1115   }</span>
1116 
1117       if (signal_id &amp;&amp; detail_p)
<a name="52" id="anc52"></a><span class="line-modified">1118   *detail_p = colon[2] ? (force_quark ? g_quark_from_string : g_quark_try_string) (colon + 2) : 0;</span>
1119     }
1120   else
1121     signal_id = 0;
1122   return signal_id;
1123 }
1124 
1125 /**
1126  * g_signal_parse_name:
1127  * @detailed_signal: a string of the form &quot;signal-name::detail&quot;.
1128  * @itype: The interface/instance type that introduced &quot;signal-name&quot;.
1129  * @signal_id_p: (out): Location to store the signal id.
1130  * @detail_p: (out): Location to store the detail quark.
1131  * @force_detail_quark: %TRUE forces creation of a #GQuark for the detail.
1132  *
1133  * Internal function to parse a signal name into its @signal_id
1134  * and @detail quark.
1135  *
1136  * Returns: Whether the signal name could successfully be parsed and @signal_id_p and @detail_p contain valid return values.
1137  */
1138 gboolean
1139 g_signal_parse_name (const gchar *detailed_signal,
<a name="53" id="anc53"></a><span class="line-modified">1140          GType        itype,</span>
<span class="line-modified">1141          guint       *signal_id_p,</span>
<span class="line-modified">1142          GQuark      *detail_p,</span>
<span class="line-modified">1143          gboolean   force_detail_quark)</span>
1144 {
1145   SignalNode *node;
1146   GQuark detail = 0;
1147   guint signal_id;
1148 
1149   g_return_val_if_fail (detailed_signal != NULL, FALSE);
1150   g_return_val_if_fail (G_TYPE_IS_INSTANTIATABLE (itype) || G_TYPE_IS_INTERFACE (itype), FALSE);
1151 
1152   SIGNAL_LOCK ();
1153   signal_id = signal_parse_name (detailed_signal, itype, &amp;detail, force_detail_quark);
1154   SIGNAL_UNLOCK ();
1155 
1156   node = signal_id ? LOOKUP_SIGNAL_NODE (signal_id) : NULL;
1157   if (!node || node-&gt;destroyed ||
1158       (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED)))
1159     return FALSE;
1160 
1161   if (signal_id_p)
1162     *signal_id_p = signal_id;
1163   if (detail_p)
1164     *detail_p = detail;
1165 
1166   return TRUE;
1167 }
1168 
1169 /**
1170  * g_signal_stop_emission_by_name:
1171  * @instance: (type GObject.Object): the object whose signal handlers you wish to stop.
1172  * @detailed_signal: a string of the form &quot;signal-name::detail&quot;.
1173  *
1174  * Stops a signal&#39;s current emission.
1175  *
1176  * This is just like g_signal_stop_emission() except it will look up the
1177  * signal id for you.
1178  */
1179 void
1180 g_signal_stop_emission_by_name (gpointer     instance,
<a name="54" id="anc54"></a><span class="line-modified">1181         const gchar *detailed_signal)</span>
1182 {
1183   guint signal_id;
1184   GQuark detail = 0;
1185   GType itype;
1186 
1187   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
1188   g_return_if_fail (detailed_signal != NULL);
1189 
1190   SIGNAL_LOCK ();
1191   itype = G_TYPE_FROM_INSTANCE (instance);
1192   signal_id = signal_parse_name (detailed_signal, itype, &amp;detail, TRUE);
1193   if (signal_id)
1194     {
1195       SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
1196 
1197       if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
<a name="55" id="anc55"></a><span class="line-modified">1198   g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);</span>
1199       else if (!g_type_is_a (itype, node-&gt;itype))
1200         g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
1201                    G_STRLOC, detailed_signal, instance, g_type_name (itype));
1202       else
<a name="56" id="anc56"></a><span class="line-modified">1203   {</span>
<span class="line-modified">1204     Emission *emission = emission_find (signal_id, detail, instance);</span>
1205 
<a name="57" id="anc57"></a><span class="line-modified">1206     if (emission)</span>
<span class="line-modified">1207       {</span>
<span class="line-modified">1208         if (emission-&gt;state == EMISSION_HOOK)</span>
<span class="line-modified">1209     g_warning (G_STRLOC &quot;: emission of signal \&quot;%s\&quot; for instance &#39;%p&#39; cannot be stopped from emission hook&quot;,</span>
<span class="line-modified">1210          node-&gt;name, instance);</span>
<span class="line-modified">1211         else if (emission-&gt;state == EMISSION_RUN)</span>
<span class="line-modified">1212     emission-&gt;state = EMISSION_STOP;</span>
<span class="line-modified">1213       }</span>
<span class="line-modified">1214     else</span>
<span class="line-modified">1215       g_warning (G_STRLOC &quot;: no emission of signal \&quot;%s\&quot; to stop for instance &#39;%p&#39;&quot;,</span>
<span class="line-modified">1216            node-&gt;name, instance);</span>
<span class="line-modified">1217   }</span>
1218     }
1219   else
1220     g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
1221                G_STRLOC, detailed_signal, instance, g_type_name (itype));
1222   SIGNAL_UNLOCK ();
1223 }
1224 
1225 /**
1226  * g_signal_lookup:
1227  * @name: the signal&#39;s name.
1228  * @itype: the type that the signal operates on.
1229  *
1230  * Given the name of the signal and the type of object it connects to, gets
1231  * the signal&#39;s identifying integer. Emitting the signal by number is
1232  * somewhat faster than using the name each time.
1233  *
1234  * Also tries the ancestors of the given type.
1235  *
1236  * See g_signal_new() for details on allowed signal names.
1237  *
1238  * Returns: the signal&#39;s identifying number, or 0 if no signal was found.
1239  */
1240 guint
1241 g_signal_lookup (const gchar *name,
1242                  GType        itype)
1243 {
1244   guint signal_id;
1245   g_return_val_if_fail (name != NULL, 0);
1246   g_return_val_if_fail (G_TYPE_IS_INSTANTIATABLE (itype) || G_TYPE_IS_INTERFACE (itype), 0);
1247 
1248   SIGNAL_LOCK ();
1249   signal_id = signal_id_lookup (g_quark_try_string (name), itype);
1250   SIGNAL_UNLOCK ();
1251   if (!signal_id)
1252     {
1253       /* give elaborate warnings */
1254       if (!g_type_name (itype))
<a name="58" id="anc58"></a><span class="line-modified">1255   g_warning (G_STRLOC &quot;: unable to look up signal \&quot;%s\&quot; for invalid type id &#39;%&quot;G_GSIZE_FORMAT&quot;&#39;&quot;,</span>
<span class="line-modified">1256        name, itype);</span>
1257       else if (!G_TYPE_IS_INSTANTIATABLE (itype))
<a name="59" id="anc59"></a><span class="line-modified">1258   g_warning (G_STRLOC &quot;: unable to look up signal \&quot;%s\&quot; for non instantiatable type &#39;%s&#39;&quot;,</span>
<span class="line-modified">1259        name, g_type_name (itype));</span>
1260       else if (!g_type_class_peek (itype))
<a name="60" id="anc60"></a><span class="line-modified">1261   g_warning (G_STRLOC &quot;: unable to look up signal \&quot;%s\&quot; of unloaded type &#39;%s&#39;&quot;,</span>
<span class="line-modified">1262        name, g_type_name (itype));</span>
1263     }
1264 
1265   return signal_id;
1266 }
1267 
1268 /**
1269  * g_signal_list_ids:
1270  * @itype: Instance or interface type.
1271  * @n_ids: Location to store the number of signal ids for @itype.
1272  *
1273  * Lists the signals by id that a certain instance or interface type
1274  * created. Further information about the signals can be acquired through
1275  * g_signal_query().
1276  *
1277  * Returns: (array length=n_ids) (transfer full): Newly allocated array of signal IDs.
1278  */
1279 guint*
1280 g_signal_list_ids (GType  itype,
<a name="61" id="anc61"></a><span class="line-modified">1281        guint *n_ids)</span>
1282 {
1283   SignalKey *keys;
1284   GArray *result;
1285   guint n_nodes;
1286   guint i;
1287 
1288   g_return_val_if_fail (G_TYPE_IS_INSTANTIATABLE (itype) || G_TYPE_IS_INTERFACE (itype), NULL);
1289   g_return_val_if_fail (n_ids != NULL, NULL);
1290 
1291   SIGNAL_LOCK ();
1292   keys = g_bsearch_array_get_nth (g_signal_key_bsa, &amp;g_signal_key_bconfig, 0);
1293   n_nodes = g_bsearch_array_get_n_nodes (g_signal_key_bsa);
1294   result = g_array_new (FALSE, FALSE, sizeof (guint));
1295 #ifdef GSTREAMER_LITE
1296   if (result == NULL) {
1297     SIGNAL_UNLOCK ();
1298     return NULL;
1299   }
1300 #endif // GSTREAMER_LITE
1301 
1302   for (i = 0; i &lt; n_nodes; i++)
1303     if (keys[i].itype == itype)
1304       {
<a name="62" id="anc62"></a><span class="line-modified">1305   const gchar *name = g_quark_to_string (keys[i].quark);</span>
1306 
<a name="63" id="anc63"></a><span class="line-modified">1307   /* Signal names with &quot;_&quot; in them are aliases to the same</span>
<span class="line-modified">1308    * name with &quot;-&quot; instead of &quot;_&quot;.</span>
<span class="line-modified">1309    */</span>
<span class="line-modified">1310   if (!strchr (name, &#39;_&#39;))</span>
<span class="line-modified">1311     g_array_append_val (result, keys[i].signal_id);</span>
1312       }
1313   *n_ids = result-&gt;len;
1314   SIGNAL_UNLOCK ();
1315   if (!n_nodes)
1316     {
1317       /* give elaborate warnings */
1318       if (!g_type_name (itype))
<a name="64" id="anc64"></a><span class="line-modified">1319   g_warning (G_STRLOC &quot;: unable to list signals for invalid type id &#39;%&quot;G_GSIZE_FORMAT&quot;&#39;&quot;,</span>
<span class="line-modified">1320        itype);</span>
1321       else if (!G_TYPE_IS_INSTANTIATABLE (itype) &amp;&amp; !G_TYPE_IS_INTERFACE (itype))
<a name="65" id="anc65"></a><span class="line-modified">1322   g_warning (G_STRLOC &quot;: unable to list signals of non instantiatable type &#39;%s&#39;&quot;,</span>
<span class="line-modified">1323        g_type_name (itype));</span>
1324       else if (!g_type_class_peek (itype) &amp;&amp; !G_TYPE_IS_INTERFACE (itype))
<a name="66" id="anc66"></a><span class="line-modified">1325   g_warning (G_STRLOC &quot;: unable to list signals of unloaded type &#39;%s&#39;&quot;,</span>
<span class="line-modified">1326        g_type_name (itype));</span>
1327     }
1328 
1329   return (guint*) g_array_free (result, FALSE);
1330 }
1331 
1332 /**
1333  * g_signal_name:
1334  * @signal_id: the signal&#39;s identifying number.
1335  *
1336  * Given the signal&#39;s identifier, finds its name.
1337  *
1338  * Two different signals may have the same name, if they have differing types.
1339  *
1340  * Returns: the signal name, or %NULL if the signal number was invalid.
1341  */
1342 const gchar *
1343 g_signal_name (guint signal_id)
1344 {
1345   SignalNode *node;
1346   const gchar *name;
1347 
1348   SIGNAL_LOCK ();
1349   node = LOOKUP_SIGNAL_NODE (signal_id);
1350   name = node ? node-&gt;name : NULL;
1351   SIGNAL_UNLOCK ();
1352 
1353   return (char*) name;
1354 }
1355 
1356 /**
1357  * g_signal_query:
1358  * @signal_id: The signal id of the signal to query information for.
1359  * @query: (out caller-allocates): A user provided structure that is
1360  *  filled in with constant values upon success.
1361  *
1362  * Queries the signal system for in-depth information about a
1363  * specific signal. This function will fill in a user-provided
1364  * structure to hold signal-specific information. If an invalid
1365  * signal id is passed in, the @signal_id member of the #GSignalQuery
1366  * is 0. All members filled into the #GSignalQuery structure should
1367  * be considered constant and have to be left untouched.
1368  */
1369 void
1370 g_signal_query (guint         signal_id,
<a name="67" id="anc67"></a><span class="line-modified">1371     GSignalQuery *query)</span>
1372 {
1373   SignalNode *node;
1374 
1375   g_return_if_fail (query != NULL);
1376 
1377   SIGNAL_LOCK ();
1378   node = LOOKUP_SIGNAL_NODE (signal_id);
1379   if (!node || node-&gt;destroyed)
1380     query-&gt;signal_id = 0;
1381   else
1382     {
1383       query-&gt;signal_id = node-&gt;signal_id;
1384       query-&gt;signal_name = node-&gt;name;
1385       query-&gt;itype = node-&gt;itype;
1386       query-&gt;signal_flags = node-&gt;flags;
1387       query-&gt;return_type = node-&gt;return_type;
1388       query-&gt;n_params = node-&gt;n_params;
1389       query-&gt;param_types = node-&gt;param_types;
1390     }
1391   SIGNAL_UNLOCK ();
1392 }
1393 
1394 /**
1395  * g_signal_new:
1396  * @signal_name: the name for the signal
1397  * @itype: the type this signal pertains to. It will also pertain to
1398  *  types which are derived from this type.
1399  * @signal_flags: a combination of #GSignalFlags specifying detail of when
1400  *  the default handler is to be invoked. You should at least specify
1401  *  %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST.
1402  * @class_offset: The offset of the function pointer in the class structure
1403  *  for this type. Used to invoke a class method generically. Pass 0 to
1404  *  not associate a class method slot with this signal.
1405  * @accumulator: the accumulator for this signal; may be %NULL.
1406  * @accu_data: user data for the @accumulator.
1407  * @c_marshaller: (nullable): the function to translate arrays of parameter
1408  *  values to signal emissions into C language callback invocations or %NULL.
1409  * @return_type: the type of return value, or #G_TYPE_NONE for a signal
1410  *  without a return value.
1411  * @n_params: the number of parameter types to follow.
1412  * @...: a list of types, one for each parameter.
1413  *
1414  * Creates a new signal. (This is usually done in the class initializer.)
1415  *
1416  * A signal name consists of segments consisting of ASCII letters and
1417  * digits, separated by either the &#39;-&#39; or &#39;_&#39; character. The first
1418  * character of a signal name must be a letter. Names which violate these
1419  * rules lead to undefined behaviour of the GSignal system.
1420  *
1421  * When registering a signal and looking up a signal, either separator can
1422  * be used, but they cannot be mixed.
1423  *
1424  * If 0 is used for @class_offset subclasses cannot override the class handler
1425  * in their class_init method by doing super_class-&gt;signal_handler = my_signal_handler.
1426  * Instead they will have to use g_signal_override_class_handler().
1427  *
<a name="68" id="anc68"></a><span class="line-modified">1428  * If @c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as</span>
<span class="line-modified">1429  * the marshaller for this signal. In some simple cases, g_signal_new()</span>
<span class="line-added">1430  * will use a more optimized c_marshaller and va_marshaller for the signal</span>
<span class="line-added">1431  * instead of g_cclosure_marshal_generic().</span>
<span class="line-added">1432  *</span>
<span class="line-added">1433  * If @c_marshaller is non-%NULL, you need to also specify a va_marshaller</span>
<span class="line-added">1434  * using g_signal_set_va_marshaller() or the generic va_marshaller will</span>
<span class="line-added">1435  * be used.</span>
1436  *
1437  * Returns: the signal id
1438  */
1439 guint
<a name="69" id="anc69"></a><span class="line-modified">1440 g_signal_new (const gchar  *signal_name,</span>
<span class="line-modified">1441         GType     itype,</span>
<span class="line-modified">1442         GSignalFlags    signal_flags,</span>
<span class="line-modified">1443         guint               class_offset,</span>
<span class="line-modified">1444         GSignalAccumulator  accumulator,</span>
<span class="line-modified">1445         gpointer      accu_data,</span>
<span class="line-modified">1446         GSignalCMarshaller  c_marshaller,</span>
<span class="line-modified">1447         GType     return_type,</span>
<span class="line-modified">1448         guint     n_params,</span>
<span class="line-modified">1449         ...)</span>
1450 {
1451   va_list args;
1452   guint signal_id;
1453 
1454   g_return_val_if_fail (signal_name != NULL, 0);
1455 
1456   va_start (args, n_params);
1457 
1458   signal_id = g_signal_new_valist (signal_name, itype, signal_flags,
1459                                    class_offset ? g_signal_type_cclosure_new (itype, class_offset) : NULL,
<a name="70" id="anc70"></a><span class="line-modified">1460            accumulator, accu_data, c_marshaller,</span>
1461                                    return_type, n_params, args);
1462 
1463   va_end (args);
1464 
1465   return signal_id;
1466 }
1467 
1468 /**
1469  * g_signal_new_class_handler:
1470  * @signal_name: the name for the signal
1471  * @itype: the type this signal pertains to. It will also pertain to
1472  *  types which are derived from this type.
1473  * @signal_flags: a combination of #GSignalFlags specifying detail of when
1474  *  the default handler is to be invoked. You should at least specify
1475  *  %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST.
1476  * @class_handler: a #GCallback which acts as class implementation of
1477  *  this signal. Used to invoke a class method generically. Pass %NULL to
1478  *  not associate a class method with this signal.
1479  * @accumulator: the accumulator for this signal; may be %NULL.
1480  * @accu_data: user data for the @accumulator.
1481  * @c_marshaller: (nullable): the function to translate arrays of parameter
1482  *  values to signal emissions into C language callback invocations or %NULL.
1483  * @return_type: the type of return value, or #G_TYPE_NONE for a signal
1484  *  without a return value.
1485  * @n_params: the number of parameter types to follow.
1486  * @...: a list of types, one for each parameter.
1487  *
1488  * Creates a new signal. (This is usually done in the class initializer.)
1489  *
1490  * This is a variant of g_signal_new() that takes a C callback instead
1491  * of a class offset for the signal&#39;s class handler. This function
1492  * doesn&#39;t need a function pointer exposed in the class structure of
1493  * an object definition, instead the function pointer is passed
1494  * directly and can be overriden by derived classes with
1495  * g_signal_override_class_closure() or
1496  * g_signal_override_class_handler()and chained to with
1497  * g_signal_chain_from_overridden() or
1498  * g_signal_chain_from_overridden_handler().
1499  *
1500  * See g_signal_new() for information about signal names.
1501  *
1502  * If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
1503  * the marshaller for this signal.
1504  *
1505  * Returns: the signal id
1506  *
1507  * Since: 2.18
1508  */
1509 guint
1510 g_signal_new_class_handler (const gchar        *signal_name,
1511                             GType               itype,
1512                             GSignalFlags        signal_flags,
1513                             GCallback           class_handler,
1514                             GSignalAccumulator  accumulator,
1515                             gpointer            accu_data,
1516                             GSignalCMarshaller  c_marshaller,
1517                             GType               return_type,
1518                             guint               n_params,
1519                             ...)
1520 {
1521   va_list args;
1522   guint signal_id;
1523 
1524   g_return_val_if_fail (signal_name != NULL, 0);
1525 
1526   va_start (args, n_params);
1527 
1528   signal_id = g_signal_new_valist (signal_name, itype, signal_flags,
1529                                    class_handler ? g_cclosure_new (class_handler, NULL, NULL) : NULL,
1530                                    accumulator, accu_data, c_marshaller,
1531                                    return_type, n_params, args);
1532 
1533   va_end (args);
1534 
1535   return signal_id;
1536 }
1537 
1538 static inline ClassClosure*
1539 signal_find_class_closure (SignalNode *node,
<a name="71" id="anc71"></a><span class="line-modified">1540          GType       itype)</span>
1541 {
1542   GBSearchArray *bsa = node-&gt;class_closure_bsa;
1543   ClassClosure *cc;
1544 
1545   if (bsa)
1546     {
1547       ClassClosure key;
1548 
1549       /* cc-&gt;instance_type is 0 for default closure */
1550 
1551       if (g_bsearch_array_get_n_nodes (bsa) == 1)
1552         {
1553           cc = g_bsearch_array_get_nth (bsa, &amp;g_class_closure_bconfig, 0);
1554           if (cc &amp;&amp; cc-&gt;instance_type == 0) /* check for default closure */
1555             return cc;
1556         }
1557 
1558       key.instance_type = itype;
1559       cc = g_bsearch_array_lookup (bsa, &amp;g_class_closure_bconfig, &amp;key);
1560       while (!cc &amp;&amp; key.instance_type)
<a name="72" id="anc72"></a><span class="line-modified">1561   {</span>
<span class="line-modified">1562     key.instance_type = g_type_parent (key.instance_type);</span>
<span class="line-modified">1563     cc = g_bsearch_array_lookup (bsa, &amp;g_class_closure_bconfig, &amp;key);</span>
<span class="line-modified">1564   }</span>
1565     }
1566   else
1567     cc = NULL;
1568   return cc;
1569 }
1570 
1571 static inline GClosure*
1572 signal_lookup_closure (SignalNode    *node,
<a name="73" id="anc73"></a><span class="line-modified">1573            GTypeInstance *instance)</span>
1574 {
1575   ClassClosure *cc;
1576 
1577   cc = signal_find_class_closure (node, G_TYPE_FROM_INSTANCE (instance));
1578   return cc ? cc-&gt;closure : NULL;
1579 }
1580 
1581 static void
1582 signal_add_class_closure (SignalNode *node,
<a name="74" id="anc74"></a><span class="line-modified">1583         GType       itype,</span>
<span class="line-modified">1584         GClosure   *closure)</span>
1585 {
1586   ClassClosure key;
1587 
1588   node-&gt;single_va_closure_is_valid = FALSE;
1589 
1590   if (!node-&gt;class_closure_bsa)
1591     node-&gt;class_closure_bsa = g_bsearch_array_create (&amp;g_class_closure_bconfig);
1592   key.instance_type = itype;
1593   key.closure = g_closure_ref (closure);
1594   node-&gt;class_closure_bsa = g_bsearch_array_insert (node-&gt;class_closure_bsa,
<a name="75" id="anc75"></a><span class="line-modified">1595                 &amp;g_class_closure_bconfig,</span>
<span class="line-modified">1596                 &amp;key);</span>
1597   g_closure_sink (closure);
1598   if (node-&gt;c_marshaller &amp;&amp; closure &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (closure))
1599     {
1600       g_closure_set_marshal (closure, node-&gt;c_marshaller);
1601       if (node-&gt;va_marshaller)
<a name="76" id="anc76"></a><span class="line-modified">1602   _g_closure_set_va_marshal (closure, node-&gt;va_marshaller);</span>
1603     }
1604 }
1605 
1606 /**
1607  * g_signal_newv:
1608  * @signal_name: the name for the signal
1609  * @itype: the type this signal pertains to. It will also pertain to
1610  *     types which are derived from this type
1611  * @signal_flags: a combination of #GSignalFlags specifying detail of when
1612  *     the default handler is to be invoked. You should at least specify
1613  *     %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST
1614  * @class_closure: (nullable): The closure to invoke on signal emission;
1615  *     may be %NULL
1616  * @accumulator: (nullable): the accumulator for this signal; may be %NULL
1617  * @accu_data: user data for the @accumulator
1618  * @c_marshaller: (nullable): the function to translate arrays of
1619  *     parameter values to signal emissions into C language callback
1620  *     invocations or %NULL
1621  * @return_type: the type of return value, or #G_TYPE_NONE for a signal
1622  *     without a return value
1623  * @n_params: the length of @param_types
1624  * @param_types: (array length=n_params): an array of types, one for
1625  *     each parameter
1626  *
1627  * Creates a new signal. (This is usually done in the class initializer.)
1628  *
1629  * See g_signal_new() for details on allowed signal names.
1630  *
1631  * If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
1632  * the marshaller for this signal.
1633  *
1634  * Returns: the signal id
1635  */
1636 guint
1637 g_signal_newv (const gchar       *signal_name,
1638                GType              itype,
1639                GSignalFlags       signal_flags,
1640                GClosure          *class_closure,
1641                GSignalAccumulator accumulator,
<a name="77" id="anc77"></a><span class="line-modified">1642          gpointer     accu_data,</span>
1643                GSignalCMarshaller c_marshaller,
<a name="78" id="anc78"></a><span class="line-modified">1644                GType      return_type,</span>
1645                guint              n_params,
<a name="79" id="anc79"></a><span class="line-modified">1646                GType     *param_types)</span>
1647 {
1648   gchar *name;
1649   guint signal_id, i;
1650   SignalNode *node;
1651   GSignalCMarshaller builtin_c_marshaller;
1652   GSignalCVaMarshaller builtin_va_marshaller;
1653   GSignalCVaMarshaller va_marshaller;
1654 
1655   g_return_val_if_fail (signal_name != NULL, 0);
1656   g_return_val_if_fail (G_TYPE_IS_INSTANTIATABLE (itype) || G_TYPE_IS_INTERFACE (itype), 0);
1657   if (n_params)
1658     g_return_val_if_fail (param_types != NULL, 0);
1659   g_return_val_if_fail ((return_type &amp; G_SIGNAL_TYPE_STATIC_SCOPE) == 0, 0);
1660   if (return_type == (G_TYPE_NONE &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
1661     g_return_val_if_fail (accumulator == NULL, 0);
1662   if (!accumulator)
1663     g_return_val_if_fail (accu_data == NULL, 0);
1664 
1665   name = g_strdup (signal_name);
1666   g_strdelimit (name, G_STR_DELIMITERS &quot;:^&quot;, &#39;_&#39;);  /* FIXME do character checks like for types */
1667 
1668   SIGNAL_LOCK ();
1669 
1670   signal_id = signal_id_lookup (g_quark_try_string (name), itype);
1671   node = LOOKUP_SIGNAL_NODE (signal_id);
1672   if (node &amp;&amp; !node-&gt;destroyed)
1673     {
1674       g_warning (G_STRLOC &quot;: signal \&quot;%s\&quot; already exists in the &#39;%s&#39; %s&quot;,
1675                  name,
1676                  type_debug_name (node-&gt;itype),
1677                  G_TYPE_IS_INTERFACE (node-&gt;itype) ? &quot;interface&quot; : &quot;class ancestry&quot;);
1678       g_free (name);
1679       SIGNAL_UNLOCK ();
1680       return 0;
1681     }
1682   if (node &amp;&amp; node-&gt;itype != itype)
1683     {
1684       g_warning (G_STRLOC &quot;: signal \&quot;%s\&quot; for type &#39;%s&#39; was previously created for type &#39;%s&#39;&quot;,
1685                  name,
1686                  type_debug_name (itype),
1687                  type_debug_name (node-&gt;itype));
1688       g_free (name);
1689       SIGNAL_UNLOCK ();
1690       return 0;
1691     }
1692   for (i = 0; i &lt; n_params; i++)
1693     if (!G_TYPE_IS_VALUE (param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
1694       {
<a name="80" id="anc80"></a><span class="line-modified">1695   g_warning (G_STRLOC &quot;: parameter %d of type &#39;%s&#39; for signal \&quot;%s::%s\&quot; is not a value type&quot;,</span>
<span class="line-modified">1696        i + 1, type_debug_name (param_types[i]), type_debug_name (itype), name);</span>
<span class="line-modified">1697   g_free (name);</span>
<span class="line-modified">1698   SIGNAL_UNLOCK ();</span>
<span class="line-modified">1699   return 0;</span>
1700       }
1701   if (return_type != G_TYPE_NONE &amp;&amp; !G_TYPE_IS_VALUE (return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
1702     {
1703       g_warning (G_STRLOC &quot;: return value of type &#39;%s&#39; for signal \&quot;%s::%s\&quot; is not a value type&quot;,
<a name="81" id="anc81"></a><span class="line-modified">1704      type_debug_name (return_type), type_debug_name (itype), name);</span>
1705       g_free (name);
1706       SIGNAL_UNLOCK ();
1707       return 0;
1708     }
1709   if (return_type != G_TYPE_NONE &amp;&amp;
1710       (signal_flags &amp; (G_SIGNAL_RUN_FIRST | G_SIGNAL_RUN_LAST | G_SIGNAL_RUN_CLEANUP)) == G_SIGNAL_RUN_FIRST)
1711     {
1712       g_warning (G_STRLOC &quot;: signal \&quot;%s::%s\&quot; has return type &#39;%s&#39; and is only G_SIGNAL_RUN_FIRST&quot;,
<a name="82" id="anc82"></a><span class="line-modified">1713      type_debug_name (itype), name, type_debug_name (return_type));</span>
1714       g_free (name);
1715       SIGNAL_UNLOCK ();
1716       return 0;
1717     }
1718 
1719   /* setup permanent portion of signal node */
1720   if (!node)
1721     {
1722       SignalKey key;
1723 
1724       signal_id = g_n_signal_nodes++;
1725       node = g_new (SignalNode, 1);
1726       node-&gt;signal_id = signal_id;
1727       g_signal_nodes = g_renew (SignalNode*, g_signal_nodes, g_n_signal_nodes);
1728       g_signal_nodes[signal_id] = node;
1729       node-&gt;itype = itype;
1730       node-&gt;name = name;
1731       key.itype = itype;
1732       key.quark = g_quark_from_string (node-&gt;name);
1733       key.signal_id = signal_id;
1734       g_signal_key_bsa = g_bsearch_array_insert (g_signal_key_bsa, &amp;g_signal_key_bconfig, &amp;key);
1735       g_strdelimit (name, &quot;_&quot;, &#39;-&#39;);
1736       node-&gt;name = g_intern_string (name);
1737       key.quark = g_quark_from_string (name);
1738       g_signal_key_bsa = g_bsearch_array_insert (g_signal_key_bsa, &amp;g_signal_key_bconfig, &amp;key);
1739 
1740       TRACE(GOBJECT_SIGNAL_NEW(signal_id, name, itype));
1741     }
1742   node-&gt;destroyed = FALSE;
1743 
1744   /* setup reinitializable portion */
1745   node-&gt;single_va_closure_is_valid = FALSE;
1746   node-&gt;flags = signal_flags &amp; G_SIGNAL_FLAGS_MASK;
1747   node-&gt;n_params = n_params;
1748   node-&gt;param_types = g_memdup (param_types, sizeof (GType) * n_params);
1749   node-&gt;return_type = return_type;
1750   node-&gt;class_closure_bsa = NULL;
1751   if (accumulator)
1752     {
1753       node-&gt;accumulator = g_new (SignalAccumulator, 1);
1754       node-&gt;accumulator-&gt;func = accumulator;
1755       node-&gt;accumulator-&gt;data = accu_data;
1756     }
1757   else
1758     node-&gt;accumulator = NULL;
1759 
1760   builtin_c_marshaller = NULL;
1761   builtin_va_marshaller = NULL;
1762 
1763   /* Pick up built-in va marshallers for standard types, and
1764      instead of generic marshaller if no marshaller specified */
1765   if (n_params == 0 &amp;&amp; return_type == G_TYPE_NONE)
1766     {
1767       builtin_c_marshaller = g_cclosure_marshal_VOID__VOID;
1768       builtin_va_marshaller = g_cclosure_marshal_VOID__VOIDv;
1769     }
1770   else if (n_params == 1 &amp;&amp; return_type == G_TYPE_NONE)
1771     {
1772 #define ADD_CHECK(__type__) \
1773       else if (g_type_is_a (param_types[0] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE, G_TYPE_ ##__type__))         \
<a name="83" id="anc83"></a><span class="line-modified">1774   {                                                                \</span>
<span class="line-modified">1775     builtin_c_marshaller = g_cclosure_marshal_VOID__ ## __type__;  \</span>
<span class="line-modified">1776     builtin_va_marshaller = g_cclosure_marshal_VOID__ ## __type__ ##v;     \</span>
<span class="line-modified">1777   }</span>
1778 
1779       if (0) {}
1780       ADD_CHECK (BOOLEAN)
1781       ADD_CHECK (CHAR)
1782       ADD_CHECK (UCHAR)
1783       ADD_CHECK (INT)
1784       ADD_CHECK (UINT)
1785       ADD_CHECK (LONG)
1786       ADD_CHECK (ULONG)
1787       ADD_CHECK (ENUM)
1788       ADD_CHECK (FLAGS)
1789       ADD_CHECK (FLOAT)
1790       ADD_CHECK (DOUBLE)
1791       ADD_CHECK (STRING)
1792       ADD_CHECK (PARAM)
1793       ADD_CHECK (BOXED)
1794       ADD_CHECK (POINTER)
1795       ADD_CHECK (OBJECT)
1796       ADD_CHECK (VARIANT)
1797     }
1798 
1799   if (c_marshaller == NULL)
1800     {
1801       if (builtin_c_marshaller)
1802         {
1803     c_marshaller = builtin_c_marshaller;
1804           va_marshaller = builtin_va_marshaller;
1805         }
1806       else
<a name="84" id="anc84"></a><span class="line-modified">1807   {</span>
<span class="line-modified">1808     c_marshaller = g_cclosure_marshal_generic;</span>
<span class="line-modified">1809     va_marshaller = g_cclosure_marshal_generic_va;</span>
<span class="line-modified">1810   }</span>
1811     }
1812   else
1813     va_marshaller = NULL;
1814 
1815   node-&gt;c_marshaller = c_marshaller;
1816   node-&gt;va_marshaller = va_marshaller;
1817   node-&gt;emission_hooks = NULL;
1818   if (class_closure)
1819     signal_add_class_closure (node, 0, class_closure);
1820 
1821   SIGNAL_UNLOCK ();
1822 
1823   g_free (name);
1824 
1825   return signal_id;
1826 }
1827 
1828 /**
1829  * g_signal_set_va_marshaller:
1830  * @signal_id: the signal id
1831  * @instance_type: the instance type on which to set the marshaller.
1832  * @va_marshaller: the marshaller to set.
1833  *
1834  * Change the #GSignalCVaMarshaller used for a given signal.  This is a
1835  * specialised form of the marshaller that can often be used for the
1836  * common case of a single connected signal handler and avoids the
1837  * overhead of #GValue.  Its use is optional.
1838  *
1839  * Since: 2.32
1840  */
1841 void
1842 g_signal_set_va_marshaller (guint              signal_id,
<a name="85" id="anc85"></a><span class="line-modified">1843           GType              instance_type,</span>
<span class="line-modified">1844           GSignalCVaMarshaller va_marshaller)</span>
1845 {
1846   SignalNode *node;
1847 
1848   g_return_if_fail (signal_id &gt; 0);
1849   g_return_if_fail (va_marshaller != NULL);
1850 
1851   SIGNAL_LOCK ();
1852   node = LOOKUP_SIGNAL_NODE (signal_id);
1853   if (node)
1854     {
1855       node-&gt;va_marshaller = va_marshaller;
1856       if (node-&gt;class_closure_bsa)
<a name="86" id="anc86"></a><span class="line-modified">1857   {</span>
<span class="line-modified">1858     ClassClosure *cc = g_bsearch_array_get_nth (node-&gt;class_closure_bsa, &amp;g_class_closure_bconfig, 0);</span>
<span class="line-modified">1859     if (cc-&gt;closure-&gt;marshal == node-&gt;c_marshaller)</span>
<span class="line-modified">1860       _g_closure_set_va_marshal (cc-&gt;closure, va_marshaller);</span>
<span class="line-modified">1861   }</span>
1862 
1863       node-&gt;single_va_closure_is_valid = FALSE;
1864     }
1865 
1866   SIGNAL_UNLOCK ();
1867 }
1868 
1869 
1870 /**
1871  * g_signal_new_valist:
1872  * @signal_name: the name for the signal
1873  * @itype: the type this signal pertains to. It will also pertain to
1874  *  types which are derived from this type.
1875  * @signal_flags: a combination of #GSignalFlags specifying detail of when
1876  *  the default handler is to be invoked. You should at least specify
1877  *  %G_SIGNAL_RUN_FIRST or %G_SIGNAL_RUN_LAST.
1878  * @class_closure: The closure to invoke on signal emission; may be %NULL.
1879  * @accumulator: the accumulator for this signal; may be %NULL.
1880  * @accu_data: user data for the @accumulator.
1881  * @c_marshaller: (nullable): the function to translate arrays of parameter
1882  *  values to signal emissions into C language callback invocations or %NULL.
1883  * @return_type: the type of return value, or #G_TYPE_NONE for a signal
1884  *  without a return value.
1885  * @n_params: the number of parameter types in @args.
1886  * @args: va_list of #GType, one for each parameter.
1887  *
1888  * Creates a new signal. (This is usually done in the class initializer.)
1889  *
1890  * See g_signal_new() for details on allowed signal names.
1891  *
1892  * If c_marshaller is %NULL, g_cclosure_marshal_generic() will be used as
1893  * the marshaller for this signal.
1894  *
1895  * Returns: the signal id
1896  */
1897 guint
1898 g_signal_new_valist (const gchar       *signal_name,
1899                      GType              itype,
1900                      GSignalFlags       signal_flags,
1901                      GClosure          *class_closure,
1902                      GSignalAccumulator accumulator,
<a name="87" id="anc87"></a><span class="line-modified">1903          gpointer   accu_data,</span>
1904                      GSignalCMarshaller c_marshaller,
1905                      GType              return_type,
1906                      guint              n_params,
1907                      va_list            args)
1908 {
1909   GType *param_types;
1910   guint i;
1911   guint signal_id;
1912 
1913   if (n_params &gt; 0)
1914     {
1915       param_types = g_new (GType, n_params);
1916 
1917       for (i = 0; i &lt; n_params; i++)
<a name="88" id="anc88"></a><span class="line-modified">1918   param_types[i] = va_arg (args, GType);</span>
1919     }
1920   else
1921     param_types = NULL;
1922 
1923   signal_id = g_signal_newv (signal_name, itype, signal_flags,
<a name="89" id="anc89"></a><span class="line-modified">1924            class_closure, accumulator, accu_data, c_marshaller,</span>
<span class="line-modified">1925            return_type, n_params, param_types);</span>
1926   g_free (param_types);
1927 
1928   return signal_id;
1929 }
1930 
1931 static void
1932 signal_destroy_R (SignalNode *signal_node)
1933 {
1934   SignalNode node = *signal_node;
1935 
1936   signal_node-&gt;destroyed = TRUE;
1937 
1938   /* reentrancy caution, zero out real contents first */
1939   signal_node-&gt;single_va_closure_is_valid = FALSE;
1940   signal_node-&gt;n_params = 0;
1941   signal_node-&gt;param_types = NULL;
1942   signal_node-&gt;return_type = 0;
1943   signal_node-&gt;class_closure_bsa = NULL;
1944   signal_node-&gt;accumulator = NULL;
1945   signal_node-&gt;c_marshaller = NULL;
1946   signal_node-&gt;va_marshaller = NULL;
1947   signal_node-&gt;emission_hooks = NULL;
1948 
1949 #ifdef  G_ENABLE_DEBUG
1950   /* check current emissions */
1951   {
1952     Emission *emission;
1953 
1954     for (emission = g_emissions; emission; emission = emission-&gt;next)
1955       if (emission-&gt;ihint.signal_id == node.signal_id)
1956         g_critical (G_STRLOC &quot;: signal \&quot;%s\&quot; being destroyed is currently in emission (instance &#39;%p&#39;)&quot;,
1957                     node.name, emission-&gt;instance);
1958   }
1959 #endif
1960 
1961   /* free contents that need to
1962    */
1963   SIGNAL_UNLOCK ();
1964   g_free (node.param_types);
1965   if (node.class_closure_bsa)
1966     {
1967       guint i;
1968 
1969       for (i = 0; i &lt; node.class_closure_bsa-&gt;n_nodes; i++)
<a name="90" id="anc90"></a><span class="line-modified">1970   {</span>
<span class="line-modified">1971     ClassClosure *cc = g_bsearch_array_get_nth (node.class_closure_bsa, &amp;g_class_closure_bconfig, i);</span>
1972 
<a name="91" id="anc91"></a><span class="line-modified">1973     g_closure_unref (cc-&gt;closure);</span>
<span class="line-modified">1974   }</span>
1975       g_bsearch_array_free (node.class_closure_bsa, &amp;g_class_closure_bconfig);
1976     }
1977   g_free (node.accumulator);
1978   if (node.emission_hooks)
1979     {
1980       g_hook_list_clear (node.emission_hooks);
1981       g_free (node.emission_hooks);
1982     }
1983   SIGNAL_LOCK ();
1984 }
1985 
1986 /**
1987  * g_signal_override_class_closure:
1988  * @signal_id: the signal id
1989  * @instance_type: the instance type on which to override the class closure
1990  *  for the signal.
1991  * @class_closure: the closure.
1992  *
1993  * Overrides the class closure (i.e. the default handler) for the given signal
1994  * for emissions on instances of @instance_type. @instance_type must be derived
1995  * from the type to which the signal belongs.
1996  *
1997  * See g_signal_chain_from_overridden() and
1998  * g_signal_chain_from_overridden_handler() for how to chain up to the
1999  * parent class closure from inside the overridden one.
2000  */
2001 void
2002 g_signal_override_class_closure (guint     signal_id,
<a name="92" id="anc92"></a><span class="line-modified">2003          GType     instance_type,</span>
<span class="line-modified">2004          GClosure *class_closure)</span>
2005 {
2006   SignalNode *node;
2007 
2008   g_return_if_fail (signal_id &gt; 0);
2009   g_return_if_fail (class_closure != NULL);
2010 
2011   SIGNAL_LOCK ();
2012   node = LOOKUP_SIGNAL_NODE (signal_id);
2013   node_check_deprecated (node);
2014 #ifndef GSTREAMER_LITE
2015   if (!g_type_is_a (instance_type, node-&gt;itype))
2016 #else // GSTREAMER_LITE
2017   if (node == NULL || !g_type_is_a (instance_type, node-&gt;itype))
2018 #endif // GSTREAMER_LITE
2019     g_warning (&quot;%s: type &#39;%s&#39; cannot be overridden for signal id &#39;%u&#39;&quot;, G_STRLOC, type_debug_name (instance_type), signal_id);
2020   else
2021     {
2022       ClassClosure *cc = signal_find_class_closure (node, instance_type);
2023 
2024       if (cc &amp;&amp; cc-&gt;instance_type == instance_type)
<a name="93" id="anc93"></a><span class="line-modified">2025   g_warning (&quot;%s: type &#39;%s&#39; is already overridden for signal id &#39;%u&#39;&quot;, G_STRLOC, type_debug_name (instance_type), signal_id);</span>
2026       else
<a name="94" id="anc94"></a><span class="line-modified">2027   signal_add_class_closure (node, instance_type, class_closure);</span>
2028     }
2029   SIGNAL_UNLOCK ();
2030 }
2031 
2032 /**
2033  * g_signal_override_class_handler:
2034  * @signal_name: the name for the signal
2035  * @instance_type: the instance type on which to override the class handler
2036  *  for the signal.
2037  * @class_handler: the handler.
2038  *
2039  * Overrides the class closure (i.e. the default handler) for the
2040  * given signal for emissions on instances of @instance_type with
2041  * callback @class_handler. @instance_type must be derived from the
2042  * type to which the signal belongs.
2043  *
2044  * See g_signal_chain_from_overridden() and
2045  * g_signal_chain_from_overridden_handler() for how to chain up to the
2046  * parent class closure from inside the overridden one.
2047  *
2048  * Since: 2.18
2049  */
2050 void
2051 g_signal_override_class_handler (const gchar *signal_name,
<a name="95" id="anc95"></a><span class="line-modified">2052          GType        instance_type,</span>
<span class="line-modified">2053          GCallback    class_handler)</span>
2054 {
2055   guint signal_id;
2056 
2057   g_return_if_fail (signal_name != NULL);
2058   g_return_if_fail (instance_type != G_TYPE_NONE);
2059   g_return_if_fail (class_handler != NULL);
2060 
2061   signal_id = g_signal_lookup (signal_name, instance_type);
2062 
2063   if (signal_id)
2064     g_signal_override_class_closure (signal_id, instance_type,
2065                                      g_cclosure_new (class_handler, NULL, NULL));
2066   else
2067     g_warning (&quot;%s: signal name &#39;%s&#39; is invalid for type id &#39;%&quot;G_GSIZE_FORMAT&quot;&#39;&quot;,
2068                G_STRLOC, signal_name, instance_type);
2069 
2070 }
2071 
2072 /**
2073  * g_signal_chain_from_overridden:
2074  * @instance_and_params: (array) the argument list of the signal emission.
2075  *  The first element in the array is a #GValue for the instance the signal
2076  *  is being emitted on. The rest are any arguments to be passed to the signal.
2077  * @return_value: Location for the return value.
2078  *
2079  * Calls the original class closure of a signal. This function should only
2080  * be called from an overridden class closure; see
2081  * g_signal_override_class_closure() and
2082  * g_signal_override_class_handler().
2083  */
2084 void
2085 g_signal_chain_from_overridden (const GValue *instance_and_params,
<a name="96" id="anc96"></a><span class="line-modified">2086         GValue       *return_value)</span>
2087 {
2088   GType chain_type = 0, restore_type = 0;
2089   Emission *emission = NULL;
2090   GClosure *closure = NULL;
2091   guint n_params = 0;
2092   gpointer instance;
2093 
2094   g_return_if_fail (instance_and_params != NULL);
2095   instance = g_value_peek_pointer (instance_and_params);
2096   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
2097 
2098   SIGNAL_LOCK ();
2099   emission = emission_find_innermost (instance);
2100   if (emission)
2101     {
2102       SignalNode *node = LOOKUP_SIGNAL_NODE (emission-&gt;ihint.signal_id);
2103 
2104       g_assert (node != NULL);  /* paranoid */
2105 
2106       /* we should probably do the same parameter checks as g_signal_emit() here.
2107        */
2108       if (emission-&gt;chain_type != G_TYPE_NONE)
<a name="97" id="anc97"></a><span class="line-modified">2109   {</span>
<span class="line-modified">2110     ClassClosure *cc = signal_find_class_closure (node, emission-&gt;chain_type);</span>
2111 
<a name="98" id="anc98"></a><span class="line-modified">2112     g_assert (cc != NULL);  /* closure currently in call stack */</span>
2113 
<a name="99" id="anc99"></a><span class="line-modified">2114     n_params = node-&gt;n_params;</span>
<span class="line-modified">2115     restore_type = cc-&gt;instance_type;</span>
<span class="line-modified">2116     cc = signal_find_class_closure (node, g_type_parent (cc-&gt;instance_type));</span>
<span class="line-modified">2117     if (cc &amp;&amp; cc-&gt;instance_type != restore_type)</span>
<span class="line-modified">2118       {</span>
<span class="line-modified">2119         closure = cc-&gt;closure;</span>
<span class="line-modified">2120         chain_type = cc-&gt;instance_type;</span>
<span class="line-modified">2121       }</span>
<span class="line-modified">2122   }</span>
2123       else
<a name="100" id="anc100"></a><span class="line-modified">2124   g_warning (&quot;%s: signal id &#39;%u&#39; cannot be chained from current emission stage for instance &#39;%p&#39;&quot;, G_STRLOC, node-&gt;signal_id, instance);</span>
2125     }
2126   else
2127     g_warning (&quot;%s: no signal is currently being emitted for instance &#39;%p&#39;&quot;, G_STRLOC, instance);
2128 
2129   if (closure)
2130     {
2131       emission-&gt;chain_type = chain_type;
2132       SIGNAL_UNLOCK ();
2133       g_closure_invoke (closure,
<a name="101" id="anc101"></a><span class="line-modified">2134       return_value,</span>
<span class="line-modified">2135       n_params + 1,</span>
<span class="line-modified">2136       instance_and_params,</span>
<span class="line-modified">2137       &amp;emission-&gt;ihint);</span>
2138       SIGNAL_LOCK ();
2139       emission-&gt;chain_type = restore_type;
2140     }
2141   SIGNAL_UNLOCK ();
2142 }
2143 
2144 /**
2145  * g_signal_chain_from_overridden_handler: (skip)
2146  * @instance: (type GObject.TypeInstance): the instance the signal is being
2147  *    emitted on.
2148  * @...: parameters to be passed to the parent class closure, followed by a
2149  *  location for the return value. If the return type of the signal
2150  *  is #G_TYPE_NONE, the return value location can be omitted.
2151  *
2152  * Calls the original class closure of a signal. This function should
2153  * only be called from an overridden class closure; see
2154  * g_signal_override_class_closure() and
2155  * g_signal_override_class_handler().
2156  *
2157  * Since: 2.18
2158  */
2159 void
2160 g_signal_chain_from_overridden_handler (gpointer instance,
2161                                         ...)
2162 {
2163   GType chain_type = 0, restore_type = 0;
2164   Emission *emission = NULL;
2165   GClosure *closure = NULL;
2166   SignalNode *node;
2167   guint n_params = 0;
2168 
2169   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
2170 
2171   SIGNAL_LOCK ();
2172   emission = emission_find_innermost (instance);
2173   if (emission)
2174     {
2175       node = LOOKUP_SIGNAL_NODE (emission-&gt;ihint.signal_id);
2176 
2177       g_assert (node != NULL);  /* paranoid */
2178 
2179       /* we should probably do the same parameter checks as g_signal_emit() here.
2180        */
2181       if (emission-&gt;chain_type != G_TYPE_NONE)
<a name="102" id="anc102"></a><span class="line-modified">2182   {</span>
<span class="line-modified">2183     ClassClosure *cc = signal_find_class_closure (node, emission-&gt;chain_type);</span>
2184 
<a name="103" id="anc103"></a><span class="line-modified">2185     g_assert (cc != NULL);  /* closure currently in call stack */</span>
2186 
<a name="104" id="anc104"></a><span class="line-modified">2187     n_params = node-&gt;n_params;</span>
<span class="line-modified">2188     restore_type = cc-&gt;instance_type;</span>
<span class="line-modified">2189     cc = signal_find_class_closure (node, g_type_parent (cc-&gt;instance_type));</span>
<span class="line-modified">2190     if (cc &amp;&amp; cc-&gt;instance_type != restore_type)</span>
<span class="line-modified">2191       {</span>
<span class="line-modified">2192         closure = cc-&gt;closure;</span>
<span class="line-modified">2193         chain_type = cc-&gt;instance_type;</span>
<span class="line-modified">2194       }</span>
<span class="line-modified">2195   }</span>
2196       else
<a name="105" id="anc105"></a><span class="line-modified">2197   g_warning (&quot;%s: signal id &#39;%u&#39; cannot be chained from current emission stage for instance &#39;%p&#39;&quot;, G_STRLOC, node-&gt;signal_id, instance);</span>
2198     }
2199   else
2200     g_warning (&quot;%s: no signal is currently being emitted for instance &#39;%p&#39;&quot;, G_STRLOC, instance);
2201 
2202   if (closure)
2203     {
2204       GValue *instance_and_params;
2205       GType signal_return_type;
2206       GValue *param_values;
2207       va_list var_args;
2208       guint i;
2209 
2210       va_start (var_args, instance);
2211 
2212       signal_return_type = node-&gt;return_type;
2213       instance_and_params = g_alloca (sizeof (GValue) * (n_params + 1));
2214       memset (instance_and_params, 0, sizeof (GValue) * (n_params + 1));
2215       param_values = instance_and_params + 1;
2216 
2217       for (i = 0; i &lt; node-&gt;n_params; i++)
2218         {
2219           gchar *error;
2220           GType ptype = node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
2221           gboolean static_scope = node-&gt;param_types[i] &amp; G_SIGNAL_TYPE_STATIC_SCOPE;
2222 
2223           SIGNAL_UNLOCK ();
2224           G_VALUE_COLLECT_INIT (param_values + i, ptype,
<a name="106" id="anc106"></a><span class="line-modified">2225         var_args,</span>
<span class="line-modified">2226         static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="line-modified">2227         &amp;error);</span>
2228           if (error)
2229             {
2230               g_warning (&quot;%s: %s&quot;, G_STRLOC, error);
2231               g_free (error);
2232 
2233               /* we purposely leak the value here, it might not be
2234                * in a sane state if an error condition occoured
2235                */
2236               while (i--)
2237                 g_value_unset (param_values + i);
2238 
2239               va_end (var_args);
2240               return;
2241             }
2242           SIGNAL_LOCK ();
2243         }
2244 
2245       SIGNAL_UNLOCK ();
2246       instance_and_params-&gt;g_type = 0;
2247       g_value_init_from_instance (instance_and_params, instance);
2248       SIGNAL_LOCK ();
2249 
2250       emission-&gt;chain_type = chain_type;
2251       SIGNAL_UNLOCK ();
2252 
2253       if (signal_return_type == G_TYPE_NONE)
2254         {
2255           g_closure_invoke (closure,
2256                             NULL,
2257                             n_params + 1,
2258                             instance_and_params,
2259                             &amp;emission-&gt;ihint);
2260         }
2261       else
2262         {
2263           GValue return_value = G_VALUE_INIT;
2264           gchar *error = NULL;
2265           GType rtype = signal_return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
2266           gboolean static_scope = signal_return_type &amp; G_SIGNAL_TYPE_STATIC_SCOPE;
2267 
2268           g_value_init (&amp;return_value, rtype);
2269 
2270           g_closure_invoke (closure,
2271                             &amp;return_value,
2272                             n_params + 1,
2273                             instance_and_params,
2274                             &amp;emission-&gt;ihint);
2275 
2276           G_VALUE_LCOPY (&amp;return_value,
2277                          var_args,
2278                          static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,
2279                          &amp;error);
2280           if (!error)
2281             {
2282               g_value_unset (&amp;return_value);
2283             }
2284           else
2285             {
2286               g_warning (&quot;%s: %s&quot;, G_STRLOC, error);
2287               g_free (error);
2288 
2289               /* we purposely leak the value here, it might not be
2290                * in a sane state if an error condition occurred
2291                */
2292             }
2293         }
2294 
2295       for (i = 0; i &lt; n_params; i++)
2296         g_value_unset (param_values + i);
2297       g_value_unset (instance_and_params);
2298 
2299       va_end (var_args);
2300 
2301       SIGNAL_LOCK ();
2302       emission-&gt;chain_type = restore_type;
2303     }
2304   SIGNAL_UNLOCK ();
2305 }
2306 
2307 /**
2308  * g_signal_get_invocation_hint:
2309  * @instance: (type GObject.Object): the instance to query
2310  *
2311  * Returns the invocation hint of the innermost signal emission of instance.
2312  *
2313  * Returns: (transfer none): the invocation hint of the innermost signal  emission.
2314  */
2315 GSignalInvocationHint*
2316 g_signal_get_invocation_hint (gpointer instance)
2317 {
2318   Emission *emission = NULL;
2319 
2320   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), NULL);
2321 
2322   SIGNAL_LOCK ();
2323   emission = emission_find_innermost (instance);
2324   SIGNAL_UNLOCK ();
2325 
2326   return emission ? &amp;emission-&gt;ihint : NULL;
2327 }
2328 
2329 /**
2330  * g_signal_connect_closure_by_id:
2331  * @instance: (type GObject.Object): the instance to connect to.
2332  * @signal_id: the id of the signal.
2333  * @detail: the detail.
2334  * @closure: the closure to connect.
2335  * @after: whether the handler should be called before or after the
2336  *  default handler of the signal.
2337  *
2338  * Connects a closure to a signal for a particular object.
2339  *
2340  * Returns: the handler ID (always greater than 0 for successful connections)
2341  */
2342 gulong
2343 g_signal_connect_closure_by_id (gpointer  instance,
<a name="107" id="anc107"></a><span class="line-modified">2344         guint     signal_id,</span>
<span class="line-modified">2345         GQuark    detail,</span>
<span class="line-modified">2346         GClosure *closure,</span>
<span class="line-modified">2347         gboolean  after)</span>
2348 {
2349   SignalNode *node;
2350   gulong handler_seq_no = 0;
2351 
2352   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
2353   g_return_val_if_fail (signal_id &gt; 0, 0);
2354   g_return_val_if_fail (closure != NULL, 0);
2355 
2356   SIGNAL_LOCK ();
2357   node = LOOKUP_SIGNAL_NODE (signal_id);
2358   if (node)
2359     {
2360       if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
<a name="108" id="anc108"></a><span class="line-modified">2361   g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);</span>
2362       else if (!g_type_is_a (G_TYPE_FROM_INSTANCE (instance), node-&gt;itype))
<a name="109" id="anc109"></a><span class="line-modified">2363   g_warning (&quot;%s: signal id &#39;%u&#39; is invalid for instance &#39;%p&#39;&quot;, G_STRLOC, signal_id, instance);</span>
2364       else
<a name="110" id="anc110"></a><span class="line-modified">2365   {</span>
<span class="line-modified">2366     Handler *handler = handler_new (signal_id, instance, after);</span>
<span class="line-modified">2367 </span>
<span class="line-modified">2368     handler_seq_no = handler-&gt;sequential_number;</span>
<span class="line-modified">2369     handler-&gt;detail = detail;</span>
<span class="line-modified">2370     handler-&gt;closure = g_closure_ref (closure);</span>
<span class="line-modified">2371     g_closure_sink (closure);</span>
<span class="line-modified">2372     add_invalid_closure_notify (handler, instance);</span>
<span class="line-modified">2373     handler_insert (signal_id, instance, handler);</span>
<span class="line-modified">2374     if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (closure))</span>
<span class="line-modified">2375       {</span>
<span class="line-modified">2376         g_closure_set_marshal (closure, node-&gt;c_marshaller);</span>
<span class="line-modified">2377         if (node-&gt;va_marshaller)</span>
<span class="line-modified">2378     _g_closure_set_va_marshal (closure, node-&gt;va_marshaller);</span>
<span class="line-modified">2379       }</span>
<span class="line-modified">2380   }</span>
2381     }
2382   else
2383     g_warning (&quot;%s: signal id &#39;%u&#39; is invalid for instance &#39;%p&#39;&quot;, G_STRLOC, signal_id, instance);
2384   SIGNAL_UNLOCK ();
2385 
2386   return handler_seq_no;
2387 }
2388 
2389 /**
2390  * g_signal_connect_closure:
2391  * @instance: (type GObject.Object): the instance to connect to.
2392  * @detailed_signal: a string of the form &quot;signal-name::detail&quot;.
2393  * @closure: the closure to connect.
2394  * @after: whether the handler should be called before or after the
2395  *  default handler of the signal.
2396  *
2397  * Connects a closure to a signal for a particular object.
2398  *
2399  * Returns: the handler ID (always greater than 0 for successful connections)
2400  */
2401 gulong
2402 g_signal_connect_closure (gpointer     instance,
<a name="111" id="anc111"></a><span class="line-modified">2403         const gchar *detailed_signal,</span>
<span class="line-modified">2404         GClosure    *closure,</span>
<span class="line-modified">2405         gboolean     after)</span>
2406 {
2407   guint signal_id;
2408   gulong handler_seq_no = 0;
2409   GQuark detail = 0;
2410   GType itype;
2411 
2412   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
2413   g_return_val_if_fail (detailed_signal != NULL, 0);
2414   g_return_val_if_fail (closure != NULL, 0);
2415 
2416   SIGNAL_LOCK ();
2417   itype = G_TYPE_FROM_INSTANCE (instance);
2418   signal_id = signal_parse_name (detailed_signal, itype, &amp;detail, TRUE);
2419   if (signal_id)
2420     {
2421       SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
2422 
2423       if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
<a name="112" id="anc112"></a><span class="line-modified">2424   g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);</span>
2425       else if (!g_type_is_a (itype, node-&gt;itype))
2426         g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
2427                    G_STRLOC, detailed_signal, instance, g_type_name (itype));
2428       else
<a name="113" id="anc113"></a><span class="line-modified">2429   {</span>
<span class="line-modified">2430     Handler *handler = handler_new (signal_id, instance, after);</span>
<span class="line-modified">2431 </span>
<span class="line-modified">2432     handler_seq_no = handler-&gt;sequential_number;</span>
<span class="line-modified">2433     handler-&gt;detail = detail;</span>
<span class="line-modified">2434     handler-&gt;closure = g_closure_ref (closure);</span>
<span class="line-modified">2435     g_closure_sink (closure);</span>
<span class="line-modified">2436     add_invalid_closure_notify (handler, instance);</span>
<span class="line-modified">2437     handler_insert (signal_id, instance, handler);</span>
<span class="line-modified">2438     if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (handler-&gt;closure))</span>
<span class="line-modified">2439       {</span>
<span class="line-modified">2440         g_closure_set_marshal (handler-&gt;closure, node-&gt;c_marshaller);</span>
<span class="line-modified">2441         if (node-&gt;va_marshaller)</span>
<span class="line-modified">2442     _g_closure_set_va_marshal (handler-&gt;closure, node-&gt;va_marshaller);</span>
<span class="line-modified">2443       }</span>
<span class="line-modified">2444   }</span>
2445     }
2446   else
2447     g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
2448                G_STRLOC, detailed_signal, instance, g_type_name (itype));
2449   SIGNAL_UNLOCK ();
2450 
2451   return handler_seq_no;
2452 }
2453 
2454 static void
2455 node_check_deprecated (const SignalNode *node)
2456 {
2457   static const gchar * g_enable_diagnostic = NULL;
2458 
2459   if (G_UNLIKELY (!g_enable_diagnostic))
2460     {
2461       g_enable_diagnostic = g_getenv (&quot;G_ENABLE_DIAGNOSTIC&quot;);
2462       if (!g_enable_diagnostic)
2463         g_enable_diagnostic = &quot;0&quot;;
2464     }
2465 
2466   if (g_enable_diagnostic[0] == &#39;1&#39;)
2467     {
2468       if (node-&gt;flags &amp; G_SIGNAL_DEPRECATED)
2469         {
2470           g_warning (&quot;The signal %s::%s is deprecated and shouldn&#39;t be used &quot;
2471                      &quot;anymore. It will be removed in a future version.&quot;,
2472                      type_debug_name (node-&gt;itype), node-&gt;name);
2473         }
2474     }
2475 }
2476 
2477 /**
2478  * g_signal_connect_data:
2479  * @instance: (type GObject.Object): the instance to connect to.
2480  * @detailed_signal: a string of the form &quot;signal-name::detail&quot;.
2481  * @c_handler: the #GCallback to connect.
2482  * @data: data to pass to @c_handler calls.
2483  * @destroy_data: a #GClosureNotify for @data.
2484  * @connect_flags: a combination of #GConnectFlags.
2485  *
2486  * Connects a #GCallback function to a signal for a particular object. Similar
2487  * to g_signal_connect(), but allows to provide a #GClosureNotify for the data
2488  * which will be called when the signal handler is disconnected and no longer
2489  * used. Specify @connect_flags if you need `..._after()` or
2490  * `..._swapped()` variants of this function.
2491  *
2492  * Returns: the handler ID (always greater than 0 for successful connections)
2493  */
2494 gulong
2495 g_signal_connect_data (gpointer       instance,
<a name="114" id="anc114"></a><span class="line-modified">2496            const gchar   *detailed_signal,</span>
<span class="line-modified">2497            GCallback      c_handler,</span>
<span class="line-modified">2498            gpointer       data,</span>
<span class="line-modified">2499            GClosureNotify destroy_data,</span>
<span class="line-modified">2500            GConnectFlags  connect_flags)</span>
2501 {
2502   guint signal_id;
2503   gulong handler_seq_no = 0;
2504   GQuark detail = 0;
2505   GType itype;
2506   gboolean swapped, after;
2507 
2508   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
2509   g_return_val_if_fail (detailed_signal != NULL, 0);
2510   g_return_val_if_fail (c_handler != NULL, 0);
2511 
2512   swapped = (connect_flags &amp; G_CONNECT_SWAPPED) != FALSE;
2513   after = (connect_flags &amp; G_CONNECT_AFTER) != FALSE;
2514 
2515   SIGNAL_LOCK ();
2516   itype = G_TYPE_FROM_INSTANCE (instance);
2517   signal_id = signal_parse_name (detailed_signal, itype, &amp;detail, TRUE);
2518   if (signal_id)
2519     {
2520       SignalNode *node = LOOKUP_SIGNAL_NODE (signal_id);
2521 
2522       node_check_deprecated (node);
2523 
2524       if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
<a name="115" id="anc115"></a><span class="line-modified">2525   g_warning (&quot;%s: signal &#39;%s&#39; does not support details&quot;, G_STRLOC, detailed_signal);</span>
2526       else if (!g_type_is_a (itype, node-&gt;itype))
2527         g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
2528                    G_STRLOC, detailed_signal, instance, g_type_name (itype));
2529       else
<a name="116" id="anc116"></a><span class="line-modified">2530   {</span>
<span class="line-modified">2531     Handler *handler = handler_new (signal_id, instance, after);</span>
<span class="line-modified">2532 </span>
<span class="line-modified">2533     handler_seq_no = handler-&gt;sequential_number;</span>
<span class="line-modified">2534     handler-&gt;detail = detail;</span>
<span class="line-modified">2535     handler-&gt;closure = g_closure_ref ((swapped ? g_cclosure_new_swap : g_cclosure_new) (c_handler, data, destroy_data));</span>
<span class="line-modified">2536     g_closure_sink (handler-&gt;closure);</span>
<span class="line-modified">2537     handler_insert (signal_id, instance, handler);</span>
<span class="line-modified">2538     if (node-&gt;c_marshaller &amp;&amp; G_CLOSURE_NEEDS_MARSHAL (handler-&gt;closure))</span>
<span class="line-modified">2539       {</span>
<span class="line-modified">2540         g_closure_set_marshal (handler-&gt;closure, node-&gt;c_marshaller);</span>
<span class="line-modified">2541         if (node-&gt;va_marshaller)</span>
<span class="line-modified">2542     _g_closure_set_va_marshal (handler-&gt;closure, node-&gt;va_marshaller);</span>
<span class="line-modified">2543       }</span>
2544         }
2545     }
2546   else
2547     g_warning (&quot;%s: signal &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
2548                G_STRLOC, detailed_signal, instance, g_type_name (itype));
2549   SIGNAL_UNLOCK ();
2550 
2551   return handler_seq_no;
2552 }
2553 
2554 /**
2555  * g_signal_handler_block:
2556  * @instance: (type GObject.Object): The instance to block the signal handler of.
2557  * @handler_id: Handler id of the handler to be blocked.
2558  *
2559  * Blocks a handler of an instance so it will not be called during any
2560  * signal emissions unless it is unblocked again. Thus &quot;blocking&quot; a
2561  * signal handler means to temporarily deactive it, a signal handler
2562  * has to be unblocked exactly the same amount of times it has been
2563  * blocked before to become active again.
2564  *
2565  * The @handler_id has to be a valid signal handler id, connected to a
2566  * signal of @instance.
2567  */
2568 void
2569 g_signal_handler_block (gpointer instance,
2570                         gulong   handler_id)
2571 {
2572   Handler *handler;
2573 
2574   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
2575   g_return_if_fail (handler_id &gt; 0);
2576 
2577   SIGNAL_LOCK ();
2578   handler = handler_lookup (instance, handler_id, NULL, NULL);
2579   if (handler)
2580     {
2581 #ifndef G_DISABLE_CHECKS
2582       if (handler-&gt;block_count &gt;= HANDLER_MAX_BLOCK_COUNT - 1)
2583         g_error (G_STRLOC &quot;: handler block_count overflow, %s&quot;, REPORT_BUG);
2584 #endif
2585       handler-&gt;block_count += 1;
2586     }
2587   else
2588     g_warning (&quot;%s: instance &#39;%p&#39; has no handler with id &#39;%lu&#39;&quot;, G_STRLOC, instance, handler_id);
2589   SIGNAL_UNLOCK ();
2590 }
2591 
2592 /**
2593  * g_signal_handler_unblock:
2594  * @instance: (type GObject.Object): The instance to unblock the signal handler of.
2595  * @handler_id: Handler id of the handler to be unblocked.
2596  *
2597  * Undoes the effect of a previous g_signal_handler_block() call.  A
2598  * blocked handler is skipped during signal emissions and will not be
2599  * invoked, unblocking it (for exactly the amount of times it has been
2600  * blocked before) reverts its &quot;blocked&quot; state, so the handler will be
2601  * recognized by the signal system and is called upon future or
2602  * currently ongoing signal emissions (since the order in which
2603  * handlers are called during signal emissions is deterministic,
2604  * whether the unblocked handler in question is called as part of a
2605  * currently ongoing emission depends on how far that emission has
2606  * proceeded yet).
2607  *
2608  * The @handler_id has to be a valid id of a signal handler that is
2609  * connected to a signal of @instance and is currently blocked.
2610  */
2611 void
2612 g_signal_handler_unblock (gpointer instance,
2613                           gulong   handler_id)
2614 {
2615   Handler *handler;
2616 
2617   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
2618   g_return_if_fail (handler_id &gt; 0);
2619 
2620   SIGNAL_LOCK ();
2621   handler = handler_lookup (instance, handler_id, NULL, NULL);
2622   if (handler)
2623     {
2624       if (handler-&gt;block_count)
2625         handler-&gt;block_count -= 1;
2626       else
2627         g_warning (G_STRLOC &quot;: handler &#39;%lu&#39; of instance &#39;%p&#39; is not blocked&quot;, handler_id, instance);
2628     }
2629   else
2630     g_warning (&quot;%s: instance &#39;%p&#39; has no handler with id &#39;%lu&#39;&quot;, G_STRLOC, instance, handler_id);
2631   SIGNAL_UNLOCK ();
2632 }
2633 
2634 /**
2635  * g_signal_handler_disconnect:
2636  * @instance: (type GObject.Object): The instance to remove the signal handler from.
2637  * @handler_id: Handler id of the handler to be disconnected.
2638  *
2639  * Disconnects a handler from an instance so it will not be called during
2640  * any future or currently ongoing emissions of the signal it has been
2641  * connected to. The @handler_id becomes invalid and may be reused.
2642  *
2643  * The @handler_id has to be a valid signal handler id, connected to a
2644  * signal of @instance.
2645  */
2646 void
2647 g_signal_handler_disconnect (gpointer instance,
2648                              gulong   handler_id)
2649 {
2650   Handler *handler;
2651 
2652   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
2653   g_return_if_fail (handler_id &gt; 0);
2654 
2655   SIGNAL_LOCK ();
2656   handler = handler_lookup (instance, handler_id, 0, 0);
2657   if (handler)
2658     {
2659       g_hash_table_remove (g_handlers, handler);
2660       handler-&gt;sequential_number = 0;
2661       handler-&gt;block_count = 1;
2662       remove_invalid_closure_notify (handler, instance);
2663       handler_unref_R (handler-&gt;signal_id, instance, handler);
2664     }
2665   else
2666     g_warning (&quot;%s: instance &#39;%p&#39; has no handler with id &#39;%lu&#39;&quot;, G_STRLOC, instance, handler_id);
2667   SIGNAL_UNLOCK ();
2668 }
2669 
2670 /**
2671  * g_signal_handler_is_connected:
2672  * @instance: (type GObject.Object): The instance where a signal handler is sought.
2673  * @handler_id: the handler ID.
2674  *
2675  * Returns whether @handler_id is the ID of a handler connected to @instance.
2676  *
2677  * Returns: whether @handler_id identifies a handler connected to @instance.
2678  */
2679 gboolean
2680 g_signal_handler_is_connected (gpointer instance,
<a name="117" id="anc117"></a><span class="line-modified">2681              gulong   handler_id)</span>
2682 {
2683   Handler *handler;
2684   gboolean connected;
2685 
2686   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), FALSE);
2687 
2688   SIGNAL_LOCK ();
2689   handler = handler_lookup (instance, handler_id, NULL, NULL);
2690   connected = handler != NULL;
2691   SIGNAL_UNLOCK ();
2692 
2693   return connected;
2694 }
2695 
2696 /**
2697  * g_signal_handlers_destroy:
2698  * @instance: (type GObject.Object): The instance whose signal handlers are destroyed
2699  *
2700  * Destroy all signal handlers of a type instance. This function is
2701  * an implementation detail of the #GObject dispose implementation,
2702  * and should not be used outside of the type system.
2703  */
2704 void
2705 g_signal_handlers_destroy (gpointer instance)
2706 {
2707   GBSearchArray *hlbsa;
2708 
2709   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
2710 
2711   SIGNAL_LOCK ();
2712   hlbsa = g_hash_table_lookup (g_handler_list_bsa_ht, instance);
2713   if (hlbsa)
2714     {
2715       guint i;
2716 
2717       /* reentrancy caution, delete instance trace first */
2718       g_hash_table_remove (g_handler_list_bsa_ht, instance);
2719 
2720       for (i = 0; i &lt; hlbsa-&gt;n_nodes; i++)
2721         {
2722           HandlerList *hlist = g_bsearch_array_get_nth (hlbsa, &amp;g_signal_hlbsa_bconfig, i);
2723           Handler *handler = hlist-&gt;handlers;
2724 
2725           while (handler)
2726             {
2727               Handler *tmp = handler;
2728 
2729               handler = tmp-&gt;next;
2730               tmp-&gt;block_count = 1;
2731               /* cruel unlink, this works because _all_ handlers vanish */
2732               tmp-&gt;next = NULL;
2733               tmp-&gt;prev = tmp;
2734               if (tmp-&gt;sequential_number)
<a name="118" id="anc118"></a><span class="line-modified">2735     {</span>
2736                   g_hash_table_remove (g_handlers, tmp);
<a name="119" id="anc119"></a><span class="line-modified">2737       remove_invalid_closure_notify (tmp, instance);</span>
<span class="line-modified">2738       tmp-&gt;sequential_number = 0;</span>
<span class="line-modified">2739       handler_unref_R (0, NULL, tmp);</span>
<span class="line-modified">2740     }</span>
2741             }
2742         }
2743       g_bsearch_array_free (hlbsa, &amp;g_signal_hlbsa_bconfig);
2744     }
2745   SIGNAL_UNLOCK ();
2746 }
2747 
2748 /**
2749  * g_signal_handler_find:
2750  * @instance: (type GObject.Object): The instance owning the signal handler to be found.
2751  * @mask: Mask indicating which of @signal_id, @detail, @closure, @func
2752  *  and/or @data the handler has to match.
2753  * @signal_id: Signal the handler has to be connected to.
2754  * @detail: Signal detail the handler has to be connected to.
2755  * @closure: (nullable): The closure the handler will invoke.
2756  * @func: The C closure callback of the handler (useless for non-C closures).
2757  * @data: The closure data of the handler&#39;s closure.
2758  *
2759  * Finds the first signal handler that matches certain selection criteria.
2760  * The criteria mask is passed as an OR-ed combination of #GSignalMatchType
2761  * flags, and the criteria values are passed as arguments.
2762  * The match @mask has to be non-0 for successful matches.
2763  * If no handler was found, 0 is returned.
2764  *
2765  * Returns: A valid non-0 signal handler id for a successful match.
2766  */
2767 gulong
2768 g_signal_handler_find (gpointer         instance,
2769                        GSignalMatchType mask,
2770                        guint            signal_id,
<a name="120" id="anc120"></a><span class="line-modified">2771            GQuark   detail,</span>
2772                        GClosure        *closure,
2773                        gpointer         func,
2774                        gpointer         data)
2775 {
2776   gulong handler_seq_no = 0;
2777 
2778   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
2779   g_return_val_if_fail ((mask &amp; ~G_SIGNAL_MATCH_MASK) == 0, 0);
2780 
2781   if (mask &amp; G_SIGNAL_MATCH_MASK)
2782     {
2783       HandlerMatch *mlist;
2784 
2785       SIGNAL_LOCK ();
2786       mlist = handlers_find (instance, mask, signal_id, detail, closure, func, data, TRUE);
2787       if (mlist)
<a name="121" id="anc121"></a><span class="line-modified">2788   {</span>
<span class="line-modified">2789     handler_seq_no = mlist-&gt;handler-&gt;sequential_number;</span>
<span class="line-modified">2790     handler_match_free1_R (mlist, instance);</span>
<span class="line-modified">2791   }</span>
2792       SIGNAL_UNLOCK ();
2793     }
2794 
2795   return handler_seq_no;
2796 }
2797 
2798 static guint
2799 signal_handlers_foreach_matched_R (gpointer         instance,
<a name="122" id="anc122"></a><span class="line-modified">2800            GSignalMatchType mask,</span>
<span class="line-modified">2801            guint            signal_id,</span>
<span class="line-modified">2802            GQuark           detail,</span>
<span class="line-modified">2803            GClosure        *closure,</span>
<span class="line-modified">2804            gpointer         func,</span>
<span class="line-modified">2805            gpointer         data,</span>
<span class="line-modified">2806            void     (*callback) (gpointer instance,</span>
<span class="line-modified">2807                      gulong   handler_seq_no))</span>
2808 {
2809   HandlerMatch *mlist;
2810   guint n_handlers = 0;
2811 
2812   mlist = handlers_find (instance, mask, signal_id, detail, closure, func, data, FALSE);
2813   while (mlist)
2814     {
2815       n_handlers++;
2816       if (mlist-&gt;handler-&gt;sequential_number)
<a name="123" id="anc123"></a><span class="line-modified">2817   {</span>
<span class="line-modified">2818     SIGNAL_UNLOCK ();</span>
<span class="line-modified">2819     callback (instance, mlist-&gt;handler-&gt;sequential_number);</span>
<span class="line-modified">2820     SIGNAL_LOCK ();</span>
<span class="line-modified">2821   }</span>
2822       mlist = handler_match_free1_R (mlist, instance);
2823     }
2824 
2825   return n_handlers;
2826 }
2827 
2828 /**
2829  * g_signal_handlers_block_matched:
2830  * @instance: (type GObject.Object): The instance to block handlers from.
2831  * @mask: Mask indicating which of @signal_id, @detail, @closure, @func
2832  *  and/or @data the handlers have to match.
2833  * @signal_id: Signal the handlers have to be connected to.
2834  * @detail: Signal detail the handlers have to be connected to.
2835  * @closure: (nullable): The closure the handlers will invoke.
2836  * @func: The C closure callback of the handlers (useless for non-C closures).
2837  * @data: The closure data of the handlers&#39; closures.
2838  *
2839  * Blocks all handlers on an instance that match a certain selection criteria.
2840  * The criteria mask is passed as an OR-ed combination of #GSignalMatchType
2841  * flags, and the criteria values are passed as arguments.
2842  * Passing at least one of the %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC
2843  * or %G_SIGNAL_MATCH_DATA match flags is required for successful matches.
2844  * If no handlers were found, 0 is returned, the number of blocked handlers
2845  * otherwise.
2846  *
2847  * Returns: The number of handlers that matched.
2848  */
2849 guint
2850 g_signal_handlers_block_matched (gpointer         instance,
<a name="124" id="anc124"></a><span class="line-modified">2851          GSignalMatchType mask,</span>
<span class="line-modified">2852          guint            signal_id,</span>
<span class="line-modified">2853          GQuark           detail,</span>
<span class="line-modified">2854          GClosure        *closure,</span>
<span class="line-modified">2855          gpointer         func,</span>
<span class="line-modified">2856          gpointer         data)</span>
2857 {
2858   guint n_handlers = 0;
2859 
2860   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
2861   g_return_val_if_fail ((mask &amp; ~G_SIGNAL_MATCH_MASK) == 0, 0);
2862 
2863   if (mask &amp; (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
2864     {
2865       SIGNAL_LOCK ();
2866       n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
<a name="125" id="anc125"></a><span class="line-modified">2867                   closure, func, data,</span>
<span class="line-modified">2868                   g_signal_handler_block);</span>
2869       SIGNAL_UNLOCK ();
2870     }
2871 
2872   return n_handlers;
2873 }
2874 
2875 /**
2876  * g_signal_handlers_unblock_matched:
2877  * @instance: (type GObject.Object): The instance to unblock handlers from.
2878  * @mask: Mask indicating which of @signal_id, @detail, @closure, @func
2879  *  and/or @data the handlers have to match.
2880  * @signal_id: Signal the handlers have to be connected to.
2881  * @detail: Signal detail the handlers have to be connected to.
2882  * @closure: (nullable): The closure the handlers will invoke.
2883  * @func: The C closure callback of the handlers (useless for non-C closures).
2884  * @data: The closure data of the handlers&#39; closures.
2885  *
2886  * Unblocks all handlers on an instance that match a certain selection
2887  * criteria. The criteria mask is passed as an OR-ed combination of
2888  * #GSignalMatchType flags, and the criteria values are passed as arguments.
2889  * Passing at least one of the %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC
2890  * or %G_SIGNAL_MATCH_DATA match flags is required for successful matches.
2891  * If no handlers were found, 0 is returned, the number of unblocked handlers
2892  * otherwise. The match criteria should not apply to any handlers that are
2893  * not currently blocked.
2894  *
2895  * Returns: The number of handlers that matched.
2896  */
2897 guint
2898 g_signal_handlers_unblock_matched (gpointer         instance,
<a name="126" id="anc126"></a><span class="line-modified">2899            GSignalMatchType mask,</span>
<span class="line-modified">2900            guint            signal_id,</span>
<span class="line-modified">2901            GQuark           detail,</span>
<span class="line-modified">2902            GClosure        *closure,</span>
<span class="line-modified">2903            gpointer         func,</span>
<span class="line-modified">2904            gpointer         data)</span>
2905 {
2906   guint n_handlers = 0;
2907 
2908   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
2909   g_return_val_if_fail ((mask &amp; ~G_SIGNAL_MATCH_MASK) == 0, 0);
2910 
2911   if (mask &amp; (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
2912     {
2913       SIGNAL_LOCK ();
2914       n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
<a name="127" id="anc127"></a><span class="line-modified">2915                   closure, func, data,</span>
<span class="line-modified">2916                   g_signal_handler_unblock);</span>
2917       SIGNAL_UNLOCK ();
2918     }
2919 
2920   return n_handlers;
2921 }
2922 
2923 /**
2924  * g_signal_handlers_disconnect_matched:
2925  * @instance: (type GObject.Object): The instance to remove handlers from.
2926  * @mask: Mask indicating which of @signal_id, @detail, @closure, @func
2927  *  and/or @data the handlers have to match.
2928  * @signal_id: Signal the handlers have to be connected to.
2929  * @detail: Signal detail the handlers have to be connected to.
2930  * @closure: (nullable): The closure the handlers will invoke.
2931  * @func: The C closure callback of the handlers (useless for non-C closures).
2932  * @data: The closure data of the handlers&#39; closures.
2933  *
2934  * Disconnects all handlers on an instance that match a certain
2935  * selection criteria. The criteria mask is passed as an OR-ed
2936  * combination of #GSignalMatchType flags, and the criteria values are
2937  * passed as arguments.  Passing at least one of the
2938  * %G_SIGNAL_MATCH_CLOSURE, %G_SIGNAL_MATCH_FUNC or
2939  * %G_SIGNAL_MATCH_DATA match flags is required for successful
2940  * matches.  If no handlers were found, 0 is returned, the number of
2941  * disconnected handlers otherwise.
2942  *
2943  * Returns: The number of handlers that matched.
2944  */
2945 guint
2946 g_signal_handlers_disconnect_matched (gpointer         instance,
<a name="128" id="anc128"></a><span class="line-modified">2947               GSignalMatchType mask,</span>
<span class="line-modified">2948               guint            signal_id,</span>
<span class="line-modified">2949               GQuark           detail,</span>
<span class="line-modified">2950               GClosure        *closure,</span>
<span class="line-modified">2951               gpointer         func,</span>
<span class="line-modified">2952               gpointer         data)</span>
2953 {
2954   guint n_handlers = 0;
2955 
2956   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
2957   g_return_val_if_fail ((mask &amp; ~G_SIGNAL_MATCH_MASK) == 0, 0);
2958 
2959   if (mask &amp; (G_SIGNAL_MATCH_CLOSURE | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA))
2960     {
2961       SIGNAL_LOCK ();
2962       n_handlers = signal_handlers_foreach_matched_R (instance, mask, signal_id, detail,
<a name="129" id="anc129"></a><span class="line-modified">2963                   closure, func, data,</span>
<span class="line-modified">2964                   g_signal_handler_disconnect);</span>
2965       SIGNAL_UNLOCK ();
2966     }
2967 
2968   return n_handlers;
2969 }
2970 
2971 /**
2972  * g_signal_has_handler_pending:
2973  * @instance: (type GObject.Object): the object whose signal handlers are sought.
2974  * @signal_id: the signal id.
2975  * @detail: the detail.
2976  * @may_be_blocked: whether blocked handlers should count as match.
2977  *
2978  * Returns whether there are any handlers connected to @instance for the
2979  * given signal id and detail.
2980  *
2981  * If @detail is 0 then it will only match handlers that were connected
2982  * without detail.  If @detail is non-zero then it will match handlers
2983  * connected both without detail and with the given detail.  This is
2984  * consistent with how a signal emitted with @detail would be delivered
2985  * to those handlers.
2986  *
2987  * Since 2.46 this also checks for a non-default class closure being
2988  * installed, as this is basically always what you want.
2989  *
2990  * One example of when you might use this is when the arguments to the
2991  * signal are difficult to compute. A class implementor may opt to not
2992  * emit the signal if no one is attached anyway, thus saving the cost
2993  * of building the arguments.
2994  *
2995  * Returns: %TRUE if a handler is connected to the signal, %FALSE
2996  *          otherwise.
2997  */
2998 gboolean
2999 g_signal_has_handler_pending (gpointer instance,
<a name="130" id="anc130"></a><span class="line-modified">3000             guint    signal_id,</span>
<span class="line-modified">3001             GQuark   detail,</span>
<span class="line-modified">3002             gboolean may_be_blocked)</span>
3003 {
3004   HandlerMatch *mlist;
3005   gboolean has_pending;
3006   SignalNode *node;
3007 
3008   g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), FALSE);
3009   g_return_val_if_fail (signal_id &gt; 0, FALSE);
3010 
3011   SIGNAL_LOCK ();
3012 
3013   node = LOOKUP_SIGNAL_NODE (signal_id);
3014   if (detail)
3015     {
3016 #ifndef GSTREAMER_LITE
3017       if (!(node-&gt;flags &amp; G_SIGNAL_DETAILED))
3018 #else // GSTREAMER_LITE
3019       if (node == NULL || !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
3020 #endif // GSTREAMER_LITE
<a name="131" id="anc131"></a><span class="line-modified">3021   {</span>
<span class="line-modified">3022     g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);</span>
<span class="line-modified">3023     SIGNAL_UNLOCK ();</span>
<span class="line-modified">3024     return FALSE;</span>
<span class="line-modified">3025   }</span>
3026     }
3027   mlist = handlers_find (instance,
<a name="132" id="anc132"></a><span class="line-modified">3028        (G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_DETAIL | (may_be_blocked ? 0 : G_SIGNAL_MATCH_UNBLOCKED)),</span>
<span class="line-modified">3029        signal_id, detail, NULL, NULL, NULL, TRUE);</span>
3030   if (mlist)
3031     {
3032       has_pending = TRUE;
3033       handler_match_free1_R (mlist, instance);
3034     }
3035   else
3036     {
3037       ClassClosure *class_closure = signal_find_class_closure (node, G_TYPE_FROM_INSTANCE (instance));
3038       if (class_closure != NULL &amp;&amp; class_closure-&gt;instance_type != 0)
3039         has_pending = TRUE;
3040       else
<a name="133" id="anc133"></a><span class="line-modified">3041         has_pending = FALSE;</span>
3042     }
3043   SIGNAL_UNLOCK ();
3044 
3045   return has_pending;
3046 }
3047 
3048 /**
3049  * g_signal_emitv:
3050  * @instance_and_params: (array): argument list for the signal emission.
3051  *  The first element in the array is a #GValue for the instance the signal
3052  *  is being emitted on. The rest are any arguments to be passed to the signal.
3053  * @signal_id: the signal id
3054  * @detail: the detail
3055  * @return_value: (inout) (optional): Location to
3056  * store the return value of the signal emission. This must be provided if the
3057  * specified signal returns a value, but may be ignored otherwise.
3058  *
3059  * Emits a signal.
3060  *
3061  * Note that g_signal_emitv() doesn&#39;t change @return_value if no handlers are
3062  * connected, in contrast to g_signal_emit() and g_signal_emit_valist().
3063  */
3064 void
3065 g_signal_emitv (const GValue *instance_and_params,
<a name="134" id="anc134"></a><span class="line-modified">3066     guint         signal_id,</span>
<span class="line-modified">3067     GQuark        detail,</span>
<span class="line-modified">3068     GValue       *return_value)</span>
3069 {
3070   gpointer instance;
3071   SignalNode *node;
3072 #ifdef G_ENABLE_DEBUG
3073   const GValue *param_values;
3074   guint i;
3075 #endif
3076 
3077   g_return_if_fail (instance_and_params != NULL);
3078   instance = g_value_peek_pointer (instance_and_params);
3079   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
3080   g_return_if_fail (signal_id &gt; 0);
3081 
3082 #ifdef G_ENABLE_DEBUG
3083   param_values = instance_and_params + 1;
3084 #endif
3085 
3086   SIGNAL_LOCK ();
3087   node = LOOKUP_SIGNAL_NODE (signal_id);
3088   if (!node || !g_type_is_a (G_TYPE_FROM_INSTANCE (instance), node-&gt;itype))
3089     {
3090       g_warning (&quot;%s: signal id &#39;%u&#39; is invalid for instance &#39;%p&#39;&quot;, G_STRLOC, signal_id, instance);
3091       SIGNAL_UNLOCK ();
3092       return;
3093     }
3094 #ifdef G_ENABLE_DEBUG
3095   if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
3096     {
3097       g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);
3098       SIGNAL_UNLOCK ();
3099       return;
3100     }
3101   for (i = 0; i &lt; node-&gt;n_params; i++)
3102     if (!G_TYPE_CHECK_VALUE_TYPE (param_values + i, node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
3103       {
<a name="135" id="anc135"></a><span class="line-modified">3104   g_critical (&quot;%s: value for &#39;%s&#39; parameter %u for signal \&quot;%s\&quot; is of type &#39;%s&#39;&quot;,</span>
<span class="line-modified">3105         G_STRLOC,</span>
<span class="line-modified">3106         type_debug_name (node-&gt;param_types[i]),</span>
<span class="line-modified">3107         i,</span>
<span class="line-modified">3108         node-&gt;name,</span>
<span class="line-modified">3109         G_VALUE_TYPE_NAME (param_values + i));</span>
<span class="line-modified">3110   SIGNAL_UNLOCK ();</span>
<span class="line-modified">3111   return;</span>
3112       }
3113   if (node-&gt;return_type != G_TYPE_NONE)
3114     {
3115       if (!return_value)
<a name="136" id="anc136"></a><span class="line-modified">3116   {</span>
<span class="line-modified">3117     g_critical (&quot;%s: return value &#39;%s&#39; for signal \&quot;%s\&quot; is (NULL)&quot;,</span>
<span class="line-modified">3118           G_STRLOC,</span>
<span class="line-modified">3119           type_debug_name (node-&gt;return_type),</span>
<span class="line-modified">3120           node-&gt;name);</span>
<span class="line-modified">3121     SIGNAL_UNLOCK ();</span>
<span class="line-modified">3122     return;</span>
<span class="line-modified">3123   }</span>
3124       else if (!node-&gt;accumulator &amp;&amp; !G_TYPE_CHECK_VALUE_TYPE (return_value, node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE))
<a name="137" id="anc137"></a><span class="line-modified">3125   {</span>
<span class="line-modified">3126     g_critical (&quot;%s: return value &#39;%s&#39; for signal \&quot;%s\&quot; is of type &#39;%s&#39;&quot;,</span>
<span class="line-modified">3127           G_STRLOC,</span>
<span class="line-modified">3128           type_debug_name (node-&gt;return_type),</span>
<span class="line-modified">3129           node-&gt;name,</span>
<span class="line-modified">3130           G_VALUE_TYPE_NAME (return_value));</span>
<span class="line-modified">3131     SIGNAL_UNLOCK ();</span>
<span class="line-modified">3132     return;</span>
<span class="line-modified">3133   }</span>
3134     }
3135   else
3136     return_value = NULL;
3137 #endif  /* G_ENABLE_DEBUG */
3138 
3139   /* optimize NOP emissions */
3140   if (!node-&gt;single_va_closure_is_valid)
3141     node_update_single_va_closure (node);
3142 
3143   if (node-&gt;single_va_closure != NULL &amp;&amp;
3144       (node-&gt;single_va_closure == SINGLE_VA_CLOSURE_EMPTY_MAGIC ||
3145        _g_closure_is_void (node-&gt;single_va_closure, instance)))
3146     {
3147       HandlerList* hlist = handler_list_lookup (node-&gt;signal_id, instance);
3148       if (hlist == NULL || hlist-&gt;handlers == NULL)
<a name="138" id="anc138"></a><span class="line-modified">3149   {</span>
<span class="line-modified">3150     /* nothing to do to emit this signal */</span>
<span class="line-modified">3151     SIGNAL_UNLOCK ();</span>
<span class="line-modified">3152     /* g_printerr (&quot;omitting emission of \&quot;%s\&quot;\n&quot;, node-&gt;name); */</span>
<span class="line-modified">3153     return;</span>
<span class="line-modified">3154   }</span>
3155     }
3156 
3157   SIGNAL_UNLOCK ();
3158   signal_emit_unlocked_R (node, detail, instance, return_value, instance_and_params);
3159 }
3160 
3161 static inline gboolean
3162 accumulate (GSignalInvocationHint *ihint,
<a name="139" id="anc139"></a><span class="line-modified">3163       GValue                *return_accu,</span>
<span class="line-modified">3164       GValue            *handler_return,</span>
<span class="line-modified">3165       SignalAccumulator     *accumulator)</span>
3166 {
3167   gboolean continue_emission;
3168 
3169   if (!accumulator)
3170     return TRUE;
3171 
3172   continue_emission = accumulator-&gt;func (ihint, return_accu, handler_return, accumulator-&gt;data);
3173   g_value_reset (handler_return);
3174 
3175   return continue_emission;
3176 }
3177 
3178 /**
3179  * g_signal_emit_valist: (skip)
3180  * @instance: (type GObject.TypeInstance): the instance the signal is being
3181  *    emitted on.
3182  * @signal_id: the signal id
3183  * @detail: the detail
3184  * @var_args: a list of parameters to be passed to the signal, followed by a
3185  *  location for the return value. If the return type of the signal
3186  *  is #G_TYPE_NONE, the return value location can be omitted.
3187  *
3188  * Emits a signal.
3189  *
3190  * Note that g_signal_emit_valist() resets the return value to the default
3191  * if no handlers are connected, in contrast to g_signal_emitv().
3192  */
3193 void
3194 g_signal_emit_valist (gpointer instance,
<a name="140" id="anc140"></a><span class="line-modified">3195           guint    signal_id,</span>
<span class="line-modified">3196           GQuark   detail,</span>
<span class="line-modified">3197           va_list  var_args)</span>
3198 {
3199   GValue *instance_and_params;
3200   GType signal_return_type;
3201   GValue *param_values;
3202   SignalNode *node;
3203   guint i, n_params;
3204 
3205   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
3206   g_return_if_fail (signal_id &gt; 0);
3207 
3208   SIGNAL_LOCK ();
3209   node = LOOKUP_SIGNAL_NODE (signal_id);
3210   if (!node || !g_type_is_a (G_TYPE_FROM_INSTANCE (instance), node-&gt;itype))
3211     {
3212       g_warning (&quot;%s: signal id &#39;%u&#39; is invalid for instance &#39;%p&#39;&quot;, G_STRLOC, signal_id, instance);
3213       SIGNAL_UNLOCK ();
3214       return;
3215     }
3216 #ifndef G_DISABLE_CHECKS
3217   if (detail &amp;&amp; !(node-&gt;flags &amp; G_SIGNAL_DETAILED))
3218     {
3219       g_warning (&quot;%s: signal id &#39;%u&#39; does not support detail (%u)&quot;, G_STRLOC, signal_id, detail);
3220       SIGNAL_UNLOCK ();
3221       return;
3222     }
3223 #endif  /* !G_DISABLE_CHECKS */
3224 
3225   if (!node-&gt;single_va_closure_is_valid)
3226     node_update_single_va_closure (node);
3227 
3228   if (node-&gt;single_va_closure != NULL)
3229     {
3230       HandlerList* hlist = handler_list_lookup (node-&gt;signal_id, instance);
3231       Handler *fastpath_handler = NULL;
3232       Handler *l;
3233       GClosure *closure = NULL;
3234       gboolean fastpath = TRUE;
3235       GSignalFlags run_type = G_SIGNAL_RUN_FIRST;
3236 
3237       if (node-&gt;single_va_closure != SINGLE_VA_CLOSURE_EMPTY_MAGIC &amp;&amp;
<a name="141" id="anc141"></a><span class="line-modified">3238     !_g_closure_is_void (node-&gt;single_va_closure, instance))</span>
<span class="line-modified">3239   {</span>
<span class="line-modified">3240     if (_g_closure_supports_invoke_va (node-&gt;single_va_closure))</span>
<span class="line-modified">3241       {</span>
<span class="line-modified">3242         closure = node-&gt;single_va_closure;</span>
<span class="line-modified">3243         if (node-&gt;single_va_closure_is_after)</span>
<span class="line-modified">3244     run_type = G_SIGNAL_RUN_LAST;</span>
<span class="line-modified">3245         else</span>
<span class="line-modified">3246     run_type = G_SIGNAL_RUN_FIRST;</span>
<span class="line-modified">3247       }</span>
<span class="line-modified">3248     else</span>
<span class="line-modified">3249       fastpath = FALSE;</span>
<span class="line-modified">3250   }</span>
3251 
3252       for (l = hlist ? hlist-&gt;handlers : NULL; fastpath &amp;&amp; l != NULL; l = l-&gt;next)
<a name="142" id="anc142"></a><span class="line-added">3253   {</span>
<span class="line-added">3254     if (!l-&gt;block_count &amp;&amp;</span>
<span class="line-added">3255         (!l-&gt;detail || l-&gt;detail == detail))</span>
<span class="line-added">3256       {</span>
<span class="line-added">3257         if (closure != NULL || !_g_closure_supports_invoke_va (l-&gt;closure))</span>
<span class="line-added">3258     {</span>
<span class="line-added">3259       fastpath = FALSE;</span>
<span class="line-added">3260       break;</span>
<span class="line-added">3261     }</span>
<span class="line-added">3262         else</span>
3263     {
<a name="143" id="anc143"></a>









3264                   fastpath_handler = l;
<a name="144" id="anc144"></a><span class="line-modified">3265       closure = l-&gt;closure;</span>
<span class="line-modified">3266       if (l-&gt;after)</span>
<span class="line-modified">3267         run_type = G_SIGNAL_RUN_LAST;</span>
<span class="line-modified">3268       else</span>
<span class="line-modified">3269         run_type = G_SIGNAL_RUN_FIRST;</span>


3270     }
<a name="145" id="anc145"></a><span class="line-added">3271       }</span>
<span class="line-added">3272   }</span>
3273 
3274       if (fastpath &amp;&amp; closure == NULL &amp;&amp; node-&gt;return_type == G_TYPE_NONE)
<a name="146" id="anc146"></a><span class="line-modified">3275   {</span>
<span class="line-modified">3276     SIGNAL_UNLOCK ();</span>
<span class="line-modified">3277     return;</span>
<span class="line-modified">3278   }</span>
3279 
3280       /* Don&#39;t allow no-recurse emission as we might have to restart, which means
<a name="147" id="anc147"></a><span class="line-modified">3281    we will run multiple handlers and thus must ref all arguments */</span>
3282       if (closure != NULL &amp;&amp; (node-&gt;flags &amp; (G_SIGNAL_NO_RECURSE)) != 0)
<a name="148" id="anc148"></a><span class="line-modified">3283   fastpath = FALSE;</span>
3284 
3285       if (fastpath)
<a name="149" id="anc149"></a><span class="line-modified">3286   {</span>
<span class="line-modified">3287     SignalAccumulator *accumulator;</span>
<span class="line-modified">3288     Emission emission;</span>
<span class="line-modified">3289     GValue *return_accu, accu = G_VALUE_INIT;</span>
<span class="line-modified">3290     guint signal_id;</span>
<span class="line-modified">3291     GType instance_type = G_TYPE_FROM_INSTANCE (instance);</span>
<span class="line-modified">3292     GValue emission_return = G_VALUE_INIT;</span>
3293           GType rtype = node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
<a name="150" id="anc150"></a><span class="line-modified">3294     gboolean static_scope = node-&gt;return_type &amp; G_SIGNAL_TYPE_STATIC_SCOPE;</span>









3295 
<a name="151" id="anc151"></a><span class="line-modified">3296     signal_id = node-&gt;signal_id;</span>
<span class="line-modified">3297     accumulator = node-&gt;accumulator;</span>
<span class="line-modified">3298     if (rtype == G_TYPE_NONE)</span>
<span class="line-modified">3299       return_accu = NULL;</span>
<span class="line-modified">3300     else if (accumulator)</span>
<span class="line-modified">3301       return_accu = &amp;accu;</span>
<span class="line-modified">3302     else</span>
<span class="line-added">3303       return_accu = &amp;emission_return;</span>
<span class="line-added">3304 </span>
<span class="line-added">3305     emission.instance = instance;</span>
<span class="line-added">3306     emission.ihint.signal_id = signal_id;</span>
<span class="line-added">3307     emission.ihint.detail = detail;</span>
<span class="line-added">3308     emission.ihint.run_type = run_type;</span>
<span class="line-added">3309     emission.state = EMISSION_RUN;</span>
<span class="line-added">3310     emission.chain_type = instance_type;</span>
<span class="line-added">3311     emission_push (&amp;emission);</span>
3312 
3313           if (fastpath_handler)
3314             handler_ref (fastpath_handler);
3315 
<a name="152" id="anc152"></a><span class="line-modified">3316     SIGNAL_UNLOCK ();</span>
3317 
<a name="153" id="anc153"></a><span class="line-modified">3318     TRACE(GOBJECT_SIGNAL_EMIT(signal_id, detail, instance, instance_type));</span>
3319 
<a name="154" id="anc154"></a><span class="line-modified">3320     if (rtype != G_TYPE_NONE)</span>
<span class="line-modified">3321       g_value_init (&amp;emission_return, rtype);</span>
3322 
<a name="155" id="anc155"></a><span class="line-modified">3323     if (accumulator)</span>
<span class="line-modified">3324       g_value_init (&amp;accu, rtype);</span>
3325 
<a name="156" id="anc156"></a><span class="line-modified">3326     if (closure != NULL)</span>
<span class="line-modified">3327       {</span>
<span class="line-modified">3328         g_object_ref (instance);</span>
<span class="line-modified">3329         _g_closure_invoke_va (closure,</span>
<span class="line-modified">3330             return_accu,</span>
<span class="line-modified">3331             instance,</span>
<span class="line-modified">3332             var_args,</span>
<span class="line-modified">3333             node-&gt;n_params,</span>
<span class="line-modified">3334             node-&gt;param_types);</span>
<span class="line-modified">3335         accumulate (&amp;emission.ihint, &amp;emission_return, &amp;accu, accumulator);</span>
<span class="line-modified">3336       }</span>
3337 
<a name="157" id="anc157"></a><span class="line-modified">3338     SIGNAL_LOCK ();</span>
3339 
<a name="158" id="anc158"></a><span class="line-modified">3340     emission.chain_type = G_TYPE_NONE;</span>
<span class="line-modified">3341     emission_pop (&amp;emission);</span>
3342 
3343           if (fastpath_handler)
3344             handler_unref_R (signal_id, instance, fastpath_handler);
3345 
<a name="159" id="anc159"></a><span class="line-modified">3346     SIGNAL_UNLOCK ();</span>
3347 
<a name="160" id="anc160"></a><span class="line-modified">3348     if (accumulator)</span>
<span class="line-modified">3349       g_value_unset (&amp;accu);</span>
3350 
<a name="161" id="anc161"></a><span class="line-modified">3351     if (rtype != G_TYPE_NONE)</span>
<span class="line-modified">3352       {</span>
<span class="line-modified">3353         gchar *error = NULL;</span>
<span class="line-modified">3354         for (i = 0; i &lt; node-&gt;n_params; i++)</span>
<span class="line-modified">3355     {</span>
<span class="line-modified">3356       GType ptype = node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;</span>
<span class="line-modified">3357       G_VALUE_COLLECT_SKIP (ptype, var_args);</span>
<span class="line-modified">3358     }</span>
3359 
<a name="162" id="anc162"></a><span class="line-modified">3360         G_VALUE_LCOPY (&amp;emission_return,</span>
<span class="line-modified">3361            var_args,</span>
<span class="line-modified">3362            static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="line-modified">3363            &amp;error);</span>
<span class="line-modified">3364         if (!error)</span>
<span class="line-modified">3365     g_value_unset (&amp;emission_return);</span>
<span class="line-modified">3366         else</span>
<span class="line-modified">3367     {</span>
<span class="line-modified">3368       g_warning (&quot;%s: %s&quot;, G_STRLOC, error);</span>
<span class="line-modified">3369       g_free (error);</span>
<span class="line-modified">3370       /* we purposely leak the value here, it might not be</span>
<span class="line-modified">3371        * in a sane state if an error condition occurred</span>
<span class="line-modified">3372        */</span>
<span class="line-modified">3373     }</span>
<span class="line-modified">3374       }</span>
3375 
<a name="163" id="anc163"></a><span class="line-modified">3376     TRACE(GOBJECT_SIGNAL_EMIT_END(signal_id, detail, instance, instance_type));</span>
3377 
3378           if (closure != NULL)
3379             g_object_unref (instance);
3380 
<a name="164" id="anc164"></a><span class="line-modified">3381     return;</span>
<span class="line-modified">3382   }</span>
3383     }
3384   SIGNAL_UNLOCK ();
3385 
3386   n_params = node-&gt;n_params;
3387   signal_return_type = node-&gt;return_type;
3388   instance_and_params = g_alloca (sizeof (GValue) * (n_params + 1));
3389   memset (instance_and_params, 0, sizeof (GValue) * (n_params + 1));
3390   param_values = instance_and_params + 1;
3391 
3392   for (i = 0; i &lt; node-&gt;n_params; i++)
3393     {
3394       gchar *error;
3395       GType ptype = node-&gt;param_types[i] &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
3396       gboolean static_scope = node-&gt;param_types[i] &amp; G_SIGNAL_TYPE_STATIC_SCOPE;
3397 
3398       G_VALUE_COLLECT_INIT (param_values + i, ptype,
<a name="165" id="anc165"></a><span class="line-modified">3399           var_args,</span>
<span class="line-modified">3400           static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="line-modified">3401           &amp;error);</span>
3402       if (error)
<a name="166" id="anc166"></a><span class="line-modified">3403   {</span>
<span class="line-modified">3404     g_warning (&quot;%s: %s&quot;, G_STRLOC, error);</span>
<span class="line-modified">3405     g_free (error);</span>
3406 
<a name="167" id="anc167"></a><span class="line-modified">3407     /* we purposely leak the value here, it might not be</span>
<span class="line-modified">3408      * in a sane state if an error condition occoured</span>
<span class="line-modified">3409      */</span>
<span class="line-modified">3410     while (i--)</span>
<span class="line-modified">3411       g_value_unset (param_values + i);</span>
3412 
<a name="168" id="anc168"></a><span class="line-modified">3413     return;</span>
<span class="line-modified">3414   }</span>
3415     }
3416 
3417   instance_and_params-&gt;g_type = 0;
3418   g_value_init_from_instance (instance_and_params, instance);
3419   if (signal_return_type == G_TYPE_NONE)
3420     signal_emit_unlocked_R (node, detail, instance, NULL, instance_and_params);
3421   else
3422     {
3423       GValue return_value = G_VALUE_INIT;
3424       gchar *error = NULL;
3425       GType rtype = signal_return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE;
3426       gboolean static_scope = signal_return_type &amp; G_SIGNAL_TYPE_STATIC_SCOPE;
3427 
3428       g_value_init (&amp;return_value, rtype);
3429 
3430       signal_emit_unlocked_R (node, detail, instance, &amp;return_value, instance_and_params);
3431 
3432       G_VALUE_LCOPY (&amp;return_value,
<a name="169" id="anc169"></a><span class="line-modified">3433          var_args,</span>
<span class="line-modified">3434          static_scope ? G_VALUE_NOCOPY_CONTENTS : 0,</span>
<span class="line-modified">3435          &amp;error);</span>
3436       if (!error)
<a name="170" id="anc170"></a><span class="line-modified">3437   g_value_unset (&amp;return_value);</span>
3438       else
<a name="171" id="anc171"></a><span class="line-modified">3439   {</span>
<span class="line-modified">3440     g_warning (&quot;%s: %s&quot;, G_STRLOC, error);</span>
<span class="line-modified">3441     g_free (error);</span>
3442 
<a name="172" id="anc172"></a><span class="line-modified">3443     /* we purposely leak the value here, it might not be</span>
<span class="line-modified">3444      * in a sane state if an error condition occurred</span>
<span class="line-modified">3445      */</span>
<span class="line-modified">3446   }</span>
3447     }
3448   for (i = 0; i &lt; n_params; i++)
3449     g_value_unset (param_values + i);
3450   g_value_unset (instance_and_params);
3451 }
3452 
3453 /**
3454  * g_signal_emit:
3455  * @instance: (type GObject.Object): the instance the signal is being emitted on.
3456  * @signal_id: the signal id
3457  * @detail: the detail
3458  * @...: parameters to be passed to the signal, followed by a
3459  *  location for the return value. If the return type of the signal
3460  *  is #G_TYPE_NONE, the return value location can be omitted.
3461  *
3462  * Emits a signal.
3463  *
3464  * Note that g_signal_emit() resets the return value to the default
3465  * if no handlers are connected, in contrast to g_signal_emitv().
3466  */
3467 void
3468 g_signal_emit (gpointer instance,
<a name="173" id="anc173"></a><span class="line-modified">3469          guint    signal_id,</span>
<span class="line-modified">3470          GQuark   detail,</span>
<span class="line-modified">3471          ...)</span>
3472 {
3473   va_list var_args;
3474 
3475   va_start (var_args, detail);
3476   g_signal_emit_valist (instance, signal_id, detail, var_args);
3477   va_end (var_args);
3478 }
3479 
3480 /**
3481  * g_signal_emit_by_name:
3482  * @instance: (type GObject.Object): the instance the signal is being emitted on.
3483  * @detailed_signal: a string of the form &quot;signal-name::detail&quot;.
3484  * @...: parameters to be passed to the signal, followed by a
3485  *  location for the return value. If the return type of the signal
3486  *  is #G_TYPE_NONE, the return value location can be omitted.
3487  *
3488  * Emits a signal.
3489  *
3490  * Note that g_signal_emit_by_name() resets the return value to the default
3491  * if no handlers are connected, in contrast to g_signal_emitv().
3492  */
3493 void
3494 g_signal_emit_by_name (gpointer     instance,
<a name="174" id="anc174"></a><span class="line-modified">3495            const gchar *detailed_signal,</span>
<span class="line-modified">3496            ...)</span>
3497 {
3498   GQuark detail = 0;
3499   guint signal_id;
3500   GType itype;
3501 
3502   g_return_if_fail (G_TYPE_CHECK_INSTANCE (instance));
3503   g_return_if_fail (detailed_signal != NULL);
3504 
3505   itype = G_TYPE_FROM_INSTANCE (instance);
3506 
3507   SIGNAL_LOCK ();
3508   signal_id = signal_parse_name (detailed_signal, itype, &amp;detail, TRUE);
3509   SIGNAL_UNLOCK ();
3510 
3511   if (signal_id)
3512     {
3513       va_list var_args;
3514 
3515       va_start (var_args, detailed_signal);
3516       g_signal_emit_valist (instance, signal_id, detail, var_args);
3517       va_end (var_args);
3518     }
3519   else
3520     g_warning (&quot;%s: signal name &#39;%s&#39; is invalid for instance &#39;%p&#39; of type &#39;%s&#39;&quot;,
3521                G_STRLOC, detailed_signal, instance, g_type_name (itype));
3522 }
3523 
3524 static gboolean
3525 signal_emit_unlocked_R (SignalNode   *node,
<a name="175" id="anc175"></a><span class="line-modified">3526       GQuark        detail,</span>
<span class="line-modified">3527       gpointer      instance,</span>
<span class="line-modified">3528       GValue       *emission_return,</span>
<span class="line-modified">3529       const GValue *instance_and_params)</span>
3530 {
3531   SignalAccumulator *accumulator;
3532   Emission emission;
3533   GClosure *class_closure;
3534   HandlerList *hlist;
3535   Handler *handler_list = NULL;
3536   GValue *return_accu, accu = G_VALUE_INIT;
3537   guint signal_id;
3538   gulong max_sequential_handler_number;
3539   gboolean return_value_altered = FALSE;
3540 
3541   TRACE(GOBJECT_SIGNAL_EMIT(node-&gt;signal_id, detail, instance, G_TYPE_FROM_INSTANCE (instance)));
3542 
3543   SIGNAL_LOCK ();
3544   signal_id = node-&gt;signal_id;
3545 
3546   if (node-&gt;flags &amp; G_SIGNAL_NO_RECURSE)
3547     {
3548       Emission *node = emission_find (signal_id, detail, instance);
3549 
3550       if (node)
<a name="176" id="anc176"></a><span class="line-modified">3551   {</span>
<span class="line-modified">3552     node-&gt;state = EMISSION_RESTART;</span>
<span class="line-modified">3553     SIGNAL_UNLOCK ();</span>
<span class="line-modified">3554     return return_value_altered;</span>
<span class="line-modified">3555   }</span>
3556     }
3557   accumulator = node-&gt;accumulator;
3558   if (accumulator)
3559     {
3560       SIGNAL_UNLOCK ();
3561       g_value_init (&amp;accu, node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE);
3562       return_accu = &amp;accu;
3563       SIGNAL_LOCK ();
3564     }
3565   else
3566     return_accu = emission_return;
3567   emission.instance = instance;
3568   emission.ihint.signal_id = node-&gt;signal_id;
3569   emission.ihint.detail = detail;
3570   emission.ihint.run_type = 0;
3571   emission.state = 0;
3572   emission.chain_type = G_TYPE_NONE;
3573   emission_push (&amp;emission);
3574   class_closure = signal_lookup_closure (node, instance);
3575 
3576  EMIT_RESTART:
3577 
3578   if (handler_list)
3579     handler_unref_R (signal_id, instance, handler_list);
3580   max_sequential_handler_number = g_handler_sequential_number;
3581   hlist = handler_list_lookup (signal_id, instance);
3582   handler_list = hlist ? hlist-&gt;handlers : NULL;
3583   if (handler_list)
3584     handler_ref (handler_list);
3585 
3586   emission.ihint.run_type = G_SIGNAL_RUN_FIRST;
3587 
3588   if ((node-&gt;flags &amp; G_SIGNAL_RUN_FIRST) &amp;&amp; class_closure)
3589     {
3590       emission.state = EMISSION_RUN;
3591 
3592       emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
3593       SIGNAL_UNLOCK ();
3594       g_closure_invoke (class_closure,
<a name="177" id="anc177"></a><span class="line-modified">3595       return_accu,</span>
<span class="line-modified">3596       node-&gt;n_params + 1,</span>
<span class="line-modified">3597       instance_and_params,</span>
<span class="line-modified">3598       &amp;emission.ihint);</span>
3599       if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;
<a name="178" id="anc178"></a><span class="line-modified">3600     emission.state == EMISSION_RUN)</span>
<span class="line-modified">3601   emission.state = EMISSION_STOP;</span>
3602       SIGNAL_LOCK ();
3603       emission.chain_type = G_TYPE_NONE;
3604       return_value_altered = TRUE;
3605 
3606       if (emission.state == EMISSION_STOP)
<a name="179" id="anc179"></a><span class="line-modified">3607   goto EMIT_CLEANUP;</span>
3608       else if (emission.state == EMISSION_RESTART)
<a name="180" id="anc180"></a><span class="line-modified">3609   goto EMIT_RESTART;</span>
3610     }
3611 
3612   if (node-&gt;emission_hooks)
3613     {
3614       gboolean need_destroy, was_in_call, may_recurse = TRUE;
3615       GHook *hook;
3616 
3617       emission.state = EMISSION_HOOK;
3618       hook = g_hook_first_valid (node-&gt;emission_hooks, may_recurse);
3619       while (hook)
<a name="181" id="anc181"></a><span class="line-modified">3620   {</span>
<span class="line-modified">3621     SignalHook *signal_hook = SIGNAL_HOOK (hook);</span>
3622 
<a name="182" id="anc182"></a><span class="line-modified">3623     if (!signal_hook-&gt;detail || signal_hook-&gt;detail == detail)</span>
<span class="line-modified">3624       {</span>
<span class="line-modified">3625         GSignalEmissionHook hook_func = (GSignalEmissionHook) hook-&gt;func;</span>
3626 
<a name="183" id="anc183"></a><span class="line-modified">3627         was_in_call = G_HOOK_IN_CALL (hook);</span>
<span class="line-modified">3628         hook-&gt;flags |= G_HOOK_FLAG_IN_CALL;</span>
3629               SIGNAL_UNLOCK ();
<a name="184" id="anc184"></a><span class="line-modified">3630         need_destroy = !hook_func (&amp;emission.ihint, node-&gt;n_params + 1, instance_and_params, hook-&gt;data);</span>
<span class="line-modified">3631         SIGNAL_LOCK ();</span>
<span class="line-modified">3632         if (!was_in_call)</span>
<span class="line-modified">3633     hook-&gt;flags &amp;= ~G_HOOK_FLAG_IN_CALL;</span>
<span class="line-modified">3634         if (need_destroy)</span>
<span class="line-modified">3635     g_hook_destroy_link (node-&gt;emission_hooks, hook);</span>
<span class="line-modified">3636       }</span>
<span class="line-modified">3637     hook = g_hook_next_valid (node-&gt;emission_hooks, hook, may_recurse);</span>
<span class="line-modified">3638   }</span>
3639 
3640       if (emission.state == EMISSION_RESTART)
<a name="185" id="anc185"></a><span class="line-modified">3641   goto EMIT_RESTART;</span>
3642     }
3643 
3644   if (handler_list)
3645     {
3646       Handler *handler = handler_list;
3647 
3648       emission.state = EMISSION_RUN;
3649       handler_ref (handler);
3650       do
<a name="186" id="anc186"></a><span class="line-modified">3651   {</span>
<span class="line-modified">3652     Handler *tmp;</span>
3653 
<a name="187" id="anc187"></a><span class="line-modified">3654     if (handler-&gt;after)</span>
<span class="line-modified">3655       {</span>
<span class="line-modified">3656         handler_unref_R (signal_id, instance, handler_list);</span>
<span class="line-modified">3657         handler_list = handler;</span>
<span class="line-modified">3658         break;</span>
<span class="line-modified">3659       }</span>
<span class="line-modified">3660     else if (!handler-&gt;block_count &amp;&amp; (!handler-&gt;detail || handler-&gt;detail == detail) &amp;&amp;</span>
<span class="line-modified">3661        handler-&gt;sequential_number &lt; max_sequential_handler_number)</span>
<span class="line-modified">3662       {</span>
<span class="line-modified">3663         SIGNAL_UNLOCK ();</span>
<span class="line-modified">3664         g_closure_invoke (handler-&gt;closure,</span>
<span class="line-modified">3665         return_accu,</span>
<span class="line-modified">3666         node-&gt;n_params + 1,</span>
<span class="line-modified">3667         instance_and_params,</span>
<span class="line-modified">3668         &amp;emission.ihint);</span>
<span class="line-modified">3669         if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;</span>
<span class="line-modified">3670       emission.state == EMISSION_RUN)</span>
<span class="line-modified">3671     emission.state = EMISSION_STOP;</span>
<span class="line-modified">3672         SIGNAL_LOCK ();</span>
<span class="line-modified">3673         return_value_altered = TRUE;</span>
3674 
<a name="188" id="anc188"></a><span class="line-modified">3675         tmp = emission.state == EMISSION_RUN ? handler-&gt;next : NULL;</span>
<span class="line-modified">3676       }</span>
<span class="line-modified">3677     else</span>
<span class="line-modified">3678       tmp = handler-&gt;next;</span>
3679 
<a name="189" id="anc189"></a><span class="line-modified">3680     if (tmp)</span>
<span class="line-modified">3681       handler_ref (tmp);</span>
<span class="line-modified">3682     handler_unref_R (signal_id, instance, handler_list);</span>
<span class="line-modified">3683     handler_list = handler;</span>
<span class="line-modified">3684     handler = tmp;</span>
<span class="line-modified">3685   }</span>
3686       while (handler);
3687 
3688       if (emission.state == EMISSION_STOP)
<a name="190" id="anc190"></a><span class="line-modified">3689   goto EMIT_CLEANUP;</span>
3690       else if (emission.state == EMISSION_RESTART)
<a name="191" id="anc191"></a><span class="line-modified">3691   goto EMIT_RESTART;</span>
3692     }
3693 
3694   emission.ihint.run_type = G_SIGNAL_RUN_LAST;
3695 
3696   if ((node-&gt;flags &amp; G_SIGNAL_RUN_LAST) &amp;&amp; class_closure)
3697     {
3698       emission.state = EMISSION_RUN;
3699 
3700       emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
3701       SIGNAL_UNLOCK ();
3702       g_closure_invoke (class_closure,
<a name="192" id="anc192"></a><span class="line-modified">3703       return_accu,</span>
<span class="line-modified">3704       node-&gt;n_params + 1,</span>
<span class="line-modified">3705       instance_and_params,</span>
<span class="line-modified">3706       &amp;emission.ihint);</span>
3707       if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;
<a name="193" id="anc193"></a><span class="line-modified">3708     emission.state == EMISSION_RUN)</span>
<span class="line-modified">3709   emission.state = EMISSION_STOP;</span>
3710       SIGNAL_LOCK ();
3711       emission.chain_type = G_TYPE_NONE;
3712       return_value_altered = TRUE;
3713 
3714       if (emission.state == EMISSION_STOP)
<a name="194" id="anc194"></a><span class="line-modified">3715   goto EMIT_CLEANUP;</span>
3716       else if (emission.state == EMISSION_RESTART)
<a name="195" id="anc195"></a><span class="line-modified">3717   goto EMIT_RESTART;</span>
3718     }
3719 
3720   if (handler_list)
3721     {
3722       Handler *handler = handler_list;
3723 
3724       emission.state = EMISSION_RUN;
3725       handler_ref (handler);
3726       do
<a name="196" id="anc196"></a><span class="line-modified">3727   {</span>
<span class="line-modified">3728     Handler *tmp;</span>
3729 
<a name="197" id="anc197"></a><span class="line-modified">3730     if (handler-&gt;after &amp;&amp; !handler-&gt;block_count &amp;&amp; (!handler-&gt;detail || handler-&gt;detail == detail) &amp;&amp;</span>
<span class="line-modified">3731         handler-&gt;sequential_number &lt; max_sequential_handler_number)</span>
<span class="line-modified">3732       {</span>
<span class="line-modified">3733         SIGNAL_UNLOCK ();</span>
<span class="line-modified">3734         g_closure_invoke (handler-&gt;closure,</span>
<span class="line-modified">3735         return_accu,</span>
<span class="line-modified">3736         node-&gt;n_params + 1,</span>
<span class="line-modified">3737         instance_and_params,</span>
<span class="line-modified">3738         &amp;emission.ihint);</span>
<span class="line-modified">3739         if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;</span>
<span class="line-modified">3740       emission.state == EMISSION_RUN)</span>
<span class="line-modified">3741     emission.state = EMISSION_STOP;</span>
<span class="line-modified">3742         SIGNAL_LOCK ();</span>
<span class="line-modified">3743         return_value_altered = TRUE;</span>
3744 
<a name="198" id="anc198"></a><span class="line-modified">3745         tmp = emission.state == EMISSION_RUN ? handler-&gt;next : NULL;</span>
<span class="line-modified">3746       }</span>
<span class="line-modified">3747     else</span>
<span class="line-modified">3748       tmp = handler-&gt;next;</span>
3749 
<a name="199" id="anc199"></a><span class="line-modified">3750     if (tmp)</span>
<span class="line-modified">3751       handler_ref (tmp);</span>
<span class="line-modified">3752     handler_unref_R (signal_id, instance, handler);</span>
<span class="line-modified">3753     handler = tmp;</span>
<span class="line-modified">3754   }</span>
3755       while (handler);
3756 
3757       if (emission.state == EMISSION_STOP)
<a name="200" id="anc200"></a><span class="line-modified">3758   goto EMIT_CLEANUP;</span>
3759       else if (emission.state == EMISSION_RESTART)
<a name="201" id="anc201"></a><span class="line-modified">3760   goto EMIT_RESTART;</span>
3761     }
3762 
3763  EMIT_CLEANUP:
3764 
3765   emission.ihint.run_type = G_SIGNAL_RUN_CLEANUP;
3766 
3767   if ((node-&gt;flags &amp; G_SIGNAL_RUN_CLEANUP) &amp;&amp; class_closure)
3768     {
3769       gboolean need_unset = FALSE;
3770 
3771       emission.state = EMISSION_STOP;
3772 
3773       emission.chain_type = G_TYPE_FROM_INSTANCE (instance);
3774       SIGNAL_UNLOCK ();
3775       if (node-&gt;return_type != G_TYPE_NONE &amp;&amp; !accumulator)
<a name="202" id="anc202"></a><span class="line-modified">3776   {</span>
<span class="line-modified">3777     g_value_init (&amp;accu, node-&gt;return_type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE);</span>
<span class="line-modified">3778     need_unset = TRUE;</span>
<span class="line-modified">3779   }</span>
3780       g_closure_invoke (class_closure,
<a name="203" id="anc203"></a><span class="line-modified">3781       node-&gt;return_type != G_TYPE_NONE ? &amp;accu : NULL,</span>
<span class="line-modified">3782       node-&gt;n_params + 1,</span>
<span class="line-modified">3783       instance_and_params,</span>
<span class="line-modified">3784       &amp;emission.ihint);</span>
<span class="line-added">3785       if (!accumulate (&amp;emission.ihint, emission_return, &amp;accu, accumulator) &amp;&amp;</span>
<span class="line-added">3786           emission.state == EMISSION_RUN)</span>
<span class="line-added">3787         emission.state = EMISSION_STOP;</span>
3788       if (need_unset)
<a name="204" id="anc204"></a><span class="line-modified">3789   g_value_unset (&amp;accu);</span>
3790       SIGNAL_LOCK ();
<a name="205" id="anc205"></a><span class="line-added">3791       return_value_altered = TRUE;</span>
<span class="line-added">3792 </span>
3793       emission.chain_type = G_TYPE_NONE;
3794 
3795       if (emission.state == EMISSION_RESTART)
<a name="206" id="anc206"></a><span class="line-modified">3796   goto EMIT_RESTART;</span>
3797     }
3798 
3799   if (handler_list)
3800     handler_unref_R (signal_id, instance, handler_list);
3801 
3802   emission_pop (&amp;emission);
3803   SIGNAL_UNLOCK ();
3804   if (accumulator)
3805     g_value_unset (&amp;accu);
3806 
3807   TRACE(GOBJECT_SIGNAL_EMIT_END(node-&gt;signal_id, detail, instance, G_TYPE_FROM_INSTANCE (instance)));
3808 
3809   return return_value_altered;
3810 }
3811 
3812 static void
3813 add_invalid_closure_notify (Handler  *handler,
<a name="207" id="anc207"></a><span class="line-modified">3814           gpointer  instance)</span>
3815 {
3816   g_closure_add_invalidate_notifier (handler-&gt;closure, instance, invalid_closure_notify);
3817   handler-&gt;has_invalid_closure_notify = 1;
3818 }
3819 
3820 static void
3821 remove_invalid_closure_notify (Handler  *handler,
<a name="208" id="anc208"></a><span class="line-modified">3822              gpointer  instance)</span>
3823 {
3824   if (handler-&gt;has_invalid_closure_notify)
3825     {
3826       g_closure_remove_invalidate_notifier (handler-&gt;closure, instance, invalid_closure_notify);
3827       handler-&gt;has_invalid_closure_notify = 0;
3828     }
3829 }
3830 
3831 static void
3832 invalid_closure_notify (gpointer  instance,
<a name="209" id="anc209"></a><span class="line-modified">3833             GClosure *closure)</span>
3834 {
3835   Handler *handler;
3836   guint signal_id;
3837 
3838   SIGNAL_LOCK ();
3839 
3840   handler = handler_lookup (instance, 0, closure, &amp;signal_id);
3841 #ifdef GSTREAMER_LITE
3842   if (handler == NULL)
3843     return;
3844 #endif // GSTREAMER_LITE
3845   /* See https://bugzilla.gnome.org/show_bug.cgi?id=730296 for discussion about this... */
3846   g_assert (handler != NULL);
3847   g_assert (handler-&gt;closure == closure);
3848 
3849   handler-&gt;sequential_number = 0;
3850   handler-&gt;block_count = 1;
3851   handler_unref_R (signal_id, instance, handler);
3852 
3853   SIGNAL_UNLOCK ();
3854 }
3855 
3856 static const gchar*
3857 type_debug_name (GType type)
3858 {
3859   if (type)
3860     {
3861       const char *name = g_type_name (type &amp; ~G_SIGNAL_TYPE_STATIC_SCOPE);
3862       return name ? name : &quot;&lt;unknown&gt;&quot;;
3863     }
3864   else
3865     return &quot;&lt;invalid&gt;&quot;;
3866 }
3867 
3868 /**
3869  * g_signal_accumulator_true_handled:
3870  * @ihint: standard #GSignalAccumulator parameter
3871  * @return_accu: standard #GSignalAccumulator parameter
3872  * @handler_return: standard #GSignalAccumulator parameter
3873  * @dummy: standard #GSignalAccumulator parameter
3874  *
3875  * A predefined #GSignalAccumulator for signals that return a
3876  * boolean values. The behavior that this accumulator gives is
3877  * that a return of %TRUE stops the signal emission: no further
3878  * callbacks will be invoked, while a return of %FALSE allows
3879  * the emission to continue. The idea here is that a %TRUE return
3880  * indicates that the callback handled the signal, and no further
3881  * handling is needed.
3882  *
3883  * Since: 2.4
3884  *
3885  * Returns: standard #GSignalAccumulator result
3886  */
3887 gboolean
3888 g_signal_accumulator_true_handled (GSignalInvocationHint *ihint,
<a name="210" id="anc210"></a><span class="line-modified">3889            GValue                *return_accu,</span>
<span class="line-modified">3890            const GValue          *handler_return,</span>
<span class="line-modified">3891            gpointer               dummy)</span>
3892 {
3893   gboolean continue_emission;
3894   gboolean signal_handled;
3895 
3896   signal_handled = g_value_get_boolean (handler_return);
3897   g_value_set_boolean (return_accu, signal_handled);
3898   continue_emission = !signal_handled;
3899 
3900   return continue_emission;
3901 }
3902 
3903 /**
3904  * g_signal_accumulator_first_wins:
3905  * @ihint: standard #GSignalAccumulator parameter
3906  * @return_accu: standard #GSignalAccumulator parameter
3907  * @handler_return: standard #GSignalAccumulator parameter
3908  * @dummy: standard #GSignalAccumulator parameter
3909  *
3910  * A predefined #GSignalAccumulator for signals intended to be used as a
3911  * hook for application code to provide a particular value.  Usually
3912  * only one such value is desired and multiple handlers for the same
3913  * signal don&#39;t make much sense (except for the case of the default
3914  * handler defined in the class structure, in which case you will
3915  * usually want the signal connection to override the class handler).
3916  *
3917  * This accumulator will use the return value from the first signal
3918  * handler that is run as the return value for the signal and not run
3919  * any further handlers (ie: the first handler &quot;wins&quot;).
3920  *
3921  * Returns: standard #GSignalAccumulator result
3922  *
3923  * Since: 2.28
3924  **/
3925 gboolean
3926 g_signal_accumulator_first_wins (GSignalInvocationHint *ihint,
3927                                  GValue                *return_accu,
3928                                  const GValue          *handler_return,
3929                                  gpointer               dummy)
3930 {
3931   g_value_copy (handler_return, return_accu);
3932   return FALSE;
3933 }
<a name="211" id="anc211"></a><span class="line-added">3934 </span>
<span class="line-added">3935 /**</span>
<span class="line-added">3936  * g_clear_signal_handler:</span>
<span class="line-added">3937  * @handler_id_ptr: A pointer to a handler ID (of type #gulong) of the handler to be disconnected.</span>
<span class="line-added">3938  * @instance: (type GObject.Object): The instance to remove the signal handler from.</span>
<span class="line-added">3939  *</span>
<span class="line-added">3940  * Disconnects a handler from @instance so it will not be called during</span>
<span class="line-added">3941  * any future or currently ongoing emissions of the signal it has been</span>
<span class="line-added">3942  * connected to. The @handler_id_ptr is then set to zero, which is never a valid handler ID value (see g_signal_connect()).</span>
<span class="line-added">3943  *</span>
<span class="line-added">3944  * If the handler ID is 0 then this function does nothing.</span>
<span class="line-added">3945  *</span>
<span class="line-added">3946  * A macro is also included that allows this function to be used without</span>
<span class="line-added">3947  * pointer casts.</span>
<span class="line-added">3948  *</span>
<span class="line-added">3949  * Since: 2.62</span>
<span class="line-added">3950  */</span>
<span class="line-added">3951 #undef g_clear_signal_handler</span>
<span class="line-added">3952 void</span>
<span class="line-added">3953 g_clear_signal_handler (gulong   *handler_id_ptr,</span>
<span class="line-added">3954                         gpointer  instance)</span>
<span class="line-added">3955 {</span>
<span class="line-added">3956   g_return_if_fail (handler_id_ptr != NULL);</span>
<span class="line-added">3957 </span>
<span class="line-added">3958   if (*handler_id_ptr != 0)</span>
<span class="line-added">3959     {</span>
<span class="line-added">3960       g_signal_handler_disconnect (instance, *handler_id_ptr);</span>
<span class="line-added">3961       *handler_id_ptr = 0;</span>
<span class="line-added">3962     }</span>
<span class="line-added">3963 }</span>
<a name="212" id="anc212"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="212" type="hidden" />
</body>
</html>