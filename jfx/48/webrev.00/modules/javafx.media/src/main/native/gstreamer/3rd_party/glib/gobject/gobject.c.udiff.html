<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gobject.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gobject-autocleanups.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gobject.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gobject.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -51,10 +51,17 @@</span>
   * For the high-level concepts behind GObject, read [Instantiable classed types:
   * Objects][gtype-instantiable-classed].
   *
   * ## Floating references # {#floating-ref}
   *
<span class="udiff-line-added">+  * **Note**: Floating references are a C convenience API and should not be</span>
<span class="udiff-line-added">+  * used in modern GObject code. Language bindings in particular find the</span>
<span class="udiff-line-added">+  * concept highly problematic, as floating references are not identifiable</span>
<span class="udiff-line-added">+  * through annotations, and neither are deviations from the floating reference</span>
<span class="udiff-line-added">+  * behavior, like types that inherit from #GInitiallyUnowned and still return</span>
<span class="udiff-line-added">+  * a full reference from g_object_new().</span>
<span class="udiff-line-added">+  *</span>
   * GInitiallyUnowned is derived from GObject. The only difference between
   * the two is that the initial reference of a GInitiallyUnowned is flagged
   * as a &quot;floating&quot; reference. This means that it is not specifically
   * claimed to be &quot;owned&quot; by any code portion. The main motivation for
   * providing floating references is C convenience. In particular, it
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -81,11 +88,27 @@</span>
   * to g_object_ref() and returns a new reference.
   *
   * Since floating references are useful almost exclusively for C convenience,
   * language bindings that provide automated reference and memory ownership
   * maintenance (such as smart pointers or garbage collection) should not
<span class="udiff-line-modified-removed">-  * expose floating references in their API.</span>
<span class="udiff-line-modified-added">+  * expose floating references in their API. The best practice for handling</span>
<span class="udiff-line-added">+  * types that have initially floating references is to immediately sink those</span>
<span class="udiff-line-added">+  * references after g_object_new() returns, by checking if the #GType</span>
<span class="udiff-line-added">+  * inherits from #GInitiallyUnowned. For instance:</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * |[&lt;!-- language=&quot;C&quot; --&gt;</span>
<span class="udiff-line-added">+  * GObject *res = g_object_new_with_properties (gtype,</span>
<span class="udiff-line-added">+  *                                              n_props,</span>
<span class="udiff-line-added">+  *                                              prop_names,</span>
<span class="udiff-line-added">+  *                                              prop_values);</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * // or: if (g_type_is_a (gtype, G_TYPE_INITIALLY_UNOWNED))</span>
<span class="udiff-line-added">+  * if (G_IS_INITIALLY_UNOWNED (res))</span>
<span class="udiff-line-added">+  *   g_object_ref_sink (res);</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * return res;</span>
<span class="udiff-line-added">+  * ]|</span>
   *
   * Some object implementations may need to save an objects floating state
   * across certain code portions (an example is #GtkMenu), to achieve this,
   * the following sequence can be used:
   *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -105,11 +128,11 @@</span>
   * ]|
   */
  
  
  /* --- macros --- */
<span class="udiff-line-modified-removed">- #define PARAM_SPEC_PARAM_ID(pspec)      ((pspec)-&gt;param_id)</span>
<span class="udiff-line-modified-added">+ #define PARAM_SPEC_PARAM_ID(pspec)    ((pspec)-&gt;param_id)</span>
  #define PARAM_SPEC_SET_PARAM_ID(pspec, id)  ((pspec)-&gt;param_id = (id))
  
  #define OBJECT_HAS_TOGGLE_REF_FLAG 0x1
  #define OBJECT_HAS_TOGGLE_REF(object) \
      ((g_datalist_get_flags (&amp;(object)-&gt;qdata) &amp; OBJECT_HAS_TOGGLE_REF_FLAG) != 0)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -139,52 +162,52 @@</span>
    PROP_NONE
  };
  
  
  /* --- prototypes --- */
<span class="udiff-line-modified-removed">- static void g_object_base_class_init        (GObjectClass   *class);</span>
<span class="udiff-line-modified-removed">- static void g_object_base_class_finalize        (GObjectClass   *class);</span>
<span class="udiff-line-modified-removed">- static void g_object_do_class_init          (GObjectClass   *class);</span>
<span class="udiff-line-modified-removed">- static void g_object_init               (GObject    *object,</span>
<span class="udiff-line-modified-removed">-                              GObjectClass   *class);</span>
<span class="udiff-line-modified-removed">- static GObject* g_object_constructor            (GType                  type,</span>
<span class="udiff-line-modified-removed">-                              guint                  n_construct_properties,</span>
<span class="udiff-line-modified-removed">-                              GObjectConstructParam *construct_params);</span>
<span class="udiff-line-modified-added">+ static void g_object_base_class_init    (GObjectClass *class);</span>
<span class="udiff-line-modified-added">+ static void g_object_base_class_finalize    (GObjectClass *class);</span>
<span class="udiff-line-modified-added">+ static void g_object_do_class_init      (GObjectClass *class);</span>
<span class="udiff-line-modified-added">+ static void g_object_init       (GObject  *object,</span>
<span class="udiff-line-modified-added">+                GObjectClass *class);</span>
<span class="udiff-line-modified-added">+ static GObject* g_object_constructor      (GType                  type,</span>
<span class="udiff-line-modified-added">+                guint                  n_construct_properties,</span>
<span class="udiff-line-modified-added">+                GObjectConstructParam *construct_params);</span>
  static void     g_object_constructed                    (GObject        *object);
<span class="udiff-line-modified-removed">- static void g_object_real_dispose           (GObject    *object);</span>
<span class="udiff-line-modified-removed">- static void g_object_finalize           (GObject    *object);</span>
<span class="udiff-line-modified-removed">- static void g_object_do_set_property        (GObject        *object,</span>
<span class="udiff-line-modified-removed">-                              guint           property_id,</span>
<span class="udiff-line-modified-removed">-                              const GValue   *value,</span>
<span class="udiff-line-modified-removed">-                              GParamSpec     *pspec);</span>
<span class="udiff-line-modified-removed">- static void g_object_do_get_property        (GObject        *object,</span>
<span class="udiff-line-modified-removed">-                              guint           property_id,</span>
<span class="udiff-line-modified-removed">-                              GValue         *value,</span>
<span class="udiff-line-modified-removed">-                              GParamSpec     *pspec);</span>
<span class="udiff-line-modified-removed">- static void g_value_object_init         (GValue     *value);</span>
<span class="udiff-line-modified-removed">- static void g_value_object_free_value       (GValue     *value);</span>
<span class="udiff-line-modified-removed">- static void g_value_object_copy_value       (const GValue   *src_value,</span>
<span class="udiff-line-modified-removed">-                              GValue     *dest_value);</span>
<span class="udiff-line-modified-removed">- static void g_value_object_transform_value      (const GValue   *src_value,</span>
<span class="udiff-line-modified-removed">-                              GValue     *dest_value);</span>
<span class="udiff-line-modified-added">+ static void g_object_real_dispose     (GObject  *object);</span>
<span class="udiff-line-modified-added">+ static void g_object_finalize     (GObject  *object);</span>
<span class="udiff-line-modified-added">+ static void g_object_do_set_property    (GObject        *object,</span>
<span class="udiff-line-modified-added">+                guint           property_id,</span>
<span class="udiff-line-modified-added">+                const GValue   *value,</span>
<span class="udiff-line-modified-added">+                GParamSpec     *pspec);</span>
<span class="udiff-line-modified-added">+ static void g_object_do_get_property    (GObject        *object,</span>
<span class="udiff-line-modified-added">+                guint           property_id,</span>
<span class="udiff-line-modified-added">+                GValue         *value,</span>
<span class="udiff-line-modified-added">+                GParamSpec     *pspec);</span>
<span class="udiff-line-modified-added">+ static void g_value_object_init     (GValue   *value);</span>
<span class="udiff-line-modified-added">+ static void g_value_object_free_value   (GValue   *value);</span>
<span class="udiff-line-modified-added">+ static void g_value_object_copy_value   (const GValue *src_value,</span>
<span class="udiff-line-modified-added">+                GValue   *dest_value);</span>
<span class="udiff-line-modified-added">+ static void g_value_object_transform_value    (const GValue *src_value,</span>
<span class="udiff-line-modified-added">+                GValue   *dest_value);</span>
  static gpointer g_value_object_peek_pointer             (const GValue   *value);
<span class="udiff-line-modified-removed">- static gchar*   g_value_object_collect_value        (GValue     *value,</span>
<span class="udiff-line-modified-removed">-                              guint           n_collect_values,</span>
<span class="udiff-line-modified-removed">-                              GTypeCValue    *collect_values,</span>
<span class="udiff-line-modified-removed">-                              guint           collect_flags);</span>
<span class="udiff-line-modified-removed">- static gchar*   g_value_object_lcopy_value      (const GValue   *value,</span>
<span class="udiff-line-modified-removed">-                              guint           n_collect_values,</span>
<span class="udiff-line-modified-removed">-                              GTypeCValue    *collect_values,</span>
<span class="udiff-line-modified-removed">-                              guint           collect_flags);</span>
<span class="udiff-line-modified-removed">- static void g_object_dispatch_properties_changed    (GObject    *object,</span>
<span class="udiff-line-modified-removed">-                              guint       n_pspecs,</span>
<span class="udiff-line-modified-removed">-                              GParamSpec    **pspecs);</span>
<span class="udiff-line-modified-added">+ static gchar* g_value_object_collect_value    (GValue   *value,</span>
<span class="udiff-line-modified-added">+                guint           n_collect_values,</span>
<span class="udiff-line-modified-added">+                GTypeCValue    *collect_values,</span>
<span class="udiff-line-modified-added">+                guint           collect_flags);</span>
<span class="udiff-line-modified-added">+ static gchar* g_value_object_lcopy_value    (const GValue *value,</span>
<span class="udiff-line-modified-added">+                guint           n_collect_values,</span>
<span class="udiff-line-modified-added">+                GTypeCValue    *collect_values,</span>
<span class="udiff-line-modified-added">+                guint           collect_flags);</span>
<span class="udiff-line-modified-added">+ static void g_object_dispatch_properties_changed  (GObject  *object,</span>
<span class="udiff-line-modified-added">+                guint     n_pspecs,</span>
<span class="udiff-line-modified-added">+                GParamSpec    **pspecs);</span>
  static guint               object_floating_flag_handler (GObject        *object,
                                                           gint            job);
  
  static void object_interface_check_properties           (gpointer        check_data,
<span class="udiff-line-modified-removed">-                              gpointer        g_iface);</span>
<span class="udiff-line-modified-added">+                gpointer        g_iface);</span>
  
  /* --- typedefs --- */
  typedef struct _GObjectNotifyQueue            GObjectNotifyQueue;
  
  struct _GObjectNotifyQueue
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -196,20 +219,20 @@</span>
  
  /* --- variables --- */
  G_LOCK_DEFINE_STATIC (closure_array_mutex);
  G_LOCK_DEFINE_STATIC (weak_refs_mutex);
  G_LOCK_DEFINE_STATIC (toggle_refs_mutex);
<span class="udiff-line-modified-removed">- static GQuark               quark_closure_array = 0;</span>
<span class="udiff-line-modified-removed">- static GQuark               quark_weak_refs = 0;</span>
<span class="udiff-line-modified-removed">- static GQuark               quark_toggle_refs = 0;</span>
<span class="udiff-line-modified-added">+ static GQuark             quark_closure_array = 0;</span>
<span class="udiff-line-modified-added">+ static GQuark             quark_weak_refs = 0;</span>
<span class="udiff-line-modified-added">+ static GQuark             quark_toggle_refs = 0;</span>
  static GQuark               quark_notify_queue;
  static GQuark               quark_in_construction;
  static GParamSpecPool      *pspec_pool = NULL;
<span class="udiff-line-modified-removed">- static gulong               gobject_signals[LAST_SIGNAL] = { 0, };</span>
<span class="udiff-line-modified-added">+ static gulong             gobject_signals[LAST_SIGNAL] = { 0, };</span>
  static guint (*floating_flag_handler) (GObject*, gint) = object_floating_flag_handler;
  /* qdata pointing to GSList&lt;GWeakRef *&gt;, protected by weak_locations_lock */
<span class="udiff-line-modified-removed">- static GQuark               quark_weak_locations = 0;</span>
<span class="udiff-line-modified-added">+ static GQuark             quark_weak_locations = 0;</span>
  static GRWLock              weak_locations_lock;
  
  G_LOCK_DEFINE_STATIC(notify_lock);
  
  /* --- functions --- */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -261,11 +284,10 @@</span>
  {
    GParamSpec *pspecs_mem[16], **pspecs, **free_me = NULL;
    GSList *slist;
    guint n_pspecs = 0;
  
<span class="udiff-line-removed">-   g_return_if_fail (nqueue-&gt;freeze_count &gt; 0);</span>
    g_return_if_fail (g_atomic_int_get(&amp;object-&gt;ref_count) &gt; 0);
  
    G_LOCK(notify_lock);
  
    /* Just make sure we never get into some nasty race condition */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -315,24 +337,24 @@</span>
    G_UNLOCK(notify_lock);
  }
  
  #ifdef  G_ENABLE_DEBUG
  G_LOCK_DEFINE_STATIC     (debug_objects);
<span class="udiff-line-modified-removed">- static guint         debug_objects_count = 0;</span>
<span class="udiff-line-modified-removed">- static GHashTable   *debug_objects_ht = NULL;</span>
<span class="udiff-line-modified-added">+ static guint     debug_objects_count = 0;</span>
<span class="udiff-line-modified-added">+ static GHashTable *debug_objects_ht = NULL;</span>
  
  static void
  debug_objects_foreach (gpointer key,
<span class="udiff-line-modified-removed">-                gpointer value,</span>
<span class="udiff-line-modified-removed">-                gpointer user_data)</span>
<span class="udiff-line-modified-added">+            gpointer value,</span>
<span class="udiff-line-modified-added">+            gpointer user_data)</span>
  {
    GObject *object = value;
  
    g_message (&quot;[%p] stale %s\tref_count=%u&quot;,
<span class="udiff-line-modified-removed">-          object,</span>
<span class="udiff-line-modified-removed">-          G_OBJECT_TYPE_NAME (object),</span>
<span class="udiff-line-modified-removed">-          object-&gt;ref_count);</span>
<span class="udiff-line-modified-added">+        object,</span>
<span class="udiff-line-modified-added">+        G_OBJECT_TYPE_NAME (object),</span>
<span class="udiff-line-modified-added">+        object-&gt;ref_count);</span>
  }
  
  #ifdef G_HAS_CONSTRUCTORS
  #ifdef G_DEFINE_DESTRUCTOR_NEEDS_PRAGMA
  #pragma G_DEFINE_DESTRUCTOR_PRAGMA_ARGS(debug_objects_atexit)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -363,28 +385,28 @@</span>
    GTypeInfo info = {
      sizeof (GObjectClass),
      (GBaseInitFunc) g_object_base_class_init,
      (GBaseFinalizeFunc) g_object_base_class_finalize,
      (GClassInitFunc) g_object_do_class_init,
<span class="udiff-line-modified-removed">-     NULL    /* class_destroy */,</span>
<span class="udiff-line-modified-removed">-     NULL    /* class_data */,</span>
<span class="udiff-line-modified-added">+     NULL  /* class_destroy */,</span>
<span class="udiff-line-modified-added">+     NULL  /* class_data */,</span>
      sizeof (GObject),
<span class="udiff-line-modified-removed">-     0       /* n_preallocs */,</span>
<span class="udiff-line-modified-added">+     0   /* n_preallocs */,</span>
      (GInstanceInitFunc) g_object_init,
<span class="udiff-line-modified-removed">-     NULL,   /* value_table */</span>
<span class="udiff-line-modified-added">+     NULL, /* value_table */</span>
    };
    static const GTypeValueTable value_table = {
<span class="udiff-line-modified-removed">-     g_value_object_init,      /* value_init */</span>
<span class="udiff-line-modified-added">+     g_value_object_init,    /* value_init */</span>
      g_value_object_free_value,    /* value_free */
      g_value_object_copy_value,    /* value_copy */
      g_value_object_peek_pointer,  /* value_peek_pointer */
<span class="udiff-line-modified-removed">-     &quot;p&quot;,              /* collect_format */</span>
<span class="udiff-line-modified-added">+     &quot;p&quot;,        /* collect_format */</span>
      g_value_object_collect_value, /* collect_value */
<span class="udiff-line-modified-removed">-     &quot;p&quot;,              /* lcopy_format */</span>
<span class="udiff-line-modified-added">+     &quot;p&quot;,        /* lcopy_format */</span>
      g_value_object_lcopy_value,   /* lcopy_value */
    };
<span class="udiff-line-modified-removed">-   GType type;</span>
<span class="udiff-line-modified-added">+   GType type G_GNUC_UNUSED  /* when compiling with G_DISABLE_ASSERT */;</span>
  
    g_return_if_fail (initialized == FALSE);
    initialized = TRUE;
  
    /* G_TYPE_OBJECT
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -501,34 +523,34 @@</span>
     * [canonical parameter names][canonical-parameter-names] as
     * detail strings for the notify signal.
     */
    gobject_signals[NOTIFY] =
      g_signal_new (g_intern_static_string (&quot;notify&quot;),
<span class="udiff-line-modified-removed">-           G_TYPE_FROM_CLASS (class),</span>
<span class="udiff-line-modified-removed">-           G_SIGNAL_RUN_FIRST | G_SIGNAL_NO_RECURSE | G_SIGNAL_DETAILED | G_SIGNAL_NO_HOOKS | G_SIGNAL_ACTION,</span>
<span class="udiff-line-modified-removed">-           G_STRUCT_OFFSET (GObjectClass, notify),</span>
<span class="udiff-line-modified-removed">-           NULL, NULL,</span>
<span class="udiff-line-modified-removed">-           g_cclosure_marshal_VOID__PARAM,</span>
<span class="udiff-line-modified-removed">-           G_TYPE_NONE,</span>
<span class="udiff-line-modified-removed">-           1, G_TYPE_PARAM);</span>
<span class="udiff-line-modified-added">+       G_TYPE_FROM_CLASS (class),</span>
<span class="udiff-line-modified-added">+       G_SIGNAL_RUN_FIRST | G_SIGNAL_NO_RECURSE | G_SIGNAL_DETAILED | G_SIGNAL_NO_HOOKS | G_SIGNAL_ACTION,</span>
<span class="udiff-line-modified-added">+       G_STRUCT_OFFSET (GObjectClass, notify),</span>
<span class="udiff-line-modified-added">+       NULL, NULL,</span>
<span class="udiff-line-modified-added">+       NULL,</span>
<span class="udiff-line-modified-added">+       G_TYPE_NONE,</span>
<span class="udiff-line-modified-added">+       1, G_TYPE_PARAM);</span>
  
    /* Install a check function that we&#39;ll use to verify that classes that
     * implement an interface implement all properties for that interface
     */
    g_type_add_interface_check (NULL, object_interface_check_properties);
  }
  
  static inline gboolean
  install_property_internal (GType       g_type,
<span class="udiff-line-modified-removed">-                guint       property_id,</span>
<span class="udiff-line-modified-removed">-                GParamSpec *pspec)</span>
<span class="udiff-line-modified-added">+          guint       property_id,</span>
<span class="udiff-line-modified-added">+          GParamSpec *pspec)</span>
  {
    if (g_param_spec_pool_lookup (pspec_pool, pspec-&gt;name, g_type, FALSE))
      {
        g_warning (&quot;When installing property: type &#39;%s&#39; already has a property named &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          g_type_name (g_type),</span>
<span class="udiff-line-modified-removed">-          pspec-&gt;name);</span>
<span class="udiff-line-modified-added">+      g_type_name (g_type),</span>
<span class="udiff-line-modified-added">+      pspec-&gt;name);</span>
        return FALSE;
      }
  
    g_param_spec_ref_sink (pspec);
    PARAM_SPEC_SET_PARAM_ID (pspec, property_id);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -538,11 +560,11 @@</span>
  
  static gboolean
  validate_pspec_to_install (GParamSpec *pspec)
  {
    g_return_val_if_fail (G_IS_PARAM_SPEC (pspec), FALSE);
<span class="udiff-line-modified-removed">-   g_return_val_if_fail (PARAM_SPEC_PARAM_ID (pspec) == 0, FALSE);   /* paranoid */</span>
<span class="udiff-line-modified-added">+   g_return_val_if_fail (PARAM_SPEC_PARAM_ID (pspec) == 0, FALSE); /* paranoid */</span>
  
    g_return_val_if_fail (pspec-&gt;flags &amp; (G_PARAM_READABLE | G_PARAM_WRITABLE), FALSE);
  
    if (pspec-&gt;flags &amp; G_PARAM_CONSTRUCT)
      g_return_val_if_fail ((pspec-&gt;flags &amp; G_PARAM_CONSTRUCT_ONLY) == 0, FALSE);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -604,12 +626,12 @@</span>
   * by installing a property with the same name. This can be useful at times,
   * e.g. to change the range of allowed values or the default value.
   */
  void
  g_object_class_install_property (GObjectClass *class,
<span class="udiff-line-modified-removed">-                  guint         property_id,</span>
<span class="udiff-line-modified-removed">-                                  GParamSpec   *pspec)</span>
<span class="udiff-line-modified-added">+          guint         property_id,</span>
<span class="udiff-line-modified-added">+          GParamSpec   *pspec)</span>
  {
    GType oclass_type, parent_type;
  
    g_return_if_fail (G_IS_OBJECT_CLASS (class));
    g_return_if_fail (property_id &gt; 0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -759,11 +781,11 @@</span>
   *
   * Since: 2.4
   */
  void
  g_object_interface_install_property (gpointer      g_iface,
<span class="udiff-line-modified-removed">-                      GParamSpec   *pspec)</span>
<span class="udiff-line-modified-added">+              GParamSpec   *pspec)</span>
  {
    GTypeInterface *iface_class = g_iface;
  
    g_return_if_fail (G_TYPE_IS_INTERFACE (iface_class-&gt;g_type));
    g_return_if_fail (!G_IS_PARAM_SPEC_OVERRIDE (pspec)); /* paranoid */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -784,39 +806,39 @@</span>
   * Returns: (transfer none): the #GParamSpec for the property, or
   *          %NULL if the class doesn&#39;t have a property of that name
   */
  GParamSpec*
  g_object_class_find_property (GObjectClass *class,
<span class="udiff-line-modified-removed">-                   const gchar  *property_name)</span>
<span class="udiff-line-modified-added">+             const gchar  *property_name)</span>
  {
    GParamSpec *pspec;
    GParamSpec *redirect;
  
    g_return_val_if_fail (G_IS_OBJECT_CLASS (class), NULL);
    g_return_val_if_fail (property_name != NULL, NULL);
  
    pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="udiff-line-modified-removed">-                     property_name,</span>
<span class="udiff-line-modified-removed">-                     G_OBJECT_CLASS_TYPE (class),</span>
<span class="udiff-line-modified-removed">-                     TRUE);</span>
<span class="udiff-line-modified-added">+             property_name,</span>
<span class="udiff-line-modified-added">+             G_OBJECT_CLASS_TYPE (class),</span>
<span class="udiff-line-modified-added">+             TRUE);</span>
    if (pspec)
      {
        redirect = g_param_spec_get_redirect_target (pspec);
        if (redirect)
<span class="udiff-line-modified-removed">-     return redirect;</span>
<span class="udiff-line-modified-added">+   return redirect;</span>
        else
<span class="udiff-line-modified-removed">-     return pspec;</span>
<span class="udiff-line-modified-added">+   return pspec;</span>
      }
    else
      return NULL;
  }
  
  /**
   * g_object_interface_find_property:
   * @g_iface: (type GObject.TypeInterface): any interface vtable for the
   *  interface, or the default vtable for the interface
<span class="udiff-line-modified-removed">-  * @property_name: name of a property to lookup.</span>
<span class="udiff-line-modified-added">+  * @property_name: name of a property to look up.</span>
   *
   * Find the #GParamSpec with the given name for an
   * interface. Generally, the interface vtable passed in as @g_iface
   * will be the default vtable from g_type_default_interface_ref(), or,
   * if you know the interface has already been loaded,
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -828,21 +850,21 @@</span>
   *          interface with the name @property_name, or %NULL if no
   *          such property exists.
   */
  GParamSpec*
  g_object_interface_find_property (gpointer      g_iface,
<span class="udiff-line-modified-removed">-                   const gchar  *property_name)</span>
<span class="udiff-line-modified-added">+           const gchar  *property_name)</span>
  {
    GTypeInterface *iface_class = g_iface;
  
    g_return_val_if_fail (G_TYPE_IS_INTERFACE (iface_class-&gt;g_type), NULL);
    g_return_val_if_fail (property_name != NULL, NULL);
  
    return g_param_spec_pool_lookup (pspec_pool,
<span class="udiff-line-modified-removed">-                    property_name,</span>
<span class="udiff-line-modified-removed">-                    iface_class-&gt;g_type,</span>
<span class="udiff-line-modified-removed">-                    FALSE);</span>
<span class="udiff-line-modified-added">+            property_name,</span>
<span class="udiff-line-modified-added">+            iface_class-&gt;g_type,</span>
<span class="udiff-line-modified-added">+            FALSE);</span>
  }
  
  /**
   * g_object_class_override_property:
   * @oclass: a #GObjectClass
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -869,12 +891,12 @@</span>
   *
   * Since: 2.4
   */
  void
  g_object_class_override_property (GObjectClass *oclass,
<span class="udiff-line-modified-removed">-                   guint         property_id,</span>
<span class="udiff-line-modified-removed">-                   const gchar  *name)</span>
<span class="udiff-line-modified-added">+           guint         property_id,</span>
<span class="udiff-line-modified-added">+           const gchar  *name)</span>
  {
    GParamSpec *overridden = NULL;
    GParamSpec *new;
    GType parent_type;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -885,36 +907,36 @@</span>
    /* Find the overridden property; first check parent types
     */
    parent_type = g_type_parent (G_OBJECT_CLASS_TYPE (oclass));
    if (parent_type != G_TYPE_NONE)
      overridden = g_param_spec_pool_lookup (pspec_pool,
<span class="udiff-line-modified-removed">-                        name,</span>
<span class="udiff-line-modified-removed">-                        parent_type,</span>
<span class="udiff-line-modified-removed">-                        TRUE);</span>
<span class="udiff-line-modified-added">+              name,</span>
<span class="udiff-line-modified-added">+              parent_type,</span>
<span class="udiff-line-modified-added">+              TRUE);</span>
    if (!overridden)
      {
        GType *ifaces;
        guint n_ifaces;
  
        /* Now check interfaces
         */
        ifaces = g_type_interfaces (G_OBJECT_CLASS_TYPE (oclass), &amp;n_ifaces);
        while (n_ifaces-- &amp;&amp; !overridden)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       overridden = g_param_spec_pool_lookup (pspec_pool,</span>
<span class="udiff-line-modified-removed">-                          name,</span>
<span class="udiff-line-modified-removed">-                          ifaces[n_ifaces],</span>
<span class="udiff-line-modified-removed">-                          FALSE);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     overridden = g_param_spec_pool_lookup (pspec_pool,</span>
<span class="udiff-line-modified-added">+              name,</span>
<span class="udiff-line-modified-added">+              ifaces[n_ifaces],</span>
<span class="udiff-line-modified-added">+              FALSE);</span>
<span class="udiff-line-modified-added">+   }</span>
  
        g_free (ifaces);
      }
  
    if (!overridden)
      {
        g_warning (&quot;%s: Can&#39;t find property to override for &#39;%s::%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          G_STRFUNC, G_OBJECT_CLASS_NAME (oclass), name);</span>
<span class="udiff-line-modified-added">+      G_STRFUNC, G_OBJECT_CLASS_NAME (oclass), name);</span>
        return;
      }
  
    new = g_param_spec_override (name, overridden);
    g_object_class_install_property (oclass, property_id, new);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -930,20 +952,20 @@</span>
   * Returns: (array length=n_properties) (transfer container): an array of
   *          #GParamSpec* which should be freed after use
   */
  GParamSpec** /* free result */
  g_object_class_list_properties (GObjectClass *class,
<span class="udiff-line-modified-removed">-                 guint        *n_properties_p)</span>
<span class="udiff-line-modified-added">+         guint        *n_properties_p)</span>
  {
    GParamSpec **pspecs;
    guint n;
  
    g_return_val_if_fail (G_IS_OBJECT_CLASS (class), NULL);
  
    pspecs = g_param_spec_pool_list (pspec_pool,
<span class="udiff-line-modified-removed">-                    G_OBJECT_CLASS_TYPE (class),</span>
<span class="udiff-line-modified-removed">-                    &amp;n);</span>
<span class="udiff-line-modified-added">+            G_OBJECT_CLASS_TYPE (class),</span>
<span class="udiff-line-modified-added">+            &amp;n);</span>
    if (n_properties_p)
      *n_properties_p = n;
  
    return pspecs;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -967,21 +989,21 @@</span>
   *          array should be freed with g_free() when you are done with
   *          it.
   */
  GParamSpec**
  g_object_interface_list_properties (gpointer      g_iface,
<span class="udiff-line-modified-removed">-                     guint        *n_properties_p)</span>
<span class="udiff-line-modified-added">+             guint        *n_properties_p)</span>
  {
    GTypeInterface *iface_class = g_iface;
    GParamSpec **pspecs;
    guint n;
  
    g_return_val_if_fail (G_TYPE_IS_INTERFACE (iface_class-&gt;g_type), NULL);
  
    pspecs = g_param_spec_pool_list (pspec_pool,
<span class="udiff-line-modified-removed">-                    iface_class-&gt;g_type,</span>
<span class="udiff-line-modified-removed">-                    &amp;n);</span>
<span class="udiff-line-modified-added">+            iface_class-&gt;g_type,</span>
<span class="udiff-line-modified-added">+            &amp;n);</span>
    if (n_properties_p)
      *n_properties_p = n;
  
    return pspecs;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -991,12 +1013,12 @@</span>
  {
    return g_datalist_id_get_data (&amp;object-&gt;qdata, quark_in_construction) != NULL;
  }
  
  static void
<span class="udiff-line-modified-removed">- g_object_init (GObject      *object,</span>
<span class="udiff-line-modified-removed">-            GObjectClass *class)</span>
<span class="udiff-line-modified-added">+ g_object_init (GObject    *object,</span>
<span class="udiff-line-modified-added">+          GObjectClass *class)</span>
  {
    object-&gt;ref_count = 1;
    object-&gt;qdata = NULL;
  
    if (CLASS_HAS_PROPS (class))
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1020,13 +1042,13 @@</span>
      });
  }
  
  static void
  g_object_do_set_property (GObject      *object,
<span class="udiff-line-modified-removed">-               guint         property_id,</span>
<span class="udiff-line-modified-removed">-               const GValue *value,</span>
<span class="udiff-line-modified-removed">-               GParamSpec   *pspec)</span>
<span class="udiff-line-modified-added">+         guint         property_id,</span>
<span class="udiff-line-modified-added">+         const GValue *value,</span>
<span class="udiff-line-modified-added">+         GParamSpec   *pspec)</span>
  {
    switch (property_id)
      {
      default:
        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1034,13 +1056,13 @@</span>
      }
  }
  
  static void
  g_object_do_get_property (GObject     *object,
<span class="udiff-line-modified-removed">-               guint        property_id,</span>
<span class="udiff-line-modified-removed">-               GValue      *value,</span>
<span class="udiff-line-modified-removed">-               GParamSpec  *pspec)</span>
<span class="udiff-line-modified-added">+         guint        property_id,</span>
<span class="udiff-line-modified-added">+         GValue      *value,</span>
<span class="udiff-line-modified-added">+         GParamSpec  *pspec)</span>
  {
    switch (property_id)
      {
      default:
        G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1077,12 +1099,12 @@</span>
      });
  }
  
  static void
  g_object_dispatch_properties_changed (GObject     *object,
<span class="udiff-line-modified-removed">-                       guint        n_pspecs,</span>
<span class="udiff-line-modified-removed">-                       GParamSpec **pspecs)</span>
<span class="udiff-line-modified-added">+               guint        n_pspecs,</span>
<span class="udiff-line-modified-added">+               GParamSpec **pspecs)</span>
  {
    guint i;
  
    for (i = 0; i &lt; n_pspecs; i++)
      g_signal_emit (object, gobject_signals[NOTIFY], g_param_spec_get_name_quark (pspecs[i]), pspecs[i]);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1099,11 +1121,11 @@</span>
   */
  void
  g_object_run_dispose (GObject *object)
  {
    g_return_if_fail (G_IS_OBJECT (object));
<span class="udiff-line-modified-removed">-   g_return_if_fail (object-&gt;ref_count &gt; 0);</span>
<span class="udiff-line-modified-added">+   g_return_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt; 0);</span>
  
    g_object_ref (object);
    TRACE (GOBJECT_OBJECT_DISPOSE(object,G_TYPE_FROM_INSTANCE(object), 0));
    G_OBJECT_GET_CLASS (object)-&gt;dispose (object);
    TRACE (GOBJECT_OBJECT_DISPOSE_END(object,G_TYPE_FROM_INSTANCE(object), 0));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1155,11 +1177,11 @@</span>
    return pspec;
  }
  
  static inline void
  g_object_notify_by_spec_internal (GObject    *object,
<span class="udiff-line-modified-removed">-                   GParamSpec *pspec)</span>
<span class="udiff-line-modified-added">+           GParamSpec *pspec)</span>
  {
    GParamSpec *notify_pspec;
  
    notify_pspec = get_notify_pspec (pspec);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1199,11 +1221,11 @@</span>
   * and will be emitted (in reverse order) when g_object_thaw_notify() is
   * called.
   */
  void
  g_object_notify (GObject     *object,
<span class="udiff-line-modified-removed">-          const gchar *property_name)</span>
<span class="udiff-line-modified-added">+      const gchar *property_name)</span>
  {
    GParamSpec *pspec;
  
    g_return_if_fail (G_IS_OBJECT (object));
    g_return_if_fail (property_name != NULL);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1214,19 +1236,19 @@</span>
    /* We don&#39;t need to get the redirect target
     * (by, e.g. calling g_object_class_find_property())
     * because g_object_notify_queue_add() does that
     */
    pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="udiff-line-modified-removed">-                     property_name,</span>
<span class="udiff-line-modified-removed">-                     G_OBJECT_TYPE (object),</span>
<span class="udiff-line-modified-removed">-                     TRUE);</span>
<span class="udiff-line-modified-added">+             property_name,</span>
<span class="udiff-line-modified-added">+             G_OBJECT_TYPE (object),</span>
<span class="udiff-line-modified-added">+             TRUE);</span>
  
    if (!pspec)
      g_warning (&quot;%s: object class &#39;%s&#39; has no property named &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-            G_STRFUNC,</span>
<span class="udiff-line-modified-removed">-            G_OBJECT_TYPE_NAME (object),</span>
<span class="udiff-line-modified-removed">-            property_name);</span>
<span class="udiff-line-modified-added">+          G_STRFUNC,</span>
<span class="udiff-line-modified-added">+          G_OBJECT_TYPE_NAME (object),</span>
<span class="udiff-line-modified-added">+          property_name);</span>
    else
      g_object_notify_by_spec_internal (object, pspec);
    g_object_unref (object);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1276,11 +1298,11 @@</span>
   *
   * Since: 2.26
   */
  void
  g_object_notify_by_pspec (GObject    *object,
<span class="udiff-line-modified-removed">-               GParamSpec *pspec)</span>
<span class="udiff-line-modified-added">+         GParamSpec *pspec)</span>
  {
  
    g_return_if_fail (G_IS_OBJECT (object));
    g_return_if_fail (G_IS_PARAM_SPEC (pspec));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1377,12 +1399,12 @@</span>
                 g_type_name (pspec-&gt;owner_type), pspec-&gt;name);
  }
  
  static inline void
  object_get_property (GObject     *object,
<span class="udiff-line-modified-removed">-              GParamSpec  *pspec,</span>
<span class="udiff-line-modified-removed">-              GValue      *value)</span>
<span class="udiff-line-modified-added">+          GParamSpec  *pspec,</span>
<span class="udiff-line-modified-added">+          GValue      *value)</span>
  {
    GObjectClass *class = g_type_class_peek (pspec-&gt;owner_type);
    guint param_id = PARAM_SPEC_PARAM_ID (pspec);
    GParamSpec *redirect;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1402,13 +1424,13 @@</span>
    class-&gt;get_property (object, param_id, value, pspec);
  }
  
  static inline void
  object_set_property (GObject             *object,
<span class="udiff-line-modified-removed">-              GParamSpec          *pspec,</span>
<span class="udiff-line-modified-removed">-              const GValue        *value,</span>
<span class="udiff-line-modified-removed">-              GObjectNotifyQueue  *nqueue)</span>
<span class="udiff-line-modified-added">+          GParamSpec          *pspec,</span>
<span class="udiff-line-modified-added">+          const GValue        *value,</span>
<span class="udiff-line-modified-added">+          GObjectNotifyQueue  *nqueue)</span>
  {
    GValue tmp_value = G_VALUE_INIT;
    GObjectClass *class = g_type_class_peek (pspec-&gt;owner_type);
    guint param_id = PARAM_SPEC_PARAM_ID (pspec);
    GParamSpec *redirect;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1426,22 +1448,22 @@</span>
  
    /* provide a copy to work from, convert (if necessary) and validate */
    g_value_init (&amp;tmp_value, pspec-&gt;value_type);
    if (!g_value_transform (value, &amp;tmp_value))
      g_warning (&quot;unable to set property &#39;%s&#39; of type &#39;%s&#39; from value of type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-            pspec-&gt;name,</span>
<span class="udiff-line-modified-removed">-            g_type_name (pspec-&gt;value_type),</span>
<span class="udiff-line-modified-removed">-            G_VALUE_TYPE_NAME (value));</span>
<span class="udiff-line-modified-added">+          pspec-&gt;name,</span>
<span class="udiff-line-modified-added">+          g_type_name (pspec-&gt;value_type),</span>
<span class="udiff-line-modified-added">+          G_VALUE_TYPE_NAME (value));</span>
    else if (g_param_value_validate (pspec, &amp;tmp_value) &amp;&amp; !(pspec-&gt;flags &amp; G_PARAM_LAX_VALIDATION))
      {
        gchar *contents = g_strdup_value_contents (value);
  
        g_warning (&quot;value \&quot;%s\&quot; of type &#39;%s&#39; is invalid or out of range for property &#39;%s&#39; of type &#39;%s&#39;&quot;,
<span class="udiff-line-modified-removed">-          contents,</span>
<span class="udiff-line-modified-removed">-          G_VALUE_TYPE_NAME (value),</span>
<span class="udiff-line-modified-removed">-          pspec-&gt;name,</span>
<span class="udiff-line-modified-removed">-          g_type_name (pspec-&gt;value_type));</span>
<span class="udiff-line-modified-added">+      contents,</span>
<span class="udiff-line-modified-added">+      G_VALUE_TYPE_NAME (value),</span>
<span class="udiff-line-modified-added">+      pspec-&gt;name,</span>
<span class="udiff-line-modified-added">+      g_type_name (pspec-&gt;value_type));</span>
        g_free (contents);
      }
    else
      {
        class-&gt;set_property (object, param_id, &amp;tmp_value, pspec);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1459,11 +1481,11 @@</span>
    g_value_unset (&amp;tmp_value);
  }
  
  static void
  object_interface_check_properties (gpointer check_data,
<span class="udiff-line-modified-removed">-                    gpointer g_iface)</span>
<span class="udiff-line-modified-added">+            gpointer g_iface)</span>
  {
    GTypeInterface *iface_class = g_iface;
    GObjectClass *class;
    GType iface_type = iface_class-&gt;g_type;
    GParamSpec **pspecs;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1480,24 +1502,24 @@</span>
    pspecs = g_param_spec_pool_list (pspec_pool, iface_type, &amp;n);
  
    while (n--)
      {
        GParamSpec *class_pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="udiff-line-modified-removed">-                               pspecs[n]-&gt;name,</span>
<span class="udiff-line-modified-removed">-                               G_OBJECT_CLASS_TYPE (class),</span>
<span class="udiff-line-modified-removed">-                               TRUE);</span>
<span class="udiff-line-modified-added">+                 pspecs[n]-&gt;name,</span>
<span class="udiff-line-modified-added">+                 G_OBJECT_CLASS_TYPE (class),</span>
<span class="udiff-line-modified-added">+                 TRUE);</span>
  
        if (!class_pspec)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_critical (&quot;Object class %s doesn&#39;t implement property &quot;</span>
<span class="udiff-line-modified-removed">-               &quot;&#39;%s&#39; from interface &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-               g_type_name (G_OBJECT_CLASS_TYPE (class)),</span>
<span class="udiff-line-modified-removed">-               pspecs[n]-&gt;name,</span>
<span class="udiff-line-modified-removed">-               g_type_name (iface_type));</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-       continue;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_critical (&quot;Object class %s doesn&#39;t implement property &quot;</span>
<span class="udiff-line-modified-added">+           &quot;&#39;%s&#39; from interface &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+           g_type_name (G_OBJECT_CLASS_TYPE (class)),</span>
<span class="udiff-line-modified-added">+           pspecs[n]-&gt;name,</span>
<span class="udiff-line-modified-added">+           g_type_name (iface_type));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+     continue;</span>
<span class="udiff-line-modified-added">+   }</span>
  
        /* We do a number of checks on the properties of an interface to
         * make sure that all classes implementing the interface are
         * overriding the properties in a sane way.
         *
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1632,12 +1654,12 @@</span>
   * Returns: (transfer full) (type GObject.Object): a new instance of
   *   @object_type
   */
  gpointer
  g_object_new (GType    object_type,
<span class="udiff-line-modified-removed">-               const gchar *first_property_name,</span>
<span class="udiff-line-modified-removed">-               ...)</span>
<span class="udiff-line-modified-added">+         const gchar *first_property_name,</span>
<span class="udiff-line-modified-added">+         ...)</span>
  {
    GObject *object;
    va_list var_args;
  
    /* short circuit for calls supplying no properties */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1705,11 +1727,11 @@</span>
              consider_issuing_property_deprecation_warning (pspec);
              value = params[j].value;
              break;
            }
  
<span class="udiff-line-modified-removed">-       if (j == n_params)</span>
<span class="udiff-line-modified-added">+       if (value == NULL)</span>
          {
            value = &amp;cvalues[cvals_used++];
            g_value_init (value, pspec-&gt;value_type);
            g_param_value_set_default (pspec, value);
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1831,11 +1853,11 @@</span>
                  consider_issuing_property_deprecation_warning (pspec);
                  value = params[j].value;
                  break;
                }
  
<span class="udiff-line-modified-removed">-           if (j == n_params)</span>
<span class="udiff-line-modified-added">+           if (value == NULL)</span>
              value = g_param_spec_get_default_value (pspec);
  
            object_set_property (object, pspec, value, nqueue);
          }
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1993,10 +2015,11 @@</span>
   * @object_type
   *
   * Deprecated: 2.54: Use g_object_new_with_properties() instead.
   * deprecated. See #GParameter for more information.
   */
<span class="udiff-line-added">+ G_GNUC_BEGIN_IGNORE_DEPRECATIONS</span>
  gpointer
  g_object_newv (GType       object_type,
                 guint       n_parameters,
                 GParameter *parameters)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2044,10 +2067,11 @@</span>
    if (unref_class)
      g_type_class_unref (unref_class);
  
    return object;
  }
<span class="udiff-line-added">+ G_GNUC_END_IGNORE_DEPRECATIONS</span>
  
  /**
   * g_object_new_valist: (skip)
   * @object_type: the type id of the #GObject subtype to instantiate
   * @first_property_name: the name of the first property
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2143,12 +2167,12 @@</span>
    return object;
  }
  
  static GObject*
  g_object_constructor (GType                  type,
<span class="udiff-line-modified-removed">-               guint                  n_construct_properties,</span>
<span class="udiff-line-modified-removed">-               GObjectConstructParam *construct_params)</span>
<span class="udiff-line-modified-added">+           guint                  n_construct_properties,</span>
<span class="udiff-line-modified-added">+           GObjectConstructParam *construct_params)</span>
  {
    GObject *object;
  
    /* create object */
    object = (GObject*) g_type_create_instance (type);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2158,17 +2182,17 @@</span>
      {
        GObjectNotifyQueue *nqueue = g_object_notify_queue_freeze (object, FALSE);
  
        /* set construct properties */
        while (n_construct_properties--)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       GValue *value = construct_params-&gt;value;</span>
<span class="udiff-line-modified-removed">-       GParamSpec *pspec = construct_params-&gt;pspec;</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     GValue *value = construct_params-&gt;value;</span>
<span class="udiff-line-modified-added">+     GParamSpec *pspec = construct_params-&gt;pspec;</span>
  
<span class="udiff-line-modified-removed">-       construct_params++;</span>
<span class="udiff-line-modified-removed">-       object_set_property (object, pspec, value, nqueue);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     construct_params++;</span>
<span class="udiff-line-modified-added">+     object_set_property (object, pspec, value, nqueue);</span>
<span class="udiff-line-modified-added">+   }</span>
        g_object_notify_queue_thaw (object, nqueue);
        /* the notification queue is still frozen from g_object_init(), so
         * we don&#39;t need to handle it here, g_object_newv() takes
         * care of that
         */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2265,13 +2289,13 @@</span>
   *  name/value pairs, followed by %NULL
   *
   * Sets properties on an object.
   */
  void
<span class="udiff-line-modified-removed">- g_object_set_valist (GObject     *object,</span>
<span class="udiff-line-modified-removed">-                      const gchar *first_property_name,</span>
<span class="udiff-line-modified-removed">-              va_list      var_args)</span>
<span class="udiff-line-modified-added">+ g_object_set_valist (GObject   *object,</span>
<span class="udiff-line-modified-added">+          const gchar *first_property_name,</span>
<span class="udiff-line-modified-added">+          va_list    var_args)</span>
  {
    GObjectNotifyQueue *nqueue;
    const gchar *name;
  
    g_return_if_fail (G_IS_OBJECT (object));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2285,26 +2309,26 @@</span>
        GValue value = G_VALUE_INIT;
        GParamSpec *pspec;
        gchar *error = NULL;
  
        pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="udiff-line-modified-removed">-                     name,</span>
<span class="udiff-line-modified-removed">-                     G_OBJECT_TYPE (object),</span>
<span class="udiff-line-modified-removed">-                     TRUE);</span>
<span class="udiff-line-modified-added">+           name,</span>
<span class="udiff-line-modified-added">+           G_OBJECT_TYPE (object),</span>
<span class="udiff-line-modified-added">+           TRUE);</span>
  
        if (!g_object_set_is_valid_property (object, pspec, name))
          break;
  
        G_VALUE_COLLECT_INIT (&amp;value, pspec-&gt;value_type, var_args,
<span class="udiff-line-modified-removed">-                 0, &amp;error);</span>
<span class="udiff-line-modified-added">+           0, &amp;error);</span>
        if (error)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;%s: %s&quot;, G_STRFUNC, error);</span>
<span class="udiff-line-modified-removed">-       g_free (error);</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;%s: %s&quot;, G_STRFUNC, error);</span>
<span class="udiff-line-modified-added">+     g_free (error);</span>
            g_value_unset (&amp;value);
<span class="udiff-line-modified-removed">-       break;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     break;</span>
<span class="udiff-line-modified-added">+   }</span>
  
        consider_issuing_property_deprecation_warning (pspec);
        object_set_property (object, pspec, &amp;value, nqueue);
        g_value_unset (&amp;value);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2368,13 +2392,13 @@</span>
  
    obj_type = G_OBJECT_TYPE (object);
    for (i = 0; i &lt; n_properties; i++)
      {
        pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="udiff-line-modified-removed">-                         names[i],</span>
<span class="udiff-line-modified-removed">-                         obj_type,</span>
<span class="udiff-line-modified-removed">-                         TRUE);</span>
<span class="udiff-line-modified-added">+                 names[i],</span>
<span class="udiff-line-modified-added">+                 obj_type,</span>
<span class="udiff-line-modified-added">+                 TRUE);</span>
        if (!g_object_get_is_valid_property (object, pspec, names[i]))
          break;
  
        memset (&amp;values[i], 0, sizeof (GValue));
        g_value_init (&amp;values[i], pspec-&gt;value_type);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2397,13 +2421,13 @@</span>
   * the type, for instance by calling g_free() or g_object_unref().
   *
   * See g_object_get().
   */
  void
<span class="udiff-line-modified-removed">- g_object_get_valist (GObject     *object,</span>
<span class="udiff-line-modified-removed">-                      const gchar *first_property_name,</span>
<span class="udiff-line-modified-removed">-              va_list      var_args)</span>
<span class="udiff-line-modified-added">+ g_object_get_valist (GObject   *object,</span>
<span class="udiff-line-modified-added">+          const gchar *first_property_name,</span>
<span class="udiff-line-modified-added">+          va_list    var_args)</span>
  {
    const gchar *name;
  
    g_return_if_fail (G_IS_OBJECT (object));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2416,29 +2440,29 @@</span>
        GValue value = G_VALUE_INIT;
        GParamSpec *pspec;
        gchar *error;
  
        pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="udiff-line-modified-removed">-                     name,</span>
<span class="udiff-line-modified-removed">-                     G_OBJECT_TYPE (object),</span>
<span class="udiff-line-modified-removed">-                     TRUE);</span>
<span class="udiff-line-modified-added">+           name,</span>
<span class="udiff-line-modified-added">+           G_OBJECT_TYPE (object),</span>
<span class="udiff-line-modified-added">+           TRUE);</span>
  
        if (!g_object_get_is_valid_property (object, pspec, name))
          break;
  
        g_value_init (&amp;value, pspec-&gt;value_type);
  
        object_get_property (object, pspec, &amp;value);
  
        G_VALUE_LCOPY (&amp;value, var_args, 0, &amp;error);
        if (error)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;%s: %s&quot;, G_STRFUNC, error);</span>
<span class="udiff-line-modified-removed">-       g_free (error);</span>
<span class="udiff-line-modified-removed">-       g_value_unset (&amp;value);</span>
<span class="udiff-line-modified-removed">-       break;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;%s: %s&quot;, G_STRFUNC, error);</span>
<span class="udiff-line-modified-added">+     g_free (error);</span>
<span class="udiff-line-modified-added">+     g_value_unset (&amp;value);</span>
<span class="udiff-line-modified-added">+     break;</span>
<span class="udiff-line-modified-added">+   }</span>
  
        g_value_unset (&amp;value);
  
        name = va_arg (var_args, gchar*);
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2459,12 +2483,12 @@</span>
   * reverse order) after all properties have been set. See
   * g_object_freeze_notify().
   */
  void
  g_object_set (gpointer     _object,
<span class="udiff-line-modified-removed">-           const gchar *first_property_name,</span>
<span class="udiff-line-modified-removed">-           ...)</span>
<span class="udiff-line-modified-added">+         const gchar *first_property_name,</span>
<span class="udiff-line-modified-added">+         ...)</span>
  {
    GObject *object = _object;
    va_list var_args;
  
    g_return_if_fail (G_IS_OBJECT (object));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2506,12 +2530,12 @@</span>
   *  g_object_unref (objval);
   *  ]|
   */
  void
  g_object_get (gpointer     _object,
<span class="udiff-line-modified-removed">-           const gchar *first_property_name,</span>
<span class="udiff-line-modified-removed">-           ...)</span>
<span class="udiff-line-modified-added">+         const gchar *first_property_name,</span>
<span class="udiff-line-modified-added">+         ...)</span>
  {
    GObject *object = _object;
    va_list var_args;
  
    g_return_if_fail (G_IS_OBJECT (object));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2529,81 +2553,93 @@</span>
   *
   * Sets a property on an object.
   */
  void
  g_object_set_property (GObject      *object,
<span class="udiff-line-modified-removed">-                        const gchar  *property_name,</span>
<span class="udiff-line-modified-removed">-                        const GValue *value)</span>
<span class="udiff-line-modified-added">+            const gchar  *property_name,</span>
<span class="udiff-line-modified-added">+            const GValue *value)</span>
  {
    g_object_setv (object, 1, &amp;property_name, value);
  }
  
  /**
   * g_object_get_property:
   * @object: a #GObject
   * @property_name: the name of the property to get
   * @value: return location for the property value
   *
<span class="udiff-line-modified-removed">-  * Gets a property of an object. @value must have been initialized to the</span>
<span class="udiff-line-modified-removed">-  * expected type of the property (or a type to which the expected type can be</span>
<span class="udiff-line-modified-removed">-  * transformed) using g_value_init().</span>
<span class="udiff-line-modified-added">+  * Gets a property of an object.</span>
<span class="udiff-line-modified-added">+  *</span>
<span class="udiff-line-modified-added">+  * The @value can be:</span>
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  *  - an empty #GValue initialized by %G_VALUE_INIT, which will be</span>
<span class="udiff-line-added">+  *    automatically initialized with the expected type of the property</span>
<span class="udiff-line-added">+  *    (since GLib 2.60)</span>
<span class="udiff-line-added">+  *  - a #GValue initialized with the expected type of the property</span>
<span class="udiff-line-added">+  *  - a #GValue initialized with a type to which the expected type</span>
<span class="udiff-line-added">+  *    of the property can be transformed</span>
   *
   * In general, a copy is made of the property contents and the caller is
   * responsible for freeing the memory by calling g_value_unset().
   *
   * Note that g_object_get_property() is really intended for language
   * bindings, g_object_get() is much more convenient for C programming.
   */
  void
  g_object_get_property (GObject     *object,
<span class="udiff-line-modified-removed">-                        const gchar *property_name,</span>
<span class="udiff-line-modified-removed">-                GValue      *value)</span>
<span class="udiff-line-modified-added">+            const gchar *property_name,</span>
<span class="udiff-line-modified-added">+            GValue    *value)</span>
  {
    GParamSpec *pspec;
  
    g_return_if_fail (G_IS_OBJECT (object));
    g_return_if_fail (property_name != NULL);
<span class="udiff-line-modified-removed">-   g_return_if_fail (G_IS_VALUE (value));</span>
<span class="udiff-line-modified-added">+   g_return_if_fail (value != NULL);</span>
  
    g_object_ref (object);
  
    pspec = g_param_spec_pool_lookup (pspec_pool,
<span class="udiff-line-modified-removed">-                     property_name,</span>
<span class="udiff-line-modified-removed">-                     G_OBJECT_TYPE (object),</span>
<span class="udiff-line-modified-removed">-                     TRUE);</span>
<span class="udiff-line-modified-added">+             property_name,</span>
<span class="udiff-line-modified-added">+             G_OBJECT_TYPE (object),</span>
<span class="udiff-line-modified-added">+             TRUE);</span>
  
    if (g_object_get_is_valid_property (object, pspec, property_name))
      {
        GValue *prop_value, tmp_value = G_VALUE_INIT;
  
<span class="udiff-line-modified-removed">-       /* auto-conversion of the callers value type</span>
<span class="udiff-line-modified-removed">-        */</span>
<span class="udiff-line-modified-removed">-       if (G_VALUE_TYPE (value) == pspec-&gt;value_type)</span>
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_value_reset (value);</span>
<span class="udiff-line-modified-removed">-       prop_value = value;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+       if (G_VALUE_TYPE (value) == G_TYPE_INVALID)</span>
<span class="udiff-line-modified-added">+         {</span>
<span class="udiff-line-modified-added">+           /* zero-initialized value */</span>
<span class="udiff-line-modified-added">+           g_value_init (value, pspec-&gt;value_type);</span>
<span class="udiff-line-modified-added">+           prop_value = value;</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+       else if (G_VALUE_TYPE (value) == pspec-&gt;value_type)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+           /* auto-conversion of the callers value type */</span>
<span class="udiff-line-added">+           g_value_reset (value);</span>
<span class="udiff-line-added">+           prop_value = value;</span>
<span class="udiff-line-added">+         }</span>
        else if (!g_value_type_transformable (pspec-&gt;value_type, G_VALUE_TYPE (value)))
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;%s: can&#39;t retrieve property &#39;%s&#39; of type &#39;%s&#39; as value of type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-              G_STRFUNC, pspec-&gt;name,</span>
<span class="udiff-line-modified-removed">-              g_type_name (pspec-&gt;value_type),</span>
<span class="udiff-line-modified-removed">-              G_VALUE_TYPE_NAME (value));</span>
<span class="udiff-line-modified-removed">-       g_object_unref (object);</span>
<span class="udiff-line-modified-removed">-       return;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+         {</span>
<span class="udiff-line-modified-added">+           g_warning (&quot;%s: can&#39;t retrieve property &#39;%s&#39; of type &#39;%s&#39; as value of type &#39;%s&#39;&quot;,</span>
<span class="udiff-line-modified-added">+                      G_STRFUNC, pspec-&gt;name,</span>
<span class="udiff-line-modified-added">+                      g_type_name (pspec-&gt;value_type),</span>
<span class="udiff-line-modified-added">+                      G_VALUE_TYPE_NAME (value));</span>
<span class="udiff-line-modified-added">+           g_object_unref (object);</span>
<span class="udiff-line-modified-added">+           return;</span>
<span class="udiff-line-modified-added">+         }</span>
        else
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_value_init (&amp;tmp_value, pspec-&gt;value_type);</span>
<span class="udiff-line-modified-removed">-       prop_value = &amp;tmp_value;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+         {</span>
<span class="udiff-line-modified-added">+           g_value_init (&amp;tmp_value, pspec-&gt;value_type);</span>
<span class="udiff-line-modified-added">+           prop_value = &amp;tmp_value;</span>
<span class="udiff-line-modified-added">+         }</span>
        object_get_property (object, pspec, prop_value);
        if (prop_value != value)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_value_transform (prop_value, value);</span>
<span class="udiff-line-modified-removed">-       g_value_unset (&amp;tmp_value);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+         {</span>
<span class="udiff-line-modified-added">+           g_value_transform (prop_value, value);</span>
<span class="udiff-line-modified-added">+           g_value_unset (&amp;tmp_value);</span>
<span class="udiff-line-modified-added">+         }</span>
      }
  
    g_object_unref (object);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2617,36 +2653,36 @@</span>
   *
   * A convenience function to connect multiple signals at once.
   *
   * The signal specs expected by this function have the form
   * &quot;modifier::signal_name&quot;, where modifier can be one of the following:
<span class="udiff-line-modified-removed">-  * * - signal: equivalent to g_signal_connect_data (..., NULL, 0)</span>
<span class="udiff-line-modified-added">+  * - signal: equivalent to g_signal_connect_data (..., NULL, 0)</span>
   * - object-signal, object_signal: equivalent to g_signal_connect_object (..., 0)
   * - swapped-signal, swapped_signal: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED)
   * - swapped_object_signal, swapped-object-signal: equivalent to g_signal_connect_object (..., G_CONNECT_SWAPPED)
   * - signal_after, signal-after: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_AFTER)
   * - object_signal_after, object-signal-after: equivalent to g_signal_connect_object (..., G_CONNECT_AFTER)
   * - swapped_signal_after, swapped-signal-after: equivalent to g_signal_connect_data (..., NULL, G_CONNECT_SWAPPED | G_CONNECT_AFTER)
   * - swapped_object_signal_after, swapped-object-signal-after: equivalent to g_signal_connect_object (..., G_CONNECT_SWAPPED | G_CONNECT_AFTER)
   *
   * |[&lt;!-- language=&quot;C&quot; --&gt;
   *   menu-&gt;toplevel = g_object_connect (g_object_new (GTK_TYPE_WINDOW,
<span class="udiff-line-modified-removed">-  *                         &quot;type&quot;, GTK_WINDOW_POPUP,</span>
<span class="udiff-line-modified-removed">-  *                         &quot;child&quot;, menu,</span>
<span class="udiff-line-modified-removed">-  *                         NULL),</span>
<span class="udiff-line-modified-removed">-  *                   &quot;signal::event&quot;, gtk_menu_window_event, menu,</span>
<span class="udiff-line-modified-removed">-  *                   &quot;signal::size_request&quot;, gtk_menu_window_size_request, menu,</span>
<span class="udiff-line-modified-removed">-  *                   &quot;signal::destroy&quot;, gtk_widget_destroyed, &amp;menu-&gt;toplevel,</span>
<span class="udiff-line-modified-removed">-  *                   NULL);</span>
<span class="udiff-line-modified-added">+  *               &quot;type&quot;, GTK_WINDOW_POPUP,</span>
<span class="udiff-line-modified-added">+  *               &quot;child&quot;, menu,</span>
<span class="udiff-line-modified-added">+  *               NULL),</span>
<span class="udiff-line-modified-added">+  *             &quot;signal::event&quot;, gtk_menu_window_event, menu,</span>
<span class="udiff-line-modified-added">+  *             &quot;signal::size_request&quot;, gtk_menu_window_size_request, menu,</span>
<span class="udiff-line-modified-added">+  *             &quot;signal::destroy&quot;, gtk_widget_destroyed, &amp;menu-&gt;toplevel,</span>
<span class="udiff-line-modified-added">+  *             NULL);</span>
   * ]|
   *
   * Returns: (transfer none) (type GObject.Object): @object
   */
  gpointer
  g_object_connect (gpointer     _object,
<span class="udiff-line-modified-removed">-           const gchar *signal_spec,</span>
<span class="udiff-line-modified-removed">-           ...)</span>
<span class="udiff-line-modified-added">+       const gchar *signal_spec,</span>
<span class="udiff-line-modified-added">+       ...)</span>
  {
    GObject *object = _object;
    va_list var_args;
  
    g_return_val_if_fail (G_IS_OBJECT (object), NULL);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2657,53 +2693,53 @@</span>
      {
        GCallback callback = va_arg (var_args, GCallback);
        gpointer data = va_arg (var_args, gpointer);
  
        if (strncmp (signal_spec, &quot;signal::&quot;, 8) == 0)
<span class="udiff-line-modified-removed">-     g_signal_connect_data (object, signal_spec + 8,</span>
<span class="udiff-line-modified-removed">-                    callback, data, NULL,</span>
<span class="udiff-line-modified-removed">-                    0);</span>
<span class="udiff-line-modified-added">+   g_signal_connect_data (object, signal_spec + 8,</span>
<span class="udiff-line-modified-added">+              callback, data, NULL,</span>
<span class="udiff-line-modified-added">+              0);</span>
        else if (strncmp (signal_spec, &quot;object_signal::&quot;, 15) == 0 ||
                 strncmp (signal_spec, &quot;object-signal::&quot;, 15) == 0)
<span class="udiff-line-modified-removed">-     g_signal_connect_object (object, signal_spec + 15,</span>
<span class="udiff-line-modified-removed">-                  callback, data,</span>
<span class="udiff-line-modified-removed">-                  0);</span>
<span class="udiff-line-modified-added">+   g_signal_connect_object (object, signal_spec + 15,</span>
<span class="udiff-line-modified-added">+          callback, data,</span>
<span class="udiff-line-modified-added">+          0);</span>
        else if (strncmp (signal_spec, &quot;swapped_signal::&quot;, 16) == 0 ||
                 strncmp (signal_spec, &quot;swapped-signal::&quot;, 16) == 0)
<span class="udiff-line-modified-removed">-     g_signal_connect_data (object, signal_spec + 16,</span>
<span class="udiff-line-modified-removed">-                    callback, data, NULL,</span>
<span class="udiff-line-modified-removed">-                    G_CONNECT_SWAPPED);</span>
<span class="udiff-line-modified-added">+   g_signal_connect_data (object, signal_spec + 16,</span>
<span class="udiff-line-modified-added">+              callback, data, NULL,</span>
<span class="udiff-line-modified-added">+              G_CONNECT_SWAPPED);</span>
        else if (strncmp (signal_spec, &quot;swapped_object_signal::&quot;, 23) == 0 ||
                 strncmp (signal_spec, &quot;swapped-object-signal::&quot;, 23) == 0)
<span class="udiff-line-modified-removed">-     g_signal_connect_object (object, signal_spec + 23,</span>
<span class="udiff-line-modified-removed">-                  callback, data,</span>
<span class="udiff-line-modified-removed">-                  G_CONNECT_SWAPPED);</span>
<span class="udiff-line-modified-added">+   g_signal_connect_object (object, signal_spec + 23,</span>
<span class="udiff-line-modified-added">+          callback, data,</span>
<span class="udiff-line-modified-added">+          G_CONNECT_SWAPPED);</span>
        else if (strncmp (signal_spec, &quot;signal_after::&quot;, 14) == 0 ||
                 strncmp (signal_spec, &quot;signal-after::&quot;, 14) == 0)
<span class="udiff-line-modified-removed">-     g_signal_connect_data (object, signal_spec + 14,</span>
<span class="udiff-line-modified-removed">-                    callback, data, NULL,</span>
<span class="udiff-line-modified-removed">-                    G_CONNECT_AFTER);</span>
<span class="udiff-line-modified-added">+   g_signal_connect_data (object, signal_spec + 14,</span>
<span class="udiff-line-modified-added">+              callback, data, NULL,</span>
<span class="udiff-line-modified-added">+              G_CONNECT_AFTER);</span>
        else if (strncmp (signal_spec, &quot;object_signal_after::&quot;, 21) == 0 ||
                 strncmp (signal_spec, &quot;object-signal-after::&quot;, 21) == 0)
<span class="udiff-line-modified-removed">-     g_signal_connect_object (object, signal_spec + 21,</span>
<span class="udiff-line-modified-removed">-                  callback, data,</span>
<span class="udiff-line-modified-removed">-                  G_CONNECT_AFTER);</span>
<span class="udiff-line-modified-added">+   g_signal_connect_object (object, signal_spec + 21,</span>
<span class="udiff-line-modified-added">+          callback, data,</span>
<span class="udiff-line-modified-added">+          G_CONNECT_AFTER);</span>
        else if (strncmp (signal_spec, &quot;swapped_signal_after::&quot;, 22) == 0 ||
                 strncmp (signal_spec, &quot;swapped-signal-after::&quot;, 22) == 0)
<span class="udiff-line-modified-removed">-     g_signal_connect_data (object, signal_spec + 22,</span>
<span class="udiff-line-modified-removed">-                    callback, data, NULL,</span>
<span class="udiff-line-modified-removed">-                    G_CONNECT_SWAPPED | G_CONNECT_AFTER);</span>
<span class="udiff-line-modified-added">+   g_signal_connect_data (object, signal_spec + 22,</span>
<span class="udiff-line-modified-added">+              callback, data, NULL,</span>
<span class="udiff-line-modified-added">+              G_CONNECT_SWAPPED | G_CONNECT_AFTER);</span>
        else if (strncmp (signal_spec, &quot;swapped_object_signal_after::&quot;, 29) == 0 ||
                 strncmp (signal_spec, &quot;swapped-object-signal-after::&quot;, 29) == 0)
<span class="udiff-line-modified-removed">-     g_signal_connect_object (object, signal_spec + 29,</span>
<span class="udiff-line-modified-removed">-                  callback, data,</span>
<span class="udiff-line-modified-removed">-                  G_CONNECT_SWAPPED | G_CONNECT_AFTER);</span>
<span class="udiff-line-modified-added">+   g_signal_connect_object (object, signal_spec + 29,</span>
<span class="udiff-line-modified-added">+          callback, data,</span>
<span class="udiff-line-modified-added">+          G_CONNECT_SWAPPED | G_CONNECT_AFTER);</span>
        else
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;%s: invalid signal spec \&quot;%s\&quot;&quot;, G_STRFUNC, signal_spec);</span>
<span class="udiff-line-modified-removed">-       break;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;%s: invalid signal spec \&quot;%s\&quot;&quot;, G_STRFUNC, signal_spec);</span>
<span class="udiff-line-modified-added">+     break;</span>
<span class="udiff-line-modified-added">+   }</span>
        signal_spec = va_arg (var_args, gchar*);
      }
    va_end (var_args);
  
    return object;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2724,12 +2760,12 @@</span>
   * callback and data, or &quot;any_signal::signal_name&quot;, which only
   * disconnects the signal named &quot;signal_name&quot;.
   */
  void
  g_object_disconnect (gpointer     _object,
<span class="udiff-line-modified-removed">-              const gchar *signal_spec,</span>
<span class="udiff-line-modified-removed">-              ...)</span>
<span class="udiff-line-modified-added">+          const gchar *signal_spec,</span>
<span class="udiff-line-modified-added">+          ...)</span>
  {
    GObject *object = _object;
    va_list var_args;
  
    g_return_if_fail (G_IS_OBJECT (object));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2742,33 +2778,33 @@</span>
        gpointer data = va_arg (var_args, gpointer);
        guint sid = 0, detail = 0, mask = 0;
  
        if (strncmp (signal_spec, &quot;any_signal::&quot;, 12) == 0 ||
            strncmp (signal_spec, &quot;any-signal::&quot;, 12) == 0)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       signal_spec += 12;</span>
<span class="udiff-line-modified-removed">-       mask = G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     signal_spec += 12;</span>
<span class="udiff-line-modified-added">+     mask = G_SIGNAL_MATCH_ID | G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA;</span>
<span class="udiff-line-modified-added">+   }</span>
        else if (strcmp (signal_spec, &quot;any_signal&quot;) == 0 ||
                 strcmp (signal_spec, &quot;any-signal&quot;) == 0)
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       signal_spec += 10;</span>
<span class="udiff-line-modified-removed">-       mask = G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     signal_spec += 10;</span>
<span class="udiff-line-modified-added">+     mask = G_SIGNAL_MATCH_FUNC | G_SIGNAL_MATCH_DATA;</span>
<span class="udiff-line-modified-added">+   }</span>
        else
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       g_warning (&quot;%s: invalid signal spec \&quot;%s\&quot;&quot;, G_STRFUNC, signal_spec);</span>
<span class="udiff-line-modified-removed">-       break;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     g_warning (&quot;%s: invalid signal spec \&quot;%s\&quot;&quot;, G_STRFUNC, signal_spec);</span>
<span class="udiff-line-modified-added">+     break;</span>
<span class="udiff-line-modified-added">+   }</span>
  
        if ((mask &amp; G_SIGNAL_MATCH_ID) &amp;&amp;
<span class="udiff-line-modified-removed">-       !g_signal_parse_name (signal_spec, G_OBJECT_TYPE (object), &amp;sid, &amp;detail, FALSE))</span>
<span class="udiff-line-modified-removed">-     g_warning (&quot;%s: invalid signal name \&quot;%s\&quot;&quot;, G_STRFUNC, signal_spec);</span>
<span class="udiff-line-modified-added">+     !g_signal_parse_name (signal_spec, G_OBJECT_TYPE (object), &amp;sid, &amp;detail, FALSE))</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;%s: invalid signal name \&quot;%s\&quot;&quot;, G_STRFUNC, signal_spec);</span>
        else if (!g_signal_handlers_disconnect_matched (object, mask | (detail ? G_SIGNAL_MATCH_DETAIL : 0),
<span class="udiff-line-modified-removed">-                               sid, detail,</span>
<span class="udiff-line-modified-removed">-                               NULL, (gpointer)callback, data))</span>
<span class="udiff-line-modified-removed">-     g_warning (&quot;%s: signal handler %p(%p) is not connected&quot;, G_STRFUNC, callback, data);</span>
<span class="udiff-line-modified-added">+                   sid, detail,</span>
<span class="udiff-line-modified-added">+                   NULL, (gpointer)callback, data))</span>
<span class="udiff-line-modified-added">+   g_warning (&quot;%s: signal handler %p(%p) is not connected&quot;, G_STRFUNC, callback, data);</span>
        signal_spec = va_arg (var_args, gchar*);
      }
    va_end (var_args);
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2809,19 +2845,19 @@</span>
   * object&#39;s last g_object_unref() might happen in another thread.
   * Use #GWeakRef if thread-safety is required.
   */
  void
  g_object_weak_ref (GObject    *object,
<span class="udiff-line-modified-removed">-            GWeakNotify notify,</span>
<span class="udiff-line-modified-removed">-            gpointer    data)</span>
<span class="udiff-line-modified-added">+        GWeakNotify notify,</span>
<span class="udiff-line-modified-added">+        gpointer    data)</span>
  {
    WeakRefStack *wstack;
    guint i;
  
    g_return_if_fail (G_IS_OBJECT (object));
    g_return_if_fail (notify != NULL);
<span class="udiff-line-modified-removed">-   g_return_if_fail (object-&gt;ref_count &gt;= 1);</span>
<span class="udiff-line-modified-added">+   g_return_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt;= 1);</span>
  
    G_LOCK (weak_refs_mutex);
    wstack = g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark_weak_refs);
    if (wstack)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2849,12 +2885,12 @@</span>
   *
   * Removes a weak reference callback to an object.
   */
  void
  g_object_weak_unref (GObject    *object,
<span class="udiff-line-modified-removed">-              GWeakNotify notify,</span>
<span class="udiff-line-modified-removed">-              gpointer    data)</span>
<span class="udiff-line-modified-added">+          GWeakNotify notify,</span>
<span class="udiff-line-modified-added">+          gpointer    data)</span>
  {
    WeakRefStack *wstack;
    gboolean found_one = FALSE;
  
    g_return_if_fail (G_IS_OBJECT (object));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2865,20 +2901,20 @@</span>
    if (wstack)
      {
        guint i;
  
        for (i = 0; i &lt; wstack-&gt;n_weak_refs; i++)
<span class="udiff-line-modified-removed">-     if (wstack-&gt;weak_refs[i].notify == notify &amp;&amp;</span>
<span class="udiff-line-modified-removed">-         wstack-&gt;weak_refs[i].data == data)</span>
<span class="udiff-line-modified-removed">-       {</span>
<span class="udiff-line-modified-removed">-         found_one = TRUE;</span>
<span class="udiff-line-modified-removed">-         wstack-&gt;n_weak_refs -= 1;</span>
<span class="udiff-line-modified-removed">-         if (i != wstack-&gt;n_weak_refs)</span>
<span class="udiff-line-modified-removed">-           wstack-&gt;weak_refs[i] = wstack-&gt;weak_refs[wstack-&gt;n_weak_refs];</span>
<span class="udiff-line-modified-added">+   if (wstack-&gt;weak_refs[i].notify == notify &amp;&amp;</span>
<span class="udiff-line-modified-added">+       wstack-&gt;weak_refs[i].data == data)</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       found_one = TRUE;</span>
<span class="udiff-line-modified-added">+       wstack-&gt;n_weak_refs -= 1;</span>
<span class="udiff-line-modified-added">+       if (i != wstack-&gt;n_weak_refs)</span>
<span class="udiff-line-modified-added">+         wstack-&gt;weak_refs[i] = wstack-&gt;weak_refs[wstack-&gt;n_weak_refs];</span>
  
<span class="udiff-line-modified-removed">-         break;</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-added">+       break;</span>
<span class="udiff-line-modified-added">+     }</span>
      }
    G_UNLOCK (weak_refs_mutex);
    if (!found_one)
      g_warning (&quot;%s: couldn&#39;t find weak ref %p(%p)&quot;, G_STRFUNC, notify, data);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2999,11 +3035,11 @@</span>
  (g_object_ref_sink) (gpointer _object)
  {
    GObject *object = _object;
    gboolean was_floating;
    g_return_val_if_fail (G_IS_OBJECT (object), object);
<span class="udiff-line-modified-removed">-   g_return_val_if_fail (object-&gt;ref_count &gt;= 1, object);</span>
<span class="udiff-line-modified-added">+   g_return_val_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt;= 1, object);</span>
    g_object_ref (object);
    was_floating = floating_flag_handler (object, -1);
    if (was_floating)
      g_object_unref (object);
    return object;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3022,11 +3058,11 @@</span>
   */
  void
  g_object_force_floating (GObject *object)
  {
    g_return_if_fail (G_IS_OBJECT (object));
<span class="udiff-line-modified-removed">-   g_return_if_fail (object-&gt;ref_count &gt;= 1);</span>
<span class="udiff-line-modified-added">+   g_return_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt;= 1);</span>
  
    floating_flag_handler (object, +1);
  }
  
  typedef struct {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3038,11 +3074,11 @@</span>
    } toggle_refs[1];  /* flexible array */
  } ToggleRefStack;
  
  static void
  toggle_refs_notify (GObject *object,
<span class="udiff-line-modified-removed">-             gboolean is_last_ref)</span>
<span class="udiff-line-modified-added">+         gboolean is_last_ref)</span>
  {
    ToggleRefStack tstack, *tstackptr;
  
    G_LOCK (toggle_refs_mutex);
    tstackptr = g_datalist_id_get_data (&amp;object-&gt;qdata, quark_toggle_refs);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3095,19 +3131,19 @@</span>
   *
   * Since: 2.8
   */
  void
  g_object_add_toggle_ref (GObject       *object,
<span class="udiff-line-modified-removed">-              GToggleNotify  notify,</span>
<span class="udiff-line-modified-removed">-              gpointer       data)</span>
<span class="udiff-line-modified-added">+        GToggleNotify  notify,</span>
<span class="udiff-line-modified-added">+        gpointer       data)</span>
  {
    ToggleRefStack *tstack;
    guint i;
  
    g_return_if_fail (G_IS_OBJECT (object));
    g_return_if_fail (notify != NULL);
<span class="udiff-line-modified-removed">-   g_return_if_fail (object-&gt;ref_count &gt;= 1);</span>
<span class="udiff-line-modified-added">+   g_return_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt;= 1);</span>
  
    g_object_ref (object);
  
    G_LOCK (toggle_refs_mutex);
    tstack = g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark_toggle_refs);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3131,11 +3167,11 @@</span>
      g_datalist_set_flags (&amp;object-&gt;qdata, OBJECT_HAS_TOGGLE_REF_FLAG);
  
    tstack-&gt;toggle_refs[i].notify = notify;
    tstack-&gt;toggle_refs[i].data = data;
    g_datalist_id_set_data_full (&amp;object-&gt;qdata, quark_toggle_refs, tstack,
<span class="udiff-line-modified-removed">-                    (GDestroyNotify)g_free);</span>
<span class="udiff-line-modified-added">+              (GDestroyNotify)g_free);</span>
    G_UNLOCK (toggle_refs_mutex);
  }
  
  /**
   * g_object_remove_toggle_ref: (skip)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3150,12 +3186,12 @@</span>
   *
   * Since: 2.8
   */
  void
  g_object_remove_toggle_ref (GObject       *object,
<span class="udiff-line-modified-removed">-                 GToggleNotify  notify,</span>
<span class="udiff-line-modified-removed">-                 gpointer       data)</span>
<span class="udiff-line-modified-added">+           GToggleNotify  notify,</span>
<span class="udiff-line-modified-added">+           gpointer       data)</span>
  {
    ToggleRefStack *tstack;
    gboolean found_one = FALSE;
  
    g_return_if_fail (G_IS_OBJECT (object));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3166,23 +3202,23 @@</span>
    if (tstack)
      {
        guint i;
  
        for (i = 0; i &lt; tstack-&gt;n_toggle_refs; i++)
<span class="udiff-line-modified-removed">-     if (tstack-&gt;toggle_refs[i].notify == notify &amp;&amp;</span>
<span class="udiff-line-modified-removed">-         tstack-&gt;toggle_refs[i].data == data)</span>
<span class="udiff-line-modified-removed">-       {</span>
<span class="udiff-line-modified-removed">-         found_one = TRUE;</span>
<span class="udiff-line-modified-removed">-         tstack-&gt;n_toggle_refs -= 1;</span>
<span class="udiff-line-modified-removed">-         if (i != tstack-&gt;n_toggle_refs)</span>
<span class="udiff-line-modified-removed">-           tstack-&gt;toggle_refs[i] = tstack-&gt;toggle_refs[tstack-&gt;n_toggle_refs];</span>
<span class="udiff-line-modified-added">+   if (tstack-&gt;toggle_refs[i].notify == notify &amp;&amp;</span>
<span class="udiff-line-modified-added">+       tstack-&gt;toggle_refs[i].data == data)</span>
<span class="udiff-line-modified-added">+     {</span>
<span class="udiff-line-modified-added">+       found_one = TRUE;</span>
<span class="udiff-line-modified-added">+       tstack-&gt;n_toggle_refs -= 1;</span>
<span class="udiff-line-modified-added">+       if (i != tstack-&gt;n_toggle_refs)</span>
<span class="udiff-line-modified-added">+         tstack-&gt;toggle_refs[i] = tstack-&gt;toggle_refs[tstack-&gt;n_toggle_refs];</span>
  
<span class="udiff-line-modified-removed">-         if (tstack-&gt;n_toggle_refs == 0)</span>
<span class="udiff-line-modified-removed">-           g_datalist_unset_flags (&amp;object-&gt;qdata, OBJECT_HAS_TOGGLE_REF_FLAG);</span>
<span class="udiff-line-modified-added">+       if (tstack-&gt;n_toggle_refs == 0)</span>
<span class="udiff-line-modified-added">+         g_datalist_unset_flags (&amp;object-&gt;qdata, OBJECT_HAS_TOGGLE_REF_FLAG);</span>
  
<span class="udiff-line-modified-removed">-         break;</span>
<span class="udiff-line-modified-removed">-       }</span>
<span class="udiff-line-modified-added">+       break;</span>
<span class="udiff-line-modified-added">+     }</span>
      }
    G_UNLOCK (toggle_refs_mutex);
  
    if (found_one)
      g_object_unref (object);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3208,13 +3244,13 @@</span>
  {
    GObject *object = _object;
    gint old_val;
  
    g_return_val_if_fail (G_IS_OBJECT (object), NULL);
<span class="udiff-line-removed">-   g_return_val_if_fail (object-&gt;ref_count &gt; 0, NULL);</span>
  
    old_val = g_atomic_int_add (&amp;object-&gt;ref_count, 1);
<span class="udiff-line-added">+   g_return_val_if_fail (old_val &gt; 0, NULL);</span>
  
    if (old_val == 1 &amp;&amp; OBJECT_HAS_TOGGLE_REF (object))
      toggle_refs_notify (object, FALSE);
  
    TRACE (GOBJECT_OBJECT_REF(object,G_TYPE_FROM_INSTANCE(object),old_val));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3239,28 +3275,27 @@</span>
  {
    GObject *object = _object;
    gint old_ref;
  
    g_return_if_fail (G_IS_OBJECT (object));
<span class="udiff-line-removed">-   g_return_if_fail (object-&gt;ref_count &gt; 0);</span>
  
    /* here we want to atomically do: if (ref_count&gt;1) { ref_count--; return; } */
   retry_atomic_decrement1:
    old_ref = g_atomic_int_get (&amp;object-&gt;ref_count);
    if (old_ref &gt; 1)
      {
        /* valid if last 2 refs are owned by this call to unref and the toggle_ref */
        gboolean has_toggle_ref = OBJECT_HAS_TOGGLE_REF (object);
  
        if (!g_atomic_int_compare_and_exchange ((int *)&amp;object-&gt;ref_count, old_ref, old_ref - 1))
<span class="udiff-line-modified-removed">-     goto retry_atomic_decrement1;</span>
<span class="udiff-line-modified-added">+   goto retry_atomic_decrement1;</span>
  
        TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));
  
        /* if we went from 2-&gt;1 we need to notify toggle refs if any */
        if (old_ref == 2 &amp;&amp; has_toggle_ref) /* The last ref being held in this case is owned by the toggle_ref */
<span class="udiff-line-modified-removed">-     toggle_refs_notify (object, TRUE);</span>
<span class="udiff-line-modified-added">+   toggle_refs_notify (object, TRUE);</span>
      }
    else
      {
        GSList **weak_locations;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3316,48 +3351,55 @@</span>
          {
            /* valid if last 2 refs are owned by this call to unref and the toggle_ref */
            gboolean has_toggle_ref = OBJECT_HAS_TOGGLE_REF (object);
  
            if (!g_atomic_int_compare_and_exchange ((int *)&amp;object-&gt;ref_count, old_ref, old_ref - 1))
<span class="udiff-line-modified-removed">-         goto retry_atomic_decrement2;</span>
<span class="udiff-line-modified-added">+       goto retry_atomic_decrement2;</span>
  
<span class="udiff-line-modified-removed">-       TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));</span>
<span class="udiff-line-modified-added">+     TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));</span>
  
            /* if we went from 2-&gt;1 we need to notify toggle refs if any */
            if (old_ref == 2 &amp;&amp; has_toggle_ref) /* The last ref being held in this case is owned by the toggle_ref */
<span class="udiff-line-modified-removed">-         toggle_refs_notify (object, TRUE);</span>
<span class="udiff-line-modified-added">+       toggle_refs_notify (object, TRUE);</span>
  
<span class="udiff-line-modified-removed">-       return;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     return;</span>
<span class="udiff-line-modified-added">+   }</span>
  
        /* we are still in the process of taking away the last ref */
        g_datalist_id_set_data (&amp;object-&gt;qdata, quark_closure_array, NULL);
        g_signal_handlers_destroy (object);
        g_datalist_id_set_data (&amp;object-&gt;qdata, quark_weak_refs, NULL);
  
        /* decrement the last reference */
        old_ref = g_atomic_int_add (&amp;object-&gt;ref_count, -1);
<span class="udiff-line-added">+       g_return_if_fail (old_ref &gt; 0);</span>
  
        TRACE (GOBJECT_OBJECT_UNREF(object,G_TYPE_FROM_INSTANCE(object),old_ref));
  
        /* may have been re-referenced meanwhile */
        if (G_LIKELY (old_ref == 1))
<span class="udiff-line-modified-removed">-     {</span>
<span class="udiff-line-modified-removed">-       TRACE (GOBJECT_OBJECT_FINALIZE(object,G_TYPE_FROM_INSTANCE(object)));</span>
<span class="udiff-line-modified-added">+   {</span>
<span class="udiff-line-modified-added">+     TRACE (GOBJECT_OBJECT_FINALIZE(object,G_TYPE_FROM_INSTANCE(object)));</span>
            G_OBJECT_GET_CLASS (object)-&gt;finalize (object);
  
<span class="udiff-line-modified-removed">-       TRACE (GOBJECT_OBJECT_FINALIZE_END(object,G_TYPE_FROM_INSTANCE(object)));</span>
<span class="udiff-line-modified-added">+     TRACE (GOBJECT_OBJECT_FINALIZE_END(object,G_TYPE_FROM_INSTANCE(object)));</span>
  
            GOBJECT_IF_DEBUG (OBJECTS,
<span class="udiff-line-modified-removed">-         {</span>
<span class="udiff-line-modified-removed">-           /* catch objects not chaining finalize handlers */</span>
<span class="udiff-line-modified-removed">-           G_LOCK (debug_objects);</span>
<span class="udiff-line-modified-removed">-           g_assert (!g_hash_table_contains (debug_objects_ht, object));</span>
<span class="udiff-line-modified-removed">-           G_UNLOCK (debug_objects);</span>
<span class="udiff-line-modified-removed">-         });</span>
<span class="udiff-line-modified-added">+       {</span>
<span class="udiff-line-modified-added">+               gboolean was_present;</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+               /* catch objects not chaining finalize handlers */</span>
<span class="udiff-line-modified-added">+               G_LOCK (debug_objects);</span>
<span class="udiff-line-modified-added">+               was_present = g_hash_table_remove (debug_objects_ht, object);</span>
<span class="udiff-line-added">+               G_UNLOCK (debug_objects);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+               if (was_present)</span>
<span class="udiff-line-added">+                 g_critical (&quot;Object %p of type %s not finalized correctly.&quot;,</span>
<span class="udiff-line-added">+                             object, G_OBJECT_TYPE_NAME (object));</span>
<span class="udiff-line-added">+       });</span>
            g_type_free_instance ((GTypeInstance*) object);
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+   }</span>
      }
  }
  
  /**
   * g_clear_object: (skip)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3393,11 +3435,11 @@</span>
   *
   * Returns: (transfer none) (nullable): The user data pointer set, or %NULL
   */
  gpointer
  g_object_get_qdata (GObject *object,
<span class="udiff-line-modified-removed">-             GQuark   quark)</span>
<span class="udiff-line-modified-added">+         GQuark   quark)</span>
  {
    g_return_val_if_fail (G_IS_OBJECT (object), NULL);
  
    return quark ? g_datalist_id_get_data (&amp;object-&gt;qdata, quark) : NULL;
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3417,12 +3459,12 @@</span>
   * the old pointer set, using #NULL as pointer essentially
   * removes the data stored.
   */
  void
  g_object_set_qdata (GObject *object,
<span class="udiff-line-modified-removed">-             GQuark   quark,</span>
<span class="udiff-line-modified-removed">-             gpointer data)</span>
<span class="udiff-line-modified-added">+         GQuark   quark,</span>
<span class="udiff-line-modified-added">+         gpointer data)</span>
  {
    g_return_if_fail (G_IS_OBJECT (object));
    g_return_if_fail (quark &gt; 0);
  
    g_datalist_id_set_data (&amp;object-&gt;qdata, quark, data);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3527,19 +3569,19 @@</span>
   * the data is being overwritten by a call to g_object_set_qdata()
   * with the same @quark.
   */
  void
  g_object_set_qdata_full (GObject       *object,
<span class="udiff-line-modified-removed">-              GQuark     quark,</span>
<span class="udiff-line-modified-removed">-              gpointer   data,</span>
<span class="udiff-line-modified-removed">-                          GDestroyNotify destroy)</span>
<span class="udiff-line-modified-added">+        GQuark   quark,</span>
<span class="udiff-line-modified-added">+        gpointer data,</span>
<span class="udiff-line-modified-added">+        GDestroyNotify destroy)</span>
  {
    g_return_if_fail (G_IS_OBJECT (object));
    g_return_if_fail (quark &gt; 0);
  
    g_datalist_id_set_data_full (&amp;object-&gt;qdata, quark, data,
<span class="udiff-line-modified-removed">-                    data ? destroy : (GDestroyNotify) NULL);</span>
<span class="udiff-line-modified-added">+              data ? destroy : (GDestroyNotify) NULL);</span>
  }
  
  /**
   * g_object_steal_qdata:
   * @object: The GObject to get a stored user data pointer from
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3583,11 +3625,11 @@</span>
   *
   * Returns: (transfer full) (nullable): The user data pointer set, or %NULL
   */
  gpointer
  g_object_steal_qdata (GObject *object,
<span class="udiff-line-modified-removed">-               GQuark   quark)</span>
<span class="udiff-line-modified-added">+           GQuark   quark)</span>
  {
    g_return_val_if_fail (G_IS_OBJECT (object), NULL);
    g_return_val_if_fail (quark &gt; 0, NULL);
  
    return g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3622,10 +3664,15 @@</span>
   * Each object carries around a table of associations from
   * strings to pointers.  This function lets you set an association.
   *
   * If the object already had an association with that name,
   * the old association will be destroyed.
<span class="udiff-line-added">+  *</span>
<span class="udiff-line-added">+  * Internally, the @key is converted to a #GQuark using g_quark_from_string().</span>
<span class="udiff-line-added">+  * This means a copy of @key is kept permanently (even after @object has been</span>
<span class="udiff-line-added">+  * finalized) - so it is recommended to only use a small, bounded set of values</span>
<span class="udiff-line-added">+  * for @key in your program, to avoid the #GQuark storage growing unbounded.</span>
   */
  void
  g_object_set_data (GObject     *object,
                     const gchar *key,
                     gpointer     data)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3700,10 +3747,13 @@</span>
   * the registered destroy notify for it (passed out in @old_destroy).
   * It&#39;s up to the caller to free this as needed, which may
   * or may not include using @old_destroy as sometimes replacement
   * should not destroy the object in the normal way.
   *
<span class="udiff-line-added">+  * See g_object_set_data() for guidance on using a small, bounded set of values</span>
<span class="udiff-line-added">+  * for @key.</span>
<span class="udiff-line-added">+  *</span>
   * Returns: %TRUE if the existing value for @key was replaced
   *  by @newval, %FALSE otherwise.
   *
   * Since: 2.34
   */
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3745,11 +3795,11 @@</span>
  {
    g_return_if_fail (G_IS_OBJECT (object));
    g_return_if_fail (key != NULL);
  
    g_datalist_id_set_data_full (&amp;object-&gt;qdata, g_quark_from_string (key), data,
<span class="udiff-line-modified-removed">-                    data ? destroy : (GDestroyNotify) NULL);</span>
<span class="udiff-line-modified-added">+              data ? destroy : (GDestroyNotify) NULL);</span>
  }
  
  /**
   * g_object_steal_data:
   * @object: #GObject containing the associations
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3788,21 +3838,21 @@</span>
      g_object_unref (value-&gt;data[0].v_pointer);
  }
  
  static void
  g_value_object_copy_value (const GValue *src_value,
<span class="udiff-line-modified-removed">-                GValue   *dest_value)</span>
<span class="udiff-line-modified-added">+          GValue *dest_value)</span>
  {
    if (src_value-&gt;data[0].v_pointer)
      dest_value-&gt;data[0].v_pointer = g_object_ref (src_value-&gt;data[0].v_pointer);
    else
      dest_value-&gt;data[0].v_pointer = NULL;
  }
  
  static void
  g_value_object_transform_value (const GValue *src_value,
<span class="udiff-line-modified-removed">-                 GValue       *dest_value)</span>
<span class="udiff-line-modified-added">+         GValue       *dest_value)</span>
  {
    if (src_value-&gt;data[0].v_pointer &amp;&amp; g_type_is_a (G_OBJECT_TYPE (src_value-&gt;data[0].v_pointer), G_VALUE_TYPE (dest_value)))
      dest_value-&gt;data[0].v_pointer = g_object_ref (src_value-&gt;data[0].v_pointer);
    else
      dest_value-&gt;data[0].v_pointer = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3813,31 +3863,31 @@</span>
  {
    return value-&gt;data[0].v_pointer;
  }
  
  static gchar*
<span class="udiff-line-modified-removed">- g_value_object_collect_value (GValue      *value,</span>
<span class="udiff-line-modified-removed">-                               guint        n_collect_values,</span>
<span class="udiff-line-modified-removed">-                               GTypeCValue *collect_values,</span>
<span class="udiff-line-modified-removed">-                               guint        collect_flags)</span>
<span class="udiff-line-modified-added">+ g_value_object_collect_value (GValue    *value,</span>
<span class="udiff-line-modified-added">+             guint        n_collect_values,</span>
<span class="udiff-line-modified-added">+             GTypeCValue *collect_values,</span>
<span class="udiff-line-modified-added">+             guint        collect_flags)</span>
  {
    if (collect_values[0].v_pointer)
      {
        GObject *object = collect_values[0].v_pointer;
  
        if (object-&gt;g_type_instance.g_class == NULL)
<span class="udiff-line-modified-removed">-     return g_strconcat (&quot;invalid unclassed object pointer for value type &#39;&quot;,</span>
<span class="udiff-line-modified-removed">-                 G_VALUE_TYPE_NAME (value),</span>
<span class="udiff-line-modified-removed">-                 &quot;&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-                 NULL);</span>
<span class="udiff-line-modified-added">+   return g_strconcat (&quot;invalid unclassed object pointer for value type &#39;&quot;,</span>
<span class="udiff-line-modified-added">+           G_VALUE_TYPE_NAME (value),</span>
<span class="udiff-line-modified-added">+           &quot;&#39;&quot;,</span>
<span class="udiff-line-modified-added">+           NULL);</span>
        else if (!g_value_type_compatible (G_OBJECT_TYPE (object), G_VALUE_TYPE (value)))
<span class="udiff-line-modified-removed">-     return g_strconcat (&quot;invalid object type &#39;&quot;,</span>
<span class="udiff-line-modified-removed">-                 G_OBJECT_TYPE_NAME (object),</span>
<span class="udiff-line-modified-removed">-                 &quot;&#39; for value type &#39;&quot;,</span>
<span class="udiff-line-modified-removed">-                 G_VALUE_TYPE_NAME (value),</span>
<span class="udiff-line-modified-removed">-                 &quot;&#39;&quot;,</span>
<span class="udiff-line-modified-removed">-                 NULL);</span>
<span class="udiff-line-modified-added">+   return g_strconcat (&quot;invalid object type &#39;&quot;,</span>
<span class="udiff-line-modified-added">+           G_OBJECT_TYPE_NAME (object),</span>
<span class="udiff-line-modified-added">+           &quot;&#39; for value type &#39;&quot;,</span>
<span class="udiff-line-modified-added">+           G_VALUE_TYPE_NAME (value),</span>
<span class="udiff-line-modified-added">+           &quot;&#39;&quot;,</span>
<span class="udiff-line-modified-added">+           NULL);</span>
        /* never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types */
        value-&gt;data[0].v_pointer = g_object_ref (object);
      }
    else
      value-&gt;data[0].v_pointer = NULL;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3845,13 +3895,13 @@</span>
    return NULL;
  }
  
  static gchar*
  g_value_object_lcopy_value (const GValue *value,
<span class="udiff-line-modified-removed">-                 guint        n_collect_values,</span>
<span class="udiff-line-modified-removed">-                 GTypeCValue *collect_values,</span>
<span class="udiff-line-modified-removed">-                 guint        collect_flags)</span>
<span class="udiff-line-modified-added">+           guint        n_collect_values,</span>
<span class="udiff-line-modified-added">+           GTypeCValue *collect_values,</span>
<span class="udiff-line-modified-added">+           guint        collect_flags)</span>
  {
    GObject **object_p = collect_values[0].v_pointer;
  
    if (!object_p)
      return g_strdup_printf (&quot;value location for &#39;%s&#39; passed as NULL&quot;, G_VALUE_TYPE_NAME (value));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3883,11 +3933,11 @@</span>
   * own, or one it has taken) to ensure that the object won&#39;t be destroyed while
   * the #GValue still exists).
   */
  void
  g_value_set_object (GValue   *value,
<span class="udiff-line-modified-removed">-             gpointer  v_object)</span>
<span class="udiff-line-modified-added">+         gpointer  v_object)</span>
  {
    GObject *old;
  
    g_return_if_fail (G_VALUE_HOLDS_OBJECT (value));
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3917,33 +3967,33 @@</span>
   *
   * Deprecated: 2.4: Use g_value_take_object() instead.
   */
  void
  g_value_set_object_take_ownership (GValue  *value,
<span class="udiff-line-modified-removed">-                    gpointer v_object)</span>
<span class="udiff-line-modified-added">+            gpointer v_object)</span>
  {
    g_value_take_object (value, v_object);
  }
  
  /**
   * g_value_take_object: (skip)
   * @value: a valid #GValue of %G_TYPE_OBJECT derived type
   * @v_object: (nullable): object value to be set
   *
   * Sets the contents of a %G_TYPE_OBJECT derived #GValue to @v_object
<span class="udiff-line-modified-removed">-  * and takes over the ownership of the callers reference to @v_object;</span>
<span class="udiff-line-modified-added">+  * and takes over the ownership of the caller&#39;s reference to @v_object;</span>
   * the caller doesn&#39;t have to unref it any more (i.e. the reference
   * count of the object is not increased).
   *
   * If you want the #GValue to hold its own reference to @v_object, use
   * g_value_set_object() instead.
   *
   * Since: 2.4
   */
  void
  g_value_take_object (GValue  *value,
<span class="udiff-line-modified-removed">-              gpointer v_object)</span>
<span class="udiff-line-modified-added">+          gpointer v_object)</span>
  {
    g_return_if_fail (G_VALUE_HOLDS_OBJECT (value));
  
    if (value-&gt;data[0].v_pointer)
      {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4015,14 +4065,14 @@</span>
   *
   * Returns: the handler id.
   */
  gulong
  g_signal_connect_object (gpointer      instance,
<span class="udiff-line-modified-removed">-              const gchar  *detailed_signal,</span>
<span class="udiff-line-modified-removed">-              GCallback     c_handler,</span>
<span class="udiff-line-modified-removed">-              gpointer      gobject,</span>
<span class="udiff-line-modified-removed">-              GConnectFlags connect_flags)</span>
<span class="udiff-line-modified-added">+        const gchar  *detailed_signal,</span>
<span class="udiff-line-modified-added">+        GCallback     c_handler,</span>
<span class="udiff-line-modified-added">+        gpointer      gobject,</span>
<span class="udiff-line-modified-added">+        GConnectFlags connect_flags)</span>
  {
    g_return_val_if_fail (G_TYPE_CHECK_INSTANCE (instance), 0);
    g_return_val_if_fail (detailed_signal != NULL, 0);
    g_return_val_if_fail (c_handler != NULL, 0);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4064,26 +4114,26 @@</span>
   * }
   */
  
  static void
  object_remove_closure (gpointer  data,
<span class="udiff-line-modified-removed">-                GClosure *closure)</span>
<span class="udiff-line-modified-added">+            GClosure *closure)</span>
  {
    GObject *object = data;
    CArray *carray;
    guint i;
  
    G_LOCK (closure_array_mutex);
    carray = g_object_get_qdata (object, quark_closure_array);
    for (i = 0; i &lt; carray-&gt;n_closures; i++)
      if (carray-&gt;closures[i] == closure)
        {
<span class="udiff-line-modified-removed">-     carray-&gt;n_closures--;</span>
<span class="udiff-line-modified-removed">-     if (i &lt; carray-&gt;n_closures)</span>
<span class="udiff-line-modified-removed">-       carray-&gt;closures[i] = carray-&gt;closures[carray-&gt;n_closures];</span>
<span class="udiff-line-modified-removed">-     G_UNLOCK (closure_array_mutex);</span>
<span class="udiff-line-modified-removed">-     return;</span>
<span class="udiff-line-modified-added">+   carray-&gt;n_closures--;</span>
<span class="udiff-line-modified-added">+   if (i &lt; carray-&gt;n_closures)</span>
<span class="udiff-line-modified-added">+     carray-&gt;closures[i] = carray-&gt;closures[carray-&gt;n_closures];</span>
<span class="udiff-line-modified-added">+   G_UNLOCK (closure_array_mutex);</span>
<span class="udiff-line-modified-added">+   return;</span>
        }
    G_UNLOCK (closure_array_mutex);
    g_assert_not_reached ();
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4107,12 +4157,12 @@</span>
    g_free (carray);
  }
  
  /**
   * g_object_watch_closure:
<span class="udiff-line-modified-removed">-  * @object: GObject restricting lifetime of @closure</span>
<span class="udiff-line-modified-removed">-  * @closure: GClosure to watch</span>
<span class="udiff-line-modified-added">+  * @object: #GObject restricting lifetime of @closure</span>
<span class="udiff-line-modified-added">+  * @closure: #GClosure to watch</span>
   *
   * This function essentially limits the life time of the @closure to
   * the life time of the object. That is, when the object is finalized,
   * the @closure is invalidated by calling g_closure_invalidate() on
   * it, in order to prevent invocations of the closure with a finalized
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4122,25 +4172,25 @@</span>
   * @closure.  Usually, this function will be called on closures that
   * use this @object as closure data.
   */
  void
  g_object_watch_closure (GObject  *object,
<span class="udiff-line-modified-removed">-             GClosure *closure)</span>
<span class="udiff-line-modified-added">+       GClosure *closure)</span>
  {
    CArray *carray;
    guint i;
  
    g_return_if_fail (G_IS_OBJECT (object));
    g_return_if_fail (closure != NULL);
    g_return_if_fail (closure-&gt;is_invalid == FALSE);
    g_return_if_fail (closure-&gt;in_marshal == FALSE);
<span class="udiff-line-modified-removed">-   g_return_if_fail (object-&gt;ref_count &gt; 0); /* this doesn&#39;t work on finalizing objects */</span>
<span class="udiff-line-modified-added">+   g_return_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt; 0); /* this doesn&#39;t work on finalizing objects */</span>
  
    g_closure_add_invalidate_notifier (closure, object, object_remove_closure);
    g_closure_add_marshal_guards (closure,
<span class="udiff-line-modified-removed">-                 object, (GClosureNotify) g_object_ref,</span>
<span class="udiff-line-modified-removed">-                 object, (GClosureNotify) g_object_unref);</span>
<span class="udiff-line-modified-added">+         object, (GClosureNotify) g_object_ref,</span>
<span class="udiff-line-modified-added">+         object, (GClosureNotify) g_object_unref);</span>
    G_LOCK (closure_array_mutex);
    carray = g_datalist_id_remove_no_notify (&amp;object-&gt;qdata, quark_closure_array);
    if (!carray)
      {
        carray = g_renew (CArray, NULL, 1);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4172,16 +4222,16 @@</span>
   *
   * Returns: (transfer full): a newly allocated #GClosure
   */
  GClosure*
  g_closure_new_object (guint    sizeof_closure,
<span class="udiff-line-modified-removed">-               GObject *object)</span>
<span class="udiff-line-modified-added">+           GObject *object)</span>
  {
    GClosure *closure;
  
    g_return_val_if_fail (G_IS_OBJECT (object), NULL);
<span class="udiff-line-modified-removed">-   g_return_val_if_fail (object-&gt;ref_count &gt; 0, NULL);     /* this doesn&#39;t work on finalizing objects */</span>
<span class="udiff-line-modified-added">+   g_return_val_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt; 0, NULL);     /* this doesn&#39;t work on finalizing objects */</span>
  
    closure = g_closure_new_simple (sizeof_closure, object);
    g_object_watch_closure (object, closure);
  
    return closure;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4200,16 +4250,16 @@</span>
   *
   * Returns: a new #GCClosure
   */
  GClosure*
  g_cclosure_new_object (GCallback callback_func,
<span class="udiff-line-modified-removed">-                GObject  *object)</span>
<span class="udiff-line-modified-added">+            GObject  *object)</span>
  {
    GClosure *closure;
  
    g_return_val_if_fail (G_IS_OBJECT (object), NULL);
<span class="udiff-line-modified-removed">-   g_return_val_if_fail (object-&gt;ref_count &gt; 0, NULL);     /* this doesn&#39;t work on finalizing objects */</span>
<span class="udiff-line-modified-added">+   g_return_val_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt; 0, NULL);     /* this doesn&#39;t work on finalizing objects */</span>
    g_return_val_if_fail (callback_func != NULL, NULL);
  
    closure = g_cclosure_new (callback_func, object, NULL);
    g_object_watch_closure (object, closure);
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -4229,16 +4279,16 @@</span>
   *
   * Returns: a new #GCClosure
   */
  GClosure*
  g_cclosure_new_object_swap (GCallback callback_func,
<span class="udiff-line-modified-removed">-                 GObject  *object)</span>
<span class="udiff-line-modified-added">+           GObject  *object)</span>
  {
    GClosure *closure;
  
    g_return_val_if_fail (G_IS_OBJECT (object), NULL);
<span class="udiff-line-modified-removed">-   g_return_val_if_fail (object-&gt;ref_count &gt; 0, NULL);     /* this doesn&#39;t work on finalizing objects */</span>
<span class="udiff-line-modified-added">+   g_return_val_if_fail (g_atomic_int_get (&amp;object-&gt;ref_count) &gt; 0, NULL);     /* this doesn&#39;t work on finalizing objects */</span>
    g_return_val_if_fail (callback_func != NULL, NULL);
  
    closure = g_cclosure_new_swap (callback_func, object, NULL);
    g_object_watch_closure (object, closure);
  
</pre>
<center><a href="gobject-autocleanups.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gobject.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>