<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gthread-posix.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gtestutils.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gthread-win32.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gthread-posix.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  40 #include &quot;config.h&quot;
  41 
  42 #include &quot;gthread.h&quot;
  43 
  44 #include &quot;gthreadprivate.h&quot;
  45 #include &quot;gslice.h&quot;
  46 #include &quot;gmessages.h&quot;
  47 #include &quot;gstrfuncs.h&quot;
  48 #include &quot;gmain.h&quot;
  49 #include &quot;gutils.h&quot;
  50 
  51 #include &lt;stdlib.h&gt;
  52 #include &lt;stdio.h&gt;
  53 #include &lt;string.h&gt;
  54 #include &lt;errno.h&gt;
  55 #include &lt;pthread.h&gt;
  56 
  57 #include &lt;sys/time.h&gt;
  58 #include &lt;unistd.h&gt;
  59 



  60 #ifdef HAVE_SCHED_H
  61 #include &lt;sched.h&gt;
  62 #endif
  63 #ifdef G_OS_WIN32
  64 #include &lt;windows.h&gt;
  65 #endif
  66 
  67 /* clang defines __ATOMIC_SEQ_CST but doesn&#39;t support the GCC extension */
  68 #if defined(HAVE_FUTEX) &amp;&amp; defined(__ATOMIC_SEQ_CST) &amp;&amp; !defined(__clang__)
  69 #define USE_NATIVE_MUTEX
  70 #endif
  71 
  72 static void
  73 g_thread_abort (gint         status,
  74                 const gchar *function)
  75 {
  76   fprintf (stderr, &quot;GLib (gthread-posix.c): Unexpected error from C library during &#39;%s&#39;: %s.  Aborting.\n&quot;,
  77            function, strerror (status));
  78   g_abort ();
  79 }
</pre>
<hr />
<pre>
 570  * @rw_lock: a #GRWLock
 571  *
 572  * Release a write lock on @rw_lock.
 573  *
 574  * Calling g_rw_lock_writer_unlock() on a lock that is not held
 575  * by the current thread leads to undefined behaviour.
 576  *
 577  * Since: 2.32
 578  */
 579 void
 580 g_rw_lock_writer_unlock (GRWLock *rw_lock)
 581 {
 582   pthread_rwlock_unlock (g_rw_lock_get_impl (rw_lock));
 583 }
 584 
 585 /**
 586  * g_rw_lock_reader_lock:
 587  * @rw_lock: a #GRWLock
 588  *
 589  * Obtain a read lock on @rw_lock. If another thread currently holds
<span class="line-modified"> 590  * the write lock on @rw_lock or blocks waiting for it, the current</span>
<span class="line-modified"> 591  * thread will block. Read locks can be taken recursively.</span>


 592  *
 593  * It is implementation-defined how many threads are allowed to
 594  * hold read locks on the same lock simultaneously. If the limit is hit,
 595  * or if a deadlock is detected, a critical warning will be emitted.
 596  *
 597  * Since: 2.32
 598  */
 599 void
 600 g_rw_lock_reader_lock (GRWLock *rw_lock)
 601 {
 602   int retval = pthread_rwlock_rdlock (g_rw_lock_get_impl (rw_lock));
 603 
 604   if (retval != 0)
 605     g_critical (&quot;Failed to get RW lock %p: %s&quot;, rw_lock, g_strerror (retval));
 606 }
 607 
 608 /**
 609  * g_rw_lock_reader_trylock:
 610  * @rw_lock: a #GRWLock
 611  *
</pre>
<hr />
<pre>
1098  * Since: 2.32
1099  **/
1100 void
1101 g_private_replace (GPrivate *key,
1102                    gpointer  value)
1103 {
1104   pthread_key_t *impl = g_private_get_impl (key);
1105   gpointer old;
1106   gint status;
1107 
1108   old = pthread_getspecific (*impl);
1109   if (old &amp;&amp; key-&gt;notify)
1110     key-&gt;notify (old);
1111 
1112   if G_UNLIKELY ((status = pthread_setspecific (*impl, value)) != 0)
1113     g_thread_abort (status, &quot;pthread_setspecific&quot;);
1114 }
1115 
1116 /* {{{1 GThread */
1117 
<span class="line-modified">1118 #define posix_check_err(err, name) G_STMT_START{            \</span>
<span class="line-modified">1119   int error = (err);                            \</span>
<span class="line-modified">1120   if (error)                                \</span>
<span class="line-modified">1121     g_error (&quot;file %s: line %d (%s): error &#39;%s&#39; during &#39;%s&#39;&quot;,       \</span>
<span class="line-modified">1122            __FILE__, __LINE__, G_STRFUNC,               \</span>
<span class="line-modified">1123            g_strerror (error), name);                   \</span>
1124   }G_STMT_END
1125 
1126 #define posix_check_cmd(cmd) posix_check_err (cmd, #cmd)
1127 
1128 typedef struct
1129 {
1130   GRealThread thread;
1131 
1132   pthread_t system_thread;
1133   gboolean  joined;
1134   GMutex    lock;
1135 } GThreadPosix;
1136 
1137 void
1138 g_system_thread_free (GRealThread *thread)
1139 {
1140   GThreadPosix *pt = (GThreadPosix *) thread;
1141 
1142   if (!pt-&gt;joined)
1143     pthread_detach (pt-&gt;system_thread);
1144 
1145   g_mutex_clear (&amp;pt-&gt;lock);
1146 
1147   g_slice_free (GThreadPosix, pt);
1148 }
1149 
1150 GRealThread *
<span class="line-modified">1151 g_system_thread_new (GThreadFunc   thread_func,</span>
1152                      gulong        stack_size,



1153                      GError      **error)
1154 {
1155   GThreadPosix *thread;

1156   pthread_attr_t attr;
1157   gint ret;
1158 
1159   thread = g_slice_new0 (GThreadPosix);







1160 
1161   posix_check_cmd (pthread_attr_init (&amp;attr));
1162 
1163 #ifdef HAVE_PTHREAD_ATTR_SETSTACKSIZE
1164   if (stack_size)
1165     {
1166 #ifdef _SC_THREAD_STACK_MIN
1167       long min_stack_size = sysconf (_SC_THREAD_STACK_MIN);
1168       if (min_stack_size &gt;= 0)
<span class="line-modified">1169         stack_size = MAX (min_stack_size, stack_size);</span>
1170 #endif /* _SC_THREAD_STACK_MIN */
1171       /* No error check here, because some systems can&#39;t do it and
1172        * we simply don&#39;t want threads to fail because of that. */
1173       pthread_attr_setstacksize (&amp;attr, stack_size);
1174     }
1175 #endif /* HAVE_PTHREAD_ATTR_SETSTACKSIZE */
1176 
<span class="line-modified">1177   ret = pthread_create (&amp;thread-&gt;system_thread, &amp;attr, (void* (*)(void*))thread_func, thread);</span>
1178 
1179   posix_check_cmd (pthread_attr_destroy (&amp;attr));
1180 
1181   if (ret == EAGAIN)
1182     {
1183       g_set_error (error, G_THREAD_ERROR, G_THREAD_ERROR_AGAIN,
1184                    &quot;Error creating thread: %s&quot;, g_strerror (ret));
1185       g_slice_free (GThreadPosix, thread);
1186       return NULL;
1187     }
1188 
1189   posix_check_err (ret, &quot;pthread_create&quot;);
1190 
1191   g_mutex_init (&amp;thread-&gt;lock);
1192 
1193   return (GRealThread *) thread;
1194 }
1195 
1196 /**
1197  * g_thread_yield:
</pre>
<hr />
<pre>
1215   g_mutex_lock (&amp;pt-&gt;lock);
1216 
1217   if (!pt-&gt;joined)
1218     {
1219       posix_check_cmd (pthread_join (pt-&gt;system_thread, NULL));
1220       pt-&gt;joined = TRUE;
1221     }
1222 
1223   g_mutex_unlock (&amp;pt-&gt;lock);
1224 }
1225 
1226 void
1227 g_system_thread_exit (void)
1228 {
1229   pthread_exit (NULL);
1230 }
1231 
1232 void
1233 g_system_thread_set_name (const gchar *name)
1234 {
<span class="line-modified">1235 #if defined(HAVE_PTHREAD_SETNAME_NP_WITH_TID)</span>
<span class="line-removed">1236   pthread_setname_np (pthread_self(), name); /* on Linux and Solaris */</span>
<span class="line-removed">1237 #elif defined(HAVE_PTHREAD_SETNAME_NP_WITHOUT_TID)</span>
1238   pthread_setname_np (name); /* on OS X and iOS */






1239 #endif
1240 }
1241 
1242 /* {{{1 GMutex and GCond futex implementation */
1243 
1244 #if defined(USE_NATIVE_MUTEX)
1245 
1246 #include &lt;linux/futex.h&gt;
1247 #include &lt;sys/syscall.h&gt;
1248 
1249 #ifndef FUTEX_WAIT_PRIVATE
1250 #define FUTEX_WAIT_PRIVATE FUTEX_WAIT
1251 #define FUTEX_WAKE_PRIVATE FUTEX_WAKE
1252 #endif
1253 
1254 /* We should expand the set of operations available in gatomic once we
1255  * have better C11 support in GCC in common distributions (ie: 4.9).
1256  *
1257  * Before then, let&#39;s define a couple of useful things for our own
1258  * purposes...
</pre>
<hr />
<pre>
1411   syscall (__NR_futex, &amp;cond-&gt;i[0], (gsize) FUTEX_WAKE_PRIVATE, (gsize) 1, NULL);
1412 }
1413 
1414 void
1415 g_cond_broadcast (GCond *cond)
1416 {
1417   g_atomic_int_inc (&amp;cond-&gt;i[0]);
1418 
1419   syscall (__NR_futex, &amp;cond-&gt;i[0], (gsize) FUTEX_WAKE_PRIVATE, (gsize) INT_MAX, NULL);
1420 }
1421 
1422 gboolean
1423 g_cond_wait_until (GCond  *cond,
1424                    GMutex *mutex,
1425                    gint64  end_time)
1426 {
1427   struct timespec now;
1428   struct timespec span;
1429   guint sampled;
1430   int res;

1431 
1432   if (end_time &lt; 0)
1433     return FALSE;
1434 
1435   clock_gettime (CLOCK_MONOTONIC, &amp;now);
1436   span.tv_sec = (end_time / 1000000) - now.tv_sec;
1437   span.tv_nsec = ((end_time % 1000000) * 1000) - now.tv_nsec;
1438   if (span.tv_nsec &lt; 0)
1439     {
1440       span.tv_nsec += 1000000000;
1441       span.tv_sec--;
1442     }
1443 
1444   if (span.tv_sec &lt; 0)
1445     return FALSE;
1446 
1447   sampled = cond-&gt;i[0];
1448   g_mutex_unlock (mutex);
1449   res = syscall (__NR_futex, &amp;cond-&gt;i[0], (gsize) FUTEX_WAIT_PRIVATE, (gsize) sampled, &amp;span);

1450   g_mutex_lock (mutex);
1451 
<span class="line-modified">1452   return (res &lt; 0 &amp;&amp; errno == ETIMEDOUT) ? FALSE : TRUE;</span>
1453 }
1454 
1455 #endif
1456 
1457   /* {{{1 Epilogue */
1458 /* vim:set foldmethod=marker: */
</pre>
</td>
<td>
<hr />
<pre>
  40 #include &quot;config.h&quot;
  41 
  42 #include &quot;gthread.h&quot;
  43 
  44 #include &quot;gthreadprivate.h&quot;
  45 #include &quot;gslice.h&quot;
  46 #include &quot;gmessages.h&quot;
  47 #include &quot;gstrfuncs.h&quot;
  48 #include &quot;gmain.h&quot;
  49 #include &quot;gutils.h&quot;
  50 
  51 #include &lt;stdlib.h&gt;
  52 #include &lt;stdio.h&gt;
  53 #include &lt;string.h&gt;
  54 #include &lt;errno.h&gt;
  55 #include &lt;pthread.h&gt;
  56 
  57 #include &lt;sys/time.h&gt;
  58 #include &lt;unistd.h&gt;
  59 
<span class="line-added">  60 #ifdef HAVE_PTHREAD_SET_NAME_NP</span>
<span class="line-added">  61 #include &lt;pthread_np.h&gt;</span>
<span class="line-added">  62 #endif</span>
  63 #ifdef HAVE_SCHED_H
  64 #include &lt;sched.h&gt;
  65 #endif
  66 #ifdef G_OS_WIN32
  67 #include &lt;windows.h&gt;
  68 #endif
  69 
  70 /* clang defines __ATOMIC_SEQ_CST but doesn&#39;t support the GCC extension */
  71 #if defined(HAVE_FUTEX) &amp;&amp; defined(__ATOMIC_SEQ_CST) &amp;&amp; !defined(__clang__)
  72 #define USE_NATIVE_MUTEX
  73 #endif
  74 
  75 static void
  76 g_thread_abort (gint         status,
  77                 const gchar *function)
  78 {
  79   fprintf (stderr, &quot;GLib (gthread-posix.c): Unexpected error from C library during &#39;%s&#39;: %s.  Aborting.\n&quot;,
  80            function, strerror (status));
  81   g_abort ();
  82 }
</pre>
<hr />
<pre>
 573  * @rw_lock: a #GRWLock
 574  *
 575  * Release a write lock on @rw_lock.
 576  *
 577  * Calling g_rw_lock_writer_unlock() on a lock that is not held
 578  * by the current thread leads to undefined behaviour.
 579  *
 580  * Since: 2.32
 581  */
 582 void
 583 g_rw_lock_writer_unlock (GRWLock *rw_lock)
 584 {
 585   pthread_rwlock_unlock (g_rw_lock_get_impl (rw_lock));
 586 }
 587 
 588 /**
 589  * g_rw_lock_reader_lock:
 590  * @rw_lock: a #GRWLock
 591  *
 592  * Obtain a read lock on @rw_lock. If another thread currently holds
<span class="line-modified"> 593  * the write lock on @rw_lock, the current thread will block. If another thread</span>
<span class="line-modified"> 594  * does not hold the write lock, but is waiting for it, it is implementation</span>
<span class="line-added"> 595  * defined whether the reader or writer will block. Read locks can be taken</span>
<span class="line-added"> 596  * recursively.</span>
 597  *
 598  * It is implementation-defined how many threads are allowed to
 599  * hold read locks on the same lock simultaneously. If the limit is hit,
 600  * or if a deadlock is detected, a critical warning will be emitted.
 601  *
 602  * Since: 2.32
 603  */
 604 void
 605 g_rw_lock_reader_lock (GRWLock *rw_lock)
 606 {
 607   int retval = pthread_rwlock_rdlock (g_rw_lock_get_impl (rw_lock));
 608 
 609   if (retval != 0)
 610     g_critical (&quot;Failed to get RW lock %p: %s&quot;, rw_lock, g_strerror (retval));
 611 }
 612 
 613 /**
 614  * g_rw_lock_reader_trylock:
 615  * @rw_lock: a #GRWLock
 616  *
</pre>
<hr />
<pre>
1103  * Since: 2.32
1104  **/
1105 void
1106 g_private_replace (GPrivate *key,
1107                    gpointer  value)
1108 {
1109   pthread_key_t *impl = g_private_get_impl (key);
1110   gpointer old;
1111   gint status;
1112 
1113   old = pthread_getspecific (*impl);
1114   if (old &amp;&amp; key-&gt;notify)
1115     key-&gt;notify (old);
1116 
1117   if G_UNLIKELY ((status = pthread_setspecific (*impl, value)) != 0)
1118     g_thread_abort (status, &quot;pthread_setspecific&quot;);
1119 }
1120 
1121 /* {{{1 GThread */
1122 
<span class="line-modified">1123 #define posix_check_err(err, name) G_STMT_START{      \</span>
<span class="line-modified">1124   int error = (err);              \</span>
<span class="line-modified">1125   if (error)                \</span>
<span class="line-modified">1126     g_error (&quot;file %s: line %d (%s): error &#39;%s&#39; during &#39;%s&#39;&quot;,   \</span>
<span class="line-modified">1127            __FILE__, __LINE__, G_STRFUNC,       \</span>
<span class="line-modified">1128            g_strerror (error), name);         \</span>
1129   }G_STMT_END
1130 
1131 #define posix_check_cmd(cmd) posix_check_err (cmd, #cmd)
1132 
1133 typedef struct
1134 {
1135   GRealThread thread;
1136 
1137   pthread_t system_thread;
1138   gboolean  joined;
1139   GMutex    lock;
1140 } GThreadPosix;
1141 
1142 void
1143 g_system_thread_free (GRealThread *thread)
1144 {
1145   GThreadPosix *pt = (GThreadPosix *) thread;
1146 
1147   if (!pt-&gt;joined)
1148     pthread_detach (pt-&gt;system_thread);
1149 
1150   g_mutex_clear (&amp;pt-&gt;lock);
1151 
1152   g_slice_free (GThreadPosix, pt);
1153 }
1154 
1155 GRealThread *
<span class="line-modified">1156 g_system_thread_new (GThreadFunc   proxy,</span>
1157                      gulong        stack_size,
<span class="line-added">1158                      const char   *name,</span>
<span class="line-added">1159                      GThreadFunc   func,</span>
<span class="line-added">1160                      gpointer      data,</span>
1161                      GError      **error)
1162 {
1163   GThreadPosix *thread;
<span class="line-added">1164   GRealThread *base_thread;</span>
1165   pthread_attr_t attr;
1166   gint ret;
1167 
1168   thread = g_slice_new0 (GThreadPosix);
<span class="line-added">1169   base_thread = (GRealThread*)thread;</span>
<span class="line-added">1170   base_thread-&gt;ref_count = 2;</span>
<span class="line-added">1171   base_thread-&gt;ours = TRUE;</span>
<span class="line-added">1172   base_thread-&gt;thread.joinable = TRUE;</span>
<span class="line-added">1173   base_thread-&gt;thread.func = func;</span>
<span class="line-added">1174   base_thread-&gt;thread.data = data;</span>
<span class="line-added">1175   base_thread-&gt;name = g_strdup (name);</span>
1176 
1177   posix_check_cmd (pthread_attr_init (&amp;attr));
1178 
1179 #ifdef HAVE_PTHREAD_ATTR_SETSTACKSIZE
1180   if (stack_size)
1181     {
1182 #ifdef _SC_THREAD_STACK_MIN
1183       long min_stack_size = sysconf (_SC_THREAD_STACK_MIN);
1184       if (min_stack_size &gt;= 0)
<span class="line-modified">1185         stack_size = MAX ((gulong) min_stack_size, stack_size);</span>
1186 #endif /* _SC_THREAD_STACK_MIN */
1187       /* No error check here, because some systems can&#39;t do it and
1188        * we simply don&#39;t want threads to fail because of that. */
1189       pthread_attr_setstacksize (&amp;attr, stack_size);
1190     }
1191 #endif /* HAVE_PTHREAD_ATTR_SETSTACKSIZE */
1192 
<span class="line-modified">1193   ret = pthread_create (&amp;thread-&gt;system_thread, &amp;attr, (void* (*)(void*))proxy, thread);</span>
1194 
1195   posix_check_cmd (pthread_attr_destroy (&amp;attr));
1196 
1197   if (ret == EAGAIN)
1198     {
1199       g_set_error (error, G_THREAD_ERROR, G_THREAD_ERROR_AGAIN,
1200                    &quot;Error creating thread: %s&quot;, g_strerror (ret));
1201       g_slice_free (GThreadPosix, thread);
1202       return NULL;
1203     }
1204 
1205   posix_check_err (ret, &quot;pthread_create&quot;);
1206 
1207   g_mutex_init (&amp;thread-&gt;lock);
1208 
1209   return (GRealThread *) thread;
1210 }
1211 
1212 /**
1213  * g_thread_yield:
</pre>
<hr />
<pre>
1231   g_mutex_lock (&amp;pt-&gt;lock);
1232 
1233   if (!pt-&gt;joined)
1234     {
1235       posix_check_cmd (pthread_join (pt-&gt;system_thread, NULL));
1236       pt-&gt;joined = TRUE;
1237     }
1238 
1239   g_mutex_unlock (&amp;pt-&gt;lock);
1240 }
1241 
1242 void
1243 g_system_thread_exit (void)
1244 {
1245   pthread_exit (NULL);
1246 }
1247 
1248 void
1249 g_system_thread_set_name (const gchar *name)
1250 {
<span class="line-modified">1251 #if defined(HAVE_PTHREAD_SETNAME_NP_WITHOUT_TID)</span>


1252   pthread_setname_np (name); /* on OS X and iOS */
<span class="line-added">1253 #elif defined(HAVE_PTHREAD_SETNAME_NP_WITH_TID)</span>
<span class="line-added">1254   pthread_setname_np (pthread_self (), name); /* on Linux and Solaris */</span>
<span class="line-added">1255 #elif defined(HAVE_PTHREAD_SETNAME_NP_WITH_TID_AND_ARG)</span>
<span class="line-added">1256   pthread_setname_np (pthread_self (), &quot;%s&quot;, (gchar *) name); /* on NetBSD */</span>
<span class="line-added">1257 #elif defined(HAVE_PTHREAD_SET_NAME_NP)</span>
<span class="line-added">1258   pthread_set_name_np (pthread_self (), name); /* on FreeBSD, DragonFlyBSD, OpenBSD */</span>
1259 #endif
1260 }
1261 
1262 /* {{{1 GMutex and GCond futex implementation */
1263 
1264 #if defined(USE_NATIVE_MUTEX)
1265 
1266 #include &lt;linux/futex.h&gt;
1267 #include &lt;sys/syscall.h&gt;
1268 
1269 #ifndef FUTEX_WAIT_PRIVATE
1270 #define FUTEX_WAIT_PRIVATE FUTEX_WAIT
1271 #define FUTEX_WAKE_PRIVATE FUTEX_WAKE
1272 #endif
1273 
1274 /* We should expand the set of operations available in gatomic once we
1275  * have better C11 support in GCC in common distributions (ie: 4.9).
1276  *
1277  * Before then, let&#39;s define a couple of useful things for our own
1278  * purposes...
</pre>
<hr />
<pre>
1431   syscall (__NR_futex, &amp;cond-&gt;i[0], (gsize) FUTEX_WAKE_PRIVATE, (gsize) 1, NULL);
1432 }
1433 
1434 void
1435 g_cond_broadcast (GCond *cond)
1436 {
1437   g_atomic_int_inc (&amp;cond-&gt;i[0]);
1438 
1439   syscall (__NR_futex, &amp;cond-&gt;i[0], (gsize) FUTEX_WAKE_PRIVATE, (gsize) INT_MAX, NULL);
1440 }
1441 
1442 gboolean
1443 g_cond_wait_until (GCond  *cond,
1444                    GMutex *mutex,
1445                    gint64  end_time)
1446 {
1447   struct timespec now;
1448   struct timespec span;
1449   guint sampled;
1450   int res;
<span class="line-added">1451   gboolean success;</span>
1452 
1453   if (end_time &lt; 0)
1454     return FALSE;
1455 
1456   clock_gettime (CLOCK_MONOTONIC, &amp;now);
1457   span.tv_sec = (end_time / 1000000) - now.tv_sec;
1458   span.tv_nsec = ((end_time % 1000000) * 1000) - now.tv_nsec;
1459   if (span.tv_nsec &lt; 0)
1460     {
1461       span.tv_nsec += 1000000000;
1462       span.tv_sec--;
1463     }
1464 
1465   if (span.tv_sec &lt; 0)
1466     return FALSE;
1467 
1468   sampled = cond-&gt;i[0];
1469   g_mutex_unlock (mutex);
1470   res = syscall (__NR_futex, &amp;cond-&gt;i[0], (gsize) FUTEX_WAIT_PRIVATE, (gsize) sampled, &amp;span);
<span class="line-added">1471   success = (res &lt; 0 &amp;&amp; errno == ETIMEDOUT) ? FALSE : TRUE;</span>
1472   g_mutex_lock (mutex);
1473 
<span class="line-modified">1474   return success;</span>
1475 }
1476 
1477 #endif
1478 
1479   /* {{{1 Epilogue */
1480 /* vim:set foldmethod=marker: */
</pre>
</td>
</tr>
</table>
<center><a href="gtestutils.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gthread-win32.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>