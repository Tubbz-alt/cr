<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstminiobject.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstmeta.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstminiobject.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstminiobject.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 35,13 ***</span>
   * function of the miniobject is called.
   *
   * A copy can be made with gst_mini_object_copy().
   *
   * gst_mini_object_is_writable() will return %TRUE when the refcount of the
<span class="line-modified">!  * object is exactly 1, meaning the current caller has the only reference to the</span>
<span class="line-modified">!  * object. gst_mini_object_make_writable() will return a writable version of the</span>
<span class="line-modified">!  * object, which might be a new copy when the refcount was not 1.</span>
   *
   * Opaque data can be associated with a #GstMiniObject with
   * gst_mini_object_set_qdata() and gst_mini_object_get_qdata(). The data is
   * meant to be specific to the particular object and is not automatically copied
   * with gst_mini_object_copy() or similar methods.
<span class="line-new-header">--- 35,14 ---</span>
   * function of the miniobject is called.
   *
   * A copy can be made with gst_mini_object_copy().
   *
   * gst_mini_object_is_writable() will return %TRUE when the refcount of the
<span class="line-modified">!  * object is exactly 1 and there is no parent or a single parent exists and is</span>
<span class="line-modified">!  * writable itself, meaning the current caller has the only reference to the</span>
<span class="line-modified">!  * object. gst_mini_object_make_writable() will return a writable version of</span>
<span class="line-added">+  * the object, which might be a new copy when the refcount was not 1.</span>
   *
   * Opaque data can be associated with a #GstMiniObject with
   * gst_mini_object_set_qdata() and gst_mini_object_get_qdata(). The data is
   * meant to be specific to the particular object and is not automatically copied
   * with gst_mini_object_copy() or similar methods.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 69,19 ***</span>
  #define LOCK_ONE (GST_LOCK_FLAG_LAST)
  #define FLAG_MASK (GST_LOCK_FLAG_LAST - 1)
  #define LOCK_MASK ((SHARE_ONE - 1) - FLAG_MASK)
  #define LOCK_FLAG_MASK (SHARE_ONE - 1)
  
  typedef struct
  {
    GQuark quark;
    GstMiniObjectNotify notify;
    gpointer data;
    GDestroyNotify destroy;
  } GstQData;
  
<span class="line-modified">! #define QDATA(o,i)          ((GstQData *)(o)-&gt;qdata)[(i)]</span>
  #define QDATA_QUARK(o,i)    (QDATA(o,i).quark)
  #define QDATA_NOTIFY(o,i)   (QDATA(o,i).notify)
  #define QDATA_DATA(o,i)     (QDATA(o,i).data)
  #define QDATA_DESTROY(o,i)  (QDATA(o,i).destroy)
  
<span class="line-new-header">--- 70,59 ---</span>
  #define LOCK_ONE (GST_LOCK_FLAG_LAST)
  #define FLAG_MASK (GST_LOCK_FLAG_LAST - 1)
  #define LOCK_MASK ((SHARE_ONE - 1) - FLAG_MASK)
  #define LOCK_FLAG_MASK (SHARE_ONE - 1)
  
<span class="line-added">+ /* For backwards compatibility reasons we use the</span>
<span class="line-added">+  * guint and gpointer in the GstMiniObject struct in</span>
<span class="line-added">+  * a rather complicated way to store the parent(s) and qdata.</span>
<span class="line-added">+  * Originally the were just the number of qdatas and the qdata.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * The guint is used as an atomic state integer with the following</span>
<span class="line-added">+  * states:</span>
<span class="line-added">+  * - Locked: 0, basically a spinlock</span>
<span class="line-added">+  * - No parent, no qdata: 1 (pointer is NULL)</span>
<span class="line-added">+  * - One parent: 2 (pointer contains the parent)</span>
<span class="line-added">+  * - Multiple parents or qdata: 3 (pointer contains a PrivData struct)</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Unless we&#39;re in state 3, we always have to move to Locking state</span>
<span class="line-added">+  * atomically and release that again later to the target state whenever</span>
<span class="line-added">+  * accessing the pointer. When we&#39;re in state 3, we will never move to lower</span>
<span class="line-added">+  * states again</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * FIXME 2.0: We should store this directly inside the struct, possibly</span>
<span class="line-added">+  * keeping space directly allocated for a couple of parents</span>
<span class="line-added">+  */</span>
<span class="line-added">+ </span>
<span class="line-added">+ enum</span>
<span class="line-added">+ {</span>
<span class="line-added">+   PRIV_DATA_STATE_LOCKED = 0,</span>
<span class="line-added">+   PRIV_DATA_STATE_NO_PARENT = 1,</span>
<span class="line-added">+   PRIV_DATA_STATE_ONE_PARENT = 2,</span>
<span class="line-added">+   PRIV_DATA_STATE_PARENTS_OR_QDATA = 3,</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  typedef struct
  {
    GQuark quark;
    GstMiniObjectNotify notify;
    gpointer data;
    GDestroyNotify destroy;
  } GstQData;
  
<span class="line-modified">! typedef struct</span>
<span class="line-added">+ {</span>
<span class="line-added">+   /* Atomic spinlock: 1 if locked, 0 otherwise */</span>
<span class="line-added">+   gint parent_lock;</span>
<span class="line-added">+   guint n_parents, n_parents_len;</span>
<span class="line-added">+   GstMiniObject **parents;</span>
<span class="line-added">+ </span>
<span class="line-added">+   guint n_qdata, n_qdata_len;</span>
<span class="line-added">+   GstQData *qdata;</span>
<span class="line-added">+ } PrivData;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #define QDATA(q,i)          (q-&gt;qdata)[(i)]</span>
  #define QDATA_QUARK(o,i)    (QDATA(o,i).quark)
  #define QDATA_NOTIFY(o,i)   (QDATA(o,i).notify)
  #define QDATA_DATA(o,i)     (QDATA(o,i).data)
  #define QDATA_DESTROY(o,i)  (QDATA(o,i).destroy)
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 116,12 ***</span>
  
    mini_object-&gt;copy = copy_func;
    mini_object-&gt;dispose = dispose_func;
    mini_object-&gt;free = free_func;
  
<span class="line-modified">!   mini_object-&gt;n_qdata = 0;</span>
<span class="line-modified">!   mini_object-&gt;qdata = NULL;</span>
  
    GST_TRACER_MINI_OBJECT_CREATED (mini_object);
  }
  
  /**
<span class="line-new-header">--- 157,13 ---</span>
  
    mini_object-&gt;copy = copy_func;
    mini_object-&gt;dispose = dispose_func;
    mini_object-&gt;free = free_func;
  
<span class="line-modified">!   g_atomic_int_set ((gint *) &amp; mini_object-&gt;priv_uint,</span>
<span class="line-modified">!       PRIV_DATA_STATE_NO_PARENT);</span>
<span class="line-added">+   mini_object-&gt;priv_pointer = NULL;</span>
  
    GST_TRACER_MINI_OBJECT_CREATED (mini_object);
  }
  
  /**
</pre>
<hr />
<pre>
<span class="line-old-header">*** 182,15 ***</span>
        /* shared ref */
        newstate += SHARE_ONE;
        access_mode &amp;= ~GST_LOCK_FLAG_EXCLUSIVE;
      }
  
<span class="line-modified">!       /* shared counter &gt; 1 and write access is not allowed */</span>
      if (((state &amp; GST_LOCK_FLAG_WRITE) != 0
              || (access_mode &amp; GST_LOCK_FLAG_WRITE) != 0)
          &amp;&amp; IS_SHARED (newstate))
<span class="line-modified">!         goto lock_failed;</span>
  
      if (access_mode) {
        if ((state &amp; LOCK_FLAG_MASK) == 0) {
          /* nothing mapped, set access_mode */
          newstate |= access_mode;
<span class="line-new-header">--- 224,15 ---</span>
        /* shared ref */
        newstate += SHARE_ONE;
        access_mode &amp;= ~GST_LOCK_FLAG_EXCLUSIVE;
      }
  
<span class="line-modified">!     /* shared counter &gt; 1 and write access is not allowed */</span>
      if (((state &amp; GST_LOCK_FLAG_WRITE) != 0
              || (access_mode &amp; GST_LOCK_FLAG_WRITE) != 0)
          &amp;&amp; IS_SHARED (newstate))
<span class="line-modified">!       goto lock_failed;</span>
  
      if (access_mode) {
        if ((state &amp; LOCK_FLAG_MASK) == 0) {
          /* nothing mapped, set access_mode */
          newstate |= access_mode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 255,10 ***</span>
<span class="line-new-header">--- 297,36 ---</span>
      }
    } while (!g_atomic_int_compare_and_exchange (&amp;object-&gt;lockstate, state,
            newstate));
  }
  
<span class="line-added">+ /* Locks the priv pointer and sets the priv uint to PRIV_DATA_STATE_LOCKED,</span>
<span class="line-added">+  * unless the full struct was already stored in the priv pointer.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Returns the previous state of the priv uint</span>
<span class="line-added">+  */</span>
<span class="line-added">+ static guint</span>
<span class="line-added">+ lock_priv_pointer (GstMiniObject * object)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   gint priv_state = g_atomic_int_get ((gint *) &amp; object-&gt;priv_uint);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (priv_state != PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added">+     /* As long as the struct was not allocated yet and either someone else</span>
<span class="line-added">+      * locked it or our priv_state is out of date, try to lock it */</span>
<span class="line-added">+     while (priv_state != PRIV_DATA_STATE_PARENTS_OR_QDATA &amp;&amp;</span>
<span class="line-added">+         (priv_state == PRIV_DATA_STATE_LOCKED ||</span>
<span class="line-added">+             !g_atomic_int_compare_and_exchange ((gint *) &amp; object-&gt;priv_uint,</span>
<span class="line-added">+                 priv_state, PRIV_DATA_STATE_LOCKED)))</span>
<span class="line-added">+       priv_state = g_atomic_int_get ((gint *) &amp; object-&gt;priv_uint);</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* Note that if we got the full struct, we did not store</span>
<span class="line-added">+      * PRIV_DATA_STATE_LOCKED and did not actually lock the priv pointer */</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   return priv_state;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  /**
   * gst_mini_object_is_writable:
   * @mini_object: the mini-object to check
   *
   * If @mini_object has the LOCKABLE flag set, check if the current EXCLUSIVE
</pre>
<hr />
<pre>
<span class="line-old-header">*** 276,18 ***</span>
<span class="line-new-header">--- 344,61 ---</span>
   */
  gboolean
  gst_mini_object_is_writable (const GstMiniObject * mini_object)
  {
    gboolean result;
<span class="line-added">+   gint priv_state;</span>
  
    g_return_val_if_fail (mini_object != NULL, FALSE);
  
<span class="line-added">+   /* Let&#39;s first check our own writability. If this already fails there&#39;s</span>
<span class="line-added">+    * no point in checking anything else */</span>
    if (GST_MINI_OBJECT_IS_LOCKABLE (mini_object)) {
      result = !IS_SHARED (g_atomic_int_get (&amp;mini_object-&gt;lockstate));
    } else {
      result = (GST_MINI_OBJECT_REFCOUNT_VALUE (mini_object) == 1);
    }
<span class="line-added">+   if (!result)</span>
<span class="line-added">+     return result;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* We are writable ourselves, but are there parents and are they all</span>
<span class="line-added">+    * writable too? */</span>
<span class="line-added">+   priv_state = lock_priv_pointer (GST_MINI_OBJECT_CAST (mini_object));</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Now we either have to check the full struct and all the</span>
<span class="line-added">+    * parents in there, or if there is exactly one parent we</span>
<span class="line-added">+    * can check that one */</span>
<span class="line-added">+   if (priv_state == PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added">+     PrivData *priv_data = mini_object-&gt;priv_pointer;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* Lock parents */</span>
<span class="line-added">+     while (!g_atomic_int_compare_and_exchange (&amp;priv_data-&gt;parent_lock, 0, 1));</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* If we have one parent, we&#39;re only writable if that parent is writable.</span>
<span class="line-added">+      * Otherwise if we have multiple parents we are not writable, and if</span>
<span class="line-added">+      * we have no parent, we are writable */</span>
<span class="line-added">+     if (priv_data-&gt;n_parents == 1)</span>
<span class="line-added">+       result = gst_mini_object_is_writable (priv_data-&gt;parents[0]);</span>
<span class="line-added">+     else if (priv_data-&gt;n_parents == 0)</span>
<span class="line-added">+       result = TRUE;</span>
<span class="line-added">+     else</span>
<span class="line-added">+       result = FALSE;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* Unlock again */</span>
<span class="line-added">+     g_atomic_int_set (&amp;priv_data-&gt;parent_lock, 0);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     if (priv_state == PRIV_DATA_STATE_ONE_PARENT) {</span>
<span class="line-added">+       result = gst_mini_object_is_writable (mini_object-&gt;priv_pointer);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       g_assert (priv_state == PRIV_DATA_STATE_NO_PARENT);</span>
<span class="line-added">+       result = TRUE;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* Unlock again */</span>
<span class="line-added">+     g_atomic_int_set ((gint *) &amp; mini_object-&gt;priv_uint, priv_state);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
    return result;
  }
  
  /**
   * gst_mini_object_make_writable: (skip)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 341,11 ***</span>
  {
    gint old_refcount, new_refcount;
  
    g_return_val_if_fail (mini_object != NULL, NULL);
    /* we can&#39;t assert that the refcount &gt; 0 since the _free functions
<span class="line-modified">!    * increments the refcount from 0 to 1 again to allow resurecting</span>
     * the object
     g_return_val_if_fail (mini_object-&gt;refcount &gt; 0, NULL);
     */
  
    old_refcount = g_atomic_int_add (&amp;mini_object-&gt;refcount, 1);
<span class="line-new-header">--- 452,11 ---</span>
  {
    gint old_refcount, new_refcount;
  
    g_return_val_if_fail (mini_object != NULL, NULL);
    /* we can&#39;t assert that the refcount &gt; 0 since the _free functions
<span class="line-modified">!    * increments the refcount from 0 to 1 again to allow resurrecting</span>
     * the object
     g_return_val_if_fail (mini_object-&gt;refcount &gt; 0, NULL);
     */
  
    old_refcount = g_atomic_int_add (&amp;mini_object-&gt;refcount, 1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 357,66 ***</span>
    GST_TRACER_MINI_OBJECT_REFFED (mini_object, new_refcount);
  
    return mini_object;
  }
  
  static gint
  find_notify (GstMiniObject * object, GQuark quark, gboolean match_notify,
      GstMiniObjectNotify notify, gpointer data)
  {
    guint i;
  
<span class="line-modified">!   for (i = 0; i &lt; object-&gt;n_qdata; i++) {</span>
<span class="line-modified">!     if (QDATA_QUARK (object, i) == quark) {</span>
        /* check if we need to match the callback too */
<span class="line-modified">!       if (!match_notify || (QDATA_NOTIFY (object, i) == notify &amp;&amp;</span>
<span class="line-modified">!               QDATA_DATA (object, i) == data))</span>
          return i;
      }
    }
    return -1;
  }
  
  static void
  remove_notify (GstMiniObject * object, gint index)
  {
    /* remove item */
<span class="line-modified">!   if (--object-&gt;n_qdata == 0) {</span>
      /* we don&#39;t shrink but free when everything is gone */
<span class="line-modified">!     g_free (object-&gt;qdata);</span>
<span class="line-modified">!     object-&gt;qdata = NULL;</span>
<span class="line-modified">!   } else if (index != object-&gt;n_qdata)</span>
<span class="line-modified">!     QDATA (object, index) = QDATA (object, object-&gt;n_qdata);</span>
  }
  
  static void
  set_notify (GstMiniObject * object, gint index, GQuark quark,
      GstMiniObjectNotify notify, gpointer data, GDestroyNotify destroy)
  {
    if (index == -1) {
      /* add item */
<span class="line-modified">!     index = object-&gt;n_qdata++;</span>
<span class="line-modified">!     object-&gt;qdata =</span>
<span class="line-modified">!         g_realloc (object-&gt;qdata, sizeof (GstQData) * object-&gt;n_qdata);</span>
    }
<span class="line-modified">!   QDATA_QUARK (object, index) = quark;</span>
<span class="line-modified">!   QDATA_NOTIFY (object, index) = notify;</span>
<span class="line-modified">!   QDATA_DATA (object, index) = data;</span>
<span class="line-modified">!   QDATA_DESTROY (object, index) = destroy;</span>
  }
  
  static void
<span class="line-modified">! call_finalize_notify (GstMiniObject * obj)</span>
  {
    guint i;
  
<span class="line-modified">!   for (i = 0; i &lt; obj-&gt;n_qdata; i++) {</span>
<span class="line-removed">-     if (QDATA_QUARK (obj, i) == weak_ref_quark)</span>
<span class="line-removed">-       QDATA_NOTIFY (obj, i) (QDATA_DATA (obj, i), obj);</span>
<span class="line-removed">-     if (QDATA_DESTROY (obj, i))</span>
<span class="line-removed">-       QDATA_DESTROY (obj, i) (QDATA_DATA (obj, i));</span>
    }
  }
  
  /**
   * gst_mini_object_unref: (skip)
   * @mini_object: the mini-object
<span class="line-new-header">--- 468,162 ---</span>
    GST_TRACER_MINI_OBJECT_REFFED (mini_object, new_refcount);
  
    return mini_object;
  }
  
<span class="line-added">+ /* Called with global qdata lock */</span>
  static gint
  find_notify (GstMiniObject * object, GQuark quark, gboolean match_notify,
      GstMiniObjectNotify notify, gpointer data)
  {
    guint i;
<span class="line-added">+   gint priv_state = g_atomic_int_get ((gint *) &amp; object-&gt;priv_uint);</span>
<span class="line-added">+   PrivData *priv_data;</span>
  
<span class="line-modified">!   if (priv_state != PRIV_DATA_STATE_PARENTS_OR_QDATA)</span>
<span class="line-modified">!     return -1;</span>
<span class="line-added">+ </span>
<span class="line-added">+   priv_data = object-&gt;priv_pointer;</span>
<span class="line-added">+ </span>
<span class="line-added">+   for (i = 0; i &lt; priv_data-&gt;n_qdata; i++) {</span>
<span class="line-added">+     if (QDATA_QUARK (priv_data, i) == quark) {</span>
        /* check if we need to match the callback too */
<span class="line-modified">!       if (!match_notify || (QDATA_NOTIFY (priv_data, i) == notify &amp;&amp;</span>
<span class="line-modified">!               QDATA_DATA (priv_data, i) == data))</span>
          return i;
      }
    }
    return -1;
  }
  
  static void
  remove_notify (GstMiniObject * object, gint index)
  {
<span class="line-added">+   gint priv_state = g_atomic_int_get ((gint *) &amp; object-&gt;priv_uint);</span>
<span class="line-added">+   PrivData *priv_data;</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_assert (priv_state == PRIV_DATA_STATE_PARENTS_OR_QDATA);</span>
<span class="line-added">+   priv_data = object-&gt;priv_pointer;</span>
<span class="line-added">+ </span>
    /* remove item */
<span class="line-modified">!   priv_data-&gt;n_qdata--;</span>
<span class="line-added">+   if (priv_data-&gt;n_qdata == 0) {</span>
      /* we don&#39;t shrink but free when everything is gone */
<span class="line-modified">!     g_free (priv_data-&gt;qdata);</span>
<span class="line-modified">!     priv_data-&gt;qdata = NULL;</span>
<span class="line-modified">!     priv_data-&gt;n_qdata_len = 0;</span>
<span class="line-modified">!   } else if (index != priv_data-&gt;n_qdata) {</span>
<span class="line-added">+     QDATA (priv_data, index) = QDATA (priv_data, priv_data-&gt;n_qdata);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /* Make sure we allocate the PrivData of this object if not happened yet */</span>
<span class="line-added">+ static void</span>
<span class="line-added">+ ensure_priv_data (GstMiniObject * object)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   gint priv_state;</span>
<span class="line-added">+   PrivData *priv_data;</span>
<span class="line-added">+   GstMiniObject *parent = NULL;</span>
<span class="line-added">+ </span>
<span class="line-added">+   GST_CAT_DEBUG (GST_CAT_PERFORMANCE,</span>
<span class="line-added">+       &quot;allocating private data %s miniobject %p&quot;,</span>
<span class="line-added">+       g_type_name (GST_MINI_OBJECT_TYPE (object)), object);</span>
<span class="line-added">+ </span>
<span class="line-added">+   priv_state = lock_priv_pointer (object);</span>
<span class="line-added">+   if (priv_state == PRIV_DATA_STATE_PARENTS_OR_QDATA)</span>
<span class="line-added">+     return;</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Now we&#39;re either locked, or someone has already allocated the struct</span>
<span class="line-added">+    * before us and we can just go ahead</span>
<span class="line-added">+    *</span>
<span class="line-added">+    * Note: if someone else allocated it in the meantime, we don&#39;t have to</span>
<span class="line-added">+    * unlock as we didn&#39;t lock! */</span>
<span class="line-added">+   if (priv_state != PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added">+     if (priv_state == PRIV_DATA_STATE_ONE_PARENT)</span>
<span class="line-added">+       parent = object-&gt;priv_pointer;</span>
<span class="line-added">+ </span>
<span class="line-added">+     object-&gt;priv_pointer = priv_data = g_new0 (PrivData, 1);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (parent) {</span>
<span class="line-added">+       priv_data-&gt;parents = g_new (GstMiniObject *, 16);</span>
<span class="line-added">+       priv_data-&gt;n_parents_len = 16;</span>
<span class="line-added">+       priv_data-&gt;n_parents = 1;</span>
<span class="line-added">+       priv_data-&gt;parents[0] = parent;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* Unlock */</span>
<span class="line-added">+     g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint,</span>
<span class="line-added">+         PRIV_DATA_STATE_PARENTS_OR_QDATA);</span>
<span class="line-added">+   }</span>
  }
  
  static void
  set_notify (GstMiniObject * object, gint index, GQuark quark,
      GstMiniObjectNotify notify, gpointer data, GDestroyNotify destroy)
  {
<span class="line-added">+   PrivData *priv_data;</span>
<span class="line-added">+ </span>
<span class="line-added">+   ensure_priv_data (object);</span>
<span class="line-added">+   priv_data = object-&gt;priv_pointer;</span>
<span class="line-added">+ </span>
    if (index == -1) {
      /* add item */
<span class="line-modified">!     index = priv_data-&gt;n_qdata++;</span>
<span class="line-modified">!     if (index &gt;= priv_data-&gt;n_qdata_len) {</span>
<span class="line-modified">!       priv_data-&gt;n_qdata_len *= 2;</span>
<span class="line-added">+       if (priv_data-&gt;n_qdata_len == 0)</span>
<span class="line-added">+         priv_data-&gt;n_qdata_len = 16;</span>
<span class="line-added">+ </span>
<span class="line-added">+       priv_data-&gt;qdata =</span>
<span class="line-added">+           g_realloc (priv_data-&gt;qdata,</span>
<span class="line-added">+           sizeof (GstQData) * priv_data-&gt;n_qdata_len);</span>
<span class="line-added">+     }</span>
    }
<span class="line-modified">! </span>
<span class="line-modified">!   QDATA_QUARK (priv_data, index) = quark;</span>
<span class="line-modified">!   QDATA_NOTIFY (priv_data, index) = notify;</span>
<span class="line-modified">!   QDATA_DATA (priv_data, index) = data;</span>
<span class="line-added">+   QDATA_DESTROY (priv_data, index) = destroy;</span>
  }
  
  static void
<span class="line-modified">! free_priv_data (GstMiniObject * obj)</span>
  {
    guint i;
<span class="line-added">+   gint priv_state = g_atomic_int_get ((gint *) &amp; obj-&gt;priv_uint);</span>
<span class="line-added">+   PrivData *priv_data;</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (priv_state != PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added">+     if (priv_state == PRIV_DATA_STATE_LOCKED) {</span>
<span class="line-added">+       g_warning</span>
<span class="line-added">+           (&quot;%s: object finalizing but has locked private data (object:%p)&quot;,</span>
<span class="line-added">+           G_STRFUNC, obj);</span>
<span class="line-added">+     } else if (priv_state == PRIV_DATA_STATE_ONE_PARENT) {</span>
<span class="line-added">+       g_warning</span>
<span class="line-added">+           (&quot;%s: object finalizing but still has parent (object:%p, parent:%p)&quot;,</span>
<span class="line-added">+           G_STRFUNC, obj, obj-&gt;priv_pointer);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     return;</span>
    }
<span class="line-added">+ </span>
<span class="line-added">+   priv_data = obj-&gt;priv_pointer;</span>
<span class="line-added">+ </span>
<span class="line-added">+   for (i = 0; i &lt; priv_data-&gt;n_qdata; i++) {</span>
<span class="line-added">+     if (QDATA_QUARK (priv_data, i) == weak_ref_quark)</span>
<span class="line-added">+       QDATA_NOTIFY (priv_data, i) (QDATA_DATA (priv_data, i), obj);</span>
<span class="line-added">+     if (QDATA_DESTROY (priv_data, i))</span>
<span class="line-added">+       QDATA_DESTROY (priv_data, i) (QDATA_DATA (priv_data, i));</span>
<span class="line-added">+   }</span>
<span class="line-added">+   g_free (priv_data-&gt;qdata);</span>
<span class="line-added">+ </span>
<span class="line-added">+   if (priv_data-&gt;n_parents)</span>
<span class="line-added">+     g_warning (&quot;%s: object finalizing but still has %d parents (object:%p)&quot;,</span>
<span class="line-added">+         G_STRFUNC, priv_data-&gt;n_parents, obj);</span>
<span class="line-added">+   g_free (priv_data-&gt;parents);</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_free (priv_data);</span>
  }
  
  /**
   * gst_mini_object_unref: (skip)
   * @mini_object: the mini-object
</pre>
<hr />
<pre>
<span class="line-old-header">*** 455,21 ***</span>
      if (G_LIKELY (do_free)) {
        /* there should be no outstanding locks */
        g_return_if_fail ((g_atomic_int_get (&amp;mini_object-&gt;lockstate) &amp; LOCK_MASK)
            &lt; 4);
  
<span class="line-modified">!       if (mini_object-&gt;n_qdata) {</span>
<span class="line-modified">!         call_finalize_notify (mini_object);</span>
<span class="line-removed">-         g_free (mini_object-&gt;qdata);</span>
<span class="line-removed">-       }</span>
        GST_TRACER_MINI_OBJECT_DESTROYED (mini_object);
        if (mini_object-&gt;free)
          mini_object-&gt;free (mini_object);
      }
    }
  }
  
  /**
   * gst_mini_object_replace:
   * @olddata: (inout) (transfer full) (nullable): pointer to a pointer to a
   *     mini-object to be replaced
   * @newdata: (allow-none): pointer to new mini-object
<span class="line-new-header">--- 662,43 ---</span>
      if (G_LIKELY (do_free)) {
        /* there should be no outstanding locks */
        g_return_if_fail ((g_atomic_int_get (&amp;mini_object-&gt;lockstate) &amp; LOCK_MASK)
            &lt; 4);
  
<span class="line-modified">!       free_priv_data (mini_object);</span>
<span class="line-modified">! </span>
        GST_TRACER_MINI_OBJECT_DESTROYED (mini_object);
        if (mini_object-&gt;free)
          mini_object-&gt;free (mini_object);
      }
    }
  }
  
<span class="line-added">+ /**</span>
<span class="line-added">+  * gst_clear_mini_object: (skip)</span>
<span class="line-added">+  * @object_ptr: a pointer to a #GstMiniObject reference</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Clears a reference to a #GstMiniObject.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * @object_ptr must not be %NULL.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * If the reference is %NULL then this function does nothing.</span>
<span class="line-added">+  * Otherwise, the reference count of the object is decreased using</span>
<span class="line-added">+  * gst_mini_object_unref() and the pointer is set to %NULL.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * A macro is also included that allows this function to be used without</span>
<span class="line-added">+  * pointer casts.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 1.16</span>
<span class="line-added">+  **/</span>
<span class="line-added">+ #undef gst_clear_mini_object</span>
<span class="line-added">+ void</span>
<span class="line-added">+ gst_clear_mini_object (GstMiniObject ** object_ptr)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   g_clear_pointer (object_ptr, gst_mini_object_unref);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  /**
   * gst_mini_object_replace:
   * @olddata: (inout) (transfer full) (nullable): pointer to a pointer to a
   *     mini-object to be replaced
   * @newdata: (allow-none): pointer to new mini-object
</pre>
<hr />
<pre>
<span class="line-old-header">*** 668,13 ***</span>
    g_return_if_fail (object != NULL);
    g_return_if_fail (quark &gt; 0);
  
    G_LOCK (qdata_mutex);
    if ((i = find_notify (object, quark, FALSE, NULL, NULL)) != -1) {
  
<span class="line-modified">!     old_data = QDATA_DATA (object, i);</span>
<span class="line-modified">!     old_notify = QDATA_DESTROY (object, i);</span>
  
      if (data == NULL)
        remove_notify (object, i);
    }
    if (data != NULL)
<span class="line-new-header">--- 897,14 ---</span>
    g_return_if_fail (object != NULL);
    g_return_if_fail (quark &gt; 0);
  
    G_LOCK (qdata_mutex);
    if ((i = find_notify (object, quark, FALSE, NULL, NULL)) != -1) {
<span class="line-added">+     PrivData *priv_data = object-&gt;priv_pointer;</span>
  
<span class="line-modified">!     old_data = QDATA_DATA (priv_data, i);</span>
<span class="line-modified">!     old_notify = QDATA_DESTROY (priv_data, i);</span>
  
      if (data == NULL)
        remove_notify (object, i);
    }
    if (data != NULL)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 704,14 ***</span>
  
    g_return_val_if_fail (object != NULL, NULL);
    g_return_val_if_fail (quark &gt; 0, NULL);
  
    G_LOCK (qdata_mutex);
<span class="line-modified">!   if ((i = find_notify (object, quark, FALSE, NULL, NULL)) != -1)</span>
<span class="line-modified">!     result = QDATA_DATA (object, i);</span>
<span class="line-modified">!   else</span>
      result = NULL;
    G_UNLOCK (qdata_mutex);
  
    return result;
  }
  
<span class="line-new-header">--- 934,16 ---</span>
  
    g_return_val_if_fail (object != NULL, NULL);
    g_return_val_if_fail (quark &gt; 0, NULL);
  
    G_LOCK (qdata_mutex);
<span class="line-modified">!   if ((i = find_notify (object, quark, FALSE, NULL, NULL)) != -1) {</span>
<span class="line-modified">!     PrivData *priv_data = object-&gt;priv_pointer;</span>
<span class="line-modified">!     result = QDATA_DATA (priv_data, i);</span>
<span class="line-added">+   } else {</span>
      result = NULL;
<span class="line-added">+   }</span>
    G_UNLOCK (qdata_mutex);
  
    return result;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 736,14 ***</span>
    g_return_val_if_fail (object != NULL, NULL);
    g_return_val_if_fail (quark &gt; 0, NULL);
  
    G_LOCK (qdata_mutex);
    if ((i = find_notify (object, quark, FALSE, NULL, NULL)) != -1) {
<span class="line-modified">!     result = QDATA_DATA (object, i);</span>
      remove_notify (object, i);
    } else {
      result = NULL;
    }
    G_UNLOCK (qdata_mutex);
  
    return result;
  }
<span class="line-new-header">--- 968,147 ---</span>
    g_return_val_if_fail (object != NULL, NULL);
    g_return_val_if_fail (quark &gt; 0, NULL);
  
    G_LOCK (qdata_mutex);
    if ((i = find_notify (object, quark, FALSE, NULL, NULL)) != -1) {
<span class="line-modified">!     PrivData *priv_data = object-&gt;priv_pointer;</span>
<span class="line-added">+     result = QDATA_DATA (priv_data, i);</span>
      remove_notify (object, i);
    } else {
      result = NULL;
    }
    G_UNLOCK (qdata_mutex);
  
    return result;
  }
<span class="line-added">+ </span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * gst_mini_object_add_parent:</span>
<span class="line-added">+  * @object: a #GstMiniObject</span>
<span class="line-added">+  * @parent: a parent #GstMiniObject</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * This adds @parent as a parent for @object. Having one ore more parents affects the</span>
<span class="line-added">+  * writability of @object: if a @parent is not writable, @object is also not</span>
<span class="line-added">+  * writable, regardless of its refcount. @object is only writable if all</span>
<span class="line-added">+  * the parents are writable and its own refcount is exactly 1.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Note: This function does not take ownership of @parent and also does not</span>
<span class="line-added">+  * take an additional reference. It is the responsibility of the caller to</span>
<span class="line-added">+  * remove the parent again at a later time.</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 1.16</span>
<span class="line-added">+  */</span>
<span class="line-added">+ void</span>
<span class="line-added">+ gst_mini_object_add_parent (GstMiniObject * object, GstMiniObject * parent)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   gint priv_state;</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_return_if_fail (object != NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   GST_CAT_TRACE (GST_CAT_REFCOUNTING, &quot;adding parent %p to object %p&quot;, parent,</span>
<span class="line-added">+       object);</span>
<span class="line-added">+ </span>
<span class="line-added">+   priv_state = lock_priv_pointer (object);</span>
<span class="line-added">+   /* If we already had one parent, we need to allocate the full struct now */</span>
<span class="line-added">+   if (priv_state == PRIV_DATA_STATE_ONE_PARENT) {</span>
<span class="line-added">+     /* Unlock again */</span>
<span class="line-added">+     g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint, priv_state);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ensure_priv_data (object);</span>
<span class="line-added">+     priv_state = PRIV_DATA_STATE_PARENTS_OR_QDATA;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Now we either have to add the new parent to the full struct, or add</span>
<span class="line-added">+    * our one and only parent to the pointer field */</span>
<span class="line-added">+   if (priv_state == PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added">+     PrivData *priv_data = object-&gt;priv_pointer;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* Lock parents */</span>
<span class="line-added">+     while (!g_atomic_int_compare_and_exchange (&amp;priv_data-&gt;parent_lock, 0, 1));</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (priv_data-&gt;n_parents &gt;= priv_data-&gt;n_parents_len) {</span>
<span class="line-added">+       priv_data-&gt;n_parents_len *= 2;</span>
<span class="line-added">+       if (priv_data-&gt;n_parents_len == 0)</span>
<span class="line-added">+         priv_data-&gt;n_parents_len = 16;</span>
<span class="line-added">+ </span>
<span class="line-added">+       priv_data-&gt;parents =</span>
<span class="line-added">+           g_realloc (priv_data-&gt;parents,</span>
<span class="line-added">+           priv_data-&gt;n_parents_len * sizeof (GstMiniObject *));</span>
<span class="line-added">+     }</span>
<span class="line-added">+     priv_data-&gt;parents[priv_data-&gt;n_parents] = parent;</span>
<span class="line-added">+     priv_data-&gt;n_parents++;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* Unlock again */</span>
<span class="line-added">+     g_atomic_int_set (&amp;priv_data-&gt;parent_lock, 0);</span>
<span class="line-added">+   } else if (priv_state == PRIV_DATA_STATE_NO_PARENT) {</span>
<span class="line-added">+     object-&gt;priv_pointer = parent;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* Unlock again */</span>
<span class="line-added">+     g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint, PRIV_DATA_STATE_ONE_PARENT);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     g_assert_not_reached ();</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ /**</span>
<span class="line-added">+  * gst_mini_object_remove_parent:</span>
<span class="line-added">+  * @object: a #GstMiniObject</span>
<span class="line-added">+  * @parent: a parent #GstMiniObject</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * This removes @parent as a parent for @object. See</span>
<span class="line-added">+  * gst_mini_object_add_parent().</span>
<span class="line-added">+  *</span>
<span class="line-added">+  * Since: 1.16</span>
<span class="line-added">+  */</span>
<span class="line-added">+ void</span>
<span class="line-added">+ gst_mini_object_remove_parent (GstMiniObject * object, GstMiniObject * parent)</span>
<span class="line-added">+ {</span>
<span class="line-added">+   gint priv_state;</span>
<span class="line-added">+ </span>
<span class="line-added">+   g_return_if_fail (object != NULL);</span>
<span class="line-added">+ </span>
<span class="line-added">+   GST_CAT_TRACE (GST_CAT_REFCOUNTING, &quot;removing parent %p from object %p&quot;,</span>
<span class="line-added">+       parent, object);</span>
<span class="line-added">+ </span>
<span class="line-added">+   priv_state = lock_priv_pointer (object);</span>
<span class="line-added">+ </span>
<span class="line-added">+   /* Now we either have to add the new parent to the full struct, or add</span>
<span class="line-added">+    * our one and only parent to the pointer field */</span>
<span class="line-added">+   if (priv_state == PRIV_DATA_STATE_PARENTS_OR_QDATA) {</span>
<span class="line-added">+     PrivData *priv_data = object-&gt;priv_pointer;</span>
<span class="line-added">+     guint i;</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* Lock parents */</span>
<span class="line-added">+     while (!g_atomic_int_compare_and_exchange (&amp;priv_data-&gt;parent_lock, 0, 1));</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (i = 0; i &lt; priv_data-&gt;n_parents; i++)</span>
<span class="line-added">+       if (parent == priv_data-&gt;parents[i])</span>
<span class="line-added">+         break;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (i != priv_data-&gt;n_parents) {</span>
<span class="line-added">+       priv_data-&gt;n_parents--;</span>
<span class="line-added">+       if (priv_data-&gt;n_parents != i)</span>
<span class="line-added">+         priv_data-&gt;parents[i] = priv_data-&gt;parents[priv_data-&gt;n_parents];</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       g_warning (&quot;%s: couldn&#39;t find parent %p (object:%p)&quot;, G_STRFUNC,</span>
<span class="line-added">+           object, parent);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     /* Unlock again */</span>
<span class="line-added">+     g_atomic_int_set (&amp;priv_data-&gt;parent_lock, 0);</span>
<span class="line-added">+   } else if (priv_state == PRIV_DATA_STATE_ONE_PARENT) {</span>
<span class="line-added">+     if (object-&gt;priv_pointer != parent) {</span>
<span class="line-added">+       g_warning (&quot;%s: couldn&#39;t find parent %p (object:%p)&quot;, G_STRFUNC,</span>
<span class="line-added">+           object, parent);</span>
<span class="line-added">+       /* Unlock again */</span>
<span class="line-added">+       g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint, priv_state);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       object-&gt;priv_pointer = NULL;</span>
<span class="line-added">+       /* Unlock again */</span>
<span class="line-added">+       g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint,</span>
<span class="line-added">+           PRIV_DATA_STATE_NO_PARENT);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     /* Unlock again */</span>
<span class="line-added">+     g_atomic_int_set ((gint *) &amp; object-&gt;priv_uint, PRIV_DATA_STATE_NO_PARENT);</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
</pre>
<center><a href="gstmeta.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gstminiobject.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>