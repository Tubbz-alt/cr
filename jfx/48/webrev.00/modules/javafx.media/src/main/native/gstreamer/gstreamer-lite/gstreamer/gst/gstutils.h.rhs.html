<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/gst/gstutils.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) 1999,2000 Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  *                    2000 Wim Taymans &lt;wtay@chello.be&gt;
   4  *                    2002 Thomas Vander Stichele &lt;thomas@apestaart.org&gt;
   5  *
   6  * gstutils.h: Header for various utility functions
   7  *
   8  * This library is free software; you can redistribute it and/or
   9  * modify it under the terms of the GNU Library General Public
  10  * License as published by the Free Software Foundation; either
  11  * version 2 of the License, or (at your option) any later version.
  12  *
  13  * This library is distributed in the hope that it will be useful,
  14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16  * Library General Public License for more details.
  17  *
  18  * You should have received a copy of the GNU Library General Public
  19  * License along with this library; if not, write to the
  20  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  21  * Boston, MA 02110-1301, USA.
  22  */
  23 
  24 
  25 #ifndef __GST_UTILS_H__
  26 #define __GST_UTILS_H__
  27 
  28 #include &lt;glib.h&gt;
  29 #include &lt;gst/gstconfig.h&gt;
  30 #include &lt;gst/gstbin.h&gt;
  31 #include &lt;gst/gstparse.h&gt;
  32 
  33 G_BEGIN_DECLS
  34 
  35 GST_API
  36 void            gst_util_set_value_from_string  (GValue *value, const gchar *value_str);
  37 
  38 GST_API
  39 void            gst_util_set_object_arg         (GObject *object, const gchar *name, const gchar *value);
  40 
  41 GST_API
  42 gboolean        gst_util_set_object_array       (GObject * object, const gchar * name,
  43                                                  const GValueArray * array);
  44 GST_API
  45 gboolean        gst_util_get_object_array       (GObject * object, const gchar * name,
  46                                                  GValueArray ** array);
  47 GST_API
  48 void            gst_util_dump_mem               (const guchar *mem, guint size);
  49 
  50 GST_API
  51 void            gst_util_dump_buffer            (GstBuffer * buf);
  52 
  53 GST_API
  54 guint64         gst_util_gdouble_to_guint64     (gdouble value)  G_GNUC_CONST;
  55 
  56 GST_API
  57 gdouble         gst_util_guint64_to_gdouble     (guint64 value)  G_GNUC_CONST;
  58 
  59 /**
  60  * gst_guint64_to_gdouble:
  61  * @value: the #guint64 value to convert
  62  *
  63  * Convert @value to a gdouble.
  64  *
  65  * Returns: @value converted to a #gdouble.
  66  */
  67 
  68 /**
  69  * gst_gdouble_to_guint64:
  70  * @value: the #gdouble value to convert
  71  *
  72  * Convert @value to a guint64.
  73  *
  74  * Returns: @value converted to a #guint64.
  75  */
  76 #ifdef WIN32
  77 #define         gst_gdouble_to_guint64(value)   gst_util_gdouble_to_guint64(value)
  78 #define         gst_guint64_to_gdouble(value)   gst_util_guint64_to_gdouble(value)
  79 #else
  80 #define         gst_gdouble_to_guint64(value)   ((guint64) (value))
  81 #define         gst_guint64_to_gdouble(value)   ((gdouble) (value))
  82 #endif
  83 
  84 GST_API
  85 guint64         gst_util_uint64_scale           (guint64 val, guint64 num, guint64 denom);
  86 
  87 GST_API
  88 guint64         gst_util_uint64_scale_round     (guint64 val, guint64 num, guint64 denom);
  89 
  90 GST_API
  91 guint64         gst_util_uint64_scale_ceil      (guint64 val, guint64 num, guint64 denom);
  92 
  93 GST_API
  94 guint64         gst_util_uint64_scale_int       (guint64 val, gint num, gint denom);
  95 
  96 GST_API
  97 guint64         gst_util_uint64_scale_int_round (guint64 val, gint num, gint denom);
  98 
  99 GST_API
 100 guint64         gst_util_uint64_scale_int_ceil  (guint64 val, gint num, gint denom);
 101 
 102 /**
 103  * GST_SEQNUM_INVALID:
 104  *
 105  * A value which is guaranteed to never be returned by
 106  * gst_util_seqnum_next().
 107  *
 108  * Can be used as a default value in variables used to store seqnum.
 109  *
 110  * Since: 1.14
 111  */
 112 #define GST_SEQNUM_INVALID (0)
 113 
 114 GST_API
 115 guint32         gst_util_seqnum_next            (void);
 116 
 117 GST_API
 118 gint32          gst_util_seqnum_compare         (guint32 s1, guint32 s2);
 119 
 120 /**
 121  * GST_GROUP_ID_INVALID:
 122  *
 123  * A value which is guaranteed to never be returned by
 124  * gst_util_group_id_next().
 125  *
 126  * Can be used as a default value in variables used to store group_id.
 127  *
 128  * Since: 1.14
 129  */
 130 #define GST_GROUP_ID_INVALID (0)
 131 
 132 GST_API
 133 guint           gst_util_group_id_next          (void);
 134 
 135 /**
 136  * GST_CALL_PARENT:
 137  * @parent_class_cast: the name of the class cast macro for the parent type
 138  * @name: name of the function to call
 139  * @args: arguments enclosed in &#39;( )&#39;
 140  *
 141  * Just call the parent handler.  This assumes that there is a variable
 142  * named parent_class that points to the (duh!) parent class.  Note that
 143  * this macro is not to be used with things that return something, use
 144  * the _WITH_DEFAULT version for that
 145  */
 146 #define GST_CALL_PARENT(parent_class_cast, name, args)                  \
 147         ((parent_class_cast(parent_class)-&gt;name != NULL) ?              \
 148          parent_class_cast(parent_class)-&gt;name args : (void) 0)
 149 
 150 /**
 151  * GST_CALL_PARENT_WITH_DEFAULT:
 152  * @parent_class_cast: the name of the class cast macro for the parent type
 153  * @name: name of the function to call
 154  * @args: arguments enclosed in &#39;( )&#39;
 155  * @def_return: default result
 156  *
 157  * Same as GST_CALL_PARENT(), but in case there is no implementation, it
 158  * evaluates to @def_return.
 159  */
 160 #define GST_CALL_PARENT_WITH_DEFAULT(parent_class_cast, name, args, def_return)\
 161         ((parent_class_cast(parent_class)-&gt;name != NULL) ?              \
 162          parent_class_cast(parent_class)-&gt;name args : def_return)
 163 
 164 /* Define PUT and GET functions for unaligned memory */
 165 #define _GST_GET(__data, __idx, __size, __shift) \
 166     (((guint##__size) (((const guint8 *) (__data))[__idx])) &lt;&lt; (__shift))
 167 
 168 #define _GST_PUT(__data, __idx, __size, __shift, __num) \
 169     (((guint8 *) (__data))[__idx] = (((guint##__size) (__num)) &gt;&gt; (__shift)) &amp; 0xff)
 170 
 171 #ifndef __GTK_DOC_IGNORE__
 172 #if GST_HAVE_UNALIGNED_ACCESS
 173 static inline guint16 __gst_fast_read16(const guint8 *v) {
 174   return *(const guint16*)(const void*)(v);
 175 }
 176 static inline guint32 __gst_fast_read32(const guint8 *v) {
 177   return *(const guint32*)(const void*)(v);
 178 }
 179 static inline guint64 __gst_fast_read64(const guint8 *v) {
 180   return *(const guint64*)(const void*)(v);
 181 }
 182 static inline guint16 __gst_fast_read_swap16(const guint8 *v) {
 183   return GUINT16_SWAP_LE_BE(*(const guint16*)(const void*)(v));
 184 }
 185 static inline guint32 __gst_fast_read_swap32(const guint8 *v) {
 186   return GUINT32_SWAP_LE_BE(*(const guint32*)(const void*)(v));
 187 }
 188 static inline guint64 __gst_fast_read_swap64(const guint8 *v) {
 189   return GUINT64_SWAP_LE_BE(*(const guint64*)(const void*)(v));
 190 }
 191 # define _GST_FAST_READ(s, d) __gst_fast_read##s((const guint8 *)(d))
 192 # define _GST_FAST_READ_SWAP(s, d) __gst_fast_read_swap##s((const guint8 *)(d))
 193 
 194 static inline void __gst_fast_write16 (guint8 *p, guint16 v) {
 195   *(guint16*)(void*)(p) = v;
 196 }
 197 static inline void __gst_fast_write32 (guint8 *p, guint32 v) {
 198   *(guint32*)(void*)(p) = v;
 199 }
 200 static inline void __gst_fast_write64 (guint8 *p, guint64 v) {
 201   *(guint64*)(void*)(p) = v;
 202 }
 203 static inline void __gst_fast_write_swap16 (guint8 *p, guint16 v) {
 204   *(guint16*)(void*)(p) = GUINT16_SWAP_LE_BE (v);
 205 }
 206 static inline void __gst_fast_write_swap32 (guint8 *p, guint32 v) {
 207   *(guint32*)(void*)(p) = GUINT32_SWAP_LE_BE (v);
 208 }
 209 static inline void __gst_fast_write_swap64 (guint8 *p, guint64 v) {
 210   *(guint64*)(void*)(p) = GUINT64_SWAP_LE_BE (v);
 211 }
 212 # define _GST_FAST_WRITE(s, d, v) __gst_fast_write##s((guint8 *)(d), (v))
 213 # define _GST_FAST_WRITE_SWAP(s, d, v) __gst_fast_write_swap##s((guint8 *)(d), (v))
 214 #endif
 215 #endif
 216 
 217 
 218 /**
 219  * GST_READ_UINT64_BE:
 220  * @data: memory location
 221  *
 222  * Read a 64 bit unsigned integer value in big endian format from the memory buffer.
 223  */
 224 
 225 /**
 226  * GST_READ_UINT64_LE:
 227  * @data: memory location
 228  *
 229  * Read a 64 bit unsigned integer value in little endian format from the memory buffer.
 230  */
 231 #if GST_HAVE_UNALIGNED_ACCESS
 232 # if (G_BYTE_ORDER == G_BIG_ENDIAN)
 233 #  define GST_READ_UINT64_BE(data)      _GST_FAST_READ (64, data)
 234 #  define GST_READ_UINT64_LE(data)      _GST_FAST_READ_SWAP (64, data)
 235 # else
 236 #  define GST_READ_UINT64_BE(data)      _GST_FAST_READ_SWAP (64, data)
 237 #  define GST_READ_UINT64_LE(data)      _GST_FAST_READ (64, data)
 238 # endif
 239 #else
<a name="1" id="anc1"></a><span class="line-modified"> 240 #define _GST_READ_UINT64_BE(data) (_GST_GET (data, 0, 64, 56) | \</span>
<span class="line-modified"> 241            _GST_GET (data, 1, 64, 48) | \</span>
<span class="line-modified"> 242            _GST_GET (data, 2, 64, 40) | \</span>
<span class="line-modified"> 243            _GST_GET (data, 3, 64, 32) | \</span>
<span class="line-modified"> 244            _GST_GET (data, 4, 64, 24) | \</span>
<span class="line-modified"> 245            _GST_GET (data, 5, 64, 16) | \</span>
<span class="line-modified"> 246            _GST_GET (data, 6, 64,  8) | \</span>
<span class="line-modified"> 247            _GST_GET (data, 7, 64,  0))</span>
<span class="line-modified"> 248 </span>
<span class="line-modified"> 249 #define _GST_READ_UINT64_LE(data) (_GST_GET (data, 7, 64, 56) | \</span>
<span class="line-modified"> 250            _GST_GET (data, 6, 64, 48) | \</span>
<span class="line-modified"> 251            _GST_GET (data, 5, 64, 40) | \</span>
<span class="line-modified"> 252            _GST_GET (data, 4, 64, 32) | \</span>
<span class="line-modified"> 253            _GST_GET (data, 3, 64, 24) | \</span>
<span class="line-modified"> 254            _GST_GET (data, 2, 64, 16) | \</span>
<span class="line-modified"> 255            _GST_GET (data, 1, 64,  8) | \</span>
<span class="line-modified"> 256            _GST_GET (data, 0, 64,  0))</span>
 257 
 258 #define GST_READ_UINT64_BE(data) __gst_slow_read64_be((const guint8 *)(data))
 259 static inline guint64 __gst_slow_read64_be (const guint8 * data) {
 260   return _GST_READ_UINT64_BE (data);
 261 }
 262 #define GST_READ_UINT64_LE(data) __gst_slow_read64_le((const guint8 *)(data))
 263 static inline guint64 __gst_slow_read64_le (const guint8 * data) {
 264   return _GST_READ_UINT64_LE (data);
 265 }
 266 #endif
 267 
 268 /**
 269  * GST_READ_UINT32_BE:
 270  * @data: memory location
 271  *
 272  * Read a 32 bit unsigned integer value in big endian format from the memory buffer.
 273  */
 274 
 275 /**
 276  * GST_READ_UINT32_LE:
 277  * @data: memory location
 278  *
 279  * Read a 32 bit unsigned integer value in little endian format from the memory buffer.
 280  */
 281 #if GST_HAVE_UNALIGNED_ACCESS
 282 # if (G_BYTE_ORDER == G_BIG_ENDIAN)
 283 #  define GST_READ_UINT32_BE(data)      _GST_FAST_READ (32, data)
 284 #  define GST_READ_UINT32_LE(data)      _GST_FAST_READ_SWAP (32, data)
 285 # else
 286 #  define GST_READ_UINT32_BE(data)      _GST_FAST_READ_SWAP (32, data)
 287 #  define GST_READ_UINT32_LE(data)      _GST_FAST_READ (32, data)
 288 # endif
 289 #else
<a name="2" id="anc2"></a><span class="line-modified"> 290 #define _GST_READ_UINT32_BE(data) (_GST_GET (data, 0, 32, 24) | \</span>
<span class="line-modified"> 291            _GST_GET (data, 1, 32, 16) | \</span>
<span class="line-modified"> 292            _GST_GET (data, 2, 32,  8) | \</span>
<span class="line-modified"> 293            _GST_GET (data, 3, 32,  0))</span>
 294 
<a name="3" id="anc3"></a><span class="line-modified"> 295 #define _GST_READ_UINT32_LE(data) (_GST_GET (data, 3, 32, 24) | \</span>
<span class="line-modified"> 296            _GST_GET (data, 2, 32, 16) | \</span>
<span class="line-modified"> 297            _GST_GET (data, 1, 32,  8) | \</span>
<span class="line-modified"> 298            _GST_GET (data, 0, 32,  0))</span>
 299 
 300 #define GST_READ_UINT32_BE(data) __gst_slow_read32_be((const guint8 *)(data))
 301 static inline guint32 __gst_slow_read32_be (const guint8 * data) {
 302   return _GST_READ_UINT32_BE (data);
 303 }
 304 #define GST_READ_UINT32_LE(data) __gst_slow_read32_le((const guint8 *)(data))
 305 static inline guint32 __gst_slow_read32_le (const guint8 * data) {
 306   return _GST_READ_UINT32_LE (data);
 307 }
 308 #endif
 309 
 310 /**
 311  * GST_READ_UINT24_BE:
 312  * @data: memory location
 313  *
 314  * Read a 24 bit unsigned integer value in big endian format from the memory buffer.
 315  */
 316 #define _GST_READ_UINT24_BE(data)       (_GST_GET (data, 0, 32, 16) | \
 317                                          _GST_GET (data, 1, 32,  8) | \
 318                                          _GST_GET (data, 2, 32,  0))
 319 
 320 #define GST_READ_UINT24_BE(data) __gst_slow_read24_be((const guint8 *)(data))
 321 static inline guint32 __gst_slow_read24_be (const guint8 * data) {
 322   return _GST_READ_UINT24_BE (data);
 323 }
 324 
 325 /**
 326  * GST_READ_UINT24_LE:
 327  * @data: memory location
 328  *
 329  * Read a 24 bit unsigned integer value in little endian format from the memory buffer.
 330  */
 331 #define _GST_READ_UINT24_LE(data)       (_GST_GET (data, 2, 32, 16) | \
 332                                          _GST_GET (data, 1, 32,  8) | \
 333                                          _GST_GET (data, 0, 32,  0))
 334 
 335 #define GST_READ_UINT24_LE(data) __gst_slow_read24_le((const guint8 *)(data))
 336 static inline guint32 __gst_slow_read24_le (const guint8 * data) {
 337   return _GST_READ_UINT24_LE (data);
 338 }
 339 
 340 /**
 341  * GST_READ_UINT16_BE:
 342  * @data: memory location
 343  *
 344  * Read a 16 bit unsigned integer value in big endian format from the memory buffer.
 345  */
 346 /**
 347  * GST_READ_UINT16_LE:
 348  * @data: memory location
 349  *
 350  * Read a 16 bit unsigned integer value in little endian format from the memory buffer.
 351  */
 352 #if GST_HAVE_UNALIGNED_ACCESS
 353 # if (G_BYTE_ORDER == G_BIG_ENDIAN)
 354 #  define GST_READ_UINT16_BE(data)      _GST_FAST_READ (16, data)
 355 #  define GST_READ_UINT16_LE(data)      _GST_FAST_READ_SWAP (16, data)
 356 # else
 357 #  define GST_READ_UINT16_BE(data)      _GST_FAST_READ_SWAP (16, data)
 358 #  define GST_READ_UINT16_LE(data)      _GST_FAST_READ (16, data)
 359 # endif
 360 #else
<a name="4" id="anc4"></a><span class="line-modified"> 361 #define _GST_READ_UINT16_BE(data) (_GST_GET (data, 0, 16,  8) | \</span>
<span class="line-modified"> 362            _GST_GET (data, 1, 16,  0))</span>
 363 
<a name="5" id="anc5"></a><span class="line-modified"> 364 #define _GST_READ_UINT16_LE(data) (_GST_GET (data, 1, 16,  8) | \</span>
<span class="line-modified"> 365            _GST_GET (data, 0, 16,  0))</span>
 366 
 367 #define GST_READ_UINT16_BE(data) __gst_slow_read16_be((const guint8 *)(data))
 368 static inline guint16 __gst_slow_read16_be (const guint8 * data) {
 369   return _GST_READ_UINT16_BE (data);
 370 }
 371 #define GST_READ_UINT16_LE(data) __gst_slow_read16_le((const guint8 *)(data))
 372 static inline guint16 __gst_slow_read16_le (const guint8 * data) {
 373   return _GST_READ_UINT16_LE (data);
 374 }
 375 #endif
 376 
 377 /**
 378  * GST_READ_UINT8:
 379  * @data: memory location
 380  *
 381  * Read an 8 bit unsigned integer value from the memory buffer.
 382  */
 383 #define GST_READ_UINT8(data)            (_GST_GET (data, 0,  8,  0))
 384 
 385 /**
 386  * GST_WRITE_UINT64_BE:
 387  * @data: memory location
 388  * @val: value to store
 389  *
 390  * Store a 64 bit unsigned integer value in big endian format into the memory buffer.
 391  */
 392 /**
 393  * GST_WRITE_UINT64_LE:
 394  * @data: memory location
 395  * @val: value to store
 396  *
 397  * Store a 64 bit unsigned integer value in little endian format into the memory buffer.
 398  */
 399 #if GST_HAVE_UNALIGNED_ACCESS
 400 # if (G_BYTE_ORDER == G_BIG_ENDIAN)
 401 #  define GST_WRITE_UINT64_BE(data,val) _GST_FAST_WRITE(64,data,val)
 402 #  define GST_WRITE_UINT64_LE(data,val) _GST_FAST_WRITE_SWAP(64,data,val)
 403 # else
 404 #  define GST_WRITE_UINT64_BE(data,val) _GST_FAST_WRITE_SWAP(64,data,val)
 405 #  define GST_WRITE_UINT64_LE(data,val) _GST_FAST_WRITE(64,data,val)
 406 # endif
 407 #else
 408 #define GST_WRITE_UINT64_BE(data,val)   do { \
 409                                           gpointer __put_data = data; \
 410                                           guint64 __put_val = val; \
 411                                           _GST_PUT (__put_data, 0, 64, 56, __put_val); \
 412                                           _GST_PUT (__put_data, 1, 64, 48, __put_val); \
 413                                           _GST_PUT (__put_data, 2, 64, 40, __put_val); \
 414                                           _GST_PUT (__put_data, 3, 64, 32, __put_val); \
 415                                           _GST_PUT (__put_data, 4, 64, 24, __put_val); \
 416                                           _GST_PUT (__put_data, 5, 64, 16, __put_val); \
 417                                           _GST_PUT (__put_data, 6, 64,  8, __put_val); \
 418                                           _GST_PUT (__put_data, 7, 64,  0, __put_val); \
 419                                         } while (0)
 420 
 421 #define GST_WRITE_UINT64_LE(data,val)   do { \
 422                                           gpointer __put_data = data; \
 423                                           guint64 __put_val = val; \
 424                                           _GST_PUT (__put_data, 0, 64,  0, __put_val); \
 425                                           _GST_PUT (__put_data, 1, 64,  8, __put_val); \
 426                                           _GST_PUT (__put_data, 2, 64, 16, __put_val); \
 427                                           _GST_PUT (__put_data, 3, 64, 24, __put_val); \
 428                                           _GST_PUT (__put_data, 4, 64, 32, __put_val); \
 429                                           _GST_PUT (__put_data, 5, 64, 40, __put_val); \
 430                                           _GST_PUT (__put_data, 6, 64, 48, __put_val); \
 431                                           _GST_PUT (__put_data, 7, 64, 56, __put_val); \
 432                                         } while (0)
 433 #endif /* !GST_HAVE_UNALIGNED_ACCESS */
 434 
 435 /**
 436  * GST_WRITE_UINT32_BE:
 437  * @data: memory location
 438  * @val: value to store
 439  *
 440  * Store a 32 bit unsigned integer value in big endian format into the memory buffer.
 441  */
 442 /**
 443  * GST_WRITE_UINT32_LE:
 444  * @data: memory location
 445  * @val: value to store
 446  *
 447  * Store a 32 bit unsigned integer value in little endian format into the memory buffer.
 448  */
 449 #if GST_HAVE_UNALIGNED_ACCESS
 450 # if (G_BYTE_ORDER == G_BIG_ENDIAN)
 451 #  define GST_WRITE_UINT32_BE(data,val) _GST_FAST_WRITE(32,data,val)
 452 #  define GST_WRITE_UINT32_LE(data,val) _GST_FAST_WRITE_SWAP(32,data,val)
 453 # else
 454 #  define GST_WRITE_UINT32_BE(data,val) _GST_FAST_WRITE_SWAP(32,data,val)
 455 #  define GST_WRITE_UINT32_LE(data,val) _GST_FAST_WRITE(32,data,val)
 456 # endif
 457 #else
 458 #define GST_WRITE_UINT32_BE(data,val)   do { \
 459                                           gpointer __put_data = data; \
 460                                           guint32 __put_val = val; \
 461                                           _GST_PUT (__put_data, 0, 32, 24, __put_val); \
 462                                           _GST_PUT (__put_data, 1, 32, 16, __put_val); \
 463                                           _GST_PUT (__put_data, 2, 32,  8, __put_val); \
 464                                           _GST_PUT (__put_data, 3, 32,  0, __put_val); \
 465                                         } while (0)
 466 
 467 #define GST_WRITE_UINT32_LE(data,val)   do { \
 468                                           gpointer __put_data = data; \
 469                                           guint32 __put_val = val; \
 470                                           _GST_PUT (__put_data, 0, 32,  0, __put_val); \
 471                                           _GST_PUT (__put_data, 1, 32,  8, __put_val); \
 472                                           _GST_PUT (__put_data, 2, 32, 16, __put_val); \
 473                                           _GST_PUT (__put_data, 3, 32, 24, __put_val); \
 474                                         } while (0)
 475 #endif /* !GST_HAVE_UNALIGNED_ACCESS */
 476 
 477 /**
 478  * GST_WRITE_UINT24_BE:
 479  * @data: memory location
 480  * @num: value to store
 481  *
 482  * Store a 24 bit unsigned integer value in big endian format into the memory buffer.
 483  */
 484 #define GST_WRITE_UINT24_BE(data, num)  do { \
 485                                           gpointer __put_data = data; \
 486                                           guint32 __put_val = num; \
 487                                           _GST_PUT (__put_data, 0, 32,  16, __put_val); \
 488                                           _GST_PUT (__put_data, 1, 32,  8, __put_val); \
 489                                           _GST_PUT (__put_data, 2, 32,  0, __put_val); \
 490                                         } while (0)
 491 
 492 /**
 493  * GST_WRITE_UINT24_LE:
 494  * @data: memory location
 495  * @num: value to store
 496  *
 497  * Store a 24 bit unsigned integer value in little endian format into the memory buffer.
 498  */
 499 #define GST_WRITE_UINT24_LE(data, num)  do { \
 500                                           gpointer __put_data = data; \
 501                                           guint32 __put_val = num; \
 502                                           _GST_PUT (__put_data, 0, 32,  0, __put_val); \
 503                                           _GST_PUT (__put_data, 1, 32,  8, __put_val); \
 504                                           _GST_PUT (__put_data, 2, 32,  16, __put_val); \
 505                                         } while (0)
 506 
 507 /**
 508  * GST_WRITE_UINT16_BE:
 509  * @data: memory location
 510  * @val: value to store
 511  *
 512  * Store a 16 bit unsigned integer value in big endian format into the memory buffer.
 513  */
 514 /**
 515  * GST_WRITE_UINT16_LE:
 516  * @data: memory location
 517  * @val: value to store
 518  *
 519  * Store a 16 bit unsigned integer value in little endian format into the memory buffer.
 520  */
 521 #if GST_HAVE_UNALIGNED_ACCESS
 522 # if (G_BYTE_ORDER == G_BIG_ENDIAN)
 523 #  define GST_WRITE_UINT16_BE(data,val) _GST_FAST_WRITE(16,data,val)
 524 #  define GST_WRITE_UINT16_LE(data,val) _GST_FAST_WRITE_SWAP(16,data,val)
 525 # else
 526 #  define GST_WRITE_UINT16_BE(data,val) _GST_FAST_WRITE_SWAP(16,data,val)
 527 #  define GST_WRITE_UINT16_LE(data,val) _GST_FAST_WRITE(16,data,val)
 528 # endif
 529 #else
 530 #define GST_WRITE_UINT16_BE(data,val)   do { \
 531                                           gpointer __put_data = data; \
 532                                           guint16 __put_val = val; \
 533                                           _GST_PUT (__put_data, 0, 16,  8, __put_val); \
 534                                           _GST_PUT (__put_data, 1, 16,  0, __put_val); \
 535                                         } while (0)
 536 
 537 #define GST_WRITE_UINT16_LE(data,val)   do { \
 538                                           gpointer __put_data = data; \
 539                                           guint16 __put_val = val; \
 540                                           _GST_PUT (__put_data, 0, 16,  0, __put_val); \
 541                                           _GST_PUT (__put_data, 1, 16,  8, __put_val); \
 542                                         } while (0)
 543 #endif /* !GST_HAVE_UNALIGNED_ACCESS */
 544 
 545 /**
 546  * GST_WRITE_UINT8:
 547  * @data: memory location
 548  * @num: value to store
 549  *
 550  * Store an 8 bit unsigned integer value into the memory buffer.
 551  */
 552 #define GST_WRITE_UINT8(data, num)      do { \
 553                                           _GST_PUT (data, 0,  8,  0, num); \
 554                                         } while (0)
 555 
 556 /* Float endianness conversion macros */
 557 
 558 /* FIXME: Remove this once we depend on a GLib version with this */
 559 #ifndef GFLOAT_FROM_LE
 560 /**
 561  * GFLOAT_SWAP_LE_BE:
 562  * @in: input value
 563  *
 564  * Swap byte order of a 32-bit floating point value (float).
 565  *
 566  * Returns: @in byte-swapped.
 567  */
 568 static inline gfloat
 569 GFLOAT_SWAP_LE_BE(gfloat in)
 570 {
 571   union
 572   {
 573     guint32 i;
 574     gfloat f;
 575   } u;
 576 
 577   u.f = in;
 578   u.i = GUINT32_SWAP_LE_BE (u.i);
 579   return u.f;
 580 }
 581 
 582 /**
 583  * GDOUBLE_SWAP_LE_BE:
 584  * @in: input value
 585  *
 586  * Swap byte order of a 64-bit floating point value (double).
 587  *
 588  * Returns: @in byte-swapped.
 589  */
 590 static inline gdouble
 591 GDOUBLE_SWAP_LE_BE(gdouble in)
 592 {
 593   union
 594   {
 595     guint64 i;
 596     gdouble d;
 597   } u;
 598 
 599   u.d = in;
 600   u.i = GUINT64_SWAP_LE_BE (u.i);
 601   return u.d;
 602 }
 603 
 604 /**
 605  * GDOUBLE_TO_LE:
 606  * @val: value
 607  *
 608  * Convert 64-bit floating point value (double) from native byte order into
 609  * little endian byte order.
 610  */
 611 /**
 612  * GDOUBLE_TO_BE:
 613  * @val: value
 614  *
 615  * Convert 64-bit floating point value (double) from native byte order into
 616  * big endian byte order.
 617  */
 618 /**
 619  * GDOUBLE_FROM_LE:
 620  * @val: value
 621  *
 622  * Convert 64-bit floating point value (double) from little endian byte order
 623  * into native byte order.
 624  */
 625 /**
 626  * GDOUBLE_FROM_BE:
 627  * @val: value
 628  *
 629  * Convert 64-bit floating point value (double) from big endian byte order
 630  * into native byte order.
 631  */
 632 
 633 /**
 634  * GFLOAT_TO_LE:
 635  * @val: value
 636  *
 637  * Convert 32-bit floating point value (float) from native byte order into
 638  * little endian byte order.
 639  */
 640 /**
 641  * GFLOAT_TO_BE:
 642  * @val: value
 643  *
 644  * Convert 32-bit floating point value (float) from native byte order into
 645  * big endian byte order.
 646  */
 647 /**
 648  * GFLOAT_FROM_LE:
 649  * @val: value
 650  *
 651  * Convert 32-bit floating point value (float) from little endian byte order
 652  * into native byte order.
 653  */
 654 /**
 655  * GFLOAT_FROM_BE:
 656  * @val: value
 657  *
 658  * Convert 32-bit floating point value (float) from big endian byte order
 659  * into native byte order.
 660  */
 661 
 662 #if G_BYTE_ORDER == G_LITTLE_ENDIAN
 663 #define GFLOAT_TO_LE(val)    ((gfloat) (val))
 664 #define GFLOAT_TO_BE(val)    (GFLOAT_SWAP_LE_BE (val))
 665 #define GDOUBLE_TO_LE(val)   ((gdouble) (val))
 666 #define GDOUBLE_TO_BE(val)   (GDOUBLE_SWAP_LE_BE (val))
 667 
 668 #elif G_BYTE_ORDER == G_BIG_ENDIAN
 669 #define GFLOAT_TO_LE(val)    (GFLOAT_SWAP_LE_BE (val))
 670 #define GFLOAT_TO_BE(val)    ((gfloat) (val))
 671 #define GDOUBLE_TO_LE(val)   (GDOUBLE_SWAP_LE_BE (val))
 672 #define GDOUBLE_TO_BE(val)   ((gdouble) (val))
 673 
 674 #else /* !G_LITTLE_ENDIAN &amp;&amp; !G_BIG_ENDIAN */
 675 #error unknown ENDIAN type
 676 #endif /* !G_LITTLE_ENDIAN &amp;&amp; !G_BIG_ENDIAN */
 677 
 678 #define GFLOAT_FROM_LE(val)  (GFLOAT_TO_LE (val))
 679 #define GFLOAT_FROM_BE(val)  (GFLOAT_TO_BE (val))
 680 #define GDOUBLE_FROM_LE(val) (GDOUBLE_TO_LE (val))
 681 #define GDOUBLE_FROM_BE(val) (GDOUBLE_TO_BE (val))
 682 
 683 #endif /* !defined(GFLOAT_FROM_LE) */
 684 
 685 /**
 686  * GST_READ_FLOAT_LE:
 687  * @data: memory location
 688  *
 689  * Read a 32 bit float value in little endian format from the memory buffer.
 690  *
 691  * Returns: The floating point value read from @data
 692  */
 693 static inline gfloat
 694 GST_READ_FLOAT_LE(const guint8 *data)
 695 {
 696   union
 697   {
 698     guint32 i;
 699     gfloat f;
 700   } u;
 701 
 702   u.i = GST_READ_UINT32_LE (data);
 703   return u.f;
 704 }
 705 
 706 /**
 707  * GST_READ_FLOAT_BE:
 708  * @data: memory location
 709  *
 710  * Read a 32 bit float value in big endian format from the memory buffer.
 711  *
 712  * Returns: The floating point value read from @data
 713  */
 714 static inline gfloat
 715 GST_READ_FLOAT_BE(const guint8 *data)
 716 {
 717   union
 718   {
 719     guint32 i;
 720     gfloat f;
 721   } u;
 722 
 723   u.i = GST_READ_UINT32_BE (data);
 724   return u.f;
 725 }
 726 
 727 /**
 728  * GST_READ_DOUBLE_LE:
 729  * @data: memory location
 730  *
 731  * Read a 64 bit double value in little endian format from the memory buffer.
 732  *
 733  * Returns: The double-precision floating point value read from @data
 734  */
 735 static inline gdouble
 736 GST_READ_DOUBLE_LE(const guint8 *data)
 737 {
 738   union
 739   {
 740     guint64 i;
 741     gdouble d;
 742   } u;
 743 
 744   u.i = GST_READ_UINT64_LE (data);
 745   return u.d;
 746 }
 747 
 748 /**
 749  * GST_READ_DOUBLE_BE:
 750  * @data: memory location
 751  *
 752  * Read a 64 bit double value in big endian format from the memory buffer.
 753  *
 754  * Returns: The double-precision floating point value read from @data
 755  */
 756 static inline gdouble
 757 GST_READ_DOUBLE_BE(const guint8 *data)
 758 {
 759   union
 760   {
 761     guint64 i;
 762     gdouble d;
 763   } u;
 764 
 765   u.i = GST_READ_UINT64_BE (data);
 766   return u.d;
 767 }
 768 
 769 /**
 770  * GST_WRITE_FLOAT_LE:
 771  * @data: memory location
 772  * @num: value to store
 773  *
 774  * Store a 32 bit float value in little endian format into the memory buffer.
 775  */
 776 static inline void
 777 GST_WRITE_FLOAT_LE(guint8 *data, gfloat num)
 778 {
 779   union
 780   {
 781     guint32 i;
 782     gfloat f;
 783   } u;
 784 
 785   u.f = num;
 786   GST_WRITE_UINT32_LE (data, u.i);
 787 }
 788 
 789 /**
 790  * GST_WRITE_FLOAT_BE:
 791  * @data: memory location
 792  * @num: value to store
 793  *
 794  * Store a 32 bit float value in big endian format into the memory buffer.
 795  */
 796 static inline void
 797 GST_WRITE_FLOAT_BE(guint8 *data, gfloat num)
 798 {
 799   union
 800   {
 801     guint32 i;
 802     gfloat f;
 803   } u;
 804 
 805   u.f = num;
 806   GST_WRITE_UINT32_BE (data, u.i);
 807 }
 808 
 809 /**
 810  * GST_WRITE_DOUBLE_LE:
 811  * @data: memory location
 812  * @num: value to store
 813  *
 814  * Store a 64 bit double value in little endian format into the memory buffer.
 815  */
 816 static inline void
 817 GST_WRITE_DOUBLE_LE(guint8 *data, gdouble num)
 818 {
 819   union
 820   {
 821     guint64 i;
 822     gdouble d;
 823   } u;
 824 
 825   u.d = num;
 826   GST_WRITE_UINT64_LE (data, u.i);
 827 }
 828 
 829 /**
 830  * GST_WRITE_DOUBLE_BE:
 831  * @data: memory location
 832  * @num: value to store
 833  *
 834  * Store a 64 bit double value in big endian format into the memory buffer.
 835  */
 836 static inline void
 837 GST_WRITE_DOUBLE_BE(guint8 *data, gdouble num)
 838 {
 839   union
 840   {
 841     guint64 i;
 842     gdouble d;
 843   } u;
 844 
 845   u.d = num;
 846   GST_WRITE_UINT64_BE (data, u.i);
 847 }
 848 
 849 /* Miscellaneous utility macros */
 850 
 851 /**
 852  * GST_ROUND_UP_2:
 853  * @num: integer value to round up
 854  *
 855  * Rounds an integer value up to the next multiple of 2.
 856  */
 857 #define GST_ROUND_UP_2(num)  (((num)+1)&amp;~1)
 858 /**
 859  * GST_ROUND_UP_4:
 860  * @num: integer value to round up
 861  *
 862  * Rounds an integer value up to the next multiple of 4.
 863  */
 864 #define GST_ROUND_UP_4(num)  (((num)+3)&amp;~3)
 865 /**
 866  * GST_ROUND_UP_8:
 867  * @num: integer value to round up
 868  *
 869  * Rounds an integer value up to the next multiple of 8.
 870  */
 871 #define GST_ROUND_UP_8(num)  (((num)+7)&amp;~7)
 872 /**
 873  * GST_ROUND_UP_16:
 874  * @num: integer value to round up
 875  *
 876  * Rounds an integer value up to the next multiple of 16.
 877  */
 878 #define GST_ROUND_UP_16(num) (((num)+15)&amp;~15)
 879 /**
 880  * GST_ROUND_UP_32:
 881  * @num: integer value to round up
 882  *
 883  * Rounds an integer value up to the next multiple of 32.
 884  */
 885 #define GST_ROUND_UP_32(num) (((num)+31)&amp;~31)
 886 /**
 887  * GST_ROUND_UP_64:
 888  * @num: integer value to round up
 889  *
 890  * Rounds an integer value up to the next multiple of 64.
 891  */
 892 #define GST_ROUND_UP_64(num) (((num)+63)&amp;~63)
 893 /**
 894  * GST_ROUND_UP_128:
 895  * @num: integer value to round up
 896  *
 897  * Rounds an integer value up to the next multiple of 128.
 898  * Since: 1.4
 899  */
 900 #define GST_ROUND_UP_128(num) (((num)+127)&amp;~127)
 901 /**
 902  * GST_ROUND_UP_N:
 903  * @num: integrer value to round up
 904  * @align: a power of two to round up to
 905  *
 906  * Rounds an integer value up to the next multiple of @align. @align MUST be a
 907  * power of two.
 908  */
 909 #define GST_ROUND_UP_N(num,align) ((((num) + ((align) - 1)) &amp; ~((align) - 1)))
 910 
 911 
 912 /**
 913  * GST_ROUND_DOWN_2:
 914  * @num: integer value to round down
 915  *
 916  * Rounds an integer value down to the next multiple of 2.
 917  */
 918 #define GST_ROUND_DOWN_2(num)  ((num)&amp;(~1))
 919 /**
 920  * GST_ROUND_DOWN_4:
 921  * @num: integer value to round down
 922  *
 923  * Rounds an integer value down to the next multiple of 4.
 924  */
 925 #define GST_ROUND_DOWN_4(num)  ((num)&amp;(~3))
 926 /**
 927  * GST_ROUND_DOWN_8:
 928  * @num: integer value to round down
 929  *
 930  * Rounds an integer value down to the next multiple of 8.
 931  */
 932 #define GST_ROUND_DOWN_8(num)  ((num)&amp;(~7))
 933 /**
 934  * GST_ROUND_DOWN_16:
 935  * @num: integer value to round down
 936  *
 937  * Rounds an integer value down to the next multiple of 16.
 938  */
 939 #define GST_ROUND_DOWN_16(num) ((num)&amp;(~15))
 940 /**
 941  * GST_ROUND_DOWN_32:
 942  * @num: integer value to round down
 943  *
 944  * Rounds an integer value down to the next multiple of 32.
 945  */
 946 #define GST_ROUND_DOWN_32(num) ((num)&amp;(~31))
 947 /**
 948  * GST_ROUND_DOWN_64:
 949  * @num: integer value to round down
 950  *
 951  * Rounds an integer value down to the next multiple of 64.
 952  */
 953 #define GST_ROUND_DOWN_64(num) ((num)&amp;(~63))
 954 /**
 955  * GST_ROUND_DOWN_128:
 956  * @num: integer value to round down
 957  *
 958  * Rounds an integer value down to the next multiple of 128.
 959  * Since: 1.4
 960  */
 961 #define GST_ROUND_DOWN_128(num) ((num)&amp;(~127))
 962 /**
 963  * GST_ROUND_DOWN_N:
 964  * @num: integrer value to round down
 965  * @align: a power of two to round down to
 966  *
 967  * Rounds an integer value down to the next multiple of @align. @align MUST be a
 968  * power of two.
 969  */
 970 #define GST_ROUND_DOWN_N(num,align) (((num) &amp; ~((align) - 1)))
 971 
 972 
 973 GST_API
 974 void                    gst_object_default_error        (GstObject    * source,
 975                                                          const GError * error,
 976                                                          const gchar  * debug);
 977 
 978 /* element functions */
 979 
 980 GST_API
 981 void                    gst_element_create_all_pads     (GstElement *element);
 982 
 983 GST_API
 984 GstPad*                 gst_element_get_compatible_pad  (GstElement *element, GstPad *pad,
 985                                                          GstCaps *caps);
 986 GST_API
 987 GstPadTemplate*         gst_element_get_compatible_pad_template (GstElement *element, GstPadTemplate *compattempl);
 988 
 989 GST_API
 990 const gchar*            gst_element_state_get_name      (GstState state);
 991 
 992 GST_API
 993 const gchar *           gst_element_state_change_return_get_name (GstStateChangeReturn state_ret);
 994 
 995 GST_API
 996 const gchar *           gst_state_change_get_name       (GstStateChange transition);
 997 
 998 GST_API
 999 gboolean                gst_element_link                (GstElement *src, GstElement *dest);
1000 
1001 GST_API
1002 gboolean                gst_element_link_many           (GstElement *element_1,
1003                                                          GstElement *element_2, ...) G_GNUC_NULL_TERMINATED;
1004 GST_API
1005 gboolean                gst_element_link_filtered       (GstElement * src,
1006                                                          GstElement * dest,
1007                                                          GstCaps *filter);
1008 GST_API
1009 void                    gst_element_unlink              (GstElement *src, GstElement *dest);
1010 
1011 GST_API
1012 void                    gst_element_unlink_many         (GstElement *element_1,
1013                                                          GstElement *element_2, ...) G_GNUC_NULL_TERMINATED;
1014 GST_API
1015 gboolean                gst_element_link_pads           (GstElement *src, const gchar *srcpadname,
1016                                                          GstElement *dest, const gchar *destpadname);
1017 GST_API
1018 gboolean                gst_element_link_pads_full      (GstElement *src, const gchar *srcpadname,
1019                                                          GstElement *dest, const gchar *destpadname,
1020                                                          GstPadLinkCheck flags);
1021 GST_API
1022 void                    gst_element_unlink_pads         (GstElement *src, const gchar *srcpadname,
1023                                                          GstElement *dest, const gchar *destpadname);
1024 GST_API
1025 gboolean                gst_element_link_pads_filtered  (GstElement * src, const gchar * srcpadname,
1026                                                          GstElement * dest, const gchar * destpadname,
1027                                                          GstCaps *filter);
1028 GST_API
1029 gboolean                gst_element_seek_simple         (GstElement   *element,
1030                                                          GstFormat     format,
1031                                                          GstSeekFlags  seek_flags,
1032                                                          gint64        seek_pos);
1033 
1034 /* util elementfactory functions */
1035 
1036 GST_API
1037 gboolean gst_element_factory_can_sink_all_caps (GstElementFactory *factory, const GstCaps *caps);
1038 
1039 GST_API
1040 gboolean gst_element_factory_can_src_all_caps  (GstElementFactory *factory, const GstCaps *caps);
1041 
1042 GST_API
1043 gboolean gst_element_factory_can_sink_any_caps (GstElementFactory *factory, const GstCaps *caps);
1044 
1045 GST_API
1046 gboolean gst_element_factory_can_src_any_caps  (GstElementFactory *factory, const GstCaps *caps);
1047 
1048 /* util query functions */
1049 
1050 GST_API
1051 gboolean                gst_element_query_position      (GstElement *element, GstFormat format, gint64 *cur);
1052 
1053 GST_API
1054 gboolean                gst_element_query_duration      (GstElement *element, GstFormat format, gint64 *duration);
1055 
1056 GST_API
1057 gboolean                gst_element_query_convert       (GstElement *element, GstFormat src_format, gint64 src_val,
1058                                                          GstFormat dest_format, gint64 *dest_val);
1059 
1060 /* pad functions */
1061 
1062 GST_API
1063 void                    gst_pad_use_fixed_caps          (GstPad *pad);
1064 
1065 GST_API
1066 GstElement*             gst_pad_get_parent_element      (GstPad *pad);
1067 
1068 /* util query functions */
1069 
1070 GST_API
1071 gboolean                gst_pad_proxy_query_accept_caps (GstPad *pad, GstQuery *query);
1072 
1073 GST_API
1074 gboolean                gst_pad_proxy_query_caps        (GstPad *pad, GstQuery *query);
1075 
1076 GST_API
1077 gboolean                gst_pad_query_position          (GstPad *pad, GstFormat format, gint64 *cur);
1078 
1079 GST_API
1080 gboolean                gst_pad_query_duration          (GstPad *pad, GstFormat format, gint64 *duration);
1081 
1082 GST_API
1083 gboolean                gst_pad_query_convert           (GstPad *pad, GstFormat src_format, gint64 src_val,
1084                                                          GstFormat dest_format, gint64 *dest_val);
1085 GST_API
1086 GstCaps *               gst_pad_query_caps              (GstPad *pad, GstCaps *filter);
1087 
1088 GST_API
1089 gboolean                gst_pad_query_accept_caps       (GstPad *pad, GstCaps *caps);
1090 
1091 GST_API
1092 gboolean                gst_pad_link_maybe_ghosting      (GstPad            *src,
1093                                                           GstPad            *sink);
1094 GST_API
1095 gboolean                gst_pad_link_maybe_ghosting_full (GstPad            *src,
1096                                                           GstPad            *sink,
1097                                                           GstPadLinkCheck   flags);
1098 GST_API
1099 gboolean                gst_pad_peer_query_position     (GstPad *pad, GstFormat format, gint64 *cur);
1100 
1101 GST_API
1102 gboolean                gst_pad_peer_query_duration     (GstPad *pad, GstFormat format, gint64 *duration);
1103 
1104 GST_API
1105 gboolean                gst_pad_peer_query_convert      (GstPad *pad, GstFormat src_format, gint64 src_val,
1106                                                          GstFormat dest_format, gint64 *dest_val);
1107 GST_API
1108 GstCaps *               gst_pad_peer_query_caps         (GstPad * pad, GstCaps *filter);
1109 
1110 GST_API
1111 gboolean                gst_pad_peer_query_accept_caps  (GstPad * pad, GstCaps *caps);
1112 
1113 GST_API
1114 gchar *                 gst_pad_create_stream_id               (GstPad * pad, GstElement * parent, const gchar *stream_id) G_GNUC_MALLOC;
1115 
1116 GST_API
1117 gchar *                 gst_pad_create_stream_id_printf        (GstPad * pad, GstElement * parent, const gchar *stream_id, ...) G_GNUC_PRINTF (3, 4) G_GNUC_MALLOC;
1118 
1119 GST_API
1120 gchar *                 gst_pad_create_stream_id_printf_valist (GstPad * pad, GstElement * parent, const gchar *stream_id, va_list var_args) G_GNUC_PRINTF (3, 0) G_GNUC_MALLOC;
1121 
1122 GST_API
1123 gchar *                 gst_pad_get_stream_id           (GstPad * pad);
1124 
1125 GST_API
1126 GstStream *             gst_pad_get_stream              (GstPad * pad);
1127 
1128 /* bin functions */
1129 
1130 GST_API
1131 void                    gst_bin_add_many                (GstBin *bin, GstElement *element_1, ...) G_GNUC_NULL_TERMINATED;
1132 
1133 GST_API
1134 void                    gst_bin_remove_many             (GstBin *bin, GstElement *element_1, ...) G_GNUC_NULL_TERMINATED;
1135 
1136 GST_API
1137 GstPad *                gst_bin_find_unlinked_pad       (GstBin *bin, GstPadDirection direction);
1138 
1139 GST_API
1140 gboolean                gst_bin_sync_children_states    (GstBin *bin);
1141 
1142 /* parse utility functions */
1143 
1144 GST_API
1145 GstElement *            gst_parse_bin_from_description      (const gchar     * bin_description,
1146                                                              gboolean          ghost_unlinked_pads,
1147                                                              GError         ** err);
1148 GST_API
1149 GstElement *            gst_parse_bin_from_description_full (const gchar     * bin_description,
1150                                                              gboolean          ghost_unlinked_pads,
1151                                                              GstParseContext * context,
1152                                                              GstParseFlags     flags,
1153                                                              GError         ** err);
1154 GST_API
1155 GstClockTime            gst_util_get_timestamp          (void);
1156 
1157 /**
1158  * GstSearchMode:
1159  * @GST_SEARCH_MODE_EXACT : Only search for exact matches.
1160  * @GST_SEARCH_MODE_BEFORE: Search for an exact match or the element just before.
1161  * @GST_SEARCH_MODE_AFTER : Search for an exact match or the element just after.
1162  *
1163  * The different search modes.
1164  */
1165 typedef enum {
1166   GST_SEARCH_MODE_EXACT = 0,
1167   GST_SEARCH_MODE_BEFORE,
1168   GST_SEARCH_MODE_AFTER
1169 } GstSearchMode;
1170 
1171 GST_API
1172 gpointer      gst_util_array_binary_search      (gpointer array, guint num_elements,
1173                                                  gsize element_size, GCompareDataFunc search_func,
1174                                                  GstSearchMode mode, gconstpointer search_data,
1175                                                  gpointer user_data);
1176 
1177 /* fraction operations */
1178 
1179 GST_API
1180 gint          gst_util_greatest_common_divisor  (gint a, gint b);
1181 
1182 GST_API
1183 gint64        gst_util_greatest_common_divisor_int64 (gint64 a, gint64 b);
1184 
1185 GST_API
1186 void          gst_util_fraction_to_double       (gint src_n, gint src_d, gdouble *dest);
1187 
1188 GST_API
1189 void          gst_util_double_to_fraction       (gdouble src, gint *dest_n, gint *dest_d);
1190 
1191 GST_API
1192 gboolean      gst_util_fraction_multiply        (gint a_n, gint a_d, gint b_n, gint b_d,
1193                                                  gint *res_n, gint *res_d);
1194 GST_API
1195 gboolean      gst_util_fraction_add             (gint a_n, gint a_d, gint b_n, gint b_d,
1196                                                  gint *res_n, gint *res_d);
1197 GST_API
1198 gint          gst_util_fraction_compare         (gint a_n, gint a_d, gint b_n, gint b_d);
1199 
1200 GST_API
1201 gboolean      gst_calculate_linear_regression   (const GstClockTime * xy,
1202                                                  GstClockTime * temp, guint n,
1203                                                  GstClockTime * m_num, GstClockTime * m_denom,
1204                                                  GstClockTime * b, GstClockTime * xbase,
1205                                                  gdouble * r_squared);
1206 
1207 
1208 G_END_DECLS
1209 
1210 #endif /* __GST_UTILS_H__ */
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>