<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gparamspecs.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gparam.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gparamspecs.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/gobject/gparamspecs.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  36 /**
  37  * SECTION:param_value_types
  38  * @short_description: Standard Parameter and Value Types
  39  * @see_also: #GParamSpec, #GValue, g_object_class_install_property().
  40  * @title: Parameters and Values
  41  *
  42  * #GValue provides an abstract container structure which can be
  43  * copied, transformed and compared while holding a value of any
  44  * (derived) type, which is registered as a #GType with a
  45  * #GTypeValueTable in its #GTypeInfo structure.  Parameter
  46  * specifications for most value types can be created as #GParamSpec
  47  * derived instances, to implement e.g. #GObject properties which
  48  * operate on #GValue containers.
  49  *
  50  * Parameter names need to start with a letter (a-z or A-Z). Subsequent
  51  * characters can be letters, numbers or a &#39;-&#39;.
  52  * All other characters are replaced by a &#39;-&#39; during construction.
  53  */
  54 
  55 
<span class="line-modified">  56 #define G_FLOAT_EPSILON     (1e-30)</span>
<span class="line-modified">  57 #define G_DOUBLE_EPSILON    (1e-90)</span>
  58 
  59 
  60 /* --- param spec functions --- */
  61 static void
  62 param_char_init (GParamSpec *pspec)
  63 {
  64   GParamSpecChar *cspec = G_PARAM_SPEC_CHAR (pspec);
  65 
  66   cspec-&gt;minimum = 0x7f;
  67   cspec-&gt;maximum = 0x80;
  68   cspec-&gt;default_value = 0;
  69 }
  70 
  71 static void
  72 param_char_set_default (GParamSpec *pspec,
<span class="line-modified">  73             GValue     *value)</span>
  74 {
  75   value-&gt;data[0].v_int = G_PARAM_SPEC_CHAR (pspec)-&gt;default_value;
  76 }
  77 
  78 static gboolean
  79 param_char_validate (GParamSpec *pspec,
<span class="line-modified">  80              GValue     *value)</span>
  81 {
  82   GParamSpecChar *cspec = G_PARAM_SPEC_CHAR (pspec);
  83   gint oval = value-&gt;data[0].v_int;
  84 
  85   value-&gt;data[0].v_int = CLAMP (value-&gt;data[0].v_int, cspec-&gt;minimum, cspec-&gt;maximum);
  86 
  87   return value-&gt;data[0].v_int != oval;
  88 }
  89 
  90 static void
  91 param_uchar_init (GParamSpec *pspec)
  92 {
  93   GParamSpecUChar *uspec = G_PARAM_SPEC_UCHAR (pspec);
  94 
  95   uspec-&gt;minimum = 0;
  96   uspec-&gt;maximum = 0xff;
  97   uspec-&gt;default_value = 0;
  98 }
  99 
 100 static void
 101 param_uchar_set_default (GParamSpec *pspec,
<span class="line-modified"> 102              GValue     *value)</span>
 103 {
 104   value-&gt;data[0].v_uint = G_PARAM_SPEC_UCHAR (pspec)-&gt;default_value;
 105 }
 106 
 107 static gboolean
 108 param_uchar_validate (GParamSpec *pspec,
<span class="line-modified"> 109               GValue     *value)</span>
 110 {
 111   GParamSpecUChar *uspec = G_PARAM_SPEC_UCHAR (pspec);
 112   guint oval = value-&gt;data[0].v_uint;
 113 
 114   value-&gt;data[0].v_uint = CLAMP (value-&gt;data[0].v_uint, uspec-&gt;minimum, uspec-&gt;maximum);
 115 
 116   return value-&gt;data[0].v_uint != oval;
 117 }
 118 
 119 static void
 120 param_boolean_set_default (GParamSpec *pspec,
<span class="line-modified"> 121                GValue     *value)</span>
 122 {
 123   value-&gt;data[0].v_int = G_PARAM_SPEC_BOOLEAN (pspec)-&gt;default_value;
 124 }
 125 
 126 static gboolean
 127 param_boolean_validate (GParamSpec *pspec,
<span class="line-modified"> 128             GValue     *value)</span>
 129 {
 130   gint oval = value-&gt;data[0].v_int;
 131 
 132   value-&gt;data[0].v_int = value-&gt;data[0].v_int != FALSE;
 133 
 134   return value-&gt;data[0].v_int != oval;
 135 }
 136 
 137 static void
 138 param_int_init (GParamSpec *pspec)
 139 {
 140   GParamSpecInt *ispec = G_PARAM_SPEC_INT (pspec);
 141 
 142   ispec-&gt;minimum = 0x7fffffff;
 143   ispec-&gt;maximum = 0x80000000;
 144   ispec-&gt;default_value = 0;
 145 }
 146 
 147 static void
 148 param_int_set_default (GParamSpec *pspec,
<span class="line-modified"> 149                GValue     *value)</span>
 150 {
 151   value-&gt;data[0].v_int = G_PARAM_SPEC_INT (pspec)-&gt;default_value;
 152 }
 153 
 154 static gboolean
 155 param_int_validate (GParamSpec *pspec,
<span class="line-modified"> 156             GValue     *value)</span>
 157 {
 158   GParamSpecInt *ispec = G_PARAM_SPEC_INT (pspec);
 159   gint oval = value-&gt;data[0].v_int;
 160 
 161   value-&gt;data[0].v_int = CLAMP (value-&gt;data[0].v_int, ispec-&gt;minimum, ispec-&gt;maximum);
 162 
 163   return value-&gt;data[0].v_int != oval;
 164 }
 165 
 166 static gint
 167 param_int_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 168               const GValue *value1,</span>
<span class="line-modified"> 169               const GValue *value2)</span>
 170 {
 171   if (value1-&gt;data[0].v_int &lt; value2-&gt;data[0].v_int)
 172     return -1;
 173   else
 174     return value1-&gt;data[0].v_int &gt; value2-&gt;data[0].v_int;
 175 }
 176 
 177 static void
 178 param_uint_init (GParamSpec *pspec)
 179 {
 180   GParamSpecUInt *uspec = G_PARAM_SPEC_UINT (pspec);
 181 
 182   uspec-&gt;minimum = 0;
 183   uspec-&gt;maximum = 0xffffffff;
 184   uspec-&gt;default_value = 0;
 185 }
 186 
 187 static void
 188 param_uint_set_default (GParamSpec *pspec,
<span class="line-modified"> 189             GValue     *value)</span>
 190 {
 191   value-&gt;data[0].v_uint = G_PARAM_SPEC_UINT (pspec)-&gt;default_value;
 192 }
 193 
 194 static gboolean
 195 param_uint_validate (GParamSpec *pspec,
<span class="line-modified"> 196              GValue     *value)</span>
 197 {
 198   GParamSpecUInt *uspec = G_PARAM_SPEC_UINT (pspec);
 199   guint oval = value-&gt;data[0].v_uint;
 200 
 201   value-&gt;data[0].v_uint = CLAMP (value-&gt;data[0].v_uint, uspec-&gt;minimum, uspec-&gt;maximum);
 202 
 203   return value-&gt;data[0].v_uint != oval;
 204 }
 205 
 206 static gint
 207 param_uint_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 208                const GValue *value1,</span>
<span class="line-modified"> 209                const GValue *value2)</span>
 210 {
 211   if (value1-&gt;data[0].v_uint &lt; value2-&gt;data[0].v_uint)
 212     return -1;
 213   else
 214     return value1-&gt;data[0].v_uint &gt; value2-&gt;data[0].v_uint;
 215 }
 216 
 217 static void
 218 param_long_init (GParamSpec *pspec)
 219 {
 220   GParamSpecLong *lspec = G_PARAM_SPEC_LONG (pspec);
 221 
 222 #if SIZEOF_LONG == 4
 223   lspec-&gt;minimum = 0x7fffffff;
 224   lspec-&gt;maximum = 0x80000000;
 225 #else /* SIZEOF_LONG != 4 (8) */
 226   lspec-&gt;minimum = 0x7fffffffffffffff;
 227   lspec-&gt;maximum = 0x8000000000000000;
 228 #endif
 229   lspec-&gt;default_value = 0;
 230 }
 231 
 232 static void
 233 param_long_set_default (GParamSpec *pspec,
<span class="line-modified"> 234             GValue     *value)</span>
 235 {
 236   value-&gt;data[0].v_long = G_PARAM_SPEC_LONG (pspec)-&gt;default_value;
 237 }
 238 
 239 static gboolean
 240 param_long_validate (GParamSpec *pspec,
<span class="line-modified"> 241              GValue     *value)</span>
 242 {
 243   GParamSpecLong *lspec = G_PARAM_SPEC_LONG (pspec);
 244   glong oval = value-&gt;data[0].v_long;
 245 
 246   value-&gt;data[0].v_long = CLAMP (value-&gt;data[0].v_long, lspec-&gt;minimum, lspec-&gt;maximum);
 247 
 248   return value-&gt;data[0].v_long != oval;
 249 }
 250 
 251 static gint
 252 param_long_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 253                const GValue *value1,</span>
<span class="line-modified"> 254                const GValue *value2)</span>
 255 {
 256   if (value1-&gt;data[0].v_long &lt; value2-&gt;data[0].v_long)
 257     return -1;
 258   else
 259     return value1-&gt;data[0].v_long &gt; value2-&gt;data[0].v_long;
 260 }
 261 
 262 static void
 263 param_ulong_init (GParamSpec *pspec)
 264 {
 265   GParamSpecULong *uspec = G_PARAM_SPEC_ULONG (pspec);
 266 
 267   uspec-&gt;minimum = 0;
 268 #if SIZEOF_LONG == 4
 269   uspec-&gt;maximum = 0xffffffff;
 270 #else /* SIZEOF_LONG != 4 (8) */
 271   uspec-&gt;maximum = 0xffffffffffffffff;
 272 #endif
 273   uspec-&gt;default_value = 0;
 274 }
 275 
 276 static void
 277 param_ulong_set_default (GParamSpec *pspec,
<span class="line-modified"> 278              GValue     *value)</span>
 279 {
 280   value-&gt;data[0].v_ulong = G_PARAM_SPEC_ULONG (pspec)-&gt;default_value;
 281 }
 282 
 283 static gboolean
 284 param_ulong_validate (GParamSpec *pspec,
<span class="line-modified"> 285               GValue     *value)</span>
 286 {
 287   GParamSpecULong *uspec = G_PARAM_SPEC_ULONG (pspec);
 288   gulong oval = value-&gt;data[0].v_ulong;
 289 
 290   value-&gt;data[0].v_ulong = CLAMP (value-&gt;data[0].v_ulong, uspec-&gt;minimum, uspec-&gt;maximum);
 291 
 292   return value-&gt;data[0].v_ulong != oval;
 293 }
 294 
 295 static gint
 296 param_ulong_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 297             const GValue *value1,</span>
<span class="line-modified"> 298             const GValue *value2)</span>
 299 {
 300   if (value1-&gt;data[0].v_ulong &lt; value2-&gt;data[0].v_ulong)
 301     return -1;
 302   else
 303     return value1-&gt;data[0].v_ulong &gt; value2-&gt;data[0].v_ulong;
 304 }
 305 
 306 static void
 307 param_int64_init (GParamSpec *pspec)
 308 {
 309   GParamSpecInt64 *lspec = G_PARAM_SPEC_INT64 (pspec);
 310 
 311   lspec-&gt;minimum = G_MININT64;
 312   lspec-&gt;maximum = G_MAXINT64;
 313   lspec-&gt;default_value = 0;
 314 }
 315 
 316 static void
 317 param_int64_set_default (GParamSpec *pspec,
<span class="line-modified"> 318             GValue     *value)</span>
 319 {
 320   value-&gt;data[0].v_int64 = G_PARAM_SPEC_INT64 (pspec)-&gt;default_value;
 321 }
 322 
 323 static gboolean
 324 param_int64_validate (GParamSpec *pspec,
<span class="line-modified"> 325              GValue     *value)</span>
 326 {
 327   GParamSpecInt64 *lspec = G_PARAM_SPEC_INT64 (pspec);
 328   gint64 oval = value-&gt;data[0].v_int64;
 329 
 330   value-&gt;data[0].v_int64 = CLAMP (value-&gt;data[0].v_int64, lspec-&gt;minimum, lspec-&gt;maximum);
 331 
 332   return value-&gt;data[0].v_int64 != oval;
 333 }
 334 
 335 static gint
 336 param_int64_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 337                const GValue *value1,</span>
<span class="line-modified"> 338                const GValue *value2)</span>
 339 {
 340   if (value1-&gt;data[0].v_int64 &lt; value2-&gt;data[0].v_int64)
 341     return -1;
 342   else
 343     return value1-&gt;data[0].v_int64 &gt; value2-&gt;data[0].v_int64;
 344 }
 345 
 346 static void
 347 param_uint64_init (GParamSpec *pspec)
 348 {
 349   GParamSpecUInt64 *uspec = G_PARAM_SPEC_UINT64 (pspec);
 350 
 351   uspec-&gt;minimum = 0;
 352   uspec-&gt;maximum = G_MAXUINT64;
 353   uspec-&gt;default_value = 0;
 354 }
 355 
 356 static void
 357 param_uint64_set_default (GParamSpec *pspec,
<span class="line-modified"> 358              GValue     *value)</span>
 359 {
 360   value-&gt;data[0].v_uint64 = G_PARAM_SPEC_UINT64 (pspec)-&gt;default_value;
 361 }
 362 
 363 static gboolean
 364 param_uint64_validate (GParamSpec *pspec,
<span class="line-modified"> 365               GValue     *value)</span>
 366 {
 367   GParamSpecUInt64 *uspec = G_PARAM_SPEC_UINT64 (pspec);
 368   guint64 oval = value-&gt;data[0].v_uint64;
 369 
 370   value-&gt;data[0].v_uint64 = CLAMP (value-&gt;data[0].v_uint64, uspec-&gt;minimum, uspec-&gt;maximum);
 371 
 372   return value-&gt;data[0].v_uint64 != oval;
 373 }
 374 
 375 static gint
 376 param_uint64_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 377             const GValue *value1,</span>
<span class="line-modified"> 378             const GValue *value2)</span>
 379 {
 380   if (value1-&gt;data[0].v_uint64 &lt; value2-&gt;data[0].v_uint64)
 381     return -1;
 382   else
 383     return value1-&gt;data[0].v_uint64 &gt; value2-&gt;data[0].v_uint64;
 384 }
 385 
 386 static void
 387 param_unichar_init (GParamSpec *pspec)
 388 {
 389   GParamSpecUnichar *uspec = G_PARAM_SPEC_UNICHAR (pspec);
 390 
 391   uspec-&gt;default_value = 0;
 392 }
 393 
 394 static void
 395 param_unichar_set_default (GParamSpec *pspec,
<span class="line-modified"> 396              GValue     *value)</span>
 397 {
 398   value-&gt;data[0].v_uint = G_PARAM_SPEC_UNICHAR (pspec)-&gt;default_value;
 399 }
 400 
 401 static gboolean
 402 param_unichar_validate (GParamSpec *pspec,
<span class="line-modified"> 403                 GValue     *value)</span>
 404 {
 405   gunichar oval = value-&gt;data[0].v_uint;
 406   gboolean changed = FALSE;
 407 
 408   if (!g_unichar_validate (oval))
 409     {
 410       value-&gt;data[0].v_uint = 0;
 411       changed = TRUE;
 412     }
 413 
 414   return changed;
 415 }
 416 
 417 static gint
 418 param_unichar_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 419             const GValue *value1,</span>
<span class="line-modified"> 420             const GValue *value2)</span>
 421 {
 422   if (value1-&gt;data[0].v_uint &lt; value2-&gt;data[0].v_uint)
 423     return -1;
 424   else
 425     return value1-&gt;data[0].v_uint &gt; value2-&gt;data[0].v_uint;
 426 }
 427 
 428 static void
 429 param_enum_init (GParamSpec *pspec)
 430 {
 431   GParamSpecEnum *espec = G_PARAM_SPEC_ENUM (pspec);
 432 
 433   espec-&gt;enum_class = NULL;
 434   espec-&gt;default_value = 0;
 435 }
 436 
 437 static void
 438 param_enum_finalize (GParamSpec *pspec)
 439 {
 440   GParamSpecEnum *espec = G_PARAM_SPEC_ENUM (pspec);
 441   GParamSpecClass *parent_class = g_type_class_peek (g_type_parent (G_TYPE_PARAM_ENUM));
 442 
 443   if (espec-&gt;enum_class)
 444     {
 445       g_type_class_unref (espec-&gt;enum_class);
 446       espec-&gt;enum_class = NULL;
 447     }
 448 
 449   parent_class-&gt;finalize (pspec);
 450 }
 451 
 452 static void
 453 param_enum_set_default (GParamSpec *pspec,
<span class="line-modified"> 454             GValue     *value)</span>
 455 {
 456   value-&gt;data[0].v_long = G_PARAM_SPEC_ENUM (pspec)-&gt;default_value;
 457 }
 458 
 459 static gboolean
 460 param_enum_validate (GParamSpec *pspec,
<span class="line-modified"> 461              GValue     *value)</span>
 462 {
 463   GParamSpecEnum *espec = G_PARAM_SPEC_ENUM (pspec);
 464   glong oval = value-&gt;data[0].v_long;
 465 
 466   if (!espec-&gt;enum_class ||
 467       !g_enum_get_value (espec-&gt;enum_class, value-&gt;data[0].v_long))
 468     value-&gt;data[0].v_long = espec-&gt;default_value;
 469 
 470   return value-&gt;data[0].v_long != oval;
 471 }
 472 
 473 static void
 474 param_flags_init (GParamSpec *pspec)
 475 {
 476   GParamSpecFlags *fspec = G_PARAM_SPEC_FLAGS (pspec);
 477 
 478   fspec-&gt;flags_class = NULL;
 479   fspec-&gt;default_value = 0;
 480 }
 481 
 482 static void
 483 param_flags_finalize (GParamSpec *pspec)
 484 {
 485   GParamSpecFlags *fspec = G_PARAM_SPEC_FLAGS (pspec);
 486   GParamSpecClass *parent_class = g_type_class_peek (g_type_parent (G_TYPE_PARAM_FLAGS));
 487 
 488   if (fspec-&gt;flags_class)
 489     {
 490       g_type_class_unref (fspec-&gt;flags_class);
 491       fspec-&gt;flags_class = NULL;
 492     }
 493 
 494   parent_class-&gt;finalize (pspec);
 495 }
 496 
 497 static void
 498 param_flags_set_default (GParamSpec *pspec,
<span class="line-modified"> 499              GValue     *value)</span>
 500 {
 501   value-&gt;data[0].v_ulong = G_PARAM_SPEC_FLAGS (pspec)-&gt;default_value;
 502 }
 503 
 504 static gboolean
 505 param_flags_validate (GParamSpec *pspec,
<span class="line-modified"> 506               GValue     *value)</span>
 507 {
 508   GParamSpecFlags *fspec = G_PARAM_SPEC_FLAGS (pspec);
 509   gulong oval = value-&gt;data[0].v_ulong;
 510 
 511   if (fspec-&gt;flags_class)
 512     value-&gt;data[0].v_ulong &amp;= fspec-&gt;flags_class-&gt;mask;
 513   else
 514     value-&gt;data[0].v_ulong = fspec-&gt;default_value;
 515 
 516   return value-&gt;data[0].v_ulong != oval;
 517 }
 518 
 519 static void
 520 param_float_init (GParamSpec *pspec)
 521 {
 522   GParamSpecFloat *fspec = G_PARAM_SPEC_FLOAT (pspec);
 523 
 524   fspec-&gt;minimum = -G_MAXFLOAT;
 525   fspec-&gt;maximum = G_MAXFLOAT;
 526   fspec-&gt;default_value = 0;
 527   fspec-&gt;epsilon = G_FLOAT_EPSILON;
 528 }
 529 
 530 static void
 531 param_float_set_default (GParamSpec *pspec,
<span class="line-modified"> 532              GValue     *value)</span>
 533 {
 534   value-&gt;data[0].v_float = G_PARAM_SPEC_FLOAT (pspec)-&gt;default_value;
 535 }
 536 
 537 static gboolean
 538 param_float_validate (GParamSpec *pspec,
<span class="line-modified"> 539               GValue     *value)</span>
 540 {
 541   GParamSpecFloat *fspec = G_PARAM_SPEC_FLOAT (pspec);
 542   gfloat oval = value-&gt;data[0].v_float;
 543 
 544   value-&gt;data[0].v_float = CLAMP (value-&gt;data[0].v_float, fspec-&gt;minimum, fspec-&gt;maximum);
 545 
 546   return value-&gt;data[0].v_float != oval;
 547 }
 548 
 549 static gint
 550 param_float_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 551             const GValue *value1,</span>
<span class="line-modified"> 552             const GValue *value2)</span>
 553 {
 554   gfloat epsilon = G_PARAM_SPEC_FLOAT (pspec)-&gt;epsilon;
 555 
 556   if (value1-&gt;data[0].v_float &lt; value2-&gt;data[0].v_float)
 557     return - (value2-&gt;data[0].v_float - value1-&gt;data[0].v_float &gt; epsilon);
 558   else
 559     return value1-&gt;data[0].v_float - value2-&gt;data[0].v_float &gt; epsilon;
 560 }
 561 
 562 static void
 563 param_double_init (GParamSpec *pspec)
 564 {
 565   GParamSpecDouble *dspec = G_PARAM_SPEC_DOUBLE (pspec);
 566 
 567   dspec-&gt;minimum = -G_MAXDOUBLE;
 568   dspec-&gt;maximum = G_MAXDOUBLE;
 569   dspec-&gt;default_value = 0;
 570   dspec-&gt;epsilon = G_DOUBLE_EPSILON;
 571 }
 572 
 573 static void
 574 param_double_set_default (GParamSpec *pspec,
<span class="line-modified"> 575               GValue     *value)</span>
 576 {
 577   value-&gt;data[0].v_double = G_PARAM_SPEC_DOUBLE (pspec)-&gt;default_value;
 578 }
 579 
 580 static gboolean
 581 param_double_validate (GParamSpec *pspec,
<span class="line-modified"> 582                GValue     *value)</span>
 583 {
 584   GParamSpecDouble *dspec = G_PARAM_SPEC_DOUBLE (pspec);
 585   gdouble oval = value-&gt;data[0].v_double;
 586 
 587   value-&gt;data[0].v_double = CLAMP (value-&gt;data[0].v_double, dspec-&gt;minimum, dspec-&gt;maximum);
 588 
 589   return value-&gt;data[0].v_double != oval;
 590 }
 591 
 592 static gint
 593 param_double_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 594              const GValue *value1,</span>
<span class="line-modified"> 595              const GValue *value2)</span>
 596 {
 597   gdouble epsilon = G_PARAM_SPEC_DOUBLE (pspec)-&gt;epsilon;
 598 
 599   if (value1-&gt;data[0].v_double &lt; value2-&gt;data[0].v_double)
 600     return - (value2-&gt;data[0].v_double - value1-&gt;data[0].v_double &gt; epsilon);
 601   else
 602     return value1-&gt;data[0].v_double - value2-&gt;data[0].v_double &gt; epsilon;
 603 }
 604 
 605 static void
 606 param_string_init (GParamSpec *pspec)
 607 {
 608   GParamSpecString *sspec = G_PARAM_SPEC_STRING (pspec);
 609 
 610   sspec-&gt;default_value = NULL;
 611   sspec-&gt;cset_first = NULL;
 612   sspec-&gt;cset_nth = NULL;
 613   sspec-&gt;substitutor = &#39;_&#39;;
 614   sspec-&gt;null_fold_if_empty = FALSE;
 615   sspec-&gt;ensure_non_null = FALSE;
 616 }
 617 
 618 static void
 619 param_string_finalize (GParamSpec *pspec)
 620 {
 621   GParamSpecString *sspec = G_PARAM_SPEC_STRING (pspec);
 622   GParamSpecClass *parent_class = g_type_class_peek (g_type_parent (G_TYPE_PARAM_STRING));
 623 
 624   g_free (sspec-&gt;default_value);
 625   g_free (sspec-&gt;cset_first);
 626   g_free (sspec-&gt;cset_nth);
 627   sspec-&gt;default_value = NULL;
 628   sspec-&gt;cset_first = NULL;
 629   sspec-&gt;cset_nth = NULL;
 630 
 631   parent_class-&gt;finalize (pspec);
 632 }
 633 
 634 static void
 635 param_string_set_default (GParamSpec *pspec,
<span class="line-modified"> 636               GValue     *value)</span>
 637 {
 638   value-&gt;data[0].v_pointer = g_strdup (G_PARAM_SPEC_STRING (pspec)-&gt;default_value);
 639 }
 640 
 641 static gboolean
 642 param_string_validate (GParamSpec *pspec,
<span class="line-modified"> 643                GValue     *value)</span>
 644 {
 645   GParamSpecString *sspec = G_PARAM_SPEC_STRING (pspec);
 646   gchar *string = value-&gt;data[0].v_pointer;
 647   guint changed = 0;
 648 
 649   if (string &amp;&amp; string[0])
 650     {
 651       gchar *s;
 652 
 653       if (sspec-&gt;cset_first &amp;&amp; !strchr (sspec-&gt;cset_first, string[0]))
<span class="line-modified"> 654     {</span>
 655           if (value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS)
 656             {
 657               value-&gt;data[0].v_pointer = g_strdup (string);
 658               string = value-&gt;data[0].v_pointer;
 659               value-&gt;data[1].v_uint &amp;= ~G_VALUE_NOCOPY_CONTENTS;
 660             }
<span class="line-modified"> 661       string[0] = sspec-&gt;substitutor;</span>
<span class="line-modified"> 662       changed++;</span>
<span class="line-modified"> 663     }</span>
 664       if (sspec-&gt;cset_nth)
<span class="line-modified"> 665     for (s = string + 1; *s; s++)</span>
<span class="line-modified"> 666       if (!strchr (sspec-&gt;cset_nth, *s))</span>
<span class="line-modified"> 667         {</span>
 668               if (value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS)
 669                 {
 670                   value-&gt;data[0].v_pointer = g_strdup (string);
 671                   s = (gchar*) value-&gt;data[0].v_pointer + (s - string);
 672                   string = value-&gt;data[0].v_pointer;
 673                   value-&gt;data[1].v_uint &amp;= ~G_VALUE_NOCOPY_CONTENTS;
 674                 }
<span class="line-modified"> 675           *s = sspec-&gt;substitutor;</span>
<span class="line-modified"> 676           changed++;</span>
<span class="line-modified"> 677         }</span>
 678     }
 679   if (sspec-&gt;null_fold_if_empty &amp;&amp; string &amp;&amp; string[0] == 0)
 680     {
 681       if (!(value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS))
 682         g_free (value-&gt;data[0].v_pointer);
 683       else
 684         value-&gt;data[1].v_uint &amp;= ~G_VALUE_NOCOPY_CONTENTS;
 685       value-&gt;data[0].v_pointer = NULL;
 686       changed++;
 687       string = value-&gt;data[0].v_pointer;
 688     }
 689   if (sspec-&gt;ensure_non_null &amp;&amp; !string)
 690     {
 691       value-&gt;data[1].v_uint &amp;= ~G_VALUE_NOCOPY_CONTENTS;
 692       value-&gt;data[0].v_pointer = g_strdup (&quot;&quot;);
 693       changed++;
 694       string = value-&gt;data[0].v_pointer;
 695     }
 696 
 697   return changed;
 698 }
 699 
 700 static gint
 701 param_string_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 702              const GValue *value1,</span>
<span class="line-modified"> 703              const GValue *value2)</span>
 704 {
 705   if (!value1-&gt;data[0].v_pointer)
 706     return value2-&gt;data[0].v_pointer != NULL ? -1 : 0;
 707   else if (!value2-&gt;data[0].v_pointer)
 708     return value1-&gt;data[0].v_pointer != NULL;
 709   else
 710     return strcmp (value1-&gt;data[0].v_pointer, value2-&gt;data[0].v_pointer);
 711 }
 712 
 713 static void
 714 param_param_init (GParamSpec *pspec)
 715 {
 716   /* GParamSpecParam *spec = G_PARAM_SPEC_PARAM (pspec); */
 717 }
 718 
 719 static void
 720 param_param_set_default (GParamSpec *pspec,
<span class="line-modified"> 721              GValue     *value)</span>
 722 {
 723   value-&gt;data[0].v_pointer = NULL;
 724 }
 725 
 726 static gboolean
 727 param_param_validate (GParamSpec *pspec,
<span class="line-modified"> 728               GValue     *value)</span>
 729 {
 730   /* GParamSpecParam *spec = G_PARAM_SPEC_PARAM (pspec); */
 731   GParamSpec *param = value-&gt;data[0].v_pointer;
 732   guint changed = 0;
 733 
 734   if (param &amp;&amp; !g_value_type_compatible (G_PARAM_SPEC_TYPE (param), G_PARAM_SPEC_VALUE_TYPE (pspec)))
 735     {
 736       g_param_spec_unref (param);
 737       value-&gt;data[0].v_pointer = NULL;
 738       changed++;
 739     }
 740 
 741   return changed;
 742 }
 743 
 744 static void
 745 param_boxed_init (GParamSpec *pspec)
 746 {
 747   /* GParamSpecBoxed *bspec = G_PARAM_SPEC_BOXED (pspec); */
 748 }
 749 
 750 static void
 751 param_boxed_set_default (GParamSpec *pspec,
<span class="line-modified"> 752              GValue     *value)</span>
 753 {
 754   value-&gt;data[0].v_pointer = NULL;
 755 }
 756 
 757 static gboolean
 758 param_boxed_validate (GParamSpec *pspec,
<span class="line-modified"> 759               GValue     *value)</span>
 760 {
 761   /* GParamSpecBoxed *bspec = G_PARAM_SPEC_BOXED (pspec); */
 762   guint changed = 0;
 763 
 764   /* can&#39;t do a whole lot here since we haven&#39;t even G_BOXED_TYPE() */
 765 
 766   return changed;
 767 }
 768 
 769 static gint
 770 param_boxed_values_cmp (GParamSpec    *pspec,
<span class="line-modified"> 771              const GValue *value1,</span>
<span class="line-modified"> 772              const GValue *value2)</span>
 773 {
 774   guint8 *p1 = value1-&gt;data[0].v_pointer;
 775   guint8 *p2 = value2-&gt;data[0].v_pointer;
 776 
 777   /* not much to compare here, try to at least provide stable lesser/greater result */
 778 
 779   return p1 &lt; p2 ? -1 : p1 &gt; p2;
 780 }
 781 
 782 static void
 783 param_pointer_init (GParamSpec *pspec)
 784 {
 785   /* GParamSpecPointer *spec = G_PARAM_SPEC_POINTER (pspec); */
 786 }
 787 
 788 static void
 789 param_pointer_set_default (GParamSpec *pspec,
<span class="line-modified"> 790                GValue     *value)</span>
 791 {
 792   value-&gt;data[0].v_pointer = NULL;
 793 }
 794 
 795 static gboolean
 796 param_pointer_validate (GParamSpec *pspec,
<span class="line-modified"> 797             GValue     *value)</span>
 798 {
 799   /* GParamSpecPointer *spec = G_PARAM_SPEC_POINTER (pspec); */
 800   guint changed = 0;
 801 
 802   return changed;
 803 }
 804 
 805 static gint
 806 param_pointer_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 807               const GValue *value1,</span>
<span class="line-modified"> 808               const GValue *value2)</span>
 809 {
 810   guint8 *p1 = value1-&gt;data[0].v_pointer;
 811   guint8 *p2 = value2-&gt;data[0].v_pointer;
 812 
 813   /* not much to compare here, try to at least provide stable lesser/greater result */
 814 
 815   return p1 &lt; p2 ? -1 : p1 &gt; p2;
 816 }
 817 
 818 static void
 819 param_value_array_init (GParamSpec *pspec)
 820 {
 821   GParamSpecValueArray *aspec = G_PARAM_SPEC_VALUE_ARRAY (pspec);
 822 
 823   aspec-&gt;element_spec = NULL;
 824   aspec-&gt;fixed_n_elements = 0; /* disable */
 825 }
 826 
 827 static inline guint
 828 value_array_ensure_size (GValueArray *value_array,
<span class="line-modified"> 829              guint        fixed_n_elements)</span>
 830 {
 831   guint changed = 0;
 832 
 833   if (fixed_n_elements)
 834     {
 835       while (value_array-&gt;n_values &lt; fixed_n_elements)
<span class="line-modified"> 836     {</span>
<span class="line-modified"> 837       g_value_array_append (value_array, NULL);</span>
<span class="line-modified"> 838       changed++;</span>
<span class="line-modified"> 839     }</span>
 840       while (value_array-&gt;n_values &gt; fixed_n_elements)
<span class="line-modified"> 841     {</span>
<span class="line-modified"> 842       g_value_array_remove (value_array, value_array-&gt;n_values - 1);</span>
<span class="line-modified"> 843       changed++;</span>
<span class="line-modified"> 844     }</span>
 845     }
 846   return changed;
 847 }
 848 
 849 static void
 850 param_value_array_finalize (GParamSpec *pspec)
 851 {
 852   GParamSpecValueArray *aspec = G_PARAM_SPEC_VALUE_ARRAY (pspec);
 853   GParamSpecClass *parent_class = g_type_class_peek (g_type_parent (G_TYPE_PARAM_VALUE_ARRAY));
 854 
 855   if (aspec-&gt;element_spec)
 856     {
 857       g_param_spec_unref (aspec-&gt;element_spec);
 858       aspec-&gt;element_spec = NULL;
 859     }
 860 
 861   parent_class-&gt;finalize (pspec);
 862 }
 863 
 864 static void
 865 param_value_array_set_default (GParamSpec *pspec,
<span class="line-modified"> 866                    GValue     *value)</span>
 867 {
 868   GParamSpecValueArray *aspec = G_PARAM_SPEC_VALUE_ARRAY (pspec);
 869 
 870   if (!value-&gt;data[0].v_pointer &amp;&amp; aspec-&gt;fixed_n_elements)
 871     value-&gt;data[0].v_pointer = g_value_array_new (aspec-&gt;fixed_n_elements);
 872 
 873   if (value-&gt;data[0].v_pointer)
 874     {
 875       /* g_value_reset (value);  already done */
 876       value_array_ensure_size (value-&gt;data[0].v_pointer, aspec-&gt;fixed_n_elements);
 877     }
 878 }
 879 
 880 static gboolean
 881 param_value_array_validate (GParamSpec *pspec,
<span class="line-modified"> 882                 GValue     *value)</span>
 883 {
 884   GParamSpecValueArray *aspec = G_PARAM_SPEC_VALUE_ARRAY (pspec);
 885   GValueArray *value_array = value-&gt;data[0].v_pointer;
 886   guint changed = 0;
 887 
 888   if (!value-&gt;data[0].v_pointer &amp;&amp; aspec-&gt;fixed_n_elements)
 889     value-&gt;data[0].v_pointer = g_value_array_new (aspec-&gt;fixed_n_elements);
 890 
 891   if (value-&gt;data[0].v_pointer)
 892     {
 893       /* ensure array size validity */
 894       changed += value_array_ensure_size (value_array, aspec-&gt;fixed_n_elements);
 895 
 896       /* ensure array values validity against a present element spec */
 897       if (aspec-&gt;element_spec)
<span class="line-modified"> 898     {</span>
<span class="line-modified"> 899       GParamSpec *element_spec = aspec-&gt;element_spec;</span>
<span class="line-modified"> 900       guint i;</span>
 901 
<span class="line-modified"> 902       for (i = 0; i &lt; value_array-&gt;n_values; i++)</span>
<span class="line-modified"> 903         {</span>
<span class="line-modified"> 904           GValue *element = value_array-&gt;values + i;</span>
<span class="line-modified"> 905 </span>
<span class="line-modified"> 906           /* need to fixup value type, or ensure that the array value is initialized at all */</span>
<span class="line-modified"> 907           if (!g_value_type_compatible (G_VALUE_TYPE (element), G_PARAM_SPEC_VALUE_TYPE (element_spec)))</span>
<span class="line-modified"> 908         {</span>
<span class="line-modified"> 909           if (G_VALUE_TYPE (element) != 0)</span>
<span class="line-modified"> 910             g_value_unset (element);</span>
<span class="line-modified"> 911           g_value_init (element, G_PARAM_SPEC_VALUE_TYPE (element_spec));</span>
<span class="line-modified"> 912           g_param_value_set_default (element_spec, element);</span>
<span class="line-modified"> 913           changed++;</span>
<span class="line-removed"> 914         }</span>
<span class="line-removed"> 915           /* validate array value against element_spec */</span>
<span class="line-removed"> 916           changed += g_param_value_validate (element_spec, element);</span>
<span class="line-removed"> 917         }</span>
 918     }




 919     }
 920 
 921   return changed;
 922 }
 923 
 924 static gint
 925 param_value_array_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 926                   const GValue *value1,</span>
<span class="line-modified"> 927                   const GValue *value2)</span>
 928 {
 929   GParamSpecValueArray *aspec = G_PARAM_SPEC_VALUE_ARRAY (pspec);
 930   GValueArray *value_array1 = value1-&gt;data[0].v_pointer;
 931   GValueArray *value_array2 = value2-&gt;data[0].v_pointer;
 932 
 933   if (!value_array1 || !value_array2)
 934     return value_array2 ? -1 : value_array1 != value_array2;
 935 
 936   if (value_array1-&gt;n_values != value_array2-&gt;n_values)
 937     return value_array1-&gt;n_values &lt; value_array2-&gt;n_values ? -1 : 1;
 938   else if (!aspec-&gt;element_spec)
 939     {
 940       /* we need an element specification for comparisons, so there&#39;s not much
 941        * to compare here, try to at least provide stable lesser/greater result
 942        */
 943       return value_array1-&gt;n_values &lt; value_array2-&gt;n_values ? -1 : value_array1-&gt;n_values &gt; value_array2-&gt;n_values;
 944     }
 945   else /* value_array1-&gt;n_values == value_array2-&gt;n_values */
 946     {
 947       guint i;
 948 
 949       for (i = 0; i &lt; value_array1-&gt;n_values; i++)
<span class="line-modified"> 950     {</span>
<span class="line-modified"> 951       GValue *element1 = value_array1-&gt;values + i;</span>
<span class="line-modified"> 952       GValue *element2 = value_array2-&gt;values + i;</span>
<span class="line-modified"> 953       gint cmp;</span>
<span class="line-modified"> 954 </span>
<span class="line-modified"> 955       /* need corresponding element types, provide stable result otherwise */</span>
<span class="line-modified"> 956       if (G_VALUE_TYPE (element1) != G_VALUE_TYPE (element2))</span>
<span class="line-modified"> 957         return G_VALUE_TYPE (element1) &lt; G_VALUE_TYPE (element2) ? -1 : 1;</span>
<span class="line-modified"> 958       cmp = g_param_values_cmp (aspec-&gt;element_spec, element1, element2);</span>
<span class="line-modified"> 959       if (cmp)</span>
<span class="line-modified"> 960         return cmp;</span>
<span class="line-modified"> 961     }</span>
 962       return 0;
 963     }
 964 }
 965 
 966 static void
 967 param_object_init (GParamSpec *pspec)
 968 {
 969   /* GParamSpecObject *ospec = G_PARAM_SPEC_OBJECT (pspec); */
 970 }
 971 
 972 static void
 973 param_object_set_default (GParamSpec *pspec,
<span class="line-modified"> 974               GValue     *value)</span>
 975 {
 976   value-&gt;data[0].v_pointer = NULL;
 977 }
 978 
 979 static gboolean
 980 param_object_validate (GParamSpec *pspec,
<span class="line-modified"> 981                GValue     *value)</span>
 982 {
 983   GParamSpecObject *ospec = G_PARAM_SPEC_OBJECT (pspec);
 984   GObject *object = value-&gt;data[0].v_pointer;
 985   guint changed = 0;
 986 
 987   if (object &amp;&amp; !g_value_type_compatible (G_OBJECT_TYPE (object), G_PARAM_SPEC_VALUE_TYPE (ospec)))
 988     {
 989       g_object_unref (object);
 990       value-&gt;data[0].v_pointer = NULL;
 991       changed++;
 992     }
 993 
 994   return changed;
 995 }
 996 
 997 static gint
 998 param_object_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 999              const GValue *value1,</span>
<span class="line-modified">1000              const GValue *value2)</span>
1001 {
1002   guint8 *p1 = value1-&gt;data[0].v_pointer;
1003   guint8 *p2 = value2-&gt;data[0].v_pointer;
1004 
1005   /* not much to compare here, try to at least provide stable lesser/greater result */
1006 
1007   return p1 &lt; p2 ? -1 : p1 &gt; p2;
1008 }
1009 
1010 static void
1011 param_override_init (GParamSpec *pspec)
1012 {
1013   /* GParamSpecOverride *ospec = G_PARAM_SPEC_OVERRIDE (pspec); */
1014 }
1015 
1016 static void
1017 param_override_finalize (GParamSpec *pspec)
1018 {
1019   GParamSpecOverride *ospec = G_PARAM_SPEC_OVERRIDE (pspec);
1020   GParamSpecClass *parent_class = g_type_class_peek (g_type_parent (G_TYPE_PARAM_OVERRIDE));
1021 
1022   if (ospec-&gt;overridden)
1023     {
1024       g_param_spec_unref (ospec-&gt;overridden);
1025       ospec-&gt;overridden = NULL;
1026     }
1027 
1028   parent_class-&gt;finalize (pspec);
1029 }
1030 
1031 static void
1032 param_override_set_default (GParamSpec *pspec,
<span class="line-modified">1033                 GValue     *value)</span>
1034 {
1035   GParamSpecOverride *ospec = G_PARAM_SPEC_OVERRIDE (pspec);
1036 
1037   g_param_value_set_default (ospec-&gt;overridden, value);
1038 }
1039 
1040 static gboolean
1041 param_override_validate (GParamSpec *pspec,
<span class="line-modified">1042              GValue     *value)</span>
1043 {
1044   GParamSpecOverride *ospec = G_PARAM_SPEC_OVERRIDE (pspec);
1045 
1046   return g_param_value_validate (ospec-&gt;overridden, value);
1047 }
1048 
1049 static gint
1050 param_override_values_cmp (GParamSpec   *pspec,
<span class="line-modified">1051                const GValue *value1,</span>
<span class="line-modified">1052                const GValue *value2)</span>
1053 {
1054   GParamSpecOverride *ospec = G_PARAM_SPEC_OVERRIDE (pspec);
1055 
1056   return g_param_values_cmp (ospec-&gt;overridden, value1, value2);
1057 }
1058 
1059 static void
1060 param_gtype_init (GParamSpec *pspec)
1061 {
1062 }
1063 
1064 static void
1065 param_gtype_set_default (GParamSpec *pspec,
<span class="line-modified">1066              GValue     *value)</span>
1067 {
1068   GParamSpecGType *tspec = G_PARAM_SPEC_GTYPE (pspec);
1069 
1070   value-&gt;data[0].v_pointer = GSIZE_TO_POINTER (tspec-&gt;is_a_type);
1071 }
1072 
1073 static gboolean
1074 param_gtype_validate (GParamSpec *pspec,
<span class="line-modified">1075               GValue     *value)</span>
1076 {
1077   GParamSpecGType *tspec = G_PARAM_SPEC_GTYPE (pspec);
1078   GType gtype = GPOINTER_TO_SIZE (value-&gt;data[0].v_pointer);
1079   guint changed = 0;
1080 
1081   if (tspec-&gt;is_a_type != G_TYPE_NONE &amp;&amp; !g_type_is_a (gtype, tspec-&gt;is_a_type))
1082     {
1083       value-&gt;data[0].v_pointer = GSIZE_TO_POINTER (tspec-&gt;is_a_type);
1084       changed++;
1085     }
1086 
1087   return changed;
1088 }
1089 
1090 static gint
1091 param_gtype_values_cmp (GParamSpec   *pspec,
<span class="line-modified">1092             const GValue *value1,</span>
<span class="line-modified">1093             const GValue *value2)</span>
1094 {
1095   GType p1 = GPOINTER_TO_SIZE (value1-&gt;data[0].v_pointer);
1096   GType p2 = GPOINTER_TO_SIZE (value2-&gt;data[0].v_pointer);
1097 
1098   /* not much to compare here, try to at least provide stable lesser/greater result */
1099 
1100   return p1 &lt; p2 ? -1 : p1 &gt; p2;
1101 }
1102 
1103 static void
1104 param_variant_init (GParamSpec *pspec)
1105 {
1106   GParamSpecVariant *vspec = G_PARAM_SPEC_VARIANT (pspec);
1107 
1108   vspec-&gt;type = NULL;
1109   vspec-&gt;default_value = NULL;
1110 }
1111 
1112 static void
1113 param_variant_finalize (GParamSpec *pspec)
</pre>
<hr />
<pre>
1174   else if (v1 == NULL &amp;&amp; v2 != NULL)
1175     return -1;
1176   else if (v1 != NULL &amp;&amp; v2 == NULL)
1177     return 1;
1178 
1179   if (!g_variant_type_equal (g_variant_get_type (v1), g_variant_get_type (v2)) ||
1180       variant_is_incomparable (v1) ||
1181       variant_is_incomparable (v2))
1182     return g_variant_equal (v1, v2) ? 0 : (v1 &lt; v2 ? -1 : 1);
1183 
1184   return g_variant_compare (v1, v2);
1185 }
1186 
1187 /* --- type initialization --- */
1188 GType *g_param_spec_types = NULL;
1189 
1190 void
1191 _g_param_spec_types_init (void)
1192 {
1193   const guint n_types = 23;
<span class="line-modified">1194   GType type, *spec_types, *spec_types_bound;</span>



1195 
1196   g_param_spec_types = g_new0 (GType, n_types);
1197   spec_types = g_param_spec_types;

1198   spec_types_bound = g_param_spec_types + n_types;

1199 
1200   /* G_TYPE_PARAM_CHAR
1201    */
1202   {
1203     const GParamSpecTypeInfo pspec_info = {
1204       sizeof (GParamSpecChar),  /* instance_size */
<span class="line-modified">1205       16,           /* n_preallocs */</span>
<span class="line-modified">1206       param_char_init,      /* instance_init */</span>
<span class="line-modified">1207       G_TYPE_CHAR,      /* value_type */</span>
<span class="line-modified">1208       NULL,         /* finalize */</span>
<span class="line-modified">1209       param_char_set_default,   /* value_set_default */</span>
1210       param_char_validate,  /* value_validate */
1211       param_int_values_cmp, /* values_cmp */
1212     };
1213     type = g_param_type_register_static (g_intern_static_string (&quot;GParamChar&quot;), &amp;pspec_info);
1214     *spec_types++ = type;
1215     g_assert (type == G_TYPE_PARAM_CHAR);
1216   }
1217 
1218   /* G_TYPE_PARAM_UCHAR
1219    */
1220   {
1221     const GParamSpecTypeInfo pspec_info = {
1222       sizeof (GParamSpecUChar), /* instance_size */
1223       16,                       /* n_preallocs */
1224       param_uchar_init,         /* instance_init */
<span class="line-modified">1225       G_TYPE_UCHAR,     /* value_type */</span>
<span class="line-modified">1226       NULL,         /* finalize */</span>
1227       param_uchar_set_default,  /* value_set_default */
1228       param_uchar_validate, /* value_validate */
<span class="line-modified">1229       param_uint_values_cmp,    /* values_cmp */</span>
1230     };
1231     type = g_param_type_register_static (g_intern_static_string (&quot;GParamUChar&quot;), &amp;pspec_info);
1232     *spec_types++ = type;
1233     g_assert (type == G_TYPE_PARAM_UCHAR);
1234   }
1235 
1236   /* G_TYPE_PARAM_BOOLEAN
1237    */
1238   {
1239     const GParamSpecTypeInfo pspec_info = {
1240       sizeof (GParamSpecBoolean), /* instance_size */
1241       16,                         /* n_preallocs */
<span class="line-modified">1242       NULL,           /* instance_init */</span>
1243       G_TYPE_BOOLEAN,             /* value_type */
1244       NULL,                       /* finalize */
1245       param_boolean_set_default,  /* value_set_default */
1246       param_boolean_validate,     /* value_validate */
1247       param_int_values_cmp,       /* values_cmp */
1248     };
1249     type = g_param_type_register_static (g_intern_static_string (&quot;GParamBoolean&quot;), &amp;pspec_info);
1250     *spec_types++ = type;
1251     g_assert (type == G_TYPE_PARAM_BOOLEAN);
1252   }
1253 
1254   /* G_TYPE_PARAM_INT
1255    */
1256   {
1257     const GParamSpecTypeInfo pspec_info = {
1258       sizeof (GParamSpecInt),   /* instance_size */
1259       16,                       /* n_preallocs */
1260       param_int_init,           /* instance_init */
<span class="line-modified">1261       G_TYPE_INT,       /* value_type */</span>
<span class="line-modified">1262       NULL,         /* finalize */</span>
<span class="line-modified">1263       param_int_set_default,    /* value_set_default */</span>
<span class="line-modified">1264       param_int_validate,   /* value_validate */</span>
1265       param_int_values_cmp, /* values_cmp */
1266     };
1267     type = g_param_type_register_static (g_intern_static_string (&quot;GParamInt&quot;), &amp;pspec_info);
1268     *spec_types++ = type;
1269     g_assert (type == G_TYPE_PARAM_INT);
1270   }
1271 
1272   /* G_TYPE_PARAM_UINT
1273    */
1274   {
1275     const GParamSpecTypeInfo pspec_info = {
1276       sizeof (GParamSpecUInt),  /* instance_size */
1277       16,                       /* n_preallocs */
1278       param_uint_init,          /* instance_init */
<span class="line-modified">1279       G_TYPE_UINT,      /* value_type */</span>
<span class="line-modified">1280       NULL,         /* finalize */</span>
<span class="line-modified">1281       param_uint_set_default,   /* value_set_default */</span>
1282       param_uint_validate,  /* value_validate */
<span class="line-modified">1283       param_uint_values_cmp,    /* values_cmp */</span>
1284     };
1285     type = g_param_type_register_static (g_intern_static_string (&quot;GParamUInt&quot;), &amp;pspec_info);
1286     *spec_types++ = type;
1287     g_assert (type == G_TYPE_PARAM_UINT);
1288   }
1289 
1290   /* G_TYPE_PARAM_LONG
1291    */
1292   {
1293     const GParamSpecTypeInfo pspec_info = {
1294       sizeof (GParamSpecLong),  /* instance_size */
1295       16,                       /* n_preallocs */
1296       param_long_init,          /* instance_init */
<span class="line-modified">1297       G_TYPE_LONG,      /* value_type */</span>
<span class="line-modified">1298       NULL,         /* finalize */</span>
<span class="line-modified">1299       param_long_set_default,   /* value_set_default */</span>
1300       param_long_validate,  /* value_validate */
<span class="line-modified">1301       param_long_values_cmp,    /* values_cmp */</span>
1302     };
1303     type = g_param_type_register_static (g_intern_static_string (&quot;GParamLong&quot;), &amp;pspec_info);
1304     *spec_types++ = type;
1305     g_assert (type == G_TYPE_PARAM_LONG);
1306   }
1307 
1308   /* G_TYPE_PARAM_ULONG
1309    */
1310   {
1311     const GParamSpecTypeInfo pspec_info = {
1312       sizeof (GParamSpecULong), /* instance_size */
1313       16,                       /* n_preallocs */
1314       param_ulong_init,         /* instance_init */
<span class="line-modified">1315       G_TYPE_ULONG,     /* value_type */</span>
<span class="line-modified">1316       NULL,         /* finalize */</span>
1317       param_ulong_set_default,  /* value_set_default */
1318       param_ulong_validate, /* value_validate */
<span class="line-modified">1319       param_ulong_values_cmp,   /* values_cmp */</span>
1320     };
1321     type = g_param_type_register_static (g_intern_static_string (&quot;GParamULong&quot;), &amp;pspec_info);
1322     *spec_types++ = type;
1323     g_assert (type == G_TYPE_PARAM_ULONG);
1324   }
1325 
1326   /* G_TYPE_PARAM_INT64
1327    */
1328   {
1329     const GParamSpecTypeInfo pspec_info = {
1330       sizeof (GParamSpecInt64),  /* instance_size */
1331       16,                       /* n_preallocs */
1332       param_int64_init,         /* instance_init */
<span class="line-modified">1333       G_TYPE_INT64,     /* value_type */</span>
<span class="line-modified">1334       NULL,         /* finalize */</span>
1335       param_int64_set_default,  /* value_set_default */
1336       param_int64_validate, /* value_validate */
<span class="line-modified">1337       param_int64_values_cmp,   /* values_cmp */</span>
1338     };
1339     type = g_param_type_register_static (g_intern_static_string (&quot;GParamInt64&quot;), &amp;pspec_info);
1340     *spec_types++ = type;
1341     g_assert (type == G_TYPE_PARAM_INT64);
1342   }
1343 
1344   /* G_TYPE_PARAM_UINT64
1345    */
1346   {
1347     const GParamSpecTypeInfo pspec_info = {
1348       sizeof (GParamSpecUInt64), /* instance_size */
1349       16,                       /* n_preallocs */
1350       param_uint64_init,        /* instance_init */
<span class="line-modified">1351       G_TYPE_UINT64,        /* value_type */</span>
<span class="line-modified">1352       NULL,         /* finalize */</span>
1353       param_uint64_set_default, /* value_set_default */
<span class="line-modified">1354       param_uint64_validate,    /* value_validate */</span>
1355       param_uint64_values_cmp,  /* values_cmp */
1356     };
1357     type = g_param_type_register_static (g_intern_static_string (&quot;GParamUInt64&quot;), &amp;pspec_info);
1358     *spec_types++ = type;
1359     g_assert (type == G_TYPE_PARAM_UINT64);
1360   }
1361 
1362   /* G_TYPE_PARAM_UNICHAR
1363    */
1364   {
1365     const GParamSpecTypeInfo pspec_info = {
1366       sizeof (GParamSpecUnichar), /* instance_size */
1367       16,                        /* n_preallocs */
<span class="line-modified">1368       param_unichar_init,    /* instance_init */</span>
<span class="line-modified">1369       G_TYPE_UINT,       /* value_type */</span>
<span class="line-modified">1370       NULL,          /* finalize */</span>
1371       param_unichar_set_default, /* value_set_default */
<span class="line-modified">1372       param_unichar_validate,    /* value_validate */</span>
1373       param_unichar_values_cmp,  /* values_cmp */
1374     };
1375     type = g_param_type_register_static (g_intern_static_string (&quot;GParamUnichar&quot;), &amp;pspec_info);
1376     *spec_types++ = type;
1377     g_assert (type == G_TYPE_PARAM_UNICHAR);
1378   }
1379 
1380  /* G_TYPE_PARAM_ENUM
1381    */
1382   {
1383     const GParamSpecTypeInfo pspec_info = {
1384       sizeof (GParamSpecEnum),  /* instance_size */
1385       16,                       /* n_preallocs */
1386       param_enum_init,          /* instance_init */
<span class="line-modified">1387       G_TYPE_ENUM,      /* value_type */</span>
1388       param_enum_finalize,  /* finalize */
<span class="line-modified">1389       param_enum_set_default,   /* value_set_default */</span>
1390       param_enum_validate,  /* value_validate */
<span class="line-modified">1391       param_long_values_cmp,    /* values_cmp */</span>
1392     };
1393     type = g_param_type_register_static (g_intern_static_string (&quot;GParamEnum&quot;), &amp;pspec_info);
1394     *spec_types++ = type;
1395     g_assert (type == G_TYPE_PARAM_ENUM);
1396   }
1397 
1398   /* G_TYPE_PARAM_FLAGS
1399    */
1400   {
1401     const GParamSpecTypeInfo pspec_info = {
1402       sizeof (GParamSpecFlags), /* instance_size */
<span class="line-modified">1403       16,           /* n_preallocs */</span>
<span class="line-modified">1404       param_flags_init,     /* instance_init */</span>
<span class="line-modified">1405       G_TYPE_FLAGS,     /* value_type */</span>
1406       param_flags_finalize, /* finalize */
1407       param_flags_set_default,  /* value_set_default */
1408       param_flags_validate, /* value_validate */
<span class="line-modified">1409       param_ulong_values_cmp,   /* values_cmp */</span>
1410     };
1411     type = g_param_type_register_static (g_intern_static_string (&quot;GParamFlags&quot;), &amp;pspec_info);
1412     *spec_types++ = type;
1413     g_assert (type == G_TYPE_PARAM_FLAGS);
1414   }
1415 
1416   /* G_TYPE_PARAM_FLOAT
1417    */
1418   {
1419     const GParamSpecTypeInfo pspec_info = {
1420       sizeof (GParamSpecFloat), /* instance_size */
1421       16,                       /* n_preallocs */
1422       param_float_init,         /* instance_init */
<span class="line-modified">1423       G_TYPE_FLOAT,     /* value_type */</span>
<span class="line-modified">1424       NULL,         /* finalize */</span>
1425       param_float_set_default,  /* value_set_default */
1426       param_float_validate, /* value_validate */
<span class="line-modified">1427       param_float_values_cmp,   /* values_cmp */</span>
1428     };
1429     type = g_param_type_register_static (g_intern_static_string (&quot;GParamFloat&quot;), &amp;pspec_info);
1430     *spec_types++ = type;
1431     g_assert (type == G_TYPE_PARAM_FLOAT);
1432   }
1433 
1434   /* G_TYPE_PARAM_DOUBLE
1435    */
1436   {
1437     const GParamSpecTypeInfo pspec_info = {
<span class="line-modified">1438       sizeof (GParamSpecDouble),    /* instance_size */</span>
<span class="line-modified">1439       16,               /* n_preallocs */</span>
<span class="line-modified">1440       param_double_init,        /* instance_init */</span>
<span class="line-modified">1441       G_TYPE_DOUBLE,            /* value_type */</span>
<span class="line-modified">1442       NULL,             /* finalize */</span>
<span class="line-modified">1443       param_double_set_default,     /* value_set_default */</span>
<span class="line-modified">1444       param_double_validate,        /* value_validate */</span>
<span class="line-modified">1445       param_double_values_cmp,      /* values_cmp */</span>
1446     };
1447     type = g_param_type_register_static (g_intern_static_string (&quot;GParamDouble&quot;), &amp;pspec_info);
1448     *spec_types++ = type;
1449     g_assert (type == G_TYPE_PARAM_DOUBLE);
1450   }
1451 
1452   /* G_TYPE_PARAM_STRING
1453    */
1454   {
1455     const GParamSpecTypeInfo pspec_info = {
<span class="line-modified">1456       sizeof (GParamSpecString),    /* instance_size */</span>
<span class="line-modified">1457       16,               /* n_preallocs */</span>
<span class="line-modified">1458       param_string_init,        /* instance_init */</span>
<span class="line-modified">1459       G_TYPE_STRING,            /* value_type */</span>
<span class="line-modified">1460       param_string_finalize,        /* finalize */</span>
<span class="line-modified">1461       param_string_set_default,     /* value_set_default */</span>
<span class="line-modified">1462       param_string_validate,        /* value_validate */</span>
<span class="line-modified">1463       param_string_values_cmp,      /* values_cmp */</span>
1464     };
1465     type = g_param_type_register_static (g_intern_static_string (&quot;GParamString&quot;), &amp;pspec_info);
1466     *spec_types++ = type;
1467     g_assert (type == G_TYPE_PARAM_STRING);
1468   }
1469 
1470   /* G_TYPE_PARAM_PARAM
1471    */
1472   {
1473     const GParamSpecTypeInfo pspec_info = {
1474       sizeof (GParamSpecParam), /* instance_size */
<span class="line-modified">1475       16,           /* n_preallocs */</span>
<span class="line-modified">1476       param_param_init,     /* instance_init */</span>
<span class="line-modified">1477       G_TYPE_PARAM,     /* value_type */</span>
<span class="line-modified">1478       NULL,         /* finalize */</span>
1479       param_param_set_default,  /* value_set_default */
1480       param_param_validate, /* value_validate */
1481       param_pointer_values_cmp, /* values_cmp */
1482     };
1483     type = g_param_type_register_static (g_intern_static_string (&quot;GParamParam&quot;), &amp;pspec_info);
1484     *spec_types++ = type;
1485     g_assert (type == G_TYPE_PARAM_PARAM);
1486   }
1487 
1488   /* G_TYPE_PARAM_BOXED
1489    */
1490   {
1491     const GParamSpecTypeInfo pspec_info = {
1492       sizeof (GParamSpecBoxed), /* instance_size */
<span class="line-modified">1493       4,            /* n_preallocs */</span>
<span class="line-modified">1494       param_boxed_init,     /* instance_init */</span>
<span class="line-modified">1495       G_TYPE_BOXED,     /* value_type */</span>
<span class="line-modified">1496       NULL,         /* finalize */</span>
1497       param_boxed_set_default,  /* value_set_default */
1498       param_boxed_validate, /* value_validate */
<span class="line-modified">1499       param_boxed_values_cmp,   /* values_cmp */</span>
1500     };
1501     type = g_param_type_register_static (g_intern_static_string (&quot;GParamBoxed&quot;), &amp;pspec_info);
1502     *spec_types++ = type;
1503     g_assert (type == G_TYPE_PARAM_BOXED);
1504   }
1505 
1506   /* G_TYPE_PARAM_POINTER
1507    */
1508   {
1509     const GParamSpecTypeInfo pspec_info = {
1510       sizeof (GParamSpecPointer),  /* instance_size */
1511       0,                           /* n_preallocs */
<span class="line-modified">1512       param_pointer_init,      /* instance_init */</span>
<span class="line-modified">1513       G_TYPE_POINTER,          /* value_type */</span>
<span class="line-modified">1514       NULL,            /* finalize */</span>
1515       param_pointer_set_default,   /* value_set_default */
<span class="line-modified">1516       param_pointer_validate,      /* value_validate */</span>
1517       param_pointer_values_cmp,    /* values_cmp */
1518     };
1519     type = g_param_type_register_static (g_intern_static_string (&quot;GParamPointer&quot;), &amp;pspec_info);
1520     *spec_types++ = type;
1521     g_assert (type == G_TYPE_PARAM_POINTER);
1522   }
1523 
1524   /* G_TYPE_PARAM_VALUE_ARRAY
1525    */
1526   {
1527     /* const */ GParamSpecTypeInfo pspec_info = {
<span class="line-modified">1528       sizeof (GParamSpecValueArray),    /* instance_size */</span>
<span class="line-modified">1529       0,                /* n_preallocs */</span>
<span class="line-modified">1530       param_value_array_init,       /* instance_init */</span>
<span class="line-modified">1531       0xdeadbeef,           /* value_type, assigned further down */</span>
<span class="line-modified">1532       param_value_array_finalize,   /* finalize */</span>
<span class="line-modified">1533       param_value_array_set_default,    /* value_set_default */</span>
<span class="line-modified">1534       param_value_array_validate,   /* value_validate */</span>
1535       param_value_array_values_cmp, /* values_cmp */
1536     };
1537     pspec_info.value_type = G_TYPE_VALUE_ARRAY;
1538     type = g_param_type_register_static (g_intern_static_string (&quot;GParamValueArray&quot;), &amp;pspec_info);
1539     *spec_types++ = type;
1540     g_assert (type == G_TYPE_PARAM_VALUE_ARRAY);
1541   }
1542 
1543   /* G_TYPE_PARAM_OBJECT
1544    */
1545   {
1546     const GParamSpecTypeInfo pspec_info = {
1547       sizeof (GParamSpecObject), /* instance_size */
1548       16,                        /* n_preallocs */
<span class="line-modified">1549       param_object_init,     /* instance_init */</span>
<span class="line-modified">1550       G_TYPE_OBJECT,         /* value_type */</span>
<span class="line-modified">1551       NULL,          /* finalize */</span>
1552       param_object_set_default,  /* value_set_default */
<span class="line-modified">1553       param_object_validate,     /* value_validate */</span>
1554       param_object_values_cmp,   /* values_cmp */
1555     };
1556     type = g_param_type_register_static (g_intern_static_string (&quot;GParamObject&quot;), &amp;pspec_info);
1557     *spec_types++ = type;
1558     g_assert (type == G_TYPE_PARAM_OBJECT);
1559   }
1560 
1561   /* G_TYPE_PARAM_OVERRIDE
1562    */
1563   {
1564     const GParamSpecTypeInfo pspec_info = {
1565       sizeof (GParamSpecOverride), /* instance_size */
1566       16,                        /* n_preallocs */
1567       param_override_init,   /* instance_init */
<span class="line-modified">1568       G_TYPE_NONE,       /* value_type */</span>
1569       param_override_finalize,   /* finalize */
1570       param_override_set_default, /* value_set_default */
1571       param_override_validate,    /* value_validate */
1572       param_override_values_cmp,  /* values_cmp */
1573     };
1574     type = g_param_type_register_static (g_intern_static_string (&quot;GParamOverride&quot;), &amp;pspec_info);
1575     *spec_types++ = type;
1576     g_assert (type == G_TYPE_PARAM_OVERRIDE);
1577   }
1578 
1579   /* G_TYPE_PARAM_GTYPE
1580    */
1581   {
1582     GParamSpecTypeInfo pspec_info = {
1583       sizeof (GParamSpecGType), /* instance_size */
<span class="line-modified">1584       0,            /* n_preallocs */</span>
<span class="line-modified">1585       param_gtype_init,     /* instance_init */</span>
<span class="line-modified">1586       0xdeadbeef,       /* value_type, assigned further down */</span>
<span class="line-modified">1587       NULL,         /* finalize */</span>
1588       param_gtype_set_default,  /* value_set_default */
1589       param_gtype_validate, /* value_validate */
<span class="line-modified">1590       param_gtype_values_cmp,   /* values_cmp */</span>
1591     };
1592     pspec_info.value_type = G_TYPE_GTYPE;
1593     type = g_param_type_register_static (g_intern_static_string (&quot;GParamGType&quot;), &amp;pspec_info);
1594     *spec_types++ = type;
1595     g_assert (type == G_TYPE_PARAM_GTYPE);
1596   }
1597 
1598   /* G_TYPE_PARAM_VARIANT
1599    */
1600   {
1601     const GParamSpecTypeInfo pspec_info = {
1602       sizeof (GParamSpecVariant), /* instance_size */
1603       0,                          /* n_preallocs */
1604       param_variant_init,         /* instance_init */
1605       G_TYPE_VARIANT,             /* value_type */
1606       param_variant_finalize,     /* finalize */
1607       param_variant_set_default,  /* value_set_default */
1608       param_variant_validate,     /* value_validate */
1609       param_variant_values_cmp,   /* values_cmp */
1610     };
</pre>
<hr />
<pre>
1617 }
1618 
1619 /* --- GParamSpec initialization --- */
1620 
1621 /**
1622  * g_param_spec_char:
1623  * @name: canonical name of the property specified
1624  * @nick: nick name for the property specified
1625  * @blurb: description of the property specified
1626  * @minimum: minimum value for the property specified
1627  * @maximum: maximum value for the property specified
1628  * @default_value: default value for the property specified
1629  * @flags: flags for the property specified
1630  *
1631  * Creates a new #GParamSpecChar instance specifying a %G_TYPE_CHAR property.
1632  *
1633  * Returns: (transfer full): a newly created parameter specification
1634  */
1635 GParamSpec*
1636 g_param_spec_char (const gchar *name,
<span class="line-modified">1637                    const gchar *nick,</span>
<span class="line-modified">1638                    const gchar *blurb,</span>
<span class="line-modified">1639            gint8    minimum,</span>
<span class="line-modified">1640            gint8    maximum,</span>
<span class="line-modified">1641            gint8    default_value,</span>
<span class="line-modified">1642            GParamFlags  flags)</span>
1643 {
1644   GParamSpecChar *cspec;
1645 
1646   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
1647 
1648   cspec = g_param_spec_internal (G_TYPE_PARAM_CHAR,
<span class="line-modified">1649                  name,</span>
<span class="line-modified">1650                  nick,</span>
<span class="line-modified">1651                  blurb,</span>
<span class="line-modified">1652                  flags);</span>
1653   if (cspec == NULL)
1654     return NULL;
1655 
1656   cspec-&gt;minimum = minimum;
1657   cspec-&gt;maximum = maximum;
1658   cspec-&gt;default_value = default_value;
1659 
1660   return G_PARAM_SPEC (cspec);
1661 }
1662 
1663 /**
1664  * g_param_spec_uchar:
1665  * @name: canonical name of the property specified
1666  * @nick: nick name for the property specified
1667  * @blurb: description of the property specified
1668  * @minimum: minimum value for the property specified
1669  * @maximum: maximum value for the property specified
1670  * @default_value: default value for the property specified
1671  * @flags: flags for the property specified
1672  *
1673  * Creates a new #GParamSpecUChar instance specifying a %G_TYPE_UCHAR property.
1674  *
1675  * Returns: (transfer full): a newly created parameter specification
1676  */
1677 GParamSpec*
1678 g_param_spec_uchar (const gchar *name,
<span class="line-modified">1679                     const gchar *nick,</span>
<span class="line-modified">1680                     const gchar *blurb,</span>
<span class="line-modified">1681             guint8   minimum,</span>
<span class="line-modified">1682             guint8   maximum,</span>
<span class="line-modified">1683             guint8   default_value,</span>
<span class="line-modified">1684             GParamFlags  flags)</span>
1685 {
1686   GParamSpecUChar *uspec;
1687 
1688   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
1689 
1690   uspec = g_param_spec_internal (G_TYPE_PARAM_UCHAR,
<span class="line-modified">1691                  name,</span>
<span class="line-modified">1692                  nick,</span>
<span class="line-modified">1693                  blurb,</span>
<span class="line-modified">1694                  flags);</span>
1695   if (uspec == NULL)
1696     return NULL;
1697 
1698   uspec-&gt;minimum = minimum;
1699   uspec-&gt;maximum = maximum;
1700   uspec-&gt;default_value = default_value;
1701 
1702   return G_PARAM_SPEC (uspec);
1703 }
1704 
1705 /**
1706  * g_param_spec_boolean:
1707  * @name: canonical name of the property specified
1708  * @nick: nick name for the property specified
1709  * @blurb: description of the property specified
1710  * @default_value: default value for the property specified
1711  * @flags: flags for the property specified
1712  *
1713  * Creates a new #GParamSpecBoolean instance specifying a %G_TYPE_BOOLEAN
1714  * property. In many cases, it may be more appropriate to use an enum with
1715  * g_param_spec_enum(), both to improve code clarity by using explicitly named
1716  * values, and to allow for more values to be added in future without breaking
1717  * API.
1718  *
1719  * See g_param_spec_internal() for details on property names.
1720  *
1721  * Returns: (transfer full): a newly created parameter specification
1722  */
1723 GParamSpec*
1724 g_param_spec_boolean (const gchar *name,
<span class="line-modified">1725                       const gchar *nick,</span>
<span class="line-modified">1726                       const gchar *blurb,</span>
<span class="line-modified">1727               gboolean     default_value,</span>
<span class="line-modified">1728                       GParamFlags  flags)</span>
1729 {
1730   GParamSpecBoolean *bspec;
1731 
1732   g_return_val_if_fail (default_value == TRUE || default_value == FALSE, NULL);
1733 
1734   bspec = g_param_spec_internal (G_TYPE_PARAM_BOOLEAN,
<span class="line-modified">1735                  name,</span>
<span class="line-modified">1736                  nick,</span>
<span class="line-modified">1737                  blurb,</span>
<span class="line-modified">1738                  flags);</span>
1739   if (bspec == NULL)
1740     return NULL;
1741 
1742   bspec-&gt;default_value = default_value;
1743 
1744   return G_PARAM_SPEC (bspec);
1745 }
1746 
1747 /**
1748  * g_param_spec_int:
1749  * @name: canonical name of the property specified
1750  * @nick: nick name for the property specified
1751  * @blurb: description of the property specified
1752  * @minimum: minimum value for the property specified
1753  * @maximum: maximum value for the property specified
1754  * @default_value: default value for the property specified
1755  * @flags: flags for the property specified
1756  *
1757  * Creates a new #GParamSpecInt instance specifying a %G_TYPE_INT property.
1758  *
1759  * See g_param_spec_internal() for details on property names.
1760  *
1761  * Returns: (transfer full): a newly created parameter specification
1762  */
1763 GParamSpec*
1764 g_param_spec_int (const gchar *name,
<span class="line-modified">1765                   const gchar *nick,</span>
<span class="line-modified">1766                   const gchar *blurb,</span>
<span class="line-modified">1767           gint         minimum,</span>
<span class="line-modified">1768           gint         maximum,</span>
<span class="line-modified">1769           gint         default_value,</span>
<span class="line-modified">1770                   GParamFlags  flags)</span>
1771 {
1772   GParamSpecInt *ispec;
1773 
1774   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
1775 
1776   ispec = g_param_spec_internal (G_TYPE_PARAM_INT,
<span class="line-modified">1777                  name,</span>
<span class="line-modified">1778                  nick,</span>
<span class="line-modified">1779                  blurb,</span>
<span class="line-modified">1780                  flags);</span>
1781   if (ispec == NULL)
1782     return NULL;
1783 
1784   ispec-&gt;minimum = minimum;
1785   ispec-&gt;maximum = maximum;
1786   ispec-&gt;default_value = default_value;
1787 
1788   return G_PARAM_SPEC (ispec);
1789 }
1790 
1791 /**
1792  * g_param_spec_uint:
1793  * @name: canonical name of the property specified
1794  * @nick: nick name for the property specified
1795  * @blurb: description of the property specified
1796  * @minimum: minimum value for the property specified
1797  * @maximum: maximum value for the property specified
1798  * @default_value: default value for the property specified
1799  * @flags: flags for the property specified
1800  *
1801  * Creates a new #GParamSpecUInt instance specifying a %G_TYPE_UINT property.
1802  *
1803  * See g_param_spec_internal() for details on property names.
1804  *
1805  * Returns: (transfer full): a newly created parameter specification
1806  */
1807 GParamSpec*
1808 g_param_spec_uint (const gchar *name,
<span class="line-modified">1809                    const gchar *nick,</span>
<span class="line-modified">1810                    const gchar *blurb,</span>
<span class="line-modified">1811            guint    minimum,</span>
<span class="line-modified">1812            guint    maximum,</span>
<span class="line-modified">1813            guint    default_value,</span>
<span class="line-modified">1814            GParamFlags  flags)</span>
1815 {
1816   GParamSpecUInt *uspec;
1817 
1818   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
1819 
1820   uspec = g_param_spec_internal (G_TYPE_PARAM_UINT,
<span class="line-modified">1821                  name,</span>
<span class="line-modified">1822                  nick,</span>
<span class="line-modified">1823                  blurb,</span>
<span class="line-modified">1824                  flags);</span>
1825   if (uspec == NULL)
1826     return NULL;
1827 
1828   uspec-&gt;minimum = minimum;
1829   uspec-&gt;maximum = maximum;
1830   uspec-&gt;default_value = default_value;
1831 
1832   return G_PARAM_SPEC (uspec);
1833 }
1834 
1835 /**
1836  * g_param_spec_long:
1837  * @name: canonical name of the property specified
1838  * @nick: nick name for the property specified
1839  * @blurb: description of the property specified
1840  * @minimum: minimum value for the property specified
1841  * @maximum: maximum value for the property specified
1842  * @default_value: default value for the property specified
1843  * @flags: flags for the property specified
1844  *
1845  * Creates a new #GParamSpecLong instance specifying a %G_TYPE_LONG property.
1846  *
1847  * See g_param_spec_internal() for details on property names.
1848  *
1849  * Returns: (transfer full): a newly created parameter specification
1850  */
1851 GParamSpec*
1852 g_param_spec_long (const gchar *name,
<span class="line-modified">1853                    const gchar *nick,</span>
<span class="line-modified">1854                    const gchar *blurb,</span>
<span class="line-modified">1855            glong    minimum,</span>
<span class="line-modified">1856            glong    maximum,</span>
<span class="line-modified">1857            glong    default_value,</span>
<span class="line-modified">1858            GParamFlags  flags)</span>
1859 {
1860   GParamSpecLong *lspec;
1861 
1862   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
1863 
1864   lspec = g_param_spec_internal (G_TYPE_PARAM_LONG,
<span class="line-modified">1865                  name,</span>
<span class="line-modified">1866                  nick,</span>
<span class="line-modified">1867                  blurb,</span>
<span class="line-modified">1868                  flags);</span>
1869   if (lspec == NULL)
1870     return NULL;
1871 
1872   lspec-&gt;minimum = minimum;
1873   lspec-&gt;maximum = maximum;
1874   lspec-&gt;default_value = default_value;
1875 
1876   return G_PARAM_SPEC (lspec);
1877 }
1878 
1879 /**
1880  * g_param_spec_ulong:
1881  * @name: canonical name of the property specified
1882  * @nick: nick name for the property specified
1883  * @blurb: description of the property specified
1884  * @minimum: minimum value for the property specified
1885  * @maximum: maximum value for the property specified
1886  * @default_value: default value for the property specified
1887  * @flags: flags for the property specified
1888  *
1889  * Creates a new #GParamSpecULong instance specifying a %G_TYPE_ULONG
1890  * property.
1891  *
1892  * See g_param_spec_internal() for details on property names.
1893  *
1894  * Returns: (transfer full): a newly created parameter specification
1895  */
1896 GParamSpec*
1897 g_param_spec_ulong (const gchar *name,
<span class="line-modified">1898                     const gchar *nick,</span>
<span class="line-modified">1899                     const gchar *blurb,</span>
<span class="line-modified">1900             gulong   minimum,</span>
<span class="line-modified">1901             gulong   maximum,</span>
<span class="line-modified">1902             gulong   default_value,</span>
<span class="line-modified">1903             GParamFlags  flags)</span>
1904 {
1905   GParamSpecULong *uspec;
1906 
1907   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
1908 
1909   uspec = g_param_spec_internal (G_TYPE_PARAM_ULONG,
<span class="line-modified">1910                  name,</span>
<span class="line-modified">1911                  nick,</span>
<span class="line-modified">1912                  blurb,</span>
<span class="line-modified">1913                  flags);</span>
1914   if (uspec == NULL)
1915     return NULL;
1916 
1917   uspec-&gt;minimum = minimum;
1918   uspec-&gt;maximum = maximum;
1919   uspec-&gt;default_value = default_value;
1920 
1921   return G_PARAM_SPEC (uspec);
1922 }
1923 
1924 /**
1925  * g_param_spec_int64:
1926  * @name: canonical name of the property specified
1927  * @nick: nick name for the property specified
1928  * @blurb: description of the property specified
1929  * @minimum: minimum value for the property specified
1930  * @maximum: maximum value for the property specified
1931  * @default_value: default value for the property specified
1932  * @flags: flags for the property specified
1933  *
1934  * Creates a new #GParamSpecInt64 instance specifying a %G_TYPE_INT64 property.
1935  *
1936  * See g_param_spec_internal() for details on property names.
1937  *
1938  * Returns: (transfer full): a newly created parameter specification
1939  */
1940 GParamSpec*
1941 g_param_spec_int64 (const gchar *name,
<span class="line-modified">1942                     const gchar *nick,</span>
<span class="line-modified">1943                     const gchar *blurb,</span>
<span class="line-modified">1944             gint64   minimum,</span>
<span class="line-modified">1945             gint64   maximum,</span>
<span class="line-modified">1946             gint64   default_value,</span>
<span class="line-modified">1947             GParamFlags  flags)</span>
1948 {
1949   GParamSpecInt64 *lspec;
1950 
1951   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
1952 
1953   lspec = g_param_spec_internal (G_TYPE_PARAM_INT64,
<span class="line-modified">1954                  name,</span>
<span class="line-modified">1955                  nick,</span>
<span class="line-modified">1956                  blurb,</span>
<span class="line-modified">1957                  flags);</span>
1958   if (lspec == NULL)
1959     return NULL;
1960 
1961   lspec-&gt;minimum = minimum;
1962   lspec-&gt;maximum = maximum;
1963   lspec-&gt;default_value = default_value;
1964 
1965   return G_PARAM_SPEC (lspec);
1966 }
1967 
1968 /**
1969  * g_param_spec_uint64:
1970  * @name: canonical name of the property specified
1971  * @nick: nick name for the property specified
1972  * @blurb: description of the property specified
1973  * @minimum: minimum value for the property specified
1974  * @maximum: maximum value for the property specified
1975  * @default_value: default value for the property specified
1976  * @flags: flags for the property specified
1977  *
1978  * Creates a new #GParamSpecUInt64 instance specifying a %G_TYPE_UINT64
1979  * property.
1980  *
1981  * See g_param_spec_internal() for details on property names.
1982  *
1983  * Returns: (transfer full): a newly created parameter specification
1984  */
1985 GParamSpec*
1986 g_param_spec_uint64 (const gchar *name,
<span class="line-modified">1987                      const gchar *nick,</span>
<span class="line-modified">1988                      const gchar *blurb,</span>
<span class="line-modified">1989              guint64      minimum,</span>
<span class="line-modified">1990              guint64      maximum,</span>
<span class="line-modified">1991              guint64      default_value,</span>
<span class="line-modified">1992                      GParamFlags  flags)</span>
1993 {
1994   GParamSpecUInt64 *uspec;
1995 
1996   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
1997 
1998   uspec = g_param_spec_internal (G_TYPE_PARAM_UINT64,
<span class="line-modified">1999                  name,</span>
<span class="line-modified">2000                  nick,</span>
<span class="line-modified">2001                  blurb,</span>
<span class="line-modified">2002                  flags);</span>
2003   if (uspec == NULL)
2004     return NULL;
2005 
2006   uspec-&gt;minimum = minimum;
2007   uspec-&gt;maximum = maximum;
2008   uspec-&gt;default_value = default_value;
2009 
2010   return G_PARAM_SPEC (uspec);
2011 }
2012 
2013 /**
2014  * g_param_spec_unichar:
2015  * @name: canonical name of the property specified
2016  * @nick: nick name for the property specified
2017  * @blurb: description of the property specified
2018  * @default_value: default value for the property specified
2019  * @flags: flags for the property specified
2020  *
2021  * Creates a new #GParamSpecUnichar instance specifying a %G_TYPE_UINT
2022  * property. #GValue structures for this property can be accessed with
2023  * g_value_set_uint() and g_value_get_uint().
2024  *
2025  * See g_param_spec_internal() for details on property names.
2026  *
2027  * Returns: (transfer full): a newly created parameter specification
2028  */
2029 GParamSpec*
2030 g_param_spec_unichar (const gchar *name,
<span class="line-modified">2031                       const gchar *nick,</span>
<span class="line-modified">2032                       const gchar *blurb,</span>
<span class="line-modified">2033               gunichar     default_value,</span>
<span class="line-modified">2034                       GParamFlags  flags)</span>
2035 {
2036   GParamSpecUnichar *uspec;
2037 
2038   uspec = g_param_spec_internal (G_TYPE_PARAM_UNICHAR,
<span class="line-modified">2039                  name,</span>
<span class="line-modified">2040                  nick,</span>
<span class="line-modified">2041                  blurb,</span>
<span class="line-modified">2042                  flags);</span>
2043   if (uspec == NULL)
2044     return NULL;
2045 
2046   uspec-&gt;default_value = default_value;
2047 
2048   return G_PARAM_SPEC (uspec);
2049 }
2050 
2051 /**
2052  * g_param_spec_enum:
2053  * @name: canonical name of the property specified
2054  * @nick: nick name for the property specified
2055  * @blurb: description of the property specified
2056  * @enum_type: a #GType derived from %G_TYPE_ENUM
2057  * @default_value: default value for the property specified
2058  * @flags: flags for the property specified
2059  *
2060  * Creates a new #GParamSpecEnum instance specifying a %G_TYPE_ENUM
2061  * property.
2062  *
2063  * See g_param_spec_internal() for details on property names.
2064  *
2065  * Returns: (transfer full): a newly created parameter specification
2066  */
2067 GParamSpec*
2068 g_param_spec_enum (const gchar *name,
<span class="line-modified">2069                    const gchar *nick,</span>
<span class="line-modified">2070                    const gchar *blurb,</span>
<span class="line-modified">2071            GType    enum_type,</span>
<span class="line-modified">2072            gint     default_value,</span>
<span class="line-modified">2073            GParamFlags  flags)</span>
2074 {
2075   GParamSpecEnum *espec;
2076   GEnumClass *enum_class;
2077 
2078   g_return_val_if_fail (G_TYPE_IS_ENUM (enum_type), NULL);
2079 
2080   enum_class = g_type_class_ref (enum_type);
2081 
2082   g_return_val_if_fail (g_enum_get_value (enum_class, default_value) != NULL, NULL);
2083 
2084   espec = g_param_spec_internal (G_TYPE_PARAM_ENUM,
<span class="line-modified">2085                  name,</span>
<span class="line-modified">2086                  nick,</span>
<span class="line-modified">2087                  blurb,</span>
<span class="line-modified">2088                  flags);</span>
2089   if (espec == NULL)
2090     return NULL;
2091 
2092   espec-&gt;enum_class = enum_class;
2093   espec-&gt;default_value = default_value;
2094   G_PARAM_SPEC (espec)-&gt;value_type = enum_type;
2095 
2096   return G_PARAM_SPEC (espec);
2097 }
2098 
2099 /**
2100  * g_param_spec_flags:
2101  * @name: canonical name of the property specified
2102  * @nick: nick name for the property specified
2103  * @blurb: description of the property specified
2104  * @flags_type: a #GType derived from %G_TYPE_FLAGS
2105  * @default_value: default value for the property specified
2106  * @flags: flags for the property specified
2107  *
2108  * Creates a new #GParamSpecFlags instance specifying a %G_TYPE_FLAGS
2109  * property.
2110  *
2111  * See g_param_spec_internal() for details on property names.
2112  *
2113  * Returns: (transfer full): a newly created parameter specification
2114  */
2115 GParamSpec*
2116 g_param_spec_flags (const gchar *name,
<span class="line-modified">2117                     const gchar *nick,</span>
<span class="line-modified">2118                     const gchar *blurb,</span>
<span class="line-modified">2119             GType    flags_type,</span>
<span class="line-modified">2120             guint    default_value,</span>
<span class="line-modified">2121             GParamFlags  flags)</span>
2122 {
2123   GParamSpecFlags *fspec;
2124   GFlagsClass *flags_class;
2125 
2126   g_return_val_if_fail (G_TYPE_IS_FLAGS (flags_type), NULL);
2127 
2128   flags_class = g_type_class_ref (flags_type);
2129 #ifdef GSTREAMER_LITE
2130   if (flags_class == NULL)
2131       return NULL;
2132 #endif // GSTREAMER_LITE
2133 
2134   g_return_val_if_fail ((default_value &amp; flags_class-&gt;mask) == default_value, NULL);
2135 
2136   fspec = g_param_spec_internal (G_TYPE_PARAM_FLAGS,
<span class="line-modified">2137                  name,</span>
<span class="line-modified">2138                  nick,</span>
<span class="line-modified">2139                  blurb,</span>
<span class="line-modified">2140                  flags);</span>
2141   if (fspec == NULL)
2142     return NULL;
2143 
2144   fspec-&gt;flags_class = flags_class;
2145   fspec-&gt;default_value = default_value;
2146   G_PARAM_SPEC (fspec)-&gt;value_type = flags_type;
2147 
2148   return G_PARAM_SPEC (fspec);
2149 }
2150 
2151 /**
2152  * g_param_spec_float:
2153  * @name: canonical name of the property specified
2154  * @nick: nick name for the property specified
2155  * @blurb: description of the property specified
2156  * @minimum: minimum value for the property specified
2157  * @maximum: maximum value for the property specified
2158  * @default_value: default value for the property specified
2159  * @flags: flags for the property specified
2160  *
2161  * Creates a new #GParamSpecFloat instance specifying a %G_TYPE_FLOAT property.
2162  *
2163  * See g_param_spec_internal() for details on property names.
2164  *
2165  * Returns: (transfer full): a newly created parameter specification
2166  */
2167 GParamSpec*
2168 g_param_spec_float (const gchar *name,
<span class="line-modified">2169                     const gchar *nick,</span>
<span class="line-modified">2170                     const gchar *blurb,</span>
<span class="line-modified">2171             gfloat   minimum,</span>
<span class="line-modified">2172             gfloat   maximum,</span>
<span class="line-modified">2173             gfloat   default_value,</span>
<span class="line-modified">2174             GParamFlags  flags)</span>
2175 {
2176   GParamSpecFloat *fspec;
2177 
2178   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
2179 
2180   fspec = g_param_spec_internal (G_TYPE_PARAM_FLOAT,
<span class="line-modified">2181                  name,</span>
<span class="line-modified">2182                  nick,</span>
<span class="line-modified">2183                  blurb,</span>
<span class="line-modified">2184                  flags);</span>
2185   if (fspec == NULL)
2186     return NULL;
2187 
2188   fspec-&gt;minimum = minimum;
2189   fspec-&gt;maximum = maximum;
2190   fspec-&gt;default_value = default_value;
2191 
2192   return G_PARAM_SPEC (fspec);
2193 }
2194 
2195 /**
2196  * g_param_spec_double:
2197  * @name: canonical name of the property specified
2198  * @nick: nick name for the property specified
2199  * @blurb: description of the property specified
2200  * @minimum: minimum value for the property specified
2201  * @maximum: maximum value for the property specified
2202  * @default_value: default value for the property specified
2203  * @flags: flags for the property specified
2204  *
2205  * Creates a new #GParamSpecDouble instance specifying a %G_TYPE_DOUBLE
2206  * property.
2207  *
2208  * See g_param_spec_internal() for details on property names.
2209  *
2210  * Returns: (transfer full): a newly created parameter specification
2211  */
2212 GParamSpec*
2213 g_param_spec_double (const gchar *name,
<span class="line-modified">2214                      const gchar *nick,</span>
<span class="line-modified">2215                      const gchar *blurb,</span>
<span class="line-modified">2216              gdouble      minimum,</span>
<span class="line-modified">2217              gdouble      maximum,</span>
<span class="line-modified">2218              gdouble      default_value,</span>
<span class="line-modified">2219                      GParamFlags  flags)</span>
2220 {
2221   GParamSpecDouble *dspec;
2222 
2223   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
2224 
2225   dspec = g_param_spec_internal (G_TYPE_PARAM_DOUBLE,
<span class="line-modified">2226                  name,</span>
<span class="line-modified">2227                  nick,</span>
<span class="line-modified">2228                  blurb,</span>
<span class="line-modified">2229                  flags);</span>
2230   if (dspec == NULL)
2231     return NULL;
2232 
2233   dspec-&gt;minimum = minimum;
2234   dspec-&gt;maximum = maximum;
2235   dspec-&gt;default_value = default_value;
2236 
2237   return G_PARAM_SPEC (dspec);
2238 }
2239 
2240 /**
2241  * g_param_spec_string:
2242  * @name: canonical name of the property specified
2243  * @nick: nick name for the property specified
2244  * @blurb: description of the property specified
2245  * @default_value: (nullable): default value for the property specified
2246  * @flags: flags for the property specified
2247  *
2248  * Creates a new #GParamSpecString instance.
2249  *
2250  * See g_param_spec_internal() for details on property names.
2251  *
2252  * Returns: (transfer full): a newly created parameter specification
2253  */
2254 GParamSpec*
2255 g_param_spec_string (const gchar *name,
<span class="line-modified">2256              const gchar *nick,</span>
<span class="line-modified">2257              const gchar *blurb,</span>
<span class="line-modified">2258              const gchar *default_value,</span>
<span class="line-modified">2259              GParamFlags  flags)</span>
2260 {
2261   GParamSpecString *sspec = g_param_spec_internal (G_TYPE_PARAM_STRING,
<span class="line-modified">2262                            name,</span>
<span class="line-modified">2263                            nick,</span>
<span class="line-modified">2264                            blurb,</span>
<span class="line-modified">2265                            flags);</span>
2266   if (sspec == NULL)
2267     return NULL;
2268 
2269   g_free (sspec-&gt;default_value);
2270   sspec-&gt;default_value = g_strdup (default_value);
2271 
2272   return G_PARAM_SPEC (sspec);
2273 }
2274 
2275 /**
2276  * g_param_spec_param:
2277  * @name: canonical name of the property specified
2278  * @nick: nick name for the property specified
2279  * @blurb: description of the property specified
2280  * @param_type: a #GType derived from %G_TYPE_PARAM
2281  * @flags: flags for the property specified
2282  *
2283  * Creates a new #GParamSpecParam instance specifying a %G_TYPE_PARAM
2284  * property.
2285  *
2286  * See g_param_spec_internal() for details on property names.
2287  *
2288  * Returns: (transfer full): a newly created parameter specification
2289  */
2290 GParamSpec*
2291 g_param_spec_param (const gchar *name,
<span class="line-modified">2292                     const gchar *nick,</span>
<span class="line-modified">2293                     const gchar *blurb,</span>
<span class="line-modified">2294             GType    param_type,</span>
<span class="line-modified">2295                     GParamFlags  flags)</span>
2296 {
2297   GParamSpecParam *pspec;
2298 
2299   g_return_val_if_fail (G_TYPE_IS_PARAM (param_type), NULL);
2300 
2301   pspec = g_param_spec_internal (G_TYPE_PARAM_PARAM,
<span class="line-modified">2302                  name,</span>
<span class="line-modified">2303                  nick,</span>
<span class="line-modified">2304                  blurb,</span>
<span class="line-modified">2305                  flags);</span>
2306   if (pspec == NULL)
2307     return NULL;
2308 
2309   G_PARAM_SPEC (pspec)-&gt;value_type = param_type;
2310 
2311   return G_PARAM_SPEC (pspec);
2312 }
2313 
2314 /**
2315  * g_param_spec_boxed:
2316  * @name: canonical name of the property specified
2317  * @nick: nick name for the property specified
2318  * @blurb: description of the property specified
2319  * @boxed_type: %G_TYPE_BOXED derived type of this property
2320  * @flags: flags for the property specified
2321  *
2322  * Creates a new #GParamSpecBoxed instance specifying a %G_TYPE_BOXED
2323  * derived property.
2324  *
2325  * See g_param_spec_internal() for details on property names.
2326  *
2327  * Returns: (transfer full): a newly created parameter specification
2328  */
2329 GParamSpec*
2330 g_param_spec_boxed (const gchar *name,
<span class="line-modified">2331                     const gchar *nick,</span>
<span class="line-modified">2332                     const gchar *blurb,</span>
<span class="line-modified">2333             GType    boxed_type,</span>
<span class="line-modified">2334                     GParamFlags  flags)</span>
2335 {
2336   GParamSpecBoxed *bspec;
2337 
2338   g_return_val_if_fail (G_TYPE_IS_BOXED (boxed_type), NULL);
2339   g_return_val_if_fail (G_TYPE_IS_VALUE_TYPE (boxed_type), NULL);
2340 
2341   bspec = g_param_spec_internal (G_TYPE_PARAM_BOXED,
<span class="line-modified">2342                  name,</span>
<span class="line-modified">2343                  nick,</span>
<span class="line-modified">2344                  blurb,</span>
<span class="line-modified">2345                  flags);</span>
2346   if (bspec == NULL)
2347     return NULL;
2348 
2349   G_PARAM_SPEC (bspec)-&gt;value_type = boxed_type;
2350 
2351   return G_PARAM_SPEC (bspec);
2352 }
2353 
2354 /**
2355  * g_param_spec_pointer:
2356  * @name: canonical name of the property specified
2357  * @nick: nick name for the property specified
2358  * @blurb: description of the property specified
2359  * @flags: flags for the property specified
2360  *
2361  * Creates a new #GParamSpecPointer instance specifying a pointer property.
2362  * Where possible, it is better to use g_param_spec_object() or
2363  * g_param_spec_boxed() to expose memory management information.
2364  *
2365  * See g_param_spec_internal() for details on property names.
2366  *
2367  * Returns: (transfer full): a newly created parameter specification
2368  */
2369 GParamSpec*
2370 g_param_spec_pointer (const gchar *name,
<span class="line-modified">2371               const gchar *nick,</span>
<span class="line-modified">2372               const gchar *blurb,</span>
<span class="line-modified">2373               GParamFlags  flags)</span>
2374 {
2375   GParamSpecPointer *pspec;
2376 
2377   pspec = g_param_spec_internal (G_TYPE_PARAM_POINTER,
<span class="line-modified">2378                  name,</span>
<span class="line-modified">2379                  nick,</span>
<span class="line-modified">2380                  blurb,</span>
<span class="line-modified">2381                  flags);</span>
2382   if (pspec == NULL)
2383     return NULL;
2384 
2385   return G_PARAM_SPEC (pspec);
2386 }
2387 
2388 /**
2389  * g_param_spec_gtype:
2390  * @name: canonical name of the property specified
2391  * @nick: nick name for the property specified
2392  * @blurb: description of the property specified
2393  * @is_a_type: a #GType whose subtypes are allowed as values
2394  *  of the property (use %G_TYPE_NONE for any type)
2395  * @flags: flags for the property specified
2396  *
2397  * Creates a new #GParamSpecGType instance specifying a
2398  * %G_TYPE_GTYPE property.
2399  *
2400  * See g_param_spec_internal() for details on property names.
2401  *
2402  * Since: 2.10
2403  *
2404  * Returns: (transfer full): a newly created parameter specification
2405  */
2406 GParamSpec*
2407 g_param_spec_gtype (const gchar *name,
<span class="line-modified">2408             const gchar *nick,</span>
<span class="line-modified">2409             const gchar *blurb,</span>
<span class="line-modified">2410             GType        is_a_type,</span>
<span class="line-modified">2411             GParamFlags  flags)</span>
2412 {
2413   GParamSpecGType *tspec;
2414 
2415   tspec = g_param_spec_internal (G_TYPE_PARAM_GTYPE,
<span class="line-modified">2416                  name,</span>
<span class="line-modified">2417                  nick,</span>
<span class="line-modified">2418                  blurb,</span>
<span class="line-modified">2419                  flags);</span>
2420   if (tspec == NULL)
2421     return NULL;
2422 
2423   tspec-&gt;is_a_type = is_a_type;
2424 
2425   return G_PARAM_SPEC (tspec);
2426 }
2427 
2428 /**
2429  * g_param_spec_value_array: (skip)
2430  * @name: canonical name of the property specified
2431  * @nick: nick name for the property specified
2432  * @blurb: description of the property specified
2433  * @element_spec: a #GParamSpec describing the elements contained in
2434  *  arrays of this property, may be %NULL
2435  * @flags: flags for the property specified
2436  *
2437  * Creates a new #GParamSpecValueArray instance specifying a
2438  * %G_TYPE_VALUE_ARRAY property. %G_TYPE_VALUE_ARRAY is a
2439  * %G_TYPE_BOXED type, as such, #GValue structures for this property
2440  * can be accessed with g_value_set_boxed() and g_value_get_boxed().
2441  *
2442  * See g_param_spec_internal() for details on property names.
2443  *
2444  * Returns: a newly created parameter specification
2445  */
2446 GParamSpec*
2447 g_param_spec_value_array (const gchar *name,
<span class="line-modified">2448               const gchar *nick,</span>
<span class="line-modified">2449               const gchar *blurb,</span>
<span class="line-modified">2450               GParamSpec  *element_spec,</span>
<span class="line-modified">2451               GParamFlags  flags)</span>
2452 {
2453   GParamSpecValueArray *aspec;
2454 
2455   if (element_spec)
2456     g_return_val_if_fail (G_IS_PARAM_SPEC (element_spec), NULL);
2457 
2458   aspec = g_param_spec_internal (G_TYPE_PARAM_VALUE_ARRAY,
<span class="line-modified">2459                  name,</span>
<span class="line-modified">2460                  nick,</span>
<span class="line-modified">2461                  blurb,</span>
<span class="line-modified">2462                  flags);</span>
2463   if (aspec == NULL)
2464     return NULL;
2465 
2466   if (element_spec)
2467     {
2468       aspec-&gt;element_spec = g_param_spec_ref (element_spec);
2469       g_param_spec_sink (element_spec);
2470     }
2471 
2472   return G_PARAM_SPEC (aspec);
2473 }
2474 
2475 /**
2476  * g_param_spec_object:
2477  * @name: canonical name of the property specified
2478  * @nick: nick name for the property specified
2479  * @blurb: description of the property specified
2480  * @object_type: %G_TYPE_OBJECT derived type of this property
2481  * @flags: flags for the property specified
2482  *
2483  * Creates a new #GParamSpecBoxed instance specifying a %G_TYPE_OBJECT
2484  * derived property.
2485  *
2486  * See g_param_spec_internal() for details on property names.
2487  *
2488  * Returns: (transfer full): a newly created parameter specification
2489  */
2490 GParamSpec*
2491 g_param_spec_object (const gchar *name,
<span class="line-modified">2492                      const gchar *nick,</span>
<span class="line-modified">2493                      const gchar *blurb,</span>
<span class="line-modified">2494              GType    object_type,</span>
<span class="line-modified">2495                      GParamFlags  flags)</span>
2496 {
2497   GParamSpecObject *ospec;
2498 
2499   g_return_val_if_fail (g_type_is_a (object_type, G_TYPE_OBJECT), NULL);
2500 
2501   ospec = g_param_spec_internal (G_TYPE_PARAM_OBJECT,
<span class="line-modified">2502                  name,</span>
<span class="line-modified">2503                  nick,</span>
<span class="line-modified">2504                  blurb,</span>
<span class="line-modified">2505                  flags);</span>
2506   if (ospec == NULL)
2507     return NULL;
2508 
2509   G_PARAM_SPEC (ospec)-&gt;value_type = object_type;
2510 
2511   return G_PARAM_SPEC (ospec);
2512 }
2513 
2514 /**
2515  * g_param_spec_override: (skip)
2516  * @name: the name of the property.
2517  * @overridden: The property that is being overridden
2518  *
2519  * Creates a new property of type #GParamSpecOverride. This is used
2520  * to direct operations to another paramspec, and will not be directly
2521  * useful unless you are implementing a new base type similar to GObject.
2522  *
2523  * Since: 2.4
2524  *
2525  * Returns: the newly created #GParamSpec
2526  */
2527 GParamSpec*
2528 g_param_spec_override (const gchar *name,
<span class="line-modified">2529                GParamSpec  *overridden)</span>
2530 {
2531   GParamSpec *pspec;
2532 
2533   g_return_val_if_fail (name != NULL, NULL);
2534   g_return_val_if_fail (G_IS_PARAM_SPEC (overridden), NULL);
2535 
2536   /* Dereference further redirections for property that was passed in
2537    */
2538   while (TRUE)
2539     {
2540       GParamSpec *indirect = g_param_spec_get_redirect_target (overridden);
2541       if (indirect)
<span class="line-modified">2542     overridden = indirect;</span>
2543       else
<span class="line-modified">2544     break;</span>
2545     }
2546 
2547   pspec = g_param_spec_internal (G_TYPE_PARAM_OVERRIDE,
<span class="line-modified">2548                  name, NULL, NULL,</span>
<span class="line-modified">2549                  overridden-&gt;flags);</span>
2550   if (pspec == NULL)
2551     return NULL;
2552 
2553   pspec-&gt;value_type = G_PARAM_SPEC_VALUE_TYPE (overridden);
2554   G_PARAM_SPEC_OVERRIDE (pspec)-&gt;overridden = g_param_spec_ref (overridden);
2555 
2556   return pspec;
2557 }
2558 
2559 /**
2560  * g_param_spec_variant:
2561  * @name: canonical name of the property specified
2562  * @nick: nick name for the property specified
2563  * @blurb: description of the property specified
2564  * @type: a #GVariantType
2565  * @default_value: (nullable) (transfer full): a #GVariant of type @type to
2566  *                 use as the default value, or %NULL
2567  * @flags: flags for the property specified
2568  *
2569  * Creates a new #GParamSpecVariant instance specifying a #GVariant
</pre>
</td>
<td>
<hr />
<pre>
  36 /**
  37  * SECTION:param_value_types
  38  * @short_description: Standard Parameter and Value Types
  39  * @see_also: #GParamSpec, #GValue, g_object_class_install_property().
  40  * @title: Parameters and Values
  41  *
  42  * #GValue provides an abstract container structure which can be
  43  * copied, transformed and compared while holding a value of any
  44  * (derived) type, which is registered as a #GType with a
  45  * #GTypeValueTable in its #GTypeInfo structure.  Parameter
  46  * specifications for most value types can be created as #GParamSpec
  47  * derived instances, to implement e.g. #GObject properties which
  48  * operate on #GValue containers.
  49  *
  50  * Parameter names need to start with a letter (a-z or A-Z). Subsequent
  51  * characters can be letters, numbers or a &#39;-&#39;.
  52  * All other characters are replaced by a &#39;-&#39; during construction.
  53  */
  54 
  55 
<span class="line-modified">  56 #define G_FLOAT_EPSILON   (1e-30)</span>
<span class="line-modified">  57 #define G_DOUBLE_EPSILON  (1e-90)</span>
  58 
  59 
  60 /* --- param spec functions --- */
  61 static void
  62 param_char_init (GParamSpec *pspec)
  63 {
  64   GParamSpecChar *cspec = G_PARAM_SPEC_CHAR (pspec);
  65 
  66   cspec-&gt;minimum = 0x7f;
  67   cspec-&gt;maximum = 0x80;
  68   cspec-&gt;default_value = 0;
  69 }
  70 
  71 static void
  72 param_char_set_default (GParamSpec *pspec,
<span class="line-modified">  73       GValue     *value)</span>
  74 {
  75   value-&gt;data[0].v_int = G_PARAM_SPEC_CHAR (pspec)-&gt;default_value;
  76 }
  77 
  78 static gboolean
  79 param_char_validate (GParamSpec *pspec,
<span class="line-modified">  80          GValue     *value)</span>
  81 {
  82   GParamSpecChar *cspec = G_PARAM_SPEC_CHAR (pspec);
  83   gint oval = value-&gt;data[0].v_int;
  84 
  85   value-&gt;data[0].v_int = CLAMP (value-&gt;data[0].v_int, cspec-&gt;minimum, cspec-&gt;maximum);
  86 
  87   return value-&gt;data[0].v_int != oval;
  88 }
  89 
  90 static void
  91 param_uchar_init (GParamSpec *pspec)
  92 {
  93   GParamSpecUChar *uspec = G_PARAM_SPEC_UCHAR (pspec);
  94 
  95   uspec-&gt;minimum = 0;
  96   uspec-&gt;maximum = 0xff;
  97   uspec-&gt;default_value = 0;
  98 }
  99 
 100 static void
 101 param_uchar_set_default (GParamSpec *pspec,
<span class="line-modified"> 102        GValue     *value)</span>
 103 {
 104   value-&gt;data[0].v_uint = G_PARAM_SPEC_UCHAR (pspec)-&gt;default_value;
 105 }
 106 
 107 static gboolean
 108 param_uchar_validate (GParamSpec *pspec,
<span class="line-modified"> 109           GValue     *value)</span>
 110 {
 111   GParamSpecUChar *uspec = G_PARAM_SPEC_UCHAR (pspec);
 112   guint oval = value-&gt;data[0].v_uint;
 113 
 114   value-&gt;data[0].v_uint = CLAMP (value-&gt;data[0].v_uint, uspec-&gt;minimum, uspec-&gt;maximum);
 115 
 116   return value-&gt;data[0].v_uint != oval;
 117 }
 118 
 119 static void
 120 param_boolean_set_default (GParamSpec *pspec,
<span class="line-modified"> 121          GValue     *value)</span>
 122 {
 123   value-&gt;data[0].v_int = G_PARAM_SPEC_BOOLEAN (pspec)-&gt;default_value;
 124 }
 125 
 126 static gboolean
 127 param_boolean_validate (GParamSpec *pspec,
<span class="line-modified"> 128       GValue     *value)</span>
 129 {
 130   gint oval = value-&gt;data[0].v_int;
 131 
 132   value-&gt;data[0].v_int = value-&gt;data[0].v_int != FALSE;
 133 
 134   return value-&gt;data[0].v_int != oval;
 135 }
 136 
 137 static void
 138 param_int_init (GParamSpec *pspec)
 139 {
 140   GParamSpecInt *ispec = G_PARAM_SPEC_INT (pspec);
 141 
 142   ispec-&gt;minimum = 0x7fffffff;
 143   ispec-&gt;maximum = 0x80000000;
 144   ispec-&gt;default_value = 0;
 145 }
 146 
 147 static void
 148 param_int_set_default (GParamSpec *pspec,
<span class="line-modified"> 149            GValue     *value)</span>
 150 {
 151   value-&gt;data[0].v_int = G_PARAM_SPEC_INT (pspec)-&gt;default_value;
 152 }
 153 
 154 static gboolean
 155 param_int_validate (GParamSpec *pspec,
<span class="line-modified"> 156         GValue     *value)</span>
 157 {
 158   GParamSpecInt *ispec = G_PARAM_SPEC_INT (pspec);
 159   gint oval = value-&gt;data[0].v_int;
 160 
 161   value-&gt;data[0].v_int = CLAMP (value-&gt;data[0].v_int, ispec-&gt;minimum, ispec-&gt;maximum);
 162 
 163   return value-&gt;data[0].v_int != oval;
 164 }
 165 
 166 static gint
 167 param_int_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 168           const GValue *value1,</span>
<span class="line-modified"> 169           const GValue *value2)</span>
 170 {
 171   if (value1-&gt;data[0].v_int &lt; value2-&gt;data[0].v_int)
 172     return -1;
 173   else
 174     return value1-&gt;data[0].v_int &gt; value2-&gt;data[0].v_int;
 175 }
 176 
 177 static void
 178 param_uint_init (GParamSpec *pspec)
 179 {
 180   GParamSpecUInt *uspec = G_PARAM_SPEC_UINT (pspec);
 181 
 182   uspec-&gt;minimum = 0;
 183   uspec-&gt;maximum = 0xffffffff;
 184   uspec-&gt;default_value = 0;
 185 }
 186 
 187 static void
 188 param_uint_set_default (GParamSpec *pspec,
<span class="line-modified"> 189       GValue     *value)</span>
 190 {
 191   value-&gt;data[0].v_uint = G_PARAM_SPEC_UINT (pspec)-&gt;default_value;
 192 }
 193 
 194 static gboolean
 195 param_uint_validate (GParamSpec *pspec,
<span class="line-modified"> 196          GValue     *value)</span>
 197 {
 198   GParamSpecUInt *uspec = G_PARAM_SPEC_UINT (pspec);
 199   guint oval = value-&gt;data[0].v_uint;
 200 
 201   value-&gt;data[0].v_uint = CLAMP (value-&gt;data[0].v_uint, uspec-&gt;minimum, uspec-&gt;maximum);
 202 
 203   return value-&gt;data[0].v_uint != oval;
 204 }
 205 
 206 static gint
 207 param_uint_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 208            const GValue *value1,</span>
<span class="line-modified"> 209            const GValue *value2)</span>
 210 {
 211   if (value1-&gt;data[0].v_uint &lt; value2-&gt;data[0].v_uint)
 212     return -1;
 213   else
 214     return value1-&gt;data[0].v_uint &gt; value2-&gt;data[0].v_uint;
 215 }
 216 
 217 static void
 218 param_long_init (GParamSpec *pspec)
 219 {
 220   GParamSpecLong *lspec = G_PARAM_SPEC_LONG (pspec);
 221 
 222 #if SIZEOF_LONG == 4
 223   lspec-&gt;minimum = 0x7fffffff;
 224   lspec-&gt;maximum = 0x80000000;
 225 #else /* SIZEOF_LONG != 4 (8) */
 226   lspec-&gt;minimum = 0x7fffffffffffffff;
 227   lspec-&gt;maximum = 0x8000000000000000;
 228 #endif
 229   lspec-&gt;default_value = 0;
 230 }
 231 
 232 static void
 233 param_long_set_default (GParamSpec *pspec,
<span class="line-modified"> 234       GValue     *value)</span>
 235 {
 236   value-&gt;data[0].v_long = G_PARAM_SPEC_LONG (pspec)-&gt;default_value;
 237 }
 238 
 239 static gboolean
 240 param_long_validate (GParamSpec *pspec,
<span class="line-modified"> 241          GValue     *value)</span>
 242 {
 243   GParamSpecLong *lspec = G_PARAM_SPEC_LONG (pspec);
 244   glong oval = value-&gt;data[0].v_long;
 245 
 246   value-&gt;data[0].v_long = CLAMP (value-&gt;data[0].v_long, lspec-&gt;minimum, lspec-&gt;maximum);
 247 
 248   return value-&gt;data[0].v_long != oval;
 249 }
 250 
 251 static gint
 252 param_long_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 253            const GValue *value1,</span>
<span class="line-modified"> 254            const GValue *value2)</span>
 255 {
 256   if (value1-&gt;data[0].v_long &lt; value2-&gt;data[0].v_long)
 257     return -1;
 258   else
 259     return value1-&gt;data[0].v_long &gt; value2-&gt;data[0].v_long;
 260 }
 261 
 262 static void
 263 param_ulong_init (GParamSpec *pspec)
 264 {
 265   GParamSpecULong *uspec = G_PARAM_SPEC_ULONG (pspec);
 266 
 267   uspec-&gt;minimum = 0;
 268 #if SIZEOF_LONG == 4
 269   uspec-&gt;maximum = 0xffffffff;
 270 #else /* SIZEOF_LONG != 4 (8) */
 271   uspec-&gt;maximum = 0xffffffffffffffff;
 272 #endif
 273   uspec-&gt;default_value = 0;
 274 }
 275 
 276 static void
 277 param_ulong_set_default (GParamSpec *pspec,
<span class="line-modified"> 278        GValue     *value)</span>
 279 {
 280   value-&gt;data[0].v_ulong = G_PARAM_SPEC_ULONG (pspec)-&gt;default_value;
 281 }
 282 
 283 static gboolean
 284 param_ulong_validate (GParamSpec *pspec,
<span class="line-modified"> 285           GValue     *value)</span>
 286 {
 287   GParamSpecULong *uspec = G_PARAM_SPEC_ULONG (pspec);
 288   gulong oval = value-&gt;data[0].v_ulong;
 289 
 290   value-&gt;data[0].v_ulong = CLAMP (value-&gt;data[0].v_ulong, uspec-&gt;minimum, uspec-&gt;maximum);
 291 
 292   return value-&gt;data[0].v_ulong != oval;
 293 }
 294 
 295 static gint
 296 param_ulong_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 297       const GValue *value1,</span>
<span class="line-modified"> 298       const GValue *value2)</span>
 299 {
 300   if (value1-&gt;data[0].v_ulong &lt; value2-&gt;data[0].v_ulong)
 301     return -1;
 302   else
 303     return value1-&gt;data[0].v_ulong &gt; value2-&gt;data[0].v_ulong;
 304 }
 305 
 306 static void
 307 param_int64_init (GParamSpec *pspec)
 308 {
 309   GParamSpecInt64 *lspec = G_PARAM_SPEC_INT64 (pspec);
 310 
 311   lspec-&gt;minimum = G_MININT64;
 312   lspec-&gt;maximum = G_MAXINT64;
 313   lspec-&gt;default_value = 0;
 314 }
 315 
 316 static void
 317 param_int64_set_default (GParamSpec *pspec,
<span class="line-modified"> 318       GValue     *value)</span>
 319 {
 320   value-&gt;data[0].v_int64 = G_PARAM_SPEC_INT64 (pspec)-&gt;default_value;
 321 }
 322 
 323 static gboolean
 324 param_int64_validate (GParamSpec *pspec,
<span class="line-modified"> 325          GValue     *value)</span>
 326 {
 327   GParamSpecInt64 *lspec = G_PARAM_SPEC_INT64 (pspec);
 328   gint64 oval = value-&gt;data[0].v_int64;
 329 
 330   value-&gt;data[0].v_int64 = CLAMP (value-&gt;data[0].v_int64, lspec-&gt;minimum, lspec-&gt;maximum);
 331 
 332   return value-&gt;data[0].v_int64 != oval;
 333 }
 334 
 335 static gint
 336 param_int64_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 337            const GValue *value1,</span>
<span class="line-modified"> 338            const GValue *value2)</span>
 339 {
 340   if (value1-&gt;data[0].v_int64 &lt; value2-&gt;data[0].v_int64)
 341     return -1;
 342   else
 343     return value1-&gt;data[0].v_int64 &gt; value2-&gt;data[0].v_int64;
 344 }
 345 
 346 static void
 347 param_uint64_init (GParamSpec *pspec)
 348 {
 349   GParamSpecUInt64 *uspec = G_PARAM_SPEC_UINT64 (pspec);
 350 
 351   uspec-&gt;minimum = 0;
 352   uspec-&gt;maximum = G_MAXUINT64;
 353   uspec-&gt;default_value = 0;
 354 }
 355 
 356 static void
 357 param_uint64_set_default (GParamSpec *pspec,
<span class="line-modified"> 358        GValue     *value)</span>
 359 {
 360   value-&gt;data[0].v_uint64 = G_PARAM_SPEC_UINT64 (pspec)-&gt;default_value;
 361 }
 362 
 363 static gboolean
 364 param_uint64_validate (GParamSpec *pspec,
<span class="line-modified"> 365           GValue     *value)</span>
 366 {
 367   GParamSpecUInt64 *uspec = G_PARAM_SPEC_UINT64 (pspec);
 368   guint64 oval = value-&gt;data[0].v_uint64;
 369 
 370   value-&gt;data[0].v_uint64 = CLAMP (value-&gt;data[0].v_uint64, uspec-&gt;minimum, uspec-&gt;maximum);
 371 
 372   return value-&gt;data[0].v_uint64 != oval;
 373 }
 374 
 375 static gint
 376 param_uint64_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 377       const GValue *value1,</span>
<span class="line-modified"> 378       const GValue *value2)</span>
 379 {
 380   if (value1-&gt;data[0].v_uint64 &lt; value2-&gt;data[0].v_uint64)
 381     return -1;
 382   else
 383     return value1-&gt;data[0].v_uint64 &gt; value2-&gt;data[0].v_uint64;
 384 }
 385 
 386 static void
 387 param_unichar_init (GParamSpec *pspec)
 388 {
 389   GParamSpecUnichar *uspec = G_PARAM_SPEC_UNICHAR (pspec);
 390 
 391   uspec-&gt;default_value = 0;
 392 }
 393 
 394 static void
 395 param_unichar_set_default (GParamSpec *pspec,
<span class="line-modified"> 396        GValue     *value)</span>
 397 {
 398   value-&gt;data[0].v_uint = G_PARAM_SPEC_UNICHAR (pspec)-&gt;default_value;
 399 }
 400 
 401 static gboolean
 402 param_unichar_validate (GParamSpec *pspec,
<span class="line-modified"> 403             GValue     *value)</span>
 404 {
 405   gunichar oval = value-&gt;data[0].v_uint;
 406   gboolean changed = FALSE;
 407 
 408   if (!g_unichar_validate (oval))
 409     {
 410       value-&gt;data[0].v_uint = 0;
 411       changed = TRUE;
 412     }
 413 
 414   return changed;
 415 }
 416 
 417 static gint
 418 param_unichar_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 419       const GValue *value1,</span>
<span class="line-modified"> 420       const GValue *value2)</span>
 421 {
 422   if (value1-&gt;data[0].v_uint &lt; value2-&gt;data[0].v_uint)
 423     return -1;
 424   else
 425     return value1-&gt;data[0].v_uint &gt; value2-&gt;data[0].v_uint;
 426 }
 427 
 428 static void
 429 param_enum_init (GParamSpec *pspec)
 430 {
 431   GParamSpecEnum *espec = G_PARAM_SPEC_ENUM (pspec);
 432 
 433   espec-&gt;enum_class = NULL;
 434   espec-&gt;default_value = 0;
 435 }
 436 
 437 static void
 438 param_enum_finalize (GParamSpec *pspec)
 439 {
 440   GParamSpecEnum *espec = G_PARAM_SPEC_ENUM (pspec);
 441   GParamSpecClass *parent_class = g_type_class_peek (g_type_parent (G_TYPE_PARAM_ENUM));
 442 
 443   if (espec-&gt;enum_class)
 444     {
 445       g_type_class_unref (espec-&gt;enum_class);
 446       espec-&gt;enum_class = NULL;
 447     }
 448 
 449   parent_class-&gt;finalize (pspec);
 450 }
 451 
 452 static void
 453 param_enum_set_default (GParamSpec *pspec,
<span class="line-modified"> 454       GValue     *value)</span>
 455 {
 456   value-&gt;data[0].v_long = G_PARAM_SPEC_ENUM (pspec)-&gt;default_value;
 457 }
 458 
 459 static gboolean
 460 param_enum_validate (GParamSpec *pspec,
<span class="line-modified"> 461          GValue     *value)</span>
 462 {
 463   GParamSpecEnum *espec = G_PARAM_SPEC_ENUM (pspec);
 464   glong oval = value-&gt;data[0].v_long;
 465 
 466   if (!espec-&gt;enum_class ||
 467       !g_enum_get_value (espec-&gt;enum_class, value-&gt;data[0].v_long))
 468     value-&gt;data[0].v_long = espec-&gt;default_value;
 469 
 470   return value-&gt;data[0].v_long != oval;
 471 }
 472 
 473 static void
 474 param_flags_init (GParamSpec *pspec)
 475 {
 476   GParamSpecFlags *fspec = G_PARAM_SPEC_FLAGS (pspec);
 477 
 478   fspec-&gt;flags_class = NULL;
 479   fspec-&gt;default_value = 0;
 480 }
 481 
 482 static void
 483 param_flags_finalize (GParamSpec *pspec)
 484 {
 485   GParamSpecFlags *fspec = G_PARAM_SPEC_FLAGS (pspec);
 486   GParamSpecClass *parent_class = g_type_class_peek (g_type_parent (G_TYPE_PARAM_FLAGS));
 487 
 488   if (fspec-&gt;flags_class)
 489     {
 490       g_type_class_unref (fspec-&gt;flags_class);
 491       fspec-&gt;flags_class = NULL;
 492     }
 493 
 494   parent_class-&gt;finalize (pspec);
 495 }
 496 
 497 static void
 498 param_flags_set_default (GParamSpec *pspec,
<span class="line-modified"> 499        GValue     *value)</span>
 500 {
 501   value-&gt;data[0].v_ulong = G_PARAM_SPEC_FLAGS (pspec)-&gt;default_value;
 502 }
 503 
 504 static gboolean
 505 param_flags_validate (GParamSpec *pspec,
<span class="line-modified"> 506           GValue     *value)</span>
 507 {
 508   GParamSpecFlags *fspec = G_PARAM_SPEC_FLAGS (pspec);
 509   gulong oval = value-&gt;data[0].v_ulong;
 510 
 511   if (fspec-&gt;flags_class)
 512     value-&gt;data[0].v_ulong &amp;= fspec-&gt;flags_class-&gt;mask;
 513   else
 514     value-&gt;data[0].v_ulong = fspec-&gt;default_value;
 515 
 516   return value-&gt;data[0].v_ulong != oval;
 517 }
 518 
 519 static void
 520 param_float_init (GParamSpec *pspec)
 521 {
 522   GParamSpecFloat *fspec = G_PARAM_SPEC_FLOAT (pspec);
 523 
 524   fspec-&gt;minimum = -G_MAXFLOAT;
 525   fspec-&gt;maximum = G_MAXFLOAT;
 526   fspec-&gt;default_value = 0;
 527   fspec-&gt;epsilon = G_FLOAT_EPSILON;
 528 }
 529 
 530 static void
 531 param_float_set_default (GParamSpec *pspec,
<span class="line-modified"> 532        GValue     *value)</span>
 533 {
 534   value-&gt;data[0].v_float = G_PARAM_SPEC_FLOAT (pspec)-&gt;default_value;
 535 }
 536 
 537 static gboolean
 538 param_float_validate (GParamSpec *pspec,
<span class="line-modified"> 539           GValue     *value)</span>
 540 {
 541   GParamSpecFloat *fspec = G_PARAM_SPEC_FLOAT (pspec);
 542   gfloat oval = value-&gt;data[0].v_float;
 543 
 544   value-&gt;data[0].v_float = CLAMP (value-&gt;data[0].v_float, fspec-&gt;minimum, fspec-&gt;maximum);
 545 
 546   return value-&gt;data[0].v_float != oval;
 547 }
 548 
 549 static gint
 550 param_float_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 551       const GValue *value1,</span>
<span class="line-modified"> 552       const GValue *value2)</span>
 553 {
 554   gfloat epsilon = G_PARAM_SPEC_FLOAT (pspec)-&gt;epsilon;
 555 
 556   if (value1-&gt;data[0].v_float &lt; value2-&gt;data[0].v_float)
 557     return - (value2-&gt;data[0].v_float - value1-&gt;data[0].v_float &gt; epsilon);
 558   else
 559     return value1-&gt;data[0].v_float - value2-&gt;data[0].v_float &gt; epsilon;
 560 }
 561 
 562 static void
 563 param_double_init (GParamSpec *pspec)
 564 {
 565   GParamSpecDouble *dspec = G_PARAM_SPEC_DOUBLE (pspec);
 566 
 567   dspec-&gt;minimum = -G_MAXDOUBLE;
 568   dspec-&gt;maximum = G_MAXDOUBLE;
 569   dspec-&gt;default_value = 0;
 570   dspec-&gt;epsilon = G_DOUBLE_EPSILON;
 571 }
 572 
 573 static void
 574 param_double_set_default (GParamSpec *pspec,
<span class="line-modified"> 575         GValue     *value)</span>
 576 {
 577   value-&gt;data[0].v_double = G_PARAM_SPEC_DOUBLE (pspec)-&gt;default_value;
 578 }
 579 
 580 static gboolean
 581 param_double_validate (GParamSpec *pspec,
<span class="line-modified"> 582            GValue     *value)</span>
 583 {
 584   GParamSpecDouble *dspec = G_PARAM_SPEC_DOUBLE (pspec);
 585   gdouble oval = value-&gt;data[0].v_double;
 586 
 587   value-&gt;data[0].v_double = CLAMP (value-&gt;data[0].v_double, dspec-&gt;minimum, dspec-&gt;maximum);
 588 
 589   return value-&gt;data[0].v_double != oval;
 590 }
 591 
 592 static gint
 593 param_double_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 594        const GValue *value1,</span>
<span class="line-modified"> 595        const GValue *value2)</span>
 596 {
 597   gdouble epsilon = G_PARAM_SPEC_DOUBLE (pspec)-&gt;epsilon;
 598 
 599   if (value1-&gt;data[0].v_double &lt; value2-&gt;data[0].v_double)
 600     return - (value2-&gt;data[0].v_double - value1-&gt;data[0].v_double &gt; epsilon);
 601   else
 602     return value1-&gt;data[0].v_double - value2-&gt;data[0].v_double &gt; epsilon;
 603 }
 604 
 605 static void
 606 param_string_init (GParamSpec *pspec)
 607 {
 608   GParamSpecString *sspec = G_PARAM_SPEC_STRING (pspec);
 609 
 610   sspec-&gt;default_value = NULL;
 611   sspec-&gt;cset_first = NULL;
 612   sspec-&gt;cset_nth = NULL;
 613   sspec-&gt;substitutor = &#39;_&#39;;
 614   sspec-&gt;null_fold_if_empty = FALSE;
 615   sspec-&gt;ensure_non_null = FALSE;
 616 }
 617 
 618 static void
 619 param_string_finalize (GParamSpec *pspec)
 620 {
 621   GParamSpecString *sspec = G_PARAM_SPEC_STRING (pspec);
 622   GParamSpecClass *parent_class = g_type_class_peek (g_type_parent (G_TYPE_PARAM_STRING));
 623 
 624   g_free (sspec-&gt;default_value);
 625   g_free (sspec-&gt;cset_first);
 626   g_free (sspec-&gt;cset_nth);
 627   sspec-&gt;default_value = NULL;
 628   sspec-&gt;cset_first = NULL;
 629   sspec-&gt;cset_nth = NULL;
 630 
 631   parent_class-&gt;finalize (pspec);
 632 }
 633 
 634 static void
 635 param_string_set_default (GParamSpec *pspec,
<span class="line-modified"> 636         GValue     *value)</span>
 637 {
 638   value-&gt;data[0].v_pointer = g_strdup (G_PARAM_SPEC_STRING (pspec)-&gt;default_value);
 639 }
 640 
 641 static gboolean
 642 param_string_validate (GParamSpec *pspec,
<span class="line-modified"> 643            GValue     *value)</span>
 644 {
 645   GParamSpecString *sspec = G_PARAM_SPEC_STRING (pspec);
 646   gchar *string = value-&gt;data[0].v_pointer;
 647   guint changed = 0;
 648 
 649   if (string &amp;&amp; string[0])
 650     {
 651       gchar *s;
 652 
 653       if (sspec-&gt;cset_first &amp;&amp; !strchr (sspec-&gt;cset_first, string[0]))
<span class="line-modified"> 654   {</span>
 655           if (value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS)
 656             {
 657               value-&gt;data[0].v_pointer = g_strdup (string);
 658               string = value-&gt;data[0].v_pointer;
 659               value-&gt;data[1].v_uint &amp;= ~G_VALUE_NOCOPY_CONTENTS;
 660             }
<span class="line-modified"> 661     string[0] = sspec-&gt;substitutor;</span>
<span class="line-modified"> 662     changed++;</span>
<span class="line-modified"> 663   }</span>
 664       if (sspec-&gt;cset_nth)
<span class="line-modified"> 665   for (s = string + 1; *s; s++)</span>
<span class="line-modified"> 666     if (!strchr (sspec-&gt;cset_nth, *s))</span>
<span class="line-modified"> 667       {</span>
 668               if (value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS)
 669                 {
 670                   value-&gt;data[0].v_pointer = g_strdup (string);
 671                   s = (gchar*) value-&gt;data[0].v_pointer + (s - string);
 672                   string = value-&gt;data[0].v_pointer;
 673                   value-&gt;data[1].v_uint &amp;= ~G_VALUE_NOCOPY_CONTENTS;
 674                 }
<span class="line-modified"> 675         *s = sspec-&gt;substitutor;</span>
<span class="line-modified"> 676         changed++;</span>
<span class="line-modified"> 677       }</span>
 678     }
 679   if (sspec-&gt;null_fold_if_empty &amp;&amp; string &amp;&amp; string[0] == 0)
 680     {
 681       if (!(value-&gt;data[1].v_uint &amp; G_VALUE_NOCOPY_CONTENTS))
 682         g_free (value-&gt;data[0].v_pointer);
 683       else
 684         value-&gt;data[1].v_uint &amp;= ~G_VALUE_NOCOPY_CONTENTS;
 685       value-&gt;data[0].v_pointer = NULL;
 686       changed++;
 687       string = value-&gt;data[0].v_pointer;
 688     }
 689   if (sspec-&gt;ensure_non_null &amp;&amp; !string)
 690     {
 691       value-&gt;data[1].v_uint &amp;= ~G_VALUE_NOCOPY_CONTENTS;
 692       value-&gt;data[0].v_pointer = g_strdup (&quot;&quot;);
 693       changed++;
 694       string = value-&gt;data[0].v_pointer;
 695     }
 696 
 697   return changed;
 698 }
 699 
 700 static gint
 701 param_string_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 702        const GValue *value1,</span>
<span class="line-modified"> 703        const GValue *value2)</span>
 704 {
 705   if (!value1-&gt;data[0].v_pointer)
 706     return value2-&gt;data[0].v_pointer != NULL ? -1 : 0;
 707   else if (!value2-&gt;data[0].v_pointer)
 708     return value1-&gt;data[0].v_pointer != NULL;
 709   else
 710     return strcmp (value1-&gt;data[0].v_pointer, value2-&gt;data[0].v_pointer);
 711 }
 712 
 713 static void
 714 param_param_init (GParamSpec *pspec)
 715 {
 716   /* GParamSpecParam *spec = G_PARAM_SPEC_PARAM (pspec); */
 717 }
 718 
 719 static void
 720 param_param_set_default (GParamSpec *pspec,
<span class="line-modified"> 721        GValue     *value)</span>
 722 {
 723   value-&gt;data[0].v_pointer = NULL;
 724 }
 725 
 726 static gboolean
 727 param_param_validate (GParamSpec *pspec,
<span class="line-modified"> 728           GValue     *value)</span>
 729 {
 730   /* GParamSpecParam *spec = G_PARAM_SPEC_PARAM (pspec); */
 731   GParamSpec *param = value-&gt;data[0].v_pointer;
 732   guint changed = 0;
 733 
 734   if (param &amp;&amp; !g_value_type_compatible (G_PARAM_SPEC_TYPE (param), G_PARAM_SPEC_VALUE_TYPE (pspec)))
 735     {
 736       g_param_spec_unref (param);
 737       value-&gt;data[0].v_pointer = NULL;
 738       changed++;
 739     }
 740 
 741   return changed;
 742 }
 743 
 744 static void
 745 param_boxed_init (GParamSpec *pspec)
 746 {
 747   /* GParamSpecBoxed *bspec = G_PARAM_SPEC_BOXED (pspec); */
 748 }
 749 
 750 static void
 751 param_boxed_set_default (GParamSpec *pspec,
<span class="line-modified"> 752        GValue     *value)</span>
 753 {
 754   value-&gt;data[0].v_pointer = NULL;
 755 }
 756 
 757 static gboolean
 758 param_boxed_validate (GParamSpec *pspec,
<span class="line-modified"> 759           GValue     *value)</span>
 760 {
 761   /* GParamSpecBoxed *bspec = G_PARAM_SPEC_BOXED (pspec); */
 762   guint changed = 0;
 763 
 764   /* can&#39;t do a whole lot here since we haven&#39;t even G_BOXED_TYPE() */
 765 
 766   return changed;
 767 }
 768 
 769 static gint
 770 param_boxed_values_cmp (GParamSpec    *pspec,
<span class="line-modified"> 771        const GValue *value1,</span>
<span class="line-modified"> 772        const GValue *value2)</span>
 773 {
 774   guint8 *p1 = value1-&gt;data[0].v_pointer;
 775   guint8 *p2 = value2-&gt;data[0].v_pointer;
 776 
 777   /* not much to compare here, try to at least provide stable lesser/greater result */
 778 
 779   return p1 &lt; p2 ? -1 : p1 &gt; p2;
 780 }
 781 
 782 static void
 783 param_pointer_init (GParamSpec *pspec)
 784 {
 785   /* GParamSpecPointer *spec = G_PARAM_SPEC_POINTER (pspec); */
 786 }
 787 
 788 static void
 789 param_pointer_set_default (GParamSpec *pspec,
<span class="line-modified"> 790          GValue     *value)</span>
 791 {
 792   value-&gt;data[0].v_pointer = NULL;
 793 }
 794 
 795 static gboolean
 796 param_pointer_validate (GParamSpec *pspec,
<span class="line-modified"> 797       GValue     *value)</span>
 798 {
 799   /* GParamSpecPointer *spec = G_PARAM_SPEC_POINTER (pspec); */
 800   guint changed = 0;
 801 
 802   return changed;
 803 }
 804 
 805 static gint
 806 param_pointer_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 807         const GValue *value1,</span>
<span class="line-modified"> 808         const GValue *value2)</span>
 809 {
 810   guint8 *p1 = value1-&gt;data[0].v_pointer;
 811   guint8 *p2 = value2-&gt;data[0].v_pointer;
 812 
 813   /* not much to compare here, try to at least provide stable lesser/greater result */
 814 
 815   return p1 &lt; p2 ? -1 : p1 &gt; p2;
 816 }
 817 
 818 static void
 819 param_value_array_init (GParamSpec *pspec)
 820 {
 821   GParamSpecValueArray *aspec = G_PARAM_SPEC_VALUE_ARRAY (pspec);
 822 
 823   aspec-&gt;element_spec = NULL;
 824   aspec-&gt;fixed_n_elements = 0; /* disable */
 825 }
 826 
 827 static inline guint
 828 value_array_ensure_size (GValueArray *value_array,
<span class="line-modified"> 829        guint        fixed_n_elements)</span>
 830 {
 831   guint changed = 0;
 832 
 833   if (fixed_n_elements)
 834     {
 835       while (value_array-&gt;n_values &lt; fixed_n_elements)
<span class="line-modified"> 836   {</span>
<span class="line-modified"> 837     g_value_array_append (value_array, NULL);</span>
<span class="line-modified"> 838     changed++;</span>
<span class="line-modified"> 839   }</span>
 840       while (value_array-&gt;n_values &gt; fixed_n_elements)
<span class="line-modified"> 841   {</span>
<span class="line-modified"> 842     g_value_array_remove (value_array, value_array-&gt;n_values - 1);</span>
<span class="line-modified"> 843     changed++;</span>
<span class="line-modified"> 844   }</span>
 845     }
 846   return changed;
 847 }
 848 
 849 static void
 850 param_value_array_finalize (GParamSpec *pspec)
 851 {
 852   GParamSpecValueArray *aspec = G_PARAM_SPEC_VALUE_ARRAY (pspec);
 853   GParamSpecClass *parent_class = g_type_class_peek (g_type_parent (G_TYPE_PARAM_VALUE_ARRAY));
 854 
 855   if (aspec-&gt;element_spec)
 856     {
 857       g_param_spec_unref (aspec-&gt;element_spec);
 858       aspec-&gt;element_spec = NULL;
 859     }
 860 
 861   parent_class-&gt;finalize (pspec);
 862 }
 863 
 864 static void
 865 param_value_array_set_default (GParamSpec *pspec,
<span class="line-modified"> 866              GValue     *value)</span>
 867 {
 868   GParamSpecValueArray *aspec = G_PARAM_SPEC_VALUE_ARRAY (pspec);
 869 
 870   if (!value-&gt;data[0].v_pointer &amp;&amp; aspec-&gt;fixed_n_elements)
 871     value-&gt;data[0].v_pointer = g_value_array_new (aspec-&gt;fixed_n_elements);
 872 
 873   if (value-&gt;data[0].v_pointer)
 874     {
 875       /* g_value_reset (value);  already done */
 876       value_array_ensure_size (value-&gt;data[0].v_pointer, aspec-&gt;fixed_n_elements);
 877     }
 878 }
 879 
 880 static gboolean
 881 param_value_array_validate (GParamSpec *pspec,
<span class="line-modified"> 882           GValue     *value)</span>
 883 {
 884   GParamSpecValueArray *aspec = G_PARAM_SPEC_VALUE_ARRAY (pspec);
 885   GValueArray *value_array = value-&gt;data[0].v_pointer;
 886   guint changed = 0;
 887 
 888   if (!value-&gt;data[0].v_pointer &amp;&amp; aspec-&gt;fixed_n_elements)
 889     value-&gt;data[0].v_pointer = g_value_array_new (aspec-&gt;fixed_n_elements);
 890 
 891   if (value-&gt;data[0].v_pointer)
 892     {
 893       /* ensure array size validity */
 894       changed += value_array_ensure_size (value_array, aspec-&gt;fixed_n_elements);
 895 
 896       /* ensure array values validity against a present element spec */
 897       if (aspec-&gt;element_spec)
<span class="line-modified"> 898   {</span>
<span class="line-modified"> 899     GParamSpec *element_spec = aspec-&gt;element_spec;</span>
<span class="line-modified"> 900     guint i;</span>
 901 
<span class="line-modified"> 902     for (i = 0; i &lt; value_array-&gt;n_values; i++)</span>
<span class="line-modified"> 903       {</span>
<span class="line-modified"> 904         GValue *element = value_array-&gt;values + i;</span>
<span class="line-modified"> 905 </span>
<span class="line-modified"> 906         /* need to fixup value type, or ensure that the array value is initialized at all */</span>
<span class="line-modified"> 907         if (!g_value_type_compatible (G_VALUE_TYPE (element), G_PARAM_SPEC_VALUE_TYPE (element_spec)))</span>
<span class="line-modified"> 908     {</span>
<span class="line-modified"> 909       if (G_VALUE_TYPE (element) != 0)</span>
<span class="line-modified"> 910         g_value_unset (element);</span>
<span class="line-modified"> 911       g_value_init (element, G_PARAM_SPEC_VALUE_TYPE (element_spec));</span>
<span class="line-modified"> 912       g_param_value_set_default (element_spec, element);</span>
<span class="line-modified"> 913       changed++;</span>




 914     }
<span class="line-added"> 915         /* validate array value against element_spec */</span>
<span class="line-added"> 916         changed += g_param_value_validate (element_spec, element);</span>
<span class="line-added"> 917       }</span>
<span class="line-added"> 918   }</span>
 919     }
 920 
 921   return changed;
 922 }
 923 
 924 static gint
 925 param_value_array_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 926             const GValue *value1,</span>
<span class="line-modified"> 927             const GValue *value2)</span>
 928 {
 929   GParamSpecValueArray *aspec = G_PARAM_SPEC_VALUE_ARRAY (pspec);
 930   GValueArray *value_array1 = value1-&gt;data[0].v_pointer;
 931   GValueArray *value_array2 = value2-&gt;data[0].v_pointer;
 932 
 933   if (!value_array1 || !value_array2)
 934     return value_array2 ? -1 : value_array1 != value_array2;
 935 
 936   if (value_array1-&gt;n_values != value_array2-&gt;n_values)
 937     return value_array1-&gt;n_values &lt; value_array2-&gt;n_values ? -1 : 1;
 938   else if (!aspec-&gt;element_spec)
 939     {
 940       /* we need an element specification for comparisons, so there&#39;s not much
 941        * to compare here, try to at least provide stable lesser/greater result
 942        */
 943       return value_array1-&gt;n_values &lt; value_array2-&gt;n_values ? -1 : value_array1-&gt;n_values &gt; value_array2-&gt;n_values;
 944     }
 945   else /* value_array1-&gt;n_values == value_array2-&gt;n_values */
 946     {
 947       guint i;
 948 
 949       for (i = 0; i &lt; value_array1-&gt;n_values; i++)
<span class="line-modified"> 950   {</span>
<span class="line-modified"> 951     GValue *element1 = value_array1-&gt;values + i;</span>
<span class="line-modified"> 952     GValue *element2 = value_array2-&gt;values + i;</span>
<span class="line-modified"> 953     gint cmp;</span>
<span class="line-modified"> 954 </span>
<span class="line-modified"> 955     /* need corresponding element types, provide stable result otherwise */</span>
<span class="line-modified"> 956     if (G_VALUE_TYPE (element1) != G_VALUE_TYPE (element2))</span>
<span class="line-modified"> 957       return G_VALUE_TYPE (element1) &lt; G_VALUE_TYPE (element2) ? -1 : 1;</span>
<span class="line-modified"> 958     cmp = g_param_values_cmp (aspec-&gt;element_spec, element1, element2);</span>
<span class="line-modified"> 959     if (cmp)</span>
<span class="line-modified"> 960       return cmp;</span>
<span class="line-modified"> 961   }</span>
 962       return 0;
 963     }
 964 }
 965 
 966 static void
 967 param_object_init (GParamSpec *pspec)
 968 {
 969   /* GParamSpecObject *ospec = G_PARAM_SPEC_OBJECT (pspec); */
 970 }
 971 
 972 static void
 973 param_object_set_default (GParamSpec *pspec,
<span class="line-modified"> 974         GValue     *value)</span>
 975 {
 976   value-&gt;data[0].v_pointer = NULL;
 977 }
 978 
 979 static gboolean
 980 param_object_validate (GParamSpec *pspec,
<span class="line-modified"> 981            GValue     *value)</span>
 982 {
 983   GParamSpecObject *ospec = G_PARAM_SPEC_OBJECT (pspec);
 984   GObject *object = value-&gt;data[0].v_pointer;
 985   guint changed = 0;
 986 
 987   if (object &amp;&amp; !g_value_type_compatible (G_OBJECT_TYPE (object), G_PARAM_SPEC_VALUE_TYPE (ospec)))
 988     {
 989       g_object_unref (object);
 990       value-&gt;data[0].v_pointer = NULL;
 991       changed++;
 992     }
 993 
 994   return changed;
 995 }
 996 
 997 static gint
 998 param_object_values_cmp (GParamSpec   *pspec,
<span class="line-modified"> 999        const GValue *value1,</span>
<span class="line-modified">1000        const GValue *value2)</span>
1001 {
1002   guint8 *p1 = value1-&gt;data[0].v_pointer;
1003   guint8 *p2 = value2-&gt;data[0].v_pointer;
1004 
1005   /* not much to compare here, try to at least provide stable lesser/greater result */
1006 
1007   return p1 &lt; p2 ? -1 : p1 &gt; p2;
1008 }
1009 
1010 static void
1011 param_override_init (GParamSpec *pspec)
1012 {
1013   /* GParamSpecOverride *ospec = G_PARAM_SPEC_OVERRIDE (pspec); */
1014 }
1015 
1016 static void
1017 param_override_finalize (GParamSpec *pspec)
1018 {
1019   GParamSpecOverride *ospec = G_PARAM_SPEC_OVERRIDE (pspec);
1020   GParamSpecClass *parent_class = g_type_class_peek (g_type_parent (G_TYPE_PARAM_OVERRIDE));
1021 
1022   if (ospec-&gt;overridden)
1023     {
1024       g_param_spec_unref (ospec-&gt;overridden);
1025       ospec-&gt;overridden = NULL;
1026     }
1027 
1028   parent_class-&gt;finalize (pspec);
1029 }
1030 
1031 static void
1032 param_override_set_default (GParamSpec *pspec,
<span class="line-modified">1033           GValue     *value)</span>
1034 {
1035   GParamSpecOverride *ospec = G_PARAM_SPEC_OVERRIDE (pspec);
1036 
1037   g_param_value_set_default (ospec-&gt;overridden, value);
1038 }
1039 
1040 static gboolean
1041 param_override_validate (GParamSpec *pspec,
<span class="line-modified">1042        GValue     *value)</span>
1043 {
1044   GParamSpecOverride *ospec = G_PARAM_SPEC_OVERRIDE (pspec);
1045 
1046   return g_param_value_validate (ospec-&gt;overridden, value);
1047 }
1048 
1049 static gint
1050 param_override_values_cmp (GParamSpec   *pspec,
<span class="line-modified">1051          const GValue *value1,</span>
<span class="line-modified">1052          const GValue *value2)</span>
1053 {
1054   GParamSpecOverride *ospec = G_PARAM_SPEC_OVERRIDE (pspec);
1055 
1056   return g_param_values_cmp (ospec-&gt;overridden, value1, value2);
1057 }
1058 
1059 static void
1060 param_gtype_init (GParamSpec *pspec)
1061 {
1062 }
1063 
1064 static void
1065 param_gtype_set_default (GParamSpec *pspec,
<span class="line-modified">1066        GValue     *value)</span>
1067 {
1068   GParamSpecGType *tspec = G_PARAM_SPEC_GTYPE (pspec);
1069 
1070   value-&gt;data[0].v_pointer = GSIZE_TO_POINTER (tspec-&gt;is_a_type);
1071 }
1072 
1073 static gboolean
1074 param_gtype_validate (GParamSpec *pspec,
<span class="line-modified">1075           GValue     *value)</span>
1076 {
1077   GParamSpecGType *tspec = G_PARAM_SPEC_GTYPE (pspec);
1078   GType gtype = GPOINTER_TO_SIZE (value-&gt;data[0].v_pointer);
1079   guint changed = 0;
1080 
1081   if (tspec-&gt;is_a_type != G_TYPE_NONE &amp;&amp; !g_type_is_a (gtype, tspec-&gt;is_a_type))
1082     {
1083       value-&gt;data[0].v_pointer = GSIZE_TO_POINTER (tspec-&gt;is_a_type);
1084       changed++;
1085     }
1086 
1087   return changed;
1088 }
1089 
1090 static gint
1091 param_gtype_values_cmp (GParamSpec   *pspec,
<span class="line-modified">1092       const GValue *value1,</span>
<span class="line-modified">1093       const GValue *value2)</span>
1094 {
1095   GType p1 = GPOINTER_TO_SIZE (value1-&gt;data[0].v_pointer);
1096   GType p2 = GPOINTER_TO_SIZE (value2-&gt;data[0].v_pointer);
1097 
1098   /* not much to compare here, try to at least provide stable lesser/greater result */
1099 
1100   return p1 &lt; p2 ? -1 : p1 &gt; p2;
1101 }
1102 
1103 static void
1104 param_variant_init (GParamSpec *pspec)
1105 {
1106   GParamSpecVariant *vspec = G_PARAM_SPEC_VARIANT (pspec);
1107 
1108   vspec-&gt;type = NULL;
1109   vspec-&gt;default_value = NULL;
1110 }
1111 
1112 static void
1113 param_variant_finalize (GParamSpec *pspec)
</pre>
<hr />
<pre>
1174   else if (v1 == NULL &amp;&amp; v2 != NULL)
1175     return -1;
1176   else if (v1 != NULL &amp;&amp; v2 == NULL)
1177     return 1;
1178 
1179   if (!g_variant_type_equal (g_variant_get_type (v1), g_variant_get_type (v2)) ||
1180       variant_is_incomparable (v1) ||
1181       variant_is_incomparable (v2))
1182     return g_variant_equal (v1, v2) ? 0 : (v1 &lt; v2 ? -1 : 1);
1183 
1184   return g_variant_compare (v1, v2);
1185 }
1186 
1187 /* --- type initialization --- */
1188 GType *g_param_spec_types = NULL;
1189 
1190 void
1191 _g_param_spec_types_init (void)
1192 {
1193   const guint n_types = 23;
<span class="line-modified">1194   GType type, *spec_types;</span>
<span class="line-added">1195 #ifndef G_DISABLE_ASSERT</span>
<span class="line-added">1196   GType *spec_types_bound;</span>
<span class="line-added">1197 #endif</span>
1198 
1199   g_param_spec_types = g_new0 (GType, n_types);
1200   spec_types = g_param_spec_types;
<span class="line-added">1201 #ifndef G_DISABLE_ASSERT</span>
1202   spec_types_bound = g_param_spec_types + n_types;
<span class="line-added">1203 #endif</span>
1204 
1205   /* G_TYPE_PARAM_CHAR
1206    */
1207   {
1208     const GParamSpecTypeInfo pspec_info = {
1209       sizeof (GParamSpecChar),  /* instance_size */
<span class="line-modified">1210       16,     /* n_preallocs */</span>
<span class="line-modified">1211       param_char_init,    /* instance_init */</span>
<span class="line-modified">1212       G_TYPE_CHAR,    /* value_type */</span>
<span class="line-modified">1213       NULL,     /* finalize */</span>
<span class="line-modified">1214       param_char_set_default, /* value_set_default */</span>
1215       param_char_validate,  /* value_validate */
1216       param_int_values_cmp, /* values_cmp */
1217     };
1218     type = g_param_type_register_static (g_intern_static_string (&quot;GParamChar&quot;), &amp;pspec_info);
1219     *spec_types++ = type;
1220     g_assert (type == G_TYPE_PARAM_CHAR);
1221   }
1222 
1223   /* G_TYPE_PARAM_UCHAR
1224    */
1225   {
1226     const GParamSpecTypeInfo pspec_info = {
1227       sizeof (GParamSpecUChar), /* instance_size */
1228       16,                       /* n_preallocs */
1229       param_uchar_init,         /* instance_init */
<span class="line-modified">1230       G_TYPE_UCHAR,   /* value_type */</span>
<span class="line-modified">1231       NULL,     /* finalize */</span>
1232       param_uchar_set_default,  /* value_set_default */
1233       param_uchar_validate, /* value_validate */
<span class="line-modified">1234       param_uint_values_cmp,  /* values_cmp */</span>
1235     };
1236     type = g_param_type_register_static (g_intern_static_string (&quot;GParamUChar&quot;), &amp;pspec_info);
1237     *spec_types++ = type;
1238     g_assert (type == G_TYPE_PARAM_UCHAR);
1239   }
1240 
1241   /* G_TYPE_PARAM_BOOLEAN
1242    */
1243   {
1244     const GParamSpecTypeInfo pspec_info = {
1245       sizeof (GParamSpecBoolean), /* instance_size */
1246       16,                         /* n_preallocs */
<span class="line-modified">1247       NULL,       /* instance_init */</span>
1248       G_TYPE_BOOLEAN,             /* value_type */
1249       NULL,                       /* finalize */
1250       param_boolean_set_default,  /* value_set_default */
1251       param_boolean_validate,     /* value_validate */
1252       param_int_values_cmp,       /* values_cmp */
1253     };
1254     type = g_param_type_register_static (g_intern_static_string (&quot;GParamBoolean&quot;), &amp;pspec_info);
1255     *spec_types++ = type;
1256     g_assert (type == G_TYPE_PARAM_BOOLEAN);
1257   }
1258 
1259   /* G_TYPE_PARAM_INT
1260    */
1261   {
1262     const GParamSpecTypeInfo pspec_info = {
1263       sizeof (GParamSpecInt),   /* instance_size */
1264       16,                       /* n_preallocs */
1265       param_int_init,           /* instance_init */
<span class="line-modified">1266       G_TYPE_INT,   /* value_type */</span>
<span class="line-modified">1267       NULL,     /* finalize */</span>
<span class="line-modified">1268       param_int_set_default,  /* value_set_default */</span>
<span class="line-modified">1269       param_int_validate, /* value_validate */</span>
1270       param_int_values_cmp, /* values_cmp */
1271     };
1272     type = g_param_type_register_static (g_intern_static_string (&quot;GParamInt&quot;), &amp;pspec_info);
1273     *spec_types++ = type;
1274     g_assert (type == G_TYPE_PARAM_INT);
1275   }
1276 
1277   /* G_TYPE_PARAM_UINT
1278    */
1279   {
1280     const GParamSpecTypeInfo pspec_info = {
1281       sizeof (GParamSpecUInt),  /* instance_size */
1282       16,                       /* n_preallocs */
1283       param_uint_init,          /* instance_init */
<span class="line-modified">1284       G_TYPE_UINT,    /* value_type */</span>
<span class="line-modified">1285       NULL,     /* finalize */</span>
<span class="line-modified">1286       param_uint_set_default, /* value_set_default */</span>
1287       param_uint_validate,  /* value_validate */
<span class="line-modified">1288       param_uint_values_cmp,  /* values_cmp */</span>
1289     };
1290     type = g_param_type_register_static (g_intern_static_string (&quot;GParamUInt&quot;), &amp;pspec_info);
1291     *spec_types++ = type;
1292     g_assert (type == G_TYPE_PARAM_UINT);
1293   }
1294 
1295   /* G_TYPE_PARAM_LONG
1296    */
1297   {
1298     const GParamSpecTypeInfo pspec_info = {
1299       sizeof (GParamSpecLong),  /* instance_size */
1300       16,                       /* n_preallocs */
1301       param_long_init,          /* instance_init */
<span class="line-modified">1302       G_TYPE_LONG,    /* value_type */</span>
<span class="line-modified">1303       NULL,     /* finalize */</span>
<span class="line-modified">1304       param_long_set_default, /* value_set_default */</span>
1305       param_long_validate,  /* value_validate */
<span class="line-modified">1306       param_long_values_cmp,  /* values_cmp */</span>
1307     };
1308     type = g_param_type_register_static (g_intern_static_string (&quot;GParamLong&quot;), &amp;pspec_info);
1309     *spec_types++ = type;
1310     g_assert (type == G_TYPE_PARAM_LONG);
1311   }
1312 
1313   /* G_TYPE_PARAM_ULONG
1314    */
1315   {
1316     const GParamSpecTypeInfo pspec_info = {
1317       sizeof (GParamSpecULong), /* instance_size */
1318       16,                       /* n_preallocs */
1319       param_ulong_init,         /* instance_init */
<span class="line-modified">1320       G_TYPE_ULONG,   /* value_type */</span>
<span class="line-modified">1321       NULL,     /* finalize */</span>
1322       param_ulong_set_default,  /* value_set_default */
1323       param_ulong_validate, /* value_validate */
<span class="line-modified">1324       param_ulong_values_cmp, /* values_cmp */</span>
1325     };
1326     type = g_param_type_register_static (g_intern_static_string (&quot;GParamULong&quot;), &amp;pspec_info);
1327     *spec_types++ = type;
1328     g_assert (type == G_TYPE_PARAM_ULONG);
1329   }
1330 
1331   /* G_TYPE_PARAM_INT64
1332    */
1333   {
1334     const GParamSpecTypeInfo pspec_info = {
1335       sizeof (GParamSpecInt64),  /* instance_size */
1336       16,                       /* n_preallocs */
1337       param_int64_init,         /* instance_init */
<span class="line-modified">1338       G_TYPE_INT64,   /* value_type */</span>
<span class="line-modified">1339       NULL,     /* finalize */</span>
1340       param_int64_set_default,  /* value_set_default */
1341       param_int64_validate, /* value_validate */
<span class="line-modified">1342       param_int64_values_cmp, /* values_cmp */</span>
1343     };
1344     type = g_param_type_register_static (g_intern_static_string (&quot;GParamInt64&quot;), &amp;pspec_info);
1345     *spec_types++ = type;
1346     g_assert (type == G_TYPE_PARAM_INT64);
1347   }
1348 
1349   /* G_TYPE_PARAM_UINT64
1350    */
1351   {
1352     const GParamSpecTypeInfo pspec_info = {
1353       sizeof (GParamSpecUInt64), /* instance_size */
1354       16,                       /* n_preallocs */
1355       param_uint64_init,        /* instance_init */
<span class="line-modified">1356       G_TYPE_UINT64,    /* value_type */</span>
<span class="line-modified">1357       NULL,     /* finalize */</span>
1358       param_uint64_set_default, /* value_set_default */
<span class="line-modified">1359       param_uint64_validate,  /* value_validate */</span>
1360       param_uint64_values_cmp,  /* values_cmp */
1361     };
1362     type = g_param_type_register_static (g_intern_static_string (&quot;GParamUInt64&quot;), &amp;pspec_info);
1363     *spec_types++ = type;
1364     g_assert (type == G_TYPE_PARAM_UINT64);
1365   }
1366 
1367   /* G_TYPE_PARAM_UNICHAR
1368    */
1369   {
1370     const GParamSpecTypeInfo pspec_info = {
1371       sizeof (GParamSpecUnichar), /* instance_size */
1372       16,                        /* n_preallocs */
<span class="line-modified">1373       param_unichar_init,  /* instance_init */</span>
<span class="line-modified">1374       G_TYPE_UINT,     /* value_type */</span>
<span class="line-modified">1375       NULL,      /* finalize */</span>
1376       param_unichar_set_default, /* value_set_default */
<span class="line-modified">1377       param_unichar_validate,  /* value_validate */</span>
1378       param_unichar_values_cmp,  /* values_cmp */
1379     };
1380     type = g_param_type_register_static (g_intern_static_string (&quot;GParamUnichar&quot;), &amp;pspec_info);
1381     *spec_types++ = type;
1382     g_assert (type == G_TYPE_PARAM_UNICHAR);
1383   }
1384 
1385  /* G_TYPE_PARAM_ENUM
1386    */
1387   {
1388     const GParamSpecTypeInfo pspec_info = {
1389       sizeof (GParamSpecEnum),  /* instance_size */
1390       16,                       /* n_preallocs */
1391       param_enum_init,          /* instance_init */
<span class="line-modified">1392       G_TYPE_ENUM,    /* value_type */</span>
1393       param_enum_finalize,  /* finalize */
<span class="line-modified">1394       param_enum_set_default, /* value_set_default */</span>
1395       param_enum_validate,  /* value_validate */
<span class="line-modified">1396       param_long_values_cmp,  /* values_cmp */</span>
1397     };
1398     type = g_param_type_register_static (g_intern_static_string (&quot;GParamEnum&quot;), &amp;pspec_info);
1399     *spec_types++ = type;
1400     g_assert (type == G_TYPE_PARAM_ENUM);
1401   }
1402 
1403   /* G_TYPE_PARAM_FLAGS
1404    */
1405   {
1406     const GParamSpecTypeInfo pspec_info = {
1407       sizeof (GParamSpecFlags), /* instance_size */
<span class="line-modified">1408       16,     /* n_preallocs */</span>
<span class="line-modified">1409       param_flags_init,   /* instance_init */</span>
<span class="line-modified">1410       G_TYPE_FLAGS,   /* value_type */</span>
1411       param_flags_finalize, /* finalize */
1412       param_flags_set_default,  /* value_set_default */
1413       param_flags_validate, /* value_validate */
<span class="line-modified">1414       param_ulong_values_cmp, /* values_cmp */</span>
1415     };
1416     type = g_param_type_register_static (g_intern_static_string (&quot;GParamFlags&quot;), &amp;pspec_info);
1417     *spec_types++ = type;
1418     g_assert (type == G_TYPE_PARAM_FLAGS);
1419   }
1420 
1421   /* G_TYPE_PARAM_FLOAT
1422    */
1423   {
1424     const GParamSpecTypeInfo pspec_info = {
1425       sizeof (GParamSpecFloat), /* instance_size */
1426       16,                       /* n_preallocs */
1427       param_float_init,         /* instance_init */
<span class="line-modified">1428       G_TYPE_FLOAT,   /* value_type */</span>
<span class="line-modified">1429       NULL,     /* finalize */</span>
1430       param_float_set_default,  /* value_set_default */
1431       param_float_validate, /* value_validate */
<span class="line-modified">1432       param_float_values_cmp, /* values_cmp */</span>
1433     };
1434     type = g_param_type_register_static (g_intern_static_string (&quot;GParamFloat&quot;), &amp;pspec_info);
1435     *spec_types++ = type;
1436     g_assert (type == G_TYPE_PARAM_FLOAT);
1437   }
1438 
1439   /* G_TYPE_PARAM_DOUBLE
1440    */
1441   {
1442     const GParamSpecTypeInfo pspec_info = {
<span class="line-modified">1443       sizeof (GParamSpecDouble),  /* instance_size */</span>
<span class="line-modified">1444       16,       /* n_preallocs */</span>
<span class="line-modified">1445       param_double_init,    /* instance_init */</span>
<span class="line-modified">1446       G_TYPE_DOUBLE,      /* value_type */</span>
<span class="line-modified">1447       NULL,       /* finalize */</span>
<span class="line-modified">1448       param_double_set_default,   /* value_set_default */</span>
<span class="line-modified">1449       param_double_validate,    /* value_validate */</span>
<span class="line-modified">1450       param_double_values_cmp,    /* values_cmp */</span>
1451     };
1452     type = g_param_type_register_static (g_intern_static_string (&quot;GParamDouble&quot;), &amp;pspec_info);
1453     *spec_types++ = type;
1454     g_assert (type == G_TYPE_PARAM_DOUBLE);
1455   }
1456 
1457   /* G_TYPE_PARAM_STRING
1458    */
1459   {
1460     const GParamSpecTypeInfo pspec_info = {
<span class="line-modified">1461       sizeof (GParamSpecString),  /* instance_size */</span>
<span class="line-modified">1462       16,       /* n_preallocs */</span>
<span class="line-modified">1463       param_string_init,    /* instance_init */</span>
<span class="line-modified">1464       G_TYPE_STRING,      /* value_type */</span>
<span class="line-modified">1465       param_string_finalize,    /* finalize */</span>
<span class="line-modified">1466       param_string_set_default,   /* value_set_default */</span>
<span class="line-modified">1467       param_string_validate,    /* value_validate */</span>
<span class="line-modified">1468       param_string_values_cmp,    /* values_cmp */</span>
1469     };
1470     type = g_param_type_register_static (g_intern_static_string (&quot;GParamString&quot;), &amp;pspec_info);
1471     *spec_types++ = type;
1472     g_assert (type == G_TYPE_PARAM_STRING);
1473   }
1474 
1475   /* G_TYPE_PARAM_PARAM
1476    */
1477   {
1478     const GParamSpecTypeInfo pspec_info = {
1479       sizeof (GParamSpecParam), /* instance_size */
<span class="line-modified">1480       16,     /* n_preallocs */</span>
<span class="line-modified">1481       param_param_init,   /* instance_init */</span>
<span class="line-modified">1482       G_TYPE_PARAM,   /* value_type */</span>
<span class="line-modified">1483       NULL,     /* finalize */</span>
1484       param_param_set_default,  /* value_set_default */
1485       param_param_validate, /* value_validate */
1486       param_pointer_values_cmp, /* values_cmp */
1487     };
1488     type = g_param_type_register_static (g_intern_static_string (&quot;GParamParam&quot;), &amp;pspec_info);
1489     *spec_types++ = type;
1490     g_assert (type == G_TYPE_PARAM_PARAM);
1491   }
1492 
1493   /* G_TYPE_PARAM_BOXED
1494    */
1495   {
1496     const GParamSpecTypeInfo pspec_info = {
1497       sizeof (GParamSpecBoxed), /* instance_size */
<span class="line-modified">1498       4,      /* n_preallocs */</span>
<span class="line-modified">1499       param_boxed_init,   /* instance_init */</span>
<span class="line-modified">1500       G_TYPE_BOXED,   /* value_type */</span>
<span class="line-modified">1501       NULL,     /* finalize */</span>
1502       param_boxed_set_default,  /* value_set_default */
1503       param_boxed_validate, /* value_validate */
<span class="line-modified">1504       param_boxed_values_cmp, /* values_cmp */</span>
1505     };
1506     type = g_param_type_register_static (g_intern_static_string (&quot;GParamBoxed&quot;), &amp;pspec_info);
1507     *spec_types++ = type;
1508     g_assert (type == G_TYPE_PARAM_BOXED);
1509   }
1510 
1511   /* G_TYPE_PARAM_POINTER
1512    */
1513   {
1514     const GParamSpecTypeInfo pspec_info = {
1515       sizeof (GParamSpecPointer),  /* instance_size */
1516       0,                           /* n_preallocs */
<span class="line-modified">1517       param_pointer_init,    /* instance_init */</span>
<span class="line-modified">1518       G_TYPE_POINTER,        /* value_type */</span>
<span class="line-modified">1519       NULL,        /* finalize */</span>
1520       param_pointer_set_default,   /* value_set_default */
<span class="line-modified">1521       param_pointer_validate,    /* value_validate */</span>
1522       param_pointer_values_cmp,    /* values_cmp */
1523     };
1524     type = g_param_type_register_static (g_intern_static_string (&quot;GParamPointer&quot;), &amp;pspec_info);
1525     *spec_types++ = type;
1526     g_assert (type == G_TYPE_PARAM_POINTER);
1527   }
1528 
1529   /* G_TYPE_PARAM_VALUE_ARRAY
1530    */
1531   {
1532     /* const */ GParamSpecTypeInfo pspec_info = {
<span class="line-modified">1533       sizeof (GParamSpecValueArray),  /* instance_size */</span>
<span class="line-modified">1534       0,        /* n_preallocs */</span>
<span class="line-modified">1535       param_value_array_init,   /* instance_init */</span>
<span class="line-modified">1536       0xdeadbeef,     /* value_type, assigned further down */</span>
<span class="line-modified">1537       param_value_array_finalize, /* finalize */</span>
<span class="line-modified">1538       param_value_array_set_default,  /* value_set_default */</span>
<span class="line-modified">1539       param_value_array_validate, /* value_validate */</span>
1540       param_value_array_values_cmp, /* values_cmp */
1541     };
1542     pspec_info.value_type = G_TYPE_VALUE_ARRAY;
1543     type = g_param_type_register_static (g_intern_static_string (&quot;GParamValueArray&quot;), &amp;pspec_info);
1544     *spec_types++ = type;
1545     g_assert (type == G_TYPE_PARAM_VALUE_ARRAY);
1546   }
1547 
1548   /* G_TYPE_PARAM_OBJECT
1549    */
1550   {
1551     const GParamSpecTypeInfo pspec_info = {
1552       sizeof (GParamSpecObject), /* instance_size */
1553       16,                        /* n_preallocs */
<span class="line-modified">1554       param_object_init,   /* instance_init */</span>
<span class="line-modified">1555       G_TYPE_OBJECT,     /* value_type */</span>
<span class="line-modified">1556       NULL,      /* finalize */</span>
1557       param_object_set_default,  /* value_set_default */
<span class="line-modified">1558       param_object_validate,   /* value_validate */</span>
1559       param_object_values_cmp,   /* values_cmp */
1560     };
1561     type = g_param_type_register_static (g_intern_static_string (&quot;GParamObject&quot;), &amp;pspec_info);
1562     *spec_types++ = type;
1563     g_assert (type == G_TYPE_PARAM_OBJECT);
1564   }
1565 
1566   /* G_TYPE_PARAM_OVERRIDE
1567    */
1568   {
1569     const GParamSpecTypeInfo pspec_info = {
1570       sizeof (GParamSpecOverride), /* instance_size */
1571       16,                        /* n_preallocs */
1572       param_override_init,   /* instance_init */
<span class="line-modified">1573       G_TYPE_NONE,     /* value_type */</span>
1574       param_override_finalize,   /* finalize */
1575       param_override_set_default, /* value_set_default */
1576       param_override_validate,    /* value_validate */
1577       param_override_values_cmp,  /* values_cmp */
1578     };
1579     type = g_param_type_register_static (g_intern_static_string (&quot;GParamOverride&quot;), &amp;pspec_info);
1580     *spec_types++ = type;
1581     g_assert (type == G_TYPE_PARAM_OVERRIDE);
1582   }
1583 
1584   /* G_TYPE_PARAM_GTYPE
1585    */
1586   {
1587     GParamSpecTypeInfo pspec_info = {
1588       sizeof (GParamSpecGType), /* instance_size */
<span class="line-modified">1589       0,      /* n_preallocs */</span>
<span class="line-modified">1590       param_gtype_init,   /* instance_init */</span>
<span class="line-modified">1591       0xdeadbeef,   /* value_type, assigned further down */</span>
<span class="line-modified">1592       NULL,     /* finalize */</span>
1593       param_gtype_set_default,  /* value_set_default */
1594       param_gtype_validate, /* value_validate */
<span class="line-modified">1595       param_gtype_values_cmp, /* values_cmp */</span>
1596     };
1597     pspec_info.value_type = G_TYPE_GTYPE;
1598     type = g_param_type_register_static (g_intern_static_string (&quot;GParamGType&quot;), &amp;pspec_info);
1599     *spec_types++ = type;
1600     g_assert (type == G_TYPE_PARAM_GTYPE);
1601   }
1602 
1603   /* G_TYPE_PARAM_VARIANT
1604    */
1605   {
1606     const GParamSpecTypeInfo pspec_info = {
1607       sizeof (GParamSpecVariant), /* instance_size */
1608       0,                          /* n_preallocs */
1609       param_variant_init,         /* instance_init */
1610       G_TYPE_VARIANT,             /* value_type */
1611       param_variant_finalize,     /* finalize */
1612       param_variant_set_default,  /* value_set_default */
1613       param_variant_validate,     /* value_validate */
1614       param_variant_values_cmp,   /* values_cmp */
1615     };
</pre>
<hr />
<pre>
1622 }
1623 
1624 /* --- GParamSpec initialization --- */
1625 
1626 /**
1627  * g_param_spec_char:
1628  * @name: canonical name of the property specified
1629  * @nick: nick name for the property specified
1630  * @blurb: description of the property specified
1631  * @minimum: minimum value for the property specified
1632  * @maximum: maximum value for the property specified
1633  * @default_value: default value for the property specified
1634  * @flags: flags for the property specified
1635  *
1636  * Creates a new #GParamSpecChar instance specifying a %G_TYPE_CHAR property.
1637  *
1638  * Returns: (transfer full): a newly created parameter specification
1639  */
1640 GParamSpec*
1641 g_param_spec_char (const gchar *name,
<span class="line-modified">1642        const gchar *nick,</span>
<span class="line-modified">1643        const gchar *blurb,</span>
<span class="line-modified">1644        gint8  minimum,</span>
<span class="line-modified">1645        gint8  maximum,</span>
<span class="line-modified">1646        gint8  default_value,</span>
<span class="line-modified">1647        GParamFlags  flags)</span>
1648 {
1649   GParamSpecChar *cspec;
1650 
1651   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
1652 
1653   cspec = g_param_spec_internal (G_TYPE_PARAM_CHAR,
<span class="line-modified">1654          name,</span>
<span class="line-modified">1655          nick,</span>
<span class="line-modified">1656          blurb,</span>
<span class="line-modified">1657          flags);</span>
1658   if (cspec == NULL)
1659     return NULL;
1660 
1661   cspec-&gt;minimum = minimum;
1662   cspec-&gt;maximum = maximum;
1663   cspec-&gt;default_value = default_value;
1664 
1665   return G_PARAM_SPEC (cspec);
1666 }
1667 
1668 /**
1669  * g_param_spec_uchar:
1670  * @name: canonical name of the property specified
1671  * @nick: nick name for the property specified
1672  * @blurb: description of the property specified
1673  * @minimum: minimum value for the property specified
1674  * @maximum: maximum value for the property specified
1675  * @default_value: default value for the property specified
1676  * @flags: flags for the property specified
1677  *
1678  * Creates a new #GParamSpecUChar instance specifying a %G_TYPE_UCHAR property.
1679  *
1680  * Returns: (transfer full): a newly created parameter specification
1681  */
1682 GParamSpec*
1683 g_param_spec_uchar (const gchar *name,
<span class="line-modified">1684         const gchar *nick,</span>
<span class="line-modified">1685         const gchar *blurb,</span>
<span class="line-modified">1686         guint8   minimum,</span>
<span class="line-modified">1687         guint8   maximum,</span>
<span class="line-modified">1688         guint8   default_value,</span>
<span class="line-modified">1689         GParamFlags  flags)</span>
1690 {
1691   GParamSpecUChar *uspec;
1692 
1693   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
1694 
1695   uspec = g_param_spec_internal (G_TYPE_PARAM_UCHAR,
<span class="line-modified">1696          name,</span>
<span class="line-modified">1697          nick,</span>
<span class="line-modified">1698          blurb,</span>
<span class="line-modified">1699          flags);</span>
1700   if (uspec == NULL)
1701     return NULL;
1702 
1703   uspec-&gt;minimum = minimum;
1704   uspec-&gt;maximum = maximum;
1705   uspec-&gt;default_value = default_value;
1706 
1707   return G_PARAM_SPEC (uspec);
1708 }
1709 
1710 /**
1711  * g_param_spec_boolean:
1712  * @name: canonical name of the property specified
1713  * @nick: nick name for the property specified
1714  * @blurb: description of the property specified
1715  * @default_value: default value for the property specified
1716  * @flags: flags for the property specified
1717  *
1718  * Creates a new #GParamSpecBoolean instance specifying a %G_TYPE_BOOLEAN
1719  * property. In many cases, it may be more appropriate to use an enum with
1720  * g_param_spec_enum(), both to improve code clarity by using explicitly named
1721  * values, and to allow for more values to be added in future without breaking
1722  * API.
1723  *
1724  * See g_param_spec_internal() for details on property names.
1725  *
1726  * Returns: (transfer full): a newly created parameter specification
1727  */
1728 GParamSpec*
1729 g_param_spec_boolean (const gchar *name,
<span class="line-modified">1730           const gchar *nick,</span>
<span class="line-modified">1731           const gchar *blurb,</span>
<span class="line-modified">1732           gboolean     default_value,</span>
<span class="line-modified">1733           GParamFlags  flags)</span>
1734 {
1735   GParamSpecBoolean *bspec;
1736 
1737   g_return_val_if_fail (default_value == TRUE || default_value == FALSE, NULL);
1738 
1739   bspec = g_param_spec_internal (G_TYPE_PARAM_BOOLEAN,
<span class="line-modified">1740          name,</span>
<span class="line-modified">1741          nick,</span>
<span class="line-modified">1742          blurb,</span>
<span class="line-modified">1743          flags);</span>
1744   if (bspec == NULL)
1745     return NULL;
1746 
1747   bspec-&gt;default_value = default_value;
1748 
1749   return G_PARAM_SPEC (bspec);
1750 }
1751 
1752 /**
1753  * g_param_spec_int:
1754  * @name: canonical name of the property specified
1755  * @nick: nick name for the property specified
1756  * @blurb: description of the property specified
1757  * @minimum: minimum value for the property specified
1758  * @maximum: maximum value for the property specified
1759  * @default_value: default value for the property specified
1760  * @flags: flags for the property specified
1761  *
1762  * Creates a new #GParamSpecInt instance specifying a %G_TYPE_INT property.
1763  *
1764  * See g_param_spec_internal() for details on property names.
1765  *
1766  * Returns: (transfer full): a newly created parameter specification
1767  */
1768 GParamSpec*
1769 g_param_spec_int (const gchar *name,
<span class="line-modified">1770       const gchar *nick,</span>
<span class="line-modified">1771       const gchar *blurb,</span>
<span class="line-modified">1772       gint         minimum,</span>
<span class="line-modified">1773       gint         maximum,</span>
<span class="line-modified">1774       gint         default_value,</span>
<span class="line-modified">1775       GParamFlags  flags)</span>
1776 {
1777   GParamSpecInt *ispec;
1778 
1779   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
1780 
1781   ispec = g_param_spec_internal (G_TYPE_PARAM_INT,
<span class="line-modified">1782          name,</span>
<span class="line-modified">1783          nick,</span>
<span class="line-modified">1784          blurb,</span>
<span class="line-modified">1785          flags);</span>
1786   if (ispec == NULL)
1787     return NULL;
1788 
1789   ispec-&gt;minimum = minimum;
1790   ispec-&gt;maximum = maximum;
1791   ispec-&gt;default_value = default_value;
1792 
1793   return G_PARAM_SPEC (ispec);
1794 }
1795 
1796 /**
1797  * g_param_spec_uint:
1798  * @name: canonical name of the property specified
1799  * @nick: nick name for the property specified
1800  * @blurb: description of the property specified
1801  * @minimum: minimum value for the property specified
1802  * @maximum: maximum value for the property specified
1803  * @default_value: default value for the property specified
1804  * @flags: flags for the property specified
1805  *
1806  * Creates a new #GParamSpecUInt instance specifying a %G_TYPE_UINT property.
1807  *
1808  * See g_param_spec_internal() for details on property names.
1809  *
1810  * Returns: (transfer full): a newly created parameter specification
1811  */
1812 GParamSpec*
1813 g_param_spec_uint (const gchar *name,
<span class="line-modified">1814        const gchar *nick,</span>
<span class="line-modified">1815        const gchar *blurb,</span>
<span class="line-modified">1816        guint  minimum,</span>
<span class="line-modified">1817        guint  maximum,</span>
<span class="line-modified">1818        guint  default_value,</span>
<span class="line-modified">1819        GParamFlags  flags)</span>
1820 {
1821   GParamSpecUInt *uspec;
1822 
1823   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
1824 
1825   uspec = g_param_spec_internal (G_TYPE_PARAM_UINT,
<span class="line-modified">1826          name,</span>
<span class="line-modified">1827          nick,</span>
<span class="line-modified">1828          blurb,</span>
<span class="line-modified">1829          flags);</span>
1830   if (uspec == NULL)
1831     return NULL;
1832 
1833   uspec-&gt;minimum = minimum;
1834   uspec-&gt;maximum = maximum;
1835   uspec-&gt;default_value = default_value;
1836 
1837   return G_PARAM_SPEC (uspec);
1838 }
1839 
1840 /**
1841  * g_param_spec_long:
1842  * @name: canonical name of the property specified
1843  * @nick: nick name for the property specified
1844  * @blurb: description of the property specified
1845  * @minimum: minimum value for the property specified
1846  * @maximum: maximum value for the property specified
1847  * @default_value: default value for the property specified
1848  * @flags: flags for the property specified
1849  *
1850  * Creates a new #GParamSpecLong instance specifying a %G_TYPE_LONG property.
1851  *
1852  * See g_param_spec_internal() for details on property names.
1853  *
1854  * Returns: (transfer full): a newly created parameter specification
1855  */
1856 GParamSpec*
1857 g_param_spec_long (const gchar *name,
<span class="line-modified">1858        const gchar *nick,</span>
<span class="line-modified">1859        const gchar *blurb,</span>
<span class="line-modified">1860        glong  minimum,</span>
<span class="line-modified">1861        glong  maximum,</span>
<span class="line-modified">1862        glong  default_value,</span>
<span class="line-modified">1863        GParamFlags  flags)</span>
1864 {
1865   GParamSpecLong *lspec;
1866 
1867   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
1868 
1869   lspec = g_param_spec_internal (G_TYPE_PARAM_LONG,
<span class="line-modified">1870          name,</span>
<span class="line-modified">1871          nick,</span>
<span class="line-modified">1872          blurb,</span>
<span class="line-modified">1873          flags);</span>
1874   if (lspec == NULL)
1875     return NULL;
1876 
1877   lspec-&gt;minimum = minimum;
1878   lspec-&gt;maximum = maximum;
1879   lspec-&gt;default_value = default_value;
1880 
1881   return G_PARAM_SPEC (lspec);
1882 }
1883 
1884 /**
1885  * g_param_spec_ulong:
1886  * @name: canonical name of the property specified
1887  * @nick: nick name for the property specified
1888  * @blurb: description of the property specified
1889  * @minimum: minimum value for the property specified
1890  * @maximum: maximum value for the property specified
1891  * @default_value: default value for the property specified
1892  * @flags: flags for the property specified
1893  *
1894  * Creates a new #GParamSpecULong instance specifying a %G_TYPE_ULONG
1895  * property.
1896  *
1897  * See g_param_spec_internal() for details on property names.
1898  *
1899  * Returns: (transfer full): a newly created parameter specification
1900  */
1901 GParamSpec*
1902 g_param_spec_ulong (const gchar *name,
<span class="line-modified">1903         const gchar *nick,</span>
<span class="line-modified">1904         const gchar *blurb,</span>
<span class="line-modified">1905         gulong   minimum,</span>
<span class="line-modified">1906         gulong   maximum,</span>
<span class="line-modified">1907         gulong   default_value,</span>
<span class="line-modified">1908         GParamFlags  flags)</span>
1909 {
1910   GParamSpecULong *uspec;
1911 
1912   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
1913 
1914   uspec = g_param_spec_internal (G_TYPE_PARAM_ULONG,
<span class="line-modified">1915          name,</span>
<span class="line-modified">1916          nick,</span>
<span class="line-modified">1917          blurb,</span>
<span class="line-modified">1918          flags);</span>
1919   if (uspec == NULL)
1920     return NULL;
1921 
1922   uspec-&gt;minimum = minimum;
1923   uspec-&gt;maximum = maximum;
1924   uspec-&gt;default_value = default_value;
1925 
1926   return G_PARAM_SPEC (uspec);
1927 }
1928 
1929 /**
1930  * g_param_spec_int64:
1931  * @name: canonical name of the property specified
1932  * @nick: nick name for the property specified
1933  * @blurb: description of the property specified
1934  * @minimum: minimum value for the property specified
1935  * @maximum: maximum value for the property specified
1936  * @default_value: default value for the property specified
1937  * @flags: flags for the property specified
1938  *
1939  * Creates a new #GParamSpecInt64 instance specifying a %G_TYPE_INT64 property.
1940  *
1941  * See g_param_spec_internal() for details on property names.
1942  *
1943  * Returns: (transfer full): a newly created parameter specification
1944  */
1945 GParamSpec*
1946 g_param_spec_int64 (const gchar *name,
<span class="line-modified">1947         const gchar *nick,</span>
<span class="line-modified">1948         const gchar *blurb,</span>
<span class="line-modified">1949         gint64   minimum,</span>
<span class="line-modified">1950         gint64   maximum,</span>
<span class="line-modified">1951         gint64   default_value,</span>
<span class="line-modified">1952         GParamFlags  flags)</span>
1953 {
1954   GParamSpecInt64 *lspec;
1955 
1956   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
1957 
1958   lspec = g_param_spec_internal (G_TYPE_PARAM_INT64,
<span class="line-modified">1959          name,</span>
<span class="line-modified">1960          nick,</span>
<span class="line-modified">1961          blurb,</span>
<span class="line-modified">1962          flags);</span>
1963   if (lspec == NULL)
1964     return NULL;
1965 
1966   lspec-&gt;minimum = minimum;
1967   lspec-&gt;maximum = maximum;
1968   lspec-&gt;default_value = default_value;
1969 
1970   return G_PARAM_SPEC (lspec);
1971 }
1972 
1973 /**
1974  * g_param_spec_uint64:
1975  * @name: canonical name of the property specified
1976  * @nick: nick name for the property specified
1977  * @blurb: description of the property specified
1978  * @minimum: minimum value for the property specified
1979  * @maximum: maximum value for the property specified
1980  * @default_value: default value for the property specified
1981  * @flags: flags for the property specified
1982  *
1983  * Creates a new #GParamSpecUInt64 instance specifying a %G_TYPE_UINT64
1984  * property.
1985  *
1986  * See g_param_spec_internal() for details on property names.
1987  *
1988  * Returns: (transfer full): a newly created parameter specification
1989  */
1990 GParamSpec*
1991 g_param_spec_uint64 (const gchar *name,
<span class="line-modified">1992          const gchar *nick,</span>
<span class="line-modified">1993          const gchar *blurb,</span>
<span class="line-modified">1994          guint64    minimum,</span>
<span class="line-modified">1995          guint64    maximum,</span>
<span class="line-modified">1996          guint64    default_value,</span>
<span class="line-modified">1997          GParamFlags  flags)</span>
1998 {
1999   GParamSpecUInt64 *uspec;
2000 
2001   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
2002 
2003   uspec = g_param_spec_internal (G_TYPE_PARAM_UINT64,
<span class="line-modified">2004          name,</span>
<span class="line-modified">2005          nick,</span>
<span class="line-modified">2006          blurb,</span>
<span class="line-modified">2007          flags);</span>
2008   if (uspec == NULL)
2009     return NULL;
2010 
2011   uspec-&gt;minimum = minimum;
2012   uspec-&gt;maximum = maximum;
2013   uspec-&gt;default_value = default_value;
2014 
2015   return G_PARAM_SPEC (uspec);
2016 }
2017 
2018 /**
2019  * g_param_spec_unichar:
2020  * @name: canonical name of the property specified
2021  * @nick: nick name for the property specified
2022  * @blurb: description of the property specified
2023  * @default_value: default value for the property specified
2024  * @flags: flags for the property specified
2025  *
2026  * Creates a new #GParamSpecUnichar instance specifying a %G_TYPE_UINT
2027  * property. #GValue structures for this property can be accessed with
2028  * g_value_set_uint() and g_value_get_uint().
2029  *
2030  * See g_param_spec_internal() for details on property names.
2031  *
2032  * Returns: (transfer full): a newly created parameter specification
2033  */
2034 GParamSpec*
2035 g_param_spec_unichar (const gchar *name,
<span class="line-modified">2036           const gchar *nick,</span>
<span class="line-modified">2037           const gchar *blurb,</span>
<span class="line-modified">2038           gunichar     default_value,</span>
<span class="line-modified">2039           GParamFlags  flags)</span>
2040 {
2041   GParamSpecUnichar *uspec;
2042 
2043   uspec = g_param_spec_internal (G_TYPE_PARAM_UNICHAR,
<span class="line-modified">2044          name,</span>
<span class="line-modified">2045          nick,</span>
<span class="line-modified">2046          blurb,</span>
<span class="line-modified">2047          flags);</span>
2048   if (uspec == NULL)
2049     return NULL;
2050 
2051   uspec-&gt;default_value = default_value;
2052 
2053   return G_PARAM_SPEC (uspec);
2054 }
2055 
2056 /**
2057  * g_param_spec_enum:
2058  * @name: canonical name of the property specified
2059  * @nick: nick name for the property specified
2060  * @blurb: description of the property specified
2061  * @enum_type: a #GType derived from %G_TYPE_ENUM
2062  * @default_value: default value for the property specified
2063  * @flags: flags for the property specified
2064  *
2065  * Creates a new #GParamSpecEnum instance specifying a %G_TYPE_ENUM
2066  * property.
2067  *
2068  * See g_param_spec_internal() for details on property names.
2069  *
2070  * Returns: (transfer full): a newly created parameter specification
2071  */
2072 GParamSpec*
2073 g_param_spec_enum (const gchar *name,
<span class="line-modified">2074        const gchar *nick,</span>
<span class="line-modified">2075        const gchar *blurb,</span>
<span class="line-modified">2076        GType  enum_type,</span>
<span class="line-modified">2077        gint   default_value,</span>
<span class="line-modified">2078        GParamFlags  flags)</span>
2079 {
2080   GParamSpecEnum *espec;
2081   GEnumClass *enum_class;
2082 
2083   g_return_val_if_fail (G_TYPE_IS_ENUM (enum_type), NULL);
2084 
2085   enum_class = g_type_class_ref (enum_type);
2086 
2087   g_return_val_if_fail (g_enum_get_value (enum_class, default_value) != NULL, NULL);
2088 
2089   espec = g_param_spec_internal (G_TYPE_PARAM_ENUM,
<span class="line-modified">2090          name,</span>
<span class="line-modified">2091          nick,</span>
<span class="line-modified">2092          blurb,</span>
<span class="line-modified">2093          flags);</span>
2094   if (espec == NULL)
2095     return NULL;
2096 
2097   espec-&gt;enum_class = enum_class;
2098   espec-&gt;default_value = default_value;
2099   G_PARAM_SPEC (espec)-&gt;value_type = enum_type;
2100 
2101   return G_PARAM_SPEC (espec);
2102 }
2103 
2104 /**
2105  * g_param_spec_flags:
2106  * @name: canonical name of the property specified
2107  * @nick: nick name for the property specified
2108  * @blurb: description of the property specified
2109  * @flags_type: a #GType derived from %G_TYPE_FLAGS
2110  * @default_value: default value for the property specified
2111  * @flags: flags for the property specified
2112  *
2113  * Creates a new #GParamSpecFlags instance specifying a %G_TYPE_FLAGS
2114  * property.
2115  *
2116  * See g_param_spec_internal() for details on property names.
2117  *
2118  * Returns: (transfer full): a newly created parameter specification
2119  */
2120 GParamSpec*
2121 g_param_spec_flags (const gchar *name,
<span class="line-modified">2122         const gchar *nick,</span>
<span class="line-modified">2123         const gchar *blurb,</span>
<span class="line-modified">2124         GType  flags_type,</span>
<span class="line-modified">2125         guint  default_value,</span>
<span class="line-modified">2126         GParamFlags  flags)</span>
2127 {
2128   GParamSpecFlags *fspec;
2129   GFlagsClass *flags_class;
2130 
2131   g_return_val_if_fail (G_TYPE_IS_FLAGS (flags_type), NULL);
2132 
2133   flags_class = g_type_class_ref (flags_type);
2134 #ifdef GSTREAMER_LITE
2135   if (flags_class == NULL)
2136       return NULL;
2137 #endif // GSTREAMER_LITE
2138 
2139   g_return_val_if_fail ((default_value &amp; flags_class-&gt;mask) == default_value, NULL);
2140 
2141   fspec = g_param_spec_internal (G_TYPE_PARAM_FLAGS,
<span class="line-modified">2142          name,</span>
<span class="line-modified">2143          nick,</span>
<span class="line-modified">2144          blurb,</span>
<span class="line-modified">2145          flags);</span>
2146   if (fspec == NULL)
2147     return NULL;
2148 
2149   fspec-&gt;flags_class = flags_class;
2150   fspec-&gt;default_value = default_value;
2151   G_PARAM_SPEC (fspec)-&gt;value_type = flags_type;
2152 
2153   return G_PARAM_SPEC (fspec);
2154 }
2155 
2156 /**
2157  * g_param_spec_float:
2158  * @name: canonical name of the property specified
2159  * @nick: nick name for the property specified
2160  * @blurb: description of the property specified
2161  * @minimum: minimum value for the property specified
2162  * @maximum: maximum value for the property specified
2163  * @default_value: default value for the property specified
2164  * @flags: flags for the property specified
2165  *
2166  * Creates a new #GParamSpecFloat instance specifying a %G_TYPE_FLOAT property.
2167  *
2168  * See g_param_spec_internal() for details on property names.
2169  *
2170  * Returns: (transfer full): a newly created parameter specification
2171  */
2172 GParamSpec*
2173 g_param_spec_float (const gchar *name,
<span class="line-modified">2174         const gchar *nick,</span>
<span class="line-modified">2175         const gchar *blurb,</span>
<span class="line-modified">2176         gfloat   minimum,</span>
<span class="line-modified">2177         gfloat   maximum,</span>
<span class="line-modified">2178         gfloat   default_value,</span>
<span class="line-modified">2179         GParamFlags  flags)</span>
2180 {
2181   GParamSpecFloat *fspec;
2182 
2183   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
2184 
2185   fspec = g_param_spec_internal (G_TYPE_PARAM_FLOAT,
<span class="line-modified">2186          name,</span>
<span class="line-modified">2187          nick,</span>
<span class="line-modified">2188          blurb,</span>
<span class="line-modified">2189          flags);</span>
2190   if (fspec == NULL)
2191     return NULL;
2192 
2193   fspec-&gt;minimum = minimum;
2194   fspec-&gt;maximum = maximum;
2195   fspec-&gt;default_value = default_value;
2196 
2197   return G_PARAM_SPEC (fspec);
2198 }
2199 
2200 /**
2201  * g_param_spec_double:
2202  * @name: canonical name of the property specified
2203  * @nick: nick name for the property specified
2204  * @blurb: description of the property specified
2205  * @minimum: minimum value for the property specified
2206  * @maximum: maximum value for the property specified
2207  * @default_value: default value for the property specified
2208  * @flags: flags for the property specified
2209  *
2210  * Creates a new #GParamSpecDouble instance specifying a %G_TYPE_DOUBLE
2211  * property.
2212  *
2213  * See g_param_spec_internal() for details on property names.
2214  *
2215  * Returns: (transfer full): a newly created parameter specification
2216  */
2217 GParamSpec*
2218 g_param_spec_double (const gchar *name,
<span class="line-modified">2219          const gchar *nick,</span>
<span class="line-modified">2220          const gchar *blurb,</span>
<span class="line-modified">2221          gdouble    minimum,</span>
<span class="line-modified">2222          gdouble    maximum,</span>
<span class="line-modified">2223          gdouble    default_value,</span>
<span class="line-modified">2224          GParamFlags  flags)</span>
2225 {
2226   GParamSpecDouble *dspec;
2227 
2228   g_return_val_if_fail (default_value &gt;= minimum &amp;&amp; default_value &lt;= maximum, NULL);
2229 
2230   dspec = g_param_spec_internal (G_TYPE_PARAM_DOUBLE,
<span class="line-modified">2231          name,</span>
<span class="line-modified">2232          nick,</span>
<span class="line-modified">2233          blurb,</span>
<span class="line-modified">2234          flags);</span>
2235   if (dspec == NULL)
2236     return NULL;
2237 
2238   dspec-&gt;minimum = minimum;
2239   dspec-&gt;maximum = maximum;
2240   dspec-&gt;default_value = default_value;
2241 
2242   return G_PARAM_SPEC (dspec);
2243 }
2244 
2245 /**
2246  * g_param_spec_string:
2247  * @name: canonical name of the property specified
2248  * @nick: nick name for the property specified
2249  * @blurb: description of the property specified
2250  * @default_value: (nullable): default value for the property specified
2251  * @flags: flags for the property specified
2252  *
2253  * Creates a new #GParamSpecString instance.
2254  *
2255  * See g_param_spec_internal() for details on property names.
2256  *
2257  * Returns: (transfer full): a newly created parameter specification
2258  */
2259 GParamSpec*
2260 g_param_spec_string (const gchar *name,
<span class="line-modified">2261          const gchar *nick,</span>
<span class="line-modified">2262          const gchar *blurb,</span>
<span class="line-modified">2263          const gchar *default_value,</span>
<span class="line-modified">2264          GParamFlags  flags)</span>
2265 {
2266   GParamSpecString *sspec = g_param_spec_internal (G_TYPE_PARAM_STRING,
<span class="line-modified">2267                name,</span>
<span class="line-modified">2268                nick,</span>
<span class="line-modified">2269                blurb,</span>
<span class="line-modified">2270                flags);</span>
2271   if (sspec == NULL)
2272     return NULL;
2273 
2274   g_free (sspec-&gt;default_value);
2275   sspec-&gt;default_value = g_strdup (default_value);
2276 
2277   return G_PARAM_SPEC (sspec);
2278 }
2279 
2280 /**
2281  * g_param_spec_param:
2282  * @name: canonical name of the property specified
2283  * @nick: nick name for the property specified
2284  * @blurb: description of the property specified
2285  * @param_type: a #GType derived from %G_TYPE_PARAM
2286  * @flags: flags for the property specified
2287  *
2288  * Creates a new #GParamSpecParam instance specifying a %G_TYPE_PARAM
2289  * property.
2290  *
2291  * See g_param_spec_internal() for details on property names.
2292  *
2293  * Returns: (transfer full): a newly created parameter specification
2294  */
2295 GParamSpec*
2296 g_param_spec_param (const gchar *name,
<span class="line-modified">2297         const gchar *nick,</span>
<span class="line-modified">2298         const gchar *blurb,</span>
<span class="line-modified">2299         GType  param_type,</span>
<span class="line-modified">2300         GParamFlags  flags)</span>
2301 {
2302   GParamSpecParam *pspec;
2303 
2304   g_return_val_if_fail (G_TYPE_IS_PARAM (param_type), NULL);
2305 
2306   pspec = g_param_spec_internal (G_TYPE_PARAM_PARAM,
<span class="line-modified">2307          name,</span>
<span class="line-modified">2308          nick,</span>
<span class="line-modified">2309          blurb,</span>
<span class="line-modified">2310          flags);</span>
2311   if (pspec == NULL)
2312     return NULL;
2313 
2314   G_PARAM_SPEC (pspec)-&gt;value_type = param_type;
2315 
2316   return G_PARAM_SPEC (pspec);
2317 }
2318 
2319 /**
2320  * g_param_spec_boxed:
2321  * @name: canonical name of the property specified
2322  * @nick: nick name for the property specified
2323  * @blurb: description of the property specified
2324  * @boxed_type: %G_TYPE_BOXED derived type of this property
2325  * @flags: flags for the property specified
2326  *
2327  * Creates a new #GParamSpecBoxed instance specifying a %G_TYPE_BOXED
2328  * derived property.
2329  *
2330  * See g_param_spec_internal() for details on property names.
2331  *
2332  * Returns: (transfer full): a newly created parameter specification
2333  */
2334 GParamSpec*
2335 g_param_spec_boxed (const gchar *name,
<span class="line-modified">2336         const gchar *nick,</span>
<span class="line-modified">2337         const gchar *blurb,</span>
<span class="line-modified">2338         GType  boxed_type,</span>
<span class="line-modified">2339         GParamFlags  flags)</span>
2340 {
2341   GParamSpecBoxed *bspec;
2342 
2343   g_return_val_if_fail (G_TYPE_IS_BOXED (boxed_type), NULL);
2344   g_return_val_if_fail (G_TYPE_IS_VALUE_TYPE (boxed_type), NULL);
2345 
2346   bspec = g_param_spec_internal (G_TYPE_PARAM_BOXED,
<span class="line-modified">2347          name,</span>
<span class="line-modified">2348          nick,</span>
<span class="line-modified">2349          blurb,</span>
<span class="line-modified">2350          flags);</span>
2351   if (bspec == NULL)
2352     return NULL;
2353 
2354   G_PARAM_SPEC (bspec)-&gt;value_type = boxed_type;
2355 
2356   return G_PARAM_SPEC (bspec);
2357 }
2358 
2359 /**
2360  * g_param_spec_pointer:
2361  * @name: canonical name of the property specified
2362  * @nick: nick name for the property specified
2363  * @blurb: description of the property specified
2364  * @flags: flags for the property specified
2365  *
2366  * Creates a new #GParamSpecPointer instance specifying a pointer property.
2367  * Where possible, it is better to use g_param_spec_object() or
2368  * g_param_spec_boxed() to expose memory management information.
2369  *
2370  * See g_param_spec_internal() for details on property names.
2371  *
2372  * Returns: (transfer full): a newly created parameter specification
2373  */
2374 GParamSpec*
2375 g_param_spec_pointer (const gchar *name,
<span class="line-modified">2376           const gchar *nick,</span>
<span class="line-modified">2377           const gchar *blurb,</span>
<span class="line-modified">2378           GParamFlags  flags)</span>
2379 {
2380   GParamSpecPointer *pspec;
2381 
2382   pspec = g_param_spec_internal (G_TYPE_PARAM_POINTER,
<span class="line-modified">2383          name,</span>
<span class="line-modified">2384          nick,</span>
<span class="line-modified">2385          blurb,</span>
<span class="line-modified">2386          flags);</span>
2387   if (pspec == NULL)
2388     return NULL;
2389 
2390   return G_PARAM_SPEC (pspec);
2391 }
2392 
2393 /**
2394  * g_param_spec_gtype:
2395  * @name: canonical name of the property specified
2396  * @nick: nick name for the property specified
2397  * @blurb: description of the property specified
2398  * @is_a_type: a #GType whose subtypes are allowed as values
2399  *  of the property (use %G_TYPE_NONE for any type)
2400  * @flags: flags for the property specified
2401  *
2402  * Creates a new #GParamSpecGType instance specifying a
2403  * %G_TYPE_GTYPE property.
2404  *
2405  * See g_param_spec_internal() for details on property names.
2406  *
2407  * Since: 2.10
2408  *
2409  * Returns: (transfer full): a newly created parameter specification
2410  */
2411 GParamSpec*
2412 g_param_spec_gtype (const gchar *name,
<span class="line-modified">2413         const gchar *nick,</span>
<span class="line-modified">2414         const gchar *blurb,</span>
<span class="line-modified">2415         GType        is_a_type,</span>
<span class="line-modified">2416         GParamFlags  flags)</span>
2417 {
2418   GParamSpecGType *tspec;
2419 
2420   tspec = g_param_spec_internal (G_TYPE_PARAM_GTYPE,
<span class="line-modified">2421          name,</span>
<span class="line-modified">2422          nick,</span>
<span class="line-modified">2423          blurb,</span>
<span class="line-modified">2424          flags);</span>
2425   if (tspec == NULL)
2426     return NULL;
2427 
2428   tspec-&gt;is_a_type = is_a_type;
2429 
2430   return G_PARAM_SPEC (tspec);
2431 }
2432 
2433 /**
2434  * g_param_spec_value_array: (skip)
2435  * @name: canonical name of the property specified
2436  * @nick: nick name for the property specified
2437  * @blurb: description of the property specified
2438  * @element_spec: a #GParamSpec describing the elements contained in
2439  *  arrays of this property, may be %NULL
2440  * @flags: flags for the property specified
2441  *
2442  * Creates a new #GParamSpecValueArray instance specifying a
2443  * %G_TYPE_VALUE_ARRAY property. %G_TYPE_VALUE_ARRAY is a
2444  * %G_TYPE_BOXED type, as such, #GValue structures for this property
2445  * can be accessed with g_value_set_boxed() and g_value_get_boxed().
2446  *
2447  * See g_param_spec_internal() for details on property names.
2448  *
2449  * Returns: a newly created parameter specification
2450  */
2451 GParamSpec*
2452 g_param_spec_value_array (const gchar *name,
<span class="line-modified">2453         const gchar *nick,</span>
<span class="line-modified">2454         const gchar *blurb,</span>
<span class="line-modified">2455         GParamSpec  *element_spec,</span>
<span class="line-modified">2456         GParamFlags  flags)</span>
2457 {
2458   GParamSpecValueArray *aspec;
2459 
2460   if (element_spec)
2461     g_return_val_if_fail (G_IS_PARAM_SPEC (element_spec), NULL);
2462 
2463   aspec = g_param_spec_internal (G_TYPE_PARAM_VALUE_ARRAY,
<span class="line-modified">2464          name,</span>
<span class="line-modified">2465          nick,</span>
<span class="line-modified">2466          blurb,</span>
<span class="line-modified">2467          flags);</span>
2468   if (aspec == NULL)
2469     return NULL;
2470 
2471   if (element_spec)
2472     {
2473       aspec-&gt;element_spec = g_param_spec_ref (element_spec);
2474       g_param_spec_sink (element_spec);
2475     }
2476 
2477   return G_PARAM_SPEC (aspec);
2478 }
2479 
2480 /**
2481  * g_param_spec_object:
2482  * @name: canonical name of the property specified
2483  * @nick: nick name for the property specified
2484  * @blurb: description of the property specified
2485  * @object_type: %G_TYPE_OBJECT derived type of this property
2486  * @flags: flags for the property specified
2487  *
2488  * Creates a new #GParamSpecBoxed instance specifying a %G_TYPE_OBJECT
2489  * derived property.
2490  *
2491  * See g_param_spec_internal() for details on property names.
2492  *
2493  * Returns: (transfer full): a newly created parameter specification
2494  */
2495 GParamSpec*
2496 g_param_spec_object (const gchar *name,
<span class="line-modified">2497          const gchar *nick,</span>
<span class="line-modified">2498          const gchar *blurb,</span>
<span class="line-modified">2499          GType    object_type,</span>
<span class="line-modified">2500          GParamFlags  flags)</span>
2501 {
2502   GParamSpecObject *ospec;
2503 
2504   g_return_val_if_fail (g_type_is_a (object_type, G_TYPE_OBJECT), NULL);
2505 
2506   ospec = g_param_spec_internal (G_TYPE_PARAM_OBJECT,
<span class="line-modified">2507          name,</span>
<span class="line-modified">2508          nick,</span>
<span class="line-modified">2509          blurb,</span>
<span class="line-modified">2510          flags);</span>
2511   if (ospec == NULL)
2512     return NULL;
2513 
2514   G_PARAM_SPEC (ospec)-&gt;value_type = object_type;
2515 
2516   return G_PARAM_SPEC (ospec);
2517 }
2518 
2519 /**
2520  * g_param_spec_override: (skip)
2521  * @name: the name of the property.
2522  * @overridden: The property that is being overridden
2523  *
2524  * Creates a new property of type #GParamSpecOverride. This is used
2525  * to direct operations to another paramspec, and will not be directly
2526  * useful unless you are implementing a new base type similar to GObject.
2527  *
2528  * Since: 2.4
2529  *
2530  * Returns: the newly created #GParamSpec
2531  */
2532 GParamSpec*
2533 g_param_spec_override (const gchar *name,
<span class="line-modified">2534            GParamSpec  *overridden)</span>
2535 {
2536   GParamSpec *pspec;
2537 
2538   g_return_val_if_fail (name != NULL, NULL);
2539   g_return_val_if_fail (G_IS_PARAM_SPEC (overridden), NULL);
2540 
2541   /* Dereference further redirections for property that was passed in
2542    */
2543   while (TRUE)
2544     {
2545       GParamSpec *indirect = g_param_spec_get_redirect_target (overridden);
2546       if (indirect)
<span class="line-modified">2547   overridden = indirect;</span>
2548       else
<span class="line-modified">2549   break;</span>
2550     }
2551 
2552   pspec = g_param_spec_internal (G_TYPE_PARAM_OVERRIDE,
<span class="line-modified">2553          name, NULL, NULL,</span>
<span class="line-modified">2554          overridden-&gt;flags);</span>
2555   if (pspec == NULL)
2556     return NULL;
2557 
2558   pspec-&gt;value_type = G_PARAM_SPEC_VALUE_TYPE (overridden);
2559   G_PARAM_SPEC_OVERRIDE (pspec)-&gt;overridden = g_param_spec_ref (overridden);
2560 
2561   return pspec;
2562 }
2563 
2564 /**
2565  * g_param_spec_variant:
2566  * @name: canonical name of the property specified
2567  * @nick: nick name for the property specified
2568  * @blurb: description of the property specified
2569  * @type: a #GVariantType
2570  * @default_value: (nullable) (transfer full): a #GVariant of type @type to
2571  *                 use as the default value, or %NULL
2572  * @flags: flags for the property specified
2573  *
2574  * Creates a new #GParamSpecVariant instance specifying a #GVariant
</pre>
</td>
</tr>
</table>
<center><a href="gparam.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="gparamspecs.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>