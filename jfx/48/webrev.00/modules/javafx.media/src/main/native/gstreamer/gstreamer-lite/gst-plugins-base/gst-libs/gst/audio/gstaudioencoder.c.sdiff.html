<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudioencoder.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="gstaudiodecoder.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstaudioencoder.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/audio/gstaudioencoder.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 120  *
 121  */
 122 
 123 #ifdef HAVE_CONFIG_H
 124 #  include &quot;config.h&quot;
 125 #endif
 126 
 127 #include &quot;gstaudioencoder.h&quot;
 128 #include &quot;gstaudioutilsprivate.h&quot;
 129 #include &lt;gst/base/gstadapter.h&gt;
 130 #include &lt;gst/audio/audio.h&gt;
 131 #include &lt;gst/pbutils/descriptions.h&gt;
 132 
 133 #include &lt;stdlib.h&gt;
 134 #include &lt;string.h&gt;
 135 
 136 
 137 GST_DEBUG_CATEGORY_STATIC (gst_audio_encoder_debug);
 138 #define GST_CAT_DEFAULT gst_audio_encoder_debug
 139 
<span class="line-removed"> 140 #define GST_AUDIO_ENCODER_GET_PRIVATE(obj)  \</span>
<span class="line-removed"> 141     (G_TYPE_INSTANCE_GET_PRIVATE ((obj), GST_TYPE_AUDIO_ENCODER, \</span>
<span class="line-removed"> 142         GstAudioEncoderPrivate))</span>
<span class="line-removed"> 143 </span>
 144 enum
 145 {
 146   PROP_0,
 147   PROP_PERFECT_TS,
 148   PROP_GRANULE,
 149   PROP_HARD_RESYNC,
 150   PROP_TOLERANCE
 151 };
 152 
 153 #define DEFAULT_PERFECT_TS   FALSE
 154 #define DEFAULT_GRANULE      FALSE
 155 #define DEFAULT_HARD_RESYNC  FALSE
 156 #define DEFAULT_TOLERANCE    40000000
 157 #define DEFAULT_HARD_MIN     FALSE
 158 #define DEFAULT_DRAINABLE    TRUE
 159 
 160 typedef struct _GstAudioEncoderContext
 161 {
 162   /* input */
 163   /* last negotiated input caps */
</pre>
<hr />
<pre>
 230   gboolean hard_resync;
 231   gboolean granule;
 232   gboolean hard_min;
 233   gboolean drainable;
 234 
 235   /* upstream stream tags (global tags are passed through as-is) */
 236   GstTagList *upstream_tags;
 237 
 238   /* subclass tags */
 239   GstTagList *tags;
 240   GstTagMergeMode tags_merge_mode;
 241 
 242   gboolean tags_changed;
 243 
 244   /* pending serialized sink events, will be sent from finish_frame() */
 245   GList *pending_events;
 246 };
 247 
 248 
 249 static GstElementClass *parent_class = NULL;

 250 
 251 static void gst_audio_encoder_class_init (GstAudioEncoderClass * klass);
 252 static void gst_audio_encoder_init (GstAudioEncoder * parse,
 253     GstAudioEncoderClass * klass);
 254 
 255 GType
 256 gst_audio_encoder_get_type (void)
 257 {
 258   static GType audio_encoder_type = 0;
 259 
 260   if (!audio_encoder_type) {
 261     static const GTypeInfo audio_encoder_info = {
 262       sizeof (GstAudioEncoderClass),
 263       (GBaseInitFunc) NULL,
 264       (GBaseFinalizeFunc) NULL,
 265       (GClassInitFunc) gst_audio_encoder_class_init,
 266       NULL,
 267       NULL,
 268       sizeof (GstAudioEncoder),
 269       0,
 270       (GInstanceInitFunc) gst_audio_encoder_init,
 271     };
 272 #ifndef GSTREAMER_LITE
 273     const GInterfaceInfo preset_interface_info = {
 274       NULL,                     /* interface_init */
 275       NULL,                     /* interface_finalize */
 276       NULL                      /* interface_data */
 277     };
 278 #endif // GSTREAMER_LITE
 279 
 280     audio_encoder_type = g_type_register_static (GST_TYPE_ELEMENT,
 281         &quot;GstAudioEncoder&quot;, &amp;audio_encoder_info, G_TYPE_FLAG_ABSTRACT);
 282 




 283 #ifndef GSTREAMER_LITE
 284     g_type_add_interface_static (audio_encoder_type, GST_TYPE_PRESET,
 285         &amp;preset_interface_info);
 286 #endif // GSTREAMER_LITE
 287   }
 288   return audio_encoder_type;
 289 }
 290 






 291 static void gst_audio_encoder_finalize (GObject * object);
 292 static void gst_audio_encoder_reset (GstAudioEncoder * enc, gboolean full);
 293 
 294 static void gst_audio_encoder_set_property (GObject * object,
 295     guint prop_id, const GValue * value, GParamSpec * pspec);
 296 static void gst_audio_encoder_get_property (GObject * object,
 297     guint prop_id, GValue * value, GParamSpec * pspec);
 298 
 299 static gboolean gst_audio_encoder_sink_activate_mode (GstPad * pad,
 300     GstObject * parent, GstPadMode mode, gboolean active);
 301 
 302 static GstCaps *gst_audio_encoder_getcaps_default (GstAudioEncoder * enc,
 303     GstCaps * filter);
 304 
 305 static gboolean gst_audio_encoder_sink_event_default (GstAudioEncoder * enc,
 306     GstEvent * event);
 307 static gboolean gst_audio_encoder_src_event_default (GstAudioEncoder * enc,
 308     GstEvent * event);
 309 static gboolean gst_audio_encoder_sink_event (GstPad * pad, GstObject * parent,
 310     GstEvent * event);
</pre>
<hr />
<pre>
 332     encoder, GstBuffer * outbuf, GstMeta * meta, GstBuffer * inbuf);
 333 
 334 static gboolean gst_audio_encoder_sink_query_default (GstAudioEncoder * encoder,
 335     GstQuery * query);
 336 static gboolean gst_audio_encoder_src_query_default (GstAudioEncoder * encoder,
 337     GstQuery * query);
 338 
 339 static void
 340 gst_audio_encoder_class_init (GstAudioEncoderClass * klass)
 341 {
 342   GObjectClass *gobject_class;
 343   GstElementClass *gstelement_class;
 344 
 345   gobject_class = G_OBJECT_CLASS (klass);
 346   gstelement_class = GST_ELEMENT_CLASS (klass);
 347   parent_class = g_type_class_peek_parent (klass);
 348 
 349   GST_DEBUG_CATEGORY_INIT (gst_audio_encoder_debug, &quot;audioencoder&quot;, 0,
 350       &quot;audio encoder base class&quot;);
 351 
<span class="line-modified"> 352   g_type_class_add_private (klass, sizeof (GstAudioEncoderPrivate));</span>

 353 
 354   gobject_class-&gt;set_property = gst_audio_encoder_set_property;
 355   gobject_class-&gt;get_property = gst_audio_encoder_get_property;
 356 
 357   gobject_class-&gt;finalize = GST_DEBUG_FUNCPTR (gst_audio_encoder_finalize);
 358 
 359   /* properties */
 360   g_object_class_install_property (gobject_class, PROP_PERFECT_TS,
 361       g_param_spec_boolean (&quot;perfect-timestamp&quot;, &quot;Perfect Timestamps&quot;,
 362           &quot;Favour perfect timestamps over tracking upstream timestamps&quot;,
 363           DEFAULT_PERFECT_TS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 364   g_object_class_install_property (gobject_class, PROP_GRANULE,
 365       g_param_spec_boolean (&quot;mark-granule&quot;, &quot;Granule Marking&quot;,
 366           &quot;Apply granule semantics to buffer metadata (implies perfect-timestamp)&quot;,
 367           DEFAULT_GRANULE, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 368   g_object_class_install_property (gobject_class, PROP_HARD_RESYNC,
 369       g_param_spec_boolean (&quot;hard-resync&quot;, &quot;Hard Resync&quot;,
 370           &quot;Perform clipping and sample flushing upon discontinuity&quot;,
 371           DEFAULT_HARD_RESYNC, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 372   g_object_class_install_property (gobject_class, PROP_TOLERANCE,
</pre>
<hr />
<pre>
 379       GST_DEBUG_FUNCPTR (gst_audio_encoder_change_state);
 380 
 381   klass-&gt;getcaps = gst_audio_encoder_getcaps_default;
 382   klass-&gt;sink_event = gst_audio_encoder_sink_event_default;
 383   klass-&gt;src_event = gst_audio_encoder_src_event_default;
 384   klass-&gt;sink_query = gst_audio_encoder_sink_query_default;
 385   klass-&gt;src_query = gst_audio_encoder_src_query_default;
 386   klass-&gt;propose_allocation = gst_audio_encoder_propose_allocation_default;
 387   klass-&gt;decide_allocation = gst_audio_encoder_decide_allocation_default;
 388   klass-&gt;negotiate = gst_audio_encoder_negotiate_default;
 389   klass-&gt;transform_meta = gst_audio_encoder_transform_meta_default;
 390 }
 391 
 392 static void
 393 gst_audio_encoder_init (GstAudioEncoder * enc, GstAudioEncoderClass * bclass)
 394 {
 395   GstPadTemplate *pad_template;
 396 
 397   GST_DEBUG_OBJECT (enc, &quot;gst_audio_encoder_init&quot;);
 398 
<span class="line-modified"> 399   enc-&gt;priv = GST_AUDIO_ENCODER_GET_PRIVATE (enc);</span>
 400 
 401   /* only push mode supported */
 402   pad_template =
 403       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;sink&quot;);
 404   g_return_if_fail (pad_template != NULL);
 405   enc-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 406   gst_pad_set_event_function (enc-&gt;sinkpad,
 407       GST_DEBUG_FUNCPTR (gst_audio_encoder_sink_event));
 408   gst_pad_set_query_function (enc-&gt;sinkpad,
 409       GST_DEBUG_FUNCPTR (gst_audio_encoder_sink_query));
 410   gst_pad_set_chain_function (enc-&gt;sinkpad,
 411       GST_DEBUG_FUNCPTR (gst_audio_encoder_chain));
 412   gst_pad_set_activatemode_function (enc-&gt;sinkpad,
 413       GST_DEBUG_FUNCPTR (gst_audio_encoder_sink_activate_mode));
 414   gst_element_add_pad (GST_ELEMENT (enc), enc-&gt;sinkpad);
 415 
 416   GST_DEBUG_OBJECT (enc, &quot;sinkpad created&quot;);
 417 
 418   /* and we don&#39;t mind upstream traveling stuff that much ... */
 419   pad_template =
</pre>
<hr />
<pre>
 611   GstTagList *merged_tags;
 612 
 613   GST_LOG_OBJECT (enc, &quot;upstream : %&quot; GST_PTR_FORMAT, enc-&gt;priv-&gt;upstream_tags);
 614   GST_LOG_OBJECT (enc, &quot;encoder  : %&quot; GST_PTR_FORMAT, enc-&gt;priv-&gt;tags);
 615   GST_LOG_OBJECT (enc, &quot;mode     : %d&quot;, enc-&gt;priv-&gt;tags_merge_mode);
 616 
 617   merged_tags =
 618       gst_tag_list_merge (enc-&gt;priv-&gt;upstream_tags, enc-&gt;priv-&gt;tags,
 619       enc-&gt;priv-&gt;tags_merge_mode);
 620 
 621   GST_DEBUG_OBJECT (enc, &quot;merged   : %&quot; GST_PTR_FORMAT, merged_tags);
 622 
 623   if (merged_tags == NULL)
 624     return NULL;
 625 
 626   if (gst_tag_list_is_empty (merged_tags)) {
 627     gst_tag_list_unref (merged_tags);
 628     return NULL;
 629   }
 630 
<span class="line-modified"> 631     /* add codec info to pending tags */</span>
 632 #if 0
<span class="line-modified"> 633     caps = gst_pad_get_current_caps (enc-&gt;srcpad);</span>
 634   gst_pb_utils_add_codec_description_to_tag_list (merged_tags,
<span class="line-modified"> 635         GST_TAG_AUDIO_CODEC, caps);</span>
 636 #endif
 637 
 638   return gst_event_new_tag (merged_tags);
 639 }
 640 
 641 static void
 642 gst_audio_encoder_check_and_push_pending_tags (GstAudioEncoder * enc)
 643 {
 644   if (enc-&gt;priv-&gt;tags_changed) {
 645     GstEvent *tags_event;
 646 
 647     tags_event = gst_audio_encoder_create_merged_tags_event (enc);
 648 
 649     if (tags_event != NULL)
 650       gst_audio_encoder_push_event (enc, tags_event);
 651 
 652     enc-&gt;priv-&gt;tags_changed = FALSE;
 653   }
 654 }
 655 
</pre>
<hr />
<pre>
 707     info-&gt;transform_func (outbuf, *meta, inbuf,
 708         _gst_meta_transform_copy, &amp;copy_data);
 709   }
 710   return TRUE;
 711 }
 712 
 713 /**
 714  * gst_audio_encoder_finish_frame:
 715  * @enc: a #GstAudioEncoder
 716  * @buffer: encoded data
 717  * @samples: number of samples (per channel) represented by encoded data
 718  *
 719  * Collects encoded data and pushes encoded data downstream.
 720  * Source pad caps must be set when this is called.
 721  *
 722  * If @samples &lt; 0, then best estimate is all samples provided to encoder
 723  * (subclass) so far.  @buf may be NULL, in which case next number of @samples
 724  * are considered discarded, e.g. as a result of discontinuous transmission,
 725  * and a discontinuity is marked.
 726  *
<span class="line-modified"> 727  * Note that samples received in gst_audio_encoder_handle_frame()</span>
 728  * may be invalidated by a call to this function.
 729  *
 730  * Returns: a #GstFlowReturn that should be escalated to caller (of caller)
 731  */
 732 GstFlowReturn
 733 gst_audio_encoder_finish_frame (GstAudioEncoder * enc, GstBuffer * buf,
 734     gint samples)
 735 {
 736   GstAudioEncoderClass *klass;
 737   GstAudioEncoderPrivate *priv;
 738   GstAudioEncoderContext *ctx;
 739   GstFlowReturn ret = GST_FLOW_OK;
 740   gboolean needs_reconfigure = FALSE;
 741   GstBuffer *inbuf = NULL;
 742 
 743   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
 744   priv = enc-&gt;priv;
 745   ctx = &amp;enc-&gt;priv-&gt;ctx;
 746 
 747   /* subclass should not hand us no data */
</pre>
<hr />
<pre>
 827           GST_LOG_OBJECT (enc, &quot;new upstream ts only introduces jitter&quot;);
 828         }
 829       }
 830     }
 831     /* advance sample view */
 832     if (G_UNLIKELY (samples * ctx-&gt;info.bpf &gt; priv-&gt;offset)) {
 833       guint avail = gst_adapter_available (priv-&gt;adapter);
 834 
 835       if (G_LIKELY (!priv-&gt;force)) {
 836         /* we should have received EOS to enable force */
 837         goto overflow;
 838       } else {
 839         priv-&gt;offset = 0;
 840         if (avail &gt; 0 &amp;&amp; samples * ctx-&gt;info.bpf &gt;= avail) {
 841           inbuf = gst_adapter_take_buffer_fast (priv-&gt;adapter, avail);
 842           gst_adapter_clear (priv-&gt;adapter);
 843         } else if (avail &gt; 0) {
 844           inbuf =
 845               gst_adapter_take_buffer_fast (priv-&gt;adapter,
 846               samples * ctx-&gt;info.bpf);
<span class="line-modified"> 847       }</span>
 848       }
 849     } else {
 850       guint avail = gst_adapter_available (priv-&gt;adapter);
 851 
 852       if (avail &gt; 0) {
 853         inbuf =
 854             gst_adapter_take_buffer_fast (priv-&gt;adapter,
 855             samples * ctx-&gt;info.bpf);
 856       }
 857       priv-&gt;offset -= samples * ctx-&gt;info.bpf;
 858       /* avoid subsequent stray prev_ts */
 859       if (G_UNLIKELY (gst_adapter_available (priv-&gt;adapter) == 0))
 860         gst_adapter_clear (priv-&gt;adapter);
 861     }
 862     /* sample count advanced below after buffer handling */
 863   }
 864 
 865   /* collect output */
 866   if (G_LIKELY (buf)) {
 867     gsize size;
</pre>
<hr />
<pre>
 886 
 887         /* Ogg codecs like Vorbis use offset/offset-end in a special
 888          * way and both should be 0 for these codecs */
 889         if (priv-&gt;base_gp &gt;= 0) {
 890           GST_BUFFER_OFFSET (tmpbuf) = 0;
 891           GST_BUFFER_OFFSET_END (tmpbuf) = 0;
 892         } else {
 893           GST_BUFFER_OFFSET (tmpbuf) = priv-&gt;bytes_out;
 894           GST_BUFFER_OFFSET_END (tmpbuf) = priv-&gt;bytes_out + size;
 895         }
 896 
 897         GST_OBJECT_LOCK (enc);
 898         priv-&gt;bytes_out += size;
 899         GST_OBJECT_UNLOCK (enc);
 900 
 901         ret = gst_pad_push (enc-&gt;srcpad, tmpbuf);
 902         if (ret != GST_FLOW_OK) {
 903           GST_WARNING_OBJECT (enc, &quot;pushing header returned %s&quot;,
 904               gst_flow_get_name (ret));
 905           goto exit;
<span class="line-modified"> 906       }</span>
 907       }
 908       priv-&gt;ctx.new_headers = FALSE;
 909     }
 910 
 911     size = gst_buffer_get_size (buf);
 912 
 913     GST_LOG_OBJECT (enc, &quot;taking %&quot; G_GSIZE_FORMAT &quot; bytes for output&quot;, size);
 914     buf = gst_buffer_make_writable (buf);
 915 
 916     /* decorate */
 917     if (G_LIKELY (GST_CLOCK_TIME_IS_VALID (priv-&gt;base_ts))) {
 918       /* FIXME ? lookahead could lead to weird ts and duration ?
 919        * (particularly if not in perfect mode) */
 920       /* mind sample rounding and produce perfect output */
 921       GST_BUFFER_TIMESTAMP (buf) = priv-&gt;base_ts +
 922           gst_util_uint64_scale (priv-&gt;samples - ctx-&gt;lookahead, GST_SECOND,
 923           ctx-&gt;info.rate);
 924       GST_BUFFER_DTS (buf) = GST_BUFFER_TIMESTAMP (buf);
 925       GST_DEBUG_OBJECT (enc, &quot;out samples %d&quot;, samples);
 926       if (G_LIKELY (samples &gt; 0)) {
</pre>
<hr />
<pre>
1367     gst_buffer_unref (buffer);
1368     ret = GST_FLOW_NOT_NEGOTIATED;
1369     goto done;
1370   }
1371 wrong_buffer:
1372   {
1373     GST_ELEMENT_ERROR (enc, STREAM, ENCODE, (NULL),
1374         (&quot;buffer size %&quot; G_GSIZE_FORMAT &quot; not a multiple of %d&quot;,
1375             gst_buffer_get_size (buffer), ctx-&gt;info.bpf));
1376     gst_buffer_unref (buffer);
1377     ret = GST_FLOW_ERROR;
1378     goto done;
1379   }
1380 wrong_time:
1381   {
1382     GST_ELEMENT_ERROR (enc, STREAM, ENCODE, (NULL),
1383         (&quot;buffer going too far back in time&quot;));
1384     gst_buffer_unref (buffer);
1385     ret = GST_FLOW_ERROR;
1386     goto done;
<span class="line-modified">1387 }</span>
1388 }
1389 
1390 static gboolean
1391 gst_audio_encoder_sink_setcaps (GstAudioEncoder * enc, GstCaps * caps)
1392 {
1393   GstAudioEncoderClass *klass;
1394   GstAudioEncoderContext *ctx;
1395   GstAudioInfo state;
1396   gboolean res = TRUE;
1397   guint old_rate;
1398 
1399   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
1400 
1401   /* subclass must do something here ... */
1402   g_return_val_if_fail (klass-&gt;set_format != NULL, FALSE);
1403 
1404   ctx = &amp;enc-&gt;priv-&gt;ctx;
1405 
1406   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1407 
</pre>
<hr />
<pre>
1477 
1478 /**
1479  * gst_audio_encoder_proxy_getcaps:
1480  * @enc: a #GstAudioEncoder
1481  * @caps: (allow-none): initial caps
1482  * @filter: (allow-none): filter caps
1483  *
1484  * Returns caps that express @caps (or sink template caps if @caps == NULL)
1485  * restricted to channel/rate combinations supported by downstream elements
1486  * (e.g. muxers).
1487  *
1488  * Returns: (transfer full): a #GstCaps owned by caller
1489  */
1490 GstCaps *
1491 gst_audio_encoder_proxy_getcaps (GstAudioEncoder * enc, GstCaps * caps,
1492     GstCaps * filter)
1493 {
1494   return __gst_audio_element_proxy_getcaps (GST_ELEMENT_CAST (enc),
1495       GST_AUDIO_ENCODER_SINK_PAD (enc), GST_AUDIO_ENCODER_SRC_PAD (enc),
1496       caps, filter);
<span class="line-modified">1497   }</span>
1498 
1499 static GstCaps *
1500 gst_audio_encoder_getcaps_default (GstAudioEncoder * enc, GstCaps * filter)
1501 {
1502   GstCaps *caps;
1503 
1504   caps = gst_audio_encoder_proxy_getcaps (enc, NULL, filter);
1505   GST_LOG_OBJECT (enc, &quot;returning caps %&quot; GST_PTR_FORMAT, caps);
1506 
1507   return caps;
1508 }
1509 
1510 static GList *
1511 _flush_events (GstPad * pad, GList * events)
1512 {
1513   GList *tmp;
1514 
1515   for (tmp = events; tmp; tmp = tmp-&gt;next) {
1516     if (GST_EVENT_TYPE (tmp-&gt;data) != GST_EVENT_EOS &amp;&amp;
1517         GST_EVENT_TYPE (tmp-&gt;data) != GST_EVENT_SEGMENT &amp;&amp;
</pre>
<hr />
<pre>
1620       GST_DEBUG_OBJECT (enc, &quot;received STREAM_START. Clearing taglist&quot;);
1621       if (enc-&gt;priv-&gt;upstream_tags) {
1622         gst_tag_list_unref (enc-&gt;priv-&gt;upstream_tags);
1623         enc-&gt;priv-&gt;upstream_tags = NULL;
1624         enc-&gt;priv-&gt;tags_changed = TRUE;
1625       }
1626       GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1627       res = gst_audio_encoder_push_event (enc, event);
1628       break;
1629     }
1630 
1631     case GST_EVENT_TAG:
1632     {
1633       GstTagList *tags;
1634 
1635       gst_event_parse_tag (event, &amp;tags);
1636 
1637       if (gst_tag_list_get_scope (tags) == GST_TAG_SCOPE_STREAM) {
1638         GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1639         if (enc-&gt;priv-&gt;upstream_tags != tags) {
<span class="line-modified">1640         tags = gst_tag_list_copy (tags);</span>
<span class="line-modified">1641 </span>
<span class="line-modified">1642         /* FIXME: make generic based on GST_TAG_FLAG_ENCODED */</span>
<span class="line-modified">1643         gst_tag_list_remove_tag (tags, GST_TAG_CODEC);</span>
<span class="line-modified">1644         gst_tag_list_remove_tag (tags, GST_TAG_AUDIO_CODEC);</span>
<span class="line-modified">1645         gst_tag_list_remove_tag (tags, GST_TAG_VIDEO_CODEC);</span>
<span class="line-modified">1646         gst_tag_list_remove_tag (tags, GST_TAG_SUBTITLE_CODEC);</span>
<span class="line-modified">1647         gst_tag_list_remove_tag (tags, GST_TAG_CONTAINER_FORMAT);</span>
<span class="line-modified">1648         gst_tag_list_remove_tag (tags, GST_TAG_BITRATE);</span>
<span class="line-modified">1649         gst_tag_list_remove_tag (tags, GST_TAG_NOMINAL_BITRATE);</span>
<span class="line-modified">1650         gst_tag_list_remove_tag (tags, GST_TAG_MAXIMUM_BITRATE);</span>
<span class="line-modified">1651         gst_tag_list_remove_tag (tags, GST_TAG_MINIMUM_BITRATE);</span>
<span class="line-modified">1652         gst_tag_list_remove_tag (tags, GST_TAG_ENCODER);</span>
<span class="line-modified">1653         gst_tag_list_remove_tag (tags, GST_TAG_ENCODER_VERSION);</span>
1654 
1655           if (enc-&gt;priv-&gt;upstream_tags)
1656             gst_tag_list_unref (enc-&gt;priv-&gt;upstream_tags);
1657           enc-&gt;priv-&gt;upstream_tags = tags;
1658           GST_INFO_OBJECT (enc, &quot;upstream stream tags: %&quot; GST_PTR_FORMAT, tags);
1659         }
1660         gst_event_unref (event);
1661         event = gst_audio_encoder_create_merged_tags_event (enc);
1662         GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1663 
1664         /* No tags, go out of here instead of fall through */
1665         if (!event) {
<span class="line-modified">1666         res = TRUE;</span>
<span class="line-modified">1667         break;</span>
<span class="line-modified">1668       }</span>
1669       }
1670       /* fall through */
1671     }
1672     default:
1673       /* Forward non-serialized events immediately. */
1674       if (!GST_EVENT_IS_SERIALIZED (event)) {
1675         res =
1676             gst_pad_event_default (enc-&gt;sinkpad, GST_OBJECT_CAST (enc), event);
1677       } else {
1678         GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1679         enc-&gt;priv-&gt;pending_events =
1680             g_list_append (enc-&gt;priv-&gt;pending_events, event);
1681         GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1682         res = TRUE;
1683       }
1684       break;
1685   }
1686   return res;
1687 }
1688 
</pre>
<hr />
<pre>
1938               gst_pad_peer_query_convert (enc-&gt;sinkpad, fmt, dur, req_fmt,
1939                   &amp;val))) {
1940         gst_query_set_duration (query, req_fmt, val);
1941       }
1942       break;
1943     }
1944     case GST_QUERY_FORMATS:
1945     {
1946       gst_query_set_formats (query, 2, GST_FORMAT_TIME, GST_FORMAT_BYTES);
1947       res = TRUE;
1948       break;
1949     }
1950     case GST_QUERY_CONVERT:
1951     {
1952       GstFormat src_fmt, dest_fmt;
1953       gint64 src_val, dest_val;
1954 
1955       gst_query_parse_convert (query, &amp;src_fmt, &amp;src_val, &amp;dest_fmt, &amp;dest_val);
1956       GST_OBJECT_LOCK (enc);
1957       res = __gst_audio_encoded_audio_convert (&amp;enc-&gt;priv-&gt;ctx.info,
<span class="line-modified">1958                   enc-&gt;priv-&gt;bytes_out, enc-&gt;priv-&gt;samples_in, src_fmt, src_val,</span>
1959           &amp;dest_fmt, &amp;dest_val);
1960       GST_OBJECT_UNLOCK (enc);
1961       if (!res)
1962         break;
1963       gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
1964       break;
1965     }
1966     case GST_QUERY_LATENCY:
1967     {
1968       if ((res = gst_pad_peer_query (enc-&gt;sinkpad, query))) {
1969         gboolean live;
1970         GstClockTime min_latency, max_latency;
1971 
1972         gst_query_parse_latency (query, &amp;live, &amp;min_latency, &amp;max_latency);
1973         GST_DEBUG_OBJECT (enc, &quot;Peer latency: live %d, min %&quot;
1974             GST_TIME_FORMAT &quot; max %&quot; GST_TIME_FORMAT, live,
1975             GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
1976 
1977         GST_OBJECT_LOCK (enc);
1978         /* add our latency */
<span class="line-modified">1979           min_latency += enc-&gt;priv-&gt;ctx.min_latency;</span>
1980         if (max_latency == -1 || enc-&gt;priv-&gt;ctx.max_latency == -1)
1981           max_latency = -1;
1982         else
1983           max_latency += enc-&gt;priv-&gt;ctx.max_latency;
1984         GST_OBJECT_UNLOCK (enc);
1985 
1986         gst_query_set_latency (query, live, min_latency, max_latency);
1987       }
1988       break;
1989     }
1990     default:
1991       res = gst_pad_query_default (pad, GST_OBJECT (enc), query);
1992       break;
1993   }
1994 
1995   return res;
1996 }
1997 
1998 static gboolean
1999 gst_audio_encoder_src_query (GstPad * pad, GstObject * parent, GstQuery * query)
</pre>
<hr />
<pre>
2135 GstAudioInfo *
2136 gst_audio_encoder_get_audio_info (GstAudioEncoder * enc)
2137 {
2138   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), NULL);
2139 
2140   return &amp;enc-&gt;priv-&gt;ctx.info;
2141 }
2142 
2143 /**
2144  * gst_audio_encoder_set_frame_samples_min:
2145  * @enc: a #GstAudioEncoder
2146  * @num: number of samples per frame
2147  *
2148  * Sets number of samples (per channel) subclass needs to be handed,
2149  * at least or will be handed all available if 0.
2150  *
2151  * If an exact number of samples is required, gst_audio_encoder_set_frame_samples_max()
2152  * must be called with the same number.
2153  *
2154  * Note: This value will be reset to 0 every time before
<span class="line-modified">2155  * GstAudioEncoder::set_format() is called.</span>
2156  */
2157 void
2158 gst_audio_encoder_set_frame_samples_min (GstAudioEncoder * enc, gint num)
2159 {
2160   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2161 
2162   enc-&gt;priv-&gt;ctx.frame_samples_min = num;
2163   GST_LOG_OBJECT (enc, &quot;set to %d&quot;, num);
2164 }
2165 
2166 /**
2167  * gst_audio_encoder_get_frame_samples_min:
2168  * @enc: a #GstAudioEncoder
2169  *
2170  * Returns: currently minimum requested samples per frame
2171  */
2172 gint
2173 gst_audio_encoder_get_frame_samples_min (GstAudioEncoder * enc)
2174 {
2175   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2176 
2177   return enc-&gt;priv-&gt;ctx.frame_samples_min;
2178 }
2179 
2180 /**
2181  * gst_audio_encoder_set_frame_samples_max:
2182  * @enc: a #GstAudioEncoder
2183  * @num: number of samples per frame
2184  *
2185  * Sets number of samples (per channel) subclass needs to be handed,
2186  * at most or will be handed all available if 0.
2187  *
2188  * If an exact number of samples is required, gst_audio_encoder_set_frame_samples_min()
2189  * must be called with the same number.
2190  *
2191  * Note: This value will be reset to 0 every time before
<span class="line-modified">2192  * GstAudioEncoder::set_format() is called.</span>
2193  */
2194 void
2195 gst_audio_encoder_set_frame_samples_max (GstAudioEncoder * enc, gint num)
2196 {
2197   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2198 
2199   enc-&gt;priv-&gt;ctx.frame_samples_max = num;
2200   GST_LOG_OBJECT (enc, &quot;set to %d&quot;, num);
2201 }
2202 
2203 /**
2204  * gst_audio_encoder_get_frame_samples_max:
2205  * @enc: a #GstAudioEncoder
2206  *
2207  * Returns: currently maximum requested samples per frame
2208  */
2209 gint
2210 gst_audio_encoder_get_frame_samples_max (GstAudioEncoder * enc)
2211 {
2212   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2213 
2214   return enc-&gt;priv-&gt;ctx.frame_samples_max;
2215 }
2216 
2217 /**
2218  * gst_audio_encoder_set_frame_max:
2219  * @enc: a #GstAudioEncoder
2220  * @num: number of frames
2221  *
2222  * Sets max number of frames accepted at once (assumed minimally 1).
2223  * Requires @frame_samples_min and @frame_samples_max to be the equal.
2224  *
2225  * Note: This value will be reset to 0 every time before
<span class="line-modified">2226  * GstAudioEncoder::set_format() is called.</span>
2227  */
2228 void
2229 gst_audio_encoder_set_frame_max (GstAudioEncoder * enc, gint num)
2230 {
2231   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2232 
2233   enc-&gt;priv-&gt;ctx.frame_max = num;
2234   GST_LOG_OBJECT (enc, &quot;set to %d&quot;, num);
2235 }
2236 
2237 /**
2238  * gst_audio_encoder_get_frame_max:
2239  * @enc: a #GstAudioEncoder
2240  *
2241  * Returns: currently configured maximum handled frames
2242  */
2243 gint
2244 gst_audio_encoder_get_frame_max (GstAudioEncoder * enc)
2245 {
2246   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2247 
2248   return enc-&gt;priv-&gt;ctx.frame_max;
2249 }
2250 
2251 /**
2252  * gst_audio_encoder_set_lookahead:
2253  * @enc: a #GstAudioEncoder
2254  * @num: lookahead
2255  *
2256  * Sets encoder lookahead (in units of input rate samples)
2257  *
2258  * Note: This value will be reset to 0 every time before
<span class="line-modified">2259  * GstAudioEncoder::set_format() is called.</span>
2260  */
2261 void
2262 gst_audio_encoder_set_lookahead (GstAudioEncoder * enc, gint num)
2263 {
2264   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2265 
2266   enc-&gt;priv-&gt;ctx.lookahead = num;
2267   GST_LOG_OBJECT (enc, &quot;set to %d&quot;, num);
2268 }
2269 
2270 /**
2271  * gst_audio_encoder_get_lookahead:
2272  * @enc: a #GstAudioEncoder
2273  *
2274  * Returns: currently configured encoder lookahead
2275  */
2276 gint
2277 gst_audio_encoder_get_lookahead (GstAudioEncoder * enc)
2278 {
2279   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
</pre>
<hr />
<pre>
2668 gst_audio_encoder_merge_tags (GstAudioEncoder * enc,
2669     const GstTagList * tags, GstTagMergeMode mode)
2670 {
2671   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2672   g_return_if_fail (tags == NULL || GST_IS_TAG_LIST (tags));
2673   g_return_if_fail (tags == NULL || mode != GST_TAG_MERGE_UNDEFINED);
2674 
2675   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
2676   if (enc-&gt;priv-&gt;tags != tags) {
2677     if (enc-&gt;priv-&gt;tags) {
2678       gst_tag_list_unref (enc-&gt;priv-&gt;tags);
2679       enc-&gt;priv-&gt;tags = NULL;
2680       enc-&gt;priv-&gt;tags_merge_mode = GST_TAG_MERGE_APPEND;
2681     }
2682     if (tags) {
2683       enc-&gt;priv-&gt;tags = gst_tag_list_ref ((GstTagList *) tags);
2684       enc-&gt;priv-&gt;tags_merge_mode = mode;
2685     }
2686 
2687     GST_DEBUG_OBJECT (enc, &quot;setting encoder tags to %&quot; GST_PTR_FORMAT, tags);
<span class="line-modified">2688   enc-&gt;priv-&gt;tags_changed = TRUE;</span>
2689   }
2690   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
2691 }
2692 
2693 static gboolean
2694 gst_audio_encoder_negotiate_default (GstAudioEncoder * enc)
2695 {
2696   GstAudioEncoderClass *klass;
2697   gboolean res = TRUE;
2698   GstQuery *query = NULL;
2699   GstAllocator *allocator;
2700   GstAllocationParams params;
2701   GstCaps *caps, *prevcaps;
2702 
2703   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), FALSE);
2704   g_return_val_if_fail (GST_IS_CAPS (enc-&gt;priv-&gt;ctx.caps), FALSE);
2705 
2706   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
2707 
2708   caps = enc-&gt;priv-&gt;ctx.caps;
</pre>
<hr />
<pre>
2914     goto fallback;
2915   }
2916 
2917   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
2918 
2919   return buffer;
2920 
2921 fallback:
2922   buffer = gst_buffer_new_allocate (NULL, size, NULL);
2923   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
2924 
2925   return buffer;
2926 }
2927 
2928 /**
2929  * gst_audio_encoder_get_allocator:
2930  * @enc: a #GstAudioEncoder
2931  * @allocator: (out) (allow-none) (transfer full): the #GstAllocator
2932  * used
2933  * @params: (out) (allow-none) (transfer full): the
<span class="line-modified">2934  * #GstAllocatorParams of @allocator</span>
2935  *
2936  * Lets #GstAudioEncoder sub-classes to know the memory @allocator
2937  * used by the base class and its @params.
2938  *
2939  * Unref the @allocator after use it.
2940  */
2941 void
2942 gst_audio_encoder_get_allocator (GstAudioEncoder * enc,
2943     GstAllocator ** allocator, GstAllocationParams * params)
2944 {
2945   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2946 
2947   if (allocator)
2948     *allocator = enc-&gt;priv-&gt;ctx.allocator ?
2949         gst_object_ref (enc-&gt;priv-&gt;ctx.allocator) : NULL;
2950 
2951   if (params)
2952     *params = enc-&gt;priv-&gt;ctx.params;
2953 }
</pre>
</td>
<td>
<hr />
<pre>
 120  *
 121  */
 122 
 123 #ifdef HAVE_CONFIG_H
 124 #  include &quot;config.h&quot;
 125 #endif
 126 
 127 #include &quot;gstaudioencoder.h&quot;
 128 #include &quot;gstaudioutilsprivate.h&quot;
 129 #include &lt;gst/base/gstadapter.h&gt;
 130 #include &lt;gst/audio/audio.h&gt;
 131 #include &lt;gst/pbutils/descriptions.h&gt;
 132 
 133 #include &lt;stdlib.h&gt;
 134 #include &lt;string.h&gt;
 135 
 136 
 137 GST_DEBUG_CATEGORY_STATIC (gst_audio_encoder_debug);
 138 #define GST_CAT_DEFAULT gst_audio_encoder_debug
 139 




 140 enum
 141 {
 142   PROP_0,
 143   PROP_PERFECT_TS,
 144   PROP_GRANULE,
 145   PROP_HARD_RESYNC,
 146   PROP_TOLERANCE
 147 };
 148 
 149 #define DEFAULT_PERFECT_TS   FALSE
 150 #define DEFAULT_GRANULE      FALSE
 151 #define DEFAULT_HARD_RESYNC  FALSE
 152 #define DEFAULT_TOLERANCE    40000000
 153 #define DEFAULT_HARD_MIN     FALSE
 154 #define DEFAULT_DRAINABLE    TRUE
 155 
 156 typedef struct _GstAudioEncoderContext
 157 {
 158   /* input */
 159   /* last negotiated input caps */
</pre>
<hr />
<pre>
 226   gboolean hard_resync;
 227   gboolean granule;
 228   gboolean hard_min;
 229   gboolean drainable;
 230 
 231   /* upstream stream tags (global tags are passed through as-is) */
 232   GstTagList *upstream_tags;
 233 
 234   /* subclass tags */
 235   GstTagList *tags;
 236   GstTagMergeMode tags_merge_mode;
 237 
 238   gboolean tags_changed;
 239 
 240   /* pending serialized sink events, will be sent from finish_frame() */
 241   GList *pending_events;
 242 };
 243 
 244 
 245 static GstElementClass *parent_class = NULL;
<span class="line-added"> 246 static gint private_offset = 0;</span>
 247 
 248 static void gst_audio_encoder_class_init (GstAudioEncoderClass * klass);
 249 static void gst_audio_encoder_init (GstAudioEncoder * parse,
 250     GstAudioEncoderClass * klass);
 251 
 252 GType
 253 gst_audio_encoder_get_type (void)
 254 {
 255   static GType audio_encoder_type = 0;
 256 
 257   if (!audio_encoder_type) {
 258     static const GTypeInfo audio_encoder_info = {
 259       sizeof (GstAudioEncoderClass),
 260       (GBaseInitFunc) NULL,
 261       (GBaseFinalizeFunc) NULL,
 262       (GClassInitFunc) gst_audio_encoder_class_init,
 263       NULL,
 264       NULL,
 265       sizeof (GstAudioEncoder),
 266       0,
 267       (GInstanceInitFunc) gst_audio_encoder_init,
 268     };
 269 #ifndef GSTREAMER_LITE
 270     const GInterfaceInfo preset_interface_info = {
 271       NULL,                     /* interface_init */
 272       NULL,                     /* interface_finalize */
 273       NULL                      /* interface_data */
 274     };
 275 #endif // GSTREAMER_LITE
 276 
 277     audio_encoder_type = g_type_register_static (GST_TYPE_ELEMENT,
 278         &quot;GstAudioEncoder&quot;, &amp;audio_encoder_info, G_TYPE_FLAG_ABSTRACT);
 279 
<span class="line-added"> 280     private_offset =</span>
<span class="line-added"> 281         g_type_add_instance_private (audio_encoder_type,</span>
<span class="line-added"> 282         sizeof (GstAudioEncoderPrivate));</span>
<span class="line-added"> 283 </span>
 284 #ifndef GSTREAMER_LITE
 285     g_type_add_interface_static (audio_encoder_type, GST_TYPE_PRESET,
 286         &amp;preset_interface_info);
 287 #endif // GSTREAMER_LITE
 288   }
 289   return audio_encoder_type;
 290 }
 291 
<span class="line-added"> 292 static inline GstAudioEncoderPrivate *</span>
<span class="line-added"> 293 gst_audio_encoder_get_instance_private (GstAudioEncoder * self)</span>
<span class="line-added"> 294 {</span>
<span class="line-added"> 295   return (G_STRUCT_MEMBER_P (self, private_offset));</span>
<span class="line-added"> 296 }</span>
<span class="line-added"> 297 </span>
 298 static void gst_audio_encoder_finalize (GObject * object);
 299 static void gst_audio_encoder_reset (GstAudioEncoder * enc, gboolean full);
 300 
 301 static void gst_audio_encoder_set_property (GObject * object,
 302     guint prop_id, const GValue * value, GParamSpec * pspec);
 303 static void gst_audio_encoder_get_property (GObject * object,
 304     guint prop_id, GValue * value, GParamSpec * pspec);
 305 
 306 static gboolean gst_audio_encoder_sink_activate_mode (GstPad * pad,
 307     GstObject * parent, GstPadMode mode, gboolean active);
 308 
 309 static GstCaps *gst_audio_encoder_getcaps_default (GstAudioEncoder * enc,
 310     GstCaps * filter);
 311 
 312 static gboolean gst_audio_encoder_sink_event_default (GstAudioEncoder * enc,
 313     GstEvent * event);
 314 static gboolean gst_audio_encoder_src_event_default (GstAudioEncoder * enc,
 315     GstEvent * event);
 316 static gboolean gst_audio_encoder_sink_event (GstPad * pad, GstObject * parent,
 317     GstEvent * event);
</pre>
<hr />
<pre>
 339     encoder, GstBuffer * outbuf, GstMeta * meta, GstBuffer * inbuf);
 340 
 341 static gboolean gst_audio_encoder_sink_query_default (GstAudioEncoder * encoder,
 342     GstQuery * query);
 343 static gboolean gst_audio_encoder_src_query_default (GstAudioEncoder * encoder,
 344     GstQuery * query);
 345 
 346 static void
 347 gst_audio_encoder_class_init (GstAudioEncoderClass * klass)
 348 {
 349   GObjectClass *gobject_class;
 350   GstElementClass *gstelement_class;
 351 
 352   gobject_class = G_OBJECT_CLASS (klass);
 353   gstelement_class = GST_ELEMENT_CLASS (klass);
 354   parent_class = g_type_class_peek_parent (klass);
 355 
 356   GST_DEBUG_CATEGORY_INIT (gst_audio_encoder_debug, &quot;audioencoder&quot;, 0,
 357       &quot;audio encoder base class&quot;);
 358 
<span class="line-modified"> 359   if (private_offset != 0)</span>
<span class="line-added"> 360     g_type_class_adjust_private_offset (klass, &amp;private_offset);</span>
 361 
 362   gobject_class-&gt;set_property = gst_audio_encoder_set_property;
 363   gobject_class-&gt;get_property = gst_audio_encoder_get_property;
 364 
 365   gobject_class-&gt;finalize = GST_DEBUG_FUNCPTR (gst_audio_encoder_finalize);
 366 
 367   /* properties */
 368   g_object_class_install_property (gobject_class, PROP_PERFECT_TS,
 369       g_param_spec_boolean (&quot;perfect-timestamp&quot;, &quot;Perfect Timestamps&quot;,
 370           &quot;Favour perfect timestamps over tracking upstream timestamps&quot;,
 371           DEFAULT_PERFECT_TS, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 372   g_object_class_install_property (gobject_class, PROP_GRANULE,
 373       g_param_spec_boolean (&quot;mark-granule&quot;, &quot;Granule Marking&quot;,
 374           &quot;Apply granule semantics to buffer metadata (implies perfect-timestamp)&quot;,
 375           DEFAULT_GRANULE, G_PARAM_READABLE | G_PARAM_STATIC_STRINGS));
 376   g_object_class_install_property (gobject_class, PROP_HARD_RESYNC,
 377       g_param_spec_boolean (&quot;hard-resync&quot;, &quot;Hard Resync&quot;,
 378           &quot;Perform clipping and sample flushing upon discontinuity&quot;,
 379           DEFAULT_HARD_RESYNC, G_PARAM_READWRITE | G_PARAM_STATIC_STRINGS));
 380   g_object_class_install_property (gobject_class, PROP_TOLERANCE,
</pre>
<hr />
<pre>
 387       GST_DEBUG_FUNCPTR (gst_audio_encoder_change_state);
 388 
 389   klass-&gt;getcaps = gst_audio_encoder_getcaps_default;
 390   klass-&gt;sink_event = gst_audio_encoder_sink_event_default;
 391   klass-&gt;src_event = gst_audio_encoder_src_event_default;
 392   klass-&gt;sink_query = gst_audio_encoder_sink_query_default;
 393   klass-&gt;src_query = gst_audio_encoder_src_query_default;
 394   klass-&gt;propose_allocation = gst_audio_encoder_propose_allocation_default;
 395   klass-&gt;decide_allocation = gst_audio_encoder_decide_allocation_default;
 396   klass-&gt;negotiate = gst_audio_encoder_negotiate_default;
 397   klass-&gt;transform_meta = gst_audio_encoder_transform_meta_default;
 398 }
 399 
 400 static void
 401 gst_audio_encoder_init (GstAudioEncoder * enc, GstAudioEncoderClass * bclass)
 402 {
 403   GstPadTemplate *pad_template;
 404 
 405   GST_DEBUG_OBJECT (enc, &quot;gst_audio_encoder_init&quot;);
 406 
<span class="line-modified"> 407   enc-&gt;priv = gst_audio_encoder_get_instance_private (enc);</span>
 408 
 409   /* only push mode supported */
 410   pad_template =
 411       gst_element_class_get_pad_template (GST_ELEMENT_CLASS (bclass), &quot;sink&quot;);
 412   g_return_if_fail (pad_template != NULL);
 413   enc-&gt;sinkpad = gst_pad_new_from_template (pad_template, &quot;sink&quot;);
 414   gst_pad_set_event_function (enc-&gt;sinkpad,
 415       GST_DEBUG_FUNCPTR (gst_audio_encoder_sink_event));
 416   gst_pad_set_query_function (enc-&gt;sinkpad,
 417       GST_DEBUG_FUNCPTR (gst_audio_encoder_sink_query));
 418   gst_pad_set_chain_function (enc-&gt;sinkpad,
 419       GST_DEBUG_FUNCPTR (gst_audio_encoder_chain));
 420   gst_pad_set_activatemode_function (enc-&gt;sinkpad,
 421       GST_DEBUG_FUNCPTR (gst_audio_encoder_sink_activate_mode));
 422   gst_element_add_pad (GST_ELEMENT (enc), enc-&gt;sinkpad);
 423 
 424   GST_DEBUG_OBJECT (enc, &quot;sinkpad created&quot;);
 425 
 426   /* and we don&#39;t mind upstream traveling stuff that much ... */
 427   pad_template =
</pre>
<hr />
<pre>
 619   GstTagList *merged_tags;
 620 
 621   GST_LOG_OBJECT (enc, &quot;upstream : %&quot; GST_PTR_FORMAT, enc-&gt;priv-&gt;upstream_tags);
 622   GST_LOG_OBJECT (enc, &quot;encoder  : %&quot; GST_PTR_FORMAT, enc-&gt;priv-&gt;tags);
 623   GST_LOG_OBJECT (enc, &quot;mode     : %d&quot;, enc-&gt;priv-&gt;tags_merge_mode);
 624 
 625   merged_tags =
 626       gst_tag_list_merge (enc-&gt;priv-&gt;upstream_tags, enc-&gt;priv-&gt;tags,
 627       enc-&gt;priv-&gt;tags_merge_mode);
 628 
 629   GST_DEBUG_OBJECT (enc, &quot;merged   : %&quot; GST_PTR_FORMAT, merged_tags);
 630 
 631   if (merged_tags == NULL)
 632     return NULL;
 633 
 634   if (gst_tag_list_is_empty (merged_tags)) {
 635     gst_tag_list_unref (merged_tags);
 636     return NULL;
 637   }
 638 
<span class="line-modified"> 639   /* add codec info to pending tags */</span>
 640 #if 0
<span class="line-modified"> 641   caps = gst_pad_get_current_caps (enc-&gt;srcpad);</span>
 642   gst_pb_utils_add_codec_description_to_tag_list (merged_tags,
<span class="line-modified"> 643       GST_TAG_AUDIO_CODEC, caps);</span>
 644 #endif
 645 
 646   return gst_event_new_tag (merged_tags);
 647 }
 648 
 649 static void
 650 gst_audio_encoder_check_and_push_pending_tags (GstAudioEncoder * enc)
 651 {
 652   if (enc-&gt;priv-&gt;tags_changed) {
 653     GstEvent *tags_event;
 654 
 655     tags_event = gst_audio_encoder_create_merged_tags_event (enc);
 656 
 657     if (tags_event != NULL)
 658       gst_audio_encoder_push_event (enc, tags_event);
 659 
 660     enc-&gt;priv-&gt;tags_changed = FALSE;
 661   }
 662 }
 663 
</pre>
<hr />
<pre>
 715     info-&gt;transform_func (outbuf, *meta, inbuf,
 716         _gst_meta_transform_copy, &amp;copy_data);
 717   }
 718   return TRUE;
 719 }
 720 
 721 /**
 722  * gst_audio_encoder_finish_frame:
 723  * @enc: a #GstAudioEncoder
 724  * @buffer: encoded data
 725  * @samples: number of samples (per channel) represented by encoded data
 726  *
 727  * Collects encoded data and pushes encoded data downstream.
 728  * Source pad caps must be set when this is called.
 729  *
 730  * If @samples &lt; 0, then best estimate is all samples provided to encoder
 731  * (subclass) so far.  @buf may be NULL, in which case next number of @samples
 732  * are considered discarded, e.g. as a result of discontinuous transmission,
 733  * and a discontinuity is marked.
 734  *
<span class="line-modified"> 735  * Note that samples received in #GstAudioEncoderClass.handle_frame()</span>
 736  * may be invalidated by a call to this function.
 737  *
 738  * Returns: a #GstFlowReturn that should be escalated to caller (of caller)
 739  */
 740 GstFlowReturn
 741 gst_audio_encoder_finish_frame (GstAudioEncoder * enc, GstBuffer * buf,
 742     gint samples)
 743 {
 744   GstAudioEncoderClass *klass;
 745   GstAudioEncoderPrivate *priv;
 746   GstAudioEncoderContext *ctx;
 747   GstFlowReturn ret = GST_FLOW_OK;
 748   gboolean needs_reconfigure = FALSE;
 749   GstBuffer *inbuf = NULL;
 750 
 751   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
 752   priv = enc-&gt;priv;
 753   ctx = &amp;enc-&gt;priv-&gt;ctx;
 754 
 755   /* subclass should not hand us no data */
</pre>
<hr />
<pre>
 835           GST_LOG_OBJECT (enc, &quot;new upstream ts only introduces jitter&quot;);
 836         }
 837       }
 838     }
 839     /* advance sample view */
 840     if (G_UNLIKELY (samples * ctx-&gt;info.bpf &gt; priv-&gt;offset)) {
 841       guint avail = gst_adapter_available (priv-&gt;adapter);
 842 
 843       if (G_LIKELY (!priv-&gt;force)) {
 844         /* we should have received EOS to enable force */
 845         goto overflow;
 846       } else {
 847         priv-&gt;offset = 0;
 848         if (avail &gt; 0 &amp;&amp; samples * ctx-&gt;info.bpf &gt;= avail) {
 849           inbuf = gst_adapter_take_buffer_fast (priv-&gt;adapter, avail);
 850           gst_adapter_clear (priv-&gt;adapter);
 851         } else if (avail &gt; 0) {
 852           inbuf =
 853               gst_adapter_take_buffer_fast (priv-&gt;adapter,
 854               samples * ctx-&gt;info.bpf);
<span class="line-modified"> 855         }</span>
 856       }
 857     } else {
 858       guint avail = gst_adapter_available (priv-&gt;adapter);
 859 
 860       if (avail &gt; 0) {
 861         inbuf =
 862             gst_adapter_take_buffer_fast (priv-&gt;adapter,
 863             samples * ctx-&gt;info.bpf);
 864       }
 865       priv-&gt;offset -= samples * ctx-&gt;info.bpf;
 866       /* avoid subsequent stray prev_ts */
 867       if (G_UNLIKELY (gst_adapter_available (priv-&gt;adapter) == 0))
 868         gst_adapter_clear (priv-&gt;adapter);
 869     }
 870     /* sample count advanced below after buffer handling */
 871   }
 872 
 873   /* collect output */
 874   if (G_LIKELY (buf)) {
 875     gsize size;
</pre>
<hr />
<pre>
 894 
 895         /* Ogg codecs like Vorbis use offset/offset-end in a special
 896          * way and both should be 0 for these codecs */
 897         if (priv-&gt;base_gp &gt;= 0) {
 898           GST_BUFFER_OFFSET (tmpbuf) = 0;
 899           GST_BUFFER_OFFSET_END (tmpbuf) = 0;
 900         } else {
 901           GST_BUFFER_OFFSET (tmpbuf) = priv-&gt;bytes_out;
 902           GST_BUFFER_OFFSET_END (tmpbuf) = priv-&gt;bytes_out + size;
 903         }
 904 
 905         GST_OBJECT_LOCK (enc);
 906         priv-&gt;bytes_out += size;
 907         GST_OBJECT_UNLOCK (enc);
 908 
 909         ret = gst_pad_push (enc-&gt;srcpad, tmpbuf);
 910         if (ret != GST_FLOW_OK) {
 911           GST_WARNING_OBJECT (enc, &quot;pushing header returned %s&quot;,
 912               gst_flow_get_name (ret));
 913           goto exit;
<span class="line-modified"> 914         }</span>
 915       }
 916       priv-&gt;ctx.new_headers = FALSE;
 917     }
 918 
 919     size = gst_buffer_get_size (buf);
 920 
 921     GST_LOG_OBJECT (enc, &quot;taking %&quot; G_GSIZE_FORMAT &quot; bytes for output&quot;, size);
 922     buf = gst_buffer_make_writable (buf);
 923 
 924     /* decorate */
 925     if (G_LIKELY (GST_CLOCK_TIME_IS_VALID (priv-&gt;base_ts))) {
 926       /* FIXME ? lookahead could lead to weird ts and duration ?
 927        * (particularly if not in perfect mode) */
 928       /* mind sample rounding and produce perfect output */
 929       GST_BUFFER_TIMESTAMP (buf) = priv-&gt;base_ts +
 930           gst_util_uint64_scale (priv-&gt;samples - ctx-&gt;lookahead, GST_SECOND,
 931           ctx-&gt;info.rate);
 932       GST_BUFFER_DTS (buf) = GST_BUFFER_TIMESTAMP (buf);
 933       GST_DEBUG_OBJECT (enc, &quot;out samples %d&quot;, samples);
 934       if (G_LIKELY (samples &gt; 0)) {
</pre>
<hr />
<pre>
1375     gst_buffer_unref (buffer);
1376     ret = GST_FLOW_NOT_NEGOTIATED;
1377     goto done;
1378   }
1379 wrong_buffer:
1380   {
1381     GST_ELEMENT_ERROR (enc, STREAM, ENCODE, (NULL),
1382         (&quot;buffer size %&quot; G_GSIZE_FORMAT &quot; not a multiple of %d&quot;,
1383             gst_buffer_get_size (buffer), ctx-&gt;info.bpf));
1384     gst_buffer_unref (buffer);
1385     ret = GST_FLOW_ERROR;
1386     goto done;
1387   }
1388 wrong_time:
1389   {
1390     GST_ELEMENT_ERROR (enc, STREAM, ENCODE, (NULL),
1391         (&quot;buffer going too far back in time&quot;));
1392     gst_buffer_unref (buffer);
1393     ret = GST_FLOW_ERROR;
1394     goto done;
<span class="line-modified">1395   }</span>
1396 }
1397 
1398 static gboolean
1399 gst_audio_encoder_sink_setcaps (GstAudioEncoder * enc, GstCaps * caps)
1400 {
1401   GstAudioEncoderClass *klass;
1402   GstAudioEncoderContext *ctx;
1403   GstAudioInfo state;
1404   gboolean res = TRUE;
1405   guint old_rate;
1406 
1407   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
1408 
1409   /* subclass must do something here ... */
1410   g_return_val_if_fail (klass-&gt;set_format != NULL, FALSE);
1411 
1412   ctx = &amp;enc-&gt;priv-&gt;ctx;
1413 
1414   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1415 
</pre>
<hr />
<pre>
1485 
1486 /**
1487  * gst_audio_encoder_proxy_getcaps:
1488  * @enc: a #GstAudioEncoder
1489  * @caps: (allow-none): initial caps
1490  * @filter: (allow-none): filter caps
1491  *
1492  * Returns caps that express @caps (or sink template caps if @caps == NULL)
1493  * restricted to channel/rate combinations supported by downstream elements
1494  * (e.g. muxers).
1495  *
1496  * Returns: (transfer full): a #GstCaps owned by caller
1497  */
1498 GstCaps *
1499 gst_audio_encoder_proxy_getcaps (GstAudioEncoder * enc, GstCaps * caps,
1500     GstCaps * filter)
1501 {
1502   return __gst_audio_element_proxy_getcaps (GST_ELEMENT_CAST (enc),
1503       GST_AUDIO_ENCODER_SINK_PAD (enc), GST_AUDIO_ENCODER_SRC_PAD (enc),
1504       caps, filter);
<span class="line-modified">1505 }</span>
1506 
1507 static GstCaps *
1508 gst_audio_encoder_getcaps_default (GstAudioEncoder * enc, GstCaps * filter)
1509 {
1510   GstCaps *caps;
1511 
1512   caps = gst_audio_encoder_proxy_getcaps (enc, NULL, filter);
1513   GST_LOG_OBJECT (enc, &quot;returning caps %&quot; GST_PTR_FORMAT, caps);
1514 
1515   return caps;
1516 }
1517 
1518 static GList *
1519 _flush_events (GstPad * pad, GList * events)
1520 {
1521   GList *tmp;
1522 
1523   for (tmp = events; tmp; tmp = tmp-&gt;next) {
1524     if (GST_EVENT_TYPE (tmp-&gt;data) != GST_EVENT_EOS &amp;&amp;
1525         GST_EVENT_TYPE (tmp-&gt;data) != GST_EVENT_SEGMENT &amp;&amp;
</pre>
<hr />
<pre>
1628       GST_DEBUG_OBJECT (enc, &quot;received STREAM_START. Clearing taglist&quot;);
1629       if (enc-&gt;priv-&gt;upstream_tags) {
1630         gst_tag_list_unref (enc-&gt;priv-&gt;upstream_tags);
1631         enc-&gt;priv-&gt;upstream_tags = NULL;
1632         enc-&gt;priv-&gt;tags_changed = TRUE;
1633       }
1634       GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1635       res = gst_audio_encoder_push_event (enc, event);
1636       break;
1637     }
1638 
1639     case GST_EVENT_TAG:
1640     {
1641       GstTagList *tags;
1642 
1643       gst_event_parse_tag (event, &amp;tags);
1644 
1645       if (gst_tag_list_get_scope (tags) == GST_TAG_SCOPE_STREAM) {
1646         GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1647         if (enc-&gt;priv-&gt;upstream_tags != tags) {
<span class="line-modified">1648           tags = gst_tag_list_copy (tags);</span>
<span class="line-modified">1649 </span>
<span class="line-modified">1650           /* FIXME: make generic based on GST_TAG_FLAG_ENCODED */</span>
<span class="line-modified">1651           gst_tag_list_remove_tag (tags, GST_TAG_CODEC);</span>
<span class="line-modified">1652           gst_tag_list_remove_tag (tags, GST_TAG_AUDIO_CODEC);</span>
<span class="line-modified">1653           gst_tag_list_remove_tag (tags, GST_TAG_VIDEO_CODEC);</span>
<span class="line-modified">1654           gst_tag_list_remove_tag (tags, GST_TAG_SUBTITLE_CODEC);</span>
<span class="line-modified">1655           gst_tag_list_remove_tag (tags, GST_TAG_CONTAINER_FORMAT);</span>
<span class="line-modified">1656           gst_tag_list_remove_tag (tags, GST_TAG_BITRATE);</span>
<span class="line-modified">1657           gst_tag_list_remove_tag (tags, GST_TAG_NOMINAL_BITRATE);</span>
<span class="line-modified">1658           gst_tag_list_remove_tag (tags, GST_TAG_MAXIMUM_BITRATE);</span>
<span class="line-modified">1659           gst_tag_list_remove_tag (tags, GST_TAG_MINIMUM_BITRATE);</span>
<span class="line-modified">1660           gst_tag_list_remove_tag (tags, GST_TAG_ENCODER);</span>
<span class="line-modified">1661           gst_tag_list_remove_tag (tags, GST_TAG_ENCODER_VERSION);</span>
1662 
1663           if (enc-&gt;priv-&gt;upstream_tags)
1664             gst_tag_list_unref (enc-&gt;priv-&gt;upstream_tags);
1665           enc-&gt;priv-&gt;upstream_tags = tags;
1666           GST_INFO_OBJECT (enc, &quot;upstream stream tags: %&quot; GST_PTR_FORMAT, tags);
1667         }
1668         gst_event_unref (event);
1669         event = gst_audio_encoder_create_merged_tags_event (enc);
1670         GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1671 
1672         /* No tags, go out of here instead of fall through */
1673         if (!event) {
<span class="line-modified">1674           res = TRUE;</span>
<span class="line-modified">1675           break;</span>
<span class="line-modified">1676         }</span>
1677       }
1678       /* fall through */
1679     }
1680     default:
1681       /* Forward non-serialized events immediately. */
1682       if (!GST_EVENT_IS_SERIALIZED (event)) {
1683         res =
1684             gst_pad_event_default (enc-&gt;sinkpad, GST_OBJECT_CAST (enc), event);
1685       } else {
1686         GST_AUDIO_ENCODER_STREAM_LOCK (enc);
1687         enc-&gt;priv-&gt;pending_events =
1688             g_list_append (enc-&gt;priv-&gt;pending_events, event);
1689         GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
1690         res = TRUE;
1691       }
1692       break;
1693   }
1694   return res;
1695 }
1696 
</pre>
<hr />
<pre>
1946               gst_pad_peer_query_convert (enc-&gt;sinkpad, fmt, dur, req_fmt,
1947                   &amp;val))) {
1948         gst_query_set_duration (query, req_fmt, val);
1949       }
1950       break;
1951     }
1952     case GST_QUERY_FORMATS:
1953     {
1954       gst_query_set_formats (query, 2, GST_FORMAT_TIME, GST_FORMAT_BYTES);
1955       res = TRUE;
1956       break;
1957     }
1958     case GST_QUERY_CONVERT:
1959     {
1960       GstFormat src_fmt, dest_fmt;
1961       gint64 src_val, dest_val;
1962 
1963       gst_query_parse_convert (query, &amp;src_fmt, &amp;src_val, &amp;dest_fmt, &amp;dest_val);
1964       GST_OBJECT_LOCK (enc);
1965       res = __gst_audio_encoded_audio_convert (&amp;enc-&gt;priv-&gt;ctx.info,
<span class="line-modified">1966           enc-&gt;priv-&gt;bytes_out, enc-&gt;priv-&gt;samples_in, src_fmt, src_val,</span>
1967           &amp;dest_fmt, &amp;dest_val);
1968       GST_OBJECT_UNLOCK (enc);
1969       if (!res)
1970         break;
1971       gst_query_set_convert (query, src_fmt, src_val, dest_fmt, dest_val);
1972       break;
1973     }
1974     case GST_QUERY_LATENCY:
1975     {
1976       if ((res = gst_pad_peer_query (enc-&gt;sinkpad, query))) {
1977         gboolean live;
1978         GstClockTime min_latency, max_latency;
1979 
1980         gst_query_parse_latency (query, &amp;live, &amp;min_latency, &amp;max_latency);
1981         GST_DEBUG_OBJECT (enc, &quot;Peer latency: live %d, min %&quot;
1982             GST_TIME_FORMAT &quot; max %&quot; GST_TIME_FORMAT, live,
1983             GST_TIME_ARGS (min_latency), GST_TIME_ARGS (max_latency));
1984 
1985         GST_OBJECT_LOCK (enc);
1986         /* add our latency */
<span class="line-modified">1987         min_latency += enc-&gt;priv-&gt;ctx.min_latency;</span>
1988         if (max_latency == -1 || enc-&gt;priv-&gt;ctx.max_latency == -1)
1989           max_latency = -1;
1990         else
1991           max_latency += enc-&gt;priv-&gt;ctx.max_latency;
1992         GST_OBJECT_UNLOCK (enc);
1993 
1994         gst_query_set_latency (query, live, min_latency, max_latency);
1995       }
1996       break;
1997     }
1998     default:
1999       res = gst_pad_query_default (pad, GST_OBJECT (enc), query);
2000       break;
2001   }
2002 
2003   return res;
2004 }
2005 
2006 static gboolean
2007 gst_audio_encoder_src_query (GstPad * pad, GstObject * parent, GstQuery * query)
</pre>
<hr />
<pre>
2143 GstAudioInfo *
2144 gst_audio_encoder_get_audio_info (GstAudioEncoder * enc)
2145 {
2146   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), NULL);
2147 
2148   return &amp;enc-&gt;priv-&gt;ctx.info;
2149 }
2150 
2151 /**
2152  * gst_audio_encoder_set_frame_samples_min:
2153  * @enc: a #GstAudioEncoder
2154  * @num: number of samples per frame
2155  *
2156  * Sets number of samples (per channel) subclass needs to be handed,
2157  * at least or will be handed all available if 0.
2158  *
2159  * If an exact number of samples is required, gst_audio_encoder_set_frame_samples_max()
2160  * must be called with the same number.
2161  *
2162  * Note: This value will be reset to 0 every time before
<span class="line-modified">2163  * #GstAudioEncoderClass.set_format() is called.</span>
2164  */
2165 void
2166 gst_audio_encoder_set_frame_samples_min (GstAudioEncoder * enc, gint num)
2167 {
2168   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2169 
2170   enc-&gt;priv-&gt;ctx.frame_samples_min = num;
2171   GST_LOG_OBJECT (enc, &quot;set to %d&quot;, num);
2172 }
2173 
2174 /**
2175  * gst_audio_encoder_get_frame_samples_min:
2176  * @enc: a #GstAudioEncoder
2177  *
2178  * Returns: currently minimum requested samples per frame
2179  */
2180 gint
2181 gst_audio_encoder_get_frame_samples_min (GstAudioEncoder * enc)
2182 {
2183   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2184 
2185   return enc-&gt;priv-&gt;ctx.frame_samples_min;
2186 }
2187 
2188 /**
2189  * gst_audio_encoder_set_frame_samples_max:
2190  * @enc: a #GstAudioEncoder
2191  * @num: number of samples per frame
2192  *
2193  * Sets number of samples (per channel) subclass needs to be handed,
2194  * at most or will be handed all available if 0.
2195  *
2196  * If an exact number of samples is required, gst_audio_encoder_set_frame_samples_min()
2197  * must be called with the same number.
2198  *
2199  * Note: This value will be reset to 0 every time before
<span class="line-modified">2200  * #GstAudioEncoderClass.set_format() is called.</span>
2201  */
2202 void
2203 gst_audio_encoder_set_frame_samples_max (GstAudioEncoder * enc, gint num)
2204 {
2205   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2206 
2207   enc-&gt;priv-&gt;ctx.frame_samples_max = num;
2208   GST_LOG_OBJECT (enc, &quot;set to %d&quot;, num);
2209 }
2210 
2211 /**
2212  * gst_audio_encoder_get_frame_samples_max:
2213  * @enc: a #GstAudioEncoder
2214  *
2215  * Returns: currently maximum requested samples per frame
2216  */
2217 gint
2218 gst_audio_encoder_get_frame_samples_max (GstAudioEncoder * enc)
2219 {
2220   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2221 
2222   return enc-&gt;priv-&gt;ctx.frame_samples_max;
2223 }
2224 
2225 /**
2226  * gst_audio_encoder_set_frame_max:
2227  * @enc: a #GstAudioEncoder
2228  * @num: number of frames
2229  *
2230  * Sets max number of frames accepted at once (assumed minimally 1).
2231  * Requires @frame_samples_min and @frame_samples_max to be the equal.
2232  *
2233  * Note: This value will be reset to 0 every time before
<span class="line-modified">2234  * #GstAudioEncoderClass.set_format() is called.</span>
2235  */
2236 void
2237 gst_audio_encoder_set_frame_max (GstAudioEncoder * enc, gint num)
2238 {
2239   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2240 
2241   enc-&gt;priv-&gt;ctx.frame_max = num;
2242   GST_LOG_OBJECT (enc, &quot;set to %d&quot;, num);
2243 }
2244 
2245 /**
2246  * gst_audio_encoder_get_frame_max:
2247  * @enc: a #GstAudioEncoder
2248  *
2249  * Returns: currently configured maximum handled frames
2250  */
2251 gint
2252 gst_audio_encoder_get_frame_max (GstAudioEncoder * enc)
2253 {
2254   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
2255 
2256   return enc-&gt;priv-&gt;ctx.frame_max;
2257 }
2258 
2259 /**
2260  * gst_audio_encoder_set_lookahead:
2261  * @enc: a #GstAudioEncoder
2262  * @num: lookahead
2263  *
2264  * Sets encoder lookahead (in units of input rate samples)
2265  *
2266  * Note: This value will be reset to 0 every time before
<span class="line-modified">2267  * #GstAudioEncoderClass.set_format() is called.</span>
2268  */
2269 void
2270 gst_audio_encoder_set_lookahead (GstAudioEncoder * enc, gint num)
2271 {
2272   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2273 
2274   enc-&gt;priv-&gt;ctx.lookahead = num;
2275   GST_LOG_OBJECT (enc, &quot;set to %d&quot;, num);
2276 }
2277 
2278 /**
2279  * gst_audio_encoder_get_lookahead:
2280  * @enc: a #GstAudioEncoder
2281  *
2282  * Returns: currently configured encoder lookahead
2283  */
2284 gint
2285 gst_audio_encoder_get_lookahead (GstAudioEncoder * enc)
2286 {
2287   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), 0);
</pre>
<hr />
<pre>
2676 gst_audio_encoder_merge_tags (GstAudioEncoder * enc,
2677     const GstTagList * tags, GstTagMergeMode mode)
2678 {
2679   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2680   g_return_if_fail (tags == NULL || GST_IS_TAG_LIST (tags));
2681   g_return_if_fail (tags == NULL || mode != GST_TAG_MERGE_UNDEFINED);
2682 
2683   GST_AUDIO_ENCODER_STREAM_LOCK (enc);
2684   if (enc-&gt;priv-&gt;tags != tags) {
2685     if (enc-&gt;priv-&gt;tags) {
2686       gst_tag_list_unref (enc-&gt;priv-&gt;tags);
2687       enc-&gt;priv-&gt;tags = NULL;
2688       enc-&gt;priv-&gt;tags_merge_mode = GST_TAG_MERGE_APPEND;
2689     }
2690     if (tags) {
2691       enc-&gt;priv-&gt;tags = gst_tag_list_ref ((GstTagList *) tags);
2692       enc-&gt;priv-&gt;tags_merge_mode = mode;
2693     }
2694 
2695     GST_DEBUG_OBJECT (enc, &quot;setting encoder tags to %&quot; GST_PTR_FORMAT, tags);
<span class="line-modified">2696     enc-&gt;priv-&gt;tags_changed = TRUE;</span>
2697   }
2698   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
2699 }
2700 
2701 static gboolean
2702 gst_audio_encoder_negotiate_default (GstAudioEncoder * enc)
2703 {
2704   GstAudioEncoderClass *klass;
2705   gboolean res = TRUE;
2706   GstQuery *query = NULL;
2707   GstAllocator *allocator;
2708   GstAllocationParams params;
2709   GstCaps *caps, *prevcaps;
2710 
2711   g_return_val_if_fail (GST_IS_AUDIO_ENCODER (enc), FALSE);
2712   g_return_val_if_fail (GST_IS_CAPS (enc-&gt;priv-&gt;ctx.caps), FALSE);
2713 
2714   klass = GST_AUDIO_ENCODER_GET_CLASS (enc);
2715 
2716   caps = enc-&gt;priv-&gt;ctx.caps;
</pre>
<hr />
<pre>
2922     goto fallback;
2923   }
2924 
2925   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
2926 
2927   return buffer;
2928 
2929 fallback:
2930   buffer = gst_buffer_new_allocate (NULL, size, NULL);
2931   GST_AUDIO_ENCODER_STREAM_UNLOCK (enc);
2932 
2933   return buffer;
2934 }
2935 
2936 /**
2937  * gst_audio_encoder_get_allocator:
2938  * @enc: a #GstAudioEncoder
2939  * @allocator: (out) (allow-none) (transfer full): the #GstAllocator
2940  * used
2941  * @params: (out) (allow-none) (transfer full): the
<span class="line-modified">2942  * #GstAllocationParams of @allocator</span>
2943  *
2944  * Lets #GstAudioEncoder sub-classes to know the memory @allocator
2945  * used by the base class and its @params.
2946  *
2947  * Unref the @allocator after use it.
2948  */
2949 void
2950 gst_audio_encoder_get_allocator (GstAudioEncoder * enc,
2951     GstAllocator ** allocator, GstAllocationParams * params)
2952 {
2953   g_return_if_fail (GST_IS_AUDIO_ENCODER (enc));
2954 
2955   if (allocator)
2956     *allocator = enc-&gt;priv-&gt;ctx.allocator ?
2957         gst_object_ref (enc-&gt;priv-&gt;ctx.allocator) : NULL;
2958 
2959   if (params)
2960     *params = enc-&gt;priv-&gt;ctx.params;
2961 }
</pre>
</td>
</tr>
</table>
<center><a href="gstaudiodecoder.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstaudioencoder.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>