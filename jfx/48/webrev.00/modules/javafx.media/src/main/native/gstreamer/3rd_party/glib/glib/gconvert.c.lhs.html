<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gconvert.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GLIB - Library of useful routines for C programming
   2  *
   3  * gconvert.c: Convert between character sets using iconv
   4  * Copyright Red Hat Inc., 2000
   5  * Authors: Havoc Pennington &lt;hp@redhat.com&gt;, Owen Taylor &lt;otaylor@redhat.com&gt;
   6  *
   7  * This library is free software; you can redistribute it and/or
   8  * modify it under the terms of the GNU Lesser General Public
   9  * License as published by the Free Software Foundation; either
  10  * version 2.1 of the License, or (at your option) any later version.
  11  *
  12  * This library is distributed in the hope that it will be useful,
  13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  15  * Lesser General Public License for more details.
  16  *
  17  * You should have received a copy of the GNU Lesser General Public
  18  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  19  */
  20 
  21 #include &quot;config.h&quot;
  22 #include &quot;glibconfig.h&quot;
  23 
  24 #ifndef G_OS_WIN32
  25 #include &lt;iconv.h&gt;
  26 #endif
  27 #include &lt;errno.h&gt;
  28 #include &lt;stdio.h&gt;
  29 #include &lt;string.h&gt;
  30 #include &lt;stdlib.h&gt;
  31 
  32 #ifdef G_OS_WIN32
  33 #include &quot;win_iconv.c&quot;
  34 #endif
  35 
  36 #ifdef G_PLATFORM_WIN32
  37 #define STRICT
  38 #include &lt;windows.h&gt;
  39 #undef STRICT
  40 #endif
  41 
  42 #include &quot;gconvert.h&quot;
  43 
  44 #include &quot;gcharsetprivate.h&quot;
  45 #include &quot;gslist.h&quot;
  46 #include &quot;gstrfuncs.h&quot;
  47 #include &quot;gtestutils.h&quot;
  48 #include &quot;gthread.h&quot;
<a name="1" id="anc1"></a>
  49 #include &quot;gunicode.h&quot;
  50 #include &quot;gfileutils.h&quot;
  51 
  52 #include &quot;glibintl.h&quot;
  53 
<a name="2" id="anc2"></a><span class="line-removed">  54 #if defined(USE_LIBICONV_GNU) &amp;&amp; !defined (_LIBICONV_H)</span>
<span class="line-removed">  55 #error GNU libiconv in use but included iconv.h not from libiconv</span>
<span class="line-removed">  56 #endif</span>
<span class="line-removed">  57 #if !defined(USE_LIBICONV_GNU) &amp;&amp; defined (_LIBICONV_H) \</span>
<span class="line-removed">  58      &amp;&amp; !defined (__APPLE_CC__) &amp;&amp; !defined (__LP_64__)</span>
<span class="line-removed">  59 #error GNU libiconv not in use but included iconv.h is from libiconv</span>
<span class="line-removed">  60 #endif</span>
<span class="line-removed">  61 </span>
  62 
  63 /**
  64  * SECTION:conversions
  65  * @title: Character Set Conversion
  66  * @short_description: convert strings between different character sets
  67  *
  68  * The g_convert() family of function wraps the functionality of iconv().
  69  * In addition to pure character set conversions, GLib has functions to
  70  * deal with the extra complications of encodings for file names.
  71  *
  72  * ## File Name Encodings
  73  *
  74  * Historically, UNIX has not had a defined encoding for file names:
  75  * a file name is valid as long as it does not have path separators
  76  * in it (&quot;/&quot;). However, displaying file names may require conversion:
  77  * from the character set in which they were created, to the character
  78  * set in which the application operates. Consider the Spanish file name
  79  * &quot;Presentacion.sxi&quot;. If the application which created it uses
  80  * ISO-8859-1 for its encoding,
  81  * |[
  82  * Character:  P  r  e  s  e  n  t  a  c  i  o  n  .  s  x  i
  83  * Hex code:   50 72 65 73 65 6e 74 61 63 69 f3 6e 2e 73 78 69
  84  * ]|
  85  * However, if the application use UTF-8, the actual file name on
  86  * disk would look like this:
  87  * |[
  88  * Character:  P  r  e  s  e  n  t  a  c  i  o  n  .  s  x  i
  89  * Hex code:   50 72 65 73 65 6e 74 61 63 69 c3 b3 6e 2e 73 78 69
  90  * ]|
  91  * Glib uses UTF-8 for its strings, and GUI toolkits like GTK+ that use
  92  * GLib do the same thing. If you get a file name from the file system,
  93  * for example, from readdir() or from g_dir_read_name(), and you wish
  94  * to display the file name to the user, you  will need to convert it
  95  * into UTF-8. The opposite case is when the user types the name of a
  96  * file they wish to save: the toolkit will give you that string in
  97  * UTF-8 encoding, and you will need to convert it to the character
  98  * set used for file names before you can create the file with open()
  99  * or fopen().
 100  *
 101  * By default, GLib assumes that file names on disk are in UTF-8
 102  * encoding. This is a valid assumption for file systems which
 103  * were created relatively recently: most applications use UTF-8
 104  * encoding for their strings, and that is also what they use for
 105  * the file names they create. However, older file systems may
 106  * still contain file names created in &quot;older&quot; encodings, such as
 107  * ISO-8859-1. In this case, for compatibility reasons, you may want
 108  * to instruct GLib to use that particular encoding for file names
 109  * rather than UTF-8. You can do this by specifying the encoding for
 110  * file names in the [`G_FILENAME_ENCODING`][G_FILENAME_ENCODING]
 111  * environment variable. For example, if your installation uses
 112  * ISO-8859-1 for file names, you can put this in your `~/.profile`:
 113  * |[
 114  * export G_FILENAME_ENCODING=ISO-8859-1
 115  * ]|
 116  * GLib provides the functions g_filename_to_utf8() and
 117  * g_filename_from_utf8() to perform the necessary conversions.
 118  * These functions convert file names from the encoding specified
 119  * in `G_FILENAME_ENCODING` to UTF-8 and vice-versa. This
 120  * [diagram][file-name-encodings-diagram] illustrates how
 121  * these functions are used to convert between UTF-8 and the
 122  * encoding for file names in the file system.
 123  *
 124  * ## Conversion between file name encodings # {#file-name-encodings-diagram)
 125  *
 126  * ![](file-name-encodings.png)
 127  *
 128  * ## Checklist for Application Writers
 129  *
 130  * This section is a practical summary of the detailed
 131  * things to do to make sure your applications process file
 132  * name encodings correctly.
 133  *
 134  * 1. If you get a file name from the file system from a function
 135  *    such as readdir() or gtk_file_chooser_get_filename(), you do
 136  *    not need to do any conversion to pass that file name to
 137  *    functions like open(), rename(), or fopen() -- those are &quot;raw&quot;
 138  *    file names which the file system understands.
 139  *
 140  * 2. If you need to display a file name, convert it to UTF-8 first
 141  *    by using g_filename_to_utf8(). If conversion fails, display a
 142  *    string like &quot;Unknown file name&quot;. Do not convert this string back
 143  *    into the encoding used for file names if you wish to pass it to
 144  *    the file system; use the original file name instead.
 145  *
 146  *    For example, the document window of a word processor could display
 147  *    &quot;Unknown file name&quot; in its title bar but still let the user save
 148  *    the file, as it would keep the raw file name internally. This
 149  *    can happen if the user has not set the `G_FILENAME_ENCODING`
 150  *    environment variable even though he has files whose names are
 151  *    not encoded in UTF-8.
 152  *
 153  * 3. If your user interface lets the user type a file name for saving
 154  *    or renaming, convert it to the encoding used for file names in
 155  *    the file system by using g_filename_from_utf8(). Pass the converted
 156  *    file name to functions like fopen(). If conversion fails, ask the
 157  *    user to enter a different file name. This can happen if the user
 158  *    types Japanese characters when `G_FILENAME_ENCODING` is set to
 159  *    `ISO-8859-1`, for example.
 160  */
 161 
 162 /* We try to terminate strings in unknown charsets with this many zero bytes
 163  * to ensure that multibyte strings really are nul-terminated when we return
 164  * them from g_convert() and friends.
 165  */
 166 #define NUL_TERMINATOR_LENGTH 4
 167 
 168 G_DEFINE_QUARK (g_convert_error, g_convert_error)
 169 
 170 static gboolean
 171 try_conversion (const char *to_codeset,
<a name="3" id="anc3"></a><span class="line-modified"> 172         const char *from_codeset,</span>
<span class="line-modified"> 173         iconv_t    *cd)</span>
 174 {
 175   *cd = iconv_open (to_codeset, from_codeset);
 176 
 177   if (*cd == (iconv_t)-1 &amp;&amp; errno == EINVAL)
 178     return FALSE;
 179   else
 180     return TRUE;
 181 }
 182 
 183 static gboolean
 184 try_to_aliases (const char **to_aliases,
<a name="4" id="anc4"></a><span class="line-modified"> 185         const char  *from_codeset,</span>
<span class="line-modified"> 186         iconv_t     *cd)</span>
 187 {
 188   if (to_aliases)
 189     {
 190       const char **p = to_aliases;
 191       while (*p)
<a name="5" id="anc5"></a><span class="line-modified"> 192     {</span>
<span class="line-modified"> 193       if (try_conversion (*p, from_codeset, cd))</span>
<span class="line-modified"> 194         return TRUE;</span>
 195 
<a name="6" id="anc6"></a><span class="line-modified"> 196       p++;</span>
<span class="line-modified"> 197     }</span>
 198     }
 199 
 200   return FALSE;
 201 }
 202 
 203 /**
 204  * g_iconv_open: (skip)
 205  * @to_codeset: destination codeset
 206  * @from_codeset: source codeset
 207  *
 208  * Same as the standard UNIX routine iconv_open(), but
 209  * may be implemented via libiconv on UNIX flavors that lack
 210  * a native implementation.
 211  *
 212  * GLib provides g_convert() and g_locale_to_utf8() which are likely
 213  * more convenient than the raw iconv wrappers.
 214  *
 215  * Returns: a &quot;conversion descriptor&quot;, or (GIConv)-1 if
 216  *  opening the converter failed.
 217  **/
 218 GIConv
 219 g_iconv_open (const gchar  *to_codeset,
<a name="7" id="anc7"></a><span class="line-modified"> 220           const gchar  *from_codeset)</span>
 221 {
 222   iconv_t cd;
 223 
 224   if (!try_conversion (to_codeset, from_codeset, &amp;cd))
 225     {
 226       const char **to_aliases = _g_charset_get_aliases (to_codeset);
 227       const char **from_aliases = _g_charset_get_aliases (from_codeset);
 228 
 229       if (from_aliases)
<a name="8" id="anc8"></a><span class="line-modified"> 230     {</span>
<span class="line-modified"> 231       const char **p = from_aliases;</span>
<span class="line-modified"> 232       while (*p)</span>
<span class="line-modified"> 233         {</span>
<span class="line-modified"> 234           if (try_conversion (to_codeset, *p, &amp;cd))</span>
<span class="line-modified"> 235         goto out;</span>
 236 
<a name="9" id="anc9"></a><span class="line-modified"> 237           if (try_to_aliases (to_aliases, *p, &amp;cd))</span>
<span class="line-modified"> 238         goto out;</span>
 239 
<a name="10" id="anc10"></a><span class="line-modified"> 240           p++;</span>
<span class="line-modified"> 241         }</span>
<span class="line-modified"> 242     }</span>
 243 
 244       if (try_to_aliases (to_aliases, from_codeset, &amp;cd))
<a name="11" id="anc11"></a><span class="line-modified"> 245     goto out;</span>
 246     }
 247 
 248  out:
 249   return (cd == (iconv_t)-1) ? (GIConv)-1 : (GIConv)cd;
 250 }
 251 
 252 /**
 253  * g_iconv: (skip)
 254  * @converter: conversion descriptor from g_iconv_open()
 255  * @inbuf: bytes to convert
 256  * @inbytes_left: inout parameter, bytes remaining to convert in @inbuf
 257  * @outbuf: converted output bytes
 258  * @outbytes_left: inout parameter, bytes available to fill in @outbuf
 259  *
 260  * Same as the standard UNIX routine iconv(), but
 261  * may be implemented via libiconv on UNIX flavors that lack
 262  * a native implementation.
 263  *
 264  * GLib provides g_convert() and g_locale_to_utf8() which are likely
 265  * more convenient than the raw iconv wrappers.
 266  *
 267  * Note that the behaviour of iconv() for characters which are valid in the
 268  * input character set, but which have no representation in the output character
 269  * set, is implementation defined. This function may return success (with a
 270  * positive number of non-reversible conversions as replacement characters were
 271  * used), or it may return -1 and set an error such as %EILSEQ, in such a
 272  * situation.
 273  *
 274  * Returns: count of non-reversible conversions, or -1 on error
 275  **/
 276 gsize
 277 g_iconv (GIConv   converter,
<a name="12" id="anc12"></a><span class="line-modified"> 278      gchar  **inbuf,</span>
<span class="line-modified"> 279      gsize   *inbytes_left,</span>
<span class="line-modified"> 280      gchar  **outbuf,</span>
<span class="line-modified"> 281      gsize   *outbytes_left)</span>
 282 {
 283   iconv_t cd = (iconv_t)converter;
 284 
 285   return iconv (cd, inbuf, inbytes_left, outbuf, outbytes_left);
 286 }
 287 
 288 /**
 289  * g_iconv_close: (skip)
 290  * @converter: a conversion descriptor from g_iconv_open()
 291  *
 292  * Same as the standard UNIX routine iconv_close(), but
 293  * may be implemented via libiconv on UNIX flavors that lack
 294  * a native implementation. Should be called to clean up
 295  * the conversion descriptor from g_iconv_open() when
 296  * you are done converting things.
 297  *
 298  * GLib provides g_convert() and g_locale_to_utf8() which are likely
 299  * more convenient than the raw iconv wrappers.
 300  *
 301  * Returns: -1 on error, 0 on success
 302  **/
 303 gint
 304 g_iconv_close (GIConv converter)
 305 {
 306   iconv_t cd = (iconv_t)converter;
 307 
 308   return iconv_close (cd);
 309 }
 310 
 311 static GIConv
 312 open_converter (const gchar *to_codeset,
<a name="13" id="anc13"></a><span class="line-modified"> 313         const gchar *from_codeset,</span>
<span class="line-modified"> 314         GError     **error)</span>
 315 {
 316   GIConv cd;
 317 
 318   cd = g_iconv_open (to_codeset, from_codeset);
 319 
 320   if (cd == (GIConv) -1)
 321     {
 322       /* Something went wrong.  */
 323       if (error)
<a name="14" id="anc14"></a><span class="line-modified"> 324     {</span>
<span class="line-modified"> 325       if (errno == EINVAL)</span>
<span class="line-modified"> 326         g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_NO_CONVERSION,</span>
<span class="line-modified"> 327              _(&quot;Conversion from character set &#39;%s&#39; to &#39;%s&#39; is not supported&quot;),</span>
<span class="line-modified"> 328              from_codeset, to_codeset);</span>
<span class="line-modified"> 329       else</span>
<span class="line-modified"> 330         g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,</span>
<span class="line-modified"> 331              _(&quot;Could not open converter from &#39;%s&#39; to &#39;%s&#39;&quot;),</span>
<span class="line-modified"> 332              from_codeset, to_codeset);</span>
<span class="line-modified"> 333     }</span>
 334     }
 335 
 336   return cd;
 337 }
 338 
 339 static int
 340 close_converter (GIConv cd)
 341 {
 342   if (cd == (GIConv) -1)
 343     return 0;
 344 
 345   return g_iconv_close (cd);
 346 }
 347 
 348 /**
 349  * g_convert_with_iconv: (skip)
 350  * @str:           (array length=len) (element-type guint8):
 351  *                 the string to convert.
 352  * @len:           the length of the string in bytes, or -1 if the string is
 353  *                 nul-terminated (Note that some encodings may allow nul
 354  *                 bytes to occur inside strings. In that case, using -1
 355  *                 for the @len parameter is unsafe)
 356  * @converter:     conversion descriptor from g_iconv_open()
 357  * @bytes_read:    (out) (optional): location to store the number of bytes in
 358  *                 the input string that were successfully converted, or %NULL.
 359  *                 Even if the conversion was successful, this may be
 360  *                 less than @len if there were partial characters
 361  *                 at the end of the input. If the error
 362  *                 #G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value
 363  *                 stored will be the byte offset after the last valid
 364  *                 input sequence.
 365  * @bytes_written: (out) (optional): the number of bytes stored in
 366  *                 the output buffer (not including the terminating nul).
 367  * @error:         location to store the error occurring, or %NULL to ignore
 368  *                 errors. Any of the errors in #GConvertError may occur.
 369  *
 370  * Converts a string from one character set to another.
 371  *
 372  * Note that you should use g_iconv() for streaming conversions.
 373  * Despite the fact that @bytes_read can return information about partial
 374  * characters, the g_convert_... functions are not generally suitable
 375  * for streaming. If the underlying converter maintains internal state,
 376  * then this won&#39;t be preserved across successive calls to g_convert(),
 377  * g_convert_with_iconv() or g_convert_with_fallback(). (An example of
 378  * this is the GNU C converter for CP1255 which does not emit a base
 379  * character until it knows that the next character is not a mark that
 380  * could combine with the base character.)
 381  *
 382  * Characters which are valid in the input character set, but which have no
 383  * representation in the output character set will result in a
 384  * %G_CONVERT_ERROR_ILLEGAL_SEQUENCE error. This is in contrast to the iconv()
 385  * specification, which leaves this behaviour implementation defined. Note that
 386  * this is the same error code as is returned for an invalid byte sequence in
 387  * the input character set. To get defined behaviour for conversion of
 388  * unrepresentable characters, use g_convert_with_fallback().
 389  *
 390  * Returns: (array length=bytes_written) (element-type guint8) (transfer full):
 391  *               If the conversion was successful, a newly allocated buffer
 392  *               containing the converted string, which must be freed with
 393  *               g_free(). Otherwise %NULL and @error will be set.
 394  **/
 395 gchar*
 396 g_convert_with_iconv (const gchar *str,
<a name="15" id="anc15"></a><span class="line-modified"> 397               gssize       len,</span>
<span class="line-modified"> 398               GIConv       converter,</span>
<span class="line-modified"> 399               gsize       *bytes_read,</span>
<span class="line-modified"> 400               gsize       *bytes_written,</span>
<span class="line-modified"> 401               GError     **error)</span>
 402 {
 403   gchar *dest;
 404   gchar *outp;
 405   const gchar *p;
 406   gsize inbytes_remaining;
 407   gsize outbytes_remaining;
 408   gsize err;
 409   gsize outbuf_size;
 410   gboolean have_error = FALSE;
 411   gboolean done = FALSE;
 412   gboolean reset = FALSE;
 413 
 414   g_return_val_if_fail (converter != (GIConv) -1, NULL);
 415 
 416   if (len &lt; 0)
 417     len = strlen (str);
 418 
 419   p = str;
 420   inbytes_remaining = len;
 421   outbuf_size = len + NUL_TERMINATOR_LENGTH;
 422 
 423   outbytes_remaining = outbuf_size - NUL_TERMINATOR_LENGTH;
 424   outp = dest = g_malloc (outbuf_size);
 425 
 426   while (!done &amp;&amp; !have_error)
 427     {
 428       if (reset)
 429         err = g_iconv (converter, NULL, &amp;inbytes_remaining, &amp;outp, &amp;outbytes_remaining);
 430       else
 431         err = g_iconv (converter, (char **)&amp;p, &amp;inbytes_remaining, &amp;outp, &amp;outbytes_remaining);
 432 
 433       if (err == (gsize) -1)
<a name="16" id="anc16"></a><span class="line-modified"> 434     {</span>
<span class="line-modified"> 435       switch (errno)</span>






 436         {
<a name="17" id="anc17"></a><span class="line-modified"> 437         case EINVAL:</span>
<span class="line-modified"> 438           /* Incomplete text, do not report an error */</span>
<span class="line-modified"> 439           done = TRUE;</span>
<span class="line-modified"> 440           break;</span>
<span class="line-modified"> 441         case E2BIG:</span>
<span class="line-modified"> 442           {</span>
<span class="line-modified"> 443         gsize used = outp - dest;</span>
<span class="line-modified"> 444 </span>
<span class="line-modified"> 445         outbuf_size *= 2;</span>
<span class="line-modified"> 446         dest = g_realloc (dest, outbuf_size);</span>
<span class="line-removed"> 447 </span>
<span class="line-removed"> 448         outp = dest + used;</span>
<span class="line-removed"> 449         outbytes_remaining = outbuf_size - used - NUL_TERMINATOR_LENGTH;</span>
<span class="line-removed"> 450           }</span>
<span class="line-removed"> 451           break;</span>
<span class="line-removed"> 452         case EILSEQ:</span>
 453               g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
 454                                    _(&quot;Invalid byte sequence in conversion input&quot;));
<a name="18" id="anc18"></a><span class="line-modified"> 455           have_error = TRUE;</span>
<span class="line-modified"> 456           break;</span>
<span class="line-modified"> 457         default:</span>
 458               {
 459                 int errsv = errno;
 460 
 461                 g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,
 462                              _(&quot;Error during conversion: %s&quot;),
 463                              g_strerror (errsv));
 464               }
<a name="19" id="anc19"></a><span class="line-modified"> 465           have_error = TRUE;</span>
<span class="line-modified"> 466           break;</span>
<span class="line-modified"> 467         }</span>
<span class="line-modified"> 468     }</span>
 469       else if (err &gt; 0)
 470         {
 471           /* @err gives the number of replacement characters used. */
 472           g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
 473                                _(&quot;Unrepresentable character in conversion input&quot;));
 474           have_error = TRUE;
 475         }
 476       else
<a name="20" id="anc20"></a><span class="line-modified"> 477     {</span>
<span class="line-modified"> 478       if (!reset)</span>
<span class="line-modified"> 479         {</span>
<span class="line-modified"> 480           /* call g_iconv with NULL inbuf to cleanup shift state */</span>
<span class="line-modified"> 481           reset = TRUE;</span>
<span class="line-modified"> 482           inbytes_remaining = 0;</span>
<span class="line-modified"> 483         }</span>
<span class="line-modified"> 484       else</span>
<span class="line-modified"> 485         done = TRUE;</span>
<span class="line-modified"> 486     }</span>
 487     }
 488 
 489   memset (outp, 0, NUL_TERMINATOR_LENGTH);
 490 
 491   if (bytes_read)
 492     *bytes_read = p - str;
 493   else
 494     {
 495       if ((p - str) != len)
<a name="21" id="anc21"></a><span class="line-modified"> 496     {</span>
 497           if (!have_error)
 498             {
 499               g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_PARTIAL_INPUT,
 500                                    _(&quot;Partial character sequence at end of input&quot;));
 501               have_error = TRUE;
 502             }
<a name="22" id="anc22"></a><span class="line-modified"> 503     }</span>
 504     }
 505 
 506   if (bytes_written)
<a name="23" id="anc23"></a><span class="line-modified"> 507     *bytes_written = outp - dest;   /* Doesn&#39;t include &#39;\0&#39; */</span>
 508 
 509   if (have_error)
 510     {
 511       g_free (dest);
 512       return NULL;
 513     }
 514   else
 515     return dest;
 516 }
 517 
 518 /**
 519  * g_convert:
 520  * @str:           (array length=len) (element-type guint8):
 521  *                 the string to convert.
 522  * @len:           the length of the string in bytes, or -1 if the string is
 523  *                 nul-terminated (Note that some encodings may allow nul
 524  *                 bytes to occur inside strings. In that case, using -1
 525  *                 for the @len parameter is unsafe)
 526  * @to_codeset:    name of character set into which to convert @str
 527  * @from_codeset:  character set of @str.
 528  * @bytes_read:    (out) (optional): location to store the number of bytes in
 529  *                 the input string that were successfully converted, or %NULL.
 530  *                 Even if the conversion was successful, this may be
 531  *                 less than @len if there were partial characters
 532  *                 at the end of the input. If the error
 533  *                 #G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value
 534  *                 stored will be the byte offset after the last valid
 535  *                 input sequence.
 536  * @bytes_written: (out) (optional): the number of bytes stored in
 537  *                 the output buffer (not including the terminating nul).
 538  * @error:         location to store the error occurring, or %NULL to ignore
 539  *                 errors. Any of the errors in #GConvertError may occur.
 540  *
 541  * Converts a string from one character set to another.
 542  *
 543  * Note that you should use g_iconv() for streaming conversions.
 544  * Despite the fact that @bytes_read can return information about partial
 545  * characters, the g_convert_... functions are not generally suitable
 546  * for streaming. If the underlying converter maintains internal state,
 547  * then this won&#39;t be preserved across successive calls to g_convert(),
 548  * g_convert_with_iconv() or g_convert_with_fallback(). (An example of
 549  * this is the GNU C converter for CP1255 which does not emit a base
 550  * character until it knows that the next character is not a mark that
 551  * could combine with the base character.)
 552  *
 553  * Using extensions such as &quot;//TRANSLIT&quot; may not work (or may not work
 554  * well) on many platforms.  Consider using g_str_to_ascii() instead.
 555  *
 556  * Returns: (array length=bytes_written) (element-type guint8) (transfer full):
 557  *          If the conversion was successful, a newly allocated buffer
 558  *          containing the converted string, which must be freed with g_free().
 559  *          Otherwise %NULL and @error will be set.
 560  **/
 561 gchar*
 562 g_convert (const gchar *str,
 563            gssize       len,
 564            const gchar *to_codeset,
 565            const gchar *from_codeset,
 566            gsize       *bytes_read,
<a name="24" id="anc24"></a><span class="line-modified"> 567        gsize       *bytes_written,</span>
<span class="line-modified"> 568        GError     **error)</span>
 569 {
 570   gchar *res;
 571   GIConv cd;
 572 
 573   g_return_val_if_fail (str != NULL, NULL);
 574   g_return_val_if_fail (to_codeset != NULL, NULL);
 575   g_return_val_if_fail (from_codeset != NULL, NULL);
 576 
 577   cd = open_converter (to_codeset, from_codeset, error);
 578 
 579   if (cd == (GIConv) -1)
 580     {
 581       if (bytes_read)
 582         *bytes_read = 0;
 583 
 584       if (bytes_written)
 585         *bytes_written = 0;
 586 
 587       return NULL;
 588     }
 589 
 590   res = g_convert_with_iconv (str, len, cd,
<a name="25" id="anc25"></a><span class="line-modified"> 591                   bytes_read, bytes_written,</span>
<span class="line-modified"> 592                   error);</span>
 593 
 594   close_converter (cd);
 595 
 596   return res;
 597 }
 598 
 599 /**
 600  * g_convert_with_fallback:
 601  * @str:          (array length=len) (element-type guint8):
 602  *                the string to convert.
 603  * @len:          the length of the string in bytes, or -1 if the string is
 604  *                 nul-terminated (Note that some encodings may allow nul
 605  *                 bytes to occur inside strings. In that case, using -1
 606  *                 for the @len parameter is unsafe)
 607  * @to_codeset:   name of character set into which to convert @str
 608  * @from_codeset: character set of @str.
 609  * @fallback:     UTF-8 string to use in place of characters not
 610  *                present in the target encoding. (The string must be
 611  *                representable in the target encoding).
 612  *                If %NULL, characters not in the target encoding will
 613  *                be represented as Unicode escapes \uxxxx or \Uxxxxyyyy.
 614  * @bytes_read:   (out) (optional): location to store the number of bytes in
 615  *                the input string that were successfully converted, or %NULL.
 616  *                Even if the conversion was successful, this may be
 617  *                less than @len if there were partial characters
 618  *                at the end of the input.
 619  * @bytes_written: (out) (optional): the number of bytes stored in
 620  *                 the output buffer (not including the terminating nul).
 621  * @error:        location to store the error occurring, or %NULL to ignore
 622  *                errors. Any of the errors in #GConvertError may occur.
 623  *
 624  * Converts a string from one character set to another, possibly
 625  * including fallback sequences for characters not representable
 626  * in the output. Note that it is not guaranteed that the specification
 627  * for the fallback sequences in @fallback will be honored. Some
 628  * systems may do an approximate conversion from @from_codeset
 629  * to @to_codeset in their iconv() functions,
 630  * in which case GLib will simply return that approximate conversion.
 631  *
 632  * Note that you should use g_iconv() for streaming conversions.
 633  * Despite the fact that @bytes_read can return information about partial
 634  * characters, the g_convert_... functions are not generally suitable
 635  * for streaming. If the underlying converter maintains internal state,
 636  * then this won&#39;t be preserved across successive calls to g_convert(),
 637  * g_convert_with_iconv() or g_convert_with_fallback(). (An example of
 638  * this is the GNU C converter for CP1255 which does not emit a base
 639  * character until it knows that the next character is not a mark that
 640  * could combine with the base character.)
 641  *
 642  * Returns: (array length=bytes_written) (element-type guint8) (transfer full):
 643  *          If the conversion was successful, a newly allocated buffer
 644  *          containing the converted string, which must be freed with g_free().
 645  *          Otherwise %NULL and @error will be set.
 646  **/
 647 gchar*
 648 g_convert_with_fallback (const gchar *str,
<a name="26" id="anc26"></a><span class="line-modified"> 649              gssize       len,</span>
<span class="line-modified"> 650              const gchar *to_codeset,</span>
<span class="line-modified"> 651              const gchar *from_codeset,</span>
<span class="line-modified"> 652              const gchar *fallback,</span>
<span class="line-modified"> 653              gsize       *bytes_read,</span>
<span class="line-modified"> 654              gsize       *bytes_written,</span>
<span class="line-modified"> 655              GError     **error)</span>
 656 {
 657   gchar *utf8;
 658   gchar *dest;
 659   gchar *outp;
 660   const gchar *insert_str = NULL;
 661   const gchar *p;
 662   gsize inbytes_remaining;
 663   const gchar *save_p = NULL;
 664   gsize save_inbytes = 0;
 665   gsize outbytes_remaining;
 666   gsize err;
 667   GIConv cd;
 668   gsize outbuf_size;
 669   gboolean have_error = FALSE;
 670   gboolean done = FALSE;
 671 
 672   GError *local_error = NULL;
 673 
 674   g_return_val_if_fail (str != NULL, NULL);
 675   g_return_val_if_fail (to_codeset != NULL, NULL);
 676   g_return_val_if_fail (from_codeset != NULL, NULL);
 677 
 678   if (len &lt; 0)
 679     len = strlen (str);
 680 
 681   /* Try an exact conversion; we only proceed if this fails
 682    * due to an illegal sequence in the input string.
 683    */
 684   dest = g_convert (str, len, to_codeset, from_codeset,
<a name="27" id="anc27"></a><span class="line-modified"> 685             bytes_read, bytes_written, &amp;local_error);</span>
 686   if (!local_error)
 687     return dest;
 688 
 689   if (!g_error_matches (local_error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE))
 690     {
 691       g_propagate_error (error, local_error);
 692       return NULL;
 693     }
 694   else
 695     g_error_free (local_error);
 696 
 697   local_error = NULL;
 698 
 699   /* No go; to proceed, we need a converter from &quot;UTF-8&quot; to
 700    * to_codeset, and the string as UTF-8.
 701    */
 702   cd = open_converter (to_codeset, &quot;UTF-8&quot;, error);
 703   if (cd == (GIConv) -1)
 704     {
 705       if (bytes_read)
 706         *bytes_read = 0;
 707 
 708       if (bytes_written)
 709         *bytes_written = 0;
 710 
 711       return NULL;
 712     }
 713 
 714   utf8 = g_convert (str, len, &quot;UTF-8&quot;, from_codeset,
<a name="28" id="anc28"></a><span class="line-modified"> 715             bytes_read, &amp;inbytes_remaining, error);</span>
 716   if (!utf8)
 717     {
 718       close_converter (cd);
 719       if (bytes_written)
 720         *bytes_written = 0;
 721       return NULL;
 722     }
 723 
 724   /* Now the heart of the code. We loop through the UTF-8 string, and
 725    * whenever we hit an offending character, we form fallback, convert
 726    * the fallback to the target codeset, and then go back to
 727    * converting the original string after finishing with the fallback.
 728    *
 729    * The variables save_p and save_inbytes store the input state
 730    * for the original string while we are converting the fallback
 731    */
 732   p = utf8;
 733 
 734   outbuf_size = len + NUL_TERMINATOR_LENGTH;
 735   outbytes_remaining = outbuf_size - NUL_TERMINATOR_LENGTH;
 736   outp = dest = g_malloc (outbuf_size);
 737 
 738   while (!done &amp;&amp; !have_error)
 739     {
 740       gsize inbytes_tmp = inbytes_remaining;
 741       err = g_iconv (cd, (char **)&amp;p, &amp;inbytes_tmp, &amp;outp, &amp;outbytes_remaining);
 742       inbytes_remaining = inbytes_tmp;
 743 
 744       if (err == (gsize) -1)
<a name="29" id="anc29"></a><span class="line-modified"> 745     {</span>
<span class="line-modified"> 746       switch (errno)</span>





 747         {
<a name="30" id="anc30"></a><span class="line-modified"> 748         case EINVAL:</span>
<span class="line-removed"> 749           g_assert_not_reached();</span>
<span class="line-removed"> 750           break;</span>
<span class="line-removed"> 751         case E2BIG:</span>
<span class="line-removed"> 752           {</span>
<span class="line-removed"> 753         gsize used = outp - dest;</span>
 754 
<a name="31" id="anc31"></a><span class="line-modified"> 755         outbuf_size *= 2;</span>
<span class="line-modified"> 756         dest = g_realloc (dest, outbuf_size);</span>
 757 
<a name="32" id="anc32"></a><span class="line-modified"> 758         outp = dest + used;</span>
<span class="line-modified"> 759         outbytes_remaining = outbuf_size - used - NUL_TERMINATOR_LENGTH;</span>
 760 
<a name="33" id="anc33"></a><span class="line-modified"> 761         break;</span>
<span class="line-removed"> 762           }</span>
<span class="line-removed"> 763         case EILSEQ:</span>
<span class="line-removed"> 764           if (save_p)</span>
<span class="line-removed"> 765         {</span>
<span class="line-removed"> 766           /* Error converting fallback string - fatal</span>
<span class="line-removed"> 767            */</span>
<span class="line-removed"> 768           g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,</span>
<span class="line-removed"> 769                    _(&quot;Cannot convert fallback &#39;%s&#39; to codeset &#39;%s&#39;&quot;),</span>
<span class="line-removed"> 770                    insert_str, to_codeset);</span>
<span class="line-removed"> 771           have_error = TRUE;</span>
<span class="line-removed"> 772           break;</span>
 773         }
<a name="34" id="anc34"></a><span class="line-modified"> 774           else if (p)</span>













 775         {
<a name="35" id="anc35"></a><span class="line-modified"> 776           if (!fallback)</span>
<span class="line-modified"> 777             {</span>
<span class="line-modified"> 778               gunichar ch = g_utf8_get_char (p);</span>
<span class="line-removed"> 779               insert_str = g_strdup_printf (ch &lt; 0x10000 ? &quot;\\u%04x&quot; : &quot;\\U%08x&quot;,</span>
<span class="line-removed"> 780                             ch);</span>
<span class="line-removed"> 781             }</span>
<span class="line-removed"> 782           else</span>
<span class="line-removed"> 783             insert_str = fallback;</span>
<span class="line-removed"> 784 </span>
<span class="line-removed"> 785           save_p = g_utf8_next_char (p);</span>
<span class="line-removed"> 786           save_inbytes = inbytes_remaining - (save_p - p);</span>
<span class="line-removed"> 787           p = insert_str;</span>
<span class="line-removed"> 788           inbytes_remaining = strlen (p);</span>
<span class="line-removed"> 789           break;</span>
 790         }
<a name="36" id="anc36"></a><span class="line-modified"> 791           /* fall thru if p is NULL */</span>
<span class="line-modified"> 792         default:</span>










 793               {
 794                 int errsv = errno;
 795 
 796                 g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_FAILED,
 797                              _(&quot;Error during conversion: %s&quot;),
 798                              g_strerror (errsv));
 799               }
 800 
<a name="37" id="anc37"></a><span class="line-modified"> 801           have_error = TRUE;</span>
<span class="line-modified"> 802           break;</span>
<span class="line-modified"> 803         }</span>
<span class="line-modified"> 804     }</span>
<span class="line-removed"> 805       else</span>
<span class="line-removed"> 806     {</span>
<span class="line-removed"> 807       if (save_p)</span>
<span class="line-removed"> 808         {</span>
<span class="line-removed"> 809           if (!fallback)</span>
<span class="line-removed"> 810         g_free ((gchar *)insert_str);</span>
<span class="line-removed"> 811           p = save_p;</span>
<span class="line-removed"> 812           inbytes_remaining = save_inbytes;</span>
<span class="line-removed"> 813           save_p = NULL;</span>
<span class="line-removed"> 814         }</span>
<span class="line-removed"> 815       else if (p)</span>
<span class="line-removed"> 816         {</span>
<span class="line-removed"> 817           /* call g_iconv with NULL inbuf to cleanup shift state */</span>
<span class="line-removed"> 818           p = NULL;</span>
<span class="line-removed"> 819           inbytes_remaining = 0;</span>
<span class="line-removed"> 820         }</span>
 821       else
<a name="38" id="anc38"></a><span class="line-modified"> 822         done = TRUE;</span>
<span class="line-modified"> 823     }</span>
















 824     }
 825 
 826   /* Cleanup
 827    */
 828   memset (outp, 0, NUL_TERMINATOR_LENGTH);
 829 
 830   close_converter (cd);
 831 
 832   if (bytes_written)
<a name="39" id="anc39"></a><span class="line-modified"> 833     *bytes_written = outp - dest;   /* Doesn&#39;t include &#39;\0&#39; */</span>
 834 
 835   g_free (utf8);
 836 
 837   if (have_error)
 838     {
 839       if (save_p &amp;&amp; !fallback)
<a name="40" id="anc40"></a><span class="line-modified"> 840     g_free ((gchar *)insert_str);</span>
 841       g_free (dest);
 842       return NULL;
 843     }
 844   else
 845     return dest;
 846 }
 847 
 848 /*
 849  * g_locale_to_utf8
 850  *
 851  *
 852  */
 853 
 854 /*
 855  * Validate @string as UTF-8. @len can be negative if @string is
 856  * nul-terminated, or a non-negative value in bytes. If @string ends in an
 857  * incomplete sequence, or contains any illegal sequences or nul codepoints,
 858  * %NULL will be returned and the error set to
 859  * %G_CONVERT_ERROR_ILLEGAL_SEQUENCE.
 860  * On success, @bytes_read and @bytes_written, if provided, will be set to
 861  * the number of bytes in @string up to @len or the terminating nul byte.
 862  * On error, @bytes_read will be set to the byte offset after the last valid
 863  * and non-nul UTF-8 sequence in @string, and @bytes_written will be set to 0.
 864  */
 865 static gchar *
 866 strdup_len (const gchar *string,
<a name="41" id="anc41"></a><span class="line-modified"> 867         gssize       len,</span>
<span class="line-modified"> 868         gsize       *bytes_read,</span>
<span class="line-modified"> 869         gsize       *bytes_written,</span>
<span class="line-modified"> 870         GError     **error)</span>
 871 {
 872   gsize real_len;
 873   const gchar *end_valid;
 874 
 875   if (!g_utf8_validate (string, len, &amp;end_valid))
 876     {
 877       if (bytes_read)
<a name="42" id="anc42"></a><span class="line-modified"> 878     *bytes_read = end_valid - string;</span>
 879       if (bytes_written)
<a name="43" id="anc43"></a><span class="line-modified"> 880     *bytes_written = 0;</span>
 881 
 882       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
 883                            _(&quot;Invalid byte sequence in conversion input&quot;));
 884       return NULL;
 885     }
 886 
 887   real_len = end_valid - string;
 888 
 889   if (bytes_read)
 890     *bytes_read = real_len;
 891   if (bytes_written)
 892     *bytes_written = real_len;
 893 
 894   return g_strndup (string, real_len);
 895 }
 896 
 897 typedef enum
 898 {
 899   CONVERT_CHECK_NO_NULS_IN_INPUT  = 1 &lt;&lt; 0,
 900   CONVERT_CHECK_NO_NULS_IN_OUTPUT = 1 &lt;&lt; 1
 901 } ConvertCheckFlags;
 902 
 903 /*
 904  * Convert from @string in the encoding identified by @from_codeset,
 905  * returning a string in the encoding identifed by @to_codeset.
 906  * @len can be negative if @string is nul-terminated, or a non-negative
 907  * value in bytes. Flags defined in #ConvertCheckFlags can be set in @flags
 908  * to check the input, the output, or both, for embedded nul bytes.
 909  * On success, @bytes_read, if provided, will be set to the number of bytes
 910  * in @string up to @len or the terminating nul byte, and @bytes_written, if
 911  * provided, will be set to the number of output bytes written into the
 912  * returned buffer, excluding the terminating nul sequence.
 913  * On error, @bytes_read will be set to the byte offset after the last valid
 914  * sequence in @string, and @bytes_written will be set to 0.
 915  */
 916 static gchar *
 917 convert_checked (const gchar      *string,
 918                  gssize            len,
 919                  const gchar      *to_codeset,
 920                  const gchar      *from_codeset,
 921                  ConvertCheckFlags flags,
 922                  gsize            *bytes_read,
 923                  gsize            *bytes_written,
 924                  GError          **error)
 925 {
 926   gchar *out;
 927   gsize outbytes;
 928 
 929   if ((flags &amp; CONVERT_CHECK_NO_NULS_IN_INPUT) &amp;&amp; len &gt; 0)
 930     {
 931       const gchar *early_nul = memchr (string, &#39;\0&#39;, len);
 932       if (early_nul != NULL)
 933         {
 934           if (bytes_read)
 935             *bytes_read = early_nul - string;
 936           if (bytes_written)
 937             *bytes_written = 0;
 938 
 939           g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
 940                                _(&quot;Embedded NUL byte in conversion input&quot;));
 941           return NULL;
 942         }
 943     }
 944 
 945   out = g_convert (string, len, to_codeset, from_codeset,
 946                    bytes_read, &amp;outbytes, error);
 947   if (out == NULL)
 948     {
 949       if (bytes_written)
 950         *bytes_written = 0;
 951       return NULL;
 952     }
 953 
 954   if ((flags &amp; CONVERT_CHECK_NO_NULS_IN_OUTPUT)
 955       &amp;&amp; memchr (out, &#39;\0&#39;, outbytes) != NULL)
 956     {
 957       g_free (out);
 958       if (bytes_written)
 959         *bytes_written = 0;
 960       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_EMBEDDED_NUL,
 961                            _(&quot;Embedded NUL byte in conversion output&quot;));
 962       return NULL;
 963     }
 964 
 965   if (bytes_written)
 966     *bytes_written = outbytes;
 967   return out;
 968 }
 969 
 970 /**
 971  * g_locale_to_utf8:
 972  * @opsysstring:   (array length=len) (element-type guint8): a string in the
 973  *                 encoding of the current locale. On Windows
 974  *                 this means the system codepage.
 975  * @len:           the length of the string, or -1 if the string is
 976  *                 nul-terminated (Note that some encodings may allow nul
 977  *                 bytes to occur inside strings. In that case, using -1
 978  *                 for the @len parameter is unsafe)
 979  * @bytes_read: (out) (optional): location to store the number of bytes in the
 980  *                 input string that were successfully converted, or %NULL.
 981  *                 Even if the conversion was successful, this may be
 982  *                 less than @len if there were partial characters
 983  *                 at the end of the input. If the error
 984  *                 %G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value
 985  *                 stored will be the byte offset after the last valid
 986  *                 input sequence.
 987  * @bytes_written: (out) (optional): the number of bytes stored in the output
 988  *                 buffer (not including the terminating nul).
 989  * @error:         location to store the error occurring, or %NULL to ignore
 990  *                 errors. Any of the errors in #GConvertError may occur.
 991  *
 992  * Converts a string which is in the encoding used for strings by
 993  * the C runtime (usually the same as that used by the operating
 994  * system) in the [current locale][setlocale] into a UTF-8 string.
 995  *
 996  * If the source encoding is not UTF-8 and the conversion output contains a
 997  * nul character, the error %G_CONVERT_ERROR_EMBEDDED_NUL is set and the
 998  * function returns %NULL.
 999  * If the source encoding is UTF-8, an embedded nul character is treated with
1000  * the %G_CONVERT_ERROR_ILLEGAL_SEQUENCE error for backward compatibility with
1001  * earlier versions of this library. Use g_convert() to produce output that
1002  * may contain embedded nul characters.
1003  *
1004  * Returns: (type utf8): The converted string, or %NULL on an error.
1005  **/
1006 gchar *
1007 g_locale_to_utf8 (const gchar  *opsysstring,
<a name="44" id="anc44"></a><span class="line-modified">1008           gssize        len,</span>
<span class="line-modified">1009           gsize        *bytes_read,</span>
<span class="line-modified">1010           gsize        *bytes_written,</span>
<span class="line-modified">1011           GError      **error)</span>
1012 {
1013   const char *charset;
1014 
1015   if (g_get_charset (&amp;charset))
1016     return strdup_len (opsysstring, len, bytes_read, bytes_written, error);
1017   else
1018     return convert_checked (opsysstring, len, &quot;UTF-8&quot;, charset,
1019                             CONVERT_CHECK_NO_NULS_IN_OUTPUT,
1020                             bytes_read, bytes_written, error);
1021 }
1022 
1023 /**
1024  * g_locale_from_utf8:
1025  * @utf8string:    a UTF-8 encoded string
1026  * @len:           the length of the string, or -1 if the string is
1027  *                 nul-terminated.
1028  * @bytes_read: (out) (optional): location to store the number of bytes in the
1029  *                 input string that were successfully converted, or %NULL.
1030  *                 Even if the conversion was successful, this may be
1031  *                 less than @len if there were partial characters
1032  *                 at the end of the input. If the error
1033  *                 %G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value
1034  *                 stored will be the byte offset after the last valid
1035  *                 input sequence.
1036  * @bytes_written: (out) (optional): the number of bytes stored in the output
1037  *                 buffer (not including the terminating nul).
1038  * @error:         location to store the error occurring, or %NULL to ignore
1039  *                 errors. Any of the errors in #GConvertError may occur.
1040  *
1041  * Converts a string from UTF-8 to the encoding used for strings by
1042  * the C runtime (usually the same as that used by the operating
1043  * system) in the [current locale][setlocale]. On Windows this means
1044  * the system codepage.
1045  *
1046  * The input string shall not contain nul characters even if the @len
1047  * argument is positive. A nul character found inside the string will result
1048  * in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE. Use g_convert() to convert
1049  * input that may contain embedded nul characters.
1050  *
1051  * Returns: (array length=bytes_written) (element-type guint8) (transfer full):
1052  *          A newly-allocated buffer containing the converted string,
1053  *          or %NULL on an error, and error will be set.
1054  **/
1055 gchar *
1056 g_locale_from_utf8 (const gchar *utf8string,
<a name="45" id="anc45"></a><span class="line-modified">1057             gssize       len,</span>
<span class="line-modified">1058             gsize       *bytes_read,</span>
<span class="line-modified">1059             gsize       *bytes_written,</span>
<span class="line-modified">1060             GError     **error)</span>
1061 {
1062   const gchar *charset;
1063 
1064   if (g_get_charset (&amp;charset))
1065     return strdup_len (utf8string, len, bytes_read, bytes_written, error);
1066   else
1067     return convert_checked (utf8string, len, charset, &quot;UTF-8&quot;,
1068                             CONVERT_CHECK_NO_NULS_IN_INPUT,
1069                             bytes_read, bytes_written, error);
1070 }
1071 
1072 #ifndef G_PLATFORM_WIN32
1073 
1074 typedef struct _GFilenameCharsetCache GFilenameCharsetCache;
1075 
1076 struct _GFilenameCharsetCache {
1077   gboolean is_utf8;
1078   gchar *charset;
1079   gchar **filename_charsets;
1080 };
1081 
1082 static void
1083 filename_charset_cache_free (gpointer data)
1084 {
1085   GFilenameCharsetCache *cache = data;
1086   g_free (cache-&gt;charset);
1087   g_strfreev (cache-&gt;filename_charsets);
1088   g_free (cache);
1089 }
1090 
1091 /**
1092  * g_get_filename_charsets:
1093  * @filename_charsets: (out) (transfer none) (array zero-terminated=1):
1094  *    return location for the %NULL-terminated list of encoding names
1095  *
1096  * Determines the preferred character sets used for filenames.
1097  * The first character set from the @charsets is the filename encoding, the
1098  * subsequent character sets are used when trying to generate a displayable
1099  * representation of a filename, see g_filename_display_name().
1100  *
1101  * On Unix, the character sets are determined by consulting the
1102  * environment variables `G_FILENAME_ENCODING` and `G_BROKEN_FILENAMES`.
1103  * On Windows, the character set used in the GLib API is always UTF-8
1104  * and said environment variables have no effect.
1105  *
1106  * `G_FILENAME_ENCODING` may be set to a comma-separated list of
1107  * character set names. The special token &quot;\@locale&quot; is taken
1108  * to  mean the character set for the [current locale][setlocale].
1109  * If `G_FILENAME_ENCODING` is not set, but `G_BROKEN_FILENAMES` is,
1110  * the character set of the current locale is taken as the filename
1111  * encoding. If neither environment variable  is set, UTF-8 is taken
1112  * as the filename encoding, but the character set of the current locale
1113  * is also put in the list of encodings.
1114  *
1115  * The returned @charsets belong to GLib and must not be freed.
1116  *
1117  * Note that on Unix, regardless of the locale character set or
1118  * `G_FILENAME_ENCODING` value, the actual file names present
1119  * on a system might be in any random encoding or just gibberish.
1120  *
1121  * Returns: %TRUE if the filename encoding is UTF-8.
1122  *
1123  * Since: 2.6
1124  */
1125 gboolean
1126 g_get_filename_charsets (const gchar ***filename_charsets)
1127 {
1128   static GPrivate cache_private = G_PRIVATE_INIT (filename_charset_cache_free);
1129   GFilenameCharsetCache *cache = g_private_get (&amp;cache_private);
1130   const gchar *charset;
1131 
1132   if (!cache)
<a name="46" id="anc46"></a><span class="line-modified">1133     {</span>
<span class="line-removed">1134       cache = g_new0 (GFilenameCharsetCache, 1);</span>
<span class="line-removed">1135       g_private_set (&amp;cache_private, cache);</span>
<span class="line-removed">1136     }</span>
1137 
1138   g_get_charset (&amp;charset);
1139 
1140   if (!(cache-&gt;charset &amp;&amp; strcmp (cache-&gt;charset, charset) == 0))
1141     {
1142       const gchar *new_charset;
1143       gchar *p;
1144       gint i;
1145 
1146       g_free (cache-&gt;charset);
1147       g_strfreev (cache-&gt;filename_charsets);
1148       cache-&gt;charset = g_strdup (charset);
1149 
1150       p = getenv (&quot;G_FILENAME_ENCODING&quot;);
1151       if (p != NULL &amp;&amp; p[0] != &#39;\0&#39;)
<a name="47" id="anc47"></a><span class="line-modified">1152     {</span>
<span class="line-modified">1153       cache-&gt;filename_charsets = g_strsplit (p, &quot;,&quot;, 0);</span>
<span class="line-modified">1154       cache-&gt;is_utf8 = (strcmp (cache-&gt;filename_charsets[0], &quot;UTF-8&quot;) == 0);</span>
1155 
<a name="48" id="anc48"></a><span class="line-modified">1156       for (i = 0; cache-&gt;filename_charsets[i]; i++)</span>
<span class="line-modified">1157         {</span>
<span class="line-modified">1158           if (strcmp (&quot;@locale&quot;, cache-&gt;filename_charsets[i]) == 0)</span>
<span class="line-removed">1159         {</span>
<span class="line-removed">1160           g_get_charset (&amp;new_charset);</span>
<span class="line-removed">1161           g_free (cache-&gt;filename_charsets[i]);</span>
<span class="line-removed">1162           cache-&gt;filename_charsets[i] = g_strdup (new_charset);</span>
<span class="line-removed">1163         }</span>
<span class="line-removed">1164         }</span>
<span class="line-removed">1165     }</span>
<span class="line-removed">1166       else if (getenv (&quot;G_BROKEN_FILENAMES&quot;) != NULL)</span>
1167     {
<a name="49" id="anc49"></a><span class="line-modified">1168       cache-&gt;filename_charsets = g_new0 (gchar *, 2);</span>
<span class="line-modified">1169       cache-&gt;is_utf8 = g_get_charset (&amp;new_charset);</span>
<span class="line-modified">1170       cache-&gt;filename_charsets[0] = g_strdup (new_charset);</span>
1171     }
<a name="50" id="anc50"></a>







1172       else
<a name="51" id="anc51"></a><span class="line-modified">1173     {</span>
<span class="line-modified">1174       cache-&gt;filename_charsets = g_new0 (gchar *, 3);</span>
<span class="line-modified">1175       cache-&gt;is_utf8 = TRUE;</span>
<span class="line-modified">1176       cache-&gt;filename_charsets[0] = g_strdup (&quot;UTF-8&quot;);</span>
<span class="line-modified">1177       if (!g_get_charset (&amp;new_charset))</span>
<span class="line-modified">1178         cache-&gt;filename_charsets[1] = g_strdup (new_charset);</span>
<span class="line-modified">1179     }</span>
1180     }
1181 
1182   if (filename_charsets)
1183     *filename_charsets = (const gchar **)cache-&gt;filename_charsets;
1184 
1185   return cache-&gt;is_utf8;
1186 }
1187 
1188 #else /* G_PLATFORM_WIN32 */
1189 
1190 gboolean
1191 g_get_filename_charsets (const gchar ***filename_charsets)
1192 {
1193   static const gchar *charsets[] = {
1194     &quot;UTF-8&quot;,
1195     NULL
1196   };
1197 
1198 #ifdef G_OS_WIN32
1199   /* On Windows GLib pretends that the filename charset is UTF-8 */
1200   if (filename_charsets)
1201     *filename_charsets = charsets;
1202 
1203   return TRUE;
1204 #else
1205   gboolean result;
1206 
1207   /* Cygwin works like before */
1208   result = g_get_charset (&amp;(charsets[0]));
1209 
1210   if (filename_charsets)
1211     *filename_charsets = charsets;
1212 
1213   return result;
1214 #endif
1215 }
1216 
1217 #endif /* G_PLATFORM_WIN32 */
1218 
1219 static gboolean
1220 get_filename_charset (const gchar **filename_charset)
1221 {
1222   const gchar **charsets;
1223   gboolean is_utf8;
1224 
1225   is_utf8 = g_get_filename_charsets (&amp;charsets);
1226 
1227   if (filename_charset)
1228     *filename_charset = charsets[0];
1229 
1230   return is_utf8;
1231 }
1232 
1233 /**
1234  * g_filename_to_utf8:
1235  * @opsysstring: (type filename): a string in the encoding for filenames
1236  * @len:           the length of the string, or -1 if the string is
1237  *                 nul-terminated (Note that some encodings may allow nul
1238  *                 bytes to occur inside strings. In that case, using -1
1239  *                 for the @len parameter is unsafe)
1240  * @bytes_read: (out) (optional): location to store the number of bytes in the
1241  *                 input string that were successfully converted, or %NULL.
1242  *                 Even if the conversion was successful, this may be
1243  *                 less than @len if there were partial characters
1244  *                 at the end of the input. If the error
1245  *                 %G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value
1246  *                 stored will be the byte offset after the last valid
1247  *                 input sequence.
1248  * @bytes_written: (out) (optional): the number of bytes stored in the output
1249  *                 buffer (not including the terminating nul).
1250  * @error:         location to store the error occurring, or %NULL to ignore
1251  *                 errors. Any of the errors in #GConvertError may occur.
1252  *
1253  * Converts a string which is in the encoding used by GLib for
1254  * filenames into a UTF-8 string. Note that on Windows GLib uses UTF-8
1255  * for filenames; on other platforms, this function indirectly depends on
1256  * the [current locale][setlocale].
1257  *
1258  * The input string shall not contain nul characters even if the @len
1259  * argument is positive. A nul character found inside the string will result
1260  * in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE.
1261  * If the source encoding is not UTF-8 and the conversion output contains a
1262  * nul character, the error %G_CONVERT_ERROR_EMBEDDED_NUL is set and the
1263  * function returns %NULL. Use g_convert() to produce output that
1264  * may contain embedded nul characters.
1265  *
1266  * Returns: (type utf8): The converted string, or %NULL on an error.
1267  **/
1268 gchar*
1269 g_filename_to_utf8 (const gchar *opsysstring,
<a name="52" id="anc52"></a><span class="line-modified">1270             gssize       len,</span>
<span class="line-modified">1271             gsize       *bytes_read,</span>
<span class="line-modified">1272             gsize       *bytes_written,</span>
<span class="line-modified">1273             GError     **error)</span>
1274 {
1275   const gchar *charset;
1276 
1277   g_return_val_if_fail (opsysstring != NULL, NULL);
1278 
1279   if (get_filename_charset (&amp;charset))
1280     return strdup_len (opsysstring, len, bytes_read, bytes_written, error);
1281   else
1282     return convert_checked (opsysstring, len, &quot;UTF-8&quot;, charset,
1283                             CONVERT_CHECK_NO_NULS_IN_INPUT |
1284                             CONVERT_CHECK_NO_NULS_IN_OUTPUT,
1285                             bytes_read, bytes_written, error);
1286 }
1287 
1288 /**
1289  * g_filename_from_utf8:
1290  * @utf8string:    (type utf8): a UTF-8 encoded string.
1291  * @len:           the length of the string, or -1 if the string is
1292  *                 nul-terminated.
1293  * @bytes_read:    (out) (optional): location to store the number of bytes in
1294  *                 the input string that were successfully converted, or %NULL.
1295  *                 Even if the conversion was successful, this may be
1296  *                 less than @len if there were partial characters
1297  *                 at the end of the input. If the error
1298  *                 %G_CONVERT_ERROR_ILLEGAL_SEQUENCE occurs, the value
1299  *                 stored will be the byte offset after the last valid
1300  *                 input sequence.
1301  * @bytes_written: (out) (optional): the number of bytes stored in
1302  *                 the output buffer (not including the terminating nul).
1303  * @error:         location to store the error occurring, or %NULL to ignore
1304  *                 errors. Any of the errors in #GConvertError may occur.
1305  *
1306  * Converts a string from UTF-8 to the encoding GLib uses for
1307  * filenames. Note that on Windows GLib uses UTF-8 for filenames;
1308  * on other platforms, this function indirectly depends on the
1309  * [current locale][setlocale].
1310  *
1311  * The input string shall not contain nul characters even if the @len
1312  * argument is positive. A nul character found inside the string will result
1313  * in error %G_CONVERT_ERROR_ILLEGAL_SEQUENCE. If the filename encoding is
1314  * not UTF-8 and the conversion output contains a nul character, the error
1315  * %G_CONVERT_ERROR_EMBEDDED_NUL is set and the function returns %NULL.
1316  *
1317  * Returns: (type filename):
1318  *               The converted string, or %NULL on an error.
1319  **/
1320 gchar*
1321 g_filename_from_utf8 (const gchar *utf8string,
<a name="53" id="anc53"></a><span class="line-modified">1322               gssize       len,</span>
<span class="line-modified">1323               gsize       *bytes_read,</span>
<span class="line-modified">1324               gsize       *bytes_written,</span>
<span class="line-modified">1325               GError     **error)</span>
1326 {
1327   const gchar *charset;
1328 
1329   if (get_filename_charset (&amp;charset))
1330     return strdup_len (utf8string, len, bytes_read, bytes_written, error);
1331   else
1332     return convert_checked (utf8string, len, charset, &quot;UTF-8&quot;,
1333                             CONVERT_CHECK_NO_NULS_IN_INPUT |
1334                             CONVERT_CHECK_NO_NULS_IN_OUTPUT,
1335                             bytes_read, bytes_written, error);
1336 }
1337 
1338 /* Test of haystack has the needle prefix, comparing case
1339  * insensitive. haystack may be UTF-8, but needle must
1340  * contain only ascii. */
1341 static gboolean
1342 has_case_prefix (const gchar *haystack, const gchar *needle)
1343 {
1344   const gchar *h, *n;
1345 
1346   /* Eat one character at a time. */
1347   h = haystack;
1348   n = needle;
1349 
1350   while (*n &amp;&amp; *h &amp;&amp;
<a name="54" id="anc54"></a><span class="line-modified">1351      g_ascii_tolower (*n) == g_ascii_tolower (*h))</span>
1352     {
1353       n++;
1354       h++;
1355     }
1356 
1357   return *n == &#39;\0&#39;;
1358 }
1359 
1360 typedef enum {
1361   UNSAFE_ALL        = 0x1,  /* Escape all unsafe characters   */
1362   UNSAFE_ALLOW_PLUS = 0x2,  /* Allows &#39;+&#39;  */
1363   UNSAFE_PATH       = 0x8,  /* Allows &#39;/&#39;, &#39;&amp;&#39;, &#39;=&#39;, &#39;:&#39;, &#39;@&#39;, &#39;+&#39;, &#39;$&#39; and &#39;,&#39; */
1364   UNSAFE_HOST       = 0x10, /* Allows &#39;/&#39; and &#39;:&#39; and &#39;@&#39; */
1365   UNSAFE_SLASHES    = 0x20  /* Allows all characters except for &#39;/&#39; and &#39;%&#39; */
1366 } UnsafeCharacterSet;
1367 
1368 static const guchar acceptable[96] = {
1369   /* A table of the ASCII chars from space (32) to DEL (127) */
1370   /*      !    &quot;    #    $    %    &amp;    &#39;    (    )    *    +    ,    -    .    / */
1371   0x00,0x3F,0x20,0x20,0x28,0x00,0x2C,0x3F,0x3F,0x3F,0x3F,0x2A,0x28,0x3F,0x3F,0x1C,
1372   /* 0    1    2    3    4    5    6    7    8    9    :    ;    &lt;    =    &gt;    ? */
1373   0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x38,0x20,0x20,0x2C,0x20,0x20,
1374   /* @    A    B    C    D    E    F    G    H    I    J    K    L    M    N    O */
1375   0x38,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
1376   /* P    Q    R    S    T    U    V    W    X    Y    Z    [    \    ]    ^    _ */
1377   0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x20,0x20,0x20,0x20,0x3F,
1378   /* `    a    b    c    d    e    f    g    h    i    j    k    l    m    n    o */
1379   0x20,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,
1380   /* p    q    r    s    t    u    v    w    x    y    z    {    |    }    ~  DEL */
1381   0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x3F,0x20,0x20,0x20,0x3F,0x20
1382 };
1383 
1384 static const gchar hex[16] = &quot;0123456789ABCDEF&quot;;
1385 
1386 /* Note: This escape function works on file: URIs, but if you want to
1387  * escape something else, please read RFC-2396 */
1388 static gchar *
1389 g_escape_uri_string (const gchar *string,
<a name="55" id="anc55"></a><span class="line-modified">1390              UnsafeCharacterSet mask)</span>
1391 {
1392 #define ACCEPTABLE(a) ((a)&gt;=32 &amp;&amp; (a)&lt;128 &amp;&amp; (acceptable[(a)-32] &amp; use_mask))
1393 
1394   const gchar *p;
1395   gchar *q;
1396   gchar *result;
1397   int c;
1398   gint unacceptable;
1399   UnsafeCharacterSet use_mask;
1400 
1401   g_return_val_if_fail (mask == UNSAFE_ALL
<a name="56" id="anc56"></a><span class="line-modified">1402             || mask == UNSAFE_ALLOW_PLUS</span>
<span class="line-modified">1403             || mask == UNSAFE_PATH</span>
<span class="line-modified">1404             || mask == UNSAFE_HOST</span>
<span class="line-modified">1405             || mask == UNSAFE_SLASHES, NULL);</span>
1406 
1407   unacceptable = 0;
1408   use_mask = mask;
1409   for (p = string; *p != &#39;\0&#39;; p++)
1410     {
1411       c = (guchar) *p;
1412       if (!ACCEPTABLE (c))
<a name="57" id="anc57"></a><span class="line-modified">1413     unacceptable++;</span>
1414     }
1415 
1416   result = g_malloc (p - string + unacceptable * 2 + 1);
1417 
1418   use_mask = mask;
1419   for (q = result, p = string; *p != &#39;\0&#39;; p++)
1420     {
1421       c = (guchar) *p;
1422 
1423       if (!ACCEPTABLE (c))
<a name="58" id="anc58"></a><span class="line-modified">1424     {</span>
<span class="line-modified">1425       *q++ = &#39;%&#39;; /* means hex coming */</span>
<span class="line-modified">1426       *q++ = hex[c &gt;&gt; 4];</span>
<span class="line-modified">1427       *q++ = hex[c &amp; 15];</span>
<span class="line-modified">1428     }</span>
1429       else
<a name="59" id="anc59"></a><span class="line-modified">1430     *q++ = *p;</span>
1431     }
1432 
1433   *q = &#39;\0&#39;;
1434 
1435   return result;
1436 }
1437 
1438 
1439 static gchar *
1440 g_escape_file_uri (const gchar *hostname,
<a name="60" id="anc60"></a><span class="line-modified">1441            const gchar *pathname)</span>
1442 {
1443   char *escaped_hostname = NULL;
1444   char *escaped_path;
1445   char *res;
1446 
1447 #ifdef G_OS_WIN32
1448   char *p, *backslash;
1449 
1450   /* Turn backslashes into forward slashes. That&#39;s what Netscape
1451    * does, and they are actually more or less equivalent in Windows.
1452    */
1453 
1454   pathname = g_strdup (pathname);
1455   p = (char *) pathname;
1456 
1457   while ((backslash = strchr (p, &#39;\\&#39;)) != NULL)
1458     {
1459       *backslash = &#39;/&#39;;
1460       p = backslash + 1;
1461     }
1462 #endif
1463 
1464   if (hostname &amp;&amp; *hostname != &#39;\0&#39;)
1465     {
1466       escaped_hostname = g_escape_uri_string (hostname, UNSAFE_HOST);
1467     }
1468 
1469   escaped_path = g_escape_uri_string (pathname, UNSAFE_PATH);
1470 
1471   res = g_strconcat (&quot;file://&quot;,
<a name="61" id="anc61"></a><span class="line-modified">1472              (escaped_hostname) ? escaped_hostname : &quot;&quot;,</span>
<span class="line-modified">1473              (*escaped_path != &#39;/&#39;) ? &quot;/&quot; : &quot;&quot;,</span>
<span class="line-modified">1474              escaped_path,</span>
<span class="line-modified">1475              NULL);</span>
1476 
1477 #ifdef G_OS_WIN32
1478   g_free ((char *) pathname);
1479 #endif
1480 
1481   g_free (escaped_hostname);
1482   g_free (escaped_path);
1483 
1484   return res;
1485 }
1486 
1487 static int
1488 unescape_character (const char *scanner)
1489 {
1490   int first_digit;
1491   int second_digit;
1492 
1493   first_digit = g_ascii_xdigit_value (scanner[0]);
1494   if (first_digit &lt; 0)
1495     return -1;
1496 
1497   second_digit = g_ascii_xdigit_value (scanner[1]);
1498   if (second_digit &lt; 0)
1499     return -1;
1500 
1501   return (first_digit &lt;&lt; 4) | second_digit;
1502 }
1503 
1504 static gchar *
1505 g_unescape_uri_string (const char *escaped,
<a name="62" id="anc62"></a><span class="line-modified">1506                int         len,</span>
<span class="line-modified">1507                const char *illegal_escaped_characters,</span>
<span class="line-modified">1508                gboolean    ascii_must_not_be_escaped)</span>
1509 {
1510   const gchar *in, *in_end;
1511   gchar *out, *result;
1512   int c;
1513 
1514   if (escaped == NULL)
1515     return NULL;
1516 
1517   if (len &lt; 0)
1518     len = strlen (escaped);
1519 
1520   result = g_malloc (len + 1);
1521 
1522   out = result;
1523   for (in = escaped, in_end = escaped + len; in &lt; in_end; in++)
1524     {
1525       c = *in;
1526 
1527       if (c == &#39;%&#39;)
<a name="63" id="anc63"></a><span class="line-modified">1528     {</span>
<span class="line-modified">1529       /* catch partial escape sequences past the end of the substring */</span>
<span class="line-modified">1530       if (in + 3 &gt; in_end)</span>
<span class="line-modified">1531         break;</span>
1532 
<a name="64" id="anc64"></a><span class="line-modified">1533       c = unescape_character (in + 1);</span>
1534 
<a name="65" id="anc65"></a><span class="line-modified">1535       /* catch bad escape sequences and NUL characters */</span>
<span class="line-modified">1536       if (c &lt;= 0)</span>
<span class="line-modified">1537         break;</span>
1538 
<a name="66" id="anc66"></a><span class="line-modified">1539       /* catch escaped ASCII */</span>
<span class="line-modified">1540       if (ascii_must_not_be_escaped &amp;&amp; c &lt;= 0x7F)</span>
<span class="line-modified">1541         break;</span>
1542 
<a name="67" id="anc67"></a><span class="line-modified">1543       /* catch other illegal escaped characters */</span>
<span class="line-modified">1544       if (strchr (illegal_escaped_characters, c) != NULL)</span>
<span class="line-modified">1545         break;</span>
1546 
<a name="68" id="anc68"></a><span class="line-modified">1547       in += 2;</span>
<span class="line-modified">1548     }</span>
1549 
1550       *out++ = c;
1551     }
1552 
1553   g_assert (out - result &lt;= len);
1554   *out = &#39;\0&#39;;
1555 
1556   if (in != in_end)
1557     {
1558       g_free (result);
1559       return NULL;
1560     }
1561 
1562   return result;
1563 }
1564 
1565 static gboolean
1566 is_asciialphanum (gunichar c)
1567 {
1568   return c &lt;= 0x7F &amp;&amp; g_ascii_isalnum (c);
1569 }
1570 
1571 static gboolean
1572 is_asciialpha (gunichar c)
1573 {
1574   return c &lt;= 0x7F &amp;&amp; g_ascii_isalpha (c);
1575 }
1576 
1577 /* allows an empty string */
1578 static gboolean
1579 hostname_validate (const char *hostname)
1580 {
1581   const char *p;
1582   gunichar c, first_char, last_char;
1583 
1584   p = hostname;
1585   if (*p == &#39;\0&#39;)
1586     return TRUE;
1587   do
1588     {
1589       /* read in a label */
1590       c = g_utf8_get_char (p);
1591       p = g_utf8_next_char (p);
1592       if (!is_asciialphanum (c))
<a name="69" id="anc69"></a><span class="line-modified">1593     return FALSE;</span>
1594       first_char = c;
1595       do
<a name="70" id="anc70"></a><span class="line-modified">1596     {</span>
<span class="line-modified">1597       last_char = c;</span>
<span class="line-modified">1598       c = g_utf8_get_char (p);</span>
<span class="line-modified">1599       p = g_utf8_next_char (p);</span>
<span class="line-modified">1600     }</span>
1601       while (is_asciialphanum (c) || c == &#39;-&#39;);
1602       if (last_char == &#39;-&#39;)
<a name="71" id="anc71"></a><span class="line-modified">1603     return FALSE;</span>
1604 
1605       /* if that was the last label, check that it was a toplabel */
1606       if (c == &#39;\0&#39; || (c == &#39;.&#39; &amp;&amp; *p == &#39;\0&#39;))
<a name="72" id="anc72"></a><span class="line-modified">1607     return is_asciialpha (first_char);</span>
1608     }
1609   while (c == &#39;.&#39;);
1610   return FALSE;
1611 }
1612 
1613 /**
1614  * g_filename_from_uri:
1615  * @uri: a uri describing a filename (escaped, encoded in ASCII).
1616  * @hostname: (out) (optional) (nullable): Location to store hostname for the URI.
1617  *            If there is no hostname in the URI, %NULL will be
1618  *            stored in this location.
1619  * @error: location to store the error occurring, or %NULL to ignore
1620  *         errors. Any of the errors in #GConvertError may occur.
1621  *
1622  * Converts an escaped ASCII-encoded URI to a local filename in the
1623  * encoding used for filenames.
1624  *
1625  * Returns: (type filename): a newly-allocated string holding
1626  *               the resulting filename, or %NULL on an error.
1627  **/
1628 gchar *
1629 g_filename_from_uri (const gchar *uri,
<a name="73" id="anc73"></a><span class="line-modified">1630              gchar      **hostname,</span>
<span class="line-modified">1631              GError     **error)</span>
1632 {
1633   const char *path_part;
1634   const char *host_part;
1635   char *unescaped_hostname;
1636   char *result;
1637   char *filename;
1638   int offs;
1639 #ifdef G_OS_WIN32
1640   char *p, *slash;
1641 #endif
1642 
1643   if (hostname)
1644     *hostname = NULL;
1645 
1646   if (!has_case_prefix (uri, &quot;file:/&quot;))
1647     {
1648       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,
<a name="74" id="anc74"></a><span class="line-modified">1649            _(&quot;The URI &#39;%s&#39; is not an absolute URI using the &#39;file&#39; scheme&quot;),</span>
<span class="line-modified">1650            uri);</span>
1651       return NULL;
1652     }
1653 
1654   path_part = uri + strlen (&quot;file:&quot;);
1655 
1656   if (strchr (path_part, &#39;#&#39;) != NULL)
1657     {
1658       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,
<a name="75" id="anc75"></a><span class="line-modified">1659            _(&quot;The local file URI &#39;%s&#39; may not include a &#39;#&#39;&quot;),</span>
<span class="line-modified">1660            uri);</span>
1661       return NULL;
1662     }
1663 
1664   if (has_case_prefix (path_part, &quot;///&quot;))
1665     path_part += 2;
1666   else if (has_case_prefix (path_part, &quot;//&quot;))
1667     {
1668       path_part += 2;
1669       host_part = path_part;
1670 
1671       path_part = strchr (path_part, &#39;/&#39;);
1672 
1673       if (path_part == NULL)
<a name="76" id="anc76"></a><span class="line-modified">1674     {</span>
<span class="line-modified">1675       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,</span>
<span class="line-modified">1676                _(&quot;The URI &#39;%s&#39; is invalid&quot;),</span>
<span class="line-modified">1677                uri);</span>
<span class="line-modified">1678       return NULL;</span>
<span class="line-modified">1679     }</span>
1680 
1681       unescaped_hostname = g_unescape_uri_string (host_part, path_part - host_part, &quot;&quot;, TRUE);
1682 
1683       if (unescaped_hostname == NULL ||
<a name="77" id="anc77"></a><span class="line-modified">1684       !hostname_validate (unescaped_hostname))</span>
<span class="line-modified">1685     {</span>
<span class="line-modified">1686       g_free (unescaped_hostname);</span>
<span class="line-modified">1687       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,</span>
<span class="line-modified">1688                _(&quot;The hostname of the URI &#39;%s&#39; is invalid&quot;),</span>
<span class="line-modified">1689                uri);</span>
<span class="line-modified">1690       return NULL;</span>
<span class="line-modified">1691     }</span>
1692 
1693       if (hostname)
<a name="78" id="anc78"></a><span class="line-modified">1694     *hostname = unescaped_hostname;</span>
1695       else
<a name="79" id="anc79"></a><span class="line-modified">1696     g_free (unescaped_hostname);</span>
1697     }
1698 
1699   filename = g_unescape_uri_string (path_part, -1, &quot;/&quot;, FALSE);
1700 
1701   if (filename == NULL)
1702     {
1703       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_BAD_URI,
<a name="80" id="anc80"></a><span class="line-modified">1704            _(&quot;The URI &#39;%s&#39; contains invalidly escaped characters&quot;),</span>
<span class="line-modified">1705            uri);</span>
1706       return NULL;
1707     }
1708 
1709   offs = 0;
1710 #ifdef G_OS_WIN32
1711   /* Drop localhost */
1712   if (hostname &amp;&amp; *hostname != NULL &amp;&amp;
1713       g_ascii_strcasecmp (*hostname, &quot;localhost&quot;) == 0)
1714     {
1715       g_free (*hostname);
1716       *hostname = NULL;
1717     }
1718 
1719   /* Turn slashes into backslashes, because that&#39;s the canonical spelling */
1720   p = filename;
1721   while ((slash = strchr (p, &#39;/&#39;)) != NULL)
1722     {
1723       *slash = &#39;\\&#39;;
1724       p = slash + 1;
1725     }
1726 
1727   /* Windows URIs with a drive letter can be like &quot;file://host/c:/foo&quot;
1728    * or &quot;file://host/c|/foo&quot; (some Netscape versions). In those cases, start
1729    * the filename from the drive letter.
1730    */
1731   if (g_ascii_isalpha (filename[1]))
1732     {
1733       if (filename[2] == &#39;:&#39;)
<a name="81" id="anc81"></a><span class="line-modified">1734     offs = 1;</span>
1735       else if (filename[2] == &#39;|&#39;)
<a name="82" id="anc82"></a><span class="line-modified">1736     {</span>
<span class="line-modified">1737       filename[2] = &#39;:&#39;;</span>
<span class="line-modified">1738       offs = 1;</span>
<span class="line-modified">1739     }</span>
1740     }
1741 #endif
1742 
1743   result = g_strdup (filename + offs);
1744   g_free (filename);
1745 
1746   return result;
1747 }
1748 
1749 /**
1750  * g_filename_to_uri:
1751  * @filename: (type filename): an absolute filename specified in the GLib file
1752  *     name encoding, which is the on-disk file name bytes on Unix, and UTF-8
1753  *     on Windows
1754  * @hostname: (nullable): A UTF-8 encoded hostname, or %NULL for none.
1755  * @error: location to store the error occurring, or %NULL to ignore
1756  *         errors. Any of the errors in #GConvertError may occur.
1757  *
1758  * Converts an absolute filename to an escaped ASCII-encoded URI, with the path
1759  * component following Section 3.3. of RFC 2396.
1760  *
1761  * Returns: a newly-allocated string holding the resulting
1762  *               URI, or %NULL on an error.
1763  **/
1764 gchar *
1765 g_filename_to_uri (const gchar *filename,
<a name="83" id="anc83"></a><span class="line-modified">1766            const gchar *hostname,</span>
<span class="line-modified">1767            GError     **error)</span>
1768 {
1769   char *escaped_uri;
1770 
1771   g_return_val_if_fail (filename != NULL, NULL);
1772 
1773   if (!g_path_is_absolute (filename))
1774     {
1775       g_set_error (error, G_CONVERT_ERROR, G_CONVERT_ERROR_NOT_ABSOLUTE_PATH,
<a name="84" id="anc84"></a><span class="line-modified">1776            _(&quot;The pathname &#39;%s&#39; is not an absolute path&quot;),</span>
<span class="line-modified">1777            filename);</span>
1778       return NULL;
1779     }
1780 
1781   if (hostname &amp;&amp;
1782       !(g_utf8_validate (hostname, -1, NULL)
<a name="85" id="anc85"></a><span class="line-modified">1783     &amp;&amp; hostname_validate (hostname)))</span>
1784     {
1785       g_set_error_literal (error, G_CONVERT_ERROR, G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
1786                            _(&quot;Invalid hostname&quot;));
1787       return NULL;
1788     }
1789 
1790 #ifdef G_OS_WIN32
1791   /* Don&#39;t use localhost unnecessarily */
1792   if (hostname &amp;&amp; g_ascii_strcasecmp (hostname, &quot;localhost&quot;) == 0)
1793     hostname = NULL;
1794 #endif
1795 
1796   escaped_uri = g_escape_file_uri (hostname, filename);
1797 
1798   return escaped_uri;
1799 }
1800 
1801 /**
1802  * g_uri_list_extract_uris:
1803  * @uri_list: an URI list
1804  *
1805  * Splits an URI list conforming to the text/uri-list
1806  * mime type defined in RFC 2483 into individual URIs,
1807  * discarding any comments. The URIs are not validated.
1808  *
1809  * Returns: (transfer full): a newly allocated %NULL-terminated list
1810  *   of strings holding the individual URIs. The array should be freed
1811  *   with g_strfreev().
1812  *
1813  * Since: 2.6
1814  */
1815 gchar **
1816 g_uri_list_extract_uris (const gchar *uri_list)
1817 {
1818   GSList *uris, *u;
1819   const gchar *p, *q;
1820   gchar **result;
1821   gint n_uris = 0;
1822 
1823   uris = NULL;
1824 
1825   p = uri_list;
1826 
1827   /* We don&#39;t actually try to validate the URI according to RFC
1828    * 2396, or even check for allowed characters - we just ignore
1829    * comments and trim whitespace off the ends.  We also
1830    * allow LF delimination as well as the specified CRLF.
1831    *
1832    * We do allow comments like specified in RFC 2483.
1833    */
1834   while (p)
1835     {
1836       if (*p != &#39;#&#39;)
<a name="86" id="anc86"></a><span class="line-modified">1837     {</span>
<span class="line-modified">1838       while (g_ascii_isspace (*p))</span>
<span class="line-modified">1839         p++;</span>
1840 
<a name="87" id="anc87"></a><span class="line-modified">1841       q = p;</span>
<span class="line-modified">1842       while (*q &amp;&amp; (*q != &#39;\n&#39;) &amp;&amp; (*q != &#39;\r&#39;))</span>
<span class="line-modified">1843         q++;</span>
1844 
<a name="88" id="anc88"></a><span class="line-modified">1845       if (q &gt; p)</span>
<span class="line-modified">1846         {</span>
<span class="line-removed">1847           q--;</span>
<span class="line-removed">1848           while (q &gt; p &amp;&amp; g_ascii_isspace (*q))</span>
1849         q--;
<a name="89" id="anc89"></a>

1850 
<a name="90" id="anc90"></a><span class="line-modified">1851           if (q &gt; p)</span>
<span class="line-modified">1852         {</span>
<span class="line-modified">1853           uris = g_slist_prepend (uris, g_strndup (p, q - p + 1));</span>
<span class="line-modified">1854           n_uris++;</span>
<span class="line-removed">1855         }</span>
<span class="line-removed">1856         }</span>
1857     }
<a name="91" id="anc91"></a>

1858       p = strchr (p, &#39;\n&#39;);
1859       if (p)
<a name="92" id="anc92"></a><span class="line-modified">1860     p++;</span>
1861     }
1862 
1863   result = g_new (gchar *, n_uris + 1);
1864 
1865   result[n_uris--] = NULL;
1866   for (u = uris; u; u = u-&gt;next)
1867     result[n_uris--] = u-&gt;data;
1868 
1869   g_slist_free (uris);
1870 
1871   return result;
1872 }
1873 
1874 /**
1875  * g_filename_display_basename:
1876  * @filename: (type filename): an absolute pathname in the
1877  *     GLib file name encoding
1878  *
1879  * Returns the display basename for the particular filename, guaranteed
1880  * to be valid UTF-8. The display name might not be identical to the filename,
1881  * for instance there might be problems converting it to UTF-8, and some files
1882  * can be translated in the display.
1883  *
1884  * If GLib cannot make sense of the encoding of @filename, as a last resort it
1885  * replaces unknown characters with U+FFFD, the Unicode replacement character.
1886  * You can search the result for the UTF-8 encoding of this character (which is
1887  * &quot;\357\277\275&quot; in octal notation) to find out if @filename was in an invalid
1888  * encoding.
1889  *
1890  * You must pass the whole absolute pathname to this functions so that
1891  * translation of well known locations can be done.
1892  *
1893  * This function is preferred over g_filename_display_name() if you know the
1894  * whole path, as it allows translation.
1895  *
1896  * Returns: a newly allocated string containing
1897  *   a rendition of the basename of the filename in valid UTF-8
1898  *
1899  * Since: 2.6
1900  **/
1901 gchar *
1902 g_filename_display_basename (const gchar *filename)
1903 {
1904   char *basename;
1905   char *display_name;
1906 
1907   g_return_val_if_fail (filename != NULL, NULL);
1908 
1909   basename = g_path_get_basename (filename);
1910   display_name = g_filename_display_name (basename);
1911   g_free (basename);
1912   return display_name;
1913 }
1914 
1915 /**
1916  * g_filename_display_name:
1917  * @filename: (type filename): a pathname hopefully in the
1918  *     GLib file name encoding
1919  *
1920  * Converts a filename into a valid UTF-8 string. The conversion is
1921  * not necessarily reversible, so you should keep the original around
1922  * and use the return value of this function only for display purposes.
1923  * Unlike g_filename_to_utf8(), the result is guaranteed to be non-%NULL
1924  * even if the filename actually isn&#39;t in the GLib file name encoding.
1925  *
1926  * If GLib cannot make sense of the encoding of @filename, as a last resort it
1927  * replaces unknown characters with U+FFFD, the Unicode replacement character.
1928  * You can search the result for the UTF-8 encoding of this character (which is
1929  * &quot;\357\277\275&quot; in octal notation) to find out if @filename was in an invalid
1930  * encoding.
1931  *
1932  * If you know the whole pathname of the file you should use
1933  * g_filename_display_basename(), since that allows location-based
1934  * translation of filenames.
1935  *
1936  * Returns: a newly allocated string containing
1937  *   a rendition of the filename in valid UTF-8
1938  *
1939  * Since: 2.6
1940  **/
1941 gchar *
1942 g_filename_display_name (const gchar *filename)
1943 {
1944   gint i;
1945   const gchar **charsets;
1946   gchar *display_name = NULL;
1947   gboolean is_utf8;
1948 
1949   is_utf8 = g_get_filename_charsets (&amp;charsets);
1950 
1951   if (is_utf8)
1952     {
1953       if (g_utf8_validate (filename, -1, NULL))
<a name="93" id="anc93"></a><span class="line-modified">1954     display_name = g_strdup (filename);</span>
1955     }
1956 
1957   if (!display_name)
1958     {
1959       /* Try to convert from the filename charsets to UTF-8.
1960        * Skip the first charset if it is UTF-8.
1961        */
1962       for (i = is_utf8 ? 1 : 0; charsets[i]; i++)
<a name="94" id="anc94"></a><span class="line-modified">1963     {</span>
<span class="line-modified">1964       display_name = g_convert (filename, -1, &quot;UTF-8&quot;, charsets[i],</span>
<span class="line-modified">1965                     NULL, NULL, NULL);</span>
1966 
<a name="95" id="anc95"></a><span class="line-modified">1967       if (display_name)</span>
<span class="line-modified">1968         break;</span>
<span class="line-modified">1969     }</span>
1970     }
1971 
1972   /* if all conversions failed, we replace invalid UTF-8
1973    * by a question mark
1974    */
1975   if (!display_name)
1976     display_name = g_utf8_make_valid (filename, -1);
1977 
1978   return display_name;
1979 }
1980 
1981 #ifdef G_OS_WIN32
1982 
1983 /* Binary compatibility versions. Not for newly compiled code. */
1984 
1985 _GLIB_EXTERN gchar *g_filename_to_utf8_utf8   (const gchar  *opsysstring,
1986                                                gssize        len,
1987                                                gsize        *bytes_read,
1988                                                gsize        *bytes_written,
1989                                                GError      **error) G_GNUC_MALLOC;
1990 _GLIB_EXTERN gchar *g_filename_from_utf8_utf8 (const gchar  *utf8string,
1991                                                gssize        len,
1992                                                gsize        *bytes_read,
1993                                                gsize        *bytes_written,
1994                                                GError      **error) G_GNUC_MALLOC;
1995 _GLIB_EXTERN gchar *g_filename_from_uri_utf8  (const gchar  *uri,
1996                                                gchar       **hostname,
1997                                                GError      **error) G_GNUC_MALLOC;
1998 _GLIB_EXTERN gchar *g_filename_to_uri_utf8    (const gchar  *filename,
1999                                                const gchar  *hostname,
2000                                                GError      **error) G_GNUC_MALLOC;
2001 
2002 gchar *
2003 g_filename_to_utf8_utf8 (const gchar *opsysstring,
2004                          gssize       len,
2005                          gsize       *bytes_read,
2006                          gsize       *bytes_written,
2007                          GError     **error)
2008 {
2009   return g_filename_to_utf8 (opsysstring, len, bytes_read, bytes_written, error);
2010 }
2011 
2012 gchar *
2013 g_filename_from_utf8_utf8 (const gchar *utf8string,
2014                            gssize       len,
2015                            gsize       *bytes_read,
2016                            gsize       *bytes_written,
2017                            GError     **error)
2018 {
2019   return g_filename_from_utf8 (utf8string, len, bytes_read, bytes_written, error);
2020 }
2021 
2022 gchar *
2023 g_filename_from_uri_utf8 (const gchar *uri,
2024                           gchar      **hostname,
2025                           GError     **error)
2026 {
2027   return g_filename_from_uri (uri, hostname, error);
2028 }
2029 
2030 gchar *
2031 g_filename_to_uri_utf8 (const gchar *filename,
2032                         const gchar *hostname,
2033                         GError     **error)
2034 {
2035   return g_filename_to_uri (filename, hostname, error);
2036 }
2037 
2038 #endif
<a name="96" id="anc96"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="96" type="hidden" />
</body>
</html>