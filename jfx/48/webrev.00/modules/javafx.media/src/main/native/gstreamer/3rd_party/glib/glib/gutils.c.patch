diff a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gutils.c b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gutils.c
--- a/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gutils.c
+++ b/modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gutils.c
@@ -27,17 +27,18 @@
  */
 
 #include "config.h"
 
 #include "gutils.h"
+#include "gutilsprivate.h"
 
 #include <stdarg.h>
 #include <stdlib.h>
 #include <stdio.h>
 #include <locale.h>
 #include <string.h>
-#include <ctype.h>      /* For tolower() */
+#include <ctype.h>    /* For tolower() */
 #include <errno.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #ifdef G_OS_UNIX
 #include <pwd.h>
@@ -86,45 +87,19 @@
 #  include <windows.h>
 #  ifndef GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS
 #    define GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT 2
 #    define GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS 4
 #  endif
-#  include <lmcons.h>       /* For UNLEN */
+#  include <lmcons.h>   /* For UNLEN */
 #endif /* G_PLATFORM_WIN32 */
 
 #ifdef G_OS_WIN32
 #  include <direct.h>
 #  include <shlobj.h>
-   /* older SDK (e.g. msvc 5.0) does not have these*/
-#  ifndef CSIDL_MYMUSIC
-#    define CSIDL_MYMUSIC 13
-#  endif
-#  ifndef CSIDL_MYVIDEO
-#    define CSIDL_MYVIDEO 14
-#  endif
-#  ifndef CSIDL_INTERNET_CACHE
-#    define CSIDL_INTERNET_CACHE 32
-#  endif
-#  ifndef CSIDL_COMMON_APPDATA
-#    define CSIDL_COMMON_APPDATA 35
-#  endif
-#  ifndef CSIDL_MYPICTURES
-#    define CSIDL_MYPICTURES 0x27
-#  endif
-#  ifndef CSIDL_COMMON_DOCUMENTS
-#    define CSIDL_COMMON_DOCUMENTS 46
-#  endif
-#  ifndef CSIDL_PROFILE
-#    define CSIDL_PROFILE 40
-#  endif
 #  include <process.h>
 #endif
 
-#ifdef HAVE_CARBON
-#include <CoreServices/CoreServices.h>
-#endif
-
 #ifdef HAVE_CODESET
 #include <langinfo.h>
 #endif
 
 #ifdef G_PLATFORM_WIN32
@@ -221,10 +196,11 @@
  * calling g_atexit() (or atexit()) except in the main executable of a
  * program.
  *
  * Deprecated:2.32: It is best to avoid g_atexit().
  */
+G_GNUC_BEGIN_IGNORE_DEPRECATIONS
 void
 g_atexit (GVoidFunc func)
 {
   gint result;
   int errsv;
@@ -235,20 +211,21 @@
     {
       g_error ("Could not register atexit() function: %s",
                g_strerror (errsv));
     }
 }
+G_GNUC_END_IGNORE_DEPRECATIONS
 
 #endif // GSTREAMER_LITE
 
 /* Based on execvp() from GNU Libc.
  * Some of this code is cut-and-pasted into gspawn.c
  */
 
 static gchar*
 my_strchrnul (const gchar *str,
-          gchar        c)
+        gchar        c)
 {
   gchar *p = (gchar*)str;
   while (*p && (*p != c))
     ++p;
 
@@ -268,37 +245,37 @@
       strchr (last_dot, '\\') != NULL ||
       strchr (last_dot, '/') != NULL)
     {
       const gint program_length = strlen (program);
       gchar *pathext = g_build_path (";",
-                     ".exe;.cmd;.bat;.com",
-                     g_getenv ("PATHEXT"),
-                     NULL);
+             ".exe;.cmd;.bat;.com",
+             g_getenv ("PATHEXT"),
+             NULL);
       gchar *p;
       gchar *decorated_program;
       gchar *retval;
 
       p = pathext;
       do
-    {
-      gchar *q = my_strchrnul (p, ';');
+  {
+    gchar *q = my_strchrnul (p, ';');
 
-      decorated_program = g_malloc (program_length + (q-p) + 1);
-      memcpy (decorated_program, program, program_length);
-      memcpy (decorated_program+program_length, p, q-p);
-      decorated_program [program_length + (q-p)] = '\0';
+    decorated_program = g_malloc (program_length + (q-p) + 1);
+    memcpy (decorated_program, program, program_length);
+    memcpy (decorated_program+program_length, p, q-p);
+    decorated_program [program_length + (q-p)] = '\0';
 
-      retval = inner_find_program_in_path (decorated_program);
-      g_free (decorated_program);
+    retval = inner_find_program_in_path (decorated_program);
+    g_free (decorated_program);
 
-      if (retval != NULL)
-        {
-          g_free (pathext);
-          return retval;
-        }
-      p = q;
-    } while (*p++ != '\0');
+    if (retval != NULL)
+      {
+        g_free (pathext);
+        return retval;
+      }
+    p = q;
+  } while (*p++ != '\0');
       g_free (pathext);
       return NULL;
     }
   else
     return inner_find_program_in_path (program);
@@ -363,11 +340,11 @@
       || strchr (program, '/') != NULL
 #endif
       )
     {
       if (g_file_test (program, G_FILE_TEST_IS_EXECUTABLE) &&
-      !g_file_test (program, G_FILE_TEST_IS_DIR))
+    !g_file_test (program, G_FILE_TEST_IS_DIR))
         return g_strdup (program);
       else
         return NULL;
     }
 
@@ -470,17 +447,17 @@
         startp = name + 1;
       else
         startp = memcpy (name - (p - path), path, p - path);
 
       if (g_file_test (startp, G_FILE_TEST_IS_EXECUTABLE) &&
-      !g_file_test (startp, G_FILE_TEST_IS_DIR))
+    !g_file_test (startp, G_FILE_TEST_IS_DIR))
         {
           gchar *ret;
           ret = g_strdup (startp);
           g_free (freeme);
 #ifdef G_OS_WIN32
-      g_free ((gchar *) path_copy);
+    g_free ((gchar *) path_copy);
 #endif
           return ret;
         }
     }
   while (*p++ != '\0');
@@ -561,16 +538,17 @@
   gchar *user_name;
   gchar *real_name;
   gchar *home_dir;
 } UserDatabaseEntry;
 
+/* These must all be read/written with @g_utils_global held. */
 static  gchar   *g_user_data_dir = NULL;
 static  gchar  **g_system_data_dirs = NULL;
 static  gchar   *g_user_cache_dir = NULL;
 static  gchar   *g_user_config_dir = NULL;
+static  gchar   *g_user_runtime_dir = NULL;
 static  gchar  **g_system_config_dirs = NULL;
-
 static  gchar  **g_user_special_dirs = NULL;
 
 /* fifteen minutes of fame for everybody */
 #define G_USER_DIRS_EXPIRE      15 * 60
 
@@ -588,11 +566,11 @@
   hr = SHGetSpecialFolderLocation (NULL, csidl, &pidl);
   if (hr == S_OK)
     {
       b = SHGetPathFromIDListW (pidl, path);
       if (b)
-    retval = g_utf16_to_utf8 (path, -1, NULL, NULL, NULL);
+  retval = g_utf16_to_utf8 (path, -1, NULL, NULL, NULL);
       CoTaskMemFree (pidl);
     }
   return retval;
 }
 
@@ -608,15 +586,15 @@
        */
       char *windowsdir = g_utf16_to_utf8 (wwindowsdir, -1, NULL, NULL, NULL);
       char *p;
 
       if (windowsdir == NULL)
-    return g_strdup ("C:\\");
+  return g_strdup ("C:\\");
 
       p = (char *) g_path_skip_root (windowsdir);
       if (G_IS_DIR_SEPARATOR (p[-1]) && p[-2] != ':')
-    p--;
+  p--;
       *p = '\0';
       return windowsdir;
     }
   else
     return g_strdup ("C:\\");
@@ -796,10 +774,83 @@
   entry = g_get_user_database_entry ();
 
   return entry->real_name;
 }
 
+/* Protected by @g_utils_global_lock. */
+static gchar *g_home_dir = NULL;  /* (owned) (nullable before initialised) */
+
+static gchar *
+g_build_home_dir (void)
+{
+  gchar *home_dir;
+
+  /* We first check HOME and use it if it is set */
+  home_dir = g_strdup (g_getenv ("HOME"));
+
+#ifdef G_OS_WIN32
+  /* Only believe HOME if it is an absolute path and exists.
+   *
+   * We only do this check on Windows for a couple of reasons.
+   * Historically, we only did it there because we used to ignore $HOME
+   * on UNIX.  There are concerns about enabling it now on UNIX because
+   * of things like autofs.  In short, if the user has a bogus value in
+   * $HOME then they get what they pay for...
+   */
+  if (home_dir != NULL)
+    {
+      if (!(g_path_is_absolute (home_dir) &&
+            g_file_test (home_dir, G_FILE_TEST_IS_DIR)))
+        g_clear_pointer (&home_dir, g_free);
+    }
+
+  /* In case HOME is Unix-style (it happens), convert it to
+   * Windows style.
+   */
+  if (home_dir != NULL)
+    {
+      gchar *p;
+      while ((p = strchr (home_dir, '/')) != NULL)
+        *p = '\\';
+    }
+
+  if (home_dir == NULL)
+    {
+      /* USERPROFILE is probably the closest equivalent to $HOME? */
+      if (g_getenv ("USERPROFILE") != NULL)
+        home_dir = g_strdup (g_getenv ("USERPROFILE"));
+    }
+
+  if (home_dir == NULL)
+    home_dir = get_special_folder (CSIDL_PROFILE);
+
+  if (home_dir == NULL)
+    home_dir = get_windows_directory_root ();
+#endif /* G_OS_WIN32 */
+
+  if (home_dir == NULL)
+    {
+      /* If we didn't get it from any of those methods, we will have
+       * to read the user database entry.
+       */
+      UserDatabaseEntry *entry = g_get_user_database_entry ();
+      home_dir = g_strdup (entry->home_dir);
+    }
+
+  /* If we have been denied access to /etc/passwd (for example, by an
+   * overly-zealous LSM), make up a junk value. The return value at this
+   * point is explicitly documented as 'undefined'. */
+  if (home_dir == NULL)
+    {
+      g_warning ("Could not find home directory: $HOME is not set, and "
+                 "user database could not be read.");
+      home_dir = g_strdup ("/");
+    }
+
+  return g_steal_pointer (&home_dir);
+}
+
 /**
  * g_get_home_dir:
  *
  * Gets the current user's home directory.
  *
@@ -825,91 +876,19 @@
  * Returns: (type filename): the current user's home directory
  */
 const gchar *
 g_get_home_dir (void)
 {
-  static gchar *home_dir;
-
-  if (g_once_init_enter (&home_dir))
-    {
-      gchar *tmp;
+  const gchar *home_dir;
 
-      /* We first check HOME and use it if it is set */
-      tmp = g_strdup (g_getenv ("HOME"));
-
-#ifdef G_OS_WIN32
-      /* Only believe HOME if it is an absolute path and exists.
-       *
-       * We only do this check on Windows for a couple of reasons.
-       * Historically, we only did it there because we used to ignore $HOME
-       * on UNIX.  There are concerns about enabling it now on UNIX because
-       * of things like autofs.  In short, if the user has a bogus value in
-       * $HOME then they get what they pay for...
-       */
-      if (tmp)
-        {
-          if (!(g_path_is_absolute (tmp) &&
-                g_file_test (tmp, G_FILE_TEST_IS_DIR)))
-            {
-              g_free (tmp);
-              tmp = NULL;
-            }
-        }
-
-      /* In case HOME is Unix-style (it happens), convert it to
-       * Windows style.
-       */
-      if (tmp)
-        {
-          gchar *p;
-          while ((p = strchr (tmp, '/')) != NULL)
-            *p = '\\';
-        }
-
-      if (!tmp)
-        {
-          /* USERPROFILE is probably the closest equivalent to $HOME? */
-          if (g_getenv ("USERPROFILE") != NULL)
-            tmp = g_strdup (g_getenv ("USERPROFILE"));
-        }
-
-      if (!tmp)
-        tmp = get_special_folder (CSIDL_PROFILE);
-
-      if (!tmp)
-        tmp = get_windows_directory_root ();
-#endif /* G_OS_WIN32 */
-
-      if (!tmp)
-        {
-          /* If we didn't get it from any of those methods, we will have
-           * to read the user database entry.
-           */
-          UserDatabaseEntry *entry;
-
-          entry = g_get_user_database_entry ();
-
-          /* Strictly speaking, we should copy this, but we know that
-           * neither will ever be freed, so don't bother...
-           */
-          tmp = entry->home_dir;
-        }
+  G_LOCK (g_utils_global);
 
-      /* If we have been denied access to /etc/passwd (for example, by an
-       * overly-zealous LSM), make up a junk value. The return value at this
-       * point is explicitly documented as �?undefined’. Memory management is as
-       * immediately above: strictly this should be copied, but we know not
-       * copying it is OK. */
-      if (tmp == NULL)
-        {
-          g_warning ("Could not find home directory: $HOME is not set, and "
-                     "user database could not be read.");
-          tmp = "/";
-        }
+  if (g_home_dir == NULL)
+    g_home_dir = g_build_home_dir ();
+  home_dir = g_home_dir;
 
-      g_once_init_leave (&home_dir, tmp);
-    }
+  G_UNLOCK (g_utils_global);
 
   return home_dir;
 }
 
 /**
@@ -1008,12 +987,41 @@
     {
       gboolean failed;
       gchar *utmp;
 
 #ifndef G_OS_WIN32
-      gchar *tmp = g_malloc (sizeof (gchar) * 100);
-      failed = (gethostname (tmp, sizeof (gchar) * 100) == -1);
+      glong max;
+      gsize size;
+      /* The number 256 * 256 is taken from the value of _POSIX_HOST_NAME_MAX,
+       * which is 255. Since we use _POSIX_HOST_NAME_MAX + 1 (= 256) in the
+       * fallback case, we pick 256 * 256 as the size of the larger buffer here.
+       * It should be large enough. It doesn't looks reasonable to name a host
+       * with a string that is longer than 64 KiB.
+       */
+      const gsize size_large = (gsize) 256 * 256;
+      gchar *tmp;
+
+      max = sysconf (_SC_HOST_NAME_MAX);
+      if (max > 0 && max <= G_MAXSIZE - 1)
+        size = (gsize) max + 1;
+      else
+#ifdef HOST_NAME_MAX
+        size = HOST_NAME_MAX + 1;
+#else
+        size = _POSIX_HOST_NAME_MAX + 1;
+#endif
+
+      tmp = g_malloc (size);
+      failed = (gethostname (tmp, size) == -1);
+      if (failed && size < size_large)
+        {
+          /* Try again with a larger buffer if 'size' may be too small. */
+          g_free (tmp);
+          tmp = g_malloc (size_large);
+          failed = (gethostname (tmp, size_large) == -1);
+        }
+
       if (failed)
         g_clear_pointer (&tmp, g_free);
       utmp = tmp;
 #else
       wchar_t tmp[MAX_COMPUTERNAME_LENGTH + 1];
@@ -1044,42 +1052,20 @@
  * g_application_run(). In case of GDK or GTK+ it is set in
  * gdk_init(), which is called by gtk_init() and the
  * #GtkApplication::startup handler. The program name is found by
  * taking the last component of @argv[0].
  *
- * Returns: the name of the program. The returned string belongs
+ * Returns: (nullable): the name of the program, or %NULL if it has not been
+ *     set yet. The returned string belongs
  *     to GLib and must not be modified or freed.
  */
 const gchar*
 g_get_prgname (void)
 {
   gchar* retval;
 
   G_LOCK (g_prgname);
-#ifdef G_OS_WIN32
-  if (g_prgname == NULL)
-    {
-      static gboolean beenhere = FALSE;
-
-      if (!beenhere)
-    {
-      gchar *utf8_buf = NULL;
-      wchar_t buf[MAX_PATH+1];
-
-      beenhere = TRUE;
-      if (GetModuleFileNameW (GetModuleHandle (NULL),
-                  buf, G_N_ELEMENTS (buf)) > 0)
-        utf8_buf = g_utf16_to_utf8 (buf, -1, NULL, NULL, NULL);
-
-      if (utf8_buf)
-        {
-          g_prgname = g_path_get_basename (utf8_buf);
-          g_free (utf8_buf);
-        }
-    }
-    }
-#endif
   retval = g_prgname;
   G_UNLOCK (g_prgname);
 
   return retval;
 }
@@ -1173,10 +1159,139 @@
 
   if (already_set)
     g_warning ("g_set_application_name() called multiple times");
 }
 
+/* Set @global_str to a copy of @new_value if it's currently unset or has a
+ * different value. If its current value matches @new_value, do nothing. If
+ * replaced, we have to leak the old value as client code could still have
+ * pointers to it. */
+static void
+set_str_if_different (gchar       **global_str,
+                      const gchar  *type,
+                      const gchar  *new_value)
+{
+  if (*global_str == NULL ||
+      !g_str_equal (new_value, *global_str))
+    {
+      g_debug ("g_set_user_dirs: Setting %s to %s", type, new_value);
+
+      /* We have to leak the old value, as user code could be retaining pointers
+       * to it. */
+      *global_str = g_strdup (new_value);
+    }
+}
+
+static void
+set_strv_if_different (gchar                ***global_strv,
+                       const gchar            *type,
+                       const gchar  * const   *new_value)
+{
+  if (*global_strv == NULL ||
+      !g_strv_equal (new_value, (const gchar * const *) *global_strv))
+    {
+      gchar *new_value_str = g_strjoinv (":", (gchar **) new_value);
+      g_debug ("g_set_user_dirs: Setting %s to %s", type, new_value_str);
+      g_free (new_value_str);
+
+      /* We have to leak the old value, as user code could be retaining pointers
+       * to it. */
+      *global_strv = g_strdupv ((gchar **) new_value);
+    }
+}
+
+/*
+ * g_set_user_dirs:
+ * @first_dir_type: Type of the first directory to set
+ * @...: Value to set the first directory to, followed by additional type/value
+ *    pairs, followed by %NULL
+ *
+ * Set one or more 'user' directories to custom values. This is intended to be
+ * used by test code (particularly with the %G_TEST_OPTION_ISOLATE_DIRS option)
+ * to override the values returned by the following functions, so that test
+ * code can be run without touching an installed system and user data:
+ *
+ *  - g_get_home_dir() - use type `HOME`, pass a string
+ *  - g_get_user_cache_dir() - use type `XDG_CACHE_HOME`, pass a string
+ *  - g_get_system_config_dirs() - use type `XDG_CONFIG_DIRS`, pass a
+ *    %NULL-terminated string array
+ *  - g_get_user_config_dir() - use type `XDG_CONFIG_HOME`, pass a string
+ *  - g_get_system_data_dirs() - use type `XDG_DATA_DIRS`, pass a
+ *    %NULL-terminated string array
+ *  - g_get_user_data_dir() - use type `XDG_DATA_HOME`, pass a string
+ *  - g_get_user_runtime_dir() - use type `XDG_RUNTIME_DIR`, pass a string
+ *
+ * The list must be terminated with a %NULL type. All of the values must be
+ * non-%NULL - passing %NULL as a value won't reset a directory. If a reference
+ * to a directory from the calling environment needs to be kept, copy it before
+ * the first call to g_set_user_dirs(). g_set_user_dirs() can be called multiple
+ * times.
+ *
+ * Since: 2.60
+ */
+/*< private > */
+void
+g_set_user_dirs (const gchar *first_dir_type,
+                 ...)
+{
+  va_list args;
+  const gchar *dir_type;
+
+  G_LOCK (g_utils_global);
+
+  va_start (args, first_dir_type);
+
+  for (dir_type = first_dir_type; dir_type != NULL; dir_type = va_arg (args, const gchar *))
+    {
+      gconstpointer dir_value = va_arg (args, gconstpointer);
+      g_assert (dir_value != NULL);
+
+      if (g_str_equal (dir_type, "HOME"))
+        set_str_if_different (&g_home_dir, dir_type, dir_value);
+      else if (g_str_equal (dir_type, "XDG_CACHE_HOME"))
+        set_str_if_different (&g_user_cache_dir, dir_type, dir_value);
+      else if (g_str_equal (dir_type, "XDG_CONFIG_DIRS"))
+        set_strv_if_different (&g_system_config_dirs, dir_type, dir_value);
+      else if (g_str_equal (dir_type, "XDG_CONFIG_HOME"))
+        set_str_if_different (&g_user_config_dir, dir_type, dir_value);
+      else if (g_str_equal (dir_type, "XDG_DATA_DIRS"))
+        set_strv_if_different (&g_system_data_dirs, dir_type, dir_value);
+      else if (g_str_equal (dir_type, "XDG_DATA_HOME"))
+        set_str_if_different (&g_user_data_dir, dir_type, dir_value);
+      else if (g_str_equal (dir_type, "XDG_RUNTIME_DIR"))
+        set_str_if_different (&g_user_runtime_dir, dir_type, dir_value);
+      else
+        g_assert_not_reached ();
+    }
+
+  va_end (args);
+
+  G_UNLOCK (g_utils_global);
+}
+
+static gchar *
+g_build_user_data_dir (void)
+{
+  gchar *data_dir = NULL;
+  const gchar *data_dir_env = g_getenv ("XDG_DATA_HOME");
+
+  if (data_dir_env && data_dir_env[0])
+    data_dir = g_strdup (data_dir_env);
+#ifdef G_OS_WIN32
+  else
+    data_dir = get_special_folder (CSIDL_LOCAL_APPDATA);
+#endif
+  if (!data_dir || !data_dir[0])
+    {
+      gchar *home_dir = g_build_home_dir ();
+      data_dir = g_build_filename (home_dir, ".local", "share", NULL);
+      g_free (home_dir);
+    }
+
+  return g_steal_pointer (&data_dir);
+}
+
 /**
  * g_get_user_data_dir:
  *
  * Returns a base directory in which to access application data such
  * as icons that is customized for a particular user.
@@ -1198,71 +1313,43 @@
  * Since: 2.6
  **/
 const gchar *
 g_get_user_data_dir (void)
 {
-  gchar *data_dir = NULL;
+  const gchar *user_data_dir;
 
   G_LOCK (g_utils_global);
 
-  if (!g_user_data_dir)
-    {
-      const gchar *data_dir_env = g_getenv ("XDG_DATA_HOME");
-
-      if (data_dir_env && data_dir_env[0])
-        data_dir = g_strdup (data_dir_env);
-#ifdef G_OS_WIN32
-      else
-      data_dir = get_special_folder (CSIDL_LOCAL_APPDATA);
-#endif
-      if (!data_dir || !data_dir[0])
-    {
-          const gchar *home_dir = g_get_home_dir ();
-
-          if (home_dir)
-            data_dir = g_build_filename (home_dir, ".local", "share", NULL);
-      else
-            data_dir = g_build_filename (g_get_tmp_dir (), g_get_user_name (), ".local", "share", NULL);
-    }
-
-      g_user_data_dir = data_dir;
-    }
-  else
-    data_dir = g_user_data_dir;
+  if (g_user_data_dir == NULL)
+    g_user_data_dir = g_build_user_data_dir ();
+  user_data_dir = g_user_data_dir;
 
   G_UNLOCK (g_utils_global);
 
-  return data_dir;
+  return user_data_dir;
 }
 
-static void
-g_init_user_config_dir (void)
+static gchar *
+g_build_user_config_dir (void)
 {
   gchar *config_dir = NULL;
+  const gchar *config_dir_env = g_getenv ("XDG_CONFIG_HOME");
 
-  if (!g_user_config_dir)
-    {
-      const gchar *config_dir_env = g_getenv ("XDG_CONFIG_HOME");
-
-      if (config_dir_env && config_dir_env[0])
+  if (config_dir_env && config_dir_env[0])
     config_dir = g_strdup (config_dir_env);
 #ifdef G_OS_WIN32
-      else
-      config_dir = get_special_folder (CSIDL_LOCAL_APPDATA);
+  else
+    config_dir = get_special_folder (CSIDL_LOCAL_APPDATA);
 #endif
-      if (!config_dir || !config_dir[0])
+  if (!config_dir || !config_dir[0])
     {
-          const gchar *home_dir = g_get_home_dir ();
-
-          if (home_dir)
-            config_dir = g_build_filename (home_dir, ".config", NULL);
-      else
-            config_dir = g_build_filename (g_get_tmp_dir (), g_get_user_name (), ".config", NULL);
+      gchar *home_dir = g_build_home_dir ();
+      config_dir = g_build_filename (home_dir, ".config", NULL);
+      g_free (home_dir);
     }
 
-      g_user_config_dir = config_dir;
-    }
+  return g_steal_pointer (&config_dir);
 }
 
 /**
  * g_get_user_config_dir:
  *
@@ -1286,17 +1373,43 @@
  * Since: 2.6
  **/
 const gchar *
 g_get_user_config_dir (void)
 {
+  const gchar *user_config_dir;
+
   G_LOCK (g_utils_global);
 
-  g_init_user_config_dir ();
+  if (g_user_config_dir == NULL)
+    g_user_config_dir = g_build_user_config_dir ();
+  user_config_dir = g_user_config_dir;
 
   G_UNLOCK (g_utils_global);
 
-  return g_user_config_dir;
+  return user_config_dir;
+}
+
+static gchar *
+g_build_user_cache_dir (void)
+{
+  gchar *cache_dir = NULL;
+  const gchar *cache_dir_env = g_getenv ("XDG_CACHE_HOME");
+
+  if (cache_dir_env && cache_dir_env[0])
+    cache_dir = g_strdup (cache_dir_env);
+#ifdef G_OS_WIN32
+  else
+    cache_dir = get_special_folder (CSIDL_INTERNET_CACHE);
+#endif
+  if (!cache_dir || !cache_dir[0])
+    {
+      gchar *home_dir = g_build_home_dir ();
+      cache_dir = g_build_filename (home_dir, ".cache", NULL);
+      g_free (home_dir);
+    }
+
+  return g_steal_pointer (&cache_dir);
 }
 
 /**
  * g_get_user_cache_dir:
  *
@@ -1319,41 +1432,49 @@
  * Since: 2.6
  **/
 const gchar *
 g_get_user_cache_dir (void)
 {
-  gchar *cache_dir = NULL;
+  const gchar *user_cache_dir;
 
   G_LOCK (g_utils_global);
 
-  if (!g_user_cache_dir)
-    {
-      const gchar *cache_dir_env = g_getenv ("XDG_CACHE_HOME");
+  if (g_user_cache_dir == NULL)
+    g_user_cache_dir = g_build_user_cache_dir ();
+  user_cache_dir = g_user_cache_dir;
 
-      if (cache_dir_env && cache_dir_env[0])
-        cache_dir = g_strdup (cache_dir_env);
-#ifdef G_OS_WIN32
-      else
-        cache_dir = get_special_folder (CSIDL_INTERNET_CACHE);
-#endif
-      if (!cache_dir || !cache_dir[0])
-    {
-          const gchar *home_dir = g_get_home_dir ();
+  G_UNLOCK (g_utils_global);
 
-          if (home_dir)
-            cache_dir = g_build_filename (home_dir, ".cache", NULL);
-      else
-            cache_dir = g_build_filename (g_get_tmp_dir (), g_get_user_name (), ".cache", NULL);
-    }
-      g_user_cache_dir = cache_dir;
-    }
+  return user_cache_dir;
+}
+
+static gchar *
+g_build_user_runtime_dir (void)
+{
+  gchar *runtime_dir = NULL;
+  const gchar *runtime_dir_env = g_getenv ("XDG_RUNTIME_DIR");
+
+  if (runtime_dir_env && runtime_dir_env[0])
+    runtime_dir = g_strdup (runtime_dir_env);
   else
-    cache_dir = g_user_cache_dir;
+    {
+      runtime_dir = g_build_user_cache_dir ();
 
-  G_UNLOCK (g_utils_global);
+      /* The user should be able to rely on the directory existing
+       * when the function returns.  Probably it already does, but
+       * let's make sure.  Just do mkdir() directly since it will be
+       * no more expensive than a stat() in the case that the
+       * directory already exists and is a lot easier.
+       *
+       * $XDG_CACHE_HOME is probably ~/.cache/ so as long as $HOME
+       * exists this will work.  If the user changed $XDG_CACHE_HOME
+       * then they can make sure that it exists...
+       */
+      (void) g_mkdir (runtime_dir, 0700);
+    }
 
-  return cache_dir;
+  return g_steal_pointer (&runtime_dir);
 }
 
 /**
  * g_get_user_runtime_dir:
  *
@@ -1374,116 +1495,54 @@
  * Since: 2.28
  **/
 const gchar *
 g_get_user_runtime_dir (void)
 {
-  static const gchar *runtime_dir;
-
-  if (g_once_init_enter (&runtime_dir))
-    {
-      const gchar *dir;
-
-      dir = g_strdup (getenv ("XDG_RUNTIME_DIR"));
+  const gchar *user_runtime_dir;
 
-      if (dir == NULL)
-        {
-          /* No need to strdup this one since it is valid forever. */
-          dir = g_get_user_cache_dir ();
-
-          /* The user should be able to rely on the directory existing
-           * when the function returns.  Probably it already does, but
-           * let's make sure.  Just do mkdir() directly since it will be
-           * no more expensive than a stat() in the case that the
-           * directory already exists and is a lot easier.
-           *
-           * $XDG_CACHE_HOME is probably ~/.cache/ so as long as $HOME
-           * exists this will work.  If the user changed $XDG_CACHE_HOME
-           * then they can make sure that it exists...
-   */
-          (void) g_mkdir (dir, 0700);
-        }
+  G_LOCK (g_utils_global);
 
-      g_assert (dir != NULL);
+  if (g_user_runtime_dir == NULL)
+    g_user_runtime_dir = g_build_user_runtime_dir ();
+  user_runtime_dir = g_user_runtime_dir;
 
-      g_once_init_leave (&runtime_dir, dir);
-}
+  G_UNLOCK (g_utils_global);
 
-  return runtime_dir;
+  return user_runtime_dir;
 }
 
-#ifdef HAVE_CARBON
+#ifdef HAVE_COCOA
 
-static gchar *
-find_folder (OSType type)
-{
-  gchar *filename = NULL;
-  FSRef  found;
-
-  if (FSFindFolder (kUserDomain, type, kDontCreateFolder, &found) == noErr)
-    {
-      CFURLRef url = CFURLCreateFromFSRef (kCFAllocatorSystemDefault, &found);
-
-      if (url)
-    {
-      CFStringRef path = CFURLCopyFileSystemPath (url, kCFURLPOSIXPathStyle);
-
-      if (path)
-        {
-          filename = g_strdup (CFStringGetCStringPtr (path, kCFStringEncodingUTF8));
-
-          if (! filename)
-        {
-          filename = g_new0 (gchar, CFStringGetLength (path) * 3 + 1);
-
-          CFStringGetCString (path, filename,
-                      CFStringGetLength (path) * 3 + 1,
-                      kCFStringEncodingUTF8);
-        }
-
-          CFRelease (path);
-        }
-
-      CFRelease (url);
-    }
-    }
-
-  return filename;
-}
+/* Implemented in gutils-macos.m */
+void load_user_special_dirs_macos (gchar **table);
 
 static void
 load_user_special_dirs (void)
 {
-  g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = find_folder (kDesktopFolderType);
-  g_user_special_dirs[G_USER_DIRECTORY_DOCUMENTS] = find_folder (kDocumentsFolderType);
-  g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = find_folder (kDesktopFolderType); /* XXX correct ? */
-  g_user_special_dirs[G_USER_DIRECTORY_MUSIC] = find_folder (kMusicDocumentsFolderType);
-  g_user_special_dirs[G_USER_DIRECTORY_PICTURES] = find_folder (kPictureDocumentsFolderType);
-  g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = NULL;
-  g_user_special_dirs[G_USER_DIRECTORY_TEMPLATES] = NULL;
-  g_user_special_dirs[G_USER_DIRECTORY_VIDEOS] = find_folder (kMovieDocumentsFolderType);
+  load_user_special_dirs_macos (g_user_special_dirs);
 }
 
 #elif defined(G_OS_WIN32)
 
 static void
 load_user_special_dirs (void)
 {
   typedef HRESULT (WINAPI *t_SHGetKnownFolderPath) (const GUID *rfid,
-                            DWORD dwFlags,
-                            HANDLE hToken,
-                            PWSTR *ppszPath);
+                DWORD dwFlags,
+                HANDLE hToken,
+                PWSTR *ppszPath);
   t_SHGetKnownFolderPath p_SHGetKnownFolderPath;
 
   static const GUID FOLDERID_Downloads =
     { 0x374de290, 0x123f, 0x4565, { 0x91, 0x64, 0x39, 0xc4, 0x92, 0x5e, 0x46, 0x7b } };
   static const GUID FOLDERID_Public =
     { 0xDFDF76A2, 0xC82A, 0x4D63, { 0x90, 0x6A, 0x56, 0x44, 0xAC, 0x45, 0x73, 0x85 } };
 
   wchar_t *wcp;
 
   p_SHGetKnownFolderPath = (t_SHGetKnownFolderPath) GetProcAddress (GetModuleHandle ("shell32.dll"),
-                                    "SHGetKnownFolderPath");
+                    "SHGetKnownFolderPath");
 
   g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
   g_user_special_dirs[G_USER_DIRECTORY_DOCUMENTS] = get_special_folder (CSIDL_PERSONAL);
 
   if (p_SHGetKnownFolderPath == NULL)
@@ -1559,19 +1618,21 @@
  * SOFTWARE.
  */
 static void
 load_user_special_dirs (void)
 {
+  gchar *config_dir = NULL;
   gchar *config_file;
   gchar *data;
   gchar **lines;
   gint n_lines, i;
 
-  g_init_user_config_dir ();
-  config_file = g_build_filename (g_user_config_dir,
+  config_dir = g_build_user_config_dir ();
+  config_file = g_build_filename (config_dir,
                                   "user-dirs.dirs",
                                   NULL);
+  g_free (config_dir);
 
   if (!g_file_get_contents (config_file, &data, NULL, NULL))
     {
       g_free (config_file);
       return;
@@ -1590,15 +1651,15 @@
       GUserDirectory directory;
 
       /* Remove newline at end */
       len = strlen (buffer);
       if (len > 0 && buffer[len - 1] == '\n')
-    buffer[len - 1] = 0;
+  buffer[len - 1] = 0;
 
       p = buffer;
       while (*p == ' ' || *p == '\t')
-    p++;
+  p++;
 
       if (strncmp (p, "XDG_DESKTOP_DIR", strlen ("XDG_DESKTOP_DIR")) == 0)
         {
           directory = G_USER_DIRECTORY_DESKTOP;
           p += strlen ("XDG_DESKTOP_DIR");
@@ -1637,33 +1698,33 @@
         {
           directory = G_USER_DIRECTORY_VIDEOS;
           p += strlen ("XDG_VIDEOS_DIR");
         }
       else
-    continue;
+  continue;
 
       while (*p == ' ' || *p == '\t')
-    p++;
+  p++;
 
       if (*p != '=')
-    continue;
+  continue;
       p++;
 
       while (*p == ' ' || *p == '\t')
-    p++;
+  p++;
 
       if (*p != '"')
-    continue;
+  continue;
       p++;
 
       if (strncmp (p, "$HOME", 5) == 0)
-    {
-      p += 5;
-      is_relative = TRUE;
-    }
+  {
+    p += 5;
+    is_relative = TRUE;
+  }
       else if (*p != '/')
-    continue;
+  continue;
 
       d = strrchr (p, '"');
       if (!d)
         continue;
       *d = 0;
@@ -1675,14 +1736,16 @@
       if (d[len - 1] == '/')
         d[len - 1] = 0;
 
       if (is_relative)
         {
-          g_user_special_dirs[directory] = g_build_filename (g_get_home_dir (), d, NULL);
+          gchar *home_dir = g_build_home_dir ();
+          g_user_special_dirs[directory] = g_build_filename (home_dir, d, NULL);
+          g_free (home_dir);
         }
       else
-    g_user_special_dirs[directory] = g_strdup (d);
+  g_user_special_dirs[directory] = g_strdup (d);
     }
 
   g_strfreev (lines);
   g_free (config_file);
 }
@@ -1695,11 +1758,11 @@
  *
  * Resets the cache used for g_get_user_special_dir(), so
  * that the latest on-disk version is used. Call this only
  * if you just changed the data on disk yourself.
  *
- * Due to threadsafety issues this may cause leaking of strings
+ * Due to thread safety issues this may cause leaking of strings
  * that were previously returned from g_get_user_special_dir()
  * that can't be freed. We ensure to only leak the data for
  * the directories that actually changed value though.
  *
  * Since: 2.22
@@ -1768,10 +1831,12 @@
  * Since: 2.14
  */
 const gchar *
 g_get_user_special_dir (GUserDirectory directory)
 {
+  const gchar *user_special_dir;
+
   g_return_val_if_fail (directory >= G_USER_DIRECTORY_DESKTOP &&
                         directory < G_USER_N_DIRECTORIES, NULL);
 
   G_LOCK (g_utils_global);
 
@@ -1781,16 +1846,21 @@
 
       load_user_special_dirs ();
 
       /* Special-case desktop for historical compatibility */
       if (g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] == NULL)
-        g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = g_build_filename (g_get_home_dir (), "Desktop", NULL);
+        {
+          gchar *home_dir = g_build_home_dir ();
+          g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = g_build_filename (home_dir, "Desktop", NULL);
+          g_free (home_dir);
+        }
     }
+  user_special_dir = g_user_special_dirs[directory];
 
   G_UNLOCK (g_utils_global);
 
-  return g_user_special_dirs[directory];
+  return user_special_dir;
 }
 
 #ifdef G_OS_WIN32
 
 #undef g_get_system_data_dirs
@@ -1809,19 +1879,19 @@
     return NULL;
 
   if (!beenhere)
     {
       p_GetModuleHandleExA =
-    (t_GetModuleHandleExA) GetProcAddress (GetModuleHandle ("kernel32.dll"),
-                           "GetModuleHandleExA");
+  (t_GetModuleHandleExA) GetProcAddress (GetModuleHandle ("kernel32.dll"),
+                 "GetModuleHandleExA");
       beenhere = TRUE;
     }
 
   if (p_GetModuleHandleExA == NULL ||
       !(*p_GetModuleHandleExA) (GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT |
-                GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,
-                address, &hmodule))
+        GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,
+        address, &hmodule))
     {
       MEMORY_BASIC_INFORMATION mbi;
       VirtualQuery (address, &mbi, sizeof (mbi));
       hmodule = (HMODULE) mbi.AllocationBase;
     }
@@ -1861,24 +1931,24 @@
   if (address_of_function)
     {
       G_LOCK (g_utils_global);
       hmodule = get_module_for_address (address_of_function);
       if (hmodule != NULL)
-    {
-      if (per_module_data_dirs == NULL)
-        per_module_data_dirs = g_hash_table_new (NULL, NULL);
-      else
-        {
-          retval = g_hash_table_lookup (per_module_data_dirs, hmodule);
+  {
+    if (per_module_data_dirs == NULL)
+      per_module_data_dirs = g_hash_table_new (NULL, NULL);
+    else
+      {
+        retval = g_hash_table_lookup (per_module_data_dirs, hmodule);
 
-          if (retval != NULL)
-        {
-          G_UNLOCK (g_utils_global);
-          return (const gchar * const *) retval;
-        }
-        }
+        if (retval != NULL)
+    {
+      G_UNLOCK (g_utils_global);
+      return (const gchar * const *) retval;
     }
+      }
+  }
     }
 
   data_dirs = g_array_new (TRUE, TRUE, sizeof (char *));
 
   /* Documents and Settings\All Users\Application Data */
@@ -1920,11 +1990,11 @@
   if (glib_dll != NULL)
     {
       gchar *glib_root = g_win32_get_package_installation_directory_of_module (glib_dll);
       p = g_build_filename (glib_root, "share", NULL);
       if (p)
-    g_array_append_val (data_dirs, p);
+  g_array_append_val (data_dirs, p);
       g_free (glib_root);
     }
 
   exe_root = g_win32_get_package_installation_directory_of_module (NULL);
   p = g_build_filename (exe_root, "share", NULL);
@@ -1935,11 +2005,11 @@
   retval = (gchar **) g_array_free (data_dirs, FALSE);
 
   if (address_of_function)
     {
       if (hmodule != NULL)
-    g_hash_table_insert (per_module_data_dirs, hmodule, retval);
+  g_hash_table_insert (per_module_data_dirs, hmodule, retval);
       G_UNLOCK (g_utils_global);
     }
 
   return (const gchar * const *) retval;
 }
@@ -1948,11 +2018,11 @@
 g_win32_get_system_data_dirs_for_module (void (*address_of_function)(void))
 {
   gboolean should_call_g_get_system_data_dirs;
 
   should_call_g_get_system_data_dirs = TRUE;
-  /* These checks are the same as the ones that g_get_system_data_dirs() does.
+  /* These checks are the same as the ones that g_build_system_data_dirs() does.
    * Please keep them in sync.
    */
   G_LOCK (g_utils_global);
 
   if (!g_system_data_dirs)
@@ -1992,10 +2062,34 @@
   return g_win32_get_system_data_dirs_for_module_real (address_of_function);
 }
 
 #endif
 
+static gchar **
+g_build_system_data_dirs (void)
+{
+  gchar **data_dir_vector = NULL;
+  gchar *data_dirs = (gchar *) g_getenv ("XDG_DATA_DIRS");
+
+  /* These checks are the same as the ones that g_win32_get_system_data_dirs_for_module()
+   * does. Please keep them in sync.
+   */
+#ifndef G_OS_WIN32
+  if (!data_dirs || !data_dirs[0])
+    data_dirs = "/usr/local/share/:/usr/share/";
+
+  data_dir_vector = g_strsplit (data_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
+#else
+  if (!data_dirs || !data_dirs[0])
+    data_dir_vector = g_strdupv ((gchar **) g_win32_get_system_data_dirs_for_module_real (NULL));
+  else
+    data_dir_vector = g_strsplit (data_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
+#endif
+
+  return g_steal_pointer (&data_dir_vector);
+}
+
 /**
  * g_get_system_data_dirs:
  *
  * Returns an ordered list of base directories in which to access
  * system-wide application data.
@@ -2036,41 +2130,53 @@
  * Since: 2.6
  **/
 const gchar * const *
 g_get_system_data_dirs (void)
 {
-  gchar **data_dir_vector;
+  const gchar * const *system_data_dirs;
 
-  /* These checks are the same as the ones that g_win32_get_system_data_dirs_for_module()
-   * does. Please keep them in sync.
-   */
   G_LOCK (g_utils_global);
 
-  if (!g_system_data_dirs)
-    {
-      gchar *data_dirs = (gchar *) g_getenv ("XDG_DATA_DIRS");
+  if (g_system_data_dirs == NULL)
+    g_system_data_dirs = g_build_system_data_dirs ();
+  system_data_dirs = (const gchar * const *) g_system_data_dirs;
 
-#ifndef G_OS_WIN32
-      if (!data_dirs || !data_dirs[0])
-          data_dirs = "/usr/local/share/:/usr/share/";
+  G_UNLOCK (g_utils_global);
 
-      data_dir_vector = g_strsplit (data_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
-#else
-      if (!data_dirs || !data_dirs[0])
-        data_dir_vector = g_strdupv ((gchar **) g_win32_get_system_data_dirs_for_module_real (NULL));
-      else
-        data_dir_vector = g_strsplit (data_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
-#endif
+  return system_data_dirs;
+}
 
-      g_system_data_dirs = data_dir_vector;
+static gchar **
+g_build_system_config_dirs (void)
+{
+  gchar **conf_dir_vector = NULL;
+  const gchar *conf_dirs = g_getenv ("XDG_CONFIG_DIRS");
+#ifdef G_OS_WIN32
+  if (conf_dirs)
+    {
+      conf_dir_vector = g_strsplit (conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
     }
   else
-    data_dir_vector = g_system_data_dirs;
+    {
+      gchar *special_conf_dirs = get_special_folder (CSIDL_COMMON_APPDATA);
 
-  G_UNLOCK (g_utils_global);
+      if (special_conf_dirs)
+        conf_dir_vector = g_strsplit (special_conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
+      else
+        /* Return empty list */
+        conf_dir_vector = g_strsplit ("", G_SEARCHPATH_SEPARATOR_S, 0);
 
-  return (const gchar * const *) data_dir_vector;
+      g_free (special_conf_dirs);
+    }
+#else
+  if (!conf_dirs || !conf_dirs[0])
+    conf_dirs = "/etc/xdg";
+
+  conf_dir_vector = g_strsplit (conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
+#endif
+
+  return g_steal_pointer (&conf_dir_vector);
 }
 
 /**
  * g_get_system_config_dirs:
  *
@@ -2099,48 +2205,21 @@
  * Since: 2.6
  **/
 const gchar * const *
 g_get_system_config_dirs (void)
 {
-  gchar **conf_dir_vector;
+  const gchar * const *system_config_dirs;
 
   G_LOCK (g_utils_global);
 
-  if (!g_system_config_dirs)
-    {
-      const gchar *conf_dirs = g_getenv ("XDG_CONFIG_DIRS");
-#ifdef G_OS_WIN32
-      if (conf_dirs)
-    {
-      conf_dir_vector = g_strsplit (conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
-    }
-      else
-    {
-      gchar *special_conf_dirs = get_special_folder (CSIDL_COMMON_APPDATA);
-
-      if (special_conf_dirs)
-        conf_dir_vector = g_strsplit (special_conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
-      else
-      /* Return empty list */
-      conf_dir_vector = g_strsplit ("", G_SEARCHPATH_SEPARATOR_S, 0);
+  if (g_system_config_dirs == NULL)
+    g_system_config_dirs = g_build_system_config_dirs ();
+  system_config_dirs = (const gchar * const *) g_system_config_dirs;
 
-      g_free (special_conf_dirs);
-    }
-#else
-      if (!conf_dirs || !conf_dirs[0])
-          conf_dirs = "/etc/xdg";
-
-      conf_dir_vector = g_strsplit (conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
-#endif
-
-      g_system_config_dirs = conf_dir_vector;
-    }
-  else
-    conf_dir_vector = g_system_config_dirs;
   G_UNLOCK (g_utils_global);
 
-  return (const gchar * const *) conf_dir_vector;
+  return system_config_dirs;
 }
 
 /**
  * g_nullify_pointer:
  * @nullify_location: (not nullable): the memory address of the pointer.
@@ -2174,11 +2253,13 @@
  * @size: a size in bytes
  *
  * Formats a size (for example the size of a file) into a human readable
  * string.  Sizes are rounded to the nearest size prefix (kB, MB, GB)
  * and are displayed rounded to the nearest tenth. E.g. the file size
- * 3292528 bytes will be converted into the string "3.2 MB".
+ * 3292528 bytes will be converted into the string "3.2 MB". The returned string
+ * is UTF-8, and may use a non-breaking space to separate the number and units,
+ * to ensure they aren't separated when line wrapped.
  *
  * The prefix units base is 1000 (i.e. 1 kB is 1000 bytes).
  *
  * This string should be freed with g_free() when not needed any longer.
  *
@@ -2241,11 +2322,11 @@
                     GFormatSizeFlags flags)
 {
   struct Format
   {
     guint64 factor;
-    char string[9];
+    char string[10];
   };
 
   typedef enum
   {
     FORMAT_BYTES,
@@ -2254,41 +2335,65 @@
     FORMAT_BITS_IEC
   } FormatIndex;
 
   const struct Format formats[4][6] = {
     {
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { KILOBYTE_FACTOR, N_("%.1f kB") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { MEGABYTE_FACTOR, N_("%.1f MB") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { GIGABYTE_FACTOR, N_("%.1f GB") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { TERABYTE_FACTOR, N_("%.1f TB") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { PETABYTE_FACTOR, N_("%.1f PB") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { EXABYTE_FACTOR,  N_("%.1f EB") }
     },
-        {
+    {
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { KIBIBYTE_FACTOR, N_("%.1f KiB") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { MEBIBYTE_FACTOR, N_("%.1f MiB") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { GIBIBYTE_FACTOR, N_("%.1f GiB") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { TEBIBYTE_FACTOR, N_("%.1f TiB") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { PEBIBYTE_FACTOR, N_("%.1f PiB") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { EXBIBYTE_FACTOR, N_("%.1f EiB") }
     },
     {
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { KILOBYTE_FACTOR, N_("%.1f kb") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { MEGABYTE_FACTOR, N_("%.1f Mb") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { GIGABYTE_FACTOR, N_("%.1f Gb") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { TERABYTE_FACTOR, N_("%.1f Tb") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { PETABYTE_FACTOR, N_("%.1f Pb") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { EXABYTE_FACTOR,  N_("%.1f Eb") }
     },
     {
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { KIBIBYTE_FACTOR, N_("%.1f Kib") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { MEBIBYTE_FACTOR, N_("%.1f Mib") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { GIBIBYTE_FACTOR, N_("%.1f Gib") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { TEBIBYTE_FACTOR, N_("%.1f Tib") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { PEBIBYTE_FACTOR, N_("%.1f Pib") },
+      /* Translators: Keep the no-break space between %.1f and the unit symbol */
       { EXBIBYTE_FACTOR, N_("%.1f Eib") }
-        }
+    }
   };
 
   GString *string;
   FormatIndex index;
 
@@ -2318,13 +2423,13 @@
       const char * format;
 
       if (index == FORMAT_BYTES || index == FORMAT_BYTES_IEC)
         {
           format = g_dngettext (GETTEXT_PACKAGE, "%u byte", "%u bytes", (guint) size);
-    }
-  else
-    {
+        }
+      else
+        {
           format = g_dngettext (GETTEXT_PACKAGE, "%u bit", "%u bits", (guint) size);
         }
 
       g_string_printf (string, format, (guint) size);
 
@@ -2387,28 +2492,19 @@
       const gchar *translated_format;
       gchar *formatted_number;
 
       if (index == FORMAT_BYTES || index == FORMAT_BYTES_IEC)
         {
-      /* Translators: the %s in "%s bytes" will always be replaced by a number. */
+          /* Translators: the %s in "%s bytes" will always be replaced by a number. */
           translated_format = g_dngettext (GETTEXT_PACKAGE, "%s byte", "%s bytes", plural_form);
         }
       else
         {
           /* Translators: the %s in "%s bits" will always be replaced by a number. */
           translated_format = g_dngettext (GETTEXT_PACKAGE, "%s bit", "%s bits", plural_form);
         }
-      /* XXX: Windows doesn't support the "'" format modifier, so we
-       * must not use it there.  Instead, just display the number
-       * without separation.  Bug #655336 is open until a solution is
-       * found.
-       */
-#ifndef G_OS_WIN32
       formatted_number = g_strdup_printf ("%'"G_GUINT64_FORMAT, size);
-#else
-      formatted_number = g_strdup_printf ("%"G_GUINT64_FORMAT, size);
-#endif
 
       g_string_append (string, " (");
       g_string_append_printf (string, translated_format, formatted_number);
       g_free (formatted_number);
       g_string_append (string, ")");
@@ -2522,11 +2618,11 @@
  * Returns %TRUE if the current process was executed as setuid
  */
 gboolean
 g_check_setuid (void)
 {
-#if defined(HAVE_SYS_AUXV_H)
+#if defined(HAVE_SYS_AUXV_H) && defined(HAVE_GETAUXVAL) && defined(AT_SECURE)
   unsigned long value;
   int errsv;
 
   errno = 0;
   value = getauxval (AT_SECURE);
