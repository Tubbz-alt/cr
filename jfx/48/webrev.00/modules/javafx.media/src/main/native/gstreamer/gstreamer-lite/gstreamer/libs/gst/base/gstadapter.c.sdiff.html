<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstadapter.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="base.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstbaseparse.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gstreamer/libs/gst/base/gstadapter.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 110  * memcpy() operation, and these operations are not the fastest. Because of
 111  * this, some functions like gst_adapter_available_fast() are provided to help
 112  * speed up such cases should you want to. To avoid repeated memory allocations,
 113  * gst_adapter_copy() can be used to copy data into a (statically allocated)
 114  * user provided buffer.
 115  *
 116  * #GstAdapter is not MT safe. All operations on an adapter must be serialized by
 117  * the caller. This is not normally a problem, however, as the normal use case
 118  * of #GstAdapter is inside one pad&#39;s chain function, in which case access is
 119  * serialized via the pad&#39;s STREAM_LOCK.
 120  *
 121  * Note that gst_adapter_push() takes ownership of the buffer passed. Use
 122  * gst_buffer_ref() before pushing it into the adapter if you still want to
 123  * access the buffer later. The adapter will never modify the data in the
 124  * buffer pushed in it.
 125  */
 126 
 127 #include &lt;gst/gst_private.h&gt;
 128 #include &quot;gstadapter.h&quot;
 129 #include &lt;string.h&gt;

 130 
 131 /* default size for the assembled data buffer */
 132 #define DEFAULT_SIZE 4096
 133 
 134 static void gst_adapter_flush_unchecked (GstAdapter * adapter, gsize flush);
 135 
 136 GST_DEBUG_CATEGORY_STATIC (gst_adapter_debug);
 137 #define GST_CAT_DEFAULT gst_adapter_debug
 138 
 139 struct _GstAdapter
 140 {
 141   GObject object;
 142 
 143   /*&lt; private &gt; */
<span class="line-modified"> 144   GSList *buflist;</span>
<span class="line-removed"> 145   GSList *buflist_end;</span>
 146   gsize size;
 147   gsize skip;
 148   guint count;
 149 
 150   /* we keep state of assembled pieces */
 151   gpointer assembled_data;
 152   gsize assembled_size;
 153   gsize assembled_len;
 154 
 155   GstClockTime pts;
 156   guint64 pts_distance;
 157   GstClockTime dts;
 158   guint64 dts_distance;
 159   guint64 offset;
 160   guint64 offset_distance;
 161 
 162   gsize scan_offset;
<span class="line-modified"> 163   GSList *scan_entry;</span>

 164 
 165   GstClockTime pts_at_discont;
 166   GstClockTime dts_at_discont;
 167   guint64 offset_at_discont;
 168 
 169   guint64 distance_from_discont;
 170 
 171   GstMapInfo info;
 172 };
 173 
 174 struct _GstAdapterClass
 175 {
 176   GObjectClass parent_class;
 177 };
 178 
 179 #define _do_init \
 180   GST_DEBUG_CATEGORY_INIT (gst_adapter_debug, &quot;adapter&quot;, 0, &quot;object to splice and merge buffers to desired size&quot;)
 181 #define gst_adapter_parent_class parent_class
 182 G_DEFINE_TYPE_WITH_CODE (GstAdapter, gst_adapter, G_TYPE_OBJECT, _do_init);
 183 
</pre>
<hr />
<pre>
 191 
 192   object-&gt;dispose = gst_adapter_dispose;
 193   object-&gt;finalize = gst_adapter_finalize;
 194 }
 195 
 196 static void
 197 gst_adapter_init (GstAdapter * adapter)
 198 {
 199   adapter-&gt;assembled_data = g_malloc (DEFAULT_SIZE);
 200   adapter-&gt;assembled_size = DEFAULT_SIZE;
 201   adapter-&gt;pts = GST_CLOCK_TIME_NONE;
 202   adapter-&gt;pts_distance = 0;
 203   adapter-&gt;dts = GST_CLOCK_TIME_NONE;
 204   adapter-&gt;dts_distance = 0;
 205   adapter-&gt;offset = GST_BUFFER_OFFSET_NONE;
 206   adapter-&gt;offset_distance = 0;
 207   adapter-&gt;pts_at_discont = GST_CLOCK_TIME_NONE;
 208   adapter-&gt;dts_at_discont = GST_CLOCK_TIME_NONE;
 209   adapter-&gt;offset_at_discont = GST_BUFFER_OFFSET_NONE;
 210   adapter-&gt;distance_from_discont = 0;

 211 }
 212 
 213 static void
 214 gst_adapter_dispose (GObject * object)
 215 {
 216   GstAdapter *adapter = GST_ADAPTER (object);
 217 
 218   gst_adapter_clear (adapter);
 219 
 220   GST_CALL_PARENT (G_OBJECT_CLASS, dispose, (object));
 221 }
 222 
 223 static void
 224 gst_adapter_finalize (GObject * object)
 225 {
 226   GstAdapter *adapter = GST_ADAPTER (object);
 227 
 228   g_free (adapter-&gt;assembled_data);
 229 


 230   GST_CALL_PARENT (G_OBJECT_CLASS, finalize, (object));
 231 }
 232 
 233 /**
 234  * gst_adapter_new:
 235  *
 236  * Creates a new #GstAdapter. Free with g_object_unref().
 237  *
 238  * Returns: (transfer full): a new #GstAdapter
 239  */
 240 GstAdapter *
 241 gst_adapter_new (void)
 242 {
 243   return g_object_new (GST_TYPE_ADAPTER, NULL);
 244 }
 245 
 246 /**
 247  * gst_adapter_clear:
 248  * @adapter: a #GstAdapter
 249  *
 250  * Removes all buffers from @adapter.
 251  */
 252 void
 253 gst_adapter_clear (GstAdapter * adapter)
 254 {

 255   g_return_if_fail (GST_IS_ADAPTER (adapter));
 256 
 257   if (adapter-&gt;info.memory)
 258     gst_adapter_unmap (adapter);
 259 
<span class="line-modified"> 260   g_slist_foreach (adapter-&gt;buflist, (GFunc) gst_mini_object_unref, NULL);</span>
<span class="line-modified"> 261   g_slist_free (adapter-&gt;buflist);</span>
<span class="line-modified"> 262   adapter-&gt;buflist = NULL;</span>
<span class="line-removed"> 263   adapter-&gt;buflist_end = NULL;</span>
 264   adapter-&gt;count = 0;
 265   adapter-&gt;size = 0;
 266   adapter-&gt;skip = 0;
 267   adapter-&gt;assembled_len = 0;
 268   adapter-&gt;pts = GST_CLOCK_TIME_NONE;
 269   adapter-&gt;pts_distance = 0;
 270   adapter-&gt;dts = GST_CLOCK_TIME_NONE;
 271   adapter-&gt;dts_distance = 0;
 272   adapter-&gt;offset = GST_BUFFER_OFFSET_NONE;
 273   adapter-&gt;offset_distance = 0;
 274   adapter-&gt;pts_at_discont = GST_CLOCK_TIME_NONE;
 275   adapter-&gt;dts_at_discont = GST_CLOCK_TIME_NONE;
 276   adapter-&gt;offset_at_discont = GST_BUFFER_OFFSET_NONE;
 277   adapter-&gt;distance_from_discont = 0;
 278   adapter-&gt;scan_offset = 0;
<span class="line-modified"> 279   adapter-&gt;scan_entry = NULL;</span>
 280 }
 281 
 282 static inline void
 283 update_timestamps_and_offset (GstAdapter * adapter, GstBuffer * buf)
 284 {
 285   GstClockTime pts, dts;
 286   guint64 offset;
 287 
 288   pts = GST_BUFFER_PTS (buf);
 289   if (GST_CLOCK_TIME_IS_VALID (pts)) {
 290     GST_LOG_OBJECT (adapter, &quot;new pts %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (pts));
 291     adapter-&gt;pts = pts;
 292     adapter-&gt;pts_distance = 0;
 293   }
 294   dts = GST_BUFFER_DTS (buf);
 295   if (GST_CLOCK_TIME_IS_VALID (dts)) {
 296     GST_LOG_OBJECT (adapter, &quot;new dts %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (dts));
 297     adapter-&gt;dts = dts;
 298     adapter-&gt;dts_distance = 0;
 299   }
</pre>
<hr />
<pre>
 301   if (offset != GST_BUFFER_OFFSET_NONE) {
 302     GST_LOG_OBJECT (adapter, &quot;new offset %&quot; G_GUINT64_FORMAT, offset);
 303     adapter-&gt;offset = offset;
 304     adapter-&gt;offset_distance = 0;
 305   }
 306 
 307   if (GST_BUFFER_IS_DISCONT (buf)) {
 308     /* Take values as-is (might be NONE) */
 309     adapter-&gt;pts_at_discont = pts;
 310     adapter-&gt;dts_at_discont = dts;
 311     adapter-&gt;offset_at_discont = offset;
 312     adapter-&gt;distance_from_discont = 0;
 313   }
 314 }
 315 
 316 /* copy data into @dest, skipping @skip bytes from the head buffers */
 317 static void
 318 copy_into_unchecked (GstAdapter * adapter, guint8 * dest, gsize skip,
 319     gsize size)
 320 {
<span class="line-removed"> 321   GSList *g;</span>
 322   GstBuffer *buf;
 323   gsize bsize, csize;

 324 
 325   /* first step, do skipping */
 326   /* we might well be copying where we were scanning */
<span class="line-modified"> 327   if (adapter-&gt;scan_entry &amp;&amp; (adapter-&gt;scan_offset &lt;= skip)) {</span>
<span class="line-modified"> 328     g = adapter-&gt;scan_entry;</span>
 329     skip -= adapter-&gt;scan_offset;
 330   } else {
<span class="line-modified"> 331     g = adapter-&gt;buflist;</span>
 332   }
<span class="line-modified"> 333   buf = g-&gt;data;</span>
 334   bsize = gst_buffer_get_size (buf);
 335   while (G_UNLIKELY (skip &gt;= bsize)) {
 336     skip -= bsize;
<span class="line-modified"> 337     g = g_slist_next (g);</span>
<span class="line-removed"> 338     buf = g-&gt;data;</span>
 339     bsize = gst_buffer_get_size (buf);
 340   }
 341   /* copy partial buffer */
 342   csize = MIN (bsize - skip, size);
 343   GST_DEBUG (&quot;bsize %&quot; G_GSIZE_FORMAT &quot;, skip %&quot; G_GSIZE_FORMAT &quot;, csize %&quot;
 344       G_GSIZE_FORMAT, bsize, skip, csize);
 345   GST_CAT_LOG_OBJECT (GST_CAT_PERFORMANCE, adapter, &quot;extract %&quot; G_GSIZE_FORMAT
 346       &quot; bytes&quot;, csize);
 347   gst_buffer_extract (buf, skip, dest, csize);
 348   size -= csize;
 349   dest += csize;
 350 
 351   /* second step, copy remainder */
 352   while (size &gt; 0) {
<span class="line-modified"> 353     g = g_slist_next (g);</span>
<span class="line-removed"> 354     buf = g-&gt;data;</span>
 355     bsize = gst_buffer_get_size (buf);
 356     if (G_LIKELY (bsize &gt; 0)) {
 357       csize = MIN (bsize, size);
 358       GST_CAT_LOG_OBJECT (GST_CAT_PERFORMANCE, adapter,
 359           &quot;extract %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, csize);
 360       gst_buffer_extract (buf, 0, dest, csize);
 361       size -= csize;
 362       dest += csize;
 363     }
 364   }
 365 }
 366 
 367 /**
 368  * gst_adapter_push:
 369  * @adapter: a #GstAdapter
 370  * @buf: (transfer full): a #GstBuffer to add to queue in the adapter
 371  *
 372  * Adds the data from @buf to the data stored inside @adapter and takes
 373  * ownership of the buffer.
 374  */
 375 void
 376 gst_adapter_push (GstAdapter * adapter, GstBuffer * buf)
 377 {
 378   gsize size;
 379 
 380   g_return_if_fail (GST_IS_ADAPTER (adapter));
 381   g_return_if_fail (GST_IS_BUFFER (buf));
 382 
 383   size = gst_buffer_get_size (buf);
 384   adapter-&gt;size += size;
 385 
 386   /* Note: merging buffers at this point is premature. */
<span class="line-modified"> 387   if (G_UNLIKELY (adapter-&gt;buflist == NULL)) {</span>
 388     GST_LOG_OBJECT (adapter, &quot;pushing %p first %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
 389         buf, size);
<span class="line-modified"> 390     adapter-&gt;buflist = adapter-&gt;buflist_end = g_slist_append (NULL, buf);</span>
 391     update_timestamps_and_offset (adapter, buf);
 392   } else {
 393     /* Otherwise append to the end, and advance our end pointer */
 394     GST_LOG_OBJECT (adapter, &quot;pushing %p %&quot; G_GSIZE_FORMAT &quot; bytes at end, &quot;
 395         &quot;size now %&quot; G_GSIZE_FORMAT, buf, size, adapter-&gt;size);
<span class="line-modified"> 396     adapter-&gt;buflist_end = g_slist_append (adapter-&gt;buflist_end, buf);</span>
<span class="line-removed"> 397     adapter-&gt;buflist_end = g_slist_next (adapter-&gt;buflist_end);</span>
 398   }
 399   ++adapter-&gt;count;
 400 }
 401 
 402 #if 0
 403 /* Internal method only. Tries to merge buffers at the head of the queue
 404  * to form a single larger buffer of size &#39;size&#39;.
 405  *
 406  * Returns %TRUE if it managed to merge anything.
 407  */
 408 static gboolean
 409 gst_adapter_try_to_merge_up (GstAdapter * adapter, gsize size)
 410 {
 411   GstBuffer *cur, *head;
 412   GSList *g;
 413   gboolean ret = FALSE;
 414   gsize hsize;
 415 
 416   g = adapter-&gt;buflist;
 417   if (g == NULL)
</pre>
<hr />
<pre>
 489 
 490   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
 491   g_return_val_if_fail (size &gt; 0, NULL);
 492 
 493   if (adapter-&gt;info.memory)
 494     gst_adapter_unmap (adapter);
 495 
 496   /* we don&#39;t have enough data, return NULL. This is unlikely
 497    * as one usually does an _available() first instead of peeking a
 498    * random size. */
 499   if (G_UNLIKELY (size &gt; adapter-&gt;size))
 500     return NULL;
 501 
 502   /* we have enough assembled data, return it */
 503   if (adapter-&gt;assembled_len &gt;= size)
 504     return adapter-&gt;assembled_data;
 505 
 506 #if 0
 507   do {
 508 #endif
<span class="line-modified"> 509     cur = adapter-&gt;buflist-&gt;data;</span>
 510     skip = adapter-&gt;skip;
 511 
 512     csize = gst_buffer_get_size (cur);
 513     if (csize &gt;= size + skip) {
 514       if (!gst_buffer_map (cur, &amp;adapter-&gt;info, GST_MAP_READ))
 515         return FALSE;
 516 
 517       return (guint8 *) adapter-&gt;info.data + skip;
 518     }
 519     /* We may be able to efficiently merge buffers in our pool to
 520      * gather a big enough chunk to return it from the head buffer directly */
 521 #if 0
 522   } while (gst_adapter_try_to_merge_up (adapter, size));
 523 #endif
 524 
 525   /* see how much data we can reuse from the assembled memory and how much
 526    * we need to copy */
 527   toreuse = adapter-&gt;assembled_len;
 528   tocopy = size - toreuse;
 529 
</pre>
<hr />
<pre>
 550       &quot; bytes from adapter&quot;, tocopy);
 551   data = adapter-&gt;assembled_data;
 552   copy_into_unchecked (adapter, data + toreuse, skip + toreuse, tocopy);
 553   adapter-&gt;assembled_len = size;
 554 
 555   return adapter-&gt;assembled_data;
 556 }
 557 
 558 /**
 559  * gst_adapter_unmap:
 560  * @adapter: a #GstAdapter
 561  *
 562  * Releases the memory obtained with the last gst_adapter_map().
 563  */
 564 void
 565 gst_adapter_unmap (GstAdapter * adapter)
 566 {
 567   g_return_if_fail (GST_IS_ADAPTER (adapter));
 568 
 569   if (adapter-&gt;info.memory) {
<span class="line-modified"> 570     GstBuffer *cur = adapter-&gt;buflist-&gt;data;</span>
 571     GST_LOG_OBJECT (adapter, &quot;unmap memory buffer %p&quot;, cur);
 572     gst_buffer_unmap (cur, &amp;adapter-&gt;info);
 573     adapter-&gt;info.memory = NULL;
 574   }
 575 }
 576 
 577 /**
 578  * gst_adapter_copy: (skip)
 579  * @adapter: a #GstAdapter
 580  * @dest: (out caller-allocates) (array length=size) (element-type guint8):
 581  *     the memory to copy into
 582  * @offset: the bytes offset in the adapter to start from
 583  * @size: the number of bytes to copy
 584  *
 585  * Copies @size bytes of data starting at @offset out of the buffers
 586  * contained in #GstAdapter into an array @dest provided by the caller.
 587  *
 588  * The array @dest should be large enough to contain @size bytes.
 589  * The user should check that the adapter has (@offset + @size) bytes
 590  * available before calling this function.
</pre>
<hr />
<pre>
 612  *
 613  * Returns: (transfer full): A new #GBytes structure containing the copied data.
 614  *
 615  * Since: 1.4
 616  */
 617 GBytes *
 618 gst_adapter_copy_bytes (GstAdapter * adapter, gsize offset, gsize size)
 619 {
 620   gpointer data;
 621   data = g_malloc (size);
 622   gst_adapter_copy (adapter, data, offset, size);
 623   return g_bytes_new_take (data, size);
 624 }
 625 
 626 /*Flushes the first @flush bytes in the @adapter*/
 627 static void
 628 gst_adapter_flush_unchecked (GstAdapter * adapter, gsize flush)
 629 {
 630   GstBuffer *cur;
 631   gsize size;
<span class="line-removed"> 632   GSList *g;</span>
 633 
 634   GST_LOG_OBJECT (adapter, &quot;flushing %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, flush);
 635 
 636   if (adapter-&gt;info.memory)
 637     gst_adapter_unmap (adapter);
 638 
 639   /* clear state */
 640   adapter-&gt;size -= flush;
 641   adapter-&gt;assembled_len = 0;
 642 
 643   /* take skip into account */
 644   flush += adapter-&gt;skip;
 645   /* distance is always at least the amount of skipped bytes */
 646   adapter-&gt;pts_distance -= adapter-&gt;skip;
 647   adapter-&gt;dts_distance -= adapter-&gt;skip;
 648   adapter-&gt;offset_distance -= adapter-&gt;skip;
 649   adapter-&gt;distance_from_discont -= adapter-&gt;skip;
 650 
<span class="line-modified"> 651   g = adapter-&gt;buflist;</span>
<span class="line-removed"> 652   cur = g-&gt;data;</span>
 653   size = gst_buffer_get_size (cur);
 654   while (flush &gt;= size) {
 655     /* can skip whole buffer */
 656     GST_LOG_OBJECT (adapter, &quot;flushing out head buffer&quot;);
 657     adapter-&gt;pts_distance += size;
 658     adapter-&gt;dts_distance += size;
 659     adapter-&gt;offset_distance += size;
 660     adapter-&gt;distance_from_discont += size;
 661     flush -= size;
 662 
<span class="line-removed"> 663     gst_buffer_unref (cur);</span>
<span class="line-removed"> 664     g = g_slist_delete_link (g, g);</span>
 665     --adapter-&gt;count;
 666 
<span class="line-modified"> 667     if (G_UNLIKELY (g == NULL)) {</span>



 668       GST_LOG_OBJECT (adapter, &quot;adapter empty now&quot;);
<span class="line-removed"> 669       adapter-&gt;buflist_end = NULL;</span>
 670       break;
 671     }
 672     /* there is a new head buffer, update the timestamps */
<span class="line-modified"> 673     cur = g-&gt;data;</span>
 674     update_timestamps_and_offset (adapter, cur);
 675     size = gst_buffer_get_size (cur);
 676   }
<span class="line-removed"> 677   adapter-&gt;buflist = g;</span>
 678   /* account for the remaining bytes */
 679   adapter-&gt;skip = flush;
 680   adapter-&gt;pts_distance += flush;
 681   adapter-&gt;dts_distance += flush;
 682   adapter-&gt;offset_distance += flush;
 683   adapter-&gt;distance_from_discont += flush;
 684   /* invalidate scan position */
 685   adapter-&gt;scan_offset = 0;
<span class="line-modified"> 686   adapter-&gt;scan_entry = NULL;</span>
 687 }
 688 
 689 /**
 690  * gst_adapter_flush:
 691  * @adapter: a #GstAdapter
 692  * @flush: the number of bytes to flush
 693  *
 694  * Flushes the first @flush bytes in the @adapter. The caller must ensure that
 695  * at least this many bytes are available.
 696  *
 697  * See also: gst_adapter_map(), gst_adapter_unmap()
 698  */
 699 void
 700 gst_adapter_flush (GstAdapter * adapter, gsize flush)
 701 {
 702   g_return_if_fail (GST_IS_ADAPTER (adapter));
 703   g_return_if_fail (flush &lt;= adapter-&gt;size);
 704 
 705   /* flushing out 0 bytes will do nothing */
 706   if (G_UNLIKELY (flush == 0))
</pre>
<hr />
<pre>
 796  * Returns a #GstBuffer containing the first @nbytes of the @adapter, but
 797  * does not flush them from the adapter. See gst_adapter_take_buffer_fast()
 798  * for details.
 799  *
 800  * Caller owns a reference to the returned buffer. gst_buffer_unref() after
 801  * usage.
 802  *
 803  * Free-function: gst_buffer_unref
 804  *
 805  * Returns: (transfer full) (nullable): a #GstBuffer containing the first
 806  *     @nbytes of the adapter, or %NULL if @nbytes bytes are not available.
 807  *     gst_buffer_unref() when no longer needed.
 808  *
 809  * Since: 1.6
 810  */
 811 GstBuffer *
 812 gst_adapter_get_buffer_fast (GstAdapter * adapter, gsize nbytes)
 813 {
 814   GstBuffer *buffer = NULL;
 815   GstBuffer *cur;
<span class="line-removed"> 816   GSList *item;</span>
 817   gsize skip;
 818   gsize left = nbytes;

 819 
 820   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
 821   g_return_val_if_fail (nbytes &gt; 0, NULL);
 822 
 823   GST_LOG_OBJECT (adapter, &quot;getting buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
 824       nbytes);
 825 
 826   /* we don&#39;t have enough data, return NULL. This is unlikely
 827    * as one usually does an _available() first instead of grabbing a
 828    * random size. */
 829   if (G_UNLIKELY (nbytes &gt; adapter-&gt;size))
 830     return NULL;
 831 
 832   skip = adapter-&gt;skip;
<span class="line-modified"> 833   cur = adapter-&gt;buflist-&gt;data;</span>
 834 
 835   if (skip == 0 &amp;&amp; gst_buffer_get_size (cur) == nbytes) {
 836     GST_LOG_OBJECT (adapter, &quot;providing buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
 837         &quot; as head buffer&quot;, nbytes);
 838     buffer = gst_buffer_ref (cur);
 839     goto done;
 840   }
 841 
<span class="line-modified"> 842   for (item = adapter-&gt;buflist; item &amp;&amp; left &gt; 0; item = item-&gt;next) {</span>


 843     gsize size, cur_size;
 844 
<span class="line-modified"> 845     cur = item-&gt;data;</span>
 846     cur_size = gst_buffer_get_size (cur);
 847     size = MIN (cur_size - skip, left);
 848 
 849     GST_LOG_OBJECT (adapter, &quot;appending %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
 850         &quot; via region copy&quot;, size);
 851     if (buffer)
 852       gst_buffer_copy_into (buffer, cur,
 853           GST_BUFFER_COPY_MEMORY | GST_BUFFER_COPY_META, skip, size);
 854     else
 855       buffer = gst_buffer_copy_region (cur, GST_BUFFER_COPY_ALL, skip, size);
 856     skip = 0;
 857     left -= size;
 858   }
 859 
 860 done:
 861 
 862   return buffer;
 863 }
 864 
 865 /**
</pre>
<hr />
<pre>
 962 GstBuffer *
 963 gst_adapter_get_buffer (GstAdapter * adapter, gsize nbytes)
 964 {
 965   GstBuffer *buffer;
 966   GstBuffer *cur;
 967   gsize hsize, skip;
 968   guint8 *data;
 969 
 970   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
 971   g_return_val_if_fail (nbytes &gt; 0, NULL);
 972 
 973   GST_LOG_OBJECT (adapter, &quot;getting buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
 974       nbytes);
 975 
 976   /* we don&#39;t have enough data, return NULL. This is unlikely
 977    * as one usually does an _available() first instead of grabbing a
 978    * random size. */
 979   if (G_UNLIKELY (nbytes &gt; adapter-&gt;size))
 980     return NULL;
 981 
<span class="line-modified"> 982   cur = adapter-&gt;buflist-&gt;data;</span>
 983   skip = adapter-&gt;skip;
 984   hsize = gst_buffer_get_size (cur);
 985 
 986   /* our head buffer has enough data left, return it */
 987   if (skip == 0 &amp;&amp; hsize == nbytes) {
 988     GST_LOG_OBJECT (adapter, &quot;providing buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
 989         &quot; as head buffer&quot;, nbytes);
 990     buffer = gst_buffer_ref (cur);
 991     goto done;
 992   } else if (hsize &gt;= nbytes + skip) {
 993     GST_LOG_OBJECT (adapter, &quot;providing buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
 994         &quot; via region copy&quot;, nbytes);
 995     buffer = gst_buffer_copy_region (cur, GST_BUFFER_COPY_ALL, skip, nbytes);
 996     goto done;
 997   }
 998 #if 0
 999   if (gst_adapter_try_to_merge_up (adapter, nbytes)) {
1000     /* Merged something, let&#39;s try again for sub-buffering */
1001     cur = adapter-&gt;buflist-&gt;data;
1002     skip = adapter-&gt;skip;
1003     if (gst_buffer_get_size (cur) &gt;= nbytes + skip) {
1004       GST_LOG_OBJECT (adapter, &quot;providing buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
1005           &quot; via sub-buffer&quot;, nbytes);
1006       buffer = gst_buffer_copy_region (cur, GST_BUFFER_COPY_ALL, skip, nbytes);
1007       goto done;
1008     }
1009   }
1010 #endif
1011 
1012   data = gst_adapter_get_internal (adapter, nbytes);
1013 
1014   buffer = gst_buffer_new_wrapped (data, nbytes);
1015 
1016   {
<span class="line-modified">1017     GSList *g;</span>
1018     GstBuffer *cur;
1019     gsize read_offset = 0;
1020 
<span class="line-modified">1021     g = adapter-&gt;buflist;</span>
<span class="line-modified">1022     while (g &amp;&amp; read_offset &lt; nbytes + adapter-&gt;skip) {</span>
<span class="line-modified">1023       cur = g-&gt;data;</span>


1024 
1025       gst_buffer_foreach_meta (cur, foreach_metadata, buffer);
1026       read_offset += gst_buffer_get_size (cur);
1027 
<span class="line-modified">1028       g = g_slist_next (g);</span>
1029     }
1030   }
1031 
1032 done:
1033 
1034   return buffer;
1035 }
1036 
1037 /**
1038  * gst_adapter_take_buffer:
1039  * @adapter: a #GstAdapter
1040  * @nbytes: the number of bytes to take
1041  *
1042  * Returns a #GstBuffer containing the first @nbytes bytes of the
1043  * @adapter. The returned bytes will be flushed from the adapter.
1044  * This function is potentially more performant than
1045  * gst_adapter_take() since it can reuse the memory in pushed buffers
1046  * by subbuffering or merging. This function will always return a
1047  * buffer with a single memory region.
1048  *
</pre>
<hr />
<pre>
1091  * Caller owns returned list and contained buffers. gst_buffer_unref() each
1092  * buffer in the list before freeing the list after usage.
1093  *
1094  * Returns: (element-type Gst.Buffer) (transfer full) (nullable): a #GList of
1095  *     buffers containing the first @nbytes of the adapter, or %NULL if @nbytes
1096  *     bytes are not available
1097  */
1098 GList *
1099 gst_adapter_take_list (GstAdapter * adapter, gsize nbytes)
1100 {
1101   GQueue queue = G_QUEUE_INIT;
1102   GstBuffer *cur;
1103   gsize hsize, skip, cur_size;
1104 
1105   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
1106   g_return_val_if_fail (nbytes &lt;= adapter-&gt;size, NULL);
1107 
1108   GST_LOG_OBJECT (adapter, &quot;taking %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, nbytes);
1109 
1110   while (nbytes &gt; 0) {
<span class="line-modified">1111     cur = adapter-&gt;buflist-&gt;data;</span>
1112     skip = adapter-&gt;skip;
1113     cur_size = gst_buffer_get_size (cur);
1114     hsize = MIN (nbytes, cur_size - skip);
1115 
1116     cur = gst_adapter_take_buffer (adapter, hsize);
1117 
1118     g_queue_push_tail (&amp;queue, cur);
1119 
1120     nbytes -= hsize;
1121   }
1122   return queue.head;
1123 }
1124 
1125 /**
1126  * gst_adapter_get_list:
1127  * @adapter: a #GstAdapter
1128  * @nbytes: the number of bytes to get
1129  *
1130  * Returns a #GList of buffers containing the first @nbytes bytes of the
1131  * @adapter, but does not flush them from the adapter. See
1132  * gst_adapter_take_list() for details.
1133  *
1134  * Caller owns returned list and contained buffers. gst_buffer_unref() each
1135  * buffer in the list before freeing the list after usage.
1136  *
1137  * Returns: (element-type Gst.Buffer) (transfer full) (nullable): a #GList of
1138  *     buffers containing the first @nbytes of the adapter, or %NULL if @nbytes
1139  *     bytes are not available
1140  *
1141  * Since: 1.6
1142  */
1143 GList *
1144 gst_adapter_get_list (GstAdapter * adapter, gsize nbytes)
1145 {
1146   GQueue queue = G_QUEUE_INIT;
1147   GstBuffer *cur, *buffer;
1148   gsize hsize, skip, cur_size;
<span class="line-modified">1149   GSList *g = NULL;</span>
1150 
1151   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
1152   g_return_val_if_fail (nbytes &lt;= adapter-&gt;size, NULL);
1153 
1154   GST_LOG_OBJECT (adapter, &quot;getting %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, nbytes);
1155 
<span class="line-modified">1156   g = adapter-&gt;buflist;</span>
1157   skip = adapter-&gt;skip;
1158 
1159   while (nbytes &gt; 0) {
<span class="line-modified">1160     cur = g-&gt;data;</span>
1161     cur_size = gst_buffer_get_size (cur);
1162     hsize = MIN (nbytes, cur_size - skip);
1163 
1164     if (skip == 0 &amp;&amp; cur_size == hsize) {
1165       GST_LOG_OBJECT (adapter,
1166           &quot;inserting a buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, hsize);
1167       buffer = gst_buffer_ref (cur);
1168     } else {
1169       GST_LOG_OBJECT (adapter, &quot;inserting a buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
1170           &quot; via region copy&quot;, hsize);
1171       buffer = gst_buffer_copy_region (cur, GST_BUFFER_COPY_ALL, skip, hsize);
1172     }
1173 
1174     g_queue_push_tail (&amp;queue, buffer);
1175 
1176     nbytes -= hsize;
1177     skip = 0;
<span class="line-removed">1178     g = g_slist_next (g);</span>
1179   }
1180 
1181   return queue.head;
1182 }
1183 
1184 /**
1185  * gst_adapter_take_buffer_list:
1186  * @adapter: a #GstAdapter
1187  * @nbytes: the number of bytes to take
1188  *
1189  * Returns a #GstBufferList of buffers containing the first @nbytes bytes of
1190  * the @adapter. The returned bytes will be flushed from the adapter.
1191  * When the caller can deal with individual buffers, this function is more
1192  * performant because no memory should be copied.
1193  *
1194  * Caller owns the returned list. Call gst_buffer_list_unref() to free
1195  * the list after usage.
1196  *
1197  * Returns: (transfer full) (nullable): a #GstBufferList of buffers containing
1198  *     the first @nbytes of the adapter, or %NULL if @nbytes bytes are not
</pre>
<hr />
<pre>
1207   GstBuffer *cur;
1208   gsize hsize, skip, cur_size;
1209   guint n_bufs;
1210 
1211   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
1212 
1213   if (nbytes &gt; adapter-&gt;size)
1214     return NULL;
1215 
1216   GST_LOG_OBJECT (adapter, &quot;taking %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, nbytes);
1217 
1218   /* try to create buffer list with sufficient size, so no resize is done later */
1219   if (adapter-&gt;count &lt; 64)
1220     n_bufs = adapter-&gt;count;
1221   else
1222     n_bufs = (adapter-&gt;count * nbytes * 1.2 / adapter-&gt;size) + 1;
1223 
1224   buffer_list = gst_buffer_list_new_sized (n_bufs);
1225 
1226   while (nbytes &gt; 0) {
<span class="line-modified">1227     cur = adapter-&gt;buflist-&gt;data;</span>
1228     skip = adapter-&gt;skip;
1229     cur_size = gst_buffer_get_size (cur);
1230     hsize = MIN (nbytes, cur_size - skip);
1231 
1232     gst_buffer_list_add (buffer_list, gst_adapter_take_buffer (adapter, hsize));
1233     nbytes -= hsize;
1234   }
1235   return buffer_list;
1236 }
1237 
1238 /**
1239  * gst_adapter_get_buffer_list:
1240  * @adapter: a #GstAdapter
1241  * @nbytes: the number of bytes to get
1242  *
1243  * Returns a #GstBufferList of buffers containing the first @nbytes bytes of
1244  * the @adapter but does not flush them from the adapter. See
1245  * gst_adapter_take_buffer_list() for details.
1246  *
1247  * Caller owns the returned list. Call gst_buffer_list_unref() to free
1248  * the list after usage.
1249  *
1250  * Returns: (transfer full) (nullable): a #GstBufferList of buffers containing
1251  *     the first @nbytes of the adapter, or %NULL if @nbytes bytes are not
1252  *     available
1253  *
1254  * Since: 1.6
1255  */
1256 GstBufferList *
1257 gst_adapter_get_buffer_list (GstAdapter * adapter, gsize nbytes)
1258 {
1259   GstBufferList *buffer_list;
1260   GstBuffer *cur, *buffer;
1261   gsize hsize, skip, cur_size;
1262   guint n_bufs;
<span class="line-modified">1263   GSList *g = NULL;</span>
1264 
1265   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
1266 
1267   if (nbytes &gt; adapter-&gt;size)
1268     return NULL;
1269 
1270   GST_LOG_OBJECT (adapter, &quot;getting %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, nbytes);
1271 
1272   /* try to create buffer list with sufficient size, so no resize is done later */
1273   if (adapter-&gt;count &lt; 64)
1274     n_bufs = adapter-&gt;count;
1275   else
1276     n_bufs = (adapter-&gt;count * nbytes * 1.2 / adapter-&gt;size) + 1;
1277 
1278   buffer_list = gst_buffer_list_new_sized (n_bufs);
1279 
<span class="line-modified">1280   g = adapter-&gt;buflist;</span>
1281   skip = adapter-&gt;skip;
1282 
1283   while (nbytes &gt; 0) {
<span class="line-modified">1284     cur = g-&gt;data;</span>
1285     cur_size = gst_buffer_get_size (cur);
1286     hsize = MIN (nbytes, cur_size - skip);
1287 
1288     if (skip == 0 &amp;&amp; cur_size == hsize) {
1289       GST_LOG_OBJECT (adapter,
1290           &quot;inserting a buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, hsize);
1291       buffer = gst_buffer_ref (cur);
1292     } else {
1293       GST_LOG_OBJECT (adapter, &quot;inserting a buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
1294           &quot; via region copy&quot;, hsize);
1295       buffer = gst_buffer_copy_region (cur, GST_BUFFER_COPY_ALL, skip, hsize);
1296     }
1297 
1298     gst_buffer_list_add (buffer_list, buffer);
1299 
1300     nbytes -= hsize;
1301     skip = 0;
<span class="line-removed">1302     g = g_slist_next (g);</span>
1303   }
1304 
1305   return buffer_list;
1306 }
1307 
1308 /**
1309  * gst_adapter_available:
1310  * @adapter: a #GstAdapter
1311  *
1312  * Gets the maximum amount of bytes available, that is it returns the maximum
1313  * value that can be supplied to gst_adapter_map() without that function
1314  * returning %NULL.
1315  *
1316  * Returns: number of bytes available in @adapter
1317  */
1318 gsize
1319 gst_adapter_available (GstAdapter * adapter)
1320 {
1321   g_return_val_if_fail (GST_IS_ADAPTER (adapter), 0);
1322 
1323   return adapter-&gt;size;
1324 }
1325 
1326 /**
1327  * gst_adapter_available_fast:
1328  * @adapter: a #GstAdapter
1329  *
1330  * Gets the maximum number of bytes that are immediately available without
1331  * requiring any expensive operations (like copying the data into a
1332  * temporary buffer).
1333  *
1334  * Returns: number of bytes that are available in @adapter without expensive
1335  * operations
1336  */
1337 gsize
1338 gst_adapter_available_fast (GstAdapter * adapter)
1339 {
1340   GstBuffer *cur;
1341   gsize size;
<span class="line-modified">1342   GSList *g;</span>
1343 
1344   g_return_val_if_fail (GST_IS_ADAPTER (adapter), 0);
1345 
1346   /* no data */
1347   if (adapter-&gt;size == 0)
1348     return 0;
1349 
1350   /* some stuff we already assembled */
1351   if (adapter-&gt;assembled_len)
1352     return adapter-&gt;assembled_len;
1353 
1354   /* take the first non-zero buffer */
<span class="line-modified">1355   g = adapter-&gt;buflist;</span>
1356   while (TRUE) {
<span class="line-modified">1357     cur = g-&gt;data;</span>
1358     size = gst_buffer_get_size (cur);
1359     if (size != 0)
1360       break;
<span class="line-removed">1361     g = g_slist_next (g);</span>
1362   }
1363 
1364   /* we can quickly get the (remaining) data of the first buffer */
1365   return size - adapter-&gt;skip;
1366 }
1367 
1368 /**
1369  * gst_adapter_get_distance_from_discont:
1370  * @adapter: a #GstAdapter
1371  *
1372  * Get the distance in bytes since the last buffer with the
1373  * %GST_BUFFER_FLAG_DISCONT flag.
1374  *
1375  * The distance will be reset to 0 for all buffers with
1376  * %GST_BUFFER_FLAG_DISCONT on them, and then calculated for all other
1377  * following buffers based on their size.
1378  *
1379  * Since: 1.10
1380  *
1381  * Returns: The offset. Can be %GST_BUFFER_OFFSET_NONE.
</pre>
<hr />
<pre>
1532  * @offset: the offset in the adapter at which to get timestamp
1533  * @distance: (out) (allow-none): pointer to location for distance, or %NULL
1534  *
1535  * Get the pts that was before the byte at offset @offset in the adapter. When
1536  * @distance is given, the amount of bytes between the pts and the current
1537  * position is returned.
1538  *
1539  * The pts is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when
1540  * the adapter is first created or when it is cleared. This also means that before
1541  * the first byte with a pts is removed from the adapter, the pts
1542  * and distance returned are GST_CLOCK_TIME_NONE and 0 respectively.
1543  *
1544  * Since: 1.2
1545  * Returns: The previously seen pts at given offset.
1546  */
1547 GstClockTime
1548 gst_adapter_prev_pts_at_offset (GstAdapter * adapter, gsize offset,
1549     guint64 * distance)
1550 {
1551   GstBuffer *cur;
<span class="line-removed">1552   GSList *g;</span>
1553   gsize read_offset = 0;
1554   gsize pts_offset = 0;
1555   GstClockTime pts = adapter-&gt;pts;

1556 
1557   g_return_val_if_fail (GST_IS_ADAPTER (adapter), GST_CLOCK_TIME_NONE);
1558 
<span class="line-modified">1559   g = adapter-&gt;buflist;</span>

1560 
<span class="line-modified">1561   while (g &amp;&amp; read_offset &lt; offset + adapter-&gt;skip) {</span>
<span class="line-modified">1562     cur = g-&gt;data;</span>
1563 
1564     if (GST_CLOCK_TIME_IS_VALID (GST_BUFFER_PTS (cur))) {
1565       pts = GST_BUFFER_PTS (cur);
1566       pts_offset = read_offset;
1567     }
1568 
1569     read_offset += gst_buffer_get_size (cur);
<span class="line-removed">1570     g = g_slist_next (g);</span>
1571   }
1572 
1573   if (distance)
1574     *distance = adapter-&gt;pts_distance + offset - pts_offset;
1575 
1576   return pts;
1577 }
1578 
1579 /**
1580  * gst_adapter_prev_dts_at_offset:
1581  * @adapter: a #GstAdapter
1582  * @offset: the offset in the adapter at which to get timestamp
1583  * @distance: (out) (allow-none): pointer to location for distance, or %NULL
1584  *
1585  * Get the dts that was before the byte at offset @offset in the adapter. When
1586  * @distance is given, the amount of bytes between the dts and the current
1587  * position is returned.
1588  *
1589  * The dts is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when
1590  * the adapter is first created or when it is cleared. This also means that before
1591  * the first byte with a dts is removed from the adapter, the dts
1592  * and distance returned are GST_CLOCK_TIME_NONE and 0 respectively.
1593  *
1594  * Since: 1.2
1595  * Returns: The previously seen dts at given offset.
1596  */
1597 GstClockTime
1598 gst_adapter_prev_dts_at_offset (GstAdapter * adapter, gsize offset,
1599     guint64 * distance)
1600 {
1601   GstBuffer *cur;
<span class="line-removed">1602   GSList *g;</span>
1603   gsize read_offset = 0;
1604   gsize dts_offset = 0;
1605   GstClockTime dts = adapter-&gt;dts;

1606 
1607   g_return_val_if_fail (GST_IS_ADAPTER (adapter), GST_CLOCK_TIME_NONE);
1608 
<span class="line-modified">1609   g = adapter-&gt;buflist;</span>

1610 
<span class="line-modified">1611   while (g &amp;&amp; read_offset &lt; offset + adapter-&gt;skip) {</span>
<span class="line-modified">1612     cur = g-&gt;data;</span>
1613 
1614     if (GST_CLOCK_TIME_IS_VALID (GST_BUFFER_DTS (cur))) {
1615       dts = GST_BUFFER_DTS (cur);
1616       dts_offset = read_offset;
1617     }
1618 
1619     read_offset += gst_buffer_get_size (cur);
<span class="line-removed">1620     g = g_slist_next (g);</span>
1621   }
1622 
1623   if (distance)
1624     *distance = adapter-&gt;dts_distance + offset - dts_offset;
1625 
1626   return dts;
1627 }
1628 
1629 /**
1630  * gst_adapter_masked_scan_uint32_peek:
1631  * @adapter: a #GstAdapter
1632  * @mask: mask to apply to data before matching against @pattern
1633  * @pattern: pattern to match (after mask is applied)
1634  * @offset: offset into the adapter data from which to start scanning, returns
1635  *          the last scanned position.
1636  * @size: number of bytes to scan from offset
1637  * @value: (out) (allow-none): pointer to uint32 to return matching data
1638  *
1639  * Scan for pattern @pattern with applied mask @mask in the adapter data,
1640  * starting from offset @offset.  If a match is found, the value that matched
1641  * is returned through @value, otherwise @value is left untouched.
1642  *
1643  * The bytes in @pattern and @mask are interpreted left-to-right, regardless
1644  * of endianness.  All four bytes of the pattern must be present in the
1645  * adapter for it to match, even if the first or last bytes are masked out.
1646  *
1647  * It is an error to call this function without making sure that there is
1648  * enough data (offset+size bytes) in the adapter.
1649  *
1650  * Returns: offset of the first match, or -1 if no match was found.
1651  */
1652 gssize
1653 gst_adapter_masked_scan_uint32_peek (GstAdapter * adapter, guint32 mask,
1654     guint32 pattern, gsize offset, gsize size, guint32 * value)
1655 {
<span class="line-removed">1656   GSList *g;</span>
1657   gsize skip, bsize, i;
1658   guint32 state;
1659   GstMapInfo info;
1660   guint8 *bdata;
1661   GstBuffer *buf;

1662 
1663   g_return_val_if_fail (size &gt; 0, -1);
1664   g_return_val_if_fail (offset + size &lt;= adapter-&gt;size, -1);
1665   g_return_val_if_fail (((~mask) &amp; pattern) == 0, -1);
1666 
1667   /* we can&#39;t find the pattern with less than 4 bytes */
1668   if (G_UNLIKELY (size &lt; 4))
1669     return -1;
1670 
1671   skip = offset + adapter-&gt;skip;
1672 
1673   /* first step, do skipping and position on the first buffer */
1674   /* optimistically assume scanning continues sequentially */
<span class="line-modified">1675   if (adapter-&gt;scan_entry &amp;&amp; (adapter-&gt;scan_offset &lt;= skip)) {</span>
<span class="line-modified">1676     g = adapter-&gt;scan_entry;</span>
1677     skip -= adapter-&gt;scan_offset;
1678   } else {
<span class="line-modified">1679     g = adapter-&gt;buflist;</span>
1680     adapter-&gt;scan_offset = 0;
<span class="line-modified">1681     adapter-&gt;scan_entry = NULL;</span>
1682   }
<span class="line-modified">1683   buf = g-&gt;data;</span>
1684   bsize = gst_buffer_get_size (buf);
1685   while (G_UNLIKELY (skip &gt;= bsize)) {
1686     skip -= bsize;
<span class="line-removed">1687     g = g_slist_next (g);</span>
1688     adapter-&gt;scan_offset += bsize;
<span class="line-modified">1689     adapter-&gt;scan_entry = g;</span>
<span class="line-modified">1690     buf = g-&gt;data;</span>
1691     bsize = gst_buffer_get_size (buf);
1692   }
1693   /* get the data now */
1694   if (!gst_buffer_map (buf, &amp;info, GST_MAP_READ))
1695     return -1;
1696 
1697   bdata = (guint8 *) info.data + skip;
1698   bsize = info.size - skip;
1699   skip = 0;
1700 
1701   /* set the state to something that does not match */
1702   state = ~pattern;
1703 
1704   /* now find data */
1705   do {
1706     bsize = MIN (bsize, size);
1707     for (i = 0; i &lt; bsize; i++) {
1708       state = ((state &lt;&lt; 8) | bdata[i]);
1709       if (G_UNLIKELY ((state &amp; mask) == pattern)) {
1710         /* we have a match but we need to have skipped at
1711          * least 4 bytes to fill the state. */
1712         if (G_LIKELY (skip + i &gt;= 3)) {
1713           if (G_LIKELY (value))
1714             *value = state;
1715           gst_buffer_unmap (buf, &amp;info);
1716           return offset + skip + i - 3;
1717         }
1718       }
1719     }
1720     size -= bsize;
1721     if (size == 0)
1722       break;
1723 
1724     /* nothing found yet, go to next buffer */
1725     skip += bsize;
<span class="line-removed">1726     g = g_slist_next (g);</span>
1727     adapter-&gt;scan_offset += info.size;
<span class="line-modified">1728     adapter-&gt;scan_entry = g;</span>
1729     gst_buffer_unmap (buf, &amp;info);
<span class="line-modified">1730     buf = g-&gt;data;</span>
1731 
1732     if (!gst_buffer_map (buf, &amp;info, GST_MAP_READ))
1733       return -1;
1734 
1735     bsize = info.size;
1736     bdata = info.data;
1737   } while (TRUE);
1738 
1739   gst_buffer_unmap (buf, &amp;info);
1740 
1741   /* nothing found */
1742   return -1;
1743 }
1744 
1745 /**
1746  * gst_adapter_masked_scan_uint32:
1747  * @adapter: a #GstAdapter
1748  * @mask: mask to apply to data before matching against @pattern
1749  * @pattern: pattern to match (after mask is applied)
1750  * @offset: offset into the adapter data from which to start scanning, returns
</pre>
</td>
<td>
<hr />
<pre>
 110  * memcpy() operation, and these operations are not the fastest. Because of
 111  * this, some functions like gst_adapter_available_fast() are provided to help
 112  * speed up such cases should you want to. To avoid repeated memory allocations,
 113  * gst_adapter_copy() can be used to copy data into a (statically allocated)
 114  * user provided buffer.
 115  *
 116  * #GstAdapter is not MT safe. All operations on an adapter must be serialized by
 117  * the caller. This is not normally a problem, however, as the normal use case
 118  * of #GstAdapter is inside one pad&#39;s chain function, in which case access is
 119  * serialized via the pad&#39;s STREAM_LOCK.
 120  *
 121  * Note that gst_adapter_push() takes ownership of the buffer passed. Use
 122  * gst_buffer_ref() before pushing it into the adapter if you still want to
 123  * access the buffer later. The adapter will never modify the data in the
 124  * buffer pushed in it.
 125  */
 126 
 127 #include &lt;gst/gst_private.h&gt;
 128 #include &quot;gstadapter.h&quot;
 129 #include &lt;string.h&gt;
<span class="line-added"> 130 #include &lt;gst/base/gstqueuearray.h&gt;</span>
 131 
 132 /* default size for the assembled data buffer */
 133 #define DEFAULT_SIZE 4096
 134 
 135 static void gst_adapter_flush_unchecked (GstAdapter * adapter, gsize flush);
 136 
 137 GST_DEBUG_CATEGORY_STATIC (gst_adapter_debug);
 138 #define GST_CAT_DEFAULT gst_adapter_debug
 139 
 140 struct _GstAdapter
 141 {
 142   GObject object;
 143 
 144   /*&lt; private &gt; */
<span class="line-modified"> 145   GstQueueArray *bufqueue;</span>

 146   gsize size;
 147   gsize skip;
 148   guint count;
 149 
 150   /* we keep state of assembled pieces */
 151   gpointer assembled_data;
 152   gsize assembled_size;
 153   gsize assembled_len;
 154 
 155   GstClockTime pts;
 156   guint64 pts_distance;
 157   GstClockTime dts;
 158   guint64 dts_distance;
 159   guint64 offset;
 160   guint64 offset_distance;
 161 
 162   gsize scan_offset;
<span class="line-modified"> 163   /* G_MAXUINT when unset */</span>
<span class="line-added"> 164   guint scan_entry_idx;</span>
 165 
 166   GstClockTime pts_at_discont;
 167   GstClockTime dts_at_discont;
 168   guint64 offset_at_discont;
 169 
 170   guint64 distance_from_discont;
 171 
 172   GstMapInfo info;
 173 };
 174 
 175 struct _GstAdapterClass
 176 {
 177   GObjectClass parent_class;
 178 };
 179 
 180 #define _do_init \
 181   GST_DEBUG_CATEGORY_INIT (gst_adapter_debug, &quot;adapter&quot;, 0, &quot;object to splice and merge buffers to desired size&quot;)
 182 #define gst_adapter_parent_class parent_class
 183 G_DEFINE_TYPE_WITH_CODE (GstAdapter, gst_adapter, G_TYPE_OBJECT, _do_init);
 184 
</pre>
<hr />
<pre>
 192 
 193   object-&gt;dispose = gst_adapter_dispose;
 194   object-&gt;finalize = gst_adapter_finalize;
 195 }
 196 
 197 static void
 198 gst_adapter_init (GstAdapter * adapter)
 199 {
 200   adapter-&gt;assembled_data = g_malloc (DEFAULT_SIZE);
 201   adapter-&gt;assembled_size = DEFAULT_SIZE;
 202   adapter-&gt;pts = GST_CLOCK_TIME_NONE;
 203   adapter-&gt;pts_distance = 0;
 204   adapter-&gt;dts = GST_CLOCK_TIME_NONE;
 205   adapter-&gt;dts_distance = 0;
 206   adapter-&gt;offset = GST_BUFFER_OFFSET_NONE;
 207   adapter-&gt;offset_distance = 0;
 208   adapter-&gt;pts_at_discont = GST_CLOCK_TIME_NONE;
 209   adapter-&gt;dts_at_discont = GST_CLOCK_TIME_NONE;
 210   adapter-&gt;offset_at_discont = GST_BUFFER_OFFSET_NONE;
 211   adapter-&gt;distance_from_discont = 0;
<span class="line-added"> 212   adapter-&gt;bufqueue = gst_queue_array_new (10);</span>
 213 }
 214 
 215 static void
 216 gst_adapter_dispose (GObject * object)
 217 {
 218   GstAdapter *adapter = GST_ADAPTER (object);
 219 
 220   gst_adapter_clear (adapter);
 221 
 222   GST_CALL_PARENT (G_OBJECT_CLASS, dispose, (object));
 223 }
 224 
 225 static void
 226 gst_adapter_finalize (GObject * object)
 227 {
 228   GstAdapter *adapter = GST_ADAPTER (object);
 229 
 230   g_free (adapter-&gt;assembled_data);
 231 
<span class="line-added"> 232   gst_queue_array_free (adapter-&gt;bufqueue);</span>
<span class="line-added"> 233 </span>
 234   GST_CALL_PARENT (G_OBJECT_CLASS, finalize, (object));
 235 }
 236 
 237 /**
 238  * gst_adapter_new:
 239  *
 240  * Creates a new #GstAdapter. Free with g_object_unref().
 241  *
 242  * Returns: (transfer full): a new #GstAdapter
 243  */
 244 GstAdapter *
 245 gst_adapter_new (void)
 246 {
 247   return g_object_new (GST_TYPE_ADAPTER, NULL);
 248 }
 249 
 250 /**
 251  * gst_adapter_clear:
 252  * @adapter: a #GstAdapter
 253  *
 254  * Removes all buffers from @adapter.
 255  */
 256 void
 257 gst_adapter_clear (GstAdapter * adapter)
 258 {
<span class="line-added"> 259   GstMiniObject *obj;</span>
 260   g_return_if_fail (GST_IS_ADAPTER (adapter));
 261 
 262   if (adapter-&gt;info.memory)
 263     gst_adapter_unmap (adapter);
 264 
<span class="line-modified"> 265   while ((obj = gst_queue_array_pop_head (adapter-&gt;bufqueue)))</span>
<span class="line-modified"> 266     gst_mini_object_unref (obj);</span>
<span class="line-modified"> 267 </span>

 268   adapter-&gt;count = 0;
 269   adapter-&gt;size = 0;
 270   adapter-&gt;skip = 0;
 271   adapter-&gt;assembled_len = 0;
 272   adapter-&gt;pts = GST_CLOCK_TIME_NONE;
 273   adapter-&gt;pts_distance = 0;
 274   adapter-&gt;dts = GST_CLOCK_TIME_NONE;
 275   adapter-&gt;dts_distance = 0;
 276   adapter-&gt;offset = GST_BUFFER_OFFSET_NONE;
 277   adapter-&gt;offset_distance = 0;
 278   adapter-&gt;pts_at_discont = GST_CLOCK_TIME_NONE;
 279   adapter-&gt;dts_at_discont = GST_CLOCK_TIME_NONE;
 280   adapter-&gt;offset_at_discont = GST_BUFFER_OFFSET_NONE;
 281   adapter-&gt;distance_from_discont = 0;
 282   adapter-&gt;scan_offset = 0;
<span class="line-modified"> 283   adapter-&gt;scan_entry_idx = G_MAXUINT;</span>
 284 }
 285 
 286 static inline void
 287 update_timestamps_and_offset (GstAdapter * adapter, GstBuffer * buf)
 288 {
 289   GstClockTime pts, dts;
 290   guint64 offset;
 291 
 292   pts = GST_BUFFER_PTS (buf);
 293   if (GST_CLOCK_TIME_IS_VALID (pts)) {
 294     GST_LOG_OBJECT (adapter, &quot;new pts %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (pts));
 295     adapter-&gt;pts = pts;
 296     adapter-&gt;pts_distance = 0;
 297   }
 298   dts = GST_BUFFER_DTS (buf);
 299   if (GST_CLOCK_TIME_IS_VALID (dts)) {
 300     GST_LOG_OBJECT (adapter, &quot;new dts %&quot; GST_TIME_FORMAT, GST_TIME_ARGS (dts));
 301     adapter-&gt;dts = dts;
 302     adapter-&gt;dts_distance = 0;
 303   }
</pre>
<hr />
<pre>
 305   if (offset != GST_BUFFER_OFFSET_NONE) {
 306     GST_LOG_OBJECT (adapter, &quot;new offset %&quot; G_GUINT64_FORMAT, offset);
 307     adapter-&gt;offset = offset;
 308     adapter-&gt;offset_distance = 0;
 309   }
 310 
 311   if (GST_BUFFER_IS_DISCONT (buf)) {
 312     /* Take values as-is (might be NONE) */
 313     adapter-&gt;pts_at_discont = pts;
 314     adapter-&gt;dts_at_discont = dts;
 315     adapter-&gt;offset_at_discont = offset;
 316     adapter-&gt;distance_from_discont = 0;
 317   }
 318 }
 319 
 320 /* copy data into @dest, skipping @skip bytes from the head buffers */
 321 static void
 322 copy_into_unchecked (GstAdapter * adapter, guint8 * dest, gsize skip,
 323     gsize size)
 324 {

 325   GstBuffer *buf;
 326   gsize bsize, csize;
<span class="line-added"> 327   guint idx = 0;</span>
 328 
 329   /* first step, do skipping */
 330   /* we might well be copying where we were scanning */
<span class="line-modified"> 331   if (adapter-&gt;scan_entry_idx != G_MAXUINT &amp;&amp; (adapter-&gt;scan_offset &lt;= skip)) {</span>
<span class="line-modified"> 332     idx = adapter-&gt;scan_entry_idx;</span>
 333     skip -= adapter-&gt;scan_offset;
 334   } else {
<span class="line-modified"> 335     idx = 0;</span>
 336   }
<span class="line-modified"> 337   buf = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
 338   bsize = gst_buffer_get_size (buf);
 339   while (G_UNLIKELY (skip &gt;= bsize)) {
 340     skip -= bsize;
<span class="line-modified"> 341     buf = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>

 342     bsize = gst_buffer_get_size (buf);
 343   }
 344   /* copy partial buffer */
 345   csize = MIN (bsize - skip, size);
 346   GST_DEBUG (&quot;bsize %&quot; G_GSIZE_FORMAT &quot;, skip %&quot; G_GSIZE_FORMAT &quot;, csize %&quot;
 347       G_GSIZE_FORMAT, bsize, skip, csize);
 348   GST_CAT_LOG_OBJECT (GST_CAT_PERFORMANCE, adapter, &quot;extract %&quot; G_GSIZE_FORMAT
 349       &quot; bytes&quot;, csize);
 350   gst_buffer_extract (buf, skip, dest, csize);
 351   size -= csize;
 352   dest += csize;
 353 
 354   /* second step, copy remainder */
 355   while (size &gt; 0) {
<span class="line-modified"> 356     buf = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>

 357     bsize = gst_buffer_get_size (buf);
 358     if (G_LIKELY (bsize &gt; 0)) {
 359       csize = MIN (bsize, size);
 360       GST_CAT_LOG_OBJECT (GST_CAT_PERFORMANCE, adapter,
 361           &quot;extract %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, csize);
 362       gst_buffer_extract (buf, 0, dest, csize);
 363       size -= csize;
 364       dest += csize;
 365     }
 366   }
 367 }
 368 
 369 /**
 370  * gst_adapter_push:
 371  * @adapter: a #GstAdapter
 372  * @buf: (transfer full): a #GstBuffer to add to queue in the adapter
 373  *
 374  * Adds the data from @buf to the data stored inside @adapter and takes
 375  * ownership of the buffer.
 376  */
 377 void
 378 gst_adapter_push (GstAdapter * adapter, GstBuffer * buf)
 379 {
 380   gsize size;
 381 
 382   g_return_if_fail (GST_IS_ADAPTER (adapter));
 383   g_return_if_fail (GST_IS_BUFFER (buf));
 384 
 385   size = gst_buffer_get_size (buf);
 386   adapter-&gt;size += size;
 387 
 388   /* Note: merging buffers at this point is premature. */
<span class="line-modified"> 389   if (gst_queue_array_is_empty (adapter-&gt;bufqueue)) {</span>
 390     GST_LOG_OBJECT (adapter, &quot;pushing %p first %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
 391         buf, size);
<span class="line-modified"> 392     gst_queue_array_push_tail (adapter-&gt;bufqueue, buf);</span>
 393     update_timestamps_and_offset (adapter, buf);
 394   } else {
 395     /* Otherwise append to the end, and advance our end pointer */
 396     GST_LOG_OBJECT (adapter, &quot;pushing %p %&quot; G_GSIZE_FORMAT &quot; bytes at end, &quot;
 397         &quot;size now %&quot; G_GSIZE_FORMAT, buf, size, adapter-&gt;size);
<span class="line-modified"> 398     gst_queue_array_push_tail (adapter-&gt;bufqueue, buf);</span>

 399   }
 400   ++adapter-&gt;count;
 401 }
 402 
 403 #if 0
 404 /* Internal method only. Tries to merge buffers at the head of the queue
 405  * to form a single larger buffer of size &#39;size&#39;.
 406  *
 407  * Returns %TRUE if it managed to merge anything.
 408  */
 409 static gboolean
 410 gst_adapter_try_to_merge_up (GstAdapter * adapter, gsize size)
 411 {
 412   GstBuffer *cur, *head;
 413   GSList *g;
 414   gboolean ret = FALSE;
 415   gsize hsize;
 416 
 417   g = adapter-&gt;buflist;
 418   if (g == NULL)
</pre>
<hr />
<pre>
 490 
 491   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
 492   g_return_val_if_fail (size &gt; 0, NULL);
 493 
 494   if (adapter-&gt;info.memory)
 495     gst_adapter_unmap (adapter);
 496 
 497   /* we don&#39;t have enough data, return NULL. This is unlikely
 498    * as one usually does an _available() first instead of peeking a
 499    * random size. */
 500   if (G_UNLIKELY (size &gt; adapter-&gt;size))
 501     return NULL;
 502 
 503   /* we have enough assembled data, return it */
 504   if (adapter-&gt;assembled_len &gt;= size)
 505     return adapter-&gt;assembled_data;
 506 
 507 #if 0
 508   do {
 509 #endif
<span class="line-modified"> 510     cur = gst_queue_array_peek_head (adapter-&gt;bufqueue);</span>
 511     skip = adapter-&gt;skip;
 512 
 513     csize = gst_buffer_get_size (cur);
 514     if (csize &gt;= size + skip) {
 515       if (!gst_buffer_map (cur, &amp;adapter-&gt;info, GST_MAP_READ))
 516         return FALSE;
 517 
 518       return (guint8 *) adapter-&gt;info.data + skip;
 519     }
 520     /* We may be able to efficiently merge buffers in our pool to
 521      * gather a big enough chunk to return it from the head buffer directly */
 522 #if 0
 523   } while (gst_adapter_try_to_merge_up (adapter, size));
 524 #endif
 525 
 526   /* see how much data we can reuse from the assembled memory and how much
 527    * we need to copy */
 528   toreuse = adapter-&gt;assembled_len;
 529   tocopy = size - toreuse;
 530 
</pre>
<hr />
<pre>
 551       &quot; bytes from adapter&quot;, tocopy);
 552   data = adapter-&gt;assembled_data;
 553   copy_into_unchecked (adapter, data + toreuse, skip + toreuse, tocopy);
 554   adapter-&gt;assembled_len = size;
 555 
 556   return adapter-&gt;assembled_data;
 557 }
 558 
 559 /**
 560  * gst_adapter_unmap:
 561  * @adapter: a #GstAdapter
 562  *
 563  * Releases the memory obtained with the last gst_adapter_map().
 564  */
 565 void
 566 gst_adapter_unmap (GstAdapter * adapter)
 567 {
 568   g_return_if_fail (GST_IS_ADAPTER (adapter));
 569 
 570   if (adapter-&gt;info.memory) {
<span class="line-modified"> 571     GstBuffer *cur = gst_queue_array_peek_head (adapter-&gt;bufqueue);</span>
 572     GST_LOG_OBJECT (adapter, &quot;unmap memory buffer %p&quot;, cur);
 573     gst_buffer_unmap (cur, &amp;adapter-&gt;info);
 574     adapter-&gt;info.memory = NULL;
 575   }
 576 }
 577 
 578 /**
 579  * gst_adapter_copy: (skip)
 580  * @adapter: a #GstAdapter
 581  * @dest: (out caller-allocates) (array length=size) (element-type guint8):
 582  *     the memory to copy into
 583  * @offset: the bytes offset in the adapter to start from
 584  * @size: the number of bytes to copy
 585  *
 586  * Copies @size bytes of data starting at @offset out of the buffers
 587  * contained in #GstAdapter into an array @dest provided by the caller.
 588  *
 589  * The array @dest should be large enough to contain @size bytes.
 590  * The user should check that the adapter has (@offset + @size) bytes
 591  * available before calling this function.
</pre>
<hr />
<pre>
 613  *
 614  * Returns: (transfer full): A new #GBytes structure containing the copied data.
 615  *
 616  * Since: 1.4
 617  */
 618 GBytes *
 619 gst_adapter_copy_bytes (GstAdapter * adapter, gsize offset, gsize size)
 620 {
 621   gpointer data;
 622   data = g_malloc (size);
 623   gst_adapter_copy (adapter, data, offset, size);
 624   return g_bytes_new_take (data, size);
 625 }
 626 
 627 /*Flushes the first @flush bytes in the @adapter*/
 628 static void
 629 gst_adapter_flush_unchecked (GstAdapter * adapter, gsize flush)
 630 {
 631   GstBuffer *cur;
 632   gsize size;

 633 
 634   GST_LOG_OBJECT (adapter, &quot;flushing %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, flush);
 635 
 636   if (adapter-&gt;info.memory)
 637     gst_adapter_unmap (adapter);
 638 
 639   /* clear state */
 640   adapter-&gt;size -= flush;
 641   adapter-&gt;assembled_len = 0;
 642 
 643   /* take skip into account */
 644   flush += adapter-&gt;skip;
 645   /* distance is always at least the amount of skipped bytes */
 646   adapter-&gt;pts_distance -= adapter-&gt;skip;
 647   adapter-&gt;dts_distance -= adapter-&gt;skip;
 648   adapter-&gt;offset_distance -= adapter-&gt;skip;
 649   adapter-&gt;distance_from_discont -= adapter-&gt;skip;
 650 
<span class="line-modified"> 651   cur = gst_queue_array_peek_head (adapter-&gt;bufqueue);</span>

 652   size = gst_buffer_get_size (cur);
 653   while (flush &gt;= size) {
 654     /* can skip whole buffer */
 655     GST_LOG_OBJECT (adapter, &quot;flushing out head buffer&quot;);
 656     adapter-&gt;pts_distance += size;
 657     adapter-&gt;dts_distance += size;
 658     adapter-&gt;offset_distance += size;
 659     adapter-&gt;distance_from_discont += size;
 660     flush -= size;
 661 


 662     --adapter-&gt;count;
 663 
<span class="line-modified"> 664     cur = NULL;</span>
<span class="line-added"> 665     gst_buffer_unref (gst_queue_array_pop_head (adapter-&gt;bufqueue));</span>
<span class="line-added"> 666 </span>
<span class="line-added"> 667     if (gst_queue_array_is_empty (adapter-&gt;bufqueue)) {</span>
 668       GST_LOG_OBJECT (adapter, &quot;adapter empty now&quot;);

 669       break;
 670     }
 671     /* there is a new head buffer, update the timestamps */
<span class="line-modified"> 672     cur = gst_queue_array_peek_head (adapter-&gt;bufqueue);</span>
 673     update_timestamps_and_offset (adapter, cur);
 674     size = gst_buffer_get_size (cur);
 675   }

 676   /* account for the remaining bytes */
 677   adapter-&gt;skip = flush;
 678   adapter-&gt;pts_distance += flush;
 679   adapter-&gt;dts_distance += flush;
 680   adapter-&gt;offset_distance += flush;
 681   adapter-&gt;distance_from_discont += flush;
 682   /* invalidate scan position */
 683   adapter-&gt;scan_offset = 0;
<span class="line-modified"> 684   adapter-&gt;scan_entry_idx = G_MAXUINT;</span>
 685 }
 686 
 687 /**
 688  * gst_adapter_flush:
 689  * @adapter: a #GstAdapter
 690  * @flush: the number of bytes to flush
 691  *
 692  * Flushes the first @flush bytes in the @adapter. The caller must ensure that
 693  * at least this many bytes are available.
 694  *
 695  * See also: gst_adapter_map(), gst_adapter_unmap()
 696  */
 697 void
 698 gst_adapter_flush (GstAdapter * adapter, gsize flush)
 699 {
 700   g_return_if_fail (GST_IS_ADAPTER (adapter));
 701   g_return_if_fail (flush &lt;= adapter-&gt;size);
 702 
 703   /* flushing out 0 bytes will do nothing */
 704   if (G_UNLIKELY (flush == 0))
</pre>
<hr />
<pre>
 794  * Returns a #GstBuffer containing the first @nbytes of the @adapter, but
 795  * does not flush them from the adapter. See gst_adapter_take_buffer_fast()
 796  * for details.
 797  *
 798  * Caller owns a reference to the returned buffer. gst_buffer_unref() after
 799  * usage.
 800  *
 801  * Free-function: gst_buffer_unref
 802  *
 803  * Returns: (transfer full) (nullable): a #GstBuffer containing the first
 804  *     @nbytes of the adapter, or %NULL if @nbytes bytes are not available.
 805  *     gst_buffer_unref() when no longer needed.
 806  *
 807  * Since: 1.6
 808  */
 809 GstBuffer *
 810 gst_adapter_get_buffer_fast (GstAdapter * adapter, gsize nbytes)
 811 {
 812   GstBuffer *buffer = NULL;
 813   GstBuffer *cur;

 814   gsize skip;
 815   gsize left = nbytes;
<span class="line-added"> 816   guint idx, len;</span>
 817 
 818   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
 819   g_return_val_if_fail (nbytes &gt; 0, NULL);
 820 
 821   GST_LOG_OBJECT (adapter, &quot;getting buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
 822       nbytes);
 823 
 824   /* we don&#39;t have enough data, return NULL. This is unlikely
 825    * as one usually does an _available() first instead of grabbing a
 826    * random size. */
 827   if (G_UNLIKELY (nbytes &gt; adapter-&gt;size))
 828     return NULL;
 829 
 830   skip = adapter-&gt;skip;
<span class="line-modified"> 831   cur = gst_queue_array_peek_head (adapter-&gt;bufqueue);</span>
 832 
 833   if (skip == 0 &amp;&amp; gst_buffer_get_size (cur) == nbytes) {
 834     GST_LOG_OBJECT (adapter, &quot;providing buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
 835         &quot; as head buffer&quot;, nbytes);
 836     buffer = gst_buffer_ref (cur);
 837     goto done;
 838   }
 839 
<span class="line-modified"> 840   len = gst_queue_array_get_length (adapter-&gt;bufqueue);</span>
<span class="line-added"> 841 </span>
<span class="line-added"> 842   for (idx = 0; idx &lt; len &amp;&amp; left &gt; 0; idx++) {</span>
 843     gsize size, cur_size;
 844 
<span class="line-modified"> 845     cur = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx);</span>
 846     cur_size = gst_buffer_get_size (cur);
 847     size = MIN (cur_size - skip, left);
 848 
 849     GST_LOG_OBJECT (adapter, &quot;appending %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
 850         &quot; via region copy&quot;, size);
 851     if (buffer)
 852       gst_buffer_copy_into (buffer, cur,
 853           GST_BUFFER_COPY_MEMORY | GST_BUFFER_COPY_META, skip, size);
 854     else
 855       buffer = gst_buffer_copy_region (cur, GST_BUFFER_COPY_ALL, skip, size);
 856     skip = 0;
 857     left -= size;
 858   }
 859 
 860 done:
 861 
 862   return buffer;
 863 }
 864 
 865 /**
</pre>
<hr />
<pre>
 962 GstBuffer *
 963 gst_adapter_get_buffer (GstAdapter * adapter, gsize nbytes)
 964 {
 965   GstBuffer *buffer;
 966   GstBuffer *cur;
 967   gsize hsize, skip;
 968   guint8 *data;
 969 
 970   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
 971   g_return_val_if_fail (nbytes &gt; 0, NULL);
 972 
 973   GST_LOG_OBJECT (adapter, &quot;getting buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;,
 974       nbytes);
 975 
 976   /* we don&#39;t have enough data, return NULL. This is unlikely
 977    * as one usually does an _available() first instead of grabbing a
 978    * random size. */
 979   if (G_UNLIKELY (nbytes &gt; adapter-&gt;size))
 980     return NULL;
 981 
<span class="line-modified"> 982   cur = gst_queue_array_peek_head (adapter-&gt;bufqueue);</span>
 983   skip = adapter-&gt;skip;
 984   hsize = gst_buffer_get_size (cur);
 985 
 986   /* our head buffer has enough data left, return it */
 987   if (skip == 0 &amp;&amp; hsize == nbytes) {
 988     GST_LOG_OBJECT (adapter, &quot;providing buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
 989         &quot; as head buffer&quot;, nbytes);
 990     buffer = gst_buffer_ref (cur);
 991     goto done;
 992   } else if (hsize &gt;= nbytes + skip) {
 993     GST_LOG_OBJECT (adapter, &quot;providing buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
 994         &quot; via region copy&quot;, nbytes);
 995     buffer = gst_buffer_copy_region (cur, GST_BUFFER_COPY_ALL, skip, nbytes);
 996     goto done;
 997   }
 998 #if 0
 999   if (gst_adapter_try_to_merge_up (adapter, nbytes)) {
1000     /* Merged something, let&#39;s try again for sub-buffering */
1001     cur = adapter-&gt;buflist-&gt;data;
1002     skip = adapter-&gt;skip;
1003     if (gst_buffer_get_size (cur) &gt;= nbytes + skip) {
1004       GST_LOG_OBJECT (adapter, &quot;providing buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
1005           &quot; via sub-buffer&quot;, nbytes);
1006       buffer = gst_buffer_copy_region (cur, GST_BUFFER_COPY_ALL, skip, nbytes);
1007       goto done;
1008     }
1009   }
1010 #endif
1011 
1012   data = gst_adapter_get_internal (adapter, nbytes);
1013 
1014   buffer = gst_buffer_new_wrapped (data, nbytes);
1015 
1016   {
<span class="line-modified">1017     guint idx, len;</span>
1018     GstBuffer *cur;
1019     gsize read_offset = 0;
1020 
<span class="line-modified">1021     idx = 0;</span>
<span class="line-modified">1022     len = gst_queue_array_get_length (adapter-&gt;bufqueue);</span>
<span class="line-modified">1023 </span>
<span class="line-added">1024     while (idx &lt; len &amp;&amp; read_offset &lt; nbytes + adapter-&gt;skip) {</span>
<span class="line-added">1025       cur = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx);</span>
1026 
1027       gst_buffer_foreach_meta (cur, foreach_metadata, buffer);
1028       read_offset += gst_buffer_get_size (cur);
1029 
<span class="line-modified">1030       idx++;</span>
1031     }
1032   }
1033 
1034 done:
1035 
1036   return buffer;
1037 }
1038 
1039 /**
1040  * gst_adapter_take_buffer:
1041  * @adapter: a #GstAdapter
1042  * @nbytes: the number of bytes to take
1043  *
1044  * Returns a #GstBuffer containing the first @nbytes bytes of the
1045  * @adapter. The returned bytes will be flushed from the adapter.
1046  * This function is potentially more performant than
1047  * gst_adapter_take() since it can reuse the memory in pushed buffers
1048  * by subbuffering or merging. This function will always return a
1049  * buffer with a single memory region.
1050  *
</pre>
<hr />
<pre>
1093  * Caller owns returned list and contained buffers. gst_buffer_unref() each
1094  * buffer in the list before freeing the list after usage.
1095  *
1096  * Returns: (element-type Gst.Buffer) (transfer full) (nullable): a #GList of
1097  *     buffers containing the first @nbytes of the adapter, or %NULL if @nbytes
1098  *     bytes are not available
1099  */
1100 GList *
1101 gst_adapter_take_list (GstAdapter * adapter, gsize nbytes)
1102 {
1103   GQueue queue = G_QUEUE_INIT;
1104   GstBuffer *cur;
1105   gsize hsize, skip, cur_size;
1106 
1107   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
1108   g_return_val_if_fail (nbytes &lt;= adapter-&gt;size, NULL);
1109 
1110   GST_LOG_OBJECT (adapter, &quot;taking %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, nbytes);
1111 
1112   while (nbytes &gt; 0) {
<span class="line-modified">1113     cur = gst_queue_array_peek_head (adapter-&gt;bufqueue);</span>
1114     skip = adapter-&gt;skip;
1115     cur_size = gst_buffer_get_size (cur);
1116     hsize = MIN (nbytes, cur_size - skip);
1117 
1118     cur = gst_adapter_take_buffer (adapter, hsize);
1119 
1120     g_queue_push_tail (&amp;queue, cur);
1121 
1122     nbytes -= hsize;
1123   }
1124   return queue.head;
1125 }
1126 
1127 /**
1128  * gst_adapter_get_list:
1129  * @adapter: a #GstAdapter
1130  * @nbytes: the number of bytes to get
1131  *
1132  * Returns a #GList of buffers containing the first @nbytes bytes of the
1133  * @adapter, but does not flush them from the adapter. See
1134  * gst_adapter_take_list() for details.
1135  *
1136  * Caller owns returned list and contained buffers. gst_buffer_unref() each
1137  * buffer in the list before freeing the list after usage.
1138  *
1139  * Returns: (element-type Gst.Buffer) (transfer full) (nullable): a #GList of
1140  *     buffers containing the first @nbytes of the adapter, or %NULL if @nbytes
1141  *     bytes are not available
1142  *
1143  * Since: 1.6
1144  */
1145 GList *
1146 gst_adapter_get_list (GstAdapter * adapter, gsize nbytes)
1147 {
1148   GQueue queue = G_QUEUE_INIT;
1149   GstBuffer *cur, *buffer;
1150   gsize hsize, skip, cur_size;
<span class="line-modified">1151   guint idx;</span>
1152 
1153   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
1154   g_return_val_if_fail (nbytes &lt;= adapter-&gt;size, NULL);
1155 
1156   GST_LOG_OBJECT (adapter, &quot;getting %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, nbytes);
1157 
<span class="line-modified">1158   idx = 0;</span>
1159   skip = adapter-&gt;skip;
1160 
1161   while (nbytes &gt; 0) {
<span class="line-modified">1162     cur = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
1163     cur_size = gst_buffer_get_size (cur);
1164     hsize = MIN (nbytes, cur_size - skip);
1165 
1166     if (skip == 0 &amp;&amp; cur_size == hsize) {
1167       GST_LOG_OBJECT (adapter,
1168           &quot;inserting a buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, hsize);
1169       buffer = gst_buffer_ref (cur);
1170     } else {
1171       GST_LOG_OBJECT (adapter, &quot;inserting a buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
1172           &quot; via region copy&quot;, hsize);
1173       buffer = gst_buffer_copy_region (cur, GST_BUFFER_COPY_ALL, skip, hsize);
1174     }
1175 
1176     g_queue_push_tail (&amp;queue, buffer);
1177 
1178     nbytes -= hsize;
1179     skip = 0;

1180   }
1181 
1182   return queue.head;
1183 }
1184 
1185 /**
1186  * gst_adapter_take_buffer_list:
1187  * @adapter: a #GstAdapter
1188  * @nbytes: the number of bytes to take
1189  *
1190  * Returns a #GstBufferList of buffers containing the first @nbytes bytes of
1191  * the @adapter. The returned bytes will be flushed from the adapter.
1192  * When the caller can deal with individual buffers, this function is more
1193  * performant because no memory should be copied.
1194  *
1195  * Caller owns the returned list. Call gst_buffer_list_unref() to free
1196  * the list after usage.
1197  *
1198  * Returns: (transfer full) (nullable): a #GstBufferList of buffers containing
1199  *     the first @nbytes of the adapter, or %NULL if @nbytes bytes are not
</pre>
<hr />
<pre>
1208   GstBuffer *cur;
1209   gsize hsize, skip, cur_size;
1210   guint n_bufs;
1211 
1212   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
1213 
1214   if (nbytes &gt; adapter-&gt;size)
1215     return NULL;
1216 
1217   GST_LOG_OBJECT (adapter, &quot;taking %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, nbytes);
1218 
1219   /* try to create buffer list with sufficient size, so no resize is done later */
1220   if (adapter-&gt;count &lt; 64)
1221     n_bufs = adapter-&gt;count;
1222   else
1223     n_bufs = (adapter-&gt;count * nbytes * 1.2 / adapter-&gt;size) + 1;
1224 
1225   buffer_list = gst_buffer_list_new_sized (n_bufs);
1226 
1227   while (nbytes &gt; 0) {
<span class="line-modified">1228     cur = gst_queue_array_peek_head (adapter-&gt;bufqueue);</span>
1229     skip = adapter-&gt;skip;
1230     cur_size = gst_buffer_get_size (cur);
1231     hsize = MIN (nbytes, cur_size - skip);
1232 
1233     gst_buffer_list_add (buffer_list, gst_adapter_take_buffer (adapter, hsize));
1234     nbytes -= hsize;
1235   }
1236   return buffer_list;
1237 }
1238 
1239 /**
1240  * gst_adapter_get_buffer_list:
1241  * @adapter: a #GstAdapter
1242  * @nbytes: the number of bytes to get
1243  *
1244  * Returns a #GstBufferList of buffers containing the first @nbytes bytes of
1245  * the @adapter but does not flush them from the adapter. See
1246  * gst_adapter_take_buffer_list() for details.
1247  *
1248  * Caller owns the returned list. Call gst_buffer_list_unref() to free
1249  * the list after usage.
1250  *
1251  * Returns: (transfer full) (nullable): a #GstBufferList of buffers containing
1252  *     the first @nbytes of the adapter, or %NULL if @nbytes bytes are not
1253  *     available
1254  *
1255  * Since: 1.6
1256  */
1257 GstBufferList *
1258 gst_adapter_get_buffer_list (GstAdapter * adapter, gsize nbytes)
1259 {
1260   GstBufferList *buffer_list;
1261   GstBuffer *cur, *buffer;
1262   gsize hsize, skip, cur_size;
1263   guint n_bufs;
<span class="line-modified">1264   guint idx;</span>
1265 
1266   g_return_val_if_fail (GST_IS_ADAPTER (adapter), NULL);
1267 
1268   if (nbytes &gt; adapter-&gt;size)
1269     return NULL;
1270 
1271   GST_LOG_OBJECT (adapter, &quot;getting %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, nbytes);
1272 
1273   /* try to create buffer list with sufficient size, so no resize is done later */
1274   if (adapter-&gt;count &lt; 64)
1275     n_bufs = adapter-&gt;count;
1276   else
1277     n_bufs = (adapter-&gt;count * nbytes * 1.2 / adapter-&gt;size) + 1;
1278 
1279   buffer_list = gst_buffer_list_new_sized (n_bufs);
1280 
<span class="line-modified">1281   idx = 0;</span>
1282   skip = adapter-&gt;skip;
1283 
1284   while (nbytes &gt; 0) {
<span class="line-modified">1285     cur = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
1286     cur_size = gst_buffer_get_size (cur);
1287     hsize = MIN (nbytes, cur_size - skip);
1288 
1289     if (skip == 0 &amp;&amp; cur_size == hsize) {
1290       GST_LOG_OBJECT (adapter,
1291           &quot;inserting a buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;, hsize);
1292       buffer = gst_buffer_ref (cur);
1293     } else {
1294       GST_LOG_OBJECT (adapter, &quot;inserting a buffer of %&quot; G_GSIZE_FORMAT &quot; bytes&quot;
1295           &quot; via region copy&quot;, hsize);
1296       buffer = gst_buffer_copy_region (cur, GST_BUFFER_COPY_ALL, skip, hsize);
1297     }
1298 
1299     gst_buffer_list_add (buffer_list, buffer);
1300 
1301     nbytes -= hsize;
1302     skip = 0;

1303   }
1304 
1305   return buffer_list;
1306 }
1307 
1308 /**
1309  * gst_adapter_available:
1310  * @adapter: a #GstAdapter
1311  *
1312  * Gets the maximum amount of bytes available, that is it returns the maximum
1313  * value that can be supplied to gst_adapter_map() without that function
1314  * returning %NULL.
1315  *
1316  * Returns: number of bytes available in @adapter
1317  */
1318 gsize
1319 gst_adapter_available (GstAdapter * adapter)
1320 {
1321   g_return_val_if_fail (GST_IS_ADAPTER (adapter), 0);
1322 
1323   return adapter-&gt;size;
1324 }
1325 
1326 /**
1327  * gst_adapter_available_fast:
1328  * @adapter: a #GstAdapter
1329  *
1330  * Gets the maximum number of bytes that are immediately available without
1331  * requiring any expensive operations (like copying the data into a
1332  * temporary buffer).
1333  *
1334  * Returns: number of bytes that are available in @adapter without expensive
1335  * operations
1336  */
1337 gsize
1338 gst_adapter_available_fast (GstAdapter * adapter)
1339 {
1340   GstBuffer *cur;
1341   gsize size;
<span class="line-modified">1342   guint idx;</span>
1343 
1344   g_return_val_if_fail (GST_IS_ADAPTER (adapter), 0);
1345 
1346   /* no data */
1347   if (adapter-&gt;size == 0)
1348     return 0;
1349 
1350   /* some stuff we already assembled */
1351   if (adapter-&gt;assembled_len)
1352     return adapter-&gt;assembled_len;
1353 
1354   /* take the first non-zero buffer */
<span class="line-modified">1355   idx = 0;</span>
1356   while (TRUE) {
<span class="line-modified">1357     cur = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
1358     size = gst_buffer_get_size (cur);
1359     if (size != 0)
1360       break;

1361   }
1362 
1363   /* we can quickly get the (remaining) data of the first buffer */
1364   return size - adapter-&gt;skip;
1365 }
1366 
1367 /**
1368  * gst_adapter_get_distance_from_discont:
1369  * @adapter: a #GstAdapter
1370  *
1371  * Get the distance in bytes since the last buffer with the
1372  * %GST_BUFFER_FLAG_DISCONT flag.
1373  *
1374  * The distance will be reset to 0 for all buffers with
1375  * %GST_BUFFER_FLAG_DISCONT on them, and then calculated for all other
1376  * following buffers based on their size.
1377  *
1378  * Since: 1.10
1379  *
1380  * Returns: The offset. Can be %GST_BUFFER_OFFSET_NONE.
</pre>
<hr />
<pre>
1531  * @offset: the offset in the adapter at which to get timestamp
1532  * @distance: (out) (allow-none): pointer to location for distance, or %NULL
1533  *
1534  * Get the pts that was before the byte at offset @offset in the adapter. When
1535  * @distance is given, the amount of bytes between the pts and the current
1536  * position is returned.
1537  *
1538  * The pts is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when
1539  * the adapter is first created or when it is cleared. This also means that before
1540  * the first byte with a pts is removed from the adapter, the pts
1541  * and distance returned are GST_CLOCK_TIME_NONE and 0 respectively.
1542  *
1543  * Since: 1.2
1544  * Returns: The previously seen pts at given offset.
1545  */
1546 GstClockTime
1547 gst_adapter_prev_pts_at_offset (GstAdapter * adapter, gsize offset,
1548     guint64 * distance)
1549 {
1550   GstBuffer *cur;

1551   gsize read_offset = 0;
1552   gsize pts_offset = 0;
1553   GstClockTime pts = adapter-&gt;pts;
<span class="line-added">1554   guint idx, len;</span>
1555 
1556   g_return_val_if_fail (GST_IS_ADAPTER (adapter), GST_CLOCK_TIME_NONE);
1557 
<span class="line-modified">1558   idx = 0;</span>
<span class="line-added">1559   len = gst_queue_array_get_length (adapter-&gt;bufqueue);</span>
1560 
<span class="line-modified">1561   while (idx &lt; len &amp;&amp; read_offset &lt; offset + adapter-&gt;skip) {</span>
<span class="line-modified">1562     cur = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
1563 
1564     if (GST_CLOCK_TIME_IS_VALID (GST_BUFFER_PTS (cur))) {
1565       pts = GST_BUFFER_PTS (cur);
1566       pts_offset = read_offset;
1567     }
1568 
1569     read_offset += gst_buffer_get_size (cur);

1570   }
1571 
1572   if (distance)
1573     *distance = adapter-&gt;pts_distance + offset - pts_offset;
1574 
1575   return pts;
1576 }
1577 
1578 /**
1579  * gst_adapter_prev_dts_at_offset:
1580  * @adapter: a #GstAdapter
1581  * @offset: the offset in the adapter at which to get timestamp
1582  * @distance: (out) (allow-none): pointer to location for distance, or %NULL
1583  *
1584  * Get the dts that was before the byte at offset @offset in the adapter. When
1585  * @distance is given, the amount of bytes between the dts and the current
1586  * position is returned.
1587  *
1588  * The dts is reset to GST_CLOCK_TIME_NONE and the distance is set to 0 when
1589  * the adapter is first created or when it is cleared. This also means that before
1590  * the first byte with a dts is removed from the adapter, the dts
1591  * and distance returned are GST_CLOCK_TIME_NONE and 0 respectively.
1592  *
1593  * Since: 1.2
1594  * Returns: The previously seen dts at given offset.
1595  */
1596 GstClockTime
1597 gst_adapter_prev_dts_at_offset (GstAdapter * adapter, gsize offset,
1598     guint64 * distance)
1599 {
1600   GstBuffer *cur;

1601   gsize read_offset = 0;
1602   gsize dts_offset = 0;
1603   GstClockTime dts = adapter-&gt;dts;
<span class="line-added">1604   guint idx, len;</span>
1605 
1606   g_return_val_if_fail (GST_IS_ADAPTER (adapter), GST_CLOCK_TIME_NONE);
1607 
<span class="line-modified">1608   idx = 0;</span>
<span class="line-added">1609   len = gst_queue_array_get_length (adapter-&gt;bufqueue);</span>
1610 
<span class="line-modified">1611   while (idx &lt; len &amp;&amp; read_offset &lt; offset + adapter-&gt;skip) {</span>
<span class="line-modified">1612     cur = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
1613 
1614     if (GST_CLOCK_TIME_IS_VALID (GST_BUFFER_DTS (cur))) {
1615       dts = GST_BUFFER_DTS (cur);
1616       dts_offset = read_offset;
1617     }
1618 
1619     read_offset += gst_buffer_get_size (cur);

1620   }
1621 
1622   if (distance)
1623     *distance = adapter-&gt;dts_distance + offset - dts_offset;
1624 
1625   return dts;
1626 }
1627 
1628 /**
1629  * gst_adapter_masked_scan_uint32_peek:
1630  * @adapter: a #GstAdapter
1631  * @mask: mask to apply to data before matching against @pattern
1632  * @pattern: pattern to match (after mask is applied)
1633  * @offset: offset into the adapter data from which to start scanning, returns
1634  *          the last scanned position.
1635  * @size: number of bytes to scan from offset
1636  * @value: (out) (allow-none): pointer to uint32 to return matching data
1637  *
1638  * Scan for pattern @pattern with applied mask @mask in the adapter data,
1639  * starting from offset @offset.  If a match is found, the value that matched
1640  * is returned through @value, otherwise @value is left untouched.
1641  *
1642  * The bytes in @pattern and @mask are interpreted left-to-right, regardless
1643  * of endianness.  All four bytes of the pattern must be present in the
1644  * adapter for it to match, even if the first or last bytes are masked out.
1645  *
1646  * It is an error to call this function without making sure that there is
1647  * enough data (offset+size bytes) in the adapter.
1648  *
1649  * Returns: offset of the first match, or -1 if no match was found.
1650  */
1651 gssize
1652 gst_adapter_masked_scan_uint32_peek (GstAdapter * adapter, guint32 mask,
1653     guint32 pattern, gsize offset, gsize size, guint32 * value)
1654 {

1655   gsize skip, bsize, i;
1656   guint32 state;
1657   GstMapInfo info;
1658   guint8 *bdata;
1659   GstBuffer *buf;
<span class="line-added">1660   guint idx;</span>
1661 
1662   g_return_val_if_fail (size &gt; 0, -1);
1663   g_return_val_if_fail (offset + size &lt;= adapter-&gt;size, -1);
1664   g_return_val_if_fail (((~mask) &amp; pattern) == 0, -1);
1665 
1666   /* we can&#39;t find the pattern with less than 4 bytes */
1667   if (G_UNLIKELY (size &lt; 4))
1668     return -1;
1669 
1670   skip = offset + adapter-&gt;skip;
1671 
1672   /* first step, do skipping and position on the first buffer */
1673   /* optimistically assume scanning continues sequentially */
<span class="line-modified">1674   if (adapter-&gt;scan_entry_idx != G_MAXUINT &amp;&amp; (adapter-&gt;scan_offset &lt;= skip)) {</span>
<span class="line-modified">1675     idx = adapter-&gt;scan_entry_idx;</span>
1676     skip -= adapter-&gt;scan_offset;
1677   } else {
<span class="line-modified">1678     idx = 0;</span>
1679     adapter-&gt;scan_offset = 0;
<span class="line-modified">1680     adapter-&gt;scan_entry_idx = G_MAXUINT;</span>
1681   }
<span class="line-modified">1682   buf = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
1683   bsize = gst_buffer_get_size (buf);
1684   while (G_UNLIKELY (skip &gt;= bsize)) {
1685     skip -= bsize;

1686     adapter-&gt;scan_offset += bsize;
<span class="line-modified">1687     adapter-&gt;scan_entry_idx = idx;</span>
<span class="line-modified">1688     buf = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
1689     bsize = gst_buffer_get_size (buf);
1690   }
1691   /* get the data now */
1692   if (!gst_buffer_map (buf, &amp;info, GST_MAP_READ))
1693     return -1;
1694 
1695   bdata = (guint8 *) info.data + skip;
1696   bsize = info.size - skip;
1697   skip = 0;
1698 
1699   /* set the state to something that does not match */
1700   state = ~pattern;
1701 
1702   /* now find data */
1703   do {
1704     bsize = MIN (bsize, size);
1705     for (i = 0; i &lt; bsize; i++) {
1706       state = ((state &lt;&lt; 8) | bdata[i]);
1707       if (G_UNLIKELY ((state &amp; mask) == pattern)) {
1708         /* we have a match but we need to have skipped at
1709          * least 4 bytes to fill the state. */
1710         if (G_LIKELY (skip + i &gt;= 3)) {
1711           if (G_LIKELY (value))
1712             *value = state;
1713           gst_buffer_unmap (buf, &amp;info);
1714           return offset + skip + i - 3;
1715         }
1716       }
1717     }
1718     size -= bsize;
1719     if (size == 0)
1720       break;
1721 
1722     /* nothing found yet, go to next buffer */
1723     skip += bsize;

1724     adapter-&gt;scan_offset += info.size;
<span class="line-modified">1725     adapter-&gt;scan_entry_idx = idx;</span>
1726     gst_buffer_unmap (buf, &amp;info);
<span class="line-modified">1727     buf = gst_queue_array_peek_nth (adapter-&gt;bufqueue, idx++);</span>
1728 
1729     if (!gst_buffer_map (buf, &amp;info, GST_MAP_READ))
1730       return -1;
1731 
1732     bsize = info.size;
1733     bdata = info.data;
1734   } while (TRUE);
1735 
1736   gst_buffer_unmap (buf, &amp;info);
1737 
1738   /* nothing found */
1739   return -1;
1740 }
1741 
1742 /**
1743  * gst_adapter_masked_scan_uint32:
1744  * @adapter: a #GstAdapter
1745  * @mask: mask to apply to data before matching against @pattern
1746  * @pattern: pattern to match (after mask is applied)
1747  * @offset: offset into the adapter data from which to start scanning, returns
</pre>
</td>
</tr>
</table>
<center><a href="base.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="gstbaseparse.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>