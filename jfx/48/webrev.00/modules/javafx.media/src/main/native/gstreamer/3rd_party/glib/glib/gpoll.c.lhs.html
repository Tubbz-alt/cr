<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gpoll.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* GLIB - Library of useful routines for C programming
  2  * Copyright (C) 1995-1997  Peter Mattis, Spencer Kimball and Josh MacDonald
  3  *
  4  * gpoll.c: poll(2) abstraction
  5  * Copyright 1998 Owen Taylor
  6  * Copyright 2008 Red Hat, Inc.
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Lesser General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2.1 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Lesser General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Lesser General Public
 19  * License along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
 20  */
 21 
 22 /*
 23  * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
 24  * file for a list of people on the GLib Team.  See the ChangeLog
 25  * files for a list of changes.  These files are distributed with
 26  * GLib at ftp://ftp.gtk.org/pub/gtk/.
 27  */
 28 
 29 /*
 30  * MT safe
 31  */
 32 
 33 #include &quot;config.h&quot;
 34 #include &quot;glibconfig.h&quot;
 35 #include &quot;giochannel.h&quot;
 36 
 37 /* Uncomment the next line (and the corresponding line in gmain.c) to
 38  * enable debugging printouts if the environment variable
 39  * G_MAIN_POLL_DEBUG is set to some value.
 40  */
 41 /* #define G_MAIN_POLL_DEBUG */
 42 
 43 #ifdef _WIN32
 44 /* Always enable debugging printout on Windows, as it is more often
 45  * needed there...
 46  */
 47 #define G_MAIN_POLL_DEBUG
 48 #endif
 49 
 50 #include &lt;sys/types.h&gt;
 51 #include &lt;time.h&gt;
 52 #include &lt;stdlib.h&gt;
 53 #ifdef HAVE_SYS_TIME_H
 54 #include &lt;sys/time.h&gt;
 55 #endif /* HAVE_SYS_TIME_H */
 56 #ifdef HAVE_POLL
 57 #  include &lt;poll.h&gt;
 58 
 59 /* The poll() emulation on OS/X doesn&#39;t handle fds=NULL, nfds=0,
 60  * so we prefer our own poll emulation.
 61  */
 62 #if defined(_POLL_EMUL_H_) || defined(BROKEN_POLL)
 63 #undef HAVE_POLL
 64 #endif
 65 
 66 #endif /* GLIB_HAVE_SYS_POLL_H */
 67 #ifdef G_OS_UNIX
 68 #include &lt;unistd.h&gt;
 69 #endif /* G_OS_UNIX */
 70 #include &lt;errno.h&gt;
 71 
 72 #ifdef G_OS_WIN32
 73 #define STRICT
 74 #include &lt;windows.h&gt;
<a name="1" id="anc1"></a>
 75 #endif /* G_OS_WIN32 */
 76 
 77 #include &quot;gpoll.h&quot;
 78 
 79 #ifdef G_OS_WIN32
 80 #include &quot;gprintf.h&quot;
 81 #endif
 82 
 83 #ifdef G_MAIN_POLL_DEBUG
 84 extern gboolean _g_main_poll_debug;
 85 #endif
 86 
 87 #ifdef HAVE_POLL
 88 
 89 /**
 90  * g_poll:
 91  * @fds: file descriptors to poll
 92  * @nfds: the number of file descriptors in @fds
 93  * @timeout: amount of time to wait, in milliseconds, or -1 to wait forever
 94  *
 95  * Polls @fds, as with the poll() system call, but portably. (On
 96  * systems that don&#39;t have poll(), it is emulated using select().)
 97  * This is used internally by #GMainContext, but it can be called
 98  * directly if you need to block until a file descriptor is ready, but
 99  * don&#39;t want to run the full main loop.
100  *
101  * Each element of @fds is a #GPollFD describing a single file
102  * descriptor to poll. The @fd field indicates the file descriptor,
103  * and the @events field indicates the events to poll for. On return,
104  * the @revents fields will be filled with the events that actually
105  * occurred.
106  *
107  * On POSIX systems, the file descriptors in @fds can be any sort of
108  * file descriptor, but the situation is much more complicated on
109  * Windows. If you need to use g_poll() in code that has to run on
110  * Windows, the easiest solution is to construct all of your
111  * #GPollFDs with g_io_channel_win32_make_pollfd().
112  *
113  * Returns: the number of entries in @fds whose @revents fields
114  * were filled in, or 0 if the operation timed out, or -1 on error or
115  * if the call was interrupted.
116  *
117  * Since: 2.20
118  **/
119 gint
120 g_poll (GPollFD *fds,
<a name="2" id="anc2"></a><span class="line-modified">121     guint    nfds,</span>
<span class="line-modified">122     gint     timeout)</span>
123 {
124   return poll ((struct pollfd *)fds, nfds, timeout);
125 }
126 
<a name="3" id="anc3"></a><span class="line-modified">127 #else   /* !HAVE_POLL */</span>
128 
129 #ifdef G_OS_WIN32
130 
131 static int
132 poll_rest (GPollFD *msg_fd,
<a name="4" id="anc4"></a>
133            HANDLE  *handles,
134            GPollFD *handle_to_fd[],
135            gint     nhandles,
<a name="5" id="anc5"></a><span class="line-modified">136            gint     timeout)</span>
137 {
138   DWORD ready;
139   GPollFD *f;
140   int recursed_result;
141 
142   if (msg_fd != NULL)
143     {
144       /* Wait for either messages or handles
145        * -&gt; Use MsgWaitForMultipleObjectsEx
146        */
147       if (_g_main_poll_debug)
<a name="6" id="anc6"></a><span class="line-modified">148     g_print (&quot;  MsgWaitForMultipleObjectsEx(%d, %d)\n&quot;, nhandles, timeout);</span>
149 
<a name="7" id="anc7"></a><span class="line-modified">150       ready = MsgWaitForMultipleObjectsEx (nhandles, handles, timeout,</span>
<span class="line-modified">151                        QS_ALLINPUT, MWMO_ALERTABLE);</span>
152 
153       if (ready == WAIT_FAILED)
<a name="8" id="anc8"></a><span class="line-modified">154     {</span>
<span class="line-modified">155       gchar *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-modified">156       g_warning (&quot;MsgWaitForMultipleObjectsEx failed: %s&quot;, emsg);</span>
<span class="line-modified">157       g_free (emsg);</span>
<span class="line-modified">158     }</span>
159     }
160   else if (nhandles == 0)
161     {
162       /* No handles to wait for, just the timeout */
<a name="9" id="anc9"></a><span class="line-modified">163       if (timeout == INFINITE)</span>
<span class="line-modified">164     ready = WAIT_FAILED;</span>
165       else
<a name="10" id="anc10"></a><span class="line-modified">166     {</span>
167           /* Wait for the current process to die, more efficient than SleepEx(). */
<a name="11" id="anc11"></a><span class="line-modified">168           WaitForSingleObjectEx (GetCurrentProcess (), timeout, TRUE);</span>
<span class="line-modified">169       ready = WAIT_TIMEOUT;</span>
<span class="line-modified">170     }</span>
171     }
172   else
173     {
174       /* Wait for just handles
175        * -&gt; Use WaitForMultipleObjectsEx
176        */
177       if (_g_main_poll_debug)
<a name="12" id="anc12"></a><span class="line-modified">178     g_print (&quot;  WaitForMultipleObjectsEx(%d, %d)\n&quot;, nhandles, timeout);</span>
179 
<a name="13" id="anc13"></a><span class="line-modified">180       ready = WaitForMultipleObjectsEx (nhandles, handles, FALSE, timeout, TRUE);</span>
181       if (ready == WAIT_FAILED)
<a name="14" id="anc14"></a><span class="line-modified">182     {</span>
<span class="line-modified">183       gchar *emsg = g_win32_error_message (GetLastError ());</span>
<span class="line-modified">184       g_warning (&quot;WaitForMultipleObjectsEx failed: %s&quot;, emsg);</span>
<span class="line-modified">185       g_free (emsg);</span>
<span class="line-modified">186     }</span>
187     }
188 
189   if (_g_main_poll_debug)
190     g_print (&quot;  wait returns %ld%s\n&quot;,
<a name="15" id="anc15"></a><span class="line-modified">191          ready,</span>
<span class="line-modified">192          (ready == WAIT_FAILED ? &quot; (WAIT_FAILED)&quot; :</span>
<span class="line-modified">193           (ready == WAIT_TIMEOUT ? &quot; (WAIT_TIMEOUT)&quot; :</span>
<span class="line-modified">194            (msg_fd != NULL &amp;&amp; ready == WAIT_OBJECT_0 + nhandles ? &quot; (msg)&quot; : &quot;&quot;))));</span>
195 
196   if (ready == WAIT_FAILED)
197     return -1;
198   else if (ready == WAIT_TIMEOUT ||
<a name="16" id="anc16"></a><span class="line-modified">199        ready == WAIT_IO_COMPLETION)</span>
200     return 0;
201   else if (msg_fd != NULL &amp;&amp; ready == WAIT_OBJECT_0 + nhandles)
202     {
203       msg_fd-&gt;revents |= G_IO_IN;
204 
205       /* If we have a timeout, or no handles to poll, be satisfied
206        * with just noticing we have messages waiting.
207        */
<a name="17" id="anc17"></a><span class="line-modified">208       if (timeout != 0 || nhandles == 0)</span>
<span class="line-modified">209     return 1;</span>
210 
211       /* If no timeout and handles to poll, recurse to poll them,
212        * too.
213        */
<a name="18" id="anc18"></a><span class="line-modified">214       recursed_result = poll_rest (NULL, handles, handle_to_fd, nhandles, 0);</span>
215       return (recursed_result == -1) ? -1 : 1 + recursed_result;
216     }
217   else if (ready &gt;= WAIT_OBJECT_0 &amp;&amp; ready &lt; WAIT_OBJECT_0 + nhandles)
218     {
<a name="19" id="anc19"></a>

219       f = handle_to_fd[ready - WAIT_OBJECT_0];
<a name="20" id="anc20"></a><span class="line-modified">220           f-&gt;revents = f-&gt;events;</span>
<span class="line-modified">221           if (_g_main_poll_debug)</span>
222         g_print (&quot;  got event %p\n&quot;, (HANDLE) f-&gt;fd);
223 
<a name="21" id="anc21"></a>


224       /* If no timeout and polling several handles, recurse to poll
225        * the rest of them.
226        */
<a name="22" id="anc22"></a><span class="line-modified">227       if (timeout == 0 &amp;&amp; nhandles &gt; 1)</span>
<span class="line-modified">228     {</span>
<span class="line-modified">229       /* Poll the handles with index &gt; ready */</span>
<span class="line-modified">230           HANDLE  *shorter_handles;</span>
231           GPollFD **shorter_handle_to_fd;
<a name="23" id="anc23"></a><span class="line-modified">232           gint     shorter_nhandles;</span>
233 
234           shorter_handles = &amp;handles[ready - WAIT_OBJECT_0 + 1];
235           shorter_handle_to_fd = &amp;handle_to_fd[ready - WAIT_OBJECT_0 + 1];
236           shorter_nhandles = nhandles - (ready - WAIT_OBJECT_0 + 1);
237 
<a name="24" id="anc24"></a><span class="line-modified">238       recursed_result = poll_rest (NULL, shorter_handles, shorter_handle_to_fd, shorter_nhandles, 0);</span>
<span class="line-modified">239       return (recursed_result == -1) ? -1 : 1 + recursed_result;</span>
<span class="line-modified">240     }</span>
<span class="line-modified">241       return 1;</span>
242     }
243 
244   return 0;
245 }
246 
<a name="25" id="anc25"></a><span class="line-modified">247 gint</span>
<span class="line-removed">248 g_poll (GPollFD *fds,</span>
<span class="line-removed">249     guint    nfds,</span>
<span class="line-removed">250     gint     timeout)</span>
251 {
252   HANDLE handles[MAXIMUM_WAIT_OBJECTS];
253   GPollFD *handle_to_fd[MAXIMUM_WAIT_OBJECTS];
<a name="26" id="anc26"></a><span class="line-modified">254   GPollFD *msg_fd = NULL;</span>
<span class="line-modified">255   GPollFD *f;</span>
<span class="line-modified">256   gint nhandles = 0;</span>






257   int retval;
258 
<a name="27" id="anc27"></a><span class="line-removed">259   if (_g_main_poll_debug)</span>
<span class="line-removed">260     g_print (&quot;g_poll: waiting for&quot;);</span>
<span class="line-removed">261 </span>
<span class="line-removed">262   for (f = fds; f &lt; &amp;fds[nfds]; ++f)</span>
<span class="line-removed">263     {</span>
<span class="line-removed">264     if (f-&gt;fd == G_WIN32_MSG_HANDLE &amp;&amp; (f-&gt;events &amp; G_IO_IN))</span>
<span class="line-removed">265       {</span>
<span class="line-removed">266           if (_g_main_poll_debug &amp;&amp; msg_fd == NULL)</span>
<span class="line-removed">267       g_print (&quot; MSG&quot;);</span>
<span class="line-removed">268           msg_fd = f;</span>
<span class="line-removed">269       }</span>
<span class="line-removed">270     else if (f-&gt;fd &gt; 0)</span>
<span class="line-removed">271       {</span>
<span class="line-removed">272         if (nhandles == MAXIMUM_WAIT_OBJECTS)</span>
<span class="line-removed">273           {</span>
<span class="line-removed">274             g_warning (&quot;Too many handles to wait for!&quot;);</span>
<span class="line-removed">275             break;</span>
<span class="line-removed">276           }</span>
<span class="line-removed">277         else</span>
<span class="line-removed">278           {</span>
<span class="line-removed">279         if (_g_main_poll_debug)</span>
<span class="line-removed">280           g_print (&quot; %p&quot;, (HANDLE) f-&gt;fd);</span>
<span class="line-removed">281               handle_to_fd[nhandles] = f;</span>
<span class="line-removed">282         handles[nhandles++] = (HANDLE) f-&gt;fd;</span>
<span class="line-removed">283           }</span>
<span class="line-removed">284       }</span>
<span class="line-removed">285       f-&gt;revents = 0;</span>
<span class="line-removed">286       }</span>
<span class="line-removed">287 </span>
<span class="line-removed">288   if (_g_main_poll_debug)</span>
<span class="line-removed">289     g_print (&quot;\n&quot;);</span>
<span class="line-removed">290 </span>
<span class="line-removed">291   if (timeout == -1)</span>
<span class="line-removed">292     timeout = INFINITE;</span>
<span class="line-removed">293 </span>
294   /* Polling for several things? */
<a name="28" id="anc28"></a><span class="line-modified">295   if (nhandles &gt; 1 || (nhandles &gt; 0 &amp;&amp; msg_fd != NULL))</span>
296     {
297       /* First check if one or several of them are immediately
298        * available
299        */
<a name="29" id="anc29"></a><span class="line-modified">300       retval = poll_rest (msg_fd, handles, handle_to_fd, nhandles, 0);</span>
301 
302       /* If not, and we have a significant timeout, poll again with
303        * timeout then. Note that this will return indication for only
304        * one event, or only for messages.
305        */
<a name="30" id="anc30"></a><span class="line-modified">306       if (retval == 0 &amp;&amp; (timeout == INFINITE || timeout &gt; 0))</span>
<span class="line-modified">307     retval = poll_rest (msg_fd, handles, handle_to_fd, nhandles, timeout);</span>
308     }
309   else
310     {
311       /* Just polling for one thing, so no need to check first if
312        * available immediately
313        */
<a name="31" id="anc31"></a><span class="line-modified">314       retval = poll_rest (msg_fd, handles, handle_to_fd, nhandles, timeout);</span>






























































































































































































315     }
316 
317   if (retval == -1)
318     for (f = fds; f &lt; &amp;fds[nfds]; ++f)
319       f-&gt;revents = 0;
320 
<a name="32" id="anc32"></a>


321   return retval;
322 }
323 
324 #else  /* !G_OS_WIN32 */
325 
326 /* The following implementation of poll() comes from the GNU C Library.
327  * Copyright (C) 1994, 1996, 1997 Free Software Foundation, Inc.
328  */
329 
330 #include &lt;string.h&gt; /* for bzero on BSD systems */
331 
332 #ifdef HAVE_SYS_SELECT_H
333 #include &lt;sys/select.h&gt;
334 #endif /* HAVE_SYS_SELECT_H */
335 
336 gint
337 g_poll (GPollFD *fds,
<a name="33" id="anc33"></a><span class="line-modified">338     guint    nfds,</span>
<span class="line-modified">339     gint     timeout)</span>
340 {
341   struct timeval tv;
342   fd_set rset, wset, xset;
343   GPollFD *f;
344   int ready;
345   int maxfd = 0;
346 
347   FD_ZERO (&amp;rset);
348   FD_ZERO (&amp;wset);
349   FD_ZERO (&amp;xset);
350 
351   for (f = fds; f &lt; &amp;fds[nfds]; ++f)
352     if (f-&gt;fd &gt;= 0)
353       {
<a name="34" id="anc34"></a><span class="line-modified">354     if (f-&gt;events &amp; G_IO_IN)</span>
<span class="line-modified">355       FD_SET (f-&gt;fd, &amp;rset);</span>
<span class="line-modified">356     if (f-&gt;events &amp; G_IO_OUT)</span>
<span class="line-modified">357       FD_SET (f-&gt;fd, &amp;wset);</span>
<span class="line-modified">358     if (f-&gt;events &amp; G_IO_PRI)</span>
<span class="line-modified">359       FD_SET (f-&gt;fd, &amp;xset);</span>
<span class="line-modified">360     if (f-&gt;fd &gt; maxfd &amp;&amp; (f-&gt;events &amp; (G_IO_IN|G_IO_OUT|G_IO_PRI)))</span>
<span class="line-modified">361       maxfd = f-&gt;fd;</span>
362       }
363 
364   tv.tv_sec = timeout / 1000;
365   tv.tv_usec = (timeout % 1000) * 1000;
366 
367   ready = select (maxfd + 1, &amp;rset, &amp;wset, &amp;xset,
<a name="35" id="anc35"></a><span class="line-modified">368           timeout == -1 ? NULL : &amp;tv);</span>
369   if (ready &gt; 0)
370     for (f = fds; f &lt; &amp;fds[nfds]; ++f)
371       {
<a name="36" id="anc36"></a><span class="line-modified">372     f-&gt;revents = 0;</span>
<span class="line-modified">373     if (f-&gt;fd &gt;= 0)</span>
<span class="line-modified">374       {</span>
<span class="line-modified">375         if (FD_ISSET (f-&gt;fd, &amp;rset))</span>
<span class="line-modified">376           f-&gt;revents |= G_IO_IN;</span>
<span class="line-modified">377         if (FD_ISSET (f-&gt;fd, &amp;wset))</span>
<span class="line-modified">378           f-&gt;revents |= G_IO_OUT;</span>
<span class="line-modified">379         if (FD_ISSET (f-&gt;fd, &amp;xset))</span>
<span class="line-modified">380           f-&gt;revents |= G_IO_PRI;</span>
<span class="line-modified">381       }</span>
382       }
383 
384   return ready;
385 }
386 
387 #endif /* !G_OS_WIN32 */
388 
389 #endif  /* !HAVE_POLL */
<a name="37" id="anc37"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="37" type="hidden" />
</body>
</html>