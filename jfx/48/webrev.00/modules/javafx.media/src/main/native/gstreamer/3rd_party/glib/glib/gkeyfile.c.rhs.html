<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/3rd_party/glib/glib/gkeyfile.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* gkeyfile.c - key file parser
   2  *
   3  *  Copyright 2004  Red Hat, Inc.
   4  *  Copyright 2009-2010  Collabora Ltd.
   5  *  Copyright 2009  Nokia Corporation
   6  *
   7  * Written by Ray Strode &lt;rstrode@redhat.com&gt;
   8  *            Matthias Clasen &lt;mclasen@redhat.com&gt;
   9  *
  10  * This library is free software; you can redistribute it and/or
  11  * modify it under the terms of the GNU Lesser General Public
  12  * License as published by the Free Software Foundation; either
  13  * version 2.1 of the License, or (at your option) any later version.
  14  *
  15  * This library is distributed in the hope that it will be useful,
  16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  18  * Lesser General Public License for more details.
  19  *
  20  * You should have received a copy of the GNU Lesser General Public License
  21  * along with this library; if not, see &lt;http://www.gnu.org/licenses/&gt;.
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 
  26 #include &quot;gkeyfile.h&quot;
  27 #include &quot;gutils.h&quot;
  28 
  29 #include &lt;errno.h&gt;
  30 #include &lt;fcntl.h&gt;
  31 #include &lt;locale.h&gt;
  32 #include &lt;string.h&gt;
  33 #include &lt;stdio.h&gt;
  34 #include &lt;stdlib.h&gt;
  35 #include &lt;sys/types.h&gt;
  36 #include &lt;sys/stat.h&gt;
  37 #ifdef G_OS_UNIX
  38 #include &lt;unistd.h&gt;
  39 #endif
  40 #ifdef G_OS_WIN32
  41 #include &lt;io.h&gt;
  42 
  43 #undef fstat
  44 #define fstat(a,b) _fstati64(a,b)
  45 #undef stat
  46 #define stat _stati64
  47 
  48 #ifndef S_ISREG
  49 #define S_ISREG(mode) ((mode)&amp;_S_IFREG)
  50 #endif
  51 
  52 #endif  /* G_OS_WIN23 */
  53 
  54 #include &quot;gconvert.h&quot;
  55 #include &quot;gdataset.h&quot;
  56 #include &quot;gerror.h&quot;
  57 #include &quot;gfileutils.h&quot;
  58 #include &quot;ghash.h&quot;
  59 #include &quot;glibintl.h&quot;
  60 #include &quot;glist.h&quot;
  61 #include &quot;gslist.h&quot;
  62 #include &quot;gmem.h&quot;
  63 #include &quot;gmessages.h&quot;
  64 #include &quot;gstdio.h&quot;
  65 #include &quot;gstring.h&quot;
  66 #include &quot;gstrfuncs.h&quot;
  67 #include &quot;gutils.h&quot;
  68 
  69 
  70 /**
  71  * SECTION:keyfile
  72  * @title: Key-value file parser
  73  * @short_description: parses .ini-like config files
  74  *
  75  * #GKeyFile lets you parse, edit or create files containing groups of
  76  * key-value pairs, which we call &quot;key files&quot; for lack of a better name.
  77  * Several freedesktop.org specifications use key files now, e.g the
  78  * [Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec)
  79  * and the
  80  * [Icon Theme Specification](http://freedesktop.org/Standards/icon-theme-spec).
  81  *
  82  * The syntax of key files is described in detail in the
  83  * [Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec),
  84  * here is a quick summary: Key files
  85  * consists of groups of key-value pairs, interspersed with comments.
  86  *
  87  * |[
  88  * # this is just an example
  89  * # there can be comments before the first group
  90  *
  91  * [First Group]
  92  *
  93  * Name=Key File Example\tthis value shows\nescaping
  94  *
  95  * # localized strings are stored in multiple key-value pairs
  96  * Welcome=Hello
  97  * Welcome[de]=Hallo
  98  * Welcome[fr_FR]=Bonjour
  99  * Welcome[it]=Ciao
 100  * Welcome[be@latin]=Hello
 101  *
 102  * [Another Group]
 103  *
 104  * Numbers=2;20;-200;0
 105  *
 106  * Booleans=true;false;true;true
 107  * ]|
 108  *
 109  * Lines beginning with a &#39;#&#39; and blank lines are considered comments.
 110  *
 111  * Groups are started by a header line containing the group name enclosed
 112  * in &#39;[&#39; and &#39;]&#39;, and ended implicitly by the start of the next group or
 113  * the end of the file. Each key-value pair must be contained in a group.
 114  *
 115  * Key-value pairs generally have the form `key=value`, with the
 116  * exception of localized strings, which have the form
 117  * `key[locale]=value`, with a locale identifier of the
 118  * form `lang_COUNTRY@MODIFIER` where `COUNTRY` and `MODIFIER`
 119  * are optional.
 120  * Space before and after the &#39;=&#39; character are ignored. Newline, tab,
 121  * carriage return and backslash characters in value are escaped as \n,
 122  * \t, \r, and \\\\, respectively. To preserve leading spaces in values,
 123  * these can also be escaped as \s.
 124  *
 125  * Key files can store strings (possibly with localized variants), integers,
 126  * booleans and lists of these. Lists are separated by a separator character,
 127  * typically &#39;;&#39; or &#39;,&#39;. To use the list separator character in a value in
 128  * a list, it has to be escaped by prefixing it with a backslash.
 129  *
 130  * This syntax is obviously inspired by the .ini files commonly met
 131  * on Windows, but there are some important differences:
 132  *
 133  * - .ini files use the &#39;;&#39; character to begin comments,
 134  *   key files use the &#39;#&#39; character.
 135  *
 136  * - Key files do not allow for ungrouped keys meaning only
 137  *   comments can precede the first group.
 138  *
 139  * - Key files are always encoded in UTF-8.
 140  *
 141  * - Key and Group names are case-sensitive. For example, a group called
 142  *   [GROUP] is a different from [group].
 143  *
 144  * - .ini files don&#39;t have a strongly typed boolean entry type,
 145  *    they only have GetProfileInt(). In key files, only
 146  *    true and false (in lower case) are allowed.
 147  *
 148  * Note that in contrast to the
 149  * [Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec),
 150  * groups in key files may contain the same
 151  * key multiple times; the last entry wins. Key files may also contain
 152  * multiple groups with the same name; they are merged together.
 153  * Another difference is that keys and group names in key files are not
 154  * restricted to ASCII characters.
 155  *
 156  * Here is an example of loading a key file and reading a value:
 157  * |[&lt;!-- language=&quot;C&quot; --&gt;
 158  * g_autoptr(GError) error = NULL;
 159  * g_autoptr(GKeyFile) key_file = g_key_file_new ();
 160  *
 161  * if (!g_key_file_load_from_file (key_file, &quot;key-file.ini&quot;, flags, &amp;error))
 162  *   {
 163  *     if (!g_error_matches (error, G_FILE_ERROR, G_FILE_ERROR_NOENT))
 164  *       g_warning (&quot;Error loading key file: %s&quot;, error-&gt;message);
 165  *     return;
 166  *   }
 167  *
 168  * g_autofree gchar *val = g_key_file_get_string (key_file, &quot;Group Name&quot;, &quot;SomeKey&quot;, &amp;error);
 169  * if (val == NULL &amp;&amp;
 170  *     !g_error_matches (error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_KEY_NOT_FOUND))
 171  *   {
 172  *     g_warning (&quot;Error finding key in key file: %s&quot;, error-&gt;message);
 173  *     return;
 174  *   }
 175  * else if (val == NULL)
 176  *   {
 177  *     // Fall back to a default value.
 178  *     val = g_strdup (&quot;default-value&quot;);
 179  *   }
 180  * ]|
 181  *
 182  * Here is an example of creating and saving a key file:
 183  * |[&lt;!-- language=&quot;C&quot; --&gt;
 184  * g_autoptr(GKeyFile) key_file = g_key_file_new ();
 185  * const gchar *val = ...;
 186  * g_autoptr(GError) error = NULL;
 187  *
 188  * g_key_file_set_string (key_file, &quot;Group Name&quot;, &quot;SomeKey&quot;, val);
 189  *
 190  * // Save as a file.
 191  * if (!g_key_file_save_to_file (key_file, &quot;key-file.ini&quot;, &amp;error))
 192  *   {
 193  *     g_warning (&quot;Error saving key file: %s&quot;, error-&gt;message);
 194  *     return;
 195  *   }
 196  *
 197  * // Or store to a GBytes for use elsewhere.
 198  * gsize data_len;
 199  * g_autofree guint8 *data = (guint8 *) g_key_file_to_data (key_file, &amp;data_len, &amp;error);
 200  * if (data == NULL)
 201  *   {
 202  *     g_warning (&quot;Error saving key file: %s&quot;, error-&gt;message);
 203  *     return;
 204  *   }
 205  * g_autoptr(GBytes) bytes = g_bytes_new_take (g_steal_pointer (&amp;data), data_len);
 206  * ]|
 207  */
 208 
 209 /**
 210  * G_KEY_FILE_ERROR:
 211  *
 212  * Error domain for key file parsing. Errors in this domain will
 213  * be from the #GKeyFileError enumeration.
 214  *
 215  * See #GError for information on error domains.
 216  */
 217 
 218 /**
 219  * GKeyFileError:
 220  * @G_KEY_FILE_ERROR_UNKNOWN_ENCODING: the text being parsed was in
 221  *     an unknown encoding
 222  * @G_KEY_FILE_ERROR_PARSE: document was ill-formed
 223  * @G_KEY_FILE_ERROR_NOT_FOUND: the file was not found
 224  * @G_KEY_FILE_ERROR_KEY_NOT_FOUND: a requested key was not found
 225  * @G_KEY_FILE_ERROR_GROUP_NOT_FOUND: a requested group was not found
 226  * @G_KEY_FILE_ERROR_INVALID_VALUE: a value could not be parsed
 227  *
 228  * Error codes returned by key file parsing.
 229  */
 230 
 231 /**
 232  * GKeyFileFlags:
 233  * @G_KEY_FILE_NONE: No flags, default behaviour
 234  * @G_KEY_FILE_KEEP_COMMENTS: Use this flag if you plan to write the
 235  *     (possibly modified) contents of the key file back to a file;
 236  *     otherwise all comments will be lost when the key file is
 237  *     written back.
 238  * @G_KEY_FILE_KEEP_TRANSLATIONS: Use this flag if you plan to write the
 239  *     (possibly modified) contents of the key file back to a file;
 240  *     otherwise only the translations for the current language will be
 241  *     written back.
 242  *
 243  * Flags which influence the parsing.
 244  */
 245 
 246 /**
 247  * G_KEY_FILE_DESKTOP_GROUP:
 248  *
 249  * The name of the main group of a desktop entry file, as defined in the
 250  * [Desktop Entry Specification](http://freedesktop.org/Standards/desktop-entry-spec).
 251  * Consult the specification for more
 252  * details about the meanings of the keys below.
 253  *
 254  * Since: 2.14
 255  */
 256 
 257 /**
 258  * G_KEY_FILE_DESKTOP_KEY_TYPE:
 259  *
 260  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
 261  * giving the type of the desktop entry. Usually
 262  * #G_KEY_FILE_DESKTOP_TYPE_APPLICATION,
 263  * #G_KEY_FILE_DESKTOP_TYPE_LINK, or
 264  * #G_KEY_FILE_DESKTOP_TYPE_DIRECTORY.
 265  *
 266  * Since: 2.14
 267  */
 268 
 269 /**
 270  * G_KEY_FILE_DESKTOP_KEY_VERSION:
 271  *
 272  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
 273  * giving the version of the Desktop Entry Specification used for
 274  * the desktop entry file.
 275  *
 276  * Since: 2.14
 277  */
 278 
 279 /**
 280  * G_KEY_FILE_DESKTOP_KEY_NAME:
 281  *
 282  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
 283  * string giving the specific name of the desktop entry.
 284  *
 285  * Since: 2.14
 286  */
 287 
 288 /**
 289  * G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME:
 290  *
 291  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
 292  * string giving the generic name of the desktop entry.
 293  *
 294  * Since: 2.14
 295  */
 296 
 297 /**
 298  * G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY:
 299  *
 300  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
 301  * stating whether the desktop entry should be shown in menus.
 302  *
 303  * Since: 2.14
 304  */
 305 
 306 /**
 307  * G_KEY_FILE_DESKTOP_KEY_COMMENT:
 308  *
 309  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
 310  * string giving the tooltip for the desktop entry.
 311  *
 312  * Since: 2.14
 313  */
 314 
 315 /**
 316  * G_KEY_FILE_DESKTOP_KEY_ICON:
 317  *
 318  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a localized
 319  * string giving the name of the icon to be displayed for the desktop
 320  * entry.
 321  *
 322  * Since: 2.14
 323  */
 324 
 325 /**
 326  * G_KEY_FILE_DESKTOP_KEY_HIDDEN:
 327  *
 328  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
 329  * stating whether the desktop entry has been deleted by the user.
 330  *
 331  * Since: 2.14
 332  */
 333 
 334 /**
 335  * G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN:
 336  *
 337  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list of
 338  * strings identifying the environments that should display the
 339  * desktop entry.
 340  *
 341  * Since: 2.14
 342  */
 343 
 344 /**
 345  * G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN:
 346  *
 347  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list of
 348  * strings identifying the environments that should not display the
 349  * desktop entry.
 350  *
 351  * Since: 2.14
 352  */
 353 
 354 /**
 355  * G_KEY_FILE_DESKTOP_KEY_TRY_EXEC:
 356  *
 357  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
 358  * giving the file name of a binary on disk used to determine if the
 359  * program is actually installed. It is only valid for desktop entries
 360  * with the `Application` type.
 361  *
 362  * Since: 2.14
 363  */
 364 
 365 /**
 366  * G_KEY_FILE_DESKTOP_KEY_EXEC:
 367  *
 368  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
 369  * giving the command line to execute. It is only valid for desktop
 370  * entries with the `Application` type.
 371  *
 372  * Since: 2.14
 373  */
 374 
 375  /**
 376   * G_KEY_FILE_DESKTOP_KEY_PATH:
 377   *
 378   * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
 379   * containing the working directory to run the program in. It is only
 380   * valid for desktop entries with the `Application` type.
 381   *
 382   * Since: 2.14
 383   */
 384 
 385 /**
 386  * G_KEY_FILE_DESKTOP_KEY_TERMINAL:
 387  *
 388  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
 389  * stating whether the program should be run in a terminal window.
 390  * It is only valid for desktop entries with the
 391  * `Application` type.
 392  *
 393  * Since: 2.14
 394  */
 395 
 396 /**
 397  * G_KEY_FILE_DESKTOP_KEY_MIME_TYPE:
 398  *
 399  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list
 400  * of strings giving the MIME types supported by this desktop entry.
 401  *
 402  * Since: 2.14
 403  */
 404 
 405 /**
 406  * G_KEY_FILE_DESKTOP_KEY_CATEGORIES:
 407  *
 408  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a list
 409  * of strings giving the categories in which the desktop entry
 410  * should be shown in a menu.
 411  *
 412  * Since: 2.14
 413  */
 414 
 415 /**
 416  * G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY:
 417  *
 418  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean
 419  * stating whether the application supports the
 420  * [Startup Notification Protocol Specification](http://www.freedesktop.org/Standards/startup-notification-spec).
 421  *
 422  * Since: 2.14
 423  */
 424 
 425 /**
 426  * G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS:
 427  *
 428  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is string
 429  * identifying the WM class or name hint of a window that the application
 430  * will create, which can be used to emulate Startup Notification with
 431  * older applications.
 432  *
 433  * Since: 2.14
 434  */
 435 
 436 /**
 437  * G_KEY_FILE_DESKTOP_KEY_URL:
 438  *
 439  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string
 440  * giving the URL to access. It is only valid for desktop entries
 441  * with the `Link` type.
 442  *
 443  * Since: 2.14
 444  */
 445 
 446 /**
 447  * G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE:
 448  *
 449  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a boolean set to true
 450  * if the application is D-Bus activatable.
 451  *
 452  * Since: 2.38
 453  */
 454 
 455 /**
 456  * G_KEY_FILE_DESKTOP_KEY_ACTIONS:
 457  *
 458  * A key under #G_KEY_FILE_DESKTOP_GROUP, whose value is a string list
 459  * giving the available application actions.
 460  *
 461  * Since: 2.38
 462  */
 463 
 464 /**
 465  * G_KEY_FILE_DESKTOP_TYPE_APPLICATION:
 466  *
 467  * The value of the #G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop
 468  * entries representing applications.
 469  *
 470  * Since: 2.14
 471  */
 472 
 473 /**
 474  * G_KEY_FILE_DESKTOP_TYPE_LINK:
 475  *
 476  * The value of the #G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop
 477  * entries representing links to documents.
 478  *
 479  * Since: 2.14
 480  */
 481 
 482 /**
 483  * G_KEY_FILE_DESKTOP_TYPE_DIRECTORY:
 484  *
 485  * The value of the #G_KEY_FILE_DESKTOP_KEY_TYPE, key for desktop
 486  * entries representing directories.
 487  *
 488  * Since: 2.14
 489  */
 490 
 491 typedef struct _GKeyFileGroup GKeyFileGroup;
 492 
 493 /**
 494  * GKeyFile:
 495  *
 496  * The GKeyFile struct contains only private data
 497  * and should not be accessed directly.
 498  */
 499 struct _GKeyFile
 500 {
 501   GList *groups;
 502   GHashTable *group_hash;
 503 
 504   GKeyFileGroup *start_group;
 505   GKeyFileGroup *current_group;
 506 
 507   GString *parse_buffer; /* Holds up to one line of not-yet-parsed data */
 508 
 509   gchar list_separator;
 510 
 511   GKeyFileFlags flags;
 512 
 513   gchar **locales;
 514 
 515   volatile gint ref_count;
 516 };
 517 
 518 typedef struct _GKeyFileKeyValuePair GKeyFileKeyValuePair;
 519 
 520 struct _GKeyFileGroup
 521 {
 522   const gchar *name;  /* NULL for above first group (which will be comments) */
 523 
 524   GKeyFileKeyValuePair *comment; /* Special comment that is stuck to the top of a group */
 525 
 526   GList *key_value_pairs;
 527 
 528   /* Used in parallel with key_value_pairs for
 529    * increased lookup performance
 530    */
 531   GHashTable *lookup_map;
 532 };
 533 
 534 struct _GKeyFileKeyValuePair
 535 {
 536   gchar *key;  /* NULL for comments */
 537   gchar *value;
 538 };
 539 
 540 static gint                  find_file_in_data_dirs            (const gchar            *file,
<a name="1" id="anc1"></a><span class="line-modified"> 541                 const gchar           **data_dirs,</span>
<span class="line-modified"> 542                 gchar                 **output_file,</span>
<span class="line-modified"> 543                 GError                **error);</span>
 544 static gboolean              g_key_file_load_from_fd           (GKeyFile               *key_file,
<a name="2" id="anc2"></a><span class="line-modified"> 545                 gint                    fd,</span>
<span class="line-modified"> 546                 GKeyFileFlags           flags,</span>
<span class="line-modified"> 547                 GError                **error);</span>
 548 static GList                *g_key_file_lookup_group_node      (GKeyFile               *key_file,
<a name="3" id="anc3"></a><span class="line-modified"> 549                                               const gchar            *group_name);</span>
 550 static GKeyFileGroup        *g_key_file_lookup_group           (GKeyFile               *key_file,
<a name="4" id="anc4"></a><span class="line-modified"> 551                 const gchar            *group_name);</span>
 552 
 553 static GList                *g_key_file_lookup_key_value_pair_node  (GKeyFile       *key_file,
<a name="5" id="anc5"></a><span class="line-modified"> 554                                                    GKeyFileGroup  *group,</span>
 555                                                                      const gchar    *key);
 556 static GKeyFileKeyValuePair *g_key_file_lookup_key_value_pair       (GKeyFile       *key_file,
 557                                                                      GKeyFileGroup  *group,
 558                                                                      const gchar    *key);
 559 
 560 static void                  g_key_file_remove_group_node          (GKeyFile      *key_file,
<a name="6" id="anc6"></a><span class="line-modified"> 561                       GList         *group_node);</span>
 562 static void                  g_key_file_remove_key_value_pair_node (GKeyFile      *key_file,
 563                                                                     GKeyFileGroup *group,
 564                                                                     GList         *pair_node);
 565 
 566 static void                  g_key_file_add_key_value_pair     (GKeyFile               *key_file,
 567                                                                 GKeyFileGroup          *group,
 568                                                                 GKeyFileKeyValuePair   *pair);
 569 static void                  g_key_file_add_key                (GKeyFile               *key_file,
<a name="7" id="anc7"></a><span class="line-modified"> 570                 GKeyFileGroup          *group,</span>
<span class="line-modified"> 571                 const gchar            *key,</span>
<span class="line-modified"> 572                 const gchar            *value);</span>
 573 static void                  g_key_file_add_group              (GKeyFile               *key_file,
<a name="8" id="anc8"></a><span class="line-modified"> 574                 const gchar            *group_name);</span>
 575 static gboolean              g_key_file_is_group_name          (const gchar *name);
 576 static gboolean              g_key_file_is_key_name            (const gchar *name);
 577 static void                  g_key_file_key_value_pair_free    (GKeyFileKeyValuePair   *pair);
 578 static gboolean              g_key_file_line_is_comment        (const gchar            *line);
 579 static gboolean              g_key_file_line_is_group          (const gchar            *line);
 580 static gboolean              g_key_file_line_is_key_value_pair (const gchar            *line);
 581 static gchar                *g_key_file_parse_value_as_string  (GKeyFile               *key_file,
<a name="9" id="anc9"></a><span class="line-modified"> 582                 const gchar            *value,</span>
<span class="line-modified"> 583                 GSList                **separators,</span>
<span class="line-modified"> 584                 GError                **error);</span>
 585 static gchar                *g_key_file_parse_string_as_value  (GKeyFile               *key_file,
<a name="10" id="anc10"></a><span class="line-modified"> 586                 const gchar            *string,</span>
<span class="line-modified"> 587                 gboolean                escape_separator);</span>
 588 static gint                  g_key_file_parse_value_as_integer (GKeyFile               *key_file,
<a name="11" id="anc11"></a><span class="line-modified"> 589                 const gchar            *value,</span>
<span class="line-modified"> 590                 GError                **error);</span>
 591 static gchar                *g_key_file_parse_integer_as_value (GKeyFile               *key_file,
<a name="12" id="anc12"></a><span class="line-modified"> 592                 gint                    value);</span>
 593 static gdouble               g_key_file_parse_value_as_double  (GKeyFile               *key_file,
 594                                                                 const gchar            *value,
 595                                                                 GError                **error);
 596 static gboolean              g_key_file_parse_value_as_boolean (GKeyFile               *key_file,
<a name="13" id="anc13"></a><span class="line-modified"> 597                 const gchar            *value,</span>
<span class="line-modified"> 598                 GError                **error);</span>
 599 static gchar                *g_key_file_parse_boolean_as_value (GKeyFile               *key_file,
<a name="14" id="anc14"></a><span class="line-modified"> 600                 gboolean                value);</span>
 601 static gchar                *g_key_file_parse_value_as_comment (GKeyFile               *key_file,
<a name="15" id="anc15"></a><span class="line-modified"> 602                                                                 const gchar            *value,</span>
<span class="line-added"> 603                                                                 gboolean                is_final_line);</span>
 604 static gchar                *g_key_file_parse_comment_as_value (GKeyFile               *key_file,
 605                                                                 const gchar            *comment);
 606 static void                  g_key_file_parse_key_value_pair   (GKeyFile               *key_file,
<a name="16" id="anc16"></a><span class="line-modified"> 607                 const gchar            *line,</span>
<span class="line-modified"> 608                 gsize                   length,</span>
<span class="line-modified"> 609                 GError                **error);</span>
 610 static void                  g_key_file_parse_comment          (GKeyFile               *key_file,
<a name="17" id="anc17"></a><span class="line-modified"> 611                 const gchar            *line,</span>
<span class="line-modified"> 612                 gsize                   length,</span>
<span class="line-modified"> 613                 GError                **error);</span>
 614 static void                  g_key_file_parse_group            (GKeyFile               *key_file,
<a name="18" id="anc18"></a><span class="line-modified"> 615                 const gchar            *line,</span>
<span class="line-modified"> 616                 gsize                   length,</span>
<span class="line-modified"> 617                 GError                **error);</span>
 618 static gchar                *key_get_locale                    (const gchar            *key);
 619 static void                  g_key_file_parse_data             (GKeyFile               *key_file,
<a name="19" id="anc19"></a><span class="line-modified"> 620                 const gchar            *data,</span>
<span class="line-modified"> 621                 gsize                   length,</span>
<span class="line-modified"> 622                 GError                **error);</span>
 623 static void                  g_key_file_flush_parse_buffer     (GKeyFile               *key_file,
<a name="20" id="anc20"></a><span class="line-modified"> 624                 GError                **error);</span>
 625 
 626 G_DEFINE_QUARK (g-key-file-error-quark, g_key_file_error)
 627 
 628 static void
 629 g_key_file_init (GKeyFile *key_file)
 630 {
 631   key_file-&gt;current_group = g_slice_new0 (GKeyFileGroup);
 632   key_file-&gt;groups = g_list_prepend (NULL, key_file-&gt;current_group);
 633   key_file-&gt;group_hash = g_hash_table_new (g_str_hash, g_str_equal);
 634   key_file-&gt;start_group = NULL;
 635   key_file-&gt;parse_buffer = g_string_sized_new (128);
 636   key_file-&gt;list_separator = &#39;;&#39;;
 637   key_file-&gt;flags = 0;
 638   key_file-&gt;locales = g_strdupv ((gchar **)g_get_language_names ());
 639 }
 640 
 641 static void
 642 g_key_file_clear (GKeyFile *key_file)
 643 {
 644   GList *tmp, *group_node;
 645 
 646   if (key_file-&gt;locales)
 647     {
 648       g_strfreev (key_file-&gt;locales);
 649       key_file-&gt;locales = NULL;
 650     }
 651 
 652   if (key_file-&gt;parse_buffer)
 653     {
 654       g_string_free (key_file-&gt;parse_buffer, TRUE);
 655       key_file-&gt;parse_buffer = NULL;
 656     }
 657 
 658   tmp = key_file-&gt;groups;
 659   while (tmp != NULL)
 660     {
 661       group_node = tmp;
 662       tmp = tmp-&gt;next;
 663       g_key_file_remove_group_node (key_file, group_node);
 664     }
 665 
 666   if (key_file-&gt;group_hash != NULL)
 667     {
 668       g_hash_table_destroy (key_file-&gt;group_hash);
 669       key_file-&gt;group_hash = NULL;
 670     }
 671 
 672   g_warn_if_fail (key_file-&gt;groups == NULL);
 673 }
 674 
 675 
 676 /**
 677  * g_key_file_new:
 678  *
 679  * Creates a new empty #GKeyFile object. Use
 680  * g_key_file_load_from_file(), g_key_file_load_from_data(),
 681  * g_key_file_load_from_dirs() or g_key_file_load_from_data_dirs() to
 682  * read an existing key file.
 683  *
 684  * Returns: (transfer full): an empty #GKeyFile.
 685  *
 686  * Since: 2.6
 687  **/
 688 GKeyFile *
 689 g_key_file_new (void)
 690 {
 691   GKeyFile *key_file;
 692 
 693   key_file = g_slice_new0 (GKeyFile);
 694   key_file-&gt;ref_count = 1;
 695   g_key_file_init (key_file);
 696 
 697   return key_file;
 698 }
 699 
 700 /**
 701  * g_key_file_set_list_separator:
 702  * @key_file: a #GKeyFile
 703  * @separator: the separator
 704  *
 705  * Sets the character which is used to separate
 706  * values in lists. Typically &#39;;&#39; or &#39;,&#39; are used
 707  * as separators. The default list separator is &#39;;&#39;.
 708  *
 709  * Since: 2.6
 710  */
 711 void
 712 g_key_file_set_list_separator (GKeyFile *key_file,
<a name="21" id="anc21"></a><span class="line-modified"> 713              gchar     separator)</span>
 714 {
 715   g_return_if_fail (key_file != NULL);
 716 
 717   key_file-&gt;list_separator = separator;
 718 }
 719 
 720 
 721 /* Iterates through all the directories in *dirs trying to
 722  * open file.  When it successfully locates and opens a file it
 723  * returns the file descriptor to the open file.  It also
 724  * outputs the absolute path of the file in output_file.
 725  */
 726 static gint
 727 find_file_in_data_dirs (const gchar   *file,
 728                         const gchar  **dirs,
 729                         gchar        **output_file,
 730                         GError       **error)
 731 {
 732   const gchar **data_dirs, *data_dir;
 733   gchar *path;
 734   gint fd;
 735 
 736   path = NULL;
 737   fd = -1;
 738 
 739   if (dirs == NULL)
 740     return fd;
 741 
 742   data_dirs = dirs;
 743 
 744   while (data_dirs &amp;&amp; (data_dir = *data_dirs) &amp;&amp; fd == -1)
 745     {
 746       gchar *candidate_file, *sub_dir;
 747 
 748       candidate_file = (gchar *) file;
 749       sub_dir = g_strdup (&quot;&quot;);
 750       while (candidate_file != NULL &amp;&amp; fd == -1)
 751         {
 752           gchar *p;
 753 
 754           path = g_build_filename (data_dir, sub_dir,
 755                                    candidate_file, NULL);
 756 
 757           fd = g_open (path, O_RDONLY, 0);
 758 
 759           if (fd == -1)
 760             {
 761               g_free (path);
 762               path = NULL;
 763             }
 764 
 765           candidate_file = strchr (candidate_file, &#39;-&#39;);
 766 
 767           if (candidate_file == NULL)
 768             break;
 769 
 770           candidate_file++;
 771 
 772           g_free (sub_dir);
 773           sub_dir = g_strndup (file, candidate_file - file - 1);
 774 
 775           for (p = sub_dir; *p != &#39;\0&#39;; p++)
 776             {
 777               if (*p == &#39;-&#39;)
 778                 *p = G_DIR_SEPARATOR;
 779             }
 780         }
 781       g_free (sub_dir);
 782       data_dirs++;
 783     }
 784 
 785   if (fd == -1)
 786     {
 787       g_set_error_literal (error, G_KEY_FILE_ERROR,
 788                            G_KEY_FILE_ERROR_NOT_FOUND,
 789                            _(&quot;Valid key file could not be &quot;
 790                              &quot;found in search dirs&quot;));
 791     }
 792 
 793   if (output_file != NULL &amp;&amp; fd != -1)
 794     *output_file = g_strdup (path);
 795 
 796   g_free (path);
 797 
 798   return fd;
 799 }
 800 
 801 static gboolean
 802 g_key_file_load_from_fd (GKeyFile       *key_file,
<a name="22" id="anc22"></a><span class="line-modified"> 803        gint            fd,</span>
<span class="line-modified"> 804        GKeyFileFlags   flags,</span>
<span class="line-modified"> 805        GError        **error)</span>
 806 {
 807   GError *key_file_error = NULL;
 808   gssize bytes_read;
 809   struct stat stat_buf;
 810   gchar read_buf[4096];
 811   gchar list_separator;
 812 
 813   if (fstat (fd, &amp;stat_buf) &lt; 0)
 814     {
 815       int errsv = errno;
 816       g_set_error_literal (error, G_FILE_ERROR,
 817                            g_file_error_from_errno (errsv),
 818                            g_strerror (errsv));
 819       return FALSE;
 820     }
 821 
 822   if (!S_ISREG (stat_buf.st_mode))
 823     {
 824       g_set_error_literal (error, G_KEY_FILE_ERROR,
 825                            G_KEY_FILE_ERROR_PARSE,
 826                            _(&quot;Not a regular file&quot;));
 827       return FALSE;
 828     }
 829 
 830   list_separator = key_file-&gt;list_separator;
 831   g_key_file_clear (key_file);
 832   g_key_file_init (key_file);
 833   key_file-&gt;list_separator = list_separator;
 834   key_file-&gt;flags = flags;
 835 
 836   do
 837     {
 838       int errsv;
 839 
 840       bytes_read = read (fd, read_buf, 4096);
 841       errsv = errno;
 842 
 843       if (bytes_read == 0)  /* End of File */
 844         break;
 845 
 846       if (bytes_read &lt; 0)
 847         {
 848           if (errsv == EINTR || errsv == EAGAIN)
 849             continue;
 850 
 851           g_set_error_literal (error, G_FILE_ERROR,
 852                                g_file_error_from_errno (errsv),
 853                                g_strerror (errsv));
 854           return FALSE;
 855         }
 856 
 857       g_key_file_parse_data (key_file,
<a name="23" id="anc23"></a><span class="line-modified"> 858            read_buf, bytes_read,</span>
<span class="line-modified"> 859            &amp;key_file_error);</span>
 860     }
 861   while (!key_file_error);
 862 
 863   if (key_file_error)
 864     {
 865       g_propagate_error (error, key_file_error);
 866       return FALSE;
 867     }
 868 
 869   g_key_file_flush_parse_buffer (key_file, &amp;key_file_error);
 870 
 871   if (key_file_error)
 872     {
 873       g_propagate_error (error, key_file_error);
 874       return FALSE;
 875     }
 876 
 877   return TRUE;
 878 }
 879 
 880 /**
 881  * g_key_file_load_from_file:
 882  * @key_file: an empty #GKeyFile struct
 883  * @file: (type filename): the path of a filename to load, in the GLib filename encoding
 884  * @flags: flags from #GKeyFileFlags
 885  * @error: return location for a #GError, or %NULL
 886  *
 887  * Loads a key file into an empty #GKeyFile structure.
 888  *
 889  * If the OS returns an error when opening or reading the file, a
 890  * %G_FILE_ERROR is returned. If there is a problem parsing the file, a
 891  * %G_KEY_FILE_ERROR is returned.
 892  *
 893  * This function will never return a %G_KEY_FILE_ERROR_NOT_FOUND error. If the
 894  * @file is not found, %G_FILE_ERROR_NOENT is returned.
 895  *
 896  * Returns: %TRUE if a key file could be loaded, %FALSE otherwise
 897  *
 898  * Since: 2.6
 899  **/
 900 gboolean
 901 g_key_file_load_from_file (GKeyFile       *key_file,
<a name="24" id="anc24"></a><span class="line-modified"> 902          const gchar    *file,</span>
<span class="line-modified"> 903          GKeyFileFlags   flags,</span>
<span class="line-modified"> 904          GError        **error)</span>
 905 {
 906   GError *key_file_error = NULL;
 907   gint fd;
 908   int errsv;
 909 
 910   g_return_val_if_fail (key_file != NULL, FALSE);
 911   g_return_val_if_fail (file != NULL, FALSE);
 912 
 913   fd = g_open (file, O_RDONLY, 0);
 914   errsv = errno;
 915 
 916   if (fd == -1)
 917     {
 918       g_set_error_literal (error, G_FILE_ERROR,
 919                            g_file_error_from_errno (errsv),
 920                            g_strerror (errsv));
 921       return FALSE;
 922     }
 923 
 924   g_key_file_load_from_fd (key_file, fd, flags, &amp;key_file_error);
 925   close (fd);
 926 
 927   if (key_file_error)
 928     {
 929       g_propagate_error (error, key_file_error);
 930       return FALSE;
 931     }
 932 
 933   return TRUE;
 934 }
 935 
 936 /**
 937  * g_key_file_load_from_data:
 938  * @key_file: an empty #GKeyFile struct
 939  * @data: key file loaded in memory
 940  * @length: the length of @data in bytes (or (gsize)-1 if data is nul-terminated)
 941  * @flags: flags from #GKeyFileFlags
 942  * @error: return location for a #GError, or %NULL
 943  *
 944  * Loads a key file from memory into an empty #GKeyFile structure.
 945  * If the object cannot be created then %error is set to a #GKeyFileError.
 946  *
 947  * Returns: %TRUE if a key file could be loaded, %FALSE otherwise
 948  *
 949  * Since: 2.6
 950  **/
 951 gboolean
 952 g_key_file_load_from_data (GKeyFile       *key_file,
<a name="25" id="anc25"></a><span class="line-modified"> 953          const gchar    *data,</span>
<span class="line-modified"> 954          gsize           length,</span>
<span class="line-modified"> 955          GKeyFileFlags   flags,</span>
<span class="line-modified"> 956          GError        **error)</span>
 957 {
 958   GError *key_file_error = NULL;
 959   gchar list_separator;
 960 
 961   g_return_val_if_fail (key_file != NULL, FALSE);
 962   g_return_val_if_fail (data != NULL || length == 0, FALSE);
 963 
 964   if (length == (gsize)-1)
 965     length = strlen (data);
 966 
 967   list_separator = key_file-&gt;list_separator;
 968   g_key_file_clear (key_file);
 969   g_key_file_init (key_file);
 970   key_file-&gt;list_separator = list_separator;
 971   key_file-&gt;flags = flags;
 972 
 973   g_key_file_parse_data (key_file, data, length, &amp;key_file_error);
 974 
 975   if (key_file_error)
 976     {
 977       g_propagate_error (error, key_file_error);
 978       return FALSE;
 979     }
 980 
 981   g_key_file_flush_parse_buffer (key_file, &amp;key_file_error);
 982 
 983   if (key_file_error)
 984     {
 985       g_propagate_error (error, key_file_error);
 986       return FALSE;
 987     }
 988 
 989   return TRUE;
 990 }
 991 
 992 /**
 993  * g_key_file_load_from_bytes:
 994  * @key_file: an empty #GKeyFile struct
 995  * @bytes: a #GBytes
 996  * @flags: flags from #GKeyFileFlags
 997  * @error: return location for a #GError, or %NULL
 998  *
 999  * Loads a key file from the data in @bytes into an empty #GKeyFile structure.
1000  * If the object cannot be created then %error is set to a #GKeyFileError.
1001  *
1002  * Returns: %TRUE if a key file could be loaded, %FALSE otherwise
1003  *
1004  * Since: 2.50
1005  **/
1006 gboolean
1007 g_key_file_load_from_bytes (GKeyFile       *key_file,
1008                             GBytes         *bytes,
1009                             GKeyFileFlags   flags,
1010                             GError        **error)
1011 {
1012   const guchar *data;
1013   gsize size;
1014 
1015   g_return_val_if_fail (key_file != NULL, FALSE);
1016   g_return_val_if_fail (bytes != NULL, FALSE);
1017 
1018   data = g_bytes_get_data (bytes, &amp;size);
1019   return g_key_file_load_from_data (key_file, (const gchar *) data, size, flags, error);
1020 }
1021 
1022 /**
1023  * g_key_file_load_from_dirs:
1024  * @key_file: an empty #GKeyFile struct
1025  * @file: (type filename): a relative path to a filename to open and parse
1026  * @search_dirs: (array zero-terminated=1) (element-type filename): %NULL-terminated array of directories to search
1027  * @full_path: (out) (type filename) (optional): return location for a string containing the full path
1028  *   of the file, or %NULL
1029  * @flags: flags from #GKeyFileFlags
1030  * @error: return location for a #GError, or %NULL
1031  *
1032  * This function looks for a key file named @file in the paths
1033  * specified in @search_dirs, loads the file into @key_file and
1034  * returns the file&#39;s full path in @full_path.
1035  *
1036  * If the file could not be found in any of the @search_dirs,
1037  * %G_KEY_FILE_ERROR_NOT_FOUND is returned. If
1038  * the file is found but the OS returns an error when opening or reading the
1039  * file, a %G_FILE_ERROR is returned. If there is a problem parsing the file, a
1040  * %G_KEY_FILE_ERROR is returned.
1041  *
1042  * Returns: %TRUE if a key file could be loaded, %FALSE otherwise
1043  *
1044  * Since: 2.14
1045  **/
1046 gboolean
1047 g_key_file_load_from_dirs (GKeyFile       *key_file,
1048                            const gchar    *file,
1049                            const gchar   **search_dirs,
1050                            gchar         **full_path,
1051                            GKeyFileFlags   flags,
1052                            GError        **error)
1053 {
1054   GError *key_file_error = NULL;
1055   const gchar **data_dirs;
1056   gchar *output_path;
1057   gint fd;
1058   gboolean found_file;
1059 
1060   g_return_val_if_fail (key_file != NULL, FALSE);
1061   g_return_val_if_fail (!g_path_is_absolute (file), FALSE);
1062   g_return_val_if_fail (search_dirs != NULL, FALSE);
1063 
1064   found_file = FALSE;
1065   data_dirs = search_dirs;
1066   output_path = NULL;
1067   while (*data_dirs != NULL &amp;&amp; !found_file)
1068     {
1069       g_free (output_path);
1070       output_path = NULL;
1071 
1072       fd = find_file_in_data_dirs (file, data_dirs, &amp;output_path,
1073                                    &amp;key_file_error);
1074 
1075       if (fd == -1)
1076         {
1077           if (key_file_error)
1078             g_propagate_error (error, key_file_error);
<a name="26" id="anc26"></a><span class="line-modified">1079     break;</span>
1080         }
1081 
1082       found_file = g_key_file_load_from_fd (key_file, fd, flags,
<a name="27" id="anc27"></a><span class="line-modified">1083                                       &amp;key_file_error);</span>
1084       close (fd);
1085 
1086       if (key_file_error)
1087         {
<a name="28" id="anc28"></a><span class="line-modified">1088     g_propagate_error (error, key_file_error);</span>
<span class="line-modified">1089     break;</span>
1090         }
1091     }
1092 
1093   if (found_file &amp;&amp; full_path)
1094     *full_path = output_path;
1095   else
1096     g_free (output_path);
1097 
1098   return found_file;
1099 }
1100 
1101 /**
1102  * g_key_file_load_from_data_dirs:
1103  * @key_file: an empty #GKeyFile struct
1104  * @file: (type filename): a relative path to a filename to open and parse
1105  * @full_path: (out) (type filename) (optional): return location for a string containing the full path
1106  *   of the file, or %NULL
1107  * @flags: flags from #GKeyFileFlags
1108  * @error: return location for a #GError, or %NULL
1109  *
1110  * This function looks for a key file named @file in the paths
1111  * returned from g_get_user_data_dir() and g_get_system_data_dirs(),
1112  * loads the file into @key_file and returns the file&#39;s full path in
1113  * @full_path.  If the file could not be loaded then an %error is
1114  * set to either a #GFileError or #GKeyFileError.
1115  *
1116  * Returns: %TRUE if a key file could be loaded, %FALSE othewise
1117  * Since: 2.6
1118  **/
1119 gboolean
1120 g_key_file_load_from_data_dirs (GKeyFile       *key_file,
<a name="29" id="anc29"></a><span class="line-modified">1121         const gchar    *file,</span>
<span class="line-modified">1122         gchar         **full_path,</span>
<span class="line-modified">1123         GKeyFileFlags   flags,</span>
<span class="line-modified">1124         GError        **error)</span>
1125 {
1126   gchar **all_data_dirs;
1127   const gchar * user_data_dir;
1128   const gchar * const * system_data_dirs;
1129   gsize i, j;
1130   gboolean found_file;
1131 
1132   g_return_val_if_fail (key_file != NULL, FALSE);
1133   g_return_val_if_fail (!g_path_is_absolute (file), FALSE);
1134 
1135   user_data_dir = g_get_user_data_dir ();
1136   system_data_dirs = g_get_system_data_dirs ();
1137   all_data_dirs = g_new (gchar *, g_strv_length ((gchar **)system_data_dirs) + 2);
1138 
1139   i = 0;
1140   all_data_dirs[i++] = g_strdup (user_data_dir);
1141 
1142   j = 0;
1143   while (system_data_dirs[j] != NULL)
1144     all_data_dirs[i++] = g_strdup (system_data_dirs[j++]);
1145   all_data_dirs[i] = NULL;
1146 
1147   found_file = g_key_file_load_from_dirs (key_file,
1148                                           file,
1149                                           (const gchar **)all_data_dirs,
1150                                           full_path,
1151                                           flags,
1152                                           error);
1153 
1154   g_strfreev (all_data_dirs);
1155 
1156   return found_file;
1157 }
1158 
1159 /**
1160  * g_key_file_ref: (skip)
1161  * @key_file: a #GKeyFile
1162  *
1163  * Increases the reference count of @key_file.
1164  *
1165  * Returns: the same @key_file.
1166  *
1167  * Since: 2.32
1168  **/
1169 GKeyFile *
1170 g_key_file_ref (GKeyFile *key_file)
1171 {
1172   g_return_val_if_fail (key_file != NULL, NULL);
1173 
1174   g_atomic_int_inc (&amp;key_file-&gt;ref_count);
1175 
1176   return key_file;
1177 }
1178 
1179 /**
1180  * g_key_file_free: (skip)
1181  * @key_file: a #GKeyFile
1182  *
1183  * Clears all keys and groups from @key_file, and decreases the
1184  * reference count by 1. If the reference count reaches zero,
1185  * frees the key file and all its allocated memory.
1186  *
1187  * Since: 2.6
1188  **/
1189 void
1190 g_key_file_free (GKeyFile *key_file)
1191 {
1192   g_return_if_fail (key_file != NULL);
1193 
1194   g_key_file_clear (key_file);
1195 
1196   if (g_atomic_int_dec_and_test (&amp;key_file-&gt;ref_count))
1197     g_slice_free (GKeyFile, key_file);
1198   else
1199     g_key_file_init (key_file);
1200 }
1201 
1202 /**
1203  * g_key_file_unref:
1204  * @key_file: a #GKeyFile
1205  *
1206  * Decreases the reference count of @key_file by 1. If the reference count
1207  * reaches zero, frees the key file and all its allocated memory.
1208  *
1209  * Since: 2.32
1210  **/
1211 void
1212 g_key_file_unref (GKeyFile *key_file)
1213 {
1214   g_return_if_fail (key_file != NULL);
1215 
1216   if (g_atomic_int_dec_and_test (&amp;key_file-&gt;ref_count))
1217     {
1218       g_key_file_clear (key_file);
1219       g_slice_free (GKeyFile, key_file);
1220     }
1221 }
1222 
1223 /* If G_KEY_FILE_KEEP_TRANSLATIONS is not set, only returns
1224  * true for locales that match those in g_get_language_names().
1225  */
1226 static gboolean
1227 g_key_file_locale_is_interesting (GKeyFile    *key_file,
<a name="30" id="anc30"></a><span class="line-modified">1228           const gchar *locale)</span>
1229 {
1230   gsize i;
1231 
1232   if (key_file-&gt;flags &amp; G_KEY_FILE_KEEP_TRANSLATIONS)
1233     return TRUE;
1234 
1235   for (i = 0; key_file-&gt;locales[i] != NULL; i++)
1236     {
1237       if (g_ascii_strcasecmp (key_file-&gt;locales[i], locale) == 0)
<a name="31" id="anc31"></a><span class="line-modified">1238   return TRUE;</span>
1239     }
1240 
1241   return FALSE;
1242 }
1243 
1244 static void
1245 g_key_file_parse_line (GKeyFile     *key_file,
<a name="32" id="anc32"></a><span class="line-modified">1246            const gchar  *line,</span>
<span class="line-modified">1247            gsize         length,</span>
<span class="line-modified">1248            GError      **error)</span>
1249 {
1250   GError *parse_error = NULL;
1251   gchar *line_start;
1252 
1253   g_return_if_fail (key_file != NULL);
1254   g_return_if_fail (line != NULL);
1255 
1256   line_start = (gchar *) line;
1257   while (g_ascii_isspace (*line_start))
1258     line_start++;
1259 
1260   if (g_key_file_line_is_comment (line_start))
1261     g_key_file_parse_comment (key_file, line, length, &amp;parse_error);
1262   else if (g_key_file_line_is_group (line_start))
1263     g_key_file_parse_group (key_file, line_start,
<a name="33" id="anc33"></a><span class="line-modified">1264           length - (line_start - line),</span>
<span class="line-modified">1265           &amp;parse_error);</span>
1266   else if (g_key_file_line_is_key_value_pair (line_start))
1267     g_key_file_parse_key_value_pair (key_file, line_start,
<a name="34" id="anc34"></a><span class="line-modified">1268              length - (line_start - line),</span>
<span class="line-modified">1269              &amp;parse_error);</span>
1270   else
1271     {
1272       gchar *line_utf8 = g_utf8_make_valid (line, length);
1273       g_set_error (error, G_KEY_FILE_ERROR,
1274                    G_KEY_FILE_ERROR_PARSE,
1275                    _(&quot;Key file contains line &#39;%s&#39; which is not &quot;
1276                      &quot;a key-value pair, group, or comment&quot;),
1277                    line_utf8);
1278       g_free (line_utf8);
1279 
1280       return;
1281     }
1282 
1283   if (parse_error)
1284     g_propagate_error (error, parse_error);
1285 }
1286 
1287 static void
1288 g_key_file_parse_comment (GKeyFile     *key_file,
<a name="35" id="anc35"></a><span class="line-modified">1289         const gchar  *line,</span>
<span class="line-modified">1290         gsize         length,</span>
<span class="line-modified">1291         GError      **error)</span>
1292 {
1293   GKeyFileKeyValuePair *pair;
1294 
1295   if (!(key_file-&gt;flags &amp; G_KEY_FILE_KEEP_COMMENTS))
1296     return;
1297 
1298   g_warn_if_fail (key_file-&gt;current_group != NULL);
1299 
1300   pair = g_slice_new (GKeyFileKeyValuePair);
1301 #ifdef GSTREAMER_LITE
1302   if (pair == NULL) {
1303     g_warn_if_fail(pair != NULL);
1304     return;
1305   }
1306 #endif // GSTREAMER_LITE
1307   pair-&gt;key = NULL;
1308   pair-&gt;value = g_strndup (line, length);
1309 
1310   key_file-&gt;current_group-&gt;key_value_pairs =
1311     g_list_prepend (key_file-&gt;current_group-&gt;key_value_pairs, pair);
1312 }
1313 
1314 static void
1315 g_key_file_parse_group (GKeyFile     *key_file,
<a name="36" id="anc36"></a><span class="line-modified">1316       const gchar  *line,</span>
<span class="line-modified">1317       gsize         length,</span>
<span class="line-modified">1318       GError      **error)</span>
1319 {
1320   gchar *group_name;
1321   const gchar *group_name_start, *group_name_end;
1322 
1323   /* advance past opening &#39;[&#39;
1324    */
1325   group_name_start = line + 1;
1326   group_name_end = line + length - 1;
1327 
1328   while (*group_name_end != &#39;]&#39;)
1329     group_name_end--;
1330 
1331   group_name = g_strndup (group_name_start,
1332                           group_name_end - group_name_start);
1333 
1334   if (!g_key_file_is_group_name (group_name))
1335     {
1336       g_set_error (error, G_KEY_FILE_ERROR,
<a name="37" id="anc37"></a><span class="line-modified">1337        G_KEY_FILE_ERROR_PARSE,</span>
<span class="line-modified">1338        _(&quot;Invalid group name: %s&quot;), group_name);</span>
1339       g_free (group_name);
1340       return;
1341     }
1342 
1343   g_key_file_add_group (key_file, group_name);
1344   g_free (group_name);
1345 }
1346 
1347 static void
1348 g_key_file_parse_key_value_pair (GKeyFile     *key_file,
<a name="38" id="anc38"></a><span class="line-modified">1349          const gchar  *line,</span>
<span class="line-modified">1350          gsize         length,</span>
<span class="line-modified">1351          GError      **error)</span>
1352 {
1353   gchar *key, *value, *key_end, *value_start, *locale;
1354   gsize key_len, value_len;
1355 
1356   if (key_file-&gt;current_group == NULL || key_file-&gt;current_group-&gt;name == NULL)
1357     {
1358       g_set_error_literal (error, G_KEY_FILE_ERROR,
1359                            G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
1360                            _(&quot;Key file does not start with a group&quot;));
1361       return;
1362     }
1363 
1364   key_end = value_start = strchr (line, &#39;=&#39;);
1365 
1366   g_warn_if_fail (key_end != NULL);
1367 
1368   key_end--;
1369   value_start++;
1370 
1371   /* Pull the key name from the line (chomping trailing whitespace)
1372    */
1373   while (g_ascii_isspace (*key_end))
1374     key_end--;
1375 
1376   key_len = key_end - line + 2;
1377 
1378   g_warn_if_fail (key_len &lt;= length);
1379 
1380   key = g_strndup (line, key_len - 1);
1381 
1382   if (!g_key_file_is_key_name (key))
1383     {
1384       g_set_error (error, G_KEY_FILE_ERROR,
1385                    G_KEY_FILE_ERROR_PARSE,
1386                    _(&quot;Invalid key name: %s&quot;), key);
1387       g_free (key);
1388       return;
1389     }
1390 
1391   /* Pull the value from the line (chugging leading whitespace)
1392    */
1393   while (g_ascii_isspace (*value_start))
1394     value_start++;
1395 
1396   value_len = line + length - value_start + 1;
1397 
1398   value = g_strndup (value_start, value_len);
1399 
1400   g_warn_if_fail (key_file-&gt;start_group != NULL);
1401 
1402   if (key_file-&gt;current_group
1403       &amp;&amp; key_file-&gt;current_group-&gt;name
1404       &amp;&amp; strcmp (key_file-&gt;start_group-&gt;name,
1405                  key_file-&gt;current_group-&gt;name) == 0
1406       &amp;&amp; strcmp (key, &quot;Encoding&quot;) == 0)
1407     {
1408       if (g_ascii_strcasecmp (value, &quot;UTF-8&quot;) != 0)
1409         {
<a name="39" id="anc39"></a><span class="line-modified">1410     gchar *value_utf8 = g_utf8_make_valid (value, value_len);</span>
1411           g_set_error (error, G_KEY_FILE_ERROR,
1412                        G_KEY_FILE_ERROR_UNKNOWN_ENCODING,
1413                        _(&quot;Key file contains unsupported &quot;
<a name="40" id="anc40"></a><span class="line-modified">1414        &quot;encoding &#39;%s&#39;&quot;), value_utf8);</span>
<span class="line-modified">1415     g_free (value_utf8);</span>
1416 
1417           g_free (key);
1418           g_free (value);
1419           return;
1420         }
1421     }
1422 
1423   /* Is this key a translation? If so, is it one that we care about?
1424    */
1425   locale = key_get_locale (key);
1426 
1427   if (locale == NULL || g_key_file_locale_is_interesting (key_file, locale))
1428     {
1429       GKeyFileKeyValuePair *pair;
1430 
1431       pair = g_slice_new (GKeyFileKeyValuePair);
1432 #ifdef GSTREAMER_LITE
1433       if (pair == NULL) {
1434         if (locale != NULL) {
1435           g_free (locale);
1436         }
1437         return;
1438       }
1439 #endif // GSTREAMER_LITE
1440       pair-&gt;key = key;
1441       pair-&gt;value = value;
1442 
1443       g_key_file_add_key_value_pair (key_file, key_file-&gt;current_group, pair);
1444     }
1445   else
1446     {
1447       g_free (key);
1448       g_free (value);
1449     }
1450 
1451   g_free (locale);
1452 }
1453 
1454 static gchar *
1455 key_get_locale (const gchar *key)
1456 {
1457   gchar *locale;
1458 
1459   locale = g_strrstr (key, &quot;[&quot;);
1460 
1461   if (locale &amp;&amp; strlen (locale) &lt;= 2)
1462     locale = NULL;
1463 
1464   if (locale)
1465     locale = g_strndup (locale + 1, strlen (locale) - 2);
1466 
1467   return locale;
1468 }
1469 
1470 static void
1471 g_key_file_parse_data (GKeyFile     *key_file,
<a name="41" id="anc41"></a><span class="line-modified">1472            const gchar  *data,</span>
<span class="line-modified">1473            gsize         length,</span>
<span class="line-modified">1474            GError      **error)</span>
1475 {
1476   GError *parse_error;
1477   gsize i;
1478 
1479   g_return_if_fail (key_file != NULL);
1480   g_return_if_fail (data != NULL || length == 0);
1481 
1482   parse_error = NULL;
1483 
1484   i = 0;
1485   while (i &lt; length)
1486     {
1487       if (data[i] == &#39;\n&#39;)
1488         {
<a name="42" id="anc42"></a><span class="line-modified">1489     if (key_file-&gt;parse_buffer-&gt;len &gt; 0</span>
<span class="line-modified">1490         &amp;&amp; (key_file-&gt;parse_buffer-&gt;str[key_file-&gt;parse_buffer-&gt;len - 1]</span>
<span class="line-modified">1491       == &#39;\r&#39;))</span>
<span class="line-modified">1492       g_string_erase (key_file-&gt;parse_buffer,</span>
<span class="line-modified">1493           key_file-&gt;parse_buffer-&gt;len - 1,</span>
<span class="line-modified">1494           1);</span>
1495 
1496           /* When a newline is encountered flush the parse buffer so that the
1497            * line can be parsed.  Note that completely blank lines won&#39;t show
1498            * up in the parse buffer, so they get parsed directly.
1499            */
1500           if (key_file-&gt;parse_buffer-&gt;len &gt; 0)
1501             g_key_file_flush_parse_buffer (key_file, &amp;parse_error);
1502           else
1503             g_key_file_parse_comment (key_file, &quot;&quot;, 1, &amp;parse_error);
1504 
1505           if (parse_error)
1506             {
1507               g_propagate_error (error, parse_error);
1508               return;
1509             }
1510           i++;
1511         }
1512       else
1513         {
1514           const gchar *start_of_line;
1515           const gchar *end_of_line;
1516           gsize line_length;
1517 
1518           start_of_line = data + i;
1519           end_of_line = memchr (start_of_line, &#39;\n&#39;, length - i);
1520 
1521           if (end_of_line == NULL)
1522             end_of_line = data + length;
1523 
1524           line_length = end_of_line - start_of_line;
1525 
1526           g_string_append_len (key_file-&gt;parse_buffer, start_of_line, line_length);
1527           i += line_length;
1528         }
1529     }
1530 }
1531 
1532 static void
1533 g_key_file_flush_parse_buffer (GKeyFile  *key_file,
<a name="43" id="anc43"></a><span class="line-modified">1534              GError   **error)</span>
1535 {
1536   GError *file_error = NULL;
1537 
1538   g_return_if_fail (key_file != NULL);
1539 
1540   file_error = NULL;
1541 
1542   if (key_file-&gt;parse_buffer-&gt;len &gt; 0)
1543     {
1544       g_key_file_parse_line (key_file, key_file-&gt;parse_buffer-&gt;str,
<a name="44" id="anc44"></a><span class="line-modified">1545            key_file-&gt;parse_buffer-&gt;len,</span>
<span class="line-modified">1546            &amp;file_error);</span>
1547       g_string_erase (key_file-&gt;parse_buffer, 0, -1);
1548 
1549       if (file_error)
1550         {
1551           g_propagate_error (error, file_error);
1552           return;
1553         }
1554     }
1555 }
1556 
1557 /**
1558  * g_key_file_to_data:
1559  * @key_file: a #GKeyFile
1560  * @length: (out) (optional): return location for the length of the
1561  *   returned string, or %NULL
1562  * @error: return location for a #GError, or %NULL
1563  *
1564  * This function outputs @key_file as a string.
1565  *
1566  * Note that this function never reports an error,
1567  * so it is safe to pass %NULL as @error.
1568  *
1569  * Returns: a newly allocated string holding
1570  *   the contents of the #GKeyFile
1571  *
1572  * Since: 2.6
1573  **/
1574 gchar *
1575 g_key_file_to_data (GKeyFile  *key_file,
<a name="45" id="anc45"></a><span class="line-modified">1576         gsize     *length,</span>
<span class="line-modified">1577         GError   **error)</span>
1578 {
1579   GString *data_string;
1580   GList *group_node, *key_file_node;
1581 
1582   g_return_val_if_fail (key_file != NULL, NULL);
1583 
1584   data_string = g_string_new (NULL);
1585 
1586   for (group_node = g_list_last (key_file-&gt;groups);
1587        group_node != NULL;
1588        group_node = group_node-&gt;prev)
1589     {
1590       GKeyFileGroup *group;
1591 
1592       group = (GKeyFileGroup *) group_node-&gt;data;
1593 
1594       /* separate groups by at least an empty line */
1595       if (data_string-&gt;len &gt;= 2 &amp;&amp;
1596           data_string-&gt;str[data_string-&gt;len - 2] != &#39;\n&#39;)
1597         g_string_append_c (data_string, &#39;\n&#39;);
1598 
1599       if (group-&gt;comment != NULL)
1600         g_string_append_printf (data_string, &quot;%s\n&quot;, group-&gt;comment-&gt;value);
1601 
1602       if (group-&gt;name != NULL)
1603         g_string_append_printf (data_string, &quot;[%s]\n&quot;, group-&gt;name);
1604 
1605       for (key_file_node = g_list_last (group-&gt;key_value_pairs);
1606            key_file_node != NULL;
1607            key_file_node = key_file_node-&gt;prev)
1608         {
1609           GKeyFileKeyValuePair *pair;
1610 
1611           pair = (GKeyFileKeyValuePair *) key_file_node-&gt;data;
1612 
1613           if (pair-&gt;key != NULL)
1614             g_string_append_printf (data_string, &quot;%s=%s\n&quot;, pair-&gt;key, pair-&gt;value);
1615           else
1616             g_string_append_printf (data_string, &quot;%s\n&quot;, pair-&gt;value);
1617         }
1618     }
1619 
1620   if (length)
1621     *length = data_string-&gt;len;
1622 
1623   return g_string_free (data_string, FALSE);
1624 }
1625 
1626 /**
1627  * g_key_file_get_keys:
1628  * @key_file: a #GKeyFile
1629  * @group_name: a group name
1630  * @length: (out) (optional): return location for the number of keys returned, or %NULL
1631  * @error: return location for a #GError, or %NULL
1632  *
1633  * Returns all keys for the group name @group_name.  The array of
1634  * returned keys will be %NULL-terminated, so @length may
1635  * optionally be %NULL. In the event that the @group_name cannot
1636  * be found, %NULL is returned and @error is set to
1637  * #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
1638  *
1639  * Returns: (array zero-terminated=1) (transfer full): a newly-allocated %NULL-terminated array of strings.
1640  *     Use g_strfreev() to free it.
1641  *
1642  * Since: 2.6
1643  **/
1644 gchar **
1645 g_key_file_get_keys (GKeyFile     *key_file,
<a name="46" id="anc46"></a><span class="line-modified">1646          const gchar  *group_name,</span>
<span class="line-modified">1647          gsize        *length,</span>
<span class="line-modified">1648          GError      **error)</span>
1649 {
1650   GKeyFileGroup *group;
1651   GList *tmp;
1652   gchar **keys;
1653   gsize i, num_keys;
1654 
1655   g_return_val_if_fail (key_file != NULL, NULL);
1656   g_return_val_if_fail (group_name != NULL, NULL);
1657 
1658   group = g_key_file_lookup_group (key_file, group_name);
1659 
1660   if (!group)
1661     {
1662       g_set_error (error, G_KEY_FILE_ERROR,
1663                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
1664                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
1665 #ifdef GSTREAMER_LITE
1666                    group_name ? group_name : &quot;(null)&quot;);
1667 #else // GSTREAMER_LITE
1668                    group_name);
1669 #endif // GSTREAMER_LITE
1670       return NULL;
1671     }
1672 
1673   num_keys = 0;
1674   for (tmp = group-&gt;key_value_pairs; tmp; tmp = tmp-&gt;next)
1675     {
1676       GKeyFileKeyValuePair *pair;
1677 
1678       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
1679 
1680       if (pair-&gt;key)
<a name="47" id="anc47"></a><span class="line-modified">1681   num_keys++;</span>
1682     }
1683 
1684   keys = g_new (gchar *, num_keys + 1);
1685 
1686   i = num_keys - 1;
1687   for (tmp = group-&gt;key_value_pairs; tmp; tmp = tmp-&gt;next)
1688     {
1689       GKeyFileKeyValuePair *pair;
1690 
1691       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
1692 
1693       if (pair-&gt;key)
<a name="48" id="anc48"></a><span class="line-modified">1694   {</span>
<span class="line-modified">1695     keys[i] = g_strdup (pair-&gt;key);</span>
<span class="line-modified">1696     i--;</span>
<span class="line-modified">1697   }</span>
1698     }
1699 
1700   keys[num_keys] = NULL;
1701 
1702   if (length)
1703     *length = num_keys;
1704 
1705   return keys;
1706 }
1707 
1708 /**
1709  * g_key_file_get_start_group:
1710  * @key_file: a #GKeyFile
1711  *
1712  * Returns the name of the start group of the file.
1713  *
1714  * Returns: The start group of the key file.
1715  *
1716  * Since: 2.6
1717  **/
1718 gchar *
1719 g_key_file_get_start_group (GKeyFile *key_file)
1720 {
1721   g_return_val_if_fail (key_file != NULL, NULL);
1722 
1723   if (key_file-&gt;start_group)
1724     return g_strdup (key_file-&gt;start_group-&gt;name);
1725 
1726   return NULL;
1727 }
1728 
1729 /**
1730  * g_key_file_get_groups:
1731  * @key_file: a #GKeyFile
1732  * @length: (out) (optional): return location for the number of returned groups, or %NULL
1733  *
1734  * Returns all groups in the key file loaded with @key_file.
1735  * The array of returned groups will be %NULL-terminated, so
1736  * @length may optionally be %NULL.
1737  *
1738  * Returns: (array zero-terminated=1) (transfer full): a newly-allocated %NULL-terminated array of strings.
1739  *   Use g_strfreev() to free it.
1740  * Since: 2.6
1741  **/
1742 gchar **
1743 g_key_file_get_groups (GKeyFile *key_file,
<a name="49" id="anc49"></a><span class="line-modified">1744            gsize    *length)</span>
1745 {
1746   GList *group_node;
1747   gchar **groups;
1748   gsize i, num_groups;
1749 
1750   g_return_val_if_fail (key_file != NULL, NULL);
1751 
1752   num_groups = g_list_length (key_file-&gt;groups);
1753 
1754   g_return_val_if_fail (num_groups &gt; 0, NULL);
1755 
1756   group_node = g_list_last (key_file-&gt;groups);
1757 
1758   g_return_val_if_fail (((GKeyFileGroup *) group_node-&gt;data)-&gt;name == NULL, NULL);
1759 
1760   /* Only need num_groups instead of num_groups + 1
1761    * because the first group of the file (last in the
1762    * list) is always the comment group at the top,
1763    * which we skip
1764    */
1765   groups = g_new (gchar *, num_groups);
1766 
1767 
1768   i = 0;
1769   for (group_node = group_node-&gt;prev;
1770        group_node != NULL;
1771        group_node = group_node-&gt;prev)
1772     {
1773       GKeyFileGroup *group;
1774 
1775       group = (GKeyFileGroup *) group_node-&gt;data;
1776 
1777       g_warn_if_fail (group-&gt;name != NULL);
1778 
1779       groups[i++] = g_strdup (group-&gt;name);
1780     }
1781   groups[i] = NULL;
1782 
1783   if (length)
1784     *length = i;
1785 
1786   return groups;
1787 }
1788 
1789 static void
1790 set_not_found_key_error (const char *group_name,
1791                          const char *key,
1792                          GError    **error)
1793 {
1794   g_set_error (error, G_KEY_FILE_ERROR,
1795                G_KEY_FILE_ERROR_KEY_NOT_FOUND,
1796                _(&quot;Key file does not have key &#39;%s&#39; in group &#39;%s&#39;&quot;),
1797                key, group_name);
1798 }
1799 
1800 /**
1801  * g_key_file_get_value:
1802  * @key_file: a #GKeyFile
1803  * @group_name: a group name
1804  * @key: a key
1805  * @error: return location for a #GError, or %NULL
1806  *
1807  * Returns the raw value associated with @key under @group_name.
1808  * Use g_key_file_get_string() to retrieve an unescaped UTF-8 string.
1809  *
1810  * In the event the key cannot be found, %NULL is returned and
1811  * @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
1812  * event that the @group_name cannot be found, %NULL is returned
1813  * and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
1814  *
1815  *
1816  * Returns: a newly allocated string or %NULL if the specified
1817  *  key cannot be found.
1818  *
1819  * Since: 2.6
1820  **/
1821 gchar *
1822 g_key_file_get_value (GKeyFile     *key_file,
<a name="50" id="anc50"></a><span class="line-modified">1823           const gchar  *group_name,</span>
<span class="line-modified">1824           const gchar  *key,</span>
<span class="line-modified">1825           GError      **error)</span>
1826 {
1827   GKeyFileGroup *group;
1828   GKeyFileKeyValuePair *pair;
1829   gchar *value = NULL;
1830 
1831   g_return_val_if_fail (key_file != NULL, NULL);
1832   g_return_val_if_fail (group_name != NULL, NULL);
1833   g_return_val_if_fail (key != NULL, NULL);
1834 
1835   group = g_key_file_lookup_group (key_file, group_name);
1836 
1837   if (!group)
1838     {
1839       g_set_error (error, G_KEY_FILE_ERROR,
1840                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
1841                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
1842 #ifdef GSTREAMER_LITE
1843                    group_name ? group_name : &quot;(null)&quot;);
1844 #else // GSTREAMER_LITE
1845                    group_name);
1846 #endif // GSTREAMER_LITE
1847       return NULL;
1848     }
1849 
1850   pair = g_key_file_lookup_key_value_pair (key_file, group, key);
1851 
1852   if (pair)
1853     value = g_strdup (pair-&gt;value);
1854   else
1855     set_not_found_key_error (group_name, key, error);
1856 
1857   return value;
1858 }
1859 
1860 /**
1861  * g_key_file_set_value:
1862  * @key_file: a #GKeyFile
1863  * @group_name: a group name
1864  * @key: a key
1865  * @value: a string
1866  *
1867  * Associates a new value with @key under @group_name.
1868  *
1869  * If @key cannot be found then it is created. If @group_name cannot
1870  * be found then it is created. To set an UTF-8 string which may contain
1871  * characters that need escaping (such as newlines or spaces), use
1872  * g_key_file_set_string().
1873  *
1874  * Since: 2.6
1875  **/
1876 void
1877 g_key_file_set_value (GKeyFile    *key_file,
<a name="51" id="anc51"></a><span class="line-modified">1878           const gchar *group_name,</span>
<span class="line-modified">1879           const gchar *key,</span>
<span class="line-modified">1880           const gchar *value)</span>
1881 {
1882   GKeyFileGroup *group;
1883   GKeyFileKeyValuePair *pair;
1884 
1885   g_return_if_fail (key_file != NULL);
1886   g_return_if_fail (g_key_file_is_group_name (group_name));
1887   g_return_if_fail (g_key_file_is_key_name (key));
1888   g_return_if_fail (value != NULL);
1889 
1890   group = g_key_file_lookup_group (key_file, group_name);
1891 
1892   if (!group)
1893     {
1894       g_key_file_add_group (key_file, group_name);
1895       group = (GKeyFileGroup *) key_file-&gt;groups-&gt;data;
1896 
1897       g_key_file_add_key (key_file, group, key, value);
1898     }
1899   else
1900     {
1901       pair = g_key_file_lookup_key_value_pair (key_file, group, key);
1902 
1903       if (!pair)
1904         g_key_file_add_key (key_file, group, key, value);
1905       else
1906         {
1907           g_free (pair-&gt;value);
1908           pair-&gt;value = g_strdup (value);
1909         }
1910     }
1911 }
1912 
1913 /**
1914  * g_key_file_get_string:
1915  * @key_file: a #GKeyFile
1916  * @group_name: a group name
1917  * @key: a key
1918  * @error: return location for a #GError, or %NULL
1919  *
1920  * Returns the string value associated with @key under @group_name.
1921  * Unlike g_key_file_get_value(), this function handles escape sequences
1922  * like \s.
1923  *
1924  * In the event the key cannot be found, %NULL is returned and
1925  * @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
1926  * event that the @group_name cannot be found, %NULL is returned
1927  * and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
1928  *
1929  * Returns: a newly allocated string or %NULL if the specified
1930  *   key cannot be found.
1931  *
1932  * Since: 2.6
1933  **/
1934 gchar *
1935 g_key_file_get_string (GKeyFile     *key_file,
<a name="52" id="anc52"></a><span class="line-modified">1936            const gchar  *group_name,</span>
<span class="line-modified">1937            const gchar  *key,</span>
<span class="line-modified">1938            GError      **error)</span>
1939 {
1940   gchar *value, *string_value;
1941   GError *key_file_error;
1942 
1943   g_return_val_if_fail (key_file != NULL, NULL);
1944   g_return_val_if_fail (group_name != NULL, NULL);
1945   g_return_val_if_fail (key != NULL, NULL);
1946 
1947   key_file_error = NULL;
1948 
1949   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
1950 
1951   if (key_file_error)
1952     {
1953       g_propagate_error (error, key_file_error);
1954       return NULL;
1955     }
1956 
1957   if (!g_utf8_validate (value, -1, NULL))
1958     {
1959       gchar *value_utf8 = g_utf8_make_valid (value, -1);
1960       g_set_error (error, G_KEY_FILE_ERROR,
1961                    G_KEY_FILE_ERROR_UNKNOWN_ENCODING,
1962                    _(&quot;Key file contains key &#39;%s&#39; with value &#39;%s&#39; &quot;
1963                      &quot;which is not UTF-8&quot;), key, value_utf8);
1964       g_free (value_utf8);
1965       g_free (value);
1966 
1967       return NULL;
1968     }
1969 
1970   string_value = g_key_file_parse_value_as_string (key_file, value, NULL,
<a name="53" id="anc53"></a><span class="line-modified">1971                &amp;key_file_error);</span>
1972   g_free (value);
1973 
1974   if (key_file_error)
1975     {
1976       if (g_error_matches (key_file_error,
1977                            G_KEY_FILE_ERROR,
1978                            G_KEY_FILE_ERROR_INVALID_VALUE))
1979         {
1980           g_set_error (error, G_KEY_FILE_ERROR,
1981                        G_KEY_FILE_ERROR_INVALID_VALUE,
1982                        _(&quot;Key file contains key &#39;%s&#39; &quot;
1983                          &quot;which has a value that cannot be interpreted.&quot;),
1984                        key);
1985           g_error_free (key_file_error);
1986         }
1987       else
1988         g_propagate_error (error, key_file_error);
1989     }
1990 
1991   return string_value;
1992 }
1993 
1994 /**
1995  * g_key_file_set_string:
1996  * @key_file: a #GKeyFile
1997  * @group_name: a group name
1998  * @key: a key
1999  * @string: a string
2000  *
2001  * Associates a new string value with @key under @group_name.
2002  * If @key cannot be found then it is created.
2003  * If @group_name cannot be found then it is created.
2004  * Unlike g_key_file_set_value(), this function handles characters
2005  * that need escaping, such as newlines.
2006  *
2007  * Since: 2.6
2008  **/
2009 void
2010 g_key_file_set_string (GKeyFile    *key_file,
<a name="54" id="anc54"></a><span class="line-modified">2011            const gchar *group_name,</span>
<span class="line-modified">2012            const gchar *key,</span>
<span class="line-modified">2013            const gchar *string)</span>
2014 {
2015   gchar *value;
2016 
2017   g_return_if_fail (key_file != NULL);
2018   g_return_if_fail (string != NULL);
2019 
2020   value = g_key_file_parse_string_as_value (key_file, string, FALSE);
2021   g_key_file_set_value (key_file, group_name, key, value);
2022   g_free (value);
2023 }
2024 
2025 /**
2026  * g_key_file_get_string_list:
2027  * @key_file: a #GKeyFile
2028  * @group_name: a group name
2029  * @key: a key
2030  * @length: (out) (optional): return location for the number of returned strings, or %NULL
2031  * @error: return location for a #GError, or %NULL
2032  *
2033  * Returns the values associated with @key under @group_name.
2034  *
2035  * In the event the key cannot be found, %NULL is returned and
2036  * @error is set to #G_KEY_FILE_ERROR_KEY_NOT_FOUND.  In the
2037  * event that the @group_name cannot be found, %NULL is returned
2038  * and @error is set to #G_KEY_FILE_ERROR_GROUP_NOT_FOUND.
2039  *
2040  * Returns: (array zero-terminated=1 length=length) (element-type utf8) (transfer full):
2041  *  a %NULL-terminated string array or %NULL if the specified
2042  *  key cannot be found. The array should be freed with g_strfreev().
2043  *
2044  * Since: 2.6
2045  **/
2046 gchar **
2047 g_key_file_get_string_list (GKeyFile     *key_file,
<a name="55" id="anc55"></a><span class="line-modified">2048           const gchar  *group_name,</span>
<span class="line-modified">2049           const gchar  *key,</span>
<span class="line-modified">2050           gsize        *length,</span>
<span class="line-modified">2051           GError      **error)</span>
2052 {
2053   GError *key_file_error = NULL;
2054   gchar *value, *string_value, **values;
2055   gint i, len;
2056   GSList *p, *pieces = NULL;
2057 
2058   g_return_val_if_fail (key_file != NULL, NULL);
2059   g_return_val_if_fail (group_name != NULL, NULL);
2060   g_return_val_if_fail (key != NULL, NULL);
2061 
2062   if (length)
2063     *length = 0;
2064 
2065   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
2066 
2067   if (key_file_error)
2068     {
2069       g_propagate_error (error, key_file_error);
2070       return NULL;
2071     }
2072 
2073   if (!g_utf8_validate (value, -1, NULL))
2074     {
2075       gchar *value_utf8 = g_utf8_make_valid (value, -1);
2076       g_set_error (error, G_KEY_FILE_ERROR,
2077                    G_KEY_FILE_ERROR_UNKNOWN_ENCODING,
2078                    _(&quot;Key file contains key &#39;%s&#39; with value &#39;%s&#39; &quot;
2079                      &quot;which is not UTF-8&quot;), key, value_utf8);
2080       g_free (value_utf8);
2081       g_free (value);
2082 
2083       return NULL;
2084     }
2085 
2086   string_value = g_key_file_parse_value_as_string (key_file, value, &amp;pieces, &amp;key_file_error);
2087   g_free (value);
2088   g_free (string_value);
2089 
2090   if (key_file_error)
2091     {
2092       if (g_error_matches (key_file_error,
2093                            G_KEY_FILE_ERROR,
2094                            G_KEY_FILE_ERROR_INVALID_VALUE))
2095         {
2096           g_set_error (error, G_KEY_FILE_ERROR,
2097                        G_KEY_FILE_ERROR_INVALID_VALUE,
2098                        _(&quot;Key file contains key &#39;%s&#39; &quot;
2099                          &quot;which has a value that cannot be interpreted.&quot;),
2100                        key);
2101           g_error_free (key_file_error);
2102         }
2103       else
2104         g_propagate_error (error, key_file_error);
2105 
2106       g_slist_free_full (pieces, g_free);
2107       return NULL;
2108     }
2109 
2110   len = g_slist_length (pieces);
2111   values = g_new (gchar *, len + 1);
2112   for (p = pieces, i = 0; p; p = p-&gt;next)
2113     values[i++] = p-&gt;data;
2114   values[len] = NULL;
2115 
2116   g_slist_free (pieces);
2117 
2118   if (length)
2119     *length = len;
2120 
2121   return values;
2122 }
2123 
2124 /**
2125  * g_key_file_set_string_list:
2126  * @key_file: a #GKeyFile
2127  * @group_name: a group name
2128  * @key: a key
2129  * @list: (array zero-terminated=1 length=length) (element-type utf8): an array of string values
2130  * @length: number of string values in @list
2131  *
2132  * Associates a list of string values for @key under @group_name.
2133  * If @key cannot be found then it is created.
2134  * If @group_name cannot be found then it is created.
2135  *
2136  * Since: 2.6
2137  **/
2138 void
2139 g_key_file_set_string_list (GKeyFile            *key_file,
<a name="56" id="anc56"></a><span class="line-modified">2140           const gchar         *group_name,</span>
<span class="line-modified">2141           const gchar         *key,</span>
<span class="line-modified">2142           const gchar * const  list[],</span>
<span class="line-modified">2143           gsize                length)</span>
2144 {
2145   GString *value_list;
2146   gsize i;
2147 
2148   g_return_if_fail (key_file != NULL);
2149   g_return_if_fail (list != NULL || length == 0);
2150 
2151   value_list = g_string_sized_new (length * 128);
2152 #ifdef GSTREAMER_LITE
2153   if (value_list == NULL) {
2154     return;
2155   }
2156 #endif // GSTREAMER_LITE
2157   for (i = 0; i &lt; length &amp;&amp; list[i] != NULL; i++)
2158     {
2159       gchar *value;
2160 
2161       value = g_key_file_parse_string_as_value (key_file, list[i], TRUE);
2162       g_string_append (value_list, value);
2163       g_string_append_c (value_list, key_file-&gt;list_separator);
2164 
2165       g_free (value);
2166     }
2167 
2168   g_key_file_set_value (key_file, group_name, key, value_list-&gt;str);
2169   g_string_free (value_list, TRUE);
2170 }
2171 
2172 /**
2173  * g_key_file_set_locale_string:
2174  * @key_file: a #GKeyFile
2175  * @group_name: a group name
2176  * @key: a key
2177  * @locale: a locale identifier
2178  * @string: a string
2179  *
2180  * Associates a string value for @key and @locale under @group_name.
2181  * If the translation for @key cannot be found then it is created.
2182  *
2183  * Since: 2.6
2184  **/
2185 void
2186 g_key_file_set_locale_string (GKeyFile     *key_file,
<a name="57" id="anc57"></a><span class="line-modified">2187             const gchar  *group_name,</span>
<span class="line-modified">2188             const gchar  *key,</span>
<span class="line-modified">2189             const gchar  *locale,</span>
<span class="line-modified">2190             const gchar  *string)</span>
2191 {
2192   gchar *full_key, *value;
2193 
2194   g_return_if_fail (key_file != NULL);
2195   g_return_if_fail (key != NULL);
2196   g_return_if_fail (locale != NULL);
2197   g_return_if_fail (string != NULL);
2198 
2199   value = g_key_file_parse_string_as_value (key_file, string, FALSE);
2200   full_key = g_strdup_printf (&quot;%s[%s]&quot;, key, locale);
2201   g_key_file_set_value (key_file, group_name, full_key, value);
2202   g_free (full_key);
2203   g_free (value);
2204 }
2205 
2206 /**
2207  * g_key_file_get_locale_string:
2208  * @key_file: a #GKeyFile
2209  * @group_name: a group name
2210  * @key: a key
2211  * @locale: (nullable): a locale identifier or %NULL
2212  * @error: return location for a #GError, or %NULL
2213  *
2214  * Returns the value associated with @key under @group_name
2215  * translated in the given @locale if available.  If @locale is
2216  * %NULL then the current locale is assumed.
2217  *
2218  * If @locale is to be non-%NULL, or if the current locale will change over
2219  * the lifetime of the #GKeyFile, it must be loaded with
2220  * %G_KEY_FILE_KEEP_TRANSLATIONS in order to load strings for all locales.
2221  *
2222  * If @key cannot be found then %NULL is returned and @error is set
2223  * to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the value associated
2224  * with @key cannot be interpreted or no suitable translation can
2225  * be found then the untranslated value is returned.
2226  *
2227  * Returns: a newly allocated string or %NULL if the specified
2228  *   key cannot be found.
2229  *
2230  * Since: 2.6
2231  **/
2232 gchar *
2233 g_key_file_get_locale_string (GKeyFile     *key_file,
<a name="58" id="anc58"></a><span class="line-modified">2234             const gchar  *group_name,</span>
<span class="line-modified">2235             const gchar  *key,</span>
<span class="line-modified">2236             const gchar  *locale,</span>
<span class="line-modified">2237             GError      **error)</span>
2238 {
2239   gchar *candidate_key, *translated_value;
2240   GError *key_file_error;
2241   gchar **languages;
2242   gboolean free_languages = FALSE;
2243   gint i;
2244 
2245   g_return_val_if_fail (key_file != NULL, NULL);
2246   g_return_val_if_fail (group_name != NULL, NULL);
2247   g_return_val_if_fail (key != NULL, NULL);
2248 
2249   candidate_key = NULL;
2250   translated_value = NULL;
2251   key_file_error = NULL;
2252 
2253   if (locale)
2254     {
2255       languages = g_get_locale_variants (locale);
2256       free_languages = TRUE;
2257     }
2258   else
2259     {
2260       languages = (gchar **) g_get_language_names ();
2261       free_languages = FALSE;
2262     }
2263 
2264   for (i = 0; languages[i]; i++)
2265     {
2266       candidate_key = g_strdup_printf (&quot;%s[%s]&quot;, key, languages[i]);
2267 
2268       translated_value = g_key_file_get_string (key_file,
<a name="59" id="anc59"></a><span class="line-modified">2269             group_name,</span>
<span class="line-modified">2270             candidate_key, NULL);</span>
2271       g_free (candidate_key);
2272 
2273       if (translated_value)
<a name="60" id="anc60"></a><span class="line-modified">2274   break;</span>
2275 
2276       g_free (translated_value);
2277       translated_value = NULL;
2278    }
2279 
2280   /* Fallback to untranslated key
2281    */
2282   if (!translated_value)
2283     {
2284       translated_value = g_key_file_get_string (key_file, group_name, key,
<a name="61" id="anc61"></a><span class="line-modified">2285             &amp;key_file_error);</span>
2286 
2287       if (!translated_value)
2288         g_propagate_error (error, key_file_error);
2289     }
2290 
2291   if (free_languages)
2292     g_strfreev (languages);
2293 
2294   return translated_value;
2295 }
2296 
2297 /**
2298  * g_key_file_get_locale_for_key:
2299  * @key_file: a #GKeyFile
2300  * @group_name: a group name
2301  * @key: a key
2302  * @locale: (nullable): a locale identifier or %NULL
2303  *
2304  * Returns the actual locale which the result of
2305  * g_key_file_get_locale_string() or g_key_file_get_locale_string_list()
2306  * came from.
2307  *
2308  * If calling g_key_file_get_locale_string() or
2309  * g_key_file_get_locale_string_list() with exactly the same @key_file,
2310  * @group_name, @key and @locale, the result of those functions will
2311  * have originally been tagged with the locale that is the result of
2312  * this function.
2313  *
2314  * Returns: (nullable): the locale from the file, or %NULL if the key was not
2315  *   found or the entry in the file was was untranslated
2316  *
2317  * Since: 2.56
2318  */
2319 gchar *
2320 g_key_file_get_locale_for_key (GKeyFile    *key_file,
2321                                const gchar *group_name,
2322                                const gchar *key,
2323                                const gchar *locale)
2324 {
2325   gchar **languages_allocated = NULL;
2326   const gchar * const *languages;
2327   gchar *result = NULL;
2328   gsize i;
2329 
2330   g_return_val_if_fail (key_file != NULL, NULL);
2331   g_return_val_if_fail (group_name != NULL, NULL);
2332   g_return_val_if_fail (key != NULL, NULL);
2333 
2334   if (locale != NULL)
2335     {
2336       languages_allocated = g_get_locale_variants (locale);
2337       languages = (const gchar * const *) languages_allocated;
2338     }
2339   else
2340     languages = g_get_language_names ();
2341 
2342   for (i = 0; languages[i] != NULL; i++)
2343     {
2344       gchar *candidate_key, *translated_value;
2345 
2346       candidate_key = g_strdup_printf (&quot;%s[%s]&quot;, key, languages[i]);
2347       translated_value = g_key_file_get_string (key_file, group_name, candidate_key, NULL);
2348       g_free (translated_value);
2349       g_free (candidate_key);
2350 
2351       if (translated_value != NULL)
2352         break;
2353    }
2354 
2355   result = g_strdup (languages[i]);
2356 
2357   g_strfreev (languages_allocated);
2358 
2359   return result;
2360 }
2361 
2362 /**
2363  * g_key_file_get_locale_string_list:
2364  * @key_file: a #GKeyFile
2365  * @group_name: a group name
2366  * @key: a key
2367  * @locale: (nullable): a locale identifier or %NULL
2368  * @length: (out) (optional): return location for the number of returned strings or %NULL
2369  * @error: return location for a #GError or %NULL
2370  *
2371  * Returns the values associated with @key under @group_name
2372  * translated in the given @locale if available.  If @locale is
2373  * %NULL then the current locale is assumed.
2374  *
2375  * If @locale is to be non-%NULL, or if the current locale will change over
2376  * the lifetime of the #GKeyFile, it must be loaded with
2377  * %G_KEY_FILE_KEEP_TRANSLATIONS in order to load strings for all locales.
2378  *
2379  * If @key cannot be found then %NULL is returned and @error is set
2380  * to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. If the values associated
2381  * with @key cannot be interpreted or no suitable translations
2382  * can be found then the untranslated values are returned. The
2383  * returned array is %NULL-terminated, so @length may optionally
2384  * be %NULL.
2385  *
2386  * Returns: (array zero-terminated=1 length=length) (element-type utf8) (transfer full): a newly allocated %NULL-terminated string array
2387  *   or %NULL if the key isn&#39;t found. The string array should be freed
2388  *   with g_strfreev().
2389  *
2390  * Since: 2.6
2391  **/
2392 gchar **
2393 g_key_file_get_locale_string_list (GKeyFile     *key_file,
<a name="62" id="anc62"></a><span class="line-modified">2394            const gchar  *group_name,</span>
<span class="line-modified">2395            const gchar  *key,</span>
<span class="line-modified">2396            const gchar  *locale,</span>
<span class="line-modified">2397            gsize        *length,</span>
<span class="line-modified">2398            GError      **error)</span>
2399 {
2400   GError *key_file_error;
2401   gchar **values, *value;
2402   char list_separator[2];
2403   gsize len;
2404 
2405   g_return_val_if_fail (key_file != NULL, NULL);
2406   g_return_val_if_fail (group_name != NULL, NULL);
2407   g_return_val_if_fail (key != NULL, NULL);
2408 
2409   key_file_error = NULL;
2410 
2411   value = g_key_file_get_locale_string (key_file, group_name,
<a name="63" id="anc63"></a><span class="line-modified">2412           key, locale,</span>
<span class="line-modified">2413           &amp;key_file_error);</span>
2414 
2415   if (key_file_error)
2416     g_propagate_error (error, key_file_error);
2417 
2418   if (!value)
2419     {
2420       if (length)
2421         *length = 0;
2422       return NULL;
2423     }
2424 
2425   len = strlen (value);
2426   if (value[len - 1] == key_file-&gt;list_separator)
2427     value[len - 1] = &#39;\0&#39;;
2428 
2429   list_separator[0] = key_file-&gt;list_separator;
2430   list_separator[1] = &#39;\0&#39;;
2431   values = g_strsplit (value, list_separator, 0);
2432 
2433   g_free (value);
2434 
2435   if (length)
2436     *length = g_strv_length (values);
2437 
2438   return values;
2439 }
2440 
2441 /**
2442  * g_key_file_set_locale_string_list:
2443  * @key_file: a #GKeyFile
2444  * @group_name: a group name
2445  * @key: a key
2446  * @locale: a locale identifier
2447  * @list: (array zero-terminated=1 length=length): a %NULL-terminated array of locale string values
2448  * @length: the length of @list
2449  *
2450  * Associates a list of string values for @key and @locale under
2451  * @group_name.  If the translation for @key cannot be found then
2452  * it is created.
2453  *
2454  * Since: 2.6
2455  **/
2456 void
2457 g_key_file_set_locale_string_list (GKeyFile            *key_file,
<a name="64" id="anc64"></a><span class="line-modified">2458            const gchar         *group_name,</span>
<span class="line-modified">2459            const gchar         *key,</span>
<span class="line-modified">2460            const gchar         *locale,</span>
<span class="line-modified">2461            const gchar * const  list[],</span>
<span class="line-modified">2462            gsize                length)</span>
2463 {
2464   GString *value_list;
2465   gchar *full_key;
2466   gsize i;
2467 
2468   g_return_if_fail (key_file != NULL);
2469   g_return_if_fail (key != NULL);
2470   g_return_if_fail (locale != NULL);
2471   g_return_if_fail (length != 0);
2472 
2473   value_list = g_string_sized_new (length * 128);
2474 #ifdef GSTREAMER_LITE
2475   if (value_list == NULL) {
2476     return;
2477   }
2478 #endif // GSTREAMER_LITE
2479   for (i = 0; i &lt; length &amp;&amp; list[i] != NULL; i++)
2480     {
2481       gchar *value;
2482 
2483       value = g_key_file_parse_string_as_value (key_file, list[i], TRUE);
2484       g_string_append (value_list, value);
2485       g_string_append_c (value_list, key_file-&gt;list_separator);
2486 
2487       g_free (value);
2488     }
2489 
2490   full_key = g_strdup_printf (&quot;%s[%s]&quot;, key, locale);
2491   g_key_file_set_value (key_file, group_name, full_key, value_list-&gt;str);
2492   g_free (full_key);
2493   g_string_free (value_list, TRUE);
2494 }
2495 
2496 /**
2497  * g_key_file_get_boolean:
2498  * @key_file: a #GKeyFile
2499  * @group_name: a group name
2500  * @key: a key
2501  * @error: return location for a #GError
2502  *
2503  * Returns the value associated with @key under @group_name as a
2504  * boolean.
2505  *
2506  * If @key cannot be found then %FALSE is returned and @error is set
2507  * to #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value
2508  * associated with @key cannot be interpreted as a boolean then %FALSE
2509  * is returned and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
2510  *
2511  * Returns: the value associated with the key as a boolean,
2512  *    or %FALSE if the key was not found or could not be parsed.
2513  *
2514  * Since: 2.6
2515  **/
2516 gboolean
2517 g_key_file_get_boolean (GKeyFile     *key_file,
<a name="65" id="anc65"></a><span class="line-modified">2518       const gchar  *group_name,</span>
<span class="line-modified">2519       const gchar  *key,</span>
<span class="line-modified">2520       GError      **error)</span>
2521 {
2522   GError *key_file_error = NULL;
2523   gchar *value;
2524   gboolean bool_value;
2525 
2526   g_return_val_if_fail (key_file != NULL, FALSE);
2527   g_return_val_if_fail (group_name != NULL, FALSE);
2528   g_return_val_if_fail (key != NULL, FALSE);
2529 
2530   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
2531 
2532   if (!value)
2533     {
2534       g_propagate_error (error, key_file_error);
2535       return FALSE;
2536     }
2537 
2538   bool_value = g_key_file_parse_value_as_boolean (key_file, value,
<a name="66" id="anc66"></a><span class="line-modified">2539               &amp;key_file_error);</span>
2540   g_free (value);
2541 
2542   if (key_file_error)
2543     {
2544       if (g_error_matches (key_file_error,
2545                            G_KEY_FILE_ERROR,
2546                            G_KEY_FILE_ERROR_INVALID_VALUE))
2547         {
2548           g_set_error (error, G_KEY_FILE_ERROR,
2549                        G_KEY_FILE_ERROR_INVALID_VALUE,
2550                        _(&quot;Key file contains key &#39;%s&#39; &quot;
2551                          &quot;which has a value that cannot be interpreted.&quot;),
2552                        key);
2553           g_error_free (key_file_error);
2554         }
2555       else
2556         g_propagate_error (error, key_file_error);
2557     }
2558 
2559   return bool_value;
2560 }
2561 
2562 /**
2563  * g_key_file_set_boolean:
2564  * @key_file: a #GKeyFile
2565  * @group_name: a group name
2566  * @key: a key
2567  * @value: %TRUE or %FALSE
2568  *
2569  * Associates a new boolean value with @key under @group_name.
2570  * If @key cannot be found then it is created.
2571  *
2572  * Since: 2.6
2573  **/
2574 void
2575 g_key_file_set_boolean (GKeyFile    *key_file,
<a name="67" id="anc67"></a><span class="line-modified">2576       const gchar *group_name,</span>
<span class="line-modified">2577       const gchar *key,</span>
<span class="line-modified">2578       gboolean     value)</span>
2579 {
2580   gchar *result;
2581 
2582   g_return_if_fail (key_file != NULL);
2583 
2584   result = g_key_file_parse_boolean_as_value (key_file, value);
2585   g_key_file_set_value (key_file, group_name, key, result);
2586   g_free (result);
2587 }
2588 
2589 /**
2590  * g_key_file_get_boolean_list:
2591  * @key_file: a #GKeyFile
2592  * @group_name: a group name
2593  * @key: a key
2594  * @length: (out): the number of booleans returned
2595  * @error: return location for a #GError
2596  *
2597  * Returns the values associated with @key under @group_name as
2598  * booleans.
2599  *
2600  * If @key cannot be found then %NULL is returned and @error is set to
2601  * #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
2602  * with @key cannot be interpreted as booleans then %NULL is returned
2603  * and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
2604  *
2605  * Returns: (array length=length) (element-type gboolean) (transfer container):
2606  *    the values associated with the key as a list of booleans, or %NULL if the
2607  *    key was not found or could not be parsed. The returned list of booleans
2608  *    should be freed with g_free() when no longer needed.
2609  *
2610  * Since: 2.6
2611  **/
2612 gboolean *
2613 g_key_file_get_boolean_list (GKeyFile     *key_file,
<a name="68" id="anc68"></a><span class="line-modified">2614            const gchar  *group_name,</span>
<span class="line-modified">2615            const gchar  *key,</span>
<span class="line-modified">2616            gsize        *length,</span>
<span class="line-modified">2617            GError      **error)</span>
2618 {
2619   GError *key_file_error;
2620   gchar **values;
2621   gboolean *bool_values;
2622   gsize i, num_bools;
2623 
2624   g_return_val_if_fail (key_file != NULL, NULL);
2625   g_return_val_if_fail (group_name != NULL, NULL);
2626   g_return_val_if_fail (key != NULL, NULL);
2627 
2628   if (length)
2629     *length = 0;
2630 
2631   key_file_error = NULL;
2632 
2633   values = g_key_file_get_string_list (key_file, group_name, key,
<a name="69" id="anc69"></a><span class="line-modified">2634                &amp;num_bools, &amp;key_file_error);</span>
2635 
2636   if (key_file_error)
2637     g_propagate_error (error, key_file_error);
2638 
2639   if (!values)
2640     return NULL;
2641 
2642   bool_values = g_new (gboolean, num_bools);
2643 
2644   for (i = 0; i &lt; num_bools; i++)
2645     {
2646       bool_values[i] = g_key_file_parse_value_as_boolean (key_file,
<a name="70" id="anc70"></a><span class="line-modified">2647                 values[i],</span>
<span class="line-modified">2648                 &amp;key_file_error);</span>
2649 
2650       if (key_file_error)
2651         {
2652           g_propagate_error (error, key_file_error);
2653           g_strfreev (values);
2654           g_free (bool_values);
2655 
2656           return NULL;
2657         }
2658     }
2659   g_strfreev (values);
2660 
2661   if (length)
2662     *length = num_bools;
2663 
2664   return bool_values;
2665 }
2666 
2667 /**
2668  * g_key_file_set_boolean_list:
2669  * @key_file: a #GKeyFile
2670  * @group_name: a group name
2671  * @key: a key
2672  * @list: (array length=length): an array of boolean values
2673  * @length: length of @list
2674  *
2675  * Associates a list of boolean values with @key under @group_name.
2676  * If @key cannot be found then it is created.
2677  * If @group_name is %NULL, the start_group is used.
2678  *
2679  * Since: 2.6
2680  **/
2681 void
2682 g_key_file_set_boolean_list (GKeyFile    *key_file,
<a name="71" id="anc71"></a><span class="line-modified">2683            const gchar *group_name,</span>
<span class="line-modified">2684            const gchar *key,</span>
<span class="line-modified">2685            gboolean     list[],</span>
<span class="line-modified">2686            gsize        length)</span>
2687 {
2688   GString *value_list;
2689   gsize i;
2690 
2691   g_return_if_fail (key_file != NULL);
2692   g_return_if_fail (list != NULL);
2693 
2694   value_list = g_string_sized_new (length * 8);
2695 #ifdef GSTREAMER_LITE
2696   if (value_list == NULL) {
2697     return;
2698   }
2699 #endif // GSTREAMER_LITE
2700   for (i = 0; i &lt; length; i++)
2701     {
2702       gchar *value;
2703 
2704       value = g_key_file_parse_boolean_as_value (key_file, list[i]);
2705 
2706       g_string_append (value_list, value);
2707       g_string_append_c (value_list, key_file-&gt;list_separator);
2708 
2709       g_free (value);
2710     }
2711 
2712   g_key_file_set_value (key_file, group_name, key, value_list-&gt;str);
2713   g_string_free (value_list, TRUE);
2714 }
2715 
2716 /**
2717  * g_key_file_get_integer:
2718  * @key_file: a #GKeyFile
2719  * @group_name: a group name
2720  * @key: a key
2721  * @error: return location for a #GError
2722  *
2723  * Returns the value associated with @key under @group_name as an
2724  * integer.
2725  *
2726  * If @key cannot be found then 0 is returned and @error is set to
2727  * #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated
2728  * with @key cannot be interpreted as an integer, or is out of range
2729  * for a #gint, then 0 is returned
2730  * and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
2731  *
2732  * Returns: the value associated with the key as an integer, or
2733  *     0 if the key was not found or could not be parsed.
2734  *
2735  * Since: 2.6
2736  **/
2737 gint
2738 g_key_file_get_integer (GKeyFile     *key_file,
<a name="72" id="anc72"></a><span class="line-modified">2739       const gchar  *group_name,</span>
<span class="line-modified">2740       const gchar  *key,</span>
<span class="line-modified">2741       GError      **error)</span>
2742 {
2743   GError *key_file_error;
2744   gchar *value;
2745   gint int_value;
2746 
2747   g_return_val_if_fail (key_file != NULL, -1);
2748   g_return_val_if_fail (group_name != NULL, -1);
2749   g_return_val_if_fail (key != NULL, -1);
2750 
2751   key_file_error = NULL;
2752 
2753   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
2754 
2755   if (key_file_error)
2756     {
2757       g_propagate_error (error, key_file_error);
2758       return 0;
2759     }
2760 
2761   int_value = g_key_file_parse_value_as_integer (key_file, value,
<a name="73" id="anc73"></a><span class="line-modified">2762              &amp;key_file_error);</span>
2763   g_free (value);
2764 
2765   if (key_file_error)
2766     {
2767       if (g_error_matches (key_file_error,
2768                            G_KEY_FILE_ERROR,
2769                            G_KEY_FILE_ERROR_INVALID_VALUE))
2770         {
2771           g_set_error (error, G_KEY_FILE_ERROR,
2772                        G_KEY_FILE_ERROR_INVALID_VALUE,
2773                        _(&quot;Key file contains key &#39;%s&#39; in group &#39;%s&#39; &quot;
2774                          &quot;which has a value that cannot be interpreted.&quot;),
2775                          key, group_name);
2776           g_error_free (key_file_error);
2777         }
2778       else
2779         g_propagate_error (error, key_file_error);
2780     }
2781 
2782   return int_value;
2783 }
2784 
2785 /**
2786  * g_key_file_set_integer:
2787  * @key_file: a #GKeyFile
2788  * @group_name: a group name
2789  * @key: a key
2790  * @value: an integer value
2791  *
2792  * Associates a new integer value with @key under @group_name.
2793  * If @key cannot be found then it is created.
2794  *
2795  * Since: 2.6
2796  **/
2797 void
2798 g_key_file_set_integer (GKeyFile    *key_file,
<a name="74" id="anc74"></a><span class="line-modified">2799       const gchar *group_name,</span>
<span class="line-modified">2800       const gchar *key,</span>
<span class="line-modified">2801       gint         value)</span>
2802 {
2803   gchar *result;
2804 
2805   g_return_if_fail (key_file != NULL);
2806 
2807   result = g_key_file_parse_integer_as_value (key_file, value);
2808   g_key_file_set_value (key_file, group_name, key, result);
2809   g_free (result);
2810 }
2811 
2812 /**
2813  * g_key_file_get_int64:
2814  * @key_file: a non-%NULL #GKeyFile
2815  * @group_name: a non-%NULL group name
2816  * @key: a non-%NULL key
2817  * @error: return location for a #GError
2818  *
2819  * Returns the value associated with @key under @group_name as a signed
2820  * 64-bit integer. This is similar to g_key_file_get_integer() but can return
2821  * 64-bit results without truncation.
2822  *
2823  * Returns: the value associated with the key as a signed 64-bit integer, or
2824  * 0 if the key was not found or could not be parsed.
2825  *
2826  * Since: 2.26
2827  */
2828 gint64
2829 g_key_file_get_int64 (GKeyFile     *key_file,
2830                       const gchar  *group_name,
2831                       const gchar  *key,
2832                       GError      **error)
2833 {
2834   gchar *s, *end;
2835   gint64 v;
2836 
2837   g_return_val_if_fail (key_file != NULL, -1);
2838   g_return_val_if_fail (group_name != NULL, -1);
2839   g_return_val_if_fail (key != NULL, -1);
2840 
2841   s = g_key_file_get_value (key_file, group_name, key, error);
2842 
2843   if (s == NULL)
2844     return 0;
2845 
2846   v = g_ascii_strtoll (s, &amp;end, 10);
2847 
2848   if (*s == &#39;\0&#39; || *end != &#39;\0&#39;)
2849     {
2850       g_set_error (error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_INVALID_VALUE,
2851                    _(&quot;Key &#39;%s&#39; in group &#39;%s&#39; has value &#39;%s&#39; &quot;
2852                      &quot;where %s was expected&quot;),
2853                    key, group_name, s, &quot;int64&quot;);
2854       g_free (s);
2855       return 0;
2856     }
2857 
2858   g_free (s);
2859   return v;
2860 }
2861 
2862 /**
2863  * g_key_file_set_int64:
2864  * @key_file: a #GKeyFile
2865  * @group_name: a group name
2866  * @key: a key
2867  * @value: an integer value
2868  *
2869  * Associates a new integer value with @key under @group_name.
2870  * If @key cannot be found then it is created.
2871  *
2872  * Since: 2.26
2873  **/
2874 void
2875 g_key_file_set_int64 (GKeyFile    *key_file,
2876                       const gchar *group_name,
2877                       const gchar *key,
2878                       gint64       value)
2879 {
2880   gchar *result;
2881 
2882   g_return_if_fail (key_file != NULL);
2883 
2884   result = g_strdup_printf (&quot;%&quot; G_GINT64_FORMAT, value);
2885   g_key_file_set_value (key_file, group_name, key, result);
2886   g_free (result);
2887 }
2888 
2889 /**
2890  * g_key_file_get_uint64:
2891  * @key_file: a non-%NULL #GKeyFile
2892  * @group_name: a non-%NULL group name
2893  * @key: a non-%NULL key
2894  * @error: return location for a #GError
2895  *
2896  * Returns the value associated with @key under @group_name as an unsigned
2897  * 64-bit integer. This is similar to g_key_file_get_integer() but can return
2898  * large positive results without truncation.
2899  *
2900  * Returns: the value associated with the key as an unsigned 64-bit integer,
2901  * or 0 if the key was not found or could not be parsed.
2902  *
2903  * Since: 2.26
2904  */
2905 guint64
2906 g_key_file_get_uint64 (GKeyFile     *key_file,
2907                        const gchar  *group_name,
2908                        const gchar  *key,
2909                        GError      **error)
2910 {
2911   gchar *s, *end;
2912   guint64 v;
2913 
2914   g_return_val_if_fail (key_file != NULL, -1);
2915   g_return_val_if_fail (group_name != NULL, -1);
2916   g_return_val_if_fail (key != NULL, -1);
2917 
2918   s = g_key_file_get_value (key_file, group_name, key, error);
2919 
2920   if (s == NULL)
2921     return 0;
2922 
2923   v = g_ascii_strtoull (s, &amp;end, 10);
2924 
2925   if (*s == &#39;\0&#39; || *end != &#39;\0&#39;)
2926     {
2927       g_set_error (error, G_KEY_FILE_ERROR, G_KEY_FILE_ERROR_INVALID_VALUE,
2928                    _(&quot;Key &#39;%s&#39; in group &#39;%s&#39; has value &#39;%s&#39; &quot;
2929                      &quot;where %s was expected&quot;),
2930                    key, group_name, s, &quot;uint64&quot;);
2931       g_free (s);
2932       return 0;
2933     }
2934 
2935   g_free (s);
2936   return v;
2937 }
2938 
2939 /**
2940  * g_key_file_set_uint64:
2941  * @key_file: a #GKeyFile
2942  * @group_name: a group name
2943  * @key: a key
2944  * @value: an integer value
2945  *
2946  * Associates a new integer value with @key under @group_name.
2947  * If @key cannot be found then it is created.
2948  *
2949  * Since: 2.26
2950  **/
2951 void
2952 g_key_file_set_uint64 (GKeyFile    *key_file,
2953                        const gchar *group_name,
2954                        const gchar *key,
2955                        guint64      value)
2956 {
2957   gchar *result;
2958 
2959   g_return_if_fail (key_file != NULL);
2960 
2961   result = g_strdup_printf (&quot;%&quot; G_GUINT64_FORMAT, value);
2962   g_key_file_set_value (key_file, group_name, key, result);
2963   g_free (result);
2964 }
2965 
2966 /**
2967  * g_key_file_get_integer_list:
2968  * @key_file: a #GKeyFile
2969  * @group_name: a group name
2970  * @key: a key
2971  * @length: (out): the number of integers returned
2972  * @error: return location for a #GError
2973  *
2974  * Returns the values associated with @key under @group_name as
2975  * integers.
2976  *
2977  * If @key cannot be found then %NULL is returned and @error is set to
2978  * #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
2979  * with @key cannot be interpreted as integers, or are out of range for
2980  * #gint, then %NULL is returned
2981  * and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
2982  *
2983  * Returns: (array length=length) (element-type gint) (transfer container):
2984  *     the values associated with the key as a list of integers, or %NULL if
2985  *     the key was not found or could not be parsed. The returned list of
2986  *     integers should be freed with g_free() when no longer needed.
2987  *
2988  * Since: 2.6
2989  **/
2990 gint *
2991 g_key_file_get_integer_list (GKeyFile     *key_file,
<a name="75" id="anc75"></a><span class="line-modified">2992            const gchar  *group_name,</span>
<span class="line-modified">2993            const gchar  *key,</span>
<span class="line-modified">2994            gsize        *length,</span>
<span class="line-modified">2995            GError      **error)</span>
2996 {
2997   GError *key_file_error = NULL;
2998   gchar **values;
2999   gint *int_values;
3000   gsize i, num_ints;
3001 
3002   g_return_val_if_fail (key_file != NULL, NULL);
3003   g_return_val_if_fail (group_name != NULL, NULL);
3004   g_return_val_if_fail (key != NULL, NULL);
3005 
3006   if (length)
3007     *length = 0;
3008 
3009   values = g_key_file_get_string_list (key_file, group_name, key,
<a name="76" id="anc76"></a><span class="line-modified">3010                &amp;num_ints, &amp;key_file_error);</span>
3011 
3012   if (key_file_error)
3013     g_propagate_error (error, key_file_error);
3014 
3015   if (!values)
3016     return NULL;
3017 
3018   int_values = g_new (gint, num_ints);
3019 
3020   for (i = 0; i &lt; num_ints; i++)
3021     {
3022       int_values[i] = g_key_file_parse_value_as_integer (key_file,
<a name="77" id="anc77"></a><span class="line-modified">3023                values[i],</span>
<span class="line-modified">3024                &amp;key_file_error);</span>
3025 
3026       if (key_file_error)
3027         {
3028           g_propagate_error (error, key_file_error);
3029           g_strfreev (values);
3030           g_free (int_values);
3031 
3032           return NULL;
3033         }
3034     }
3035   g_strfreev (values);
3036 
3037   if (length)
3038     *length = num_ints;
3039 
3040   return int_values;
3041 }
3042 
3043 /**
3044  * g_key_file_set_integer_list:
3045  * @key_file: a #GKeyFile
3046  * @group_name: a group name
3047  * @key: a key
3048  * @list: (array length=length): an array of integer values
3049  * @length: number of integer values in @list
3050  *
3051  * Associates a list of integer values with @key under @group_name.
3052  * If @key cannot be found then it is created.
3053  *
3054  * Since: 2.6
3055  **/
3056 void
3057 g_key_file_set_integer_list (GKeyFile    *key_file,
<a name="78" id="anc78"></a><span class="line-modified">3058            const gchar *group_name,</span>
<span class="line-modified">3059            const gchar *key,</span>
<span class="line-modified">3060            gint         list[],</span>
<span class="line-modified">3061            gsize        length)</span>
3062 {
3063   GString *values;
3064   gsize i;
3065 
3066   g_return_if_fail (key_file != NULL);
3067   g_return_if_fail (list != NULL);
3068 
3069   values = g_string_sized_new (length * 16);
3070 #ifdef GSTREAMER_LITE
3071   if (values == NULL) {
3072     return;
3073   }
3074 #endif // GSTREAMER_LITE
3075   for (i = 0; i &lt; length; i++)
3076     {
3077       gchar *value;
3078 
3079       value = g_key_file_parse_integer_as_value (key_file, list[i]);
3080 
3081       g_string_append (values, value);
3082       g_string_append_c (values, key_file-&gt;list_separator);
3083 
3084       g_free (value);
3085     }
3086 
3087   g_key_file_set_value (key_file, group_name, key, values-&gt;str);
3088   g_string_free (values, TRUE);
3089 }
3090 
3091 /**
3092  * g_key_file_get_double:
3093  * @key_file: a #GKeyFile
3094  * @group_name: a group name
3095  * @key: a key
3096  * @error: return location for a #GError
3097  *
3098  * Returns the value associated with @key under @group_name as a
3099  * double. If @group_name is %NULL, the start_group is used.
3100  *
3101  * If @key cannot be found then 0.0 is returned and @error is set to
3102  * #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the value associated
3103  * with @key cannot be interpreted as a double then 0.0 is returned
3104  * and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
3105  *
3106  * Returns: the value associated with the key as a double, or
3107  *     0.0 if the key was not found or could not be parsed.
3108  *
3109  * Since: 2.12
3110  **/
3111 gdouble
3112 g_key_file_get_double  (GKeyFile     *key_file,
3113                         const gchar  *group_name,
3114                         const gchar  *key,
3115                         GError      **error)
3116 {
3117   GError *key_file_error;
3118   gchar *value;
3119   gdouble double_value;
3120 
3121   g_return_val_if_fail (key_file != NULL, -1);
3122   g_return_val_if_fail (group_name != NULL, -1);
3123   g_return_val_if_fail (key != NULL, -1);
3124 
3125   key_file_error = NULL;
3126 
3127   value = g_key_file_get_value (key_file, group_name, key, &amp;key_file_error);
3128 
3129   if (key_file_error)
3130     {
3131       g_propagate_error (error, key_file_error);
3132       return 0;
3133     }
3134 
3135   double_value = g_key_file_parse_value_as_double (key_file, value,
3136                                                   &amp;key_file_error);
3137   g_free (value);
3138 
3139   if (key_file_error)
3140     {
3141       if (g_error_matches (key_file_error,
3142                            G_KEY_FILE_ERROR,
3143                            G_KEY_FILE_ERROR_INVALID_VALUE))
3144         {
3145           g_set_error (error, G_KEY_FILE_ERROR,
3146                        G_KEY_FILE_ERROR_INVALID_VALUE,
3147                        _(&quot;Key file contains key &#39;%s&#39; in group &#39;%s&#39; &quot;
3148                          &quot;which has a value that cannot be interpreted.&quot;),
3149                        key, group_name);
3150           g_error_free (key_file_error);
3151         }
3152       else
3153         g_propagate_error (error, key_file_error);
3154     }
3155 
3156   return double_value;
3157 }
3158 
3159 /**
3160  * g_key_file_set_double:
3161  * @key_file: a #GKeyFile
3162  * @group_name: a group name
3163  * @key: a key
<a name="79" id="anc79"></a><span class="line-modified">3164  * @value: a double value</span>
3165  *
3166  * Associates a new double value with @key under @group_name.
3167  * If @key cannot be found then it is created.
3168  *
3169  * Since: 2.12
3170  **/
3171 void
3172 g_key_file_set_double  (GKeyFile    *key_file,
3173                         const gchar *group_name,
3174                         const gchar *key,
3175                         gdouble      value)
3176 {
3177   gchar result[G_ASCII_DTOSTR_BUF_SIZE];
3178 
3179   g_return_if_fail (key_file != NULL);
3180 
3181   g_ascii_dtostr (result, sizeof (result), value);
3182   g_key_file_set_value (key_file, group_name, key, result);
3183 }
3184 
3185 /**
3186  * g_key_file_get_double_list:
3187  * @key_file: a #GKeyFile
3188  * @group_name: a group name
3189  * @key: a key
3190  * @length: (out): the number of doubles returned
3191  * @error: return location for a #GError
3192  *
3193  * Returns the values associated with @key under @group_name as
3194  * doubles.
3195  *
3196  * If @key cannot be found then %NULL is returned and @error is set to
3197  * #G_KEY_FILE_ERROR_KEY_NOT_FOUND. Likewise, if the values associated
3198  * with @key cannot be interpreted as doubles then %NULL is returned
3199  * and @error is set to #G_KEY_FILE_ERROR_INVALID_VALUE.
3200  *
3201  * Returns: (array length=length) (element-type gdouble) (transfer container):
3202  *     the values associated with the key as a list of doubles, or %NULL if the
3203  *     key was not found or could not be parsed. The returned list of doubles
3204  *     should be freed with g_free() when no longer needed.
3205  *
3206  * Since: 2.12
3207  **/
3208 gdouble *
3209 g_key_file_get_double_list  (GKeyFile     *key_file,
3210                              const gchar  *group_name,
3211                              const gchar  *key,
3212                              gsize        *length,
3213                              GError      **error)
3214 {
3215   GError *key_file_error = NULL;
3216   gchar **values;
3217   gdouble *double_values;
3218   gsize i, num_doubles;
3219 
3220   g_return_val_if_fail (key_file != NULL, NULL);
3221   g_return_val_if_fail (group_name != NULL, NULL);
3222   g_return_val_if_fail (key != NULL, NULL);
3223 
3224   if (length)
3225     *length = 0;
3226 
3227   values = g_key_file_get_string_list (key_file, group_name, key,
3228                                        &amp;num_doubles, &amp;key_file_error);
3229 
3230   if (key_file_error)
3231     g_propagate_error (error, key_file_error);
3232 
3233   if (!values)
3234     return NULL;
3235 
3236   double_values = g_new (gdouble, num_doubles);
3237 
3238   for (i = 0; i &lt; num_doubles; i++)
3239     {
3240       double_values[i] = g_key_file_parse_value_as_double (key_file,
<a name="80" id="anc80"></a><span class="line-modified">3241                  values[i],</span>
<span class="line-modified">3242                  &amp;key_file_error);</span>
3243 
3244       if (key_file_error)
3245         {
3246           g_propagate_error (error, key_file_error);
3247           g_strfreev (values);
3248           g_free (double_values);
3249 
3250           return NULL;
3251         }
3252     }
3253   g_strfreev (values);
3254 
3255   if (length)
3256     *length = num_doubles;
3257 
3258   return double_values;
3259 }
3260 
3261 /**
3262  * g_key_file_set_double_list:
3263  * @key_file: a #GKeyFile
3264  * @group_name: a group name
3265  * @key: a key
3266  * @list: (array length=length): an array of double values
3267  * @length: number of double values in @list
3268  *
3269  * Associates a list of double values with @key under
3270  * @group_name.  If @key cannot be found then it is created.
3271  *
3272  * Since: 2.12
3273  **/
3274 void
3275 g_key_file_set_double_list (GKeyFile    *key_file,
<a name="81" id="anc81"></a><span class="line-modified">3276           const gchar *group_name,</span>
<span class="line-modified">3277           const gchar *key,</span>
<span class="line-modified">3278           gdouble      list[],</span>
<span class="line-modified">3279           gsize        length)</span>
3280 {
3281   GString *values;
3282   gsize i;
3283 
3284   g_return_if_fail (key_file != NULL);
3285   g_return_if_fail (list != NULL);
3286 
3287   values = g_string_sized_new (length * 16);
3288 #ifdef GSTREAMER_LITE
3289   if (values == NULL) {
3290     return;
3291   }
3292 #endif // GSTREAMER_LITE
3293   for (i = 0; i &lt; length; i++)
3294     {
3295       gchar result[G_ASCII_DTOSTR_BUF_SIZE];
3296 
3297       g_ascii_dtostr( result, sizeof (result), list[i] );
3298 
3299       g_string_append (values, result);
3300       g_string_append_c (values, key_file-&gt;list_separator);
3301     }
3302 
3303   g_key_file_set_value (key_file, group_name, key, values-&gt;str);
3304   g_string_free (values, TRUE);
3305 }
3306 
3307 static gboolean
3308 g_key_file_set_key_comment (GKeyFile     *key_file,
3309                             const gchar  *group_name,
3310                             const gchar  *key,
3311                             const gchar  *comment,
3312                             GError      **error)
3313 {
3314   GKeyFileGroup *group;
3315   GKeyFileKeyValuePair *pair;
3316   GList *key_node, *comment_node, *tmp;
3317 
3318   group = g_key_file_lookup_group (key_file, group_name);
3319   if (!group)
3320     {
3321       g_set_error (error, G_KEY_FILE_ERROR,
3322                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
3323                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
3324                    group_name ? group_name : &quot;(null)&quot;);
3325 
3326       return FALSE;
3327     }
3328 
3329   /* First find the key the comments are supposed to be
3330    * associated with
3331    */
3332   key_node = g_key_file_lookup_key_value_pair_node (key_file, group, key);
3333 
3334   if (key_node == NULL)
3335     {
3336       set_not_found_key_error (group-&gt;name, key, error);
3337       return FALSE;
3338     }
3339 
3340   /* Then find all the comments already associated with the
3341    * key and free them
3342    */
3343   tmp = key_node-&gt;next;
3344   while (tmp != NULL)
3345     {
3346       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3347 
3348       if (pair-&gt;key != NULL)
3349         break;
3350 
3351       comment_node = tmp;
3352       tmp = tmp-&gt;next;
3353       g_key_file_remove_key_value_pair_node (key_file, group,
3354                                              comment_node);
3355     }
3356 
3357   if (comment == NULL)
3358     return TRUE;
3359 
3360   /* Now we can add our new comment
3361    */
3362   pair = g_slice_new (GKeyFileKeyValuePair);
3363 #ifdef GSTREAMER_LITE
3364   if (pair == NULL) {
3365     return FALSE;
3366   }
3367 #endif // GSTREAMER_LITE
3368   pair-&gt;key = NULL;
3369   pair-&gt;value = g_key_file_parse_comment_as_value (key_file, comment);
3370 
3371   key_node = g_list_insert (key_node, pair, 1);
3372 
3373   return TRUE;
3374 }
3375 
3376 static gboolean
3377 g_key_file_set_group_comment (GKeyFile     *key_file,
3378                               const gchar  *group_name,
3379                               const gchar  *comment,
3380                               GError      **error)
3381 {
3382   GKeyFileGroup *group;
3383 
3384   g_return_val_if_fail (g_key_file_is_group_name (group_name), FALSE);
3385 
3386   group = g_key_file_lookup_group (key_file, group_name);
3387   if (!group)
3388     {
3389       g_set_error (error, G_KEY_FILE_ERROR,
3390                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
3391                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
3392                    group_name ? group_name : &quot;(null)&quot;);
3393 
3394       return FALSE;
3395     }
3396 
3397   /* First remove any existing comment
3398    */
3399   if (group-&gt;comment)
3400     {
3401       g_key_file_key_value_pair_free (group-&gt;comment);
3402       group-&gt;comment = NULL;
3403     }
3404 
3405   if (comment == NULL)
3406     return TRUE;
3407 
3408   /* Now we can add our new comment
3409    */
3410   group-&gt;comment = g_slice_new (GKeyFileKeyValuePair);
3411 #ifdef GSTREAMER_LITE
3412   if (group-&gt;comment == NULL) {
3413     return FALSE;
3414   }
3415 #endif // GSTREAMER_LITE
3416   group-&gt;comment-&gt;key = NULL;
3417   group-&gt;comment-&gt;value = g_key_file_parse_comment_as_value (key_file, comment);
3418 
3419   return TRUE;
3420 }
3421 
3422 static gboolean
3423 g_key_file_set_top_comment (GKeyFile     *key_file,
3424                             const gchar  *comment,
3425                             GError      **error)
3426 {
3427   GList *group_node;
3428   GKeyFileGroup *group;
3429   GKeyFileKeyValuePair *pair;
3430 
3431   /* The last group in the list should be the top (comments only)
3432    * group in the file
3433    */
3434   g_warn_if_fail (key_file-&gt;groups != NULL);
3435   group_node = g_list_last (key_file-&gt;groups);
3436   group = (GKeyFileGroup *) group_node-&gt;data;
3437   g_warn_if_fail (group-&gt;name == NULL);
3438 
3439   /* Note all keys must be comments at the top of
3440    * the file, so we can just free it all.
3441    */
3442   g_list_free_full (group-&gt;key_value_pairs, (GDestroyNotify) g_key_file_key_value_pair_free);
3443   group-&gt;key_value_pairs = NULL;
3444 
3445   if (comment == NULL)
3446      return TRUE;
3447 
3448   pair = g_slice_new (GKeyFileKeyValuePair);
3449 #ifdef GSTREAMER_LITE
3450   if (pair == NULL) {
3451     return FALSE;
3452   }
3453 #endif // GSTREAMER_LITE
3454   pair-&gt;key = NULL;
3455   pair-&gt;value = g_key_file_parse_comment_as_value (key_file, comment);
3456 
3457   group-&gt;key_value_pairs =
3458     g_list_prepend (group-&gt;key_value_pairs, pair);
3459 
3460   return TRUE;
3461 }
3462 
3463 /**
3464  * g_key_file_set_comment:
3465  * @key_file: a #GKeyFile
3466  * @group_name: (nullable): a group name, or %NULL
3467  * @key: (nullable): a key
3468  * @comment: a comment
3469  * @error: return location for a #GError
3470  *
3471  * Places a comment above @key from @group_name.
3472  *
3473  * If @key is %NULL then @comment will be written above @group_name.
3474  * If both @key and @group_name  are %NULL, then @comment will be
3475  * written above the first group in the file.
3476  *
3477  * Note that this function prepends a &#39;#&#39; comment marker to
3478  * each line of @comment.
3479  *
3480  * Returns: %TRUE if the comment was written, %FALSE otherwise
3481  *
3482  * Since: 2.6
3483  **/
3484 gboolean
3485 g_key_file_set_comment (GKeyFile     *key_file,
3486                         const gchar  *group_name,
3487                         const gchar  *key,
3488                         const gchar  *comment,
3489                         GError      **error)
3490 {
3491   g_return_val_if_fail (key_file != NULL, FALSE);
3492 
3493   if (group_name != NULL &amp;&amp; key != NULL)
3494     {
3495       if (!g_key_file_set_key_comment (key_file, group_name, key, comment, error))
3496         return FALSE;
3497     }
3498   else if (group_name != NULL)
3499     {
3500       if (!g_key_file_set_group_comment (key_file, group_name, comment, error))
3501         return FALSE;
3502     }
3503   else
3504     {
3505       if (!g_key_file_set_top_comment (key_file, comment, error))
3506         return FALSE;
3507     }
3508 
3509   return TRUE;
3510 }
3511 
3512 static gchar *
3513 g_key_file_get_key_comment (GKeyFile     *key_file,
3514                             const gchar  *group_name,
3515                             const gchar  *key,
3516                             GError      **error)
3517 {
3518   GKeyFileGroup *group;
3519   GKeyFileKeyValuePair *pair;
3520   GList *key_node, *tmp;
3521   GString *string;
3522   gchar *comment;
3523 
3524   g_return_val_if_fail (g_key_file_is_group_name (group_name), NULL);
3525 
3526   group = g_key_file_lookup_group (key_file, group_name);
3527   if (!group)
3528     {
3529       g_set_error (error, G_KEY_FILE_ERROR,
3530                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
3531                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
3532                    group_name ? group_name : &quot;(null)&quot;);
3533 
3534       return NULL;
3535     }
3536 
3537   /* First find the key the comments are supposed to be
3538    * associated with
3539    */
3540   key_node = g_key_file_lookup_key_value_pair_node (key_file, group, key);
3541 
3542   if (key_node == NULL)
3543     {
3544       set_not_found_key_error (group-&gt;name, key, error);
3545       return NULL;
3546     }
3547 
3548   string = NULL;
3549 
3550   /* Then find all the comments already associated with the
3551    * key and concatentate them.
3552    */
3553   tmp = key_node-&gt;next;
3554   if (!key_node-&gt;next)
3555     return NULL;
3556 
3557   pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3558   if (pair-&gt;key != NULL)
3559     return NULL;
3560 
3561   while (tmp-&gt;next)
3562     {
3563       pair = (GKeyFileKeyValuePair *) tmp-&gt;next-&gt;data;
3564 
3565       if (pair-&gt;key != NULL)
3566         break;
3567 
3568       tmp = tmp-&gt;next;
3569     }
3570 
3571   while (tmp != key_node)
3572     {
3573       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3574 
3575       if (string == NULL)
<a name="82" id="anc82"></a><span class="line-modified">3576   string = g_string_sized_new (512);</span>
3577 
<a name="83" id="anc83"></a><span class="line-modified">3578       comment = g_key_file_parse_value_as_comment (key_file, pair-&gt;value,</span>
<span class="line-added">3579                                                    (tmp-&gt;prev == key_node));</span>
3580       g_string_append (string, comment);
3581       g_free (comment);
3582 
3583       tmp = tmp-&gt;prev;
3584     }
3585 
3586   if (string != NULL)
3587     {
3588       comment = string-&gt;str;
3589       g_string_free (string, FALSE);
3590     }
3591   else
3592     comment = NULL;
3593 
3594   return comment;
3595 }
3596 
3597 static gchar *
3598 get_group_comment (GKeyFile       *key_file,
<a name="84" id="anc84"></a><span class="line-modified">3599        GKeyFileGroup  *group,</span>
<span class="line-modified">3600        GError        **error)</span>
3601 {
3602   GString *string;
3603   GList *tmp;
3604   gchar *comment;
3605 
3606   string = NULL;
3607 
3608   tmp = group-&gt;key_value_pairs;
3609   while (tmp)
3610     {
3611       GKeyFileKeyValuePair *pair;
3612 
3613       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3614 
3615       if (pair-&gt;key != NULL)
<a name="85" id="anc85"></a><span class="line-modified">3616   {</span>
<span class="line-modified">3617     tmp = tmp-&gt;prev;</span>
<span class="line-modified">3618     break;</span>
<span class="line-modified">3619   }</span>
3620 
3621       if (tmp-&gt;next == NULL)
<a name="86" id="anc86"></a><span class="line-modified">3622   break;</span>
3623 
3624       tmp = tmp-&gt;next;
3625     }
3626 
3627   while (tmp != NULL)
3628     {
3629       GKeyFileKeyValuePair *pair;
3630 
3631       pair = (GKeyFileKeyValuePair *) tmp-&gt;data;
3632 
3633       if (string == NULL)
3634         string = g_string_sized_new (512);
3635 
<a name="87" id="anc87"></a><span class="line-modified">3636       comment = g_key_file_parse_value_as_comment (key_file, pair-&gt;value,</span>
<span class="line-added">3637                                                    (tmp-&gt;prev == NULL));</span>
3638       g_string_append (string, comment);
3639       g_free (comment);
3640 
3641       tmp = tmp-&gt;prev;
3642     }
3643 
3644   if (string != NULL)
3645     return g_string_free (string, FALSE);
3646 
3647   return NULL;
3648 }
3649 
3650 static gchar *
3651 g_key_file_get_group_comment (GKeyFile     *key_file,
3652                               const gchar  *group_name,
3653                               GError      **error)
3654 {
3655   GList *group_node;
3656   GKeyFileGroup *group;
3657 
3658   group = g_key_file_lookup_group (key_file, group_name);
3659   if (!group)
3660     {
3661       g_set_error (error, G_KEY_FILE_ERROR,
3662                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
3663                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
3664                    group_name ? group_name : &quot;(null)&quot;);
3665 
3666       return NULL;
3667     }
3668 
3669   if (group-&gt;comment)
3670     return g_strdup (group-&gt;comment-&gt;value);
3671 
3672   group_node = g_key_file_lookup_group_node (key_file, group_name);
3673   group_node = group_node-&gt;next;
3674   group = (GKeyFileGroup *)group_node-&gt;data;
3675   return get_group_comment (key_file, group, error);
3676 }
3677 
3678 static gchar *
3679 g_key_file_get_top_comment (GKeyFile  *key_file,
3680                             GError   **error)
3681 {
3682   GList *group_node;
3683   GKeyFileGroup *group;
3684 
3685   /* The last group in the list should be the top (comments only)
3686    * group in the file
3687    */
3688   g_warn_if_fail (key_file-&gt;groups != NULL);
3689   group_node = g_list_last (key_file-&gt;groups);
3690   group = (GKeyFileGroup *) group_node-&gt;data;
3691   g_warn_if_fail (group-&gt;name == NULL);
3692 
3693   return get_group_comment (key_file, group, error);
3694 }
3695 
3696 /**
3697  * g_key_file_get_comment:
3698  * @key_file: a #GKeyFile
3699  * @group_name: (nullable): a group name, or %NULL
3700  * @key: a key
3701  * @error: return location for a #GError
3702  *
3703  * Retrieves a comment above @key from @group_name.
3704  * If @key is %NULL then @comment will be read from above
3705  * @group_name. If both @key and @group_name are %NULL, then
3706  * @comment will be read from above the first group in the file.
3707  *
<a name="88" id="anc88"></a><span class="line-modified">3708  * Note that the returned string does not include the &#39;#&#39; comment markers,</span>
<span class="line-added">3709  * but does include any whitespace after them (on each line). It includes</span>
<span class="line-added">3710  * the line breaks between lines, but does not include the final line break.</span>
3711  *
3712  * Returns: a comment that should be freed with g_free()
3713  *
3714  * Since: 2.6
3715  **/
3716 gchar *
3717 g_key_file_get_comment (GKeyFile     *key_file,
3718                         const gchar  *group_name,
3719                         const gchar  *key,
3720                         GError      **error)
3721 {
3722   g_return_val_if_fail (key_file != NULL, NULL);
3723 
3724   if (group_name != NULL &amp;&amp; key != NULL)
3725     return g_key_file_get_key_comment (key_file, group_name, key, error);
3726   else if (group_name != NULL)
3727     return g_key_file_get_group_comment (key_file, group_name, error);
3728   else
3729     return g_key_file_get_top_comment (key_file, error);
3730 }
3731 
3732 /**
3733  * g_key_file_remove_comment:
3734  * @key_file: a #GKeyFile
3735  * @group_name: (nullable): a group name, or %NULL
3736  * @key: (nullable): a key
3737  * @error: return location for a #GError
3738  *
3739  * Removes a comment above @key from @group_name.
3740  * If @key is %NULL then @comment will be removed above @group_name.
3741  * If both @key and @group_name are %NULL, then @comment will
3742  * be removed above the first group in the file.
3743  *
3744  * Returns: %TRUE if the comment was removed, %FALSE otherwise
3745  *
3746  * Since: 2.6
3747  **/
3748 
3749 gboolean
3750 g_key_file_remove_comment (GKeyFile     *key_file,
3751                            const gchar  *group_name,
3752                            const gchar  *key,
3753                            GError      **error)
3754 {
3755   g_return_val_if_fail (key_file != NULL, FALSE);
3756 
3757   if (group_name != NULL &amp;&amp; key != NULL)
3758     return g_key_file_set_key_comment (key_file, group_name, key, NULL, error);
3759   else if (group_name != NULL)
3760     return g_key_file_set_group_comment (key_file, group_name, NULL, error);
3761   else
3762     return g_key_file_set_top_comment (key_file, NULL, error);
3763 }
3764 
3765 /**
3766  * g_key_file_has_group:
3767  * @key_file: a #GKeyFile
3768  * @group_name: a group name
3769  *
3770  * Looks whether the key file has the group @group_name.
3771  *
3772  * Returns: %TRUE if @group_name is a part of @key_file, %FALSE
3773  * otherwise.
3774  * Since: 2.6
3775  **/
3776 gboolean
3777 g_key_file_has_group (GKeyFile    *key_file,
<a name="89" id="anc89"></a><span class="line-modified">3778           const gchar *group_name)</span>
3779 {
3780   g_return_val_if_fail (key_file != NULL, FALSE);
3781   g_return_val_if_fail (group_name != NULL, FALSE);
3782 
3783   return g_key_file_lookup_group (key_file, group_name) != NULL;
3784 }
3785 
3786 /* This code remains from a historical attempt to add a new public API
3787  * which respects the GError rules.
3788  */
3789 static gboolean
3790 g_key_file_has_key_full (GKeyFile     *key_file,
<a name="90" id="anc90"></a><span class="line-modified">3791        const gchar  *group_name,</span>
<span class="line-modified">3792        const gchar  *key,</span>
<span class="line-modified">3793        gboolean     *has_key,</span>
<span class="line-modified">3794        GError      **error)</span>
3795 {
3796   GKeyFileKeyValuePair *pair;
3797   GKeyFileGroup *group;
3798 
3799   g_return_val_if_fail (key_file != NULL, FALSE);
3800   g_return_val_if_fail (group_name != NULL, FALSE);
3801   g_return_val_if_fail (key != NULL, FALSE);
3802 
3803   group = g_key_file_lookup_group (key_file, group_name);
3804 
3805   if (!group)
3806     {
3807       g_set_error (error, G_KEY_FILE_ERROR,
3808                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
3809                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
3810 #ifdef GSTREAMER_LITE
3811                    group_name ? group_name : &quot;(null)&quot;);
3812 #else // GSTREAMER_LITE
3813                    group_name);
3814 #endif // GSTREAMER_LITE
3815 
3816       return FALSE;
3817     }
3818 
3819   pair = g_key_file_lookup_key_value_pair (key_file, group, key);
3820 
3821   if (has_key)
3822     *has_key = pair != NULL;
3823   return TRUE;
3824 }
3825 
3826 /**
3827  * g_key_file_has_key: (skip)
3828  * @key_file: a #GKeyFile
3829  * @group_name: a group name
3830  * @key: a key name
3831  * @error: return location for a #GError
3832  *
3833  * Looks whether the key file has the key @key in the group
3834  * @group_name.
3835  *
3836  * Note that this function does not follow the rules for #GError strictly;
3837  * the return value both carries meaning and signals an error.  To use
3838  * this function, you must pass a #GError pointer in @error, and check
3839  * whether it is not %NULL to see if an error occurred.
3840  *
3841  * Language bindings should use g_key_file_get_value() to test whether
3842  * or not a key exists.
3843  *
3844  * Returns: %TRUE if @key is a part of @group_name, %FALSE otherwise
3845  *
3846  * Since: 2.6
3847  **/
3848 gboolean
3849 g_key_file_has_key (GKeyFile     *key_file,
<a name="91" id="anc91"></a><span class="line-modified">3850         const gchar  *group_name,</span>
<span class="line-modified">3851         const gchar  *key,</span>
<span class="line-modified">3852         GError      **error)</span>
3853 {
3854   GError *temp_error = NULL;
3855   gboolean has_key;
3856 
3857   if (g_key_file_has_key_full (key_file, group_name, key, &amp;has_key, &amp;temp_error))
3858     {
3859       return has_key;
3860     }
3861   else
3862     {
3863       g_propagate_error (error, temp_error);
3864       return FALSE;
3865     }
3866 }
3867 
3868 static void
3869 g_key_file_add_group (GKeyFile    *key_file,
<a name="92" id="anc92"></a><span class="line-modified">3870           const gchar *group_name)</span>
3871 {
3872   GKeyFileGroup *group;
3873 
3874   g_return_if_fail (key_file != NULL);
3875   g_return_if_fail (g_key_file_is_group_name (group_name));
3876 
3877   group = g_key_file_lookup_group (key_file, group_name);
3878   if (group != NULL)
3879     {
3880       key_file-&gt;current_group = group;
3881       return;
3882     }
3883 
3884   group = g_slice_new0 (GKeyFileGroup);
3885   group-&gt;name = g_strdup (group_name);
3886   group-&gt;lookup_map = g_hash_table_new (g_str_hash, g_str_equal);
3887   key_file-&gt;groups = g_list_prepend (key_file-&gt;groups, group);
3888   key_file-&gt;current_group = group;
3889 
3890   if (key_file-&gt;start_group == NULL)
3891     key_file-&gt;start_group = group;
3892 
3893   g_hash_table_insert (key_file-&gt;group_hash, (gpointer)group-&gt;name, group);
3894 }
3895 
3896 static void
3897 g_key_file_key_value_pair_free (GKeyFileKeyValuePair *pair)
3898 {
3899   if (pair != NULL)
3900     {
3901       g_free (pair-&gt;key);
3902       g_free (pair-&gt;value);
3903       g_slice_free (GKeyFileKeyValuePair, pair);
3904     }
3905 }
3906 
3907 /* Be careful not to call this function on a node with data in the
3908  * lookup map without removing it from the lookup map, first.
3909  *
3910  * Some current cases where this warning is not a concern are
3911  * when:
3912  *   - the node being removed is a comment node
3913  *   - the entire lookup map is getting destroyed soon after
3914  *     anyway.
3915  */
3916 static void
3917 g_key_file_remove_key_value_pair_node (GKeyFile      *key_file,
3918                                        GKeyFileGroup *group,
<a name="93" id="anc93"></a><span class="line-modified">3919                      GList         *pair_node)</span>
3920 {
3921 
3922   GKeyFileKeyValuePair *pair;
3923 
3924   pair = (GKeyFileKeyValuePair *) pair_node-&gt;data;
3925 
3926   group-&gt;key_value_pairs = g_list_remove_link (group-&gt;key_value_pairs, pair_node);
3927 
3928   g_warn_if_fail (pair-&gt;value != NULL);
3929 
3930   g_key_file_key_value_pair_free (pair);
3931 
3932   g_list_free_1 (pair_node);
3933 }
3934 
3935 static void
3936 g_key_file_remove_group_node (GKeyFile *key_file,
<a name="94" id="anc94"></a><span class="line-modified">3937             GList    *group_node)</span>
3938 {
3939   GKeyFileGroup *group;
3940   GList *tmp;
3941 
3942   group = (GKeyFileGroup *) group_node-&gt;data;
3943 
3944   if (group-&gt;name)
3945     g_hash_table_remove (key_file-&gt;group_hash, group-&gt;name);
3946 
3947   /* If the current group gets deleted make the current group the last
3948    * added group.
3949    */
3950   if (key_file-&gt;current_group == group)
3951     {
3952       /* groups should always contain at least the top comment group,
3953        * unless g_key_file_clear has been called
3954        */
3955       if (key_file-&gt;groups)
3956         key_file-&gt;current_group = (GKeyFileGroup *) key_file-&gt;groups-&gt;data;
3957       else
3958         key_file-&gt;current_group = NULL;
3959     }
3960 
3961   /* If the start group gets deleted make the start group the first
3962    * added group.
3963    */
3964   if (key_file-&gt;start_group == group)
3965     {
3966       tmp = g_list_last (key_file-&gt;groups);
3967       while (tmp != NULL)
<a name="95" id="anc95"></a><span class="line-modified">3968   {</span>
<span class="line-modified">3969     if (tmp != group_node &amp;&amp;</span>
<span class="line-modified">3970         ((GKeyFileGroup *) tmp-&gt;data)-&gt;name != NULL)</span>
<span class="line-modified">3971       break;</span>
3972 
<a name="96" id="anc96"></a><span class="line-modified">3973     tmp = tmp-&gt;prev;</span>
<span class="line-modified">3974   }</span>
3975 
3976       if (tmp)
3977         key_file-&gt;start_group = (GKeyFileGroup *) tmp-&gt;data;
3978       else
3979         key_file-&gt;start_group = NULL;
3980     }
3981 
3982   key_file-&gt;groups = g_list_remove_link (key_file-&gt;groups, group_node);
3983 
3984   tmp = group-&gt;key_value_pairs;
3985   while (tmp != NULL)
3986     {
3987       GList *pair_node;
3988 
3989       pair_node = tmp;
3990       tmp = tmp-&gt;next;
3991       g_key_file_remove_key_value_pair_node (key_file, group, pair_node);
3992     }
3993 
3994   g_warn_if_fail (group-&gt;key_value_pairs == NULL);
3995 
3996   if (group-&gt;comment)
3997     {
3998       g_key_file_key_value_pair_free (group-&gt;comment);
3999       group-&gt;comment = NULL;
4000     }
4001 
4002   if (group-&gt;lookup_map)
4003     {
4004       g_hash_table_destroy (group-&gt;lookup_map);
4005       group-&gt;lookup_map = NULL;
4006     }
4007 
4008   g_free ((gchar *) group-&gt;name);
4009   g_slice_free (GKeyFileGroup, group);
4010   g_list_free_1 (group_node);
4011 }
4012 
4013 /**
4014  * g_key_file_remove_group:
4015  * @key_file: a #GKeyFile
4016  * @group_name: a group name
4017  * @error: return location for a #GError or %NULL
4018  *
4019  * Removes the specified group, @group_name,
4020  * from the key file.
4021  *
4022  * Returns: %TRUE if the group was removed, %FALSE otherwise
4023  *
4024  * Since: 2.6
4025  **/
4026 gboolean
4027 g_key_file_remove_group (GKeyFile     *key_file,
<a name="97" id="anc97"></a><span class="line-modified">4028        const gchar  *group_name,</span>
<span class="line-modified">4029        GError      **error)</span>
4030 {
4031   GList *group_node;
4032 
4033   g_return_val_if_fail (key_file != NULL, FALSE);
4034   g_return_val_if_fail (group_name != NULL, FALSE);
4035 
4036   group_node = g_key_file_lookup_group_node (key_file, group_name);
4037 
4038   if (!group_node)
4039     {
4040       g_set_error (error, G_KEY_FILE_ERROR,
<a name="98" id="anc98"></a><span class="line-modified">4041        G_KEY_FILE_ERROR_GROUP_NOT_FOUND,</span>
<span class="line-modified">4042        _(&quot;Key file does not have group &#39;%s&#39;&quot;),</span>
<span class="line-modified">4043        group_name);</span>
4044       return FALSE;
4045     }
4046 
4047   g_key_file_remove_group_node (key_file, group_node);
4048 
4049   return TRUE;
4050 }
4051 
4052 static void
4053 g_key_file_add_key_value_pair (GKeyFile             *key_file,
4054                                GKeyFileGroup        *group,
4055                                GKeyFileKeyValuePair *pair)
4056 {
4057   g_hash_table_replace (group-&gt;lookup_map, pair-&gt;key, pair);
4058   group-&gt;key_value_pairs = g_list_prepend (group-&gt;key_value_pairs, pair);
4059 }
4060 
4061 static void
4062 g_key_file_add_key (GKeyFile      *key_file,
<a name="99" id="anc99"></a><span class="line-modified">4063         GKeyFileGroup *group,</span>
<span class="line-modified">4064         const gchar   *key,</span>
<span class="line-modified">4065         const gchar   *value)</span>
4066 {
4067   GKeyFileKeyValuePair *pair;
4068 
4069   pair = g_slice_new (GKeyFileKeyValuePair);
4070 #ifdef GSTREAMER_LITE
4071   if (pair == NULL) {
4072     return;
4073   }
4074 #endif // GSTREAMER_LITE
4075   pair-&gt;key = g_strdup (key);
4076   pair-&gt;value = g_strdup (value);
4077 
4078   g_key_file_add_key_value_pair (key_file, group, pair);
4079 }
4080 
4081 /**
4082  * g_key_file_remove_key:
4083  * @key_file: a #GKeyFile
4084  * @group_name: a group name
4085  * @key: a key name to remove
4086  * @error: return location for a #GError or %NULL
4087  *
4088  * Removes @key in @group_name from the key file.
4089  *
4090  * Returns: %TRUE if the key was removed, %FALSE otherwise
4091  *
4092  * Since: 2.6
4093  **/
4094 gboolean
4095 g_key_file_remove_key (GKeyFile     *key_file,
<a name="100" id="anc100"></a><span class="line-modified">4096            const gchar  *group_name,</span>
<span class="line-modified">4097            const gchar  *key,</span>
<span class="line-modified">4098            GError      **error)</span>
4099 {
4100   GKeyFileGroup *group;
4101   GKeyFileKeyValuePair *pair;
4102 
4103   g_return_val_if_fail (key_file != NULL, FALSE);
4104   g_return_val_if_fail (group_name != NULL, FALSE);
4105   g_return_val_if_fail (key != NULL, FALSE);
4106 
4107   pair = NULL;
4108 
4109   group = g_key_file_lookup_group (key_file, group_name);
4110   if (!group)
4111     {
4112       g_set_error (error, G_KEY_FILE_ERROR,
4113                    G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
4114                    _(&quot;Key file does not have group &#39;%s&#39;&quot;),
4115 #ifdef GSTREAMER_LITE
4116                    group_name ? group_name : &quot;(null)&quot;);
4117 #else // GSTREAMER_LITE
4118                    group_name);
4119 #endif // GSTREAMER_LITE
4120       return FALSE;
4121     }
4122 
4123   pair = g_key_file_lookup_key_value_pair (key_file, group, key);
4124 
4125   if (!pair)
4126     {
4127       set_not_found_key_error (group-&gt;name, key, error);
4128       return FALSE;
4129     }
4130 
4131   group-&gt;key_value_pairs = g_list_remove (group-&gt;key_value_pairs, pair);
4132   g_hash_table_remove (group-&gt;lookup_map, pair-&gt;key);
4133   g_key_file_key_value_pair_free (pair);
4134 
4135   return TRUE;
4136 }
4137 
4138 static GList *
4139 g_key_file_lookup_group_node (GKeyFile    *key_file,
<a name="101" id="anc101"></a><span class="line-modified">4140             const gchar *group_name)</span>
4141 {
4142   GKeyFileGroup *group;
4143   GList *tmp;
4144 
4145   for (tmp = key_file-&gt;groups; tmp != NULL; tmp = tmp-&gt;next)
4146     {
4147       group = (GKeyFileGroup *) tmp-&gt;data;
4148 
4149       if (group &amp;&amp; group-&gt;name &amp;&amp; strcmp (group-&gt;name, group_name) == 0)
4150         break;
4151     }
4152 
4153   return tmp;
4154 }
4155 
4156 static GKeyFileGroup *
4157 g_key_file_lookup_group (GKeyFile    *key_file,
<a name="102" id="anc102"></a><span class="line-modified">4158        const gchar *group_name)</span>
4159 {
4160   return (GKeyFileGroup *)g_hash_table_lookup (key_file-&gt;group_hash, group_name);
4161 }
4162 
4163 static GList *
4164 g_key_file_lookup_key_value_pair_node (GKeyFile       *key_file,
<a name="103" id="anc103"></a><span class="line-modified">4165                      GKeyFileGroup  *group,</span>
4166                                        const gchar    *key)
4167 {
4168   GList *key_node;
4169 
4170   for (key_node = group-&gt;key_value_pairs;
4171        key_node != NULL;
4172        key_node = key_node-&gt;next)
4173     {
4174       GKeyFileKeyValuePair *pair;
4175 
4176       pair = (GKeyFileKeyValuePair *) key_node-&gt;data;
4177 
4178       if (pair-&gt;key &amp;&amp; strcmp (pair-&gt;key, key) == 0)
4179         break;
4180     }
4181 
4182   return key_node;
4183 }
4184 
4185 static GKeyFileKeyValuePair *
4186 g_key_file_lookup_key_value_pair (GKeyFile      *key_file,
<a name="104" id="anc104"></a><span class="line-modified">4187           GKeyFileGroup *group,</span>
<span class="line-modified">4188           const gchar   *key)</span>
4189 {
4190   return (GKeyFileKeyValuePair *) g_hash_table_lookup (group-&gt;lookup_map, key);
4191 }
4192 
4193 /* Lines starting with # or consisting entirely of whitespace are merely
4194  * recorded, not parsed. This function assumes all leading whitespace
4195  * has been stripped.
4196  */
4197 static gboolean
4198 g_key_file_line_is_comment (const gchar *line)
4199 {
4200   return (*line == &#39;#&#39; || *line == &#39;\0&#39; || *line == &#39;\n&#39;);
4201 }
4202 
4203 static gboolean
4204 g_key_file_is_group_name (const gchar *name)
4205 {
4206   gchar *p, *q;
4207 
4208   if (name == NULL)
4209     return FALSE;
4210 
4211   p = q = (gchar *) name;
4212   while (*q &amp;&amp; *q != &#39;]&#39; &amp;&amp; *q != &#39;[&#39; &amp;&amp; !g_ascii_iscntrl (*q))
4213     q = g_utf8_find_next_char (q, NULL);
4214 
4215   if (*q != &#39;\0&#39; || q == p)
4216     return FALSE;
4217 
4218   return TRUE;
4219 }
4220 
4221 static gboolean
4222 g_key_file_is_key_name (const gchar *name)
4223 {
4224   gchar *p, *q;
4225 
4226   if (name == NULL)
4227     return FALSE;
4228 
4229   p = q = (gchar *) name;
4230   /* We accept a little more than the desktop entry spec says,
4231    * since gnome-vfs uses mime-types as keys in its cache.
4232    */
4233   while (*q &amp;&amp; *q != &#39;=&#39; &amp;&amp; *q != &#39;[&#39; &amp;&amp; *q != &#39;]&#39;)
4234     q = g_utf8_find_next_char (q, NULL);
4235 
4236   /* No empty keys, please */
4237   if (q == p)
4238     return FALSE;
4239 
4240   /* We accept spaces in the middle of keys to not break
4241    * existing apps, but we don&#39;t tolerate initial or final
4242    * spaces, which would lead to silent corruption when
4243    * rereading the file.
4244    */
4245   if (*p == &#39; &#39; || q[-1] == &#39; &#39;)
4246     return FALSE;
4247 
4248   if (*q == &#39;[&#39;)
4249     {
4250       q++;
4251       while (*q &amp;&amp; (g_unichar_isalnum (g_utf8_get_char_validated (q, -1)) || *q == &#39;-&#39; || *q == &#39;_&#39; || *q == &#39;.&#39; || *q == &#39;@&#39;))
4252         q = g_utf8_find_next_char (q, NULL);
4253 
4254       if (*q != &#39;]&#39;)
4255         return FALSE;
4256 
4257       q++;
4258     }
4259 
4260   if (*q != &#39;\0&#39;)
4261     return FALSE;
4262 
4263   return TRUE;
4264 }
4265 
4266 /* A group in a key file is made up of a starting &#39;[&#39; followed by one
4267  * or more letters making up the group name followed by &#39;]&#39;.
4268  */
4269 static gboolean
4270 g_key_file_line_is_group (const gchar *line)
4271 {
4272   gchar *p;
4273 
4274   p = (gchar *) line;
4275   if (*p != &#39;[&#39;)
4276     return FALSE;
4277 
4278   p++;
4279 
4280   while (*p &amp;&amp; *p != &#39;]&#39;)
4281     p = g_utf8_find_next_char (p, NULL);
4282 
4283   if (*p != &#39;]&#39;)
4284     return FALSE;
4285 
4286   /* silently accept whitespace after the ] */
4287   p = g_utf8_find_next_char (p, NULL);
4288   while (*p == &#39; &#39; || *p == &#39;\t&#39;)
4289     p = g_utf8_find_next_char (p, NULL);
4290 
4291   if (*p)
4292     return FALSE;
4293 
4294   return TRUE;
4295 }
4296 
4297 static gboolean
4298 g_key_file_line_is_key_value_pair (const gchar *line)
4299 {
4300   gchar *p;
4301 
4302   p = (gchar *) g_utf8_strchr (line, -1, &#39;=&#39;);
4303 
4304   if (!p)
4305     return FALSE;
4306 
4307   /* Key must be non-empty
4308    */
4309   if (*p == line[0])
4310     return FALSE;
4311 
4312   return TRUE;
4313 }
4314 
4315 static gchar *
4316 g_key_file_parse_value_as_string (GKeyFile     *key_file,
<a name="105" id="anc105"></a><span class="line-modified">4317           const gchar  *value,</span>
<span class="line-modified">4318           GSList      **pieces,</span>
<span class="line-modified">4319           GError      **error)</span>
4320 {
4321   gchar *string_value, *p, *q0, *q;
4322 
4323   string_value = g_new (gchar, strlen (value) + 1);
4324 
4325   p = (gchar *) value;
4326   q0 = q = string_value;
4327   while (*p)
4328     {
4329       if (*p == &#39;\\&#39;)
4330         {
4331           p++;
4332 
4333           switch (*p)
4334             {
4335             case &#39;s&#39;:
4336               *q = &#39; &#39;;
4337               break;
4338 
4339             case &#39;n&#39;:
4340               *q = &#39;\n&#39;;
4341               break;
4342 
4343             case &#39;t&#39;:
4344               *q = &#39;\t&#39;;
4345               break;
4346 
4347             case &#39;r&#39;:
4348               *q = &#39;\r&#39;;
4349               break;
4350 
4351             case &#39;\\&#39;:
4352               *q = &#39;\\&#39;;
4353               break;
4354 
<a name="106" id="anc106"></a><span class="line-modified">4355       case &#39;\0&#39;:</span>
<span class="line-modified">4356         g_set_error_literal (error, G_KEY_FILE_ERROR,</span>
4357                                    G_KEY_FILE_ERROR_INVALID_VALUE,
4358                                    _(&quot;Key file contains escape character &quot;
4359                                      &quot;at end of line&quot;));
<a name="107" id="anc107"></a><span class="line-modified">4360         break;</span>
4361 
4362             default:
<a name="108" id="anc108"></a><span class="line-modified">4363         if (pieces &amp;&amp; *p == key_file-&gt;list_separator)</span>
<span class="line-modified">4364     *q = key_file-&gt;list_separator;</span>
<span class="line-modified">4365         else</span>
<span class="line-modified">4366     {</span>
<span class="line-modified">4367       *q++ = &#39;\\&#39;;</span>
<span class="line-modified">4368       *q = *p;</span>
4369 
<a name="109" id="anc109"></a><span class="line-modified">4370       if (*error == NULL)</span>
<span class="line-modified">4371         {</span>
<span class="line-modified">4372           gchar sequence[3];</span>
4373 
<a name="110" id="anc110"></a><span class="line-modified">4374           sequence[0] = &#39;\\&#39;;</span>
<span class="line-modified">4375           sequence[1] = *p;</span>
<span class="line-modified">4376           sequence[2] = &#39;\0&#39;;</span>
4377 
<a name="111" id="anc111"></a><span class="line-modified">4378           g_set_error (error, G_KEY_FILE_ERROR,</span>
<span class="line-modified">4379            G_KEY_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">4380            _(&quot;Key file contains invalid escape &quot;</span>
<span class="line-modified">4381              &quot;sequence &#39;%s&#39;&quot;), sequence);</span>

4382         }
<a name="112" id="anc112"></a><span class="line-added">4383     }</span>
4384               break;
4385             }
4386         }
4387       else
<a name="113" id="anc113"></a><span class="line-modified">4388   {</span>
<span class="line-modified">4389     *q = *p;</span>
<span class="line-modified">4390     if (pieces &amp;&amp; (*p == key_file-&gt;list_separator))</span>
<span class="line-modified">4391       {</span>
<span class="line-modified">4392         *pieces = g_slist_prepend (*pieces, g_strndup (q0, q - q0));</span>
<span class="line-modified">4393         q0 = q + 1;</span>
<span class="line-modified">4394       }</span>
<span class="line-modified">4395   }</span>
4396 
4397       if (*p == &#39;\0&#39;)
<a name="114" id="anc114"></a><span class="line-modified">4398   break;</span>
4399 
4400       q++;
4401       p++;
4402     }
4403 
4404   *q = &#39;\0&#39;;
4405   if (pieces)
4406   {
4407     if (q0 &lt; q)
4408       *pieces = g_slist_prepend (*pieces, g_strndup (q0, q - q0));
4409     *pieces = g_slist_reverse (*pieces);
4410   }
4411 
4412   return string_value;
4413 }
4414 
4415 static gchar *
4416 g_key_file_parse_string_as_value (GKeyFile    *key_file,
<a name="115" id="anc115"></a><span class="line-modified">4417           const gchar *string,</span>
<span class="line-modified">4418           gboolean     escape_separator)</span>
4419 {
4420   gchar *value, *p, *q;
4421   gsize length;
4422   gboolean parsing_leading_space;
4423 
4424   length = strlen (string) + 1;
4425 
4426   /* Worst case would be that every character needs to be escaped.
4427    * In other words every character turns to two characters
4428    */
4429   value = g_new (gchar, 2 * length);
4430 
4431   p = (gchar *) string;
4432   q = value;
4433   parsing_leading_space = TRUE;
4434   while (p &lt; (string + length - 1))
4435     {
4436       gchar escaped_character[3] = { &#39;\\&#39;, 0, 0 };
4437 
4438       switch (*p)
4439         {
4440         case &#39; &#39;:
4441           if (parsing_leading_space)
4442             {
4443               escaped_character[1] = &#39;s&#39;;
4444               strcpy (q, escaped_character);
4445               q += 2;
4446             }
4447           else
4448             {
<a name="116" id="anc116"></a><span class="line-modified">4449         *q = *p;</span>
<span class="line-modified">4450         q++;</span>
4451             }
4452           break;
4453         case &#39;\t&#39;:
4454           if (parsing_leading_space)
4455             {
4456               escaped_character[1] = &#39;t&#39;;
4457               strcpy (q, escaped_character);
4458               q += 2;
4459             }
4460           else
4461             {
<a name="117" id="anc117"></a><span class="line-modified">4462         *q = *p;</span>
<span class="line-modified">4463         q++;</span>
4464             }
4465           break;
4466         case &#39;\n&#39;:
4467           escaped_character[1] = &#39;n&#39;;
4468           strcpy (q, escaped_character);
4469           q += 2;
4470           break;
4471         case &#39;\r&#39;:
4472           escaped_character[1] = &#39;r&#39;;
4473           strcpy (q, escaped_character);
4474           q += 2;
4475           break;
4476         case &#39;\\&#39;:
4477           escaped_character[1] = &#39;\\&#39;;
4478           strcpy (q, escaped_character);
4479           q += 2;
4480           parsing_leading_space = FALSE;
4481           break;
4482         default:
<a name="118" id="anc118"></a><span class="line-modified">4483     if (escape_separator &amp;&amp; *p == key_file-&gt;list_separator)</span>
<span class="line-modified">4484       {</span>
<span class="line-modified">4485         escaped_character[1] = key_file-&gt;list_separator;</span>
<span class="line-modified">4486         strcpy (q, escaped_character);</span>
<span class="line-modified">4487         q += 2;</span>
4488               parsing_leading_space = TRUE;
<a name="119" id="anc119"></a><span class="line-modified">4489       }</span>
<span class="line-modified">4490     else</span>
<span class="line-modified">4491       {</span>
<span class="line-modified">4492         *q = *p;</span>
<span class="line-modified">4493         q++;</span>
4494               parsing_leading_space = FALSE;
<a name="120" id="anc120"></a><span class="line-modified">4495       }</span>
4496           break;
4497         }
4498       p++;
4499     }
4500   *q = &#39;\0&#39;;
4501 
4502   return value;
4503 }
4504 
4505 static gint
4506 g_key_file_parse_value_as_integer (GKeyFile     *key_file,
<a name="121" id="anc121"></a><span class="line-modified">4507            const gchar  *value,</span>
<span class="line-modified">4508            GError      **error)</span>
4509 {
4510   gchar *eof_int;
4511   glong long_value;
4512   gint int_value;
4513   int errsv;
4514 
4515   errno = 0;
4516   long_value = strtol (value, &amp;eof_int, 10);
4517   errsv = errno;
4518 
4519   if (*value == &#39;\0&#39; || (*eof_int != &#39;\0&#39; &amp;&amp; !g_ascii_isspace(*eof_int)))
4520     {
4521       gchar *value_utf8 = g_utf8_make_valid (value, -1);
4522       g_set_error (error, G_KEY_FILE_ERROR,
<a name="122" id="anc122"></a><span class="line-modified">4523        G_KEY_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">4524        _(&quot;Value &#39;%s&#39; cannot be interpreted &quot;</span>
<span class="line-modified">4525          &quot;as a number.&quot;), value_utf8);</span>
4526       g_free (value_utf8);
4527 
4528       return 0;
4529     }
4530 
4531   int_value = long_value;
4532   if (int_value != long_value || errsv == ERANGE)
4533     {
4534       gchar *value_utf8 = g_utf8_make_valid (value, -1);
4535       g_set_error (error,
<a name="123" id="anc123"></a><span class="line-modified">4536        G_KEY_FILE_ERROR,</span>
<span class="line-modified">4537        G_KEY_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">4538        _(&quot;Integer value &#39;%s&#39; out of range&quot;),</span>
<span class="line-modified">4539        value_utf8);</span>
4540       g_free (value_utf8);
4541 
4542       return 0;
4543     }
4544 
4545   return int_value;
4546 }
4547 
4548 static gchar *
4549 g_key_file_parse_integer_as_value (GKeyFile *key_file,
<a name="124" id="anc124"></a><span class="line-modified">4550            gint      value)</span>
4551 
4552 {
4553   return g_strdup_printf (&quot;%d&quot;, value);
4554 }
4555 
4556 static gdouble
4557 g_key_file_parse_value_as_double  (GKeyFile     *key_file,
4558                                    const gchar  *value,
4559                                    GError      **error)
4560 {
4561   gchar *end_of_valid_d;
4562   gdouble double_value = 0;
4563 
4564   double_value = g_ascii_strtod (value, &amp;end_of_valid_d);
4565 
4566   if (*end_of_valid_d != &#39;\0&#39; || end_of_valid_d == value)
4567     {
4568       gchar *value_utf8 = g_utf8_make_valid (value, -1);
4569       g_set_error (error, G_KEY_FILE_ERROR,
<a name="125" id="anc125"></a><span class="line-modified">4570        G_KEY_FILE_ERROR_INVALID_VALUE,</span>
<span class="line-modified">4571        _(&quot;Value &#39;%s&#39; cannot be interpreted &quot;</span>
<span class="line-modified">4572          &quot;as a float number.&quot;),</span>
<span class="line-modified">4573        value_utf8);</span>
4574       g_free (value_utf8);
4575 
4576       double_value = 0;
4577     }
4578 
4579   return double_value;
4580 }
4581 
4582 static gint
4583 strcmp_sized (const gchar *s1, size_t len1, const gchar *s2)
4584 {
4585   size_t len2 = strlen (s2);
4586   return strncmp (s1, s2, MAX (len1, len2));
4587 }
4588 
4589 static gboolean
4590 g_key_file_parse_value_as_boolean (GKeyFile     *key_file,
<a name="126" id="anc126"></a><span class="line-modified">4591            const gchar  *value,</span>
<span class="line-modified">4592            GError      **error)</span>
4593 {
4594   gchar *value_utf8;
4595   gint i, length = 0;
4596 
4597   /* Count the number of non-whitespace characters */
4598   for (i = 0; value[i]; i++)
4599     if (!g_ascii_isspace (value[i]))
4600       length = i + 1;
4601 
4602   if (strcmp_sized (value, length, &quot;true&quot;) == 0 || strcmp_sized (value, length, &quot;1&quot;) == 0)
4603     return TRUE;
4604   else if (strcmp_sized (value, length, &quot;false&quot;) == 0 || strcmp_sized (value, length, &quot;0&quot;) == 0)
4605     return FALSE;
4606 
4607   value_utf8 = g_utf8_make_valid (value, -1);
4608   g_set_error (error, G_KEY_FILE_ERROR,
4609                G_KEY_FILE_ERROR_INVALID_VALUE,
4610                _(&quot;Value &#39;%s&#39; cannot be interpreted &quot;
<a name="127" id="anc127"></a><span class="line-modified">4611      &quot;as a boolean.&quot;), value_utf8);</span>
4612   g_free (value_utf8);
4613 
4614   return FALSE;
4615 }
4616 
4617 static gchar *
4618 g_key_file_parse_boolean_as_value (GKeyFile *key_file,
<a name="128" id="anc128"></a><span class="line-modified">4619            gboolean  value)</span>
4620 {
4621   if (value)
4622     return g_strdup (&quot;true&quot;);
4623   else
4624     return g_strdup (&quot;false&quot;);
4625 }
4626 
4627 static gchar *
4628 g_key_file_parse_value_as_comment (GKeyFile    *key_file,
<a name="129" id="anc129"></a><span class="line-modified">4629                                    const gchar *value,</span>
<span class="line-added">4630                                    gboolean     is_final_line)</span>
4631 {
4632   GString *string;
4633   gchar **lines;
4634   gsize i;
4635 
4636   string = g_string_sized_new (512);
4637 
4638   lines = g_strsplit (value, &quot;\n&quot;, 0);
4639 
4640   for (i = 0; lines[i] != NULL; i++)
4641     {
<a name="130" id="anc130"></a><span class="line-modified">4642       const gchar *line = lines[i];</span>
<span class="line-modified">4643 </span>
<span class="line-modified">4644       if (i != 0)</span>
<span class="line-modified">4645         g_string_append_c (string, &#39;\n&#39;);</span>
<span class="line-added">4646 </span>
<span class="line-added">4647       if (line[0] == &#39;#&#39;)</span>
<span class="line-added">4648         line++;</span>
<span class="line-added">4649       g_string_append (string, line);</span>
4650     }
4651   g_strfreev (lines);
4652 
<a name="131" id="anc131"></a><span class="line-added">4653   /* This function gets called once per line of a comment, but we don&#39;t want</span>
<span class="line-added">4654    * to add a trailing newline. */</span>
<span class="line-added">4655   if (!is_final_line)</span>
<span class="line-added">4656     g_string_append_c (string, &#39;\n&#39;);</span>
<span class="line-added">4657 </span>
4658   return g_string_free (string, FALSE);
4659 }
4660 
4661 static gchar *
4662 g_key_file_parse_comment_as_value (GKeyFile      *key_file,
4663                                    const gchar   *comment)
4664 {
4665   GString *string;
4666   gchar **lines;
4667   gsize i;
4668 
4669   string = g_string_sized_new (512);
4670 
4671   lines = g_strsplit (comment, &quot;\n&quot;, 0);
4672 
4673   for (i = 0; lines[i] != NULL; i++)
4674     g_string_append_printf (string, &quot;#%s%s&quot;, lines[i],
4675                             lines[i + 1] == NULL? &quot;&quot; : &quot;\n&quot;);
4676   g_strfreev (lines);
4677 
4678   return g_string_free (string, FALSE);
4679 }
4680 
4681 /**
4682  * g_key_file_save_to_file:
4683  * @key_file: a #GKeyFile
4684  * @filename: the name of the file to write to
4685  * @error: a pointer to a %NULL #GError, or %NULL
4686  *
4687  * Writes the contents of @key_file to @filename using
4688  * g_file_set_contents().
4689  *
4690  * This function can fail for any of the reasons that
4691  * g_file_set_contents() may fail.
4692  *
4693  * Returns: %TRUE if successful, else %FALSE with @error set
4694  *
4695  * Since: 2.40
4696  */
4697 gboolean
4698 g_key_file_save_to_file (GKeyFile     *key_file,
4699                          const gchar  *filename,
4700                          GError      **error)
4701 {
4702   gchar *contents;
4703   gboolean success;
4704   gsize length;
4705 
4706   g_return_val_if_fail (key_file != NULL, FALSE);
4707   g_return_val_if_fail (filename != NULL, FALSE);
4708   g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
4709 
4710   contents = g_key_file_to_data (key_file, &amp;length, NULL);
4711   g_assert (contents != NULL);
4712 
4713   success = g_file_set_contents (filename, contents, length, error);
4714   g_free (contents);
4715 
4716   return success;
4717 }
<a name="132" id="anc132"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="132" type="hidden" />
</body>
</html>