<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-base/gst-libs/gst/tag/mklangtables.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* GStreamer Language Tag Utility Functions
  2  * Copyright (C) 2009 Tim-Philipp MÃ¼ller &lt;tim centricular net&gt;
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public
 15  * License along with this library; if not, write to the
 16  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 
 20 /* mklangtables.c:
 21  * little program that reads iso_639.xml and outputs tables for us as fallback
 22  * for when iso-codes are not available or we fail to read the file for some
 23  * reason, and so we don&#39;t have to parse the xml file just to map codes.
 24  */
 25 
 26 #ifdef HAVE_CONFIG_H
 27 #include &quot;config.h&quot;
 28 #endif
 29 
 30 #include &lt;glib.h&gt;
 31 #include &lt;string.h&gt;
 32 
 33 #define ISO_639_XML_PATH ISO_CODES_PREFIX &quot;/share/xml/iso-codes/iso_639.xml&quot;
 34 
 35 typedef struct
 36 {
 37   gchar code_1[3];              /* de     */
 38   gchar code_2t[4];             /* deu    */
 39   gchar code_2b[4];             /* ger    */
 40   const gchar *name;            /* German */
 41   guint name_offset;            /* offset into string table */
 42 } IsoLang;
 43 
 44 static GArray *languages = NULL;
 45 
 46 static void
 47 dump_languages (void)
 48 {
 49   GString *names;
 50   const char *s;
 51   int i, num_escaped;
 52 
 53   g_assert (languages != NULL);
 54 
 55   names = g_string_new (&quot;&quot;);
 56 
<a name="1" id="anc1"></a><span class="line-modified"> 57   g_print (&quot;/* generated by mklangtables from iso-codes &quot; ISO_CODES_VERSION</span>
<span class="line-added"> 58       &quot; */\n&quot;);</span>
<span class="line-added"> 59   g_print (&quot;/* License: LGPL-2.1+ */\n&quot;);</span>
 60   g_print (&quot;\n&quot;);
 61   g_print (&quot;#include &lt;glib.h&gt;\n&quot;);
 62   g_print (&quot;\n&quot;);
 63   g_print (&quot;#define ISO_639_FLAG_2T  (1 &lt;&lt; 0)\n&quot;);
 64   g_print (&quot;#define ISO_639_FLAG_2B  (1 &lt;&lt; 1)\n&quot;);
 65   g_print (&quot;\n&quot;);
 66   g_print (&quot;/* *INDENT-OFF* */\n&quot;);
 67   g_print (&quot;\n&quot;);
 68   g_print (&quot;static const struct\n&quot;);
 69   g_print (&quot;{\n&quot;);
 70   g_print (&quot;  const gchar iso_639_1[3];\n&quot;);
 71   g_print (&quot;  const gchar iso_639_2[4];\n&quot;);
 72   g_print (&quot;  guint8 flags;\n&quot;);
 73   g_print (&quot;  guint16 name_offset;\n&quot;);
 74   g_print (&quot;} iso_639_codes[] = {\n&quot;);
 75 
 76   for (i = 0, num_escaped = 0; i &lt; languages-&gt;len; ++i) {
 77     IsoLang *lang = &amp;g_array_index (languages, IsoLang, i);
 78 
 79     /* For now just print those where there&#39;s both a ISO-639-1 and -2 code */
 80     if (lang-&gt;code_1[0] == &#39;\0&#39;)
 81       continue;
 82 
 83     /* save current offset */
 84     lang-&gt;name_offset = names-&gt;len;
 85 
 86     /* adjust for fact that \000 is 4 chars now but will take up only 1 later */
 87     lang-&gt;name_offset -= num_escaped * 3;
 88 
 89     /* append one char at a time, making sure to escape UTF-8 characters */
 90     for (s = lang-&gt;name; s != NULL &amp;&amp; *s != &#39;\0&#39;; ++s) {
 91       if (g_ascii_isprint (*s) &amp;&amp; *s != &#39;&quot;&#39; &amp;&amp; *s != &#39;\\&#39;) {
 92         g_string_append_c (names, *s);
 93       } else {
 94         g_string_append_printf (names, &quot;\\%03o&quot;, (unsigned char) *s);
 95         ++num_escaped;
 96       }
 97     }
 98     g_string_append (names, &quot;\\000&quot;);
 99     ++num_escaped;
100 
101     g_print (&quot;    /* %s */\n&quot;, lang-&gt;name);
102     if (strcmp (lang-&gt;code_2b, lang-&gt;code_2t) == 0) {
103       g_print (&quot;  { \&quot;%s\&quot;, \&quot;%s\&quot;, ISO_639_FLAG_2T | ISO_639_FLAG_2B, %u },\n&quot;,
104           lang-&gt;code_1, lang-&gt;code_2t, lang-&gt;name_offset);
105     } else {
106       /* if 639-2T and 639-2B differ, put 639-2T first */
107       g_print (&quot;  { \&quot;%s\&quot;, \&quot;%s\&quot;, ISO_639_FLAG_2T, %u },\n&quot;,
108           lang-&gt;code_1, lang-&gt;code_2t, lang-&gt;name_offset);
109       g_print (&quot;  { \&quot;%s\&quot;, \&quot;%s\&quot;, ISO_639_FLAG_2B, %u },\n&quot;,
110           lang-&gt;code_1, lang-&gt;code_2b, lang-&gt;name_offset);
111     }
112   }
113 
114   g_print (&quot;};\n&quot;);
115   g_print (&quot;\n&quot;);
116   g_print (&quot;static const gchar iso_639_names[] =\n&quot;);
117   s = names-&gt;str;
118   while (s != NULL &amp;&amp; *s != &#39;\0&#39;) {
119     gchar line[74], *lastesc;
120     guint left;
121 
122     left = strlen (s);
123     g_strlcpy (line, s, MIN (left, sizeof (line)));
124     s += sizeof (line) - 1;
125     /* avoid partial escaped codes at the end of a line */
126     if ((lastesc = strrchr (line, &#39;\\&#39;)) &amp;&amp; strlen (lastesc) &lt; 4) {
127       s -= strlen (lastesc);
128       *lastesc = &#39;\0&#39;;
129     }
130     g_print (&quot;  \&quot;%s\&quot;&quot;, line);
131     if (left &lt; 74)
132       break;
133     g_print (&quot;\n&quot;);
134   }
135   g_print (&quot;;\n&quot;);
136   g_print (&quot;\n&quot;);
137   g_print (&quot;/* *INDENT-ON* */\n&quot;);
138 
139   g_string_free (names, TRUE);
140 }
141 
142 static gboolean
143 copy_attribute (gchar * dest, guint dest_len, const gchar ** attr_names,
144     const gchar ** attr_vals, const gchar * needle)
145 {
146   while (attr_names != NULL &amp;&amp; *attr_names != NULL) {
147     if (strcmp (*attr_names, needle) == 0) {
148       g_strlcpy (dest, *attr_vals, dest_len);
149       return TRUE;
150     }
151     ++attr_names;
152     ++attr_vals;
153   }
154   dest[0] = &#39;\0&#39;;
155   return FALSE;
156 }
157 
158 static void
159 xml_start_element (GMarkupParseContext * ctx, const gchar * element_name,
160     const gchar ** attr_names, const gchar ** attr_vals,
161     gpointer user_data, GError ** error)
162 {
163   gchar name[256];
164   IsoLang lang;
165 
166   if (strcmp (element_name, &quot;iso_639_entry&quot;) != 0)
167     return;
168 
169   copy_attribute (lang.code_1, 3, attr_names, attr_vals, &quot;iso_639_1_code&quot;);
170   copy_attribute (lang.code_2t, 4, attr_names, attr_vals, &quot;iso_639_2T_code&quot;);
171   copy_attribute (lang.code_2b, 4, attr_names, attr_vals, &quot;iso_639_2B_code&quot;);
172 
173   copy_attribute (name, sizeof (name), attr_names, attr_vals, &quot;name&quot;);
174   lang.name = g_intern_string (name);
175 
176   g_array_append_val (languages, lang);
177 }
178 
179 static void
180 parse_iso_639_xml (const gchar * data, gsize len)
181 {
182   GMarkupParser xml_parser = { xml_start_element, NULL, NULL, NULL, NULL };
183   GMarkupParseContext *ctx;
184   GError *err = NULL;
185 
186   g_return_if_fail (g_utf8_validate (data, len, NULL));
187 
188   ctx = g_markup_parse_context_new (&amp;xml_parser, 0, NULL, NULL);
189   if (!g_markup_parse_context_parse (ctx, data, len, &amp;err))
190     g_error (&quot;Parsing failed: %s&quot;, err-&gt;message);
191 
192   g_markup_parse_context_free (ctx);
193 }
194 
195 static gint
196 languages_sort_func (IsoLang * l1, IsoLang * l2)
197 {
198   if (l1 == l2)
199     return 0;
200 
201   if (l1-&gt;code_1[0] == &#39;\0&#39; &amp;&amp; l2-&gt;code_1[0] != &#39;\0&#39;)
202     return -1;
203 
204   return strcmp (l1-&gt;code_1, l2-&gt;code_1);
205 }
206 
207 int
208 main (int argc, char **argv)
209 {
210   GMappedFile *f;
211   gchar *xml_data;
212   gsize xml_len;
213 
214   f = g_mapped_file_new (ISO_639_XML_PATH, FALSE, NULL);
215   if (f != NULL) {
216     xml_data = (gchar *) g_mapped_file_get_contents (f);
217     xml_len = g_mapped_file_get_length (f);
218   } else {
219     GError *err = NULL;
220 
221     if (!g_file_get_contents (ISO_639_XML_PATH, &amp;xml_data, &amp;xml_len, &amp;err))
222       g_error (&quot;Could not read %s: %s&quot;, ISO_639_XML_PATH, err-&gt;message);
223   }
224 
225   languages = g_array_new (FALSE, TRUE, sizeof (IsoLang));
226 
227   parse_iso_639_xml (xml_data, xml_len);
228 
229   g_array_sort (languages, (GCompareFunc) languages_sort_func);
230 
231   dump_languages ();
232 
233   g_array_free (languages, TRUE);
234 
235   if (f != NULL)
236     g_mapped_file_unref (f);
237   else
238     g_free (xml_data);
239 
240   return 0;
241 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>