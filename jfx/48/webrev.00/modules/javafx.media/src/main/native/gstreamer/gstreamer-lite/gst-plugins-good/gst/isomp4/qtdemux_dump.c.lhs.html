<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.media/src/main/native/gstreamer/gstreamer-lite/gst-plugins-good/gst/isomp4/qtdemux_dump.c</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /* GStreamer
   2  * Copyright (C) &lt;1999&gt; Erik Walthinsen &lt;omega@cse.ogi.edu&gt;
   3  * Copyright (C) 2009 Tim-Philipp MÃ¼ller &lt;tim centricular net&gt;
   4  * Copyright (C) &lt;2009&gt; STEricsson &lt;benjamin.gaignard@stericsson.com&gt;
   5  *
   6  * This library is free software; you can redistribute it and/or
   7  * modify it under the terms of the GNU Library General Public
   8  * License as published by the Free Software Foundation; either
   9  * version 2 of the License, or (at your option) any later version.
  10  *
  11  * This library is distributed in the hope that it will be useful,
  12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  * Library General Public License for more details.
  15  *
  16  * You should have received a copy of the GNU Library General Public
  17  * License along with this library; if not, write to the
  18  * Free Software Foundation, Inc., 51 Franklin St, Fifth Floor,
  19  * Boston, MA 02110-1301, USA.
  20  */
  21 
  22 #include &quot;qtdemux_debug.h&quot;
  23 #include &quot;qtdemux_types.h&quot;
  24 #include &quot;qtdemux_dump.h&quot;
  25 #include &quot;fourcc.h&quot;
  26 
  27 #include &quot;qtatomparser.h&quot;
  28 
  29 #include &lt;string.h&gt;
  30 
  31 #define GST_CAT_DEFAULT qtdemux_debug
  32 
  33 #define GET_UINT8(data)   gst_byte_reader_get_uint8_unchecked(data)
  34 #define GET_UINT16(data)  gst_byte_reader_get_uint16_be_unchecked(data)
  35 #define GET_UINT32(data)  gst_byte_reader_get_uint32_be_unchecked(data)
  36 #define GET_UINT64(data)  gst_byte_reader_get_uint64_be_unchecked(data)
  37 #define GET_FP32(data)   (gst_byte_reader_get_uint32_be_unchecked(data)/65536.0)
  38 #define GET_FP16(data)   (gst_byte_reader_get_uint16_be_unchecked(data)/256.0)
  39 #define GET_FOURCC(data)  qt_atom_parser_get_fourcc_unchecked(data)
  40 
  41 gboolean
  42 qtdemux_dump_mvhd (GstQTDemux * qtdemux, GstByteReader * data, int depth)
  43 {
  44   guint32 version = 0;
  45 
  46   if (!qt_atom_parser_has_remaining (data, 100))
  47     return FALSE;
  48 
  49   version = GET_UINT32 (data);
  50   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, version);
  51 
  52   version = version &gt;&gt; 24;
  53   if (version == 0) {
  54     GST_LOG (&quot;%*s  creation time: %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
  55     GST_LOG (&quot;%*s  modify time:   %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
  56     GST_LOG (&quot;%*s  time scale:    1/%u sec&quot;, depth, &quot;&quot;, GET_UINT32 (data));
  57     GST_LOG (&quot;%*s  duration:      %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
  58   } else if (version == 1) {
  59     GST_LOG (&quot;%*s  creation time: %&quot; G_GUINT64_FORMAT,
  60         depth, &quot;&quot;, GET_UINT64 (data));
  61     GST_LOG (&quot;%*s  modify time:   %&quot; G_GUINT64_FORMAT,
  62         depth, &quot;&quot;, GET_UINT64 (data));
  63     GST_LOG (&quot;%*s  time scale:    1/%u sec&quot;, depth, &quot;&quot;, GET_UINT32 (data));
  64     GST_LOG (&quot;%*s  duration:      %&quot; G_GUINT64_FORMAT,
  65         depth, &quot;&quot;, GET_UINT64 (data));
  66   } else
  67     return FALSE;
  68 
  69   GST_LOG (&quot;%*s  pref. rate:    %g&quot;, depth, &quot;&quot;, GET_FP32 (data));
  70   GST_LOG (&quot;%*s  pref. volume:  %g&quot;, depth, &quot;&quot;, GET_FP16 (data));
  71   gst_byte_reader_skip_unchecked (data, 46);
  72   GST_LOG (&quot;%*s  preview time:  %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
  73   GST_LOG (&quot;%*s  preview dur.:  %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
  74   GST_LOG (&quot;%*s  poster time:   %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
  75   GST_LOG (&quot;%*s  select time:   %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
  76   GST_LOG (&quot;%*s  select dur.:   %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
  77   GST_LOG (&quot;%*s  current time:  %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
  78   GST_LOG (&quot;%*s  next track ID: %d&quot;, depth, &quot;&quot;, GET_UINT32 (data));
  79   return TRUE;
  80 }
  81 
  82 gboolean
  83 qtdemux_dump_tkhd (GstQTDemux * qtdemux, GstByteReader * data, int depth)
  84 {
  85   guint64 duration, ctime, mtime;
  86   guint32 version = 0, track_id = 0, iwidth = 0, iheight = 0;
  87   guint16 layer = 0, alt_group = 0, ivol = 0;
  88   guint value_size;
  89 
  90   if (!gst_byte_reader_get_uint32_be (data, &amp;version))
  91     return FALSE;
  92 
  93   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, version);
  94 
  95   value_size = ((version &gt;&gt; 24) == 1) ? sizeof (guint64) : sizeof (guint32);
  96 
  97   if (qt_atom_parser_get_offset (data, value_size, &amp;ctime) &amp;&amp;
  98       qt_atom_parser_get_offset (data, value_size, &amp;mtime) &amp;&amp;
  99       gst_byte_reader_get_uint32_be (data, &amp;track_id) &amp;&amp;
 100       gst_byte_reader_skip (data, 4) &amp;&amp;
 101       qt_atom_parser_get_offset (data, value_size, &amp;duration) &amp;&amp;
 102       gst_byte_reader_skip (data, 4) &amp;&amp;
 103       gst_byte_reader_get_uint16_be (data, &amp;layer) &amp;&amp;
 104       gst_byte_reader_get_uint16_be (data, &amp;alt_group) &amp;&amp;
 105       gst_byte_reader_skip (data, 4) &amp;&amp;
 106       gst_byte_reader_get_uint16_be (data, &amp;ivol) &amp;&amp;
 107       gst_byte_reader_skip (data, 2 + (9 * 4)) &amp;&amp;
 108       gst_byte_reader_get_uint32_be (data, &amp;iwidth) &amp;&amp;
 109       gst_byte_reader_get_uint32_be (data, &amp;iheight)) {
 110     GST_LOG (&quot;%*s  creation time: %&quot; G_GUINT64_FORMAT, depth, &quot;&quot;, ctime);
 111     GST_LOG (&quot;%*s  modify time:   %&quot; G_GUINT64_FORMAT, depth, &quot;&quot;, mtime);
 112     GST_LOG (&quot;%*s  track ID:      %u&quot;, depth, &quot;&quot;, track_id);
 113     GST_LOG (&quot;%*s  duration:      %&quot; G_GUINT64_FORMAT, depth, &quot;&quot;, duration);
 114     GST_LOG (&quot;%*s  layer:         %u&quot;, depth, &quot;&quot;, layer);
 115     GST_LOG (&quot;%*s  alt group:     %u&quot;, depth, &quot;&quot;, alt_group);
 116     GST_LOG (&quot;%*s  volume:        %g&quot;, depth, &quot;&quot;, ivol / 256.0);
 117     GST_LOG (&quot;%*s  track width:   %g&quot;, depth, &quot;&quot;, iwidth / 65536.0);
 118     GST_LOG (&quot;%*s  track height:  %g&quot;, depth, &quot;&quot;, iheight / 65536.0);
 119     return TRUE;
 120   }
 121 
 122   return FALSE;
 123 }
 124 
 125 gboolean
 126 qtdemux_dump_elst (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 127 {
 128   guint32 ver_flags = 0, num_entries = 0, i;
 129 
 130   if (!gst_byte_reader_get_uint32_be (data, &amp;ver_flags) ||
 131       !gst_byte_reader_get_uint32_be (data, &amp;num_entries))
 132     return FALSE;
 133 
 134   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, ver_flags);
 135   GST_LOG (&quot;%*s  n entries:     %d&quot;, depth, &quot;&quot;, num_entries);
 136 
 137   if (!qt_atom_parser_has_chunks (data, num_entries, 4 + 4 + 4))
 138     return FALSE;
 139 
 140   for (i = 0; i &lt; num_entries; i++) {
 141     GST_LOG (&quot;%*s    track dur:     %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 142     GST_LOG (&quot;%*s    media time:    %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 143     GST_LOG (&quot;%*s    media rate:    %g&quot;, depth, &quot;&quot;, GET_FP32 (data));
 144   }
 145   return TRUE;
 146 }
 147 
 148 gboolean
 149 qtdemux_dump_mdhd (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 150 {
 151   guint32 version = 0;
 152   guint64 duration, ctime, mtime;
 153   guint32 time_scale = 0;
 154   guint16 language = 0, quality = 0;
 155   guint value_size;
 156 
 157   if (!gst_byte_reader_get_uint32_be (data, &amp;version))
 158     return FALSE;
 159 
 160   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, version);
 161 
 162   value_size = ((version &gt;&gt; 24) == 1) ? sizeof (guint64) : sizeof (guint32);
 163 
 164   if (qt_atom_parser_get_offset (data, value_size, &amp;ctime) &amp;&amp;
 165       qt_atom_parser_get_offset (data, value_size, &amp;mtime) &amp;&amp;
 166       gst_byte_reader_get_uint32_be (data, &amp;time_scale) &amp;&amp;
 167       qt_atom_parser_get_offset (data, value_size, &amp;duration) &amp;&amp;
 168       gst_byte_reader_get_uint16_be (data, &amp;language) &amp;&amp;
 169       gst_byte_reader_get_uint16_be (data, &amp;quality)) {
 170     GST_LOG (&quot;%*s  creation time: %&quot; G_GUINT64_FORMAT, depth, &quot;&quot;, ctime);
 171     GST_LOG (&quot;%*s  modify time:   %&quot; G_GUINT64_FORMAT, depth, &quot;&quot;, mtime);
 172     GST_LOG (&quot;%*s  time scale:    1/%u sec&quot;, depth, &quot;&quot;, time_scale);
 173     GST_LOG (&quot;%*s  duration:      %&quot; G_GUINT64_FORMAT, depth, &quot;&quot;, duration);
 174     GST_LOG (&quot;%*s  language:      %u&quot;, depth, &quot;&quot;, language);
 175     GST_LOG (&quot;%*s  quality:       %u&quot;, depth, &quot;&quot;, quality);
 176     return TRUE;
 177   }
 178 
 179   return FALSE;
 180 }
 181 
 182 gboolean
 183 qtdemux_dump_hdlr (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 184 {
 185   guint32 version, type, subtype, manufacturer;
 186   const gchar *name;
 187 
 188   if (!qt_atom_parser_has_remaining (data, 4 + 4 + 4 + 4 + 4 + 4))
 189     return FALSE;
 190 
 191   version = GET_UINT32 (data);
 192   type = GET_FOURCC (data);
 193   subtype = GET_FOURCC (data);
 194   manufacturer = GET_FOURCC (data);
 195 
 196   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, version);
 197   GST_LOG (&quot;%*s  type:          %&quot; GST_FOURCC_FORMAT, depth, &quot;&quot;,
 198       GST_FOURCC_ARGS (type));
 199   GST_LOG (&quot;%*s  subtype:       %&quot; GST_FOURCC_FORMAT, depth, &quot;&quot;,
 200       GST_FOURCC_ARGS (subtype));
 201   GST_LOG (&quot;%*s  manufacturer:  %&quot; GST_FOURCC_FORMAT, depth, &quot;&quot;,
 202       GST_FOURCC_ARGS (manufacturer));
 203   GST_LOG (&quot;%*s  flags:         %08x&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 204   GST_LOG (&quot;%*s  flags mask:    %08x&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 205 
 206   /* quicktime uses pascal string, mp4 zero-terminated string */
 207   if (gst_byte_reader_peek_string (data, &amp;name)) {
 208     GST_LOG (&quot;%*s  name:          %s&quot;, depth, &quot;&quot;, name);
 209   } else {
 210     gchar buf[256];
 211     guint8 len;
 212 
 213     if (gst_byte_reader_get_uint8 (data, &amp;len)
 214         &amp;&amp; qt_atom_parser_has_remaining (data, len)) {
 215       memcpy (buf, gst_byte_reader_peek_data_unchecked (data), len);
 216       buf[len] = &#39;\0&#39;;
 217       GST_LOG (&quot;%*s  name:          %s&quot;, depth, &quot;&quot;, buf);
 218     }
 219   }
 220   return TRUE;
 221 }
 222 
 223 gboolean
 224 qtdemux_dump_vmhd (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 225 {
 226   if (!qt_atom_parser_has_remaining (data, 4 + 4))
 227     return FALSE;
 228 
 229   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 230   GST_LOG (&quot;%*s  mode/color:    %08x&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 231   return TRUE;
 232 }
 233 
 234 gboolean
 235 qtdemux_dump_dref (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 236 {
 237   guint32 ver_flags = 0, num_entries = 0, i;
 238 
 239   if (!gst_byte_reader_get_uint32_be (data, &amp;ver_flags) ||
 240       !gst_byte_reader_get_uint32_be (data, &amp;num_entries))
 241     return FALSE;
 242 
 243   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, ver_flags);
 244   GST_LOG (&quot;%*s  n entries:     %u&quot;, depth, &quot;&quot;, num_entries);
 245   for (i = 0; i &lt; num_entries; i++) {
 246     guint32 size = 0, fourcc;
 247 
 248     if (!gst_byte_reader_get_uint32_be (data, &amp;size) ||
 249         !qt_atom_parser_get_fourcc (data, &amp;fourcc) || size &lt; 8 ||
 250         !gst_byte_reader_skip (data, size - 8))
 251       return FALSE;
 252 
 253     GST_LOG (&quot;%*s    size:          %u&quot;, depth, &quot;&quot;, size);
 254     GST_LOG (&quot;%*s    type:          %&quot; GST_FOURCC_FORMAT, depth, &quot;&quot;,
 255         GST_FOURCC_ARGS (fourcc));
 256   }
 257   return TRUE;
 258 }
 259 
 260 static gboolean
 261 qtdemux_dump_stsd_avc1 (GstQTDemux * qtdemux, GstByteReader * data, guint size,
 262     int depth)
 263 {
 264   guint32 fourcc;
 265 
 266   /* Size of avc1 = 78 bytes */
 267   if (size &lt; (6 + 2 + 4 + 4 + 4 + 4 + 2 + 2 + 4 + 4 + 4 + 2 + 1 + 31 + 2 + 2))
 268     return FALSE;
 269 
 270   gst_byte_reader_skip_unchecked (data, 6);
 271   GST_LOG_OBJECT (qtdemux, &quot;%*s    data reference:%d&quot;, depth, &quot;&quot;,
 272       GET_UINT16 (data));
 273   GST_LOG_OBJECT (qtdemux, &quot;%*s    version/rev.:  %08x&quot;, depth, &quot;&quot;,
 274       GET_UINT32 (data));
 275   fourcc = GET_FOURCC (data);
 276   GST_LOG_OBJECT (qtdemux, &quot;%*s    vendor:        %&quot; GST_FOURCC_FORMAT, depth,
 277       &quot;&quot;, GST_FOURCC_ARGS (fourcc));
 278   GST_LOG_OBJECT (qtdemux, &quot;%*s    temporal qual: %u&quot;, depth, &quot;&quot;,
 279       GET_UINT32 (data));
 280   GST_LOG_OBJECT (qtdemux, &quot;%*s    spatial qual:  %u&quot;, depth, &quot;&quot;,
 281       GET_UINT32 (data));
 282   GST_LOG_OBJECT (qtdemux, &quot;%*s    width:         %u&quot;, depth, &quot;&quot;,
 283       GET_UINT16 (data));
 284   GST_LOG_OBJECT (qtdemux, &quot;%*s    height:        %u&quot;, depth, &quot;&quot;,
 285       GET_UINT16 (data));
 286   GST_LOG_OBJECT (qtdemux, &quot;%*s    horiz. resol:  %g&quot;, depth, &quot;&quot;,
 287       GET_FP32 (data));
 288   GST_LOG_OBJECT (qtdemux, &quot;%*s    vert. resol.:  %g&quot;, depth, &quot;&quot;,
 289       GET_FP32 (data));
 290   GST_LOG_OBJECT (qtdemux, &quot;%*s    data size:     %u&quot;, depth, &quot;&quot;,
 291       GET_UINT32 (data));
 292   GST_LOG_OBJECT (qtdemux, &quot;%*s    frame count:   %u&quot;, depth, &quot;&quot;,
 293       GET_UINT16 (data));
 294   /* something is not right with this, it&#39;s supposed to be a string but it&#39;s
 295    * not apparently, so just skip this for now */
 296   gst_byte_reader_skip_unchecked (data, 1 + 31);
 297   GST_LOG_OBJECT (qtdemux, &quot;%*s    compressor:    (skipped)&quot;, depth, &quot;&quot;);
 298   GST_LOG_OBJECT (qtdemux, &quot;%*s    depth:         %u&quot;, depth, &quot;&quot;,
 299       GET_UINT16 (data));
 300   GST_LOG_OBJECT (qtdemux, &quot;%*s    color table ID:%u&quot;, depth, &quot;&quot;,
 301       GET_UINT16 (data));
 302 
 303   return TRUE;
 304 }
 305 
<a name="1" id="anc1"></a>












































 306 gboolean
 307 qtdemux_dump_stsd (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 308 {
 309   guint32 ver_flags = 0, num_entries = 0, i;
 310 
 311   if (!gst_byte_reader_get_uint32_be (data, &amp;ver_flags) ||
 312       !gst_byte_reader_get_uint32_be (data, &amp;num_entries))
 313     return FALSE;
 314 
 315   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, ver_flags);
 316   GST_LOG (&quot;%*s  n entries:     %d&quot;, depth, &quot;&quot;, num_entries);
 317 
 318   for (i = 0; i &lt; num_entries; i++) {
 319     GstByteReader sub;
 320     guint32 size, remain;
 321     guint32 fourcc;
 322 
 323     if (!gst_byte_reader_get_uint32_be (data, &amp;size) ||
 324         !qt_atom_parser_get_fourcc (data, &amp;fourcc))
 325       return FALSE;
 326 
 327     GST_LOG_OBJECT (qtdemux, &quot;%*s    size:          %u&quot;, depth, &quot;&quot;, size);
 328     GST_LOG_OBJECT (qtdemux, &quot;%*s    type:          %&quot; GST_FOURCC_FORMAT, depth,
 329         &quot;&quot;, GST_FOURCC_ARGS (fourcc));
 330 
 331     remain = gst_byte_reader_get_remaining (data);
 332     /* Size includes the 8 bytes we just read: len &amp; fourcc, then 8 bytes
 333      * version, flags, entries_count */
 334     if (size &gt; remain + 8) {
 335       GST_LOG_OBJECT (qtdemux,
 336           &quot;Not enough data left for this atom (have %u need %u)&quot;, remain, size);
 337       return FALSE;
 338     }
 339 
 340     qt_atom_parser_peek_sub (data, 0, size, &amp;sub);
 341     switch (fourcc) {
 342       case FOURCC_avc1:
 343         if (!qtdemux_dump_stsd_avc1 (qtdemux, &amp;sub, size, depth + 1))
 344           return FALSE;
 345         break;
 346       case FOURCC_fLaC:
 347         /* will be dumped by node_dump_foreach */
 348         break;
 349       case FOURCC_mp4s:
 350         if (!gst_byte_reader_get_uint32_be (&amp;sub, &amp;ver_flags) ||
 351             !gst_byte_reader_get_uint32_be (&amp;sub, &amp;num_entries))
 352           return FALSE;
 353         if (!qtdemux_dump_unknown (qtdemux, &amp;sub, depth + 1))
 354           return FALSE;
 355         break;
<a name="2" id="anc2"></a>



 356       default:
 357         /* Unknown stsd data, dump the bytes */
 358         if (!qtdemux_dump_unknown (qtdemux, &amp;sub, depth + 1))
 359           return FALSE;
 360         break;
 361     }
 362 
 363     if (!gst_byte_reader_skip (data, size - (4 + 4)))
 364       return FALSE;
 365   }
 366   return TRUE;
 367 }
 368 
 369 gboolean
 370 qtdemux_dump_stts (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 371 {
 372   guint32 ver_flags = 0, num_entries = 0, i;
 373 
 374   if (!gst_byte_reader_get_uint32_be (data, &amp;ver_flags) ||
 375       !gst_byte_reader_get_uint32_be (data, &amp;num_entries))
 376     return FALSE;
 377 
 378   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, ver_flags);
 379   GST_LOG (&quot;%*s  n entries:     %d&quot;, depth, &quot;&quot;, num_entries);
 380 
 381   if (!qt_atom_parser_has_chunks (data, num_entries, 4 + 4))
 382     return FALSE;
 383 
 384   for (i = 0; i &lt; num_entries; i++) {
 385     GST_LOG (&quot;%*s    count:         %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 386     GST_LOG (&quot;%*s    duration:      %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 387   }
 388   return TRUE;
 389 }
 390 
 391 gboolean
 392 qtdemux_dump_stps (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 393 {
 394   guint32 ver_flags = 0, num_entries = 0, i;
 395 
 396   if (!gst_byte_reader_get_uint32_be (data, &amp;ver_flags) ||
 397       !gst_byte_reader_get_uint32_be (data, &amp;num_entries))
 398     return FALSE;
 399 
 400   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, ver_flags);
 401   GST_LOG (&quot;%*s  n entries:     %d&quot;, depth, &quot;&quot;, num_entries);
 402 
 403   if (!qt_atom_parser_has_chunks (data, num_entries, 4))
 404     return FALSE;
 405 
 406   for (i = 0; i &lt; num_entries; i++) {
 407     GST_LOG (&quot;%*s    sample:        %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 408   }
 409   return TRUE;
 410 }
 411 
 412 gboolean
 413 qtdemux_dump_stss (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 414 {
 415   guint32 ver_flags = 0, num_entries = 0, i;
 416 
 417   if (!gst_byte_reader_get_uint32_be (data, &amp;ver_flags) ||
 418       !gst_byte_reader_get_uint32_be (data, &amp;num_entries))
 419     return FALSE;
 420 
 421   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, ver_flags);
 422   GST_LOG (&quot;%*s  n entries:     %d&quot;, depth, &quot;&quot;, num_entries);
 423 
 424   if (!qt_atom_parser_has_chunks (data, num_entries, 4))
 425     return FALSE;
 426 
 427   for (i = 0; i &lt; num_entries; i++) {
 428     GST_LOG (&quot;%*s    sample:        %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 429   }
 430   return TRUE;
 431 }
 432 
 433 gboolean
 434 qtdemux_dump_stsc (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 435 {
 436   guint32 ver_flags = 0, num_entries = 0, i;
 437 
 438   if (!gst_byte_reader_get_uint32_be (data, &amp;ver_flags) ||
 439       !gst_byte_reader_get_uint32_be (data, &amp;num_entries))
 440     return FALSE;
 441 
 442   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, ver_flags);
 443   GST_LOG (&quot;%*s  n entries:     %d&quot;, depth, &quot;&quot;, num_entries);
 444 
 445   if (!qt_atom_parser_has_chunks (data, num_entries, 4 + 4 + 4))
 446     return FALSE;
 447 
 448   for (i = 0; i &lt; num_entries; i++) {
 449     GST_LOG (&quot;%*s    first chunk:   %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 450     GST_LOG (&quot;%*s    sample per ch: %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 451     GST_LOG (&quot;%*s    sample desc id:%08x&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 452   }
 453   return TRUE;
 454 }
 455 
 456 gboolean
 457 qtdemux_dump_stsz (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 458 {
 459   guint32 ver_flags = 0, sample_size = 0, num_entries = 0, i;
 460 
 461   if (!gst_byte_reader_get_uint32_be (data, &amp;ver_flags) ||
 462       !gst_byte_reader_get_uint32_be (data, &amp;sample_size))
 463     return FALSE;
 464 
 465   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, ver_flags);
 466   GST_LOG (&quot;%*s  sample size:   %d&quot;, depth, &quot;&quot;, sample_size);
 467 
 468   if (sample_size == 0) {
 469     if (!gst_byte_reader_get_uint32_be (data, &amp;num_entries))
 470       return FALSE;
 471 
 472     GST_LOG (&quot;%*s  n entries:     %d&quot;, depth, &quot;&quot;, num_entries);
 473     if (!qt_atom_parser_has_chunks (data, num_entries, 4))
 474       return FALSE;
 475     for (i = 0; i &lt; num_entries; i++) {
 476       GST_TRACE (&quot;%*s    sample size:   %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 477     }
 478   }
 479   return TRUE;
 480 }
 481 
 482 gboolean
 483 qtdemux_dump_stco (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 484 {
 485   guint32 ver_flags = 0, num_entries = 0, i;
 486 
 487   if (!gst_byte_reader_get_uint32_be (data, &amp;ver_flags) ||
 488       !gst_byte_reader_get_uint32_be (data, &amp;num_entries))
 489     return FALSE;
 490 
 491   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, ver_flags);
 492   GST_LOG (&quot;%*s  n entries:     %d&quot;, depth, &quot;&quot;, num_entries);
 493 
 494   if (!qt_atom_parser_has_chunks (data, num_entries, 4))
 495     return FALSE;
 496 
 497   for (i = 0; i &lt; num_entries; i++) {
 498     GST_LOG (&quot;%*s    chunk offset:  %u&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 499   }
 500   return TRUE;
 501 }
 502 
 503 gboolean
 504 qtdemux_dump_ctts (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 505 {
 506   guint32 ver_flags = 0, num_entries = 0, i, count;
 507   gint32 offset;
 508 
 509 
 510   if (!gst_byte_reader_get_uint32_be (data, &amp;ver_flags) ||
 511       !gst_byte_reader_get_uint32_be (data, &amp;num_entries))
 512     return FALSE;
 513 
 514   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, ver_flags);
 515   GST_LOG (&quot;%*s  n entries:     %u&quot;, depth, &quot;&quot;, num_entries);
 516 
 517   if (!qt_atom_parser_has_chunks (data, num_entries, 4 + 4))
 518     return FALSE;
 519 
 520   for (i = 0; i &lt; num_entries; i++) {
 521     count = GET_UINT32 (data);
 522     offset = GET_UINT32 (data);
 523     GST_LOG (&quot;%*s    sample count :%8d offset: %8d&quot;, depth, &quot;&quot;, count, offset);
 524   }
 525   return TRUE;
 526 }
 527 
 528 gboolean
 529 qtdemux_dump_cslg (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 530 {
 531   guint32 ver_flags = 0, shift = 0;
 532   gint32 least_offset = 0, start_time = 0, end_time = 0;
 533 
 534   if (!gst_byte_reader_get_uint32_be (data, &amp;ver_flags) ||
 535       !gst_byte_reader_get_uint32_be (data, &amp;shift) ||
 536       !gst_byte_reader_get_int32_be (data, &amp;least_offset) ||
 537       !gst_byte_reader_get_int32_be (data, &amp;start_time) ||
 538       !gst_byte_reader_get_int32_be (data, &amp;end_time))
 539     return FALSE;
 540 
 541   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, ver_flags);
 542   GST_LOG (&quot;%*s  shift:         %u&quot;, depth, &quot;&quot;, shift);
 543   GST_LOG (&quot;%*s  least offset:  %d&quot;, depth, &quot;&quot;, least_offset);
 544   GST_LOG (&quot;%*s  start time:    %d&quot;, depth, &quot;&quot;, start_time);
 545   GST_LOG (&quot;%*s  end time:      %d&quot;, depth, &quot;&quot;, end_time);
 546 
 547   return TRUE;
 548 }
 549 
 550 gboolean
 551 qtdemux_dump_co64 (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 552 {
 553   guint32 ver_flags = 0, num_entries = 0, i;
 554 
 555   if (!gst_byte_reader_get_uint32_be (data, &amp;ver_flags) ||
 556       !gst_byte_reader_get_uint32_be (data, &amp;num_entries))
 557     return FALSE;
 558 
 559   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, ver_flags);
 560   GST_LOG (&quot;%*s  n entries:     %d&quot;, depth, &quot;&quot;, num_entries);
 561 
 562   if (!qt_atom_parser_has_chunks (data, num_entries, 8))
 563     return FALSE;
 564 
 565   for (i = 0; i &lt; num_entries; i++) {
 566     GST_LOG (&quot;%*s    chunk offset:  %&quot; G_GUINT64_FORMAT, depth, &quot;&quot;,
 567         GET_UINT64 (data));
 568   }
 569   return TRUE;
 570 }
 571 
 572 gboolean
 573 qtdemux_dump_dcom (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 574 {
 575   if (!qt_atom_parser_has_remaining (data, 4))
 576     return FALSE;
 577 
 578   GST_LOG (&quot;%*s  compression type: %&quot; GST_FOURCC_FORMAT, depth, &quot;&quot;,
 579       GST_FOURCC_ARGS (GET_FOURCC (data)));
 580   return TRUE;
 581 }
 582 
 583 gboolean
 584 qtdemux_dump_cmvd (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 585 {
 586   if (!qt_atom_parser_has_remaining (data, 4))
 587     return FALSE;
 588 
 589   GST_LOG (&quot;%*s  length: %d&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 590   return TRUE;
 591 }
 592 
 593 gboolean
 594 qtdemux_dump_mfro (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 595 {
 596   if (!qt_atom_parser_has_remaining (data, 4))
 597     return FALSE;
 598 
 599   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 600   GST_LOG (&quot;%*s  size: %d&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 601   return TRUE;
 602 }
 603 
 604 gboolean
 605 qtdemux_dump_mfhd (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 606 {
 607   if (!qt_atom_parser_has_remaining (data, 4))
 608     return FALSE;
 609 
 610   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 611   GST_LOG (&quot;%*s  sequence_number: %d&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 612   return TRUE;
 613 }
 614 
 615 gboolean
 616 qtdemux_dump_tfra (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 617 {
 618   guint64 time = 0, moof_offset = 0;
 619   guint32 len = 0, num_entries = 0, ver_flags = 0, track_id = 0, i;
 620   guint value_size, traf_size, trun_size, sample_size;
 621 
 622   if (!gst_byte_reader_get_uint32_be (data, &amp;ver_flags))
 623     return FALSE;
 624 
 625   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, ver_flags);
 626 
 627   if (!gst_byte_reader_get_uint32_be (data, &amp;track_id) ||
 628       !gst_byte_reader_get_uint32_be (data, &amp;len) ||
 629       !gst_byte_reader_get_uint32_be (data, &amp;num_entries))
 630     return FALSE;
 631 
 632   GST_LOG (&quot;%*s  track ID:      %u&quot;, depth, &quot;&quot;, track_id);
 633   GST_LOG (&quot;%*s  length:        0x%x&quot;, depth, &quot;&quot;, len);
 634   GST_LOG (&quot;%*s  n entries:     %u&quot;, depth, &quot;&quot;, num_entries);
 635 
 636   value_size = ((ver_flags &gt;&gt; 24) == 1) ? sizeof (guint64) : sizeof (guint32);
 637   sample_size = (len &amp; 3) + 1;
 638   trun_size = ((len &amp; 12) &gt;&gt; 2) + 1;
 639   traf_size = ((len &amp; 48) &gt;&gt; 4) + 1;
 640 
 641   if (!qt_atom_parser_has_chunks (data, num_entries,
 642           value_size + value_size + traf_size + trun_size + sample_size))
 643     return FALSE;
 644 
 645   for (i = 0; i &lt; num_entries; i++) {
 646     qt_atom_parser_get_offset (data, value_size, &amp;time);
 647     qt_atom_parser_get_offset (data, value_size, &amp;moof_offset);
 648     GST_LOG (&quot;%*s    time:          %&quot; G_GUINT64_FORMAT, depth, &quot;&quot;, time);
 649     GST_LOG (&quot;%*s    moof_offset:   %&quot; G_GUINT64_FORMAT,
 650         depth, &quot;&quot;, moof_offset);
 651     GST_LOG (&quot;%*s    traf_number:   %u&quot;, depth, &quot;&quot;,
 652         qt_atom_parser_get_uint_with_size_unchecked (data, traf_size));
 653     GST_LOG (&quot;%*s    trun_number:   %u&quot;, depth, &quot;&quot;,
 654         qt_atom_parser_get_uint_with_size_unchecked (data, trun_size));
 655     GST_LOG (&quot;%*s    sample_number: %u&quot;, depth, &quot;&quot;,
 656         qt_atom_parser_get_uint_with_size_unchecked (data, sample_size));
 657   }
 658 
 659   return TRUE;
 660 }
 661 
 662 gboolean
 663 qtdemux_dump_tfhd (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 664 {
 665   guint32 flags = 0, n = 0, track_id = 0;
 666   guint64 base_data_offset = 0;
 667 
 668   if (!gst_byte_reader_skip (data, 1) ||
 669       !gst_byte_reader_get_uint24_be (data, &amp;flags))
 670     return FALSE;
 671   GST_LOG (&quot;%*s  flags: %08x&quot;, depth, &quot;&quot;, flags);
 672 
 673   if (!gst_byte_reader_get_uint32_be (data, &amp;track_id))
 674     return FALSE;
 675   GST_LOG (&quot;%*s  track_id: %u&quot;, depth, &quot;&quot;, track_id);
 676 
 677   if (flags &amp; TF_BASE_DATA_OFFSET) {
 678     if (!gst_byte_reader_get_uint64_be (data, &amp;base_data_offset))
 679       return FALSE;
 680     GST_LOG (&quot;%*s    base-data-offset: %&quot; G_GUINT64_FORMAT,
 681         depth, &quot;&quot;, base_data_offset);
 682   }
 683 
 684   if (flags &amp; TF_SAMPLE_DESCRIPTION_INDEX) {
 685     if (!gst_byte_reader_get_uint32_be (data, &amp;n))
 686       return FALSE;
 687     GST_LOG (&quot;%*s    sample-description-index: %u&quot;, depth, &quot;&quot;, n);
 688   }
 689 
 690   if (flags &amp; TF_DEFAULT_SAMPLE_DURATION) {
 691     if (!gst_byte_reader_get_uint32_be (data, &amp;n))
 692       return FALSE;
 693     GST_LOG (&quot;%*s    default-sample-duration:  %u&quot;, depth, &quot;&quot;, n);
 694   }
 695 
 696   if (flags &amp; TF_DEFAULT_SAMPLE_SIZE) {
 697     if (!gst_byte_reader_get_uint32_be (data, &amp;n))
 698       return FALSE;
 699     GST_LOG (&quot;%*s    default-sample-size:  %u&quot;, depth, &quot;&quot;, n);
 700   }
 701 
 702   if (flags &amp; TF_DEFAULT_SAMPLE_FLAGS) {
 703     if (!gst_byte_reader_get_uint32_be (data, &amp;n))
 704       return FALSE;
 705     GST_LOG (&quot;%*s    default-sample-flags:  %u&quot;, depth, &quot;&quot;, n);
 706   }
 707 
 708   GST_LOG (&quot;%*s    duration-is-empty:     %s&quot;, depth, &quot;&quot;,
 709       flags &amp; TF_DURATION_IS_EMPTY ? &quot;yes&quot; : &quot;no&quot;);
 710 
 711   return TRUE;
 712 }
 713 
 714 gboolean
 715 qtdemux_dump_trun (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 716 {
 717   guint32 flags = 0, samples_count = 0, data_offset = 0, first_sample_flags = 0;
 718   guint32 sample_duration = 0, sample_size = 0, sample_flags =
 719       0, composition_time_offsets = 0;
 720   int i = 0;
 721 
 722   if (!gst_byte_reader_skip (data, 1) ||
 723       !gst_byte_reader_get_uint24_be (data, &amp;flags))
 724     return FALSE;
 725 
 726   GST_LOG (&quot;%*s  flags: %08x&quot;, depth, &quot;&quot;, flags);
 727 
 728   if (!gst_byte_reader_get_uint32_be (data, &amp;samples_count))
 729     return FALSE;
 730   GST_LOG (&quot;%*s  samples_count: %u&quot;, depth, &quot;&quot;, samples_count);
 731 
 732   if (flags &amp; TR_DATA_OFFSET) {
 733     if (!gst_byte_reader_get_uint32_be (data, &amp;data_offset))
 734       return FALSE;
 735     GST_LOG (&quot;%*s    data-offset: %u&quot;, depth, &quot;&quot;, data_offset);
 736   }
 737 
 738   if (flags &amp; TR_FIRST_SAMPLE_FLAGS) {
 739     if (!gst_byte_reader_get_uint32_be (data, &amp;first_sample_flags))
 740       return FALSE;
 741     GST_LOG (&quot;%*s    first-sample-flags: %u&quot;, depth, &quot;&quot;, first_sample_flags);
 742   }
 743 
 744   for (i = 0; i &lt; samples_count; i++) {
 745     if (flags &amp; TR_SAMPLE_DURATION) {
 746       if (!gst_byte_reader_get_uint32_be (data, &amp;sample_duration))
 747         return FALSE;
 748       GST_TRACE (&quot;%*s    sample-duration:  %u&quot;, depth, &quot;&quot;, sample_duration);
 749     }
 750 
 751     if (flags &amp; TR_SAMPLE_SIZE) {
 752       if (!gst_byte_reader_get_uint32_be (data, &amp;sample_size))
 753         return FALSE;
 754       GST_TRACE (&quot;%*s    sample-size:  %u&quot;, depth, &quot;&quot;, sample_size);
 755     }
 756 
 757     if (flags &amp; TR_SAMPLE_FLAGS) {
 758       if (!gst_byte_reader_get_uint32_be (data, &amp;sample_flags))
 759         return FALSE;
 760       GST_TRACE (&quot;%*s    sample-flags:  %u&quot;, depth, &quot;&quot;, sample_flags);
 761     }
 762 
 763     if (flags &amp; TR_COMPOSITION_TIME_OFFSETS) {
 764       if (!gst_byte_reader_get_uint32_be (data, &amp;composition_time_offsets))
 765         return FALSE;
 766       GST_TRACE (&quot;%*s    composition_time_offsets:  %u&quot;, depth, &quot;&quot;,
 767           composition_time_offsets);
 768     }
 769   }
 770 
 771   return TRUE;
 772 }
 773 
 774 gboolean
 775 qtdemux_dump_trex (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 776 {
 777   if (!qt_atom_parser_has_remaining (data, 4 + 4 + 4 + 4 + 4 + 4))
 778     return FALSE;
 779 
 780   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 781   GST_LOG (&quot;%*s  track ID:      %08x&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 782   GST_LOG (&quot;%*s  default sample desc. index: %08x&quot;, depth, &quot;&quot;,
 783       GET_UINT32 (data));
 784   GST_LOG (&quot;%*s  default sample duration:    %08x&quot;, depth, &quot;&quot;,
 785       GET_UINT32 (data));
 786   GST_LOG (&quot;%*s  default sample size:        %08x&quot;, depth, &quot;&quot;,
 787       GET_UINT32 (data));
 788   GST_LOG (&quot;%*s  default sample flags:       %08x&quot;, depth, &quot;&quot;,
 789       GET_UINT32 (data));
 790 
 791   return TRUE;
 792 }
 793 
 794 gboolean
 795 qtdemux_dump_mehd (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 796 {
 797   guint32 version = 0;
 798   guint64 fragment_duration;
 799   guint value_size;
 800 
 801   if (!gst_byte_reader_get_uint32_be (data, &amp;version))
 802     return FALSE;
 803 
 804   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, version);
 805 
 806   value_size = ((version &gt;&gt; 24) == 1) ? sizeof (guint64) : sizeof (guint32);
 807   if (qt_atom_parser_get_offset (data, value_size, &amp;fragment_duration)) {
 808     GST_LOG (&quot;%*s  fragment duration: %&quot; G_GUINT64_FORMAT,
 809         depth, &quot;&quot;, fragment_duration);
 810     return TRUE;
 811   }
 812 
 813   return FALSE;
 814 }
 815 
 816 gboolean
 817 qtdemux_dump_tfdt (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 818 {
 819   guint32 version = 0;
 820   guint64 decode_time;
 821   guint value_size;
 822 
 823   if (!gst_byte_reader_get_uint32_be (data, &amp;version))
 824     return FALSE;
 825 
 826   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, version);
 827 
 828   value_size = ((version &gt;&gt; 24) == 1) ? sizeof (guint64) : sizeof (guint32);
 829   if (qt_atom_parser_get_offset (data, value_size, &amp;decode_time)) {
 830     GST_LOG (&quot;%*s  Track fragment decode time: %&quot; G_GUINT64_FORMAT,
 831         depth, &quot;&quot;, decode_time);
 832     return TRUE;
 833   }
 834 
 835   return FALSE;
 836 }
 837 
 838 gboolean
 839 qtdemux_dump_sdtp (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 840 {
 841   guint32 version;
 842   guint8 val;
 843   guint i = 1;
 844 
 845   version = GET_UINT32 (data);
 846   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, version);
 847 
 848   /* the sample_count is specified in the stsz or stz2 box.
 849    * the information for a sample is stored in a single byte,
 850    * so we read until there are no remaining bytes */
 851   while (qt_atom_parser_has_remaining (data, 1)) {
 852     val = GET_UINT8 (data);
 853     GST_LOG (&quot;%*s     sample number: %d&quot;, depth, &quot;&quot;, i);
 854     GST_LOG (&quot;%*s     sample_depends_on: %d&quot;, depth, &quot;&quot;,
 855         ((guint16) (val)) &amp; 0x3);
 856     GST_LOG (&quot;%*s     sample_is_depended_on: %d&quot;, depth, &quot;&quot;,
 857         ((guint16) (val &gt;&gt; 2)) &amp; 0x3);
 858     GST_LOG (&quot;%*s     sample_has_redundancy: %d&quot;, depth, &quot;&quot;,
 859         ((guint16) (val &gt;&gt; 4)) &amp; 0x3);
 860     GST_LOG (&quot;%*s     early display: %d&quot;, depth, &quot;&quot;,
 861         ((guint16) (val &gt;&gt; 6)) &amp; 0x1);
 862     ++i;
 863   }
 864   return TRUE;
 865 }
 866 
 867 gboolean
 868 qtdemux_dump_svmi (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 869 {
 870   guint32 version;
 871   guint stereo_mono_change_count;
 872   guint i;
 873 
 874   version = GET_UINT32 (data);
 875   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, version);
 876 
 877   if (!version) {
 878     /* stereoscopic visual type information */
 879     GST_LOG (&quot;%*s     stereo_composition_type: %d&quot;, depth, &quot;&quot;,
 880         GET_UINT8 (data));
 881     GST_LOG (&quot;%*s     is_left_first: %d&quot;, depth, &quot;&quot;,
 882         ((guint8) GET_UINT8 (data)) &amp; 0x01);
 883 
 884     /* stereo_mono_change information */
 885     stereo_mono_change_count = GET_UINT32 (data);
 886     GST_LOG (&quot;%*s     stereo_mono_change_count: %d&quot;, depth, &quot;&quot;,
 887         stereo_mono_change_count);
 888     for (i = 1; i &lt;= stereo_mono_change_count; i++) {
 889       GST_LOG (&quot;%*s     sample_count: %d&quot;, depth, &quot;&quot;, GET_UINT32 (data));
 890       GST_LOG (&quot;%*s     stereo_flag: %d&quot;, depth, &quot;&quot;,
 891           ((guint8) GET_UINT8 (data)) &amp; 0x01);
 892     }
 893   }
 894   return TRUE;
 895 }
 896 
 897 gboolean
 898 qtdemux_dump_dfLa (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 899 {
 900   const gchar *block_types[] = {
 901     &quot;STREAMINFO&quot;, &quot;PADDING&quot;, &quot;APPLICATION&quot;, &quot;SEEKTABLE&quot;, &quot;VORBIS_COMMENT&quot;,
 902     &quot;CUESHEET&quot;, &quot;PICTURE&quot;, &quot;UNKNOWN&quot;, &quot;INVALID&quot;
 903   };
 904 
 905   guint32 ver_flags, block_header, block_size;
 906   gint8 block_type;
 907   gboolean isLast = FALSE;
 908 
 909   if (!gst_byte_reader_get_uint32_be (data, &amp;ver_flags))
 910     return FALSE;
 911 
 912   GST_LOG (&quot;%*s  version/flags: %08x&quot;, depth, &quot;&quot;, ver_flags);
 913 
 914   do {
 915     if (!gst_byte_reader_get_uint32_be (data, &amp;block_header))
 916       break;
 917 
 918     isLast = (block_header &gt;&gt; 31) &amp; 1;
 919     block_type = (block_header &gt;&gt; 24) &amp; 0x7F;
 920     block_size = block_header &amp; 0xFFFFFF;
 921 
 922     if (block_type == 127)
 923       block_type = 8;
 924     else if (block_type &gt; 6)
 925       block_type = 7;
 926 
 927     GST_LOG (&quot;%*s  block_type:      %s&quot;, depth, &quot;&quot;, block_types[block_type]);
 928     GST_LOG (&quot;%*s  last-block-flag: %s&quot;, depth, &quot;&quot;, isLast ? &quot;true&quot; : &quot;false&quot;);
 929     GST_LOG (&quot;%*s  length:          %d&quot;, depth, &quot;&quot;, block_size);
 930 
 931     if (!gst_byte_reader_skip (data, block_size))
 932       break;
 933   } while (!isLast);
 934 
 935   return TRUE;
 936 }
 937 
 938 gboolean
 939 qtdemux_dump_fLaC (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 940 {
 941   guint16 data_ref_id, n_channels, sample_size;
 942   guint32 sample_rate;
 943 
 944   if (!gst_byte_reader_skip (data, 6) ||
 945       !gst_byte_reader_get_uint16_be (data, &amp;data_ref_id) ||
 946       !gst_byte_reader_skip (data, 8) ||
 947       !gst_byte_reader_get_uint16_be (data, &amp;n_channels) ||
 948       !gst_byte_reader_get_uint16_be (data, &amp;sample_size) ||
 949       !gst_byte_reader_skip (data, 4) ||
 950       !gst_byte_reader_get_uint32_be (data, &amp;sample_rate))
 951     return FALSE;
 952 
 953   GST_LOG (&quot;%*s  data reference: %d&quot;, depth, &quot;&quot;, data_ref_id);
 954   GST_LOG (&quot;%*s  channel count:  %d&quot;, depth, &quot;&quot;, n_channels);
 955   GST_LOG (&quot;%*s  sample size:    %d&quot;, depth, &quot;&quot;, sample_size);
 956   GST_LOG (&quot;%*s  sample rate:    %d&quot;, depth, &quot;&quot;, (sample_rate &gt;&gt; 16));
 957 
 958   return TRUE;
 959 }
 960 
 961 gboolean
 962 qtdemux_dump_gmin (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 963 {
 964   guint32 ver_flags;
 965   guint16 graphics_mode, opc_r, opc_g, opc_b, balance;
 966 
 967   if (!gst_byte_reader_get_uint32_be (data, &amp;ver_flags))
 968     return FALSE;
 969 
 970   GST_LOG (&quot;%*s  version/flags : %08x&quot;, depth, &quot;&quot;, ver_flags);
 971   if (!gst_byte_reader_get_uint16_be (data, &amp;graphics_mode) ||
 972       !gst_byte_reader_get_uint16_be (data, &amp;opc_r) ||
 973       !gst_byte_reader_get_uint16_be (data, &amp;opc_g) ||
 974       !gst_byte_reader_get_uint16_be (data, &amp;opc_b) ||
 975       !gst_byte_reader_get_uint16_be (data, &amp;balance))
 976     return FALSE;
 977 
 978   GST_LOG (&quot;%*s  graphics mode : 0x%x&quot;, depth, &quot;&quot;, graphics_mode);
 979   GST_LOG (&quot;%*s  opcolor :       r:0x%x g:0x%x b:0x%x&quot;, depth, &quot;&quot;, opc_r, opc_g,
 980       opc_b);
 981   GST_LOG (&quot;%*s  balance :       %d&quot;, depth, &quot;&quot;, balance);
 982 
 983   return TRUE;
 984 }
 985 
 986 gboolean
 987 qtdemux_dump_unknown (GstQTDemux * qtdemux, GstByteReader * data, int depth)
 988 {
 989   int len;
 990 
 991   len = gst_byte_reader_get_remaining (data);
 992   GST_LOG (&quot;%*s  length: %d&quot;, depth, &quot;&quot;, len);
 993 
 994   GST_MEMDUMP_OBJECT (qtdemux, &quot;unknown atom data&quot;,
 995       gst_byte_reader_peek_data_unchecked (data), len);
 996   return TRUE;
 997 }
 998 
 999 static gboolean
1000 qtdemux_node_dump_foreach (GNode * node, gpointer qtdemux)
1001 {
1002   GstByteReader parser;
1003   guint8 *buffer = (guint8 *) node-&gt;data;       /* FIXME: move to byte reader */
1004   guint32 node_length;
1005   guint32 fourcc;
1006   const QtNodeType *type;
1007   int depth;
1008 
1009   node_length = GST_READ_UINT32_BE (buffer);
1010   fourcc = GST_READ_UINT32_LE (buffer + 4);
1011 
1012   g_warn_if_fail (node_length &gt;= 8);
1013 
1014   gst_byte_reader_init (&amp;parser, buffer + 8, node_length - 8);
1015 
1016   type = qtdemux_type_get (fourcc);
1017 
1018   depth = (g_node_depth (node) - 1) * 2;
1019   GST_LOG (&quot;%*s&#39;%&quot; GST_FOURCC_FORMAT &quot;&#39;, [%d], %s&quot;,
1020       depth, &quot;&quot;, GST_FOURCC_ARGS (fourcc), node_length, type-&gt;name);
1021 
1022   if (type-&gt;dump) {
1023     gboolean ret;
1024 
1025     ret = type-&gt;dump (GST_QTDEMUX_CAST (qtdemux), &amp;parser, depth);
1026 
1027     if (!ret) {
1028       GST_WARNING (&quot;%*s  not enough data parsing atom %&quot; GST_FOURCC_FORMAT,
1029           depth, &quot;&quot;, GST_FOURCC_ARGS (fourcc));
1030     }
1031   }
1032 
1033   return FALSE;
1034 }
1035 
1036 gboolean
1037 qtdemux_node_dump (GstQTDemux * qtdemux, GNode * node)
1038 {
1039 #ifndef GST_DISABLE_GST_DEBUG
1040   /* Only traverse/dump if we know it will be outputted in the end */
1041   if (qtdemux_debug-&gt;threshold &lt; GST_LEVEL_LOG)
1042     return TRUE;
1043 
1044   g_node_traverse (node, G_PRE_ORDER, G_TRAVERSE_ALL, -1,
1045       qtdemux_node_dump_foreach, qtdemux);
1046 #endif
1047   return TRUE;
1048 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>